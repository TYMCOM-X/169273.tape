.TITLE  TMBOXB   KL10B CORE MEMORY SYSTEM DIAGNOSTIC     VER 1.0
        .NLIST CND,BEX
        .LIST MC,MD,MEB
        DTEASB=1                ;ASSEMBLE DTE20 PARAMETERS.
        DTEDEF=1                
        KWASB=1                 ;ASSEMBLE CLOCK PARAMETERS.
        $MBOX=1                 ;ASSEMBLE MBOX ERROR REPORTS
        $OPSEL=1                ;ALLOW "/COMMANDS" FOR USE BY DIAGNOSTIC
        $DFTBP=1                ;DEFAULT BACKPLANE IS 1 (DMA20/DIA20)
        DEXWDS=.DAT3
        PXCT=XCT                ;PXCT INSTR IS XCT INSTR WITH NON-ZERO AC FIELD
        $CHTST=1                ;ASSEMBLE CHANNEL TEST SUBROUTINES
        ISAME=1                 ;SAME ISOLATION FOR KL10PV & KL10PA
        ESTSIZ=100              ;ALLOW ENOUGH ROOM ON ERROR STACK
        UCODE=156               ;FREEZE MICRO-CODE VERSION
        EPT=3000                ;EXEC PAGE TABLE LOCATION
        .ENABL  ABS,AMA
        .=3000
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION
RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)
PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR
ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE
TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE
INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH
 
;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFINITIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE OCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04              ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
  .NLIST    SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
  .LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-10000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM

.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE

.SBTTL  *MMAC*  MBOX MACRO LIBRARY 26-OCT-76

.REM    %
        KL10 AC DEFINITIONS %
        
        AC0=    000000
        AC1=    000001
        AC2=    000002
        AC3=    000003
        AC4=    000004
        AC5=    000005
        AC6=    000006
        AC7=    000007
        AC10=   000010
        AC11=   000011
        AC12=   000012
        AC13=   000013
        AC14=   000014
        AC15=   000015
        AC16=   000016
        AC17=   000017
.REM    %
        KL10 INSTRUCTION OP CODES
        %
MOVE=   200
MOVEI=  201
MOVEM=  202
ROT=    241
LSH=    242
EXCH=   250
BLT=    251
AOBJN=  253
JRST=   254
XCT=    256
MAP=    257
ADD=    270
ADDI=   271
SUB=    274
SUBI=   275
CAIE=   302
CAIN=   306
CAME=   312
CAMN=   316
JUMPL=  321
JUMPE=  322
JUMPA=  324
JUMPGE= 325
JUMPN=  326
SKIP=   330
SKIPE=  332
AOJE=   342
AOJA=   344
AOS=    350
SOJE=   362
SOJA=   364
SOJGE=  365
SOJG=   367
SETZM=  402
ANDI=   405
XOR=    430
IOR=    434
IORI=   435
SETCAM= 452
SETCM=  460
SETO=   474
SETOM=  476
SETOB=  477
HRLI=   505
HLLZS=  513
HRLZI=  515
HRLOI=  525
HRRI=   541
HRRZI=  551
HRRZM=  552
TRNE=   602
TLNE=   603
TRNN=   606
TLNN=   607
TDNE=   612
TRZ=    620
TLZ=    621
TRZN=   626
TRC=    640
TRCE=   642
TLO=    661
SBDIAG= 70050

.REM    %
        GENERATES A TABLE ENTRY TO IDENTIFY A DIAGNOSTIC
FUNCTION FOR USE BY CMP.S AND S10.
%
.MACRO  DF.     D
.NLIST  SRC
                .BYTE 200!D
.LIST   SRC
.ENDM
.REM    %
        GENERATES TABLE ENTRIES TO IDENTIFY BITS OF DIAGNOSTIC
FUNCTIONS TO BE TESTED BY CMP.S AND S10.  ORDER IS MSB TO LSB.  A NEGATIVE VALUE 
INDICATES THE TABLE END.
%
.MACRO  BP.     B
.IRP    B1,<B>
        B10=^D'B1
F=0
.IF     LT      B10
BX=-B10
F=1
.IFF
BX=B10
.ENDC
B11=^D35-BX
W11=B11/^D16
P11=B11-<W11*^D16>
.NLIST  SRC
                .BYTE <F*100>!<P11*4>!<W11>
.LIST   SRC
.ENDM
.ENDM

;SEQ139

.REM    %
        MACRO TO ENCODE DIAGNOSTIC FUNCTION, BIT NUMBER & FLAVOR
INTO A PDP11 WORD.
%
.MACRO  S10.    A,B,C
.NLIST
        .NARG   XXX
        .IF     EQ <XXX-1>
          .WORD A
        .IFF
        .IF     EQ      C
        BP.     B
        .IFF
        BP.     -B
        .ENDC
        DF.     A
        .ENDC
.LIST
.ENDM   S10.

.REM    %
PDP10 DIAGNOSTIC DATA BIT TEST ROUTINE.  ARGUMENT IS PDP10
BIT NUMBER OF A WORD LOCATED IN THE DTE20 DEXWDS.
%
.MACRO  TBIT    N
BB=^D'N+12.
BBD=BB/16.
BM=1
.REPT <15.-<BB-<16.*BBD>>>
BM=BM+BM
.ENDM
.NLIST  SRC
          MOV   #^D'N,ERBIT
          BIT   #BM,@<.DAT1-<2*BBD>>
.LIST   SRC
.ENDM   TBIT


;SEQ140

.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%

        .MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&8400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        BOO.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   V

        .MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   U


;SEQ141

.MACRO  NUMARG  A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
        .NARG   $$NARG
        .ENDM   NUMARG

.REM    %
        MEM DATA MACRO.  GENERATES A TABLE FOR IDENTIFYING A MEMORY REQUEST.
THE FIRST BYTE IS LEFT JUSTIFIED EXPECTED BIT VALUES FOR RQ0,RQ1,RQ2, RD & WR
REQUESTS.  THE NEXT 3 BYTES ARE THE EXPECTED SBUS ADDRESS.
%
.MACRO  MEMTAB  ADR,LST
        RQ0=200
        RQ1=100
        RQ2=40
        RQ3=20
        RD=10
        WR=4
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE <LOR>   ;REQUEST DATA
        
.LIST   SRC
        WD22    ADR     ;ADDRESS
.ENDM   MEMTAB


;SEQ142

.REM    %
        THIS SECTION CONTAINS A COLLECTION OF MACROS FOR USE IN ISOLATION
ROUTINES OF THE PDP-11 BASED PROCESSOR DIAGNOSTICS.
THIS IS A SCHEME FOR MANAGING BOARD-CALLOUT INFORMATION.  THE
BASIS OF THE SYSTEM IS A FOUR-WORD TABLE WHICH MAY BE MANIPULATED
BY THE USER.  SEVEN BYTES OF THE TABLE ARE A BITWISE MAPPING OF THE
PROCESSOR BACKPLANE.  WHILE THE EIGHTH BYTE INDICATES THE MOST LIKELY
FAILING BOARD OF A GROUP OF BOARDS.  A TYPEOUT ROUTINE IS PROVIDED
WHICH INTERPRETS SUCH A TABLE, PRINTING THE IDENTIFICATION OF
ALL BOARDS FOR WHICH THERE IS A ONE-BIT IN THE TABLE.  THIS TABLE
IS REFERRED TO AS A "UML TABLE", AFTER THE ENGINEERING "UML" OR
UTILIZATION MODULE LIST.  THAT IS THE DOCUMENT WHICH SHOWS WHAT
BOARD GOES WHERE IN THE BACKPLANE.  THE TYPEOUT ROUTINE IS CALLED
"PNTUML".

        THE MACROS PROVIDED PERMIT GENERATING SUCH UML TABLES AT
ASSEMBLY TIME OR, ALTERNATIVELY, CREATING A TABLE DURING THE
RUNNING OF THE ISOLATION ROUTINE, OR A COMBINATION OF ACTIONS.
THE MACROS TAKE SLOT NUMBERS AS ARGUMENTS AND DO ALL THE NECCESSARY
BIT-FIDDLING.

        THE PRINT ROUTINE SCANS THE UML TABLE SUPPLIED AS A CALLING 
ARGUMENT, LOOKING FOR ONE-BITS.  WHEN ONE IS FOUND, ITS POSITION IS
CONVERTED TO A SLOT NUMBER.  THE SLOT NUMBER INDEXES A TABLE WHERE
THE M# FOR THE BOARD BELONGING TO THAT SLOT IS FOUND.  SLOTS
CONTAINING CABLES OR EMPTY SLOTS ARE RECOGNIZED AS SUCH.  THERE ARE UP TO THREE
CALLOUTS PRINTED PER LINE.  A CALLOUT LOOKS LIKE THIS:

        M8523,SLOT 38.

38 IS THE SLOT NUMBER.  M8523 IS, OF COURSE, THE M# OF THE BOARD IN
THAT SLOT.
        IN A MULTI-BOARD CALLOUT, ONE MODULE IS FLAGGED AS THE
MOST LIKELY OR MOST PROBABLE FAILING BOARD:

BACKPLANE: 4.  M8523,SLOT 38.  M8510,SLOT 46.** M8512,SLOT 53.
        **HIGHEST PROBABILITY OF FAILURE

        AS AN EXAMPLE OF THE MACROS, TO PRODUCE THE LATTER TYPEOUT
ONE COULD CREATE A UML TABLE AT ASSEMBLY TIME USING THE "UML" MACRO:

        TABLE1: UML     <46,53,38>

        WHERE THE ARGUMENT IS A LIST OF SLOT NUMBERS FOR THE BOARDS
YOU WANT CALLED OUT, WITH THE MOST LIKELY BOARD FIRST.  THE ORDER
OF THE REMAINING BOARDS IS NOT SIGNIFICANT.  THIS LISTING CONTAINS
AND M#'S INTO SLOTS.


;SEQ143

        NOTE THAT THE BACKPLANE NUMBER DEFAULTS TO 4, THE CPU BACKPLANE.
THIS  DEFAULT MAY BE CHANGED AT ASSEMBLY TIME BY $DFTBP=?, WHERE ? IS
THE NEW DEFAULT.  IT MAY BE CHANGED DYNAMICALLY BY TRAP "BACKPLANE" WITH
THE NEW # IN R0.  IT IS RESET TO THE ASSEMBLY DEFAULT BEFORE THE
ONE TIME INIT.

        TO PRINT, USE THE "PNTUML" MACRO:

        PNTUML  TABLE1

        A TABLE MAY BE BUILT OR MODIFIED DURING THE 
ISOLATION ROUTINE EXECUTION BY USING THE "SSET", "SCLR", AND
"SETUP" MACROS.  THESE MACROS TAKE TWO ARGUMENTS, THE FIRST IS THE
SLOT NUMBER.  THE SECOND IS THE ADDRESS OF THE TABLE.  THE ADDRESS
CAN BE IN THE FORM 'ADDRESS, OR '(RN)' IF THE ADDRESS IS
IN A REGISTER.
A BELOW IS A SUMMARY OF THEIR ACTIONS:


        SSET    SS,1    ;SET THE FLAG FOR SLOT SS IN TABLE T
        SCLR    SS,T    ;CLEAR (DITTO)
        SETHP   SS,T    ;MAKE THE BOARD IN SLOT SS, THE MOST
                        ;PROBABLE FAILURE IN TABLE T.

        NOTE:  WHEN A SLOT'S FLAG IS SET, PNTUML WILL PRINT THE
        BOARD IDENTIFIER FOR THAT SLOT.
        SETHP STORES THE SLOT NUMBER IN BYTE 1+6
        WHERE IT IS USED BY THE TYPEOUT ROUTINE TO FLAG THE HIGH 
        PROBABILITY BOARD.


        FOR COMPLETENESS, A MACRO IS PROVIDED FOR TESTING A SLOT'S FLAG BIT
        IN A UML TABLE:

        STST    SS,T    ;DOES A BIT TEST OF THE FLAG BIT FOR SLOT
                        ;SS IN TABLE T.

        FINALLY, A MACRO IS PROVIDED TO DYNAMICALLY SET THE BACKPLANE NUMBER.
THE MACRO IS "BACKPLANE" (TRUNCATED TO BACKPL) AND IS USED AS
FOLLOWS:
        BACKPL  X
        NXTINSTR

        IF X (THE NEW BACKPLANE) ISN'T GIVEN, IT IS ASSUMED ALREADY
LOADED IN THE RHE OF R0.
%

;SEQ144

.SBTTL          UTILIZATION MODULE LISTS
.REM    %
SLOT    BOARD   DESCRIPTION     (BACKPLANE 01, DMA/DIA)
-----------------------------------------------------------------
01      CABLE   SBUS    CABLE
02      M8563   DMA20   CONTROL
03      M8560   DMA20   SBUS    INTERFACE
04      M8558   DMA20   KBUS    0 ADAPTER, BITS 0-17 & PAR
05      M8558   DMA20   KBUS    0 ADAPTER, BITS 18-35
06      M8558   DMA20   KBUS    1 ADAPTER, BITS 0-17 & PAR
07      M8558   DMA20   KBUS    1 ADAPTER, BITS 18-35
08      M8558   DMA20   KBUS    2 ADAPTER, BITS 0-17 & PAR
09      M8558   DMA20   KBUS    2 ADAPTER, BITS 18-35
10      M8558   DMA20   KBUS    3 ADAPTER, BITS 0-17 & PAR
11      M8558   DMA20   KBUS    3 ADAPTER, BITS 18-35
12      SPARE
13      M8550   DIA20   DATA PATH
14      M8550   DIA20   DATA PATH
15      M8551   DIA20   CONTROL
16      CABLE   EBUS CABLE

SLOT    BOARD   DESCRIPTION     (BACKPLANE 02, DTE20/RH20)
-----------------------------------------------------------------
01      CABLE   EBUS CABLE
02      M8559   CDS
03      M8554   DTE20 UNIBUS BR & NPR CONTROL
04      M8553   DTE20 CONTROL
05      M8552   DTE20 DATA PATH
06      SPARE
07      SPARE
08      SPARE
09      SPARE
10      CABLE   EBUS CABLE

NOTE THAT MA20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MA20)
-------------------------------------------------------------------

01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8562   "MAT" TIMING (MA20 0,2)
02      G235    X-Y DRIVER
03      H217B   CORE STACK      >SM 0,0-17
        
04      G114    SENSE-INHIBIT   /
05      G235    X-Y DRIVER      \
06      H217B   CORE STACK      >SM 1, 0-17
07      G114    SENSE-INHIBIT   /
08      G235    X-Y DRIVER      \
09      H217B   CORE STACK      >SM 2, 0-17
10      G114    SENSE-INHIBIT   /
11      G235    X-Y DRIVER      \
12      H217B   CORE STACK      >SM 3, 0-17
13      G114    SENSE-INHIBIT   /


;SEQ145

14      G235    X-Y DRIVER      \
15      H217B   CORE STACK      >SM 0, 18-PAR
16      G114    SENSE-INHIBIT   /
17      G235    X-Y DRIVER      \
18      H217B   CORE STACK      >SM 1, 18-PAR
19      G114    SENSE-INHIBIT   /
20      G235    X-Y DRIVER      \
21      H217B   CORE STACK      >SM 2, 18-PAR
22      G114    SENSE-INHIBIT   /
23      G235    X-Y DRIVER      \
24      H217B   CORE STACK      >SM 3, 18-PAR
25      G114    SENSE-INHIBIT   /
26      M8561   CONTROL "MAC"   (MA20 0,2)
27      SPARE
28      SPARE
29      M8561   CCONTROL "MAC"  (MA20 1,3)
30      G235    X-Y DRIVER      \
31      H217B   CORE STACK      >SM 0, 0-17
32      G114    SENSE-INHIBIT   /
33      G235    X-Y DRIVER      \
34      H217B   CORE STACK      >SM 1, 0-17
35      G114    SENSE-INHIBIT   /
36      G235    X-Y DRIVER      \
37      H217B   CORE STACK      >SM 2, 0-17
38      G114    SENSE-INHIBIT   /
39      G235    X-Y DRIVER      \
40      H217B   CORE STACK      >SM 3, 0-17
41      G114    SENSE-INHIBIT   /
42      G235    X-Y DRIVER      \
43      H217B   CORE STACK      >SM 0, 18-PAR
44      G114    SENSE-INHIBIT   /
45      G235    X-Y DRIVER      \
46      H217B   CORE STACK      >SM 1, 18-PAR
47      G114    SENSE-INHIBIT   /
48      G235    X-Y DRIVER      \
49      H217B   CORE STACK      >SM 2, 18-PAR
50      G114    SENSE-INHIBIT   /
51      G235    X-Y DRIVER      \
52      H217B   CORE STACK      >SM 3, 18-PAR
53      G114    SENSE-INHIBIT   /
54      AB      M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8562   "MAT" TIMING (MA20 1,3)

NOTE THAT MB20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MB20)
------------------------------------------------------------------------
01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8565   "MAT" TIMING (MB20 0,2)
02      G236    X-Y DRIVER
03      H224B   CORE STACK      >SM 0, 0-17


;SEQ146

04      G116    SENSE-INHIBIT   /
05      G236    X-Y DRIVER      \
06      H224B   CORE STACK      >SM 1, 0-17
07      G116    SENSE-INHIBIT   /
08      G236    X-Y DRIVER      \
09      H224B   CORE STACK      >SM 2, 0-17
10      G116    SENSE-INHIBIT   /
11      G236    X-Y DRIVER      \
12      H224B   CORE STACK      >SM 3, 0-17
13      G116    SENSE-INHIBIT   /
14      G236    X-Y DRIVER      \
15      H224B   CORE STACK      >SM 0, 18-PAR
16      G116    SENSE-INHIBIT   /
17      G236    X-Y DRIVER      \
18      H224B   CORE STACK      >SM 1, 18-PAR
19      G116    SENSE-INHIBIT   /
20      G236    X-Y DRIVER      \
21      H224B   CORE STACK      >SM 2, 18-PAR
22      G116    SENSE-INHIBIT   /
23      G236    X-Y DRIVER      \
24      H224B   CORE STACK      >SM 3, 18-PAR
25      G116    SENSE-INHIBIT   /
26      M8568   CONTROL "MAC" (MB20 0,2)
27      SPARE
28      SPARE
29      M8568   CONTROL "MAC" (MB20 1,3)
30      G236    X-Y DRIVER      \
31      H224B   CORE STACK      >SM 0, 0-17
32      G116    SENSE-INHIBIT   /
33      G236    X-Y DRIVER      \
34      H224B   CORE STACK      >SM 1, 0-17
35      G116    SENSE-INHIBIT   /
36      G236    X-Y DRIVER      \
37      H224B   CORE STACK      >SM 2, 0-17
38      G116    SENSE-INHIBIT   /
39      G236    X-Y DRIVER      \
40      H224B   CORE STACK      >SM 3, 0-17
41      G116    SENSE-INHIBIT   /
42      G236    X-Y DRIVER      \
43      H224B   CORE STACK      >SM 0, 18-PAR
44      G116    SENSE-INHIBIT   /
45      G236    X-Y DRIVER      \
46      H224B   CORE STACK      >SM 1, 18-PAR
47      G116    SENSE-INHIBIT   /
48      G236    X-Y DRIVER      /
49      H224B   CORE STACK      >SM 2, 18-PAR
50      G116    SENSE-INHIBIT
51      G236    X-Y DRIVER      \
52      H224B   CORE STACK      >SM 3, 18-PAR
53      G116    SENSE-INHIBIT   /
54 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8565   "MAT" TIMING (MB20 1,3)
%



;SEQ147


.REM    %
SLOT    BOARD   DESCRIPTION             (BACKPLANE 04, CPU)
-------------------------------------------------------------------------
01      CABLE   E AND C BUS CABLE
02      CABLE   S0 BUS CABLE
03      CABLE   S1 BUS CABLE
04      M8516   E AND C BUS TRANS, 24-35
05      M8516   E AND C BUS TRANS, 12-23
06      M8516   E AND C BUS TRANS, 00-11
07      M8519   S BUS TRANS
08      M8519   S BUS TRANS
09      M8533   CH
10      M8535   CRC
11      M8536   CCL
12      M8534   CCW
13      SPARE
14      M8517   MB; 12-17, 30-35
15      M8517   MB; 06-11, 24-29
16      M8517   MB; 00-05, 18-23
17      M8521   CHD, 27-35
18      SPARE
19      M8521   CHD, 18-26
20      M8537   MBZ
21      M8529YA MBX
22      M8531YA MBC
23      M8513YA CSH
24      M8521   CHD, 09-17
25      M8521   CHD, 00-08
26      SPARE
27      M8514   CHA
28      M8515   CHX
29      M8518YA PMA
30      M8520YA PAG
31      M8532   PI
32      M8526   CLK
33      M8538   MTR
34      M8545   APR
35      M8525   CON
36      M8543   CTL
37      SPARE
38      M8542   VMA
39      M8512   EDP, 30-35
40      M8548   CRM
41      M8512   EDP, 24-29
42      M8548   CRM
43      M8512   EDP, 18-23
44      M8548   CRM
45      M8541   CRA
46      M8540   SH
47      M8544   MCL
48      M8522   IR
49      M8512   EDP, 12-17
50      M8548   CRM
51      M8512   EDP, 06-11

;SEQ148

52      M8548   CRM
53      M8512   EDP, 00-05
54      M8524   SCD
%


.REM    \
        BIT-SETTING MACRO USED TO TURN ON THE FLAG BIT TO
CAUSE PRINTING OF THE MODULE TYPE AND SLOT.
TO USE:
        SSET    SLOT#,TABLE
        TABLE IS THE ADDRESS OF A FOUR-WORD UML TABLE, AND
        SLOT# IS THE SLOT NUMBER, 1-54, OF THE DESIRED BOARD.
\
        .MACRO  SSET    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIS   #B,WW+T ;SET BIT FOR SLOT SS
        .IFT
          BIS   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SSET

.REM    \
        MACRO FOR SETTING THE BACKPLANE NUMBER FOR PNTUML.
        \
.MACRO  BACKPL  .B      
        .IIF    NB,.B,  MOV     #.B,R0  ;THE NEW BACKPLANE # IS .8
        .IIF    DF,TRAPS,       TRAP 115
        .IIF    NDF,TRAPS,      JSR     R5,BACKPL
        .ENDM   BACKPL

;SEQ149

.REM    \
        BIT-CLEARING MACRO TO REMOVE A BOARD'S PRESENCE FROM A
UML TABLE.  THE ACTION IS COMPLEMENTARY TO THE SSET MACRO.
        TO USE:
                SCLR    SLOT#,TABLE
        \
        .MACRO  SCLR    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIC   #B,WW+T                 ;CLR BIT FOR SLOT SS
        .IFT
          BIC   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SCLR


.REM    \
        BIT TEST MACRO WHICH ADDRESSES A SLOT BIT IN THE
        UML TABLE OF CONCERN.  TO USE:

                STST    SLOT#,TABLE     
        BXX                     ;YOUR CHOICE OF BRANCH HERE
        \
        .MACRO  STST    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIT   #B,WW+T         ;TEST BIT FOR SLOT SS
        .IFT
          BIT   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   STST


;SEQ150

.REM    \
        MACRO FOR BUILDING AN INITIAL OR CONSTANT UML TABLE.
        TO USE:

        LABEL:  UML     <S1,S2,...SN>
                WHERE S1,S2 ETC., ARE THE SLOT NUMBERS OF ALL THE 
                BOARDS YOU WANT THIS TABLE TO POINT TO.
                THE ANGLE BRACKETS ARE REQUIRED IF MORE THAN ONE
                SLOT IS LISTED.
        A FOUR-WORD TABLE IS GENERATED CONTAINING 1'S MAPPED INTO
        THE BITS REPRESENTING THE SLOTS IN THE ARGUMENT.
        LIST.
        THE BYTE IN BITS 0-7 OF THE FOURTH WORD IS USED
        TO HOLD THE SLOT NUMBER OF THE FIRST ARGUMENT IN THE
        ARGUMENT LIST, IF THERE WAS MORE THAN ONE ARGUMENT.  THIS
        BYTE IDENTIFIES THE HIGHEST PROBABILITY BOARD TO THE
        TYPEOUT ROUTINE.
        \
        .MACRO  UML     SSS
                T=0
                W1=0
                W2=0
                W3=0
                W4=0
                HP=0
                .IRP    SS,<SSS>
                .IF     EQ,HP
                        .NARG   A
                        .IIF GT,<A-1>,HP=^D'SS
                .ENDC
                SLOT.   SS,T
                .IIF EQ,WW,     W1=W1!B
                .IIF EQ,<WW-2>, W2=W2!B
                .IIF EQ,<WW-4>, W3=W3!B
                .IIF EQ,<WW-6>, W4=W4!B
                .ENDM
                .NLIST  SRC
        .WORD   W1,W2,W3
        .WORD   W4!HP
                .LIST   SRC
        .ENDM   UML


;SEQ151

.REM    \
        MACRO SUBRTOUTINE TO CONVERT A SLOT NUMBER INTO A WORD
        AND BIT NUMBER FOR USE BY OTHER MACROS.
        \
        .MACRO  SLOT.   SS,T
                S=^D'SS
                .IIF GT,<S-54.>,.ERROR          ;SLOT NUMBER TOO BIG
                .IIF LE,S,.ERROR                ;NEGATIVE SLOT NUMBER
                W=S/16.
                .IIF B,T,WW=2*W
                .IIF NB,T,WW=2*W+T
                B=1
                .REPT   16.*W+15.-S
                B=B+B
                .ENDM
        .ENDM   SLOT.

.REM    \
        MACRO TO ALTER THE MOST LIKELY BOARD ENTRY OF A UML TABLE.
        GENERATES A MOVB INSTRUCTION.
        \
        .MACRO  SETHP   SS,T
        .NLIST  SRC
        .NTYPE  ZZZ,T
        .IF     EQ,<ZZZ&70-10>
        .IFF
          MOVB  #^D'SS,T+6
        .IFT
           MOVB #^D'SS,6'T
        .ENDC
        .LIST   SRC
        .ENDM   SETHP


;SEQ152

.SBTTL          SUBROUTINE CALLERS
.REM    \
        MACROS FOR CALLS TO REGISTER SAVE & RESTORE
ROUTINES
\

        ;SAVE   R3-R5

.MACRO  SAV.3
        
.IIF    NDF,TRTAPS      JSR     R5,SAV.3        ;SAVE R3-R5
.IIF    DF,TRAPS,        TRAP    4              ;SAVE R3-R5
.ENDM

        ;RESTORE R3-R5

.MACRO  RST.3
.IIF    NDF,TRAPS,      JSR     R5,RST.3        ;RESTORE R3-R5
.IIF    DF,TRAPS,       TRAP    5               ;RESTORE R3-R5
.ENDM

        ;SAVE R1-R5

.MACRO  SAV.5
.IIF    NDF,TRAPS,      JSR     R5,SAV.5        ;SAVE R1-R5
.IIF    DF,TRAPS,       TRAP    6               ;SAVE R1-R5
.ENDM

        ;RESTORE R1-R5

.MACRO  RST.5
.IIF    NDF,TRAPS,      JSR     R5,RST.5        ;RESTORE R1-R5
.IIF    DF,TRAPS,       TRAP    7               ;RESTORE R1-R5
.ENDM


;SEQ153

.REM    \
        ISOLATION ROUTINE LOAD HEADER PRINT ROUTINE CALLER
\
.MACRO  PNTID
          TRAP 125                              ;PRINT LOAD ID
.ENDM   PNTID

.REM    \
        CALLER TO FIX PROGRAM VERSION
\
.MACRO  GETVER
.IIF    NDF,TRAPS,      JSR     R5,GETVER       ;FIX PROGRAM VERSION
.IIF    DF,TRAPS,       TRAP    126             ;FIX PROGRAM VERSION
.ENDM   GETVER

.REM    \
        CALLER TO PRINT PROGRAM VERSION NUMBER
\
.MACRO  PNTVER
.IIF    NDF,TRAPS,      JSR     R5,PNTVER       ;PRINT VERSION #
.IIF    DF,TRAPS        TRAP    127             ;PRINT VERSION #
.ENDM   PNTVER

.REM    \
        CALLER TO CALIBRATE A TIME DELAY
\
.MACRO  CALTIM
          JSR   R5,CALTIM                       ;CALIBRATE TIME DELAY
.ENDM   CALTIM

.REM    \
        CALLER FOR TIME DELAY.  PARAMETER IS THE NUMBER OF MILLI-
SECONDS TO WAIT.
\
.MACRO  TWAIT   TIME
        $TWAIT=1
.IIF    NB,TIME,        MOV     #TIME,R0        ;# OF MILLISECONDS
.IIF    NDF,TRAPS,      JSR     R5,TWAIT        ;WAIT
.IIF    DF,TRAPS,       TRAP    130             ;WAIT
.ENDM   TWAIT


;SEQ154

.REM    \
        MACRO TO MOVE A CHARACTER STRING FROM ONE LOCATION TO ANOTHER.
        \
.MACRO  MVC     SRC,DST,LEN
        $MVC=1
.IIF    NDF,TRAPS,      JSR     R5,MVC          ;MOVE CHARACTER STRING
.IIF    DF,TRAPS,       TRAP    3               ;MOVE CHARACTER STRING
          .WORD SRC,DST,LEN
.ENDM   MVC

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION & PERFORM A DIAGNOSTIC
READ.
\
.MACRO  FNRD    DIAFN                           ;DO A DIAGNOSTIC READ
        $SDFRD=1
        .IF     NB,DIAFN
        .IFT
          JSR   R5,SDFRD                        ;DIAGNOSTIC READ
          .WORD DIAFN                           ;READ FN
        .IFF
          JSR   R5,SDFRDA                       ;DIAGNOSTIC READ
        .ENDC
.ENDM   FNRD

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION, PERFORM A DIAGNOSTIC
READ AND TEST A BIT IN THE DTE20 DEXWDS.

\
.MACRO  TENBIT  DIAFN,N                         ;DO A READ & TEST A BIT
        $SDFRD=1
        FNRD    DIAFN
        TBIT    N
.ENDM   TENBIT


;SEQ155

.REM    \
        STARTS A KL PROGRAM AT ADDRESS A & WAITS FOR
EITHER A HALT OR A TIMEOUT.  A = STARTING ADDRESS.
\
.MACRO  RUN     A
.IIF    NDF,TRAPS,      JSR     R5,RUNPRG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    10              ;RUN PROGRAM
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUN

.REM    \
        STARTS THE KL RUNNING AND WAITS FOR EITHER A HALT OR
A TIMEOUT.
\
.MACRO  CONTIN
.IIF    NDF,TRAPS,      JSR     R5,CONTIN       ;RUN & CONTINUE
.IIF    DF,TRAPS,       TRAP    11              ;RUN & CONTINUE
.ENDM   CONTIN

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH 
RUNS A LONG PROGRAM.  N IS THE NUMBER OF 30MS INTERVALS
TO WAIT FOR A TIMEOUT
\
.MACRO  RUNBIG  A,N
.IIF    NDF,TRAPS,      JSR     R5,RUNBIG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    12              ;RUN PROGRAM
          .WORD N                               ;# OF 125MS INTERVALS
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUNBIG

.REM    \
        CHANNEL RESET TEST CALLER
\
.MACRO CHRCHK
        $CHRCHK=1
.IIF    NDF,TRAPS,      JSR     R5,CHRCHK       ;CLEAR & TEST CHANNELS
.IIF    DF,TRAPS,       TRAP    117             ;CLEAR & TEST CHANNELS
.ENDM   CHRCHK

.REM    \
        CHANNEL RESET ISOLATION ROUTINE TEST CALLER
\
.MACRO  CHRISO
          TRAP  125                             ;LOAD & GO TO A5 ISOLATOR
.ENDM   CHRISO


;SEQ156

.REM    \
        MACRO TO GENERATE A CALL TO A PROGRAM WHICH LOADS THE C-RAM.
        DAT = POINTER TO DATA BUFFER
        FCAD = FIRST C-RAM ADDRESS TO LOAD (LAST IF LCAD IS BLANK)
        LCAD = LAST C-RAM ADDRESS TO LOAD (IF BOTH FCAD & LCAD NON-BLANK)
\
.MACRO  RAMLOD  DAT,FCAD,LCAD
        $RAMLOD=1
        .IIF    B,FCAD,FCAD=0
        .IF     B,LCAD
        ECAD=FCAD
        FCAD=0
        .IFF
        ECAD=LCAD
        .ENDC
          JSR   R5,RAMLOD                       ;LOAD C-RAM
          .WORD DAT                             ;DATA BUFFER LOCATION
          .WORD FCAD                            ;FIRST C-RAM ADDR
          .WORD ECAD                            ;LAST C-RAM ADR
.ENDM   RAMLOD

.REM    \
        MACRO TO SETUP FOR EXECUTION OF SPECIAL MICRO-CODE.
ARGUMENTS ARE POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE
USED FOR INITIATION OF AN MBOX WRITE. 
\
.MACRO  USTART  ADR,DAT
        $USTART=1
.IIF    NDF,TRAPS,      JSR     R5,USTART       ;SETUP SPECIAL U-CODE
.IIF    DF,TRAPS,       TRAP    33              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USTART

.REM    \
        MACRO TO EXECUTE SPECIAL MICRO-CODE.  ARGUMENTS ARE
POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE USED FOR
INITIATION OF AN MBOX WRITE.

\
.MACRO  USPEC   ADR,DAT
        $USPEC=1
.IIF    NDF,TRAPS,      JSR     R5,USPEC        ;SPECIAL U-CODE LOOPBACK
.IIF    DF,TRAPS,       TRAP    45              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USPEC


;SEQ157

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE 
WHICH RESETS THE KL-10 & MEMORY CONTROLLERS.
\
.MACRO  MEMRST
.IIF    NDF,TRAPS,      JSR     R5,MEMRST       ;RESET MEM CONTROLLERS
.IIF    DF,TRAPS,       TRAP    50              ;RESET MEM CONTROLLERS
.ENDM   MEMRST

.REM    \
        MACRO TO RESET THE MBOX TO A KNOWN STATE.
\
.MACRO  RSTMBX
.IIF    NDF,TRAPS,      JSR     R5,RSTMBX       ;RESET KL
.IIF    DF,TRAPS,       TRAP    51              ;RESET KL
.ENDM   RSTMBX

.REM    \
        MACRO TO INITIALIZE SLIDING BIT PATTERN GENERATOR.
PARAMETER IS THE WIDTH OF THE PATTERNS TO BE GENERATED.
IF LEFT BLANK THE DEFAULT IS 36-BITS.
\

.MACRO  SBINI   WID
        $SBINI=1
        .IIF B,WID,W=36.
        .IIF NB,WID,W=WID
.IIF    NDF,TRAPS,      JSR     R5,SBINI        ;INITIALIZE PATTERN GENERATOR
.IIF    DF,TRAPS,       TRAP    42              ;INITIALIZE PATTERN GENERATOR
          .WORD W                               ;PATTERN WIDTH
.ENDM   SBINI

.REM    \
        MACRO TO RETURN A POINTER TO A SLIDING BIT PATTERN IN R0.
\
.MACRO  SB
        $SB=1
.IIF    NDF,TRAPS,      JSR     R5,SB           ;GET POINTER TO SLIDING BIT
.IIF    DF,TRAPS,       TRAP    43              ;GET POINTER TO SLIDING BIT
.ENDM   SB


;SEQ158

.REM    \
PDP10 LOADER CALL MACRO.  THE FIRST ARGUMENT TELLS THE FIRST
TEN ADDRESS TO LOAD.  0-17 ARE INTERPRETED AS AC'S IN THE CURRENT
AC BLOCK.  ADDRESSES ABOVE 17 ARE PHYSICAL MEMORY.  VALID ADDRESSES
ARE 20-177777.  THE 2ND ADDRESS IS EITHER THE PDP-11 ADDR.
OF A BLOCK OF 5-BYTE TEN CODE - IN WHICH CASE THE THIRD ARGUMENT
TELLS HOW MANY WORDS TO LOAD - OR A LIST OF PDP11 ADDRESSES
CONTAINING 5-BYTE WORDS TO BE LOADED - IN WHICH CASE THE THIRD ARGUMENT
MUST BE OMITTED.  EXAMPLES OF CALL FORMAT
        LOAD    2,ACODE,R       OR
        LOAD    2,<INST1,INST2,INST3,INST4>
\
.MACRO  LOAD    TENAD,A,N
        $LOAD=1
        .NARG   XXX
.IIF    NDF,TRAPS,      JSR     R5,LOAD         ;PROGRAM LOAD
.IIF    DF,TRAPS,       TRAP    37              ;PROGRAM LOAD
          .WORD TENAD
        .IF     EQ <XXX-3>
          .WORD -N
          .WORD A
        .IFF
        XXX=0
        .IRP    XA,<A>
        .IF     EQ XXX
        .NARG XXX
        .IIF EQ <XXX-1>,                        .WORD 1
        .IIF NE <XXX-1>,                        .WORD XXX
        .ENDC
          .WORD XA
        .ENDM
        .ENDC
.ENDM   LOAD

.REM    \
        CALLER  FOR ROUTINE TO EXAMINE AN AC.
\
.MACRO  ACNDR   AC
        $ACNDR=1
        .IF     NB,AC
        .IFT    
          MOV   #AC,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,ACNDR        ;READ AC
.IIF    DF,TRAPS,       TRAP    40              ;READ AC
.ENDM   ACNDR


;SEQ159

.REM    \
        AC MASK SYMBOLS FOR EASING THE USE OF ACLOAD MACRO.
        \
ACC0=000001
ACC1=000002
ACC2=000004
ACC3=000010
ACC4=000020
ACC5=000040
ACC6=000100
ACC7=000200
ACC10=000400
ACC11=001000
ACC12=002000
ACC13=004000
ACC14=010000
ACC15=020000
ACC16=040000
ACC17=100000

.REM    \
        MACRO FOR CALLING ACLOAD & ACSCAT.  TWO FORMATS ARE PERMITTED.
        LOADAC  ACMASK,ADDRESS                  ;CALLS ACLOAD
        LOADAC  ACMASK,<ADR1,ADR2,...,ADRN>     ;CALLS ACSCAT
        \

.MACRO  LOADAC  ACMASK,WDADR
        $LOADAC=1
        NUMARG  WDADR                           ;RETURNS # OF ARGS IN $$NARG
        .IF     GT,$$NARG-1
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,ACSCAT       ;LOAD ACS FROM SCATTERED 11 MEM
.IIF    DF,TRAPS,       TRAP    113             ;LOAD ACS FROM SCATTERED 11 MEM
        .IFF
.IIF    NDF,TRAPS,      JSR     R5,ACLOAD       ;LOAD ACS FROM CONTIGUOUS 11 MEM
.IIF    DF,TRAPS,       TRAP    114             ;LOAD ACS FROM 11 MEM BLOCK
        .ENDC
          .WORD ACMASK                          ;LOAD MASK
          .WORD WDADR                           ;PDP11 MEM ADR(S)
        .ENDM   LOADAC


;SEQ160

.REM    \
        MACRO TO CALL ACBLK:  A SUBROUTINE TO SET THE AC BLOCK.
        \
.MACRO  ACBLK   BN
        $ACBLK=1                                ;AC FORCE ASSEMBLY OF SUBROUTINE
.IIF    NB,BN   MOV     #BN,R0                  ;AC BLOCK NUMBER TO PARAM REG
.IIF    DF,$TRAPS,      TRAP 30                 ;GO SET AC BLOCK NUMBER
.IIF    NDF,$TRAPS,     JSR     R5,ACBLK        ;GO SET AC BLOCK NUMBER
.ENDM   ACBLK

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH
EXECUTES A PDP10 INSTRUCTION POINTED TO BY ARGUMENT A.
        \
.MACRO  XQT     A
        $XQT=1
        .IF     B,A
        .IFF
          MOV   #A,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,XQT          ;DO EXECUTE ROUTINE
.IIF    DF,TRAPS,       TRAP    47              ;DO EXECUTE ROUTINE
.ENDM   XQT

.REM    \
        MACRO TO SETUP EXECUTION OF A TEN INSTRUCTION FOR MSCAN
\
.MACRO  STEXCT  ARG
        $STEXCT=1
        
.IIF    NDF,TRAPS,      JSR     R5,STEXCT               ;START EXECUTION
.IIF    DF,TRAPS,       TRAP    46                      ;START EXECUTION
          .WORD ARG                                     ;POINTER TO INSTRUCTION
.ENDM   STEXCT


;SEQ161

.REM    \
        MACRO PWTES GENERATES A CALL TO A SUBROUTINE WHICH PUTS AN
INVISIBLE PARAM WORD ON THE ERROR STACK.  IF NO PARAM IS GIVEN, IT IS
ASSUMED LOADED ALREADY IN R0.
        \
.MACRO   PWTES   .ARG
$PWTES=1                                                ;FORCE ASSEMBLY OF PWTES SUBROUTINE
.IIF    NB,.ARG,        MOV     .ARG,R0
          JSR   R5,PWTES                                ;MOV INVISIBLE PARAM TO ERROR STACK
.ENDM   PWTES

.REM    \
        MACRO   CHKIT GENERATES A CALL TO A SUBROUTINE WHICH DOES ESSENTIALLY
THE SAME THING AS MASK36 WITH THE ADDITIONAL FEATURE OF BEING ABLE
TO NAME THE DISCREPANCY BITS.  SEE SUBRTN FOR FURTHER INFO.
        \
.MACRO  CHKIT   XPCTD,ACTUAL,MASK,NAMLST
$CHKIT=1                                        ;FORCE ASSEMBLY OF CHKIT SUBROUTINE
        JSR     R5,CHKIT                        ;CHECK ACTUAL VS. XPCTD UNDER MASK
.IIF    NB,MASK,        .WORD MASK,XPCTD,ACTUAL,NAMLST
.IIF    B,MASK, .WORD ZERO..,XPCTD,ACTUAL,NAMLST
.ENDM   CHKIT

.REM    \
        MACROS BLK10,X10,X010,ENDBLK,XRUN,AND XRUNBIG ARE ALL RELATED.  BLK10 AND
ENDBLK ARE USED TO ENABLE THE CALCULATION OF PDP10
SYMBOLIC RELATIVE ADDRESSES.  X10 AND X010 ARE THE SAME AS I10 AND IO10
EXCEPT THAT THEY USE THE RELATIVE ADDRESSES INSTEAD OF THE ABSOLUTE
NUMBERS USED BY THE 'I' MACROS.  X RUN AND XRUNBIG DIFFER FROM RUN AND
RUNBIG IN THAT 1)  THEY TURN ON CACHE, AND 2) THEY ALLOW STARTING AT A
PDP10 REL. ADR.
\

.MACRO  BLK10   TENLOC
$TB=TENLOC                                              ;STARTING LOC OF 10 CODE BLOCK
$EB=.                                                   ;ADR OF 10 CODE BLOCK WITHIN DPD11
        .IIF NDF, RELEASE,.LIST MEB                     ;LIST EXPANSION BINARY SO THAT IT IS AVAILABLE
.ENDM   BLK10

.MACRO  X10     OP,AC,I,Y,X
          I10   OP,AC,I,\Y-$EB/5+$TB,X
.ENDM   X10

.MACRO  XO10    OP,DEV,I,Y,X
          IO10  OP,DEV,I,\Y-$EB/5+$TB,X
.ENDM   XO10


;SEQ162


.MACRO ENDBLK   ACMASK,NOEVEN
$TL=.-$EB/5                     ;NUMBER OF PDP10 WORDS IN THE BLOCK
.IF     NB,ACMASK
ACMASK=0
.REPT   $TL
ACMASK=ACMASK+ACMASK+1
.ENDR
.REPT   $TB
ACMASK=ACMASK+ACMASK
.ENDR
.ENDC
.IIF    B,NOEVEN,       .EVEN
.IIF    NDF,RELEASE,.NLIST MEB
.ENDM   ENDBLK

.MACRO  XRUN    TENADR
$XRUN=1                         ;FORCE ASSEMBLY OF XRUNBIG SUBROUTINE
          JSR   R5,XRUN         ;CALL SUBROUTINE TO START 10
          .WORD TENADR-$EB/5+$TB        ;STARTING ADR FOR 10
.ENDM   XRUN

.MACRO  XRUNBIG TENADR,TIM
$XRUN=1                         ;RUN 10 FOR A LONG TIME
          JSR   R5,XRUNBI       ;RUN 10 FOR A LONG TIME
          .WORD TIM,TENADR-$EB/5+$TB    ;TIME FACTOR, START ADR
.ENDM   XRUNBIG

.REM    \
        MACRO CGOTO DOES A COMPUTED GO-TO BASED ON THE GIVEN PARAM
(0 TO N) OR THE VALUE IN R0 IF NO PARAM GIVEN.  CHECKS THE RANGE OF THE
PARAM VS. THE LENGTH OF THE PARAM LIST.
        \
.MACRO  CGOTO   LST,NDX
$CGOTO=1                        ;FORCE ASSEMBLY OF CGOTO SUBROUTINE
        .IIF    NB,NDX,MOV      NDX,R0  ;MOV LIST INDEX TO R0
          JSR   R5,CGOTO        ;CALL COMPUTED GOTO SUBROUTINE
        NUMARG  LST             ;GET # ARGS IN LIST
          .WORD $$NARG-1,LST
.ENDM   CGOTO

.REM    \
        
        DPV1PG IS USED TO DEPOSIT AND VERIFY EXACTLY 1 KL10 PAGE.  IT
DIFFERS FROM 'LOAD' IN THAT IT DOES 1 PAGE ONLY, ZERO FILLING IF NECESSARY
, AND DOES 2 VERIFIES, ONE AFTER EACH DEPOSIT AND ONCE MORE AFTER
ALL DEPOSITS ARE DONE.  SCATTER LOADING ISN'T SUPPORTED.
        \
.MACRO  DPV1PG  TADR,EADR,NWDS
$DPV1PG=1                                       ;FORCE ASSEMBLY OF DPV1PG SUBROUTINE
          JSR   R5,DPV1PG                       ;DEPOSIT & VERIFY 1 KL10 PAGE
          .WORD TADR,EADR,NWDS
.ENDM   DPV1PG


;SEQ163

.REM    \
CALLER FOR CLOCK CONTROL ROUTINE.  FIRST ARGUMENT IS THE
PDP11 ADDRESS OF A PDP10 INSTRUCTION TO BE EXECUTED WITH
CONTROLLED CLOCKING.  THE SECOND ARGUMENT SPECIFIES HOW
TO DETERMINE THE NUMBER OF CLOCKS.  IF IT IS AN INTEGER,
IT IS USED AS A BURST COUNT.  OTHERWISE IT MAY BE OF THE
FORM <DIAGFCN,BITNBR,FLAVOR> TO SPECIFY THAT THE CLOCK IS
TO BE SINGLE-STEPPED UNTIL BIT "BITNBR" OF DIAGNOSTIC
FUNCTION "DIAGFCN" TRANSITIONS TO "FLAVOR" (0 OR 1).
\

.MACRO  STEP10  INSTR,EPNT
.IIF    NDF,TRAPS,      JSR     R5,STEP10       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    16              ;STEP TO EVENT OR BURST NXT WD POS
          .WORD INSTR                           ;INSTRUCTION TO EXECUTE
        S10.    EPNT
.ENDM   STEP10

.REM    \
        CALLER FOR A ROUTINE WHICH TESTS FOR THE LEADING EDGE OF
AN EVENT.  THE EVENT IS SPECIFIED BY <DIAGFCN,BITNBR,FLAVOR>.
\
.MACRO  EVENT   ARG                     ;GENERATES EVENT CALL
.IIF    NDF,TRAPS       JSR     R5,EVENT        ;EVENT THIS CLOCK?
.IIF    DF,TRAPS,       TRAP    15              ;EVENT THIS CLOCK?
        S10.    ARG
.ENDM   EVENT

.REM    \
CALLER FOR ROUTINE WHICH STEPS THE CLOCK UNTIL AN EVENT 
IS DETECTED.  THE EVENT IS SPECIFIED BY <DIAGFCN, BITNBR, FLAVOR>.
\
.MACRO  FIND    ARG                     ;GENERATES FIND CALL
.IIF    NDF,TRAPS,      JSR     R5,FIND ;STEP TO EVENT
.IIF    DF,TRAPS                TRAP 14 ;STEP TO EVENT
        S10.    ARG
.ENDM   FIND


;SEQ164

.REM    \
        STEP10 CONTINUATION CALL
\
.MACRO  STPCON  EPNT
.IIF    NDF,TRAPS,      JSR     R5,STPCON       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS        TRAP    17              ;STEP TO EVENT OR BURST NXT WD POS
        .WORD   EPNT
.ENDM   STPCON

.REM    \
        MACRO   TO CALL SOBAC.  PARAMS ARE STD FUNC ARGS
\
.MACRO  SOBAC   ARG,CLK
        $SOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,SOBAC        ;STEP TO EVNT OR BURST & CHK EVNT
.IIF    DF,TRAPS,       TRAP    72              ;STWEP TO EVNT OR BRST & CHK EVENT
          .WORD CLK
          S10.  ARG
        .ENDM   SOBAC

.REM    \
        MACRO TO CALL DSOBAC,  PARAM ASSUMED ALREADY LOADED IN R0.
\
.MACRO  DSOBAC
        $DSOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,DSOBAC       ;STEP TO EVNT, OR BRST & CHK EVNT
.IIF    DF,TRAPS        TRAP    73              ;STEP TO EVNT, OR BRST & CHK EVNT
        .ENDM   DSOBAC

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE TO
GENERATE A BURST OF CLOCKS.
\
.MACRO  BRST    K
        $BRST=1
.IIF    NDF,TRAPS       JSR     R5,BRST ;BURST
.IIF    DF,TRAPS,       TRAP    20      ;BURST
          .WORD K                       ;# OF CLOCKS
.ENDM   BRST

;SEQ165

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE
WHICH STEPS THE MBOX CLOCK ONCE.  THIS ROUTINE SUPPORTS
FUNCTION BREAKPOINTS.
\
.MACRO  STEP
.IIF    NDF,TRAPS,      JSR     R5,STEP        ;STEP THE CLOCK
.IIF    DF,TRAPS,       TRAP    13           ;STEP THE CLOCK
.ENDM   STEP


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH SAVES THE VALUES OF RQ0,RQ1,RQ2,RQ3,RD & WR LEFT
JUSTIFIED IN A BYTE, & SAVES THE EBUS REG & SBUS ADR 34 & 35
LOWER 22-BITS IN 3 BYTES.
\
.MACRO  GETMEM
        $GETMEM=1
.IIF    NDF,TRAPS,      JSR     R5,GETMEM       ;GET MEMORY STATUS
.IIF    DF,TRAPS,       TRAP    54              ;GET MEMORY STATUS
.ENDM   GETMEM


.REM    \
        CALLER FOR CLEAR MEMORY ROUTINE.  STARTS AT PDP-10 ADDRESS
20.  ARGUMENT IS UPPER LIMIT POINTER.
\
.MACRO  MEMCLR  ULIM
        $MEMCLR=1
.IIF    NB,ULIM,        MOV     #ULIM,R0        ;POINTER TO UPPER LIMIT
          JSR   R5,MEMCLR                       ;CLEAR 10 MEMORY
.ENDM   MEMCLR


.REM    \
        CALLER FOR SUBROUTINE TO GET & PRINT THE ERA.
\
.MACRO  PNTERA  AC
$PNTERA=1                                       ;FORCE ASSEMBLY OF PNTERA SUBROUTINE
.IF     B,AC
          JSR   R5,GPNTER                       ;GET & PRINT ERA(USING AC0)
.IFF
          JSR   R5,PNTERA                       ;PRINT ERA WORD ALREADY IN AC
          .WORD AC
.ENDC
.ENDM   PNTERA



;SEQ166

.REM    \
        MACRO TO PERFORM AN SBUS DIAG TO A PREVIOUSLY SELECTED
CONTROLLER.
\
.MACRO  SBUSDG  PTR
        $SBUSDG=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0                         ;SBUS VALUE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SBUSDG       ;EXECUTE
.IIF    DF,TRAPS,       TRAP    56              ;EXECUTE SBUS DIAG
.ENDM   SBUSDG

.REM    \
MCRO TO SET ADDRESS BOUNDARIES TO CORRESPOND TO A 22-BIT
ADDRESS.
\
.MACRO  ADRSET  ADR
        $ADRSET=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR R5,ADRSET           ;SET SWITCHES FOR ADR
.IIF    DF,TRAPS,       TRAP    60              ;SET SWITCHES FOR ADR
.ENDM   ADRSET

.REM    \
        MACRO TO PERFORM AN SBUS DIAG LOOPBACK OPERATION FROM
AC15 TO AC17.
\
.MACRO  LOOPAR  ADR
        $LOOPAR=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOOPER       ;SBUS DIAG LOOPBACK
.IIF    DF,TRAPS,       TRAP    57              ;SBUS DIAG LOOPBACK
.ENDM   LOOPAR


;SEQ167


.REM    \
        LOAD A PROGRAM FOR USE IN DETERMINATION OF MEMORY
CONFIGURATION.
\
.MACRO  SBUPRG
        $SBUPRG=1
.IIF    NDF,TRAPS,      JSR     R5,SBUPRG       ;LOAD PROGRAM
.IIF    DF,TRAPS,       TRAP    55              ;LOAD PROGRAM
.ENDM   SBUPRG

.REM    \
        RUN  PROGRAM WHICH DETERMINES & SAVES THE CONFIGURATION 
OF KL MEMORY.
\  
.MACRO  CONDET
        $CONDET=1
          JSR   R5,CONDET                       ;DETERMINE MEM. CONFIG.
.ENDM   CONDET

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
REPORTS THE CONFIGURATION OF PDP-10 MEMORY
\
.MACRO  REPMEM
        $REPMEM=1
          JSR   R5,REPMEM                       ;REPORT DCONFIGURATION
.ENDM   REPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE WHICH PRINTS
A 22-BIT VALUE LEADING ZEROS SUPPRESSED.  PTR = POINTER TO
3 BYTES OF DATA.
\
.MACRO  PNT22S  PTR
        $PNT22S=1
        .IF     NB,PTR
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,PNT225       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    52              ;PRINT ADDRESS
          .WORD PTR                             ;ADDRESS POINTER
        .IFF
.IIF    NDF,TRAPS.      JSR     R5,PNT22A       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    53              ;PRINT ADDRESS
        .ENDC
.ENDM   PNT22S

;SEQ168

.REM    \
        MACRO TO TRANSFER AC17 TO PDP-11 CORE.  CLEARS AC17.
A PUTS 5 BYTES IN A BUFFER POINTED TO BY R0.
\
.MACRO  READ17
        $READ17=1
.IIF    NDF,TRAPS,      JSR     R5,READ17       ;GET AC17
.IIF    DF,TRAPS,       TRAP    44              ;GET AC17
.ENDM   READ17


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS THE STANDARD CACHE REFILL ALGORITHM.
\
.MACRO  CRRSTD
        $CRRSTD=1       
.IIF    NDF,TRAPS,      JSR     R5,CRRSTD       ;STANDARD CACHE REFILL
.IIF    DF,TRAPS,       TRAP    61              ;STANDARD CACHE REFILL
.ENDM   CRRSTD


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS ANY CACHE REFILL ALGORITHM.
\
.MACRO  REFILL  TAB
        $REFILL=1
.IIF    NDF,TRAPS,      JSR     R5,REFILL       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS,       TRAP    62              ;LOAD CACHE REFILL RAM
          .WORD TAB                             ;TABLE POINTER
.ENDM   REFILL


;SEQ169

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH LOADS THE CACHE
REFILL ALGORITHM TO ACCESS ONLY ONE CACHE.  ARG = CACHE.
\
.MACRO  CRRONE  ARG
        $CRRONE=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0                         ;CACHE TO USE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CRRONE       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS        TRAP    63              ;LOAD CACHE REFILL RAM
.ENDM   CRRONE


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH INVALIDATES THE CACHE
\
.MACRO  INVAL
        $INVAL=1
.IIF    NDF,TRAPS       JSR     R5,INVAL                ;INVALIDATE CACHE
.IIF    DF,TRAPS        TRAP    64              ;INVALIDATE CACHE
.ENDM   INVAL


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH VALIDATES CORE.
\
.MACRO  VALCOR
        $VALCOR=1
.IIF    NDF,TRAPS,      JSR     R5,VALCOR               ;VALIDATE CORE
.IIF    DF,TRAPS,       TRAP    65                      ;VALIDATE CORE
.ENDM   VALCOR


;SEQ170

.REM    \
        MACRO FOR CALLS TO COMPARE THE STATE OF SELECTED DIAGNOSTIC
FUNCTION BITS TO A PDP11 WORD OF EXPECTED DATA.
        T = POINTER TO A SPEC. TABLE
        X = REGISTER OR EXPECTED DATA
        M = THE MASK TO BE USED (OPTIONAL)

\
.MACRO  CMP.S   T,X,M
        $CMP.S=1
.NARG   XXX
        .IF     B,X
        .IFT
          XX=0
.IIF    NDF,TRAPS,      JSR     R5,CMPSG.
.IIF    DF,TRAPS,       TRAP    116
          .WORD 0
        .IFF
          XX=X
.NTYPE  ZZZ,X
.IF     LE<ZZZ&70-10>
.IIF    NDF,TRAPS,      JSR     R5,CMPSR.
.IIF    DF,TRAPS        TRAP    2
          MOV   XX,R1
.IFF
.IIF    NDF,TRAPS,      JSR     R5,CMPS.
.IIF    DF,TRAPS,       TRAP    1
          .WORD XX
        .ENDC
        .ENDC

          .WORD T
.IF     B,M
          .WORD 0
.IFF
MM=M
          .WORD 0
          .WORD ^CMM
.ENDC
.ENDM

.REM    \
        CALL TO REPORT PDP10 BIT TEST ERRORS.  CREATES AN ERROR
STACK ENTRY.
\
.MACRO  BITERR
          JSR   R5,BITERR               ;BIT TO ERROR STACK
.ENDM   BITERR


;SEQ171

.REM    \
        MACRO TO LOAD THE ERROR STACK WITH A 5-BYTE PATTERN.
\
.MACRO  PATERR  PTR
        $PATERR=1
        .IF     B,PTR
        .IFF
          MOV   #PTR,R0                 ;PATTERN TO ERROR STACK
        .ENDC
          JSR   R5,PATERR               ;PATTERN TO ERROR STACK
.ENDM   PATERR

.REM    \
MACRO TO PUT A DIAG FN NUMBER ON THE ERROR STACK.
FUNCTION OBTAINED AT LAST FNRD.
\
.MACRO  FRERR
          JSR   R5,FRERR                ;DIAG FN TO ERROR STACK
.ENDM   FRERR

.REM    \
        MACRO TO GENERATE A CALL TO THE PNTUML ROUTINE.
\
.MACRO PNTUML   T
          TRAP  74                      ;PRINT BOARD CALLOUTS
        .IF     NB,T
        .IFT
          .WORD T                       ;UML TABLE POINTER
        .ENDC
.ENDM   PNTUML

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.E ROUTINE
\
.MACRO  CMP.E   S
.IIF    DF,TRAPS,       TRAP    75              ;SCAN THE ERROR STACK
          .WORD S                       ;SPEC TABLE POINTER
.ENDM   CMP.E

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.F ROUTINE
\
.MACRO  CMP.F   S
        $CMP.F=1
.IIF    DF,TRAPS,       TRAP    76              ;SCAN THE ERROR STACK
          .WORD S                               ;SPEC TABLE POINTER
.ENDM   CMP.F


;SEQ172

.REM    \
        MACRO TO CALL THE MBOX MASTER RESET ISOLATION ROUTINE.
\
        .MACRO  ISORST
.IIF    DF,TRAPS,       TRAP    77              ;LOAD & GO TO A4 ISOLATOR
        .ENDM   ISORST
.REM    \
        MACRO TO CALL THE RANGE ROUTINE.
\
        .MACRO  RANGE
        $RANGE=1
.IIF    DF,TRAPS,       TRAP    32              ;DETERMINE FAILING BIT RANGE
        .ENDM   RANGE
.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSK = THE MASK (OPTIONAL)
\
.MACRO  MASK16  EXP,ACT,MSK             ;GENERATES MASK16 CALL
        $MASK16=1
.IIF    NDF,TRAPS,      JSR     R5,MASK16       ;COMPARE
.IIF    DF,TRAPS,.      TRAP    21              ;COMPARE
        .IF     B,MSK
        .IFT
          .WORD 0
        .IFF
          .WORD MSK                     ;MASK
        .ENDC
          .WORD ACT                     ;ACTUAL POINTER
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MASK16

.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED.
R2 = MASK
R3 = ACTUAL DATA
R4 = EXPECTED DATA
\
.MACRO  MSK16R
        $MSK16R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK16R       ;16-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    22              ;16-BIT COMPATE
.ENDM   MSK16R


;SEQ173

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSL = POINTER TO MASK (36-BIT OPTIONAL)
\
.MACRO  MASK36  EXP,ACT,MSK             ;GENERATES MASK36 CALL
        $MASK36=1
.IIF    NDF,TRAPS,      JSR     R5,MASK36  ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    24      ;36-BIT COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK             ;MASK POINTER
        .ENDC
          .WORD EXP             ;EXPECTED POINTER
          .WORD ACT             ;ACTUAL POINTER
.ENDM   MASK36

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL AND EXPECTED DATA.
PARAMETERS PASSED IN REGISTERS.
R2 = MASK POINTER
R3 = EXPECTED POINTER
R4 = ACTUAL POINTER
\
.MACRO  MSK36R
        $MSK36R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK36        ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    23              ;36-BIT COMPARE
.ENDM   MSK36R


;SEQ174

.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM THE DTE-20
TO SOME EXPECTED DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
MSL = POINT TO MASK (36-BIT, OPTIONAL)
\
.MACRO  MSKDAT  EXP,MSK         ;GENERATES MSKDAT CALL
        $MSKDAT=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDAT ;DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    25      ;DTE20 COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDAT


.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  SIMILAR TO MSKDAT EXCEPT
THAT DIAG. FUNCTION IS THE FIRST PARAMETER.
\
.MACRO  MSKDF   DIA,EXP,MSK             ;GENERATES MSKDF CALL
        
        $MSKDF=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDF; DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    26      ;DTE20 COMPARE
          .WORD DIA                     ;DIAGNOSTIC FN
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDF


;SEQ175

.REM    \
        CALLER FOR A ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  PARAMETERS PASSED IN REGS.
R0 = DIAGNOSTIC FUNCTION
R2 = MASK POINTER
R3 = EXPECTED POINTER
\
.MACRO  MSKDFR
        $MSKDFR=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDFR               ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    27              ;36-BIT COMPARE
.ENDM   MSKDFR

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH COMPARES EXPECTED
MEMORY STATUS TO ACTUAL STATUS.
\
.MACRO  CMPMEM  TAB
        $CMPMEM=1
.IIF    NDF,TRAPS,      JSR     R5,CMPMEM               ;COMPARE MEM STATUS
.IIF    DF,TRAPS        TRAP    36              ;COMPARE MEM STATUS
          .WORD TAB                             ;EXPECTED
.ENDM   CMPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE
WHICH COMPARES TWO 3-BYTE (22-BIT) ADDRESSES
VALUES.
\
.MACRO  CMP22   ACT,EXP
        $CMP22=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22        ;3-BYTE COMPARE
.IIF    DF,TRAPS        TRAP    35              ;3-BYTE COMPARE
          .WORD ACT                             ;POINTER TO ACTUAL
          .WORD EXP
.ENDM   CMP22


;SEQ176

.REM    \
        GENERATES A CALL TO  A ROUTINE WHICH COMPARES TWO 3-BYTE VALUES.
PARAMETERS PASSED IN REGISTERS.
R2 = POINTER TO ACTUAL
R3 = POINTER TO EXPECTED
\
.MACRO  CMP22R
        $CMP22R=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22R       ;3-BYTE COMPARE
.IIF    DF,TRAPS,       TRAP    34              ;3-BYTE COMPARE
.ENDM   CMP22R

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE 10 ADDRESS TEST
A MEMORY MODULE.  ARGUMENTS ARE A POINTER TO THE BASE ADDRESS OF
THE MODULE & A NUMBER TO IDENTIFY THE MODULE TYPE.
\
.MACRO  MEMADR  ADR,TYP
        $MEMADR=1
.IIF    NDF,TRAPS,      JSR     R5,MEMADR       ;PERFORM ADDRESS TEST
.IIF    DF,TRAPS,       TRAP    41              ;PERFORM ADDRESS TEST
          .WORD ADR                             ;MODULE BASE ADR POINTER
        .IIF    B,TYP,TYP=0
          .WORD TYP                             ;MODULE TYPE CODE
.ENDM   MEMADR


.REM    \
        MACRO   TO TEST THE MBOX MASTER RESET STATE
\
.MACRO  RSTCHK
        $RSTCHK=1
          JSR   R5,RSTCHK               ;TEST MBOX RESET
.ENDM   RSTCHK

.REM    \
        MACRO TO SET AN MBOX SCANOUT MASK.  PARAMETER IS THE MASK
TABLE POINTER.
\
.MACRO  SETMSK  MTB
        $SETMSK=1
        $MSCAN=1
          JSR   R5,SETMSK               ;SET MBOX SNAPSHOT MASK
          .WORD MTB                     ;MASK TABLE POINTER
.ENDM   SETMSK


;SEQ177

.REM    \
        MBOX/ CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MCSCAN  TAB,CLK
        $CSCAN=1
          JSR   R5,MCSCAN               ;MBOX/ CHANNEL SCANOUT
          .WORD TAB                     ;TABLE POINTER
          .WORD   CLK
.ENDM   MCSCAN

.REM    \
        MBOX SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS OF A
TABLE TO BE COMPARED TO A SNAPSHOT OF MBOX DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MSCAN   TAB,CLK
        $MSCAN=1
          JSR   R5,MSCAN                ;MBOX SCANOUT
          .WORD TAB                     ;TABLE POINTER
          .WORD CLK
.ENDM   MSCAN


.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR MSCAN.
\
.MACRO  MSOTB
          .WORD 0               ;MBOX SCANOUT TABLE
          .BLKW MSIZE-1
.ENDM   MSOTB

.REM    \
        CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF CHANNEL DIAG READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED  BEFORE
THE SCAN.
\
.MACRO  CSCAN   TAB,CLK
        $CSCAN=1
          JSR   R5,CSCAN        ;CHANNEL SCANOUT
          .WORD TAB             ;TABLE POINTER
        S10.    CLK
.ENDM   CSCAN

.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR CSCAN.
\
.MACRO CSOTB
          .WORD 0                       ;CHANNEL SCANOUT TABLE
          .BLKW CSIZE-1
.ENDM   CSOTB


;SEQ178

.SBTTL          SPECIAL EXAMINE & DEPOSIT MACROS 18-AUG-75
.REM    \
        SPECIAL EXAMINE ROUTINE MACRO.  DOES NOT USE THE PI
SYSTEM.  SUPPORTS FUNCTION BREAKPOINTS.
ADR = POINTER TO 18-BIT ADDRESS.
\
.MACRO  SPCEXM  ADR
        $SPCEXM=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCEXM       ;EXAMINE
.IIF    DF,TRAPS,       TRAP    66              ;EXAMINE
.ENDM   SPCEXM

.REM    \
        SPECIAL DEPOSIT ROUTINE CALL.  DOES NOT USE THE PI SYSTEM
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SPCDEP  DTA,ADR
        $SPCDEP=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCDEP       ;DEPOSIT
.IIF    DF,TRAPS,       TRAP    67              ;DEPOSIT
.ENDM   SPCDEP


;SEQ179

.REM    \
        DEPOSIT & VERIFY CALL.  DOES NOT USE THE PI SYSTEM.
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SDPVR   DTA,ADR
        $SDPVR=1
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R0         ;DATA POINTER
        .ENDC
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SDPVR        ;DEPOSIT & VERIFY
.IIF    DF,TRAPS,       TRAP    70              ;DEPOSIT & VERIFY
.ENDM   SDPVR

.REM    \
        TRANSFER A 36-BIT WORD TO AC17.
        PRT = POINTER TO 36-BIT DATA
\
.MACRO  LOAD17  PTR
        $LOAD17=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0         ;DATA POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOAD17       ;LOAD AC17
.IIF    DF,TRAPS,       TRAP    71              ;LOAD AC17
.ENDM   LOAD17



;SEQ180


.SBTTL          CACHE TEST MACROS       25-FEB-76

.REM    \
MACRO TO CALL ROUTINE TO SET THE PC, PUSH RUN AND CONTINUE
SO THAT TEST MAY STEP THRU 10 CODE.
        P IS THE VALUE (0 - 177777)
        \

.MACRO  SETPC   P
        $SETPC=1
.IIF    DF,TRAPS,       TRAP    100     ;ASSIGN
        NDF,TRAPS,      JSR     R5,SETPC
          P
.ENDM   SETPC

.REM    \
CALL A ROUTINE WHICH LOADS THE "CRRONE" AC CODE BUT DOESN'T RUN IT
        ARG IS THE DESIRED 3-BIT REFILL RAM DATA
        \

.MACRO  LDREF1  ARG
        $LDREF1=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0         ;DATA
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LDREF1       ;LOAD REFILL PROGRAM
.IIF    DF,TRAPS,       TRAP    112             ;LOAD REFILL PROGRAM
.ENDM   LDREF1

;CACHE FAULT CALLER.  ARGUMENT IS COMMENT. WORD AFTER "JSR PC,FAULT"
;POINTS TO CACHE NUMBER MESSAGE
.MACRO  FAULTC  ARG
        $FAULTC=1
          JSR   PC,FAULTC
        .IF     B,<ARG>
        .IFT
          .WORD 0
        .IFF
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   FAULTC

;SEQ181

.REM    \
        CALL TO READ REFILL RAM DATA AND ADDRESS
        RETURNS POINTER IN R0
        \

.MACRO  RDRFIL
        $RDRFIL=1               
.IIF    DF,TRAPS,       TRAP    101
.IIF    NDF,TRAPS,      JSR     R5,RDRFIL
.ENDM   RDRFIL
  
.REM    \
LOAD A ONE WORD WRITE, ARGS:  DATA POINTER, 16-BIT PDP-10 ADDRESS.
        \

.MACRO  LDWRIT  DAT,ADR
        $LDWRIT=1
.IIF    DF,TRAPS,       TRAP    102
.IIF    NDG,TRAPS,      JSR     R5,LDWRIT
          DAT
          ADR
.ENDM   LDWRIT

.REM    \
        CALL TO WRITE EVERY FOURTH WORD OF A PAGE IN CACHE.
ARGS:  DATA POINTER, PAGE NBR, WORD NBR (0-3).
        \
.MACRO  CSHWRD  DAT,PAG,WRD
        $CSHWRD=1
.IIF    DF,TRAPS,       TRAP    103
.IIF    NDF,TRAPS,      JSR     R5,CSHWRD
          DAT
          PAG
.IIF    NB,WRD, WRD
.ENDM   CSHWRD
   
;SEQ 182

.REM    \
CALL TO WRITE DISTURB PATTERN TO CACHE
        A IS PHYSICAL PAGE NUMBER
        \

.MACRO  DSTRBC  A
        $DSTRBC=1
          MOV   #A,R0           ;GET PHYSICAL PAGE NUMBER
.IIF    DF,TRAPS,       TRAP    104
.IIF    NDF,TRAPS,      JSR     R5,DSTRBC
.ENDM   DSTRBC

.REM    \
        CALL TO WRITE A DATA WORD ALL OVER ONE PHYSICAL PAGE
        DP IS POINTER TO 36-BIT DATA
        P IS PHYSICAL PAGE NUMBER
        \

.MACRO  CSHPAG  DP,P
        $CSHPAG=1
.IIF    DF,TRAPS,       TRAP    105
.IIF    NDF,TRAPS       JSR     R5,CSHPAG       ;WRITE ONE PAGE
          DP                    ;PTR TO 36-BIT DATA
          P                       ;PHYS PAGE NBR (ADR13-26)
.ENDM   CSHPAG

.REM    \
CALL TO READ CACHE REFILL ADDRESS AND DATA
        \

.MACRO  RDRFL
        RDRFIL
.ENDM   RDRFL

.REM    \
CALL TO READ OLD AND NEW CONTENTS OF REFILL RAM.
REQUIRES SPECIAL AC CODE TO WORK.
\

.MACRO  RRFONW
        $RRFONW=1
.IIF    DF,TRAPS,       TRAP    106
.IIF    NDF,TRAPS,      JSR     R5,RRFONW
.ENDM   RRFONW


;SEQ183

.REM    \
CALL TO WRITE CACHE DIRECTORY PARITY TEST PATTERNS.
DAT IS ADDRESS OF PHYSICAL PAGE PATTERNS (FOUR OF THEM),
FLAG IS 0 TO WRITE NORMAL PARITY, 1 TO WRITE EVEN PARITY.
        \

.MACRO  WRCPAR  DAT,FLAG
        $WRCPAR=1
.IIF    DF,TRAPS,       TRAP    107
.IIF    NDF,TRAPS,      JSR     R5,WRCPAR
          DAT
          FLAG
.ENDM   WRCPAR

.REM    \
        CALL TO RESTORE THE USE OF MEMORY
        \
.MACRO  CMEMEN
        $CMEMEM=1
.IIF    DF,TRAPS,       TRAP    110
.IIF    NDF,TRAPS,      JSR     R5,CMEMEN
.ENDM   CMEMEN

.REM    \
        CALL TO INSERT BASE MEMORY PAGE INTO AN INSTRUCTION
ADDRESS FIELD.  BASE IS ADDED TO ADDRESS POINTED TO BY R0.
        \

.MACRO  INMBAS  B
        $INMBAS=1
.IIF    DF,TRAPS,       TRAP    111
.IIF    NDF,TRAPS,      JSR     R5,INMBAS
          B                                     ;ADDRESS OF PAGE OFFSET
.ENDM   INMBAS


;SEQ184

.REM    \
CALL TO PERFORM A "STEXCT" OF AN INSTRUCTION FOLLOWED BY
A "FIND" OF CLK EBOX REQ AND A CHECK OF EBOX/MBOX INTERFACE
SIGNAL STATES.  FIRST ARG IS INSTRUCTION POINTER, SECOND ARG IS
POINTER TO A THREE-WORD EXPECTED DATA TABLE.
        \

.MACRO  STEREQ  INS,TAB
        $STEREQ=1
.IIF    NDF,TRAPS,      JSR     R5,STEREQ       ;START INSTR & CHECK EBOX REQ'S
.IIF    DF,TRAPS,       TRAP    121             ;START INSTR & CHECK EBOX REQ'S
          .WORD INS                             ;INSTRUCTION POINTER
          .WORD TAB                             ;EXPECTED DATA TABLE POINTER
        .ENDM   STEREQ

.REM    \
CALL TO CHECK EBOX/MBOX INTERFACE SIGNALS.  ARG IS POINTER TO A
3-WORD EXPECTED DATA TABLE.
\

.MACRO  ESNAP   T
        $ESNAP=1
.IIF    NDF,TRAPS,      JSR     R5,ESNAP        ;CHECK EBOX SIGNALS
.IIF    DF,TRAPS,       TRAP    122             ;CHECK EBOX SIGNALS
          .WORD 1                               ;EXPECTED DATA TABLE POINTER
        .ENDM   ESNAP

.REM    \
CALL TO FIND 16K OF MEMORY AND SAVE BASE ADDRESS.  C-BIT IS SET IF NONE
WAS FOUND.  ARG IS ADDRESS OF WHERE BASE IS TO BE STORED.
        \

.MACRO  FNDM16  B
        $FNDM16=1
.IIF    NDF,TRAPS,      JSR     R5,FNDM16       ;FIND 16K OF MEMORY
.IIF    DF,TRAPS,       TRAP    123             ;FIND 16K OF MEMORY
          .WORD B                               ;STORE BASE HERE
        .ENDM   FNDM16

.REM    \
SAVE MEMORY CONFIGURATION CALL.
        \
.MACRO  SAVMCN
        $SAVMCN=1
.IIF    NDF,TRAPS,      JSR     R5,SAVMCN       ;SAVE MEM CONFIGURATION
.IIF    DF,TRAPS        TRAP    124             ;SAVE MEM CONFIGURATION
        .ENDM   SAVMCN



;SEQ185


;SEQ134

.SBTTL          CHANNEL MACRO LIBRARY  02-FEB-76
.REM    \
        CHANNEL COMMAND WORD MACRO.  GENERATES
A CCW FROM THE FOLLOWING ARGUMENTS.
        CCW     OP              ADR,WC,E,R

OP=     CHLT FOR A 0 OP CODE
        CJMP FOR A 1 OP CODE
        CDTA FOR A 2 OP CODE
ADR=    ADDRESS FIELD
        WC=     WORD COUNT (OPTIONAL)
        E=      NONBLANK FOR END BIT
        R=      NONBLANK FOR REVERSE
\
.MACRO  CCW             OP,ADR,WC,END,REV
        CHLT=0
        CJMP=1
        CDTA=2
        .IIF    B,WC,W=0
        .IIF    NB,WC,W=WC
        .IIF    B,REV,R=0
        .IIF    NB,REV,R=1
        .IIF    B,END,E=0
        .IIF    NB,END,E=1
        ADH=0
        ADL=0
        .IRPC   AD,ADR
        .IIF    GE,<ADL-10000>,ADH=<10*ADH>+<ADL/10000>
        ADL=10*<ADL&7777>+AD
        .ENDM
.NLIST  SRC
        .BYTE   <ADL&377>,<<ADL/400>!<ADH*200&377>>,<<ADH/2&77>!<<W&3>*100>>
        .BYTE<<W&1774>/4>,<<<W&2000>/2000>!<R*2>!<E*4>!<OP*4>>
.LIST   SRC
.ENDM   CCW


;SEQ135

.REM    \
        CBUS DATA MACRO.  GENERATES A 36-BIT
OPERAND FOR PERFORMING A DIAGNOSTIC FUNCTION
TO SIMULATE CBUS REQUESTS.
\

.MACRO  CBUS    LST
        RST=200
        ST=100
        DON=20
        CTOM=10
        STR=4
        SLW=2
        FST=1
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE 0,0,<LOR&3>*100
          .BYTE <LOR>/4,0
.LIST   SRC
.ENDM   CBUS
.REM    \
        READ THE CCW CHA ADDRESS REGISTER AND RETURN A POINTER
TO THE 22-BIT VALUE IN R0
\
.MACRO  CCWRD
.IIF    NDF,TRAPS,      JSR     R5,CCWRD                ;GET CCW ADR
.IIF    DF,TRAPS,       TRAP    131             ;GET CCW ADR
.ENDM   CCWRD
.REM    \
        GENERATE A CALL TO SUBROUTINE WHICH GENERATES ENOUGH MBOX
CLOCKS TO PERFORM THE SPCIFIED NUMBER OF MEMORY REFERENCES.
\
.MACRO  MEMREF  N
.IIF    NDF,TRAPS       JSR     R5,MEMREF               ;ENGOUH MBOX CLOCKS
.IIF    DF,TRAPS        TRAP    147             ;ENOUGH MBOX CLOCKS
          .WORD N                       ;FOR THIS MANY MEM REFS
.ENDM   MEMREF


;SEQ136

.REM    \
        STOP CHANNEKL TIMING
\
.MACRO  STOPCH
.IIF    NDF,TRAPS,      JSR     R5,STOPCH               ;STOP CHANNEL TIMING
.IIF    DF,TRAPS        TRAP    142     ;STOP CHANNEL TIMING
.ENDM   STOPCH
.REM\
        RESTART CHANNEL TIMING
\
.MACRO  STARCH
.IIF    NDF,TRAPS,      JSR     R5,STARCH       ;RESTART CHANNEL TIMING
        
.IIF    DF,TRAPS,       TRAP    143             ;RESTART CHANNEL TIMING
.ENDM   STARCH
.REM    \
        SYNCHRONIZE MBOX WITH CHANNEL TIMING & RESTART CHANNEL
TIMING
\
.MACRO  CHSYNC
.IIF    NDF,TRAPS,      JSR     R5,CHSYNC               ;SYNC MBOX & RESTART CHANS
.IIF    DF,TRAPS,       TRAP    144     ;SYNC MBOX & RESTART CHANS
.ENDM   CHSYNC
.REM    \
        DO A CHANNEL READ
\
.MACRO  MEMRD
.IIF    NDF,TRAPS,      JSR     R5,MEMRD                ;DO CHAN READ
.IIF    DF,TRAPS,       TRAP    145     ;DO CHAN READ
.ENDM   MEMRD
.REM    \
        DO A CHANNEL WRITE
\
.MACRO  MEMWR
.IIF    NDF,TRAPS,      JSR     R5,MEMWR                ;DO CHAN WRITE
.IIF    DF,TRAPS        TRAP    146             ;DO CHAN WRITE
.ENDM   MEMWR


;SEQ137

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH PERFORMS THE
SETUP OF A COMMAND WORD AT EPT+3000+(4*CH).
\
.MACRO  SETEPT  CH,DTA
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL
        .ENDC
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R1         ;COMMAND WORD POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SETEPT               ;CONDITION EPT
.IIF    DF,TRAPS,       TRAP    132     ;CONDITION EPT
.ENDM   SETEPT
.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH GETS
TO A POINT WHERE THE CBUS SELECT FOR A SPECIFIC 
CHANNEL IS TRUE.
\
.MACRO  CHSEL   CH
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL #
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CHSEL                ;GET TO CBUS SELECT
.IIF    DF,TRAPS,       TRAP    1133            ;GET TO CBUS SELECT
.ENDM   CHSEL
.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
SIMULATES A CBUS COMMAND FOR A CHANNEL.
\
.MACRO  SIMBUS  CH,COM
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL #
        .ENDC
        .IF     NB,COM
        .IFT
          MOV   #COM,R1 ;COMMAND POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SIMBUS       ;SIMULATE
.IIF    DF,TRAPS,       TRAP    134             ;SIMULATE COMMAND
.ENDM   SIMBUS


;SEQ138

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH TESTS FOR THE
OCCURENCE OF A MEMORY REFERENCE.  STEPS THE CLOCK ONCE.
\
.MACRO  MEMTST
.IIF    NDF,TRAPS,      JSR     R5,MEMTST       ;MEMREF?
.IIF    DF,TRAPS        TRAP    135             ;MEM REF?
.ENDM   MEMTST
.REM    \
        MACRO TO ASK FOR AND GET A CHANNEL #.
\
.MACRO  TTICH
.IIF    NDF,TRAPS,      JSR     R5,TTICH        ;GET CHANNEL #
        
.IIF    DF,TRAPS,       TRAP    136             ;GET CHANNEL #
.ENDM   TTICH

.REM    \
        MACRO TO SELECT A STARTING CHANNEL #.
\
.MACRO  CHSTRT
.IIF    NDF,TRAPS,      JSR     R5,CHSTRT       ;STARTING CHANNEL TO R4
.ENDM   CHSTRT
.REM    \
        MACRO TO UPDATE THE CHANNEL #
\
.MACRO  NEXTCH
.IIF    NDF,TRAPS,      JSR     R5,NEXTCH       ;NEXT CHANNEL TO R4
.ENDM   NEXTCH
.REM    \
        MACRO TOR EPORT CHANNEL # AND DETERMINE SUBTEST.
\
.MACRO  CHTYP
.IIF    NDF,TRPAS,      JSR     R5,CHTYP        ;TYPE CHANNEL
.IIF    DF,TRAPS,       TRAP    137             ;TYPE CHANNEL
.ENDM   CHTYP


;SEQ139

.REM    \
        CHANNEL FAULT CALLER.  PUTS THE CHANNEL IN R4 ON THE ERROR
STACK AND DETERMINES THE SUBTEST.  ACCEPTS THE SAME ARGUMENTS AS
THE DIACON FAULT MACRO.
\
.MACRO  CFAULT  ARG
          JSR   PC,CFAULT               ;SAVE CHAN # & FAULT RETURN
        .IIF    B,<ARG>         .WORD 0
        .IF     NB,<ARG>
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   CFAULT
.REM    \
        CALLER FOR A ROUTINE WHICH LOOKS FOR THE NEXT MEMORY
REFERENCE.  SETS THE C-BIT IF TIMEOUT.
\
.MACRO  TSTREF
.IIF    NDF,TRAPS,      JSR     R5,TSTREF       ;GET TO SBUS ADR HOLD
.IIF    DF,TRAPS.       TRAP    140             ;GET TO SBUS ADR HOLD
.ENDM   TSTREF

.REM    \
        MACRO TO TEST CHANNEL STATUS WORD 1.
\
.MACRO  STACOM  ST
.IIF    NDF,TRAPS,      JSR     R5,STACOM       ;TEST STATUS
.IIF    DF,TRAPS.       TRAP    141     ;TEST STATUS 1
          .WORD ST              ;EXPECTED STATUS POINTER
.ENDM
.REM    \
        MACRO TO TREST CHANNEL STATUS WORD 2.
\
.MACRO  STAT2   ST
.IIF    NDF,TRAPS.      JSR     R5,STAT2                ;TEST STATUS 2
.IIF    DF,TRAPS,       TRAP    150             ;TEST STATUS 2
          .WORD ST              ;ERXPECTED STATUS POINTER
.ENDM

.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
.IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<.ASCIZ    %'$TXT'%>
        .LIST  SRC
          .WORD  TEXT
        .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        TTIBRK                  ;GET LAST CHARACTER TYPED
        CMP     R0,#'/          ;SWITCH SPECIFIED?
        BNE     1$              ;NO
        JSR     PC,USERSW       ;YES,GO TO USER SWITCH ROUTINE
1$:     SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
        MOV     #DIACOM,COMRET          ;SET COMMAND RETURN
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        CMP     R0,#'/                  ;SLASH?
        BNE     NOPSEL                  ;NO
        JSR     PC,USERSW                 ;YES, GO DO USER SWITCH ROUTINE
        BR      DIACOM                  ;BACK TO COMMAND MODE
NOPSEL: MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRINT SYMPTOM
        .BYTE   'F,'B           ;FB - SET FUNCTION BREAKPOINT
        .BYTE   'F,'C           ;FC - FUNCTION BREAK CONTINUE
        .BYTE   'C,'B           ;CB - CLEAR FUNCTION BREAKPOINT
        .BYTE   'R,'G           ;RG - PRINT FN BREAK REGISTERS
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;
        .WORD   FB..
        .WORD   FC..
        .WORD   CB..
        .WORD   RG..

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    </	PROGRAM DEFINED SWITCHES\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>
        PMSG    <FB	SET FUNCTION BREAKPOINT\>
        PMSG    <FC	FUNCTION BREAK CONTINUE\>
        PMSG    <CB	CLEAR FUNCTION BREAK\>
        PMSG    <RG	PRINT BREAK REGISTERS\>


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        JSR     PC,USRHLP               ;PRINT USER HELP INFORMATION
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKPOINTS DURING INITIALIZATION
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKS DURING INITIALIZATION
        JSR     PC,(R3)                 ;DO INITIALIZATION
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR DATA STACKING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  6-APR-78
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SYNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN ALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     $CNTLC          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPEOUT AND HOW TO MAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FTNON           ;12 - FT3 NOT USED
        FTT     FTNON           ;14 - FT6 NOT USED
        FTT     FT8             ;16
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTMEM           ;30
        FTT     FTPRM          ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44
        FTT     FTNON           ;46

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
        %

.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %

FT8T:FTM.        <HEDSCT,ENTSCT>

.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

FTMEMT:FTM.     <HEDMRQ,ACTMRQ,EXPMRQ>

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ACTMRQ:ACMRQ
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
ENTSCT:ENSCT
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXPMRQ:XPMRQ
HEDMRQ:HDMRQ
IBPTAB: IBPTB
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT



        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ %	CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>
        .LIT ERMRQ,<.ASCIZ %         RQ0 RQ1 RQ2 RQ3 RD  WR  SBUS ADR\%>

.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER
.REM    %
        PRINT ACTUAL MEMORY RQ'S AND 22-BIT ADDRESS
        %
ACMRQ:  $PMSG,ERACT             ;PRINT MESSAGE
MRQCOM: JSR     PC,TYPRQS       ;TYPE REQUEST BITS
        MOV     R5,R0   
        ADD     #3,R5           ;SKIP OVER INFO
        PNT22                   ;SBUS ADR IN OCTAL
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER




.REM    %
        
STACK HAS ONE OR MORE ENTRIES TO REPORT SCANOUT ERRORS.
WORD1:DIAG FN,,SIZE ((CHAN OR MBOX TABLE ID)
        NEXT 2 OR 3 BYTES:EXPECTED DATA
        NEXT 2 OR 3 BYTES :ACTUAL DATA
        WHETHER 2 OR 3 BYTES IS DETERMINED BY SIZE AND DIAG FN, WHICH
        ALSO DETERMINES THE E-BUS BIT NUMBER CORRESPONDENCE.
        %

ENSCT:  CLRB    FT8DUN          ;CLR DONE FLAG
1$:     JSR     PC,GNSCT                ;GET ONE ENTRY FROM ERROR STACK

;NOW TEST ALL THE BITS IN THIS ENTRY AND PRINT DIFFERENCES
        JSR     PC,PRDBYT
        TSTB    FT8DUN          ;LAST ENTRY?
        BEQ     1$              ;NO, DO IT AGAIN
        RTS     PC              ;RETURN TO SCANNER



;SET UP AN ENTRY FOR REPORTING
GNSCT:  MOVB    (R5)+,FT8SIZ            ;GET SIZE PARAM
        MOVB    (R5)+,FT8DF             ;GET DIAG FCN
        BPL     2$              ;BR IF NO LAST ENTRY FLAG
        INCB    FT8DUN          ;SET DONE FLAG
        BICB    #200,FT8DF      ;AND CLEAN DF BUFFER
2$:     CLR     R3              ;INIT INDEX
        CMPB    FT8SIZ,#CSIZE   ;CHANNEL?
        BEQ     3$              ;BR IF SO
        INC     R3              ;NEXT INDEX
        CMPB    FT8DF,#163      ;FIND WHICH MBOX GROUP
        BLT     3$              
        INC     R3              ;2-BYTE GROUP
3$:     ASL     R3              ;MAKE WORD INDEX
        ADD     F8SIZT(R3),R5   ;POINT BEYOND EXPECTED
        MOV     R5,R1           ;MAKE EXPECTED PTR
        DEC     R1
        ADD     F8SIZT(R3),R5   ;POINT BEYOND ACTUAL
        MOV     R5,R2           ;MAKE ACTUAL PTR
        DEC     R2
        MOV     F8BITT(R3),F8BTF        ;GET # OF FIRST, LAST BITS
        MOV     F8MSKT(R3),R3   ;GET IRST BIT MASK
        RTS     PC              ;RETURN


;SEQ119

.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER

.REM    %
        PRINT EXPECTED DATA, MEM RQ AND 22-BIT ADDRESS
        %
XPMRQ:  $PMSG,ERCOR     ;PRINT MESSAGE
        JMP     MRQCOM  ;TYPE BITS, ADDRESS



.REM    %
REPORT MEMORY REQUESTS AND 22-BIT SBUS ADDRESS.
PRINT HEADER LINE
        %
HDMRQ:  $PMSG,ERMRQ     ;PRINT MESSAGE
        RTS     PC



.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER


;TYPE MEMORY REQUESTS AND READ/WRITE BITS

TYPRQS: MOV     #6,R2   ;BIT COUNT
        MOVB    (R5)+,R1        ;GET BIT WORD
        SWAB    R1              ;POSITION TO SHF INTO SGN
        PSPACE                  ;SPACE 1
1$:     MOV     #'0,R0          ;ASSUME A ZERO
        TST     R1              ;
        BPL     2$              ;BR IF ZERO
        MOV     #'1,R0          ;ITS A ONE
2$:     PNTCHR
        PSPACE,PSPACE,PSPACE    ;SPACE3
        ROL     R1              ;NEXT BIT
        DEC     R2              ;COUNT
        BGT     1$              ;DO MORE
        RTS     PC


;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT         ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ138



;SEQ206


;SEQ204


.SBTTL  *MBOX*  MEMORY MANAGEMENT TESTS 20-JAN-77  EDIT#142

.REM    %
        MEMORY SYSTEM DIAGNOSTIC DISPATCH TABLES FOLLOW.
%
INITAB: .WORD   I.0             ;00-ONE TIME INITIALIZATION
        .WORD   I.1!BIT15       ;01-DETERMINE MEMORY CONFIGURATION

FIMCT=<.-INITAB>/2               ;FIRST INTERNAL MEMORY CONTROLLER TEST
        .WORD   I.2!BIT15       ;02-DETERMINE TEST CONTROLLER
        .WORD   I.3             ;03-SBUS RESET
        .WORD   I.4             ;04-SET FLOPS FOR SBUS DIAG
        .WORD   I.5!BIT15       ;05-LOAD AC10
        .WORD   0               ;06-NO INIT FOR TEST#6
        .WORD   0               ;07-NO INIT FOR TEST#7
        .WORD   0               ;08-NO INIT FOR TEST#8
FIMMT=<.-INITAB>/2              ;FIRST INTERNAL MEMORY MODULE TEST
        .WORD   I.9!BIT15               ;9-STOR MOD SEL...INIT LPBK CYC TEST
        .WORD   I.10!BIT15      ;10-1S & 0S LOOPBACK
        .WORD   I.11!BIT15      ;11-ROTATING PATTERN TO LOOPBACK
        .WORD   0               ;12-NO INIT FOR TEST#12
        .WORD   I.13!BIT15      ;13-ZEROS TO ALL MODULE LOCATIONS
        .WORD   I.14!BIT15      ;14-LD AC PRGM FOR TEST
LIMMT=<.-INITAB>/2              ;LAST INTERNAL MEMORY MODULE TEST
        .WORD   I.15!BIT15      ;15-ODD PAR BIT TO ALL MODULE LOCATIONS
        .WORD   NXTMOD          ;16-DISPATCH MODIFIER FOR MODULES
        .WORD   I.17!BIT15      ;17-INIT FOR INT MEM ADR/TAG TEST
        .WORD   I.18!BIT15      ;18-READ/PAUSE/WRITE TEST FOR CONTROLLER
        .WORD   I.19!BIT15      ;19-INT MEM INCMP CYC TEST INIT
        .WORD    I.20            ;20-4 WORD RD TEST.  1 WAY INTERLEAVE
        .WORD   I.21            ;21- 4 WD RD TEST, 2 WAY INTERLEAVE
LIMCT=<.-INITAB>/2              ;LAST INTERNAL MEMORY CONTROLLER TEST
        .WORD   I.22            ;22- 4 WORD RD TEST, 4 WAY INTERLEAVE
        .WORD   NXTCON          ;23-INTERNAL MEMORY CONTROLLER DIAPATCH

FEMT=<.-INITAB>/2               ;FIRST EXTERNAL MEMORY TEST
        .WORD   I.24            ;24-SET SBUS DIAG FLOPS
        .WORD   I.25            ;25-SBUS RESET
        .WORD   I.26            ;26-SET SBUS DIAG FLOPS
        .WORD   I.27!BIT15              ;27-LOAD AC PROGRAM FOR TEST#27
        .WORD   I.28!BIT15      ;28-LOAD AC PROGRAM FOR TEST#28
        .WORD   I.29            ;29-LOAD PROG & CLR KBUS BUFFERS
        .WORD   I.30            ;30-SBUS RESET
        .WORD   I.31            ;31-SBUS RESET
        .WORD   I.32!BIT15      ;32-INIT FOR TEST#42
        .WORD   I.33!BIT15      ;33-INIT FOR TEST#33
        .WORD   0               ;34-NO INIT FOR EXT MEM ADR/TAG TEST
        .WORD   I.35!BIT15      ;35-READ/PAUSE/WRITE TEST INIT
        .WORD   I.36!BIT15      ;36-SINGLE STEP TEST INIT
LEMT=<.-INITAB>/2               ;LAST EXTERNAL MEMORY TEST
        .WORD   I.37!BIT15      ;37-X MEM 4 WD READ TEST INIT
        .WORD   XMEMS          ;38-MARK X MEM TESTED, CONFIGURE MEMORY


;SEQ205

;-----BIT0 SET MEANS THAT TEST LEAVES FAST LOOP RUNNING ON DETECTING
;       AN ERROR.

TESTAB: .BYTE   $NT             ;NUMBER OF TESTS
        .BYTE   'M              ;"M" IS THW SGKBB IS0. RTN. ID
        .WORD   T.1             ;01-FORMAT CHECK & REPORT MEM

        ;INTERNAL MEMORY:  MA 20 AND MB20

        .WORD   T.2             ;02-MA20 RESET
        .WORD   T.3             ;03-SBUS DIAG FLOPS
        .WORD   T.4             ;04-SBUS DIAG FLOPS CLR
        .WORD   T.5             ;05-ADDR BNDRY & RQ RESPONSE
        .WORD   T.6             ;06-ADDR BNDRY NO RESPONSE
        .WORD   T.7             ;07-RQ EN NO RESPONSE
        .WORD   T.8             ;08-MA20 ADDR PARITY
        .WORD   T.9             ;09-INTERNAL MEM LOOPBACK CYCLE TEST
        .WORD   T.10!BIT0       ;10-LOOPBACK ALL 1'S & ALL 0'S
        .WORD   T.11!BIT0               ;11-LOOPBACK ROTTING PATTERN
        .WORD   T.12!BIT0       ;12-ADDRESS TEST A MODULE
        .WORD   T.13!BIT0       ;13-MODULE 0S/1S TEST
        .WORD   T.14!BIT0       ;14-MODULE ROTATING PATTERN TEST
        .WORD   T.15!BIT0       ;15-MODULE PARITY BIT TEST
        .WORD   NORMAL          ;16-NO TEST
        .WORD   T.17            ;17-INIT MEM ADR/TAG TEST
        .WORD   T.18!BIT0       ;18-READ/PAUSE/WRITE TEST FOR INT MEM
        .WORD   T.19            ;19-INTERNAL MEM INCOMPLETE CYCLE TEST
        .WORD   T.20!BIT0       ;20- 4 WD RD TEST, 1 WAYINTERLAEAVE
        .WORD   T.21!BIT0       ;21- 4 WD RD TEST, 2 WAY INTERLEAVE
        .WORD   T.22!BIT0       ;22- 4 WD RD TEST, 4 WAY INTERLEAVE
        .WORD   0               ;23-NO RESET

        ;EXTERNAL MEMORY:       DMA20
        .WORD   T.24            ;24-DMA20 SBUS RESET FLOPS
        .WORD   T.25            ;25-SBUS DIAG SET FLOPS
        .WORD   T.26            ;26-SBUS DIAG CLR FLOPS
        .WORD   T.27!BIT0       ;27-PARTIAL ADDRESS PATH CHECK
        .WORD   T.28            ;28-ADDRESS PARITY FOR 1-WD RQS
        .WORD   T.29            ;29-DATA PATH THRU KBUS BUFFERS VIA LOOPBACK
        .WORD   T.30            ;30-DATA PARITY BIA LOOPBACK
        .WORD   T.31            ;31-PARITY ERROR DETECTION VIA LOOPBA K
        .WORD   T.32!BIT0       ;32-EXT MEM DATA PATH ONES/ZEROS TEST
        .WORD   T.33!BIT0       ;33-EXT MEM DATA PATH SLIDING PTRN TEST
        .WORD   T.34            ;34-EXTERNAL MEM ADR/TAG TEST
        .WORD   T.35!BIT0       ;35-EXT MEM RD/PS/WRT TEST
        .WORD   T.36            ;36-EXT MEM SINGLE STEP TEST
        .WORD   T.37!BIT0       ;37-X MEM 4 WD READ TEST
        .WORD   NORMAL          ;38-NO TEST

$NT=<.-TESTAB>/2-1


;SEQ206

.SBTTL          ONE-TIME INITIALIZATION

.REM    %
        THIS ROUTINE PERFORMS ONCE-ONLY INITIALIZATION.
        %
I.0:    PCRLF                   ;CR/LF
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #CHAIN,R0       ;CHAIN MODE?
        BNE     1$              ;YES, BYPASS TITLE PRINT
        PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TMBOXB\>

        PMSG    <CORE MEMORY SYSTEM DIAGNOSTIC >
        PNTVER                  ;PRINT DIAGNOSTIC VERSION #
        PMSG    <\SWITCHES = >
        SWITCH,PNTOCT,PCRLF
1$:     JSR     R5,INITM        ;INITIALIZE MBOX SUBROUTINES
;-----SECTION TO LOAD OR VERIFY EXISTING MICROCODE.
        CLR     R2              ;ZAP UCODE LOADED SWITCH
2$:     SM                      ;TRY A SM
        BCC     4$              ;BR IF OK
        TST     R2              ;ELSE ERR...DID WE LOAD UCODE?
        BEQ     3$              ;BR IF NO...GO LOAD & RETRY
        ERROR   <UCODE START ERR\>
3$:     MOV     #P.RAM,R0       ;ELSE LOAD UCODE VIA A PROGRAM CMD
        PRGCMD
        BCS     7$              ;BR IF CMD NOT SUCCESSFUL
        INC     R2              ;IND WE LOADED UCODE
        BR      2$              ;GO RETRY UCODE
        

4$:     MOV     #XAPRID,R0      ;DO APRID INSTRUCTION
        EXCT
        BCC     5$              ;BR IF SUCCESSFUL
        TST     R2              ;DID WE LOAD UCODE?
        BEQ     3$              ;NO...GO LOAD I & RETRY
        ERROR   <APRID EXCT ERR\>
5$:     EXAMT,AC17,D20TMP       ;GET APRID RESULTS
        BCC     6$              ;BR IF EXAMINE OK
        TST     R2              ;ELSE DID WE LOAD UCODE?
        BEQ     3$              ;NO...GO LOAD IT
        ERROR   <CAN'T EXAMINE AC\>

6$:     BITB    #2,D20TMP+4     ;DO WE HAVE DIAGNOSTIC MICROCODE?


;SEQ207

        BNE     8$              ;YES, FINISH ONE TIME INIT
        TST     R2              ;DID WE ALREADY TRY TO LOAD UCODE?
        BEQ     3$              ;NO, GO LD & RETRY
7$:     PMSG    <LOAD>
        $PMSG,P.RAM+1           ;PRINT UCODE NAME
        PMSG    < & HC\>
        PRGHLT
        BR      1$              ;UPON HC GO BACK & TRY AGAIN

8$:

 
;SEQ208

;-----TURN ON MASTER OSCILLATOR IF WE HAVE ONE.
        CLRB    MSTROS          ;SAY THAT WE DON'T HAVE A MASTER OSC
        BIT     #20000,D20TMP   ;CHECK IF MASTER OSCILLATOR BIT IS SET
        BEQ     11$             ;BR IF NO MASTER OSC.  DON'T TRY TO USE IT!
        MOV     #CSCMD1,R0      ;SELECT CLOCK SOURCE 2 (EXTERNAL)
        PRGCMD
        BCC     10$             ;BR IF NO ERROR
        PMSG    <CAN'T SEL MASTER OSC\>
9$:     PMSG    <TURN POWER OFF, THEN ON\MASTER OSC BAD\>
        PRGHLT                  ;STOP REGARDLESS OF ERSTOP SWITCH SETTING
        
10$:    MOV     #SMCMD1,R0      ;NOW TEST TO SEE IF IT IS REALLY THERE
        PRGCMD                  ;BY TRYING TO DO AN 'SM'
        BCS     9$              ;BR IF NOT OK
        INCB    MSTROS          ;INDICATE WE HAVE MASTER OSC & IT IS ON
11$:    
        INVAL                   ;SWEEP CACHE TO DE-JUNMK IT
;-----SECTION TO PRINT ALL THE REST OF THE TITLE JUNK.
        SWITCH                  ;GET SWITCHES AGAIN
        BIT     #CHAIN,R0               ;CHAIN MODE SET?
        BNE     FLGSET          ;IF YES, DONT PRINT THIS JUNK
        PMSG    <UCODE VERSION >
        MOV     D20TMP+2,R0     ;EXTRACT UCODE VERS #
        ASR     R0
        ASR     R0
        BIC     #177000,R0
        PNTOCS
        PMSG    <, CLOCK RATE >
        CLKPRM
        MOV     (R0),R0
        BIC     #177774,R0
        PNTNBR
        PMSG    <, PROCESSOR ID #>
        MOV     D20TMP,R0
        BIC     #170000,R0
        PNTDEC,PCRLF
FLGSET: CLR     DEVFLG          ;RESET TEST CONTR CONTROL FLAG
        MOV     #-1,TSTMOD      ;INDICATE MODULE NOT SELECTED
        MOV     #-1,EXTFLG      ;SET FORCE-EXTENDED-ADDRESSING FLAG
        MOV     #-1,LSTCNP      ;NO LAST CONTR # PRINTED
        RTS     PC              ;RETURN


;SEQ209

        DEVFLG: .WORD   0               ;MEM CONTROLLER FLAG
        SCANWD: .WORD   0               ;GENERATION PASS CONTROL WD
        LSTCNP: .WORD   -1              ;LAST CONTR # PRINTED
        XAPRID: WD36    7000,0000,0017  ;APRID AC17
P.RAM:  .ASCIZ  "P DIAGB.RAM"   ;MODEL B DIAGNOSTIC UCODE
        CSCMD1: .ASCIZ  "CS 2"          ;SELECT MASTER OSCILLATOR COMMAND
        SMCMD1: .ASCIZ  "SM"            ;START MICRO CODE COMMAND
        MSTROS: .BYTE   0               ;SET IF WE HAVE MASTER OSC
        .EVEN


;SEQ210

.SBTTL          COMMAND PARSER FOR / TYPE CMDS TO DIAGNOSTIC
.REM    %
        THE COMMANDS CURRENTLY RECOGNIZED ARE:

/B<NUMBER>      FORCES DMA20 BUS MODE TO WHATEVER YOU WANT IT TO BE.
        DEFAULT IS WHATEVER THE MEMORY CONFIGURATOR DECIDES IS
        BEST.  THE <NUMBER> MAY BE 0 (ALLOW DEFAULT), 1, 2, OR 4.
        
/P      DO A ROUTINE TO AID IN PATCHING THE DIAGNOSTIC.

TERMINATING THE LAST INPUT TO A COMMAND WITH AN ALTMODE 9ESCAPE) CAUSES
THE DIAGNOSTIC TO BE STARTED IMMEDIATELY.
        %
;-----GET THE COMMAND LETTER & GO TO THE CORRECT ROUTINE.
USERSW: TTICHR                  ;GET THE FIRST CHAR
        CMP     R0,#'B          ;FORCE DMA20 BUS MODE CMD?
      
        BEQ     1$              ;YES...GO DO IT
        CMP     R0,#'P          ;PATCH CMD?
        BEQ     2$              ;YES...DO IT
;-----COMMAND NOT RECOGNIZED.
        PMSG    <\?\>           ;SEN ERR MSG
        TTPINI                  ;RESET I/0
        RTS     PC              ;RETURN TO DIACON
;-----SECTION FOR B COMMAND.
1$:     JSR     R5,FDMABM               ;GO SET BUS MODE
        BR      FDCB            ;EXIT GRACEFULLY
;-----SECTION FOR P COMMAND.
$$PATCH=1                       ;FORCE ASSEMBLY OF PATCH SUBROUTINE
2$:     JSR     R5,PATCH        ;CALL PATCHER ROUTINE
;       BR      FDCB            ;EXIT GRACEFULLY
;-----SECTION TO EXIT TO DIACON OR THE DIAGNOSTIC
FDCB:   TTBACK                  ;COME HERE AFTER NUMERIC PARAMS
FDC:    TTICHR                  ;HERE AFTER NON-NUMERIC PARAMS
        CMP     R0,#ALTMOD      ;CMD TERMINATED WITH ALTMODE?
        BEQ     1$              ;YES...GO START DIAGNOSTIC
        RTS     PC              ;ELSE JUST RETURN TO DIACON CMD PARSE
1$:     POP     R0              ;DEL RET ADR FROM STK
        JMP     MX..            ;GO START DIAGNOSTIC

;-----HELP COMMAND EXTENSION.
USRHLP: PMSG    <\/B	FORCE DMA20 BUS MODE\/P	PATCH DIAGNOSTIC\>
        RTS     PC

;SEQ211

.SBTTL          TEST ROUTINES COMMON TO ALL MEMORY TYPES

.REM    %
        CODE FOR CXQT...EXECUTE AND CHECK.
        %

.MACRO  CXQT    INSTR
.IF     NB,INSTR
          JSR   R5,CXQT         ;WEXECUTE AND CHECK
          .WORD INSTR           ;ADR OF INSTRUCTION
.IFF    
        JSR     R5,CXQT1        ;EXECUTE INSTR PTD TO BY RO
.ENDC
.ENDM   CXQT

CXQT:   MOV     (R5)+,R0        ;GET INSTR ADR
        
CXQT1:  XQT                     ;DO THE INSTRUCTION
        BCC     1$              
        MOV     R5,(SP) ;FOOL CHKX ROUTINE IF ERR
        JMP     CHKX+4  ;CALL OUT ERR
1$:     RTS     R5              ;RET IF OK

.REM    %
        DVAOT --- A SUBROUTINE TO CHECK THE STATE OF 'DATA WORD
        A OUT H' AND 'DATA VALID B OUT H' DURING THE COURSE OF A
        READ/PAUSE/WRITE.  THIS SHOULD COME UP JUST BEFORE THE
        WRITE PORTION OF THIS CYCLE.
        %
DVAOT:  MOV     (R4)+,6$+4      ;SET UP STEXCT
        MOV     #2,R0           ;SET PHASE TO 'B PHASE COMING'
        SETMPH  
        CLR     12$             ;WE ARE LOOKING FOR "A" OR "B"
        JSR     R4,6$           ; ***** SUBTEST 1 *****
        BCC     1$              ;BR IF NO ERR
        CLR     R0              ;ELSE ERR...RESET PHASE
        SETMPH          
        PWTES   12$             ;PARAM WD TO ERR STK
        FAULT   <NEITHER 'DATA VALID ? OUT H' SIGNAL SET DURING R-P-W>

1$:     CLR     R0              ;RESET PHASE
        SETMPH
        JSR     R4,6$           ; ***** SUBTEST 2 *****
        BCC     3$              ;NO ERR
        PWTES   12$             ;PARAM WD TO ERR STK
        MOV     #4$,R0          ;ASSUME "A" NOT FOUND
        TSTB    12$             ;WAS IT "A"?
        BEQ     2$              ;YES
        MOV     #5$,R0  ;ELSE SAY IT WAS "B"


;SEQ212

2$:     ERRCOM  PNTAL           ;PRINT PHASE MSG
        ERRMSG  < OUT H" NOT SET DURING R-P-W>
        FAULT
3$:     RTS     R4
4$:     .ASCIZ  %"DATA VALID A%
5$:     .ASCIZ  %"DATA VALID B%


;SEQ213

;-----LOCAL DIRTYWORK SUBROUTINE. STARTS THE INSTRUCTION WHICH
;       DOES A RD-PS-WR & STEPS THRU IT LOOKING FOR SIGNAL.
6$:     STEXCT  000000          ;START SINGLE STEPPING SPECIFIED INSTR
        FIND    <177,28.,0>     ;FIND "RD PAUSE 2ND HALF L" TO SAVE TIME
        BCC     7$              ;BR IF FOUND
        ERROR   <"RD PAUSE 2ND HALF L" NOT FND>
7$:     MOV     #200,R1         ;TIMEOUT COUNT
        INSYNC                  ; ***** NEXT SUBTEST *****
8$:     STEP                    ;MBOX CLOCK
        TSTB    12$             ;STILL LOOKING FOR "A"?
        BNE     9$              ;BR IF NO
        DFRDT,163               ;GET "A"
        BIT     #BIT2,@.DAT3    ;SET?
        BEQ     9$              ;BR IF NOT
        INCB    12$             ;ELSE IND NO LONGER LOOKING FOR "A"
        BR      10$             ;CLC EXIT
9$:     TSTB    13$             ;STILL LOOKING FOR "B"?
        BNE     11$             ;BR IF NO
        DFRDT,164                       ;ELSE GET IT
        BIT     #BIT8,@.DAT3    ;...AND SEE IF IT'S SET
        BEQ     11$             ;BR IF NOT
        INCB    13$     ;ELSE MARK IT AS FOUND
10$:    CLC                     ;OK EXIT...CLR C-BIT
        RTS     R4
11$:    DEC     R1              ;REDUCE TIMEOUT CNT
        BGT     8$              ;LOOP IF COUNTS LEFT
        SEC                     ;ELSE SET ERROR
        RTS     R4              ;AND RETURN
        .EVEN
12$:    .BYTE   000             ; =0 MEANS "A" NOT YET FOUND
13$:    .BYTE   000             ; =0 MEANS "B" NOT YET FOUND

;-----SUBROUTINE TO STICK THE CURRENT CONTROLLER NUMBER INTO AN
;       SBUS DIAG WORD.  THE ADDRESS OF THE SBUS DIAG WORD IS A T.P.
CNTSD:  PUSH    R1              
        MOV     (R5)+,R1        ;ADDRESS OF SBUS DIAG WD
        MOVB    TSTCON,R0               ;GET CONTROLLER #
        ROR     R0              
        MOVB    R0,4(R1)        ;BIT 0-3
        BICB    #200,3(R1)      
        BCC     1$              ;BIT 4
        BISB    #200,3(R1)      
1$:     POP     R1

        RTS     R5


;SEQ214

.REM    %
        TSTCAP --- SUBROUTINE TO MAKE SURE THAT THE APR BOARD HAS SENSED
        AN ADR PAR ERR, AND THAT 'HOLD ERA L' IS ASSERTED.  IT ALSO
        CHECKS TO SEE IF 'HOLD ERA L' CAN BE MADE TO GO AWAY.
        %
TSTCAP: MOV     (R4)+,1$+2      ;RD OR WR
        CXQT    RDAPR           ;GET APR STAT
        EXAMT,AC17,D20TMP       
        JSR     PC,CHKED
        BIT     #100,(R0)       ;ADR PAR ERR SET?
        BNE     2$              ;YES...OK
        PWTES   #1              ;ELSE ERR TYPE 1
1$:     MOV     #000000,R0      ;LD ADR OF PROPER ERR MSG
        ERRCOM  PNTAL           ;PRINT IT
        ERRMSG  < BAD ADR PARITY.  APR SAYS NO ERR>
        FAULT
2$:     STEXCT  RDMEM           ;START A FREAD CYCLE
        SOBAC   <166,32.,0>,31  ;WAIT FOR MEM START L
        BCC     4$              ;BR IF FOUND
3$:     ERROR   <"MEM START L" NOT FOUND>       ;ELSE DIE
4$:     DFRDT,162                       ;F RD FOR 'HOLD ERA L'
        BIT     #BIT13,@.DAT3   ;CHECK SIGNAL
        BEQ     5$              ;LOW...OK
        PWTES   #2              ;ELSE ERR TYPE 2
        FAULT   <"HOLD ERA L" NOT ASSERTED FOR BAD ADR PARITY>
5$:     DFXCTT,STRCLK           ;RESTART CLOCK
        CXQT    7$              ;TURN OFF ERR GENERATION
        INSYNC                  ; ***** NEXT SUBTEST *****
        CXQT    CLRAPR  ;CLEAR APR FLAGS...ALLOWS "-HOLD ERA "


;SEQ215

        STEXCT  RDMEM           ;SATART A READ CYCLE
        SOBAC   <166,32.,0>,31  ;WAIT FOR "MEM START L"
        BCS     3$              ;ERR IF NOT FND
        DFRDT,162               ;F RD FOR "HOLD ERA L"
        BIT     #BIT13,@.DAT3   ;"HOLD ERA L"
        BNE     6$              ;BR IF YES...OK
        FAULT   <"HOLD ERA L" NOT CLEARED ON APR CLR BAD ADR PAR ERR>
6$:     DFXCTT,STRCLK           ;LET INSTRUCTION FINISH
        RTS     R4              ;RETURN TO CALLER
7$:     IO10    CONO,PI,,10000  ;RESET PI SYS
TCWR:   .ASCIZ  %WR%
TCRD:   .ASCIZ  %RD%
        .EVEN

.REM    %
        SUBROUTINES TO CHECK STATE OF CONTROLLERS ADR PARITY ERR BIT.
        %
APCTST: SBUSDG  SDC05           ;CLEAR CONTR ERR BITS 0-5
        BR      APTST           ;GO CHK STATE OF BIT AFTER CLEAR
APETST: SBUSDG  ZERO.           ;READ VALUE OF ADR PAR ERR FLG
APTST:  TBIT    5               ;TST ITS STATE

        RTS     R5              ;RETURN TO CALLER


;SEQ216

.REM    %
        "ADRTAG" IS A SUBROUTINE DESIGNED TO DO AN ADDRESS-IS-DATA TEST,
OTHERWISE KNOWN AS AN ADDRESS-TAG TEST.  THE BASIC SCHEME IS THIS:  WRITE THE
ADDRESSES OF EACH WORD INTO THE WORD AND READ THEM ALL BACK.  IF THERE WAS ANY
ADDRESS INTERFERENCE ON THE WRITES IT WILL SHOW UP ON THE READ BACK.  THE
ADDRESSES ARE ALSO WRITTEN IN A REVERSE ORDER TO CATCH ADDRESS INTERFERENCE
PROBEMS FOM HIGH TO LOW MEMORY.  FINALLY, BOTH OF THE ABOVE ARE REPEATED WITH
COMPLEMENTARY DATA TO MAKE SURE THAT EACH BIT OF THE MEMORY CAN HOLD A 1 AND A
        
0, AND ALSO TO CATCH DATA RELEATED ADDRESS INTERFERENCE PROBLEMS.

        THIS ADDRESS-TAG TEST FEATURES PATTERNS IN BOTH HALVES OF THE DATA WORD.
THIS IS NECESSARY BECAUSE THE MEMORIES ARE BUILT AS TWO 18 BIT MODULES IN
PARALLEL.  THE PROBLEM IS THAT THE MAXIMUM ADDRESS IS 22 BITS AND YOU CANNOT FIT
2 22 BIT NUMBERS INTO 36 BITS.  THE WAY IT'S DONE IN THIS TEST IS THE 22 BIT
ADDRESS  IS KEPT IN THE RHE OF THE WORD AND A SPECIAL "1 BIT INSENSITIVE" PATTERN
IS KEPT IN THE HIGH ORDER 14 BITS OF THE WORD.  THE NATURE OF THIS PATTERN IS
SUCH THAT ANY 1 BIT ADDRESS ERROR WILL GO TO A WORD WHOSE HIGH ORDER PATTERN IS
DIFFERENT.  THUS YOU HAVE AN INDICATION OF WHETHER THE ADDRESS INTERFERENCE
OCCURED IN THE LEFT, RIGHT, OR BOTH HALVES OF THE WORD, WHICH GFIVES MORE OF AN
INDICATION  OF JUST WHERE THE ERROR IS OCCURING.

        TO PERSERVE PDP-11 MEMORY SPACE THE AC PROGRAMS FOR ALL 9 SUBTESTS ARE
NOT GIVEN.  INSTEAD THE AC PROGRAMS ARE CONSTUCTED BY THE PDP-11 IN THE ACS AT
RUN TIME.  A LOT OF THE 11 CODE IS USED TOT HIS END AND IS NOT ACTUALLY PART OF
"THE TEST".  NOTE THE CAPABILITY TO CHANGE THE ORDER OF THE SUBTESTS.

        SUBTESTS 1, 4, 6 AND 8 SHOULD NOT GET ANY ERRORS EXCEPT PERHAPS FOR
ERRONEOUS NXMS  WHICH INDICATES FAULTY ADDRESS-ACKNOWLEDGE LOGIC.

        SUBTESTS 2, 5, 7 AND 9 WILL CATCH MOST OF THE ERRORS IN THIS TREST.
THESE INCLUDE DROPOUTS, PICKED & STUCK BITS, AND ADDRESS INTERFERENCE.  CHANCES
ARE THAT EITHER THE PATTERN IN BITS 00-13 OR THE ADDRESS IN 14-35 IS CORRECT
BUT INCORRECT DATA THEN THEN CHANCES ARE THAT THE PROBLEM IS ADDRESS
INTERFERENCE.

        AN ERROR IN SUBTEST 3 INDICATES READ-RESTORE PROBLEMS IF THE DATA COMING
BACK HAS MASSIVE DROPOUTS, OTHERWISE THE PROBLEM IS MOST LIKELY A FLAKY READ
9SENSE) ERROR.

        SUBTEST 10 IS DIFFERENCT FROM ALL THE OTHERS.  IT USES THE ADDRESS AND
DATA LEFT HANGING AROUND BY SUBTEST 9 TO TEST THAT WRITES ARE INHIBITED BY BAD
ADDRESS PARITY.


;SEQ217

***** CONTENTS OF ACCUMULATORS FOR SUBTESTS 1 TO 5. *****

SUBTEST 1       SUBTEST 2       SUBTEST 4 *1    SUBTEST 5
WRITE FORWARD   READ FORWARD    WRITE FORWARD   READ FORWARD
ADR COM PTRN    ADR COMP PTRN   ADDRESS PTRN    ADDRESS PTRN    AC
-----------------------------    ------------   -------------   ----
TRNN,17,,37777  TRNN,17,,37777  TRNN,17,37777   TRNN,17,37777   ! 00
HRRI,2,,-320,2  HRRI,2,,-320,2  HRRI,2,,320,2   HRRI,2,320,2    ! 01
HRLOI,16,,-1    HRLOI,16,,-1    HRLZI,16,,0     HRLZI,16,,0     ! 02 <START>
XOR,16,,17      XOR,16,,17      XOR,16,,17      XOR,16,,17      ! 03
HRRI,2,,-460,2  HRRI,2,,-460,2  HRRI,2,,460,2   HRRI,2,,460,2   ! 04
SXCT,,,13       SXCTT,,,13      SXCT,,,13       SXCTT,,,13      ! 05

JRST,,,10       CAME,15,,16     JRST,,,10       CAME,15,,16     ! 06
                HALT,,,1                        HALT,,,1        ! 07
CAME,17,,14     CAME,17,,14     CAME,17,,14     CAME,17,,14     ! 10
AOJA,17,,0      AOJA,17,,0      AOJA,17,,0      AOJA,17,,0      ! 11
HALT,,,0        HALT,,,0        HALT,,,0        HALT,,,0        ! 12
MOVEM,16,,0,17  MOVE,15,,0,17   MOVEM,16,,0,17  MOVE,15,,0,17   ! 13
LAST ADR        LAST ADR        LAST ADR        LAST ADR        ! 14
ECHO            ECHO            ECHO            ECHO            ! 15
PATTERN         PATTERN         PATTERN         PATTERN         ! 16
ADDRESS         ADDRESS         ADDRESS         ADDRESS         ! 17


***** CONTENTS OF ACCUMULATORS FOR SUBTESTS 6 TO 9. *****

SUBTEST 6       SUBTEST 7       SUBTEST 8       SUBTEST 9
WRITE BACKWARD  READ BACKWARD   WRITE BACKWARD  READ BACKWARD
ADR COMP PTRNADR COMP PTRN      ADDRESS PTRN    ADDRESS PTRN    AC
-------------   ------------    --------------  --------------  ----
TRNN,17,,37777  TRNN,17,,37777  TRNN,17,,37777  TRNN,17,,37777  ! 00
HRRI,2,,-320,2  HRRI,2,,-320,2  HRRI,2,,320,2   HRRI,2,,320,2   ! 01
HRLOI,16,,-1    HRLOI,16,,-1    HRLZI,16,,0     HRLZI,16,,0     ! 02 <START>
XOR,16,,17      XOR,16,,17      XOR,16,,17      XOR,16,,17      ! 03
        
HRRI,2,,-460,2  HRRI,2,,-460    HRRI,2,,460,2   HRRI,2,,460,2   ! 04
SXCT,,,13       SXCT,,,13       SXCTT,,,13      SXCT,,,13       ! 05
JRST,,,10       CAME,15,,16     JRST,,,10       CAME,15,,16     ! 06
        HALT,,,1                                HALT,,,1        ! 07
CAME,17,,14     CAME,17,,14     CAME,17,,14     CAME,17,,14     ! 10
SOJA,17,,0      SOJA,17,,0      SOJA,17,,0      SOJA,17,,0      ! 11
HALT,,,0        HALT,,,0        HALT,,,0        HALT,,,0        ! 12
MOVEM,16,,0,17  MOVE,15,,0,17   MOVEM,16,,0,17  MOVE,15,,0,17   ! 13


LAST ADR        LAST ADR        LAST ADR        LAST ADR        ! 14
ECHO            ECHO            ECHO            ECHO            ! 15
PATTERN         PATTERN         PATTERN         PATTERN         ! 16
ADDRESS         ADDRESS         ADDRESS         ADDRESS         ! 17
*1 NOTE: SUBTEST 3 IS THE SAME AS SUBTEST 2.  THIS IS SPECIFICALLY TO
CHECK FORE THE POSSIBLITY OF A FAULTY READ-RESTORE OPERATION IN THE
MEMORY.
        %
;NOTE: FOR MODEL B THE SXCT INSTRUCTIONS ARE REPLACED WITH XCT INSTRUC-
;TIONS AND "FORCE EXTENDED ADDRESSING" IS SET IN THE EBOX.


;SEQ218

.REM    %
        WHAT FOLLOWS IS THE INSTRUCTION "VOLLECTION" FOR THE ADDRESS-TAG
TEST.  THEY ARE BROKEN INTO GROUPS ACCORDING TO FUNCTION.
        %
        BLK10   0

ATCGPM=ACC0+ACC3+ACC5+ACC10+ACC12       ;INSTRUCTIONS COMMON TO ALL SUBTESTS
ATCGI:  I10     TRNN,17,,37777  ;0-
        I10     XOR,16,,17              ;3
        I10     XCT,,,13                ;5-
        I10     CAME,17,,14     ;10-
        I10     JRST,4,,0               ;12-

ATWGPM=ACC6+ACC13                       ;WRITE GROUP INSTRUCTIONS
ATWG=BIT0                               ;LOAD CONTROL BIT
ATWGI:  I10     JRST,,,10       ;6-
        I10     MOVEM,16,,0,17          ;13-
ATRGPM=ACC6+ACC7+ACC13          ;READ GROUP INSTRUCTIONS
ATRG=BIT1                       ;LOAD CONTROL BIT
ATRGI:  I10     CAME,15,,16     ;6
        I10     JRST,4,,1       ;7-
        I10     MOVE,15,,0,17   ;13-
ATCAPM=ACC1+ACC2+ACC4                   ;COMPLEMENTARY ADR PATTERN ISNTRS
ATCA=BIT2                               ;LOAD CONTROL BIT
ATCAI:  I10     HRRI,2,,777460,2        ;1-
        I10     HRLOI,16,,777777        ;2

        I10     HRRI,2,,777320,2        ;4
ATNAPM=ATCAPM                   ;NORMAL ADDRESS PATTERN INSTRUCTIONS
ATNA=BIT3                       ;LOAD CONROL BIT
ATNAI:  I10     HRRI,2,,320,2   ;1-
        I10     HRLZI,16,,0     ;2-
        I10     HRRI,2,,460,2   ;4-

ATIAPM=ACC11                    ;TO USE ASCENDING ADDRESSES
ATIA=BIT4                       ;LOAD CONTROL BIT

ATIAI:  I10     AOJA,17,,0      ;11-

ATDAPM=ACC11                    ;TO USE DESCENDING ADDRESSES
ATDA=BIT5                       ;LOAD CONTROL BIT
ATDAI:  I10     SOJA,17,,0              ;11-

ATEX=BIT6                       ;LOAD CONTROL BIT
EXCH14: I10     EXCH,14,,17             ;EXCHANGES HI/LO ADRS FOR DECREASING ADR

        ENDBLK


;SEQ219

.REM    %
        THE FOLLOWING ARE THE "SUBTEST ORDER" CONTROL TABLES.  NORMALLY
ONLY THE FIRST IS USED.  IT DOES THE SUBTESTS IN THE ORDER ADVERTISED
ABOVE.  "ATREVP" REVERSES THE PATTERN ORDER, USEFUL FOR CHECKING FOR
STUCK BITS.  "ATREVA" REVERSES THE ORDER OF ADDRESS DIRECTION USEFUL
FOR CHECKING FOR ADDRESS INTEREFERENCE.  TO SELECT ONE OR THE OTHER MOVE
THE ADDRESS OF THE DESIRED TABLE INTO "ATSORD".
        %

ATSORD: .WORD   ATNORM          ;SUBTEST ORDER TABLE ADDRESS

;-----SUBTEST ORDER:  1,2,3,4,5,6,7,8,9.
ATNORM: .BYTE   ATWG+ATCA+ATIA          ;1-WRITE COMP PTRNS FORWARD
        .BYTE   ATRG+ATCA               ;2-READ & CHECK
        .BYTE   ATCA                    ;3-REREAD TO CHECK READ-RESTORE
        .BYTE   ATWG+ATNA               ;4-WRITE NORMAL PTRNS FORWARD
        .BYTE   ATRG+ATNA               ;5-READ & CHECK
        .BYTE   ATWG+ATCA+ATDA+ATEX     ;6-WRITE COMP PTRNS BACKWARD
        .BYTE   ATRG+ATEX+ATCA          ;7-READ 7 CHECK
        .BYTE   ATWG+ATNA+ATEX          ;8-WRITE NORMAL PTRNS BACKWARD

        .BYTE   ATRG+ATEX+ATNA          ;9-READ & CHECK

;-----SUBTEST ORDER:  4,5,3,1,2,8,9,6,7.
ATREVP: .BYTE   ATWG+ATNA+ATIA          ;1-WRITE NORMAL PTRNS FORWARD
        .BYTE   ATRG+ATNA               ;2-READ & CHECK
        .BYTE   ATNA                    ;3-REREAD TO CHECK READ-RESTORE
        .BYTE   ATWG+ATCA               ;4-WRITE COMP PTRNS FORWARD
        .BYTE   ATRG+ATCA               ;5-READ & CHECK
        .BYTE   ATWG+ATNA+ATDA+ATEX     ;6-WRITE NORMAL PTRNS BACKWARD
        .BYTE   ATRG+ATEX+ATNA          ;7-READ & CHECK
        .BYTE   ATWG+ATCA+ATEX          ;8-WRITE COMP PTRNS BACKWARD
        .BYTE   ATRG+ATEX+ATCA          ;9-READ & CHECK

;-----SUBTEST ORDER:  6,7,3,8,9,1,2,4,5.
ATREVA:         .BYTE   ATWG+ATCA+ATDA+ATEX     ;1-WRITE COMP PTRNS BACKWARD
        .BYTE   ATRG+ATEX+ATCA          ;2-READ & CHECK
        .BYTE   ATEX+ATCA               ;3-REREAD TO CHECK READ-RESTORE
        .BYTE   ATWG+ATNA+ATEX          ;4-WRITE NORMAL PTRNS BACKWARD
        .BYTE   ATRG+ATEX+ATNA          ;5-READ & CHECK
        .BYTE   ATWG+ATCA+ATIA          ;6-WRITE COMP PTRNS FORWARD
        .BYTE   ATRG+ATCA               ;7-READ & CHECK
        .BYTE   ATWG+ATNA               ;8-WRITE NORMAL PTRNS FORWARD
        .BYTE   ATRG+ATNA               ;9-READ & CHECK

        .EVEN


;SEQ220

.REM    %
        START OF THE PDP11 CODE FOR THE ADDRESS/TAG TEST.
        %
;-----ENTRY SECTION.  SET UP CONTYROL VARIABLES.
ADRTAG: SAV.5                   ;SAVE PDP11 REGS
        MOV     R0,R4           ;ADR LIST PTR TO R4
        CLR     R5              ;SUBTEST #
        PUSH    EXTFLG          ;SAVE CUR VAL OF FORCE-EXTEND FLAG
        MOV     #-1,EXTFLG              ;SET IT
        RSTMBX                  ;RESET MACHINE & SET FORCE-EXTEND
        POP     EXTFLG          ;RESTORE OLD VAL

        LOADAC  ATCGPM,ATCGI    ;LOAD COMMON AC CODE
;-----INIT DONE.  GET LOAD CONTROL BYTE FROM APPROP TABLE & LOAD
        
;       SPECIFIED AC GROUPS.
1$:     INC     R5              ;NEXT SUBTEST
        CMP     R5,#9.          ;ALL SUBTESTS DONE YET?
        BLE     2$              ;NO...CONT
        JMP     17$             ;DO BAD ADR PAR INVALID TEST
2$:     MOV     ATSORD,R1               ;GET TABLE ADDRESS
        ADD     R5,R1           ;NDX INTO IT
        MOVB    -1(R1),R1               ;NOW GET LOAD CNTL BYTE
        MOV     #ACLOAD,R2              ;PTR TO LOADAC SUBRTN SAVES TIME & SPACE
;-----READ OR WRITE GROUP.
;NOTE:  THE LOAD CONTROL BITS ARE PEELED OFF THE RHE OF R1 BECAUSE THEY
;       ARE DEFINED IN THE SAME ORDER OF USE.  SAVES TIME & SPACE.
        ASR     R1              ;LOAD WRITE GROUP (ATWG)
        BCC     3$              ;NO
        JSR     R5,(R2)         ;GO LOAD SPECD ACS
        .WORD   ATWGPM,ATWGI
3$:     ASR     R1              ;LOAD READ GROUP (ATRG)
        BCC     4$              ;NO
        JSR     R5,(R2)         ;GO LOAD SPECD ACS
        .WORD   ATRGPM,ATRGI
;------COMPLEMENT OR NORMAL PATTERN GROUPS.
4$:     ASR     R1              ;COMPLEMENTARY PATTERN.  9ATCA)
        BCC     5$              ;NO
        JSR     R5,(R2)         ;GO LOAD SPECD ACS
        .WORD   ATCAPM,ATCAI
5$:     ASR     R1              ;NORMAL PATTERNS? (ATNA)
        BCC     6$              ;NO
        JSR     R5,(R2)         ;GO LOAD SPECD ACS
        .WORD   ATNAPM,ATNAI
;-----INCREASING OR DECREASING ADDRESSES.
6$:     ASR     R1              ;INCREASING ADRS? (ATIA)
        BCC     7$              ;NO
        JSR     R5,(R2)         ;GO LOAD SPECD ACS
        .WORD   ATIAPM,ATIAI
;-----

;SEQ 221

7$:     ASR     R1              ;DECREASING ADRS?  (ATDA)
        BCC     8$              ;NO
        JSR     R5,(R2)         ;GO LOAD SPECD ACS
        .WORD   ATDAPM,ATDAI

;SEQ222

;-----INSTRUCTIONS ARE NOW LOADED.  INIT MEM BLOCK TABLE REGS FOR INNTER
;       LOOP CONTROL.
8$:     MOV     R4,R3           ;R3 PTS TO TAB ENTRY CNT WD
        MOV     (R3)+,R2        ;R3 PTS TO 1ST ENTRY, R2 HAS ENTRY COUNT
;-----START OF INNER LOOP.  CREATE BOUNDARY ADDRESSES AND LOAD THEM.
        ;REVERSE IF NEC FOR DESCENDING ADDRESS SUBTESTS.
9$:     MOV     (R3),R0         ;GET 16K FMT BLK START ADR
        JSR     R5,REAP2        ;EDIT TO 36 BIT ADR
        BIS     #100,REAPWD+2   ;SETTING IT 13 FORCES NO AC REFS
        LOADAC  ACC17,REAPWD    ;ADR ACS FROM CONTIGUOUG 11 MEM
        MOV     (R3)+,R0        ;CALC BLK END ADR
        PUSH    (R3)            ;CALC BLK SIZ ALSO

10$:    ADD     (R3)+,R0        ;ADD SIZ TOEND ADR
        DEC     R2              ;ANY MORE BLOCKS LEFT?
        BEQ     12$             ;NO...DOING LAST RIGHT NOW
        BGT     11$             ;YES...CHK FOR CONTIG BLKS
        TST     (SP)+           ;NO AGAIN...DEL JUNK FROM STK
        BR      1$              ;GO DO NXT SUBTEST
11$:    CMP     R0,(R3)         ;BLK END = NXT BLK START?
                                ;(POSSIBLE FOR EXTERNAL MEMORY)
        BNE     12$             ;NOPE...END ADR & SIZ CALCD
        TST     (R3)+           ;SKIP NEW BLK START...WE ALREADY KNOW IT
        ADD     (R3),(SP)       ;ADD NEW BLK SIZ TO SIZ ON STK
        BR      10$             ;LOOP
12$:    JSR     R5,REAP2        ;CHANGE TO 36 BIT ADR ALSO
        SUB     #1,(R0)+        ;DEC ADR SO IT'S WITHIN MEM BLK
        SBC     (R0)
        BIS     #100,REAPWD+2   ;SETTING BIT 13 FORCES NO AC REFS
        DPOST,AC14,REAPWD               ;MOVE UPPER BOUND TO ACS ALSO
        TST     R1              ;NECESSARY TO REVERSE ADRS? (ATEX)
        BEQ     13$             ;NO...GO START PRGM
       CXQT     EXCH14  ;ELSE REVERSE THEM
        ;-----AC PROGRAM IS NOW ALL SET TO RUN.  ESTIMATE RUN TIME BASD ON MEM
        ;       BLOCK SIZE & THEN RUN PROGRAM.
13$:    SL      (SP),3          ;CALC TIM CONST BASED ONB LK SIZ
        POP     14$+4           ;& SAV IT IN RUNBI PARAM LST
14$:    RUNBIG  AC2,000000      ;RUN THE PRGM NOW
;-----=PROGRAM HAS BEEN RUN.  FIGURE OUT WHAT HAPPENED.
        BCC     16$             ;HALTED WITHIN TIME ALLOTED
        TENSP                   ;DIDN'T HAL;T, SO HALT IT.
        JSR     R5,NXMTST       ;NXM SET?


        BNE     21$             ;YES...THAT'S PROBABLY WHY IT DIDN'T HALT
15$:    JSR     PC,CHKP+4       ;ELSE WE DON'T KNOW...
16$:    DFPC                    ;GET HALTED PC (HALT CODE)
        CMP     (R0),#1         ;WHAT WAS IT?
        BEQ     20$             ;1...ERROR DETECTED
        BHI     15$             ;>1...SOMETHING'S WRONG HERE
;-----HALT CODE (PC) IS 0...ALL OK.  DO NXT MEM BLK
        BR      9$
;----- ***** SUBTEST 10 *****
;MAKE SURE THAT WRITES ARE INHIBITED ON BAD ADDRESS PARITY.
17$:    LOADAC  AEIWPM,19$      ;LD THE AC PROGRAM.  ADR & DATA ALREADY IN
        RUN     AC1             ;RUN IT
        JSR     PC,CHKP
        DFPC                    ;GET THE HALTED PC
        TST     (R0)            ;DID WE GET AN ERROR
        BEQ     18$             ;NO...CLOEAN UP AND EXIT
        ERRMSG  <CONTROLLER >
        MOV     TSTCON,R0
        ERRCOM  PNTOCS
        FAULT   <WRITE NOT INHIBITED ON BAD ADR PAR>
18$:    SBUSDG  SDC05           ;CLEAR THE CONTROLLER
        SM                      ;AND THE CPU
        CLC                     
        BR      25$             ;EXIT
;-----LITTLE AC PROGRAM TO TEST THE INHIBIT WRITE ON BAD ADR PARITY FUNCTION.
        BLK10   1
19$:    IO10    CONO,PI,,4000000        ;1-FORCE BAD ADR PAR
        I10     SETCAM,16,,0,14 ;2-WR COMP OF EXISTING DATA TO MEM
        I10     CAME,16,,0,14   ;3-SKIP IF DATA DIDN'T CHANGE
        I10     JRST,4,,1       ;4-ELSE ERROR.. BAD ADR PAR DIDN'T INHIBIT WR
        I10     JRST,4,,0       ;5-NORMAL HALT
                                ;14-ADR LEFT OVER FROM SUBTEST 9
                                ;16-DATA PTRN LEFT OVER FROM SUBTEST 9
AEIWPM=000076

        ENDBLK


;SEQ224

;-----ERROR SECTION.
20$:    EXAMT,AC17,ERRADR       ;SAVE AC17 CAUSE NXMTST CLOBBERS IT
        JSR     PC,CHKED
        JSR     R5,NXMTST       ;NXM FOUND?
        BEQ     22$             ;NO...DATA OR ADR INTERF ERROR
21$:    PNTERA                  ;ERA WORD TO ERROR STACK
        ERRMSG  <\NXM ERROR>
        BR      24$             ;DO C-BIT SET EXIT
22$:    JSR     R5,RCAS3        ;DUMP ADR, CONTR, & MOD #
        JSR     R5,GDPM         ;DUMP ERROR WORDS
        CMP     R5,#3           ;DIE IN SUBTEST 3
        BNE     23$             ;NO
        ERRMSG  <\POSSIBLE READ-RESTORE ERROR>
        
23$:    ERRMSG  <\ADR TAG MEM TEST>
;-----EXIT SECTION
24$:    SEC                     ;C-BIT SET FOR ERROR RETURN
25$:    MOV     R5,R0           ;SUBTEST # TO R0
        RST.5           ;RESTORE THE REGS
        MOV     R0,(SP)         ;RETURN SUBTEST # IN R5
        RTS     R5


;SEQ225

.REM    %
        FWDRDTI --- THIS IS THE CONTINUATIN OF THE FOUR WORD READ TEST
        INITIALIZATIONS.  IT DOES THE NECESSARY THINGS COMMON TO ALL THE
        4 WORD READS TESTS.  THE PHYSICAL PAGE ADDRESS OF WHERE THE EPT
        IS EXPECTED IN R1 IN 16K FORMAT.  AFTER EDITING AND PLACING
        THIS ADDRESS IN THE PROGRAM, THE INIT THEN LOADS THE PROGRAM,
        WHICH, IT IS WORTH NOTING, ISD A MULTIPLE AC BLOCK PROGRAM.
        %
FWDRDI: MOV     R1,R0           ;16 K EPT ADR TO PARAM REG
        JSR     R5,REAP2        ;FORMAT IT
        BIS     #600,(R0)               ;ADD 600 FOR BASE ADR OF EXEC PAGE TABLE
        MOV     (R0),FWRTP1     ;PG TAB ADR TO 2 PRGM WDS
        MOV     (R0)+,FWRTP4
        MOVB    (R0),FWRTP1+2
        MOVB    (R0),FWRTP4+2
        SWAB    R1              ;CALC PG # FROM 16K EMT ADR
        CLC                     ;TO DO A "LOGICAL" SHIFT
        ROR     R1
        ASR     R1
        ASR     R1
        MOV     R1,FWRTX1       ;PAG # TO DATAO PAG WD IN AC BLK 1
        BIS     #20000,R1       ;"TRAP ENABLE" (PAGING ON) BIT
        MOVB    R1,FWRTX2       ;SET UP CONO PAG BITS 20-35
        SWAB    R1
        MOVB    R1,FWRTX2+1
        SM                      ;CLEAR THE MACHINE
        ACBLK   1               ;SELECT AC BLOCK 1.
        LOADAC  FWPM1,FWRTP1    ;LOAD AC1-17
        ACBLK   2               ;SELECT AC BLOCK 2.
        LOADAC  FWPM2,FWRTP2    ;LOAD AC2-17
        ACBLK   3               ;SLECT AC BLOCK 3.
        LOADAC  FWPM3,FWRTP3    ;LOAD AC5-17
        ACBLK   4               ;SELECT AC BLOCK 4.
        LOADAC  FWPM4,FWRTP4    ;LOAD AC1-17
        RTS     PC              ;INIT DONE


;SEQ226

;-----FOUR WORD READ TEST PROGRAM; AC BLOCK 1.
;       WRITES THE FOUR WORD PATTERN INTO THE FIRST FOUR WORDS OF THE
;       EXEC PAGE TABLE, VARYING THE PATTERN EACH TIME CONTROL RETURNS
;       HERE.  HALTS IF ALL 4 FOUR WORD PATTERNS HAVE BEEN DONE.
        BLK10   1
FWRTP1:                         ;0--<SETZM,SETOM>,,,0,1 GOES HERE
        WD36    0000,0000,0600  ;1--EXEC PAG TAB BASE ADR TO BE SUPPLIED
FWP1C:  WD36    1673,5701,1110  ;2--PROGRAM CONTROLLING PATTERN
FWP1A:  I10     TLNN,2,,777777  ;3--SKIP IF MORE TO DO
        I10     JRST,4,,0               ;4--ELSE DO NORMAL HALT
        I10     TRZ,1,,7        ;5--<START HERE>RESET PAG TAB BASE ADR
FWP1B:  I10     HRLZI,0,,402001 ;6--MOVE SETZM TO AC0
        I10     TRNE,2,,1       ;7--SKIP IF WE WANT ZEROS
        I10     HRLZI,0,,476001         ;10-ELSE PUT SFTOM IN 0
        I10     XCT,,,0                 ;11-MOVE 0S (OR 1S) TO PAGE TAB WD
        I10     LSH,2,,777777   ;12-SHIFT CONTROLLING PATTERN FOR NXT WD
        I10     TLNE,2,,1               ;13-SKIP IF 4 WDS WRTN TO PG TAB
        X10     AOJA,1,,FWP1B           ;14-ELSE INC ADR & GO DO NXT WD
        IO10    DATAO,PAG,,17           ;15-GO TO NXT AC BLK
        X10     JRST,,,FWP1A            ;160GO TO FIRST INSTR OF THIS BLK
FWRTX1: WD36    5021,0040,0000          ;17-AC BLK # & UPT PG # TO BE SUPPLIED
        ENDBLK  FWPM1
;-----FOUR WORD READ TEST PROGRAM; AC BLOCK 2.
;       DOES 8 MAP INSTRUCTIONS AFTER TURNING ON PAGING.  THE FIRST OF
;       THESE MAPS WILL DO A 4 WORD READ.  THE RESULTS OF THAT MAP AND
        
;       THE OTHER 7 ARE USED TO BUILD UP A RESPONSE PATTERN IN AC1.
        BLK10   2
FWRTP2:                         ;0--SCRTCH WORD
                                ;1--PATTERN BUILT UP HERE
        WD36    0000,1777,7000  ;2MASK TO LOOK AT PAGE # ONLY
        
FWP2A:  I10     HRLZI,1,,776000 ;3--INIT PTRN REG...BITS FORM LOOP CNT
        I10     HRRI,6,,20      ;4--INIT MAP ADR
FWRTX2: IO10    CONO,PAG,,000000        ;5--SET EPT PAG # & TURN ON PAGING
FWP2B:  I10     MAP,0,,000020           ;6--READ PAGE TABLE
        I10     LSH,1,,1                ;7--SHFT PTRN
        I10     TDNE,0,,2               ;10-SKIP IF PG # WAS 0
        I10     IORI,1,,1               ;11-ELSE MARK NON-0 PG # IN PTRN
        I10     ADDI,6,,1000    ;12-NEXT PAGE ADR FOR MAP INSTR
        X10     JUMPL,1,,FWP2B          ;13-LOOP IF MORE TO DO
        IO10    CONO,PAG,,0     ;14-SHUT OFF PAGING
        IO10    DATAO,PAG,,17   ;15-GO TO NXT AC BLK
        X10     JRST,,,FWP2A    ;16-GO TO FIRST INSTR OF THIS BLK
        WD36    4032,0000,0000  ;17-NXT AC BLK #
        ENDBLK  FWPM2


;SEQ227

;-----FOUR WORD READ TEST PROGRAM; AC BLOCK 3.
;       RETRIEVES THE PATTERN FROM AC BLOCK 2 AND MAKES SURE THAT IT IS
;       AS EXPECTED.  HALTS IF IT ISN'T.
        BLK10   5
FWRTP3:                         ;0--PATTERN FROM PREV AC BLK GOES HERE
                                ;1--ERA WORD GOES HERE
                                ;2--
                                ;3--
                                ;4--
FWP3A:  WD36    0300,1400,6003  ;5-PRGM CONTROL WD
 
FWP3B:  I10     MOVE,0,,1       ;6--USED TO ET PTRN FROM PREV BLK
FWP3C:  IO10    RDERA,,,1               ;7--READ THE ERA TO AC1

        X10     PXCT,4,,FWP3B   ;10-GET PTRN TO AC0
        X10     XOR,0,,FWP3A    ;11-COMP WITH XPCTD PTRN
        I10     TRNE,0,,377     ;12-SKIP IF SAME IN BITS THAT COUNT
        I10     JRST,4,,1       ;13-ELSE 4 WD RD ERROR
        I10     LSH,5,,777770   ;14-SHIFT PTRN FOR NEXT TIME
        IO10    DATAO,PAG,,17   ;15-GO TO NEXT AC BLOCK
        X10     JRST,,,FWP3C    ;16-GO TO FIRST INSTR IN THIS AC BLK
        WD36    4043,0000,0000  ;17-0PTR TO NXT AC BLK
        ENDBLK  FWPM3
;-----FOUR WORD READ TEST PROGRAM; AC BLOCK 4.
        
;       RE-READS THE 4 WORD PTTERN FROM THE EPT TO MAKE SURE THAT
;       READS-RESTORES WERE DONE PROPERLY DURINF THE 4 WORD READ.  HALTS
;       IF ERROR DETECTED, ELSE GOES BACK TO AC BLOCK 1 FOR NEXT PATTERN
        BLK10   1
FWRTP4:                         ;0--SCRATCH
        WD36    0000,0000,0000  ;1--EXEC PG TAB BASE ADR TO BE SUPPLIED
FWP4D:  WD36    1673,5701,1110  ;2--PROG CONTROLLING WD
FWP4A:  I10     MOVE,0,,0,1     ;3--EXECUTED TO GET WD FROM PG TABLE
FWP4B:  I10     TRZ,1,,7        ;4--RESET PG TABLE ADR
FWP4C:  X10     XCT,,,FWP4A     ;5--RD BACK TO PG TABLE WD
        I10     TRNE,2,,1               ;6--SKIP IF WD WAS SUPPOSED TO BE 0.
FWSETC: I10     SETCM,0,,0      ;7--ELSE CHNG -1 TO 0
        I10     SKIPE,,,0       ;10-SKIP IF THE WD IS STILL OK
        I10     JRST,4,,2       ;11-ELSE HALT...4 WD RD-RESTORE ERR
        I10     LSH,2,,777777   ;12-SHIFT CONTROLLING PTRN
        I10     TLNE,2,,1       ;13-SKIP IF ALL 4 WDS CHECKED
        X10     AOJA,1,,FWP4C   ;14-ELSE GO BACK & DO NEXT WORD
        IO10    DATAO,PAG,,17   ;15-GO BACK TO FIRST AC BLOCK
        X10     JRST,,,FWP4B    ;16-GO TO FIRST INSTR OF THIS BLK
        WD36    4014,0000,0000  ;17-NXT AC BLK POINTER
        ENDBLK  FWPM4


;SEQ228

.REM    %
        THE FOUR WORD READ TEST CHECKS THE ABILITY OF MEMORY CONTROLLERS
TO PROPERLY DO A 4 WORD READ.  THE TEST USES THE ONLY PIECE OF HARDWARE
GUARANTEED TO BE ON A KL10 SYSTEM WHICH WILL DO A 4 WORD READ:  THE PAGER.
THE PAGER IS STIMULATED BY USING A MAP INSTRUCTION.  AFTER THE PAGER IS
CLEARED BY A CONO PAG, 8 MAP INSTRUCTIONS ARE DONE, THE FIRST OF WHICH
CAUSES A PAGE REFILL:  A 4 WORD READ, WORD 0 FIRST.
        THE PATTERN IN THE EXEC PAGE TABLE (EPT+600) CONSITS OF 3 ZERO
WORDS AND A -1 WORD.  SINCE THE INFORMATION RETURENED BY THE MAP INSTRUC-
TION REFLECTS THE CONTENTS OF A HALFWORD, 8 MAPS ARE NECESSARY TO
CHECK 4 WORDS.  ALSO, SINCE IT IS KNOWN ONLY THAT THE PAGER CAN HOLD
ZEROS AT THIS POINT IN THE TEST SEQUENCE) THE OCCURANCE OF A 1 BIT IS
TAKEN TO MEAN THAT THE CORRESPONDOJGN HALFWORD WAS ALL ONES.  IN THIS
MANNER A HALFWORD RESPONSE PATTERN IS BUILD UP WHICH IS THEN CHECKED
AGAINST THE EXPECTED RESPONSE PATTERN.
        AFTERTHIS IS DONE THE PAGE TABLE IS CHECKED TO MAKE SURE THAT
IT IS UNCHANGED.  A FAILURE HERE INDICATES THAT THE READ-RESOTRES OF
THE 4 WORD RED WERE UNCUCCESSFUL.  IF THE PAGE TABLE IS OK THE PROCE-
DURE IS REPEATED WITH THE NEXT 4 WORD PATTERN.
        IF AN ERROR IS DETECTED THE PDP11 STARTS A FAST LOOP RUNNING IN
THE KL10.  IT IS A 3 INSTRUCTION LOOP WHICH DOES 4 WORD READS.  SYNC ON
"MEM STARTL" WHICH IS CPU PIN DV2, SLOT22.
        %
;-----RUN THE AC PROGRAM AND CHECK THE HALT CODE (PC).
FWDRDT: RSTMBX                  ;CLEAR THE MACHIN
        ACBLK   1               ;SELECT STARTING AC BLOCK
        INSYNC                  ; ***** NEXT SUBTEST *****
        RUN     AC5             ;RUN THE AC PROGRAM
        JSR     PC,CHKP
        DFPC                    ;GET THE PC (THE HALT CODE)
        MOV     (R0),R5         ;MAKE HALT CODE THE SUBTEST NUMBER
        CMP     R5,#1           ;WAS HALT CODE 0, 1 OR 2?
        BEQ     1$              ;BR ON 1...APPARENT 4 WD RD ERR
        BGT     6$              ;BR ON 2...READ-RESTORE EROOR
        CLC                             ;INDICATE NO ERROR
        RTS     PC              ;RETURN TO CALLER


;SEQ229

;-----SECTION TO REPORT A 4 WORD READ ERROR.  BEFORE DOING THIS WE MUST
;       CHECK TO MAKE SURE THAT THE PROPER ADDRESS WAS GENERATED BECAUSE
;       IS POSSIBLE (DUE TO TEST SEQUENCE)THAT THE PAGE TABLE ADDRESS
;       WAS NOT PROPERLY GENERATED.  IF THIS IS THE CASE, THEN THE ERROR
;       IS MOST PROBABLY ON THE PMA BOARD.
1$:     EXAMT,AC1,ERRADR                ;GET THE ERA WORD FROM AC 1
        JSR     PC,CHKED
        MSKDAT  REAPWD,5$               ;CHK THE ADR USED BY THE 4 WD RQ
        BCC     2$              ;BR IF PAGER OK
        TST     (SP)+           ;ELSE PAGER FAULT
        JSR     PC,3$           ;GO START HARD LOOP 
        FAULT   <ADR GENERATION ERR DURING 4 WD RD TEST>
2$:     PWTES   TSTCON          ;TEST CONTROLLEWR # TO ERR STK
        ERRMSG  <EPT WORD PATTERN BY HALFWORDS:>
        EXAMT,AC5,PTM           ;GET EXPECTED PATTERN
        ACBLK   2               ;SELECT AC BLOCK 2
        EXAMT,AC1,PFM           ;GET ACTUAL PATTERN
        JSR     PC,CHKED
        MASK16  PTM,PFM,177400  ;DUMP ERR INFO ON STK
        TSTB    ALTCON          ;IF ALTCON >= 0, USING 2 CONTROLLERS
        BGE     3$              ;SO DON'T PRINT SBUS DIAG STUFF
        SBUSDG  ZERO.           ;GET CONTROLLER INFO
        ERR36T  <SBDIAG FUNC 0: >,EXAREA


;SEQ230

;-----ERROR EXIT SECTION START FAST LOOP RUNNING.
3$:     ERRCOM  PCRLF           ; <CRLF> TO ERR STK
        ACBLK   2               ;SELECT AC BLOCK 2
        LOADAC  ACC7,4$         ;LOAD JRST,,,5 IN AC7
        RUN     AC4             ;TURN ON FAST LOOP
        SEC                     ;SET C-BIT FOR ERROR RETURN
        RTS     PC              ;RETURN TO CALLER
4$:     I10     JRST,,,5                ;FOR FAST LOOP
5$:     WD36    7777,6000,0003  ;MASK OFF 0-13, 34-35


;SEQ231

;-----SECTION TO HANDLE READ-RESTORE ERROR.
6$:     PWTES   TSTCON          ;TEST CONTROLLER # TO ERRSTK
        EXAMT,AC2,PTM           ;GET CONTROL BITS WORD
        JSR     PC,CHKED
        MOV     #ZERO..,8$      ;ASSUME EXPECTED PATTERN IS 0S
        BIT     #1,(R0)         ;WAS PTRN ZEROS?
        BEQ     7$              ;YES
        MOV     #SEVENS,8$              ;ELSE MAKE PTRN 1S
        CXQT    FWSETC          ;"INCOMPLEMENT" PATTERN
7$:     EXAMT,AC0,PFM           ;GET PATTERN FROM MEMORY

        JSR     PC,CHKED
        JSR     R5,MSKDAT               ;ERR DATA TO ERR STK
        .WORD   ZERO..          ;MASK
8$:     .WORD   000000          ;XPCTD VAL PTR TO BE SUPPLIED
        ERRMSG  <\WORD >

        EXAMT,AC1,ERRADR                ;GET ERROR ADDRESS
        MOV     (R0),R0         ;GET RHE OF ADR
        BIC     #-4,R0          ;DE-JUNK
        ERRCOM  PNTOCS
        BR      3$              ;DO ERROR EXIT


.REM    %
        MEMORY TEST FAULT DATA DUMPING SUBROUTINES.  THESE ROUTINES
DEPEND ON:
        AC15    DATA PATTERN BACK FROM MEMORY
        AC16    DATA PATTERN SENT TO MEMORY
        AC17    ADDRESS UNDER TEST
        %
;-----SUBROUTINES TO GET & STACK PATTERN DATA.
GDP:    EXAMT,AC15,PFM          ;GET PATTERN FRLM MEM
        JSR     PC,CHKED
        EXAMT,AC16,PTM              ;GET PATTERN SENT TO MEM
        RTS     R5
GDPM:   JSR     R5,GDP          ;GET PATTERN DATA
        MASK36  PTM,PFM,ZERO..  ;DUMP MASK STUFF TO ERR STK
        RTS     R5
PFM:    .WORD   0,0,0
PTM:    .WORD   0,0,0

;-----SUBROUTINE TO DUMP ADDRESS, CONTROLLER, & MODULE # TO ERR STK.
RCAS:   EXAMT,AC17,ERRADR               ;GET ADR OF FAULT
        JSR     PC,CHKED
RCAS3:  ERRADR  ERRADR          ;ERROR ADR TO ERR STK
RCAS2:  ERRMSG  <   CONTROLLER: >
        MOVB    TSTCON,R0
        ERRCOM  PNTOCS
        TSTB    TSTMOD+1        ;MEM MOD CURRENTLY UNDER TEST?
        BNE     1$              ;NO...DONT PRINT MOD INFO
        ERRMSG  <   STORAGE MOD: >
        MOVB    TSTMOD,R0
        ERRCOM  PNTOCS
1$:     ERRCOM  PCRLF
        RTS     R5


;SEQ233

.SBTTL          DISPATCH DETERMINATION ROUTINES
.REM    %
        TEST#1 SETUP DETERMINES MEMORY CONFIGURATION
%
I.1:    BR      1$              ;BYPASS LOAD IF LOOP
        MEMRST
        TST     FAULTS          ;ANY FAULTS DETECTED?
        BNE     2$              ;YES, BYPASS DETERMINATION
1$:     SBUPRG                  ;***** REMOVE WHEN CONDET FIXED *****
        JSR     R5,CONDET               ;DETERMINE MEM CONFIGURATION
2$:     RTS     PC              ;INIT DONE


;SEQ234

.REM    %
        TEST#1 IS THE MEMORY SYSTEM CONFIGURATION BVALIDITY CHECK.
        %
;-----THIS TEST IS CONSTRIUCTED AS FOLLOWS:  THE INIT CALLS ROUTINES IN THE MEMORY
;CONFIGURATOR TO DETERMINE THE PHYSICAL CONFIGURATION OF THE MEMORY SYSEM.
;THE TEST FIRST DETERMINES IF THERE WAS ANY RESPONSE TO THE SBUS DIAG DONE.
;NEXT THE TEST CYCLES THROUGH THE CONTROLLERS (37 TO 0) AND CHECKS TO SEE THAT
;THE PROPER CONTROLLER TYPES ARE RESPONDING TO EACH CONTROLLER#, AND THAT THE
;RESPONSE OF EACH CONTROLLER TYPE IS CORRECT.

T.1:    INC     R5              ;  *****SUBTEST 1 *****
        TST     DMA20           ;ANY DMA20 OR UNDEFINED TYPES?
        BNE     1$              ;YES...OK
        TST     MA20            ;ANY MA20 OR MB20 CONTROLLERS?
        BNE     1$              ;YES...OK
        TST     MX20            ;ANY MX20 OR MF20?
        BNE     1$              ;YES, GO ON
        PWTES   #0              ;ERROR TYPE 0
        FAULT   <NO RESPONSE TO SBUS DIAG FUNC 1>


1$:     MOV     #37,R4          ;INIT R4 9THE CONTROLLER #)
;-----TOP OF CONROLLER LOOP.  PICK UP DATA FROM MCON TABLES
T1L:    MOVB    TYPNUM(R4),R1   ;CONTROLLER TYPE
        BIC     #177600,R1      ;CLR "TESTED" BIT
        MOVB    MODNUM(R4),R2   ;RESPONDING MODULES
        MOVB    SBUSEN(R4),R3   ;SBUS REQUESTS ENABLES (SHD B NONE)
        MOVB    CATDSP(R4),R0   ;DISPATCH TO PROPER SUBRTIN FOR THIS
        JMP     @CAT(R0)        ;...CONTROLLER NUMBER.
;-----END OF CONTROLLER LOOP.  CYCLE THRU ALL CONTROLLER NUMBERS.
T1EL:   DEC     R4
        BGE     T1L
        BITB    #BIT0,DEVFLG    ;PHYS CONFIG. PREV REPORTED?
        BNE     1$              ;YES, RETURN
        JSR     R5,REPCON       ;REPORT MEM CONFIGURATION
        BISB    #BIT0,DEVFLG    ;MARK PHYS CONFIG REPORTED
1$:     NORMAL
;-----CONTROLLER NUMBER DISPATCH TABLES.
CATDSP: .BYTE   0,0,0,0 ;CONTR 0-3
        .BYTE   2               ;CONTR 4
        .BYTE   4               ;CONTR 5
        .BYTE   10,10           ;CONTR 6-7
        .BYTE   6,6,6,6,6,6,6,6 ;CONTR 10-17
        .BYTE   4,4,4,4,4,4,4,4 ;CONTR 20-27
        .BYTE   6,6,6,6,6,6,6,6;CONTR 30-37
CAT:    .WORD   C0.3,C4.,CUNDEF,C10.17,C6.7     ;ADRS OF CONTR # SUBRTNS


;SEQ235

;-----SUBROUTINE FOR CONTROLLERS 0 TO 3.  CURRENTLY ONLY MA20'S OR
;       MB20'S SHOULD RESPOND TO THESE CONTROLLER NUMBERS.
C0.3:   JSR     R5,MA20C        ;;CHK FOR MA20 CONTROLLER
        BCC     T1EL            ;FOUND & OK...DO NXT CONTR
        JSR     R5,MB20C        ;CHK FOR MB20 CONTR
        BCC     T1EL            ;FND & OK...DO NXT CONTR
        BR      NOC             ;CHK FOR  NO CONTR.
;-----SUBROUTINE FOR CONTROLLER 4.  CURRENTLY ONLY THE DMA20 DSHOULD
;       RESPOND HERE, OR THERE SHOULD BE NO CONTROLLER AT ALL.
C4.:    JSR     R5,DMA20C       ;CHK FOR DMA20
        BCC     T1EL            ;FND & OK ...DO NXT CONTR
        
        BR      NOC             ;CHK FOR NO CONTR
;-----SUBROUTINE FOR POSSIBLE MF20 RESPONSES.  WILL BE 10-17 OR
;        30-37 WITH MX20.
C10.17: JSR     R5,MF20C        ;CHK FOR MF20
        BCC     T1EL            ;BR IF FOUND.. OK
        BR      NOC             ;ELSE LOOK FOR NO CONTR
;-----SUBROUTINE FOR MX20.
C6.7:   JSR     R5,MX20C                ;CHK FOR MX20
        BCC     T1EL            ;BR IF FOUND...OK 
;       BR      NOC             ;CHK FOR NO CONR
;-----SUBROUTINE FOR CONTROLLER NUMBERS 5-37.  CURRENTLY THERE SHOULD
;       BE NO RESPONSE FROM THESE CONTROLLER NUMBERS.
CUNDEF:
NOC:    JSR     R5,NONEXC               ;CHK FOR NO CONTROLLER
        BCC     T1EL            ;NONE FOUND...OK...DO NXT CONTR
;       BR      UNDEFC          ;ELSE UNDEFINED CONTROLLER OR CONTROLLER
                                ;RESPONDING TO WRONG CONTROLLER #
;-----SECTION TO PRINT UNDEFINED CONTROLLER TYPE OR CONTROLLER
;       RESPONDING TO WRONG CONTROLLER # MESSAGE.
UNDEFC: CMP     R1,#4           ;UNDEFINED TYPE?
        BLT     2$              ;NO...CONTR RESP TO WRONG #
        PWTES   #1              ;ERROR TYPE...UNDEFINED CONTR TYPE
        JSR     R5,MFEDDX               ;DUMP CONTR DATA TO ERR STK
        ERRMSG  < IS OF UNDEFINED TYPE: >
1$:     MOV     R1,R0           ;CONTR TYPE TO PARAM REG
        ERRCOM  PNTOCS          ;MOVE TO ERR STK
        FAULT                   ;FAULT CALL TO DIACON
2$:     PWTES   #2              ;ERROR TYPE 2...WRONG CONTR TYPE FOR #
        JSR     R5,MFEDDX               ;DUMP CONTR # DATA TO ERR STK
        ERRMSG  < HAS INVALID CONTROLLER TYPE RESPONDING: >


;SEQ236

        BR      1$


;SEQ237

;-----MACRO FOR WHAT FOLLOWS.
.MACRO  MFEDD   X,Y
          JSR   R5,MFEDD        ;GO DUMP JUNK TO ERR STK
          .WORD X               ;ERROR TYPE X
        .ASCIZ  %Y%             ;MERROR MESSAGE
        .EVEN
        .ENDM   MFEDD
;-----SUBROUTINES FOR MA20 & MB20 TYPE CONTROLLERS.
MB20C:  CMP     R1,#3           ;MB20 CONTROLLER?
        BR      MA20C+4         ;CONTINUE CHECK
MA20C:  CMP     R1,#1           ;MA20 CONTROLLER TYPE 
        BEQ     1$              ;YES...CHECK FURTHER
        JMP     SECRET          ;NO...DO CBIT SET RETURN
1$:     MOV     R4,R0           ;MAKE SURE EVEN/ODD CONTR TYPES MATCH
        EXOR    #1,R0                   
        MOVB    TYPNUM(R0),R0   ;GET ALTERNATE CONTR TYPE
        BIC     #177600,R0      ;CLR "TESTED" BIT
        CMP     R0,R1           ;SAME TYPES?
        BEQ     2$              ;BR IF MATCH...OK
        MFEDD   10.,<EVEN/ODD CONTROLLER PAIR TYPE MISMATCH>
2$:     BIT     #17,R2          ;SM0-3 REPORTED?
        BNE     3$              ;YES...OK
        MFEDD   3,<NO STORAGE MODULES>
3$:     BIT     #360,R2         ;SM 4-7 REPORTED?
        BEQ     4$              ;NO...OK
        MFEDD   4,<MODULE(S) 4-7>
4$:     TST     R3              ;ANY SBUS REQUESTS ENABLES STILL SET?
        BEQ     CLCRET          ;NO...OK
                MFEDD   5,<SBUS RQ ENABLE(S) SET AFTER SBUS RESET>


;SEQ238


;-----SUBROUTINE FOR THE DMA20 CONTROLLER.
DMA20C: CMP     R1,#2           ;CONTR TYPE 2 (DMA20)?
        BNE     SECRET          ;NO...DO CBIT SE RETURN
        TST     R2              ;ANY STORAGE MODULES?
        BEQ     1$              ;NO...OK
        MFEDD   6,<STORAGE MODULE(S)>
1$:     TST     R3              ;SBUS REQUEST ENABLES SET?
        BEQ     CLCRET          ;NO...OK...CBIT CLR RETURN
        MFEDD   7,<SBUS RQ ENABLE(S)>

        ;-----CHECK NUMBER OF MF20 CONTROLLER.
MF20C:  CMP     R1,#5           ;IS THIS CONTR AN MF20?
        BNE     SECRET          ;YES
        BR      CLCRET          ;NO
;-----CHECK NUMBER OF MX20 CONTROLLER.
MX20C:  CMP     R1,#4           ;IS THIS CONTR AN MX20?
        BEQ     CLCRET          ;YES
;       BNE     SECRET          ;NO
;-----RETURN ROUTINES.
SECRET: SEC
        RTS     R5
CLCRET: CLC     
        RTS     R5


;SEQ239

;-----SUBROUTINE FOR NON-EXISTANCE OF A CONTROLLER.
NONEXC: TST     R1              ;NON-EX CONTROLLER TYPE (0)?
        BNE     SECRET          ;NO...CBIT SET RETURN
        TST     R2              ;ANY STORAGE MODULES?
        BEQ     1$              ;NO...OK
        MFEDD   8.,<STORAGE MODULE(S)>
1$:     TST     R3              ;ANY RQ ENBS?
        BEQ     CLCRET          ;NO...OK...DO CBIT CLR RET
        MFEDD   9.,<SBUS RQ ENABLE(S)>
;-----ERROR DATA DUMPER FOR MEMORY CONTROLLER TYPES.
MFEDD:  MOV     (R5)+,R0        ;GET ERR TYPE
        PWTES                   ;MOV IT TO ERR STK
        JSR     R5,MFEDDX       ;DUMP CONTR JUNK TO ERR STK
        ERRMSG  <(TYPE>
        ASL     R1              ;PRINT CONTROLLER TYPE
        MOV     MEMTYP(R1),R0
        ADD     #2,R0   
        ERRCOM  PNTAL
        ERRMSG  <) REPORTS >
        MOV     R5,R0           ;PRINT ERR MSG SPECIFIED
        ERRCOM  PNTAL
        TST     (SP)+           ;RESET STK
        CLR     R5              ;NO SUBTESTS
        FAULT
;-----SUBROUTINE TO DUMP CONTROLLER # JUNK TO ERR STK
MFEDDX: MOV     R4,R0           ;CONTR # TO ERR STK
        PWTES
        PWTES   #DMA20I         ;ADR OF DMA20I IN MCON TO ERR STK
        ERRMSG  <MEMORY CONTROLLER #>

 

;SEQ240

        MOV     R4,R0
        ERRCOM  PNTOCS
        RTS     R5


;SEQ241


;SEQ249

;-----ROUTINE TO DISPATCH TO A GIVEN TEST INIT.
IDISP:  MOV     TSTNUM,R0       ;GET TEST #
        ASL     R0              ;DOUBLE TO USE AS DISP INTO INITAB
        MOV     INITAB(R0),R0   ;GET INIT ADR FROM TAB
        BGE     1$              ;GRE IF BIT15 NOT SET
        ADD     #100002,R0     ;ELSE FIX UP ADR
1$:     JMP     (R0)            ;ANG GO TOINT
.REM    %
        TEST#2 SETUP DETERMINES TEST DISPATCHING FOR MEMORY 
CONTROLLER TESTS.  IF THE TEST IS STARTED AT A CONTROLLER TEST,
ONLY ONE CONTROLLER WILL BE TESTED.  THE CONTROLLER ADDRESS WILL
THEN BE SOLICITED.  IF THE TEST IS RUN IN A NORMAL FASHION, ALL
WILL BE TESTED.  INTERNAL MEMORY TESTS PRECED EXTERNAL MEMORY.
INTERNAL MEMORIES ARE TESTED IN NUMERIC,L ORDER.
%
I.2:    BR      I2GO            ;BYPASS SELECTION IF LOOP
        CLRB    MBFLAG          ;CLEAR MB20 FLAG
        MOVB    #-1,ALTCON      ;MARK NO ALTERNATE CONTROLLER FRO NOW
        MOV     TSTART,R0       ;GET TEST START
        CMPB    R0,#FIMCT       ;START AT CONTROLLER TEST?
        BLT     LOWCON          ;NO, FIND A CONTROLLER
        CMPB    R0,#LIMCT
        BLE     2$              ;YES, PERMIT SELECTION
        CMPB    R0,#LEMT        ;START DMA20 TEST?
        BGT     1$              ;NO
        MOV     #4,R0           ;YES, CONTROLLER # IS 4
        BR      EXTMEM          ;SELECT IT
1$:     CMPB    R0,#377         ;XOR INITIALIZATION?
        BEQ     LOWCON          ;YES, SELECT A CONTROLLER
        JMP     MEMSET          ;BYP[ASS CONTROLLERS

2$:     TSTB    DEVFLG+1        ;TESTING A CONTROLLER NOW?
        BNE     NOSEL           ;YES, BYPASS SELECTION
        SWITCH
        BIT     #CHAIN,R0               ;SKIP REPORT IF CHAIN SW SET
        BNE     CONADR
        JSR     R5,REPCON               ;NO, REPORT CONFIGURATION
CONADR: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <MEM CONTROLLER #: _>
        
1$:     TTILIN
        BCS     1$              ;WAIT FOR REPLY
        TTIOCT                  ;CONVERT OCTAL FORMAT
        BCS     REPBAD          ;IMPROPER FORMAT
        CMP     R0,#37          ;VALID ADDRESS?
        BGT     REPBAD          ;NO
        CMP     R0,#4           ;DID THE OPR TYPE 4?  (DMA20)
        BNE     EXTMEM          ;IF NOT, JUST KEEP GOING
        TSTB    DMA20           ;ELSE IS THERE A DMA20?
        BEQ     EXTMEM          ;IF NOT, ASSUME INT MEM CONTR 4
        MOV     #FEMT,TSTART            ;ELSE FORCE TEST START AT DMA20 TESTS.
EXTMEM: MOVB    TYPNUM(R0),R1   ;FETCH CONTROLLER TYPE
        INCB    DEVFLG+1        ;INDICATE SPECIFIC CONTR UNDER TEST
        PNORML          ;NORMAL TYPEOUTS
        BR      SELDON          ;SELECTION DONE


;SEQ250

REPBAD: PMSG    <?\>            ;REPLY BAD
        BR      CONADR          ;TRY AGAIN
DMAOPT: MOV     #FEMT,TSTNUM    ;INITIALIZE DMA20
        BR      IDISP           ;GO DO FIRST X MEM TSAT
I2GO:   JMP     I.2A            ;CAUSE BR CAN'T GO THAT FAR....
LOWCON: MOV     #2,R1           ;FIND LOWEST CONTROLLER
        TST     MA20            ;ANY MA OR MB20?
        BEQ     2$              ;NO, USE DMA20
        TSTB    MA20            ;ANY MA20?
        BEQ     1$              ;NO, USE MB20
        DEC     R1              ;TYPE = 1
        BR      2$              ;FIND IT
1$:     INC     R1              ;TYPE = 3
2$:     CLR     R0              ;ADDRESS TO CHECK
MATCON: CMPB    R1,TYPNUM(R0)   ;TYPE MATCH?
        BEQ     SELDON          ;YES
        INC     R0              ;NO, TRY NEXT ONE
        BR      MATCON          ;
NOSEL:  MOVB    TSTCON,R0                ;GET ADDRESS FOR TEST
        MOVB    TYPNUM(R0),R1   ;GET TY[E
SELDON: MOVB    R0,TSTCON               ;CONTROLLER ADR FOR TEST
        BMI     REPBAD          ;NEG # NOT ALLOWED
        CMP     R0,LSTCNP       ;WAS THIS CONTR # THE LAST ONE PRINTED?
        BEQ     1$              ;YES...DON'T RE-PRINT
        MOV     R0,LSTCNP       ;ELSE SAVE NUMBER FOR NXT TIM
        CMPB    TSTART,#377     ;XOR INITIALIZATION?
        BEQ     1$              ;YES, BYPASS PRINT

        PMSG    <***** MEM CONTROLLER >
        MOVB    TSTCON,R0               ;PRINT CONTROLLER #
        PNTOCS                  ;
        PCRLF                   ;
1$:     TSTB    TSTMOD+1                ;MODULE SPECIFICALLY SELECTED?
        BEQ     2$              ;IF YES, DON'T REET IT
        MOV     #-1,TSTMOD              ;SET MODULE = 0
2$:     ASL     R1              ;MULTIPY TYPE # BY 2
        JMP     @CONTBL(R1)     ;GO TO CONTROLLER TEST
CONTBL: .WORD   NXTCON          ;CUSTOMER TYPE, BYPASS
        .WORD   MAOPT           ;MA20 TEST
        .WORD   DMAOPT          ;DMA20 TEST
        .WORD   MBOPT           ;MB20 TEST
        .WORD   REPBAD          ;UNDEFINED TYPE
MBOPT:  MOVB    #2,MBFLAG       ;SET MB20 OPTION FLAG...2 FOR INDEX
MAOPT:


;SEQ251

.SBTTL          MA20/MB20 CONTROLLER TESTS
.REM    %
        ;THIS PORTIO OF THE INITIALIZATION IS USED FOR MA/MB20
        ;TESTS.  IT SETS THOSE FLOPS CLEARED BY A CONTROLLER
        ;RESET.
        %
I.4:    
I.2A:   SBUSDG  SF07S           ;SET INTRLV & WD RQ BITS
        SBUSDG  SF17S           ;SET ADR BOUNDS BITS
        RTS     PC              ;RETURN
SF07S:  WD36    0077,4000,0000  ;BINARY IS FOR SBUS FN 0
SF17S:  WD36    0000,5777,7341  ;BINARY IS FOR SBUS FN 1
MBFLAG: .BYTE   0               ;MBW0 OPTIIN FLAG
ALTCON: .BYTE   -1              ;ALTERNATE CONTR FOR INT MEM 4 WD RD TESTS
        .EVEN

;SEQ252

.REM    %
        **** TEST#2 CHECKS THE SELECTED MA/MB20
CONTROLLER RESET FUNCTION.
%
T.2:    INSYNC                  ;*****SUBTEST 1 *****
        MEMRST
        SBUSDG  ZERO.
        MSKDAT  ZERO..,MSNIME   ;CHEK FOR O, IGNORE ERR BIS MEMRST LEAVES
BCC             1$              ;O.K.
        PWTES   TSTCON          ;CONTR # TO ERR STK
        FAULT   <SBUS RESET/ SBUS DIAG F0>
1$:     SBUSDG  SDCLB
        MSKDAT  ZERO..,M12.35   ;TEST 12-35 ZERO.
        BCC     2$              ;O.K.
        PWTES   TSTCON          ;CONTR # TO ERR STK
        FAULT   <SBUS RESET/ SBUS DIAG F1>
2$:     NORMAL
M12.35: WD36    7777,0000,0000  ;

        .EVEN


;SEQ253

;SEQ255

.REM    %
        TEST#3 SETUP PERFORMS A CONTROLLER RESET.
%
I.3:    JSR     R5,MEMRST               ;RESET MEMORY CONTROLLERS
        RTS     PC              ;RETURN

.REM    %
        *****TEST #3 CHECKS SETTING OF MA/MB20 FLIP-FLOPS WHICH
MAY BE SET ON SBUS DIAG.

%
T.3:    INSYNC                  ;*****SUBTEST 1 *****
        SBUSDG  SF07S           ;SET INTLV & RQ EN
        MSKDAT  XV4WI,MSNIME    ;CHECK SET
        BCC     1$              ;O,.K.
        PWTES   TSTCON          ;CONTR # TO ERR STK
        FAULT   <SBUS DIAG SET INTLV>
1$:     MOV     #SF11S,R2               ;
2$:     INSYNC                  ;****SUBTESTS 2,3 & 4 *****
        MOV     R2,R0           ;
        SBUSDG                  ;SET BOUNDARY & A MARGIN
        MSKDAT  SD11S,M12.35    ;CHECK SET
        BCC     5$              ;O.K.
        PWTES   TSTCON          ;CONTR # TO ERR STK
        CMP     R5,#3           ;
        BGE     3$              ;
        FAULT   <ADR BNDRY, RQ EN, CURRENT MARGIN>


;SEQ256

3$:     BGT     4$
        FAULT   <STROBE MARGIN>

4$:     FAULT   <THRSHLD MARGIN>
5$:     ADD     #5,R2           ;NEXT OPERAND
        CMP     R5,#4           ;DONE?
        BLT     2$              ;LOOP AGAIN
        NORMAL

SF11S:  WD36    0000,5777,7101  ;SET LOOP, ADR CURRENT
        WD36    0000,5777,7201  ;SAME ONLY STROBE
        WD36    0000,5777,7401  ;SAME ONLY THRESHOLD
SD11S:  WD36    0000,5777,6057  ;READBACK FN 1

        .EVEN


;SEQ257


;SEQ259

.REM    %
        TEST#4 SETUP SETS MA/MB20 FLIP-FLOPS WHICH MAY BE
SET BY AN SBUS DIAG.
%
.REM    %
        ****TEST#4 CHECKS CLEARING OF MA/MB20
FLIP-FLOPS WHIH MAY BE SET ON SBUS DIAG.
%
T.4:    INSYNC                  ;****SUBTEST 1 ****
        SBUSDG  SF00S           ;CLEAR INTLV & RQ EN
        MSKDAT  ZERO..          ;CHECK CLEAR
        BCC     1$              ;O.K.
        PWTES   TSTCON          ;CONTR # TO ERR STK
        FAULT   <SBUS DIAG CLR INTLV>
1$:     INSYNC                  ;****SUBTEST 2****
        SBUSDG  SF10S           ;CLEAR BOUNDRY & MARGINS
        MSKDAT  ZERO..,M13.35   ;CHECK CLEAR
        BCC     2$              ;O.K.
        PWTES   TSTCON          ;CONTR # TO ERR STK
        FAULT   <SBUS DIAG CLR ADR BNDRY, RQ EN, MARGINS>
2$:     NORMAL
SF00S:  WD36    0100,4000,0000  ;CLR 0-5, INTLV, SBUS RQS

SF10S:  WD36    0000,0000,1041  ;CLR ADR FNDS, MARGINS
M13.35: WD36    7777,4000,0000

        .EVEN


;SEQ260


;SEQ262

.REM    %
        TEST#5 SETUP LOADS AN INSTRUCTION IN AC10 TO SUPPORT
THE TEST.  IT IS AS FOLLOWS:
        10:     MOVE    AC17,0(7)
%
I.5:    BR      1$              ;BYPASS LOAD IF LOOP
        LOADAC  ACC10,RDMEM
1$:     RTS     PC              ;RETURN

.REM    %
        *****TEST#5 CHECKS MA20 ENABLES & ADDRESS BOUNDRES FOR
RESPONSE CONDITIONS.  SUBTESTS 1-4 CHECK THE REQUESTS.
        %
T.5:    JSR     R5,RSTMBX       ;RESET MBOX
        PWTES   TSTCON          ;PUT TEST CONTR # ON ERR STK
        INSYNC                  ; *****SUBTEST 1 *****
        SBUSDG  ENMA20          ;SET ALL RQ EN/1 WAY INTERLEAVE
        MOV     #2,R2           ;LOWR = 0. UPPER = 0
        JSR     R5,SWSET                ;SET SWITCHES
        CXQT    RQEN0           ;READ ADDR 100
        JSR     R5,NXMTST               ;CHECK RESPONSE
        BEQ     1$              ;O.K. 
        FAULT   <NO RESPONSE ADR SW = 0, RQ0>
1$:     INSYNC                  ; ****SUBTEST 2 *****
        CXQT    RQEN1           ;READ ADDR 101
        JSR     R5,NXMTST               ;CHECK RESPONSE
        BEQ     2$              ;O.K.
        FAULT   <NO RESPONSE, RQ1>


;SEQ263

2$:     INSYNC                  ;*****SUBTEST 3 *****
        CXQT    RQEN2            ;READ ADDR 102
        JSR     R5,NXMTST               ;CHECK RESPONSE
        BEQ     3$              ;O.K.
        FAULT   <NO RESPONSE, RQ2>
3$:     INSYNC                  ;*****SUBTEST 4 *****
        CXQT    RQEN3           ;READ ADFR 103
        JSR     R5,NXMTST       ;CHECK RESPONSE
        BEQ     4$              ;O.K.
        FAULT   <NO RESPONSE, RQ3>
4$:     NORMAL


;SEQ264

ENMA20: WD36    0137,4000,0000
RQEN0:  I10     MOVE,AC17,,100
RQEN1:  I10     MOVE,AC17,,101
RQEN2:  I10     MOVE,AC17,,102
RQEN3:  I10     MOVE,AC17,,103
D14.21: WD36     0000,1774,0000
M14.25: WD36    7777,6000,1777

        .EVEN


;SEQ265

        ;THIS SUBROUTINE SETS & CHECKS MA20/MB20
        ;ADDRESS BOUNDRIES.
SWSET:  MOV     R2,SETSW                ;TO BITS 12-27
        MOV     #SWDIAG,R0      ;
        JSR     R5,SBUSDG       ;SET SWITCHES
        MSKDAT  SWDIAG,M14.25   ;CHECK SWITCHES
        BCC     1$              ;O.K.
        POP     R5              ;SET SUBTEST
        FAULT   <BAD SET ADR BOUNDRY>
1$:     RTS     R5              ;SWITCHES
        ;THI SUBROUTINE GENERATES A READ FROM THE ADDRESS
        ;POINTED TO BY R3 & CHECKS FOR A NXM.

NONXM:  DFXCTT,STRCLK           ;START THE CLOCK
        MOV    R3,1$+4         ;WD ADR TO DPOST PARAM LIST
1$:     DPOST,AC7,000000        ;DEPOSIT ADR IN ACY
        JSR     PC,CHKED                ;CHK EXAM/DPOS
        CXQT    XCT10           ;XCT OF INST IN AC10
NXMTST: CXQT    RDAPR   ;DO CONI, APR 17
        READ17  
        TBIT    25              ;NXM ERR FLAG?
        RTS     R5              ;Z NOT SET IF NXM
        .ODD
SWDIAG: .BYTE   1               ;
SETSW:  .WORD   0               ;BITS 12-27 OF SBUS DIAG 1
        .WORD   0               ;

;SEQ266


;SEQ268

.REM    %
        ****TEST #6 CHECKS MA20/MB20 ADDRESS BOUNDRIES FOR NO-
RESPONSE CONDITIONS.  SUBTESTS 1-8 CHECK SINGLE-BIT-SET ADDRESS
BOUNDAREIS AGAINST AN ADDRESS IN PAGE 0.  SBUS DIAGS ARE VERIFIED AS THE
BOUNDRIES ARE SET.  SUBTESTS 9-16 CHECK A ZERO BOUNDRY CONDITION
AGINST EACH CORRESPONDING ADDRESS BIT.  SUBTEST 17 CHECKS THE
ADDRESS BOUNDARIES FOR A RESPONSE.
        %
T.6:    RSTMBX                  ;RESET THE MACHINE
        MOV     #100,R4         ;SWITCH BIT21
        PWTES   TSTCON          ;TEST CONTR  TO ERR STK
1$:     CXQT    CLRNXM          ;CLEAR NXM FLAG
        MOV     R4,R2           ;
        BIS     #BIT01,R2               ;SETUP SBUS DIAG
        INSYNC                  ;*****SUBTESTS 1-8*****
        JSR     R5,SWSET                ;SET SWITCHES
        CXQT    RQEN0           ;READ FROM PAGE 0
        JSR     R5,NXMTST       ;CHECK RESPONSE
        BNE     2$              ;NXM SET, O.K.
        MOV     #SWDIAG,R0              ;NO NXM
        PATERR                  ;PATTERN TO ERROR STACK
        JSR     PC,FAULT                ;MA20 ERROR
        .ASCII  %RESPONSE TO NO RESPONSE CONDITION\%
        .ASCIZ  %PAGE = 0, PATTERN IS SBUS DIAG.%
        .EVEN
2$:     ASL     R4              ;NEXT SWITCH
        CMP     #40000,R4       ;DONE?
        BGT     1$              ;NO, LOOP AGAIN


;SEQ268

        MOV     #2,R2           ;
        JSR     R5,SWSET        ;CLEAR SWITCHES
        MOV     #ADRPAT,R3      ;
        MOV     #100,R4         ;
3$:     MOV     R4,PATADR               ;
        CXQT    CLRNXM          ;CLEAR NXM FLAG
        INSYNC                  ;*****SUBTESTS 9-16*****
        JSR     R5,NONXM                ;TRY ADDRESS, WAIT FOR NXM
        BNE     4$              ;NXM SET, O.K.
        MOV     #ADRPAT,R0              ;NO NXM
        PATERR          ;PATTERN TO ERROR STACK
        JSR     PC,FAULT                ;MA20 ERROR
        .ASCII  %RESPONSE TO NO RESPONSE CONDITION\%
        .ASCIZ  %SWITCHES CLEAR, PATTERN IS ADDRESS%
        .EVEN
4$:     ASL     R4              ;NEXT ADDRESS BIT
        CMP     #40000,R4               ;DONE?
        BGT     3$              ;NO, LOOP AGAIN

;SEQ270
        CXQT    CLRNXM          ;CLR OUT NXM FLAG
        JSR     PC,CHKX         ;MAKE SURE EXECUTE FINISHED
        MOV     #37776,R2               ;;SET ALL SWITCHES
        INSYNC                  ;*****SUBTEST 17 *****
        JSR     R5,SWSET                ;
        MOV     #D14.21,R3      ;TEST FOR RESPONSE
        JSR     R5,NONXM;
        BEQ     5$              ;O.K.
        FAULT   <NO RESPONSE, ALL SWITCHES, ADR = 17 740000>
5$:     NORMAL          ;ADDRESS BOUNDRIES O.K.
CLRNXM: IO10    CONO,APR,,22000
ADRPAT: .BYTE   20              ;5 BYTES OF PDP10 ADDRESS
PATADR: .WORD   0               ;
        .WORD   0

;SEQ271


;SEQ273

.REM    %
        *****TEST#7 CHECKS EACH RQ WITH NO RQ EN TO VERIFY A
NO RESPONSE CONDITION.
%
T.7:    RSTMBX
        PWTES   TSTCON          ;TEST CONTR # TO ERR STK
        SBUSDG  SF00S           ;NO REQUEST ENABLES
        MOV     #2,R2           ;
        JSR     R5,SWSET                ;SWITCHES TO LOW MODULE
        INSYNC                  ;*****SUBTEST 1 *****
        CXQT    RQEN0           ;100 TO AC17
        JSR     R5,NXMTST       ;CHECK RESPONSE
        BNE     1$              ;NXM SET, O.K.
        FAULT   <RQ0 RESPONSE, RQ EN CLR>
1$:     CXQT    CLRNXM          ;CLEAR NXM FLAG
        INSYNC                  ;*****SUBTEST 2 *****
        CXQT    RQEN1           ;101 TO AC17
        JSR     R5,NXMTST       ;CHECK RESPONSE
        BNE     2$              ;NXM SET, O.K.
        FAULT   <RQ1 RESPONSE, RQ EN CLR>
2$:     CXQT    CLRNXM          ;CLEAR NXM FLAG
        INSYNC                  ;*****SUBTEST 3*****
        CXQT    RQEN2           ;102 TO AC17
        JSR     R5,NXMTST               ;CHECK RESPONSE
        BNE     3$              ;NXM SET, O.K.
        FAULT   <RQ2 RESPONSE, RQ EN CLR>



;SEQ274

3$:     CXQT    CLRNXM          ;CLEAR NXM FLAG
        INSYNC          ;*****SUBTEST 4 *****
        CXQT    RQEN3           ;ADR OF INSTRUCTION
        JSR     R5,NXMTST               ;CHECK RESPONSE
        BNE     4$              ;NXM SET, O.K.
        FAULT   <RQ3 RESPONSE, RQ EN CLR>

4$:     NORMAL



;SEQ275


;SEQ277

.REM    %
        *****TEST#8 CHECKS MA20/MB20 ADDRESS PARITY FOR ONE-WORD
COMBINATIONS.  SUBTESTS 1-17 CHECK READS FROM AN ADDRESS PATTERN
LIST.  SUBTESTS 18-22 CHECK PROPER GENERATION OF A PARITY ERROR
FOR A WRITE AND A READ.
%
T.8:    MEMRST
        PWTES   TSTCON          ;TEST CONTR# TO ERROR STK
        SBUSDG  ENMA20          ;SET INTLV 1-WAY
        MOV     #SPAR1,R4       ;PATTERN POINTER
        LOADAC  ACC10,RDMEM     ;MOV RD INSTRTO AC10
1$:     MOV     R4,R0           ;
        ADRSET
        CMP     R4,#SPAR17      ;READS DONE?
        BNE     2$              ;NO
        LOADAC  ACC10,WRMEM     ;MOV WR INSTR TO AC10
2$:     MOVB    (R4)+,ADRBUF    ;ADDRESS TO BUFFER AREA
        MOVB    (R4)+,ADRBUF+1  ;
        MOVB    (R4)+,ADRBUF+2  ;
        LOADAC  ACC7,ADRBUF     ;ADR TO AC7
        INSYNC                  ;*****SUBTESTS 1-17 *****
        CXQT    XCT10           ;EXECUTE AND CHECK
        JSR     R5,APETST       ;GET & TEST ADR PAR ERR BIT
        BEQ     5$              ;NOT SET O.K.


;SEQ278

        CMP     R4,SPAR20               ;READ?
        BGE     3$
        ERRMSG  <RD>
        BR      4$              ;
3$:     ERRMSG  <WR>            ;
4$:     PATERR  ADRBUF          ;TYPE ADDRESS
        FAULT   <ADR PAR ERROR, PATTERN IS ADDRESS>
5$:     CMP     R4,#SPAR21      ;DONE?
        BLE     1$              ;NO, LOOP AGAIN
        SM                      ;RESET THE PC CAUSE IT'S BEEN MOVING


;SEQ279

        CXQT    BADADR          ;FORCE BAD ADR PAR
        INSYNC                  ;*****SUBTEST 18 *****
        CXQT    WRMEM                   ;WR TO ADR IN AC7
        JSR     R5,APETST               ;GET & TEST ADR PAR ERR BIT
        BNE     6$              ;SET, O.K.
        PWTES   #0
        FAULT   <SBDIAG FUNC 0: NO ERR SET ON WR WITH BAD ADR PAR>
        
6$:     JSR     R4,TSTCAP               ;CHK APR DATA ***** SUBTEST 19 *****
        .WORD   TCWR            ;INDICATE A WRITE
        INSYNC                  ;*****SUBTEST 20*****
        JSR     R5,APCTST               ;CLR CNTRLR ERR BIT & TEST IT.
        BEQ     7$              ;CLR, O.K.
        FAULT   <SBUS DIAG FUNCT 0 CLR 0-5 FROM MEM>
7$:     CXQT    BADADR          ;FORCE BAD ADR PARITY
        INSYNC                  ;*****SUBTEST 21 *****
        CXQT    RDMEM           ;RD FROM ADR IN AC7
        JSR     R5,APETST       ;GET & TEST ADR PAR ERR BIT
        BNE     8$
        PWTES   #0
        FAULT   <SBDIAG FUNC 0: NO ERR SET ON RD WITH BAD ADR PAR>


;SEQ280

8$:     JSR     R4,TSTCAP               ;*****SUBTEST 22****
        .WORD   TCRD
        SBUSDG  SDC05           ;DO A CLEAR 0-5
        MEMRST                  ;RESET ALL ERRORS
        NORMAL          
SPAR1:  WD22    11111111
        WD22    02222222
        WD22    13333333
        WD22    04444444
        WD22    15555555
        WD22    06666666
        WD22    00017777
        WD22    17760000
        WD22    00020020
        WD22    00200200
        WD22    00220220
        WD22    02002002
        WD22    02020202
        WD22    02202202
SPAR17: WD22    00000020
SPAR20: WD22    00020000
SPAR21: WD22    00020020
        .EVEN


;SEQ281


;SEQ284

.REM    %
        TEST#9-TEST#15 CHECK MEMORY MODULES.  IF STARTED AT A
MODULE TEST, ANY MODULE MAY BE TESTED.  THE MODULE # WILL
        THEN BE SOLICITED.  IF THE TEST IS RUN IN A NORMAL FASHION,
ALL MODULES WILL BE TESTED.
        %
I.9:    RTS     PC              ;NO INIT IF LOOP
        MOV     TSTART,R0               ;GET TEST START
        CMPB    R0,#FIMMT       ;START AT MODULE TEST?
        BLT     4$              ;NO...SELECT NEXT MODULE
        CMPB    R0,#LIMMT
        BGT     GMA             ;NO,,STARTING BEYOND MOD TSTS, CONTINUE
        TSTB    TSTMOD+1        ;TESTING A MODULE NOW?
        BEQ     GMA             ;YES, EXIT
1$:     PFORCE                  ;FORCE TYPEOUTS
        PMSG    <MODULE #: _>
2$:     TTILIN                  ;
        BCS     2$              ;WAIT FOR REPLY
        TTIOCT                  ;CONVERT OCTAL FORMAT
        BCS     3$              ;IMPROPER FORMAT
        CMP     R0,#3           ;VALID #?
        BGT     3$              ;NO
        MOVB    R0,TSTMOD               ;SET TEST MODULE #
        BMI     3$              ;
        PNORML                  ;NORMAL TYPEOUTS
        CLRB    TSTMOD+1                ;CLEAR ALLOW SELECT MODULE
        BR      5$              ;TEST IF THERE
3$:     PMSG    <?\>
        BR      1$              ;TRY AGAIN
4$:     INCB    TSTMOD          ;NEXT MODULE
5$:     MOVB    TSTCON,R0               ;GET CONTROLLER #
        MOVB    TSTMOD,R1       ;GET MODULE #
        ASL     R1              ;TIMES 2 FOR INDEX
        BITB    MTBL(R1),MODNUM(R0)     ;MODULE REPORTED?
        BNE     GMA             ;BR IF MOD EXISTS, GO TEST IT
        CMPB    MODNUM(R0),MTBL(R1)     ;ANY MOD LEFT TO TEST?
        BHI     4$              ;YES
;-----SECTION TO FOOL DIACON INTO THINII G THAT WE ARE FALLING
;       OUT OF THE BOTTEM OF THE MODULE TESTS.
        MOV     #-1,TSTMOD              ;RESET TEST MODULE # IN CASE OF FUNNY
                                ;TEST LOOP
        POP     R0              ;GET RID OF THE PC FROM THE STK
        MOV     #LIMMT+1,TSTNUM ;ADR OF THIS TEST (INCD BY DIACON)
        TST     TEND.           ;TEST LOOP IN PROGRESS?
        BLE     6$              ;BR IF NO...JUST GO TO NXT RTEST
        CMP     #LIMMT+2,TEND. ;HAVE WE GONE BEYOND THE LOOP LIMIT?
        BLE     6$              ;NO...LET DIACON HANDLE THINGS
        MOV     TEND.,TSTNUM            ;ELSE MAKE UP FOR LOGICAL DEFICIENCY IN
                                ;DIACON & THEN LET DIACON TAKE OVER.
6$:     NORMAL          ;END OF MODULE LOOP



;SEQ285

.REM    %
        TEST#9 SETUP CONFIGURES THE TEST CONTROLLER TO RESPOND
TO ITS MAXIMUM ADDRESS RANGE, 1-WAY INTERLEAVED, AND LOADS THE AC
PROGRAM FOR LOOPBACK CYCLE CHECKOUT.
        %
GMA:    JSR     R5,SETIMA       ;SETUP INT MEM MOD ADR
        MOV     R0,R2           ;VAL OF MBFLAG TO R2
        MEMRST                  ;REET ALL MEMORY CONTROLLERS
                SBUSDG  ENMA20  ;SET 1-WAY INTERLEAVE
        MOV     1$(R2),R0               ;GET PTR TO PROPER SBUS DIAG WD (MA/MB)
        JSR     R5,SBUSDG       ;MAKE CONTR RESPOND TO MAX RANGE
        LOADAC  LCCPM,IMLCCP    ;LOAD THE AC PROGRAM
        JSR     R5,CNTSD                ;PUT CONTR # IN SBUS DIAG WD
        .WORD   SDSLB
        LOADAC  ACC13!ACC17,<SDSLB,IMAC1>        ;LD SBUS DIAG WD, MOD RESP ADR
        RTS     PC              ;INIT DONE
1$:     .WORD   MAXMA,MAXMB     ;PTRS TO SBDIAG WDS FOR MAX RANGE

;-----THE AC PROGRAM.  THIS PROGRAM IS DESIGNE TO DETECT 1 OF 2 THINGS:
;       THAT DATA IS GOING TO MEMORY DURING A LOOPACK CYCLE, OR THAT
;       LOOPBACK DOESN'T GO AWAY LIKE IT SHOULD.
        BLK10   0
IMLCCP: I10     SETO,16,,0      ;0--INIT PTTERN
        I10     SETCAM,16,,0,17 ;1--WR PTRN TO MEM
        I10     MOVE,15,,0,17   ;2--RD IT BACK
        I10     MOVE,15,,0,17   ;3-RD IT AGAIN SO IT SETTLES DOWN
        IO10    SBDIAG,,,13     ;4--NOW SET LOOPBACK
        I10     MOVEM,16,,0,17  ;5--OPPOSITE WD TO LOOPBACK BUFFERS
        I10     MOVE,14,,0,17   ;6--FINISH OFF LOOPBACK CYCLE
        I10     CAME,15,,0,17   ;7--DID ANY BITS IN MEM CHANGE
        I10     JRST,4,,1               ;10-YES...LOOPBACK WENT TO MEM...ERR
        I10     AOJE,16,,1      ;11-DO IT OVER FOR OTHER PATTERN
        I10     JRST,4,,0       ;12-HALT WHEN BOTH PATTERNS DOEN
                                ;13-SBUS DIAG WD TO SET LOOPBACK
                                ;14-SCRATCH
                                ;15-MEM WD GOES HERE
                                ;16-PATTERN...ALL 1S OR 0S
                                ;17-LEGAL MEM ADR
ENDBLK  LCCPM


;SEQ286

;-----THE INTERNAL MEMORY LOOPBACK CYCLE TEST.
T.9:    RUN     AC0             ;RUN THE PROGRAM
        JSR     PC,CHKP
        DFPC                    ;GET THE HALT CODE
        TST     (R0)            ;0 OR NOT 0?
        BEQ     1$              ;0...OK
        JSR     R5,RCAS2        ;CALL OUT CONTR & STOP MOD
        FAULT   <LOOPBAK WENT TO MEM OR DIDN'T CLEAR>

1$:     NORMAL


;SEQ287
;SEQ289

;-----SUBROUTINE TO CALC IMAC1 BASED ON TEST MOD # AND CONTROLLER TYPE.
;       RETURNS VALUE OF MBFLAG IN R0,ALSO.
SETIMA: JSR     R5,SAV.3                ;SAVE REGS
        TSTB    TSTMOD          ;IS TEST MOD DEFINED?

        BGE     1$              ;YES
        CLRB    TSTMOD          ;ELSE FORCE MOD 0
1$:     MOVB    TSTMOD,R1       ;GET TEST MOD #
        BIS     #4,R1           ;SET NXT HIGHER BIT TO FORCE IT UP IN ADR SPACE
        CLR     R2
        ASR     R1              ;SHIFT INTO PLACE FOR MA20 OR MB20
        ROR     R2
        MOVB    MBFLAG,R0
        BNE     2$
        ASR     R1
        ROR     R2
2$:     MOV     #IMAC1,R3       ;PTR SAVES TIME AND SPACE
        MOV     R2,(R3)+        ;IMACT 20-35
        MOV     R1,(R3)+        ;4-19
        MOVB    3$(R0),(R3)     ;MOD SIZE BITS 16K/32K (MA/MB)
        JSR     R5,RST.3                ;ALL DONE...RESTORE REGS
        RTS     R5
3$:     .WORD   17,16           ;16K,32K
TSTMOD: .WORD   0               ;MODULE FOR TEST
IMAC1:  .WORD   0,0,0           ;KL10 WD <-MOD SIZE,,MOD START ADR>



;SEQ290

.REM    %
        TEST#10 IS THE ONES AND ZEROS LOOPBACK TEST TO INTERNAL MEMORY.
UPON DETECTING AN ERROR IT GOES INTO A FST SCOPE LOOP.
        %
I.10:   RTS     PC              ;SKIP INIT ON LOADS
        SM                      ;RESET THE MACHINE
        LOADAC  GMAPM,IMLOZP    ;LOAD AC PRGM (AC0-11)
        
I10C:   JSR     R5,CNTSD                ;UT CONTR # ION SBUS DIAG WD
        .WORD   SDSLB
        LOADAC  ACC13!ACC17,<SDSLB,IMAC1>       ;LD SBUS DIAG WD, MOD RESP ADR
        RTS     PC              ;INIT DONE
;-----AC PRGM TO LOOPBACK 1'S & 0'S TO INTERNAL MEMORY
        BLK10   0
IMLOZP: I10     SETO,16,,0      ;0--FIRST PTRN IS ONES
        I10     SETCAM,16,,0,17 ;1--MOVE COMPLEMENTARY PATTERN
        IO10    SBDIAG,,,13             ;2--SVBUS DIAG TO SET LOOPBACK
        I10     MOVEM,16,,0,17  ;3--PTRN TO LOOPBACK REG
        I10     MOVE,15,,0,17   ;4--GET BACK FROM LOOPBACK REGISTER
        I10     CAME,15,,16     ;5--SAME?  SKIP IF YES
        I10     HRLI,4,,610657  ;6--ELSE FORCE STATIC LOOP ON ERROR
        I10     JUMPL,4,,1              ;7--LOOP ON ERR SET
        I10     AOJE,16,,1      ;10-GEN NXT PTRN, JUMP IF NOT DONE
        I10     JRST,4,,0               ;11-HALT WHEN DONE
                                ;13-DIAG FUNC 1 TO MEM SETS LOOPBACK
                                ;15-ERROR PATTERN FROM MEMORY
                                ;16-PATTERN TO MEM
ENDBLK  GMAPM           ;17-ADDRESS UNDER TEST


;SEQ291

.REM    %
        TEST#11 INIT JUST LOADS THE AC PROGRAM FOR DOING A SLIDING
        PATTERN LOOPBACK.  THE FIRST PATTERN IS 757020,,020757, WHICH IS
THEREAFTER ROTATED TO THE LEFT.
        %
I.11:   RTS     PC              ;NO INIT ON LOOPS
        SM                              ;RESET THE MACHINE
        LOADAC  ISPLPM,1$               ;LOAD AC PRGM (AC0-12)
        BR      I10C            ;PDP11 MEM ADR(S)
;-----AC PRGNM TO DO LOOPBACK OF ROTATING PATTERNS TO INTERNAL MEM.
        BLK10   0
1$:     I10     SETCAM, 15,,0,17        ;0--SET COMPLEMENTARY PTRN TO MEM
        IO10    SBDIAG,,,13             ;1--TURN ON LOOPBACK
        I10     MOVEM,16,,0,17          ;2-PTRN TO MEM
        I10     MOVE,15,,0,17   ;3--GERT PTRN BACK
        I10     CAME,15,,16     ;4--SAME?
        I10     HRLI,3,,610657          ;5--IF NOT, FORCE STATIC LOOP
        I10     JUMPL,3.,0              ;6--LOOP ON ERR
        I10     ROT,16,,1               ;7--NXT PTRN
        I10     TRNE,16,,757020 ;10-SKIP WHEN DONE
        I10     JRST,,,0                ;11-ELSE LOOP TIL DONE
        I10     JRST,4,,0               ;12-HALT
                                ;13-SBUS DIAG TO SET LOOPBACK
                                ;14-
                                ;15-ERR PTRN FROM MEM
                                ;16-PTRN TO MEM
ENDBLK  ISPLPM          ;17-ADDR UNDER TEST


;SEQ292

.REM    %
        INTERNAL MEMORY LOOPBACK TESTS.  NOTE THAT BOTH TEST#10 TEST#11
LEAVE A FAST SCOPE LOOP RUJJING AFTER DETECTION OF AN ERROR.
%
T.11:   LOADAC  ACC16,ROTPAT            ;PTRN TO PTRN REG
T.10:   MOVB    TSTMOD,R5
        INSYNC                  ;*****SUBTEST (MOD# +1) *****
        RUN     AC0             ;START PROGRAM
        BCS     1$              ;BR IF DIDN'T GOMOSJ
        NORMAL                  ;ELSE DONE OK
1$:     JSR     R5,RCAS         ;REPROT CONTR, STOR MOD, & ADDRESS
        JSR     R5,GDPM         ;DUMP ERR PTRN
        FAULT   <INTERNAL MEM LOOPBACK ERROR>

$RANGE=1        ;FORCES ASSEMBLY OF THE RANGE SUBROUTINE


;SEQ293


;SEQ296


;SEQ299

.REM    %
        *****TEST#12 ADDRESS TESTS AN MA20/MB20 MEMORY MODULE.  THE
TEST IS PERFORMED BY EXECUTING THE FOLLOWING SEQUENCE:

        1.      WRITE ZEROS TO A MEMORY LOCATION
        2.      READ THE LOCATION JUST WRITTEN
        3.      READ THE SAME LOCATION AGAIN (TO ELIMINATE DATA
                PATHS FROM CONSIDERATION)
        4.      WRITE ALL 1S TO A DIFFERENCT LOCATION
        5.      TEST THAT THE ORIGINAL LOCATION DID NOT CHANGE

SOLID FAULTS IN THIS TEST SHOULD BE GENERATED ONLY BY ADDRESSING
PROBLEMS.  PATTERNS USED CORRESPOND TO THE INPUT COMBINATIONS
FOR MODULE X, Y DRIVEW.  A LOOP IS LEFT RUNNING IN THE ACS IF A
FAULT IS DETECTED.  THE ADDRESSES ARE LEFT IN AC15 & AC16.
%
T.12:   SM                      ;RESET THE MACHINE
        PWTES   TSTCON          ;CONTR # TO ERR STK FOR ISOLATION
        MOVB    TSTMOD,R5
        MOVB    MBFLAG,R0       ;GET MA/MB20 FLAG TO USE AS NDX
        MOV     3$(R0),2$       ;USE IT TO SET CORRECT MEMORY TYPE PARAM
        INSYNC                  ;*****SUBTEST (MOD# + 1) *****
        MEMADR  IMAC1,2$                ;GO ADR TEST THE STOR MOD
        BCC     1$              ;BR IF TESTED OK
        FAULT   <INTERNAL MEMORY MODULE ADDRESSING ERROR>
1$:     NORMAL
2$:     .WORD   000000          ;MEMORY TYPE CODE GOES HERE
3$:     .WORD   3,5             ;MEM TYPE CODES FOR MA20/MB20 RESP.

 

;SEQ300


;SEQ303

.REM    %
        INTERNAL MEMORY ONES & ZEROS TEST.,  THIS TEST MAKES SURE THAT
        EACH WORD IN A GIVEN STORAGE MODULE CAN HOLD ALL ONES AND ALL
        ZEROS.  KINITIALIZATION CONSISTS OF LOADING THE AC PRGM.
        %
I.13:   BR      1$              ;ON LOOPS SKIP PRGM LOAD
        SM                      ;RESET THE MACHINE
        LOADAC  IOZPM,2$                ;LOAD THE AC PRGM 9AC0-11)
        
1$:     LOADAC  ACC17,IMAC1    ;LOAD -CNT,,ADR WD
        RTS     PC              ;INIT DONE
;-----THE AC PROGRAM FOR TEST#14.
        BLK10   0
2$:     I10     SETO,16,,0      ;0--SET FIRST PTRN OF ALL ONES
3$:     I10     SETCAM,16,,0,17 ;1--COMPLEMENT OF PTRN TO MEM
        I10     MOVEM,16,,0,17  ;2--MOVE PTRN TO MEM
        I10     MOVE,14,,0,17   ;3--READ WD BACK ONCE
        I10     MOVE,15,,0,17  ;4--GET IT 2ND TIME TO CHK RD-RSTR
        I10     CAME,15,,16     ;5--SKIP IF DIDNT CHANGE
        I10     HRLI,4,,610657  ;6--ELSE ERROR...FORCE STATIC LOOP
        X10     JUMPL,4,,3$     ;7--LOOP ON ERROR
        X10     AOJE,16,,3$     ;10-GEN ZEROS PTRN & LOOP
        X10     AOBJN,17,,2$    ;11-GO TO NXT MEM LOC
        I10     JRST,4,,0       ;12-HALT WHEN DONE & NO ERR
                                ;14-SCRATCH
                                ;15-ECHO RECEIVED BY EBOX
                                ;16-PATTERN SENT BY EBOX
                                ;17-ADDRESS TO WHICH PTRN WAS SENT
        ENDBLK  IOZPM
.REM    %
        INTERNAL MEMORY ONES & ZEROS TEST.
        A LOOP IS LEFT RUNNING IN THE KL AC'S IF AN ERROR
        IS DETECTED.  SCOPABLE.  THE TEST FIRST SENDS ONES THEN ZEROS
        TO A GIVEN MEM LOC, THEN GOES ON TO THE NEXT LOC.
        %
T.13:   MOVB    TSTMOD,R5       ;CALC SUBTEST #
        INSYNC                  ;*****SUBTEST # = MOD# + 1 ******
        RUNBIG  AC0,25.         ;RUN THE PROGRAM
        BCS     1$              ;PRGM DOESNT HALT IF ERR FOUND
        NORMAL                  ;ELSE NO ERR, TEST DONE
1$:     JSR     R5,RCAS         ;STACK ADR, CONTR, & MOD #
        JSR     R5,GDPM         ;STACK BIT PATTERNS
        FAULT   <INTERNAL MEM CORE FAILURE>


;SEQ304

;SEQ307

.REM    %
        TEST#14 IS A SLIDING PATTERN TEST WHICH SENDS THE GENERATED
        PATTERN TO THE FIRST WORD OF THE SELECTED STORAGE MODULE.  SINCE
        THE LOOPBACK TEST FOR THE STORAGE MOD HAD A SLIDING BIT TEST,
        A FAILURE IN THIS TEST MOST PRBABLY INDICATES A FAULT ON THE
        SENSE/INHIBIT BOARD OF THE STOR MOD BOARD SET.
%
I.14:  BR      1$              ;SKIP LOAD  ON LOOPS
        SM                      ;RESET THE MACHINE
        LOADAC  ISPPM,2$                ;LOAD AC PRGM (AC0-12)
        DPOST,AC17,IMAC1        ;ADR WHICH REGS STOR MOD
1$:     RTS     PC              ;INIT DONE
;-----AC PROGRAM FOR ROTATING PATTERN TO INT. MEM STOR MODULE.
        BLK10   0
2$:     X10     MOVE,16,,ROTPAT ;0--COPY PTRN TO BE ROTATED
3$:     I10     MOVEM,16,,0,17  ;1--MOVE PTRN TO MEM
        I10     MOVE,14,,0,17   ;2--GET IT BACK
        I10     MOVE,15,,0,17   ;3--GET BACK PATTERN 2ND TIME
        I10     CAME,15,,16     ;4--IS IT OK...SKIP IF YES
        I10     HRLI,3,,610657  ;5--ELSE FORCE STATIC LOOP ON ERR
        X10     JUMPL,3,,3$     ;6--LOOP ON ERROR
        I10     ROT,16,,1               ;7--ROTATE PTRN TO GET NXT ONE
        X10     CAMN,16,,ROTPAT ;10-SKIP IF NOT DONEN YET
        I10     JRST,4,,0               ;11-ELSE HALT...DONE
        X10     JRST,,,3$               ;12-LOOP TIL ALL PTRNS DONE
ROTPAT: WD36    7570,2002,0757  ;13-INITIAL PATTERN
                        ;14-SCRATCH
                                ;15-PTRN FROM EM GOES HERE
                                ;16-PTRN TO MEM GOE HERE
        ENDBLK  ISPPM           ;17-ADDRESS UNDER TEST GOES HERE
.REM    %
        THE INTERNAL MEMORY ROTATING PATTERN TEST.  NOTE THAT A FAST
        LOOP IS LEFT RUNNING UPON FAULT DETECTION.
        %
T.14:   MOVB    TSTMOD,R5               ;*****SUBTEST (MOD#+1) *****
        INSYNC
        RUN     AC0                     ;RUN THE PRGM
        BCC     1$              ;BR IF IT FINISHED (ALL OK)
        JSR     R5,RCAS                 ;STACK ADR, CONTR, & SM NUMBERS
        JSR     R5,GDPM         ;GET & STACK ERROR INFO
        FAULT   <INTERNAL MEM DATA PATH ERR.  PROBABLY SENSE/INHIBIT.>
1$:     NORMAL


;SEQ308


;SEQ311
.REM    %
        INTERNAL MEMORY PARITY BIT CHECK.  THIS TEST AMES SURE
        THAT EACH WORD IN A GIVEN INTERNAL MEMORY MODULE HAS A WORKING 
        PARITY BIT.  THE INIT JUST LOADS THE AC PROGRAM.
        %
I.15:   BR      1$              ;ON LOOPS, SKIP PRGM LOAD
        SM                      ;RESET THE MACHINE
        LOADAC  IPBPM,2$        ;PDP11 MEM ADR(S)
1$:     DPOST,AC17,IMAC1        ;LOAD BASE ADR OF STORAGE MODULE
        RTS     PC
;-----THE AC PROGRAM FOR TEST#15
        BLK10   0
2$:     I10     MOVEI,16,,1     ;0--SET FIRST PTRN OF ONE
3$:     I10     MOVEM, 16,,0,17 ;1--MOV PTRN TO MEM
        I10     MOVE,14,,0,17   ;2--RD WD ONCE
        I10     MOVE,15,,0,17   ;3--GET IT 2ND TIME TO CHK RD-RSTR
        IO10    CONSZ,APR,,400  ;4--SKIP IF NO PAR ERROR
        I10     HRLI,3,,610657    ;5--ELSE ERROR...FORCE STATIC LOOP
        X10     JUMPL,3,,3$     ;6--LOOPP ON ERROR
        X10     SOJE,16,,3$     ;7--GEN ZEROS PTRN & LOOP
        X10     AOBJN,17,,2$    ;10-GO TO NXT MEM LOC
        I10     JRST,4,,0       ;11-HALT WHEN DOEN & NO ERR
                                ;14-SCRATCH
                                ;15-ECH0 RECEIVED BY EBOX
                                ;16-PATTERN SENT BY EBOX
                                ;17-ADDRESS TO WHICH PTR WAS SENT
        ENDBLK  IPBPM
.REM    %
        INTERNAL MEMORY TEST#15 LEAVBES LOOP RUNNING IN AC'S UPON
        DETECTING ERROR.  SCOPABLE.
        %
T.15:   SM                      ;CLR OUT MACHINE
        MOVB    TSTMOD,R5       ;CALC SUBTEST #
        INSYNC                  ;*****SUBTEST (MOD# +1) *****
        RUNBIG  AC0,25.         ;RUN THE AC PRGM
        BCS     1$              ;BR ON ERROR
        NORMAL                  ;ELSE TEST DONE
1$:     JSR     R5,RCAS         ;STACK ADR, CONTR, & MOD#
        EXAMT,AC15,D20TMP       ;GET PTRN
        JSR     PC,CHKED                ;EHK EXAM/DPOS
        PATERR  D20TMP          ;DATAPTRN TO ERR STK
        FAULT   <INTERNAL MEM PAR BIT ERR, PTRN IS DATA>


;SEQ312


;SEQ315

.REM    %
        TEST#16 INIT IS A DISPATCH MODIFIER FOR INTERNAL MEM MOD TESTS.
        %
NXTMOD: CMP     TSTART,#LIMMT+1 ;SHOUD WE LOOP ON MODULE TESTS?
        BLE     2$              ;BR IF YES
        JSR     R5,SETIMA       ;SET UP IMAC1
1$:     RTS     PC              ;ELSE CONTINUE TO NEXT INIT
2$:     CMP     TEND.,#LIMMT+1  ; *TL END BEYOND MODULES LOOP?
        BLE     3$              ;IF NOT, GET NEXT MODULE
        TSTB    TSTMOD+1        ;TESTING SPECIFIEC MODULE?
        BEQ     1$              ;IF YES, CONTINUE W/NEXT TEST
3$:     MOV    #FIMMT,TSTNUM   ;ELSE LOOK FOR NEXT MODULE
        JMP     IDISP           ;GO DO FIRST MODULE


;SEQ316

.REM    %
        TEST#17 IS THE INTERNAL MEMORY MODULE SELECT TEST.  IT MAKES
SURE THAT THE MA20/MB20 CONTROLLER IS PROPERLY SELECTING STORAGE MODULES
CORRECTLY.  IT ALSO WORKS OVER THE MODULES A LITTLE MORE HEAVILY THAN
THE 1S/0S TEST.  ALL OF THIS IS ACCOMPLISHED VIA THE ADDRESS/TAG TEST.
THE INITIALIZATION IS USED ONLY TO SET UP THE TABLE REQUIRED BY HE TEST.
        THE ONLY SOLID ERRORS WHICH SHOULD SHOW UP HERE ARE ADDRESS IN-
TERFERENCE ERRORS BETWEEN STORAGE MODULES. SEE THE ADRTAG SUBROUTINE
FOR MORE INFORMATION REGARDING FAILURE MODES.
        %

I.17:   RTS     PC              ;SKIP INIT ON LOOPS
        MOVB    TSTCON,R0               ;CONTR # TO R0
        MOVB    MODNUM(R0),R1   ;GET STOR MOD PRESENSE BITS
        ASL     R1              ;DOUBLE FOR USE AS WD INDEX
        MOV     3$(R1),R1       ;GET COMPRESSED IMATAB BITS
        MOV     #IMATAB+10.,R2  ;PT PAST END OF IMATAB
;-----LOOP TO ENPAND BITS INTO IMATAB
1$:     MOV     R1,-(R2)
        BIC     #177770,(R2)
        SR      R1,3


        CMP     R2,#IMATAB
        BHI     1$
;-----IF MB20, DOUBLE ALL ADR & SIZE WORDS IN IMATAB.
        TSTB    MBFLAG
        BEQ     2$
        TST     (R2)+
        ASL     (R2)+
        ASL     (R2)+
        ASL     (R2)+
        ASL     (R2)+
2$:     RTS     PC              ;ALL DONE...IMATAB SET UP FOR ADRTAG
;THE FOLLOWING TABLE CONTAINS COMPRESSED INFO FOR IMATAB.  WHICH
;       WORD IS SELECTED DEPENDS ON THE STOP MOD CONFIGURATION.
3$:     .WORD   04040,14140,15140,14240,16140,24161,15240,14340
        .WORD   17140,24171, 25171,24271,16240,24162,15340,14440
;-----IMATAB    IS A 16K FORMAT TABLE SIMILAR TO THE TABLES USED BY THE
;       MEMORY ONFIGURATOR.
IMATAB: .WORD   0               ;#ENTRIES IN IMATAB (1 OR 2)
        .WORD   0,0             ;1ST MEM START ADR, SIZE
        .WORD   0,0             ;2ND MEM START ADR, SIZE


 
 
;SEQ317

;-----TEST#17 SIMPLY CALLS THE ADRTAG SUBROUTINE.
T.17:   PWTES   TSTCON          ;CONTR # TO ERR STK FOR ISOLATION
        MOV     #IMATAB,R0      ;ADR OF TABLE TO PARAM REG
        JSR     R5,ADRTAG       ;GO TEST
        BCC     1$              ;BR IF NO ERR
        FAULT   <INTERNAL MEM MOD SEL ERR>
1$:     NORMAL


;SEQ318


;SEQ322

.REM    %
        TEST#18 IS THE INTERNAL MEMORY READ-PAUSE-WRITE TEST.  IT
        IS PERFORMED ONCE FORE EACH CONTROLLER USING THEADDRESS LEFT
        OVER FROM THE LAST PREVIOUS MODULE TEST.
        INIT CONSISTS OF LOADING THE AC PROGRAM USED.
        %
I.18:   RTS     PC              ;SKIP INIT ON LOOPS
        SM                      ;RESET THE MACHINE
        LOADAC  IRPWPM,RPWPRG   ;LOAD R-P-W PRGM TO AC7-14
I20C:   DPOST,AC17,IMAC1        ;LOAD BASE ADR OF LAST MOD TESTED
        RTS     PC              ;OINIT DONE
;-----READ-PAUSE-WRITE AC PROGRAM.  GOES INTO INFINITE LOOP ON ERR.
;       SCOPABLE.
        BLK10   7
RPWPRG: I10     SETOB,16,,0,17  ;7--MOVE -1 TO MEM
RPWRPW: I10     AOS,,,0,17      ;10-DO R-P-W USING AN AOS INSTR
RPWRD:  I10     SKIPE,15,,0,17  ;11-SKIP IF A0S WORKD
        I10     MOVEI,17,,0,17  ;12-ELSE SET LOOP FLAG
        I10     JUMPGE,17,,7    ;13-LOOP IF ERROR
        I10     JRST,4,,7               ;14-ELSE HALT
                                ;15-ECHO RECEIVED BY EBOX
                                ;16-PATTERN SENT BY EBOX
                                ;17-ADDRESS TO WHICH PTRN WAS SENT
        ENDBLK  IRPWPM
.REM    %
        THE INTERNAL MEMORY READ-PAUSE WRITE TEST DOES 2 THINGS.  FIRST IT
VERIFIES THAT THE 'DATA VALID X OUT H'SIGNALS ARE SET DURING A R-P-W CYCLE.
THEN IT CHECKS TO SEE IF A R-P-W DOES.  IN FACT, WORK.  IF THE TEST FAILS HERE, A
LOOP IS LEFT RUNNING IN THE AC'S WHICH IS SCOPALE.
        %
T.18:   JSR     R4,DVAOT                ;CHK FOR DATA VALID SIGNALS
        .WORD   RPWRPW          ;ADR OF INSTR FOR EXEC
        INSYNC                  ;*****SUBTEST 3 *****
        RUN     AC7             ;TRUN YHR AC PRGM
        BCS     1$              ;BR IF DIDNT HALT (IF ERR END)
        NORMAL                  ;ELSE DONE
1$:     JSR     R5,RCAS2        ;DUMP CONTR # TO ERR STK

        FAULT   <INTRNL MEM READ-PAUSE-WRITE ERR (USING AOS)>


;SEQ323
 


;SEQ326

.REM    %
        TEST#19 IS THE INTERNAL MEMORY INCOMPLETE-CYCLE TEST.  IT
ATTEMPTS TO FORCE AN INCMP CYC BY STOPPING A RPW IN THE MIDDLE AND THEN
DOING A READ.  IT THEN CHECKS TO SEE IF THE FLAG BIT IS SET, AND THAT
THE FLAG CAN BE CLEARED.
        %
I.19:   RTS     PC              ;SKIP INIT ON LOOPS
        SM                      ;RESET THE MACHINE
        BR      I20C            ;GO LOAD AN ADDRESS TO USE
T.19:   MOVB    TSTCON,R5               ;SUBTEST # = CONTR # +1
        INC     R5
        STEXCT  RPWRPW          ;START THE READ-PAUSE-WRITE
        FIND    <177,28.,0>     ;STEP 'TIL "RD PAUSE 2ND HALF L" FOUND
        MRESET,DFXCTT,STRCLK    ;STOP THE RPW, RESTART THE CLOCK
        
        CXQT    RPWRD           ;NOW DO A READ
        SBUSDG  ZERO.           ;NOW GET THE ERROR BITS WORD
        BIT     #2,4(R0)        ;INCMP CYC BIT SET?
        BNE     1$              ;YES...OK
        FAULT   <COULDN'T FORCE INCMP CYC>
1$:     SBUSDG  SDC05           ;NOW ATTEMPT TO CLR THE FLAG
        BIT     #2,4(R0)        ;DID IT CLR?
        BEQ     2$              ;YES...OK...ALL DONE
        FAULT   <COULDN'T CLR INCMP CYC FLAG>
2$:     NORMAL                  ;TEST DONE OK

;SEQ327


;SEQ329

.REM    %
        THE INIT FOR THE INTERNAL MEMORY 4 WORD READ/ONE WAY INTERLEAVE
        TEST CONSISTS OF SETTING UP CONSTANTS AND LOADING THE AC PRGM.
        %
I.20:   MOVB    #'1,IMFWTI      ;"1" TO ERR MSG JUST IN CASE
        MOVB    IMAC1+2,R1      ;CALC 16K FMT EPT PAG # FOR CONO-PAG
        SWAB    R1
        BISB    IMAC1+1,R1
        ASL     R1
        ASL     R1
        SWAB    R1
        BIC     #177400,R1      ;DE-JUNK
        JMP     FWDRDI          ;FINISH INIT
.REM    %
        THE INTERNAL MEMORY 4 WORD READ ONE WAY INTERLEAVE TEST
        SEE SUBROUTINE FWDRDT FOR COMMENTS.
        %
T.20:   JSR     PC,FWDRDT               ;CALL TEST
        BCC     1$              ;BR IF NO ERROR
        JMP     IMFWTP          ;GO PRINT ERR MSG
1$:     NORMAL


;SEQ330

        

;SEQ332

;*****NOTE***** - SEQ332 MICROFICHE IS BLANK.


;SEQ333

.REM    %
        THE INITIALIZATION FOR TEST#21 AND TREST#22 CONSIS OF TWO BASIC
        PSRT.  FIRST, CHECKING FOR COMPATABILITY BETWEEN THE TEST CON-
        TROLLER (TSTCON) AND ITS ALTERATE (ALTCON=TSTCON.XOR.1). AND
        SETTING UP THE SBUS DIAGS NECESSARY..  SECOND, LOADING UP THE
        STUFF FOR THE CANNED 4 WORD READ TEST.  THIS IS DONE BY "FWDRDI".
        %
I.21:   MOV     #'2,R5          ;INDICATES 2 WAY INTERLEAVES
        BR      I.22+4  
I.22:   MOV     #'4,R5          ;INDICATES 4 WAY INTRLV
        MOVB    TSTCON,R1       ;GET TEST CONTR #
        MOV     R1,R2           ;CALC ALTERNATE CONTR #
        EXOR    #1,R2
        MOVB    R2,ALTCON               ;SAV IT
;----IF THE TEST CONTROLLER WAS SPECIFICALLY SELECTED, TRY TO USE ITS
;       ALTERNATE EVEN IF IT HASN'T BEEN TESTTED.
        TSTB    DEVFLG+1                ;SELECTED SPECIFIC INRT MEWM CONTR?
        BNE     1$              ;YES...USE ALTCON REGARDLESS
        TSTB    TYPNUM(R2)      ;WAS ALTCON TESTED?
        BGE     3$              ;NO...DON'T DO TEST
;-----NOW MAKE SURE TSTCON & ALTCON ARE COMPATABLE.  SEND WARNING &
;       DON'T DO TEST IF NOT.
1$:     MOVB    MODNUM(R1),R3   ;GET "AND" OF STOR MODS
        MOVB    MODNUM(R2),R4
        COM     R4
        BIC     R4,R3           ;"AND" MAP OF COMMON MODS NOW IN R3
        BGT     6$              ;BR IF CONTRS HAVE MODS IN COMMON
2$:     MOVB    R5,5$           ;ELSE CONTRS INCOMPATABLE...SET ERR MSG
        PFORCE
        $PMSG,4$                ;SEN ERR MSG
        PNORML
3$:     TST     (SP)+           ;DON'T DO TEST
        NORMAL
4$:     .ASCII  %WARNING: CAN'T DO INTERNAL MEM %
5$:     .ASCIZ  %? INTRLV TEST. STORAGE MODS INCOMPATABLE\%
        .EVEN


;SEQ334

;-----NOW SET UP THE SBUS DIAGS. NOTE THAT 4 WAY INTERLEAVE REQUIREDS
;       FURTHER COMPATABILITY CHECKING.
6$:     MOVB    TWAT(R3),R4     ;GET ADR BOUNDS FOR 2 WAY INTRLV
        CMP     R5,#'2          ;ARE WE DOING 2 WAY?
        BEQ     7$              ;YES...ADR BOUNDS CALC DONE
        COM     R3              ;ELSE DO 4 WAY CHECK & SET
        MOV     #3,R4           ;ADR BOUNDS FOR SM0&1, BOTH CONTR
        BIT     #3,R3           ;DO BOTH CONTR HAVE SM0&1?
        BEQ     7$              ;YES...USE THEM
        MOV     #107,R4         ;ADR BOUNDS FOR SM2&3
        BIT     #14,R3          ;DO CONTS BOTH HAVE SM2&3?
        BNE     2$              ;NO...CAN'T DO 4 WAY TEST AT ALL
7$:     TSTB    MBFLAG          ;ARE WE TESTING MB20S?
        BEQ     8$              ;NO...OK
        ASL     R4              ;ELSE IT'S NEC TO "DOUBLE" THE ADR BOUNDS
        INC     R4
8$:     ASL     R4              ;FMT ADR BNDS FOR TEH SBUS DIAG F1
        INC     R4              ;(FOR "LOAD BOUNDS"BIT)
        ASL     R4              
        MOV     R4,IM4WF1+1     ;PUT ADR BNDS IN SBUS DIAG
;-----DONE WITH FIRST PART OF INIT.  SET UP FOR SECOND PART.
        MOV     R4,R1           ;CALC 16K FMT ADR FOR REST OF INIT
        ASL     R1
        ASL     R1
        SWAB    R1
        BIC     #177400,R1
        JMP     FWDRDI          ;FINISH INIT
IM4WF0: WD36    0177,4000,0000  ;SBUS DIAG WD FOR INTRLV & RQ ENABLES
IM4WF1: WD36    0000,0000,1001  ;WD FOR ADR BOUNDS
TWAT:   .BYTE   000,001,043,001 ;TWO WAY ADDRESS TABLE (SURE!)
        .BYTE   105,001,043,001
        .BYTE   147,001,043,001
        .BYTE   105,001,043,001


;SEQ335

.REM    %
        THE INTERNAL MEMORY (MA20 & MB20) 4 WORD READ/INTERLEAVE 2&4
        TESTS WORK IN THE FOLLOWING MANNER:  THE SBUS DIAGS NECESSARY AND
        THE AC PROGRAM ARE SET UP THE BHE INITIALIZATION.  THE TEST
        THEN RESETS MEMORY, AND CONFIGURES JUST TSTCON & ALTCON.  FIRST
        THE EVEN        REQUEST ENABLES ARE ASSIGNED TO ALTCON, THEN LATER TO
        TSTCON.  THE ACTUAL TEST IS THE CANNED 4 WORD READ TEST "FWDRDT".
        NOTE THAT A HARD LOOP IS LEFT RUNNING UPON THE DETECTION OF AN
        ERROR.
        %
T.21:   MOV     #062600,IM4WF0+2        ;2 WAY INTRLV, R EN 1&3 FOR TSTCON
        MOV     #'2,R0          ;INDICATE 2 AY
        BR      T20COM
T.22:   MOV     #072600,IM4WF0+2        ;4 WAY INTRLV RQ EN 1&3 FOR TSTCON
        MOV     #'4,R0          ;INDICATWE 4 WAY
T20COM: MOVB    R0,IMFWTI       ;SET UP ERR MSG JUST IN CASE
;-----FIRST PART: TSTCON HAS REQUEST ENALES 1&3.  ALTCON HAS 0&2.
        JSR     PC,1$           ;MEMRST,DO SBUS DIAGS
        JSR     PC,FWDRDT               ;*****SUBTEST 1*****
        BCS     IMFWTP         ;PRINT ERR MSG ON ERR
;-----SECOND PART:  TSTCON HAS REQUEST ENABLES 0&2, ALTCON HAS 1&3.
        JSR     PC,1$           ;MEMRST,SE OPPOSITE ENABLES
        ACBLK   1               ;NECESSARY TO RE-INIT FWDRDT CNTL ACS
        LOADAC  ACC2,FWP1C      
        ACBLK   3
        LOADAC  ACC5,FWP3A      
        ACBLK   4
        LOADAC  ACC2,FWP4D
        JSR     PC,FWDRDT               ;*****SUBTESTS 5-8 *****
        BCS     IMFWTP          ;BR IF ERROR
        MEMRST                  ;DE-CONFIGURE MEM AS IT'S NOGOOD ELSEWHERE
        NORMAL


 

;SEQ336

;-----LOCAL DIRTYWORK SUBROUTINE.
1$:     MEMRST          ;RESET ALL MEM CONTRS
        JSR     PC,2$           ;DO SBUS DIAGS
        EXOR    #7400,IM4WF0+2  ;GENERATE OPPOSITE REQUEST ENABLES
        PUSH    TSTCON          ;SAVE TSTCON
        MOVB    ALTCON,TSTCON           ;SUBSTITUTE ALTCON FOR IT
        JSR     PC,2$           ;DO SBUS DIAGS FOR ALTCON
        POP     TSTCON          ;RESTORE TSTCON
        RTS     PC              
2$:     SBUSDG  IM4WF0          ;SET INTRLV & EQUEST ENABLES
        JSR     PC,CHKX
        SBUSDG  IM4WF1          ;SET ADDRESS RESPONSE BOUNDS
        RTS     PC
IMFWTI=.+2      ;INTERLEAVE NUMBER GOES HERE
IMFWTP: MOV     #000000,R0      ;INTRLV CHR TO BE PRINTED
        ERRCOM  PNTCHR
        ERRMSG  <WAY INTERLEAVE>
        FAULT   <INTERNAL MEM 4 WORD READ ERROR>


;SEQ337


;SEQ340

;*****NOTE***** - SE2340 MICROFICHE IS BLANK.


;SEQ341


;SEQ343

;*****NOTE***** - SEQ343 MICROFICHE IS BLANK.


;SEQ344

.REM    %
        NEXT INTERNAL MEMORY CONTROLLER SELECT.
        %
NXTCON: MOVB    TSTCON,R0       ;CONTROLLER TESTED
        MOVB    TYPNUM(R0),R1   ;GET TYPE
        BISB    #BIT7,TYPNUM(R0) ;MARK IT TESTED
        ASL     R1              ;DOUBLE TYPE #
        DECB    @MDCP-2(R1)     ;DECREMENT # OF THIS TYPE
        TSTB    DEVFLG+1        ;TESTING SPECIFIEC I.M. CONTROLLER?
        BEQ     2$              ;BR IF NO
        JSR     PC,MEMSET               ;ELSE CONFIGURE JUST THAT CONTROLLER
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #ABORT,R0               ;THIS IS END OF 'LOOP'...TST ABORT
        BNE     3$              ;BR IF SET...FUDGE END OF LOOP
1$:     MOV     #FIMCT,TSTNUM   ;ELSE SET TEST NO. TO FIRST IMC TEST
        JMP     IDISP           ;GO TO IT
2$:     TST     MA20            ;ANY INT MEM LEFFT?
        BNE     1$              ;YES...LET FIMCT SLECT IT
        TSTB    DMA20           ;DMA20?
        BNE     1$              ;YES...LET FIMCT SELECT IT
        JSR     PC,MEMSET               ;ELSE CONF MEM
3$:     MOVB    TESTAB,TSTNUM   ;FUDGE END OF PASS
        POP     R0
        NORMAL

;SEQ345

.SBTTL          DMA20 DIAGNOSTIC TEST (DON'T GO TO MEM)

.REM    %
        TEST#24 THROUGH TEST#26 CHECK THE 'SETABILITY' OF THE DMA20
        SBUS DIAGNOSTIC FUNCTION BITS.
        %
.REM    %
        TEST#24 INITALIZATION:  SET BITS TO CHK MEMRST
        %
I.24:   
I.26:   SBUSDG  SDS4WI  ;DIAG FUNC 0
        SBUSDG  SDSLB           ;DIAG FUNC 1
        RTS     PC              ;FOM W/0 CHKG ANYTHING
.REM    %
        TEST#24 CHECKS THE MEMRST FUNCTION WITH RESPECT TO THE DMA20
        DIAGNOSTIC FUNCTION BITS.
        %
T.24:   CLR     R1
        INSYNC                  ;****SUBTEST 1 ****
        MEMRST                  ;ATMP H MEM RST
        SBUSDG  ZERO.           ;READ FUNC 0
        MSKDAT  ZERO..,ZERO..  ;CHK
        BCS     1$              ;BR IF ERROR
        INC     R1
        SBUSDG  SDCLB           ;"READ" FUNC 1
        MSKDAT  XVDCN,ZERO..    ;SO IS REALLY A WASTE
        BCS     1$              ;BR IF ERROR
        NORMAL                  ;ELSE TEST PASSES
1$:     ERRMSG  <SBDIAG FUNC >
        MOV     R1,R0           ;FUNC # TO PARAM REG
        ERRCOM  PNTOCS          ;STACK IT


;SEQ346

        FAULT   <DMA20: ERR ON SBUS RESET>


;SEQ347


;SEQ349

.REM    %
        TEST#25 INITIALIZATION--RESET PRIOR TO SET
        %
I.25:   MEMRST                  ;RST ALL (THIS SHOULD WORK NOW)
        RTS     PC
.REM    %
        TEST#25 CHECKS TO SEE THAT THE DIAG FUNCS CAN SET THE BITS
        THEY ARE SUPPOSED TO.
        %
T.25:   INSYNC                  ;*****SUBTEST 1*****
        SBUSDG  SDS4WI          ;ATMP TO SET INTRLV BITS
        MSKDAT  XV4WI,ZERO..    ;CHK
                BCC     1$              ;BR OK
        FAULT   <DMA20 CANT SET INTRLV BIT(S)>
1$:     INSYNC                  ;*****SUBTEST 2*****
        SBUSDG  SDSLB           ;ATMP TO GET LOOPBACK
        MSKDAT  XVCNLB,ZERO..   ;CHK
        BCC     2$              ;BR OK
        FAULT   <DMA20 CANT SET LPBK BIT>
2$:     NORMAL


;SEQ350


;SEQ352

.REM    %
        TEST#26 CHECKS TO SEE IF ALL THE SETABLE BITS CAN BE RESET
        %
T.26:   INSYNC                  ;*****SUBTEST 1*****
        SBUSDG  SDSNOI          ;ATMP TO RESET INTRLV
        MSKDAT  ZERO..,ZERO..   ;CHK
        BCC     1$              ;BR OK
        FAULT   <DMA20 CANT CLR INTRLV BIT(S)>
1$:     INSYNC                  ;*****SUBTEST 2*****
        SBUSDG  SDCLB           ;ATMP TO RST LOOPBACK
        MSKDAT  XVDCN,ZERO..    ;CHK
        BCC     2$              ;BR OK
        FAULT  <DMA20 CANT CLR LPBK BIT>
2$:     NORMAL


;SEQ353


;SEQ355

.REM    %
        THE INIT FOR TEST#27 & TEST#28 LOADS THE AC PROGRAM COMMON TO
BOTH OF THE TESTS.
        %
I.27:
I.28:   RTS     PC              ;SKIP INIT ON LOOPS
        MRESET
        LOADAC  1577,1$         ;LOAD THE AC PROGRAM (AC0-6T0,11)
        RTS     PC              ;INIT DONE
.REM    %
        THE AC PROGRAM         FOR TEST #27 & TEST#28 STS UP AN ADDRESS IN AC17
AND THEN READS FROM THAT ADDRESS.  DATA IS IGNORED: INSTEAD AN SBUS DIAG
FN 0 IS DONE TO READ THE ADDRESS IN THE DAM20 ADDRESS REG. BIT13 OF THE
ADDRESS IS ON TO FORCE NO-AC-REF.
        %
1$:     I10     ROT,14,,1       ;0--ROTATE THE PATTERN IF STARTED HERE
        I10     MOVE,7,,14      ;1--SET UP THE ADR IN AC7 W/ BIT 13 SET
        I10     TLZ,7,,777760   ;2--
        I10     TLO,7,,20       ;3--
        I10     XCT,,,10        ;4--ACCESS MEM IN 23 BIT MODE
        IO10    SBDIAG,,,11     ;5--READ DMA ADR REG
        I10     JRST,4,,1       ;6--HALT TO LET THE PDP11 LOOK
                                ;7--ADDRESS SENT TO MEM
        
SKIP7:  I10     SKIP,,,0,7      ;10-INSTR TO ACCESS MEM
        WD36    1000,0000,0000  ;11-SBUS DIAG FN 0 TO DMA20
                                ;12-SBUS DIAG FN 0 FROM DMA20
                                ;14-[ATTERN ADDRESS GOES HERE
        ENDBLK

;SEQ356

.REM    %
        TEST#27 IS THE ADDRESS PATH TEST TO AND FROM THE DMA20.  IT
SENDS A PATTERN OF ALL ONES, ALL ZEROS, SLIDING ONES, AND SLIDING ZEROS
THRU THE DMA20.  IF THERE IS A STUCK BIT OR SHORT IN THIS PATH IT WILL
SHOW UP HERE.  IF THER IS A FAULT IT IS MOSTLIKELY ON THE M8560 BOARD.
        %
T.27:   MEMRST                  ;RESET THE MACHINE
        DFXCTT,STRCLK           ;RESTART THE CLOCK
        JSR     R4,5$           ;*****SUBTEST 1*****
        .WORD   SEVENS
        JSR     R4,5$           ;*****SUBTEST 2*****
        .WORD   ZERO..
        JSR     R4,3$           ;*****SUBTESTS 3-24*****
        .WORD   1$
        JSR     R4,3$           ;*****SUBTESTS 25-46*****
        .WORD   2$
        NORMAL                  ;ALL OK IF HERE...DONE
1$:     WD36    3777,7777,7777  ;SLIDING 0 PATTERN
2$:     WD36    4000,0000,0000  ;SLIDING 1 PATTERN
;-----SLIDING PATTERN CONTROL LOOP.
3$:     MOV     (R4)+,6$+6      ;PTRN PTR TO LOADAC
        JSR     R4,6$           ;LD PTRN & DO IT
        MOV     #21.,R3         ;LP CNT
4$:     JSR     R4,7$           ;DO NXT PTRN
        DEC     R3              
        BGT     4$              ;LP IF MORE TO DO
        RTS     R4              ;ELSE SLIDING PTRN DONE
;-----SINGLE PATTERN RUN & CHECK RESULTS.
5$:     MOV     (R4)+,6$+6      ;PTRN PTR TO LOADAC
6$:     LOADAC  ACC14,000000   ;PTRN GOES TO AC14
7$:     INSYNC                  ;*****NEXT SUBTEST*****
        RUN     AC0             ;RUN THE PRGM
        JSR     PC,CHKP
        CHKIT   AC7,AC12,B1433C,10$     ;CHK THE RESULT
        BCS     8$              ;BR IF BAD
        RTS     R4              ;ELSE OK...RET TO CALLER


;SEQ357

;-----ERROR HANDLING SECTION.  START INFINITE LOOP & REPORT ERROR.
8$:     LOADAC  ACC6,9$         ;LOAD INSTR TO MAKE PRGM LOOP FOREVER
        RUN     AC1             ;START LOOP
        FAULT   <DMA20: ERROR IN ADDRESS PATH>
9$:     I10     JRST,,,4                ;INF LP INSTR
10$:    .ASCIZ  %\SBUS DIAG FN 0 FROM DMA20%
        .BYTE   -1              ;END OF "CHKIT" TYPE NAME LIST
B1433C: WD36    7777,6000,0003  ;MASK TO LOOK AT ADR 14-33
        .EVEN


;SEQ358

;SEQ360

.REM    %
        TEST#28 CHECKS DMA20 ADDRESS PARITY FOR ONE-WORD REQUESTS.
        FIRST RUN THROUGH PATTERNS WHILE CHECKING FOR ADR PAR ERROR.
        %
T.28:   MEMRST
        PWTES   TSTCON          ;TREST CONTR # TO ERR STK
        MOV     #9$,R4          ;PATTERN POINTER
        LOADAC  ACC10,SKIP7     ;RD INSTR TO AC10
1$:     CMP     R4,#10$         ;READS DONE?
        BNE     2$              ;NO
        LOADAC  ACC10,12$         ;WR INSTR TO AC10
2$:     MOVB    (R4)+,ADRBUF    ;ADDRESS TO BUFFER AREA
        MOVB    (R4)+,ADRBUF+1  ;
        MOVB    (R4)+,ADRBUF+2  ;
        LOADAC  ACC14,ADRBUF    ;LOAD ADDRESS INTO AC14
        JSR     PC,8$           ;DO RD/WR, GET & CHK SBUS STAT
        BEQ     3$              ;BR ON NO SBUS ERR
        PATERR  ADRBUF          ;TYPE ADDRESS
        FAULT   <DMA20 DETECTED ADR PAR ERR>
3$:     CMP     R4,#11$ ;DONE?
        BLE     1$              ;NO, LOOP AGAIN


;SEQ361

.REM    %
        NOW MAKE SURE THAT BAD ADDRESS PARITY CAN BE DETECTED ON A READ
        %
                                ;*****SUBTEST 9*****
        CXQT    BADADR          ;FORCE BAD ADR PAR
        JSR     PC,8$           ;DO WRITE, CHK DMA20 STAT
        BEQ     5$              ;NO ADR PAR ERR WHEN EXPECTED
        JSR     R4,TSTCAP       ;CONI APR TEST *****SUBTEST 10 *****
        .WORD   TCWR
.REM    %
        MAKE SURE ERR CAN BE RST VIA SBUS DIAG F0
        %
        INSYNC                  ;****SUBTEST 11*****
        JSR     R5,APCTST       ;CLR CNTRLR ERR BIT & TEST IT.
        BEQ     4$              ;CLR, O.K.
        FAULT   <DMA20: SBUSDIAG0 CLR0-5, BIT 5 NOT CLR>


;SEQ362

.REM    %
        FORCE BAD ADR PAR FOR WRITE AND MAKE SURE ERROR ACTUALLY OCCURS
        %
4$:     LOADAC  ACC10,SKIP7     ;RD INSTR TO AC7
        CXQT    BADADR          ;FORCE BAD ADR PARITY
        JSR     PC,8$           ;CHK DMA20 STAT
        BNE     6$              ;ERR EXPECTED--BR IF FOUND
5$:     PWTES   #0
        FAULT   <DMA20 FAILED TO DETECT AN ADR PAR ERR>
6$:     JSR     R4,TSTCAP               ;*****SUBTEST 13 *****
        .WORD   TCRD
        INSYNC                  ;*****SUBTEST 14 *****
        MEMRST                  ;RESET ALL ERRORS
        JSR     R5,APETST       ;ADR PAR ERR BIT CLRD?
        BEQ     7$              ;YES...OK
        FAULT   <DMA20: MEMRST, ADR PAR ERR -RESET>
7$:     NORMAL
;-----LOCALDIRTYWORK FUNCTION 2
8$:     INSYNC
        RUN     AC1             ;RUN PROGRAM
        JSR     PC,CHKP
        JSR     R5,APETST       ;TEST DMA20 ADR PAR ERR FLAG
        RTS     PC


;SEQ363

;----THE FOLLOWING PATTERNS ARE THE MINIMUM REQUIRED TO COMPLETELY
;       CHECK THE ADDRESS PARITY CHECK CAPABILITY OF THE DMA20.
;       I SPENT A LOT OF TIME GENERATING THEM, AND IF THEY CHANGE THE
;       DMA20 IN THIS AREA, I'M GOING TO BE DISTURBED!
9$:     WD22    16676665        ;READ ADDRESS
        WD22    10042230        ;READ ADDRESS
        WD22    04410042        ;READ ADDRESS
        WD22    02224417        ;READ ADDRESS
10$:    WD22    15555541        ;WRITE ADDRESS
        WD22    13361114        ;WRITE ADDRESS
        WD22    07733366        ;WRITE ADDRESS
11$:    WD22    01107733        ;WRITE ADDRESS
12$:    I10     SETZM,,,0,7     ;INSTR TO WR TO ADR IN AC7


        .EVEN

        
 


;SEQ367
.REM    %
        INIT TEST#29--LOAD PROG AND CLEAR KBUS BUFFERS
        %
I.29:   MEMRST
        DFXCTT,STRCLK           ;START THE CLK AGAIN
        LOADAC  XLBPM!ACC13!ACC15,1$    ;LOAD AC PRGM (AC1-6, 13, 15)
        RTS     PC              ;INIT DONE
;-----THE FOLLOWING PROGRAM IS USED THROUGHOUT TEST#29 & OTHERS
        BLK10   1
1$:     IO10    SBDIAG,,,13     ;1--TURN ON DMA20, CLEAR, SET 4 WAY INTR
        IO10    SBDIAG,,,15     ;2--TURN ON LOOPBACK
D20SEW: I10     MOVEM,12,,0,11  ;3--MOVE DATA TO KBUS BUFFER
D20SER: I10     MOVE,17,,4,11   ;4--ATMPT TO RETIEVE IT
        IO10    CONI,APR,,14    ;5--GET STATUS OF READ
        I10     JRST,4,,1       ;6--HALT..RESTART AT FIRST BLKO
        ENDBLK  XLBPM,NO.EVEN   ;11-ADR TO SEL KBUS 0, 1, 2, OR 3
                                ;12-PTRN BEING SENT OUT
        WD36    1160,4000,0000  ;13-CLR DMA20, 4 BUS MODE
                                ;14-CONI APR STUFF
        WD36    1000,4000,0001  ;15-SET LOOP BACK
                                ;16-JUNK
        .EVEN                   ;17-ECHO PTRN GOES HERE


;SEQ368

;-----SUBROUTINE TO GENERATE ADDRESSES FOR TEST#29 THRU TEST#30.
;       THE ADDRESSES GENERATED ARE 3000 THRU 3003 WHICH WILL ACCESS
;       KBUSSES 0-3 RESPECTIVELY WHEN DMA20 IS IN 4-BUS LOOPBACK MODE.
SETNAI: MOV     #2777,D20NAA    ;RE-INIT ADR
        RTS     R5              ;LOAD ADR TO AC11
SETNAA: INC     D20NAA          ;INC ADR TO GET NXT KBUS
        CMP     D20NAA,#3004    ;DONE YET?
        BLT     1$              ;NO...CONTINUE
        POP     R5              ;ELSE RESET STK
        NORMAL                  ;AND TEST IS DONE
1$:     LOADAC  ACC11,D20NAA    ;PUT ADR IN AC11
        RTS     R5              

;-----SUBROUTINE TO CALL OUT FAILING KBUS FOR TES#29 THRU TEST#30.
DMAKLM: PWTES   D20NAA  ;KBUS # TO ERR STK FOR ISOLATION
        ERRMSG  <EXTERNAL MEM KBUS # >
        MOV     D20NAA,R0
        ERRCOM  PNTNBR
        RTS     R5              ;RETURN TO CALLER
D20NAA: .WORD   0,0,0


;SEQ369

.REM    %
        TEST#29 CHECKS EACH DATA PATH THROUGH THE KBUS BUFFERS, ALL
        PATTERNS THROUGH EACH BUFFER, THEN ON TO THE NEXT BUFFER.
        THE PATTERNS ARE 1S, 0S & SLIDING 1S AND 0S.
        %
T.29:   JSR     R5,SETNAI
        
1$:     JSR     R5,SETNAA       ;GEN ADR FOR NXT KBUS
        JSR     R4,3$           ;CHECK PATRN
        .WORD   SEVENS          ;OF ALL ONES
        JSR     R4,3$           ;CHK PTRN
        .WORD   ZERO..          ;OF ZEROS
        SBINI   36.             ;INIT SLIDING PATTERNS SUBROUTINE
2$:     SB                      ;GET A PATTERN
        BCS     1$              ;BR IF NO MORE FOR THIS KBUS
        JSR     R4,3$           ;CHK PTRN
        .WORD   SBPAT           ;USE PTRN JUST GENERATED
        BR      2$              ;LOOP UNTIL NO MORE PTRNS
;-----LOCAL DIRTYWORK SUBROUTINE LOADS A PATTERN, RUNS THE AC PROGRAM
;       AND CHECKS THE RESULTS
3$:     MOV     (R4),4$+4       ;DPOST PARAM
        MOV     (R4)+,5$                ;MSKDAT PARAM
4$:     DPOST,AC12,000000       ;PTRN TO AC PRGM
        JSR     PC,CHKED        ;CHK EXAM/DPOS
        INSYNC                  ;*****ALL SUBTESTS
        RUN     AC1             ;RUN THE PROGRAM
        JSR     PC,CHKP
        EXAMT,AC17,PFM          ;ECHO CHK
        JSR     PC,CHKED
        JSR     R5,MSKDAT
        .WORD   ZERO..          ;CHK ALL BITS
5$:     .WORD   000000          ;ADR OF PTRN TO BE SUPPLIED
        BCS     6$              ;BR ON ERR
        RTS     R4              ;ELSE OK--RET
6$:     JSR     R5,DMAKLM               ;PRINT SBUS #
        LOADAC  ACC5,RUNJRS     ;SET UP FAST LOOP
        RUN     AC1             ;START IT
        FAULT   <DMA20 DATA PATH ERR USING LOOPBACK. FAST LOOP NOW RUNNING>


;SEQ370


;SEQ373

.REM    %
        TEST#30 INITIALIZATION JUST RESETS THE MACHINE.
        %
I.30:   MEMRST                  ;SIMPLY RESET MEM CONTROLLERS
        DFXCTT,STRCLK           ;RESTART THE CLOCK
        RTS     PC              ;& RET
.REM    %
        TEST#30 CHECKS DATA PARITY ON ALL THE KBUSSES VIA LOOPBACK
        %
T.30:   JSR     R5,SETNAI
1$:     JSR     R5,SETNAA       ;GEN ADR FOR NXT KBUS
        MOV     #5$,R3          ;PTRN FOR TESTS
2$:     MOV     R3,3$+4         ;PTRN PTR TO PARAM WD FOR DEPOSIT
3$:     DPOST,AC12,000000       ;PTRN TO AC12
        JSR     PC,CHKED                ;CHK EXAM/DPOS
        INSYNC                  ;SYNC IF FAILING WUBTST
        RUN     AC1             ;DO WRITE/READ/CHK
        SBUSDG  ZERO.           ;GET DMA20 STATUS
        MSKDAT  ZERO..,MSDF0A   ;ALL ERR BITS SHD B 0
        BCC     4$              ;BR IF THEY ARE
MOV     R3,R0           ;ELSE ERR...PTRN PTR TO R0 FOR 'PATERR'
        JSR     R5,PATERR       ;PTRN TO ERR STK
        JSR     R5,DMAKLM       ;CALL OUT KBUS
        FAULT   <ERR DETECTED W/LOOPBACK>
4$:     ADD     #5,R3           ;PNT TO NXT PTRN
        CMP     R3,#6$          ;DONE ALL PTRNS?
        BLOS    2$              ;NO
        BR      1$              ;LOOP TIL ALL KBUSSES DONE


;SEQ374

;-----DATA PATTERNS FOR DMA20 DATA PATH PARITY CHECK
5$:     WD36    6664,4020,4022
        WD36    7555,7333,7111
        WD36    4406,6602,2755
        WD36    5737,5511,1666
        WD36    2043,3766,6440
        WD36    3372,0475,5573
        WD36    0221,1144,0337
6$:     WD36    1110,2257,3204

        .EVEN


;SEQ375


;SEQ377

.REM    %
INITIALIZATION FOR TEST#31
        %
I.31:   MEMRST
        DFXCTT,STRCLK           ;RESTART THE CLOCK
        RTS     PC

.REM    %
        TEST#31 CHECKS TO SEE IF EACH KBUS CAN DETECT AND REPORT BAD
        DATA PARITY.
        %
T.31:   JSR     R5,SETNAI
1$:     JSR     R5,SETNAA               ;SET ADR INTO AC PRGM
        LOADAC  ACC3!ACC4,<BADDAT,D20SEW>       ;LOAD OVERLAY (AC3-4)
        JSR     R4,2$           ;RUN AC PRGM, CHK RESEULTS
        .WORD   XV2             ;VALUE PARAM
        LOADAC  ACC3!ACC4,<CLRAPR,D20SER>       ;LOAD ACS FROM SCATTERED 11 MEM
        JSR     R4,2$           ;RUN PRGM AND CHK
        .WORD   XV1
        BR      1$              ;LOOP TIL ALL KBUSSES DONE
;-----LOCAL DIRTYWORK SUBROUTINE.  RUNS THE AC PRGM, THEN CHECKS THE
;       RESULTS WITH AN SBUS DIAG AND A CONI APR.
2$:     MOV     (R4)+,3$        ;MOVE PARAM FOR MSKDAT
        INSYNC                  ;*****SUBTESTS 1,3,5-10*****
        RUN     AC1             ;RUN THE AC PRGM
        SBUSDG  ZERO.           ;GET DMA20 STATUS
        JSR     R5,MSKDAT       ;CHK
        .WORD   MSDF0           ;MASK ADR
3$:     .WORD   000000          ;VAALUE ADR TO BE SUPPLIED AT RUN TIME
        BCC     4$              ;BR OK
        JSR     R5,DMAKLM
        FAULT   <DMA20 DIDNT DETECT DATA PAR ERR>
4$:     TSTB    D20NAA          ;TESTING KBUS 0?
        BNE     5$              ;IF NOT, DON'T BOTHER W/THIS SUBTEST
        INSYNC                  ;*****SUBTESTS 2 & 4
        SBUSDG  SDC05           ;ATTEMPT TO CLR ERROR BITS


;SEQ378

        JSR     R5,MSKDAT               ;CHK
        .WORD   MSDF0A,ZERO..   ;MASK,EXPCTD DATA
        BCC     5$              ;BR IF BITS CLRC....OK
        FAULT   <DMA20: DATA PAR ERR BIT -CLRD>
5$:     SM                      ;CLR OUT THE EBOX
        EXAMT,AC14,D20TMP              ;GET CONI APR DATA FROM AC14
        JSR     PC,CHKED
        BIT     #CIAPRP,(R0)    ;PAR ERR BIT SET?
        BEQ     6$              ;NO...FAULT
        RTS     R4              ;EXIT BACK TO TEST
6$:     FAULT   <MB PAR ERR NOT DETECTED BY APR>


;SEQ379


;SEQ381

.SBTTL          EXTERNAL MEMORY TESTS

.REM    %
        DGKBB TEST#32 & TEST#33 ARE THE EXTERNAL MEMORY DATA PATH TESTS.
        THESE TESTS ARE DESIGNED TO SHOW UP AN ERROR IN THE DATA PATH
        TO & FROM MEWMORY.  SUFFICIENT ADDRESSES ARE TESTED TO MAKE SURE
        THAT ALL DAA PATHS ARE CHECKED, REGARDLESS OF MEMORY TYPE,
        CONFIGURATION AND INTERLEAVING.  BOTH TESTS LEAVE A FAST
        SCOPE LOOP RUNNING UPON DETECTION OF AN ERROR.
        %
.REM    %
        TEST#32 IS THE ONES & ZEROS DATA PATH CHECK.  THE INIT LOADS AN
        AC PROGRAM WHICH PERFORMS THE TEST.
        %
I.32:   BR      1$              ;SKIP INIT ON LOOPS
        MEMRST                  ;RESET THE MEMORY
        JSR     R5,DMADET               ;GET EXT MEM CONFIGURATION
        LOADAC  XDPRM,2$                ;LOAD AC PRGM (AC0-13)
1$:     RTS     PC              
;-----AC PROGRAM TO SEND & CHECK 1S & 0S TO EXTERNAL MEMORY
        BLK10   0
2$:     I10     SETO,16,,0      ;0--FIRST PTRN OF ALL ONES
        I10     MOVEM,16,,0,17  ;1--PTRN TO MEM
        I10     MOVE,14,,0,17   ;2--READ IT BACK
        I10     MOVE,15,,0,17   ;3--RD IOT BACK AGAIN TO CHK RD-RSTR
        I10     CAME,15,,16     ;4--SKIP IF SAME...OK
        I10     HRLI,3,,610657  ;5--ELSE FORCE STATIC LOOP ON ERROR
        I10     JUMPL,3,,1              ;6--LOOP ON ERROR
        I10     AOJE,16,,1      ;7--GEN NXT PTRN
        I10     JRST,4,,0       ;10-HALT WHEN DONE
                                ;14-SCRATCH
                                ;15-PTRN FROM EM OGES HERE
                                ;16-PTRN TO MEM GOES HERE
        ENDBLK  XDPRM           ;17-ADDRESS UNDER TEST GOES HERE


;SEQ382

.REM    %
        TEST#33 IS A SLIDING PATTERN TEST.  THE INITIAL PATTERN IS
        757020,,020757.  THIS PATTERN IS ROTATED 36 TIMES, EACH TIME
        BEING SENT TO MEMORY & CHECKED.  THE INIT JUST LOADS THE AC
        PROGRAM WHICH DOES THIS.
        %
I.33:   RTS     PC              ;SKIP INIT ON LOOPS
        RSTMBX                  ;RESET THE MACHINE
        LOADAC  XRDPPM,1$       ;LOAD AC PRGM (AC0-14)
        RTS     PC              
;-----AC PROGRAM TO SEND 7 CHECK A ROTATING PATTERN TO EXTERNAL MEMORY
        BLK10   0
1$:     I10     MOVE,16,,12     ;0--COPY PTRN TO BE ROTATED
        I10     MOVEM,16,,0,17  ;1--MOVE PTRN TO MEM
        I10     MOVE,15,,0,17   ;2--GET BACK PATTERN
        I10     CAME,15,,16     ;3--IS IT OK...SKIP IF YES
        I10     HRLI,2,,610657   ;4--ELSE ERR...FORCE STATIC ERROR LOOP
        I10     JUMPL,2,,1      ;5--LOOP ON ERROR
        I10     ROT,16,,1       ;6--RETOTATE PTRN TO GET NXT ONE
        I10     CAMN,16,,12     ;7--SKIP IF NOT DONE YET
        I10     JRST,4,,0       ;10-ELSE HALT...DONE
        I10     JRST,,,1        ;11-LOOP TIL ALL PTRNS DONE
        WD36    7570,2002,0757  ;12-INITIAL PATTERN
                                ;15-PTRN FROM EMM GOES HERE
                                ;16-PTRN TO MEM GOES HERE
        ENDBLK  XRDPPM          ;17-ADDRESS UNDER TEST GOES HERE


;SEQ383
.REM    %
        THE EXTERNAL MEMORY DATA PATH TEST.  NOTE THAT A HARD, FAST
        SCOPE LOOP IS LEFT RUNNING UPON DETECTION OF AN ERROR.
        %
T.33:
T.32:   MOV     DMA2TS,R2       ;DOES DMA REPORT ANY MEMORY?
        BGT     1$              ;YES...OK
        FAULT   <DMA20: NO MEMORY FOUND>
1$:     MOV     #DMA20T,R1      ;ADR OF XMEM TABLE TO R1 FOR PTR
 
2$:     MOV     (R1)+,R0        ;16K ADR TO PARAM REG
        JSR     R5,REAP2        ;EDIT TO WD36 FMT
        BIS     #20,(R0)        ;SET BIT TO SKIP AC'S
        MOV     (R1)+,R3        ;GET 16K MEM BLK SIZ
        ASL     R3              ;MAKE IT 4K SIZ
        ASL     R3              
3$:     LOADAC  ACC17,REAPWD    ;ADR TO PRGM
        INSYNC                  ;*****SUBTESTS 1-2*****
        RUN     AC0             ;RUN PTRNS THRU GVN ADR
        BCC     4$              ;BR IF OK
        JSR     R5,RCAS         ;STACK ADR, CONTR #
        JSR     R5,GDPM         ;SRTACK PATTERNS
        FAULT   <EXTERNAL MEM DATA PATH ERROR>
4$:     MOV     #REAPWD,R0              ;PTR SAVES SPAC
        INC     (R0)            ;NXT ADR
        BIT     #4,(R0)         ;IS IT OK?
        BEQ     3$              ;YES
        ADD     #10000-4,(R0)+  ;ELSE ADJ TO NXT 4K ADR
        ADC     (R0)
        DEC     R3              ;ANY MORE 4K ADR'S TO TST IN THIS BLK?
        BGT     3$              ;BR IF YES
        DEC     R2              ;ANY MORE MEM BLKS TO TST?
        BGT     2$              ;LOOP IF YES
        NORMAL                  ;ELSE TEST DONE



;SEQ384


;SEQ386


;SEQ388

.REM    %
        TEST#34 IS THE EXTERNAL MEMORY ADDRESS/TAG TEST.  THE BASIC
        FUNCTION OF THIS TEST IS TO MAKE SURE THAT ALL THE ADDRESS SELECTION
LOGIC IS WORKING PROPERLY.  THERE ARE MANY POSSIBLE FAILURE MODES, AND
        THERE IS NO INIT FOR THIS TEST.
        %
T.34:   MOV     #DMA2TS,R0      ;ADR OF MEM RESP TABLE TO PARAM REG
        JSR     R5,ADRTAG               ;DO TEST
        BCC     1$
        FAULT   <EXTERNAL MEM ERROR. PROBABLY ADR INTERFERENCE.>
1$:     NORMAL


;SEQ389


;SEQ391

.REM    %
        EXTERNAL MEMORY READ/PAUSE/WRITE TEST.  TEST INIT LOADS
        THE AC PROGRAM.
        %
I.35:   BR      2$              ;SKIP FIRST PART OF INIT ON LOOPS
        RSTMBX                  ;RESET THE MACHINE
        LOADAC  XRPWPM,3$       ;LOAD AC PRGM (AC2-14)
        TST     DMA2TS          ;ANY X MEM?
        BGT     1$              ;BR IF YES
        NORMAL                  ;ELSE DONT DO THIS TEST
I34C=.
1$:     MOV     DMA20T,R0               ;GET ADR OF LOWWEST X MEM
        JSR     R5,REAP2                ;CNVRT TO WD36 FMT
        BIS     #20,(R0)        ;SET AC SKIP BITS
2$:     DPOST,AC17,REAPWD       ;ADR TO AC17 FOR AC PRGM
        RTS     PC              ;INIT DONE
;-----AC PRGM PUTS -1 IN A MEM LOCATION, THEN DOES & CHKS AN A0S
        BLK10   2
3$:     I10     TLO,1,,400000   ;2--SET NO-ERR FLG
        I10     SETOM,,,0,17    ;3--PUT -1 IN MEM LOC
T31I:   I10     AOS,,,0,17      ;4--DO A0S
        I10     SKIPE,15,,0,17  ;5--SKIP IF RESULT OF A0S WAS 0
        I10     TLZ,1,,400000   ;6--ELSE CLR NO-ERR FLAG
        I10     JUMPGE,1,,3     ;7--LOOP FOR EVER IF NO-ERR FLG CLR
        I10     AOS,,,17        ;10--ELSE INC ADR FOR NXT TIME
        I10     JRST,4,,2       ;11-HALT
                                ;15-ECH RECEIVED BY EBOX
                                ;16-PATTERN SENT BY EBOX
        ENDBLK  XRPWPM          ;17-ADDRESS TO WHICH PTRN WAS SENT


;SEQ392

.REM    %
        EXTERNAL MEMORY READ/PAUSE/WRITE TEST CHECKS TO MAKE SURE THAT
        THE DMA20 DOES THE CORRECT THING IN THAT IT CAN GO THROUGH THE
R/P/W CYCLE WITHOUT MODIFYING THE ADDRESS.
        %
T.35:   CMPB    DMA20I,#1       ;ONE WAY INTERLEAVE ON DMA20?
        BNE     1$              ;BR IF NO...DON'T DO DVAOT
        JSR     R4,DVAOT        ;DATA VALID ***** SUBTESTS 1&2 *****
        .WORD   T31I
1$:     MOV     #2,R5           ;KEEP SUBTEST # UPTO DATE
        MOV     #REAPWD,R1      ;SET UP FOR D10ZRO
        MOV     #4,R0
        D10ZRO                  ;CLR 4 WD BLOCK OF X MEM
2$:     INSYNC                  ;*****SUBTESTS 3-6 *****
        RUN     AC2             ;START THE AC PRGM
        BCS     3$              ;ERR IF IT DIDNT HALT
        CMP     R5,#4           ;DONE YET?
        BLT     2$              ;LOOP IF NOT
        NORMAL                  ;ELSE EXIT
3$:     EXAMT,AC17,ERRADR       ;GET ADR OF WHERE ERR OCCURED
        JSR     PC,CHKED                ;CHK EXAM/DPOS
        ERRADR  ERRADR          ;ERR ADR TO ERR STK

        FAULT   <EXT MEM READ/PAUSE/WRITE ERR>


;SEQ393


;SEQ395

.REM    %
        THE INIT FOR TEST#36 LOADS THE AC PROGRAM.
        %
I.36:   RTS     PC              ;SKIP INIT ON LOOPS
        RSTMBX                  ;RESET THE MACHINE
        LOADAC  XSSPM!ACC16,1$  ;LOAD AC PRGM (AC0-4,16)
        JMP     I34C            ;FORMAT & LOAD EXT MEM ADR
;-----AC PROGRAM FOR TEST#36
        BLK10   0
1$:     I10     MOVEM,16,,0,17  ;0--PTRN TO MEM
        I10     MOVE,15,,0,17   ;1--GET PTRN ECHO
        I10     JRST,4,,0               ;2--HALT
        ENDBLK  XSSPM,NO.EVEN   ;15-ECHO GOES HERE
        WD36    7570,2002,0757  ;16--PATTERN

        .EVEN           ;17-FIRST EXT MEM ADR
 


;SEQ396

.REM    %
        TEST#36 IS THE EXTERNAL MEMORY (DMA20) SINGLE STEP TEST.  IT
        STARTS THE AC PROGRAM IN SINGLE STEP MODE & RUNS THROUGH IT TO
        MAKE SURE THINGS HAPPEN IN THE CORRECT ORDER.
        %
T.36:   CLR     RUNJRS          ;INIT PC=0
        STEXCT  RUNJRS          ;INIT A JRST 0
        DFXCTT,SETRUN           ;ALLOWS THE WHOLE AC PRGM TO RUN
        INSYNC                  ;*****SUBTEST 1*****
        FIND    <164,31.,0>     ;FIND "ACKN PULSE L" FROM THE MOVEM
        BCC     1$              ;BR IF FOUND
        FAULT   <DMA20: "ACKN PULSE L" NOT FOUND/SINGLE STEP WRITE>
1$:     FIND    <166,27.,1>     ;WAIT FOR MOVE TO START
        BCC     2$
        ERROR   <"MEM RD RQ B H" NOT FOUND>
2$:     INSYNC                  ;*****SUBTEST 2*****
        FIND    <164,31.,0>     ;FIND "ACKN PULSE L" FROM THE MOVE
        BCC     3$              ;BR IF FOUND...OK
        FAULT   <DMA20: "ACKN PULSE L" NOT FOUND/SINGLE STEP READ>
3$:     INSYNC                  ;*****SUBTEST 3*****
        TENBIT  165,30.         ;"CORE DATA VALID -2 L" SET RIGHT NOW?
        BEQ     5$              ;YES...OK
        FIND    <165,30.,0>     ;"CORE DATA VALID -2 L" MEANS GETTING DATA
        BCS     4$              ;BR IF NOT FND AT ALL
        CMP     R0,#6           ;ELSE SHD HAV BEEN EXACTLY 6 TICKS
        BEQ     5$              ;IT WAS...OK
4$:     FAULT   <DMA20: "CORE DATA VALID -2 L" NOT FOUND/SINGLE STEP READ>


;SEQ397

;-----STEP TO HALT LOOP.  MAKE SURE DATA MOVED OK.
5$:     MOV     BASE20,R2       ;GET DTE20 BASE ADDRESS
        ADD     #DIAG1,R2       ;ADR OF HALTED BIT WORD
        MOV     #200,R1         ;LOOP COUNTER
6$:     STEP                    ;MBOX CLK
        BIT     #HALTLP,(R2)    ;KL HALTED YET?
        BNE     7$              ;YES
        DEC     R1              ;ELSE LOOP CON COUNT
        BGT     6$              
        JSR     PC,CHKP+4       ;FORCE ERR MSG
7$:     DFXCTT,STRCLK           ;START THE CLK FOR EXAM/DPOS
        EXAMT,AC15,D20TMP       ;GET ECHO PTRN
        JSR     PC,CHKED
        MSKDAT  ROTPAT          ;CHECK RETURNED DATA
        BCC     8$              ;BR IF OK
        FAULT   <DMA20: SINGLE STEP WRITE/READ TO MEM>
8$:     NORMAL


;SEQ398


;SEQ400

.REM    %
        THE INIT FOR THE DMA20 4 WORD READ TEST CONSISTS OF
        SETTING UP THE AC'S AND SOME CONSTANTS  FOR THE TEST.
        %
I.37:   RTS     PC              ;SKIP INIT ON LOOPS
        MOV     DMA20T,R1               ;GET 16K FMT ADR OF LOW X MEM
        JMP     FWDRDI          ;GO FINISH INIT

.REM    %
        DMA20 (EXTERNAL MEMORY) 4 WORD READ TEST.  SEE SUBROUTINE FWDRDT
        FOR EXPLANATIONS.
        %
T.37:   JSR     PC,FWDRDT               ;*****SUBTESTS 1-4*****
        BCC     1$              ;BR IF NO ERROR
        FAULT   <DMA20: 4 WD READ ERR>
1$:     NORMAL


;SEQ401


;SEQ403

;-----THIS SECTION IS CALLED AT INITIALIZATION LEVEL.  IT MARKS THE DMA20 AS
;TESTED, AND DROPS THROUGH TO THE CONFIGURATOR.
XMEMS:  CLRB    DMA20           ;NO MORE DMA'S TO TEST
        BISB    #BIT7,TYPNUM+4  ;MARK DMA TESTED

;-----CONFIGURES MEMORY.  ONLY CONTROLLERS PREVIOUSLY TESTED ARE USED UNLESS NO
;MEMORY HAS BEEN TESTED; IN WHICH CASE, ALL MEMORY IS CONFIGUEED.
MEMSET: CLR     R0              ;CONTROLLER#
1$:     MOVB    TYPNUM(R0),R1   ;GET CONTROLLER TYPE
        BEQ     3$              ;BR IF NO CONTROLLER EXISTS
        BMI     2$              ;BR IF EXISTS AND WAS TESTED
        ASL     R1              ;ELSE PRETEND ITS NOT THERE
        DECB    @MDCP-2(R1)     ;
        CLRB    TYPNUM(R0)      ;
        CLRB    MODNUM(R0)      ;
        BR      3$              ;NEXT CONTROLLER
2$:     BIC     #177600,R1      ;RESTORE TYPE DESIGNATION
        MOVB    R1,TYPNUM(R0)   ;
        ASL     R1              ;
        INCB    @MDCP-2(R1)     ;COUNT # OF THIS TYPE
3$:     INC     R0              ;NEXT CONTROLLER
        CMP     R0,#37          ;LAST ONE?
        BLE     1$              ;NO, CHECK NEXT
        MEMRST                  ;RESET ALL MEM PRIOR TO CONFIGURING IT
        TSTB    MSTROS          ;DO WE HAVE A MASTER OSCILLATOR
        BNE     6$              ;YES..SKIP MEM CONFIG ALTOGETHER
        TST     MA20            ;ANY INTERNAL MEM TESTED?
        BNE     4$              ;YES, CONFIGURE
        TSTB    DMA20           ;ANY EXTERNAL MEM TESTED?
        BNE     4$              ;YES, CONFIGURE
        SBUPRG
        JSR     R5,CONDET       ;REDETERMINE MEM CONFIG
4$:     JSR     R5,DMADET       ;DETERMINE EXTERNAL MEM CONFIG
        BIS     #PTS,MCCB       ;SET PHYSICAL CONFIG DONE
        BITB    #BIT1,DEVFLG    ;ALREADY REPORTED?
        BNE     5$              ;YES, BYPASS REPORT
        JSR     R5,SETLT        ;SET LOGICAL TABLE
        JSR     R5,REPLOG       ;REPORT LOGICAL CONFIGURATION
        BISB    #BIT1,DEVFLG    ;SET CONFIGURATION REPORTED
5$:     JSR     R5,MEMCON       ;CONFIGURE MEMORIES
        JSR     R5,CLRALC       ;CLR ANY 'ALLOCATED' BITS MEMCON LEFT IN
                                ;TYPNUM, AS THESE WILL INTERFERE.
6$:     TST     SCANWD          ;IN GERNERATION PASS?
        BNE     ENDPAS          ;BR IF YES
        RTS     PC              ;ELSE PASS DONE

;SEQ404

;-----END OF GENERATION PASS ROUTINE
ENDPAS: PMSG    <DHKBB GEN PASS DONE\>
        PMSG    <GEN PASS DONE W/ ALL MEM TYPES? (Y,N) _>
        TTILNW,TTIYES           ;GET ANSWER
        BCS     3$              ;BR ON GIBBERISH
        BMI     1$              ;BR ON NO...DONT DISABLE THIS SECTION
        CLR     SCANWD          ;CLR PASS CONTROL WD
        GETVER                  ;GET PRGM VERSION NUMBER
        PNTCI,"CD
        BR      2$
1$:     PMSG    <CDA>
2$:     PMSG    < DHKBB 3000,>   ;SET UP CMD FOR EXEC
        MOV     $$FF,R0
        PNTOCS
        PNTVER
        PCRLF
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        PRGCMD          ;DUMP THIS PROGRAM
        BCC     4$              ;BR IDF DUMP OK
        PMSG    <CDUMP ERR\>
3$:     CLR     SCANWD          ;INDICATE GEN PAS DONE
4$:     PRGHLT

;SEQ405

.REM    %
        DATA AREAS COMMON TO TWO OR MORE TESTS
        %
ERRADR: .WORD   0,0,0           ;ADDRESS IN ERROR GOES HERE
D20TMP: .WORD   0,0,0           ;SCRATCH AREA
ADRBUF: WD36    0,0,0           ;EXPAND 22 BIT ADRS HERE
ZERO.:  WD36    0000,0000,0000  ;FOR USE BY SBUS DIAG
SEVENS: WD36    7777,7777,7777  ;FOR GENERAL USE
CIAPRP=4000                     ;PARITY ERR BIT IN CONI-APR
.REM    %
        MASKS, EXPECTED VALUES, INSTRUCTINS, AND SBUS DIAG FUNCTIONS
        %
XCT10:  I10     XCT,,,10                ;EXECUTE OF INSTR IN AC10
RDMEM:  I10     MOVE,AC17,,0,7  ;MEM ADR AC7 TO AC17
WRMEM:  I10     MOVEM,AC7,,0,7  ;AC7 TO MEM ADR AC7
RDAPR:  IO10    CONI,APR,,17    ;READ APR FLAGS
BADADR: IO10    CONO,PI,,400000 ;FORCE BAD ADR PARITY
BADDAT: IO10    CONO,PI,,200000 ;FORCE BAD DATA PARITY
CLRAPR: IO10    CONO,APR,,27700 ;CLEAR APR FLAGS
SDS4WI: WD36    0060,4000,0000  ;SBDF0 SET 4-WAY INTRLV
SDSLB:  WD36    0000,4000,0001  ;SBDE1 SET LOOPBACK
MAXMA:  WD36    0000,0021,7001  ;SET MA20 MAX RESPONSE
MAXMB:  WD36    0000,0043,7001  ;SET MB20 MAX RESPONSE
SDCLB:  WD36    0000,0000,0001  ;SBDF1 CLEAR LOOPBACK, ECHO THE REST


;SEQ406

XVDCN:  WD36    0002,0000,0000  ;XVAL DMA20 CONTROLLER #
XV4WI:  WD36    0060,0000,0000  ;XVAL 4-WAY INTRLV
XVCNLB: WD36    0002,4000,0000  ;XVAL DMA20 CONTRLR # AND LOOPBACK
SDSNOI: WD36    0000,4000,0000  ;SBDF0 SET NO INTRLV
SDC05:  WD36    0100,0000,0000  ;SBDF0 CLEAR 0-5 FROM MEM
XV1:    WD36    0460,4000,0000  ;XVAL FOR TEST
MSDF0:  WD36    0017,1777,7777  ;MASK
MSDF0A: WD36    0077,7777,7777  ;MASK TO LOOK AT ALL SBDF0 ERR BITS
XV2:    WD36    0260,2000,0000  ;XVAL FOR TEST
MSNIME: WD36    1100,0000,0000  ;MASK TO IGNORE MA20/MB20 ERRORS
        .EVEN


;SEQ407



.SBTTL  MEMORY CONFIGURATOR, VERSION 3B                 
.REM    %
        THIS IS VERSION 3B OF THE MEMORY CONFIGURATOR.  THIS CODE IS NOW
OBSOLETE BUT IS MAINTAINED FOR USE WITH DGKBB/DHKBB.  THIS VERSION RECOGNIZES
MF20 MOS MEMORY CONTROLLERS AND MX20S, BUT IS QUITE INCAPABLE OF DOING ANYTHING
WITH THE AFORMENTIONED DEVICES.
----------------------------------------------------------------------------------

        THIS IS VERSION 3A OF THE MEMORY CONFIGURATOR.THE 2 DIFFERENCES
BETWEEN THIS VERSION AND THE LAST ARE: (1) AN ERROR WAS FIXED IN THE KL MODEL
DETERMINATION WHICH CAUSED EXTERNAL MEMORY DETERMINATION TO FAIL.  (2) THE ORDER
OF THE CONFIGURATION RULES IS CHANGED SO THAT THE MOST CONSTRAINED RULES ARE
DONE FIRST WHICH SHOLD LESSEN THE TENDENCY TO CREATE GAPS IN THE MEMORY SPACE.
-----------------------------------------------------------------------------------

        THIS IS VERSION 3 OF THE MEMORY CONFIGURATOR.  THE MAJOR DIFFERENCE
BETWEEN VERSION 2A AND 3 IS THE METHOD OF DETERMINING THE CONFIGURATION OF
EXTERNAL MEMORY.  THE FIRST MAJOR CHANGE IS THAT MCON ADAPTS TO THE MICROCDE IN
MODEL A KL10S TO USE EITHER SXCTS OR EXTENDED ADDRESS EXAMINES TO MAP EXTERNAL
MEMORY.  THE SECOND MAJOR DIFFERENCE IS THAT MCON NOW CHECKS THE ITNERLEAVE MODE
OF ALL EXTERNAL MEMORY AND PICKS THE BEST ONE POSSIBLE.  THERE ARE FURTHER MINOR
DIFFERENCES IN THE ROUTINE WHICH REPROTS THE EXTERNAL MEMORY RESPONSE (REPDMA).
ALL THE MAJOR CHANGES ARE IN DDCON (IN FACT DDCON WAS RE-WRITTEN).
--------------------------------------------------------------------------------------

        THIS IS VERSION 2A OF THE KL10 MEMORY CONFIGURATOR.  THE DIFFERENCE
BETWEEN VER. 2 AND 23A IS THAT 2A HAS BEEN UPDATED TO ALLOW FOR MODEL B
MACHINES.  MOST CHANGES WERE IN THE "DMADET" SECTION.
------------------------------------------------------------------------------------

        THIS IS VERSION 2 OF THE KL10 MEMORY CONFIGURATOR.  THERE ARE MAJOR
DIFFERENCES BETWEEN VERSIONS 1 AND 2.

        THE FIRST  AND MOST IMPROTANT DIFFERENCE IS IN THE MANNER IN WHICH THE
MA20 AND MB20  MEMORY CONTROLLERS ARE HANDLED:  VERSION 1 WOULD ATTEMPT TO
MAXIMIZE INTERLEAVE AT THE COST OF STORAGE APACITY IN SOME CASES, WHEREAS
VERSION 2 ATTEMPTS TO MAXIMIZE STORAGE.
        VERSION 1 WOULDNOT ALLOW GAPS IN THE PHYSICAL MEMORY ADDRESS SPACE
WHEREAS VERSION 2 WILL.  IT IS UP TO THE USER TO WORK AROUND THESE GAPS IF AND
WHERE THEY OCCUR.
        VESION 2 HAS ALL POSSIBLE RULES FOR CONFIGURATION OF MA20 AND MB20
CONTROLLERS.  VERSION 1 DID NOT.
        VERSION 2 HAS BEEN CONSIDRABLY CLEANED UP OVER VERSION 1, IN ADDITION
VERSION 2 HAS FACILITIES FOR HANDLING FUTURE INTERNAL MEMORY TYPES AS YET
UNDEFINED.
        VERSION 2 HAS FACILITIES FOR FORCING INTERLEAVE MODE AND ORDER OF
MA20/MB20 CONTROLLER UTILIZATION.  THESE FACILITIES ARE CONTROLLED BY THE
VARIABLE "INTMOD".  "CONEX" HAS FACILITIES FOR SETTING AND CLEAR-ING INTMOD.
WARNING:        FORCING INTERLEAVE MODE MAY RESULT IN LOSS OF MEMORY BECAUSE VERSION 2
WILL NOT DELETE STORAGE MODULES TO MAKE A CONTROLLER FIT AN INTERLEAVE MODE.
                        MAY YOU HAVE GOOD MEMORIES,
                                JEFFREY ARNO BARRY 29857

        %


;SEQ408

;-----SPECIALIZED ADDR FUNCTIN FOR ALCAT AND OTHERS
;       INPUTS:CONTR# IN R0, TYPNUM
;       OUTPUTS:TYPNUM, PROPER CATTAB ENTRY ADDR IN R0
CATAC:BISB      #200,TYPNUM(R0)
CATAC2: ADD     R0,R0
        ADD     R0,R0
        ADD     #CATTAB,R0
        RTS     PC
;-----SUBROUTINE TO OUTPUT AN ADDRESS<CONDITIONAL TAB><SPACE>
EPA:    PUSH    R0
        JSR     R5,REAP2                ;EDIT THE ADDR/16K WORD
        PNTADR                  ;PRINT THE ADDR
        CMP     (SP)+,#20       ;<SPACES> NECESSARY FOR ALLIGNMENT?
        BGE     1$      ;NO
        PSPACE
        PSPACE
        PSPACE
1$:     RTS     R5
;-----SUBROUTINE TO CHANGE AN ADDR/16K WORD TO WD36 FORMAT
REAP2:  CLC             ;CLEAR CARRY BIT TO AVOID TRASH
        PUSH    R1

        MOV     #REAPWD+5,R1
        CLRB    -(R1)
        CLRB    -(R1)
        ROR     R0              ;POSITION AND SET BITS 14-19
        ROR     R0
        MOVB    R0,-(R1)
        ROR     R0              ;BITS 20,21
        SWAB    R0
        MOVB    R0,-(R1)
        CLRB    -(R1)
        MOV     R1,R0           ;ROPOINTS TO "REAPWD" UPON RETURN
        POP     R1
        RTS     R5              ;RETURN


;SEQ409

;-----SUBROUTINE TO CLEAR THE 'ALLOCATED' BIT FROM EACH MEMBER OF TYPNUM
CLRALC: MOV     #37,R0          ;CLEAR 'ALLOCATED' BIT IN TYNUM
        
1$:     BICB    #200,TYPNUM(R0)
        DEC     R0
        BGE     1$
        RTS     R5

;-----THIS SUROUTINE MOVBES A PDP10 WORD FROM (R0) TO (R1)
MOVE36: MOVB    (R0)+,(R1)+
        MOVB    (R0)+,(R1)+
        MOVB    (R0)+,(R1)+
        MOVB    (R0)+,(R1)+
        MOVB    (R0)+,(R1)+
        RTS     R5
;-----SUBROUTINE FOR MISCELLANEOUS ERRORS THAT WE DON'T UNDERSTAND.
MCLEM:  ERRMSG  <ERR PC=>
        POP     R0
        ERRCOM  PNTOCT
        ERROR   <MEMORY CONFIGURATOR OR MACHINE ERROR>


;SEQ410

.SBTTL  COMMON DATA FOR MEMORY CONFIGURATION ROUTINES
;-----CONTROL WORD AND BIT DEFINITIONS
MCCB:   .WORD   0
PTS=2   ;PHYUS CONF TAB SET=SET
PTA=4   ;PHYS CONF TAB ALTERED=SET
LTS=10  ;LOG CONF TAB SET=SET
LTA=20  ;LOG CONF TAB ALTERED=SET
CS=2000;SET MEANS CONF. HAS BEEN DONE
;********************************************************************
;------NOTE: THE FOLLOWIN VARIABLES ARE REFERENCE BY DISPLACEMENTS
;       IN THE DGKBB ISOLATION ROUTINE AND LSHOULD NOT BE MOVED WITH
;       RESPECT TO EACH OTHER WITHOUT CHANGING THE DISPACEMENT DEFS
;       IN THE ISOLATION ROUTINE.S
;-----DMA20 (EXTERNAL MEM) INFORMATION
DMA20I:         .WORD   0               ;DMA 20 MAX INTERLEAVE GOES HERE
                                ;DMA20I+1 .NE. 0 MEANS BUS MODE FORCED BY OPR
DMA2TS: .WORD   0               ;#ENTRIES IN TABLE BELOW (16 MAX)       
DMA20T: .BLKW   40              ;DMA20 ADDR RESPONSES GO HERE
                                ;FORMAT:  ADDR/16K      SIZE/16K
DNXMT:  .BLKW           40              ;DMA20 NXM RESPONSE/BUS MODE TABLE
                                ;2WORDS/ENTRY: NXM-RESP BUS-MODE
                        ;NXM-RESP WORD: BITS 15-12 ARE 0
                                ;BIT 11 IS 4 BUS-WD0 NXM
                                ;BIT 10 IS 4BUS-WD1 NXM  ..ETC..
                                ;BIT 00 IS 1BUS-WD3 NXM
;NOTE: ENTIRES INDMA20T AND DNXMT ARE 1 FOR 1.
DMA20:  .WORD   0               ;# OF DMA20'S
UNDEF=DMA20+1                   ;# OF UNDEFINED TYPES
;----MA20/MB20 INFORMATION.
MA20:   .WORD   0               ;# O MA20S
MB20=MA20+1                     ;# OF MB20S
        
MX20:   .BYTE                           ;NUMBER OF MX20S
MF20:   .BYTE                   ;NMBER OF MF20S
MDCP:   .WORD   MA20,DMA20,MB20,MX20,MF20,UNDEF ;POINTERS TO ACCESS COUNTS
STRFLG: .WORD   0               ;OR OF ALL MODULES
TYPNUM: .BLKB   40              ;TYPE # FOR EACH ADDR
MODNUM: .BLKB   40              ;# OF MODULES FOR EACH
SBUSEN: .BLKB   40              ;SBUS REQ EN FOR EACH
;****************************************************************************



;SEQ411

;-----DATA RELATING TO LOGICAL TABLE SETUP
CONT0:  .BLKW   1               ;2 BYTES FOR CONTROLLER NUMBERS FOUND BY SMCI
CONT1=CONT0+1   
BITCNT: .BYTE   0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4 ;#ONE BITS TABLE
CATIF:  .BYTE   112,132,152,172                 ;CLR 0-5, INTRLV,SBUS RQ EN 0.2
CRDEND: .WORD   0               ;"CRUDE"END OF ADDRESS HOLE
HEND:   .WORD   0               ;REFINED END OF ADDRESS HOLE
HSTART: .WORD   0                       ;START OF ADDRESS HOLE
;NOTE:  THE VARIABLE INTMOD HAS GREAT EFFECT ON THE CONFIGURATION
;       L0 ORD BYTE--0 MEANS OPTIMIZE INTERLEAVE WHERE POSSIBLE,1,2.
;                       OR MEANS ATTEMPT TO FORCE A PARTICULAR INTERLEAVE
;               MODE.
;       HI ORD BYTE--0 MEANS UTILIZE MA/MB20 CONROLLERS IN 0-3 ORDER.
;                       NOTT 0 MEANS USE 3-0 ORDER
INTMOD: .WORD   0               ;CONFIGURATION CONTROL WORD
MODELB: .WORD   0               ;=0 FOR MODEL A, NOT 0 FOR MODEL B
;-----THE LOGICAL CONFIURATION TABLE FOR MA20 AND MB 20 CONTROLLERS.
;TABLE ENTRY FORMAT:    01IIQQQQ00SSSSLLLLUUUU10CCCCCC
;BYTE DISPLACEMENTS;    333333332222222211111111000000
;MEANINGS :0,1 OBVIOUS; 1 IS SBUS R      Q EN 0123; S IS "SECTION" NO.
;       L IS LOWER BOUND                ;U IS UPPTER BOUND; C IS ALTERNATE CONTROLLER #
CATTAB: .BLKW   100             ;THE LOGICAL CONFIGURATION TABLE

;-----PHYSICAL MEMORY GAP TABLE.  TWO WORD ENTRIES IN 16K FORMAT:
;       GAP START ADDRESS, GAP SIZE.
GAPCNT: .WORD   0               ;COUNT OF ENTIRES IN THE GAP TABLE
        .WORD   -1,0            ;DUMMY GAP TABLE ENTRY 
GAPTAB: .BLKW   32.             ;UP TO 16 GAPS ALLOWD.

;-----EDITING DATA
REAPWD: .WORD   0,0,0           
MEMTYP: .WORD   TYPE0           ;MEMORY TYPE POINTERS
        .WORD   TYPE1           ;
        .WORD   TYPE2           ;
        .WORD   TYPE3           ;
        .WORD   TYPE4           ;
        .WORD   TYPE5           ;
        .WORD   TYPE6           ;
TYPE0:  .ASCIZ  /   CUST. /     ;MEMORY TYPE TEXT
TYPE1:  .ASCIZ  /    MA20 /     ;
TYPE2:  .ASCIZ  /   DMA20 /     ;
TYPE3:  .ASCIZ  /    MB20 /     ;
TYPE4:  .ASCIZ  /    MX20 /     ;
TYPE5:  .ASCIZ  /    MF20 /     ;
TYPE6:  .ASCIZ  /  UNDEF. /     ;


;SEQ412

.SBTTL  PHYSICAL CONFIGURATION DETERMNING ROUTINE
;----THIS ROUTINE SETS THE PHYSICAL CONF. TABLE BASED UPON ACTUAL
;       HRDWARE MEMORY CONFIGURATION.
SETPT:  BIT     #PTS,MCCB       ;PHYS TAB ALREADY SET?
        BNE     XXXX           ;YES,EXIT
SETPTN: SBUPRG
        BCC     1$              ;PRG LOAD OK
        ERROR   <AC LOAD ERR, CAN'T DETERMINE PHYS. MEM CONFIG.>
1$:     JSR     R5,CONDET               ;DETERMINE MEM CONFIG.
        JSR     R5,DMADET       ;DETERMINE DMA20 LAYOUT
        BIT     #PTA+LTA,MCCB   ;ANY ALTERATIONS PREV.?
        BEQ     2$              ;NO
        PMSG    <DELETED PREV CHANGES\>  ;ELSE WARN
2$:     MOV     #PTS,MCCB       ;MARK PHYS TAB SET
XXXX:   RTS     R5              ;RETURN


;SEQ413

;-----DETERMINES CONTROLLER TYPES AND PRESENCE.
CONDET: CLR     MCCB            ;SE
        CLR     MODELB          ;SET MODEL A AS DEFAULT
        MRESET,DFRDT,107        ;REA "MODEL B BIT"
        TBIT    21              ;IS IT SET?
        BEQ     1$              ;NO...MACHINE IS MODEL A
        INC     MODELB          ;ELSE SET MODEL B FLAG
1$:     SM
        RUN     AC1
        JSR     R5,CLRALC
        JSR     R5,DI
        JSR     R5,DE
        CLR     DMA20
        CLR     STRFLG          ;CLEAR STORAGE FLAG
        CLR     R2              ;CONTROLLEWR #
2$:     READ17                  ;GET PROGRAM RESULT
        MOV     (R0)+,R3        ;GET BITS 20-35
        BIC     #177760,R3      ;ISOLATE 32-35 (SBUS RQ EN)
        MOVB    R3,SBUSEN(R2)   ;SAVE REQUEST ENABLE IN TAB
        MOV     (R0)+,R4        ;GET # OF MOD BITS
        MOVB    (R0),R3
        MOV     #4,R0           ;POSITION IN BYTE
3$:     ROR     R3              ;
        ROR     R4              ;
        DEC     R0              ;
        BGT     3$              ;
        SWAB    R4              ;
        BISB    R4,STRFLG       ;ACCUMULATE STORAGE BITS
        MOVB    R4,MODNUM(R2)   ;SAVE # OF MODULES
        SWAB    R4              ;
        SR      R4,4            ;POSITION CONTROLLER TYPE
        BIC     #177760,R4      ;
        MOVB    R4,TYPNUM(R2)   ;SAVE TYPE
        BEQ     5$              ;CONTROLLER NOT PRESENT
        CMP     R4,#6           ;DEFINED TYPE?
        BLT     4$              ;YES
        MOV     #6,R4           ;NO,SET UNDEFINED
4$:     ADD     R4,R4           ;DOUBLE FOR WORD INDEX
        INCB    @MDCP-2(R4)     ;COUNT TYPE
5$:     INC     R2              ;NEXT CONTROLLER
        CMP     R2,#37          ;LAST ADDRESS
        BGT     6$              ;YES, DONE
        RUN     4               ;RESTART PROGRAM
        BR      2$              ;LOOP AGAIN
6$:     RTS     R5              ;RETURN



;SEQ414


.REM    %
        SUBROUTINE DMADET DETERMINES THE BUS MODE OF EXTERNAL MEMORY 
AND WHAT ADDRESSES IT IS RESPONDING TO.
        %
;-----FIRST SEE IF THIS CAN AND SHOULD BE DONE
DMADET: MOV     #77,R0          ;CLEAR DMA20 RESPONSE TABLE
1$:     CLRB    DMA20T(R0)      
        DEC     R0
        BGE     1$              
        CLR     DMA2TS          ;CLEAR TABLE SIZE COUNT
        TSTB    DMA20           ;ANY DMA20 PRESENT?
        BGT     DDCON           ;IF YES GO CONTINUE SUBROUTINE
        RTS     R5              ;ELSE NO MEM...RETURN

.REM    %
        DDCON -- DETERMINE DMA20 (EXTERNAL MEMORY) CONFIGURATION.
THERE ARE 3 BASIC PARTS TO THIS TASK:
1)      DETERMINE MEHTOD OF GENERATING 22-BIT (EXTENDED) ADDRESSES.  FOR
MODEL B THIS IS NO PROBLEM; JUST SET FORCE EXTEND.  FOR MODEL A USE
EITHER SXCT INSTRUCTIONS OR 22-BIT EXAMINES.  IF THE MICROCODE SUPPORTS
NEITHER OF THESE IT IS NECESSARY TO STOP AT 256K.  THIS MAY CAUSE ERRORS.
2)      READ 4 CONTIGUOUS WORDS EVERY 16K IN EACH BUS MODE (1,2,4).
AND RECORD THE NXMS WHICH OCCUR WHILE DOIBNG THIS.
3)      DETERMINE THE BEST BUS MODE FOR EACH BLOCK OF EXTERNAL MEMORY
WHICH RESPONDS DIFFERENTLY AND ALSO THE BEST BUS MODE FOR ALL OF X MEM.
        %
;-----INITIALIZAE A FEW THINGS.
DDCON:  REGSAV                  ;SAVE REGS
        MEMRST                  ;RESET MEMORY
        CLR     R4              ;SET EXT ADR METHOD TO DIRECT
        MOV     #100,XMAL       ;ASSUME WE CAN ADR ALL 4 MEGAWORDS
        TST     MODELB          ;IS THIS A MODEL B MACHINE
        BNE     3$              ;YES...SKIP ECT ADR METHOD DETERMINATION


;SEQ415

;-----DETERMINE THE EXTENDED ADDRESSING METHOD TO USE FOR THIS MODEL A
;       MACHINE.  TRY A SXCT.  IF IT WORKS USE SXCTS, OTHERWISE TRY AN
;       EXAMINE IN 22-BIT ADR MODE.  IF THAT WORKS USE EXAMINES, OTHER-
;       WISE LIMIT ADDRESSING TO 18 BITS (256K) & USE DIRECT ADDRESSING.
        LOADAC  174,9$          ;LOAD HELPFUL LITTLE PROGRAM
        RUN     AC2             ;RUN IT TO CLR THINGS
        XQT     12$             ;TRY A SXCT
        JSR     R5,5$           ;SEE IF IT WORKED
        BCS     1$              ;BR IF SXCT DIDN'T WORK
        DEC     R4              ;ELSE SET METHOD TO -1...USE SXCT
        BR      3$
1$:     SM                      ;CLR THE KL10 AS SOMETHING WAS HUNG UP
        RUN     AC2             ;SET THE ERA AGAIN.
        MOV     #11$,R0         ;PT R0 TO A 22-BIT ADR
        EXAM                    ;TRY THE EXAMINE
        JSR     R5,5$           ;SEE IF IT WORKED
        BCS     2$              ;BR IF EXAMINE DIDN'T WORK
        INC     R4              ;ELSE SET METHOD TO +1... USE EXAMINES
        BR      3$
;-----HERE IF NEITHE OF THE METHODS WORKS
2$:     PFORCE,$PMSG,8$,PBELL,PNORML    ;SEN ERR MSG
        MOV     #4,XMAL         ;FORCE LIMIT OF SCAN TO BE 256K


;SEQ416

;-----THE EXTENDED ADDRESSING METHOD HAS BEEN DETERMINED.  NOW LOAD THE
;       SCANNING PROGRAM AND MODIFY IT TO SUIT THE METHOD TO BE USED.
3$:     SM                      ;RESET THE KL10
        LOADAC  7776,14$                ;LOAD THE PROGRAM
        TST     R4              ;TEST THE METHOD FLAG
        BLT     17$             ;BR IF SXCT...DON'T MODIFY PROGRAM
        BEQ     4$              ;BR IF DIRECT...PUT MOBVE IN PLACE
        DPOST,AC3,10$           ;ELSE EXAMINES...PUT HALT IN PLACE
        BR      17$
4$:     DPOST,AC3,16$           ;HERE TO SUBSTITUTE MOVE FOR SXCT
        BR      17$
;-----LITTLE SUBROUTINE TO SEE IF AN EXTENDED ADDRESSING METHOD WORKED.
5$:     BCS     6$              ;BR IF ERR
        XQT     13$             ;READ THE ERA
        BCS     6$              ;ERR IF RDERA DIDN'T WORK
        EXAMT,AC0,REAPWD                ;GET ERA WORD
        BCS     6$              ;BR IF THIS EXAM FAILED 
        BIT     #4,REAPWD+2     ;ERA ADR BIT17 SET?
        BNE     7$              ;BR IF YES...22-BIT ADR SU CESSFULLY GEND
6$:     SEC                     ;ELSE SET C-BIT AS ERR FLAG
7$:     RTS     R5              ;RETURN
8$:     .ASCIZ  %UCODE ERR. CAN'T MAP X MEM > 256K\%


;SEQ417

;-----THIS IS A QUICKY PROGRAM TO AID IN DETERMINING IF SXCT OR EXTENDED
;       ADDRESS EXAMINES WORK WITH THE PATICULAR MICRO-CODE LOADED.
9$:     I10     MOVE,0,,20      ;2--RD LOC 20 TO CLR ERA
        IO10    CONO,APR,,27700 ;3--CLR APR AGAIN TO UNLOCK ERA
10$:    I10     JRST,4,,4               ;4--WAIT FOR THE 11 TO DO ITS STUFF
        I10     MOVE,0,,0,6     ;5--USED BY SXCT
11$:    WD36    0000,0100,0020  ;6--ADR ABOVE 256K
12$:    I10     SXCT,,,5                ;USED TO SEE IF SXCT WORKS
13$:    IO10    RDERA,,,0       ;GET THE ADDRESS FROM THE ERA
;-----THIS AC PROGRAM IS AN AID IN MAPIONG EXTERNAL MEMORY RESPONSE.
;       ITS FUNCTION IS TO TURN ON THE DMA20, AND THEN DO 4 READS AND
;       RECORD THE NXM BIT AFTER EACH READ.  IT SHOULD BE NOTED THAT THE
;       INSTRUCTION IN AC3 MAY BE OVERLAID DEPENDING ON THE METHOD BEING
;       USED TO DO EXTENDED ADDRESS READS.
14$:    IO10    SBDIAG,,,16     ;1--CLR DMA20, SET BUS MODE
        IO10    CONO,APR,,27700 ;2--CLR APR TO SEE IF WE CAN GET NXM
        I10     SXCT,,,13       ;3--DO THE MEMORY ACCESS
        I10     LSH,14,,1               ;4--SHIFT NXM WORD
        IO10    CONSZ,APR,,2000 ;5--SKIP IF NO NXM
        I10     IORI,14,,1      ;6--ELSE MARK NXM IN NXM WORD
        I10     ADDI,15,,1      ;7--GO TO NXT WD OF QUADWORD
        I10     TRNE,15,,3              ;10-SKIP IF QUADWORD DONE


;SEQ418

        I10     JRST,,,2                ;11-ELSE GO DO NXT WD
15$:    I10     JRST,4,,1               ;12-HALT SO 11 CAN CNG SBIDIAG WD OR EXAM
16$:    I10     MOVE,17,,0,15           ;13-INSTR TO ACCESS MEM
                                        ;14-NXM WD GEND HERE
                                        ;15-ADDRESS LOAD HERE BY 11
                                        ;16-SBDIAG WD LOADED HERE BY 11
                                
        .EVEN                           ;17-SCRATCH
        SXCT=106

;SEQ419

;-----PROGRAM LOADED.  NOW ACCESS 4 MEMORY WORDS EVERY 16K IN EACH
;       OF THE BUS MODES TO GET A MAP OF WHERE NXM RESPONSES CHANGE.
17$:    MEMRST                  ;REST THE MEMORIES
        DFWRTT,EXTWD,76         ;SET FORCE EXTENDED ADRG (NNOP ON MOD A)
        MOV     #ADDR+2,R1      ;INI ADR PTR FOR EXAMINES
        CLR     (R1)            ;NOW INI THE ADR
        MOV     #20,-(R1)
        CLR     D16KBN          ;SET 16K BLK # TO 0
        MOV     #DMA20T,R2              ;INI PTR TO DMA20 ADR/SIZ TABLE
        MOV     #7777,R3        ;INI PREV NXM FLAGS TO TRUE NXM
        XQT     15$             ;SET UP FOR KL10 CONTINUES
        JSR     PC,CHKX
;-----TOP OF 16K MEMORY BLOCK LOOP.
18$:    LOADAC  ACC15,ADDR      ;LOAD THE ADR WE WILL ACCESS
        MOV     #70200,CDCODW+2 ;INI SBDIAG WD TO SAY 4-BUS MODE
;-----TOP OF BUS MODE LOOP.
19$:    LOADAC  ACC16,CDCODW   ;LOAD THE SBUS DIAG WD
        CONTIN                  ;CONTINUE THE KL...WAIT FOR HALT
        JSR     PC,CHKP
        TST     R4              ;USING EXAMS AS EXT ADRG METHOD>?
        BLE     21$             ;NO...GO DO NEXT BUS MODE
20$:    MOV     R1,R0           ;PT PARAM REG AT THE ADR
        EXAM                    ;ELSE DO THE EXAMINE
        CONTIN                  ;CONTINUE THE KL10
        JSR     PC,CHKP
        INC     (R1)            ;PT TO THE NEXT OF THE 4 WORDS
        BIT     #3,(R1)         ;HAVE WE EXAMINED ALL  4 WORDS?
        BNE     20$             ;BR IF NO...KEEP GOING
21$:    SUB     #10000,CDCODW+2 ;CALC NXT BUS MODE
        BIT     #30000,CDCODW+2 ;ALL 3 MODES DONE?
        BNE     19$             ;BR IF NO


;SEQ420

;-----ALL THREE BUS MODES HAVE BEEN DONE FOR THIS 16K BLOCK NOW.  GET
;       THE RESULTING NXM MASK AND UPDATE THE TABLES IF IT HAS CHANGED
;       SINCE THE LAST 16K BLOCK.
        EXAMT,AC14,REAPWD       ;GET THE WORD
        JSR     PC,CHKED
        MOV     (R0),R0
        BIC     #170000,R0      ;SHUT OFF THE JUNK
        CMP     R0,R3           ;HAS THE NXM MASK CHANGED?
        BEQ     22$             ;NO...JUST GO ON TO THE NXT 16K BLK
        JSR     R5,24$          ;ELSE CALL ROUTINE WHICH RECORDS CHANGES
22$:    INC     D16KBN          ;UPDATE BLOCK NUMBER
        ADD     #40000,(R1)+    ;INC ADR BY 16K
        ADC     (R1)
XMAL=.+2                        ;THE ADR LIMIT WD
        BIT     #000000,(R1)    ;E-O ALLOWED ADR SPACE (256K OR 4 MEG?)
        BNE     23$             ;YES...FINISH UP THIS PHASE
        BIC     #17,-(R1)       ;ELSE FIX ADR CAUSE IT CHANGE FOR EXAM
        BR      18$             ; & GO DO NXT 16K BLOCK


;SEQ421

;-----ALL 16K BLOCKS HAVE BEEN DONE. FINIS THE TABLES AND DO A
;       CONSISTENCY CHECK.
23$:    MOV     #7777,R0                ;FOOL SUBRTN INTO THINKING IT GOT NXMS
        JSR     R5,24$          ;FINISH UP TABLES
        ASR     DMA2TS          ;DIV TABLE SIZE BY 2
        BCC     27$             ;BR IF WAS EVEN...ALL OK
        JSR     PC,MCLEM                ;SOMETHING WRONG IF HERE
;-----SUBROUTINE TO UPDATE THE TABLES: DAM20T AND DNXMT.
24$:    BIT     #1,DMA2TS       ;ON EVEN OR ODD WD OF TABLE?
        BEQ     25$             ;EVEN...START NEW ENTRY
        INC     DMA2TS          ;ELSE FINISH OLD ENTRY
        MOV     D16KBN,2(R2)    ;CALC BLOCK LENGTH
        SUB     (R2)+,(R2)+
25$:    CMP     R0,#7777        ;WAS NEW RESP A TRUE NXM?
        BEQ     26$             ;YES...DON'T MAKE NEW ENTRY IN TABLE
        INC     DMA2TS          ;ELSE CREATE NEW ENTRY
D16KBN=.+2                      ;THE 16K BLOCK # IS STORED HERE
        MOV     #000000,(R2)    ;SAVE START ADR OF NEW RESPONSE BLK
        MOV     R0,DNXMT-DMA20T(R2)     ;SAV NXM RESPONSETIN NXM TABLE
26$:    MOV     R0,R3           ;MAKE THE NEW RESP THE OLD RESP
        RTS     R5              ;RETURN TO CALLER
;-----ALL NXM INFO IS IN.  FIGURE OUT THE BUS MODE FOR EACH BLOCK AND
;       HEN DETERMINE THE OVERALL BUS MODE.
27$:    MOV     #DNXMT,R2       ;INI NXM RESPONSE TABLE PTR
        CLR     R3              ;RE ACCUMULATES "OR" OF ALLNXMS
        MOV     DMA2TS,R4       ;LOOP COUNT
        BEQ     29$             ;IF NO X MEM FND ASK FOR BUS MODE
28$:    MOV(R2)+,R0             ;GET NXM RESP OF THIS BLK
        BIS     R0,R3           ;OR IT INTO R3
        JSR     R5,31$          ;CALC BUS MODE OF MASK IN R0
        MOV     R0,(R2)+        ;SAVE CALCD BUS MODE IN TABLE
        DEC     R4              ;ANY MORE TO DO?
        BGT     28$             ;BR IF YES
        MOV     R3,R0           ;OR OF ALL NXMS TO R0
        JSR     R5,31$          ;CALC OVERALL BUS MODE


;SEQ422

;-----CHECK FORCE BUS MODE FLAG.  DO NOTHING IF SET, ELSE SAVE HE BUS
;       MODE IF IT IS KNOWN.  IF NOT, ASK FOR IT.
        TSTB    DMA20I+1        ;DMA20 BUS MODE FORCED?
        BNE     30$             ;YES...DO NOTHING
        MOV     R0,DMA20I       ;ELSE SAVE THE BUS MODE
        BGT     30$             ;BR IF IT WAS GOOD
29$:    PMSG    <DMA20 BUS MODE SHOULD BE [0(OFF),1,2,4]? _>
        JSR     R5,RXBM         ;READ THE BUS MODE
        BCS     29$             ;LOOP IF WE DIDN'T GET ITM
;-----BUS MODE IS NOW KNOWN.  SET IT AND EXIT
30$:    MOVB    DMA20I,R0       ;GET BUS MODE
        MOVB    CATIF(R0),CDCODW+3      ;GET PROPER BITS FOR THAT MODE
        LOADAC  ACC16,CDCODW    ;ABDIAG WD TO AC16
        MEMRST                  ;RESET EVERYTHING
        XQT     14$             ;DO THE SBUS DIAG
        JSR     PC,CHKX
        REGRST                  ;DONE...RESTORE REGS & EXIT
        RTS     R5
;-----SUBROUTINE TO LOOK AT THE 12BIT NXM RESPONSE IN R0 AND
;       DETERMINE THE HIGHEST BUS MODE THAT WORKS.  THIS NUMBER IS
;       RETURNED IN R0.
31$:    PUSH    R0              ;COPY NXM RESPONSE BITS
        MOV     #3,R0           ;INI BUS MODE NUMBER
32$:    BIT     #7400,(SP)      ;ANY NXMS FOR THIS BUS MODE?
        BEQ     33$             ;NO...USE THIS BUS MODE
        SL      (SP),4          ;SHIFT RESPONSE WD
        DEC     R0              ;NXT LOWER BUS MODE
        BGT     32$             ;BR IF SOME LEFT
33$:    TST     (SP)+           ;DEL WD FROM STK
        RTS     R5

;-----DATA SECTIONS FOLLOW
ADDR:   .WORD   0,0,0           ;ADDR WHERE CHANGE OCCURED GOES HERE
CDCODW: WD36    1160,4000,0000  ;DIAG FUNC 0, BITS 4-19 SET BY PROGRTAM
EXTWD:  WD36    0000,0000,0400  ;WD FOR DFWR TO FORCE EXTENDED ADRRG

        .EVEN


;SEQ423

;-----SECTION TO GET THE DMA20 BUS MODE FROM THE OPERATOR.
RXBM:   TTILIN                  ;<HERE TO GET NEW LINE>
        BCC     RXBM2           ;BR IF RESPONSE
        CLR     R0              ;ELSEASSUME RESPONSE TO BE 0
        BR      1$              ;& SET 0
RXBM2=. 
        TTIDEC                  ;GET THE NUM <HERE TO USE CUR INP LINE>
        BCS     2$              ;ON BAD DATA, TRY AGAIN
        CMP     R0,#3           ;CHECK RANGE
        BEQ     2$              ;3...ERROR
        BLT     1$              ;MAY BE 1 OR 2...CHECK
        CMP     R0,#4           ;IS IT 4 BUS MODE?
        BNE     2$              ;NO...ERROR
        DEC     R0              ;ELSE CONVERT TO 3 FOR INTERNAL USE
1$:     MOV     R0,DMA20I               ;SAVE BUS MODE
        BLT     2$              ;ERR IF .LT.  0
        CLC                     ;INDICATE ALL OK
        RTS     R5              ;RETURN
2$:     SEC                     ;SET ERR FLAG
        RTS     R5


;S





;SEQ424



.SBTTL          PHYSICAL CONFIGURATION REPORTER
;-----MEMORY CONFIGURATION REPORTER
REPMEM: JSR     R5,SETPT
REPCON: PMSG    <\MEMORY REPORTED:>
REPCN2: PMSG    <\CONTROLLER ADDRESS  TYPE  STORAGE\>
        TST     MA20                    ;(&MB20SIMULTANEOUSLY)
        BEQ     1$              ;IF NO MA OR MB TWENTIES, SKIP NXT MSG
        PMSG    <			  7 6 5 4 3 2 1 0\>
1$:     CLR     R2
2$:     MOVB    TYPNUM(R2),R1  ;GET TYPE
        BIC     #177600,R1      ;DE-JUNK
        BNE     3$              ;NOT ZERO
        TSTB    MODNUM(R2)      ;STORAGE REPORTED?
        BEQ     9$              ;NO, DON'T REPORT ADR
3$:     CMP     R1,#6           ;DEVICE # OUT OF RANGE?
        BLE     4$              ;NO..OK...CONTINUE
        MOV     #6,R1           ;ELSE SET DEFAULT
4$:     PCRLF
        MOV     #TAB,R0         ;
        PNTCHR                  ;TYP A TAB
        MOV     R2,R0           ;
        PNTOCS                  ;TYPE CONTROLLER ADDR
        MOV     #TAB,R0         ;
        PNTCHR                  ;TYPE A TAB
        ASL     R1              ;MULT TYPE # BY 2
        MOV     MEMTYP(R1),R0   ;
        PNTAL                   ;TYPE MEMORY TYPE       
        CMP     R1,#2*2         ;DMA20?
        BNE     6$              ;NO
        MOV     DMA2TS,R1               ;ELSE CALC TOTAL DMA20 MEMORY
        BEQ     9$              ;BR IF TABLE EMPTY...SKIP SIZ CALC
        MOV     #DMA20T,R3
        PSPACE
        CLR     R0
5$:     TST     (R3)+
        ADD     (R3)+,R0
        DEC     R1
        BGT     5$
        JSR     PC,COMCO2
        TST     (SP)+           ;DEL CO-RTN LINK
        BR      9$              ;CONTINUE WITH SUBRTN
6$:     CMP     R1,#4*2         ;MX20?
        BEQ     9$              ;YES.. DONT REPORT STORAGE
        CMP     R1,#5*2         ;MF20?
        BEQ     9$              ;YES...DONT REPORT STORAGE
        MOVB    MODNUM(R2),R3   ;GET # OF MODULES
        MOV     #8.,R4  ;COUNTER
7$:     PSPACE                  ;TYPE A SPACE


;SEQ425

        CLR     R0              ;
        ROLB    R3              ;GET A BIT
        BCC     8$              ;0
        MOV     #1,R0           ;1
8$:     PNTOCS                  ;PRINT BINARY BIT
        DEC     R4              ;DONE?
        BGT     7$              ;NO,NEXT BIT
9$:     INC     R2              ;NEXT CONTROLLER
        CMP     R2,#37          ;LAST ONE?
        BLE     2$              ;NO,KEEP GOING
        PCRLF                   ;CR/LF
        PCRLF                   ;CR/LF
        RTS     R5              ;RETURN

;-----SECTION TO PRINT OUT DMA20 (EXTERNAL) MEMORY RESPONSE
REPDMA: TSTB    DMA20           ;ANY DMA20 PRESENT?
        BLE     3$              ;BR IF NO
        PMSG    <EXTERNAL MEMORY RESPONSE\>
        PMSG    <ADDRESS   SIZE   INT\>
        MOV     #DMA20T,R2      ;MOVE TABLE POINTER
        MOV     DMA2TS,R3               ;TABLE ENTRY COUNTER
        BEQ     3$              ;BR IF TABLE EMPTY...EXIT
1$:     DEC     R3              ;COUNT DOWN
        BLT     2$              ;BR IF NO MORE
        MOV     (R2)+,R0        ;ADDRESS
        JSR     R5,EPA
        MOV     (R2)+,R0        ;SIZE
        JSR     PC,COMCO2       ;PRINT
        TST     (SP)+           ;DEL CO-RTN LINK
        PNTCI,"                 ;NOW PRINT ITNERLEAVE FOR THIS BLOCK
        MOV     DNXMT-DMA20T-2(R2),R0   ;GET INTERLEAVE MODE
        JSR     R5,PBMCR                ;PRINT IT
        BR      1$              ;LOOP
2$:     PCRLF
3$:     RTS     R5              ;REPORT DONE
;-----SUBROUTINE TO READ FORCED BUS MODE FROM THE CONSOLE.
FDBMA:  PMSG    <FORCE DMA20 BUS MODE [0(N0),1,2,4] _>
        JSR     R5,RXBM         ;GO READ FORCED BUS MODE(GET NEW LINE)
        BR      FDBMB           ;CONTINUE
FDMABM: JSR     R5,RXBM2                ;GO READ FORCED BUS MODE (USE OLD LINE)
FDBMB:  BCS     FDBMA           ;BR IF ERR OR NOTHING TO READ...PROMPT
        BEQ     1$              ;BR IF 0 GIVEN...DON'T FORCE BUS MODE
        INCB    DMA20I+1        ;ELSE SET FLAG TO FORCE MODE WHEN CONF
1$:     RTS     R5


;SEQ426

.SBTTL          PHYSICAL MEM CONFIGURATION ALTERING SUBROUTINES

;-----INDIVIDUAL D GROUP CMD SUBROUTINES
;-----DC COMMAND: DELETE SPECIFIED CONTROLLER
DC2:    MOVB    TYPNUM(R0),R1   ;GET CONTROLLER TYPE
        CLRB    TYPNUM(R0)             ;DEL SPEC CONTR
        CLRB    MODNUM(R0)              ;DEL MODULE BITS AS WELL
        TST     R1              ;KNOWN CONTR TYPE?
        BLE     2$              ;NO
        CMP     #3,R1
        BLT     2$              ;ALSO NO
        CMP     R1,#2           ;DMA20?
        BNE     1$              ;NO
        JMP     DE              ;YES...GO DELETE EXTERNAL MEMORY
1$:     ADD     R1,R1           ;MAKE INTO WORD INDEX
        DECB    @MDCP-2(R1)     ;DECREMENT PROPER CONTR COUNT
        BLT     3$              ;COUNT NEG--FATAL LOGIC ERR
2$:     RTS     R5                      ;RET
3$:     JSR     PC,MCLEM

;-----DI, DA, AND DB SUBROUTINES
DI:     JSR     R5,DB           ;DEL MA20'S
DA:     CLRB    MA20            ;MA20 COUNT TO 0
        MOV     #1,R0
        JSR     R5,SFAD         ;DEL MA20'S FROM PHYS TAB
        RTS     R5
DB:     CLRB    MB20            ;MB20 COUNT TO 0
        MOV     #3,R0
        JSR     R5,SFAD         ;DEL MB20'S FROM PHYS DEV TAB
        RTS     R5

;-----DE (DELETE X MEM) SUBROUTINE.

DE:     CLRB    DMA20                   ;ZAP ALLIMPORTANT IND OF DMA20 PRESENSE
        CLR     DMA2TS
        CLR     DMA20T
        MOV     #2,R0
        JSR     R5,SFAD         ;SDWL DMA20 FROM TABLE
        RTS     R5

;-----SUBRTN SFAD DELETES ALL CONTROLLERS OF A CERTAIN TYPE (#IN TO)
SFAD:   MOV     #37,R1
1$:     CMPB    R0,TYPNUM(R1)   ;RIGHT KIND?
        BNE     2$              ;NO
        CLRB    TYPNUM(R1)
        CLRB    MODNUM(R1)
2$:     DEC     R1
        BGE     1$              ;LOOP TIL DONE
        RTS     R5              ;RET


 


;SEQ427

.SBTTL          LOGICAL TASBLE SETUP CONTROL ROUTINE
;-----THIS SUBROUTINE SETS UP THE LOGICAL TABLES USED UPON THE CURRENT
;       CONTENTS OF THE PHYS CONF TABLES.  THE PHYS TABS ARE ST UP FIRST
;       IF REQURED.
SETLT:  BIT     #LTS,MCCB               ;LOG TABS ALREADY SET?
        BNE     SETLT2          ;YES--FORGET IT
SETLT1: JSR     R5,SETPT
        JSR     R5,MDSLT                ;GO SET UP THE LOGICAL TABLE
        BIS     #LTS,MCCB       ;MARK TABLE SET
SETLT2: RTS     R5              ;RETURN
;-----MDSLT IS THE SUBROUTINE FOR DETERMINING WHAT THE MEMORY CONFIG-
;       URATION IS TO BE.  INPUTS TO THIS ROUTINE AE THE PHYSICAL
;       CONFIGURATION TABLES AND ASSOCIATED CONTROL WORDS.  THE OUTPUTS
;       ARE THE LOGICAL CONFIGURATION TABLES AND THE "GAP" TALBE.  A
;       WORD    ON NOTATION IS NEEDED HERE: A HOLE IS SOMETHING MDSLT IS
;       TRYING TO FILL WHEREAS A GAP IS SOMETHING MDSLT HAS GIVEN UP
;       TRYING TO FILL.  BASICALLY MDSLT WORKS AS FOLLOWS:
;       HOLES ARE BOUND BY EXTERNAL MEMORY AND THE ABSOLUTE LIMITS OF
;       THE MEMORY SPACE.  MDSLT ATTEMPTS TO FILL THESE HOLES WITH
;       INTERNAL MEMORY.  IF A HOLE OR A PORTION THEREOF CANNOT BE
;       FILLED THAT SPACE IS ASSIGNED AS A GAP.  IN THIS MANNER MDSLT
;       WILL ACCOUNT FOR ALL 4 MEGAWORDS OF PHYSICAL MEMORY.  NOTHING
;       SHOULD CAUSE MDSLT TO FAIL... HE WILL LOGICALLY CONFIGURE WHAT-
;       EVER HE FINDS IN THE PHYSICAL TABLES.  ALL INTERNAL AND EXTERNAL
;       MEMORY WILL BE CONFIGURED, WITHOUT GAPS IF POSSIBLE, AND WITH
;       "OPTIMAL" INTERLEAVING OF INTERNAL MEMORY IF ALLOWED

;-----ENTRY SECTION.  DO APPROPRIATE INITS.
MDSLT:  REGSAV                  ;SAVE ALL REGS
        JSR     R5,CLRALC       ;CLEAR ALLOCATED CONTR BITS
        JSR     PC,NMAMBC       ;CALC TOTAL # USABLE MA/MB20 CONTRS
        CLR     GAPCNT          ;RESET GHAP COUNTER
        MOV     #GAPTAB-4,R3            ;INIT GAP TABLE POINTER
        MOV     DMA2TS,R1       ;INIT EXTERNAL MEM BLOCK COUNT
        MOV     #DMA20T,R2      ;INIT PTR FOR SAME
        CLR     R4              ;INIT HOLE (TO FILL) START TO 0
;-----FIRST: ARE WE DONE YET (HAVE WE REACHED 4 MEG?)
SLTGO:  CMP     R4,#400         ;HOLE START UP TO 4 MEG YET?
        BLT     1$              ;NO...MORE TO GO
        BEQ     MDSLTE          ;YES...ALL DONE
        JSR     PC,MCLEM                ;WE HAVE CONF > 4MEG !?!!!! ERROR
;-----A HOLE START ADDRESS IS IN R4.  SHOULD WE PUT INTERNAL OR EXTERNAL
;       MEMORY HERE?
1$:     MOV     #400,CRDEND             ;CRUDE HOLE END=4MEG IN CASE NO X MEM
        TST     R1              ;ANY X MEM LEFT?
        BEQ     SIMLT           ;NO...GO ATTEMPT TO FILL IN TO 4 MEG
;-----WE HAVE XC MEM.  DO WE USER IT NOW OR DO WE HAVE TO FILL UP TO IT?
        CMP     (R2),R4         ;CMP X MEM BLK STRT TO HOLE START
        BGT     3$              ;BR IF ROOM BEFORE X MEM NEEDING FILL
        BEQ     2$              ;X MEM & HOLE CO-INCIDE...USE XMEM
        JSR     PC,MCLEM                ;HAVE CONF OVER XMEM...SERIOUS LOGIC ERR


;SEQ428

2$:MOV  (R2)+,R4                ;RECOMPUTE HOLE START (BEYOND X MEM)
        ADD     (R2)+,R4        
        DEC     R1              ;DECR X MEM BLOCK COUNT
        BR      SLTGO           ;GO START PROCEDURE ALL OVER AGAIN
3$:     MOV     (R2),CRDEND     ;X MEM BLK START MARKS ENDS OF HOLE
;-----SECTION TO WORK ON INTERNAL MEMORY LOGIC TABLES.
SIMLT:  MOV     R4,HSTART               ;MOVE HOLE START TO HSTART AS EXPECTED
        REGSAV                  ;SAVE REGS CAUSE SUBROUTINES DON'T
;-----SECTION FOR MA20 & MB20 CONTROLLERS.
        JSR     PC,MABFIL               ;ATTEMPT TO FILL HOLE WITH MA20 & MB20
        BCC     SIMLTS          ;BR IF HOLE COMPLETELY FILLED
;-----SECTION FOR OTHER INTERNAL MEMORY CONTROLLER TYPES,.
;       -----NONE AT THE MOMENT -----
;-----CONTROL HAS FALLEN THROUGH TO HERE MEANING THAT NONE OF THE
;       INTERNAL MEMORY CONTROLLER TYPES COULD HANDLE THE HOLE COM-
;       PLETELY.  ASSIGN WHAT'S LEFTOVER TO GAP SPACE.
        REGRST                  ;RESTORE OUT REGS
        MOV     HSTART,R4               ;GET BACK UPDATED HOLE START ADDRESS
        MOV     (R3)+,R0        ;GET CURRENT GAP START ADR
        ADD     (R3)+,R0        ;ADD LEN TO CALC WHERE IT ENDS
        CMP     R0,R4           ;WAS ANY MEM ALLOCATED SINCE LAST GAP?
        BEQ     1$              ;BR IF NO...JUST ADD MORE TO OUR GAP
        BLT     2$              ;BR IF YES...CREATE NEW GAP AFTER ALLOC
        JSR     PC,MCLEM                ;YES...MEM ALLOCTE DBACKWARDS...ERROR
1$:     INC     -(R3)           ;INCREASE GAP SIZE BY 16K
        BR      3$              ;GO DO RETRY
2$:     MOV     R4,(R3)+                ;HSTART IS NEW GAP START
        MOV     #1,(R3)         ;GAP IS AT LEAST 16K
        INC     GAPCNT          ;BUMP GAP COUNT
3$:     TST     -(R3)           ;BAKUP GAP TAB PTR
        INC     R4              ;MOV HOLE START 16K PAST SPACE JUST
                                ;ASSIGNED TO GAP TABLE
;-----ARETHERE ANY MEM RESOURCES LEFT TO CONFIGURE?
        TST     R1              ;ANY X MEM BLOCKS LEFT?
        BGT     SLTGO           ;YES GO TRY & DO THEM
        TST     NMAMB           ;ANY MA/MB20 WITH STORAGE?
        BGT     SLTGO           ;YES...GO DO 'EM
;-----IF THERE'S NOTHING LEFT TO WORK ON, THEN WE ARE, PERFORCE, DONE.
;       CALCUALTE FINAL GAP SIZE AND EXIT.
        TST     (R3)+           ;PT TO FINAL GAP SIZE WD
        ADD     #400,(R3)        ;ADD <4 MEG-HOLE START> TO IT
        SUB     R4,(R3)         ;ALL DONE
;-----EXIT SECTION
 MDSLTE:        REGRST                  ;RESTORE ALL REGS
        RTS     R5              ;RETURN TO CALLER
;-----COME HERE WHEN INT MEM ALLOCATION IS COMPLETELY SUCCESSFUL.
SIMLTS: REGRST                  ;RESTORE REGS
        MOV     HSTART,R4               ;PUT UPDATED HOLE START ADR BAK IN R4
        BR      SLTGO           ;KEEP GOING


;SEQ429

.SBTTL          ;MA20/MB20 LOGICAL TABLE SETUP ROUTINES

;-----SUBROUTINE NMAMBC CALCULATES THE TOTAL NUMBER OF MA20 AND MB20 MEM
;       CONTROLLERS WHICH HAVE STORAGE MODULES.  THE EXISTANCE OF THIS
;       COUNT ALLOWS THE CONFIGURATOR TC TERMINATE MUCH MORE QUICKLY
;       WHEN ITS RESOURCES ARE EXHAUSTED.
NMAMBC: CLR     NMAMB   ;RESET THE VARIABLE
        MOV     #3,R0           ;TO SRCH THRU CONTR 3 TO 0
1$:     CMPB    TYPNUM(R0),#1   ;MA20?
        BEQ     2$              ;YES
        CMPB    TYPNUM(R0),#3   ;MB20?
        BNE     3$              ;NO...DON'T COUNT THIS CONTROLLER
2$:     BITB    #17,MODNUM(R0)  ;DOES IT HAVE STOR MODS?
        BEQ     3$              ;NO...DON'T COUNT IT
        INC     NMAMB           ;ELSE BUMP COUNTER
        
3$:     DEC     R0              ;DECR CONTR #
        BGE     1$              ;LOOP IF MORE TO DO
        RTS     PC              ;ELSE DONE
NMAMB:  .WORD   0               ;TOTAL # OF MA20+MB20 WITH STORAGE MODS
;------SUBROUTINE MABFIL SIMPLY RETURHS TO THE CALLER IF THERE ARE NO
;       MA20 OR MB20 CONTROLLERS LEFT WHICH HAVE STORAGE MODULES.  IF
;       THERE IS AT LEAST ONE, MABFIL TAKES THE CRUDELY DEFINED HOLE
;       (HSTART TO CRDEND) AND BREAKS IT INTO 256K (OR LESS) BLOCK AS
;       REQUIRED (HSTART TO HEND) TO HOLFIL TO BE PROCESSED.
MABFIL: TST     NMAMB           ;ANY MA/MB20 LEFT?
        SEC                     ;IN CASE NOT
        BEQ     3$              ;BR IF NONE...JUST ERROR RETURN
        MOV     HSTART,R0               ;TEMP=MOD(HSTART+256K,256K)
        ADD     #20,R0
        BIC     #17,R0
        MOV     CRDEND,HEND             ;MOVE CRDFND IN CASE ITS OK
        CMP     R0,CRDEND       ;HOLE TO CRDEND WITHIN SECTION?
        BGE     1$              ;YES--HEND ALL SET
        MOV     R0,HEND ;ELSE HEND MUST BE FIXED
1$:     JSR     PC,HOLFIL               ;FILL THE REFINED HOLE
        BCS     3$              ;ERR RET
        CMP     HEND,CRDEND     ;ONE HOLE FILLED OK, ARE WE DONE YET?
        BLT     MABFIL          ;NO
        BEQ     2$              ;YES,EXACTLY
        JSR     PC,MCLEM                ;LOGIC CHECK--HOLE OVERFILLED?????
2$:     CLC                     ;SET OK RETURN
3$:     RTS     PC              ;RETURN


;SEQ430

;-----THE FOLLOWING SECTIONS CONTAIN THE RULES AND ALGORITHMS FOR
;       THE ALLOCATILN OF MA20 AND MB20 INTERNAL MEMORY.
;-----BASIC OPERATION IS AS FOLLOWS:  THE FIRST RULE TO TRY IS
;       DETERMINED BY THE HOLE SIZE.  IF THE RULE CANNOT BE SATISFIED
;       THEN THE NEXT RULE IS TRIED, ETC.  IF NONE OF THE RULES WORK
;       A C-BIT SET RETURN IS DONE BACK TO MABFIL.  IF A SATISFACTORY
        ;RULE IS FOUND BY RULE, CONTROL IS PASSED TO ALICAT WHERE THE
;       APPROPRIATE CATTAB ENTRIES ARE SET UP.  ALICAT THEN JUMPS
;       BACK TO HOLFIL WHO DETERMINES IF THERE IS MORE TO FILL OR NOT.
;       IF SO, HOLFIL REPEATS THE CYCLE, IF NOT, CONTROL IS RETURNED
;       TO MABFIL WITH THE C-BIT CLEAR.

;-----THE RULE CONTROL SUBROUTINE.  FIRST SECTION COMPUTES HOLD SIZE,
;       CHECKS IT, AND SELECTS THE APPROPRIATE POINT IN THE RULE TABLE.
HOLFIL: MOV     HEND,R0 
        SUB     HSTART,R0               ;CALC HOLE SIZE
        BGT     2$              ;MORE TO GO YET
        BEQ     1$              ;DONE RETURN
        JSR     PC,MCLEM                ;SERIOUS LOGIC ERROR IF HERE
1$:     CLC                     ;OK...C-BIT CLEAR RETURN
        RTS     PC
2$:     MOVB    3$-1(R0),R4     ;GET DISP TO FIRST RULE
        BIC     #177400,R4      ;FORMAT IT PROPERLY
        ADD     #M256K,R4       ;ADR OF FIRST RULE TO TRY NOW IN R4
        JMP     RULE            ;GO TO RULE TO EVALUATE RULES
3$:     .IRP    X,<16,32,48,64,64,96,96,128,128,128,128,192,192,192,192,256>
        .BYTE   <M'X'K-M256K>   ;FIRST RULE DISPLACEMENT BYTE
        .ENDM


;SEQ431

;-----THE 'RULE' MACRO HAS THE FOLLOWING ARGUMENTS:
;       RULE    MCT,SM,INTRLV,PAS,PASM
;       MCT     MEM CONTROLLER TYPE: MA20, MB20
;       SM      STORAGE MODULES REQUIRED BY THE RULE: 2**0=SM0,ETC.
        
;       INTRLV  INTERLEAVE APPLICABLE TO THIS RULE
;       PAS     PERMISSABLE ADDR START: BITS 18-21 OF HOLE START ADR
;               MASKED BY PASM, MUST BE EQUAL TO THIS VALUE FOR RULE
;               TO BE ACCEPTED.
;       PASM    SEE PAS
.MACRO  RULE    MCT,SM,INTRLV,PAS,PASM
.IF     IDN     MCT,MB20
          .BYTE 3,SM,INTRLV,PAS,17-PASM
        .IFF
          .BYTE 1,SM,INTRLV,PAS,17-PASM
.ENDC
.ENDM   RULE


;SEQ432

;-----THE MA20 AND MB20 CONTROLLER CONFIGURATION RULE TABLE.  TIS
;       TABLE HAS ALL POSSIBLE LEGAL RULES WITH WHICH ALICAT CAN WORK.
M256K:  RULE    MB20,17,3,00,17 ;PAIR OF MB20   (4 WAY)
        RULE    MB20,17,2,00,17 ;                       (2 WAY)
M192K:  RULE    MB20,07,2,00,17 ;PAIR OF 3/4 MB20
        RULE    MB20,16,2,04,17
M128K:  RULE    MB20,03,3,00,17 ;PAIR OF 1/2 MB20       (4 WAY)
        RULE    MB20,14,3,10,17 
        RULE    MB20,03,2,00,17 ;                       (2 WAY)
        RULE    MB20,06,2,04,17
        RULE    MB20,14,2,10,17
        RULE    MA20,17,3,00,07 ;PAIR OF MZ20           (4 WAY)
        RULE    MA20,17,2,00,07 ;                       (2 WAY)
        RULE    MB20,17,1,00,07 ;SINGLE MB20
M96K:   RULE    MA20,07,2,00,07 ;PAIR OF 3/4 MA20S
        RULE    MA20,16,2,02,07
        RULE    MB20,07,1,00,07 ;SINGLE 3/4 MB20
        RULE    MB20,16,1,02,07
M64K:   RULE    MB20,01,2,00,17 ;PAIR OF 1/4 MB20
        RULE    MB20,02,2,04,17
        RULE    MB20,04,2,10,17
        RULE    MB20,10,2,14,17
        RULE    MA20,03,3,00,07 ;PAIR OF 1/2 MA20       (4 WAY)
        RULE    MA20,14,3,04,07
        RULE    MA20,03,2,00,07 ;                       (2 WAY)
        RULE    MA20,06,2,02,07
        RULE    MA20,14,2,04,07



;SEQ433

        RULE    MB20,03,1,00,07 ;SINGLE 1/2 MB20
        RULE    MB20,06,1,02,07
        RULE    MB20,14,1,04,07
        RULE    MA20,17,1,00,03 ;SINGLE MA20
M48K:   RULE    MA20,07,1,00,03 ;SINGLE 3/4 MA20
        RULE    MA20,16,1,01,03
M32K:   RULE    MA20,01,2,00,07 ;PAIR 1/4 MA20
        RULE    MA20,02,2,02,07
        RULE    MA20,04,2,04,07
        RULE    MA20,10,2,06,07
        RULE    MB20,01,1,00,07 ;SINGLE 1/4 MB20
        RULE    MB20,02,1,02,07
        RULE    MB20,04,1,04,07
        RULE    MB20,10,1,06,07
        RULE    MA20,03,1,00,03 ;SINGLE 1/2 MA20
        RULE    MA20,06,1,01,03
        RULE    MA20,14,1,02,03
M16K:   RULE    MA20,01,1,00,03 ;SINGLE 1/4 MA20
        RULE    MA20,02,1,01,03
        RULE    MA20,04,1,02,03
        RULE    MA20,10,1,03,03
M0K:                            ;NO MORE...WE'RE IN TROUBLE IF HERE
        .EVEN

;SEQ434


;-----'RULE'  ROUTINE.  THE RULE IS REJECTED IF:
;       1-PAS.NE. (HOLESTART(18-21). AND.PASM)  (IE BOUNDARY COND NOT OK)
;       2-PROPER TYPE OF CONTROLLER/SM GROUP CANNOT BE FOUND
;       3-MCT=MB20.AND.HOLESTART(21)=1  (IE MB20 ON 16K BOUNDARY)
;       4-INTMOD.NE.0 .AND. INTMOD.NE.RULEMODE (IE INTERLEAVE MODE IS
;       FORCED AND RULE'S INTERLEAVE MODE DOESN T MATCH FORCED MODE.)
;-----NOTES:
;       1-SMO=00 IMPLIES SINGLE COTROLLER,ODD OR EVEN, WITH ONE WAY
;       INTERLEAVE
;       2-NO HOLE WILL CROSS A 256K ADDRESS BOUNDARY
;-----REJECT FOUR.
RULE:   MOVB    INTMOD,R0               ;GET INT MODE
        BEQ     1$              ;BR IF 0 (NOT FORCED)
        CMPB    R0,2(R4)        ;ELSE DOES RULE MATCH FORCED MODE?
        BNE     REJECT          ;NO...REJECT THIS RULE
;-----REJECT ONE.
1$:     MOV     HSTART,R0
        BICB    4(R4),R0        ;.NOT.(17-PASM).AND.HSTART(18-21)
        BIC     #177760,R0      ;CLEAR SECTION # AND OTHER JUNK
        CMPB    3(R4),R0        ;IS STARTING ADDR OK FOR THIS RULE?
        BNE     REJECT          ;NO
;-----REJECT THREE.
        CMPB    #3,(R4)         ;MB20?
        BNE     2$              ;ON NO, SKIP THIS CHECK
        BIT     #1,HSTART       ;16K ADDR BOUNDARY?
        BNE     REJECT          ;ON YES,,,REJECT RULE
;-----REJECT TWO.
2$:     JSR     PC,SMCT         ;SEARCH MEM CONTR TAB FOR EXACT OR COVERING
                                ;FIT ACCORDING TO THIS RULE AND FRCFIL
        BCS     REJECT          ;BR IF C-BIT SET...CONTR(S) NOT FOUND
        JMP     ALICAT          ;FOUND--GO ALLOCATE
;-----REJECT EXIT. GET NEXT RULE IF ANY LEFT.
REJECT: ADD     #5,R4           ;MOVE ON TO NEXT RULE
        CMP     R4,#M0K         ;ANY RULES LEFT TO TRY?
        BLO     RULE            ;YES...GO TRY
        SEC                     ;ELSE SET C-BIT
        RTS     PC              ;AND DO ERROR RETURN



;SEQ435

;-----SUBROUTINE SMCT IS RESPONSIBLE FOR SEARCHING THE PHYSICAL TABLE
;       TO DETERMINE IF THERE ARE ANY CONTROLLERS CAPABLE OF MEETING
;       THE REQUIREMENTS OF THE CURRENT FULE (POINTED TO BY R4). IF
;       THERE ARE IT DOES A C-BIT CLEAR ETURN WITH THE CONTROLLER # IN
;       CONT0 (+ALTERNATE CONTR # IN CONT1 FOR 2 & 4 WAY RULES).  SMCT
;       WON'T BREAK UP AN INTERLEAVABLE CONTROLLER PAIR FOR A 1 WAY RULE
;       UNLESS 1 WAY IS FORCED BY THE VARIABLE INTMOD.  IF NO CONTROLLER
;       CAN BE FOUND IT DOES A C-BIT SET ERROR RETURN.  SMCT ASSUMES
;       THAT MA20 & MB20 CONTROLLERS ONLY RESPOND TO CONTROLLER NUMERS
;       0 TO 3, AND THAT BOTH CONTRS OF A PAIR ARE THE SAME (MA/MB) TYPE.
SMCT:   MOV     #-1,CONT0       ;LOGICALLY ZAP CONT0 & CONT1
        MOV     #1,R2           ;CONSTANT SAVES TIME 7 SPACE
        CLR     R0              ;ZERO CONTR #
        TSTB    INTMOD+1        ;CONF IN REVERSE ORDER?
        BEQ     1$              ;NO...START WITH CONTR0
        MOV     #3,R0           ;ELSE START WITH CONTR 3
1$:     CMPB    TYPNUM(R0),(R4) ;IS CONTR CORRECT TYPE & FREE?
        BNE     5$              ;NO...TRY NXT CONTR
        MOVB    MODNUM(R0),R3   ;GET STORAGE MODULE PRESENCE BITS
        CMPB    LGLTAB(R3),1(R4)        ;DO LEGAL STOR MODS MATCH RULE?
        BNE     5$              ;NO...TRY NXT CONTR
        MOVB    R0,CONT0        ;CONTR 0 FND...SAVE UITS REAL #
        MOV     R0,R1           ;COP CONTR #
        EXOR    R2,R1,R3                ;CALC # OF OTHER CONTR IN PAIR (TOP R1)
        MOVB    MODNUM(R1),R3   ;GET ITS MODULE PRESENCE BITS
        CMPB    LGLTAB(R3),1(R4)        ;DO LEGAL STOR MODS MATCH RULE HERE TOO?
        BEQ     3$              ;YES HAVE FOUND CONTR PAIR MATCHING RULE
        CMPB    R2,2(R4)        ;NO...RULE HAD BETTER BE 1 WAY...IS IT?
        BNE     5$              ;NO...CANT USE CONTO W/ THIS RULE
2$:     CLC                     ;YES...CAN USE CONTR(S) FOR THIS RULE
        RTS     PC              ;SUCCESSFULL RETURN
3$:     CMPB    R2,2(R4)        ;IS RULE 1 WAY?
        BEQ     4$              ;YES, BUT HAVE CONTR PAIR...TRY TO KEEP
        MOVB    R1,CONT1        ;NOT 1 WAY MUST BE 2/4, SAVE 2ND CONTR
        BR      2$              ;DO SUCCESSFUL EXIT
4$:     CMPB    INTMOD,R2               ;1 WAY INTRLV FORCED?
        BEQ     2$              ;YES...MUST BREAK UP CONTR PAIR
5$:     TSTB    INTMOD+1                ;CONF IN REVERSE ORDER?
        BEQ     6$              ;NO...GO INCR CONTR #
        DEC     R0              ;ELSE DECR CONTR #
        BGE     1$              ;BR IF NOT ALL CONTR DONE
        BR      7$              ;ELSE ERR EXIT. NO CONTR FND TO  FIT RULE
6$:     INC     R0              ;GET NXT CONTR #
        CMP     R0,#3           ;ALL CONTR SCANNED?
        BLE     1$              ;NO...KEEP GOING
7$:     SEC                     ;ELSE CAN T FIND CONTR
        RTS     PC              ;ERROR RETURN



 


;SEQ436

;-----THE FOLLOWING TABLE IS USED TO CONVERT ILLEGAL STORAGE MODULE
;       COMBINATIONS TO LEGAL ONES.  THIS IS PERHAPS A CRUDE METHOD,
;       RESULTING IN A CONFIGURATION WITH PERHAPS MORE ENTROPY THAN
;       A SOPHISTICATED STOR MODE ELIMINATION ALGORITHM.  NOTE THAT
;       LEGAL COMBINATIONS ARE NOT ALTERED.
LGLTAB: .BYTE   0,1,2,3,4,1,6,7,10,1,2,3,14,14,16,17


;SEQ437


;-----SECTION TO ALLOCATE INTERNAL MEMORY.  ALLOCATION IS EFFECTED BY
;       BY SETTING HIGH BIT OF APPROP TYPNUM BYTE AND ALSO BY FILLING
;       IN THE CATTAB ENTRY FOR THE CONTROLLER.
;-----ARGUMENTS: CONT0, CONT1, TYPNUM, ?(R4) RULE, HSTART
;-----OUTPUTS:CATTAB, TYPNUM, HSTART
ALICAT: MOVB    CONT0,R0                ;GET FIRST CONTROLLER NUMBER
        JSR     PC,CATAC                ;DO ALICAT ADDR FUNC
        MOVB    CONT1,(R0)+     ;SET ALTERNATE CONTROLLER NUMBER
        MOVB    #2,(R0)         ;INIT +1 BYTE (SBUS DIAG FUNC 1 ENABLE 14-25)
;-----CALC RULE MEM SIZE FOR UPPER BOUND
        MOVB    1(R4),R2        ;GET SM MODULE COUNT
        MOVB    BITCNT(R2),R1
        CMPB    2(R4),#1        ;IS RULE 1 WAY?
        BEQ     1$              ;YES...DO NOTHING
        ASL     R1              ;ELSE DOUBLE RULE SIZE CAUSE 2 CONTRS
1$:     CMPB    #3,(R4)         ;DOUBLE TOTAL FOR MB20
        BNE     2$              ;BR NOT MB20
        ADD     R1,R1
;-----CALC UPPER AND LOWER BOUND BITS AND CHECK
2$:     MOV     HSTART,R2               ;CALC UPPER BOUND BITS
        ADD     R2,R1
        MOV     R1,HSTART       ;SAVE UPDATED HOLE START ADDR
        DEC     R1              ;CURRENT HOLE END ADDR FOR SBUS DIAG FUNC
        PUSH    R2              ;SAVE OLD HOLE START FOR SBUS DIAG FUNC
        EXOR    R1,R2,R3                ;LOGIC CHECK--SECTION #'S SHOUDLBE SAME
        BIT     #360,R2
        BEQ     3$
        JSR     PC,MCLEM        ;NOT SAME....RATS!


;SEQ438

;-----POSITION EVERYTHING AND PUT INTO CATTAB ENTRY
3$:     SL      R1,14           ;POSITION UPPER BOUNDS
        BIC     #7777,R1        ;DE-JUNK
        POP     R2              ;LOWER BOUNDS FOR CONCATENATION
        ASR     R2
        ROR     R1
        ASR     R2
        ROR     R1              ;2LOWER BOUND BITS CONCATENATED
        SWAB    R1              ;PUT IN RH FOR BISB
        BISB    R1,(R0)+        ;SET REST OF +1 BYTE
        BIC     #177700,R2             ;SET UP +2,+3 BYTES--DEJUNK FIRST
        SWAB    R2
        MOVB    2(R4),R1        ;GET AND TRANSLATE INTERLEAVE   
        BISB    CATIF(R1),R2    ;SEE CATIF FOR CONTENTS
        SWAB    R2
        MOV     R2,(R0)         ;SET +2,+3 BYTES INTO CATTAB ENTRY
        BIS     #2400,R2        ;SET RQ EN 1,3 JUST IN CASE
;-----DETERMINE IF SINGLE OR DOUBLE CONTROLLER ALLOCATION AND TAKE
;       APPROPRIATE ACTION
        DEC     NMAMB           ;DEC MA/MB20 W/STORAGE COUNT
        TSTB    CONT1           ;SINGLE OR DOUBLE ALLOC?
        BGE     4$              ;DOUBLE
        MOV     R2,(R0)         ;CHANGE +2,+3 BYTES FOR SINGLE CONTROLLER
                                ;ALLOCATION TO SBUS RQ EN 0123 SET
        BR      5$              ;GO TO EXIT ROUTINE
4$:     DEC     NMAMB           ;DECR IT AGAIN FOR DOUBLE CONTER RULE
        BIC     #5000,R2                ;SHUT OFF RQ EN 0,2 FOR OTHER CONTR.
        MOV     -(R0),R1        ;GET +0,+1 BYTES FOR COPY
        MOVB    CONT1,R0                ;GET OTHER CONTROLLER NO.
        JSR     PC,CATAC                ;PERFORM ALICAT ADDR FUNC
        MOV     R1,(R0)+
        MOV     R2,(R0)         ;COPY DONE
        MOVB    CONT0,-2(R0)    ;SET IN ALTERNATE CONTROLLER NO.
5$:     JMP     HOLFIL          ;FILL REST OF HOLE IF ANY


;SEQ439

.SBTTL          LOGICAL TABLE CONTENT REPORTER
;-----THIS SUBROUTINE REPORTS THE CONTENTS OF THE LOGICAL TABLES
;       SETTING THEM UP FIRST IF NEED BE.
REPLOG: JSR     R5,SETLT
RLC:    PMSG    <\LOGICAL MEMORY CONFIGURATION:\>
        PMSG    <		   CONTROLLER\>
        PMSG    <ADDRESS   SIZE   RQ0 RQ1 RQ2 RQ3  CONTYPE INT\>
        PUSH    <GAPCNT,#GAPTAB,DMA2TS,#DMA20T> ;TEMP COUNTERS AND PNTRS
        CLR     R3              ;SET 'THE' ADDRESS INTO R3
;-----PRINT 'THE'ADDRESS
RLCL:   MOV     R3,R0
        JSR     R5,EPA          ;GO AND PRINT
;-----IS 'THE' ADDRESS ALLOCATED TO INTERNAL OR EXTERNAL MEMORY?
        TST     2(SP)           ;ANYTHING LEFT IN EXT TABLE?
        BEQ     2$              ;NO
        CMP     R3,@(SP)        ;ALLOCATED TO EXTERNAL?
        BLT     2$              ;NO, THEREFORE TO INTERNAL
        BEQ     1$              ;YES
        JSR     PC,FED          ;LOGIC ERROR--ADDR NOT GELONGING TO ANYONE
;-----START OF EXTERNAL MEMORY CO-ROUTINE--FIRST GET BLOCK SIZE
1$:     DEC     2(SP)           ;DEC TABLE ENTRY COUNT AS LOGIC CHECK
        ADD     #2,(SP)
        MOV     @(SP),R0        ;SIZE NOW IN R0
        ADD     #2,(SP)
        JSR     PC,COMCO                ;START COMMON CO-ROUTINE
        MOV     #4,R0           ;NOW DMA20 CONTROLLER ADDR
        JSR     PC,@(SP)+
        PMSG    <FOR ALL     >
        ADD     #2,(SP)         ;ENABLE REST OF CO ROUTINE
        $PMSG,TYPE2             ;PRINT 'DMA20'
        MOVB    DMA20I,R1
        JSR     PC,@(SP)+       ;DONE---


;SEQ440

;-----START OF INTERNAL MEMORY CO-ROUTINE---GET CONTR NO.
2$:     MOV     #37,R2          ;CONTR NO./INDEX TO R2
        
3$:     TSTB    TYPNUM(R2)              ;IS CONTROLLER ALLOCATED?
        BGE     4$              ;NO, JUST GO GET NEXT ONE
        MOV     R2,R0
        JSR     PC,CATAC2               ;GET CATTAB ENTRY ADDR FOR THIS CONTR
        MOV     (R0)+,R1        ;ISOLATE START ADDR
        MOVB    (R0),R0
        ROL     R1
        ROL     R0
        ROL     R1
        ROL     R0
        CMP     R0,R3           ;IS IT THE SAME AS 'THE ' ADDR
        BEQ     5$              ;YES--THIS CONTR IS ALLOCATED TO 'THE' ADDR
4$:     DEC     R2              ;ELSE LOOK AT NEXT CONTROLLER DOWN THE LINE
        BGE     3$              ;LOOP IF SOME LEFT
        BR      GAPFND  ;AMYBE GAP ALLOCATED HERE....GO CHECK
;-----CONTROLLER FOUND--EXTRACT AND PRINT SIZE INFO
5$:     ROL     R1              ;GET SIZE
        ROL     R1
        ROL     R1
        ROL     R1
        ROL     R1
        BIC     #177760,R1
        INC     R1
        BIC     #177760,R0
        SUB     R0,R1           ;DIFFERENCE BETWEEN UPPER AND LOWER IS SIZE
        MOV     R1,R0
        JSR     PC,COMCO                ;START THE COMMON CO-ROUTINE
;-----EXTRACT AND PRINT CONTROLLER NUMBERS
        MOV     #4,R4   ;LOOP CONT
        MOV     R2,R0           ;FOR CATAC2
        JSR     PC,CATAC2       ;GET CATTAB ENTRY ADR FOR GIVEN CONTR #
        MOV     (R0)+,7$+2      ;SAVE ALTERNATE CONTR #
        MOV     (R0),R1         ;RQ ENABLES AND INTRLV BITS TO R1
        ROL     R1              ;POSITION RQ BITS FOR USE
        ROL     R1
        ROL     R1
        ROL     R1
6$:     MOV     R2,R0           ;CURRENT CONTR #
        ROL     R1              ;IS RQ ENABLED FOR CURRENT CONTR?
        BCS     8$              ;YES...USE CONTR # ALREADY IN R0
7$:     MOVB    #000000,R0      ;ELSE USE ALTERNATE CONTR #
8$:     JSR     PC,@(SP)+       ;CALL CO-ROUTINE
        DEC     R4
        BGT     6$              ;LOOP UNTIL DONE
        ADD     #2,(SP) ;ENABLE REST OF CO-RTN


;SEQ441

;-----PRINT CONTROLLER TYPE
        MOVB    TYPNUM(R2),R0   ;GET TYPE
        BIC     #177770,R0      ;DEJUNK
        ASL     R0
        MOV     MEMTYP(R0),R0   ;ADDR OF NAME CHAR STRING
        PNTAL
;-----PRINT INTERLEAVE MODE (FIRST EXTRACT FROM R1)
        ASR     R1
        ASR     R1
        ASR     R1
        BIC     #177774,R1               ;DEJUNK
        JSR     PC,@(SP)+       ;PRITN AND EXIT
;-----SECTION TO CHECK AND SEE IF A MEMORY GAP HAS BEEN CALLED FOR AND
;       IF IT'S IN THE RIGHT PLACE.
GAPFND: DEC     6(SP)   ;ANY GAPS LEFT?
        BGE     1$              ;YES...OK SO FAR
        JSR     PC,FED          ;ELSE PROBABLE LOGIC ERROR
1$:     CMP     @4(SP),R3       ;IS GAP WHERE IT SHOULD BE?
        BEQ     2$              ;YES...OK TOO
        JSR     PC,FED          ;ELSE FATAL LOGIC ERROR
2$:     ADD     #2,4(SP)                ;PT TO GAP SIZE
        MOV     @4(SP),R0       ;GET SIZE
        JSR     PC,COMCO                ;O PEINR & UPDATE 'THE' ADDRESS
        TST     (SP)+
        ADD     #2,4(SP)                ;PT TO NXT GAP NOW
        PMSG   < NONEXISTENT MEMORY\>
        BR      ENDCRR          ;CONTINUE PRINT & CHECK LOOP


;SEQ442

;-----CO-ROUTINE TO PRINT DATA FOR BOTH INTERNAL AND EXTERNAL MEM PATH
COMCO:  ADD     R0,R3           ;UPDATE 'THE' ADDR FOR NEXT TIME AROUND
COMCO2: SL      R0,4            ;GET SIZE IN TERMS OF K, NOT 16K
        PUSH    R0              ;SAVE SIZE TEMPORARILY
        PNTDEC
        PMSG    <K	>       ;K<TAB> AFTER SIZE
        CMP     (SP)+,#1000.    ;SIZE >= 1000.K?
        BLO     1$              ;NO
        PNTBAK                  ;ELSE SUPPRESS TAB CHARACTER
1$:     JSR     PC,@(SP)+
;-----NOW THE CONTROLLER NUMBER
2$:     PUSH    R0              ;SAVE CONTR #
        PSPACE
        POP     R0              ;RSTR CONTR #
        JSR     R5,P20D         ;FIRST NUMBER
        PSPACE
        JSR     PC,@(SP)+       
        BR      2$              ;LOOP UNTIL SKIPPED ON CALL
;-----NOW THE INTERLEAVE MODE
        PSPACE
        MOV     R1,R0
        JSR     R5,PBMCR        ;PRINT INT MODE
;-----END OF LINE...FINISH UP
        TST     (SP)+           ;DEL CO-ROUTINE LINK FROM STACK
ENDCRR: CMP     R3,#400         ;DONE? (4 MEG ACCOUNTED FOR?)
        BLT     1$              ;NO--MORE TO GO
        BEQ     2$              ;YES
        JSR     PC,FED          ;YES--WE ARE REALLY FINISHED ---LOGIC ERROR
1$:     JMP     RLCL            ;LOOP
2$:     ADD     #8.,SP          ;DELETE TEMPS
        RTS     R5              ;DONE--RETURN


;SEQ443

;-----ERRORS COME HRE
FED:    PCRLF           ;PRINT WHAT PART OF THE LINE WE HAVE TO HERE
        JSR     PC,MCLEM

;-----SUBROUTINE TO PRINT ONE OR TWO OCTAL DIGITS RJ IN THE PARAM REG.
P20D:   PUSH    R0
        ROR     R0
        ROR     R0
        ROR     R0
        PNTNBR          ;PRINT FIRST DIGIT
        POP     R0
        PNTNBR          ;PRINT SECOND DIGIT
        RTS     R5

;-----SUBROUTINE TO PRINT THE INTELEAVE & A <CRLF>.
PBMCR:  CMP     R0,#3           ;4 WAY?
        BNE     1$              ;NO
        INC     R0              ;ELSE MAKE 3 A 4
1$:     PNTNBR,PCRLF
        RTS     R5


;SEQ444


.SBTTL  SUBTRN TO SET THE CALCULATED CONFIGURATION
;-----THIS SUBROUTINE GOES OUT AND DOES THE CONFIGURATION OF MEMORY
;       BASED  UPON THE CONTENTS OF THE LOGICAL TABLES AFTER THEY HAVE BEEN
;       CHECKED FOR VALIDITY.  THE TALBES ARE FIRST SET IF NEED BE.
MEMCON: JSR     R5,SETLT
CONFIG: MEMRST          ;RESET ALL MEM CONTROLLERS
        TST     DMA2TS          ;ANY EXT MEM?
        BEQ     1$              ;NO
;-----SET UP AND DO SBUS DIAG FUNC 0 TO EXT MEM
        MOVB    DMA20I,R0       ;SET UP INTRLV & CLR 0-5
        MOVB    CATIF(R0),SDF0+3        ;(RQ EN 0,2 IGNORED BY DMA209)
        MOV     #4,TSTCON               ;SET CONTROLLER NO. FOR DMA20
        SBUSDG  SDF0
        BICB    #317,SDF0+3             ;ECHO CHECK SBUS DIAG JUST DONE
        BICB    #317,3(R0)
        CMPB    3(R0),SDF0+3
        BNE     MCCE


;SEQ445

;-----LOOP THROUGH MA20 AND MB20 CONTROLLERS AND DO THEM TOO.
1$:     MOV     #3,R1           ;CONTR #/INDEX
2$:     TSTB    TYPNUM(R1)      ;CONTR ALLOCATED?
        BGE     3$
        MOV     R1,R0   
        JSR     PC,CATAC2       ;GET LOGICAL TABLE ENTRY ADDR
        INC     R0              ;SKIP +0 BYTE
        MOVB    (R0)+,SDF1+1    ;SET YUP SBUS DIAG FUNCS
        MOVB    (R0)+,SDF1+2
        MOVB    (R0),SDF0+3
        MOV     R1,TSTCON       ;SET CONTR #
        SBUSDG  SDF0
        BICB    #317,SDF0+3     ;ECHO CHECK SBUS DIAG JUST DONE
        BICB    #317,3(R0)
        CMPB    3(R0),SDF0+3
        BNE     MCCE
        SBUSDG  SDF1
        BICB    #300,SDF1+2    ;ECHO CHECK SBUS DIAG JUST DONE
        BICB    #300,2(R0)
        CMPB    2(R0),SDF1+2
        BNE     MCCE
        BICB    #3,SDF1+1       ;ECHO CHECK SBUS DIAG JUST DONE
        BICB    #3,1(R0)
        CMPB    1(R0),SDF1+1
        BNE     MCCE
3$:     DEC     R1              ;LOOP UNTIL DONE
        BGE     2$
        BIS     #CS,MCCB        ;MARK CONF. SET
        BIC     #PTS+PTA+LTS+LTA,MCCB   ;FORCE REDETERMINATION NXT TIME
        RTS     R5
SDF0:   WD36    0000,4000,0000  ;SBUS DIAG FUNC BLANKS
SDF1:   WD36    0000,0000,0001
MCCE:   PMSG    <UNABLE TO CONF. MEM: MACH. ERR\>        ;MACH, ERR
        FATAL

;SEQ446
 
.SBTTL  *MBOX*  MBOX TEST SUBROUTINE LIBRARY  20-MAY-77
.REM    %
        TRAP HANDLER.  EMULATES AN R5 CALLING CONVENTION.
%
$TRAP:  MOV     R5,$SAVE        ;SAVE R5
        MOV     (SP),R5         ;GET TRAP PC
        MOVB    -2(R5),R5       ;GET TRAP #
        CMP     R5,#130         ;VALID TRAP?
        BLE     1$              ;YES
        CLR     R5              ;NO,UNDEFINED
1$:     ASL     R5              ;MULTIPLY BY 2
        MOV     $TRBAS(R5),$LINK        ;GET ENTRY POINT
        POP     R5              ;TRAP PC TO R5

        PUSH    #2$

        RTT                     ;RESTORE USER STATUS
2$:     PUSH    $SAVE           ;ORIGINAL R5 TO STACK

        JMP     @$LINK          ;CALL PROGRAM

$LINK:  .WORD   0               ;TRAP LINKAGE SCRATCH
$SAVE:  .WORD   0               ;R5 FOR CALLING CONVENTION

$UNDEF: PMSG    <UNDEF. TRAP AT PC >
     

        MOV     R5,R0
        DEC     R0              ;
        DEC     R0              ;
        PNTOCS                  ;PRINT TRAP LOCATION
        POP     R5              ;RESTORE R5

        FATAL


;SEQ447

$TRBAS: .WORD   $UNDEF  ;ILLEGAL TRAP
        .WORD   $UNDEF  ;TRAP 1 RESERVED
        .WORD   $UNDEF  ;TRAP 2 RESERVED
        .WORD   $UNDEF  ;TRAP 3 RESERVED
        .WORD   SAV.3   ;TRAP 4
        .WORD   RST.3   ;TRAP 5
        .WORD   SAV.5   ;TRAP 6
        .WORD   RST.5   ;TRAP 7
        .WORD   RUNPRG  ;TRAP 10
        .WORD   CONTIN  ;TRAP 11
        .WORD   RUNBIG  ;TRAP 12
        .WORD   STEP    ;TRAP 13
        .WORD   FIND    ;TRAP 14
        .WORD   EVENT   ;TRAP 15
        .WORD   STEP10  ;TRAP 16
        .WORD   STPCON  ;TRAP 17
        .WORD   BRST    ;TRAP 20
        .WORD   MASK16  ;TRAP 21
        .WORD   $UNDEF  ;TRAP 22 RESERVED
        .WORD   $UNDEF  ;TRAP 23 RESERVED
        .WORD   MASK36  ;TRAP 24
        .WORD   MSKDAT  ;TRAP 25
        .WORD   $UNDEF  ;TRAP 26 RESERVED
        .WORD   $UNDEF  ;TRAP 27 RESERVED
        .WORD   ACBLK   ;TRAP 30
        .WORD   $UNDEF  ;TRAP 31 RESERVED
        .WORD   RANGE   ;TRAP 32
        .WORD   $UNDEF  ;TRAP 33 RESERVED
        .WORD   $UNDEF  ;TRAP 34 RESERVED
        .WORD   $UNDEF  ;TRAP 35 RESERVED
        .WORD   $UNDEF  ;TRAP 36 RESERVED
        .WORD   LOAD    ;TRAP 37
        .WORD   $UNDEF  ;TRAP 40 RESERVED
        .WORD   MEMADR  ;TRAP 41
        .WORD   SBINI   ;TRAP 42
        .WORD   SB      ;TRAP 43
        .WORD   READ17  ;TRAP 44
        .WORD   $UNDEF  ;TRAP 45 RESERVED
        .WORD   STEXCT  ;TRAP 46
        .WORD   XQT     ;TRAP 47
        .WORD   MEMRST  ;TRAP 50     
        .WORD   RSTMBX  ;TRAP 51
        .WORD   $UNDEF  ;TRAP 52 RESERVED
        .WORD   $UNDEF  ;TRAP 53 RESERVED
        .WORD   $UNDEF  ;TRAP 54 RESERVED
        .WORD   SBUPRG  ;TRAP 55
        .WORD   SBUSDG  ;TRAP 56
        .WORD   $UNDEF  ;TRAP 57 RESERVED
        .WORD   ADRSET  ;TRAP 60
        .WORD   $UNDEF  ;TRAP 61 RESERVED
        .WORD   $UNDEF  ;TRAP 62 RESERVED
        .WORD   $UNDEF  ;TRAP 63 RESERVED
        .WORD   INVAL   ;TRAP 64


;SEQ448

        .WORD   $UNDEF  ;TRAP 65 RESERVED
        .WORD   $UNDEF  ;TRAP 66 RESERVED
        .WORD   $UNDEF  ;TRAP 67 RESERVED
        .WORD   $UNDEF  ;TRAP 70 RESERVED
        .WORD   $UNDEF  ;TRAP 71 RESERVED
        .WORD   SOBAC   ;TRAP 72
        .WORD   $UNDEF  ;TRAP 73 RESERVED
        .WORD   PNTUML  ;TRAP 74
        .WORD   CMP.E   ;TRAP 75
        .WORD   CMP.F   ;TRAP 76
        .WORD   $UNDEF  ;TRAP 77 RESERVED
        .WORD   $UNDEF  ;TRAP 100 RESERVED
        .WORD   $UNDEF  ;TRAP 101 RESERVED
        .WORD   $UNDEF  ;TRAP 102 RESERVED
        .WORD   $UNDEF  ;TRAP 103 RESERVED
        .WORD   $UNDEF  ;TRAP 104 RESERVED
        .WORD   $UNDEF  ;TRAP 105 RESERVED
        .WORD   $UNDEF  ;TRAP 106 RESERVED
        .WORD   $UNDEF  ;TRAP 107 RESERVED
        .WORD   $UNDEF  ;TRAP 110 RESERVED
        .WORD   $UNDEF  ;TRAP 111 RESERVED
        .WORD   $UNDEF  ;TRAP 112 RESERVED
        .WORD   ACSCAT  ;TRAP 113
        .WORD   ACLOAD  ;TRAP 114
        .WORD   BACKPL  ;TRAP 115
        .WORD   $UNDEF  ;TRAP 116 RESERVED
        .WORD   $UNDEF  ;TRAP 117 RESERVED
        .WORD   $UNDEF  ;TRAP 120 RESERVED
        .WORD   $UNDEF  ;TRAP 121 RESERVED
        .WORD   $UNDEF  ;TRAP 122 RESERVED
        .WORD   $UNDEF ;TRAP 123 RESERVED
        .WORD   $UNDEF  ;TRAP 124 RESERVED
        .WORD   PNTID   ;TRAP 125
        .WORD   GETVER  ;TRAP 126
        .WORD   PNTVER  ;TRAP 127
        .WORD   $UNDEF  ;TRAP 130 RESERVED



.REM    %
        SUBROUTINE TO MAKE SURE THAT EXAM/DEPOSIT, EXECUTE, OR PROGRAM
RUN FINISHED UP CORRECTLY.  CHECKS C-BIT.  RETURNS IF CLEAR, ELSE DOES
ERROR WITH MESSAGE DEPENDING ON ENTRY POINT (CHKED, CHKX, OR CHKP).
        %
CHKED:  BCS     1$              ;BR IF ANY ERROR(S)
        RTS     PC              ;ELSE RETURN TO CALLER
1$:     MOV     #ERRED,R0       ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CCODE
CHKX:   BCS     1$              ;BR IF ERR BIT SET
        RTS     PC              ;ELSE RETURN
        
1$:     MOV     #ERRX,R0        ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKP:   BCS     1$              ;BR IF CARRY SET...ERR
        RTS     PC              ;ELSE RET
1$:     MOV     #ERRP,R0        ;POINT TO ERROR MESSAFE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKCOM:ERRCOM   PNTAL           ;PRINT ERROR MESSAGE
        ERRMSG  <\REAL ERROR PC: >

        POP     R0              ;GET REAL ERR PC

        SUB     #4,R0           ;ADJ
        ERRCOM  PNTOCT          ;PRINT IT
        TST     R5              ;CHK SUBTEST # FOR REASONABLE VAALUE
        BLE     1$              ; .LE. 0... NG
        CMP     R5,#3000
        BGT     1$              ;NG
        ERRMSG  <  SUBTEST: >

        MOV     R5,R0           ;SUBTEST # TO PARAM REG
        ERRCOM  PNTDEC          ;PRINT IT
1$:     ERROR

        ERRED:  .ASCIZ  %EXAMINE/DEPOSIT ERROR%
        ERRX:   .ASCIZ  %INSTRUCTION EXECUTE ERROR%
        ERRP:   .ASCIZ  %PROGRAM DIDN'T HALT%
        .EVEN



;SEQ449

.REM    %
        SUBROUTINE TO PLACE A PARAMETER WORD ON THE ERROR STACK.  THIS
        WORD IS IGNORED BY THE ERROR REPORTER, BUT MAY BE USED BY THE
        ISOLATION ROUTINE.  THE WORD IS PASSED TO THIS ROUTINE IN R0.
        %
PWTES:  PUSH    R0              ;SAVE PARAM WD
        MOV     ERSP..,R0       ;GET PTR TO ERR STK
        MOV     #FTPRM,(R0)+    ;PARAM WD FORMAT MARKER TO ERR STK
        POP     (R0)+           ;MOVE PARAM WD TO ERR STK
        MOV     R0,ERSP..       ;UPDATE ERR STK PTR
        RTS     R5              ;RET TO CALLER

 

;SEQ451

.REM    %
        PNTERA IS A SUBROUTINE DESIGNED TO PRINT THE ERA WORD WHICH IS
ASSUMED LOADED IN THE GIVEN AC.  GPNTER DOES A RDERA,,,0 AND THEN CALLS
PNTERA WITH A PARAM OF AC0.
        %
GPNTER: XQT     1$              ;READ THE ERA INTO AC0
        JSR     PC,CHKX
        PNTERA  AC0
        RTS     R5
1$:     IO10    RDERA,,,0
        .EVEN
PNTERA: MOV     (R5)+,1$+2      ;AC # TO EXAMT PARAM LST
        ERRMSG  <\ERA WORD: >
1$:     EXAMT,000000,ERAWD      ;GET THE ERA WD INTO 11 MEM
        JSR     PC,CHKED
        ERRDAT  ERAWD
        RTS     R5
ERAWD:  .WORD   0,0,0           ;ERA WORED GOES HERE
 
;SEQ452

.REM    %
        ROUTINE TO REPORT BIT ERROR FOR TBIT PDP-10 BIT TEST
        %
BITERR: BNE     1$              ;FIND OUT BIT FLAVOR
        CLR     R0              ;WAS A ZERO
        BR      2$      
1$:     MOV     #200,R0         ;WAS A ONE
2$:     PUSH    <R1,R3>


        MOV     ERSP..,R3               ;GET ERR STACK POINTER
        MOV     #FT9,(R3)+              ;STORE FORMAT TYPE
        BISB    DFSAVE,R0               ;GET DIAG PN
        MOVB    R0,(R3)+                ;STACK BYTE
        MOVB    ERBIT,(R3)+             ;STACK BIT NBR IN LEFT
        MOV     R3,ERSP..               ;SAVE POINTER
        POP     <R3,R1>


        RTS     R5              ;RETURN


.SBTTL          COMPARE ROUTINES
.REM    %
        36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPARISON
OF 5-BYTES OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT &
LOADS THE ERROR STACK IF MISCOMPARE.
CALL IS:
        JSR     R5,MSK36R
        R2 = POINTER TO MASK (0S IMPLY TEST)
        R3 = POINTER TO EXPECTED DATA
        R4 = POINTER TO ACTUAL DATA

%
MSK36R: PUSH    <R1,R5>


        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #5,R0           ;LOOP COUNT
1$:     MOVB    (R3)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R2),R1         ;MASK IT
        MOVB    (R4)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R2)+,R5        ;MASK IT
        CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGT     1$              ;NO, LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     3$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R2           ;RESOTRE MASK POINTER
        MOV     R2,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R4           ;RESTORE ACTUAL POINTER
        MOVB    (R4)+,(R0)+     ;ACTUAL TO ERROR STACK
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        SUB     #5,R3           ;RESTORE POINTER TO EXPECTED
        MOVB    (R3)+,(R0)+     ;EXPECTED TO ERROR STACK
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
3$:     POP     <R5,R1>


        RTS     R5              ;RETURN

FFLAG:  .WORD   0               ;FAULT FLAG



.REM    %
        36-BIT DATA COMPARE ROUTINE (TRAILING PARAMETERS).
USES MSK36R.
CALL IS:
        JSR     R5,MASK36
        ENTRY+2 = POINTER T MASK (OS IMPLY TEST)
        ENTRY+4 = POINTER TO EXPECTED DATA
        ENTRY+6 = POINTER TO ACTUAL DATA
%
MASK36: PUSH    <R2,R3,R4>



        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     (R5)+,R4        ;ACTUAL POINTER TO R4
        JSR     R5,MSK36R       ;PERFORM THE TEST
        POP     <R4,R3,R2>



        RTS     R5              ;RETURN


.REM    %
        36-BIT DTE-20 DATA COMPARE ROUTINE (TRAILING PARAMETERS)
USES MSK36R.
CALL IS:
        JSR     R5,MSKDAT
        ENTRY+2 = POINTER TO MASK
        ENTRY+4 = POINTER TO EXPECTED DATA
%
MSKDAT: PUSH    <R2,R3,R4>



        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     .DAT3,R4        ;DTE20 DATA POINTER TO R4
        JSR     R5,MSK36R       ;DO COMPARISON
        POP     <R4,R3,R2>



        RTS     R5              ;RETURN




;SEQ455
 
.REM    %
        SUBROUTINE CHKIT IS DESIGNED TO COMPARE 2 PDP-10 WORDS UNDER A MASK TO
MAKE SURE THEY ARE IDENTICAL.  IF THEY ARE NOTHING HAPPENS.   IF THEY ARE NOT,
THE SUBROUTINE WILL DUMP A TITLE THEN THE ERROR BITS.  IF ANY BIT APPEARS IN
THE NAMELIST ASSOCIATED WITH THE CALL TO CHKIT ITS NAME IS ALSO SENT TO THE
ERROR STACK.  NOT THAT IF THE POINTER TO THE KL10 WORD IN PDP11 MEMORY IS LESS
THAN 20, THE SUBROUTINE FIRST RETRIEVES THE WORD FROM THE APPROPRIATE KL10 AC.
CHKIT IS DIVIDED INTO 2 PARTS:  CHKIT WHICH RETRIEVES THE WORDS AND CHECKS THEM,
AND CHKBE WHICH DUMPS ERROR INFO TO THE ERROR STACK WHEN CHKIT DETECTS AN ERROR.
SEE THE NAME LISTS ABOVE FOR EXAMPLES OF CONSTRUCTION OF NAMELISTS.
        %
;-----SETUP:    RESET FLAG, GET POINTERS.
CHKIT:  REGSAV                  ;SAVE P[DP11 REGS
        MOV     #-1,CHKFLG      ;RESET STATE VARIABLE
        MOV     #35.,CHKBN       ;RHE BIT # OF BYE  BEING PROCESSED
        MOV     (R5)+,R2        ;MASK POINTER

        MOV     (R5)+,R3        ;EXPECTED VALUE POINTER
        MOV     (R5)+,R4        ;ACTUAL VALUE POINTER
;-----IF EITHER THE ACTUAL OR EXPECTED VALUES IS IN A KL10 AC, GET IT.
        CMP     R3,#17          ;EXPECTED VALUE
        BHI     2$              ;BR IF NOT IN AC
        MOV     R3,1$+2 
1$:    EXAMT,000000,8$  ;ELSE GET IT FROM AC
        JSR     PC,CHKED
        MOV     R0,R3           ;UPDATE PTR
2$:     CMP     R4,#17          ;ACTUAAL VALUE
        BHI     4$
        MOV     R4,3$+2
3$:     EXAMT,000000,9$
        JSR     PC,CHKED
        MOV     R0,R4
;-----POINTERS ARE NOW VALID.  COPY T HEM TO CHKBE SO THAT IT MAY USE THEM.
4$:     MOV     R2,CHKBE1+2     ;MASK
        MOV     R4,CHKBE2+2     ;ACTUAL
        MOV     R3,CHKBE3+2     ;EXPECTED


;SEQ456
;-----NOW SCAN FOR ERRORS. CALL CHKBE IF ANY ARE FOUND.
5$:     MOVB    (R3)+,R0        ;GET 8 BITS OF EXPECTED KL10 WD
        MOVB    (R4)+,R1        ;8 BITS OF ACTUAL, TOO
        EXOR    R0,R1           ;GET BIT DIFFERENCES IN R1
        BICB    (R2)+,R1        ;SHUT OFF ANY MASKED DIFFERENCES
        BIC     #177400,R1      ;SHUT OFF ANYTHING OUTSIDE OF THE 8 BITS
        BEQ     6$              ;BR IF NO DIFFERENCES....OK
        JSR     PC,CHKBE                ;ELSE CALL ERROR INFO DUMPER
6$:     SUB     #8.,CHKBN       ;NO ERR.  GO ON TO NXT 8 BIT GROUP
        BGT     5$              ;BR IF THERE ARE ANY GROUPS LEFT
        REGRST          ;ELSE ALL DONE... RESTORE PDP11 REGS
        ADD     #8.,R5          ;SKIP PARAM LIST
        TST     CHKFLG          ;WERE ANY ERRS DETECTED (ALSO CLR C-BIT)
        BLT     7$              ;NO...OK...DO C-BIT CLR RETURN
        SEC                     ;ELSE SET ERROR FLAG
7$:     RTS     R5              ;RETURN
8$:     .WORD   0,0,0           ;EXPECTED VALUE GOES HERE IF WAS IN AC

9$:     .WORD   0,0,0           ;SAME FOR ACTUAAL VAL
CHKFLG: .WORD   -1              ;STATE CONTROL FOR CHKIT & CHKBE
CHKBN:  .WORD   35.             ;BIT # OF RIGHT HAND BIT OF KL10 IN 11 BYTE
;-----SUBROUTINE CHKBE.  ENTRY:  SAV REGS, SHUFFLE ERROR INFO AROUND.
CHKBE:  REGSAV
        MOV     R0,R2           ;EXPECTED BIT ALUES
        MOV     R1,R3           ;ERROR BITS
        MOV     CHKBN,R4        ;BHE BIT # OF BYTE
;-----PRINT TITLE AND MASK INFO IF NOT DONE YET.
        TST     CHKFLG          ;TITLE PRINT DOE YET?
        BGE     CHKBE4          ;YES...SKIP
        INC     CHKFLG          ;ELSE INDICATE DONE
        MOV     (R5),R0         ;GET TITLE ADR
        ERRCOM  PNTAL           ;TITLE TO ERR STK
        MOV     #FTM36,(R0)+    ;MASK INFO MARKER TO ERR STK
CHKBE1: MOV     #000000,(R0)+   ;MASK PTR TO ERR STK
CHKBE2: MOV     #000000,R1      ;ACT DATA PTR TO R1
        MOVB    (R1)+,(R0)+     ;MOVEACT DAT TO ERR STK
        MOVB    (R1)+,(R0)+
        MOVB    (R1)+,(R0)+
        MOVB    (R1)+,(R0)+
        MOVB    (R1)+,(R0)+
CHKBE3: MOV     #000000,R1      ;EXPECTED DATA PTR TO R1
        MOVB    (R1)+,(R0)+     ;MOV XPCTD DAT TO ERR STK
        MOVB    (R1)+,(R0)+
        MOVB    (R1)+,(R0)+



;SEQ457

        MOVB    (R1)+,(R0)+
        MOVB    (R1)+,(R0)+
        MOV     R0,ERSP..       ;UPDATE END OF ERR STK PTR


;SEQ458

;-----FIND SIGNAL & PRINT IT.  IF FOUND, PRINT COL HEADER IF NOT DONE BEFORE.
CHKBE4: BIT     #1,R3           ;WAS THIS BIT IN ERROR?
        BEQ     4$              ;NO...GO LOOK AT NXT BIT
        MOV     (R5),R1         ;NAME LIST PTR TO R1
1$:     TSTB    (R1)+           ;SCAN LIST FOR 0 BYTE (END OF STRING)
        BNE     1$
        TSTB    (R1)            ;HIT END OF LIST YET?
        BLT     4$              ;YES...BIT NOT IN LIST...G CHK NXT BIT
        CMPB    R4,(R1)+        ;IS THIS THE BIT WE'RE AFTER?
        BNE     1$              ;NO...SCAN LIST SOME MORE
        TST     CHKFLG          ;COL HEADER PRINTED?
        BGT     2$              ;YES...DON'T PRINT AGAIN
        INC     CHKFLG          ;ELSE INDICATE THAT IT WAS PRINTED
        ERRMSG  <\ACT EXP SIGNAL NAME/DESCRIPTION>
2$:     MOV     #5$,R0          ;ASSUME BIT WAS LO WHEN SHD HAV BEEN HI
        BIT     #1,R2           ;IS THAT THE WAY IT IS?
        BNE     3$              ;YES
        MOV     #6$,R0  ;ELSE SAY IT WAS HI WHEN SHD HAV BEEN LO
3$:     ERRCOM  PNTAL           ;PRINT "HI-LOW" OR "LO-HI"
        MOV     R1,R0           ;BIT NAME PTR TO R0
        ERRCOM  PNTAL           ;SEN NAM TO ERR STK ALSO
4$:     DEC     R4              ;NXT BIT #
        ASR     R2              ;NXT EXPECTED BIT
        ASR     R3              ;NXT ERR BIT
        BNE     CHKBE4          ;LOOP IF MORE TO DO
        REGRST                  ;ELSE DONE...RESTORE REGS
        RTS     PC              ;RETURN TO CHKIT TO FINISH SCAN
5$:     .ASCIZ  %\ L  H	%
6$:     .ASCIZ  %\ H  L	%

;SEQ459
.REM    %
        16-BIT DATA COMPARE ROUTINE.  SETS THE C-BIT & LOADS
        THE ERROR STACK IF MISCOMPARE.  RETURNS THE MASKED
        DIFFERENCE (ACTUAL -EXPECTED) IN R0.
        CALL IS:
        JSR     R5,MASK16
        CALL+2  = MASK (0S IMPLY TEST)
        CALL+4  = POINTER TO ACTUAL
        CALL+6  = POINTER TO EXPECTED
%
MASK16: PUSH    R1

        PUSH    (R5)+           ;MASK

        MOV     @(R5)+,R0       ;ACTUAL
        MOV     @(R5)+,R1       ;EXPECTED
        BIC     (SP),R0         ;MASK ACTUAL
        BIC     (SP)+,R1        ;MASK EXPECTED
        SUB     R1,R0           ;ACTUAL - EXPECTED
        BEQ     MSK16E          ;COMPARISON O.K.
        MOV     ERSP..,R1       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R1)+    ;FORMAT TO ERROR STACK
        SUB     #6,R5           ;RESTORE ENTRY POINT
        MOV     (R5)+,(R1)+     ;MASK TO ERROR STACK
        MOV     @(R5)+,(R1)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R1)+    ;EXPECTED TO ERROR STACK
        BR      MSK16F          ;CLEANUP & RETURN



;SEQ459

.REM    %
        16-BIT REGISTER DATA COMPARE ROUTINE.  SETS THE C-BIT &
        LOADS THE ERROR STACK IF MISCOMPARE.  RETURNS THE MASK-
        ED DIFFERENCE (ACTUAL - EXPECTED) IN R0.
        CALL IS;
        JSR     R5,MSK16R
        R2 = MASK (0S IMPLY TEST)
        R3 = ACTUAL DATA
        R4 = EXPECTED DATA
%
MSK16R: PUSH    R1


        MOV     R3,R0           ;
        BIC     R2,R0           ;MASK ACTUAL
        MOV     R4,R1           ;
        BIC     R2,R1           ;MASK EXPECTED
        SUB     R1,R0           ;ACTUAL - EXPECTED
        BEQ     MSK16E          ;COMPARISON O.K.
        MOV     ERSP..,R1       ;GET ERROR STACK POINTER
        MOV     #FTM16,(R1)+    ;FORMAT TO ERROR STACK
        MOV     R2,(R1)+        ;MASK TO ERROR STACK
        MOV     R3,(R1)+        ;ACTUAL TO ERROR STACK
        MOV     R4,(R1)+        ;EXPECTED TO ERROR STACK
MSK16F: MOV     R1,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
MSK16E: POP     R1

        RTS     R5              ;RETURN





.REM    %
SDFRD - ROUTINE TO SAVE DIAGNOSTIC FUNCTION & PERFORM A DIAG-
NOSTIC READ.
%
SDFRD:  MOV     (R5)+,R0        ;GET DIAG FN
SDFRDA: MOV     R0,DFSAVE       ;SAVE DIAG FN
        DFRD
        RTS     R5              ;RETURN

.REM    %
PATERR - ROUTINE TO PUT A 36-BIT PATTERN ON THE ERROR STACK.
PATTERN POINTER IN R0.
%
PATERR: PUSH    <R1,R2>                 ;PATTERN ERROR REPORTER
        MOV     ERSP..,R1               ;POINT TO STACK
        MOV     #FT11,(R1)+             ;FORMAT TYPE
        MOV     #5,R2                   ;BYTE COUNT
1$:     MOVB    (R0)+,(R1)+             ;36 BIT PATTERN
        DEC     R2      
        BGT     1$                      ;DONE?
        CLRB    (R1)+                   ;YES, CLEAR EXTRA BYTE
        MOV     R1,ERSP..               ;RESET STACK POINTER
        POP     <R2,R1>
 
        RTS R5
  
  

;SEQ461

.SBTTL          36-BIT ERROR PARSER  06-AUG-75
.REM    %
RANGE - ROUTINE TO TEST THE ERROR STACK TO DETERMINE THE BIT RANGE
OF 36-BIT DATA PATH ERRORS.  THE CALL IS JSR R5,RANGE.  REGISTER
R3 MUST POINT TO THE FTM36 FORMAT ENTRY ON THE ERROR STACK.
RETURNS AN INDEX OF BIT POSITION, RANGES IN R0.  INDEXES ARE AS
FOLLOWS:
        0:      BITS 30-35
        2:      BITS 27-29
        4:      BITS 24-26
        6:      BITS 18-23
        10:     BITS 12-17
        12:     BITS 09-11
        14:     BITS 06-08
        16:     BITS 00-05
        20:     BOTH HALVES
        22:     LOWER HALF
        24:     UPPER HALF
%
RANGE:  REGSAV                  ;SAVE REGISTERS
        CMP     (R3)+,#FTM36    ;FORMAT CORRECT?
        BNE     2$              ;NO, FATAL ERROR
        CLR     R4              ;CLEAR INDEX
1$:     JSR     PC,RANCOM       ;COMPARE A BIT RANGE
        BNE     3$              ;MISMATCH FOUND
        INC     R4              ;NEXT BIT RANGE
        INC     R4              
        CMP     R4,#20          ;ALL DONE?
        BLT     1$              ;NO, ERROR STACK O.K.
2$:     FATAL                   ;ERROR STACK ERROR
3$:     TST     R4              ;BITS 30-35?
        BEQ     4$              ;YES, TEST LOWER HALF
        CMP     R4,#10          ;BITS 12-17?
        BNE     5$              ;NO,SET INDEX & RETURN
        MOV     R4,TEM.         ;SAVE INDEX
        MOV     #16,R4          ;UPPER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 0-5
        BEQ     6$              ;NOT UPPER HALF
        MOV     #24,TEM.        ;SET INDEX = UPPER HALF
        BR      6$              ;CLEANUP & RETURN
4$:     MOV     R4,TEM.         ;SAVE INDEX
        MOV     #6,R4           ;LOWER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 18-23
        BEQ     6$              ;NOT LOWER HALF
        MOV     #22,TEM.        ;SET INDEX = LOWER HALF
        MOV     #10,R4          ;BOTH HALVES TEST
        JSR     PC,RANCOM       ;CHK BITS 12-17
        BEQ     6$              ;LOWER HALF
        MOV     #20,TEM.        ;SET INDEX = BOTH HALVES
        BR      6$              ;CLEANUP & RETURN
5$:     MOV     R4,TEM.         ;GET INDEX
6$:     REGRST                  ;RESTORE REGISTERS
        MOV     TEM.,R0         ;GET INDEX
        RTS     R5              ;RETURN


;SEQ333

        ;SUBROUTINE TO COMPARE ACTUAL & EXPECTED FOR THE RANGE
        ;SPECIFIED FOR THE INDEX VALUE IN R4.

RANCOM: PUSH    R4

        MOV     BRCNT(R4),SPCNT ;GET SHIFT COUNT
        MOV     R3,R4           ;GET ERROR STACK POINTER
        INC     R4              ;POINT TO ACTUAL
        INC     R4              
        JSR     PC,RANPOS       ;GET MASK & POSITION ACTUAL
        PUSH    R0              ;SAVE SHIFTED ACTUAL

        JSR     PC,RANPOS       ;GET, MASK & POSITION EXPECTED
        POP     <R1,R4>         ;RESTORE ACTUAL & INDEX


        MOV     BRMASK(R4),R2   ;GET MASK
        BIC     R2,R0           ;MASK EXPECTED
        BIC     R2,R1           ;MASK ACTUAL
        CMP     R0,R1           ;COMPARE THEM
        RTS     PC              ;RETURN

;TAKES THE DATA POINTED TO BY R4, MASKS IT & RETURNS THE
;BIT RANGE DESIRED RIGHT JUSTIFIED IN R0.
RANPOS: MOV     (R3),R5         ;GET MASK POINTER
        CLR     R0              ;BITS 20-35
        JSR     PC,RANP0        ;GET & MASK 28-35
        JSR     PC,RANP0        ;GET & MASK 20-27
        CLR     R1              ;BITS 4-19
        JSR     PC,RANP1        ;GET & MASK 12-19
        JSR     PC,RANP1        ;GET & MASK 4-11
        CLR     R2              ;BITS 0-3
        BISB    (R4)+,R2        ;SET 0-3
        BICB    (R5),R2         ;MASAK 0-3
        MOV     SPCNT,R5                ;GET SHIFT COUNT
1$:     DEC     R5              ;SHIFT DONE?
        BLT     2$              ;YES, RETURN
        ASR     R2              ;NO, SHIFT 3 WORDS RIGHT
        ROR     R1              ;
        ROR     R0
        BR      1$              ;LOOP AGAIN
2$:     RTS     PC              ;DATA IN R0, RETURN


RANP0:  BISB    (R4)+,R0        ;SET A BYTE
        BICB    (R5)+,R0        ;POSITION IT
        SWAB    R0              ;POSITION IT
        RTS     PC

RANP1:  BISB    (R4)+,R1        ;SET A BYTE
        BICB    (R5)+,R1        ;MASK A BYTE
        SWAB    R1              ;POSITION IT
        RTS     PC


;SEQ334

        ;TABLE OF SHIFT COUNT TO RIGHT JUSTIFY BITS LISTED

BRCNT:  .WORD   0       ;30-35
        .WORD   6.      ;27-29
        .WORD   9.      ;24-26
        .WORD   12.     ;18-23
        .WORD   18.     ;12-17
        .WORD   24.     ;09-11
        .WORD   27.     ;06-08
        .WORD   30.     ;00-05

        ;TABLE OF BIT CLEAR MASKS FOR EACH BIT RANGE

BRMASK: .WORD   177700  ;30-35
        .WORD   177770  ;27-29
        .WORD   177770  ;24-26
        .WORD   177700  ;18-23
        .WORD   177700  ;12-17
        .WORD   177770  ;09-11
        .WORD    177770     ;06-08
        .WORD   177700  ;00-05


.SBTTL          ERROR STACK COMPARE ROUTINES  22-SEP-75
.REM    %
        ROUTINES TO TEST THE ERROR STACK FOR THE PRESENCE OF DIAGNOSTIC
FUNCTION BIT ENTRIES OF FORMAT TYPE FT8 OR FT9.  SETS A BIT
IN A UML TABLE FOR EACH DIAGNOSTIC FUNCTION BIT FOUND TO CORRESPOND
TO A SPECIFIED LIST.  THE CALL IS JSR R5,CMP.E TO TEST ALL LIST
ENTRIES AND CMP.F TO SCAN FOR THE FIRST ERROR.  THE TRAILING
PARAMETER IS A POINTER TO A BYTE TABLE OF DIAGNOSTIC FUNCTIONS
AND BIT NUMBERS TO BE TESTED.  THE END OF THE TABLE IS DESIGNATED
BY SETTING BIT 7 OF THE LAST BYTE.  R0 MUST POINT TO THE ERROR
STACK FORMAT ENTRY OF FORMAT TYPE FT8 OR FT9.  THE C-BIT IS SET
AND A POINTER TO THE UML TABLE IS RETURNED IN R0 IF ANY MATCH IS
FOUND:  OTHERWISE R0 IS UNCHANGED.
%
CMP.E:  MOVB    #-1,EFLAG       ;SET ALL ERRORS FLAG
        BR      CMP.G           ;
CMP.F:  CLRB    EFLAG           ;CLEAR ALL ERRORS FLAG
        
CMP.G:  MOV     R0,DIF.         ;SAVE ERROR STACK POINTER
        MOV     (R5)+,TEM.      ;GET SPEC TABLE POINTER
        REGSAV
        MOV     TEM.,R4         ;GET SPEC TABLE POINTER
        CLRB    ISOFLG          ;CLEAR UML MATCH FLAG
        CLR     ISOUML          ;CLEAR UML TABLE
        CLR     ISOUML+2        ;
        CLR     ISOUML+4        ;
        CLR     ISOUML+6        ;
1$:     MOVB    (R4)+,R0        ;GET SPEC TABLE ENTRY
        BIT     #100,R0         ;DIAG. FN. OR BIT?
        BEQ     2$              ;BIT
        MOVB    R0,DFD8         ;SAVE FUNCTION
        BR      1$              ;GET BIT
2$:     BIC     #177600,R0      ;CLEAR END BIT
        CLRB    FT8DUN         ;CLEAR ERROR STACK DONE FLAG
        MOV     DIF.,R5         ;GET ERROR STACK POINTER
        CLR     FT9FLG          ;
        CMP     (R5)+,#FT8      ;FORMAT TYPE 8?
        BEQ     3$              ;YES
        MOV     #2,FT9FLG       ;
        CMP     -2(R5),#FT9     ;FORMAT TYPE 9?
        BEQ     3$              ;YES
        FATAL                   ;IMPROPER FORMAT



;SEQ258

3$:     MOV     FT9FLG,R1       ;GET FORMAT FLAG
        JSR     PC,@TSTERS(R1)  ;COMPARE AN ERROR STACK ENTRY
        BNE     4$              ;NO MATCH FOUND
        MOVB    FT8DF,R0        ;GET DIAGNOSTIC FUNCTION
        MOVB    R0,ISOFLG       ;SET UML FLAG
        SR      R0,2            ;DIVIDE DIAG. FN. BY 8


        BIC     #177761,R0      ;
        MOV     R0,DFD8         ;SAVE FOR SBOARD
        JSR     R5,SBOARD       ;SET PROPER BIT IN UML TABLE
                ISOUML          ;
        TSTB    EFLAG           ;ALL ERRORS?
        BNE     5$              ;YES, CONTINUE SCAN
        BR      6$              ;NO, CLEANUP & RETURN
4$:     TSTB    FT8DUN          ;DONE WITH STACK?
        BEQ     3$              ;NO, NEXT STACK ENTRY
5$:     TSTB    -1(R4)          ;DONE WITH SPEC TABLE?
        BPL     1$              ;NO, TRY NEXT
6$:     REGRST
        TSTB    ISOFLG          ;ANY FOUND?
        BEQ     7$              ;NO
        MOV     #ISOUML,R0      ;POINT TO UML TABLE
        SEC                     ;YES, SET C-BIT
7$:     RTS     R5              ;RETURN


;SEQ259

        ;COMPARE A FORMAT TYPE 8 ENTRY

ERSFT8: JSR     PC,GNSCT        ;GET ENTRY FROM ERROR STACK
        CMPB    DFD8,FT8DF      ;THIS DIAGNOSTIC  FUNCTION?
        BNE     6$              ;NO, RETURN
1$:     BITB    R3,(R1)         ;TEST EXPECTED = ACTUAL
        BEQ     2$
        BITB    R3,(R2)         ;
        BEQ     3$              ;NO, ERROR FOUND
        BR      4$              ;YES, MOVE ON
2$:     BITB    R3,(R2)         ;
        BEQ     4$              ;YES, MOVE ON
3$:     CMPB    R0,F8BTF        ;THIS BIT?
        BEQ     6$              ;YES, RETURN
4$:     ASR     R3              ;NEXT BIT
        BNE     5$              ;DONE WITH BYTE?
        BISB    #200,R3         ;YES, START NEXT
        DEC     R1              ;
        DEC     R2              ;
5$:     INC     F8BTF           ;INCREMENT BIT #
        CMPB    F8BTF,F8BTL    ;LAST BIT DONE?
        BLE     1$              ;NO, KEEP ON A PLUGGIN
6$:     RTS     PC              ;RETURN


        ;COMPARE A FT9 ENTRY

ERSFT9: MOVB    (R5)+,FT8DF     ;GET DIAG FN.
        BPL     1$              ;MAKE IT POSITIVE
        NEGB    FT8DF           ;
1$:     MOVB    (R5)+,F8BTF     ;GET BIT
        BMI     2$              ;DONE?
        INCB    FT8DUN          ;YES, SET FLAG & DO COMPARE
        BR      3$              ;
2$:     BICB    #BIT7,F8BTF     ;NO, CLEAR FLAG BIT
3$:     CMPB    DFD8,FT8DF      ;THIS DIAG FN.?
        BNE     4$              ;NO, RETURN
        CMPB    R0,F8BTF        ;COMPARE BITS
4$:     RTS     PC              ;RETURN

TSTERS:         ERSFT8          ;ENTRY POINT FOR FT8
                ERSFT9          ;ENTRY POINT FOR FT9
ISOFLG: .BYTE   0               ;UML TABLE SET FLAG
EFLAG:  .BYTE   0               ;ALL ERRORS FLAG
FT9FLG: .WORD   0               ;SET FOR FT9

DFSAVE: .WORD   0               ;LAST DIAG FN

ISOUML: .WORD   0,0,0,0         ;UML TABLE


;SEQ467


.SBTTL          MEMORY MODULE ADDRESS TEST SUBROUTINE
.REM    %
MEMADR - ROUTINE TO ADDRESS TEST A MEMORY MODULE.  THE FIRST
PARAMETER IS A POINTER TO THE MODULE LOCATION IN THE PHYSICAL
ADDRESS SPACE.  THE SECOND PARAMETER POINTS TO THE MODULE TYPE.
THE MEMORY MUST BE CONFIGURED ONE-WAY FOR PROPER TESTING. THE
MODULE TYPE NUMBERS DEFINED ARE AS FOLLOWS:

        0 - ME10        4K
        1 - MF10        8K
        2 - MG10        16K
        3 - MA20        16K
        4 - MH10        32K
        5 - MB20        32K
%
MEMADR: MOV     (R5)+,R0        ;GET BASE ADDRESS POINTER
        MOV     @(R5)+,MODTYP   ;GET TYPE #
        JSR     R5,SAV.5        ;SAVE R1 - R5
        MOV     MODTYP,R1       ;TYPE # TO R1
        BIC     #BIT0,R1        ;MAKE IT EVEN
        TST     MODTYP          ;4K SENSE?
        BEQ     1$              ;YES
        INC     R1              ;NO, ADD 2
        INC     R1
1$:     MOV     R1,MODIND       ;SAVE MODULE TYPE INDEX
        MOV     SIZPRM(R1),R1   ;SET MODULE MAX ADDRESS
        MOVB    (R0)+,MEMBAS    ;SAVE S.A. LOWER
        MOVB    (R0)+,MEMBAS+1  ;
        MOVB    (R0),ADRA+2     ;PUT UPPER IN ADR A
        MOVB    (R0),ADRB+2     ;PUT UPPER IN ADR B
        BNE     2$              ;
        TST     MEMBAS          ;BASE AT ADDRESS 0?
        BNE     2$              ;NO
        MOVB    #20,STADR       ;YES, STARTING ADR = 20
2$:     LOAD    1,ADRTST,14     ;LOAD TEST PROGRAM IN ACS
        BCC     ADRBIT          ;LOAD OK?
        ERRORA  LODERR          ;NO, ABORT


;SEQ468


        ;TEST BASIC ADDRESS BITS BY CHECKING EACH BIT AGAINST ALL
;OTHERS.

ADRBIT: MOV     #BITTBL,R2      ;POINT TO A TABLE OF BITS
1$:     MOV     (R2)+,R0        ;ADDRESS A STARTS AT 0
        CMP     R0,#20          ;ADDRESS LESS THAN 20?
        BHIS    2$              ;NO
        BISB    STADR,R0                ;YES, SET START IF ANY
2$:     BIS     MEMBAS,R0       ;PUT IN MEMORY BASE
        MOV     R0,ADRA         ;
        DPOST                   ;DEPOSIT IN AC15
                15,ADRA         ;
        MOV     #BITTBL,R3       ;POINT TO TABLE OF BITS
3$:     MOV     (R3)+,R0        ;ADDRESS B STARTS AT 0
        CMP     R0,#20          ;ADDRESS LESS THAN 20?
        BHIS    4$              ;NO
        BISB    STADR,R0        ;SET START IF ANY
4$:     BIS     MEMBAS,R0       ;PUT IN MEMORY BASE
        MOV     R0,ADRB         ;
        DPOST                   ;DEPOSIT IN AC16
                16,ADRB         ;
        RUN     1               ;TEST AN ADDRESS PAIR
        BCS     ADRERR          ;FAILS
        CMP     (R3),R1         ;LAST ADDRESS B CHECKED?
        BLO     3$              ;NO, TEST NEW ADR B
        CMP     (R2),R1 ;LAST ADDRESS A CHECKED?
        BLO     1$              ;NO, TEST NEXT ADR A


;SEQ469

        ;SINCE NO BASIC BIT PROBLEMS HAVE BEEN FOUND, THE PROGRAM
;PROCEEDS TO CHECK X,Y DRIVE DECODING BY TETING FOR INTER-
;FERENCE BETWEEN ALL COMBINATIONS OF ADDRES PAIRS FOR EACH
;DECODER.

XYDRV:  CLR     R3              ;R3 IS DECODE GROUP INDEX
1$:     MOV     INCTAB(R3),R4   ;R4 IS GROUP ADDRESS INCREMENT
        MOV     XYMAX(R3),R5    ;GET MAX ADR TABLE POINTER
        ADD     MODIND,R5       ;
        MOV     (R5),R5         ;R5 IS GROUP MAX ADDRESS
        MOVB    STADR,R1        ;R1 IS WORKING ADDRESS A
        
2$:     MOV     R1,R0           ;
        JSR     PC,@XYMOD(R3)   ;GO MODIFY WORKING ADDRESS A
        MOV     R0,ADRA         ;
        DPOST                   ;DEPOSIT ADDRESS A IN AC15
                15,ADRA         ;
        MOVB    STADR,R2                ;R2 IS WORKING ADDRESS B
3$:     MOV     R2,R0           ;
        JSR     PC,@XYMOD(R3)   ;GO MODIFY WORKING ADDRESS B
        MOV     R0,ADRB         ;
        DPOST                   ;;DEPOSIT ADDRESS B IN AC16
                16,ADRB ;
        RUN     1               ;RUN THE TEST PROGRAM
        BCS     ADRERR          ;FAILS
        ADD     R4,R2           ;NEXT ADDRESS B
        CMP     R2,R5           ;MAX ADR DONE?
        BLOS    3$              ;NO, LOOP ON B
        ADD     R4,R1           ;NEXT ADDRESS A
        CMP     R1,R5           ;MAX ADR DONE?
        BLOS    2$              ;NO, LOOP ON A
        INC     R3              ;NEXT DECODE GROUP
        INC     R3              ;
        CMP     R3,#6           ;LAST ONE DONE?
        BLE     1$              ;NO, DO NEXT
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;TEST PASSES, RETURN


;SEQ470

        ;HERE IF FAULT DETECTED

ADRERR: ERRMSG  <WRITING MEMORY ADDRESS >

        BICB    #100,ADRB+2     ;CLEAR VIRTAL ADDRESS BIT
        MOV     #ADRB,R0        ;ADDRESS B TO ERROR STACK
        ERRADR
        ERRMSG  < DISTURBS ADDRESS >
        BICB    #100,ADRB+2     ;CLEAR VIRTUAL ADDRESS BIT
        MOV     #ADRA,R0        ;
        ERRADR                  ;ADDRESS A TO ERROR STACK
        ERRMSG  <\DIFFERENCE IS >
        EXAMT                   ;GO GET RESULT FROM AC0
                0,ERRAC0        ;
        MOV     #ERRAC0,R0      ;
        ERRDAT                  ;AC0 TO ERROR STACK
        JSR     R5,RST.5        ;RESTORE R1-R5
        SEC                     ;SET C-BIT ERROR FLAG
        RTS     R5              ;TEST FAILS, RETURN

        ;PROGRAM VARIABLES

MODTYP: .BYTE   0               ;MODULE TYPE CODE
STADR:  .BYTE   0               ;LOGICAL STARTING ADDRESS
MEMBAS: .WORD   0               ;BASE ADDRESS OF MODULE
        
MODIND: .WORD   0               ;MODULE TYPE INDEX
ADRA:   .WORD   0,0,0           ;ADDRESS A
ADRB:   .WORD   0,0,0   ;ADDRESS B
ERRAC0: .WORD    0,0,0           ;ERROR BITS IF ANY


;SEQ471
        ;PROGRAM TO TEST FOR ADDRESS INTERFERENCE BETWEEN TWO
        ;MEMORY LOCATIONS.  THE TWO ADDRESSES ARE DEPOSITED IN
        ;AC15 & AC16.  THE PROGRAM LOOPS ON ERROR & HALTS IF NO
        ;ERROR.  IT IS AS FOLLOWS:
;       0:                      ;DIFFERENCE IF ERROR
;       1:      CAMN    AC15,16         ;ADDRESS A = ADDRESS B?
;       2:      JRST,4  1                       ;HALT TEST PASSES
;       3:      SETZM   0               ;CLEAR ERROR FLAG
;       4:      SETZM   0(AC15)         ;ZEROS TO LOCATION A
;       5:      MOVE    AC17,0(AC15)    ;READ LOCATION A
;       6:      MOVE    AC17,0(AC15)    ;AGAIN TO FILTER INHIBITS
;       7:      SETOM   0(AC16)         ;ALL 1S TO LOCATION B
;       10:     JUMPN   AC0,4           ;LOOP IF ERROR FLAG SET
;       11:     XOR     AC17,0(AC15)    ;DID LOCATION A CHANGE?
;       12:     JUMPE   AC17,2          ;NO, DO THE HALT
;       13:     MOVE    AC0,17          ;YES, SET ERROR FLAG
;       14:     JUMPA   4               ;LOOP
;       15:             0               ;ADDRESS A GOES HERE
;       16:             0               ;ADDRESS B GOES HERE

ADRTST: I10     CAMN,AC16,,15           ;1
        I10     JRST,4,,1               ;2
        I10     SETZM,,,0               ;3
        I10     SETZM,,,0,AC15          ;4
        I10     MOVE,AC17,,0,AC15       ;5
        I10     MOVE,AC17,,0,AC15       ;6
        I10     SETOM,,,0,AC16  ;7
        I10     JUMPN,AC0,,4            ;10
        I10     XOR,AC17,,0,AC15        ;11
        I10     JUMPE,AC17,,2           ;12
        I10     MOVE,AC0,,17            ;13
        I10     JUMPA,,,4               ;14


;SEQ472


        .EVEN
        ;TABLE OF Y LOWER GROUP MAXIMUM ADDRESSES

YLOMAX:         7               ;4K
                7               ;8K
                7               ;16K
                7               ;32K

        ;TABLE OF Y UPPER GROUP MAXIMUM ADDRESSES

YHIMAX:         70              ;4K
                70              ;8K
                170             ;16K - UPPER BIT = 22
                170             ;32K - UPPER BIT = 22

        ;TABLE OF X LOWER GROUP MAXIMUM ADDRESSES

XLOMAX:         700             ;4K
                700             ;8K
                700             ;16K
        1700                    ;32K - UPPER BIT = 21

        ;TABLE OF X UPPER GROUP MAXIMUM ADDRESSES

XHIMAX:         7000            ;4K
                17000           ;8K
                17000           ;16K
        17000           ;32K

        ;TABLE OF MODULE MAX ADDRESSES

SIZPRM:         7777            ;4K
                17777           ;8K
                37777           ;16K
                77777           ;32K


;SEQ473


        ;TABLE OF BASIC ADDRESS INCREMENTS;

INCTAB:         1       ;Y LOWER
                10      ;Y UPPER

                100     ;X UPPER
                1000    ;X UPPER

        ;POINTERS TO GROUP MAXIMUM ADDRESS TABLES

XYMAX:          YLOMAX  ;Y LOWER
        YHIMAX          ;Y UPPER
                XLOMAX  ;X LOWER

                XHIMAX  ;X UPPER

        ;ENTRY POINT TABLE FOR ADDRESS MODIFICATION

XYMOD:          YLOMOD          ;Y LOWER
        YHIMOD          ;Y UPPER
                XLOMOD  ;X LOWER
                BASMOD          ;X UPPER

        ;ADDRESS MODIFICATION SUBROUTINES

YLOMOD: PUSH    R1

        MOV     MODIND,R1       ;GET MODULE TYPE INDEX
        JMP     @MODYLO(R1)     ;DISPATCH AS FOLLOWS:

MODYLO:         MODBAS          ;4K - BASE ONLY
                MODBAS          ;8K - BASE ONLY
        EX3233                  ;16K - SWAP 32/33
                MODBAS          ;32K -B ASE ONLY

YHIMOD: PUSH    R1

        MOV     MODIND,R1       ;GET MODULE TYPE INDEX
        JMP     @MODYHI(R1)     ;DISPATCH AS FOLLOWS:

MODYHI:         MODBAS          ;4K - BASE ONLY
        MODBAS          ;8K - BASE ONLY
        EX2233          ;16K - SWAP 22/29 & 32/33
                EX2229          ;32K - SWAP 22/29

XLOMOD: PUSH    R1
        MOV     MODIND,R1       ;GET MODULE TYUPE INDEX
        JMP     @MODXLO(R1)     ;DISPATCH AS FOLLOWS:

MODXLO:         MODBAS          ;4K - BASE ONLY
                MODBAS          ;8K - BASE ONLY
                MODBAS          ;16K - BASE ONLY
                EX2126          ;32K - SWAP 21/26


;SEQ474

        ;BIT 26 IN WORKING ADDRESS IS ACTUALLY BIT 21

EX2126: JSR     R5,BITSWP       ;GO SWAP BITS
                BIT14           ;10 BIT 21
                BIT9            ;10 BIT 26
        BR      MODBAS          ;FUDGE BASE

        ;BIT 29 IN WORKING ADDRESS IS ACTUALLY BIT 22

EX2229: JSR     R5,BITSWP               ;GO SWAP BITS
                BIT13           ;10 BIT 22
                BIT6            ;10 BIT 29
        BR      MODBAS          ;FUDGE BASE

        ;BIT 29 IS REALLY 22 & 32/33 ARE REVERSED

EX2233: JSR     R5,BITSWP       ;GO SWAP BITS
                BIT13           ;10 BIT 22
                BIT6            ;10 BIT 29

        ;DECODERS HAVE 32 & 33 SWAPPED

EX3233: JSR     R5,BITSWP               ;GO SWAP BITS
                BIT3            ;10 BIT 32
                BIT2            ;10 BIT 33

        ;BASE ADDRESS FUDGE

MODBAS: POP     R1

BASMOD: BIS     MEMBAS,R0               ;SET BASE IN ADDRESS
        RTS     PC              ;END OF ENTIRE SUBROUTINE
        ;SUBROUTINE TO INTERCHANGE TWO BITS IN A DATA WORD.  THE
        ;VALUE TO BE MODIFIED IS IN R0, & THE BITS TO SWAP ARE
        ;PASSED AS TRAILING PARAMETERS.


BITSWP: BIT     (R5)+,R0        ;TEST 1ST BIT
        BEQ     1$              ;BRANCH IF CLEAR
        BIT     (R5)+,R0        ;TEST 2NSD
        BNE     2$              ;BOTH SET, NO CHANGE
        BIC     -4(R5),R0       ;1ST SET, CLEAR IT
        BIS     -2(R5),R0       ;2ND CLEAR SET IT
        RTS     R5              ;RETURN

1$:     BIT     (R5)+,R0        ;TEST 2ND
        BEQ     2$              ;BOTH CLEAR, NO CHANGE
        BIS     -4(R5),R0       ;1ST CLEAR, SET IT
        BIC     -2(R5),R0       ;2ND SET, CLEAR IT
2$:     RTS     R5              ;RETURN



.SBTTL  MBOX UTILITY SUBROUTINE LIBRARY

.REM    %
INITM - ROUTINE TO INITIALIZE TABLES FOR MSUB.
%
INITM:
        MOV     #$TRAP,34       ;SET TRAP VECTOR
        DTEBAS                  ;GET DTE 20 BASE ADDRESS
        MOV     #BASE20,R1      ;
1$:     MOV     R0,(R1)+        ;POINTERS TO TABLE
        INC     R0              ;
        INC     R0              ;
        CMP     R1,#.DAT1       ;DONE?
        BLOS    1$              ;NO, LOOP AGAIN
        MOV     #SSCLK,CLKTYP   ;SET CLOCK TYPE TO MBOX
        MOV     #BASE20-$FLAGS-2,R0     ;# OF FLAGS-2 * 2
2$:     CLR     @$FLAGS(R0)     ;CLEAR A FLAG
        DEC     R0              ;
        DEC     R0              ;
        BGE     2$              ;ALL CLEARED?
        RTS     R5              ;YES, RETURN
$FLAGS: .WORD   $RUNFL          ;FLAGS TO CLEAR
        .WORD   CRAFLG          ;DIAG CRAM ADDR TO USE
        .WORD   MEMFLG          ;NO FORCE SBUS RESET
        .WORD   CSHFLG          ;NO SET CACHE LOOK & LOAD
        .WORD   PMAFLG          ;NO FORCE PMA TO ERG
        .WORD   EXTFLG          ;NO FORCE EXTEND
        .WORD   CHFLAG          ;NO CHANNEL REST
        .WORD   CLKFLG          ;NO CLOCK STOP CONDITIONS

BASE20: .WORD   174400          ;DTE BASE ADDRESS
.DAT3:  .WORD   174402          ;POINTER TO DEXWD3
.DAT2:  .WORD   174404          ;POINTER TO DEXWD2
.DAT1:  .WORD   174406          ;POINTER TO DEXWD1

LODERR: .ASCIZ  %AC LOAD ERROR\%
        .EVEN

ZERO..: .WORD   0,0,0            ;A 36-BIT ZERO CONSTANT
REVNUM: .BYTE   0               ;HARDWARE REV LEVEL INSERTED
VERNUM: .BYTE   1               ;PROGRAM VERSION INSERTED
CSHNBR:         0               ;OTHER COMMON DATA & VARIABLES
SCRWD:          0               ;SCRATCH WORD
SVERSP:         0
ERBIT:  .WORD   0               ;LAST KL BIT TESTED BY TBIT
ADRL:   .WORD   0               ;BUFFER LOCATION FOR ADDRESSES
ADRH:   .WORD   0,0             ;


;SEQ263

.REM    %
GETVER - SUBROUTINE TO CHECK FOR PROGRAM VERSION AND SOLICIT ONE
IF NOT PRESENT.
%
GETVER: TST     REVNUM          ;VERSION SET?
        BNE     4$              ;YES, RETURN
1$:     PMSG    <HARDWARE REV: _>

        TTILIN                  ;GET REPLY
        BCC     2$              ;GOT ONE
        COM     REVNUM          ;TIMEOUT, SET REV TO -1
        PCRLF                   ;FINISH LINE
        BR      4$              ;RETURN
2$:     TTIDEC          ;
        BCS     1$      ;GARBAGE REPLY
        MOVB    R0,REVNUM       ;SAVE REV LEVEL
3$:     PMSG    <VERSION: _>

        TTILNW          ;WAIT FOR REPLY
        TTIDEC          ;
        BCS     3$      ;GARBAGE REPLY
        MOVB    R0,VERNUM       ;SAVE VERSION
4$:     RTS     R5


.REM    %
PNTVER - SUBROUTINE TO PRINT PROGRAM VERSION IF SET
%
PNTVER: TST     REVNUM          ;VERSION SET?
        BEQ     1$              ;NO, RETURN
        BMI     1$              ;NEGATIVE, RETURN
        PMSG    < VER >

        MOVB    VERNUM,R0       ;GET PROGRAM VERSION
        PNTDEC                  ;PRINT IT
        MOVB    REVNUM,R0       ;GET HARDWARE LEVEL
        PNTDEC                  ;PRINT IT
        PNTBAK                  ;DISCARD PERIOD
1$:     RTS     R5              ;RETURN

.SBTTL          PROGRAM PATCHER JAB29857        09-SEP-76  EDIT#11

;-----THIS IS A SMALL SUBROUTINE TO AID IN THE PATCHING OF PROGRAM.
;       IT IS STARTED VIA A KLDCP 'SE<ADR>' COMMAND.  FIRST IT ASKS FOR
;       ADDITIONS TO THE PATCH AREA, THEREAFTER IT REQUESTS AN ADR.
;       ANY NON-NUMERIC INPUT TERMINATES THE CURRENT ADR CHAIN.
$PATCH: JSR     R5,PATCH        ;<START HERE FOR SE<ADR> TYPE START>
        PRGHLT
        BR      $PATCH          ;LOOP ON 'HC' COMMAND
PATCH:  MOV     #$$FF,R3        ;PTR SAVES A WORD
        MOV     (R3),R1         ;POINT THE ADR REG AT THE PATCH AREA
        CLR     R2              ;IND ERR MSG NOT SENT
        INC     R1              ;MAKE SURE IT'S AN EVEN ADR
        BR      10$             ; (BR TO BIC SAVES A WORD)
1$:     CMP     R1,#70000       ;IN OVERLAY AREA?
        BLO     2$              ;BR IF NO
        TST     R2              ;HAVE WE SENT MESSAGE?
        BNE     2$              ;BR IF YES...DONT RESEND IT
        PMSG    <WARNING: IN OVERLAY AREA\>

        INC     R2              ;INDICATE ERR MSG SENT
2$:     MOV     R1,R0           ;GET & PRINT <ADR>/<CONTENTS>
        PNTOCT,PNTBAK,PSLASH
        MOV     (R1),R0
        PNTOCT
        PMSG    <   _>

        JSR     R5,7$           ;GO TO INPUT SUBROUTINE
        BCS     4$              ;BR ON NON-NUMBER...END OF INPUT
3$:     MOV     R0,(R1)+        ;PUT DATA IN MEMORY
        CMP     R1,(R3)         ;SHD WE SAV UPDATED ADR?
        BLOS    1$              ;NO
        MOV     R1,(R3)         ;SAV UPDATED ADR
        BR      1$              ;LOOP FOR NEXT DATA WORD
4$:     CLR     R2              ;INDICATE MUST REPRINT ERR MSG IF NEC.
        PMSG    <ADDRESS: _>

        JSR     R5,7$           ;GO TO INPUT SUBROUTINE
        BCS     9$              ;BR ON NON-NUMBER...END OF INPUT
5$:     MOV     R0,R1           ;MOVE ADR TO ADR REG
10$:    BIC     #BIT0,R1        ;FORCE TO EVEN ADR
        BR      1$              ;GO GET DATA INPUT
8$:     PMSG    <?\>            ;PRINT ERR INDICATOR

7$:     TTILNW,TTISDL           ;WAIT FOR INPUT, BYPASS JUNK
        BCS     9$              ;BR ON NO INPUT
        TTIOCT                  ;GET NUMBER
        BCS     8$              ;BR ON BAD #
9$:     RTS     R5              ;RETURN



;SEQ264

.SBTTL          RESET SUBROUTINES
.REM    %
        ROUTINES TO RESET MEM CONTROLLERS & MBOX.  DOES A MASTER
RESETS & SETS THE MICRO CODE STARTING ADDRESS.  ISSUES 1 MBOX
CLOCK AFTER CLEARING MR.  THE SETTING OF ONE OR MORE FLAGS MAY CAUSE 
THIS SUBROUTINE TO PERFORM MORE THAN THE BASIC FUNCTIONS:
        CLKFLG = SET CLOCK STOP CONDITIONS
                BIT 0 = FS PROBE
                BIT 1 = DRAM PARITY
                BIT 2 = CRAM PARITY
                BIT 3 = FM PARITY
        CRAFLG = SET DIAG CRAM ADDR TO VALUE
        CSHFLG = SET LOOK & LOAD & CLEAR THE EBR
        PMAFLG = FORCE PMA TO EBUS REG
        MEMFLG = INHIBIT MEMORY CONTROLLER TIMING
        EXTFLG = SET FORCE EXTEND
        CHFLAG = PERFORM AT LEAST 35 CLOCKS FOR CHANNEL RESET
%
MEMRST: DFWRTT                  ;RESET MEMORY CONTROLLERS
                KLB24           ;
                76              ;
RSTMBX: MOV     R5,BRKPC        ;SAVE PC
        JSR     PC,SPCRST       ;DO SPECIAL RESET SUBROUTINE
CSHSET: TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO
        MOV     #CSHALW,R0      ;SET CACHE LOOK & LOAD
        JSR     R5,XQT1         ;CONTROLLED EXCT
1$:     RTS     R5              ;RETURN

MEMFLG: .WORD   0               ;INHIBIT MEM CONTROLLER TIMING
CSHFLG: .WORD   0               ;CACHE ENABLE FLAG
PMAFLG: .WORD   0               ;PMA TO ERG ENABLE FLAG
EXTFLG: .WORD   0               ;FORCE EXTEND FLAG - FUNCTIONS ON
                                ;MODEL B PROCESSOR ONLY
CHFLAG: .WORD   0               ;CHANNEL RESET FLAG
CLKFLG: .WORD   0               ;SET INDICATED CLK STOP CONDITION
CRAFLG: .WORD   0               ;VALUE FOR DIAG CRAM ADDR
RSTWD:  .WORD   0               ;RESET CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CLKWD:  .WORD   0               ;CLOCK STOP CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CSHALW: IO10    CONO PAG,,600000


KLB24:  WD36    0,0,4000


KLB35:  WD36    0,0,1


        .EVEN


;SEQ266

SPCRST: MOV     CRAFLG,R0       ;GET VALUE FOR DIAG CRAM ADDR
        WWADR                   ;MR RESET/ LOAD CRAM ADDR
        CLR     R0              ;CLEAR FN 76 BITS
        TST     MEMFLG          ;FORCE SBUS RESET?
        BEQ     1$              ;NO
        BIS     #BIT11,R0       ;YES,SET BIT FOR FN 76
1$:     TST     PMAFLG          ;SET PMA TO ERG?
        BEQ     2$              ;NO
        BIS     #BIT9,R0        ;YES, SET BIT FOR FN 76
2$:     TST     EXTFLG          ;FORCE EXTEND?
        BEQ     22$             ;NO
        BIS     #BIT8,R0        ;YES, SET BIT FOR FN 76
22$:    MOV     R0,RSTWD        ;PUT BITS IN FUNCTION
        DFWRTT                  ;DO ANY SPECIAL CONTROL
                RSTWD           ;BITS SET UP
                76              ;FUNCTION CODE
        DFSCLK                  ;STEP THE CLOCK
        MOV     CLKFLG,CLKWD    ;GET CLK ERROR STOP CONDITIONS
        BEQ     3$              ;NONE
        DFWRTT                  ;ENABLE CONDITIONS
       
                CLKWD           ;CONDITIONS
                46              ;FUNCTION CODE
        DFWRTT                  ;ENABLE CLOCK STOP
                KLB35           ;
                47              ;
3$:     TST     CHFLAG          ;RESET CHANNELS TOO?
        BEQ     4$              ;NO
        MOV     #34.,R0         ;NO
        JSR     R5,BRST1        ;YES,BUTST 34 TICKS
4$:     RTS     PC              ;RETURN


;SEQ267

.SBTTL          REGISTER SAVE & RESTORE ROUTINES

;ROUTINE TO SAVE R3-R5
;
SAV.3:  PUSH    R4

        PUSH    R3

        PUSH    4(SP)

        RTS     R5              ;STACK HAS R5,R4,R3


;RESTORE R3-R5
;
RST.3:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R3

        POP     R4

        RTS     R5

;ROUTINE TO SAVE R1-R5
;
SAV.5:  PUSH    R4

        PUSH    R3

        PUSH    R2

        PUSH    R1
   
        PUSH    10(SP)

        RTS     R5      ;STACK HAS R5,R4,R3,R2,R1

;RESTORE        R1-R5
;
RST.5:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R1

        POP     R2

        POP     R3

        POP     R4

        RTS     R5

.SBTTL          ROUTINE TO CHANGE THE CURRENT AC BLOCK

.REM    %
        SUBROUTINE ACBLK SETS THE CURRENT AC BLOCK NUMBER ACCORDING TO
        THE VALUE IN R0 WITHOUT USING AN AC OR MEMORY.  PREVIOUS AC
        BLOCK NUMBER IS SET TO ZERO.
%

ACBLK:  MOV     R5,BRKPC        ;FOR FUNC BREAKPOINT
ACBLK1: BIC     #177770,R0      ;SHUT OF JUNK BITS
        SL      R0,3            ;POSITION



        MOVB    R0,2$+3         ;AC BLK # TO WORD
        STEXCT   1$              ;START DATAO PAG
        MOV     #18.,R0         ;BURST COUNT
        JSR     R5,BRST1        ;SKIP SOME TICKS TO SAVE TIME
        JSR     R5,FIND1        ;TICK UNTIL AR LOADED (WITH GARBAGE)
        S10.    132,23,1        ;"CON AR LOADED H"
        BCS     3$              ;ERR IF NOT FOUND
        DFXCTT,CECLK            ;BRING EBOX CLOCK DOWN
        DFWRTT,2$,LDAR          ;PUT THE DATA WE REALLY WANT IN THE AR
        DFXCTT,STRCLK           ;RESTART THE CLOCK TO FINISH UP
3$:     RTS     R5              ;DONE...RETURN
1$:     IO10    DATAO,PAG,,0    ;INSTR TO SET AC BLOCK NUMBER

2$:     WD36    4000,0040,0000  ;WD USED BY THE ABOVE


        .EVEN



;SEQ268


.SBTTL          PROGRAM RUN ROUTINES

        ;ROUTINES TO START & RUN A KL10 PROGRAM.  ALL PROGRAMS
        ;ARE EXPECTED TO END WITH A HALT.  A WATCHDOG TIMER IS
        ;USED TO RETURN WITH THE C-BIT SET IF NO HALT OCCURS
        ;WITHIN THE TIME INTERVAL SPECIFIED.  INTERVALS ARE IN
        ;INCREMENTS OF 30MS.  IF A FUNCTION BREAKPOINT IS ACTIVE,
        ;THE TIMEOUT IS PERFORMED BY COUNTING CLOCK TICKS OF THE
        ;MBOX CLOCK, OTHERWISE THE PDP-11 LINE-FREQUENCY CLOCK
        ;IS USED.

.REM    %
        
RUNPRG - RUNS A KL PROGRAM STARTING AT THE GIVEN ADDRESS 0-177777
AND WAITS FOR EITHER A HALT OR A TIMEOUT.
%
RUNPRG: MOV     R5,BRKPC        ;SAVE PC
RUNPR1: MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
        MOV     #2,TIMINT       ;SET TIME INTERVAL OF 2 16MS
RUNPR2: MOV     #RUNJRS,R0      ;POINT AT JRST
        JSR     R5,XQT1         ;DO JRST
        BR      CON2            ;CONTINUE
        
.REM    %
RUNBIG - RUN A PROGRAM WHICH TAKES MORE THAN 30 MILLISECONDS.
CALLING FORMAT:
        JSR     R5,RUNBIG
        ENTRY+2 = # OF 30 MS INTERVALS FOR TIMEOUT
        ENTRY+4 = STARTING ADDRESS (0-177777)
%
RUNBIG: MOV     R5,BRKPC        ;SAVE PC
RUNBG1: MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
RUNBG2: ASL     TIMINT          ;USE TWICE INTERVAL PARAMETER
        BR      RUNPR2          ;EXECUTE JRST & CONTINUE

.REM    %
        WAIT THE INTERVAL SPECIFIED FOR THE PROCESSOR TO HALT.
%
HWAIT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        BR      CON3            ;WAIT FOR HALT OR TIMEOUT

LOOPK:  .WORD   0               ;#OF TIMEOUT LOOPS
TIMINT: .WORD   0               ;# OF TIMEOUT INTERVALS

RUNJRS: I10     JRST    0,,0


        .EVEN


;SEQ270

.REM    %
        CONTIN - STARTS THE KL RUNNING.  SETS THE C-BIT IF NO HALT WITHIN
        THE TIMING INTERVAL SPECIFIED.
%
CONTIN: MOV     R5,BRKPC        ;SAVE PC
CON1:   MOV     #2,TIMINT       ;SET TIMING = 30 MS
CON2:   DFXCTT                  ;SET RUN FLOP
                SETRUN          ;
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
CON3:   TST     FNBRK           ;FUNCTION BREAK ACTIVE?
        BNE     5$              ;YES, USE SINGLE PULSES
        CLKPRM                 ;GET CLOCK RATE
        MOV     (R0),R0         ;
        BIC     #177774,R0      ;
1$:     DEC     R0              ;MULTIPLY INTERVAL BY RATE
        BMI     2$              ;
        ASL     TIMINT          ;
        BR      1$                      ;
2$:     INC     TIMINT          ;ADD ONE
        MOV     BASE20,R0       ;GET DTE20 BASE
3$:     CLR     KWLKS           ;CLEAR 11 CLOCK
4$:     BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES,RETURN
        TST     KWLKS           ;CLOCK TICKED?
        BEQ     4$              ;NO TEST KL AGAIN
        DEC     TIMINT          ;TIMEOUT COMPLETE?
        BGT     3$              ;NO WAIT ANOTHER 16MS (MIN)
        BR      9$              ;YES TIMEOUT
5$:     MOV     #7,R0           ;GET OUT OF HALT LOOP
        JSR     R5,BRST1        ;
6$:     MOV     #1000.,STEPK    ;COUNT 50,000 TICKS
7$:     MOV     #50.,LOOPK      ;
8$:     JSR     R5,STEP1        ;SINGLE PULSE
        MOV     BASE20,R0       ;GET DTE20 BASE
        BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES, RETURN
        DEC     LOOPK           ;DECREMENT COUNTERS
        BGT     8$              ;
        DEC     STEPK           ;
        BGT     7$              ;UNTIL DONE
        DEC     TIMINT          ;DECREMENT INTERVAL COUNT
        BGT     6$              ;
9$:     TST     CLKFLG          ;CLK STOP ENABLED?
        BEQ     10$             ;NO,JUST ERROR RETURN
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERR STOP?
        BEQ     10$             ;NO, RUN TIMEOUT
        JMP     CLKERR          ;GO TO CLK ERROR POINT
10$:    SEC                     ;SET ERROR FLAG
        BR      12$             ;
11$:    CLC                     ;KL HALTED (NORMAL)
12$:    RTS     R5              ;RETURN

;SEQ271

.SBTTL          MBOX CLOCK CONTROL ROUTINES
.REM    %
FIND - STEPS THE CLOCK UNTIL AN EVENT LEADING EDGE IS FOUND OR
4092 CLOCKS HAVE BEEN ISSUED.  RETURNS THE CLOCK COUNT IN R0 &
SETS THE C-BIT IF TIMEOUT.
%
FIND:   MOV     R5,BRKPC        ;SAVE PC
FIND1:  MOV     (R5)+,R0        ;PARAMETERS TO R0
FIND2:  JSR     R5,SAV.5        ;SAVE R1-R5
        MOV     #1,STEPK        ;SET CLOCK COUNT = 1
        JSR     PC,EVENT2       ;TEST FOR EVENT
        BCC     2$              ;FOUND ON FIRST TICK
1$:     JSR     PC,EVENT3       ;TEST SAME EVENT AGAIN
        INC     STEPK           ;INCREMENT CLOCK COUNT
        BCC     2$              ;EVENT FOUND
        CMP     STEPK,#4092.    ;TIMEOUT?
        BLT     1$              ;NO,TRY AGAIN
        SEC                     ;YES,SET ERROR FLAG
2$:     MOV     STEPK,R0        ;CLOCK COUNT TO R0
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5      ;RETURN

STEPK:  .WORD   0               ;STEP COUNT


.REM    %
STEP10 - ROUTINE TO GET MACHINE TO KNOWN MBOX STATE WHILE
EXECUTING A PDP10 INSTRUCTION.
%
STEP10: MOV     R5,BRKPC        ;SAVE PC
STP10A: MOV     (R5)+,R0        
        LODAR                   ;GET INSTRUCTION NEATLY IN AR
        MOV     #CONBUT,R0      
        DFXCT                   ;PRESS CONTINUE BUTTON
        TST     $RUNFL          ;SHOULD I PRESS RUN, TOO?
        BEQ     STPC1           ;NO IF ZERO
        MOV     #SETRUN,R0
        DFXCT                   ;DO IT
        BR      STPC1           ;CONTINUE

.REM    %
STPCON - FINDS THE LEADING EDGE OF AN EVENT & REPLACES THE EVENT
WITH A BURST COUNT OR BURSTS THE CLOCK IF NO EVEN SPECIFIED.
%
STPCON: MOV     R5,BRKPC        ;SAVE PC
STPC1:  MOV     (R5)+,R0        ;GET THE PARAMETER
        TST     R0              ;
        BMI     1$              ;STEP IF NEGATIVE
        PUSH    R0              ;SAVE BURST COUNT

        JSR     R5,BRST1        ;BURST IF POSITIVE
        POP     R0              ;RESTORE BURST COUNT

        BR      2$              ;
1$:     JSR     R5,FIND2        ;FIND EVENT
        BCS     2$              ;ERROR, TIMEOUT
        TST     NOBRST          ;FUNCTIONAL TEST ONLY?
        BNE     2$              ;YES, DON'T SAVE BURST COUNT
        MOV     R0,-2(R5)       ;O.K., SAVE BURST
2$:     RTS     R5              ;
NOBRST: .WORD   0               ;NEVER SET BY PROGRAM
$RUNFL: .WORD   0               ;-1 MEANS SET RUN BEFORE STEP
        

;SEQ273

.SBTTL          FUNCTION BREAKPOINT & CLOCK CONTROL

        ;ROUTINE TO SET A FUNCTION BREAKPOINT.

FB..:   TTISDL                  ;DIAGNOSTIC PN SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <DIAGNOSTIC FUNCTION: _>

        TTILNW                  ;WAIT FOR REPLY
2$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;NOT OCTAL
        CMP     R0,#77          ;TOO SMALL?
        BLE     BRKERR          ;YES
        CMP     R0,#177         ;TOO BIG?
        BGT     BRKERR          ;YES
        MOVB    R0,FNBRK+1      ;SET FN IN BREAK WORD
        TTISDL                  ;BIT SPECIFIED?
        BCC     4$              ;YES, USE IT
3$:     PMSG    <BIT: _>

        TTILNW                  ;WAIT FOR REPLY
4$:     TTIDEC                  ;CONVERT DECIMAL VALUE
        BCS     BRKERR          ;NOT DECIMAL
        CMP     R0,#35.         ;TOO BIG?
        BGT     BRKERR          ;YES
        CLR     R1              ;CLEAR WORD INDEX
        SUB     #20.,R0         ;BITS 20-35?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 4-19?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 0-3
5$:     MOV     #15.,R2          ;SWAP ORDER OF SIGNIFICANCE
        SUB     R0,R2           ;
        ASL     R2              ;POSITION
        ASL     R2              ;
        BIS     R1,R2           ;SET WORD INDEX
        MOVB    R2,FNBRK        ;SET BIT IN FN BREAK
        TTISDL                  ;POLARITY SPECIFIED?
        BCC     7$              ;YES, USE IT
6$:     PMSG    <0 OR 1? _>

        TTILNW                  ;GET REPLY
7$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;GARBAGE
        TST     R0              ;
        BEQ     8$              ;
        BIS     #100,FNBRK      ;SET POLARITY = 1
8$:     JMP     @COMRET         ;NEXT COMMAND


;SEQ274

        ;ROUTINE TO CLEAR A FUNCTION BREAKPOINT.

CB..:   CLR     FNBRK           ;CLEAR IT
        CLR     SAVBRK          ;CLEAR EXEC SAVE BREAK
        JMP     @COMRET         ;NEXT COMMAND



        ;BREAKPOINT DETECTED.

BRKPNT: MOV     R0,BRKR0        ;SAVE REGISTERS
        MOV     R1,BRKR1
        MOV     R2,BRKR2
        MOV     R3,BRKR3
        MOV     R4,BRKR4
        MOV     R5,BRKR5
        MOV     SP,BRKSP
        PCRLF                   ;CARRIAGE RETURN
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <FN. BREAK AT PC >

        MOV     BRKPC,R0        ;GET SUBROUTINE PC
        SUB     #4,R0           ;
        PNTOCS                  ;PRINT IT
        PCRLF
        INC     BRKFLG          ;SET BREAKPOINT FLAG
        JMP     @COMRET         ;RETURN TO COMMAND MODE


        BRKR0:  .WORD   0       ;REGISTER STORE FOR FN. BREAK
        BRKR1:  .WORD   0
        BRKR2:  .WORD   0
        BRKR3:  .WORD   0
        BRKR4:  .WORD   0
        BRKR5:  .WORD   0
        BRKSP:  .WORD   0
        BRKPC:  .WORD   0

        COMRET: .WORD   0       ;RETURN POINT
        BRKFLG: .WORD   0       ;BREAK PERFORMED FLAG
        FNBRK:  .WORD   0       ;DIAG. FN., BIT & POLARITY
        SAVBRK: .WORD   0       ;FUNCTION BREAK SAVE


;SEQ275

        ;BREAKPOINT CONTINUE

FC..:   TST     BRKFLG          ;BREAKPOINT PERFORMED?
        BNE     BRKRST          ;YES
BRKERR: PNTCI,'?                ;PRINT ?
        JMP     @COMRET         ;RETURN TO COMMAND MODE
BRKRST: PNORML                  ;NORMAL TYPEOUTS
        MOV     BRKR0,R0        ;RESTORE REGISTERS
        MOV     BRKR1,R1
        MOV     BRKR2,R2
        MOV     BRKR3,R3
        MOV     BRKR4,R4
        MOV     BRKR5,R5
        MOV     BRKSP,SP
        CLR     BRKFLG          ;CLEAR CONTINUE
        JMP     BRKCON          ;CONTINUE FROM BREAK


        ;PRINT REGISTERS

RG..:   CLR     R1              ;REGISTER INDEX
1$:     PNTCI,'R                ;PRINT REGISTER #
        MOV     R1,R0           ;
        PNTOCS                  ;
2$:     PNTCI,'/                ;
        MOV     R1,R2           ;
        ASL     R2              ;
        MOV     BRKR0(R2),R0    ;GET CONTENTS
        PNTOCT                  ;PRINT IT
        INC     R1              ;NEXT REGISTER
        CMP     R1,#6           ;DONE?
        BLT     1$              ;NO, NEXT ONE
        BGT     3$              ;YES
        PMSG    <SP>            ;NO, STACKPOINTER

        BR      2$              ;PRINT IT
3$:     PCRLF                   ;CARRIAGE RETURN
        JMP     @COMRET         ;NEXT COMMAND


;SEQ276

.REM    %
        GENERATES AN EBOX OR AN MBOX CLOCK DEPENDING UPON ENTRY.
TESTS FOR THE OCCURENCE OF AN EVENT IF A FUNCTION BREAKPOINT IS
SET.  CALL IS VIA JSR,R5.
%
ESTEP:  MOV     R5,BRKPC        ;SAVE PC
ESTEP1: MOV     #SECLK,R0       ;DIAG FN TO RO
        BR      XSTEP           ;DO EBOX CLOCK
STEP:   MOV     R5,BRKPC        ;SAVE PC
STEP1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     1$              ;NO, JUST STEP
        MOV     #SSCLK,R0       ;DIAG FN TO RO
        BR      TSTBRK          ;STEP AND TEST
1$:     DFSCLK                  ;STEP MBOX CLOCK
        BR      CLKERC          ;CHECK CLKERROR STOP
XSTEP:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     TSTBRK          ;YES, STEP & TEST
        DFXCT                   ;NO, JUST STEP IT
CLKERC: MOV     BASE20,R0       ;GET DTE20 BASE ADDRESS
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERROR STOP?
        BEQ     1$              ;NO, RETURN
        TST     CLKFLG          ;CLOCK ERR STOP ENABLED?
        BNE     CLKERR          ;YES, GO TO ERROR POINT
        SEC                     ;NO, SET ERROR FLAG
1$:     RTS     R5              ;RETURN

CLKTYP: .WORD   SSCLK           ;CLOCK TYPE

TSTBRK: MOV     R0,CLKTYP       ;SAVE DIAG FN FOR CLOCK
        MOV     FNBRK,R0        ;GET BREAKPOINT
        PUSH    R0              ;SAVE IT

        CLR     FNBRK           ;CLEAR REENTRY
        JSR     R5,EVENT1       ;STEP & TEST
        MOV     #SSCLK,CLKTYP   ;RESET CLOCK TYPE
        POP     FNBRK           ;RESTORE BREAKPOINT

        BCS     BRKCON          ;EVENT DETECTED?
        JMP     BRKPNT          ;YES
BRKCON: CLC
        RTS     R5              ;RETURN


;SEQ277

.REM    %
                GENERATES A BURST OF CLOCK PULSES.
%
BRST:   MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,R0        ;GET THE BURST COUNT
BRST1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     2$              ;NO,DO A REAL BURST
        PUSH    R1

        MOV     R0,R1           ;BURST COUNT TO R1
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        DEC     R1              ;
        BGT     1$              ;LOOP UNTIL DONE
        POP     R1

        BR      3$              ;
2$:     BURST
        JSR     R5,CLKERC       ;TEST FOR CLK ERR STOP
3$:     RTS     R5              ;RETURN

;SEQ278

.REM    %
        ERROR POINT FOR EBOX CLOCK STOP ERRORS.  DETERMINES THE
ERROR TYPE & PRINTS THE ERROR TYPE & SUBROUTINE ENTRY POINT.
%
CLKERR:         ERRMSG  <CLK ERROR STOP - >

        MOV     #103,ERRFCT     ;DIAG FN TO READ
        JSR     PC,ERRCLK       ;TESTS BIT 30
        BEQ     1$              ;NO DRAM PAR ERR
        ERRMSG  <DRAM PAR\>

1$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     2$              ;NO CRAM PAR ERR
        ERRMSG  <CRAM PAR\>

2$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     3$              ;NO FM PAR ERR
        ERRMSG  <FM PAR\>

3$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     4$              ;NO FS ERROR
        ERRMSG  <FS CHECK\>

4$:     ERRMSG  <CALL PC = >

        MOV     BRKPC,R0        ;GET CALLER'S PC
        SUB     #4,R0           ;FIX IT
        ERROCT                  ;PRINT IT
        ERCRLF                  ;CARRIAGE RETURN
        ERROR                   ;EBOX ERROR


;SEQ279

ERRCLK: DFRDT           ;READ A FUNCTION
ERRFCT:         103     ;FIRST ONE IS 103
        INC     ERRFCT  ;SETUP NEXT
        TBIT    30      ;TST PROPER CLK ERR


        RTS     PC      ;RETURN


;SEQ280

.REM    %
        TESTS FOR THE FIRST OCCURENCE OF AN EVENT. STEPS THE
PROPER CLOCK ONCE & SETS THE C-BIT IF THE EVENT DOES NOT OCCUR.
CALL IS JSR,R5.  PARAMETER TRAILS FOR EVENT & IS IN R0 FOR
EVENT1.  EVENT1 DOES NOT SAVE THE FUNCTION BREAK PC.
%

EVENT:  MOV     R5,BRKPC        ;SAVE PC
EVENTA: MOV     (R5)+,R0        ;PARAMETERS TO R0
EVENT1: JSR     R5,SAV.5        ;SAVE R1-R5
        JSR     PC,EVENT2       ;CHECK FOR EVENT 
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;RETURN

        ;SUBROUTINE TO TEST FOR EVENT WITHOUT SAVING & RESTORING
        ;REGISTERS.  LEAVES R1-R5 EQUAL TO THE FOLLOWING
        ;R1 = THE POLARITY OF THE DIAGNOSTIC FN READ
        ;R2 = THE POLARITY FOR THE EVENT TO BE DETECTED
        ;R3 = THE DIAGNOSTIC FUNCTION READ
        ;R4 = THE BIT MASK TO APPLY TO THE APPROPRIATE DEXWD
        ;R5 = THE ADDRESS OF THE PROPER DEXWD TO TEST

EVENT2: MOVB    R0,R2           ;PARAMETER LOWER TO R2
        SWAB    R0              ;
        BIC     #177600,R0      ;
        MOV     R0,R3           ;DIAGNOSTIC FUNCTION
        MOV     R2,R5           ;
        BIC     #177774,R5      ;DEXWD #
        ASL     R5              ;MULTIPLY BY 2
        ADD     .DAT3,R5        ;WORD TO TEST
        MOV     R2,R4           ;
        BIC     #177703,R4      ;
        ASR     R4              ;2 + BIT #
        MOV     BMTAB(R4),R4    ;BIT MASK
        BIC     #177677,R2      ;POLARITY FLAG
        DFRD                    ;READ DIAG FN
        CLR     R1              ;CLEAR EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     EVENT3          ;ZERO?
        INC     R1              ;NO,SET EVENT FLAG


;SEQ281

        ;SUBROUTINE TO TEST FOR AN EVENT AFTER HAVING PREVIOUSLY
        ;TESTED FOR THE SAME EVENT USING ENTRY POINT EVENT2.
        ;CALL IS JSR PC,EVENT3.  SETS THE C-BIT IF EVENT IS NOT
        ;DETECTED.  ASSUMES THAT REGISTERS R1-R5 ARE NOT DESTROYED
        ;FROM ONE ENTRY TO ANOTHER.

EVENT3: MOV     CLKTYP,R0       ;GET EBOX OR MBOX CLK FN
        JSR     R5,XSTEP        ;STEP CLOCK ONCE
        MOV     R3,R0           ;READ SAME DIAG FN
        DFRD                    ;
        CLR     R0              ;CLEAR NEXT EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     1$              ;ZERO?
        INC     R0              ;SET NEXT EVENT FLAG
        TST     R1              ;NO, CHECK CHANGE
        BNE     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     2$              ;NO
        BR      3$              ;YES, EVENT EDGE DETECTED
1$:     TST     R1              ;CHECK CHANGE
        BEQ     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     3$              ;YES, EVENT EDGE DETECTED
2$:     SEC                     ;NO EVENT, SET C-BIT
        MOV     R0,R1           ;SET CURRENT EVENT FLAG
3$:     RTS     PC              ;RETURN

BMTAB:  .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
                
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15


;SEQ348

.SBTTL          PATTERN GENERATOR
.REM    %
        
-----SLIDING BIT PATTERN SUBROUTINE JAB29857 20-DEC-74 EDIT#15
-----THESE TWO SUBROUTINES GENERATE ALL BIT PATTERNS NECESSARY TO TEST
        AN N-BIT WORD.  SBINI IS CALLED TO INITIALIZE SB.  SB WHEN
        CALLED RETURNS THE FOLLOWING PATTERNS, ONE FOR EACH CALL:
N SLIDING 0 PATTERNS, THEN N SLIDING 1 PATTERNS.
        REGISTER 0 POINTS TO THE PATTERN ON RETURN.

-----SBINI IS THE INITIALIZATION SUBRTN.  HE IS CALLED WITH A JSR R5.
        THE ONE TRAILING PARAMETER IS THE WIDTH (N BITS) OF THE PATTERN
        TO BE GENERATED.
%
SBINI:  MOV     (R5)+,R0        ;PICK UP THE PTRN SIZ
        MOV     R0,SBACSK               ;SAV IT FOR ACSKIP KLUDGE
        BGT     1$              ;BR IF GT 0 (NO ADJ NEC)
        BEQ     5$              ;PTRNS OF 0 WIDTH ARE A NO-NO
        NEG     R0              ;ELSE MAKE IT POS
1$:     CMP     #36.,R0
        BGE     4$
5$:     FATAL           ;PTRNS OF GT 36 BITS NOT ALLOWED
4$:     PUSH    R1
;-----SECTION TO CALC TRANSITION BYTE ADR
        MOV     #SBPAT-1,R1
2$:     INC     R1
        SUB     #8.,R0
        BGT     2$              ;LUD
        MOV     R1,SBFADR       ;SAV TRANSITION BYTE ADR
;-----SEC TO CREATE TRANSITION BYTE BIT PTRNS
        MOV     #377,R1
        SEC
3$:     ROR     R1
        CLC             
        INC     R0
        BLE     3$              ;LUD
        MOV     R1,SBSM         ;SAV 0 SLIDE STARTUP BIT PTRN
        MOVB    SBSM+1,SBFILL   ;SAV 0 SLIDE FILL BIT
        MOVB    #-1,SBCNTL      ;RST CNTL BYTE
        BR      SBEXIT          ;OUTA HERE
;-----DATA RETURN SUBROUTINE: RO<0 FOR SLIDING 0, >0 FOR SLIDING 1.  R1
;       HAS THE CURRENT PATTERN #.
SBD:    MOV     #61,R0  ;ASCII 1, SIGN BIT OFF, FOR SLIDING 1 PTRN
        TST     SBSM    ;SLIDING 1 OR 0?
        BEQ     1$              ;BR 1
        MOV     #100060,R0      ;ASCII 0, SIGN BIT ON, FOR SLIDING 0 PTRN
1$:     MOVB    SBCNTL,R1               ;PTRN # (1 TO N) INTO R1
        RTS     R5              ;RETURN


;SEQ349

;-----PATTERN GENERATION SUBROUTINE.  EXPECTS THAT SBINI HAS BEEN
;       CALLED.  RETURNS WITH R0 POINTING TO NEW PATTERN.  PATTTERN
;       MUST NOT BE MODIFIED OUTSIDE OF THIS SUBROUTINE. SB RETURNS
;       WITH THE CARRY SET WHEN CALLED AFTER THE LAST PATTERN HAS BEEN
;       GENERATED
SB:     PUSH    R1

1$:     MOV     #SBPAT+6,R0             ;EVERYONE NEEDS THIS PNTR
        INCB    SBCNTL          ;NEXT FUNC
        BGT     20$             ;SLIDE EXISTING PATTERN
;----SECTION TO CREATE INITIAL SLIDING 1 OR 0 PATTERN.  SLIDE 0 FIRST
        CLR     R1              ;INITY A SRC OF 0'S
10$:    MOVB    R1,-(R0)        ;PUT IN FILL BYUTE

        CMP     R0,SBFADR       ;IS THIS THE TRANSITION BYTE?
        BNE     12$             ;NO
        TST     SBSM            ;IS NEW PTRN SLIDING 1 OR 0?
        BNE     13$             ;BR SLIDING 0
        MOVB    SBFILL,(R0)     ;ELSE FOR SLIDING 1, PUT IN THE 1
        BR      12$
13$:    MOVB    SBSM,(R0)               ;FOR SLIDING 0, PUT IN 0 & TRAILING 1'S
        COM     R1              ;FILL WITH 1'S FROM NOW ON
12$:    CMP     R0,#SBPAT       ;PTRN DONE?
        BGT     10$             ;NO--LUD
        INCB    SBCNTL  ;IND OLD PTRN, CUR # IS 1
        BR      25$             ;EXIT WITH C-BIT CLEAR
;-----EXISTING PATTERN SHIFT SECTION.
20$:    ASR     -(R0)           ;START SHIFT (0 INTO MSBYTE)
        ROR     -(R0)
        ROR     -(R0)   ;THIS LAST SHIFT SETS C-BIT FOR LATER USE
        MOV     #SBSM,R1        ;PTR SAVES SPACE & TIME
        BCS     21$             ;BR IF 1 SHIFTED OUT
;-----SECTION FOR 0 SHIFTED OUT
        TST     (R1)            ;0 OR 1 SLIDE?
        BEQ     22$             ;BR 1 SLIDE
        CLR     (R1)+           ;0 SLIDE DONE...SET UP FOR 1 SLIDE
        MOVB    #-1,(R1)        ;ZAP SBCNTL
        BR      1$              ;CALC NEW PTRN FOR SLIDING 1
;-----AC SKIP PATTERN KLUDGE:  DONT ADDRESS THE AC'S IF N WAS LT 0
22$:    CMP     #10,(R0)        ;IS IT TIME FOR THE KLUDGE?
        BNE     25$             ;NO
        TST     SBACSK          ;WAS THE KLUDGE DESIRED?
        BGE     25$             ;NO
        BR      23$             ;DO KLUDGE---SET HI ORD BIT
;-----SECTION FOR 1 SHIFTED OUT OF THE PATTERN
21$:    TST     (R1)            ;0 OR 1 SLIDE?
        BNE     23$             ;BR 0 SLIDE
        SEC                     ;IF 1 CAME OUT & ARE IN 1 SLIDE
        BR      SBEXIT          ;THEN WE ARE DONE...IND THIS FACT
23$:    BISB    SBFILL,@-(R1)   ;SET HI ORD PTRN BIT ON 0 SLIDE/KLUDGE


;SEQ350

;-----EXIT SECTION.
25$:    CLC             ;CLEAR C-BIT FOR NOT DONE RET
SBEXIT: POP     R1              ;RSTR R1
        RTS     R5              ;& RETURN
;-----DATA SECTION FOR SBINI AND SB.
SBFADR: .WORD   0               ;ADDR OF TRANSITION BYTE IN PTRN
SBSM:   .WORD   0               ;LESSER 1 BITS & CNTL
SBCNTL: .BYTE   0               ;CONTROL AND PTRN #
        
SBFILL: .BYTE   0               ;HI ORD BIT OF PTRN
;NOTE: THE ABOVE 4 LINE MUST STAY AS THEY ARE
SBACSK: .WORD   0               ;AC SKIP INDICATOR
SBPAT:  .WORD   0,0,0   ;THE PTRN GOES HERE, R0 PNTS HERE ON EXIT




.REM    %
        
-----JAB29857 19-FEB-75  SUBROUTINE TO PERFORM THE SAME FUNCTION
        AS "STPCON" WITH THE EXCEPTION THAT, HAVING ONCE
        ESTABLISHED THE BURST COUNT, IT MAKES SURE THAT THE EVENT
        OCCURS AGAIN AT THE END OF THE BURST ON SUBSEQUENT CALLS.
%

SOBAC:  MOV     R5,BRKPC                ;SAV PC FOR FUNC. BRKPT.
SOBAC1: MOV     (R5)+,R0        ;GET BURST CNT
        BLT     1$              ;BR ON NO BURST CNT YET
        DEC     R0              ;BURST FOR 1 CLK LESS THAN CNT
        JSR     R5,BRST1        ;BURST
        MOV     (R5)+,R0        ;FUNCTION TO RO FOR 'EVENT1'
        JSR     R5,EVENT1       ;CLK & TEST FOR OCCURENCE OF EVENT
        RTS     R5              ;RET W/ C-BIT: CLR=FOUND, SET=NOT FOUND
1$:     MOV     (R5)+,R0        ;GET FUNCTION FOR 'FIND'
        JSR     R5,FIND2        ;STEP UNTIL EVENT OCCURS
        BCS     2$              ;IF EVENT DIDNT OCCUR, DONT SAV BRST CNT
        MOV     R0,-4(R5)       ;ELSE SAV BRST CNT FOR FUTURE USE
2$:     RTS     R5              ;RET W/C-BIT SET/CLR AS ABOVE

.REM    %
        
-----A DYNAMIC-DATA CALLER FOR SOBAC.  DOES THE SAME THING, EXCEPT
        THAT IT SHUFFLES DATA PASSED AND RETURNED.  BURST COUNTS ARE
        ASSUMED IN A LIST POINTED TO BY BCLA.  UPDATES COUNT IN LIST
        AND ADDRESS IN BCLA IF SOBAC WAS SUCCESSFUL.
%
SOBACF: MOV     (R5)+,R0        ;ENTRY FOR STATIC FUNC #
DSOBAC: MOV     R5,BRKPC        ;SAV PC FOR FUNC BRK PNT
        MOV     R0,2$           ;MOV FUNC TO PARAM LST
        MOV     @BCLA,1$        ;MOV BURST CNT TO PARAM LIST
        JSR     R5,SOBAC1       ;GO AND DO SOBAC
1$:      000000                 ;BURST CNT TO BE SUPPLIED
2$:      000000                 ;FUNCTION TO BE SUPPLIED
          BCS   3$              ;ON FAILURE, DONT UPDATE ANYTHING
        MOV     BCLA,R0         ;SAV BURST CNT & UPDATED ADR...
        MOV     1$,(R0)+        ;W/0 MODFG C-BIT
        MOV     R0,BCLA
3$:     RTS     R5

BCLA:   .WORD   -1              ;BURST COUNT LIST ADDRESS

;SEQ283

.SBTTL          AC LOADERS
.REM    %
        ROUTINE TO LOAD PDP10 AC'S AND LIMITED MEMORY SPACE
CALL:
        JSR     R5,LOAD
        ARG1
        ARG2
        ARG3

ARG1:   FIRST PDP10 ADDRESS TO LOAD. ADDRESSES 1-17 ARE INTERPRETED AS
IN THE CURRENT AC BLOCK.

ARG2:  NUMBER OF PDP10 WORDS TO LOAD.  THE VALUE IS NEGATIVE IF
THE WORDS ARE TO COME FROM CONSECUTIVE PDP11 LOCATIONS.
VALUES 0,1, AND -1 ARE TREATED ALIKE.

ARG3:  IF ARG2 IS NEGATIVE THIS WORD POINTS TO THE FIRST BYTE OF
THE FIRST PDP10 WORD IN PDP11 MEMORY.  IF ARG2 IS POSITIVE, THEN
THERE MUST BE ONE ARG3 FOR EACH PDP10 WORD TO BE LOADED. (I.E.,
THE WORDS TO BE LOADED ARE SCATTERED IN DPD11 MEMORY).
%

LOAD:   PUSH    R1

        DFXCTT          ;START THE CLOCK
                STRCLK  ;
        CLR     DEADR+2 ;CLR HIGH ORDER ADDR WORD
        MOV     (R5)+,DEADR     ;GET DESIRED ADDRESS
1$:     MOV     (R5)+,WDCNT     ;GET COUNT OF XFERS
        MOV     (R5)+,R0        ;GET COUNT OF XFERS
       TST      WDCNT
        BNE     2$
        INC     WDCNT           ;TURN 0 INTO 1

2$:     MOV     #DEADR,R1       ;ADDRESS OF ADDRESS
        PUSH    R0              ;SAVE DATA POINTER

        DPOSVR                  ;DO DEPOSIT
        POP     R0

        BCS     6$              ;DEPOSIT ERROR

        TST     WDCNT           ;WHERE'S NEXT DATA?
        BPL     3$              ;SKIP IF SCATTERED
        INC     WDCNT           ;STRAIGHT LINE- UP CNT
        ADD     #5,R0           ;DO NEXT 5 BYTES
        BR      4$              ;CONTINUE


;SEQ284

3$:     DEC     WDCNT   ;SCATTERED- DOWN COUNT
4$:     TST     WDCNT   
        BEQ     7$              ;EXIT IF DONE
        BMI     5$              ;SKIP IF STRAIGHT LINE
        MOV     (R5)+,R0        ;NEW ADDRESS IF NOT
5$:     INC     DEADR           ;BUMP LOW ADR
        ADC     DEADR+2         ;CARRY TO HIGH
        BR      2$              ;DO ANOTHER DEPOSITY

6$:     DEC     WDCNT           ;WILL WE RETURN CORRECTLY?
        BLE     7$              ;O.K. IF 0 OR NEG
        ASL     WDCNT           ;IF SCATTERED MUST PASS OVER POINTERS
        ADD     WDCNT,R5        ;TO GET BACK O.K.
        SEC                     ;SET ERROR FLAG AGAIN
7$:     POP     R1

        RTS     R5              ;DONE - RETURN


DEADR:  .BLKW   2               ;PDP10 ADDRESS HOLDER
WDCNT:  .WORD   0



                


.REM    %
        SUBROUTINE TO PERFORM A "RANDOM" LOAD OF THE KL10 AC'S.  EDIT#4
        METHOD OF CALL IS AS FOLLOWS:
        JSR     R5,ACLOAD
        .WORD   ACMASK,11-ADR
        -----OR-----
        JSR     R5,ACSCAT
        .WORD   ACMASK,ADR1,ADR2,...,ADRN
        -----WHERE-----
        ACMASK SPECIFIES WHICH KL10 AC'S ARE TO BE LOADED: BIT 0 SET
        MEANS ACO GETS LOADED, ETC.
        A CALL TO ACLOAD SAYS THAT THE KL10 WORDS ARE CONTIGUOUS WITHIN
        PDP11 MEMORY, STARTING AT "11-ADR".
        A CALL TO ACSCAT SAYS THAT THE KL10 WORDS ARE SCATTERED IN PDP11
        MEMORY. AND ARE POINTED TO BY ADR1, ADR2, ETC., ON ADR/WORD.
        THE C-BIT IS CLEAR UPON RETURN FOR SUCCESSFUL COMPLETION.
        %

ACLOAD: PUSH    <R1,R2>         ;SAVE REGS


        MOV     (R5)+,R1        ;GET MASK
        MOV     (R5)+,R2        ;ADR OF LOAD STRING TO R2
        BR      ACLDCM          ;GO TO COMMON ROUTINE
ACSCAT: PUSH    <R1,R2>         ;SAVE REGS


        MOV     (R5)+,R1        ;GET MASK
        CLR     R2              ;INDICATE SCATTERED LOAD WORDS
ACLDCM: CLR     3$+2            ;SET KL10 ADR=AC0, CLR C-BIT
        DFXCTT,STRCLK           ;MAKE SURE CLOCK IS RUNNING
1$:     ROR     R1              ;MOV MASK BIT TO C-BIT
        BCC     4$              ;BR IF THIS AC IS NOT BE BE LOADED
        MOV     R2,3$+4         ;MOV PDP11 ADR TO DPOST ADR LIST
        BEQ     2$              ;BR IF NOT CORRECT ADR
        ADD     #5,R2           ;ELSE PT TO KL WD FOR NXT TIME
        BR      3$              ;GO DO THE DPOSIT
2$:     MOV     (R5)+,3$+4      ;FOR SCATTERED LOAD, MOV NXT ADR
3$:     DPOST,000000,000000     ;DEPOSIT (KL ADR & PDP11 ADR TO BE SUP.)
        BCC     4$              ;BR IF NO ERROR ON DEPOSIT
        ERRMSG  <REAL ERR PC=>

        MOV     R5,R0           ;RETURN PC TO PARAM REG
        ERRCOM  PNTOCT          ;RET PC TO ERR SKT
        ERROR   <AC PROGRAM LOAD ERR>

4$:     INC     3$+2            ;NXT KL ADR
        TST     R1              ;ANY MORE AC'S TO BE LOADED?


  

        BGT     1$              ;BR IF YES
        POP     <R2,R1>         ;RESTORE REGS


        RTS     R5
;SEQ502
.REM    %
READ17 - READS & CLEARS AC17.  POINTER TO DATA RETURNED IN R0.
%
READ17: PUSH    R1

        MOV     #HDWEXA,R0       ;
        EXCT                    ;DO A SUB AC17 17
        MOV     #ZERO..,R0      ;POINT TO ZEROS IF ERROR
        BCS     1$              ;ERROR
        MOV     #DPBR,R0        ;READ BR FOR AC17
        MOV     #EXAREA,R1      ;BUFFER ADDRESS
        DFRDMV                  ;PUT AC17 IN BUFFER
        MOV     R1,R0           ;POINTER TO R0
1$:     POP     R1

        
        RTS     R5              ;RETURN


        
HDWEXA: I10     SUB AC17,,17


        .EVEN
EXAREA: WD36    0,0,0


        .EVEN

.SBTTL          EXECUTE ROUTINES

.REM    %
STEXCT - ROUTINE TO START EXECUTION OF AN INSTRUCTION.  SUPPORTS
MBOX SCANOUTS.  TRAILING PARAMETER IS THE INSTRUCTION POINTER.
%
STEXCT: MOV     (R5)+,R0        ;GET INSTRUCTION POINTER
        LODAR                   ;PUT INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        RTS     R5              ;RETURN

.REM    %
XQT - ROUTINE TO EXECUTE A PDP-10 INSTRUCTION.  OPERATES AT
HIGH SPEED UNLESS A FUNCTION BREAKPOINT IS ACTIVE.  SETS THE
C-BIT IF THE INSTRUCTION DOES NOT RETURN TO THE HALT LOOP.
%
XQT:    MOV     R5,BRKPC        ;SAVE PC
        
XQT1:   TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     XQT2            ;YES
        EXCT                    ;NO, DO CONSOLE EXECUTE
        BCC     1$              ;ERROR?
        MOV     BASE20,R0       ;YES, GET DTE20 BASE ADDRESS
        JSR     R5,CLKERC       ;CHECK FOR CLK ERR STOP
1$:     RTS     R5              ;RETURN

XQT2:   JSR     R5,SAV.3        ;SAVE R3-R5
        LODAR                   ;GET INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        MOV     #20,R3          ;MAX COUNT TO LEAVE HALT LOOP
        MOV     #5000.,R4       ;MAX COUNT TO ENTER HALT LOOP
        MOV     BASE20,R5       ;GET DTE20 BASE
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)       
        BEQ     2$              ;LEFT HALT LOOP
        DEC     R3              ;DIDNT
        BGT     1$              ;TRY AGAIN
        BR      3$              ;ERROR
2$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)
        BNE     4$              ;BACK TO HALT LOOP
        DEC     R4              ;NOT THERE YET
        BGT     2$              ;LOOP AGAIN
3$:     SEC                     ;SET C-BIT
4$:     JSR     R5,RST.3        ;RESTORE R3-R5
        RTS     R5              ;


    



.SBTTL          SBUS DIAG SUBROUTINES
.REM    %
SBUSDG - THIS SUBROUTINE SETS UP AN SBUS DIAG OPERAND IN AC16 BY
INSERTING THE CONTROLLER ADDRESS IN THE 36-BIT WORD POINTED TO
BY R0, AN SBUS DIAG IS INITIATED & THE RESULT IS TRANSFERRED
TO THE DTE20.
%

SBUSDG: MOV     R5,BRKPC                ;SAVE PC
SBUSD1:         PUSH    R1

        MOVB    TSTCON,R1               ;GET CONTROLLER ADR
        ROR     R1              ;0-3 TO R1
        MOVB    R1,4(R0)        ;TO SBUS OPERAND
        BICB    #BIT07,3(R0)    ;CLEAR CONTROLLER ADR 4
        BCC     SBUSD3          ;SET IT?
        BISB    #BIT07,3(R0)    ;YES
        BR      SBUSD3          ;
SBUSD2: MOV     R5,BRKPC        ;SAVE PC
        PUSH    R1              ;
SBUSD3: PUSH    R0
        DFXCTT          ;START THE CLOCK
                STRCLK          ;
        POP     R0              ;
        MOV     #ADAC16,R1              ;ADDRESS TO LOAD
        DPOS            ;DO DEPOSIT
        BCS     1$              ;ERROR
        MOV     #SBUSD,R0       ;DO SBUS DIAG
        JSR     R5,XQT1         ;
        BCS     1$              ;ERROR
        JSR     R5,READ17               ;GET AC178
1$:     POP             R1              ;RESTORE R1
        RTS     R5              ;RETURN
    
ADAC16: .WORD   16,0            ;
TSTCON: .WORD   0               ;TEST CONTROLLER
SBUSD:  IO10    BLKO PI,,16     ;

        .EVEN

;SEQ505

.REM    %
        SBUPRG - LOADS A PROGRAM TO SUPPORT DETERMINATION OF MEMORY
CONFIGURATION.  IT IS AS FOLLOWS:

        1:      MOVE    AC16,6  ;SET SBUS F1, ADR0

        2:      BLK0    PI,16   ;DO SBUS DIAG
        3:      JRST,4  4       ;HALT
        4:      ADD     AC16,7  ;INCREMENT ADDRESS
        5:      JRST    2       ;NEXT SBUS DIG
        6:              1       ;FUNCTION 1,ADR0
        7:      020000  000000  ;ADDRESS INCREMENT
%
SBUPRG: MOV     R5,BRKPC                ;SAVE PC
        JSR     R5,LOAD         ;LOAD THE PROGRAM
        .WORD   1
        .WORD   -7
        .WORD   SBUCON
        RTS     R5              ;RETURN

SBUCON: I10     MOVE AC16,,6    ;
        IO10    BLKO PI,,16     ;
        I10     JRST,4,,4       ;
        I10     ADD AC16,,7     ;
        I10     JRST,,,2        ;
        WD36    0000,0000,0001  ;
        WD36    0200,0000,0000  ;
        .EVEN


;SEQ506

.REM    %
LOOPAR - ROUTINE TO LOOP THE DATA IN AC15 TO AC17 VIA THE SBUS
DIAG LOOPBACK.  THE MEM ADDRESS TO BE USED IS POINTED TO BY R0.
%
LOOPAR: MOV     R5,BRKPC                ;SAVE PC
        MOVB    (R0)+,TOSBUS    ;ADDRESS TO LOOPBACK OPERANDS
        MOVB    (R0)+,TOSBUS+1  ;
        BICB    #3,TOSBUS+2     ;
        BISB    (R0),TOSBUS+2   ;
        BICB    #3,FRSBUS+2      ;
        BISB    (R0),FRSBUS+2   ;
        MOV     TOSBUS,FRSBUS   ;
        MOV     #ARLOOP,R0      ;
        JSR     R5,SBUSD1       ;SET LOOP AROUND MODE
        BCS     1$              ;ERROR
        MOV     #TOSBUS,R0      ;
        JSR     R5,XQT1         ;MOVE TO CONTROLLER
        BCS     1$              ;ERROR
        MOV     #FRSBUS,R0      ;
        JSR     R5,XQT1         ;MOVE FROM CONTROLLER
1$:     RTS     R5              ;RETURN

TOSBUS: I10     MOVEM AC15,,0

        .EVEN
FRSBUS: I10     MOVE AC17,,0
ARLOOP: WD36    0000,4000,0001

        

;SEQ507


.REM    %
ADRSET - ROUTINE TO SET CONTROLLER (TSTCON) ADDRESS SWITCHES
TO CORRRESPOND TO THE PROPER RANGE FOR A 22-BIT ADDRESS POINTED
TO BY R0.
%
ADRSET: MOV     R5,BRKPC        ;SAVE PC
        PUSH    <R1,R2>

        MOVB    1(R0),R1        ;GET BITS 20 & 21
        BIC     #177477,R1      ;
        MOVB    2(R0),R2        ;GET BITS 14-19
        BIC     #177700,R2      ;
        MOVB    R1,SETADR+1     ;PUT SEC & LOWER BOUNDRY
        MOVB    R2,SETADR+2     ;IN SBUS DIAG
        ROR     R2              ;UPPER 2 BITS OF LOWER BOUNDRY
        RORB    R1              ;LEFT JUST IN R1 LOWER
        ROR     R2              ;
        RORB    R1              ;
        CLC                     ;POSITION AT UPPER LIMIT
        RORB    R1              ;
        RORB    R1              ;
        RORB    R1              ;
        RORB    R1              ;
        BIS     #2,R1           ;ENABLE BITS 14-25
        BISB    R1,SETADR+1     ;TO SBUS DIAG
        MOV     #SETADR,R0      ;DO SBUS DIAGT
        JSR     R5,SBUSD1       ;
        POP     <R2,R1> 
        RTS     R5              ;RETURN

SETADR: WD36    0,0,1

        .EVEN


;SEQ294

.SBTTL          CACHE SWEEP ROUTINES
        
.REM    %
INVAL - INVALIDATES THE CACHE.
%
INVAL:  MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,LOAD         ;LOAD PROGRAM
        .WORD   1
        .WORD   -4
        .WORD   CSHSWP
        JSR     R5,RUNPR1       ;RUN IT
        .WORD   1               ;STARTING ADDRESS
        RTS     R5              ;RETURN

CSHSWP: IO10    DATAI CCA,,0


        IO10    CONSZ APR,,200000

        I10     JRST,,,2


        I10     JRST,4,,1





.SBTTL  *STOR11* DECSYSTEM10 PDP-11 PROGRAM STORAGE SECTION

;ASSIGN LITERAL AREA
        .EVEN
$$FF:   $$CLIT  ;FIRST FREE

$$LITT=.        ;START OF LITERAL AREA

.END    START
   <ftXA