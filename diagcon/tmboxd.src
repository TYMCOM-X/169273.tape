.TITLE  TMBOXD   KL10 CHANNEL CONTROL TEST       VER 1.0
        .NLIST CND,TOC,BEX
        DTEASB=1                ;ASSEMBLE DTE20 PARAMETERS.
        DTEDEF=1                
        KWASB=1                 ;ASSEMBLE CLOCK PARAMETERS.
        $MBOX=1                 ;ASSEMBLE MBOX ERROR REPORTS
        $CHTST=1                ;ASSEMBLE CHANNEL TEST SUBROUTINES
        ISAME=1                 ;SAME ISOLATION FOR KL10PV & KL10PA
        ESTSIZ=128.             ;ALLOW ENOUGH ROOM ON ERROR STACK
        UCODE=156               ;FREEZE MICRO-CODE VERSION
        EPT=3000                ;EXEC PAGE TABLE LOCATION
        .ENABL  ABS,AMA
        .=3000
.SBTTL  *PRM11* DECSYSTEM10 PDP-11 PROGRAM/SUBROUTINE PARAMETERS, 7-MAR-77

;PROGRAM CONTROL SWITCHES

ABORT=  100000          ;ABORT AT PROGRAM PASS COMPLETION

RSTART= 40000           ;RESTART TEST
TOTALS= 20000           ;PRINT TEST TOTALS
NOPNT=  10000           ;INHIBIT ALL PRINT OUT (EXCEPT FORCED)

PNTLP=4000              ;PRINT ON LINE-PRINTER
DING=  2000             ;RING TTY BELL ON ERROR
LOOPER= 1000            ;LOOP ON ERROR

ERSTOP= 400             ;HALT ON ERROR
PALERS= 200             ;PRINT ALL ERRORS
RELIAB= 100             ;RELIABILITY RUN MODE

TXTINH= 40              ;TEXT INHIBIT
INHPAG= 20              ;INHIBIT PAGING
MODDVC= 10              ;MODIFY DEVICE CODE

INHCSH= 4                ;INHIBIT CACHE
OPRSEL= 2               ;OPERATOR SELECTION
CHAIN=  1               ;CHAIN CONTROL SWITCH

;*OPERATOR DEFINITION - SUBROUTINE CALLS (EMTS)

FATAL=  EMT!0           ;FATAL PROGRAMMING ERROR.
ERRHLT= EMT!1           ;PROGRAM HALT, ONLY IF "ERSTOP" SWITCH SET
PRGHLT= EMT!2           ;PROGRAM HALT, DON'T CHECK SWITCH
RUNLP=   EMT!3          ;CONSOLE IDLE RUN LOOP
DFLEGAL=EMT!226         ;DIAGNOSTIC FUNCTION LEGALITY CHECK

;*TELETYPE INPUT SUBROUTINE CALLS (EMTS)
;  *** CALL SEQUENCE ***
;   TT----
;RETURN, C BIT SET FOR NO/ERROR RESPONSE

TTILIN= EMT!4           ;READ TTY LINE INPUT INTO BUFFER
TTILNW=  EMT!224                ;READ TTY LINE INPUT, WAIT FOREVER
TTICCL= EMT!225                ;PROCESS TTY INPUT FROM INDIRECT CCL BUFFER
TTICHR= EMT!5           ;INPUT A CHARACTER FROM BUFFER
TTCCHR= EMT!254         ;INPUT CHAR, ABORT IF NON-AVAIL
TTBACK= EMT!144         ;BACKUP INPUT POINTER
TTLOOK=  EMT!6           ;LOOK FOR A TTY INPUT
TTIOCT=  EMT!7          ;INPUT AN OCTAL NUMBER FROM BUFFER
TTCOCT= EMT!10          ;INPUT & CHECK OCTAL, TRN IF OK
TTOCTE= EMT!200         ;INPUT EVEN OCTAL NUMBER
TTIDEC= EMT!11          ;INPUT A DECIMAL NUMBER FROM BUFFER
TTIYES= EMT!12          ;ASK YES-NO, N BIT ON NO, C BIT SET ON ERROR
TTALTM= EMT!13          ;ALT-MODE CHECK, C BIT SET IF NON-ALT-MODE
TTI36=  EMT!14          ;READ 36 DIGIT NUMBER FROM BUFFER
TTIBRK= EMT!15          ;GET NUMBER INPUT BREAK CHARACTER
TTISDL= EMT!16          ;SPACE DELETE, C BIT SET ON NON-NUMBER
TTISDO= EMT!17          ;SPACE DELETE & OCTAL INPUT, RTN IF OK
TTIS36= EMT!20          ;SPACE DELETE & 36BIT INPUT, TRN IF OK
TTICRA= EMT!21          ;INPUT C-RAM ADDRESS
TTITRM= EMT!22          ;CHECK INPUT TERMINATOR, RTN IF OK
TTBTRM= EMT!23          ;BACKUP, THEN "
TTERM=  EMT!201         ;NUMBER TERMINATION CHECK, C BIT SET IF ERROR
TTPINI= EMT!217         ;INITIALIZE INPUT & OUTPUT BUFFER POINTERS

;*TELETYPE OUTPUT SUBROUTINE CALLS (EMTS)
;*** CALL SEQUENCE ***
;  MOV ARG,R0           ;IF CALL REQUIRES AN ARGUMEMNT
;  P_____

PNTAL=  EMT!24          ;PRINT ASCII LINE, ADDRESS IN RO
$PMSG=  EMT!25          ;PRINT MESSAGE, TRAILING PARAMETER
$PMSGR= EMT!26          ;PRINT MESSAGE, CONDITIONAL ON "RPTFLG"
PNTCHR= EMT!27          ;PRINTASCII CHARACTER IN RO
PNTCI=  EMT!214         ;PRINT CHAR IMMEDIATE, TRAILING CHARS
PNTNBR= EMT!30         ;PRINT  NUMBER
PCRLF=  EMT!31          ;PRINT CR-LF
PSPACE= EMT!32          ;PRINT A SPACE
PSLASH= EMT!33          ;PRINT A SLASH
PCOMMA= EMT!34          ;PRINT A COMMA
PTAB=  EMT!227          ;PRINT A TAB
PNTOCT= EMT!35          ;PRINT OCTAL NUMBER IN RO
PNTOCS= EMT!36          ;PRINT OCTAL IN R0, SUPPRESS LEADING ZEROS
PNTDEC= EMT!37          ;PRINT DECIMAL NUMBER IN RO
PNT18=  EMT!40          ;PRINT LOWER 18 OF 36 BIT NUMBER
PNT23=  EMT!41          ;PRINT LOWER 23 BITS OF 36 BIT NUMBER
PNT22=  EMT!41          ; "OLD PNT23 "
PNT36=  EMT!42          ;PRINT 36 BIT NUMBER, ADDRESS IN RO
PNT36B= EMT!134         ;PRINT 36 BIT NUMBER IN BINARY
PNTADR= EMT!137         ;PRINT PDP-10 ADDRESS
PFORCE= EMT!43          ;SET FORCED PRINTOUT FLAG
PNORML= EMT!44         ;CLEAR FORCED PRINTOUT FLAG
PBELL=  EMT!45          ;DING THE TTY BELL
PNTODC= EMT!46          ;PRINT SPECIFIED OCTAL DIGITS
PNTODT= EMT!47          ;PRINT SPECIFIED DIGITS, TRAILING PARAMETER

PRINTT= EMT!151         ;PRINT, TTY OUTPUT
PTTY=   EMT!152         ;PRINT, TTY DRIVER
PLPT=   EMT!153         ;PRINT, LPT DRIVER
PLDBUF= EMT!154         ;PRINT, LOAD BUFFER
PNTBAK= EMT!177         ;PRINT, BACKUP OUTPUT INSERTION POINTER

PNTRST= EMT!215         ;PRINT, OUTPUT POINTERS RESET


;*MISCELLANEOUS FUNCTION SUBROUTINE CALLS (EMTS)

REGSAV= EMT!50          ;SAVE RO THRU R5
REGRST= EMT!51          ;RESTORE RO THRU R5
SHIFTR= EMT!53          ;SHIFT RO RIGHT, TRAILING PARAMETER
SHIFTL= EMT!54          ;SHIFT RO LEFT, TRAILING PARAMETER
PROL36= EMT!146         ;ROTATE LEFT 36 BITS
SETFLG= EMT!55          ;SET -1 TO FLAG, TRAILING PARAMETER
MULTPY= EMT!72                ;MULTIPLY
TDELAY= EMT!56          ;SMALL DELAY
SWITCH= EMT!57          ;READ THE SWITCH REGISTER, RETURNED IN RO
SWTSAM= EMT!60          ;RETURN PRESENT STORED SWITCHES IN RO
EOP=   EMT!61           ;END OF PASS ROUTINE, RETURNS IF NOT COMPLETED
ERREOP= EMT!62          ;ERROR END OF PASS
EOPSET= EMT!63          ;SET END OF PASS PRINTOUT INTERVAL
ITRCNT= EMT!255         ;GET PASS ITERATION COUNT

;*DEVICE ROUTINE SUBROUTINE CALLS (EMTS)

NAMEXT= EMT!206         ;FILE NAME.EXT PROCESS
DTAFILE=EMT!207         ;DECTAPE FILE SELECTION
RPFILE= EMT!210         ;RP04 FILE SELECTION
R5OUPK= EMT!155         ;RAD50 TO ASCII UNPACK
ASCR50= EMT!165         ;ASCII TO RAD50 CONVERSION
DTINIT= EMT!156         ;DECTAPE INITIALIZATION
RPINIT= EMT!157         ;RP04 INITIALIZATION
RPLOAD= EMT!166         ;RP04 LOAD PACK
DVDATA= EMT!160         ;DEVICE DATA BLOCK READ
DTRDFL= EMT!211         ;DECTAPE READ FILE
DTWTFL= EMT!212         ;DECTAPE WRITE FILE
DTBASE= EMT!213         ;RETURN DECTAPE PARAMETER BASE ADDRESS
DTREAD= EMT!161         ;DECTAPE READ
DTWRT=  EMT!205         ;DECTAPE WRITE
RPFIND= EMT!167         ;RP04 FIND FILE
RPLKUP= EMT!170         ;RP04 FILE DIRECTORY LOOKUP
RPRDFL= EMT!171         ;RP04 READ FILE
RPWRFL= EMT!172         ;RP04 WRITE FILE
RPREAD= EMT!162         ;RP04 READ
RPWRIT= EMT!173         ;RP04 WRITE
RPADDR= EMT!174         ;RP04 ADDRESS CALCULATION
RPBASE= EMT!175         ;RETURN RP04 PARAMETER BLOCK BASE ADDRESS
RPERROR=EMT!237         ;RP04 ERROR REPORTER
DVFRAM= EMT!163         ;DEVICE DATA FRAME READ
DVWRD=  EMT!164         ;DEVICE WORD READ
RXFILE= EMT!230         ;RX11/RX101 FLOPPY FILE SELECTION
RXINIT= EMT!231         ;  FLOPPY INITIALIZATION
RXRDFL= EMT!232         ;  FLOPPY READ FILE
EZWTFL= EMT!233         ;  FLOPPY WRITE FILE
RXBASE= EMT!234         ;  FLOPPY PARAMETER BLOCK BASE ADDRESS
RXREAD= EMT!235         ;  FLOPPY READ
RXWRT=  EMT!236         ;  FLOPPY WRITE
DIRCMP= EMT!250         ;DIRECTORY ENTRY COMPARE
DIRPNT= EMT!251         ;DIRECTORY ENTRY PRINT

;*COMMUNICATION ROUTINE SUBROUTINE CALLS (EMTS)

COMCMD = EMT!220                ;COMMUNICATIONS COMMAND
COMRTRY=EMT!221         ;COMMUNICATIONS COMMAND RETRY
COMENQ= EMT!222         ;COMMUNICATIONS ENQUIRY
COMEOT= EMT!223         ;COMMUNICATIONS END OF TRANSMISSION
COMLIN= EMT!64          ;COMMUNICATIONS LINE INPUT
COMSND= EMT!65          ;COMMUNICATIONS LINE OUTPUT
COMACK= EMT!66          ;COMMUNICATIONS ACKNOWLEDGE
COMNAK= EMT!67          ;COMMUNICATIONS NEGATIVE ACKNOWLEDGE
COMCLR= EMT!70          ;COMMUNICATIONS CLEAR
COMCTL= EMT!71          ;COMMUNICATIONS CONTROL SEQUENCE

;*KL10 ROUTINE SUBROUTINE CALLS (EMTS)

WCRAM= EMT!73           ;WRITE IN TO C-RAM
RCRAM=  EMT!74          ;READ THE C-RAM
WWADR=  EMT!75          ;WRITE C-RAM ADDRESS
MICNUL= EMT!203         ;C-RAM FILL WITH 0'S
MICFIL= EMT!204         ;C-RAM FILL WITH 1'S

MRESET= EMT!76          ;MASTER RESET

TENSW=  EMT!145         ;PDP-10 SWITCHES

TENSP=  EMT!77          ;TURN OFF TEN RUNNING

TENCHR= EMT!176         ;PDP-10 LAST TYPED CHARACTER

SM=      EMT!100                ;START MACHINE
EXCT=   EMT!101         ;EXECUTE PDP10 INSTR, REQUIRES SM
LODAR=  EMT!102         ;SPECIAL AR LOAD FOREXCT AND MBOX TEST
SETMPH= EMT!147         ;SET M-BOX PHASE

ECLOK=  EMT!135         ;E BOX CLOCK

EXAM=   EMT!103         ;EXAMINE 10 MEMORY
EXAMT=  EMT!104         ;EXAMINE 10 MEMORY, TRAILING PARAMETERS
DPOS=  EMT!105          ;DEPOSIT INTO 10 MEMORY
DPOST=  EMT!106         ;DEPOSIT INTO 10 MEMORY, TRAINING PARAMETERS
DPOSVR= EMT!107         ;DEPOSIT AND VERIFY 10 MEMORY
DPOSVT= EMT!110         ;DEPOSIT AND VERIFY 10 MEMORY, TRAILING PARAMETERS
D10MON= EMT!111         ;DEPOSIT -1 INTO 10 FLAG WORD
D10ZRO= EMT!112         ;PDP-10 MEMORY ZERO

CMPR36= EMT!52          ;COMPARE 5BYTE 36-BIT WORD

DTEBAS= EMT!113         ;RETURN DTE20 BASE ADDRESS

DFXCT=  EMT!114         ;DIAGNOSTIC FUNCTION EXECUTE
DFXCTT= EMT!115         ;DF EXECUTE, TRAILING PARAMETER

DFRD=  EMT!116          ;DIAGNOSTIC FUNCTION READ
DFRDT=  EMT!140         ;DF READ, TRAILING PARAMETER
DFRDMV= EMT!117         ;DIAGNOSTIC FUNCTION READ & MNOVE

DFWRT=  EMT!120         ;DIAGNOSTIC FUNCTION WRITE
DFWRTT= EMT!141         ;DF WRITE, TRAILING PARAMETERS
DFWIR=  EMT!121         ;DIAGNOSTIC FUNCTION WRITE IR

DFSCLK= EMT!122         ;DIAGNOSTIC FUNCTION, SINGLE STEP CLOCK

DFPC=   EMT!123         ;DIAGNOSTIC FUNCTION READ PC
DFVMA=  EMT!124         ;DIAGNOSTIC FUNCTION READ VMA
DFADB=  EMT!125         ;DIAGNOSTIC FUNCTION READ ADDRESS BREAK
DFVMAH= EMT!150         ;DIAGNOSTIC FUNCTION READ VMA HELD

RDRAM=  EMT!126         ;READ D-RAM
WDRAM=  EMT!127         ;WRITE D-RAM
DRAMAD= EMT!130         ;SELECT D-RAM ADDRESS

CLKPRM= EMT!202         ;RETURN ADDRESS OF "CLKDFL" WORD

BURST=  EMT!131         ;BURST M-BOX CLOCK

PNTCPU= EMT!132         ;PRINT CPU, C-RAM & REGISTERS

PNTCRM= EMT!142         ;PRINT C-RAM, LOGICAL FIELD FORMAT

PNTDRM= EMT!143         ;PRINT D-RAM, LOGICAL FIELD FORMAT

PRGCMD= EMT!133         ;PROGRAM COMMAND
PRGNPT= EMT!216         ;PROGRAM COMMAND, NO PRINT
PRGSEL= EMT!252         ;PROGRAM FILE SELECTION
PRGRD8= EMT!253         ;PROGRAM FILE 8 BIT READ

;*FILES-11 SUBROUTINE CALLS (EMTS)

F11LOAD=EMT!240         ;FILES-11 LOAD
F11READ=EMT!241         ;FILES-11 READ
F11IDR= EMT!243         ;FILES-11 READ HEADER VIA ID#
F11FRD= EMT!244         ;FILES-11 FILE READ
F11FIND=EMT!245         ;FILES-11 FIND
RPFADR= EMT!247         ;RP04 FILES-11 LOGICAL BLOCK # TO CYL/SURF/SECT
DVBPNT= EMT!136         ;%TEST% FILES-11 DEVICE BUFFER PRINT

;*BASIC MACROS

        $$CLIT=$$LITT   ;LITERAL STORAGE ASSIGNMENT

.MACRO  PMSG    $ARG
        $PMSG,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PMSGR  $ARG
        $PMSGR,$$CLIT
                .NLIST  SRC
                $$CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  PNTMSG  $ARG
        MOV  #$$CLIT,R0
        PNTAL
                .NLIST  SRC
                $CLC=.
                .=$$CLIT
                .ASCIZ  %$ARG%
                .EVEN
                $$CLIT=.
                .=$$CLC
                .LIST  SRC
.ENDM

.MACRO  EXIT
        JMP  $EXIT
.ENDM
.MACRO  EXITSKP
        JMP  $EXITS
.ENDM
.MACRO  EXITERR
        JMP  $EXITE
.ENDM
.MACRO  PUSH    A
                .NLIST  SRC
        .IRP  B,<A>
MOV  B,-(SP)    ;PUSH B ON STACK
        .ENDR
                .LIST  SRC
.ENDM

.MACRO  POP    A
                .NLIST  SRC
        .IRP  B,<A>
        MOV    (SP)+,B          ;POP STACK INTO B
        .ENDR
                .LIST SRC
.ENDM

.MACRO  MULT    SOURCE,REG
        PUSH SOURCE             ;REG GETS LO-ORDER 16 BITS
        PUSH REG        ;REG+1 GET HI-ORDER IF REG EVEN #
        MULTPY
        POP    REG
        .NTYPE  X,REG
                .IF    EQ,X&1
        .IFT
        POP    REG+1
                .IFF
        TST    (SP)+
                .ENDC

.ENDM

.MACRO  .LIT    $LTAG,$LARG
                $$CLC=.
                .=$$CLIT
                .EVEN
        $LTAG=.
        .IIF  B,<$LARG>,0
        .IF    NB,<$LARG>
        $LARG
                .ENDC
                .EVEN
                $$CLIT=.
                .=$$CLC
.ENDM

.MACRO  SL      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
        .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASL    REG
                .ENDR
                .IFF
                .REPT  NUM
        ASL  REG
                .ENDR
                .ENDC
                .LIST  SRC
.ENDM

.MACRO  SR      REG,NUM
                .NLIST  SRC
                .IF     GT,NUM-7
                .IFT
        SWAB  REG
                .REPT    NUM-^D8
        ASR    REG
                .ENDR
                .IFF
                .REPT     NUM
        ASR    REG
                .ENDR
                .ENDC
                .LIST    SRC
.ENDM

.MACRO  EXOR    REG,DESTIN,SCRTCH
                .IF    NB,SCRTCH
                .IFT
        MOV      REG,SCRTCH
        BIC    DESTIN,SCRTCH
        BIC     REG,DESTIN
        BIS     SCRTCH,DESTIN
                .IFF
        MOV    REG,-(SP)
        BIC    DESTIN,(SP)
        BIC    REG,DESTIN
        BIS    (SP)+,DESTIN
                .ENDC
.ENDM

;*STANDARD PROGRAM ASSIGNMENTS

STACK=  157776          ;INITIAL STACK POINTER
CONSOL= 100000           ;CONSOLE START ADDRESS
$CONSL= 100014          ;CONSOLE RETURN ADDRESS
$CNTLC= 100004          ;CONSOLE CONTROL C ADDRESS

CBIT=   1               ;CARRY BIT
NBIT=   10              ;NEGATIVE BIT
ZBIT=   4               ;ZERO BIT
VBIT=   2               ;OVERFLOW BIT
TBIT=   20             ;TRAP BIT

;*REGISTER DEFINITIONS

R0=    %0               ;GENERAL REGISTERS
R1=    %1
R2=    %2
R3=    %3
R4=     %4
R5=    %5
R6=    %6
SP=    %6               ;STACK POINTER
PC=    %7               ;PROGRAM COUNTER

;*PDP-11/40 STANDARD TRAP VECTOR ASSIGNMENTS

RESVED=0                ;RESERVED
ERRVEC= 4               ;TIME OUT, BUS ERROR
RESVEC= 10              ;RESERVED INSTRUCTION
TRTVEC= 14              ;BREAK POINT VECTOR
IOTVEC= 20              ;IOT TRAP VECTOR
PWRVEC= 24              ;POWER FAIL TRAP VECTOR
EMTVEC= 30              ;EMT TRAP VECTOR
TRAPVEC=34      ;"TRAP" TRAP VECTOR
TKVEC=  60              ;TTY KEYBOARD VECTOR
TPVEC=  64              ;TTY PRINTER VECTOR
TA11=  260              ;CASSETTETAPE READER
TC11=   214             ;DECTAPE VECTOR
TBITVEC=14
BPTVEC=  14             

;*PDP-11/40 STANDARD ADDRESS ASSIGNMENTS

PS=    177776           ;CPU STATUS
STKLMT= 177774          ;STACK LIMIT
SWR=   177570           ;CONSOLE SWITCH REGISTER
TTODBR=177566           ;TTY OUT DBR
TTOCSR=177564           ;TTY OUT CSR
TTIDBR= 177562          ;TTY IN DBR
TTICSR= 177560          ;TTY IN CSR
XORCR=  174200          
XORSR=  174202

;*BIT ASSIGNMENTS

BIT00=  1
BIT0=   BIT00
BIT01=  2
BIT1=  BIT01
BIT02=  4
BIT2=   BIT02
BIT03=  10
BIT3=   BIT03
BIT04=  20
BIT4=   BIT04
BIT05=  40
BIT5=   BIT05

BIT06=  100
BIT6=   BIT06
BIT07=  200
BIT7=   BIT07
BIT08=  400
BIT8=   BIT08

BIT09=  1000
BIT9=   BIT09
BIT10=  2000
BIT11=  4000

BIT12=  10000
BIT13=  20000
BIT14=  40000

BIT15=  100000

;*PRIORITY ASSIGNMENTS

PR0= 000
PR1= 040
PR2= 100
PR3= 140
PR4= 200
PR5=  240
PR6=  300
PR7= 340

;*ASCII CHARACTER DEFINITIONS

MSWCHR= 030             ;MONITOR TO "KLDCP" SWITCH CHAR, CONTROL X
TEXTERM=0               ;TERMINATES TEXT
TAB=     11             ;TAB
CNTRLI=  11             ;CONTROL-I (TAB)
LF=      12             ;LINE FEED
VT=      13             ;VERTICAL TAB
FF=      14             ;FORM FEED
CR=      15             ;CARRIAGE RETURN
BELL=    7              ;BELL
BLANK=   40             ;BLANK (SPACE)
SPACE=   40             ;SPACE
COMMA=   54             ;COMMA
SLASH=   57             ;SLASH
BKSLH=  134             ;BACK SLASH
BKARW=   137            ;BACK ARROW
XOFF=   023             ;X-OFF     (CONTROL 5)
XON=    021             ;X-ON     (CONTROL Q)
CNTRLO= 017             ;CONTROL O
CNTRLU= 025             ;CONTROL U
CNTRLA= 001             ;CONTROL A
CNTRLC=  003            ;CONTROL C
CNTRLD= 004             ;CONTROL D
CNTRLK= 013             ;CONTROL K
CNTRLL=  14             ;CONTROL L
CNTRLR= 022             ;CONTROL R
CNTRLT= 024             ;CONTROL T
CNTRLX= 030             ;CONTROL X
CNTRLZ= 032             ;CONTROL Z
RUBOUT= 177             ;RUB OUT
ALTMOD= 33              ;ALTMODE
ETB=     27             ;END OF TRANSMISSION BLOCK    (CONTROL W)
NULL=    026            ;NULL FILLER CHAR
SYN=     001            ;COMMUNICATIONS SYNC CHAR (CONTROL A)





.SBTTL  DTE20 DEVICE REGISTER AND BIT DEFNINTIONS, 27-MAY-76

DTEADR= 174400          ;ADDRESS OF (FIRST) DT20 DEVICE REGISTER BLOCK
DTESIZ= 000040          ;SPACING BETWEEN CONSCUTIVE DTE20'S
DTEMAX= 4               ;MAXIMUM NUMBER OF DTE20'S ON ONE PDP-11
DTESZS= 5               ;SHIFT TO CONVERT DTE ADDRESS TO DTE #

;OFFSETS FROM THE BASE OF THE DTE20 DEVICE REGISTER BLOCK
;TO SPECIFIC 10/11 INTERFACE RAM LOCATIONS AND REGISTERS.

;THE FIRST 12 REGISTERS ARE NOT INITIALIZED BY "INIT" (BECAUSE THEY ARE IN RAMS)


DLYCNT=  00             ;DELAY COUNT            (ADDRESS XXXX00)
DEXWD3= 02              ;DEPOSIT OR EXAMINE WORD 3      (ADDRESS XXXX02)
DEXWD2= 04         ;DEPOSIT OR EXAMINE WORD 2      (ADDRESS XXXX04)
DEXWD1= 06              ;DEPOSIT OR EXAMINE WORD 1      (ADDRESS XXXX06)
TENAD1= 10              ;10 ADDRESS WORD 1 FOR DEX      (ADDRESS XXXX10)
TENAD2= 12              ;10 ADDRESS WORD 2 FOR DEX
TO10BC= 14              ;TO10 BYTE COUNT                (ADDRESS XXXX14)
TO11BC= 16              ;TO11 BYTE COUNT        (ADDRESS XXXX16)
TO10AD= 20              ;TO10 PDP11 MEMORY ADDRESS      (ADDRESS XXXX20)
TO11AD= 22              ;TO11 PDP11 MEMORY ADDRESS      (ADDRESS XXXX22)
TO10DT= 24              ;TO10 PDP11 DATA WORD           (ADDRESS XXXX24)
TO11DT= 26              ;TO11 PDP11 DATA WORD           (ADDRESS XXXX26)

;THE LAST 4 REGISTERS ARE INITIAALIZED BY "INIT" (BECAUSE THEY ARE IN FLIP-FLOPS)

DIAG1= 30               ;DIAGNOSTIC WORD 1              (ADDRESS XXXX30)
DIAG2= 32               ;DIAGNOSTIC WORD 2              (ADDRESS XXXX32)
STATUS= 34              ;10/11 INTERFACE STATUS WORD    (ADDRESS XXXX34)
DIAG3= 36               ;DIAGNOSTIC WORD 3              (ADDRESS XXXX36)


;THE ADDRESSES OF THE DTE20 INTERRUPT VECTORS

DTEIV0= 774             ;INTERRUPT VECTOR FOR DTE20 #0
DTEIV1 = 770            ;INTERRUPT VECTOR FOR DTE20 #1
DTEIV2= 764             ;INTERRUUPT VECTOR FOR DTE20 #2
DTEIV3= 760             ;INTERRUPT VECTOR FOR DTE20 #3

;BIT ASSIGNMENTS FOR 10/11 INTERFACE REGISTERS

;BIT ASSIGNMENTS FOR TENAD1

PHYS=   BIT15           ;EXAMINE/DEP PHYSICAL ADDRESS
USEVIR= BIT14!BIT13             ;EX/DP USER VIRTUAL ADDRESS
XUPT=    BIT14          ;EX/DP VIA USER PROCESS TABLE
EXVIRT= BIT13           ;EX/DP EXEC VIRTUAL ADDRESS
DEP=     BIT12          ;MODE BIT FOR DEPOSIT (0=EXAMINE)
PRTOFF= BIT11           ;PROTECT OFF
XEPT=    0              ;EX/DP VIA EXEC PROCESS TABLE

;BIT ASSIGNMENTS FOR T011BC

INT10=   BIT15          ;SET DONE AND INTERRUPT BOTH 10 AND 11
ZSTOP=   BIT14          ;STOP ON NULL (ZERO) CHARACTER
BYTE2=   BIT13          ;TWO EIGHT BIT BYTES PER WORD
TO11BM=  BIT13          ;TO-11 BYTE MODE

;BIT ASSIGNMENTS FOR DIAG1 (WRITE)

DS00=    BIT15          ;DIAGNOSTIC STATUS
DS01=    BIT14          ;"
DS02=    BIT13          ;"
DS03=    BIT12          ;"
DS04=    BIT11          ;"
DS05=    BIT10          ;"
DS06=    BIT9           ;"
DFUNC=   BIT7          ;DOING DIAGNOSTIC FUNCTION (DFRD,DFWRT,DFXCT)
PULSE= BIT4!BIT5                ;SINGLE PULSE THE 10/11 CLOCK (ALSO SETS
                        ;10/11 DIAGNOSTIC CODE)
DCOMST= BIT0            ;DIAGNOSTIC COMMAND START 
DCSRT=   BIT0           ;DIAGNOSTIC COMMAND START (NEW NAME FOR DCOMST)
DSEND=   BIT2           ;SEND THE EBUS DURING DIAGNOSTIC FUNCTION
DIKL10= BIT3            ;KL10 DIAGNOSTIC MODE
D1011=   BIT5           ;10/11 INTERFACE DIAGNOSTIC MODE

;BIT ASSIGNMENTS FOR DIAG1 (READ)

TO10=    BIT7           ;INTERFACE MAJOR STATE = TO10 TRANSFER
DEX=     BIT8           ;  "          "     "  = DEPOSIT OR EXAMINE
TO11=    BIT6           ;   "          "     "  = TO11 TRANSFER
VEC04=   BIT4           ;VECTOR INTERRUPT ADDRESS BIT 4
VEC03=   BIT3           ;   "         "         ""   3
VEC02=   BIT2           ;  "         "        "      " 2
HALTLP= BIT9            ;EBOX IS IN HALT LOOP
KLRUN=  BIT10           ;RUN FLOP, KL IS EXECUTING INSTRUCTIONS
ERRSTP= BIT11           ;EBOX CLOCK STOPPED DUE TO ERROR

;BIT ASSIGNMENTS FOR DIAG2 (WRITE)

EDONES= BIT14           ;SET EBUS DONE
DRESET= BIT6            ;PERFORM DIAGNOSTIC CLEAR

;BIT ASSIGNMENTS FOR DIAG2 (READ)

;BIT ASSIGNMENTS FOR DIAG3 (WRITE)

SCD=      BIT5          ;SHIFT CAPTURED DATA(PARITY ERROR DATA)
CDD=     BIT4           ;CLEAR DUPE & DURE ERROR FLAGS
WEP=     BIT3           ;WRITE EVEN (BAD) PARITY
CNUPE=  BIT1            ;CLEAR NUPE
TO10BM= BIT0            ;TO-10 TRANSFER BYTES FROM THE 11

;BIT ASSIGNMENTS FOR DIAG3 (READ)

RFMAD0= BIT15           ;RFM ADDRESS BIT 0
RFMAD1= BIT14           ; "     "     "  1
RFMAD2= BIT13           ; "     "    "  2
RFMAD3= BIT12           ; "     "     "  3

;BIT ASSIGNMENTS FOR DIAG3 (READ)

SWSLF1= BIT15           ;SWAP SELECT LEFT
CAB08=  BIT14           ;CAPTURED UNIBUS ADDRESS BIT 08
DUPE=    BIT4           ;DATO UNIBUS PARITY ERROR
DURE=    BIT2           ;DATO UNIBUS RECIEVER ERROR
NUPE=    BIT1           ;NPR UNIBUS PARITY ERROR
UPECD=  BIT13!BIT12!BIT11!BIT10!BIT9    ;UNIBUS PARITY ERR,CAPTURED DATA

;BIT ASSIGNMENTS FOR STATUS (WRITE)

DON10S= BIT15           ;SET TO10 DONE
DON10C= BIT14           ;CLEAR TO10 DONE
ERR10S= BIT13           ;SET TO10 ERROR
ERR10C= BIT12           ;CLEAR TO10 ERROR
INT11S= BIT11           ;SET 10 REQ INTERRUPT (INTERRUPTS 11)
INT11C= BIT10           ;CLEAR 10 REQ INTERRUPT (REMOVES INTERRUPT TO 11)
PERCLR= BIT9            ;CLEAR -11 MEMORY PARITY ERROR
INT10S= BIT8            ;SET REQUEST 10 INTERRUPT (INTERRUPTS 10)
DON11S= BIT7            ;SET TO11 DONE
DON11C= BIT6            ;CLEAR TO11 DONE
INTRON= BIT5            ;ENABLE DTE20 TO INTERRUPT THE 11
EBUSPC= BIT4            ;CLEAR EBUS PARITY ERROR
INTROF= BIT3            ;DISABLE THE DTE20 11-INTERRUPTS
EBUSPS= BIT2            ;SET EBUS PARITY ERROR
ERR11S= BIT1            ;SET TO11 ERROR
ERR11C= BIT0            ;CLEAR TO11 ERROR

;BIT ASSIGNMENTS FOR STATUS (READ)

TO10DN= BIT15           ;TO10 DONE
TO10ER= BIT13           ;TO 10 ERROR (NPR TIMEOUT OR BUS ERROR)
RAMISO= BIT12           ;DATA OUT OF DTE RAM IS AL OS (RFM=0)
TO11DB= BIT11           ;10 REQUESTING 11 INTERRUPT (DOORBELL FROM 10)
DXWRD1= BIT10           ;DEPOSIT OR EXAMINE WORD ONE
D11MPE= BIT9            ;-11 MEMORY PARITY ERROR
TO10DB= BIT8            ;REQUEST 10 INTERRUPT (DOORBELL FROM 11)
TO11DN= BIT7            ;TO11 DONE
EBSEL=  BIT6            ;E BUFFER SELECT
NULSTP= BIT5            ;NULL STOP
BPARER= BIT4            ;EBUS PARITY ERROR
RM=     BIT3            ;THIS DTE20 IN RESTRICTED MODE
DEXDON= BIT2            ;DEPOSIT OR EXAMINE DONE
TO11ER=BIT1             ;TO 11 ERROR (NPR TIMEOUT OR BUS ERROR)
INTSON= BIT0            ;INTERRUPTS ON, DTE20 ENABLED TO INTERRUPT 11

;*KL10 DIAGNOSTIC FUNCTION DEFINITIONS

;CLOCK CONTROL FUNCTIONS

STPCLK= 000             ;STOP CLOCK
STRCLK=  001            ;START CLOCK
SSCLK=   002            ;SINGLE STEP THE MBOX CCLOCK
SECLK= 003              ;SINGLE STEP EBOX CLOCK
CECLK=  004             ;CONDTIONAL EBOX CLOCK
CLRMR=  006             ;CLEAR MR RESET
SETMR=  007             ;SET MR RESET
BRCLK=  005             ;BURST THE BLOCK

;CLOCK LOAD FUNCTIONS

LDBRR=  42              ;LOAD BURST REGISTER RIGHT HALF
LDBRL=  43              ;LOAD BURST REGISTER LEFT HALF
LDSEL=  44              ;LOADSOURCE AND RATE SELECTS
LDDIS=  45              ;LOAD EBOX CLOCK DISTRIBUTION REGISTER
LDCHK1= 46              ;LOAD PARITY CHECK REGISTER (ENABLE BAD PARITY STOP)
LDCHK2=  47             ;LOAD EBOX INTERNAL CHECK REGISTER

;DRAM FUNCTIONS

LDRAM1= 60              ;LOAD A & B FIELDS EVEN
LDRAM2= 61              ;LOAD A & B FIELDS ODD
LDRAM3= 62              ;LOAD COMMON J1-J4
LDRJEV= 63              ;LOAD PARITY & J8-J10 EVEN
LDRJOD= 64              ;LOAD PARITY & J8-J10 ODD
DRAMAB= 133             ;READ D-RAM A & B
DRJ710= 135             ;READ D-RAM J7-J10
DRJ1.4= 134             ;READ D-RAM J1-J4

;IR DRAM CONTROL

DISIOJ= 65              ;DISABLE 7XX & JRST=254
DISACF= 66              ;DIABLE THE IR AC"C
ENIOJA= 67              ;ENABLE 7XX, JRST=254 & IR AC'S

;CRAM FUNCTIONS

LCRAM1= 57      ; LOAD C-RAM DATA
LCRAM2= 56
LCRAM3= 55
LCRAM4= 54
LCRAM5= 53
LCRDAL= 52      ;LOAD CRAM ADDRESS LEFT (00-04)
LCRDAR= 51      ;LOAD CRAM ADDRESS RIGHT (05-10)
RCRAM1= 147     ;READ C-RAM DATA
RCRAM2= 146
RCRAM3= 145
RCRAM4= 144
RCSPEC= 141     ;READ C-RAM SPEC

;MISC CONTROL FUNCTIONS

IRLOAD= 14      ;LOAD THE IR FROM AD
DRLTCH= 15      ;LOAD D-RAM LATCHES
CLRRUN= 10      ;CLEAR RUN FLIP-FLOP
SETRUN= 11      ;SET RUN FLIP-FLOP
CONBUT= 12      ;THE CONTINUE BUTTON
LDAR=   77      ;LOAD THE AR

;MBOX CONTROL FUNCTIONS

LDMBXA= 71      ;LOAD MEMORY TO CACHE SELECTOR
LDCHAN= 70      ;LOAD CHANNEL DIAGNOSTIC CONDITIONS

;PI CONTROL FUNCTIONS

READ0= 100      ;PI     (READ STATUS0)
READ1= 101      ;PI     (READ STATUS 1)
READ2= 102      ;PI     (READ STATUS 2)
READ3= 103      ;PI     (READ STATUS 3)

;DATA PATH CONTROL FUNCTIONS

DPAR    =120     ; AR
DPBR    =121     ; BR
DPMQ    =122    ; MQ
DPFM    =123    ; FM
DPFMA    =114     ; FM ADR
DPBRX    =124     ; BRX
DPARX    =125     ; ARX
DPADX    =126     ; ADX
DPAD    = 127     ; AD
DPPC    =153     ; PC
DPVMA   =157     ; VMA
DPVMHD   =157     ; VMA HELD
DPADB    =153     ; ADDRESS BREAK
DPERG    =167     ; E-BUS REGISTER
DPFE    =132     ; FE 05-09
DPFE1    =133     ; FE 00-04
DPSC    =130      ; SC 05-09
DPSC1    =131     ; SC 00-04

.SBTTL  KL10 EBOX MACRO DEFINITIONS, 27-MAY-76

;MACRO TO TURN 36 BIT WORDS INTO 5 UPSIDE DOWN BYTES

.MACRO WD36    A,B,C
  .NLIST    SRC
  .BYTE <377&C>,<<<C&7400>/400>!<<B&17>*20>>,<<B&7760>/20>
  .BYTE <A&377>,<<A&7400>/400>
  .LIST    SRC
.ENDM

;PDP10 CPU INSTRUCTION MACRO. TAKES 5 ARGUMENTS AS IN NORMAL
;10 CODE. 5 FIELDS MUST BE PRESENT (4 FIELD SEPARATIONS)
;BUT THE AD,AC,I, AND XR FIELDS MAY BE LEFT BLANK AND IF SO,
;WILL ASSEMBLE AS ZERO.  THE OP FIELD MUST NOT BE LEFT BLANK.

.MACRO  I10    OP,CAC,CI,CAD,CXR
       ADH=0
       ADL=0
  .IF    NB,CAD
  .IRPC AD1,CAD
  .IIF  GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
  .ENDC
  .IIF B,CAC,AC=0
  .IIF NB,CAC,AC=CAC
  .IIF B,CI,I=0
  .IIF NB,CI,I=CI
  .IIF B,CXR,XR=0
  .IIF NB,CXR,XR=CXR
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<AC&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <OP&37*10+<AC/2>>,<OP/40>
.LIST    SRC
.ENDM    I10

;MACRO TO GENERATE A RIGHT JUSTIFIED 3-BYTE VALUE
;FOR A 22-BIT ARGUMENT

.MACRO  WD22     AD
  ADH=0
  ADL=0
  .IRPC AD1,AD
  .IIF  GE,<ADL-10000>,ADH=<10*ADH>+<ADL/10000>
  ADL=10*<ADL&7777>+AD1
.ENDM
.NLIST  SRC
.BYTE  <ADL&377>,<<ADL/400>!<ADH*200&377>>,<ADH/2>
.LIST  SRC
.ENDM  WD22

;PDP10 I/O INSTRUCTION MACRO. TAKES 5 ARGUMENT AS NOTED ABOVE
;IN THE DESCRIPTION OF THE I10 MACRO. THE 8 I/O OP CODES ARE
;DEFINED AS ARE DEVICE CODES APR, PI, PAG, CCA, TIM, AND MTR.
;IN ADDITION, 1010 WILL HANDLE THE 16 COMMON "FUNNY INSTRUCTIONS" (SUCH
;AS APRID).  TO USE THIS FEATURE PLACE THE MNEUMONIC IN THE INSTRUCTION
;FIELD AND LEAVE THE DEVICE FIELD EMPTY.

BLKO=2
DATAO=3
BLKI=0
DATAI=1
CONO=4
CONI=5
CONSZ=6
CONSO=7
APR=0
PI=4
PAG=10
CCA=14
TIM=20
MTR=24

$APRID=BLKI
$WRFIL=BLKO
$RDERA=BLKI
$SBDIAG=BLKO
$CLRPT=BLKO
$SWPIA=DATAI
$SWPVA=BLKO
$SWPUA=DATAO
$SWPIO=CONI
$SWPVO=CONSZ
$SWPUO=CONSO
$RDPERF=BLKI
$RDTIME=DATAI
$WRPAE=BLKO
$RDMACT=BLKI
$RDEACT=DATAI

$$APRID=APR
$$WRFIL=APR
$$RDERA=PI
$$SBDIAG=PI
$$CLRPT=PAG
$$SWPIA=CCA
$$SWPVA=CCA
$$SWPUA=CCA
$$SWPIO=CCA
$$SWPVO=CCA
$$SWPUO=CCA
$$RDPERF=TIM
$$RDTIME=TIM
$$WRPAE=TIM
$$RDMACT=MTR
$$RDEACT=MTR

.MACRO  IO10    OP,DV,CI,AD,CXR
  I=0
  .IIF NB,CI,I=CI
  XR=0
.IIF  NB,CXR,XR=CXR
  .IF B,DV
  XOP=$'OP
XDV=$$'OP
  .IFF
  XOP=OP
  XDV=DV
  .ENDC
        ADH=0
        ADL=0
  .IRPC AD1,AD
.IIF GE,<ADL-10000>,ADH=ADL/10000
  ADL=10*<ADL&7777>+AD1
  .ENDM
.NLIST  SRC
  .BYTE <ADL&377>,<<ADL/400>!<ADH*200&377>>,<XOP&1*200+<I*100+<XR*4>>+<ADH/2>>
  .BYTE <XDV&374+<XOP/2>>,<XDV/400+16>
.LIST  SRC
.ENDM  IO10

;THIS IS A MACRO TO WAIT FOR A DONE FLAG

.MACRO WFZERO BITSEL
        MOV  #^D2500,-(SP)      ;SET TIMEOUT CNT
  91$:  BIT    #BITSEL,@.DIAG1  ;TEST BIT
        BEQ    92$      ;LEAVE IF BIT ZERO(OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    91$             ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    92$
        JSR    R1,$DFTIM
  92$.  TST    (SP)+    ;RESET STACK & CONTINUE
.ENDM


;THIS MACRO IS A WAIT FOR FLAG MACRO.
;IT WAITS FOR A TEST BIT TO GO TO ONE
;FROM A ZERO

.MACRO WFONE BITSEL
        MOV    #^D2500,-(SP)    ;SET TIMEOUT CNT
  93$:  BIT    #BITSEL,@.STDTE  ;TEST BIT
        BNE    94$      ;LEAVE IF NOW A ONE (OK)
        DEC    (SP)     ;DECREMENT CNT
        BNE    93$      ;CONTINUE LOOP
        TST    RPTFLG   ;OTHERWISE TIME OUT
        BNE    94$
        JSR        R1,$DFTIM
  94$:  TST    (SP)+    ;RESET STACK
.ENDM

.SBTTL  KW11 DEVICE REGISTERS AND BIT DEFINITIONS, 27-MAY-76

KWLIV= 100              ;VECTOR ADDRESS

KWLKS=  177546          ;LINE CLOCK STATUS DEVICE ADDRESS

KWLKE=  100             ;LINE CLOCK INTERRUPT ENABLE BIT

.SBTTL  MM11 DEVICE REGISTERS AND BIT ASSIGNMENTS, 27-MAY-76

MMLPIV=  114            ;VECTOR ADDRESS

MMLPBA=  172100         ;1ST MM11-LP DEVICE ADDRESS
MMLPEA=  172136         ;LAST MM11-LP DEVICE ADDRESS

MMERRF=  BIT15          ;ERROR FLAG

MMADDM=  7740           ;ADDRESS MASK
MMADDS=  5              ;ADDRESS SHIFT

MMWWP=  BIT2            ;WRITE WRONG PARITY
MMPIE=  BIT0            ;PARITY INTERRUPT ENABLE

.SBTTL  *MMAC*  MBOX MACRO LIBRARY 26-OCT-76

.REM    %
        KL10 AC DEFINITIONS %
        
        AC0=    000000
        AC1=    000001
        AC2=    000002
        AC3=    000003
        AC4=    000004
        AC5=    000005
        AC6=    000006
        AC7=    000007
        AC10=   000010
        AC11=   000011
        AC12=   000012
        AC13=   000013
        AC14=   000014
        AC15=   000015
        AC16=   000016
        AC17=   000017
.REM    %
        KL10 INSTRUCTION OP CODES
        %
MOVE=   200
MOVEI=  201
MOVEM=  202
LSH=    242
BLT=    251
AOBJN=  253
JRST=   254
XCT=    256
ADD=    270
ADDI=   271
SUB=    274
SUBI=   275
CAIE=   302
CAIN=   306
CAME=   312
JUMPL=  321
JUMPGE= 325
JUMPN=  326
SKIP=   330
SKIPE=  332
AOS=    350
SOJGE=  365
SOJG=   367
SETZM=  402
ANDI=   405
IOR=    434
IORI=   435
SETOM=  476
HRLI=   505
HLLZS=  513
HRLZI=  515
HRRI=   541
HRRZI=  551
HRRZM=  552
TRNE=   602
TLNE=   603
TRNN=   606
TLNN=   607
TRZ=    620
TRZN=   626
TRC=    640
TRCE=   642


.REM    %
        GENERATES A TABLE ENTRY TO IDENTIFY A DIAGNOSTIC
FUNCTION FOR USE BY CMP.S AND S10.
%
.MACRO  DF.     D
.NLIST  SRC
                .BYTE 200!D
.LIST   SRC
.ENDM

.REM    %
        GENERATES TABLE ENTRIES TO IDENTIFY BITS OF DIAGNOSTIC
FUNCTIONS TO BE TESTED BY CMP.S AND S10.  ORDER IS MSB TO LSB.  A NEGATIVE VALUE 
INDICATES THE TABLE END.
%
.MACRO  BP.     B
.IRP    B1,<B>
        B10=^D'B1
F=0
.IF     LT      B10
BX=-B10
F=1
.IFF
BX=B10
.ENDC
B11=^D35-BX
W11=B11/^D16
P11=B11-<W11*^D16>
.NLIST  SRC
                .BYTE <F*100>!<P11*4>!<W11>
.LIST   SRC
.ENDM
.ENDM


;SEQ139

.REM    %
        MACRO TO ENCODE DIAGNOSTIC FUNCTION, BIT NUMBER & FLAVOR
INTO A PDP11 WORD.
%
.MACRO  S10.    A,B,C
.NLIST
        .NARG   XXX
        .IF     EQ <XXX-1>
          .WORD A
        .IFF
        .IF     EQ      C
        BP.     B
        .IFF
        BP.     -B
        .ENDC
        DF.     A
        .ENDC
.LIST
.ENDM   S10.

.REM    %
PDP10 DIAGNOSTIC DATA BIT TEST ROUTINE.  ARGUMENT IS PDP10
BIT NUMBER OF A WORD LOCATED IN THE DTE20 DEXWDS.
%
.MACRO  TBIT    N
BB=^D'N+12.
BBD=BB/16.
BM=1
.REPT <15.-<BB-<16.*BBD>>>
BM=BM+BM
.ENDM
.NLIST  SRC
          MOV   #^D'N,ERBIT
          BIT   #BM,@<.DAT1-<2*BBD>>
.LIST   SRC
.ENDM   TBIT


;SEQ140

.REM    %
        MACROS TO GENERATE 11-BYTE C-RAM DATA FROM MICRO COMPILER
FIELDS.
%

        .MACRO V ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<X6&8400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        BOO.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   V

        .MACRO U ADDR,X1,X2,X3,X4,X5,X6,X7
.NLIST  SRC
        B72.79=<<X5&100>*^D2>!<<X2&4000>/^D64>!<<X5&40>/^D4>!<<X5&20>/^D8>
        B64.71=<<X3&2000>/^D8>!<<X3&1000>/^D16>!<<X3&200>/^D16>!<<X3&100>/^D32>
        B56.63=<<X3&7>*^D32>!<<X6&100>/^D4>!<X4&10>!<X4&2>
        B48.55=<<X5&17>*^D16>!<<X3&40>/^D4>!<<6&400>/^D64>!<<X3&20>/^D8>!<<X6&200>/^D12
        B40.47=<X4&300>!<<X4&20>*^D2>!<<X5&200>/^D16>!<<X3&4000>/^D512>!<<X5&3000>/^D512
        B32.39=<<X2&1>*^D128>!<<X7&70>*^D2>!<<X3&400>/^D32>!<X7&7>
        B24.31=<<X2&2000>/^D8>!<<X2&70>*^D2>!<<X2&2>*^D4>!<<X7&700>/^D64>
        B16.23=<<X3&10>*^D16>!<<X6&7000>/^D32>!<<X2&1700>/^D64>
        B08.15=<X1&377>
        B00.07=<<X4&400>/^D2>!<<X4&7000>/^D32>!<<X4&1>*^D8>!<<X1&3400>/^D256>
        BDS0.4=<X6&77>
        .BYTE   B72.79,B64.71,B56.63
        .BYTE   B48.55,B40.47,B32.39
        .BYTE   B24.31,B16.23,B08.15
        .BYTE   B00.07,BDS0.4
.LIST   SRC
        .ENDM   U


;SEQ141

.MACRO  NUMARG  A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
        .NARG   $$NARG
        .ENDM   NUMARG

.REM    %
        MEM DATA MACRO.  GENERATES A TABLE FOR IDENTIFYING A MEMORY REQUEST.
THE FIRST BYTE IS LEFT JUSTIFIED EXPECTED BIT VALUES FOR RQ0,RQ1,RQ2, RD & WR
REQUESTS.  THE NEXT 3 BYTES ARE THE EXPECTED SBUS ADDRESS.
%
.MACRO  MEMTAB  ADR,LST
        RQ0=200
        RQ1=100
        RQ2=40
        RQ3=20
        RD=10
        WR=4
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE <LOR>   ;REQUEST DATA
        
.LIST   SRC
        WD22    ADR     ;ADDRESS
.ENDM   MEMTAB


;SEQ142

.REM    %
        THIS SECTION CONTAINS A COLLECTION OF MACROS FOR USE IN ISOLATION
ROUTINES OF THE PDP-11 BASED PROCESSOR DIAGNOSTICS.
THIS IS A SCHEME FOR MANAGING BOARD-CALLOUT INFORMATION.  THE
BASIS OF THE SYSTEM IS A FOUR-WORD TABLE WHICH MAY BE MANIPULATED
BY THE USER.  SEVEN BYTES OF THE TABLE ARE A BITWISE MAPPING OF THE
PROCESSOR BACKPLANE.  WHILE THE EIGHTH BYTE INDICATES THE MOST LIKELY
FAILING BOARD OF A GROUP OF BOARDS.  A TYPEOUT ROUTINE IS PROVIDED
WHICH INTERPRETS SUCH A TABLE, PRINTING THE IDENTIFICATION OF
ALL BOARDS FOR WHICH THERE IS A ONE-BIT IN THE TABLE.  THIS TABLE
IS REFERRED TO AS A "UML TABLE", AFTER THE ENGINEERING "UML" OR
UTILIZATION MODULE LIST.  THAT IS THE DOCUMENT WHICH SHOWS WHAT
BOARD GOES WHERE IN THE BACKPLANE.  THE TYPEOUT ROUTINE IS CALLED
"PNTUML".

        THE MACROS PROVIDED PERMIT GENERATING SUCH UML TABLES AT
ASSEMBLY TIME OR, ALTERNATIVELY, CREATING A TABLE DURING THE
RUNNING OF THE ISOLATION ROUTINE, OR A COMBINATION OF ACTIONS.
THE MACROS TAKE SLOT NUMBERS AS ARGUMENTS AND DO ALL THE NECCESSARY
BIT-FIDDLING.

        THE PRINT ROUTINE SCANS THE UML TABLE SUPPLIED AS A CALLING 
ARGUMENT, LOOKING FOR ONE-BITS.  WHEN ONE IS FOUND, ITS POSITION IS
CONVERTED TO A SLOT NUMBER.  THE SLOT NUMBER INDEXES A TABLE WHERE
THE M# FOR THE BOARD BELONGING TO THAT SLOT IS FOUND.  SLOTS
CONTAINING CABLES OR EMPTY SLOTS ARE RECOGNIZED AS SUCH.  THERE ARE UP TO THREE
CALLOUTS PRINTED PER LINE.  A CALLOUT LOOKS LIKE THIS:

        M8523,SLOT 38.

38 IS THE SLOT NUMBER.  M8523 IS, OF COURSE, THE M# OF THE BOARD IN
THAT SLOT.
        IN A MULTI-BOARD CALLOUT, ONE MODULE IS FLAGGED AS THE
MOST LIKELY OR MOST PROBABLE FAILING BOARD:

BACKPLANE: 4.  M8523,SLOT 38.  M8510,SLOT 46.** M8512,SLOT 53.
        **HIGHEST PROBABILITY OF FAILURE

        AS AN EXAMPLE OF THE MACROS, TO PRODUCE THE LATTER TYPEOUT
ONE COULD CREATE A UML TABLE AT ASSEMBLY TIME USING THE "UML" MACRO:

        TABLE1: UML     <46,53,38>

        WHERE THE ARGUMENT IS A LIST OF SLOT NUMBERS FOR THE BOARDS
YOU WANT CALLED OUT, WITH THE MOST LIKELY BOARD FIRST.  THE ORDER
OF THE REMAINING BOARDS IS NOT SIGNIFICANT.  THIS LISTING CONTAINS
AND M#'S INTO SLOTS.


;SEQ143

        NOTE THAT THE BACKPLANE NUMBER DEFAULTS TO 4, THE CPU BACKPLANE.
THIS  DEFAULT MAY BE CHANGED AT ASSEMBLY TIME BY $DFTBP=?, WHERE ? IS
THE NEW DEFAULT.  IT MAY BE CHANGED DYNAMICALLY BY TRAP "BACKPLANE" WITH
THE NEW # IN R0.  IT IS RESET TO THE ASSEMBLY DEFAULT BEFORE THE
ONE TIME INIT.

        TO PRINT, USE THE "PNTUML" MACRO:

        PNTUML  TABLE1

        A TABLE MAY BE BUILT OR MODIFIED DURING THE 
ISOLATION ROUTINE EXECUTION BY USING THE "SSET", "SCLR", AND
"SETUP" MACROS.  THESE MACROS TAKE TWO ARGUMENTS, THE FIRST IS THE
SLOT NUMBER.  THE SECOND IS THE ADDRESS OF THE TABLE.  THE ADDRESS
CAN BE IN THE FORM 'ADDRESS, OR '(RN)' IF THE ADDRESS IS
IN A REGISTER.
A BELOW IS A SUMMARY OF THEIR ACTIONS:


        SSET    SS,1    ;SET THE FLAG FOR SLOT SS IN TABLE T
        SCLR    SS,T    ;CLEAR (DITTO)
        SETHP   SS,T    ;MAKE THE BOARD IN SLOT SS, THE MOST
                        ;PROBABLE FAILURE IN TABLE T.

        NOTE:  WHEN A SLOT'S FLAG IS SET, PNTUML WILL PRINT THE
        BOARD IDENTIFIER FOR THAT SLOT.
        SETHP STORES THE SLOT NUMBER IN BYTE 1+6
        WHERE IT IS USED BY THE TYPEOUT ROUTINE TO FLAG THE HIGH 
        PROBABILITY BOARD.


        FOR COMPLETENESS, A MACRO IS PROVIDED FOR TESTING A SLOT'S FLAG BIT
        IN A UML TABLE:

        STST    SS,T    ;DOES A BIT TEST OF THE FLAG BIT FOR SLOT
                        ;SS IN TABLE T.

        FINALLY, A MACRO IS PROVIDED TO DYNAMICALLY SET THE BACKPLANE NUMBER.
THE MACRO IS "BACKPLANE" (TRUNCATED TO BACKPL) AND IS USED AS
FOLLOWS:
        BACKPL  X
        NXTINSTR

        IF X (THE NEW BACKPLANE) ISN'T GIVEN, IT IS ASSUMED ALREADY
LOADED IN THE RHE OF R0.
%

;SEQ144

.SBTTL          UTILIZATION MODULE LISTS
.REM    %
SLOT    BOARD   DESCRIPTION     (BACKPLANE 01, DMA/DIA)
-----------------------------------------------------------------
01      CABLE   SBUS    CABLE
02      M8563   DMA20   CONTROL
03      M8560   DMA20   SBUS    INTERFACE
04      M8558   DMA20   KBUS    0 ADAPTER, BITS 0-17 & PAR
05      M8558   DMA20   KBUS    0 ADAPTER, BITS 18-35
06      M8558   DMA20   KBUS    1 ADAPTER, BITS 0-17 & PAR
07      M8558   DMA20   KBUS    1 ADAPTER, BITS 18-35
08      M8558   DMA20   KBUS    2 ADAPTER, BITS 0-17 & PAR
09      M8558   DMA20   KBUS    2 ADAPTER, BITS 18-35
10      M8558   DMA20   KBUS    3 ADAPTER, BITS 0-17 & PAR
11      M8558   DMA20   KBUS    3 ADAPTER, BITS 18-35
12      SPARE
13      M8550   DIA20   DATA PATH
14      M8550   DIA20   DATA PATH
15      M8551   DIA20   CONTROL
16      CABLE   EBUS CABLE

SLOT    BOARD   DESCRIPTION     (BACKPLANE 02, DTE20/RH20)
-----------------------------------------------------------------
01      CABLE   EBUS CABLE
02      M8559   CDS
03      M8554   DTE20 UNIBUS BR & NPR CONTROL
04      M8553   DTE20 CONTROL
05      M8552   DTE20 DATA PATH
06      SPARE
07      SPARE
08      SPARE
09      SPARE
10      CABLE   EBUS CABLE

NOTE THAT MA20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MA20)
-------------------------------------------------------------------

01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8562   "MAT" TIMING (MA20 0,2)
02      G235    X-Y DRIVER
03      H217B   CORE STACK      >SM 0,0-17
        
04      G114    SENSE-INHIBIT   /
05      G235    X-Y DRIVER      \
06      H217B   CORE STACK      >SM 1, 0-17
07      G114    SENSE-INHIBIT   /
08      G235    X-Y DRIVER      \
09      H217B   CORE STACK      >SM 2, 0-17
10      G114    SENSE-INHIBIT   /
11      G235    X-Y DRIVER      \
12      H217B   CORE STACK      >SM 3, 0-17
13      G114    SENSE-INHIBIT   /


;SEQ145

14      G235    X-Y DRIVER      \
15      H217B   CORE STACK      >SM 0, 18-PAR
16      G114    SENSE-INHIBIT   /
17      G235    X-Y DRIVER      \
18      H217B   CORE STACK      >SM 1, 18-PAR
19      G114    SENSE-INHIBIT   /
20      G235    X-Y DRIVER      \
21      H217B   CORE STACK      >SM 2, 18-PAR
22      G114    SENSE-INHIBIT   /
23      G235    X-Y DRIVER      \
24      H217B   CORE STACK      >SM 3, 18-PAR
25      G114    SENSE-INHIBIT   /
26      M8561   CONTROL "MAC"   (MA20 0,2)
27      SPARE
28      SPARE
29      M8561   CCONTROL "MAC"  (MA20 1,3)
30      G235    X-Y DRIVER      \
31      H217B   CORE STACK      >SM 0, 0-17
32      G114    SENSE-INHIBIT   /
33      G235    X-Y DRIVER      \
34      H217B   CORE STACK      >SM 1, 0-17
35      G114    SENSE-INHIBIT   /
36      G235    X-Y DRIVER      \
37      H217B   CORE STACK      >SM 2, 0-17
38      G114    SENSE-INHIBIT   /
39      G235    X-Y DRIVER      \
40      H217B   CORE STACK      >SM 3, 0-17
41      G114    SENSE-INHIBIT   /
42      G235    X-Y DRIVER      \
43      H217B   CORE STACK      >SM 0, 18-PAR
44      G114    SENSE-INHIBIT   /
45      G235    X-Y DRIVER      \
46      H217B   CORE STACK      >SM 1, 18-PAR
47      G114    SENSE-INHIBIT   /
48      G235    X-Y DRIVER      \
49      H217B   CORE STACK      >SM 2, 18-PAR
50      G114    SENSE-INHIBIT   /
51      G235    X-Y DRIVER      \
52      H217B   CORE STACK      >SM 3, 18-PAR
53      G114    SENSE-INHIBIT   /
54      AB      M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8562   "MAT" TIMING (MA20 1,3)

NOTE THAT MB20 CONTROLLERS 0&1 OCCUPY BACKPLANE 05, 2&3 ON BACKPLANE 03,
AND THAT EVEN CONTROLLERS USE SLOTS 1-27, ODD CONTROLLERS 28-54.

SLOT    BOARD   DESCRIPTION     (BACKPLANES 3 & 5, MB20)
------------------------------------------------------------------------
01 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
01 EF   M8565   "MAT" TIMING (MB20 0,2)
02      G236    X-Y DRIVER
03      H224B   CORE STACK      >SM 0, 0-17


;SEQ146

04      G116    SENSE-INHIBIT   /
05      G236    X-Y DRIVER      \
06      H224B   CORE STACK      >SM 1, 0-17
07      G116    SENSE-INHIBIT   /
08      G236    X-Y DRIVER      \
09      H224B   CORE STACK      >SM 2, 0-17
10      G116    SENSE-INHIBIT   /
11      G236    X-Y DRIVER      \
12      H224B   CORE STACK      >SM 3, 0-17
13      G116    SENSE-INHIBIT   /
14      G236    X-Y DRIVER      \
15      H224B   CORE STACK      >SM 0, 18-PAR
16      G116    SENSE-INHIBIT   /
17      G236    X-Y DRIVER      \
18      H224B   CORE STACK      >SM 1, 18-PAR
19      G116    SENSE-INHIBIT   /
20      G236    X-Y DRIVER      \
21      H224B   CORE STACK      >SM 2, 18-PAR
22      G116    SENSE-INHIBIT   /
23      G236    X-Y DRIVER      \
24      H224B   CORE STACK      >SM 3, 18-PAR
25      G116    SENSE-INHIBIT   /
26      M8568   CONTROL "MAC" (MB20 0,2)
27      SPARE
28      SPARE
29      M8568   CONTROL "MAC" (MB20 1,3)
30      G236    X-Y DRIVER      \
31      H224B   CORE STACK      >SM 0, 0-17
32      G116    SENSE-INHIBIT   /
33      G236    X-Y DRIVER      \
34      H224B   CORE STACK      >SM 1, 0-17
35      G116    SENSE-INHIBIT   /
36      G236    X-Y DRIVER      \
37      H224B   CORE STACK      >SM 2, 0-17
38      G116    SENSE-INHIBIT   /
39      G236    X-Y DRIVER      \
40      H224B   CORE STACK      >SM 3, 0-17
41      G116    SENSE-INHIBIT   /
42      G236    X-Y DRIVER      \
43      H224B   CORE STACK      >SM 0, 18-PAR
44      G116    SENSE-INHIBIT   /
45      G236    X-Y DRIVER      \
46      H224B   CORE STACK      >SM 1, 18-PAR
47      G116    SENSE-INHIBIT   /
48      G236    X-Y DRIVER      /
49      H224B   CORE STACK      >SM 2, 18-PAR
50      G116    SENSE-INHIBIT
51      G236    X-Y DRIVER      \
52      H224B   CORE STACK      >SM 3, 18-PAR
53      G116    SENSE-INHIBIT   /
54 AB   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 CD   M9006   SBUS CABLE (OR M9005 TERMINATOR)
54 EF   M8565   "MAT" TIMING (MB20 1,3)
%



;SEQ147


.REM    %
SLOT    BOARD   DESCRIPTION             (BACKPLANE 04, CPU)
-------------------------------------------------------------------------
01      CABLE   E AND C BUS CABLE
02      CABLE   S0 BUS CABLE
03      CABLE   S1 BUS CABLE
04      M8516   E AND C BUS TRANS, 24-35
05      M8516   E AND C BUS TRANS, 12-23
06      M8516   E AND C BUS TRANS, 00-11
07      M8519   S BUS TRANS
08      M8519   S BUS TRANS
09      M8533   CH
10      M8535   CRC
11      M8536   CCL
12      M8534   CCW
13      SPARE
14      M8517   MB; 12-17, 30-35
15      M8517   MB; 06-11, 24-29
16      M8517   MB; 00-05, 18-23
17      M8521   CHD, 27-35
18      SPARE
19      M8521   CHD, 18-26
20      M8537   MBZ
21      M8529YA MBX
22      M8531YA MBC
23      M8513YA CSH
24      M8521   CHD, 09-17
25      M8521   CHD, 00-08
26      SPARE
27      M8514   CHA
28      M8515   CHX
29      M8518YA PMA
30      M8520YA PAG
31      M8532   PI
32      M8526   CLK
33      M8538   MTR
34      M8545   APR
35      M8525   CON
36      M8543   CTL
37      SPARE
38      M8542   VMA
39      M8512   EDP, 30-35
40      M8548   CRM
41      M8512   EDP, 24-29
42      M8548   CRM
43      M8512   EDP, 18-23
44      M8548   CRM
45      M8541   CRA
46      M8540   SH
47      M8544   MCL
48      M8522   IR
49      M8512   EDP, 12-17
50      M8548   CRM
51      M8512   EDP, 06-11

;SEQ148

52      M8548   CRM
53      M8512   EDP, 00-05
54      M8524   SCD
%


.REM    \
        BIT-SETTING MACRO USED TO TURN ON THE FLAG BIT TO
CAUSE PRINTING OF THE MODULE TYPE AND SLOT.
TO USE:
        SSET    SLOT#,TABLE
        TABLE IS THE ADDRESS OF A FOUR-WORD UML TABLE, AND
        SLOT# IS THE SLOT NUMBER, 1-54, OF THE DESIRED BOARD.
\
        .MACRO  SSET    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIS   #B,WW+T ;SET BIT FOR SLOT SS
        .IFT
          BIS   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SSET

.REM    \
        MACRO FOR SETTING THE BACKPLANE NUMBER FOR PNTUML.
        \
.MACRO  BACKPL  .B      
        .IIF    NB,.B,  MOV     #.B,R0  ;THE NEW BACKPLANE # IS .8
        .IIF    DF,TRAPS,       TRAP 115
        .IIF    NDF,TRAPS,      JSR     R5,BACKPL
        .ENDM   BACKPL

;SEQ149

.REM    \
        BIT-CLEARING MACRO TO REMOVE A BOARD'S PRESENCE FROM A
UML TABLE.  THE ACTION IS COMPLEMENTARY TO THE SSET MACRO.
        TO USE:
                SCLR    SLOT#,TABLE
        \
        .MACRO  SCLR    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIC   #B,WW+T                 ;CLR BIT FOR SLOT SS
        .IFT
          BIC   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   SCLR


.REM    \
        BIT TEST MACRO WHICH ADDRESSES A SLOT BIT IN THE
        UML TABLE OF CONCERN.  TO USE:

                STST    SLOT#,TABLE     
        BXX                     ;YOUR CHOICE OF BRANCH HERE
        \
        .MACRO  STST    SS,T
        .NTYPE  ZZZ,T
        SLOT.   SS
        .NLIST  SRC
        .IF     EQ,<ZZZ&70-10>
        .IFF
          BIT   #B,WW+T         ;TEST BIT FOR SLOT SS
        .IFT
          BIT   #B,WW'T
        .ENDC
        .LIST   SRC
        .ENDM   STST


;SEQ150

.REM    \
        MACRO FOR BUILDING AN INITIAL OR CONSTANT UML TABLE.
        TO USE:

        LABEL:  UML     <S1,S2,...SN>
                WHERE S1,S2 ETC., ARE THE SLOT NUMBERS OF ALL THE 
                BOARDS YOU WANT THIS TABLE TO POINT TO.
                THE ANGLE BRACKETS ARE REQUIRED IF MORE THAN ONE
                SLOT IS LISTED.
        A FOUR-WORD TABLE IS GENERATED CONTAINING 1'S MAPPED INTO
        THE BITS REPRESENTING THE SLOTS IN THE ARGUMENT.
        LIST.
        THE BYTE IN BITS 0-7 OF THE FOURTH WORD IS USED
        TO HOLD THE SLOT NUMBER OF THE FIRST ARGUMENT IN THE
        ARGUMENT LIST, IF THERE WAS MORE THAN ONE ARGUMENT.  THIS
        BYTE IDENTIFIES THE HIGHEST PROBABILITY BOARD TO THE
        TYPEOUT ROUTINE.
        \
        .MACRO  UML     SSS
                T=0
                W1=0
                W2=0
                W3=0
                W4=0
                HP=0
                .IRP    SS,<SSS>
                .IF     EQ,HP
                        .NARG   A
                        .IIF GT,<A-1>,HP=^D'SS
                .ENDC
                SLOT.   SS,T
                .IIF EQ,WW,     W1=W1!B
                .IIF EQ,<WW-2>, W2=W2!B
                .IIF EQ,<WW-4>, W3=W3!B
                .IIF EQ,<WW-6>, W4=W4!B
                .ENDM
                .NLIST  SRC
        .WORD   W1,W2,W3
        .WORD   W4!HP
                .LIST   SRC
        .ENDM   UML


;SEQ151

.REM    \
        MACRO SUBRTOUTINE TO CONVERT A SLOT NUMBER INTO A WORD
        AND BIT NUMBER FOR USE BY OTHER MACROS.
        \
        .MACRO  SLOT.   SS,T
                S=^D'SS
                .IIF GT,<S-54.>,.ERROR          ;SLOT NUMBER TOO BIG
                .IIF LE,S,.ERROR                ;NEGATIVE SLOT NUMBER
                W=S/16.
                .IIF B,T,WW=2*W
                .IIF NB,T,WW=2*W+T
                B=1
                .REPT   16.*W+15.-S
                B=B+B
                .ENDM
        .ENDM   SLOT.

.REM    \
        MACRO TO ALTER THE MOST LIKELY BOARD ENTRY OF A UML TABLE.
        GENERATES A MOVB INSTRUCTION.
        \
        .MACRO  SETHP   SS,T
        .NLIST  SRC
        .NTYPE  ZZZ,T
        .IF     EQ,<ZZZ&70-10>
        .IFF
          MOVB  #^D'SS,T+6
        .IFT
           MOVB #^D'SS,6'T
        .ENDC
        .LIST   SRC
        .ENDM   SETHP


;SEQ152

.SBTTL          SUBROUTINE CALLERS
.REM    \
        MACROS FOR CALLS TO REGISTER SAVE & RESTORE
ROUTINES
\

        ;SAVE   R3-R5

.MACRO  SAV.3
        
.IIF    NDF,TRTAPS      JSR     R5,SAV.3        ;SAVE R3-R5
.IIF    DF,TRAPS,        TRAP    4              ;SAVE R3-R5
.ENDM

        ;RESTORE R3-R5

.MACRO  RST.3
.IIF    NDF,TRAPS,      JSR     R5,RST.3        ;RESTORE R3-R5
.IIF    DF,TRAPS,       TRAP    5               ;RESTORE R3-R5
.ENDM

        ;SAVE R1-R5

.MACRO  SAV.5
.IIF    NDF,TRAPS,      JSR     R5,SAV.5        ;SAVE R1-R5
.IIF    DF,TRAPS,       TRAP    6               ;SAVE R1-R5
.ENDM

        ;RESTORE R1-R5

.MACRO  RST.5
.IIF    NDF,TRAPS,      JSR     R5,RST.5        ;RESTORE R1-R5
.IIF    DF,TRAPS,       TRAP    7               ;RESTORE R1-R5
.ENDM


;SEQ153

.REM    \
        ISOLATION ROUTINE LOAD HEADER PRINT ROUTINE CALLER
\
.MACRO  PNTID
          TRAP 125                              ;PRINT LOAD ID
.ENDM   PNTID

.REM    \
        CALLER TO FIX PROGRAM VERSION
\
.MACRO  GETVER
.IIF    NDF,TRAPS,      JSR     R5,GETVER       ;FIX PROGRAM VERSION
.IIF    DF,TRAPS,       TRAP    126             ;FIX PROGRAM VERSION
.ENDM   GETVER

.REM    \
        CALLER TO PRINT PROGRAM VERSION NUMBER
\
.MACRO  PNTVER
.IIF    NDF,TRAPS,      JSR     R5,PNTVER       ;PRINT VERSION #
.IIF    DF,TRAPS        TRAP    127             ;PRINT VERSION #
.ENDM   PNTVER

.REM    \
        CALLER TO CALIBRATE A TIME DELAY
\
.MACRO  CALTIM
          JSR   R5,CALTIM                       ;CALIBRATE TIME DELAY
.ENDM   CALTIM

.REM    \
        CALLER FOR TIME DELAY.  PARAMETER IS THE NUMBER OF MILLI-
SECONDS TO WAIT.
\
.MACRO  TWAIT   TIME
        $TWAIT=1
.IIF    NB,TIME,        MOV     #TIME,R0        ;# OF MILLISECONDS
.IIF    NDF,TRAPS,      JSR     R5,TWAIT        ;WAIT
.IIF    DF,TRAPS,       TRAP    130             ;WAIT
.ENDM   TWAIT


;SEQ154

.REM    \
        MACRO TO MOVE A CHARACTER STRING FROM ONE LOCATION TO ANOTHER.
        \
.MACRO  MVC     SRC,DST,LEN
        $MVC=1
.IIF    NDF,TRAPS,      JSR     R5,MVC          ;MOVE CHARACTER STRING
.IIF    DF,TRAPS,       TRAP    3               ;MOVE CHARACTER STRING
          .WORD SRC,DST,LEN
.ENDM   MVC

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION & PERFORM A DIAGNOSTIC
READ.
\
.MACRO  FNRD    DIAFN                           ;DO A DIAGNOSTIC READ
        $SDFRD=1
        .IF     NB,DIAFN
        .IFT
          JSR   R5,SDFRD                        ;DIAGNOSTIC READ
          .WORD DIAFN                           ;READ FN
        .IFF
          JSR   R5,SDFRDA                       ;DIAGNOSTIC READ
        .ENDC
.ENDM   FNRD

.REM    \
        MACRO TO SAVE A DIAGNOSTIC FUNCTION, PERFORM A DIAGNOSTIC
READ AND TEST A BIT IN THE DTE20 DEXWDS.

\
.MACRO  TENBIT  DIAFN,N                         ;DO A READ & TEST A BIT
        $SDFRD=1
        FNRD    DIAFN
        TBIT    N
.ENDM   TENBIT


;SEQ155

.REM    \
        STARTS A KL PROGRAM AT ADDRESS A & WAITS FOR
EITHER A HALT OR A TIMEOUT.  A = STARTING ADDRESS.
\
.MACRO  RUN     A
.IIF    NDF,TRAPS,      JSR     R5,RUNPRG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    10              ;RUN PROGRAM
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUN

.REM    \
        STARTS THE KL RUNNING AND WAITS FOR EITHER A HALT OR
A TIMEOUT.
\
.MACRO  CONTIN
.IIF    NDF,TRAPS,      JSR     R5,CONTIN       ;RUN & CONTINUE
.IIF    DF,TRAPS,       TRAP    11              ;RUN & CONTINUE
.ENDM   CONTIN

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH 
RUNS A LONG PROGRAM.  N IS THE NUMBER OF 30MS INTERVALS
TO WAIT FOR A TIMEOUT
\
.MACRO  RUNBIG  A,N
.IIF    NDF,TRAPS,      JSR     R5,RUNBIG       ;RUN PROGRAM
.IIF    DF,TRAPS,       TRAP    12              ;RUN PROGRAM
          .WORD N                               ;# OF 125MS INTERVALS
          .WORD A                               ;STARTING ADDRESS
.ENDM   RUNBIG

.REM    \
        CHANNEL RESET TEST CALLER
\
.MACRO CHRCHK
        $CHRCHK=1
.IIF    NDF,TRAPS,      JSR     R5,CHRCHK       ;CLEAR & TEST CHANNELS
.IIF    DF,TRAPS,       TRAP    117             ;CLEAR & TEST CHANNELS
.ENDM   CHRCHK

.REM    \
        CHANNEL RESET ISOLATION ROUTINE TEST CALLER
\
.MACRO  CHRISO
          TRAP  125                             ;LOAD & GO TO A5 ISOLATOR
.ENDM   CHRISO


;SEQ156

.REM    \
        MACRO TO GENERATE A CALL TO A PROGRAM WHICH LOADS THE C-RAM.
        DAT = POINTER TO DATA BUFFER
        FCAD = FIRST C-RAM ADDRESS TO LOAD (LAST IF LCAD IS BLANK)
        LCAD = LAST C-RAM ADDRESS TO LOAD (IF BOTH FCAD & LCAD NON-BLANK)
\
.MACRO  RAMLOD  DAT,FCAD,LCAD
        $RAMLOD=1
        .IIF    B,FCAD,FCAD=0
        .IF     B,LCAD
        ECAD=FCAD
        FCAD=0
        .IFF
        ECAD=LCAD
        .ENDC
          JSR   R5,RAMLOD                       ;LOAD C-RAM
          .WORD DAT                             ;DATA BUFFER LOCATION
          .WORD FCAD                            ;FIRST C-RAM ADDR
          .WORD ECAD                            ;LAST C-RAM ADR
.ENDM   RAMLOD

.REM    \
        MACRO TO SETUP FOR EXECUTION OF SPECIAL MICRO-CODE.
ARGUMENTS ARE POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE
USED FOR INITIATION OF AN MBOX WRITE. 
\
.MACRO  USTART  ADR,DAT
        $USTART=1
.IIF    NDF,TRAPS,      JSR     R5,USTART       ;SETUP SPECIAL U-CODE
.IIF    DF,TRAPS,       TRAP    33              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USTART

.REM    \
        MACRO TO EXECUTE SPECIAL MICRO-CODE.  ARGUMENTS ARE
POINTERS TO A 22-BIT ADDRESS & 36-BIT DATA TO BE USED FOR
INITIATION OF AN MBOX WRITE.

\
.MACRO  USPEC   ADR,DAT
        $USPEC=1
.IIF    NDF,TRAPS,      JSR     R5,USPEC        ;SPECIAL U-CODE LOOPBACK
.IIF    DF,TRAPS,       TRAP    45              ;SPECIAL U-CODE LOOPBACK
          .WORD ADR                             ;ADDRESS POINTER
          .WORD DAT                             ;DATA POINTER
.ENDM   USPEC


;SEQ157

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE 
WHICH RESETS THE KL-10 & MEMORY CONTROLLERS.
\
.MACRO  MEMRST
.IIF    NDF,TRAPS,      JSR     R5,MEMRST       ;RESET MEM CONTROLLERS
.IIF    DF,TRAPS,       TRAP    50              ;RESET MEM CONTROLLERS
.ENDM   MEMRST

.REM    \
        MACRO TO RESET THE MBOX TO A KNOWN STATE.
\
.MACRO  RSTMBX
.IIF    NDF,TRAPS,      JSR     R5,RSTMBX       ;RESET KL
.IIF    DF,TRAPS,       TRAP    51              ;RESET KL
.ENDM   RSTMBX

.REM    \
        MACRO TO INITIALIZE SLIDING BIT PATTERN GENERATOR.
PARAMETER IS THE WIDTH OF THE PATTERNS TO BE GENERATED.
IF LEFT BLANK THE DEFAULT IS 36-BITS.
\

.MACRO  SBINI   WID
        $SBINI=1
        .IIF B,WID,W=36
        .IIF NB,WID,W=WD
.IIF    NDF,TRAPS,      JSR     R4,SBINI        ;INITIALIZE PATTERN GENERATOR
.IIF    DF,TRAPS,       TRAP    42              ;INITIALIZE PATTERN GENERATOR
          .WORD W                               ;PATTERN WIDTH
.ENDM   SBINI

.REM    \
        MACRO TO RETURN A POINTER TO A SLIDING BIT PATTERN IN R0.
\
.MACRO  SB
        $SB=1
.IIF    NDF,TRAPS,      JSR     R5,SB           ;GET POINTER TO SLIDING BIT
.IIF    DF,TRAPS,       TRAP    43              ;GET POINTER TO SLIDING BIT
.ENDM   SB


;SEQ158

.REM    \
PDP10 LOADER CALL MACRO.  THE FIRST ARGUMENT TELLS THE FIRST
TEN ADDRESS TO LOAD.  0-17 ARE INTERPRETED AS AC'S IN THE CURRENT
AC BLOCK.  ADDRESSES ABOVE 17 ARE PHYSICAL MEMORY.  VALID ADDRESSES
ARE 20-177777.  THE 2ND ADDRESS IS EITHER THE PDP-11 ADDR.
OF A BLOCK OF 5-BYTE TEN CODE - IN WHICH CASE THE THIRD ARGUMENT
TELLS HOW MANY WORDS TO LOAD - OR A LIST OF PDP11 ADDRESSES
CONTAINING 5-BYTE WORDS TO BE LOADED - IN WHICH CASE THE THIRD ARGUMENT
MUST BE OMITTED.  EXAMPLES OF CALL FORMAT
        LOAD    2,ACODE,R       OR
        LOAD    2,<INST1,INST2,INST3,INST4>
\
.MACRO  LOAD    TENAD,A,N
        $LOAD=1
        .NARG   XXX
.IIF    NDF,TRAPS,      JSR     R5,LOAD         ;PROGRAM LOAD
.IIF    DF,TRAPS,       TRAP    37              ;PROGRAM LOAD
          .WORD TENAD
        .IF     EQ <XXX-3>
          .WORD -N
          .WORD A
        .IFF
        XXX=0
        .IRP    XA,<A>
        .IF     EQ XXX
        .NARG XXX
        .IIF EQ <XXX-1>,                        .WORD 1
        .IIF NE <XXX-1>,                        .WORD XXX
        .ENDC
          .WORD XA
        .ENDM
        .ENDC
.ENDM   LOAD

.REM    \
        CALLER  FOR ROUTINE TO EXAMINE AN AC.
\
.MACRO  ACNDR   AC
        $ACNDR=1
        .IF     NB,AC
        .IFT    
          MOV   #AC,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,ACNDR        ;READ AC
.IIF    DF,TRAPS,       TRAP    40              ;READ AC
.ENDM   ACNDR


;SEQ159

.REM    \
        AC MASK SYMBOLS FOR EASING THE USE OF ACLOAD MACRO.
        \
ACC0=000001
ACC1=000002
ACC2=000004
ACC3=000010
ACC4=000020
ACC5=000040
ACC6=000100
ACC7=000200
ACC10=000400
ACC11=001000
ACC12=002000
ACC13=004000
ACC14=010000
ACC15=020000
ACC16=040000
ACC17=100000

.REM    \
        MACRO FOR CALLING ACLOAD & ACSCAT.  TWO FORMATS ARE PERMITTED.
        LOADAC  ACMASK,ADDRESS                  ;CALLS ACLOAD
        LOADAC  ACMASK,<ADR1,ADR2,...,ADRN>     ;CALLS ACSCAT
        \

.MACRO  LOADAC  ACMASK,WDADR
        $LOADAC=1
        NUMARG  WDADR                           ;RETURNS # OF ARGS IN $$NARG
        .IF     GT,$$NARG-1
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,ACSCAT       ;LOAD ACS FROM SCATTERED 11 MEM
.IIF    DF,TRAPS,       TRAP    113             ;LOAD ACS FROM SCATTERED 11 MEM
        .IFF
.IIF    NDF,TRAPS,      JSR     R5,ACLOAD       ;LOAD ACS FROM CONTIGUOUS 11 MEM
.IIF    DF,TRAPS,       TRAP    114             ;LOAD ACS FROM 11 MEM BLOCK
        .ENDC
          .WORD ACMASK                          ;LOAD MASK
          .WORD WDADR                           ;PDP11 MEM ADR(S)
        .ENDM   LOADAC


;SEQ160

.REM    \
        MACRO TO CALL ACBLK:  A SUBROUTINE TO SET THE AC BLOCK.
        \
.MACRO  ACBLK   BN
        $ACBLK=1                                ;AC FORCE ASSEMBLY OF SUBROUTINE
.IIF    NB,BN   MOV     #BN,R0                  ;AC BLOCK NUMBER TO PARAM REG
.IIF    DF,$TRAPS,      TRAP 30                 ;GO SET AC BLOCK NUMBER
.IIF    NDF,$TRAPS,     JSR     R5,ACBLK        ;GO SET AC BLOCK NUMBER
.ENDM   ACBLK

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE WHICH
EXECUTES A PDP10 INSTRUCTION POINTED TO BY ARGUMENT A.
        \
.MACRO  XQT     A
        $XQT=1
        .IF     B,A
        .IFF
          MOV   #A,R0
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,XQT          ;DO EXECUTE ROUTINE
.IIF    DF,TRAPS,       TRAP    47              ;DO EXECUTE ROUTINE
.ENDM   XQT

.REM    \
        MACRO TO SETUP EXECUTION OF A TEN INSTRUCTION FOR MSCAN
\
.MACRO  STEXCT  ARG
        $STEXCT=1
        
.IIF    NDF,TRAPS,      JSR     R5,STEXCT               ;START EXECUTION
.IIF    DF,TRAPS,       TRAP    46                      ;START EXECUTION
          .WORD ARG                                     ;POINTER TO INSTRUCTION
.ENDM   STEXCT


;SEQ161

.REM    \
        MACRO PWTES GENERATES A CALL TO A SUBROUTINE WHICH PUTS AN
INVISIBLE PARAM WORD ON THE ERROR STACK.  IF NO PARAM IS GIVEN, IT IS
ASSUMED LOADED ALREADY IN R0.
        \
.MACRO   PWTES   .ARG
$PWTES=1                                                ;FORCE ASSEMBLY OF PWTES SUBROUTINE
.IIF    NB,.ARG,        MOV     .ARG,R0
          JSR   R5,PWTES                                ;MOV INVISIBLE PARAM TO ERROR STACK
.ENDM   PWTES

.REM    \
        MACRO   CHKIT GENERATES A CALL TO A SUBROUTINE WHICH DOES ESSENTIALLY
THE SAME THING AS MASK36 WITH THE ADDITIONAL FEATURE OF BEING ABLE
TO NAME THE DISCREPANCY BITS.  SEE SUBRTN FOR FURTHER INFO.
        \
.MACRO  CHKIT   XPCTD,ACTUAL,MASK,NAMLST
$CHKIT=1                                        ;FORCE ASSEMBLY OF CHKIT SUBROUTINE
        JSR     R5,CHKIT                        ;CHECK ACTUAL VS. XPCTD UNDER MASK
.IIF    NB,MASK,        .WORD MASK,XPCTD,ACTUAL,NAMLST
.IIF    B,MASK, .WORD ZERO..,XPCTD,ACTUAL,NAMLST
.ENDM   CHKIT

.REM    \
        MACROS BLK10,X10,X010,ENDBLK,XRUN,AND XRUNBIG ARE ALL RELATED.  BLK10 AND
ENDBLK ARE USED TO ENABLE THE CALCULATION OF PDP10
SYMBOLIC RELATIVE ADDRESSES.  X10 AND X010 ARE THE SAME AS I10 AND IO10
EXCEPT THAT THEY USE THE RELATIVE ADDRESSES INSTEAD OF THE ABSOLUTE
NUMBERS USED BY THE 'I' MACROS.  X RUN AND XRUNBIG DIFFER FROM RUN AND
RUNBIG IN THAT 1)  THEY TURN ON CACHE, AND 2) THEY ALLOW STARTING AT A
PDP10 REL. ADR.
\

.MACRO  BLK10   TENLOC
$TB=TENLOC                                              ;STARTING LOC OF 10 CODE BLOCK
$EB=.                                                   ;ADR OF 10 CODE BLOCK WITHIN DPD11
        .IIF NDF, RELEASE,.LIST MEB                     ;LIST EXPANSION BINARY SO THAT IT IS AVAILABLE
.ENDM   BLK10

.MACRO  X10     OP,AC,I,Y,X
          I10   OP,AC,I,\Y-$EB/5+$TB,X
.ENDM   X10

.MACRO  XO10    OP,DEV,I,Y,X
          IO10  OP,DEV,I,\Y-$EB/5+$TB,X
.ENDM   XO10


;SEQ162


.MACRO ENDBLK   ACMASK,NOEVEN
$TL=.-$EB/5                     ;NUMBER OF PDP10 WORDS IN THE BLOCK
.IF     NB,ACMASK
ACMASK=0
.REPT   $TL
ACMASK=ACMASK+ACMASK+1
.ENDR
.REPT   $TB
ACMASK=ACMASK+ACMASK
.ENDR
.ENDC
.IIF    B,NOEVEN,       .EVEN
.IIF    NDF,RELEASE,.NLIST MEB
.ENDM   ENDBLK

.MACRO  XRUN    TENADR
$XRUN=1                         ;FORCE ASSEMBLY OF XRUNBIG SUBROUTINE
          JSR   R5,XRUN         ;CALL SUBROUTINE TO START 10
          .WORD TENADR-$EB/5+$TB        ;STARTING ADR FOR 10
.ENDM   XRUN

.MACRO  XRUNBIG TENADR,TIM
$XRUN=1                         ;RUN 10 FOR A LONG TIME
          JSR   R5,XRUNBI       ;RUN 10 FOR A LONG TIME
          .WORD TIM,TENADR-$EB/5+$TB    ;TIME FACTOR, START ADR
.ENDM   XRUNBIG

.REM    \
        MACRO CGOTO DOES A COMPUTED GO-TO BASED ON THE GIVEN PARAM
(0 TO N) OR THE VALUE IN R0 IF NO PARAM GIVEN.  CHECKS THE RANGE OF THE
PARAM VS. THE LENGTH OF THE PARAM LIST.
        \
.MACRO  CGOTO   LST,NDX
$CGOTO=1                        ;FORCE ASSEMBLY OF CGOTO SUBROUTINE
        .IIF    NB,NDX,MOV      NDX,R0  ;MOV LIST INDEX TO R0
          JSR   R5,CGOTO        ;CALL COMPUTED GOTO SUBROUTINE
        NUMARG  LST             ;GET # ARGS IN LIST
          .WORD $$NARG-1,LST
.ENDM   CGOTO

.REM    \
        
        DPV1PG IS USED TO DEPOSIT AND VERIFY EXACTLY 1 KL10 PAGE.  IT
DIFFERS FROM 'LOAD' IN THAT IT DOES 1 PAGE ONLY, ZERO FILLING IF NECESSARY
, AND DOES 2 VERIFIES, ONE AFTER EACH DEPOSIT AND ONCE MORE AFTER
ALL DEPOSITS ARE DONE.  SCATTER LOADING ISN'T SUPPORTED.
        \
.MACRO  DPV1PG  TADR,EADR,NWDS
$DPV1PG=1                                       ;FORCE ASSEMBLY OF DPV1PG SUBROUTINE
          JSR   R5,DPV1PG                       ;DEPOSIT & VERIFY 1 KL10 PAGE
          .WORD TADR,EADR,NWDS
.ENDM   DPV1PG


;SEQ163

.REM    \
CALLER FOR CLOCK CONTROL ROUTINE.  FIRST ARGUMENT IS THE
PDP11 ADDRESS OF A PDP10 INSTRUCTION TO BE EXECUTED WITH
CONTROLLED CLOCKING.  THE SECOND ARGUMENT SPECIFIES HOW
TO DETERMINE THE NUMBER OF CLOCKS.  IF IT IS AN INTEGER,
IT IS USED AS A BURST COUNT.  OTHERWISE IT MAY BE OF THE
FORM <DIAGFCN,BITNBR,FLAVOR> TO SPECIFY THAT THE CLOCK IS
TO BE SINGLE-STEPPED UNTIL BIT "BITNBR" OF DIAGNOSTIC
FUNCTION "DIAGFCN" TRANSITIONS TO "FLAVOR" (0 OR 1).
\

.MACRO  STEP10  INSTR,EPNT
.IIF    NDF,TRAPS,      JSR     R5,STEP10       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS,       TRAP    16              ;STEP TO EVENT OR BURST NXT WD POS
          .WORD INSTR                           ;INSTRUCTION TO EXECUTE
        S10.    EPNT
.ENDM   STEP10

.REM    \
        CALLER FOR A ROUTINE WHICH TESTS FOR THE LEADING EDGE OF
AN EVENT.  THE EVENT IS SPECIFIED BY <DIAGFCN,BITNBR,FLAVOR>.
\
.MACRO  EVENT   ARG                     ;GENERATES EVENT CALL
.IIF    NDF,TRAPS       JSR     R5,EVENT        ;EVENT THIS CLOCK?
.IIF    DF,TRAPS,       TRAP    15              ;EVENT THIS CLOCK?
        S10.    ARG
.ENDM   EVENT

.REM    \
CALLER FOR ROUTINE WHICH STEPS THE CLOCK UNTIL AN EVENT 
IS DETECTED.  THE EVENT IS SPECIFIED BY <DIAGFCN, BITNBR, FLAVOR>.
\
.MACRO  FIND    ARG                     ;GENERATES FIND CALL
.IIF    NDF,TRAPS,      JSR     R5,FIND ;STEP TO EVENT
.IIF    DF,TRAPS                TRAP 14 ;STEP TO EVENT
        S10.    ARG
.ENDM   FIND


;SEQ164

.REM    \
        STEP10 CONTINUATION CALL
\
.MACRO  STPCON  EPNT
.IIF    NDF,TRAPS,      JSR     R5,STPCON       ;STEP TO EVENT OR BURST NXT WD POS
.IIF    DF,TRAPS        TRAP    17              ;STEP TO EVENT OR BURST NXT WD POS
        .WORD   EPNT
.ENDM   STPCON

.REM    \
        MACRO   TO CALL SOBAC.  PARAMS ARE STD FUNC ARGS
\
.MACRO  SOBAC   ARG,CLK
        $SOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,SOBAC        ;STEP TO EVNT OR BURST & CHK EVNT
.IIF    DF,TRAPS,       TRAP    72              ;STWEP TO EVNT OR BRST & CHK EVENT
          .WORD CLK
          S10.  ARG
        .ENDM   SOBAC

.REM    \
        MACRO TO CALL DSOBAC,  PARAM ASSUMED ALREADY LOADED IN R0.
\
.MACRO  DSOBAC
        $DSOBAC=1
.IIF    NDF,TRAPS,      JSR     R5,DSOBAC       ;STEP TO EVNT, OR BRST & CHK EVNT
.IIF    DF,TRAPS        TRAP    73              ;STEP TO EVNT, OR BRST & CHK EVNT
        .ENDM   DSOBAC

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE TO
GENERATE A BURST OF CLOCKS.
\
.MACRO  BRST    K
        $BRST=1
.IIF    NDF,TRAPS       JSR     R5,BRST ;BURST
.IIF    DF,TRAPS,       TRAP    20      ;BURST
          .WORD K                       ;# OF CLOCKS
.ENDM   BRST

;SEQ165

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE
WHICH STEPS THE MBOX CLOCK ONCE.  THIS ROUTINE SUPPORTS
FUNCTION BREAKPOINTS.
\
.MACRO  STEP
.IIF    NDF,TRAPS,      JSR     R5,STEP        ;STEP THE CLOCK
.IIF    DF,TRAPS,       TRAP    13           ;STEP THE CLOCK
.ENDM   STEP


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH SAVES THE VALUES OF RQ0,RQ1,RQ2,RQ3,RD & WR LEFT
JUSTIFIED IN A BYTE, & SAVES THE EBUS REG & SBUS ADR 34 & 35
LOWER 22-BITS IN 3 BYTES.
\
.MACRO  GETMEM
        $GETMEM=1
.IIF    NDF,TRAPS,      JSR     R5,GETMEM       ;GET MEMORY STATUS
.IIF    DF,TRAPS,       TRAP    54              ;GET MEMORY STATUS
.ENDM   GETMEM


.REM    \
        CALLER FOR CLEAR MEMORY ROUTINE.  STARTS AT PDP-10 ADDRESS
20.  ARGUMENT IS UPPER LIMIT POINTER.
\
.MACRO  MEMCLR  ULIM
        $MEMCLR=1
.IIF    NB,ULIM,        MOV     #ULIM,R0        ;POINTER TO UPPER LIMIT
          JSR   R5,MEMCLR                       ;CLEAR 10 MEMORY
.ENDM   MEMCLR


.REM    \
        CALLER FOR SUBROUTINE TO GET & PRINT THE ERA.
\
.MACRO  PNTERA  AC
$PNTERA=1                                       ;FORCE ASSEMBLY OF PNTERA SUBROUTINE
.IF     B,AC
          JSR   P5,GPNTER                       ;GET & PRINT ERA(USING AC0)
.IFF
          JSR   R5,PNTERA                       ;PRINT ERA WORD ALREADY IN AC
          .WORD AC
.ENDC
.ENDM   PNTERA



;SEQ166

.REM    \
        MACRO TO PERFORM AN SBUS DIAG TO A PREVIOUSLY SELECTED
CONTROLLER.
\
.MACRO  SBUSDG  PTR
        $SBUSDG=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0                         ;SBUS VALUE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SBUSDG       ;EXECUTE
.IIF    DF,TRAPS,       TRAP    56              ;EXECUTE SBUS DIAG
.ENDM   SBUSDG

.REM    \
MCRO TO SET ADDRESS BOUNDARIES TO CORRESPOND TO A 22-BIT
ADDRESS.
\
.MACRO  ADRSET  ADR
        $ADRSET=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR,R5,ADRSET           ;SET SWITCHES FOR ADR
.IIF    DF,TRAPS,       TRAP    60              ;SET SWITCHES FOR ADR
.ENDM   ADRSET

.REM    \
        MACRO TO PERFORM AN SBUS DIAG LOOPBACK OPERATION FROM
AC15 TO AC17.
\
.MACRO  LOOPAR  ADR
        $LOOPAR=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOOPER       ;SBUS DIAG LOOPBACK
.IIF    DF,TRAPS,       TRAP    57              ;SBUS DIAG LOOPBACK
.ENDM   LOOPAR


;SEQ167


.REM    \
        LOAD A PROGRAM FOR USE IN DETERMINATION OF MEMORY
CONFIGURATION.
\
.MACRO  SBUPRG
        $SBUPRG=1
.IIF    NDF,TRAPS,      JSR     R5,SBUPRG       ;LOAD PROGRAM
.IIF    DF,TRAPS,       TRAP    55              ;LOAD PROGRAM
.ENDM   SBUPRG

.REM    \
        RUN  PROGRAM WHICH DETERMINES & SAVES THE CONFIGURATION 
OF KL MEMORY.
\  
.MACRO  CONDET
        $CONDET=1
          JSR   R5,CONDET                       ;DETERMINE MEM. CONFIG.
.ENDM   CONDET

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
REPORTS THE CONFIGURATION OF PDP-10 MEMORY
\
.MACRO  REPMEM
        $REPMEM=1
          JSR   R5,REPMEM                       ;REPORT DCONFIGURATION
.ENDM   REPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE WHICH PRINTS
A 22-BIT VALUE LEADING ZEROS SUPPRESSED.  PTR = POINTER TO
3 BYTES OF DATA.
\
.MACRO  PNT22S  PTR
        $PNT22S=1
        .IF     NB,PTR
        .IFT
.IIF    NDF,TRAPS,      JSR     R5,PNT225       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    52              ;PRINT ADDRESS
          .WORD PTR                             ;ADDRESS POINTER
        .IFF
.IIF    NDF,TRAPS.      JSR     R5,PNT22A       ;PRINT ADDRESS
.IIF    DF,TRAPS,       TRAP    53              ;PRINT ADDRESS
        .ENDC
.ENDM   PNT22S

;SEQ168

.REM    \
        MACRO TO TRANSFER AC17 TO PDP-11 CORE.  CLEARS AC17.
A PUTS 5 BYTES IN A BUFFER POINTED TO BY R0.
\
.MACRO  READ17
        $READ17=1
.IIF    NDF,TRAPS,      JSR     R5,READ17       ;GET AC17
.IIF    DF,TRAPS,       TRAP    44              ;GET AC17
.ENDM   READ17


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS THE STANDARD CACHE REFILL ALGORITHM.
\
.MACRO  CRRSTD
        $CRRSTD=1       
.IIF    NDF,TRAPS,      JSR     R5,CRRSTD       ;STANDARD CACHE REFILL
.IIF    DF,TRAPS,       TRAP    61              ;STANDARD CACHE REFILL
.ENDM   CRRSTD


.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
LOADS ANY CACHE REFILL ALGORITHM.
\
.MACRO  REFILL  TAB
        $REFILL=1
.IIF    NDF,TRAPS,      JSR     R5,REFILL       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS,       TRAP    62              ;LOAD CACHE REFILL RAM
          .WORD TAB                             ;TABLE POINTER
.ENDM   REFILL


;SEQ169

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH LOADS THE CACHE
REFILL ALGORITHM TO ACCESS ONLY ONE CACHE.  ARG = CACHE.
\
.MACRO  CRRONE  ARG
        $CRRONE=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0                         ;CACHE TO USE
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CRRONE       ;LOAD CACHE REFILL RAM
.IIF    DF,TRAPS        TRAP    63              ;LOAD CACHE REFILL RAM
.ENDM   CRRONE


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH INVALIDATES THE CACHE
\
.MACRO  INVAL
        $INVAL=1
.IIF    NDF,TRAPS       JSR     R5,INVAL                ;INVALIDATE CACHE
.IIF    DF,TRAPS        TRAP    64              ;INVALIDATE CACHE
.ENDM   INVAL


.REM    \
        GENERATE A CALL TO A PROGRAM WHICH VALIDATES CORE.
\
.MACRO  VALCOR
        $VALCOR=1
.IIF    NDF,TRAPS,      JSR     R5,VALCOR               ;VALIDATE CORE
.IIF    DF,TRAPS,       TRAP    65                      ;VALIDATE CORE
.ENDM   VALCOR


;SEQ170

.REM    \
        MACRO FOR CALLS TO COMPARE THE STATE OF SELECTED DIAGNOSTIC
FUNCTION BITS TO A PDP11 WORD OF EXPECTED DATA.
        T = POINTER TO A SPEC. TABLE
        X = REGISTER OR EXPECTED DATA
        M = THE MASK TO BE USED (OPTIONAL)

\
.MACRO  CMP.S   T,X,M
        $CMP.S=1
.NARG   XXX
        .IF     B,X
        .IFT
          XX=0
.IIF    NDF,TRAPS,      JSR     R5,CMPSG.
.IIF    DF,TRAPS,       TRAP    116
          .WORD 0
        .IFF
          XX=X
.NTYPE  ZZZ,X
.IF     LE<ZZZ&70-10>
.IIF    NDF,TRAPS,      JSR     R5,CMPSR.
.IIF    DF,TRAPS        TRAP    2
          MOV   XX,R1
.IFF
.IIF    NDF,TRAPS,      JSR     R5,CMPS.
.IIF    DF,TRAPS,       TRAP    1
          .WORD XX
        .ENDC
        .ENDC

          .WORD T
.IF     B,M
          .WORD 0
.IFF
MM=M
          .WORD 0
          .WORD ^CMM
.ENDC
.ENDM

.REM    \
        CALL TO REPORT PDP10 BIT TEST ERRORS.  CREATES AN ERROR
STACK ENTRY.
\
.MACRO  BITERR
          JSR   R5,BITERR               ;BIT TO ERROR STACK
.ENDM   BITERR


;SEQ171

.REM    \
        MACRO TO LOAD THE ERROR STACK WITH A 5-BYTE PATTERN.
\
.MACRO  PATERR  PTR
        $PATERR=1
        .IF     B,PTR
        .IFF
          MOV   #PTR,R0                 ;PATTERN TO ERROR STACK
        .ENDC
          JSR   R5,PATERR               ;PATTERN TO ERROR STACK
.ENDM   PATERR

.REM    \
MACRO TO PUT A DIAG FN NUMBER ON THE ERROR STACK.
FUNCTION OBTAINED AT LAST FNRD.
\
.MACRO  FRERR
          JSR   R5,FRERR                ;DIAG FN TO ERROR STACK
.ENDM   FRERR

.REM    \
        MACRO TO GENERATE A CALL TO THE PNTUML ROUTINE.
\
.MACRO PNTUML   T
          TRAP  74                      ;PRINT BOARD CALLOUTS
        .IF     NB,T
        .IFT
          .WORD T                       ;UML TABLE POINTER
        .ENDC
.ENDM   PNTUML

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.E ROUTINE
\
.MACRO  CMP.E   S
.IIF    DF,TRAPS,       TRAP    75              ;SCAN THE ERROR STACK
          .WORD S                       ;SPEC TABLE POINTER
.ENDM   CMP.E

.REM    \
        MACRO TO GENERATE A CALL TO THE CMP.F ROUTINE
\
.MACRO  CMP.F   S
        $CMP.F=1
.IIF    DF,TRAPS,       TRAP    76              ;SCAN THE ERROR STACK
          .WORD S                               ;SPEC TABLE POINTER
.ENDM   CMP.F


;SEQ172

.REM    \
        MACRO TO CALL THE MBOX MASTER RESET ISOLATION ROUTINE.
\
        .MACRO  ISORST
.IIF    DF,TRAPS,       TRAP    77              ;LOAD & GO TO A4 ISOLATOR
        .ENDM   ISORST
.REM    \
        MACRO TO CALL THE RANGE ROUTINE.
\
        .MACRO  RANGE
        $RANGE=1
.IIF    DF,TRAPS,       TRAP    32              ;DETERMINE FAILING BIT RANGE
        .ENDM   RANGE
.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSK = THE MASK (OPTIONAL)
\
.MACRO  MASK16  EXP,ACT,MSK             ;GENERATES MASK16 CALL
        $MASK16=1
.IIF    NDF,TRAPS,      JSR     R5,MASK16       ;COMPARE
.IIF    DF,TRAPS,.      TRAP    21              ;COMPARE
        .IF     B,MSK
        .IFT
          .WORD 0
        .IFF
          .WORD MSK                     ;MASK
        .ENDC
          .WORD ACT                     ;ACTUAL POINTER
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MASK16

.REM    \
        CALLER FOR ROUTINE TO COMPARE 16-BIT ACTUAL & EXPECTED.
R2 = MASK
R3 = ACTUAL DATA
R4 = EXPECTED DATA
\
.MACRO  MSK16R
        $MSK16R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK16R       ;16-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    22              ;16-BIT COMPATE
.ENDM   MSK16R


;SEQ173

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL & EXPECTED
DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
ACT = POINTER TO ACTUAL DATA
MSL = POINTER TO MASK (36-BIT OPTIONAL)
\
.MACRO  MASK36  EXP,ACT,MSK             ;GENERATES MASK36 CALL
        $MASK36=1
.IIF    NDF,TRAPS,      JSR     R5,MASK36  ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    24      ;36-BIT COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK             ;MASK POINTER
        .ENDC
          .WORD EXP             ;EXPECTED POINTER
          .WORD ACT             ;ACTUAL POINTER
.ENDM   MASK36

.REM    \
        CALLER FOR ROUTINE TO COMPARE 5-BYTE ACTUAL AND EXPECTED DATA.
PARAMETERS PASSED IN REGISTERS.
R2 = MASK POINTER
R3 = EXPECTED POINTER
R4 = ACTUAL POINTER
\
.MACRO  MSK36R
        $MSK36R=1
.IIF    NDF,TRAPS,      JSR     R5,MSK36        ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    23              ;36-BIT COMPARE
.ENDM   MSK36R


;SEQ174

.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM THE DTE-20
TO SOME EXPECTED DATA.  (TRAILING PARAMETERS)
EXP = POINTER TO EXPECTED DATA
MSL = POINT TO MASK (36-BIT, OPTIONAL)
\
.MACRO  MSKDAT  EXP,MSK         ;GENERATES MSKDAT CALL
        $MSKDAT=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDAT ;DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    25      ;DTE20 COMPARE
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDAT


.REM    \
        CALLER FOR ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  SIMILAR TO MSKDAT EXCEPT
THAT DIAG. FUNCTION IS THE FIRST PARAMETER.
\
.MACRO  MSKDF   DIA,EXP,MSK             ;GENERATES MSKDF CALL
        
        $MSKDF=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDF; DTE20 COMPARE
.IIF    DF,TRAPS,       TRAP    26      ;DTE20 COMPARE
          .WORD DIA                     ;DIAGNOSTIC FN
        .IF     B,MSK
        .IFT
          .WORD ZERO..
        .IFF
          .WORD MSK                     ;MASK POINTER
        .ENDC
          .WORD EXP                     ;EXPECTED POINTER
.ENDM   MSKDF


;SEQ175

.REM    \
        CALLER FOR A ROUTINE TO COMPARE DATA FROM A DIAGNOSTIC
READ FUNCTION TO SOME EXPECTED DATA.  PARAMETERS PASSED IN REGS.
R0 = DIAGNOSTIC FUNCTION
R2 = MASK POINTER
R3 = EXPECTED POINTER
\
.MACRO  MSKDFR
        $MSKDFR=1
.IIF    NDF,TRAPS,      JSR     R5,MSKDFR               ;36-BIT COMPARE
.IIF    DF,TRAPS,       TRAP    27              ;36-BIT COMPARE
.ENDM   MSKDFR

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH COMPARES EXPECTED
MEMORY STATUS TO ACTUAL STATUS.
\
.MACRO  CMPMEM  TAB
        $CMPMEM=1
.IIF    NDF,TRAPS,      JSR     R5,CMPMEM               ;COMPARE MEM STATUS
.IIF    DF,TRAPS        TRAP    36              ;COMPARE MEM STATUS
          .WORD TAB                             ;EXPECTED
.ENDM   CMPMEM

.REM    \
        MACRO TO GENERATE A CALL TO A SUBROUTINE
WHICH COMPARES TWO 3-BYTE (22-BIT) ADDRESSES
VALUES.
\
.MACRO  CMP22   ACT,EXP
        $CMP22=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22        ;3-BYTE COMPARE
.IIF    DF,TRAPS        TRAP    35              ;3-BYTE COMPARE
          .WORD ACT                             ;POINTER TO ACTUAL
          .WORD EXP
.ENDM   CMP22


;SEQ176

.REM    \
        GENERATES A CALL TO  A ROUTINE WHICH COMPARES TWO 3-BYTE VALUES.
PARAMETERS PASSED IN REGISTERS.
R2 = POINTER TO ACTUAL
R3 = POINTER TO EXPECTED
\
.MACRO  CMP22R
        $CMP22R=1
.IIF    NDF,TRAPS,      JSR     R5,CMP22R       ;3-BYTE COMPARE
.IIF    DF,TRAPS,       TRAP    34              ;3-BYTE COMPARE
.ENDM   CMP22R

.REM    \
        MACRO TO GENERATE A CALL TO A ROUTINE 10 ADDRESS TEST
A MEMORY MODULE.  ARGUMENTS ARE A POINTER TO THE BASE ADDRESS OF
THE MODULE & A NUMBER TO IDENTIFY THE MODULE TYPE.
\
.MACRO  MEMADR  ADR,TYP
        $MEMADR=1
.IIF    NDF,TRAPS,      JSR     R5,MEMADR       ;PERFORM ADDRESS TEST
.IIF    DF,TRAPS,       TRAP    41              ;PERFORM ADDRESS TEST
          .WORD ADR                             ;MODULE BASE ADR POINTER
        .IIF    B,TYP,TYP=0
          .WORD TYP                             ;MODULE TYPE CODE
.ENDM   MEMADR


.REM    \
        MACRO   TO TEST THE MBOX MASTER RESET STATE
\
.MACRO  RSTCHK
        $RSTCHK=1
          JSR   R5,RSTCHK               ;TEST MBOX RESET
.ENDM   RSTCHK

.REM    \
        MACRO TO SET AN MBOX SCANOUT MASK.  PARAMETER IS THE MASK
TABLE POINTER.
\
.MACRO  SETMSK  MTB
        $SETMSK=1
        $MSCAN=1
          JSR   R5,SETMSK               ;SET MBOX SNAPSHOT MASK
          .WORD MTB                     ;MASK TABLE POINTER
.ENDM   SETMSK


;SEQ177

.REM    \
        MBOX/ CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MCSCAN  TAB,CLK
        $CSCAN=1
          JSR   R5,MCSCAN               ;MBOX/ CHANNEL SCANOUT
          .WORD TAB                     ;TABLE POINTER
          .WORD   CLK
.ENDM   MCSCAN

.REM    \
        MBOX SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS OF A
TABLE TO BE COMPARED TO A SNAPSHOT OF MBOX DIAGNOSTIC READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED BEFORE
THE SCAN.
\
.MACRO  MSCAN   TAB,CLK
        $MSCAN=1
          JSR   R5,MSCAN                ;MBOX SCANOUT
          .WORD TAB                     ;TABLE POINTER
          .WORD CLK
.ENDM   MSCAN


.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR MSCAN.
\
.MACRO  MSOTB
          .WORD 0               ;MBOX SCANOUT TABLE
          .BLKW MSIZE-1
.ENDM   MSOTB

.REM    \
        CHANNEL SCANOUT CALLER.  FIRST ARGUMENT IS THE ADDRESS
OF A TABLE TO BE COMPARED TO A SNAPSHOT OF CHANNEL DIAG READS.
THE SECOND ARGUMENT IS THE CLOCK CONTROL TO BE PERFORMED  BEFORE
THE SCAN.
\
.MACRO  CSCAN   TAB,CLK
        $CSCAN=1
          JSR   R5,CSCAN        ;CHANNEL SCANOUT
          .WORD TAB             ;TABLE POINTER
        S10.    CLK
.ENDM   CSCAN

.REM    \
        MACRO TO GENERATE A BLANK TABLE FOR CSCAN.
\
.MACRO CSOTB
          .WORD 0                       ;CHANNEL SCANOUT TABLE
          .BLKW CSIZE-1
.ENDM   CSOTB


;SEQ178

.SBTTL          SPECIAL EXAMINE & DEPOSIT MACROS 18-AUG-75
.REM    \
        SPECIAL EXAMINE ROUTINE MACRO.  DOES NOT USE THE PI
SYSTEM.  SUPPORTS FUNCTION BREAKPOINTS.
ADR = POINTER TO 18-BIT ADDRESS.
\
.MACRO  SPCEXM  ADR
        $SPCEXM=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R0                 ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCEXM       ;EXAMINE
.IIF    DF,TRAPS,       TRAP    66              ;EXAMINE
.ENDM   SPCEXM

.REM    \
        SPECIAL DEPOSIT ROUTINE CALL.  DOES NOT USE THE PI SYSTEM
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SPCDEP  DTA,ADR
        $SPCDEP=1
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SPCDEP       ;DEPOSIT
.IIF    DF,TRAPS,       TRAP    67              ;DEPOSIT
.ENDM   SPCDEP


;SEQ179

.REM    \
        DEPOSIT & VERIFY CALL.  DOES NOT USE THE PI SYSTEM.
DOES SUPPORT FUNCTION BREAKPOINTS.
DTA = POINTER TO 36-BIT DATA
ADR = POINTER TO 18-BIT ADDRESS
\
.MACRO  SDPVR   DTA,ADR
        $SDPVR=1
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R0         ;DATA POINTER
        .ENDC
        .IF     NB,ADR
        .IFT
          MOV   #ADR,R1         ;ADDRESS POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SDPVR        ;DEPOSIT & VERIFY
.IIF    DF,TRAPS,       TRAP    70              ;DEPOSIT & VERIFY
.ENDM   SDPVR

.REM    \
        TRANSFER A 36-BIT WORD TO AC17.
        PRT = POINTER TO 36-BIT DATA
\
.MACRO  LOAD17  PTR
        $LOAD17=1
        .IF     NB,PTR
        .IFT
          MOV   #PTR,R0         ;DATA POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LOAD17       ;LOAD AC17
.IIF    DF,TRAPS,       TRAP    71              ;LOAD AC17
.ENDM   LOAD17



;SEQ180


.SBTTL          CACHE TEST MACROS       25-FEB-76

.REM    \
MACRO TO CALL ROUTINE TO SET THE PC, PUSH RUN AND CONTINUE
SO THAT TEST MAY STEP THRU 10 CODE.
        P IS THE VALUE (0 - 177777)
        \

.MACRO  SETPC   P
        $SETPC=1
.IIF    DF,TRAPS,       TRAP    100     ;ASSIGN
        NDF,TRAPS,      JSR     R5,SETPC
          P
.ENDM   SETPC

.REM    \
CALL A ROUTINE WHICH LOADS THE "CRRONE" AC CODE BUT DOESN'T RUN IT
        ARG IS THE DESIRED 3-BIT REFILL RAM DATA
        \

.MACRO  LDREF1  ARG
        $LDREF1=1
        .IF     NB,ARG
        .IFT
          MOV   #ARG,R0         ;DATA
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,LDREF1       ;LOAD REFILL PROGRAM
.IIF    DF,TRAPS,       TRAP    112             ;LOAD REFILL PROGRAM
.ENDM   LDREF1

;CACHE FAULT CALLER.  ARGUMENT IS COMMENT. WORD AFTER "JSR PC,FAULT"
;POINTS TO CACHE NUMBER MESSAGE
.MACRO  FAULTC  ARG
        $FAULTC=1
          JSR   PC,FAULTC
        .IF     B,<ARG>
        .IFT
          .WORD 0
        .IFF
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   FAULTC

;SEQ181

.REM    \
        CALL TO READ REFILL RAM DATA AND ADDRESS
        RETURNS POINTER IN R0
        \

.MACRO  RDRFIL
        $RDRFIL=1               
.IIF    DF,TRAPS,       TRAP    101
.IIF    NDF,TRAPS,      JSR     R5,RDRFIL
.ENDM   RDRFIL
  
.REM    \
LOAD A ONE WORD WRITE, ARGS:  DATA POINTER, 16-BIT PDP-10 ADDRESS.
        \

.MACRO  LDWRIT  DAT,ADR
        $LDWRIT=1
.IIF    DF,TRAPS,       TRAP    102
.IIF    NDG,TRAPS,      JSR     R5,LDWRIT
          DAT
          ADR
.ENDM   LDWRIT

.REM    \
        CALL TO WRITE EVERY FOURTH WORD OF A PAGE IN CACHE.
ARGS:  DATA POINTER, PAGE NBR, WORD NBR (0-3).
        \
.MACRO  CSHWRD  DAT,PAG,WRD
        $CSHWRD=1
.IIF    DF,TRAPS,       TRAP    103
.IIF    NDF,TRAPS,      JSR     R5,CSHWRD
          DAT
          PAG
.IIF    NB,WRD, WRD
.ENDM   CSHWRD
   
;SEQ 182

.REM    \
CALL TO WRITE DISTURB PATTERN TO CACHE
        A IS PHYSICAL PAGE NUMBER
        \

.MACRO  DSTRBC  A
        $DSTRBC=1
          MOV   #A,R0           ;GET PHYSICAL PAGE NUMBER
.IIF    DF,TRAPS,       TRAP    104
.IIF    NDF,TRAPS,      JSR     R5,DSTRBC
.ENDM   DSTRBC

.REM    \
        CALL TO WRITE A DATA WORD ALL OVER ONE PHYSICAL PAGE
        DP IS POINTER TO 36-BIT DATA
        P IS PHYSICAL PAGE NUMBER
        \

.MACRO  CSHPAG  DP,P
        $CSHPAG=1
.IIF    DF,TRAPS,       TRAP    105
.IIF    NDF,TRAPS       JSR     R5,CSHPAG       ;WRITE ONE PAGE
          DP                    ;PTR TO 36-BIT DATA
          P                       ;PHYS PAGE NBR (ADR13-26)
.ENDM   CSHPAG

.REM    \
CALL TO READ CACHE REFILL ADDRESS AND DATA
        \

.MACRO  RDRFL
        RDRFIL
.ENDM   RDRFL

.REM    \
CALL TO READ OLD AND NEW CONTENTS OF REFILL RAM.
REQUIRES SPECIAL AC CODE TO WORK.
\

.MACRO  RRFONW
        $RRFONW=1
.IIF    DF,TRAPS,       TRAP    106
.IIF    NDF,TRAPS,      JSR     R5,RRFONW
.ENDM   RRFONW


;SEQ183

.REM    \
CALL TO WRITE CACHE DIRECTORY PARITY TEST PATTERNS.
DAT IS ADDRESS OF PHYSICAL PAGE PATTERNS (FOUR OF THEM),
FLAG IS 0 TO WRITE NORMAL PARITY, 1 TO WRITE EVEN PARITY.
        \

.MACRO  WRCPAR  DAT,FLAG
        $WRCPAR=1
.IIF    DF,TRAPS,       TRAP    107
.IIF    NDF,TRAPS,      JSR     R5,WRCPAR
          DAT
          FLAG
.ENDM   WRCPAR

.REM    \
        CALL TO RESTORE THE USE OF MEMORY
        \
.MACRO  CMEMEN
        $CMEMEM=1
.IIF    DF,TRAPS,       TRAP    110
.IIF    NDF,TRAPS,      JSR     R5,CMEMEN
.ENDM   CMEMEN

.REM    \
        CALL TO INSERT BASE MEMORY PAGE INTO AN INSTRUCTION
ADDRESS FIELD.  BASE IS ADDED TO ADDRESS POINTED TO BY R0.
        \

.MACRO  INMBAS  B
        $INMBAS=1
.IIF    DF,TRAPS,       TRAP    111
.IIF    NDF,TRAPS,      JSR     R5,INMBAS
          B                                     ;ADDRESS OF PAGE OFFSET
.ENDM   INMBAS


;SEQ184

.REM    \
CALL TO PERFORM A "STEXCT" OF AN INSTRUCTION FOLLOWED BY
A "FIND" OF CLK EBOX REQ AND A CHECK OF EBOX/MBOX INTERFACE
SIGNAL STATES.  FIRST ARG IS INSTRUCTION POINTER, SECOND ARG IS
POINTER TO A THREE-WORD EXPECTED DATA TABLE.
        \

.MACRO  STEREQ  INS,TAB
        $STEREQ=1
.IIF    NDF,TRAPS,      JSR     R5,STEREQ       ;START INSTR & CHECK EBOX REQ'S
.IIF    DF,TRAPS,       TRAP    121             ;START INSTR & CHECK EBOX REQ'S
          .WORD INS                             ;INSTRUCTION POINTER
          .WORD TAB                             ;EXPECTED DATA TABLE POINTER
        .ENDM   STEREQ

.REM    \
CALL TO CHECK EBOX/MBOX INTERFACE SIGNALS.  ARG IS POINTER TO A
3-WORD EXPECTED DATA TABLE.
\

.MACRO  ESNAP   T
        $ESNAP=1
.IIF    NDF,TRAPS,      JSR     R5,ESNAP        ;CHECK EBOX SIGNALS
.IIF    DF,TRAPS,       TRAP    122             ;CHECK EBOX SIGNALS
          .WORD 1                               ;EXPECTED DATA TABLE POINTER
        .ENDM   ESNAP

.REM    \
CALL TO FIND 16K OF MEMORY AND SAVE BASE ADDRESS.  C-BIT IS SET IF NONE
WAS FOUND.  ARG IS ADDRESS OF WHERE BASE IS TO BE STORED.
        \

.MACRO  FNDM16  B
        $FNDM16=1
.IIF    NDF,TRAPS,      JSR     R5,FNDM16       ;FIND 16K OF MEMORY
.IIF    DF,TRAPS,       TRAP    123             ;FIND 16K OF MEMORY
          .WORD B                               ;STORE BASE HERE
        .ENDM   FNDM16

.REM    \
SAVE MEMORY CONFIGURATION CALL.
        \
.MACRO  SAVMCN
        $SAVMCN=1
.IIF    NDF,TRAPS,      JSR     R5,SAVMCN       ;SAVE MEM CONFIGURATION
.IIF    DF,TRAPS        TRAP    124             ;SAVE MEM CONFIGURATION
        .ENDM   SAVMCN



;SEQ185


;SEQ134

.SBTTL          CHANNEL MACRO LIBRARY  02-FEB-76
.REM    \
        CHANNEL COMMAND WORD MACRO.  GENERATES
A CCW FROM THE FOLLOWING ARGUMENTS.
        CCW     OP              ADR,WC,E,R

OP=     CHLT FOR A 0 OP CODE
        CJMP FOR A 1 OP CODE
        CDTA FOR A 2 OP CODE
ADR=    ADDRESS FIELD
        WC=     WORD COUNT (OPTIONAL)
        E=      NONBLANK FOR END BIT
        R=      NONBLANK FOR REVERSE
\
.MACRO  CCW             OP,ADR,WC,END,REV
        CHLT=0
        CJMP=1
        CDTA=2
        .IIF    B,WC,W=0
        .IIF    NB,WC,W=WC
        .IIF    B,REV,R=0
        .IIF    NB,REV,R=1
        .IIF    B,END,E=0
        .IIF    NB,END,E=1
        ADH=0
        ADL=0
        .IRPC   AD,ADR
        .IIF    GE,<ADL-10000>,ADH=<10*ADH>+<ADL/10000>
        ADL=10*<ADL&7777>+AD
        .ENDM
.NLIST  SRC
        .BYTE   <ADL&377>,<<ADL/400>!<ADH*200&377>>,<<ADH/2&77>!<<W&3>*100>>
        .BYTE<<W&1774>/4>,<<<W&2000>/2000>!<R*2>!<E*4>!<OP*4>>
.LIST   SRC
.ENDM   CCW


;SEQ135

.REM    \
        CBUS DATA MACRO.  GENERATES A 36-BIT
OPERAND FOR PERFORMING A DIAGNOSTIC FUNCTION
TO SIMULATE CBUS REQUESTS.
\

.MACRO  CBUS    LST
        RST=200
        ST=100
        DON=20
        CTOM=10
        STR=4
        SLW=2
        FST=1
        LOR=0
.IRP    L1,<LST>
        LOR=LOR!L1
.ENDR
.NLIST  SRC
          .BYTE 0,0,<LOR&3>*100
          .BYTE <LOR>/4,0
.LIST   SRC
.ENDM   CBUS
.REM    \
        READ THE CCW CHA ADDRESS REGISTER AND RETURN A POINTER
TO THE 22-BIT VALUE IN R0
\
.MACRO  CCWRD
.IIF    NDF,TRAPS,      JSR     R5,CCWRD                ;GET CCW ADR
.IIF    DF,TRAPS,       TRAP    131             ;GET CCW ADR
.ENDM   CCWRD
.REM    \
        GENERATE A CALL TO SUBROUTINE WHICH GENERATES ENOUGH MBOX
CLOCKS TO PERFORM THE SPCIFIED NUMBER OF MEMORY REFERENCES.
\
.MACRO  MEMREF  N
.IIF    NDF,TRAPS       JSR     R5,MEMREF               ;ENGOUH MBOX CLOCKS
.IIF    DF,TRAPS        TRAP    147             ;ENOUGH MBOX CLOCKS
          .WORD N                       ;FOR THIS MANY MEM REFS
.ENDM   MEMREF


;SEQ136

.REM    \
        STOP CHANNEKL TIMING
\
.MACRO  STOPCH
.IIF    NDF,TRAPS,      JSR     R5,STOPCH               ;STOP CHANNEL TIMING
.IIF    DF,TRAPS        TRAP    142     ;STOP CHANNEL TIMING
.ENDM   STOPCH
.REM\
        RESTART CHANNEL TIMING
\
.MACRO  STARCH
.IIF    NDF,TRAPS,      JSR     R5,STARCH       ;RESTART CHANNEL TIMING
        
.IIF    DF,TRAPS,       TRAP    143             ;RESTART CHANNEL TIMING
.ENDM   STARCH
.REM    \
        SYNCHRONIZE MBOX WITH CHANNEL TIMING & RESTART CHANNEL
TIMING
\
.MACRO  CHSYNC
.IIF    NDF,TRAPS,      JSR     R5,CHSYNC               ;SYNC MBOX & RESTART CHANS
.IIF    DF,TRAPS,       TRAP    144     ;SYNC MBOX & RESTART CHANS
.ENDM   CHSYNC
.REM    \
        DO A CHANNEL READ
\
.MACRO  MEMRD
.IIF    NDF,TRAPS,      JSR     R5,MEMRD                ;DO CHAN READ
.IIF    DF,TRAPS,       TRAP    145     ;DO CHAN READ
.ENDM   MEMRD
.REM    \
        DO A CHANNEL WRITE
\
.MACRO  MEMWR
.IIF    NDF,TRAPS,      JSR     R5,MEMWR                ;DO CHAN WRITE
.IIF    DF,TRAPS        TRAP    146             ;DO CHAN WRITE
.ENDM   MEMWR


;SEQ137

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH PERFORMS THE
SETUP OF A COMMAND WORD AT EPT+3000+(4*CH).
\
.MACRO  SETEPT  CH,DTA
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL
        .ENDC
        .IF     NB,DTA
        .IFT
          MOV   #DTA,R1         ;COMMAND WORD POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SETEPT               ;CONDITION EPT
.IIF    DF,TRAPS,       TRAP    132     ;CONDITION EPT
.ENDM   SETEPT
.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH GETS
TO A POINT WHERE THE CBUS SELECT FOR A SPECIFIC 
CHANNEL IS TRUE.
\
.MACRO  CHSEL   CH
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL #
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,CHSEL                ;GET TO CBUS SELECT
.IIF    DF,TRAPS,       TRAP    1133            ;GET TO CBUS SELECT
.ENDM   CHSEL
.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH
SIMULATES A CBUS COMMAND FOR A CHANNEL.
\
.MACRO  SIMBUS  CH,COM
        .IF     NB,CH
        .IFT
          MOV   #CH,R0          ;CHANNEL #
        .ENDC
        .IF     NB,COM
        .IFT
          MOV   #COM,R1 ;COMMAND POINTER
        .ENDC
.IIF    NDF,TRAPS,      JSR     R5,SIMBUS       ;SIMULATE
.IIF    DF,TRAPS,       TRAP    134             ;SIMULATE COMMAND
.ENDM   SIMBUS


;SEQ138

.REM    \
        GENERATE A CALL TO A SUBROUTINE WHICH TESTS FOR THE
OCCURENCE OF A MEMORY REFERENCE.  STEPS THE CLOCK ONCE.
\
.MACRO  MEMTST
.IIF    NDF,TRAPS,      JSR     R5,MEMTST       ;MEMREF?
.IIF    DF,TRAPS        TRAP    135             ;MEM REF?
.ENDM   MEMTST
.REM    \
        MACRO TO ASK FOR AND GET A CHANNEL #.
\
.MACRO  TTICH
.IIF    NDF,TRAPS,      JSR     R5,TTICH        ;GET CHANNEL #
        
.IIF    DF,TRAPS,       TRAP    136             ;GET CHANNEL #
.ENDM   TTICH

.REM    \
        MACRO TO SELECT A STARTING CHANNEL #.
\
.MACRO  CHSTRT
.IIF    NDF,TRAPS,      JSR     R5,CHSTRT       ;STARTING CHANNEL TO R4
.ENDM   CHSTRT
.REM    \
        MACRO TO UPDATE THE CHANNEL #
\
.MACRO  NEXTCH
.IIF    NDF,TRAPS,      JSR     R5,NEXTCH       ;NEXT CHANNEL TO R4
.ENDM   NEXTCH
.REM    \
        MACRO TOR EPORT CHANNEL # AND DETERMINE SUBTEST.
\
.MACRO  CHTYP
.IIF    NDF,TRPAS,      JSR     R5,CHTYP        ;TYPE CHANNEL
.IIF    DF,TRAPS,       TRAP    137             ;TYPE CHANNEL
.ENDM   CHTYP


;SEQ139

.REM    \
        CHANNEL FAULT CALLER.  PUTS THE CHANNEL IN R4 ON THE ERROR
STACK AND DETERMINES THE SUBTEST.  ACCEPTS THE SAME ARGUMENTS AS
THE DIACON FAULT MACRO.
\
.MACRO  CFAULT  ARG
          JSR   PC,CFAULT               ;SAVE CHAN # & FAULT RETURN
        .IIF    B,<ARG>         .WORD 0
        .IF     NB,<ARG>
        .NLIST  SRC
        .ASCIZ  \'ARG'\
        .EVEN
        .LIST   SRC
        .ENDC
.ENDM   CFAULT
.REM    \
        CALLER FOR A ROUTINE WHICH LOOKS FOR THE NEXT MEMORY
REFERENCE.  SETS THE C-BIT IF TIMEOUT.
\
.MACRO  TSTREF
.IIF    NDF,TRAPS,      JSR     R5,TSTREF       ;GET TO SBUS ADR HOLD
.IIF    DF,TRAPS.       TRAP    140             ;GET TO SBUS ADR HOLD
.ENDM   TSTREF

.REM    \
        MACRO TO TEST CHANNEL STATUS WORD 1.
\
.MACRO  STACOM  ST
.IIF    NDF,TRAPS,      JSR     R5,STACOM       ;TEST STATUS
.IIF    DF,TRAPS.       TRAP    141     ;TEST STATUS 1
          .WORD ST              ;EXPECTED STATUS POINTER
.ENDM
.REM    \
        MACRO TO TREST CHANNEL STATUS WORD 2.
\
.MACRO  STAT2   ST
.IIF    NDF,TRAPS.      JSR     R5,STAT2                ;TEST STATUS 2
.IIF    DF,TRAPS,       TRAP    150             ;TEST STATUS 2
          .WORD ST              ;ERXPECTED STATUS POINTER
.ENDM

.SBTTL  *DIACON*        DIAGNOSTIC MACROS 15-JUL-77


.REM    \
        MACRO TO GENERATE A CALL TO PRINT VARIABLE LENGTH OCTALLY GROUPED
BINARY DATA.  PARAMETERN IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
SUBROUTINE ASSEMBLED ONLY IF PARAMETER $SPNTVAR IS DEFINED.
\

.MACRO  PNTVAR  N
        JSR    R5,PNTVAR                ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  PNTVAR


.REM    \
        MACRO TO PUT VARIABLE LENGTH BINARY DATA ON THE ERROR STACK.
PARAMETER N IS THE NUMBER OF BITS (NOT TO EXCEED 48.)
\

.MACRO  STKVAR  N
         JSR    R5,STKVAR               ;PRINT N BIT BINARY
        .VBIN    N
.ENDM  STKVAR


.REM    \
        MACRO TO GENERATE BYTE LENGTH, # OF SHIFTS TO LEFT JUSTIFY AND
THE NUMBER OF OCTAL GROUPS FROM THE NUMBER OF BINARY BITS SPECIFIED.
\

.MACRO    .VBIN    N
.NLIST    SRC
          NN=^D'N
          BYT=NN/^D8
          .IIF    GT,NN-<BYT*^D8>,BYT=BYT+1     ;# OF BYTES
          JST=<BYT*^D8>-NN      ;# OF SHIFTS TO MSB
          CHR=NN/3              ;# OF OCTAL CHARACTERS
          ODC=NN-<CHR*3>                ;# OF LEFTOVER BITS
          XXX=BYT!<JST*^D8>!<ODC*^D256>!<CHR*^D2048>
           .WORD XXX
.LIST    SRC
.ENDM    .VBIN

.REM    \
        16-BIT STANDARD ERROR REPORTING MACRO.
                COR = ADDRESS OF CORRECT DATA
                ACT = ADDRESS OF ACTUAL DATA
                MSK = ADDRESS OF MASK (OPTIONAL)
                ARG = ASCII MESSAGE (OPTIONAL)
\
.MACRO  ERR16    COR,ACT,MSK,ARG
        .IF       NB,MSK
          JSR   R5,MERR16
        .IFF
          JSR   R5,ERR16
        .ENDC
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR16


.REM    \
        36-BIT STANDARD ERROR REPORTING MACRO.  SAME AS ERR16
EXCEPT THAT DATA POINTED TO IS 5-BYTE FORMAT.
\
.MACRO  ERR36   COR,ACT,MSK,ARG
        .IF     NB,MSK
          JSR   R5,MERR36
        .IIF
          JSR   R5,ERR36
        .ENDC   
        .IF     NB,<ARG>
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
          .WORD 0
        .ENDC
.IIF    NB,MSK, .WORD MSK       ;MASK POINTER
          .WORD ACT             ;ACTUAL POINTER
          .WORD COR             ;EXPECTED POINTER
.ENDM   ERR36

.REM    %
        NORMAL - TEST COMPLETION MACRO.
%
.MACRO  NORMAL
          JMP    NORMAL         ;TEST PASSES
.ENDM

.REM    %
        NORSKP - ALTERNATE TEST COMPLETION MACRO.  USE IF THE CURRENT
TEST IS PROPER INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT 
TEST INITIALIZATION FOR THE NEXT ONE.  CAUSES THE NEXT TEST
INITIALIZATION TO BE SKIPPED EXCEPT DURING SCOPE LOOPS.
%
 .MACRO  NORSKP
          JMP    NORSKP         ;TEST PASSES, SKIP NEXT INIT.
.ENDM


.REM    %
        FAULT - FAULT RETURN MACRO. ASSUMES THAT ERROR REPORTING DATA
IS ALREADY ON THE ERROR STACK.  OPTIONAL TEST IS A MESSAGE TO BE
TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  FAULT    ARG
        JSR        PC,FAULT
        .IF       B,<ARG>
          .WORD 0
        .IFF
        .NLIST    SRC
.IF     DF,$RELIA
        .LIT    TEXT,<.ASCIZ    %'ARG'%>
        .LIST    SRC
           .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM    FAULT

.REM    %
        PFAULT - ALTERNATE FAULT RETURN MACRO.  ASSUMES THAT ERROR
REPORTING DATA IS ALREADY ON THE ERROR STACK.  THE ARGUMENT IS A
POINTER TO TEXT TO BE TYPED FOLLOWING ERROR REPORTING.
%
.MACRO  PFAULT  MSGPTR
        JSR  PC,FAULT
         .WORD MSGPTR!BIT15     ;TEXT POINTER
.ENDM   PFAULT

.REM    %
        ERROR & ERRORA - ILLOGICAL FAULT RETURN MACROS.  USE ONLY IF A
FAULT IS DETECTED IN PREVIOUSLY TESTED LOGIC OR FUNCTIONS.  HAS ALL THE
PROPERTIES OF FAULT EXCEPT THAT NO ISOLATION ROUTINE MAY BE CALLED.
DOES NOT REPORT SUBTEST IN ORDER TO PERMIT CALLS FROM INITIALIZATION
ROUTINES OR ANY SUBROUTINE DEPTH.
%
.MACRO  ERROR    ARG
        JSR    PC,ERROR
        .IF     B,<ARG>
        .WORD 0
        .IFF
        .NLIST  SRC
        .IF     DF,$RELIA
        .LIT    TEXT,<ASCIZ    %'ARG'>
        .LIST   SRC
          .WORD TEXT!BIT15
        .IFF
        .ASCIZ  %'ARG'%
        .EVEN
        .LIST   SRC
        .ENDC
        .ENDC
.ENDM   ERROR

.MACRO  ERRORA  MSGPTR
          JSR  PC,ERROR
        .WORD MSGPTR!BIT15      ;TEXT POINTER
        .ENDM   ERRORA


.REM    %
        SYNC,SYNCLIF & INSYNC - SCOPE SYNC MACROS
%
.MACRO SYNC
        JSR  PC,SYNC            ;SYUNC SCOPE @ A36,E1
.ENDM

.MACRO  SYNCIF
        JSR  PC,SYNCIF          ;SYNC @ A36,E1 IF FAILING SUBTEST
.ENDM

.MACRO  INSYNC
        JSR  PC,INSYNC          ;NEXT SUBTEST,FAULT SYNC @ A36,E1
.ENDM

.MACRO  NEWSUB
        JSR  PC,NEWSUB          ;NEW SUBTEST,CHECK TTY
.ENDM

.REM    %
        ERROR REPORT MACROS TO SIMULATE PNTXXX CALLS BY PUTTING
        THE EMT AND DATA ON THE ERROR STACK FOR LATER EXECUTION.
%
.MACRO  ERRCOM  EMT.
          JSR  R5,$ERPNT                ;RO & EMT TO ERROR STACK
        .WORD EMT.
.ENDM  ERRCOM

.MACRO ERRMSG  $ARG
        .NLIST  SRC
        .LIT    TEXT,<.ASCIZ    %'$ARG'%>
        .LIST  SRC
          MOV  #TEXT,R0
        ERRCOM  PNTAL
.ENDM  ERRMSG

.MACRO  ERRDAT  $DAT
..IIF    NB,$DAT,       MOV  #$DAT,R0           ;POINT TO 36-BIT DATA
          JSR  R5,STKDAT                ;PUT IT ON THE ERROR STACK
.ENDM    ERRDAT

.MACRO  ERR36T  $TXT,$DAT
        JSR  R5,STK36T          ;TEXT & 36-BIT DATA TO ERROR STACK
        .NLIST  SRC
          .LIT  TEXT,<ASCIZ    %"$TXT'%>
        .LIST  SRC
          .WORD  TEXT
                  .WORD $DAT
.ENDM  ERR36T

.MACRO ERRADR  $ADR
        .IF    B,$ADR
          JSR  R5,STKADR                ;22-BIT ADDRESS TO ERROR STACK
        .IFF
         JSR  R5,STK22H         ;22-BIT ADDRESS TO ERROR STACK
          .WORD  $ADR
        .ENDC
.ENDM  ERRADR

.MACRO  ERRCHR
        ERRCOM  PNTCHR
.ENDM   ERRCHR

.MACRO  ERROCT
        ERRCOM  PNTOCT
.ENDM   ERROCT

.MACRO  ERROCS
        ERRCOM  PNTOCS
.ENDM   ERROCS

.MACRO  ERRDEC
        ERRCOM  PNTDEC
.ENDM   ERRDEC

.MACRO  ERCRLF
        ERRCOM  PCRLF
.ENDM   ERCRLF

.REM    %
        MACRO TO GENERATE A FORMAT TABLE:  TO USE:
LABEL: FTM. <FUNC1,FUNC2,FUNC3,FUNC4>
        WHERE FUNCN IS THE LABEL OF THE JUIMP TABLE ENTRY TO PERFORM
        THE DESIRED FUNCTION.
%
         .MACRO  FTM.   FUNC
ZZZ=0
XXX=0
.IRP    F,<FUNC>
.IF EQ <ZZZ>
.NARG  ZZZ
.ENDC
XXX=XXX+1
.IF EQ <ZZZ-XXX>
        .BYTE <F-TJMPT>!1
.IFF
        .BYTE <F-TJMPT>
.ENDC
.ENDM
.ENDM   FTM.








.REM    %
        TEST CONTROL IS FACILITATED BY TABLES SUPPLIED BY THE USER.
TABLE INITAB IS A LIST OF INITIALIZATION ROUTINES TO BE EXECUTED BEFORE
CALLING A TEST.  TABLE TESTAB IS A LIST OF TESTS.  SINCE ALL LEGAL
ADDRESSES FOR INITIALIZATION OR TEST CALL ARE EVEN AND LESS THAN 100000,
BITS 0 & 15 ARE USED TO PROVIDE DIACON WITH INFORMATION REGARDING
DISPATCHING OPTIONS.  THE USE OF THESE BITS IS AS FOLLOWS:

        TABLE & BIT     FUNCTION
        -----------     --------

        INITAB BIT 0    REINITIALIZE AFTER FAULT
INITAB BIT 15   ENTER INIT AT PC+2 EXCEPT FOR SCOPE LOOPS
        TESTAB BIT 0    PDP-10 FAST LOOP USED FOR SCOPE LOOPS
        TESTAB BIT 15   TEST NOT REQUIRED FOR XOR TESTING

THIS VERSION OF DIACON SUPPORTS TEST INTERRUPTION CAPABILITIES.  AN
ALTMODE (ESCAPE) TYPED DURING EXECUTION PERMITS THE USER TO PERFORM
A KLDCP COMMAND LINE.  FOLLOWING COMMAND EXECUTION, THE TEST WILL
CONTINUE.
%


.SBTTL  *DIACON*        DIAGNOSTIC EXECUTIVE  4-FEB-77
.REM    %
        THIS ROUTINE DOES TEST DISPATCHING, FAULT CONVERGENCE,
       AND SCOPE LOOPS.  SWITCH 1 PUTS THE PROGRAM IN COMMAND MODE.
THE XOR TESTER IS ANBLED BY BEING READY UPON INITIAL START.
TYPE H FOR HELP.
%
START:  BR      STARTA          ;START @ 3000, CONVERGENCE ALLOWED
        MOVB    #-1,HARD               ;START @ 3002, NO CONVERGENCE
        BR      STARTB          ;
STARTA:  CLRB   HARD            ;CLEAR SOLID FAULT FLAG
STARTB:  MOV    R0,TESTSP       ;SAVE STACK LOCATION
        PNTRST                  ;RESET OUTPUT BUFFER
        MOV     R0,$TTYO                ;SAVE ITS LOCATION
DIACON:  CLR    TSTART           ;CLEAR TEST START
        CLR     TEND.           ;CLEAR LOOP END
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     #OPRSEL,R0      ;OPERATOR SWITCH SET?
        BEQ     MX..            ;NO,START TEST

        ;DIACON COMMAND PROCESSOR

        DIAEND=CMDLST-DIATAB

        PMSG    <DIACON\>
DIACOM: PFORCE                  ;FORCE TYPEOUTS
        PMSG    <*_>                    ;PRINT AN *
        MOV     #DIACOM,COMRET          ;SET COMMAND RETURN
        TTILNW                          ;WAIT FOR REPLY
        TTICHR                          ;GET FIRST CHARACTER
        CMP     R0,#CR                  ;CARRIAGE RETURN?
        BEQ     DIACOM                  ;YES, IGNORE IT
        CMP     R0,#'.                  ;PERIOD?
        BEQ     CONCMD                  ;YES, CONSOLE COMMAND
        MOV     R0,R1                   ;ASSEMBLE 2 CHARACTERS
        TTICHR                  ;
        SWAB    R0                      ;
        BISB    R1,R0                  ;
        CLR     R1                      ;CLEAR SCAN INDEX
1$:     CMP     R0,DIATAB(R1)           ;SCAN COMMAND LIST
        BEQ     DIACMD                  ;
        INC     R1                      ;
        INC     R1                      ;
        CMP     R1,#DIAEND              ;
        BLT     1$                      ;
CONCMD:  CLR    R0                      ;
        PRGCMD                          ;PASS INPUT TO CONSOLE
        BR      DIACOM                  ;NEXT COMMAND
DIACMD: JMP     @CMDLST(R1)             ;DO COMMAND FOUND

.SBTTL          DIACON COMMANDS

        ;DIACON COMMAND LIST
DIATAB: .BYTE   'H,CR           ;H - HELP
        .BYTE   'H,'E           ;HE - MORE HELP
        .BYTE   'T,'S           ;TS - TEST START
        .BYTE   'T,'L           ;TL- TEST LOOP
        .BYTE   'P,'S           ;PS - PRINT SYMPTOM
        .BYTE   'F,'B           ;FB - SET FUNCTION BREAKPOINT
        .BYTE   'F,'C           ;FC - FUNCTION BREAK CONTINUE
        .BYTE   'C,'B           ;CB - CLEAR FUNCTION BREAKPOINT
        .BYTE   'R,'G           ;RG - PRINT FN BREAK REGISTERS
 

CMDLST: .WORD   H..             ;LIST MUST FOLLOW DIATAB
        .WORD   HE..            ;
        .WORD   TS..            ;
        .WORD   TL..            ;
        .WORD   PS..            ;
        .WORD   FB..
        .WORD   FC..
        .WORD   CB..
        .WORD   RG..

STKERR: POP     R0              ;DISCARD SUBR ENTRY POINT
DIAERR: PNTCI,'?                        ;IMPROPER COMMAND, PRINT ?
        BR     DIACOM                ;TRY AGAIN
CONRET: PMSG    <TIMEOUT\>      
        ERREOP                  ;RETURN TO CONSOLE

        ;HELP COMMANDS
H..:    PNORML;NOT FORCED
        PMSG    <PROPER ENTRIES ARE:\>
        PMSG    <HE	MORE HELP\>
        PMSG    <TS	TEST START\>
        PMSG    <TL	TEST LOOP\>
        PMSG    <PS	PRINT SYMPTOM\>
        PMSG    <FP	SET FUNCTION BREAKPOINT\>
        PMSG    <FC	FUNCTION BREAK CONTINUE\>
        PMSG    <CB	CLEAR FUNCTION BREAK\>
        PMSG    <RG	PRINT BREAK REGISTERS\>


        BR      DIACOM


HE..:   PNORML                  ;NOT FORCING TYPEOUTS
        PMSG    <H DIACON.HLP>
        MOV     #-1,R0
        PRGCMD                  ;PRINT HELP FILE
        BR      DIACOM          

        ;REPORT LAST SYMPTOM

PS..:   MOV     LSTPC,R3                ;GET LAST FAULT PC
        BEQ     1$                      ;NO FAULT
        JMP     TYPSYM                  ;TYPE SYMPTOM

1$:     PMSG    <NO SYMPTOM\>
        BR      DIACOM

        ;TEST START

TS..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        BR      2$              ;
1$:     PMSG    <FIRST >                 ;ASK FOR FIRST TEST #
        JSR     PC,GETTST               ;GET IT
2$:     MOV     R0,TSTART               ;SAVE TEST START
        CLR     TEND.                   ;CLEAR LOOP END
MX..:   JMP     MODEX                   ;START TEST

        ;TEST LOOP

TL..:   TTISDL                  ;TEST SPECIFIED?
        BCS     1$                      ;NO, GET ONE
        JSR     PC,TCHK..               ;TEST FORMAT
        MOV     R0,TSTART               ;SAVE LOWER LIMIT
        TTISDL                          ;2ND TEST SPECIFIED?
        BCS     2$                      ;NO, USE LOWER LLIMIT
        JSR     PC,TCHK..               ;GET & TEST UPPER LIMIT
        BR      3$                      ;
1$:     PMSG    <FIRST >                 ;GET START OF TEST LOOP
        JSR     PC,GETTST               ;
        MOV     R0,TSTART               ;SVE TEST START
        PMSG    <LAST >                  ;GET TEST END
        JSR     PC,GETTST                      ;
        TST     R0                      ;ANY SPECIFIED?
        BNE     3$                      ;YES, USE IT
2$:     MOV     TSTART,R0               ;NO, USE LOWER LIMIT
3$:     CMP     R0,TSTART               ;TEST RANGE
        BLT     DIAERR                  ;UPPER LIMIT TOO SMALL
        MOV     R0,TEND.                ;SET UPPER LIMIT
        BR      MODEX                   ;START TEST

GETTST: PMSG    <TEST: _>
        TTILNW                         ;WAIT FOR REPLY
TCHK..: TTIDEC                         ;CONVERT TEST TO OCTAL
        MOV     R0,R0           ;TEST R0 W/O LOSING C-BIT
        BCC     1$                      ;FORMAT OK
        BNE     STKERR                  ;IMROPER INPUT IF NOT ZERO
1$:     BNE     2$                      ;TEST # NOT 0
        INC     R0                      ;ZER0 DEFAULT TO 1
2$:     CMP     R0,#376                 ;TEST FORMAT
        BHI     STKERR                  ;IMPROPER FORMAT
        CMPB    R0,TESTAB             ;TEST RANGE
        BLE     3$                      ;O.K.
        MOVB    TESTAB,R0               ;TOO BIG, USE LAST TEST #
3$:     RTS     PC                      ;TEST # IN R0

.SBTTL          EXEC

        ;MODE DETERMINATION & INITIALIZATION

MODEX:  MOV     #CONVRG,R4             ;CLEARS EXEC FLAGS
1$:     CLR     (R4)+                   ;CLEARS A WORD
        CMP     #SAVETP,R4              ;LAST ONE CLEARED?
        BGT     1$                      ;NO, LOOP
        MOV     ERSI..,ERSP..           ;RESET ERROR STACKS
        MOV     ERTI..,ERTP..           ;
        MOV     #77777,R0               ;
        MOV     R0,SAVEPC               ;SET ERROR PC MAX
        MOV     R0,SUBTST               ;SET SUBTEST MAX
        MOVB    R0,XMODE                ;SET XOR MODE
        PUSH    ERRVEC                  ;SAVE TIMEOUT VECTOR
        MOV     #NOXOR,ERRVEC           ;SET TIMEOUT VECTOR
        MOV     XORSR+2,R0              ;CHECK FOR XOR
        TSTB    XMODE                   ;XOR CLEAR O.K.?
        BEQ     XREST                   ;NO
        BIT     XORSR,#BIT07            ;XOR READY?
        BNE     XREST                   ;YES
        CLRB    XMODE                   ;NO, CLEAR XOR MODE
XREST:  POP     ERRVEC                  ;RESTORE TIMEOUT VECTOR
        MOV     INITAB,R3               ;PROGRAM INITIALIZATION?
        BEQ     NEWPAS                  ;NONE SPECIFIED
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKPOINTS DURING INITIALIZATION
        PFORCE                          ;FORCE TYPEOUTS
        JSR     PC,(R3)         ;PROGRAM I.D./PARAMETERS
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
CLRLP:  CLRB    LOOPEN                  ;CLEAR LOOP ENABLE


        ;NEW PROGRAM PASS

NEWPAS: CLR     TSTNUM                  ;CLEAR TEST #
        CLRB    SKPFLG                  ;CLEAR INITILIZATION SKIP
        MOVB    #$DFTBP,$BPN            ;RE-INIT BACKPLANE # TO DEFAULT
        TSTB    XMODE                   ;XOR MODE?
        BEQ     TSTINI                  ;NO
        TSTB    LOOPEN                  ;LOOPING ?
        BNE     1$                      ;IF SO, DON'T PRINT
        PMSG    <XOR START\>            
1$:     MOV     TSTART,XSAVE           ;SAVE TEST START
        MOV     #377,TSTART             ;INITIALIZE XOR


        ;TEST DISPATCHING

TSTINI: CMP     SP,TESTSP               ;STACK POINTER O.K.?
        BEQ     1$                      ;YES
        PFORCE
        PMSG    <PS ERR, TEST >
        MOV     TSTNUM,R0               ;PRINT TEST #
        PNTDEC                          ;
        FATAL                           ;SP CHANGED BY TEST
1$:     PNORML                          ;CLEAR FORCED TYPEOUTS
        INC     TSTNUM                  ;SET NEXT TEST #
        MOV     TSTNUM,R4               ;GET TEST #
        CMPB    R4,TESTAB               ;LAST TEST DONE?
        BLOS    2$                      ;NO, CONTINUE
        JMP     DONE                    ;YES, END PROGRAM
2$:     TSTB    SKPFLG                  ;SKIP INITIALIZATION?
        BEQ     RETEST                  ;NO, FLAG NOT SET
        CLRB    SKPFLG                  ;CLEAR INITIALIZATION SKIP
        BR      RTEST                   ;NEXT TEST
RETEST: ASL     R4                      ;;MUL TEST # BY 2
        MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;BYPASS IF NONE
        BPL     ITEST                   ;IF NOLOAD ROUTINE
        ADD     #2,R3                   ;CHANGE POINTER TO LOAD
ITEST:  BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        MOV     FNBRK,SAVBRK            ;SAVE FUNCTION BREAKPOINT
        CLR     FNBRK                   ;NO BREAKS DURING INITIALIZATION
        JSR     PC,(R3)                 ;DO INITIALIZATION
        MOV     SAVBRK,FNBRK            ;RESTORE FUNCTION BREAKPOINT
RTEST:  JSR     PC,CHKCC.               ;TTY INPUT CHECK
        MOV    TSTNUM,R4               ;GET TEST #
        BEQ     NORINI                  ;NO TEST DISPATCH FOR INIT
        CMP     R4,TSTART                       ;START REACHED
        BLT     TSTINI                  ;NO, INITIALIZE
        ASL     R4                      ;;MUL TEST # BY 2
        MOV     TESTAB(R4),R3           ;GET TEST ENTRY
        BPL     1$                      ;BIT 15 SET?
        TSTB    XMODE                   ;YES, BYPASS TEST IF XOR
        BNE     TSTINI                  ;NEXT TEST
1$:     BIC     #BIT0!BIT15,R3          ;DISCARD LSB & MSB
        CLR     R5                      ;CONVENTION AT ENTRY
        JMP     (R3)                    ;DO TEST
LOOPT:  ASL     R4                      ;MUL TEST # BY 2
LOOPT1: MOV     INITAB(R4),R3           ;GET INITIALIZATION
        BEQ     RTEST                   ;RUN TEST IF NONE
        BR      ITEST                   ;INITIALIZE

NOXOR:  CLRB    XMODE                   ;TIMEOUT, CLEAR XOR MODE
        RTI                             ;RETURN

        ;RETURN FROM DIAGNOSTIC FOR TEST COMPLETION, RETURN IS
        ;VIA JMP.

NORSKP: COMB    SKPFLG          ;SET SKIP NEXT INITIALIZATION
NORMAL: MOV     ERSI..,ERSP..   ;RESET WORKING ERROR STACK
        MOV     TSTNUM,R4       ;GET TEST#
NORINI: CLRB    FASTLP          ;CLEAR FAST LOOP ENABLE
        JSR     PC,TLOOP               ;TEST FOR SCOPE LOOPS
1$:     TSTB    XMODE           ;XOR MODE?
        BNE     XTEST           ;YES
        CMP     CONVRG,R4              ;CONVERGE HERE?
        BNE     TSTINI          ;NO, CONTINUE
        PMSG    <NO FAULT\>     
DKPASS: INC     PASS            ;INCREMENT PASS COUNT
        SWITCH                  ;GET SWITCH REG
        CMPB    DURERR,MAXERR   ;DURATION GT MAX?
        BLE     1$              ;NO
        MOVB    DURERR,MAXERR   ;SET NEW MAX CONSECUTIVE
1$:     CLRB    DURERR          ;CLEAR CONSECUTIVE FAULTS
        TSTB    NOTIME          ;TIMEOUT ACTIVE?
        BNE     2$              ;NO
        CMP     PASS,#50.               ;50 PASSES?
        BGE     3$              ;YES, ABORT
2$:     BIT     R0,#ABORT       ;ABORT?
        BEQ     NEWJMP          ;NO, RESTRT TEST
3$:     JMP     CONCAL          ;CALCULATE CONFIDENCE



        ;XOR TEST HANDLING

XTEST:  MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     XORSR,R1                ;GET XOR STATUS
        BIT     R1,#BIT07               ;XOR READY?
        BEQ     XWAIT           ;NO, QUIT
        BIT     R1,#BIT15               ;XERCPU?
        BEQ     1$                      ;NO ERROR DETECTEWD
        TSTB    LOOPEN                  ;FIRST FAULT?
        BNE     2$                      ;NO
        PMSG    <TEST >
        MOV     R4,R0                   ;GET TEST #
        PNTDEC                          ;PRINT IT
        PMSG    <, SUBTEST >
        MOV     R5,R0                   ;GET SUBTEST #
        PNTDEC                          ;PRINT IT
        PCRLF                           ;CARRIAGE RETURN
        MOVB    R1,LOOPEN               ;SET LOOP ENABLE
1$:     TSTB    LOOPEN          ;LOOP?
        BEQ     4$                      ;NO, NEXT TEST
2$:     CMP     CONVRG,R4               ;END OR NO GOBACK OR RERUN?
        BGT     4$                      ;NO, DO NEXT TEST
        MOV     R4,CONVRG               ;SET CONVERGE AT TEST #
        BIT     R1,#BIT08               ;GOBACK?
        BEQ     3$                      ;NO, TEST FOR RERUN
        CMP     R4,#1                   ;FIRST TEST?
        BEQ     NEWJMP                  ;YES, SAME AS RERUN
        DEC     R4                      ;BACKUP ONE TEST
        MOV     R4,TSTNUM               ;CORRECT TEST #
        BR      LOOPT                   ;DO PREVIOUS TEST
3$:     BIT     R1,#BIT03               ;RERUN?
        BNE     NEWJMP                  ;YES, DO IT
        CLR     CONVRG                  ;CLEAR TEST CONVERGENCE
        BR      LOOPT                   ;LOOP ON TEST
4$:     JMP     TSTINI                  ;NEXT INITIALIZATION



        ;LAST TEST DONE OR END OF INITIALIZATION

DONE:   CMP     TSTART,#377             ;INITIALIZATION ONLY?
        BEQ     IONLY                   ;YES
        CLRB    HARD                    ;CANNOT BE HARD FAULT IF END PASS
        TSTB    XMODE                   ;XOR MODE?
        BNE     XDONE                   ;YES MODULE PASS
        INC     PASS                    ;INCREMENT PASS COUNT






1$:     EOP                             ;NORMAL END
NEWJMP: JMP     NEWPAS                  ;RESTART TEST
IONLY:  CLR     TSTNUM                  ;CLEAR TEST NUMBER
        MOV     #BIT00,XORCR            ;ENABLE XOR
        MOV     XSAVE,TSTART                    ;ENABLE TEST START
        JMP     TSTINI                  ;START TEST
XDONE:  BIS     #BIT02,XORCR            ;SET XOR MUT PASS
        SWITCH                          ;GET SWITCH REG
        BIT     #CHAIN,R0               ;CHAIN MODE?
        BEQ     1$                              ;NO
        ERREOP                          ;YES, RETURN TO CONSOLE
1$:     JSR     PC,CHKCC.               ;CHECK FOR ^C
        BIT     XORSR,#BIT07            ;XCOR READY?
        BNE     1$                      ;YES, WAIT FOR POWER OFF
XWAIT:  SWITCH                          ;GET SWITCH REG
        BIT     R0,#ABORT               ;ABORT?
        BEQ     1$                      ;NO
        JMP     CONSOL                  ;RETURN TO CONSOL
1$:     BIT     XORSR,#BIT07            ;XOR READY?
        BEQ     XWAIT                   ;NO, WAIT FOR POWER ON
XCLEAR: TST     XORSR+2                 ;CLEAR XOR
        JMP     CLRLP                   ;RESTART TEST


        ;RETURN FROM DIAGNOSTIC TEST FOR ILLOGICAL FAULTS.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 IS MEANINGLESS.

ERROR:  MOV     #77777,R5               ;FLAG ILLOGICAL FAULT

        ;RETURN FROM DIAGNOSTIC TEST IF FAULT DETECTED.  RETURN
        ;IS VIA JSR PC.  REGISTER R5 MUST CONTAIN SUBTEST #.

FAULT:  POP     R3                      ;GET ERROR PC
        MOV     R3,LSTPC                ;SAVE IT
        MOV     R5,LSTSUB               ;SAVE SUBTEST
        MOV     TESTSP,SP               ;RESET STACK POINTER
        MOV     ERTI..,R1               ;INTERCHANGE BASE OF    
        MOV     ERSI..,ERTI..           ;WORKING & TYPEOUT
        MOV     R1,ERSI..               ;STACKS.
        MOV     ERTP..,SAVETP           ;SAVE OLD TYPEOUT END
        MOV      ERSP..,ERTP..           ;SET TYPEOUT END
        MOV     R1,ERSP..               ;RESET WORKING STACK POINTER
        MOV     TSTNUM,R4               ;GET TEST #
        TSTB    XMODE                   ;XOR MODE?
        BEQ     1$                      ;NO
        CLRB    LOOPEN                  ;YES, CLEAR LOOP ENABLE
        CLRB    XMODE                   ;CLEAR XOR MODE
        MOV     XSAVE,TSTART            ;RESTORE TEST START
        BIS     #BIT01,XORCR            ;SET SYSTEM ERROR
1$:     JSR     PC,ERHAND               ;HANDLE ERROR TYPEOUTS
        JSR     PC,TLOOP                ;TEST FOR SCOPE LOOPS
        TSTB    HARD                    ;CONVERGENCE ALLOWED?
        BEQ     2$                      ;YES
        JMP     TYPSYM                  ;NO, BYPASS IT
2$:     INC     PASS                    ;INCREMENT PROGRAM PASS
        CMP     CONVRG,R4               ;SAME TEST?
        BNE     10$                     ;NO
        CMP     SUBTST,R5                      ;SAME SUBTEST?
        BEQ     3$                      ;YES
        BGT     11$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
3$:     CMP     SAVEPC,R3               ;SAME PC?
        BEQ     4$                      ;YES
        BHI     12$                     ;NEW SYMPTOM
        JMP     OLDSYM                  ;RESTORE TYPEOUT STACK
4$:     INC     FAULTS                  ;COUNT SAME SYMPTOMS
        INCB    DURERR                  ;COUNT SEQUENTIAL FAULTS
        TSTB    MAXERR                  ;ANY NORMAL PASSES?
        BNE     5$                      ;YES, INTERMITTENT
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     5$                      ;NO, INTERMITTENT
        CMPB    #4,DURERR               ;4 SEQUENTIAL FAULTS?
        BGT     13$                     ;NO, LOOP ON TEST
        INCB    MAXERR                  ;SET MAX SEQUENTIAL=1
        JMP     NEWPAS                  ;RESTART TEST



        ;INTERMITTENT FAULT CONVERGENCE

5$:     CMPB    #5,DURERR               ;5 SEQUENTIAL FAULTS?
        BGT     7$                      ;NO, CHECK FREQUENCY
        CMPB    FAULTS,DURERR                   ;ALL FAULTS SEQUENTIAL?
        BNE     6$                      ;NO, INTERMITTENT
        CMPB    SYMPT,#1                        ;ONLY ONE SYMPTOM?
        BEQ     SOLID                   ;YES, SOLID FAULT
6$:     MOVB    #97.,PCT                ;CONFIDENCE=97%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
7$:     CMP     #1,R4                   ;FIRST TEST?
        BLT     8$                      ;NO
        CMP     #1,R5                   ;FIRST SUBTEST?
        BLT     8$                      ;NO
        MOVB    #99.,PCT                ;CONFIDENCE=99%
        JMP     CONFID                  ;TYPE CONFID. & SYMPTOM
8$:     MOV     R4,R1                   ;TEST # TO R1
        INC     R1                              ;USE N+1      
        MULT    CON90,R1                ;100X=231(N+1)
        MOV     FAULTS,R3               ;GET X
        MULT    SCALE,R3                ;SCALE IT
        CMP     R3,R1                   ;CONFIDENCE REACHED?
        BLT     9$                      ;NO
        MOVB    #90.,PCT                ;CONFIDENCE=90%
        BR      CONFID                  ;TYPE CONFID. & SYMPTOM
        
9$:     BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFIDENCE
        JMP     NEWPAS                  ;RESTART TEST



        ;NEW SYMPTOM DETECTED

10$:    MOV     R4,CONVRG               ;SAVE TEST #
11$:    MOV     R5,SUBTST               ;SAVE SUBTEST #
12$:    MOV     R3,SAVEPC               ;SAVE ERR0R PC
        INC     SYMPT           ;COUNT NEW SYMPTOM
        MOV     #1,FAULTS               ;SAME SYMPTOM=1
        MOVB    #1,DURERR               ;SEQUENTIAL FAULTS=1
        CLRB    MAXERR                  ;MAX SEQUENTIAL=0
        CMP     SYMPT,#1                ;FIRST SYMPTOM?
        BNE     14$                     ;NO
        BIT     R0,#PALERS              ;PRINT ALL ERRORS?
        BNE     13$                     ;YES, ALREADY DONE
        PMSG    <FAULT DETECTED\>
13$:    TST     TSTNUM                  ;ERROR IN ONE-TIME INIT?
        BEQ     TYPSYM                  ;YES,PRINT SYMPTOM
        JMP     RETEST                  ;NO,LOOP ON TEST
14$:    CLR     TSTART                  ;CLEAR TEST START
        BIT     R0,#ABORT               ;ABORT?
        BNE     CONCAL                  ;YES, CALCULATE CONFID.
CONCON: PMSG    <CONVERGING\>           ;CONTINUE CONVERGENCE
        JMP     CLRLP                   ;RESTART PROGRAM
SOLID:  PFORCE                          ;FORCE TYPEOUT
        PMSG    <SOLID FAULT\>          ;
        INCB    HARD                    ;SET HARD FAULT FLAG 
        BR      TYPSYM                  ;TYPE SYMPTOM


        ;RESTORES TYPEOUT STACK TO PREVIOUS SYMPTOM


OLDSYM: MOV     ERTI..,R1               ;INTERCHANGE BASE OF
        MOV     ERSI..,ERTI..           ;TYPEOUT AND WORKING
        MOV     R1,ERSI..               ;STACKS
        MOV     R1,ERSP..                       ;RESET WORKING STACK
        MOV     SAVETP,ERTP..           ;RESTORE TYPEOUT STACK END
        JMP     DKPASS          ;CONTINUE CONVERGENCE


        ;ABORT HAS FORCED CALCULATION OF FAULT CONVERGENCE
        ;CONFIDENCE OR CONVERGENCE HAS COMPLETED.

CONCAL: MOVB    MAXERR,R1               ;GET MAX DURATION
        CMPB    DURERR,R1               ;DURATION GT MAX?
        BLE     1$                      ;NO, USE MAX
        MOVB    DURERR,R1               ;USE CURRENT DURATION
1$:     MOVB    DURCON(R1),PCT          ;GET DURATION CONFIDENCE
        INC     R4                      ;N+1
        MOV     FAULTS,R1               ;# OF SAME SYMPTOMS
        MULT    SCALE,R1                ;100X
        MOV     R1,R2                   ;
        CLR     R0                      ;VALUE INDEX
2$:     MOVB    VALUE(R0),R1            ;GET MAGIC VALUE * 100
        MULT    R4,R1                   ;COMPUTE 100(VALUE) (N+1)
        CMP     R2,R1                   ;FAULTS GT VALUE (N+1)?
        BLT     3$                      ;NO
        INC     R0                      ;NEXT INDEX
        CMP     #6,R0                   ;LAST VALUE?
        BGT     2$                      ;NO, LOOP AGAIN
3$:     MOVB    FRECON(R0),R1           ;GET FREQUENCY CONFIDENCE
        CMPB    R1,PCT                  ;FREQUENCY GT DURATION?
        BLE     CONFID  ;NO
        MOVB    R1,PCT                  ;USE FREQUENCY
CONFID: PFORCE                          ;
        MOV     FAULTS,R0               ;GET # OF THIS SYMPTOM FAULTS
        PNTDEC                          ;PRINT IT
        PMSG    < OF THIS FAULT ON >
        MOV     PASS,R0                 ;GET # OF PROGRAM PASSES
        PNTDEC                          ;PRINT IT
        PMSG    < PASSES\>
        PMSG    <CONFIDENCE OF SOLID FAULT SYMPTOM IS >
        MOVB    PCT,R0          ;GET CONFIDENCE
        PNTDEC                          ;PRINT IT
        PNTCI,'%                                ;PRINT %
        PCRLF                           ;CARRIAGE/LINEFEED
TYPSYM: TST     CONVRG                  ;SYMPTOM SAVED?
        BNE     1$                      ;YES
        MOV     R3,SAVEPC               ;NO, SAVE IT
        MOV     TSTNUM,CONVRG           ;
        MOV     LSTSUB,SUBTST           ;
1$:     MOV     SAVEPC,R3               ;GET ERROR PC
        MOV     CONVRG,R4               ;GET TEST #
        MOV     SUBTST,R5               ;GET SUBTEST #
        PFORCE                          ;FORCE TYPEOUTS
        TSTB    HARD                    ;SOLID FAULT?
        BEQ     2$                      ;NO, DO TYPEOUT
        BIT     $R0SAV,#PALERS          ;PRINT ALL ERRORS?
        BNE     ISODET                  ;YES, NO NEED TO REPEAT
2$:     JSR     PC,FORSYM                       ;FORCE ERROR TYPEOUT


        ;DETERMINE IF ISOLATION ROUTINE IS TO BE CALLED

ISODET: INCB    LOOPEN                  ;ENABLE SCOPE LOOP
        CMP     R5,#77777          ;ILLOGICAL FAULT?
        BEQ     DIADON                  ;YES, NO ISOLATION
        MOVB    TESTAB+1,R0
        BLE     DIADON                  ;NO ISOLATION ROUTINES
        TSTB    HARD                    ;SOLID FAULT?
        BNE     ISCALL                  ;YES, DO ISOLATION
        CMPB    PCT,#90.                        ;HIGH CONFIDENCE?
        BGE     ISCALL                  ;YES, DO ISOLATION
        PMSG    <LOW FAULT CONFIDENCE, >
RISOL:  PFORCE                          ;FORCE TYPOUT
        PMSG    <RUN ISOLATION? _>
        TTILIN                          ;GET REPLY
        BCC     1$                              ;GOT IT
        JMP     CONRET                  ;TIMEOUT
1$:     TTIYES                          ;YES OR NO?
        BCS     RISOL                   ;GARBAGE
        BPL     ISCALL                  ;YES, DO IT
        CLRB    PCT                     ;CLEAR CONFIDENCE
        PNORML                          ;CLEAR FORCED TYPEOUTS
        BR      DIADON                  ;DONE

ISCALL:  ;LOAD & CALL ISOLATION ROUTINE
        PFORCE                          ;FORCE TYPEOUTS TO END CONTROL O
        PCRLF                           ;CARRIAGE RETURN
        PNORML                          ;NORMAL TYPOUTS
        MOVB    TESTAB+1,R1                     ;GET USUER PREFIX
        CMPB    R1,CONSOL-1             ;LOADED?
        BNE     1$                      ;NO, DO LOAD
        CMPB    CONVRG,CONSOL-2         ;
        BEQ     ISOPRM                  ;YES, BYPASS LOAD
1$:     PNTCI                           ;BUILD P COMMAND
                "P 
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
        MOV     #-1,R0                  ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG                       ;LOAD PROGRAM
        BCS     LOOKER                  ;LOOKUP OR LOAD ERROR
        MOVB    R1,CONSOL-1             ;IDENTIFY OVERLAY
        MOVB    CONVRG,CONSOL-2         ;
ISOPRM: MOV     #SUBTST,R4              ;POINTER TO SUBTEST  & PC
        MOV     ERTI..,R3               ;TYPEOUT STACK POINTER
        MOV     ERTP..,R2               ;TYPEOUT STACK END
        MOV     R2,SAVETP               ;SAVE IT
        MOV     #1$,R5                  ;PASS RETURN ADDRESS
        MOV     #STARTI,R0              ;CALL PROGRAM
        PRGCMD                          ;GO COMMAND
1$:      MOV    SAVETP,ERTP..   ;RESTORE TYPE POINTER


DIADON: SWITCH                          ;GET CONSOLE SWITCHES
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        BIT     R0,#TXTINH              ;INHIBIT TYPE TEXT?
        BNE     3$                      ;YES
        TSTB    HARD                    ;SOLID FAULT OR NO CONVERGENCE?
        BEQ     1$                      ;NO, INTERMITTENT
        PMSG    <\HC TO RESTART>
        BR      2$
1$:     PMSG    <\HC TO CONTINUE CONVERGENCE>
2$:     PMSG    < OR LOOP ON ERROR\>
3$:     PRGHLT                          ;CONTINUABLE RETURN
4$:     PNORML                          ;CLEAR FORCED PRINT     
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#LOOPER              ;LOOP ON ERROR?
        BNE     XLOOP                   ;YES, START LOOP
        TSTB    HARD                    ;SOLID FAULT?
        BNE     5$                      ;YES, RESTART
        INCB    NOTIME                  ;SET NO TIMEOUT
        JMP     CONCON                  ;CONTINUE CONVERGENCE
5$:     JMP     DIACON                  ;RESTART PROGRAM

LOOKER: PMSG    <MOUNT >                ;REQUEST MANUAL INTERVENTION
        JSR     PC,ISONAM               ;GET ISOLATION ROUTINE NAME
      PMSG      <  HC WHEN READY\>
        PRGHLT                          ;CONTINUABLE RETURN
        JMP     RISOL                   ;MOUNTED, TRY AGAIN
XLOOP:  MOV     CONVRG,R4               ;GET TEST #
        JMP     LOOPT                   ;LOOP ON TEST

ISONAM: ;PUT ISOLATION ROUTINE NAME IN OUTPUT BUFFER
        MOV     R1,R0                   ;PROGRAM NAME IS
        PNTCHR                          ;USER PREFIX
        MOV     CONVRG,R0                       ;+ TEST #
        PNTDEC                          ;
        PMSG    <A11>                   ;.A11 EXTENSION
        RTS     PC                      ;RETURN


.REM    %
        THIS SUBROUTINE HANDLES ERROR TYPEOUTS
        %
ERHAND: SWITCH                          ;GET SWITCH REG
        MOV     R0,$R0SAV               ;SAVE SWITCHES
        BIT     R0,#DING                ;BELL ON ERROR?
        BEQ     1$                              ;NO
        PBELL                           ;RING BELL
1$:             BIT     $R0SAV,#PALERS  ;PRINT ALL ERRORS?
        BNE     FORSYM                  ;YES, REPORT IT
        TSTB    LOOPEN                  ;SCOPE LOOP ENABLED?
        BEQ     RDONE                   ;NO,BYPASS REPORT
2$:     CMP     R4,CONVRG               ;SAME TEST?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R3,SAVEPC               ;SAME PC?
        BNE     FORSYM                  ;NO, REPORT ERROR
        CMP     R5,SUBTST                       ;SAME SUBTEST?
        BEQ     RDONE                   ;YES, BYPASS REPORT

        ;FORCED SYMPTOMS ENTER HERE

FORSYM: PUSH    R5                      ;SAVE SUBTEST #
        PUSH    R4                      ;SAVE TEST #
        PUSH    R3                              ;SAVE ERROR PC
        CMP     R5,#77777               ;ILLOGICAL FAULT?
        BNE     1$                              ;NO
        CLR     R5                      ;YES, DON'T REPORT SUBTEST
1$:     JSR     PC,REPORT               ;REPORT BASIC SYMPTOM
        POP     R3                      ;RESTORE ERROR PC
        POP     R4                      ;RESTORE TEST #
        POP     R5                      ;RESTORE SUBTEST #
        SWITCH                          ;GET SWITCH REG
        BIT     R0,#TXTINH              ;INHIBIT TEXT?
        BNE     RDONE                   ;YES
        MOV     R3,R0                   ;PC POINTS TO TEXT
        TST     (R0)                    ;TEST WORD AFTER JSR
        BEQ     RDONE                   ;NO TEXCT
                
        BPL     2$                      ;TEXT IN LINE?
        MOV     (R0),R0                 ;GET POINTER
        BIC     #BIT15,R0               ;NO, DISCARD MSB
2$:     PNTAL                           ;PRINT TEXT
        PCRLF                           ;CARRIAGE RET/LINEFEED
RDONE:  PNORML                          ;CLEAR FORCED TYPEOUTS
        ERRHLT                          ;HALT IDF SWITCH 8 SET
        RTS     PC                      ;RETURN


        ;SUBROUTINE TO LOAD A PROGRAM

LODPRG: CLR     PRGLOD                  ;CLEAR OUT LAST PROGRAM I.D.
        PRGNPT                          ;DO LOAD
        BCS     3$                      ;ERROR
        MOV     $TTYO,R0                ;GET TTY OUTPUT BUFFER POINTER
        PUSH    <R1,R2>                 ;SAVE BUFFER CONTENTS
        MOV     #PRGLOD,R1              ;BUFFER AREA
        MOV     #82.,R2                  ;CHARACTER COUNT
1$:     MOVB    (R0)+,(R1)+             ;SAVE A CHARACTER
        BEQ     2$                      ;DONE
        DEC     R2                      ;BUFFER FULL?
        BGT     1$                      ;NO, NEXT CHARACTER
2$:     POP     <R2,R1>                 ;
        PNTRST                          ;RESET OUTPUT BUFFER
        BR      4$                      ;RETURN
3$:     PNTCI                           ;PRINT ERROR MESSAGE
                NULL                    ;
        SEC                            ;SET ERROR FLAG
4$:     RTS     PC                      ;RETURN

        ;PRINT LOAD I.D.  CALL IS JSR R5,PNTID

        
PNTID:  $PMSG,PRGLOD                    ;PRINT MESSAGE
        PCRLF                           ;CARRIAGE RETURN       
        RTS     R5                      ;RETURN

STARTI: .ASCIZ   %GO%                    ;GO COMMAND
        .EVEN


        ;TEST FOR SCOPE LOOPS
TLOOP:  POP     TLPRET                  ;GET ENTRY POINT
LPTST:  SWITCH                          ;GET SWITCH REG
        TST     TEND.                   ;TEST LOOP?
        BEQ     2$                      ;NO, TEST ERROR LOOP
        CMP     R4,TEND.                ;END LOOP?
        BLT     1$                      ;NO
        BIT     R0,#ABORT               ;ABORT?
        BNE     7$                      ;YES
        MOV     TSTART,R4               ;SET BEGINNING OF LOOP
        MOV     R4,TSTNUM               ;
        CMP     R4,TEND.                ;ONE TEST?
        BEQ     3$                      ;YES, NORMAL SCOPE LOOP
        JMP     RETEST                  ;NO, MULTIPLE TEST LOOP
1$:     JMP     TSTINI                  ;NEXT TEST
2$:     TSTB    LOOPEN                  ;LOOP ENABLED?
        BEQ     9$                      ;NO, RETURN
        BIT     R0,#LOOPER                      ;LOOP ON ERROR?
        BNE     3$                      ;YES, DO IT
        TSTB    XMODE                   ;XOR MODE?
        BNE     9$                      ;YES, RETURN
        JMP     DIADON                  ;DONE
3$:     TSTB    FASTLP          ;FAST LOOP ENABLED?
        BNE     5$                      ;YES, GO WAIT FOR IT
        ASL     R4                      ;NO, SHOULD I ENABLE IT?
        MOV     TESTAB(R4),R3           ;GET TESTAB ENTRY FOR THIS TEST
        ASR     R3                      ;BIT 0 SET?
        BCC     4$                      ;NO, GO DO LOOP
        INCB    FASTLP                  ;SET FAST LOOPENABLE
4$:     JMP     LOOPT1                  ;GO START LOOP
        5$:     PMSG    <FAST LOOP NOW RUNNING\>
6$:     JSR     PC,CHKCC.                       ;GO CHECK FOR INPUT
        SWITCH                          ;GET CONSOLE SWITCHES
        TST     TEND.                   ;TEST LOOP ACTIVE?
        BEQ     8$                      ;NO, MUST BE SCOPE LOOP
        BIT     #ABORT,R0               ;ABORT SWITCH SET?
        BEQ     6$                      ;NO, WAIT FOR ABORT OR CONTROL C
7$:     JMP     DIACOM                  ;RETURN TO DIACON COMMAND MODE
8$:     BIT     #LOOPER,R0              ;LOOP ON ERROR SET?
        BNE     6$                      ;YES, WAIT FOR IT TO GO AWAY
9$:     JMP     @TLPRET                 ;SUBROUTINE RETURN

TLPRET: .WORD   0                       ;NORMAL RETURN POINT


        ;PROGRAM CONSTANTS

SCALE:  .WORD   100.            ;SCALE FACTOR
CON90:  .WORD   231.            ;CONSTANT FOR 90%CONFID.
DURCON: .BYTE   0,0,75.,87.,94. ;LOOKUP TABLES
        
FRECON: .BYTE   0,30.,40.,50.,60.,70.,80.
VALUE:  .BYTE   36.,51.,69.,92.,120.,161.

        ;PROGRAM VARIABLES & POINTERS


SUBTST: .WORD   077777          ;SUBTEST
SAVEPC: .WORD   077777          ;ERROR PC
DIAGBI: .WORD   DIAUML          ;PTR TO SLOT INFO AND EBUS STUCK
CONVRG: .WORD   0               ;EARLIEST TEST #
PASS:   .WORD   0               ;PASS COUNT
FAULTS: .WORD   0               ;# OF SYMPTOMS IN TEST
TSTNUM: .WORD   0               ;TEST #
LSTPC:  .WORD   0               ;LAST FAULT PC
LSTSUB: .WORD   0               ;LAST SUBTEST #
SYMPT:  .WORD   0               ;# OF DIFFERENT FAULTS
XMODE:  .WORD   0               ;XOR MODE FLAG
DURERR: .BYTE   0               ;# OF CONSECUTIVE FAULTS
MAXERR: .BYTE   0               ;MAX # CONSECUTVE
PCT:    .BYTE   0               ;CONFIDENCE (%)
SKPFLG: .BYTE   0               ;FLG FOR NEXT INITIALIZATION SKP
LOOPEN: .BYTE   0               ;ERROR REPORTED FLAG
FASTLP: .BYTE   0               ;FAST LOOP ENABLE
XSAVE:  .WORD   0               ;XOR START
SAVETP: .WORD   0               ;END OF TYPE STACK
TESTSP: .WORD   0               ;SP AT FAILING TEST
NOTIME: .BYTE   0               ;NO TIMEOUT ON TEST
HARD:   .BYTE   0               ;SOLID FAULT OR NO CONVERGENCE FLAG
TSTART: .WORD   0               ;TEST START
TEND.:  .WORD   0               ;LOOP END
$R0SAV: .WORD   0               ;SAVE AREA FOR R0
$TTYO:  .WORD   0               ;GETS POINTER TO TTY OUTPUT
PRGLOD: .WORD   0               ;80 CHARACTER OVERLAY ID BUFFER
        .BLKW   40.             ;

.SBTTL          STANDARD ERROR DATA STACKING SUBROUTINES
.REM    %
        THE FOLLOWING SUBROUTINES PUT STANDARD 16-BIT & 36-BIT
ERROR INFORMATION ON THE ERROR STACK & RETURN TO THE DIAGNOSTIC
EXECUTIVE.
%
MERR16: PUSH    R5              ;16-BIT WITH MASK
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM16,(R0)+    ;FORMAT TO ERROR STACK
        INC     R5              ;BYPASS FIRST PARAMETER
        INC     R5              ;
        MOV     @(R5)+,(R0)+    ;MASK TO ERROR STACK
        BR      ERR16A          ;
ERR16:  PUSH    R5              ;16-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA16,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
ERR16A: MOV     @(R5)+,(R0)+    ;ACTUAL TO ERROR STACK
        MOV     @(R5)+,(R0)+    ;EXPECTED TO ERROR STACK
        BR      ERR36B          ;
MERR36: PUSH    R5              ;36-BIT WITH MASK
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+           ;BYPASS FIRST PARAMETER
        MOV     (R5)+,(R0)+     ;MASK POINTER TO ERROR STACK
        BR      ERR36A          ;
ERR36:  PUSH    R5              ;36-BIT
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTA36,(R0)+    ;FORMAT TO ERROR STACK
        TST     (R5)+   ;BYPASS FIRST PARAMETER
ERR36A: JSR     PC,STK36                ;ACTUAL TO ERROR STACK
        JSR     PC,STK36        ;EXPECTED TO ERROR STACK
ERR36B: MOV     R0,ERSP..       ;RESET ERROR STACK POINTER
        POP     R0              ;GET ENTRY ADDRESS

        POP     R5              ;RESTORE SUBTEST #
        PUSH    R0              ;SET ERROR PC
        JMP     FAULT           ;RETURN TO EXEC

        ;PUSHES 36-BIT DATA ON ERROR STACK.  CALL IS VIA JSR,PC.
        ;R5 IS ADDRESS OF POINTER TO 5-BYTE FORMATTED 36-BIT
        ;DATA.  R0 IS ERROR STACK POINTER.  R1 IS DESTROYED.

STK36:  MOV     (R5)+,R1         ;DATA POINTER TO R1
STK36A: MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        MOVB    (R1)+,(R0)+     ;MOVE BYTE TO ERR STACK
        CLRB    (R0)+           ;CLR EXTRA BYTE TO EVEN THINGS UP
        RTS     PC                      ;RETURN


;SEQ097

.REM    %
        STK36T- SUROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.  THE FIRST PARAMETER IS A POINTER TO TEXT WHICH IS TO
PRECEDE THE DATA.
%
STK36T: PUSH    R1              ;SAVE R1

        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT36T,(R0)+    ;GORMAT TYPE TO ERROR STACK
        MOV     (R5)+,(R0)+     ;TEXT POINTER TO ERROR STACK
        JSR     PC,STK36        ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN



.REM    %
        STKDAT- SUBROUTINE TO PUT 36-BIT ERROR REPORTING DATA ON THE
ERROR STACK.
%
STKDAT: PUSH    R1              ;SAVE R1


        MOV     R0,R1           ;GET DATA POI9NTER
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTDAT,(R0)+    ;FORMAT TYPE TO ERROR STACK
        JSR     PC,STK36A       ;DATA TO ERROR STACK
        BR      STKEX           ;CLEANUP & RETURN


.REM    %
        STKADR- SUBROUTINE TO PUT A 22-BIT ADDRESS ON THE ERROR STACK.
PARAMETER IN R0.
%
STKADR: PUSH    R1              ;SAVE R1

        MOV     R0,R1           ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FTADR,(R0)+    ;FORMAT TYPE TO ERROR STACK
        BR      STK22           ;PUT ADDRESS ON ERROR STACK

.REM    %
        STK22H- SUBROUTINE TO REPORT ADDRESS: @ THE ADDRESS.
PARAMETER TRAILS.
%
        
STK22H: PUSH    R1              ;SAVE R1

        MOV     (R5)+,R1        ;GET POINTER TO ADDRESS
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22H,(R0)+    ;FORMAT TYPE TO ERROR STACK


STK22:  MOVB    (R1)+,(R0)+     ;ADDRESS TO ERROR STACK
        MOVB    (R1)+,(R0)+     ;
        MOVB    (R1),R1         ;MASKING OUT GARBAGE
        BIC     #177700,R1      ;
        MOV     R1,(R0)+        ;
STKEX:  MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER



;SEQ098


        POP     R1              ;RESTORE R1


        RTS     R5              ;RETURN

.SBTTL          SCOPE SYNC SUBROUTINES  6-APR-78
.REM    %
        THESE SUBROUTINES ARE USED TO GENERATE A SCOPE SYNC ON THE 
DTE20.  ENTRY POINTS ARE AS FOLLOWS:
SYNC            PROVIDE THE SCOPE SYNCHRONIZATION.
SYNCIF          SYNC IF FAILING SUBTEST = R5.
INSYNC          INCREMENT R5 & SYNC IF = FAILING SUBTEST.

        SYNCIF & INSYNC CAUSE AN ERROR RETURN IF IN XOR MODE
& THE XOR HAS DETECTED AN ERROR.  CALLED VIA JSR,PC.
%
INSYNC: INC     R5              ;NEXT SUBTEST
SYNCIF: JSR     PC,CHKCC.       ;TTY INPUT CHECK
        TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        BIT     #BIT15,XORSR    ;XERCPU?
        BEQ     2$              ;NO
        MOV     TSTNUM,R4       ;SET UP TEST NUMBER AGAIN
        TST     TEND.           ;TEST LOOP?
        BEQ     1$              ;NO,XOR LOOPER
        JMP     TLOOP           ;YES, TEST LOOP
1$:     JMP     XTEST           ;XOR LOOPER
2$:     CMP     SUBTST,R5       ;POIN OF FAILURE?
        BEQ     SYNC            ;YES,SYNC
        RTS     PC              ;NO, RETURN
SYNC:   DFXCTT                  ;SYNC AT A36,E1
        74                      ;UNUSED FUNCTION
        RTS     PC              ;RETURN


        ;TTY INPUT CHECK
NEWSUB:
CHKCC.:  TTALTM          ;CHECK FOR TTY INPUT
        BCC     1$              ;GOT AN ALTMOD
        CMP     R0,#CNTRLC      ;CONTROL C?
        BNE     4$              ;NO
        PFORCE                  ;YES,FORCE TYPEOUTS
        PMSG    <^C\>           ;ECHO ^C
        JMP     $CNTLC          ;GO TO KLDCP
1$:     PFORCE                  ;ALTMODE, FORCE TYPEOUTS
        PMSG    <$	PRGM INTERRUPTED AT TEST >
        MOV     TSTNUM,R0       ;PRINT TEST #
        PNTDEC                  ;
        TST     R5              ;SUBTEST?
        BEQ     2$              ;NO
        PNTBAK                  ;DISCARD PERIOD
        PMSG    <, SUBTEST >
        MOV     R5,R0           ;PRINT SUBTEST #
        PNTDEC                  ;
2$:     PCRLF
3$:     PNTCI,">.               ;GIVE KLDCP PROMPT
        TTILNW                  ;GET A LINE OF INPUT
        CLR     R0    
        PRGCMD                  ;DO KLDCP COMMAND
        BCS     3$              ;ERROR INCOMMAND, PERMIT RETRY
        PMSG    <	PRGM CONTINUED\>
        PNORML                  ;NORMAL TYPEOUTS
4$:     RTS     PC              ;RETURN


.SBTTL          ERROR REPORTER                  15-JUL-77
        MSIZE=15.       ;MBOX SCAN TABLE SIZE
        CSIZE=12.       ;CHANNEL SCAN TABLE SIZE
        ASDSH=55        ;DASH
        ASQT=42         ;QUOTE
        ASX=130         ;X
        ASSP=40         ;SPACE
        AS0=60          ;ZERO
        AS1=61          ;ONE
        OVRLAY=70000   ;BASE ADDR OF OVERLAY AREA

.REM    %
        TYPEOUT ROUTINES FOR UNPACKING AND FORMATTING THE INFORMATION
        LEFT IN THE ERROR STACK.  EACH ENTRY IN THE STACK IS HEADED BY A
        POINTER WHICH IS USED BY THIS ROUTINE TO ADDRESS A FORMAT
        TABLE WHOSE CONTENTS DIRECT THEHANDLING OF EACH ITEM IN THE
        STACK ENTRY.
        EACH BYTE OF THE FORMAT TABLE IS USED AS AN INDEX TO A JUMP TABLE
        TO CALL THE FORMATTING SUBROUTINE FOR THE CURRENT ITEM IN THE ERROR
        
        STACK.  THE FORMATTING ROUTINES MASSAGE THE DATA FOR ONE 
LINE OF TYPEOUT ADDING LABELS WHERE NEEDED AND THEN CALL THE SUBROUTINE
        PACKAGE WHICH PERFORMS THE ACTUAL TYPEOUTS.

        SAMPLE TYPEOUT AND HOW TO MAKE IT HAPPEN

        TEST NUMBER 27          SUBTEST 5               PC = 10244

        DIAGNOSTIC FUNCTION - 47
        EXPECTED DATA - 100 XXX XXX XXX 0X0 1XX XXX XXX XXX XXX XXX 111
        ACTUAL DATA  - 101 010 010 010 000 011 111 001 101 000 100 111
        DIFFERENCE   -   1                  1

        THE FIRST LINE'S DATA ARE CAPTURED BY THE TEST MONITOR.
        THE DATA FOR THE REST OF THE TYPOUT IS FROM AN ENTRY IN THE
        ERROR STACK MADE BY THE ROUTINE DETECTING THE ERROR:
        STACK: <ADDRESS OF FORMAT TABLE>
        +1      <DIAGNOSTIC FUNCTION>
        +2      <ADDRESS OF 5-BYTE MASK>
        +3      <ADDRESS OF 5-BYTE EXPECTED DATA>
        +4      <ADDRESS OF 5-BYTE ACTUAL DATA>

        THE FORMAT TABLE CONTROLS THE PRINTING OF THE 'NOISE WORDS' AND
        THE OVERALL APPEARANCE OF THE OUTPUT. THE FTM. MACRO (SEE NEXT
        PAGE) FOR THIS SAMPLE TYPOUT WOULD BE.:

                FTM.  <DIAFR,IMSK36,IACT36,DIFF36>
        WHICH DIRECTS:  "THE RIGHT BYTE OF THE FIRST WORD IS A DIAGNOSTIC
        FUNCTION.  THE SECOND WORD POINTS TO A MASKWHICH TELLS WHERE TO
        PUT X'S IN THE TYPOUT.  THE THIRD WORD POINTS TO THE EXPECTED
        DATA.
        THE FOURTH WORD POINTS TO THE ACTUAL DATA.  FINALLY, DISPLAY
        THE XOR DIFFERENCE BETWEEN THE EXPECTED AND ACTUAL DATA."
        %


.SBTTL          FORMAT TABLES
.REM    %
        FORMAT TABLES CONSIST OF BYTES WHICH ARE INDEXES ON THE JUMP 
        TABLE "TJMPT".  THE LAST BYTE OF A BYTE TABLE CONTAINS A 1 IN
        BIT ZERO.  THIS WORKS BECAUSE ALL INDEX VALUES ARE EVEN
        %



;       FORMAT TABLE POINTER TABLE USED TO TRANSLATE ABSOLUTE
;       FORMAT NUMBERS INTO THE ADDRESS OF THE FORMAT TABLE.

.MACRO  FTT     FF
          FF=.-TFMTT
          .WORD FF'T
        .ENDM   FTT

TFMTT:  FTT     FTA16           ;0
        FTT     FTM16           ;2
        FTT     FTA36           ;4
        FTT     FTM36           ;6
        FTT     FT0             ;10
        FTT     FTNON           ;12 - FT3 NOT USED
        FTT     FTNON           ;14 - FT6 NOT USED
        FTT     FT8             ;16
        FTT     FT9             ;20
        FTT     FT10            ;22
        FTT     FT11            ;24
        FTT     FT22            ;26
        FTT     FTMEM           ;30
        FTT     FTPRM          ;32
        FTT     FTDAT           ;34
        FTT     FT36T           ;36
        FTT     FTADR           ;40
        FTT     FT22H           ;42




;SEQ103


        FTT     FTNON           ;44
        FTT     FTNON           ;46

TFMTH=.-TFMTT


.REM    %
        STACK CONTENTS:

        S       FTA16
        S+2     16-BIT ACTUAL
        S+4     16-BIT EXPECTED
        %
FTA16T: FTM.    <ACT16,EXP16,DIFF16>


.REM    %
        STACK CONTENTS:

        S       FTM16
        S+2     16-BIT MASK WORD
        S+4     16-BIT ACTUAL
        S+6     16-BIT EXPECTED
        %

FTM16T: FTM.    <MSK16,ACT16,EXP16,DIFF16>

.REM    %
        STACK CONTENTS:

        S       FTA36
        S+2     ACTUAL, BITS 20-35
        S+4     ACTUAL,BITS 4-19
        S+6     ACTUAL, BITS 0-3 (1 BYTE)
        S+7     EXPECTED, BITS 27-35 (1 BYTE)
        S+10    EXPECTED, BITS 12-26
        S+12    EXPECTED, BITS 0-11
        %
FTA36T: FTM.    <ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FTM36
        S+2     POINTER TO 36-BIT MASK
        S+4     ACTUAL, BITS 20-35
        S+6     ACTUAL, BITS 4-19
        S+10    ACTUAL, BITS 0-3 (1 BYTE)
        S+11    EXPECTED, BITS 27-35 (1 BYTE)
        S+12    EXPECTED, BITS 12-26
        S+14    EXPECTED, BITS 0-11
        %

FTM36T: FTM.    <IMSK36,ACT36,EXP36,DIFF36>


.REM    %
        STACK CONTENTS:

        S       FT3
        S+2     POINTER TO A TABLE OF DIAG. FCN. BYTES
        S+4     POINTER TO A TABLE OF EBUS BYTE POINTERS
        S+6     POINTER TO A TABLE OF MASK BYTES
        S+10    POINTER TO A TABLE OF EXPECTED DATA BYTES
        S+12    ACTUAL DATA BYTE
        S+13    INDEX ON ABOVE TABLES
        -
        -
        -
        
        S+N     FINAL ACTUAL DATA BYTE
        S+N+1   FINAL INDEX ON TABLES, SIGN BIT = 1
        %

.REM    %
        STACK CONTENTS

        S       FT6
        S+2     POINTER TO C-RAM ADDRESS
        S+4 TO S+14     11 BYTE ACTUAL C-RAM CONTENTS
        S+15 TO S+25    11 BYTE EXPECTED C-RAM CONTENTS
        %

.REM    %
        STACK CONTENTS:

        S       FT8
        S+2 TO S+N+1    VARIABLE NUMBER OF MULTI-FORMAT ENTRIES:

        E       TABLE SIZE - "MSIZE" OR "CSIZE"
        E+1     DIAG FCN IN RANGE 160-177, SIGN BIT IS
                SET IF THIS IS LAST ENTRY.

        IF E =  CSIZE, THEN:
                E+2 TO E+4  EXPECTGED BITS 0-19
        E       E+5 TO E+7  ACTUAL BITS 0-19

        IF E NOT = CSIZE, THEN
                IF DIAG FCN 160-162
          E+2 TO E+4 EXP. BITS 12-35
          
        E+5 TO E+7 ACT. BITS 12-35

                
        IF DIAG FCN 163-166, 170-177
        E+2 AND E+3 EXP. BITS 20-35
        E+4 AND E+5 ACT. BITS 20-35
        %

FT8T:FTM.        <HEDSCT,ENTSCT>

.REM    %
        STACK CONTENTS:

        S       FTMEM
        S+2     ACTUAL REQUESTS, RQ0-RQ3 IS BITS 7,6,5,4
        S+3     ACTUAL 22-BIT ADDRESS, BITS 27-35
        S+4     ACTUAL ADDRESS, BITS 14-26
        S+6     EXPECTED REQUEST BITS
        S+7     EXPECTED ADDRESS, BITS 27-35
        S+10    EXPECTED ADDRESS, BITS 14-26
        %

FTMEMT:FTM.     <HEDMRQ,ACTMRQ,EXPMRQ>

.REM    %
        STACK CONTENTS:

        S       FT0
        S+2     A DIAGNOSTIC DUNCTION CODE
        %
FT0T:   FTM.    <DIAFR>


.REM    %
        STACK CONTENTS:

        S       FT9
        S+2     DIAG. FCN. (BYTE) SIGN BIT IS ACTUAL STATE OF SIGNAL
        S+3     EBUS BIT NUMBER. SIGN BIT SET IF MORE ENTRIES FOLLOW
        S+N     FINAL DIAG. FNC. AND BIT VALUE
        S+N+1   FINAL EBUS BIT NUMBER WITH ZERO SIGN BIT
        %

FT9T:FTM.       <HEDSCT,ERDBIT>

.REM    %
        STACK CONTENTS:

        S       FT10
        S+2     A"PNTXXX" EMT TO BE EXECUTED
        S+4     EMT ARGUMENT TO BE LOADED INTO R0 BEFORE EMT EXECUTION
        %
FT10T:  FTM.    <PNTEMT>

.REM    %
        STACK CONTENTS:

        S       FT11
        S+2     36-BIT DATA PATTERN BITS 20-35
        S+4     DATA BITS 4-19
        S+6     DATA BITS 0-3
        %
FT11T:  FTM.    <PAT36>



.REM    %
        STACK CONTENTS:

        S       FT22
        S+2     22-BIT ACTUAL, BITS 20-35
        S+4     22-BIT ACTUAL, BITS 14-19
        S+6     22-BIT EXPECTED, BITS 20-35
        S+10    22-BIT EXPECTED, BITS 14-19
        %

FT22T:  FTM.    <ACT22B,EXP22B,DIFF22>


.REM    %
        STACK CONTENTS:
        S       FTPRM
        S+2     NON-PRINTING USER PARAMETER
        %
FTPRMT: FTM.    <SKPPRM>


.REM    %
        STACK CONTENTS:
        S       FTDAT
        S+2     36-BIT DATA 20-35
        S+4     BITS 4-19
        S+6     BITS 0-3
        %

FTDATT: FTM.    <DAT36>
        

.REM    %
        STACK CONTENTS:

        S       FT36T
        S+2     TEXT POINTER
        S+4     36-BIT DATA 20-35
        S+6     BITS 4-19
        S+10    BITS 0-3
        %


FT36TT: FTM.    <HEDTXT,DAT36>

.REM    %

        STACK CONTENTS:

        S       FTADR
        S+2     22-BIT DATA 20-35
        S+4     BITS 14-19
        %
  
FTADRT: FTM.    <ADR22>

.REM    %
        STACK CONTENTS:

        S       FT22H
        S+2     22-BIT DATA 20-35


        S+4     BITS 14-19
        %


FT22HT: FTM.    <ADH22>

.REM    %
        STACK CONTENTS:

        S       FTUSR
        S+2     ADDRESS OF USER SUPPLIED TYPEOUT SUBROUTINE
        S+4     START OF USER SUPPLIED DATA
        S+?     END OF USER SUPPLIED DATA
        %


.REM    %
        STACK CONTENTS:


        S       FTVAR
        S+2     FORMAT CONTROL WOWRD
        S+4     START OF BINARY DATA
        S+?     END OF BINARY DATA
        %


.REM    %
        UNDEFINED FORMAT OR PARAMETER
        %
FTNONT: FTM.    <NOFORM>
        .EVEN


.SBTTL          REPORT HEADING PRINTER
.REM    %
        ERROR REPORTING ROUTINE CALLED BY DISPATCHER AT
        APPROPRIATE TIMES.  TYPES OUT THE ERROR PC, TEST NUMBER,
        AND SUBTEST NUMBER, FOLLOWED BY ALL THE ENTRIES ON THE ERROR
        STACK.  THE DISPATCHER TAKES CARE OF SETTING THE FORCE PRINTOUT
        FLAG
        %

REPORT: MOV #DIAUML,R0          ;CLEAR BOARD TABLE
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     (R0)+
        CLR     BUSBIT          ;CLEAR E-BUS BIT TRACKER
        PMSG    <\TEST NUMBER - >
         MOV    R4,R0
        PNTDEC          ;PRINT TEST NUMBER

        TST     R5      ;IS THERE A SUBTEST #?
        BEQ     1$     ;NO BRANCHES
        PMSG    <    SUBTEST - >
        MOV     R5, R0
        PNTDEC          ;PRINT SUBTEST NUMBER

1$:     PMSG    <    PC = >
        MOV     R3,R0
        SUB     #4,R0
        PNTOCS          ;PRINT ERROR PC
        PCRLF



.SBTTL          ERROR STACK SCANNER
.REM    %
        USES R5 TO POINT TO THE ERROR STACK AND R4 TO POINT TO THE
        CURRENT FORMAT SPECIFICATION TABLE.  THE SCANNER PICKS UP
        THE FORMAT TABLE POINTER FROM THE ERROR STACK.  IT THEN DISPATCHES
        TO EACH FORMAT ROUTINE IN SEQUENCE.  WHEN THE END OF A FORMAT
        TABLE IS REACHED, A CARRIAGE RETURN LINE FEED IS OUTPUT
        AND THE ERROR STACK IS LOOKED AT FOR ANOTHER ENTRY.  WHEN
        THE END OF THE ERROR STACK IS REACHED, ANOTHER CRLF IS
        PRINTED AND THE SCANNER EXITS. THE SCANNER DOES NOT CHANGE THE
        ERROR STACK POINTERS JUST IN CASE WE MAY WANT TO PASS THIS INFO
        TO THE ISOLATION ROUTINES.  IN ANY CASE THE BASELINE TEST MONITOR
        RESETS THE POINTERS AT THE RIGHT TIME.
        %

ERSS:   MOV     ERTI...,R5              ;GET BASE OF STACK
        CLR     PNAMSV
ERS1:   CMP     R5,ERTP..               ;CHECK END ERROR STACK
        BLT     1$              ;BRANCH IF NOT EMPTY
        PCRLF                           ;OUTPUT A CRLF PAIR
        RTS     PC                      ;GO BACK TO DISPATCHER

1$:     MOV     (R5)+,R4                ;GET THE FMT TABLE PTR
        BMI     BADFMT                  ;ERROR IF NOT POSITIVE
        CMP     R4,#TFMTH                       ;CHECK UPPER BOUNDS
        BGT     BADFMT                  ;TOO BIG
        MOV     TFMTT(R4),R4            ;GET FMT TABLE ADDRESS
        MOV     #ZMK.,MKP.              ;DEFAULT ZERO MASK
        MOVB    #ASX,AXORSP             ;MASK ONES ARE X'S
        MOVB    #AS0,ZORSP              ;ZERO FILL CHAR
ERS2:   MOVB    (R4),R3                 ;GET AN ENTRY FROM FMT TL
        BICB    #1,R3                   ;CLEAR END FLAG
        JSR     PC,@TJMPT(R3)           ;DISPATCH TO FORMAT ROUTINE

        
;FORMAT ROUTINES RETURN HERE

ERSRTN: BITB    #1,(R4)+                ;TST END FLAG, BUMP POINTER
        BEQ     ERS2                    ;NOT DONE YET, CONTINUE
        JMP     ERS1                    ;CONTINUE ERROR TABLE SCAN

;IMPROPER FORMATS GET HERE

BADFMT: PMSG    <\?ERROR STACK FORMAT\>
        FATAL

;ERROR STACK POINTERS

        ERSI..: .WORD   ESTK1           ;BASE OF WORKING STACK
        ERSP..: .WORD   ESTK1           ;POINTER TO WORKING STACK
        ERTI..: .WORD   ESTK2           ;BASE OF TYUPEOUT STACK
        ERTP..: .WORD   ESTK2           ;POINTER TO END OF TYPEOUT STACK



.SBTTL          JUMP TABLE
.REM    %
        THE ERROR STACK SCANNER DISPATCHES THRU THIS TABLE TO
        EXECUTE THE FORMAT ROUTINES.
        %

TJMPT:
ACT16:  AC16.
ACT22B: AC22B
  ACT36:        AC36
ACTMRQ:ACMRQ
ADDR16: ADR16
DIAFR:  DIFR
DIFF16: DIF16
DIFF22: DIF22
DIFF36: DIF36
ENTSCT:ENSCT
ERDBIT:ERDBT
HEDSCT:HDSCT
HEDTXT:PTTXT
DAT36:PTDAT
ADR22:PT22
ADH22:PT22H
EXP16:  XP16
EXP22B: XP22B
EXP36:  XP36
EXPMRQ:XPMRQ
HEDMRQ:HDMRQ
IBPTAB: IBPTB
IMSK36: IMK36
MSK16:  MK16
PAT36:  PT36
        PNTEMT: PTEMT
SKPPRM: IBPTB
NOFORM: BADFMT



        ;ERROR REPORT HEADINGS AND "NOISE WORDS"

        .LIT ERPAT,<.ASCIZ %\PATTERN: %>
        .LIT ERADR,<.ASCIZ %\ADDRESS: %>
        .LIT ERSCT,<.ASCIZ % CORRECT ACTUAL  SIGNAL NAME\%>
        .LIT ERACT,<.ASCIZ %ACTUAL:  %>
        .LIT ERCOR,<.ASCIZ %CORRECT: %>
        .LIT ERDSC,<.ASCIZ %DISCREP: %>
        .LIT ERBT1,<.ASCIZ %       ACTUAL       DISCREP.%>
        .LIT ERMRQ,<.ASCIZ %         RQ0 RQ1 RQ2 RQ3 RD  WR  SBUS ADR\%>

.SBTTL          MAIN REPORT ROUTINES
        
.REM    %
STACK ENTRY IS 16-BIT ACTUAL
        %

AC16.:  PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC16.X: MOV     R5,ACP.         ;SAVE POINTER TO A TUAL
        MOV     #ZMK.,R1                ;USE ZERO MASK
        JMP     AX16C           ;GO TO COMMON CODE


.REM    %
        ACTUAL DATA IS 22-BITS IN TWO WORDS ON STACT
        %
AC22B:  $PMSG,ERACT             ;PRINT MESSAGE
AC22BX: MOV     R5,ACP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE ACTUAL DATA

.REM    %
        ACTUAL IS 5 BYTES ON STACK IN USUAL UPSIDE-DOWN
        36-BIT FORMAT.
        %
AC36:   PCRLF
        $PMSG,ERACT             ;PRINT MESSAGE
AC36X:  MOV     R5,ACP.         ;SAVE POINTER TO FIRST WORD
        MOV     R5,R2           ;POINT TO IT FOR TYPER
        ADD     #5,R5           ;SKIP OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;PRINT NO X'S
        JMP     TYP36           ;TYPE,RETURN TO SCANNER
.REM    %
        PRINT ACTUAL MEMORY RQ'S AND 22-BIT ADDRESS
        %
ACMRQ:  $PMSG,ERACT             ;PRINT MESSAGE
MRQCOM: JSR     PC,TYPRQS       ;TYPE REQUEST BITS
        MOV     R5,R0   
        ADD     #3,R5           ;SKIP OVER INFO
        PNT22                   ;SBUS ADR IN OCTAL
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS AN ADDRESS IN 16-BIT FORM
        %

ADR16:  $PMSG,ERADR             ;PRINT MESSAGE
ADR16X: MOV     (R5)+,R0         ;GET ADDRESS
        PNTOCT                  ;PRINT IN OCTAL
        RTS     PC



.REM    %
        STACK ENTRY IS DIAGNOSTIC FUNCTION IN BITS 6-0
        %
DIFR:   PMSG    <\DIAGNOSTIC FUNCTION - >
        MOV     (R5)+,R0        ;GET FUNCTION
        PNTOCS                  ;TYPE NO LEADING ZEROES
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN



.REM    %
        COMPUTE AND TYPE XOR DIFFERENCE BETWEEN 16-BIT ACTUAL AND EXPECTED
        %

DIF16:  PCRLF
        $PMSG,ERDSC             ;PRINT MESSAGE
DIF16X: MOV     ACP.,R2          ;GETPTR TO ACTUAL
        MOV     EXP.,R3         ;GET PTR TO EXPECTED
        MOV     (R2),R0         ;ACTUAL TO R0
        MOV     (R3),DIF.               ;EXPECTED TO RESULT
        BIC     DIF.,R0         ;ACT .AND. -EXP
        BIC     (R2),DIF.               ;EXP .AND. -ACT
        BIS     R0,DIF.         ;ACT .XOR. EXP

        MOVB    #ASSP,AXORSP    ;SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;SPACE FILL IF NO DIFFERENCE
        MOV     #DIF.,R2
        MOV     MKP.,R1         ;POINT TO MASK
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        COMPUTE AND TYPE DIFFERENCE BETWEEN 22-BIT ACT AND EXP
        %
DIF22:  $PMSG,ERDSC             ;PRINT MESSAGE
DIF22X: MOV     EXP.,R3
        MOV     ACP.,R2
        MOV     DFP.,R1
        MOV     #-3,TEM.

1$:     MOVB    (R3),R0         ;GET EXPECTED
        BICB    (R2),R0
        MOVB    (R2)+,(R1)      ;HALT OF RESULT
        BICB    (R3)+,(R1)
        BISB    R0,(R1)+                ;XOR RESULT
        INC     TEM.            ;COUNT BYTES
        BMI     1$              ;MORE
        MOVB    #ASSP,ZORSP     ;SPACE WHERE NO DIFF
        MOV     DFP.,R2         ;POINT TO DIFF
        JMP     TYP22B          ;PRINT IT


.REM    %
        CALCULATE AND TYPE THE XOR DIFFERENCE BETWEEN THE ACTUAL
        AND THE EXPECTED 36-BIT DATA.
        %

DIF36:  $PMSG,ERDSC             ;PRINT MESSAGE
     DIF36X:    MOV     EXP.,R3 ;POINT TO EXPECTED
        MOV     ACP.,R2         ;POINT TO ACTUAL
        MOV     DFP.,R1         ;POINT TO DIFF BUFFER
        PUSH    R4
        MOV     #-5,R4          ;INIT BYTE COUNT

1$:     MOVB    (R3),R0
        BICB    (R2),R0         ;-ACT .AND. EXP
        MOVB    (R2)+,(R1)
        BICB    (R3)+,(R1)              ;ACT       .AND. EXP
        BISB    R0,(R1)+                ;ACT .XOR. EXP
        INC     R4              ;COUNT BYTES
        BMI     1$                      ;BRANCH IF MORE
        MOVB    #ASSP,AXORSP    ;MAKE SPACES FOR ONES IN MASK
        MOVB    #ASSP,ZORSP     ;BLANK IF NO DIFFERENCE
        MOV     DFP.,R2         ;POINT AT DIFF DATA
        MOV     MKP.,R4         ;ZERO MASK - NO X'S
        JMP     TYP36           ;TYPE, RETURN TO SCANNER




.REM    %
        
STACK HAS ONE OR MORE ENTRIES TO REPORT SCANOUT ERRORS.
WORD1:DIAG FN,,SIZE ((CHAN OR MBOX TABLE ID)
        NEXT 2 OR 3 BYTES:EXPECTED DATA
        NEXT 2 OR 3 BYTES :ACTUAL DATA
        WHETHER 2 OR 3 BYTES IS DETERMINED BY SIZE AND DIAG FN, WHICH
        ALSO DETERMINES THE E-BUS BIT NUMBER CORRESPONDENCE.
        %

ENSCT:  CLRB    FT8DUN          ;CLR DONE FLAG
1$:     JSR     PC,GNSCT                ;GET ONE ENTRY FROM ERROR STACK

;NOW TEST ALL THE BITS IN THIS ENTRY AND PRINT DIFFERENCES
        JSR     PC,PRDBYT
        TSTB    FT8DUN          ;LAST ENTRY?
        BEQ     1$              ;NO, DO IT AGAIN
        RTS     PC              ;RETURN TO SCANNER



;SET UP AN ENTRY FOR REPORTING
GNSCT:  MOVB    (R5)+,FT8SIZ            ;GET SIZE PARAM
        MOVB    (R5)+,FT8DF             ;GET DIAG FCN
        BPL     2$              ;BR IF NO LAST ENTRY FLAG
        INCB    FT8DUN          ;SET DONE FLAG
        BICB    #200,FT8DF      ;AND CLEAN DF BUFFER
2$:     CLR     R3              ;INIT INDEX
        CMPB    FT8SIZ,#CSIZE   ;CHANNEL?
        BEQ     3$              ;BR IF SO
        INC     R3              ;NEXT INDEX
        CMPB    FT8DF,#163      ;FIND WHICH MBOX GROUP
        BLT     3$              
        INC     R3              ;2-BYTE GROUP
3$:     ASL     R3              ;MAKE WORD INDEX
        ADD     F8SIZT(R3),R5   ;POINT BEYOND EXPECTED
        MOV     R5,R1           ;MAKE EXPECTED PTR
        DEC     R1
        ADD     F8SIZT(R3),R5   ;POINT BEYOND ACTUAL
        MOV     R5,R2           ;MAKE ACTUAL PTR
        DEC     R2
        MOV     F8BITT(R3),F8BTF        ;GET # OF FIRST, LAST BITS
        MOV     F8MSKT(R3),R3   ;GET IRST BIT MASK
        RTS     PC              ;RETURN


;SEQ119

.REM    %
        STACK HAS DIAGNOSTIC FUNCTION BIT ERROR.  BIT NBR IN LEFT,
        DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.
        IF BIT 15 = 1 THERE ARE MORE ENTRIES LEFT ON STACK
        %
;DIAGNOSTIC FUNCTION IN RIGHT WITH ACTUAL VALUE IN BIT 7.

ERDBT:  PCRLF
        
11$:    MOVB    (R5),FT8DF      ;GET DIAG FCN
        BICB    #200,FT8DF
        MOVB    1(R5),F8BTF     ;GET BIT NBR
        BICB    #200,F8BTF      ;CLEAR FLAG
        CLR     R0
        BIT     #BIT7,(R5)      ;TEST ACTUAL
        BEQ     1$
        INC     R0
1$:     MOVB    LHTAB(R0),DIF.+1
        INC     R0              ;MAKE EXP OPPOSITE ACTUAL
2$:     MOVB    LHTAB(R0),DIF.
        JSR     PC,SCERPT       ;FIND AND PRINT NAME, STATES
        TST     (R5)+           ;BUMP STACK PTR
        BMI     11$             ;CONTINUE
        RTS     PC


.REM    %
        STACK ENTRY IS 16-BIT EXPECTED
        %

XP16:   PCRLF
        $PMSG,ERCOR             ;PRINT MESSAGE
XP16X:  MOV     MKP.,R1         ;USE REAL MASK
                
        MOV     R5,EXP.         ;SAVE POINTER TO EXPECTED DATA

AX16C:  MOV     R5,R2           ;POINT TO TYPEOUT DATA
        ADD     #2,R5           ;BUMP OVER 1 WORD
        JMP     TYP16           ;TYPE,RETURN TO SCANNER


.REM    %
        EXPECTED DATA IS 22 BITS IN TWO WORDS ON STACK
        %
XP22B:  $PMSG,ERCOR             ;PRINT MESSAGE
XP22BX: MOV     R5,EXP.
        MOV     R5,R2
        ADD     #4,R5           ;SKIP OVER DATA
        JMP     TYP22B          ;TYPE EXPECTED DATA


.REM    %
STACK CONTAINS 5 BYTES OF EXPECTED 36-BIT DATA
        %
XP36:   $PMSG,ERCOR             ;PRINT MESSAGE
XP36X:  MOV     R5,EXP.         ;SAVE THE POINTER
        MOV     R5,R2
        ADD     #5,R5   ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     MKP.,R4         ;USE REAL MASK
        JMP     TYP36           ;TYPE, RETURN TO SCANNER

.REM    %
        PRINT EXPECTED DATA, MEM RQ AND 22-BIT ADDRESS
        %
XPMRQ:  $PMSG,ERCOR     ;PRINT MESSAGE
        JMP     MRQCOM  ;TYPE BITS, ADDRESS



.REM    %
REPORT MEMORY REQUESTS AND 22-BIT SBUS ADDRESS.
PRINT HEADER LINE
        %
HDMRQ:  $PMSG,ERMRQ     ;PRINT MESSAGE
        RTS     PC



.REM    %
        TYPE SCANOUT ERROR HEADING
        %

HDSCT:PCRLF
        $PMSG,ERSCT             ;PRINT MESSAGE
        RTS     PC

.REM    %
STACK POINTS TO BYTE POINTER
        %

IBPTB:  MOV     (R5)+,BYP.              ;PICK UP BASE
        RTS     PC              ;RETURN TO SCAN



.REM    %
POINTER TO 5-BYTE MASK IS ON ERROR TABLE
        %

IMK36:  MOV     (R5)+,MKP.              ;PICK UP POINTER FRROM TABLE
        RTS     PC              ;RETURN TO SCANNER


.REM    %
SIXTEEN BIT MASK IS IN ERROR TABLE
        %

MK16:   MOV     R5,MKP.         ;POINT INTO STACK
        ADD     #2,R5           ;PASS PTR OVER 1 WORD
        RTS     PC              ;RETURN TO SCANNER



.REM    %
        STACK HAS 3 WORDS CONTAINING A 36-BIT DATA PATTERN TO BE PRINTED
IN BINARY FORMAT.
        %
PT36:   $PMSG,ERPAT             ;PRINT MESSAGE
        MOV     R5,R2           ;DATA ADDRESS
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PUSH    R4
        MOV     #ZMK.,R4        ;NO MASKING
        JMP     TYP36   ;GO TYPE AND RETURN


.REM    %
        THE STACK HAS AN EMT PNTXXX AND R0 CONTENTS
        %

PTEMT:  MOV     (R5)+,1$        ;GET EMT
        MOV     (R5)+,R0        ;LOAD R0 WITH DATA OR PTR
1$:     EMT                     ;EXECUTE THE EMT
        RTS     PC              ;BACK TO SCAN




.REM    %
        STACK HAS 3 WORDS CONTAINING 36-BIT DATA TO BE TYPED IN
PDP-10 FORMAT.
%
PTDAT:  MOV     R5,R0           ;POINT TO DATA
        ADD     #6,R5           ;PASS OVER 3 WORDS
        PNT36                   ;PRINT THE DATA
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS TEXT POINTER
%
PTTXT:  MOV     (R5)+,R0        ;GET THE TEXT POINTER
        PNTAL                   ;PRINT IT
        RTS     PC              ;BACK TO SCAN

.REM    %
        STACK HAS PDP-10 FORMAT 22-BIT ADDRESS
%
PT22H: $PMSG,ERADR             ;PRINT MESSAGE
        PT22:   MOV     R5,R0           ;POINT TO DATA
        ADD     #4,R5           ;PASS OVER 2 WORDS
        PNTADR                  ;PRINT THE ADDRESS
        RTS     PC              ;BACK TO SCAN


.SBTTL          REPORT SUBROUTINES
.REM    %
        THIS ROUTINE IS USED TO PRINT ONE BYTE'S CONTENTS OF
        DIAGNOSTIC BIT ERRORS.  
        %
PRDBYT: MOV     ASCLL,DIF.      ;RESET RESULT BUFFER
        BITB    R3,(R1)         ;TEST EXPECTED
        BEQ     4$              ;BR IF LOW
        MOVB    #'H,DIF.        ;SET TOO HIGH
4$:     BITB    R3,(R2)         ;TEST ACTUAL
        BEQ     5$              ;BR IF LOW
        MOVB    #'H,DIF.+1      ;SET TOO HIGH
5$:     CMPB    DIF.,DIF.+1     ;ARE THEY DIFF?
        BEQ     7$              ;COUNTIN IF NOT
        JSR     PC,SCERPT       ;PRINT AN ERROR LINE


7$:     ASR     R3              ;SHIFT MASK BIT
        BNE     8$              ;BR IF DIDN'T FALL OFF
        BISB    #200,R3         ;RESET TO LEFT OF BYTE
        DEC     R1      
        DEC     R2              ;NEXT BYTE
8$:     INC     F8BTF           ;INC BIT #
        CMPB    F8BTF,F8BTL
        BLE     PRDBYT
        RTS     PC



;SCANOUT ERROR LINE TYPER
;ROUTINE TO PRINT DIAGNOSTIC FUNCTION BIT ERRORS USING REAL
;SIGNAL WNAMES, AN OVERLAY AREA IS USED TO CONTAIN A ROUTINE
;WHICH CONVERTS FROM DIAGNOSTIC FUNCTION AND BIT NUMBER
;TO NAME FOR PIECES OF THE DIAGNOSTIC ADDRESS SPACE.  THREE
;OVERLAYS ARE REQURIED TO COVER ALL THE NAMES.
SCERPT: CLR     NONAME
        JSR     PC,READDS       ;CHECK AND GET OVERLAY IF MISSING
        BCS     1$              ;NO T AVAILBLE, DO OTHERWISE
        CLR     R0
        BISB    FT8DF,R0        ;GET DIAG FCN
        SWAB    R0              ;TO LEFT
        BISB    F8BTF,R0        ;EBUS BIT TO RIGHT
        JSR     R5,OVRLAY       ;CALL CONVERTER
        PNAMES                  ;RETURN NAME PTR HERE
        PSTATE                  ;RETURN TRUTH STATE HERE
        TST     PSTATE          ;WAS IT FOUND?
        BPL     2$              ;YES, PRINT NAMES
1$:     COM     NONAME          ;NO, PRINT NUMBERS
2$:     PTAB                    ;TAB
        MOVB    DIF.,R0         ;GET EXPECTED
        PNTCHR
        PTAB                    ;TAB
        MOVB    DIF.+1,R0       ;GERT ACTUAL
        PNTCHR
        PTAB                    ;TAB
        TST     NONAME
        BNE     4$              ;NO CONVERSION WAS DONE
        MOV     PNAMES,R0
        PNTAL           ;PRINT NAME
        PSPACE                  ;SPACE
        MOV     PSTATE,R0       ;GET TRUTH
        BMI     3$              ;NOT KNOWN
        PNTCHR                  ;PRINT TRUTH
3$:     PCRLF                   ;END LINE
        JSR     R5,SBOARD       ;RECORD THE BOARD FROM
                DIAUML  ;WHICH THIS SIGNAL WAS READ
        JSR     PC,EBUSB        ;RECORD COMMON BIT FAILURE
        RTS     PC
4$:     MOVB    FT8DF ,R0       ;GET DIAG FCN
        PNTOCS                  ;PRINT OCTAL
        PTAB                    ;TAB
        MOVB    F8BTF,R0                ;GET BACK
        PNTDEC                  ;PRINT DECIMAL
        BR      3$

NONAME: 0               ;SET WHEN NO OVERLAY FILE AVAILABLE
PNAMES: 0               ;PLACE  FOR OVERLAY TOR ETURN NAME PTR
PSTATE:0                ;RETURN OF H OF L OR -1 IF NAME NOT FOUND



.REM    %
        ROUTINE RECORDS THE BOARD FROM WHICH THE CURRENT
        DIAGNOSTIC SIGNAL IN ERROR CAME.  THIS IS DONE BY
        INCLUSIVE-OR-ING A BIT INTO A UML TABLE WHOSE BITS
        REPRESENT BACKPLANE SLOTS.  THIS TABLE'S ADDRESS IS
PASSED TOISOLATION ROUTINES FOR THEIR USE.
        %
SBOARD: PUSH    <R1,R2>



        MOV     (R5)+,R2        ;GET POINTER TO UML TABLE
        MOV     DFD8,R0         ;GET READ FUNCTION/8
        MOV     DFXUM(R0),R0    ;GET CONVERT TABLE PTR
        MOVB    (R0)+,R1        ;GET ENTRY COUNT
1$:     BEQ     3$              ;NO ENTRIES OR NOT FOUND
        CMPB    F8BTF,(R0)+     ;FIND BIT RANGE
        BLE     2$              ;ITS IN RANGE OF INTEREST
        INCB    R0              ;SKIP SLOT NUMBER
        DEC     R1              ;COUNT ENTIRES
        BR      1$              ;LOOP
2$:     MOVB    (R0),R1         ;GET SLOT NUMBER
        ASR     R1              ;DIVIDE BY 8
        ASR     R1
        ASR     R1              ;
        BIC     #177771,R1      ;MAKE WORD INDEX
        ADD     R2,R1           ;ADD TABLE BASE 
        MOVB    (R0),R0         ;AGAIN GET SLOT NUMBER
        BIC     #177760,R0      ;KEEP LOW 4 BITS
        SUB     #15.,R0 ;MAKE PDP-11 BIT NUMBER
        NEG     R0
        ASL     R0              ;MAKE WORD INDEX
        BIS     MTBL(R0),(R1)   ;SET THE SLOT BIT
3$:     POP     <R2,R1>         



        RTS     R5


;       THIS IS THE UML TABLE REPRESENTING THE PROCESSOR BACKPLANE .
;SLOTS ARE MAPPED INTO BITS FROM LEFT TO RIGHT, TOP TO
;BOTTOM.  E.G., SLOT 1 IS BIT 14 OF THE FIRST WORD, SLOT 16 IS
;BIT 15 OF THE SECOND WORD.  THE TABLE MUST BE CLEARED UPON
;EACH ENTRY TO "REPORT".

DIAUML: .WORD   0,0,0,0

;NEXT TWO BYTES MUST BE IN THIS ORDER.
;USED BY EBUSB ROUTINE TO TRACK COMMON EBUS BIT FAILURES.
;IF EBFLG IS POSITIVE AND NON-ZERO, THEN IT IS A COUNT OF THE
;NUMBER OF ERRORS AND BUSBIT IS THE EBUS BIT NUMBER.  EBFLG
;IS ZERO IF NO ERRORS OR -1 IF MORE THAN ONE BIT HAD ERRORS.
BUSBIT: .BYTE   0
EBFLG:  .BYTE   0
        
DFD8:   0               ;HOLDS DIAG FCN DIVIDED BY 88






;CONVERSION TABLE FOR MAPPING DIAGNOSTIC FUNCTION.  BIT
;NUMBERS INTO THE BOARD (ACTUALLY SLOT) OF ORIGIN.
;1$ THRU 8$ REPRESENT THE 8 GROUPS OF DIAGNOSTIC FUNCTIONS.
;E.G. 3$ IS FUNCTIONS 120-127.  THE FIRST BYTE WITHIN EACH
;GROUP ENTRY TELLS HOW MANY PAIRS OF BYTES FOLLOW IT.
;THE FIRST BYTE O@ EACH SUBSEQUENT PAIR IS THE
;BIT NUMBER OF THE RIGHTMOST GROUP OF BITS AND THE SECOND BYTE
;IS THE SLOT NUMBER OF THE BORD FROM WHICH THT GROUP OF
;BITS IS READ.  THE LEFTMOST BIT OF A GROUP IS BIT 0 IF IT IS THE
;FIRST GROUP IN THE ENTRY, OTHERWISE IT IS ONE BIT HIGHER THAN
;THE RIGHTMOST BIT OF THE PREVIOUS GROUP.  THAT MEANS THAT SOME
;GROUPS WILL MAP UNUSE BITS TO A SLOT, BUT UNUSED BITS SHOULDN'T
;GET THIS FAR INTO THE ERROR REPORTER.
DFXUM:  1$,2$,3$,4$,5$,6$,7$,8$
;DF 100-107
1$:     .BYTE   4,17.,31.,23.,47.,28.,36.,35.,32.
;DF 110-117
2$:     .BYTE   2,17.,34.,35.,33.
;DF     120-127
3$:     .BYTE   0               ;EDP REGISTERS, NO BITS
;DF 130-137
4$:     .BYTE   3, 11.,54.,17.,48.,24.,35.
;DF 140-147
5$:     .BYTE   6,5,45.,11.,52.,17.,50.,23.,44.,29.,42.,35.,40.
;DF 150-157
6$:     .BYTE   1,35.,38.
;DF 160-167
7$:     .BYTE   4,8.,20.,26.,20.,33.,22.,35.,20.
;DF 170-177
8$:     .BYTE   7,4,10.,10.,12.,14.,9., 19.,11.
        .BYTE   21.,28., 29.,23.,35.,21.
.EVEN
.REM    %
        ROUTINE TO KEEP TRACK OF WHETHER ALL DIAGNOSTIC BIT
FAILURES WERE ON THE SAME EBUS BIT, FOR USE BY ISOLATION ROUTINES.
THE FLAG BYTE, EBFLG, IS ZEROED UPON ENTRY TO REPORT.
IF ALL ERRORS IN A DIAG FUNCTION ERRORCALL
;SCANOUT OR DCOMP WERE ON THE SAME EBUS, BIT, THEN THE FLAG BECOMES THE
ERROR COUNT.  IF MORE THAN BIUT HAD AN ERROR, THE FLAG IS SET NEGATIVE.
IF THE FLAG IS POSITIVE AND NON-ZERO THEN THE BYTE 'BUSBIT' HAS THE
BIT NUMBER.  THE TWO BYTES ARE IN ONE WORD WITH THE FLAG IN THE LEFT.
        %
EBUSB:  TSTB    EBFLG           ;WHAT STATE ARE WE IN NOW?
        BMI     2$              ;ALREADY MULTI-BITSD
        BGT     1$              ;NO FIRST TIME, SAME BIT
;FIRST TIME, FLAG WAS ZERO
        MOVB    F8BTF,BUSBIT    ;SAVE BIT NUMBER
1$:     INCB    EBFLG           ;COUNT IN FLAG
        CMPB    F8BTF,BUSBIT
        BEQ     2$              ;STILL SAME BIT
        MOV     #-1,BUSBIT      ;SET MULTI-BIT FLAG
2$:     RTS     PC




;ROUTINE CHECKS FOR PRESENCE OF CORRECT OVERLAY FILE AND
;TRIES TO LOAD IT FI NOT CURRENTLY IN CORE.
READDS: MOVB    FT8DF,R0        ;GET DIAG FCN
        ASR     R0
        ASR     R0
        BIC     #177761,R0      
        MOV     R0,DFD8         ;SAVWE FOR "SBOARD"
        MOV     DSTFNM(R0),R0   ;GET FILE NAME PTR
;ENTRY POINT RDNDS IS FOR OVERLAYS OTHER THAN THE PROCESSOR DS FILES.
;R0 SHOULD POINT TO A SIX BYTE ASCII FILENAME.
RDNDS:  PUSH    <R1,R0>


        MOV     #CONSOL-6,R1    ;POINT AT TAG LOC
1$:     CMP     (R0)+,(R1)+     
        BNE     2$              ;WRONG TAG, NEED LOAD
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    1$              ;DO 3 WORDS
        BR      31$             ;CK...ALREADY LOADED

2$:     MOV     (SP),R0         ;GET NAME PTR
        CMP     R0,PNAMSV       ;TRIED BEFORE?
        BEQ     41$             ;YES, NOT AGAIN
        CLR     TRIES
        MOV     R0,PNAMSV       ;NO     SAVE FOR CHECK
        MOV     (R0)+,RPBUF     ;STORE NAME STRING
        MOV     (R0)+,RPBUF+2
        MOV     (R0),RPBUF+4
21$:    MOV     #RPBUF0,R0
        JSR     PC,LODPRG      ;TRY FOR FILE
        BCC     22$             ;IF ALL O.K.
        TST     TRIES           ;DONE THIS BEFORE?
        BNE     41$             ;BR IF YES
        PMSG    <MOUNT >

        MOV     #RPBUF,R0       ;ASK FOR FILE TO BE MOUNTED
        PNTAL   
        PMSG    < AND HC\>

        PRGHLT
        INC     TRIES           ;SET ONE TIME SWITCH
        BR      21$             ;GIVE USER ONE CHANCE
22$:    MOV     (SP),R0         ;NAME PTR,AGAIN
        MOV     #CONSOL-6,R1   ;TAG LOC
3$:     MOV     (R0)+,(R1)+     ;STORE I.D. TAG
        CMP     R1,#CONSOL-2    ;DONE?
        BLOS    3$              ;DO 3 WORDS
31$:    CLC
        
4$:     POP     <R0,R1>



        RTS     PC




41$:    SEC                     ;TAKE ERROR EXIT
        BR      4$
        
TRIES:  0                       ;FILE MOUNT TRY CTR
        
PNAMSV: 0
RPBUF0: .ASCII  %P %
RPBUF: .ASCIZ  %NNNNNN.A11%
.EVEN

;NAMES OF DIAGNOSTIC SIGNAL INTERPRETER FILES
DSTFNM: 1$,1$,2$,2$,2$,2$,3$,3$    ;8 ENTRIES
1$:     .ASCIZ  %DH1017%        ;DF 100-117
.EVEN
2$:     .ASCIZ  %DH1257%        ;DF 120-157

.EVEN
3$:     .ASCIZ  %DH1677%        ;DF 160-177
.EVEN

;SETUP TABLES FOR SCANOUT ERROR REPORTER
;DATA SIZE IN BYTES
F8SIZT: .WORD   3,3,2
;FIRST AND LAST BIT NBRS
F8BITT: .BYTE   0,19.,12.,35.,20.,35.
;FIRST BIT MASK  (BYTE)
F8MSKT: .WORD   10,200,200

ASCLL:  .ASCII  %LL%
;FIRST AND LAST BIT VARIABLE STORAGE
F8BTF:  .BYTE   0
F8BTL:  .BYTE   0
FT8DUN: .BYTE   0
FT8DF:  .BYTE   0               ;DIAG FCN
FT8SIZ: .BYTE   0       ;SIZE PARAM
.EVEN


;ROUTINE TO HANDLE TYPING OF A 36-BIT WORD POINTED TO BY R2
;UNPACKS AND SENDS ONE BYTE AT A TIME TO BINPAK WHICH CONVERTS
;TO BINARY-ASCII IN GROUPS OF THREE BITS.  ONES IN THE MASK WORD
;CAUSE XS TO APPEAR IN THE TYPED BINARY WORD.

TYP36:  PUSH    R5
        MOV     #-5,R5          ;SET BYTE COUNT
        JSR     PC,TYPBI                ;SET UP BUFFER
;LOOP HERE TO PROCESS THE 5 BYTES

1$:     MOV     #-8.,TEM.                ;SET BIT COUNTER
        MOVB    (R4)+,R0                ;GET MASK BYTE
        MOVB    (R2)+,R1                ;GET DATA BYTE
        JSR     PC,BINPAK               ;EDIT BINARY INTO BUFFER
        INC     R5
        BMI     1$              ;CONTINUE

        MOV     R3,R0           ;PICK UP PTR
        ADD     #6,R0           ;SKIP LEADING GARBAGE
        PNTAL
        POP     R5
        POP     R4
        PCRLF                   ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO TYPE 16-BIT DATA IN BINARY-ASCII

TYP16:  JSR     PC,TYPBI                ;INIT BUFFER
        MOV     (R1),R0         ;LOAD MASK WORD
        MOV     (R2),R1         ;LOAD DATA WORD
        MOV     #-16.,TEM.               ;DO 16 BITS
        JSR     PC,BINPAK               ;EDIT TO BUFFER

        MOV     R3,R0           ;PICK UP PTR
        PNTAL                   ;PRINT IT
        RTS     PC              ;RETURN TO SCANNER


;TYPE MEMORY REQUESTS AND READ/WRITE BITS

TYPRQS: MOV     #6,R2   ;BIT COUNT
        MOVB    (R5)+,R1        ;GET BIT WORD
        SWAB    R1              ;POSITION TO SHF INTO SGN
        PSPACE                  ;SPACE 1
1$:     MOV     #'0,R0          ;ASSUME A ZERO
        TST     R1              ;
        BPL     2$              ;BR IF ZERO
        MOV     #'1,R0          ;ITS A ONE
2$:     PNTCHR
        PSPACE,PSPACE,PSPACE    ;SPACE3
        ROL     R1              ;NEXT BIT
        DEC     R2              ;COUNT
        BGT     1$              ;DO MORE
        RTS     PC


;TYPE 22-BIT BINARY
TYP22B: PUSH    R5
        MOV     #-3,R5          ;BYTE COUNT
        JSR     PC,TYPBI                ;SET UP
1$:     MOV     #-8.,TEM.       ;BIT COUNT
        CLR     R0              ;ZERO MASK
        MOVB    (R2)+,R1        ;GET DATA BASE
        JSR     PC,BINPAK       ;STUFF BUFFER
        INC     R5              ;COUNT BYTE
        BMI     1$
        MOV     R3,R0           ;GET POINTER TO STRING
        ADD     #3,R0           ;SKIP BITS 12,13
        PNTAL
        POP     R5      ;RESTORE STACK PTR
        PCRLF           ;CR/LF
        RTS     PC              ;BACK TO SCAN

;ROUTINE TO INITIALIZE SOME VALUES FOR TYP16 AND TYP36

TYPBI:  MOV     #TYPBF+60.,R3   ;POINT TO RIGHT END OF BUFFER
        CLRB    -(R3)           ;SET TERMINATOR
        MOV     #2,SPCNT                ;SET SPACE COUNT
        RTS     PC

;THIS ROUTINE GENERATES CHARACTERS IN AN OUTPUT BUFFER BY
        
;SCANNING UP TO 16-BITS OF DATA AND A MASK.  A ONE IN THE MASK
;CAUSES AN X TO APPEAR IN THE BUFFER.  A ZERO IN THE MASK CAUSES
;RTHE CORRESPONDING DATABITS VALUE TO APPEAR.  THE MAGIC SPACE
;COUNT CAUSES A SPACE TO APPEAR AFTER 3 BITS OF DATA AND CAN
;BE PRESET TO CASES THE FIRST SPACE TO APPEAR
;AFTER EITHER 1 BIT AS FOR A 16-BIT WORD, OR 3 BITS AS FOR A 36-BIT WORD.

BINPAK: BIT     #BIT0,R0                ;TEST MASK BIT
        BEQ     1$                      ;IF ZERO TEST DATA
        MOVB    AXORSP,-(R3)    ;INSERT AN X
        BR      3$                      ;CONTINUE

1$:     BIT     #BIT0,R1                ;TEST DATA BIT
        BNE     2$
        MOVB    ZORSP,-(R3)     ;PUT A 0 OR SPACE IN BUFFER
        BR      3$              ;CONTINUE

2$:     MOVB    #AS1,-(R3)              ;PUT A 1 IN BUFFER

3$:     BIT     #BIT0!BIT1,SPCNT         ;TIME TO SPACE?
        BNE     4$                      ;NO
        MOVB    #ASSP,-(R3)             ;INSERT SPACE
        INC     SPCNT                   ;AND COUNT IT


4$:     ROR     R0                      ;SHIFT MASK
        ROR     R1                      ;SHIFT DATA

        INC     SPCNT                   ;COUNT BIT
        INC     TEM.                    ;COUNT OPERATIONS
        BMI     BINPAK
        RTS     PC                      ;ALL DONE

;-----HERE IS A LITTLE ROUTINE WHICH PLACES AN EMT ON THE ERROR STACK
;       WITH 16-BIT DATA FOR LATER PRINTING.
$ERPNT: PUSH    R0
        MOV     ERSP..,R0               ;GET STACK PTR
        MOV     #FT10,(R0)+             ;FORMAT TYPE
        MOV     (R5)+,(R0)+             ;THE EMT
        POP     (R0)+                   ;R0 CONTENTS
        MOV     R0,ERSP..               ;SAVE NEW PTR


        RTS     R5


.SBTTL          SLOT-TO-BOARD# CONVERSION TABLE & DATA 14-MAR-77

.REM    %
        EACH TABLE IS INDEXED BY SLOT NUMBER.  WHICH TABLE & HOW THAT
        TABLE IS USED DEPENDS UPON THE BACKPLANE NUMBER.  FOR THOSE
        BACKPLANES WHICH HAVE EXCLUSIVELY M8500 BOARTDS, THE TABLE
        CONTAINS THE LAST 2 DIGITS OF THE BOARD #.  FOR INTERNAL
MEMORY BACKPLANES, THE TABLE CONTAINS A DISPLACEMENT INTO A
STRING OF CHARACTERS.  NOTE THAT IN ALL TABLES A 0 MEANS A SPARE
        AND A -1 INDICATES A CABLE.  ANY OTHER NEGATIVE # MEANS THAT BOARD
        REPLACEMENT REQUIRES DESKEWING OF OTHER SYSTEM COMPONENTS.
        %
;----COMMON BACKPLANE TBLE PARAMETERS.
$MAXBP=5                        ;CURRENTLY BACKPLANES 1-5 ARE
                                ;RECOGNIZED
                                ;NOTE THAT BKPLN 0 MAKES PNTUML A NOP.


$DFTBP=4                        ;DEFAULT BP SET TO 4
$BPN:   .BYTE   $DFTBP          ;BACKPLANE # (DFT OR AS SET)
$BPDEV: .BYTE   0               ;BACKPLANE DEVICE FLAG
BPTA:   .WORD   BP1,BP2,BP35,BP4,BP35 ;ADRS OF BKPLAN BD # TABS
BPCRA:  .WORD   M8500,M8500,IMEMBP,M8500,IMEMBP ;ADR OF CONV ROUTINES
HSNPB:  .BYTE   16.,10.,54.,54.,54. ;HIGHEST SLOT/BACKPLANE
;-----BAKCPLANE 1.  DMA/DIA BACKPLANE
BP1:    .BYTE   0,-1,-63.,-60.,58.,58.,58.,58.,58.,58.,58. ;SLOTS 0-10
        .BYTE   58.,0,50.,50.,51.,-1            ;SLOTS 11-16
;-----BACKPLANE 2.DTE20/RH20 BACKPLANE.
BP2:    .BYTE   0,-1,-59.,54.,53.,52.,0,0,0,0,-1        ;SLOTS 0-10
;-----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MA20.
BN35A:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8562/         ;2
        .ASCIZ  /G235/  ;10
        .ASCIZ  /H217B/         ;15
        .ASCIZ  /G114/  ;23
        .ASCIZ  /M8561/ ;30
;----THE FOLLOWING IS A LIST OF PART NAMES FOR THE MB20.
BN35B:  .ASCIZ  /?/             ;0
        .ASCIZ  /M8565/         ;2
        .ASCIZ  /G236/          ;10
        .ASCIZ  /H224B/         ;15
        .ASCIZ  /G116/  ;23
        .ASCIZ  /M8568/         ;30
;-----BACKPLANES 3 & 5.  INTERNAL MEMORY (MA20,MB20).
BP35:   .BYTE   0,-2,10,15,23,10,15,23,10,15,23                 ;0-10
        .BYTE   10,15,23,10,15,23,10,15,23,10           ;11-20
        .BYTE   15,23,10,15,23,-30,0,0,-30,10   ;21-30
        .BYTE   15,23,10,15,23,10,15,23,10,15   ;31-40
        .BYTE   23,10,15,23,10,15,23,10,15,23   ;41-50
        .BYTE   40,15,23,-2                     ;51-54
;-----BACKPLANE 4.  KL10A CPU BACKPLANE.
BP4:    .BYTE   0,-1,-1,-1,-16.,-16.,-16.,-19.,-19.,33.        ;0-9
        .BYTE   35.,36.,34.,0,17.,17.,17.,21.,0,21.     ;10-19
        .BYTE   37.,29.,31.,13.,21.,21.,0,14.,15.,18.   ;20-29
        .BYTE   20.,32.,-26.,38.,45.,25.,43.,0.,42.,12. ;30-39
        .BYTE   48.,12.,48.,12.,48.,41.,40.,44.,22.,12. ;40-49
        .BYTE   48.,12.,48.,12.,24.
                                                        ;50-54
.EVEN
;-----LIST OF BOARDS WITH "YA" PART NUMBERS
YALIST: .BYTE   13.,18.,20.,26.,29.,31.,0
.EVEN

.SBTTL          BOARD CALLOUT PRINT ROUTINE
.REM    %
        ROUTINE TO PRINT BOARD  CALLOUTS.  TABLE DRIVEN FROM A FOUR-WORD
        UML TABLE CONTAINING ONES IN POSITIONS REPRESENTING
        BOARDS (SLOTS) TO BE CALLED OUT.

        JSR     R5,PNTUML
        .WORD   TABLE           ;ADDRESS OF UML TABLE

        EACH ONE-BIT FOUND IN THE TABLE WILL BE USED TO CAUSE A PRINTOUT
        OF THE FORM "M8520,SLOT 30."  UP TO THREE SUCH ITEMS ARE PRINTED
        PER LINE UNTIL THE TABLE IS EXHAUSTED.  BITS IN POSITIONS FOR
        CABLES CAUSE A PRINTOUT OF "CAVBLE, SLOT 2." WHILE A BIT IN
        AN EMPTY SLOT POSITION CAUSE PRINTINGOF "ERROR,SLOT 18."
        BITS IN THE LAST WORD IN PHANTOM SLOTS 55 AND 56 ARE IGNORED.
        IF THE BYTE IN BITS 0-7 OF HE FOURTH WORD EQUALS THE SLOT NUMBER
        OF THE ITEM BEING PRINTED, THAT ITEM IS FLAGGEWD AS BEINGTHE
MOST LIKELY FAILING BOARD.  NOTE THAT THE BACKPLANE NUMBER IS PRINTED
FIRST, NOT AS A PART OF THE BOARD LOCATION.
        %
;-----NON-BACKPLANE RELATED INIT.
PNTUML: REGSAV                  ;SAVE ALL REGS
        MOV     (R5),R5         ;ADR OF UML TO R5
        MOVB    6(R5),12$+2             ;HIGHEST PROBABILITY BOARD
        CLR     SKEW.           ;CLEAR SKEW ADJ FLAG
        CLR     R2              ;TO FOOL SLOT SELECTOR
        TST     -(R5)
        MOV     #-1,R4          ;"CURRENT SLOT #"
;-----PRINT LINE LOOP TOP
        PMSG    <\BACKPLANE: >
        MOVB    $BPN,R0         ;GET OUR BKPLN NUMBER
        BEQ     17$             ;BKPLN 0...IGNORE & RETURN
        BLT     1$              ;NEG BKPLN...ERROR
        CMP     R0,#$MAXBP              ;BKPLN # IN RANGE ?
        BLE     2$              ;YES
1$:     PMSG    <?\>            ;ELSE SEND ERR CHR

        BR      17$             ;& EXIT
2$:     MOV     R0,R1           ;HANG ONTO B# FOR NOW
        PNTDEC                  ;PRINT B#
;----BACKPLANE RELATED INIT
        MOVB    HSNPB-1(R1),6$+2        ;MAX SLOT # FOR THIS BKPLN
        ADD     R1,R1           ;DOUBLE B# FOR WD NDX
        MOV     BPTA-2(R1),7$+2         ;CONVERSION TABLE ADDRESS
        MOV     BPCRA-2(R1),10$+2       ;CONVERSION ROUTINE ADR
        BR      3$+2            ;SKIP A TAB
3$:     PTAB,PTAB
        MOV     #3,R3   ;ITEMS/LINE COUNT



;
;-----SECTION TO SELECT SLOT # ACCORDING TO UML
4$:     INC     R4              ;BUMP SLOT NUMBER
        CLC                     ;TO IMPLIMENT A LOGICAL RIGHT SHIFT
        ROR     R2              ;SHIFT MASK
        BNE     5$      ;BR IF SOMETHING LEFT IN MASK
        MOV     #BIT15,R2               ;ELSE RESET MASK
        TST     (R5)+           ; & PT TO NXT UML WD
5$:     BIT     R2,(R5)         ;BIT SET IN UML WD?
        BEQ     4$      ;BR IF NO...CHK NXT BIT
6$:     CMP     R4,#000000      ;SLOT # IN RANGE OF BACKPLANE?
        BGT     14$             ;BR IF NOT...EXIT CLEANLY


;----PRINT BOARD NAME AND SLOT #
        
7$:     MOVB    000000(R4),R1   ;GET BYTE FROM CONV TABLE
        BEQ     8$      ;BR IF ERROR
        BGT     10$             ;BR IF NO DESKEW
        NEG     R1              ;DESKEW OR CABLE?
        INC     SKEW.           ;SET SKEW FLAGM
        CMP     R1,#1           ;CABLE?
        BEQ     9$              ;YES
        PNTCI,'#                ;NO, PRINT DESKEW CHARACTER
        BR      10$             
8$:     PMSG    <ERROR>         ;ELSE ERROR
        BR      11$
9$:     PMSG    <#CABLE>
        BR      11$
10$:    JSR     PC,000000       ;CALL CONVERSION ROUTINE
11$:    PMSG    <,SLOT >        ;PRINT REST OF MSG
        MOV     R4,R0           ;SLOT #
        PNTDEC
12$:    CMP     R4,#000000      ;HIGHEST PROB SLOT?
        BNE     13$             ;NO
        PNTCI,"**               ;YES...MARK OUTPUT
        NEGB    12$+2           ;MARK ** P[RINTED
13$:    PSPACE,PSPACE,PSPACE    ;SEP BOARTD CALLOUTS
        DEC     R3              ;WHAT TO DO ABOUT <CRLF>
        BGT     4$              ;NOTHING
        PCRLF                   ;ELSE SEND LINE
        BR      3$              ;LOOP


;-----EXIT SECTION
14$:    CMP     R3,#3           ;AT END OF LINE WHEN DONE?
        BEQ     15$             ;YES, NO CRLF
        PCRLF
15$:    PNTBAK  ;BACK UP OUT BUFFER PTR
        TSTB    12$+2           ; ** PRINTED?
        BGE     16$             ;NO
        PMSG    <**HIGHEST PROBABILITY OF FAILURE>
16$:    PCRLF
        TST     SKEW.           ;SKEW SENSITIVE BOARD?
        BEQ     17$             ;NO
        PMSG    <#SYSTEM DESKEW REQUIRED\>
17$:    REGRST                  ;RESTORE THE REGISTERS
        TST     (R5)+           ;BYPASS TP
        RTS     R5              ;RETURN TO CALLER


;----M8500 ONLY CONVERSION ROUTINE.
M8500:  PNTCI,'M                ;PRINT "M"
        MOV     #8500.,R0       ;GET 8500
        ADD     R1,R0           ;TACK ON LAST 2 DSIGITS
        PNTDEC,PNTBAK           ;PRINT #,DEL .
        MOV     #YALIST,R0      ;POINT TO LIST OF YA TYPES
1$:     CMPB    R1,(R0)         ;FIND ONE?
        BEQ     2$              ;YES
        TSTB    (R0)+           ;END OF LIST?
        BNE     1$              ;NO, CHECK NEXT ENTRY
        BR      3$              ;DONE, GET OUT
2$:     PNTCI,"YA                       ;ADD YA TO PART #
3$:     RTS     PC
;-----INTERNAL MEMORY BACKPLAN CONVERSION ROUTINE.
IMEMBP: MOV     #BN35A,R0       ;POINT TO MA20 NAMES
        TSTB    $BPDEV          ;MB20?
        BEQ     1$              ;NO
        MOV     #BN35B,R0       ;YES, POINT TO MB20 NAMES
1$:     ADD     R1,R0           ;DISPLACEMENT TO R0
        PNTAL                   ;PRINT THE NAME STRING
        RTS     PC


.REM    %
        SUBROUTINE "BACKPLANE" SETS THE BACKPLANE NUMBER USED BY
        PNTUML.  IT IS PROVIDED FOR USE FROM AN ISOLATION ROUTINE.
        THE UPPER HALF OF R0 MAY BE USED TO IDENTIFY THE DEVICE IN
        THE BACKPLANE BEING SET.

%
BACKPL: MOV     R0,$BPN         ;GET BACKPLANE # FROM R0
        RTS     R5              ;RETURN TO CALLER



.SBTTL          REPORT VARIABLES AND CONSTANTS
;ERROR STACKS - ONE ALSO USED AS TYPEOUT BUFFER SO MIN SIZE IS
;37 WORDS
ESTK1:  .BLKW   ESTSIZ
ESTK2:  .BLKW   ESTSIZ
TYPBF:  .BLKW   37.

;POINTERS AND OTHER VARIABLES

MKP.:    ZMK.            ;MASK POINTER
ZMK.:   .WORD   0,0,0,0,0,0     ;DEFAULT MASK
ACP.:   0               ;POINTER TO ACTUAL DATA
EXP.:   0               ;POINTER TO EXPECTED DATA
DFP.:   DIF.            ;POINTER TO DIFFERENCE DATA
DIF.:   .WORD   0,0,0,0,0,0
        TEM.:   0               ;TEMP
SKEW.:  0               ;TEMP
LHTAB: .ASCII %LHLH%
AXORSP: .WORD   ASX             ;REPLACEMENT CHAR FOR ONES IN MASK
ZORSP:  .WORD   60              ;FILL CHARACTYER 0 OR SPACE
SPCNT:  0               ;SPACE POSITION COUNTER
ALL7:   .WORD   -1,-1,-1,-1,-1,37
        DGP.:   .WORD   0               ;HOLDS DIAG FCN PTR
        BYP.:   .WORD   0               ;HOLDS BYTE PTR TABLE PTR
        BIT.:   .WORD   0               ;BIT MASK FOR SCANOUT ERR
BITTBL:        .WORD   0               ;ZERO CONSTANT TO GO WITH TABLE
MTBL:   .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15
;SEQ138



;SEQ206

.SBTTL  *DHKBD* DISPATCH TABLES
        ;INITIALIZATION ROUTINES

        ;BIT 15 SET IF ENTRY POINT TO BE INCREMENTED BY 2 UNLESS LOOPING.

INITAB: .WORD   I.000           ;ONE-TIME INITIALIZATION
        .WORD   I.001!BIT15     ;SET PROPER DEFAULTS
        .WORD   0               ;NO INIT FOR TEST 2
        .WORD   0               ;NO INIT FOR TEST 3
        .WORD   I.004!BIT15     ;SET-UP, CLEAR MEMORY & SET SCAN
        .WORD   I.005           ;CONDITION CCW ADDRESS
        .WORD   I.006           ;CONDITION CCW ADDRESS
        .WORD   0               ;NO INIT FOR TEST 7
        .WORD   0               ;NO INIT FOR TEST 8
        .WORD   I.009!BIT15     ;CONDITION CCW BUF WD 1
        .WORD   I.010           ;CONDITION CCW BUF WD 2
        .WORD   I.011           ;CONDITION CCW BUF WD 2
        .WORD   I.012           ;CONDITION CCW BUF WD 1
        .WORD   I.013           ;HALTS TO EPT
        .WORD   0               ;NO INIT FOR TEST 14
        .WORD   I.015!BIT15     ;SET COMMAND LIST FOR TEST 15
        .WORD   I.016!BIT15     ;SET COMMAND LISTS FOR TEST 16
        .WORD   I.017!BIT15     ;CONDITION CCW & SET SCAN MASK
        .WORD   0               ;NO INIT FOR TEST 18
        .WORD   0               ;NO INIT FOR TEST 19
        .WORD   I.020!BIT15     ;SET COMMAND LIST FOR TEST 20
        .WORD   I.021!BIT15     ;SET COMMAND LIST FOR TEST 21
        .WORD   I.022!BIT15     ;SET COMMAND LIST FOR TEST 22
        .WORD   I.023!BIT15     ;SET COMMAND LIST FOR TEST 23
        .WORD   I.024!BIT15     ;SET COMMAND LIST FOR TEST 24
        .WORD   I.025!BIT15     ;SET COMMAND LIST FOR TEST 25
        .WORD   I.026!BIT15     ;SET COMMAND LIST FOR TEST 26
        .WORD   I.027!BIT15     ;SET COMMAND LIST FOR TEST 27
        .WORD   0               ;NO INIT FOR TEST 28
        .WORD   0               ;NO INIT FOR TEST 29
        .WORD   I.023!BIT15     ;30 SAME AS 23 INIT
        .WORD   I.031!BIT15     ;SET COMMAND LIST FOR TEST 31
        .WORD   I.032!BIT15     ;SET COMMAND LIST FOR TEST 32
        .WORD   0               ;NO INIT FOR TEST 33
        .WORD   0               ;NO INIT FOR TEST 34
        .WORD   ENDPAS          ;END PASS CONTROL

;SEQ207

        ;TEST ROUTINES

        ;BIT 15 SET IF TEST MAY BE BYPASSED FOR XOR TESTING

TESTAB: .BYTE   35.             ;NUMBER OF TESTS
        .BYTE   'C              ;CHANNEL I.D.
        .WORD   T.001           ;CHANNEL TIMING/ CBUS SCAN
        .WORD   T.002!BIT15     ;CHANNEL MASTER RESET
        .WORD   T.003           ;CHANNEL RAM RESET
        .WORD   T.004!BIT15     ;TEST ADDRESSING FOR EPT FETCH
        .WORD   T.005!BIT15     ;CCW ADDRESS 17777777
        .WORD   T.006!BIT15     ;CCW ADDRESS 0
        .WORD   T.007           ;SLIDING BIT CCW TEST
        .WORD   T.008           ;INITIAL WORD-COUNT TEST
        .WORD   T.009!BIT15     ;STORE STATUS ADDRESSING TEST
        .WORD   T.010           ;CCW BUF WORD2 ONES
        .WORD   T.011           ;CCW BUF WORD2 0S
        .WORD   T.012           ;CCW BUF WORD 1 CLP=17777777
        .WORD   T.013           ;CCW BUF WORD 1 NXM,CLP=0
        .WORD   T.014!BIT15     ;JUMP
        .WORD   T.015!BIT15     ;ZERO-WD XFER/ INCREMENTAL CCW FETCH
        .WORD   T.016           ;CH PRIORITY/ CCW BUFFER ADDRESS
        .WORD   T.017           ;1 WD CTOM ZERO-FILL
        .WORD   T.018!BIT15     ;INITIAL ACTION COUNTER
        .WORD   T.019           ;CCL ALU/REQ CTR
        .WORD   T.020           ;1 WD DATA FETCH ADDRESSING
        .WORD   T.021           ;2 WD DATA FETCH ADDRESSING
        .WORD   T.022           ;3 WD DATA FETCH ADDRESSING
                                ;LONG WC ERROR STATUS
        .WORD   T.023           ;4 WD DATA FETCH ADDRESSING
                                ;BUFFER UNLOAD & NORMAL STATUS
        .WORD   T.024           ;1-WD RD REVERSE ADDRESSING
        .WORD   T.025           ;2-WD RD REVERSE ADDRESSING
        .WORD   T.026           ;3-WD REVERSE ADDRESSING
        .WORD   T.027           ;4-WD RD REVERSE ADDRESSING
        .WORD   T.028           ;CCW ALU CARRY
        .WORD   T.029           ;ZERO-FILL DATA FETCH
        .WORD   T.030           ;RH20 ERROR STATUS
        .WORD   T.031           ;FAST CHANNEL OVERRUN TEST
        .WORD   T.032           ;SLOW CHANNEL OVERRUN TEST
        .WORD   T.033           ;LAST TRANSFER ERROR/ NORMAL
        .WORD   T.034           ;LAST TRANSFER ERROR/ STORE
        .WORD   NORMAL          ;END PASS


;SEQ208

.SBTTL          CHANNEL DIAGNOSTIC TEST INITIALIZATION
        .LIST   MC,MD,MEB
.REM    %
        THIS ROUTINE PERFORMS ONCE-ONLY INITIALIZATION.
%
I.000:  CLR     NIPASS          ;CLR NOT INITIAL PASS
        TST     IMEMCF          ;INITIAL PROGRAM LOAD?
        BNE     1$              ;NO, BYPAS TITLE PRINT
        PMSG    <TYMSHARE DIAGNOSTIC SYSTEM-TMBOXD\>

        PMSG    <KL-10 CHANNEL CONTROL DIAGNOSTIC >

        PNTVER
1$:     PMSG    <\CONSOLE SWITCHES = >

        SWITCH                  ;GET CONSOLE SWITCHES
        PNTOCT                  ;PRINT THEM
        PCRLF                   ;CARRIAGE RETURN
        CALTIM

.REM    %
        LOADS STANDARD MICRO-CODE IF REQUIRED & CLEARS THE USER
BASE ADDRESS.
%
        CLR     R2              ;SET TRY U-CODE LOAD
        MOV     CONSOL-2,PWRUP  ;JUST POWERED UP?
        BGT     4$              ;NO, CHECK SM
        TST     IMEMCF          ;INITIAL LOAD?
        BEQ     4$              ;YES, CHECK SM
2$:     INC     R2              ;SET U-CODE TRIED
        MOV     #ULOAD,R0       ;
        PRGCMD                  ;LOAD MICRO CODE
        BCC     4$              ;LOADS O.K., CHECK SM

3$:     PMSG    <PLEASE LOAD DIAGB,RAM, HC WHEN READY\>

        PRGHLT                  ;WAIT FOR CONTINUE


;SEQ209

4$:     MOV     #1,CONSOL-2     ;CLEAR INITIAL PASS
5$:     SM                      ;START U-CODE
        BCC     7$              ;O.K.
        TST     R2              ;DID I LOAD IT?
        BEQ     2$              ;NO,TRY IT ONCE
6$:     ERROR   <U-CODE ERR>    ;EBOX PROBLEM?

7$:     DPOST                   ;DATA TO AC0
                AC0,UBRCLR      ;
        MOV     #CLRUBR,R0      ;CLEAR USER BASE ADDRESS
        EXCT                    ;
        BCS     6$              ;EXECUTE ERROR

        ;INITIALIZE & PRINT APRID DATA

        JSR     R5,INITM                ;INITIALIZE MBOX SUBROUTINES
        CLR     SCERR           ;CLEAR SCAN ERROR FLAG
        CLR     R0              ;
        SETMPH                  ;SET CLK A PHASE SYNC
        CLR     FAILCH          ;CLEA FAILING CHANNEL
        MOV     #7,CLKFLG       ;ENABLE CRAM/DRAM PARITY/FS STOP
        RSTMBX  
        XQT     APRID           ;GET PROCESSOR & U-CODE OPTIONS
        READ17
        MOV     @.DAT2,R1       ;GET U-CODE VERSION #
        SR      R1,2            ;DISCARD GARBAGE

        BIC     #177000,R1      ;
        PMSG    <U-CODE VERSION >

        MOV     R1,R0           ;PRINT VERSION USED
        PNTOCS
        PTAB


;SEQ210

        ;PROCESSOR OPTIONS CHECK

PROCNO: PMSG    <PROCESSOR SERIAL # >

        MOV     @.DAT3,R0       ;
        BIC     #170000,R0              ;
        PNTDEC                  ;PRINT APRID SERIAL #
        PCRLF                   ;CARRIAGE RETURN
        CLR     CSHOPT          ;CLEAR CACHE OPTION FLAG
        TBIT    19              ;TEST APRID CACHE EXISTS

        BEQ     1$              ;NO CACHE
        COMB    CSHOPT          ;CACHE, SET OPTION FLAG
        TBIT    20              ;TEST APRID CHANNELS EXIST

        BNE     1$              ;OPTION BIT SET
        PMSG    <APRID CHANNEL BIT NOT SET\>

        TST     TSTART          ;START AT SPECIFIC TEST?
        BNE     1$              ;YES, PERMIT RUN
        PMSG    <TEST ABORTED\>

        ERREOP
1$:     RTS     PC              ;RETURN

NIPASS: .WORD   0               ;NON-INITIAL PASS FLAG
PWRUP:  .WORD   0               ;ZERO IF RI OR POWER UP
CSHOPT: .WORD   0               ;CACHE OPTION FLAG
        FAILCH: .WORD   0               ;FAILING CHANNEL
APRID:  WD36    7000,0000,0017  

CLRUBR: IO10    DATAO PAG,,0    ;DATA IN AC0

UBRCLR: WD36    1000,0040,0000  ;DATA FOR CLRUBR

ULOAD:  .ASCIZ  %P DIAGB.RAM%
        .EVEN


;SEQ211

.SBTTL          CHANNEL LOGIC TIMING TEST

.REM    %
        SETS PROPER FLAGS FOR SUBROUTINE DEFAULT & PERFORMS AN MR
%
I.001:  BR      1$              ;BYPASS INITIALIZATION IF LOOP
        JSR     R5,INITM        ;INITIALIZE MBOX SUBROUTINES
        MOV     #1,CLKFLG       ;ENABLE FS CLOCK
        RSTMBX  
1$:     RTS     PC              ;RETURN

.REM    %
        ****TEST 1 CHECKS THE CHANNEL LOGIC TIMING.  SUBTESTS 1 - 5
CHECK CH MR RESET & CH T0-T3.  SUBTESTS 6 & 7 CHECK CH TIMING BLOCK
AND MB REQ INH.  SUBTESTS 8 - 37 CHECK CBUS SELECT LOGIC.  EVEN SUBTESTS
CHECK THE CH BOARD CBUS SELECTS, AND ODD SUBTESTS CHECK THE CRC CBUS
SEL D SIGNALS FOR THE PROPER CBUS SELECTS AT D-TIME.
%

T.001:  INSYNC          ;****SUBTEST 1
        DFXCTT                  ;SET MR RESET
                SETMR           ;
        BRST    8.              ;LET TIMING CYCLE AT LEAST ONCE
        MOV     #3,R3           ;GET CLOCK TO A CHANGE COMING
1$:     FNRD    162             ;
        TBIT    32              ;

        BEQ     2$              ;
        STEP
        DEC     R3              ;
        BGT     1$              ;
2$:     CMP.S   CLKTB1,10       ;AT CH T0?
        BCC     3$
        FAULT   <CH CLK SYN>


;SEQ212

3$:     MOV     #1,R2           ;# OF TICKS FTER SYNC
4$:     MOVB    CHTIM(R2),R1    ;GET EXPECTED DATA
        INSYNC                  ;****SUBTESTS 2-5
        STEP
        CMP.S   CLKTB1,R1       ;TEST CH TIMING
        BCC     5$              ;O.K.
        FAULT   <CH TIMING>

5$:     INC     R2              ;INCREMENT TICK COUNT
        CMP     R2,#4           ;DONE WITH CH TIMING?
        BLE     4$              ;NO, LOOP AGAIN
        INSYNC                  ;****SUBTEST 6
        DFXCTT                  ;SET CH TIMING BLOCK
                70              ;
        STEP            
        FNRD    176             ;CHK MB REQ INH
        TBIT    13

        BNE     6$              ;SET, O.K.
        BITERR
        BR      7$              ;


;SEQ213

6$:     INSYNC                  ;****SUBTEST 7
        BRST    2               ;TRY TO ADVANCE CLOCK
        DFXCTT                  ;CLEAR MASTER RESET
                CLRMR           ;
        STEP
        CMP.S   CLKTB1,10       ;TEST CH TIMING
        BCC     8$
7$:     FAULT   <CH TIMING BLOCK>

8$:     CLR     R2              ;BYTE INDEX
9$:     CLR     R1              ;ODD SUBTESTS
        BISB    CBUSA(R2),R1    ;GET EXPECTED CBUS SEL
        CMP     R1,#1           ;
        BGT     10$             ;
        BIS     #400,R1         ;
10$:    MOV     R2,R3           ;CALCULATE BURST COUNT
        SL      R3,2            ;BRST = (R2*4)


        INC     R5              ;****SUBTESTS 8-37
        INSYNC                  ;SYNC FOR ODD SUBTESTS
        DEC     R5              ;
        SYNCIF                  ;EVEN SUBTEST
        MRESET                  ;MR RESET
        MOV     R3,11$          ;GET BURST COUNT
        JSR     R5,BRST        ;BURST THE CLOCK
11$:    .WORD   0               ;BURST COUNT GOES HERE
        CMP.S   CLKTB2,R1       ;TEST CBUS SEL (A-TIME)
        BCC     12$
        FAULT   <A-TIME CBUS SEL>


;SEQ214

12$:    INC     R5              ;ODD SUBTEST
        MOVB    CBUSD(R2),R1    ;GET EXPECTED DATA
        CMP.S   CLKTB3,R1       ;TEST CRC SEL (D-TIME)
        BCC     13$             ;O.K.
        FAULT   <CRC D-TIME>

13$:    INC     R2              ;NEXT INDEX
        CMP     R2,#14          ;TEST DONE?
        BLE     9$              ;NO, LOOP AGAIN
        NORMAL

CBUSA:  .BYTE   0               ;**8 BURST 0 = 0
        .BYTE   200             ;**10 BURST  4 = 1
        .BYTE   100             ;**12 BURST  8 = 2
        .BYTE   40              ;**14 BURST 12 = 3
        .BYTE   20              ;**16 BURST 16 = 4
        .BYTE   10              ;**18 BURST 20 = 5
        .BYTE   1               ;**20 BURST 24 = 0 & 8A
        .BYTE   201             ;**22 BURST 28 = 1 & 8A
        .BYTE   101             ;**24 BURST 32 = 2 & 8A
        .BYTE   41              ;**26 BURST 36 = 3 & 8A
        .BYTE   5               ;**28 BURST 40 = 6 & 8A
        .BYTE   3               ;**30 BURST 44 = 7 & 8A
        .BYTE   0               ;**32 BURST 48 = 0
        .BYTE   200             ;**34 BURST 52 = 1
        .BYTE   100             ;**36 BURST 56 = 2

CBUSD:  .BYTE   7               ;BURST  0 = D-TIME 0
        .BYTE   7               ;BURST 4 = D-TIME 0
        .BYTE   7               ;BURST 8 = D-TIME 0
        .BYTE   7               ;BURST 12 = D-TIME 0
        .BYTE   6               ;BURST 16 = D-TIME 1
        .BYTE   5               ;BURST 20 = D-TIME 2
        .BYTE   4               ;BURST 24 = D-TIME 3
        .BYTE   3               ;BURST 28 = D-TIME 4
        .BYTE   2               ;BURST 32 = D-TIME 5
        .BYTE   7               ;BURST 36 = D-TIME 0
        .BYTE   6               ;BURST 40 = D-TIME 1
        .BYTE   5               ;BURST 44 = D-TIME 2
        .BYTE   4               ;BURST 48 = D-TIME 3
        .BYTE   1               ;BURST 52 = D-TIME 6
        .BYTE   0               ;BURST 56 =D-TIME 7


;SEQ215

CHTIM:  .BYTE   10      ;CH T0
        .BYTE   4       ;CH T1
        .BYTE   2       ;CH T2
        .BYTE   1               ;CH T3
        .BYTE   10      ;CH T0

CLKTB1: DF.     170     ;CH T0

        BP.     <11>

        DF.     171     ;CH T1

        BP.     <11>

        DF.     172     ;CH T2

        BP.     <11>

        DF.     173     ;CH T3

        BP.     <-11>


;SEQ216

CLKTB2: DF.     170     ;CBUS SEL 0E

        BP.     <12>

        DF.     171     ;CBUS SEL 1E

        BP.     <12>

        DF.     172     ;CBUS SEL 2E

        BP.     <12>

        DF.     173     ;CBUS SEL 3E

        BP.     <12>

        DF.     174     ;CBUS SEL 4E

        BP.     <12>

        DF.     175     ;CBUS SEL 5E

        BP.     <12>

        DF.     176     ;CBUS SEL 6E

        BP.     <12>

        DF.     177     ;CBUS SEL 7E

        BP.     <12>

        DF.     175     ;CH SEL 8A

        BP.     <-13>

CLKTB3: DF.     175     ;

        BP.     <3,2,-1>        ;


        .EVEN



;SEQ220


.SBTTL          CHANNEL MASTER RESET TEST
.REM    %
        **** TEST 2 CHECKS THE STATE OF THE CHANNEL LOGIC AFTER A 
MR RESET + 1 TICK.  THE FOLLOWING SIGNALS ARE UNKNOWN AT THIS TIME
AND ARE THEREFORE MASKED FROM THE SNAPSHOT:

        CCL CH MB SEL 1 & 2 (SIGNALS)
        CCL     ODD WC PAR
        CCL WC GE4
        CCL     WC 0,1,2 & 3 (SIGNALS)
        CCW ALU C2 & C8 OUT (SIGNALS)
        CCW     CHA 14-35
        CCW MEM ADR = 0
        CCW ODD ADR PAR
        CRC ACT CTR OR, 1R & 2R (SIGNALS)
        CRC ACT FLAG ENA
             CT FLAG ENA
        -CRC ACT FLAG REQ ENA
        CRC CH ADR 0C,1C,2C & 3C (SIGNALS)
        CRC CH BUF ADR 0-6
        CRC     DONE IN
        CRC ERR IN
        CRC LAST WORD IN
        CRC LONG WC ERR
        CRC MEM PTR0-PTR3 (SIGNALS)
        -CRC MEM STORE ENA
        CRC     OP CODE 00 & 01 (SIGNALS)
        CRC OVN ERR IN
        CRC PTR DIF = 0
        CRC READY IN
        CRC REVERSE IN
        CRC RH20 ERR IN
        CRC SHORT WC ERR
        CRC STORE IN
%
T.002:  RSTMBX
        MOV     #CHRM1,CMASK    ;SET CHANNEL SNAPSHOT MASK
        MOV     #CMRTAB,R0      ;POINT TO RESET TABLE
        MOV     #2,SCFLAG       ;SET CHANNEL SHANPSHOT FLAG
        JSR     R5,SNAP         ;CHECK RESET
        BCC     1$              ;O.K.
        FAULT   <MR RESET>

1$:     NORMAL


;SEQ221

        ;CHANNEL MSTER RESET DATA

CMRTAB: .BYTE   000,001,000     ;170 (12-19,04-11,00-03)
        .BYTE   203,000,000     ;171
        .BYTE   000,016,000     ;172
        .BYTE   001,000,000     ;173
        .BYTE   000,000,002     ;174
        .BYTE   040,000,007     ;175
        .BYTE   101,000,000     ;176
        .BYTE   002,000,000     ;177
        .EVEN

        

;SEQ222



;SEQ226




;SEQ227

.SBTTL          CHANNEL RESET TEST

.REM    %
        **** TEST 3 CHECKS THE CHANNEL RESET FUNCTION.  SEE SUBROUTINE
        CHRCHK FOR ADDITIONAL INFORMATION.  IT ALSO CHECKS
        THAT NO RH20 IS POLLUTING THE CBUS DURING A CHANNEL SCAN.
%
T.003:  SM                      ;CLEAR RH20S
        CHRCHK
        MOV     #12.,R2         ;SET CHANNEL SCAN COUNT
1$:     INSYNC                  ;****SUBTESTS 1-12
        BRST    4               ;NEXT CHANNEL
        CMP.S   RHIN,0          ;TEST NO RH20 REQUESTS OR INTERRUPTS
        BCC     2$              ;O.K.
        ERRMSG  <CHANNEL >

        FNRD    175             ;GET CURRENT D TIME
        MOV     @.DAT1,R1       ;UPSIDE DOWN & BACKWARDS
        COM     R1              ;FIX POLARITY
        CLR     R0              ;
        .REPT   3               ;NOW INTERCHANGE BITS
        ROR     R1
        ROL     R0
.ENDR
        ERROCS                  ;CHANNEL # TO ERROR STACK
        ERROR   < RH20 ERROR>

2$:     DEC     R2              ;ALL CHANNELS TESTED?
        BGT     1$              ;NO, DO NEXT
        NORMAL  


;SEQ228

RHIN:   DF.     170     ;CHX RESET

        BP.     <13>    ;

        DF.     171     ;CHX START
        
        BP.     <13>    ;

        DF.     172     ;CHX DONE

        BP.     <13>    ;

        DF.     173     ;CHX STORE

        BP.     <13>    ;

        DF.     174     ;CHX CTOM

        BP.     <13>    ;

        DF.     177     ;CH CBUS REQ

        BP.     <-11>   ;


;SEQ229



;SEQ234


;*****NOTE***** - - - FICHE #SEQ234 IS BLANK.


;SEQ235

.SBTTL          INITIAL CCW FETCH ADDRESSING TEST
.REM    %
        TEST 4 SETUP SAVES OR RESTORES THE MEMORY CONFIGUATION AS
REQUIRED.  SCANOUT MASKS ARE THEN APPLIED TO THE MBOX & CHANNELS.
THE MBOX SIGNALS MASKED ARE AS FOLLOWS:
        -A CHANGE, B CHANGE COMING (SIGNALS)
         CAM SEL 1, 2 (SIGNALS)
         CBUS PAR LEFT, RIGHT TE (SIGNALS)
         CSH CCA INVAL CSH
         CSH CCA VAL CORE
         CSH 0,1,2 & 3 ANY VAL (SIGNALS)
        -CSH 0,1,2 & 3 ANY WR (SIGNALS)
         CSH 0,1,2, & 3 DIR PAR ODD (SIGNALS)
         CSH LRU 1 & 2 (SIGNALS)
         CSH PAR BIT
         CSH PAR BIT IN
         CSH PAR BIT A & B (SIGNALS)
         CSH USE ADR 2,3 & 4 (SIGNALS)
        CSH USE IN 0,1,2,3 & 4 (SIGNALS)
         MB PAR BIT IN
         MEM ADR PAR
        -MBOX SBUS ERR
        -MBOX MB PAR ERR
         PAG MB 00-17, 18-35 PAR (SIGNALS)
         NXM T6,7
ADDITIONAL SIGNALS ARE MASKED IF THE MACHINE HAS NO CACHE.  SEE SUB-
ROUTINE SETMSK FOR THE ADDITIONAL LIST.  IF INTERNAL MEMORY IS BEING
USED, MBZ3 SEQUENTIAL RQ IS ALSO MASKED.

THE CHANNEL SIGNALS MASKED FOR THIS TEST ARE AS FOLLOWS:
        CCL CH MB SEL 1&2 (SIGNALS)
        CCL ODD WC PAR
        CCL WC GE4
        CCL WC=0,1,2&3 (SIGNALS)
             -CCW ACT CTR 0,1&2 EN (SIGNALS)
        CCW ALU C2 OUT
        CCW ALU C8 OUT
        CCW CHA 14-35
        CCW MEM ADR PAR
        CRC CH BUF ADR 0-6
%

;SEQ236

I.004:  BR      I.004A          ;BYPASS SET IF LOOP
        MOV     #7,CLKFLG               ;ENABLE CRAM/DRAM PARITY STOP
1$:     RSTMBX
        TST     IMEMCF          ;MEM CONFIGURATION SAVED?
        BNE     5$              ;YES
I.004A=.
        TST     IMEMCF          ;MEMORY CONFIGURATION SAVED?
        BEQ     2$              ;NO, SAVE IT
        JMP     12$             ;BYPASS LOAD MEMORY
2$:     SAVMCN
        BCS     6$              ;MF20 CONFIGURATION ERROR
        INC     IMEMCF          ;SET MEM CONFIG SAVED
3$:     MOV     TCWRT0,R0       ;GET CONTROLLER # FOR ADDRESS 0
        CMP     R0,#4           ;CORE MEMORY?
        BGT     10$             ;NO
        BNE     4$              ;DMA20?
        INC     TRCMEM          ;YES, SET TRACE TO DISABLE BURSTS
4$:     ASL     R0              ;MULTIPLY CONTROLLER # BY 4
        ASL     R0
        MOVB    CONTAB(R0),R1   ;GET INTERLEAVE BITS
        BEQ     6$              ;ERROR IF OFF-LINE
        CMPB    R1,#20          ;ONE-WAY?
        BNE     7$              ;NO
        INC     BANDW           ;YES, SET BANDWIDTH WARNING
5$:     TST     PWRUP           ;JUST POWERED UP?
        BNE     7$              ;NO
        JSR     R5,RSTMCN       ;YES, RESTORE CONFIGURATION
        BCC     7$              ;CONFIGURATION OK?
6$:     ERROR   <FAULTY MEM CONFIG, RUN MEMCON\>

7$:     TST     TRCMEM          ;USING DMA20?
        BEQ     10$             ;NO, CONTINUE
        TST     BANDW           ;ONE-BUS MODE?
        BNE     10$             ;YES, CONTINUE


;SEQ237

        PMSG    <SETTING DMA20 1-BUS MODE\>

        MOV     #4,TSTCON
        SBUSDG  ONEBUS          ;SET DMA20 1-BUS MODE
        TST     NIPASS          ;INITIAL PASS?
        BNE     10$             ;NO, BYPASS SWITCH MSG
        TST     CLKRAT          ;CLOCK RATE 0?
        BEQ     10$             ;YES, BYPASS SWITCH MSG
        PFORCE                  ;FORCE TYPEOUTS
8$:     PMSG    <MEM SWITCHES OK? _>

        PNORML                  ;NOT FORCING TYPEOUTS
        TTILIN                  ;GET REPLY
        BCC     9$              ;GOT ONE
        PMSG    < NO REPLY, REST ABORTED\>

        ERREOP                  ;RETURN TO KLDCP
9$:     TTIYES                  ;YES?
        BPL     10$             ;YEP
        PMSG    <H SWITCH.HLP>

        MOV     #-1,R0          ;COMMAND IN OUTPUT BUFFER
        PRGCMD                  ;PRINT HELP FILE
        BR      8$              ;ASK AGAIN
10$:    MOV     #-1,NIPASS      ;SET NOT INITIAL PASS
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        MOV     #EPTBAS,R1      ;POINT TO EPT BASE
        MOV     #37,R0          ;NUMBER OF LOCATIONS TO CLEAR
        D10ZRO                  ;ZERO EPT TO EPT+36
        SETMSK  MASKM
        TST     TRCMEM          ;USING EXTERNAL MEMORY?
        BNE     11$             ;YES
        BISB    #BIT1,M2040     ;NO,SET MASK MBZ3 SEQUENTIAL RQ
11$:    MOV     #CHRM2,CMASK    ;SET CHANNEL SCANOUT MASK
        MOV     #EPT/1000,EBRFLG        ;SET EBR FLAG FOR PAGE
        JSR     R5,SETEBR               ;SET EBR
        MOV     #1,CHFLAG       ;RSTMBX DOES 34 EXTRA TICKS
        MOV     #1,PMAFLG       ;SET FORCE PMA TO ERG
12$:    RSTMBX
        RTS     PC              ;RETURN


;SEQ238

        ;MBOX SCANOUT MASK TABLE

MASKM:  .BYTE   0       ;UNUSED
        .BYTE   201             ;163  27-34
        .WORD   005003  ;160  20-35
        .BYTE   002     ;160  12-19
        .BYTE   1       ;164  27-34
        .WORD   005003  ;161  20-35
        .BYTE   016     ;161  12-19
        .BYTE   303     ;165  27-34
        .WORD   007013  ;162  20-35
M2040:  .BYTE   016     ;162  12-19
        .BYTE   1       ;166  27-34
        .WORD   140000  ;170  20-35
        .WORD   140000  ;171  20-35
        .WORD   142000  ;172  20-35
        .WORD   142000  ;173  20-35
        .WORD   142020  ;174  20-35
        .WORD   142020  ;175  20-35
        .WORD   142010  ;176  20-35
        .WORD   142000  ;177  20-35

IMEMCF: .WORD   0       ;MEMORY SAVED FLAG
BANDW:  .WORD   0       ;ONE-WAY INTERLEAVE BANDWIDTH WARNING
EPTBAS: WD22    \EPT    ;EPT BASE ADDRESS

ONEBUS: WD36    0120,4000,0000


        .EVEN


;SEQ239

.REM    %
        TEST 4CHECKS THE ABILITY TO GENERATE CHAN EPT REFERENCES
FOR FETCHING INITIAL COMMAND WORDS FOR EACH CHANNEL.  THE BASE PAGE
USED IS DETERMINED AT ASSEMBLY TIME.
%
T.004:  CHSTRT
1$:     INSYNC                  ;****SUBTEST X1
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS ,ICCWF           ;STAT/RESET
        BCC     2$              ;TIMING O.K.
        CHTYP   
        FAULT   <IMPROPER D-TIME>

2$:     INSYNC                  ;****SUBTEST X2
                
        MOV     R4,R2           ;GET CHANNEL #
        ASL     R2              ;MULTIPLY IT BY 2
        BNE     3$              ;NOT CHANNEL 0
        MCSCAN   T4CH0,<30>              ;SCAN @ CORE RD IN PROG
        BCC     6$              ;CHANNEL O.K.

        BR      5$              ;BAD
3$:     MOV     T4TAB-2(R2),4$  ;GET SNAPSHOT TABLE POINTER
        JSR     R5,CSCAN        ;SCAN CHANNELS
4$:     .WORD   0               ;TABLE POINTER GOES HERE
        .WORD   30              ;@ CORE RD IN PROG CLK CNT
        BCC     6$              ;O.K.
5$:     CFAULT  <INITIAL CCW FETCH>


;SEQ240

6$:     INSYNC                  ;***SUBTEST X3
        MOV     R4,R3           ;PUT ADDRESS IN TABLE
        SL      R3,2


        MOVB    R3,ICCWTB+1
        CMPMEM  ICCWTB          ;TEST MEM REF O.K.
        BCC     7$              ;O.K.
        CFAULT  <PMA FOR CHAN EPT>

7$:     DFXCTT                  ;FINISH FETCH
                STRCLK          ;
        CHRCHK
        RSTCHK
        NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL

ICCWF:  CBUS    <ST,RST>


ICCWTB: MEMTAB  \EPT,<RD,RQ0>

        .EVEN


;SEQ241

T4TAB:          T4CH1           ;1
                T4CH2           ;2
                T4CH3           ;3
                T4CH4           ;4
                T4CH5           ;5
                T4CH6           ;6
                T4CH7           ;7


T4CH0:  .WORD   024004          ;B D
        .WORD   032024          ;CPT
        .WORD   024034          ;B \
        .WORD   062700          ;FW@
        .WORD   036021          ;CpQ
        .WORD   140024          ;L@T
        .WORD   141020          ;LHP
        .WORD   026722          ;BwR
        .WORD   035522          ;CmR
        .WORD   035230          ;CjX
        .WORD   035322          ;CkR
        .WORD   035654          ;Cnl
        .WORD   025355          ;Bkm
        .WORD   035365          ;Cku
        .WORD   031305          ;CKE
        .WORD   020400          ;BD@
        .WORD   005406          ; lF
        .WORD   000100          ; A@
        .WORD   007002          ; xB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   044002          ;D B
        .WORD   001600          ; N@
        .WORD   000203          ; BC
        .WORD   000000          ;   
        .WORD   007600          ; >@
T4CH1:  .WORD   020404          ;BDD
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   006002          ; pB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   104002          ;H B
        .WORD   002600          ; V@
        .WORD   000003          ;  C
        .WORD   000000          ;   
        .WORD   007600          ; >@
T4CH2:  .WORD   020604          ;BFD
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   005002          ; hB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   044002          ;D*B
        .WORD   000600          ; F@
        .WORD   000003          ;  C
        .WORD   000000          ;   
        .WORD   007600          ; >@
T4CH3:  .WORD   020404          ;BDD
        .WORD   105402          ;HlB
        .WORD   000100          ; A@
        .WORD   004002          ;  B
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   044002          ;D B
        .WORD   003200          ; Z@
        .WORD   000003          ;  C
        .WORD   000000          ;   
        .WORD   007600          ; >@
T4CH4:  .WORD   020404          ;BDD
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   003202          ; ZB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   004002          ;  B
        .WORD   000200          ; B@
        .WORD   000003          ;  C
        .WORD   000000          ;   
        .WORD   007600          ; >@
T4CH5:  .WORD   020404          ;BDD
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   002002          ; PB
        .WORD   100400          ;HD@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   004002          ;  B
        .WORD   003600          ; ^@
        .WORD   000003          ;  C
        .WORD   000000          ;   
        .WORD   007600          ; >@
T4CH6:  .WORD   020404          ;BDD
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   001202          ; JB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   044002          ;D B
        .WORD   001200          ; J@
        .WORD   000003          ;  C
        .WORD   000000          ;   
        .WORD   007600          ; >@
T4CH7:  .WORD   020404          ;BDD
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   000002          ;  B
        .WORD   100400          ;HD@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   044002          ;D B
        .WORD   003600          ; ^@
        .WORD   000003          ;  C
        .WORD   000000          ;   
        .WORD   007600          ; >@
;SEQ242



;SEQ248



;SEQ249

.SBTTL          HALT FETCH TESTS
.REM    %
        TEST 5 SETUP FETCHES A HALT
%
I.005:  RSTMBX
        CLR     R0              ;
        SETEPT  ,ZERO.. ;SET ZERO TO CHANNEL 0 EPT
        CLR     R0              ;CHANNEL 0
        SIMBUS  ,ICCWF  ;START/RESET
        DFXCTT                  ;START CLOCK
                STRCLK          ;
        RSTMBX
        RTS     PC              ;RETURN

.REM    %
        **** TEST 5 CHECKS THE ABILITY TO FETCH A HALT WITH AN
ADDRESS FIELD OF 17777777.
%
T.005:  CLR     R0              ;CHANNEL 0
        SETEPT  ,CCWF1S
        RSTMBX
        CLR     R0              ;CHANNEL 0
        SIMBUS  ,ICCWF          ;START/RESET
        BCC     1$              ;O.K.
        JMP     CBUSTO          ;CBUS TIMEOUT
1$:     INSYNC                  ; ****SUBTEST 1
        STPCON  <30>            ;FETCH CCW
        STOPCH
        FIND    <174,33,0>      ;LOOK FOR -MB0 HOLD
        BCC     2$              ;O.K.
        STARCH                  ;DON'T LEAVE CHANNEL TIMING HUNG
        FAULT   <MBOX LOAD MB FOR CCW FETCH>

;SEQ250

2$:     CHSYNC
        INSYNC                  ;****SUBTEST 2
        MCSCAN  T5TAB1,<3>              ;SCAN @ CCL CH TEST MB PAR CLK CNT
        BCS     3$              ;BAD
        INSYNC                  ;****SUBTEST 3
        MCSCAN  T5TAB2,<7>              ;SCAN @ -CORE BUSY CLK CNT
        BCC     4$              ;O.K.
3$:     FAULT   <CCW FETCH>

4$:     INSYNC                  ;****SUBTEST 4
        JSR     PC,CCWCOM       ;TEST ADDRESS FETCHED
        NORSKP


;SEQ251

.REM    %
        LOCAL SUBROUTINE FOR TESTS 5, 6 & 7.
%
CCWCOM: XQT     GETBAS          ;CHAN EPT BASE CONTENTS TO AC17
        BCC     1$              ;EBOX READ O.K.
        FAULT   <MBOX HUNG ON FETCH>

1$:     READ17
        CCWRD
        CMP22   ADRL,EXAREA     ;COMPARE THEM
        BCC     2$              ;O.K.
        FAULT   <CCW ADDRESS FETCH>

2$:     RTS     PC              ;RETURN

T5TAB1: .WORD   024004          ;B D
        .WORD   032024          ;CPT
        .WORD   024034          ;B \
        .WORD   062700          ;FW@
        .WORD   034021          ;C Q
        .WORD   000004          ;  D
        .WORD   003020          ; XP
        .WORD   026722          ;BwR
        .WORD   035522          ;CmR
        .WORD   035230          ;CjX
        .WORD   035322          ;CkR
        .WORD   035644          ;Cnd
        .WORD   025345          ;Bke
        .WORD   035365          ;Cku
        .WORD   031305          ;CKE
        .WORD   060400          ;FD@
        .WORD   005006          ; hF
        .WORD   000000          ;   
        .WORD   007002          ; xB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000002          ;  B
        .WORD   044002          ;D B
        .WORD   002600          ; V@
        .WORD   000003          ;  C
        .WORD   100000          ;H@@
        .WORD   007600          ; >@
T5TAB2: .WORD   024004          ;B D
        .WORD   012024          ;APT
        .WORD   034014          ;C L
        .WORD   062700          ;FW@
        .WORD   034021          ;C Q
        .WORD   000004          ;  D
        .WORD   003021          ; XQ
        .WORD   026722          ;BwR
        .WORD   035722          ;CoR
        .WORD   035230          ;CjX
        .WORD   035322          ;CkR
        .WORD   035644          ;Cnd
        .WORD   025345          ;Bke
        .WORD   035365          ;Cku
        .WORD   031305          ;CKE
        .WORD   000200          ; B@
        .WORD   001406          ; LF
        .WORD   000000          ;   
        .WORD   007000          ; x@
        .WORD   000400          ; D@
        .WORD   000401          ; DA
        .WORD   000000          ;   
        .WORD   000002          ;  B
        .WORD   000600          ; F@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@

CBUSTO: ERROR   <CBUS SELECT ERROR>

CCWF1S: CCW     CHLT,17777777


GETBAS: I10     MOVE,AC17,,\EPT

ADRBAS: WD22    \EPT

        .EVEN


;SEQ252



;SEQ259



;SEQ260

.REM    %
        TEST 6 SETUP FETCHES A HALT WITH A MAXIMUM ADDRESS FIELD.
%
I.006:  CLR     R0              ;
        SETEPT  ,CCWF1S          ;
        CLR     R0              ;CHANNERL 0
        SIMBUS  ,ICCWF          ;START/RESET
        DFXCTT                  ;DO CCW FETCH
                STRCLK          ;
        RSTMBX          
        RTS     PC              ;RETURN


;SEQ261

.REM    %
        **** TEST 6 CHECKS THE CCW ADDRESS, CCW MEM ADR=0 & CCW ODD
ADR PAR FOR A CCW OF ZERO.
%
T.006:  RSTMBX
        CLR     R0              ;
        SETEPT  ,ZERO..         ;
        RSTMBX
        SYNC
        CLR     R0              ;CHANNEL 0
        SIMBUS  ,ICCWF          ;START/RESET
        BCC     1$              ;O.K.
        JMP     CBUSTO          ;CBUS TIMEOUT
1$:     INC     R5              ;***SUBTEST 1
        JSR     PC,CCWCOM       ;TEST ADDRESS FETCHED
        INC     R5              ;****SUBTEST 2
        TENBIT  171,9           ;TEST CCW MEM ADR = 0

        BEQ     2$              ;ERROR
        TENBIT  177,10          ;TEST CCW ODD ADR PAR


        BEQ     3$              ;O.K.
2$:     BITERR
        FAULT
3$:     NORMAL


;SEQ262



;SEQ264



;SEQ265

.REM    %
        TEST 7 SLIDES A ONE & A ZERO THROUGH THE INITIAL CCW
FETCH ADDRESS.  THE SLIDING ONE IS USED TO TEST CCW MWEM ADR = 0
& CCW ODD ADR PAR GENERTION AS WELL AS THE CCW ADDRESS.
%
T.007:  MOV     #ADRML1,R0      ;SET ADDRESS AREA TO -2
        JSR     PC,PATINI       ;
1$:     JSR     PC,CHKPAT       ;CHECK PATTERN
        JSR     PC,SLDPAT       ;SLIDE A 0
        BNE     1$              ;TEST NEXT PATTERN
        MOV     #ADR1,R0        ;SET ADDRESS  AREA TO 1
        JSR     PC,PATINI       ;INITIALIZE PATTERN
2$:     JSR     PC,CHKPAT       ;CHECK THE PATTERN
        TENBIT  171,9           ;TEST CCW MEM ADR = 0


        BEQ     3$              ;NOT ZERO, O.K.
        BR      4$              ;BAD
3$:     TENBIT  177,10          ;TESTCCW ODD ADR PAR


        BNE     5$              ;ODD, O.K.
4$:     BITERR
        FAULT
5$:     JSR     PC,SLDPAT       ;SLIDE A ONE
        BNE     2$              ;TEST NEXT PATTERN
        NORMAL

ADR1:   WD22    1

        .EVEN
ADRML1: WD22    17777776

        .EVEN


;SEQ266

PATINI: MOV     (R0)+,R3        ;GET PATTERN LOWER
        MOV     R3,ADRPAT       ;SAVE IT
        MOVB    (R0),ADRPAT+2   ;SAVE UPPER
        MOV     #22.,R4         ;COUNT
        RTS     PC              ;INITIALIZATION DONE



CHKPAT: RSTMBX
        CLR     R0              ;CHANNEL 0
        SETEPT  ,ADRPAT         ;PATTERN TO EPT
        CLR     R0              ;
        SIMBUS  ,ICCWF          ;START/RESET CH0
        BCC     1$              ;
        JMP     CBUSTO          ;CBUS SEL TIMEOUT
1$:     INSYNC
        JSR     PC,CCWCOM       ;COMPARE TO EXPECTED
        RTS     PC              ;RETURN


SLDPAT: TST     R3              ;CHECK SIGN BIT
        BPL     1$              ;POS
        SEC                     ;NEG
1$:     ROL     ADRPAT          ;SLIDE PATTERN
        ROL     ADRPAT+2        ;
        BIC     #177700,ADRPAT+2
        DEC     R4              ;DECREMENT COUNT
        RTS     PC              ;RETURN


ADRPAT: .WORD   0,0,0           ;PATTERN AREA


;SEQ267



;SEQ269




;SEQ270

.REM    %
        TEST 8 SETUP FETCHES A HALT WITH A MAXIMUM ADDRESS AND WORD COUNT.
%
I.008:  CLR     R0              ;
        SETEPT  ,MAXHLT         ;
        CLR     R0              ;CHANNEL 0
        SIMBUS  ,ICCWF          ;START/RESET
        DFXCTT                  ;DO CCW FETCH
                STRCLK          ;
        RSTMBX
        RTS     PC              ;RETURN

MAXHLT: CCW     CHLT,17777777,3777


        .EVEN

.REM    %
        ****TEST 8 CHECKS CCL WC=0, 1,2,3, GE4 & ODD WC PAR BY
COUNTING UP A HALT WITH WORD COUNTS OF 0-4 AND THEN A SLIDING ONE
FOR WORD COUNTS GREATER THAN 4.
%
T.008:  CLRB    WDPAT+4         ;SET INITIAL WC = 0
        CLR     WDPAT+2          ;
        CLR     R2              ;CLEAR INDEX
1$:     INSYNC
        RSTMBX
        CLR     R0              ;HALT TO CHANNEL O EPT
        SETEPT  ,WDPAT          ;
        CLR     R0              ;CHANNEL 0
        SIMBUS  ,ICCWF          ;START/RESET
        FIND    <172,16,1>      ;GET TO CCL CCWF T2
        MOVB    WDVALU(R2),R1   ;GET VALUE TO CHECK
        CMP.S   CCLWD,R1        ;CHECK WORD COUNT LOGIC
        BCC     2$              ;PATTERN O.K.


;SEQ271


ERRMSG  <CCW = >

        MOV     #WDPAT,R0       ;PATTERN TO ERROR STACK
        ERRCOM  PNT36
        FAULT   <WORD COUNT FOR INITIAL CCW FETCH>

2$:     CMP     R2,#4           ;0,1,2,3 & 4 CHECKED?
        BGE     3$              ;YES, DO THE SLIDE
        INC     R2              ;NO, NEXT VALUE
        ADD     #100,WDPAT+2    ;
        BR      1$              ;LOOP AGAIN
3$:     ASLB    WDPAT+3         ;SLIDE THE BIT
        ROLB    WDPAT+4         ;
        CMPB    WDPAT+4,#2      ;DONE
        BLT     1$              ;NO, LOOP AGAIN
        RSTMBX
        NORMAL

        ;TABLE OF VALUES TO CHECK

WDVALU: .BYTE   0                       ;WC=0
        .BYTE   61              ;WC=1
        .BYTE   62              ;WC=2
        .BYTE   24              ;WC=3
        .BYTE   70              ;WC GE4

CCLWD:  DF.     170             ;CCL ODD WC PAR, WC=0, WC GE 4

        BP.     <16,19,18>


        DF.     176             ;CCL WD=3

        BP.     <5>             ;


        DF.     177             ;CCL WC=2,. 1

        BP.     <9,-8>          ;

        .EVEN

WDPAT:  .WORD   0,0,0


;SEQ272



;SEQ273



;SEQ274

.SBTTL          MBOX ERROR STATUS TESTS
.REM    %
        TEST 9 SETUP FETCHES AN INITIAL COMMAND WORD OF ZERO FOR EACH
CHANNEL.  BAD PARITY WORDS OF 17777777 ARE THEN PUT IN THE EPT AREA.
%
I.009:  BR      3$              ;BYPASS INIT IF LOOP
        RSTMBX
        MOV     #7,R4           ;CHANNEL #
        
1$:     MOV     R4,R0           ;CURRENT CHANNEL #
        SETEPT  ,ZERO..         ;CLEAR CHANNEL EPT
        MOV     R4,R0           ;CURRENT CHANNEL #
        SIMBUS  ,ICCWF          ;FETCH A HALT
        DFXCTT                  ;
                STRCLK          ;
        DEC     R4              ;NEXT CHANNEL
        BGE     1$              ;LOOP UNTIL DONE
        RSTMBX  
        XQT     DATPAR          ;WRITE EVEN DATA PARITY
        MOV     #7,R4           ;CHANNEL #
2$:     MOV     R4,R0           ;CURRENT CHANNEL #
        SETEPT  ,CCWF1S         ;CHLT,17777777 TO EPT
        DEC     R4              ;NEXT CHANNEL
        BGE     2$              ;LOOP UNTIL DONE
        JSR     PC,CLRERR       ;CLEAR MEMORY ERRORS
3$:     RSTMBX
        RTS     PC              ;RETURN


;SEQ275

.REM    %
        **** TEST 9 CHECKS SEQUENCING & ADDRESSING FOR STORE STATUS.
PROPER STATUS FOR AN MB PAR ERR WITH A CLP = 17777777 IS ALSO
TESTED FOR ALL CHANNELS.
%
T.009:  CHSTRT
1$:     RSTMBX
        INSYNC                  ;SUBTEST X1
        MOV     R4,R0           ;CHANNEL UNDER TEST
        SIMBUS  ,ICCWF           ;START/RESET

        FIND    <165,32,1>      ;GET TO CORE RD IN PROG
        STOPCH
        FIND    <174,33,0>      ;GET TO -MB0 HOLD IN
        CHSYNC
        FIND    <171,19,0>      ;GET TO CCW CH TEST MB PAR
        BCC     2$              ;O.K.
        FAULT   <NO CCW CH TEST MB PAR>

2$:     INSYNC                  ;****SUBTEST X2
        MOV     R4,R2           ;GET CHANNEL #
        ASL     R2              ;MAKE INTO WORD INDEX
        BNE     3$              ;NOT CHANNEL 0
        MCSCAN  T92CH0,<30>             ;SCAN @ -MB1 HOLD IN CLK CNT
        BCC     5$              ;CHANNEL 0 O.K.
        BR      8$              ;BAD
3$:     MOV     T9TAB2-2(R2),4$ ;GET SNAPSHOT POINTER
        JSR     R5,CSCAN        ;SCAN CHANNELS
4$:     .WORD   0               ;TABLE POINTER GOES HERE
        .WORD   30              ;SCAN @ -MB1 HOLD IN CLK CNT
        BCS     8$              ;BAD


;SEQ276

5$:     INSYNC          ;****SUBTEST X3
        MSCAN   T9MTAB,<1>              ;SCAN @ SBUS ADR HOLD CLK CNT
        BCS     8$              ;BAD
        MOV     R4,R3           ;PUT ADDRESS IN TABLE
        SL      R3,2            ;


        INC     R3              ;
        MOVB    R3,STRS1+1      ;
        CMPMEM  STRS1           ;TEST IF MEM REF O.K.
        BCS     8$              ;BAD
        INSYNC                  ;****SUBTEST 4 ONLY
        TST     R2              ;CHANNEL 0?
        BNE     6$              ;NO
        MCSCAN  T94CH0,<3>              ;SCAN @ -MB2 HOLD IN CLK CNT
        BCS     8$              ;CHANNEL 0 / MBOX ERROR
        INSYNC                  ;*****SUBTEST 5 ONLY
        MCSCAN  T95CH0,<1>              ;SCAN @ -CCL CSH CHAN CY CLK CNT
        BCC     9$              ;O.K.
        BR      8$              ;CHANNEL 0 /MBOX ERROR
6$:     INSYNC                  ;****SUBTEST X5
        MOV     T9TABS-2(R2),7$ ;GET SNAPSHOT POINTER
        JSR     R5,CSCAN        ;SCAN CHANNELS
7$:     .WORD   0               ;TABLE POINTER GOES HERE
        .WORD   4               ;SCAN @ -CCL CSH CHAN CYC CLK CNT
        BCC     9$              ;O.K.
8$:     CFAULT  <BAD STORE STATUS>


;SEQ277

9$:     INSYNC          ;****SUBTEST X6
        STACOM  PARST           ;TEST PROPER STATUS
        BCC     10$             ;O.K.
        FAULT   <EPT FETCH WITH EVEN PARITY>

10$:    JSR     PC,CLRERR       ;CLEAR MEMORY ERRORS
        NEXTCH
        BEQ     11$             ;DONE?
        JMP     1$              ;NO, LOOP AGAIN
11$:    NORMAL
DATPAR: IO10    CONO PI,,200000

PARST:  WD36    7000,1777,7777

CL05:   WD36    0100,0000,0000
STRS1:  MEMTAB  \EPT,<WR,RQ1,RQ2>

        .EVEN


;SEQ278


T9TAB2:         T92CH1  ;1
                T92CH2          ;2
                T92CH3          ;3
                T92CH4          ;4
                T92CH5          ;5
                T92CH6          ;6
                T92CH7          ;7

T92CH0: .WORD   024004          ;B D
        .WORD   032024          ;CPT
        .WORD   024034          ;B \
        .WORD   172700          ;OW@
        .WORD   034021          ;C Q
        .WORD   100000          ;H@@
        .WORD   002021          ; PQ
        .WORD   026733          ;Bw[
        .WORD   035723          ;CoS
        .WORD   034670          ;Cfx
        .WORD   035302          ;CkB
        .WORD   035745          ;Coe
        .WORD   024343          ;Bcc
        .WORD   035345          ;Cke
        .WORD   031725          ;COU
        .WORD   010400          ;AD@
        .WORD   005406          ; lF
        .WORD   000060          ;  p
        .WORD   007002          ; xB
        .WORD   000401          ; DA
        .WORD   000400          ; D@
        .WORD   000003          ;  C
        .WORD   100402          ;HDB
        .WORD   002600          ; V@
        .WORD   000002          ;  B
        .WORD   000000          ;   
        .WORD   007600          ; >@
T92CH1: .WORD   010604          ;AFD
        .WORD   005402          ; lB
        .WORD   000060          ;  p
        .WORD   006002          ; pB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000003          ;  C
        .WORD   000402          ; DB
        .WORD   000600          ; F@
        .WORD   000002          ;  B
        .WORD   000000          ;   
        .WORD   007600          ; >@
T92CH2: .WORD   010404          ;ADD
        .WORD   105402          ;HlB
        .WORD   000060          ;  p
        .WORD   005002          ; hB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000003          ;  C
        .WORD   000402          ; DB
        .WORD   002200          ; R@
        .WORD   000002          ;  B
        .WORD   000000          ;   
        .WORD   007600          ; >@
T92CH3: .WORD   010404          ;ADD
        .WORD   005402          ; lB
        .WORD   000060          ;  p
        .WORD   004202          ; bB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000003          ;  C
        .WORD   000402          ; DB
        .WORD   000200          ; B@
        .WORD   000002          ;  B
        .WORD   000000          ;   
        .WORD   007600          ; >@
T92CH4: .WORD   010404          ;ADD
        .WORD   005402          ; lB
        .WORD   000060          ;  p
        .WORD   003002          ; XB
        .WORD   100400          ;HD@
        .WORD   003400          ; \@
        .WORD   000003          ;  C
        .WORD   040402          ;DDB
        .WORD   003600          ; ^@
        .WORD   000002          ;  B
        .WORD   000000          ;   
        .WORD   007600          ; >@
T92CH5: .WORD   010404          ;ADD
        .WORD   005402          ; lB
        .WORD   000060          ;  p
        .WORD   002002          ; PB
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000003          ;  C
        .WORD   040402          ;DDB
        .WORD   001600          ; N@
        .WORD   000202          ; BB
        .WORD   000000          ;   
        .WORD   007600          ; >@
T92CH6: .WORD   010404          ;ADD
        .WORD   005402          ; lB
        .WORD   000060          ;  p
        .WORD   001002          ; HB
        .WORD   100400          ;HD@
        .WORD   003400          ; \@
        .WORD   000003          ;  C
        .WORD   000402          ; DB
        .WORD   003600          ; ^@
        .WORD   000002          ;  B
        .WORD   000000          ;   
        .WORD   007600          ; >@
T92CH7: .WORD   010404          ;ADD
        .WORD   005402          ; lB
        .WORD   000060          ;  p
        .WORD   000002          ;  B
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000203          ; BC
        .WORD   000402          ; DB
        .WORD   001600          ; N@
        .WORD   000002          ;  B
        .WORD   000000          ;   
        .WORD   007600          ; >@
T9MTAB: .WORD   024000          ;B @
        .WORD   032024          ;CPT
        .WORD   035034          ;Ch\
        .WORD   172704          ;OWD
        .WORD   034021          ;C Q
        .WORD   140020          ;L@P
        .WORD   030021          ;C@Q
        .WORD   026733          ;Bw[
        .WORD   035767          ;Cow
        .WORD   035630          ;CnX
        .WORD   035316          ;CkN
        .WORD   035645          ;Cne
        .WORD   025347          ;Bkg
        .WORD   035345          ;Cke
        .WORD   031335          ;CK]
T94CH0: .WORD   024004          ;B D
        .WORD   032024          ;CPT
        .WORD   025034          ;Bh\
        .WORD   162700          ;NW@
        .WORD   034021          ;C Q
        .WORD   140024          ;L@T
        .WORD   030021          ;C@Q
        .WORD   026722          ;BwR
        .WORD   035766          ;Cov
        .WORD   035230          ;CjX
        .WORD   035336          ;Ck^
        .WORD   035644          ;Cnd
        .WORD   025345          ;Bke
        .WORD   035341          ;Cka
        .WORD   031335          ;CK]
        .WORD   010600          ;AF@
        .WORD   005406          ; lF
        .WORD   000060          ;  p
        .WORD   007002          ; xB
        .WORD   000401          ; DA
        .WORD   000400          ; D@
        .WORD   000003          ;  C
        .WORD   040402          ;DDB
        .WORD   000600          ; F@
        .WORD   000011          ;  I
        .WORD   000000          ;   
        .WORD   007600          ; >@
;SEQ279

T9TABS:         T95CH1          ;1
                T95CH2          ;2
                T95CH3          ;3
                T95CH4          ;4
                T95CH5          ;5
                T95CH6          ;6
                T95CH7          ;7

T95CH0: .WORD   024000          ;B @
        .WORD   132024          ;KPT
        .WORD   035034          ;Ch\
        .WORD   162700          ;NW@
        .WORD   034021          ;C Q
        .WORD   040024          ;D@T
        .WORD   030021          ;C@Q
        .WORD   026722          ;BwR
        .WORD   035726          ;CoV
        .WORD   035230          ;CjX
        .WORD   035336          ;Ck^
        .WORD   035644          ;Cnd
        .WORD   025345          ;Bke
        .WORD   035345          ;Cke
        .WORD   031335          ;CK]
        .WORD   000200          ; B@
        .WORD   001406          ; LF
        .WORD   000061          ;  q
        .WORD   007000          ; x@
        .WORD   000401          ; DA
        .WORD   000400          ; D@
        .WORD   000000          ;   
        .WORD   040002          ;D@B
        .WORD   000600          ; F@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T95CH1: .WORD   000004          ;  D
        .WORD   101402          ;HLB
        .WORD   000061          ;  q
        .WORD   007000          ; x@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   000002          ;  B
        .WORD   002200          ; R@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T95CH2: .WORD   000004          ;  D
        .WORD   001402          ; LB
        .WORD   000061          ;  q
        .WORD   007200          ; z@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   000002          ;  B
        .WORD   000200          ; B@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T95CH3: .WORD   000004          ;  D
        .WORD   001402          ; LB
        .WORD   000061          ;  q
        .WORD   007000          ; x@
        .WORD   100400          ;HD@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   000002          ;  B
        .WORD   003600          ; ^@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T95CH4: .WORD   000004          ;  D
        .WORD   001402          ; LB
        .WORD   000061          ;  q
        .WORD   007000          ; x@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   040002          ;D@B
        .WORD   001600          ; N@
        .WORD   000201          ; BA
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T95CH5: .WORD   000004          ;  D
        .WORD   001402          ; LB
        .WORD   000061          ;  q
        .WORD   007000          ;x@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   040002          ;D@B
        .WORD   002600          ; V@
        .WORD   000001          ;  A
        .WORD   101000          ;HH@
        .WORD   007600          ; >@
T95CH6: .WORD   000004          ;  D
        .WORD   001402          ; LB
        .WORD   000061          ;  q
        .WORD   007000          ; x@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000200          ; B@
        .WORD   000002          ;  B
        .WORD   001600          ; N@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T95CH7: .WORD   000004          ;  D
        .WORD   001402          ; LB
        .WORD   000061          ;  q
        .WORD   007000          ; x@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   100002          ;H@B
        .WORD   002600          ; V@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@

;SEQ280


;SEQ286



;SEQ287

.REM    %
        TEST 10 SETUP FORCES A STORE STATUS OF ALL BINARY ONES
FOR STATUS WORD 2 (ALL CHANNELS)
%
I.010:  MOV     #7,R4           ;CHANNEL #
        
1$:     JSR     PC,CCWMAX               ;CONDITION CCW FOR CHAN
        DFXCTT                  ;SET RUN TO FINISH STORE
                STRCLK          ;
        TWAIT   1
        DEC     R4              ;NEXT CHANNEL
        BGE     1$              ;LOOP UNTIL DONE
        JSR     PC,CLRERR       ;CLEAR MEMORY ERRORS
        RTS     PC              ;RETURN
.REM    %
        ***** TEST 10 CHECKS STORING OF STATUS WORD 2 WITH
DATA OF 400000 000000.  ALL CHANNELS ARE TESTED.
%
T.010:  CHSTRT
1$:     INSYNC                  ;****SUBTEST X1
        JSR     PC,CCWMIN               ;SETUP FOR ERROR CONDITION
        MEMRD
        MEMWR
        BCC     2$              ;STORE COMPLETED
        CHTYP
        FAULT   <NO CCL MEM PAR ERR>

2$:     INSYNC                  ;*****SUBTEST X2
        STAT2   MINDAT
        BCC     3$              ;O.K.
        FAULT
3$:     JSR     PC,CCWMAX       ;RECONDITION CHANNEL
        DFXCTT                  ;
                STRCLK          ;
        TWAIT   1                    
          JSR   PC,CLRERR       ;CLEAR MEMORY ERRORS
        NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL


;SEQ288

.REM    %
        LOCAL SUBROUTINES FOR TESTS 10 & 11
%

;SETUP FOR STORE STATUS WORD 2 = 400000 000000

CCWMIN: RSTMBX
        XQT     DATPAR          ;FORCE WRITE BAD DATA PARITY
        MOV     R4,R0           ;GET CURRENT CHANNEL #
        SETEPT  ,MINDAT         ;DATA IS 400000 000000
        RSTMBX
        MOV     R4,R0           ;
        SIMBUS  ,ICCWF          ;START/RESET
        RTS     PC              ;RETURN


;SETUP FOR STORE STATUS WORD 2 = 777777 777777

CCWMAX: RSTMBX
          XQT   DATPAR  ;FORCE WRITE BAD DATA PARITY
        MOV     R4,R0           ;GET CURRENT CHANNEL #
        SETEPT  ,SEVENS         ;DATA IS 777777 777777
        RSTMBX
        MOV     R4,R0           ;
        SIMBUS  ,RDSTRT ;START/RESET/CTOM
        RTS     PC              ;RETURN

SEVENS: WD36    7777,7777,7777

MINDAT: CCW     CDTA    0

ESTAT2: I10     MOVE,AC17,,\EPT ;REAL ADDRESS INSERTED

        .EVEN


;SEQ289



;SEQ290



;SEQ291



;SEQ292

.REM    %
        TEST 11 SETUP FORCES A STORE STATUS OF 400000 000000
FOR STATUS WORD 2 (ALL CHANNELS)
%
I.011:  MOV     #7,R4           ;CHANNEL #
        
1$:     JSR     PC,CCWMIN       ;CONDITION CCW FOR CHAN
        DFXCTT                  ;COMPLETE STORE
                STRCLK          ;
        TWAIT   1
        DEC     R4              ;NEXT CHANNEL
        BGE     1$              ;LOOP UNTIL DONE
        RTS     PC              ;RETURN

.REM    %
        **** TEST 11 CHECKS STORING OF STATUS WORD 2 WITH
DATA OF ALL BINARY 1S.  ALL CHANNELS ARE TESTED.
%
T.011:  CHSTRT
1$:     INSYNC
        JSR     PC,CCWMAX       ;SETUP FOR ERROR CONDITION
        MEMRD
        MEMWR
        STAT2   SEVENS
        BCC     2$              ;O.K.
        FAULT
2$:     JSR     PC,CCWMAX       ;RECONDITION CCW
        DFXCTT                  ;
                STRCLK          ;
        TWAIT   1
        NEXTCH
        BNE     1$             ;LOOP UNTIL DONE
        NORMAL


;SEQ293



;SEQ294




;SEQ295

.REM    %
        TEST 12 SETUP FORCES A STORE STATUS OF 700017 777777 FOR ALL CHANNELS.
%
I.012:  RSTMBX
        XQT     DATPAR          ;WRITE EVEN PARITY
        MOV     #7,R4           ;CHANNEL #
1$:     MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,CCWF1S         ;17777777 TO CHAN EPT
        MOV     R4,R0           ;
        SIMBUS  ,ICCWF          ;START/RESET CURRENT CHANNEL
        DFXCTT                  ;FINISH IT UP
                STRCLK          ;
        DEC     R4              ;NEXT CHANNEL
        BGE     1$              ;LOOP UNTIL DONE
        JSR     PC,CLRERR       ;CLEAR MEMORY ERRORS
        RSTMBX
                
        RTS     PC              ;RETURN



.REM    %
        ****TEST 12 CHECKS STATUS WORD 1 FOR ADR PARITY ERROR.
ALL CHANNELS ARE TESTED.
%
T.012:  CHSTRT                  ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,CCWF1S          ;
        XQT     ADRPAR          ;FORCE BAD ADR PARITY
        MOV     R4,R0           ;
        SIMBUS  ,ICCWF          ;START/RESET
        INSYNC                  ;****SUBTEST X1
        FIND    <162,15,0>      ;GET TO CHAN ADR PAR ERR
        BCC     2$              ;GOT THERE


;SEQ296

        FAULT   <NO CHAN ADR PAR ERR>

2$:     INSYNC                  ;***SUBTEST X2
        TSTREF                  ;GET TO STORE
        BCC     3$              ;O.K.
        CFAULT  <NO STORE FOR ADR PAR ERR>

3$:     FIND    <162,31,0>      ;GET PAST STORE (-SBUS ADR HOLD)
        MOV     #ADRMSK,R0
        JSR     R5,COMST1       ;TEST STATUS 1
        .WORD   SBUST           ;
        BCC     4$              ;O.K.
        FAULT   <ADR PAR ERR EXPECTED>

4$:     JSR     PC,CLRERR               ;CLEAR MEMORY ERRORS
        NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL

ADRPAR: IO10    CONO PI,,400000

ADRMSK: WD36    0200,0000,0000  ;MASK NXM BIT

SBUST:  WD36    6000,0000,0000  ;ADR PAR & PAR

        .EVEN


;SEQ297


;SEQ298



;SEQ299

.REM    %
        TEST13 SETUP SETS EPT LOCATIONS TO A HALT WITH AN
ADDRESS OF 17777777.  IT ALSO CHECKS TO SEE IF NXMS CAN BE TESTED.
%
I.013:  RSTMBX
LOAD    0,MOVUP,2                       ;LOAD ACS FOR NXM TEST
        CLR     CHNNXM          ;CLEAR TEST NXM
        DFWRTT                  ;SET FORCE EXTEND
                KLB27           ;BIT 27
                76              ;FUNCTION 76
        XQT     SXCT0           ;CHECK FOR NXM @ 17777676
        XQT     GETAPR          ;CONI APR
        READ17  
        TBIT    25              ;NXM?


        BEQ     1$              ;NO, BYPASS NXM TEST
        INC     CHNNXM           ;SET TEST NXM
        JSR     PC,CLRERR               ;CLEAR MEMORY ERRORS
1$:     MOV     #7,R4           ;CHANNEL #
2$:     MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,CCWF1S
        DEC     R4              ;NEXT CHANNEL
        BGE     2$              ;NO, LOOP AGAIN
        RSTMBX
        RTS     PC              ;RETURN


;SEQ300

.REM    %
        **** TEST 13 CHECKS STATUS WORD 1 FOR NXM ERROR & A
CLP = 0 FOR ALL CHANNELS.  THE CBUS START IS ALSO TESTED.
%
T.013:  CHSTRT                  ;CHANNEL #
1$:     MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        MEMRD
        INSYNC                  ;****SUBTEST X1
        INSYNC                  ;SYNC FOR SUBTEST 2
        DEC     R5
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,STRT           ;START
        TSTREF
        BCC     2$              ;O.K.
        CFAULT  <NO FETCH FOR CBUS START>


2$:     INC     R5              ;*****SUBTEST X2
        CMPMEM  STATST
        BCC     3$              ;START O.K.
        CFAULT  <FETCH FOR START>

3$:     TST     CHNNXM          ;TEST NXM STATUS?
        BEQ     5$              ;NO
        INSYNC                  ;****SUBTEST X3
        INSYNC                  ;SYNC FOR SUBTEST 4
        DEC     R5              ;
        TSTREF
        BCC     4$              ;O.K.
        CFAULT  <NO STORE FOR NXM ERROR>


;SEQ301

4$:     INC     R5              ;****SUBTEST X4
        STACOM  NXMST
        BCC     5$              ;O.K.
        FAULT   <NXM OF EPT FETCH>

5$:     RSTMBX          ;RESET KL
        NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL

CHNNXM: .WORD   0               ;TEST NXM FLAG
MOVUP:  I10     MOVE AC2,,0,1


        WD36    0000,1777,7676


KLB27:  WD36    0000,0000,0400


SXCT0:  I10     XCT 0,,0        ;EXTENDED ADDRESS


STRT:   CBUS    <ST>


STATST: MEMTAB  17777777,<RD,RQ3>


NXMST:  WD36    7200,0,0


        .EVEN


;SEQ302



;SEQ 304



;SEQ305

.SBTTL          JUMP TEST
.REM    %
        **** TEST 14 CHECKS THE JUMP.
%
T.014:  JSR     PC,CLRERR               ;CLEAR MEMORY ERRORS
        CLR     R2              ;JUMP PATTERN INDEX
1$:     RSTMBX
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        MOV     JMPPTR(R2),R0   ;GET PROPER JUMP POINTER
        MOV     #ADRBAS,R1      ;EPT ADDRESS
        DPOS
        SYNC
        CLR     R0              ;CHANNEL 0
        SIMBUS  ,ICCWF          ;START/RESET
        TSTREF                  ;GET TO FIRST FETCH
        TSTREF                  ;GET TO JUMP FETCH
        BCC     2$              ;O.K.
        FAULT   <NO JUMP FETCH>

2$:     TST             R2      ;
        BNE     3$              ;
        CMPMEM  MEMJP1          ;ADDRESS 777
        BR      4$              ;
3$:     CMPMEM  MEMJP2          ;ADDRESS 17 777000
4$:     BCC 6$          ;COMPARE O.K.
        INC     R5              ;DETERMINE SUBTEST
        TST     R2              ;
        BEQ     5$              ;FIRST JUMP
        INC     R5              ;SECOND JUMP
5$:     FAULT   <JUMP REF.>


;SEQ306

6$:     TST     R2              ;DONE?
        BNE     7$              ;YES
        MOV     #2,R2           ;
        BR      1$              ;NO, LOOP AGAIN
7$:     RSTMBX
        NORMAL  

JMPPTR: .WORD   JMP1
        .WORD   JMP2

JMP1:   CCW     CJMP,777

JMP2:   CCW     CJMP,17777000

MEMJP1: MEMTAB  777,<RD,RQ3>

MEMJP2: MEMTAB  17777000,<RD,RQ0>

        .EVEN


;SEQ307



;SEQ308



;SEQ309

.SBTTL          ZERO-WD DATA FETCH/ INCREMENTAL CCW FETCH TEST

.REM    %
        TEST 15 SETUP PUTS A CJMP,100 IN CHANNEL EPT LOCATIONS
& DATA  TRANSFERS OF ZERO WORDS IN 100 & 101.  102 GETS A CHLT,100.
%
I.015:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,TRAN0,3     ;LOAD 100-102
1$:     RTS     PC              ;RETURN


TRAN0:  CCW     CDTA,300,0

        CCW     CDTA,301,0



        CCW     CHLT,100


        .EVEN

.REM    %
        ****TEST 15 CHECKS THAT NO ACTION FLAG REQUEST OCCURS FOR
-CTOM TRANSFERS WITH A WORD COUNT OF 0 FOR ALL CHANNELS.  INCREMENTAL
CCW FETCHES AE ALSO TESTED.
%
T.015:  CHSTRT                  ;CHANNEL #
1$:     RSTMBX
                
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        MEMRD                   ;GET PAST JUMP
        FIND    <165,32,1>      ;GET TO CORE RD IN PROG
        STOPCH
        FIND    <165,32,0>      ;GET TO -CORE RD IN PROG
        CHSYNC


;SEQ310

        INSYNC                  ;****SUBTEST X1
        MOV     R4,R2           ;GET CURRENT CHANNEL #
        ASL     R2              ;MULTIPLY BY 2
        MOV     T15TAB(R2),2$   ;GET SNAPSHOT DATA POINTER
        JSR     R5,CSCAN                ;SCAN CHANNELS
2$:     .WORD   0               ;TABLE POINTER GOES HERE
        14.             ;@ -CCW CCWF WAITING + 1 TICK
        BCC     3$      ;O.K.
        CFAULT  <0 WD XFER>

3$:     INSYNC                  ;****SUBTEST X2
        TSTREF                  ;GET TO NEXT COMMAND
        BCC     4$              ;O.K.
        CFAULT  <NO INCREMENTAL CCW FETCH>

4$:     CMPMEM  FETCH2          ;TEST 1 WORD AT 101
        BCC     5$              ;O.K.
        CFAULT  <IMPROPER MEM REF FOR 2ND CCW FETCH>

5$:     INSYNC                  ;****SUBTEST X3
        TSTREF                  ;GET TO HALT FETCH
        BCC     6$              ;O.K.
        CFAULT  <NO HALT FETCH AFTER DTA XFERS>

6$:     FIND    <162,31,1>      ;TEST NO MORE (SBUS ADR HOLD)
        BCS     7$              ;O.K.
        CFAULT  <MEM REF AFTER HALT>

7$:     NEXTCH
        BEQ     8$              ;YES
          JMP   1$              ;NO LOOP AGAIN
8$:     NORMAL


;SEQ311

FETCH2: MEMTAB  101,<RD,RQ1>


        .EVEN

T15TAB:         T15CH0          ;0
                T15CH1          ;1
                T15CH2          ;2
                T15CH3          ;3
                T15CH4          ;4
                T15CH5          ;5
        T15CH6          ;6
                T15CH7          ;7

T15CH0: .WORD   020004          ;B@D
        .WORD   105406          ;HlF
        .WORD   000000          ;   
        .WORD   007000          ; x@
        .WORD   000400          ; D@
        .WORD   002201          ; RA
        .WORD   000000          ;   
        .WORD   044001          ;D A
        .WORD   003000          ; X@
        .WORD   000003          ;  C
        .WORD   001000          ; H@
        .WORD   003600          ; ^@
T15CH1: .WORD   020004          ;B@D
        .WORD   005406          ; lF
        .WORD   000000          ;   
        .WORD   006200          ; r@
        .WORD   000400          ; D@
        .WORD   002201          ; RA
        .WORD   000000          ;   
        .WORD   004001          ;  A
        .WORD   000000          ;   
        .WORD   000003          ;  C
        .WORD   001000          ; H@
        .WORD   003700          ; _@
T15CH2: .WORD   020004          ;B@D
        .WORD   005406          ; lF
        .WORD   000000          ;   
        .WORD   005000          ; h@
        .WORD   100400          ;HD@
        .WORD   002201          ; RA
        .WORD   000000          ;   
        .WORD   004001          ;  A
        .WORD   003400          ; \@
        .WORD   000003          ;  C
        .WORD   001000          ; H@
        .WORD   003640          ; ^ 
T15CH3: .WORD   020004          ;B@D
        .WORD   005406          ; lF
        .WORD   000000          ;   
        .WORD   004000          ;  @
        .WORD   000400          ; D@
        .WORD   002201          ; RA
        .WORD   000200          ; B@
        .WORD   004001          ;  A
        .WORD   001400          ; L@
        .WORD   000003          ;  C
        .WORD   001000          ; H@
        .WORD   003740          ; _ 
T15CH4: .WORD   020004          ;B@D
        .WORD   005406          ; lF
        .WORD   000000          ;   
        .WORD   003000          ; X@
        .WORD   000400          ; D@
        .WORD   002201          ; RA
        .WORD   000000          ;   
        .WORD   044001          ;D A
        .WORD   002400          ; T@
        .WORD   000003          ;  C
        .WORD   101000          ;HH@
        .WORD   003620          ; ^P
T15CH5: .WORD   020204          ;BBD
        .WORD   005406          ; lF
        .WORD   000000          ;   
        .WORD   002000          ; P@
        .WORD   000400          ; D@
        .WORD   002201          ; RA
        .WORD   000000          ;   
        .WORD   004001          ;  A
        .WORD   000400          ; D@
        .WORD   000003          ;  C
        .WORD   001000          ; H@
        .WORD   003720          ; _P
T15CH6: .WORD   020004          ;B@D
        .WORD   005406          ; lF
        .WORD   000000          ;   
        .WORD   001000          ; H@
        .WORD   000400          ; D@
        .WORD   002201          ; RA
        .WORD   000000          ;   
        .WORD   104001          ;H A
        .WORD   002400          ; T@
        .WORD   000003          ;  C
        .WORD   001000          ; H@
        .WORD   003660          ; ^p
T15CH7: .WORD   020204          ;BBD
        .WORD   005406          ; lF
        .WORD   000000          ;   
        .WORD   000000          ;   
        .WORD   000400          ; D@
        .WORD   002201          ; RA
        .WORD   000000          ;   
        .WORD   044001          ;D A
        .WORD   000400          ; D@
        .WORD   000003          ;  C
        .WORD   001000          ; H@
        .WORD   003760          ; _p
;SEQ312



;SEQ314



;SEQ315

.SBTTL          CHANNEL PRIORITY/ CCW BUFFER ADDRESSING TEST

.REM    %
        TEST 16 SETUP SETS COMMAND LISTS STARTING AT 100 & 200
WHICH CAUSE STATUS 1 CLP & STATUS 2 COMPLEMENTARY DATA WHEN STARTED.
%
I.016:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX  
        LOAD    200,LOWCCW,1    ;200 GETS 0-WD XFER FROM 101
        XQT     DATPAR          ;FORCE WRITE EVEN DATA PARITY
          
        LOAD    100,BIGCCW,1            ;100 GETS 777777 777676








        LOAD    201,JMPBIG,1    ;201 GETS CJMP 17 777676
          
        JSR     PC,CLRERR       ;CLEAR MEMORY ERRORS
1$:     RSTMBX
        RTS     PC              ;

LOWCCW: CCW     CDTA,101


BIGCCW: WD36             7777,7777,7676


JMP200: CCW     CJMP,200


JMPBIG: CCW     CJMP,17777676


        .EVEN


;SEQ316

.REM    %
        ****TEST 16 CHECKS CHANNEL PRIORITY, AND IT ADDRESS TERSTS
THE CCW BUFFER.  IT DOES THIS BY CAUSING ONE CHANNEL TO HOLD A COM-
MAND LIST PTR OF 17 777676 & A CHANNEL COMMAND WD OF 400000 000101.
THIS CHANNEL IS STARTED FIRST.  ALL OTHER CHANNELS ARE THEN STARTED.
THESE CHANNELS GENERATE  A COMPLEMENT CLP AND CCW.  AFTER ALL CHAN
NELS HAVE LOGGED OUT WITH PARITY ERRORS, THE FIRST STARTED CHANNEL
STATUS IS TESTED TO ENSURE THAT NO OTHER CHANNEL  HAS DISTURBED ITS
DATA.  THE TEST CONTINUES UNTIL EACH CHANNEL HAS BEEN FIRST.
%
T.016:  CHSTRT
1$:     RSTMBX  
        MOV     R4,R0                   ;CURRENT TEST CHANNEL
        SETEPT  ,JMP200                 ;GETS A CJMP 200
        MOV     #7,R2                   ;
        
2$:     CMP     R2,R4                   ;
        BEQ     3$                      ;
        MOV     R2,R0                   ;ALL OTHERS
        SETEPT  ,JMP100         ;GET A CJMP 100
3$:     DEC     R2                      ;CONTINUE UNTIL EPT DONE
        
        BGE     2$              ;CONTINUE UNTIL EPT DONE
        CLR     R2              ;RESET DISTURBV CHANNEL
        CLR     R3              ;RESET MEM REF COUNT
        INSYNC                  ;****SUBTEST X1
        PUSH    TRCMEM          ;SAVE MEM TRACE FLAG

        INC     TRCMEM          ;ET TRACE MEM REFS
        MOV     R4,R0           ;CURRENT TEST CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        BRST    4               ;IN CASE CHANNEL 0 NEXT


;SEQ317

4$:     CMP     R2,R4           ;
        BEQ     5$              ;
        MOV     R2,R0           ;DISTURB CHANNEL
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        TST     MEMRQ
        BEQ     5$              ;NO MEM REF
        JSR     PC,CHKREF       ;MEM REF DETECTED, TEST IT
5$:     INC     R2              ;NEXT DISTURB CHANNEL
        CMP     R2,#7           ;LSAT ONE STARTED?
        BLE     4$              ;NO, DO NEXT
6$:     CMP     R3,#25.         ;ALL MEM REFS DONE?
        BGE     8$              ;YES
        FIND    <162,31,1>      ;NO, FIND SBUS ADR HOLD
        BCC     7$              ;FOUND IT
        ERRMSG  <MBOX HUNG, ACTUAL IS LAST MEM REF DONE\>

        JSR     PC,CHKREF       ;PRINT SYMPTOM
        FATAL                   ;SHOULD NEVER GET HERE
7$:     GETMEM
        JSR     PC,CHKREF       ;TEST MEM REF
        BR      6$              ;NEXT ONE
8$:     POP     TRCMEM          ;RESTORE MEM TRACE FLAG

        INSYNC                  ;****SUBTEST X2
        STACOM  CCWADR          ;NOW TEST STATUS
        BCS     9$              ;BAD
        STAT2   LOWCCW          ;
        BCC     10$             ;O.K.
9$:     FAULT   <CCW BUFFER ADDRESSING>

10$:    JSR     PC,CLRERR       ;CLEAR MEMORY ERRORS
        NEXTCH
        BEQ     11$             ;DONE?
        JMP     1$              ;NO LOOP AGAIN
11$:    NORMAL


;SEQ318


        ;LOCAL SUBROUTINE FOR TEST 16

CHKREF: TST     R3              ;FIRST MEM REF?
        BNE     1$              ;NO
        MOV     R4,R0           ;YES, SET EPT + (4*CH)
        SL      R0,2            ;


        MOVB    R0,ICCWTB+1     ;IN ICCWTB
1$:     CMP     R3,#2           ;1ST, 2ND OR 3RD MEM REF
        BGT     3$              ;NO
        MOV     R3,R0           ;YES, GET POINTER
        ASL     R0              ;
        MOV     2$(R0),R0       ;
        BR      7$              ;GO DO COMPARE
2$:             ICCWTB          ;1 - EPT + (4*CH)
                CCW200          ;2 - 200
                CCW201          ;3 - 201
3$:     CMP     R3,#17.         ;4TH - 17TH MEM REF?
        BGE     6$              ;NO
        MOV     R3,R0           ;YES EVEN OR ODD NUMBER?
        ASR     R0              ;
        BCS     4$              ;# OF REF IS ODD IF R3 EVEN
        MOV     #CCW100,R0      ;ODD REF - 100
        BR      7$              ;GO DO COMPARE
4$:     MOV     R3,R0           ;CALCULATE CHANNEL #
        SUB     #3,R0           ;
        ASR     R0              ;
        CMP     R0,R4           ;
        BLT     5$              ;
        INC     R0              ;
5$:     SL      R0,2            ;CALCULATE EPT + (4*CH)



        MOVB    R0,ICCWTB+1     ;
        MOV     #ICCWTB,R0      ;POINT TO REF DATA
        BR      7$              ;GO DO COMPARE
6$:     MOV     R3,R0           ;18TH - 25TH MEM REF
        SUB     #17.,R0          ;
        SL      R0,2            ;CALCULATE EPT + (4*CH) +1


        INC     R0              ;
        MOVB    R0,STRS1+1      ;
        MOV     #STRS1,R0       ;POINT TO REF DATA


;SEQ319

7$:     INC     R3              ;COUNT MEM REF
        JSR     R5,CMEM2                ;COMPARE MEM REF
        BCC     8$              ;COMPARE O.K.
        POP     R0              ;DISCARD ENTRY POINT


        POP     TRCMEM          ;RESTORE MEM TRACE FLAG

        FAULT   <CHANNEL PRIORITY>

8$:     RTS     PC              ;RETURN


CCW100: MEMTAB  100,<RD,RQ0>


CCW200: MEMTAB  200,<RD,RQ0>


CCW201: MEMTAB  201,<RD,RQ1>


CCWADR: WD36    7000,1777,7676


        .EVEN


;SEQ320



;SEQ322




;SEQ323

.SBTTL          1-WD CTOM ZERO-FILL/ DONE INTERRUPT TEST

.REM    %

        TEST 17 SETUP CONDITIONS THE CCW BUFFER & THEN APPLIES A NEW
SCANOUT MASK TO THE CHANNELS.  THE ONLY SIGNALS MASKED ARE CRC CH
BUF ADR 0-6 & CCL ODD WC PAR.
%
I.017:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        LOAD    100,ZEROF1      ;100 GETS 1 WD ZERO-FILL
        DPOST                   ;200 GETS 0 WD XFER FORM 101
        200,LOWCCW              ;
        DPOST                   ;201 GET A HALT
                201,MAXHLT      ;
1$:     MOV     #7,R4           ;ALL CHANNELS
2$:     RSTMBX
        MOV     R4,R0           ;
        SETEPT  ,JMP200 ;GET A CJMP 200
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,ICCWF          ;DONDITION CCW F       BUFFER
        DFXCTT                  ;
                STRCLK          ;
        TWAIT   1
        DEC     R4              ;NEXT CHANNEL
        BGE     2$              ;LOOP UNTIL ALL CHANNELS DONE
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        MOV     #MASKC,CMASK    ;SET CHANNEL SNAPSHOT MASK
        RTS     PC              ;RETURN

MASKC:  .BYTE   10,0,10         ;170 (12-19,04-11,00-03)
        .BYTE   0,0,10          ;171
        .BYTE   0,0,10          ;172
        .BYTE   0,0,10          ;173
        .BYTE   0,0,10          ;174
        .BYTE   0,0,10          ;175
        .BYTE   0,0,10          ;176
        .BYTE   0,0,0           ;177

ZEROF1: CCW     CDTA,0,1,END


        .EVEN


;SEQ324

.REM    %
        ****TEST 17 CHECKS PROPER TIME STATES FOR A ONE-WORD CTOM
ZERO-FILL WITH A WORD COUNT OF 1 AND THE DONE INTERRUPT FOR ALL CHAN-
NELS.  DECREMENTING THE WORD COUNT FROM 1 TO ZERO TESTS THE CCL ALU
FOR THE ALL CARRY CASE.
%
T.017:  CHSTRT          ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        MEMRD                   ;GET PAST JUMP
        FIND    <165,32,1>      ;GET TO CORE RD IN PROG
        STOPCH  
        FIND    <165,32,0>      ;GET TO -CORE RD IN PROG
        CHSYNC
        INSYNC                  ;****SUBTEST X1
        MOV     R4,R2           ;GET CURRENT CHANNEL #
        ASL     R2              ;MULTIPLY BY 2
        MOV     T17TB1(R2),2$   ;GET SNAPSHOT DATA POINTER
        JSR     R5,CSCAN        ;SCAN CHANNELS
2$:     .WORD   0               ;TABLE POINTER GOES HERE
        .WORD   23              ;@ CBUS READY E CLK CNT
        BCS     4$              ;BAD
        INSYNC                  ;****SUBTEST X2
        MOV     R4,R0           ;CURRENT CHANNEL
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        MOV     R4,R2           ;GET CURRENT CHANNEL #
        ASL     R2              ;MULTIPLY BY 2
        MOV     T17TB2(R2),3$   ;GET SNAPSHOT DATA POINTER
        JSR     R5,CSCAN        ;SCAN CHANNELS
3$:     .WORD   0               ;TABLE POINTER GOES HERE
        .WORD   21              ;@ -CCL ACT FLAG REQ CLK CNT
        BCC     5$              ;O.K.
4$:     CFAULT  <1-WD CTOM ZERO-FILL>


;SEQ325

5$:     INSYNC                  ;*****SUBTEST X3
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,DONINT ;DONE
        MOV     R4,R2           ;GET CURRENT CHANNEL #
        ASL     R2              ;MULTIPLY BY 2
        MOV     T17TB3(R2),6$   ;GET SNAPSHOT DATA POINTER
        JSR     R5,CSCAN        ;SCAN CHANNELS
6$:     .WORD   0               ;TABLE POINTER GOES HERE
        .WORD   5               ;@ -CRC READY IN CLK CNT
        BCS     7$              ;BAD
        TSTREF
        BCS     8$              ;NO MEM REF, O.K.
        ERRMSG  <MEM REF AFTER DONE >

        
7$:     CFAULT  <DONE INTERRUPT>

8$:     NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL


;SEQ326

DONINT: CBUS    <DON>



        .EVEN

T17TB1:   T17CA0        ;0
                T17CA1          ;1
                T17CA2  ;2
                T17CA3  ;3
                T17CA4  ;4
                T17CA5  ;5
                T17CA6  ;6
                T17CA7  ;7
T17CA0: .WORD   000405          ; DE
        .WORD   001406          ; LF
        .WORD   000004          ;  D
        .WORD   017000          ;Ax@
        .WORD   100404          ;HDD
        .WORD   000400          ; D@
        .WORD   100440          ;HD 
        .WORD   040003          ;D@C
        .WORD   003600          ; ^@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007610          ; >H
T17CA1: .WORD   000404          ; DD
        .WORD   001402          ; LB
        .WORD   000004          ;  D
        .WORD   047000          ;Dx@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000600          ; F@
        .WORD   000002          ;  B
        .WORD   001600          ; N@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T17CA2: .WORD   000404          ; DD
        .WORD   001402          ; LB
        .WORD   000004          ;  D
        .WORD   047000          ;Dx@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000400          ; D@
        .WORD   100002          ;H@B
        .WORD   002600          ; V@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T17CA3: .WORD   000604          ; FD
        .WORD   001402          ; LB
        .WORD   000004          ;  D
        .WORD   047000          ;Dx@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000400          ; D@
        .WORD   040002          ;D@B
        .WORD   000600          ; F@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T17CA4: .WORD   000404          ; DD
        .WORD   101402          ;HLB
        .WORD   000004          ;  D
        .WORD   047000          ;Dx@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   000002          ;  B
        .WORD   002200          ; R@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T17CA5: .WORD   000404          ; DD
        .WORD   001402          ; LB
        .WORD   000004          ;  D
        .WORD   047200          ;Dz@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   000002          ;  B
        .WORD   000200          ; B@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T17CA6: .WORD   000404          ; DD
        .WORD   101402          ;HLB
        .WORD   000004          ;  D
        .WORD   047000          ;Dx@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   040002          ;D@B
        .WORD   003200          ; Z@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@
T17CA7: .WORD   000404          ; DD
        .WORD   001402          ; LB
        .WORD   000004          ;  D
        .WORD   047200          ;Dz@
        .WORD   000400          ; D@
        .WORD   003400          ; \@
        .WORD   000000          ;   
        .WORD   040002          ;D@B
        .WORD   001200          ; J@
        .WORD   000001          ;  A
        .WORD   001000          ; H@
        .WORD   007600          ; >@

;SEQ327

T17TB2:         T17CB0  ;0
                T17CB1  ;1
                T17CB2  ;2
                T17CB3  ;3
                T17CB4  ;4
                T17CB5  ;5
                T17CB6  ;6
                T17CB7  ;7

T17CB0: .WORD   000007          ;  G
        .WORD   101406          ;HLF
        .WORD   000105          ; AE
        .WORD   047000          ;Dx@
        .WORD   000004          ;  D
        .WORD   000400          ; D@
        .WORD   100040          ;H@ 
        .WORD   040003          ;D@C
        .WORD   003200          ; Z@
        .WORD   100001          ;H@A
        .WORD   001400          ; L@
        .WORD   003400          ; \@
T17CB1: .WORD   000007          ;  G
        .WORD   001406          ; LF
        .WORD   000105          ; AE
        .WORD   047200          ;Dz@
        .WORD   000004          ;  D
        .WORD   000400          ; D@
        .WORD   100000          ;H@@
        .WORD   000003          ;  C
        .WORD   000200          ; B@
        .WORD   000001          ;  A
        .WORD   001400          ; L@
        .WORD   007400          ;  @
T17CB2: .WORD   000007          ;  G
        .WORD   001406          ; LF
        .WORD   000105          ; AE
        .WORD   047000          ;Dx@
        .WORD   100004          ;H@D
        .WORD   000400          ; D@
        .WORD   100000          ;H@@
        .WORD   000003          ;  C
        .WORD   003600          ; ^@
        .WORD   000001          ;  A
        .WORD   001400          ; L@
        .WORD   007400          ;  @
T17CB3: .WORD   000007          ;  G
        .WORD   001406          ; LF
        .WORD   000105          ; AE
        .WORD   047000          ;Dx@
        .WORD   000004          ;  D
        .WORD   000400          ; D@
        .WORD   100200          ;HB@
        .WORD   000003          ;  C
        .WORD   001600          ; N@
        .WORD   000001          ;  A
        .WORD   001400          ; L@
        .WORD   007400          ;  @
T17CB4: .WORD   000007          ;  G
        .WORD   001406          ; LF
        .WORD   000105          ; AE
        .WORD   047000          ;Dx@
        .WORD   000004          ;  D
        .WORD   000400          ; D@
        .WORD   100000          ;H@@
        .WORD   040003          ;D@C
        .WORD   002600          ; V@
        .WORD   000001          ;  A
        .WORD   101400          ;HL@
        .WORD   007400          ;  @
T17CB5: .WORD   000207          ; BG
        .WORD   001406          ; LF
        .WORD   000105          ; AE
        .WORD   047000          ;Dx@
        .WORD   000004          ;  D
        .WORD   000400          ; D@
        .WORD   100000          ;H@@
        .WORD   000003          ;  C
        .WORD   000600          ; F@
        .WORD   000001          ;  A
        .WORD   001400          ; L@
        .WORD   007400          ;  @
T17CB6: .WORD   000007          ;  G
        .WORD   001406          ; LF
        .WORD   000105          ; AE
        .WORD   047000          ;Dx@
        .WORD   000004          ;  D
        .WORD   000400          ; D@
        .WORD   100000          ;H@@
        .WORD   100003          ;H@C
        .WORD   002600          ; V@
        .WORD   000001          ;  A
        .WORD   001400          ; L@
        .WORD   007400          ;  @
T17CB7: .WORD   000207          ; BG
        .WORD   001406          ; LF
        .WORD   000105          ; AE
        .WORD   047000          ;Dx@
        .WORD   000004          ;  D
        .WORD   000400          ; D@
        .WORD   100000          ;H@@
        .WORD   040003          ;D@C
        .WORD   000600          ; F@
        .WORD   000001          ;  A
        .WORD   001400          ; L@
        .WORD   007400          ;  @

T17TB3:         T17CC0  ;0
                T17CC1  ;1
                T17CC2  ;2
                T17CC3  ;3
                T17CC4  ;4
                T17CC5  ;5
                T17CC6  ;6
                T17CC7  ;7

T17CC0: .WORD   000004          ;  D
        .WORD   001407          ; LG
        .WORD   000005          ;  E
        .WORD   047040          ;Dx 
        .WORD   000400          ; D@
        .WORD   002200          ; R@
        .WORD   100040          ;H@ 
        .WORD   060003          ;F@C
        .WORD   002600          ; V@
        .WORD   100001          ;H@A
        .WORD   141000          ;LH@
        .WORD   007400          ;  @
T17CC1: .WORD   000204          ; BD
        .WORD   001403          ; LC
        .WORD   000005          ;  E
        .WORD   047040          ;Dx 
        .WORD   000400          ; D@
        .WORD   003600          ; ^@
        .WORD   000040          ;   
        .WORD   060002          ;F@B
        .WORD   000600          ; F@
        .WORD   100001          ;H@A
        .WORD   041000          ;DH@
        .WORD   007700          ; ?@
T17CC2: .WORD   000004          ;D
        .WORD   101403          ;HLC
        .WORD   000005          ;  E
        .WORD   047040          ;Dx 
        .WORD   000400          ; D@
        .WORD   003600          ; ^@
        .WORD   000040          ;   
        .WORD   060002          ;F@B
        .WORD   003200          ; Z@
        .WORD   100001          ;H@A
        .WORD   041000          ;DH@
        .WORD   007640          ; > 
T17CC3: .WORD   000004          ;  D
        .WORD   001403          ; LC
        .WORD   000005          ;  E
        .WORD   047240          ;Dz 
        .WORD   000400          ; D@
        .WORD   003600          ; ^@
        .WORD   000040          ;   
        .WORD   060002          ;F@B
        .WORD   001200          ; J@
        .WORD   100001          ;H@A
        .WORD   041000          ;DH@
        .WORD   007740          ; ? 
T17CC4: .WORD   000004          ;  D
        .WORD   001403          ; LC
        .WORD   000005          ;  E
        .WORD   047040          ;Dx 
        .WORD   100400          ;HD@
        .WORD   003600          ; ^@
        .WORD   000040          ;   
        .WORD   060002          ;F@B
        .WORD   003600          ; ^@
        .WORD   100001          ;H@A
        .WORD   041000          ;DH@
        .WORD   007620          ; >P
T17CC5: .WORD   000004          ;  D
        .WORD   001403          ; LC
        .WORD   000005          ;  E
        .WORD   047040          ;Dx 
        .WORD   000400          ; D@
        .WORD   003600          ; ^@
        .WORD   000040          ;   
        .WORD   060002          ;F@B
        .WORD   001600          ; N@
        .WORD   100201          ;HBA
        .WORD   041000          ;DH@
        .WORD   007720          ; ?P
T17CC6: .WORD   000004          ;  D
        .WORD   001403          ; LC
        .WORD   000005          ;  E
        .WORD   047040          ;Dx 
        .WORD   100400          ;HD@
        .WORD   003600          ; ^@
        .WORD   000040          ;   
        .WORD   020002          ;B@B
        .WORD   003600          ; ^@
        .WORD   100001          ;H@A
        .WORD   041000          ;DH@
        .WORD   007660          ; >p
T17CC7: .WORD   000004          ;  D
        .WORD   001403          ; LC
        .WORD   000005          ;  E
        .WORD   047040          ;Dx 
        .WORD   000400          ; D@
        .WORD   003600          ; ^@
        .WORD   000240          ; B 
        .WORD   020002          ;B@B
        .WORD   001600          ; N@
        .WORD   100001          ;H@A
        .WORD   041000          ;DH@
        .WORD   007760          ; ?p
;SEQ328



;SEQ334



;SEQ336


;SEQ335

.SBTTL          INITIAL ACTION COUNTER TEST

.REM    %
        *****TEST 18 CHECKS THE ACTION COUNTER FOR INITIAL WORD
COUNTS OF 1-4 AND ADDRESS = 0 (CTOM ZERO-FILL ALL CHANNELS)
%
T.018:  CHSTRT
        
1$:     MOV     #1,R3           ;STARTING WC = 1
        MOV     #100,ACPAT+2    ;
        MOVB    #14,ACPAT+4     ;
2$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,ACPAT          ;AERO FILL CTOM TRANSFER TO EPT
        INSYNC
        MOV     R4,R0           ;
        SIMBUS  ,RDSTRT         ;START/REST/CTOM
        FIND    <165,32,0>      ;GET PAST FETCH (-CORE RD IN PROG)
        MOV     R4,R0           ;CURRENT TEST CHANNEL
        FIND    <176,6,0>       ;GET TO -CCL CCW REG LOAD
        CMP.S   ACTEN,R3        ;CHECK CCW ACT CTR ENABLES
        BCS     5$              ;BAD
        MOV     R3,R2
3$:     MOV     R4,R0           ;CURRENT TEST CHANNEL
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        DEC     R2              ;DONE ENOUGH?
        BGT     3$              ;NO
        FIND    <174,01,1>      ;GET TO CRC ACT FLAG ENA
        BCC     4$              ;GOT THERE
        CFAULT  <NO CRC ACT FLAG ENA>

4$:     CMP.S   ACTCTR,R3       ;CHECK CRC ACT CTR
        BCC     6$              ;O.K.


;SEQ336

5$:     CHTYP
        ERRMSG  < ADR = 0, WC = >
        MOV     R3,R0           ;WORD COUNT TO ERROR STACK
        ERROCS
        ERCRLF
        FAULT   <INITIAL LOAD ACTION COUNTER>

6$:     ADD     #100,ACPAT+2    ;
        INC     R3              ;NEWXT WORD COUNT
        CMP     R3,#4           ;DONE 1-4?
        BLE     2$              ;NO, NEXT PATTERN
        NEXTCH
        BNE     1$              ;LOOP UNTIL ALL CHANNELS DONE
        CHRCHK
        NORMAL  


ACPAT:  CCW     CDTA,0,1,END


ACTEN:  DF.     172             ;
                
        BP.    5               ;CCW ACT CTR 0 EN

        BP.     6               ;CCW ACT CTR 1 EN

        BP.     -7              ;CCW ACT CTR 2 EN

ACTCTR: DF.     173             ;

        BP.     1               ;CRC ACT CTR OR

        BP.     2               ;CRC ACT CTR 1R

        BP.     -3              ;CRC ACT CTR 2R

        .EVEN


;SEQ337



;SEQ339




;SEQ340

.SBTTL          CCL ALU/ REQUEST COUNTER TEST

.REM    %

        *****TEST 19 CHECKS THE CCL ALU & REQ CTR.  IT PERFORMS THIS
BY DOWN-COUNTING WORD COUNTS OF 1-7.  IN ORDER TO TEST THAT THE CCL
ALU CARRY PROPAGATION STOPS AT THE CORRECT POINT, THE MAXIMUM WORD
COUNT IS THEN DOWN-COUNTED.
%
T.019:  MOV     #1,R3           ;INITIAL WORD COUNT = 1
        MOV     #100,ACPAT+2    ;
        MOVB    #14,ACPAT+4      ;
1$:     RSTMBX
        CLR     R0              ;CHANNEL 0
        SETEPT  ,ACPAT          ;PUT N WORD ZERO-FILL IN EPT
        INSYNC
        CLR     R0              ;
        SIMBUS  ,RDSTRT          ;START/RESET/CTOM
        MEMRD
        PUSH    TRCMEM          ;SAVE MEM TRACE FLAG

        CLR     TRCMEM          ;ALLOW MAX SPEED OPERATION
        MOV     R3,R2           ;NUMBER OF REQUESTS TO DO
2$:     CLR     R0              ;
        JSR     R5,SLOWRQ       ;SLOW-MODE CBUS REQUEST
        DEC     R2              ;
        BGT     2$              ;LOOP UNTIL ALL DONE
        SOBAC   <175,18,1>,3    ;GET TO CCL ACT FLAG REQ
        BCC     3$              ;GOT THERE
        ERRMSG  <PREMATURE TERMINATION, >

        BR      4$              ;FINISH REST OF ERROR REPORT


;SEQ341

3$:     STPCON  <12>                    ;GET TO CCL MEM PTR EN CLK CNT
        TENBIT  170,19          ;CHECK CCL WC=0


        BEQ     5$              ;O.K.
        BITERR
4$:     POP     TRCMEM  ;RESTORE MEM TRACE FLAG

        ERRMSG  <INITIAL WC = >

        MOV     R3,R0           ;
        ERROCS                  ;WORD COUNT TO ERROR STACK
        ERCRLF
        FAULT   <CCL ALU/ REQ CTR, CRC CH PTR>
5$:     POP     TRCMEM          ;RESTORE MEM TRACE FLAG

        CMP     R3,#7           ;1-7 DONE?
        BEQ     6$              ;YES, DO MAX WC
        BGT     7$              ;ALL DONE?
        INC     R3              ;NO INCREMENT WC
        ADD     #100,ACPAT+2    ;
        BR      1$              ;LOOP FOR WC 1-7
6$:     MOV     #3777,R3        ;MAX WORD COUNT
        MOV     #177700,ACPAT+2 ;
        INCB    ACPAT+4         ;
        BR      1$              ;LOOP FOR MAX WC
7$:     NORMAL


;SEQ342



;SEQ343




;SEQ344

.SBTTL          1-WD -CTOM DATA TRANSFER TEST
.REM    %
        TEST 20 SETUP PUTS A CJMP, 100 IN CHANNEL EPT LOCATIONS,
& DATA TRANSFERS FROM 300,301, 302 & 303 IN 100, 101, 102
& 103.  300-307 ARE ZEROED.
%
I.020:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,TRAN1,4             ;LOAD 100-104
        CLRB    ADRH            ;
        MOV     #300,ADRL       ;
        MOV     #ADRL,R1        ;
        MOV     #10,R0          ;
        D10ZRO                  ;ZERO 300-307
1$:     RTS     PC              ;RETURN


TRAN1:  CCW     CDTA,300,1


        CCW     CDTA,301,1


        CCW     CDTA,302,1


        CCW     CDTA,303,1,END


;SEQ345

.REM    %
        *****TEST 20 CHECKS DATA FETCH ADDRESSING OF ONE WORD FOR
ALL CHANNELS.
%
T.020:  CHSTRT                  ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        MEMRD                   ;GET PAST JUMP
        FIND    <165,32,1>      ;GET TO CORE RD IN PROG
        STOPCH
        FIND    <165,32,0>      ;GET TO -CORE RD IN PROG
        CHSYNC
        INSYNC                  ;****SUBTEST X1
        MOV     R4,R2           ;GET CURRENT CHANNEL #
        ASL     R2              ;MULTIPLY BY 2
        BNE     2$              ;NOT CHANNEL 0
        MCSCAN  T20CH0,<26>             ;SCAN @ SBUS ADR HOLD CLK CNT
        BCC     5$              ;CHANNEL 0 O.K. 
        BR      4$              ;BAD
2$:     MOV     T20TAB-2(R2),3$ ;GET SNAPSHOT DATA POINTER
        JSR     R5,CSCAN        ;SCAN CHANNELS
3$:     .WORD   0               ;TABLE POINTER GOES HERE
        .WORD   26              ;@ SBUS ADR HOLD CLK CNT
        BCC     5$              ;O.K.
4$:     CFAULT  <1-WD -CTOM DATA XFER>


;SEQ346

5$:     INSYNC                  ;*****SUBTEST X2
        CMPMEM  WD1AT0          ;TEST 1 WORD AT 300
        BCS     6$              ;BAD
        INSYNC                  ;****SUBTEST X3
        JSR     PC,DFETCH       ;GET TO 2ND TRANSFER
        CMPMEM  WD1AT1          ;TEST 1 WORD AT 301
        BCS     6$              ;BAD
        INSYNC                  ;****SUBTEST X4
        JSR     PC,DFETCH       ;GET TO 3RD TRANSFER
        CMPMEM  WD1AT2          ;TEST 1 WORD AT 302
        BCS     6$              ;BAD
        INSYNC                  ;****SUBTEST X5
        JSR     PC,DFETCH       ;GET TO 4TH TRANSFER
        CMPMEM  WD1AT3          ;TEST 1 WORD AT 303
        BCC     7$              ;O.K.
6$:     CFAULT  <BAD ONE-WORD TRANSFER>

7$:     NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL


;SEQ347

WD1AT0: MEMTAB  300,<RD,RQ0>

WD1AT1: MEMTAB  301,<RD,RQ1>

WD1AT2: MEMTAB  302,<RD,RQ2>

WD1AT3: MEMTAB  303,<RD,RQ3>


SLOMOD: CBUS    <SLW>


        .EVEN

T20TAB:         T20CH1  ;1
                T20CH2  ;2
                T20CH3  ;3
                T20CH4  ;4
                T20CH5  ;5
                T20CH6  ;6
                T20CH7  ;7

T20CH0: .WORD   024004          ;B D
        .WORD   032024          ;CPT
        .WORD   034034          ;C \
        .WORD   062700          ;FW@
        .WORD   034021          ;C Q
        .WORD   060020          ;F@P
        .WORD   141020          ;LHP
        .WORD   026722          ;BwR
        .WORD   035522          ;CmR
        .WORD   035632          ;CnZ
        .WORD   035322          ;CkR
        .WORD   035644          ;Cnd
        .WORD   025345          ;Bke
        .WORD   035365          ;Cku
        .WORD   031307          ;CKG
        .WORD   004001          ;  A
        .WORD   005406          ; lF
        .WORD   000100          ; A@
        .WORD   017002          ;AxB
        .WORD   100400          ;HD@
        .WORD   000401          ; DA
        .WORD   003000          ; X@
        .WORD   041003          ;DHC
        .WORD   003600          ; ^@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
T20CH1: .WORD   004005          ;  E
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   016002          ;ApB
        .WORD   000400          ; D@
        .WORD   003401          ; \A
        .WORD   003200          ; Z@
        .WORD   001002          ; HB
        .WORD   001600          ; N@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
T20CH2: .WORD   004005          ;  E
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   015002          ;AhB
        .WORD   000400          ; D@
        .WORD   003401          ; \A
        .WORD   003000          ; X@
        .WORD   101002          ;HHB
        .WORD   002600          ; V@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
T20CH3: .WORD   004205          ; bE
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   014002          ;A B
        .WORD   000400          ; D@
        .WORD   003401          ; \A
        .WORD   003000          ; X@
        .WORD   041002          ;DHB
        .WORD   000600          ; F@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
T20CH4: .WORD   004005          ;  E
        .WORD   105402          ;HlB
        .WORD   000100          ; A@
        .WORD   013002          ;AXB
        .WORD   000400          ; D@
        .WORD   003401          ; \A
        .WORD   003000          ; X@
        .WORD   001002          ; HB
        .WORD   002200          ; R@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
T20CH5: .WORD   004005          ;  E
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   012202          ;ARB
        .WORD   000400          ; D@
        .WORD   003401          ; \A
        .WORD   003000          ; X@
        .WORD   001002          ; HB
        .WORD   000200          ; B@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
T20CH6: .WORD   004005          ;  E
        .WORD   105402          ;HlB
        .WORD   000100          ; A@
        .WORD   011002          ;AHB
        .WORD   000400          ; D@
        .WORD   003401          ; \A
        .WORD   003000          ; X@
        .WORD   041002          ;DHB
        .WORD   003200          ; Z@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
T20CH7: .WORD   004005          ;  E
        .WORD   005402          ; lB
        .WORD   000100          ; A@
        .WORD   010202          ;ABB
        .WORD   000400          ; D@
        .WORD   003401          ; \A
        .WORD   003000          ; X@
        .WORD   041002          ;DHB
        .WORD   001200          ; J@
        .WORD   000001          ;  A
        .WORD   000000          ;   
        .WORD   007610          ; >H
;SEQ348



;SEQ351



;SEQ3

;SEQ352

.SBTTL          2-WD -CTOM DATA TRANSFER TEST
.REM    %
        TEST 21 SETUP PUTS 2 WORD TRANSFERS FROM 300,301,302
& 303 IN100,101,102 & 103.
%
I.021:  BR      1$              ;BYPASS LOAD IF LOOP
          RSTMBX
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,TRAN2,4     ;LOAD 100-104
1$:     RTS     PC              ;RETURN

TRAN2:  CCW     CDTA,300,2


        CCW     CDTA,301,2

        
        CCW     CDTA,302,2




        CCW     CDTA,303,2,END



.REM    %
        ****TEST 21 CHECKS DATA FETCH ADDRESSING OF TWO WORDS
FOR ALL CHANNELS.
%
T.021:  CHSTRT                  ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        TSTREF                  ;GET TO JUMP
        INSYNC                  ;****SUBTEST X1
        JSR     PC,DFETCH       ;GET TO FIRST TRANSFER
        CMPMEM  WD2AT0          ;TEST 2 WDS AT 300
        BCS     2$              ;BAD


;SEQ353


        INSYNC                  ;****SUBTEST X2
        JSR     PC,DFETCH               ;GET TO 2ND TRANSFER
        CMPMEM  WD2AT1          ;TEST 2 WDS AT 301
        BCS     2$              ;BAD
        INSYNC                  ;****SUBTEST X3
        JSR     PC,DFETCH       ;GET TO 3RD TRANSFER
        CMPMEM  WD2AT2          ;TEST 2 WORDS AT 302
        BCC     3$              ;O.K.
2$:     CFAULT  <2-WD -CTOM XFER>

3$:     INSYNC                  ;****SUBTEST X4
        JSR     PC,DFETCH               ;GET TO 4TH TRANSFER
        CMPMEM  WD1AT3          ;TEST 1 WD AT 303
        BCC     4$              ;O.K.
        CFAULT  <1ST OF 2 MEM REFS FOR 2 WD XFER>

4$:     JSR     PC,SECREF      ;GET TO 2ND MEM REF
        CMPMEM  WD1AT4          ;RWAR 1 WD AT 304
        BCC     5$              ;O.K.

        CFAULT  <2ND OF 2 MEM REFS FOR 2 WD XFER>

5$:     NEXTCH
        BNE     1$              ;DONNE?
        NORMAL                  ;YES


WD2AT0: MEMTAB  300,<RD, RQ0,RQ1>


WD2AT1: MEMTAB  301,<RD,RQ1,RQ2>


WD2AT2: MEMTAB  302,<RD,RQ2,RQ3>


WD1AT4: MEMTAB  304,<RD,RQ0>


;SEQ354




;SEQ355



;SEQ356

.SBTTL          3-WD -CTOM DATA TRANSFER / LONG WC TEST
.REM    %
        TEST 22 SETUP PUTS 3 WORD TRANSFERS FROM 300,301,302
& 303 IN 100, 101, 102 & 103.
%
I.022:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,TRAN3,4     ;LOAD 100-104
1$:     RTS     PC              ;RETURN

TRAN3:  CCW     CDTA,300,3


        CCW     CDTA,301,3


        CCW     CDTA,302,3


        CCW     CDTA,303,3,END


;SEQ357

.REM    %
        *****TEST 22 CHECKS DATA FETCH ADDRESSING OF THREE WORDS
FOR ALL CHANNELS.  LONG WC ERROR STATUS IS ALSO TESTED.
%
T.022:  CHSTRT                  ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        TSTREF                  ;GET TO JUMP
        INSYNC                  ;****SUBTEST X1
        JSR     PC,DFETCH               ;GET TO FIRST RRANSFER
        CMPMEM  WD3AT0          ;TEST 3 WDS AT 300
        BCS     2$              ;BAD
        INSYNC                  ;*****SUBTEST X2
        JSR     PC,DFETCH              ;GET TO 2ND TRANSFER
        CMPMEM  WD3AT1          ;TEST 3 WDS AT 301
        BCC     3$              ;O.K.
2$:     CFAULT  <3-WD -CTOM XFER>

3$:     INSYNC                  ;*****SUBTEST X3
        JSR     PC,DFETCH       ;GET TO 3RD TRANSFER
        CMPMEM  WD2AT2          ;TEST 2 WDS AT 302
        BCS     4$              ;BAD
        JSR     PC,SECREF               ;GET TO 2ND MEM REF
        CMPMEM  WD1AT4          ;TEST 1 WD AT 304
        BCS     6$              ;BAD
        INSYNC                  ;****SUBTEST X4
        JSR     PC,DFETCH       ;GET TO 4TH TRANSFER
        CMPMEM  WD1AT3          ;TEST 1 WD AT 303
        BCC     5$              ;O.K.
4$:     CFAULT  <1ST OF 2 MEM REFS FOR 3 WD XFER>


;SEQ358

5$:     JSR     PC,SECREF       ;GET TO 2ND MEM REF
        CMPMEM  WD2AT4          ;TEST 2 WDS AT 304
        BCC     7$              ;O.K.
6$:     

6$:     CFAULT  <2ND OF 2 MEM REFS FOR 3 WD XFER>

7$:     INSYNC                  ;****8SUBTEST X5
        MOV     R4,R0           ;
        SIMBUS  ,STADON         ;DONE/STORE
        TSTREF  
        BCC     8$              ;O.K.
        CFAULT  <NO STORE FOR DONE/STORE>

8$:     STACOM  LONGWC
        BCC     9$              ;O.K.
        FAULT   <LONG WC EXPECTED>

9$:     NEXTCH
        BEQ     10$             ;DONE?
        JMP     1$              ;NO, LOOP AGAIN
10$:    NORMAL


WD3AT0: MEMTAB  300,<RD,RQ0,RQ1,RQ2>


WD3AT1: MEMTAB  301,<RD,RQ1,RQ2,RQ3>

WD2AT4: MEMTAB  304,<RD,RQ0,RQ1>

LONGWC: WD36    5001,0,104


        .EVEN


;SEQ359



;SEQ360



;SEQ361

.SBTTL          4-WD -CTOM DATA TRANSFER / NORMAL STATUS TEST
.REM    %
        TEST 23 SETUP PUTS 4 WORD TRANSFERS FROM 300,301,302
& 303 IN 100, 101, 102 & 103.
%
I.023:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX  

        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,TRAN4,4     ;LOAD 100-104
1$:     RTS     PC              ;RETURN

TRAN4:  CCW     CDTA,300,4


        CCW     CDTA,301,4


        CCW     CDTA,302,4


        CCW     CDTA,303,4,3NE


.REM    %
        *****TEST 23 CHECKS DATA FETCH ADDRESSING OF FOUR WORDS
FOR ALL CHANNELS.  THE ABILITY TO UNLOAD THE BUFFER & NORMAL
STATUS ARE ALSO TESTED.
%

T.023:  CHSTRT                  ;CHANNEL #
1$:     MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        TSTREF                  ;GET TO JUIMP
        INSYNC                  ;****SUBTEST X1
        JSR     PC,DFETCH       ;GET TO FIRST TRANSFER
        CMPMEM  WD4AT0          ;TEST 4 WDS AT 300
        BCC     2$              ;O.K.
        CFAULT  <4-WD -CTOM XFER>


;SEQ362

2$:     INSYNC                  ;*****SUBTEST X2
        JSR     PC,DFETCH       ;GET TO 2ND TRANSFER
        CMPMEM  WD3AT1          ;TEST 3 WDS AT 301
        BCS     3$              ;BAD
        JSR     PC,SECREF       ;GET TO 2ND MEM REF
        CMPMEM  WD1AT4          ;TEST 1 WD AT 304
                
          
        BCS     5$              ;BAD
        INSYNC                  ;*****SUBTEST X3
        JSR     PC,DFETCH       ;GET TO 3RD TRANSFER
        CMPMEM  WD2AT2  ;TEST 2 WDS AT 302
        BCS     3$              ;BAD
        JSR     PC,SECREF       ;GET TO 2ND MEM REF
        CMPMEM  WD2AT4          ;TEST 2 WDS AT 304
        BCS     5$              ;BAD
        INSYNC                  ;****SUBTEST X4
        JSR     PC,DFETCH       ;GET TO 4TH TRANSFER
        CMPMEM  WD1AT3  ;TEST 1 WD AT 303
       
        BCC     4$      ;O.K.
3$:     CFAULT  <1ST OF 2 MEM REFS FOR 4 WD XFER>

4$:     MOV     R4,R0           ;
        JSR     R5,SLOWRQ       ;CBUS REG
        JSR     PC,SECREF       ;GET TO 2ND MEM REF
        CMPMEM  WD3AT4  ;TEST 3 WDS AT 304
        BCC     6$              ;O.K.
5$:     CFAULT  <2ND OF 2 MEM REFS FOR 4 WD XFER>


;SEQ363

6$:     INSYNC                  ;****SUBTEST X5
        MOV     #1,R2           ;REQUEST #
7$:     MOV     R4,R0           ;
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        TSTREF                  ;ANY MEM REF?
        BCS     8$              ;NO, O.K.
        CHTYP   
        ERRMSG  < OVERRUNS ON TRANSFER >

        MOV     R2,R0
        ERRDEC                  ;TYPE TRANSFER #
        ERRMSG  < OF 15.>       ;

8$:     INC     R2              ;NEXT REQUEST
        CMP     R2,#15. ;15 DONE?
        BLE     7$              ;NO,LOOP AGAIN
        INSYNC                  ;****SUBTEST X6
        TSTREF
        MOV     R4,R0           ;
        SIMBUS  ,STADON         ;DONE/STORE
        TSTREF                  ;GET TO MEM REF
        BCC     9$              ;O.K.
        CFAULT  <NO STORE FOR DONE/STORE>


;SEQ364

9$:     STACOM  NORSTA
        BCC     10$             ;O.K.
        FAULT   <NORMAL STATUS EXPECTED>

10$:    TSTREF
        BCS     11$             ;NONE, O.K.

        CFAULT  <MEM REF AFTER DONE>

11$:    NEXTCH
        BEQ     12$             ;DONE?
        JMP     1$              ;NO, LOOP AGAIN
12$:    NORMAL          


WD4AT0: MEMTAB  300,<RD,RQ0,RQ1,RQ2,RQ3>


WD3AT4: MEMTAB  304,<RD,RQ0,RQ1,RQ2>


STADON:CBUS     <DON,STR>

NORSTA: WD36    5000,0,104



;SEQ365




;SEQ366



;SEQ367

.SBTTL          1-WD READ REVERSE TEST
.REM    %
        TEST 24 SETUP PUTS 1-WD REVERSE TRANSFERS TO 303, 302, 301
        
& 300 IN 100,101, 102 & 103.
%
I.024:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,REV1,4      ;LOAD 100-103
1$:     RTS     PC              ;RETURN

REV1:   CCW     CDTA,303,1,,REV


        CCW     CDTA,302,1,,REV


        CCW     CDTA,301,1,,REV

        CCW     CDTA,300,1,END,REV



;SEQ368

.REM    %

        ****TEST 24 CHECKS REVERSE READ ADDRESSING OF ONE WORD FOR ALL CHANNELS.
%
T.024:  CHSTRT                  ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        TSTREF                  ;GET TO JUMP
        INSYNC
        JSR     PC,STRAN        ;GET TO 1ST TRANSFER
        CMPMEM  WR1AT3          ;TEST 1 WD AT 303
        BCS     2$              ;BAD
        INSYNC                  ;****SUBTEST X2
        JSR     PC,STRAN        ;GET TO 2ND TRANSFER
        CMPMEM  WR1AT2          ;TEST 1 WD AT 302
        BCS     2$              ;BAD
        INSYNC                  ;****SUBTEST X3
        JSR     PC,STRAN        ;GET TO 3RD TRANSFER
        CMPMEM  WR1AT1          ;TEST 1 WD AT 301
        BCS     2$              ;BAD
        INSYNC                  ;****SUBTEST X4
        JSR     PC,STRAN        ;GET TO 4TH TRANSFER
        CMPMEM  WR1AT0          ;TEST 1 WD AT 300
        BCC     3$              ;O.K.
2$:     CFAULT   <1-WD RD REVERSE>

3$:     NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL  

;SEQ369

WR1AT0: MEMTAB  300,<WR,RQ0>


        
WR1AT1: MEMTAB  301,<WR,RQ1>


WR1AT2: MEMTAB  302,<WR,RQ2>


WR1AT3: MEMTAB  303,<WR,RQ3>



RDSTRT: CBUS    <ST,RST,CTOM>


        .EVEN


;SEQ370



;SEQ371



;SEQ372

.SBTTL          2-WD READ REVERSE TEST
.REM    %
        TEST 25 SETUP PUTS 2-WD REVERSE TRANSFERS TO 303,
302, 301 & 300 IN 100, 102 & 103.
%
I.025:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX  
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,REV2,4      ;LOAD 100-103
1$:     RTS     PC              ;RETURN

REV2:   CCW     CDTA,303,2,,REV


        CCW     CDTA,302,2,,REV


        CCW     CDTA,301,2,,REV


        CCW     CDTA,300,2,END,REV



.REM    %
        *****TEST 25 CHECKS REVERSE READ ADDRESSING OF TWO WORDS
FOR ALL CHANNELS.
%

T.025:  CHSTRT          ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,RDSTRT ;START/RESET/CTOM
        TSTREF                  ;GET TO JUMP
        INSYNC                  ;*****SUBTEST X1
        JSR     PC,STRAN2       ;GET TO FIRST RRANSFER
        CMPMEM  WR2AT2          ;TEST 2 WDS AT 302
        BCS     2$              ;BAD


;SEQ373

        INSYNC          ;SUBTEST X2
        JSR     PC,STRAN2       ;GET TO WND TRANSFER
        CMPMEM  WR2AT1          ;TEST 2 WDS AT 301
        BCS     2$              ;BAD
        INSYNC                  ;*****SUBTEST X3
        
        JSR     PC,STRAN2       ;GET TO 3RD TRANSFER
        CMPMEM  WR2AT0  ;TEST 2 WDS AT 300
        BCC     3$              ;O.K.
2$:     CFAULT  <2-WD RD REVERSE>

3$:     INSYNC                  ;****SUBTEST X4
        JSR     PC,STRAN        ;GET TO 4TH TRANSFER
        CMPMEM  WR1AT0          ;TEST 1 WD AT 300
        BCC     4$              ;O.K.
        CFAULT  <1ST OF 2 MEM REFS FOR 2-WD RD REVERSE>

4$:     JSR     PC,DOTRAN       ;GET TO 2ND MEM REF
        CMPMEM  WR1AT7          ;TEST 1 WD AT 277
        BCC     5$              ;O.KL.
        CFAULT  <2ND OF 2 MEM REFS FOR 2-WD RD REVERSE>

5$:     NEXTCH
        BEQ     6$              ;DONE?
        JMP     1$              ;NO, LOOP AGAIN
6$:     NORMAL


WR2AT0: MEMTAB  300,<WR,RQ0,RQ1>


WR2AT1: MEMTAB  301,<WR,RQ1,RQ2>


WR2AT2: MEMTAB  302,<WR,RQ2,RQ3>


WR1AT7: MEMTAB  277,<WR,RQ3>



;SEQ374



;SEQ375



;SEQ376

.SBTTL          3-WD READ REVERSE TEST
.REM    %
        TEST 26 SETUP PUTS 3-WD REVERSE TRANSFERS TO 303.
302, 301, & 300 IN 100, 101, 102, & 103.
%
I.026:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        JSR     PC,EPT100    
        LOAD    100,REV3,4      ;LOAD 100-103
1$:     RTS     PC              ;RETURN

REV3:   CCW     CDTA,303,3,,REV


        CCW     CDTA,302,3,,REV


        CCW     CDTA,301,3,,REV


        CCW     CDTA,300,3,END,REV



.REM    %
        *****TEST 26 CHECKS REVERSE READ ADDRESSING OF 3 WORDS
FOR ALL CHANNELS.
%
T.026:  CHSTRT          ;CHANNEL #
1$:     RSTMBX

        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,RDSTRT ;START/RESET/CTOM
        TSTREF                  ;FGET TO JUMP
        INSYNC                  ;****SUBTEST X1
        JSR     PC,STRAN3       ;GET TO FIRST TRANSFER
        CMPMEM  WR3AT1          ;TEST 3 WDS AT 301
        BCS     2$              ;BAD


;SEQ377

        INSYNC                  ;****SUBTEST X2
        JSR     PC,STRAN3       ;GET TO 2ND TRANSFER
        CMPMEM  WR3AT0          ;TEST 3 WDS AT 300
        BCC     3$              ;O.K.
2$:     CFAULT  <3-WD RD REVERSE>

3$:     INSYNC
        JSR     PC,STRAN2       ;GET TO 3RD TRANSFER
        CMPMEM  WR2AT0          ;TEST 2 WDS AT 300
        BCS     4$              ;BAD
        JSR     PC,DOTRAN       ;GET TO 2ND MEM REF
        CMPMEM  WR1AT7          ;TEST 1 WD AT 777
        BCS     6$              ;BAD
        INSYNC          ;****SUBTEST X4
        JSR     PC,STRAN                ;GET TO 4TH TRANSFER
        CMPMEM  WR1AT0          ;TEST 1 WD AT 300
        BCC     5$              ;O.K.
4$:     CFAULT  <1ST OF 2 MEM REFS FOR 3-WD RD REVERSE>


5$:     JSR     PC,DOTRN2       ;GET TO 2ND MEM REF
        CMPMEM  WR2AT6          ;TEST 2 WDS AT 276
        BCC     7$              ;O.K.
6$:     CFAULT  <2ND OF 2 MEM REFS FOR 3-WD RD REVERSE>

7$:     NEXTCH
        BEQ     8$              ;DONE?
        JMP     1$              ;NO, LOOP AGAIN
8$:     NORMAL


;SEQ378

WR3AT0: MEMTAB  300,<WR,RQ0,RQ1,RQ2>

WR3AT1: MEMTAB  301,<WR,RQ1,RQ2,RQ3>

WR2AT6: MEMTAB  276,<WR,RQ2,RQ3>


;SEQ379



;SEQ380



;SEQ381

.SBTTL          4-WD READ REVERSE TEST

.REM    %
        TEST 27 SETUP PUTS 4-WD REVERSE TRANSFERS TO 303,
302, 301 & 300 IN 100, 101, 102 & 103.
%
I.027:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,REV4,4      ;LOAD 100-103
1$:     RTS     PC              ;RETURN

REV4:   CCW     CDTA,303,4,,REV

        CCW     CDTA,302,4,,REV


        CCW     CDTA,301,4,,REV


        CCW     CDTA,300,4,END,REV


;SEQ382

.REM    %
        ****TEST 27 CHECKS REVERSE READ ADDRESSING OF 4 WORDS
FOR ALL CHANNELS.
%
T.027:  CHSTRT                  ;CHANNEL #
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        TSTREF                  ;GET TO JUMP
        INSYNC                  ;*****SUBTEST X1
        TSTREF                  ;GET TO FIRST COMMAND
        MOV     R4,R0           ;
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        JSR     PC,DOTRN3       ;GET TO FIRST TRANSFER
        CMPMEM  WR4AT0          ;TEST 4 WDS AT 300
        BCC     2$              ;O.K.
        CFAULT  <4-WD RD REVERSE>

2$:     INSYNC                  ;*****SUBTEST X2
        JSR     PC,STRAN3       ;GET TO 2ND TRANSFER
        CMPMEM  WR3AT0          ;TEST 3 WDS AT 300
        BCS     3$              ;BAD
        JSR     PC,DOTRAN       ;GET TO 2ND MEM REF
        CMPMEM  WR1AT7          ;TEST 1 WD AT 777
        BCS     5$              ;BAD
        INSYNC                  ;****SUBTEST X3
        JSR     PC,STRAN2       ;GET TO 3RD TRANSFER
        CMPMEM  WR2AT0          ;TEST 2 WDS AT 300
        BCS     3$              ;BAD
        JSR     PC,DOTRN2       ;GET TO 2ND MEM REF
        CMPMEM  WR2AT6          ;TEST 2 WDS AT 776
        BCS     5$              ;BAD


;SEQ383

        INSYNC                  ;****SUBTEST X4
        JSR     PC,STRAN        ;GET TO 4TH TRANSFER
        CMPMEM  WR1AT0          ;TEST 1 WD AT 300
        BCC     4$              ;O.K.
3$:     CFAULT  <1ST OF 2 MEM REFS FOR 4-WD RD REVERSE>

4$:     JSR     PC,DOTRN3       ;GET TO 2ND MEM REF
        CMPMEM  WR3AT5          ;TEST 3 WDS AT 275
        BCC     6$              ;O.K.
5$:     CFAULT  <2ND OF 2 MEM REFS FOR 4-WD RD REVERSE>

6$:     NEXTCH
        BEQ     7$              ;DONE?
        JMP     1$              ;NO, LOOP AGAIN
7$:     RSTMBX
        NORMAL

WR4AT0: MEMTAB  300,<WR,RQ0,RQ1,RQ2,RQ3>


WR3AT5: MEMTAB  275,<WR,RQ1,RQ2,RQ3>



;SEQ384



;SEQ385



;SEQ386

.SBTTL          CCW ALU CARRY TEST

.REM    %
        ****TEST 28 CHECKS THE CCW ALU FOR ALL CARRY CASES NOT CHECKED
IN PRECEDING TESTS.  THIS IS DONE BY PERFORMING A 0NE-WORD -CTOM
DATA TRANSFER FROM A MEMORY ADDRESS CHOSEN TO CARRY TO THE NEXT HIGH ORDER
ADDRESS BIT.  A STORE STATUS IS USED TO LOAD THE CCW CHA REG. WITH
THE INCREMENTED ADDRESS PORTION OF THE DATA TRANSFER WORD.  THE
TEST TERMINATES WHEN A FULL 22-BITS HAVE BEEN TESTED OR A NXM HAS
BEEN DETECTED.
%
T.028:  MOV     #403,ALUPAT     ;FIRST DATA TRANSFER FROM 104
        MOVB    #100,ALUPAT+2   ;
        CLR     R2              ;
1$:     RSTMBX
        CLR     R0              ;CHANNEL 0
        SETEPT  ,ALUPAT ;EPT GETS DATA TRANSFER
        CLR     R0              ;
        SIMBUS  ,ICCWF          ;START/RESET
        MEMRD   
        INSYNC
        MEMRD
        CLR     R0              ;
        SIMBUS  ,STADON         ;DONE/STORE
        MEMWR
        XQT     GETAPR          ;READ APR FLAGS
        READ17                  ;
        TBIT    25              ;NXM?

        BNE     4$              ;YES, TEST PASSES



;SEQ387

        CCWRD
        MOV     ALUPAT,EXAREA   ;COMPUTE EXPECTED DATA
        MOVB    R2,EXAREA+2
        ADD     #1,EXAREA       ;
        ADCB    EXAREA+2        ;
        BICB    #100,EXAREA+2   
        CMP22   ADRL,EXAREA     ;COMPARE RESULT
        BCC     2$              ;O.K.
        FAULT   <CCW ALU>

2$:     SEC                     ;SET C-BIT
        ROLB    ALUPAT          ;NEXT PATTERN
        BCS     3$              ;ABOVE 377 IN LOWER 8 BITS
        BPL     1$              ;BELOW 377 IN LOWER 8 BITS
        CLRB    ALUPAT+1        ;377 - CLEAR 400 BIT
        
3$:     ROLB    ALUPAT+1                ;COMPLETE MULTIPLY BY 2
        ROLB    R2              ;
        CMP     R2,#177         ;DONE?
        BGE     4$              ;YES
        BISB    R2,ALUPAT+2     ;NO, GET WORD COUNT RIGHT
        BR      1$              ;NEXT SUBTEST
4$:     NORMAL

ALUPAT: CCW     CDTA,403,1,END
.EVEN

;SEQ388



;SEQ389



;SEQ390

.SBTTL          ZERO-FILL EPT FETCH TEST

.REM    %
        ****TEST 29 CHECKS ZERO FILL DATA FETCH ADDRESSING OF FOUR
WORDS.
%
T.029:  RSTMBX
        CLR     R0              ;CHANNEL 0
        SETEPT  ,ZEROF4         ;ZERO-FILL XFER TO EPT
        CLR     R0              ;
        SIMBUS  ,ICCWF          ;START/RESET
        INSYNC                  ;****SUBTEST 1
        JSR     PC,DFETCH       ;GET TO TRANSFER
1$:     CMPMEM  WD4EPT          ;EXPECTED
        BCC     3$              ;O.K.
        FAULT   <IMPROPER ZERO-FILL WRITE>


3$:     RSTMBX
        NORMAL



WD4EPT: MEMTAB  3060,<RD,RQ0,RQ1,RQ2,RQ3>


ZEROF4: CCW     CDTA,0,4,END


        .EVEN


;SEQ391



;SEQ392



;SEQ393

.SBTTL          RH20 ERROR STATUS TEST
.REM    %
        ****TEST 30 CHECKS RH20 ERROR STATUS FOR ALL CHANNELS.
%


        ;INITIALIZATION FOR TEST 23 IS USED

T.030:  RSTMBX
        CHSTRT
1$:     INSYNC
        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        TSTREF                  ;GET PAST JUMP
        MOV     R4,R0           ;
        SIMBUS  ,STRTRD          ;START/CTOM
        MEMREF  3
        JSR     R5,COMSTA       ;TEST STATUS
        .WORD   RH20ER          ;
        BCC     2$              ;O.K.
        FAULT   <RH20 ERROR EXPECTED>

2$:     NEXTCH
        BNE     1$              ;LOOP UNTIL DONE
        NORMAL

STRTRD: CBUS    <ST,CTOM>


RH20ER: WD36            5402,0,102


;SEQ394



;SEQ395



;SEQ396

.SBTTL          FAST CHANNEL OVERRUN TEST
.REM    %
        TEST 31 SETUP LOADS A COMMAND LIST FOR TEST 31
%
I.031:  BR      1$              ;BYPASS LOAD IF LOOP
        RSTMBX
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,TRAN4,4     ;4 FOUR WORD XFERS TO 100-103
1$:     RTS     PC              ;RETURN


.REM    %
        *****TEST 31 CHECKS OVERRUN ERROR STATUS FOR CHANNELS 0-3.
%
T.031:  CHSTRT
        


1$:     CMP     R4,#4           ;FAST CHANNEL?
        BGE     4$              ;NO, DONE
        RSTMBX  
        INSYNC
        MOV     R4,R0           ;CURRENTL CHANNEL
        SIMBUS  ,ICCWF          ;START/RESET
        FIND    <162,31,0>      ;GET PAST JUMP FETCH (-SBUS ADR HOLD)
        FIND    <162,31,0>      ;GET READY (-SBUS ADR HOLD)
        MOV     #13.,R2          ;REQUEST COUNT
2$:     MOV     R4,R0           ;
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        DEC     R2              ;
        BGT     2$              ;
        MEMREF  10.             ;
         JSR    R5,COMSTA       ;TEST STATUS
        .WORD   OVRRUN         ;
        BCC     3$              ;O.K.
        FAULT   <OVERRUN EXPECTED>

3$:     NEXTCH
        BR      1$              ;NEXT CHANNEL
4$:     NORMAL


;SEQ397



;SEQ398



;SEQ399

.SBTTL          SLOW CHANNEL OVERRUN TEST

.REM    %
        TEST 32 SETUP LOADS COMMAND LISTS FOR TEST 32
        %
I.032:  BR      6$              ;BYPASS LOAD IF LOOP
        RSTMBX
        LOAD    1,L.032,2       ;LOAD EBOX INTERFERENCE LOOP
        MOV     #7,R4           ;CHANNEL #
1$:     MOV     R4,R0           ;
        CMP     R4,#3           ;FAST CHANNEL?
        BGT     2$              ;NO, SLOW
        SETEPT  ,JMP200         ;FAST COMMAND LISTS @ 200
        BR      3$              ;CONTINUE
2$:     SETEPT  ,JMP100 ;SLOW COMMAND LISTS @ 100
3$:     DEC     R4              ;NEXT CHANNEL
        BGE     1$              ;LOOP UNTIL DONE
4$:     LOAD    100,SLOLST,1    ;17-WORD XFER TO 100
        CLRB    ADRH            ;
        MOV     #200,ADRL       ;ZERO-WD XFERS TO 200-227
5$:     MOV     #ADRL,R1        ;
        MOV     #TRAN0,R0       ;DO DEPOSIT
        DPOS                    ;DO DEPOSIT
        INC     ADRL            ;NEXT ADDRESS
        CMP     ADRL,#227       ;DONE?
        BLE     5$              ;NO, LOOP
        DPOST                   ;PUT A HALT @ 230
                230,ZERO..      ;
6$:     RTS     PC              ;RETURN

        ;EBOX/ CHANNEL INTERFERENCE PROGRAM


        
L.032:  I10     AOS,,,20                ;DO READ-PAUSE-WRITE

        I10     JRST,,,1        ;LOOP FOREVER


;SEQ400

.REM    %
        ****TEST 32 CHECKS OVERRUN STATUS FOR CHANNELS 4-7.  IT ALSO
TESTS RAM ADDRESSING FOR THE OVERRUN BIT BY CHECKING FOR INTERFERENCE
BETWEEN THE RAM ADDRESS AND ITS COMPLEMENT.
%
T.032:  CMP     TCWRT0,#4       ;DMA20 OR MOS MEMORY?
        BMI     1$              ;N9O
        TST     CLKRAT  ;CLOCK-RATE 0?
        BNE     7$              ;NO, APPARENT BANDWIDTH TOO HIGH
1$:     MOV     #4,R4           ;STARTING CHANNEL IS 4
        JSR     R5,CSTRT1       ;SELECT CHANNEL
        TST     TEND.           ;LOOP ON CHANNEL?
        BEQ     2$              ;NO, CONTINUE
        CMPB    FAILCH,R4       ;CORRECT CHANNEL?
        BNE     7$              ;NO, RETURN
2$:     MOV     R4,R3           ;GET COMPLEMENT CHANNEL IN R3
        COM     R3      ;GET COMPLEMENT CHANNEL IN R3
     
        BIC     #177770,R3      ;
        RSTMBX
        INSYNC

        INSYNC  
        DEC     R5              ;****SUBTEST X1
        MOV     R4,R0           ;TEST CHANNEL #
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        MOV     #1,RUNJRS       ;SET STARTING PC
        XQT     RUNJRS          ;EXECUTE THE JRST
        CMP     TCWRT0,#4       ;DMA202
        BEQ     3$              ;YES, RD-PSE-WR TEST FEATURE NOT
                                ;IMPLEMENTED
        DFXCTT                  ;SET RUN & CONTINUE
                SETRUN
        DFXCTT
                CONBUT
3$:     TWAIT   1
        MOV     R3,R0           ;INTERFERING CHANNEL #
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        MOV     #17,R2          ;REQUEST COUNT
4$:     MOV     R4,R0           ;TEST CHANNEL
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        DEC     R2              ;COUNT REQUEST
        BGT     4$              ;DONE 17?
        MEMREF  14.             ;YES, ALLOW TIME TO FINISH


;SEQ401

        JSR     R5,COMSTA       ;TEST STATUS 1 FOR OVERRUN
        .WORD   RUNOVR          ;
        BCC     5$              ;O.K.
        FAULT   <OVERRUN EXPECTED>

5$:     INC     R5              ;****SUBTEST X2
        PUSH    R4              ;SAVE TEST CHANNEL #


        MOV     R3,R4           ;GET INTERFERING CHANNEL
        JSR     R5,COMSTA       ;TEST STATUS 1 FOR NO ERROR
        .WORD   ZERO..          ;;
        POP     R4              ;RESTORE TEST CHANNEL #

        BCC     6$              ;O.K.
        FAULT   <NO ERROR EXPECTED>

6$:     NEXTCH
        BNE     2$              ;DONE?
7$:     NORMAL                  ;YES


SLOLST: CCW     CDTA,300,17,END


OVRRUN: WD36    5400,2000,0102


RUNOVR: WD36    5400,2000,0101


        .EVEN


;SEQ402



;SEQ403




;SEQ404

.SBTTL          LAST TRANSFER ERROR/NO ERROR STATUS TEST
.REM    %
        ****TEST 33 CHECKS STATUS FOR A LAST-TRANSFER ERROR FOLLOWED
BY A NO ERROR TRANSFER FOR EACH CHANNEL.
%
T.033:  CHSTRT
        TST     CHNNXM  ;CAN I GENERATE A NXM?
        BEQ     4$              ;NO BYPASS THIS TEST
1$:     RSTMBX
        MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,JMP100         ;CONDITION
        DPOST                   ;1-WD NXM TO 100
                100,LSTTRA      ;
        INSYNC                  ;*****SUBTEST X1
        MOV     R4,R0           ;
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        FIND    <162,31,0>      ;GET PAST JUMP FETCH (-SBUS ADR HOLD)
        FIND    <162,31,0>      ;GET READY (-SBUS ADR HOLD)
        MOV     R4,R0           ;GET CURRENT CHANNEL
        SIMBUS  ,LSTSIM         ;CBUS REQUEST/DONE
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
     TWAIT      1
        JSR     R5,COMSTA       ;TEST STATUS
        .WORD   LSTERR          ;
        BCC     2$              ;O.K.
        FAULT   <LAST-TRANSFER ERROR EXPECTED>


;SEQ405

2$:     MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,JMP100         ;CONDITION EPT
        DPOST
                100,NOERR       ;
        INSYNC                  ;****SUBTEST X2
        MOV     R4,R0           ;
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        FIND    <162,31,0>      ;GET PAST JUMP FETCH (-SBUS ADR HOLD)
        FIND    <162,31,0>      ;GET READY (-SBUS ADR HOLD)
        MOV     R4,R0           ;GET CURRENT CHANNEL
        SIMBUS  ,LSTSIM         ;CBUS REQUEST/DONE
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        TWAIT   1
        JSR     R5,COMSTA       ;TEST STATUS
        .WORD   ZERO..          ;
        BCC     3$              ;O.K.
        FAULT   <NO ERROR EXPECTED>

3$:     NEXTCH  
        BNE     1$              ;DONE?
4$:     NORMAL                  ;YES


;SEQ406

LSTTRA: CCW     CDTA,17777777,1,END


NOERR:  CCW     CDTA,300,1,END


LSTSIM: CBUS    <SLW,DON>


LSTERR: WD36    5204,0000,0101


        .EVEN


;SEQ407



;SEQ408



;SEQ409


.SBTTL          LAST-TRANSFER ERROR/ STORE STATUS TEST
.REM    %
        *****TEST 34 CHECKS STATUS FOR A LAST-TRANSFER ERROR FOLLOWED
BY ANOTHER LAST TRANSFER ERROR TO TEST CMD TOGGLED & CMD STORED.
%
T.034:  CHSTRT
        TST     CHNNXM          ;CAN I GENERATE A NXM?
        BEQ     3$              ;NO, BYPASS THIS TEST
1$:     RSTMBX
        INSYNC  
        MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,JMP100 ;CONDITION EPT
        DPOST                   ;1-WD NXM TO 100
                100,LSTTRA      ;
        MOV     R4,R0           ;
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM
        FIND    <162,31,0>              ;GET PAST JUMP FETCH (-SBUS ADR HOLD)
        FIND    <162,31,0>      ;GET READY (-SBUS ADR HOLD)
        MOV     R4,R0           ;GET CURRENT CHANNEL
        SIMBUS  ,LSTSIM         ;SBUS REQUEST/DONE
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        TWAIT   1               ;WAIT FOR ERROR LOGOUT
        MOV     R4,R0           ;CURRENT CHANNEL
        SETEPT  ,JMP100         ;CONDITION EPT


;SEQ410

        MOV     R4,R0           ;CURRENT CHANNEL
        SIMBUS  ,RDSTRT         ;START/RESET/CTOM


        FIND    <162,31,0>      ;GET PAST JUMP FETCH (-SBUS ADR HOLD)
        FIND    <162,31,0>      ;GET READY (-SBUS ADR HOLD)
        MOV     R4,R0           ;GET CURRENT CHANNEL
        SIMBUS  ,SIMLST         ;CBUS REQUEST/DONE/STORE
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        TWAIT   1
        JSR     R5,COMSTA       ;TEST STATUS
        .WORD   LSTERR          ;
        BCC     2$              ;O.K.
        FAULT   <LAST-XFER ERROR EXPECTED>

2$:     NEXTCH  
        BNE     1$              ;DONE?
3$:     NORMAL                  ;YES


SIMLST: CBUS    <SLW,DON,STR>


        .EVEN


;SEQ411



;SEQ412




;SEQ413

.REM    %
        END PASS CONTORL
%
ENDPAS: TSTB    XMODE           ;XOR MODE?
        BEQ     2$              ;NO
        RSTMBX                  ;YES, INITIALIZE CHANNEL BUFFER
        JSR     PC,EPT100       ;ALL COMMAND LISTS @ 100
        LOAD    100,SLOLST,1     ;100 GETS A 17-WD XFER
        MOV     #300,ADRL               ;ZERO A CORE BUFFER
        MOV     #ADRL,R1        ;
        MOV     #17.,R0 ;
        D10ZRO                  ;
        MOV     #7,R4           ;CHANNEL #
1$:     MOV     R4,R0           ;
        SIMBUS  ,ICCWF          ;START/RESET
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        TWAIT   1               ;WAIT FOR BUFFER TO FILL
        MOV     R4,R0           ;
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        MEMREF  5               ;FILL LAST LOCATION
        DEC     R4              ;NEXT CHANNEL
        BGE     1$              ;LOOP UNTIL BUFFER CLEARED


;SEQ414

2$:     SM                      ;GET MACHINE RUNNING
        TST     TRCMEM          ;USING DMA20?
        BEQ     3$              ;NO
        TST     BANDW           ;ALREDY ONE-BUS MODE?
        BNE     3$              ;YES, DON;'T CHANGE IT
        PMSG    <RESTORING DMA20 CONFIGURATION\>

        MOVB    CONTAB+16.,DMABAK+3
        BISB    #BIT6,DMABAK+3  ;SBUS DIAG NOW HAS BUS MODE
        MOV     #4,TSTCON       ;
        SBUSDG  DMABAK          ;RESTORE BUS MODE AT ENTRY
                                ;11023
3$:     TST     TEST            ;11024
        BEQ     5$              ;11025
        JSR     PC,TEST         ;11026
        TST     TEST            ;11027
        BNE     5$              ;11028
        CLR     FAILCH          ;11029
        CLR     NIPASS          ;11030
        CLR     IMEMCF          ;11031
        CLR     TEST            ;11032
        CLR     BANDW           ;11033
        GETVER                  ;11034
                                ;11035
        PMSG    <ADD1>          ;11036
        MOV     $$FF,R0         ;11037
        PNTOCS                  ;11038
        PNTVER                  ;11039
        PCRLF                   ;11040
        MOV     TEST,R0         ;11041
                                ;11042
        BCC     5$              ;11043
        PMSG    <ADD2345678901234567890-12345>
        PRGHLT                  ;11045
        BR      5$              ;11046
                                ;11047
DEBUG=  0                       ;DEFINE DEBUG
5$:     RTS     PC              ;RETURN
TEST:   .WORD   0               ;FAKE IT
DMABAK: WD36    0100,4000,0000  ;CONTROLLER & BUS MODE INSERTED



        .EVEN


;SEQ415

.SBTTL          CHANNEL CONTROL SUBROUTINES

.REM    %
        SUBROUTINE TO SET ALL CHANNEL EPT LOCATIONS TO START AT 100.
%
EPT100: PUSH    <R1,R2>


        MOV     #7,R2           ;# OF CHANNELS
1$:     MOV     R2,R0           ;CURRENT CHANNEL
        SETEPT  ,JMP100         ;
        BCS     2$              ;ERROR
        DEC     R2              ;NEXT CHANNEL
        BGE     1$              ;LOOP UNTIL DONE
2$:     POP     <R2,R1>



        RTS     PC              ;RETURN

JMP100: CCW     CJMP,100


        .EVEN

.REM    %
        SUBROUTINES TO FETCH A CCW & GENERATE THE PROPER #
 OF REQUESTS TO CAUSE A CTOM REFERENCE.
%
        ;ONE REQUEST REQUIRED
STRAN:  TSTREF                  ;GET TO COMMAND

DOTRAN: MOV     R4,R0           ;CURRENT CHANNEL
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        TSTREF                  ;GET TO TRANSFER
        BCS     NOTRAN          ;NO TRANSFER DETECTED
        RTS     PC              ;RETURN

        ;2 REQUESTS REQUIRED
STRAN2: TSTREF                  ;GET TO COMMAND
DOTRN2:        MOV     R4,R0           ;CURRENT CHANNEL
        JSR     R5,SLOWRQ       ;CBUS REQUEST
        BR      DOTRAN  ;DO 2ND REQUEST

        ;3 REQUESTS REQUIRED
STRAN3: TSTREF                  ;GET TO COMMAND
        
DOTRN3:        MOV     R4,R0   ;CURRENT CHANNEL
        JSR     R5,SLOWRQ       ;CBUS
        BR      DOTRN2          ;DO 2 MORE REQUESTS


;SEQ416

.REM    %
        SUBROUTINES TO FETCH A COMMAND WORD AND /OR STEP TO THE POINT
THAT SBUS ADR HOLD IS TRUE FOR THE RESULTING TRANSFER
%
DFETCH: TSTREF                  ;FETCH COMMAND WORD
        BCS     NOTRAN          ;NO FETCH
SECREF: TSTREF                  ;FETCH THE DATA
        BCS     NOTRAN          ;NO DATA
        RTS     PC              ;RETURN


.REM    %
        FAULT CALLER FOR MISSING DATA TRANSFERS
%
NOTRAN: CHTYP
        ERCRLF
        ERRMSG  <NO DATA XFER   ERROR PC = >
        POP     R0              ;GET PC


        SUB     #4,R0           ;
        ERROCS                  ;PRINT VALUE
        FAULT

.REM    %
        SUBROUTINE TO CLEAR MEMORY ERROR STATUS
%
CLRERR: MOV     #4,TSTCON       ;FIRST RESET DMA20
        SBUSDG  CL05
        MOV     TCWRT0,TSTCON   ;THEN THE CONTROLLER USED
        SBUSDG  CL05
        RTS     PC              ;RETURN TO CALLER

        .SBTTL  MBOX TEST SUBROUTINE LIBRARY  15-SEP-78
.REM    %
        TRAP HANDLER.  EMULATES AN R5 CALLING CONVENTION.
%
$TRAP:  MOV     R5,$SAVE        ;SAVE R5
        MOV     (SP),R5         ;GET TRAP PC
        MOVB    -2(R5),R5       ;GET TRAP #
        CMP     R5,#150         ;VALID TRAP?
        BLE     1$              ;YES
        CLR     R5              ;NO,UNDEFINED
1$:     ASL     R5              ;MULTIPLY BY 2
        MOV     $TRBAS(R5),$LINK        ;GET ENTRY POINT
        POP     R5              ;TRAP PC TO R5

        PUSH    #2$

        RTT                     ;RESTORE USER STATUS
2$:     PUSH    $SAVE           ;ORIGINAL R5 TO STACK

        JMP     @$LINK          ;CALL PROGRAM

$LINK:  .WORD   0               ;TRAP LINKAGE SCRATCH
$SAVE:  .WORD   0               ;R5 FOR CALLING CONVENTION

$UNDEF: PMSG    <UNDEF. TRAP AT PC >
     

        MOV     R5,R0
        DEC     R0              ;
        DEC     R0              ;
        PNTOCS                  ;PRINT TRAP LOCATION
        POP     R5              ;RESTORE R5

        FATAL


;SEQ312

$TRBAS: .WORD   $UNDEF  ;ILLEGAL TRAP
        .WORD   CMPS.   ;TRAP 1
        .WORD   CMPSR.  ;TRAP 2
        .WORD   $UNDEF  ;TRAP 3 RESERVED
        .WORD   SAV.3   ;TRAP 4
        .WORD   RST.3   ;TRAP 5
        .WORD   SAV.5   ;TRAP 6
        .WORD   RST.5   ;TRAP 7
        .WORD   RUNPRG  ;TRAP 10
        .WORD   CONTIN  ;TRAP 11
        .WORD   RUNBIG  ;TRAP 12
        .WORD   STEP    ;TRAP 13
        .WORD   FIND    ;TRAP 14
        .WORD   EVENT   ;TRAP 15
        .WORD   STEP10  ;TRAP 16
        .WORD   STPCON  ;TRAP 17
        .WORD   BRST    ;TRAP 20
        .WORD   $UNDEF  ;TRAP 21 RESERVED
        .WORD   $UNDEF  ;TRAP22
        .WORD   $UNDEF  ;TRAP 23 RESERVED
        .WORD   $UNDEF  ;TRAP 24
        .WORD   $UNDEF  ;TRAP 25 RESERVED
        .WORD   MSKDF   ;TRAP 26
        .WORD   MSKDFR  ;TRAP 27
        .WORD   $UNDEF  ;TRAP 30 RESERVED
        .WORD   $UNDEF  ;TRAP 31 RESERVED
        .WORD   RANGE   ;TRAP 32
        .WORD   $UNDEF  ;TRAP 33 RESERVED
        .WORD   CMP22R  ;TRAP 34
        .WORD   CMP22   ;TRAP 35
        .WORD   CMPMEM  ;TRAP 36
        .WORD   LOAD    ;TRAP 37
        .WORD   $UNDEF  ;TRAP 40 RESERVED
        .WORD   $UNDEF  ;TRAP 41 RESERVED
        .WORD   $UNDEF  ;TRAP 42 RESERVED
        .WORD   $UNDEF  ;TRAP 43 RESERVED
        .WORD   READ17  ;TRAP 44
        .WORD   $UNDEF  ;TRAP 45 RESERVED
        .WORD   $UNDEF  ;TRAP 46
        .WORD   XQT     ;TRAP 47
        .WORD   MEMRST  ;TRAP 50     
        .WORD   RSTMBX  ;TRAP 51
        .WORD   $UNDEF  ;TRAP 52 RESERVED
        .WORD   $UNDEF  ;TRAP 53 RESERVED
        .WORD   GETMEM  ;TRAP 54
        .WORD   $UNDEF  ;TRAP 55 RESERVED
        .WORD   SBUSDG  ;TRAP 56
        .WORD   $UNDEF  ;TRAP 57 RESERVED
        .WORD   $UNDEF  ;TRAP 60 RESERVED
        .WORD   $UNDEF  ;TRAP 61
        .WORD   $UNDEF  ;TRAP 62
        .WORD   $UNDEF  ;TRAP 63
        .WORD   $UNDEF  ;TRAP 64


;SEQ313

        .WORD   $UNDEF  ;TRAP 65 RESERVED
        .WORD   $UNDEF  ;TRAP 66 RESERVED
        .WORD   $UNDEF  ;TRAP 67 RESERVED
        .WORD   $UNDEF  ;TRAP 70 RESERVED
        .WORD   $UNDEF  ;TRAP 71 RESERVED
        .WORD   SOBAC   ;TRAP 72
        .WORD   $UNDEF  ;TRAP 73 RESERVED
        .WORD   PNTUML  ;TRAP 74
        .WORD   CMP.E   ;TRAP 75
        .WORD   CMP.F   ;TRAP 76
        .WORD   ISORST  ;TRAP 77
        .WORD   $UNDEF  ;TRAP 100
        .WORD   $UNDEF  ;TRAP 101
        .WORD   $UNDEF  ;TRAP 102
        .WORD   $UNDEF  ;TRAP 103
        .WORD   $UNDEF  ;TRAP 104
        .WORD   $UNDEF  ;TRAP 105
        .WORD   $UNDEF  ;TRAP 106
        .WORD   $UNDEF  ;TRAP 107 RESERVED
        .WORD   $UNDEF  ;TRAP 110
        .WORD   $UNDEF ;TRAP 111
        .WORD   $UNDEF  ;TRAP 112
        .WORD   $UNDEF  ;TRAP 113 RESERVED
        .WORD   $UNDEF  ;TRAP 114 RESERVED
        .WORD   BACKPL  ;TRAP 115
        .WORD   CMPSG.  ;TRAP 116
        .WORD   CHRCHK  ;TRAP 117
        .WORD   CHRISO  ;TRAP 120
        .WORD   $UNDEF  ;TRAP 121
        .WORD   $UNDEF  ;TRAP 122 RESERVED
        .WORD   $UNDEF  ;TRAP 123
        .WORD   SAVMCN  ;TRAP 124
        .WORD   PNTID   ;TRAP 125
        .WORD   GETVER  ;TRAP 126
        .WORD   PNTVER  ;TRAP 127
        .WORD   TWAIT   ;TRAP 130
        .WORD   CCWRD   ;TRAP 131
        .WORD   SETEPT  ;TRAP 132
        .WORD   CHSEL   ;TRAP 133
        .WORD   SIMBUS  ;TRAP 134
        .WORD   MEMTST  ;TRAP 135
        .WORD   TTICH   ;TRAP 136
        .WORD   CHTYP   ;TRAP 137
        .WORD   TSTREF  ;TRAP 140
        .WORD   STACOM  ;TRAP 141
        .WORD   STOPCH  ;TRAP 142
        .WORD   STARCH  ;TRAP 143
        .WORD   CHSYNC  ;TRAP 144
        .WORD   MEMRD   ;TRAP 145
        .WORD   MEMWR   ;TRAP 146
        .WORD   MEMREF  ;TRAP 147
        .WORD   STAT2   ;TRAP 150



;SEQ314

.SBTTL          MASTER RESET TEST SUBROUTINE    19-AUG-76
.REM    %
        
RSTCHK - ROUTINE TO PERFORM AN MBOX RESET & TEST THE RESULT.
RETURNS ONLY IF THE RESET IS PROPER.  RESTORES MR RESET TO THE
CONDITION DETERMINED BY THE RSTMBX FLAGS.  THE FOLLOWING SIGNALS
ARE MASKED FROM THE SNAPSHOT:

        -A CHANGE COMING
        -B CHANGE COMING
         CAM SEL 1, 2 (SIGNALS)
         CBUS PAR LEFT TE
         CBUS PAR RIGHT TE
         CSH CCA INVAL CSH
         CSH CCA VAL CORE
         CSH 0,1,2 & 3 ANY VAL (SIGNALS)
        -CSH 0,1,2, & 3 ANY WR SIGNALS
         CSH 0,1,2, & 3 DIR PAR ODD (SIGNALS)
         CSH LRU 1 & 2 (SIGNALS)
         CSH USE ADR 2,3 & 4 (SIGNALS)
         CSH USE IN 2,3 & 4 (SIGNALS)
         MB PAR BIT IN
        MEM ADR PAR
         PAG MB 00-17 PAR
         PAG MB 18-35 PAR
%
RSTCHK: PUSH    PMAFLG          ;SAVE STATE OF LOAD ERG FLAG

        INC     PMAFLG          ;SET LOAD ERG FROM PMA
        JSR     PC,SPCRST       ;DO SPECIAL RESET CONTROL
        POP     PMAFLG          ;RESTORE LOAD ERG FLAG

        CLR     SCFLAG          ;MBOX SNAPSHOT ONLY
        PUSH    MMASK           ;SAVE DEFAULT MASK POINTER

        SETMSK  RSTMSK      
        MOV     #RSTTAB,R0      ;POINT TO SCAN TABLE
        JSR     R5,SNAP         ;DO SNAPSHOT
        POP     MMASK           ;RESTORE DEFAULT MASK

        BCS     1$              ;ERROR - GO TO FAULT
        DFVMA                   ;READ VMA
        MOVB    2(R0),ERGRST+2  ;PUT BITS 14-26 IN EXPECTED
        BIC     #300,ERGRST+2   ;
        MOVB    1(R0),ERGRST+1  ;
        BIC     #BIT8,ERGRST    ;CLEAR BIT 27
        MSKDF   167,ERGRST,ERGMSK
        BCC     2$              ;O.K.


;SEQ315

1$:     ERRMSG  <  CALL PC = >

        MOV     R5,R0           ;GET USER PC
        SUB     #4,R0           ;
        ERROCT                  ;PUT IT ON ERROR STACK
        ERCRLF
        CLR     R5              ;CLEAR SUBTEST #
        FAULT   <MR ERROR>

2$:     TST     PMAFLG          ;ENABLE PMA?
        BNE     3$              ;YES
        JMP     RSTMBX          ;NO, RESET & RETURN
3$:     TST     CSHFLG          ;SET LOOK & LOAD?
        BEQ     4$              ;NO
        JMP     CSHSET          ;YES, DO IT & RETURN
4$:     RTS     R5              ;RETURN


;SEQ316

        ;TABLE OF VALUES FOR MBOX MASTER RESET (+ 1 TICK).

RSTTAB: .BYTE   0               ;UNUSED
        .BYTE   050             ;163 27-34
        .WORD   016024          ;160 20-35
        .BYTE   014             ;160 12-19
        .BYTE   050             ;164 27-34
        .WORD   076700          ;161 20-35
        .BYTE   021             ;161 12-19
        .BYTE   070             ;165 27-34
        .WORD   004004          ;162 20-35
        .BYTE   021             ;162 12-19
        .BYTE   6               ;166 27-34
        .WORD   026722          ;170 20-35
        .WORD   035722          ;171 20-35
        .WORD   035230  ;172 20-35
        .WORD   035322          ;173 20-35
        .WORD   035654          ;174 20-35
        .WORD   025355          ;175 20-35
        .WORD   035365          ;176 20-35
        .WORD   031305          ;177 20-35



        ;TABLE OF MASK BITS FOR MBOX MASTER RESET (+ 1 TICK)


RSTMSK: .BYTE   0                       ;UNUSED
        .BYTE   200             ;163 27-34
        .WORD   001000          ;160 20-35
        .BYTE   002             ;160 12-19
        .BYTE   0               ;164 27-34
        .WORD   0               ;161 20-35
        .BYTE   010             ;161 12-19
        .BYTE   302             ;165 27-34
        .WORD   002010          ;162 20-35
        .BYTE   010             ;162 12-19
        .BYTE   0               ;166 27-34
        .WORD   100000          ;170 20-35
        .WORD   100000          ;171 20-35
        .WORD   142000          ;172 20-35
        .WORD   142000          ;173 20-35
        .WORD   142020          ;174 20-35
        .WORD   142020          ;175 20-35
        .WORD   142010          ;176 20-35
        .WORD   142000          ;177 20-35

ERGRST: WD36    0,0,0           ;BUFFER FOR EXPECTED ERG DATA

ERGMSK: WD36    3770,0,0        ;MASK PAGE FAIL CODES





;SEQ317

.REM    %
ISORST - ROUTINE TO TRANSFER CONTROL TO HE MBOX MASTER RESET
ISOLATION ROUTINE.
%
ISORST: MOV     TESTSP,SP               ;RESET THE STACK POINTER
1$:     PMSG    <P A4.A11>              ;SETUP FILENAME


        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG               ;LOAD PROGRAM
        BCC     2$              ;LOAD ERROR?
        PMSG    <MOUNT A4.A11  HC WHEN READY\>


        PRGHLT                  ;LOOKUP OR LOAD ERROR
        BR      1$              ;TRY AGAIN
2$:     JMP     ISOPRM          ;GO TO DIACON FOR CALL



.SBTTL          CHANNEL RESET TEST SUBROUTINE 2-JUN-77
.REM    %
        
CHRCK - ROUTINE TO TEST FOR PROPER CHANNEL RESET.  RETURNS ONLY 
IF THE RESET IS PROPER.  THE STATE OF THE CHANNEL LOGIC IS TESTED
AT THE T3 FOLLOWING A MASTER REST.  THE CLOCK IS THEN BURSTED TO
THE NEXT T2, AND THE FOLLOWING ITEMS ARE CHECKED FOR EACH CHANNEL
UNTIL ALL RESETS HAVE BEEN HONORED:

        CCW RAM ADR 1, 2 & 4
        -CRC RESET IN
        -------------------------
        CRC DONE IN
        CRC ERR IN
        CRC READY IN
        CRC LAST WORD IN
        CRC REVERSE IN
        -------------------
        CRC MEM PTR0-3
        -CH ADR 0C-3C
        CRC ACT CTR 0R-2R
        CRC OP CODE 00 & 01
        ----------------------
        CH CTOM
        CRC PTR DIF = 09
        CRC AF REQ EN

THE STATE OF THE CHANNEL LOGIC IS THEN TESTED TO ENSURE THAT ALL
KNOWN SIGNALS ARE CORRECT AND THAT NO CHANNEL ACTIVITY OCCURS.
THE FOLLOWING ITEMS ARE STILL IN UNKNOWN STATES, AND TEHY ARE THERE-
FORE MASKED FROM THE SNAPSHOT:

         
         CCL CH MB SEL 1&2 (SIGNALS)
         CCL ODD WC PAR
         CCL WD GE4
         CCL WC=0,1,2&3 (SIGNALS)
        -CCW ACT CTR 0, 1&2 EN (SIGNALS)
        CCW ALU C2 OUT
         CCW ALU C8 OUT
         CCW CHA 14-35
         CCW MEM ADR=0
         CCW ODD ADR PAR
         CRC CH BUF ADR 0-6
%


;SEQ436


CHRCHK: PUSH    R1

        MOV     ERSP..,R0               ;GET ERROR STACK POIONTER
        PUSH    R0              ;SAVE ERROR STACK POINTER
        MOV     #FTPRM,(R0)+    ;PUT TRANSPARENT ENTRY ON STACK
        MOV     #CERRWD,(R0)    ;PUT ERROR ID POINTER ON STACK
        CLR     CERRWD          ;CLEAR ERROR ID
        MRESET                  ;MASTER RESET
        BRST    4               ;GET TO T3
        PUSH    CMASK           ;SAVE DEFAULT MASK
        MOV     #CHRM1,CMASK    ;SET MASK POINTER
        MOV     #2,SCFLAG       ;SET CHANNEL SHANPSHOT FLAG
        MOV     #CHRD1,R0       ;POINT TO SNAPSHOT DATA
        JSR     R5,SNAP         ;CHECK MR STATE
        BCS     8$              ;ERROR, GO TO COMMON ERROR CODE
        BRST    3               ;GET TO T2
        INC     CERRWD          ;ERR I.D. = 1
        CLR     R1              ;FIRST RAM ADR=1
1$:     INC     R1              ;COMPUTE RAM ADR
        BIC     #177770,R1      ;
        CMP.S           RAMADR,R1               ;CHK CRC RESET IN & RAM ADR
        BCS     8$              ;BAD, GO TO COMMON ERROR CODE
        CMP.S   RAMIN,0         ;TEST RAM INPUTS

        BCS     7$              ;BAD, GO TO COMMON ERROR CODE
        MOV     R1,R0           ;DONE WITH RAMS?
        BEQ     4$              ;YES



;SEQ437

        ROR     R0              ;EVEN OR ODD ADDRESS?
        BCS     2$              ;
        CMP.S   CHCTOM,0        ;EVEN, CHK -CTOM & RELATED
        BCS     7$              ;BAD
        BR      3$              ;O.K.
2$:     CMP.S   CHCTOM,7                ;ODD, CHK CTOM & RELATED
        BCS     7$              ;BAD
3$:     BRST    4               ;NEXT RAM ADDRESS
        BR      1$              ;LOOP AGAIN
4$:     MRESET                  ;START ANOTHER SCAN
        BRST    3               ;GET TO T2
5$:     BRST    4               ;
        INC     R1              ;NEXT RAM ADDRESS
        BIC     #177770,R1      ;
        CMP.S   RAMOUT,177      ;TEST RAM OUTPUTS
        BCS     7$              ;BAD
        TST     R1              ;LAST ONE CHECKED?
        BGT     5$              ;NO, LOOP AGAIN
6$:     INC     CERRWD          ;ERROR I.D. = 2
        MOV     #CHRM2,CMASK    ;SET NEW MASK POINTER
        MOV     #CHRD2,R0       ;POINT TO SNAPSHOT DATA
        JSR     R5,SNAP         ;CHECK CHANNEL RESET DONE
        BCC     9$              ;O.K.


;SEQ438

7$:     ERRMSG  <RAM ADR = >
        MOV     R1,R0           ;RAM ADDRESS TO ERROR STACK
        ERROCS
8$:     POP     CMASK           ;RESTORE DEFAULT MASK
        ERRMSG  <   CALL PC = >
        MOV     R5,R0           ;
        SUB     #4,R0           ;
        ERROCT                  ;CALL PC TO ERROR STACK
        ERCRLF                  ;
        CLR     R5              ;CLEAR SUBTEST #
        FAULT   <CHANNEL RESET>
9$:     POP     CMASK           ;RESTORE DEFAULT MASK
10$:    POP     ERSP..          ;RESTORE ERROR STACK
        POP     R1              
        RTS     R5              ;RETURN



;SEQ439



        ;CHANNEL MASTER RESET MASK (+4 TICKS)

CHRM1:  .BYTE   013,206,013             ;170 (12-19,04-11,00-03)
        .BYTE   000,204,017     ;171
        .BYTE   000,360,017     ;172
        .BYTE   012,176,017     ;173
        .BYTE   000,376,015     ;174
        .BYTE   001,376,010     ;175
        .BYTE   000,336,017     ;176
        .BYTE   010,216,017     ;177

        .EVEN

        ;CHANNEL MASTER RESET DATA (+4 TICKS)
CHRD1:  .BYTE   040,000,000     ;170 (12-19,04-11,00-03)
        .BYTE   203,000,000     ;171
        .BYTE   000,016,000     ;172
        .BYTE   001,201,000     ;173
        .BYTE   000,000,000     ;174
        .BYTE   040,000,007     ;175
        .BYTE   101,000,000     ;176
        .BYTE   102,000,000     ;177

        ;ITEMS TESTED FOR EACH RAM ADDRESS

RAMADR: DF.     170             ;CRC RESET IN
        BP.     <1>             ;
        DF.     177             ;CCW RAM ADR
        BP.     <7,6,-5>        ;
RAMIN:  DF.     172             ;CRC IN SIGNALS
        BP.     <1,2,3,4>       ;READY, LAST WORD, ERR, REVERSE
        DF.     170             ;CRC DONE IN
        BP.     <-3>            ;


;SEQ440

RAMOUT: DF.     176             ;CRC MEM PTR0-3
        BP.     <1,2,3,4>       ;
        DF.     174             ;CRC OP CODE 00 & 01
        BP.     <3,4>           ;
        DF.     177             ;-CRC CH ADR 0C-3C
        BP.     <1,2,3,4>       ;
        DF.     173             ;CRC ACT CTR 0R-2R
        BP.     <1,2,-3>        ;
CHCTOM: DF.     174             ;CH CTOM
        BP.     <14>            ;
        DF.     177             ;CRC PTR DIF=0
        BP.     <0>             ;
        DF.     175             ;CRC AF REQ EN
        BP.     <-4>            ;
        .EVEN


;SEQ441

;CHANNEL RESET MASK (MR +35 TICKS)
CHRM2:  .BYTE   013,006,010     ;170 (12-19,04-11,00-03)
        .BYTE   000,004,010     ;171
        .BYTE   000,160,010     ;172
        .BYTE   012,176,010     ;173
        .BYTE   000,176,010     ;174
        .BYTE   000,176,010     ;175
        .BYTE   000,176,010     ;176
        .BYTE   000,016,000     ;177
        .EVEN

        ;CHANNEL RESET DATA (MR +35 TICKS)
CHRD2:  .BYTE   000,000,002     ;170 (12-19,04-11,00-03)
        .BYTE   003,000,000     ;171
        .BYTE   000,017,000     ;172
        .BYTE   201,000,007     ;173
        .BYTE   000,000,002     ;174
        .BYTE   100,200,007     ;175
        .BYTE   001,000,000     ;176
        .BYTE   002,200,017     ;177
        .EVEN

CERRWD: .WORD   0               ;ERROR I.D. FOR ISOLATION
.REM    %
        CHRISO - ROUTINE TO TRANSFER CONTROL TO THE CHANNEL RESET ISOLATION
ROUTINE.
%
CHRISO: MOV     TESTSP,SP       ;RESET THE STACK POINTER
1$:     PMSG    <P C3.A11>      ;SETUP FILENAME
        MOV     #-1,R0          ;POINT TO OUTPUT BUFFER
        JSR     PC,LODPRG               ;LOAD PROGRAM
        BCC     2$              ;LOAD ERROR?
        PMSG    <MOUNT C3.A11  HC WHEN READY\>
        PRGHLT                  ;LOOKUP OR LOAD ERROR
        BR      1$              ;TRY AGAIN
2$:     JMP     ISOPRM          ;GO TO DIACON FOR CALL


;SEQ442

.REM    %
        SUBROUTINE TO MAKE SURE THAT EXAM/DEPOSIT, EXECUTE, OR PROGRAM
RUN FINISHED UP CORRECTLY.  CHECKS C-BIT.  RETURNS IF CLEA, ELSE DOES
ERROR WITH MESSAGE DEPENDING ON ENTRY POINT (CHKED, CHKX, OR CHKP).
        %
CHKED:  BCS     1$              ;BR IF ANY ERROR(S)
        RTS     PC              ;ELSE RETURN TO CALLER
1$:     MOV     #ERRED,R0               ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CODE
        
CHKX:   BCS     1$              ;BR IF ERR BIT SET
        RTS     PC              ;ELSE RETURN
1$:     MOV     #ERRX,R0                ;PONT TO ERROR MESSAE
        BR      CHKCOM          ;GO TO COMMON COCE
CHKP:   BCS     1$              ;BR IF CARRY SET...ERR
        RTS     PC              ;ELSE RET
1$:     MOV     #ERRP,R0                ;POINT TO ERROR MESSAGE
        BR      CHKCOM          ;GO TO COMMON CODE
CHKCOM: ERRCOM  PNTAL           ;PRINT ERROR MESSAGE
        ERRMSG  <\REAL ERROR PC: >
        POP     R0              ;GET REAL ERR PC
        SUB     #4,R0           ;ADJ
        ERRCOM  PNTOCT          ;PRINT IT
        TST     R5              ;CHK SUBTEST # FOR REASONABLE VALUE
        BLE     1$              ; .LE. 0... NG
        CMP     R5,#3000
        BGT     1$              ;NG
        ERRMSG  <  SUBTEST: >
        MOV     R5,R0           ;SUBTEST # TO PARAM REG
        ERRCOM  PNTDEC          ;PRINT IT
        
1$:     ERROR
ERRED:  .ASCIZ  %EXAMINE/DEPOSIT ERROR%
ERRX:   .ASCIZ  %INSTRUCTION EXECUTE ERROR%
ERRP:   .ASCIZ  %PROGRAM DIDN'T HALT%
        .EVEN


;SEQ443

.REM    %
ROUTINES TO GET AND COMPARE A PSEUDO-STATUS WORD REGISTER
TO AN EXPECTED VALUE.  BOTH ARE MASKED BEFORE A COMPAISON.
CMPS. IS CALLED BY JSR, R5,CMPS.
                .WORD <EXPECTED DATA>
                .WORD <ADDRESS OF SPEC TABLE>

                .WORD <MASK USED WITH BIC>

CMPSR.  IS THE SAME EXCEPT THAT IN PLACE OF EXPECTED DATA
IS A MOV R'N',R1 WHERE N IS A REGISTER 1-4 THAT POINTS
AT THE EXPECTED DATA (PRESUMABLY IN A TABLE).
        
UPON RETURN FROM EITHER ROUTINE, THE "C-BIT" IS A ONE IF A 
MISMATCH WAS DETECTED.  THE ACTUAL DATA IS RETURNED IN R0,MASKED.

ERRORS CAUSE AN ERROR STACK ENTRY OF TYEP  'FT9'.  AS MANY
WORDS ARE PUT ON THE STACK AS THERE ARE BITS IN ERROR.  THE
LAS ENTRY HAS A ZERO SIGN BIT.

CMPSG.  ENTRY ONLY:

ON A DIAGNOSTIC GENERATION PASS (SCANWD=X2X000), THE EXPECTED
DAT WILL BE CORRECTED AND NO ERRORS FLAGGED.
%
CMPSG.:  BIT     #NOTVAL,SCANWD  ;TABLE VALID?
        BEQ     CMPS.           ;YES,,DO COMPARE
        MOV     R5,CPXDAD       ;SAVE EXPECTED DATA ADDRESS
        BR      CMPS.1          ;JOIN COMMON CODE
CMPS.:  CLR     CPXDAD          ;NO DATA GENERATION !
CMPS.1: PUSH    R1              
        MOV     (R5)+,R1        ;GET EXPECTED DATA
        BR      CMPSC.          ;DO COMMON OPERATION

CMPSR.: CLR     CPXDAD          ;NO DATA GENERATION
        PUSH    R1
        MOV     (R5)+,1$                ;GET DATA GETTER
1$:     MOV     R1,R1           ;**PROTO - REPLACED DURING EXECUTION


;SEQ444


CMPSC.: PUSH    <R2,R3,R4>
        JSR     PC,CMPSM.               ;SET UP BIT SELECT MASK
        MOV     (R5)+,R4                ;POINT AT TABLE
        CLR     TEM.            ;FIRST ERROR FLAG
1$:     MOVB    (R4),R0         ;GET NEXT CONTROL BYTE
        BMI     3$              ;GO DO DIAG READ
        BIT     R3,(R5)         ;ENABLED?
        BNE     4$              ;NO, GET NEXT BYTE
        MOV     R0,R2           ;COPY BIT PTR
        BIC     #174,R0         ;PRESEVE WORD BITS
        ASL     R0              ;MULT BY 2
        MOVB    R0,ERBIT+1
        ADD     .DAT3,R0                ;R3 NOW POINTS TO DEXWD
        CLC
        BIC     #177703,R2      ;SAVE BIT # FILED
        ROR     R2              ;POSITION TO SELECT WORD
        MOVB    R2,ERBIT
        BIT     R3,R1           ;TEST EXPECTED
        BNE     5$              ;ITS A ONE
        BIT     MTBL(R2),(R0)   ;TEST THE DIAG BIT
        BEQ     4$              ;WAS IT  ZERO?
        MOV     #200,R0
        BR      8$              ;ERROR IS H NOT L



;SEQ445

;REQUEST A READ OF THIS DIAGNOSTIC MUX
3$:     BIC     #177600,R0      ;CLEAN OUT SIGN BITS
        MOV     R0,DFSAVE
        DFRD                    ;DO DIAG READ
        TSTB    (R4)+           ;BUMP SPEC PTR
        BR      1$              ;AND RETURN TO COMMON CODE
4$:     CLC
        ROR     R3
        BITB    #100,(R4)+
        BEQ     1$              ;DO ANOTHER
        POP     <R4,R3,R2,R1>   ;DONE
        TST     (R5)+           
        CLC                     ;CLEAR ERROR FLAG
        TST     TEM.
        BEQ     41$             ;IF NO ERROR
        SEC                     ;SET ERROR FLAG
41$:    RTS     R5
5$:     BIT     MTBL(R2),(R0)
        BNE     4$              ;H IS OK
        CLR     R0
8$:     TST     CPXDAD          ;GENERATE EXPECTED?
        BEQ     81$             ;BR IF NOT
        BIS     R3,@CPXDAD      ;SET EXPECTED DATA
        TST     R0              ;REALLY WANT TO SET?
        BNE     4$              ;YES, WE DID
        BIC     R3,@CPXDAD      ;NO, _AKE EXPECTED ZERO
        BR      4$              ;CONTINUE TESTING
81$:    TST     TEM.            ;FIRST ERROR?
        BNE     10$             ;BR IF NOT
        MOV     ERSP..,R2
        MOV     #FT9,(R2)+
        COM     TEM.            ;SET FLAG
9$:     BISB    DFSAVE,R0
        MOVB    R0,(R2)+        ;ACTUAL AND DIAG FCN
        ASR     ERBIT
        MOVB    ERBIT+1,R0      
        MOVB    ENDB(R0),R0    ;GET END BIT
        CLRB    ERBIT+1
        SUB     ERBIT,R0                ;MINUS PDP11 BIT = PDP10
        MOVB    R0,(R2)+                ;BIT NBR TO STACK
        MOV     R2,ERSP..
        BR      4$              ;RETURN TOT EST
10$:    MOV     ERSP..,R2
        BIS     #BIT15,-2(R2)   ;SET CONTINUE ON PREV ENTRY
        BR      9$
ENDB:   .BYTE   35.,19.,3
.EVEN
CPXDAD: 0               ;DATA ADDRESS STORAGE


;SEQ446

CMPSM.: MOV     (R5),R4         ;POINT TO TABLE
        CLR     R3
        SEC
11$:    ROL     R3              ;PICK UP NEXT BIT
1$:     TSTB    (R4)
        BMI     2$              ;DIAG FCN
        BITB    #100,(R4)+      ;DONE?
        BEQ     11$             ;BR IF NOT
        RTS     PC
2$:     INC     R4              ;BYPASS
        BR      1$              ;NEXT BYTE


;SEQ447

.REM    %
ROUTINE TO REPORT BIT ERROR FIR TBIT PDP-10 BIT TEST
        %
BITERR: BNE     1$              ;FIND OUT BIT FLAVOR
        CLR     R0              ;WAS A ZERO
        BR      2$
1$:     MOV     #200,R0         ;WAS A ONE
2$:     PUSH    <R1,R3>
        MOV     ERSP..,R3               ;GET ERR STACK POINTER
        MOV     #FT9,(R3)+      ;STORE FORMAT TYPE
        BISB    DFSAVE,R0       ;GET DIAG FN
        MOVB    R0,(R3)+        ;STACK BYTE
        MOVB    ERBIT,(R3)+     ;STACK BIT NBR IN LEFT
        MOV     R3,ERSP..       ;SAVE POINTER
        POP     <R3,R1>

        RTS     R5              ;RETURN

.SBTTL          COMPARE ROUTINES
.REM    %
        36-BIT DATA COMPARE ROUTINE.  PERFORMS A MASKED COMPARISON
OF 5-BYTES OF DATA TO SOME EXPECTED DATA.  SETS THE C-BIT &
LOADS THE ERROR STACK IF MISCOMPARE.
CALL IS:
        JSR     R5,MSK36R
        R2 = POINTER TO MASK (0S IMPLY TEST)
        R3 = POINTER TO EXPECTED DATA
        R4 = POINTER TO ACTUAL DATA

%
MSK36R: PUSH    <R1,R5>


        CLRB    FFLAG           ;CLEAR ERROR FLAG
        MOV     #5,R0           ;LOOP COUNT
1$:     MOVB    (R3)+,R1        ;GET A BYTE OF EXPECTED
        BICB    (R2),R1         ;MASK IT
        MOVB    (R4)+,R5        ;GET A BYTE OF ACTUAL
        BICB    (R2)+,R5        ;MASK IT
        CMPB    R1,R5           ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF FAULT
2$:     DEC     R0              ;DONE?
        BGT     1$              ;NO, LOOP AGAIN
        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     3$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0               ;GET ERROR STACK POINTER
        MOV     #FTM36,(R0)+    ;FORMAT TO ERROR STACK
        SUB     #5,R2           ;RESOTRE MASK POINTER
        MOV     R2,(R0)+        ;POINTER TO ERROR STACK
        SUB     #5,R4           ;RESTORE ACTUAL POINTER
        MOVB    (R4)+,(R0)+     ;ACTUAL TO ERROR STACK
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        MOVB    (R4)+,(R0)+
        SUB     #5,R3           ;RESTORE POINTER TO EXPECTED
        MOVB    (R3)+,(R0)+     ;EXPECTED TO ERROR STACK
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOVB    (R3)+,(R0)+
        MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET C-BIT
3$:     POP     <R5,R1>


        RTS     R5              ;RETURN

FFLAG:  .WORD                   ;FAULT FLAG



.REM    %
        36-BIT DTE-20 DATA COMPARE ROUTINE (TRAILING PARAMETERS)
USES MSK36R.
CALL IS:
        JSR     R5,MSKDAI
        ENTRY+2 = POINTER TO MASK
        ENTRY+4 = POINTER TO EXPECTED DATA
%
MSKDAT: PUSH    <R2,R3,R4>



        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     .DAT3,R4        ;DTE20 DATA POINTER TO R4
        JSR     R5,MSK36R       ;DO COMPARISON
        POP     <R4,R3,R2>



        RTS     R5              ;RETURN


;SEQ326

.REM    %
        DIAGNOSTIC FUNCTION READ & COMPARE ROUTINE.
        (TRAINING PARAMETERS) USES MSK36R & FRERR.
CALL IS:
        JSR     R5,MSKDF
        ENTRY+2 = DIAGNOSTIC FUNCTION
        ENTRY+4 = POINTER TO MASK (0S IMPLY TEST)
        ENTRY+6 = POINTER TO EXPECTED DATA
%
MSKDF:  PUSH    <R2,R3,R4>



        MOV     (R5)+,R0        ;GET DIAGNOSTIC FUNCTION
        PUSH    R0

        DFRD                    ;READ DIAGNOSTIC WORD
        MOV     (R5)+,R2        ;MASK POINTER TO R2
        MOV     (R5)+,R3        ;EXPECTED POINTER TO R3
        MOV     .DAT3,R4        ;DTE20 DATA POINTER TO R4
        JSR     R5,MSK36R       ;PERFORM TEST
        POP     R0

        BCC     1$              ;PASSES
        JSR     R5,FRERR        ;DIAG FN TO ERROR STACK
1$:     POP     <R4,R3,R2>


        RTS     R5              ;RETURN


.REM    %
        DIAGNOSTIC FUNCTION READ & COMPARE ROUTINE.  USES
MSK36R & FRERR.
CALL IS:
        JSR     R5,MSKDFR
        R0      = DIAGNOSTIC FUNCTION
        R2      = POINTER TO MASK (OS IMPLY TEST)
        R3      = POINTER TO EXPECTED
%
MSKDFR: PUSH    <R4,R0>


        DFRD                    ;READ DIAGNOSTIC WORD
        MOV     .DAT3,R4                ;DTE20 DATA POINTER
        JSR     R5,MSK36R       ;PERFORM TEST
        POP     <R0,R4>

        BCC     1$              ;PASSES
        JSR     R5,FRERR        ;PUT DIAG FN ON ERROR STACK
1$:     RTS     R5              ;RETURN




.REM    %
        22-BIT ADDRESS VALUE COMPARE ROUTINE.
        (TRAILING PARAMETERS) USES CMP22R.
CALL IS:
        JSR     R5,CMP22
        ENTRY+2 = POINTER TO 3-BYTE ACTUAL
        ENTRY+4 = POINTER TO 3-BYTE EXPECTED
%
CMP22:  PUSH    <R2,R3>


        MOV     (R5)+,R2        ;GET ACTUAL POINTER
        MOV     (R5)+,R3        ;GET EXPECTED POINTER
        JSR     R5,CMP22R       ;DO COMPARE
        POP     <R3,R2>


        RTS     R5              ;RETURN


;SEQ330

.REM    %
        22-BIT ADDRESS VALUE COMPARE ROUTINE. COMPARES 22-BITS OF
ACTUAL DATA TO 3-BYTES OF EXPECTED DATA.  SETS THE C-BIT & LOADS THE
ERROR STACK IF MISCOMPARE.  INCREMENTS R2 & R3 BY 3.
CALL IS:
        JSR     R5,CMP22R
        R2=     POINTER TO ACTUAL DATA
        R3=     POINTER TO EXPECTED DATA
%
CMP22R: PUSH    R1

        MOV     #2,R0           ;LOOP COUNT-1
        CLRB    FFLAG           ;CLEAR ERROR FLAG
1$:     MOVB    (R2)+,R1        ;GET A BYTE OF ACTUAL
        TST     R0              ;LAST BYTE?
        BNE     2$              ;NO
        BIC     #177700,R1      ;YES, MASK UPPER BITS
2$:     CMPB    R1,(R3)+        ;COMPARE A BYTE
        BEQ     3$              ;O.K.
        INCB    FFLAG           ;SET FLAG IF BAD
3$:     DEC     R0              ;DONE?
        BGE     1$              ;NO, LOOP AGAIN
        POP     R1

        TSTB    FFLAG           ;MISCOMPARE?
        BEQ     4$              ;NO, COMPARE O.K.
        MOV     ERSP..,R0       ;GET ERROR STACK POINTER
        MOV     #FT22,(R0)+     ;FORMAT TO ERROR STACK
        SUB     #3,R2           ;RESTORE ACTUAL POINTER 
        MOVB    (R2)+,(R0)+     ;ACTUAL TO ERROR STACK
        MOVB    (R2)+,(R0)+     ;
        MOVB    (R2)+,(R0)+     ;
        CLRB    (R0)+           ;CLEAR EXTRA BYTE
        SUB     #3,R3           ;RESTORE EXPECTED POINTER
        MOVB    (R3)+,(R0)+     ;EXPECTED TO ERROR STACK
        MOVB    (R3)+,(R0)+     ;
        MOVB    (R3)+,(R0)+     ;
        CLRB    (R0)+           ;CLEAR EXTRA BYTE
        MOV     R0,ERSP..       ;UPDATE ERROR STACK POINTER
        SEC                     ;SET ERROR FLAG
4$:     RTS     R5              ;RETURN


;SEQ331

.REM    %
SDFRD - ROUTINE TO SAVE DIAGNOSTIC FUNCTION & PERFORM A DIAG-
NOSTIC READ.
%
SDFRD:  MOV     (R5)+,R0        ;GET DIAG FN
SDFRDA: MOV     R0,DFSAVE       ;SAVE DIAG FN
        DFRD
        RTS     R5              ;RETURN
        ;PUTS DIAGNOSTIC FUNCTION IN RO ON ERROR STACK

FRERR:  PUSH    R5

        MOV     ERSP..,R5       ;GET ERROR STACK POINTER
        MOV     #FT0,(R5)+      ;FORMAT TO ERROR STACK
        MOV     R0,(R5)+        ;DIAG FN TO ERROR STACK
        MOV     R5,ERSP..       ;UPDATE ERROR STACK POINTER
        POP     R5


        RTS     R5              ;RETURN


;SEQ332
.REM    %
CMPMEM - ROUTINE TO COMPARE MEMORY STATUS IN THE USER DEFINED
TABLE TO ACTUAL VALUERS. SETS THE C-BIT & LOADS THE ERROR STACK
IF MISCOMPARE.
%
CMPMEM: MOV     (R5)+,R0 ;GET EXPECTED POINTER
CMEM1:  PUSH    R0
        JSR     R5,GETMEM       ;GET MEM STATUS
        POP     R0

CMEM2:  PUSH    R1

        MOV     #MEMTAB,R1      ;GET ACTUAL POINTER
        CLRB    FFLAG         ;CLEAR FAULT FLAG
1$:     CMPB    (R0)+,(R1)+     ;COMPARE A BYTE
        BEQ     2$              ;O.K.
        INC     FFLAG              ;ERROR SET FLAG
2$:     CMP     R1,#MEMTAB+3    ;DONE?
        BLE     1$            ;NO, LOOP AGAIN
        TSTB    FFLAG      ;MISCOMPARE?
        BEQ     3$           ;NO, COMPARE O.K.
        PUSH    R2

        MOV     ERSP..,R2       ;GET ERROR STACK POINTER
        MOV     #FTMEM,(R2)+    ;FORMAT TO ERROR STACK
        SUB     #4,R1   ;RESTORE ACTUAL POINTER
        .REPT   4       ;ACTUAL TO ERROR STACK
        MOVB    (R1)+,(R2)+     
.ENDR
        SUB     #4,R0           ;RESTORE EXPECTED POINTER
        .REPT   4               ;EXPECTED TO ERROR STACK
        MOVB    (R0)+,(R2)+ 
.ENDR
        MOV     R2,ERSP..       ;RESET ERROR STACK POINTER
        SEC             ;SET ERROR FLAG
        POP     R2

3$:     POP     R1

        RTS     R5      ;RETURN
;SEQ254

.SBTTL          36-BIT ERROR PARSER  06-AUG-75
.REM    %
RANGE - ROUTINE TO TEST THE ERROR STACK TO DETERMINE THE BIT RANGE
OF 36-BIT DATA PATH ERRORS.  THE CALL IS JSR R5,RANGE.  REGISTER
R3 MUST POINT TO THE FTM36 FORMAT ENTRY ON THE ERROR STACK.
RETURNS AN INDEX OF BIT POSITION, RANGES IN R0.  INDEXES ARE AS
FOLLOWS:
        0:      BITS 30-35
        2:      BITS 27-29
        4:      BITS 24-26
        6:      BITS 18-23
        10:     BITS 12-17
        12:     BITS 09-11
        14:     BITS 06-08
        16:     BITS 00-05
        20:     BOTH HALVES
        22:     LOWER HALF
        24:     UPPER HALF
%
RANGE:  REGSAV                  ;SAVE REGISTERS
        CMP     (R3)+,#FTM36    ;FORMAT CORRECT?
        BNE     2$              ;NO, FATAL ERROR
        CLR     R4              ;CLEAR INDEX
1$:     JSR     PC,RANCOM       ;COMPARE A BIT RANGE
        BNE     3$              ;MISMATCH FOUND
        INC     R4              ;NEXT BIT RANGE
        INC     R4              
        CMP     R4,#20          ;ALL DONE?
        BLT     1$              ;NO, ERROR STACK O.K.
2$:     FATAL                   ;ERROR STACK ERROR
3$:     TST     R4              ;BITS 30-35?
        BEQ     4$              ;YES, TEST LOWER HALF
        CMP     R4,#10          ;BITS 12-17?
        BNE     5$              ;NO,SET INDEX & RETURN
        MOV     R4,TEM.         ;SAVE INDEX
        MOV     #16,R4          ;UPPER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 0-5
        BEQ     6$              ;NOT UPPER HALF
        MOV     #24,TEM.        ;SET INDEX = UPPER HALF
        BR      6$              ;CLEANUP & RETURN
4$:     MOV     R4,TEM.         ;SAVE INDEX
        MOV     #6,R4           ;LOWER HALF TEST
        JSR     PC,RANCOM       ;CHK BITS 18-23
        BEQ     6$              ;NOT LOWER HALF
        MOV     #22,TEM.        ;SET INDEX = LOWER HALF
        MOV     #10,R4          ;BOTH HALVES TEST
        JSR     PC,RANCOM       ;CHK BITS 12-17
        BEQ     6$              ;LOWER HALF
        MOV     #20,TEM.        ;SET INDEX = BOTH HALVES
        BR      6$              ;CLEANUP & RETURN
5$:     MOV     R4,TEM.         ;GET INDEX
6$:     REGRST                  ;RESTORE REGISTERS
        MOV     TEM.,R0         ;GET INDEX
        RTS     R5              ;RETURN


;SEQ255

        ;SUBROUTINE TO COMPARE ACTUAL & EXPECTED FOR THE RANGE
        ;SPECIFIED FOR THE INDEX VALUE IN R4.

RANCOM: PUSH    R4

        MOV     BRCNT(R4),SPCNT ;GET SHIFT COUNT
        MOV     R3,R4           ;GET ERROR STACK POINTER
        INC     R4              ;POINT TO ACTUAL
        INC     R4              
        JSR     PC,RANPOS       ;GET MASK & POSITION ACTUAL
        PUSH    R0              ;SAVE SHIFTED ACTUAL

        JSR     PC,RANPOS       ;GET, MASK & POSITION EXPECTED
        POP     <R1,R4>         ;RESTORE ACTUAL & INDEX


        MOV     BRMASK(R4),R2   ;GET MASK
        BIC     R2,R0           ;MASK EXPECTED
        BIC     R2,R1           ;MASK ACTUAL
        CMP     R0,R1           ;COMPARE THEM
        RTS     PC              ;RETURN

;TAKES THE DATA POINTED TO BY R4, MASKS IT & RETURNS THE
;BIT RANGE DESIRED RIGHT JUSTIFIED IN R0.
RANPOS: MOV     (R3),R5         ;GET MASK POINTER
        CLR     R0              ;BITS 20-35
        JSR     PC,RANP0        ;GET & MASK 28-35
        JSR     PC,RANP0        ;GET & MASK 20-27
        CLR     R1              ;BITS 4-19
        JSR     PC,RANP1        ;GET & MASK 12-19
        JSR     PC,RANP1        ;GET & MASK 4-11
        CLR     R2              ;BITS 0-3
        BISB    (R4)+,R2        ;SET 0-3
        BICB    (R5),R2         ;MASAK 0-3
        MOV     SPCNT,R5                ;GET SHIFT COUNT
1$:     DEC     R5              ;SHIFT DONE?
        BLT     2$              ;YES, RETURN
        ASR     R2              ;NO, SHIFT 3 WORDS RIGHT
        ROR     R1              ;
        ROR     R0
        BR      1$              ;LOOP AGAIN
2$:     RTS     PC              ;DATA IN R0, RETURN


RANP0:  BISB    (R4)+,R0        ;SET A BYTE
        BICB    (R5)+,R0        ;POSITION IT
        SWAB    R0              ;POSITION IT
        RTS     PC

RANP1:  BISB    (R4)+,R1        ;SET A BYTE
        BICB    (R5)+,R1        ;MASK A BYTE
        SWAB    R1              ;POSITION IT
        RTS     PC


;SEQ256

        ;TABLE OF SHIFT COUNT TO RIGHT JUSTIFY BITS LISTED

BRCNT:  .WORD   0       ;30-35
        .WORD   6.      ;27-29
        .WORD   9.      ;24-26
        .WORD   12.     ;18-23
        .WORD   18.     ;12-17
        .WORD   24.     ;09-11
        .WORD   27.     ;06-08
        .WORD   30.     ;00-05

        ;TABLE OF BIT CLEAR MASKS FOR EACH BIT RANGE

BRMASK: .WORD   177700  ;30-35
        .WORD   177770  ;27-29
        .WORD   177770  ;24-26
        .WORD   177700  ;18-23
        .WORD   177700  ;12-17
        .WORD   177770  ;09-11
        .WORD    177770     ;06-08
        .WORD   177700  ;00-05


;

;SEQ257


.SBTTL          SCANOUT ROUTINES  1-MAR-76
.REM    %
        SUBROUTINE TO SET AN MBOX SCANOUT MASK.  THE MASK POINTER
IS THE TRAILING PARAMETER.  IF NO CACHE EXISTS IN THE MACHINE, THE
USER MASK TABLE IS MODIFIED TO ENSURE THAT THE FOLLOWING UNTERMINATED
MBOX SIGNALS ARE MASKED:
        
        CSH SEL LRU
        CSH USE HOLD
        CSH USE WR EN
        CSH VAL SEL ALL
        CSH     VAL SEL WR DATA
        CSH WR SEL ALL
        CSH WR WD 0-3 EN (SIGNALS)
        CSH WR WR DATA
        FORCE NO MATCH
        FORCE VALID MATCH 0-3 (SIGNALS)
%

SETMSK: MOV     (R5)+,MMASK             ;SAVE MASK POINTER
        TSTB    CSHOPT          ;CACHE INSTALLED?
        BNE     2$              ;YES RETURN
        PUSH    R1      

        MOV     #CSHMSK,R0      ;POINT TO CACHE SIGNAL MASK
        MOV     MMASK,R1                ;POINT TO USER MASK
1$:     BIS     (R0)+,(R1)+     ;SET BITS IN USER MASK
        CMP     R0,#CSHMSK+28.  ;DONE?
        BLE     1$              ;NO, CONITNUE MODIFICATION
        POP     R1

2$:     RTS     R5              ;RETURN

CSHMSK: .BYTE   000             ;UNUSED
        .BYTE   074             ;163 27-34

        .WORD   000740          ;160 20-35
        .BYTE   000             ;160 12-19
        .BYTE   000             ;164 27-34
        .WORD   000040          ;161 20-35
        .BYTE   000             ;161 12-19
        .BYTE   000             ;165 27-34
        .WORD   000000          ;162 20-35
        .BYTE   000             ;162 12-19
        .BYTE   000             ;166 27-34
        .WORD   000010  ;170 20-35
        .WORD   000010          ;171 20-35
        .WORD   000410          ;172 20-25
        .WORD   000000          ;173 20-35
        .WORD   000000          ;174 20-35
        .WORD   010000  ;175 20-35
        .WORD   000020          ;176 20-35
        .WORD   000020          ;177 20-35

 

;SEQ336

.REM    %
        CONTROLLED CLOCK SCANOUT ROUTINE.  SUPPORTS BUILDING &
COMPARING DIAGNOSTIC FUNCTION SNAPSHOTS IN ORDER TO DETERMINE
THE FIRST POINT OF DEPARTURE FROM A PROPER SEQUENCE OF EVENTS.
THE TABLE WHICH IDENTIFIES THE PROPER STATE OF THE MBOX AT THE
        END OF A SPECIFIED BURST OF CLOCKS IS CORE RESIDENT.  THE STATE
OF THE MBOX FOR INTERMEDIATE CLOCK TICKS IS MATINTAINED ON .A11
FORMAT FILES.  THE MACHINE IS STOPPED AT ONE MBOX CLOCK BEFORE
THE POINT OF ERROR DETECTION IF A TICK FILE EXISTS.
%

        OVRLAY=70000
MCSCAN: MOV     #4,SCFLAG               ;SET CHANNEL/MBOX SCAN
        BR      SCOUT
CSCAN:  MOV     #2,SCFLAG               ;SET CHANNEL SCAN FLAG
        BR      SCOUT
MSCAN:  CLR     SCFLAG          ;CLEAR SCAN FLAG
SCOUT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TABPTR    ;SAVE TABLE POINTER
        MOV     (R5)+,SCNEND    ;SAVE SCAN END POINT
        MOV     SCANWD,R0       ;GET SCAN CONTROL WORD
        BEQ     SCANIT          ;NORMAL SCAN
        MOV     (SP),SCSUB      ;SAVE SUBTEST
        BIT     #UPDATE,R0      ;
        BEQ     1$              ;
        JMP     UPASS           ;UPDATE IN PROGRESS
1$:     BIT     #BUILD,R0       ;
        BEQ     2$              ;
        JMP     GPASS           ;GENERATION IN PROGRESS
2$:     BIT     #CALTIC,R0      ;
        BNE     NOSCAN          ;CALCULATE BURST COUNT
        MOV     SCNEND,R0       ;GET END POINT
        BPL     CALBST          ;BURST SPECIFIED
        JSR     R5,FIND2        ;FIND EVENT
        BR      ENDCHK          ;TEST FOR ERROR

        ;NO SCAN ACTIVE

NOSCAN: MOV     SCNEND,R0       ;GET BURST COUNT
CALBST: JSR     PC,SCNSTP       ;GET TO END POINT
ENDCHK: BCS     TICERR          ;ERROR
        RTS     R5              ;RETURN

TICERR: ERRMSG  <EVENT NOT FOUND\>

        SEC     
        RTS     R5              ;ERROR RETURN


;SEQ337

        ;NORMAL SCAN

SCANIT: TST     SCERR   ;PREVIOUS ERROR?
        BEQ     DOMAIN  ;NO, DO MAIN SCAN
        CMP     SCERR,TSTNUM    ;THIS TEST?
        BNE     DOMAIN          ;NO, DO MAIN SCN
        CMP     (SP),SCSUB      ;THIS SUBTEST?
        BNE     DOMAIN          ;NO, DO MAIN SCAN
        BIT     #BIT2,@TABPTR   ;TICK FILE VALID?
        BNE     SCISOL          ;YES, USE IT
        MOV     SCNEND,R0       ;NO, GET TICK COUNT
        BR      TICKIT          ;DO TICKS

        ;MAIN SCANNER

DOMAIN: MOV     SCNEND,R0               ;GET SCAN END POINT
        BEQ     1$              ;NO TICKS
        JSR     PC,SCNSTP       ;GET TO END POINT
        BCS     TICERR          ;ERROR
1$:     MOV     TABPTR,R0       ;GET TABLE POINTER
        JSR     R5,SNAP         ;DO SNAPSHOT
        BCC     2$              ;O.K.
        BR      STICK           ;ERROR, START ISOLATION
2$:     RTS     R5              ;RETURN


MMASK:  .WORD  0                ;POINTER TO MBOX SCAN MASK
CMASK:  .WORD 0                 ;POINTER TO CHANNEL MASK


        ;START ISOLATION

STICK:  MOV     TSTNUM, SCERR   ;SAVE TEST #
        MOV     (SP),SCSUB     ;SAVE SUBTEST #
RESCAN: POP     R5              ;RESTORE R5

        MOV     TSTNUM,R4       ;GET TEST #
        JMP     RETEST          ;RERUN CURRENT TEST



;SEQ338

        ;RERUN RETURN POINT

SCISOL: TST     TICFLG  ;RERUN TO DO TICKS -1?
        BNE     1$              ;YES
        INC    TICFLG   ;NO, SET FLAG FOR NEXT TIME
        JSR     R5,TSCAN        ;SCAN TICK FILE
        ERRMSG  <TICK COUNT = >

        MOV     SCBRST,R0               ;
        ERRDEC                  ;
        ERRMSG  <, STOPPED @ TICK-1\>

        BR      STICK           ;RERUN AGAIN
1$:     CLR     TICFLG          ;CLEAR TICK-1 FLAG

        ;TICK TO ERROR POINT MIN7US ONE MBOX CLOCK

        MOV     SCBRST,R0               ;GET ERROR TICK COUINT
        DEC     R0              ;DECREMTN CLOCK COUNT
        BLE     NOTICK                  ;ANY TICKS TO DO?
TICKIT: JSR     R5,BRST1                ;YES, DO THEM
NOTICK: CLR     SCERR           ;CLEAR ISOLATION FLAG
        SEC                     ;SET ERROR FLAG
        RTS     R5              ;RETURN



TABPTR: .WORD   0               ;TABLE POINTER
SCNEND: .WORD   0               ;SCAN END POINT
SCOSIZ: .WORD   15.             ;TABLE SIZE
SCERR:  .WORD   0               ;SCANOUT ERROR FLAG
SCSUB:  .WORD   0               ;SUBTEST
SCFLAG: .WORD   0               ;
TICPTR: .WORD   0               ;OVERLAY SCAN POINTER
        SCBRST: .WORD   0               ;BURST COUNT
TICFLG: .WORD   0               ;FLAG TO TICK #-1


;SEQ462

        ;SNAPSHOT ROUTINE

SNAP:   JSR     R5,SAV.5                ;SAVE R1-R5
        MOV     R0,R5           ;TABLE POINTER TO R5
        CLRB    FFLAG           ;CLEAR SCANOUT ERROR FLAG
        MOV     SCFLAG,R1       ;
        JMP     @1$(R1)         ;DO SNAPSHOT
1$:     .WORD   MSNAP           ;CALL MBOX SNAPSHOT
        .WORD   CSNAP           ;CALL CHANNEL SNAPSHOT
        .WORD   MSNAP           ;CALL MBOX THEN CHANNEL
        ;CHANNEL SNAPSHOT COMPARE ROUTINE - MASKSS ACTUAL ONLY
CSNAP:  MOV     #CSIZE,SCOSIZ   ;SET TABLE SIZE
        MOV     CMASK,R2        ;GET MASK POINTER
        MOV     #170,R3         ;FIRST DIAG FN
1$:     MOV     R3,R0           ;CURRENT DIAG FN
        DFRD                    ;READ IT
        BITB    #BIT2,(R5)      ;SCAN VALID?
        BEQ     2$              ;NO
        BIS     #BIT2,@.DAT2    ;YES, SET BIT IN ACTUAL
2$:     TST     R2              ;MASK?
        BEQ     3$              ;NO, DONT MASK
        MOVB    (R2)+,R0        ;FIRST MASK BYTE TO R0
        CLR     R1              ;
        BISB    (R2)+,R1        ;2ND MASK BYTE TO R1
        SWAB    R1              ;UPPER
        BISB    R0,R1           ;NOW HAVE MASK WORD

        BIC     R1,@.DAT2       ;MASK DEXWD2
        MOVB    (R2)+,R0        ;GET 3RD MASK BYTE
        BIC     R0,@.DAT1       ;MASK DEXWD1
3$:     MOV     .DAT2,R4        ;DEXWD2 POINTER
        CLR     R0              ;CLEAR ERROR FLAG
        CMPB    (R4)+,(R5)+     ;COMPARE FIRST BYTE
        BEQ     4$              ;O.K.
        INC     R0              ;ERROR,SET FLAG
4$:     CMPB    (R4)+,(R5)+     ;COMPARE 2ND BYTE
        BEQ     5$              ;O.K.
        INC     R0              ;ERROR,SET FLAG
5$:     CMPB    (R4),(R5)+      ;COMPARE 3RD BYTE
        BNE     6$              ;ERROR
        TST     R0              ;PREVIUS ERROR?
        BEQ     7$              ;NO, COMPARE O.K.
6$:     MOV     @.DAT2,R0       ;ACTUAL TO R0 & R1
        MOV     (R4),R1         ;
        JSR     PC,SNERR3       ;LOAD ERROR STACK
7$:     INC     R3              ;NEXT FUNCTION
        CMP     R3,#177         ;LAST ONE DONE?
        BLE     1$              ;NO, LOOP AGAIN
        TSTB    FFLAG           ;ERROR?
        BEQ     8$              ;NO, RETURN
        SEC                     ;YES, SET ERROR FLAG
8$:     JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;RETURN

        ;MOBX SNAPSHOT COMPARE ROUTINE - MASKS BOTH ACTUAL & EXPECTED

MSNAP:  MOV     #MSIZE,SCOSIZ   ;SET TABLE SIZE
        MOV     MMASK,R2                ;GET MASK POINTER
        MOV     #160,R3         ;FIRST DIAG FN
        MOV     .DAT3,R4        ;POINTER TO .DAT3
        TST     (R5)+           ;POINT TO TABLE+2
        TST     R2              ;MASK?
        BEQ     M6062           ;NO
        TST     (R2)+           ;YES, POINT TO MASK TABLE +2

        ;COMPARE FOR MBOX FUNCTIONS 160-162

M6062:  MOV     R3,R0           ;CURRENT DIAG FN
        DFRD                    ;READ IT
        MOV     (R4),R0         ;GET DEXWD3
        MOV     @.DAT2,R1       ;GET DEXWD2
        TST     R2              ;MASK?
        BEQ     1$              ;NO, DONT MASK
        BIC     (R2),(R5)               ;MASK EXPECTED
        BIC     (R2)+,R0        ;MASK ACTUAL
        BICB    (R2),2(R5)      ;MASK EXPECTED
        BIC     (R2)+,R1        ;MASK ACTUAL
1$:     CMP     R0,(R5)+        ;COMPARE TO EXPECTED
        BEQ     2$              ;FIRST WORD O.K.
        INC     R5              ;ERROR,UPDATE POINTER
        BR      3$              ;
2$:     CMPB    R1,(R5)+        ;COMPARE NEXT BYTE
        BEQ     4$              ;O.K.
3$:     JSR     PC,SNERR3               ;LOAD ERROR STACK
4$:     INC     R5              ;UPDATE EXPECTED POINTER
        INC     R3              ;NEXT FUNCTION
        CMP     R3,#163         ;163 NEXT?
        BLT     M6062           ;NO, LOOP AGAIN
        MOV     #16,R0          ;
        SUB     R0,R5           ;BACK UP TO TABLE BASE
        TST     R2              ;MASK?
        BEQ     M6366           ;NO
        SUB     R0,R2           ;YES, BACK UP MASK TOO


;SEQ340

        ;COMPARE FOR MBOX FUNCTIONS 163-166

M6366:  MOV     R3,R0           ;CURRENT FUNCTION
        DFRD                    ;READ IT
        MOV     (R4),R0         ;GET ACTUAL
        ASR     R0              ;POSITION IT
        TST     R2              ;MASK?
        BEQ     1$              ;NO, DONT MASK
        INC     R2              ;UPDATE MASK POINTER
        BICB    (R2)+,R0        ;MASK ACTUAL
        TST     (R2)+           ;UPDATE MASK POINTER
1$:     INC     R5              ;UPDATE EXPECTED POINTER
        BICB    -3(R2),(R5)     ;MASK EXPECTED
        CMPB    R0,(R5)+        ;COMPARE BITS 27-34
        BEQ     2$              ;O.K.
        JSR     PC,SNERR1               ;ERROR, PUT ON ERROR STACK
        
2$:     INC     R3              ;NEXT FUNCTION
        CMP     R3,#167         ;167 NEXT6?
        BGE     3$              ;YES
        TST     (R5)+           ;NO, UPDATE EXPECTED POINTER
        BR      M6366           ;LOOP AGAIN
3$:     INC     R3              ;SKIP FN 167
        TST     R2              ;MASK?
        BEQ     M7077           ;NO
        TST     -(R2)           ;YES, BACKUP MASK POINTER

        ;COMPARE FOR MBOX FUNCTIONS 170-177

M7077:  MOV     R3,R0           ;CURRENT FUNCTION
        DFRD                    ;READ IT
        MOV     (R4),R0 ;GET DEXWD3
        TST     R2              ;MASK?
        BEQ     1$              ;NO, DONT MASK
        BIC     (R2),R0         ;MASK ACTUAL
        BIC     (R2)+,(R5)      ;MASK EXPECTED
1$:     CMP     R0,(R5)+                ;COMPARE TO EXPECTED
        BEQ     2$              ;O.K.
        JSR     PC,SNERR        ;LOAD ERROR STACK
2$:     INC     R3              ;NEXT FUNCTION
        CMP     R3,#177 ;LAST ONE DONE?
        BLE     M7077           ;NO, LOOP AGAIN
        TST     SCFLAG          ;SCAN CHANNELS TOO?
        BEQ     3$              ;NO
        JMP     CSNAP           ;YES,DO IT
3$:     TSTB    FFLAG           ;ERROR?
        BEQ     4$              ;NO, COMPARE O.K.
        SEC                     ;YES  SET ERROR FLAG
4$:     JSR     R5,RST.5                ;RESTORE R1-R5
        RTS     R5              ;RETURN


;SEQ341

        ;1-WD FORMAT ERROR STACK STUFFER

SNERR:  JSR     PC,ERSTRT       ;FORMAT TO ERROR STACK
        MOV     -2(R5),(R4)+    ;EXPECTED TO ERROR STACK
        MOV     R0,(R4)+        ;ACTUAL TO ERROR STACK
        BR      EREND           ;FINISH UP

        ;COMMON SNAPSHOT ERROR STACK CODE

ERSTRT: MOV     ERSP..,R4       ;GET ERROR STACK POINTER
        TSTB    FFLAG           ;FIRST ERROR?
        BNE     1$              ;NO
        MOV     ERSI..,R4       ;YES, RESET ERROR STACK
        COMB    FFLAG           ;SET FLAG
        MOV     #FT8,(R4)+      ;FORMAT TO ERROR STACK
        BR      2$              ;
1$:     BIC     #BIT15,@ERSS..  ;CLEAR THE END BITR
2$:     MOV     R4,ERSS..       ;SAVE FORMAT POINTER
        MOVB    SCOSIZ,(R4)+    ;FORMAT I.D. TO ERROR STACK
        MOVB    R3,(R4)+        ;DIAG FN. TO ERROR STACK
        RTS     PC              ;

        ;1-BYTE TO 1 WORD CONVERTER & ERROR STACK STUFFER

SNERR1: JSR     PC,ERSTRT       ;FORMAT TO ERROR STACK
        CLR     R1              ;
        BISB    -1(R5),R1       ;GET EXPECTED
        ASL     R1              ;POSITION IT
        MOV     R1,(R4)+        ;TO ERROR STACK
        BIC     #177400,R0      ;
        ASL     R0              ;POSITION ACTUAL
        MOV     R0,(R4)+        ;TO ERROR STACK
        BR      EREND           ;FINISH UP

        ;3-BYTE FORMAT ERROR STACK STUFFER

SNERR3: JSR     PC,ERSTRT       ;FORMAT TO ERROR STACK
        MOVB    -3(R5),(R4)+    ;EXPECTED TO ERROR STACK
        MOVB    -2(R5),(R4)+    ;
        MOVB    -1(R5),(R4)+    ;
        MOVB    R0,(R4)+                ;ACTUAL TO ERROR STACK
        SWAB    R0              ;
        MOVB    R0,(R4)+        ;
        MOVB    R1,(R4)+        ;
        
EREND:  BIS     #BIT15,@ERSS..  ;SET THE END BIT
        MOV     R4,ERSP..       ;RESTORE ERROR STACK POINTER
        MOV     .DAT3,R4                ;DEXWD POINTER TO R4
        RTS     PC              ;RETURN

ERSS..: .WORD   0               ;POINTER TO FORMAT WORD


;SEQ342

        ;TICK FILE SCANNER

TSCAN:  CMPB    TSTNUM,CONSOL-2 ;FILE LOADED?
        BNE     TLOAD           ;NO
        CMPB    SCSUB,CONSOL-1  ;
        BEQ     RSCAN           ;YES

        ;LOADS TICK FILE

TLOAD:  PMSG    <LE >           ;REQUEST PROGRAM LOAD

        JSR     R5,TICKID       ;GER FILENAME
        MOV     #-1,R0          ;COMMAND IN OUTPUT BUFFER
        JSR     PC,LODPRG               ;LOAD TIC FILE
        BCC     1$              ;FILE LOADED
        PMSG    <MOUNT >        ;ERROR

        JSR     R5,TICKID       ;GET FILENAME
        PMSG    <,  HC WHEN READY\>

        PRGHLT                  ;WAIT FOR ERROR CORRECTION
        BR      TLOAD           ;TRY AGAIN
1$:     MOVB    TSTNUM,CONSOL-2 ;SET FILE LOADED
        MOVB    SCSUB,CONSOL-1
        
RSCAN:  CLR     SCBRST          ;CLEAR TICK COUNT
        MOV     #OVRLAY,TICPTR  ;INITIALIZE TABLE POINTER
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        INC     SCBRST          ;COUNT TICK
        CMP     SCBRST,SCNEND   ;DONE?
        BGE     2$              ;YES, RETURN
        MOV     TICPTR,R0       ;GET TABLE POINTER
        JSR     R5,SNAP         ;NO, PERFORM SNAPSHOT
        BCS     2$              ;ERROR RETURN
        MOV     SCFLAG,R0       ;GET SNAPSHOT ID
        MOV     MCSIZE(R0),R0   ;GET TABLE SIZE
        ASL     R0              ;MULTIPLY BY 2
        ADD     R0,TICPTR       ;UPDATE TABLE POINTER
        BR      1$              ;LOOP AGAIN
2$:     RTS     R5              ;RETURN

MCSIZE: .WORD   MSIZE           ;MBOX TABLE SIZE PARAMETER
        .WORD   CSIZE           ;CHANNEL TABLE SIZE
        .WORD   MSIZE+CSIZE   ;BOTH
;SEQ343

      ;GET TO PROPER POINT FOR SCAN

SCNSTP: TST     R0              ;FIND OR BURST?
        BEQ     2$              ;NOTHING TO DO
        BMI     1$              ;STEP IF NEGATIVE
        JSR     R5,BRST1        ;BURST
        BR      2$              ;
1$:     JSR     R5,FIND2                ;FIND EVENT
        BCS     2$      ;ERROR,TIMEOUT
        MOV     R0,-2(R5)       ;O.K. SVE BURST
        MOV     R0,SCNEND       ;
2$:     RTS     PC              ;

        ;PUTS PROGRAM ID IN OUTPUT BUFFER

TICKID: MOVB    TESTAB+1,R0     ;
        PNTCHR                  ;USER PREFIX
        MOV     TSTNUM,R0       ;
        PNTDEC                  ;TEST #
        PNTBAK          ;DISCARD PERIOD
        PNTCI,'H                ;PROCESSOR TYPE TO BUFFER
        MOV     SCSUB,R0        ;
        PNTDEC                  ;SUBTEST #
        PMSG    <TIC>           ;TIC EXTENSION

        RTS     R5              ;RETURN


        ;SCAN CONTROL WORD

SCANWD: .WORD   0               ;ZERO FOR NORMAL SCANOUTS
                        ;DEFAULT NOW SET TO GENERATE
                                ;NO SCAN TABLES

;DHMCA MISSING CODE - TAKEN FROM DHKBA-A :   LINES 12153 THRU 12458, THE EQUIV OF DHMCA LINES 13114 THRU 13417.

                ;13114
NOTVAL=BIT15    ;115
UPDATE=BIT14    ;116
BUILD=BIT13     ;117
INTICK=BIT12    ;118
                ;119
CALTIC=BIT11    ;120
                ;121
                ;122            NOTE: CMASK AND LINES OF ASSOCIATED CODE HAVE BEEN REMOVED FROM THIS VERSION.
                ;123
;SCANWD:.WORD 100000    ;ZERO FOR NORMAL SCANOUTS       ;124    NOTE: LINE BEGUN WITH SEMICOLON TO AVOID DOUBLE DEF.
                        ;DEFAULT NOW SET TO GENERATE    ;125
                        ;NO SCAN TABLES                 ;126
                ;127
                ;128
                ;129
                ;130
UPASS:  MOVB    R0,R0   ;131    NOTE: ASSUMING THE FIRST R0. THE 2ND IS VERIFIED.
        JMP     @UPASS1(R0)     ;132
                        ;133
UPASS1: .WORD   GMAIN   ;134
UPASS2: .WORD   VSCAN   ;135
UPASS3: .WORD   USCAN   ;136
UPASS4: .WORD   VUPDT   ;137
                        ;138
                        ;139
                        ;140
                        ;141
GPASS:  MOVB    R0,R0   ;142    NOTE: ASSUMING THE FIRST R0. THE 2ND IS VERIFIED.
        JMP     @GPASS1(R0)     ;143
                        ;144
GPASS1: .WORD   GMAIN   ;145
GPASS2: .WORD   SCANIT  ;146
GPASS3: .WORD   GTICK   ;147
GPASS4: .WORD   VTICK   ;148
                        ;149
                        ;150
                        ;151
                        ;152
SCPASS:MOV      @#SCANWD,R0     ;153
        BEQ     2$      ;154
        MOVB    R0,R1   ;155
        INC     R0      ;156
        INC     R0      ;157
        BIT     #UPDATE,R0      ;158
        BEQ     1$              ;159
        JMP     @PASSU(R1)      ;160
1$:     BIT     #BUILD,R0       ;161
        BEQ     2$              ;162
        JMP     @PASSG(R1)      ;163


2$:     RTS     PC              ;13164
                                ;165
                                ;166
                                ;167
PASSU:  .WORD   PASS1           ;168
        .WORD   NPASS           ;169
        .WORD   NPASS           ;170
        .WORD   SCDONE          ;171
                                ;172
                                ;173
                                ;174
PASSG:  .WORD   PASS1           ;175
        .WORD   PASS2           ;176
        .WORD   NPASS           ;177
        .WORD   SCDONE          ;178
                                ;179
                                ;180
PASS1:  BIS     #NOTVAL,R0      ;181
        BR      NPASS           ;182
PASS2:  BIC     #NOTVAL,R0      ;183
        BIT     #INTICK,R0      ;184
        BNE     NPASS           ;185
SCDONE: CLR     R0              ;186
NPASS:  MOV     R0,@#SCANWD     ;187
        RTS     PC              ;188
                                ;189
                                ;190
                                ;191
GMAIN:  BIC     #BIT2,@TABPTR    ;192
        MOV     @#SCNEND,R0     ;193
        JSR     PC,@#SCNSTP     ;194
        BCC     1$              ;195
        JMP     @#TICERR        ;196
1$:     BIT     #NOTVAL,@#SCANWD;197
        BEQ     2$              ;198
        MOV     @#TABPTR,R0     ;199
        JSR     R5,GENTAB       ;200
        BIT     #UPDATE,@#SCANWD;201
        BEQ     2$              ;202
        CMP     @#SCNEND,#1     ;203
        BLE     2$              ;204
        BIS     #BIT2,@TABPTR   ;205
2$:     RTS     R5              ;206


                        ;13207
                        ;208
                        ;209
GTICK:  MOV     @#SCNEND,R0     ;210
        BEQ     7$              ;211
        JSR     R5,SAV.3        ;212
        CMP     R0,#1           ;213
        BEQ     5$              ;214
        MOV     #OVRLAY,R5      ;215
        MOV     #1,R4           ;216
        MOV     @#SCFLAG,R0     ;217
        MOV     MCSIZE(R0),R3   ;218 NOTE: THESE 3 OPERANDS FOR SURE
        ASL     R3      ;219
1$:     JSR      R5, STEP1   ;220
        CMP     R5,#CONSOL-20   ;221
        BLT     2$              ;222
        PMSG    <TEST >         ;223
        MOV     @#TSTNUM,R0     ;224
        PNTDEC                  ;225
        PMSG    <, SUBTEST >    ;226
        MOV     @#SCSUB,R0      ;227
        PNTDEC          ;228
        PMSG    < FILE TOO BIG\>  ;229
        MOV     @#SCNEND,R0     ;230
        SUB     R4,R0   ;231
        JSR     R5,BRST1        ;232
        BR      6$      ;233
2$:     INC     R4      ;234
        MOV     R5,R0   ;235
        JSR     R5,GENTAB       ;236
        ADD     R3,R5   ;237
        CMP     R4,@#SCNEND     ;238
        BLT     1$              ;239
                        ;240
                        ;241
                        ;242
3$:     JSR     R5,GETVER       ;243
        PMSG    <CD >           ;244
        JSR     R5,TICKID       ;245
        PMSG    < 70000,>       ;246
        MOV     R5,R0   ;247
        DEC     R0              ;248
        DEC     R0              ;249
        PNTOCS          ;250


        JSR     R5,PNTVER       ;13251
        PCRLF                   ;252
        MOV     #-1,R0          ;253
        PRGCMD                  ;254
        BCC     4$              ;255
        PMSG    <IC TO RETRY\>   ;256
        PRGHLT                  ;257
        BR      3$              ;258
4$:     BIT     #UPDATE,@#SCANWD ;259
        BNE     5$              ;260
        BIS     #BIT2,@TABPTR   ;261
5$:     JSR     R5,STEP1        ;262
6$:     JSR     R5,RST.3        ;263
7$:     RTS     R5              ;264
                                ;265
                                ;266
                                ;267
VSCAN:  JSR     R5,VTICK        ;268
        BIT     #BIT2,@TABPTR   ;269
        BEQ     1$              ;270
        MOV     @#TABPTR,R0     ;271
        JSR     R5,SNAP         ;272
        BCS     VALERR          ;273
1$:     RTS     R5              ;274
                                ;275
                                ;276
                                ;277
VTICK:  BIT     #BIT2,@TABPTR     ;278
        BNE     1$              ;279
        JMP     @#NOSCAN        ;280    
1$:     JSR     R5,@#TSCAN      ;281
        BCS     VALERR          ;282
        RTS     R5              ;283
                                ;284
VALERR: PFORCE                  ;285
        PMSG    <EBOX CAN'T EXECUT>     ;286
        MOV     @#SCBRST,R0     ;287
        PNTDEC                  ;288
        PCRLF                   ;289
        PNORML                  ;290
        MOV     @#ERTI..,R0     ;291
        MOV     @#ERSI..,@#ERTI.. ;292
        MOV     R0,@#ERSI..     ;293


        MOV     @#ERSP..,@#ERTP.. ;13294
        MOV     R0,@#ERSP..       ;295
        JSR     R5,SAV.5        ;296
        MOV     @#BRKPC,R3        ;297
        MOV     @#TSTNUM,R4       ;298
        MOV     @#SCSUB,R5        ;299
        JSR     PC,@#REPORT     ;300
        PCRLF                   ;301
        JSR     R5,@#RST.5      ;302
        BIC     #BIT2,@TABPTR   ;303
        MOV     @#SCNEND,R0     ;304
        SUB     @#SCBRST,R0     ;305
        BLE     1$              ;306
        JSR     R5,BRST1        ;307
1$:     RTS     R5              ;308
                                ;309
                                ;310
USCAN:  BIT     #BIT2,@TABPTR   ;311
        BEQ     1$              ;312
        JMP     NOSCAN          ;313
1$:     JSR     R5,GTICK        ;314
        MOV     @#TABPTR,R0     ;315
        JSR     R5,GENTAB       ;316
        RTS     R5              ;317
                                ;318
                                ;319
VUPDT:  BIT     #BIT2,@TABPTR   ;320
        BNE     1$              ;321
        CMP     @#SCNEND,#01    ;322
        BGT     2$              ;323
1$:     JMP     SCANIT          ;324
2$:     BIS     #BIT2,@TABPTR   ;325
        JMP     VSCAN           ;326
                                ;327
                                ;328
                                ;329
GENTAB: JSR     R5,SAV.5        ;330
        MOV     R0,R5           ;331
        MOV     @#SCFLAG,R3    ;332
        JMP     @MBUILD-2(R3)   ;333
                                ;334

        
        .WORD   MBUILD          ;133335
                                ;336
                                ;337
                                ;338
                                ;339
                                ;340
                                ;341
                                ;342
                                ;343
                                ;344
                                ;345
                                ;346
                                ;347
                               ;348
                                ;349
                                ;350
                                ;351
                                ;352
                                ;353
                                ;354
                                ;355
                                ;356
                                ;357
                                ;358
                                ;359
                                ;360
                                ;361
                                ;362
                                ;363
                                ;364
                                ;365
                                ;366
                                ;367
                                ;368
                                ;369
                                ;370
                                ;371
MBUILD: MOV     #160,R3         ;372
        MOV     @#.DAT3,R4      ;373
        TST     (R5)+           ;374

1$:     MOV     R3,R0           ;13375
        DFRD                    ;376
        MOV     (R4),R0         ;377
        MOV     @.DAT2,R1       ;378
        MOV     R0,(R5)+        ;379
        MOVB    R1,(R5)+        ;380
        INC     R5              ;381
        INC     R3              ;382
        CMP     R3,#163         ;383
        BLT     1$              ;384
2$:     MOV     #16,R0          ;385
        SUB     R0,R5           ;386
3$:     MOV     R3,R0           ;387
        DFRD                    ;388
        MOV     (R4),R0         ;389
        ASR     R0              ;390
        INC     R5              ;391
        MOVB    R0,(R5)+        ;392
        INC     R3              ;393
        CMP     R3,#167         ;394
        BGE     4$              ;395
        TST     (R5)+           ;396
        BR      3$              ;397
4$:     INC     R3              ;398
5$:     MOV     R3,R0           ;399
        DFRD                    ;400
        MOV     (R4),R0         ;401
        MOV  R0,(R5)+           ;402
        INC     R3              ;403
        CMP     R3,#177         ;404
        BLE     5$              ;405
                                ;406
                                ;407
                                ;408
                                ;409
                                ;410
        JSR     R5,RST.5        ;411
        RTS     R5              ;412
                                ;413
                                ;414
                                ;415
        .BLKW   45              ;416 FAKE OUT LOC CTR

;SEQ344

.SBTTL          ERROR STACK COMPARE ROUTINES  22-SEP-75
.REM    %
        ROUTINES TO TEST THE ERROR STACK FOR THE PRESENCE OF DIAGNOSTIC
FUNCTION BIT ENTRIES OF FORMAT TYPE FT8 OR FT9.  SETS A BIT
IN A UML TABLE FOR EACH DIAGNOSTIC FUNCTION BIT FOUND TO CORRESPOND
TO A SPECIFIED LIST.  THE CALL IS JSR R5,CMP.E TO TEST ALL LIST
ENTRIES AND CMP.F TO SCAN FOR THE FIRST ERROR.  THE TRAILING
PARAMETER IS A POINTER TO A BYTE TABLE OF DIAGNOSTIC FUNCTIONS
AND BIT NUMBERS TO BE TESTED.  THE END OF THE TABLE IS DESIGNATED
BY SETTING BIT 7 OF THE LAST BYTE.  R0 MUST POINT TO THE ERROR
STACK FORMAT ENTRY OF FORMAT TYPE FT8 OR FT9.  THE C-BIT IS SET
AND A POINTER TO THE UML TABLE IS RETURNED IN R0 IF ANY MATCH IS
FOUND:  OTHERWISE R0 IS UNCHANGED.
%
CMP.E:  MOVB    #-1,EFLAG       ;SET ALL ERRORS FLAG
        BR      CMP.G           ;
CMP.F:  CLRB    EFLAG           ;CLEAR ALL ERRORS FLAG
        
CMP.G:  MOV     R0,DIF.         ;SAVE ERROR STACK POINTER
        MOV     (R5)+,TEM.      ;GET SPEC TABLE POINTER
        REGSAV
        MOV     TEM.,R4         ;GET SPEC TABLE POINTER
        CLRB    ISOFLG          ;CLEAR UML MATCH FLAG
        CLR     ISOUML          ;CLEAR UML TABLE
        CLR     ISOUML+2        ;
        CLR     ISOUML+4        ;
        CLR     ISOUML+6        ;
1$:     MOVB    (R4)+,R0        ;GET SPEC TABLE ENTRY
        BIT     #100,R0         ;DIAG. FN. OR BIT?
        BEQ     2$              ;BIT
        MOVB    R0,DFD8         ;SAVE FUNCTION
        BR      1$              ;GET BIT
2$:     BIC     #177600,R0      ;CLEAR END BIT
        CLRB    FT8DUN         ;CLEAR ERROR STACK DONE FLAG
        MOV     DIF.,R5         ;GET ERROR STACK POINTER
        CLR     FT9FLG          ;
        CMP     (R5)+,#FT8      ;FORMAT TYPE 8?
        BEQ     3$              ;YES
        MOV     #2,FT9FLG       ;
        CMP     -2(R5),#FT9     ;FORMAT TYPE 9?
        BEQ     3$              ;YES
        FATAL                   ;IMPROPER FORMAT



;SEQ258

3$:     MOV     FT9FLG,R1       ;GET FORMAT FLAG
        JSR     PC,@TSTERS(R1)  ;COMPARE AN ERROR STACK ENTRY
        BNE     4$              ;NO MATCH FOUND
        MOVB    FT8DF,R0        ;GET DIAGNOSTIC FUNCTION
        MOVB    R0,ISOFLG       ;SET UML FLAG
        SR      R0,2            ;DIVIDE DIAG. FN. BY 8


        BIC     #177761,R0      ;
        MOV     R0,DFD8         ;SAVE FOR SBOARD
        JSR     R5,SBOARD       ;SET PROPER BIT IN UML TABLE
                ISOUML          ;
        TSTB    EFLAG           ;ALL ERRORS?
        BNE     5$              ;YES, CONTINUE SCAN
        BR      6$              ;NO, CLEANUP & RETURN
4$:     TSTB    FT8DUN          ;DONE WITH STACK?
        BEQ     3$              ;NO, NEXT STACK ENTRY
5$:     TSTB    -1(R4)          ;DONE WITH SPEC TABLE?
        BPL     1$              ;NO, TRY NEXT
6$:     REGRST
        TSTB    ISOFLG          ;ANY FOUND?
        BEQ     7$              ;NO
        MOV     #ISOUML,R0      ;POINT TO UML TABLE
        SEC                     ;YES, SET C-BIT
7$:     RTS     R5              ;RETURN


;SEQ259

        ;COMPARE A FORMAT TYPE 8 ENTRY

ERSFT8: JSR     PC,GNSCT        ;GET ENTRY FROM ERROR STACK
        CMPB    DFD8,FT8DF      ;THIS DIAGNOSTIC  FUNCTION?
        BNE     6$              ;NO, RETURN
1$:     BITB    R3,(R1)         ;TEST EXPECTED = ACTUAL
        BEQ     2$
        BITB    R3,(R2)         ;
        BEQ     3$              ;NO, ERROR FOUND
        BR      4$              ;YES, MOVE ON
2$:     BITB    R3,(R2)         ;
        BEQ     4$              ;YES, MOVE ON
3$:     CMPB    R0,F8BTF        ;THIS BIT?
        BEQ     6$              ;YES, RETURN
4$:     ASR     R3              ;NEXT BIT
        BNE     5$              ;DONE WITH BYTE?
        BISB    #200,R3         ;YES, START NEXT
        DEC     R1              ;
        DEC     R2              ;
5$:     INC     F8BTF           ;INCREMENT BIT #
        CMPB    F8BTF,F8BTL    ;LAST BIT DONE?
        BLE     1$              ;NO, KEEP ON A PLUGGIN
6$:     RTS     PC              ;RETURN


        ;COMPARE A FT9 ENTRY

ERSFT9: MOVB    (R5)+,FT8DF     ;GET DIAG FN.
        BPL     1$              ;MAKE IT POSITIVE
        NEGB    FT8DF           ;
1$:     MOVB    (R5)+,F8BTF     ;GET BIT
        BMI     2$              ;DONE?
        INCB    FT8DUN          ;YES, SET FLAG & DO COMPARE
        BR      3$              ;
2$:     BICB    #BIT7,F8BTF     ;NO, CLEAR FLAG BIT
3$:     CMPB    DFD8,FT8DF      ;THIS DIAG FN.?
        BNE     4$              ;NO, RETURN
        CMPB    R0,F8BTF        ;COMPARE BITS
4$:     RTS     PC              ;RETURN

TSTERS:         ERSFT8          ;ENTRY POINT FOR FT8
                ERSFT9          ;ENTRY POINT FOR FT9
ISOFLG: .BYTE   0               ;UML TABLE SET FLAG
EFLAG:  .BYTE   0               ;ALL ERRORS FLAG
FT9FLG: .WORD   0               ;SET FOR FT9

DFSAVE: .WORD   0               ;LAST DIAG FN

ISOUML: .WORD   0,0,0,0         ;UML TABLE




;SEQ471

.SBTTL          CHANNEL TEST SUBROUTINES  20-=JAN-76
.REM    %
        ROUTINE TO TEST FOR THE START OF A MEMORY REFERENCE.
COMPLETES ANY REFERENCE IN PROGRESS, & TIMES OUT ON A NEW
REFERENCE.  SETS THE C-BIT IF NO REFERENCE WITHIN 48 MBOX
CLOCKS.
%
TSTREF: MOV     #162,R0         ;TEST SBUS ADR HOLD
        DFRD
        TBIT    31              ;SET?
        BEQ     1$              ;NO
        JSR     R5,FIND1        ;YES, WAIT FOR CLEAR
        S10.    162,31,0        ;
        BCC     1$              ;O.K.
        ERRMSG  <FAILING REF AT PC = >
        MOV     R5,R0           ;GET ERROR PC
        SUB     #4,R0           ;
        ERROCS
        ERROR   <MBOX HUNG>
1$:     PUSH    R4
        MOV     #48.,R4         ;CLOCK COUNT
2$:     JSR     R5,EVENTA       ;STEP THE CLOCK
        S10.    162,31,1        ;SBUS ADR HOLD?
        BCC     3$              ;YES
        DEC     R4              ;DECREMENT CLOCK COUNT
        BGT     2$              ;LOOP UNTIL TIMEOUT
3$:     POP     R4
        RTS     R5              ;C-BIT SET IF TIMEOUT


;SEQ472

.REM    %
        COMPARES STATUS WORD 1 AGAINST SOME EXPECTED DATA.
%
STACOM: JSR     R5,FIND1                ;COMPLETE STORE
        S10.    162,31,0        ;GET TO -SBUS ADR HOLD
        BCC     COMSTA          ;STORE COMPLETED
        ERRMSG  <STORE AT PC = >
        MOV     R5,R0           ;GET ENTRY POINT
        SUB     #4,R0           ;
        ERROCS                  ;TO ERR STACK
        ERROR   <MBOX HUNG>
COMSTA: MOV     #ZERO..,R0      ;MASK TO USE
COMST1: PUSH    R0
        RSTMBX
        POP     R0

COMST2: MOV     R0,1$           ;SET MASK POINTER
        MOV     (R5)+,2$                ;GET STATUS POINTER
        MOV     R4,R0           ;CHANNEL #
        SL      R0,2            ;MUL BY 4
        ADD     #EPT+1,R0       ;ADD CH EPT BASE+1
        MOV     R0,GSTAT                ;TO MOVE INST
        XQT     GSTAT           ;STATUS TO AC17
        READ17
        JSR     R5,MSKDAT               ;COMPAE
1$:     .WORD   0               ;STATUS MASK GOES HERE
2$:     .WORD   0               ;EXPECTED POINTER GOES HERE
        BCS     3$              ;BAD



;SEQ473

        XQT     GETAPR          ;DO CONI APR
        READ17                  
        TBIT    27              ;TEST MB PAR ERR
        BEQ     4$              ;NO ERROR, O.K.
        ERRMSG  <MB PAR ERR, >
3$:     JSR     R5,CHTYP                ;TYPE CHANNEL
        ERRMSG  < STATUS 1 >
        SEC                     ;SET C-BIT
4$:     RTS     R5              ;RETURN
GSTAT:  I10     MOVE,AC17,,0
GETAPR: IO10    CONI APR,,17



;SEQ474

.REM    %
        COMPARES STATUS WORD 2 AGAINST SOME EXPECTED DATA.
%
STAT2:  RSTMBX
        MOV     (R5)+,1$        ;GET STATUS POINTER
        MOV     R4,R0           ;CHANNEL #
        SL      R0,2            ;MUL BY 4
        ADD     #EPT+2,R0       ;ADD CH EPT BASE+2
        MOV     R0,GSTAT        ;TO MOVE INST
        XQT     GSTAT           ;STATUS TO AC17
        READ17
        JSR     R5,MSKDAT               ;COMPARE
        .WORD   ZERO..  ;NO MASK
1$:     .WORD   0               ;EXPECTED POINTER GOES HERE
        BCS     2$              ;BAD
        XQT     GETAPR          ;DO CONI APR
        READ17
        TBIT    27              ;TEST MB PAR ERR
        BEQ     3$              ;NO ERROR, O.K.
        ERRMSG  <MB PAR ERR, >
2$:     JSR     R5,CHTYP                ;TYPE CHANNEL
        ERRMSG  < STATUS 2 >
        SEC                     ;SET C-BIT
3$:     RTS     R5              ;RETURN



;SEQ475


.REM    %
        ROUTINE TO STOP CHANNEL TIMING
%
STOPCH: BIS     #BIT10,RSTWD            ;CHANGE FN 76 DEFAULT
        BR      SPORST          ;DO FIN WRITE 76 $ RETURN

.REM    %
        ROUTINE TO RESTART CHANNEL TIMING
%
STARCH:BIC      #BIT10,RSTWD    ;CHANGE FN 76 DEFAULT
SPORST: DFWRTT          ;STOP OR START CHANNELS
                RSTWD           ;
                76              ;
        RTS     R5              ;RETURN
.REM    %
        ROUTINE TO SYNCHRONIZE CHANNEL TIMING WITH THE MBOX AND
RESTART CHANNEL TIMING
%
CHSYNC: MOV     R5,BRKPC                ;SAVE PC
CHSYN1: PUSH    R1
        MOV     #170,R1         ;FIRST FUNCTION TO READ
1$:     MOV     R1,R0           ;CURRENT FUNCTION
        DFRD                    ;DO THE READ
        TBIT    11              ;TEST CH TO T1 OR T2
        BNE     2$              ;FOUND ONE SET
        INC     R1              ;NEXT FUNCTION
        CMP     R1,#173         ;T3 NXT?
        BLT     1$              ;NO, TEST ANOTHER
2$:     BIC     #170,R1         ;LEAVE ONLY TIME STATWE
        JSR     R5,FIND1        ;GET MBOX TO A CHANGE COMING
        S10.    162,32,0        ;
        MOV     R1,R0           ;GET NUMBER TO BURST
        BEQ     3$              ;NOE
        JSR     R5,BRST1        ;DO BURST
3$:     STARCH
        POP     R1
        RTS     R5              ;RETURN


;SEQ476

.REM    %
        ROUTINE TO PERFORM A NON-MEMORY TYPE DEPENDENT CHAN READ.
%
MEMRD:  MOV     R5,BRKPC        ;SAVE PC
        JSR     R5,FIND1                ;GET TO CORE RD IN PROG
        S10.    165,32,1                ;
        BCS     2$              ;EXIT IF ERROR
        STOPCH
        JSR     R5,FIND1        ;GET TO -CORE RD IN PROG
        S10.    165,32,0        ;
        BCC     1$              ;NO ERROR
        JSR     R5,CHSYN1       ;SYNC MBOX & RESTART CHANNELS
        SEC                     ;SET ERROR FLAG
        BR      2$              ;RETURN
1$:     JSR     R5,CHSYN1       ;SYNC MBOX & RESTART CHANNELS
        JSR     R5,FIND1                ;GET TO -CCL CSH CHAN CYC
        S10.    177,18,1        ;
2$:     RTS     R5              ;RETURN
.REM    %
        ROUTINE TO PERFORM A NON-MEMORY TYPE DEPENDENT CHAN WRITE.
%
MEMWR:  MOV     R5,BRKPC                ;SAVE PC
        JSR     R5,FIND1        ;GET TO -CCL CSH CHAN CYC
        S10.    177,18,1                ;
        BCS     2$              ;EXIT IF ERROR
        STOPCH
        JSR     R5,FIND1                ;GET TO -SBUS ADR HOLD
        S10.    162,31,0        ;
        BCC     1$              ;NO ERROR
        JSR     R5,CHSYN1       ;SYNC MBOX & RESTART CHANNELS
        SEC                     ;SET ERROR FLAG
        BR      2$              ;RETURN
1$:     JSR     R5,CHSYN1       ;SYNC MBOX & RESTART CHANNELS
2$:     RTS     R5              ;RETURN


;SEQ477

.REM    %
        ROUTINE TO PERFORM ENOUGH MBOX CLOCKS TO PERFORM THE NUMBER
OF MEMORY REFERENCES SPECIFIED.  BURSTS THE CLOCK 256 * THE PARAMETER
UNLESS FLAG TRCMEM IS SET.  IN THIS CASE, THE CLOCK IS SINGLE-PULSED
128 * THE PARAMETER.
%
MEMREF: MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,R0        ;GET THE PARAMETER
        SWAB    R0              ;MULTIPLY BY 256.
        ASR     R0              ;
        TST     TRCMEM          ;SINGLE PULSE?
        BEQ     2$              ;NO, BURST
        ASR     R0              ;YES, DIVIDE COUNT BY 2
        PUSH    R1
        MOV     R0,R1           ;COUNT TO R1
1$:     JSR     R5,STEP1        ;ONE MBOX CLOCK
        DEC     R1              ;ENOUGH CLOCKS?
        BGT     1$              ;NO, DO ANOTHER
        POP     R1
        BR      3$              ;RETURN
2$:     JSR     R5,BRST1        ;NOT SINGLE PULSE, DO BURST
3$:     RTS     R5              ;RETURN


;SEQ478

.REM    %M      ROUTINE TO SELECT A STARTING CHANNEL #.  STARTS AT
CHANNEL 0 EXCEPT FOR SPECIFIC TEST STARTS & SCOPEW LOOPS.
CHANNEL # GOES TO R4.
%
CHSTRT: CLR     R4              ;NORMAL CHANNEL #
CSTRT1: TST     TSTART          ;START AT A TEST?
        BEQ     2$              ;NO
        CMPB    TSTART,#377     ;XOR INITIALIZATION?
        BEQ     2$              ;YES, NO START
        TST     FAILCH          ;CHANNEL SELECTED>
        BNE     3$              ;YES, BYPASS DIALOG
        TST     TEND.           ;LOOP ON TEST?
        BNE     1$              ;YES, CHANNEL TO LOOP
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <STARTING >             ;NO, CHANNEL TO START

1$:     JSR     R5,TTICH        ;GET CHANNEL #
        MOVB    R0,FAILCH       ;SET CHANNEL SELECTED
        INCB    FAILCH+1        ;
        BR      3$              ;
2$:     TSTB    LOOPEN          ;LOOP ENABLED?
        BEQ     4$              ;NO, RETURN
        SWITCH                  ;GET CONSOLE SWITCHES
        BIT     R0,#BIT9        ;LOOP ON ERROR?
        BEQ     4$              ;NO, RETURN
3$:     CMPB    FAILCH,R4       ;STARTING CHAN .LT. NORMAL CHAN?
        BLE     4$              ;YES, USE NORMAL CHANNEL
        MOVB    FAILCH,R4               ;CHANNEL # TO R4
4$:     MOV     R4,R0           ;
        SL      R0,3            ;MULTIPLY BY 10
        ADD     R4,R0           ;
        ADD     R4,R0           ;
        MOV     R0,(SP)         ;SET SUBTEST = X0
        RTS     R5              ;RETURN


;SEQ479

.REM    %
        CHANNEL INCREMENTATION CONTROL.  TRUNCATES PROGRAM AT
CHANNEL IF LOOPING ON TEST OR LOOPING ON ERROR & THE CURRENT
TEST HAS FAILED FOR THE CURRENT CHANNEL.  PS IS SET TO EQUAL IF
ALL CHANNELS ARE DONE.
%
NEXTCH: TST     TSTART          ;START AT SPECIFIC TEST?
        BEQ     1$              ;NO
        CMPB    TSTART,#377     ;XOR INITIALIZATION?
        BEQ     3$              ;YES, NORMAL INCREMENT
        TST     TEND.           ;LOOP ON TEST?
        BNE     2$              ;YES
        BR      3$              ;NO
1$:     SWITCH                  ;GET CONSOLE SWITCHES
        BIT     R0,#BIT9                ;LOOP ON ERROR?
        BEQ     3$              ;NO, NORMAL INCREMENT
        TST     FAILCH          ;FAILURE?
        BNE     3$              ;NO, NORMAL INCREMENT
        CMP     CONVRG,TSTNUM   ;THIS TEST?
        BNE     3$              ;NO, NORMAL INCREMENT
2$:     CMPB    R4,FAILCH       ;THIS CHANNEL?
        BEQ     4$              ;YES, SET DONE
3$:     CMP     R4,#7           ;LAST CHANNEL?
        BEQ     4$              ;YES, SET DONE
        INC     R4              ;NEXT CHANNEL
        MOV     R4,R0           ;CHANNEL TO R0
        SL      R0,3            ;X0 TO SUBTEST
        ADD     R4,R0           ;
        ADD     R4,R0           ;
        MOV     R0,(SP)         ;UPPER SUBTEST DIGIT IS CH
4$:     RTS     R5              ;RETURN
.REM    %
        CHANNEL FAULT RETURN GETS CHANNEL # FROM R4
%
CFAULT: JSR     R5,CHTYP                ;CHANNEL TO ERROR STACK
        JMP     FAULT           ;FAULT RETURN


;SEQ480

.REM    %
        ROUTINE TO ASK FOR & GET A CHANNEL.
%
TTICH:  PFORCE                  ;FORCE TYPEOUTS
        PMSG    <CHANNEL: _>
        TTILIN                   ;GET REPLY
        BCS     1$              ;TIMEOUT
        TTICHR                  ;GET CHARACTER
        BCS     TTICH           ;NO CHARACTER
        SUB     #60,R0          ;CONVERT TO OCTAL
        BLT     TTICH           ;NOT NUMERIC
        CMP     R0,#7
        BGT     TTICH           ;GREATER THAN 7
        PUSH    R0              ;SAVE RESULT
TTICHR                  ;GET NEXT CHARACTER
        BCS     TTICH           ;NO CHARACTER
        CMP     R0, #CR         ;
        BNE     TTICH           ;NOT CARRIAGE RETURN
        PNORML                  ;NORMAL TYPEOUTS
        POP     R0              ;RESTORE CHANNEL #
        RTS     R5              ;RETURN
1$:     PMSG    <TIMEOUT\>
        ERREOP
.REM    %
        ROUTINE TO TYPE CHANNEL & SET FAILCH.
%
CHTYP:  ERRMSG  <CHANNEL >      ;CHANNEL TO ERROR STACK
        MOV     R4,R0           ;
        ERROCS                  ;
        MOVB    R4,FAILCH       ;SAVE FAILING CHANNEL
        MOVB    #1,FAILCH+1     ;SET FLAG
        RTS     R5              ;RETURN


;SEQ483

        .SBTTL  MBOX UTILITY SUBROUTINE LIBRARY

.REM    %
INITM - ROUTINE TO INITIALIZE TABLES FOR MSUB.
%
INITM:
        MOV     #$TRAP,34       ;SET TRAP VECTOR
        DTEBAS                  ;GET DTE 20 BASE ADDRESS
        MOV     #BASE20,R1      ;
1$:     MOV     R0,(R1)+        ;POINTERS TO TABLE
        INC     R0              ;
        INC     R0              ;
        CMP     R1,#.DAT1       ;DONE?
        BLOS    1$              ;NO, LOOP AGAIN
        MOV     #SSCLK,CLKTYP   ;SET CLOCK TYPE TO MBOX
        MOV     #BASE20-$FLAGS-2,R0     ;# OF FLAGS-2 * 2
2$:     CLR     @$FLAGS(R0)     ;CLEAR A FLAG
        DEC     R0              ;
        DEC     R0              ;
        BGE     2$              ;ALL CLEARED?
        RTS     R5              ;YES, RETURN
$FLAGS: .WORD   $RUNFL          ;FLAGS TO CLEAR
        .WORD   CRAFLG          ;DIAG CRAM ADDR TO USE
        .WORD   MEMFLG          ;NO FORCE SBUS RESET
        .WORD   CSHFLG          ;NO SET CACHE LOOK & LOAD
        .WORD   PMAFLG          ;NO FORCE PMA TO ERG
        .WORD   EXTFLG          ;NO FORCE EXTEND
        .WORD   CHFLAG          ;NO CHANNEL REST
        .WORD   CLKFLG          ;NO CLOCK STOP CONDITIONS

BASE20: .WORD   174400          ;DTE BASE ADDRESS
.DAT3:  .WORD   174402          ;POINTER TO DEXWD3
.DAT2:  .WORD   174404          ;POINTER TO DEXWD2
.DAT1:  .WORD   174406          ;POINTER TO DEXWD1

LODERR: .ASCIZ  %AC LOAD ERROR\%
        .EVEN

ZERO..: .WORD   0,0,0            ;A 36-BIT ZERO CONSTANT
REVNUM: .BYTE   0               ;HARDWARE REV LEVEL INSERTED
VERNUM: .BYTE   1               ;PROGRAM VERSION INSERTED
CSHNBR:         0               ;OTHER COMMON DATA & VARIABLES
SCRWD:          0               ;SCRATCH WORD
SVERSP:         0
ERBIT:  .WORD   0               ;LAST KL BIT TESTED BY TBIT
ADRL:   .WORD   0               ;BUFFER LOCATION FOR ADDRESSES
ADRH:   .WORD   0,0             ;


;SEQ263

.REM    %
GETVER - SUBROUTINE TO CHECK FOR PROGRAM VERSION AND SOLICIT ONE
IF NOT PRESENT.
%
GETVER: TST     REVNUM          ;VERSION SET?
        BNE     4$              ;YES, RETURN
1$:     PMSG    <HARDWARE REV: _>

        TTILIN                  ;GET REPLY
        BCC     2$              ;GOT ONE
        COM     REVNUM          ;TIMEOUT, SET REV TO -1
        PCRLF                   ;FINISH LINE
        BR      4$              ;RETURN
2$:     TTIDEC          ;
        BCS     1$      ;GARBAGE REPLY
        MOVB    R0,REVNUM       ;SAVE REV LEVEL
3$:     PMSG    <VERSION: _>

        TTILNW          ;WAIT FOR REPLY
        TTIDEC          ;
        BCS     3$      ;GARBAGE REPLY
        MOVB    R0,VERNUM       ;SAVE VERSION
4$:     RTS     R5


.REM    %
PNTVER - SUBROUTINE TO PRINT PROGRAM VERSION IF SET
%
PNTVER: TST     REVNUM          ;VERSION SET?
        BEQ     1$              ;NO, RETURN
        BMI     1$              ;NEGATIVE, RETURN
        PMSG    < VER >

        MOVB    VERNUM,R0       ;GET PROGRAM VERSION
        PNTDEC                  ;PRINT IT
        MOVB    REVNUM,R0       ;GET HARDWARE LEVEL
        PNTDEC                  ;PRINT IT
        PNTBAK                  ;DISCARD PERIOD
1$:     RTS     R5              ;RETURN



.SBTTL          TIME DELAY ROUTINE       6-APR-78
.REM    %
        CALTIM - SUBROUTINE TO CALIBRATE A 1 MILLISECOND LOOP USING
THE KW11L AS A TIMING SOURCE.  MUST BE CALLED BEFORE USING TWAIT.
SINCE THE LOOP IS TO BE USED FOR TIMING EVENTS IN THE KL-10, THE
TIME IS MULTIPLIED BY THE CLOCK-RATE SELECTED.  NOTE THAT 1 MS IS
ONLY APPROXIMATE, AND THAT 50 HZ POWER EXTENDS THE TIME.
%
CALTIM: MOV     #77777,TIMCNT   ;SET MAX POS LOOP COUNT
        MOV     #3$,KWLIV       ;SET KW11L INTERRUPT VECTOR
        CLR     KWLIV+2         ;PS TO USE
        MOV     #KWLKE,KWLKS    ;SET KW11L INTERRUPT ENABLE
        PUSH    PS              
        CLR     PS              ;SET PRIORITY LEVEL 0
1$:     CLR     R0              ;START LOOP
2$:     INC     R0              ;
        CMP     R0,TIMCNT               ;MAX REACHED?
        BLT     2$              ;NO, CONTINUE COUNT
        CLR     KWLKS           ;ERROR, CLEAR KW11L ENABLE
        POP     PS              ;RESTORE PRIORITY LEVEL
        PMSG    <NO KW11L INTERRUPT\>
        FATAL                   ;KW11L NOT COUNTING?
3$:     MOV     #4$,KWLIV               ;GO FIRST INTERRUPT
        MOV     #1$,(SP)        ;DO SAME FOR SECOND
        RTI                     ;
4$:     MOV     #5$,(SP)        ;GOT SECOND
        RTI                     ;CLEAR INTERRUPT STATUS
5$:     CLR     KWLKS           ;CLEAR KW11L ENABLE
        POP     PS              ;RESTORE PROCESSOR STATUS
        MOV     R0,TIMCNT       ;SAVE 16 MS TIME BASE

        CLKPRM                  ;GET CLOCK RATE
        MOV     (R0),R0         ;
        MOV     R0,CLKVAL       ;SAVE CLOCK SOURCE & RATE
        BIC     #177774,R0      ;
        MOV     R0,CLKRAT       ;SAVE CLOCK RATE
        NEG     R0              ;CALCULATE SHIFT FOR DIVIDE
        ADD     #4,R0           ;
6$:     ASR     TIMCNT          ;DIVIDE BY PROPER POWER OF 2
        DEC     R0              ;
        BGT     6$              ;ENOUGH SHIFTS DONE?
        INC     TIMCNT          ;YES, ROUND UP
        RTS     R5              ;"1 MS" TIME COUNT CALIBRATED
CLKVAL: .WORD   0               ;CLOCK SOURCE & RATE
CLKRAT: .WORD   0               ;CLOCK RATE SELECTED


;SEQ484

.REM    %
        TWAIT - SUBROUTINE TO WAIT  A SPECIFIED PERIOD OF TIME.  THE
PARAMETER IN R0 IS THE NUMBER OF MILLISECONDS TO WAIT.  THE MINIMUM
WAIT IS 1 MS.  THIS WAIT MUST BE CALIBRATED BY CALLING CALTIM BEFORE
FIRST USEAGE.  THE DELAY IS INCREASED TO 1.2 MS FOR 50 HZ POWER.
%
TWAIT:  PUSH    R1
        
1$:     CLR     R1              ;CLEAR DELAY COUNT
2$:     INC     R1              ;COUNT # OF LOOPS
        CMP     R1,TIMCNT               ;1 MS WORTH?
        BLT     2$              ;NO, KEEP COUNTING
        DEC     R0              ;TOTAL DELAY DONE?
        BGT     1$              ;NO, WAIT 1 MS MORE
        
        POP     R1
        RTS     R5              ;DELAY DONE, RETURN
TIMCNT: .WORD   77777           ;CALIBRATED COUNT GOES HERE


.SBTTL          RESET SUBROUTINES
.REM    %
        ROUTINES TO RESET MEM CONTROLLERS & MBOX.  DOES A MASTER
RESETS & SETS THE MICRO CODE STARTING ADDRESS.  ISSUES 1 MBOX
CLOCK AFTER CLEARING MR.  THE SETTING OF ONE OR MORE FLAGS MAY CAUSE 
THIS SUBROUTINE TO PERFORM MORE THAN THE BASIC FUNCTIONS:
        CLKFLG = SET CLOCK STOP CONDITIONS
                BIT 0 = FS PROBE
                BIT 1 = DRAM PARITY
                BIT 2 = CRAM PARITY
                BIT 3 = FM PARITY
        CRAFLG = SET DIAG CRAM ADDR TO VALUE
        CSHFLG = SET LOOK & LOAD & CLEAR THE EBR
        PMAFLG = FORCE PMA TO EBUS REG
        MEMFLG = INHIBIT MEMORY CONTROLLER TIMING
        EXTFLG = SET FORCE EXTEND
        CHFLAG = PERFORM AT LEAST 35 CLOCKS FOR CHANNEL RESET
%
MEMRST: DFWRTT                  ;RESET MEMORY CONTROLLERS
                KLB24           ;
                76              ;
RSTMBX: MOV     R5,BRKPC        ;SAVE PC
        JSR     PC,SPCRST       ;DO SPECIAL RESET SUBROUTINE
CSHSET: TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO
        MOV     #CSHALW,R0      ;SET CACHE LOOK & LOAD
        JSR     R5,XQT1         ;CONTROLLED EXCT
1$:     RTS     R5              ;RETURN

MEMFLG: .WORD   0               ;INHIBIT MEM CONTROLLER TIMING
CSHFLG: .WORD   0               ;CACHE ENABLE FLAG
PMAFLG: .WORD   0               ;PMA TO ERG ENABLE FLAG
EXTFLG: .WORD   0               ;FORCE EXTEND FLAG - FUNCTIONS ON
                                ;MODEL B PROCESSOR ONLY
CHFLAG: .WORD   0               ;CHANNEL RESET FLAG
CLKFLG: .WORD   0               ;SET INDICATED CLK STOP CONDITION
CRAFLG: .WORD   0               ;VALUE FOR DIAG CRAM ADDR
RSTWD:  .WORD   0               ;RESET CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CLKWD:  .WORD   0               ;CLOCK STOP CONTROL WORD
        .BYTE   0,0,0           ;REMAINDER OF 36-BIT WORD
        .EVEN
CSHALW: IO10    CONO PAG,,600000


KLB24:  WD36    0,0,4000


KLB35:  WD36    0,0,1


        .EVEN



;SEQ486

SPCRST: TSTB    XMODE           ;XOR MODE?
        BEQ     12$             ;NO
        ;THE FOLLOWING CODE IS EXECUTED WHEN XOR TESTING A CHANNEL
        ;BOARD ONLY.  ITS PURPOSE IS TO AVOID A RACE CONDITION TO
        ;PINS CE1 & CF2 ON THE M8533 DURING A MR RESET.  THIS SIG-
        ;NAL IS BLOCKED BY MR RESET ON THE M8535, SO THAT NO RACE
        ;EXISTS DURING NORMAL OPERATION.
        DFXCTT                  ;STOP THE CLOCK
                STPCLK          ;
        TENBIT  170,11          ;CH T0?
        BNE     11$             ;YES
        TENBIT  173,11          ;CH T3?
        BEQ     12$             ;NO
        
11$:    DFSCLK                  ;GET CH TIMING TO T1 OR T2
        DFSCLK                  ;END OF SPECIAL CODE


;SEQ487

12$:    MOV     CRAFLG,R0       ;GET VALUE FOR DIAG CRAM ADDR
        WWADR                   ;MR RESET/LOAD CRAM ADDR
        CLR     R0              ;CLEAR FN 76 BITS
        TST     MEMFLG          ;FORCE SBUS RESET?
        BEQ     1$              ;NO
        BIS     #BIT11,R0               ;YES, SET BIT FOR FN 76
1$:     TST     PMAFLG          ;SET PMA TO ERG?
        BEQ     2$              ;NO
        BIS     #BIT9,R0        ;YES, SET BIT FOR FN 76
2$:     TST     EXTFLG          ;FORCE EXTEND?
        BEQ     22$             ;NO
        BIS     #BIT8,R0        ;YES, SET BIT FOR FN 76
22$:    MOV     R0,RSTWD        ;PUT BITS IN FUNCTION
        DFWRTT                  ;DO ANY SPECIAL CONTROL
                RSTWD           ;BITS SET UP[
                76              ;FUNCTION CODE
        DFSCLK                  ;STEP THE CLOCK
        MOV     CLKFLG,CLKWD    ;GET CLK ERROR STOP CONDITIONS
        BEQ     3$              ;NONE
        DFWRTT          ;ENABLE CONDITIONS
                CLKWD           ;CONDITIONS
                46              ;FUNCTION CODE
        DFWRTT                  ;ENABLE CLOCK STOP
                KLB35   ;
                47              ;
3$:     TST     CHFLAG          ;RESET CHANNELS TOO?
        BEQ     4$              ;NO
        MOV     #34.,R0         ;
        JSR     R5,BRST1        ;YES, BURST 34 TICKS
4$:     RTS     PC              ;RETURN

;SEQ267

.SBTTL          REGISTER SAVE & RESTORE ROUTINES

;ROUTINE TO SAVE R3-R5
;
SAV.3:  PUSH    R4

        PUSH    R3

        PUSH    4(SP)

        RTS     R5              ;STACK HAS R5,R4,R3


;RESTORE R3-R5
;
RST.3:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R3

        POP     R4

        RTS     R5

;ROUTINE TO SAVE R1-R5
;
SAV.5:  PUSH    R4

        PUSH    R3

        PUSH    R2

        PUSH    R1
   
        PUSH    10(SP)

        RTS     R5      ;STACK HAS R5,R4,R3,R2,R1

;RESTORE        R1-R5
;
RST.5:  MOV     (SP),(SP)+      ;GARBAGE COLLECT
        POP     R1

        POP     R2

        POP     R3

        POP     R4

        RTS     R5


;SEQ269

.SBTTL          PROGRAM RUN ROUTINES

        ;ROUTINES TO START & RUN A KL10 PROGRAM.  ALL PROGRAMS
        ;ARE EXPECTED TO END WITH A HALT.  A WATCHDOG TIMER IS
        ;USED TO RETURN WITH THE C-BIT SET IF NO HALT OCCURS
        ;WITHIN THE TIME INTERVAL SPECIFIED.  INTERVALS ARE IN
        ;INCREMENTS OF 30MS.  IF A FUNCTION BREAKPOINT IS ACTIVE,
        ;THE TIMEOUT IS PERFORMED BY COUNTING CLOCK TICKS OF THE
        ;MBOX CLOCK, OTHERWISE THE PDP-11 LINE-FREQUENCY CLOCK
        ;IS USED.

.REM    %
        
RUNPRG - RUNS A KL PROGRAM STARTING AT THE GIVEN ADDRESS 0-177777
AND WAITS FOR EITHER A HALT OR A TIMEOUT.
%
RUNPRG: MOV     R5,BRKPC        ;SAVE PC
RUNPR1: MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
        MOV     #2,TIMINT       ;SET TIME INTERVAL OF 2 16MS
RUNPR2: MOV     #RUNJRS,R0      ;POINT AT JRST
        JSR     R5,XQT1         ;DO JRST
        BR      CON2            ;CONTINUE
        
.REM    %
RUNBIG - RUN A PROGRAM WHICH TAKES MORE THAN 30 MILLISECONDS.
CALLING FORMAT:
        JSR     R5,RUNBIG
        ENTRY+2 = # OF 30 MS INTERVALS FOR TIMEOUT
        ENTRY+4 = STARTING ADDRESS (0-177777)
%
RUNBIG: MOV     R5,BRKPC        ;SAVE PC
RUNBG1: MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        MOV     (R5)+,RUNJRS    ;PUT ADDRESS INTO JRST
RUNBG2: ASL     TIMINT          ;USE TWICE INTERVAL PARAMETER
        BR      RUNPR2          ;EXECUTE JRST & CONTINUE

.REM    %
        WAIT THE INTERVAL SPECIFIED FOR THE PROCESSOR TO HALT.
%
HWAIT:  MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,TIMINT    ;SAVE INTERVAL COUNT
        BR      CON3            ;WAIT FOR HALT OR TIMEOUT

LOOPK:  .WORD   0               ;#OF TIMEOUT LOOPS
TIMINT: .WORD   0               ;# OF TIMEOUT INTERVALS

RUNJRS: I10     JRST    0,,0


        .EVEN


;SEQ270

.REM    %
        CONTIN - STARTS THE KL RUNNING.  SETS THE C-BIT IF NO HALT WITHIN
        THE TIMING INTERVAL SPECIFIED.
%
CONTIN: MOV     R5,BRKPC        ;SAVE PC
CON1:   MOV     #2,TIMINT       ;SET TIMING = 30 MS
CON2:   DFXCTT                  ;SET RUN FLOP
                SETRUN          ;
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
CON3:   TST     FNBRK           ;FUNCTION BREAK ACTIVE?
        BNE     5$              ;YES, USE SINGLE PULSES
        CLKPRM                 ;GET CLOCK RATE
        MOV     (R0),R0         ;
        BIC     #177774,R0      ;
1$:     DEC     R0              ;MULTIPLY INTERVAL BY RATE
        BMI     2$              ;
        ASL     TIMINT          ;
        BR      1$                      ;
2$:     INC     TIMINT          ;ADD ONE
        MOV     BASE20,R0       ;GET DTE20 BASE
3$:     CLR     KWLKS           ;CLEAR 11 CLOCK
4$:     BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES,RETURN
        TST     KWLKS           ;CLOCK TICKED?
        BEQ     4$              ;NO TEST KL AGAIN
        DEC     TIMINT          ;TIMEOUT COMPLETE?
        BGT     3$              ;NO WAIT ANOTHER 16MS (MIN)
        BR      9$              ;YES TIMEOUT
5$:     MOV     #7,R0           ;GET OUT OF HALT LOOP
        JSR     R5,BRST1        ;
6$:     MOV     #1000.,STEPK    ;COUNT 50,000 TICKS
7$:     MOV     #50.,LOOPK      ;
8$:     JSR     R5,STEP1        ;SINGLE PULSE
        MOV     BASE20,R0       ;GET DTE20 BASE
        BIT     #HALTLP,DIAG1(R0)       ;KL HALTED?
        BNE     11$             ;YES, RETURN
        DEC     LOOPK           ;DECREMENT COUNTERS
        BGT     8$              ;
        DEC     STEPK           ;
        BGT     7$              ;UNTIL DONE
        DEC     TIMINT          ;DECREMENT INTERVAL COUNT
        BGT     6$              ;
9$:     TST     CLKFLG          ;CLK STOP ENABLED?
        BEQ     10$             ;NO,JUST ERROR RETURN
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERR STOP?
        BEQ     10$             ;NO, RUN TIMEOUT
        JMP     CLKERR          ;GO TO CLK ERROR POINT
10$:    SEC                     ;SET ERROR FLAG
        BR      12$             ;
11$:    CLC                     ;KL HALTED (NORMAL)
12$:    RTS     R5              ;RETURN

;SEQ271

.SBTTL          MBOX CLOCK CONTROL ROUTINES
.REM    %
FIND - STEPS THE CLOCK UNTIL AN EVENT LEADING EDGE IS FOUND OR
4092 CLOCKS HAVE BEEN ISSUED.  RETURNS THE CLOCK COUNT IN R0 &
SETS THE C-BIT IF TIMEOUT.
%
FIND:   MOV     R5,BRKPC        ;SAVE PC
FIND1:  MOV     (R5)+,R0        ;PARAMETERS TO R0
FIND2:  JSR     R5,SAV.5        ;SAVE R1-R5
        MOV     #1,STEPK        ;SET CLOCK COUNT = 1
        JSR     PC,EVENT2       ;TEST FOR EVENT
        BCC     2$              ;FOUND ON FIRST TICK
1$:     JSR     PC,EVENT3       ;TEST SAME EVENT AGAIN
        INC     STEPK           ;INCREMENT CLOCK COUNT
        BCC     2$              ;EVENT FOUND
        CMP     STEPK,#4092.    ;TIMEOUT?
        BLT     1$              ;NO,TRY AGAIN
        SEC                     ;YES,SET ERROR FLAG
2$:     MOV     STEPK,R0        ;CLOCK COUNT TO R0
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5      ;RETURN

STEPK:  .WORD   0               ;STEP COUNT


;SEQ272

.REM    %
STEP10 - ROUTINE TO GET MACHINE TO KNOWN MBOX STATE WHILE
EXECUTING A PDP10 INSTRUCTION.
%
STEP10: MOV     R5,BRKPC        ;SAVE PC
STP10A: MOV     (R5)+,R0        
        LODAR                   ;GET INSTRUCTION NEATLY IN AR
        MOV     #CONBUT,R0      
        DFXCT                   ;PRESS CONTINUE BUTTON
        TST     $RUNFL          ;SHOULD I PRESS RUN, TOO?
        BEQ     STPC1           ;NO IF ZERO
        MOV     #SETRUN,R0
        DFXCT                   ;DO IT
        BR      STPC1           ;CONTINUE

.REM    %
STPCON - FINDS THE LEADING EDGE OF AN EVENT & REPLACES THE EVENT
WITH A BURST COUNT OR BURSTS THE CLOCK IF NO EVEN SPECIFIED.
%
STPCON: MOV     R5,BRKPC        ;SAVE PC
STPC1:  MOV     (R5)+,R0        ;GET THE PARAMETER
        TST     R0              ;
        BMI     1$              ;STEP IF NEGATIVE
        PUSH    R0              ;SAVE BURST COUNT

        JSR     R5,BRST1        ;BURST IF POSITIVE
        POP     R0              ;RESTORE BURST COUNT

        BR      2$              ;
1$:     JSR     R5,FIND2        ;FIND EVENT
        BCS     2$              ;ERROR, TIMEOUT
        TST     NOBRST          ;FUNCTIONAL TEST ONLY?
        BNE     2$              ;YES, DON'T SAVE BURST COUNT
        MOV     R0,-2(R5)       ;O.K., SAVE BURST
2$:     RTS     R5              ;
NOBRST: .WORD   0               ;NEVER SET BY PROGRAM
$RUNFL: .WORD   0               ;-1 MEANS SET RUN BEFORE STEP
        

;SEQ273

.SBTTL          FUNCTION BREAKPOINT & CLOCK CONTROL

        ;ROUTINE TO SET A FUNCTION BREAKPOINT.

FB..:   TTISDL                  ;DIAGNOSTIC PN SPECIFIED?
        BCC     2$              ;YES, USE IT
1$:     PMSG    <DIAGNOSTIC FUNCTION: _>

        TTILNW                  ;WAIT FOR REPLY
2$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;NOT OCTAL
        CMP     R0,#77          ;TOO SMALL?
        BLE     BRKERR          ;YES
        CMP     R0,#177         ;TOO BIG?
        BGT     BRKERR          ;YES
        MOVB    R0,FNBRK+1      ;SET FN IN BREAK WORD
        TTISDL                  ;BIT SPECIFIED?
        BCC     4$              ;YES, USE IT
3$:     PMSG    <BIT: _>

        TTILNW                  ;WAIT FOR REPLY
4$:     TTIDEC                  ;CONVERT DECIMAL VALUE
        BCS     BRKERR          ;NOT DECIMAL
        CMP     R0,#35.         ;TOO BIG?
        BGT     BRKERR          ;YES
        CLR     R1              ;CLEAR WORD INDEX
        SUB     #20.,R0         ;BITS 20-35?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 4-19?
        BPL     5$              ;YES
        INC     R1              ;NEXT WORD INDEX
        ADD     #16.,R0         ;BITS 0-3
5$:     MOV     #15.,R2          ;SWAP ORDER OF SIGNIFICANCE
        SUB     R0,R2           ;
        ASL     R2              ;POSITION
        ASL     R2              ;
        BIS     R1,R2           ;SET WORD INDEX
        MOVB    R2,FNBRK        ;SET BIT IN FN BREAK
        TTISDL                  ;POLARITY SPECIFIED?
        BCC     7$              ;YES, USE IT
6$:     PMSG    <0 OR 1? _>

        TTILNW                  ;GET REPLY
7$:     TTIOCT                  ;CONVERT OCTAL VALUE
        BCS     BRKERR          ;GARBAGE
        TST     R0              ;
        BEQ     8$              ;
        BIS     #100,FNBRK      ;SET POLARITY = 1
8$:     JMP     @COMRET         ;NEXT COMMAND


;SEQ274

        ;ROUTINE TO CLEAR A FUNCTION BREAKPOINT.

CB..:   CLR     FNBRK           ;CLEAR IT
        CLR     SAVBRK          ;CLEAR EXEC SAVE BREAK
        JMP     @COMRET         ;NEXT COMMAND



        ;BREAKPOINT DETECTED.

BRKPNT: MOV     R0,BRKR0        ;SAVE REGISTERS
        MOV     R1,BRKR1
        MOV     R2,BRKR2
        MOV     R3,BRKR3
        MOV     R4,BRKR4
        MOV     R5,BRKR5
        MOV     SP,BRKSP
        PCRLF                   ;CARRIAGE RETURN
        PFORCE                  ;FORCE TYPEOUTS
        PMSG    <FN. BREAK AT PC >

        MOV     BRKPC,R0        ;GET SUBROUTINE PC
        SUB     #4,R0           ;
        PNTOCS                  ;PRINT IT
        PCRLF
        INC     BRKFLG          ;SET BREAKPOINT FLAG
        JMP     @COMRET         ;RETURN TO COMMAND MODE


        BRKR0:  .WORD   0       ;REGISTER STORE FOR FN. BREAK
        BRKR1:  .WORD   0
        BRKR2:  .WORD   0
        BRKR3:  .WORD   0
        BRKR4:  .WORD   0
        BRKR5:  .WORD   0
        BRKSP:  .WORD   0
        BRKPC:  .WORD   0

        COMRET: .WORD   0       ;RETURN POINT
        BRKFLG: .WORD   0       ;BREAK PERFORMED FLAG
        FNBRK:  .WORD   0       ;DIAG. FN., BIT & POLARITY
        SAVBRK: .WORD   0       ;FUNCTION BREAK SAVE


;SEQ275

        ;BREAKPOINT CONTINUE

FC..:   TST     BRKFLG          ;BREAKPOINT PERFORMED?
        BNE     BRKRST          ;YES
BRKERR: PNTCI,'?                ;PRINT ?
        JMP     @COMRET         ;RETURN TO COMMAND MODE
BRKRST: PNORML                  ;NORMAL TYPEOUTS
        MOV     BRKR0,R0        ;RESTORE REGISTERS
        MOV     BRKR1,R1
        MOV     BRKR2,R2
        MOV     BRKR3,R3
        MOV     BRKR4,R4
        MOV     BRKR5,R5
        MOV     BRKSP,SP
        CLR     BRKFLG          ;CLEAR CONTINUE
        JMP     BRKCON          ;CONTINUE FROM BREAK


        ;PRINT REGISTERS

RG..:   CLR     R1              ;REGISTER INDEX
1$:     PNTCI,'R                ;PRINT REGISTER #
        MOV     R1,R0           ;
        PNTOCS                  ;
2$:     PNTCI,'/                ;
        MOV     R1,R2           ;
        ASL     R2              ;
        MOV     BRKR0(R2),R0    ;GET CONTENTS
        PNTOCT                  ;PRINT IT
        INC     R1              ;NEXT REGISTER
        CMP     R1,#6           ;DONE?
        BLT     1$              ;NO, NEXT ONE
        BGT     3$              ;YES
        PMSG    <SP>            ;NO, STACKPOINTER

        BR      2$              ;PRINT IT
3$:     PCRLF                   ;CARRIAGE RETURN
        JMP     @COMRET         ;NEXT COMMAND


;SEQ276

.REM    %
        GENERATES AN EBOX OR AN MBOX CLOCK DEPENDING UPON ENTRY.
TESTS FOR THE OCCURENCE OF AN EVENT IF A FUNCTION BREAKPOINT IS
SET.  CALL IS VIA JSR,R5.
%
ESTEP:  MOV     R5,BRKPC        ;SAVE PC
ESTEP1: MOV     #SECLK,R0       ;DIAG FN TO RO
        BR      XSTEP           ;DO EBOX CLOCK
STEP:   MOV     R5,BRKPC        ;SAVE PC
STEP1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     1$              ;NO, JUST STEP
        MOV     #SSCLK,R0       ;DIAG FN TO RO
        BR      TSTBRK          ;STEP AND TEST
1$:     DFSCLK                  ;STEP MBOX CLOCK
        BR      CLKERC          ;CHECK CLKERROR STOP
XSTEP:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     TSTBRK          ;YES, STEP & TEST
        DFXCT                   ;NO, JUST STEP IT
CLKERC: MOV     BASE20,R0       ;GET DTE20 BASE ADDRESS
        BIT     #ERRSTP,DIAG1(R0)       ;CLK ERROR STOP?
        BEQ     1$              ;NO, RETURN
        TST     CLKFLG          ;CLOCK ERR STOP ENABLED?
        BNE     CLKERR          ;YES, GO TO ERROR POINT
        SEC                     ;NO, SET ERROR FLAG
1$:     RTS     R5              ;RETURN

CLKTYP: .WORD   SSCLK           ;CLOCK TYPE

TSTBRK: MOV     R0,CLKTYP       ;SAVE DIAG FN FOR CLOCK
        MOV     FNBRK,R0        ;GET BREAKPOINT
        PUSH    R0              ;SAVE IT

        CLR     FNBRK           ;CLEAR REENTRY
        JSR     R5,EVENT1       ;STEP & TEST
        MOV     #SSCLK,CLKTYP   ;RESET CLOCK TYPE
        POP     FNBRK           ;RESTORE BREAKPOINT

        BCS     BRKCON          ;EVENT DETECTED?
        JMP     BRKPNT          ;YES
BRKCON: CLC
        RTS     R5              ;RETURN


;SEQ277

.REM    %
                GENERATES A BURST OF CLOCK PULSES.
%
BRST:   MOV     R5,BRKPC        ;SAVE PC
        MOV     (R5)+,R0        ;GET THE BURST COUNT
BRST1:  TST     FNBRK           ;FUNCTION BREAKPOINT?
        BEQ     2$              ;NO,DO A REAL BURST
        PUSH    R1

        MOV     R0,R1           ;BURST COUNT TO R1
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        DEC     R1              ;
        BGT     1$              ;LOOP UNTIL DONE
        POP     R1

        BR      3$              ;
2$:     BURST
        JSR     R5,CLKERC       ;TEST FOR CLK ERR STOP
3$:     RTS     R5              ;RETURN

;SEQ278

.REM    %
        ERROR POINT FOR EBOX CLOCK STOP ERRORS.  DETERMINES THE
ERROR TYPE & PRINTS THE ERROR TYPE & SUBROUTINE ENTRY POINT.
%
CLKERR:         ERRMSG  <CLK ERROR STOP - >

        MOV     #103,ERRFCT     ;DIAG FN TO READ
        JSR     PC,ERRCLK       ;TESTS BIT 30
        BEQ     1$              ;NO DRAM PAR ERR
        ERRMSG  <DRAM PAR\>

1$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     2$              ;NO CRAM PAR ERR
        ERRMSG  <CRAM PAR\>

2$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     3$              ;NO FM PAR ERR
        ERRMSG  <FM PAR\>

3$:     JSR     PC,ERRCLK       ;NEXT FUNCTION
        BEQ     4$              ;NO FS ERROR
        ERRMSG  <FS CHECK\>

4$:     ERRMSG  <CALL PC = >

        MOV     BRKPC,R0        ;GET CALLER'S PC
        SUB     #4,R0           ;FIX IT
        ERROCT                  ;PRINT IT
        ERCRLF                  ;CARRIAGE RETURN
        ERROR                   ;EBOX ERROR


;SEQ279

ERRCLK: DFRDT           ;READ A FUNCTION
ERRFCT:         103     ;FIRST ONE IS 103
        INC     ERRFCT  ;SETUP NEXT
        TBIT    30      ;TST PROPER CLK ERR


        RTS     PC      ;RETURN


;SEQ280

.REM    %
        TESTS FOR THE FIRST OCCURENCE OF AN EVENT. STEPS THE
PROPER CLOCK ONCE & SETS THE C-BIT IF THE EVENT DOES NOT OCCUR.
CALL IS JSR,R5.  PARAMETER TRAILS FOR EVENT & IS IN R0 FOR
EVENT1.  EVENT1 DOES NOT SAVE THE FUNCTION BREAK PC.
%

EVENT:  MOV     R5,BRKPC        ;SAVE PC
EVENTA: MOV     (R5)+,R0        ;PARAMETERS TO R0
EVENT1: JSR     R5,SAV.5        ;SAVE R1-R5
        JSR     PC,EVENT2       ;CHECK FOR EVENT 
        JSR     R5,RST.5        ;RESTORE R1-R5
        RTS     R5              ;RETURN

        ;SUBROUTINE TO TEST FOR EVENT WITHOUT SAVING & RESTORING
        ;REGISTERS.  LEAVES R1-R5 EQUAL TO THE FOLLOWING
        ;R1 = THE POLARITY OF THE DIAGNOSTIC FN READ
        ;R2 = THE POLARITY FOR THE EVENT TO BE DETECTED
        ;R3 = THE DIAGNOSTIC FUNCTION READ
        ;R4 = THE BIT MASK TO APPLY TO THE APPROPRIATE DEXWD
        ;R5 = THE ADDRESS OF THE PROPER DEXWD TO TEST

EVENT2: MOVB    R0,R2           ;PARAMETER LOWER TO R2
        SWAB    R0              ;
        BIC     #177600,R0      ;
        MOV     R0,R3           ;DIAGNOSTIC FUNCTION
        MOV     R2,R5           ;
        BIC     #177774,R5      ;DEXWD #
        ASL     R5              ;MULTIPLY BY 2
        ADD     .DAT3,R5        ;WORD TO TEST
        MOV     R2,R4           ;
        BIC     #177703,R4      ;
        ASR     R4              ;2 + BIT #
        MOV     BMTAB(R4),R4    ;BIT MASK
        BIC     #177677,R2      ;POLARITY FLAG
        DFRD                    ;READ DIAG FN
        CLR     R1              ;CLEAR EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     EVENT3          ;ZERO?
        INC     R1              ;NO,SET EVENT FLAG


;SEQ281

        ;SUBROUTINE TO TEST FOR AN EVENT AFTER HAVING PREVIOUSLY
        ;TESTED FOR THE SAME EVENT USING ENTRY POINT EVENT2.
        ;CALL IS JSR PC,EVENT3.  SETS THE C-BIT IF EVENT IS NOT
        ;DETECTED.  ASSUMES THAT REGISTERS R1-R5 ARE NOT DESTROYED
        ;FROM ONE ENTRY TO ANOTHER.

EVENT3: MOV     CLKTYP,R0       ;GET EBOX OR MBOX CLK FN
        JSR     R5,XSTEP        ;STEP CLOCK ONCE
        MOV     R3,R0           ;READ SAME DIAG FN
        DFRD                    ;
        CLR     R0              ;CLEAR NEXT EVENT FLAG
        BIT     R4,(R5)         ;TEST EVENT
        BEQ     1$              ;ZERO?
        INC     R0              ;SET NEXT EVENT FLAG
        TST     R1              ;NO, CHECK CHANGE
        BNE     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     2$              ;NO
        BR      3$              ;YES, EVENT EDGE DETECTED
1$:     TST     R1              ;CHECK CHANGE
        BEQ     2$              ;NO CHANGE
        TST     R2              ;MATCH?
        BEQ     3$              ;YES, EVENT EDGE DETECTED
2$:     SEC                     ;NO EVENT, SET C-BIT
        MOV     R0,R1           ;SET CURRENT EVENT FLAG
3$:     RTS     PC              ;RETURN

BMTAB:  .WORD   BIT0,BIT1,BIT2,BIT3,BIT4,BIT5,BIT6,BIT7,BIT8
                
        .WORD   BIT9,BIT10,BIT11,BIT12,BIT13,BIT14,BIT15


;SEQ282

.REM    %
        
-----JAB29857 19-FEB-75  SUBROUTINE TO PERFORM THE SAME FUNCTION
        AS "STPCON" WITH THE EXCEPTION THAT, HAVING ONCE
        ESTABLISHED THE BURST COUNT, IT MAKES SURE THAT THE EVENT
        OCCURS AGAIN AT THE END OF THE BURST ON SUBSEQUENT CALLS.
%

SOBAC:  MOV     R5,BRKPC                ;SAV PC FOR FUNC. BRKPT.
SOBAC1: MOV     (R5)+,R0        ;GET BURST CNT
        BLT     1$              ;BR ON NO BURST CNT YET
        DEC     R0              ;BURST FOR 1 CLK LESS THAN CNT
        JSR     R5,BRST1        ;BURST
        MOV     (R5)+,R0        ;FUNCTION TO RO FOR 'EVENT1'
        JSR     R5,EVENT1       ;CLK & TEST FOR OCCURENCE OF EVENT
        RTS     R5              ;RET W/ C-BIT: CLR=FOUND, SET=NOT FOUND
1$:     MOV     (R5)+,R0        ;GET FUNCTION FOR 'FIND'
        JSR     R5,FIND2        ;STEP UNTIL EVENT OCCURS
        BCS     2$              ;IF EVENT DIDNT OCCUR, DONT SAV BRST CNT
        MOV     R0,-4(R5)       ;ELSE SAV BRST CNT FOR FUTURE USE
2$:     RTS     R5              ;RET W/C-BIT SET/CLR AS ABOVE

.REM    %
        
-----A DYNAMIC-DATA CALLER FOR SOBAC.  DOES THE SAME THING, EXCEPT
        THAT IT SHUFFLES DATA PASSED AND RETURNED.  BURST COUNTS ARE
        ASSUMED IN A LIST POINTED TO BY BCLA.  UPDATES COUNT IN LIST
        AND ADDRESS IN BCLA IF SOBAC WAS SUCCESSFUL.
%
SOBACF: MOV     (R5)+,R0        ;ENTRY FOR STATIC FUNC #
DSOBAC: MOV     R5,BRKPC        ;SAV PC FOR FUNC BRK PNT
        MOV     R0,2$           ;MOV FUNC TO PARAM LST
        MOV     @BCLA,1$        ;MOV BURST CNT TO PARAM LIST
        JSR     R5,SOBAC1       ;GO AND DO SOBAC
1$:      000000                 ;BURST CNT TO BE SUPPLIED
2$:      000000                 ;FUNCTION TO BE SUPPLIED
          BCS   3$              ;ON FAILURE, DONT UPDATE ANYTHING
        MOV     BCLA,R0         ;SAV BURST CNT & UPDATED ADR...
        MOV     1$,(R0)+        ;W/0 MODFG C-BIT
        MOV     R0,BCLA
3$:     RTS     R5

BCLA:   .WORD   -1              ;BURST COUNT LIST ADDRESS
                                ;TO BE SUPPLIED BY CALLER


;SEQ283

.SBTTL          AC LOADERS
.REM    %
        ROUTINE TO LOAD PDP10 AC'S AND LIMITED MEMORY SPACE
CALL:
        JSR     R5,LOAD
        ARG1
        ARG2
        ARG3

ARG1:   FIRST PDP10 ADDRESS TO LOAD. ADDRESSES 1-17 ARE INTERPRETED AS
IN THE CURRENT AC BLOCK.

ARG2:  NUMBER OF PDP10 WORDS TO LOAD.  THE VALUE IS NEGATIVE IF
THE WORDS ARE TO COME FROM CONSECUTIVE PDP11 LOCATIONS.
VALUES 0,1, AND -1 ARE TREATED ALIKE.

ARG3:  IF ARG2 IS NEGATIVE THIS WORD POINTS TO THE FIRST BYTE OF
THE FIRST PDP10 WORD IN PDP11 MEMORY.  IF ARG2 IS POSITIVE, THEN
THERE MUST BE ONE ARG3 FOR EACH PDP10 WORD TO BE LOADED. (I.E.,
THE WORDS TO BE LOADED ARE SCATTERED IN DPD11 MEMORY).
%

LOAD:   PUSH    R1

        DFXCTT          ;START THE CLOCK
                STRCLK  ;
        CLR     DEADR+2 ;CLR HIGH ORDER ADDR WORD
        MOV     (R5)+,DEADR     ;GET DESIRED ADDRESS
1$:     MOV     (R5)+,WDCNT     ;GET COUNT OF XFERS
        MOV     (R5)+,R0        ;GET COUNT OF XFERS
       TST      WDCNT
        BNE     2$
        INC     WDCNT           ;TURN 0 INTO 1

2$:     MOV     #DEADR,R1       ;ADDRESS OF ADDRESS
        PUSH    R0              ;SAVE DATA POINTER

        DPOSVR                  ;DO DEPOSIT
        POP     R0

        BCS     6$              ;DEPOSIT ERROR

        TST     WDCNT           ;WHERE'S NEXT DATA?
        BPL     3$              ;SKIP IF SCATTERED
        INC     WDCNT           ;STRAIGHT LINE- UP CNT
        ADD     #5,R0           ;DO NEXT 5 BYTES
        BR      4$              ;CONTINUE


;SEQ284

3$:     DEC     WDCNT   ;SCATTERED- DOWN COUNT
4$:     TST     WDCNT   
        BEQ     7$              ;EXIT IF DONE
        BMI     5$              ;SKIP IF STRAIGHT LINE
        MOV     (R5)+,R0        ;NEW ADDRESS IF NOT
5$:     INC     DEADR           ;BUMP LOW ADR
        ADC     DEADR+2         ;CARRY TO HIGH
        BR      2$              ;DO ANOTHER DEPOSITY

6$:     DEC     WDCNT           ;WILL WE RETURN CORRECTLY?
        BLE     7$              ;O.K. IF 0 OR NEG
        ASL     WDCNT           ;IF SCATTERED MUST PASS OVER POINTERS
        ADD     WDCNT,R5        ;TO GET BACK O.K.
        SEC                     ;SET ERROR FLAG AGAIN
7$:     POP     R1

        RTS     R5              ;DONE - RETURN


DEADR:  .BLKW   2               ;PDP10 ADDRESS HOLDER
WDCNT:  .WORD   0


.REM    %
READ17 - READS & CLEARS AC17.  POINTER TO DATA RETURNED IN R0.
%
READ17: PUSH    R1

        MOV     #HDWEXA,R0       ;
        EXCT                    ;DO A SUB AC17 17
        MOV     #ZERO..,R0      ;POINT TO ZEROS IF ERROR
        BCS     1$              ;ERROR
        MOV     #DPBR,R0        ;READ BR FOR AC17
        MOV     #EXAREA,R1      ;BUFFER ADDRESS
        DFRDMV                  ;PUT AC17 IN BUFFER
        MOV     R1,R0           ;POINTER TO R0
1$:     POP     R1

        
        RTS     R5              ;RETURN


        
HDWEXA: I10     SUB AC17,,17


        .EVEN
EXAREA: WD36    0,0,0


        .EVEN

;SEQ287

.SBTTL          EXECUTE ROUTINES

.REM    %
STEXCT - ROUTINE TO START EXECUTION OF AN INSTRUCTION.  SUPPORTS
MBOX SCANOUTS.  TRAILING PARAMETER IS THE INSTRUCTION POINTER.
%
STEXCT: MOV     (R5)+,R0        ;GET INSTRUCTION POINTER
        LODAR                   ;PUT INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        RTS     R5              ;RETURN

.REM    %
XQT - ROUTINE TO EXECUTE A PDP-10 INSTRUCTION.  OPERATES AT
HIGH SPEED UNLESS A FUNCTION BREAKPOINT IS ACTIVE.  SETS THE
C-BIT IF THE INSTRUCTION DOES NOT RETURN TO THE HALT LOOP.
%
XQT:    MOV     R5,BRKPC        ;SAVE PC
        
XQT1:   TST     FNBRK           ;FUNCTION BREAKPOINT?
        BNE     XQT2            ;YES
        EXCT                    ;NO, DO CONSOLE EXECUTE
        BCC     1$              ;ERROR?
        MOV     BASE20,R0       ;YES, GET DTE20 BASE ADDRESS
        JSR     R5,CLKERC       ;CHECK FOR CLK ERR STOP
1$:     RTS     R5              ;RETURN

XQT2:   JSR     R5,SAV.3        ;SAVE R3-R5
        LODAR                   ;GET INST IN AR
        DFXCTT                  ;PRESS CONTINUE
                CONBUT          ;
        MOV     #20,R3          ;MAX COUNT TO LEAVE HALT LOOP
        MOV     #5000.,R4       ;MAX COUNT TO ENTER HALT LOOP
        MOV     BASE20,R5       ;GET DTE20 BASE
1$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)       
        BEQ     2$              ;LEFT HALT LOOP
        DEC     R3              ;DIDNT
        BGT     1$              ;TRY AGAIN
        BR      3$              ;ERROR
2$:     JSR     R5,STEP1        ;STEP THE CLOCK
        BIT     #HALTLP,DIAG1(R5)
        BNE     4$              ;BACK TO HALT LOOP
        DEC     R4              ;NOT THERE YET
        BGT     2$              ;LOOP AGAIN
3$:     SEC                     ;SET C-BIT
4$:     JSR     R5,RST.3        ;RESTORE R3-R5
        RTS     R5              ;




;SEQ507

.SBTTL          MEM REF SUBROUTINE
.REM    %
        
GETMEM - ROUTINE TO SAVE THE STATUS OF A MEMORY REFERENCE.  PUTS
RQ0, RQ1, RQ2, RQ3, RD & WR RQS & THE SBUS ADR IN TABLE MEMTAB:
%
GETMEM: PUSH    R1
        DFRDT                   ;READ REQUESTS
                166             ;
        MOV     @.DAT3,R1       ;
        BIC     #177417,R1      ;CLEAR GARBAGE
        TBIT    27              ;RD?
        BEQ     1$              ;NO
        BIS     #10,R1          ;YES
1$:     TBIT    33              ;WR?
        BNE     2$              ;NO
        BIS     #4,R1           ;YES
2$:     MOVB    R1,MEMTAB               ;PUT RQS IN FIRST BYTE
        DFRDT                   ;GET EBUS REG (PMA)
                167             ;
        MOV     .DAT3,R0        ;
        MOV     #MEMTAB+1,R1    ;
        MOVB    (R0)+,(R1)+     ;PUT IN NEXT 3 BYTES
        MOVB    (R0)+,(R1)+     ;
        MOVB    (R0),(R1)       ;
        BICB    #300,(R1)       ;CLEAR GARBAGE
        MOV     #MEMTAB+1,R1    ;
        BICB    #3,(R1)         ;CLEAR OUT PMA 34 & 35
        TENBIT  173,35          ;TEST SBUS ADR 34
        BEQ     3$              ;CLEAR
        BISB    #2,(R1)         ;SET
3$:     TENBIT  174,35          ;TEST SBUS ADR 35
        BEQ     4$              ;CLEAR
        INCB    (R1)            ;SET
4$:     MOV     #MEMTAB,R0              ;TABLE POINTER TO R0
        MOV     R0,MEMRQ        ;SET FLAG
        POP     R1
        RTS     R5              ;RETURN
MEMTAB: .WORD   0,0             ;MEM RQ STATUS
MEMRQ:  .WORD   0               ;MEM STATUS FLAG


;SEQ508

.SBTTL          SBUS DIAG SUBROUTINES
.REM    %
SBUSDG - THIS SUBROUTINE SETS UP AN SBUS DIAG OPERAND IN AC16 BY
INSERTING THE CONTROLLER ADDRESS IN THE 36-BIT WORD POINTED TO
BY R0, AN SBUS DIAG IS INITIATED & THE RESULT IS TRANSFERRED
TO THE DTE20.
%

SBUSDG: MOV     R5,BRKPC                ;SAVE PC
SBVUSD1:        PUSH    R1

        MOVB    TSTCON,R1               ;GET CONTROLLER ADR
        ROR     R1              ;0-3 TO R1
        MOVB    R1,4(R0)        ;TO SBUS OPERAND
        BICB    #BIT07,3(R0)    ;CLEAR CONTROLLER ADR 4
        BCC     SBUSD3          ;SET IT?
        BISB    #BIT07,3(R0)    ;YES
        BR      SBUSD3          ;
SBUSD2: MOV     R5,BRKPC        ;SAVE PC
        PUSH    R1              ;
SBUSD3: PUSH    R0
        DFXCTT          ;START THE CLOCK
                STRCLK          ;
        POP     R0              ;
        MOV     #ADAC16,R1              ;ADDRESS TO LOAD
        DPOS            ;DO DEPOSIT
        BCS     1$              ;ERROR
        MOV     #SBUSD,R0       ;DO SBUS DIAG
        JSR     R5,XQT1         ;
        BCS     1$              ;ERROR
        JSR     R5,READ17               ;GET AC178
1$:     POP             R1              ;RESTORE R1
        RTS     R5              ;RETURN
    
ADAC16: .WORD   16,0            ;
TSTCON: .WORD   0               ;TEST CONTROLLER
SBUSD:  IO10    BLKO PI,,16     ;

        .EVEN


.SBTTL          MEMORY CONFIGURATION SAVE & RESTORE
;FIND A MEMORY THAT RESPONDS AND SAVE ITS BASE ADDRESS.  IF 
;NO MEMORY IS FOUND WITH FOUR CONSECUTIVE REFERENCES WITHIN THE
;FIRST 256K THEN AN ERROR RETURN IS GIVEN.

;SEQ297

.REM    %
        SAVMCN SAVES THE EXISTING MEMORY CONFIGURATION.  THE CONFIGURATION IS
ASSUMED TO BE VALID.  FOR MF20S, ONLY A MAP OF CONFIGURED, USABLE CONTROLLERS
IS KEPT.  THIS MEANS THAT IF POWER IS SHUT OFF THE CONFIGURATION IS DESTROYED.
A C-BIT SET RETURN IS DONE ONLY IS 2 MF20S RESPOND TO ADDRESS 0.  
A VARIABLE (TCWRTO) IS SET TO THE NUMBER OF THE CONTROLLER RESPONDING
TO ADDRESS C (DMA20 IS ASSUMBED IF NO MA20/MB20/MF20 HAS THAT ADDRESS).
        %

NUMCON=5                ;CURRENT MAXIMUM NUMBER OF CORE MEMORY CONTROLLERS

SAVMCN: PUSH    R1              ;SAV REG


;-----HERE TO RECORD STATE OF MA20,MB20/DMA20 MEMORY.

        LOAD    1,GTMCNF,13     ;LOAD AC PRGM (AC1-13)
        MOV     #CONTAB,R1      ;PTR TO CONF TABLE SAVES TIME & SPACE
        RUN     1
        BCS     2$              ;AC ROUTINE HUNG
1$:     READ17                  ;GET FUNCTION 0 RESULT
        MOVB    3(R0),(R1)+     ;INTERLEAVE BITS TO TABLE
        CONTIN                  ;DO FUNCTION 1
        BCS     2$              ;AC ROUTINE HUNG
        READ17                  ;GET FUNCTION 1 RESULT
        MOVB    (R0)+,(R1)+     ;REQUEST ENABLE BITS TO TABLE
        BIC     #170317,-2(R1)  ;CLR JUNK FROM INT & R0 EN BITS
        MOVB    (R0)+,(R1)+     ;MOV ADR BOUNDS STUFF
        MOVB    (R0)+,(R1)+     ;DITTO
         
        BIC     #140003,-2(R1)  ;CLR JUNK BITS FROM ADR BOUNDS
        CONTIN                  ;NEXT FUNCTION 0
        BCC     3$
2$:     ERRORA  ERRP            ;AC ROUTINE HUNG?
3$:     CMP     R1,#CONTAB+<4*NUMCON>   ;DONE WITH ALL CONTRS YET?
        BLO     1$              ;NO...KEEP GOING


;SEQ298

;-----THIS CODE GOES AND GETS MF20 INFO: USABLE MF20 & DESELECTED-AT-0 MAPS.

        LOAD    0,GMFUMP,20     ;LD AC 0-17
        RUN     0               ;RUN THE AC PRGM
        BCS     2$              ;BR ON ERR
        READ17                  ;GET RESULT DATA
        MOV     (R0)+,R1        ;USABLE MF20 MAP TO R1 (BIT0=MF20 #10, ETC)
        MOV     (R0),R0         ;GET DESELECTED-AT-0 MAP INTO R0        
        MOV     R1,UMFMAP       ;SAV USABLE MF20 MAP

;-----FIND OUT WHICH MF20,IF ANY, RESPONDS TO ADDRESS 0.

        COM     R1              ;CALC UNUSABLE MF20 MAP
        BIS     R1,R0           ;CALC UNUSABLE .OR. DESEL-AT-O MAP
        COM     R0              ;CALC USABLE .AND. SEL-AT-0 MAP
        BEQ     5$              ;NO MF20 RESPONDS AT 0.. GO TRY FOR MA20/MB20
        MOV     #7,R1           ;INI MF20 # FOR SEARCH THRU MAP IN R0
4$:     INC     R1              ;NXT MF20
        CLC     
        ROR     R0              ;IS THIS MF20 USABLE & SELECTED-AT-0?
        BCC     4$              ;NO.. TRY NXT
        BNE     10$             ;YES BUT THERE IS ANOTHER TOO.. ERROR! C SET RET
        BR      9$              ;OK, JUST 1 MF RESPONDS TO 0.. GO SAV ITS #

;----HERE TO FIND OUT WHICH MA20/MB20, IF ANY, RESPONDS TO ADDRESS 0.  IF NONE
;DOES THEN WE ASSUME THAT THE DMA20 IS RESPONDING TO 0.

5$:     CLR     R1              ;INI TABLE SRCH NDX
6$:     BIT     #37700,CONTAB+2(R1)     ;IS CONTR LO ADR BOUND AT 0?
        BNE     7$              ;NO.  TRY NEXT MA/MB
        BIT     #4000,CONTAB(R1)        ;DOES CONTR RESP TO RQ 0?
        BEQ     7$              ;NO. TRY NXT MA/MB
        TSTB    CONTAB(R1)      ;IS CONTR TURNED ON (IE INTRL NOT 0)?
        BNE     8$              ;YES.  THIS IS THE ONE, GO RECORD ITS #
7$:     ADD     #4,R1           ;ELSE LOOK AT NXT MA20/MB20
        CMP     R1,#12.         ;TRIED THEM ALL?
        BLE     6$              ;NO, LOOP.  IF YES, JUST ASSUME DMA20.
8$:     ASR     R1              ;DIVIDE NDX BY 4 TO GET CONTR #
        ASR     R1              

;-----HERE TO SET THE CONTROLLER NUMBER WHICH RESPONDS TO 0 AND EXIT.

9$:     MOV     R1,TCWRT0       ;SAV # OF THE CONTROLLER WHICH RESPONDS TO 0
        CLC                     ;IND NO ERROR
10$:    POP     R1              ;GET BACK REG SAVED EARLIER

        RTS     R5              ;RETURN TO CALLER


;SEQ299

;-----THE CORE MEMORY CONFIGURATION TABLE. 2 BYTES AND A WORD PER CONTROLLER.
CONTAB: .REPT   NUMCON
        .BYTE   000             ;THE INTERLEAVE BITS (00II0000)
        .BYTE   000             ;THE WORD REQUEST ENABLE BITS (0000RRRR)
        .WORD   000000          ;THE ADR BOUNDS BITS (00SSSSLLLLUUUU00)
        .ENDM

TCWRT0: .WORD   0               ;NUMBER OF THE CONTR WHICH RESPONDS TO 0.  IF NO
                                ;MA20/MB20/MF20 IS AT 0, THEN WE ASSUME DMA20.


;SEQ300

;-----AC PROGRAM TO READ SBUS DIAGS FROM DIFFERENT CORE MEMORY CONTROLLERS
;SO THAT THE EXISTING CONFIGURATION CAN BE DETERMINED.

GTMCNF: I10     SETZM,0,,16     ;1--


        I10     IOR,16,,12      ;2--


        IO10    SBDIAG,,,16     ;3--


        I10     JRST,4,,5       ;4--
   
        I10     AOS,0,,16       ;5--


        IO10    SBDIAG,,,16     ;6--


        I10     JRST,4,,10      ;7--


        I10     ADD,12,,13      ;10-


        I10     JRST,0,,1       ;11-


        WD36    0100,0000,0000  ;12-


        WD36    0200,0000,0000  ;13-


;-----THIS AC PROGRAM CREATES 2 MAPS:  ONE WHICH SAYS WHICH MF20S ARE USABLE,
;AND ANOTHER SAYING WHICH MF20S ARE DESELECTED AT ADDRESS 0.  THE BITS IN THE
;MAPS CORRESPOND POSITIONALLY.  IF THE MF20 IS NOT USABLE THEN THE DESELECTED
;BIT IS MEANINGLESS.  THE PROGRAM IS HARDCODED TO LOOK AT CONTROLLERS 10-17.
;THE TWO MAPS ARE BUILT IN AC17.  THE "USABLE" MAP IS IN BITS 28-35, BIT 35
;IS FOR MF20 #10.  34 IS FOR #11, ETC.  THE OTHER MAP IS IN  BITS 12-19.  THESE
;BIT POSITIONS ARE USED TO ERASE WORK DONE BY THE DPD-11.  A USABLE CONTROLLER
;IS (1) AN MF20, (2) IN SOFTRWARE STATE 2 OR 3, AND (3) IS NOT DISABLED.

GMFUMP: I10     LSH,17,,1               ;0-<START> SHIFT CTL/OUTPUT WD PRIOR TO NXT MF20


        IO10    SBDIAG,,,15             ;1-DO FCN 1 TO GET MF20 STATUS


        I10     LSH,16,,777767          ;2-GET STATUS INFO INTO RHE OF AC16


;SEQ301

        I10     CAIN,16,,500001 ;3-SKIP IF -USABLE (-MF20,-SS 2/3, OR DISABLED)


        I10     IORI,17,,1      ;4-ELSE MARK CONTR AS USABLE
        

        I10     HRRI,15,,12     ;5-TURN FCN 1 INTO FCN 12 FOR ADRESP RAM RD


        IO10    SBDIAG,,,15     ;6-RD ADRESP RAM WD 0

        I10     TLNE,16,,10     ;7 - SKIP IF DESFL BIT IS 0

        I10     IORI,17,,2000000        ;10-ELSE SET DESEL BIT IN MAP TOO


        I10     SUB,15,,14      ;11-TURN FCN 12 INTO FCN 1, NXT CONTR #


        I10     JUMPL,17,,0     ;12-LP TIL ALL MF20S DONE (AC17 BIT 00 = 0)


        I10     JRST,4,,0       ;13-HALT WHEN DONE


        WD36    0200,0000,0011  ;14-SUB FROM SBDIAG WD TO GET FCN 1, NXT MF


        WD36    3600,0000,0001  ;15-FCN 1 SBDIAG FOR HIGHEST MF20.. MODIFIED


        WD36    0000,0000,0000  ;16-FCN 1 & 12 RESULT GOES HERE


        WD36    7760,0000,0000  ;17-LHF IS CONTROL # OF LPS.  MAPS BUILT HERE


        .EVEN


;SEQ303

.REM    %
        RSTMCN RESTORES THE MEMORY CONFIGURATION SVED BY SAVMCN.  ONLY DOES A
C-BIT SET RETURN IF MF20 CONFIGURATION WAS BLOWN BY POWER OFF AND WE DO NOT HAVE
A CORE MEMORY AT ADDRESS 0.
        %

RSTMCN: PUSH    <R3,R4,R5>      ;SAVE REGS


        
        LOAD    1,7$,3          ;LOAD THE AC PROGRAM (AC1-3)
        CLR     R5              ;INIT CONTROLLER NUMBER
        MOV     #CONTAB,R3      ;CONF TABLE PTR INIT
;-----SBUS DIAG FUNCTION 0 SETUP
1$:     MOV     #CNFWD0+3,R4    ;DIAG WD PTR SAVES TIME & SPACE
        MOVB    (R3)+,(R4)      ;INTERLEAVE BITS TO WORD
        BISB    (R3)+,(R4)      ;WD RQ BITS TO WORD
        PUSH    R5              ;SCRATCH CONTR # ON STACK

        ROR     (SP)            ;SPLIT CONTR # 4-1
        BCC     2$              ;BR IF EVEN CONTR
        BISB    #200,(R4)       ;ELSE SET ODD CONTR BIT IN WD
2$:     BISB    #100,(R4)+      ;SET CLR 0-5 BIT IN WD
        MOVB    (SP)+,(R4)      ;HI ORD 4 BITS OF CONTR # TO WD


;SEQ304

;-----SBUS DIAG FUNCTION 1 WORD SETUP
        TST     (R4)+           ;SKIP DIAG WD STUFF TO LEAVE ALONE
        MOV     (R3)+,(R4)      ;MOV ADR BOUNDS BITS TO WD
        BIS     #2,(R4)+        ;SET LOAD BOUNDS BIT IN WD
        MOV     R5,(R4)         ;CONTR # TO WORD
        SWAB    (R4)            ;POSIITON IT PROPERLY
        ASR     (R4)
;-----LOAD SBUS DIAG WORDS AND RUN PROGRAM
        DPOST,4,CNFWD0          ;AC4
        DPOST,6,CNFWD1          ;AC6
        RUN     1
        BCC     4$              
3$:     ERRORA  ERRP            ;AC PROGRAM DIDN'T HALT
;-----SELECT NEXT CORE MEMORY CONTROLLER OR GO ON TO MF20S.
4$:     INC     R5              ;BUMP CONTR #
        CMP     R5,#NUMCON      ;DONE YET?
        BLT     1$              ;NO...CONTINUE

;-----THIS SECTION REENABLES ANY MF20S WHICH EXISTED AND WERE USABLE WHEN
;SAVMCN WAS CALLED.

        LOAD    1,RSTMFP,16     ;LOAD THE AC PROGRAM
        RUN     1               ;RUN IT
        BCS     3$              ;BR ON ERROR
        DFPC                    ;GET THE HALTED PC
        TST     (R0)            ;PC 0 OR NOT 0?
        BEQ     5$              ;0.. NORMAL COMPLETION
        CMP     TCWRT0,#4       ;IS THE CONTR WHICH RESPONDS TO 0 A CORE MEM?
        BLE     5$              ;YES..WE STILL HAVE MEM AT 0
        SEC                     ;MF20S POWERED OFF.. CONFIG BLOWN
        BR      6$              ;EXIT WITH C-BIT SET
5$:     CLC
6$:     POP     <R5,R4,R3>      ;RESTORE REGS


        RTS     R5


;SEQ305

;-----AC PROGRAM TO DO SBDIAGS TO SET CORE MEM CONF.
        .ODD            ;FORCE EVEN ALLIGNMENT FOR CNFWD0
7$:     IO10    SBDIAG,,,4      ;1--DO SBUS DIAG FUNC 0


        IO10    SBDIAG,,,6      ;2--DO SBUS DIAG FUNC 1


        I10     JRST,4,,1       ;3--HALT


CNFWD0: WD36    0100,4000,0000  ;4--SBUS DIAG FUNCTION 0 WORD


                                ;5--
CNFWD1: WD36    0000,0000,1001  ;6--SBUS DIAG FUNCTION 1 WORD


                                ;7--

;-----THIS AC PROGRAM SCANS THRU THE MF20S AND REENABLES THOSE MF20S WHICH WERE
;ON AT THE TIME SAVMCN WAS CALLED.  SINCE IT TAKES SO MUCH DATA TO BRING UP AN
;MF20 AFTER POWER ON WE PUNT IF AN MF20 WHICH WAS ON IS NO LONGER ON, IE IT WAS
;POWERED OFF FOR SOME REASON.  THE MAP UMFMAP IS CREATED AND SVAED HERE BY
;SAVMCN.  AN MF20 WAS USABLE IF A MAP BIT IS SET.  BIT35=MF20#10.  34=#11, ETC.

        .EVEN                   ;FORCE UMFMAP TO EVEN BOUNDARY
                                ;0 - NOT USED
RSTMFP: IO10    SBDIAG,,,16     ;1-<START>DO FCN 1 TO GET STATE OF MF20


        I10     HRRI,16,,1201   ;2-CNG FCN 1 TO LD SS 2, NOT DISABLE


        I10     TRNN,15,,1      ;3-WAS THIS MF20 USABLE WHEN SAVMCN WAS RUN?


        I10     JRST,,,10       ;4--HERE IF NO.  DONT SET SS 2.


        I10     TRNN,17,,1000    ;5-SKIP IF MF20 AT SS 2 (IE NOT POWERED OFF)


        I10     JRST,4,,7       ;6-ELSE HALT.  MEM CONFIG BLOWN BY POWER OFF


        IO10    SBDIAG,,,16     ;7-ALL OK.  SET SS2, NOT DISABLED


        I10     ADD,16,,14      ;10-CNG SBDIAG WD BAK TO FCN 1 RD, NXT MF20


        I10     LSH,15,,777777   ;11-LOOK AT NXT CTL BIT


;SEQ306

        I10     JUMPN,15,,1     ;12-LOOP IF MORE MF20S TO DO


        I10     JRST,4,,0       ;13-ELSE HALT.. ALL DONE OK


        WD36    0177,7777,6600  ;14-CHANGES FCN 1 SET -DIS/SS2 TO FCN 1 RD, NXT


UMFMAP: WD36    0000,0000,0000  ;15-MAP OF USABLE MF20S (BIT35=10,BIT34=11,ETC)


        WD36    2000,0000,0001  ;16-FCN 1 RD SBDIAG WD, MF20 #10 FIRST


                                ;17-ECHO FROM FCN 1

        .EVEN


;SEQ518

        .SBTTL CHANNEL UTILITY SUBROUTINES  11-DEC-75

.REM    %
        ROUTINE TO CONDITION THE EPT FOR A CHANNEL.  CHANNEL IN
R0; DATA POINTER IN R1.  CLEARS STATUS WORD 1.
%
SETEPT: MOV     R5,BRKPC                ;SAVE PC FOR FN. BREAK
        SL      R0,2            ;CHANNEL * 4
        MOVB    R0,EBRADR       ;TO ADDRESS LOWER
        MOV     EBRFLG,R0               ;GET EPT BASE PAGE
        ASL     R0              ;POSITION AT 1K BOUNDARY
        MOV     R0,EBRADR+1     ;PUT IN ADDRESS
        DFXCTT                  ;START THE CLOCK
                STRCLK          ;
        MOV     R1,R0           ;DATA POINTER
        MOV     #EBRADR,R1      ;ADDRESS
        DPOSVR                  ;DEPOSIT & VERIFY
        BCS     1$              ;ERROR
        INCB    EBRADR          ;EPT +1
        MOV     #ZERO..,R0      ;
        DPOS                    ;CLEAR IT
        TSTB    CSHCLR          ;EBR SET?
        BEQ     SETEBR          ;NO, SET IT
1$:     RTS     R5              ;RETURN
.REM    %
        SUBROUTINE TO SET THE EBR TO THE VALUE IN EBRFLG.
ALSO SETS CACHE LOOK & LOAD IF CSHFLG SET.
%
SETEBR: MOV     EBRFLG,CSHCLR   ;NO, SET EBR DEFAULT
        MOV     EBRFLG,CSHALW   ;
        TST     CSHFLG          ;CACHE ENABLED?
        BEQ     1$              ;NO, JUST SET ERR
        XQT     CSHALW          ;YRS, ALSO SET LOOK & LOAD
        BR      2$              ;
1$:     XQT     CSHCLR          ;SET EBR TO DEFAULT
2$:     RTS     R5              ;RETURN
CSHCLR: IO10    CONO PAG,,0     ;MUST BE EVEN ADDRESS
EBRADR: WD22    0               ;MUST BE ODD ADDRESS
EBRFLG: .WORD   0               ;MUST BE EVEN ADDRESS


;SEQ519

.REM    %
        ROUTINE TO READ THE CCW ADR.  RETURNS A POINTER TO THE
22-BIT VALUE IN R0.
%
CCWRD:  PUSH    R1
        CLR     ADRL            ;CLEAR ADDRESS BUFFER
        CLR     ADRH            ;
        MOV     #173,R1         ;FIRST DIAG FUNCTION
        JSR     PC,CCWCHA       ;GET BITS 30-35
        SWAB    R0              ;POSITION
        ASR     R0              ;
        BIC     #177700,R0      ;CLEAR GARBAGE
        BIS     R0,ADRL         ;PUT IN ADDRESS BUFFER
        JSR     PC,CCWCHA       ;GET BITS 24-39
        SR      R0,3            ;POSITION
        BIC     #170077,R0      ;CLEAR GARBAGE
        BIS     R0,ADRL         ;PUT IN ADDRESS BUFFER
        JSR     PC,CCWCHA               ;GET BITS 18-23
        ASL     R0              ;POSITION
        ROL     R0              ;UPPER 2 TO ADRH
        ROL     ADRH            ;
        ROL     R0              ;
        ROL     ADRH            ;
        BIC     #7777,R0        ;CLEAR GARBAGE
        BIS     R0,ADRL         ;REST TO ADRL
        JSR     PC,CCWCHA       ;GET BITS 14-17
        SWAB    R0              ;POSITION
        ASL     R0              ;
        BIC     #177703,R0      ;CLEAR GARBAGE
        BIS     R0,ADRH         ;PUT IN BUFFER
        MOV     #ADRL,R0                ;POINT TO BUFFER
        POP     R1
        RTS     R5              ;RETURN
CCWCHA: MOV     R1,R0           ;GET CURRENT DIAG FN.
        DFRD                    ;DO DIAG READ
        MOV     @.DAT2,R0               ;GET RESULT
        INC     R1              ;NEXT FUNCTION
        RTS     PC              ;5-19 IN R0


;SEQ520

.REM    %
        ROUTINE TO PERFORM A CBUS SELECT.  CHECKS FOR CBUS SEL
XE & STEPS THE CLOCK UNTIL IT BECOMES TRUE.  R0 EQUALS THE
CHANNEL NUMBER.  SETS THE C-BIT IF TIMEOUT.
%
CHSEL:  PUSH    <R1,R2>
        BIC     #177770,R0      ;ONLY LEGAL CHANNELS
        ADD     #170,R0         ;MAKE INTO DIAG READ FN.
        MOV     R0,R1           ;SAVE FUNCTION
        DFXCTT                  ;STOP THE CLOCK
                STPCLK          ;
        MOV     #48.,R2         ;MAX CLOCK COUNT
1$:     DFRDT           ;READ FUNCTION 170
                170             ;
        TBIT    11              ;TEST CH T0
        BEQ     2$              ;NOT SET
        MOV     R1,R0           ;
        DFRD                    ;READ PROPER FUNCTION
        TBIT    12              ;TEST CBUS SEL XE
        BNE     3$              ;MATCH?
2$:     JSR     R5,MEMTST       ;NO, STEP CLOCK
        DEC     R2              ;TIMEOUT?
        BGT     1$              ;NO, TRY AGAIN
        SEC                     ;SET C-BIT
3$:     POP     <R2,R1>
        RTS     R5              ;RETURN


;SEQ521

.REM    %
        ROUTINE TO GET TO POINT IN CHANNEL TIMING WHERE C-BUS
REQUESTS SHOULD APPEAR.  THIS IS 12 TICKS AFTER THE C-BUS SEL.
(D TIME).  R0 EQUALSA THE CHANNEL NUMBER.  SETS THE C-BIT IF
TIMEOUT.
%
CHSELD:         BIC     #177770,R0      ;ONLY LEGAL CHANNELS
        ASL     R0              ;CHANNEL * 2
        JMP     DSELCT(R0)      ;DISPATCH
DSELCT: BR      CH0D
        BR      CH1D
        BR      CH2D
        BR      CH3D
        BR      CH4D
        BR      CH5D
        BR      CH6D
        BR      CH7D
CH0D:   MOV     #3,R0           ;CBUS SEL = 3
        JMP     CHSEL           ;
CH1D:   JSR     R5,TST8A                ;4,5 THIS SCAN?
        BNE     1$              ;NO, 6,7
        MOV     #4,R0           ;CBUS SEL = 4
        JMP     CHSEL           ;
1$:     MOV     #6,R0           ;CBUS SEL = 6
        JMP     CHSEL           ;
CH2D:   JSR     R5,TST8A        ;4,5 THIS SCAN?
        BNE     1$              ;NO, 6,7
        MOV     #5,R0           ;CBUS SEL = 5
        JMP     CHSEL           ;
1$:     MOV     #7,R0           ;
        JMP     CHSEL           ;
CH3D:   CLR     R0              ;CBUS SEL = 0
        JMP     CHSEL           ;
CH4D:   MOV     #1,R0           ;CBUS SEL = 1
        BR      CH4.5D  ;
CH5D:   MOV     #2,R0           ;CBUS SEL = 2
CH4.5D: JSR     R5,CHSEL                ;SELECT IT
        BCS     1$              ;EXIT IF TIMEOUT
        JSR     R5,TST8A        ;4,5 LAST SCAN?
        BNE     1$              ;YES
        JSR     R5,SCAN1        ;NO, DO 1 SCAN
1$:     RTS     R5              ;RETURN
CH6D:   MOV     #1,R0           ;CBUS SEL = 1
        BR      CH6.7D          ;
CH7D:   MOV     #2,R0           ;CBUS SEL = 2
CH6.7D: JSR     R5,CHSEL                ;SELECT IT
        BCS     1$              ;EXIT IF TIMEOUT
        JSR     R5,TST8A                ;6,7 LAST SCAN?
        BEQ     1$              ;YES
        JSR     R5,SCAN1        ;NO, DO 1 SCAN
1$:     RTS     R5              ;RETURN

TST8A:  DFRDT           ;TEST CCW SEL 8A


;SEQ522

                175             ;
        TBIT    13              ;
        RTS     R5              ;RETURN WITH COND

.REM    %
        ROUTINE TO GENERATE A CBUS COMMAND.  ACCEPTS THE
COMMAND WORD IN T1 & GENERATES IT FOR 4 CLOCKS.  FAST MODE
MAY ALSO BE SET OR CLEARED.
%
CSIM:   PUSH    <R2,R1>
        MOV     #LDCHAN,R0      ;DO FUNCTION
        DFWRT                   ;
        MOV     #4,R2           ;STEP CLOCK 4 TIMES
        TST     TRCMEM          ;SELECT PRINT MEMORY?
        BNE     1$              ;YES
        MOV     R2,R0           ;NO, BURST CLOCK
        JSR     R5,BRST1                ;NO, BURST CLOCK
        BR      2$              ;
1$:     JSR     R5,MEMTST       ;
        DEC     R2              
        BGT     1$
2$:     MOV     #MODES+2,R1     ;FAST MODE BUFFER AREA
        MOV     (SP),R0         ;GET FUNCTION DONE
        MOVB    2(R0),(R1)      ;FAST TO BUFFER
        BIC     #177677,(R1)    ;CLEAR EXTRA BITS
        DFWRTT          ;CLEAR ALL EXCEPT FAST
                MODES           ;
                LDCHAN          ;
        POP     <R1,R2>
        RTS     R5              ;RETURN

MODES:  .WORD   0,0,0           ;BUFFER AREA


;SEQ523

.REM    %
        GENERATES A SLOW RQ FOR THE CHANNEL IN R0.
%
SLOWRQ: JSR     R5,CHSEL                ;GET TO CBUS SELECT
        BCS     3$              ;TIMEOUT
        PUSH    <R1,R2>

        MOV     #8.,R2          ;STEP CLOCK 8 TIMES
        TST     TRCMEM          ;SELECT PRINT MEMORY?
        BNE     1$              ;YES
        MOV     R2,R0           ;NO, BURST CLOCK
        BURST
        BR      2$              ;
1$:     JSR     R5,MEMTST               ;
        DEC     R2              ;
        BGT     1$              ;
2$:     MOV     #SLOW,R1                ;SLOW BIT POINTER
        JSR     R5,CSIM ;SIMULATE COMMAND
        POP     <R2,R1>
        CLC                     ;
3$:     RTS     R5              ;RETURN
SLOW:   WD36    0000,4000,0000
.EVEN


;SEQ524

.REM   %
        ROUTINE TO SIMULATE A REQUEST FOR CHANNEL R0.  THE EBUS
DATA IS POINTED TO BY R1.  SETS THE C-BIT IF THE CORRECT CHANNEL
CANNOT BE SELECTED.  RETURNS THE POINTER TO MEMORY REQUEST DATA
IN R0 IF A MEMORY CYCLE WAS INITIATED.
%
SIMBUS: MOV     R5,BRKPC                ;SAVE PC
        PUSH    R2
        MOV    R0,R2           ;
        DFXCTT                  ;STOP THE CLOCK
                STPCLK          ;
        MOV     R2,R0           ;
        CLR     MEMRQ           ;CLEAR MEM RQ FLAG
        CLR     R2              ;CLEAR SLOW RQ FLAG
        BITB    #BIT7,2(R1)
        BEQ     1$              ;NO
        PUSH    R0

        JSR     R5,SLOWRQ               ;GENERATE IT
        POP     R0

        BCS     3$              ;TIMEOUT
        TSTB    3(R1)           ;ANY OTHER REQUESTS?
        BEQ     2$              ;NO
        INC     R2              ;YES, SET FLAG
        BICB    #BIT7,2(R1)     ;CLEAR SLOW RQ BIT
1$:     JSR     R5,CHSELD       ;GET TO D-TIME
        BCS     2$              ;TIMEOUT
        JSR     R5,CSIM         ;SIMULATE REQUEST
        TST     R2              ;SLOW REQUEST?
        BEQ     2$              ;NO
        BISB    #BIT7,2(R1)     ;YES, RESTORE IT
2$:     MOV     MEMRQ,R0                ;GET MEM STATUS
3$:     POP     R2
        RTS     R5              ;RETURN


;SEQ525

        ;STEPS THE CLOCK.  TESTS FOR LEADING EDGE OF RQ HOLD
        ;IF TRCMEM SET.  GETS MEM STATUS IF EVENT DETECTED.

MEMTST: TST     TRCMEM          ;SELECT PRINT MEMORY?
        BNE     TSTMEM          ;YES, TRACE
        JSR     R5,STEP1                ;STEP THE CLOCK
        RTS     R5              ;RETURN
TSTMEM: MOV     RQHOLD,R0       ;TEST FOR SBUS ADR HOLD
        JSR     R5,EVENT1       ;
        BCS     1$              ;NO MEM REF
        JMP     GETMEM          ;GET MEM STATUS
1$:     CLR     R0              ;
        RTS     R5              ;RETURN

        ;EITHER BURSTS THE CLOCK 24 TIMES OR SINGLE STEPS THE
        ;CLOCK 24 TIMES WHILE TESTING FOR A MEMORY REFERENCE.
SCAN1:  TST     TRCMEM          ;ASELECT PRINT MEMORY?
        BEQ     2$              ;NO, DONT TRACE
        PUSH    R2              
        MOV     #24.,R2         ;CLOCK COUNT
1$:     JSR     R5,TSTMEM               ;CHECK FOR MEM REF
        DEC     R2              ;
        BGT     1$              ;DONE?
        POP     R2              ;YES
        BR      3$              ;
2$:     MOV     #24.,R0 ;BURST CLOCK 24
        JSR     R5,BRST1        ;
3$:     RTS     R5              ;RETURN

TRCMEM: .WORD   0               ;MEMORY TRACE FLAG
RQHOLD: S10.    162,31,1                ;SBUS ADR HOLD



.SBTTL  *STOR11* DECSYSTEM10 PDP11 PROGRAM STORAGE SECTION

;ASSIGN LITERAL AREA

$$FF:   $$CLIT  ;FIRST FREE

$$LITT=.        ;START OF LITERAL AREA

.END    START
    |SM/