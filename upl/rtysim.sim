! RTYSIM.SIM - 06/17/75
GLOBAL  %RTYSIM
%RTYSIM ( RTYPE, PCODE )

FIND    %RTY.UUO, %RTY.DAT, %RTY.TRU, %RTY.JOB, %RTY.NODE, %RTY.CR
FIND    %RTY.PPN, %RTY.FPN, %RTY.LIC, %RTY.MTH, RTY.CNM(0)
FIND    %RTY.INT, %RTY.LKP, %RTY.ENT, %RTY.SIO, %RTY.INP, %RTY.OUT
FIND    %RTY.USI, %RTY.USO, %RTY.RLS, JOBJDA(0), %RTY.MSG, RTY.DYN(0)
FIND    %RTY.DSK
GLOBAL  %RTY.ERR

DEF VERSION     AS      2.00
DEF INIT.TRU    AS      INIT(1)
DEF INIT.NODE   AS      INIT(2)
DEF INIT.PORT   AS      INIT(3)
DEF INIT.JOB    AS      INIT(4)
DEF INIT.DATE   AS      INIT(5)
DEF INIT.TIME   AS      INIT(6)
DEF INIT.PPN    AS      INIT(7)
DEF INIT.FPN    AS      INIT(8)
DEF INIT.YEAR   AS      INIT(9)
DEF INIT.MONTH  AS      INIT(10)
DEF INIT.DAY    AS      INIT(11)
DEF CURR.TRU    AS      CURR(1)
DEF CURR.NODE   AS      CURR(2)
DEF CURR.PORT   AS      CURR(3)
DEF CURR.JOB    AS      CURR(4)
DEF CURR.DATE   AS      CURR(5)
DEF CURR.TIME   AS      CURR(6)
DEF CURR.PPN    AS      CURR(7)
DEF CURR.FPN    AS      CURR(8)
DEF CURR.YEAR   AS      CURR(9)
DEF CURR.MONTH  AS      CURR(10)
DEF CURR.DAY    AS      CURR(11)
DEF INIT.LEN    AS      12
DEF BASE.YEAR   AS      64              !FOR PDP10 MONITOR (1/1/1964)
DEF JIFFIES     AS      3600            !JIFFIES PER MINUTE
DEF BLANK       AS      ^"     "
DEF BUFL        AS      32
DEF MIN.CHRG.CODE       AS      1
DEF MAX.CHRG.CODE       AS      2
DEF PRU.SCALE   AS      10.000
DEF TRU.SCALE   AS      10.000
DEF SIX.BIT(X)  AS      ( ( X - OCT 40 ) BAND OCT 77 )
DEF CTRL.CODE   AS      CTRLB(0)
DEF CTRL.PPN1   AS      CTRLB(1)
DEF CTRL.NM     AS      CTRLB(2)
DEF CTRL.PPN2   AS      CTRLB(3)
DEF CTRL.PGM1   AS      CTRLB(4)
DEF CTRL.PGM2   AS      CTRLB(5)
DEF CTRL.LIM    AS      CTRLB(6)
DEF CTRL.CHRG   AS      CTRLB(7)
DEF CTRL.WRITE  AS      HW(@CTRLB(8),0)
DEF CTRL.PRIORITY AS    HW(@CTRLB(8),1)
DEF CTRL.RATE   AS      CTRLB(10)
DEF ACTG.CNT    AS      ACTG(0)
DEF ACTG.PPN    AS      ACTG(1)
DEF ACTG.NM     AS      ACTG(2)
DEF ACTG.EXT    AS      HW(@ACTG(3),0)
DEF ACTG.DT1    AS      HW(@ACTG(3),1)
DEF ACTG.PROT   AS      BYT(ACTG(4),9,27)
DEF ACTG.DT2    AS      BYT(ACTG(4),27,0)
DEF ACTG.SIZ    AS      ACTG(5)
DEF BLK.SIZE    AS      128
DEF MAX.PRU     AS      255
DEF MIN.TYPE    AS      1
DEF MAX.TYPE    AS      2
DEF MIN.PCODE   AS      10000
DEF MAX.PCODE   AS      19999
DEF MAX.CALLS   AS      999999
DEF MAX.WRITES  AS      999999
DEF MIN.CHAR    AS      $A
DEF MAX.CHAR    AS      $K
DEF MIN.CHAN    AS      0
DEF MAX.CHAN    AS      15
DEF ZERO        AS      0
DEF HOME.FILES  AS      ( OCT 2000.000000 )

LOCAL   %CHARG.PRU.TRU, %TERM, %INITR, %WRITE.RECORD
LOCAL   %RTY.DATA
LOCAL   %RTY.CTRL, %OPEN.ACTG, %RTY.CH, %MONTH, %PROT, %PPN
LOCAL   %DROUND, %PUTCH, %PUTS, %PUTN
LOCAL   %CNTSC, %BUILD.REC, %LDAY, %CLOSE.ACTG, %REL.CH
LOCAL   %ADV.REC

LOCAL   CODE, UN.PRU, UN.TRU, ACC.PRU, ACC.TRU, ACC.CALLS, ACC.WRITES
LOCAL   CHAN, ACTG(0:6), SIZE, WRITE.FLAG
LOCAL   CTRLB(0:BLK.SIZE), CHGD.PRU, TRU.LIM, SEQ.CHAR
LOCAL   PRU.RATE, CHRG.CODE, Q1, Q2, Q3, PACC.TRU, BUF()
LOCAL   CHRG.IDX, BUF.IDX
LOCAL   CURR(0:INIT.LEN), INIT(0:INIT.LEN)

!*

EIF NOT ( MIN.TYPE <= RTYPE <= MAX.TYPE ) THEN RTY.ERR ( 1 )
FIF NOT ( MIN.PCODE <= PCODE <= MAX.PCODE ) THEN RTY.ERR ( 2 )

RTY.DATA


DO RTYPE OF MIN.TYPE:MAX.TYPE
 !INCREMENT TRU WITH THRESHOLD
 1: IF PCODE # CODE &
     OR CURR.MONTH # INIT.MONTH &
     OR CURR.NODE  # INIT.NODE  &
      THEN DO
     TERM ; INITR
    END ELSE DO
     CHARG.PRU.TRU ( 2 )
    END

 !TERMINATE PCODE
 2: TERM

END
RETURN

%RTY.ERR ( ERRCODE )
!ERROR CODES -
!  1 - RECORD TYPE ARGUMENT OUT OF RANGE
!  2 - PROGRAM CODE NUMBER ARGUMENT OUT OF RANGE
!  3 - TYMCHG UUO FAILURE
!  4 - ERROR ON GETTAB FOR GMT DATE
!  5 - ERROR ON GETTAB FOR GMT JIFFIES
!  6 - PPN2 IN CONTROL FILE IS ZERO
!  7 - ERROR ON INIT OF I/O CHANNEL
!  8 - ERROR ON GETTAB FOR JBTAUN, PPN FOR THIS JOB
!  9 -
! 10 -
! 11 - INPUT ERROR
! 12 - OUTPUT ERROR
! 13 -
! 14 - NO I/O CHANNELS AVAILABLE
! 15 - PROGRAM CODE NUMBER FROM CONTROL FILE IS NOT EQUAL TO
!      PROGRAM CODE NUMBER ARGUMENT
! 16 - ERROR ON LOOKUP FOR  CONTROL FILE
! 17 - EXCEEDED MAXIMUM SEQUENCE CHARACTER IN FILE NAME
!      INDICATING COMPLETE FAILURE ON OPENING ACCOUNTING FILE
! 18 - CHARGE CODE INDEX FROM CONTROL FILE OUT OF RANGE
 RTY.CR
 CTRLB(0) _ CTRLB(1) _ CTRLB(2) _ BLANK
 RTY.MSG ( " FATAL ERROR A" ) ; PUTN ( CTRLB, ERRCODE, 1, 4, 10, 1000 )
 PUTCH ( CTRLB, $-, 5 );  PUTN ( CTRLB, CURR.JOB, 6, 3, 10, 0 )
 PUTCH ( CTRLB, CARRET, 9 ) ; PUTCH ( CTRLB, LNFEED, 10 )
 PUTCH ( CTRLB, EOLIT, 11 ) ; RTY.MSG ( CTRLB )
 RTY.MSG ( " PLEASE CONTACT YOUR TYMSHARE REPRESENTATIVE IMMEDIATELY." )
 RTY.CR ; EXIT
END RTY.ERR

%CHARG.PRU.TRU ( REC.TYPE )
 ACC.CALLS _ ( ACC.CALLS + 1 ) MIN MAX.CALLS
!ACCUMULATIVE TRU = CURRENT TRU MINUS THE INITIAL VALUE OF
! TRU, MINUS THE PRU CHARGED SO FAR ON THIS CODE
 ACC.TRU _ CURR.TRU - INIT.TRU - CHGD.PRU
 DO CHRG.CODE OF MIN.CHRG.CODE:MAX.CHRG.CODE
! CHRG.CODE 1 - STRAIGHT SURCHARGE PER TRU
  1: [ Q1 ; Q2 ] _ ACC.TRU DMUL PRU.RATE
     ACC.PRU _ DROUND ( Q1 , Q2 , TRU.SCALE )
! CHRG.CODE 2 - FLAT FEE PER CODE
  2: ACC.PRU + _ PRU.RATE
 END


!CALCULATE UNCHARGED PRUS
 UN.PRU _ ( ACC.PRU - CHGD.PRU ) MAX ZERO
!CHARGE EXCESS UNCHARGED PRUS
 Q1 _ DROUND ( ZERO , UN.PRU , PRU.SCALE )
 CHGD.PRU + _ ( Q1*PRU.SCALE )
 WHILE Q1 <== ( Q1 - ( Q2 _ Q1 MIN MAX.PRU )) > ZERO THEN RTY.UUO ( Q2 )
!WRITE RECORD IF TRU THRESHOLD HAS BEEN EXCEEDED OR RECORD TYPE
! NEQ 2
 IF ( REC.TYPE # 2 ) OR ( ( ACC.TRU - PACC.TRU ) >= TRU.LIM ) &
  THEN WRITE.RECORD ( REC.TYPE )
 RETURN
END CHARG.PRU.TRU

%TERM
 IF CODE = ZERO THEN RETURN
 CHARG.PRU.TRU ( 3 ) ; CODE _ ZERO ; CLOSE.ACTG
 RETURN
END TERM

%INITR
 CODE _ PCODE ; RTY.CTRL ; OPEN.ACTG ; RTY.DATA
 MOVE INIT.LEN FROM CURR TO INIT
 ACC.PRU _ CHGD.PRU _ PACC.TRU _ ACC.CALLS _ ACC.WRITES _ ZERO
 CHARG.PRU.TRU ( 1 )
 RETURN
END INITR

%WRITE.RECORD ( REC.TYPE )
 IF WRITE.FLAG # ZERO THEN RETURN
 PACC.TRU _ ACC.TRU ; ACC.WRITES _ ( ACC.WRITES + 1 ) MIN MAX.WRITES
 BUILD.REC ( REC.TYPE )
 RTY.USO ( CHAN, SIZE ) ; RTY.OUT ( CHAN )
 RETURN
END WRITE.RECORD

%ADV.REC
 IF ( BUF.IDX + _ BUFL ) >= BLK.SIZE THEN &
  [ INC SIZE ; BUF.IDX _ ZERO ; MOVE BLK.SIZE FROM ALL ZERO TO CTRLB ]
 RETURN
END ADV.REC


%BUILD.REC ( REC.TYPE )
 MOVE BUFL FROM ALL BLANK TO BUF
 PUTN ( BUF, VERSION, 1, 4, 10, 0 )     !VERSION NUMBER
 PUTN ( BUF, REC.TYPE, 5, 2, 10, 0 )    !RECORD TYPE
 PUTN ( BUF, CODE, 7, 5, 10, 0 )        !PROGRAM CODE
 PUTN ( BUF, CURR.PPN, 12, 12, 8, 0 )    !PPN
 PUTN ( BUF, CURR.NODE, 24, 4, 8, 0 )   !NODE
 PUTN ( BUF, CURR.PORT, 28, 3, 8, 0 )   !PORT
 PUTN ( BUF, CHRG.IDX, 31, 2, 10, 0 )   !CHARGE INDEX
 PUTN ( BUF, INIT.DATE, 33, 6, 10, 0 )  !START DATE
 PUTN ( BUF, INIT.TIME, 39, 4, 10, 0 )  !START TIME GMT
 PUTN ( BUF, CURR.DATE, 43, 6, 10, 0 )  !CURRENT DATE
 PUTN ( BUF, CURR.TIME, 49, 4, 10, 0 )  !CURRENT TIME GMT
 PUTN ( BUF, INIT.TRU, 53, 12, 10, 10000 ) !INITIAL TRU
 PUTN ( BUF, CURR.TRU, 65, 12, 10, 10000 ) !CURRENT TRU
 PUTN ( BUF, ACC.TRU, 77, 12, 10, 10000 ) !ACCUMLATIVE TRU
 PUTN ( BUF, ACC.PRU, 89, 12, 10, 10000 ) !ACCUMULATIVE PRU
 PUTN ( BUF, CHGD.PRU, 101, 12, 10, 10000 ) !CHARGED PRU
 PUTN ( BUF, TRU.LIM, 113, 12, 10, 10000 ) !TRU THRESHOLD
 PUTN ( BUF, CHRG.CODE, 125, 2, 10, 0 )  !CHARGE CODE
 PUTN ( BUF, PRU.RATE, 127, 12, 10, 10000 ) !PRU RATE
 PUTN ( BUF, CURR.JOB, 139, 3, 10, 0 )  !JOB NUMBER
 PUTN ( BUF, ACC.CALLS, 142, 6, 10, 0 )  !ACCUMULATIVE NUMBER OF CALLS
    !FROM HOST PROGRAM TO RTYCHG WITH CURRENT PCODE
 PUTN ( BUF, ACC.WRITES, 148, 6, 10, 0 )  !NUMBER OF WRITES TO BILLING FILE
 PUTCH ( BUF, CARRET, 159 )
 PUTCH ( BUF, LNFEED, 160 )
 PUTCH ( BUF, EOLIT, 161 )
!RTY.MSG ( BUF )
 RETURN
END BUILD.REC


%RTY.DATA
 CURR.TRU _ RTY.TRU ; CURR.JOB _ RTY.JOB
 CURR.PPN _ RTY.PPN ; CURR.FPN _ RTY.FPN
 [ CURR.NODE ; CURR.PORT ] _ DOUBLE RTY.NODE
 [ CURR.DATE ; CURR.TIME ] _ DOUBLE RTY.DAT
 [ Q1 ; Q2 ] _ ( CURR.DATE*4 ) DIVMOD 1461 ; Q2 _ Q2 / 4 + 1
 CURR.YEAR _ Q1 + BASE.YEAR
 CURR.MONTH _ ZERO
 WHILE Q2 > ZERO THEN &
    Q3 _ Q2 <== ( Q2 - LDAY ( INC CURR.MONTH , CURR.YEAR ))
 CURR.DATE _ CURR.YEAR*10000 + CURR.MONTH*100 + CURR.DAY _ Q3
 [ Q1 ; Q2 ] _ ( CURR.TIME/JIFFIES ) DIVMOD 60 ; CURR.TIME _ Q1*100 + Q2
 RETURN
END RTY.DATA

%OPEN.ACTG
 IF WRITE.FLAG # ZERO THEN [ BUF.IDX _ ZERO ; BUF _ CTRLB ; RETURN ]
 ACTG.CNT _ 5
 ACTG.EXT _ MONTH ; ACTG.PROT _ PROT ; ACTG.PPN _ PPN
 CHAN _ RTY.CH ; RTY.INT ( CHAN )
 SEQ.CHAR _ SIX.BIT ( MIN.CHAR )
 LOOP DO
  ACTG.NM _ [ 12,6,6,6,6 ] * [ CTRL.NM, SEQ.CHAR, &
   SIX.BIT ( ( ( CURR.JOB / 100 ) MOD 10 ) + $0 ), &
   SIX.BIT ( ( ( CURR.JOB / 10 ) MOD 10 ) + $0 ), &
   SIX.BIT ( ( CURR.JOB MOD 10 ) + $0 ) ]
  RTY.LKP ( CHAN , ACTG ) ; SIZE _ ACTG.SIZ
  ACTG.PROT _ PROT ; ACTG.DT1 _ ACTG.DT2 _ ZERO
  WHILE  RTY.ENT ( CHAN , ACTG ) # ZERO
  IF INC SEQ.CHAR > SIX.BIT ( MAX.CHAR )  THEN RTY.ERR ( 17 )
 END
!CONVERT WORD COUNT TO BLOCK NUMBER
 SIZE _ ( SIZE/BLK.SIZE ) + 1
 RTY.SIO ( BLK.SIZE, CTRLB ) ; RTY.USI ( CHAN, SIZE )
 MOVE BLK.SIZE FROM ALL ZERO TO CTRLB ; RTY.INP ( CHAN )
 BUF.IDX _ ZERO
 WHILE CTRLB ( BUF.IDX ) # 0 THEN ADV.REC
 BUF _ @CTRLB ( BUF.IDX ) ; RTY.SIO ( BUF.IDX + BUFL , CTRLB )
 RETURN
END OPEN.ACTG

%CLOSE.ACTG
 IF WRITE.FLAG = ZERO THEN  REL.CH ( CHAN ) ; RETURN
END CLOSE.ACTG


%RTY.CTRL
 CHAN _ RTY.CH ; RTY.INT ( CHAN )
 MOVE 4 FROM RTY.CNM TO ACTG
 IF RTY.LKP ( CHAN, ACTG ) # ZERO THEN RTY.ERR ( 16 ) !CANT OPEN CONTROL FILE
 RTY.SIO ( BLK.SIZE, CTRLB ) ; RTY.USI ( CHAN, CODE-MIN.PCODE+1 )
 RTY.INP ( CHAN ) ; REL.CH ( CHAN ) 
 IF CTRL.CODE # CODE THEN RTY.ERR ( 15 )
 TRU.LIM _ CTRL.LIM ; PRU.RATE _ CTRL.RATE ; CHRG.CODE _ CTRL.CHRG
 WRITE.FLAG _ CTRL.WRITE
 IF NOT ( MIN.CHRG.CODE <= CHRG.CODE <= MAX.CHRG.CODE ) THEN RTY.ERR ( 18 )
 IF CTRL.PPN2 = ZERO THEN  RTY.ERR ( 6 )
 RETURN
END RTY.CTRL

%RTY.CH
 LOCAL I
 FOR I _ MAX.CHAN TO MIN.CHAN BY -1 &
   IF JOBJDA(I) = ZERO = RTY.DYN(I) THEN &
    [ RTY.DYN ( I ) _ RTY.DSK ; RETURN ( I SHL 23 ) ]
 RTY.ERR ( 14 )
END RTY.CH

%REL.CH ( CHAN )
 RTY.DYN ( CHAN SHR 23 ) _ ZERO ; RTY.RLS ( CHAN ) ; RETURN
END REL.CH

%MONTH
 RETURN RTY.MTH ( CURR.MONTH )
END MONTH

%PROT
 RETURN IF CTRL.PPN1 = 0 OR CTRL.PPN2 = CURR.FPN &
  THEN OCT 0.4.7 ELSE OCT 1.0.0
END PROT

%PPN
 RETURN IF CTRL.PPN1 = 0 THEN CURR.FPN ELSE CTRL.PPN2
END PPN

%DROUND ( N1, N2, DEN )
 LOCAL Q1,Q2,%RND
 [Q1;Q2]_[N1;N2] DDIVMOD DEN
 RETURN RND
 %RND
  IF ABS Q2>=(DEN+1)/2 THEN IF Q1>=0 THEN INC Q1 ELSE DEC Q1
  RETURN Q1
 END RND
END DROUND

%PUTCH(BUF,CHR,POS)
 LOCAL PTR,PTR1,STR(0:5),L
 CHV CHPT(BUF,POS-1) _ CHR
 RETURN

 %%PUTS(BUF,SPTR,POS,LN)
  PTR_CHPT(BUF,POS-2); PTR1_ CHPT(SPTR,-1)
  L_ 0
  LOOP DO
   WHILE INC L <=LN AND NCHV PTR1 # EOLIT
   NCHV PTR_ IF CARRET#CHV PTR1#LNFEED THEN CHV PTR1 ELSE $ 
  END
  RETURN

 %%PUTN(BUF,VAL,POS,LN,B,SCL)
  PTR1_CNTSC(VAL,CHPT(STR,-1),@L,B,SCL)
  PTR_CHPT(BUF,POS-2+LN-L)
  WHILE NCHV PTR1#EOLIT THEN NCHV PTR_CHV PTR1
  RETURN
END PUTCH

%CNTSC(N,PTR,@I,B,S)
 LOCAL A(0:3),APTR,Q1,Q2,RPTR, J
 RPTR_PTR
 J_I_0; APTR_CHPT(A,-1)
 IF N<0 THEN [N_-N; INC I; NCHV PTR_$-]
 IF S#0 THEN [N;Q2]_N DIVMOD S
 LOOP DO
  [N;Q1]_N DIVMOD B ; NCHV APTR _ Q1+$0 ; INC J
  WHILE N#0
 END
 NCHV APTR
 FOR Q1 _ 1 TO J  [ NCHV PTR _ CHV (CHPT(A,J-Q1)); INC I ]
 IF S#0 THEN DO
  NCHV PTR_$. ; INC I
  WHILE S <== S/B >1 THEN DO
   [Q1;Q2]_Q2 DIVMOD S ; INC I ; NCHV PTR _ Q1+$0
  END
 END
 NCHV PTR_EOLIT
 RETURN RPTR
END CNTSC

%LDAY(MM,YY)
!MM-MONTH (1:12)
!YY-YEAR
 LOCAL D
 TABLE NDAY(1:12)[31,28,31,30,31,30,31,31,30,31,30,31]
 D_NDAY(MM)
 IF MM=2 AND YY MOD 4 = 0 THEN INC D
 RETURN D
END LDAY

END RTYSIM
 