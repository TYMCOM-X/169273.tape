TITLE ASP ABSOLUTE STRUCTURE SAVE AND RESTORE PROGRAM
SUBTTL E. SOCCI 10/31/79
LALL
	COPVER==10
	LOC 137
	EXP COPVER
	RELOC

	SALL	;CLEAN LISTINGS PLEASE

;REVISION HISTORY

comment \
1	FIRST VERSION OF ASP, ABSOLUTE STRUCTURESAVINGANDRESTORING PROGRAM

2	*Prints out recording density with header and tape change
	messages. /EVS
	*Prints out unit within structure and page within unit
	being saved for each tape written or restored (i.e.
	DSKB2, PAGE 11111 (OCTAL) . Installed for debugging./EVS
	*ASP will no longer allow a tape to be overwritten during
	a given ASP SAVE run if the header on that tape indicates
	that it has been written during that run (to save people
	from typing return accidentally when ASP asks for new
	tape unit. /EVS

3	Put blank line in output after printing out STR unit
	and DP as per operations request.
	Fixed bug where could overwrite ASP tape of the same set
	after a fatal output error.
	Fixed bug where record sequence number got zeroed instead
	of reset after fatal tape output error.
	Fixed bug where you could type I DONT and it would overwrite
	tape because it stopped scanning.
	Tape is now always rewound before writing header onto it.

4	VERIFY command - allows tape drive speed verification of an ASP
	tape set. Does everything for a restore short of actually writing
	the data onto the disk. Doesn't require stand alone system to perform,
	can be performed under timesharing. After a set of ASP tapes has
	been verified with no significant read back problems, it is far more
	likely that the restore if it is necessary will proceed successfully.

	New output error recovery: If a write error is encountered,
	a section of blank tape enough to cover the size of the failed record
	is written onto the tape, and the record is re-written. If the
	retry is unsuccessful, the another section of blank tape is written,
	and the record is tried once again. If this cycle finally succeeds
	in successfully writing the record before OECMAX tries (currently
	20 is the default) then the save will proceed normally. Otherwise,
	the operator is asked to set the tape aside and mount a new tape,
	at which point the save is restarted from there.

	The header record for each tape is actually read back after it is
	written so ensure that it made it out to the tape successfully.

	New input error recovery:
	On input, if an I/O error or consistency error (bad record sequencen
	number, bad prologue code) is encountered, the tape is searched backwards
	for the last good record. If it is not found, the tape is searched
	forwards for the first good record that can be found. If it is found,
	a message stating what the last disk page restored or verified
	is is printed. The tape is then searched for the next good record.
	If it is not found on the remainer of the tape, the operator
	is asked to mount the next tape if it exists. Otherwise,
	the restore continues from the record that was found.

	New Prologue Record format:
	The format of an ASP tape consists of a header, followed by
	<data record><prologue record> pairs. The prologue record used
	to contain SIXBIT/ASP/, but now has been changed to contain
	the GMT time of day that was written into the header. This
	ensures that during read recovery old ASP data is not mistaken
	for new ASP data. However, this format also makes tapes written
	by this version of ASP unreadable by previous ASP versions.

	OECMAX and SRCLEN commands: These commands set the number of
	times an output record is tried to be written out before asking
	for a new tape, and the number of records to search in input
	error recovery for a good record in the forward direction.
	Under normal circumstances, these commands should not be used.

	A more explicit error message is now given on a fatal tape output
	error. The operator is now specifically instructed that the tape
	is no longer part of the ASP tape save set and that it should be
	put aside.

	A bug was fixed which was introduced in ASP version 3 which caused
	the code instead of the record sequence number to be stored
	in the prologue record, causing the tapes to be unuseable on
	restore - would have gotten record sequence error.  However, data on
	the tapes written by version 3 was still good, and if it becomes necessary
	to use that data, a special version of ASP V3 can be created which
	will restore those tapes.

5	Put in SETRES command to set tape number, unit number
	and page number to do a restart of an ASP SAVE or RESTOR,
	and a PRTRES command to print out current status of
	SETRES. TThe CHECK command will now print out the first
	page written on the tape to facilitate restarting saves
	or restores. Since only certain disk pages are legal to
	start saves or restores on, there is some built in
	consistency checking.

6	Fixed problem with SETRES which caused current date and time to
	be written onto a restarted tape instead of date and time of
	ASP save set. format for SETRES is now SETRES <tape unit name>.
	Operator must mount last fully successful tape saved, restored,
	or checked, and ASP gets the tape number and date and time from
	the header of that tape. Then operator mounts tape to restart
	(fresh tape for save, next tape to restore or verify for
	RESTORE and VERIFY operations) and ASP operation continues
	from there. PRTRES changed to print out date and time
	of ASP save/restore.
	Routine CHKHED changed so that in verify mode ASP doesn't
	demand that structure of the system the verify is being done
	on is the same as structure that the ASP dump is for.

7       Code modified @ INOK+6 to type record sequence numbers when
        verify detects an error.  Change made by Darren Price but
        not distributed./SUTTOND

10      Removed <ADDI T1,1> @ NXTSAV+5 so that when a tape is replaced
        in a SAVE operation the 1st record on the tape will be rewritten.
        Also added <MTAPE TAPE,.MTEOF> @ UNLTAP to write a tape mark on
        the bad tape./SUTTOND
	\;end comment

;AC DEFINITIONS

	S=0
	T1=1
	T2=2
	T3=3
	T4=4
	DP=5
	CNT=6
	BUF=10
	IOW=11
	IOW1=12		;MUST BE IOW+1
	IOW2=13		;MUST BE IOW+2
	CH=14
	P=17

;MTAPE FUNCTION CODES

.MTREW==1
.MTEOF==3
.MTSKR==6
.MTBSR==7
.MTBLK==13
.MTUNL==11


;PARAMETERS


IFNDEF MAXREC,<MAXREC==30000>			;MAXIMUM RECORD SIZE (32 PAGES)
MAXRCP==<MAXREC+777>/1000		;IF MAXREC < 1000, ROUND UP
BUFNUM==^D10
PPC==BUFNUM*<MAXREC/1000>	;NUMBER OF PAGES PER COPY
STDSRC==^D20			;STANDARD DEFAULT LENGTH TO SEARCH IN RESYNC BEFORE GINVING UP FORWARDS.
INCHPG==^D3			;HOW MANY INCHES A .MTBLK WRITES BLANK TAPE FOR
STDOEC==^D10		;NUMBER OF TIMES WILL TRY TO WRITE SAME REC OUT TO TAPE.

;I/O CHANNELS

DISK==0
TAPE==1


;MACRO DEFINITIONS

DEFINE ERROR(MSG),<PUSHJ P, [OUTSTR [ASCIZ\MSG
\]
		EXIT 1,
		JRST .-1]>;END ERROR MACRO DEFINITION
DEFINE ERRPOP(MESS) <
JRST	[OUTSTR [ASCIZ \'MESS
\]
	 POPJ P,]
>;END ERRPOP

DEFINE MSG(MESS,CRLF)<IFB <CRLF> <OUTSTR [ASCIZ\'MESS\]>
IFNB <CRLF> <OUTSTR [ASCIZ \'MESS
\]>
>;END MSG MACRO DEFINITION

PDLLEN==^D40


;DEFINITIONS

.CHSMP==43
IO.UWC==1B31
.WSRNG==1

;UGETF SYMBOLS

.UGCNT==0		;GET LAST RECORD SIZE
.UGSTS==2		;GET STATUS
  UG.HWP==(1B0)
  UG.RDY==(1B1)		;READY
  UG.LDP==(1B3)		;LOAD POINT
  UG.D62==(1B13)	;DENSITY 6200
  UG.D16==(1B14)	;DENSITY 1600
  UG.D8==(1B15)		;DENSITY 800
  UG.D5==(1B16)		;DENSITY 500
  UG.D2==(1B17)		;DENSITY 200
  UG.DNM==UG.D62!UG.D16!UG.D8!UG.D5!UG.D2

OPDEF VCLEAR [CALLI -66]
OPDEF VCREAT [CALLI -67]
OPDEF VPROT [CALLI -70]
OPDEF WSCTL [CALLI -74]
OPDEF PREREF [CALLI -75]
OPDEF PERSET [CALLI -72]

OPDEF PJRST [JRST]

.GTCNF==11
  .CNDAT==11
  .CNTIM==10
SYSNSZ==5		;NUMBER OF WORDS IN SYSTEM NAME

IOTEND==2000		;END OF TAPE
IODEND==20000		;END OF FILE
IOEMSK==740000		;ERROR MASK
IODERR==200000
IODTER==100000
IOIMPM==400000		;WRITE LOCK

IFNDEF FTDEBG,<FTDEBG==0>

;COMMAND TABLES

DEFINE COMMAC <
X SAVE,SAVE,<SAVES A FILE STRUCTURE IMAGE TO TAPE>
X CHECK,CHECK,<READS ID RECORD FROM ASP TAPE>
X RESTOR,RESTOR,<REBUILDS A DISK STRUCTURE FROM A ASP TAPE>
X VERIFY,VERIFY,<VERIFIES A SET OF ASP TAPES TO ENSURE THEIR READABILITY>
X HELP,HELP,<TYPES THIS MESSAGE>
X STATUS,STATUS,<PRINTS STATUS AND DENSITIES AVAILABLE FOR CURRENT TAPE DRIVE>
X DENSIT,SETDEN,<SETS OTHER THAN STANDARD DENSITY>
X REWIND,REWIND,<REWINDS CURRENT TAPE UNIT>
X UNLOAD,UNLOAD,<UNLOADS CURRENT TAPE UNIT>
X OPEN,TAPOPN,<SELECTS TAPE UNIT>
X DAYTIM,DAYTIM,<PRINTS CURRENT DATE AND TIME>
X OECMAX,MAXOEC,<SET NUMBER OF TIMES TO TRY OUTPUTTING SAME REC BEFORE ASKING FOR NEW TAPE>
X SRCLEN,SETSRC,<SET NUMBER OF BAD RECORDS TO SEARCH IN RESYNC BEFORE GIVING UP>
X SETRES,SETRES,<SET OCTAL UNIT IN FILE STRUCTURE AND OCTAL PAGE WITHIN STRUCTURE FOR REWRITING A TAPE AFTER A CRASH>
X PRTRES,PRTRES,<PRINT OUT RESTART TAPE NUMBER AND LOCATION IF ANY>
X QUIT,COPBYE,<EXIT FROM ASP>
>

DEFINE X(A,B,C)<SIXBIT /'A/>
COMNAM:	COMMAC
	COMLEN==.-COMNAM
DEFINE X(A,B,C)<EXP 'B>
COMADR:	COMMAC

ST:	JFCL
	RESET
	MOVE	P,[IOWD PDLLEN,PDL]
	MOVEI	T1,STDOEC
	MOVEM	T1,OECMAX	;SETUP STD RETRY COUNT
	MOVEI	T1,STDSRC	;AND FORWARD RESYNC SEARCH COUNT
	MOVEM	T1,SRCLEN
	OPEN	DISK,OPNSTR	;OPEN THE STRUCTURE
	  ERRPOP <CANNOT OPEN DSKB>
	SETZB	T4,STRMXP	;START WITH FIRST SYSTEM UNIT, CLEAR MAX PAGES PER STR
	SETZM	OPNTNM		;SAY NO TAPE IS OPENED.
	SETZM	STRNMU		;CLEAR NUMBER OF UNITS WORD.
	SETZM	DEBCNT#		;CLEAR DEBUG COUNT
UNILUP:	SYSPHY	T4,
	  ERRPOP <ERRPOP IN SYSSTR UUO>
	JUMPE	T4,UNIDON	;IF RETURNED ZERO, WE'RE DONE.
	MOVEM	T4,DSKCHB	;PUT INTO DSKCHR BLOCK
	MOVE	T1,[20,,DSKCHB]
	DSKCHR	T1,
	  ERRPOP <DSKCHR GAVE ERRPOP FOR UNIT NAME SYSSTR GAVE>
	MOVE	T1,DSKCHB+4	;GET STRUCTURE NAME
	CAME	T1,STRNAM	;IS IT OUR STRUCTURE?
	JRST	UNILUP		;NO
	AOS	STRNMU		;COUNT ANOTHER UNIT
	MOVE	T1,DSKCHB+6	;GET UNIT CAPACITY IN PAGES
	ADDM	T1,STRMXP	;ADD TO STRMXP
	MOVE	T1,DSKCHB+16	;GET HOM BLOCK UNIT ID
	TRZ	T1,7777		;MASK OFF UNIT NAME
	MOVEM	T1,STRHID	;PUT INTO HERE FOR REFERENCE.
	JRST	UNILUP		;AND CONTINUE.
UNIDON:
	HRRZ	BUF,.JBFF##	;GET FIRST FREE LOC
	IORI	BUF,777
	HRLI	BUF,-BUFNUM	;GET -BUFS,,ADDR-1
	MOVEM	BUF,PTRBUF	;SAVE FOR WRAP AROUND

;GET COMMAND AND PROCESS.

GETCOM:	MSG	,CRLF
	MOVEI	CH,-1		;SO SCANNERS
	OUTCHI	">"		;PROMPT FOR COMMAND
	PUSHJ	P,SIXIN		;GET IT
	  JRST	GETCOM		;BLANK.
	MOVE	T4,[-COMLEN,,COMNAM] ;SCAN THE TABLE
	PUSHJ	P,COMMAN
	  JRST	GETCOM		;GET A COMMAND
	PUSHJ	P,@COMADR(T4)	;DO IT
	  JFCL			;IN CASE OF ERROR RETURNS
	PUSHJ	P,BRKEAT	;EAT UP UNUSED CHARS.
	JRST	GETCOM		;AND GET ANOTHER COMMAND

SUBTTL HELP MESSAGE

HELP:	MSG	(<VALID COMMANDS ARE>,CRLF)

DEFINE X(A,B,C),<
MSG (<'A	'C>,CRLF)
>
	COMMAC			;;PRINT OUT TEXT FOR ALL COMMANDS
	POPJ	P,

SUBTTL CHECK

CHECK:	PUSHJ	P,GETTAP	;GET TAPE
	  JRST	NOTAPO
	PUSHJ	P,CHECK0
	  POPJ	P,		;NO GOOD.
	IN	TAPE,[IOWD 1,HEDBF1
			IOWD PROLEN,PROBUF
			0] ;GET FIRST DP ON TAPE.
	JRST	.+2	;OK
	JRST	[GETSTS TAPE,S
		 ERRPOP <CANNOT READ FIRST DATA RECORD ON TAPE>
		 JRST TPINER]
	MOVE	T1,HEDBUF+HEDTIM	;MAKE SURE CODE MATCHES
	CAME	T1,PROBUF+PROCOD
	ERRPOP	<BAD PROLOGUE CODE FOUND IN FIRST RECORD>
	MOVE	T4,PROBUF+PROCNT
	IMULI	T4,MAXRCP
	MSG	<FIRST PAGE ON TAPE IS >
	AOS	(P)
	PJRST	PRTDP

CHECK0:	MTAPE	TAPE,.MTREW		;REWIND
	SETZM	HEDBUF		;CLEAR OUT THE BUFFER
	MOVE	T1,[HEDBUF,,HEDBUF+1]
	BLT	T1,HEDBUF+SIZHED-1
	IN	TAPE,[IOWD SIZHED,HEDBUF
			0]
	  JRST	CHECK1
	GETSTS	TAPE,S		;GET STATUS IN S FOR TPINER
	JRST	[MSG <CANNOT READ HEADER RECORD: >
		 JRST TPINER]
CHECK1:	MOVE	T2,HEDBUF+HEDSIZ
	CAIE	T2,SIZHED		;PROPER SIZE?
	ERRPOP	<NOT IN ASP FORMAT, BAD HEADER SIZE>
	MOVE	T1,HEDBUF+HEDNAM	;MAKE SURE ITS OK
	CAME	T1,CODNAM	;OK?
	ERRPOP	<NOT IN ASP FORMAT, BAD HEADER CODE NAME>
	MOVEI	T4,HEDBUF
	MSG	<RECORDED BY >
	AOS	(P)
	PJRST	PRTHED

REWIND:	PUSHJ	P,GETTAP	;GET TAPE OPEN
	  JRST	NOTAPO
	MTAPE	TAPE,.MTREW		;YES, REWIND IT
	POPJ	P,		;AND RETURN.

UNLOAD:	PUSHJ	P,GETTAP	;GET A TAPE OPEN
	  JRST	NOTAPO
	MTAPE	TAPE,.MTUNL		;REWIND AND UNLOAD.
	JRST	CPOPJ1		;OK RETURN.

COPBYE:	RELEAS	DISK,
	RELEAS	TAPE,
	EXIT	1,
	JRST	.-1

SUBTTL MAIN COMMAND ROUTINES

TAPOPN:	PUSHJ	P,SIXIN
	  ERRPOP <NO TAPE SPECIFIED>
	PUSHJ	P,TAPOP1	;OPEN IT
	  ERRPOP	<DEVICE NOT AVAILABLE>
	JRST	CPOPJ1

TAPOP1:	MOVEM	T1,OPNTNM	;PUT INTO TAPE OPEN BLOCK
TAPOP2:	OPEN	TAPE,OPNTAP
	  JRST	[SETZM OPNTNM	;NOTHING IS REALLY OPEN
		 POPJ P,]	;RETURN.
	MOVE	S,OPNTAP	;GET INITIAL STATUS SETUP IN S.
	AOS	(P)		;IT WILL WORK.
	PJRST	SETDTB		;SETUP DENSITY BLOCK ADDRESS AND RETURN.

;STATUS COMMAND, PRINTS MISCELLANEOUS STATUS.
; ENTER AT CURDEN TO PRINT CURRENT DENSITY ON OPEN TAPE UNIT

STATUS:	PUSHJ	P,GETTAP	;OPEN TAPE UNIT
	  JRST	NOTAPO
	MOVE	T1,OPNTNM	;GET NAME IN T1 FOR PRINTOUT
	PUSHJ	P,SIXOUT	;PRINT IT OUT
	MSG	<:>,CRLF
	MOVEI	T1,.UGSTS	;GET CONDENSED DEVICE INDEPENDENT TAPE STATUS
	UGETF	TAPE,T1		;ANSWER IN T2
	TLNE	T2,UG.HWP	;WRITE PROTECTED?
	MSG	(<UNIT IS WRITE PROTECTED>,CRLF)
	TLNN	T2,UG.LDP	;UNIT AT LOAD POINT?
	MSG	(<UNIT NOT AT LOAD POINT>,CRLF)
	PUSHJ	P,PRTDEN	;PRINT AVAILABLE DENSITIES
	MSG	<, CURRENT = >
CURDEN:	LDB	T1,[POINT 2,OPNTAP,28] ;GET CURRENT
	JUMPE	T1,STAT0
	SUBI	T1,3
	MOVMS	T1		;GET INDEX INTO DENSITY TABLE
STAT0:	ADD	T1,TAPDTB
	HRRZ	T1,(T1)		;GET THE DECIMAL NUMBER
	PUSHJ	P,DECOUT	;PRINT IT AND
	MSG	< BPI>,CRLF
	POPJ	P,		;RETURN.


;ROUTINE TO PRINT DENSITIES AVAILABLE. TAPE DENSITY TABLE IN TAPDTB.

PRTDEN:	MSG	(<DENSITY(>)
	MOVE	T3,TAPDTB	;GET DENSITY TABLE ADDRESS
	HRRZ	T1,(T3)		;MUST BE AT LEAST ONE
	JRST	DENLP0		;DON'T PRINT COMMA FIRST TIME.
DENLUP:	SKIPN	T1,(T3)		;GET NEXT ONE
	JRST	DENDON		;RETURN.
	MSG	(<,>)		;SEPARATE
DENLP0:	HRRZS	T1
	PUSHJ	P,DECOUT	;PRINT OUT IN DECIMAL
	AOJA	T3,DENLUP	;AND PRINT NEXT IF ANY.

DENDON:	MSG	(<)>)
	POPJ	P,		;AND RETURN.


SETDTB:	MOVEI	T1,.UGSTS	;GET UGETF WORD	
	UGETF	TAPE,T1		;IN T2
	TDZ	T2,[<-UG.DNM-1>,,-1]
	SETZ	T3,		;FOR INDEXING
FNDDTB:	HLLZ	T1,DENSTB(T3)	;GET BITS
	SKIPN	T1
	ERRPOP	<UNIT HAS UNKNOWN COMBINATION OF DENSITIES>
	CAME	T1,T2		;MATCH
	AOJA	T3,FNDDTB	;NO, GO FOR NEXT
	MOVE	T4,DENSTB(T3)		;GET ADDRESS OF TABLE.
	MOVEM	T4,TAPDTB	;SAVE IT FOR LATER.
	POPJ	P,		;AND RETURN.

SUBTTL SAVE CODE

SAVE:	SETZM	VERFLG		;THIS IS NOT A VERIFY, DO NORMAL MAPPING.
	PUSHJ	P,GETTAP	;OPEN TAPE UNIT
	  JRST	NOTAPO

	PUSHJ	P,ALONE		;I WANT TO BE ALONE
	  POPJ	P,		;SORRY.

	SETZ	DP,		;CLEAR OUT AND GET VALUE OF
	EXCH	DP,RESTDP	;WHERE TO START
	MOVE	T1,DP		;GET DP
	IDIVI	T1,MAXRCP	;GET RECORD NUMBER WE WILL START WITH
	MOVEM	T1,TAPBAS	;THIS IS WHERE THIS TAPE STARTS
	MTAPE	TAPE,.MTREW		;REWIND THE TAPE
	SETZ	T1,
	EXCH	T1,RESTTP	;GET TAPE NUMBER TO RESTART AT
	SKIPN	T1
	MOVEI	T1,1		;IF NO RESTART, START AT TAPE 1
	MOVEM	T1,TAPNUM

	PUSHJ	P,INIHED		;INIT THE HEADER TO GO OUT
	  POPJ	P,		;BAD DATE OR SOMETHING

;HERE TO RESTART THE WRITE OF A TAPE REEL
; DP HAS DISK PAGE ADDRESS TO START WITH.

SAVRST:	PUSHJ	P,WRTHED	;WRITE IT OUT
	  POPJ	P,		;SORRY, DIDN'T WORK.
	MOVEI	T4,HEDBUF	;ADDRESS OF THE HEADER
	PUSHJ	P,PRTHED	;PRINT IT OUT FOR USER

	MOVSI	IOW,-MAXREC	;START OUT WITH THIS BIG OF A TRANSFER
	MOVE	IOW+1,[IOWD PROLEN,PROBUF] ;PROLOGUE BUFFER
	SETZ	IOW+2,		;END OF LIST
	MOVE	DP,TAPBAS	;GET DP SETUP TO BEGINNING OF REEL
	IMULI	DP,MAXRCP	;TURN FROM REC PAIR NO TO DP NO

;HERE AFTER A WRITE ERROR RECOVERY TO WRITE OUT THE TAPE FROM LAST KNOWN GOOD POINT.

WRTRST:	MOVE	BUF,PTRBUF	;GET PAGE BUFFER POINTER SETUP
	SETZM	LASBUF		;INDICATOR FOR LAST BUFFER.
	MOVE	T1,FIRTIM	;CODE IS THE TIME SET STARTED.
				;THIS KEEPS OVERLAPPING ASP DATA FROM APPEARINK OK ON RESTORE.
	MOVEM	T1,PROBUF+PROCOD
	MOVE	T1,DP		;GET FIRST RECORD THAT GOES ONTO THIS TAPE.
	IDIVI	T1,MAXRCP	;TURN INTO REC PAIR NUMBER
	MOVEM	T1,PROBUF+PROCNT ;THIS IS FIRST REC NUMBER THAT GOES INTO PROLOGUE RECORD.
	MOVE	T4,DP		;GET DP TO PRINT OUT
	MSG	<SAVING >
	PUSHJ	P,PRTDP		;NOW PRINT WHAT WE ARE SAVING.

;NOW START IN THE WHOLE BUFFER AREA

	MOVEI	CNT,MAXRCP*BUFNUM	;MAP IN EVERYTHING
	PUSHJ	P,MAPRD
	  POPJ	P,		;SOMETHING WENT VERY WRONG
	ADDI	DP,MAXRCP*BUFNUM ;ADVANCE DISK ADDRESS.
	MOVEI	CNT,MAXRCP	;FROM NOW ON, DO ONE BUFFER AT A TIME.

;NOW START OUT A BUFFER TO TAPE, THEN START NEXT XFER INTO IT.
; DP HAS NEXT DISK PAGE TO MAP.

COPLUP:	HRR	IOW,BUF		;GET NEXT ADDRESS INTO IOW
	CAME	BUF,LASBUF	;IS THIS THE LAST BUFFER?
	JRST	COPRTY		;NO.
	MOVN	T1,CNT		;YES, GET -VE PAGES TO DO
	ASH	T1,^D9		;TURN INTO WORDS
	HRL	IOW,T1		;PUT INTO IOW
COPRTY:	TRNE	S,IOTEND	;IS END OF TAPE LEFT OVER FROM LAST WRITE?
	JRST	NXTSAV		;YES, MUST SWITCH TAPES.
	OUT	TAPE,IOW	;START IT OUT
	  JRST	OUTOK		;ALL IS OK.
	GETSTS	TAPE,S		;GET TAPE STATUS
	TRNE	S,IOEMSK	;MAKE SURE NO ERRORS
	JRST	TPOERR		;TAPE OUTPUT ERROR, TRY TO RECOVER
	TRNN	S,IOTEND	;END OF TAPE?
	ERRPOP	<UNKNOWN TAPE OUTPUT ERROR CONDITION>
	JRST	OUTOK		;YES, WE WILL CATCH IT ABOVE IF WE HAVE TO WRITE ANOTHER RECORD OUT

NXTSAV:	MTAPE	TAPE,.MTEOF		;WRITE EOT
	GETSTS	TAPE,S		;SEE IF CAN WRITE IT
	TRNE	S,IOEMSK	;MAKE SURE NO FATAL ERRORS
	JRST	BADTAP		;NO GOOD, REWRITE THE TAPE
	MOVE	T1,PROBUF+PROCNT ;GET NEXT RECORD NUMBER
	MOVEM	T1,TAPBAS	;STORE IN CASE HAVE TO RESTART
	AOS	HEDBUF+HEDTPN	;WRITE NEXT NUMBER OUT
	AOS	TAPNUM
NXTSV1:	MSG	<NEXT TAPE UNIT:>
	MOVEI	CH,-1		;NEW LINE TO INPUT
	PUSHJ	P,GETTAP	;GET NEXT ONE
	  JRST	NXTSV1		;HE HAS TO SPECIFY ONE.
	MTAPE	TAPE,.MTREW		;REWIND IT
	PUSHJ	P,NOTHED	;MAKE SURE NOT FROM CURRENT SET BEING RECORDED
	  JRST	NXTSV1		;NO GOOD, ASK AGAIN.
	PUSHJ	P,WRTHED	;WRITE OUT HEADER
	  JRST	NXTSV1		;WRITE ERROR OR SOMETHING, ASK FOR ANOTHER UNIT
	MOVEI	T4,HEDBUF	;AND PRINT OUT THE INFO FOR USER'S INFO
	PUSHJ	P,PRTHED	;PRINT OUT THE INFO FOR HIM
	MSG	<SAVING >
	MOVE	T4,PROBUF+PROCNT ;RECORD NUMBER WE ARE SAVING.
	IMULI	T4,MAXRCP	;TURN INTO PAGE NUMBER
	PUSHJ	P,PRTDP
	JRST	COPRTY		;AND GO REJOIN THE CODE.



TPOERR:	TRNE	S,IODERR	;DEVICE?
	MSG	<DEVICE >
	TRNE	S,IODTER	;DATA?
	MSG	<DATA >
	MSG	<WRITE ERROR, ATTEMPTING RECOVERY >,CRLF
	MOVE	T1,PROBUF+PROCNT	;GET REC NUMBER OF THIS ERROR
	EXCH	T1,LASOER	;THIS IS NOW LAST ERROR
	CAME	T1,LASOER	;SAME AS LAST TIME?T	[SETZM LASOEC	;NO, RESET COUNT
		  JRST TPOER1]	;AND DO FIRST RETRY FOR THIS REC
	AOS	T1,LASOEC	;INCREMENT COUNT, GET IT
	CAMLE	T1,OECMAX	;STILL IN RANGE?
	JRST	BADTP0		;NO, ASK FOR NEW TAPE.
TPOER1:	SETOM	T4			;INDICATE BACKWARD SEARCH
	PUSHJ	P,RESYNC		;FIND PLACE ON TAPE AGAIN.
	  JRST	BADTP0			;CANNOT RESYNC, TRY ANOTHER TAPE
	CAML	T4,PROBUF+PROCNT	;MUST NOT BE ONE WE JUST FAILED ON
	JRST	[MTAPE TAPE,.MTBSR ;IT WAS, BACKSPACE
		 MSG (<.>)
		 JRST TPOER1]
	LDB	T2,[POINT 2,OPNTAP,28] ;GET DENSITY
	JUMPE	T2,TPOSTD	;STD DENSITY IF ZERO
	SUBI	T2,3
	MOVMS	T2
TPOSTD:	ADD	T2,TAPDTB
	HRRZ	T2,(T2)		;GET THE  DENSITY
	IMULI	T2,^D8		;TIMES MAX NUMBER OF TRACKS GIVES BITS PER INCH
	IDIVI	T2,^D36		;GET WORDS PER INCH
	MOVEI	T1,MAXREC+PROLEN	;NUMBER OF WORDS PER RECORD PAIR
	ADDI	T1,-1(T2)	;ROUND UP
	IDIV	T1,T2		;GET NUMBER OF INCHES TO WRITE
	IDIVI	T1,INCHPG	;GET NUMBER OF GAPS TO WRITE
	MOVEI	T2,1		;GET 1 PLUS COUNT
	ADD	T2,LASOEC		; OF ERROR ON SAME RECORD

	IMUL	T1,T2		;DO THIS MANY TIMES RETRY COUNT
	MTAPE	TAPE,.MTBLK
	SOJGE	T1,.-1		;AND WRITE ONE EXTRA FOR THE RECORD GAPS
	AOS	DP,T4		;OK, GET REC NUMBER WE FOUND, LAST GOOD + 1 = WHERE TO START.
	IMULI	DP,MAXRCP	;GET DP TO START OVER WITH
	STATZ	TAPE,IOEMSK+IOTEND	;ANY PROBLEMS?
	JRST	BADTP0			;YES, TRY ANOTHER TAPE
	MSG	<RECOVERY SUCCESSFUL, >
	JRST	WRTRST		;AND GO RESTART THE TAPE FROM C(DP) POINT.


;HERE IF NO HOPE OR GOT ERROR IN SOME PAIN IN THE NECK SPOT

BADTP0:	MSG	<RECOVERY UNSUCCESSFUL, FATAL WRITE ERROR>,CRLF
	MSG	<>,CRLF
	JRST	BADT1A
BADTAP:	PUSHJ	P,TPOUER	;COMPLAIN ABOUT THE ERROR (DEVICE OR DATA)
BADT1A:	MOVE	DP,TAPBAS	;GET RECORD NUMBER THIS TAPE STARTED WITH
	IMULI	DP,MAXRCP	;COMPUTE STARTING DP ADDRESS
UNLTAP: MTAPE   TAPE,.MTEOF     ;WRITE TAPE MARK ON BAD TAPE
	MTAPE	TAPE,.MTUNL	;UNLOAD THE TAPE - TELL OPR WE DON'T LIKE IT
BADTP1:	MSG	<PLEASE MOUNT A NEW TAPE AND PUT THIS ONE ASIDE,>,CRLF
	MSG	< IT IS NO LONGER PART OF THIS ASP SAVE SET.>,CRLF
	MSG	<NEXT TAPE UNIT:>
	MOVEI	CH,-1		;SCANNING A NEW LINE
	PUSHJ	P,GETTAP	;OPEN UP NEW TAPE
	  JRST	BADTP1		;SOME PROBLEM, ASK AGAIN
	PUSHJ	P,NOTHED	;REWIND, MAKE SURE NOT OF SAME SET.
	  JRST	BADTP1		;NO, ASK AGAIN.
	JRST	SAVRST		;AND GO RESTART THE TAPE.

;HERE IF NO ERROR.
OUTOK:	AOS	PROBUF+PROCNT	;NEXT RECORD NUMBER
	SKIPN	T1,LASBUF	;SKIP IF WE'RE DONE MAPPING IN STUFF
	JRST	OUTOK1		;NOT DONE MAPPING YET.
	CAMN	T1,BUF		;HAVE WE JUST XFERRED THE LAST BUFFER?
	JRST	SAVDON		;YES.
	JRST	NOMAPR		;NO, JUST OUTPUT REMAINING ONES TO TAPE

OUTOK1:	MOVE	T1,STRMXP	;GET PAGE PER STRUCTURE
	SUB	T1,DP		;GET PAGES LEFT TO GO
	CAILE	T1,MAXRCP	;SKIP IF THIS IS LAST RECORD
	JRST	COPROK		;NOT LAST RECORD
	MOVEM	BUF,LASBUF	;FLAG THAT THIS IS LAST BUFFER TO COPY
				;(MAYBE 1 PAST LAST IF COUNT IS ZERO)
	MOVE	CNT,T1		;GET LAST PAGE COUNT IN CNT
COPROK:	PUSHJ	P,MAPRD
	  POPJ	P,		;SOMETHING WENT WRONG
	ADD	DP,CNT		;NEXT DISK ADDRESS TO DO.
NOMAPR:	ADDI	BUF,MAXREC-1
	AOBJN	BUF,COPLUP
	MOVE	BUF,PTRBUF	;WRAP AROUND
	JRST	COPLUP

SAVDON:	MTAPE	TAPE,.MTEOF		;WRITE EOT
	GETSTS	TAPE,S		;MAKE SURE ALL IS OK
	TRNE	S,IOEMSK	;MAKE SURE NO PROBLEMS.
	ERRPOP	<CANNOT WRITE LOGICAL EOT>
	MSG	<ASP SAVE OF >
XXXDON:	MOVE	T1,STRNAM
	PUSHJ	P,SIXOUT
	MSG	< COMPLETED ON >
	PUSHJ	P,CURDAT
	  POPJ	P,		;DATE NOT YET RECEIVED (SHOULD NEVER HAPPEN, CHECKED ABOVE)
	MSG	,CRLF
	JRST	CPOPJ1

DAYTIM:	PUSHJ	P,CURDAT
	MSG	,CRLF
	JRST	CPOPJ1

CURDAT:	MOVE	T1,[.CNDAT,,.GTCNF]
	GETTAB	T1,
	  ERRPOP	<CAN'T GETTAB DATE>
	SKIPGE	T1		;MAKE SURE SYSTEM KNOWS
	ERRPOP	<DATE NOT YET RECEIVED, ABORTING>
	MOVE	T2,[.CNTIM,,.GTCNF]
	GETTAB	T2,
	  ERRPOP <CAN'T GETTAB TIME>
	AOS	(P)		;GIVE SKIP RETURN NOW
	PJRST	PRTDAT		;AND PRINT DATE, CALER DOES CRLF


MAXOEC:	MOVE	T1,OECMAX	;PRINT OLD VALUE
	MSG	<OLD OECMAX WAS >
	PUSHJ	P,DECOUT
	MSG	<>,CRLF
	PUSHJ	P,DECIN		;GET NUMBER
	  JRST	[MSG <SETTING TO DEFAULT VALUE >
		  MOVEI T1,STDOEC
		   PUSHJ P,DECOUT
		 MOVEI T1,STDOEC
		 JRST .+1]
	MOVEM	T1,OECMAX
	JRST	CPOPJ1

SETSRC:	MOVE	T1,SRCLEN	;GET OLD VALUE
	MSG	<OLD SRCLEN WAS >
	PUSHJ	P,DECOUT
	MSG	<>,CRLF
	PUSHJ	P,DECIN		;GET NUMBER TYPED
	  JRST	[MSG <SETTING TO DEFAULT VALUE >
		 MOVEI T1,STDSRC
		 PUSHJ P,DECOUT
		 MOVEI T1,STDSRC
		 JRST .+1]
	MOVEM	T1,SRCLEN
	JRST	CPOPJ1

SETRES:	SETZM	RESTDP		;CLEAR OUT PREVIOUS ONE
	SETZM	RESTTP
	PUSHJ	P,GETTAP	;OPEN UP TAPE UNIT
	  JRST	NOTAPO		;NOT AVAILABLE, MSG ALREADY PRINTED.
	PUSHJ	P,CHECK0	;
	  POPJ	P,		;NO GOOD
	MOVE	T1,HEDBUF+HEDTPN	;GET TAPE NUMBER
	ADDI	T1,1		;NEXT TAPE NUMBER IS ONE TO RESTART WITH
	MOVEM	T1,RESTTP	;SAVE IT
	MOVE	T1,HEDBUF+HEDDAT
	MOVEM	T1,RESDAT
	MOVE	T1,HEDBUF+HEDTIM
	MOVEM	T1,RESTIM	;DATE AND TIME OF THIS SET.
	MSG	<TYPE IN UNIT NUMBER WITHIN STRUCTURE WHICH PRINTED AT START OF
TAPE TO RESTART:>

	PUSHJ	P,BRKEAT
	PUSHJ	P,OCTIN		;GET OCTAL UNIT WITHIN STRUCTURE
	  ERRPOP	<BAD UNIT NUMBER TYPED>
	CAML	T1,STRNMU		;MAKE SURE ARG IS WITHIN RANGE
	ERRPOP	<UNIT WITHIN STRUCTURE NOT WITHIN LEGAL RANGE>
	MOVE	DP,T1		;SAVE IN SAFE PLACE
	MSG	<TYPE PAGE WITHIN THE UNIT WHICH TYPE OUT AFTER SAVE HAD STARTED ON TAPE TO RESTART:>
	PUSHJ	P,BRKEAT
	PUSHJ	P,OCTIN		;GET NEXT NUMBER
	  ERRPOP	<TYPE UNIT, COMMA, AND PAGE NUMBER IN OCTAL FOR THIS COMMAND>
	MOVE	T2,STRMXP	;GET STRMXP
	IDIV	T2,STRNMU	;GET PAGES PER UNIT
	CAML	T1,T2		;MAKE SURE ITS IN RANGE
	ERRPOP	<PAGE NUMBER NOT WITHIN RANGE OF THE UNIT>
	IMUL	DP,T2		;GET NUMBER OF PAGES THAT GETS US PAST PREVIOUS UNITS
	ADDB	DP,T1		;ADD IN PAGE WITHIN UNIT
	IDIVI	T1,MAXRCP	;MAKE SURE ITS ON A RECORD BOUNDARY
	IMULI	T1,MAXRCP	;TRUNCATE
	CAME	DP,T1		;HAVE TO BE SAME
	ERRPOP	<THAT IS NOT A LEGAL STARTING PAGE FOR AN ASP RECORD>
	MOVEM	DP,RESTDP	;SAVE AND
	MTAPE	TAPE,.MTREW	;REWIND THE GOOD TAPE
	MSG	<NOW MOUNT THE TAPE YOU WISH TO CONTINUE ON.>,CRLF
	JRST	CPOPJ1		;RETURN.

PRTRES:	MSG	<NEXT SAVE, RESTORE, OR VERIFY WILL BE STARTED ON TAPE >
	SKIPN	T1,RESTTP
	MOVEI	T1,1		;DEFAULT IS TAPE 1
	PUSHJ	P,DECOUT
	MSG	< ON >
	MOVE	T4,RESTDP
	PUSHJ	P,PRTDP
	MOVE	T1,RESDAT
	MOVE	T2,RESTIM
	JUMPE	T1,CPOPJ1		;IF ZERO, NO DATE
	MSG	<IDENTIFYING DATE FOR THIS ASP TAPE SET IS >
	PUSHJ	P,PRTDAT
	MSG	<>,CRLF
	JRST	CPOPJ1

SUBTTL RESTORE

VERIFY:	SETZM	VERBFF		;FORCE MAPIT TO RESET BUFFERS
	AOSA	VERFLG		;FLAG THAT WE ARE VERIFYING.
RESTOR:	SETZM	VERFLG		;NOT VERIFYING.
	PUSHJ	P,GETTAP	;GET TAPE DRIVE SETUP
	  JRST	NOTAPO		;NO DICE.
	PUSHJ	P,ALONE		;I WANT TO BE ALONE
	  POPJ	P,		;SORRY, WE'RE NOT ALONE
;OK, NOW ALL STUFF IN FILE SYSTEM IS WRITTEN OUT TO DISK.

	SETZ	DP,		;CLEAR OUT RESTART AND GET IT IF NON-ZERO
	EXCH	DP,RESTDP	;GET WHERE TO START RESTORING.
	MOVE	T1,DP		;GET DP
	IDIVI	T1,MAXRCP	;GET FIRST SEQUENCE NUMBER TO LOOK FOR
	MOVEM	T1,CNTPRO	;AND STORE IT
	SETZM	LASBUF		;CLEAR LAST BUFFER FLAG
	SETZ	T1,
	EXCH	T1,RESTTP
	SKIPN	T1
	MOVEI	T1,1
	MOVEM	T1,TAPNUM
	PUSHJ	P,CHKFIR	;READ IN FIRST HEADER AND CHECK IT OUT FOR RESTORING
	  POPJ	P,		;IT DIDN'T CHECK OUT SOMEHOW
	PUSHJ	P,RESVER	;SAY RESTORING OR VERIFYING
	MOVE	T4,DP		;THIS IS WHERE TO SAY WE ARE RESTORING FROM
	PUSHJ	P,PRTDP		;SAY WHERE WE ARE RESTORING FROM PROCNT

	MOVSI	IOW,-MAXREC
	MOVE	IOW+1,[IOWD PROLEN,PROBUF] ;PROLOGUE IOWD
	SETZ	IOW+2,		;END OF IOWD LIST

;NOW MAP IN THE FIRST BUFFERS

;HERE TO RESTART A RESTORE AFTER A TAPE INPUT ERROR.

RESRES:	MOVE	BUF,PTRBUF	;RESET BUFFER POINTERS.
	MOVEI	CNT,MAXRCP*BUFNUM
	PUSHJ	P,MAPWT		;WRITE MAP THEM IN
	  POPJ	P,		;SOMETHING WENT WRONG
	ADDI	DP,MAXRCP*BUFNUM ;THIS WILL BE NEXT DP TO MAP.
	MOVEI	CNT,MAXRCP	;DO IT THIS WAY

RESLUP:	HRR	IOW,BUF		;GET CURRENT BUFFER
	CAME	BUF,LASBUF	;LAST BUFFER? IF SO, NEED DIFFERENT COUNT
	JRST	RESLU1		;NOT LAST.
	MOVN	T1,CNT		;GET -VE COUNT
	ASH	T1,^D9		;GET COUNT IN -VE WORDS
	HRL	IOW,T1		;PUT INTO IOW
RESLU1:	TRNE	S,IOTEND	;DID WE SEE PHYSICAL EOT LAST RECORD?
	JRST	NXTRS0		;YES, MAKE SURE LOGICAL EOT IS NEXT.
	IN	TAPE,IOW
	  JRST	INOK		;OK
	GETSTS	TAPE,S		;GET STATUS
	TRNE	S,IOEMSK	;MAKE SURE NO INPUT ERRORS
	JRST	TINERR		;SOME FATAL ERROR.
	TRNE	S,IODEND	;END OF FILE?
	JRST	NXTRES		;YES, GET NEXT TAPE.
	TRNN	S,IOTEND	;END OF TAPE?
	ERRPOP	<UNKNOWN TAPE INPUT ERROR CONDITION>
	JRST	INOK		;JUST PHYSICAL EOT, HANDLE IT IF HAVE TO READ ANOTHER TAPE.

NXTRS0:	IN	TAPE,[IOWD 1,PROBUF
			0]
	ERRPOP	<LOGICAL EOT MISSING AT PHYSICAL END OF TAPE>
	GETSTS	TAPE,S		;GET TAPE STATUS
	TRNE	S,IOEMSK	;MAKE SURE NO ERRORS
	JRST	TPINER		;INPUT ERRORS, GO PRINT
	TRNN	S,IODEND	;OK, MAKE SURE LOGICAL EOT
	ERRPOP	<UNKNOWN TAPE INPUT ERROR CONDITION>
NXTRES:	AOS	TAPNUM		;NEXT TAPE NUMBER
NXTRS1:	MSG	<NEXT TAPE UNIT:>
	MOVEI	CH,-1		;FORCE READ OF NEW LINE
	PUSHJ	P,GETTAP	;GET NEXT TAPE UNIT NAME
	  JRST	NXTRS1		;KEEP TRYING
	PUSHJ	P,CHKHED	;REWIND TAPE, READ IN AND CHECK THE HEADER
	  JRST	NXTRS1		;HEADER NO GOOD, ASK FOR ANOTHER TAPE UNIT
	PUSHJ	P,RESVER
	MOVE	T4,PROBUF+PROCNT ;LAST RECORD RESTORED
	ADDI	T4,1		;THIS IS WHAT WE WILL RESTORE NEXT
	IMULI	T4,MAXRCP	;TURN INTO PAGE NUMBER
	PUSHJ	P,PRTDP		;PRINT DISK ADDRESS FROM PROCNT
	JRST	RESLUP		;THE RESTORE.


;HERE ON INPUT ERROR FROM TAPE. BACKUP TO FIND LAST RECORD RESTORED,
; THEN SPACE FORWARD TO NEXT RECORD AND RESTART THE RESTORE,
; AND TELL OPERATOR WHICH DISK PAGES DIDN'T MAKE IT OFF THE TAPE.

TINERR:	TRNE	S,IODERR
	MSG	<DEVICE READ ERROR >
	TRNE	S,IODTER
	MSG	<DATA READ ERROR >
TBDERR:	MSG	<, ATTEMPTING RECOVERY>,CRLF
TINER1:	SETO	T4,		;SEARCH BACKWARDS
	PUSHJ	P,RESYNC	;FOR THE RECORD
	  JRST	[MSG <CANNOT FIND LAST GOOD RECORD, SEARCHING FOR NEXT GOOD RECORD>,CRLF
		  JRST TINER2]
	CAML	T4,CNTPRO	;MAKE SURE ITS LESS THAN ONE WERE WERE TRYING TO RESTORE
	JRST	TINER1		;NOT, SEARCH BACKWARDS SOME MORE
TINCSB:	MSG	<LAST PAGE READ SUCCESSFULLY WAS >
	IMULI	T4,MAXRCP	;FIRST PAGE IN LAST REC DONE
	ADDI	T4,MAXRCP-1	;LAST PAGE DONE
	PUSHJ	P,PRTDP
	MSG	<>,CRLF
TINER2:	SETZ	T4,		;NOW SEARCH FORWARD FOR A GOOD RECORD
	PUSHJ	P,RESYNC	;TRY IT
	JRST	TINNXT		;SORRY, TRY ANOTHER TAPE.
	CAMG	T4,CNTPRO	;DON'T MESS WITH ONE WE COULDN'T RESTORE
	JRST	TINER2		;KEEP GOING
	MOVEM	T4,CNTPRO	;OK, THIS IS NEXT RECORD WE WILL BE RESTORING.
	IMULI	T4,MAXRCP	;TURN INTO PAGE NUMBER FOR PRTDP
	MOVE	DP,T4		;GET INTO DP FOR MAPPING ROUTINE
	PUSHJ	P,RESBSR	;NOW BACKSPACE BEHIND PROLOG RECORD
	  ERRPOP <CANNOT BACKSPACE PAST NEXT GOOD RECORD IN INPUT ERROR RECOVERY>
	PUSHJ	P,RESBSR	;NOW SPACE BACK OVER THE DATA RECORD
	  ERRPOP <CANNOT BACKSPACE PAST NEXT GOOD DATA RECORD>
	MSG	<CONTINUING AT DISK PAGE >
	PUSHJ	P,PRTDP		;PRINT OUT
	MSG	<>,CRLF
	SKIPN	VERFLG		;DONT BOTHER US ABOUT VERIFIES.
	MSG	<NOTIFY OPERATING SYSTEMS OF THE MISSING PAGES. SAVE THIS OUTPUT.>,CRLF
	JRST	RESRES		;AND GO REDO THE BUFFERS, ETC.

;HERE IF NO HOPE, PRINT OUT MESSAGE.

TINNXT:	MSG	<CANNOT READ THE REMAINDER OF THIS TAPE. IF THERE IS
ANOTHER TAPE,>,CRLF
	MSG	<PLEASE MOUNT IT AND RESTORE WILL BE CONTINUED FROM THERE.>,CRLF
	MSG	<IF THERE IS NO OTHER TAPE, ALL PAGES ON THE STRUCTURE AFTER THE LAST REPORTED ONE>,CRLF	
	MSG	<HAVE BEEN LOST.  IF TOO MANY PAGES HAVE BEEN LOST,, DO NOT BRING UP SYSTEM>,CRLF
	JRST	NXTRES		;TRY TO RESTORE FROM NEXT TAPE.

;HERE IF ALL IS OK

INOK:	MOVE	T1,PROBUF+PROCOD	;GET MAGIC CODE
	CAME	T1,FIRTIM		;SEE IF ITS CORRECT
	JRST	[MSG <BAD DATA RECORD PROLOGUE CODE >
		 JRST TBDERR] ;TRY TO RECOVER
	MOVE	T1,PROBUF+PROCNT	;GET RECORD NUMBER
	CAMN	T1,CNTPRO		;OK?
	JRST	INOK0			;Yes
	MSG	(<BAD RECORD SEQUENCE NUMBER FOUND IN DATA RECORD >,CRLF)
	MSG	<FOUND >
	PUSHJ	P,OCTOUT		;Type out T1 (PROBUF+PROCNT)
	MSG	<, EXPECTING >
	MOVE	T1,CNTPRO
	PUSHJ	P,OCTOUT
	JRST	TBDERR			;TRY TO RECOVER

INOK0:	AOS	CNTPRO			;GO TO NEXT ONE.
	SKIPN	T1,LASBUF	;IF THROUGH MAPPING STUF,
	JRST	INOK1		;NOT THRU
	CAME	T1,BUF		;DID WE JUST INPUT TO THE LAST BUFFER?
	JRST	NOMAPW		;OK,SKIP AROUND MAPPING.
	IN	TAPE,[IOWD 1,PROBUF
			0]	;MAKE SURE WE SEE EOT
NOEOT:	ERRPOP	<LOGICAL EOT EXPECTED AND NOT SEEN>
	GETSTS	TAPE,S
	TRNE	S,IODEND	;IF END OF FILE,
	JRST	RESDON		;THEN END OF RESTORE.
	TRNN	S,IOEMSK	;ANY IO ERROR? IF SO, PRINT.
	ERRPOP	<EXPECTING LOGICAL EOT BUT RECEIVED >
	JRST	TPINER		;SAY WHAT WENT WRONG.
INOK1:	MOVE	T1,STRMXP	;GET MAX PAGE NUMBER ON THIS STR
	SUB	T1,DP		;T1 GETS HOW MANY LEFT
	CAILE	T1,MAXRCP	;SKIP IF THIS IS LAST RECORD
	JRST	INOK2		;NO, JUST MAP IN NEXT BUFFER
	MOVEM	BUF,LASBUF	;THIS WILL BE LAST BUFFER WE RESTORE TO
	MOVE	CNT,T1
INOK2:	PUSHJ	P,MAPWT		;GET NEXT BUFFER IN
	  POPJ	P,		;NO GOOD
	ADD	DP,CNT		;ADVANCE TO NEXT ADDRESS TO MAP
NOMAPW:	ADDI	BUF,MAXREC-1	;ADVANCE BUFFER ADDRESS
	AOBJN	BUF,RESLUP	;AND INPUT TO NEXT BUFFER
	MOVE	BUF,PTRBUF	;WRAP AROUND
	JRST	RESLUP		;AND LOOP

;HERE IF FIND END OF FILE. MAKE SURE EVERYTHING HAS BEEN RESTORED

RESDON:	CAME	BUF,LASBUF	;MAKE SURE WE JUST RESTORED LAST BUFFER
	ERRPOP	<NOT ENOUGH DATA ON TAPES TO RESTORE ENTIRE STRUCTURE>
	MSG	<ASP >
	PUSHJ	P,RESVER
	MSG	<TO >
	PJRST	XXXDON		;PRINT COMPLETED ON AND GIVE SKIP RETURN
				;WHAT ABOUT IF A FEW PAGES MISSING FROM
				;THE LAST RECORD?

;HERE WITH CHANNEL STATUS IN S TO PRINT MESSAGE AND POPJ

TPINER:	MSG <FATAL INPUT TAPE >
	JRST	TPXXER		;COMMON PLACE
TPOUER:	MSG	<FATAL OUTPUT TAPE >
TPXXER:	TRNE S,IODERR
	MSG <DEVICE >
	TRNE S,IODTER
	MSG <DATA >
	TRNE	S,IOIMPM	;WRITE LOCK?
	MSG	<WRITE LOCK >
	ERRPOP	<ERROR>

ALONE:	SKIPE	VERFLG		;IF VERIFYING,
	JRST	CPOPJ1		;THEN OK.
	ONEJOB			;SEE IF OK TO RESTORE
	  ERRPOP <NOT ONLY JOB OR SYSTEM NOT SUPER SHUT, ABORTED>
	DSKCLR	0,		;OK, TRY TO DUMP OUT PCBS
	  JRST	.-1		;PCB IO IN PROGRESS, TRY AGAIN
	ERRPOP <CANNOT PERFORM DSKCLR, ABORTING>

	JRST	CPOPJ1		;OK, FINISHED.

COMMENT \RESYNC - ROUTINE TO FIND A GOOD RECORD ON TAPE
ENTER WITH T4/0 IF SEARCH FORWARD, 1 IF SEARCH BACKWARD
RETURNS CPOPJ IF CANNOT FIND ANY GOOD RECORDS
RETURNS CPOPJ1 WITH RECORD PAIR NUMBER IN T4 IF FIND A GOOD RECORD.

\

RESYNC:	MOVN	T3,SRCLEN	;HOW MANY PAIRS TO SEARCH
	HRLZS	T3		;GET -COUNT,,0
	SETSTS	TAPE,@OPNTAP	;CLEAR ANY ERROR STATUS

RESYN1:	JUMPE	T4,RESYN2	;GO IF GOING FORWARD.
	PUSHJ	P,RESBSR	;TRY IT
	  POPJ	P,		;DIDNT WORK.
RESYN2:	IN	TAPE,[IOWD PROLEN,HEDBF1
		      0]	;READ DATA IN
	  JRST	RESYN3		;OK, SEE WHAT WE'VE GOT FOR DATA
	GETSTS	TAPE,S		;GET IO STATUS
	TRNN	S,IOTEND+IODEND	;BEG OR END OF TAPE?
	JRST	RESYN4		;NO, SOME OTHER ERROR, JUST IGNORE
	JRST	RESERR		;PRINT OUT AND CPOPJ RETURN.

RESYN3:	MOVE	T1,HEDBF1+PROCOD ;IS IT A PROLOGUE RECORD?
	CAME	T1,FIRTIM
	JRST	RESYN4		;NO, KEEP GOING
	MOVE	T4,HEDBF1+PROCNT	;GET NUMBER AND
	JRST	CPOPJ1		;RETURN, POSITIONED AFTER THE RECORD FOUND.
RESYN4:	TRNE	S,IOEMSK	;ANY ERRORS?
	SETSTS	TAPE,@OPNTAP	;YES, CLEAR THE STATUS SO CAN DO A NEW INPUT.
	JUMPE	T4,RESYN5	;GO IF NOT BACKAPCE
	PUSHJ	P,RESBSR	;TRY TO BACKSPACE
	  POPJ	P,		;NO GO
RESYN5:	AOBJN	T3,RESYN1	;GO FOR MORE
	ERRPOP	<CANNOT FIND A GOOD PROLOGUE RECORD IN RESYNC>

;ROUTINE TO TRY TO BACKSPACE A RECORD.

RESBSR:	MTAPE	TAPE,.MTBSR	;THEN BACKSPACE PAST REC WE JUST READ.
	GETSTS	TAPE,S		;GET STATUS AFTER BACKSPACE.
	TRNN	S,IOEMSK+IOTEND+IODEND ;ANY PROBLEMS?
	JRST	CPOPJ1		;OK.

RESERR:	TRNE	S,IOTEND
	ERRPOP	<PHYSICAL END OR BEGINNING OF TAPE DURING RESYNC>
	TRNE	S,IODEND
	ERRPOP	<LOGICAL END OF TAPE ENCOUNTERED DURING RESYNC>
	ERRPOP	<UNKNOWN ERROR IN RESYNC>

;ROUTINE TO MAP A NUMBER OF PAGES INTO THE BUFFER AREA.
; BUF/ADDR-1 OF PLACE TO START MAPPING
; CNT/NUMBER OF PAGES TO MAP.
; DP/DISK ADDRESS TO START MAPPING.

MAPRD:	MOVSI	T4,2000(CNT)	;GET WORD FOR MAPPING
	JRST	MAPIT
MAPWT:	MOVSI	T4,6000(CNT)	;FOR WRITING (COPY ON WRITE FOR TESTING)
MAPIT:	SKIPE	VERFLG	;IF VERIFY,
	JRST	MAPVER	;DO DIFFERENT THING.
	MOVEI	T1,1(BUF)	;GET ADDR OF BUFFER
	LSH	T1,-^D9		;PAGE NUMBER
	HRL	T1,CNT		;COUNT,,FIRST PAGE TO REMOVE
	VCLEAR	T1,		;REMOVE THE PAGE
	  JRST	[HRRZS T1		;JUST CODE
		 CAIE T1,4	;MAKE SURE JUST BECAUSE PAGE WASN'T THERE
		 ERRPOP <UNEXPECTED VCLEAR ERROR CODE>
		  ]
	MOVE	T3,[.CHSMP,,DISK] ;THE FUNCTION
	MOVE	T2,DP		;GET DP TO MAP
	HLL	T1,T4		;GET PROPER BITS+COUNT,,PAGE IN T1
PATMAP:
IFE FTDEBG,<CHANIO T3,T1>
IFN FTDEBG,<VCREAT T1,>
	  ERRPOP <CAN'T SUPER MAP>
PATMP1:
IFN FTDEBG,<TLNN T4,4000	;IF READING,
	JRST	[MOVE T2,T1
		 TLO T2,4000
		 VPROT T2,	;READ ENABLE
		  ERRPOP <VPROT FAILED>
		 MOVEM DP,1(BUF) ;SET DP IN THIS PAGE
		 TLZ T2,4000
		 VPROT T2,
		  ERRPOP <VPROT FAILED>
		 JRST .+1]>;END IFN FTDEBG
	MOVE	T2,[.WSRNG,,T1]	;PUT THEM INTO WS
	WSCTL	T2,
	  ERRPOP <CAN'T PUT PAGES INTO WORKING SET>
	PREREF	T1,		;PREREF THE FIRST PAGE, REST WILL COME IN WITH IT.
	  ERRPOP <CAN'T PREREF PAGE>
	HRLI	T1,2000(CNT)	;NOW SET IGNORE ERRORS
	PERSET	T1,
	  ERRPOP <CANNOT SET IGNORE ERROR FOR PAGE BUFFER>
	JRST	CPOPJ1		;GOOD RETURN

MAPVER:	SKIPE	VERBFF	;ALREADY DONE?
	JRST	CPOPJ1
	SETOM	VERBFF
	MOVEI	T1,1(BUF)
	LSH	T1,-^D9
	HRL	T1,CNT
	MOVE	T2,T1
	VCLEAR	T1,
	  ERRPOP	<CANNOT VCLEAR PAGES IN MAPVER>
	HLL	T2,T4
	VCREAT	T2,
	  ERRPOP	<CANNOT VCREAT IN MAPVER>
	JRST	CPOPJ1

SUBTTL HEADER STUFF

COMMENT #THE FIRST RECORD ON A ASP TAPE CONTAINS THE FOLLOWING
INFORMATION

SIZE OF RECORD
CODE NAME
VERSION OF ASP
TAPE NUMBER
SYSTEM NAME
DATE ASP STARTED
TIME ASP STARTED (GMT)
STRUCTURE NAME
FIRST DISK PAGE ADDRESS ON TAPE

#


INIHED:	MOVEI	T1,SIZHED
	MOVEM	T1,HEDBUF+HEDSIZ
	MOVE	T1,CODNAM
	MOVEM	T1,HEDBUF+HEDNAM
	MOVEI	T1,COPVER
	MOVEM	T1,HEDBUF+HEDVER
	MOVE	T1,TAPNUM	;CURRENT TAPE NUMBER
	MOVEM	T1,HEDBUF+HEDTPN	;STORE IT
	MOVE	T1,STRNMU	;GET NUMBER OF UNITS
	MOVEM	T1,HEDBUF+HEDNMU
	MOVE	T1,STRHID	;HOME BLOCK ID OF STR
	MOVEM	T1,HEDBUF+HEDHID
	MOVE	T1,STRMXP	;GET STR SIZE
	MOVEM	T1,HEDBUF+HEDMXP ;SET IN HEADER
	MOVSI	T2,-SYSNSZ	;AOBJN POINTER
SYNLUP:	MOVEI	T1,.GTCNF	;TABLE NUMBER
	HRL	T1,T2		;GET WORD NUMBER
	GETTAB	T1,		;GET THE NAME
	  ERRPOP	<CANNOT GET SYSTEM NAME>
	MOVEM	T1,HEDBUF+HEDSYN(T2)	;STORE INTO HEADER
	AOBJN	T2,SYNLUP
	SETZ	T1,		;GET POSSIBLE RESTART DATE
	EXCH	T1,RESDAT	;AND CLEAR
	JUMPN	T1,INISRD	;SET RESTART DATE
	MOVE	T1,[.CNDAT,,.GTCNF]
	GETTAB	T1,
	  ERRPOP <CANNOT GET DATE>
	SKIPGE	T1		;MAKE SURE SYSTEM HAS A DATE
	ERRPOP	<DATE NOT YET RECEIVED, SAVE ABORTED>
INISRD:	MOVEM	T1,HEDBUF+HEDDAT
	SETZ	T1,		;GET POSSIBLE RESTART TIME
	EXCH	T1,RESTIM
	JUMPN	T1,INISRT	;SET RESTART TIME
	MOVE	T1,[.CNTIM,,.GTCNF]
	GETTAB	T1,
	  ERRPOP <CANNOT GETTAB TIME>
INISRT:	MOVEM	T1,HEDBUF+HEDTIM
	MOVEM	T1,FIRTIM	;ALSO SAVE HERE TO WRITE IN PROLOG RECORDS.
	MOVE	T1,STRNAM	;GET NAME OF STR WE'RE DOING
	MOVEM	T1,HEDBUF+HEDSTR
	JRST	CPOPJ1		;AND GIVE GOOD RETURN

WRTHED:	OUT	TAPE,[IOWD SIZHED,HEDBUF
			0]
	  JRST	WRTHD1		;GO MAKE SURE IT GOT OUT
	MSG	<CAN'T WRITE HEADER RECORD: >
	GETSTS	TAPE,S		;GET STATUS IN S FOR PRINTING
	JRST	TPOUER
WRTHD1:	MTAPE	TAPE,.MTREW	;REWIND NOW
	IN	TAPE,[IOWD SIZHED,HEDBF1
		      0] ;AND SEE IF DATA GOT OUT
	  JRST	WRTHD2		;OK, GO CHECK DATA
	GETSTS	TAPE,S		;GET STATUS
	MSG	<CAN'T READ HEADER RECORD JUST WRITTEN: >
	JRST	TPINER

WRTHD2:	MOVSI	T1,-SIZHED
WRTHD3:	MOVE	T2,HEDBUF(T1)
	CAMN	T2,HEDBF1(T1)
	AOBJN	T1,WRTHD3
	JUMPGE	T1,CPOPJ1
	ERRPOP	<READ BACK CHECK OF HEADER RECORD FAILED>

;PRINT OUT A HEADER, ADDRESS OF BLOCK IN T4

PRTHED:	MSG	<ASP VERSION >
	MOVE	T1,HEDVER(T4)
	PUSHJ	P,OCTOUT
	MSG	,CRLF
	MSG	<UNIT >
	MOVE	T1,OPNTNM	;GET TAPE  NAME
	PUSHJ	P,SIXOUT
	MSG	<  AT DENSITY >
	PUSHJ	P,CURDEN
	MSG	<TAPE NUMBER >
	MOVE	T1,HEDTPN(T4)
	PUSHJ	P,DECOUT
	MSG	< ON >
	MOVE	T1,HEDDAT(T4)
	MOVE	T2,HEDTIM(T4)
	PUSH	P,T4
	PUSHJ	P,PRTDAT
	POP	P,T4
	MSG	<>,CRLF
	OUTSTR	HEDSYN(T4)
	MSG	< STRUCTURE >
	MOVE	T1,HEDSTR(T4)
	PUSHJ	P,SIXOUT
	OUTCHI	"("
	MOVE	T1,HEDHID(T4)	;ID FOR STRUCURE
	PUSHJ	P,SIXOUT
	OUTCHI	")"
	MSG	,CRLF
	MSG	,CRLF
	POPJ	P,



;ROUTINE TO PRINT DISK UNIT NUMBER AND PAGE FROM T4

PRTDP:	MOVE	T1,STRNAM	;GET STR NAME
	PUSHJ	P,SIXOUT	;PRINT STR NAME
	MOVE	T1,T4		;GET PAGE NUMBER IN T1
	MOVE	T2,STRMXP	;GET SIZE OF STR
	IDIV	T2,STRNMU	;GET PAGES PER UNIT
	IDIV	T1,T2		;GET UNIT NO IN T1, PAGE IN T2
	PUSH	P,T2
	PUSHJ	P,OCTOUT	;PRINT "DSKB0", ETC
	MSG	<, PAGE >
	POP	P,T1		;GET INTO T1
	PUSHJ	P,OCTOUT	;PRINT IT
	MSG	< (OCTAL)>,CRLF
	MSG	,CRLF
	POPJ	P,		;AND RETURN.

RESVER:	SKIPE	VERFLG
	JRST	[MSG <VERIFYING >
		 POPJ P,]
	MSG	<RESTORING >
	POPJ	P,

;CHKFIR - CHECK FIRST HEADER.

CHKFIR:	PUSHJ	P,CHECK0		;READ IT IN AND MAKE SURE ITS REASONABLE
	  POPJ	P,		;NO
	MOVE	T1,HEDBUF+HEDDAT
	MOVEM	T1,FIRDAT
	MOVE	T1,HEDBUF+HEDTIM
	MOVEM	T1,FIRTIM	;SETUP FIRST DATE AND TIME FOR LATER TAPES
	JRST	CHKHD0		;AND FINISH UP.

;CHKHED - CHECK HEADER FOR TAPE OUT. TAPE NUMBER MUST BE INCREMENTED BEFORE CALLING

CHKHED:	PUSHJ	P,CHECK0	;REWIND TAPE, READ IN HEADER AND CHECK GENERALLY
	  POPJ	P,		;NO GOOD.
CHKHD0:	MOVE	T1,TAPNUM	;GET TAPE NUMBER
	CAME	T1,HEDBUF+HEDTPN	;GET TAPE NUMBER
	JRST	[MSG <WRONG TAPE NUMBER MOUNTED, PLEASE MOUNT TAPE NUMBER >
		 PUSHJ P,DECOUT
		 ERRPOP ()]
	MOVE	T1,HEDBUF+HEDDAT ;DATE AND TIME HAD BETTER MATCH
	CAME	T1,FIRDAT
	ERRPOP	<DATE ON THIS TAPE DOESN'T MATCH PREVIOUS TAPE OR TAPES>
	MOVE	T1,HEDBUF+HEDTIM
	CAME	T1,FIRTIM
	ERRPOP	<TIME ON THIS TAPE DOESN'T MATCH PREVIOUS TAPE OR TAPES>
	SKIPE	VERFLG		;IF ONLY VERIFYING, DON'T CHECK SYSTEM
				;SPECIFIC STUFF
	JRST	CPOPJ1
	MOVE	T1,HEDBUF+HEDSTR ;MAKE SURE SAME STR
	CAME	T1,STRNAM
	ERRPOP	<TAPE IS NOT FOR SAME STRUCTURE BEING RESTORED>
	MOVE	T1,HEDBUF+HEDHID ;GET UNIT ID
	CAME	T1,STRHID	;FOR SAME HID?
	ERRPOP	<TAPE NOT FOR SAME SYSTEM-PACK SET>
	MOVE	T1,HEDBUF+HEDMXP ;GET SIZE OF STRUCUTRE
	CAME	T1,STRMXP	;SAME SIZE?
	ERRPOP	<BAD STRUCURE SIZE>
	MOVE	T1,HEDBUF+HEDNMU ;GET NUMBER OF UNITS IN STR
	CAME	T1,STRNMU	;BETTER BE THE SAME
	ERRPOP	<NUMBER OF UNITS IN STR ON TAPE DOESN'T MATCH NUMBER OF UNITS IN STR TO BE RESTORED>
	JRST	CPOPJ1

;ROUTINE NOTHED - MAKE SURE TAPE CURRENTLY MOUNTED DOES NOT
; BELONG TO THE SET WE ARE CURRENTLY WRITING.
; CALLED AFTER INIHED AND BEFORE WRTHED.
; TAPE UNIT IS OPEN AND READY TO BE WRITTEN ON.
; TAPE IS AT LOAD POINT, SO NOTHED WILL PUT IT BACK THERE BEFORE EXITING.
; RETURNS SKIP IF OK TO OVERWRITE TAPE, NON-SKIP IF NOT.
; ASKS OPERATOR WHETHER OR NOT TO OVERWRITE TAPE IF HEADER LOOKS LIKE
; ITS FROM THIS SET.

NOTHED:	MTAPE	TAPE,.MTREW		;REWIND SO CAN SEE THE HEADER.
	SETZM	HEDBF1
	MOVE	T1,[HEDBF1,,HEDBF1+1]
	BLT	T1,HEDBF1+SIZHED-1	;CLEAR OUT AREA
	IN	TAPE,[IOWD SIZHED,HEDBF1
			 0]
	  JRST	NOTHD1		;OK
	SETSTS	TAPE,@OPNTAP	;CLEAR STATUS AND
	JRST	NOTREW		;IF ERROR, ASSUME BAD DATA ON TAPE, LET WRITE ERROR RECOVERY
				; WORRY IF ITS THE TAPE. BUT NO HEADER IS ON HERE.

NOTHD1:	MOVE	T1,HEDBF1+HEDNAM ;IS NAME OK?
	CAME	T1,CODNAM	;WELL?
	JRST	NOTREW		;NO, NOT AN ASP TAPE, OK TO WRITE ON IT.
	MOVE	T1,HEDBF1+HEDSIZ	;RIGHT SIZE?
	CAIE	T1,SIZHED
	JRST	NOTREW		;OK

;MACRO TO SAVE OURSELVES FROM TYPING AND TYPOS

DEFINE HEDCMP(THING)<
IRP THING,<
	MOVE	T1,HEDBF1+HED'THING
	CAME	T1,HEDBUF+HED'THING
	JRST	NOTREW		;;OK, DOESN'T COMPARE. DO REWIND AND RETURN.
>;END IRP THING
>;END HEDCMP MACRO

HEDCMP(<STR,HID,MXP,NMU,DAT,TIM>)

;HERE IF ALMOST EVERYTHING MATCHES. WE DON'T CHECK ASP VERSION
; OR SYSTEM NAME OR TAPE NUMBER, IF ITS THE SAME EXACT STRUCTURE AND
; TIME, ITS SUSPICIOUS ENOUGH. ASK OPERATOR IF HE WANTS TO CONTINUE.

	MSG	<YOU ARE ABOUT TO OVERWRITE AN ASP TAPE FROM THE SAME
SET AS YOU ARE CURRENTLY RECORDING:>,CRLF
	MOVEI	T4,HEDBF1	;TELL PRTHED WHERE ITS AT.
	PUSHJ	P,PRTHED
	MSG	,CRLF
	MSG	<DO YOU WISH TO CONTINUE? TYPE "I DO" FOLLOWED BY A RETURN IF YOU DO.>,CRLF
	MSG	<?>

DEFINE STRCMP(STRING),<
IRPC STRING,<
	PUSHJ	P,GTCHR
	CAIE	CH,"'STRING"
	PJRST	BRKEAT
>;END IRPC STRING
>;END STRCMP MACRO

STRCMP(I DO)
	PUSHJ	P,GTCHR
	CAIE	CH,12		;BETTER NOT BE ANYTHING PAS THIS
	JRST	BRKEAT		;IS, FORGET IT.
	
NOTREW:	MTAPE	TAPE,.MTREW		;REWIND TO GET BACK TO HEADER PLACE
	JRST	CPOPJ1


;PRINT DATE - DAYS SINCE JAN 1,1964 IN T1
; TIME IN JIFFIES SINCE MIDNITE (GMT) IN T2

PRTDAT:	MOVSI	T3,400020	;FROM GMT TO CURRENT USERS ZONE, DEC FORMAT
	MOVEI	T4,T1
	DATUUO	T4,
	  ERROR <DATUUO ERROR RETURN - SHOULD NEVER HAPPEN>
	PUSH	P,T2		;SAVE THE TIME
	IDIVI	T1,^D31		;GET DAY OF MONTH
	PUSH	P,T1		;SAVE T1 FROM GETTING SMASHED
	MOVEI	T1,1(T2)	;GET DAY NUMBER IN T1
	PUSHJ	P,DECOUT	;PRINT IT
	POP	P,T1		;GET # MONTHS IN T1
	IDIVI	T1,^D12		;GET MONTH IN T2
	MOVE	T2,MONTAB(T2)
	SETZ	T3,
	OUTSTR	T2
	MOVEI	T1,^D1964(T1)	;YEAR
	PUSHJ	P,DECOUT	;PRINT YEAR
	OUTCHI	" "		;SEPERATE DATE AND TIME
	POP	P,T1		;GET TIME BACK
	IDIVI	T1,^D60*^D60	;GET MINUTES
	PUSH	P,T2		;SAVE JIFFY REMAINDER
	IDIVI	T1,^D60		;GET HOUR IN T1, MINUTE IN T2
	PUSH	P,T2
	CAIGE	T1,^D10		;IF LESS THAN 10,
	OUTCHI	"0"		;PRINT A ZERO
	PUSHJ	P,DECOUT	;PRINT HH
	POP	P,T1
	CAIGE	T1,^D10
	OUTCHI	"0"
	PUSHJ	P,DECOUT	;AND MM
	POP	P,T1		;GET JIFFIES
	IDIVI	T1,^D60		;GET SECONDS IN T1
	MSG	<.>
	CAIGE	T1,^D10
	OUTCHI	"0"
	PUSHJ	P,DECOUT	;PRINT FRACTIONS OF A SECOND
	MSG	< (LOCAL TIME)>
	POPJ	P,

MONTAB:	ASCII /-JAN-/
	ASCII /-FEB-/
	ASCII /-MAR-/
	ASCII /-APR-/
	ASCII /-MAY-/
	ASCII /-JUN-/
	ASCII /-JUL-/
	ASCII /-AUG-/
	ASCII /-SEP-/
	ASCII /-OCT-/
	ASCII /-NOV-/
	ASCII /-DEC-/

HEDBUF:
	PHASE 0
HEDSIZ:!	0		;SIZE OF HEADER RECORD
HEDNAM:!	0		;MAGIC CODE
HEDVER:!	0		;VERSION OF ASP
HEDTPN:!	0		;TAPE NUMBER
HEDSYN:! BLOCK SYSNSZ		;SYSTEM NAME TAPE WAS RECORDED ON
HEDDAT:!	0		;DATE FIRST TAPE WAS STARTED (APPEARS ON ALL TAPES TO GROUPTHEM TOGETHER)
HEDTIM:!	0		;TIME FIRST TAPE WAS STARTED
HEDSTR:!	0		;STRUCTURE NAME
HEDMXP:!	0		;SIZE OF STRUCTURE
HEDHID:!	0		;XXYY IN SIXBIT - SYS NUMBER AND PACK SET ID
HEDNMU:!	0		;NUMBER OF UNITS IN STR
	DEPHASE
SIZHED==.-HEDBUF

HEDBF1:	BLOCK	SIZHED

;ROUTINE TO SET DENSITIES, POINTER TO PROPER DENSITY TABLE IN T4.

SETDEN:	PUSHJ	P,GETCTP	;GET CURRENT TAPE OR NOTHING
	  POPJ	P,		;NOTHING.
	PUSHJ	P,DECIN		;GET ANSWER IN T1
	  PJRST	PRTDEN		;NOTHING TYPED, JUST PRINT
	MOVE	T3,TAPDTB	;GET DENSITY TABLE ADDRESS
DENCHK:	SKIPN	T2,(T3)		;GET VALUE
	ERRPOP	<DENSITY NOT AVAILABLE>
	XOR	T2,T1		;RH OF T2 ZERO IF MATCH
	TRNE	T2,-1		;SKIP IF GOT IT
	AOJA	T3,DENCHK	;NO, GET NEXT ONE
	HLRZ	T1,(T3)		;GET FILE STATUS
	MOVEM	T1,OPNTAP	;PUT IN STATUS WORD
	SETSTS	TAPE,(T1)	;SET IT.
	POPJ	P,		;AND NOW WE'RE DONE.

GETTAP:	PUSHJ	P,SIXIN		;SPECIFIED TAPE?
	  JRST	GETCTP		;SEE IF THERE'S A CURRENT UNIT
	PUSHJ	P,TAPOP1	;OPEN IT
	  ERRPOP <DEVICE NOT AVAILABLE>
	JRST	CPOPJ1
GETCTP:	SKIPN	OPNTNM		;ANYTHING THERE?
	ERRPOP	<NO TAPE UNIT OPEN>
	JRST	TAPOP2		;OPEN IT FRESH, AND RETURN.

NOTAPO:	POPJ	P,

DEFINE DENMAC <
X(<6250>)
X(<6250,1600>)
X(<1600>)
X(<1600,800>)
X(<800,556>)
X(<800,556,200>)
>;END DENMAC


DEFINE X(DENS)<
ZZ==3
DENBIT(<'DENS>)
XWD ZZ1,[
IRP DENS,<<ZZ>B<28>+17,,^D<'DENS>
ZZ==ZZ-1
>;END IRP DENS
	0];;END TABLE WITH A ZERO
>;END X MACRO DEFINITION


DEFINE DENBIT(DENS)<
ZZ1==0
IRP DENS,<
IFIDN <DENS> <6250> <ZZ1==ZZ1!UG.D62>
IFIDN <DENS> <1600> <ZZ1==ZZ1!UG.D16>
IFIDN <DENS> <800> <ZZ1==ZZ1!UG.D8>
IFIDN <DENS> <556> <ZZ1==ZZ1!UG.D5>
IFIDN <DENS> <200> <ZZ1==ZZ1!UG.D2>
>;END IRP
>;END DENBIT

DENSTB:	DENMAC		;GENERATE TABLE
	0		;ENDS WITH ZERO.

SUBTTL COMMAND SCANNER

;ENTER WITH COMMAND NAME IN T1, AOBJN TO TABLE IN T4
;SMASHES T2-T4, S
;NON-SKIP IF BAD COMMAND OR AMBIGUOUS COMMAND, MESSAGE PRINTED ON TERMINAL
;SKIP IF COMMAND FOUND, INDEX INTO TABLE GIVEN IN C(T4) RETURNED IN T4

COMMAN:	PUSH	P,T4		;SAVE SO CAN CALCULATE OFFSET IF COMMAND IS FOUND
	MOVE	T3,T1		;COPY COMMAND IN T3
	SETO	T2,		;MASK
	SETZ	S,		;CLEAR FLAG
	LSH	T2,-6		;AT LEAST 1 CHAR MUST BE PRESENT
	LSH	T3,6		;MAKE A TDZ MASK
	JUMPN	T3,.-2
COM1:	MOVE	T3,(T4)		;GET NEXT COMMAND NAME
	CAMN	T1,T3		;MATCH?
	JRST	COMFND		;YES, RETURN INDEX
	TDZ	T3,T2		;MASK TABLE ENTRY DOWN TO NUMBER OF CHARS IN TYPED COMMAND
	CAME	T1,T3		;MATCHES NOW?
	JRST	NXTCOM		;NO, GO FOR NEXT ENTRY
	TROE	S,1		;FLAG SEEN 1. IF ALREADY SEEN ONE,
	TRO	S,2		;MARK IT.
	HRL	S,T4		;AND SAVE ADDRESS
NXTCOM:	AOBJN	T4,COM1		;CONTINUE
	TRNE	S,2		;IF SAW TWO OR MORE,
	JRST	[MSG (<AMBIGUOUS COMMAND >)
		 JRST NOCOM]
	TRNN	S,1		;OK, SKIP IF HAVE A COMMAND
	JRST	[MSG (<UNKNOWN COMMAND >)
		 JRST NOCOM]
	HLRZ	T4,S		;RESTORE PROPER TABLE ADDRESS
COMFND:	POP	P,T3		;GET ORIGINAL AOBJN POINTER
	TLZ	T4,-1		;CLEAR OUT COUNT
	SUBI	T4,(T3)		;GET COMMAND NUMBER
CPOPJ1:	AOS	(P)		;AND SKIP RETURN
CPOPJ:	POPJ	P,		;BYE.

NOCOM:	PUSHJ	P,SIXOUT	;PRINT COMMAND
	MSG	,CRLF
	PUSHJ	P,BRKEAT	;EAT REST OF LINE
	POP	P,(P)		;GET SAVED AOBJN POINTER OFF STACK
	POPJ	P,		;AND RETURN.


DECOUT:	IDIVI	T1,^D10
	HRLM	T2,(P)
	SKIPE	T1
	PUSHJ	P,DECOUT
	HLRZ	T1,(P)
	OUTCHI	"0"(T1)		;OUTPUT AS ASCII.
	POPJ	P,

DECIN:	SETZ	T1,		;CLEAR RESULT
	PUSHJ	P,ISBRK		;WAS LAST SEP CHAR A BREAK?
	  POPJ	P,		;YES, FIELD IS BLANK
DECIN0:	PUSHJ	P,GTCHR		;SCAN TO FIRST DIGIT IF ANY
	PUSHJ	P,ISBRK		;IS IT BLANK?
	  POPJ	P,		;YES, ERROR
	CAIL	CH,"0"		;IS IT NUMERIC
	CAILE	CH,"9"
	JRST	DECIN0		;NO, SKIP THE NUMBERS
	SKIPA			;OK, HAVE FIRST ONE.
DECIN1:	PUSHJ	P,GTCHR		;GET CHAR
	CAIL	CH,"0"		;MUST BE NUMBER
	CAILE	CH,"9"
	JRST	CPOPJ1
	IMULI	T1,^D10
	ADDI	T1,-"0"(CH)	;GET IT IN
	JRST	DECIN1		;AND GO FOR MORE

OCTIN:	SETZ	T1,		;CLEAR RESULT
	PUSHJ	P,ISBRK		;WAS LAST SEP CHAR A BREAK?
	  POPJ	P,		;YES, FIELD IS BLANK
OCTIN0:	PUSHJ	P,GTCHR		;SCAN TO FIRST DIGIT IF ANY
	PUSHJ	P,ISBRK		;IS IT BLANK?
	  POPJ	P,		;YES, ERROR
	CAIL	CH,"0"		;IS IT NUMERIC
	CAILE	CH,"7"
	JRST	OCTIN0		;NO, SKIP THE NUMBERS
	SKIPA			;OK, HAVE FIRST ONE.
OCTIN1:	PUSHJ	P,GTCHR		;GET CHAR
	CAIL	CH,"0"		;MUST BE NUMBER
	CAILE	CH,"7"
	JRST	CPOPJ1
	LSH	T1,3		;SLIDE WORD OVER
	ADDI	T1,-"0"(CH)	;GET IT IN
	JRST	OCTIN1		;AND GO FOR MORE


BRKEAT:	PUSHJ	P,ISBRK		;IS IT BREAK TIME YET?
	  JRST	BRKEA1		;GO CLEAR CH AND RETURN
	PUSHJ	P,GTCHR
	JRST	BRKEAT
BRKEA1:	MOVEI	CH,-1		;SO SCANNERS DONT GIVE ERROR NEXT TIME
	POPJ	P,		;AND RETURN.

OCTOUT:	IDIVI	T1,10
	HRLM	T2,(P)
	SKIPE	T1
	PUSHJ	P,OCTOUT
	HLRZ	T1,(P)
	OUTCHI	"0"(T1)
	POPJ	P,

;RETURN NEXT SIXBIT TOKEN IN T1, BREAK CHAR IN CH
; SCANS PAST BLANKS AND CONTROL CHARS FIRST.
SIXIN:	MOVE	T3,[POINT 6,T1]
	SETZ	T1,
	PUSHJ	P,ISBRK		;WAS LAST CHAR A BREAK?
	  POPJ	P,		;GIVE ERROR RETURN.
SIXIN1:	PUSHJ	P,GTCHR
	CAILE	CH," "		;IF BLANK OR CONTROL,
	PUSHJ	P,ISBRK		;BREAK?
	  JRST	SIXIN3		;SEE IF COLLECTED ANYTHING
SIXIN2:	TLNN	T3,770000	;ANY MORE ROOM?
	JRST	SIXIN1		;NO, JUST IGNORE THE REST
	CAIL	CH,"a"		;CONVERT LOWER TO UPPER CASE
	CAILE	CH,"z"		;
	JRST	.+2
	SUBI	CH,"a"-"A"
	SUBI	CH," "
	IDPB	CH,T3
	JRST	SIXIN1		;NO, CONTINUE
SIXIN3:	JUMPN	T1,CPOPJ1	;IF COLLECTED ANYTHING, RETURN SKIP
	POPJ	P,		;ELSE ERROR RETURN.

SIXOUT:	MOVE	T2,[POINT 6,T1]
SIXOU1:	ILDB	T3,T2
	JUMPE	T3,CPOPJ
	OUTCHI	"0"-'0'(T3)
	TLNE	T2,770000
	JRST	SIXOU1
	POPJ	P,

ISBRK:	CAIE	CH,176
	CAIG	CH,37
	POPJ	P,
	JRST	CPOPJ1

GTCHR:	INCHWL	CH		;GET IT
	CAIN	CH,15		;IGNORE CR
	JRST	GTCHR
	POPJ	P,		;AND RETURN WITH IT IN CH

OBUF:	BLOCK	3
PDL:	BLOCK	PDLLEN
PTRBUF:	BLOCK	1		;AOBJN POINTER TO WRAP AROUND TO FIRST BUFFER
LASBUF:	BLOCK	1		;AOBJN POINTER TO LAST BUFFER ON SAVE AND RESTORE.
LASOER:	0			;LAST REC NUMBER OF OUTPUT ERROR
LASOEC:	BLOCK	1		;NUMBER OF TIMES TRIED TO OUTPUT SAME REC
OECMAX:	BLOCK	1		;MAX TIMES TO TRY SET HERE.
SRCLEN:	BLOCK	1		;NUMBER OF TIMES TO TRY TO FIND GOOD RECORD ON RESTORE RESYNC
RESTDP:	BLOCK	1		;IF NON-ZERO, SAYS WHERE TO START A SAVE.
RESTTP:	BLOCK	1		;IF NON-ZERO, SAYS WHICH TAPE NUMBER TO CALL IT.
RESDAT:	BLOCK	1		;WHERE TO GET DATE ON A RESTART
RESTIM:	BLOCK	1		;WHERE TO GET TIME ON A RESTART
VERFLG:	BLOCK	1		;VERIFY FLAG.
VERBFF:	BLOCK	1		;IF NONZERO, SAYS VERIFY BUFFERS SETUP
STRMXP:	BLOCK	1		;MAX PAGES PER STR STORED HERE.
DSKCHB:	BLOCK	20		;DSKCHR BLOCK
DEBNAM:	3
	0
	SIXBIT	/TAPE/
	SIXBIT	/DMP/

TAPDTB:	0			;ADDRESS OF DENSITY BLOCK FOR TAPE UNIT
CODNAM:	SIXBIT	/ASP/
TAPNUM:	BLOCK	1		;CURRENT TAPE NUMBER
TAPBAS:	BLOCK	1		;RECORD NUMBER THIS TAPE STARTED WITH
CNTPRO:	0			;PLACE TO KEEP RECORD COUNT WE EXPECT ON RESTORE

PROBUF:	PHASE	0
PROCOD:!0			;READ OR WRITE CODE HERE
PROCNT:!0			;COUNT GOES HERE
	DEPHASE
	PROLEN==.-PROBUF
OPNTAP:	EXP 17
OPNTNM:	0
	0
OPNSTR:	17
STRNAM:	SIXBIT	/DSKB/
	0			;THIS IS AN OPEN BLOCK
STRHID:	BLOCK	1		;HOME BLOCK ID
STRNMU:	BLOCK	1		;NUMBER OF UNITS IN STRUCTURE

FIRDAT:	BLOCK	1		;FIRST DATE SEEN ON RESTORE
FIRTIM:	BLOCK	1		;FIRST TIME SEEN ON RESTORE
	END	ST
d@