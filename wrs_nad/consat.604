	SUBTTL	CONSAT.602 - HANDLES PORT & NETWORK INTERACTION
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by  TYMNET, Incorporated.                                   **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **  File Name          :  CONSAT.602      last change: 12/11/86 **
: **                                                              **
: **  File Description   :  The receiver filter processes data and**
: **			    signals from terminal and sends them  **
: **			    to the network. The transmitter filter**
: **			    handles all data and signals from net-**
: **			    work and transmits them to terminals. ** 
: **                                                              **
: **  File Abstract      :  The primary function of this module   **
: **			    performs the interaction between the  **
: **			    individual ports whose are connected  **
: **			    to terminals, and their associated    **
: **			    buffers. 				  **
: **                                                              **
: ******************************************************************
: **                    CHANGE LOG                                **
: **                                                              **
: **  Ver   Date    By   PIR/NSR  Changes (most recent at top)    **
: ** ----- -------- ---  -------- ------------------------------- **
: ** 06.02 12/11/86 dlg		  Added update of X.3 parm 11 if  **
: **				  OBRATE changes.  Increments 	  **
: **				  P.BCT in VAQ1 when adding lf chr**
: **				  to PAD edit buffer.  Modified   **
: **				  SOBRAT to allow setting of all  **
: **				  speeds.
: ** 06.02 12/05/86 sdw           IXPROF is called when init SIO  **
: ** 06.02 11/26/86 DLG		  Added IF X3ON when calling 	  **
: **				  IXPROF to prevent assembly error**
: ** 06.02 11/17/86 dlg		  Removed jump to IXPROF from 	  **
: **				  IZPORT and call IXPROF 	  **
: **				  independently.		  **
: ** 06.02 11/17/86 dlg		  Removed setting profile zero X.3**
: **				  parameters if in login mode.	  **
: ** 06.02 11/13/86 sdw		  Added check for dialect selected**
: **				  prior to process TIIX routine	  **
: ** 06.02 11/06/86 DLG		  Change PMODE to PADACT	  **
: ** 06.02 11/05/86 dlg		  Replaced .TTBUF/.ECOBF with 	  **
: ** 				  .TPBUF and removed checks to see**
: **				  which buffer to use.		  **
: ** 06.02 10/20/86 CAB		  changed XIO output limits to be **
: **				  tolerant of varying foreground  **
: **				  intervals of 20-30 ms.	  **
: ** 06.02 10/13/86 CAB		  VSIO now handles hung XSIO output*
: ** 06.02 10/08/86 LH		  Add new receiver P.VASC to reset**
: **				  the port being POLLed.          **
: ** 06.02 10/03/86 CAB		  Fixed printer problem.	  **
: ** 06.02 09/26/86 LH   NSR 958  Fixed crash type 03 by changing **
: **				  IIXCAL(not under X3ON) to IIXCAP**
: ** 06.02 09/26/86 dlg  	  Changed instr. to RX3 to prevent**
: **				  assembly error in QHNS3A	  **
: ** 06.01 09/17/86 LH		  Send out ALO login string after **
: **				  IIX negotiation with smart gateway
: ** 06.01 09/10/86 DLG		  Added NSPORT switch to prevent  **
: **				  GOTSIO as undefined symbol.	  **
: ** 06.01 09/10/86 LH	          Changed JGEBS to JGE around XNF2**
: ** 06.01 09/10/86 CAB	 NSR 909  Made input backpressure work for**
: **				  SIO ports also.		  **
: ** 06.01 08/27/86 CAB		  Made input backpressure limits  **
: **				  for XON/XOFF speed dependent.   **
: ** 06.01 08/27/86 LH   NSR 899  Reset XTGATE to fix username not**
: **				  echoing on subsequent logins.   **
: ** 06.01 08/26/86 CAB  NSR 829  Improved XSIO performance and   **
: **				  added XSIOBL buffer limit table.**
: **				  With double buffering, SIO output*
: **				  runs at 99% of line capacity.   **
: ** 06.00 07/10/86 CAB		  Changed V.VTX EDEM logic to use **
: **				  TOPRTP instead of TOPORT.       **
: ** 06.00 07/10/86 CAB		  Changed QHA6 to fix port hang   **
: ** 06.00 07/10/86 DLG		  Changed VAQ1 to check if X3ON	  **
: **  				  then use .FEDBF insted of .FTBUF**
: **				  to correct "Q"-mode handler if  **
: **				  PAD.				  **
: ** 06.00 07/09/86 LH		  fixed SIIX for SIO assembly error* 
: ** 06.00 07/08/86 CAB		  fixed MSGSP to handle multibyte **
: **				  signals same way as MSG	  **
: ** 06.00 06/27/86 CAB		  Changed VASCII EDEM logic to use**
: **				  TOPRTP instead of TOPORT.       **
: ** 06.00 06/26/86 CAB		  Fixed transparency for katakana **
: ** 06.00 06/20/86 dlg		  Changes to SETALL to 		  **
: **				  INITCS and INITX3		  **
: ** 06.00 06/16/86 CAB		  Incorporated SIO hang fix by SDW**
: ** 06.00 06/13/86 CAB		  Improved VASCI performance by   **
: **				  optimizing ^Q and ^S logic.     **
: ** 06.00 06/06/86 LH		  Put NAPORT switch to SIIX and   **
: **				  TIIX to avoid assembly errors.  **
: ** 06.00 05/30/86 dlg		  Tightened up PAD hook into XASCI**
: ** 06.00 05/30/86 CAB		  Improved VASCI performance by   **
: **				  optimizing X3.N3 break logic.   **
: ** 06.00 05/29/86 dlg 	  Fixed bugs in VASCI X3.N3 logic.**
: ** 06.00 05/29/86 LH		  Moved PARBIT table from DATA.600**
: ** 06.00 05/27/86 LH	 PIR#1824 Added load msg function on zapper*
: ** 06.00 05/15/86 LH   PIR#1824 Added S-mode IIX global message **
: **				  and IIX dialect msg processor.  **
: ** 05.00 05/07/86 sdw           save current time when port     **
: **                              becomes active.                 **
: ** 05.00 04/25/86 sdw           MSG puts into buffer as even par**
: ** 05.00 04/12/86 sdw           IZPORT calls IXPROF only one an **
: **                              initial logon attempt (NEWLOG)  **
: ** 05.00 03/28/86 sdw           moved PCOWAT logic to PVC module**
: ** 04.02 03/17/86 LH   PIR#1869 Make PCOWAT suitable for all    **
: **				  Async PVC port, not only for    **
: **				  Speedlink PVC port.             **
: ** 04.02 03/14/86 LH   PIR#1869 Crash code = 90 added for SPEED-**
: **				  LINK telex port not a PVC port. **
: ** 04.02 03/12/86 CAB  NSR 0647 mask msgs to 7 bits if KANA set **
: ** 04.03 03/04/86 SDW           Make sure that both PARITY and  **
: **                              SEVBIT are not set.             **
: ** 04.02 03/03/86 SDW           MSG handles multibyte signals   **
: ** 04.03 02/24/86 LH   PIR#1869 Add TID38 for SPEEDLINK part 2. **
: ** 04.03 02/24/86 LH   PIR#0228 Change label in XHBA		  **
: ** 04.03 02/06/86 SDW           Added delay signal handling     **
: ** 04.03 01/28/86 SDW  n/a      Changed macro SIOIO to jump to  **
: **                              SCRASH which then jumps to CRASH**
: ** 04.03 01/18/86 SDW  n/a      Spun off data definitions as a  **
: **                              separate module (DATA.403)      **
: ** 04.03 01/18/86 SDW  PIR 1653 HANGAN for Outdial dialing      **
: ** 04.02 01/14/86 SDW           Make transparency a two level signal**
: ** 04.02 01/10/86 CAB  PIR 2095 Added AEQCR flag for TID table  **
: ** 04.02 01/07/86 DLG  n/a      Sup acct Msg required branch to **
: **				  PAD module when line between PAD**
: **				  and terminal or terminal is     **
: **				  powered off.			  **
: ** 04.02 01/07/86 LH   PIR 1869 Create new TID35, TID36, TID37. **
: **   ''     ''    ''      ''    New timout FWDMRK routine added **
: **				  for SPEEDLINK TELEX.            **
: **   ''     ''    ''            Add proprietary banner.         **
: **                                                              **
: ******************************************************************

	SUBTTL	(CONSAT) STATIC CONFIGURATION PARAMETERS


:	    **** *****   *   ****  *****        ***  *****
:	   *       *    * *  *   *   *         *   * *
:	    ***    *   ***** ****    *         *   * ****
:	       *   *   *   * *  *    *         *   * *
:	   ****    *   *   * *   *   *          ***  *

:	 ***   ***  ****  *****         *   ****  *****   *
:	*   * *   * *   * *            * *  *   * *      * *
:	*     *   * *   * ****        ***** ****  ****  *****
:	*   * *   * *   * *           *   * *  *  *     *   *
:	 ***  ***  ****  *****        *   * *   * ***** *   *

	SEG	A.CODE

	MO	.,CONSAT

	LO	DATA

:	Parity-translation table...1 = odd parity
PARBIT	HC	6996,9669,9669,6996,9669,6996,6996,9669

	IF 	NAPORTS
:       Rearrange the code such that the main transmitter/recievers are
:       closer to PUTCHR and AGETCH than the less commonly used trans/rcv 
:       *sdw*403*


	SUBTTL (CONSAT)	ASYNC 2741 DRIVER CODE


:	 ***  ***** *  *   **        *  ***  *****  ***  *****
:	*   *    *  *  *    *       *  *   *    *  *        *
:	   *    *   *****   *      *      *    *   ****    *
:	  *    *       *    *     *    *   *  *    *   *  *
:	***** *        *  *****  *      ***  *      ***  *

:	Symbolic names for 2741 control characters (8-bit)
.27CR	EQ	0ED			:CR (New-Line)
.27LF	EQ	0EE			:LF
.27SPC	EQ	0C0			:space
.27TAB	EQ	0AF			:HT
.27DUM	EQ	082			:dummy char (meaningless)
.27EOA	EQ	0B4			:EOA
.27EOT	EQ	0FC			:EOT
.27LC	EQ	09F			:lower-case
.27UC	EQ	09C			:upper-case
.27BS	EQ	0DD			:Back-space
.27IDL	EQ	0BD			:IDLE


:	Initial state for 2741-type terminals if not identified with CR.
:		Then must scan (and eat) input until CR arrives.  Only
:		then can we proceed with normal initialization.
Z2741	JAL	RCH,AGETCH		:Get the next character input
	 J	0,RLINK			:control-signal...ignore
	NHI	RBC,3F			:Reduce to 6-bits
	SHI	RBC,.27CR&3F		:looking for C/R
	JNR	RLINK			:exit if not

:	Got a CR...set up new receive driver
	LA	R3,V2741		:set new address
	ST	R3,.VSTAT,RPI		:...into state-vector
	JR	RLINK			:and exit


:	2741 Receiver.
:	==== ========
V2741	JAL	RCH,AGETCH		:assemble character
	 J	V27BRK			:control signal (BREAK begin or end)
	RBT	RP,EOAF			:if we're expecting EOA,
	JN	VEOA			:this must be it
	LB	R9,VTBA,RP		:translate - table start displacement
	NHI	RBC,3F			:strip stop and parity bits
	AR	R9,RBC
	RBT	RP,SCF			:special-case is good for only one char
	JEFS	V27A
	AHI	R9,80			:set special-case table address
	JFS	V27B
V27A	TBT	RP,UCF			:should this be upper case?
	JEFS	V27B
	AHI	R9,40			:yes...bias pointer to alternate table entry
V27B	LB	R9,T27VC,R9
	THI	R9,80			:high-bit of byte =0 means entry is
V27C	JE	V27C,R9			:	relative...address of special
					:	character processor
	LBR	RBC,R9			:transmit the character
V27D	JAL	RCH,PUTCHR
V27E	LIS	RBC,3			:increment carriage position count
	AHM	RBC,MARGE,RPI		:	(by 3, so we won't have to div)
	JR	RLINK

:	Special character processors:
VSPC	SBT	RP,SCF			:Special (+/-)-case shift
	JBS	V27E			:inc carriage pos on this one

:	CARRET
VCRC	LH	R5,MARGE,RPI		:compute delay
	SRLS	R5,5			:DELAY=((3*#CHAR)/32)+2
	AIS	R5,2
	JAL	RCH,ADELAY
	LHI	RBC,8D			:send a CARRET
	J	V27D

:	BREAK
V27BRK	TBT	RP,XMTF			:are we transmitting?
	JER	RLINK			:no...just ignore breaks
	 LO	SIGNAL
	SIS	R5,BESIG		:this must be ATTN request..
	 FO	SIGNAL
	JNR	RLINK			:wait until it's over (BREAK-end)
	SBT	RP,ATTN			:and set flag for transmitter
	JFS	VXCAL

VEOT	SBT	RP,EOTF			:EOT - tell X2741 that CONSAT
	SBT	RP,XMTF			:can now transmit
VXCAL	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
	LHI	RBC,.27DUM		:put a dummy char into the buffer
	JAL	RCH,PUTCHR		:	...to insure X2741 is called

VEOA	RBT	RP,SCF			:EOA...reset this just in case

VLCC	RBT	RP,UCF			:Lower-case shift

VNUL	JR	RLINK


VUCC	SBT	RP,UCF			:Upper-case shift
	JR	RLINK



:	2741 transmitter.
:	==== ===========
X2741	TBT	RP,XMTF			:can we transmit?
	JNFS	X27A			:yes...proceed
	JAL	RCH,CPEEK		:no...any signals pending?
	 J	XDEF			:no...just defer for now
	JFS	X27B			:yes...go get it

X27A	RBT	RP,ATTN			:ATTN request?
	JN	X27ATN			:yes
	RBT	RP,EOTF			:was an EOT received?
	JEFS	X27B
	SBT	RP,DEM			:start the green-ball stuff
	LHI	RBC,.27EOA		:transmit EOA
	J	X27F			:and transmit it

X27B	JAL	RCH,GETCHR		:none of the above - get a char
	 J	SIG.27			:control signal
	NHI	RBC,7F			:mask to 7-bit
	LB	R4,XTBA,RP		:get translate-table start displacement
	IF	SOLOCS
	LR	R9,RBC			:XMIT BUG
	EI
	LB	RBC,T27XC,RBC,R4	:2741 char now in RBC
	JER	RLINK			:don't output null characters
	CLHI	RBC,.27CR&7F		:is it a CARRET?
	JE	X27CR
	RBT	RP,CARR			:ignor  LF's after CR's
	JEFS	X27C
	CLHI	RBC,.27LF&7F		:LF?
	JER	RLINK
X27C	CLHI	RBC,.27LF&7F		:not CARRET...
	JE	X27LF			:LF not following CR!
	CLHI	RBC,.27SPC&7F		:don't shift case on spaces
	JE	X27E
	CLHI	RBC,.27TAB&7F		: ...or tabs
	JE	X27E
	LHI	R0,9C1F			:test for, and (if needed)...
	TBT	RP,UCF			:...shift to the correct case
	JEFS	X27D
	EXBR	R0,R0			:bit 24 now equals UCF
					:...bits 17-23 contain shift-code
					:	we might need to output
X27D	XR	R0,RBC
	THI	R0,80			:if it's 0, case is right
	JEFS	X27E
	IF	SOLOCS			:rest of patch to prevent consecutive
	EXBR	RBC,R0			:XMITs which caused microcode crash
	OHI	RBC,80
	JAL	RCH,APUTCH
	CBT	RP,UCF
	LR	RBC,R9
	GL	WCD
	JAL	R8,WCD,,
	JR	RLINK
	ELSE
	LR	R9,RBC			:else save char...
	EXBR	RBC,R0			:output a case shift
	OHI	RBC,80			:(remembering to set high bit)
	JAL	RCH,APUTCH
	CBT	RP,UCF			:complement current case
	LR	RBC,R9			:restore the character
	EI	:SOLOCS
X27E	LIS	R5,3			:inc position
	AHM	R5,MARGE,RPI
	OHI	RBC,80			:Hi-order bit always=1
X27F	JAL	RCH,APUTCH		:...on chars sent to terminal
	JR	RLINK


:	Special character processors:
X27LF	LIS	R5,1			:Line-feed...preceed with 1 delay,
	JAL	RCH,ADELAY
	LHI	RBC,.27LF		:...then line-feed
	JAL	RCH,APUTCH
	LIS	R5,2			:follow with 2-char delay
	JAL	RCH,ADELAY
	J	XDEF			:...and defer further output for now

X27CR	LHI	RBC,.27CR		:CARRET
	JAL	RCH,APUTCH
	SBT	RP,CARR			:and remember it happened
	LB	R5,MARGE+1,RPI		:compute delay
	SRLS	R5,3
	AIS	R5,2
	JAL	RCH,ADELAY		:else set delay
	J	XDEF			:and defer output this go-roundie

:	SIG.27:	Signal Processor for 2741-transmitter
:	=====

:	Called from X2741 transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.27	SIGBGN(LTMSIG,EADSIG-LADSIG,SPASIG-QQMSIG)
	SIGEXC(ZAPSIG,XZAP)		:zapper...alternate entry
	SIGEXC(GBSIG,X27GB)		:Green-ball
	SIGEXC(SHGSIG,HANGUP)		:Super-hang...just hang
	SIGEXC(ETMSIG,X27ETM)		:Enter transparency
	SIGEND

X27ATN	RBT	RP,GBO			:ignore future green-balls
	JFS	X27GB1

:	Green-ball
X27GB	RBT	RP,DEM			:check DEM
	JER	RLINK			:no...ignore it
	RBT	RP,GBO
	SBT	RP,NBO
	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	 LO	SIGNAL
	LIS	R4,LDMSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG		:send LDEC to host
X27GB1	LHI	RBC,.27EOT		:transmit EOT
	L	RBP,.TTBUF,RPI		:...toward terminal
	JAL	RCH,APUTCH
	RBT	RP,XMTF			:CONSAT can no longer transmit
	SBT	RP,EOAF			:tell receiver to expect an EOA
	LIS	R5,7
	JAL	RCH,ADELAY		:delay 7 times after EOT
	JR	RLINK

:	Enter-Transparency-Mode
X27ETM	LA	R0,VGLASS
	LA	R1,XGLASS
	RBT	RP,SCF
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK
:	2741 transparency-mode receiver.
:	==== ================= ========
VGLASS	JAL	RCH,AGETCH		:assemble the character
	 J	VGBRK			:control signal (BREAK begin or end)
	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	OHI	RBC,80			:always set Hi-order bit..
	LR	R9,RBC			:save copy of character sent
	JAL	RCH,PUTCHR
	RBT	RP,EOAF			:if we're expecting EOA,
	JN	VLCC			:...this must be it
	CLHI	R9,.27EOT		:keep track of terminal state..
	JNFS	VGLAS1
	SBT	RP,XMTF			:we can transmit now
	SBT	RP,EOTF
	J	VLCC

VGLAS1	CLHI	R9,.27UC		:...and case-shifts
	JE	VUCC
	CLHI	R9,.27LC		:down-shift?
	JE	VLCC
	JR	RLINK

:	ATTN request (BREAK begin or end) detected.
VGBRK	TBT	RP,XMTF			:bit set if CONSAT is transmitting,
	JER	RLINK			:	zero if terminal transmitting
					:	(CONSAT receiving)
	LO	SIGNAL
	SIS	R5,BESIG		:ignor until get BREAK-end
	JNR	RLINK			:not ATTN, discard noise
	L	RBP,.FTBUF,RPI		:From-terminal buffer-pointer
	TBT	RP,TSNBRK		:toss-data on BREAK enabled?
	JEFS	VGBRK1			:not enabled, handle ATTN request
					:	normally
	SBT	RP,TOSING		:alert transmitter to start tossing
					:	output
VGBRK1	SBT	RP,ATTN			:and set bit for transmitter
	JNR	RLINK			:if not first BREAK char, don't send
					:	BREAK to host
	LIS	R4,BBSIG		:send BREAK-begin signal into TYMNET
	JAL	RCH,PUTSIG
	LIS	R4,BBSIG		:...twice!
	FO	SIGNAL
	JAL	RCH,PUTSIG
	JR	RLINK			:done

:	2741 transparency-mode transmitter.
:	==== ================= ===========
XGLASS	JAL	RCH,GETCHR		:get the character
	 J	SIG.XG			:normal return...control signal
	TBT	RP,TOSING		:are we tossing output?
	JNR	RLINK			:yes - TOSING reset by receipt of
					:	gobbler
	OHI	RBC,80			:set stop-bit
	LR	R9,RBC			:save character
	JAL	RCH,APUTCH		:transmit character to terminal
	RBT	RP,EOTF			:only needed in non-transparency mode
	CLHI	R9,.27EOT		:EOT transmitted?
	JN	VGLAS1			:no, keep track of shifts
	RBT	RP,ATTN			:if ATTN req pending, it's satisfied
	RBT	RP,XMTF			:terminal now in transmit mode
	SBT	RP,EOAF			:and receiver should expect EOA
	JR	RLINK

:	SIG.XG:	Signal Processor for 2741-Transparency
:	======
:	Called from XGLASS transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.XG	SIGBGN(ETMSIG,EADSIG-LADSIG,SPASIG-QQMSIG)
	SIGEXC(GBSIG,XGGB)		:green-ball
	SIGEXC(SHGSIG,HANGUP)		:Super-hang...just hang
	SIGEXC(ZAPSIG,XGZAP)		:Zapper
	SIGEXC(LTMSIG,XGLTM)		:Leave transparency-mode
	SIGEND

:	Green-ball
XGGB	RBT	RP,DEM			:just tff DEM
	JR	RLINK			:...and ignore

:	Zapper
XGZAP	LA	RLINK,XZAP		:exit via 2741 zapper

:	Leave-Transparency-Mode
XGLTM	LA	R0,V2741
	LA	R1,X2741
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK



:	Three tables for each terminal type (EBCD or CORRESPONDANCE).
:	Single byte per entry.  Entries with high-order bit on are
:	ASCII code for character, others are P-relative addresses of
:	routines that handle special characters (i.e., case shifts).


	RA	8			:tables are in octal


:	2741 Receiver conversion tables:
NUL	EQ	VNUL-V27C		:define relative addresses..
CAR	EQ	VCRC-V27C		:of character processors
UCS	EQ	VUCC-V27C
LLS	EQ	VLCC-V27C
SPS	EQ	VSPC-V27C
ETS	EQ	VEOT-V27C

:	CORRESPONDENCE code:


T27VC	BC	240,241,364,352,264,357,354,257,265,247,345,360
	BC	NUL,NUL,NUL,NUL,262,256,356,275,372,NUL,NUL,NUL
	BC	266,351,353,361,UCS,210,NUL,LLS,261,355,370,347
	BC	260,363,350,371,267,362,344,273,NUL,CAR,212,211
	BC	263,366,365,346,271,367,342,255,270,341,343,254
	BC	ETS,NUL,NUL,NUL
:	Upper case:
	BC	240,335,324,312,244,317,314,277,245,242,305,320
	BC	NUL,NUL,NUL,NUL,300,256,316,253,332,NUL,NUL,NUL
	BC	333,311,313,321,UCS,210,NUL,LLS,SPS,315,330,307
	BC	251,323,310,331,246,322,304,272,NUL,CAR,212,211
	BC	243,326,325,306,250,327,302,337,252,301,303,254
	BC	ETS,NUL,NUL,NUL
:	Special (+/-) case
	BC	NUL,336,224,212,234,217,214,334,235,340,205,220
	BC	NUL,NUL,NUL,NUL,NUL,374,216,373,232,NUL,NUL,NUL
	BC	236,211,213,221,UCS,NUL,NUL,LLS,NUL,215,230,207
	BC	276,223,210,231,237,222,204,377,NUL,NUL,NUL,NUL
	BC	233,226,225,206,274,227,202,376,375,201,203,NUL
	BC	ETS,NUL,NUL,NUL

:	EBCD code:

:	Lower case:
T27VE	BC	240,255,300,246,270,361,371,350,264,355,365,344
	BC	NUL,NUL,NUL,NUL,262,353,363,342,260,NUL,NUL,NUL
	BC	266,357,367,346,UCS,210,NUL,LLS,261,352,257,341
	BC	271,362,372,351,265,356,366,345,NUL,CAR,212,211
	BC	263,354,364,343,243,244,254,256,267,360,370,347
	BC	ETS,NUL,NUL,NUL
:	Upper case:
	BC	240,337,SPS,253,252,321,331,310,272,315,325,304
	BC	NUL,NUL,NUL,NUL,274,313,323,302,251,NUL,NUL,NUL
	BC	247,317,327,306,UCS,210,NUL,LLS,275,312,277,301
	BC	250,322,332,311,245,316,326,305,NUL,CAR,212,211
	BC	273,314,324,303,242,241,374,336,276,320,330,307
	BC	ETS,NUL,NUL,NUL
:	Special (+/-) case
	BC	NUL,376,NUL,037,375,221,231,210,234,215,225,204
	BC	NUL,NUL,NUL,NUL,333,213,223,202,335,NUL,NUL,NUL
	BC	236,217,227,206,UCS,NUL,NUL,LLS,373,336,334,201
	BC	333,222,232,211,235,216,226,205,377,CAR,NUL,NUL
	BC	233,214,224,203,340,336,377,334,237,220,230,207
	BC	ETS,NUL,NUL,NUL

:	2741 Transmitter conversion tables:

:	ASCII to 2741 code conversion.  One byte per entry.  High-order
:	bit on indicates character is upper case.

:	CORRESPONDENCE code:
T27XC	BC	000,000,000,000,000,000,000,040,135,057,156,000
	BC	000,155,000,000,000,000,000,000,000,000,000,000
	BC	000,000,000,000,000,000,000,000,100,001,311,360
	BC	204,210,350,111,364,344,270,223,273,067,121,007
	BC	144,040,020,160,004,010,130,150,070,064,353,153
	BC	264,023,344,207

	BC	220,371,366,372,252,312,363,243,246,231,303,232
	BC	306,341,322,305,213,333,251,245,202,262,261,365
	BC	342,347,324,330,007,201,001,267,111,171,166,172
	BC	052,112,163,043,046,031,103,032,106,141,122,105
	BC	013,133,051,045,002,062,061,165,142,147,124,264
	BC	001,344,000,075

:	EBCD code:
T27XE	BC	000,000,000,000,000,000,000,040,135,057,156,000
	BC	000,155,000,000,000,000,000,000,000,000,000,000
	BC	000,000,000,000,000,000,000,000,100,365,264,064
	BC	165,350,103,130,344,324,204,303,166,001,067,142
	BC	124,040,020,160,010,150,130,070,004,144,210,360
	BC	220,240,270,342

	BC	202,243,223,363,213,353,333,273,207,347,341,321
	BC	261,311,251,231,371,305,245,322,262,312,252,232
	BC	372,306,246,344,142,324,166,201,330,043,023,163
	BC	013,153,133,073,007,147,141,121,061,111,051,031
	BC	171,105,045,122,062,112,052,032,172,106,046,344
	BC	166,124,267,075

	RA	0			:back to Hex radix

TEBC	EQ	(T27VE-T27VC)^8!(T27XE-T27XC)	:kludge for byte forward refs




	EI  :NAPORT
	 IF	VTEXT

:	*   * ***** ****  *****  ***  ***** ***** *   * *****
:	*   *   *   *   * *     *   *   *   *      * *    *
:	*   *   *   *   * ****  *   *   *   ****    *     *
:	 * *    *   *   * *     *   *   *   *      * *    *
:	  *   ***** ****  *****  ***    *   ***** *   *   *

:		Videotext terminals have several strange properties:
:	They run at 75-baud input, 1200-baud output.
:	The keyboard lacks several important features, notably many
:	desired keys.

:		Receive-filter may run in either translate or transparency
:	mode.  This is determined by ELF.CR (1=translate), permitting
:	the host to examine and determine mode.  The host cannot set ELF.CR
:	directly, but must use enter- and leave-transparency.  In translate
:	mode, the following mapping occurs:

:	KEY NAME	Input	mapped to:

:	SEND		^S|A	CR
:	PREVIOUS	^S|B	Ignored
:	REPEAT		^S|C	Ignored
:	GUIDE		^S|D	Ignored
:	CANCEL		^S|E	ESC
:	INDEX		^S|F	Ignored
:	ERASE		^S|G	Ignored
:	NEXT		^S|H	Ignored
:	DISCONNECT	^S|I	Ignored

:	The mapping table:
:	Biased by "A" (41)
:	0 means ignored
:		 A  B  C  D  E  F  G  H  I
MAP.VT	BC	8D,00,00,00,1B,00,00,00,00
MAX.VT	EQ	.-MAP.VT		:length of table

:	VIDEOTEXT Terminal Receiver
:	========= ======== ========
:	Supports both normal and transparency modes
V.VTX	JAL	RCH,AGETCH		:get the char
	 J	VAESC			:Control-signal
	LR	R9,RBC			:data -- copy it
	NHI	RBC,7F			:Input Char in R9, Working Char in RBC
	CLHI	RBC,20			:data?
	JGE	V.VTX1			:yes...just proceed
        TBT     RBC,VTABLE              :check for passable control chars
        JN      V.VTX1                  
	CLHI	RBC,13			:^S?
	JNR	RLINK			:not ^S, toss it
	TBT	RP,ELF.CR		:is translate enabled?
	JE	V.VTX1			:no...just proceed
	JAL	R0,VSAVE		:else wait for next character

	JAL	RCH,AGETCH		:back again...get next char
	 J	VAESC			:Control-signal
	LA	R0,V.VTX		:restore address
	ST	R0,.VSTAT,RPI
	NHI	RBC,7F			:mask character
	SHI	RBC,41			:^S | A ?
	JLR	RLINK			:Ignore
	CLHI	RBC,MAX.VT		:range check
	JGER	RLINK
	LB	R9,MAP.VT,RBC		:OK...look it up
	JER	RLINK			:null...ignor
	LHI	RBC,7F			:OK...set mask
	NR	RBC,R9			:make 7-bit

V.VTX1	TBT	RP,ECHO			:Echoing?
	JE	VAS300			:no...use normal handler to clean up
	TBT	RP,TOPRTP		:is output pending?
	JN	VAED			:Yes, skip echo
	TBT	RP,HAFDUX		:half-duplex?
	JN	VAHD			:yes...go service it
	TBT	RBC,.ECHT1,RPI		:Is it easily printable?
	JE	VAK1			:yes, go echo
	TBT	RP,Q.MODE		:"non-printable"...is port in "Q"-mode?
	JN	VAQ			:yes...do it
	TBT	RBC,SPABLE		:special?
	JE	VAED			:no...go enter DEM
	SIS	RBC,0D			:CR?
	JN	VAED			:not a CR...enter DEM
	TBT	RP,ECR.LF		:Line-feed needed too?
	JE	VAK1			:Echo CR for CR
	LHI	R6,0A8D
	J	VAEK1			:echo CR/LF for CR



:	Videotext Terminal transmitter
:	========= ======== ===========
X.VTX	JAL	RCH,GETCHR		:Get the data
	 J	SIG.VX			:normal return...It's a signal
	TBT	RP,TOSING		:Are we tossing data?
	JNR	RLINK			:do this until gobbler resets
	LR	R0,RBC			:else make another copy of data-char
	NHI	R0,7F			:Remove MSB
	TBT	RP,PARITY		:Parity enabled?
	JEFS	X.VTX1
	LR	RBC,R0			:yes...set char with parity-bit off
	TBT	R0,PARBIT		:lookup parity
	JEFS	X.VTX1
	OHI	RBC,80			:turn parity-bit on if appropriate
X.VTX1	SIS	R0,0D			:Carriage return?
	JNFS	X.VTX2
	STH	R0,MARGE,RPI		:yes...reset position

X.VTX2	JAL	RCH,APUTCH		:transmit the character
	JR	RLINK			:and exit


:	SIG.VX:	Signal Processor for VIDEOTEXT
:	======

:	Called from VIDEOTEXT transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.VX	SIGBGN(EADSIG,LADSIG)
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEXC(ETMSIG,ETM.VX)		:Enter transparency
	SIGEXC(LTMSIG,LTM.VX)		:Leave transparency
	SIGEXC(SLCSIG,QBPSIG)		:Set echo_CR_on_LF
	SIGEND

:	Service Enter-Transparency
ETM.VX	RBT	RP,ELF.CR		:set transparency on
	JR	RLINK

:	Service Leave-Transparency
LTM.VX	SBT	RP,ELF.CR		:set transparency off
	JR	RLINK

	 EI	:VTEXT


:	Port filters for the CONSAT
:	==== ======= === === ======

:		This code will maintain up to 256 CONSAT ASYNC ports,
:	and a data-rate of approximately 4000 CPS.
:		Service of the CONSAT ports includes all facets of the
:	TYMSHARE terminal.



:	Register usage:

:	RLINK -	Driver link register
:	RP -	port number
:	RPOL -	Register for polling index
:	RBF -	Link register for WCI
:	RBP -	Buffer-pointer for WCI, GETCHR, PUTCHR, PUTSIG
:	RBC -	Character argument for GETCHR, PUTCHR
:	RCH -	Link register for GETCHR, PUTCHR, PUTSIG


	SUBTTL	(CONSAT) HALF-SECOND LOGIC CHECKING STABLE MARKS
	
	 IF	TTELEX

:	Periodic logic to checck stable marking signals coming from device.
:	If stable marks come from devices and initial delay is over, CONSAT
:	starts requesting pseudo-needle in original end and sets limbo state
:	in terminating end.  ** 4.02 LH

	GL	FWDMRK,PORCV
POALO	EQ	1^1			:PVC ALO value
TLX.ER	EQ	90			:** LH 4.02 - crash code
FWDMRK	LHI	RPOL,(NGRP-2)*2		:for all groups
FWDMK0	L	R0,FWDPTH,RPOL		:current forward-path state
	L	R1,FWDPT0,RPOL		:previous forward-path state
	ST	R0,FWDPT0,RPOL		:save current state as history
	NR	R1,R0			:current & previous state still mark
	N	R1,TTLXP,RPOL		:for transparent TELEX ports only
	N	R1,PVCARY,RPOL		:also ports are PVC function
	N	R1,RLA,RPOL		:port-receive-line must be active
FWDMK1	JFFO	R1,FWDMK3		:find one
FWDMK2	SIS	RPOL,4	
	JGE	FWDMK0			:serve next 16 ports
	J	CSDISM		:exit

FWDMK3	ST	R1,TLXTM1		:save state
	RBT	R2,TLXTM1		:reset ports those have been served
	LR	RP,RPOL			
	SLLS	RP,3			:*8 because we're counting by 2's
	AR	RP,R2			:find out which port
	GETPTP(RPI,RP,RP)			:find pointer for port table
	TBT	RP,INTIMR		:is initial delay over?
	JN	FWDMK4			:no, don't do anything.
	TBT	RP,TT.ACP		:yes, further check if port identified
	JN	FWDMK4			:yes, do not need check AID again
	SBT	RP,NEWLOG		:set new login for original ports
	IF	NPAPRT			:if addressable ports(terminating ports)
	JAL	R0,PA.SL		:set limbo
	EI	:NPAPRT
	JAL	RLINK,AIDPVC		:if original ports, requesting P-needle
	J	TTLXER			:normal return.....error!
FWDMK4	L	R1,TLXTM1		:restore temp flag
	J	FWDMK1			:serve next
TTLXER	ABORT(R8,TLX.ER)
	EI	:TTELEX


	SUBTTL	(CONSAT) TWO-SECOND LOGIC
	
	 IF	1-NHNGBK

:	TWO-SECOND PROCESSING
:	=== ====== ==========

	GL	TWOSEC
TWOSEC	LHI	RPOL,(NGRP-2)*2		:for each pair of groups
	LIS	R0,0			:initialization value
:	Hang-on-break logic
TWOS1	L	R1,RLA,RPOL		:active port, which...
	N	R1,ASCII,RPOL		:...is ASYNC port
	N	R1,BRK,RPOL		:...must be in break-state
	N	R1,BRKTO,RPOL		:...and ready to time-out next!
	O	R1,HANGWT,RPOL		:hang these ports
	ST	R1,HANGWT,RPOL
	L	R1,BRKTO1,RPOL		:and update timeouts
	ST	R0,BRKTO1,RPOL
	ST	R1,BRKTO,RPOL
	SIS	RPOL,4			:end of a ring-group pair
	JGE	TWOS1			:next group
	J	CSDISM		:done
	 EI	:1-NHNGBK


	SUBTTL	(CONSAT) SIXTEEN-SECOND LOGIC

	 IF	NAPORT

:	SIXTEEN-SECOND PROCESSING
:	======= ====== ==========

	GL	SEC16
SEC16	LHI	RPOL,(NGRP-2)*2		:for each pair of groups
	LIS	R0,0			:initialization value
	LCS	R1,1
SEC16A	LCS	R2,1			:not AH.TO...
	X	R2,AH.TO,RPOL
	O	R2,HANGWT,RPOL		:hang these ports
	ST	R2,HANGWT,RPOL
	L	R2,AH.TO1,RPOL
	ST	R2,AH.TO,RPOL
	L	R2,AH.TO2,RPOL
	ST	R2,AH.TO1,RPOL
	ST	R1,AH.TO2,RPOL
	SIS	RPOL,4			:end of a ring-group pair
	JGE	SEC16A			:next group
	J	CSDISM		:done
	 EI	:NAPORT


	SUBTTL	(CONSAT) WHO-ARE-YOU LOGIC

	 IF	BTELEX

:	Periodic logic to check whether WRU is received or not.
:	Run every 16 seconds

	GL	WRUTM
WRUTM	LHI	RPOL,(NGRP-2)*2		:for all groups  ** 4.02 LH
WRUTM0	L	R0,WRUT1,RPOL		:update timeout
	L	R1,WRUT0,RPOL
	ST	R0,WRUT0,RPOL
	LIS	R0,0
	ST	R0,WRUT1,RPOL
	N	R1,PVCARY,RPOL		:only for PVC port
WRUTM1	JFFO	R1,WRUTM2		:find one
	SIS	RPOL,4
	JGE	WRUTM0			:service next 16 ports
	J	CSDISM		:exit

WRUTM2	LR	RP,RPOL			:port number to RP
	SLLS	RP,3			:*8,becauxe we are counting by 2's
	AR	RP,R2
	RBT	RP,FWDPTH		:forward force space
	SBT	RP,EMTBRK		:emit breaks
	RBT	RP,MRKING		:spacing in both directions
	ST	R1,WRUTMP
	RBT	R2,WRUTMP		:update temp flag
	L	R1,WRUTMP		:restore temp flag
	J	WRUTM1			:next port
	EI	:BTELEX


	SUBTTL	(CONSAT) PSUDO-NEEDLE LOGIC

	 IF	PVC

:	Periodic logic to resend psudo needle
:	Run every two minutes

	GL	POALO,PSNTM
PSNTM	LHI	RPOL,(NGRP-2)*2		:for each pair of groups
PSNTM0	L	R0,PSNT1,RPOL		:update timeout
	L	R1,PSNT0,RPOL
	ST	R0,PSNT0,RPOL
	LIS	R0,0			:initialization value
	ST	R0,PSNT1,RPOL
	N	R1,PVCARY,RPOL		:only for pvc port
PSNTM1	JFFO	R1,PSNTM2		:find one
	SIS	RPOL,4
	JGE	PSNTM0			:service next 16 prots
	J	CSDISM		:exit

PSNTM2	LR	RP,RPOL			:port number to RP
	SLLS	RP,3			:*8 because we're counting by 2's
	AR	RP,R2
	GETPTP(RPI,RP,RP)
	ST	R1,PSNTMP
	RBT	R2,PSNTMP		:reset psudo needle temp flag
	L	R6,.PVCX,RPI		:get pvc parameters for this port
	THI	R6,POALO		:test for ALO
	JEFS	PSNTM4			:no
PSNTM3	JAL	RLINK,CIRDIS		:disconnect circuit
	JAL	RLINK,ESTPRT		:establish a port
PSNTM4	L	R1,PSNTMP		:restore temp flag
	J	PSNTM1			:service next
	EI	:PVC

	

	SUBTTL	(CONSAT) RED BALL LOGIC

:	Periodic logic to cancel lost balls
:	Runs every 8 seconds
RBTIME	LHI	RPOL,(NGRP-2)*2		:For all groups
RBTIM1	L	R0,NBO,RPOL
	O	R0,TOPORT,RPOL
	XHI	R0,-1
	N	R0,DEM,RPOL
	N	R0,TBOA,RPOL
	JFFO	R0,RBTIM2		:Find one
	L	R0,TBOB,RPOL
	ST	R0,TBOA,RPOL
	LCS	R0,1
	ST	R0,TBOB,RPOL		:Age the timeouts
	SIS	RPOL,4
	JGE	RBTIM1			:Service next 16 ports
	J	CSDISM		:exit

RBTIM2	LR	RP,RPOL			:Port number to RP
	SLLS	RP,3			:*8 because we're counting by 2's
	AR	RP,R1
	GETPTP(RPI,RP,RP)		:get pointer to port table
	RBT	RP,TBOA			:Avoid RBTIM1 loop
	RBT	RP,TBOB			:No red-balls for 8 seconds
	RBT	RP,GBO			:Reset green-ball flag...sending Red
	L	RBP,.FTBUF,RPI		:get from-terminal buffer-pointer
	LO	SIGNAL
	LIS	R4,RBSIG		:flush red-ball down pipe
	FO	SIGNAL
	JAL	RCH,PUTSIG		:send control signal
	J	RBTIM1

	SUBTTL	(CONSAT) TELEX BREAK EMIT POLLING

	 IF	TELEX!BTELEX!TTELEX

:	Polls ports to see which need to have break state emitted
:	to maintain Telex free line state.
:	Called from timeout list every .025 seconds
:
:	RP	PORT NUMBER

	GL	TLXBRK,BRKCBC
TLXBRK	LHI	RPOL,(NGRP-2)*2		:For all groups
TLXBK0	L	R0,RLA,RPOL		:active ports
	LIS	R3,0			:collect all Telex ports
  IF TELEX
	O	R3,TLXP,RPOL		:telex extension cord
  EI
  IF BTELEX
	O	R3,BTLXP,RPOL		:virtual telex
  EI
  IF TTELEX				:** 4.02 LH
	O	R3,TTLXP,RPOL		:transparent telex
  EI
	NR	R0,R3			:only for telex ports
	N	R0,EMTBRK,RPOL		:  in free line state
TLXBK1	JFFO	R0,TLXBK2		:find out which one(s)
	SIS	RPOL,4			:else,check next group
	JGEBS	TLXBK0
	J	CSDISM		:til done

TLXBK2	ST	R0,TLXTMP		:save array
	RBT	R1,TLXTMP		:clear bit
	LR	RP,RPOL			:compute port number
	SLLS	RP,3
	AR	RP,R1
	JAL	R9,BRKCBC,,		:have break state emitted to maintain
					:Telex free state
	L	R0,TLXTMP		:reload array
	J	TLXBK1			:til done with all ports
	EI	:TELEX!BTELEX!TTELEX

	SUBTTL	(CONSAT) GREEN BALL LOGIC

:	Runs every foreground, tries to get out of DEM by sending green balls
GBTIME	LHI	RPOL,(NGRP-2)*2		:For all group pairs...
GBTIM1	LCS	R0,1
	X	R0,TOPORT,RPOL		:no output pending
	N	R0,NBO,RPOL		:and no balls-out
	N	R0,DEM,RPOL		:and in DEM
	N	R0,RLA,RPOL		:and port active
	JFFO	R0,GBTIM2		:skip if a port qualifies
	SIS	RPOL,4			:next group pair...
	JGEBS	GBTIM1
	J	CSDISM		:and exit

GBTIM2	LR	RP,RPOL
	SLLS	RP,3			:*8 because 8 bits/byte
	AR	RP,R1
	GETPTP(RPI,RP,RP)
	RBT	RP,TBOB
	RBT	RP,TBOA			:Start green./red-ball timeout
	RBT	RP,NBO			:Show balls-out
	SBT	RP,GBO			:Expecting a return
	LO	SIGNAL
	LIS	R4,GBSIG		:Message type
	FO	SIGNAL
	L	RBP,.FTBUF,RPI		:Get from-terminal buffer-pointer
	JAL	RCH,PUTSIG
	J	GBTIM1

:	Output Octal String
:	Expects:
:	R0	Number to place
:	R3	Pointer to first byte of string
:	R4	Number of bytes
:	uses R5 for scratch
:	Link	R6
OOS	SIS	R4,1			:Reduce count by 1
	JLR	R6			:exit when done
	LIS	R5,7			:Else set mask
	NR	R5,R0			:Extract digit
	SRLS	R0,3			:And remove it
	AHI	R5,0B0			:"0"
	STB	R5,0,R3,R4		:put digit into memory
	JBS	OOS			:and repeat for next digit

:	Output Decimal String (up to 19 bits, positive)
:	Expects:
:	R0	Number to place
:	R3	Pointer to first byte of string
:	R4	Number of bytes
:	uses R1, R5 for scratch
:	Link	R6
ODS	LIS	R5,$A 10		:set constant
ODS1	SIS	R4,1			:Reduce count by 1
	JLR	R6			:exit when done
	DHR	R0,R5			:Extract digit
	AHI	R0,0B0			:"0"
	STB	R0,0,R3,R4		:put digit into memory
	LR	R0,R1			:restore quotent
	JBS	ODS1			:and repeat for next digit


:	Output Decimal Number (up to 19 bits, positive)
:	Expects:
:	R0	Number to place
:	RBP	Buffer-pointer
:	R4	Number of bytes
:	uses R1, R5 for scratch
:	Link	R9
ODN	LIS	R5,0			:set terminator
	STB	R5,TEMPBF,R4		:place terminator
	LA	R3,TEMPBF		:set pointer
	JAL	R6,ODS			:output decimal string
	LR	R6,R3			:copy pointer
	J	MSG			:and exit via MSG

:	Put port-number into preamble message and output it
:	RP -	Port number
:	R9 -	Link
MSG0	LR	R0,RP			:get port number
	LA	R3,MS00			:place to put message
	LIS	R4,3			:3-bytes long
	JAL	R6,OOS			:Output-Octal-String
	LA	R6,MS0			:set pointer to message
	J	MSG

:	Output a message forcing space (0) parity    4.01U
:	R9 - link
:	R6 - address pointer to string terminated with 0-byte
:	80 in string means next character signal, don't terminate
:		if it is 0
	GL	XBYTE1
MSGSP	LB	RBC,0,R6	:R6 points at next byte of message
	JER	R9		:
	AIS	R6,1		:
	NHI	RBC,7F		:
	JEFS	MSGSP1		:
	JAL	RCH,PUTCHR	:
	JBS	MSGSP		:
MSGSP1	LB	R4,0,R6		:
	AIS	R6,1		:
	TBT	R4,XBYTE1,,	:handle multibyte signals*cab 600
	JEFS	MSGSP3		:
	LB	RBC,0,R6	:
	AIS	R6,1		:
MSGSP3	JAL	RCH,PUTSIG	:control in the string
	J	MSGSP		:

:	Output a message
:	R9 - link
:	R6 - address pointer to string terminated with 0-byte
:	80 in string means next character signal, don't terminate
:		if it is 0
  IF	KANA
MSG	EQ	MSGSP		:if kana, force space parity
  ELSE
MSG	LB	RBC,0,R6	:if not kana, use even parity
	JER	R9		:
	AIS	R6,1		:
	NHI	RBC,7F		:changed to put in buff as even par*500.sdw
	JEFS	MSG2		:
	TBT	RBC,PARBIT	:find parity *500.sdw
	JEFS	MSG1		:1 means set high bit for even par*500.sdw
	OHI	RBC,80		:
MSG1	JAL	RCH,PUTCHR	:
	JBS	MSG		:
MSG2	LB	R4,0,R6		:
	AIS	R6,1		:
	TBT	R4,XBYTE1,,	:handle multibyte signals*402sdw
	JEFS	MSG3		:
	LB	RBC,0,R6	:
	AIS	R6,1		:
MSG3	JAL	RCH,PUTSIG	:control in the string
	J	MSG		:
  EI	:KANA



:	OUTSTR
:	======
:	Output the SC string offered.
:	RBP -	Pointer to buffer
:	R6 -	Pointer to string
:	R5 -	Link register
OUTSTR	ST	R5,OUTSAV		:save return
	ST	R7,OUTSAV+4		:save registers
	ST	R8,OUTSAV+8
	ST	R9,OUTSAV+0C
	LB	R9,0,R6			:get size byte
	JEFS	OUTST2			:ignore if empty
OUTST1	LB	RBC,1,R6		:get a character
	AIS	R6,1			:advance pointer
	JAL	RCH,PUTCHR		:go stuff data into buffer
	SIS	R9,1			:repeat until done
	JGBS	OUTST1
OUTST2	L	R5,OUTSAV		:restore registers
	L	R7,OUTSAV+4
	L	R8,OUTSAV+8
	L	R9,OUTSAV+0C
	AIS	R6,1			:point at next character after string
	JR	R5			:and return


:	Change BF
:	R0 -	Scratch register
:	R1 -	new value of BF
:	RBP -	Buffer-pointer for change
:	R3 -	Link Register
:	NOTE -	if BFnew = BFold, nothing is done
CHNGBF	CLH	R1,BF,RBP		:is this a no-op (same BF?)
	JER	R3			:no change...leave it as-is
	LR	R1,R1			:check if making null
	JEFS	CNGBF1			:yes...just skip this part
	RBT	R1,FLAGS		:insure new bit is off
CNGBF1	LHL	R0,BF,RBP		:get old value
	STH	R1,BF,RBP		:set new value
	JER	R3			:old null...just exit
	RBT	R0,FLAGS		:not null...turn off old bit
	JER	R3			:already off...just exit
	SBT	R1,FLAGS		:else turn on new bit
	JR	R3			:and return


:	Special routine to save and change .VSTAT and exit
:	R0 -	New state
VSAVE	L	R1,.VSTAT,RPI		:save old state
	ST	R1,.VSAVE,RPI

:	Special routine to change .VSTAT and exit
:	R0 -	New state
VSTATE	ST	R0,.VSTAT,RPI		:save new state
	J	VRET			:and exit

:	Special routine to save and change .XSTAT and exit
:	R0 -	New state
XSAVE	L	R1,.XSTAT,RPI		:save old state
	ST	R1,.XSAVE,RPI

:	Special routine to change .XSTAT and exit
:	R0 -	New state
XSTATE	ST	R0,.XSTAT,RPI		:save new state
	J	XRET			:and exit


:	Routine for when port established.
:	Sets up LOGON, outputs messages:
:		Non-PVC:
:			first time:	NPID + PLI
:			Subsequent:	PLI
:		PVC:
:			first time:
:				ALO:		perform logon
:				Non-ALO:	NPID + PLI
:			Subsequent:
:				SLO or ALO:	set it up
:				neither:	PLI
:	RLINK -	link register
:	RPI -	port-table pointer
:	RP -	port number
CIRBLT	 IF	NPAPRT
	TBT	RP,AD.PRT		:is this an addressible port?
	JEFS	CIRBPA			:no
	TBT	RP,LIMBO		:yes...is it in limbo?
	JER	RLINK			:no...don't say anything
CIRBPA
	 EI	:NPAPRT
  IF	X3ON
	TBT	RP,PADACT
	JEFS	CIRBT0			:if login mode...continue
	TBT	RP,PNMODE
	JNR	RLINK			:if got psn in response to call setup
CIRBT0	HS				:then all this was already done
  EI
	L	RBP,.LGBUF,RPI		:clear logon-buffer
	JAL	RCH,EMPTY		:empty buffer
	TBT	RP,HAFDUX		:is this half-duplex port?
	JEFS	CIRBT1			:no
	LIS	RBC,8			:yes...output ^H
	JAL	RCH,PUTCHR		:...into logon-buffer
CIRBT1	HS
  IF	X3ON
	TBT	RP,PADACT
	JNFS	CIRBT4			:if not in login mode...no logger yet
  EI	(X3ON)
	SBT	RP,LOGER		:Init Logger variables
	SBT	RP,LOGING
	SBT	RP,UNAME		:initially in user-name mode
	RBT	RP,XTGATE		:**6.01 LH
CIRBT4	
	L	RBP,.TPBUF,RPI		:the echo buffer-pointer
	TBT	RP,NEWLOG		:is this first or subsequent invocation?
	JEFS	CIRBT8			:subsequent...
	TBT	RP,NPIPRT		:new port...
	JNFS	CIRBT8			:skip if shouldn't output NPID
	 IF	OMRON
	LHL	R6,.TERMT,RPI		:get terminal type
	JEFS	CIRBT7			:if OMRON terminal is used then suppresss LTEXT message
	 EI	:OMRON
	LA	R6,ULMSG		:yes...
	JAL	R9,MSG			:output common message
CIRBT7	JAL	R9,MSG0			:...folowed by NPID
CIRBT8	LCS	R9,1			:"please log in"
  IF	X3ON
	TBT	RP,PADACT
	JE	XLSTAT			:if in login mode...send "pls login"

CIRB81	LB	R0,COM.IN,RP,,
	JEFS	CIRB82			:if no command state timout
	STB	R0,COM.CU,RPI		:  else set up value for port
	SBT	RP,COMTO		:  and turn on timer
CIRB82	RBT	RP,NEWLOG		:pad no longer needs new*500.sdw
	JEFS	CIRBT9			:if not a new port...no "hello"
	LA	R6,XHELLO,,
	JAL	R5,OUTSTR
CIRBT9	LB	R0,X3.P6,RPI
	THI	R0,X3.6P
	JE	CIRB92			:if port can't accept a prompt
	LA	R6,SS.PMT,,
	LR	R5,RLINK
	J	OUTSTR		:   else send howdy
CIRB92	LA	R6,SS.FEF,,		:issue a 'CR'
	JAL	R5,OUTSTR	
	JR	RLINK
  ELSE
	J	XLSTAT			:exit via special handler
  EI	(X3ON)


:	Go enter DEM
:	RP -	port number
:	RPI -	port table pointer
:	RCH -	link register
GO.EDM	RBT	RP,ECHO			:echo off
	SBT	RP,DEM			:DEM on
	 LO	SIGNAL
	LIS	R4,EDMSIG		:enter DEM
	 FO	SIGNAL
	L	RBP,.FTBUF,RPI		:place into from-terminal buffer
  IF	X3ON
	L	R3,.ESIGF,RPI		:get signal filter pointer
	JNR	R3			:if there, exit via signal editor
  EI	:X3ON
	J	PUTSIG			:exit via PUTSIG


	SUBTTL	(CONSAT) INITIALIZE A PORT


:	***** ***** ****   ***  ****  *****
:	  *      *  *   * *   * *   *   *
:	  *     *   ****  *   * ****    *
:	  *    *    *     *   * *  *    *
:	***** ***** *      ***  *   *   *

:	General-purpose Port/Terminal initializer
:	=============== =========================
:	R5 -	Link register
:	R4 -	VID-entry cursor
:	RPI -	Port-table pointer
IZPORT	STH	R4,.TERMT,RPI		:save terminal-type cursor
	SBT	RP,NBO			:force this on
	LB	R0,VID.IB,R4
	STB	R0,IBRATE,RP		:set up input baud-rate
	LB	R0,VID.OB,R4
	STB	R0,OBRATE,RP		:set up output baud-rate
	LB	R0,VID.PA,R4		:set parameters A,B,C,D
	STB	R0,PAR.A,RP		:Parameter A
	LB	R0,VID.PB,R4
	STB	R0,PAR.B,RP		:Parameter B
	LB	R0,VID.PC,R4
	STB	R0,PAR.C,RP		:Parameter C
	LB	R0,VID.PD,R4
	STB	R0,PAR.D,RP		:Parameter D
	LHL	R2,VID.FL,R4		:Initialize bit arrays
	LCS	R3,2
IZP1	AIS	R3,2
	LHL	R1,VIDBA,R3
	JEFS	IZP2			:zero terminates list
	RBT	RP,0,R1			:turn the bit off
	SRHLS	R2,1			:test what it should be
	JNCBS	IZP1
	SBT	RP,0,R1			:else set it
	JBS	IZP1

IZP2	ST	R1,.LSTAT,RPI		:set no special status handler
	LA	R0,BASE,,			:set up base addresses
	LR	R1,R0
	AH	R0,VID.VF,R4		:convert EA to real address
	AH	R1,VID.XF,R4
	 IF	.2HD
	 GL	ZHDUX
	TBT	RP,HD202		:is this a 202 port?
	JEFS	IZP4			:no...proceed
	SBT	RP,HAFDUX		:yes...flag as half-duplex
	LB	R3,VID.TI,R4		:check TID for TID entry
	CHI	R3,20			:to compare 20 instead of 0
	JEFS	IZP3			:don't change input handler for TID
	LA	R0,ZHDUX		:no, not TID...set alternate input
	LA	R1,XHDUX		:...keep same output
	JFS	IZP4			:and skip
IZP3	LA	R1,YHDUX		:TID...set alternate output handler
IZP4	
  	 EI	:.2HD
	ST	R0,.VSTAT,RPI		:set state vectors
	ST	R1,.XSTAT,RPI

:	initialize character echo table in port table
	LR	R1,R12			:preserve RPI, use R1 as index reg
	STM	R12,TEMPA		:save registers 12-15
	LM	R12,PABLE		:get CONSAT-ASCII echoable char set
	STM	R12,.ECHT1,R1		:place 1st 1/2 (0-127) in port table
	STM	R12,.ECHT2,R1		:place 2nd 1/2 (127-255) in port table
	LM	R12,TEMPA		:restore registers 12-15

	TBT	RP,ASCII		:Check for non-ASCII terminals
	JEFS	IZP5
	TBT	RP,HAFDUX		:...or for half-duplex
	JER	R5
IZP5	RBT	RP,LGECHO		:for these, logger doesn't echo
	JR	R5			:and return
	
	SUBTTL (CONSAT)	INPUT BACKPRESSURE LOGIC

	GL	INPBP

:	XON/XOFF Logic.  Give XON/XOFF service where needed.
:
INPBP	LHI	RPOL,(NGRP-2)*2		:for each pair of groups...
XNF0	L	R0,ASYNC,RPOL		:must be ASYNC port
  IF	NSPORT
	O	R0,GOTSIO,RPOL		:or SIO port
  EI	:NSPORT
	N	R0,RLA,RPOL		:
	N	R0,XONENA,RPOL		:
	N	R0,ASCII,RPOL		:ASCII ports only!
	JEFS	XNF2			:nothing to do...
	ST	R0,P.DONE		:keep track of ports serviced
XNF1	L	R0,P.DONE
	JFFO	R0,XNF3			:find port to service
XNF2	SIS	RPOL,4			:end of a ring-group pair
	JGE	XNF0			:next ring group **6.01 LH
	J	CSDISM		:done

XNF3	RBT	R1,P.DONE		:don't look at this port again
	LR	RP,RPOL			:compute port number
	SLLS	RP,3			:(*8 because 8 bits/byte)
	AR	RP,R1			:
	GETPTP(RPI,RP,RP)		:set pointer to table
	L	RBP,.FTBUF,RPI		:check from-terminal buffer
	LH	R0,BCT,RBP		:
	LB	R1,IBRATE,RP		:CAB 6.01 - get speed
	CH	R0,XONTBL,R1,R1		:CAB 6.01 - reached XON limit?
	JGFS	XNF4			:skip...no reason to send XON
	SBT	RP,XONOUT		:small BCT...maybe send XON?
	JN	XNF1			:XON already out
	LHI	RBC,11			:get XON char
	JFS	XNF5			:send XON character
XNF4	CH	R0,XOFTBL,R1,R1		:CAB 6.01 - reached XOFF limit?
	JL	XNF1			:within middle range.  do nothing.
	RBT	RP,XONOUT		:
	JE	XNF1			:XOFF already out
	LHI	RBC,13			:XOFF char
XNF5	L	RBP,.TTBUF,RPI		:send to terminal
	JAL	RCH,PUTCHR		:...either XON or XOFF character
	J	XNF1			:...and proceed to another port


:	Back-Pressure tables
:
:	XONTBL specifies speed-dependent backpressure limit.
:	Consat will un-backpressure the terminal when the
:	bufferlets have less than a quarter-second of data
:
XONTBL	HC	3			:10 CPS
	HC	4			:15
	HC      8			:30
	HC   $A 10			:40
	HC   $A 15			:60
	HC   $A 30			:120
	HC   $A 8			:30
	HC  	4			:14.5
	HC	3			:10
	HC	3			:10
	HC   $A	60			:240
	HC   $A 120			:480 
	HC   $A 240			:960 
	HC   	5			:50 BAUD BAUDOT
	HC    	5			:75 BAUD BAUDOT
	HC      5			:75 BAUD ASCII

:	XOFTBL specifies speed-dependent backpressure limit.
:	Consat will backpressure the terminal when the
:	bufferlets have more than a half-second of data.
:
XOFTBL	HC	5			:10 CPS
	HC	7			:15
	HC   $A	15			:30
	HC   $A 20			:40
	HC   $A 30			:60
	HC   $A 60			:120
	HC   $A 15			:30
	HC  	7			:14.5
	HC	5			:10
	HC	5			:10
	HC   $A	120			:240
	HC   $A 240			:480 
	HC   $A 480			:960 
	HC   	5			:50 BAUD BAUDOT
	HC    	5			:75 BAUD BAUDOT
	HC      5			:75 BAUD ASCII

	SUBTTL	(CONSAT) SIGNAL PROCESSING



:	SIGNAL:  Generalized Signal Processor
:	=======  =========== ====== =========

:	Called from all transmitter to process control signals (in
:		standard fashion).

:	RLINK -	Link register
:	R5 -	Signal to process
:	RBC -	value (if present)
SIGNAL	LHL	R4,SIGDIS,R5,R5		:Get co-routine address
	J	BASE,R4,,		:go service signal

SIGDIS	HC	EA(TYCRSH)		:00 -	enter TID mode V
	HC	EA(TYCRSH)		:01 -	Baud-rate detected
	HC	EA(TYEXIT)		:02 -	Break-Begin
	HC	EA(TYEXIT)		:03 -	Break-end
	HC	EA(TYEXIT)		:04 -	enter data-mode
	HC	EA(TYEXIT)		:05 -	disconnect
	HC	EA(TYEXIT)		:06 -	set delay V
	HC	EA(TYEXIT)		:07 -	repeat data character
	HC	EA(TYEXIT)		:08 -	Enter DEM
	HC	EA(TYEXIT)		:09 -	Leave DEM
	HC	EA(HANGUP)		:0A -	Hang-up
	HC	EA(S.HANG)		:0B -	Super Hang-up
	HC	EA(ZAPPER)		:0C -	Zapper
	HC	EA(GOOBER)		:0D -	Gobbler
	HC	EA(R.BALL)		:0E -	Red ball
	HC	EA(G.BALL)		:0F -	Green ball
	HC	EA(TYEXIT)		:10 -	Orange ball
	HC	EA(BOUNCE)		:11 -	Yellow ball
	HC	EA(TYEXIT)		:12 -	Gray ball
	HC	EA(BOUNCE)		:13 -	Black ball
	HC	EA(ETRSIG)		:14 -	Enter Transparency    4.01U
	HC	EA(LTRSIG)		:15 -	Leave Transparency    4.01U
	HC	EA(TYEXIT)		:16 -	Enter ALternate-output-device mode
	HC	EA(TYEXIT)		:17 -	Leave ALternate-output-device mode
	HC	EA(SIIX)		:18 -	SIIX Command  **6.00 LH
	HC	EA(TIIX)		:19 -	TIIX Command  **6.00 LH
	HC	EA(TYEXIT)		:1A -	Unused
	HC	EA(TYEXIT)		:1B -	Unused
	HC	EA(TYEXIT)		:1C -	Backward TAB, used in Async
	HC	EA(TYEXIT)		:1D -	Unused
	HC	EA(TYEXIT)		:1E -	Unused
	HC	EA(TYEXIT)		:1F -	Unused

	HC	EA(QFPSIG)		:20 -	Set input baud-rate..default - DON'T
	HC	EA(QFPSIG)		:21 -	Query input baud-rate
	HC	EA(QFPSIG)		:22 -	Set output baud-rate..default - DON'T
	HC	EA(QFPSIG)		:23 -	Query output baud-rate
	HC	EA(SFPSIG)		:24 -	Set Parameter A
	HC	EA(QFPSIG)		:25 -	Query Parameter A
	HC	EA(SFPSIG)		:26 -	Set Parameter B
	HC	EA(QFPSIG)		:27 -	Query Parameter B
	HC	EA(SFPSIG)		:28 -	Set Parameter C
	HC	EA(QFPSIG)		:29 -	Query Parameter C
	HC	EA(SFPSIG)		:2A -	Set Parameter D
	HC	EA(QFPSIG)		:2B -	Query Parameter D
	HC	EA(TYEXIT)		:2C -	Unused
	HC	EA(TYEXIT)		:2D -	Unused
	HC	EA(TYEXIT)		:2E -	Unused
	HC	EA(TYEXIT)		:2F -	Unused

	HC	EA(SBPSIG)		:30 -	Set Echo-control
	HC	EA(QBPSIG)		:31 -	Query Echo-control
	HC	EA(SBPSIG)		:32 -	Set Echo control-I
	HC	EA(QBPSIG)		:33 -	Query Echo control-I
	HC	EA(SBPSIG)		:34 -	Set Echo control-H
	HC	EA(QBPSIG)		:35 -	Query Echo control-H
	HC	EA(SBPSIG)		:36 -	Set Echo CR with CR/LF
	HC	EA(QBPSIG)		:37 -	Query Echo CR with CR/LF
	HC	EA(SBPSIG)		:38 -	Set Echo LF with LF/CR/RUB
	HC	EA(QBPSIG)		:39 -	Query Echo LF with LF/CR/RUB
	HC	EA(SBPSIG)		:3A -	Set CR delay
	HC	EA(QBPSIG)		:3B -	Query CR delay
	HC	EA(SBPSIG)		:3C -	Set Parity
	HC	EA(QBPSIG)		:3D -	Query Parity
	HC	EA(SBPSIG)		:3E -	Set Half-duplex
	HC	EA(QBPSIG)		:3F -	Query Half-duplex
	HC	EA(SBPSIG)		:40 -	Set X-Enable
	HC	EA(QBPSIG)		:41 -	Query X-Enable
	HC	EA(SBPSIG)		:42 -	Set Reverse X-Enable
	HC	EA(QBPSIG)		:43 -	Query Reverse X-Enable
	HC	EA(SBPSIG)		:44 -	Set KATAKANA
	HC	EA(QBPSIG)		:45 -	Query KATAKANA
	HC	EA(SBPSIG)		:46 -	Set Terminate-output on break
	HC	EA(QBPSIG)		:47 -	Query Terminate-output on break
	HC	EA(SBPSIG)		:48 -	Set Echo-ESC
	HC	EA(QBPSIG)		:49 -	Query Echo-ESC
	HC	EA(SBPSIG)		:4A -	Set Q-mode
	HC	EA(QBPSIG)		:4B -	Query Q-mode
	HC	EA(SBPSIG)		:4C -	Set space parity (SEVBIT) 4.01U
	HC	EA(QBPSIG)		:4D -	Query SEVBIT   4.01U
	HC	EA(TYEXIT)		:4E -	Unused
	HC	EA(TYEXIT)		:4F -	Unused

C.TYCC	EQ	84			:Illegal control signal

:	Illegal control-signal decoded
TYCRSH	ABORT(R8,C.TYCC)		:R5=Control signal



:		Signal processors:
:		====== ==========

:	Green-Ball
G.BALL	RBT	RP,GBO			:are we expecting a green ball?
	JER	RLINK			:no...just exit
	SBT	RP,NBO			:No-balls-out
	RBT	RP,DEM			:not Defered-Echo-Mode
	SBT	RP,ECHO			:Echo
  IF	X3ON
	SBT	RP,X3.P2
  EI
	LO	SIGNAL
	LIS	R4,LDMSIG		:send host Leave-DEM
	FO	SIGNAL
	J	SIGRSP			:send it and exit

:	Red ball
R.BALL	SBT	RP,NBO			:No-balls-out

:	Default exit fo nothing-to-do
TYEXIT	JR	RLINK			:just return

:  Transparency mode has two levels of transparency. The first is
:  7-bit echo in which 20-7f are echoed and 80-ff are handled like ESC.
:  The second is normal 8-bit echo.  A feature of the design is that
:  two enter trans can be used to clear parity and two leave trans
:  is a set space parity messge.
:	Enter transparency mode		4.01U
ETRSIG	RBT	RP,PARITY		:Clear even parity
	RBT	RP,SEVBIT		:Clear space parity
        JEFS    ETRSG2                  :We have one or two Enters - 8 bit ech
	SBT	RP,TRANSP		:Set 7 bit echo mode *sdw
	JEFS	ETRSG1		:was if already set?
ETRSG2	RBT	RP,TRANSP		:yes, go back to 8-bit echo
ETRSG1
	LO	SIGNAL
	LHI	R4,ETMSIG		:send host Enter-trans
	FO	SIGNAL
	J	SIGRSP			:send and exit

:	Leave transparency mode		4.01U
LTRSIG	RBT	RP,TRANSP		:Reset transparency mode bit
        JNFS    LTRSG2          :was one deep so set space parity
        TBT     RP,SEVBIT       :was two or zero deep 
        JNFS    LTRSG3          :was zero deep so exit
        SBT     RP,TRANSP       :was 2 deep so goto 7-bit echo
        JFS     LTRSG3
LTRSG2  SBT     RP,SEVBIT       :set space parity
	RBT	RP,PARITY	:reset even parity
LTRSG3
	LO	SIGNAL
	LHI	R4,LTMSIG		:send host Leave-trans
	FO	SIGNAL
	J	SIGRSP			:send and exit

:	Start IIX signal - following the IIX signal are either IIX global
:	messages or dialect messages.
:	The global messages are (8080!n), 8080 being the offset.
:	The dialect messages are (C080!n), C080 being the offset.

SIIX	CLHI	RP,.SPORT		:.SPORT=NAPORT
	JGER	RLINK			:if not ASYNC ports, then exit
	 IF	NAPORT
	JAL	R6,GET2BD		:get 2 bytes of IIX message
	J	SIG.A			:signal, go to signal processor
	XI	RBC,8080		:strip off offset
	THI	RBC,4000		:is it dialect message
	JN	SMDLCT			:if so, go process dialect msg
	J	SMDGLB			:else, it is global msg
	EI	:NAPORT
	

:	TIIX signal - see if TYMNET gateway selected, if so, no response
:	be sent to other end.
	GL	MCI
TIIX	
	SBT	RP,GETIIX		:set TIIX found
	JNR	RLINK			:already have a dialect
	L	R1,.VSAVE,RPI		:restore receiver filter back
	ST	R1,.VSTAT,RPI		:to the current receiver pointer
	L	R5,.LGBUF,RPI		:**6.01 LH, after IIX negotiation
	L	R6,.FTBUF,RPI		:completed, restore data saved in
	JAL	RCH,MCI			:.LGBUF back 
	L	R6,.IIXVL,RPI		:get selected dialect value
	CI	R6,8082			:if gateway selected, no response
	JER	RLINK			:otherwise, response back with
	L	RBP,.FTBUF,RPI		:selected dialect value.
	JAL	R6,SNDSIX		:send SIIX msg
	JAL	R6,SNDDSC		:send dialect selected msg
	L	R6,.IIXVL,RPI		:get selected dialect value
	CI	R6,8081			:if ascii selected, no TIIX msg
	JER	RLINK			:yes, exit
	JAL	R6,SNDTIX		:send TIIX msg
	JR	RLINK			:exit


	LO	SIGNAL
:	Set Echo-control
SECHO	NHI	RBC,1			:turn on or off?
	JEFS	SECHO1			:turn off...skip
	TBT	RP,ECHO			:turn on...check ECHO
	JN	QECHO1			:already on, just ACK
	SBT	RP,DEM			:off, let usual mechanism do it
	J	QECHO1			:...and ACK

SECHO1	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer
	RBT	RP,ECHO			:reset ECHO
	JEFS	SECHO2			:make sure it stays off
	LHI	R4,EDMSIG		:Notify host (EDEC)
	JAL	RCH,PUTSIG	
SECHO2	RBT	RP,DEM			:Disarm Green-ball stuff
	RBT	RP,GBO	
	JEFS	SECHO3			:no balls expected, go ACK
	LHI	R4,RBSIG		:GREEN-BALL is out, send RED-BALL
	JAL	RCH,PUTSIG
	RBT	RP,TBOA			:reset the RED-BALL timeouts
	RBT	RP,TBOB
SECHO3	LHI	R5,SECSIG		:Restore signal number

:	Query ECHO
QECHO	LIS	RBC,1			:Prepare for echo on result
	TBT	RP,ECHO			:is ECHO on?
	JNFS	QECHO1			:yes...
	TBT	RP,DEM			:is ECHO about to go on?
	JNFS	QECHO1			:yes, return as on
	LIS	RBC,0			:ECHO not on
QECHO1	LCS	R4,2			:make even
	NR	R4,R5
	J	SIGRSP			:go answer query

:	Set a bit parameter
SBPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,BPFAN-SECSIG,R4	:get pointer to bit array
	JER	RLINK			:ignore if null
	SBT	RP,0,R3			:turn it on
	CLHI	R4,SPRSIG		:special case for even parity
	JNFS	SBPSG1
	NHI	RBC,1
	JEFS	SBPSG1
	RBT	RP,SEVBIT		:402sdw
SBPSG1	NHI	RBC,1			:test new state
	JN	QBPSIG			:Done...report it back
	RBT	RP,0,R3			:Else turn it off again
	CLHI	R4,SRXSIG		:special case for reverse X-enable
	JNFS	QBPSIG			:no
	RBT	RP,RXON			:yes...release back-pressure
	IF	NAPORT
	JAL	R0,ARSUM		:resume async output---receive ^Q
	EI	:NAPORT

:	Query a bit parameter
QBPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,BPFAN-SECSIG,R4	:get pointer to bit array
	JER	RLINK			:ignor if null
	LIS	RBC,0			:Expect to return a zero
	TBT	RP,0,R3			:is bit on?
	JE	SIGRSP			:no...skip
	LIS	RBC,1			:yes...return a 1
	J	SIGRSP


:	Set field parameter
SFPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,FPFAN-SIRSIG,R4	:get pointer to bit array
	JER	RLINK			:ignor if null
	STB	RBC,0,R3,RP		:set new value

:	Query Field parameter
QFPSIG	LCS	R4,2			:Make even
	NR	R4,R5
	LHL	R3,FPFAN-SIRSIG,R4	:get pointer to Field array
	JER	RLINK			:ignor if null
	LB	RBC,0,R3,RP		:get the parameter

:	Send back response
SIGRSP	L	RBP,.FTBUF,RPI		:set From-terminal buffer-pointer
	JAL	RCH,PUTSIG		:return signal
	JR	RLINK			:Then exit

	FO	SIGNAL

:	Pointers to bit parameters
BPFAN	HC	ECHO			:30 -	Echo control
	HC	ECTLI			:32 -	Echo Control-I
	HC	ECTLH			:34 -	Echo Control-H
	HC	ECR.LF			:36 -	Echo LF on CR
	HC	ELF.CR			:38 -	echo CR|RUB on LF
	HC	CRDE			:3A -	carriage-return delay
	HC	PARITY			:3C -	Parity
	HC	HAFDUX			:3E -	Half-duplex
	HC	XONENA			:40 -	X-Enable
	HC	YONENA			:42 -	Reverse X-Enable
	HC	0			:44 -	KATAKANA
	HC	TSNBRK			:46 -	Terminate output on BREAK
	HC	E.ESC			:48 -	Echo-ESC
	HC	Q.MODE			:4A -	Q-mode
	HC	SEVBIT			:4C -	Space parity    4.01U
	HC	0			:4E

:	Pointers to Field parameters
FPFAN	HC	IBRATE			:20 -	Input baud-rate
	HC	OBRATE			:22 -	Output baud-rate
	HC	PAR.A			:24 -	Parameter A
	HC	PAR.B			:26 -	Parameter B
	HC	PAR.C			:28 -	Parameter C
	HC	PAR.D			:2A -	Parameter D
	HC	0			:2C
	HC	0			:2E


:	Super-hang (for Half-Duplex, 2741)
S.HANG	TBT	RP,ASCII		:test if 2741
	JE	HANGUP			:do it if so
	RBT	RP,YONENA		:normal ASCII...Disable Reverse-XON
	JER	RLINK			:not set...just exit
	RBT	RP,RXON			:was it applied?
	JER	RLINK			:no...just exit
	IF	NAPORT
	TBT	RP,ASYNC		:is it and async port
	JEFS	S.HNG0			:if not, do for SIO
	JAL	R6,A.CLRO		:else, clear async output ring
	JR	RLINK			:and exit
	EI	:NAPORT
S.HNG0	L	R0,.XSAVE,RPI		:...else set normal transmitter
	ST	R0,.XSTAT,RPI
	JR	RLINK			:and exit

:	HANG Unconditionally
HANGUP	IF	PVC
	TBT	RP,TATBIN		:is this special PVC port?
	JE	ZAPPER			:yes...HANG translates to ZAPPER
	 EI	:PVC
HANGOP                                  :to hang even if PVCs  403*sdw
	SBT	RP,HANGWT		:hang it
	 IF	TTELEX			:transparent telex
	TBT	RP,TTLXP		:transparent telex ports?
	JEFS	HANG1			:no, skip
	RBT	RP,MRKING		:spacing both directions
	SBT	RP,EMTBRK		:emitting break (space) to device
	JR	RLINK			:exit to polling routine
	 EI	:TTELEX			:** 4.02 LH
HANG1	 IF	BTELEX
	TBT	RP,BTLXP
	JEFS	HANG2			:no
	RBT	RP,FWDPTH		:yes,space forward path
	RBT	RP,MRKING		:space both directions
	SBT	RP,EMTBRK		:emit breaks
	RBT	RP,VB.ACP		:virtual telex port not active for now
	RBT	RP,RECWRU		:clear receiving wru
	RBT	RP,WRUT1		:clear WRU timmers
	RBT	RP,WRUT0
	 EI	:BTELEX
HANG2	JR	RLINK			:and exit

:	zapper
:	RLINK need not be preserved
:	**6.00 LH There are four steps to handle zap on IIX capable circuit.
:	1. Check parity control byte to set parity for loaded message.
:	2. Move loaded message from .IIXBF to .TTBUF.
:	3. Restore old parity.
:	4. Send zap signal to .TTBUF, then exit via XRET

ZAPPER	TBT	RP,TOIIX		:**6.00 LH if use IIX capability
	JE	ZAP7
	LO	SIGNAL
	LB	RBC,.IXPAR,RPI		:get parity control byte
	JE	ZAP3			:if control=00, stay in current state
	CHI	RBC,01			:control=1 - null parity ?
	JN	ZAP1			:no, skip to check further
	LHI	R4,ETMSIG		:put two enter-transparency signals
	L	RBP,.TTBUF,RPI		:to to-terminal buffer
	JAL	RCH,PUTSIG		:to become normal 8-bit echo
	JAL	RCH,PUTSIG
	J	ZAP3			:jump to move loaded message
ZAP1	CHI	RBC,02			:control=2 - space parity ?
	JN	ZAP2			:no, skip to check further
	LHI	R4,LTMSIG		:put two leave-transparency signals
	JAL	RCH,PUTSIG		:to to-terminal buffer
	JAL	RCH,PUTSIG		:to become space parity
	J	ZAP3
ZAP2	CHI	RBC,03			:control=3 - even parity ?
	JN	ZAP3			
	LHI	R4,SPRSIG		:put even-parity signal to set
	JAL	RCH,PUTSIG		:even parity
ZAP3	L	R5,.IIXBF,RPI		:move data in source buffer
	L	R6,.TTBUF,RPI		:into destination buffer
	GL	MCI
	JAL	RCH,MCI
	TBT	RP,SEVBIT		:is old parity space ?
	JEFS	ZAP4			:no, check further
	LHI	R4,LTMSIG		:put two leave-transparency signals
	JAL	RCH,PUTSIG		:to restore back to space parity.
	JAL	RCH,PUTSIG
	J	ZAP6
ZAP4	TBT	RP,PARITY		:is old parity even ?
	JEFS	ZAP5			:no, check further
	LHI	R4,SPRSIG		:put even-parity signal
	JAL	RCH,PUTSIG		:to restore back to even parity
	JFS	ZAP6
ZAP5	LHI	R4,ETMSIG		:old parity neither space nor even
	JAL	RCH,PUTSIG		:to restore back to null parity
	JAL	RCH,PUTSIG		
ZAP6	LHI	R4,ZAPSIG		:send zap signal again then exit
	JAL	RCH,PUTSIG
	FO	SIGNAL
	J	XRET			:via XRET
ZAP7
	IF	OUTDIA			:outdial zapper is a hang
        RBT     RP,OT.AP                :but only for outdial conns
        JN      HANGOP                  :knock em off
        EI
	RBT	RP,DEM			:Turn off DEM
	RBT	RP,ECHO			:echo off
	RBT	RP,KATAKN               :turn off katakana processing
	RBT	RP,KATERM               :turn off katakana processing
	RBT	RP,TRANSP		:turn off transparency  4.01U

:	Alternate entry for 2741
XZAP	JAL	RLINK,CIRDIS		:insure circuit disconnected
	LA	RLINK,XDEF		:set return address
	RBT	RP,GBO			:no green-ball out
	SBT	RP,NBO			:no ball out
	RBT	RP,E.ESC		:turn off Echo-ESC
	RBT	RP,Q.MODE		:turn off Q-mode
	LCS	R9,4			:assume "Logon aborted..."
	RBT	RP,LOGING		:is LOGING set?
	JN	XLSTAT			:yes...exit via special handlers
	 IF	NPAPRT
	GL	PA.SL
	JAL	R0,PA.SL		:set limbo if required
	 EI	:NPAPRT
	LHL	R1,.TERMT,RPI		:test terminal type
	LHL	R1,VID.IZ,R1		:get initialization routine
	LHI	R5,SPECFE		:set IIX capable **6.00 LH
	J	BASE,R1,,

:	Gobbler
:	RLINK need not be preserved
GOOBER	RBT	RP,TOSING		:keep this reset
	J	XDEF			:and exit

:	Bounce a ball back
BOUNCE	LIS	R4,1			:Return its complement
	XR	R4,R5
	L	RBP,.FTBUF,RPI		:Place in from-terminal buffer
	JAL	RCH,PUTSIG
	JR	RLINK			:then exit


	SUBTTL	(CONSAT) ASYNC TERMINAL IDENTIFIER/INITIALIZER

	 IF	NAPORT

:	ASYNC Terminal-IDentifier and Port-Initializer
:	===== =================== === ================
AVID	JAL	RCH,AGETCH		:get input
	 J	AVID1			:skip if control-signal
	JR	RLINK			:Ignor anything not a control

	LO	SIGNAL
AVID1	CLHI	R5,TIBSIG		:check for TID
	FO	SIGNAL
	JNR	RLINK			:ignore all but those
	CLHI	RBC,0F			:Check for valid Baud-rate index
	JGR	RLINK			:Ignore...not valid
	STB	RBC,IBRATE,RP		:Save input baud-rate guess
	STB	RBC,OBRATE,RP
	JAL	RCH,AGETCH		:get TID char
	 J	0,RLINK			:control-signal...ignor
	LHI	R5,1F			:mask off lower 6 bits of TID char
	NR	R5,RBC
	LB	RBC,IBRATE,RP		:get input baud rate
	EXBR	R5,R5
	OR	RBC,R5			:TID char in next higher byte
	LHI	R4,-VID.SZ		:now scan table for match
AVID2	AHI	R4,VID.SZ
	LHL	R3,VID.TI,R4
	JN	AVID3
	JAL	R6,A.CLR		:clear current PTYTID msg
	LB	RBC,OBRATE,RP	:current output rate
	JAL	RBF,A.OBR		:this is like A.ANS but RLINK is ok
	JAL	RBF,A.TID		:Exit..no match found for TID character
	L	RBP,.TTBUF,RPI		:send "please type..' again*500.sdw
	JAL	RCH,EMPTY		:dont want to see rest of old msg
	LA	R6,LSMS0
	TBT	RP,TSPPAR
	JEFS	AVID01
	JAL	R9,MSGSP		:in space par if requested
	JR	RLINK
AVID01	JAL	R9,MSG
	JR	RLINK

AVID3	SR	R3,RBC
	JN	AVID2			:continue if no match
        JAL     R6,A.CLRO               :clear rest of "pleas.." and set TAM
	SBT	RP,C.ACP		:id accepted..set port active
	SBT	RP,AH.TO		:cancel timeouts
	SBT	RP,AH.TO1
	SBT	RP,AH.TO2
	LHL	RLINK,VID.IZ,R4		:locate initialization routine
	JAL	R5,IZPORT		:set up CONSAT terminal parameters
  IF	X3ON
	JAL	RBF,IXPROF,,		:set up PAD terminal parameters
  EI	:X3ON
	L	RBP,.TTBUF,RPI		:set to-terminal buffer-pointer
	JAL	RCH,EMPTY		:Clear  the "Please typ..." message
	JAL	R9,A.VID		:set it up
	LHI	R5,SPECFE+$4000		:IIX and extended login status **6.00 LH
	JAL	RLINK,BASE,RLINK,	:and initialize the port...
					:	(nominally, Establish the port
					:	with new TID)
	J	VRET			:exit back to polling process
	
	SUBTTL	(CONSAT) ASYNC DRIVER CODE -- ASCII

:	This code contains the ASCII async drivers 
:

CTLQS	WC	00005000,0,0,0		:^Q (11=XON) and ^S (13=XOFF)
	WC	0,0,0,0			:91 and 93 don't qualify

CTLNO	WC	00030000,0,0,0		:^N (F=SHIFT OFF) ^O (E=SHIFT ON) 
	WC	0,0,0,0			:9E and 9F don't qualify

LCCHR	WC	0,0,0,7FFFFFE0		:lower case a-z (0) parity
	WC	0,0,0,7FFFFFE0		:lower case a-z (1) parity
	EI	:NAPORT

:	New receiver to reset the port being polled
:	so that data in driver will not be fetched.
	GL	P.VASC
P.VASC	LR	R0,RP			:copy the port number
	NHI	R0,0F			:POLLing halfword by halfword
	RBT	R0,POLTMP		:don't serve the port in POLLing
	J	VRET			:**6.02 LH

	IF	NAPORT
:
:	Full-Duplex ASCII Terminal Receiver
:	=========== ===== ======== ========
VASCI	JAL	RCH,AGETCH		:get the char
	 J	VAESC			:Control-signal
	LR	R9,RBC			:data -- copy it
	TBT	RP,TRANSP		:if in transparency mode  4.01U
	JNFS	VAS100			:do not mask character    4.01U
	NHI	RBC,7F			:Input Char in R9, Working Char in RBC
VAS100
   IF	X3ON

:	...break key emulation for PAD
	CH	RBC,X3.N3,RPI		:X3.N3=-1, if break emulation off
	JNFS	VAS110			:no break, skip break logic
	L	R3,.ESIGF,RPI		:get signal editor
	JEFS	VAS110			:if not involve signal editor
	 LO SIGNAL
	LIS	R4,BBSIG		:yes, treat it as <break> detected
	 FO SIGNAL	
	JALR	RCH,R3			:invoke editor
	J	VRET			:and return to polling loop
  EI	:X3ON

:	...flow control code
VAS110	TBT	RBC,CTLQS		:CAB 6.00 - check if ^Q or ^S
	JEFS	VAS200			:no, not a flow control char, skip
	TBT	RP,YONENA		:is reverse XON/XOFF enabled?
	JEFS	VAS200			:no, skip reverse backpressure code
	CHI	RBC,11			:check for ^Q (XON)
	JNFS	VAS120			:not ^Q, must be ^S
	JAL	R0,VARSUM		:^Q...enable transmitter
	JFS	VAS200			:if already reset, then ^Q is data
VAS120	JAL	R0,VASTOP		:^S...disable transmitter
					:if already set, then ^S is data

:	...katakana code for JIS-7 translation to JIS-8
VAS200	TBT     RP,KATAKN               :katakana port?
        JE      VAS300                  :no, skip
	TBT	RP,TRANSP		:6.00 CAB - 8 bit transparent mode?
	JN	VAS300			:transparent, so skip special code
        CLHI    RBC,21                  :control char or data char?
        JGE     VAS230			:data char, go check shift mode
	LR      R9,RBC                  :control char, send 00-20, not 80-A0
	TBT	RBC,CTLNO		:shift char? (^N or ^O)
	JE	VAS300			:no
	RBT     RP,KATERM               :yes, assume ^N (shift off char)
        CLHI    RBC,0E                  :check for ^N
	JEFS	VAS210			:yes 
        SBT     RP,KATERM               :no, must be ^O, set shift on
VAS210	L       RBP,.TPBUF,RPI    	:get the echo buffer pointer 
        JAL     RCH,PUTCHR		:put char into buffer
        J       VRET			:and exit

VAS230	LR      R9,RBC                  :remove high bit
	TBT     RP,KATERM               :shift on?
	JEFS	VAS300			:shift off, just send char
	OHI     R9,80                   :shift on, set high bit
	CLHI    R9,0E0                  :lower case Katakana?
        JLFS	VAS300			:no, just send char
        NHI     R9,0DF                  :convert to uppercase

:	...echo logic
VAS300	TBT	RP,ECHO			:Echoing?
	JN	VAECKO			:yes, take alternate route
	RBT	RP,GBO			:We're not echoing
	JE	VASEND			:No green-ball out
	RBT	RP,TBOA
	RBT	RP,TBOB			:Reset red-ball timeout
	 LO	SIGNAL
	LIS	R4,RBSIG		:Red-ball signal
	 FO	SIGNAL
	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer
  IF	X3ON
	L	R3,.ESIGF,RPI		:Editor, if needed
	JEFS	VAS310			:no
	JALR	RCH,R3			:yes, invoke signal filter
	JFS	VASEND
VAS310
  EI 	:X3ON
	JAL	RCH,PUTSIG		:send signal toward network

:	Send the data (in R9) into net
VASEND	L	RBP,.FTBUF,RPI		:from-terminal buffer-pointer
VSS0    LR      RBC,R9                  :get the char
  IF	X3ON
	L	R3,.ECHRF,RPI		:edit filter (if any)
	JEFS	VSS02			:no
	JALR	RCH,R3			:yes, invoke character filter
	J	VRET
VSS02
  EI	:X3ON
	JAL	RCH,PUTCHR
	J	VRET			:and exit

VAECKO	TBT	RP,HAFDUX		:Half-Duplex?
	JN	VAHD
	TBT	RP,TOPRTP		:6.00 - CAB is output pending?
	JN	VAED			:Yes, skip echo
	TBT	RP,RXON			:has user applied backpressure?
	JN	VAED			:yes, skip echo
	THI	RBC,80			:if hi bit set, then transparent 4.01U
	JN	VAED			: and should enter DEM  4.01U
	TBT	RBC,.ECHT1,RPI		:Is it easily printable?
	JN	VAN			:No, Check special cases

:	Echo (single) character
VAK1	LR	RBC,R9			:Get the character
VAK2	L	RBP,.TPBUF,RPI		:set echo buffer-pointer
	JAL	RCH,PUTCHR		:...and echo it
	J	VASEND			:....then go send it

:	VASTOP - PROCESS XOFF 
:	link on r0
:	exit on r0 if data
:	exit on rlink if flow control char
:
VASTOP	SBT	RP,RXON			:6.00 - CAB
	JNR	R0			:already set, must be data
	RBT	RP,QDDAT		:tell ISIS no data to output
	JER	RLINK			:no data, just return to POLL
	SBT	RP,OUTMSK		:keep record, if data to output
	JR	RLINK			:and return to POLL

:	VARSUM - PROCESS XON
:	link on r0
:	exit on r0 if data
:	exit on rlink if flow control char
:
VARSUM	RBT	RP,RXON			:
	JER	R0			:already reset, must be data
	RBT	RP,OUTMSK		:was there data to output
	JER	RLINK			:no data, just return to POLL
	SBT	RP,QDDAT		:tell ISIS data to output
	JR	RLINK			:return to POLL

:	Handler for "Q"-mode
:	Echo "~" and "}"
:	Don't echo LF
:	Echo Cr (with LF) if Echo_on_LF set...
:		THEN ENTER DEM!!!
VAQ	LHI	R0,-7D,RBC		:is it "}"?
	JE	VAK1			:yes...echo it
	SIS	R0,7E-7D		:is it "~"?
	JE	VAK1			:yes...echo it
	LHI	R0,-0A,RBC		:LF?
	JE	VAED			:yes...enter DEM
	SIS	RBC,0D			:CR?
	JN	VAN2			:no...treat as non-Q char
	TBT	RP,ELF.CR		:yes...should we echo?
	JE	VAED			:no
	L	RBP,.TPBUF,RPI		:yes, set echo buffer-pointer
	LR	RBC,R9			:echo CR
	JAL	RCH,PUTCHR
	TBT	RP,ECR.LF		:Line-feed needed too?
	JEFS	VAQ1			:no
	LIS	RBC,0A			:yes...echo it
	JAL	RCH,PUTCHR		:echo CR/LF for CR
VAQ1	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
  IF	X3ON
	TBT	RP,PADARY		:is this a PAD port?
	JEFS	VAQ2			:no
	LIS	RBC,1			:prepare to increment chr counter
	AHM	RBC,P.BCT,RPI		:increment chr counter *6.02 dlg
	L	RBP,.FEDBF,RPI		:yes, get edit buffer pointer
VAQ2	
  EI	:X3ON
	LR	RBC,R9			:and send the CR
	JAL	RCH,PUTCHR
	JAL	RCH,GO.EDM		:go enter DEM
	J	VRET			:and exit


:	non-printable (?) char on echo...
VAN	TBT	RP,Q.MODE		:"non-printable"...is port in "Q"-mode?
	JN	VAQ			:yes...do it
	TBT	RBC,SPABLE		:special?
	JE	VAED			:no...go enter DEM
	SIS	RBC,0A
	JNFS	VAN1			:Not a LF
	TBT	RP,ELF.CR		:Carriage return needed too?
	JE	VAK1			:echo LF for LF
	LI	R6,7F0D00,R9
	J	VAEK1			:echo LF/CR/RUBOUT
VAN1	SIS	RBC,0D-0A		:CR?
	JNFS	VAN2			:not a CR
	TBT	RP,ECR.LF		:Line-feed needed too?
	JE	VAK1			:Echo CR for CR
	LI	R6,0A00,R9
	J	VAEK1			:echo CR/LF for CR

VAN2	AIS	RBC,0D-9		:^I? (may also enter from VAQ)
	JNFS	VAN3
	TBT	RP,ECTLI
	JE	VAED			:Didn't echo tabs
	J	VAK1
VAN3	AIS	RBC,9-8			:^H?
	JNFS	VAN4
	TBT	RP,ECTLH
	JE	VAED			:don't echo ^H
	J	VAK1
VAN4    SIS     RBC,0E-8                :shift on for katakana
        JNFS    VAN5
        TBT     RP,KATAKN               :must be katakana port
        JEFS    VAN5
        J       VAK1
VAN5    SIS     RBC,0F-0E               :shift off for katakana
        JNFS    VAN6
        TBT     RP,KATAKN               :must be katakana
        JEFS    VAN6
        J       VAK1
VAN6	SIS	RBC,1B-0F		:ESC?
	JNFS	VAED
	TBT	RP,E.ESC
	JN	VAK1			:Echo-ESC

:	Output-buffer busy - can't echo...enter DEM
VAED	JAL	RCH,GO.EDM		:go enter DEM
	J	VSS0			:send data


:	Echo a (reverse) string of characters in R6
:	(original char in R9)
VAEK1	L	RBP,.TPBUF,RPI		:get echo buffer-pointer
VAEK2	LR	RBC,R6			:get a copy
	JAL	RCH,PUTCHR		:echo it
	SRLS	R6,8			:get next character...
	JNBS	VAEK2			:...If any (up to three)
	J	VASEND			:...then go send char and exit

VAHD	TBT	RBC,SPABLE		:Half-duplex...special char?
	JE	VASEND			:no...just go send it
	LHI	R3,-0D,RBC		:Carriage return?
	JNFS	VAHD1			:skip if not
	TBT	RP,ECR.LF		:yes...echo line-feed?
	JE	VASEND			:no...just send char
	LIS	RBC,0A			:else return line-feed
	J	VAK2			:echo it

VAHD1	AIS	R3,0D-0A		:line-feed?
	JN	VASEND			:no, just send char
	TBT	RP,ELF.CR		:yes...echo with CR|RUB?
	JE	VASEND			:no, just send it
	LHI	R6,7F0D			:yes
	J	VAEK1			:echo string of characters

	 LO	SIGNAL
VAESC	CLHI	R5,BBSIG		:Break?
	 FO	SIGNAL
	JNR	RLINK
	L	R0,.VSTAT,RPI		:Save Vstate
	ST	R0,.VSAVE,RPI
	LA	R0,VASBK		:Set VASBK as receiver
	ST	R0,.VSTAT,RPI		:...until we get end-break
	SBT	RP,BRK			:record break occuring
	 IF	1-NHNGBK
	RBT	RP,BRKTO		:insure no early expiration
	SBT	RP,BRKTO1		:...and start timeout
	 EI	:1-NHNGBK
	JR	RLINK


:	Receiver for BREAK-state
:	======== === ===========
:	Hang user if 2 seconds of BREAK, unless NHNGBK set
:	Return to normal ASCII Receiver when we detect end-BREAK
VASBK	JAL	RCH,AGETCH		:Get something (BREAK/end-BREAK signal)
	 J	VASBK1			:control-signal...skip
	JR	RLINK			:non-control...eat it

	 LO	SIGNAL
VASBK1	SIS	R5,BESIG		:end-BREAK?
	JNR	RLINK			:still breaking...just eat signal
	LIS	R4,BBSIG
	 FO	SIGNAL
	L	R0,.VSAVE,RPI
	ST	R0,.VSTAT,RPI		:return to normal receiver
	RBT	RP,BRK			:turn off BREAK-flag
	SBT	RP,ATTN			:turn on ATTN
	L	RBP,.FTBUF,RPI		:set to-net buffer
  IF	X3ON
	L	R3,.ESIGF,RPI		:get signal filter pointer
	JEFS	VASBK5			:none
	ST	RLINK,TXTSAV		:save RLINK
	JALR	RCH,R3			:invoke signal filter
	L	RLINK,TXTSAV		:restore RLINK
:    ??????  JUMP VRET MIGHT BE EASIER   ??????
	JR	RLINK			:return
VASBK5
  EI	:X3ON
	JAL	RCH,PUTSIG		:just send break-signal to network
	TBT	RP,TSNBRK		:enabled the flush-flag?
	JER	RLINK			:exit if not 
	SBT	RP,TOSING		:set the flush-flag
	JR	RLINK			:and exit



:		Transmitters
:		============
:	Transmitter to delay output
:	=========== == ===== ======
:XASWT	LIS	R5,3			:set .1 second delay
:	JAL	RCH,ADELAY
:	J	XDEF			:and defer output




:	Full-duplex ASCII transmitter
:	=========== ===== ===========
XASCI	HS
:	The following check for reverse backpressure seems rather
:	inefficient since the check is executed for every character
:	processed by XASCI.  Using an alternate transmitter when the
:	port has backpressured the network seems better (CAB 6/14/86).
:
	TBT	RP,YONENA		:is reverse backpressure enabled
	JEFS	XAS100			:if disabled, continue to xmit
	TBT	RP,RXON			:is ^S set
	JEFS	XAS100			:if not, continue to xmit
	JAL	RCH,CPEEK		:else, look for signals pending
	J	XDEF			:no...delay before trying again
XAS100
  IF	X3ON
	L	R3,.XPADF,RPI    	:get PAD filter pointer
	JEFS	XAS110			:none
	JALR	RCH,R3			:invoke PAD filter 
	 J	SIG.A			:normal return...It's a signal
	JFS	XAS120			:skip return...data
XAS110
  EI
	JAL	RCH,GETCHR		:get the data	
	 J	SIG.A			:normal return...It's a signal
XAS120					:skip return...data

  IF	NUMPRN		
	CLH	RP,PRTACT		:check for async port
	JGFS	XAS130			:no...just skip
	CLHI	RBC,82			:old-style set-printer-mode (^B)?
	JNFS	XAS130			:no...skip
	LH	R0,.TERMT,RPI		:check terminal type
	CHI	R0,TID.14-VID.TI	:if POS terminal, ^B is STX
	JN	TYEAOD			:not POS, ^B is set-printer-mode
  EI	:NUMPRN
XAS130					:**6.00 LH
	TBT	RP,TOSING		:Are we tossing data?
	JNR	RLINK			:do this until gobbler resets
:	transmit the character
	LR	R0,RBC			:make another copy of data-char
	NHI	R0,7F			:Remove MSB
  IF	.2HD
	TBT	RP,HD202		:Half duplex port?
	JEFS	XAS140
	SBT	RP,HAFDUX		:set this port half-duplex
	CHI	R0,TLTA			:encounter xmit-LTA ready to turn line
	JE	XASLTA
XAS140
  EI	:.2HD
	TBT     RP,KATUPC               :uppercase only?
        JEFS    XAS200			:no
	TBT	R0,LCCHR		:check if lower case char
	JEFS	XAS200			:no 
        NHI     R0,0DF                  :yes, so make uppercase
        NHI     RBC,0DF                 :and for nonparity ports

:	...katakana code for JIS-8 translation to JIS-7
XAS200	TBT	RP,KATAKN               :katakana port?
        JE      XAS300                  :no, skip
	TBT	RP,TRANSP		:6.00 CAB - transparency mode?
	JN	XAS300			:yes, skip
        CLHI    R0,20                   :control char?
        JGE     XAS210			:no
	TBT	R0,CTLNO		:yes, now check for ^O or ^N
	JE	XAS300			:no, skip shift logic
        RBT     RP,KATCAS               :assume shift off (^N)
        CLHI    R0,0E                   :shift off key?
        JE	XAS300                  :yes
        SBT     RP,KATCAS               :no,  must be shift on (^O)
	J       XAS300			:

XAS210  CLHI    RBC,80                  :did we get an uppercase char?
        JL      XAS230                  :no, they got a lower case
        TBT     RP,KATCAS               :which logic state are we in
        JN      XAS300                  :already in upper
        SBT     RP,KATCAS               :set uppercase
        EXBR    RBC,R0			:
        AIS     RBC,0E                  :send shift on
        TBT     RP,PARITY               :even parity?
        JEFS    XAS220			:
        OHI     RBC,80                  :set since 0E is 0000 1110
XAS220  JAL     RCH,APUTCH              :Send it
        EXBR    R0,RBC			:
        NHI     R0,7F                   :remove 0E or 8E
        JFS     XAS240			:
XAS230  TBT     RP,KATCAS               :got lower case char - which l-state
        JEFS    XAS300                  :already in lower - bye
        RBT     RP,KATCAS               :clear case
        EXBR    RBC,R0                  :save R0
        AIS     RBC,0F                  :send shift off
        JAL     RCH,APUTCH              :send it
        SIS     RBC,0F                  :0F is both space and even parity
        EXBR    R0,RBC                  :restore R0
XAS240  LR      RBC,R0                  :remove garbage from rbc

XAS300	TBT	RP,SEVBIT	: are we forcing space parity?  4.01U
	JEFS	XAS310		: if yes			4.01U
	LR	RBC,R0		:  then use seven bit character 4.01U
	J	XAS320		:       and continue		4.01U
XAS310	TBT	RP,PARITY		:Parity enabled?	4.01U
	JEFS	XAS320
	LR	RBC,R0			:yes...set char with parity-bit off
	TBT	R0,PARBIT		:lookup parity
	JEFS	XAS320
	OHI	RBC,80			:turn parity-bit on if appropriate
XAS320	TBT	R0,SPABLE		:is it special?
	JEFS	XAS2			:no...just go output it
	SIS	R0,0D			:Carriage return?
	JE	XASCR
	AIS	R0,0D-0A		:LF?
	JE	XASLF
	AIS	R0,0A-09		:^I?
	JNFS	XAS2			:no
	LH	R0,MARGE,RPI		:yes
	OHI	R0,7			:force position to multiple of 8
	STH	R0,MARGE,RPI

XAS2	JAL	RCH,APUTCH		:transmit the character
	MINH(RBF,MARGE,RPI)		:count it
	JR	RLINK



:	Carriage return
XASCR	TBT	RP,CRDE			:delay needed?
	JE	XAS.PD			:nope...just output (with Parameter D)
	JAL	RCH,APUTCH		:First send it
	LB	R4,PAR.A,RP		:DELAY=MIN(B+N/2**A,CPARAM(C))
	LB	R0,PAR.B,RP		:Parameter B
	LB	R3,PAR.C,RP		:Parameter C
	LB	R5,MARGE+1,RPI		:N/2**A
	SRL	R5,0,R4
	AR	R5,R0
	CLB	R5,CPARAM,R3
	JLEFS	XASCR1
	LB	R5,CPARAM,R3
XASCR1	JAL	RCH,ADELAY		:Set up delay
	JR	RLINK

:	Output CR|LF with parameter D
XAS.PD	JAL	RCH,APUTCH		:send it
	MINH(R5,MARGE,RPI)		:Count it
	LB	R5,PAR.D,RP		:and follow it with Parameter D
	LB	R5,CPARAM,R5
	JAL	RCH,ADELYG		:ALt entry to ADELAY, saves MARGE
	JR	RLINK


:	Line-Feed
XASLF	TBT	RP,CRDE			:Delay needed?
	JN	XAS.PD			:no...output (with Parameter D)
	LB	R3,MARGE+1,RPI		:yes...need to generate LF delay
	STB	RBC,LASTCH,RP		:save a copy of the character
	CLHI	R3,1
	JGFS	XASLF1
	LB	R5,PAR.A,RP		:Column 1...Delay is Parameter A
	JFS	XASLF3

XASLF1	LB	R5,PAR.C,RP		:DELAY=B+MAX(CPARAM(C)-NCHAR,0)
	LB	R5,CPARAM,R5		:Parameter C
	SR	R5,R3
	JGEFS	XASLF2
	LIS	R5,0
XASLF2	LB	R4,PAR.B,RP		:add Parameter B
	AR	R5,R4

XASLF3	JAL	RCH,ADELAY		:Set delay
	LB	RBC,LASTCH,RP		:restore the character
	JAL	RCH,APUTCH		:and send line-feed
	JR	RLINK

:	SIG.A:	Signal Processor for ASYNC
:	=====

:	Called from ASYNC transmitter to process control signals

:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.A	SIGBGN(LADSIG)				: 4.01U
	SIGEXC(ZAPSIG,ZAP.A)		:zapper
	SIGEXC(DELSIG,DELY.A)		:delay + V
	SIGEXC(EADSIG,TYEAOD)		:Enter alternate-output-device
	SIGEXC(SIRSIG,SIBRAT)		:Set input baud-rate
	SIGEXC(SORSIG,SOBRAT)		:Set output baud-rate
	SIGEXC(SPASIG,SFPSIG)		:Set Parameter A
	SIGEXC(SPBSIG,SFPSIG)		:Set Parameter B
	SIGEXC(SPCSIG,SFPSIG)		:Set Parameter C
	SIGEXC(SPDSIG,SFPSIG)		:Set Parameter D
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	 IF	NUMPRN
	SIGEXC(SKKSIG,PRSKK)		:Set KATAKANA
	SIGEXC(QKKSIG,PRQKK)		:Query KATAKANA
	 EI	:NUMPRN
   IF X3ON
	SIGEXC(BTBSIG,BCKTAB)		:Backward TAB
   EI 	:X3ON
	SIGEND

   IF X3ON
	GL	WCD,CARPOS
:	BACKWARD TAB, USED IN PAD TO ERASE A TAB ON USER'S TERMINAL

BCKTAB	ST	RCH,BTBSAV		:SAVE REGISTERS-remove RX3*403-sdw
	ST	RLINK,BTBSAV+4

	LB	R4,.OFHTX,RPI		:GET OFFSET TO TAB EXP. COUNT TABLE
	JNFS	BCKTB2			:NOT ZERO, BRANCH
	LHI	R4,HTXSIZ		:WAS ZERO, WRAP AROUND
BCKTB2	SIS	R4,1			:BACK UP ONE ENTRY IN TABLE
	STB	R4,.OFHTX,RPI		:AND SAVE THE OFFSET
	L	R3,.TBHTX,RPI		:GET ADDRESS OF TTHE TABLE
	AR	R3,R4			:GET ADDRESS WHERE EXP. COUNT WAS SAVED
	LB	R4,0,R3			:GET # OF <BS> TO SEND IN R4
	JNFS	BCKTB4			:NON ZERO, FINE
	ABORT(R3,91)			:ZERO, SOMETHING IS WRONG, TEMP. 
BCKTB4	LB	R3,CARPOS+1,RPI	:GET CURRENT CURSOR POSITION
	JER	RLINK			:DO NOTHING IF ZERO
BCKTB6	LHI	RBC,08			:<BACK SPACE>
	ST	R3,BTBSAV+8
	ST	R4,BTBSAV+0C
	JAL	RCH,WCD,,		:WRITE TO BEGINING OF BUFFER
	L	R3,BTBSAV+8		:
	L	R4,BTBSAV+0C
	SIS	R3,1			:UPDATE CURSOR POSITION
	JEFS	BCKTB8			:STOP IF ZERO
	SIS	R4,1			:MORE <BS> TO OUTPUT
	JN	BCKTB6			:YES, BRANCH
BCKTB8
	L	RCH,BTBSAV		:
	L	RLINK,BTBSAV+4	:RESTORE REGISTERS
	JR	RLINK
  EI   X3ON

DELY.A  LR	R5,RBC
	JAL     RCH,ADELYG              :Allow use of delay signals in tymfile
        JR      RLINK                   :4.02 sdw


:	zapper
ZAP.A	TBT	RP,YONENA		:is XON/XOFF feature enabled?
	JE	ZAPPER			:no
	RBT	RP,RXON			:yes...active?
	JE	ZAPPER			:no
	JAL	R6,A.CLRO		:else, go clear async output 
	J	ZAPPER			:and proceed

:	Set input baud-rate
SIBRAT	TBT	RBC,A.SPED		:is new speed supported?
	JE	QFPSIG			:no...just go respond
	CLHI	RBC,20			:range-check on new value  *6.02 dlg
	JGE	QFPSIG			:tested something other than A.SPED
	STB	RBC,IBRATE,RP		:update input rate
	JAL	RBF,A.IBR
	J	QFPSIG			:go ACK

:	Set output baud-rate
SOBRAT	TBT	RBC,A.SPED		:is new speed supported?
	JE	QFPSIG			:no...just go respond
	CLHI	RBC,20			:range-check on new value  *6.02 dlg
	JGE	QFPSIG			:tested something other than A.SPED
	STB	RBC,OBRATE,RP		:update output rate
  IF	X3ON
	LB	R0,TBR.CC,RBC,		:get translated value
	STB	R0,X3.P11,RPI		:update X.3 parm 11 value
  EI	:X3ON
	JAL	RBF,A.OBR
	J	QFPSIG			:go ACK

:	Enter-alternate-output-device mode
	 IF	NUMPRN
TYEAOD	CLH	RP,PRTACT		:is this a printer-port?
	JGR	RLINK			:no, so ignore
	LA	R0,XPRINT		:set new driver
	ST	R0,.XSTAT,RPI
	GL	PINIT
	JAL	RCH,PINIT,,		:initialize printer
	TBT	RP,DEM			:Insure now in DEM
	JNR	RLINK			:already ok
  IF	X3ON
	LCS	R9,1		:fake non character
  EI	:X3ON
	JAL	RCH,GO.EDM		:have to do it
	JR	RLINK			:and exit
	 ELSE	:NUMPRN
TYEAOD	EQ	TYEXIT			:just exit
	 EI	:NUMPRN

	SUBTTL	(CONSAT) ASCII IIX GLOBAL MESSAGE PROCESSOR
	
	LO	IIX

MAXGLB	EQ	7
SMDGLB	CHI	RBC,MAXGLB		:is this a valid messag
	JG	PRBSM			:if not, report to Probe
	LHL	R5,GLBVAL,RBC,RBC	:get service routine
	J	BASE,R5,,		:go do it

GLBVAL	HC	EA(SLTDSM)		:8080 - select dialect command
	HC	EA(SLTRSM)		:8081 - selected dialect response
	HC	EA(SMTGSM)		:8082 - gateway reached smart host
	HC	EA(DUMGSM)		:8083 - gateway reached dumb host
	HC	EA(LGSTSM)		:8084 - normal logon status
	HC	EA(RSYNSM)		:8085 - resyncronize interface exchange
	HC	EA(PRODSM)		:8086 - product id and version
	HC	EA(REQPSM)		:8087 - request product id and version

PRBSM	LHI	R0,14			:set Probe report value for S-mode
	STB	R0,PROBVL
	JAL	RCH,PROBMG		:send message to Probe
	JR	RLINK

SLTDSM	RBT	RP,PADIIX		:not X.29 IIX dialect capable
	RBT	RP,TLXIIX		:not transparent IIX dialect capable
	SBT	RP,GATIIX		:gateway IIX dialect capable
	SBT	RP,SMDIIX		:S-mode IIX dialect capable
	SBT	RP,ASCIIX		:ASCII dialect capable
	RBT	RP,GETIIX		:no TIIX found yet 
	JAL	R4,SELDLT		:go to select dialect value routine
	J	SIG.A			:process signals
	JR	RLINK			:exit

SLTRSM	JAL	R6,GET2BD		:read 2 bytes, take no action
	J	SIG.A			:process signals
	JR	RLINK			:exit

SMTGSM	SBT	RP,IIXCAP		:the other end is IIX capable*6.02LH
	JR	RLINK			:exit

DUMGSM	RBT	RP,IIXCAP		:the other end is not IIX capable*6.02LH
	JR	RLINK			:exit

LGSTSM	JAL	R4,LOGSTA		:go to process logon-status
	J	SIG.A			:process signals

RSYNSM	JR	RLINK			:exit

PRODSM	JAL	R4,PRODCT		:get product ID and version
	J	SIG.A			:process signals
	JR	RLINK			:exit

REQPSM	JAL	R4,REQPRD		:response ID requested
	JR	RLINK			:exit
	


	SUBTTL	(IIX) ASCII ASYNC IIX DIALECT MESSAGE PROCESSOR

:	Called from IIX message preprocessor to process ASCII ASYNC
:	IIX dialect messages.

	GL	PRBSM,MCI
SDLCT0	EQ	0			:clear message dialect
SDLCT1	EQ	1			:loaded message dialect
MAXSDL	EQ	SDLCT1

SMDLCT	L	R3,.IIXVL,RPI		:has dialect been selected
	CI	R3,8093			:8093 value for ASCII async dialect
	JN	PRBSM			:no, report error to Probe
	XHI	RBC,4000		:strip off dialect msg indicator
	CHI	RBC,MAXSDL		:is it a valid msg
	JG	PRBSM			:if not, report error to Probe
	LHL	R5,DLTMSG,RBC,RBC	:get processing routinne
	J	BASE,R5,,		:go do it

DLTMSG	HC	EA(CLRLMG)		:C080= clear loaded msg
	HC	EA(LOADMG)		:C081= loaded msg


:	CLRLMG - for async dialect message 00 indicating the loaded 
:	message to be clear

CLRLMG	L	RBP,.IIXBF,RPI		:.LGBUF = .IIXBF, both share one buf.
	JAL	RCH,EMPTY		:clear buffer
	JR	RLINK

:	LOADMG - for async dialect message 01 indicating IIX dialecty
:	message should be loaded into buffer.

LOADMG	JAL	R6,GET1BD		:get the first byte - msg length.
	J	SIG.A			:go to process signals
	STB	RBC,.IXLEN,RPI		:save msg length
	JAL	R6,GET1BD		:get the second byte - parity control
	J	SIG.A			:go to process signals
	STB	RBC,.IXPAR,RPI		:save parity control byte
	L	RBP,.IIXBF,RPI		:.LGBUF = .IIXBF
	JAL	RCH,EMPTY		:make sure buffer empty before load msg
	LB	R9,.IXLEN,RPI		:restore msg length
LOAD1	L	RBP,.TTBUF,RPI		:get to-terminal buffer pointer
	JAL	R6,GET1BD		:get data from to-terminal buffer
	J	SIG.A			:go to process signals
	L	RBP,.IIXBF,RPI		:get to-IIX buffer pointer
	JAL	RCH,PUTCHR		:put data to to-IIX buffer (.IIXBF)
	SIS	R9,1			:decrease one byte of message
	JGBS	LOAD1			:still have msg
	JR	RLINK

	FO	IIX


	SUBTTL (CONSAT)	ASYNC DRIVER CODE -- ASCII HALF-DUPLEX



:		*   * ****         ***   ***   ***
:		*   * *   *       *   * *   * *   *
:		***** *   * *****    *  *   *    *
:		*   * *   *         *   *   *   *
:		*   * ****        *****  ***  *****

:	For Australia Cas, Character come in after TID as LTA
:	HD202S problems have been fixed by *LH* --LIZA HU 

	IF	.2HD

ZHDUX	JAL	RCH,AGETCH		:get the char
	 J	0,RLINK			:ignor control-signals
	STB	RBC,TRNCH,RP		:success...set this as LTA
	LA	R0,VHDUX		:set subsequent execution address
	ST	R0,.VSTAT,RPI
	J	VHD1			:and skip to finish taking the line

:	HALF-DUPLEX ASCII terminal receiver.
:	=========== ===== ======== ========
VHDUX	JAL	RCH,AGETCH		:Assemble char
	 J	VAESC			:control-signal
	LBR	R9,RBC
	NHI	RBC,7F
	TBT	RP,RTS			:to kill coming gabbage after RS up
	JNR	RLINK			:throw it away
	CLB	R9,TRNCH,RP		:line turn-around?
	JN	VHD2
	SIS	RBC,0D			:yes...CARRET?
	JEFS	VHD0			:send CARRET through network
	TBT	RP,LOGING		:no..check if in log in mode?
	JNFS	VHD1			:yes, do'nt send it off
	JFS	VHD00
VHD0	SBT	RP,CARR			:record CR passage
VHD00	L	RBP,.FTBUF,RPI		:else send it on
	LR	RBC,R9
	JAL	RCH,PUTCHR

VHD1	SBT	RP,RTS			:take the line...
	JAL	RBF,A.RS.U		:bring RS up
	RBT	RP,ATTN
	JR	RLINK

VHD2	SIS	RBC,0D			:CARRET?
	JNFS	VHD3
	SBT	RP,CARR			:make note of it
	J	VASEND

VHD3	AIS	RBC,0D-0A		:LINE FEED?
	JNFS	VHD4			:no, send off character
	RBT	RP,CARR			:yes, ignore if after a CARRET
	JNR	RLINK
	AIS	R9,0D-0A		:else change to CARRET
	J	VASEND			:and send it off

VHD4	RBT	RP,CARR
	J	VASEND


:	HALF-DUPLEX ASCII Transmitter.
:	=========== ===== ===========

:	Initial handler to set up states for login
YHDUX	JAL	RBF,A.RS.U		:initially, bring RS up!
	SBT	RP,RTS			:record it on
	L	RBP,.TTBUF,RPI		:place a green-ball at end of TID...
	LHI	RBC,TLTA		:place TLTA before green-ball
	JAL	RCH,PUTCHR		:into .TTBUF	
	J	XHD4			:...then go set up


:	normal transmitter
XHDUX	TBT	RP,XMTF			:Do we have the line?
	JEFS	XHD1			:no...check further
	RBT	RP,ATTN			:is there a reverse-channel request?
	JEFS	XHD2			:no...go service char
	RBT	RP,GBO			:yes...ignore future green-balls
	J	XHD6			:turn line around

XHD1	JAL	RCH,CPEEK		:check if control-signal pending
	 J	XHD3			:no

:	Get next element to service
XHD2	JAL	RCH,GETCHR
	 J	SIG.HD			:control signal
	J	XAS130			:data...use normal handler to send

:	No control-signals pending, and we can't transmit (yet).
XHD3	TBT	RP,RTS			:did line just turn around?
	JEFS	XHD5			:no, delay awhile longer
	LIS	R5,8			:yes, delay 0.25 sec
	JAL	RCH,ADELAY
	JAL	R0,XHSTAT

XHD4	SBT	RP,XMTF			:now we can transmit
XHD5	LIS	R5,3			:3 character times
	JAL	RCH,ADELAY
	J	XHD7			:restore XSTATE and defer output

XHD6	JAL	RCH,APUTCH		:send it
	MINH(RBF,MARGE,RPI)
	LIS	R5,1			:delay until entire char transmitted
	JAL	RCH,ADELAY
	JAL	RBF,A.RS.D		:drop request-to-send
	RBT	RP,RTS
	RBT	RP,XMTF			:we can transmit no more

:	Restore to normal transmitter function
XHD7	LA	R0,XHDUX		:restore XSTATE to normal
XHSTAT	ST	R0,.XSTAT,RPI
	J	XDEF			:defer further output


:	SIG.HD:	Signal Processor for half-duplex ASYNC
:	======

:	Called from Half-duplex ASYNC transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.HD	SIGBGN(ETMSIG,LTMSIG,EADSIG,LADSIG)
	SIGEXC(SIRSIG,SIBRAT)		:Set input baud-rate
	SIGEXC(SORSIG,SOBRAT)		:Set output baud-rate
	SIGEXC(SPASIG,SFPSIG)		:Set Parameter A
	SIGEXC(SPBSIG,SFPSIG)		:Set Parameter B
	SIGEXC(SPCSIG,SFPSIG)		:Set Parameter C
	SIGEXC(SPDSIG,SFPSIG)		:Set Parameter D
:	SIGEXC(SECSIG,SECHO)		:Set echo-control
:	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEND

:	DC1 of host data string as a line-turn-around character
XASLTA	TBT	RP,PARITY		:Parity enable?
	JE	XHD6
	LR	RBC,R0
	TBT	R0,PARBIT		:yes, set char. with parity-bit off	
	JE	XHD6
	OHI	RBC,80			:turn parity-bit on if appropriate
	J	XHD6
	EI	:.2HD

	SUBTTL	(CONSAT) HALF-DUPLEX ASYNC BAUDOT

	 IF	BAUDA!BTELEX

:	Half-Duplex BAUDOT ASYNC

:		****    *   *   * ****   ***  *****
:		*   *  * *  *   * *   * *   *   *
:		****  ***** *   * *   * *   *   *
:		*   * *   * *   * *   * *   *   *
:		****  *   *  ***  ****   ***    *

:	Half-Duplex BAUDOT ASYNC Input Routine
:	=========== ====== ===== =====
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R7 -	Character from ASYNC driver
:	R8 -	8-word index
:	R9 -	Pointer to ASYNC character
:	RPI -	Pointer to port-table entry
:	RP -	port number
	GL	VHBA0,XHBA0,XHBA1
VHBAD	JAL	RCH,AGETCH		:get the next character
	 J	VAESC			:service BREAK
	NHI	RBC,1F			:mask it down
VHBA0	TBT	RP,BICF			:which case to use
	JEFS	VHBA1			:letter
	OHI	RBC,(B.CCIT+1)*20	:number...USE CCITT TRANSLATION TABLE!
VHBA1	LB	R9,BAUD.A,RBC		:get the ASCII character
	THI	R9,80			:is this real data?
	JN	VASEND			:yes...send it
	SIS	R9,1			:special character...
	JGFS	VHBA2			:letter-shift
	JLR	RLINK			:0...ignor
	SBT	RP,BICF			:number-case
	JR	RLINK
VHBA2	RBT	RP,BICF			:letter-case
	JR	RLINK


:	Half-Duplex BAUDOT ASYNC Output Routine
:	=========== ====== ====== ====== =======
XHBAD	JAL	RCH,GETCHR		:get the character
	 J	XHBAC			:Control-signal...go process it
XHBA0	NHI	RBC,7F			:mask the character
	LB	R9,A.BAUD,RBC		:get the BAUDOT character
	JER	RLINK			:ignor nulls
XHBA1	THI	R9,80			:check for case-independence
	JN	XHBA3			:send immediately if so
	LHI	RBC,(.BADLC^8)!.BADNC!20 :set up case-shift constant
	TBT	RP,BICF			:check current case
	JNFS	XHBA2
	EXBR	RBC,RBC			:letter case...swap
XHBA2	XR	RBC,R9			:check the shift required
	THI	RBC,20			:check if same case as current
	JEFS	XHBA3			:skip if OK
	CBT	RP,BICF			:else change case
	EXBR	RBC,RBC			:RBC contains case-shift to send
	OHI	RBC,-20			:set high-bits
	JAL	RCH,APUTCH		:send case-shift
XHBA3	LR	RBC,R9			:send data-character
	OHI	RBC,-20			:set high-bits
	JAL	RCH,APUTCH
	JR	RLINK

:	Control-signal in stream
:	RLINK -	Link register
:	R5 -	Signal to examine
XHBAC	SIGBGN(EADSIG,LADSIG,SHGSIG,SEXSIG-QQMSIG)
	SIGEXC(ETMSIG,XHBETM)		:enter-transparency-mode
	SIGEND

:	Enter-Transparency-Mode
XHBETM	LA	R0,VHBGD
	LA	R1,XHBGD
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK
:	Transparent (glass) Half-Duplex BAUDOT ASYNC

:	Half-Duplex BAUDOT ASYNC Input Routine
:	=========== ====== ===== =====
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R7 -	Character from ASYNC driver
:	R8 -	8-word index
:	R9 -	Pointer to ASYNC character
:	RPI -	Pointer to port-table entry
:	RP -	port number
VHBGD	JAL	RCH,GETCHR		:get the next character
	 J	VAESC			:break
	NHI	RBC,1F			:mask down the character
	CLHI	RBC,.BADLC		:letter-case?
	JNFS	VHBG1			:no
	RBT	RP,BICF			:yes...set letter-case
	JFS	VHBG2			:go send it
VHBG1	CLHI	RBC,.BADNC		:number-case?
	JNFS	VHBG2			:no
	SBT	RP,BICF			:yes...set number-case
VHBG2	OHI	RBC,0E0,RBC		:insure high-order bits are set
	J	VASEND			:send it along


:	Half-Duplex BAUDOT ASYNC Output Routine
:	=========== ====== ====== ====== =======
XHBGD	JAL	RCH,GETCHR		:get the character
	 J	XHBGC			:Control-signal...go process it
	NHI	RBC,1F			:mask the character
	CLHI	RBC,.BADLC		:record case-shifts
	JNFS	XHBG1
	RBT	RP,BICF
	JFS	XHBG2
XHBG1	CLHI	RBC,.BADNC		:record case-shifts
	JNFS	XHBG2
	SBT	RP,BICF
XHBG2	OHI	RBC,-20			:set high-order bits
	JAL	RCH,APUTCH		:...and send data
	JR	RLINK

:	Control-signal in stream
:	RLINK -	Link register
:	R5 -	Signal to examine
XHBGC	SIGBGN(ETMSIG,EADSIG,LADSIG,SHGSIG,SEXSIG-QQMSIG)
	SIGEXC(ZAPSIG,XHBZAP)		:Zapper
	SIGEXC(LTMSIG,XHBLTM)		:leave transparency
	SIGEND

:	Zapper
XHBZAP	LA	RLINK,ZAPPER		:exit via zapper

:	Leave-Transparency-Mode
XHBLTM	LA	R0,VHBAD
	LA	R1,XHBAD
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK

	 EI	:BAUDA!BTELEX
	 
	SUBTTL  (CONSAT) PRINTER-DRIVER CODE

	 IF	NUMPRN


:	****  ****  ***** *   * ***** ***** ****
:	*   * *   *   *   **  *   *   *     *   *
:	****  ****    *   * * *   *   ****  ****
:	*     *  *    *   *  **   *   *     *  *
:	*     *   * ***** *   *   *   ***** *   *

	GL	SETPRN,PCHAR,PFLUSH

:	SIG.P:	Signal Processor for PRINTER
:	=====

:	Called from PRINTER transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.P	SIGBGN(ETMSIG,LTMSIG,EADSIG)
	SIGEXC(ZAPSIG,PRZAP)		:zapper
	SIGEXC(GOBSIG,PRLAOD)		:gobbler
	SIGEXC(LADSIG,PRLAOD)		:Leave alternate-output-device
	SIGEXC(SIRSIG,SIBRAT)		:Set input baud-rate
	SIGEXC(SORSIG,SOBRAT)		:Set output baud-rate
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEXC(SKKSIG,PRSKK)		:Set KATAKANA
	SIGEXC(QKKSIG,PRQKK)		:Query KATAKANA
	SIGEND

:	Leave alternate-output-device mode
PRLAOD	JAL	RBF,PFLUSH		:Flush output (if any)
	 NOP	0			:in case skip return
	LA	R0,XASCI		:restore normal handler
	ST	R0,.XSTAT,RPI
	JR	RLINK			:then exit

:	Zapper
PRZAP	JAL	RBF,PFLUSH		:Flush output (if any)
	 NOP	0			:in case skip return
	LA	R0,XASCI		:restore normal handler
	ST	R0,.XSTAT,RPI
	J	ZAPPER			:then proceed with zapper logic

:	Set KATAKANA
PRSKK	SBT	RP,KTKANA		:turn it on
	NHI	RBC,1			:test new state
	JNFS	PRQKK			:Done...report it back
	RBT	RP,KTKANA		:Else turn it off again

:	Query KATAKANA
PRQKK	LCS	R4,2			:Make even
	NR	R4,R5
	LIS	RBC,0			:Expect to return a zero
	TBT	RP,KTKANA		:is bit on?
	JE	SIGRSP			:no...skip
	LIS	RBC,1			:yes...return a 1
	J	SIGRSP



:		PRINTER Driver
:	Copy output from buffer to printer until:
:	1.	Hit a signal,
:	2.	Hit a CR,
:	3.	or Fill a buffer.
:	RP -	Printer (port) number
:	RLINK -	Link register
XPRINT	JAL	RBF,SETPRN		:get current rotor entry
	 J	PRINT1			:output not busy
	JAL	RCH,CPEEK		:Output is busy...
	 J	XDEF			:defer if not a signal pending
					:...else process it!! (may be zapper)

:	Proceed with printing
PRINT1	TBT	RP,TOPORT		:any more data?
	JER	RLINK			:no, exit
	JAL	RCH,GETCHR		:get a character
	 J	SIG.P			:Control-signal
	CLHI	RBC,83			:return-to-terminal-output command (^C)?
	JE	PRLAOD			:yes...leave alternate-output-device mode
	TBT	RP,KTKANA		:KATAKANA printer?
	JEFS	PRINT2			:no...skip
	CLHI	RBC,0E0			:yes...blank compression?
	JGE	PRINT5			:yes
	JFS	PRINT3			:no...skip normal test

PRINT2	CLHI	RBC,80			:is this a blank compression?
	JL	PRINT6			:jump if so
PRINT3	CLHI	RBC,8D			:carriage return?
	JNFS	PRINT4			:jump if not
	LIS	RBC,0			:<CR> converts to 0 in new format
	JAL	RBF,PCHAR		:and send it
	 J	XDEF			:defer for now
	J	XDEF			:skip return...defer for now

:	Data char...print it
PRINT4	JAL	RBF,PCHAR		:send it
	 J	PRINT1			:and go on to next char
	J	XDEF			:skip exit...quit for now

:	Blank compression
:	KATAKANA compression
PRINT5	SHI	RBC,0E0-8		:convert to standard form

:	normal compression
PRINT6	SIS	RBC,8			:bias because 09 really means one blank
	LHI	R7,-40,RBC		:how many blanks to compress?
	JLFS	PRINT7			:less than 40..send it
	AIS	R7,1			:more than 40...
	LHI	RBC,3F			:send this many first...
	JAL	RBF,PCHAR
	 NOP	0			:don't care about skip returns
	LR	RBC,R7			:this many more
PRINT7	JAL	RBF,PCHAR		:send it
	 NOP	0			:don't care about skip returns
	J	XDEF			:prevent XMIT bug *sdw

	 EI	:NUMPRN
	 
	SUBTTL  (CONSAT) ASYNC ANSWER/HANG CODE


:			    *    **** *   * *   *  ***
:			   * *  *      * *  **  * *   *
:			  *****  ***    *   * * * *
:			  *   *     *   *   *  ** *   *
:			  *   * ****    *   *   *  ***

:	*   *   *   *   *  ***          *   *   *  **** *   * ***** ****
:	*   *  * *  **  * *   *        * *  **  * *     *   * *     *   *
:	***** ***** * * * *     ***** ***** * * *  ***  * * * ****  ****
:	*   * *   * *  ** *  **       *   * *  **     * ** ** *     *  *
:	*   * *   * *   *  ****       *   * *   * ****  *   * ***** *   *

:	This is the environment-independent portion of ASYNC ANSWER/HANG --
:	It performs the following sequence of functions (by port-group):
:	1	Compute new value of CP,
:	2	Compute new value of DSR,
:	3	Compute new value of DTR,
:	4	detects changes to RLA,
:			does Answer and Hang as necessary.

:	Working registers for HANG/ANSWER module
WDTR	EQ	9			:Data Terminal Ready
WDSR	EQ	8			:Data Set Ready
WCP	EQ	7			:Carrier Present
WRLA	EQ	WDTR			:Receiver line active

AHNGAN	ST	R0,QRET			:save return
	LHI	RPOL,(NAGRP-1)*2	:start with last group

:	Note -	in the following, TRUE = 0, FALSE = 1

:	CP=(((CP0&CP1&CP2&CP3)!OLDCP)&(CP0!CP1!CP2!CP3))!@HD202
:	if he's been in a CP state for 2 seconds, record him as being in
:	that state.	
QHA1	LH	WCP,CPSAMP,RPOL
	OH	WCP,NAGRP*2+CPSAMP,RPOL
	OH	WCP,NAGRP*4+CPSAMP,RPOL
	OH	WCP,NAGRP*6+CPSAMP,RPOL	:TRUE if TRUE for all
	NH	WCP,CP,RPOL		:...OR if CPold TRUE
	LH	R1,CPSAMP,RPOL
	NH	R1,NAGRP*2+CPSAMP,RPOL
	NH	R1,NAGRP*4+CPSAMP,RPOL
	NH	R1,NAGRP*6+CPSAMP,RPOL	:TRUE if TRUE for any
	OR	WCP,R1
	NH	WCP,.NO.CP,RPOL		:or if CP not supported

:	DSR updated,old used
	LH	WDSR,NEWDSR,RPOL	:get new value of DSR
	 IF	PVC
:	For PVC ports with NOHANG option set, make WDSR follow DTR if real
:	DTR signal is active. Allows hang/answer to answer port even if DSR
:	signal does no change (eg, hardwired port).
:	LHL	R0,DTR,RPOL		:get previous DTR
:	NH	R0,NOHANG,RPOL		:...only for NOHANG ports
:	OR	WDSR,R0			:make DSR inactive if previous DTR inactive
	 EI	:PVC

:	AH.TO2=AH.TO2 ! (DSR&@oldDSR) ! (CP&@oldCP)
:	if he's come up on either 'CP' or 'DSR' in the last 1/2 second,
:	put him onto timeout. (if timeout expires, HANGWT is set.)
	LCS	R0,1
	XH	R0,DSR,RPOL		:DSR&@oldDSR
	OR	R0,WDSR
	LCS	R1,1			:CP&@oldCP
	XH	R1,CP,RPOL
	OR	R1,WCP
	NR	R0,R1			: .OR.
	NH	R0,AH.TO2,RPOL		: .or. AH.TO2
	STH	R0,AH.TO2,RPOL

:	HANGWT=(@oldDTR!HANGWT) & DSR  (HANGWT 1 true, others 0 true!)
:	if, a hang has been requested, or we tried to hang him last time,
:	and he's still there, hang him.
	LCS	R1,1
	XR	R1,WDSR
	LH	R0,DTR,RPOL		:@(notDTR) .OR. HANGWT
	OH	R0,HANGWT,RPOL
	NR	R0,R1			: .AND. (notDSR)
	STH	R0,HANGWT,RPOL		:disable HANGWT (use again below!)

:	DTR=@HANGWT & (DST ! @oldDST) & (CP ! @oldCP)
:		(NOTE.. HANGWT has ! true, others 0 true)
:	DTR is true if:
:		we/re not trying to hang the port,
:	AND 	DSR has not gone false,
:	AND CP has not gone false.
	LCS	WDTR,1			: @oldDSR ! DSR
	XH	WDTR,DSR,RPOL
	NR	WDTR,WDSR
	OR	WDTR,R0			: AND @(notHANGWT)
	LCS	R0,1			: CP ! @oldCP
	XH	R0,CP,RPOL
	NR	R0,WCP
	OR	WDTR,R0			: .AND. (CP ! @oldCP)
	 IF 	SLODTR			: Hold DTR down for 1, not .5 sec
	LH	R1,DTR1,RPOL
	STH	WDTR,DTR1,RPOL		: set pipeline
	OR	WDTR,R1			: insure immediate false state
	 EI	:SLODTR

:	AH.TOI = AH.TOI & DTR
	LR	R0,WDTR			:cancel timeouts for ports with
	OH	R0,AH.TO,RPOL		:...DTR false
	STH	R0,AH.TO,RPOL
	LR	R0,WDTR
	OH	R0,AH.TO1,RPOL
	STH	R0,AH.TO1,RPOL
	LR	R0,WDTR
	OH	R0,AH.TO2,RPOL
	STH	R0,AH.TO2,RPOL
        IF  OUTDIA
        NH      WDTR,DTRON,RPOL         :DTRON turns on dtr (0 if true)
        EI  :OUTDIA
 
	STH	WDTR,DTR,RPOL  		:save DTR for next-time odlDTR
	STH	WCP,CP,RPOL
	STH	WDSR,DSR,RPOL		:save new DSR for next-time oldDSR
	OR	WRLA,WDSR
	OR	WRLA,WCP		:RLAnew=@(DTR&DSR&CP)
	XHI	WRLA,-1
	STH	WRLA,AHATMP		:save this

:	detect changes to RLA
QHA2	LHL	R0,AHATMP		:any changes in Receiver Line Active?
        IF      OUTDIA
        OH      R0,OT.MOD,RPOL          :don't h or a  the modem
        EI     :OUTDIA
	IF	TELEX
	OH	R0,TLXP,RPOL		:don't hang or answer if TELEX port
	EI	:TELEX
	IF	BTELEX
	OH	R0,BTLXP,RPOL		:don't hang or answer if non-transparent
	EI	:BTELEX
	IF	TTELEX
	OH	R0,TTLXP,RPOL		:don't hang or answer if transparent ports
	EI	:TTELEX			:** 4.02 LH
	XH	R0,RLA,RPOL
	JFFOH	R0,QHA3			:Anything there?
	SIS	RPOL,2			:for next group
	JGE	QHA1
	L	R0,QRET
	JR	R0			:and exit

:	change to RLA detected for port...
:	figure out which port, change RLA to new value
:	...then decide if answer or hang.
QHA3	LR	RP,RPOL			:Compute port number
	SLLS	RP,3
	AR	RP,R1
	GETPTP(RPI,RP,RP)		:Set up pointer to port table
	L	RBP,.FTBUF,RPI		:empty the buffers
	JAL	RCH,EMPTY
	L	RBP,.TTBUF,RPI
	JAL	RCH,EMPTY
	CBT	RP,RLA
	JN	QHA6			:Line no longer active...

:	RLA was FALSE (=0...we're back to 1=true)
:	Initialize new port
	SBT	RP,ASYNC		:flag as an ASYNC port
	RBT	RP,BRK			:make sure BREAK off
	SBT	RP,NEWLOG		:set new logon
	SBT	RP,LGECHO		:assume LOGON echoing desired
	RBT	RP,RXON			:reverse X-ON off
	SBT	RP,XONOUT		:init XON already out
	 IF	NPAPRT
        GL      AR.FT,AR.TT
        LR      R13,RP
        AR      R13,R13                 :r13 is 2*rp
        L       R0,AR.FT,R13,R13
        ST      R0,.AR.FT,RPI
        L       R0,AR.TT,R13,R13
        ST      R0,.AR.TT,R13,R13       :save async ring addresses
	JAL	R0,PA.SL		:set limbo if required
	GL	PA.SL
	 EI	:NPAPRT
	LHI	R3,100			:Initialize the port
	STH	R3,MARGE,RPI
	JAL	RLINK,IZ.PRT		:let Tymnet-II set up buffers
  IF	X3ON
	JAL	R9,IZ.X3,,		:reset PAD-related arrays
  EI
	 IF	PVC
	GL	AIDPVC
	JAL	RLINK,AIDPVC		:Check if PVC Auto-ID port
	 J	QHA4			:normal return...NON-AID...proceed
:	PVC-AID port...
	JAL	R9,A.VID		:set up the port according to TID
	J	QHA2

QHA4	 EI	:PVC
        L       R4,SLOWC,,              :get and store time *500.sdw
        ST      R4,.TIME,RPI
	LHI	R4,TID30		:assume 30 cps port
	TBT	RP,T120			:Should this be 1200 baud port?
	JEFS	QHA500			:...no
	LHI	R4,TID120		:Yes...set that up
QHA500	TBT	RP,T240		:240 cps port?  *500.sdw
	JEFS	QHA501
	LHI	R4,TID240
QHA501	TBT	RP,T480		:480 bps port?  *500.sdw
	JEFS	QHA502
	LHI	R4,TID480
QHA502	JAL	R5,IZPORT		:Initialize the port parameters
	JAL	RLINK,A.ANS		:go answer the port
	JAL	RBF,A.TID		:set up to look for TID
	L	RBP,.TTBUF,RPI		:to-terminal buffer-pointer
	LA	R6,TIDMMD,,		:"Please type your..."
	TBT	RP,TSPPAR		:is this space parity port   4.01U
	JEFS	QHA510
	RBT	RP,PARITY		:turn off even parity
	JAL	R9,MSGSP		:send message to identify terminal
	J	QHA2			: (space parity)
QHA510	JAL	R9,MSG			:send message to identify terminal
	J	QHA2			: (even parity)

:	RLA went FALSE (=1)...
:	Circuit Disconnected
QHA6	JAL	R6,A.CLRO		:else, go clear async output
	JAL	RBF,A.DSC		:disconnect port
	IF	NMPVC
	GL	MPVZSP
	JAL	RLINK,MPVZSP		:go zap MPVC subport
	EI	:NMPVC
	IF	X3ON			:Pad function on ?		  
	GL	IIXCAL,CTARPT
	TBT	RP,IIXCAL		:yes... is this an IIX circuit?	  
	JEFS	QHA8			:no....continue
	JAL	R6,CTARPT,,		:yes...send accounting message	  
QHA8
	EI	:X3ON
	JAL	RLINK,DT.PRT		:for TYMNET-II disconnect ckt	  
	  				:goes to CIRDIS for ISIS CONSAT
	RBT	RP,C.ACP		:no longer active
	J	QHA2


	 EI	:NAPORT
	 
	SUBTTL	(CONSAT) SIO STORAGE
	
	 IF	NSPORT			:SIO-Mother Board optional

:		 **** *****  ***
:		*       *   *   *
:		 ***    *   *   *
:		    *   *   *   *
:		****  *****  ***

:	SIO data area is composed of command blocks (ICMSIO, OCMSIO)
:	data blocks (OUTSIO, INPSIO), a bit array set if SIO port is
:	configured and connected (GOTSIO).
:	Certain access to the SIO data areas is done with an index register
:	which is a function of the global CONSAT port-index, thus all data
:	labels are defined with a virtual offset since all SIO ports start
:	at .SPORT ports.

	 IF	SHIST
	SEG	A.DATA
:	History buffer:
:	SHISX -	HW cursor for next entry (relative to SHISD)
:	entry -	BC	Character,
:		BC	port number (RP)
:		HC	SIO input buffer index (on input)
:		WC	R0 - caller
	DEFAULT(SHSIZ,400)
HSTORAG(SHISPT,0,(CSBASE+(.SPORT/8)))	:if bit on, port traced
	RE	NSGRP
	HC	-1
	ER				:start by tracing all
HSTORAG(SHISX,1,CSBASE)
HSTORAG(SHISD,SHSIZ/2,CSBASE)

	SEG	A.CODE
:	Keep history
:	R0 -	Link
:	R1 -	Character
:	R3 -	Scratch
SHISTY	LH	R3,SHISX		:tracing enabled?
	JLR	R0			:no trace
	TBT	RP,SHISPT		:tracing this port?
	JER	R0			:no...just exit
	STB	R1,SHISD,R3,		:save char *403-set RX3
	STB	RP,SHISD+1,R3,		:save port #
	STH	R9,SHISD+2,R3,		:save caller
	ST	RBF,SHISD+4,R3,		:save caller
	AIS	R3,8			:advance cursor and save
	NHI	R3,SHSIZ-1
	STH	R3,SHISX,,
	JR	R0
	 EI	:SHIST

	SEG	A.CODE

:	Array containing offsets into ICMSIO
ICMSOF	HS	0
Q	EQ	0
	RE	NSPORT
	HC	Q
Q	EQ	Q+2*NSIOBF*4
	ER

:	Array containing offsets into OCMSIO/STASIO
OCMSOF	HS	0
Q	EQ	0
	RE	NSPORT
	HC	Q
Q	EQ	Q+SCBFSZ
	ER

:	Array containing offsets into INPSIO 
INPSOF	HS	0
Q	EQ	0
	RE	NSPORT
	HC	Q
Q	EQ	Q+NSIOBF*SIBFSZ		:input is NSIOBF*10x bytes 
	ER

:	Array containing offsets into OUTSIO/OB2SIO 
OUTSOF	HS	0
Q	EQ	0
	RE	NSPORT
	HC	Q
Q	EQ	Q+SOBFSZ		:SOBFSZ bytes
	ER

:	Make a list of initialization commands
S.HNG	HC	3,1500	:6.00 sdw - reset int, r5: dtr & RTS down.
	HC	0,0			:end-of-command
	HC	0,0			:spare, for debugging.
	HC	0,0			:spare, for debugging.

S.ENA	HC	3,0000			:do nothing command
	HC	3,1444			:reset int, r4: 16x clock, istopbit
	HC	3,1582			:reset int, r5: RTS & DTR up
	HC	0,0			:end-of-command

S.ASCI	HC	3,0000			:send a do-nothing command 
	HC	3,0444			:set 1 stop-bit
					:1000 = reset interrupt. Do in pairs (ref: ex-Ziloger)
	HC	3,13C1			:rx 8 bits/char rx-enable
	HC	3,15EA			:DTR and RTS on, tx 8 bits/char, tx-enable
	HC	0,0			:end-of-command

	 IF	STOP2			
S.ASC2	HC	3,0000			:send a do-nothing command	 
	HC	3,044C			:set 2 stop-bits
					:1000 = reset interrupt. do in pairs
					:(ref: ex-zi**loger)
	HC	3,13C1			:rx 8 bits/char rx-enable
	HC	3,15EA			:DTR and RTS on, tx 8 bits/char,tx-enable
	HC	0,0			:end-of-command
.STP2	BARRAY(.STP2,NPORT)
	 EI	:STOP2

	
	SUBTTL  (CONSAT) SIO CODE

SCRASH  J       CRASH,,                 :Alternate location which does use
                                        :RX3 addressing since SVC fails + 4
                                        :SDW*403

:	SIO ASCII Input Routine
:	=== ===== ===== =======
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R9 -	Pointer to SIO character
:	RPI -	Pointer to port-table entry
:	RP -	port number
VSIO	LHL	R9,OCMSOF-2*.SPORT,RP,RP	:get cmd offset
	LH	R0,OCMSIO,R9		:get cmd/status
	OH	R0,OCMSIO+10,R9		:get alternate cmd/status
	NHI	R0,200			:check for completed status
	JEFS	VSIO00			:
	JAL	RCH,SIOBSY		:check for possible hung output
	NOP				:placeholder for error return
VSIO00	LHL	R9,XINSIO,RP,RP		:get pointer to current buffer
	LH	RBC,0,R9		:Look at first character
	JGE	VSIO1			:SIO's been here, left a char?
	LR	R8,R9			:nothing here, perhaps in next buffer?
	AHI	R9,SIBFSZ		:   /
	NHI	R9,-SIBFSZ		: wrap to next buffer (10 = bufsiz)
	THI	R9,(NSIOBF-1)*SIBFSZ	:if on, not yet time to wrap
	JNFS	VSIOA			:to first buffer for this port
	SHI	R9,NSIOBF*SIBFSZ	: time to wrap
VSIOA	LH	RBC,0,R9		: anything in next buffer?
	JL	VDEF			:no, try next foreground time...
	LH	R0,0,R8			:yes, did SIO sneak them in between
	JLFS	VSIO1			: these instructions? (no...)
	LR	R9,R8			:yes, read chars from orig. pointer
	LR	RBC,R0			:and get correct character in RBC
VSIO1	JAL	RCH,VSECCK		:check if echo will be possible
	J	VSIO3A			:and skip

:	Check for buffer-end
VSIO2	THI	R9,(NSIOBF-1)*SIBFSZ!(SIBFSZ-1)
	JNFS	VSIO3			:not at buffer end, continue...
	SHI	R9,NSIOBF*SIBFSZ	: yes, reset pointer
VSIO3	LH	RBC,0,R9		: get next item
	JGE	VSIO3A			:found something other than -1
	STH	R9,XINSIO,RP,RP		:store index away
	J	VDEF			: found all the input for now

:	Now process all characters in buffer
VSIO3A	TS	0,R9			:Reset cell to -1
	 IF	SHIST;	JAL	R0,SHISTY		:trace;	 EI
	AIS	R9,2			:bump pointer to next character
	THI	RBC,100			:test for BREAK
	JEFS	VSIO3B			:normal character...skip
	JAL	RCH,SIOBRK		:See if time for BREAK
	J	VSIO2
VSIO3B
   IF	X3ON
	LR	R5,RBC			:copy char
	NHI	R5,7F			:and strip parity
	CH	RBC,X3.N3,RPI		:X3.N3=-1, if break emulation off
	JNFS	VSIO4			:no break, skip break logic
	L	R3,.ESIGF,RPI		:get signal editor
	JEFS	VSIO4			:if not involve signal editor
	 LO SIGNAL
	LIS	R4,BBSIG		:yes, treat it as <break> detected
	 FO SIGNAL	
	JALR	RCH,R3			:invoke editor
	J	VRET			:and return to polling loop
  EI	:X3ON

:	Service normal data-character
:		...Echo character if possible
VSIO4	RBT	RP,D.PAS2		:cancel any break in progress
	RBT	RP,D.PAS1
	STB	RBC,CHRSIO		:save the data-character
	LHI	R5,7F			:make a mask
	NR	R5,RBC			:reduce character to 7-bits
	CLHI	R5,13			:Check for XOFF
	JE	VSXOFF			:Do XOFF function
	CLHI	R5,11			:Check for XON
	JE	VSXON			:yes, do XON function
	TBT	RP,ECHO			:echo-able character...Echoing?
	JE	VSNOE1			:no...do ball-logic
	LH	R0,ECOSIO		:is echo permitted?
	JN	VSAED			:can't echo if output present
	TBT	RP,RXON			:backpressured?
	JN	VSAED			:can't echo if backpressured
	L	RBP,.TPBUF,RPI		:set echo buffer in case needed
VSIO4B	TBT	RP,HAFDUX		:half-duplex?
	JN	VHSCHK			:special tests if so
	TBT	R5,.ECHT1,RPI		:is it printable?
	JN	VSCHK			:no...special processing

:	echo the character
VSIO5	JAL	RCH,PUTCHR		:else echo the character
	J	VSSND			:and go send it

:	Non-echoable character
VSNOEC	TBT	RP,ECHO			:are we echoing?
	JNFS	VSAED			:yes, go enter DEM

VSNOE1	RBT	RP,GBO			:not echoing...
	JEFS	VSSND			:no green balls out
	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	RBT	RP,TBOA
	RBT	RP,TBOB			:reset red-ball timeouts
	 LO	SIGNAL
	LIS	R4,RBSIG		:Send a RED BALL
	 FO	SIGNAL
	JAL	RCH,PUTSIG		:send RED-BALL to cancel GREEN-BALL
	JFS	VSSND1			:and send character

:	Enter DEM
VSAED	JAL	RCH,GO.EDM		:Enter Defered-Echo-Mode
	JFS	VSSND1			:and skip to send char

:	Pass the character into the network
VSSND	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
VSSND1	LB	RBC,CHRSIO		:get the character
	JAL	RCH,PUTCHR		:...and send it
	J	VSIO2


:	Handler for "Q"-mode
:	Echo "~" and "}"
:	Don't echo LF
:	Echo Cr (with LF) if Echo_on_LF set...
:		THEN ENTER DEM!!!
VSQ	LHI	R0,-7D,R5		:is it "}"?
	JE	VSIO5			:yes...echo it
	SIS	R0,7E-7D		:is it "~"?
	JE	VSIO5			:yes...echo it
	LHI	R0,-0A,R5		:LF?
	JE	VSAED			:yes...enter DEM
	SIS	R0,0D-0A		:CR?
	JN	VSCHK1			:no...treat as non-Q char
	TBT	RP,ELF.CR		:CR...should we echo?
	JE	VSAED			:no...enter DEM
	JAL	RCH,PUTCHR		:echo CR
	TBT	RP,ECR.LF		:Line-feed needed too?
	JEFS	VSQ1			:no
	LIS	RBC,0A			:yes...do it too
	JAL	RCH,PUTCHR
VSQ1	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	LB	RBC,CHRSIO		:and send the CR
	JAL	RCH,PUTCHR
	JAL	RCH,GO.EDM		:go enter EDM
	J	VSIO2			:and go service next element


:	echo on, non-printable (?) char...
VSCHK	TBT	RP,Q.MODE		:"non-printable"...is port in "Q"-mode?
	JN	VSQ			:yes...perform necessary services
VSCHK1	TBT	R5,SPABLE,,		:does it require special tests?
	JE	VSAED			:no...just enter DEM
	LHI	R0,-0D,R5		:is it CR?
	JNFS	VSCHK2			:not a CR
	JAL	RCH,PUTCHR		:echo the CR
	TBT	RP,ECR.LF		:need LF?
	JE	VSSND			:no...send it
	LIS	RBC,0A			:yes...echo LF
	J	VSIO5			:Echo LF and proceed
VSCHK2	AIS	R0,0D-0A		:check for LF
	JNFS	VSCHK3			:not a LF
	TBT	RP,ELF.CR		:echo CR|RUB too?
	JE	VSIO5			:Echo LF for LF
	JAL	RCH,PUTCHR		:echo LF...
	LIS	RBC,0D
	JAL	RCH,PUTCHR		:echo CR...
	LCS	RBC,1			:...and RUB
	J	VSIO5			:Echo LF/CR/RUBOUT
VSCHK3	AIS	R0,0A-9
	JNFS	VSCHK4			:not a tab (^I)
	TBT	RP,ECTLI
	JE	VSAED			:Enter DEM, Don't echo tabs
	J	VSIO5			:Echo it
VSCHK4	SIS	R0,9-8
	JN	VSAED			:Unprintable char, enter DEM
	TBT	RP,ECTLH
	JE	VSAED			:Enter DEM for control-H
	J	VSIO5			:Echo it

:	half Duplex
VHSCHK	TBT	R5,SPABLE,,		:is it special?
	JE	VSSND			:no...just send it
	LHI	R0,-0D,R5		:un-echoable character
	JNFS	VHSCK0			:not a CR
	TBT	RP,ECR.LF
	JE	VSSND			:just send it
	LIS	RBC,0A
	J	VSIO5			:Echo LF for CR

VHSCK0	AIS	R0,0D-0A
	JN	VSSND			:not a LF
	TBT	RP,ELF.CR
	JE	VSSND
	LHI	RBC,8D			:echo CR
	JAL	RCH,PUTCHR
	LCS	RBC,1			:follow with RUB
	J	VSIO5			:send it and continue

:	X-ON
VSXON	RBT	RP,RXON			:were they in Wait-State?
	JE	VSNOEC			:no...non-echoable character
	L	R0,.XSAVE,RPI		:get previous state
	ST	R0,.XSTAT,RPI		:and set it
	J	VSIO2			:then process next character

:	X-OFF
VSXOFF	TBT	RP,YONENA		:X-OFF...is it enabled?
	JE	VSNOEC			:no, non-echoable character
	SBT	RP,RXON			:yes...set wait-state
	JN	VSNOEC			:already set...non-echoable character
	L	R0,.XSTAT,RPI		:else save current state
	ST	R0,.XSAVE,RPI
	LA	R0,XSXOFF		:...and set new state
	ST	R0,.XSTAT,RPI
	J	VSIO2			:then go service next character


:	SIO Output Routines
:	=== ====== ========

:	Delay Routine for SIO (Different than Async!!)
XSXOFF	JAL	RCH,CPEEK		:signal pending?
	 J	XDEF			:no, just defer output
	JAL	RCH,GETCHR		:get the character (signal)
	 J	SIG.SI			:should exit here
	ABORT(R5,0F)			:expected signal, didn't get one

XSIO	JAL	RCH,SIOBSY		:See if output buffer busy
	 J	XDEF			:Defer output and exit
	TBT	RP,SIOSTD		:is there something special to do?
	JE	XSIO3			:no...proceed with output
	JAL	RCH,SIOIDL		:see if idle
	 J	XDEF			:Defer output and come back later
	RBT	RP,SIOSTD		:
	RBT	RP,FRCXMT		:turn off force transmit bit
	TBT	RP,YONENA		:yes...is reverse-XON enabled?
	JEFS	XSIO2			:no...turn it off
	SIOIO(R2,XONSIO)		:yes...turn it on
	J	XDEF			:...and defer
XSIO2	SIOIO(R2,XOFSIO)		:no...turn it off
	J	XDEF			:...and defer
XSIO3
  IF	X3ON
	L	R3,.XPADF,RPI    	:get PAD filter pointer
	JEFS	XSIO3A			:none
	JALR	RCH,R3			:invoke PAD filter 
	 J	SICNTL			:normal return...It's a signal
	JFS	XSIO3B			:skip return...data
  EI
XSIO3A	JAL	RCH,GETCHR		:get the character
	 J	SICNTL			:Control-signal...go process it
XSIO3B	TBT	RP,TOSING		:Data...Are we tossing data?
	JNR	RLINK			:do this until gobbler resets
	LR	R0,RBC			:make another copy of data-char
	NHI	R0,7F			:Remove MSB
	TBT	RP,PARITY		:Parity enabled?
	JEFS	XSIO4
	LR	RBC,R0			:yes...set char with parity-bit off
	TBT	R0,PARBIT		:lookup parity
	JEFS	XSIO4
	OHI	RBC,80			:turn parity-bit on if appropriate
XSIO4	TBT	RP,SIOALT		:filling alternate output buffer?
	JNFS	XSIO5			:yes
	LHL	R7,OUTSIO,R9		:get main output buffer cursor
	 IF	SHIST;	JAL	R0,SHISTY		:trace;	 EI
	STB	RBC,OUTSIO+2,R7,R9	:put it away
	AIS	R7,1			:bump character count
	STH	R7,OUTSIO,R9		:save cursor
	JFS	XSIO6

XSIO5	LHL	R7,OB2SIO,R9		:get alternate output buffer cursor
	 IF	SHIST;	JAL	R0,SHISTY		:trace;	 EI
	STB	RBC,OB2SIO+2,R7,R9	:put it away
	AIS	R7,1			:bump character count
	STH	R7,OB2SIO,R9		:save cursor
XSIO6	TBT	RP,TOPORT		:any more?
	JEFS	XSIO7			:no...just terminate
	LB	R1,OBRATE,RP		:get port speed from table
	CH	R7,XSIOBL,R1,R1		:reached output buffer limit?
	JL	XSIO3			:no, continue
XSIO7	JAL	R0,X.ALT		:send as appropriate
	J	XDEF			:...then exit

:
:	XSIOBL - Xmit SIO Buffer Limit table
:
:	Table contains speed-dependent buffer limit
:	corresponding to 1/30th second interval.
:
:	
XSIOBL	HC	1			:10 CPS
	HC	1			:15
	HC   	1			:30
	HC   	1			:40
	HC	1			:60
	HC   	4			:120
	HC  	1			:30
	HC  	1			:14.5
	HC	1			:10
	HC	1			:10
	HC      8			:240
	HC   $A 16			:480 
  IF	SOBFSZ-7F
	HC   $A 72			:960 (special case)
  ELSE	SOBFSZ-3F
	HC   $A 36			:960 (default)
  ELSE	
	HC   $A 30			:960 
  EI
	HC   	1			:50 BAUD BAUDOT
	HC    	1			:75 BAUD BAUDOT
	HC      1			:75 BAUD ASCII

:
:	Control-signal in stream...close output first
SICNTL	JAL	R0,X.ALT		:send data as appropriate

:	SIG.SI:	Signal Processor for SIO
:	=====
:	Called from SIO transmitter to process control signals
:	RLINK -	Link register
:	R5 -	Signal to examine
SIG.SI	SIGBGN(ETMSIG,LTMSIG,EADSIG,LADSIG,SHGSIG)
	SIGEXC(SPASIG,QFPSIG)		:Set parameter A
	SIGEXC(SPBSIG,QFPSIG)		:Set parameter B
	SIGEXC(SPCSIG,QFPSIG)		:Set parameter C
	SIGEXC(SPDSIG,QFPSIG)		:Set parameter D
	SIGEXC(SECSIG,SECHO)		:Set echo-control
	SIGEXC(QECSIG,QECHO)		:Query echo-control
	SIGEXC(SRXSIG,SIO.RX)		:Set Reverse X-enable
	SIGEND


:	Set XON
SIO.RX	SBT	RP,SIOSTD		:set "something-to-do"
	SBT	RP,FRCXMT		:force xmit on next polling cycle
	J	SBPSIG			:...then go to common code

	 IF	BAUDY
:	Half-Duplex BAUDOT SIO

:	make a list of initialization commands
S.BADO	HC	3,0000			:do nothing command
	HC	3,0448			:1.5 stop bits, no parity
					:1000 = reset interrupt
	HC	3,1301			:rx 5 bit/char, rx-enable
	HC	3,158A			:DTR and RTS on, tx 5 bit/char, tx-enable
	HC	0,0			:end-of-command

:	Half-Duplex BAUDOT SIO Input Routine
:	=========== ====== === ===== =======
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R7 -	Character from SIO driver
:	R9 -	Pointer to SIO character
:	RPI -	Pointer to port-table entry
:	RP -	port number
VHSBAD	LHL	R9,XINSIO,RP,RP		:get pointer to current buffer
	LH	R7,0,R9			:Look at first character
	JGE	VHSBA4			:SIO's been here, left a char?

	LR	R8,R9			:nothing here, perhaps in next buffer?
	AHI	R9,SIBFSZ		:   /
	NHI	R9,-SIBFSZ		: wrap to next buffer (10 = bufsiz)
	THI	R9,(NSIOBF-1)*SIBFSZ	:if on, not yet time to wrap
	JNFS	VHSBA1

	SHI	R9,NSIOBF*SIBFSZ	: time to wrap
VHSBA1	LH	R7,0,R9			: anything in next buffer?
	JL	VDEF			:no, try next foreground time...

	LH	R0,0,R8			:yes, did SIO sneak them in between
	JL	VHSBA4			: these instructions? (no...)

	LR	R9,R8			:yes, read chars from orig. pointer
	LR	R7,R0			:and get correct character in R7
	JFS	VHSBA4			:found a char, now process it

VHSBA2	THI	R9,(NSIOBF-1)*SIBFSZ!(SIBFSZ-1)	:is it time to wrap?
	JNFS	VHSBA3

	SHI	R9,NSIOBF*SIBFSZ	:wrap...
VHSBA3	LH	R7,0,R9			:get the next character
	JGE	VHSBA4			:there is character there

	STH	R9,XINSIO,RP,RP		:no, found a -1
	J	VDEF			:'til next foreground!

:	Now process all characters in buffer
VHSBA4	TS	0,R9			:reset cell to -1
	 IF	SHIST;	JAL	R0,SHISTY		:trace;	 EI
	AIS	R9,2			:bump pointer to next character
	THI	R7,100			:test for BREAK
	JEFS	VHSBA5			:normal character...skip
	JAL	RCH,SIOBRK		:See if time for BREAK
	J	VHSBA2			:next char...

:	Service normal data-character
VHSBA5	RBT	RP,D.PAS2		:cancel any break in progress
	RBT	RP,D.PAS1
	NHI	R7,1F			:mask down the character
	TBT	RP,BICF			:which case to use
	JEFS	VHSBA6			:letter
	OHI	R7,(B.CCIT+1)*20	:number...USE CCITT TRANSLATION TABLE!
VHSBA6	LB	RBC,BAUD.A,R7		:get the ASCII character
	THI	RBC,80			:is this real data?
	JEFS	VHSBA7			:no...skip to interpret
	JAL	RCH,PUTCHR		:yes...pass it on
	J	VHSBA2			:and repeat

VHSBA7	SIS	RBC,1			:special character...
	JGFS	VHSBA8			:letter-shift
	JL	VHSBA2			:0...ignor
	SBT	RP,BICF			:number-case
	J	VHSBA2
VHSBA8	RBT	RP,BICF			:letter-case
	J	VHSBA2


:	Half-Duplex BAUDOT SIO Output Routine
:	=========== ====== === ====== =======
XHSBAD	JAL	RCH,SIOIDL		:See if ok to output
	J	XDEF			:Defer output and exit
XHSBA2	JAL	RCH,GETCHR		:get the character
	 J	XHSBAC			:Control-signal...go process it
	NHI	RBC,7F			:mask the character
	LB	R0,A.BAUD,RBC		:get the BAUDOT character
	JE	XHSBA5			:ignor nulls
	LHL	R7,OUTSIO,R9		:get cursor
	THI	R0,80			:check for case-independence
	JN	XHSBA4			:send immediately if so
	LHI	R1,(.BADLC^8)!.BADNC!20	:set up case-shift constant
	TBT	RP,BICF			:check current case
	JNFS	XHSBA3
	EXBR	R1,R1			:letter case...swap
XHSBA3	XR	R1,R0			:check the shift required
	THI	R1,20			:check if same case as current
	JEFS	XHSBA4			:skip if OK
	CBT	RP,BICF			:else change case
	EXBR	R1,R1			:R1 contains case-shift to send
	NHI	R1,1F			:clear high-order bits
	STB	R1,OUTSIO+2,R7,R9	:send case character
	AIS	R7,1			:bump index
XHSBA4	NHI	R0,1F			:clear high-order bits
	STB	R0,OUTSIO+2,R7,R9	:put data-character away
	AIS	R7,1			:bump character count
	STH	R7,OUTSIO,R9		:save cursor
XHSBA5	TBT	RP,TOPORT		:any more?
	JEFS	XHSBA6			:no...just terminate
	LB	R1,OBRATE,RP		:
	CH	R7,XSIOBL,R1,R1		:reached output limit?
	JL	XHSBA2			:no
XHSBA6	JAL	R0,X.SIO		:send data as appropriate
	J	XRET			:...then exit

:	Control-signal in stream...close output first
XHSBAC	JAL	R0,X.SIO		:send data as appropriate
:	RLINK -	Link register
:	R5 -	Signal to examine
	SIGBGN(EADSIG,LADSIG,SHGSIG,SEXSIG-QQMSIG)
	SIGEXC(ETMSIG,S.BETM)		:enter-transparency-mode
	SIGEND

:	Enter-Transparency-Mode
S.BETM	LA	R0,VHSBGD
	LA	R1,XHSBGD
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK
:	Transparent (glass) Half-Duplex BAUDOT SIO


:	Half-Duplex BAUDOT SIO Input Routine
:	=========== ====== === ===== =======
:	Register assignments for this driver
:	RBP -	From-port buffer index
:	R7 -	Character from SIO driver
:	R9 -	Pointer to SIO character
:	RPI -	Pointer to port-table entry
:	RP -	port number
VHSBGD	LHL	R9,XINSIO,RP,RP		:get pointer to current buffer
	LH	R7,0,R9			:Look at first character
	JGE	VHSBG4			:SIO's been here, left a char?

	LR	R8,R9			:nothing here, perhaps in next buffer?
	AHI	R9,SIBFSZ		:   /
	NHI	R9,-SIBFSZ		: wrap to next buffer (10 = bufsiz)
	THI	R9,(NSIOBF-1)*SIBFSZ	:if on, not yet time to wrap
	JNFS	VHSBG1

	SHI	R9,NSIOBF*SIBFSZ		: time to wrap
VHSBG1	LH	R7,0,R9			: anything in next buffer?
	JL	VDEF			:no, try next foreground time...

	LH	R0,0,R8			:yes, did SIO sneak them in between
	JL	VHSBG4			: these instructions? (no...)

	LR	R9,R8			:yes, read chars from orig. pointer
	LR	R7,R0			:and get correct character in R7
	JFS	VHSBG4			:found a char, now process it

VHSBG2	THI	R9,(NSIOBF-1)*SIBFSZ!(SIBFSZ-1)	:is it time to wrap?
	JNFS	VHSBG3

	SHI	R9,NSIOBF*SIBFSZ	:wrap...
VHSBG3	LH	R7,0,R9			:get the next character
	JGE	VHSBG4			:there is character there

	STH	R9,XINSIO,RP,RP		:no, found a -1
	J	VDEF			:'til next foreground!

:	Now process all characters in buffer
VHSBG4	TS	0,R9			:reset cell to -1
	 IF	SHIST;	JAL	R0,SHISTY		:trace;	 EI
	AIS	R9,2			:bump pointer to next character
	THI	R7,100			:test for BREAK
	JEFS	VHSBG5			:normal character...skip
	JAL	RCH,SIOBRK		:See if time for BREAK
	J	VHSBG2			:next char...

:	Service normal data-character
VHSBG5	RBT	RP,D.PAS2		:cancel any break in progress
	RBT	RP,D.PAS1
	NHI	R7,1F			:mask down the character
	CLHI	R7,.BADLC		:letter-case?
	JNFS	VHSBG6			:no
	RBT	RP,BICF			:yes...set letter-case
	JFS	VHSBG7			:go send it
VHSBG6	CLHI	R7,.BADNC		:number-case?
	JNFS	VHSBG7			:no
	SBT	RP,BICF			:yes...set number-case
VHSBG7	LHI	RBC,0E0,R7		:insure high-order bits are set
	JAL	RCH,PUTCHR		:send it along
	J	VHSBG2

:	Half-Duplex BAUDOT SIO Transparent Output Routine
:	=========== ====== === =========== ====== =======
XHSBGD	JAL	RCH,SIOIDL		:See if ok to output
	J	XDEF			:defer output and exit
XHSBG2	JAL	RCH,GETCHR		:get the character
	 J	XHSBG6			:Control-signal...go process it
	NHI	RBC,1F			:mask the character
	CLHI	RBC,.BADLC		:record case-shifts
	JNFS	XHSBG3
	RBT	RP,BICF
	JFS	XHSBG4
XHSBG3	CLHI	RBC,.BADNC		:record case-shifts
	JNFS	XHSBG4
	SBT	RP,BICF
XHSBG4	LHL	R7,OUTSIO,R9		:get cursor
	STB	RBC,OUTSIO+2,R7,R9	:put data-character away
	AIS	R7,1			:bump character count
	STH	R7,OUTSIO,R9		:save cursor
	TBT	RP,TOPORT		:any more?
	JEFS	XHSBG5			:no...just terminate
	LB	R1,OBRATE,RP		:
	CH	R7,XSIOBL,R1,R1		:reached output buffer limit?
	JL	XHSBG2			:no...just continue
XHSBG5	JAL	R0,X.SIO		:send data as appropriate
	J	XRET			:...then exit

:	Control-signal in stream...close output first
XHSBG6	JAL	R0,X.SIO		:transmit as appropriate
:	RLINK -	Link register
:	R5 -	Signal to examine
	SIGBGN(ETMSIG,EADSIG,LADSIG,SHGSIG,SEXSIG-QQMSIG)
	SIGEXC(ZAPSIG,S.BZAP)		:Zapper
	SIGEXC(LTMSIG,S.BLTM)		:leave transparency
	SIGEND

:	Zapper
S.BZAP	LA	RLINK,ZAPPER		:exit via zapper

:	Leave-Transparency-Mode
S.BLTM	LA	R0,VHSBAD
	LA	R1,XHSBAD
	ST	R0,.VSTAT,RPI
	ST	R1,.XSTAT,RPI
	JR	RLINK

	 EI	:BAUDY
	SUBTTL  (CONST) SIO UTILITY FUNCTIONS

:	Check if echo is permitted...ECOSIO is -1 if not
:	R8 -	8-word offset for port
:	RP -	Actual port number
:	RCH -	link register
VSECCK	TS	ECOSIO			:default is no-echo
	TBT	RP,TOPRTP		:check buffer toward port
	JNR	RCH			:can't echo if output present
	LIS	R0,0
	STH	R0,ECOSIO		:set echo-possible
	JR	RCH			:and return


:	SIO Break-handling logic
:	RCH -	link register
SIOBRK	RBT	RP,D.PAS2		:cancel pass 2
	SBT	RP,D.PAS1		:See if time for BREAK
	JNR	RCH			:ignor if already sent
	L	RBP,.FTBUF,RPI		:set from-terminal buffer-pointer
	 LO	SIGNAL
	LIS	R4,BBSIG		:Send BREAK-signal
	 FO	SIGNAL
	TBT	RP,TSNBRK		:enable the flush-flag?
	JE	PUTSIG			:no...exit by sending it
	SBT	RP,TOSING		:yes...set the flush-flag
	J	PUTSIG			:and exit by sending it

:	Transmit an SIO buffer (single buffered output)
:	R0 -	Link register
:	R9 -	offset for SIO tables
:	R3,R4 -	scratch registers
X.SIO	LH	R3,OUTSIO,R9		:check if any data buffered
	JER	R0			:no...just exit
	LHL	R9,OCMSOF-2*.SPORT,RP,RP	:get cmd offset
	LIS	R3,4			:get output command
	STH	R3,OCMSIO,R9		:
	SIOIO(R3,OCMSIO`,R9)		:start output
	LHL	R9,OUTSOF-2*.SPORT,RP,RP	:get bfr offset
	JR	R0			:exit


:	Transmit an SIO buffer (double buffered output)
:	R0 -	Link register
:	R9 -	offset for SIO tables
:	R3,R4 -	scratch registers
X.ALT	TBT	RP,SIOALT		:check which output buffer
	JN	X.ALT2			:
	LHL	R9,OUTSOF-2*.SPORT,RP,RP	:get offset
	LH	R3,OUTSIO,R9		:check if any data buffered
	JER	R0			:no...just exit
	SBT	RP,SIOALT		:set alternate buffer flag
	LHL	R9,OCMSOF-2*.SPORT,RP,RP	:get offset
	LIS	R3,0			:get a stop command (0)
	STH	R3,OCMSIO+4,R9		:store it
	LIS	R3,4			:get an output command (4)
	STH	R3,OCMSIO,R9		:store it
	LIS	R3,2			:get a jump command (2)
	STH	R3,OCMSIO+14,R9		:chain last cmd to this cmd
	LH	R3,OCMSIO+10,R9		:get last output cmd
	JEFS	X.ALT1			:if 0, no cmd
	CHI	R3,4			:if 4, output in progress
	JER	R0			:exit, let SIOBSY check later
	CHI	R3,100			:if 100, SIO advanced to next cmd
	JER	R0			:exit, let SIOBSY check later
	LIS	R3,0			:must be 200, SIO stopped
	STH	R3,OCMSIO+10,R9		:reset cmd for SIOBSY
X.ALT1	SIOIO(R3,OCMSIO`,R9)		:start SIO output
	JR	R0			:...then exit

X.ALT2	LHL	R9,OUTSOF-2*.SPORT,RP,RP	:get offset
	LH	R3,OB2SIO,R9		:check if any data buffered
	JER	R0			:no...just exit
	RBT	RP,SIOALT		:clear alternate buffer flag
	LHL	R9,OCMSOF-2*.SPORT,RP,RP	:get offset
	LIS	R3,0			:get a stop command (0)
	STH	R3,OCMSIO+14,R9		:store it
	LIS	R3,4			:get an output command (4)
	STH	R3,OCMSIO+10,R9		:store it
	LIS	R3,2			:get a jump command (2)
	STH	R3,OCMSIO+4,R9		:chain last cmd to this cmd
	LH	R3,OCMSIO,R9		:get last output cmd
	JEFS	X.ALT3			:if 0, no cmd
	CHI	R3,4			:if 4, output in progress
	JER	R0			:exit, let SIOBSY check later
	CHI	R3,100			:if 100, SIO advanced to next cmd
	JER	R0			:exit, let SIOBSY check later
	LIS	R3,0			:must be 200, SIO stopped
	STH	R3,OCMSIO,R9		:reset cmd for SIOBSY
X.ALT3	SIOIO(R3,OCMSIO+10`,R9)		:start SIO output
	JR	R0			:...then exit

:	check if sio port busy (output)
:	return +0 if current output buffer busy, else skip  return +4
:	RP  -	Port number
:	RCH -	Link register
:	R1  -	Scratch register
:	R9  -	Returned offset for SIO tables
SIOBSY	LHL	R9,OUTSOF-2*.SPORT,RP,RP	:get output buffer offset
	LHL	R1,OCMSOF-2*.SPORT,RP,RP	:get command buffer offset
	TBT	RP,SIOALT		:which buffer should be free?
	JN	SIOBS2			:
	LHL	R0,OCMSIO,R1		:check command there
	JE	SIOBS1			:none, skip other checks
	CHI	R0,4			:output cmd?
	JER	RCH			:exit if output still in progress
	CHI	R0,100			:SIO advanced to next chained cmd?
	JE	SIOBS1			:yes, skip 
	CHI	R0,200			:SIO stopped?
	JN	SIOBS1			:
	LHL	R0,OCMSIO+10,R1		:SIO stopped, check other cmd
	JE	SIOBS1			:none
	CHI	R0,4			:output cmd?
	JN	SIOBS3			:no
	SIOIO(R3,OCMSIO+10`,R9)		:yes, chain failed, restart SIO
SIOBS1	LIS	R0,0			:
	STH	R0,OCMSIO,R1		:reset cmd
	STH	R0,OUTSIO,R9		:reset character count
	J	4,RCH			:take skip return

SIOBS2	LHL	R0,OCMSIO+10,R1		:check command 
	JE	SIOBS3			:none, skip other checks
	CHI	R0,4			:output cmd?
	JER	RCH			:exit if output still in progress
	CHI	R0,100			:SIO advanced to next chained cmd?
	JE	SIOBS3			:yes, skip 
	CHI	R0,200			:SIO stopped?
	JN	SIOBS3			:
	LHL	R0,OCMSIO,R1		:SIO stopped, check other cmd
	JE	SIOBS3			:none, skip checks
	CHI	R0,4			:output cmd?
	JN	SIOBS3			:no
	SIOIO(R3,OCMSIO`,R9)		:yes, chain failed, restart SIO
SIOBS3	LIS	R0,0			:
	STH	R0,OCMSIO+10,R1		:reset cmd
	STH	R0,OB2SIO,R9		:reset character count 
	J	4,RCH			:take skip return

:	check if sio port idle (output)
:	skip return +4 if both buffers idle, else return +0
:	RP  -	Port number
:	RCH -	Link register
:	R1  -	Scratch register
:	R9  -	Returned offset for SIO tables
SIOIDL	LHL	R9,OUTSOF-2*.SPORT,RP,RP	:get output buffer offset
	LHL	R1,OCMSOF-2*.SPORT,RP,RP	:get command buffer offset
	LHL	R0,OCMSIO,R1		:Check command there
	CHI	R0,4			:what is it?
	JER	RCH			:exit if output bfr 1 is busy
	LIS	R0,0			:
	STH	R0,OCMSIO,R1		:clear old cmd
	STH	R0,OUTSIO,R9		:clear char count
	LHL	R0,OCMSIO+10,R1		:Check command 
	CHI	R0,4			:what is it?
	JER	RCH			:exit if output bfr 2 is busy
	LIS	R0,0			:
	STH	R0,OCMSIO+10,R1		:clear old cmd
	STH	R0,OB2SIO,R9		:clear char count
	J	4,RCH			:take skip return, both are idle

	SUBTTL  (CONSAT) SIO HANG/ANSWER



:				 **** *****  ***
:				*       *   *   *
:				 ***    *   *   *
:				    *   *   *   *
:				****  *****  ***

:	*   *   *   *   *  ***          *   *   *  **** *   * ***** ****
:	*   *  * *  **  * *   *        * *  **  * *     *   * *     *   *
:	***** ***** * * * *     ***** ***** * * *  ***  * * * ****  ****
:	*   * *   * *  ** *  **       *   * *  **     * ** ** *     *  *
:	*   * *   * *   *  ****       *   * *   * ****  *   * ***** *   *

:	1 second logic to check for changes in receiver active
	GL	BRKSIO,QHASIO,Q.SANS
QHASIO	LHI	RP,.SPORT-1		:For SIO-ports
QHANS1	AIS	RP,1			:For next port
	CLHI	RP,.SPORT+NSPORT	:Last port?
	JGE	CSDISM			:yes...done
	TBT	RP,GOTSIO		:service ports which are there
	JEBS	QHANS1			:nothing to do for this port
	GETPTP(RPI,RP,RP)			:set port-table pointer
	LHL	R9,OCMSOF-2*.SPORT,RP,RP	:get offset
	LB	R0,STASIO,R9		:get status
	CLHI	R0,0FF			:get this when unplugged
	JE	QHANS1			:
	THI	R0,028			:CP and DSR off?
	JE	QHANS6			:yes...disconnect
	TBT	RP,HANGWT		:port active...should it be hung?
	JN	QHANS6			:Yes, then try to hang
	SBT	RP,RLA			:was he off?
	JN	QHANS1			:was on, continue
:	Now initialize this port (Answer it)
        L       R2,SLOWC,,              :get and save time *500.sdw
        ST      R2,.TIME,RPI		:
	L	RBP,.FTBUF,RPI		:empty the buffers
	JAL	RCH,EMPTY		:
	L	RBP,.TTBUF,RPI		:
	JAL	RCH,EMPTY		:
	SBT	RP,XONOUT		:Init XON already out
	SIOIO(R2,XOFSIO)		:disable xon-xof for SIO channel
	SBT	RP,SIOSTD		:run XON-XOFF program
	SBT	RP,NEWLOG		:...New logon
	SBT	RP,LGECHO		:...assume logon-echo required
	RBT	RP,RXON			:...reverse X-ON off
	RBT	RP,D.PAS1		:...not in break-state
	RBT	RP,D.PAS2		:
	RBT	RP,HWTSIO		:...not in wait to hang state
	 IF	NPAPRT
	JAL	R0,PA.SL		:set limbo if required
	GL	PA.SL
	EI	:NPAPRT
:	we're playing funny games with addressing, since SIO card
:		expects addresses/10x, and we're obliging it.
	RBT	RP,SIOALT		:init double buffering flag
	LHL	R9,OCMSOF-2*.SPORT,RP,RP	:get command bfr offset
	LHL	R6,OUTSOF-2*.SPORT,RP,RP	:get output bfr offset
	LIS	R0,0			:
	STH	R0,OUTSIO,R6		:make sure output bfr shows 0 data
	STH	R0,OB2SIO,R6		:make sure output bfr shows 0 data
	LA	R3,OUTSIO,R6		:get output data quad-address
	SRLS	R3,4			:now make address into SIO space
	ST	R3,OCMSIO,R9		:set output addr (bfr 1)
	LA	R3,OCMSIO+10,R9		:get addr of second output cmd
	SRLS	R3,4			:now make addr into SIO space
	AI	R3,20000		:add jmp cmd (2)
	ST	R3,OCMSIO+4,R9		:set jump (to output bfr 2 cmd)
	LA	R3,OB2SIO,R6		:get output data quad-address
	SRLS	R3,4			:now make address into SIO space
	ST	R3,OCMSIO+10,R9		:set output addr (bfr 2)
	LA	R3,OCMSIO,R9		:get addr of first output cmd
	SRLS	R3,4			:now make addr into SIO space
	AI	R3,20000		:add jmp cmd (2)
	ST	R3,OCMSIO+14,R9		:set jump (to output bfr 1 cmd)
	LHL	R6,INPSOF-2*.SPORT,RP,RP	:get offset into INPSIO for port
	LA	R3,INPSIO,R6		:make it an address
	STH	R3,XINSIO,RP,RP		:set up input index
	LCS	R0,1			:
QHANS2	ST	R0,INPSIO,R6		:Init it word by word
	AIS	R6,4			:...to no data-present
	THI	R6,(NSIOBF*10)-4	:mask for end of buffer
	JNBS	QHANS2			:
	SRLS	R3,4			:convert to quadword
	AI	R3,40000		:input cmd (4), address/10x
	LHL	R9,ICMSOF-2*.SPORT,RP,RP	:get offset to command buffer
	LIS	R5,0			:get offset into command buffer
QHANS3	ST	R3,ICMSIO,R9,R5		:Store command at ICMSIO+OFFSET
	AIS	R3,SIBFSZ/10		:address = address + bufsiz/10x
	AIS	R5,4			:bump pointer
	CLHI	R5,4*NSIOBF		:done?
	JLBS	QHANS3			:
	LA	R0,ICMSIO,R9		:get address of first input cmd
	SRLS	R0,4			:convert to quadword address
	AI	R0,20000		:jump cmd (2)
	ST	R0,ICMSIO,R9,R5		:set jmp to first input cmd
	LA	R5,SAVSIO		:set initialization program
	 IF	STOP2
	TBT	RP,.STP2		:does it need 2 stop bits('D' at 110?)
	JEFS	QHNS3A			:no, do next test (if any)
	LA	R5,SAVSI2		:yes, get address
QHNS3A	 EI	:STOP2
	 IF	BAUDY
	TBT	RP,.BAUD,,		:is this BAUDOT port?*6.02dlg
	JEFS	QHANS4			:no
	LA	R5,SAVSIB		:yes...set alternate init. address
QHANS4	 EI	:BAUDY
	SIOIO(R3,0`,R5)			:start initialization program
	LHL	R6,ICMSOF-2*.SPORT,RP,RP	:get pointer
	JAL	RLINK,Q.SANS,,		:and start input
	 IF	PVC
	GL	AIDPVC
	JAL	RLINK,AIDPVC		:Check if PVC auto-ID port
	 J	QHANS5			:no...proceed
	J	QHANS1			:yes...done!

QHANS5	 EI	:PVC
	SBT	RP,C.ACP		: set port active
	LHI	R4,TID.S		:set as SIO-type terminal
	JAL	R5,IZPORT		:set up CONSAT terminal parameters
       IF      X3ON
        JAL     RBF,IXPROF,,
       EI
  IF	X3ON
	JAL	RBF,IXPROF,,		:set up PAD terminal parameters
  EI	:X3ON
	LHL	R1,.TERMT,RPI		:get terminal type
	LHL	R1,VID.IZ,R1,		:get initialization routine
	LIS	R5,0			:set "vanilla"
	JAL	RLINK,BASE,R1,		:go establish port
QHAN15	J	QHANS1			:continue

:	CP & DSR down, or HANG set
QHANS6	THI     R0,28			:6.00 SDW - carrier or DSR?
        JEFS	QHAN26			:6.00 SDW - if not, then hang
	TBT	RP,YONENA		:Is XOFF enabled
	JEFS	QHAN16			:If not, see if done outputting
	TBT	RP,RXON			:is wait state set
	JNFS	QHAN26			:is set, hang immediately
QHAN16	ST	R0,SIOSV		:6.00 SDW - save R0
	JAL	RCH,SIOIDL		:see if output complete
	J	QHANS1			:defer hang til later
	L	R0,SIOSV		:6.00 SDW - restore R0
QHAN26	SBT	RP,HWTSIO		:set waiting to hang
	JE	QHANS1			:first time...don't hang
	RBT	RP,RLA			:was it off? 	 	
	JE	QHANS7			:yes...continue
:	Circuit disconnected...flag hung
	SBT	RP,HANGWT		:set it hung so we can recover
	RBT	RP,C.ACP		:set not active
	L	RBP,.FTBUF,RPI		:empty the buffers
	JAL	RCH,EMPTY		:
	L	RBP,.TTBUF,RPI		:
	JAL	RCH,EMPTY		:
	SIOIO(R3,HNGSIO)		:hang the port (DTR -> false)
        LIS     R0,0            	:6.00 SDW - 0 is completed status
	LHL	R9,OCMSOF-2*.SPORT,RP,RP	:
        STH     R0,OCMSIO,R9	 	:6.00 SDW - say output done
        STH     R0,OCMSIO+10,R9	 	:6.00 SDW - say output done
	JAL	RLINK,DT.PRT		:for tymnet-II - disconnect ckt
	J	QHANS1

:	Port is off (RLA = 0)
QHANS7	TBT	RP,HANGWT		:check soft hang
	JE	QHANS1			:already reset...nothing to do
	THI	R0,028			:in soft-hang state...
	JN	QHANS1			:...wait for DSR to fall
	RBT	RP,HANGWT		:OK...now reset soft hang
	SIOIO(R3,ENASIO)		:and enable hardware
	J	QHANS1			: (DTR -> true)


:	SIO BREAK-DETECT
:	=== ===== ======
:	.25 second logic to check for BREAK timeout
:	This is the environment-independent portion of SIO break timeout
:	(since the SIO card doesn't detect break-begin or break-end,
:	we must fake it with a timeout, to insure we can recognize the
:	end-of-break state.)
BRKSIO	LHI	RPOL,(.SPORT/8)+(NSGRP*2)-2	:For all SIO groups...
BRKS1	LH	R1,RLA,RPOL		:Service ports that are on line
	NH	R1,GOTSIO,RPOL		:...and are there
	NH	R1,D.PAS1,RPOL		:....and which are PAS1
	STH	R1,P.DONE		:put it away
BRKS2	LH	R1,P.DONE		:More to do?
	JFFOH	R1,BRKS3		:yes...skip
	SIS	RPOL,2			:else repeat for all groups
	CLHI	RPOL,.SPORT/8		:SIO starts at this group
	JGE	BRKS1
	J	CSDISM		:Done...return

BRKS3	RBT	R2,P.DONE		:flag port processed
	LR	RP,RPOL			:compute real port number
	SLLS	RP,3
	AR	RP,R2			:make port number
	CBT	RP,D.PAS2		:Switch PAS2
	JE	BRKS2			:was 0....continue
	RBT	RP,D.PAS1		:Else turn off PAS1
	J	BRKS2
	 EI	:NSPORT


	FO	DATA
	EM	:CONSAT
C R