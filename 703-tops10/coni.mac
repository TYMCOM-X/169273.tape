SUBTTL	EXECUTIVE UUO DISPATCHERS
$HIGH
KTUUO:
	JRST	@.USMUE		;E FIELD OF THE MUUO IS TRAP HANDLER ADDRESS
				; N.B., USRIOT ISN'T ON

SNTUUO:	HALT	.		;NOT IMPLEMENTED
STUUO:	HALT	.		;NOT IMPLEMENTED
CTUUO:PTUUO:
	EXECAC
	HRLZ	T1,.USMUO
	IOR	T1,.USMUE
	JUMPL	T1,ILLTIN##

	CAILE	T1,UP.MLT
	JRST	ILLTIN##
	JRSTF	@UUTDSP(T1)
UUTDSP:	IC.UOU+SEILM##		;PAGE FAULT
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+SEPDLO##		;PUSH DOWN LIST OVERFLOW
	IC.UOU+ILLTIN##		;TRAP 3
	IC.UOU+SUILM##		;USER ENABLED PAGE FAULT
	IC.UOU+SAROVF##		;USER ENABLED ARITHMETIC OVERFLOW
	IC.UOU+SUPDLO##		;USER ENABLED PDL OVERFLOW
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+ILLTIN##		;NOT IMPLEMENTED
	IC.UOU+PSIAPR		;PSI ENABLED ARITHMETIC OVERFLOW
	$ABS
LUUOPC::0			;JSR HERE ON A LUUO IN EXEC MODE
	EXCH	T1,LUUOPC
	MOVEM	T1,.USMUP
	JRST	UUOERR##
TRP3PC:	0			;JSR HERE ON A TRAP 3 IN EXEC MODE
	HALT	.
SUBTTL	SOME DEFINITIONS FOR KL10'S
IFN M.KL10,<
KLRELC==.
	LOC	420
	IFN	./2*2-.,<0>	;MAKE SURE THEY START ON EVEN LOCATION
FREORG:	BLOCK	ALLKON*4	;ICCW BLOCKS
	BLOCK	13*4
FRE4LN==<.-FREORG>/4		;NUMBER OF 4-WORD BLOCKS

	LOC	KLRELC
>;END IFN M.KL10
SUBTTL	KS10 UBA INTERRUPT VECTOR TABLES

IFN M.KS10,<
;TABLES FOR DISPATCHING 11-STYLE VECTORED INTERRUPTS FROM THE
;KS10'S UNIBUS ADAPTORS. INITIALLY SET TO ZEROS.
;APPROPRIATE LOCATIONS WILL BE SET UP BY THE DEVICE SERVICE ROUTINES.

VECTB1::			;UBA 1 VECTOR TABLE
;REPEAT ^D128,<0>		;THIS IS WHAT'S ASSEMBLED
XLIST
REPEAT ^D128,<0>
LIST
VECTB3::			;UBA 3 VECTOR TABLE
XLIST
REPEAT ^D128,<0>
LIST
>;END IFN M.KS10
SUBTTL	CPU START-UP CODE

;NOTE: CODE AT ENTDDT SHOULD MATCH CODE FROM SYSTRT THROUGH CALL TO SYSTR0

SYSTRT::EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JRST	SYSINI##	;BOOT CPU
IFG <CPUN-1>,<
	JRST	SPRINI		;NON-BOOT CPU
>
IFLE <CPUN-1>,<
	HALT	.		;ATTEMPT TO START NON-BOOT CPU WITH A SINGLE CPU MONITOR
>
;SUBROUTINE TO SEE WHICH CPU THIS IS (CALLED ON SYSTEM
; STARTUP AND POWER FAIL AUTO-RESTART)
;CALLING SEQUENCE:
;	JSP	T4,SYSTR0
;	RETURN HERE IF BOOT CPU
;	RETURN HERE IF NON-BOOT CPU
SYSTR0::TLO	T4,(IC.UOU)	;TURN ON USRIOT FOR RETURN
IFN M.KL10,<
	CONO	APR,LP.CSF!LP.CSD
	DATAI	CCA,		;INVALIDATE CACHE, NOT VALIDATING CORE
	CONSO	APR,LP.CSD
	JRST	.-1
	CONO	APR,LP.CSF!LP.CSD
>
IFN M.KS10,<
	RDUBR	T2		;INVALIDATE CACHE
	WRUBR	T2
>
SYSTR1::APRID	T1		;READ CPU SERIAL #
	MOVE	T3,T1		;COPY
	ANDI	T1,ID.PSN	;JUST SERIAL # BITS
IFN FTMP,<
	SKIPGE	INTRST
	AOSE	INTRST
	JRST	.-2
>
	MOVEI	T2,.C0CDB
SYSTR2:	CAME	T1,.CPASN-.CPCDB(T2)
	JRST	SYSTR6
SYSTR3:	MOVEM	T3,.CPAPD-.CPCDB(T2)
	MOVE	T3,.CPMAP-.CPCDB(T2)
	SETOM	.CPOCB-.CPCDB(T2)

;MAP THE FIRST (AND POSSIBLY ONLY) PAGE OF THE CDB AT .ESKPC

IFN M.KL10,<
	APRID	T1		;GET OPTION BITS
	TRNN	T1,ID.MCA	;MCA25 INSTALLED?
	TDZA	T1,T1		;NO
	MOVSI	T1,(PM.KPM)	;YES
	MOVEM	T1,.CPKPM-.CPCDB(T2)
>
	MOVE	T1,T2
	LSH	T1,W2PLSH
	TLO	T1,(<PM.DCD>B2+PM.WRT+PM.PUB)
IFN M.KL10,<
	IOR	T1,.CPKPM-.CPCDB(T2)
>
	MOVEM	T1,.ESKPC/PAGSIZ(T3)


IFN <RHWEVM-^D3>,<IFN <RHWEVM-^D4>,<PRINTX ?RHWEVM IS SET TO AN UNKNOWN VALUE>>
;CODE BELOW IS TO MAP SECOND PAGE OF CDB IN THE .CP AREA
;RHWEVM IS CURRENTLY ONLY 3 OR 4, MEANING 1 OR 2 PAGE CDB. WHENEVER
;A CBD GOES OVER 2 PAGES, MORE CODE WILL HAVE TO BE ADDED HERE.

IFG <RHWEVM-^D3>,<
	AOS	T1
	MOVEM	T1,.ESKPC/PAGSIZ+1(T3)
> ;END IFG RHWEVM-^D3
IFN FTKL10,<
	MOVE	T1,.CPKPM-.CPCDB(T2)
	MOVE	T3,.CPEPT-.CPCDB(T2)
	IORM	T1,SECTAB+0(T3)		;TURN ON "KEEP ME" IN SECTION 0 AND 1 MAP POINTERS
	IORM	T1,SECTAB+1(T3)
	XJRSTF	[EXP XC.UOU,.+1]	;SET PRVIOUS CONTEXT USER, PCS =0
	DATAI	PAG,P3			;SET PREVIOUS CONTEXT AC SET TO 6
	AND	P3,[7B8]
	TLO	P3,(1B0+6B11)
	DATAO	PAG,P3
	MOVSI	T1,[EXP -1,0,0]		;NO CST UPDATE(AND MASK,OR MASK,BASE ADDR 0=NONE)
	EXCTXU	<BLT T1,2>		;SET LOCATIONS IN AC SET 6, FOR CSTS
	MOVEI	T1,SPTTAB		;MAKE A POINTER TO THE SPT FOR THIS CPU
	EXCTXU	<MOVEM T1,3>		;SET IT UP IN AC SET 6 LOCATION 3
	TLC	P3,(7B11)		;PREVIOUS AC SET TO 1
	DATAO	PAG,P3
>
IFN FTKS10,<
	CONO	PAG,0			;OTHERWISE THE UCODE GETS HUNG
	WRCSTM	[-1]			;KEEP ALL CST BITS (AND MASK)
	WRPUR	[0]			;SET NOTHING FOR REF'D PAGES (OR MASK)
	WRCSB	[0]			;NO CST PRESENT REQUIRES UCODE 124 
					;WITH INHCST OR NOCST TURNED ON
	APRID	0			;READ OUR ID
	TLNE	0,(ID.KLP)		;BETTER SAY KLP IS AVAIL
	TLNN	0,(ID.NCU)		;AND SOME WAY TO TURN OFF CST
	STOPCD	.+1,HALT,WNGUCV		;++WRONG UCODE VERSION
	MOVEI	0,@.CPSPT-.CPCDB(T2)	;POINT TO OUR SMALL SPT
	WRSPB	0			;TELL THE MICROCODE
>
	MOVE	P3,@.CPSPT-.CPCDB(T2)	;SAVE ORIGINAL CONTENTS
	MOVEI	T1,NLUPMP/PAGSIZ	;ESTABLISH AN SPT
	MOVEM	T1,@.CPSPT-.CPCDB(T2)

IFN M.KL10,<
IFN FTXMON,<
;NOW SETUP THE MAPPING TO MAKE ALL OF THE USER SECTION MAPS ADDRESSABLE IN EXEC MODE
; THE MAPS START AT VIRTUAL ADDRESS UMAPS IN SECTION 37.
	MOVEI	T1,<SECTAB+(<PM.ICD>B2+PM.WRT+IFE FTMP,<PM.CSH>)>
	HRL	T1,.CPCPN-.CPCDB(T2) ;@THRU CURRENT CPU'S ASSIGNED SPT SLOT
	MOVEI	T3,.CPUMA-.CPCDB(T2)
SYSTR4:	MOVSM	T1,(T3)		;POINTER FOR NEXT USER SECTION MAP
	ADDI	T1,1		;NEXT SECTION
	CAIE	T3,.CPUMA-.CPCDB+MXSECN(T2) ;MAPPED ALL SECTIONS?
	AOJA	T3,SYSTR4	;NO, LOOP OVER ALL SECTIONS
> ;END IFN FTXMON
	CONO	PAG,@.CPEBR-.CPCDB(T2)
	DATAO	PAG,NULDOP	;SETUP UBR TO
				; NULL JOB'S UPT SO THAT MUUO'S, ACCOUNTING
				; METERS, EXEC PAGE FAILS DURING ONCE ONLY
				; WORK CORRECTLY. INHIBIT ACCOUNTING STORE
>
IFN M.KS10,<
	WREBR	0		;DO THIS IN CASE POWER UP. KS10 MICRO-CODE V111
				; HAS BUG THAT WILL CAUSE BOGUS PAR ERR
				; IF THIS ISN'T DONE
	WREBR	@.CPEBR-.CPCDB(T2) ;SET UP EXEC BASE REGISTER
	WRUBR	NULDOP		;SET UP USER BASE REGISTER TO NULL JOB
				; SO THAT MUUO'S & PAGE FAILS WORK DURING ONCE
	MOVEI	T1,.EPHSB	;SET UP HALT STATUS BLOCK
	WRHSB	T1		; DUMP ADDRESS
>
IFG <CPUN-1>,<
	MOVE	T2,BOOTWD
IFN M.KL10,<
	ANDI	T2,7777
>
	SKIPGE	BOOTCP		;IS THERE ALREADY SOMEBODY AS THE BOOT CPU
	CAME	T2,.CPASN	;SAME AS THE CURRENT CPU?
	AOJA	T4,SYSTR5	;NO, THIS MUST BE CPU1
>
IFE <CPUN-1>,<
	MOVE	T2,.CPASN
>
	MOVEM	T2,SERIAL	;STORE FOR SECOND GETTAB
	MOVE	T1,.CPCPN	;OUR CPU NUMBER
	MOVEM	T1,BOOTCP	;NOBODY ELSE DURING SYSTEM STARTUP
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
	MOVEM	T1,NLUPMP+.UMUPT

SYSTR5:
IFN FTMP,<
	SETOM	INTRST
>
	JRSTF	@T4		;DO CPU1 INITIALIZATION
SYSTR6:	HLRZ	T2,.CPCDB-.CPCDB(T2)
	JUMPN	T2,SYSTR2
	MOVEI	T2,.C0CDB
SYSTR7:	SKIPE	.CPOCB-.CPCDB(T2)
	JRST	SYSTR8
	MOVEM	T1,.CPASN-.CPCDB(T2)
	JRST	SYSTR3
SYSTR8:	HLRZ	T2,.CPCDB-.CPCDB(T2)
	JUMPN	T2,SYSTR7
IFN FTMP,<
	SETOM	INTRST
>
	HALT	.



APRRES::				;HERE ON TO RESTART
IFE FTMP,<
	EXECAC
	JSP	T4,SYSTR0		;THIS DOES THAT (AND TURNS PAGING ON)
;IFG CPUN-1,<				;SORTA HARD IFE FTMP, EH?
;	 JFCL
;>
	JRSTF	@[IC.UOU+AP0RES]
>;END IFE FTMP
IFN FTMP,<
	EXECAC
	JSP	T4,SYSTR0
IFG CPUN-1,<
	  JFCL
>
	XCT	.CPRES
>;END IFN FTMP
;HERE ON A RESTART AFTER SYSTEM SLEEP, REBOOT

SYSRST::EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JFCL			;ALWAYS RESTART VIA SPRINI
	SETZM	MBTCOM		;MAKE SURE THAT DUMPED CRASHES DON'T LOOK REBOOTABLE
	SETZM	CLKDDT		;ZERO CLKDDT SO WE DON'T JUMP TO EDDT
IFN FTKL10,<
	JSP	T4,ZAPICH	;MAKE SURE INT CHANS ARE IN A REASONABLE STATE
>;END IFN FTKL10
	MOVSI	T1,(CR.TSS)	;SUCCESSFUL DUMP BIT
	ANDCAB	T1,.CPRUN	;CLEAR THAT BECAUSE IT MUST HAVE BEEN OR WE WOULDN'T BE HERE
IFG <CPUN-1>,<
	TLNN	T1,(CR.RMV!CR.DET)	;REMOVED OR DETACHED CPU?
	JRST	SPRINI		;NO, REINITIALIZE
	MOVE	P,.CPNPD	;ANY OLD PUSH DOWN LIST WILL DO
	MOVEI	T1,[ASCIZ/?Cannot REBOOT on a CPU which has been removed or DETACHed
/]
	PUSHJ	P,CTYTYP##	;EXPLAIN THE ERROR
	PUSHJ	P,RMVCPU##	;AND GO AWAY
>
;FALL INTO SPRINI ON SINGLE CPU SYSTEMS
SUBTTL INITIALIZATION ON STARTUP/RESTART AFTER SYSTEM SLEEP
;NON-BOOT PROCESSOR INITIALIZATION. REINITIALZATION FOR ALL CPUS
; AFTER SYSTEM SLEEP

SPRINI::CONO	PI,CLRPIS	;CLEAR PI AND PARITY ERROR FLAG
	CONO	APR,APRRST	;RESET EVERYTHING AND ENABLE CLOCK
IFN FTKL10,<
	EXECAC			;MAKE SURE AC BLOCKS ARE OK
>
	MOVSI	P,(CR.RMV!CR.DET) ;"CPU IS DOWN" OR "DETACHED" BITS
	TDNE	P,.CPRUN	;CAN THIS CPU RUN YET
	JRST	.-1		;NO, WAIT UNTIL IT CAN
	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
IFN FTKL10,<
	MOVE	T1,.CPCPN
	PUSHJ	P,DTEINI##
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL
>;END IFN FTKL10
IFG <CPUN-1>,<
	PUSHJ	P,PRTCPU##	;TELL OPR WHO WE ARE
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT RATHER THAT START OR RESTART?
	JRST	SPRIN1		;YES, DON'T WAIT FOR A BOOT CPU TO COME TO LIFE
	MOVE	12,[ACLOOP##,,2];LOAD AC'S WITH WAIT LOOP
	BLT	12,12		;CPU1 WILL WAIT UNTIL CPU0 IS GOING
	MOVE	12,[JRST SPRIN1];TO EXIT LOOP
	SJSP	0,3		;ENTER LOOP

;INITIALIZE PD LIST
SPRIN1:	MOVE	P,.CPNPD	;SET UP PUSH DOWN POINTER
	PUSHJ	P,MAPINI##	;COPY THE BOOT CPU'S MAP INTO THE CURRENT CPU'S MAP
	JRSTF	@[EXP IC.UOU+.+1] ;TURN ON USER IOT SO EXECUTE PAGED WORKS
				; CORRECTLY AND PROCEED WITH INITIALIZATION
	CLRPGT	(0)
	CONO	PI,10000	;AND CLEAR PI SYSTEM
	MOVSI	T1,(CR.SPD)	;SUSPENDED BIT
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT?
	JRST	SPRIN5		;YES, DISKS ARE INITIALIZED
IFN FTAUTC,<
	PUSHJ	P,AUTCON##	;GO SEE WHAT DISKS, TAPES WE CAN TALK TO
>
SPRIN2:	MOVE	17,[ONCLOP##,,1] ;WAIT IN ACS FOR CPU0 TO REQUEST IO
	BLT	17,16		; DO IT (AT SPRIN3) WHEN REQUESTED
	SJSP	0,3
;HERE FROM LOOP IN THE ACS TO DO DISK I/O DURING ONCE-ONLY ON NON-BOOT CPUS
SPROIO::
SPRIN3:	MOVE	P,.CPNPD	;SET UP A PDL
	SKIPN	T1,ONCCOM	;WHAT CPU0 WANTS US TO DO
	JRST	SPRIN2		;NOTHING TO DO
	AOJE	T1,SPRIN2	;RESTARTED IF -1
	SOS	F,T1		;COMM WORD INTO F
	SOJE	T1,SPRIN5	;DONE IF +1
	PUSHJ	P,MAPINI##	;SOME OTHER NON BOOT CPU MAY
				; HAVE CHANGED MAPS
	PUSHJ	P,CPUDSP##	;GO DO SOME WORK
	JRST	SPRIN2		;AND WAIT SOME MORE

;HERE TO SET UP TO RUN NULL JOB, & SETUP PI
SPRIN5:	PUSHJ	P,MAPINI##
IFN FTSCA,<
IFN M.SCA,<
	CONO	PI,PI.ON+DSKPIN	;TURN ON THE PI SYSTEM AND THE DISK PI'S
	MOVSI	T1,(CR.SPD!CR.IIP)	;SUSPENDED OR INITIALIZE PENDING BITS
	TDNE	T1,.CPRUN	;RESTART AFTER REBOOT OR CPU STARTED LATE?
	PUSHJ	P,SPRIPX	;YES, RE-INITIALIZE THE PHYSICAL PORT DRIVERS
>; END IFN M.SCA
>; END IFN FTSCA
IFN FTKL10,<
	PUSHJ	P,CSDMP##	;ONCE ONLY/FILSER MAY HAVE DRAGGED
				; SOMETHING INTO THE CACHE
>
>
	MOVEI	T1,CCTYO##	;GET ADDRESS OF TYPEOUT ROUTINE
	MOVEM	T1,.CPTOA	; AND TELL SCNSER
	MOVEI	T1,COMTIV##	;GET ADDRESS OF COMMAND INPUT ROUTINES
	MOVEM	T1,.CPTIV	; AND TELL SCNSER TO USE LDB'S NOW.
	SETZM	.CPTNT		;JUST STARTING
	MOVE	J,.CPCPN	; FOR THIS CPU
	SETZM	CLKMIN(J)	;CLEAR MIN REQUEST
IFN FTMP,<
	SETOM	.CPSCD		;CLEAR SCHED NESTING
	SETZM	.CPNBI		;CLEAR NUMBER OF BROKEN INTERLOCKS
	SETOM	.CPDLK		;CLEAR DSKOFF NESTING
IFN FTSCA,<
	SETOM	.CPSCA		;CLEAR SCA BUFFER MANAGEMENT NESTING
>; END IFN FTSCA
IFN FTENET,<
	SETOM	.CPETH		;CLEAR ETHERNET NESTING
>; END IFN FTENET
>;END IFN FTMP
	SETOM	.CPDWD		;GIVE UP DIE RECURSION INTERLOCK
	SETZM	.CPAEF		;CLEAR CPU ERROR/SWEEP FLAGS
	HRRZS	.CPMPC		;CLEAR SERIOUS MEMORY PARITY HALT FLAG
				; HALT AFTER PRINTING ON CPU0 CTY
	MOVE	T1,TIME		;GET CURRENT TIME
	MOVEM	T1,.CPTML	;STORE FOR TICKS GONE BY
	MOVE	T2,TICSEC	;TICK PER SECOND
	LSH	T2,-1		;DIVIDE BY 2
	ADD	T1,T2		;AND ROUND
	IDIV	T1,TICMIN	;T2 = PARTIAL MINUTE (IN TICKS)
	IDIV	T2,TICSEC	;T2 = SECONDS, T3 = REMAINDER IN TICKS
	SUBI	T2,^D60		;COMPUTE TIME TO NEXT MINUTE
	MOVNM	T2,.CPSEC	;STORE FOR ONCE-A-MINUTE UPDATE
	SUB	T3,TICSEC	;TIME TO NEXT SECOND
	MOVNM	T3,.CPHTM	;STORE FOR ONCE-A-SECOND UPDATE
	MOVEI	T1,SR.STS!SR.DIE!SR.ACL ;CLEAR THESE BITS WHEN WE
	ANDCAM	T1,.CPSBR	; RESTART THE PROCESSOR
IFG <CPUN-1>,<
	MOVEI	J,JOBMAX	;MAX JOB NO.
	MOVSI	T1,(SP.CJ0)	;JOB RUNNING ON CPU1 BIT
	LSH	T1,@.CPCPN
SPRLP1:	ANDCAM	T1,JBTSPS(J)	;CLEAR FOR ALL JOB IN SYSTEM
				; (IN CASE THIS IS A 450 RESTART ON CPU1)
	SOJGE	J,SPRLP1	;MORE?
>
IFN FTKL10,<
	APRID	T3		;PROCESSOR HARDWARE OPTIONS
	DMOVE	T1,[M.EBPS	;ASSUME A MODEL A PROCESSOR
		M.MBPS]
	TRNE	T3,ID.XKL	;IS IT A MODEL B PROCESSOR?
	DMOVE	T1,[^D30*M.EBPS/^D25 ;YES, USE DIFFERENT EBOX/MBOX CALABRATION CONSTANTS
		^D30*M.MBPS/^D25]
	MOVEM	T1,.CPEBS	;STORE AS EBOX TICS/SEC
	MOVEM	T2,.CPMBS	;STORE AS MBOX TICS/SEC
	IDIV	T1,TICSEC	;AND NOW GET EBOX COUNTS/JIFFY
	IMULI	T1,.EBCPT	;MULTIPLY BY EBOX COUNTS/TICK
	MOVEM	T1,.CPEBJ	;STORE IN CDB VARIABLE
	MOVE	T1,.CPMBS	;GET MBOX TICKS/SECOND
	IDIV	T1,TICSEC	;GET MBOX COUNTS/JIFFY
	IMULI	T1,.MBCPT	;MULTIPLY BY MBOX COUNTS/TICK
	MOVEM	T1,.CPMBJ	;SAVE
	PUSHJ	P,SETCLK	;SETUP CLOCKS, PI, APR
>
IFN FTKS10,<
	PUSHJ	P,UBAPIS	;MAKE SURE UBA'S HAVE A PIA
>
IFN FTKL10,<
	PUSHJ	P,RNXSAK##	;INSURE ALL RP20 DX20'S ARE RUNNING
>
	HLRZ	U,SYSUNI##	;FIRST UNIT IN THE SYSTEM
	MOVN	J,TICSEC	;AVOID BRKLOK
	MOVEM	J,.CPOK		;CALLS BY THE BOOT CPU
IFN FTMP,<
IFG	M.CPU-1,<
	CPLOCK	(SCD)	;CROCK TO INSURE MC AVAILABLE
>
	SKIPL	MCREQ##	; BEFORE CALL TO ATTCPD
IFG	M.CPU-1,<
	JRST	[CPUNLK (SCD)
                 JRST .-2]
>
IFLE	M.CPU-1,<
	  JRST	.-1
>
SPRIN7:	HRRZ	J,UNIKON##(U)	;KONTROLLER DATA BLOCK
	MOVE	T1,KONCAM##(J)	;CPU THIS CONTROLLER LIVES ON
	TDNN	T1,.CPBIT	;CURRENT CPU?
	JRST	SPRIN8		;NO, ONWARD AND UPWARD
	PUSHJ	P,ATTCPD##	;YES, ATTACH THE UNIT
	  JFCL			;DON'T CARE
	  JFCL			;THIS ONE EITHER
SPRIN8:	HLRZ	U,UNISYS##(U)	;NEXT UNIT IN THE SYSTEM
	JUMPN	U,SPRIN7	;GO IF NOT THE LAST
IFG	M.CPU-1,<
	CPUNLK	(SCD)
>
>
	SETZB	S,P1		;ALWAYS CALL INI ROUTINE ONCE
	HLRZ	P3,HNGLST	;LOOK ONLY AT REAL HARDWARE
SPRIN9:	MOVE	F,P3		;SETUP F FOR INI CODE
	MOVE	P3,DEVSER(P3)	;ADDRESS OF DEVICE DISPATCH VECTOR
IFN FTMP,<
	LDB	T1,DEYCPF	;CPU OWNING THE DEVICE
	CAMN	T1,.CPCPN	;CURRENT CPU?
>;END IFN FTMP
	CAIN	P1,(P3)		;YES, ALREADY CALLED INI ROUTINE?
	JRST	SPRI10		;YES, SKIP ON
	MOVSI	T1,DVMTA	;SPECIAL CHECK FOR MAGTAPE
	TDNN	T1,DEVMOD(F)	;ALWAYS DO INITIALIZATION FOR MAGTAPE
	SKIPN	.CPAID		; (SEE TPMINI) OR IF OTHER DEVICES
	CAIA			; HAVEN'T BEEN INITIALIZED YET
	JRST	SPRI10		; OTHERWISE SKIP ON
	PUSHJ	P,DINI(P3)	;NO, CALL INI ROUTINE
	  HRRZ	P1,P3		;NEEDN'T CALL IT AGAIN
SPRI10:	HLRZS	P3		;NEXT DDB
	JUMPN	P3,SPRIN9	;LOOP IF THERE IS ONE
IFN FTAUTC&FTMP,<
	PUSHJ	P,T1CINI##	;MARK PAGTAB SO DX10 DATA BASE WILL NEVER BE UNCACHED
>
IFN FTKL10,<
	PUSHJ	P,SETCSH##	;SET CACHE STRATEGY AS ESTABLISHED BY KLI
	PUSHJ	P,STAPPC##	;PATCH TO JFCL TO INHIBIT STARTING PRIMARY PROTOCOL
>; END IFN FTKL10
IFN FTKS10,<
	PUSHJ	P,ENAKAL##	;ENABLE KEEP ALIVE
>
	SETOM	.CPAID		;INDICATE DEVICES HAVE ALREADY BEEN INITIALIZED
	MOVSI	T1,(CR.SPD)	;SUPPENDED BIT
	TDNE	T1,.CPRUN	;RESTARTING AFTER SYSTEM SLEEP?
	PUSHJ	P,DSKRCL	;YES, GENERATE A FREE INTERRUPT FROM ALL DSKS
				; SO FILIO WILL REREAD THE HOME BLOCK AND
				; VERIFY THAT PACKS WEREN'T MOVED WHILE ASLEEP
	MOVSI	T1,(CR.SPD)	;SUPPENDED BIT
IFN FTNET,<
	TDNE	T1,.CPRUN	;IF RESTARTING,
	PUSHJ	P,FEKCPW##	; TELL THE FEK'S
>
	ANDCAM	T1,.CPRUN	;CLEAR IT SINCE RESUMING
IFG <CPUN-1>,<
	SKIPE	J,.CPJOB	;IF A RESTART AND A JOB WAS RUNNING,
	PUSHJ	P,CPUZAP##	; ZAP IT AND INFORM THE USER
	SETZM	.CPJOB		;NO PREVIOUS JOB
	SETZM	.CPDRQ		;NO MORE DISKS TO RESCUE
>
	CLRPGT	(0)
	SJSP	U,NULJB1	;GO START NULL JOB

SYSINH::MOVEI	T1,DF.BPT	;GET MASK OF ALL CPU BREAKPOINT ENABLE BITS
	MOVEI	T2,JS.BPT	;GET THE "SET EDDT BREAKPOINT" ON BIT
	TDNE	T1,DEBUGF	;ANY CPUS SET TO BREAKPOINT?
	IORM	T2,JBTSTS	;YES--ALLOW ^D TO DO IT'S THING
	PUSHJ	P,CSHINI##	;INIT MONITOR DISK CACHE
				;(WE HAVE TO BE OUT OF LOW SEG, AS CSHINI
				;ALLOCATES FRECOR AND BLOWS US AWAY)
IFN FTMP,<
	MOVEI	T1,1
	MOVEM	T1,ONCCOM	;TELL ALL CPUS TO START
>
	SJSP	U,NULJB1	;START THE NULL JOB (J ZERO, U NON-ZERO)
;ROUTINE CALLED ON EACH CPU TO INIT IPA DEVICES

SPRIPX::MOVSI	T1,(CR.IIP)	;IPA INITIALIZE PENDING
	ANDCAM	T1,.CPRUN	;NO LONGER PENDING, THIS CPU IS RUNNING
IFN FTSCA,<
IFN M.SCA,<
	CONO	PI,PI.ON+DSKPIN	;TURN ON THE PI SYSTEM AND THE DISK PI'S
	PUSHJ	P,PPDINX	;INITIALIZE THE PHYSICAL PORT DRIVER
>; END IFN M.SCA
>; END IFN FTSCA

IFN FTENET,<
	PUSHJ	P,KNIINI##	;INITIALIZE THE KLNI PORT DRIVER
>; END IFN FTENET

	POPJ	P,		;DONE
SETCLK:
IFN FTEMRT,<
	PUSHJ	P,ACCMON##	;START UP ACCOUNTING METERS
	PUSHJ	P,CLREMB##	;CLEAR OUT E AND MBOX ACCOUNTING METERS
>;END IFN FTEMRT
	PUSHJ	P,SETIME	;TO INITILIZE 'GGTIME' CLOCK (IN SYSINI)
IFN FTKL10,<
	CONI	MTR,T1		;PRESERVE TIME BASE INFO
	CONO	MTR,APRCHN(T1)	;SETUP INTERVAL TIMER PI
IFG <CPUN-1>,<
	MOVE	T1,BOOTCP	;BOOT CPU
	MOVSI	T2,40000	;SUPPENDED BIT
	TDNN	T2,.CPRUN	;THERE MIGHT NOT BE A BOOT CPU AFTER A REBOOT
	CAMN	T1,.CPCPN	;ALSO COULD BE THE BOOT - WARM RESTART
	JRST	SETCL1		; SO DON'T WAIT ON IT
	LSH	T1,.CPSOF	;OFFSET TO ITS CDB
	SKIPE	T2,.C0TMF(T1)	;WAIT UNTIL CLOCK FLAG CLEARS, ZERO T2
	JRST	.-1
	SKIPN	.C0TMF(T1)	;TIME FROM SET UNTIL SET
	JRST	.-1
	SKIPE	.C0TMF(T1)
	AOJA	T2,.-1
	SKIPN	.C0TMF(T1)
	AOJA	T2,.-1
	MOVE	T3,.CPCPN	;OUR CPU NUMBER
	SUB	T3,BOOTCP	; MINUS THE BOOT CPU NUMBER
	SKIPG	T3		;IF NEGATIVE, (NEVER EQUALS ZERO)
	ADDI	T3,CPUN		; MODULO THE NUMBER OF CPU'S
	IMULI	T2,(T3)
	IDIVI	T2,CPUN		;FRACTION OF A TIC TO WAIT
	SOJG	T2,.		; BEFORE STARTING THE CLOCK
>
SETCL1:	MOVEI	T1,^D1666	;ASSUME 60HZ
	MOVE	T2,STATES
	TLNE	T2,(ST.CYC)	;IS OUR ASSUMPTION CORRECT?
	MOVEI	T1,^D2000	;NO, 2000 IS INTERVAL
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT(T1)	;START TIMER GOING
>
	CONO	APR,APRNUL
	CONO	PI,PI.CPI!PI.TNP!PI.ON!II.ACO!IFE FTKS10,<PI.EPE>
				;TURN ON ALL PI, ENABLE MEMORY PARITY
	POPJ	P,
;SUBROUTINE TO STORE INFORMATION IN THE CPU STATUS BLOCK

CPUSTS::APRID	.CPAPD		;(0) APRID
	CONI	APR,.CPACN	;(1) CONI APR,
	CONI	PI,.CPPIC	;(2) CONI PI,
	DATAI	PAG,.CPPGD	;(3) DATAI PAG,
	CONI	PAG,.CPPGC	;(4) CONI PAG,
	MOVE	T1,[.USMUO,,.CPUP0] ;(5) UPT LOCS 424-427
	BLT	T1,.CPUP0+3
IFN M.KL10,<
	RDERA	.CPERA		;(11) RDERA
	CONI	RH2,.CPRHC	;(12) CONI RH20, FOR ALL 8 RH'S
	CONI	RH21,.CPRHC+1
	CONI	RH22,.CPRHC+2
	CONI	RH23,.CPRHC+3
	CONI	RH24,.CPRHC+4
	CONI	RH25,.CPRHC+5
	CONI	RH26,.CPRHC+6
	CONI	RH27,.CPRHC+7
	CONI	DTE0,.CPDTC	;(22) CONI DTEn
	CONI	DTE1,.CPDTC+1
	CONI	DTE2,.CPDTC+2
	CONI	DTE3,.CPDTC+3
	HRLZ	T1,.CPEPT	;(26) EPT LOCS 
	HRRI	T1,.CPEP0
	BLT	T1,.CPEP0+37
	MOVE	T1,.CPEPT	;(66) EPT LOCS 140-147
	HRLI	T1,140(T1)
	HRRI	T1,.CPEP1
	BLT	T1,.CPEP1+37
>
	MOVE	T1,[.UPMP+500,,.CPUP1] ;(126) UPT LOCS 500-503
	BLT	T1,.CPUP1+3
IFN M.KL10,<
	EXECAC	(6)		;(132) AC BLOCK 6, REGS 0-3 AND 12
	MOVEM	0,.CP6
	MOVEM	1,.CP6+1
	MOVEM	2,.CP6+2
	MOVEM	3,.CP6+3
	MOVEM	12,.CP6+4
>
IFN M.KS10,<
	RDCSTM	.CP6
	RDPUR	.CP6+1
	RDCSB	.CP6+2
	RDSPB	.CP6+3
>
	EXECAC	(7)		;(136) AC BLOCK 7, REGS 0-2
	MOVEM	0,.CP7
	MOVEM	1,.CP7+1
	MOVEM	2,.CP7+2
	DATAO	PAG,.CPPGD	;RESTORE ORIGIONAL AC BLOCK
IFN M.KL10,<
	PUSHJ	P,REDSBD	;READ SBDIAG INFO
>
REPEAT 0,<
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;MULTIPLY BY 2
	MOVE	T2,.CPSLF	;ADDRESS OF THIS CPU'S CDB
	ADDI	T2,.CPAPD-.CPCDB ;OFFSET OF CPU STATUS BLOCK IN CDB
	MOVEM	T2,110(T1)	;STORE ADDRESS OF CPU STATUS BLOCK FOR F/S
	MAP	T2,(T2)		;ABSOLUTE ADDRESS OF CPU STATUS BLOCK
	MOVEM	T2,111(T1)	;STORE IT FOR FIELD SERVICE
>;END REPEAT 0
	MOVEI	T1,SR.CSB	;SET FLAG TO INDICATE CPU
	IORM	T1,.CPSBR	;STATUS BLOCK READ ON THIS CPU
	POPJ	P,
IFN M.KL10,<
;ROUTINE TO CLEAR SBUS ERRORS IN EACH MEMORY CONTROLLER.  RETURNS
;CPOPJ ALWAYS AND PRESERVES ALL AC'S.

CLRSBD::PUSHJ	P,SAVE3		;SAVE P1-P3
	MOVSI	P1,-.SBNMC	;MAKE AOBJN POINTER TO ALL MEM CONTROLLERS
	MOVSI	P2,SB.CLR	;BIT TO CLEAR ALL ERRORS
CLRSB1:	DPB	P1,[POINT 5,P2,4] ;STORE MEMORY CONTROLLER NUMBER
	SBDIAG	P2		;CLEAR THE ERROR BITS
	AOBJN	P1,CLRSB1	;LOOP FOR ALL CONTROLLERS
	POPJ	P,		;RETURN


;ROUTINES TO PERFORM SBDIAG FUNCTIONS 0 AND 1 FOR EACH MEMORY CONTROLLER.
;CALL REDSBD TO JUST READ THE DATA.  CALL REDSBC TO READ THE DATA AND
;CLEAR THE ERRORS.  THE FORMAT OF THE SBDIAG STATUS BLOCK IS AS FOLLOWS:
;	WORD 0: -NUMBER OF DATA BLOCKS,,OFFSET TO FIRST BLOCK
;EACH DATA BLOCK HAS THE FOLLOWING FORMAT:
;	WORD 0: -NUMBER OF WORDS FOLLOWING,,CONTROLLER NUMBER
;	WORD 1: SBDIAG FUNCTION 0 FROM-MEMORY WORD
;	WORD 2: SBDIAG FUNCTION 1 FROM-MEMORY WORD
;DESTROYS T1, PRESERVES ALL OTHERS

REDSBD::TDZA	T1,T1		;CLEAR T1 AND SKIP
REDSBC::MOVSI	T1,SB.CLR	;BIT TO CLEAR ERRORS
	PUSHJ	P,SAVE4		;SAVE P1-P4
	SETZM	.CPSBD		;CLEAR FIRST WORD OF BLOCK FOR COUNT
	MOVSI	P1,-.SBNMC	;AOBJN POINTER TO MEMORY CONTROLLERS
	MOVEI	P2,.CPSBD+1	;START FIRST BLOCK HERE
	HRLI	P2,-.SBFNC	;-FUNCTIONS TO LH
REDSB1:	MOVEI	P3,0		;SET TO BUILD TO-MEMORY WORD
	DPB	P1,[POINT 5,P3,4] ;STORE MEMORY CONTROLLER
	SBDIAG	P3		;DO FUNCTION 0
	PUSH	P,P4		;SAVE FUNCTION 0 FROM-MEMORY WORD
	JUMPE	T1,REDSB2	;AVOID 2ND SBDIAG IF NOT CLEARING CONTROLLER
	IOR	P3,T1		;SET SB.CLR
	SBDIAG	P3		;DO FUNCTION 0 TO CLEAR CONTROLLER
REDSB2:	TRO	P3,1		;MAKE IT FUNCTION 1
	SBDIAG	P3		;DO FUNCTION 1
	POP	P,P3		;RESTORE FUNCTION 0 FROM-MEMORY WORD
	SKIPN	P3		;ANYTHING THERE?
	JUMPE	P4,REDSB3	;NO, NO MEMORY CONTROLLER IF BOTH ZERO
	MOVEM	P3,1(P2)	;SAVE FUNCTION 0 WORD IN THE BLOCK
	MOVEM	P4,2(P2)	;  ALONG WITH FUNCTION 1 WORD
	HRRZM	P1,0(P2)	;SAVE CONTROLLER NUMBER AS WORD 0
	HLLM	P2,0(P2)	;MAKE IT -WORDS,,CONTROLLER
	AOS	.CPSBD		;COUNT THIS CONTROLLER
	ADDI	P2,.SBFNC+1	;INCREMENT TO NEXT BLOCK
REDSB3:	AOBJN	P1,REDSB1	;LOOP FOR NEXT CONTROLLER
	MOVN	P1,.CPSBD	;GET NUMBER OF BLOCKS WE STORED
	JUMPE	P1,CPOPJ	;LEAVE IT ZERO IF NONE
	HRLI	P1,1		;MAKE SWAPPED HEADER WORD
	MOVSM	P1,.CPSBD	;SAVE IN WORD 0
	POPJ	P,		;RETURN
>;END IFN M.KL10
;SUBROUTINE TO READ AND STORE DEVICE STATUS

DVCSTS::MOVSI	T1,-DVSLEN	;LENGTH OF DEVICE STATUS TABLE
	XCT	DVSXCT(T1)	;DO THE I/O INSTRUCTION
	AOBJN	T1,.-1		;LOOP FOR ALL OF THEM
IFN M.KL10,<
	HRLI	T1,-10		;NOW DO THE EIGHT RH20'S
DVCST1:	LDB	T2,[POINT 7,DVSXCT(T1),9] ;GET THE DEVICE CODE
	MOVE	T3,[CONI RH2,T3] ;LOAD CONI INSTRUCTION
	DPB	T2,[POINT 7,T3,9] ;MAKE IT SPECIFIC TO THIS RH20
	XCT	T3		;DO THE CONI
	JUMPL	T3,DVCST2	;JUMP IF NOT AN RH20 (CI/NI)
	MOVE	T3,[DATAO RH2,RH2IVI] ;LOAD DATAO INSTRUCTION
	DPB	T2,[POINT 7,T3,9] ;MAKE IT SPECIFIC TO THIS RH20
	XCT	T3		;DO THE DATAO TO SELECT IVI REGISTER
	XCT	DVSXCT(T1)	;NOW DO THE DATAI TO READ THE IVI
DVCST2:	AOBJN	T1,DVCST1	;LOOP FOR ALL EIGHT RH20'S
>; END IFN M.KL10
IFN M.KS10,<
	PUSH	P,.USPFP
	PUSH	P,.USPFP+1	;SAVE PREVIOUS PC
	PUSH	P,.USPFW
	MOVSI	T1,-KSRTBL	;POINTER TO DEVICE ADDRESS TABLE
	MOVEI	T2,DVCST2	;TRAP ADDRESS FOR NX DEVICES
	EXCH	T2,.USPFN+1	;SET IT AND SAVE CURRENT ONE
DVCST1:	RDIO	T4,@KSRTAB(T1)	;READ SOME REGISTER
	MOVEM	T4,.CPUB1(T1)	;SAVE IT IN RIGHT SLOT
				;*** HERE ON NX DEVICE TRAP
DVCST2:	AOBJN	T1,DVCST1	;DO NEXT
	EXCH	T2,.USPFN+1	;RESTORE TRAP ADDRESS
	POP	P,.USPFW
	POP	P,.USPFP+1
	POP	P,.USPFP
>;END IFN M.KS10
	MOVEI	T1,SR.DSB	;SET FLAG TO INDICATE
	IORM	T1,.CPSBR	;DEVICE STATUS BLOCK READ
	POPJ	P,

IFN M.KL10,<
RH2IVI:	.DOIVI			;DATAO TO SELECT IVI
>
;TABLE OF INSTRUCTIONS TO EXECUTE TO FILL IN CDB ENTRIES BEGINNING
;AT CDB VARIABLE .CPDVS.  THE ORDER OF THIS TABLE MUST MATCH THE
;ORDERING OF ENTRIES IN THE CDB AT CDB VARIABLE .CPDVS.

;FOR THE KS10 THIS TABLE IS USED A LITTLE DIFFERENTLY.  THE FIRST
;PART OF THE TABLE CONTAINS I/O INSTRUCTIONS JUST LIKE FOR THE
;KL10.  THE SECOND PART OF THE TABLE CONTAINS THE DEVICE REGISTER
;ADDRESS FOR UNIBUS DEVICES.

DVSXCT::
IFN M.KL10,<
	CONI	TIM,.CPTMR		;INTERVAL TIMER STATUS
	CONI	MTR,.CPMTR		;METER STATUS
	CONI	TTY,.CPTTY
	CONI	PTR,.CPPRA
	CONI	PTP,.CPPPA
	CONI	DLS,.CPDLS
	CONI	DAC,.CPDAC
	CONI	DAS,.CPDAS
	CONI	CR,.CPCRA
	CONI	LPT,.CPLPT
	CONI	PLT,.CPPLA
	CONI	TMS,.CPTMS
	CONI	TMC,.CPTMC
	CONI	DX10,.CPDX1
	CONI	DSK,.CPDSK
	CONI	FHD2,.CPFH2
	CONI	FSD,.CPFSD
	CONI	FSD2,.CPFS2
	CONI	FSD3,.CPFS3
	CONI	DPC,.CPDPC
	CONI	DPC2,.CPDP2
	CONI	DPC3,.CPDP3
	CONI	DPC4,.CPDP4
	CONI	DBS,.CP2DS		;2ND TD10
	CONI	DBC,.CP2DC
	CONI	DLC,.CPDLC
	CONI	DLB,.CPDLB
	CONI	DLC2,.CPDC2
	CONI	DLB2,.CPDB2
	CONI	CDP,.CPCDP
	CONI	CDR2,.CPCRB		;CDR1
	CONI	LPT2,.CPLPB		;LPT1
	CONI	LPT3,.CPLPC		;LPT2
	CONI	PLT2,.CPPLB		;PLT1
	DATAI	APR,.CPDAK		;ADDRESS BREAK CONDITIONS
	DATAI	DSK,.CPDDK
	DATAI	FHD2,.CPDH2
	DATAI	FSD,.CPDFS
	DATAI	FSD2,.CPDS2
	DATAI	FSD3,.CPDS3
	DATAI	DPC,.CPDDP
	DATAI	DPC2,.CPDD2
	DATAI	DPC3,.CPDD3
	DATAI	DPC4,.CPDD4
	DATAI	DLC,.CPDDC
	DATAI	DLB,.CPDDB
	DATAI	DLC2,.CPD2C
	DATAI	DLB2,.CPD2B
DVSLEN==.-DVSXCT		;LENGTH OF (NON-RH20) I/O INSTRUCTION TABLE
	DATAI	RH2,.CPIVI
	DATAI	RH21,.CPIVI+1
	DATAI	RH22,.CPIVI+2
	DATAI	RH23,.CPIVI+3
	DATAI	RH24,.CPIVI+4
	DATAI	RH25,.CPIVI+5
	DATAI	RH26,.CPIVI+6
	DATAI	RH27,.CPIVI+7
>;END IFN M.KL10
IFN M.KS10,<
	RDINT	.CPTMR
	RDTIME	.CPTMB
DVSLEN==.-DVSXCT		;LENGTH OF I/O INSTRUCTION TABLE
	RDTIME	.CPTMB+1	;THIS IS A DUMMY AS RDTIME RETURNS 2 WORDS
KSRTAB:	XWD	1,UNBSTW	;UBA1 STATUS REGISTER
	XWD	3,UNBSTW	;UBA3 STATUS REGISTER
	RH11CA			;RPCS1
	RH11CA+10		;RPCS2
	RH21CA			;MTCS1
	RH21CA+10		;MTCS2
	LP11CA			;LPT CSRA
	LP11CA+2		;LPT CSRB
	CD11BA			;CDR CDST
	PR11CA			;PTR CSR
	PP11CA			;PTP CSR
	RX21BA			;RXA CSR
KSRTBL==.-KSRTAB		;LENGTH OF REGISTER TABLE
>; END IFN M.KS10
IF1,<IFN <.-DVSXCT>-.CPDVL,<PRINTX ?DVSXCT TABLE IS INCORRECT>>
LENDVS==:<.-DVSXCT-1>B26	;LENGTH OF TABLE OF INSTRUCTIONS FOR GETTAB
;HERE FROM THE DIAG. UUO IN FILIO (FUNCTION 10) TO READ THE CPU STATUS
;BLOCK.
DIACSB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	MOVEI	T1,.ERCSB	;DAEMON ERROR CODE
	JRST	DIADS1		;JOIN COMMON CODE


;HERE FROM THE DIAG. UUO IN FILIO (FUNCTION 11) TO READ THE DEVICE
;STATUS BLOCK.
DIADSB::PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
	MOVEI	T1,.ERDSB	;DAEMON ERROR CODE
DIADS1:	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEEIM##	;PLACE IN DAEMON ERROR QUEUE
	JRST	CPOPJ1		;GIVE SUCCESS RETURN FROM UUO
;ROUTINE TO TYPE RELEVANT PARTS OF THE CPU STATUS BLOCK ON THE CTY
;WHEN A CRASH OCCURS.

TYPCSB::PUSHJ	P,INLMES##
	ASCIZ/

CPU Status Block
/
	PUSHJ	P,INLMES##
	ASCIZ/
APRID = /
	MOVE	T1,.CPAPD	;GET APRID
	PUSHJ	P,HWDPNT##	;TYPE IT
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
ERA = /
	SKIPN	T1,.CPAER
	MOVE	T1,.CPERA	;GET ERA
	PUSHJ	P,HWDPNT##	;TYPE IT
>;END IFN M.KL10
	PUSHJ	P,INLMES##
	ASCIZ/
CONI APR, = /
	MOVE	T1,.CPACN	;GET CONI APR
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PI, = /
	SKIPN	T1,.CPCPI
	MOVE	T1,.CPPIC	;GET CONI PI
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
CONI PAG, = /
	MOVE 	T1,.CPPGC	;GET CONI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
DATAI PAG, = /
	MOVE	T1,.CPPGD	;GET DATAI PAG
	PUSHJ	P,HWDPNT##	;TYPE IT
IFN M.KL10,<
	PUSHJ	P,INLMES##
	ASCIZ/
AR ARX Data Word = /
	MOVE	T1,.CP7		;GET AC BLOCK 7 LOC 0
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/
IO Page Fail Word = /
	MOVE 	T1,.CP7+2	;GET AC BLOCK 7 LOC 2
	PUSHJ	P,HWDPNT##	;TYPE IT
	PUSHJ	P,INLMES##
	ASCIZ/

SBUS Diags:

CNTRLR FNC 0          FNC 1
/
	PUSHJ	P,TYPSBD	;TYPE SBDIAG INFORMATION
>;END IFN M.KL10
	PJRST	CRLF##		;END WITH CRLF AND RETURN
;ROUTINE TO TYPE THE SBDIAG FUNCTIONS AND VALUES ON THE CTY WHEN
;A CRASH OCCURS.

IFN M.KL10,<
TYPSBD::PUSH	P,P1		;SAVE P1
	PUSH	P,P2		;  AND P2
	MOVE	P1,.CPSBD	;GET -# BLOCKS,, OFFSET TO FIRST
	HRRZI	P2,.CPSBD(P1)	;POINT AT FIRST BLOCK
TYPSB1:	HLL	P2,0(P2)	;MAKE P2 BE AOBJN POINTER TO THIS BLOCK
	HRRZ	T1,0(P2)	;GET CONTROLLER LOGICAL ADDRESS
	PUSHJ	P,OCTPNT##	;PRINT IT
	HRRI	P2,1(P2)	;ADVANCE TO FIRST OF FUNCTION WORDS
TYPSB2:	PUSHJ	P,PRSPC##	;SEPARATE FIELDS WITH A SPACE
	MOVE	T1,0(P2)	;GET NEXT FUNCTION WORD
	PUSHJ	P,HWDPNT##	;TYPE IT
	AOBJN	P2,TYPSB2	;LOOP FOR ALL WORDS IN THIS BLOCK
	PUSHJ	P,CRLF##	;TYPE CRLF AT END OF LINE
	AOBJN	P1,TYPSB1	;LOOP FOR ALL BLOCKS
	POP	P,P2		;RESTORE P2
	POP	P,P1		;  AND P1
	POPJ	P,		;RETURN
>;END IFN M.KL10



;ROUTINE TO READ THE CPU AND DEVICE STATUS BLOCKS.
;CALL:	PUSHJ	P,RCDSTB
;	RETURN

RCDSTB::PUSHJ	P,CPUSTS	;READ CPU STATUS BLOCK
	PUSHJ	P,DVCSTS	;READ DEVICE STATUS BLOCK
RCDSTD::MOVEI	T1,.ERCSB	;CPU STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY FOR DAEMON
	MOVEI	T1,.ERDSB	;DEVICE STATUS BLOCK ERROR CODE
	HRL	T1,.CPSLF	;CDB ADDRESS TO LH
	PUSHJ	P,DAEDIE##	;STORE ENTRY
	POPJ	P,		;RETURN
SUBTTL STOP PROCEDURE WHEN SHUTTING DOWN SYSTEM
;TRANSFER HERE ON 404, 405, 406, OR 407 START OR LOCATION 30 BEING
;SET NON-ZERO.
;PROCEDURE TO SAVE CRASHED MONITOR ON DISK FOR LATER DEBUGGING UNDER
;TIMESHARING.  OPERATOR SHOULD:
;	1. TRY TO FORCE THE SYSTEM TO TAKE A DUMP BY CAUSING LOCATION
;	   30 TO BE SET NON-ZERO.  THIS CAN BE DONE FROM THE KEYS ON
;	   A KI10 OR THROUGH COMMANDS TO THE FRONT-END ON KL10 OR KS10
;	   SYSTEMS.
;	2. IF THIS DOESN'T WORK, TRY STARTING THE MACHINE AT 406 OR
;	   407 (FOR SINGLE CPU SYSTEMS).  THIS SHOULD GET US HERE.
;	3. IF ALL ELSE FAILS, LOAD BOOT WITH READ-IN OR VIA THE
;	   FRONT-END.  THIS HAS THE DISADVANTAGE THAT SOME MACHINE
;	   STATE, THE AC SETS, ETC. ARE LOST.

;HERE ON A 405 START TO SAVE THE MACHINE STATE AND JUMP INTO THE AC'S
STPCPU:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.DIE	;SET BIT TO FORCE CPNSER TO LOOP
	IORB	P1,.CPSBR	; IN THE AC'S UNTIL EXPLICITLY RESTARTED
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 404 START TO SET 30 TO -1 TO FORCE ALL OTHER CPU'S INTO
;THEIR AC'S
STPALL:	SETOM	CRSHWD		;FORCE ALL OTHER CPU'S INTO THE AC'S

;HERE ON A 406 START TO GET TO MONBTS ON THIS CPU REGARDLESS OF WHO
;THE BOOT CPU IS.
STPLDB:	DMOVEM	P1,RBTSVA	;SAVE P1,P2 IN A VERY TEMPORARY PLACE
	JSP	P1,PAGENB	;MAKE SURE PAGING IS ON
	MOVEI	P1,SR.LBH	;SET BIT TO GET TO MONBTS ON THIS CPU
	IORB	P1,.CPSBR	; REGARDLESS OF WHO THE BOOT CPU IS
	JRST	SYSTO1		;JOIN COMMON CODE

;HERE ON A 407 START OR 30 NON-ZERO AT APR INTERRUPT LEVEL
SYSTOP::DMOVEM	P1,RBTSVA	;SAVE P1, P2 IN A VERY TEMPORARY AREA
	JSP	P1,PAGENB	;MAKE SURE PAGING IS TURNED ON
	MOVE	P1,.CPSBR	;GET STATUS BITS
SYSTO1:	TRNE	P1,SR.ACL	;THIS CPU LOOPING IN THE AC'S?
	JRST	[DMOVE	P1,RBTSVA ;YES, AC'S SAVED BY AC LOOP SETUP
		 JRST SYSTO2]	;SO DON'T SAVE THEM AGAIN
	DMOVE	P1,RBTSVA	;RESTORE P1 AND P2
	JSR	.CPSVA		;SAVE ALL AC SETS

SYSTO2:	MOVE	P,.CPEPD	;SETUP P TO ERRPDL
	MOVEI	P1,SR.STS	;BIT SET IF MACHINE STATE ALREADY SAVED
	TDNN	P1,.CPSBR	;ALREADY SAVE MACHINE STATE?
	SKIPGE	BOOTCP		;NO, MAP SETUP YET?
	CAIA			;NO, CAN'T READ DATA BLOCKS
	PUSHJ	P,RCDSTB	;READ CPU AND DEVICE STATUS BLOCKS
	IORM	P1,.CPSBR	;SET THE BIT FOR THE NEXT TIME


				;FALL INTO REBOOT
;HERE ON ANY CPU FROM DIE OR FALL INTO FROM ABOVE TO RELOAD THE MONITOR.
;IN MULTIPROCESSOR SYSTEMS, ALL BUT THE BOOT CPU ARE DISPATCHED TO
;CP1CRS IN CPNSER.  IT IS THE CALLERS RESPONSIBILITY TO SAVE ALL AC
;SETS (WITH .CPSVA) BEFORE GETTING HERE.

REBOOT::EXECAC
	MOVE	P1,BOOTCP	;SAVE CURRENT VALUE OF BOOTCP
	SETZM	BOOTCP		;CAUSE SYSTR1 TO NOT CHANGE SERIAL, BOOTCP
	JSP	T4,SYSTR1	;TURN ON PAGING FOR THIS CPU
	  JFCL			;IGNORE RETURN
	MOVEM	P1,BOOTCP	;RESTORE BOOTCP
	MOVEM	P3,@.CPSPT	;RESTORE FROM VALUE SYSTR1 SAVE FOR US
IFN M.KL10,<
	DATAO	DLB,[0]
	DATAO	DLB2,[0]
>
IFN M.KL10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	SWPUA			;SWEEP CACHE
	CONSZ	APR,LP.CSB	;WAIT UNTIL DONE
	JRST	.-1		; ..
	CONI	PAG,T1		;GET PAGING STATE
	TRZ	T1,LG.CSL!LG.CSW ;TURN OFF, LOOK AND LOAD
	CONO	PAG,(T1)	;MAINTAIN PAGING BUT WITHOUT CACHE
	JSP	T4,ZAPICH	;FIX UP INTERNAL CHANNELS
>
IFN M.KS10,<
	CONO	PI,PI.OFF	;TURN OFF PI
	WRUBR	NULDOP		;SWEEP CACHE
>
	CONO	APR,AP0RST	;RESET SYSTEM
	CONO	PI,011577	;WIPEOUT PI-SYSTEM

IFN FTMP,<
IFG <CPUN-1>,<
	MOVEI	T1,SR.LBH	;DO WE WANT TO GET TO MONBTS ON THIS
	TDNE	T1,.CPSBR	;  CPU REGARDLESS OF WHO THE BOOT CPU IS?
	JRST	REBOO1		;YES, SKIP THE REST OF THE CHECKS
	SKIPL	BOOTCP		;MAP SETUP YET?
	SKPCPU(1)		;YES, ON ANY BUT THE BOOT CPU?
	CAIA			;NO, LOAD BOOTS AND RELOAD
	PJRST	CP1CRS##	;GO TO CPNSER AND LOOP IN THE AC'S
REBOO1:>>

;CALL TO METINI REMOVED SO METER POINTS WILL BE PRESERVED IN
;THE CRASH DUMP--THIS REQUIRES THAT NONE OF THE ROUTINES
;CALLED BELOW (E.G. GETZ) SHOULD CONTAIN METER POINTS.
	MOVE	P,.CPEPD	;SETUP P TO SPARE AREA
	MOVE	T1,[<PM.DCD>B2+PM.WRT+NUPMPP]
;*********
	MOVEM	T1,NLUPMP+.UMUPT

BNXMTS::PUSHJ	P,SUNXMT##	;SETUP NXMTAB PATCHED OUT IF SYSTEM HAS
				; BEEN STARTED (PATCHED TO JFCL AFTER START)
	MOVE	T1,LOCYER	;GET YEAR
	SUBI	T1,^D1970	;SUBTRACT BASE
	JUMPL	T1,RLDMON##	;DON'T STORE IF BAD
	LSH	T1,5		;SHIFT OVER
	IOR	T1,LOCDAY	;ADD IN DAY
	LSH	T1,4		;AND
	IOR	T1,LOCMON	;MONTH
	HRLZM	T1,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	MOVE	T2,TIME		;GET TIME IN JIFFIES
	IDIV	T2,TICSEC	;CONVERT TO SECONDS TO FIT
	ADDI	T2,RLDTIM
	HRRM	T2,CRSDTM	;SAVE FOR ONCE AFTER RELOAD
	ADD	T1,T2		;ADD DATE AND TIME TOGETHER
	HLRZ	T2,CRSWHY	;GET LEFT THREE CHARACTERS OF STOPCODE NAME
	ADD	T1,T2		;PLUS STOPCD NAME
	HRRZ	T2,STATES	;GET SCHED SETTING
	HRRM	T2,CRSSTS	;SAVE FOR RELOAD
	ADD	T1,T2		;AND ADD INTO CHECKSUM
	ADDI	T1,507601	;ADD IN THE MAGIC CONSTANT
	HRRZM	T1,CRSCHK	;SAVE CHECKSUM FOR ONCE AFTER
				; RELOAD SO IT CAN DEFEND AGAINST
				; JUNK OR NON-MONITOR PREDECESSORS.
	PJRST	RLDMON##	;GO RELOAD MONITOR
	SUBTTL	FATAL SYSTEM HALT

;THE STOPCODE MACRO DISPATCHES HERE FOR "HALT" TYPE STOPCODES.  ONLY
;ESSENTIAL HALT ACTIONS SHOULD BE TAKEN BEFORE EXECUTING THE HALT
;INSTRUCTION AT THE END OF THIS ROUTINE.

DOHALT::EXP	0,0		;XPCW HERE
	EXP	IC.UOU,.+1
	MOVEM	17,.CPCAC+17	;SAVE AC 17
	MOVEI	17,.CPCAC	;SET UP BLT
	BLT	17,.CPCAC+16	;SAVE ACS 0-16
IFN FTKL10,<JSP	T4,ZAPICH>	;ZAP INTERNAL CHANNELS


;HERE TO FORCE A RELOAD BY THE FRONT END
DOLOAD::
IFN FTKL10,<PUSHJ  P,LOAD10##>	;TELL MASTER-11 TO RELOAD US
IFN FTKS10,<
	MOVSI	T1,(KSRLD)	;RELOAD REQUEST BIT
	IORM	T1,RLWORD	;SET IT FOR THE 8080
	WRAPR	SP.SSF+SP.IFE	;BANG ON THE 8080'S BELL (POINTLESS TRADITION)
> ;END IFN FTKS10
	HALT	.		;TERMINATE THIS NONSENSE
SUBTTL	MUUO PROCESSING

	$HIGH
MUUO:	EXECAC			;EXEC ACS
	JRSTF	@[XWD XC.UOU,.+1];HAVE TO DO THIS BY HAND
	MOVE	T1,.USMUO	;GET THE MUUO PC FLAGS
	MOVE	R,.CPADR
	TLNN	T1,(XC.USR)	;WAS THE MUUO DONE IN USER MODE?
	JRST	UUOSY1##	;NO, DISPATCH TO EXEC MODE MUUO HANDLER
	JUMPE	R,MUUO1		;IS THERE A JOB DATA AREA FOR THE JOB DOING THE UUO?
				;NO, MUST BE THE DOORBELL OR ERROR IN THE
				; NULL JOB
	AOS	.CPTUC		;ACCUMULATE THE NUMBER OF UUOS ON THIS CPU
	SKIPN	P,.USEPL	;USE EXTENDED PDL IF THERE IS ONE
	MOVE	P,[XWD MJOBPD##,.JDAT+JOBPDL##]
	MOVEI	F,0		;FLAG NO DDB IN CASE ILLEGAL UUO
	MOVE	J,.CPJOB	;JOB NUMBER OF CURRENT JOB
	JRST	UUOSY1##	;DISPATCH TO MUUO HANDLER
MUUO1:	HRLZ	T1,.USMUO
	IOR	T1,.USMUE
	CAME	T1,WAKINS##	;DOORBELL CALLI
	STOPCD	.+1,STOP,UNJ,	;NO, ILLEGAL NULL JOB UUO
MUUO1A:
IFN FTMP,<
	AOS	.CPNDB		;COUNT NUMBER OF DOORBELLS
	MOVE	P,.CPNPD
	JRSTF	@[IC.UOU+.+1]
	MOVE	T1,.CPQPC
	TDNN	T1,DOORBL
	JRST	MUUO1B
	ANDCAM	T1,DOORBL
	PUSHJ	P,DSKTIC##
	PUSHJ	P,TAPTIC##
IFN FTKL10,<
	PUSHJ	P,KNITIC##	;KLNI QUEUED I/O
>; END IFN FTKL10
IFN FTSCA,<
	PUSHJ	P,PPDTIC	;KLIPA QUEUED I/O
>; END IFN FTSCA
MUUO1B:	MOVE	T1,.CPSCC
	TDNN	T1,DOORBL
	JRST	[USERAC
	 	XJEN	.USMUO]
	ANDCAM	T1,DOORBL
>
	DMOVE	T1,.USMUO
	DMOVEM	T1,.CPPC
	JRST	CLKSPD##	;DISPATCH TO THE SCHEDULAR SINCE SOME
				; JOB IS POSSIBLY NOW RUNNABLE ON THIS CPU
UMPRET::			;HERE ON RETURN FROM MUUO PROCESSING
	POP	P,.USMUP	;RESTORE THE MUUO PC
	POP	P,.USMUO	;RESTORE FLAGS

IFN	FTHPQ,<
	SKIPGE	SCDRTF		;HPQ JOB WAKE UP AND IN CORE?
	  PUSHJ	P,USCHD1##	;YES
>
	USERAC			;RESET USER AC BLOCK
	XJEN	.USMUO

	$LIT			;FORCE LITERALS INTO THE HIGH SEGMENT
SUBTTL	APR INTERRUPTS
;DEFINE MACRO TO CALL KL OR KI OR KS CODE FOR EACH CPU
DEFINE KILS(N)<
IFN	M.KL10,<KL(N)>
IFN	M.KS10,<KS(N)>
>				;END KILS MACRO DEF

	$ABS
;HERE TO TRY TO CONTINUE THE SYSTEM AFTER A CLOCK ERROR STOP
IFN M.KL10,<
APRWRS::EXECAC			;GET CORRECT AC SET
	CONO	APR,200000	;CLEAR THE WORLD (ACTUALLY, RSX20F ALREADY DID)
	CONO	PI,CLRPIS
	CONO	PAG,0
	JSP	T4,SYSTR0	;SETUP PAGING, FIND OUT WHAT CPU WE ARE
	  JFCL			;DON'T CARE WHETHER BOOT OR NOT
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	MOVEI	P,WRSPTB-1(T1)	;SETUP A VERY SHORT STACK
	LSH	T1,1		;DOUBLE WORD PC
	LDB	T2,[POINT 18,WRSLOC(T1),35] ;CODE FOR RESTART
	DMOVE	T3,WRSLOC(T1)	;GET DOUBLE WORD PC
	DMOVEM	T3,@.CPKAF	;STORE IN KAF LOC

	CAIN	T2,.WRKAC	;IF KAF, REPORT AS SUCH
	JRST	KAFSTP
	CAIE	T2,.WRPTO	;IF PROTOCOL TIMED OUT, CAN'T RECOVER
	TLNN	T3,(XC.USR)	;PC IN USER MODE?
	STOPCD	.,CPU,WRF,WRSF	;++WARM RESTART FAILED
	SKIPN	J,.CPJOB	;NULL JOB RUNNING?
	JRST	SPRINI		;YES, JUST RESTART IT
	HRRZ	T1,JBTUPM(J)	;USER PROCESS TABLE
	HRRM	T1,@.CPSPT	;SETUP SPT

	TLO	T1,(LG.LUB)	;LOAD USER BASE REGISTER
	DATAO	PAG,T1		;ZAP, ADDRESSABLE
	MOVE	P,[MJOBPD##,,.JDAT+JOBPDL##] ;ESTABLISH A USER CONTEXT STACK
	PUSH	P,T3		;SAVE FLAGS

	PUSH	P,T4		;AND PC
IFN FTMP,<
	SETZM	.CPNBI		;SINCE ESSENTIALLY STARTING OVER, NO BROKEN INTERLOCKS
>;END IFN FTMP
	PUSHJ	P,SETCLK	;SETUP CLOCKS, APR, AND PI
	PUSHJ	P,ENTSPC##	;ENTER SECONDARY PROTOCOL, MAKE SURE 20F IN SAME STATE
	PUSHJ	P,STAPPC##	;NOW, START PRIMARY PROTOCAL
	STOPCD	.,JOB,WRJ,WRSF	;++WARM RESTART GOT JOB

;HERE TO PRINT WARM RESTART CODE

WRSF:	PUSHJ	P,INLMES##	;TELL WHAT'S BEING REPORTED
	ASCIZ	/code = /
	MOVE	T1,.CPCPN	;CURRENT CPU NUMBER
	LSH	T1,1		;TIMES 2
	LDB	T1,[POINT 18,WRSLOC(T1),35] ;WARM RESTART CODE
	PJRST	PRTDI8##	;REPORT IT

WRSPTB:	REPEAT	CPUN,<
	BLOCK	1		;VERY SHORT PDL TO USE DURING WARM RESTART
>
	LIT
>	;END IFN M.KL10

KAFSTP:	STOPCD	.,CPU,KAF,		;++KEEP ALIVE FAILURE

IFN M.KL10,<
IOPSTP:	STOPCD	.,CPU,IOP,		;++I/O PAGE FAILURE
>
	$HIGH
;DEFINE KL10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KL(N)<

;HERE ON OPERATOR CONTINUE AFTER POWER FAILURE, IO PAGE FAIL, WATCH DOG TIMER RUNOUT,
AP'N'CPF: CONO	APR,LP.CSF+LP.SBE+LP.NXM+LP.PAR+LP.IOF+LP.PWF
				;CLEAR AUTO RESTART ENABLE, ENABLE CLOCK INT., CLEAR
				; IO PAGE FAIL, CLEAR NON EX MEM

;HERE ON APR CHANNEL INTERRUPT
AP'N'INT: CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	CONSO	APR,LP.CSD
	JRST	AP'N'IN1
	CONO	APR,LP.CSF+LP.CSD+AP'N'CHN
	AOS	.CPCSN
	EXCH	T1,.CPSCS
	IORM	T1,DOORBL
	EXCH	T1,.CPSCS
	XJEN	AP'N'CHL

AP'N'IN1: CONSZ	APR,LP.NXM!LP.CDP!LP.ADP!LP.SBE!LP.PAR!LP.PWF!LP.IOF	;TIMER TIMEOUT,
				; MEM PAR, POWER FAIL, ADDRESS BREAK, IO PAGE FAIL?
	JRST	AP'N'UNS	;YES, GO PROCESS UNUSUAL INTERRUPTS
AP'N'IN2::
	DMOVEM	P,.C'N'SP	;SAVE AC P

AP'N'CLK:
IFE N,<	SKIPN	CLKDDT		;IS 21 NON-ZERO
	JRST	CLKDDR		;NO--PRECEED
	SETZM	CLKDDT		;CLEAR FLAG
	XCT	SYSDDT		;GO TO EDDT IF POSSIBLE
CLKDDR::>
	MOVE	P,AP'N'PDP	;SET TO PD LIST FOR THIS CPU
	PUSH	P,P4		;SAVE P4
	PUSHJ	P,APRSUB##	;GO PROCESS INTERRUPT
	MOVE	P4,(P)		;RESTORE P4
AP'N'EPF:
	DMOVE	P,.C'N'SP	;RESTORE P

AP'N'EXT: CONO	APR,AP'N'CHN  ;SET APR PI
	XJEN	AP'N'CHL


;HERE TO PROCESS UNUSUAL INTERRUPTS
AP'N'UNS: CONSZ	APR,LP.PWF	;POWER FAIL?
	JRST	AP'N'PWF	;YES, GO SETUP FOR AUTO-RESTART
	CONSZ	APR,LP.ADP!LP.CDP!LP.IOF ;ADDRESS OR CACHE DIRECTORY PARITY?
	JRST	AP'N'NHT	;GO DO DIAG INST'S AND HALT
	CONSZ	APR,LP.NXM	;NXM?
	JRST	AP'N'NXM	;YES, DO SPECIAL STUFF ON KL
	CONSZ	APR,LP.PAR	;NO--MB PARITY ERROR?
	JRST	AP'N'IN2	;YES, GO PROCESS
	CONSZ	APR,LP.SBE	;SBUS ERROR?
IFE M.MOS,<
	JRST	AP'N'NHT	;YES, JUST DO DIAG INST'S AND HALT
	JRST	AP'N'EXT	;DISMISS INTERRUPT
>
IFN M.MOS,<
	JRST	[CONO APR,LP.CSF+LP.SBE ;CLEAR SBUS ERROR EARLY IN CASE OF SINGLE BIT
		 MOVEM P,.CPSP	; ERROR IN ERROR ANALYSIS CODE
		 MOVE P,AP'N'PDP;SETUP A PUSH DOWN LIST
		 PUSHJ P,SBERR##;DO ERROR ANALYSIS AND RECORD ERRORS FOR THGA
		 MOVE P,.CPSP	;RESTORE P
		 JRST AP'N'EXT]	;EXIT INTERRUPT
>
;HERE ON NXM - CLEAR MB PARITY ERROR AND SBUS ERROR, SWEEP CACHE
AP'N'NXM:: CONO	APR,LP.CSF!LP.PAR!LP.SBE  ;CLEAR ALL BUT INTERESTING STUFF
	SWPUA			;SWEEP THE CACHE SINCE NXM LEAVES
				; BAD PARITY IN CACHE
	CONSZ	APR,LP.CSB	;WAIT FOR FINISH
	JRST	.-1
	JRST	AP'N'IN2	;GO DO A NXM THING

;HERE TO HALT ON APR ERROR CONDITION--DO SBDIAG AND RDERA FIRST
AP'N'NHT:MOVEM	P,.C'N'SP	;GET A VALID PDL
	MOVE	P,AP'N'PDP
	CONSZ	APR,LP.IOF	;IO PAGE FAILURE?
	JRST	IOPSTP		;YES, GO HALT
	RDERA	.C'N'AER	;READ ERA INTO CPU DATA BLOCK
	CONI	APR,.C'N'AEF	;SAVE CONI APR,
	SBDIAG	.C'N'SB0	;GET SBDIAG FUNCTIONS 1+2
	SBDIAG	.C'N'SB1	;
	SWPUA			;CACHE SWEEPS SO WE CAN SEE DATA
	CONSZ	APR,LP.CSB
	JRST	.-1
	CONSZ	APR,LP.SBE	;SBUS ERROR?
	STOPCD	.,CPU,SB'N,	;++SBUS ERROR ALONE
	CONSZ	APR,LP.CDP	;CACHE DIR. PAR.?
	STOPCD	.,CPU,CD'N,	;++CACHE DIRECTORY PARITY ERROR
				;MUST BE ADDR PARITY ERROR
	STOPCD	.,CPU,AD'N,	;++ADDR. PARITY ERROR

;KL10 INTERVAL TIMER INTERRUPT HANDLER
	$ABS

TM'N'INT::0
	0
	EXP	IC.UOU
	EXP	TM'N'IN0


;KL10 KEEP-ALIVE FAILURE TRAP HANDLER

AP'N'KAF:0
	0
	EXP	IC.UOU
	EXP	AP'N'KA0
AP'N'KA0:
	MOVEM	P,KF'N'SVP	;;SAVE P
	MOVEI	P,KF'N'PDL-1	;;SETUP NEW P
	JRST	KAFSTP		;;GIVE STOPCD
KF'N'PDL:BLOCK	1
KF'N'SVP:BLOCK	1		;;SAVE P HERE


	EPLLEN==:20
EP'N'PDL::
	BLOCK	EPLLEN		;;FIRST WORD IS "P" OF OVERFLOW
	$HIGH
TM'N'IN0:
	SKIPE	CRSHWD		;OPR DEPOSIT 30 NON-ZERO?
	JRST	SYSCRH		;YES, TAKE CRASH DUMP
IFN FTMP,<
IFG <CPUN-1>,<
	SKIPE	CPNDDT		;ANY CPU HIT A BREAKPOINT?
	JRST	CPNBPT##	;YES, WAIT FOR IT
>>
AP'N'BCK::
	DMOVEM	P,.C'N'SP	;SAVE P
	DMOVE	P,TM'N'INT	;STORE PC
	DMOVEM	P,@.C'N'CHL	;SAVE AT APR PI CHANNEL JSR ADDRESS

	MOVSI	P,(ST.CYC)	;50 HZ POWER?
	TDNE	P,STATES	;SKIP IF NO
	JRST	[MOVEI	P,^D2000 ;50HZ, SO SETUP 20000 USECS
		 JRST	TM'N'IN1] ;AND SET THAT AS NEW INTERVAL
	MOVEI	P,^D1666	;60HZ, SO ASSUME LEAP JIFFY
	AOSG	.C'N'TCT	;COUNT TRIAD COUNTER (-1,0,1)
	AOJA	P,TM'N'IN1	;NOT LEAP TICK UNLESS TRIAD COUNT IS 1
	SETCMM	.C'N'TCT	;COUNT REACHED 1, SET BACK TO -2
TM'N'IN1:CONO	TIM,TO.CTD!TO.SIT(P)	;SET INTERVAL OF TIMER AGAIN
	SETOM	.C'N'TIM	;SOFTWARE CLOCK FLAG FOR KL'S
	JRST	AP'N'CLK	;GO JOIN MAIN STREAM OF EVENTS
AP'N'PWF:CONI	PI,AP'N'PD1+1	;SAVE STATE OF PI SYS
	CONO	PI,PI.OFF	;TURN OFF INTERRUPTS
	MOVEM	P,.C'N'SP	;SAVE P
	MOVE	P,.CPEBR	;GET CURRENT EBR
	ANDI	P,-1-<LG.CSL!LG.CSW> ;TURN OFF CACHE
	CONO	PAG,(P)		;...
	SWPUA			;SWEEP CACHE
	CONSZ	APR,LP.CSB
	JRST	.-1
	DATAI	PAG,AP'N'PD1+2	;SAVE UBR, CURRENT, PREVIOUS AC BLKS
	CONI	MTR,AP'N'PD1+3
	MOVE	P,.C'N'SP
	JSR	.CPSVA		;SAVE ALL AC SETS
	MOVSI	P,(JRST)
IFN FTMP,<
	HLLM	P,.CPRES
>
IFE FTMP,<
	HLLM	P,ARSLOC
>
	MOVE	P,AP'N'PDP	;GET A STACK
	ADJSP	P,4		;SKIP WORDS WE STORE JUNK IN
	PUSHJ	P,DTEPWF##	;TELL F.E. WE HAVE A POWER FAILURE
	MOVEI	17,700000
	SOJG	17,.		;MAKE SURE POWER HAS FAILED
	JRST	APRRES		;IT HASN'T
AP'N'RES:SWPIA			;CLEAR OUT CACHE
	CONSZ	APR,LP.CSB
	JRST	.-1
	CONO	PAG,@.CPEBR	;TURN ON CACHE, TRAP ENABLE
	MOVEM	P3,@.CPSPT	;RESTORE SPT
	MOVE	P,AP'N'PD1+1	;GET CONI PI WORD
	ANDI	P,377		;JUST SYS ON, OFF AND CHANNELS ON, OFF
	CONO	PI,PI.TNP(P)	;TURN ON CHANNELS AND SYS, IF IT WAS ON BEFORE
	MOVE	P,AP'N'PD1+2	;GET UPT INFO
	TRO	P,LG.IAM	;INHIBIT UPDATING OF ACCOUNTING METERS
	DATAO	PAG,P		;RESTORE UBR FOR METERS
	MOVE	P,AP'N'PD1+3	;GET CONI MTR,
	CONO	MTR,MO.LAC(P)	;LOAD ACCOUNTING CONTROL, PI
	MOVSI	P,(HALT)
IFN FTMP,<
	HLLM	P,.CPRES
>
IFE FTMP,<
	HLLM	P,ARSLOC
>
	MOVE	P,AP'N'PDP	;GET A STACK
	ADJSP	P,4		;SKIP WORDS WE STORE JUNK IN
	PUSHJ	P,DTEPFC##	;RE-ESTABLISH PRIMARY PROTOCOL
	JSP	T4,ZAPICH	;PUT INTERNAL CHANNELS BACK TOGETHER
	PUSHJ	P,DSKRCL	;CAUSE HOME BLOCKS TO BE REREAD
	RESTOR	(0,.CPCAC)
	RESTOR	(1,.CPCA1)
	RESTOR	(2,.CPCA2)
	RESTOR	(3,.CPCA3)
	RESTOR	(4,.CPCA4)
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT!^D1667
	DATAO	PAG,AP'N'PD1+2
	CONO	APR,AP'N'NUL	;CLEAR POWER FAIL, ENABLE FOR GOOD STUFF
	JRST	AP'N'EXT	;BYE.
> ;END KL10 MACRO
;DEFINE KS10 APR INTERRUPT HANDLER
; IT CALLS CPU INDEPENDENT CODE AS SOON AS POSSIBLE

DEFINE	KS(N)<

;HERE ON OPERATOR CONTINUE AFTER POWER FAILURE, IO PAGE FAIL, WATCH DOG TIMER RUNOUT,
AP'N'CPF: WRAPR	SP.CSF+SP.NXM+SP.HMP+SP.SMP+SP.PWF
				;CLEAR NXM, HARD & SOFT PARITY, POWER FAILURE

;HERE ON APR CHANNEL INTERRUPT
AP'N'INT::CONSO	APR,@.C'N'CON	;INTERRUPT FOR APR (MONITOR OR USER ENABLED)
	JRST	.-1		;NO, TRY NEXT DEVICE ON THIS PI CHANNEL
	SKIPE	CRSHWD		;OPR DEPOSIT 30 NON-ZERO?
	JRST	SYSCRH		;YES, TAKE CRASH DUMP
AP'N'BCK::CONSZ	APR,SP.NXM!SP.HMP!SP.PWF ;NXM, HARD PARITY OR POWER FAIL?
	JRST	AP'N'UNS	;YES, GO PROCESS UNUSUAL INTERRUPTS
AP'N'IN2::MOVEM	P,.C'N'SP	;SAVE AC P
	CONSO	APR,SP.ITI	;CLOCK TICK?
	JRST	AP'N'IN3	;NO, PROCEED
	MOVSI	P,(ST.CYC)	;50 HZ POWER?
	TDNE	P,STATES	;SKIP IF NO
	JRST	[MOVEI	P,<^D20> ;50HZ, SO SETUP 20 MILLISECS
		 JRST	TM'N'IN1] ;AND SET THAT AS NEW INTERVAL
	MOVEI	P,<^D16>	;60HZ, SO ASSUME LEAP JIFFY
	AOSG	.C'N'TCT	;COUNT TRIAD COUNTER (-1,0,1)
	SKIPA	P,[<^D17>] 	;NOT LEAP TICK UNLESS TRIAD COUNT IS 1
	SETCMM	.C'N'TCT	;COUNT REACHED 1, SET BACK TO -2
TM'N'IN1:ADDM	P,.C'N'LMC	;ADD THIS INTERVAL TO LEAP MSEC COUNT
	SKIPL	.C'N'LMC	;IS IT STILL NEGATIVE?
	ADDI	P,1		;NO--IT'S TIME FOR A LEAP MSEC
	LSH	P,<^D12>	;SHIFT TO LOAD INTO TIMER REGISTER
	WRINT	P		;SET INTERVAL OF TIMER AGAIN
	WRAPR	SP.CSF!SP.ITI	;CLEAR INTERVAL TIMER INTERRUPT FLAG
	SETOM	.C'N'TIM	;SET SOFTWARE CLOCK TICK FLAG
	SKIPGE	P,.C'N'LMC	;IS THIS A LEAP MSEC?
	JRST	TM'N'IN2	;NO--GO ON
	ADD	P,[-^D1024]	;YES--COMPUTE NEXT LEAP MSEC COUNT
	MOVEM	P,.C'N'LMC	;RESET IT
TM'N'IN2:SKIPN	CLKDDT		;IS 21 NON-ZERO
	JRST	CLKDDR		;NO--PROCEED
	SETZM	CLKDDT		;CLEAR FLAG
	XCT	SYSDDT		;GO TO EDDT IF POSSIBLE
CLKDDR::
AP'N'IN3::MOVE	P,AP'N'PDP	;SET TO PD LIST FOR THIS CPU
	PUSHJ	P,APRSUB##	;GO PROCESS INTERRUPT
	MOVE	P,.C'N'SP	;RESTORE P
AP'N'EXT:WRAPR	AP'N'CHN	;SET APR PI
	XJEN	AP'N'CHL	;DISMISS INTERRUPT
;HERE TO PROCESS UNUSUAL INTERRUPTS
AP'N'UNS: CONSZ	APR,SP.PWF	;POWER FAIL?
	JRST	AP'N'PWF	;YES, GO SETUP FOR AUTO-RESTART
	CONSZ	APR,SP.NXM!SP.HMP ;NXM OR PARITY ERROR?
	JRST	AP'N'IN2	;YES--GO PROCESS IT
	JRST	AP'N'EXT	;DISMISS INTERRUPT

	DEFINE ZERO(X),<
	EXECAC	(X)
	SETZ	0,
	MOVEI	17,1
	BLT	17,17
>
AP'N'PWF:RDPI	AP'N'PD1+1	;SAVE STATE OF PI SYS
	WRPI	PI.OFF		;TURN OFF PI'S
	RDUBR	AP'N'PD1+2	;SAVE UBR, CURRENT, PREVIOUS AC BLKS
	RDTIME	AP'N'PD1+3	;SAVE TIME BASE
	JSR	.CPSVA		;SAVE ALL AC SETS
	MOVE	P,[JRST APRRES]	;POWER FAIL AUTO RESTART INTSTRUCTION
	MOVEM	P,ARSLOC	;SET IT UP
	HALT			;STOP
				;FE RESTARTS US AT 70 WHICH EVENTUALLY
				; GETS US HERE
AP'N'RES:WRUBR	AP'N'PD1+2	;RESTORE UBR AND AC BLOCKS IN USE
	SETZ	0,		;CLEAR CURRENT AC BLOCK FOR USE
	MOVEI	17,1		;...
	BLT	17,17		;...
	MOVEI	P,AP'N'PD1+5	;GET A STACK
	PUSHJ	P,UBAPIS	;RESET UBA'S
	MOVE	T1,AP'N'PD1+1	;GET CONI PI WORD
	ANDI	T1,377		;JUST SYS ON, OFF AND CHANNELS
	WRPI	PI.TNP(T1)	;RESTORE PI SYSTEM
	MOVEI	T1,<^D16>B23	;RESTART INTERVAL TIMER
	WRINT	T1		;SET IT
	MOVE	T1,[HALT ARSLOC];HALT AT 70 INSTRUCTION
	MOVEM	T1,ARSLOC	;DISABLE 70 RESTART
	MOVE	U,OPRLDB	;OPR'S LDB
	MOVEI	T1,[ASCIZ /
%Power fail restart
/]
	PUSHJ	P,CONMES##	;ANNOUNCE RESTART
	PUSHJ	P,ENAKAL##	;ENABLE KEEP ALIVE FUNCTION
	PUSHJ	P,DSKRCL	;CAUSE HOME BLOCKS TO BE REREAD
	RESTOR	(0,.CPCAC)	;RESTORE AC'S
	RESTOR	(1,.CPCA1)
	RESTOR	(2,.CPCA2)
	RESTOR	(3,.CPCA3)
	RESTOR	(4,.CPCA4)
	ZERO	(5)		;CLEAN OUT REST OF AC BLOCKS
	ZERO	(6)
	ZERO	(7)
	WRUBR	AP'N'PD1+2	;RESTORE UBR AND AC BLOCKS IN USE
	WRTIME	AP'N'PD1+3	;RESTORE TIME BASE
	WRAPR	AP'N'NUL	;CLEAR POWER FAIL, ENABLE FOR GOOD STUFF
	JRST	AP'N'EXT	;BYE.

;KS10 KEEP-ALIVE FAILURE TRAP CODE
	$ABS
AP'N'KAF:EXP	0,0,IC.UOU,AP'N'KA0
AP'N'KA0:MOVEM	P,KF'N'SVP
	MOVEI	P,KF'N'PDL-1
	JRST	KAFSTP
KF'N'PDL:BLOCK	1
KF'N'SVP:BLOCK	1

	EPLLEN==:10
EP'N'PDL::
	BLOCK	EPLLEN		;;FIRST WORD IS "P" OF OVERFLOW

	$HIGH


;ROUTINE TO SET UP PI ASSIGNMENTS ON UBA'S
UBAPIS::PUSHJ	P,SAVT		;SAVE T REGS
	MOVE	T1,[1,,UNBSTW]	;UBA #1 STATUS REGISTER
	PUSHJ	P,UBGOOD##	;IS UBA #1 THERE?
	  JRST	UBAPI0		;NO--SO DON'T TRY TO INIT IT
	MOVSI	T2,1		;UBA #1
	MOVEI	T1,UBINIT	;UNIBUS INIT
	WRIO	T1,UNBSTW(T2)	;DO IT
	MOVEI	T1,UBA1PI	;UBA #1 PI
	IORI	T1,UNBDTR	;SET DISABLE XFER BIT
	WRIO	T1,UNBSTW(T2)	;SET UP AND INIT UBA #1
UBAPI0:	MOVE	T1,[3,,UNBSTW]	;UBA #3 STATUS REGISTER
	PUSHJ	P,UBGOOD##	;IS UBA #3 THERE?
	  POPJ	P,		;NO--SO DON'T TRY TO INIT IT
	MOVSI	T2,3		;UBA #3
	MOVEI	T1,UBINIT	;UNIBUS INIT
	WRIO	T1,UNBSTW(T2)	;DO IT
	MOVEI	T1,UBA3PI	;UBA #3 PI'S
	IORI	T1,UNBDTR	;SET DISABLE XFER BIT
	WRIO	T1,UNBSTW(T2)	;SET UP AND INIT UBA #3
	POPJ	P,		;RETURN
>;END KS10 MACRO
;GENERATE APR INTERRUPT CODE DEPENDING ON CPUN AND KI VS KL VS KS
ZZ==0
REPEAT CPUN,<				;NO OF CPUS IN SYSTEM
	KILS(\ZZ)			;GENERATE INTERRUPT CODE
	ZZ==ZZ+1			;STEP TO NEXT CPU NUMBER
>
	$ABS
;ENTER DDT

ENTDDT:	JFCL	DDTX		;FIRST ENTRY PATCHES THIS TO JRST
	EXECAC			;GET AC SET RIGHT
	CONO	APR,200000	;BLAST
	CONO	PI,CLRPIS	;BLAST
IFN M.KL10,<
	CONO	PAG,0		;INSURE THAT THE CACHE IS OFF
>
	JSP	T4,SYSTR0	;SEE WHICH CPU THIS IS AND SETUP THE EBR
	  JFCL			;REALLY SHOULD BE THE BOOT CPU
	MOVSI	T1,(JRST)	;ONLY NEED (WANT) TO DO THIS ONCE
	HLLM	T1,ENTDDT	; AS MONITOR WILL TURN ON PAGING FOR US
	JRST	DDTX		;ENTER DDT

	IFG	DDTN, <EXTERNAL DDTX>
	IFE	DDTN, <
		XP DDTEND,0	;ONCE REFERENCES END OF DDT
		XP DDTX,0	; AND ALSO ITS ENTRY POINT.
		XP $1B,0	; AND ALSO BREAKPOINTS
		>

;LOAD SCHEDULER FOR NON-SWAPPING OR SWAPPING SYSTEM
	EXTERNAL SCHED	;SCHED
		IFN LEVDN,<EXTERNAL SWPSER	;IO HANDLER FOR LEVEL D SWAPPER>


	EXTERNAL SEGCON
;SATISFY GLOBAL NEEDED FOR USER MODE ONCE ONLY - NEVER CALLED BY EXEC MONITOR
	XP	USRCPY,CPOPJ
SUBTTL	KL10 SYSTEM TIME BASE ROUTINES
IFN M.KL10,<

;THESE ROUTINES PERFORM THE SAME FUNCTIONS AS THE DK10 ROUTINES DO
; FOR THE KI10. THEY ALSO INITIALIZE THE ACCOUNTING METERS.

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE
; COMPUTES DATE BY CALLING SUDATE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MUL	T1,[RTUPS*^D10]	;CONVERT TO 1 USEC UNITS FOR TIME BASE
	ASHC	T1,<^D35-TB.LTP>;ACCOUNT FOR COUNTS/TICK
	CONO	MTR,MO.TOF!MO.CTB ;TURN OFF TIME BASE, CLEAR IT.
	MOVE	T3,.CPEPT	;ADDRESS OF THIS PROCESSOR'S EPT
	DMOVEM	T1,.E0HTB-.E0MP(T3) ;STORE UNIVERSAL DATE TIME BASE (RUNS OUT IN 5028
	MOVEI	T2,MO.LAC!MO.AO!MO.AEN!MO.AIP	;INITIALIZE ACCOUNTING
	MOVEI	T1,ST%XPI	;CHECK IF PI TIME IS EXCLUDED
	TDNE	T1,CNFST2	;SKIP IF IT IS NOT EXCLUDED
	TRZ	T2,MO.AIP	;IT IS, DO NOT INCLUDE
	CONO	MTR,MO.TON(T2)	;TURN TIME BASE ON, DO GOOD STUFF
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,


RTUPS==:^D100000	;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	ASHC	T3,<TB.LTP-^D35>	;ACCOUNT FOR COUNT/TIME BASE TICK
	DDIV	T1,RTCMTT	;DIVIDE BY RTCMAX*10, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND USECS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D10		;CONVERT TO RTUPS UNITS (10 USECS)
	MOVE	T1,T3		;AND GET FINAL ANSWER IN T1
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	2,203565660000	;RTUPS*^D3600*^D24*^D10 (MICROSECS/DAY)
RTCDAY==:CPOPJ


>;END IFN M.KL10
SUBTTL	KS10 SYSTEM TIME BASE ROUTINES
IFN M.KS10,<

;THESE ROUTINES PERFORM THE SAME FUNCTIONS AS THE DK10 ROUTINES DO
; FOR THE KA10 AND KI10.

;ROUTINE TO SETUP INITIAL TIME BASE VALUE, CALLED BY SYSINI AFTER ONCE
; COMPUTES DATE BY CALLING SUDATE

SETIME::MOVE	T1,DATE		;GET UNIVERSAL DATE/TIME
	MULI	T1,^D86400	;GET SECONDS SINCE NOV 17,1858
	ASHC	T1,^D17		;PUT BINARY POINT AFTER BIT
				; 35 OF T1 YIELDING
				; SECONDS SINCE NOV 17, 1858
				; IN T1
	MULI	T1,^D1000	;MILLISECOND RESOLUTION
	ASHC	T1,^D12		;ACCOUNT FOR COUNTS/TICK
	WRTIME	T1		;LOAD TIME BASE
	MOVEI	T1,<^D17>B23	;INTERVAL FOR TIMER
	WRINT	T1		;LOAD INVERVAL FOR TIMER
	WRAPR	SP.CSF+SP.ESF+SP.ITI+AP0CHN ;TURN INTERVAL TIMER ON
	PUSHJ	P,GETIME	;GET TIME SO WE CAN
	MOVEM	T1,.CPXTM	;SET UP THE FIRST LAST TIME
	POPJ	P,		;END RETURN


RTUPS==:^D100000	;RESOLUTION OF ACCOUNTING
RTUPS3==:RTUPS/^D1000		;FOR USE IN JOBTIM: ROUTINE
RTUPS5==:RTUPS/^D100000

;GET TIME OF DAY IN RTUPS UNITS/SECOND
; USES ACS T1-T4

GETIME::SETZB	T1,T2		;CLEAR T1,T2 FOR DDIV
	RDTIME	T3		;GET UNIVERSAL TIME IN TIME BASE UNITS
	DDIV	T1,RTCMTT	;DIVIDE BY TICS/DAY, YIELDING UNIVERSAL
				; DATE IN T1,T2 AND TICS SINCE MIDNITE IN T3,T4
	DIVI	T3,^D41		;CONVERT TO RTWPS UNITS
	MOVE	T1,T3		;GET INTO T1 (IN 10 USEC UNITS)
	POPJ	P,		;RETURN

RTCMAX::RTUPS*^D3600*^D24	;RTUPS UNITS/DAY
RTCMTT:	EXP	12,117226200000	;CLOCK TICS PER DAY AT 4.1 MHZ
RTCDAY==:CPOPJ


>;END IFN M.KS10
;DEFINE GLOBALS IF NO MOS MEMORY SUPPORT
IFN M.KL10,<IFE M.MOS,<
	XP	DIAGTM,CPOPJ
	XP	DIAGVM,CPOPJ
>>

;DEFINE GLOBALS IF NO EXTENDED ADDRESSING SUPPORT
IFE FTXMON,<
	XP	SSPCS,CPOPJ
	XP	SVPCS,CPOPJ
	XP	STPCS,CPOPJ
	XP	SPCS,CPOPJ
>


SUBTTL PROCESSOR STUFF

;MAKE SURE THAT PROPER VERSION OF FEATURE SWITCH FILES WERE USED TO ASSEMBLE
;THE REST OF THE MONITOR
;THE LOADER WILL PRINT MUL. DEF. GLOBAL IF A MISTAKE HAS BEEN MADE

;DUAL PROCESSOR SYSTEM ROUTINE GETS LOADED HERE

IFG <CPUN-1>,<
	EXTERN	CPNSER
>

	IFE	COREN, <IFE FTXMON,<COREN==^D256_K2PLSH>
			IFN FTXMON,<COREN==<<MXSECN+1>*^D256>_K2PLSH> ;NO RESTRICTION IF 0 TYPED>
	XP	USRLIM,COREN	;DEFINE GLOBAL RESTRICTING MAXIMUM SIZE OF
					; CORE FOR ANY SINGLE USER
					; ONCE ONLY CODE CAN ALTER THIS VALUE
					; (PATCH RH CORLIM IN SYSINI)


	$ABS

;NOTE: THESE SYMBOLS WILL GO AWAY SOON SO THAT AP.??? SYMBOLS
; WILL BE USED INSTEAD AS DEFINED IN S.MAC
;APR AND PI BITS

;APR BITS FOR BOTH PDP-6 AND KA10


	CLKBIT==:1
	REPEAT	7-CK0CHN, <CLKBIT==:CLKBIT*2>
	REQCLK==:PI.IIO+CLKBIT	;REQUEST INTERRUPT ON LOW PRIORITY CLK CHANNEL
	ZZ==1
	REPEAT	7-SCNCHN,<ZZ==ZZ*2>
	REQCTY==:PI.IIO+ZZ	;FOR KL10 CTY, MUST INTERRUPT ON SCANNER PI BY HAND
	CLRCTY==:II.CPP+ZZ	;CLEAR PSEUDO-CTY INTERRUPT (KL10)

	CLRPIS==:11577		;CLEAR THE PI SYSTEM

IFN CP0KLN,<AP0NUL==:LP.ESF!LP.CSF+LP.SBE+LP.NXM+LP.PAR+LP.IOF+LP.PWF+LP.CDP+LP.ADP+LP.CSD+AP0CHN>
				;RESET APR FOR NULL JOB
				; CLEAR EVERYTHING BUT DON'T I/O RESET
IFN CP0KSN,<AP0NUL==:SP.ESF!SP.CSF!SP.PWF!SP.ITI!SP.FEI+AP0CHN>
	AP0RST==:AP0NUL+200000	;RESET APR FOR SYSINI (I/O RESET TOO)
IFN M.KL10,<NXM==:LP.NXM>	;NON-EX MEM (APR STATUS WORD)
IFN M.KS10,<NXM==:SP.NXM>
;NOW HARDWARE BITS WHICH DEPEND ON SOFTWARE CONFIGURATION:

	XP	XI.RQC,REQCLK	;CONO PI.XI.RQC REQUESTS CLK INTERRUPT
	XP	II.CCI,II.CPP+CLKBIT
XP XC.UOU,UIOMOD

;DEFINE APR SYMBOLS FOR PDP-6 VS KA10 FOR CPU 0

	XP	PIPROG,77400	;PI STATUS REGISTER
				;ONES IF ANY PI'S IN PROGRESS
				;DO NOT DEFINE IF PDP-6 SO UNDEFINED
				;GLOBAL WILL BE CLUE TO PDP-6 USER
				;TO CHANGE CODE
	A0.NOT==PIPROG-<400_<7-AP0CHN>>	;DEFINE ALL PI IN PROGRESS FLAGS EXCEPT
				; APR FOR HALT TEST IN APRINT.
	A0.APP==1_<7-AP0CHN+10>	;CPU0 APR PI IN PROGRESS
	A0.NOC==:PIPROG-<400_<7-CK0CHN>> ;PI-IN-PROG EXCEPT CLOCK
	A0.ACO==1_<7-AP0CHN>	;CPU0 APR CHANNEL ON
	XP	SYSOFF,<177_-AP0CHN>+PI.TFP ;TURNS OFF ALL PI CHANNELS BELOW
				; THE APR CHANNEL.  USED BY INTERLOCK
				; MACROS AND DEPENDS ON NOONE ATTEMPTING
				; TO OBTAIN OR WAITING FOR AN INTERLOCK
				; AT OR ABOVE THE APR CHANNEL
	XP	SYSON,<177_-AP0CHN>+PI.TNP

IFN CP0KLN!CP0KSN, <A0.FOV==000	;PC CHANGE CANNOT BE ENABLED ON PDP-6, BECAUSE
				; IT MAKES MONITOR TRAP ALSO>
;DEFINE APR SYMBOLS FOR CPU'S GREATER THAN 1

DEFINE APRDEF(X)<
	A'X'.NOT==PIPROG-<400_<7-AP'X'CHN>>
	A'X'.APP==1_<7-AP'X'CHN+10>
	A'X'.FOV==0
	A'X'.ACO==1_<7-AP'X'CHN>
IFN M.KL10,<AP'X'NUL==:LP.ESF!LP.CSF!LP.SBE!LP.NXM!LP.PAR!LP.IOF!LP.PWF+LP.CDP+LP.ADP+LP.CSD+AP'X'CHN>
	AP'X'RST==:AP'X'NUL+200000
>;END DEFINE APRDEF

ZZ==1
REPEAT <M.CPU-1>,<
	APRDEF	(\ZZ)
ZZ==ZZ+1
>

APRNUL==:AP0NUL
APRRST==:AP0RST
APRCHN==:AP0CHN
;IF THERE IS ONLY ONE CPU IN THIS SYSTEM DEFINE ALL NECESSARY GLOBALS

IFE <CPUN-1>,<			;NO SECOND CPU?
	$HIGH
STMPEC::MOVE	P4,.C0EPT
	DPB	P3,P2
	CLRPGT	(0)
	POPJ	P,
	SUBTTL	REAL TIME TRAPPING
IFN FTRTTRP,<
IFG RTTRPN,<
	EXTERN	RTTRP
	$HIGH

RTMCAN==:.USMUE
RTMUAC::POINT	4,.USMUO,30	;UUO AC FIELD
RTMUOC::POINT	9,.USMUO,26	;UUO OPCODE FIELD


;TRPGO IS ENTERED FROM THE CHANNEL SAVE ROUTINE DURING A REAL TIME DEVICE
; INTERRUPT. RELAVENT LOCATIONS FROM THE USER PAGE MAP PAGE, TRPFLG, AND
; LOCATION 61 ARE SAVED. THE REAL TIME USER'S UPMP AND TRAP LOCATIONS ARE
; SETUP AND CONTROL IS TRANSFERRED TO THE USER'S INTERRUPT ROUTINE IN USER
; MODE.

TRPGO::
	MOVE	T1,@.CPSPT	;SPT
	MOVEM	T1,1(P)		;SAVE THAT
	MOVE	T1,RELTB1##(J)	;REAL TIME PROGRAM'S PROCESS TABLE
	HRRM	T1,@.CPSPT	;PART OF MAKING THE JOB ADDRESSABLE

	DATAO	PAG,RELTB1##(J)	;SETUP THE INTERRUPT LEVEL USER'S BASE REGISTER
	ADD	P,[XWD 22,22]	;OFFSET THE STACK FOR SAVING BACKGROUND
				; CONTEXT OF THE INTERRUPT LEVEL USER
	MOVSI	T1,.USPFT	;STARTING AT THE PAGE FAULT TRAP INSTRUCTION
	HRRI	T1,-20(P)	; THROUGH THE PUBLIC TRAP NEW MUUO PC
	BLT	T1,(P)		; SAVE THE BACKGROUNG UPMP
	MOVE	T1,[XWD RTTUPM,.USPFT]
	BLT	T1,.UPMP+437	;SETUP THE INTERRUPT LEVEL UPMP
IFN M.KL10,<
	PUSH	P,.USPFW	;SAVE PAGE FAIL WORD
	PUSH	P,.USPFP	; AND OLD P.F. PC
	PUSH	P,.USPFN	; AND NEW P.F. PC
	PUSH	P,.USPFN+1	; ..

	MOVEI	T1,RTTILM	;WHERE TO GO ON ILM
	MOVEM	T1,.USPFN+1	;STORE THAT
>
	HRRI	T1,RTTAOF	;ADDRESS OF INTERRUPT LEVEL ARITHMETIC
				; EXCEPTION PROCESSING ROUTINE
IFN M.KL10,<HLL T1,-22(P)>
	MOVEM	T1,.USAOT	;ENABLE OR DISABLE INTERRUPT LEVEL ARITHMETIC
				; TRAPPING
	PUSH	P,.CPDMI	;SAVE 61
	PUSH	P,.CPRTT	;AND LOWER LEVEL TRPFLG
	HRLI	J,400000	;MAKE TRPFLG NEGATIVE, USER MODE OFF
				; FOR CHN TEST ON WHETHER TO SAVE ACS
	MOVEM	J,.CPRTT	;SETUP TRPFLG FOR THIS INTERRUPT LEVEL USER
	MOVE	T1,DISMT1##(J)	;GET THE DISMISS INSTRUCTION FOR THIS INTERRUPT
				; LEVEL
	MOVEM	T1,.CPDMI	;STORE IT IN 61
	JRST	2,@TRPTB1##(J)	;ENTER THE USER'S INTERRUPT ROUTINE IN USER MODE
;DISMIS IS ENTERED FROM THE CHANNEL DISMISS ROUTINE BY A JSP J,DISMIS.
; THE STATE OF THE MACHINE IS RESTORED AND THE ROUTINE RETURNS TO THE
; CHANNEL DISMISS ROUTINE TO RESTORE THE AC'S AND DISMISS THE INTERRUPT.

DSMAPR:
DISMIS:	POP	P,.CPRTT	;RESTORE LOWER LEVEL TRPFLG
	POP	P,.CPDMI	;RESTORE 61
IFN M.KL10,<
	POP	P,.USPFN+1

	POP	P,.USPFN	;RESTORE NEW P.F. PC
	POP	P,.USPFP	;RESTORE OLD P.F. PC
	POP	P,.USPFW	;RESTORE P.F. WORD
>
	SUB	P,[XWD 20,20]	;SET STACK OFFSET FOR RESTORING BACKGROUND
				; UPMP
	MOVSI	T1,(P)		; ..
	HRRI	T1,.USPFT	;STARTING AT PAGE FAULT TRAP INSTRUCTION
	BLT	T1,.UPMP+437	; RESTORE UPMP THROUGH PUBLIC TRAP NEW MUUO PC
	MOVE	T1,-1(P)	;SPT AT INTERRUPT
	HRRM	T1,@.CPSPT	;RESTORE THAT

	JRST	(J)		;RESTORE AC'S AND DISMISS THE INTERRUPT

;INTERRUPT LEVEL USER PAGE MAP PAGE

RTTUPM:	RTTILM
	RTTAOF
	RTTPOF
	JFCL
	0
	0
	IC.UOU+RTTILM
	RTTILM
	EXP	MUUO
	EXP	KTUUO
	EXP	SNTUUO
	EXP	STUUO
	EXP	RTCNTU
	EXP	KTUUO
	EXP	RTPNTU
	EXP	KTUUO
;HERE ON A UUO AT INTERRUPT LEVEL

RTCNTU:RTPNTU:
	MOVE	17,.USMUP	;30 BIT PC, NOT REALLY, MUST BE IN SECTION 0
	HLL	17,.USMUO	;UUO FLAGS
	JRSTF	@[IC.UOU+UUOHND##] ;TURN ON USRIOT BY HAND AND DISPATCH TO UUO HANDLER



;HERE ON AN ARITHMETIC EXCEPTION AT INTERRUPT LEVEL

RTTAOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.AOV+AP.FOV;REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON A PUSH DOWN LIST OVERFLOW AT INTERRUPT LEVEL

RTTPOF:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
	MOVEI	T1,AP.POV	;TELL USER THE REASON FOR THE TRAP
	JRST	ERRGO		;JOIN COMMON CODE

;HERE ON AN ILLEGAL MEMORY REFERENCE (PAGE FAULT) AT INTERRUPT LEVEL

RTTILM:	SKIPL	.CPRTT		;INTERRUPT IN PROGRESS?
	JRST	.CPDMI		;NO, JUST DISMISS
	MOVEM	T1,.JDAT+.JBCNI##
IFN M.KL10,<
	MOVE	T1,.USPFP
	MOVEM	T1,.USMUO
	MOVE	T1,.USPFP+1
	MOVEM	T1,.USMUP

>
	MOVEI	T1,AP.ILM	;TELL USER THE REASON FOR THE TRAP
ERRGO:	MOVEM	J,.CPRTS	;SAVE AN AC
	MOVE	J,.CPRTT	;GET INDEX INTO REAL TIME BLOCK
	EXCH	T1,.JDAT+.JBCNI##
	EXCH	T1,.USMUP	;GET THE TRAP PC
	HLL	T1,.USMUO	;FLAGS

	EXCTXU	<MOVEM T1,@APRTB1##(J)>
	HRR	T1,APRTB1##(J)	;ADDRESS OF THE USER'S TRAP HANDLING ROUTINE
	HRRI	T1,1(T1)	;CLEAR ALL FLAGS WHICH COULD CAUSE A TRAP
	TLZ	T1,(XC.OVF+XC.FOV+XC.TRP+XC.FUF+XC.NDV)
	EXCH	T1,.USMUP	;RESTORE T1 AND STORE PC
	MOVE	J,.CPRTS	;RESTORE J
	JRSTF	@.USMUP	;AND ENTER USER'S TRAP HANDLING ROUTINE

	$ABS
	RTINIC==:1			;FLAG SYSINI TO CALL INITIALIZATION ROUTINE

ENBSTD==470550+AP0CHN

MRTRPN==:-RTTRPN
RTBSIZ==:23

RTBLK::	BLOCK	RTTRPN*RTBSIZ
>>
IFE FTRTTRP,<IFN RTTRPN,<
PRINTX ;PLEASE ASSEMBLE SOURCES WITH FTRTTRP=-1
>>
IFN FTRTTRP,<IFE RTTRPN,<
CHAINT==:CPOPJ
RTBLK==:CPOPJ
RTLINK==:CPOPJ
SAV41==:CPOPJ
SAV61==:CPOPJ
CHNTAB==:CPOPJ
RTBSIZ==:CPOPJ
BLKENB==:CPOPJ
RTINIC==:0			;FLAG SYSINI NOT TO CALL INITIALIZATION ROUTINE
>>
  h.\