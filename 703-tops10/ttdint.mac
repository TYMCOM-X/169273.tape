TITLE TTDINT - DRIVER FOR DTE20 TELETYPES V072
SUBTTL	A. WILSON/WRS/CDO    26-NOV-85

	SEARCH	F,S,DTEPRM

;NOTE:
; IF ANY CHANGES ARE MADE TO DTEPRM THAT THIS MODULE MUST HAVE, UPDATE
; THE FOLLOWING SYMBOL TO THE VERSION OF DTEPRM THAT MUST BE USED
	PRMMIN==16
; THIS WAY, ASSEMBLING THIS MODULE WITH WRONG VERSION OF DTEPRM FOR SOME REASON
; (LIKE FORGETTING TO ASSEMBLE IT) WILL CAUSE ASSEMBLY TO TERMINATE.
; THIS SCHEME DOES NOT CAUSE EXTRA EDITING, SINCE ONLY FILES
; WHICH NEED THE CHANGES NEED PRMMIN TO BE UPDATED. MODULES
; THAT DO NOT NEED A NEW VERSION OF DTEPRM NEED NOT DEMAND IT.

IFL VDTPRM-PRMMIN,<PRINTX ?PLEASE USE LATEST VERSION OF DTEPRM
			PASS2
			END>


	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<1976,1986>
;COPYRIGHT (C) 1976,1977,1978,1979,1980,1982,1984,1986
;BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;ALL RIGHTS RESERVED.


;
;
;XP VTTDNT,072
	SALL
	ENTRY	TTDINT

TTDINT::


;BITS IN LEFT HALF OF .CP20F

F20ADS==(1B0)		;TOLD -20F ITS OK TO ANSWER DATASETS
F20LPP==:(1B1)		;LOST PRIMARY PROTOCOL (SET BE DTESER)
F20SDT==:(1B2)		;TELL FRONT-END OF DATE/TIME CHANGE (SET BY DTESER)
SUBTTL	MACROS AND STRINGS

DEFINE	$8BIT(SIZE,TEXT),<
	SIZE==<COUNT==<C%0==<C%1==<C%2==<C%3==0>>>>>
	IRPC (TEXT)<
		CHAR==<ASCII\TEXT\>_-^D29
		STOBYT(\COUNT,CHAR)
		COUNT==COUNT+1
		SIZE==SIZE+1
		IFE COUNT-4,<
			BYTE (8) C%0,C%1,C%2,C%3
			COUNT==<C%0==<C%1==<C%2==<C%3==0>>>>
		>
	>
	IFN COUNT,<BYTE (8) C%0,C%1,C%2,C%3>
>

DEFINE	STOBYT(BYTE,CHAR),<C%'BYTE==CHAR>



;STRING TO SEND TO ALL TERMINALS AFTER SWITCHING FROM PRIMARY PROTOCOL TO
;	SECONDARY AND BACK AGAIN.  -20F SAID "%DECSYSTEM-10 NOT RUNNING"

CONMSG:	$8BIT	CONSIZ,<
[DECsystem-10 Continued]
>
SUBTTL	DISPATCH TABLES

	CPOPJ##			;(-1)
CT0DSP::EATMSG##		;(0)
	EATMSG##		;(1)
	EATMSG##		;(2)
	EATMSG##		;(3)
	CTYLND			;(4)TAKE LINE, CHAR
	EATMSG##		;(5)
	EATMSG##		;(6)
	EATMSG##		;(7)
	EATMSG##		;(10)
	EATMSG##		;(11)
	EATMSG##		;(12)
	EATMSG##		;(13)
	EATMSG##		;(14)
	EATMSG##		;(15)
	EATMSG##		;(16)
	CTYACK			;(17)ACK
	EATMSG##		;(20)
	EATMSG##		;(21)
	EATMSG##		;(22)
	EATMSG##		;(23)
	EATMSG##		;(24)
	EATMSG##		;(25)
	EATMSG##		;(26)
	EATMSG##		;(27)
	EATMSG##		;(30)
	EATMSG##		;(31)
	EATMSG##		;(32)
	EATMSG##		;(33)
	EATMSG##		;(34)
	CPOPJ##			;(-1)
DLSDSP::EATMSG##		;(0)
	EATMSG##		;(1)
	EATMSG##		;(2)
	EATMSG##		;(3)
	DLSLND			;(4)TAKE LINE, CHAR
	EATMSG##		;(5)
	EATMSG##		;(6)
	EATMSG##		;(7)
	EATMSG##		;(10)
	EATMSG##		;(11)
	EATMSG##		;(12)
	EATMSG##		;(13)
	EATMSG##		;(14)
	TTDDWA			;(15)DATASET WAS ANSWERED
	TTDDHU			;(16)DATASET HUNG UP
	DLSACK			;(17)ACK
	EATMSG##		;(20)
	EATMSG##		;(21)
	TTDHLS			;(22)HERE ARE LINE SPEEDS
	EATMSG##		;(23)
	EATMSG##		;(24)
	DLSAAL			;(25)ACK ALL
	EATMSG##		;(26)
	EATMSG##		;(27)
	EATMSG##		;(30)
	EATMSG##		;(31)
	EATMSG##		;(32)
	EATMSG##		;(33)
	EATMSG##		;(34)
;DISPATCH FOR SCNSER COMMUNICATION WITH TTDINT

CTYDSP::			;USE SAME DISPATCH TABLE FOR THE CTYS
TTDDSP::PJRST	SPCTYO##	;SECONDARY PROTOCOL XMIT INTERRUPT
	PJRST	TTDDSC		;GO TO DATASET CONTROL ROUTINE
	PJRST	TTDSEC		;GO TO ONCE-A-SECOND ROUTINE
	POPJ	P,		;NO INITIALIZATION ROUTINE
	PJRST	SETCHP##	;MARK H/W PARAMETERS TO COME BACK THROUGH TTDSCN
	POPJ	P,		;RETURN ON LINE PARAMETER CONTROL CALL
	POPJ	P,		;RETURN ON SET ELEMENT NUMBER CALL
	PJRST	TTDREM		;HANDLE REMOTE CALL (^O)
	PJRST	CPOPJ1##	;ALWAYS SAY ON-LINE

;HERE ON REMOTE CALL FROM SCNSER ISR DISPATCH

TTDREM:	CAIE	T3,3		;ONLY CARE ABOUT ^O STRUCK
	POPJ	P,		;WASN'T, RETURN
	MOVSI	T1,LTLCTO##	;GET ^O STRUCK FLAG FOR -20F
	IORM	T1,LDBTTD##(U)	;STORE IN LDB
	PJRST	SETCHP##	;AND LET ONCE-A-TIC CODE SEE IT

;HERE FROM DTESER WHEN DTELDR RESTARTS PRIMARY PROTOCOL ON THE MASTER

TTDRLD::SE1ENT			;ENTER SECTION 1
	PUSHJ	P,SAVE1##	;SAVE P1
	HRRZS	.CP20F##	;CLEAR -20F FLAGS
	PUSH	P,U		;SAVE U
	SETZ	P1,		;START WITH DLS #0
TTDRL1:	MOVE	U,P1		;COPY DLS LINE NUMBER
	PUSHJ	P,DLSMON	;CONVERT TO -10 LINE NUMBER
	  JRST	UPOPJ##		;ALL DONE
	MOVE	U,LINTAB##(U)	;GET LDB ADDRESS
	TRNN	U,-1		;SETUP YET?
	JRST	TTDRL2		;NOPE
	SETZM	LDBTTD##(U)	;CLEAR FLAGS
	PUSHJ	P,SETCHP##	;NEED TO RE-SEND LINE SPEEDS
TTDRL2:	AOJA	P1,TTDRL1	;STEP TO NEXT DLS

;HERE FROM DTESER FOR DTE. UUO FUNCTION 21
;T1=CPU,,DTE (ALREADY VERRIFIED AND WE ARE ON RIGHT CPU)

TTDDLN::HLRZ	T2,T1		;GET CPU NUMBER
	TRNN	T1,-1		;WANT CFE
	JRST	TTDDL1		;YES, GET KLINIK,,CTY
	ADD	T1,TTDOFS##(T2)	;CONVERT DTE# TO 10 LINE #
	MOVEI	T1,.UXTRM(T1)	;CONVERT TO A UDX
	PJRST	STOTC1##	;GIVE GOOD RETURN
TTDDL1:	HRRZ	T1,.CPCTN##	;GET CTY # ON THIS CPU
	HRL	T1,TTDOFS##(T2)	;GET KLINIK (=LOWEST ENTRY)
	TDO	T1,[.UXTRM,,.UXTRM] ;CONVERT BOTH
	PJRST	STOTC1##	;GIVE GOOD RETURN
SUBTTL	ONCE A TICK CODE FOR TTDINT

;TTDSTO IS CALLED ONCE-PER-TICK ON EACH CPU TO DE-QUEUE OUTPUT

TTDSTO::HRRZ	T1,.CP20F##	;NUMBER OF CHARACTERS STILL IN BUFFER
	JUMPN	T1,CPOPJ##	;STILL ACTIVE, WAIT FOR POSTING
	PJRST	TTDSCN		;GO START UP OUTPUT IF ANY WAITING




;HERE FROM DTESER ON POST CALL FOR STRING OUTPUT

TTDPST:	SE1ENT			;ENTER SECTION 1
	HRRZ	U,S		;GET SAVED VALUE OF U (LINE NUMBER)
	MOVE	U,LINTAB##(U)	;LDB ADDRESS
	MOVSI	T1,LTLACK##	;WAITING FOR ACK FLAG
	IORM	T1,LDBTTD##(U)	;MARK THE LINE
	HLLZS	.CP20F##	;START STRING CHAR COUNT AT ZERO
;;	PJRST	TTDSCN		;SCAN FOR A BUSY LINE
;ROUTINE TO FIND AN ACTIVE LINE AND START OUTPUT ON IT.

TTDSCN:	SE1ENT			;ENTER SECTION 1
	MOVEI	T1,.CPCTQ##	;GET QUEUE HEADER
	PUSHJ	P,TOTAKE##	;FIND NEXT ACTIVE LINE
	  POPJ	P,		;NONE LEFT, RETURN
	PUSHJ	P,SKPMPP##	;PRIMARY PROTOCOL?
	  JRST	TTDSC4		;IF SECONDARY
	MOVEI	T1,L1RCHP##	;CHANGE HARDWARE PARAMETERS REQUEST BIT
	TDNE	T1,LDBBYT##(U)	;WAITING TO CHANGE?
	JRST	TTDCHP		;CHANGE IF NECESSARY
	MOVSI	T1,LTLACK##	;WAITING FOR ACK
	TDNN	T1,LDBTTD##(U)	;IS IT WAITING
	SKIPL	LDBDCH##(U)	;OR IS THIS LINE IDLE?
	JRST	TTDSCN		;CANNOT OUTPUT, TRY FOR ANOTHER LINE
	PUSH	P,P1		;SAVE P1
	MOVE	P1,[POINT 8,.CP20B##] ;GET POINTER TO STRING AREA
TTDSC1:	PUSHJ	P,XMTCHR##	;GET A CHARACTER TO SEND
	  JRST	TTDSC2		;LINE IS IDLE
	IDPB	T3,P1		;STORE CHARACTER IN BUFFER
	AOS	T1,.CP20F##	;ADVANCE COUNT
	TLZ	T1,-1		;CLEAR FLAG BITS
	CAIL	T1,TTDMOS##	;HAVE AS MANY CHARS AS WE WANT?
	JRST	TTDSC3		;YES, SEND WHAT WE'VE GOT
	JRST	TTDSC1		;TRY FOR ANOTHER CHARACTER
TTDSC2:	HRRZ	T1,.CP20F##	;ANY CHARACTERS FOUND THIS PASS
	JUMPE	T1,[POP	P,P1	;NO, RESTORE P1
 		    JRST TTDSCN] ;AND LOOK FOR ANOTHER LINE
TTDSC3:	POP	P,P1		;RESTORE
	PUSHJ	P,SAVE4##	;SAVE P1-P4
	PUSHJ	P,STDTQ		;SET UP DTEQUE ARGUMENTS
	HRRI	P2,EM.IND+.EMSTR ;OUTPUT INDIRECT STRING TO DLS
	HRR	P3,.CP20F##	;SET P3 TO DLS LINE #,,COUNT
	MOVE	P4,[POINT 8,.CP20B##] ;POINT TO INDIRECT STRING
	LDB	S,LDPLNO##	;REMEMBER LINE NUMBER
	HRLI	S,TTDPST	;POST ADDRESS
	S0PSHJ	DTEQUE##	;QUEUE THE REQUEST
	  HLLZS	.CP20F##	;FAILED, UNBLOCK CODE
	POPJ	P,		;RETURN

;HERE IF RUNNING SECONDARY PROTOCOL

TTDSC4:	LDB	T1,LDPLNO##	;GET LINE NUMBER
	HRRZ	T2,.CPCTN##	;GET CTY ON THIS CPU
	CAIE	T1,(T2)		;THIS IT
	JRST	TTDSC5		;NO, IGNORE DATA
	SKIPGE	LDBDCH##(U)	;LINE IDLE?
	PUSHJ	P,XMTCHR##	;YES, GET CHARACTER FOR OUTPUT
	  POPJ	P,		;IDLE, RETURN
	PUSHJ	P,CLRIRM##	;CLEAR LOST ACK FLAG
	PJRST	SPCTYO##	;AND TYPE OUT ON CTY
TTDSC5:	SKIPGE	LDBDCH##(U)	;LINE IDLE
	PUSHJ	P,XMTCHR##	;YES, GET A CHARACTER
	  POPJ	P,		;ALL DONE
	JRST	.-2		;THROW IT AWAY
SUBTTL	ROUTINE TO CHANGE HARDWARE PARAMETERS

;ENTRY TTDCHP IS USED WHEN SCANNING THE 'START OUTPUT' QUEUE.
;IT CLEARS THE L1RCHP BIT IN LDBBYT BEFORE SENDING THE CHP MESSAGE.
;ARGS:	T1/BIT TO CLEAR, SETUP BY MOVEI T1,L1RCHP
;	U/LDB ADDRESS
;	PUSHJ	P,TTDCHP
;	RETURN HERE

TTDCHP:	PUSHJ	P,SAVE4##	;SAVE P1-P4
	ANDCAM	T1,LDBBYT##(U)	;CLEAR CHP REQUEST BIT
	MOVSI	T1,LTLCTO##	;CONTROL-O STRUCK
	TDNE	T1,LDBTTD##(U)	;WAS IT
	PUSHJ	P,TTDCTO	;YES, TELL -20F
	MOVSI	T1,LTLXFF##	;SEND XOFF STATUS BIT
	TDNN	T1,LDBTTD##(U)	;DO WE WANT TO?
	 JRST	TTDCH2		;NO, SKIP THE CHECKS
	ANDCAM	T1,LDBTTD##(U)	;YES, CLEAR THE BIT
	MOVSI	T2,LOLSTP##	;CONTROL-S STRUCK
	MOVSI	T1,LTLXOF##	;GET TTD XOF BIT
	TDNN	T2,LDBOST##(U)	;WAS IT ^S
	JRST	TTDCH1		;NO, NOT ^S
	TDNN	T1,LDBTTD##(U)	;YES, DID WE KNOW THAT?
	PUSHJ	P,TTDXOF	;SEND XOF MESSAGE FOR LINE
	JRST	TTDCH2		;NOW SET SPEEDS
TTDCH1:	TDNE	T1,LDBTTD##(U)	;NOT ^S DID WE THINK IT WAS?
	PUSHJ	P,TTDXON	;SEND XON MESSAGE FOR LINE
TTDCH2:	PUSHJ	P,TTDSSP	;SEND SPEEDS
	LDB	T1,[POINT 4,LDBTTD##(U),3] ;GET TRANSMIT SPEED OF TERMINAL
	MOVSI	T2,LPLXNF##	;TERMINAL PAGE SET
	MOVSI	T1,LTLAXF##	;AUTO XOFF ENABLE SET
	TDNN	T2,LDBPAG##(U)	;ARE WE IN PAGE MODE?
	 JRST	TTDC2A		;NO
	TDNN	T1,LDBTTD##(U)	;HAS IT BEEN SET YET?
	PUSHJ	P,TTDAXF	;NO, GO DO IT
	JRST	TTDCH3		;
TTDC2A:	TDNE	T1,LDBTTD##(U)	;HAS IT BEEN CLEARED YET?
	PUSHJ	P,TTDAXF	;NO, DO SO NOW
TTDCH3:	PJRST	TOPOKE##	;LOOK AT MORE (AND THIS) NEXT TICK
SUBTTL	SET LINE SPEEDS

;HERE TO SET SPEEDS FOR RSX-20F FRONT-END LINE
;ARGS:	U/LDB ADDRESS
;CALL:	SAVE P1-P4
;	PUSHJ	P,TTDSSP
;	RETURN HERE
;WON'T NOT SEND SPEEDS TO -20F IF THEY DIDN'T CHANGE FROM LAST TIME.  IF A LINE
;	GETS CONFUSED, MUST SET TO ANOTHER SPEED AND THEN BACK TO DESIRED ONE.

TTDSSP:	MOVE	T3,[POINT ^D16,.CP20B##] ;POINT TO PLACE IN CDB
	SETO	T4,		;INDICATE BOTH CHANGED
	SETCM	T1,LDBDCH##(U)	;COMPLEMENT DATASET BIT
	HLL	T1,LDBTTD##(U)	;GET REMOTE FOR -20F
	TDNN	T1,[LTLRBS##,,LDRDSD##] ;ALREADY TOLD -20F
	TRZ	T4,-1		;NO, MUST SEND SPEED
	LDB	T1,LDPRSP##	;GET CODE FOR LINE TRANSMIT SPEED
	LDB	T2,[POINT 4,LDBTTD##(U),3] ;REMEMBERED SPEED
	CAIN	T1,(T2)		;DID SPEED CHANGE
	AOSA	T4		;NO, COUNT NUMBER THAT DIDN'T
	DPB	T1,[POINT 4,LDBTTD##(U),3] ;REMEMBERED SPEED
	MOVE	T1,LSPTAB##(T1)	;CONVERT TO BAUD
	IDPB	T1,T3		;BUILD THE SPEED MESSAGE
	LDB	T1,LDPTSP##	;GET CODE FOR LINE RECEIVE SPEED
	LDB	T2,[POINT 4,LDBTTD##(U),7] ;REMEMBERED SPEED
	CAIN	T1,(T2)		;DID THIS ONE CHANGE
	AOJG	T4,CPOPJ##	;RETURN IF NEITHER CHANGED
	DPB	T1,[POINT 4,LDBTTD##(U),7] ;REMEMBERED SPEED
	MOVE	T1,LSPTAB##(T1)	;CONVERT TO BAUD
	IDPB	T1,T3		;BUILD THE SPEED MESSAGE
	MOVEI	T2,1		;ASSUME ONE STOP BIT
	CAIG	T1,^D110	;LESS THAN OR EQUAL TO 110 BAUD?
	MOVEI	T2,2		;YES, SO USE TWO STOP BITS
	MOVE	T1,LDBDCH##(U)	;GET LINE CHARACTERISTICS WORD
	TRNE	T1,LDRDSD##	;DATASET LINE?
	JRST   [MOVSI	T1,LTLRBS##;YES, GET "REMOTE BIT SENT" BIT
		TDNE	T1,LDBTTD##(U);REMOTE BIT ALREADY SENT?
		JRST	.+1	;YES, BACK TO MAIN CODE
		IORM	T1,LDBTTD##(U);NO, MARK IT SENT AS OF NOW
		TRO	T2,140000;SET REMOTE BIT AND AUTO BAUD
		JRST	.+1]	;BACK TO MAIN CODE
	IDPB	T2,T3		;STORE ARGUMENT
	PUSHJ	P,STDTQ		;SET UP DTEQUE ARGUMENTS
	HRRI	P2,EM.16B+EM.IND+.EMHLS ;SET DLS LINE SPEEDS
	HRRI	P3,6		;SIX BYTES OF ARGUMENT
	MOVE	P4,[POINT ^D16,.CP20B##] ;POINT TO SPEED MESSAGE
	HLLOS	.CP20F##	;MARK BUFFER IN USE
	MOVSI	S,TTDSS1	;POST ADDRESS
	S0PSHJ	DTEQUE##	;QUEUE THE REQUEST
TTDSS1:	  HLLZS	.CP20F##	;FAILED (OR DONE)
	POPJ	P,		;RETURN

;NOTE:	THE NONSENSE WITH THE LTLRBS BIT IN THE CODE ABOVE IS NECESSITATED
;BY A QUIRK OF THE RSX-20F FRONT-END.  THE REMOTE BIT IN A LINE-SPEED
;MESSAGE SHOULD BE SENT ONLY ONCE; IF IT'S SENT AGAIN AFTER A USER HAS
;DIALED-IN, IT CAUSES THE DATASET TO BE DISCONNECTED.
SUBTTL	XOFF/AUTO-XOFF/XON/CONTROL-O PROCESSING

;ROUTINE TO SEND AUTO-XOFF/XOFF/XON/CNTRL-O FOR ^S/^Q/^O ON AN RSX-20F LINE
;ARGS:	U/LDB ADDRESS
;	T1/BIT TO SET/CLEAR IN LDBTTD
;CALL:	SAVE P1-P4
;	PUSHJ	P,TTDXXX	WHERE XXX IS AXF, XOF, XON, OR CTO
;	RETURN HERE

TTDAXF:	MOVEI	P2,.EMAXF	;ENABLE/DISABLE AUTO XOFF FUNCTION
	PUSHJ	P,STDTQ		;SET UP DTEQUE ARGUMENTS
	MOVSI	T2,LPLXNF##	;GET TERMINAL PAGE BIT
	TDNE	T2,LDBPAG##(U)	;IS IT SET?
	 JRST	TTDAX1		;YES
	TRZ	P3,-1		;NO, CLEAR AUTO-XOFF
	ANDCAM	T1,LDBTTD##(U)	;AND SHOW IT AS CLEAR
	JRST	TTDXO2		;GO QUEUE IT
TTDAX1:	HRRI	P3,1		;ENABLE AUTO-XOFF
	IORM	T1,LDBTTD##(U)	;AND SHOW IT AS SET
	JRST	TTDXO2		;GO QUEUE IT

TTDXOF:	MOVEI	P2,.EMXOF	;XOF FOR DLS
	IORM	T1,LDBTTD##(U)	;SET REQUESTED BIT
	JRST	TTDXO1		;GO SET UP DTESER ARGUMENTS
TTDCTO:	SKIPA	P2,[.EMFLO]	;FLUSH OUTPUT FOR DLS LINE
TTDXON:	MOVEI	P2,.EMXON	;XON FOR DLS
	ANDCAM	T1,LDBTTD##(U)	;CLEAR REQUESTED BIT

TTDXO1:	PUSHJ	P,STDTQ		;SET UP DTEQUE ARGUMENTS
TTDXO2:	S0PSHJ	DTEQUE##	;QUEUE THE REQUEST
	  JFCL			;FAILED, IGNORE IT
	POPJ	P,		;RETURN


SUBTTL	DATASET CONTROL

;SUBROUTINE TO EXERCISE CONTROL OVER A DATASET
;ARGS:	U/DSCTAB INDEX
;	T3/TRANSACTION CODE
;CALL:	PUSHJ	P,TTDDSC
;	RETURN HERE

TTDDSC:	CAIN	T3,DSTON##	;WANT TO TURN DATASET ON?
	PJRST	TTDCND		;YES
	CAIN	T3,DSTOFF##	;WANT TO TURN IT OFF?
	PJRST	TTDHUD		;YES, TELL RSX-20F TO HANG UP DATASET
	CAIN	T3,DSTREQ##	;WANT TO KNOW STATUS?
	MOVEI	T3,DSTNAC##	;YES, TELL SYSINI NOT TO TAKE ACTION
	POPJ	P,		;RETURN

TTDHUD:	PUSHJ	P,SAVE4##	;SAVE P1-P4
	HRRZ	P3,DSCTAB##(U)	;GET MONITOR LINE NUMBER
	PUSHJ	P,STDT1		;SET UP DTEQUE ARGUMENTS
	HRRI	P2,.EMHUD	;HANG UP DATASET FOR DLS LINE
	S0PSHJ	DTEQUE##	;QUEUE THE REQUEST
	  JFCL			;FAILED, JUST IGNORE
	POPJ	P,		;RETURN
TTDCND:	PUSHJ	P,SAVE4##	;SAVE P1-P4
	HRRZ	P3,DSCTAB##(U)	;GET MONITOR LINE NUMBER
	PUSHJ	P,STDT1		;SET UP DTEQUE ARGUMENTS
	HRRI	P2,.EMDSC	;CONNECT DATASET
	S0PSHJ	DTEQUE##	;QUEUE THE REQUEST
	  JFCL			;FAILED, JUST IGNORE
	POPJ	P,		;RETURN
SUBTTL	TAKE LINE SPEEDS FROM FRONT-END

;HERE FROM DTESER WHEN RSX-20F SENDS LINE SPEEDS

TTDILS:	TDZA	S,S		;HERE ON COMPLETION OF INDIRECT TRANSFER
TTDHLS:	MOVSI	S,TTDILS	;HERE ON START OF MESSAGE
	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;FAILED, IGNORE THIS MESSAGE
	HLRZ	U,P3		;GET DLS LINE NUMBER
	PUSHJ	P,DLSMON	;CONVERT TO MONITOR LINE NUMBER IN U
	  PJRST	EATMSG##	;OUT OF RANGE, IGNORE THIS MESSAGE
	MOVE	U,LINTAB##(U)	;GET LDB ADDRESS
	MOVE	P4,[POINT ^D16,.CP20S##] ;WHERE TO PUT INDIRECT DATA
	JUMPE	S,TTDIL1	;BRANCH IF HAVE INDIRECT DATA
	MOVEI	P3,6		;WE WANT 6 8-BIT BYTES
	POPJ	P,		;RETURN

TTDIL1:	ILDB	T1,P4		;GET LINE TRANSMIT SPEED IN BAUD
	PUSHJ	P,FNDSPD	;SET T1 TO CODED SPEED VALUE
	SE1ENT			;ENTER SECTION 1
	JUMPE	T1,TTDIL2	;IGNORE IF -20F DOESN'T KNOW
	DPB	T1,LDPRSP##	;SAVE IN LDB
	DPB	T1,[POINT 4,LDBTTD##(U),3] ;REMEMBERED SPEED
	ILDB	T1,P4		;GET LINE RECEIVE SPEED IN BAUD
	PUSHJ	P,FNDSPD	;SET T1 TO CODED SPEED VALUE
	DPB	T1,LDPTSP##	;SAVE IN LDB
	DPB	T1,[POINT 4,LDBTTD##(U),7] ;REMEMBERED SPEED
TTDIL2:	SETZB	P3,P4		;TELL DTESER WE'RE DONE
	MOVSI	T1,LTLAXF##	;IF -20F TOLD US THE SPEEDS
	ANDCAM	T1,LDBTTD##(U)	;IT ALSO CLEARED AUTO-XOFF ENABLE
	PJRST	SETCHP##	;EXIT, WILL SEND ENABLE AUTO-XOFF AT TTDCHP

;ROUTINE TO FIND CODED VALUE OF LINE SPEED IN BAUD
;ARGS:	T1/SPEED IN BAUD
;CALL:	PUSHJ	P,FNDSPD
;	RETURN HERE, CODED VALUE IN T1

FNDSPD:	MOVSI	T2,-LSPLEN##	;MAKE AOBJN POINTER
	CAME	T1,LSPTAB##(T2)	;IS THIS THE SPEED?
	AOBJN	T2,.-1		;NO, TRY NEXT ONE
	SKIPL	T2		;MAYBE, POINTER STILL VALID?
	MOVEI	T2,0		;NO, INVALID SPEED, BUT SAY 0
	HRRZ	T1,T2		;PUT CODE IN T1
	POPJ	P,
SUBTTL	HANDLE DATASET(S) ANSWERED

;HERE FROM DTESER WHEN A DATASET WAS ANSWERED BY RSX-20F

TTDDWA:	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;COULDN'T, IGNORE THIS MESSAGE
TTDDW1:	SUBI	P3,2		;ACCOUNT FOR TWO BYTES/ARGUMENT
	JUMPL	P3,CPOPJ##	;RETURN WHEN COUNT EXHAUSTED
	ILDB	U,P4		;GET DLS LINE NUMBER

;ZERO THE LINE'S SPEED BYTES SO THAT INITIA WON'T GET A MISTAKEN NOTION AS TO
;WHAT THIS LINE'S SPEED IS.  RSX20F SHOULD BE COMING ALONG SOON TO TELL US WHAT
;THE SPEED REALLY IS.  THIS IS WORKING ON THE ASSUMPTION THAT ALL RSX20F
;DIALUPS ARE ALSO AUTOBAUD DETECT LINES, WHICH IS CURRENTLY THE CASE.  SHOULD
;THIS EVER CHANGE ...

	PUSHJ	P,DLSMON	;CONVERT TO MONITOR LINE NUMBER IN U
	  PJRST	EATMSG##	;OUT OF RANGE, IGNORE THIS MESSAGE
	MOVE	U,LINTAB##(U)	;GET LDB ADDRESS
	SE1ENT			;ENTER SECTION 1
	SETZ	T1,		;GET LINE SPEED BYTE FOR ZERO
	DPB	T1,LDPRSP##	;SAVE IN LDB
	DPB	T1,[POINT 4,LDBTTD##(U),3] ;REMEMBERED SPEED
	DPB	T1,LDPTSP##	;SAVE IN LDB
	DPB	T1,[POINT 4,LDBTTD##(U),7] ;REMEMBERED SPEED
	MOVSI	T1,LTLACK##	;MAKE SURE WE AREN'T WAITING
	ANDCAM	T1,LDBTTD##(U)	; FOR AN ACK ON THIS LINE
	LDB	U,P4		;GET THE DLS LINE NUMBER AGAIN
	IBP	P4		;MOVE PAST UNUSED BYTE
	PUSHJ	P,TTDCDD	;CONVERT DLS LINE # TO DSCTAB INDEX
	  JRST	TTDDW1		;OUT OF RANGE, LOOP FOR NEXT ARGUMENT
	MOVEI	T3,DSTRNG##	;GET CODE FOR PHONE RANG
	PUSHJ	P,DSCREC##	;CALL SCNSER
	MOVEI	T3,DSTON##	;RSX-20F ALREADY HAS DATASET ON
	PUSHJ	P,DSCREC##	;TELL SCNSER
	JRST	TTDDW1		;LOOP FOR NEXT ARGUMENT


SUBTTL	HANDLE DATASET(S) HUNG UP

;HERE FROM DTESER ON DATASET(S) HUNG UP

TTDDHU:	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;COULDN'T, IGNORE THIS MESSAGE
TTDDH1:	SUBI	P3,2		;ACCOUNT FOR TWO BYTES/ARGUMENT
	JUMPL	P3,CPOPJ##	;RETURN IF COUNT EXHAUSTED
	ILDB	U,P4		;GET DLS LINE NUMBER
	IBP	P4		;MOVE PAST UNUSED BYTE
	PUSHJ	P,TTDCDD	;CONVERT DLS LINE # TO DSCTAB INDEX
	  JRST	TTDDH1		;OUT OF RANGE, LOOP FOR NEXT ARGUMENT
	MOVEI	T3,DSTOFF##	;GET CODE FOR DATASET OFF
	PUSHJ	P,DSCREC##	;TELL SCNSER
	JRST	TTDDH1		;LOOP FOR NEXT ARGUMENT
SUBTTL	RECEIVE LINE DATA FROM RSX-20F

;HERE TO HANDLE CHARACTER DATA FOR DLS LINES
;THIS ROUTINE PROCESSES "MULTIPLEXED" INPUT (DATA,LINE,DATA,LINE,...)

DLSLND:	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;COULDN'T, IGNORE THIS MESSAGE
DLSLN1:	SUBI	P3,2		;DECREMENT COUNT BY 2
	JUMPL	P3,CPOPJ##	;RETURN IF DONE
	ILDB	T3,P4		;GET DATA
	ILDB	U,P4		;GET DLS LINE NUMBER
	PUSHJ	P,DLSMON	;CONVERT TO MONITOR LINE NUMBER IN U
	  JRST	DLSLN1		;OUT OF RANGE, LOOP FOR NEXT ARGUMENT
	PUSHJ	P,GIVLND	;GIVE CHARACTER TO SCNSER
	JRST	DLSLN1		;LOOP FOR MORE



;HERE TO HANDLE CHARACTER DATA FOR CTY

CTYLND:	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;COULDN'T, IGNORE THIS MESSAGE
	HRRZ	U,.CPCTN##	;GET CTY LINE NUMBER
CTYLN1:	SUBI	P3,2		;ACCOUNT FOR TWO BYTES/ARGUMENT
	JUMPL	P3,CPOPJ##	;RETURN IF COUNT EXHAUSTED
	ILDB	T3,P4		;GET DATA
	IBP	P4		;FIX UP POINTER
	PUSHJ	P,GIVLND	;GIVE CHARACTER TO SCNSER
	JRST	CTYLN1		;LOOP FOR ANY MORE



;HERE TO HAND THE CHARACTER TO SCNSER, CHECK TO XOFF HANDLED BY -20F

GIVLND:	SE1ENT			;ENTER SECTION 1
	MOVE	U,LINTAB##(U)	;GET LDB ADDRESS
	ANDI	T3,CK.CHR	;KEEP ONLY CHARACTER
	MOVE	T1,T3		;COP CHARACTER
	SKIPL	LDBATR##(U)	;EIGHT-BIT TERMINAL?
	ANDI	T1,CK.CH7	;NO, KEEP ONLY ASCII PART
	CAIE	T1,"S"-100	;INCOMING XOFF
	CAIN	T1,"Q"-100	;OR XON
	 CAIA			;YES, DO SOME CHECKING
	PJRST	RECPTY##	;NO, GIVE IT TO SCNSER
	MOVSI	T2,LTLAXF##	;HAVE WE ENABLED AUTO-XOFF YET
	TDNN	T2,LDBTTD##(U)	;DON'T SAY -20F STOPPED IF IT DIDN'T
	 JRST	GIVLN1		;
	MOVSI	T2,LTLXOF##	;BIT SAYING WE TOLD -20F TO STOP OUTPUT
	CAIN	T1,"S"-100	;XOFF?
	IORM	T2,LDBTTD##(U)	;MARK SINCE IT DID IT ITSELF
	CAIN	T1,"Q"-100	;XON?
	ANDCAM	T2,LDBTTD##(U)	;CLEAR SINCE IT DID IT ITSELF
	PUSHJ	P,SETCHP##	;COME BACK AND CHECK IF XOFF/XON IS A DATA CHAR
GIVLN1:	PJRST	RECPTY##	;NOW GIVE THE XOFF/XON TO SCNSER
SUBTTL	PROCESS NORMAL ACK MESSAGE FOR TERMINALS

;HERE TO PROCESS ACK MESSAGE FOR DLS LINES

DLSACK:	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;COULDN'T, IGNORE THIS MESSAGE
DLSAC1:	SUBI	P3,2		;DECREMENT COUNT BY 2
	JUMPL	P3,CPOPJ##	;RETURN WHEN COUNT EXHAUSTED
	ILDB	U,P4		;GET DLS LINE NUMBER
	IBP	P4		;MOVE PAST UNUSED BYTE
	PUSHJ	P,DLSMON	;GET MONITOR LINE NUMBER IN U
	  JRST	DLSAC1		;OUT OF RANGE, LOOP FOR NEXT ARGUMENT
	PUSHJ	P,PRCACK	;ACK THE LINE
	JRST	DLSAC1		;LOOP FOR NEXT ARGUMENT



;HERE FROM DTESER ON ACK MESSAGE FOR CTY

CTYACK:	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;COULDN'T, IGNORE THIS MESSAGE
CTYAC1:	SUBI	P3,2		;ACCOUNT FOR TWO BYTES/ARGUMENT
	JUMPL	P3,CPOPJ##	;RETURN WHEN COUNT EXHAUSTED
	ILDB	T1,P4		;GET DLS LINE NUMBER
	IBP	P4		;MOVE PAST UNUSED BYTE
	HLRZ	U,.CPCTN##	;GET CTY DLS LINE NUMBER
	CAME	T1,U		;IS THIS IT?
	JRST	CTYAC1		;NO, LOOP FOR NEXT ARGUMENT
	HRRZ	U,.CPCTN##	;GET -10 LINE NUMBER
PRCACK:	SE1ENT			;ENTER SECTION 1
	MOVE	U,LINTAB##(U)	;GET LDB ADDRESS
	MOVSI	T1,LTLACK##	;WAITING FOR ACK
	ANDCAM	T1,LDBTTD##(U)	;NOT ANYMORE
	PJRST	TOREQ##		;GET LINE STARTED AGAIN
SUBTTL	ACK ALL PROCESSING FOR RSX-20F TERMINALS

;HERE TO HANDLE ACK ALL MESSAGE FOR DLS LINES

DLSAAL:	SE1ENT			;ENTER SECTION 1
	PUSHJ	P,CHKP1		;CHECK P1 FROM DTESER
	  PJRST	EATMSG##	;COULDN'T, IGNORE THIS MESSAGE
	PUSHJ	P,SAVE3##	;SAVE DTESER'S ACS
	MOVE	P1,.CPCPN##	;GET CPU NUMBER
	MOVE	P2,TTDOFS##(P1)	;GET STARTING LINE NUMBER FOR TTD GROUP
	MOVSI	P3,LTLACK##	;WAITING FOR ACK
DLSAA1:	CAML	P2,TTDLOM##(P1)	;STILL IN THIS TTD GROUP?
	PJRST	DLSAA2		;NO, ACK CTY AND RETURN
	MOVE	U,LINTAB##(P2)	;YES, GET LDB ADDRESS
	ANDCAM	P3,LDBTTD##(U)	;SIGNAL LINE ACK'ED
	PUSHJ	P,TOREQ##	;KICK THE LINE
	AOJA	P2,DLSAA1	;LOOP FOR NEXT LINE
DLSAA2:	HRRZ	U,.CPCTN##	;GET CTY LINE NUMBER
	MOVE	U,LINTAB##(U)	;GET LDB ADDRESS
	ANDCAM	P3,LDBTTD##(U)	;SIGNAL LINE ACK'ED
	PJRST	TOREQ##		;EXIT, GIVING THE LINE A KICK
SUBTTL	ONCE A SECOND ROUTINES

;HERE ONCE A SECOND (CALLED THROUGH ISRCHK DISPATCH)

TTDSEC:	PUSHJ	P,SKPMPP##	;RUNNING PRIMARY PROTOCOL
	  POPJ	P,		;NO, WAIT UNTIL WE ARE
	PUSHJ	P,SAVE4##	;SAVE NOW IN CASE WE NEED THEM
	MOVSI	T2,F20LPP	;DID WE SWITCH PROTOCOL AND BACK AGAIN
	TDNN	T2,.CP20F##	; SET BY SVPPC
	JRST	TTDSE1		;NO, GO CHECK OUT DATASETS
	ANDCAM	T2,.CP20F##	;YES, CLEAR BIT
	HRLZ	P1,.CPCPN##	;GET CPU,,0 FOR DTEQUE
	MOVEI	P2,EM.IND+.EMSNA ;THIS IS A SEND ALL
	MOVEI	P3,CONSIZ	;SIZE OF CONTINUED MESSAGE
	MOVE	P4,[POINT 8,CONMSG] ;POINT TO THE MESSAGE
	SETZ	S,		;NO POST ADDRESS
	SKIPL	DEBUGF##	;DON'T BOTHER IF DEBUGGING
	S0PSHJ	DTEQUE##	;TELL TERMINAL USERS WE ARE NOT "NOT RUNNING"
	  JFCL			;IGNORE ERRORS HERE
TTDSE1:	MOVSI	P1,F20SDT	;DOES DTESER WANT US TO TELL
	TDNE	P1,.CP20F##	;THE FRONT-END ABOUT A DATE TIME CHANGE?
	PUSHJ	P,DTEDTM##	;YES, DO SO
	ANDCAM	P1,.CP20F##	;AND CLEAR THE FLAG
	MOVEI	T1,ST.NRL	;GET BIT FOR NO REMOTE LOGINS
	MOVSI	T2,F20ADS	;ANSWER DATASET FLAG
	TDNE	T1,STATES##	;REMOTE LOGINS ALLOWED?
	JRST	[TDNN T2,.CP20F## ;IS -20F ANSWERING DATASETS
		 JRST TTDSE3	;NO, DO NEXT THING IN SECOND CODE
		 ANDCAM T2,.CP20F## ;CLEAR FLAG THAT WE TOLD -20F ITS OK
		 JRST TTDSE2]	;AND TELL IT TO STOP ANSWERING
	TDNE	T2,.CP20F##	;IS -20F ANSWERING DATASETS
	JRST	TTDSE3		;YES, GO ON TO NEXT THING
	IORM	T2,.CP20F##	;MARK THAT WE TOLD IT TO ANSWER
	TDZA	P3,P3		;ZERO MEANS ENABLE TO ANSWER DATASETS
TTDSE2:	MOVEI	P3,1		;NON-ZERO MEANS DON'T ANSWER DATASETS
	HRLZ	P1,.CPCPN##	;GET CPU,,0 FOR DTEQUE
	MOVE	P2,[.EMDH1,,.EMEDR];ENABLE/DISABLE DATASETS FOR DH11 LINES
	SETZB	P4,S		;NO BYTE POINTER OR POST ROUTINE
	S0PSHJ	DTEQUE##	;QUEUE THE REQUEST
	  JFCL			;IGNORE ANY FAILURE
TTDSE3:	POPJ	P,		;DONE WITH ONCE-A-SECOND CODE FOR NOW
SUBTTL	COMMON SUBROUTINES FOR TTDINT

;ROUTINE TO CHECK P1 AS SUPPLIED BY DTESER FOR VALID -20F DTE
;ARGS:	P1/CPU,,DTE (FROM DTESER)
;CALL:	PUSHJ 	P,CHKP1
;	  RETURN HERE IF NOT A -20F FRONT END
;	RETURN HERE IF IT IS

CHKP1:	HRLZ	T1,.CPCPN##	;GET THIS CPU,,0
	CAMN	T1,P1		;THIS IT
	AOS	(P)		;YES, OK TO PROCEED
	POPJ	P,		;NO, IGNORE CALL


;ROUTINE TO SET UP FOR CALL TO DTEQUE FOR DLS LINE FUNCTIONS
;ARGS:	U/LDB ADDRESS  (ENTER AT STDT1 IF P3 IS ALREADY THE LINE NUMBER)
;CALL:	PUSHJ	P,STDTQ
;	ALWAYS RETURNS HERE WITH
;		P1/CPU # ,, DTE #
;		P2/.EMDLS ,, <UNCHANGED>
;		P3/DLS # ,, 0
;		P4/ 0
;		S/  0

STDTQ:	LDB	P3,LDPLNO##	;GET -10 LINE NUMBER
STDT1:	MOVE	P1,.CPCTN##	;GET DLS,,-10 LINE NUMBERS FOR CTY ON THIS CPU
	CAIE	P3,(P1)		;IS THIS THE CTY
	JRST	STDT2		;NO, WORK HARDER
	HLLZ	P3,P1		;GET DLS # ,, 0
	JRST	STDT3		;FINISH UP AND RETURN
STDT2:	MOVE	P4,.CPCPN##	;GET CPU NUMBER
	SUB	P3,TTDOFS##(P4)	;CONVERT TO A DLS LINE ON THIS CPU
	HLRZS	P1		;ISOLATE CTY LINE NUMBER
	CAIL	P3,(P1)		;LINE BELOW THE CTY
	AOS	P3		;NO, ACCOUNT FOR THE HOLE
	HRLZS	P3		;POSITION THE ANSWER
STDT3:	HRLZ	P1,.CPCPN##	;GET CPU,,0 FOR DTEQUE
	HRLI	P2,.EMDLS	;SET LH P2 = DLS FUNCTION
	SETZB	P4,S		;CLEAR BYTE POINTER AND POST ADDRESS
	POPJ	P,		;AND RETURN
;ROUTINE TO CONVERT DLS LINE # TO DSCTAB INDEX AND RANGE CHECK
;ARGS:	U/DLS LINE NUMBER
;CALL:	PUSHJ	P,TTDCDD
;	  RETURN HERE IF OUT OF RANGE OR CTY ( NOT IN DSCTAB )
;	RETURN HERE IF VALID, DSCTAB INDEX IN U

TTDCDD:	PUSHJ	P,DLSMON	;FIRST, CONVERT TO -10 LINE NUMBER
	  POPJ	P,		;OUT OF RANGE
	PUSH	P,T1		;SAVE T1
	HRRZ	T1,.CPCTN##	;GET CTY FOR THIS CPU
	CAIN	T1,(U)		;THIS IT
	JRST	TPOPJ##		;YES, CTY'S ARE NOT IN DSCTAB, OUT OF RANGE
	MOVEI	U,TTDDSO##(U)	;ADJUST FOR DSCTAB
	JRST	TPOPJ1##	;AND RETURN



;ROUTINE TO CONVERT DLS LINE NUMBER TO MONITOR LINE NUMBER AND RANGE CHECK
;ARGS:	U/DLS LINE NUMBER
;CALL:	PUSHJ	P,DLSMON
;	  RETURN HERE IF LINE NUMBER OUT OF RANGE
;	RETURN HERE, MONITOR LINE NUMBER IN U

DLSMON:	PUSH	P,T1		;SAVE ALL
	MOVS	T1,.CPCTN##	;GET -10 LINE NUMBER,,DLS LINE NUMBER
	CAIN	U,(T1)		;IS THIS CTY ON THIS CPU
	JRST	DLSMN1		;YES
	CAIL	U,(T1)		;IS THIS LINE BELOW CTY#
	SOS	U		;NO, COMPENSATE FOR HOLE
	MOVE	T1,.CPCPN##	;GET CPU WE ARE ON
	ADD	U,TTDOFS##(T1)	;ADD TO START OF LINES ON THIS CPU
	CAMGE	U,TTDLOM##(T1)	;IN RANGE?
	AOS	-1(P)		;YES, GIVE GOOD RETURN
	JRST	TPOPJ##		;RESTORE T1 AND RETURN
DLSMN1:	HLRZ	U,T1		;GET CTY LINE NUMBER
	JRST	TPOPJ1##	;AND TAKE GOOD RETURN


	END

    (.l,