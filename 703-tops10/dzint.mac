TITLE	DZINT	-- INTERRUPT SERVICE FOR DZ11 - V014
SUBTTL	Dave McClure/DMcC/DBD/TL 10 SEP 85

	SEARCH	F,S
	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<1978,1986>
;COPYRIGHT (C) 1978,1979,1980,1982,1984,1986
;BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;ALL RIGHTS RESERVED.

;
XP VDZINT,014

	ENTRY	DZINT		;LOAD DZINT IF LIBRARY SEARCH
DZINT:
	SUBTTL	DISPATCH TABLE

DZDSP::JRST	SCNTYP		;DATA OUT
	JRST	DSCTYP		;DATA SET CONTROL

	JRST	DZSEC		;CALLED ONCE A SECOND
				; CHECK INTERRUPT ENABLES
				; AND DO DATASET TIMING
	JRST	DZINI		;INIT
	JRST	DZCHP		;CHANGE HARDWARE PARAMETERS
	POPJ	P,		;SET LINE PARAM CTRL MSG
	POPJ	P,		;SET ELEMENT
	POPJ	P,		;REMOTE STATION STUFF
	JRST	DZOFL		;OFF LINE TEST
IFE 1,<
DSCOFS==DSCOF'N##		;OFFSET INTO DSCTAB
DLSMXD==DL'N'MXD##		;MAX LINE NUMBER
DLSMXL==DL'N'MXL##		;MAXIMUM DATASET NUMBER
DLSOFS==DL'N'OFS##		;OFFSET FROM HARDWARE TO LINTAB
>;IFE 1
	SUBTTL	DZ11 HARDWARE DEFINITIONS

;DZ11 OFFSETS INTO DEVICE DEFINITIONS

DZCSR==0			;CONTROL AND STATUS
DZRBUF==2			;RECEIVER BUFFER
DZLPR==2			;LINE PARAMETER REGISTER
DZTCR==4			;TRANSMIT CONTROL
DZDTR==5			;DATA TERM READY FLAGS (HIGH BYTE OF TCR
DZRNG==6			;RING INDICATOR
DZMSR==6			;COMBINATION OF RING AND CARRIER
DZCAR==7			;CARRIER
DZTBUF==6			;TRANSMITTER BUFFER
DZBRK==7			;BREAK (HIGH OF TBUF)

;CSR BIT DEFINITIONS

DZTRDY==1B20			;TRANSMIT READY
DZTIEN==1B21			;TRANSMIT INTERRUPT ENABLE
DZSILO==1B22			;SILO ALARM
DZSIEN==1B23			;SILO ALARM ENABLE
DZTXLN==7B27			;TRANSMIT LINE NUMBER
DZRRDY==1B28			;RECEIVE READY
DZRIEN==1B29			;RECIEVE INTERRUPT ENABLE
DZMSCN==1B30			;MASTER SCAN ENABLE
DZCLR==1B31			;CLEAR (RESET)

;RECEIVER BUFFER DEFINITIONS

DZRDVL==1B20			;DATA VALID
DZROVR==1B21			;OVER RUN
DZRFRM==1B22			;FRAME ERROR
DZRPAR==1B23			;PARITY ERROR
DZRLIN==7B27			;LINE NUMBER

;LINE PARAMETER DEFINITIONS

DZ1RXO==1B23			;RECEIVE ON
DZ1FRQ==17B27			;LINE FREQUENCY
	;0B27			;50 BAUD
	;1B27			;75 BAUD
	;2B27			;110 BAUD
	;3B27			;134.5 BAUD
	;4B27			;150 BAUD
	;5B27			;300 BAUD
	;6B27			;600 BAUD
	;7B27			;1200 BAUD
	;10B27			;1800 BAUD
	;11B27			;2000 BAUD
	;12B27			;2400 BAUD
	;13B27			;3600 BAUD
	;14B27			;4800 BAUD
	;15B27			;7200 BAUD
	;16B27			;9600 BAUD
	;17B27			;NOT USED
DZ1OPA==1B28			;ODD PARITY
DZ1PEN==1B29			;PARITY ENABLE
DZ1STP==0B30			;STOPCODE 1 BIT
DZ2STP==1B30			;STOPCODE 2 BITS
DZ1CHL==3B32			;CHARACTER LENGTH
	;0B32			;5 LEVEL
   DZ6BIT==1B32			;6BIT CHARACTER DEFINITION
	;2B32			;7 LEVEL
   DZ8BIT==3B32			;8BIT CHARACTER DEFINITION
DZ1LNO==7B35			;LINE NUMBER
	SUBTTL	INITIALIZATION CODE

;DEVICE-DEPENDENT PORTION OF INITIALIZATION CODE
; CALLED BY SYSINI WITH LINE NUMBER IN J

DZINI:	PUSHJ	P,SAVE3##	;SAVE P1 - P3
	MOVE	P1,[DZ11BA-10]	;BASE ADDRESS FOR DZ11'S
	HRRZ	P2,.EPVIT##-1+<DZ11BA/1000000> ;ADR OF VECTOR TABLE
	ADDI	P2,<DZ11IV/4>	;FIRST DZ11 VECTOR
	HRLI	P2,DZ0VA##	;FIRST DZ11 INTERRUPT ROUTINE
	SETZM	P3		;WILL BE DZMAXL
DZINI2:	TRNE	P3,7		;FIRST LINE ON THIS DZ11 ?
	  JRST	DZINI4		;NO SO HAVE ALREADY CLEARED IT
	ADDI	P1,10		;NEXT DZ11 ADDRESS
	MOVE	T1,P1		;FOR CALL TO UBGOOD
	PUSHJ 	P,UBGOOD##	;SEE IF THAT DZ11 EXISTS
	  JRST	DZINI8		;HAVE DONE ALL LEGAL ONES
	LDB	T1,[POINT 6,P3,32] ;GET DZ11 UNIT NUMBER
	SETZM	DZDSTB##(T1)	;INITIALIZE THE DATASET TABLE
	MOVEI	T1,DZCLR	;TO MASTER CLEAR THE DZ11
	WRIO	T1,DZCSR(P1)	;CLEAR THE DZ11
	MOVSI	T2,1		;STALL COUNTER
	TIOE	T1,DZCSR(P1)	;DID INITIALIZE CLEAR YET ?
	SOJG	T2,.-1
	JUMPLE	T2,DZINI8	;DZ11 IS BAD
	MOVSI	T1,(XPCW)	;BUILD JSR DZ#VA

	MOVE	T2,T1		;BUILD JSR DZ#VB
	HLR	T1,P2		;ADD DZ#VA
	HRRI	T2,14(T1)	;ADD DZ#VB
	DMOVEM	T1,(P2)		;ADD JSR'S TO INTERRUPT TABLE
	ADD	P2,[30,,2]	;SO NEXT SET OF JSR'S ARE RIGHT
	MOVEI	T1,DZTIEN!DZRIEN!DZMSCN ;TRANS & RECV INT ENABLE
	WRIO	T1,DZCSR(P1)	; AND MASTER SCAN ENABLE
DZINI4:	SETZM	DZCHTB(P3)	;CLEAR OUTPUT WORD FOR LINE
	SETZM	DZMSTS##(P3)	;CLEAR DATASET QUEUE WORD
	MOVEI	T1,1		;BIT FOR DATA TERMINAL READY
	MOVE	T2,P3		;COPY LINE NUMBER
	ANDI	T2,7		;LEAVE ONLY RELATIVE LINE NUMBER
	LSH	T1,(T2)		;MAKES RIGHT BIT FOR DTR
	PUSH	P,T1		;SAVE BIT
	MOVE	T1,LINTAB##(P3)	;GET LDB ADDRESS
	MOVE	T1,LDBDCH(T1)	;GET CHAR BITS
	TRNE	T1,LDRDSD##	;DATASET LINE?
	 JRST	[POP	P,T1	;YES, RESTORE LINE BIT
		 BCIOB	T1,DZDTR(P1) ;AND PREVENT DATASET FROM ANSWERING
		 MOVSI	T1,DZMABL ;MAKE ALL DATASET LINES
		 IORM	T1,DZMSTS##(P3) ;BE AUTOBAUD LINES
		 IORI	T2,DZ1RXO!12B27!DZ8BIT; RCV ON, 2400
		 JRST	DZINI5]	;DONE WITH DATASET CASE
	POP	P,T1		;LOCAL LINE, WE WANT TO SET DTR NOW
	BSIOB	T1,DZDTR(P1)	;SET DATA TERMINAL READY FOR THIS LINE
	IORI	T2,DZ1RXO!5B27!DZ8BIT ;RECEIVER ON, 300 BAUD,
DZINI5:	WRIO	T2,DZLPR(P1)	; 1 STOP BIT, 8BIT CHARS
	AOS	P3		;HAVE SETUP NEXT LINE
	CAIE	P3,M.DZNL##	;HAVE WE DONE ALL LINES WE SHOULD ?
	JRST	DZINI2		;DO NEXT LINE
DZINI8:	MOVEM	P3,DZMAXL	;SAVE NUMBER OF DZ11 LINES
	SETZM	DZLIEN		;INITALIZE ERROR COUNTER
	POPJ	P,0		;RETURN FROM DZINI
	SUBTTL	CHECK TO SEE IF DZ11 IS OFFLINE

;HERE TO SEE IF DZ11 IS "OFFLINE" = NO DZ11 FOR LINE
; CALLED WITH U POINTING TO LDB
DZOFL:	LDB	T1,LDPLNO##	;GET LINE NUMBER
	CAMGE	T1,DZMAXL	;IN RANGE ?
	AOS	(P)		;YES SO IS "ONLINE"
	POPJ	P,0
	SUBTTL	ONCE A TICK ROUTINE

;HERE ONCE A TICK TO START OUTPUT
DZSTO::	PUSH	P,T1		;SAVE QUEUE POINTER ADDRESS
DZST1:	PUSHJ	P,TOTAKE##	;ANYTHING TO TYPE?
	 JRST	DZQTIC		;NO--TIME DATASETS
	MOVEI	T1,L1RCHP##
	TDNE	T1,LDBBYT##(U)	;IS CHP SET?
	PUSHJ	P,DZCHP		;YES--GO SET SPEED
	MOVEI	T1,L1RCHP##
	ANDCAM	T1,LDBBYT##(U)	;CLEAR CHP BIT
	SKIPGE	LDBDCH##(U)	;DON'T START AN ACTIVE LINE
	PUSHJ	P,XMTCHR##	;ANY CHARS FOR THIS LINE?
	  JRST	DZST2		;NO--GO TO NEXT
	PUSHJ	P,SCNTYP	;START LINE
	PUSHJ	P,CLRIRM##	;CLEAR IRMA
DZST2:	MOVE	T1,(P)		;RESTORE QUEUE POINTER ADDRESS
	JRST	DZST1		;GO SEE IF MORE TO DO

	;HERE ONCE A TIC TO TIME DATASETS

DZQTIC:	POP	P,T1		;RESTORE T1
	SKIPG	DZTTQN##	;ANY LINES IN OUR QUEUE?
	 POPJ	P,		;NO, DONE
	PUSHJ	P,SAVE4##	;SAVE A REGISTER
	PUSHJ	P,SAVT##
	PUSH	P,U
	SETZ	P1,		;START AT BEGINNING
DZQTC1:	CAML	P1,DZMAXL	;DONE (DON'T PAGEFAIL ON NX DZ!)
	 JRST	UPOPJ##		;YES, DONE WITH TIC PROCESSING
	SCNOFF			;STOP WORLD
	LDB	T1,DZQPTM	;GET TIME TO GO
	SOSL	T1		;COUNT DOWN
	 DPB	T1,DZQPTM	; MORE TO GO, PUT TIME LEFT BACK
	JUMPN	T1,[SCNON	;EXIT IF NOTHING TO DO YET
		    JRST  DZQTC2] ;NEXT LINE...
	HRRZ	T1,DZMSTS##(P1)	;TIME'S UP, GET ROUTINE TO CALL
	HLLZS	DZMSTS##(P1)	;CLEAR ROUTINE, SAVE STATUS
	SOS	DZTTQN##	;REMOVED 1 ENTRY
	SCNON			;QUEUE IS FREE
	SKIPN	T1		;IS ROUTINE LEGAL?
	 STOPCD	DZQTC2,DEBUG,DQR,	;++ILLEGAL QUEUE ROUTINE
	MOVE	U,LINTAB##(P1)	;FIND LDB FOR THIS LINE
	PUSHJ	P,(T1)		;CALL ROUTINE
DZQTC2:	SKIPE	DZTTQN##	;MORE TO DO?
	 AOJA	P1,DZQTC1	;YES, DO NEXT LINE
	JRST	UPOPJ##		;NO, EXIT
	SUBTTL	ONCE A SECOND SERVICE FOR DZ11'S

;HERE ONCE A SECOND
; CHECK DZ11 FOR INTERRUPT ENABLES
; CHECK DZ11 FOR DATASET LINES
DZSEC:	PUSHJ	P,SAVE3##	;SAVE P1, P2, AND P3
	SETZ	P1,		;LINE NUMBER
	MOVE	P2,[DZ11BA-10]	;ADDRESS OF FIRST DZ11
	MOVEI	P3,DZDSTB##-1	;DATASET TABLE FOR DZ11
SCNCK1:	CAML	P1,DZMAXL	;DONE ALL LINES YET ?
	POPJ	P,0		;RETURN TO CLOCK
	TRNE	P1,7		;FIRST LINE IN GROUP ?
	  JRST	SCNCK3
	ADDI	P2,10		;NEXT DZ11 ADR
	AOS	P3		;NEXT DATASET WORD
	RDIO	T1,DZMSR(P2)	;GET MODEM STATUS REGISTER
	HRL	T1,(P3)		;GET OLD DATASET STATUS
	TLC	T1,(T1)		;LH IS NEW.XOR.OLD
	MOVEM	T1,(P3)		;SAVE IT
	RDIO	T1,DZCSR(P2)	;GET CONTROL AND STATUS REGISTER
	TRNE	T1,DZTIEN	;STILL HAVE TRANSMIT ENABLE ?
	TRNN	T1,DZRIEN	;AND RECEIVE ENABLE ?
	  JRST [MOVEI T1,DZTIEN!DZRIEN ;BOTH ENABLES
		BSIO T1,DZCSR(P2) ;RESET ENABLES
		AOS DZLIEN	;COUNT TIMES THEY DROP
		JRST SCNCK3 ]
SCNCK3:	MOVE	U,LINTAB##(P1)	;GET LDB FOR LINE
	MOVE	T1,LDBDCH##(U)	;GET DEVICE BITS
	TRNN	T1,LDRDSD##	;IS THIS A DATASET LINE ?
	  JRST	SCNCK8		;NOT DATASET SO DONE WITH LINE
	MOVE	T1,P1		;COPY LINE NUMBER
	ANDI	T1,7		;LEAVE RELATIVE LINE NUMBER
	MOVE	T2,[401,,401]	;BITS FOR MASK
	LSH	T2,(T1)		;MAKE MASK FOR CARRIER ETC.
	AND	T2,(P3)		;LEAVE ONLY BITS FOR THIS LINE
	TLNN	T2,-1		;DID ANYTHING CHANGE FOR THIS LINE ?
	  JRST	SCNCK8		;NO
	TLNN	T2,377*400	;DID CARRIER CHANGE ?
	  JRST	SCNCK6		;RING CHANGED
	TRNE	T2,377*400	;DID CARRIER GO AWAY ?
	 JRST	SCNCKO		;NO, CARRIER ON
	JRST	SCNCKF		;YES, CARRIER OFF

;HERE WHEN RING CHANGED
SCNCK6:	TRNN	T2,377*400	;IS CARRIER ON ?
	TRNN	T2,377		;IS RING ON NOW ?
	  JRST	SCNCK8		;NOT INTERESTING
	;THE ABOVE IGNORES RING UNLESS 0-1 RING AND CARRIER = 0
	;NOTE THAT IF A MUX THINKS IT CAN JUST PULSE RING
	;WITHOUT DROPPING CARRIER, WE CAN BE FOOLED.
	JRST	SCNCKR		;PROCESS THE RING
SCNCK8:	AOJA	P1,SCNCK1	;ON FOR NEXT LINE
	SUBTTL	ROUTINES FOR DATASET CONTROL

;THIS CODE CREATES A SMALL FRONT END FOR THE KS, AND ONLY TELLS
;SCNSER ABOUT RING, CARRIER AFTER THE ACTION IS OVER.
;
;WE ARE CALLED AT CLOCK LEVEL BY THE ONCE/SECOND DATASET POLL,
;AND BY THE ONCE/TIC EVENT TIMER IN DZQTIC

;OUR IDEA OF LINE STATUS IS KEPT IN THE LH OF DZMSTS

	;BITS IN THE LH OF DZMSTS
	DZMABL==(1B0)	;AUTOBAUD LINE
	DZMCRW==(1B1)	;IN CARRIER WAIT
	DZMABW==(1B2)	;IN AUTOBAUD WAIT
	DZMABF==(1B3)	;AUTOBAUD COMPLETE, FLUSHING DZ SILO FOR THIS LINE
	DZMCON==(1B4)	;CARRIER IS ON
	;BIT 5 IS FREE
	;BITS 6-17 ARE TIME FIELD (MAX = 4095 TICS, OR APPROX 1 MIN @ 60HZ)

DZQPTM:	POINT	12,DZMSTS##(P1),17	;POINTER TO TIME FIELD

;HERE ON A RING TRANSITION

SCNCKR:	MOVSI	T2,DZMCON	;WAS CARRIER ON?
	TDNE	T2,DZMSTS##(P1)	;...
	 JRST	[PUSHJ	P,REPCOF ;YES, BETTER TELL SCNSER
		 JRST	SCNCK8]	;...
	MOVEI	T2,1		;START WITH LINE 0
	LSH	T2,(T1)		;POSITION TO CORRECT LINE
	MOVEI	T1,ST.NRL	;ALLOWED TO ANSWER?
	TDNE	T1,STATES##	;...
	 JRST	SCNCK8		;NO, IGNORE RING
	BSIOB	T2,DZDTR(P2)	;ANSWER THE PHONE
	MOVSI	T1,DZMCRW	;IN CARRIER WAIT
	IORM	T1,DZMSTS##(P1)	;FOR NOW
	MOVE	T1,[CRWTMO,,^D<20K>] ;WAIT 20 SECONDS FOR CARRIER
	PUSHJ	P,DZQADD	;ADD TO QUEUE
	JRST	SCNCK8		;DONE WITH THIS LINE

;HERE IF CARRIER DOESN'T APPEAR, OR AUTOBAUD FAILS

CRWTMO:	PUSHJ	P,DZUADR	;GET UNIBUS ADDRESS
	BCIOB	T1,DZDTR(T2)	;HANG UP
REPCOF:	MOVSI	T1,DZMCON!DZMCRW!DZMABW!DZMABF ;GET STATUS BITS
	ANDCAM	T1,DZMSTS##(P1)	;CAN'T BE PROCESSING A CALL
	MOVE	U,P1		;SET UP U
	MOVEI	T3,DSTOFF##	;CODE FOR CARRIER WENT AWAY
	PJRST	DSCREC##	;BETTER TELL SCNSER
;HERE WHEN CARRIER COMES ON

SCNCKO:	MOVSI	T2,DZMCON	;CARRIER ON BIT
	IORM	T2,DZMSTS##(P1)	;SET IT
	MOVSI	T2,DZMCRW	;IN CARRIER WAIT?
	TDNN	T2,DZMSTS##(P1)	;...
	 JRST	[MOVEI	T3,DSTON## ;NO, BETTER TELL SCNSER
		 JRST	SCNDST]
	.CREF	DZMABL
	SKIPL	DZMSTS##(P1)	;AUTOBAUD LINE?
	 JRST	[MOVE	T1,[DZCXUP,,^D<2K>] ;NO, WAIT 2 SEC FOR CARRIER
		 PUSHJ	P,DZQADD	;TO BECOME SOLID
		 JRST	SCNCK8]		;THEN TELL SCNSER
	MOVE	T1,P1		;COPY LINE NUMBER
	ANDI	T1,7		;ONLY WITHIN DZ
	IORI	T1,DZ1RXO!12B27!DZ1STP!DZ8BIT ;TURN ON RECEIVER AT 2400 BAUD
	WRIO	T1,DZLPR(P2)	;...
	MOVE	T1,[DZABCS,,^D<2K>] ;WAIT 2 SEC FOR CARRIER TO SETTLE
	PUSHJ	P,DZQADD	;...
	JRST	SCNCK8		;DONE WITH THIS LINE

;HERE 2 SEC AFTER LAST CARRIER ON TRANSITION FOR A NON-AUTOBAUD DATASET
;OR AT END OF AUTOBAUD SEQUENCE

DZCXUP:	PUSHJ	P,DZUADR	;FIND DZ ON UNIBUS
	TIONB	T1,DZCAR(T2)	;IS CARRIER STILL THERE?
	 JRST	REPCOF		;NO, IT DIED
	MOVSI	T3,DZMCRW!DZMABW!DZMABF ;CAN'T BE IN THESE STATES ANYMORE
	ANDCAM	T3,DZMSTS##(P1)	;SO GET OUT
	MOVE	U,P1		;SET UP U FOR SCNSER
	MOVEI	T3,DSTRNG##	;RING
	PUSHJ	P,DSCREC##	;SCNSER
	MOVEI	T3,DSTON##	;CARRIER UP
	PJRST	DSCREC##	;SCNSER

;HERE 2 SEC AFTER AUTOBAUD DATASET HAS SETTLED DOWN

DZABCS:	PUSHJ	P,DZUADR	;FIND DZ ON UNIBUS
	TIONB	T1,DZCAR(T2)	;IS CARRIER STILL UP?
	 JRST	REPCOF		;NO, IT DIED
	MOVSI	T3,DZMCRW	;CARRIER WAIT
	SCNOFF			;PREVENT FUNNY RACES
	ANDCAM	T3,DZMSTS##(P1)	;IS OVER
	MOVSI	T3,DZMABW	;AND AUTOBAUD WAIT
	IORM	T3,DZMSTS##(P1)	;HAS BEGUN
	SCNON			;OK NOW
	MOVE	T1,[CRWTMO,,^D<30K>] ;ALLOW 30 SEC FOR AUTOBAUD SEQUENCE
	PJRST	DZQADD		;...
;HERE WHEN CARRIER DROPS

SCNCKF:	MOVSI	T2,DZMCON	;REMEMBER DROP
	ANDCAM	T2,DZMSTS##(P1)	;...
	MOVSI	T2,DZMCRW	;IF WE ARE IN CARRIER WAIT
	TDNE	T2,DZMSTS##(P1)	; ...
	 JRST	SCNCK8		;IGNORE CARRIER DROP
	MOVEI	T3,DSTOFF##	;OTHERWISE LET SCNSER WORRY
SCNDST:	MOVE	U,P1		;SET UP U FOR SCNSER
	PUSHJ	P,DSCREC##	;TELL SCNSER WHAT HAPPENED
	JRST	SCNCK8		;AND CONTINUE SCAN

;ROUTINE TO ADD AN ENTRY TO THE DATASET TIMER QUEUE
;
;CALL:	T1/ROUTINE TO CALL,,TIME IN MS
;	PUSHJ	P,DZQADD
;
;ROUTINE WILL BE CALLED WITH P1 = LINE # AND U = LINTAB(P1) BY DZQTIC

DZQADD:	PUSH	P,P2		;SAVE AN AC
	MOVEI	P2,-1		;MASK FOR ROUTINE ADDRESS
	SCNOFF			;NO RACES
	TDNN	P2,DZMSTS##(P1)	;REPLACING ENTRY IN Q?
	 AOS	DZTTQN##	;NO, NEW ENTRY
	HLRM	T1,DZMSTS##(P1)	;SET UP ROUTINE ADDRESS
	HRRZS	T1		;GET TIME IN MS
	IMULI	T1,JIFSEC##	;CONVERT TO K TICS
	HRRZ	T2,STOPAT##	;GET # TICS BETWEEN CALLS - 1
	IDIVI	T1,1(T2)	;AND ADJUST FOR M.STOF
	IDIVI	T1,^D1000	;TICS
	SKIPE	T2
	 AOS	T1
	DPB	T1,DZQPTM	;STORE TICS TO GO
	SCNON			;Q ALL SET
	POP	P,P2
	POPJ	P,
	SUBTTL	ROUTINE TO CONVERT A LINE NUMBER TO A UBA ADDRESS

;CALL:	P1/LINE NUMBER
;	PUSHJ	P,DZUADR
;	T1/BIT CORRESPONDING TO LINE NUMBER
;	T2/UNIBUS ADDRESS

DZUADR:	LDB	T2,[POINT 3,P1,35] ;GET LINE NUMBER IN DZ
	MOVEI	T1,1		;START WITH LINE 0
	LSH	T1,(T2)		;SHIFT TO THIS LINE NUMBER
	MOVE	T2,P1		;GET LINE NUMBER
	ANDI	T2,770		;ONLY DZ PART
	ADD	T2,[DZ11BA]	;CONVERT TO UNIBUS ADDRESS
	POPJ	P,
	SUBTTL	INTERRUPT -- RECEIVER

;HERE ON AN A VECTOR INTERRUPT ... RECEIVER
DZVECA::RDIO	T3,DZRBUF(P1)	;GET RECEIVED CHARACTER
	TRNN	T3,DZRDVL	;IS DATA VALID ?
	  POPJ	P,		;DISMISS INTERRUPT
	TRNE	T3,DZROVR	;OVERRUN ?
	  AOS	DZOVRC		;COUNT TIMES THAT HAPPENS
	LDB	U,[POINT 3,T3,27] ;GET RELATIVE LINE NUMBER
	ADDI	U,-<777777&DZ11BA>(P1) ;MAKE LINE NUMBER
	CAML	U,DZMAXL	;IS LINE NUMBER IN RANGE
	  JRST	DZVECA		;NO SO IGNORE IT
	MOVE	T1,LINTAB##(U)	;GET LDB ADDRESS
	MOVE	T1,LDBDCH##(T1)	;GET CHAR BITS
	TRNN	T1,LDRDSD##	;DATASET LINE?
	 JRST	DZVCA1		;NO, SKIP DATASET CODE
	MOVE	T1,DZMSTS##(U)	;GET SOFTWARE STATUS
	TLNN	T1,DZMCRW!DZMABF ;IF FLUSHING AB JUNK, TRASH CHAR
	TLNN	T1,DZMCON	;IS CARRIER ON?
	 JRST	DZVECA		;NO, TRASH CHARACTER
	TLNN	T1,DZMABW	;IN AUTOBAUD WAIT?
	 JRST	DZVCA1		;NO, PROCESS NORMALLY
	ANDI	T3,377		;REDUCE TO DATA BITS
	MOVE	T2,[POINT 12,ATOTAB] ;POINT TO BYTE STRING
DZVCA0:	ILDB	T1,T2		;GET CODE FOR NEXT SPEED
	JUMPE	T1,DZVECA	;IF NO MATCH, EXIT
	XOR	T1,T3		;SEE IF CHARACTER MATCHES
	TRNE	T1,366		;DOES IT?
	 JRST	DZVCA0		;NOPE, TRY NEXT
	LSH	T1,-^D8		;GET SPEED CODE
	MOVE	T2,SPDXTB(T1)	;TURN INTO DZ BITS
	DPB	T1,[POINT 4,T1,35-4] ;COPY SPEED CODE
	MOVE	T3,LINTAB##(U)	;FIND LDB
	EXCH	U,T3		;SET UP U
	DPB	T1,LDPSPD##	;STORE SPEED FOR PROGRAM
	MOVE	U,T3		;RESTORE U
	ANDI	T3,7		;MAKE DZ LINE
	IORI	T2,(T3)		;SET FOR LPR
	WRIO	T2,DZLPR(P1)	;SET SPEED, STOP BITS, RCV ENABLE, 8 BIT CHARS
	MOVSI	T1,DZMABF	;GET AUTOBAUD FLUSH STATE
	IORM	T1,DZMSTS##(U)	;SET TO FLUSH FOR 3/4 SEC (XTRA CHARS @ 100B)
	EXCH	P1,U		;SET UP P1
	MOVE	T1,[DZCXUP,,^D<750>] ;THEN TELL SCNSER LINE IS UP
	PUSHJ	P,DZQADD	;QUEUE THE TRANSACTION
	EXCH	P1,U		;RESTORE P1
	JRST	DZVECA		;PROCESS NEXT CHAR IN SILO

ATOTAB:	BYTE(4)07(8)200(4)11(8)026(4)11(8)346	;300,1200,1200
	BYTE(4)03(8)000(4)13(8)002(4)13(8)202	;110,2400,2400
	BYTE(4)13(8)004(4)13(8)204(4)14(8)360	;2400,2400,4800
	BYTE(4)14(8)160(4)14(8)162(4)15(8)366	;4800,4800,9600
	BYTE(12)0				;TERMINATOR

DZVCA1:	TRNE	T3,DZRFRM	;CHECK FOR FRAME ERROR
	  JRST	RCVFER		;HANDLE FRAMING ERROR
	ANDI	T3,CK.CHR	;KEEP ONLY CHARACTER
	PUSHJ	P,RECINT##	;CALL SCNSER
	JRST	DZVECA		;CHECK FOR MORE DATA IN SILO

;HERE WHEN RECEIVED CHAR HAS A FRAMING ERROR
RCVFER:	JRST	DZVECA		;CHECK FOR MORE DATA IN SILO
	SUBTTL	INTERRUPT -- TRANSMITTER

;HERE ON AN B VECTOR INTERRUPT ... TRANSMITTER
; HERE WITH DZ11 HDW ADR IN P1
DZVECB::RDIO	T1,DZCSR(P1)	;GET STATUS
	TRNN	T1,DZTRDY	;IS TRANSMITTER READY ?
	  POPJ	P,		;DONE
	LDB	U,[POINT 3,T1,27] ;GET RELATIVE LINE NUMBER
	ADDI	U,-<777777&DZ11BA>(P1) ;MAKE LINE NUMBER
	SKIPL	T3,DZCHTB##(U)	;GET CHAR WE SAVED TO TYPE
	  JRST	DZVCB4		;DONE WITH LINE FOR NOW
	SETZM	DZCHTB##(U)	;CLEAN OUT TABLE
	WRIOB	T3,DZTBUF(P1)	;GIVE DATA TO DZ11
	PUSHJ	P,XMTINT##	;LET SCNSER KNOW WE NEED MORE DATA
	JRST	DZVECB		;LOOK FOR MORE LINES TO SERVICE

;HERE IF LINE DONE
DZVCB4:	LDB	T1,[POINT 3,U,35] ;GET RELATIVE LINE NUMBER
	MOVEI	T2,1		;MASK
	LSH	T2,(T1)	;POSITION MASK
	BCIOB	T2,DZTCR(P1)	;CLEAR WANT TO TRANSMIT FLAG
	JRST	DZVECB		;LOOK FOR MORE LINES TO SERVICE
	SUBTTL	SETUP HARDWARE PARAMETERS

;SUBROUTINE TO SETUP EVERYTHING (I.E. SPEED) ACCORDING TO THE LDB
; CALL WITH:
;	MOVEI	U,<LDB ADR>
;	PUSHJ	P,DZCHP
;	RETURN
DZCHP:	LDB	T1,LDPLNO##	;GET LINE NUMBER
	CAML	T1,DZMAXL	;IS THIS POSSIBLE
	  POPJ	P,
	LDB	T2,LDPSPD##	;GET LINE SPEED
	MOVE	T3,T1		;COPY LINE NUMBER
	ANDI	T3,770		;STRIP RELATIVE LINE NUMBER
	ADD	T3,[DZ11BA]	;MAKES ADR OF DZ11
	ANDI	T1,7		;LEAVE ONLY RELATIVE LINE NUMBER
	ANDI	T2,17		;ONLY LOOK AT HALF OF SPEED
	IOR	T1,SPDXTB(T2)	;GET DZ11 SPEED INDEX
	JUMPL	T1,CPOPJ##	;CAN'T DO IT
	WRIO	T1,DZLPR(T3)	;SET SPEED ETC
	POPJ	P,

;TABLE TO TRANSLATE DH11 INDEXES TO DZ11 INDEXES

SPDXTB:	EXP	DZ8BIT				; 0 BAUD
	EXP	DZ1RXO!<0*400>!DZ8BIT		; 50 BAUD
	EXP	DZ1RXO!<1*400>!DZ8BIT		; 75 BAUD
	EXP	DZ1RXO!<2*400>!DZ2STP!DZ8BIT	; 110 BAUD
	EXP	-1				; 134.5 BAUD
	EXP	DZ1RXO!<4*400>!DZ8BIT		; 150 BAUD
	EXP	-1				; 200 BAUD
	EXP	DZ1RXO!<5*400>!DZ8BIT		; 300 BAUD
	EXP	DZ1RXO!<6*400>!DZ8BIT		; 600 BAUD
	EXP	DZ1RXO!<7*400>!DZ8BIT		; 1200 BAUD
	EXP	DZ1RXO!<10*400>!DZ8BIT		; 1800 BAUD
	EXP	DZ1RXO!<12*400>!DZ8BIT		; 2400 BAUD
	EXP	DZ1RXO!<14*400>!DZ8BIT		; 4800 BAUD
	EXP	DZ1RXO!<16*400>!DZ8BIT		; 9600 BAUD
	EXP	-1				; EXTERNAL INPUT A BAUD
	EXP	-1				; EXTERNAL INPUT B BAUD
	SUBTTL	CONTROL OVER DATASET

;HERE TO EXERCISE CONTROL OVER A DATASET.
; CALLED WITH TRANSACTION CODE IN T3, DSCTAB INDEX IN U.
; ENTERED FROM SCNSER ONLY.

DSCTYP:	CAML	U,DZMAXL	;IS LINE NUMBER IN RANGE
	POPJ	P,		;NO JUST SAY ITS OFF
	LDB	T2,[POINT 3,U,35] ;GET LINE NUMBER MODULO 8
	MOVEI	T1,1		;BIT FOR CARRIER ETC
	LSH	T1,(T2)		;PRESTO MASK
	MOVE	T2,U		;COPY LINE NUMBER
	ANDI	T2,770		;MAKES DZ11 # * 10
	ADD	T2,[DZ11BA]	;MAKESOF DZ11 FOR LINE
	CAIN	T3,DSTON##	;IS CODE FOR ON?
	JRST	DSDON		;YES. DRIVEN ON FLAG
	CAIN	T3,DSTOFF##	;NO. FOR OFF?
	JRST	DSDOFF		;YES. DISPATCH.
	CAIE	T3,DSTREQ##	;REQUEST SATATUS?
	POPJ	P,0		;NO. ERRONEOUS CODE. DISMISS.

;HERE TO REQUEST STATUS OF A LINE, ONLY DURING TTYINI. THUS
; IT IS OK TO GO INTO A WAIT-LOOP TO ACCOMPLISH THIS, AND TO IGNORE 
; ANY OTHER ACTIVITY.
	TIOEB	T1,DZCAR(T2)	;IS CARRIER ON ?
	SKIPA	T1,[EXP DSTON##] ;YES
	MOVEI	T1,DSTOFF##	;NOT ON
	POPJ	P,

;HERE TO DRIVE A DATASET ON.
DSDON:	BSIOB	T1,DZDTR(T2)	;TURN IT ON
	POPJ	P,

;HERE TO DRIVE A DATASET OFF.
DSDOFF:	BCIOB	T1,DZDTR(T2)	;CLEAR DATA TERMINAL READY
	MOVSI	T1,DZMCON!DZMCRW!DZMABW!DZMABF
	ANDCAM	T1,DZMSTS##(U)	;CLEAR OUR STATUS BITS
	POPJ	P,

	SUBTTL	TYPE A CHARACTER

;ROUTINE TO OUTPUT A CHARACTER TO A LINE
;CALLED FROM TYPE IN SCNSER
;WITH 8-BITS OF CHARACTER IN T3

SCNTYP:	LDB	T1,LDPLNO##	;PICK UP LINE NUMBER
	CAML	T1,DZMAXL	;IS LINE NUMBER IN RANGE ?
	  POPJ	P,		;NO SO DISMISS
	WRPI	PI.OFF		;DISABLE INTERRUPTS
	HRROM	T3,DZCHTB##(T1)	;SAVE CHAR TO TYPE LATER
	MOVEI	T3,1		;MASK FOR LINE
	MOVE	T2,T1		;COPY LINE NUMBER
	ANDI	T1,770		;LEAVE ONLY DZ11 UNIT * 10
	ADD	T1,[DZ11BA]	;MAKE ADR OF DZ11
	ANDI	T2,7		;LEAVE ONLY RELATIVE LINE NUMBER
	LSH	T3,(T2)		;POSITION MASK
	BSIOB	T3,DZTCR(T1)	;LET DZ11 KNOW WE WANT TO TYPE
	WRPI	PI.ON		;REENABLE INTERRUPTS
	POPJ	P,0		;AND RETURN
	$LOW
DZLIEN:	0			;COUNT OF LOST INTERRUPT ENABLES
DZOVRC:	Z			;COUNT OF TIMES RECEIVER GETS OVERRUN
DZMAXL:	0			;NUMBER OF DZ11 LINES
				; I.E. HIGHEST DZ11 LINE #+1

	$LIT

DZEND:	END
   {  ;