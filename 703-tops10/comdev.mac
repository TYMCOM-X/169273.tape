TITLE COMDEV -  MONITOR DEVICE DEPENDENT CODE, SYMBOLS, AND DATA - V1420
SUBTTL PART 6 COMDEV.MAC - T. HASTINGS/PH/TWE/DAL/JBS/EGF	10 SEP 85
	SEARCH	F,S
IFN FTNET,<
	SEARCH	NETPRM
>;END OF FTNET
IFN M.KL10,<
	SEARCH	DTEPRM
>;END IFN M.KL10
	$RELOC
	$LOW



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<1973,1986>
;COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986
;BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;ALL RIGHTS RESERVED.


;
XP VCOMDV,1420
				;PUT VERSION NUMBER IN GLOB AND LOADER STORAGE MAP


;SEE DATMAN FOR A LISTING OF S.MAC AND F.MAC

	SUBTTL	TABLE OF CONTENTS

;               TABLE OF CONTENTS FOR COMDEV
;
;
;                        SECTION                                   PAGE
;    1. TABLE OF CONTENTS.........................................   2
;    2. CONVERT MONGEN SYMBOLS....................................   5
;    3. DEFAULT SYMBOLS...........................................   9
;    4. COMPUTE SPECIAL SYMBOLS...................................  11
;    5. TERMINAL DATA BASE........................................  12
;    6. TERMINAL DATA BASE
;         6.1   TERMINAL CHARACTERISTICS DEFINITION...............  24
;         6.2   POINTERS FOR CURSOR SEQUENCES.....................  25
;         6.3   CURSOR CONTROL SEQUENCES..........................  26
;    7. DTESER DATA BASE GENERATION...............................  27
;    8. NETWORK SYMBOLS FOR NON-NETWORK SYSTEMS...................  28
;    9. MAGTAPE DATA BASE FOR TAPSER..............................  31
;   10. DECTAPE DATA BASE FOR DTASER..............................  39
;   11. INTERRUPT HEAD FOR DT'X...................................  40
;   12. MACRO TO GENERATE UNIT RECORD EQUIPMENT DDBS..............  46
;   13. CARD READER DDB DEFINITIONS...............................  47
;   14. CARD READER TRANSLATION TABLES............................  50
;   15. CARD PUNCH DDB DEFINITIONS................................  52
;   16. DK10 BITS AND DDB DEFINITIONS.............................  54
;   17. DEFINITIONS FOR DISPLAY AND LIGHT PEN.....................  57
;   18. LINE PRINTER DDB DEFINITIONS..............................  59
;   19. PLOTTER DDB DEFINITIONS...................................  65
;   20. DEFINITIONS FOR PAPER TAPE AND PTY'S......................  66
;   21. PAPER TAPE READER DDB DEFINITIONS.........................  66
;   22. PAPER TAPE PUNCH DDB DEFINITIONS..........................  66
;   23. ROUTINES COMMON TO PDP11 COMM FRONT-END'S ON DL10'S.......  69
;   24. LOCATE & WHERE COMMAND/UUOS...............................  76
REPEAT 0, <
;THE COMDEV SUBPROGRAM CONSISTS OF 6 FILES ASSEMBLED TOGETHER AS ONE SUBPROGRAM
	1. F.MAC -- FEATURE TESTS (OUTPUT OF## MONGEN).
	2. S.MAC - THE USUAL SYSTEM SYMBOL DEFINITIONS## ASSEMBLED WITH
	EVERY	MONITOR SUBPROGRAM
	3. HDWCNF.MAC -- HARDWARE CONFIGURATION
	4. TTYCNF.MAC -- TERMINAL CONFIGURATION
	5. REMCNF.MAC -- REMOTE CONFIGURATION
	6. COMMON.MAC - THE REST Of THIS PROGRAM WHICH IS THE SAME SOURCE FOR
	ALL	CONFIGURATIONS.  HOWEVER, THE ASSEMBLIES ARE CONDITIONED BY
	SYMBOLS	AND MACROS DEFINED IN 2.

	THE	FOLLOWING SYMBOLS AND TABLES ARE GENERATED BELOW:

	A. CONVERSION SYMBOLS FROM NEW MONGEN(M.XXXX) To OLD SYMBOLS(XXXXX.N)
	B. TTY AND REMOTE CONVERSION SYMBOLS
	C. MONGEN DEFAULT SYMBOLS
	D. TTY DATA BASE
	E. REMOTE STATION DATA BASE
	F. ALL OTHER DEVICe SPECIFIC CODE AND DATA BASES:	   (ONLY CODE WHICH CHANGES DEPENDING ON THE CONFIGURATION
	   SHOULD BE IN COMDEV). THE LIBARARY SEARCH FEATURE
	   DETERMINES WHETHER THE CONFIGURATION INDEPENDENT CODE
	   FOR A PARTICULAR DEVICe IS LOADED OR NOT).
	   SHOULD BE HERE.
	   THE ONLY DEVICe SPECIFIC STUFF IN COMMON IS THE
	   SYMBOL DEFINITIONs WHICH INCLUDE THE PI ASSIGNMENT VALUE.



LEVEL D DISK SERVICE PARAMETERS:

	ALL	SYMBOLS AND LOCATIONS ARE IN A SEPARATE FILE CALLED
	COMMOD.MAC WHICH IS ALSO ASSEMBLED WITH S AND CONFIg (BUT NOT WITH FEATURS FILES).
	THE	SEPARATE FILE IS FOR TWO REASONS:
	1.  ANTICIPATING MULTIPROCESSING SYSTEMS WHICH SHARE DISKS AND 1 16K MEMORY
	(THE DATA MUST BE IN THE COMMON MEMORY)
	2.  ELIMINATE THE NEED To ASSEMBLE COMMOD IF NOT A DISK SYSTEM
	(COMMOD.MAC TAKES LOTS Of CORE FOR ITS COMPLICATED MACROS)


		COMMUNICATIONS SOFTWARE
>

IFN FTKL10,<
;NOTE:
; IF ANY CHANGES ARE MADE TO DTEPRM THAT DTESER MUST HAVE, UPDATE
; THE FOLLOWING SYMBOL TO THE VERSION OF DTEPRM THAT MUST BE USED
	PRMMIN==16
; THIS WAY, ASSEMBLING THIS MODULE WITH WRONG VERSION OF DTEPRM FOR SOME REASON
; (LIKE FORGETTING TO ASSEMBLE IT) WILL CAUSE ASSEMBLY TO TERMINATE
; THIS SCHEME DOES NOT CAUSE EXTRA EDITING, SINCE ONLY FILES
; WHICH NEED THE CHANGES NEED PRMMIN TO BE UPDATED. MODULES
; THAT DO NOT NEED A NEW VERSION OF DTEPRM NEED NOT DEMAND IT.

IFL VDTPRM-PRMMIN,<PRINTX ?PLEASE USE LATEST VERSION OF DTEPRM
			PASS2
			END>>
SUBTTL CONVERT MONGEN SYMBOLS
REPEAT 0,<

;THIS SECTION CONVERTS NEW MONGEN SYMBOLS TO OLD MONGEN SYMBOLS
;SO THAT THE REST OF COMMON AND MONITOR CAN STILL USE THE OLD
;SYMBOLS.  THIS WAS DONE RATHER THAN CONVERTING ALL OF THE
;MONITOR TO NEW SYMBOLS FOR TWO REASONS:
; 1.  IT IS EASIER AND FASTER AND LESS LIKELY TO INTRODUCE BUGS, AND
; 2.  IT ALLOWS CUSTOMERS TO USE OLD MONGEN WITH A MINIMUM
;OF TROUBLE: ONLY A FEW EXTRA SYMBOLS MUST BE DEFINED.
;THE MONITOR WILL PROBABLY BE CONVERTED TO THE NEW MONGEN SYMBOLS
;AFTER THE 5.04 RELEASE.  THE ORDER HERE PARALLELS THE OLD
;MONGEN ORDER.

>
XP SYS40N,0		;NEW MONGEN MAKES SWAPPING SYSTEMS ONLY
XP SYS50N,1
XP DSKN,1
XP LOGINN,1

XP APRSN,M.C0SN		;APR SERIAL NUMBER (REALLY PROCESSOR 0)
XP APR0SN,M.C0SN	;PROCESSOR 0 SERIAL NUMBER
XP APR1SN,M.C1SN	;PROCESSOR 1 SERIAL NUMBER
XP CP0P6N,0		;PROCESSOR 0 IS NOT A PDP 6
XP CP1P6N,0		;PROCESSOR 1 IS NOT A PDP 6
XP CP0KIN,M.KI10	;PROCESSOR 0 MAY BE A KI10
XP CP1KIN,M.KI10	;PROCESSOR 1 MAY BE A KI10
XP CPUN,M.CPU		;NUMBER OF PROCESSORS

XP LEVDN,1		;NEW MONGEN MAKES ONLY LEVEL D DISK SERVICE
XP LEVCN,0
XP CHNN,M.CHN		;NUMBER OF DATA CHANNELS FOR DISKS

XP RD10N,M.RC10
XP RP10N,M.RP10
XP RH10NS,M.RH1S
XP RH10NP,M.RHP4
XP RN10N,M.RP20
XP RA10N,0		;NO MDF

	DEFINE	SYSDEV,<
	SIXBIT	/DSK/
>
XP JOBN,M.JOB+1
XP PDP10N,M.KI10!M.KL10N!M.KS10
XP KT10AN,MD.2RR
XP SEGN,MD.SEG
IFG KT10AN,<XP SEGN,SEGN+JOBN>	;NO. OF SEGS=NO. OF JOBS+NO. HISEGS
XP DDTN,MD.DDT

XP EDITN,0

XP PTRN,M.PTR
XP PTPN,M.PTP
XP PLTN,M.PLT
XP LPTN,M.LPT
IFNDEF M.DLP,<M.DLP==:0>
IFNDEF M.DCR,<M.DCR==:0>
XP DLPTN,M.DLP
XP DCDRN,M.DCR
XP MOVIEN,MD.MOV
XP CDRN,M.CDR
XP CR10N,MD.C10
XP CDPN,M.CDP
IFN	FTXTC,<
IFE	M.XTC,<
XP M.XTL,0>
XP XTCN,M.XTC
>
IFE	FTXTC,<
IFN	M.XTC,<
PRINTX	?NO DA28 SUPPORT WITH FTXTC=0
PRINTX	?PROCEEDING ASSUMING NO DA28
XP M.XTC,0
>
XP M.XTL,0
XP XTCN,0
>

XP DISN,M.DIS
XP PENN,M.DIS
XP T340N,M.340
XP TVP10N,M.VP10
XP T30N,0		;NO TYPE 30
XP VBCN,M.VBXC
DEFINE TDMAC(X),<
	XP	DT'X'N,M.DT'X
M.DTXN==M.DTXN+M.DT'X
>
ZZ=="A"
M.DTXN==0
REPEAT M.TD10,<
	TDMAC(\"ZZ)
ZZ==ZZ+1
>

IFN FTKS10,<
    DEFINE RX2MAC(X),<
	XP	RX'X'N,M.RX'X
    M.RXXN==M.RXXN+M.RX'X
    >
    ZZ=="A"
    M.RXXN==0
    REPEAT M.RX20,<
	RX2MAC(\"ZZ)
    ZZ==ZZ+1
    >
>;End FTKS10
IFNDEF M.TM10,<XP M.TM10,0>
IFNDEF M.TC10,<XP M.TC10,0>
IFNDEF M.TX01,<XP M.TX01,0>
IFNDEF M.DX20,<XP M.DX20,0>
XP TAPN,M.TM10+M.TC10+M.TX01+M.TM02+M.DX20+M.TM78

XP PTYN,M.PTY

XP SYSCN,M.SYSC
XP LOKN,M.LOK
XP CMNN,M.MGC
XP RTTRPN,M.RTD
XP HPQN,M.HPQ

IFNDEF M.HRSN,<XP M.HRSN,77>
IFNDEF M.LATN,<XP M.LATN,0>
IFNDEF TTXTRA,<XP TTXTRA,0>
IF2,<
IFN M.KL10,<
	DEFINE	TTXTRD(N),<TTXTRA==TTXTRA+M'N'DTEN>
	ZZ==0
	REPEAT	CPUN,<
	TTXTRD(\ZZ)
	ZZ==ZZ+1>
>>				;DEFINE ENOUGH SLAVE DDBS FOR ALL DTES
XP	TTD28N,M.XTL
IFG M.XTL,<XP M.TLTL,M.TLTL+M.XTL>
IFNDEF M.TTDN,<M.TTDN==:0>
XP	M.TLTL,M.TLTL+M.TTDN	;REDEFINE FOR ANY RSX-20F LINES
IFN M.KS10,<
XP	KLILIN,M.TLTL+M.RMCR	;LINE NO. FOR KS10 KLINIK
XP	M.TLTL,M.TLTL+1		;ADD ONE FOR KLINIK
>
XP	CTYLIN,M.TLTL+M.RMCR+M.CPU
XP	FRCLIN,CTYLIN-M.CPU
	DEFINE	OPRL(LINE),<
IFIDN <LINE> <CTY>,<SIXBIT /CTY/>
IFDIF <LINE> <CTY>,<SIXBIT /TTY'LINE/>
>

DEFINE	DSASOC,<
	XLIST

	DEFINE	L(M,N,P),<
IFIDN <M> <CTY>,<
	ZZBEG==CTYLIN
	ZZDATA==CTYLIN
>
IFDIF <M> <CTY>,<
	ZZBEG==M
	ZZDATA==M
>
IFB <P>,<
	ZZEND==ZZBEG
	ZZLINE==N
>
IFNB <P>,<
	ZZEND==N
	ZZLINE==P
>

REPEAT ZZEND-ZZBEG+1,<
	GENLIN	(\ZZDATA,ZZLINE)
ZZDATA==ZZDATA+1
ZZLINE==ZZLINE+1
>>	;END REPEAT AND DEFINITION OF L

	LIST
>	;END DEFINITION OF DSASOC
SUBTTL DEFAULT SYMBOLS
;THE FOLLOWING STANDARD SYMBOLS CAN BE SUPERSEDED BY A CUSTOMER HAVING
; PREVIOUSLY DEFINED THEM ON THE HDWGEN.MAC FILE USING THE MONGEN PROGRAM....
;**********************************************************************
;ADD NEW SYMBOLS AT END SO EASY TO UPDATE MONGEN APPENDIX	      *
;**********************************************************************
IFNDEF XPANDN,<XP XPANDN,0>	;FORCE NO EXPANSION OF MACROS
				; UNLESS XPANDN IS DEFINED NON-ZERO WITH MONGEN


				;SIZE OF MAGTAPE RECORDS (DATA WORDS IN BUFFER)
IFNDEF MTSIZ, <XP MTSIZ,^D128>	;STANDARD == 128 WORDS PER BUFFER

				;SIZE OF LPT BUFFER (NUMBER OF DATA WORDS+2)
IFNDEF LPTSIZ, <XP LPTSIZ,^D27+2> ;STANDARD == 27 WORDS PER LPT BUFFER (132 COL. PRINTER)

IFNDEF	FLCDEF,<XP FLCDEF,1>	;FILLER CLASS CODE TO USE IF NOT SPECIFIED
				;FOR A TTY LINE
IFNDEF TTYALT,<XP TTYALT,0>	;DEFAULT SETTING OF TTY ALTMODE
				; IS NO CONVERSION OF ASCII CODES 175 AND 176 TO 33
IFNDEF TTYWID,<XP TTYWID,^D72>	;DEFAULT SETTING OF TTY WIDTH IS 72.
IFNDEF TTYRMT,<XP TTYRMT,1>	;DEFAULT SETTING OF TTY REMOTE IS ON
IFNDEF TTYLCT,<XP TTYLCT,1>	;DEFAULT SETTING OF TTY LC IS OFF
IFNDEF CTYLCT,<XP CTYLCT,TTYLCT> ;MATCH DEFAULT SETTING OF CTY LC WITH TTY LC
IFNDEF PTYRMT,<XP PTYRMT,0>	;PTYS ARE NORMALLY LOCAL
IFNDEF PTYLCT,<XP PTYLCT,0>	;PTYS NORMALLY DON'T SET BITS
XP CTYLTB,<FLCDEF*TTVFLC+CTYLCT*TTVLCT+0*TTVRMT>	;CTY 'LINTAB' BITS
XP TTYLTB,<FLCDEF*TTVFLC+TTYLCT*TTVLCT+TTYRMT*TTVRMT>	;TTY 'LINTAB' BITS
XP PTYLTB,<0*TTVFLC+PTYLCT*TTVLCT+PTYRMT*TTVRMT>	;PTY 'LINTAB' BITS

;PARAMETERS THAT CONTROL THE AUTO-DISCONNECT FEATURE.

ND	IDLSEC,^D90		;ANY TERMINAL IDLE THIS LONG GETS DISCONNECTED
ND	M.AIDL,IDLSEC		;ANF-10 DEFAULT IDLE TIME
ND	M.NIDL,IDLSEC		;NRT/CTERM DEFAULT IDLE TIME
ND	M.DIDL,IDLSEC		;DATASET MAXIMUM IDLE TIME
ND	M.LIDL,IDLSEC		;LAT TERMINAL IDLE-MAX

;NOTE--IN ORDER TO RESERVE PI-CHANNELS FOR
;NON-STANDARD USAGE, FOR EACH CHANNEL (SAY N)
;DEFINE SYMBOL UNIQN==1 VIA MONGEN.  FOR
;EXAMPLE, TO RESERVE CHANNEL 4, DEFINE
;UNIQ4==1.

;IF IT IS DESIRED TO LEAVE A CHANNEL FREE FOR RTTRP JOB TO USE
;THEN THE APPROPRIATE SYMBOL "RTCH'N" SHOULD BE DEFINED AS 1.
;FOR EXAMPLE:
;IF CHANNEL 2 IS TO FREE FOR RTTRP USE THE DEFINE RTCH2==1 IN MONGEN

IFNDEF MTELOG,<XP MTELOG,-1>	;ZERO TO LOG ALL RECOVERED ERRORS
				;NON-ZERO TO LOG ERRORS THAT REQ'D MORE THAN ONE RETRY
IFNDEF MTDAEM,<XP MTDAEM,10>	;NUMBER OF TIMES PER REEL TO CALL DAEMON
				; FOR MAGTAPE ERROR REPORTS.
IFN FTTLAB,<
IFNDEF MTDLTP,<XP MTDLTP,LT.BLP>	;DEFAULT LABEL TYPE
>
IFN FTKL10,<

DEFINE DTEDEF(X,Y)<
  IFE <Y-1>,<M.AT'X'Y==M'X'TTDN> ;ASYNCHRONOUS TERMINALS ON -20F FRONT END
  IFN <Y-1>,<M.AT'X'Y==0>
	NDL	M.FD'X'Y,2	;NUMBER OF FRONT END DEVICES ON FRONT END
				; ONE FOR FILE XFER, ONE FOR DDT11
>
ZZ==0
REPEAT M.CPU,<
ZZZ==1
REPEAT 4,<
	DTEDEF	(\ZZ,\ZZZ)
ZZZ==ZZZ+1
>
ZZ==ZZ+1
>

>	;END FTKL10
;ADD NEW MONGEN SYMBOLS HERE
SUBTTL COMPUTE SPECIAL SYMBOLS

;PERFORM TRANSLATION FROM HARDWARE TO SOFTWARE DESIGNATION
; FOR ALL DISK SYMBOLS

IFN DSKN,<
	FHDN==RD10N
	DPCN==RP10N
	MDFN==RA10N
	FSDN==RH10NS
	RPXN==RH10NP
	RNXN==RN10N
>
IFE DSKN, <
	FHDN==0
	DPCN==0
	MDFN==0
	FSDN==0
	RPXN==0
	RNXN==0
>

IFN LEVDN,<
ALLDSK=FHDN+DPCN+MDFN+FSDN+RPXN+RNXN	;ALLDSK = THE TOTAL # OF DSK KONTROLLERS IN THE SYSTEM
				; IF YOU ADD ANOTHER KONTROLLER TYPE YOU MUST
				; INCLUDE THE # OF KONTROLLERS OF THAT TYPE HERE
>

;DEFINE THE PARAMETERS WHICH CONTROL THE TYPE OF SYSTEM

XP FTDISK,-DSKN			;10/40D OR 10/50S
XP FTSWAP,-SYS50N		;10/50S
XP FTLOGIN,-DSKN		;PUT FTLOGIN IN SO LOADER WILL COMPLAIN
				; IF DIFFERENT IN OTHER FILES
SUBTTL TERMINAL DATA BASE
;THE FOLLOWING SECTION DESCRIBES THE TELETYPE LINES,GLOBALS, AND
;DATA STRUCTURES OF THE MONITOR.

;THE FOLLOWING ARE SUPPLIED BY MONGEN


;M.DC10	=NUMBER OF DC10'S
;M.DC68	=NUMBER OF DC68'S
;M.DC76 =NUMBER OF DC76'S

;M.D7KN =NUMBER OF LINES ON DC76 K
;M.68LK	=NUMBER OF LINES ON DC68 K
;M.TTGK	=NUMBER OF LINES ON DC10 K
;M.DSGK	=NUMBER OF DC10E'S ON DC10 K
;M.TLTL	=TOTAL LOCAL TTY LINES

IFDEF	M.LCST,<	;#WORDS FOR CUSTOMERS IN LDB
IFG	M.LCST,<
  LDBCST==:LDBLEN##-M.LCST	;DEFINE START OF CUSTOMER AREA
>
>
IFNDEF	M.LCST,<
  M.LCST==:0
>
;DEFINE SYMBOLS FOR CPUS OTHER THAN 0 UNTIL WE GET MONGEN WORKING

DEFINE CXDEF(SYM)<
IRP SYM,<
IFNDEF M0'SYM,<M0'SYM==M.'SYM>
IFNDEF M1'SYM,<M1'SYM==0>
IFNDEF M2'SYM,<M2'SYM==0>
IFNDEF M3'SYM,<M3'SYM==0>
IFNDEF M4'SYM,<M4'SYM==0>
IFNDEF M5'SYM,<M5'SYM==0>
>>

CXDEF(<TTG0,TTG1,68L0,68L1,D70N,D71N,D72N,D73N>)
CXDEF(<D74N,D75N,D76N,D77N,DZNL>)

;THE FOLLOWING MAY BE SUPPLIED FOR LINTAB, WHERE THE LINE NUMBER
; IS CONCATENATED ON THE END (0 IN THIS CASE):

;DSD0 MEANS LINE 0 IS A DATASET LINE
;TAB0 MEANS LINE 0 HAS HARDWARE TABS
;RMT0 MEANS LINE 0 IS A REMOTE LINE, BUT NOT A DATASET.
;HLF0 MEANS LINE 0 IS HALF-DUPLEX (XMTED CHARS WILL BE RCVD)


;ALSO A MACRO IS DEFINED FOR DC10E-CONTROLLED DATASETS, WHICH
;DEFINES THE CORRESPONDENCE BETWEEN THE DC10E CONTROL LINE NUMBER
;(WHICH CONTROLS THE DATASET ENABLES, RINGING, ETC) AND THE
;CORRESPONDING DC10B LINE NUMBER (I.E., TTYN AS THE SYSTEM SEES
;IT). FOR EXAMPLE, FOR A SYSTEM WITH TWO DATASETS CONTROLLED
;BY DC10E LINES 27 AND 26, AND WITH DATA ON TTY17 AND TTY16 RESPECTIVELY,
;	DEFINE DSASOC <
;		GENLIN 27,17
;		GENLIN 26,16
;	>


;THE FOLLOWING ARE USED IN THE PREDEFINED LINE TABLES

DEFINE LINMAC (BITS) <
IRP BITS,<
LINMC1 (BITS,\LIN)
>
		LIN==LIN+1
>
DEFINE LINMC1 (B,N) <
B'N==:1
>
;THE FOLLOWING GLOBALS ARE USED IN VARIOUS ROUTINES SUCH AS
;ONCE,SCNSER,DLSINT,BTHINT,ETC.


XP SCNN,JOBN+TTXTRA		;NUMBER OF TTY DDBS TO BE BUILT
XP HGHLIN,M.TLTL		;HIGHEST LINE ON SCANNERS, BEFORE TCONLN
XP TCONLN,CTYLIN		;LINE NUMBER FOR CTY (NOT ON SCANNER)

XP DL0MXD,<10*M.TTG0>-1		;HIGHEST DC10 LINE WHICH IS REAL DATA
XP DL0MXL,<10*M.DSG0>+DL0MXD	;HIGHEST LINE ON DC10 (MAY BE DC10E)
XP DL0OFS,0			;OFFSET FROM LINTAB TO HARDWARE
XP DL1MXD,<10*M.TTG1>-1		;NUMBER OF DATA LINES ON DC10 #1
XP DL1MXL,<10*M.DSG1>+DL1MXD	;HIGHEST LINE ON DC10 #1
XP DL1OFS,<10*M.TTG0>		;ADD TO GO FROM HARDWARE TO LINTAB
XP CC0OFS,DL1OFS+<M.TTG1*10>	;OFFSET TO GET TO CCI0
XP CC1OFS,CC0OFS+M.68L0		;OFFSET TO GET TO CCI1
XP D70OFS,CC1OFS+M.68L1		;OFFSET FOR FIRST DC76
XP D71OFS,D70OFS+M.D70N		;OFFSET FOR SECOND DC76
XP D72OFS,D71OFS+M.D71N		;OFFSET FOR THIRD DC76
XP D73OFS,D72OFS+M.D72N		;OFFSET FOR FOURTH DC76
XP D74OFS,D73OFS+M.D73N		;OFFSET FOR FIFTH DC76
XP D75OFS,D74OFS+M.D74N		;OFFSET FOR SIXTH DC76
XP D76OFS,D75OFS+M.D75N		;OFFSET FOR SEVENTH DC76
XP D77OFS,D76OFS+M.D76N		;OFFSET FOR EIGHT DC76
XP DZOFS,D77OFS+M.D77N		;OFFSET FOR DZ11 TTY'S
XP TTDLAL,DZOFS+M.DZNL		;OFFSET FOR ALL TTD (RSX-20F) LINES
XP NETOFS,TTDLAL+M.TTDN		;OFFSET TO NETWORK TTY'S
XP D28OFS,NETOFS+M.RMCR		;OFFSET FOR DA28 LINES
XP DSCOF0,DL0MXD+1		;NUMBER TO SUBTRACT FROM LINE # TO
				; GET DCSTAB INDEX FOR DC10#0
XP DSCOF1,DL1MXD+1-<DL0MXL-DL0MXD> ;DITTO FOR DC10 #1

IFG <PTYN-^D512>,<PRINTX ?512 OR MORE PTY'S EXCEEDS FIELD OF DDB>
XP TTPLEN,TCONLN+PTYN+1		;LENGTH OF TRANSLATOR TABLE
				;INCLUDES ALL SCNANNERS, CTY, AND PTY'S
IFG <TTPLEN-^D512>,<PRINTX ?MORE THAN 512. TTYS+PTYS EXCEEDS FIELD OF DDB>
XP PTYOFS,TCONLN+1		;OFFSET FOR PTY-DRIVEN TTY'S

XP MTTYLN,-TTPLEN
XP MLTTYL,-SCNN
IFN M.DZNL,<

	EXTERN	DZINT	;LOAD SERVICE ROUTINE

;TABLE OF OUTPUT CHARACTERS FOR EACH DZ11 LINE
DZCHTB::BLOCK	M.DZNL

;TABLE OF DATASET STATUS FOR EACH DZ11
DZDSTB::BLOCK	<<M.DZNL+7>/10>

;TABLE OF LINE STATUS FOR AUTOBAUD FRONT END

DZTTQN::EXP	0
DZMSTS::BLOCK	M.DZNL

DEFINE X (N) <
DZ'N'VA::EXP	0		;JSR HERE ON INTERRUPT
	EXP	0,IC.UOU,.+1

	EXCH	T1,DZ'N'VA	;GET PC WE CAME FROM
	MOVEM	T1,SCNCHL##	;SAVE IT FOR SCNSAV
	MOVE	T1,DZ'N'VA+1	;SECOND WORD
	MOVEM	T1,SCNCHL##+1

	MOVE	T1,DZ'N'VA	;RESTORE T1
	JSR	SCNSAV##	;SAVE REGISTERS
	MOVE	P1,[DZ11BA+<N*10>]
	JRST	DZVECA##
DZ'N'VB::EXP	0		;JSR HERE ON INTERRUPT
	EXP	0,IC.UOU,.+1

	EXCH	T1,DZ'N'VB	;GET PC WE CAME FROM
	MOVEM	T1,SCNCHL##	;SAVE IT FOR SCNSAV
	MOVE	T1,DZ'N'VB+1	;SECOND WORD
	MOVEM	T1,SCNCHL##+1

	MOVE	T1,DZ'N'VB	;RESTORE REGISTER
	JSR	SCNSAV##	;SAVE REGISTERS
	MOVE	P1,[DZ11BA+<N*10>]
	JRST	DZVECB##
>
	Z=0
	REPEAT <<M.DZNL+7>/10>,<
	X	\Z
	Z=Z+1
	>
>;IFN M.DZNL
;DEFINE ALL DL10 SYMBOLS

	DLX.CK(0)		;MACRO DEFINED IN S.MAC


IFN FTDAS78!DLX.78,<
IFE FTDAS78,<
	PRINTX	?DEFINING A DAS78 REQUIRES FTDAS78 TO BE ON
PDP11N==PDP11N-DLX.78
DLX.78=0			;ACTUAL NUMBER
>>	;END OF IFN FTDAS78!DLX.78


IFN FTDN60!DLX.60,<
IFE FTDN60,<
	PRINTX	?DEFINING A DN60 REQUIRES FTDN60 TO BE ON
PDP11N==PDP11N-DLX.60
DLX.60=0			;ACTUAL NUMBER
>>	;END OF IFN FTDN60!DLX.60
IFNDEF M.DN6S,<M.DN6S==0>

;SCANNER ENTRY POINTS AND BIT DEFINITIONS
	EXTERN	SCNSER



;TELETYPE LINE CHARACTERISTICS (FORMER LH OF LINTAB)
;USED BY SCNSER

XP TTVRMT,1			;REMOTE LINE
XP TTVHLF,2			;HALF DUPLEX LINE (DC10C OR TWX)
XP TTVINI,4			;RUN INITIAL CUSP
XP TTVDSD,10			;DATASET DATA LINE
XP TTVDIS,20			;2741 TERMINALS ON A DC-10 INTERFACE
XP TTVNFC,40			;NO FREE CRLF AT 72 COLUMNS
XP TTVFRM,100			;FORM FEED IN HARDWARE
XP TTVLCP,200			;LOCAL COPY, BUT NOT HALF DUPLEX
XP TTVTAB,400			;TAB HARDWARE (8 COLUMNS PER)
XP TTVLCT,1000			;LOWER CASE TRANSLATE TO UPPER
XP TTVSLV,2000			;SLAVE TTY
XP TTVFLC,4000			;TWO BITS OF FILLER CLASS CODE

	DEFINE	CALLM(NAME,LINE),<
	NDL NAME'LINE,1
>

	DEFINE	TTYMAC(TYPE),<
	XLIST

	DEFINE	L(A,B),<
IFB <B>,<IFE	<SIXBIT/A/>-<SIXBIT/CTY/>,<
			ZZBEG==FRCLIN+1
			ZZEND==TCONLN>
	IFN	<SIXBIT/A/>BIT/CTY/>,<ZZBEG==<ZZEND==A>>
>
IFNB <B>,<
	ZZBEG==A
	ZZEND==B
>
ZZLINE==ZZBEG
IFGE ZZEND-FRCLIN,<ZZEND==FRCLIN-1>	;DON'T NEED TO INCLUDE PTYS
IFG ZZEND-ZZBEG+1,<
REPEAT ZZEND-ZZBEG+1,<
	CALLM	(TYPE,\ZZLINE)
ZZLINE==ZZLINE+1
>>>	;END IFG, REPEAT AND DEFINITION OF L
	MAC'TYPE
	LIST
>	;END DEFINITION OF TTYMAC
	.XCREF
	TTYMAC	DSD
	.CREF
;NOW DEFINE THE LINE TABLE FOR STORING LDB ADDRESSES.

$HIGH
LINTAB::
REPEAT TTPLEN,<
EXP	0
XLIST>
LIST
$LOW

;NOW THE DATASET CONTROLLER INFO FOR ANY DC10E'S


;CONSTRUCT THE DATASET CONTROLLER TABLE

DEFINE GENLIN(CON,DATA)<

ZZ==0
IFLE <CON-DL0MXD>,<ZZ==1>
IFG <CON-DL0MXL>,<ZZ==1>
IFG <DATA-DL0MXD>,<ZZ==1>		;CHECK RANGE OF ARGUMENT

IFN ZZ,<PRINTX ? SPECIFICATION ERROR - DSCTAB>
IFE ZZ,<
DSA'CON==1
DSB'CON==DATA
>
>

IFG M.DSG0,<
DSASOC
MACCR0			;INVOKE THE MACRO
>
DSCTAB::.INDEX==DL0MXD+1
DEFINE GENLIN(N)<
ZZ==0
IFDEF DSA'N,<IFN DSA'N,<ZZ==DL0OFS+DSB'N>>
	EXP	ZZ		;DATA SET N
.INDEX==.INDEX+1
>
REPEAT <DL0MXL-DL0MXD>,<GENLIN(\.INDEX)>

IFDEF	MACCR1,<	;ONLY IF 2 DC10'S

DEFINE GENLIN(CON,DATA)<

ZZ==0
IFLE <CON-DL1MXD>,<ZZ==1>
IFG <CON-DL1MXL>,<ZZ==1>
IFG <DATA-DL1MXD>,<ZZ==1>		;CHECK RANGE OF ARGUMENT

IFN ZZ,<PRINTX ? SPECIFICATION ERROR - DSCTAB>
IFE ZZ,<
DSA'CON==1
DSB'CON==DATA
>
>

DSASOC
MACCR1			;INVOKE THE MACRO
	.INDEX==DL1MXD+1
DEFINE GENLIN(N)<
ZZ==0
IFDEF DSA'N,<IFN DSA'N,<ZZ==DL1OFS+DSB'N>>
	EXP	ZZ		;DATA SET N
.INDEX==.INDEX+1
>
XALL
DSCTB1:REPEAT <DL1MXL-DL1MXD>,<GENLIN(\.INDEX)>
> ;END IFNDEF MACCR1

ZZ==CC0OFS
	XP	DSCNDX,<.-DSCTAB>
	XP	CC0DSO,CC0OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	CC1DSO,CC1OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D70DSO,D70OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D71DSO,D71OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D72DSO,D72OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D73DSO,D73OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D74DSO,D74OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D75DSO,D75OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D76DSO,D76OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	D77DSO,D77OFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	DZDSO,DZOFS-<<M.TTG0+M.TTG1>*10>+DSCNDX
	XP	TTDDAL,TTDLAL-<<M.TTG0+M.TTG1>*10>+DSCNDX
REPEAT M.68L0+M.68L1+M.D70N+M.D71N+M.D72N+M.D73N+M.D74N+M.D75N+M.D76N+M.D77N+M.DZNL+M.TTDN,<	EXP ZZ
ZZ==ZZ+1

>
	MDSLN==:DSCTAB-.

;DEFINE SOME CHUNK SIZE PARAMETERS AND MASKS

IFNDEF TTCHKS,<TTCHKS==4>	;DEFAULT SIZE IN WORDS OF A TTY CHUNK
IFL TTCHKS-4,<TTCHKS==4>	;MUST BE AT LEAST 4
XP TTCHKS,<1B<^L<TTCHKS>>>	;WORDS IN A CHUNK (MUST BE POWER OF TWO)
XP CK.BDY,TTCHKS-1		;MASK FOR END OF CHUNK
XP CK.BTH,-CK.BDY		;MASK FOR START OF CHUNK
XP CK.CPC,CK.BDY*CK.CPW		;CHARACTERS PER CHUNK

;THE FOLLOWING SLIDING SCALE DEFINES THE LENGTH OF THE TTY FREE LIST

IFNDEF TTCHKN,<
IFNDEF TTCHKK,<
XP TTCHKK,<<TTYWID-1>/CK.CPC>+4	;ENSURE AT LEAST TTYWID CHARACTERS PER LDB
IFL TTPLEN-40,<XP TTCHKK,TTCHKK+1>	;MORE IF FEW LINES
IFL TTPLEN-20,<XP TTCHKK,TTCHKK+1>	;DITTO
IFL TTPLEN-10,<XP TTCHKK,TTCHKK+1>	;AND DITTO
> ;END OF IFNDEF TTCHKK

XP TTCHKN,TTCHKK*TTPLEN		;AT LAST, USE THIS CONSTANT TO GET TTCHKN

> ;END OF IFNDEF TTCHKN


;SCNSER'S INPUT WARNING/LIMIT LEVELS

IFNDEF TTYMIC,<XP TTYMIC,^D60>		;MAXIMUM INPUT CHARS/MESSAGE
					;*** SHOULD MATCH DN8X DNCNFG.P11 ***

IFNDEF TTIBRK,<XP TTIBRK,^D132>		;DEFAULT ASCII/IMAGE LINE "BREAK" LEVEL
IFNDEF TTIWRN,<XP TTIWRN,^D200>		;DEFAULT ASCII/IMAGE XOFF WARNING LEVEL
IFNDEF TTIMAX,<XP TTIMAX,TTIWRN+<5*TTYMIC>>  ;DEFAULT ASCII/IMAGE MAXIMUM LEVEL
IFNDEF TTPBRK,<XP TTPBRK,^D132>		;DEFAULT PIM MODE LINE "BREAK" LEVEL
IFNDEF TTPWRN,<XP TTPWRN,^D500>		;DEFAULT PIM MODE XOFF WARNING LEVEL
IFNDEF TTPMAX,<XP TTPMAX,TTPWRN+<5*TTYMIC>>  ;DEFAULT PIM MODE MAXIMUM LEVEL


IFG XTCN,<		;GENERATE TABLE FOR DA28 POOL
TTLTAB::BLOCK	TTD28N		;KON,,UNIT
XP MTTD28,-TTD28N		;MINUS # OF DA28 LINES
>
;SOME SPACE FOR A SLOT ALLOCATION BIT TABLE FOR LAT TERMINALS
NTTLAH==:M.RMCR			;Number of LAT TTYs = number of network TTYs
NSBWDS==:<NTTLAH+^D35>/^D36	;One bit for each slot we could have
NFRSBQ::	BLOCK	NSBWDS

IFNDEF MDSLN,<MDSLN==:0>

;DEFINE A BIT TABLE SHOWING WHICH LINES WERE MONGEN'ED AS DATASETS
DSDTAB::
SALL
DEFINE GENLIN(N),<
.XCREF
IFDEF DSD'N,<IFN DSD'N,<DSDW==DSDW!ZZZ>>
.CREF
> ;END DEFINE GENLIN
	ZZ==0			;STARTING LINE NUMBER
REPEAT <M.TLTL+^D31>/^D32,<
ZZZ==1B0
DSDW==0
REPEAT ^D32,<
GENLIN(\ZZ)
ZZZ==ZZZ_-1
ZZ==ZZ+1
>
EXP DSDW
> ;END OF BUILDING DSDTAB
;SCNSER QUEUED PROTOCOL HEADERS
DEFINE QHED(N)<
IFN M'N'TTG0,<DL0TQ'N::EXP 0,0>
IFN M'N'TTG1,<DL1TQ'N::EXP 0,0>
IFN M'N'68L0,<CC0TQ'N::EXP 0,0>
IFN M'N'68L1,<CC1TQ'N::EXP 0,0>
IFN M'N'D70N,<D70TQ'N::EXP 0,0>
IFN M'N'D71N,<D71TQ'N::EXP 0,0>
IFN M'N'D72N,<D72TQ'N::EXP 0,0>
IFN M'N'D73N,<D73TQ'N::EXP 0,0>
IFN M'N'D74N,<D74TQ'N::EXP 0,0>
IFN M'N'D75N,<D75TQ'N::EXP 0,0>
IFN M'N'D76N,<D75TQ'N::EXP 0,0>
IFN M'N'D77N,<D77TQ'N::EXP 0,0>
IFN M'N'DZNL,<DZTQ'N::EXP 0,0>
>
IFN M.XTL,<XTTQUE::EXP 0,0>

ZZ=0
REPEAT CPUN,<
	QHED(\ZZ)
ZZ==ZZ+1
>

MCRRTQ::EXP 0,0			;NETWORK TERMINALS CAN RUN ON ANY CPU
				; HENCE THEY HAVE A QUEUE OF THEIR OWN.
VTMQUE::EXP 0,0			;SPECIAL QUEUE FOR NETWORK VIRTUAL TERMINALS
FRCQUE::EXP 0,0			;FORCE COMMAND LDB FAKE OUTPUT HEADER
;HERE ONCE A TICK TO START TERMINAL OUTPUT

DEFINE TTSTRT(FT,QH,RT),<
IFN FT,<
IFNB <QH>,<
	MOVEI	T1,QH
>
	PUSHJ	P,RT##
>>
DEFINE STRG(N),<

SC'N'TIC::SE1ENT
	TTSTRT(M'N'TTG0,DL0TQ'N,DL0STO)
	TTSTRT(M'N'TTG1,DL1TQ'N,DL1STO)
	TTSTRT(M'N'D70N,D70TQ'N,D76STO)
	TTSTRT(M'N'D71N,D71TQ'N,D76STO)
	TTSTRT(M'N'D72N,D72TQ'N,D76STO)
	TTSTRT(M'N'D73N,D73TQ'N,D76STO)
	TTSTRT(M'N'D74N,D74TQ'N,D76STO)
	TTSTRT(M'N'D75N,D75TQ'N,D76STO)
	TTSTRT(M'N'D76N,D76TQ'N,D76STO)
	TTSTRT(M'N'D77N,D77TQ'N,D76STO)
	TTSTRT(M'N'DZNL,DZTQ'N,DZSTO)
	TTSTRT(FTKS10,,CTYSTO)
	TTSTRT(FTKL10,,TTDSTO)
	TTSTRT(M.RMCR,,NETSTO)
	TTSTRT(M.DECN,,NRTSTO)
	TTSTRT(M.LATN,,LATSTO)
	POPJ	P,
>
$HIGH
ZZ==0
REPEAT CPUN,<
	STRG(\ZZ)
ZZ==ZZ+1
>
;HERE ONCE A SECOND FROM SCNSER
;ONLY ENTRIES HERE ARE ONES WHOSE ISR DISPATCH DOES SOMETHING

DEFINE TTSECN(FT,DSP),<
IFN FT,<PUSHJ P,DSP##+ISRCHK>
>

DEFINE STRG(N),<
SC'N'SEC::SE1ENT
	TTSECN(M'N'TTG0,DL0DSP)
	TTSECN(M'N'TTG1,DL1DSP)
	TTSECN(M'N'68L0,CC0DSP)
	TTSECN(M'N'68L1,CC1DSP)
	TTSECN(M'N'DZNL,DZDSP)
	TTSECN(FTKL10,CTYDSP)
	TTSECN(M.DECN,NRTDSP)
	TTSECN(M.LATN,LATDSP)
	POPJ	P,
>
ZZ==0
REPEAT CPUN,<
	STRG(\ZZ)
ZZ==ZZ+1
>
;THE TTY COMMAND MAP HAS 1 BIT PER LINE ARRANGED 32 BITS PER WORD
;THUS LINE 0 IS BIT 0 OF WORD 0, LINE 37(8) IS BIT 31 OF WORD 0,
; LINE 40(8) IS BIT 0 OF WORD 1, AND SO ON.
$LOW
TTMAPN==<TTPLEN/^D32>+1
CMDMAP::BLOCK	TTMAPN		;TTY COMMAND BIT MAP
$HIGH

REPEAT	0,<			;FOR HISTORICAL REASONS
;TTYCMD IS CALLED ON EVERY CLOCK TICK TO LOOK FOR A COMMAND. IF THERE
; IS A COMMAND WAITING IT CALLS COMCON TO PROCESS IT. COMCON IN TURN
; CALLS TTFCOM WHICH SCANS CMDMAP TO FIND THE COMMAND.  THE ENTIRE
; PROCESS IS VERY FAST AND IS NOT ERROR PRONE.
TTYCMD::	;HERE TO TEST FOR A COMMAND
	ZZ==0
REPEAT TTMAPN,<
	SKIPE	CMDMAP+ZZ	;ANY COMMANDS IN THIS GROUP?
	PJRST	COMMAND##	;YES--CALL COMCON
	ZZ==ZZ+1
	XLIST
>;END REPEAT
	LIST
	POPJ	P,0
>  ;END REPEAT 0

XP TTCMPT,-TTMAPN	;AOBJN POINTER TO COMMAND MAP
TTDALT::	;XCTED IN SCNSER TO SET TTY ALT DEFAULT
IFE TTYALT,<
	IORM	T1,LDBPAG##(U)	;NORMAL DEFAULT IS TTY NO ALT
>
IFN TTYALT,<
	ANDCAM	T1,LDBPAG##(U)	;IF LOTS OF 33S AND 35S
>
	SUBTTL	TERMINAL DATA BASE -- TERMINAL CHARACTERISTICS DEFINITION

TTPWID::POINT	8,TCRTAB(T1),7	;POINTER TO TERMINAL WIDTH
TTPLNB::POINT	6,TCRTAB(T1),13	;POINTER TO TERMINAL LENGTH
TTPFRM::POINT	1,TCRTAB(T1),14	;ON IF TERMINAL HAS HARDWARE FORM FEEDS
TTPTAB::POINT	1,TCRTAB(T1),15	;ON IF TERMINAL HAS HARDWARE TABS
TTPLCT::POINT	1,TCRTAB(T1),16	;ON IF TERMINAL DOESN'T HAVE LOWER CASE CHARACTERS
TTPALT::POINT	1,TCRTAB(T1),17	;ON IF NO ALTMODE CONVERSION IS REQUIRED
TTPDIS::POINT	1,TCRTAB(T1),18	;ON IF "DISPLAY" TERMINAL (E.G., FOR DDT)
TTPNFC::POINT	1,TCRTAB(T1),19	;ON IF TERMINAL NO CRLF
TTPXNF::POINT	1,TCRTAB(T1),20	;ON IF TERMINAL HAS ^S/^Q
TTP8BT::POINT	1,TCRTAB(T1),21	;ON IF TERMINAL HAS 8-BIT ASCII CHARACTER SET
TTPFLC::POINT	2,TCRTAB(T1),35	;POINTER TO DEFAULT FILL CLASS

DEFINE CUSTRM,<		;CUSTOMER TERMINAL TYPES
	SPCTRM		;MONGEN CUSTOMER TERMINAL TYPES
TERMCR	LA34,  132,  0, NOFF,   TAB,   LC, NOALT, NODIS, NOCRLF,   XON,	NO8BIT,  0,  0,  0
>

DEFINE DECTRM,<    ;DEC TERMINAL TYPES
TERMCR  TTY,    72,  0, NOFF, NOTAB, NOLC,   ALT, NODIS,   CRLF,   XON,	NO8BIT,  1,  0,  0
TERMCR  VT05,   72, 20, NOFF,   TAB, NOLC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  2, VT06EP, VTXXBP
TERMCR  VT06,   72, 25, NOFF, NOTAB, NOLC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  1, VT06EP, VT06BP
TERMCR  VT50,   80, 12, NOFF,   TAB, NOLC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, VTXXEP, VTXXBP
TERMCR  VT52,   80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, VTXXEP, VTXXBP
TERMCR  VT61,   80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, VTXXEP, VTXXBP
TERMCR  DAS21,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, VTXXEP, VTXXBP
TERMCR  VT100,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
TERMCR  TTY33,LT33,  72,  0, NOFF, NOTAB, NOLC,   ALT, NODIS,   CRLF,   XON,	NO8BIT,  1,   0,  0
TERMCR  TTY35,LT35,  72,  0,   FF,   TAB, NOLC,   ALT, NODIS,   CRLF,   XON,	NO8BIT,  1,   0,  0
TERMCR  LA30,   72,  0, NOFF, NOTAB, NOLC, NOALT, NODIS,   CRLF,   XON,	NO8BIT,  1,   0,  0
TERMCR  LA36,  132,  0, NOFF, NOTAB,   LC, NOALT, NODIS, NOCRLF,   XON,	NO8BIT,  0,   0,  0
TERMCR  2741,  128,  0, NOFF, NOTAB,   LC, NOALT, NODIS, NOCRLF,   XON,	NO8BIT,  3,   0,  0
TERMCR  LA38,  132,  0, NOFF,   TAB,   LC, NOALT, NODIS, NOCRLF,   XON,	NO8BIT,  0,   0,  0
TERMCR  LA120, 132,  0,   FF,   TAB,   LC, NOALT, NODIS, NOCRLF,   XON,	NO8BIT,  0,   0,  0
TERMCR  VT125,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
TERMCR  VK100,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
TERMCR  VT101,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
TERMCR  VT102,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
TERMCR  VT103,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
TERMCR  VT180,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
TERMCR  VT185,  80, 24, NOFF,   TAB,   LC, NOALT,   DIS,   CRLF,   XON,	NO8BIT,  0, V100EP, VTXXBP
>

DEFINE	TERMCR(NAME,ALIAS,WIDTH,LENGTH,$FF,$TAB,$LC,$ALT,$DIS,$CRLF,$XON,$8BIT,FILL,BPERAS,BPRUBO<**UNSPECIFIED**>),<
IFIDN <BPRUBO><**UNSPECIFIED**>,<TRMCR1	NAME,,ALIAS,WIDTH,LENGTH,$FF,$TAB,$LC,$ALT,$DIS,$CRLF,$XON,$8BIT,FILL,BPERAS>
IFDIF <BPRUBO><**UNSPECIFIED**>,<TRMCR1	NAME,ALIAS,WIDTH,LENGTH,$FF,$TAB,$LC,$ALT,$DIS,$CRLF,$XON,$8BIT,FILL,BPERAS,BPRUBO>
>
DEFINE	TRMCR1(NAME,ALIAS,WIDTH,LENGTH,$FF,$TAB,$LC,$ALT,$DIS,$CRLF,$XON,$8BIT,FILL,BPERAS,BPRUBO),<
X1==0
IFIDN <$FF><FF>,<X1==1>
X2==0
IFIDN <$TAB><TAB>,<X2==1>
X3==1
IFIDN <$LC><LC>,<X3==0>
X4==1
IFIDN <$ALT><ALT>,<X4==0>
X5==0
IFIDN <$DIS><DIS>,<X5==1>
X6==1
IFIDN <$CRLF><CRLF>,<X6==0>
X7==0
IFIDN <$XON><XON>,<X7==1>
X8==0
IFIDN <$8BIT><8BIT>,<X8==1>
IFNDEF T'NAME,<T'NAME:>
BYTE (8)^D'WIDTH(6)^D'LENGTH(1)X1(1)X2(1)X3(1)X4(1)X5(1)X6(1)X7(1)X8(12)0(2)FILL
IF2,<	.IF BPERAS,NEEDED,<EXTERN BPERAS>
	.IF BPRUBO,NEEDED,<EXTERN BPRUBO>
    >
	XWD	BPERAS,BPRUBO	;<CR> EOL,,B.S. SPACE B.S.
>

;EXPAND TERMINAL PARAMTERS

CTCTAB::CUSTRM
TCRTAB::DECTRM

DEFINE	TRMCR1(NAME,ALIAS,WIDTH,LENGTH,$FF,$TAB,$LC,$ALT,$DIS,$CRLF,$XON,$8BIT,FILL,BPERAS,BPRUBO),<
	EXP	SIXBIT	/NAME/
>

;EXPAND TERMINAL TYPES (FOR COMCON)

CTTWDT::CUSTRM
TTTWDT::DECTRM
TTTWDN==:.-CTTWDT

DEFINE	TRMCR1(NAME,ALIAS,WIDTH,LENGTH,$FF,$TAB,$LC,$ALT,$DIS,$CRLF,$XON,$8BIT,FILL,BPERAS,BPRUBO),<
IFNB	/ALIAS/,<
IFDIF	<NAME><ALIAS>,<	EXP	SIXBIT	/NAME/>
	>
>

;TABLE OF SIXBIT TERMINAL NAMES THAT ARE ALIASED FOR NRTSER
TRMTAB::CUSTRM
	DECTRM
TRMTBL==:.-TRMTAB	;LENGTH

DEFINE	TRMCR1(NAME,ALIAS,WIDTH,LENGTH,$FF,$TAB,$LC,$ALT,$DIS,$CRLF,$XON,$8BIT,FILL,BPERAS,BPRUBO),<
IFNB	/ALIAS/,<
IFDIF	<NAME><ALIAS>,<	EXP	SIXBIT	/ALIAS/>
	>
>

;TABLE OF SIXBIT ALIASES MATCHING TERMINAL NAMES ABOVE
TRMNAM::CUSTRM
	DECTRM
	SUBTTL	TERMINAL DATA BASE -- POINTERS FOR CURSOR SEQUENCES

VT06BP:	POINT	9,VT06TB
	POINT	9,VT06TB+2,8
	POINT	9,VT06TB+4,17
	POINT	9,VT06TB+6,26
	POINT	9,VT06TB+10,35
	POINT	9,VT06TB+13,8
	POINT	9,VT06TB+15,17
	POINT	9,VT06TB+17,26

VT06EP:	POINT	9,VT06EL
	POINT	9,VT06E1
	POINT	9,VT06E2
	POINT	9,VT06E3

VTXXBP:	POINT	9,VTXXTB
	POINT	9,VTXXTB,26
	POINT	9,VTXXTB+1,17
	POINT	9,VTXXTB+2,8
	POINT	9,VTXXTB+2,35
	POINT	9,VTXXTB+3,26
	POINT	9,VTXXTB+4,17
	POINT	9,VTXXTB+5,8

VTXXEP:	POINT	9,VTXXEL
	POINT	9,VTXXE1
	POINT	9,VTXXE2
	POINT	9,VTXXE2,17

V100EP:	POINT	9,VTXXEL
	POINT	9,V100E1
	POINT	9,V100E2
	POINT	9,V100E2,17
	SUBTTL	TERMINAL DATA BASE -- CURSOR CONTROL SEQUENCES

VT06TB:	BYTE	(9)	177,177,177,010,040,177,177,177
	BYTE	(9)	010,177,177,177,010,040,177,177
	BYTE	(9)	177,010,177,177,177,010,040,177
	BYTE	(9)	177,177,010,177,177,177,010,040
	BYTE	(9)	177,177,177,010,177,177,177,010
	BYTE	(9)	040,177,177,177,010,177,177,177
	BYTE	(9)	010,040,177,177,177,010,177,177
	BYTE	(9)	177,010,040,177,177,177,010,177
	BYTE	(9)	177,177,010,040,177,177,177,010
	BYTE	(9)	0

VT06EL:	BYTE	(9)	015,177,177,177,0
VT06E1:	BYTE	(9)	30,177,177,177,0
VT06E2:	BYTE	(9)	30,177,177,177
VT06E3:	BYTE	(9)	36,177,177,177,0

VTXXTB:	BYTE	(9)	010,040,010,010,040,010,010,040
	BYTE	(9)	010,010,040,010,010,040,010,010
	BYTE	(9)	040,010,010,040,010,010,040,010
	BYTE	(9)	0

VTXXEL:	BYTE	(9)	015,0
VTXXE1:	BYTE	(9)	33,103,0
VTXXE2:	BYTE	(9)	33,103,33,113,0

V100E1:	BYTE	(9)	233,103,0
V100E2:	BYTE	(9)	233,103,233,113,0
	SUBTTL	DTESER DATA BASE GENERATION

	$LOW

IFN FTKL10,<
	.XCREF
;GENERATE FRONT END DEVICE BLOCKS

	FEDGEN

;GENERATE HEADER FOR COMM REGION

	ETHEAD

;GENERATE COMM REGION ITSELF

	ETREGN

;GENERATE DTE CONTROL BLOCKS

	ETDGEN

;GENERATE TABLE OF CORRESPONDENCE BETWEEN CPU#,DTE# AND DTE CONTROL BLOCKS
	.CREF
	ETDTBX

;TABLE FOR MASTER DTE CONTROL BLOCK ADDRESS FOR EACH CPU

DEFINE	DFLMAS	(C),<
	EXP	ETD'C'1B
>

DTEMAS::
N10==0
REPEAT M.CPU,<
	DFLMAS	\N10
	N10==N10+1
>


;MACROS FOR RSX-20F DEVICE SYMBOLS AND STORAGE

DEFINE	RSX20F	<
	N10==0				;;INDEX FOR -10 CPU #
	REPEAT	M.CPU,<			;;DO FOR EACH CPU ON SYSTEM
		RSXCPU	\N10		;;CALL CPU MACRO
		N10==N10+1		;;STEP TO NEXT CPU
	>
>

DEFINE	RSXCPU	(C)	<
   IFDEF M'C'DTEN,<			;;DO ONLY IF DTE(S) ON THIS CPU
	N11==0				;;INDEX FOR -11 CPU (DTE) #
	REPEAT	M'C'DTEN,<		;;DO FOR ALL DTE'S
		RSXDTE	\C,\N11		;;CALL CURRENT DTE MACRO
		N11==N11+1		;;STEP TO NEXT -11 (DTE)
	>
   >
>


> ;END FTKL10


	SUBTTL	NETWORK SYMBOLS FOR NON-NETWORK SYSTEMS

IFE M.NET,<			;IF MONGEN ANSWER IS NO THEN DEFINE SYMBOLS
NODE.U==:CPOPJ##		;ILLEGAL UUO
TSTNET==:CPOPJ##		;NO NETWORK DEVICES
GENNET==:CPOPJ##
NET2ND==:CPOPJ##
HOST.U==:CPOPJ##
SRCNDB==:CPOPJ##
NETCTC==:CPOPJ##
ZAPNET==:CPOPJ##
STBSCA==:CPOPJ##
D85DSC==:ECOD4##
RDA$IN==:CPOPJ##
CDR$IN==:CPOPJ##
NETRTY::0			;NO NETWORK TTYS
NDBNNM==:0			;NO STATION BLOCKS
NETDSP==:0			;NO SERVICE ROUTINE
STBOPR::PUSH	P,U		;SAVE LDB
	MOVE	U,OPRLDB##	;GET CENTRAL (ONLY) OPR LDB
	LDB	T1,LDPLNO##	;GET LINE NUMBER
	PJRST	UPOPJ##		;RESTORE AC AND RETURN.
>;END IFE M.NET

IFE M.DN6S,<
IFN FTKL10,<
D6SDDS==:EATDSP##
>
D60UP==:CPOPJ##
D60DWN==:CPOPJ##
>
IFN M.KL10,<
IFE M.DN6S,<
D6SED==:ECOD2##
D6SQ11==:ECOD2##
DWND6S==:STOTAC##
D6STMO==:CPOPJ##
>
IFE M.DN6D,<
D6DED==:ECOD2##
D6DQ11==:ECOD2##
>
>;END IFN M.KI10!M.KL10

IFN M.KL10&FTNET,<
IFE <M.NET>*<M.DN8S>,<		;IF NONETWORKS OR NO DN87S'S
NCLDSP==:EATDSP##
>
>;END IFN M.KL10&FTNET

IFE <M.NET!M.DAS78!M.DN60>,<	 ;NEITHER NETWORKS, DAS78S, NOR DN60S
WHERE==:CPOPJ##
LOCATE==:CPOPJ##
>	;END IFE <M.NET!M.DAS78!M.DN60>

IFN M.DN60,<IFE M.NET,<SRCNDB==:CPOPJ>>	;GIVE NONSKIP RETURN
IFNDEF M.KDUP,<M.KDUP==0>
IFNDEF M.DMRN,<M.DMRN==0>
IFN M.NET!M.DC76,<		;ANY IBM 2741 FE SUPPORT
	$HIGH
;SUBROUTINE EXEINX - RETURN AN INDEX TO THE GOLF BALL NUMBER
;CALL	MOVEI	T3,BALL NUMBER(BINARY)
;	PUSHJ	P,ELEINX
;RETURN	CPOPJ			;NOT IN THE TABLE
;	CPOPJ1			;FOUND T2=INDEX
ELEINX::MOVSI	T2,-ELELEN	;SIZE OF TABLE
	CAME	T3,ELETAB(T2)	;MATCH
	AOBJN	T2,.-1		;NO--LOOP FOR MORE
	JUMPGE	T2,CPOPJ##	;EXIT IF NOT FOUND
	PJRST	CPOPJ1##	;GOOD RETURN
	RADIX	10
ELETAB::EXP	029,087,938,963,987,988
	RADIX	8
ELELEN==.-ELETAB
	$LOW
>;END M.NET!M.DC76

IFN	FTXTC,<
IFN	M.XTC,<


XP	MX11BF,^D129	;MAXIMUM PDP-11 IMAGE BINARY BUFFER SIZE
DEFINE	XTCDEF	(X),<
	IFNDEF	XT'X'S,<XT'X'S==420+X*10>
	IFNDEF	XT'X'C,<XT'X'C==:424+X*10>
XP	XKBSKP,400450

XT'X'INT:: CONSO	XT'X'C,XKBSKP	;EXTERNAL PROCESSOR INTERRUPT?
	JRST	.-1		;NO, GO DOWN THE SKIP CHAIN
	JSR	XT'X'SAV##	;SAVE ALL THE AC'S
	PUSHJ	P,SAVE4##	; ..
	JSP	W,XTCINT##	;CALL XTCSER

XP	XTCCHN,XT'X'CHN##

DEFINE	XTLNK	(A) <
	IFN	A-XTCN,<
XKBKDB::!EXP	XKB'A'		;LINK TO NEXT KDB
>
	IFE	A-XTCN,<
XKBKDB::!EXP	0		;NO MORE KDB'S
>
>
XP	XKBINT,<XT'X'INT-.>

Z=X+1
XKB'X::	PHASE	0		;BEGIN CONTROLLER DATA BLOCK
XKBNAM::!XWD	'EPA'+X,0	;EP NAME
	XTLNK	\Z		;LINK TO NEXT KDB
XKBUDB::!BLOCK	21		;SPACE FOR LINKS TO UDBS
XTSCNO::!CONO	XT'X'S,(T1)
XTCCNO::!CONO	XT'X'C,(T1)
XTSCNI::!CONI	XT'X'S,T1
XTCCNI::!CONI	XT'X'C,T1
XTSDTI::!DATAI	XT'X'S,T1
XTCDTI::!DATAI	XT'X'C,T1
XTCDTO::!DATAO	XT'X'C,T1
XTSDTO::!DATAO	XT'X'S,T2
XTCBSY::!CONSZ	XT'X'C,20
XKBLOK::!EXP	-1		;INTERLOCK
XKBDDB::!BLOCK	1		;POINTER TO DDB WAITING FOR INTRPT
XKBIUN::!BLOCK	1		;POINTER TO UDB WAITING FOR INTERRUPT
XKBDAC::!BLOCK	1		;INFO FROM LAST CONI DAC
XKBDAS::!BLOCK	1		;INFO FROM LAST CONI DAS
XKBTIM::!BLOCK	1		;COUNTER FOR TIMEOUT
XKBIOW::!BLOCK	1		;IOWD FOR DAC OR PNTR TO IOLIST
XKBCUR::!BLOCK	1		;CUR PNTR TO IOLIST (KI10 ONLY)
XKBGRB::!Z			;0 IF FREE 1 IF GRABBING
				;CONTROL -1 IF GRABBED
XKBPAC::!BLOCK	1		;# OF PSEUDO ACTIVE DDB'S ON THIS
				; CONTROLLER
XKBREQ::!BLOCK	1		;OLDEST JOB # REQUESTING USE OF UDB
XKBMBF::!BLOCK	<MX11BF*3>/2	;MONITOR BUFFER
	DEPHASE

>
	ZZ=0
	IFE	XTCN,<
XTUUO==:CPOPJ##			;NO XTUUO IF NO XTCSER
XTKLDB==:CPOPJ##		;ALSO NO DDB KILLER
XTCTTY::AOS	(P)		;DOUBLE SKIP
	JRST	CPOPJ1##
XTCTYP==:CPOPJ##
>

	IFN	XTCN,<EXTERN XTCSER>		;LOAD XTCSER IF NEEDED

	REPEAT	XTCN,<
	XTCDEF	(\ZZ)
	ZZ=ZZ+1
>
>>	;;END OF FTXTC FEATURE
SUBTTL MAGTAPE DATA BASE FOR TAPSER

IFG TAPN,<

	EXTERN	TAPSER,TAPUUO

;SOME GENERALLY USEFUL MACROS

DEFINE	CALUNI (Y,EMACR) <
	..UNI==0
	REPEAT	M.MT'Y,<
	  GENUNI (Y,\..UNI,EMACR)
	  ..UNI==..UNI+1>
>

DEFINE	UNIMAC (A,B) <
	..U'A'B>

DEFINE	CHNMAC (Z) <
	CHN'Z'CB##>

;NOTE:  ANY CHANGE TO THE DDB STRUCTURE SHOULD
;	ALSO BE MADE TO THE LABEL DDB PROTOTYPE
;	DEFINED IN TAPUUO.
DEFINE	GENDDB (X,Y) <

MT'X'DDB::	<SIXBIT	/MTA0/>+<X>_^D18	;(0)  DEVNAM
	<^D5*HUNGST>,,MTSIZ+1  ;(1)  DEVCHR
	0			;(2)  DEVIOS
	TPMDSP##		;(3)  DEVSER
DVLNG!1023,,154403+BYTBIT	;(4)  DEVMOD
	0			;(5)  DEVLOG
	0			;(6)  DEVBUF
	0			;(7)  DEVIAD
	0			;(10) DEVOAD
	;;BITS 0-13 ARE USED FOR FRAME-COUNT
	0			;(11) DEVSTS
	.TYMTA!DEPLEN,,Y*DEPEVM	;(12) DEVSTA
	2B<DENHCI>		;(13) DEVXTR
		DESHCT==:^D3	;HUNG COUNTER SIZE (Q'D/ASYNCH I/O ONLY)
		DENHCI==:^D2	;VALUE TO INITIALIZE AT
		DENHCT==:^D5	;THE BIT
;BITS 0-2 ARE NUMBER OF TIMES WE ALLOW A Q'D PROTOCAL OR ASYNCRONOUS I/O
;REQUEST TO TIME OUT (IF IT WASN'T ACTUALLY STARTED YET) BEFORE REALLY
;HANGING THE DEVICE.
;BITS 3-5 ARE THE COUNTER (COUNTS FROM CONTENTS OF BITS 0-2 TO ZERO)
;DEFAULT IS 2 TIMES TOTAL THROUGH THE HUNG CODE.
	;BITS 22-30 = NUMBER OF INPUT BUFFERS
	0			;(14) DEVEVM
	0			;(15) DEVPSI
	0			;(16) DEVESE
	0			;(17) DEVHCW
	2000*Y+M.MT'X'P*100000,,0 ;(20) DEVCPU .QUEUED PROTOCOL IF NOT TM10A
	0			;(21) DEVISN
	0			;(22) DEVJOB
	0			;(23) DEVFIL
	0			;(24) DEVEXT
	0			;(25) DEVPPN
IFN FTKL10&FTMP,<
	0			;(26) DEVNBF
	0			;(27) DEVSBF
	0			;(30) DEVCSN
>

	 PHASE	DEVLLD+IFN FTKL10&FTMP,<3>

TDVUDB::!			;LH = UDB PNTR
TDVKDB::! ..U'X'0,,MT'X'KDB	;RH = KDB PNTR (PRIME CONTROLLER)
TDVSTS::! 0			;UNIT STATUS INFO
TDVIOR::! 0			;IORB TO WAIT FOR
TDVSUL::! 0			;SAVED USER UPPER LIMIT
TDVSLL::! 0			;SAVED USER LOWER LIMIT
TDVSVM::! 0			;SAVED M FOR DUMP MODE
TDVREM::! 0			;REMAINDER FOR MODE 16

	 DEPHASE

XP MT'X'DDS,.-MT'X'DDB		;SIZE OF DDB
>	;END GENDDB MACRO
;MACRO TO GENERATE A KDB

DEFINE	GENKDB (X,KMACR) <

MT'X'INT::
IFE M.KS10,<
	CONSO	MT'X'S,0	;INTERUPT INSTRUCTION
	JRST	.-1
>
IFN M.KS10,<
	0			;VECTORRED INTERRUPT JSR'S TO HERE
	EXP	0,IC.UOU,.+1	;XPCW BLOCK

	EXCH	T1,MT'X'INT	;GET INTERRUPT PC
	MOVEM	T1,MT'X'CHL##	;STORE IN "CH'PI" SO JEN WILL DISMISS CORRECTLY
	MOVE	T1,MT'X'INT+1	;SECOND WORD
	MOVEM	T1,MT'X'CHL##+1	;FOR XJEN

	MOVE	T1,MT'X'INT	;AND RESTORE T1
>;END IFN M.KS10
IFN FTAUTC,<
	JSR	0		;AUTCON WILL FILL THIS IN
>
IFE FTAUTC,<
	JSR	MT'X'SAV##	;SAVE ACS
>
	JSP	W,TAPINT##
XP TKBCSO,MT'X'INT-.		;OFFSET OF CONSO INSTR FROM KDB
MT'X'KDB:: PHASE 0
TKBNAM::!
IFN FTAUTC,<0>
IFE FTAUTC,<
<SIXBIT /MT0/>+<X>B17
>
TKBCNT::! 0			;(1) NUMBER OF RECORDS DONE ON THIS OPERATION
TKBKDB::!
IFN FTAUTC,<0>
IFE FTAUTC,<
	IFE <X-TAPN+1>,<0>	;(2) LINK TO NEXT KDB
	IFN <X-TAPN+1>,<MTLINK (\<X+1>)>
>
TKBIUN::! -M.MT'X,,TKBUDB+IFE FTAUTC,<MT'X'KDB> ;(3) INITIAL UNIT AOBJN PNTR
TKBCUN::! -M.MT'X,,TKBUDB+IFE FTAUTC,<MT'X'KDB> ;(4) CURRENT UNIT AOBJN PNTR
TKBDSP::! MT'X'DSP		;(5) KONTROLLER DISPATCH
TKBSTS::!
IFN FTAUTC,<0>
IFE FTAUTC,<
 BYTE	(3)M.MT'X'P(33)0 ;(6) KONTROLLER STATUS
>
				;(RH) CONSECUTIVE OPS REMAINING
TKBICP::
IFN FTAUTC,<0>
IFE FTAUTC,<
	 IFE M.MT'X'T-K.TMA,<
		MTALOC##+1000*M.MT'X'P>	;PI CHL FOR TM10A
	 IFE M.MT'X'T-K.TMB,<
		$LOCW*4+LOCOCW##
		$LOCW==$LOCW+1>	;TM10B
	 IFE M.MT'X'T-K.TC1,<
		$LOCW*4+LOCOCW##
		$LOCW==$LOCW+1>	;TC10C
	 IFE M.MT'X'T-K.TX1,<
		$LOCD*4+LOCODW##
		$LOCD==$LOCD+1>	;DX10 TYPE
	 IFE M.MT'X'T-K.TM2,<
		IFLE M.T2'X'T,<
		$LOCW*4+LOCOCW##
		$LOCW==$LOCW+1>	;TM02 ON RH10
	IFG M.T2'X'T,<
		ZZ==4*M.T2'X'T
		IFE ZZ-40,<ZZ==0>
		.E0MP+ZZ+2000*M.MT'X'P
		>
		>
	 IFE M.MT'X'T-K.DX2,<
		ZZ==4*M.D2'X'T
		IFE ZZ-40,<ZZ==0>
		.E0MP+ZZ+2000*M.MT'X'P
		>
	 IFE M.MT'X'T-K.T78,<
		ZZ==4*M.T7'X'T
		IFE ZZ-40,<ZZ==0>
		.E0MP+ZZ+2000*M.MT'X'P
		>
>
TKBTIM::! 0			;(10) TIMER FOR SPACING OPS
TKBCDB::!
IFN FTAUTC,<0>
IFE FTAUTC,<
IFE M.MT'X'T,<0>	;(11) PNTR TO CHL IF NOT TM11A
IFN M.MT'X'T,<CHNMAC(\M.MT'X'C)>
>
TKBJOB::! 0			;(12) JOB NUMBER OF MAINT-MODE OWNER
				; TKBJOB MUST IMMEDIATELY PRECEDE TKBCCL
	TKWCCL==:5		;NUMBER OF WORDS IN CHANNEL COMMAND LIST
TKBCCL::! BLOCK	TKWCCL		;(13) CHANNEL COMMAND LIST
TKBERB::!
IFN FTAUTC,<0>
IFE FTAUTC,<
	MT'X'DDB		;(21) IORB FOR ERROR RECOVERY
>
	  BLOCK 3		;ADDR OF DDB AT ONCE ONLY
IFN FTMP,<
TKBFCT::!EXP	TKBICT		;FAIRNESS COUNT TO ALLOW QUEUED I/O TO START
				; EVEN IF PENDING REQUESTS ON THIS CPU
>
TKBUDB::! ..UNI==0
IFE FTAUTC,<
	REPEAT	M.MT'X,<
	  UNIMAC (X,\..UNI)
	  ..UNI==..UNI+1>
	BLOCK	^D8-M.MT'X	;ALLOW FOR 8 MAX UNITS
>
IFN FTAUTC,<
	BLOCK	^D8
>
TKBUNI::!IFN FTAUTC,<0>
IFE FTAUTC,<
	XWD	M.MT'X'U,1_M.MT'X'U ;UNIT, ATTEN BIT FOR MULTI UNITS ON AN RH
				    ; NEGATIVE IF NON MULTI-UNIT CONTROLLER
>
IFE FTKS10,<
TKBVIN::!0			;VECTOR INTERRUPTS HERE
	0
	EXP	IC.UOU
	EXP	.+1+IFE FTAUTC,<MT'X'KDB>
	XCT	TKBCSO+2+IFE FTAUTC,<MT'X'KDB>	;JSR TAPSAV
	DMOVE	T1,TKBVIN+IFE FTAUTC,<MT'X'KDB>
	DMOVEM	T1,@.CPTCH##
	JRST	TKBCSO+3+IFE FTAUTC,<MT'X'KDB>	;GO TO JSP TAPINT

IFE M.MT'X'T-K.TM2,<
TKBIVI::!IFN FTAUTC,<0>		;DATAO CONTENTS TO SET UP INTERRUPT VECTOR
IFE FTAUTC,<
	IFLE M.T2'X'T,<444002,,$LOCW*4+LOCOCW##-1>
IFG M.T2'X'T,<
	ZZ==4*M.T2'X'T
	IFE ZZ-40,<ZZ==0>
	744400,,ZZ+3
	>
>	;END IFE FTAUTC
TT2CI2::!
TKBCIS::!CONI MT'X'S,T2
TKBDIS::!DATAI MT'X'S,T2
TKBDOS::!DATAO MT'X'S,T2
TT2CO1::!CONO MT'X'S,(T1)
TT2CO3::!CONO MT'X'S,(T3)
TT2UVA::!0			;TEMP FOR READ-BACKWARDS
> ;END IFE M.MT'X'T-K.TM2
IFE M.MT'X'T-K.T78,<
TKBIVI::!IFN FTAUTC,<0>
IFE FTAUTC,<
	ZZ==4*M.T7'X'T
	IFE ZZ-40,<ZZ==0>
	744400,,ZZ+3
>
TKBCIS::!CONI MT'X'S,T2
TKBDIS::!DATAI MT'X'S,T2
TKBDOS::!DATAO MT'X'S,T2
T78COS::!CONO MT'X'S,(T3)
T78UVA::!0
T78RRO::!0
T78ACT::!0			;;COUNT OF CONTINUOUS ASYNC INTERRUPTS
T78AMX==:^D10			;;MAX BEFORE SHUTTING DOWN THE TM78
T78XIW::!RH2TRA##!RH2LST##!<17_4>,,T78REG+30 ;IOWD TO READ ERROR LOG INFO
				;;MAKE SURE TO CHANGE T78CTG IF THIS CHANGES
> ;END IFE M.MT'X'T-K.T78
>	;END IFE FTKS10
	KMACR(X)		;KONTROLLER DEPENDENT DATA
	DEPHASE
> ;END DEFINE GENKDB

DEFINE	MTLINK (X) <MT'X'KDB>
;MACRO TO GENERATE ALL TAPE INFO

DEFINE	GENTAP (KON) <

	EXPNDK	(KON)		;DEFINE 7 TRACK UNITS AND 6250 BPI UNITS

IFLE <M.MT'KON'T-K.TMB>,<	;ALL TM10S
	MT'KON'DSP=TMXDSP##
	EXTERN	TMXKON
	DOTM10(KON,M.MT'KON'T)	;GEN FOR APPROPRIATE TYPE
>
IFE <M.MT'KON'T-K.TC1>,<	;TC10C
	MT'KON'DSP=TCXDSP##
	EXTERN	TCXKON
	MT'KON'S==724+4*<%TC10-M.TC'KON'P>	;TC10 STATUS REG
	CALUNI(KON,ETCMAC)	;GEN UNITS
	GENKDB(KON,KTCMAC)	;GE KDB
		BYTBIT==0_BYTMOD
	GENDDB(KON,1)		;DDB PROTOTYPE
	%TC10==%TC10+1	;ADVANCE TO NEXT TC10C
>
IFE <M.MT'KON'T-K.TX1>,<	;TX01
	MT'KON'DSP=TX1DSP##
	EXTERN	TX1KON
	MT'KON'S==220+4*<%DX10-M.TX'KON'P>
	IFG <MT'KON'S-224>,<MT'KON'S==MT'KON'S-174>
	;DX10 STATUS REG
	CALUNI(KON,ETXMAC)	;GEN UNITS
	GENKDB(KON,KTXMAC)	;GEN KDB
		BYTBIT==1_BYTMOD
	GENDDB(KON,1)		;DDB PROTOTYPE
	%DX10==%DX10+1	;ADVANCE TO NEXT DX10
				;TM02
>
IFE <M.MT'KON'T-K.TM2>,<
	MT'KON'DSP==TM2DSP##
	EXTERN	TM2KON
	IFLE	M.T2'KON'T,<
	MT'KON'S==270-4*M.T2'KON'T
	IFG <MT'KON'S-277>,<MT'KON'S==MT'KON'S+60>
	>
IFG	M.T2'KON'T,<
	MT'KON'S==540+4*<M.T2'KON'T>
	IFE <MT'KON'S-600>,<MT'KON'S==540>
	>
	CALUNI(KON,ET2MAC)
	GENKDB(KON,KT2MAC)
		BYTBIT==1_BYTMOD
	GENDDB(KON,1)
>
IFE <M.MT'KON'T-K.TM2H>,<	;RH11/TU45 FOR KS10
	MT'KON'DSP==TRHDSP##
	EXTERN TRHKON
	CALUNI(KON,ETRMAC)
	GENKDB(KON,KTRMAC)
		BYTBIT==1_BYTMOD
	GENDDB(KON,1)
>
IFE <M.MT'KON'T-K.DX2>,<	;RH20/DX20/TX02
	MT'KON'DSP==TD2DSP##
	EXTERN	TD2KON,DX2COM
	MT'KON'S==540+4*<M.D2'KON'T>
	IFE <MT'KON'S-600>,<MT'KON'S==540>
	CALUNI(KON,ED2MAC)
	GENKDB(KON,KD2MAC)
		BYTBIT==1_BYTMOD
	GENDDB(KON,1)
>
IFE <M.MT'KON'T-K.T78>,<	;RH20/TM78/TU78
	MT'KON'DSP==T78DSP##
	EXTERN	T78KON
	MT'KON'S==540+4*<M.T7'KON'T>
	IFE <MT'KON'S-600>,<MT'KON'S==540>
	CALUNI(KON,E78MAC)
	GENKDB(KON,K78MAC)
		BYTBIT==1_BYTMOD
	GENDDB(KON,1)
>
>

DEFINE DOTM10 (KON,TYP) <
	MT'KON'C==340+10*<%TM10-M.T1'KON'P>S	;TM10 COMMAND REG
	MT'KON'S==MT'KON'C+4	;TM10 STATUS REG
	CALUNI(KON,ETMMAC)	;GEN UNITS
	GENKDB(KON,KTMMAC)	;GEN KDB
		BYTBIT==0_BYTMOD
	GENDDB(KON,TYP)		;GEN DDB PROTOTYPE FOR UNIT 0
	%TM10==%TM10+1		;ADVANCE TO NEXT UNIT
>
DEFINE TAPINS(X,Z) <
	REPEAT	M.MT'X'Z,<
	  UNIMAC(X,\..UNI)
	  ..UNI==..UNI+1>
  IFN M.MT'X'T-K.T78,<
	BLOCK	^D8-M.MT'X'Z
	..UNI==..UNI+^D8-M.MT'X'Z
   >
  IFE M.MT'X'T-K.T78,<
	BLOCK	4-M.MT'X'Z
	..UNI==..UNI+4-M.MT'X'Z
   >
>
;MACROS TO FIGURE OUT WHICH UNITS ARE 7 TRACK OR CAPABLE OF 6250 BPI

DEFINE	EXPNDK	(K) <
	..X=7
	MACKN'K (K)
	..X=6
	MACK6'K (K)>

DEFINE	KN (A,B,C<0>) <
	IFIDN	<B>,<ALL>,<TKREP (\..X,A,0,M.MT'A)>
	IFDIF	<B>,<ALL>,<TKREP (\..X,A,B,C)>
>

DEFINE	TKREP	(X,A,B,C) <
	IFE	C,<DEF'X (A,\B)>
	IFN	C,<
	..UNI==B
	REPEAT	<C-B+1>,<
	    DEF'X (A,\..UNI)
	    ..UNI==..UNI+1>
	>
>

DEFINE	DEF7 (K,U) <XP M.M7'K'U,1>

DEFINE	DEF6 (K,U) <XP M.M6'K'U,1>
;MACRO TO GENERATE A UDB

DEFINE	GENUNI(Y,U,EMACR) <

..U'Y'U::! PHASE 0
TUBNAM::! SIXBIT /MT'Y'U/	;(0) UNIT NAME
TUBKDB::! 0,,MT'Y'KDB		;(1) PNTR TO OWNING KONTROLLERS
TUBADR::! 0,,U			;(2) UNIT ADDRS ON KONTROLLER
TUBAKA::! 0			;(3) LH = UNIT ADDRS (CURRENT)
				;    RH = CURRENT KONTROLLER
TUBDDB::! 0			;(4) PNTR TO DDB'S
TUBCUR::! 0			;(5) POINTER TO CURRENT DDB
IFDEF M.M7'Y'U,<..X==TUCDR7##>	;7 TRACK TAPE
IFNDEF M.M7'Y'U,<		;NOT 7 TRACK TAPE
	IFLE	<M.MT'Y'T-K.TMB>,<..X==TUCDR8##> ;TM10 9 TRACK
	IFE	<M.MT'Y'T-K.TC1>,<..X==TUCDR6##> ;TC10C 800/1600 BPI
	IFE	<M.MT'Y'T-K.TX1>,<
	IFNDEF	M.M6'Y'U,<..X==TUCDR6##>	;TU70 800/1600 BPI
	IFDEF	M.M6'Y'U,<..X==TUCDR5##>	;TU72 1600/6250 BPI
	>
	IFE	<M.MT'Y'T-K.TM2>,<..X==TUCDR6##> ;TM02 800/1600 BPI
	IFE	<M.MT'Y'T-K.TM2H>,<..X==TUCDR6##> ;RH11/TU45 800/1600 BPI
	IFE	<M.MT'Y'T-K.DX2>,<
	IFNDEF M.M6'Y'U,<..X==TUCDR6##>	;DX20/TU70 800/1600 BPI
	IFDEF  M.M6'Y'U,<..X==TUCDR5##>	;DX20/TU72 1600/6250 BPI
	>
	IFE 	<M.MT'Y'T-K.T78>,<..X==TUCDR5##> ;TM78 1600/6250 BPI
>
TUBCNF::!			;(6) CONFIG INFO (RH)
TUBSTS::!..X+M.MT'Y'T		;    UNIT STATUS (LH)
TUBQUE::! 0			;(7) QUEUE PNTR FOR IORB'S
TUBERR::! 0			;(10) ERROR RECOVERY INFO
TUBRID::! 0			;(11) REELID (DAEMON KNOWS ABT THIS AREA)
TUBFIL::! 0			;(12) # OF FILES FROM BOT
TUBREC::! 0			;(13) # OF RECORDS FROM EOF
TUBCRD::! 0			;(14) # CHARS READ SINCE UNLOAD
TUBCWR::! 0			;(15) # CHARS WRITTEN SINCE UNLOAD
TUBSRE::! 0			;(16) SOFT READ ERRORS
TUBHRE::! 0			;(17) HARD READ ERRORS
TUBSWE::! 0			;(20) SOFT WRITE ERRORS
TUBHWE::! 0			;(21) HARD WRITE ERRORS
TUBTME::! 0			;(22) TOTAL MEDIA ERRORS SINCE UNLOAD
TUBCLE==:.-1			;     END OF AREA TO CLEAR
TUBTDE::! 0			;(23) TOTAL DEVICE ERRORS SINCE RELOAD
TUBTUN::! 0			;(24) TOTAL UNLOADS
TUBTRY::! 0			;(25) RETRIES TO RESOLVE ERROR
TUBCCR::! 0			;(26) CHAR CNT ON LAST REC
TUBPBE::! 0			;(27) POSITION BEFORE ERROR
				;     FILE,,RECORD
TUBFES::! 0			;(30) FINAL ERROR STATE WORD
TPCHMX==:.-TUBRID		;     MAX ARG ALLOWED FOR MTACHR UUO
TUBCHR::! 0			;(31) STATISTICS FOR MTCHR. UUO
TUBDDA::! BLOCK TUBTME-TUBRID+1	;SHADOW AREA FOR DAEMON
TUBDDE==:.-1			;END OF SHADOW AREA (DAEMON KNOWS ABT)
TUBPGM::!0			;PROGRAM NAME ON ERROR
TUBUID::!0			;PPN USING DRIVE ON ERROR
TUBCNI::! 0			;ERROR STATUS FOR NEXT RECORD
...X==0
IFE <M.MT'Y'T-K.TX1>,<...X==^D90>	;TU7X REWINDS QUICKLY
IFE <M.MT'Y'T-K.DX2>,<...X==^D90>
IFE <M.MT'Y'T-K.T78>,<...X==^D150>	;TU78S ARE FAIRLY FAST
TUBITM::!...X			;INITIAL VALUE FOR REWIND TIMER
TUBTIM::!0			;REWIND TIMER

IFN FTTLAB,<
TUBPTR::! 0			;BYTE POINTER TO FILE.EXT

TUBMSG::! XWD	TLMSIZ,.IPCTL##	;LENGTH,,FUNCTION CODE FOR LABEL MESSAGE
TUBPHY::! 0			;PHYSICAL NAME FOR LABEL PCS
TUBLBL::!			;LABEL STATUS WORD
IFNDEF M.M7'Y'U,<MTDLTP>
IFDEF M.M7'Y'U,<LT.BLP>
TLMSIZ==.-TUBMSG
TUBLIB::!			;START OF LABEL INFORMATION BLOCK
TUBRFM::!0			;RECORD FORMAT (FOR LABELS ONLY)
TUBRCC::!0			;RECORD SIZE (FOR LABELS ONLY)
TUBBKL::!0			;BLOCK SIZE (FOR LABELS ONLY)
TUBEXP::!0			;EXPIRATION DATE (FOR LABELS ONLY)
TUBPRT::!0			;PROTECTION (FOR LABELS ONLY)
TUBPSN::!0			;FILE POSITION #
TUBFNM::!BLOCK	<^D17+4>/5	;17 CHAR (ASCII) FILE NAME
TUBGVR::!0			;GENERATION + VERSION #
TLPMAX==:.-TUBLIB
>
	EMACR(Y)		;GENERATE ERROR INFO BLOCK
	DEPHASE
>
;SPECIFIC MACROS FOR VARIOUS CONTROLLERS

IFG M.TM10,<

DEFINE ETMMAC (X) <
TUBIEP::! -2,,TTMICC		;(30) INITIAL ERROR PNTR
TUBFEP::! -2,,TTMFCC		;(31) FINAL ERROR PNTR
TTMICC::! 0		;LAST ERROR INITIAL CONI MTC
TTMICS::! 0		;LAST ERROR INITIAL CONI MTS
TTMFCC::! 0		;LAST ERROR FINAL CONI MTC
TTMFCS::! 0		;LAST ERROR FINAL CONI MTS
>

DEFINE KTMMAC (X) <
TTMCOC::! CONO MT'X'C,(T1)
TTMCOS::! CONO MT'X'S,(T1)
TTMCIC::! CONI MT'X'C,T1
TTMCIS::! CONI MT'X'S,T1
TTMDOS::! DATAO MT'X'S,T1
TTMDIC::! DATAI MT'X'C,T1
TTMBLK::!
IFE	M.MT'X'T,<BLKI MT'X'C,(<BLKO MT'X'C,>)>
IFN	M.MT'X'T,<0>
TTMCHE::! 0		;-1 IF CHANNEL DETECTED ERROR
TTMJSR::!IFN M.MT'X'T,<0>	;JSR FOR TM10A BLKI/O STOP
	 IFE M.MT'X'T,<JSR MT'X'KDB+TTMEND
TTMEND::! 0			;HERE AT END OF DATA XFER
	  CONO 	MT'X'S,1	;STOP TAPE
	  JEN	@MT'X'KDB+TTMEND ;DISMISS INTERUPT
> ;;; END IFE M.MT'X'T
> ;;; END DEFINE KTMMAC
> ;;; END IFG M.TM10

IFG M.TX01,<

DEFINE ETXMAC (X) <
TUBIEP::! -^D20,,TTXIST		;(30) INITIAL ERROR PNTR
TUBFEP::! -^D20,,TTXFST		;(31) FINAL ERROR PNTR
TTXIST::! BLOCK	^D19	;LAST ERROR INITIAL STATUS
TTXISE::! BLOCK	1	;LAST WRD IN INITIAL STAYS
TTXFST::! BLOCK ^D20	;LAST ERROR FINAL STATUS
>

DEFINE KTXMAC (X) <
TTXCOS::! CONO	MT'X'S,(T1)
TTXCIS::! CONI MT'X'S,T1
TTXDOS::! DATAO	MT'X'S,T2
TTXDIS::! DATAI	MT'X'S,T2
TTXTMP::! BLOCK	1		;TEMP LOC FOR DX10
TTXULB::!			;MICROCODE LOADER BLOCK
	 EXP	.BTTX1##	;MICROCODE INDEX
	 XWD	0,-1		;DEVICE CODE,,UNIT NUMBER
	 SIXBIT	/TX01/		;INTERFACE NAME
	 SIXBIT	/DX10/		;CHANNEL NAME
	 EXP	TX1MVR##	;MINIMUM MICROCODE VERSION
	 EXP	0		;DATE/TIME OF LOAD SUCCESS OR FAILURE
	 EXP	0		;MICROCODE VERSION
	 EXP	0		;POINTER TO MAGIC TABLE
	 EXP	0		;MICROCODE LENGTH
	 EXP	0		;MICROCODE ADDRESS
	 CONI	0,T2		;CONI
	 CONO	0,(T2)		;CONO
	 DATAI	0,T2		;DATAI
	 DATAO	0,T2		;DATAO
>
>	;;; END IFG M.TX01
IFG M.TC10,<
DEFINE ETCMAC (X) <
TUBIEP::! -1,,TTCICS		;(30) INITIAL ERROR PNTR
TUBFEP::! -1,,TTCFCS		;(31) FINAL ERROR PNTR
TTCICS::! 0			;LAST ERROR INITIAL STATUS
TTCFCS::! 0			;LAST ERROR FINAL STATUS
>

DEFINE KTCMAC (X) <
TTCCOS::! CONO MT'X'S,(T1)
TTCCIS::! CONI MT'X'S,T1
TTCDOS::! DATAO MT'X'S,T1
TTCDIS::! DATAI MT'X'S,T1
>
>	;;; END IFG M.TC10

DEFINE ET2MAC (X) <
TUBIEP::! -16,,TT2ICS
TUBFEP::! -16,,TT2REG
TT2ICS::! BLOCK 16
TT2REG::! BLOCK 16
>
DEFINE KT2MAC (X) <
>

IFG M.TRH1,<
DEFINE ETRMAC (X) <
TUBIEP::! -16,,TRHICS
TUBFEP::! -16,,TRHREG
TRHICS::! BLOCK 16
TRHREG::! BLOCK 16
>
DEFINE KTRMAC (X) <
TRHVEC::!RH21IV			;;-11 STYLE INTERRUPT VECTOR ADDRESS
TRHBAS::!RH21CA			;;ADDRESS OF RH11 CONTROL REGISTER
				;; ALL OTHER REGISTERS OFFSET FROM HERE
TRHIVI::!XPCW	MT'X'INT	;;INTERRUPT INSTRUCTION

TRHUVA::!0			;;TEMP LOC FOR READ-BACKWARDS
>
>	;;END IFG M.TRH1

IFG M.DX20,<
DEFINE ED2MAC (X) <
..D2LN==.TD2MC+.TD2ES+.TD2MR	;SIZE OF FEP TABLE FOR DX20
TUBIEP::! -1,,TD2IST		;(30) INITIAL ERROR POINTER
TUBFEP::! -..D2LN,,TD2FST	;(31) FINAL ERROR POINTER
TD2IST::! BLOCK 1		;PLACE  HOLDER (NOT USED BY TD2KON)
TD2FST::! BLOCK	..D2LN		;LAST ERROR FINAL STATUS
>
DEFINE KD2MAC (X) <
TKBIVI::!IFN FTAUTC,<0>
IFE FTAUTC,<

	ZZ==4*M.D2'X'T
	IFE ZZ-40,<ZZ==0>
	744400,,ZZ+3
>
TKBCIS::! CONI MT'X'S,T2
TKBDIS::! DATAI MT'X'S,T2
TKBDOS::! DATAO MT'X'S,T2
TD2COS::! CONO MT'X'S,(T2)
TD2ULB::!			;MICROCODE LOADER BLOCK
	 EXP	.BTTX2##	;MICROCODE INDEX
	 XWD	0,-1		;DEVICE CODE,,UNIT NUMBER
	 SIXBIT	/TX02/		;INTERFACE NAME
	 SIXBIT	/DX20/		;CHANNEL NAME
	 EXP	TD2MVR##	;MINIMUM MICROCODE VERSION
	 EXP	0		;DATE/TIME OF LOAD SUCCESS OR FAILURE
	 EXP	0		;MICROCODE VERSION
	 IFIW	TD2MAG##	;POINTER TO MAGIC TABLE
	 EXP	0		;MICROCODE LENGTH
	 EXP	0		;MICROCODE ADDRESS
	 CONI	0,T2		;CONI
	 CONO	0,(T2)		;CONO
	 DATAI	0,T2		;DATAI
	 DATAO	0,T2		;DATAO
>
>	;; END IFG M.DX20
IFG M.TM78,<
DEFINE E78MAC (X) <
TUBIEP::! -50,,T78ICS
TUBFEP::! -50,,T78REG
T78ICS::! BLOCK	47
T78ISE::! BLOCK	1		;LAST WORD IN INITIAL STATISTICS
T78REG::! BLOCK	50
T78ESD::! BLOCK	1		;TEMP USED DURING ERROR SENSE
T78SNS::! BLOCK	1		;INDICATES A SENSE IS IN PROGRESS
>
DEFINE	K78MAC (X) < >
>	;;END IFG M.TM78
;NOW GENERATE THIS WHOLE MESS

%TM10==0
%DX10==0
%TC10==0
%TM02==0
%TM78==0
IFNDEF	TAPTIM,<XP TAPTIM,^D60>	;MAX TIME TO SKIP 10 RECORDS

IFNDEF DSETIM,<XP DSETIM,^D320> ;MAXIMUM TIME TO DO A DATA SECURITY ERASE
IFNDEF NOISE,<XP NOISE,^D12>  ;NOISE RECORD LENGTH IN BYTES
IFNDEF MQUANT,<XP MQUANT,^D10> ;CONSECUTIVE RECORDS
XP	NOISEW,NOISE/4

IFNDEF	TKBICT,<XP TKBICT,2> ;INITIAL FAIRNESS COUNT FOR QUEUED REQUEST
..KON==0		;INITIATE LOOP
$LOCW==ALLDSK		;FIRST AVAILABLE CHL PNTR
$LOCD==0		;DX10 CHL PNTR

IFN FTAUTC,<
TAPDST::0
TAPDEN::0
M.MT0==1
M.MT0T==K.TM2
M.MT0U==1
IFN M.TM02,<
MT0DSP==TM2DSP##
EXTERN TM2KON
>
IFE M.TM02,<		;STILL NEED THE KDB, UDB
MT0DSP==0		; BUT DON'T LOAD TM2KON
>
MT0S==650
TM2KDB::GENKDB(0,KT2MAC)
T2KLEN==:.-TM2KDB
IFN M.TX01,<
M.MT1==1
M.MT1T==K.TX1
MT1DSP==TX1DSP##
EXTERN TX1KON
M.MT1==1
MT1S==650
DX1KDB::GENKDB(1,KTXMAC)
DXKLEN==:.-DX1KDB
>
IFN FTKL10,<
IFN M.DX20,<
M.MT2==1
M.MT2T==K.DX2
MT2DSP=TD2DSP##
EXTERN	TD2KON,DX2COM
M.MT2U==1
MT2S==650
TX2KDB::GENKDB(2,KD2MAC)
TXKLEN==:.-TX2KDB
>
IFN M.TM78,<
M.MT3==1
M.MT3T==K.T78
MT3DSP==T78DSP##
EXTERN T78KON
M.MT3U==1
MT3S==650
T78KDB::GENKDB(3,K78MAC)
T8KLEN==:.-T78KDB
>
>
IFE M.TX01,<
DX1KDB==:0
DXKLEN==:0
DX1UDB==:0
DXULEN==:0
DX1CTG==:0
>
IFE M.DX20,<
TX2KDB==:0
TXKLEN==:0
TX2UDB==:0
TXULEN==:0
TX2CTG==:0
>
IFE M.TM78,<
T78KDB==:0
T8KLEN==:0
T78UDB==:0
T8ULEN==:0
T78CTG==:0
>
IFE FTKL10,<
TX2KDB==:0
TXKLEN==:0
T78KDB==:0
T8KLEN==:0
TX2UDB==:0
TXULEN==:0
TX2CTG==:0
T78UDB==:0
T8ULEN==:0
T78CTG==:0
>
TM2UDB::GENUNI(0,0,ET2MAC)
T2ULEN==:.-TM2UDB
TM2CTG==:0
IFN M.TX01,<
DX1UDB::GENUNI(1,0,ETXMAC)
DXULEN==:.-DX1UDB
DX1CTG==:^D20,,TTXFST
>
IFN FTKL10,<
IFN M.DX20,<
TX2UDB::GENUNI(2,0,ED2MAC)
TXULEN==:.-TX2UDB
TX2CTG==:0
>
IFN M.TM78,<
T78UDB::GENUNI(3,0,E78MAC)
T8ULEN==:.-T78UDB
T78CTG==:20,,T78REG+30
>
>
BYTBIT==1_BYTMOD
M.MT0P==0
GENDDB(0,0)
>
IFE FTAUTC,<
TAPDST::.
REPEAT TAPN,<
	GENTAP(\..KON)	;DO A CONTROLLER
	..KON==..KON+1	;ADVANCE TO NEXT
>
TAPDEN::.-1
>

;RANDOM BYTE PNTRS INTO DATA STRUCTURE

PMTCRC::POINT 9,TUBCHR(U),26	;LAST 9TK CRC (NRZI)
PMTNCR::POINT 3,TUBCHR(U),29	;BYTE RESIDUE OF LAST WORD
PBUFRM::POINT 14,DEVOAD(F),13
;RANDOM STORAGE
IFN FTMP,<
CPUTPQ::0			;COUNT OF CPUS WAITING FOR SWEEP
>
DIATAP::0			;NON-0 IF DIAG IN PROGRESS


>	;;;; END OF IFG TAPN
IFE TAPN,<	;;;; GLOBAL DUMMIES

XP	TPMCTT,CPOPJ##
XP	TAPMIN,CPOPJ##
XP	TAPSEC,CPOPJ##
XP	UTAPOP,CPOPJ##
XP	MTARID,CPOPJ##
XP	MTACHR,CPOPJ##
XP	TPFREE,CPOPJ##
XP	TPMIN,CPOPJ##
XP	MTAPE0,CPOPJ##

TPMSIL::JRST	CPOPJ1##

XP	TDYDN1,0
XP	TPKINI,0
XP	TUBQUE,0
XP	TDVKDB,0
XP	TUYKTP,0
XP	TKBUDB,0
XP	TKBDSP,0
XP	TKBCDB,0
XP	TKBKDB,0
XP	TDVUDB,0
XP	NOISEW,0
XP	TUC7TK,0
XP	TUBDDB,0
XP	TUBCNF,0
XP	PBUFRM,0
XP	TUCD20,0

>	;;; END IFE TAPN
IFE M.TX01,<
TTXCOS::
TTXCIS::JFCL		;DUMMY'S
CCHJGO==:0
TX1TCF==:CPOPJ##
>
IFE M.TM10,<
TTMCIC::
TTMCIS::
TTMCOC::JFCL	;DUMMY'S
>
IFE M.TM02-FTAUTC,<
TT2CO1::
TT2CI2::JFCL
>
IFN M.TRH1,<
TT2CO1::
TT2CI2::JFCL
TKBDIS==:0
TKBDOS==:0
TKBCIS==:0
>
IFE M.TC10,<
TTCCOS::
TTCCIS::JFCL
>
IFE M.TX01+M.TM02+M.DX20+M.TM78,<
TKBDIS==:0
TKBDOS==:0
TKBCIS==:0
>
SUBTTL	DECTAPE DATA BASE FOR DTASER
;DECTAPE ENTRY POINT AND BIT DEFINITIONS

SAVN==1		;OLD FORMAT DECTAPE SYSTEMS NO LONGER SUPPORTED BY DEC.
		; MONGEN NO LONGER ASKS THE DECTAPE FORMAT QUESTIONS.

IFG	M.DTXN, <EXTERN DTASER>	;TD10 WITH NEW FORMAT

;DEFINE SAVE MODE AND EXTENSION FOR OLD OR NEW FORMAT

	IFN	SAVN, <
		SAVDMP==:<SIXBIT /   SAV/>	;EXTENSION FOR SAVED FILES == "SAV"
>

IFE	M.DTXN,<
;IF NO DECTAPES, SATISFY GLOBALS BY DEFINING DUMMIES
	DTASEC==:CPOPJ##
	DTADDB==:CPOPJ##		;THIS WORKS BECAUSE SYSINI DOES A   MOVEI W,DTADDB##
	DTXINI==:0		;              FOLLOWED BY AN       XCT DTXINI##(W)
	DSCON==:0
	LVFLAG==:0
	USEWRD==:0
	DCONS==:0
	DTADSP==:0

	OWNDTC==:CPOPJ##
	SCDDT==:CPOPJ##
	DTXFRE==:CPOPJ##

	$HIGH
UNWDTC::
	SETZ	T3,
	POPJ	P,
	$LOW

>
DEFINE	DTDDB(X,Y,CPUN)<

SUBTTL INTERRUPT HEAD FOR DT'X
			;FLAGS LEVEL CODE
;CONTROL DEPENDENT PORTION OF DECTAPE SERVICE
DEFINE CDC (C,B) <

C=:.-DT'X'DDB	;RELATIVE LOCATION WITHIN CONTROL BLOCK
	B>

;MODEL DEVICE DATA BLOCK
DTXDDB=:.-DT'X'DDB

DT'X'DDB::SIXBIT	/DT'X'0/ ;(0) - DEVNAM
	XWD	<^D6*HUNGST>,200 ;(1) - DEVCHR
	0			;(2) - DEVIOS
	EXP	DTADSP##	;(3) - DEVSER
	XWD	1107,154403	;(4) - DEVMOD
	0			;(5) - DEVLOG
	0			;(6) - DEVBUF
	0			;(7) - DEVIAD
	0			;(10) - DEVOAD
	0			;(11) - DEVSTS
	XWD	.TYDTA,0	;(12) - DEVSTA
	0			;(13) - DEVXTR
	0			;(14) - DEVEVM
	0			;(15) - DEVPSI
	0			;(16) - DEVESE
	0			;(17) - DEVHCW
	BYTE	(3)CPUN(33)0	;(20) - DEVCPU
	0			;(21) - DEVISN
	0			;(22) - DEVJOB
	0			; - DEVFIL
	0			; - DEVEXT
	0			; - FSTBLK
	DT'X'DIR+DT'X'DDB	; - DLOC
	0			; - IBLK
	0			; - OBLK
	0			; - DISPAD
	0			; - DMPLST
	0			; - SVDWRD
	0			; - DJOTOP
	0			; - DJOBOT
	0			; - BADCOM



DT'X'DIR==:.-DT'X'DDB
	BLOCK	200
	XP	DT'X'DDS,.-DT'X'DDB
;DATA LEVEL CODE...CHANNEL 1 OR 2 USUALLY

D'X'DINT::CONSO	DAS,1		;DATA INTERRUPT FOR THIS CONTROL?
	JRST	.		;NO- PROCEED DOWN CHAIN
	SKIPN	DT'X'USE	;EXPECTING AN INTERRUPT?
	JRST	D'X'DINT+1	;NO, IGNORE IT

	SKIPE	D'X'DSRC	;ARE WE SEARCHING FOR BLOCK NUMBERS?
	JRST	D'X'SRCH	;YES
D'X'IOWD:BLKI	DAC,DT'X'PNT	;EXECUTE BLKI OR BLKO FOR THIS UNIT
	JRST	D'X'DTHR	;POINTER RAN OUT
D'X'DCTN:JFCL			;GOING REVERSE?
	XJEN	D'X'DCHL##

	SOS	DT'X'PNT	;YES- DECREMENT POINTER
	SOS	DT'X'PNT	;TWICE
	XJEN	D'X'DCHL##

D'X'DTHR:SKIPE	D'X'DDMP	;DUMP MODE POINTER RAN OUT?
	JRST	D'X'DMPA	;YES- ADVANCE POINTER
D'X'DFNS:CONO	DAS,770001	;SEND OUT FUNCTION STOP IF THROUGH
	XJEN	D'X'DCHL##


D'X'DSRC:CDC	DTXSRC,0	;SET NEGATIVE WHEN READING BLOCK NUMBERS

;HERE WHEN READING BLOCK NUMBERS AT DATA INTERRUPT LEVEL

D'X'SRCH:JSR	D'X'DSAV##	;SAVE ACS
D'X'CCNC:CONI	DAC,W		;READ FLAGS REGISTER
	HRLZS	W		;PUT MOST FLAGS INTO LEFT HALF
	HRRI	W,DT'X'DDB	;POINT TO THIS CONTROL BLOCK
	JRST	SRCH##		;DO THE SEARCH

D'X'DMPA:JSR	D'X'DSAV##	;SAVE ACS
	HRRZI	W,DT'X'DDB	;POINT TO CONTROL A
	JRST	DMPADV##	;PROCESS THE EXHAUSTED BLKI/O

	XP	DTSFNS,D'X'DFNS-DT'X'DDB
	XP	DXDINT,D'X'DINT-DT'X'DDB
	XP	DXIOWD,D'X'IOWD-DT'X'DDB
	XP	DXDCTN,D'X'DCTN-DT'X'DDB
D'X'CNUM:CDC	DXCNUM,<<DAC>B11>;CONTROL NUMBER

	XP	DTXCNC,D'X'CCNC-DT'X'DDB
;FLAGS LEVEL INTERRUPT HEAD...
DT'X'INT::CONSO	DAS,770000	;INTERRUPT FOR THIS CONTROL?
	JRST	.		;NO- PROCEED DOWN CHAIN
	SKIPN	DT'X'USE
	JRST	DT'X'INT+1
	JSR	DT'X'SAV##	;YES- SAV ACCUMULATORS FOR THIS LEVEL
	CDC	DXCCNT,<CONI DAC,T1>;READ FLAGS INTO T1
	CDC	DTSCNI,<CONI DAS,T4>;READ STATUS INTO T4
	HRLZI	W,(T1)		;PUT FLAGS (RH) INTO W (LH)
	HRRI	W,DT'X'DDB	;ADDRESS OF CONTROL DEPENDANT BLOCK
	JRST	DTXINT##	;TO NON-CONTROL DEPENDANT SECTION

	CDC	DTSCN2,<CONI DAS,T1>;STATUS REGISTER INTO T1

;CONSTANTS REQUIRED FOR EACH CONTROL...
	CDC	BFPNTR,<IOWD 200,D'X'BUF+1>
DT'X'USE:CDC	USEWRD,0
	CDC	ADRPRG,0
DT'X'PNT:CDC	PNTR,0
	CDC	DISTNC,0
	CDC	BLOCK,0
	CDC	QUANTM,0
	CDC	DSCON,0
	CDC	RVERS,0
	CDC	ERRCNT,0
	CDC	FNDTMP,0
	CDC	IOWRIT,0
	CDC	TURNCT,0
	CDC	BLKWRD,0
	CDC	LVFLAG,0
	CDC	BLKCNT,0
	CDC	SVPNTR,0
	CDC	USPNTR,0
	CDC	DIRCTN,0
	DT'X'BUF=.-DT'X'DDB
D'X'BUF:CDC	BUF,<BLOCK 200>	;A CONTROL MONITOR BUFFER
	CDC	DTXCON,<CONO DAC,(T1)>	;CONDITIONS OUT - A CONTROL A
	CDC	DTXSTP,<CONO DAC,400000>	;STOP SELECTED TAPE
	CDC	DTXTRN,<CONO DAC,DTTURN##>	;TURN SELECTED TAPE AROUND
	CDC	DTSCO2,<CONO DAS,2(T4)>
	CDC	DTSENJ,<CONO DAS,670000>	;ENABLE JOB DONE

	CDC	DTXREQ,-1		;# OF WAITERS
	CDC	DTXWAT,0		;REQUEST INTERLOCK FOR THIS CONTROL

D'X'DDMP:CDC	DTXDMP,0	;SET TO -1 WHEN READING IN DUMP MODE
	XP	DTXIOG,.-DT'X'DDB
	CONO	DAC,DTBOTH##(T2)	;START UP DECTAPE
	CONO	DAS,770000	;ENABLE INTERRUPT CONDITIONS
	POPJ	P,		;RETURN
	CDC	DTXSF,<CONSZ DAC,100000>	;SKIP IF GOING FORWARD
	CDC	DTXDSL,<CONO DAC,410000>	;STOP AND DESELECT TAPE
	CDC	DTXDST,<CONO DAC,10000>	;DESELECT TAPE
	CDC	DTXSTO,<CONO DAC,430000(T1)>	;STOP AND DESELECT
	CDC	DTXTR2,<CONO DAC,230200(T1)>	;TURN TAPE, SEARCH FOR BLOCKS
	CDC	DTXINI,<CONO DAC,0>	;SHUT DOWN CONTROL
	CDC	DTXDTI,<DATAI DAC,T1>	;READ A BLOCK NUMBER

	XP	DCONS,.-DT'X'DDB
>;END DEFINE DTDDB

DEFINE	GENDTA(CPU,CPUN)<
	ZZZZ==0
	REPEAT	M'CPU'TD10,<
		IFE ZZZZ&1,<DAC==320>
		IFN ZZZZ&1,<DAC==330>
		DAS==DAC+4
		DTDDB (\"ZZZ,\<ZZZ&7>,CPUN)
		ZZZ==ZZZ+1
		ZZZZ==ZZZZ+1
	>;END REPEAT M'CPU'TD10
>;END DEFINE GENDTA

ZZ==0
ZZZ=="A"
REPEAT	M.CPU,<
	GENDTA (\ZZ,ZZ)
	ZZ==ZZ+1
>;END REPEAT M.CPU

KONEND::		;END OF KONTROLLER DATA BLOCKS


;DDB MAGIC CELLS
FSTBLK==:DEVPPN
DLOC==:FSTBLK+1	;LH==BLOCK# DURING DEAD RECKONING,RH==ADDRESS OF DIR
IBLK==:FSTBLK+2	;LH==INDEX OF INPUT FILE(1-27),RH==BLOCK# TO READ NEXT
OBLK==:FSTBLK+3
DISPAD==:FSTBLK+4
DMPLST==:FSTBLK+5
SVDWRD==:FSTBLK+6
DJOTOP==:FSTBLK+7
DJOBOT==:FSTBLK+10
BADCOM==:FSTBLK+11
	SUBTTL	Database for RX20s on 2020s

IFN FTKS10&M.RX20,<

	EXTERN	RX2SER			;Load device driver

	;Macro to define prototype DDB for each RX20 CTLlr (RXA,RXB,...)

	DEFINE	RX2DDB(x,CPU),<

RX'x'INT::EXP	0,0,IC.UOU,.+1		;Vectored interrupts XPCW here
	EXCH	T1,RX'x'INT		;Get interrupt PC
	MOVEM	T1,RX'x'CHL##		;Save for RESn
	MOVE	T1,RX'x'INT+1		;;Second word of PC
	MOVEM	T1,RX'x'CHL##+1		;;...
	MOVE	T1,RX'x'INT		;Restore state
	JSR	RX'x'SAV##		;Save ACs
	JSP	F,RX2INT##		;Set up F and join RX2SER
RX'x'DDB::PHASE	0
	EXP	<SIXBIT/RX'x'0/>	;(0) DEVNAM for prototype DDB this CTL
	XWD	<^D5*HUNGST>,201	;(1) DEVCHR
	EXP	0			;(2) DEVIOS
	EXP	RX2DSP##		;(3) DEVSER
	XWD	DVLNG!DVIN!DVOUT,^D<1B<35-I>> ;(4) DEVMOD
	EXP	0			;(5) DEVLOG
	EXP	0			;(6) DEVBUF
	EXP	0			;(7) DEVIAD
	EXP	0			;(10) DEVOAD
	EXP	0			;(11) DEVSTS
	XWD	DEPLEN!.TYRX2,DEPEVM	;(12) DEVSTA
	EXP	0			;(13) DEVXTR
	EXP	0			;(14) DEVEVM
	EXP	0			;(15) DEVPSI
	EXP	0			;(16) DEVESE
	EXP	0			;(17) DEVHCW - Hard errors,,Soft errors
	BYTE	(3)CPU(33)0		;(20) DEVCPU
	EXP	0			;(21) DEVISN (Must leave space)
	EXP	0			;(22) DEVJOB
	EXP	0			;(23) DEVFIL
	EXP	0			;(24) DEVEXT
	EXP	0			;(25) DEVPPN
DEVRXO::!EXP	0			;(26) DEVRXO
DEVRXI::!EXP	0			;(27) DEVRXI
DEVRXQ::!EXP	0,0,0,0			;(30) DDB and CSR queue element
RX'x'DDS::!				;End of device DDB
DEVRXS::!EXP	0			;DEVRXS ;Start of CTL data
DEVRXV::!EXP	RX21IV+<<"x"-"A">*4>	;Interrupt vector
DEVRXC::!EXP	RX21BA+<<"x"-"A">*10>	;CSR address
DEVRXM::!EXP	RX2IMR##+<<"x"-"A">*2>	;UBA mapping reg addr (2 slots/RX)
DEVRXE::!EXP	RX2IEA##+<<"x"-"A">*UBAMUL> ;11 address of mapped buffer
DEVRXJ::!XPCW	RX'x'INT		;Instruction to set up vector table with
	Dephase
>;End of define RX2DDB
DEFINE	GENRX2(CPU,CPUN)<
	ZZZZ==0
	REPEAT	M'CPU'RX20,<
		RX2DDB (\"ZZZ,CPUN)
		ZZZ==ZZZ+1
		ZZZZ==ZZZZ+1
	>;;End repeat
>;End define

ZZ==0
ZZZ=="A"
REPEAT	M.CPU,<
	GENRX2 (\ZZ,ZZ)
	ZZ==ZZ+1
>;End repeat
>;End FTKS10&M.RX20
SUBTTL	MACRO TO GENERATE UNIT RECORD EQUIPMENT DDBS

DEFINE	GENDDS(DEV,DV)<

	$CPNNN==0
	$'DV'NUM==0
	REPEAT	M.CPU,<
		$'DEV'NM==0
		GENDDB(DEV,DV,\$CPNNN,$CPNNN)
		$CPNNN==$CPNNN+1
	>
>

DEFINE	GENDDB(DEV,DV,CPU,N)<

	REPEAT	M'CPU'DEV,<
		EXTERN	DEV'SER
		DEV'DDB	\$'DV'NUM,\$'DEV'NM,CPU,N
		$'DV'NUM==$'DV'NUM+1
		$'DEV'NM==$'DEV'NM+1
	>
>
SUBTTL	CARD READER DDB DEFINITIONS
IFE FTKS10,<IFG CDRN,<

DEFINE	CDRDDB	(N,P,CPU,CPUN) <
	XLIST
	CDR2==154		;DEVICE SELECTION CODE FOR SECOND CDR
	IFNDEF	CR'CPU'0,<CR'CPU'0==CR>   ;DEFINE STANDARD MNEMONIC DEFINITIONS
	IFNDEF	CR'CPU'1,<CR'CPU'1==CDR2> ; BUT ALLOW FOR OVERRIDE

CR'N==CR'CPU'P
CR'N'SV1==CR'N'SAC##+F		;DEFINE F SAVE LOCATION

CDRCON==:.-CR'N'DDB
CR'N'INT::CONSO	CR'N,0		;(-4) SKIP IF INTERRUPT FOR THIS READER
	  JRST	.-1		;(-3) NOT HERE, CONTINUE DOWN THE CHAIN
	  MOVEM	F,CR'N'SV1	;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP	F,CDRINT##	;(-1) SET F TO DDB ADDRESS AND SERVICE INTERRUPT
CR'N'DDB::
CR'N'NAM:	CRNAM=SIXBIT/CDR/
	IFE	CDRN+DCDRN-1,<CRNAM>	;(0) PHYSICAL DEVICE NAME
	IFN	CDRN+DCDRN-1,<CRNAM+<20+$CRNUM>B23>	;(0) PHYSICAL DEVICE NAME
	XWD	2*HUNGST,	;(1) DEVICE CHARACTERISTICS
CDRIOS==:.-CR'N'DDB
	0			;(2) DEVIOS
	CDRDSP##		;(3) LH=DDB LINK, RH=CDR DISPATCH TABLE
	XWD	DVCDR+DVIN,14403;(4) DEVICE CHARACTERISTICS
	0			;(5) LOGICAL DEVICE NAME (DEVLOG)
	0			;(6) BUFFER HEADER ADDRESSES
CDRIAD==:.-CR'N'DDB
	0			;(7) ADDRESS OF CURRENT INPUT BUFFER
CDRPTR==:.-CR'N'DDB
	0			;(10) BYTE POINTER TO CURRENT INPUT BUFFER
CDRSTS==.-CR'N'DDB
CR'N'STS: 0			;(11) LATEST CONI STATUS BITS
	XWD	.TYCDR!.SPCDR,0	;SPOOLED CDR
	0			;DEVXTR
	0			;DEVEVM
	0			;DEVPSI
	0			;DEVESE
	1B11			;DEVHCW (BA10)
	BYTE	(3)CPUN(33)0	;DEVCPU
	0			;DEVISN
	<N>B17			;UNIT+DEVJOB
CDRCTR==:.-CR'N'DDB
	0			;BYTE COUNTER FOR IDPB'S INTO USER'S BUFFERS
CDRCHK==:.-CR'N'DDB
	0			;CHECK SUM OF CURRENT INPUT BINARY CARD
CDRCNT==:.-CR'N'DDB
	0			;# OF CARDS READ
CDRADR==:.-CR'N'DDB
	0			;USER'S JOBDAT ADDRESS
CDRCOL==:.-CR'N'DDB
	CF'N'CHN##-CR'N'CHN##	;COLUMN COUNT ON CURRENT CARD
CDRSUP==:.-CR'N'DDB		;BLKI POINTER TO USER'S BUFFER
CR'N'SUP: 0			; FOR SUPER IMAGE MODE INPUT

CDRMIS==:.-CR'N'DDB
	0			;FLAG =-1 IF MISSED DATA ON CURRENT CARD
CDRSPU==:.-CR'N'DDB		;COUNT OF SPURIOUS END-OF-CARD FLAGS
	0			; TO CHECK ON POSSIBLE HARDWARE PROBLEM
CDRSV2==:.-CR'N'DDB
	0			;SAVE LOCATION FOR U
CDRCH==:.-CR'N'DDB
	EXP	CR'N'CHN##
CDRBKI==:.-CR'N'DDB
	BLKI	CR'N,CR'N'SUP

CDRCNO==:.-CR'N'DDB
	CONO	CR'N,(U)
CDRCSO==:.-CR'N'DDB
	CONSO	CR'N,(U)
CDRCSZ==:.-CR'N'DDB
	CONSZ	CR'N,(U)
CDRDTI==:.-CR'N'DDB
	DATAI	CR'N,U
CDRRDY==:.-CR'N'DDB
	CONSO	CR'N,IDRDY##	;SKIP IF DATA READY
CDRRTR==:.-CR'N'DDB
	CONSZ	CR'N,NOTRDY##	;SKIP IF READY TO READ
CDRSVE==:.-CR'N'DDB
CR'N'SVE: 0			;ROUTINE TO SAVE AC'S
	MOVE	F,CR'N'SV1	;RESTORE F
	JSR	CR'N'SAV##	;SAVE AC'S AND ESTABLISH P
	MOVEI	F,CR'N'DDB	;SET UP DDB ADDRESS
	JRST	@CR'N'SVE	;AND RETURN
CDREX1==:.-CR'N'DDB
	MOVE	F,CR'N'SV1	;RESTORE F
	XJEN	CR'N'CHL##

CRFCON==:.-CR'N'DDB
CF'N'INT::CONSO	CR'N,0		;SKIP IF CDR FLAG
	JRST	.-1		;NOT THIS, CONTINUE DOWN SKIP CHAIN
	JSR	CF'N'SAV##	;SAVE AC'S
	MOVEI	F,CR'N'DDB	;SET UP F
	JRST	CRFINT##	;AND SERVICE INTERRUPT
CRXSTS==:.-CR'N'DDB
	CONI	CR'N,CR'N'STS

	LIST
	>	;END DEFINE CDRDDB

	GENDDS	CDR,CR
> ;END IFG CDRN


IFG DCDRN, <				;ONLY NEED THIS IF FRONT-END CARD READERS

DEFINE	DCRDDB	(CPUN,N,U,D) <

FC'N'DDB::
	CRNAM==SIXBIT/CDR/
	IFE CDRN+DCDRN-1,<CRNAM>	;(0) DEVNAM
	IFN CDRN+DCDRN-1,<CRNAM+<20+$CRNUM>B23> ;(0) DEVNAM
	XWD	2*HUNGST,		;(1) DEVCHR
	0				;(2) DEVIOS
	DCRDSP##			;(3) LH=DDB LINK, RH=DISPATCH TABLE
	XWD	DVCDR+DVIN,14403	;(4) DEVMOD
	0				;(5) DEVLOG
	0				;(6) DEVBUF
	0				;(7) DEVIAD
	0				;(10) DEVPTR
	0				;(11) DEVSTS
	XWD .TYCDR!.SPCDR,0		;(12) DEVSPL
	0				;(13) DEVXTR
	0				;(14) DEVEVM
	0				;(15) DEVPSI
	0				;(16) DEVESE
	EXP	3B11			;(17) DEVHCW (CD20)
	BYTE	(3)CPUN(33)0		;(20) DEVCPU
	0				;(21) DEVISN
	<N>B17				;(22) PUNIT+DEVJOB
	0				;(23) DEVCTR
DCRDUX==:.-FC'N'DDB
	XWD	U,D			;(24) LINE NUMBER,,DTE INDEX
CDRCNT==:.-FC'N'DDB
	0				;(25) CARD COUNT
DCRBUF==:.-FC'N'DDB
	BLOCK	^D40			;(26) BUFFER FOR READING A CARD
>
	EXTERN	DCRSER

DEFINE	RSXDTE	(C,D)	<
	$CRUNT==0
  REPEAT M'C'CR'D'N,<
	DCRDDB	\C,\<$CRNUM-CDRN>,$CRUNT,$DTNDX
	$CRUNT==$CRUNT+1
	$CRNUM==$CRNUM+1
  >
	$DTNDX==$DTNDX+1
>


	$CRNUM==CDRN			;START NUMBERING DCB'S AT CDRN
	$DTNDX==0			;DTE INDEX STARTS AT 0

	RSX20F				;GENERATE THE FRONT END READER DDB'S
>	;END IFN DCDRN

IFN FTKL10,<
IFE M.DCR,<
FCRDSP==:EATDSP##	;IGNORE CDR MESSAGES
> ;END M.DLP
> ;END FTKL10
> ;END IFE FTKS10
IFN FTKS10,<

	IFN CDRN,<

DEFINE CDRDDB (N) <

	XLIST				;TURN OFF LISTING DURING EXPANSION

CR'N'INT::0				;INTERRUPT JSR'S TO HERE
	EXP	0,IC.UOU,.+1		;XPCW BLOCK

	EXCH	T1,CR'N'INT		;GET INTERRUPT PC
	MOVEM	T1,CR'N'CHL##		;PUT INTO -10 STYLE INTERRUPT HANDLER
	MOVE	T1,CR'N'INT+1		;SECOND WORD
	MOVEM	T1,CR'N'CHL##+1		;XJEN

	MOVE	T1,CR'N'INT		;AND RESTORE T1
	JSR	CR'N'SAV##		;SAVE AC'S
	JSP	F,CDRINT##		;SET UP F AND GO TO INTERRUPT CODE
CR'N'DDB::PHASE 0
	CRNAM==SIXBIT/CDR/
	IFE CDRN-1,<CRNAM>		;(0) DEVNAM
	IFN CDRN-1,<CRNAM+<20+$CRNUM>B23>
	XWD	2*HUNGST,0		;(1) DEVCHR
	0				;(2) DEVIOS
	CDRDSP##			;(3) DEVSER
	XWD	DVCDR+DVIN,14403	;(4) DEVMOD
	0				;(5) DEVLOG
	0				;(6) DEVBUF
	XWD	R,0			;(7) DEVIAD (DEVADR)
	0				;(10) DEVOAD (DEVPTR)
	0				;(11) DEVSTS
	XWD	.TYCDR!.SPCDR,0		;(12) DEVSTA
	0				;(13) DEVXTR
	0				;(14) DEVEVM
	0				;(15) DEVPSI
	0				;(16) DEVESE
	EXP 3B11			;(17) DEVHCW
	BYTE	(3)CPUN(33)0		;(20) DEVCPU
	0				;(21) DEVISN
	0				;(22) DEVJOB
	0				;(23) DEVCTR
CDRCHK::!0				;CHECKSUM OF CURRENT INPUT BINARY CARD
CDRCNT::!0				;# OF CARDS READ
CDRDAP::!0				;PLACE TO BUILD AOBJN POINTER TO CDRDAE
CDRDAE::!BLOCK 11			;SYSERR BLOCK
CDRVEC::!CDRIVT				;-11 STYLE INTERRUPT VECTOR ADDRESS
CDRBAS::!CD11BA				;CD20 BASE DEVICE ADDRESS
CDRIVI::!XPCW	CR'N'INT		;INTERRUPT INSTRUCTION FOR THIS CDR

CDRCDB::! CHNMAC(\M.CD'N'C)		;POINTER TO CHANNEL DATA BLOCK
CDRBUF::!BLOCK ^D40			;INTERNAL BUFFER FOR ONE CARD
	DEPHASE
	LIST
>;END DEFINE CDRDDB
	EXTERNAL CD2SER			;HAUL IN THE SERVICE ROUTINE

	$CRNUM==0			;CDR NUMBER SYMBOL

IFG CDRN-1,<PRINTX KS10 MONITOR DOES NOT SUPPORT MORE THAN ONE CDR>

	REPEAT CDRN,<

	CDRDDB	\$CRNUM
	$CRNUM==$CRNUM+1
	>

>;END IFG CDRN
>;END IFN FTKS10
SUBTTL	CARD READER TRANSLATION TABLES

;IF THERE ARE REMOTE OR LOCAL READERS, CERTAIN BYTE POINTERS
;  AND THE CHARACTER TRANSLATION TABLES MUST BE DEFINED.

IFN CDRN+DCDRN+M.RCDR,<

XP PCDRAS,700			;ASCIZ BYTE POINTER
XP PCDRBI,1400			;BINARY AND IMAGE BYTE POINTER
XP PCDRSI,4400			;SUPER IMAGE BYTE POINTER

;THE CHARACTER TRANSLATION TABLES:
	$HIGH
CRCVPT::XWD	350700+T2,CRCVTB
	XWD	260700+T2,CRCVTB
	XWD	170700+T2,CRCVTB
	XWD	100700+T2,CRCVTB

;CODE CONVERSION FOR THE 029 KEYPUNCH
;THE FOLLOWING EQUIVALENCES ARE ARTIFICIALLY DEFINED

;029 KEYTOP	;ASCII 35	;ASCII 37
;CENT		[		[
;0-8-2		]		]
;VERT BAR	^		HAT = L.C. VERT BAR
;UNDERBAR	_		UNDERBAR
;NEGATION	\		TILDE = L.C. NEGATION

	;CHARACTERS	;ZONE/DIGITS
CRCVTB:	ASCII	/ 123/		;N/N-3
	ASCII	.0/ST.		;0/N-3
	ASCII	/-JKL/		;11/N-3
	ASCII	/HI[./		;12,8/N-3
	ASCII	/&ABC/		;12/N-3
	ASCII	/QR]$/		;11,8/N-3
	ASCII	/YZ\,/		;0,8/N-3
	ASCII	/89:#/		;8/N-3
	ASCII	/4567/		;N/4-7
	ASCII	/UVWX/		;0/4-7
	ASCII	/MNOP/		;11/4-7
	ASCII	/<(+!/		;12,8/4-7
	ASCII	/DEFG/		;12/4-7
	ASCII	/*);^/		;11,8/4-7
	ASCII	/%_>?/		;0,8/4-7
	ASCII	/@'="/		;8/4-7

;CODE FOR THE 026 KEYPUNCH A LA H HYMAN

	ASCII	/ 123/		;N/N-3
	ASCII	.0/ST.		;0/N-3
	ASCII	/-JKL/		;11/N-3
	ASCII	/HI?./		;12,8/N-3
	ASCII	/+ABC/		;12/N-3
	ASCII	/QR:$/		;11,8/N-3
	ASCII	/YZ;,/		;0,8/N-3
	ASCII	/89_=/		;8/N-3
	ASCII	/4567/		;N/4-7
	ASCII	/UVWX/		;0/4-7
	ASCII	/MNOP/		;11/4-7
	ASCII	/)]<!/		;12,8/4-7
	ASCII	/DEFG/		;12/4-7
	ASCII	/*[>&/		;11,8/4-7
	ASCII	/("#%/		;0,8/4-7
	ASCII	/@^'\/		;8/4-7
	$LOW
>	;END OF IFN RCDRN+M.RCDR
SUBTTL CARD PUNCH DDB DEFINITIONS
	IFG	CDPN, <

DEFINE	CDPDDB	(N,P,CPU,CPUN) <
	XLIST

	IFNDEF CP'CPU'0,<CP'CPU'0==CDP>

CP'N=CP'CPU'P

CP'N'SV1==CP'N'SAC##+F		;DEFINE F SAVE LOCATION

CDPCON==:.-CP'N'DDB
CP'N'INT::CONSO	CP'N,0		;(-4) SKIP IF INTERRUPT FOR THIS READER
	  JRST	.-1		;(-3) NOT HERE, CONTINUE DOWN THE CHAIN
	  MOVEM	F,CP'N'SV1	;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP	F,CDPINT##	;(-1) SET F TO DDB ADDRESS AND SERVICE INTERRUPT
CP'N'DDB::
CP'N'NAM:	CDPNAM=SIXBIT/CDP/
	IFE	CDPN-1,<CDPNAM>	;(0) PHYSICAL DEVICE NAME
	IFN	CDPN-1,<CDPNAM+<20+$CPNUM>B23>	;(0) PHYSICAL DEVICE NAME
	XWD	4*HUNGST,41	;(1) CODE 4 - HUNG TIME IS 15 SECONDS
CDPIOS==:.-CP'N'DDB
	0			;(2) DEVIOS
	CDPDSP##		;(3) LH=DDB LINK, RH=CDP DISPATCH TABLE
	XWD	DVCDR+DVOUT,14403	;(4) DEVICE CHARACTERISTICS
	0			;(5) LOGICAL DEVICE NAME (DEVLOG)
CDPBUF==:.-CP'N'DDB
	0			;(6) BUFFER HEADER ADDRESSES
CDPNTR==:.-CP'N'DDB
	0			;(7) BYTE POINTER TO CURRENT OUTPUT BUFFER
CDPOAD==:.-CP'N'DDB
	0			;(10) ADDRESS OF CURRENT OUTPUT BUFFER
CDPSTS==.-CP'N'DDB
CP'N'STS: 0			;(11) LATEST CONI STATUS BITS
	XWD	.TYCDP!.SPCDP,0	;SPOOLABLE, PUNCH
	0			;DEVXTR
	0			;DEVEVM
	0			;DEVPSI
	0			;DEVESE
	3B11			;DEVHCW (LP20)
	BYTE	(3)CPUN(33)0	;DEVCPU
	0			;DEVISN
	<N>B17			;PUNIT+DEVJOB
CDPCTR==:.-CP'N'DDB
	0			;BYTE COUNTER FOR ILDB'S FROM USER'S BUFFERS
CDPCNT==:.-CP'N'DDB
	0
CDPOCT==:.-CP'N'DDB
	0
CDPOPT==:.-CP'N'DDB
	0
CDPTMP==:.-CP'N'DDB
	CG'N'CHN##-CP'N'CHN##
CDPECT==:.-CP'N'DDB
	0
CDPFCD==:.-CP'N'DDB
	0
CDPFCT==:.-CP'N'DDB
	0
CDPCCT==:.-CP'N'DDB
	0
CDPSVJ==:.-CP'N'DDB
	0
CDPSVT==:.-CP'N'DDB
	0
CDPEOC==:.-CP'N'DDB
	0
CDPBNB==:.-CP'N'DDB
	EXP	50000
CDPBUF==:.-CP'N'DDB
	BLOCK	33
CDPCH==:.-CP'N'DDB
	EXP	CP'N'CHN##	;CDP PIA
CDP10D==:.-CP'N'DDB
	EXP	M'CPU'CP1D	;1 IF CP10D, 0 IF CP10A
CDPCNO==:.-CP'N'DDB
	CONO	CP'N,(U)
CDPOAT==:.-CP'N'DDB
	CONSO	CP'N,474000	;CHECK FOR TROUBLE
CDPZTE==:.-CP'N'DDB
	CONSZ	CP'N,4100	;EOC OR TROUBLE?
CDPZPE==:.-CP'N'DDB
	CONSZ	CP'N,1000	;PUNCH ERROR?
CDPZTB==:.-CP'N'DDB
	CONSZ	CP'N,CI.TRB##	;TROUBLE?
CDPZER==:.-CP'N'DDB
	CONSZ	CP'N,CI.ERR##	;ERROR?
CDPZCP==:.-CP'N'DDB
	CONSZ	CP'N,CI.CIP##	;CARD IN PUNCH?
CDPOTN==:.-CP'N'DDB
	CONSO	CP'N,470000	;TROUBLE BUT DON'T RESET BUFFERS?
CDPOER==:.-CP'N'DDB
	CONSO	CP'N,CI.ERR##	;ERROR?
CDPDOU==:.-CP'N'DDB
	DATAO	CP'N,U
CDPDFC==:.-CP'N'DDB
	DATAO	CP'N,CDPFCD(F)
CDPDSV==:.-CP'N'DDB
	DATAO	CP'N,SEVENS##
CDPEX1==:.-CP'N'DDB
	MOVE	F,CP'N'SV1	;RESTORE F
	XJEN	CP'N'CHL##

CPFCON==:.-CP'N'DDB
CG'N'INT::CONSO	CP'N,0		;SKIP IF CDP FLAG
	JRST	.-1		;NOT THIS, CONTINUE DOWN SKIP CHAIN
	JSR	CG'N'SAV##	;SAVE ACS
	MOVEI	F,CP'N'DDB	;SETUP F
	JRST	CPFINT##	;AND SERVICE INTERRUPT
CPFCH==:.-CP'N'DDB
	EXP	CG'N'CHN##
CDPXSTS==:.-CP'N'DDB
	CONI	CP'N,CP'N'STS

	LIST
>;END CDPDDB



	GENDDS	CDP,CP

>;END IFG CDPN

SUBTTL	DK10 BITS AND DDB DEFINITIONS


;-------DK10 BITS

RTC==	070	;DEVICE ASSIGNMENT
		;CONO BITS
DK.OSO==1B23	;SET COUNT OVERFLOW
DK.OCO==1B31	;CLEAR COUNT OVERFLOW
DK.OSD==1B24	;SET DONE
DK.OCD==1B32	;CLEAR DONE
DK.OSU==1B28	;SET USER TIME
DK.OCU==1B27	;CLEAR USER TIME
DK.OON==1B30	;TURN CLOCK ON
DK.OOF==1B29	;TURN CLOCK OFF
DK.OIC==1B25	;INCREMENT CLOCK(IF OFF)
DK.OCC==1B26	;CLEAR CLOCK(COUNTER,DONE,OVF.,USER,PIA)
		;CONI BITS
DK.IO== 1B31	;OVERFLOW FLAG (INTERRUPT)
DK.ID== 1B32	;DONE FLAG (INTERRUPT)
DK.IU== 1B28	;USER TIME
DK.ION==1B30	;CLOCK ON
DK.IXS==1B26	;EXTERNAL SOURCE

;PROTOTYPE DK10 DDB

DEFINE RTCDEF(N),<
RTCNUM==RTCNUM+M.RT'N

XP C'N'RTC,0
IFG M.RT'N,<XP C'N'RTC,RT'N'DDB>
XP C'N'RTD,0
>

RTCNUM==0
ZZ==0
REPEAT M.CPU,<
	RTCDEF	\ZZ
ZZ==ZZ+1
>
DEFINE	RTCDDB	(N,DEVCOD)<


RT'N'SVF==RT'N'SAC##+F		;DEFINE SAVE LOC. FOR F
RT'N'SVT==RT'N'SAC##+T1		;SAVE LOC. FOR T1
RT'N==:DEVCOD			;DEFINE DEVICE CODE
RT'N'DTI==:(DATAI RT'N,)	;DATAI FOR EXTERNAL USE (E.G. RT'N'DTI##,,ADDR)


;----	INITIALIZATION ROUTINE (JSR RTCINI(F))
RT'N'INI:	0
	CONO	RT'N,DK.OCC	; CLEAR THE CLOCK
	DATAO	RT'N,RT'N'PRD	; SET PERIOD
	CONO	RT'N,DK.OON+RT'N'CHN##	; & START CLOCK
	JRST	@RT'N'INI

;----	EXIT ROUTINE (JRST RTCXIT(F))
RT'N'XIT:CONO	RT'N,DK.OCO+DK.OCD+RT'N'CHN##  ;CLEAR IRP.
	MOVE	F,RT'N'SVF	; RESTORE F & T1
	MOVE	T1,RT'N'SVT
	JEN	@RT'N'CHL##	; & DISMISS

;----	INTERRUPT ROUTINE
RT'N'INT::CONSO	RT'N,DK.IO+DK.ID	; INTERRUPT FOR THIS DK10 (OVERFLOW OR DONE?)
	JRST	.-1		; NO
	MOVEM	F,RT'N'SVF	; YES - SAVE F & T1
	MOVEM	T1,RT'N'SVT
	JSP	F,RTCINT##	; LOAD F WITH DDB ADDR & GO TO IRP. ROUTINE

;	DEFINE SOME DISPLACMENTS RELATIVE TO DDB
XP RTCINI,RT'N'INI-.
XP RTCXIT,RT'N'XIT-.

RT'N'DDB::
XP RTCNAM,.-RT'N'DDB		;(0) PHYSICAL NAME
	SIXBIT/RTC'N/
XP RTCPRD,.-RT'N'DDB		;(1) PERIOD (10 USEC UNITS)
RT'N'PRD:	^D100000
XP RTCTIM,.-RT'N'DDB		;(2) TIME (10 USEC UNITS) UPDATED EVERY IRP.
RT'N'TIM::	0
XP RTCSON,.-RT'N'DDB		;(3) SKIP IF DK10 ON
	CONSO	RT'N,DK.ION
XP RTCSNO,.-RT'N'DDB		;(4) SKIP IF NOT OVERFLOW
	CONSZ	RT'N,DK.IO
XP RTCDAI,.-RT'N'DDB		;(5) READ CLOCK INTO T1
	DATAI	RT'N,T1
XP RTCLGT,.-RT'N'DDB		;(6) LAST VALUE RETURNED BY GETIME
	0
>	;DEFINE RTCDDB



;GENERATE DK10 DDB'S

DEFINE RTCDEF(N)<
IFG M.RT'N,<RTCDDB(N,70)
>>
ZZ==0
REPEAT	M.CPU,<
	RTCDEF	\ZZ
ZZ==ZZ+1
>

XP RTCTIM,0			;FOR SETIME (SYSINI) SO WON'T GET
XP RTCINI,0			;UNDEFINED GLOBALS.

SUBTTL	DEFINITIONS FOR DISPLAY AND LIGHT PEN
;DISPLAY AND LITE PEN

	IFG	DISN, <
	IFN	T30N!TVP10N, <DIS==134>
	EXTERN	DISSER
XP DISJSR,DISBLK##+1		;DIS JSR LOCATION IN LOWER CORE
XP ONDIS,DISBTH##+100
XP NONDIS,DISBTH##
XP OFFDIS,0
XP DISPON,2000+DISBIT##		;CONO PI, TURNS DIS PI CHANNEL ON
XP DISPOF,1000+DISBIT##		;CONO PI, TURNS DIS PI CHANNEL OFF


DISCON:

IFN T340N, <EXP ONDIS

DISBSY==77
XP PENON,7400

SETCON::CONO	DIS,100		;PARAMETER MODE
	JRST	DISIN1##

PENINT::CONSO	DIS,0		;CHECK FOR CONI FLAGS
	JRST	PENINT		;THIS WILL BE PART OF THE LINKED INTERRUPT CHAIN.
	CONSZ	DIS,400		;STOP FLAG UP
	JRST	STPFLG		;YES
	CONSZ	DIS,2000	;PEN FLAG UP
	DATAI	DIS,PENLOC##	;YES-STORE CURRENT LITE PEN LOCATION
	CONO	DIS,NONDIS	;CLEAR FLAGS
	XJEN	PENCHL##


;"STPFLG" SERVICES STOP FLAGS (DISPLAY PROGRAMMED) BY DOING A CLOSE ON THE DISPLAY

STPFLG:	JSR	PENSAV
	JRST	DISDSP##+DCL	;DO A CLOSE


ENDCHK::TRNN	T1,-1
	JRST	EXIT1##
	JRST	EXIT0##
>	;END OF IFN T340N
IFE T340N, <Z

DISBSY==20000
PENON==10000

SETCON::MOVEI	T1,PENCHN##	;SET UP CONO WORD
	ASH	T1,3		;WITH PROPER CHANNEL ASSIGNMENTS
	ADDI	T1,DISCHN##
IFN T30N!TVP10N, <TRO T1,4300>	;SET DISPLAY READY BIT & BRIGHTNESS = 3.
	MOVEM	T1,DISCON
	JRST	DISIN1##

PENINT::CONSO	DIS,0		;CHECK FOR CONI FLAGS
	JRST	PENINT		;THIS INSTRUCTION CHANGED TO LINK IN INTERRUPT CHAIN.
	DATAI	DIS,PENLOC##	;CLEAR PEN INTERRUPT
	MOVEM	T1,PENLOC##	;SAVE AC T1
	MOVE	T1,DISBKO##	;GET ABSOLUTE ADDRESS OF NEXT DATA ELEMENT
	SUB	T1,DISREL##	;MAKE RELATIVE
	HRRZS	T1		;CLEAR OUT GARBAGE IN LH
	EXCH	T1,PENLOC##	;SAVE ADDRESS IN PENLOC
	XJEN	PENCHL##



ENDCHK::JUMPE	T1,EXIT1##	;END OF LIST?
	TRNE	T1,-1		;NO, CHANGE INTENSITY COMMAND?
	JRST	EXIT0##		;NO
	MOVSS	T1		;YES, LH HAS USER CONO BITS
	DPB	T1,INPNT	;DEPOSIT FOR CONO
	CONO	DIS,@DISCON	;SET NEW INTENSITY
	JRST	DISNX1##
INPNT:	IFN	TVP10N, <POINT 2,DISCON,28>
	IFN	T30N, <POINT 3,DISCON,29>
>	;END OF IFE T340N

DISCNA::CONO	DIS,@DISCON
DISCZA::CONSZ	DIS,@DISCON
BLKLIT::BLKO	DIS,DISBKO##
DISCNO::CONO	DIS,OFFDIS
DISCNI::CONI	DIS,DISSTS##

DISTST::CONO	DIS,DISCHN##
>	;END OF IFG DISN


IFN VBCN,<
EXTERN	VBCSER
>
SUBTTL	LINE PRINTER DDB DEFINITIONS

IFE FTKS10,<IFG LPTN,<

;LINE PRINTER DDB DEFINITIONS

LPTDON==100

DEFINE	LPTDDB	(N,P,CPU,CPUN) <
	XLIST				;TURN OFF LISTING DURING EXPANSION

	LPT2==234			;DEVICE CODE FOR SECOND PRINTER
	LPT3==230			;DEVICE CODE FOR THIRD PRINTER
	IFNDEF	LP'CPU'0,<LP'CPU'0==LPT> ;DEFINE STANDARD MNEMONIC DEFINITIONS
	IFNDEF	LP'CPU'1,<LP'CPU'1==LPT2>; BUT ALLOW FOR OVERRIDE
	IFNDEF	LP'CPU'2,<LP'CPU'2==LPT3>

LP'N==LP'CPU'P

LP'N'SV1==LP'N'SAC##+F			;DEFINE F SAVE LOCATION

LPTCON==:.-LP'N'DDB
LP'N'INT::CONSO LP'N,0			;(-4) SKIP IF INTERRUPT FOR THIS LPT
	  JRST .-1			;(-3)  GO TO NEXT SKIP CHAIN ELEMENT
	  MOVEM F,LP'N'SV1		;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP F,LPTINT##		;(-1) SET UP DDB ADDRESS AND BRANCH
LP'N'DDB::
LP'N'NAM:
	LPNAM=SIXBIT /LPT/
	IFE	LPTN+DLPTN-1, <LPNAM>		;( 0) PHYSICAL DEVICE NAME
	IFN	LPTN+DLPTN-1, <LPNAM+<20+$LPNUM>B23>	;( 0) PHYSICAL DEVICE NAME
	<XWD <6*HUNGST>,LPTSIZ>+<M'CPU'LP'N'L>B0  ;( 1) DEVICE CHARACTERISTICS
					; HUNG TIME IS 63 SECS (CODE 6)
	  0				;( 2) DEVICE I/O STATUS
	  XWD 0,LPTDSP##			;( 3) LH=DDB LINK, RH=DSP TABLE ADDR.
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES
	  XWD DVOUT+DVLPT,LPTMOD	;( 4) DEVICE CHARACTERISTICS
	  0 				;( 5) LOGICAL DEVICE NAME
	  0				;( 6) BUFFER HEADER ADDRESSES
LPTPTR==:.-LP'N'DDB
LP'N'PTR: 0				;( 7) BLOCK OUTPUT POINTER
	 0			;(10) CURRENT OUTPUT BUFFER ADDRESS
LP'N'STS:	0			;(11) DEVICE STATUS WORD
	XWD	.TYLPT!.SPLPT!DEPLEN,0	;SPOOLED LPT, VAR BUFS, DON'T DEADVANCE
	0				;DEVXTR
	0				;DEVEVM
	0				;DEVPSI
	0				;DEVESE
	0				;DEVHCW
	BYTE	(3)CPUN(33)0		;DEVCPU
	0				;DEVISN
	<N>B17				;PUNIT+DEVJOB
LPTCH==:.-LP'N'DDB
	  EXP LP'N'BTH##		; INTERRUPT CHANNEL ASSIGNMENTS
LPTSVE==:.-LP'N'DDB
	  MOVE F,LP'N'SV1		; RESTORE F, SAVE AC'S
	  JSR LP'N'SAV##		;  AND ESTABLISH P
	  MOVEI F,LP'N'NAM		; SET UP DDB ADDRESS AND RETURN
	  JRST LPTNXT##			;  TO COMMON INTERRUPT HANDLER
LPTEX1==:.-LP'N'DDB
	  MOVE F,LP'N'SV1		; RESTORE F AND
	XJEN	LP'N'CHL##

LPTSV2==:.-LP'N'DDB
	  0				; SAVE LOCATION FOR U
LPTDAP==:.-LP'N'DDB
	  0				;PLACE TO BUILD AOBJN POINTER
					;TO ERROR BLOCK
LPTDAE==:.-LP'N'DDB
	  BLOCK	7			;SYSERR BLOCK
					; THE REST OF THE DDB CONTAINS
LPTDNO==:.-LP'N'DDB
	  CONSZ LP'N,CI%SKE##		;  THE ACTUAL I/O INSTRUCTIONS
LPTDNZ==:.-LP'N'DDB
	  CONSO	LP'N,CI%SKE##
LPTCSO==:.-LP'N'DDB
	  CONSO LP'N,(U)		;  USED BY THE COMMON SERVICE
LPTCSZ==:.-LP'N'DDB
	  CONSZ LP'N,(U)		;  ROUTINE TO CONTROL A LINE
LPTCNI==:.-LP'N'DDB
	  CONI  LP'N,U			;  PRINTER. THEY ARE EXECUTED
LPTCNO==:.-LP'N'DDB
	  CONO  LP'N,(U)		;  BY MEANS OF AN XCT INSTRUCTION
LPTDTO==:.-LP'N'DDB
	  DATAO LP'N,(U)		;  INDEXED TO THE PROPER DDB
LPTBKO==:.-LP'N'DDB
	  BLKO  LP'N,LP'N'PTR		;
LPTPAG==:.-LP'N'DDB
	  0				;PAGE COUNTER WORD
LPXSTS==:.-LP'N'DDB
	CONI	LP'N,LP'N'STS		; DEVICE STATUS WORD CONI


	LIST				;TURN LISTING BACK ON AFTER EXPANSION

>;END OF DEFINE LPTDDB

	GENDDS	LPT,LP

	>;END "IFG LPTN"
   IFG DLPTN,<;GENERATE DLP DDB'S IF NECESSARY

;RSX-20F LINEPRINTER DDB DEFINITIONS

DEFINE	DLPDDB	(CPUN,N,U,D)	<
	XLIST				;TURN OFF LISTING DURING EXPANSION

;HARDWARE CHARACTERISTICS DEFAULTS

   IFNDEF M'CPUN'FL'U'L,<M'CPUN'FL'U'L==:0>	;PRINTER IS UPPER-CASE
   IFNDEF M'CPUN'FL'U'P,<M'CPUN'FL'U'P==:0>	;NO PAGE COUNTER
   IFNDEF M'CPUN'FL'U'V,<M'CPUN'FL'U'V==:1>	;DAVFU
   IFNDEF M'CPUN'FL'U'C,<M'CPUN'FL'U'C==:0>	;64-CHAR SET
   IFNDEF M'CPUN'FL'U'N,<M'CPUN'FL'U'N==:0>	;NO CHAR SET NAME
   IFNDEF M'CPUN'FL'U'T,<M'CPUN'FL'U'T==:3>	;RSX-20F LPT

FL'N'DDB::
FL'N'NAM:
	LPNAM=SIXBIT/LPT/
	IFE LPTN+DLPTN-1,<LPNAM>		;(0) PHYSICAL DEVICE NAME
	IFN LPTN+DLPTN-1,<LPNAM+<20+$DLPNM>B23> ;(0) PHYSICAL DEVICE NAME
	<XWD <5*HUNGST>,LPTSIZ>+<M'CPUN'FL'U'L>B0 ;(1) DEVICE CHARACTERISTICS
					;HUNG TIME IS 31 SECONDS
	0				;(2) DEVICE I/O STATUS
	XWD	0,RLPDSP##		;(3) DDB LINK,,DSP TABLE ADDRESS
DLPMOD==1_A+1_AL+1_BYTMOD+1_I		;LEGAL MODES
	XWD	DVOUT+DVLPT,DLPMOD	;(4) DEVICE CHARACTERISTICS
	0				;(5) LOGICAL DEVICE NAME
	0				;(6) BUFFER HEADER ADDRESSES
	0				;(7) OUTPUT POINTER
	0				;(10) CURRENT OUTPUT BUFFER ADDRESS
	0				;(11) DEVICE STATUS WORD
	XWD	.TYLPT!.SPLPT!DEPLEN,0	;SPOOLED LPT, VAR BUFS, DON'T DEADVANCE
	0				;DEVXTR
	0				;DEVEVM
	0				;DEVPSI
	0				;DEVESE
	BYTE (1) M'CPUN'FL'U'L, M'CPUN'FL'U'P, 0 (3) M'CPUN'FL'U'V, M'CPUN'FL'U'C (3) M'CPUN'FL'U'T (6) 0 (18) M'CPUN'FL'U'N
					;DEVHCW
	BYTE	(3)CPUN(33)0		;DEVCPU
	0				;DEVISN
	<N>B17				;PUNIT+DEVJOB
	0				;COUNT OF OUTPUT CHARS
DLPDUX==:.-FL'N'DDB
	XWD	U,D			;UNIT # ON FRONT-END,,DLP DTE INDEX
DLPMLA==:.-FL'N'DDB
	0				;MAXIMUM LINE ALLOCATION
DLPRLA==:.-FL'N'DDB
	0				;REMAINING LINE ALLOCATION
DLPSNT==:.-FL'N'DDB
	0				;NUMBER OF WORDS ALREADY SENT

	LIST				;TURN LISTING BACK ON AFTER EXPANSION
>;END DEFINE OF DLPDDB
   ; ... STILL IN IFG DLPTN CONDITIONAL

DEFINE	RSXDTE	(C,D)	<

   IFNDEF M'C'LP'D'N,<M'C'LP'D'N==:0>

   IFG M'C'LP'D'N,<			;;DO ONLY IF AT LEAST ONE LPT ON DTE
	EXTERN	DLPSER
	$LPUNT==0			;;UNIT STARTS AT ZERO FOR EACH DTE
	REPEAT	M'C'LP'D'N,<		;;DO FOR EACH LPT ON DTE
		DLPDDB	\C,\<$DLPNM-$LPNUM>,\$LPUNT,$DTNDX
					;;GENERATE DDB
		$LPUNT==$LPUNT+1	;;STEP TO NEXT UNIT ON DTE
		$DLPNM==$DLPNM+1	;;STEP TO NEXT UNIT FOR SYSTEM
	>
	$DTNDX==$DTNDX+1		;;STEP TO NEXT DTE
   >
>
	IFNDEF $LPNUM,<$LPNUM==0>

		$DLPNM==$LPNUM			;START DLP UNITS AFTER REGULAR LPTS

		$DTNDX==0			;DTE INDEX FOR MACRO STARTS AT 0
		RSX20F				;GENERATE DDB'S FOR RSX-20F LPT'S


>;END IFG DLPTN

;DEFINE DLPDSP IF DLPSER IS NOT LOADED
IFN FTKL10,<
IFE M.DLP,<
DLPDSP==:EATDSP##		;IGNORE DLP MESSAGES
>;END IFE M.DLP
>;END FTKL10
>;END IFE FTKS10
IFN FTKS10,<

	IFG	LPTN, <

MAXLBZ==:^D253				;MAX WORD SIZE OF USER'S LPT BUFFERS
					;(LPTSPL USES THIS NUMBER)
LPTMOD==1_A+1_AL+1_I			;LPT LEGAL MODES

;DEFINITION FOR LINE PRINTER DEVICE DATA BLOCKS

DEFINE	LPTDDB (N) <

	XLIST				;TURN OFF LISTING DURING EXPANSION

LP'N'INT::0				;INTERRUPT JSR'S TO HERE
	EXP	0,IC.UOU,.+1		;XPCW BLOCK

	EXCH	T1,LP'N'INT		;GET INTERRUPT PC
	MOVEM	T1,LP'N'CHL##		;PUT INTO -10 STYLE INTERRUPT HANDLER
	MOVE	T1,LP'N'INT+1		;NEXT
	MOVEM	T1,LP'N'CHL##+1

	MOVE	T1,LP'N'INT		;AND RESTORE T1
	JSR	LP'N'SAV##		;SAVE AC'S
	JSP	F,LPTINT##		;SET UP F AND GO TO INTERRUPT CODE
LP'N'DDB::PHASE 0
	LPNAM=SIXBIT /LPT/
	IFE	LPTN-1, <LPNAM>		;(0) DEVNAM
	IFN	LPTN-1, <LPNAM+<20+$LPNUM>B23>
	<XWD <6*HUNGST>,LPTSIZ>+<M.LP'N'L>B0  ;(1) DEVCHR
	  0				;(2) DEVIOS
	  XWD 0,LPTDSP##		;(3) DEVSER
	  XWD DVOUT+DVLPT,LPTMOD	;(4) DEVMOD
	  0 				;(5) DEVLOG
	  0				;(6) DEVBUF
LPTPTR::!0				;(7) DEVIAD
	XWD R,0				;(10) DEVOAD
	0				;(11) DEVSTS
	XWD	.TYLPT!.SPLPT!DEPLEN,0	;(12) DEVSTA
	0				;(13) DEVXTR
	0				;(14) DEVEVM
	0				;(15) DEVPSI
	0				;(16) DEVESE
	0				;(17) DEVHCW
	BYTE	(3)0(33)0		;(20) DEVCPU
	0				;(21) DEVISN
	<N>B17				;(22) PUNIT+DEVJOB
LPTDAP::!0				;PLACE TO BUILD AOBJN POINTER TO LPTDAE
LPTDAE::!BLOCK	13			;SYSERR BLOCK
LPTSTS::!0				;MORE DEVICE STATUS
LPTRSV::!0				;SAVE AREA DURING UP-ARROW TRANSLATION
LPTWSV::!0				;...
LPTUDC::!0				;UNDEFINED CHAR INTERRUPT DATA SAVED
LPTPAG::!0				;PAGE COUNTER WORD
LPTVEC::!LP11IV				;-11 STYLE INTERRUPT VECTOR ADDRESS
LPTBAS::!LP11CA				;LP20 BASE DEVICE ADDRESS
LPTIVI::!XPCW	LP'N'INT		;INTERRUPT INSTRUCTION FOR THIS LPT

LPTFNC::!0				;CURRENT FUNCTION BITS SAVED HERE
LPTBYT::!0				;OUTPUT BYTE COUNT STORED HERE
LPTCDB::! CHNMAC(\M.LP'N'C)		;POINTER TO CHANNEL DATA BLOCK
LPTBUF::!BLOCK <<MAXLBZ*5>/4>+1		;ENOUGH ROOM FOR LPTSPL 7 TO 8 BIT BYTE CONVERSION
LPTBFZ==:.-LPTBUF			;SIZE OF THE LPT BUFFER
	DEPHASE				;BACK TO NORMAL
	LIST				;TURN LISTING BACK ON AFTER EXPANSION

>;END DEFINE LPTDDB
		EXTERNAL LP2SER		;HAUL IN THE SERVICE ROUTINE

		$LPNUM==0		;LPT NUMBER SYMBOL

IFG LPTN-1,<PRINTX KS10 MONITOR DOES NOT SUPPORT MORE THAN ONE LPT>

		REPEAT LPTN, <

			LPTDDB \$LPNUM
			$LPNUM==$LPNUM+1
		>
>;END IFG TAPN
>;END IFN FTKS10
SUBTTL	PLOTTER DDB DEFINITIONS
	IFG	PLTN, <
;CALCOMP PLOTTER DDB DEFINITIONS

DEFINE	PLTDDB	(N,P,CPU,CPUN) <
	XLIST			;TURN OFF LISTING DURING EXPANSION

	PLT2==144		;DEVICE SELECTION CODE FOR SECOND PLOTTER
	IFNDEF	PL'CPU'0,<PL'CPU'0==PLT> ;DEFINE STANDARD MNEMONIC DEFINITIONS
	IFNDEF	PL'CPU'1,<PL'CPU'1==PLT2>; BUT ALLOW FOR OVERRIDE

PL'N==PL'CPU'P

PL'N'SV1==PL'N'SAC##+F		;DEFINE F SAVE LOCATION

PLTCON==:.-PL'N'DDB
PL'N'INT::CONSO	PL'N,0		; SKIP IF INTERRUPT FOR THIS PLT
	JRST	.-1		; GO TO NEXT SKIP CHAIN ELEMENT
	CONI	PL'N,PL'N'STS
	SOSGE	PL'N'CTR	;OUTPUT CHARACTERS LEFT?
	JRST	PL'N'IN2	;NO
	MOVEM	T1,PL'N'SV1	;SAVE T1 IN CHANNEL SAVE AREA
	ILDB	T1,PL'N'PTR	;GET NEXT CHARACTER
PLTDTO==:.-PL'N'DDB
	DATAO	PL'N,T1		;SEND TO PLOTTER
	MOVE	T1,PL'N'SV1	;RESTORE T1 AND
	XJEN	PL'N'CHL##


PL'N'IN2:JSR	PL'N'SAV##	;SAVE AC'S
	JSP	F,PLTNXT##	;SET UP F, GO TO PLOTTER SERVICE

PL'N'DDB::
PL'N'NAM:	PLNAM==SIXBIT /PLT/
	IFE	PLTN-1,<PLNAM>	; ( 0) PHYSICAL DEVICE NAME
	IFN	PLTN-1,<PLNAM+<20+$PLNUM>B23>; ( 0) PHYSICAL DEVICE NAME
	XWD	HUNGST*4,^D36	;( 1) XWD (HUNG TIMEOUT),(BUFFER SIZE)
				; CODE 4 - HUNG TIME=15 SECONDS
	0			;( 2) DEVICE IO STATUS
	XWD	0,PLTDSP##	;( 3) LH=DDB LINK; RH=DSP TABLE ADDR.
PLTMOD==1_A+1_AL+1_I+1_IB+1_B		;PLOTTER LEGAL MODES
	XWD	DVOUT,PLTMOD	;( 4) XWD (OUTPUT DEV), (MODES)
	0			;( 5) LOGICAL DEVICE NAME
	0			;( 6) BUFFER HEADER ADDRESSES
PLTPTR==:.-PL'N'DDB
PL'N'PTR:	0		;( 7) OUTPUT BYTE POINTER
	0			;(10) CURRENT OUTPUT BUFFER ADDRESS
PL'N'STS:	0		;(11) DEVICE STATUS WORD
	XWD	.TYPLT!.SPPLT,0	;(12) SPOOLED PLT
	0			;(13) DEVXTR
	0			;(14) DEVEVM
	0			;(15) DEVPSI
	0			;(16) DEVESE
	0			;(17) DEVHCW
	BYTE	(3)CPUN(33)0	;(20) DEVCPU
	0			;(21) DEVISN
	<N>B17			;(22) PUNIT+DEVJOB
PL'N'CTR:	0		;OUTPUT BYTE COUNTER
PLTCH==:.-PL'N'DDB
	PL'N'CHN##		; INTERRUPT CHANNEL

PLTCNO==:.-PL'N'DDB
	CONO	PL'N,(T1)	;XCT'D FROM PLTSER

	LIST			;TURN ON LISTING AFTER EXPANSION
>	;END OF PLTDDB MACRO DEFINITION


	GENDDS	PLT,PL

>	;END OF "IFG PLTN"
SUBTTL	DEFINITIONS FOR PAPER TAPE AND PTY'S

	IFG	PTRN, <

SUBTTL PAPER TAPE READER DDB DEFINITIONS

IFE FTKS10,<
DEFINE	PTRDDB	(N,P,CPU,CPUN) <

	IFNDEF	PR'CPU'0,<PR'CPU'0==PTR>

PR'N==PR'CPU'P

PR'N'SV1==PR'N'SAC##+F		;DEFINE F SAVE LOCATION

PTRCON==:.-PR'N'DDB
PR'N'INT::CONSO	PR'N,0		;(-4) SKIP IF INTERRUPT FOR THIS READER
	  JRST	.-1		;(-3) NOT HERE, CONTINUE DOWN THE CHAIN
	  MOVEM	F,PR'N'SV1	;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP	F,PTRINT##	;(-1) SET F TO DDB ADDRESS AND SERVICE INTERRUPT
PR'N'DDB::
PR'N'NAM:	PTRNAM=SIXBIT/PTR/
	IFE	PTRN-1,<PTRNAM>	;(0) PHYSICAL DEVICE NAME
	IFN	PTRN-1,<PTRNAM+<20+$PRNUM>B23>	;(0) PHYSICAL DEVICE NAME
	XWD	5*HUNGST,41	;(1) CODE 5 - HUNG TIME IS 31 SECONDS
PTRIOS==:.-PR'N'DDB
	0			;(2) DEVIOS
	PTRDSP##		;(3) LH=DDB LINK, RH=PTR DISPATCH TABLE
	XWD	DVPTR+DVIN,14403;(4) DEVICE CHARACTERISTICS
	0			;(5) LOGICAL DEVICE NAME (DEVLOG)
	0			;(6) BUFFER HEADER ADDRESSES
PTRIAD==:.-PR'N'DDB
	0			;(7) ADDRESS OF CURRENT INPUT BUFFER
PTRPTR==:.-PR'N'DDB
	0			;(10) BYTE POINTER TO CURRENT INPUT BUFFER
PTRSTS==.-PR'N'DDB
PR'N'STS: 0			;(11) LATEST CONI STATUS BITS
	XWD	.TYPTR!DEPLEN,0	;NON-SPOOLED, VARIABLE BUFFER SIZE
	0			;DEVXTR
	0			;DEVEVM
	0			;DEVPSI
	0			;DEVESE
	0			;DEVHCW
	BYTE	(3)CPUN(33)0	;DEVCPU
	0			;DEVISN
	<N>B17			;PUNIT+DEVJOB
PTRCTR==:.-PR'N'DDB
	0			;BYTE COUNTER FOR IDPB'S INTO USER'S BUFFERS
PTRSV1==:.-PR'N'DDB
	0			;TEMPORARY LOACATION FOR SAVING AN AC
PTRCH==:.-PR'N'DDB
	EXP	PR'N'CHN##	;PTR PIA
PTRPWR==:.-PR'N'DDB
	CONSO	PR'N,POW##	;PTR ON/OFF?
PTRCNO==:.-PR'N'DDB
	CONO	PR'N,(U)
PTRDTI==:.-PR'N'DDB
	DATAI	PR'N,U
PTRDS1==:.-PR'N'DDB
	DATAI	PR'N,PTRSV1(F)
PTRSVE==:.-PR'N'DDB
PR'N'SVE: 0			;ROUTINE TO SAVE AC'S
	MOVE	F,PR'N'SV1	;RESTORE F
	JSR	PR'N'SAV##	;SAVE AC'S AND ESTABLISH P
	MOVEI	F,PR'N'DDB	;SET UP DDB ADDRESS
	JRST	@PR'N'SVE	;AND RETURN
PTREX1==:.-PR'N'DDB
	MOVE	F,PR'N'SV1	;RESTORE F
	XJEN	PR'N'CHL##

PTRXSTS==:.-PR'N'DDB
	CONI	PR'N,PR'N'STS
>;DEFINE
>;IFE FTKS10
IFN FTKS10,<
DEFINE	PTRDDB	(N,P,CPU,CPUN) <

	IFNDEF	PR'CPU'0C,<PR'CPU'0C==PR11CA>
	IFNDEF	PR'CPU'0I,<PR'CPU'0I==PR11IV>

PR'N'INT::EXP	0,0,IC.UOU,.+1	;XPCW here from IVT
	EXCH	T1,PR'N'INT	;Find return PC
	MOVEM	T1,PR'N'CHL##	;Store in return locn
	MOVE	T1,PR'N'INT+1	;Second word with KLP
	MOVEM	T1,PR'N'CHL##+1	;...
	MOVE	T1,PR'N'INT	;Restore T1
	JSR	PR'N'SAV##	;Get our AC block
	JSP	F,PTRINT##	;(-1) SET F TO DDB ADDRESS AND SERVICE INTERRUPT
PR'N'DDB::
PR'N'NAM:	PTRNAM=SIXBIT/PTR/
	IFE	PTRN-1,<PTRNAM>	;(0) PHYSICAL DEVICE NAME
	IFN	PTRN-1,<PTRNAM+<20+$PRNUM>B23>	;(0) PHYSICAL DEVICE NAME
	XWD	5*HUNGST,41	;(1) CODE 5 - HUNG TIME IS 31 SECONDS
	0			;(2) DEVIOS
	PTRDSP##		;(3) LH=DDB LINK, RH=PTR DISPATCH TABLE
	XWD	DVPTR+DVIN,14403;(4) DEVICE CHARACTERISTICS
	0			;(5) LOGICAL DEVICE NAME (DEVLOG)
	0			;(6) BUFFER HEADER ADDRESSES
	0			;(7) ADDRESS OF CURRENT INPUT BUFFER
	0			;(10) BYTE POINTER TO CURRENT INPUT BUFFER
	0			;(11) LATEST CONI STATUS BITS
	XWD	.TYPTR!DEPLEN,0	;NON-SPOOLED, VARIABLE BUFFER SIZE
	0			;DEVXTR
	0			;DEVEVM
	0			;DEVPSI
	0			;DEVESE
	0			;DEVHCW
	BYTE	(3)CPUN(33)0	;DEVCPU
	0			;DEVISN
	0			;DEVJOB
	0			;BYTE COUNTER FOR IDPB'S INTO USER'S BUFFERS
PTRBLK==:.-PR'N'DDB
	BLOCK	2		;Temps for PC20 hardware simulation
PTRDTI==:.-PR'N'DDB
	EXP	PR'CPU'0C,PR'CPU'0C+2,PR'CPU'0I
	XPCW	PR'N'INT
>;End DEFINE PTRDDB
>;End FTKS10

	GENDDS	PTR,PR
>;END IFG PTR

	IFG	PTPN, <

SUBTTL PAPER TAPE PUNCH DDB DEFINITIONS

IFE FTKS10,<
DEFINE	PTPDDB	(N,P,CPU,CPUN) <

	IFNDEF	PP'CPU'0,<PP'CPU'0==PTP>

PP'N==PP'CPU'P

PP'N'SV1==PP'N'SAC##+F		;DEFINE F SAVE LOCATION

PTPCON==:.-PP'N'DDB
PP'N'INT::CONSO	PP'N,0		;(-4) SKIP IF INTERRUPT FOR THIS READER
	  JRST	.-1		;(-3) NOT HERE, CONTINUE DOWN THE CHAIN
	  MOVEM	F,PP'N'SV1	;(-2) SAVE F IN CHANNEL SAVE AREA
	  JSP	F,PTPINT##	;(-1) SET F TO DDB ADDRESS AND SERVICE INTERRUPT
PP'N'DDB::
PP'N'NAM:	PTPNAM=SIXBIT/PTP/
	IFE	PTPN-1,<PTPNAM>	;(0) PHYSICAL DEVICE NAME
	IFN	PTPN-1,<PTPNAM+<20+$PPNUM>B23>	;(0) PHYSICAL DEVICE NAME
	XWD	4*HUNGST,41	;(1) CODE 4 - HUNG TIME IS 15 SECONDS
PTPIOS==:.-PP'N'DDB
	0			;(2) DEVIOS
	PTPDSP##		;(3) LH=DDB LINK, RH=PTP DISPATCH TABLE
	XWD	DVPTP+DVOUT,14403 ;(4) DEVICE CHARACTERISTICS
	0			;(5) LOGICAL DEVICE NAME (DEVLOG)
	0			;(6) BUFFER HEADER ADDRESSES
PTPPTR==:.-PP'N'DDB
	0			;(7) BYTE POINTER TO CURRENT OUTPUT BUFFER
PTPOAD==:.-PP'N'DDB
	0			;(10) ADDRESS OF CURRENT OUTPUT BUFFER
PTPSTS==.-PP'N'DDB
PP'N'STS: 0			;(11) LATEST CONI STATUS BITS
	XWD	.TYPTP!.SPPTP!DEPLEN,0	;VAR BUFFERS, SPOOLED
	0			;DEVXTR
	0			;DEVEVM
	0			;DEVPSI
	0			;DEVESE
	0			;DEVHCW
	BYTE	(3)CPUN(33)0	;DEVCPU
	0			;DEVISN
	<N>B17			;PUNIT+DEVJOB
PTPCTR==:.-PP'N'DDB
	0			;BYTE COUNTER FOR ILDB'S FROM USER'S BUFFERS
PTPCNT==:.-PP'N'DDB
	0
PTPCHA==:.-PP'N'DDB
	0			;TEMPORARY LOCATION TO STORE CHAR
PTPSIO==:.-PP'N'DDB
	0			;SAVE DEVIOS
PTPCH==:.-PP'N'DDB
	EXP	PP'N'CHN##	;PTP PIA
PTPCNO==:.-PP'N'DDB
	CONO	PP'N,(U)
PTPCN0==:.-PP'N'DDB
	CONO	PP'N,0		;TURN PTR OFF
PTPSDN==:.-PP'N'DDB
	CONO	PP'N,PTPDON##(T1);SET DONE
PTPOOT==:.-PP'N'DDB
	CONSO	PP'N,PTPNTP##	;OUT OF TAPE?
PTPDTO==:.-PP'N'DDB
	DATAO	PP'N,T1
PTPDOC==:.-PP'N'DDB
	DATAO	PP'N,PTPCHA(F)
PTPSVE==:.-PP'N'DDB
PP'N'SVE: 0			;ROUTINE TO SAVE AC'S
	MOVE	F,PP'N'SV1	;RESTORE F
	JSR	PP'N'SAV##	;SAVE AC'S AND ESTABLISH P
	MOVEI	F,PP'N'DDB	;SET UP DDB ADDRESS
	JRST	@PP'N'SVE	;AND RETURN
PTPEX1==:.-PP'N'DDB
	MOVE	F,PP'N'SV1	;RESTORE F
	XJEN	PP'N'CHL##

PTPXSTS==:.-PP'N'DDB
	CONI	PP'N,PP'N'STS
>;DEFINE
>;FTKS10
IFN FTKS10,<

DEFINE	PTPDDB	(N,P,CPU,CPUN) <

	IFNDEF	PP'CPU'0C,<PP'CPU'0C==PP11CA>
	IFNDEF	PP'CPU'0I,<PP'CPU'0I==PP11IV>

PP'N'INT::EXP	0,0,IC.UOU,.+1
	EXCH	T1,PP'N'INT	;Get return PC
	MOVEM	T1,PP'N'CHL##	;Save for return
	MOVE	T1,PP'N'INT+1
	MOVEM	T1,PP'N'CHL##+1
	MOVE	T1,PP'N'INT	;Restore T1
	JSR	PP'N'SAV##	;Get our AC block
	JSP	F,PTPINT##	;(-1) SET F TO DDB ADDRESS AND SERVICE INTERRUPT
PP'N'DDB::
PP'N'NAM:	PTPNAM=SIXBIT/PTP/
	IFE	PTPN-1,<PTPNAM>	;(0) PHYSICAL DEVICE NAME
	IFN	PTPN-1,<PTPNAM+<20+$PPNUM>B23>	;(0) PHYSICAL DEVICE NAME
	XWD	4*HUNGST,41	;(1) CODE 4 - HUNG TIME IS 15 SECONDS
	0			;(2) DEVIOS
	PTPDSP##		;(3) LH=DDB LINK, RH=PTP DISPATCH TABLE
	XWD	DVPTP+DVOUT,14403 ;(4) DEVICE CHARACTERISTICS
	0			;(5) LOGICAL DEVICE NAME (DEVLOG)
	0			;(6) BUFFER HEADER ADDRESSES
	0			;(7) BYTE POINTER TO CURRENT OUTPUT BUFFER
	0			;(10) ADDRESS OF CURRENT OUTPUT BUFFER
	0			;(11) LATEST CONI STATUS BITS
	XWD	.TYPTP!.SPPTP!DEPLEN,0	;VAR BUFFERS, SPOOLED
	0			;DEVXTR
	0			;DEVEVM
	0			;DEVPSI
	0			;DEVESE
	0			;DEVHCW
	BYTE	(3)CPUN(33)0	;DEVCPU
	0			;DEVISN
	0			;DEVJOB
	0			;BYTE COUNTER FOR ILDB'S FROM USER'S BUFFERS
PTPCNT==:.-PP'N'DDB
	0
PTPCHA==:.-PP'N'DDB
	0			;TEMPORARY LOCATION TO STORE CHAR
PTPCNO==:.-PP'N'DDB
	EXP	PP'CPU'0C,PP'CPU'0C+2,PP'CPU'0I
	XPCW	PP'N'INT
>;End DEFINE PTPDDB
>;FTKS10

	GENDDS	PTP,PP

>;END IFG PTP
PASCII==:700
PIMAGE==:4400
PIMTTY==:1000
PBYTMD==:1000


;PSEUDO TTY ENTRY POINT

	IFE	PTYN, <PTYPE::PTMNMZ::PTYOW::PTMNMD::HALT CPOPJ##	;HALT IF SCNSER CALL PTY ROUTINES
PTYDSP==:0					; BECAUSE NONE LOADED
PTYLST==:0					;SATISFY GLOBOL IN SYSINI
;IF NO PTY'S, SATISFY GLOBALS
CTLJOB==:CPOPJ##
UJBSTS==:CPOPJ##
PTBTCH==:CPOPJ1##
;IF NO PTY'S, JOB CAN NEVER BE CONTROLLED BY PTY, SO
; SUBSTITUTE THIS DUMMY SUBROUTINE FOR CTLJB
CTLJBU::SETZM	U		;NO LDB
CTLJB::
CTLJBD::MOVNI	T1,1
	POPJ	P,
>
	IFG	PTYN, <
	EXTERNAL PTYSER			;LOAD PTY SERVICE ROUTINE
>
IFN FTKL10,<;DO THIS STUFF ONLY FOR KL CPU'S

;DEFINE SYMBOLS AND STORAGE FOR RSX-20F ASYNC TERMINALS

	$HIGH				;THIS PART INTO THE HIGH SEGMENT

DEFINE	RSXDTE(C,D),<
   IFE D,<
	EXP	$TTOFS
	$TTOFS==$TTOFS+M'C'TTDN
   >
>
	$TTOFS==TTDLAL			;INITIALIZE SYMBOL USED IN FOLLOWING MACRO
TTDOFS::RSX20F				;TABLE OF TTD LINE TABLE OFFSETS
	EXP	$TTOFS			;FIRST LINE AFTER DTE DRIVEN LINES
TTDLOM==:TTDOFS+1			;BASE OF RANGE CHECK TABLE
TTDDSO==:<TTDLAL-TTDDAL>		;TRANSLATION FOR DSCTAB ENTRIES


IFG DLPTN,<		;DO THIS ONLY IF RSX-20F LPT'S

;DEFINE STORAGE AND SYMBOLS FOR LINEPRINTERS ON RSX-20F FRONT-ENDS

DEFINE	RSXDTE	(C,D)	<

   IFG M'C'LP'D'N,<XWD	C,D>
>

LPCPDT::RSX20F				;MAKE TABLE WITH ONE ENTRY FOR EACH
					; RSX-20F FRONT-END SUPPORTING LINEPRINTERS
RSXLPN==:.-LPCPDT			;NUMBER OF SUCH FRONT-ENDS


LPDTDV::				;TABLE TO CONVERT FROM CPU #, DTE #,
					;AND UNIT NUMBER TO DDB ADDRESS

DEFINE	LPCPDT	(C)	<
  IFDEF M'C'DTEN,<Z @LP'C'DTE(P1)>	;INDEX OFF DTE NUMBER
  IFNDEF M'C'DTEN,<Z>			;NO DTE'S ON THIS CPU
>

	ZZ==0
REPEAT CPUN,<
	LPCPDT	\ZZ
	ZZ==ZZ+1
>

DEFINE	RSXDTE	(C,D)	<
  IFE D,<LP'C'DTE:>
  IFN M'C'LP'D'N,<Z @LP'C'D'DV(T1)>	;INDEX OFF LINE NUMBER
  IFE M'C'LP'D'N,<Z>			;NO LINE PRINTERS THIS DTE
>

	RSX20F				;GENERATE DTE TABLE

DEFINE	RSXDTE	(C,D)	<
  IFN M'C'LP'D'N,<
    LP'C'D'DV:
    REPEAT M'C'LP'D'N,<
	DLPDDB	\ZZ
	ZZ==ZZ+1
    >
REPEAT	<2-M'C'LP'D'N>,<
	Z
>
  >
>

DEFINE	DLPDDB	(X) <FL'X'DDB>

	ZZ==0

	RSX20F				;GENERATE THE DDB ADDRESS TABLE

>;END IFG DLPTN
   ; ... STILL IN FTKL10 CONDITIONAL

IFN DCDRN,<

	$HIGH

;DEFINE SPECIAL TABLES FOR RSX20F CARD READERS


DEFINE	RSXDTE	(C,D)	<
	XWD	C,D
>

CRCPDT::RSX20F				;CORRESPONDENCE TABLE BETWEEN
					;DTE INDEX AND CPU#,,DTE # FOR
					;DTESER

CRDTDV::				;TABLE TO CONVERT FROM CPU #, DTE #,
					;AND UNIT NUMBER TO DDB ADDRESS

DEFINE	CRCPDT	(C)	<
  IFDEF M'C'DTEN,<Z @CR'C'DTE(P1)>	;INDEX OFF DTE NUMBER
  IFNDEF M'C'DTEN,<Z>			;NO DTE'S ON THIS CPU
>

	ZZ==0
REPEAT CPUN,<
	CRCPDT	\ZZ
	ZZ==ZZ+1
>

DEFINE	RSXDTE	(C,D)	<
  IFE D,<CR'C'DTE:>
  IFN M'C'CR'D'N,<Z @CR'C'D'DV(T1)>	;INDEX OFF LINE NUMBER
  IFE M'C'CR'D'N,<Z>			;NO CARD READERS THIS DTE
>

	RSX20F				;GENERATE DTE TABLE

DEFINE	RSXDTE	(C,D)	<
  IFN M'C'CR'D'N,<
    CR'C'D'DV:
    REPEAT M'C'CR'D'N,<
	DCRDDB	\ZZ
	ZZ==ZZ+1
    >
  >
>

DEFINE	DCRDDB	(X) <FC'X'DDB>

	ZZ==0

	RSX20F				;GENERATE THE DDB ADDRESS TABLE


>;END IFN DCDRN
>;END IFN FTKL10
SUBTTL	ROUTINES COMMON TO PDP11 COMM FRONT-END'S ON DL10'S

IFN PDP11N,<
	DLMAP
	$HIGH

;SUBROUTINE TO PROCESS THE COMMAND:
;	.SET NOMESSAGE PDP11 N
;CALL WITH:
;	PUSHJ	P,D76SIL
;	RETURN HERE OR JRST COMERA
D76SIL::PUSHJ	P,DECIN##	;READ A DECIMAL NUMBER
	  JRST	D76SIP		;NO NUMBER ASSUME ZERO
	  CAIA			;ILLEGAL CHARACTER MAYBE
	  JRST	D76SIP		;OK GOT A DIGIT
	CAIE	T3,"*"		;WILD CARD
	JRST	COMERA##	;NO, ERROR
	MOVEI	T2,7		;YES, SET SIL ON ALL PDP11'S
	PUSHJ	P,D76SIA	;CONTINUE
	  JFCL			;IGNORE IF NOT THERE
	SOJGE	T2,.-2		;CONTINUE
	POPJ	P,		;RETURN
D76SIP:	PUSHJ	P,D76SIA	;GO SILENCE THIS 76
	  JRST	COMERA##		;LOST, GIVE ERROR
	POPJ	P,		;RETURN

D76SIA:	SKIPL	T2		;.LT. 0 IS WRONG.
	CAIL	T2,10		;SKIP IF PORT .LT. 8
	POPJ	P,		;INVALID PORT #
IFN M.DAS78,<
	CAILE	T2,M78HPO##	;SEE IF THIS PORT EXISTS ON A DAS78
	JRST	D76SI1		;NO, TRY OTHER 11S
	SKIPE	T1,M78BAT##(T2)	;IF A DAS78 THEN
	JRST	D76SI0		; ALL SET
> ;END IFN M.DAS78

D76SI1:	SKIPE	T1,DLXBAT##(T2)	;IF NO KNOWN PORT OR
	SKIPN	T1,DLXWIN##(T1)	; NO WINDOW ASSIGNED THEN
	POPJ	P,		; COMPLAIN
D76SI0:	SKIPG	DWN(T1)		;IS THE PDP11 DOWN?
	SETOM	DWN(T1)		;YES--TURN OFF THE MESSAGE
	JRST	CPOPJ1##	;RETURN
	$LOW
>	;END OF IFN PDP11N
IFN <PDP11N-DLX.78>,< ;IF ANY DL10 BASED 11S BUT NOT DAS78S

;ROUTINE TO GET ERROR STATUS AND CALL DAEMON FOR AN ERROR
;ON A DC76, DN85 OR DN60
;ARGUMENTS	T1=PORT # OF 11 WITH ERROR
DLB==60	;DEVICE CODE FOR DL10
DLC==64	;DEVICE CODE FOR DL10

DLBREG==3	;NUMBER OF HIGHEST CONI DLB, WE DO
DLBEDT==0	;VALUE OF R FOR DATAI DLB, WE WANT TO SAVE

	$HIGH
DL10EL::MOVEM	T1,DLEPRT	;SAVE THE PORT OF THE 11 WITH ERROR
	MOVE	T2,DLXNMT##(P2)	;GET NAME
	MOVEM	T2,DLEPGM	;SAVE
	HRLZ	T2,DLXTYP##(P2)
	MOVEM	T2,DLESTS
	MOVE	T2,DLXWIN##(P2)
	MOVE	T2,HLT(T2)
	HRRM	T2,DLESTS
	CONI	DLC,DLCCNI	;GET THE DLC CONI
	DATAI	DLC,DLCDTI	; AND DATAI
	MOVEI	T1,DLBREG	;GET NUMBER OF REGS TO SAVE OF DLB
DLBLUP:	DPB	T1,[POINT 2,DLBDTO,5]	;PUT REG INTO DATAO
	DATAO	DLB,DLBDTO	;AND DO DATAO SO CONI GETS RIGHT REG
	CONI	DLB,DLBCNI(T1)	;GET THIS DLB CONI
	CAIN	T1,DLBEDT	;IS THIS THE DATAI WE WANT?
	DATAI	DLB,DLBDTI	;YES, GET IT
	SOJGE	T1,DLBLUP	;AND LOOP BACK FOR NEXT REG
	MOVEI	T1,.ERDLE	;GET CODE FOR ERROR RPT UUO
	HRLI	T1,DLEBLK	;AND ADDRESS FOR DAEMON TO LOOK AT
	PJRST	DAEEIM##	;AND GO WAKE DAEMON

	$LOW
DLBDTO:	XWD	1,0		;BITS FOR DATAO DLB,
DLEBLK:-DLELEN,,DLEPRT	;AOBJN POINTER FOR ERROR BLOCK
DLEPRT:	BLOCK	1		;PORT OF 11 WITH ERROR
DLCCNI:	BLOCK	1		;CONI DLC AT ERROR
DLCDTI:	BLOCK	1		;DATAI DLC AT ERROR
DLBCNI:	BLOCK	4		;BLOCK FOR CONI DLB'S
DLBDTI:	BLOCK	1		;DATAI DLB WITH R=0 AT ERROR
DLEPGM:	BLOCK	1		;SIXBIT PROGRAM NAME
DLESTS:	BLOCK	1		;HALT STATUS
DLELEN==.-DLEPRT



> ;END IFN <PDP11N-DLX.78>
IFN <PDP11N!M.KL10!M.DN60!M.KDUP!M.DMRN>,< ;IF DL10S, DTES, DN60S, OR KMC/DUPS(DMRs)

;CAL11. UUO
	$HIGH

CALL11::PUSH	P,T1		;SAVE USER'S ARG
	HRLOI	P2,377777	;ASSUME PRIV. JOB.
	PUSHJ	P,PRUSET##	;SKIP IF PRIV.
	  TLO	P2,400000	;NOT PRIV.
	POP	P,T1		;RESTORE USER'S ARG
	HRR	M,T1		;GET USER'S AC
	HLRE	T3,T1		;GET COUNT
	JUMPLE	T3,ECOD7##	;.LE. ZERO ARGS NOT ENOUGH!
	PUSHJ	P,GETWDU##	;GET FUNCTION CODE INTO T1
	SOJL	T3,ECOD7##	;ERROR CODE 7: NOT ENOUGH ARGS
	MOVE	P3,T3		;SAVE LENGTH
	MOVE	P1,T1		;COPY FUNCTION WORD TO A SAFER PLACE
	SKIPL	P1		;OLD STYLE FUNCTION WORD?
	PUSHJ	P,C11OLD	;YES--HACK IT UP A BIT
	PUSHJ	P,C11ARG	;DECODE THE TYPE, CPU, AND PORT NUMBER
	  POPJ	P,		;RETURN ON ERRORS
	MOVE	T3,P3		;RESTORE LENGTH
	SKIPN	T2,DLXCAL##(W)	;GET CAL11. TABLE POINTER
	MOVE	T2,[XWD CAL11L,CAL11D]	;NONE, USE DEFAULT
	HLRZ	T4,T2		;GET LENGTH OF TABLE
	CAML	T1,T4		;FUNCTION TOO LARGE?
	  JRST	ECOD2##		;YES, ERROR CODE 2.
	ADD	T2,T1		;NO, POINT TO TABLE ENTRY
	MOVE	T1,0(T2)	;PICK UP ENTRY
	AND	T1,P2		;CLEAR SIGN BIT IF PRIV
	JUMPL	T1,ECOD1##	;IF STILL SET, NEED PRIV.
	PUSHJ	P,0(T1)		;GO DO FUNCTION
	  POPJ	P,		;PROPAGATE ERROR BACK TO USER
	PJRST	CPOPJ1##	;SKIP RETURN


;TABLE FOR CAL11. UUO IF THERE IS NO SERVICE ROUTINE
CAL11D:	XWD	400000,ECOD2##	;(0) DEPOSIT
	XWD	400000,ECOD2##	;(1) EXAMINE
	XWD	400000,ECOD2##	;(2) QUEUE A MESSAGE
	XWD	0,CAL11N	;(3) RETURN NAME
	XWD	0,CAL11S	;(4) UP/DOWN STATUS
	XWD	400000,ECOD2##	;(5) SEND
	XWD	400000,ECOD2##	;(6) RECEIVE
	XWD	0,CAL11T	;(7) TYPE
CAL11L==.-CAL11D		;LENGTH OF TABLE
; CROCK TO FUDGE UP A NEW FORMAT FUNCTION WORD FROM AN OLD STYLE WORD.
; THIS INSURES COMPATIBILITY WITH PRE-702 MONITORS.  EARLY 702 NONSENSE
; USING 400+DTE NUMBERS LOSE.  SO DO KMC/DUPS.  TO ALLOW CAL11. TO STILL
; WORK ON CPUS OTHER THAN CPU ZERO, WE'LL PICK UP THE JOB'S SET CPU COMMAND
; ARGUMENT AND SET THE CPU NUMBER TO THE FIRST CPU AVAILABLE.  NO CHECKING
; IS DONE AT THIS TIME TO MAKE SURE  THE SELECTED CPU HAS THE PORT WE'RE
; INTERESTED IN.  THAT'LL GET CAUGHT LATER.
C11OLD: HLRZ	T1,P1		;GET PORT NUMBER
	CAIGE	T1,10		;DL10 PORT?
	TDZA	T1,T1		;YES
	MOVEI	T1,.C11DT	;MUST BE A DTE
	TLZ	P1,777770	;KEEP ONLY THE PORT NUMBER
	DPB	T1,C11TYP	;SET THE TYPE CODE
	TLO	P1,(C1.1NF)	;SET NEW FORMAT

IFN FTMP,<
IFN M.CPU-1,<
	MOVE	T1,JBTSPS##(J)	;SEE IF THE USER
	TRC	T1,7777		; GAVE A SET CPU
	TRCE	T1,7777		;  COMMAND OR UUO
	SKIPA	T1,.CPCPN##	;RUN ON THIS CPU
	MOVEI	T1,0		;LOCK HIM ON CPU0
	DPB	T1,C11CPU	;STORE IT
> ;END IFN M.CPU-1
> ;END IFN FTMP

	POPJ	P,		;RETURN


; HERE TO DECODE THE TYPE, CPU, PORT NUMBER, AND FUNCTION CODE
; CALL:	MOVE	P1,FUNCTION WORD
;	PUSHJ	P,C11ARG
;
; ON RETURN, W=BASE TABLE ADDR, P1=WINDOW ADDR, T1=FUNCTION CODE
C11ARG:	LDB	T1,C11TYP	;GET THE TYPE CODE
	LDB	T2,C11CPU	;GET THE CPU NUMBER
	LDB	T3,C11POR	;GET THE PORT NUMBER
	HRRZ	T4,P1		;GET THE FUNCTION CODE
	CAILE	T2,M.CPU-1	;LEGAL CPU NUMBER?
	JRST	ECOD16##	;NO
	CAIN	T1,.C11DL	;DL10?
	JRST	C11DLX		;YES
	CAIN	T1,.C11DT	;DTE-20?
	JRST	C11DTX		;YES
	CAIN	T1,.C11KD	;KDP?
	JRST	C11KDX		;YES
	CAIN	T1,.C11DR	;DMR?
	JRST	C11DRX		;YES
	JRST	ECOD17##	;ILLEGAL TYPE CODE

C11DLX:
IFE DL10XI,<JRST ECOD21##>	;NO DL10 SUPPORT
IFN DL10XI,<
; REMOVE THE FOLLOWING INSTUCTION IF DL10S ARE MADE TO WORK ON CPU1
	MOVEI	T2,0		;GET THE CPU NUMBER
	CAIL	T3,10		;DL10 HAS PORTS 0-7
	JRST	ECOD20##	;ILLEGAL PORT NUMBER
	MOVE	T1,T2		;GET THE CPU NUMBER
	LSH	T1,3		;TIME THE NUMBER OF DL10 PORTS PER CPU (8)
	ADDI	T1,(T3)		;PLUS THE PORT NUMBER
	SKIPE	W,DLXBAT##(T1)	;GET THE BASE TABLE FOR THIS PORT
	SKIPN	P1,DLXWIN##(W)	;GET THE WINDOW ADDRESS
	JRST	ECOD3##		;THERE ISN'T ONE
	JRST	C11CPN		;GO PUT US ON THE RIGHT CPU
> ;END IFN DL10XI

C11DTX:
IFE FTKL10,<JRST ECOD22##>	;NO DTE SUPPORT
IFN FTKL10,<
	CAIL	T3,4		;DTE HAS PORTS 0-3
	JRST	ECOD20##	;ILLEGAL PORT NUMBER
	MOVE	T1,T2		;THE CPU NUMBER
	LSH	T1,2		;TIMES THE NUMBER OF DTES PER CPU (4)
	ADDI	T1,(T3)		;PLUS THE DTE NUMBER
	SKIPN	W,DTEBAS##(T1)	;HAVE ONE FOR THIS DTE?
	JRST	ECOD3##		;NO
	MOVE	P1,DLXWIN##(W)	;GET CPU#,,DTE#
	JRST	C11CPN		;GO PUT US ON THE RIGHT CPU
> ;END IFN FTKL10


C11KDX:
IFE FTKS10,<JRST ECOD23##>	;NO KDP SUPPORT
IFN FTKS10,<
	CAIL	T3,M.KDUP	;VALID LINE NUMBER
	JRST	ECOD3##		;NOPE
	MOVE	W,KDPBAS##(T3)	;GET BASE TABLE ADDRESS
	JRST	C11CPN
> ;END IFN FTKS10

C11DRX:
IFE FTKS10,<JRST ECOD24##>	;NO DMR SUPPORT
IFN FTKS10,<
	CAIL	T3,M.DMRN	;VALID LINE NUMBER
	JRST	ECOD3##		;NOPE
	MOVE	W,DMRBAS##(T3)	;GET BASE TABLE ADDRESS
> ;END IFN FTKS10

C11CPN:
IFE FTMP,<JUMPN T2,ECOD16##>	;WEED OUT JUNK CPU NUMBERS
IFN FTMP,<
IFN M.CPU-1,<
	MOVE	T1,T2		;GET THE CPU NUMBER
	PUSHJ	P,ONCPUS##	;SWITCH TO THAT CPU
	  JRST	ECOD16##	;CPU NOT RUNNING
> ;END IFN M.CPU-1
> ;END IFN FTMP

	HRRZ	T1,T4		;GET THE FUNCTION CODE
	JRST	CPOPJ1##	;AND RETURN


; BYTE POINTERS TO FIELDS IN THE FUNCTION WORD
C11TYP:	POINT	3,P1,11		;TYPE CODE
C11CPU:	POINT	3,P1,14		;CPU NUMBER
C11POR:	POINT	3,P1,17		;PORT NUMBER
CAL11N::MOVE	T1,DLXNMT##(W)	;GET NAME
	JRST	STOTC1##	;AND RETURN

CAL11T::SKIPE	T1,DLXFEK##(W)	;GET ADDRESS OF FEK
	HRLZ	T1,FEKNNM(T1)	;GET NODE NUMBER (IF ANY)
	HRR	T1,DLXTYP##(W)	;GET TYPE OF FRONT END
	JRST	STOTC1##	;RETURN

CAL11S::SKIPE	T1,DLXFEK##(W)	;GET ADDR OF FEK FOR THIS PORT
	SKIPL	T1,FEKBLK(T1)	;SKIP IF PORT UP
	TDZA	T1,T1		;DOWN
	MOVEI	T1,1		;UP
	JRST	STOTC1##	;SKIP RETURN
;COME HERE ONCE A SECOND.

IFN FTKS10*M.DN60,<
DLXSEC::PUSH	P,P1		;SAVE P1 FOR A BIT
IFN M.DN6K*M.KDUP,<		;IF ON A KS10 WITH IBM COMM
	MOVE	P1,[XWD -M.KDUP,KDPBAS] ;GET AN AOBJN POINTER TO THE BASE TABLE
DLXSE1:	MOVE	W,(P1)		;GET THE NEXT LINE
	PUSHJ	P,D6KSEC##	;SET DN60 TIME OUT THE CALL11 FUNCTIONS
	AOBJN	P1,DLXSE1	;LOOP OVER ALL LINES
>;M.DN6K
IFN M.DN6R*M.DMRN,<		;IF ON A KS10 WITH IBM COMM
	MOVE	P1,[XWD -M.DMRN,DMRBAS] ;GET AN AOBJN POINTER TO THE BASE TABLE
DLXSE2:	MOVE	W,(P1)		;GET THE NEXT LINE
	PUSHJ	P,D6KSEC##	;SET DN60 TIME OUT THE CALL11 FUNCTIONS
	AOBJN	P1,DLXSE2	;LOOP OVER ALL LINES
>;M.DN6R
	POP	P,P1		;RESTORE P1
	POPJ	P,		; AND RETURN
>; END IFN FTKS10
IFE FTKS10*M.DN60,<		;IF NOT ON A KS10 WITH IBM COMM
IFE DL10XI,<DLXSEC==:CPOPJ##>
IFN DL10XI,<
DLXSEC::
IFN M.CPU-1,<
	SKIPE	.CPCPN##	;DL10'S CAN ONLY BE ON CPU0
	POPJ	P,
>
	PUSHJ	P,SAVE3##	;SAVE P1-P3
	MOVSI	P1,-10		;AOBJN POINTER
D76SC1:	SKIPN	P2,DLXBAT##(P1)	;GET BASE ADDRESS OF THIS PDP11
	JRST	D76S1L		;NO.
	SKIPN	P3,DLXWIN##(P2)	;HAS IT A WINDOW?
	JRST	D76S1L		;NO WINDOW IS NO GOOD
	SKIPG	DLXDWN##(P3)	;IS THIS PDP11 UP?
	JRST	D76NTR		;NO.
	SKIPN	DLXHLT##(P3)	;YES, IS IT HALTED?
	JRST	D76S2L		;NO.
D76DWN:	SKIPG	DLXDWN##(P3)	;DO I THINK THE PDP11 IS UP?
	JRST	D76S1L		;NO.
	XCT	DLXCLR##(P2)	;YES, CLEAR ITS ENABLE.
	SETZM	DLXDWN##(P3)	;AND MARK IT DOWN.
	XCT	DLXPRG##(P2)	;DO ANY NECESSARY CLEAN UPS
	MOVE	T1,P1		;GET PORT #
	PUSHJ	P,DL10EL	;LOG ERROR

	MOVSI	T1,(JFCL)	;DISABLE ITS SERVICE ROUTINE
	MOVEM	T1,DLXINI##(P2)
	SETZM	DLXCAL##(P2)
	MOVEM	T1,DLXPRG##(P2)
D76S1L:	AOBJN	P1,D76SC1	;TRY NEXT PDP11.
	POPJ	P,		;NO MORE, ALL DONE.

D76S2L:	AOS	T1,DLXOK##(P3)	;COUNT THE "OK" COUNTER
	CAIL	T1,^D10		;IS THE PDP11 STILL OK?
	JRST	D76DWN		;NO, IT HAS GONE DOWN.
	JRST	D76S1L		;YES, GO ON TO NEXT PDP11.

;COME HERE IF A PDP11 IS NOT RUNNING.

D76NTR:	XCT	DLXCNI##(P2)	;CONI DLC,T1
	MOVEI	T2,22220	;PORT ENABLE BITS
	ANDCM	T2,T1		;T2 GETS A 1 FOR EACH PDP11
				;  NOT ENABLED
	LSH	T2,-1		;MOVE TO INTERRUPT BIT
	AND	T2,T1		;1 FOR EACH PDP11 LOADED BUT NOT
				;  YET STARTED.
	AND	T2,DLXMSK##(P2)	;MASK OFF BITS FOR OTHER PDP11S
	JUMPE	T2,D76S1L	;JUMP IF NOT OUR PDP11
	SETZM	DLXOK##(P3)	;NOT CRASHED YET
	SETZM	DLXHLT##(P3)	;NOR HALTED
	SETZM	TTP(P3)		;CLEAR THE Q'S
	SETZM	TTG(P3)		;CLEAR THE Q'S
	SETZM	TEP(P3)		;CLEAR THE Q'S
	SETZM	TEG(P3)		;CLEAR THE Q'S
	SETZM	DLXCEU##(P2)	;NO CAL11. USER
	MOVSI	T1,767760	;BUILD SIX BIT DL10 BYTE POINTER
	HRRI	T1,DLXNMT##(P2)	;INTO DL10 BASE TABLE
	SETZM	(T1)		;ZAP OLD NAME
	MOVEM	T1,DLXNAM##(P3)	;STORE POINTER TO NAME
	MOVEI	T1,2		;KILL IF NO RESPONSE IN 2 SEC
	MOVEM	T1,DLXDWN##(P3)	; BY MARKING PDP11 AS UP
	MOVE	T1,[PUSHJ P,D76CKN]	;CHECK NAME ON INTERRUPT
	MOVEM	T1,DLXINI##(P2)
	XCT	DLXKAX##(P2)	;SPECIFY KA10 INTERRUPTS (IN CASE NOT DONE ALREADY)
	XCT	DLXSWA##(P2)	;SET WINDOW ADDRESS
	XCT	DLXENB##(P2)	;ENABLE PORT
	JRST	D76S1L		;WAIT FOR INTERRUPT
>; END IFN DL10XI CONDITIONAL
>; END IFE FTKS10*M.DN60
>; END IFN <PDP11N!M.KL10!M.DN60!M.KDUP!M.DMRN>

IFN PDP11N,<
;COME HERE ON NEXT DL10 INTERRUPT FOR THIS PDP11.

D76CKN:	SKIPN	T1,DLXNMT##(W)	;NAME SPECIFIED YET?
	POPJ	P,		;NO.
IFN M.DC75,<
	CAMN	T1,[SIXBIT /DC75/]	;YES, DC75?
	JRST	D75III##	;YES, START UP DC75.
>
IFN M.DC76,<
	CAMN	T1,[SIXBIT /DC76/]	;NO, DC76?
	JRST	D76III##	;YES, START UP DC76.
>
IFN DLX.60,<IFN M.DN6D,<
	CAMN	T1,[SIXBIT /DN60/] ;NO, DN60?
	JRST	D60III##	;YES, START UP DN60
>>
	POPJ	P,		;NO, IGNORE IT.

;COME HERE ONCE A MINUTE.

IFE DL10XI,<D76MIN==:CPOPJ##>
IFN DL10XI,<
D76MIN::SKIPGE	DEBUGF##	;DEBUGGING
	POPJ	P,		;YES, NO MESSAGE
	PUSHJ	P,SAVE3##	;SAVE P1-P3
	MOVE	P1,UPTIME##	;GET UPTIME
	CAMGE	P1,TICMIN##	;MORE THAN 1 MINUTE
	POPJ	P,		;NO--TOO EARLY
	MOVSI	P1,-10		;MAXIMUM NUMBER OF PORTS
D76MLP:	SKIPE	P2,DLXBAT##(P1)	;IS THIS PDP11 DEFINED?
	SKIPN	P3,DLXWIN##(P2)	;YES, HAS IT A WINDOW?
	JRST	D76MNX		;NO, LOOK AT NEXT PDP11
	SKIPE	DLXDWN##(P3)	;IS IT UP OR SILENCED?
	JRST	D76MNX		;YES.
	MOVE	T1,STATES##	;SCHED SETTINGS
	TRNE	T1,ST.NOP	;IS THERE AN OPR IN ATTENDANCE?
	SETOM	DLXDWN##(P3)	;NO, ONLY REPORT THE ERROR ONCE
	MOVE	U,OPRLDB##	;NO, PRINT MESSAGE ON OPR'S TTY
	PUSHJ	P,INLMES##
	ASCIZ	/
%%PDP-11 number /
	MOVE	T1,DLXEPN##(P3)	;ELEVEN PORT NUMBER
	PUSHJ	P,RADX10##	;PRINT THAT OUT
	SKIPE	DLXHLT##(P3)	;HALTED?
	JRST	D76HLT		;YES.
	PUSHJ	P,INLMES##	;NO, JUST SAY NOT UP.
	ASCIZ	/ is not running.
/
	JRST	D76MNX		;CHECK NEXT PDP11

;STILL IN IFN DL10XI AND IFN PDP11N CONDITIONALS
;COME HERE IF THE PDP11 IS ACTUALLY HALTED.

D76HLT:	PUSHJ	P,INLMES##
	ASCIZ	/ halted at /
	MOVE	T1,DLXHLT##(P3)	;GET HALT PC (OR STOP CODE)
	PUSHJ	P,OCTPNT##	;TYPE IT OUT
	PUSHJ	P,INLMES##	;END WITH A DOT
	ASCIZ	/.
/
D76MNX:	AOBJN	P1,D76MLP	;CHECK THE REST OF THE PDP11S
	POPJ	P,		;DONE THEM ALL--RETURN.

	$LOW
>	;END OF IFN DL10XI CONDITIONAL
>	;END OF IFN PDP11N

SUBTTL	LOCATE & WHERE COMMAND/UUOS

IFE M.NET,<
	$HIGH
NODE.C::
HOST.C::
NETASG==:CPOPJ1##
IFE <M.DAS78!M.DN60>,<
CLOCAT::
CWHERE::
>	;END IFE M.DN60
	MOVSI	T1,JLOG		;IF NOT
	TDNN	T1,JBTSTS##(J)	;LOGGED IN
	DPB	T1,PJOBN##	;DON'T LEAVE GHOST JOB
	JSP	T1,ERRMES##	;CAN'T DO THESE IF NO NETWORK
	ASCIZ	/No network, DAS78, or DN60 software
/
	$LOW
>	;END IFE M.NET .IF M.NET=0 & M.DAS78!M.DN60, ONLY 1 LABEL, NETASG
	; IF BOTH=0,3LABELS

IFN	<M.NET!M.DAS78!M.DN60>,<
	$HIGH

;LOCATE COMMAND TO PLACE A JOB AT A REMOTE STATION SITE

CLOCAT::
	JSP	T2,SAVCTX##	;MUST SCHEDULE THIS COMMAND
	NETDBJ			;INTERLOCK THIS CODE WITH NETSER
	PUSHJ	P,CTEXT1##	;GET THE ARGUMENT IN SIXBIT
	SKIPN	T1,T2		;COPY TO T1
	JRST	LOCTHS		;NO ARGUMENT
	PUSHJ	P,CVTOCT##	;TRY TO CONVERT TO OCTAL
	  MOVE	T1,T2		;CAN'T-GET THE NAME BACK
LOCLC1:
IFN	M.NET,<
	PUSH	P,T1		;SAVE THE ARG
	PUSHJ	P,SRCNDB##	;SEARCH FOR THE NODE BLOCK
>;END IFN M.NET
	  JRST	LOCNOT		;DOES NOT EXIST
IFN	M.NET,<
	HLRZ	T1,NDBNNM##(W)	;YES, GET THE NODE NUMBER
	CAILE	T1,77		;KEEP IT REASONABLE
	JRST	LOCBIG		; FOR BATCH
	HRRZM	T1,JBTLOC##(J)	;LOCATE HIM WHERE HE WANTS
	POP	P,(P)		;RESTORE THE STACK
	PUSHJ	P,TYPNDB##	;TYPE THE NODE NAME
	JSP	T1,CONMES##	;EXIT TO COMDEV
	ASCIZ	/ Located
/
>;END IFN M.NET

LOCTHS:	PUSHJ	P,FNDSTA##	;GET STA NUMBER OF CONTROL TTY
	JRST	LOCLC1		;AND GO LOCATE HIM

LOCNOT:
IFN	M.NET,<
	POP	P,T1		;RESTORE THE ARG
>;END IFN M.NET
	CAIG	T1,77		;IS IT A NUMBER
IFN	M.NET,<
	JUMPG	T1,LOCNO1	;YES, WILL ALLOW THE LOCATE TO HAPPEN
	HRRZ	T1,NRTUNN##	;NO, UNDEFINE NETWORK NODE
>;END IFN M.NET
IFE	M.NET,<
	JUMPGE	T1,LOCNO1	;YES, WILL ALLOW THE LOCATE TO HAPPEN
	HRRZI	T1,[ASCIZ \Invalid station address\] ;NO.
>;END IFE M.NET
	PJRST	ERRMES##	;TYPE IT

LOCNO1:	HRRZM	T1,JBTLOC##(J)	;STORE THE LOCATION
	PUSHJ	P,INLMES##	;TYPE A MESSAGE
IFN M.NET,<
	ASCIZ	/%Node (/
>
IFE M.NET,<
	ASCIZ	/Station /
>
	HRRZ	T1,JBTLOC##(J)	;GET THE NUMBER
	PUSHJ	P,PRTDI8##	;PRINT THE NUMBER
	PUSHJ	P,INLMES##	;AND A COMMENT
IFN	M.NET,<
	ASCIZ	/) Located but off-line
/
>;END IFN M.NET
IFE	M.NET,<
	ASCIZ	/ Located
/
>;END IFE M.NET
	POPJ	P,		;RETURN
IFN M.NET,<
LOCBIG:	POP	P,T1		;RESTORE THE ARG
	MOVEI	T1,[ASCIZ/Station number out of range/] ;LOAD ERROR
	PJRST	ERRMES##	;TYPE IT AND RETURN
>;END IFN M.NET
;WHERE COMMAND - SIMILAR TO WHERE UUO
;THE LOCATION OF A DEVICE IS TYPED ON THE USER'S TTY

CWHERE::JSP	T2,SAVCTX##	;SAVE THE CONTEXT OF THE JOB
IFN FTMP,<PUSHJ	P,ONCPU0##>	;TEMPORARY AVOID COMCON RACE
	NETDBJ			;INTERLOCK THIS WITH NETSER
	PUSHJ	P,CTEXT1##	;GET FIRST ARG = SIXBIT DEV NAME
IFN M.NET,<
	PUSHJ	P,NETASG##	;SEE IF IT'S OF THE FORM "NODE_DEV"
				; AND IF IT IS, CHANGE IT TO "GGGNNU"
	POPJ	P,		;HERE IF ERROR IN NAME. (MSG ALREADY PRINTED)
>;END IFN M.NET
	PUSH	P,T2		;SAVE 6 BIT
	PUSHJ	P,FNDSTA##	;GET OUR STATION
	POP	P,T2		;GET 6 BIT NAME
	MOVE	T1,T2		;INTO T1
	PUSH	P,U		;SAVE U
	PUSHJ	P,DVCNSG##	;SEARCH FOR PHYSICAL DEV NAME
	JRST	NOTDV1##	;PRINT "NO SUCH DEVICE"
	PUSHJ	P,FNDDEV	;FIND LOCATION
IFN M.NET,<MOVE	U,(P)>		;RETRIEVE U (MAYBE LDB)
	LDB	T2,[POINT 6,DEVTYP(F),9] ;GET TYPE OF DEVICE
IFN M.NET,<
IFN M.DAS78,<
	CAIN	T2,.TYD78/.TYEST ;IS IT A DAS78?
	JRST	WCMD78		;YES
> ;END IFN M.DAS78
	CAIE	T2,.TYTTY/.TYEST;IS IT A TTY?
	JRST	CWHANF		;NO, JUST REGULAR DEVICE
	MOVE	U,DDBLDB(F)	;GET TARGET TTY'S LDB
	SE1XCT	<MOVE T4,LDBTTW##(U)>  ;GET THE TTY USE FLAGS
	TLNN	T4,LTLUSE##	;IS TTY IN USE?
	JRST	CWHNCN		;NO, JUST SAY "NOT CONNECTED"
IFN M.DECN,<			;IF DECNET,
	TLNE	T4,LTLNRT##	;IF NRT/CTERM
	JRST	CWHNRT##	;LET NRTSER TYPE IT OUT
> ;END IFN M.DECN
IFN M.LATN,<			;IF ETHERNET/LAT
	TLNE	T4,LTLLAT##	;IF LAT TERMINAL
	PJRST	CWHLAT##	;LET LATSER TYPE IT OUT
> ;END IFN M.LATN
				;FALL INTO ANF/LOCAL TTY TYPEOUT
;STILL IFN M.NET

CWHANF::MOVE	U,0(P)		;COMMAND TTY LDB
	PUSHJ	P,SRCNDB##	;SEARCH FOR THE NDB
	  MOVEI	W,NETNDB##	;USE THE LOCAL MODE
	PUSHJ	P,TYPNDB##	;TYPE THE NODE INFO
	PUSHJ	P,PRSPC##
	MOVE	T2,DEVNAM(F)
	PUSHJ	P,PRNAME##
	MOVSI	T1,DVTTY	;CHECK FOR A TTY
	TDNN	T1,DEVMOD(F)	;IS DEVICE A TTY?
	JRST	[PUSHJ	P,ZAPNET##	;NO, FREE DDB IF APPROPRIATE
		POP	P,U		;AND EXIT
		PJRST	CRLF##]
	MOVE	U,DDBLDB##(F)	;YES, GET THE LDB
	SE1XCT	<LDB T1,LDPLNO##> ;GET THE LOCAL LINE NUMBER
	MOVSI	T2,LTLANF##	;ANF NETWORK VIRTUAL TERMINAL FLAG
	SE1XCT	<TDNE T2,LDBTTW##(U)> ;CHECK A BIT
	SE1XCT	<LDB T1,LDPRLN##> ;GET REMOTE LINE NUMBER
	POP	P,U		;RESTORE THE LDB
	PUSH	P,T1		;SAVE LINE NUMBER
	PUSHJ	P,INLMES##	;TYPE OUT
	ASCIZ	/ line # /
	POP	P,T1		;RESTORE LINE NUMBER
	PUSHJ	P,PRTDI8##	;TYPE IT
	PJRST	PCRLF##		;AND CRLF

CWHNCN::MOVE	U,0(P)		;RETRIEVE COMMAND TERMINAL LDB FOR TYPEOUT
	PUSHJ	P,INLMES##	;DEVICE IS NOT CONNECTED . . .
	ASCIZ	\Device	\
	MOVE	T2,DEVNAM(F)	;GRAB THE DEVICE NAME
	PUSHJ	P,PRNAME##	;AND TYPE IT OUT
	PUSHJ	P,INLMES##	;NOT CONNECTED
	ASCIZ	/ not connected
/
	PUSHJ	P,TTYKLQ##	;ZAP THE USELESS DDB
        POP	P,U
	POPJ	P,		;RETURN
>;END IFN M.NET
IFN M.DAS78,<
WCMD78:	POP	P,U		;RESTORE LDB
	PUSHJ	P,INLMES##	;PRINT THE MESSAGE
	ASCIZ	\NODE	\
IFN	M.NET,<
	MOVE	T2,STANAM##	;CENTRAL STATION NAME
	PUSHJ	P,PRNAME##	;PRINT CENTRAL NAME
>;END IFN M.NET
	MOVEI	T3,"("		;LEFT PAREN
	PUSHJ	P,COMTYO##	;TYPE IT
	LDB	T1,PDVSTA##	;GET STATION #
	PUSHJ	P,PRTDI8##	;PRINT IT
	PUSHJ	P,INLMES##	;
	ASCIZ	\) \		;
	MOVEI	T1,CONFIG##	;SYSTEM NAME
	PUSHJ	P,CONMES##	;PRINT IT
	PUSHJ	P,PRSPC##	;SPACE
	MOVEI	T1,SYSDAT##	;DATE
	PJRST	CONMES##	;
>;END IFN M.DAS78


;ROUTINE TO FIND LOCATION OF A DEVICE
;RETURN WITH T1=LOCATION
FNDDEV::LDB	T1,PDVSTA##	;GET DDB LOCATION
	MOVSI	T2,DVTTY	;SEE IF
	TDNN	T2,DEVMOD(F)	; TTY
	POPJ	P,		;NO.
	MOVE	U,DDBLDB##(F)	;YES, SET UP U
	PJRST	FNDSTA##	;AND COMPUTE FROM LDB

;WHERE UUO
;IF AC CONTAINS 0 TO 17 THE CALLER WANTS THE LOCATION OF THE DEVICE
;INITED ON THE CHANNEL NUMBER SPECIFIED IN AC. LH(AC) = STA STATUS BITS
;IF AC IS GREATER THAN 17 IT IS ASSUMED TO BE A SIXBIT DEVICE NAME
;THAT THE CALLER WISHES TO KNOW THE STATION OF. LH(AC) = STA STATUS BITS

WHERE::
IFN FTMP,<			;TEMPORARY
	PUSHJ	P,ONCPU0##	;AVOID COMCON RACE
>
	NETDBJ			;INTERLOCK THIS WITH NETSER
	CAMN	T1,[SIXBIT/OPR/]	;IS IT AN OPR
	JRST	[HRRZ	T1,JBTLOC##(J)	;YES, GET THE JOB LOCATION
		PJRST	STOTC1##]	;RETURN LOCATION OF THE JOB
	PUSHJ	P,DVCNSG##	;SEARCH FOR DEVICE OR CHANNEL
	  JRST RTZER##		;NONE--RETURN ERROR AS 0.
	PUSHJ	P,FNDDEV	;GET STATION NUMBER
	JUMPN	T1,WHER1	;USE IT IF NON ZERO
IFN M.DAS78,<
	LDB	T2,[POINT 6,DEVSTA(F),9] ;GET TYPE OF DEVICE
	CAIE	T2,.TYD78/.TYEST ;IF DAS78 DEV LEAVE IT 0
> ;END IFN M.DAS78
	MOVE	T1,JBTLOC##	; OTHERWISE USE CENTRAL SITE NUMBER
WHER1:
IFN FTSPL,<
	SKIPN	DEVCHR(F)	;IF A "FAKE" DDB,
	HRRZ	T1,JBTLOC##(J)	;TELL WHERE JOB IS
>
IFN M.DAS78,<
IFN M.NET,<
	LDB	T2,[POINT 6,DEVSTA(F),9] ;GET DEVICE TYPE
	CAIE	T2,.TYD78/.TYEST ;SKIP IF A DAS78 DEVICE
> ;END IFN M.NET
IFE M.NET,<
	JRST	STOTC1##	;STATUS BITS TO 0 AND RETURN
> ;END IFE M.NET
> ;END IFN M.DAS78
IFN	M.NET,<
	CAMN	T1,JBTLOC##	;CENTRAL SITE?
	JRST	STOTC1##	;YES, STATUS BITS ALL ZERO.
	PUSHJ	P,SRCNDB##	;FIND THE NODE BLOCK
	  JRST	RTZER##		;DOES NO EXIST
	HLRZ	T1,NDBNNM##(W)	;GET THE NODE NUMBER
;	HLL	T1,SCBSTS##(W)	;GET THE STATUS BITS
>;END IFN M.NET
	JRST	STOTC1##	;STORE T1 IN USER'S AC

;LOCATE UUO (CALLI 62)
;PLACES THE CALLER AT THE DESIRED STATION SITE
;CALL: AC HAS STATION NAME OR NUMBER TO LOCATE AT

LOCATE::
	NETDBJ			;INTERLOCK THIS WITH NETSER
	SKIPN	F,TTYTAB##(J)	;POINT TO JOB'S TTY
	JRST	LOCAT3		;NONE.
	CAME	T1,[EXP -1]	;IF ARG IS -1...
	JRST	LOCAT3		;NO
	PUSHJ	P,FNDDEV	;PUT JOB WHERE TTY IS
	JRST	LOCAT4		;LOCATE THE JOB
LOCAT3:	MOVE	T2,T1		;COPY ARGUMENT
	PUSHJ	P,CVTOCT##	;CONVERT TO OCTAL
	  MOVE	T1,T2		;CAN'T, RESTORE
	JUMPE	T1,LOCAT1	;0 IMPLIES LOCAL NODE
IFN M.NET,<
	TLNN	T1,-1		;LOOK LIKE A NODE NAME?
	JRST	LOCAT4		;NO, MUST BE NODE NUMBER
	PUSHJ	P,SRCNDB##	;DO WE KNOW ABOUT IT?
	  POPJ	P,		;NO, CAN'T LOCATE
	HLRZ	T1,NDBNNM##(W)	;GET NODE NUMBER
>
LOCAT4:	CAILE	T1,77		;IS THE STATION IN RANGE
	POPJ	P,		;NO, ERROR RETURN
LOCAT2:	HRRZM	T1,JBTLOC##(J)	;LOCATE JOB
	JRST	CPOPJ1##	;GIVE GOOD RETURN

LOCAT1:	MOVE	T1,JBTLOC##	;CENTRAL LOCATION
	JRST	LOCAT2		;PUT HIM THERE.

	$LOW

>;END IFN <M.NET!M.DAS78!M.DN60>

	$LIT

IFNDEF FTCMBTH,<COMEND:	END>
  d, /