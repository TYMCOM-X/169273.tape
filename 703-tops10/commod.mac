TITLE	COMMOD - COMMON DATA LOCATIONS USED BY LEVEL D DISK SERVICE(FILSER) - V657
SUBTTL T. HASTINGS/TW/CMF/DAL/JBS/EVS/TW  12 NOV 85
	SEARCH	F,S

IFN FTKL10,<
	SEARCH	ICHPRM
>;FTKL10

	$RELOC

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<1973,1986>
;COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986
;BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;ALL RIGHTS RESERVED.


XP VCOMMD,657

	ENTRY	COMMOD

COMMOD:			;CAUSE COMMOD TO LOAD IF IN LIBRARY FILE

;ALL DATA LOCATIONS USED BY FILSER ARE HERE INSTEAD OF COMMON IN ANTICIPATION
; OF MULTI PROCESSING SYSTEMS WHICH SHARE DISKS AND ONE MEMORY BANK(DISK BUFFERS+DATA)
; NO DATA LOCATIONS SHOULD BE PUT INTO COMMON FOR LEVEL D


REPEAT 0,<
ASSEMBLY INSTRUCTIONS:

.R MACRO
*COMMOD,COMMOD/C=HDWCNF,COMMOD
>
SUBTTL	TABLE OF CONTENTS

;               TABLE OF CONTENTS FOR COMMOD
;
;
;                        SECTION                                   PAGE
;    1. TABLE OF CONTENTS.........................................   3
;    2. CONVERT MONGEN SYMBOLS....................................   3
;    3. DEFAULT SYMBOLS...........................................   6
;    4. GENERAL COMMENTS..........................................   9
;    5. LIMITS OF VARIOUS FIELD WIDTHS IN FILE STRUCTURES.........  16
;    6. DATA STRUCTURE DESCRIPTION................................  17
;    7. BLK - PARAMETERS WHICH APPEAR IN MORE THAN ONE DISK BLOCK.  19
;    8. COR - PARAMETERS WHICH APPEAR IN MORE THAN ONE CORE BLOCK.  20
;    9. ACC:    ACCESS DATA BLOCKS ENTRY..........................  22
;   10. BAF:            BAD ALLOCATION FILE.......................  28
;   11. CHN:    CHANNEL DATA BLOCK................................  31
;   12. DEV:    DEVICE DATA BLOCK (ONE FOR EACH ACTIVE SOFTWARE USER CHANNEL)  36
;   13. HOM:    WORD POSITIONS IN HOME FILE DATA BLOCK............  45
;   14. MONITOR JOB TABLES - ONE ENTRY PER JOB....................  50
;   15. KONTROLLER DATA BLOCKS....................................  53
;   16. LBN - LOGICAL DISK BLOCK NUMBERS WITHIN UNIT(NOT STR) ASSIGNED AS ASSEMBLY TIME  63
;   17. "MBF" - MONITOR BUFFER....................................  64
;   18. MFD     WORD POSITIONS IN MASTER FILE DIRECTORY...........  65
;   19. NMB FILE NAME DATA BLOCK..................................  66
;   20. ONCE ONLY DESTROY OPTION DATA BASE........................  68
;   21. PPB - PROJECT PROGRAMMER NUMBER DATA BLOCK................  76
;   22. RIB     WORD POSITIONS FOR RETRIEVAL INFORMATION BLOCK....  78
;   23. SAT BLOCKS................................................  84
;   24. STR:    FILE STRUCTURE DATA BLOCK.........................  89
;   25. "SYS" - SYSTEM WIDE QUANTITIES............................  92
;   26. UFB:    USER FILE DIRECTORY BLOCK......................... 100
;   27. UNI:    UNIT DATA BLOCK................................... 103
SUBTTL	CONVERT MONGEN SYMBOLS
REPEAT 0,<

;THIS SECTION CONVERTS NEW MONGEN SYMBOLS TO OLD MONGEN SYMBOLS
;SO THAT THE REST OF COMMON AND MONITOR CAN STILL USE THE OLD
;SYMBOLS.  THIS WAS DONE RATHER THAN CONVERTING ALL OF THE
;MONITOR TO NEW SYMBOLS FOR TWO REASONS:
; 1.  IT IS EASIER AND FASTER AND LESS LIKELY TO INTRODUCE BUGS, AND
; 2.  IT ALLOWS CUSTOMERS TO USE OLD MONGEN WITH A MINIMUM
;OF TROUBLE: ONLY A FEW EXTRA SYMBOLS MUST BE DEFINED.
;THE MONITOR WILL PROBABLY BE CONVERTED TO THE NEW MONGEN SYMBOLS
;AFTER THE 5.04 RELEASE.  THE ORDER HERE PARALLELS THE OLD
;MONGEN ORDER.

>
IFDEF M.C0SN,<
XP SYS40N,0		;NEW MONGEN MAKES SWAPPING SYSTEMS ONLY
XP SYS50N,1
XP DSKN,1
XP LOGINN,1

XP APRSN,M.C0SN		;APR SERIAL NUMBER (REALLY PROCESSOR 0)
XP APR0SN,M.C0SN	;PROCESSOR 0 SERIAL NUMBER
XP APR1SN,M.C1SN	;PROCESSOR 1 SERIAL NUMBER
XP CPUN,M.CPU		;NUMBER OF PROCESSORS

XP LEVDN,1		;NEW MONGEN MAKES ONLY LEVEL D DIAL SERVICE
XP LEVCN,0
XP CHNN,M.CHN		;NUMBER OF DATA CHANNELS FOR DISKS

;THE FOLLOWING CODE IS HERE ONLY SO THAT ALL MODULES AGREE ON THE VALUE OF
; M.TLTL

IFNDEF M.TTDN,<M.TTDN==:0>
IFNDEF M.XTL,<M.XTL==:0>
XP M.TLTL,M.TLTL+M.TTDN		;REDEFINE FOR RSX-20F LINES
XP M.TLTL,M.TLTL+M.XTL		;REDEFINE FOR XTC LINES
IFN M.KS10,<
XP	M.TLTL,M.TLTL+1		;ADD ONE FOR KLINIK LINE
>
IFE FTAUTC,<
	DEFINE	CALLH(CHN),<
XP	C'CHN'RHN,M.'CHN'RH
>
	DEFINE CHMRH(CHN),<
	CALLH	(\CHN)
>	;END MACRO DEFINITION

	DEFINE	CALLF(CHN),<
XP	C'CHN'FHN,M.'CHN'FH
>
	DEFINE CHMFH(CHN),<
	CALLF	(\CHN)
>	;END MACRO DEFINITION

	DEFINE	CALLS(CHN),<
XP	C'CHN'FSN,M.'CHN'FS
>
	DEFINE	CHMFS(CHN),<
	CALLS	(\CHN)
>	;END MACRO DEFINITION

	DEFINE	CALLR(CHN),<
XP	C'CHN'RPN,M.'CHN'RP
>
	DEFINE	CHMRP(CHN),<
	CALLR(\CHN)
>

	DEFINE	CALLN(CHN),<
XP	C'CHN'RNN,M.'CHN'RN
>
	DEFINE	CHMRN(CHN),<
	CALLN	(\CHN)
>

	DEFINE	CALLD(CHN),<
XP	C'CHN'DPN,M.'CHN'DP
>
	DEFINE CHMDP(CHN),<
	CALLD	(\CHN)
>	;END MACRO DEFINITION

	DEFINE	CALLM(CHN),<
XP	C'CHN'MDN,0
>
	DEFINE	CHMMF(CHN),<
	CALLM	(\CHN)
>
	DEFINE	CALLA(CHN),<
XP	C'CHN'RAN,M.'CHN'RA
>
	DEFINE	CHMRA(CHN),<
	CALLA	(\CHN)
>	;END MACRO DEFINITION
ZZ==0
ZZF==0
ZZS==0
ZZD==0
ZZR==0
ZZH==0
ZZN==0

REPEAT CHNN,<
	CHMFH	(ZZ)
	CHMFS	(ZZ)
	CHMRP	(ZZ)
	CHMDP	(ZZ)
	CHMMF	(ZZ)
	CHMRH	(ZZ)
	CHMRN	(ZZ)
	CHMRA	(ZZ)
ZZ==ZZ+1
>
>	;END IFE FTAUTC
IFE FTAUTC,<
DEFINE UNRH(KON,LIST),<
ZZCNT==0
IRP LIST,<
	IFE ZZCNT-KON,<
	XP RH'LIST'UN,M.RH'LIST
	>;END IFE
ZZCNT==ZZCNT+1
>	;END IRP
>	;END MACRO DEFINITION

REPEAT M.R11D,<
	UNRH	(ZZH,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>)
ZZH==ZZH+1
>

	DEFINE	UNFH(KON,LIST),<
ZZCNT==0
IRP LIST,<
	IFE ZZCNT-KON,<
	XP FH'LIST'UN,M.FH'LIST
	>	;END IFE
ZZCNT==ZZCNT+1
>	;END IRP
>	;END MACRO DEFINITION

REPEAT M.RC10,<
	UNFH	(ZZF,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>)
ZZF==ZZF+1
>

DEFINE UNFS(KON,LIST),<
ZZCNT==0
IRP LIST,<
	IFE ZZCNT-KON,<
	XP FS'LIST'UN,M.FS'LIST
	>;END IFE
ZZCNT==ZZCNT+1
>	;END IRP
>	;END MACRO DEFINITION

REPEAT M.RH1S,<
	UNFS	(ZZS,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>)
ZZS==ZZS+1
>
	DEFINE	UNRP(KON,LIST),<
ZZCNT==0
IRP	LIST,<
	IFE	ZZCNT-KON,<
	XP	RP'LIST'UN,M.RP'LIST
	>	;END IFE
ZZCNT==ZZCNT+1
>	;END IRP
>	;END MACRO DEFINITION

REPEAT	M.RHP4,<
	UNRP	(ZZR,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>)
ZZR==ZZR+1
>

	DEFINE	UNRN(KON,LIST),<
ZZCNT==0
IRP	LIST,<
	IFE	ZZCNT-KON,<
	XP	RN'LIST'UN,M.RN'LIST
	>	;END IFE
ZZCNT==ZZCNT+1
>	;END IRP
>	;END MACRO DEFINITION

REPEAT	M.RP20,<
	UNRN	(ZZN,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>)
ZZN==ZZN+1
>

	DEFINE	UNDP(KON,LIST),<
ZZCNT==0
IRP LIST,<
	IFE ZZCNT-KON,<
	XP DP'LIST'UN,M.DP'LIST
	>	;END IFE
ZZCNT==ZZCNT+1
>	;END IRP
>	;END MACRO DEFINITION

REPEAT M.RP10,<
	UNDP	(ZZD,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>)
ZZD==ZZD+1
>
>	;END IFE FTAUTC
XP RD10N,M.RC10
XP RP10N,M.RP10
XP RA10N,0		;NO MOF

XP JOBN,M.JOB+1
XP PDP10N,1
XP KT10AN,MD.2RR
XP SEGN,MD.SEG
XP DDTN,MD.DDT

XP EDITN,0

XP PTRN,M.PTR
XP PTPN,M.PTP
XP PLTN,M.PLT
XP LPTN,M.LPT
XP MOVIEN,MD.MOV
XP CDRN,M.CDR
XP CR10N,MD.C10
XP CDPN,M.CDP

XP DISN,M.DIS
XP PENN,M.DIS
XP T340N,M.340
XP TVP10N,M.VP10
XP T30N,0		;NO TYPE 30
DEFINE TDMAC(X),<
	XP	DT'X'N,M.DT'X
>
ZZ=="A"
REPEAT M.TD10,<
	TDMAC(\"ZZ)
ZZ==ZZ+1
>

XP PTYN,M.PTY


XP LOKN,M.LOK
XP CMNN,M.MGC
XP RTTRPN,M.RTD
XP HPQN,M.HPQ
>	;END IFDEF
SUBTTL	DEFAULT SYMBOLS
;SYMBOLS WHICH MAY BE CHANGED AT MONGEN TIME IF A USER DOES NOT LIKE STANDARD
; DEFINITIONS. HOWEVER MOST CUSTOMERS WILL BE HAPPY WITH THE STANDARD VALUES
; SO DO NOT BOTHER TO ASK HIM EXPLICIT MONGEN QUESTION.

	INTERN	STRMAX,CCWMAX,SWPMAX,DSKTRY,PRVFIL,PRVUFD,CHVIFP,CHVIFT,PTRLEN
	INTERN	UNVRSF,FIL4WD,INDPPN,LBFSIZ,LNMMXL,LNMMAX

IFNDEF STRMAX,<XP STRMAX,^D14>	;MAX NO, OF FILE STRUCTURES ON SYSTEM AT ONE TIME
			; CANNOT EXCEED 14(DEC) - ALLOW USER TO SPECIFY LESS TO
			; SAVE ONE WORD IN STRTAB TABLE FOR EACH STR.
IFNDEF CCWMAX,<XP CCWMAX,1>	;MAX. NO OF DATA CHANNEL COMMAND WORDS.
IFNDEF SWPMAX,<XP SWPMAX,^D8>	;MAX. NO OF UNITS FOR SWAPPING. - ALLOW CUSTOMER TO
			; MAKE BIGGER OR SMALLER.
IFNDEF SWCLSN,<XP SWCLSN,^D7>	;HIGHEST CLASS # FOR SWAPPING
IFG SWCLSN-^D7,<XP SWCLSN,^D7>	;DONT ALLOW USER TO SPECIFY GREATER THAN 7
IFNDEF DSKTRY,<XP DSKTRY,^D10>	;NO. OF ERROR TRYS ON DISK DATA ERRORS
			; FOR ALL FILE STRUCTURES BEFORE RECALIBRATING
IFNDEF SERTRY,<XP SERTRY,^D3>	;NO. OF TIMES TO TRY ON SEARCH ERRORS
			; BEFORE RECALIBRATING
IFNDEF RCLTRY,<XP RCLTRY,^D10>	;NO. OF TIMES TO TRY 'DSKTRY' DATA ERRORS
			; OR 'SERTRY' S ERRORS
			; WITH RECALIBRATING IN BETWEEN.
			; I.E. NO. OF RECALIBRATIONS+1.
			; TOTAL NO. TIMES = RCLTRY*DSKTRY.

IFNDEF PRVFIL,<PRVFIL==057>	;STANDARD FILE PRIVILEGE
				;OWNER=EVERYTHING,PROJ=READ,REST=NO ACCESS
IFNDEF PRVUFD,<PRVUFD==775>	;STANDARD UFD PRIVILEGE
				;OWNER=ALL,PROJ=ALL,REST=READ+LOOKUPS
IFNDEF CHVIFP,<CHVIFP==^D10>	;STANDARD INITIAL FAIRNESS COUNT FOR POSITIONING
				; CUSTOMER CAN ALSO CHANGE DEF. FOR A PARTICULAR
				; DATA  - CH'N'IFP
IFNDEF CHVIFT,<CHVIFT==^D10>	;STANDARD INITIAL FAIRNESS COUNT FOR TRANSFERRING
				; CUSTOMER CAN ALSO CHANGE DEFINITION
				; FOR A PARTICULAR DATA CHANNEL  - CH'N'IFT
IFNDEF PTRLEN,<PTRLEN==^D7>	;NO. OF IN CORE RETRIEVAL POINTERS PER FILE
				; LENGTH AFFECTS SIZE OF DEVICE DATA BLOCK
IFNDEF LBFSIZ,<LBFSIZ==1000>	;DEFAULT LARGE-BUFFER SIZE (OP.LBF ON IN OPEN)
IFNDEF FIL4WD,<FIL4WD==^D9>	;NO. OF 8 WORD CORE BLOCKS PER JOB
				; FOR FILSER NMB,PPB,UFB,ACC CORE
				; BLOCKS(INCLUDING DORMANT ONES)
IFNDEF UNVRSF,<UNVRSF==^D500>	;RECIPROCAL SAFETY FACTOR FOR EACH UNIT
				; IE NO. BLKS ON UNIT/UNVRSF
				; IS SUBTRACTED FROM NO OF FREE BLOCKS
				; SEE STRTAL,UNITAL
IFNDEF LNMMXL,<LNMMXL==144>	;MAX LENGTH OF ANY LOGICAL NAME SPECIFICATION
IFG LNMMXL-177,<LNMMXL==177>	;DONT ALLOW LOGICAL NAMES TO EXCEED FIELD WIDTH
IFNDEF LNMMAX,<LNMMAX==77>	;MAX NO OF LOGICAL NAMES
;OTHER SYMBOLS WHICH THE CUSTOMER CAN CHANGE USING MONGEN INCLUDE:
;LBNHOM=	DEFAULT LOG BLOCK WITHIN UNIT FOR 1ST HOME BLOCK
;LB2HOM=	DEFAULT LOG BLOCK WITHIN UNIT FOR 2ND HOME BLOCK
;MFDSIZ=	NO. OF CONTIGUOUS BLOCKS TO ASSIGN TO MFD SO USUALLY NEED
;		ONLY ONE RETRIEVAL POINTER
;LOCATION OF HOME BLOCKS ON A PARTICULAR UNIT:
; EG. FHA0HM,DPA3H2

IFNDEF SYRDPR,<XP SYRDPR,355000>	;NON-PRIVILEGED FILES IN SYS
				; HOME.SYS,SAT.SYS
IFNDEF SYNRPR,<XP SYNRPR,357000>	;PRIVILEGED FILES IN SYS
			; CRASH.SAV, SNAP.SYS,RECOV.SYS,BADBLK.SYS,SWAP.SYS
IFNDEF MFDPRV,<XP MFDPRV,555000>	;MFD PRIVILEGES(ALL CAN READ,LOOKUP)
			; BUT NOT CREATE
IFNDEF SYSPRV,<XP SYSPRV,775000>	;SYS UFD PRIVILEGES(PROJ 1 READ,CREATE
			;LOOKUP, OTHERS READ
			; LOOKUP ONLY

IFNDEF PRVSPL,<PRVSPL==077>	;PROTECTION FOR SPOOLED OUTPUT
IFNDEF PRVSYS,<PRVSYS==155>	;PROTECTION FOR MOST SYS:
IFNDEF PRYSYS,<PRYSYS==157>	;PROTECTION FOR SYS:.SYS
;FBOOTB==4			;FIRST LOGICAL BLOCK FOR BOOTS
IFNDEF LIMLVL,<LIMLVL==5>	;MAX NUMBER OF NESTED SFD'S FOR THIS MONITOR
IFG LIMLVL-5,<PRINTX ILLEGAL VALUE FOR LIMLVL>
IFNDEF MAXUSI,<MAXUSI==^D8>	;MAXIMUM NEGATIVE USETI
				;  FOR READING EXTENDED RIBS
IFE FTKS10,<
IFNDEF BLKMAX,<BLKMAX==^D100000> ;MAX NUMBER OF BLOCKS TO TRANSFER
				; WITH 1 IOWD (SO WONT LOCK OUT
				; HIGH PRIORITY JOBS TOO LONG)
>;END IFE FTKS10
IFN FTKS10,<
IFNDEF BLKMAX,<BLKMAX==^D252>	;MAX NUMBER OF BLOCKS TO TRANSFER
				;AT ONE TIME (UNIBUS ADAPTER MAPPING LIMIT)
>;END IFN FTKS10
IFG KT10AN,<SEGN==SEGN+JOBN>	;NO. OF SEGMENTS=NO. OF JOBS+EXTRA SEGMENTS
IFNDEF INDPPN,<INDPPN==0>	;0 MEANS PROJ-PROG ARE DEPENDENT ACCROSS PROJECTS
				; (IE OWNER IS DETERMINED BY PROGRAMMER FIELD ONLY)
				;777777 MEANS PROJ-PROG NOS ARE INDEPENDENT
				; (IE OWNER IS DETERMINED BY PROJECT AND PROGRAMMER
				; NUMBER FIELDS) - EACH ONE BIT IN INDPPN CAUSES
				; THAT BIT TO BE COMPARED IN PROJECT FIELD FOR
				; TEST OF OWNER
IFNDEF M.QSTR,<M.QSTR==0>	;DEFAULT QUESTR

IFN FTCIDSK,<
IFNDEF M.BNDT,<M.BNDT==:^D16>	;DEFAULT NUMBER OF SECONDS BEFORE BINDING CI
				; DISKS AT ONCE TIME
>; END IFN FTCIDSK

IFN FTSETS,<
IFNDEF M.SETS,<M.SETS==:0>	;DEFAULT DISK SETS THIS MONITOR MOUNTS
>; END IFN FTSETS

IFNDEF M.CBMX,<M.CBMX==JOBN-1>	;DEFAULT BLOCKS IN DISK CACHE

XP	CBHSHS,M.CBMX		;NUMBER OF BLOCKS IN DISK CACHE
IFNDEF M.CBHS,<M.CBHS==M.CBMX/2> ;DEFAULT NUMBER OF HASH SLOTS
XP     CBHSHL,<M.CBHS!1>*2       ;WORDS IN HASH TABLE (2 WORD ENTRIES,KEEP
                                 ;ODD FOR BETTER HASH)


IFNDEF MBFN,<
	MBFN==<JOBN/^D10>+1
>;END IFNDEF
IFN FTDUFC,<
IFLE MBFN-1,<
	MBFN==2
>;END IFLE
>;END IFN
SUBTTL	GENERAL COMMENTS
REPEAT 0,<
STEPS TO WRITE NEW SOFTWARE FOR A NEW KONTROLLER TYPE

1. DECIDE ON A 2 LETTER MNEMONIC (FH,MD,DP,FS,RP,RN ARE TAKEN, DR RESERVED FOR DRUM)
2. WRITE KONTROLLER DEPENDENT ROUTINE (EG XX'XKON)
3. ADD A KONTROLLER DEPENDENT MACRO XX'KON IN COMMOD
4. ADD ANOTHER REPEAT LOOP IN CHANNEL MACRO (CHNCB) TO CALL KONTCB MACRO IN COMMOD
5. ADD MNEMONIC DEFINITION FOR TOTAL NUMBER OF KONTROLLERS TO COMMON (EG FHDN FOR FH)
>

LOGIC==0		;MAKE SURE PROGRAM LOGIC FLOW IS NEVER ASSEMBLED
REPEAT	LOGIC,<
	THE	PROGRAM LOGIC FLOW FOR THE LEVEL D DISK SERVICE IS PRODUCED
FROM THE PROGRAM LISTINGS BY USE OF A TECO MACRO.  ALL TEXT INSIDE
REPEAT LOGIC,< AND > IS COPIED INTO THE MANUAL.  PUTTING THE PROGRAM
LOGIC FLOW INTO THE LISTING MAKES IT EASIER TO KEEP THE LOGIC FLOW
UP TO DATE WITH THE ACTUAL CODE.
	THE	PROGRAM LOGIC FLOW IS WRITTEN IN A CLOSE TO ENGLISH MANNER
FOLLOWING SYNTACTIC RULES OF THE MAD (MICHIGAN ALGORITHMIC DECODER)
LANGUAGE.  A MINIMUM OF ACTUAL PROGRAM SYMBOLS ARE USED IN THE STATEMENTS.
HOWEVER THE SYMBOLIC TAGS DO CORRESPOND TO THE ONES USED IN THE PROGRAM
FOR EASE OF RELATING A PIECE OF THE FLOW TO THE CODE.  ENGLISH HAS BEEN
USED FOR A NUMBER OF REASONS.  FIRST, THE ENGLISH FLOW WAS PRODUCED
BEFORE THE CODE WAS WRITTEN.  IN THIS WAY THE DESIGN OF THE DECISION
LOGIC WAS DECOMPOSED FROM THE PROBLEM OF CODING, SUCH AS NAMING SYMBOLS,
BITS, AC USAGE AND SUBROUTINE ORGANIZATION.  SECONDLY THE READER
INTERESTED IN UNDERSTANDING THE FLOW DOES NOT HAVE TO LEARN THE ENTIRE
FLOW BEFORE UNDERSTANDING A PART OF IT; HE DOES NOT NEED TO LEARN AND
REMEMBER A LOT OF SYMBOLS AND THEIR MEANING.  A FEW ABBREVIATIONS HAVE
BEEN USED AND THEY ARE:
	STR	FILE STRUCTURE - A LOGICALLY COMPLETE, SELF CONTAINED,
		AND REMOVABLE PART OF THE DISK SYSTEM.  ALL FILE
		RETRIEVAL POINTERS STORED IN AN STR REFER TO DISK
		ADDRESSES WITHIN THAT STR.
	MFD	MASTER FILE DIRECTORY - LISTS ALL PROJECT PROGRAMMER
		NUMBERS IN A SINGLE FILE STRUCTURE ALONG WITH THE DISK
		ADDRESS WITHIN THE FILE STRUCTURE OF THE ASSOCIATED UFD.
	UFD	USER FILE DIRECTORY - LISTS ALL FILES BELONGING TO A
		USER (IDENTIFIED BY A PROJECT-PROGRAMMER NUMBER PAIR)
		IN A SINGLE FILE STRUCTURE ALONG WITH THE DISK ADDRESS
		THE FILE STRUCTURE OF THE ASSOCIATED FILE.
	RIB	RETRIEVAL INFORMATION BLOCK - ALL FILES (INCLUDING THE
		MFD AND UFD) HAVE A 128 WORD DISK BLOCK (RELATIVE BLOCK 0
		OF THE FILE) WHICH CONTAINS ATTRIBUTES OF THE FILE
		ALONG WITH POINTERS TO THE CONTIGUOUS GROUPS OF 128
		WORD DATA BLOCKS OF THE FILE.  THE MFD AND UFD REALLY
		POINT TO THE RIB WHICH IN TURN POINTS TO ALL PARTS OF
		THE FILE.
>
;	THERE IS A POTENTIAL CONFUSION BETWEEN 3 KINDS OF DISK POINTERS:
;	A.  COMPRESSED UFD POINTERS (CUP) - FOUND ONLY IN DIRECTORIES,
;	    POINT TO UNIT AND FIRST CLUSTER.
;	B.  CLUSTER POINTERS - FOUND MOST EVERYWHERE - POINT TO CLUSTERS.
;	C.  BLOCK POINTERS - SELDOM FOUND IN CORE OR ON DISK.
;	    EXEPTIONS:  RIBUFD, RIBSLF,UNIBLK, HOMSLF, SAFSLF

;USE OF PREFIXES IN DEFINING SYMBOLS
;THERE ARE A NUMBER OF DATA AREAS IN CORE OR ON THE DISK WHICH HAVE
;SYMBOLS WHICH DEFINE EACH POSITION IN THE AREA.  TO MAKE IT
;CLEAR WHICH AREA A SYMBOL IS FROM, EACH SYMBOL HAS A THREE LETTER,
;PRONOUNCEABLE PREFIX.  THIS PREFIX IS DIFFERENT WHEN AREA IS IN CORE
;FROM WHEN THE SAME DATA IS ON THE DISK.   THE FOLLOWING TABLE DEFINES
;THE PREFIXES:

REPEAT	LOGIC,<
	DATA	AREA			DISK	CORE	FILE NAME(IF ANY)

	HOME	FILE DATA BLOCK		HOM
	MASTER	FILE DIRECTORY		MFD		1-1.UFD
	USER	FILE DIRECTORY		UFD	UDB	#-#.UFD
	STORAGE	ALLOCATION FILE		SAF	SAB	SAT.SYS
	STORAGE	ALLOCATION POINTERS		SAP
	BAD	ALLOCATION FILE		BAF	BAT	BAT.SYS
	RETRIEVAL INFO BLOCK		RIB
	  (1 PER GROUP OF BLOCKS)
	DSKCHR	UUO				CHR
	LOOKUP/SEARCH/ENTER/RENAME		ENT
	FILE	STRUCTURE DATA BLOCK		STR
	CHANNEL	DATA BLOCK			CHN
	CONTROLLER DATA BLOCK			CON
	UNIT	DATA BLOCK				UNI
	DEVICE	DATA BLOCK(1 PER			DEV
	  OPEN FILE - USER CHANNEL PAIR)
	PROJECT-PROGRAMMER NUMBER BLOCK		PPB
	FILENAME (WITHIN PPN) BLOCK		NMB
	ACCESS	TABLE(1 PER OPEN FILE		ACC
	  OR RECENTLY CLOSED FILE)
>



REPEAT	LOGIC,<
CONVENTIONS ABOUT SYMBOL PREFIXES.  WITHIN CORE BLOCKS THERE ARE THE
FOLLOWING TYPES OF SYMBOLS:
	ACC,NMB	1. RELATIVE WORD ADDRESS
	ACY	2. RELATIVE OR ABSOLUTE ADDRESS OF A WORD CONTAINING A BYTE POINTER
	ACS	3. SIZES OF A BYTE
	ACP	4. BIT WHICH IS IN RIGHT MOST POSITION OF BYTE OR BIT ITSELF.
		   NOTE: BIT 35 IS DEFINED AS 1, BIT 18 AS 400000,
			BIT 17 AS 1, ETC.
	ACN	5. BIT NUMBER (0...35) OF RIGHT MOST BIT OF BYTE
		   (USED TO DEFINE SYMBOLS FOR BYTE POINTERS)
		   (DO NOT CONFUSE WITH ACP)
	ACR	6. BITS IN A BYTE AFTER IT HAS BEEN RIGHT JUSTIFIED IN AN AC.
	ACV	7. VALUE OF A CODE (MORE THAN 1 BIT FLAG) RIGHT JUSTIFIED IN AN AC
		   FOR USE IN LDB AND DPB
	ACM	8. MASK FOR BYTE, I.E. ONES IN EVERY BIT POSITION
		   (BEFORE BYTE IS RIGHT JUSTIFIED)
	ACJ	9. -NO. OF PLACES TO RIGHT JUSTIFY BYTE IN AC (ALWAYS NEG.)

THE RELATIVE WORD ADDRESS HAS THE FULL 3 LETTER PREFIX OF THE CORE BLOCK.
MANY PREFIXES END WITH B STANDING FOR BLOCK, (NOT BYTE OR BIT).
THE MNEMONIC FOR BYTE IS Y(ITS SECOND LETTER - SORRY ABOUT THAT), FOR SIZE
IS S, FOR POSITION IS P, AND FOR RIGHT-JUSTIFIED IS R.

>

;THE FOLLOWING TABLE DEFINES SOME SUFFIXES
;(THE SAME 3 LETTERS IS USED IF PREFIX ALREADY EXISTS)
REPEAT	0,<
	PARAMETER ADDRESSES

	SUFFIX		DEFINITION

	CHN		CHANNEL DATA BLOCK ADDRESS
	CON		CONTROLLER DATA BLOCK ADDRESS
	UNI		UNIT DATA BLOCK ADDRESS
	CCA		CURRENT CONTROLLER ADDRESS
	CUA		CURENT UNIT DATA BLOCK ADDRESS
	CDA		CURRENT DEVICE DATA BLOCK (FILE) ADDRESS
	TAL		TALLY OF FREE BLOCKSY		BUSY
	PAR		CONTROL WORD PAIR
	SER		SERVICE ROUTINE ADDRESS
	CUP		COMPRESSED POINTER IN UFD'S
	BYT		BYTE POINTER
	POS		RIGHT MOST BIT OF BYTE POINTER BYTE POSITIONS
	SIZ		SIZE OF BYTE, USED IN BYTE POINTERS
	FIL		FILE NAME IN SIXBIT
	EXT		FILE EXTENSION
	DTE		DATE
	PPN		PROJECT-PROGRAMMER NUMBER
	UFD		LOGICAL BLOCK NUMBER OF UFD
	MOD		DEVICE DATA MODE
	MIN		CREATION TIME IN MINUTES
	PRV		ACCESS PRIVILEGES
	CRE		CREATION DATE
	RDN		READ COUNT
	ENT		LOOKUP/SEARCH/ENTER/RENAME
	K4S		NO. OF K FOR SWAPPING
	HGH		HIGHEST LOGICAL BLOCK NUMBER
	BPU		BLOCKS PER UNIT
	CYL		CYLINDER NUMBER
	BLK		LOGICAL BLOCK WITHIN LOGICAL UNIT
	REL		RELATIVE BLOCK NUMBER WITHIN FILE
	BPC(BYT)	BLOCKS PER CLUSTER
	BPY(BYTE)	BLOCKS PER SMALLEST CYLINDER
	BPT(BYTE)	BLOCKS PER TRACK
	WPB		WORDS PER BLOCK
	LUN(BYTE)	LOGICAL UNIT NO.(WITHIN FILE STRUCTURE)
	PUN(BYTE)	PHYSICAL UNIT NO.(WITHIN CONTROLLER)
	TYP(BYTE)	DEVICE TYPE (DRM,FHD,DPC,MDF)
	CNP(BYTE)	BLOCK COUNT BYTE. POINTER TO CURRENT RET. PTR.
	CKP(BYTE)	CHECKSUM BYTE POINTER IN RET. PTR. TO CURRENT RET. PTR.


	CLP(BYTE)	CLUSTER BYTE POINTER IN RET. PTR. TO CURRENT RET. PTR.
	ERR		ERROR CODE
	ECT		ERROR COUNT ON CURRENT TRANSFER
	PI		PI CHANNEL NUMBER (1 - 7)
	IFP		INITIAL FAIRNESS SETTING FOR POSITIONING ON UNITS
	CFP		CURRENT FAIRNESS COUNT FOR POSITIONING ON UNITS
	IFT		INITIAL FAIRNESS SETTING FOR TRANSFERS ON CHANNEL
	CFT		CURRENT FAIRNESS COUNT FOR TRANSFERS ON CHANNEL
	COD		STATE CODE FOR FILES AND UNITS (I,SW,S,PW,P,TW,T)
	DIF		DIFFERENCE
	MIN		MINUS
	STN		FILE STRUCTURE NUMBER
	FSN		FILE STRUCTURE NUMBER (0-14)
	PT1		FIRST RETRIEVAL POINTER
	UN1		FIRST LOGICAL NO. WITHIN STR FOR A FILE
	OVR		-NUMBER OF BLOCKS ALLOWED FOR OVERFLOW
	KNO		KNOW EXISTENCE OF FILE AS YES OR NO IN AN STR
	YES		KNOW EXISTENCE OF A FILE AS YES IN AN STR
	PRV		ACCESS PRIVILEGES
	HID		HOME BLOCK ID=PACK ID
	LBN		LOGICAL BLOCK NUMBER WITHIN UNIT

	CORE	LOCATIONS

	IOC		I/O CONTROL WORD, CHANNEL JUMP
	CCW		FINAL CHANNEL CONTROL WORD
	CMD		CONTAINS FIRST OF MANY CHANNEL COMMAND WORDS
	LAS		LAST CHANNEL COMMAND WORD, ALWAYS 0
>
REPEAT	0,<
THE FOLLOWING CONTROLLER TYPE SYMBOLS (PREFIXES IN DEVICE DEPENDENT
ROUTINES AND IN CONTROLLER DATA BLOCKS FOR THAT DEVICE)

	DRM		DRUM CONTROLLERS
	FHD		FIXED HEAD CONTROLLERS
	DPC		DISK PACK CONTROLLER
	MDF		MASS FILE CONTROLLERS

THE FOLLOWING SUFFIXES ARE USED FOR ENTRY POINTS INTO DEVICE DEPENDENT
CONTROLLER ROUTINES

	RED		READ BLOCKS
	WRT		WRITE BLOCKS
	RDS		READ AND STOP IF ERROR
	WTS		WRITE AND STOP IF ERROR
	POS		POSITION UNIT
	LTM		RETURN LATENCY TIME


THE FOLLOWING ARE PREFIXES WHICH RELATE TO THE TYPE OF DATA BUT ARE
NOT IN DATA BLOCKS

	TYP		TYPE OF DEVICE (DRM,FHD,DPC,MDF)
	DSK		DISK
	FNC		FUNCTION CODE ON CALL TO CONTROLLER ROUTINES
>

SUBTTL	LIMITS OF VARIOUS FIELD WIDTHS IN FILE STRUCTURES

	INTERN	LIMCLP,LLMCLP,LIMCNP,LLMCNP,LIMCKP,LLMCKP,MAXLVL,LIMLVL
	INTERN	LIMFRE,LIMNUS,LIMBLK,LIMLEN,LIMHOM,LIMBBF,LIMBBW,LIMUSZ
	INTERN	LIMWPS,LIMSIC,LIMUFD,LIMQTF,LIMBPC,SWBKPP
	INTERN	BLKSIZ,MBLKSZ,BLKLSH,MBKLSH,BLKBPK,MBKBPK,LIMK4S

LIMHOM==^D18		;LIMIT ON HIGHEST LOG. BLOCK # THAT CAN BE A HOME BLOCK
LIMFRE==^D13		;LIMIT ON NUMBER OF FREE CLUSTERS IN A 128 WORD
			; SAT TABLE
LIMNUS==^D6		;NO. OF UNITS IN A RH FILE STRUCTURE (77)
LIMCLP==^D23		;UPPERLIMIT ON BYTE SIZE OF CLUSTER ADDRESS IN
			; RETRIEVAL POINTER (I.E. LIMIT ON NUMBER OF
			; CLUSTERS ON A SINGLE UNIT)
LLMCLP==^D1		;LOWER LIMIT
LIMCKP==^D34		;UPPER LIMIT ON BYTE SIZE CHECKSUM
LLMCKP==^D0		;LOWER LIMIT
LIMCNP==^D18		;UPPER LIMIT ON BYTE SIZE OF NO. OF CLUSTERS IN A
			; RETRIEVAL POINTER (ELSE RUN INTO UNIT CHANGE BIT)
LLMCNP==^D1		;LOWER LIMIT
LIMBLK==^D36		;LIMIT ON THE NUMBER OF BLOCKS ON A SINGLE UNIT
LIMLEN==^D36		;MAX. NO. OF BLOCKS IN A FILE
LIMWPS==^D7		;MAX. NO. OF WORDS PER SAT BLOCK
			;(CANNOT EXCEED CLUSTER SIZE EITHER)
LIMSIC==^D8		;MAX. NO. OF SAT BUFFERS IN CORE
LIMUFD==^D9		;MAX. NO. OF BLOCKS IN MFD OR UFD
LIMQTF==^D27		;MAX. NO. OF FIRST COME FIRST SERVE DISK BLOCKS IN LOGGED IN
			; QUOTA FOR A USER ON A FILE STRUCTURE.
LIMBPC==^D9
LIMBBF==^D31		;MAX NO OF DEFAULT BLOCKS PER BUFFER
LIMBBW==^D31*^D128	;MAX NO OF WORDS PER BUFFER
LIMUSZ==^D45		;MAX NO OF BLOCKS TO ZERO ON AN ALLOCATING USETO
			;DO ***NOT*** INCREASE THIS NUMBER, IT IS HARDWARE DEPENDENT
			;(3600 WORDS * 3 IOWDS). SEE RH2FX1 IN KLSER

MAXLVL==:5		;ABSOLUTE MAX NUMBER OF NESTED SFD'S
BLKSIZ==^D128		;NO. OF WORDS IN A DISK BLOCK (MUST BE POWER OF 2)
MBLKSZ==-BLKSIZ		;MINUS NO. OF WORDS IN A DISK BLOCK
BLKLSH==^D7		;NO. OF PLACES TO SHIFT LEFT TO CONVERT FROM
			; BLOCKS TO WORDS
MBKLSH=-BLKLSH		;MINUS NO OF PLACES TO SHIFT LEFT (IE RIGHT) TO
			; CONVERT FROM WORDS TO BLOCKS
BLKBPK==^D1024/BLKSIZ	;NO. OF BLOCKS PER K WORDS
MBKBPK==-BLKBPK		;MINUS NO OF BLOCKS PER K WORDS.
SWBKPP==4		;4 BLOCKS PER PAGE
LIMK4S==^D18		;MAX NO OF PAGES FOR SWAPPING ON UNIT
SUBTTL	DATA STRUCTURE DESCRIPTION
;THE FOLLOWING CORE DATA BLOCKS ARE LINKED TOGETHER TO DESCRIBE
;AN ARBITRARY CONFIGURATION OF FILE STRUCTURES ON AN ARBITRARY
;CONFIGURATION OF CHANNELS, KONTROLLERS, POSITIONERS, AND UNITS:
;EACH SYSTEM HAS:
;SYS:	DATA LOCATIONS AND BYTE POINTERS PER SYSTEM
;STR: 1 OR MORE FILE STRUCTURES PER SYSTEM
;CHN: 1 OR MORE CHANNELS (CAN BE SHARED BY MORE THAN 1 FILE STRUCTURE)
;CON: 1 OR MORE KONTROLLERS (DIFFERENT TYPES ON SAME CHANNEL, BUT SAME
;     TYPES IN A GIVEN FILE STRUCTURE) PER CHANNEL
;UNI: 1 OR MORE UNITS PER KONTROLLER
;DEV: 1 OR MORE QUEUED POSITION REQUESTS PER UNIT
;     1 OR MORE QUEUED TRANSFER REQUESTS PER CHANNEL
;PPB: 1 OR MORE ACTIVE OR DORMANT PROJ-PROG NOS BLOCKS PER SYSTEM
;UFB: 1 OR MORE ACTIVE OR DORMANT UFD BLOCKS (1 FOR EACH STR) PER PROJ-PROG NO.
;NMB: 1 OR MORE ACTIVE OR DORMANT FILE NAME BLOCK (INDEPENDENT OF STR)
;	PER PROJ-PROG NO.
;ACC: 1 OR MORE ACTIVE OR DORMANT ACCESS BLOCK (1 FOR EACH VERSION OF A FILE)
;	PER FILEMANE/PROJ-PROG NO. PAIR

;THE FOLLOWING RESTRICTIONS APPLY:
;    1) FILE STRUCTURE MUST BE COMPOSED OF SAME SIZE AND TYPE DEVICES
;	EXCEPTIONS - RD10 (BURROUGHS FHD) AND RM10B (BRYANT DRUM) MAY
;	BE IN SAME FILE STRUCTURE SINCE ON SAME CONTROLLER; ALSO RP01
;	AND RP02 (MEMOREX DISK PACK)
;    2) FILE STRUCTURE MAY BE COMPOSED OF ONE OR MORE CONTROLLERS
;	(OF THE SAME TYPE.)
;    3) EACH UNIT CAN BE A MEMBER OF ONE AND ONLY ONE FILE STRUCTURE
;    4) MORE THAN ONE CONTROLLER IN THE SAME OR DIFFERENT FILE STRUCTURE
;	ON THE SAME CHANNEL (SOFTWARE WILL DO LATENCY OPTIMIZATION ON A
;	CHANNEL BASIS RATHER THAN A CONTROLLER BASIS)

;SOME CORE BLOCKS ARE LINKED TOGETHER BY A ONE DIRECTION STRING OF
;POINTERS TERMINATED WITH A 0.  A "LIST", PTR IN LH.  OTHER CORE BLOCKS
;ARE LINKED TOGETHER BY A ONE DIRECTIONAL STRING OF POINTERS WHICH
;CLOSES ON IT SELF.  A "RING", PTR IN LH.  STILL OTHER BLOCKS POINT
;BACK UP THE TREE TO THEIR FATHER OR THEIR GRANDFATHERS.
;UPWARD POINTERS TEND TO BE IN RH WITH BITS 13-17=0 SO INDIRECTION
;CAN BE USED.
;THE REST OF THE CORE BLOCKS ARE POINTED TO BY ONE CORE BLOCK TABLE
;OF POINTERS - A"FANOUT TABLE" THESE ARE IN RH.

;STATIC ADDRESS OF CORE DATA BLOCKS ASSEMBLED IN OTHER DATA BLOCKS:
;FANOUT TAB	- SYS POINTS TO ALL STR TABLES (TABSTR) (MAX.14)
;FANOUT TAB	- EACH KON POINTS TO ALL PHYSICAL UNI WITHIN KONTROLLERS (KONTAB)
;LIST		- EACH STR LINKS TO NEXT STR WITHIN SYS (LH STRSYS)
;LIST		- EACH UNI LINKS TO NEXT UNI WITHIN STR (LH UNISTR)
;LIST		- EACH UNI LINKS TO NEXT UNI WITHIN SYS (LH UNISER)
;RING		- EACH UNI LINKS TO NEXT UNI WITHIN CHN (LH UNICHN)
;RING		- EACH UNI LINKS TO NEXT UNI WITHIN KON (LH UNIKON)
;UPWARD POINTER	- EACH DEV POINTS TO ITS UNI (RH DEVUNI)
;UPWARD    "	- EACH UNI POINTS TO ITS CHN (RH UNICHN)
;UPWARD    "	- EACH UNI POINTS TO ITS KON (RH UNIKON)
;UPWARD    "	- EACH UNI POINTS TO ITS STR (RH UNISTR)
;UPWARD    "	- EACH KON POINTS TO ITS CHN (KONCHN)

SUBTTL	BLK - PARAMETERS WHICH APPEAR IN MORE THAN ONE DISK BLOCK
INTERN	BLKNAM,BLKCOD,BLKSLF

BLKNAM==0		;SIXBIT NAME OF LBOCK(HOM,BAT,ISW)
BLKCOD==176		;SELF IDENTIFYING CODE FOR BLOCK RH ONLY, LH==0
BLKSLF==177		;LOGICAL BLOCK WITHIN UNIT(NOT STR) TO IDENTIFY SELF
	$HIGH
SUBTTL	COR - PARAMETERS WHICH APPEAR IN MORE THAN ONE CORE BLOCK
;OUT OF ALPHABETIC ORDER BECAUSE MUST BE FIRST, SINCE SYMBOLS DEFINED USING
;THEM WITH THE SAME VALUES SO THAT GENERALIZED ROUTINES MAY BE CALLED.
;THESE SYMBOLS SHOULD NOT BE USED UNLESS FOR A GENERALIZED ROUTINE,
;ELSE BUGS SINCE NOT ALL CORE BLOCKS HAVE ALL THE FOLLOWING BYTES.
;HOWEVER ALL BYTES WHICH ARE THE SAME APPEAR IN THE SAME PLACE IN ALL
;CORE BLOCKS IN WHICH THE DATA APPEARS.



CORWDS==:10		;WORDS/CORE BLOCK
CRWDM1==:CORWDS-1
CORXTR==:7		;EXTRANEOUS BITS IN 8-WORD CORE BLOCK ADR'S

;WORD 0---------------------------------------
CORNAM==:0		;SIXBIT NAME OF BLOCK
			;[PPBNAM,NMBNAM]

;WORD 1---------------------------------------
CORLNK==:1		;LIST LINK WORD IN LH. LH=CORE ADR(ADDRESS POINTER)
			; TO NEXT BLOCK IN LIST WITH SAME FATHER. MAYBE
			; LIST OR RING, [PPBSYS,UFBPPB,NMPPB,ACCNMB]
DIFLNK==:CORLNK-CORWDS
CORUN1==:1		;FIRST LOGICAL UNIT WITHIN STR FOR THIS FILE - WORD ADR.
	COSUN1==^D4		;BYTE SIZE
	CONUN1==^D31		;BYTE PTR. POS.
	COPUN1==:20		;RIGHT MOST BIT
COYUN1::POINT	COSUN1,CORUN1(T2),CONUN1
COR1PT==:CORUN1		;SINGLE RETRIEVAL POINTER FLAG - WORD ADDR.
			;1 IF CORPT1 IS THE ONLY RETRIEVAL POINTER TO FILE
	COS1PT==^D1		;BYTE SIZE
	CON1PT==^D27		;BYTE PTR. POS.
	COP1PT==:400		;SINGLE RETRIEVAL POINTER FLAG - BIT[UFB1PT,NMB1PT,AKB1PT]

;WORD 2---------------------------------------
CORPT1==:2		;COPY OF FIRST RETRIEVAL POINTER TO FILE OR UFD
			; COR1PT=1 IF THIS IS THE ONLY POINTER [UFBPT1,AKBPT1]

;WORD 3---------------------------------------
;WORD 4---------------------------------------
CORFSN==:4		;FIRST FILE STRUCTURE NUMBER - WORD ADR.
	COSFSN==:.FSFSN		;BYTE SIZE
	CONFSN==:COSFSN-1	;BYTE PTR. POS. (LEFT JUSTIFIED IN WORD)
COYFSN::POINT	COSFSN,CORFSN(T2),CONFSN	;FILE STRUCTURE NUMBER - BYTE
COZFSN::POINT	COSFSN,CORFSN(T1),CONFSN
COXFSN::POINT	COSFSN,CORFSN(P4),CONFSN
CORZRB==4			;DIRECTORY HAS EMPTY DATA BLOCKS
	COPZRB==10		;BIT 14=1 IF YES


;WORD 5---------------------------------------
CORKNO==:5		;KNOW WHETHER FILE OR UFD DOES OR DOES NOT EXIST IN
			; IN FILE STRUCTURE N. - WORD ADR.
			; BIT N+1=1 IF KNOW IN STR N [PPBKNO,NMBKNO]
	COSKNO==:.SLMAX		;BYTE SIZE
	CONKNO==:COSKNO-1	;BYTE PTR. POS. (LEFT JUST. IN WORD)
	COPKNO==:1B<CONKNO>	;RIGHT MOST BIT
	COJKNO==:-^D35+CONKNO	;REQIRED SHIFT FOR RIGHT JUSTIFICATION
FSNBIT::COPKNO
ALLKNO::<-1>B<CONKNO>		;MASK FOR WHOLE KNO FIELD
COYKNO::POINT	COSKNO,CORKNO(T2),CONKNO
COZKNO::POINT	COSKNO,CORKNO(T1),CONKNO

;WORD 6---------------------------------------
CORYES==:6		;FILE OR UFD DEFINITELY EXISTS IN FILE STRUCTURE N-WORD ADR.
			; IF BIT N+1=1. CORRESPONDING BIT IN CORKNO=1 TOO
	COSYES==:COSKNO		;BYTE SIZE
	CONYES==:CONKNO		;BYTE PTR. POS.
	COPYES==:COPKNO		;RIGHT MOST BIT
ALLYES==:ALLKNO

;WORD 7---------------------------------------

SUBTTL	ACC:	ACCESS DATA BLOCKS ENTRY
; ONE ACCESS TABLE FOR EVERY VERSION OF AN OPEN FILE.
; MANY USERS ACCESSING SAME FILE VERSION, SHARE ACCESS TABLE
;DORMANT ACCESS TABLE IS LEFT AROUND IN CORE
; AFTER FILE IS CLOSED BY ALL USERS, IN HOPES
; THAT FILE WILL BE LOOKED UP SOON.

REPEAT 0,<

AN ACCESS TABLE CAN BE IN ONE OF THE FOLLOWING STATES:

	D  DORMANT
	R  BEING READ ON ONE OR MORE USERS-CHANNELS, NO ONE UPDATING
	C  BEING CREATED (BY ONE USER)
	S  SUPERSEDING AN OLDER VERSION AND NO ONE READING OLDER VERSION
	U  BEING UPDATED (SAME CHANNEL ALSO COUNTS AS ONE READER)
	UR	BEING UPDATED AND OTHER READERS (READER COUNT GREATER THAN 1)

FOR A GIVEN FILE STRUCTURE:  FILE.EXT[PROJ,PROG] THERE CAN BE EXACTLY
ONE AND ONLY ONE ACCESS ENTRY IN THE SYSTEM WITH THE FOLLOWING
EXCEPTIONS:
	A.  THERE CAN BE TWO ACCESS TABLE ENTRIES
	    R THE OLDER VERSION BEING READ BY 1 OR MORE USERS
	    S THE NEWER VERSION BEING CREATED BY ONE USER
	    THE SYSTEM IS SAID TO BE IN R+S STATE WITH RESPECT TO THE
	    FILE.
	B.  IN ADDITION TO ANY SINGLE ACCESS ENTRY FOR A GIVEN
	    FILE NAME (D, R, C, S, U, UR) OR THE PAIR R+S, THERE CAN
	    BE AN ARBITRARY NUMBER OF SUCCESSIVELY OLDER VERSIONS
	    STILL BEING READ BY ONE OR MORE USERS AND MARKED FOR
	    DELETION OF THE ACCESS TABLE AND DISK SPACE J WHEN READ
	    COUNT GOES TO 0.
THUS THE SYSTEM COULD BE IN ANY ONE OF THE FOLLOWING STATES WITH
REESPECT TO A FILE NAME ARE:
	NO	ACCESS ENTRY, D, R, C, S, U, UR, R+S, J, D+J, R+J, C+J, S+J
	U+J, UR+J, R+S+J, J+J, D+J+J,...R+S+J+K...K+J+J, ETC.
>
;WORD 0---------------------------------------
ACCALC==:0		;HIGHEST RELATIVE BLOCK ALLOCATED TO FILE BY MONITOR
			; OR USER (NEVER INCLUDING SECOND RIB BLOCK,
			; EVEN THOUGH IT IS ALLOCATED AT THE END OF FILE)

;WORD 1---------------------------------------
ACCNMB==:CORLNK		;LH=CORE ADDRESS(ACROSS POINTER) OF NEXT ACCESS
			; BLOCK WITH SAME NAME (AND PROJ-PROG NO.)
			;LAST ACCESS BLOCK POINTS BACK TO NAMEBLOCK(NMB)
			; MACING THIS ONE OF THE FEW RINGS INSTEAD OF LISTS
			; IN CORE BLOCK STRUCTURE. THE RING IS NEEDED SINCE
			; THERE IS NOT ROOM IN ACCESS BLOCK FOR A BACKWARD
			; POINTER TO PREVIOUS BLOCK. SINCE ACCESS RING IS
			; USUALLY ONLY ONE LONG, THIS IS NOT TOO INEFFICIENT
			; (WHEN REMOVING DORMANT ACCESS BLOCKS WHEN SPACE IS
			; NEEDED). NOTE: ADVANTAGE IS TACEN OF THE FACT
			; THAT CORE BLOCKS START AT 0 MODULO 8 ADDRESSES.
			; THE LAST ACCESS ENTRY IN RING POINTS BACK, NOT
			; TO FIRST ADDRESS IN NAME BLOCK BUT TO THE WORD WHICH
			; WHICH MAKES THE NAME BLOCK LOOK JUST LIKE AN
			; ACCESS ENTRY. THUS LOW ORDER BITS ARE ON IN LAST
			; BLOCK POINTING TO NAME BLOCK (OR IN NAME BLOCK
			; (NMBACC) IF NO ACCESS BLOCKS AT ALL IN RING.  IN
			; THIS WAY SCANNING AROUND RING AND DELETION ARE
			; NEVER SPECIAL CASES LAST ACCESS BLOCK OR FIRST
			; ACCESS BLOCK IN RING.
			;RH=USED FOR AN INDEPENDENT QUANTITY.
ACCABC==:1		;THIS FILE HAS ALWAYS BAD CHECKSUM
	ACSABC==:1		;BYTE SIZE
	ACNABC==^D18	;BYTE POINTER POSITION
	ACPABC==:400000	;RIGHT MOST BIT
ACCLBS==:1		;LAST BLOCK IN FILE SIZE (NO. OF WORDS WRITTEN IN LAST
			; DATA BLOCK)-WORD ADR.
	ACSLBS==^D8		;BYTE SIZE
	ACNLBS==^D26		;BYTE PTR. POS.
ACYLBS::POINT	ACSLBS,ACCLBS(T2),ACNLBS	;THE BYTE POINTER
ACZLBS::POINT	ACSLBS,ACCLBS(T3),ACNLBS	;THE BYTE POINTER
ACC1PT==:COR1PT		;FLAG FOR ONLY ONE RETRIEVAL POINTER FOR FILE - WORD ADR.
	ACS1PT==:COS1PT	;BYTE SIZE
	ACN1PT==:CON1PT	;BYTE PTR. POS.
	ACP1PT==:COP1PT	;RIGHT MOST BIT
ACCUN1==:CORUN1		;1ST. LOGICAL UNIT IN FILE STRUCTURE OF THIS FILE - WORD ADR.
	ACSUN1==:COSUN1	;BYTE SIZE
	ACNUN1==:CONUN1	;BYTE PTR. POS.
ACCDIR==:1		;THIS FILE IS A DIRECTORY(UFD OR MFD) - WORD ADR.
	ACSDIR==^D1		;BYTE SIZE
	ACNDIR==^D32		;BYTE PTR. POS.
	ACPDIR==:10		;THIS FILE IS A DIRECTORY(UFD OR MFD) - BIT
ACCNDL==:1		;THIS FILE CANNOT BE DELETED
	ACSNDL==:1		;BYTE SIZE
	ACNNDL==^D33		;BYTE POS
	ACPNDL==:4		;THE BIT
ACCSBC==:1		;SOMETIMES BAD CHECKSUM (UPDATE)
	ACSSBC==:1		;BYTE SIZE
	ACNSBC==^D34		;BYTE POSITION
	ACPSBC==:2		;THE BIT
ACCNCK==:ACCABC	;DONT CHEC CHECKSUMS FOR THIS FILE - WORD ADR
	ACPNCK==:ACPDIR+ACPABC+ACPSBC
ACCGRB==:ACCABC	;DONT GRAB A.T. - WORD ADDRESS
	ACPGRB==:1	;CORE GRABBER WONT TOUCH A.T. IF ON


;WORD 2---------------------------------------
ACCPT1==:CORPT1		;FIRST RETRIEVAL POINTER TO FILE - WORD ADR.
			; ACP1PT BIT=1 IF THIS POINTER COMPLETELY DESCRIBES THE FILE.
			; SO RIB DOES NOT NEED TO BE READ FOR MORE POINTERS.
			; (CLUSTER COUNT, CHECKSUM, CLUSTER ADDRESS)

;WORD 3---------------------------------------
ACCDOR==:3		;TWO WAY THREADED LIST LINK WORD
			;LH=CORE ADDRESS(ACROSS POINTER) OF NEXT ACCESS BLOCK
			; IN DORMANT ACCESS BLOCK LIST FOR SYSTEM
			;RH=CORE ADDRESS(BACKWARD POINTER) OF PREVIOUS ACCESS
			; BLOCK IN DORMANT ACCESS BLOCK LIST FOR SYSTEM.
			;THIS WORD=0 IF ACCESS BLOCK IS NOT DORMANT.
			;THIS IS ONLY FLAG FOR DORMANT.
			;THE DORMANT LIST IS TWO-WAY THREADED, SO THAT AN
			; ACCESS BLOCK CAN BE REMOVED QUICKLY FROM THE
			; MIDDLE WHENEVER THE ACCESS BLOCK BECOMES DORMANT.

;WORD 4---------------------------------------
ACCPPB==:4		;LH=USED FOR AN INDEPENDENT QUANTITY
			;RH=CORE ADDRESS (UPWARD POINTER) TO PROJ-PROG
			; BLOCK (PPB) WHICH THIS ACCESS BLOCK IS IN
ACCFSN==:CORFSN		;FSN # - WORD ADR.
	ACSFSN==:COSFSN	;BYTE SIZE
	ACNFSN==:CONFSN	;BYTE PTR. POS.
ACYFSN==:COYFSN		;FILE STRUCTURE NO. IN WHICH FILE STARTS
			;INDEXED BY T2.
ACZFSN==:COZFSN		;FSN INDEXED BY T1
FSNINC==:.FSXX1		;FILE STR NO. WHICH FLAGS AN ACCESS BLOCK AS BEING
			; INCOMPLETE(SO FNDFIL SHOULD IGNORE).

ACCWCT==:ACCPPB	;WRITE COUNT FOR SIMULTANEOUS UPDATERS
	ACSWCT==^D8	;BYTE SIZE
	ACNWCT==^D13	;BYTE PNTR POSITION
	ACPWCT==:20	;RIGHT-MOST BIT
	ACWCNT==:7760	;MASK FOR THIS FIELD
ACYWCT::POINT	ACSWCT,ACCWCT(T1),ACNWCT
ACZWCT::POINT	ACSWCT,ACCWCT(T2),ACNWCT
ACCZRB==:CORZRB			;SFD HAS EMPTY DATA BLOCKS WORD ADR
	ACPZRB==COPZRB		; THE BIT

;WORD 5---------------------------------------
ACCADT==:5		;DATE THIS FILE WAS LAST ACCESSED FOR MORE THAN JUST LOOKUP
	ACSADT==^D15		;BYTE SIZE
	ACNADT==^D17		;BYTE PTR. POS.
			;BITS 0-2 HAVE HIGH-ORDER PART OF CEATION DATE

ACCNIU==:5		;FILE NOT IN UFD - WORD ADR.
	ACSNIU==^D1		;BYTE SIZE
	ACNNIU==^D18		;BYTE PTR. POS.
	ACPNIU==:400000	;THE BIT - MUST BE BIT 18
ACCCNT==:ACCNIU		;NO. OF USER CHANS. WHICH HAVE LOOKED UP FILE - WORD ADR.
	ACSCNT==^D9		;BYTE SIZE
	ACNCNT==^D27		;BYTE PTR. POS.
	ACPCNT==:400		;RIGHT MOST BIT
	ACMCNT==:377400	;MASK (BEFORE RIGHT JUSTIFIED)
	ACMCNM==:377000		;MASK FOR READ COUNT-1
ACCUSE==:ACCCNT	;SAME FIELD, BUT USED AS AN SFD USE-COUNT
	ACPUSE==:ACPCNT
	ACMUCT==:ACMCNT
	ACMUCM==:ACMCNM

ACYCNT::POINT	ACSCNT,ACCCNT(T1),ACNCNT;READ COUNT BYTE POINTER-
			;NO. OF USER CHANNELS
			; WHICH HAVE LOOKED UP FILE(1 MAY BE UPDATING).
ACZCNT::POINT	ACSCNT,ACCCNT(T2),ACNCNT
ACCREN==:ACCSTS		;RENAME UUO IN PROGRESS FOR THIS FILE FLAG - WORD ADR.
			; CAN BE ON WITH OR WITHOUT JUST ONE FLAG BIT IN ACYSTS.
	ACSREN==^D1		;BYTE SIZE
	ACNREN==^D28		;BYTE PTR. POS.
	ACPREN==:200		;THE BIT

ACCDEL==:ACCSTS		;FILE MARKED TO BE DELETED WHEN ALL READERS FINISH-WORD ADR.
			; FILE WILL BE DELETED BY CLOSE UUO
	ACSDEL==^D1		;BYTE SIZE
	ACNDEL==^D29		;BYTE PTR. POS.
	ACPDEL==:100		;THE BIT
ACCSTS==:ACCCNT		;ACCESS TABLE STATUS - WORD ADR.
			; CONTAINS CREATE/SUPERSEDE/UPDATE UNARY STATE CODE
	ACSSTS==^D3		;BYTE SIZE
	ACNSTS==^D32		;BYTE PTR. POS.
	ACPCRE==:40		;CREATING FILE - UNARY STATE CODE
	ACRCRE==:4		;CREATING FILE - UNARY STATE CODE RIGHT JUSTIFIED
	ACPSUP==:20		;SUPERSEDING ANOTHER FILE - UNARY STATE CODE
	ACRSUP==:2		;SUPERSEDING ANOTHER FILE-UNARY STATE CODE RIGHT JUSTIFIED
	ACPUPD==:10		;UPDATING FILE - UNARY STATE CODE
	ACRUPD==:1		;UPDATING FILE - UNARY STATE CODE RIGHT JUSTIFIED

ACYSTS::POINT	ACSSTS,ACCSTS(T2),ACNSTS	;ACCESS TABLE STATUS

ACCSMU==:ACCCNT			;THIS FILE BEING SIMULTANEOUSLY UPDATED
	ACPSMU==:4		;THE BIT

ACCPAL==:ACCSTS			;PRE-ALLOCATED FILE
	ACPPAL==:2		;IF THIS IT IS ON

;NDR IS SET TO "1" BY QUESER IF ANY "NO DELETE ON RESET"
;REQUESTS ARE MADE ON THIS FILE.
ACSNDR==:^D1			;BYTE SIZE
ACNNDR==:^D35			;BYTE PTR. POS.
ACPNDR==:1			;THE BIT

;WORD 6---------------------------------------
ACCWRT==:6		;HGHEST RELATIVE BLOCK WRITTEN, NOT COUNTING SECOND
			; RIB. SINCE FIRST RIB IS RELATIVE BLOCK 0, AND
			; FIRST DATA BLOCK IS BLOCK1 THIS QUANTITY IS THE
			; SAME AS THE NUMBER OF DATA BLOCKS WRITTEN.
			;THIS WORD IS CHECKED ON READ FOR END OF FILE.
			;IT IS UPDATED DYNAMICALLY AS FILE IS APPENDED.

;WORD 7---------------------------------------
ACCPRV==:7		;PRIVILEGE WORD. SAME FORMAT AS LOOKUP/ENTER E+2
			; PRIVILEGES(9), MODE(4), CREATION TIME(11),CREATION DATE(12)
			; SEE RIBPRV FOR BIT DEFINITIONS
	ACSPRV==^D9		;BYTE SIZE
	ACNPRV==^D8		;BYTE PTR. POS.
ACYPRV::POINT	ACSPRV,ACCPRV(T4),ACNPRV	;BYTE PTR.
ACCMOD==:ACCPRV		;FILE MODE - WORD ADR.
	ACSMOD==^D4		;BYTE SIZE
	ACNMOD==^D12		;BYTE PTR. POS.
ACCCTM==:ACCPRV		;FILE CREATION TIME - WORD ADR.
	ACSCTM==^D11		;BYTE SIZE
	ACNCTM==^D23		;BYTE PTR. POS.
ACCCDT==:ACCPRV		;FILE CREATION DATE (LOW ORDER PART)
	ACSCDT==^D12		;BYTE SIZE
	ACNCDT==^D35		;BYTE PTR. POS.

SUBTTL	BAF:		BAD ALLOCATION FILE

; BLOCK AFTER HOME BLOCK IN HOME.SYS
; PROGRAMS SEARCHING HOME.SYS SHOULD LOOK FOR SIXBIT IDENTIFICATION IN
; FIRST WORD OF EACH BLOCK. THEN THEY WILL WORK NO MATTER WHAT THE
; CLUSTER SIZE IS.

	INTERN	BAFELB,BAYNBB,BAPOTH,BAFOTH,BARPUB,BAFPUB,BAYNBR
	INTERN	BAFCNT,BAFFIR,BAFCOD,BAFSLF,BASNBR,BANNBR,BAFNBR,CODBAT
	INTERN	BAYKDC,BRMAX,MBRMAX,BAFREG,BAFNUM,BAFNAM,BAFAPN
	INTERN	BAYAPN,BAYKNM


BAFNAM==BLKNAM	;CONTAINS SIXBIT /BAT/ FOR IDENTIFICATION
BAFFIR==1	;LH=-MAX. POSSIBLE NO. OF WORDS FOR BAD REGIONS MAP AND MONITOR
		; CAN ADD BEFORE BLOCK FILLS UP
		;RH=REL ADR. WITHIN THIS BLOCK OF FIRST BAD REGION PAIR
		; MAP PROGRAM FORCES LH TO BE EVEN NUMBER.
		;ALL PROGRAMS SHOULD SCAN THE BAT BLOCK BY STARTING WITH THIS WORD
		; RATHER THAN KNOWING WHERE DATA PAIRS START.  IN THIS WAY
		; ADDITIONAL HEADER WORDS CAN BE ADDED WITHOUT INVALIDATING ANY
		; PROGRAMS WHICH READ BAT BLOCK.
		;BOTH HALVES WRITTEN BY MAP PROGRAM AND NEVER CHANGED BY MONITOR

BAFNBS==2	;NO. OF BAD 128 WORD BLOCKS FOUND BY MAP PROGRAM - WORD ADR.
	BASNBS==^D9	;BYTE SIZE
	BANNBS==^D8	;BYTE PTR. POS.
BAFNBR==BAFNBS	;# OF BAD REGIONS(=# OF ENTRY PAIRS) FOUND BY MAP PROGRAM - WORD ADR.
	BASNBR==^D9	;BYTE SIZE
	BANNBR==^D17	;BYTE PTR. POS.
BAFKDC==2	;KONTROLLER DEVICE CODE USED BY MAP PROGRAM - WORD ADR.
	BASKDC==^D7	;BYTE SIZE
	BANKDC==^D24	;BYTE PTR. POS. -LEFT JUSTIFIED OCTAL SO PRINT LIKE DEVICE CODES.

BAFCNT==3	;NO. OF DISTINCT BAD REGION WORD PAIRS
		; APPENDED TO LIST BY MONITOR
		;MAP PROGRAM WRITES THIS WORD WITH ZEROES.


BAFREG==4	;FIRST BAD REGION WORD GOES HERE. THIS SYMBOL NEVER APPEARS IN ANY
		; CODE WHICH READS BAT BLOCK - EXCEPT MAP PROGRAM OR OPTIONAL ONCE
		;ONLY CODE WHICH WRITES IT THE FIRST TIME.  INSTEAD SEE RH OF BAFFIR
		;NOTE: BAFREG MUST BE AN EVEN NUMBER

BAYNBR:	POINT	BASNBR,BAFNBR(T3),BANNBR	;BYTE PTR FOR # BAD REGIONS FND BY MAP
;BAYNBS: POINT	BASNBS,BAFNBS(T3),BANNBS	;BYTE PTR FOR # BAD BLOCKS FOUND BY MAP
BAYKDC:	POINT	BASKDC,BAFKDC(T3),BANKDC	;BYTE PTR FOR KONTROLLER DEVICE CODE
;THE MAP PROGRAM IS NOT PART OF THE MONITOR - IT RUNS AS A STAND-ALONE PROGRAM
; WHICH WIRTES AN INITIAL BAT BLOCK WITH ALL THE BAD REGIONS IT FINDS.
;BOTH THE MAP PROGRAM AND THE MONITOR WRITE TWO WORD ENTRIES OF THE SAME FORMAT
;THE MONITOR ADDS TWO-WORD ENTRIES WHENEVER IT FINDS BAD REGIONS
;WHILE READING, WRITING, OR POSITIONING (READ OR WRITE)
;THE MAP PROGRAM AND MONITOR STORE LOGICAL RATHER THAN PHYSICAL ADDRESSES

BAFNBB==0	;NUMBER OF BAD BLOCKS-1 IN THIS BAD REGION(NOT CLUSTERS
		; -SINCE BADNESS IS INDEPENDENT
		; OF THE CLUSTER SIZE - WORD ADR(WITHIN 2 WORD ENTRY)
	BASNBB==^D9	;BYTE SIZE
	BANNBB==^D8	;BYTE PTR. POS.
	BAFNUM==777	;MAX NUMBER OF BAD BLOCKS IN A REGION-1
BAFOTH==0	;BIT NON-ZERO IF THIS SAVE BAD REGION IS DETECTED ON ANOTHER
		; KONTROLLER OR PROCESSOR THAN THE ONE WHICH ADDED THE ENTRY
		; IN THE FIRST PLACE - WORD ADR.
	BAPOTH==400	;BIT POS IN LH
BAYNBB:	POINT	BASNBB,BAFNBB(T2),BANNBB	;BYTE PTR
BAFPUB==0	;PHYSICAL UNIT BIT WITHIN CONTROLLER-WORD ADR.
		;BIT 10=UNIT 7, BIT 11=UNIT 6, BIT 17=UNIT 0.
	BASPUB==^D8	;BYTE SIZE
	BANPUB==^D17	;BYTE PTR. POS.
	BAPPUB==1	;LH BIT POSITION OF RIGHT MOST BIT(UNIT 0) IN BYTE
	BARPUB==1	;RIGHT-HAND BIT
BAFKNM==0	;LOGICAL KONTROLLER NUMBER OF THIS TYPE - WORD ADR.
		; SEE UNIKNM
	BASKNM==^D3	;BYTE SIZE
	BANKNM==^D20	;BYTE PTR. POS.
BAYKNM:	POINT	BASKNM,BAFKNM(T2),BANKNM	;BYTE PTR.

BAPNTP==:40000	;ON FOR NEW-STYLE BAT BLOCK ENTRIES
BAFAPN==0	;ARITHMETIC PROCESSOR # (DECIMAL) TO WHICH CONTROLLER IS ATTACHED
		; WHEN ERROR DISCOVERED BY MONITOR - WORD ADR. (WITHIN 2 WORD ENTRY)
		;THIS IS USEFUL TO IDENTIFY THE PHYSICAL UNIT ON WHICH THE ERROR
		; OCCURRED IN CASE SOME UNITS DETECT DIFFERENT SURFACE
		; ERRORS THAN OTHER UNITS WHEN THE PACKS ARE
		; EXCHANGED.
	BASAPN==^D14	;BYTE SIZE
	BANAPN==^D35	;BYTE PTR POS
BAYAPN:	POINT	BASAPN,BAFAPN(T2),BANAPN	;BYTE PTR.

BAFELB==1	;ERROR LOGICAL BLOCK ADR. WITHIN UNIT - WORD ADR. (WITHIN 2 WORD ENTRY)
		; OF FIRST LOGICAL BLOCK IN BAD REGION OF BLOCKS
REPEAT 0,<	;OLD-STYLE BAT BLOCK ENTRY
BAJCNI==-^D6	;-NO. OF LOW ORDER STATUS BITS WHICH DO NOT CONTAIN
		; INTERESTING CONI ERROR STATUS BITS.
		;LH OF BAFELB IS USED FOR CONI BITS 12 THROUGH 29
		; ON RC-10 AND RP-10 UNITS.  WHEN WE BUILD LARGER
		; UNITS THIS WILL HAVE TO BE CHANGED
>
BAFVER==:1	;BITS 0-2 VERSION NUMBER OF ENTRY (PRESENTLY = 0)
BAFERR==:1	;ERROR BITS (AS OPPOSED TO CONI BITS)
	BAPOTR==:40000	;OTHER (NOT DATA OR SEARCH ERROR)
	BAPDTR==:20000	;DATA ERROR (PARITY OR ECC HARD)
	BAPHDR==:10000	;SEARCH ERROR OR HEADER COMPARE ERROR
	BATMSK==:777000	;MASK (LH) FOR BAT ENTRY BLOCK NUMBER
	MBTMSK==:700777	;MASK FOR JUST ERROR BITS FOR BAT ENTRY
BAFCOD==BLKCOD	;CONTAINS UNLIKELY CODE
		;LH=0
CODBAT==606060	;UNLIKELY CODE FOR BAT BLOCK
BAFSLF==BLKSLF	;LH=0, RH=THIS BLOCK(NOT CLUSTER) AADR. WITHIN UNIT

BRMAX==BAFCOD-BAFREG	;MAX LENGTH OF AREA FOR APPENDING BAD REGIONS
MBRMAX==-BRMAX
	$LOW
SUBTTL	CHN:	CHANNEL DATA BLOCK

;THE RELATIVE LOCATIONS ARE DEFINED IN S.MAC JUST LIKE DEVICE DATA BLOCKS
;THESE LOCATIONS ARE SET, LOOKED AT AND CHANGED
;BY FILSER. DEVICE DEPENDENT MODULES DO NOT LOOK AT THEM.
;PARAMETERS FOR CHNCB:
; S = CHANNEL # (STARTS AT 0), SP1 = NEXT CHANNEL # (IE S+1)

	DEFINE	CHNCB (S,SP1)<
	XLIST

INTERN CHNBSY,CHNECT,CHNQUE,CHNIFP,CHNCFP,CHNIFT,CHNCFT,CHNNUM,CH'S'IFP,CH'S'IFT
INTERN DIFCDQ,CHNRCT,.CHLUE,.CHICW,.CHFCW,.CHCW2,.CHCW1,.CHCW0
INTERN .CHDW2,.CHDW1,.CHDW0,CHB22B,CP.22B
INTERN	CHNIFS,CHNCFS,CHYSCN


IFE FTAUTC,<
INTERN	CHN'S'CB
THSCCB=CHN'S'CB
>
IFN FTAUTC,<
THSCCB==0
>
CHNBSY==0	;;MAKE SURE FIRST ENTRY IN DATA BLOCK ELSE MACRO ERROR
CHN'S'CB:
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	-1	;;-1 IS IDLE, 0 OR POSITIVE IS BUSY
>
		;; MUST BE WORD 0 OF CHN DATA BLOCK
		;; SO AOSG @KONCHN(J) WILL TEST BUSY AND SET
		;; BUSY IN ONE INSTRUCTION
	PHASE	1		;;DEFINE ALL SYMBOLS WITH REPSPECT TO BEGINNING OF
		;; DATA BLOCK.
.CHSYS::!	;;(1) LH=ADR OF NEXT CHANNEL IN SYSTEM OR 0 IF LAST
		;;RH=SEE .CHLUE
.CHLUE:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD CHN'SP1'CB,0 ;;(1) RH=ADR. OF LAST UNIT DB WITH SOFT OR HARD ERROR
>
		;; LH=SEE .CHSYS
.CHICW:!0	;;(2) INITIAL CONTROL WORD ON LAST SOFT OR HARD ERROR
		;; IE CONTENTS OF EVEN LOW CORE WORD
.CHFCW:!0	;;(3) FINAL CONTROL WORD ON LAST SOFT OR HARD ERROR
		;; IE WHAT CHANNEL STORES IN ODD LOW CORE WORD
		;; LH=PRESENT CONTENTS OF CONTROL WORD ADDRESS COUNTER,
		;; RH=PRESENT CONTENTS OF DATA ADDRESS COUNTER
		;; BECAUSE EACH DEVICE HANDLES ERROR TERMINATION DIFFERENTLY
		;;  ON THE CHANNEL, THE SOFTWARE STORES 3 CONTROL WORDS AND
		;; 3 DATA WORDS 'AROUND' THE PROBLEM AREA AS INDICATED
		;; BY THE LH AND RH OF WHAT CHANNEL STORES IN .CHFCW.  NO
		;; ATTEMPT IS MADE BY THE MONITOR TO DETERMINE WHICH OF
		;; THE 3 WORDS IS REALLY THE LAST CONTROL OR DATA WORD.
		;; THAT MUST BE DONE BY THE INVESTIGATING PERSONNEL.
.CHCW2:!0	;;(4) COMMAND WORD -2 ON LAST HARD OR SOFT ERROR
.CHCW1:!0	;;(5) COMMAND WORD -1 ON LAST HARD OR SOFT ERROR
.CHCW0:!0	;;(6) COMMAND WORD ON LAST HARD OR SOFT ERROR
.CHDW2:!0	;;(7) DATA WORD -2 ON LAST HARD OR SOFT ERROR
.CHDW1:!0	;;(10) DATA WORD -1 ON LAST HARD OR SOFT ERROR
.CHDW0:!0	;;(11) DATA WORD ON LAST HARD OR SOFT ERROR
.CHMPE:!0	;;(12) NO. OF MEMORY PARITIES
.CHDPE:!0	;;(13) NO. OF DATA PARITIES (FROM DEVICE)
.CHNXM:!0	;;(14) NO. OF NON-EX MEMS OR DATA LATES (OVER RUN)
.CHCSR:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	CP.PXX!CP.CS0_<-S> ;;(15) LH=BITS TO REQUEST CPU TO SWEEP CORE
>
		;;  ON BEHALF OF CHANNEL N. STORED IN .CPAEF
		;; BY CHN MPE ROUTINE
		;;RH=UNUSED

.CHTCW:!0	;;(16)EXPECTED TERMINATION CONTROL WORD OF LAST ERROR
CHNECT:!0	;;ERROR COUNT SO FAR ON CURRENT DATA TRANSFER SET TO
		;; 0, INCREMENTED, AND TESTED BY FILSER (TO DSKTRY) NOT LOOKED AT BY
		;; INTERRUPT ROUTINE. -1 MEANS UNIT IS RECALIBRATING.
CHNRCT:!0	;;RECALIBRATE ERROR COUNT ON CURRENT DATA TRANSFER
		;; STARTS AT -0 GOES TO RCLTRY. INCREMENTED EVERY
		;; TIME CHNECT COUNTS UP TO DSKTRY.
		;; TOTAL TRIES=DSKTRY*RCLTRY
CHNQUE:!XWD 0,0	;;LH=ADR OF FIRST (LONGEST WAITING) DEVICE DATA
		;; BLOCK(FILE)
		;; WAITING TO DO A DATA TRANSFER (TW QUEUE)
		;; RH=JOB NUMBER FOR DDB WHOSE ADDRSS IS IN LH
		;; BOTH HALVES=0 IF NO FILES WAITING TO TRANSFER,
		;; SO A FAST TEST FOR EMPTY TRANSFER WAIT QUEUE
		;; NOTE - A FILE IN T STATE IS NOT IN TW QUEUE.
DIFCDQ==CHNQUE-DEVQUE	;;DIFF OF HEAD Q PTR AND LINKS - USED TO
			;; START SEARCH OF DDBS IN TRANSFER WAIT Q
IFNDEF CH'S'IFP,<CH'S'IFP==CHVIFP>	;;USE STANDARD IF CUSTOMER HAS NOT
		;; REDEFINED CH'S'IFP WITH MONGEN
CHNIFP:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
IFE M.CH'S'T,<EXP CH'S'IFP>
IFE M.CH'S'T-1,<CP.22B,,CH'S'IFP>
IFE M.CH'S'T-2,<CP.22B!CP.DX1,,CH'S'IFP>
IFE M.CH'S'T-3,<CP.22B!CP.RH2,,CH'S'IFP>
IFE M.CH'S'T-4,<CP.22B!CP.R11,,CH'S'IFP>
IFE M.CH'S'T-5,<CP.22B!CP.LP2,,0>
IFE M.CH'S'T-6,<CP.22B!CP.CD2,,0>
		;;RH=INITIAL FAIRNESS COUNT FOR POSITIONING UNITS
		;; ON THIS CHANNEL AFTER A DATA TRANSFER INTERRUPT.
		;; USED TO SET CHNCFP WHEN IT COUNTS TO 0.  AN
		;; INITIAL VALUE OF 1 (OR 0) REDUCES THE SYSTEM
		;; POSITION ON A FIRST COME, FIRST SERVE BASIS
		;; (RATHER THAN NEAREST POSITION)ALL THE TIME.
>
CHB22B==CHNIFP	;;SIGN-BIT =1 IF A 22-BIT CHANNEL, =0 IF 18 BITS
XP	CP.SWF,1	;;=1 DURING FILIO INTERRUPT SERVICE IF CACHE
			;; SWEEP MUST BE DONE BEFORE INTERRUPT EXIT
XP	CP.22B,400000	;;=1 IF 22-BIT CHAN, =0 IF 18-BIT CHAN
XP	CP.DX1,200000	;;=1 IF DX10 CHAN, = 0 IF OTHER
XP	CP.RH2,100000	;;=1 IF RH20, =0 IF RH10
XP	CP.R11,40000	;;=1 IF RH11, =0 IF NOT
XP	CP.LP2,20000	;;=1 IF LP20, =0 IF NOT
XP	CP.CD2,10000	;;=1 IF CD20, =0 IF NOT
XP	CP.MX,4000	;;=1 IF MULTIPLE XFERS AT SAME TIME (KLIPA DISK)
XP	CP.KLP,2000	;;=1 IF KLIPA, =0 IF NOT
XP	CP.KNI,1000	;;=1 IF KLNI, =0 IF NOT
CHNCFP:!0	;;CURRENT FAIRNESS COUNT FOR POSITIONING UNITS ON
		;; THIS CHANNEL AFTER A DATA TRANSFER INTERRUPT
		;; DECREMENTED BY 1 EACH DATA TRANSFER INTERRUPT
		;; ON THIS CHANNEL.  I.E. NUMBER OF DATA TRANSFER
		;; INTERRUPTS LEFT BEFORE A POSITIONING REQUEST IS
		;; SELECTED ON THE BASIS OF LONGEST WAITING FILE
		;; ("FAIR") RATHER THAN NEAREST (INCLUDING "ON
		;; CYLINDER") ("FAST")
IFNDEF CH'S'IFT,<CH'S'IFT==CHVIFT>	;;USE STANDARD IF CUSTOMER HAS
		;; NOT REDEFINED CH'S'IFT WITH MONGEN
CHNIFT:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	BYTE (9)S(9)0(18)CH'S'IFT ;;INITIAL FAIRNESS COUNT FOR DATA TRANSFERS ON
>
		;; THIS CHANNEL.  USED TO SET CHNCFT WHEN IT COUNTS TO 0.
CHBSCN==CHNIFT	;;SOFTWARE CHANNEL NUMBER - WORD ADDRESS
	CHSSCN==^D9	;;BYTE SIZE
	CHNSCN==^D8	;;BYTE PTR POS.
CHNCFT:!0	;;CURRENT FAIRNESS COUNT FOR DATA TRANSFERS ON
		;; THIS CHANNEL.  DECREMENTED BY 1 EACH DATA
		;; TRANSFER INTERRUPT.  WHEN REACHES 0 A DATA
		;; TRANSFER IS SELECTED ON THE BASIS OF THE LONGEST
		;; WAITING FILE WHICH IS IN POSITION ("FAIR")
		;; RATHER THAN THE SHORTEST LATENCY ("FAST").
CHNIFS:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	3	;;INITIAL FAIRNESS COUNT FOR SWAPPING ON THIS CHANNEL
>
CHNCFS:!0	;;CURRENT FAIRNESS COUNT FOR SWAPPING ON THIS CHANNEL.
		;; DECREMENTED BY 1 EACH TIME A SWAP OR PAGE OPERATION
		;; IS STARTED. A FILE OPERATION IS STARTED IF THIS COUNT IS
		;; NEGATIVE AND FILE IO IS PENDING

CHNNUM:!0	;;RH=NUMBER OF 128 WORD BLOCKS BEING TRANSFERRED
		;; ON THIS CHANNEL ON THE CURRENT TRANSFER.  SETUP AT
		;; SAME TIME AS CHANNEL COMMAND LIST.  NOT CLEARED AT END
		;; OF TRANSFER SO GOOD FOR LOOKING AT IN LIGHTS.
		;; LH=-1 ON ERROR, SO WORD IS NON-ZERO EVEN IF RH=0
CHNQUL:: 0	;;LENGTH OF TRANSFER WAIT QUEUE
CHNTCW::0	;;EXPECTED TERMINATION CONTROL WORD
		;;USED TO CHECK FOR ABNORMAL CHANNEL TERMINATION WITHOUT
		;;ERROR INDICATIONS FROM CONTROLLER

CHNCUA::!0	;;CURRENT UNIT ACTIVE ON CHANNEL
IFN FTKS10,<
CHNUBA::!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
			;;UNIBUS ADAPTER STATUS REGISTER ADDRESS
			;;FORMAT:	XWD UBA #,,UNBSTW
IFE M.CH'S'T-4,<		;;IF THIS CHANNEL IS AN RH11
	 IFG M.'S'RH,<		;;IF THIS IS THE DISK CHANNEL
		<RH11CA&7000000>+UNBSTW
	  >
	 IFG M.'S'TR,<		;;IF THIS IS THE TAPE CHANNEL
		<RH21CA&7000000>+UNBSTW
	  >
	>;END IFE M.CH'S'T-4
IFE M.CH'S'T-5,<		;;IF THIS CHANNEL IS AN LP20
		<LP11CA&7000000>+UNBSTW
	>;END IFE M.CH'S'T-5
IFE M.CH'S'T-6,<		;;IF THIS CHANNEL IS A CD20
		<CD11BA&7000000>+UNBSTW
	>;END IFE M.CH'S'T-6
>
CHNIMR::!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
			;;ADDRESS OF INITIAL MAPPING REGISTER FOR THIS
			;;DEVICE ON THIS "CHANNEL"
IFE M.CH'S'T-4,<		;;IF THIS CHANNEL IS AN RH11
	 IFG M.'S'RH,<		;;IF THIS IS THE DISK CHANNEL
		RH1IMR##
	  >
	 IFG M.'S'TR,<		;;IF THIS IS THE TAPE CHANNEL
		RH2IMR##
	  >
	>;END IFE M.CH'S'T-4
IFE M.CH'S'T-5,<		;;IF THIS CHANNEL IS AN LP20
		LP0IMR##
	>;END IFE M.CH'S'T-5
IFE M.CH'S'T-6,<		;;IF THIS CHANNEL IS A CD20
		CD0IMR##
	>;END IFE M.CH'S'T-6
>
CHNMRC::!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
			;;NUMBER OF MAPPING REGISTERS AVAILABLE TO THIS DEVICE
			;;ON THIS "CHANNEL"
IFE M.CH'S'T-4,<		;;IF THIS CHANNEL IS AN RH11
	 IFG M.'S'RH,<		;;IF THIS IS THE DISK CHANNEL
		RH1MRC##
	  >
	 IFG M.'S'TR,<		;;IF THIS IS THE TAPE CHANNEL
		RH2MRC##
	  >
	>;END IFE M.CH'S'T-4
IFE M.CH'S'T-5,<		;;IF THIS CHANNEL IS AN LP20
		LP0MRC##
	>;END IFE M.CH'S'T-5
IFE M.CH'S'T-6,<		;;IF THIS CHANNEL IS A CD20
		CD0MRC##
	>;END IFE M.CH'S'T-6
>
CHNIEA::!0		;;INITIAL ELEVEN STYLE ADDRESS FOR CURRENT TRANSFER
CHNBTC::!0		;;ELEVEN STYLE BYTE COUNT FOR CURRENT TRANSFER
CHNNXF::!0		;;NO-XFER FLAG-- 0=NORMAL XFER, -1 NO-XFER
			;;NO XFER REQUESTS COME DOWN FROM FILSER WHEN
			;;IT WANTS TO READ A BLOCK BUT DO NO DATA XFER ANYWHERE
			;;TO VERIFY THAT A PARTICULAR BLOCK IN FACT HAS ERRORS
CHNDBF::!0		;;DUMMY 1-WORD BUFFER FOR BUS ADDRESS INHIBIT USAGE
			;; IN RHXKON (READ A SECTOR, BUT XFER NO DATA)
CHNRRV::!0		;;READ REVERSE FLAG: 0=NORMAL, -1=READ REVERSE OPERATION
>;END IFN FTKS10
IFN FTKL10,<
CHNRSC::!0		;;NUMBER OF TIMES THAT WE HAVE RESTARTED A DX20
			;;ON THIS CHANNEL
CHNPCB::!0		;;ADDRESS OF PORT CONTROL BLOCK IF IPA TYPE CHANNEL
CHNBTS::!0		;;BITS TO TEST FOR ON AN INTERRUPT
>
	LENKTB==:20	;;LENGTH OF TABLE OF KONTROLLERS ON THIS CHANNEL
CHNTBP::!		;;AOBJN POINTER TO KONTROLLERS ON THIS CHANNEL
IFN FTAUTC,<0>
IFE FTAUTC,<
	-1,,CHN'S'CB+CHNKTB
>; END IFE FTAUTC
CHNKTB::!BLOCK	LENKTB	;;ENOUGH FOR LOTS OF KDBS FOR THIS CHN
	DEPHASE
IFE FTAUTC,<
$C==1

REPEAT C'S'FHN,<
KONTCB	FH,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$FHNUM==$FHNUM+1>

REPEAT C'S'FSN,<
KONTCB	FS,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$FSNUM==$FSNUM+1>

REPEAT C'S'RPN,<
KONTCB	RP,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$RPNUM==$RPNUM+1>

REPEAT C'S'RNN,<
KONTCB	RN,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$RNNUM==$RNNUM+1>

IFNDEF C'S'RAN,<C'S'RAN==0>
REPEAT C'S'RAN,<
KONTCB	RA,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$RANUM==$RANUM+1>

REPEAT C'S'DPN,<
KONTCB	DP,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$DPNUM==$DPNUM+1>

REPEAT C'S'MDN,<
KONTCB	MD,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$MDNUM==$MDNUM+1>

IFN FTKS10,<
REPEAT C'S'RHN,<
KONTCB	RH,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>,S
$RHNUM==$RHNUM+1>
>

$CM1==$C-1
CHNCLS (\"<$CM1+"A">,S)
>	;END IFN FTAUTC
	LIST
>	;END MACRO DEF OF CHNCB

	$HIGH
;;BYTE POINTERS
CHYSCN::POINT	CHSSCN,CHBSCN(P1),CHNSCN ;;SOFTWARE CHANNEL NUMBER
	$LOW
REPEAT 0,<
A SERIES OF MACROS ARE INCLUDED HERE FOR GENERATING CHANNEL, KONTROLLER,
AND UNIT CORE BLOCKS.  THE VARIOUS CORE BLOCKS ARE LINKED TOGETHER
APPROPRIATELY; THE NUMBER OF EACH TYPE AND APPROPRIATE LINKAGE ARE
DETERMINED BY SYMBOLS GENERATED BY MONGEN.  SYMBOLS GENERATED ARE:

	CHNN	TOTAL NUMBER OF DATA CHANNELS (DF10) FOR DISKS
		CHANNELS ARE NUMBERED FROM 0 TO CHNN - 1

	CNFH	NUMBER OF FIXED HEAD KONTROLLERS ON CHANNEL N
	CNDP	NUMBER OF DISK PACK KONTROLLERS ON CHANNEL N
	CNMD	NUMBER OF MASS FILE (BRYANT DISK) KONTROLLERS ON CHANNEL N

		KONTROLLERS OF EACH TYPE ARE LETTERED A,B,C, ETC., SO
		THE FIRST DISK PACK KONTROLLER IS DPA, THE SECOND DPB, ETC.

	XXYUN	NUMBER OF UNITS ON KONTROLLER XXY

THE CHNCB MACRO GENERATES A CHANNEL CORE BLOCK, THEN CALLS MACROS TO
GENERATE KONTROLLER AND UNIT CORE BLOCKS.  ITS ARGUMENT IS THE CHANNEL NUMBER,
IN ASCII.  CHNCB CALLS MACRO KONTCB FOR EACH KONTROLLER ON THE CHANNEL.  THERE
IS A REPEAT LOOP FOR EACH KONTROLLER TYPE, REPEATED CNXX TIMES, WHERE N IS THE
CHANNEL NUMBER AND XX IS THE KONTROLLER TYPE, EACH LOOP CALLING KONTCB ONCE.
THE ARGUMENTS FOR KONTCB ARE THE KONTROLLER TYPE, A LIST CONTAINING THE LETTERS
TO IDENTIFY SUCCESSIVE KONTROLLERS, AND THE CHANNEL NUMBER, IN ASCII.

KONTCB FIRST CALLS MACRO XXKON TO GENERATE A KONTROLLER CORE BLOCK FOR THE
KONTROLLER, THEN REPEATS XXYUN TIMES CALLING UNITCB MACRO TO GENERATE UNIT CORE
BLOCKS FOR THE KONTROLLER.  ARGUMENTS FOR XXKON ARE KONTROLLER TYPE (XX),
KONTROLLER IDENTIFIER, AND THE ASCII VALUE OF SYMBOL XXNUM, WHICH IS INCREMENTED
FOR EACH KONTROLLER OF TYPE XX.  XXKON FORMS SYMBOL XX'XXNUM (XX0, XX1, ...),
WHICH IS USED AS THE DEVICE CODE FOR THE KONTROLLER.  ARGUMENTS FOR UNITCB
INCLUDE KONTROLLER TYPE, KONTROLLER IDENTIFIER, UNIT NUMBER, AND SYMBOLS TO USE
IN LINKING THE UNIT CORE BLOCKS TOGETHER (SEE UNITCB MACRO).

EACH XXKON MACRO SHOULD CALL THE KONKON MACRO FOR THE KONTROLLER INDEPENDENT
PART OF THE KONTROLLER CORE BLOCK.  ARGUMENTS FOR KONKON MACRO ARE KONTROLLER
TYPE (XX), KONTROLLER IDENTIFIER (Y), AND SYMBOL XX'NUM WHICH IS THE DEVICE CODE
FOR THE KONTROLLER.  NUM IS INCREMENTED FOR EACH KONTROLLER OF TYPE XX.

THE UNIT CORE BLOCKS ARE LINKED IN THREE DIFFERENT WAYS.  ALL UNIT CORE
BLOCKS ON A KONTROLLER ARE LINKED IN A RING (THE LAST POINTS TO THE FIRST),
ALL UNIT CORE BLOCKS ON A CHANNEL ARE LINKED IN A RING, AND ALL UNIT CORE
BLOCKS IN THE SYSTEM ARE LINKED IN A LIST (THE LAST LINK IS 0).  TO
COMPLETE THIS LINKAGE, KONTCB CALLS MACRO KONCLS TO CLOSE THE KONTROLLER
RING, AFTER ALL UNIT CORE BLOCKS FOR THAT KONTROLLER HAVE BEEN GENERATED; CHNCB
CALLS CHNCLS TO CLOSE THE CHANNEL RING; AND AFTER ALL SYSTEM UNIT CORE BLOCKS
HAVE BEEN GENERATED, SYSCLS IS CALLED TO TERMINATE THE SYSTEM LIST.

TO ADD ANOTHER KONTROLLER TYPE XY, YOU MUST ADD ANOTHER REPEAT LOOP IN CHNCB,
REPEATING CNXY TIMES AND PASSING ARGUMENT XY TO KONTCB MACRO.  KONTCB
CALLS MACRO XYKON FOR THE KONTROLLER DEPENDENT PART OF THE KONTROLLER CORE
BLOCK; THAT MUST ALSO BE SUPPLIED.  XYKON SHOULD CALL THE KONKON MACRO FOR
THE KONTROLLER INDEPENDENT PART OF THE KONTROLLER CORE BLOCK.
>
SUBTTL	DEV:	DEVICE DATA BLOCK (ONE FOR EACH ACTIVE SOFTWARE USER CHANNEL)

EXTERN	DSKDSP
INTERN DEVNAM,DEVCHR,DEVIOS,DEVSER,DEVMOD,DEVLOG,DEVBUF,DEVIAD,DEVFSN
INTERN FNCEXC,FNCRED,FNCALL,FNCDLL,FNCAPP,FNCUPD,FNCCRE
INTERN FNCSUP,FNCTRN,FNCCAT,FNCDEL,FNCCNM,FNCCPR,DEVLPC,DEPLPC,SWPDMP
INTERN DEVOAD,DEVDMP,DEVRET,DEVREL,DEVACC,DEVUNI,DEVSWP,DEPSWP,SWPBLK
INTERN DEVQUE,DEVRIB,MINDVQ,DEVBLK,DEVRSU,DEVFLR,DEVLFT,DEVUFB
INTERN PTRLEN,MPTRLN,DEVRB1,DEVRB2,DEVRBN,DEYCOD,DEYRLC,DEYFSN,DEYFNC
INTERN DSKDDB,DDBLEN,SWPDDB,DEVFUN,DEVFAK,DEYRBU,DEYRBA,DEYRBC
INTERN DEVPRI,DEVUVA,DEVLRL,DEVWRT,DEPWRT,DEVCPT,DEPCPT,PINBFN

	INTERN DEVSFD,DEYSCN,DEVLIB,DEPLIB

	$HIGH
DSKDDB:			;ADDRESS OF PROTOTYPE DISK DDB FOR SYSTEM.
			; LINKED TO DDB LIST BUT NEVER USED.
			; (SWPDDB IS LINKED BEFORE DSKDDB)

ZERO13==0
$SWAP==0
REPN==1
IFN SYS50N,<REPN==2>

;REPEAT INSTEAD OF A MACRO SO SYMBOLS WILL BE EASIER TO FIND IN CREF LISTING


REPEAT REPN,<


;FIRST COPY IS DISK PROTOTYPE DDB, SECOND IS SWAPPING DDB (SIGN BIT ON IN DEVSWP)
IFN $SWAP, <XLIST>	;DO NOT LIST THE SWAPPING DDB. IT IS REPETITIVE

PHASE	0
IFE $SWAP, <

DEVNAM:!SIXBIT	/DSK/	;DEVICE NAME IN SIXBIT OF STR OR MORE USUALLY GENERIC DSK
>
IFN $SWAP, <
DEVNAM:!SIXBIT	/SWAP/	;DIFFERENT "DEVICE NAME" FOR SWAPPER
>
DEVCHR:!XWD 3*HUNGST,201 ;HUNG TIME COUNT, BUFFER SIZE
DSKTIM==:7		;HUNG TIME (STORED IN UDB, DEC'D EVERY SECOND)
DEVIOS:!0		;LH=MONITOR, RH=USER IO STATUS-SEE FILSER FOR
			; LH BIT DEFINITIONS SINCE LOADER WILL NOT ADD EXTERNS
DEVSER:!EXP DSKDSP	;LH=LINK TO NEXT DDB, RH=DISPATCH TABLE ADDRESS
			; IN FILSER SAME FOR ALL DISKS
DEVMOD:!XWD DVIN+DVOUT+DVDSK+DVDIR+DVLNG,154403 ;LH=CHARACTERISTICS, RH=MODES
DEVRHB==:DEVMOD		;WHOLE WORD ZERO IF REREADING HOME BLOCKS ON POWER UP INTERRUPT
DEVLOG:!0		;LOGICAL NAME IN SIXBIT
DEVBUF:!0		;LH=OUTPUT BUFFER HEADER, RH=INPUT BUFFER HEADER

DEVIAD:!0		;BIT 13=0,BITS 14-17=R, RH=POINTER TO USER INPUT BUFFER

DEVCOD==DEVIAD		;FILE STATUS CODE (I,SW,S,PW,P,TW,T)-WORD ADR
			; SEE UNISTS FOR DEFINITION
	DESCOD==^D3		;BYTE SIZE
	DENCOD==^D2		;BYTE PTR POS.
DEVLPC==DEVIAD		;BIT WHICH SAYS LAST RIB POINTER IS IN CORE
	DESLPC==^D1	;BYTE SIZE
	DENLPC==^D4	;BYTE POSITION
	DEPLPC==20000	;BIT
DEVSCN==DEVIAD		;SCANNING SWITCH FOR SFD'S
	DESSCN==^D1	;BYTE SIZE
	DENSCN==^D3	;POSITION
DEVFNC==DEVIAD		;HIGHEST FUNCTION THIS USER ALLOWED TO PERFORM ON THIS FILE
			; SET BY CHKPRV ROUTINE
	DESFNC==^D4		;BYTE SIZE
	DENFNC==^D8		;BYTE PTR POS.
			; FUNCTION CODES ARE DEFINED IN ORDER OF INCREASING POWER
			; 0 - MEANS CHKPRV HAS NOT STORED ANY FUNCTION YET
	FNCEXC==1		;EXECUTE ONLY
	FNCRED==2		;READ
	FNCALL==3		;ALLOCATE
	FNCDLL==4		;DEALLOCATE
	FNCAPP==5		;APPEND
	FNCUPD==6		;UPDATE
	FNCCRE==7		;CREATE
	FNCSUP==10		;SUPERSEDE
	FNCTRN==11		;TRUNCATE
	FNCCAT==12		;CHANGE ATTRIBUTES(EXCEPT PRIVILEGE,NAME,DIR)
	FNCDEL==13		;DELETE
	FNCCNM==14		;CHANGE NAME
	FNCCPR==15		;CHANGE PRIVILEGE
DEVEUN==DEVIAD	;LOGICAL UNIT WITHIN STR ON WHICH ERROR REGION - WORD ADR
	DESEUN==^D4		;BYTE SIZE
	DENEUN==^D12		;BYTE PTR. POS.
DEVOAD:	BYTE	(1)$SWAP(8)0(4)0(1)ZERO13(4)0(18)0
			;BIT 13=0, RH=POINTER TO USER OUTPUT BUFFER
DEVSWP==DEVOAD		;SIGN BIT = 1 FOR SWAPPING DDB
	DEPSWP==400000
DEVLIB==DEVOAD		;BIT ON IF LOOKUP FROM LIB/SYS
	DEPLIB==200000	;THE BIT
DEVRLC==DEVOAD		;RELATIVE ADDRESS (0-127) WITHIN 128 WORD RIB OF FIRST
			; RETRIEVAL POINTER IN DDB (DEVRB1 OR DEVRB1+1)-WORD ADR.
	DESRLC==^D7		;BYTE SIZE
	DENRLC==^D8		;BYTE PTR.POS.
DEVUWZ==:DEVOAD		;USE TO WRITING ZEROES - WORD ADDR
	DEPUWZ==:400	;BIT G=1 IF MONWRT CALLED FROM USETZ

DEVPP0==:DEVOAD		;E+3 WAS 0 ON LOOKUP - WORD HDR
	DEPPP0==:200	;BIT=0 IF E+3 WAS 0
	DESPP0==1
	DENPP0==^D10

DEVFDA==:DEVOAD		;FILE DAEMON SHOULD BE CALLED ON CLOSE
	DEPFDA==:100	;BIT=1 IF FILE DAEMON SHOULD BE CALLED ON CLOSE
DEVSTS:!0		;WORD FOR DEVICE CONI
IFE $SWAP,<
DEVSTA:!XWD	.TYDSK,DEPEVM
>
IFN $SWAP,<
DEVSTA:!XWD	<TYPMAX+1>*.TYEST,DEPEVM  ;NOT A LEGAL DEVICE TYPE
>

DEVCPT==DEVSTA		;READ FILE IN 10/11 COMPATABILITY MODE
	DEPCPT==200000	;THE BIT
DEVXTR:!0

DEVUVA==DEVXTR		;LH = USER VIRT ADR OF CHKSUM WORD
			;BITS 18-20 UNUSED (PREVIOUSLY SFD LEVEL)
DEVWRT==DEVXTR		;THIS DDB IS WRITING (UPDATING)
	DEPWRT==40000	;THE BIT
DEVBFN==DEVXTR		;NUMBER OF INPUT BUFFERS
	DESBFN==^D9	;BYTE SIZE
	DENBFN==^D30	;POSITION
DEVPAL==:DEVXTR		;PRE-ALLOCATE FILE
	DEPPAL==:20	;BIT 31=1 IF PRE-ALLOCATE
DEVALC==:DEVXTR		;DON'T CHANGE ACCALC WHEN GIVING UP BLOCKS OF A FILE
			; (FORMERLY IOSALC IN S, DEVIOS)
	DEPALC==:10	;BIT 32=1 IF DON'T CHANGE
			;BITS 33-35 UNUSED (PREVIOUSLY 2ND SFD LEVEL)
DEVEVM:!0
DEVPSI:!0
DEVESE:!0		;EXTENDED SOFTWARE ERROR STATUS
DEVHCW:!0		;HARDWARE CHARACTERISTICS WORD
DEVCPU::!707000,,0	;MULTI-CPU INFORMATION. Q-PROTOCOL 1
DEVISN:!0		;RH = SECTION NUMBER FOR CURRENT I/O OPERATION
DEVJOB:!0		;JOB NUMBER AND UNIT NUMBER
DEVFSN==DEVJOB		;OLD FILE STRUCTURE NUMBER (LAST LOOKUP OR ENTER)
			; USED ON SUPERSEDING FILE AT CLOSE TIME
	DESFSN==:.FSSIZ	 ;BYTE SIZE
	DENFSN==^D17	 ;POSITION
DEVLLE==:DEVJOB		;LIB HANDLING ON LOOKUP/ENTER
	DEPDSL==:1000	;(LH) DONT SEARCH LIB
	DEPAUL==:2000	;(LH) ALLOW UPDATE IN LIB
DEVFCU==:DEVJOB		;FILDEA HAS READ COUNT UP
	DEPFCU==:4000	;(LH) BIT ON IF AT COUNT IS UP
DEVNLB==:DEVLLE		;NO LOAD BALANCING ON ENTER
	DEPNLB==:10000	;DON'T BALANCE IF ON
DEVFIL:!0		;OLD FILE NAME (LAST LOOKUP OR ENTER) - ARG TO FNDFIL
DEVEXT:!XWD 0,0		;LH=OLD FILE EXTENSION (LAST LOOKUP OR ENTER) -ARG TO FNDFIL
DEVLFT==DEVEXT		;RH=+NO. OF BLOCKS LEFT IN CURRENT GROUP
			; DECREMENTED AT DATA DONE INTERRUPT
DEVPPN:!0		;OLD DIRECTORY NAME (PROJ,R) -NOT ARG TO FNDFIL
IFN FTKL10&FTMP,<
DEVNBF:!0		;NO OF BUFS SWEPT FOR
DEVSBF:!0		;COPY OF DEVNBF
DEVCSN:!0		;SWEEP SERIAL NO
>
DEVDMP:!0		;CURRENT IOWD FOR DUMP MODE OPERATIONS(CURRENT GROUP ONLY)
			; (MAYBE SMALLER THAN ONE OF USER'S IOWD
			;  IF BLOCKS AREN'T CONTIGUOUS)
			; OR CURRENT IOWD FOR MONITOR IO(EXEC ADDRESSES)
			;  SEE MONRED,MONWRT WHICH PUSH DEVDMP BEFORE USING
			; OR LOGICAL DISK ADR. WITHIN UNIT OF DIRECTORY RIB(MFD OR UFD)

DEVRET:!XWD ZERO18,0	;RH=CORE  ADR IN DDB OF CURRENT RETRIEVAL POINTER
			;BITS 0-17=0 FOR CAI TESTING
DEVREL:!0		;RELATIVE BLOCK NUMBER WITHIN FILE TO BE READ OR
			; WRITTEN ON NEXT INPUT OR OUTPUT UUO
INTERN DEVDIA
DEVDIA==DEVREL		;DATA FOR DIAG. UUO

DEVUNI:!XWD 0,0		;LH CORE ADR. OF ORIGINAL UNIT DATA BLOCK(I.E. WHERE RIB IS)
			;RH=CORE ADR.(UPWARD PNTR) TO CURRENT UNIT DATA BLOCK
			;DEVUNI IS CLEARED WHEN A F/S IS BEING REMOVED
			; (STRUUO(.FSREM)).  THE UNIT (RH DEVUNI) IS
			; IS REMEMBERED IN DEVFUN.
DEVUFB:!XWD ZERO18,0	;RH=ADDR.(UPWARD POINTER) OF UFD
			; DATA BLOCK THIS FILE IS IN
DEVSFD:!XWD 0,0		;RH=LOC OF NMB FOR FATHER SFD IF FILE IS IN AN SFD
			;LH IS USED IN RENAMING ACCROSS DIRECTORIES
DEVBLK:!0		;THE LOGICAL BLOCK NUMBER WITHIN UNIT NEXT TO BE READ OR
			; WRITTEN BY AN INPUT OR OUTPUT UUO.  UPDATED
			; AFTER (RATHER THAN BEFORE) A SUCCESSFUL DATA
			; TRANSFER AT INTERRUPT LEVEL.
DEVRSU:!XWD 0,0		;LH=NEG. NO. OF RETRIEVAL POINTER POSITIONS TO GO IN
			; RETRIEVAL BLOCK BEFORE RETRIEVAL BLOCK IS FULL
DEVACC==DEVRSU		;RH=CORE ADDR (UPWARD PTR) TO ACCESS TABLE ENTRY
			; FOR THIS USER CHAN.
DEVFLR:!0		;FLOOR FOR RETRIEVAL POINTERS IN-CORE
			;I.E., THE FIRST RELATIVE BLOCK WITHIN FILE WHICH
			; FIRST IN-CORE RETRIEVAL POINTER POINTS TO
DEVFUN:!XWD 0,0		;RH=UNIT DATA BLOCK ADR. OF FIRST RETRIEVAL POINTER IN CORE
			;RH DEVUNI STORED HERE WHEN F/S BEING REMOVED
			; (STRUUO(.FSREM)).
DEVPTB==:DEVFUN		;LH = BITS
 DEPFFS==:400000	;FILE FOUND BY SCANNING SFDS
 DEPFFL==:200000	;FILE FOUND IN LIB OR SYS
 DEPUWL==:100000	;WRITE LOCK
DEVQUE::!0		;LH=ADDRESS OF NEXT DDB IN EITHER SEEK/POSITION
			; WAIT QUEUE OR TRANSFER WAIT QUEUE DEPENDING
			; ON WHICH QUEUE THIS FILE IS ON
			;RH=JOB NUMBER OF DDB WHOSE ADDRESS IS IN LH
			;DEVQUE=0 WHEN DDB IS LAST IN QUEUE - ALSO
			;FOR SAFETY, DEVQUE IS SET 0 WHEN FILE IS IN NEITHER QUEUE
MINDVQ==-DEVQUE		;MINUS DEVQUE
	INTERN DEVELB
DEVELB:!0		;FIRST LOGICAL BLOCK OF AN ERROR REGION
			;BITS 3-8 HAVE ERROR CODE

DEVPRI:!0		;RH = DISK PRIORITY
DEVLRL==DEVPRI		;LAST DEVREL (USED FOR USETO-1
			; AFTER UPDATE ENTER)
IFN FTSPL,<
DEVSPN::!0		;ENTERED FILENAME FOR SPOOLED FILE
DEVSPM::!0		;POINTER TO SPOOLING PARAMETER BLOCK
>
DEVRIB:!0		;UNIT, ADDRESS AND COUNT OF CURRENT RIB

			;BIT 0=1 IF AN EXTENDED RIB
 DESRBC==^D8		;COUNT OF RIBS, BYTE SIZE
 DENRBC==^D8		;BYTE POSITION, POINTER IS DEYRBC
 DESRBU==^D4		;LOGICAL UNIT WITHIN STR, BYTE SIZE
 DENRBU==^D12		;BYTE POSITION, POINTER IS DEYRBU
 DESRBA==^D23		;CLUSTER ADDRESS, BYTE SIZE
 DENRBA==^D35		;BYTE POSITION, POINTER IS DEYRBA

DEVUPP::!0		;"IN YOUR BEHALF" PPN


DEVCUR::!0		;(RH) CURRENT UNIT DOING IO FOR THIS DDB
DEVRAD==:DEVCUR		;RENAME ACROSS DIRECTORIES IN PROGRESS
 DEPRAD==:400000	;BIT=1 IF RENAME
DEVPRV==:DEVCUR		;DONT CHECK PRIVS ON LOOKUP
 DEPPRV==:200000	;BIT=1 IF DONT CHECK
 DEVRRC==:DEVCUR	;AUTO-REWRITE OF RIB ON CHANGE
 DEPRRC==:100000	;BIT ON IF ENABLED
 DEPRHC==:40000		;BIT ON IF RIB HAS CHANGED
DEVPHO==:DEVCUR		;PHYSICAL-ONLY OPEN
 DEPPHO==:20000		;BIT=1 IF PHONLY ON IN INIT
DEVLBF==:DEVCUR		;USER WANTS LARGE BUFFERS
 DEPLBF==:10000		;BIT=1 IF MAKE LARGE BUFFERS
DEVNB1==DEVCUR		;NUMBER OF BLOCKS WE'RE DOING IN 1ST BUFFER
DEVNBB==DEVCUR		;NUMBER OF BLOCKS PER BUFFER
 DESNBB==^D6		;BYTE SIZE (MAX BUFFER IF 17600 WORDS)
 DENNBB==^D17		;BYTE POSITION, POINTER IS DEYNBB
 DENNB1==^D11		;BYTE POSITION FOR DEVNB1, POINTER IS DEYNB1

DEVGEN::!0		;LH=GENERATION NUMBER OF UDB WHICH DDB IS CONNECTED TO
DEVCPY==:DEVGEN		;RH=ADDRESS OF CORE-COPY OF RETRIEVAL POINTERS (OR 0)
DEVLNM::!0		;RH=LOC OF LOGICAL NAME SPEC WE ARE USING
			;LH=CURRENT SFD WE'RE LOOKING FOR IN THAT SPEC
DEVCFS::!0		;RH CFP SUPPLIED ON LOOKUP
			;LH=BITS. BIT 17=1 IF PROGRAM CAN SUPPLY CFPS
DEPCFS==:1

DEVRB1:!0		;FIRST RETRIEVAL POINTER GOES HERE IN DDB

;EACH (REAL) RETRIEVAL POINTER CONSISTS OF THREE FIELDS:
;	A. CLUSTER COUNT
;	B. CHECKSUM OF FIRST CHKNUM WORDS IN FIRST BLOCK OF GROUP
;	C. CLUSTER ADDRESS (23 BITS MAX.)

;THE WIDTHS OF THESE FIELDS ARE DIFFERENT FOR EACH FILE STRUCTURE
;	A. STRCNP
;	B. STRCKP
;	C. STRCLP

;IF THE CLUSTER COUNT IS 0, THE POINTER IS NOT A REAL POINTER
;IT MAY BE EITHER:
;	A. A NEW UNIT WITHIN THE FILE STRUCTURE(IF BIT 18 =1)
;	   BITS 19-35 SPECIFY THE LOGICAL UNIT WITHIN FILE STRUCTURE
;	B. AN EOF FLAG IF WHOLE WORD IS 0

	MPTRLN==-PTRLEN	;- NO. OF POINTERS KEPT IN CORE

DEVRB2:!0		;SECOND RETRIEVAL POINTER
	BLOCK	PTRLEN-3	;IN-CORE RET. PTRS HERE 3,4,...RBN-1
DEVRBN:!0		;LAST RETRIEVAL PTR IN CORE


DEVFAK==DEVRBN-4	;TEMP BLOCK FOR SPOOL-MODE ENTER
IFN FTCIDSK,<
DEVDRB::!0		;ADDR OF THE IORB
;THIS WORD IN SWPDDB IS VERY VERY SPECIAL (IT MUST BE CAREFULLY
;INTERLOCKED). A DEVICE DRIVER THAT DOES NOT DO MULTIPLE XFERS
;MAY NOT READ OR WRITE THIS WORD AT ANY TIME. A DEVICE DRIVER
;THAT DOES DO MULTIPLE XFERS MAY READ AND WRITE THE WORD, BUT
;IT MUST HAVE THE SWPSCN INTERLOCK.
;IT IS NOT SUFFICIENT TO MERELY DISABLE DISK INTERRUPTS.
;FOR ALL OTHER DDBS THERE ARE NO RESTRICTIONS. ANY DEVICE DRIVER
;MAY READ OR WRITE THE WORD, AND NO INTERLOCK IS REQUIRED.
>
DDBLEN==:.-DEVNAM	;LENGTH OF DSK DDB IN WORDS

DEPHASE
	$LOW

$SWAP==1		;SECOND TIME THROUGH THE REPEAT PRODUCES SWPDDB

LIST
>	;END REPEAT REPN

SWPDDB=.-DDBLEN		;ADDR OF SWAPPING DDB
			;SYSINI LINKS SWPDDB INTO
			; SYSTEM DEVICE LIST IN FRONT OF THE PROTOTYPE
			; DSKDDB.  ONLY HUNG TIMEOUT USES SWPDDB
SWPDMP=SWPDDB+DEVDMP	;IOWD FOR SWAPPER
SWPBLK=SWPDDB+DEVBLK	;BLOCK NUMBER FOR SWAPPER
IFN FTCIDSK,<
;DEFINE THE FORMAT OF A DISK I/O REQUEST BLOCK (DRB)

	ZZ==.			;SAVE RELOCATION
	LOC	0		;DEFINE DRB ENTRIES AS OFFSETS FROM ZERO
DRBLNK::!BLOCK	1		;LINK WORD
DRBGOD::!BLOCK	1		;VALUE RETURNED BY CTGOOD
DRBNUM::!BLOCK	1		;CHNNUM
DRBPRG::!BLOCK	1		;CHANNEL PROGRAM
DRBDMP::!BLOCK	1		;KONDMP
DRBBLK::!BLOCK	1		;UNIBLK
DRBCUR::!BLOCK	0		;LH=DEVCUR
DRBCDA::!BLOCK	1		;RH=UNICDA
DRBSWA::!BLOCK	1		;UNISWA (SWAPPER ONLY)
				;(BITS 0-14) UNUSED
DRBCPU::!BLOCK	0		;(BITS 15-17) CPU (SWAPPER ONLY, OTHERS USE DEYPCL)
	DRSCPU==3
	DRNCPU==^D17
DRBSTS::!BLOCK	0		;(BITS 18-22) KONERM
IF2 <IFN <KONERM-770000>,<PRINTX ?KONERM OVERFLOW>>
				;(BITS 23-24) UNUSED
	DRPTRY==:1B25		;(SWAPPER ONLY) PLS TRY AGAIN, IT'S OFF-LINE
	DRPNFI==:1B26		;NOT FILLED IN YET
	DRMDFM==:DRPTRY+DRPNFI	;DON'T FIND ME
DRBJOB::!BLOCK	1		;(BITS 27-35) UNIJOB
	DRSJOB==^D9
	DRNJOB==^D35
DRBTIM::BLOCK	1		;HUNG TIMER
DRBOPC::BLOCK	1		;RH=OPCODE
DRBBHD::BLOCK	1		;BUFFER NAME
DRBCRF::BLOCK	1		;COMMAND REFERENCE NUMBER
	SIZDRB==:.		;SIZE OF A DISK I/O REQUEST BLOCK
	RELOC	ZZ		;DON'T WASTE ANY SPACE

	$LOW
ACTDRB::XWD	ACTDRB-DRBLNK,ACTDRB-DRBLNK;DOUBLY LINKED LIST OF ACTIVE DRBS

	$HIGH
DRYJOB::POINT	DRSJOB,DRBJOB(T1),DRNJOB
DRZJOB::POINT	DRSJOB,DRBJOB(P3),DRNJOB
DRYCPU::POINT	DRSCPU,DRBCPU(T1),DRNCPU
DRZCPU::POINT	DRSCPU,DRBCPU(P3),DRNCPU
>; END FTCIDSK
	$HIGH
;BYTE POINTERS TO FIELDS IN DEVICE DATA BLOCK
DEYCOD:	POINT	DESCOD,DEVCOD(F),DENCOD	;FILE STATUS CODE - I,SW,S,PW,P,TW,T1
DEXCOD::POINT	DESCOD,DEVCOD(T2),DENCOD

DEYRLC:	POINT	DESRLC,DEVRLC(F),DENRLC	;RELATIVE ADR (0-127) WITHIN 128 WORD RIB OF
				       ; 1ST RETRIEVAL PTR IN DDB(DEVRB1 OR DEVRB1+1)
DEYFSN:	POINT	DESFSN,DEVFSN(F),DENFSN	;OLD FILE STRUCTURE NUMBER (0-15 OCTAL)
				       ; SET ON LAST LOOKUP OR ENTER
				       ; USED AT CLOSE TIME WHEN SUPERSEDING
DEYFNC:	POINT	DESFNC,DEVFNC(F),DENFNC	;HIGHEST FUNCTION THIS USER IS ALLOWED TO DO ON
				       ; THIS FILE, SET BY CHKPRV ON FIRST CALL
	INTERN	DEYEUN
DEYEUN:	POINT	DESEUN,DEVEUN(F),DENEUN	;LOGICAL UNIT WITHIN STR OF
					;ERROR REGION(0... )
DEYELB::POINT	27,DEVELB(F),35		;POINTER TO ERROR BLOCK WITHIN UNIT

DEYRBU:	POINT DESRBU,DEVRIB(F),DENRBU	;LOGICAL UNIT NUMBER OF CURRENT RIB
DEYRBA:	POINT DESRBA,DEVRIB(F),DENRBA	;CLUSTER ADDRESS OF CURRENT RIB
DEYRBC:	POINT DESRBC,DEVRIB(F),DENRBC
DEYNBB::POINT DESNBB,DEVNBB(F),DENNBB
DEYNB1::POINT DESNBB,DEVNB1(F),DENNB1
DEYSCN:	POINT	DESSCN,DEVSCN(F),DENSCN
DEYPP0::POINT	DESPP0,DEVPP0(F),DENPP0
IFN FTDPRI,<
	INTERN	DEYPRI,DEXPRI,JBYPRI,JBZPRI,JBXPRI
DEXPRI:	POINT	4,DEVPRI(F),29		;INCLUDES DEPUUO BIT
DEYPRI:	POINT	3,DEVPRI(F),29		;DOES NOT INCLUDE SET-BY-UUO BIT
JBXPRI:	POINT	3,JBTSPL##(T1),26
JBYPRI:	POINT	3,JBTSPL##(J),26	;JOB'S CURRENT PRIORITY
JBZPRI:	POINT	2,JBTPRV##(J),2		;MAX DISK PRIORITY JOB CAN SET
MXNDPR==:-3				;- HIGHEST DSK PRIORITY POSSIBLE
>

PINBFN:	POINT	DESBFN,DEVBFN(F),DENBFN	;NO OF INPUT BUFFERS
	$LOW

;ERROR CODES FOR UUO'S

;THE FOLLOWING ARE ERROR CODES FOR STRUUO

XP .ERILF,0		;ILLEGAL FUNCTION CODE (TOO LARGE)
XP .ERSNF,1		;1 OR MORE FILE STRUCTURES NOT FOUND (.FSSRC)
XP .ERSSA,2		;1 OR MORE FILE STRUCTURES SINGLE ACCESS ONLY (.FSSRC)
XP .ERILE,3		;1 OR MORE ILLEGAL ENTRIES (.FSSRC)
XP .ERTME,4		;TOO MANY ENTRIES IN SEARCH LIST (.FSSRC)
XP .ERUNA,5		;1 OR MORE UNITS NOT AVAILABLE (.FSDEF)
XP .ERNBM,6		;1 OR MORE UNITS NOT IN BEING MOUNTED STATE (.RSRDY)
XP .ERMCN,7		;CANT REDEFINE FILE STRUCTURE BECAUSE MOUNT COUNT NOT 0(.FSRDF)
XP .ERNPV,10		;NOT PRIVILEGED USER
XP .ERNPM,11		;NO UNITS MENTIONED
XP .ERPST,12		;UNIT NOT IN NO PACK MOUNTED STATE
XP .ERNID,13		;NO UNIT ID SPECIFIED
XP .ERNFS,14		;SYSTEM FULL OF FILE STRUCTURES
XP .ERNCS,15		;NOT ENOUGH FREE CORE FOR DATA BLOCK
XP .ERUNF,16		;ILLEGAL UNIT
XP .ERRSL,17		;FILE STRUCTURE REPEATED IN SEARCH LIST DEFINITION (.FSSRC)
XP .ERNSI,20		;NO SAT INFO IN STR DEFINITION (.FSDEF)
SUBTTL	HOM:	WORD POSITIONS IN HOME FILE DATA BLOCK
;PREFIX "HOM"
;EACH FILE STRUCTURE HAS ONE HOME FILE HOME.SYS.  IT IS A "SPARSE FILE"
;WITH RETRIEVAL INFORMATION IN FIRST BLOCK OF EACH GROUP.  HOWEVER ONLY
;THE SECOND BLOCK OF EACH GROUP (1 CLUSTER) HAS DATA, THE REMAINING ONES
;(IF  ANY) ARE 0, THE HOME FILE IS CONSTRUCTED SO THAT EACH GROUP IS ON A
;SEPARATE UNIT WHERE 'UNIT' IS A SIDE OF A BRYANT MDF DISK, ONE OUT OF UP TO
;FOUR BURROUGHS FIXED HEAD DISKS, ETC.

	INTERN	HOMNAM,HOMHID,HOMPHY,HOMSNM,HOMNXT,HOMPRV,HOMLOG
	INTERN	HOMLUN,HOMPPN,HOMHOM,HOMGRP,HOMSAT,HOMMFD,HOMSWP,HOMCRS,HOMMNT
	INTERN	HOMBAD,HOMPT1,HOMCNP,HOMCKP,HOMCLP,HOMK4S,HOMUTP
	INTERN	HOMBPC,HOMBSC,HOMSCU,HOMREF,HOMSIC,HOMSID,HOMSUN,HOMOVR
	INTERN	HOMGAR,HOMSLB,HOMCFS,HOMSPU,HOMCOD,CODHOM,HOMSLF,HOMTAB,HOMLEN
	INTERN	HOMSNP,HOMRCV,HOMSUF,HOMPUF,HOMUN1,HOMSRC,HOMK4C,HOMEND
	INTERN	HOMBTS,HOMSDL

IFN FTPSTR,<
	INTERN	HOMPVS,HOPPVS,HOMOPP
>

;DATA LOCATIONS IN HOME BLOCK:
;WRITTEN BY MAP PROGRAM:

HOMNAM==BLKNAM	;"HOM" IN SIXBIT (WRITTEN BY MAP PROGRAM)
HOMHID==1	;SIXBIT UNIT ID (WRITTEN BY MAP PROGRAM)
HOMPHY==2	;LH=PHYSICAL ADDRESS OF THIS HOME BLOCK ON THIS UNIT
		;RH=PHYSICAL ADDRESS OF OTHER HOME BLOCK ON THIS UNIT
		; BYTE (8) CYL ADR, (5) SURFACE, SECTOR ADR.
		; (WRITTEN AND USED BY MAP PROGRAM)
		; NO WORDS BELOW ARE CHANGED BY THE MAP PROGRAM
;WRITTEN BY OPTIONAL ONCE ONLY DIALOG:

HOMSRC==3	;LOCICAL POSITION OF THIS STR IN "SYS" SEARCH LIST(0...N)
		; -1 MEANS NOT IN SYS SEARCH LIST
HOMSNM==4	;SIXBIT FILE STRUCTURE NAME THIS UNIT BELONGS TO
		; 0 INDICATES NOT IN A FILE STRUCTURE
		; [IGNORED BY MONITOR WHEN A PACK IS MOUNTED
		; FILE STRLST.SYS IS FINAL AUTHORITY FOR THE STR NAME]
HOMNXT==5	;SIXBIT UNIT ID OF NEXT UNIT IN THIS FILE STRUCTURE.
		; 0 IF THIS UNIT IS LAST OR ONLY UNIT IN FILE STRUCTURE.
		; [CHECKED BY MONITOR AND OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMPRV==6	;SIXBIT UNIT ID OF PREVIOUS UNIT IN THIS FILE STRUCTURE.
		; 0 IF THIS UNIT IS ONLY UNIT IN FILE STRUCTURE.
		; [CHECKED BY MONITOR & OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMLOG==7	;SIXBIT LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
		; (E.G. DSKA0,DSKC12)
HOMLUN==10	;LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT
		; [CHECKED BY MONITOR AND OMOUNT CUSP WHENEVER PACK IS MOUNTED]
HOMPPN==11	;PROJECT PROGRAMMER NUMBER OF USER WHO REFRESHED DISK
		; UNDER TIME SHARING OR 0.
HOMHOM==12	;LH=LOGICAL BLOCK NUMBER WITHIN UNIT(NOT STR)
		; FOR 1ST. "HOME" BLOCK.  RH=LOGICAL BLOCK NO. WITHIN UNIT OF
		; REDUNDANT HOME BLOCK(IN CASE FIRST HOME BLOCK IS BAD)
		; NOTE: RESTRICTION THAT HOME BLOCKS ARE RESTRICETED TO FIRST
		; 262,000 BLOCKS ON A UNIT.  KNOWING LOGICAL BLOCK ADR. OF
		; HOME BLOCKS IS USEFUL ONLY TO RECOVERY PROGRAMS WHEN FILE
		; STRUCTURE HAS BEEN CLOBBERRED.  MOST PROGRAMS WILL READ HOME
		; BLOCKS VIA FILE HOME.SYS
HOMGRP==13	;NO. OF BLOCKS (NOT CLUSTERS) PER GROUP TO TRY FOR
		; ON SEQUENTIAL OUTPUT ALLOCATION
HOMBSC==14	;# BLOCKS PER SUPER CLUSTER IN THIS STR
HOMSCU==15	;# SUPER CLUSTERS PER UNIT
HOMCNP==16	;BYTE POINTER FOR CLUSTER COUNT IN A RETRIEVAL POINTER
HOMCKP==17	;BYTE POINTER FOR CHECKSUM IN A RETRIEVAL POINTER
HOMCLP==20	;BYTE POINTER FOR CLUSTER ADDRESS IN A RETRIEVAL POINTER
HOMBPC==21	;# BLOCKS PER CLUSTER(SAME FOR ALL UNITS IN AN STR)
HOMK4S==22	;# OF K WORDS OF THIS UNIT USED FOR SWAPPING
		; 0 MEANS NO SWAPPING SPACE ALLOCATED
HOMREF==23	;NON-ZERO IF FILE STRUCTURE MUST BE REFRESHED
		; BECAUSE SOME PARAMETER FOR THIS UNIT HAS BEEN CHANGED
		; SET BY DISK ONCE ONLY CODE,CHECKED WHEN SYSTEM IS STARTED
		; AND BY OMOUNT WHEN PACK MOUNTED

HOMSIC==24	;# SAT BLOCKS IN CORE
HOMSID==25	;SWAPPING ID - SIXBIT UNIT ID OF NEXT UNIT IN ACTIVE SWAPPING LIST
		; 0 IF LAST UNIT( OR UNIT NOT IN ACTIVE SWAPPING LIST)
HOMSUN==26	;LOGICAL UNIT # IN ACTIVE SWAPPING LIST(0,...,7).
		; -1 INDICATES UNIT IS NOT IN ACTIVE SWAPPING LIST.
		; (MAYBE CHANGED AT ONCE TIME WITHOUT REQUIRING REFRESHING
		; PROVIDED SWAPPING SPACE ALLOCATED AT REFRESH TIME.)
HOMSLB==27	;1ST. LOGICAL BLOCK ON UNIT FOR SWAPPING
HOMCFS==30	;SWAPPING CLASS FOR UNIT
HOMSPU==31	;# SAT BLOCKS PER UNIT
HOMOVR==32	;-# OF BLOCKS OF OVERDRAW ALLOWED A USER ON THIS STR BEFORE
		; NO MORE OUTPUTS ALLOWED.
HOMGAR==33	;UPPER BOUND ON # OF BLOCKS GUARRANTEED TO USERS BY RESERVED
		; QUOTAS.
;WORDS WRITTEN BY REFRESHER:

HOMTAB==34	;FIRST LOC OF TABLE OF LOG. BLOCK NOS OF SYSTEM FILES
HOMSAT==HOMTAB	;LOGICAL BLOCK NO. WITHIN STR(NOT UNIT) OF 1ST RIB FOR SAT.SYS
HOMHMS==35	; " FOR HOME.SYS
HOMSWP==36	; " FOR SWAP.SYS
HOMMNT==37	; " MAINT.SYS
HOMBAD==40	; " BADBLK.SYS
HOMCRS==41	; " FOR CRASH.EXE
HOMSNP==42	; " SNAP.SYS
HOMRCV==43	; " RECOV.SYS
HOMSUF==44	; " SYS UFD
HOMPUF==45	; " PRINTR UFD
HOMMFD==46	; " FOR MFD [1,1].UFD
HOMPT1==47	; COPY OF 1ST RETRIEVAL POINTER FOR MFD FOR STR THIS UNIT IS IN
HOMUN1=50	;LOGICAL UNIT NUMBER OF UNIT ON WHICH MFD BEGINS
HOMLEN==51	;FIRST ADDRESS OF TABLE OF LENGTHS OF FILES CREATED BY REFRESH
		; LENGTHS NEEDED ARE FOR CRS,SNP,RCV, AND UFDS (IN THAT ORDER)

		;57 IS LAST FILE LENGTH

HOMUTP==57	;UNIT TYPE ON WHICH HOME BLOCK WAS WRITTEN (SEE UNYUTP)
HOMRIP==60	;USED BY RIPOFF
HOMKLB==61	;20 WORDS USED BY PDP-11 IN KL10 SYSTEMS
HOMFEB==:61	;BLOCK NO OF FE.SYS (1ST DATA BLOCK)
   FEVALID==:100000	;VALID ADR IF ON
HOMFEL==:62	;LENGTH OF FE.SYS
HOMFEA==101	;FE-FILE ADDRESS FOR KS10
HOMFES==102	;FE-FILE LENGTH FOR KS10
HOMTCS==103	;TRACK/CYL/SECTOR FOR KS10
HOMKLE==104	;TO FIND FILES FOR BOOTSTRAP/DUMP
HOMK4C==105
HOMBTS==106	;BITS IN THE HOME BLOCK
IFN FTPSTR,<
HOMPVS==HOMBTS	;WORD CONTAINING BIT WHICH SAYS PRIVATE STR
HOPPVS==1B35	;ON IF THIS UNIT IS CONTAINED IN A PRIVATE STR
HOSPVS==1	;BYTE SIZE
HONPVS==^D35	;BYTE PTR POS.
	$HIGH
HOYPVS::POINT	HOSPVS,HOMPVS(P1),HONPVS  ;BYTE POINTER TO BIT WHICH
		; IF 1 SAYS THIS UNIT IS IN A PRIVATE STR
	$LOW
>
IFN FTSETS,<
HOMSET==HOMBTS	;WORD CONTAINING BYTE WHICH SPECIFIES WHICH SET THIS STRUCTURE
		; BELONGS TO
HOSSET==6	;BYTE SIZE
HONSET==^D32	;BYTE POINTER POSITION
	$HIGH
HOYSET::POINT	HOSSET,HOMSET(P1),HONSET ;BYTE POINTER TO BYTE WHICH SPECIFIES
		; WHICH SET THIS STRUCTURE BELONGS TO
	$LOW
>; END IFN FTSETS
HOMSDL==107	;POSITION OF THIS STR IN SYSTEM DUMP LIST (1...N)
		;-1 OR 0 MEANS NOT IN SDL (0 FOR COMPATABILITY)
HOMOPP==110	;OWNER PPN OF THIS STRUCTURE
HOMMSU==:111	;FOR FUTURE USE
HOMCUS==:112	;4 WORDS RESERVED TO CUSTOMERS
HOMCUL==:115	;LAST WORD IN THE HOME BLOCK RESERVED TO CUSTOMERS
HOMEND==115	;LAST WORD CONTAINING VALID DATA IN HOME BLOCK
HOMVID==:165	;VOLUME ID (3 WORDS, 12 PDP-11 BYTES)
HOMOKC==:170	;K FOR CRASH.SAV FILE
HOMVSY==:173	;SYSTEM TYPE (TOPS-10)
HOMCOD==176	;CONTAINS UNLIKELY CODE, LH=0
CODHOM==707070  ;THE UNLIKELY CODE FOR THE HOME BLOCK
HOMSLF==177	;LH=0, RH=THIS BLOCK (NO.T CLUSTER) ADR. WITHIN UNIT (SELF)
HOMOWN==:170	;OWNER NAME

HOMFLG::0		;COUNT OF UNITS NEEDING HOME BLOCKS REREAD
RHBIOW::-10,,HOMBUF-1	;IOWD TO READ HOME BLOCKS AFTER FREE INTERRUPT
	0
HOMBUF::BLOCK	10
HOMBID=:HOMBUF+HOMHID
HOMBLG=:HOMBUF+HOMLOG
;"ISW":	INITIAL SAT BLOCK FOR SWAPPING ON THIS UNIT

; WRITTEN AT MANDATORY ONCE ONLY TIME WITH 1 BIT FOR EVERY BLOCK ON UNIT
; READ BY SWPINI ON EVERY 143 RESTART
; SAME FORMAT AS "SAF" BLOCK  I.E. ALL BITS, NO OVERHEAD
SUBTTL	LNM:	LOGICAL NAME SPECIFICATIONS
LNMPLN==:0	;NAME OF LOGICAL DEVICE
LNMDEV==:1	;DEVICE (SEARCH LIST)
LNMNAM==:2	;FILE NAME
LNMEXT==:3	;FILE EXTENSION
LNMPPN==:4	;PPN
LNMSFD==:5	;1ST SFD
LNRDEV==:0	;SEARCH LIST, RELATIVE TO CURRENT DEVICE
LNRNAM==:1	;NAME
LNREXT==:2	;EXTENSION
LNRPPN==:3	;PPN, RELATIVE TO DEVICE
LNRSFD==:4	;1ST SFD, RELATIVE TO DEVICE

;BITS IN READ/SET LOGICAL NAME FUNCTIONS OF PATH.
LN.LIB==:400000	;BIT 0 =1 IF THIS IS A LIB
LN.UDF==:200000	;BIT 1=1 IF UNDEFINE THIS LOG NAME
LN.RIT==:100000	;BIT 2 = 1 IF RETURN INFO ABOUT THIS LOG NAME, RATHER THAN NEXT
LN.CMD==:40000	;BIT = 1 IF DEFINING A NAME WHICH CAN BE A COMMAND
LN.OVR==:20000	;BIT = 1 IF NAME, EXT OVERRIDE NON-0 IN LOOKUP/ENTER BLOCK

;FORMAT OF TABLE POINTED AT BY .UPLNM:
;BITS 18-35 = ADRESS OF LNMNAM
;BITS 14-17 = 0
;BIT 0=1 IF LIB
LNPCMD==:(1B1)	;BIT 1=1 IF COMMAND
LNPOVR==:(1B2)	;BIT 2+1 IF OVERRIDE
;BITS 5-11 = LENGTH OF LNM SPEC
	$HIGH
LNYLEN::POINT	7,@.USLNM,11
	$LOW

SUBTTL	MONITOR JOB TABLES - ONE ENTRY PER JOB

	INTERN	SYSBG3,SYSEN3

SYSBG3:			;1ST. LOCATION CLEARED BY ACCINI ON 403 (RE)START

	INTERN	JBTSFD,JBPSCN,JBPUFB,SFYSCU,JBPSYS,JBPXSY
JBTSFD:	BLOCK	JOBN	;RH(BITS 18-33)= LOC OF DEFAULT SFD NMB OR 0
	JBPSCN==1	;BIT 35=1 IF SCANNING IS ON, =0 IF SCANNING OFF
	JBPUFB==2	;BIT 34=1 IF JBTSFD POINTS TO A UFB
			;LH JBTSFD - USED IF FTLIB ON-
			;BITS 0-15=LOC OF PPB FOR LIBRARY
	JBPSYS==1	;BIT 17=1 IF SEARCH SYS AFTER DSK
	JBPXSY==2	;BIT 16=1 IF SEARCH NEW BEFORE SYS
	INTERN	JBTRCT,JBTWCT,JBYRCT,JBYWCT,JBYIRD,JBDIRD,MJBDRD,JBRIRD,JBRIWT
JBTRCT:	BLOCK	JOBN	;NO. OF DISK BLOCKS READ ON ALL STRS SINCE JOB LOGGED IN
			;JOB 0=SWAP READ ON ALL UNITS
JBTIRD==JBTRCT		;INCREMENTAL READ COUNT - WORD ADR.
			; ACTUALLY IT IS A COPY OF THE LOW ORDER 12 BITS
			; OF THE ACCUMULATED READS FOR THIS JOB.
			; IT IS RESET TO NEW LOW ORDER TOTAL AFTER EVERY
			; "DISK" COMMAND.  IN THIS WAY ONLY ONE COUNT NEED
			; BE INCREMENTED EVERY READ INSTEAD OF TWO.
			; INCREMENTAL DISK BLOCKS READ IS COMPUTED BY:
			;  LDB T1,JBYRCT;LDB T2,JBYIRD;DPB T1,JBYIRD;SUB T1,T2
			;  ANDI T1,JBRIRD
	JBSIRD==^D12		;BYTE SIZE
	JBNIRD==^D11		;BYTE PTR POS.
	JBRIRD==1_JBSIRD-1	;BITS IN BYTE AFTER RIGHT JUSTIFIED
	JBSRCT==^D24		;BYTE SIZE
	JBNRCT==^D35		;BYTE PTR POS

JBTWCT:	BLOCK	JOBN		;NO. OF DISK BLOCK WRITTEN ON ALL STRS SINCE JOB LOGGED IN
			; INCLUDING ALL OVERHEAD BLOCKS
			;JOB 0=SWAP WRITE ON ALL UNITS
JBDIRD==JBTWCT-JBTRCT	;DIFFERENCE BETWEEN TWO ORIGINS
MJBDRD==JBTRCT-JBTWCT	;MINUS DIFFERENCE
JBTIWT==JBTWCT		;INCREMENTAL WRITE COUNT - WORD ADR
			; SEE JBTIRD
	JBSIWT==^D12		;BYTE SIZE
	JBNIWT==^D11		;BYTE PTR POS
	JBRIWT==1_JBSIWT-1	;BITS IN BYTE AFTER BEING RIGHT JUSTIFIED
	JBSWCT==^D24		;BYTE SIZE
	JBNWCT==^D35		;BYTE PTR POS
SYSEN3=.-1		;LAST LOCATION CLEARED BY ACCINI ON 143 (RE)START
	$HIGH
JBYIRD:	POINT	JBSIRD,JBTIRD(J),JBNIRD	;BYTE POINTER
JBYRCT:	POINT	JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINTER
;JBYIWT: POINT	JBSIWT,JBTIWT(J),JBNIWT	;BYTE POINTER
JBYWCT:	POINT	JBSWCT,JBTWCT(J),JBNWCT	;BYTE POINTER
SFYSCU:	POINT	2,JBTSFD(J),35	;POINTER FOR JBPUFB & JBPSCN
	$LOW
SUBTTL	KONTROLLER DATA BLOCKS


; MACRO TO DETERMINE WHAT TYPES OF UNITS CAN BE AUTO-CONFIGURED
DEFINE	UNIATO	(KT,YN),<
IFE FTAUTC,<KT'ATO==0>
IFN FTAUTC,<
		IFIDN <YN><NO>,< KT'ATO==0>
		IFIDN <YN><YES>,<KT'ATO==1>
	> ;END IFN FTAUTC
> ;END UNIATO MACRO


; MACRO TO COUNT UP THE TOTAL NUMBER OF CONTROLLERS
DEFINE	KONTOT	(A,B),<
  TOTKON==0
  IRP A,<
    A'NUM==0
      IRP B,<
	IFE A'ATO,<
	  IFDEF M.'A'B,<
	    A'NUM==A'NUM+M.'A'B
	    TOTKON==TOTKON+1
	  > ;END IFDEF M.'A'B
	> ;END IFE A'ATO
	IFN A'ATO,<
	  A'NUM==A'NUM+1
	  TOTKON==TOTKON+1
	> ;END IFN A'ATO
      > ;END IRP B
    > ;END IRP A
 IFN FTKS10,<
    TOTKON==1
    RPNUM==M.RHA
  > ;END IFN FTKS10
> ;END KONTOT MACRO


; DEFINE THE AUTO-CONFIGURE STATUS FOR THE KNOWN UNIT TYPES
	UNIATO	(FH,NO)
	UNIATO	(FS,NO)
	UNIATO	(DP,NO)
	UNIATO	(RP,YES)
	UNIATO	(RN,YES)
	UNIATO	(RA,YES)

; COUNT UP ALL UNITS ON SYSTEM BY KONTROLLER TYPE.
	KONTOT	(<FS,FH,DP,RP,RN,RA>,<A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>)
;DEVICE INDEPENDENT STUFF

KOPOFL==:400000		;'OFF-LINE' OR 'NOT-READY' OR 'FILE UNSAFE' BIT
			; (LIGHTS UNPOFL IN UNIDES)
KOPFUS==:200000		;FILE UNSAFE - ADD TO MESSAGE TO OPERATOR
KOPUSI==:100000		;UNIT STATUS INCONSISTENT
KOPWLK==:040000		;WRITE LOCK (IF ALL THE OTHER BITS ARE OFF, THEN
			;THE PROBLEM IS ASSUMED TO BE WRITE LOCK).
KOPNOC==:020000		;(CI ONLY) NO CREDITS
KOPDER==:010000		;(CI ONLY) DEVICE ERROR
KONERM==:KOPOFL+KOPFUS+KOPUSI+KOPWLK+KOPNOC+KOPDER ;ALL ERRORS
DEFINE KONTCB (X,U,S)<
$U==0
IRP U,<
	IFE	$U-$'X'NUM,<
		X'KON (X,U,\$'X'NUM)
		$K==1
		REPEAT X'U'UN,<
		$SM1==$S-1
		$CM1==$C-1
		$KM1==$K-1
IFN M.CH'S'T-4,<
		UNITCB (\$KM1,X,U,\$S,\$SM1,\"<$C+"A">,\"<$CM1+"A">,\$K,S,TYP'X,$U)
>
IFE M.CH'S'T-4,<
		UNITCB (\$KM1,RP,U,\$S,\$SM1,\"<$C+"A">,\"<$CM1+"A">,\$K,S,TYP'X,$U)
>
		$S==$S+1
		$C==$C+1
		$K==$K+1>

		$KM1==$K-1
IFN M.CH'S'T-4,<
		KONCLS (\$KM1,X'U)
>;END IFN
IFE M.CH'S'T-4,<
		KONCLS (\$KM1,RP'U)
>;END IFE
	>
	$U==$U+1
>>	;END MACRO DEF OF KONTCB

REPEAT 0,<
TO ADD ANOTHER KONTROLLER TYPE XY, YOU MUST ADD ANOTHER REPEAT LOOP IN CHNCB
MACRO, REPEATING CNXY TIMES AND PASSING ARGUMENT XY TO KONTCB MACRO, PLUS A
LIST OF KONTROLLER IDENTIFIERS AND CHANNEL NUMBER IN ASCII.
KONTCB CALLS MACRO XYKON FOR THE KONTROLLER DEPENDENT PART OF THE KONTROLLER
CORE BLOCK; THAT MUST ALSO BE SUPPLIED.  XYKON SHOULD CALL KONKON FOR THE
KONTROLLER INDEPENDENT PART OF THE KONTROLLER CORE BLOCK.
>

;KONTROLLER DATA BLOCK DISK PACKS (ONE DEFINITION NO MATTER
;HOW MANY DISK PACK KONTROLLERS)

;RP10 - CONTROLLER FOR RP01(MEMOREX) DISK PACK UNIT AND/OR RP02
;  (MEMOREX) DISK PACK UNIT:

XP TYPDP,2		;ALWAYS DEFINE CONTROLLER TYPE CODE - SEE UNIKTP

IFE RP10N,<			;IF NO RP10 CONTROLLERS:
	INTERN	DPXSTS

DPXSTS:	MOVEI	T2,0		;DUMMY READ STATUS ROUTINE
	POPJ	P,		;ALWAYS CALLED BY ONCMOD
				;RETURN 0 STATUS(NOT WRTIE LOCKED)
>
DEFINE DPKON (X,U,N)<
DPFIX==0			;;NOT A FIXED HEAD DEVICE (IF 0)
DPOFS==400000			;;NO OFFSET CAPABILITY
DPRDC==400000			;;NO 10/11 COMPATABILITY MODE
DPUNL==400000			;;NO UNLOAD CAPABILITY
DPCPY==400000		;;KONTROLLER MUST BE IDLE TO DETERMINE UNIT TYPE
DPERNO==0			;;NO DRIVE REGISTERS TO SAVE ON ERROR
KONKON (X,U,DP'N,DP'N,N)


;;KONTROLLER TYPE DEPENDENT PART OF KONTROLLER DATA BLOCK
DPIF==10			;;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAGS)
	DEFINE	DPXUNI(Z)<
		IFNDEF DP'Z,<DP'Z==250+4*<Z-M.DP'Z'P>>
	>
ZZ==0
REPEAT M.RP10,<
	DPXUNI(\ZZ)
	ZZ==ZZ+1
>

	EXTERN	DPXKON
	INTERN	DPXCO1,DPXDOT,DPXDO1,DPXDI1,DPXCIT,DPXFNC,DPXIWD,DPXCI2,DPXDI3

DPXCCM==:CYLCM##
DPXRLD==:CPOPJ##
DPXSEC==:CPOPJ##
DPXEDL==:CPOPJ##
DPXCO1:!CONO	DP'N,(T2)
DPXDOT:!DATAO	DP'N,T1
DPXDO1:!DATAO	DP'N,T2
DPXDI1:!DATAI	DP'N,T2
DPXCIT:!CONI	DP'N,T1
DPXCI2:!CONI	DP'N,T2
DPXDI3:!DATAI	DP'N,T3
DPXFNC:!EXP	OPPOS		;;INITIAL FUNCTION CODE
				;;MAKE IT BE POSITION IN CASE OPERATOR CAUSES
				;;INTERRUPT BEFORE DISK PACKS ARE EVER USED BY SYSTEM

DPXIWD:!0
	DEPHASE
>	;;END MACRO DEF OF DPKON
IFE RP10N,<
;SATISFY GLOBALS IN DPXCPY AND DPXUPA WHICH WILL NEVER BE CALLED BUT DO GET LOADED IF NO RP10'S
XP DPXCO1,0
XP DPXDOT,0
XP DPXDO1,0
XP DPXDI1,0
XP DPXCIT,0
XP DPDONE,0
XP DPCLR,0
XP DPATTN,0
>
;RC10 CONTROLLER FOR RD10(BURROUGHS) FIXED HEAD DISK UNIT AND/OR
; RM10B(BRYANT) DRUM UNIT:

XP TYPFH,1			;ALWAYS DEFINE KONTROLLER TYPE CODE - SEE UNIKTP

DEFINE	FHKON (X,U,N)<

FHFIX==400000			;BIT 0 = 1 IF FIXED HEAD DEVICE
FHOFS==400000			;NO OFFSET CAPABILITY
FHRDC==400000			;;NO 10/11 COMPATABILITY MODE
FHUNL==400000			;;NO UNLOAD CAPABILITY
FHCPY==400000		;;KONTROLLER MUST BE IDLE TO DETERMINE UNIT TYPE
FHERNO==0			;NO DRIVE REGISTERS TO SAVE ON ERROR
KONKON (X,U,FH'N,FH'N,N)
FHIF==10			;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(DONE FLAG)
	DEFINE FHXUNI(Z)<
	  IFNDEF FH'Z,<FH'Z==170+4*<Z-M.FH'Z'P>>
	>
ZZ==0
REPEAT M.RC10,<
	FHXUNI(\ZZ)
	ZZ==ZZ+1
>

	EXTERN	FHXKON
	INTERN	FHXCI1,FHXCOT,FHXCO1,FHXDI2,FHXDOT,FHXIWD

FHXCCM==:CYLCM##
FHXALV==:CPOPJ##
FHXRLD==:CPOPJ##
FHXSEC==:CPOPJ##
FHXEDL==:CPOPJ##
FHXCI1:!CONI	FH'N,T2
FHXCOT:!CONO	FH'N,(T1)
FHXCO1:!CONO	FH'N,(T2)
FHXDI2:!DATAI	FH'N,T3
FHXDOT:!DATAO	FH'N,T1
FHXIWD:!0			;INITWD STORAGE

	DEPHASE
>	;END MACRO DEF OF FHKON
IFE RD10N,<
;SATISFY GLOBALS IN FHXCPY AND FHXUPA WHICH WILL NEVER BE CALLED BUT ARE LOADED IF NO RD10'S
XP FHXCI1,0
XP FHXCOT,0
XP FHXCO1,0
XP FHXDI2,0
XP FHXDOT,0
XP FHALCL,0
>	;END CONDITIONAL ON RD10N
;RH10 CONTROLLER FOR RS04 DISK:

XP TYPFS,4

DEFINE FSKON (X,U,N)<

FSFIX==400000			;BIT 0=1 SINCE FIXED HEAD DISK
FSOFS==400000			;NO OFFSET CAPABILITY
FSRDC==400000			;;NO 10/11 COMPATABILITY MODE
FSUNL==400000			;;NO UNLOAD CAPABILITY
FSCPY==0		;;CAN TELL UNIT TYPE EVEN IF KONTROL IS BUSY
FSERNO==^D8			;8 DRIVE REGISTERS TO SAVE ON ERROR
	DEFINE FSXUNI(Z)<
	 IFE M.FS'Z'F,<ZZ==270>
	  IFE ZZ-300,<ZZ==360>
	  IFNDEF FS'Z,<FS'Z==ZZ>
	  ZZ==ZZ+4
	>
ZZC==0
REPEAT M.RH1S,<
	FSXUNI(\ZZC)
	ZZC==ZZC+1
>
KONKON (X,U,FS'N,FS'N,N)

FSIF==350			;;INTERRUPT FLAGS FOR CONSO INSTR.
				;;(CBOV,RAE,ATTN,DONE)


EXTERN	FSXKON
INTERN	FSXCI2,FSXCO2,FSXCO4,FSXDI3,FSXDO3,FSXFNC,FSXDO4

FSXCCM==:CYLCM##
FSXALV==:CPOPJ##
FSXRLD==:CPOPJ##
FSXSEC==:CPOPJ##
FSXEDL==:CPOPJ##
FSXCO4:!CONO	FS'N,(T4)
FSXCI2:!CONI	FS'N,T2
FSXCO2:!CONO	FS'N,(T2)
FSXDI3:!DATAI	FS'N,T3
FSXDO3:!DATAO	FS'N,T3
FSXDO4:!DATAO	FS'N,T4
FSXFNC:!	0
	DEPHASE
>	;END MACRO DEF FSKON
IFE M.RH1S,<			;SATISFY GLOBALS IN FSXCPY, FSXUPA
XP FSALCL,0
XP FSXCI2,0
XP FSXCO2,0
XP FSXCO4,0
XP FSXDI3,0
XP FSXDO3,0
>
;RH10 CONTROLLER FOR RP04 DISK PACK
XP	TYPRP,5

;DEFINITIONS FOR RH20 IOWDS
XP RH2TRA,400000
XP RH2LST,200000	;(WITH RH2TRA=1)
XP RH2JMP,200000	;(WITH RH2TRA=0)
XP RH2REV,100000	;REVERSE (WITH RH2TRA=1)
XP RH2TRX,20000		;TRA, SHIFTED FOR A WORDCOUNT- BYTE POINTER
XP RH2TLS,30000		;TRA+LAST, SHIFTED

DEFINE	RPKON(X,U,N)<

RPFIX==200000		;POSITIONING DEVICE, CAN SEEK WHILE XFERRING
RPOFS==0		;CAN OFFSET FOR ERROR RECOVERY
RPRDC==0		;;10/11 COMPATABILITY MODE
RPUNL==0		;;DRIVE CAN BE UNLOADED
RPCPY==0		;;CAN TELL UNIT TYPE EVEN IF KONTROL IS BUSY
RPERNO==^D16		;16 DRIVE REGISTERS TO SAVE ON ERROR
KONKON	(X,U,RP'N,P'N,N)

		;DEVICE CODE SELECTION FOR RP04 CONTROLLERS
DEFINE RPXUNI(Z)<

IFE FTAUTC,<
IFE M.P'Z'F,<
	ZZ1==270+4*M.RS'Z'P ;1ST RH10 AFTER RS04S ON THIS CPU
	IFG ZZ1-277,<ZZ1==ZZ1+60>
>
>
IFDEF	RP'Z,<
	IFL	<RP'Z-540>,<RP'Z'IF==350>
	IFGE	<RP'Z-540>,<RP'Z'IF==4210>
>
IFNDEF RP'Z,<
IFN	M.P'Z'T,<	;IF AN RH20
	RP'Z==540+4*<M.P'Z'T-1>
	RP'Z'IF==4210		;RH20 INTERRUPT-CAUSING BITS
>
IFE	M.P'Z'T,<
	RP'Z==ZZ1
	IFE	RP'Z-300,<RP'Z==360>
	ZZ1==RP'Z+4
	RP'Z'IF==350>		;RH10 INTERRUPT-CUASING BITS
>>

ZZC==0
REPEAT M.RHP4,<
	RPXUNI(\ZZC)
	ZZC==ZZC+1
>

EXTERN RPXKON
INTERN RPXCO4,RPXCO2,RPXCI2,RPXDI1,RPXDI2,RPXDO2,RPXDO1,RPXFNC,RPXFLG

RPXCCM==:CYLCM##
RPXRLD==:CPOPJ##
RPXSEC==:CPOPJ##
RPXEDL==:CPOPJ##
RPXCO4:!CONO	RP'N,(T4)
RPXCI2:!CONI	RP'N,T2
RPXCO2:!CONO	RP'N,(T2)
RPXDI1:!DATAI	RP'N,T1
RPXDI2:!DATAI	RP'N,T2
RPXDO2:!DATAO	RP'N,T2
RPXDO1:!DATAO	RP'N,T1
RPXFNC:!0
RPXFLG:!-1
IFN FTKL10,<
RPXGON::!0
RAECNT::!0		;RAE ERRS - CBPE,,NO TRA
RPXRAE::!
IFG RP'N-500,<
	CONSZ	RP'N,4000	;TEST RAE IF RH20
>
IFL RP'N-500,<
	CAIA			;SKIP IF RH10
>
>
	DEPHASE
>

IFE M.RHP4,<	;SATISFY GLOBAL IN ONCMOD IF NO RP04
IFE FTKS10,<
	XP	DODTI4,CPOPJ##
	XP	RPXCI2,0
	XP	RPXCO2,0
	XP	RPXCO4,0
	XP	DPXDO2,0
	XP	RPALCL,0
	XP	RPXFLG,0
>;END IFE FTKS10
IFN FTKL10,<
	XP	RPXSTW,0
	XP	RPXDO2,0
>
>
;RH11 CONTROLLER FOR RP04, RP06, AND RM03
;NOTE:	KONTROLLER SERVICE ROUTINE IS CALLED RHXKON EVEN THOUGH
;	THE UNITS ARE REFERRED TO AS RP'S TO CONFORM WITH RH10,
;	RH20 IMPLEMENTATION.

XP TYPRH,TYPRP		;SAME AS RH10,RH20

DEFINE	RHKON(X,U,N)<

RPFIX==200000		;POSITIONING DEVICE, CAN SEEK WHILE XFERRING
RPOFS==0		;CAN OFFSET FOR ERROR RECOVERY
RPRDC==0		;;10/11 COMPATABILITY MODE
RPUNL==0		;;DRIVE CAN BE UNLOADED
RPCPY==0		;;CAN TELL UNIT TYPE EVEN IF KONTROL IS BUSY
RPERNO==^D16		;16 DRIVE REGISTERS TO SAVE ON ERROR
IFN FTAUTC,<
RPAUN==1>
IFE FTAUTC,<
RPAUN==RHAUN		;MAKE KONKON MACRO POINTERS TO UDB'S COME OUT RIGHT
>

KONKON	(RP,U,RH'N,RH'N,N)

RPXALV==:CPOPJ##
RPXRLD==:CPOPJ##
RPXCCM==:CYLCM##
RPXSEC==:CPOPJ##
RPXEDL==:CPOPJ##
RHXVEC::!RH11IV
;-11 STYLE INTERRUPT VECTOR ADDRESS

RHXBAS::!RH11CA			;BASE ADDRESS OF RH11 REGISTERS
RHXIVI::!XPCW	RH'N'INT	; INTERRUPT INSTRUCTIONS FOR THIS RH11

RPXFNC::!0			;LAST DATA XFER FUNCTION STORED HERE BY DRIVER
				; BIT 0 = OFF IF DSK HUNG, ON IF EVERYTHING OK
				; BITS 15-17 = UNIT NUMBER COMMAND ISSUED TO
				; BITS 30-35 = FUNCTION CODE

RPXFLG::!-1			;DATA XFER IN-PROGRESS FLAG
				; -1 = CONTROLLER IDLE
				; 0 = XFER IN-PROGRESS, STOP ON ERROR
				; 1 = XFER IN-PROGRESS, DON'T STOP ON ERROR

DEPHASE

EXTERN RHXKON

>
;RH20 CONTROLLER FOR RP20 FIXED MEDIA DISKS
XP	TYPRN,6

DEFINE	RNKON(X,U,N),<

RNFIX==0		;NOT FIXED HEAD, CANNOT SEEK WHILE XFERRING
RNOFS==0		;DRIVE CAN OFFSET. IT CAN'T REALLY BUT WE HAVE
			;TO GET FILIO TO CALL US (VIA RNXERR) TO DIRECT
			;ERROR RECOVERY.
RNRDC==400000		;NO 10/11 COMPATABLILITY MODE
RNUNL==400000		;DRIVE CANNOT BE UNLOADED
RNCPY==400000		;KONTROL MUST BE IDLE FOR RNXCPY
RNVEBK==:^D57		;NUMBER OF "MASSBUS REGISTERS" TO SAVE IN
			;KDB/UDB.  WILL GET MULTIPLY DEFINED GLOBAL
			;SYMBOLS FROM LINK IF THIS VALUE DOESN'T MATCH
			;THE ONE IN RNXKON.
RNERNO==RNVEBK		;DEFINE VALUE FOR MACRO
RNMNU==^D16		;DRIVES PER KONTROLLER

KONKON	(X,U,RN'N,\"<116>'N,N)	;THE NEXT-TO-LAST ARGUMENT TO THE KONKON
				; MACRO GENERATES, E.G.,
				; N0,N1,...  IT WAS THE ONLY WAY TO PASS THE
				; CHARACTER "N" THROUGH WITHOUT SUBSTITUTION

DEFINE	RNXUNI(Z),<
IFN FTAUTC,<
	RN'Z'IF==4210
	RNIF==4210
>
IFNDEF RN'Z,<
    RN'Z==540+4*<M.N'Z'T-1>	;DEFINE DEFAULT DEVICE CODES
IFE FTAUTC,<
	RN'Z'IF==4210		;RH20 INTERRUPT CAUSING BITS
> ;END IFE FTAUTC
>>
ZZC==0
REPEAT	M.RP20,<
	RNXUNI(\ZZC)
ZZC==ZZC+1
>

EXTERN RNXKON			;FORCE LOADING OF RNXKON
EXTERN DX2COM			;FORCE LOADING OF DX2COM

RNXCO2::!CONO	RN'N,(T2)
RNXCO4::!CONO	RN'N,(T4)
RNXCI2::!CONI	RN'N,T2
RNXDO2::!DATAO	RN'N,T2
RNXDO1::!DATAO	RN'N,T1
RNXDI2::!DATAI	RN'N,T2
RNXRAE::!CONSZ	RN'N,4000	;SKIP IF NO RAE
RNXRAC::!0			;LH=COUNT OF RAE'S CAUSED BY OTHER THAN
				;   NON-EXISTENT DRIVES
				;RH=COUNT OF RAE'S CAUSED BY NON-EXISTENT
				;   DRIVES
RNXAEC::!0			;RH=COUNT OF THE NUMBER OF TIMES AN ATTENTION
				;   SUMMARY REGISTER BIT COULDN'T BE
				;   CLEARED BY WRITING IT TO A 1.  USED
				;   TO TELL WHEN TO DO A MASSBUS INIT.
				;LH=TOTAL NUMBER OF MASSBUS INITS DONE
RNXEC1::!0			;LH=NUMBER OF TIMES LOGUPE WAS CALLED TO
				;   LOG AN ERROR THAT FILIO WOULDN'T HAVE
				;RH=NUMBER OF TIMES WGOCLR DIDN'T TIME
				;   OUT THE GO BIT
RNXEC2::!0			;LH=NUMBER OF TIMES CMDWAT TOSSED A SEEK
				;   BECAUSE AN XFER WAS IN PROGRESS
				;RH=NUMBER OF TIMES CMDWAT WAS CALLED
RNXEC3::!0			;LH=NUMBER OF TRANSFERS WHICH RESULTED IN
				;   MISSED REVOLUTIONS DURING LAST INTERVAL
				;RH=NUMBER OF TRANSFERS ATTEMPTED DURING LAST
				;   INTERVAL
RNXRSC::! EXP	THSCCB+CHNRSC	;ADDRESS OF LOCATION CONTAINING THE
				;  NUMBER OF TIMES THIS DX20 WAS RESTARTED.
RNXFLG::!0			;FLAGS (SEE RNXKON FOR DEFINITIONS)
RNXCMD::!0			;LAST COMMAND+FUNCTION FLAGS ISSUED TO
				;  KONTROLLER
RNXLAS::!0			;VALUE OF RNXCMD AT LAST INTERRUPT
				;  (FOR DEBUGGING)
RNXATN::!0			;LH=ATTENTION BITS FOR DRIVES PRESENTING
				;   ASYNCHRONOUS STATUS
				;RH=UNUSED
RNXITB::!BLOCK	2		;VALUE OF THE KL TIME BASE AT THE TIME
				;  THE LAST TRANSFER WAS STARTED.  USED
				;  TO CALCULATE MISSED REVOLUTIONS.

RNXULB::!			;MICROCODE LOADER BLOCK
	 EXP	.BTRP2##	;MICROCODE INDEX
	 XWD	0,-1		;DEVICE CODE,,UNIT NUMBER
	 SIXBIT	/RP20/		;INTERFACE NAME
	 SIXBIT	/DX20/		;CHANNEL NAME
	 EXP	RNXMVR##	;MINIMUM MICROCODE VERSION
	 EXP	0		;DATE/TIME OF LOAD SUCCESS OR FAILURE
	 EXP	0		;MICROCODE VERSION
	 EXP	0		;POINTER TO MAGIC TABLE
	 EXP	0		;MICROCODE LENGTH
	 EXP	0		;MICROCODE ADDRESS
	 CONI	0,T2		;CONI
	 CONO	0,(T2)		;CONO
	 DATAI	0,T2		;DATAI
	 DATAO	0,T2		;DATAO

	DEPHASE
>

IFE	M.RP20,<		;SATISFY GLOBALS IN ONCMOD AND SYSINI IF NO RP20
	XP	RNXCI2,0
	XP	RNXCO2,0
	XP	RNPUPA,0
	XP	RNXMPS,CPOPJ##
	XP	RNXFLG,0
	XP	RNXCMD,0
	XP	RNXIVI,CPOPJ##
	XP	RNXFKA,CPOPJ##
	XP	RNYDXN,0
	XP	RNVNMR,0
	XP	RNVSMR,0
	XP	RNXCSB,CPOPJ##
	XP	RNXSAK,CPOPJ##
	XP	RNXCMR,CPOPJ##
	XP	RNXALT,0
>
;CI BUS CONTROLLER FOR RA80, RA81

XP	TYPRA,7

DEFINE RAKON(X,U,N),<

RAMNU==^D24		;;MAXIMUM OF 24 UNITS PER KONTROLLER
RAFIX==0		;;NOT FIXED HEAD (EVEN THOUGH WE NEVER POSITION IT)
RAOFS==0		;;NO OFFSET CAPABILITY, BUT SET THE BIT SO FILIO
			;; WILL ATTEMPT SOME ERROR RECOVERY
RARDC==400000		;;NO 10/11 COMPATIBILITY MODE
RAUNL==400000		;;NO UNLOAD CAPABILITY
RACPY==0		;;CAN TELL UNIT TYPE EVEN IF KONTROL IS BUSY
RAMX==KOPMX		;;CAPABLE OF MULTIPLE TRANSFERS
RAERNO==0		;;NO DRIVE REGISTERS TO SAVE ON ERROR

KONKON	(X,U,RA'N,RA'N,N)

	RAIF==0		;;INTERRUPT FLAGS FOR CONSO INSTRUCTION

RAXRLD==:CPOPJ##	;;YOU CAN'T RELOAD THE MICROCODE
RAXEDL==:CPOPJ##	;;CAN'T ENABLE/DISABLE MICROCODE LOADING

;;START OF I/O INSTRUCTIONS

	CONI	KLP,T1	;;DUMMY INSTRUCTION SO LDB USING KONIIO WILL GET
			;; A SOMEWHAT REASONABLE VALUE FOR DEVICE CODE

;;START OF KONTROLLER-DEPENDENT VARIABLES

RAKCID::!BLOCK	2	;;CONTROLLER ID

			;;TABLES INDEXED BY CPU NUMBER
RAKCTI::!BLOCK	6	;;CONNECT TABLE INDEX FOR THIS KONTROLLER
RAKTIM::!BLOCK	6	;;KONTROLLER TIMEOUT COUNTER
RAKTMO::!BLOCK	6	;;KONTROLLER TIMEOUT VALUE (SECONDS)
			;;END OF TABLES INDEXED BY CPU NUMBER

	DEPHASE

	EXTERN	RAXKON	;;LOAD THE DISK SERVER
	EXTERN	MSCCOM	;;LOAD THE MSCP DRIVER COMMON DATA AND SUBROUTINES

>; END RAKON MACRO

IFE M0RAX,<			;SATISFY GLOBALS IN ONCMOD IF RAXKON ISN'T LOADED

	XP	MSCINI,CPOPJ##	;MSCP DRIVER INITIALIZATION
				;(WE SHOULD TEST IF NO CI TAPES EITHER SOMEDAY)
	XP	MSCUON,CPOPJ##	;SET UNIT ONLINE
	XP	MSCCUS,CPOPJ##	;CHECK UNIT STATUS
	XP	MSCGBF,CPOPJ##	;GET A BUFFER
	XP	RAKCTI,0	;CONNECT TABLE INDEX

>; END IFE M0RAX
;KON:	KONTROLLER DATA BLOCK
;DEFINE FIRST PART OF KONTROLLER DATA BLOCK
;WHICH IS THE SAME FOR ALL KONTROLLER DATA BLOCKS


;FOR EACH KONTROLLER IN SYSTEM:
; PARAMETERS FOR KONKON
; XX  - KONTROLLER TYPE (ASCIZ) EG. DP,FH,DR,MD
; X   - KONTROLLER NUMBER SYMBOL (ASCIZ) EG. A,B,C
; XXN - KONTROLLER SYMBOL (ASCIZ) EG. DP0,DP1,FH0,FH1
; XXL - KONTROLLER ALIAS (ASCIZ) EG P0,P1 (FOR RP0X), DP0,DP1 OTHERWISE
; NN  - KONTROLLER NUMBER (ASCIZ) EG 0,1,2

DEFINE	KONKON (XX,X,XXN,XXL,NN)<

	INTERN	KONBSY, KOPBSY, KONTBP, KONMUN, KONCAM, KONIIO
	INTERN	XXN'INT,KONPOS,KONRED,KONWRT,KONRDS,KONWTS,KONCPY,KONRCL
	INTERN	KONCUA,KONIOC,KONCHN,KONPTR,KONCOM,KONLST,KONSTP,KONREG,KOP22B
	INTERN	KOYPI,KONINT,KONUPA,KONDWN,KOPDWN,KOPUHE,KOPNSU
	INTERN	OPRED,OPWRT,OPRDS,OPWTS,OPPOS,OPPPOS,OPRCL,KOPWHL,KONDMP,KONEBK
	INTERN	KONECR,KONEDB,XX'X'CB

IFDEF XXN'IF,<XX'IF==XXN'IF
>
IFNDEF M.'XXL'T,<M.'XXL'T==0>	;ONLY DEFINED FOR RP04'S
XXN'INT:
IFE FTKS10,<			;;KS10 HAS VECTORRED INTERRUPT, NO SKIP CHAIN
	CONSO	XXN,XX'IF	;;(-4)SKIP IF INTERRUPT FOR THIS KONTROLLER
				;;ALWAYS HAVE INTERRUPT ROUTINE LOOKING FOR INTERRUPS
				;;THIS FLAG NEVER CLEARED (NEEDED FOR DISK PACKS
				;;OPERATOR MOUNTING AND REMOVING PACKS)
	JRST	.		;;(-3)GO TO NEXT SKIP CHAIN ELEMENT
IFN M.'XXL'T,<
	CONSZ	XXN,4050	;RH20 COULD HAVE ATTEN, ATTNS NOT ENABLED
>
IFE M.'XXL'T,<
	JFCL			;RH10 MASKS ATTEN IN CONI IF NOT ENABLED
>
	CONSO	XXN,7		;IF NO PI UP,
	JRST	XXN'INT+1	; PROBABLY DIAG FIDDLING WITH KON

>;END IFE FTKS10
IFN FTKS10,<
	0			;;VECTORED INTERRUPT JSR'S TO HERE
	EXP	0,IC.UOU,.+1	;;XPCW BLOCK

	EXCH	T1,XXN'INT	;;GET INTERRUPT PC
	MOVEM	T1,XXN'CHL##	;;AND STORE IN "CH'PI" SO JEN TO CORRECT ADDRESS
	MOVE	T1,XXN'INT+1	;;SECOND WORD
	MOVEM	T1,XXN'CHL##+1
	MOVE	T1,XXN'INT	;;AND RESTORE T1
>;END IFN M.KS10
IFE FTAUTC,<
	JSR	XXN'SV##	;;(-2) SAVE INTERRUPT ACS
>; END IFE FTAUTC
IFN FTAUTC,<
	JSR	PIERR##		;;(-2) FILLED IN BY AUTCON
>; END IFN FTAUTC
	JSP	J,XX'XINT##	;;(-1) SETUP ADDRESS OF KONTROLLER DATA BLOCK
				;; AND BRANCH INTO CODE WHICH IS COMMON
				;; TO ALL KONTROLLERS OF SAME TYPE
				;; (INTERRUPT DISMISSED BY EXTRA POPJ OR JRST XXRET)
KONINT==XXN'INT-.		;;INDEX TO CLEAR AND SET INTERRUPT CONSO FLAGS
				;; FROM DEV. DEP. CODE
XX'X'CB:!
IFE FTAUTC,<
	KDBNAM (\$KON)
>
	PHASE	0		;;CHANGE PHASE SO CAN DEFINE ALL SYMBOLS
				;; RELATIVE TO BEGINNING OF KONTROLLER
				;; DATA BLOCK. ALSO A CHECK TO BE SURE ALL
				;; KONTROLLER DATA BLOCKS ARE DEFINED THE
				;; SAME WAY.
KONBSY:!			;;(0) LH = KONTROLLER BUSY FLAG (SIGN BIT)
				;;MUST BE WORD 0 SO SKIPL @UNIKON(U) WILL TEST
				;;AS OF 18-OCT-83 NO ONE APPEARS TO DO THIS, SO
				;; THE ABOVE COMMENT MAY NO LONGER BE VALID
	KOPBSY==400000		;;KONTROLLER IS BUSY WHEN SET
IFN FTCIDSK,<
	KOPBND==:1		;;THIS KON ALREADY BOUND (ONCE ONLY)
>
IFNDEF XX'MNU,<XX'MNU==^D8>	;;DEFAULT MAXIMUM NUMBER OF UNITS ON KONTROLLER
KONMUN:!XX'MNU-1		;;(0) RH = MAXIMUM UNIT NUMBER ON KONTROLLER
KONTBP:!			;;(1) AOBJN POINTER TO KONTAB FOR THIS KONTROLLER
	-XX'MNU,,XX'KNTB+IFE FTAUTC,<XX'X'CB> ;;(AUTCON WILL FILL IN RH)
KONCAM:!			;;(2) BIT MAP OF CPUS WHICH CAN ACCESS THIS KONTROLLER
				;;MUST BE FULL WORD
	IFE FTAUTC,<1_XXN'CPU>	;;ONLY ONE CPU FOR NON-CI DISKS
	IFN FTAUTC,<0>		;;(AUTCON FILLS THIS IN)
KONIIO:!EXP XX'IIOF		;;(3) OFFSET TO I/O INSTRUCTIONS
KONCOM:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD -CCWMAX,XX'X'CB+KONLST ;;LH=-NO. WORDS ALLOCATED FOR CHAN COMMAND LIST
				;; [DEFINED AT MONGEN TIME]
				;; (SPACE IS IN KON DATA BLOCK BELOW)
				;; RH=1ST. ADR. OF CHAN COMMAND LIST IN KON DATA BLOCK
>
KONLST:!BLOCK CCWMAX		;;CHANNEL COMMAND LIST GOES HERE
				;; (NOT IN CHAN. DATA BLOCK IN CASE TWO KONTROLLERS
				;;  SHARE SAME CHANNEL & MONGEN WASN'T TOLD PROPERLY
KONCNT==:KONLST			;NO OF WORDS IN XFER ON FORMAT
	XWD	ZERO18,ZERO18	;;GUARANTEED END OF COMMAND LIST WORD

KONNXT::!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
				;;LINK TO NEXT KDB IN SYSTEM
IFE <$KON-TOTKON+1>,<0>
IFN <$KON-TOTKON+1>,<KDBLNK (\<$KON+1>)>
$KON==$KON+1
>

;;ENTRY POINTS INTO KONTROLLER TYPE DEPENDENT CODE:
;;INDIRECT AND INDEX FIELDS MUST BE 0 SINCE PUSHJ P,@KONYYY(J)
;; IS USED TO CALL

EXTERN	XX'XRED,XX'XWRT,XX'XRDS,XX'XWTS,XX'XPOS,XX'XUPA,XX'XCPY,XX'XRCL,XX'XSTP
IFE FTAUTC,<
IFE M.KS10,<
EXTERN	LOCOCW
IFE M.'XXL'T,<
XP XXN'IOC,LOCOCW+$LOCW
$LOCW==$LOCW+4
>
IFN M.'XXL'T,<
XP XXN'IOC,XXN-540+.E0MP##+XXN'CPU*2000 ;FOR RH20S RP0T=1, RP1T=2,.....)
>
>;END IFE M.KS10
IFN M.KS10,<
XP XXN'IOC,0
>
>	;END IFE FTAUTC

KONRED:!BYTE (3)0(6)TYP'XX(4)0(5)ZERO5(18)XX'XRED  ;;ENTRY POINT TO READ
KOBPI==KONRED			;;PI CHANNEL THIS KONTROLLER IS ASSIGNED TO-WORD ADR.
	KOSPI==^D3			;;BYTE SIZE
	KONPI==^D2			;;BYTE PTR POS.
KOBKTP==KONRED			;;KONTROLLER TYPE - WORD ADDRESS
	KOSKTP==^D6		;;BYTE SIZE
	KONKTP==^D8		;;BYTE PTR POS.
KONRDS:!BYTE (3)0(6)NN(4)0(5)ZERO5(18)XX'XRDS  ;;ENTRY POINT TO READ, STOP ON ERR
KOBKNM==KONRDS			;KONTROLLER NUMBER - WORD ADDRESS
	KOSKNM==^D6		;;BYTE SIZE
	KONKNM==^D8		;;BYTE PTR POS.
	INTERN KONRDF,KONWTF,KONRDC,KONWTC
KONRDF:!XWD ZERO5,XX'XRDF##	;;ENTRY POINT TO READ HEADER AND DATA
KONRDC:!XWD	XX'RDC!ZERO5,XX'XRDC##	;;ENTRY POINT TO READ IN 10/11 COMPAT. MODE

KONWRT:!XWD ZERO5,XX'XWRT	;;ENTRY POINT TO WRITE
KONWTS:!XWD ZERO5,XX'XWTS	;;ENTRY POINT TO WRITE,STOP ON ERR
IFN FTCIDSK,<
	KONCNA==:KONWTS		;;CREDITS NOT AVAILABLE
	KOPCNA==:(1B0)		;; DON'T QUEUE ANYTHING MORE
				;; MUST BE SIGN BIT
>
KONWTF:!XWD ZERO5,XX'XWTF##	;;ENTRY POINT TO WRITE FORMAT
KONWTC:!XWD XX'RDC!ZERO5,XX'XWTC##  ;;ENTRY POINT TO WRITE IN 10/11 COMPAT. MODE

	INTERN	KONUNL
KONUNL:!XWD XX'UNL!ZERO5,XX'XUNL##  ;;ENTRY POINT TO UNLOAD A DRIVE

KONPOS:!XWD XX'FIX!ZERO5,XX'XPOS ;;ENTRY POINT TO POSITION
				;;BIT 0=1 IF FIXED HEAD DEV
	KOPPWX==:200000
				;;BIT 1=1 IF CAN SEEK WHILE XFER IN PROGRESS
	OPRED==0			;;READ - FUNCTION CODE ARG TO FILINT
	OPWRT==1			;;WRITE - FUNCTION CODE ARG TO FILINT
	OPRDS==2			;;READ & STOP ON ERROR - FUNCTION CODE ARG TO FILINT
	OPWTS==3			;;WRITE & STOP ON ERROR - FUNCTION CODE ARG TO FILINT
	OPPOS==4			;;POSITION - FUNCTION CODE ARG TO FILINT
	OPPPOS==4			;;BIT POSITION FOR POSITION FUNCTION
				;; MUST BE UNIQUE. IE THIS BIT=0 IN ALL OTHER FNCS.
	OPRCL==7			;;RECALIBRATE - FUNCTION CODE ARG TO FILINT
	INTERN KONLTM
IFNDEF XX'MX,<XX'MX==0>
KONLTM:!XX'MX+XX'XLTM##	;;ENTRY POINT TO RETURN TIME TO BEGINNING OF TRANSFER
				;; I.E. LATENCY TIME
				;;BITS 1-12 UNUSED
IFN FTCIDSK,<
	KOPMX==1B0		;;DRIVE CAN DO MULTIPLE XFERS AT SAME TIME
	KONMX==:KONLTM
>
KONUPA:!XWD ZERO5,XX'XUPA	;;ENTRY POINT TO TEST IF KONTROLLER IS ON-LINE
KONDWN==KONUPA			;;BIT0=1 IF KONTROLLER IS DOWN - WORD ADDRESS
	KOPDWN==400000		;; THE BIT (SET BY KONCHK - NOT BY XX'XUPA)
				;;KONTROLLER WAS OFF-LINE WHEN SYSTEM STARTED
				;; AND OPERATOR COULD NOT PUT IT ON-LINE
				;; SKIP RETURN IF YES, NO SKIP IF NOT
	KOPWHL==200000		;;WRITE-HEADER-LOCKOUT SWITCH IS "WRONG"
KONMPS==:KONUPA			;;WORD OFFSET TO TEST KOPMPS BIT
	KOPMPS==:100000		;;THIS KDB REPRESENTS A MICROCODED
				;;DISK CONTROLLER AND THE MICROPROCESSOR
				;;HAS STOPPED.
KONCPY:!XWD XX'CPY!ZERO5,XX'XCPY	;;ENTRY POINT TO DETERMINE TYPE & CAPACITY OF UNIT
				;;BIT 0=1 IF KONTROLLER MUST BE IDLE TO DETERMINE UNIT TYPE
	KOPUHE==200000		;;UNIT HAD ERROR OF ANY KIND - LH T4 VALUE
	KOPNSU==100000		;;NO SUCH UNIT - LH T4 VALUE
	KOP22B==40000		;22-BIT CHANNEL
KONRCL:!XWD ZERO18,XX'XRCL	;;ENTRY POINT TO RECALIBRATE THIS UNIT
				;; NO-SKIP IN UNIT DOES NOT RECALIBRATE OR IS BAD
				;; SKIP RETURN IF RECALIBRATE STARTED OK
IFN FTAUTC,<XXN'CPU==0>
KONSTP:!BYTE (13)0(5)0(18)XX'XSTP ;;ENTRY POINT TO STOP A HUNG UNIT
				;; AND NO-SKIP IF CAN'T, SKIP IF CAN
IFN FTAUTC,<
KONCFG::!EXP	XX'XCFG##		;ENTRY POINT TO AUTO-CONFIGURE IF MULTIPLE DRIVES
				; ON A UNIT (EG RP20)
>
KONCUA:!XWD ZERO18,0		;;CURRENT UNIT DATA BLOCK ADDRESS DOING
				;; DATA TRANSFER (OR LAST ONE)
KONIOC:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD ZERO18,XXN'IOC	;;CONTAINS ADR. OF LOWER CORE CHANNEL
>
				;; PAIR FOR THIS PHYSICAL KONTROLLER
				;; (DIFF. PAIR FOR EACH KONTROLLER SO NO
				;;CHANNEL CONFLICT IF RECONFIGURE CHANNELS)
				;;ON KS10--CONTAINS ENDING TRANSFER ADDRESS AS
				;;REPORTED BY CONTROLLER
KONCHN:!XWD ZERO5,THSCCB	;;ADDRESS OF CHANNEL DATA BLOCK TO WHICH THIS KON
				;; CONNECTED (@USED TO TEST CHANNEL BUSY)
KONPTR:!XWD ZERO5,XX'X'CB+XX'KNTB(P3) ;;USED TO PICKUP UNIT DATA BLOCK ADDRESS
				;; GIVEN PHYSICAL UNIT NUMBER IN AC P3. (@ USED)
KONDMP:!EXP	0		;;PLACE TO STORE DEVDMP WHEN STARTING DUMP-
				;; MODE IO (USED IN ERROR RECOVERY)
INTERN	KONERR,KONECC,KONRRG
EXTERN	XX'XERR,XX'XECC
KONERR:!XWD XX'OFS!ZERO5,XX'XERR	;;ERROR RECOVERY PROGRAM IN KONTROL ROUTINE
KONECC:!XWD ZERO5,XX'XECC	;;GENERATE ECC MASK, POSITION
KONRRG:!XWD ZERO5,XX'XREG##	;READ DRIVE REGISTERS
IF2 <IFNDEF XX'XCCM,<EXTERN XX'XCCM>>
IF2 <IFNDEF XX'XALV,<EXTERN XX'XALV>>
IF2 <IFNDEF XX'XRLD,<EXTERN XX'XRLD>>
IF2 <IFNDEF XX'XEDL,<EXTERN XX'XEDL>>
IF2 <IFNDEF XX'XSEC,<EXTERN XX'XSEC>>
KONCCM::!XWD ZERO5,XX'XCCM	;COMPUTE DISTANCE FROM CYLINDER
KONALV::!XWD ZERO5,XX'XALV	;ENSURE KONTROLLER HAS A PIA
KONRLD::!XWD ZERO5,XX'XRLD	;RELOAD DISK CONTROLLER
KONEDL::!XWD ZERO5,XX'XEDL	;ENABLE/DISABLE MICROCODE LOADING
KONSEC::!XWD ZERO5,XX'XSEC	;ONCE PER SECOND CALL


;THESE MUST BE THE LAST LOCATIONS IN THE KDB BEFORE KONTROLLER-DEPENDENT STUFF
KONECR:!0			;;CONTROL REG ON ERROR
KONEDB:!0			;;DATA BUFFER REG ON ERROR
KONREG:!XX'ERNO			;;NUMBER OF DRIVE REGISTERS TO SAVE ON ERR
KONEBK:!BLOCK	XX'ERNO		;;WHERE TO SAVE THEM
XX'KNTB:!			;;SPACE FOR ADDRESSES OF UNIT DATA BLOCKS
IFN FTAUTC,<
	BLOCK	XX'MNU
>
IFE FTAUTC,<
	$U1=0			;; RH=ADDRESS OF UNIT DATA BLOCKS
	REPEAT	XX'X'UN,<	;; INDEX INTO THIS TABLE IS PHYSICAL
	UNITAD	(\$U1,XX'X)	;; UNIT NO. WITHIN KONTROLLER.
	$U1==$U1+1>		;;
	BLOCK	XX'MNU-$U1	;;RESERVE FOR MAX. POSSIBLE NO. OF
				;; PHYSICAL UNITS ON ALL DIGITAL KONTROLLERS
>
XX'IIOF:!			;;OFFSET TO I/O INSTRUCTIONS (STORED IN KONIIO)
				;;ADD IO INSTRUCTIONS AND ALL DATA LOCATIONS HERE:

>		;;END KONKON MACRO (SAME FOR ALL KONTROLLERS)

	$HIGH
;;BYTE POINTERS
KOYPI:	POINT	KOSPI,KOBPI(J),KONPI	;;PI CHANNEL THIS KONTROLLER ASSIGNED TO
KOYKTP::POINT	KOSKTP,KOBKTP(J),KONKTP	;;KONTROLLER TYPE
KOZKTP::POINT	KOSKTP,KOBKTP(P3),KONKTP ;;KONTROLLER TYPE
KOYKNM::POINT	KOSKNM,KOBKNM(J),KONKNM ;;KONTROLLER NUMBER
IFN FTAUTC,<
KOZKNM::POINT	KOSKNM,KOBKNM(T2),KONKNM ;;KONTROLLER NUMBER
>; END IFN FTAUTC
	$LOW

DEFINE	UNITAD (N,SYM)<
	XWD	ZERO5,SYM'N'CB>

DEFINE KDBLNK(N) <D'N'KDB,,0>
DEFINE KDBNAM(N) <D'N'KDB:>

;THESE MUST BE THE LAST LOCATIONS IN THE KDB BEFORE KONTROLLER-DEPENDENT STUFF
SUBTTL	LBN - LOGICAL DISK BLOCK NUMBERS WITHIN UNIT(NOT STR) ASSIGNED AS ASSEMBLY TIME

;THERE ARE AS FEW OF THESE AS POSSIBLE.  THEY CAN BE CHANGED AT MONGEN TIME
;BY DEFINING SYMBOLS
;BLOCK 0 WITHIN A UNIT IS NOT USED SINCE IT IS THE MOST LIKELY BLOCK TO BE
;WRITTEN IF FILSER HAS A BUG.  FILSER WILL HALT IF BLOCK 0 IS READ OR WRITTEN
; EXCEPT IF FILE BEING ACCESSED IS HOME.SYS OR SUPER USETI 0

	INTERN	LBNHOM,LB2HOM,LBOBAT,LBOISW

IFNDEF LBNHOM,<LBNHOM==^D1>	;LOGICAL BLOCK NO. OF HOME BLOCK

IFNDEF LB2HOM,<LB2HOM==^D10>	;2ND LOGICAL BLOCK # OF HOME BLOCK (THE REDUNDANT ONE)
				; THIS IS THE DEFAULT FOR ALL UNITS
				; (THE REDUNDANT ONE)
				; PUT ON A DIFFERENT SURFACE OR RP01 AND RP02 FROM
				; FIRST HOME BLOCK.
LBOBAT==1			;# OF BLOCKS BOTH BAT BLOCKS ARE OFFSET FROM HOME BLOCK
LBOISW==2			;# OF BLOCKS INITIAL SWAPPING
				; SAT OFFSET FROM HOME BLOCK

;BLOCKS FOR BOOTS:
IFNDEF FBOOTB,<XP FBOOTB,4>	;FIRST LOGICAL BLOCK
				; IN EACH UNIT FOR BOOTS
XP NBOOTB,4			;NO. OF BLOCKS IN BOOTS(DISK BOOTSTRAP)
XP MNBOOT,-NBOOTB		;MINUS NO. OF BLOCKS IN BOOTS
SUBTTL	MFD	WORD POSITIONS IN MASTER FILE DIRECTORY
;PREFIX "MFD"
;THIS IS ALSO THE USER FILE DIRECTORY FOR PROJECT 1, PROGRAMMER 1

	INTERN	MFDNAM,MFDEXT,MFDSIZ

MFDNAM==0	;OCTAL (NOT SIXBIT) NAME OF UFD.  THIS IS PROJECT-PROGRAMMER
		; NUMBER. IN COMMENTS THIS IS WRITTEN AS [PROJ,R]. UFD
MFDEXT==1	;LH=UFD IN SIXBIT (USUALLY)
		;RH=COMPRESSED UFD POINTER (CUP) CONTAINS UNIT AND LOGICAL BLOCK
		; WITHIN UNIT OF FIRST RETIREVAL BLOCK OF FILE.  TO CONVERT
		; FROM A CUP TO UNIT AND LOGICAL BLOCK NUMBER OF FIRST RIB:
		;	SEARCH FILE STRUCTURE TABLE AND FIND
		;	N'TH ENTRY N=1,2...M) WHICH IS FIRST ENTRY WHOSE VALUE
		;	EQUAL TO OR LESS THAN CUP.  (N-1) IS THEN
		;	THE UNIT NUMBER IN THAT FILE STRUCTURE
		;	SUBTRACTING THE (N-1)ST ENTRY(=0, ENTRY = 0) GIVES
		;	CUP INDEX RELATIVE TO THE N'TH UNIT.  MULTIPLYING
		;	BY THE CUP CONVERSION FACTOR FOR UNIT N IN THIS
		;	FILE STRUCTURE GIVES LOGICAL BLOCK NUMBER, WHEW!
IFNDEF MFDSIZ,<MFDSIZ==^D30>	;NO. OF BLOCKS FOR INITIAL MFD SET BY REFRESHER
				; INCLUDING RIBS.  MAKE IT LARGE ENOUGH SO MFD IS
				; COMPLETELY CONTAINED IN ONE GROUP SO ONLY ONE
				; RETRIEVAL POINTER(FOR SPEED).  FILSER WILL
				; HANDLE MULTIPLE GROUP MFD
SUBTTL	NMB FILE NAME DATA BLOCK
;USED TO REMEMBER FILE NAMES IN A PROJECT-PROGRAMMER NUMBER ACROSS
; ALL FILE STRUCTURES.

;*************
;WORD 0---------------------------------------
NMBNAM==:CORNAM		;SIXBIT FILE NAME LEFT JUSTIFIED

;WORD 1---------------------------------------
NMBPPB==:CORLNK		;LH=CORE ADR.(ACCROSS POINTER) OF NEXT NAME BLOCK IN THIS
			; PROJ-PROG NUMBER
	NMPUPT==:2	;IF THIS BIT IS ON IN AN NMBPPB, THE ADDRESS-2 IS
			; THE LOC OF THE FATHER SFD FOR THIS LIST OF NMB'S
			; (IT IS ONLY ON IN THE LAST NMB IN THE LIST)

	NMPSFU==:1	;BIT ON (IN AC, NEVER IN CORE) IF THE LOC RETURNED
			; (BY UFORSF) IS AN SFD A.T., OFF IF THE LOC IS A UFB
DIFAWU==:ACCWRT-NMPSFU	;DIFFERENCE BETWEEN A.T.LOC+NMPSFU AND ACCWRT

;WORD 2---------------------------------------
NMBRNG==:2		;LH=POINTER TO AN NMB-LIST OF FILES
			; UNDER THE SFD. 0 IF NOT AN SFD
DIFNMC==:NMBRNG-CORLNK
NMBCFP==:2		;RH=COPY OF COMPRESSED FILE POINTER. I.E., COPY OF
			; SECOND WORD OF PAIR IN UFD.(COMPRESSION CONTAINS
			; LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE)

;WORD 3---------------------------------------
NMBACC==:3		;LH=CORE ADR (DOWNWARD POINTER) OF FIRST ACCESS
			; BLOCK IN ACCESS RING WITH THIS FILENAME/PROJ-PROG.
			; IF RING IS EMPTY, LH NOT 0. INSTEAD IT POINTS
			; TO ITSELF-CORLNK.  IN THIS WAY NO SPECIAL
			; CHECKING IS NEED TO ADD OR DELETE ACCESS BLOCKS
			; FROM RING. IT ALSO PROVIDES A SIMPLE CHECK FOR
			; AN EMPTY RING, SINCE TWO LOW ORDER BITS=0
			; IF AN ACCESS BLOCK ADDRESS,=CORLNK IF EMPTY.
DIFNAL==:NMBACC-ACCNMB	;DIFFERENCE BETWEEN LOC. OF DOWNWARD POINTER IN
			; NMB BLOCK AND ACCROSS POINTER IN ACC BLOCK. USED
			; FOR SEARCHING RING.
NMBEXT==:3		;RH=LEFT JUSTIFIED SIXBIT FILE EXTENSION


;WORD 4---------------------------------------
NMBFSN==:CORFSN		;FSN # - WORD ADR.
	NMSFSN==:COSFSN	;BYTE SIZE
	NMNFSN==:CONFSN	;BYTE PTR. POS.
NMYFSN==:COYFSN		;RIGHT MOST BIT
			; GOES WITH (NMBCFP).
NMXFSN==:COXFSN


;WORD 5---------------------------------------
NMBKNO==:CORKNO		;KNOW WHETHER FILE EXISTS OR NOT IN STR N-WORD ADR.
			; BIT NMNKNO-N=1 IF KNOW FOR FS. N
	NMSKNO==:COSKNO	;BYTE SIZE
	NMNKNO==:CONKNO	;BYTE PTR. POS.
	NMPKNO==:COPKNO		;RIGHT MOST BIT
NMYKNO==:COYKNO
NMZKNO==:COZKNO


;WORD 6---------------------------------------
NMBYES==:CORYES		;FILE OR UFD DEFINITELY EXISTS IN FILE STRUCTURE N
			; IF BIT NMPYES-N=1 -WORD ADR. CORRESPONDING BIT
			; IN NMBKNO=1 TOO.
	NMSYES==:COSYES	;BYTE SIZE
	NMNYES==:CONYES	;BYTE PTR. POS.
	NMPYES==:COPYES	;RIGHT MOST BIT

;WORD 7---------------------------------------
NMBCNT==:7		;USE-COUNT FOR THE NMB
;PATH. UUO PARAMETERS
PT.SCN==:3			;SCAN SWITCH
PT.SXS==4			;SEARCH EXP SYS
PT.SYS==10			;SEARCH SYS
PT.DTL==:40			;SET SYS, NEW BIT DON'T TOUCH LIB

PT.LIB==:20			;SEARCH LIB
PT.IPP==:40			;IMPLIED PPN
PT.JSL==:100			;JOB SEARCH LIST
PT.ASL==:200			;ALL SEARCH LIST
PT.SSL==:300			;SYS SEARCH LIST
PT.DLN==:1000			;DEVICE WAS LOGICAL NAME
PT.EDA==:2000			;DEVICE WAS LOGICAL NAME AND ERSATZ DEVICE
PT.FFS==:4000			;FILE FOUND BY SCANNING SFDS
PT.FFL==:10000			;FILE FOUND IN LIB OR SYS

;INTERNAL FLAG BITS FOR SIXBIT OR CHANNEL ARG
PT.ESZ==:(1B1)			;SET IF DEVICE NOT BOTH A LOGICAL NAME AND
				;ERSATZ DEVICE
PT.GEN==:(1B2)			;SET IF DEVICE IS NOT GENERIC DSK
PT.PHO==:PHONLY			;SET IF THIS UUO IS PHYSICAL ONLY
SUBTTL	PTR:	COPY OF RETRIEVAL POINTERS KEPT IN CORE FOR UPDATE FILES

PTRSYS==:0			;LH=LINK TO NEXT IN-CORE COPY
PTRAT==:PTRSYS			;RH=ADDR OF ACCESS TABLE WHICH "OWNS" POINTERS
PTRFLR==:1			;COPY OF DEVFLR FOR 1ST POINTER IN GLUMP
PTRRIB==:2			;COPY OF DEVRIB
PTRFUN==:3			;LH=COPY OF DEVFUN
PTRRLC==:PTRFUN			;RH=DEYRLC BYTE, DEVRSU PLUS SOME BITS
	PTPLPC==:400000		;BIT=1 IF DEPLPC IS ON IN DDB
PTRDAT==:4			;1ST POINTER
PTRDND==:PTRDAT+PTRLEN-1	;LAST POINTER
PTRCOR==:<PTRDND+1+3>/4
	$HIGH
PTYRSU::POINT	7,PTRRLC(T2),28
	$LOW
SUBTTL	PPB - PROJECT PROGRAMMER NUMBER DATA BLOCK
;USED TO ORGANIZE FILES REMEMBERED IN MEMORY ON PPN BLOCK FOR EVERY
; PROJECT-PROGRAMMER NUMBER IN SYSTEM WHICH HAS SOME ACTIVE FILES
; SETUP WHENEVER A NEW PROJECT-PROGRAMMER NUMBER IS LOOKED UP OR
; ENTERED.


;WORD 0---------------------------------------
PPBNAM==:CORNAM		;LH=PROJECT NUMBER (RIGHT JUSTIFIED OCTAL)
			; OR LEFT JUSTIFIED SIXBIT (PROJ NAME)
			;RH=PROGRAMMER NUMBERS RIGHT JUSTIFIED OCTAL)
			; OR LEFT JUSTIFIED SIXBIT (PROJ INITIALS)

;WORD 1---------------------------------------
PPBSYS==:CORLNK		;LH=CORE ADDRESS(ACCROSS POINTER) OF NEXT PPN BLOCK IN SYSTEM

;WORD 2---------------------------------------
PPBUFB==:2		;LH=CORE ADDRESS OF FIRST UFB BLOCK WITH THIS
			; PROJECT-PROGRAMMER NUMBER.  THERE IS ONE UFB
			; BLOCK FOR EVERY FILE STRUCTURE IN WHICH THIS
			; PROJECT-PROGRAMMER NUMBER HAS A UFD
DIFPBC==:PPBUFB-CORLNK

;WORD 3---------------------------------------
PPBNMB==:3		;LH=CORE ADDRESS OF FIRST FILE NAME BLOCK (NMB)
			; WITH THIS PROJECT-PROGRAMMER NUMBER
			;RH=BIT PPPYES-N=1 IF UFD EXISTS (CLOSED IN MFD) IN
			; NTH FILE STRUCTURE IN SYSTEM.  IF BIT PPPYES-N=0
			; EITHER UFD DOES NOT EXIST OR DO NOT KNOW.
			; SEE BIT COPYES-N IN PPBUFB.
	DIFPNL==:PPBNMB-NMBPPB	;DIFFERENCE BETWEEN DOWNWARD POINTER IN PPB BLOCK
			; AND ACCROSS POINTER IN NMB BLOCK
PPBNLG==:3		;PROJ R NO. NOT LOGGED IN - WORD ADR.
	PPSNLG==^D1	;BYTE SIZE
	PPNNLG==^D35	;BYTE PTR. POS.
	PPPNLG==:1	;PROJ R NO. NOT LOGGED IN - THE BIT=0 IF NOT
			; USED TO FLUSH PPB IMMEDIATELY WHEN LAST FILE
			; BECOMES DORMANT IN PPB

;WORD 4---------------------------------------
PPBCNT==:4		;USE-COUNT FOR THE PPB
;WORD 5---------------------------------------
PPBKNO==:CORKNO		;KNOW WHETHER UFD DOES OR DOES NOT EXIST IN
			; FILE STRUCTURE N-WORD ADR. BITS 18-31 BIT PPPKNO-N=1 IF
			; MONITOR KNOWS(HAS READ UFD),=0 IF HAS NOT.
	PPSKNO==:COSKNO	;BYTE SIZE
	PPNKNO==:CONKNO	;BYTE PTR. POS.
	PPPKNO==:COPKNO	;RIGHT MOST BIT


;WORD 6---------------------------------------
PPBYES==:CORYES		;UFD DEFINITELY EXISTS IN FILESTRUCTURE - WORD ADR.
	PPSYES==:COSYES	;BYTE SIZE
	PPNYES==:CONYES	;BYTE PTR. POS.
	PPPYES==:COPYES	;RIGHT MOST BIT

;WORD 7---------------------------------------
PPBLOK==:7		;BIT N+1 =1 IF UFD FOR FSN N IS INTERLOCKED

SUBTTL	RIB	WORD POSITIONS FOR RETRIEVAL INFORMATION BLOCK
;THE FIRST "RIBDDB" LOCATIONS OF THE RIB ARE KEPT IN CORE IN THE
; DDB WHILE THE FILE IS ACTIVE, THEY ARE FLAGGED (DDB).
;SOME OF THE SAME INFORMATION ALSO APPEARS IN THE ACCESS TABLE ENTRY
; THEY ARE FLAGGED (ACT).
;THE ORDER OF THESE ARGUMENTS CORRESPONDS EXACTLY TO THE EXTENDED LOOKUP,
; ENTER, RENAME BLOCKS.  WORDS APPEARING IN EXTENDED LOOKUP, ENTER, RENAME
; ARE FLAGGED WITH (ENT). SEE LEVEL D PROJECT SPECIFICATION FOR MORE
; INFORMATION ON LOOKUP/ENTRY/RENAME ARGUMENTS AND VALUES.
;A FEW EXTRA WORDS WHICH HAVE MEANING FOR UFD'S ONLY HAVE BEEN ADDED
; TO ALL FILES.  THEY HAVE NO MEANING FOR DATA FILES.  THESE WORDS ARE
; FLAGGED (UFD-ONLY).
;ALL QUANTITIES ARE IN BLOCKS EXCEPT THE FILE SIZE (RIBSIZ), WHERE
;USER MAY WANT TO KNOW NO. OF DATA WORDS IN LAST BLOCK

	INTERN	RIBFIR,RIBPPN,RIBNAM,RIBEXT,RIBPRV,RIYPRV,RIBATT,RIBLAD,RIBDED
	INTERN	PRTEXC,PRTRED,PRTAPP,PRTUPD,PRTWRT,PRTREN,PRTCPR,RIRXLK,RIRXCR,RIRXRD,RIPPAL
	INTERN	RIBSIZ,RIBVER,RIBSPL,RIBEST,RIBALC,RIBPOS,RIPNCK,RIBLEN,RIBACT,RIBACS
	INTERN	RIBNXT,RIBPRD,RIBMTA,RIBUFD,RIBQTF,RIBQTO,RIBQTR,RIBUSD,RIPDIR,RIPCRH
	INTERN	RIBSTS,RIBFLR,RIBXRA,RIBTIM,RIPLOG,RIPHRE,RIPHWE,RIPSCE,RIPBDA,RIPBFA
	INTERN	RIBENT,MRIBLN,RIBWN1,RIBCOD,CODRIB,RIBSLF,RIBELB,RIBEUN,RIBNBB,RIPNUB
	INTERN	RIPNDL,RIPNFS,RIBAUT,RIBLNA,RIBFT1,RIBNCA,RIBDEV,RIBPCA,RIPABC,RIPCMP
IFNDEF	MLACTS,<XP MLACTS,^D39>	;MAXIMUM LENGTH OF THE ACCOUNT STRING
				; IF NOT DEFINED, 39 CHARACTERS
IFG	MLACTS-^D39,<XP MLACTS,^D39>  ;MAXIMUM LENGTH IS 39 CHARACTERS
IFL	MLACTS,<XP MLACTS,>
IFG	MLACTS,<XP ACTSTL,MLACTS/^D5+1>	;LENGTH OF ACCOUNT STRING IN WORDS
IFE	MLACTS,<XP ACTSTL,0>

RIBFIR==0	;CONTAINS AOBJN POINTER TO FIRST RETRIEVAL POINTER IN THIS RIB
		; I.E., LH=-MAX. POSSIBLE NO. POINTERS, RH=REL ADR OF FIRST PTR
RIBPPN==1	;(ACT)(DDB) (ENT) PROJECT,PROGRAMMER # IN OCTAL OR PROJECT
		; NAME (3 CHAR SIXBIT LEFT JUSTIFIED IN LH) OR PROGRAMMER
		; INITIALS (3 CHAR SIXBIT LEFT JUSTIFIED IN RH) (AS LOOKUP ENTER
		; RENAME ARG APPEARS AT RIBSIZ POSITION) OF UFD IN WHICH
		; THIS FILE APPEARS.  NEVER CONVERTED TO DECIMAL BY MAN OR MACHINE.
RIBNAM==RIBPPN+1;(ACT)(DDB) (ENT) 6 CHAR FILE NAME IN SIXBIT (OR OCTAL PROJECT
		; PROGRAMMER NO. OR SIXBIT IF THIS FILE IS MDF OR UFD).
RIBEXT==RIBNAM+1;(ACT)(DDB) (ENT) LH 3 CHAR FILE EXTENSION IN SIXBIT; BITS 24-35
		; ACCESS DATE. BYTE=RIBACD.
RIBPRV==4	;(ACT)(DDB) (ENT)FILE ATTRIBUTES 0-8 ACCESS CODE, 9-12 MODE, 13-23
		; CREATION TIME IN MINUTES SINCE MIDNIGHT, 24-35 CREATION DATE
RIBATT==RIBPRV	;ANOTHER SYMBOL FOR SAME LOCATION
	RISPRV==^D9
	RINPRV==^D8

	$HIGH
RIYPRV:	POINT	RISPRV,RIBPRV+1(T3),RINPRV	;BYTE POINTER TO ACCESS PRIVILEGES
	$LOW
		;ACCESS PRIVILEGES DEFINED IN INCREASING ORDER OF POWER FOR
		; DATA FILES (IE NON-DIRECTORY)
		; BITS 0-2 FOR ANY JOB WITH MATCHING PROGRAMMER NO.
		; (NO MATTER WHAT THE PROJECT)
		; BITS 3-5 FOR ANY JOB WITH MATCHING PROJECT NO.
		; (NO MATTER WHAT THE PROG NO.
		; BITS 6-8 NEITHER PROJ NOR PROG MATCH
		;PRIVILEGE COMES STORED BY MONITOR - COMPLEMENTED FOR USER PROGRAM
	PRTEXC==1	;EXECUTE ONLY-IE GET, R,RUN ACCESS
	PRTRED==2	;READ ONLY
	PRTAPP==3	;APPEND (ALLOCATE, DEALLOCATE, APPEND)
	PRTUPD==4	;UPDATE
	PRTWRT==5	;WRITE (SUPERSEDE,TRUNCATE)
	PRTREN==6	;RENAME (CHANGE ATTRIBUTES, NAME, EXT, DIR)
	PRTCPR==7	;CHANGE PRIVILEGE
;PROTECTION CODES (SEEN BY USER)
	XP	PR.NAF,7	;NO ACCESS TO FILE
	XP	PR.EXC,6	;EXECUTE ONLY
	XP	PR.RED,5	;READ
	XP	PR.APP,4	;APPEND (ALLOCATE, DEALLOCATE, APPEND)
	XP	PR.UPD,3	;UPDATE
	XP	PR.WRT,2	;WRITE (SUPERSEDE, TRUNCATE)
	XP	PR.REN,1	;RENAME (CHANGE ATTRIBUTES, NAME, EXT, DIR)
	XP	PR.CPR,0	;CHANGE PROTECTION
		;ACCESS PROVILEGES FOR DIRECTIORY FILES (RIPDIR SET IN RIBSTS)
		; 3 INDEPENDANT ACCESS PRIVILEGES
		; BITS 0-2 FOR ANY JOB WITH MATCHING PROG. NO, 3-5 MATCHING PROJ
		; 6-8 NEITHER MATCHING
	RIRXLK==4	;1 ALLOWS LOOKUPS IN DIRECTORY
	RIRXCR==2	;1 ALLOWS CREATES IN DIRECTORY
		; (IE ADD NAMES WHICH ARE NOT ALREADY THERE)
	RIRXRD==1	;1 ALLOWS DIRECTORY TO BE READ AS A DATA FILE
RIBSIZ==5	;(ACT)(DDB) (ENT) LH: WRITTEN LENGTH IN WORDS OR
		; BOTH HALVES POSITIVE LENGTH IN WORDS AS 36 BIT QUANTITY.
		; MAYBE LESS THAN NO. OF WORDS ALLOCATED
RIBVER==RIBSIZ+1;(ENT) VERSION NUMBER (LIKE JOBVER)
		; LH=PROGRAMMER NUMBER LAST MAKING CHANGE
		; RH=OCTAL VERSION NUMBER NEVER CONVERTED TO DECIMAL
		; BY MAN OR MACHINE.
RIBSPL==7	;(ENT) POSSIBLE USER FILE NAME WHEN FILE BEING SPOOLED
RIBEST==10	;(ENT) ESTIMATED LENGTH IN CORE & NR. OF BLOCKS
RIBALC==11	;(ENT) # OF BLOCKS ALLOCATED TO FILE INCLUDING BOTH RIBS.
RIBPOS==RIBALC+1;(ENT) LOGICAL BLOCK OF # WITHIN STR OF LAST ALLOCATED GROUP OF FILE
		; OR 0 IF LAST ALLOCATE DID NOT SPECIFY LOGICAL
		; BLOCK (POSITION)
RIBFT1==13	;ARG SAVED FOR FUTURE FOR DIGITAL TO DEFINE
RIBUNI==:RIBFT1	;(PRIV'D) UNITS WHICH WROTE FILE
		;BITS 10-17 = UNIT
		;BITS 18-20 = KONTROLLER
		;BITS 21-35 = APR SERIAL NUMBER
RIBNCA==14	;UNPRIVILEGED ARG FOR EACH CUSTOMER TO DEFINE
RIBLNA==RIBNCA	;LAST UNPRIVILEGED ARG
RIBMTA==15	;(ENT) 36 BIT TAPE LABEL IF FILE HAS BEEN PUT ON MAGTAPE
RIBDEV==16	;VALUE ONLY-FILE STRUCTURE NAME FILE STARTS ON

RIBSTS==17	;STATUS BITS FOR ALL FILES IN UFD(LH),
		; THIS FILE IN RH

	RIPLOG==400000	;(LH) IF 1 SAYS USER IS LOGGED IN. SET BY LOGIN CUSP
		; RENAME UUO.  SET TO 0 BY LOGOUT CUSP RENAME UUO.
		; BIT CHECKED BY LOGIN IN ORDER TO DETERMINE IF
		; RIBTOT IS TO BE BELIEVED (IF RIBLOG==1) SYSTEM
		; MUST HAVE CRASHED OR BEEN RELOADED WITHOUT LOGGING
		; OUT ALL USERS.
	RIPCHG==:10000	;(LH) FILSER SETS TO 1 IF ANY FILE WRITTEN/RENAMED.
		;CLEARED BY BACKUP.
	RIPDIR==400000	;(RH) 1 IF THIS FILE IS A DIRECTORY FILE (UFD OR MFD)
		; RATHER THAN A DATA FILE. NEEDED TO PROTECT
		; THE SYSTEM FROM THE USER WHO MIGHT TRY
		; TO MODIFY A DIRECTORY AS A DATA FILE
	RIPNDL==200000	;(RH)[NO DELETE] 1 IF THIS FILE CANNOT BY
		; DELETED EVEN BY A PRIVILEGED PROGRAM.  THESE FILES ARE IN
		; SOME SENSE FAKE OR CRUCIAL TO FILE STRUCTURE.
		; EG. HOME.SYS, SAT.SYS, MAINT.SYS, SWAP.SYS,BADBLK.SYS
	RIPDMP==:100000	;(RH) THIS FILE CONTAINS A MONITOR DUMP NOT YET
		; PROCESSED BY THE CRASH COPY PROGRAM
	RIPNFS==40000	;(RH)[NO FAILSAFE] 1 IF THIS FILE SHOULD NOT
		; BE DUMPED BY FAILSAFE BECAUSE IT IS A FUNNY FILE AND
		; SHOULD NOT BE RESTORED OR IS PART OF THE SKELETON
		; FILE STRUCTURE.  (BADBLK.SYS,SAT.SYS,HOME.SYS,SWAP.SYS,MAINT.SYS
		; RECOV.SYS).  (SNAP.SYS, CRASH.SAV, UFD'S AND MFD
		; DO NOT HAVE RIPNFS ON, SO THEY ARE ALL SAVED).
	RIPABC==20000	;(RH) ALWAYS BAD CHECKSUM(SWAP.SYS,SAT.SYS)
	RIPCBS==:10000 	;(RH) COMPRESS BIT SET (RIPCMP) ON ENTRY TO COMPRESSOR
		;USED TO SELECTIVELY NOT CLEAR RIPCMP ON EXIT
	RIPABU==4000	;(LH/RH) ALWAYS BACKUP THIS
		; UFD/FILE.  USED BY BACKUP TO IGNORE ACCESS
		; DATE AND WRITE FILE ANYWAY.
	RIPNQC==2000	;NON QUOTA-CHECKED FILE
	RIPCMP==1000	;(RH) THIS UFD IS BEING COMPRESSED
		; FOR ERROR RECOVERY IF CRASH WITH A JOB
		; IN THE COMPRESSOR SINCE DUPLICATE ENTRIES MAY APPEAR
	RIPSCE==400	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HAD A SOFTWARE
		; CHECKSUM ERROR DETECTED BY MONITOR.(IOIMPM)
	RIPHWE==200	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; WRITE DATA ERROR DETECTED BY MONITOR.(IODTER)
	RIPHRE==100	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE HAS HARD (3 TIMES)
		; READ DATA ERROR DETECTED BY MONITOR.(IODTER)
	RIPRMS==:40	;THIS IS AN RMS FILE
	RIPPAL==20	;(RH) THIS IS A PRE-ALLOCATED FILE
		; SUPERSEDE WILL USE THIS ALLOCATION
		; WHICH ALREADY EXISTS FOR THIS FILE
	RIPBFA==10	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY FAILSAFE
		; WHEN READING MAGNETIC TAPE TO RESTORE TO DISK.
	RIPCRH==4	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE WAS CLOSED AFTER A CRASH
		;  (PRINTED BY LOGIN)
	RIPBDA==1	;(LH/RH) 1 IF ANY FILE IN UFD/THIS FILE IN UFD FOUND BAD BY DAMAGE
		; ASSESSMENT CUSP


	RIPNCK==RIPDIR!RIPABC	;DIRECTORIES HAVE BAD CHECKSUMS
	RIPNDP==:RIPNDL!RIPPAL
	INTERN	IOSHRE,IOSHWE,IOSSCE,IOSERR,IOSMER

;IOSHRE,HWE,SCE ARE S BITS WHICH CORRESPOND TO RIB STATUS BITS
;THEY ARE IN THE SAME POSITIONS AS THE ERROR BITS

IOSHRE==RIPHRE
IOSHWE==RIPHWE
IOSSCE==RIPSCE
IOSERR==IOSHRE+IOSHWE+IOSSCE
IOSMER==-IOSERR-1
RIBELB==20	;LOGICAL BLOCK WITHIN ERROR (SEE RIBEUN)
		; IN WHICH BAD REGION BEGINS. 0 MEANS FILE HAS HAD NO BAD REGIONS
		; BAD REGIONS ARE MARKED ON HARD DATA AND DEVICE ERRORS ONLY(IODTER)
		; DETECTED BY HARDWARE PARITY OR SEARCH HARDWARE.
		; AND SOFTWARE DETECTED ERRORS.
		; DO NOT INVOKE THE BAD REGION MECHANISM(SEE CLOSE).
		;LH=CONI BITS 12-29 ON ERROR (SEE BAFELB)
RIBEUN==21	;LH=LOGICAL UNIT # WITHIN STR ON WHICH ERROR REGION OCCURED (0..)
RIBNBB==RIBEUN	;RH=# OF CONSECUTIVE LOGICAL BLOCKS IN BAD REGION
		; (MAY WANDER OUTSIDE OF THIS FILE ALLOCATION)
RIBQTF==22	;(UFD ONLY) FIRST COME FIRST SERVE LOGGED IN QUOTA IN TOTAL
		; NUMBER OF DATA + RIB BLOCKS (I.E. ALL OVERHEAD BLOCKS TOO
		; EXCEPT NOT UFD + ITS RIB - THAT IS CHARGED TO 1,1) ALLOWED THIS
		; USER IN THIS DIRECTORY IN THIS FILE STRUCTURE WHILE
		; LOGGED-IN.  SET BY LOGIN FROM AUXACC.SYS FILE.  THIS QUANTITY
		; + RIBQTR KEPT IN CORE IN UFB DATA BLOCK

RIBQTO==23	;(UFD-ONLY) LOGGED-OUT QUOTA IN TOTAL NUMBER OF DATA + RIB
		; BLOCKS ALLOWED THIS USER IN THIS DIRECTORY IN THIS STR
		; WHILE LOGGED-OUT.(I.E. ALL OVERHEAD BLOCKS TOO EXCEPT UFD
		; + ITS RIB -  THAT'S CHARGED TO 1,1).  SET BY LOGIN FROM ACCT.SYS
		; FILE (SO LOGOUT WILL NOT HAVE TO SEARCH ACCT.SYS).
		; LOGOUT WILL FORCE USER TO DELETE ENOUGH FILES SO AS TO BE
		; BELOW THIS LIMIT.  THIS QUANTITY IS NOT KEPT IN CORE

RIBQTR==24	;(UFD-ONLY) RESERVED LOGGED IN QUOTA IN TOTAL NUMBER
		; OF DATA + RIB BLOCKS (I.E. ALL OVERHEAD BLOCKS TOO EXCEPT
		; UFD+ITS RIB - THAT'S CHARGED TO 1,1).
		; RESERVED BY ADMINISTRATOR FOR THIS USER
		; IN THIS DIRECTORY IN THIS FILE STRUCTURE WHILE LOGGED IN.
		; THIS QUANTITY PLUS RIBQTF KEPT IN CORE IN UFB DATA BLOCK

RIBUSD==25	;(UFD-ONLY) COUNT OF BLOCKS USED (INCLUDING ALL OVERHEAD BLOCKS)
		; WHEN JOB WAS LOGGED OUT
		; (PROVIDED LOGBIT=0). WRITTEN BY LOGOUT, READ BY LOGIN.
RIBAUT==26	;PROJ-PROG # OF AUTHOR OF FILE, IE USER DOING
		; CREATE OR SUPERSEDE. (USUALLY THE SAME AS OWNER, IE
		; UFD IN WHICH FILE EXISTS, EXCEPT WHEN A FILE
		; IS CREATED OR SUPERSEDED IN SOMEONE ELSES UFD)
RIBNXT==27	;(ENT) SIXBIT NAME OF NEXT FILE STRUCTURE IF THIS FILE IS
		; CONTINUED ON ANOTHER FILE STRUCTURE. 0 IF IT IS ONLY
		; ON ONE STR OR THIS IS LAST SUB-FILE STR
RIBPRD==30	;(ENT) SIXBIT NAME OF PREDECESSOR FILE STR IF THIS
		; SUBFILE IS NOT THE FIRST. 0 IF IT IS FIRST OR ONLY SUBFILE.
RIBPCA==31	;(ENT) PRIVILEGED ARG FOR EACH CUSTOMER TO DEFINE

RIBUFD==32	;(ENT) LOGICAL BLOCK NUMBER WITHIN STR OF UFD DATA BLOCK(RATHER THAN CLUSTER
		; NUMBER) IN WHICH THIS FILE APPEARS.  IF 2 OR MORE BLOCKS
		; IN UFD THIS ENTRY CONTAINS THE PROPER BLOCK POINTER.  USED
		; AT CLOSE AND RENAME TIME IF IN CORE AND USED FOR FAST FILE
		; RECOVERY.

RIBFLR==33	;(ENT) RELATIVE BLOCK NUMBER IN FILE OF FIRST BLOCK IN RIB.  IMPLEMENTED
		;FOR EXTENDED RIBS
RIBXRA==34	;(ENT) (DDB) EXTENDED RIB ADDRESS.  POINTS TO NEXT RIB IN CHAIN.  IF 0 THIS IS
		;THE LAST RIB.  FORMAT IDENTICAL TO DEVRIB IN DDB
RIBTIM==35	;(ENT) CREATION DATE & TIME IN NEW DATE FORMAT
RIBLAD==36	;LAST ACCOUNTING DATE (UFD)
RIBDED==37	;DIRECTORY EXPIRATION DATE (UFD)
RIBACT==40	;AOBJN POINTER TO ACCOUNT STRING
RIBENT==RIBACT  ;LAST ARG OR VALUE ON EXTENDED LOOKUP/ENTER/RENAME

;FIRST RETRIEVAL POINTER STORED HERE
; NO SYMBOL ASSIGNED.  INSTEAD DSKSER MUST LOOK IN RIBFIR
; FOR THIS ADDRESS.  THIS IS SO RETRIEVAL DATA CAN BE ADDED
; TO WITHOUT INVALIDATING PREVIOUSLY WRITTEN DISK PACKS.

		;FORMAT FOR A RETRIEVAL POINTER IN RIB CONTAINS THREE FIELDS
		; DEFINED FOR EACH FILE STRUCTURE AND STORED IN HOME BLOCK.
		;	A - BLOCK COUNT
		;	B - CHECKSUM
		;	C - CLUSTER NUMBER

RIPNUB==400000	;BIT SET IN NEW UNIT PTR. TO INSURE NON-ZERO

RIBWN1==RIBENT+PTRLEN  ;RELATIVE LOCATION OF LAST POINTER TO BE
		; COPIED FROM DEVICE DATA BLOCK WINDOW
		; THE FIRST TIME THE RIB IS SET UP.
		; THIS SYMBOL USED IS A BLT ADR.
RIBACS==RIBCOD-ACTSTL  ;BLOCK ACTSTL LONG AT END OF RIB CONTAINS
		;ACCOUNT STRING.  AOBJN POINTER IS RIBACT
RIBCOD==BLKCOD	;CONTAINS UNLIKELY DATA WORD (I.E., NOT ASCII OR FLOATING POINT)
		;LH=0
	CODRIB==777777  ; THE UNLIKELY CODE
MRIBLN==RIBENT-RIBCOD+1+ACTSTL	;-MAX. NO. OF RETRIEVAL POINTER (AND UNITS AND ETC.)
			; RIBLEN PUT IN LH OF RIBFIR ON ENTER

RIBLEN==-MRIBLN
RIBSLF==BLKSLF	;THIS BLOCK (NOT CLUSTER) NUMBER (SELF)
SUBTTL	SAT BLOCKS
;WORD POSITIONS FOR DATA BLOCK IN SAT FILE
;PREFIX "SAF"(SAT IN CORE)
;ALL 128 WORDS ARE USED FOR BITS

;PREFIX IS "SAB" (FOR STORAGE ALLOCATION DATA BLOCK)
;THE PREFIX SAT REFERS TO THE TABLE OF DATA BITS PORTION OF THE SAB
;IT IS VERY IMPORTANT TO DISTINGUISH WHETHER AN INDEX IS RELATIVE TO SAB OR SAT
; THE DIFFERENCE BETWEEN TWO QUANTITIES IS ALWAYS SABBIT
;SAT TABLE HAS MAX. OF 128 WORDS OF BITS
;ONE BIT FOR EACH CLUSTER OF BLOCKS ON UNIT

INTERN SABRNG,SABTAL,SABSCN,SABFIR,SABBIT,SAYNDX,SAYCLA,SAPDOB,SAPDIF,SABHOL
REPEAT 0,<;LEVEL E
INTERN SABSAT,SABALT,SABRSV,SABHED
>

SABRNG==0	;LH=NEXT CORE ADDRESS IN SAB TABLE RING ON THIS UNIT
SABTAL==1	; RH=NO. OF FREE CLUSTERS IN THIS SAT BLOCK

SABSCN==2	;LH=-NO. OF WORDS IN SAT BUFFER (NEVER CHANGED)
		; RH=FIRST CORE ADDRESS TO START LOOKING
		; FOR FREE SPACE ON NEXT CALL (EACH FIND IS STORED HERE
		; SO EACH SCAN BEGINS WHERE LAST SUCCESSFUL ONE LEFT OFF)

SABFIR==3	;BITS 0-1 STATUS BITS
	SAPDIF==400000 ; BIT 0=1 IF SAT TABLE IN CORE IS DIFFERENT FROM DISK
	SAPBAD==200000 ; BIT 1=1 IF THIS SAT BLOCK IS ON A BAD BLOCK ON DISK
		; BITS 2-12 INDEX OF SAT DISK ADDR. IN SPT TABLE
	; SO ALL CLUSTERS ARE ASSUMED TO BE IN USE
		; BITS 13-35=CLUSTER ADDRESS WITHIN UNIT OF FIRST CLUSTER
		; REPRESENTED IN SAT TABLE - SAME SYMBOL CLASIZ, CLAPOS AS
		; IN SPT TABLE
		; BITS 2-35 SET -1 WHEN NEW F/S CREATED (STRUUO(.FSDEF))
		; TO FORCE SAT'S TO BE READ INTO SAB
	SAPDOB==SAPDIF!SAPBAD	;THE OR OF BOTH


SABNDX==SABFIR	;INDEX INTO SPT TABLE WHICH DESCRIBES SAB BLK-WORD ADR.
	SASNDX==^D11	;BYTE SIZE
	SANNDX==^D12	;BYTE PTR POS.

	$HIGH
SAYNDX::POINT	SASNDX,SABNDX(R),SANNDX
SAZNDX::POINT	SASNDX,SABNDX(P2),SANNDX	;BYTE PTR

SABCLA==SABFIR
SAYCLA:	POINT	CLASIZ,SABCLA(P2),CLAPOS
SABHOL==4		;NUMBER OF BLOCKS IN LARGEST HOLE (-1 IF DON'T KNOW)
	$LOW


REPEAT 0,<;POSTPONE TO LEVEL E
;THE FOLLOWING WORDS ALSO APPEAR IN SAT BLOCK ON DISK:

SABSAT==4	;FIRST SAT BLOCK HEADER WORD
		; LH=SIXBIT "SAT",
		;BITS 18-25 = UNUSED
		;BITS 26-35 ARE WRITTEN BY THE REFRESHER AND ARE
		; INCLUDED IN SAT BLOCK TO MAKE IT EASIER FOR PROGRAMS
		; TO READ THE SAT BLOCKS(DSKLST,ONCE-ONLY CODE,ETC)
		; IN FILE SAT.SYS
	SASHED==^D3	;NO. OF WORDS IN SAT HEADER - BYTE SIZE
		; SAVHED IS STORED HERE
		; CANNOT BE CHANGED WITHOUT REFRESHING(COPYING DATA WITH
		; MAGTAPE IF WANT TO CONVERT)
	SANHED==^D35	;BYTE PTR POS.
	SAVHED==SABHED	;VALUE STORED
	SASWPS==^D7	;NO. OF WORDS OF BIT DATA( IE NOT INCLUDING HEADER) - BYTE SIZE
	SANWPS==^D32	;BYTE PTR POS.
SABALT==5	;ALTER NUMBER FOR NO. OF RESERVED BLOCKS IN USE
		; CONTENTS OF STRALT ARE COPIED HERE WHEN SAT BLOCK IS WRITTEN
		; AT OTHER TIMES SABALT IS NOT CURRENT
		; THE PURPOSE OF THE ALTER NUMBER IS TO PROVIDE AN EASY
		; WAY FOR ONCE ONLY TO FIND THE LAST SAT
		; BLOCK WRITTEN ON A FILE STRUCTURE SO THAT IT CAN FIND THE
		; LATEST COPY OF THE NUMBER OF RESERVED BLOCKS(SABRSV) IN USE ON STR
SABRSV==6	;NO. OF RESERVED BLOCKS ALLOCATED( IN USE) TO USERS FOR THIS STR
		; CONTENTS OF (STRGAR-STRRES) ARE STORED HERE
		; WHEN THIS SAT BLOCK IS WRITTEN.
		; AT OTHER TIMES SABRSV IS NOT CURRENT
SABHED==4	;NO. OF WORDS IN SAT BLOCK HEADER - STORED IN SABSAT

>
SABBIT==5	;CONTAINS THE FIRST WORD OF SAT BITS
;"SAF" - FORMAT OF STORAGE ALLOCATION TABLE ON DISK
; SEE "SAB" FOR A DESCRIPTION OF SAT BLOCK HEADER.
; THE REST OF THE WORDS AFTER THE HEADER CONTAIN THE BITS
; EACH BIT REPRESENTS
; ONE CLUSTER OF DISK BLOCKS ON THE PHYSICAL UNIT WHERE THIS BLOCK IS WRITTEN.
; IF 1 CLUSTER IS PART OF A FILE OR CONTAINS SOME BAD BLOCKS (OR BOTH-FIRST TIME
; FILE IS WRITTEN)
;PROGRAMS WHICH READ THE SAT BLOCKS(DSKLST,ONCE-ONLY, ETC)
; MUST NOT LOOK AT WORDS BEYOND THE LAST ONE WHICH CONTAINS
; ALLOCATION DATA SINCE THE HARDWARE IS NOT CONSISTENT WITH RESPECT TO
; WRITING THE REMAINDER OF PARTIAL BLOCKS
; ALSO BECAUSE THE SAT BLOCKS ARE WRITTEN AS A FILE
; IF THE UNIT AND CLUSTER SIZE REQURE MORE THAN 1 128 WORD BLOCK
; EACH SAT BLOCK WILL APPEAR AS THE FIRST BLOCK OF EACH GROUP (=1 CLUSTER)
; THE REMAINING BLOCKS IN EACH SAT.SYS GROUP SHOULD BE IGNORED
; THEY WILL NOT START WITH SIXBIT "SAT" IN LH OF FIRST WORD
;THE SAT BLOCKS ARE SCATTERED ACCROSS EACH UNIT SO THAT
; THEY WILL BE NEAR THE DATA BLOCKS THEY DESCRIBE
;SPT - STORAGE ALLOCATION POINTER TABLE FOR SATS IN CORE AND DISK FOR A UNIT
;THERE IS ONE POINTER WORD IN CORE FOR EACH REAL SAT BLOCK ON UNIT,
; EVEN THOUGH NOT ALL SAT BLOCKS ARE KEPT IN CORE.
;	BITS 0-12=TALLY OF FREE CLUSTERS IN THIS SAT BLOCK
;	BITS 13-35=CLUSTER ADDRESS ON DISK WHERE SAT BLOCK IS WRITTEN
; LAST WORD IN SPT TABLE IS A ZERO.

INTERN	CLASIZ,CLAPOS,TALSIZ,TALPOS,SPTFIR,SPYTAL,SPYCLA

SPTFIR==0		;REL. LOC. IN SPT TABLE OF FIRST POINTER TO A
			; SAT BLOCK ON DISK
	TALSIZ==^D13		;SIZE OF BYTE CONTAINING FREE CLUSTER TALLY
			; FOR THIS SAT BLOCK
	TALPOS==^D12		;RIGHT MOST BIT OF SAT FREE CLUSTER TALLY

	CLASIZ==^D23		;SIZE OF BYTE CONTAINING CLUSTER ADDRESS ON THIS
			; UNIT WHERE SAT BLOCK IS WRITTEN
	CLAPOS==^D35		;RIGHT MOST BIT OF SAT CLUSTER ADDRESS


	$HIGH
SPYTAL:	POINT	TALSIZ,SPTFIR(T4),TALPOS	;# OF FREE CLUSTERS FOR THIS SAT BLOCK
SPYCLA:	POINT	CLASIZ,SPTFIR(T4),CLAPOS	;CLUSTER ADDR. OF SAT
	$LOW
SUBTTL	STR:	FILE STRUCTURE DATA BLOCK

INTERN STRNAM,STRUNM,STRHGH,STRFSN,STRUNI,STRREF,STRMNT,STRSAT,STRDB
INTERN STRPT1,STRUN1,STP1PT,STYCNP,STYCKP,STYCLP,STRBSC,STRSCU,STRTAL
INTERN STRJOB,STRSYS,STRLEN,STROVR,STRRES,STRGAR,STYTRY,STRSIZ,STRBPU
INTERN STRALT,STRSRC,STRK4C,STY1PT,STYUN1,STYRCL,STYSER,STR1PT,DIFSTU
INTERN STRPPN,STRSDL,STRCRS

STRDB:		;ADR OF STR PROTYPE DATA BLOCK
PHASE	0

STRNAM:!0	;(0)SIXBIT NAME OF FILE STR. (LEFT JUSTIFIED) FIRST 3 CHAR
		; ARE PRIMARY NAME, NEXT 3 CHAR UNUSED UNLESS TWO FILE
		; STR. WITH SAME PRIMARY NAME.
IFN STRNAM-DEVNAM,<PRINTX - STRNAM MUST=DEVNAM>
STRSYS:!XWD 0,0	;(1)LH=CORE ADDRESS OF NEXT FILE STRUCTURE DATA BLOCK IN SYSTEM
STRFSN==STRSYS	;RH=SYSTEM FILE STRUCTURE NO. OF THIS STR (0....15(OCTAL))
STRUNI:!XWD 0,0	;(2)LH=ADDRESS OF FIRST UNIT DATA BLOCK IN THIS STR
		; END OF LIST IS 0.  LH IN UNI IS UNISTR.  RH = STRK4C.
DIFSTU==STRUNI-UNISTR
STRK4C==STRUNI	;LH=STRUNI;RH=J FOR CRASH.SAV ON THIS STR
STRUNM:!XWD 0,0	;(3)RH=NO. OF UNITS IN THIS FILE STRUCTURE
STRREF==STRUNM	;LH=NON-ZERO IF THIS STR NEEDS REFRESHING BEFORE IT CAN BE USED
STRHGH:!0	;(4)HIGHEST LOGICAL BLOCK NO. IN THIS STR (0...STRHGH) (SAME AS TOTAL
		; NO OF BLOCKS COUNTING OVERHEAD AND SWAPPING)
		; (EXCEPT IF SMALL UNITS MIXED WITH BIG - SEE STRSIZ)
STRSIZ:!0	;(5)SIZE OF STR IN NO. OF 128 WORD BLOCKS INCLUDING
		; SWAPPING SPACE, BAD BLOCKS, SKELETON FILE STRUCTURE
		; BUT NOT COUNTING NON-EXISTANT LOGICAL ADDRESS SPACE CAUSED
		; BY SMALL PACKS MIXED WITH LARGER UNITS.
STRGAR:!0	;(6)UPPER BOUND ON BLOCKS GUARRANTEED TO USERS BY RESERVED QUOTAS
		; SET BY ONCE FROM HOMGAR
STRRES:!0	;(7)NO. OF RESERVED FREE BLOCKS LEFT IN THIS STR
		; THE ADMINISTRATOR SHOULD NOT OVERSUBSCRIBE RESERVED QUOTAS
		;SET BY ONCE ONLY CODE VHEN IT READS ALL SAT BLOCKS.
		; THE SAT BLOCK WITH THE LARGEST ALTER NUMBER IS USED
		; [STRGAR-RA@RSV WITH MAX. ALTER NUMBER]
STRALT:!0	;(10)ALTER NUMBER FOR THIS STR
		; INCREMENTED BY ONE EACH TIME ANY SAT BLOCK IS WRITTEN
		; FOR THIS STR.  ITS NEW CONTENTS ARE ALSO WRITTEN IN SAT BLOCK
		; HEADER ON DISK - SEE SABALT AND SABPSV
STRTAL:!0	;(11)NO. OF FIRST-COME-FIRST-SERVED FREE BLOCKS LEFT IN THIS STR
		; MINUS A SAFETY FACTOR (STVSFC - MONGEN SYMBOL)
		; THIS SAFETY FACTOR GUARANTEES THAT CLOSES CAN BE DONE
STROVR:!0	;(12)-NO. OF BLOCKS A USER IS ALLOWED TO WRITE OR ALLOCATE
		; BEYOND HIS RESERVED+FCFS QUOTA
STRMNT:!0	;(13)NO. OF DIFFERENT JOBS WHICH HAVE ISSUED MOUNT COMMAND
		; FOR THIS FILE STR.  LOGIN ISSUES AUTOMATIC MOUNT UUOS
		; FOR PUBLIC POOL STR WHICH HAS A USER UFD.
STRSAT==STRMNT	;THIS LOC TIME-SHARED BY ONCE-ONLY CODE TO REMEMBER LOG BLOCK #
		; OF 1ST RIB WITHIN STR FOR SAT.SYS
STRPT1:!0	;(14)FIRST RETRIEVAL POINTER TO MFD IN THIS FILE STRUCTURE
		; SET WHEN HOME BLOCK READ BY MONITOR
STRUN1:!XWD DSKTRY*STPTRY+SERTRY*STPSER+RCLTRY*STPRCL,0
		;(15)BITS COPUN1-COSUN1=FIRST LOGICAL UNIT
		; NUMBER WITHIN THIS FILE STRUCTURE WHERE MFD STARTS
		; (STRPT1 IS THE FIRST RETRIEVAL POINTER)
STRTRY==STRUN1	;NO. OF ERROR TRIES(DATA,SEARCH,RECALIBRATE) FOR THIS STR - WORD ADR.
		; MONGEN CAN CHANGE BY REDEFINING DSKTRY,SERTRY,RCLTRY
	STSTRY==^D6	;BYTE SIZE
	STNTRY==^D5	;BYTE PTR POS.
	STPTRY==10000	;RIGHT MOST BIT
	STSSER==^D6	;BYTE SIZE
	STNSER==^D11	;BYTE PTR POS.
	STPSER==100	;RIGHT MOST BIT
	STSRCL==^D6	;BYTE SIZE
	STNRCL==^D17	;BYTE PTR POS.
	STPRCL==1	;RIGHT MOST BIT
STR1PT==STRUN1	;STP1PT BIT - WORD ADDRESS
	STP1PT==COP1PT	;BIT STP1PT=1 IF STRPT1 IS THE ONLY POINTER TO MFD).
IFN FTPSTR,<
STRPVS==:STRUN1	;BIT STPPVS = 1 IF THIS IS A PRIVATE FILE STR
STPPVS==:1B35	;ON IF A PRIVATE FILE STRUCTURE
STSPVS==1	;BYTE SIZE
STNPVS==^D35	;BYTE PTR POS.
>
IFN FTSETS,<
STRSET==:STRUN1	;BYTE STYSET CONTAINS SET NUMBER TO WHICH STR BELONGS
STSSET==6	;BYTE SIZE
STNSET==^D23	;BYTE PTR POS.
>; END IFN FTSETS
STRBPU:!0	;(16)NOMINAL NO. OF BLOCKS PER UNIT IN THIS STR
		; IF UNITS ARE NOT SAME SIZE(RPO1,PRO2) THE LARGEST
		; UNIT IS STORED HERE.  THIS QUANTITY IS USED TO CONVERT
		; FROM LOGICAL BLOCKNO. WITHIN STR TO UNIT NO. + LOGICAL
		; BLOCK NO. WITHIN UNIT BY USING A SIMPLE DIVIDE.
STRBSC:!XWD 0,0	;(17)LH=NO. OF BLOCKS PER SUPER CLUSTER IN THIS STR
		; FILES BEGIN AT BEGINNING OF A SUPER CLUSTER, RATHER
		; THAN A CLUSTER SO THAT THE SUPER CLUSTER ADDRESS
		; + UNIT NO. WITHIN STR* NO SUPER CLUSTERS PER UNIT
		; WILL FIT INTO 18 BITS IN UFD
		;COMPUTED BY UNYBPC*(((STRHGH-0)/2*18))+1
STRSCU==STRBSC	;RH=NO. OF SUPER CLUSTERS PER UNIT
		; COMPUTED BY ((UNIBPU-1)/STRBSC)+1
STRJOB:!0	;(20)=XWD 0,0 IF ZER OR MORE THAN ONE JOB HAS F.S.
		;  MOUNTED (IN ITS SEARCH LIST).
		; =XWD 0,N IF JOB N HAS IT SINGLE ACCESS
		; =XWD -1,N IF JOB N IS ONLY JOB WITH IT MOUNTED BUT
		;  NOT SINGLE ACCESS
STRSRC==STRJOB	;TIME SHARED LOC. USED BY ONCE ONLY THEN CLEARED
		; CONTAINS POSITION OF STR (0...N) IN SEARCH LIST
		; FOR DEVICE SYS - SEE SYSSRC. -1 IF NOT IN LIST
STYCNP:!POINT 0,T2,0	;(21)BYTE POINTER TO EXTRACT CLUSTER COUNT FIELD FROM A
			;  RETRIEVAL POINTER WHICH IS IN AC T2 (LEFT FIELD)
			;  FOR THIS STR. BITS 6-11=ONCE ONLY QUESTION. CANNOT
			;  EXCEED MIN(LIMCNP,36.-BITS 6-11 STYCLP.
			;  BITS 0-5_36.-BITS 6-11 STYCNP
STYCKP:!POINT 0,T2,0	;(22)BYTE POINTER TO EXTRACT CHECKSUM FIELD FROM A
			;  RETRIEVAL POINTER WHICH IS IN AC T3 (MIDDLE FIELD)
			;  FOR THIS STR.
			;  BITS 6-11_36.-BITS 6-11 STRCNP-BITS 6-11 STYCLP
			;  BITS 0-5_BITS 0-5 STRCNP+BITS 6-11 STYCKP
STYCLP:!POINT 0,T2,35	;(23)BYTE POINTER TO EXTRACT CLUSTER ADDRESS FIELD FROM A
			;  RETRIEVAL POINTER WHICH IS IN AC T2 (RIGHT FIELD)
			;  FOR THIS STR. BITS 6-11=36.-JFFO((UNIBPU-1)/UNYBPC)
			;  CANNOT EXCEED LIMCLP.
STRPPN:!0		;(24) PPN OF THE OWNER OF THIS FILE
			;  STRUCTURE SET BY THE MOUNT SYSTEM
			;  PROGRAM FROM THE SYSTEM ACCOUNTING FILE
STRSDL:!-1		; (25) POSITION OF STR (0...N) IN SYSTEM DUMP LIST
			; -1 IF NOT IN LIST
STRCRS:!0		;(26) LOGICAL BLOCK NUMBER IN STR OF RIB FOR
			;  CRASH.EXE
STRLEN==.-STRNAM

DEPHASE


;BYTE POINTER NOT REPLICATED IN EACH STR DATA BLOCK:

	$HIGH
STYTRY:	POINT	STSTRY,STRTRY(T2),STNTRY	;BYTE POINTER TO NO. OF ERROR RETRYS
			; BEFORE CONSIDERING IT A HARD ERROR
STYRCL:	POINT	STSRCL,STRTRY(T2),STNRCL	;BYTE PTR TO NO. OF RECALIBRATE+1
			; RETRIES FOR BOTH SEARCH AND DATA ERRORS = NO. TRIES
STYSER:	POINT	STSSER,STRTRY(T2),STNSER	;BYTE PTR TO NO. OF TRIES
			; ON SEARCH ERROR (RETRIES -1) BEFORE RECALIBRATING.
STY1PT:	POINT	COS1PT,STR1PT(T2),CON1PT	;BYTE POINTER TO BIT WHICH
				; IF 1 MEANS ONLY ONE RET PTR FOR MFD FOR THIS STR
STYUN1:	POINT	COSUN1,STRUN1(T2),CONUN1	;BYTE PONTER TO FIRST
				; LOGICAL UNIT WITHIN STR FOR MFD
IFN FTPSTR,<
STYPVS::POINT	STSPVS,STRPVS(P2),STNPVS	;BYTE POINTER TO BIT WHICH
				; IF 1 MEANS THIS IS A PRIVATE STR
STYPV2::POINT	STSPVS,STRPVS(T2),STNPVS
>
IFN FTSETS,<
STYSET::POINT	STSSET,STRSET(P2),STNSET ;BYTE POINTER TO FIELD WHICH CONTAINS
				; SET NUMBER TO WHICH STR BELONGS
STYSE2::POINT	STSSET,STRSET(T2),STNSET
>; END IFN FTSETS
	$LOW
	SUBTTL	SWI - IN-CORE COPY OF SWITCH.INI
SWILEN==:0			;LENGTH OF IN-CORE COPY
SWIPT1==:1			;COPY OF ACCPT1 FOR FILE
SWIUN1==:2			;COPY OF ACCUN1,,SIZE OF FILE (ACCWRT+ACYLBS)
SWIPRV==:3			;COPY OF ACCPRV
SWIDAT==:4			;START OF DATA FOR SWITCH.INI
SUBTTL	"SYS" - SYSTEM WIDE QUANTITIES
; NO SPECIAL PREFIX

INTERN	MFDPPN,SWPMAX,MSWPMXN,SYSPPB,FFAPPN,HLPPPN
INTERN	SYSDOR,SYSCOR,UN1PTR,DINITF,DIFSTR,SWPUNI,SWPTAB,NEWPPN
INTERN	STNPRT,DIFPPL,HICORE,SWPTBE,SPLPPN,MUSTMX
INTERN	SYSSTR,SYSUNI,LVDTBL,LVDMXL,UFDPRT,SYSPPN,CORNUM,QUESTR,CRUPPN,SPLPRT
INTERN	SYSPRT,SYSPRY,.UONCE,SFDLVL,XSYPPN,MAXTRN,OLDPPN,NUMBF,MAXSWP,SWPUN2

;TABLE OF FILE STRUCTURES IN SYSTEM. A ZERO ENTRY MEANS NO FILE
; STR ASSOCIATED WITH THIS NUMBER

STRAOB::-.SLMAX,,.FSMIN	;AOBJN POINTER FOR TABSTR
TABSTR==:.-.FSMIN	;INDEX THIS ADR WITH FSN. (FSN'S START AT .FSMIN)
TABST0::REPEAT .SLMAX+1,<0>
	SUBTTL	LEVEL D GETTAB TABLE

LVDTBL:!		;GETTAB TABLE NO. 16(OCTAL)-LEVEL D DISK PARAMTERS


MFDPPN:	XWD	1,1		;(0) PROJECT-PROGRAMMER NUMBER FOR STORING
				;    UFDS ONLY (ALL OTHER FILE STRUCTURE FILES
				;    ARE STORED IN DEVICE SYS (SEE SYSPPN))
STDPPN:				;(1) PROJ-PROG NO. FOR DEVICE 'STD'
SYSPPN:	XWD	1,4		;(1) PROJ-PROG NO. FOR DEVICE 'SYS' (I.E.,
				;    CUSPS, LIBRARY)
FFAPPN:	XWD	1,2		;(2) PROJ-PROG NO. FOR FULL-FILE-ACCESS/OPERATOR
HLPPPN:	XWD	2,5		;(3) PROJ-PROG NO. FOR HELP FILES, GENERAL
				;    "NOT-LOGGED-IN" ACCOUNT (FOR SUCH AS
				;    HELP, SYSTAT, ETC.)
SPLPPN:	XWD	3,3		;(4) PROJ-PROG NO. FOR MPB/GALAXY SPOOLING
HICORE:				;1ST FREE LOCATION AVAILABLE IN HIGH CORE
				;    FOR STR DATA BLOCKS, ETC. (USED BY ONCMOD
				;    & REFSTR)
SYSPPB:	XWD	0,0		;(5) LH=FIRST PROJECT-PROGRAMMER NUMBER BLOCK
				;    IN SYSTEM
				;RH=CORE ADDRESS OF NEXT PPB BLOCK TO SCAN
				;    NAME LIST TO RECLAIM GRABBABLE NMB BLOCK
				;    IF RH=0 CORE GRABBER SHOULD START OVER AT
				;    BEGINNING OF PPB LIST (I.E., LH OF SYSPPB)
	DIFPPL==SYSPPB-CORLNK
SYSSTR:	XWD	0,STRSYS	;(6) LH=CORE ADDRESS(DOWNWARD POINTER) OF FIRST
				;    FILE STRUCTURE DATA BLOCK IN SYSTEM
				;RH=INDEX IN STR DATA BLOCK FOR PTR TO NEXT STR
	DIFSTR==SYSSTR-STRSYS
SYSUNI:	XWD	FIRUNI,UNISYS	;(7) LH=CORE ADDRESS(DOWNWARD POINTER)OF FIRST
				;    UNIT
				;RH=INDEX IN UNIT DATA BLOCK FOR PTR TO NEXT
				;    UNIT IN SYSTEM
SWPUNI:	XWD	0,UNISWP	;(10) LH=CORE ADDR (DOWNWARD PTR) OF FIRST UNIT
				;    FOR SWAPPING
				;RH=INDEX IN UNIT DATA BLOCK FOR PTR TO NEXT
				;    UNIT IN SWAPPING LIST
	SYS4WD==FIL4WD*JOBN	;NO. OF 4 WORD WORD CORE BLOCKS FOR SYSTEM
				;    MULTIPLY BY NO. OF 4 WORD BLOCKS PER JOB
IFL SYS4WD-^D50,<SYS4WD==^D50>	;INSURE AT LEAST 50 4-WORD BLOCKS FOR SYSTEM
				;    EVEN IF JUST A 1 JOB SYSTEM
CORNUM:	EXP	SYS4WD		;(11) # PERMANENT 4 WORD BLOCKS GENERATED AT
				;    ONCE ONLY TIME
STNPRT:	XWD	PRVFIL*1000,0	;(12) STANDARD PRIVILEGE
UFDPRT:	XWD	PRVUFD*1000,0	;(13) STANDARD UFD PRIVILEGE
				;    SYMBOL PRVUFD SHOULD NOT BE USED. INSTEAD
				;    UFDPRT SHOULD BE USED, SO CAN PATCH
				;    RUNNING MONITOR.
MBFNUM:	EXP	2		;(14) CONTAINS THE NUMBER OF MONITOR BUFFERS
				;    SET AT MONGEN TIME, CAN BE CHANGED AT ONCE
				;    ONLY TIME
QUESTR:	EXP	M.QSTR		;(15) SIXBIT NAME OF FILE STRUCTURE
				;    FOR QUEUEING PROGRAMS LIKE PRINT, UMOUNT,
				;    ETC SETUP BY ONCE ONLY CODE TO BE THE
				;    FIRST(FASTEST) STR WHICH IS UP(TABSTR(0)).
XPNPPN:
CRUPPN:	XWD	10,1		;(16) UFD FOR DUMPING CRASHES
SFDLVL:	EXP	LIMLVL		;(17) MAX NUMBER OF NESTED SFDS
SPLPRT:	XWD	PRVSPL*1000,0	;(20) PROTECTION FOR SPOOLED OUTPUT
SYSPRT:	XWD	PRVSYS*1000,0	;(21) PROT FOR MOST SYS FILES
SYSPRY:	XWD	PRYSYS*1000,0	;(22) PROT FOR SYS .SYS FILES
MUSTMX:	EXP	-MAXUSI		;(23) NEGATIVE MAXIMUM USETI ARGUMENT (FOR
				;    READING EXTENDED RIBS)
MAXTRN:	EXP	BLKMAX		;(24) MAX NO OF BLOCKS TO TRANSFER IN 1
				;    OPERATION (SO HIGH PRIORITY IO WON'T
				;    GET LOCKED OUT)
NEWPPN:
XSYPPN:	XWD	1,5		;(25) PPN OF EXPERIMENTAL SYS
OLDPPN:	XWD	1,3		;(26) PPN OF OLD SYS
UMDPPN::XWD	6,10		;(27) USER MODE DIAGNOSTICS PPN
				;    (CAN DISABLE ERROR LOGGING)
IFNDEF	M.DFNB,<M.DFNB==6>
NUMBF:	EXP	M.DFNB		;(30) DEFAULT NO. OF DISK BUFFERS
MAXSWP:	EXP	SWPMAX		;(31) MAX NUMBER OF UNITS IN ASL
ALGPPN:	5,,4			;(32) ALGOL LIBRARY
BLIPPN:	5,,5			;(33) BLISS LIBRARY
FORPPN:	5,,6			;(34) FORTRAN LIBRARY
MACPPN:	5,,7			;(35) MACRO LIBRARY
UNVPPN:	5,,17			;(36) UNIVERSAL LIBRARY
PUBPPN:	1,,6			;(37) USER MAINTAINED SYS:
TEDPPN:	5,,10			;(40) TEXT EDITOR LIBRARY
RELPPN:	5,,11			;(41) REL FILE LIBRARY
RNOPPN:	5,,12			;(42) RUNOFF LIBRARY
SNOPPN:	5,,13			;(43) SNOBOL LIBRARY
DOCPPN:	5,,14			;(44) DOC FILE LIBRARY
FAIPPN:	5,,15			;(45) FAIL LIBRARY
MUSPPN:	5,,16			;(46) MUSIC LIBRARY
DECPPN:	10,,7			;(47) LIBRARY FOR DEC DISTRIBUTED SOFTWARE.
TABSWP:	XWD	-SWPMAX,SWPTAB	;(50) POINTER TO ACTIVE SWAPPING LIST
BASPPN:	XWD	5,1		;(51) BASIC LIB PPN
COBPPN:	XWD	5,2		;(52) COBOL LIB PPN
MXIPPN:	XWD	5,3		;(53) PDP-11 LIB PPN
NELPPN:	XWD	5,20		;(54) NEL1AC LIBRARY
DMPPPN:	XWD	5,21		;(55) DUMP LIBRARY
POPPPN:	XWD	5,22		;(56) POP2 LIBRARY
TSTPPN:	5,,23			;(57) TEST PPN
ALLOVR::0			;(60) =0 IF DON'T CALL DAEMON ON SOFT OVERRUNS
				;    RECOVERED ON FIRST RETRY, =1 IF CALL DAEMON
				;    ON ALL OVERRUNS
MASERR:	XWD	KONREG,UNISCR	;(61) POINTERS TO MASSBUS ERROR LOCATIONS FOR
				;    DAEMON
BATCHN:	XWD	UNYBCT,UNICCT	;(62) POINTERS TO BAT BLOCK + CHANNEL ERROR
				;    INFO FOR DAEMON
DBSPPN:	XWD	5,24		;(63) DBMS LIBRARY
EXPCHN:	EXP	.CHTCW		;(64) OFFSET OF EXPECTED CHANNEL TERM, WORD
				;    IN CDB FOR DAEMON
MICPPN:	XWD	5,25		;(65) LIBRARY OF MIC MACROS
TPSPPN:	XWD	5,26		;(66) TEXT PROCESSING SYSTEM LIBRARY
CTLPPN:	XWD	5,27		;(67) CTL FILE LIBRARY
GAMPPN:	XWD	5,30		;(70) GAMES
ACTPPN:	XWD	1,7		;(71) SYSTEM ACCOUNTING
APLPPN:	XWD	5,31		;(72) APL LIB
IFNDEF	RIBERN,<RIBERN=0>
RIBECT::EXP	RIBERN		;(73) RIB-ERROR THRESHOLD
RIBTOT::0			;(74) TOTAL RIB ERRS
SYSDOR:	XWD	0,0		;(75) BEGINNING OF DORMANT ACCESS BLOCK LIST
				;LH=ADDRESS OF FIRST DORMANT ACCESS BLOCK
				;LH=0 IF NO DORMANT ACCESS BLOCKS
				;RH=ADDRESS OF LAST DORMANT ACCESS BLOCK
SYSCOR:	XWD	.,ZERO18	;(76) BEGINNING OF PERMANENT 4 WORD BLOCK LIST
				;LH=ADDRESS OF FIRST 4 WORD BLOCK, RH=0 ALWAYS
				;    IF NO FREE BLOCKS, WHOLE WORD=0.
				;    BLOCKS ARE LINKED TOGETHER BY CORLNK WORD.
INTFNC::0			;(77) NUMBER OF TIMES FRONT-END HAD DISK
D60PPN:	XWD	5,32		;(100) DAS60 LOG FILE AREA
ERTLOC::ERPTBK##		;(101) STARTING LOCATION OF QUEUE TABLE FOR
				;    DAEMON ERROR REPORTING
ERTPT1::EPKIDX##		;(102) STARTING POINTER FOR DAEMON ERROR EXTRACT
ERTPT2::ESVIDX##		;(103) STARTING POINTER FOR DAEMON ERROR INSERT
ERTLTH::ERPTMX##		;(104) LENGTH OF DAEMON ERROR TABLE

ERTCDA::UNICDA			;(105) OFFSET OF UNICDA IN UDB'S
ERTDES::UNIDES			;(106) OFFSET OF UNIDES IN UDB'S
SYSPTR::0			;(107) POINTER TO IN-CORE COPIES OF RETRIEVAL
				;    POINTERS
MAXSSL:	XWD	.SLMXS,.SLMXJ	;(110) LH=MAX STRS IN SYSTEM SEARCH LIST
				;RH=MAX STRS IN JOB SEARCH LIST
ERTSLB:	UNISLB			;(111) OFFSET OF UNISLB IN UDB'S
UTPPPN:	XWD	5,33		;(112) UETP AREA
INIPPN:	XWD	5,34		;(113) INITIALIZATION FILES AREA
ERPSIZ::EXP	4		;(114) SIZE OF AN ERPTBR ENTRY ON WORDS
SYSKON::
IFE FTAUTC,<
XWD	D0KDB,KONNXT		;(115) LH=CORE ADDR OF FIRST DISK KDB IN SYSTEM
>
IFN FTAUTC,<EXP KONNXT
>
				;      RH=OFFSET IN KDB OF POINTER TO NEXT
IFNDEF M.DFLB,<M.DFLB==3>
NUMLBF::EXP	M.DFLB		;(116) DEFAULT NUMBER OF LARGE DISK BUFFERS
	EXP	DEVUNI		;(117) OFFSET OF DEVUNI,USED BY SYSTAT
%LDCSZ::0			;(120) SIZE IN BLOCKS OF CACHE
%LDRDC::0			;(121) MONITOR CACHE BLOCK READ CALLS
%LDRDH::0			;(122) MONITOR CACHE BLOCK READ HITS
%LDWRC::0			;(123) MONITOR CACHE WRITE CALLS
%LDWRH::0			;(124) MONITOR CACHE WRITE HITS
%LDHSF::0			;(125) CSHFND CALLS
%LDHSC::0			;(126) CSHFND COLLISIONS IN HASH TABLE
%LDHSL::EXP	CBHSHL		;(127) LENGTH OF CACHE HASH TABLE
%LDHST::EXP	CBHSHT		;(130) ADDRESS OF CACHE HASH TABLE
%LDCHD::EXP	CBHEAD##	;(131) ADDRESS OF CACHE LIST HEADER
	EXP	DEVSPN		;(132) OFFSET FOR SPOOLED FILENAME
	EXP	DEVSPM		;(133) OFFSET FOR SPOOLED PARAMETER BLOCK PTR
	EXP	DEVBLK		;(134) OFFSET FOR I/O BLOCK NUMBER
	EXP	DEVRSU		;(135) OFFSET TO RETRIEVAL /ALL BLOCKS
	EXP	DEVSFD		;(136) OFFSET TO NMB FOR FATHER SFD
UPSPPN:	XWD	5,35		;(137) PPN FOR LIBRARY FOR MAILERS
	EXP	SEQTOP##	;(140) ADDRESS OF POINTER TO FIRST SYSTEM
				;    ERROR BLOCK
ROODRB::0			;(141) NUMBER OF TIMES WE RAN OUT OF DRBS
FNTPPN:	XWD	5,36		;(142) PPN FOR LASER PRINTER FONTS
IFE FTSETS,<0>			;(143)
IFN FTSETS,<
DSKSET::M.SETS			;(143) BIT MASK FOR DISK SETS THIS MONITOR MOUNTS
>; END IFN FTSETS
SYSDET::XWD	0,UNISYS	;(144) LH=CORE ADDRESS (DOWNWARD POINTER) OF
				;     FIRST DETACHED UNIT
				;RH=INDEX IN UNIT DATA BLOCK FOR PTR TO NEXT
				;    UNIT IN SYSTEM

LVDMXL==<.-LVDTBL-1>B26		;END OF GETTAB TABLE
;SYSTEM VARIABLES NOT IN GETTAB:

	$HIGH
UN1PTR:	POINT	COSUN1,T1,CONUN1 ;BYTE POINTER TO LOGICAL NUMBER WITHIN A
			;FILE STRUCTURE (AFTER DATA WORD MOVED TO AC T.)
	$LOW
NOWDUC::0		;NUMBER OF UNITS WITH UNPNDU
SYSGEN::0		;HIGHEST UNIGEN ISSUED SINCE SYSTEM WAS LOADED
DINITF:	0		;DSK INITIALIZATION IN PROGRESS (ONCE ONLY CODE)
			; REST OF MONITOR NOT AVAILABLE IF ERRORS ETC.
			; [SET NON-ZERO AT BEGINNING OF DSK ONCE ONLY CODE
			; AND DSKINI - CLEARED AT END OF DSKINI]
IFN FTCIDSK,<
BNDFLG::0		;ZERO IF HAVEN'T CALLED ONCBND YET, NON-ZERO IF HAVE
>; END IFN FTCIDSK
.UONCE:	0		;0 IF EXEC MODE, NON-0 IF USER MODE ONCE ONLY
TWCMBF::0		;USED BY TWICE
;AUTO-CONFIGURING VARIABLES
IFN FTAUTC,<
TOTTAP::0		;TOTAL NUMBER OF TAPE CONTROLLERS
NUMTAP::0		;NUMBER OF TAPE CONTROLLERS
NUMRNA::0		;NUMBER OF RNA CONTROLLERS
NUMRPA::0		;NUMBER OF RPA CONTROLLERS
NUMRNC::0		;NUMBER OF RNAS ON THIS CPU
NUMRPC::0		;NUMBER OF RPAS ON THIS CPU
IFN FTCIDSK,<
NUMRAA::0		;NUMBER OF RAA CONTROLLERS
NUMRAC::0		;NUMBER OF RAAS ON THIS CPU
>; END IFN FTCIDSK
LASCNF::0		;USED TO SEQUENCE CPUS THROUGH AUTO CONFIG
LASUNI::0		;LAST DISK UDB BUILT BY AUTCON
TAPLNK::MT0DDB##	;WHERE TO LINK MAGTAPE DDBS BUILT BY AUTCON
AUTCNO::CONO	(T1)
AUTCNI::CONI	T1
AUTDTO::DATAO	T1
AUTDTI::DATAI	T1
AUTRNX::EXP	-1
>
NUMKON::
IFE FTAUTC,<EXP ALLKON##>
IFN FTAUTC,<0>
			; SWAPPING (ONLY 1 FOR NOW),
			;RH=UNUSED
SWPTAB:	BLOCK	SWPMAX+1	;TABLE OF CORE ADDRESSES OF UNITS FOR SWAPPING
			;(CAN BE CHANGED AT MONGEN TIME)
SWPTBE==.-1		;LAST ADR. OF SWPTAB FOR BLT TO CLEAR TABLE
MSWPMX==-SWPMAX
IFN FTSPL,<
	INTERN	SPLGEN
SPLGEN:	BLOCK	1	;CURRENT NUMBER TO CREATE UNIQUE NAME
			;FOR SPOOLING FILES
>
SWPUN2:	0		;ADR OF 1ST SLOW-CLASS SWAP SPACE
NXTSUN::0		;ADR OF NEXT UNIT IN SWAPPER ALLOCATION ROUND-ROBIN
INTERN	MIGRAT,DIADSK,DIADWT,DIACHN
MIGRAT:	0		;IF NON-0 IS THE JOB NUMBER OF A JOB WHICH WE ARE
			; TRYING TO SWAP OFF OF A DISK WHICH IS ABOUT TO
			; BE REMOVED FOR DIAGNOSTIC PURPOSES
DIADSK:	0		;DDB TRYING TO SHUT DOWN DSK IO FOR USER-MODE DIAGNOSTIC
			; POSITIVE IF WAITING FOR IO TO CEASE
			; NEGATIVE IF IO HAS STOPPED (JUST DONT DO IO)
DIACHN:	0		;CHANNEL (DF10) FOR WHICH IO IS BEING STOPPED
DIADWT:	0		;FLAG THAT ANOTHER JOB IS WAITING FOR DIAG

HERLIM::DEC	25		;# OF ERRORS BEFORE TELLING OPR
HERCNT::0			;# OF DSK ERRS SO FAR

IFN FTMP,<
CPUDSQ::0			;QUEUE OF REQUESTS FOR OTHER CPUS
>

CBHSHT::BLOCK	CBHSHL		;DISK CACHE HASH TABLE
;ERSATZ DEVICE TABLES
	INTERN	SDVTBL,SDVPPN,SDVLEN,SYSNDX,SDVMXL,ALLSRC

	DEFINE	UERSTZ(DEV,P,PN,SLIST),<
		..T==0
		IFE <SIXBIT/SLIST/>-<SIXBIT/SYS/>,<..T==PT.SSL>
		IFE <SIXBIT/SLIST/>-<SIXBIT/ALL/>,<..T==PT.ASL>
		IFE <SIXBIT/SLIST/>-<SIXBIT/JOB/>,<..T==PT.JSL>
		SD	DEV,[<P,,PN>],..T
	>

DEFINE EDEVS,<
	LIB	SYS,		;MUST BE FIRST
	LIB	NEW,		;MUST BE SECOND
	LIB	OLD,
	LIB	HLP,
	SD	ALL,[0],PT.ASL
	SD	SSL,[0],PT.SSL
	SD	LIB,[-1],
	SPCEDN			;EXPAND MONGEN'ED CUSTOMER ERSATZ DEVICES
	LIB	BAS,
	LIB	COB,
	LIB	MXI,
	LIB	ALG,
	LIB	BLI,
	LIB	FOR,
	LIB	MAC,
	LIB	UNV,
	LIB	PUB,
	LIB	DEC,
	LIB	STD,
	LIB	XPN,
	LIB	FFA,
	LIB	MFD,
	LIB	UMD,
	LIB	TED,
	LIB	REL,
	LIB	RNO,
	LIB	SNO,
	LIB	DOC,
	LIB	FAI,
	LIB	MUS,
	LIB	NEL,
	LIB	DMP,
	LIB	POP,
	LIB	TST,
	LIB	DBS,
	LIB	MIC,
	LIB	TPS,
	LIB	CTL,
	LIB	GAM,
	LIB	ACT,
	LIB	APL,
	LIB	D60,
	LIB	UTP,
	LIB	INI,
	LIB	UPS,
	LIB	SPL,
	LIB	FNT,
>

DEFINE LIB(DEV),<
	SD	DEV,DEV'PPN,PT.SSL
>

DEFINE	SD(DEV,PPN,SL),<
IFNDEF ED.'DEV,<ED.'DEV==-1>
>

;SET DEFAULT ED.??? TO -1.  IF ED.??? IS DEFINED AS 0 THEN
; DEVICE ??? WILL NOT BE INCLUDED
	EDEVS

;HOWEVER, SYS:,NEW:,OLD:,ALL:,LIB: MUST REMAIN
	ED.SYS==-1
	ED.NEW==-1
	ED.OLD==-1
	ED.ALL==-1
	ED.LIB==-1

DEFINE	SD(A,B,C),<
IFN ED.'A,<
	<SIXBIT	/A/>+C
	IFE	<SIXBIT/A/>-<SIXBIT/ALL/>,<XP ZPPNDX,.-SDVTBL-1>
	IFE	<SIXBIT/A/>-<SIXBIT/LIB/>,<XP LIBNDX,.-SDVTBL-1>
>>
	$HIGH
SDVTBL:	EDEVS
	SDVLEN==.-SDVTBL-1
	SDVMXL==<SDVLEN>B26
	XP	SYSNDX,2
	XP	NEWNDX,1

;TABLE OF PPN'S FOR ERSATZ DEVICES
DEFINE	SD(A,B,C),<
IFN ED.'A,<
	EXP	B
>>
SDVPPN:	EDEVS
	$LOW
	$HIGH
ALLSL:	SLALL;		;THE ALL: SEARCH LIST
	$LOW
SYSSL:	SLEMPT(.SLMXS);	;THE SYS: SEARCH LIST
			;JOB SEARCHL LISTS ARE IN THE PDB

	$HIGH
ALLSRC::POINT	.FSSIZ,ALLSL;	;PREDECREMENTED POINTER TO ALL: SL.
SYSSRC::POINT	.FSSIZ,SYSSL;	;PREDECREMENTED POINTER TO SYS: SL.

JOBSRC::POINT	.FSSIZ,.PDJSL##(W);	;PREDECREMENTED POINTER TO JOB SL.
EMTSRC::POINT	.FSSIZ,[SLEMPT(1)];	;PREDECREMENTED POINTER TO THE EMPTY SL.
	$LOW

IFN FTKL10,<ONCTIM==:20>	;HUNG TIMER FOR ONCE
IFN FTKS10,<ONCTIM==:10>
	$HIGH
SUBTTL	UFB:	USER FILE DIRECTORY BLOCK
;ONE DATA BLOCK FOR EVERY UFD-FILE STRUCTURE PAIR WHICH HAS AN ACTIVE FILE
;ALL BLOCKS FOR A FILE STRUCTURE ARE LINKED TOGETHER


;WORD 0---------------------------------------
UFBTAL==:0		;TALLY OF RESERVED+FREE BLOCKS LEFT IN THIS UFD IN THIS
			; FILE STRUCTURE (OVER DRAW IS NEGATIVE).  NO
			; NEW ENTERS ALLOWED IF THIS IS 0 OR NEGATIVE
			; INCLUDES OVERHEAD BLOCKS (RIB).

;WORD 1---------------------------------------
UFBPPB==:CORLNK		;LH=CORE ADDRESS (ACCROSS POINTER) OF NEXT UFD
			; DATA BLOCK FOR THIS PROJECT-PROGRAMMER
			; NUMBER. (I.E. IN ANOTHER FILE STRUCTURE)
UFBPRV==:UFBPPB		;ACCESS PRIVILEGES FOR THIS UFD IN FILE STRUCTURE - WORD ADR.
	UFSPRV==^D9		;BYTE SIZE
	UFNPRV==^D26		;BYTE PTR. POS.
	UFRXLK==:RIRXLK	;CAN DO LOOKUPS OF FILES IN THIS DIRECTORY-RIGHT JUSTIFIED BIT
			; FOR OWNER, PROJECT, OR UNIVERSE
	UFRXCR==:RIRXCR	;CAN CREATE FILES IN THIS UFD (IE ENTER NAMES WHICH ARE NOT
			; YET THERE AND SO CANNOT PROTECT THEMSELVES)
	UFRXRD==:RIRXRD	;CAN READ DIRECTORY (MFD OR UFD) AS A FILE -RIGHT
			; JUSTIFIED BIT FOR OWNER, PROJECT OR UNIVERSE
UFYPRV::POINT	UFSPRV,UFBPRV(T4),UFNPRV	;BYTE POINTER FOR ALL THREE PRIVILEGES
			; (OWNER,PROJECT,UNIVERSE)
UFBUN1==:CORUN1		;LOGICAL UNIT NO. WITHIN FILE STRUCTURE
			; ASSOCIATED WITH FIRST RETRIEVAL POINTER.
	UFSUN1==:COSUN1	;BYTE SIZE
	UFNUN1==:CONUN1	;BYTE PTR. POS.
UFB1PT==:COR1PT		;IF RETRIEVAL POINTER TO UFD IS THE ONLY ONE - WORD ADR.
	UFS1PT==:COS1PT	;BYTE SIZE
	UFN1PT==:CON1PT	;BYTE PTR. POS.
	UFP1PT==:COP1PT		;RIGHT-MOST BIT

;WORD 2---------------------------------------
UFBPT1==:CORPT1		;FIRST RETRIEVAL POINTER TO UFD
			; (CLUSTER COUNT,CHECKSUM,CLUSTER ADR.)


;WORD 3---------------------------------------
UFBWRT==:3		;BITS 0-26=LOGGED IN FIRST-COME FIRST-SERVED QUOTA
			; USED TO DISTINGUISH BETWEEN RESERVED
			; AND FCFS FREE BLOCKS LEFT IN UFBTAL
			; (NEVER DECREMENTED)
UFWMSK==:777		;MASK FOR UFBWRT
UFBQTF==:UFBWRT		;FCFS LOGGED IN QUOTA - WORD ADR
	UFSQTF==^D27		;BYTE SIZE
	UFNQTF==^D26		;BYTE PTR POS
;UFYQTF::POINT	UFSQTF,UFBQTF(),UFNQTF	;BYTE PTR

	UFSWRT==^D9		;BYTE SIZE
	UFNWRT==^D35		;BYTE TRP POS(MUST BE RIGHT JUST. FOR AOS)
UFYWRT::POINT	UFSWRT,UFBWRT(T3),UFNWRT	;BYTE PTR
UFZWRT::POINT	UFSWRT,UFBWRT(T4),UFNWRT	;BYTE PTR #2
			; BITS 27-35=NO. BLOCKS WRITTEN IN UFD(OR MFD) ITSELF

;WORD 4---------------------------------------
UFBFSN==:CORFSN		;FILE STRUCTURE NUMBER THIS UFB IS ASSOCIATED WITH- WORD ADR.
	UFSFSN==:COSFSN	;BYTE SIZE
	UFNFSN==:CONFSN	;BYTE PTR. POS.

UFYFSN==:COYFSN

UFBCHG==:4		;BIT 6=1 IF ANY FILE IN UFD HAS
	UFPCHG==:4000	; BEEN WRITTEN OF RENAMED (CLEARED BY BACKUP)

UFBLOG==:4		;BIT 7=1 IF RIPLOG
	UFPLOG==:2000	; IS ON IN UFD
UFBZRB==:CORZRB		;UFD HAS EMPTY DATA BLOCKS
	UFPZRB==:COPZRB		;BIT =1 IF YES
;WORD 5---------------------------------------

UFBAUJ==:5			;=N IF JOB N OWNS AU FOR THIS UFB

;WORD 6---------------------------------------

UFBWAT==:6			;NON-0 IF JOB WAITING FOR AU

;WORD 7---------------------------------------

	$LOW
;WORD POSITIONS IN USER FILE DIRECTORIES
;PREFIX "UFD"
;THESE HAVE SAME FORMAT AS THE MFD.
;NEITHER THE MFD NOR THE UFD NAME APPEAR IN THE UFD.
;FILE ENTRIES OCCUR IN PAIRS.

INTERN	UFDNAM,UFDEXT,UFDCFP
UFDNAM==0	;SIXBIT FILE NAME
UFDEXT==1	;LH=SIXBIT EXTENSION, RH=CUP WHICH SPECIFIES
		; UNIT WITHIN FILE STRUCTURE AND LOGICAL BLOCK NUMBER OF
		; FIRST RIB OF FILE.  SEE MFDEXT ABOVE.
UFDCFP==1	;RH=COMPRESSED FILE POINTER TO RETRIEVAL BLOCK OF FILE (RIB)
		; CONTAINS LOGICAL UNIT # WITHIN STR & SUPER CLUSTER ADDRESS.
		;TO GET CLUSTER ADDRESS: DIVIDE BY NO. OF SUPER CLUSTER PER UNIT
		;  RH(STRSCU). QUOTIENT=LOGICAL UNIT NO. WITHIN STR,
		;  REMAINDER=SUPER CLUSTER ADDRESS. MULTIPLY SUPER CLUSTER ADR.
		;  BY NO. OF BLOCKS PER SUPER CLUSTER (LH(STRBSC).


;WORD POSITIONS IN DATA BLOCKS. OF FILES
; THERE IS NO FORMAT FOR DATA BLOCKS.
; THEY CONTAIN 128 WORDS OF USER DATA

SUBTTL	UNI:	UNIT DATA BLOCK

;PARAMETERS FOR UNITCB
;X   - KONTROLLER TYPE(EG. FH,DP,MD,DR)
;U   - KONTROLLER IDENTIFIER (STARTS AT A)
;N   - ASCII NUMBER OF THIS UNIT ON CURRENT KONTROLLER (STARTS AT 0)
;NK  - ASCII NUMBER OF NEXT UNIT ON CURRENT KONTROLLER (STARTS AT 1)
;NC1 - ASCII NUMBER OF THIS UNIT ON CURRENT CHANNEL (STARTS AT 0)
;NC  - ASCII NUMBER OF NEXT UNIT ON CURRENT CHANNEL (STARTS AT 1)
;NS1 - ASCII NUMBER OF THIS UNIT IN SYSTEM (STARTS AT 0)
;NS  - ASCII NUMBER OF NEXT UNIT IN SYSTEM (STARTS AT 1)
;S   - ASCII NUMBER OF CURRENT CHANNEL (STARTS AT 0)
;KT  - SYMBOL FOR CODE FOR KONTROLLER TYPE (=TYP'X)(EG TYPFH,TYPDP,TYPMD,TYPDR)
;XX  - KONTROLLER NO. WITHIN THIS KONTROLLER TYPE(STARTS AT 0)
;			EG.  0 FOR A, 1 FOR B ETC

;UNI:	UNIT DATA BLOCK
;POINTED TO BY EACH STR (FANOUT)(STRTAB)
;POINTS TO NEXT UNI IN SYS (ACROSS POINTER)(LH UNISYS)
;POINTS TO NEXT UNI WITHIN CHANNEL (RING)(RH UNICHN)
;POINTS TO NEXT UNI WITHIN KONTROLLER(ACROSS POINTER)(LH UNIKON)
;POINTS TO ITS CHN (UPWARD PTR)(RH UNICHN)
;POINTS TO ITS KON (UPWARD PTR)(RH UNIKON)
;POINTS TO NEXT UNI IN STR(ACROSS PTR)(LH UNISTR)
;POINTS TO ITS STR DATA BLOCK(UPWARD POINTER)(RH UNISTR)
;POINTS TO NEXT UNI IN ACTIVE SWAPPING LIST(ACROSS PTR)(LH UNISWP)

INTERN UNINAM,UNILOG,UNIHID,UNISTS,ICOD,PWCOD,PCOD,TWCOD,TCOD,UNISYS
INTERN UNISTR,UNICHN,UNIKON,UNIQUE,DIFUDQ,UNICDA,UNIGRP,UNICPS,UNISUN,OWCOD,OCOD
INTERN UNIBPU,UNICHR,UNICYL,UNIBLK,UNIHCT,UNISCT,UNIERR,UNISOF,UNIMCT,UNIPCT
INTERN UNISAB,DIFSAB,UNISPT,UNITAL,UNIDES,UNPRHB,UNPOFL,UNPHWP,UNPSWP,UNPWPO
INTERN UNPCHG,UNPSAF,UNPZMT,UNPPRF,UNVDWN,UNVNPM,UNVPBM,UNVPIM,UNPMSB,UNPNNA
INTERN UNYPUN,UNYLUN,UNYWPS,UNYUTP,UNYBPC,UNYBPT,UNYBPY,UNIUST,UNYKNM
INTERN UNYKTP,UNISWP,UNIPTR,UNISLB,UNIFKS,UNICFS,UNIK4S,DIFSWP,UNIBPC
INTERN UNIHOM,UNPSER,UNPRER,UNPCER,UNYLN1,UNIICT,UNIOCT,UNIHBN,UNISDI,UNIHDI
INTERN UNIBRC,UNIBWC,UNIDRC,UNIDWC,UNIMRC,UNIMWC,UNIMSC,UNIUSC,UNIXRA
INTERN DIFUNI,UNPAWL,UNPSTS,UNPSTL,UNIAWL,DIFUSY,UNIECT,UNIHNG,UNIBPY,UNIBPM
INTERN UNPHNR,UNPHRC,UNPHRS,UNPHPS,UNPUTP,UNIUTP,UNPFUS,UNPUNO,UNILAS,UNIEBK
INTERN FRSTDR,FRSTFH,FRSTDP,FRSTMD,FRSTFS,FRSTRP,O2COD,OW2COD,UNIJOB,UNITIM
DEFINE	UNITCB (N,X,U,NS,NS1,NC,NC1,NK,S,KT,XX)<

IFE FTAUTC,<
INTERN	X'U'N'CB
IFNDEF FIRUNI,<FIRUNI:>	;;DEFINE FIRST UNIT DATA BLOCK ADR. IN SYSTEM
>
IFN FTAUTC,<
	FIRUNI==0
>
X'U'N'CB:
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	 SIXBIT /X'U'N/
>
UNINAM==0	;;(0)SIXBIT PHYSICAL UNIT NAME WITHIN KONTROLLER
		;;LAST DIGIT IS 0 TO 7 -LEFT JUSTIFIED
		;; EXAMPLE:  DRA0,FHA0,MDA0,DPA0,DPA1,DPB3
		;;[NEVER CHANGED BY MONITOR]

	PHASE	1
UNILOG:!0	;;(1)SIXBIT LOGICAL UNIT NAME WITHIN STR
		;; LAST DIGIT OR TWO IS 0 TO 77 LEFT JUSTIFIED
		;; EXAMPLE:  DSKA0,DSKB0,DSKC0,DSKA17 [SET FROM HOMLOG BY HOMRED]
UNIHID:!0	;;(2)SIXBIT HOME BLOCK IDNAME - NEVER CHANGED IN HOME BLOCK
		;; SET WHEN SECTOR HEADERS ARE WRITTEN.  FOR DISK PACKS
		;; THE HOME BLOCK ID NAME IS THE PACK ID.

IFE FTAUTC,<
	%SY'NS1=X'U'N'CB
>
UNISYS:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD %SY'NS,0 ;;(3)LH=CORE ADDRESS(ACROSS POINTER) OF NEXT
>
		;; UNIT DATA BLOCK IN SYSTEM, LH=0 IN LAST UNIT IN SYSTEM
DIFUSY==SYSUNI-UNISYS	;;USED BY ONCMOD
UNISIC==UNISYS	;;# SAT BLOCKS IN CORE FOR THIS UNIT - WORD ADDR
	UNSSIC==^D8	;;BYTE POSITION
	UNNSIC==^D25	;;BYTE PTR POS
UNILUN==UNISYS	;;RH. LOGICAL UNIT NUMBER WITHIN FILE STRUCTURE OF THIS UNIT-WORD ADR.
	UNSLUN==^D6	;;BYTE SIZE
	UNNLUN==^D35	;;BYTE PTR POS.

UNISTR:!XWD 0,0	;;(4)LH=ADDRESS OF NEXT UNIT DATA BLOCK IN STR
		;; LH=0 IN LAST UNIT IN FILE STRUCTURE
		;; RH=UPWARD POINTER TO FILE STR. DATA BLOCK.
		;;WORD=0 IF THIS UNIT IS NOT IN AN STR
DIFUNI==STRUNI-UNISTR	;;DIFFERENCE BETWEEN DOWNWARD AND UPWARD POINTERS(STR AND UNI)

IFE FTAUTC,<
%CH'S'NC1=X'U'N'CB
>
UNICHN:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD %CH'S'NC,THSCCB	;;(5)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME CHANNEL
>
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO CHANNEL DATA BLOCK.
IFE FTAUTC,<
%'X'U'N=X'U'N'CB
>
UNIKON:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD %'X'U'NK,X'U'CB	;;(6)LH=ADDRESS OF NEXT UNIT DATA BLOCK ON SAME KON
>
		;; LAST UNIT POINTS BACK TO FIRST UNIT (RING)
		;; RH=UPWARD POINTER TO KONTROLLER DATA BLOCK
UNISWP:!XWD 0,0	;;(7)LH=CORE ADDR OF NEXT UNIT FOR SWAPPING
DIFSWP==SWPUNI-UNISWP ;;USED IN ONCE ONLY FOR LINKING UNITS IN ACTIVE SWAPPING LIST
UNICFS==UNISWP	;;RH CONTAINS BYTE WHICH IS CLASS FOR SWAPPING
		;; SWAPPER WILL TRY EVERYTHING TO SWAP ON ONE CLASS
		;; BEFORE TRYING NEXT CLASS, TO KEEP ON FASTEST UNITS
	UNSCFS==^D3	;;BYTE SIZE
	UNNCFS==^D22	;;BYTE PTR POS
;ERROR STATISTICS:
UNIHCT:!0	;;(10)NO. OF HARD DISK ERRORS ON THIS UNIT (RETRYS FAILED TO CLEAR ERROR)
		;; LH=NO. DEVICE+SEEK + SEARCH ERRORS(IODERR)(CHAN+CONTROL)(SEE UNIPCT)
		;; RH=NO. DATA ERRORS(IODTER)(HARDWARE DEVICE DATA PARITY
UNISCT:!0	;;(11)NO. OF SOFT + NO. OF HARD ERRORS - INCREMENTED
		;; ONCE WHEN SUCCESS FOLLOWS ONE OR MORE FAILURES
		;; NOT INCREMENTED ON HARD ERRORS
		;;LH=NO. SOFT+HARD DEVICE+SEARCH ERRORS(SEE UNIPCT)
		;; RH=NO SOFT+HARD DATA ERRORS
UNIMCT:!0	;;(12)NO. OF MONITOR DETECTED ERRORS(3 12 BIT FIELDS)
		;; USER PROGRAM SEES IOIMPM ERROR BIT SET FOR ALL 3 TYPES OF ERRORS
	UNPSER==100	;;NO. OF SAT FAILURES(NO. OF FREE CLUSTERS ON DISK SAT
		;; DISAGREE WITH EXPECTED NO AS STORED IN CORE)
	UNPRER==10000	;;NO. OF RIB REDUNDANT INFO FAILED TO COMPARE
	UNPCER==1	;;NO. OF SOFTWARE FOLDED CHECKSUM FAILURES(USER IO BUT NOT SWAP)
		;; (MUST BE RIGHT JUSTIFIED FOR AOS)
UNIERR:!0	;;(13)LAST ERROR DEVICE STATUS
		;; WHICH OCCURRED ON THIS UNIT AFTER FIRST RECOVERY
		;; ATTEMPT FAILED. SET BY MOVEM T2,UNIERR(U)
		;; IN FILSER WHERE T2 IS SET DIRECTLY FROM
		;; KONTROLLER STATUS WORD IN KONTROLLER DEPENDENT ROUTINE.
		;;IF RECOVERY SUCCEEDS BEFORE FIRST RECAL, UNIERR WILL CONTAIN 0
UNISOF:!0	;;(14)LAST ERROR DEVICE STATUS ON THIS UNIT
		;; BEFORE ANY RECOVERY ATTEMPTED
		;; DEVICE, DATA, SEARCH, HUNG ERRORS
UNIHBN:!0	;;(15)LAST LOGICAL BLOCK NUMBER ON HARD OR SOFT ERROR
		;; NOTE: SPEC CHANGED IN 5.06 TO INCLUDE SOFT ERROR

;;PERFORMANCE MONITORING DATA LOCATIONS:!
;;NOTE FOLLOWING 6 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL
;; TRANSFERS ON THIS UNIT(EXCEPT ERROR RETRYS)
;;WRITE COUNT MUST BE READ COUNT+1
UNIBRC:!0	;;(16)NO. OF BUFFERED MODE 128 WORD BLOCKS READ
UNIBWC:!0	;;(17)NO. OF BUFFERRED MODE 128 WORD BLOCKS WRITTEN
UNIDRC:!0	;;(20)NO. OF DUMP MODE 128 WORD BLOCKS READ(INCLUDEING GETS)
UNIDWC:!0	;;(21)NO. OF DUMP MODE 128 WORD BLOCKS WRITTEN(INCLUDING SAVES)
UNIMRC:!0	;;(22)NO. OF MONITOR 128 WORD BLOCKS READ(SAT,UFD,MFD,BAT,SWAP)
UNIMWC:!0	;;(23)NO. OF MONITOR 128 WORD BLOCKS WRITTEN(
		;; SAT,UFD,MFD,BAT,SWAP)
;;NOTE: TO COMPUTE NO. OF MONITOR OVERHEAD READS(WRITES)
;;  SUBTRACT UNIICT(UNIOCT) FROM UNIMRC(UNIMWC)
UNIICT:!0	;;(24)NO. OF 128 WORD BLOCKS SWAPPED IN(SET BY SWPINT)
UNIOCT:!0	;;(25)NO. OF 128 WORD BLOCKS SWAPPED OUT(SET BY SWPINT)
;;NOTE:!FOLLOWING 2 ENTRIES ARE MUTUALLY EXCLUSIVE AND ACCOUNT FOR ALL SEEKS
;; ON THIS UNIT EXCEPT END OF CYLINDER AND RECALIBRATION AND SEEK UUOS
UNIMSC:!0	;;(26)COUNT OF NO. OF MONITOR+SWAP SEEKS
UNIUSC:!0	;;(27)COUNT OF NO. OF USER(BUFFER+DUMP) SEEKS
		;; (INCLUDES GETS AND SAVES)

;;MORE ERROR STATISTICS:!
UNIPCT:!0	;;(30)(UNUSED IN 503) SEEK INCOMPLETE ERRORS(UPDATED BY KONTOLLER ROUTINES)
		;; RATHER THAN FILSER). NOTE THIS IS DIFFERENT FROM
		;; SEARCH ERRORS (SEE UNIHCT,UNISCT)
		;; RH=SOFT+HARD SEEK-INCOMPLETE FAILURES
		;; LH=POSITIONING FAILURES
		;; HARD ERRORS ARE REPORTED TO FILSER AS DEVICE ERRORS TOO
		;; FILSER RETRYS 'DSKTRY' TIMES AND COUNTS IN LH UNIHCT,UNISCT
UNIFKS:!0	;;(31) FREE K FOR SWAPPING ON THIS UNIT
		;; 0 MEANS FULL OR UNIT DOESN'T HAVE SWAPPING SPACE ALLOCATED
	UNISUN==UNIFKS ;;THIS LOCATION TIME-SHARED BY ONCE ONLY CODE TO
		;; REMEMBER LOG. UNIT # OF UNIT IN ACTIVE SWAPPING LIST.
		;; -1 IF NOT IN LIST.
UNISDI:!0	;;(32)LAST ERROR DATAI STATUS WORD
		;; DATA,DEVICE,SEARCH HUNG ERRORS BEFORE RECOVERY ATTEMPTED
UNIHDI:!0	;;(33)LAST ERROR DATAI STATUS WORD
		;; DATA,DEVICE,SEARCH ERRORS AFTER FIRST RECOVERY ATTEMPT FAILS
UNIECT:!0	;;(34) NO. OF CONSECUTIVE TIMES AN ERROR STATUS WAS RETURNED
		;; FOR THE LAST OPERATION ON THIS UNIT. (IE, FIRST+RETRIES
		;; WITH ERRORS).  SET BACK TO 1 ON FIRST ERROR, RATHER THAN
		;; BEGINNING OF NEW OPERATION, SO USER PROGRAMS HAVE MORE
		;; TIME TO LOOK AT IT.
	XP UNPFIR,400000	;; SIGN BIT (UNPFIR)=1 DURING FIRST TRY, 0 DURING RETRIES
				;; THIS BIT IS TOO DYNAMIC TO BE USEFUL FOR DAEMON ERR
				;; REPORTING
	XP UNPHRD,200000	;; UNPHRD=1 IF LAST ERROR WAS HARD, RESET WHEN RETRY COUNTER RESET
				;; SO IT IS USEFUL FOR ERROR REPORTING
	XP	UNPHNG,100000	;; =1 IF DRIVE WAS HUNG
UNIHNG:!0	;;(35)NO.OF HUNG TIME OUTS WHICH COULD NOT BE RECOVERED
		;;RH==NO. OF TIME OUTS WHICH WERE RECOVERED
	UNPHNR==1000	;;LH BIT TO COUNT HUNGS NOT RECOVERED BY
		;; STOPPING UNIT (KONSTP) UNIT IN TRANSFER STATE
	UNPHRC==1	;;LH BIT TO COUNT HUNGS RECOVERED BY
		;; STOPPING UNIT (KONSTP) UNIT IN TRANSFER STATE
	UNPHRS==1	;;RH BIT TO COUNT HUNGS RECOVERED BY
		;; RESTARTING UNIT (UUOTWQ OR PIKTRN)
		;; UNIT WAS IDLE OR TRANSFER WAIT
		;; AND CHANNEL WAS IDLE.  (MUST BE BIT 35 FOR AOS)
	UNPHPS==1000	;;RH BIT TO COUNT NUMBER OF HUNGS
		;; CAUSED (AND RECOVERED WITHOUT OPERATOR INTEVENTION)
		;; BY UNIT IN POSITION STATE

UNISTS:!0	;;STATUS WORD FOR UNIT - SET, CHANGED BY FILSER ONLY
		;;ONLY WHOLE WORD USED SO THAT EXCH TRICK CAN BE USED
		;;THESE SAME CODES ARE USED IN DEYCOD BYTE
	ICOD==0		;;IDLE - NO POSITIONING OR TRANSFERRING AND NO QUEUED
			;; REQUESTS FOR POSITIONING OR TRANSFERRING
	PWCOD==ICOD+1	;;WAITING TO POSITION WITH IMPLIED TRANSFER INTENDED
	PCOD==PWCOD+1	;;IN PROCESS OF POSITIONING
	TWCOD==PCOD+1	;;WAITING TO DO DATA TRANSFER
	TCOD==TWCOD+1	;;IN PROCESS OF DATA TRANSFER
	MDACOD==:TCOD+1	;;ONLY USABLE BY MDA (REREAD HOM BLOCKS, NO COMPARE)
;NOTE THAT THE FOLLOWING CODES MUST BE THE HIGHEST DEFINED
	OWCOD==MDACOD+1	;;WAITING FOR OPERATOR INTERVENTION, FILE IN T STATE
	OCOD==OWCOD+1	;;WAITING FOR OPR INTERVENTION, NO FILE ACTIVE
	OW2COD==OWCOD+2	;;OW, BUT NO MESSAGE ONCE A MINUTE
	O2COD==OCOD+2	;;O, BUT NO MESSAGE
UNICCT::!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD	777,0	;;RH=NUMBER OF CHAN TERMINATION ERRORS
>
UNIBCT==:UNICCT		;;BITS 9-17 = NUMBER OF SLOTS LEFT IN BAT BLOCK FOR UNIT
			;; 777 MEANS DONT KNOW
	UNSBCT==:^D9	;;BYTE SIZE
	UNNBCT==:^D17	;;POSITION
UNISNS==:UNICCT		;;BITS 0-8=SECTION NUMBER OF SECTION
			;; CONTAINING SWAPPING SATS
	UNSSNS==^D9	;;BYTE SIZE
	UNNSNS==^D8	;;BYTE POSITION

IFNDEF X'U'N'HM,<X'U'N'HM==LBNHOM>	;;DEFINE 1ST LOGICAL BLOCK
		;; FOR HOME BLOCK IF CUSTOMER HASN'T CHANGED WITH MONGEN
IFNDEF X'U'N'H2,<X'U'N'H2==LB2HOM>	;;DEFINE 2ND LOGICAL BLOCK
		;; FOR HOME BLOCK IF CUSTOMER HASN'T CHANGED WITH MONGEN
UNIHOM:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	XWD X'U'N'HM,X'U'N'H2	;;LOGICAL DISK BLOCK NO. WITHIN UNIT
>
		;; (NOT STR) OF THE TWO HOME BLOCKS ON THIS UNIT.
		;; LH=FIRST HOME BLOCK, RH=REDUNDANT ONE.  NOTE:
		;; LOGICAL BLOCK NOS. ARE NOT USUALLY RESTRICTED TO
		;; ANYTHING LESS THAN 36 BITS. HOWEVER THE HOME BLOCKS ARE
		;; RESTRICTED TO BEING LOCATED SOMEWHERE ON THE FIRST
		;; 262,000 BLOCKS ON THIS UNIT
		;; USED BY REDHOM IN ONCE ONLY CODE.
		;; THESE ARE THE ONLY DISK ADDRESSES ASSEMBLED INTO THE
		;; MONITOR. ALL OTHER DISK ADDRESSES ARE
		;; STORED ON THE DISK, STARTING WITH THE HOME BLOCK
UNIQUE:!XWD 0,0	;;LH=ADDRESS OF FIRST (LONGEST WAITING) DEVICE DATA BLOCK (FILE)
		;; IN POSITION WAIT FOR THIS UNIT (PW QUEUE)
		;;RH=JOB NUMBER FOR DDB WHOSE ADDRESS IS IN LH
		;;AS A FLAG, BOTH HALVES ARE SET TO 0 WHEN NO FILES IN
		;; POSITION WAIT QUEUE.
		;;NOTE:!THE FILE WHICH IS IN P STATE IS NOT IN QUEUE
DIFUDQ==UNIQUE-DEVQUE ;;DIFF. OF HEAD OF Q PTR AND LINK-USED TO START
		;; QUEUE SEARCH
UNIGRP:!XWD 0,0	;;LH=NO. OF SEQUENTIAL BLOCKS (NOT CLUSTERS) TO TRY ON
		;; SEQUENTIAL OUTPUT (CAN BE CHANGED WITHOUT REFRESHING)
		;;BITS	22-26	UNUSED
IFN FTMP,<
UNIPWQ==:UNIGRP	;;BIT 18 ON IF THERE IS AN OUTSTANDING CLOCK REQUEST
		;;FOR THE OTHER CPU TO PROCESS ITS POSITION WAIT QUEUE
	UNPPWQ==:1B18
>
UNINDU==:UNIGRP	;;BIT 19 ON IF WANT TO FLUSH UNIT FROM DISK CACHE
	UNPNDU==:1B19
UNIRHP==:UNIGRP	;;BIT 20 ON IF REHEAD OF HOME IS IN PROGRESS
	UNPRHP==:1B20
UNIMSG==:UNIGRP	;;BIT 21 ON IF UNIT OFFLINE MSG HAS BEEN PRINTED THIS MINUTE
	UNPMSG==:1B21
UNILKP==UNIGRP	;;BITS 27-35:LAST KNOWN POSITION OF DISK
		;; MEANINGFUL ONLY FOR RP20
	UNSLKP==^D9
	UNNLKP==^D35
UNIBPU:!0	;;NO. OF LOGICAL BLOCKS PER UNIT(RETURNED BY DSKCHR)
		;; SET BY TESTING IN ONCMOD
UNIBPM:!0	;;NO OF LOGICAL BLOCKS PER UNIT INCLUDING MAINTENANCE CYLINDERS
INTERN UNIPCI,UNIPCO
UNIPCI:!0			;;NO OF BLOCKS PAGED IN
UNIPCO:!0			;;NO OF BLOCKS PAGED OUT

UNICHR:!0	;;UNIT CHARACTERISTICS (RETURNED IN DSKCHR UUO);;
UNIBPC==UNICHR	;;BITS 0-8 = # BLOCKS/CLUSTER
	UNSBPC==^D9
	UNNBPC==^D8
UNIBPT==UNICHR	;;BITS 9-17= # BLOCKS/TRACK - SET BY TESTING IN ONCMOD
	UNSBPT==UNSLKP
	UNNBPT==^D17
UNIBPY==UNICHR	;;BITS18-35= # BLOCKS/CYLINDER (THE SMALLEST IF CYLINDER
	UNSBPY==^D18	;; HAVE DIFFERENT SIZES (MDF)) - SET BY TESTING IN ONCMOD
	UNNBPY==^D35
UNICPS:!0	;;RH=NO. OF CLUSTERS PER SAT TABLE ON THIS UNIT
		;; (ROUNDED UP IF NOT AN EVEN NUMBER OF CLUSTERS)
		;;BIT9 = UNUSED.
UNIWPS==UNICPS	;;# OF WORDS PER SAF BLOCK ON DISK FOR THIS UNIT-WORD ADR.
		;; LIMITED TO 128 WORDS OR CLUSTER SIZE WHICHEVER IS SMALLER
	UNSWPS==^D9	;;BYTE SIZE
	UNNWPS==^D8	;;BYTE PTR. POS.
UNISPU==UNICPS	;;NO. OF SAT BLOCKS ON THIS UNIT - WORD ADR.
	UNSSPU==^D8	;;BYTE SIZE
	UNNSPU==^D17	;;PYTE PTR POS.
UNICYL:!-1	;;PHYSICAL CYLINDER UNIT IS CURRENTLY AT OR POSITIONING TOWARDS.
		;; THIS IS ONLY WORD SET AND LOOKED AT BY DEVICE DEPENDENT ROUTINE.
		;; USED BY FILSER TO SEE IF UNITS IN POSITION, NEVER CHANGED BY FILSER
		;; INITIALIZE TO -1 SO FORCE POSITIONING FOR FIRST READ
		;; ELSE GET POSITIONING ERROR AND FALSE ERROR DATA
UNIBLK:!0	;;LOGICAL BLOCK NUMBER WITHIN THE UNIT.
		;; ARG TO DEVICE DEPENDENT ROUTINES
UNISAB:!XWD 0,0	;;LH=ADDR. OF FIRST SAB BLOCK IN RING FOR UNIT
DIFSAB==UNISAB-SABRNG
UNITAL:!0	;;NO. OF FREE BLOCKS(RESERVED+FCFS) LEFT ON THIS UNIT
		;; [NO SAFETY FACTOR FOR UNIT
		;; INSTEAD THERE IS ONE FOR THE STR]
UNIDES:!
IFN FTAUTC,<EXP 0>
IFE FTAUTC,<
	BYTE (18)0(3)$CHN(6)KT(3)XX(3)0(3)$K-1
>
		;;WORD RETURNED IN AC FOR DSKCHR UUO DESCRIBES THIS DISK
		;; UNIT IN TERMS OF STR NUMBER, CHANNEL,
		;; KONTROLLER UNIT NUMBER. ETC.
		;; $K   = BINARY NUMBER OF NEXT UNIT ON KONTROLLER (STARTS AT 0)
		;; $CHN = BINARY CHANNEL NUMBER (STARTS AT 0)
		;; XX   = BINARY KONTROLLER NUMBER (STARTS 0 FOR EACH KONTROLLER TYPE)
		;;HENCE, UNIDES RH=(3)CHANNEL NUM(6)KONTROLLER TYPE
		;; (3)KONTROLLER NUM(3)UNIT TYPE(3)UNIT NUMBER
	UNPRHB==400000 ;;BIT 0=1 IF MONITOR MUST REREAD HOME BLOCK BEFORE NEXT OPERATION
		;; TO INSURE THE PACK ID IS CORRECT.  THE MONITOR SETS THIS BIT
		;; WHENEVER A DISK PACK GOES OFF LINE.
	UNPOFL==200000 ;;BIT 1=1 IF THE UNIT IS OFF LINE
	UNPHWP==100000 ;;BIT 2=1 IF THE UNIT IS HARDWARE WRITE PROTECTED
	UNPWPO==UNPHWP!UNPOFL
	UNPSWP==40000  ;;BIT 3=1 IF THIS UNIT IS A MEMBER OF A STR WHICH IS SOFTWARE
		;; WRITE PROTECTED FOR THIS JOB.
		;; BIT IS   NEVER STORED HERE IN UNIT DATA BLOCK.  MUST BE
		;; COMPUTED ON EACH DSKCHR UUO.  FOR EACH JOB FROM JBTPPB(SEE STRUUO.)
	UNPCHG==UNPSWP ;;TIMESHARED BIT-A PARAMETER WAS CHANGED SO HOME BLOCK MUST BE WRITTEN
		;;  USED ONLY DURING ONCE ONLY CODE THEN CLEARED BEFORE SYSTEM STARTED
	UNPSAF==20000	;;BIT 4=1 IF UNIT IS MEMBER OF SINGLE-ACCESS F.S.
		;; NOT STORED IN UNIT DATA BLOCK
IFN FTSETS,<
	UNPNMU==:UNPSAF	;;TIMESHARED BIT-A UNIT WHICH BELONGS TO A DISK SET
		;; NOT MOUNTED TO THIS SYSTEM
		;; USED ONLY DURING ONCE ONLY CODE THEN CLEARED BEFORE SYSTEM STARTED
>; END IFN FTSETS
	UNPZMT==10000	;;BIT 5=1 IF THIS UNIT IS A MEMBER OF A STR WHOSE MOUNT COUNT
		;; HAS GONE DOWN TO ZERO, MEANING NO ONE IS USING THE STR.
		;; NOT STORED IN UNIT DATA BLOCK.
	UNPTSB==:UNPCHG	;;TIMESHARED BITS TO CLEAR WHEN EXITING ONCE ONLY CODE
IFN FTSETS,<
	UNPTSB==:UNPTSB!UNPNMU	;;INCLUDE THIS BIT
>; END IFN FTSETS
UNIPRF==UNIDES	;;UNIT IS A MEMBER OF A PRIVATE STR - WORD ADR.
	UNSPRF==^D1	;;BYTE SIZE
	UNNPRF==^D6	;;BYTE PTR. POS.
	UNPPRF==4000	;;THE BIT
		;;BITS 7 AND 8
UNIUST==UNIDES	;;UNIT STATUS - WORD ADR.
	UNSUST==^D2	;; BYTE SIZE
	UNNUST==^D8	;; BYTE PTR POS.
	UNVDWN==3	;;UNIT IS DOWN - CODE VALUE
	UNVNPM==2	;;UNIT IS UP BUT NO PACK MOUNTED - CODE VALUE
	UNVPBM==1	;;UNIT IS UP AND PACK BEING MOUNTED BY OPERATOR - CODE VALUE
	UNVPIM==0	;;UNIT IS UP AND PACK IS MOUNTED - CODE VALUE
	UNPMSB==400	;;BIT 9=1 IF THIS UNIT HAS MORE THAN ONE SAT BLOCK
	UNPNNA==200	;;BIT 10=1 IF THIS UNIT IS A MEMBER OF A STR FOR WHICH THE
		;; OPERATOR HAS REQUESTED NO NEW ACCESS INIT'S, LOOKUPS, OR ENTERS SET
		;; BY PRIVILEGED STRUUO FUNCTION
UNIAWL==UNIDES	;;BIT 11=1 IF THIS STR IS SOFTWARE WRTIE PROTECTED FROM ALL JOBS
	UNSAWL==^D1	;;BYTE SIZE
	UNNAWL==^D11	;;BYTE PTR POS.
	UNPAWL==100	;;THE BIT
	UNPFUS==40	;;BIT 12=1 IF THIS UNIT GOT A FILE UNSAFE CONDITION
		;; AT CONNECT TIME (UUO OR INT). USED TO TELL OPERATOR
		;; CLEARED WHEN UMT COMES ON-LINE WITH INTERRUPT
	UNPSTS==UNPAWL ;;BITS CHANGEABLE BY STRUUO(.FSRDF)
		;; EITHER SINGLE ACCESS OR WRITE PROTECTED FROM ALL JOBS
	UNPSTL==UNPSTS!UNPNNA!UNPRHB!UNPMSB!UNPHWP	;;BITS TO BE DETERMINED WHEN DEFINED (STRUUO-.FSDEF)

UNIWMD==:UNIDES	;;UNIT WAITING FOR MDA TO DO SOMETHING - WORD ADDRESS
	UNPWMD==:20	;; THE BIT
	UNPALT==:10	;;BIT SET IN AC IF THIS IS DUAL PORTED
	UNPUSI==:4	;;UNIT STATUS INCONSISTENT (BADUNI)
	UNPRSS==:2	;REMOVING SWAPPING UNIT
			;;BITS 15 - 17 DSKCHR ARGUMENT TAPE OR 0 INTO AC
	UNPUNO==UNPFUS+UNPOFL	;;OFF-LINE + UNSAFE

		;;BITS 15 - 17 ARE A CODE WHICH TELLS WHETHER THE ARGUMENT PASSED TO
		;; MONITOR IN LOC WAS:(NEVER STORED IN UNIT DATA BLOCK)
		;; 0	GENERIC DEVICE DSK OR LOGICAL NAME FOR IT (E.G., DSK)
		;; 1	SUBSET OF STR BECAUSE OF AN STR ABBREVIATION
		;; 2	STR NAME OR LOGICAL NAME FOR IT (E.G., DSKA)
		;; 3	UNIT WITHIN A FILE STRUCTURE OR A LOGICAL NAME FOR IT
		;; 	(E.G., DSKA0)
		;; 4	A KONTROLLER CLASS NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DR,FH,DP,MD)
		;; 5	A KONTROLLER NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA,FHA,DPA,MDA,DPB)
		;; 6	A PHYSICAL DISK UNIT NAME OR A LOGICAL NAME FOR IT
		;; 	(E.G., DRA0,DPA3)
		;;RH CONFIGURATION INFORMATION:
		;;(OBSOLETE) BITS 18-20 DATA CHANNEL NUMBER
UNIKTP==UNIDES	;;BITS 21-26 CONTROLLER TYPE
	UNSKTP==^D6	;;BYTE SIZE
	UNNKTP==^D26	;;BYTE PTR POS.
	TYPDR==0	;; 0	DR (FUTURE DRUM, IF ANY)
	TYPFH==1	;; 1	FH (BURROUGHS DISK OR BRYANT DRUM)
	TYPDP==2	;; 2	DP (MEMOREX RP01,RP02,RP03)
	TYPMD==3	;; 3	MD (BRYANT MASS DISK)
	TYPFS==4	;; 4	FS (RH10/RS04)
	TYPRP==5	;; 5	RP (RH10/RP04,RP05)
	TYPRN==6	;; 6	RN (RH20/RP20)
		;;(OBSOLETE) BITS 27-29 KONTROLLER NUMBER
UNIUTP==UNIDES	;;BITS 30-32 UNIT TYPE - A KONTROLLER DEPENDENT FIELD USED TO
	UNSUTP==^D3	;; DISTINGUISH VARIOUS OPTIONS OF A UNIT ON ITS KONTROLLER
	UNNUTP==^D32	;;BITS 21-26   BITS 30-32
	UNPUTP==10	;;RIGHT MOST BIT
	FRSTDR==0	;;POSITION OF OR UNIT TYPES ON TABLES IN ONCMOD
		;;	0	     0
	FRSTFH==FRSTDR+2	;;POSITION OF FH UNIT TYPES ON TABLES IN ONCMOD
		;;	1	     0	BURROUGHS DISK ON RC10
		;;		     1	BRYANT DRUM ON RC10
	FRSTDP==FRSTFH+2	;;POSITION OF DP UNIT TYPES ON TABLES IN ONCMOD
		;;	2	     0	RP01
		;;		     1	RP02
		;;		     2	RP03
	FRSTMD==FRSTDP+3	;;POSTION OF MD UNIT TYPES ON TABLES IN ONCMOD
		;;	3	     0	DUAL POSITIONER
		;;		     1	SINGLE POSITIONER
	FRSTFS==FRSTMD+2	;;POSITION OF FS UNIT TYPES
	FRSTRP==FRSTFS+1	;;POSITION OF RP UNIT TYPES
		;;		     0	RP04
		;;		     1	RP06
		;;		     2	RM03
		;;		     3	RP07
	FRSTRN==:FRSTRP+4	;;POSITION OF RN UNIT TYPES
		;;		     0	RP20
	FRSTRA==:FRSTRN+1	;;POSITION OF RA UNIT TYPES
		;;		     0	RA80
		;;		     1	RA81
		;;		     2	RA60
		;;(OBSOLETE) BITS 33-35 PHYSICAL UNIT NUMBER WITHIN KONTROLLER

UNIPTR:!0	;;LH=-LENGTH OF SWAP SAT TABLE
		;;RH=ADDR OF SWAP SAT TABLE (ALWAYS IN CORE)
		;; EACH BIT REPRESENTS 1K OF SWAPPING STORAGE
UNISLB:!0	;;FIRST SWAP LOGICAL BLOCK # ON THIS UNIT

UNIXRA:!0	;;LH=-NUMBER OF BLOCKS WRITTEN VIA EXTENDED RIBS
		;;RH=-NUMBER OF BLOCKS READ VIA EXTENDED RIBS
UNICDA:!XWD	0,0	;;RH=ADR OF DDB CURRENTLY
			;; POSITIONING OR XFERRING ON THIS WAIT
			;;LH=FORMER RH (RH ZEROED WHEN UNIT IDLE)
UNIGEN::!XWD	ZERO18,0;;GENERATION NUMBER OF UDB (AOS'D WHEN UNIT DISMOUNTED)
UNIRCV::!0	;;NUMBER OF RETRIES OF HUNG UNIT WITHOUT RECOVERING
UNISWA::!0	;;ADDRESS OF CURRENT SWPLST ENTRY
	UNISID==:UNISWA ;;TIME-SHARED WORD BY ONCE ONLY TO REMEMBER SWAPPING ID
UNISWD::!0	;;DISTANCE (OR TIME TO BLOCK) OF BEST SWAP FOR UNIT

UNIQUL::! 0	;;LENGTH OF POSITION WAIT QUEUE

UNIBUC::!0	;;NO OF BLOCKS ON UNIT IN 10/11 COMPAT.MODE

UNIDIA::!0		;;JOB NUMBER,,DDB OF JOB SHUTTING DOWN IO (DIAG.)

IFN FTDUAL!FTCIDSK,<
UNIALT::!0		;;RH = ADDRESS OF ALTERNATE PORT (UNLIKE UNI2ND NEVER
			;; CHANGES ONCE SET UP BY MATUN)
	CPUMSK==:77	;;LH = BIT MASK OF CPUS WHICH HAVE ATTACHED THIS PORT
			;; (BITS 12-17)
UNI2ND::!0		;;RH=ADDR OF OTHER PORT
			;;LH=-1 IFF THIS PORT IS THE ALTERNATE PORT
			;;(I.E. UNI2ND=-1,,<MAIN PORT>)
UNISER::!EXP 0,0	;;DRIVE SERIAL NUMBER (SECOND WORD ONLY USED FOR
			;; DISKS ON AN HSC-50)
>
UNITIM::!0		;;HUNG-TIMER (PDVTIM NOT USED FOR DSK DDBS)
UNIJOB::!0		;;RH=JOB NUMBER FOR DDB WHOSE ADDRESS IS IN RH(UNICDA)
			;;(0 WHEN RH(UNICDA)=0)
			;;LH=PREVIOUS RH(UNIJOB)
UNIAJB::!0			;;[P-156] RH NUMBER OF JOB OWNING DA OR ZERO
				;;[P-156] LH NUMBER OF PEOPLE WANTING (WAITERS+USER)
UNIDS2::!		;;MORE STATUS BITS
IFN FTAUTC,<0>
IFE FTAUTC,<
	BYTE (18)0(9)XX(9)$K-1
>; END IFE FTAUTC
			;;LH BITS
	U2PNRM==:400000		;;BIT 0=1 IF NON-REMOVABLE MEDIA
	U2PPGA==:200000		;;BIT =1 IF PORT WENT AWAY WITHOUT AN OFF-LINE INTERRUPT
UNIKOF==UNIDS2		;;BITS 9-17 "KONTAB" OFFSET
	UNSKOF==^D9		;;BYTE SIZE
	UNNKOF==^D26		;;BYTE PTR POS
UNIKNM==UNIDS2		;;BITS 18-26 KONTROLLER NUMBER
	UNSKNM==^D9		;;BYTE SIZE
	UNNKNM==^D26		;;BYTE PTR POS
UNIPUN==:UNIDS2		;;BITS 27-35 PHYSICAL UNIT NUMBER
	UNSPUN==^D9		;;BYTE SIZE
	UNNPUN==^D35		;;BYTE PTR POS
	UNWPUN==:777		;;MASK FOR THIS FIELD
IFN FTMDA,<
UNILTM::!0			;;UNIVERSAL DATE-TIME OF LOCK ON STR
>;END IFN FTMDA
UNISPT::!0		;;RH=ADDRESS OF STORAGE ALLOC. POINTERS (SPT) TABLE
UNIPGT::!0		;;PAGE QTR TURNS,,PAGE TURN
			;;NO OF TIMES WE REREAD RIB TO GET NEW PNTRS
UNICRC::!0		;;MONITOR CACHE READ CALLS
UNICRH::!0		;;MONITOR CACHE READ HITS
UNICWC::!0		;;MONITOR CACHE WRITE CALLS
UNICWH::!0		;;MONITOR CACHE WRITE HITS
UNICBK::!0		;;MONITOR BLOCKS CACHED THIS UNIT
UNIK4S:!0	;;K FOR SWAPPING ON THIS UNIT - WORD ADR.
		;; WHETHER UNIT IS IN ACTIVE SWAPPING LIST OR NOT
	UNSK4S==^D36	;;BYTE SIZE
	UNNK4S==^D35	;;BYTE PTR. POS.
;;THESE MUST BE THE LAST THINGS IN THE UDB.......
UNILAS:!0			;;LAST COMMAND ISSUED TO MASSBUS DEVICE
;;****DAEMON DEPENDS ON NEXT 5 LABELS BEING CONTIGUOUS****
UNISCR::!0			;;CONTROL REGISTER AT 1ST ERROR
UNIHCR::!0			;;CONTROL REGISTER AT END
UNISDR::!0			;;DATA REGISTER AT 1ST ERROR
UNIHDR::!0			;;DATA REGISTER AT END
UNIEBK:!BLOCK	X'ERNO+1	;;DRIVE REGISTERS SAVED ON ERROR HERE
				;;LH=LAST ERROR, RH=1ST ERROR
				;;LAST WORD IN BLOCK IS COMMAND WHICH CAUSED THE ERROR

	DEPHASE
>	;;END MACRO DEF OF UNITCB

DEFINE	SYSCLS (N)<
%SY'N==0>

DEFINE	CHNCLS (N,S)<
IFDEF %CH'S'A,<
%CH'S'N==%CH'S'A>>

DEFINE	KONCLS (N,SYM)<
%'SYM'N==%'SYM'0>

INTERN UNYPUN,UNYLUN,UNYWPS,UNYUTP,UNYBPC,UNYBPT,UNYBPY,UNYUST,UNYKTP
INTERN UNYSIC,UNYCFS,UNYK4S,UNYAWL,UNYPRF,UNYSPU,UNZCFS,UNZFKS

	$HIGH
UNYPUN:	POINT	UNSPUN,UNIPUN(U),UNNPUN	;PHYSICAL UNIT # (0-7) WITHIN KONTROLLER
					; ARG TO KONTROLLER ROUTINES
UNYLUN:	POINT	UNSLUN,UNILUN(U),UNNLUN	;LOGICAL UNIT # (0-77) WITHIN STR
UNYLN1:	POINT	UNSLUN,UNILUN(T1),UNNLUN ;LOGICAL UNIT # - FOR ONCE ONLY
UNYLN2::POINT	UNSLUN,UNILUN(T2),UNNLUN ;SAME, BUT T2 AS INDEX
UNYWPS:	POINT	UNSWPS,UNIWPS(U),UNNWPS	;+VE NO. OF WORDS PER SAT BLOCK
UNYUTP:	POINT	UNSUTP,UNIUTP(U),UNNUTP	;UNIT TYPE(KONTROLLER DEPENDENT)
					; SET BY ONCE ONLY
UNYBPC:	POINT	UNSBPC,UNIBPC(U),UNNBPC	;BLOCKS/CLUSTER - ARG TO KONTROLLER ROUTINES
UNYBPT:	POINT	UNSBPT,UNIBPT(U),UNNBPT	;BLOCKS/TRACK - ARG TO KONTROLLER ROUTINES
UNYBPY:	POINT	UNSBPY,UNIBPY(U),UNNBPY	;BLOCKS PER CYLINDER
					; THE SMALLEST IF CYLINDERS; HAVE DIFFERENT
					; SIZES(MDF) - ARG TO KONTROLLER ROUTINES
UNYLKP::POINT	UNSLKP,UNILKP(U),UNNLKP;LAST KNOWN POSITION
UNYUST:	POINT	UNSUST,UNIUST(U),UNNUST	;DRIVE STATUS - DOWN, NOT IN STR,
					; BEING MOUNTED, MOUNTED
UNZUST::POINT	UNSUST,UNIUST(T1),UNNUST
UNXUST::POINT	UNSUST,UNIUST(T2),UNNUST
UNYKTP:	POINT	UNSKTP,UNIKTP(U),UNNKTP	;KONTROLLER TYPE THIS UNIT IS CONNECTED TO
					; ONCE ONLY USES
UNYSIC:	POINT	UNSSIC,UNISIC(U),UNNSIC	;# SAT BLOCKS IN CORE FOR THIS UNIT
UNYCFS:	POINT	UNSCFS,UNICFS(U),UNNCFS	;CLASS FOR SWAPPING FOR THIS UNIT
UNYK4S:	POINT	UNSK4S,UNIK4S(U),UNNK4S	;K FOR SWAPPING ON THIS UNIT
UNYAWL::POINT	UNSAWL,UNIAWL(U),UNNAWL	;SOFTWARE WRITE LOCK FOR ALL JOBS
UNYPRF:	POINT	UNSPRF,UNIPRF(U),UNNPRF	;PRIVATE STR
UNYSPU:	POINT	UNSSPU,UNISPU(U),UNNSPU	;# SAT BLOCKS ON THIS UNIT
UNYKNM:	POINT	UNSKNM,UNIKNM(U),UNNKNM	;KONTROLLER NO. WITHIN THIS TYPE
					; START AT 0 FOR A, 1 FOR B, ETC
UNYKOF::POINT	UNSKOF,UNIKOF(U),UNNKOF	;"KONTAB" OFFSET
UNZCFS:	POINT	UNSCFS,T1,UNNCFS	;POINTER TO SWAPPING CLASS

UNZFKS:	POINT	UNSK4S,T1,UNNK4S	;FREE K FROM T1
UNYBCT::POINT	UNSBCT,UNIBCT(U),UNNBCT	;POINTER TO NUMBER OF SLOTS LEFT IN BAT BLOCK
IFN FTXMON,<
UNYSNS::POINT	UNSSNS,UNISNS(U),UNNSNS	;SECTION NUMBER OF SECTION CONTAINING
					; SWAPPING SATS
>
	$LOW

$FHNUM==0
$FSNUM==0
$RPNUM==0
$DPNUM==0
$MDNUM==0
$RHNUM==0
$RNNUM==0
$RANUM==0

$S==1		;USED IN LINKING UNIT CORE BLOCKS TOGEHER

$CHN==0		;CHANNEL NUMBER - ARGUMENT TO DATBAS MACRO

$LOCW==0	;USED FOR DEFINING LOW CORE CHANNEL KONTROL WORD SYMBOLS

$KON==0		;USED IN LINKING KDBS TOGETHER

IFNDEF CHNN,<CHNN==1
C0FHN==1
C0DPN==0
C0MDN==0
FHAUN==1
DPAUN==0
MDAUN==0>
IFN FTAUTC,<
CHN:	CHNCB (0,0)
LENCCB==:.-CHN
RPXKDB::RPKON (RP,A,0)
RPKLEN==:.-RPXKDB
IFN FTKL10,<
IFN M.RP20,<
RNXKDB::RNKON (RN,A,0)
RNKLEN==:.-RNXKDB
>
IFN M0RAX,<
RAXKDB::RAKON (RA,A,0)
RAKLEN==:.-RAXKDB
>; END IFN M0RAX
>
RPXUDB:	UNITCB (0,RP,A)
RPULEN==:.-RPXUDB
IFN FTKL10,<
IFN M.RP20,<
RNXUDB:	UNITCB (0,RN,A)
RNULEN==:.-RNXUDB
>
IFE M.RP20,<
RNXKDB==:0
RNKLEN==:0
RNXUDB==:0
RNULEN==:0
RNXRSC==:0
RNPUNB==:0
>
IFN M0RAX,<
RAXUDB:	UNITCB	(0,RA,A)
RAULEN==:.-RAXUDB
>; END IFN M0RAX
IFE M0RAX,<
RAXKDB==:0
RAKLEN==:0
RAXUDB==:0
RAULEN==:0
>; END IFE M0RAX
>
IFE FTKL10,<
RNXKDB==:0
RNKLEN==:0
RNULEN==:0
RNKLEN==:0
RAXKDB==:0
RAKLEN==:0
RAXUDB==:0
RAULEN==:0
>
>

IFE FTAUTC,<
REPEAT CHNN,<
CHNCB (\$CHN,\<$CHN+1>)
$CHN==$CHN+1>

$SM1==$S-1
SYSCLS (\$SM1)		;CLOSE LIST OF UNIT CORE BLOCKS

DEFINE	CBLAST (S) <CHN'S'CB==0>

CBLAST	(\CHNN)		;CLOSE OFF CHN CHAIN

>
COMEND:	END		;START MONITOR OR USER MODE DATDMP

   A  @b