TITLE	SYSINI - SYSTEM INITIALIZATION AND RESTART - V1115
SUBTTL	TH/RCC/TL/AF/PH/DAL/BGE/RLD/JBS	27 JAN 85
	SEARCH	F,S,BTSPRM
	$RELOC
	$LOW



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<1969,1986>
;COPYRIGHT (C) 1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986
;BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;ALL RIGHTS RESERVED.


;

XP VSYSII,1115
		;PUT VERSION NUMBER IN GLOB LISTING AND LOADER STORAGE MAP
	CLK==70		;MACRO 47 DOESNT KNOW ABOUT CLK.

;NOTE THAT SYSINI MAY INCLUDE INITIALIZATION ROUTINES WHICH SHOULD NOT
;BE CALLED. THIS HAPPENS IF THE FEATURE TEST SWITCH FOR A FEATURE IS ON,
;BUT THE MODULE IS NOT LOADED BECAUSE OF THE ANSWER TO A MONGEN QUESTION.
;TO SOLVE THIS PROBLEM, COMMON DEFINES SYMBOLS =0 IF THE ROUTINE IS
;NOT TO BE CALLED, = NON-0 IF IT IS TO BE CALLED.


;SYSINI HAS BEEN MADE SELF RELOCATING SO THAT IT CAN BE MOVED
;IN CASE IT IS TO BE OVERLAYED AFTER SYSTEM STARTUP.  IF IT IS,
;IT MIGHT BE CLOBBERED BEFORE INITIALIZATION WAS COMPLETE, HENCE
;IT WOULD HAVE TO BE MOVED.
;ACCUMULATOR P2 CONTAINS THE RELOCATION.
	SUBTTL	INITIALIZE SYSTEM DATA STORAGE

ENTRY SYSINI

SYSINI::CONO	APR,200000	;IO RESET
	MOVE	P,.CPNPD##	;SET UP A PDL FOR THIS
	SETZM	CRSHWD##	;PREVENT JUNK FROM CAUSING US TO ENTER BOOT IF
				; THE CLOCK SHOULD TICK BEFORE WE GET TO IOGO
	SETZM	.JBEDV##	;PREVENT JUNK FROM SCREWING UP EDDT
IFN FTKL10,<
	MOVE	T1,.CPCPN##	;FOR THIS CPU
	PUSHJ	P,DTEINI##	;INITIALIZE DTE'S EARLY
	PUSHJ	P,ENTSPC##	;START SECONDARY PROTOCOL ON MASTER DTE
>
IFN FTKS10,<
	SETZM	CTYIWD		;CLEAR CTY COMM WORDS
	SETZM	CTYOWD
	SETZM	KLIIWD		;CLEAR KLINIK WORDS
	SETZM	KLIOWD
>
	SETZ	P2,		;CLEAR RELOCATION REGISTER FOR SUBROUTINE
IFN FTMP,<
	PUSHJ	P,BCOM0##	;ESTABLISH CPU 0
>
JSR1:	JSR	ONCE##		;DO ONCE ONLY CODE ONCE
	PUSHJ	P,SETEDV##	;SETUP EDV NOW INCASE STOPCODES
				; OCCUR DURING SYSINI
IFN FTKL10,<
	PUSHJ	P,CLRSBD##	;CLEAN MEMORY CONTROLLERS
>
JSR2::	JSR	LINKSR##	;DO MANDATORY ONCE ONLY CODE ONCE FOR SURE
				;LINK IO SERVICE ROUTINES AND OVERLAY ONCE
				; ONLY CODE WITH DEVICE DATA BLOCKS
;*** SYSINI MAY BE MOVED TO HIGH CORE BY LINKSR BECAUSE SYSINI COULD GET
;CLOBBERED BY BEING OVERLAYED BEFORE IT IS FINISHED.  THEREFORE THE CODE
;IS SELF RELOCATING, USING P2 AS A RELOCATION REGISTER.  NOTE THAT LOCATION
;SYSINA WILL CONTAIN THE CURRENT ADDRESS OF SYSINI (SET A FEW INSTRUCTIONS
;DOWN THIS PAGE AND IS OCCASSIONALLY USED TO COMPUTE THE RELOCATION CONTENTS
;(RH(SYSINA))-SYSINI CALLS TO SUBROUTINES IN SYSINI BEFORE THIS POINT SHOULD
;SET P2=0 FIRST.  THIS WORKS BECAUSE SYSINI WILL NOT YET HAVE BEEN MOVED.

	MOVSI	P2+1,(JRST (P2));RETURN INSTRUCTION FOR JSR
	JSR	P2		;FIND OUT WHERE WE ARE
	MOVEI	P2,0-.(P2)	;OFFSET FOR RELOCATED LOADING INTO ORIGINAL SPOT
	HRLZ	T1,[MSWPMX##](P2)	;CAN'T HAVE SWAP SPACE
	MOVNI	T2,4		; START AT BLOCK0,
	SKIPE	T3,SWPTAB##(T1)	; SO DECREMENT UNISLB
	ADDM	T2,UNISLB##(T3)	; AND START AT LOGICAL
	AOBJN	T1,.-2(P2)	; SWAP BLOCK1
	MOVEI	T1,DSKINI(P2)	;NEW LOCATION OF DSKINI
	HRRM	T1,DSKDSP##+DINI	;STORE IN DISPATCH TABLE
	MOVEI	T1,SYSINI(P2)	;NEW LOCATION OF SYSINI
	HRRM	T1,SYSINA##	;SYSINI MOVED, CAN'T DO 403 RESTART
	MOVS	T1,.+1(P2)
	SETZM	.CPJOB##	;CLEAR CURRENT JOB
	SETZB	P1,SYSBEG##	;CLEAR P1 FOR NEXT PAGE
	MOVSM	T1,JSR1(P2)	;CLEAR SYSTEM DATA STORAGE
	MOVSM	T1,JSR2(P2)
	MOVE	T1,[XWD SYSBEG##,SYSBEG##+1](P2) ;CLEAR SYSTEM DATA STORAGE
	BLT	T1,SYSEND##

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVEI	T1,NUPMPP##	;PAGE NUMBER OF NULL JOB'S UPT
	MOVNI	T2,CPUN##	;NUMBER OF CPUS
	MOVEI	T3,.E0MAP##/PAGSIZ## ;PAGE NUMBER OF CPU0'S MAP
IFN FTXMON,<MOVEI T4,.E0STB##>	;AND SECTION TABLE FOR CPU0
IFE FTXMON,<MOVEI T4,.E0DMP##>	;DECNET MAPPING POINTER

JSR21:	MOVEM	T1,JBTUPM##(T2)	;SETUP CONTEXT SLOTS IN THE SPT
	MOVEM	T3,SPTLOW##+CPUN##(T2) ;SPT ENTRIES FOR SKY HIGH SECTION
	MOVE	S,<(MS.HGH)>(T4) ;GET SKY HIGH MAP PAGE
	MOVEM	S,SPTHGH##+CPUN##(T2) ;SPT ENTRIES FOR SPYING ON SKY HIGH SECTION
	ADDI	T3,EPTDIF##/PAGSIZ## ;NEXT MAP
	ADDI	T4,EPTDIF##	;AND NEXT SECTION TABLE
	AOJL	T2,JSR21(P2)	;LOOP FOR ALL CPUS
	MOVEM	T1,JBTUPM##+0	;AND JBTUPM FOR THE NULL JOB
IFN FTXMON,<
	MOVSI	T1,-<MXSECN-<(MS.FMD)>> ;-VE NUMBER OF SPTCOM SLOTS
	MOVE	T3,.CPEPT##	;ADDR OF OUR MAPPING PAGE
JSR22:	SKIPN	T2,SECTAB+<(MS.FMD)>(T3) ;GET COMMON DATA SECTION MAP PAGE
	MOVSI	T2,1		;MAKE ILLEGAL POINTER IF NOT ASSIGNED
	MOVEM	T2,SPTCOM##(T1)	;STORE FOR SPYING USERS
	AOS	T3		;ADVANCE SECTION POINTER INDEX
	AOBJN	T1,JSR22(P2)	;LOOP OVER ALL SUCH SLOTS
>
	MOVE	T1,[XWD NUPPPM##,NUPPPM##+1](P2)
	SETZM	NUPPPM##	;ZERO PP MAPPING IN NULL JOB'S MAP
	BLT	T1,NLUPMP##+.UMUPM-1

IFE FTMP,<
	SETOM	.CPOK##		;MAKE THE ONE AND ONLY LOOK ALIVE
>

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVSI	T1, DVDIRIN+TTYATC+TTYUSE
	HRRI	T1,ASSCON+ASSPRG
	HLRZ	F,DEVLST##	;SCAN ALL DEVICES
SYS1:	ANDCAM	T1, DEVMOD(F)	;CLEAR DIRECTORY IN CORE BIT,
				;ASSIGNED BY CONSOLE & PROGRAM
	SETZB	U,DEVLOG(F)	;CLEAR LOGICAL NAME AND U
				; FOR NXM LOOP BELOW(SYS2-SYS3)
	HLRZ	F, DEVSER(F)
	JUMPN	F, SYS1(P2)
	SUBTTL	SORT DDB CHAIN AND SET UP GENERIC DEVICE TABLE
 
;WE MUST NOW SORT ALL DDB'S SO THAT ALL DDB'S
; OF A GIVEN DEVICE CLASS (DTA, LPT, CDR, ...) ARE CONTIGUOUS
; ON THE CHAIN. THEN, WE SET UP THE GENERIC DEVICE TABLE TO POINT
; TO THE 1ST DDB IN EACH SUCH DEVICE CLASS. THIS WILL SPEED UP THE
; GENERIC SEARCH

	HLRZ	F,DEVLST##	;GET START OF CHAIN
GNSRC0:	MOVEI	T1,GENTAB##	;GET START OF GENERIC DEVICE TABLE
GNSRC1:	HLRZ	T2,(T1)		;GET DEVICE NAME FROM TABLE
	HLRZ	T3,DEVNAM(F)	; AND NAME FROM DDB
	CAME	T2,T3		;FOUND DEVICE IN TABLE?
	JRST	GNSRC2(P2)	;NO, CONTINUE THE SEARCH
	HRRZ	T2,(T1)		;YES, GET THE POINTER IN THE RH
	JUMPN	T2,GNSC2A(P2)	;IF ALREADY SET UP, EXIT
	HRRM	F,(T1)		;NO, PUT DDB ADDRESS IN TABLE
	JRST	GNSC2A(P2)	;LEAVE THIS SEARCH ROUTINE
GNSRC2:	CAIE	T1,GTEND##-1	;THRU?
	AOJA	T1,GNSRC1(P2)	;NO, KEEP GOING
	JRST	GNSRC5(P2)	;NOT FOUND IN GENTAB - TRY NEXT DDB
;FROM HERE ON, WE MUST SORT ALL DDB'S ACCORDING TO DEVICE TYPES
;AC USAGE:
;	F = CURRENT DDB
;	T1 = PTR TO "LAST" DDB IN DEVICE GROUP
;	T2 = MOVING PTR WITHIN DEVICE GROUP

GNSC2A:	MOVE	T2,F		;INIT MOVING PTR
GNSRC3:	MOVE	T1,T2		;INIT "LAST" DDB IN DEVICE GROUP
	HLRZ	T2,DEVSER(T2)	;GET NEXT DDB
	JUMPE	T2,GNSRC6(P2)	;END OF CHAIN, WE'RE THRU
	HLRZ	T3,DEVNAM(F)	;GET DEVICE NAME OF CURRENT DDB
	HLRZ	T4,DEVNAM(T2)	; AND OF THIS DDB
	CAMN	T3,T4		;SAME DEVICE?
	JRST	GNSRC3(P2)	;YES, GO UNTIL WE GET OUT OF DEVICE GOURP
GNSRC4:	MOVE	P3,T2		;SAVE THIS ADDRESS
	HLRZ	T2,DEVSER(T2)	;NOW, WE START SEARCH TO FIND ANOTHER
	JUMPE	T2,GNSRC6(P2)	;..DEVICE IN THIS GROUP
	HLRZ	T3,DEVNAM(F)	;FETCH NAME AGAIN
	HLRZ	T4,DEVNAM(T2)	;AND NEW NAME
	CAME	T3,T4		;IS THIS DDB OUT OF ORDER?
	JRST	GNSRC4(P2)	;NO

;WE HAVE NOW FOUND A DDB WHICH IS NOT CONTIGUOUS WITH OTHER DDB'S
; OF ITS DEVICE GROUP. WE MUST RE-LINK THEM SO THAT IT BECOMES
; CONTIGUOUS.

	HLRZ	T3,DEVSER(T2)	;GET NEXT DDB PTR
	HRLM	T3,DEVSER(P3)	;REMOVE THIS DDB FROM CHAIN
	HLRZ	T3,DEVSER(T1)	;GET NEXT PTR FROM "LAST" DDB IN GROUP
	HRLM	T3,DEVSER(T2)	;MAKE US POINT TO NEXT DDB
	HRLM	T2,DEVSER(T1)	;MAKE LAST DDB POINT TO US
	MOVE	T1,T2		;CONTINUE SEARCH
	JRST	GNSRC4(P2)
GNSRC5:	MOVE	T1,F		;NOT IN GENTAB, TRY NEXT DDB
GNSRC6:	HLRZ	F,DEVSER(T1)	;GO TO NEXT DDB AFTER THIS GROUP
	JUMPN	F,GNSRC0(P2)	;CONTINUE SEARCH IF MORE

;AT THIS POINT, ALL DDB'S SHOULD BE SORTED, SO FALL THRU TO NEXT PAGE.........
;SETUP CORE USE BIT TABLE(CORTAB)
;1 BIT FOR EACH 1K OF POSSIBLE MEMORY
; BIT=0 IF AVAILABLE TO USERS
; BIT=1 IF USED BY MONITOR,USER PROGRAM, OR NON-EXISTENT
; EXISTENT MEMORY MUST BE CONTIGUOUS(OR ELSE CORE SHUFFLER WON'T WORK)
; IF NOT CONTIGUOUS, BANKS ABOVE FIRST NON-EXISTENT ONE ARE IGNORED

SYSLIM::MOVEI	T1,CORBLK##	;NO. OF BIT BYTES IN CORTAB
	SKIPN	FLG256##
	MOVEI	T1,COR256##
	MOVE	W,COREP##	;1 BIT BYTE POINTER TO FIRST K-1
	MOVEI	F,PAGSIZ##	;CORE SIZE INCREMENT TO UPDATE CORMAX
	MOVE	P3,[POINT 1,NXMTAB##](P2)
SYS2:	IBP	W		;MOVE BYTE POINTER UP BY 1K
	ILDB	T4,P3
	CAML	U,SYSSIZ##	;STILL IN MONITOR(FIRST LOC NOT USED BY MON)?
	SKIPE	T4		;NO, SEEN ANY NON-EX 1K YET?
	JRST	SYS3(P2)	;YES, GO STORE 1 BIT IN CORTAB INDICATING
				; 1K NOT AVAILABLE
	MOVEM	W,CORLST##	;NO, SET LAST AVAILABLE BLOCK EVEN HIGHER
	MOVEM	U,MEMSIZ##	;SET SIZE OF PHYSICAL MEMORY EVEN HIGHER
	HRRZ	T3,CORLIM##	;MAXIMUM CORE AVAILABLE TO A SINGLE USER.  DEFINED
				; BY MONGEN, MODIFIED BY ONCE
	CAMGE	P1,T3		;REACHED MAX YET FOR SINGLE USER?
	ADDM	F,CORMAX##	;NO, INCREASE MAX SIZE CORE AVAIL. TO A USER
	ADDM	F,MAXMAX##	;INCREMENT HIGHEST LEGAL CORMAX
	ADDM	F,RMCMAX##	;REAL MAXIMUM LEGAL CORMAX
	AOS	P1,CORTAL##	;INCREMENT NO. OF FREE 1K BLOCKS
	JRST	SYS4(P2)	; AND LEAVE 0 BIT IN CORTAB TO FLAG IT AS FREE
SYS3:	MOVEI	T2,CTNMCI##	;ASSUME MONITOR CORE
	SKIPE	T4		;MONITOR OR NXM?
	MOVEI	T2,CTNXMI##	;NXM
	DPB	T2,W		;YES, FLAG THIS 1K AS NOT AVAILABLE(1 BIT IN CORATB)
SYS4:	ADDI	U,PAGSIZ##	;INCREMENT MEMORY REF
	SOJG	T1,SYS2(P2)	;FINISHED CORTAB YET?
	IBP	CORLST##	;SET TO FIRST UNAVAILABLE BLOCK
	ADDM	F,MEMSIZ##	;SET SIZE OF PHYSICAL MEMORY SO EQUAL
				; TO THE FIRST NON-EX MEM ADR
	DPB	T2,CORLST##	;IN CASE CORBLK DEFORMED.6.LT.256
	MOVE	P,.CPNPD##	;SETUP PUSH DOWN LIST
	MOVE	T1,MEMSIZ##	;SIZE OF MEMORY =
IFN FTLOCK, <
	MOVEM	T1,HOLTOP##	; TOP OF LARGEST UNLOCKED HOLE
>
	LSH	T1,W2PLSH##	;PAGE NUMBER OF HIGHEST EXISTANT PAGE
	TRZE	T1,PG.BDY##	;ROUND UP TO 256K BOUNDARY
	ADDI	T1,PP256K##
	IDIVI	T1,^D36
	MOVNI	T1,1(T1)	;NUMBER OF WORDS IN NXMTAB
	HRLI	T1,NXMTAB##	;FORM AN AOBJN POINTER
	MOVSM	T1,NXMPTR##	;STORE IT FOR DAEMON AND MONBTS
				;RECLAIM MONITOR CORE (SIZE OF MONITOR INCREASED
	PUSHJ	P,ACCINI(P2)	;AT ONCE ONLY TIME) USED BY DISK DEVICE DATA BLOCKS
				; (IF THIS IS RESTART)
	SETZ	J,		;CLEAR J TO SET UP A PDB FOR THE NULL JOB
	PUSHJ	P,CREPDB##	;ALLOCATE A PDB
	  HALT	.(P2)		;NO SPACE!
	PUSHJ	P,SWPINI(P2)	;INIT SWAPPING SPACE ALLOCATION
IFN FTSPL,<
	MOVE	T1,TIME##	;INITIALIZE SPOOL NAME GENERATOR TO RANDOM START
	IDIVI	T1,^D3600	;START WITH MINUTES SINCE MIDNIGHT
	ADD	T1,THSDAT##	;PLUS DATE
	MOVEM	T1,SPLGEN##	;SAVE FOR FILSER
>
IFN FTEQDQ,<
	SKIPE	[HSHTAB##](P2)	;SKIP IF NO INITIALIZATION TO BE DONE
	PUSHJ	P,ENQINI##	;INITIALIZE HSHTAB
>
;INITIALIZE ALL IO DEVICES


IFN FTKL10,<PIBITS==PI.CPI!PI.TFP!PI.OFF!LI.ACO!LI.CPP>	;KL10 PI BITS
IFN FTKS10,<PIBITS==PI.CPI!PI.TFP!PI.OFF!SI.ACO!SI.CPP>	;KS10 PI BITS

IOGO::	CONO	PI,PIBITS	;CLEAR PI SYSTEM (AND MEM PARITY)
IFN FTKL10,<
	CONO	APR,LP.CSF!LP.PAR
>
IFN FTKS10,<
	WRAPR	SP.DSF!SP.CSF!SP.HMP!SP.SMP!SP.NXM
>
				; DO NOT CLEAR POWER FAIL AS THIS DISABLES
				; POWER FAILURE INTERRUPTS
	CONO	APR,AP0NUL##	;SET UP THE APR (DON'T DO I/O RESET)
IFN FTKL10,<
	PUSHJ	P,ENTSPC##	;START SECONDARY PROTOCOL UP
>;END IFN FTKL10
	MOVE	T3,BOOTPA##	;PRESERVE BOOTSTRAP STARTING ADDRESS
	MOVE	T4,BOOTWD##	;PRESERVE BOOTWD FOR CPU0,CPU1 CHECK
	SETZM	20		;CLEAR 20
	MOVSI	T1,20		;SET UP A
	HRRI	T1,21		; BLT POINTER
IFN FTKL10,<BLT T1,37>		;CLEAR 21-37
IFN FTKS10,<
	BLT	T1,30		;CLEAR 21-30
	SETZM	36		;CLEAR 36
	SETZM	37		;CLEAR 37
>
	MOVEM	T3,BOOTPA##	;RESTORE BOOTPA
	MOVEM	T4,BOOTWD##	;RESTORE BOOTWD
	HRRZS	.CPMPC##	;CLEAR SERIOUS PARITY ERROR FLAG WHICH
				; CAUSES HALT AFTER CTY PRINTING
	SETZM	HNGLST##	;ZERO ADDRESS OF DEVICES WHICH SHOULD BE HUNG CHECKED
	HLRZ	F, DEVLST##	;CHAIN OF DEVICE DATA BLOKS
IOG0:	MOVEI	T2,ASSPRG	;CLEAR ASSIGNED BY PROGRAM BIT
	ANDCAB	T2,DEVMOD(F)
	HRLOI	J,777701	;DO NOT CLEAR HUNG DEVICE COUNT SETTING
	TRNE	T2,ASSCON	;ASSIGNED BY CONSOLE?
	TLO	J,774000	;YES, DO NOT CLEAR JOB NO.
	ANDM	J,DEVCHR(F)	;CLEAR HUNG DEVICE COUNT.
	SETZM	DEVIOS(F)	;CLEAR IO STATUS WORD
	SETZB	U, DEVBUF(F)	;CLEAR BUFFER ADDRESSES
	TLNE	T2,DVDTA	;IS THIS A DECTAPE?
	DPB	U,IADPTR##	;YES, SET NO. OF USER CHANNELS INITED
				; ON THIS DEVICE TO 0
	LDB	T1,PDVTYP##	;DEVICE TYPE
	CAIE	T1,.TYTTY/.TYEST	;A TTY?
	CAIN	T1,.TYPTY/.TYEST	;OR A PTY?
	JRST	IOG00(P2)	;YES
	SKIPN	HNGLST##	;NO, ALREADY SEEN A DEVICE?
	HRLM	F,HNGLST##	;NO, STORE ADDRESS OF FIRST DEVICE TO HUNG CHECK
IOG00:	HLRZ	F, DEVSER(F)
	JUMPN	F, IOG0(P2)
	MOVE	P,.CPNPD##	;GET A PDL
	PUSHJ	P,NXTINI(P2)	;ALWAYS INITILIZE SCHEDULER FIST
				;SO DEVICES MAY RESET QUEUES IF DESIRED
IFN FTMP&FTAUTC,<
	MOVEI	T2,200000	;WAIT AROUND 5 SECONDS
	SETZ	T3,
	HRROI	T1,[SKIPE .CPACD##-.CPCDB##(P1)
		    SETO  T3,
		    POPJ  P,](P2)
	PUSHJ	P,CPUAPP##	;MAKE SURE ALL CPU'S ARE THRU AUTCON
	SKIPE	T3		; SINCE BOOT'S MAP MIGHT BE CHANGED
	SOJGE	T2,.-3(P2)	;TIME OUT IN CASE SOMEONE'S NOT RUNNING
	CONO	PAG,@.CPEBR##	;MAKE SURE CHANGES ARE VISABLE
>
	HLRZ	P3,DEVLST##	;ADDR OF FIRST DDB
	SETZB	S,SAVITM
IOG01:	MOVE	F,P3		;SET UP F FOR INITIALIZATION CODE
				; (NOT ALWAYS USED)
	MOVE	P3,DEVSER(P3)
IFN FTMP,<
	LDB	T1,DEYCPF##	;CPU OWNING THE DEVICE
	CAIN	T1,CPFBOO##	;GENERIC BOOT CPU?
	JRST	IOG02(P2)	;YES, THAT'S US
	CAME	T1,.CPCPN##	;THIS CPU?
	JRST	IOG03(P2)	;NO, INI ROUTINE WILL BE CALLED ON CPU OWNING DEV
IOG02:>
	HRRZ	T1,P3
	CAIE	T1,@SAVITM	;SAME DEVICE
	PUSHJ	P,DINI(P3)	;NO. INITIALIZE IT.
	  HRRZM	P3,SAVITM	;SKIP RETURN IF INITIALIZATION CODE IS TO BE CALLED
				; FOR EACH DEVICE (I.E. MULTIPLE LINE PRINTERS)
IOG03:	HLRZS	P3
	JUMPN	P3,IOG01(P2)	;GO IF MORE DEVICES
IFN FTRTTRP,<
	SKIPE	[RTINIC##](P2)	;SKIP IF REAL TIME INITIALIZATION NOT TO BE CALLED
	PUSHJ	P,RTINI(P2)	;INITIALIZE PI CHANNELS AND RT DEVICES
>
IFN FTLOCK,<
	SKIPE	[LOKINC##](P2)	;SKIP IF LOCK INITIALIZATION NOT TO BE CALLED
	PUSHJ	P,LOKINI(P2)	;INITIALIZATION FOR LOCK UUO
>
	PUSHJ	P,QINI(P2)	;PUT ALL JOBS IN NULL QUEUE IF SWAPPER
	MOVE	T1,TICSEC##	;PRESET SEGMENT RETENTION TIME
	MOVEM	T1,SGTLIM##	;TO ONE SECOND IN TICKS AS AGE OF IDLE/DORMANT
				;SEGS BEFORE DELETION


IFN FTNSCHED,<
	MOVEI	T1,^D10		;10%
	MOVEM	T1,SCDJIL##	;INITIAL RESPONSE FAIRNESS FACTOR
	MOVEI	T1,^D50
	MOVEM	T1,SCDIOF##	;INITIAL INCORE FAIRNESS FACTOR
	MOVEI	T1,3*JIFSEC##	;6 SECONDS IN TICK PAIRS
	MOVEM	T1,SCDCOR##	;INITIALIZE SCDCOR
	SETOM	BBSUBQ##	;NO BACKGROUND BATCH CLASS
>
	SETZM	.CPJOB##
	MOVEI	J,JOBMAX##	;MAX INDEX IN JOB AND HIGH SEG TABLES
IOG2:	HRLOI	T2,JNA+JLOG+SWP	;CLEAR  ALL BUT JOB NO. ASSIGNED,
	ANDM	T2,JBTSTS##(J)	;JOB LOGGED IN(SHRSEG, IF HIGH SEG)
				; AND JOB SWAPPED BITS
	SKIPE	JBTADR##(J)	;DOES THIS JOB HAVE CORE IN MEMORY?
	PUSHJ	P,CLRJOB##	;YES, CLEAR JOB DATA AREA PROTECTED
	SOJG	J,IOG2(P2)	;FROM IO SERVICE(DEVICE ASSIGNMENT TABLE)
				;AND SET JERR BIT SO JOB CANNOT CONT
				; FINISH WITH J=0 FOR NULL JOB
	TRNN	P2,-1		;SKIP IF SYSINI WAS OVERLAYED
	JRST	IOG4(P2)	;JUMP IF SYSINI WILL BE SAVED
	MOVSI	T1,(HALT)	;NO, PATCH OUT CALLS TO SYSINI
	HRRI	T1,SYSTRT##	;MAKE ALL HALTS NOT BE CONTINUABLE
	MOVEM	T1,DSKDSP##+DINI	;DSKINI
	MOVEM	T1,SCNDSP##+DINI	;TTYINI
	SKIPE	[PTYDSP##](P2)
	MOVEM	T1,PTYDSP##+DINI
IOG4:	MOVSI	T1,(CAI)	;SETUP NO-OP IN CASE NO EDDT
IOG5::	HLLM	T1,SYSDDT##	;TURN 401 INTO A CAI UNLESS EDDT STILL AROUND
	MOVE	T1,TIME##	;GET TIME OF DAY AS UPDATED DURING TTY LOOP
	MOVE	T2,TICSEC##	;TICS PER SECOND
	LSH	T2,-1		;DIVIDE BY 2
	ADD	T1,T2		;AND ROUND
	IDIV	T1,TICMIN##	;MINUTES IN T1, REMAINDER IN TICS
	PUSH	P,T2		;SAVE REMAINDER
	IDIVI	T1,^D60		;HOURS IN T1, MINUTES IN T2
	MOVEM	T1,LOCHOR##	;UPDATE GETTAB HOURS
	MOVEM	T2,LOCMIN##	;AND MINUTES
	POP	P,T1		;GET BACK REMAINING TICS
	IDIV	T1,TICSEC##	;AND ROUND TO SECONDS
	MOVEM	T1,LOCSEC##	;AND STORE
	SUBI	T1,^D60		;-VE SECONDS UNTIL NEXT MINUTE
	MOVNM	T1,.CPSEC##	;STORE POSITIVE NUMBER FOR ONCE-A-MINUTE CALLS
	SUB	T2,TICSEC##	;-VE TICKS UNTIL NEXT SECOND
	MOVNM	T2,.CPHTM##	;STORE POSITIVE FOR ONCE-A-SECOND CALLS
	PUSHJ	P,SUDATE##	;SET UP UNIVERSAL DATE-TIME
	PUSHJ	P,CHKMNT##	;CHECK IF WENT PAST MIDNIGHT
	MOVE	T1,TIME##	;GET UPDATED TIME OF DAY
	MOVEM	T1,.CPTML##	;INITIALIZE LAST TIME OF DAY
	PUSHJ	P,SETIME##	; TO INITILIZE GETIME
	PUSHJ	P,OMSTIM##	;COMPUTE TIME TO FIRST OPR MESSAGE
IFN FTKL10,<
	APRID	T3		;PROCESSOR HARDWARE OPTIONS
	DMOVE	T1,[M.EBPS##	;ASSUME A MODEL A PROCESSOR
		M.MBPS##](P2)
	TRNE	T3,ID.XKL	;IS IT A MODEL B PROCESSOR?
	DMOVE	T1,[^D30*M.EBPS##/^D25 ;YES, USE DIFFERENT EBOX/MBOX CALABRATION CONSTANTS
		^D30*M.MBPS##/^D25](P2)
	MOVEM	T1,.CPEBS##	;STORE AS EBOX TICS/SEC
	MOVEM	T2,.CPMBS##	;STORE AS MBOX TICS/SEC
	IDIV	T1,TICSEC##	;AND NOW GET EBOX COUNTS/JIFFY
	IMULI	T1,.EBCPT	;MULITPLY BY EBOX COUNTS/TICK
	MOVEM	T1,.CPEBJ##	;STORE IN CDB VARIABLE
	MOVE	T1,.CPMBS##	;GET MBOX TICKS/SECOND
	IDIV	T1,TICSEC##	;GET MBOX COUNTS/JIFFY
	IMULI	T1,.MBCPT	;MULTIPLY BY MBOX COUNTS/TICK
	MOVEM	T1,.CPMBJ##	;SAVE
	PUSHJ	P,TIMINI(P2)	;START JIFFIES COMING
IFN FTEMRT,<
	PUSHJ	P,ACCMON##	;START UP ACCOUNTING METERS
	PUSHJ	P,CLREMB##	;CLEAR OUT E AND MBOX ACCOUNTING METERS
>;END IFN FTEMRT
>;END IFN FTKL10
IFN FTKS10,<
	PUSHJ	P,TIMINI(P2)	;START JIFFIES COMING
>
	PUSHJ	P,KIINI(P2)
IFN FTKL10,<
;	EXECAC			;MAKE SURE AC BLOCKS ARE OK
	DATAO	PAG,[LG.LAB+01B11](P2)	;BUT CAN'T USE MACRO SINCE WE MUST RELOCATE
	PUSHJ	P,SETCSH##	;SET CACHE STRATEGY AS ESTABLISHED BY KLI
	CONO	APR,LP.CSF+LP.CSD
	SWPUA
	CONSO	APR,LP.CSD
	JRST	.-1(P2)
	CONO	APR,LP.CSF+LP.CSD
	CONO	PAG,@.CPEBR##
	SETZM	.USPFW
>
;DO "NETWORK" INITIALIZATION

IFE FTXMON,<PUSHJ P,DNMAP##>	;GET DECNET CONTEXT FOR A BIT

IFN FTKS10,<
	WRUBR	[SG.LAB+01B11](P2)
	WREBR	@.CPEBR##
	MOVSI	T1,(KPACT)	;INIT THE RELOAD WORD, ENABLE KEEP ALIVE COUNTER
	MOVEM	T1,RLWORD	;SET IT
	PUSHJ	P,KDPONC##	;GO INIT THE KMC/DUP LINES
>;END IFN FTKS10

IFN FTENET,<
ETHSTR:!PUSHJ	P,ETHINI##	;INITIALIZE ETHERNET DRIVER
>; END IFN FTENET

IFN FTNET,<
ANFSTR:!MOVEI	T1,LOCSTA##	;GET CENTRAL SITE STATION NUMBER
	MOVEM	T1,JBTLOC##	;AND SAVE IN JOB LOCATION TABLE
	MOVEI	T1,NETNDB##	;GET NDB FOR CENTRAL STATION
	HRRM	T1,.GTNDA##+LOCSTA##	;SAVE FOR NETSER
>;END IFN FTNET

IFN FTDN60!FTNET,<
FEKSTR:!
IFN FTENET,<PUSHJ P,D8EINI##>	;INITIALIZE ANF/ETHERNET FEK SERVICE
	MOVEI	J,FEKFST##	;GET THE ADDR OF FIRST FEK (0 IF NONE)
	JRST	FEKST3(P2)	;ENTER FEK "ONCE ONLY" LOOP

FEKST1:	MOVEI	T1,FF.ONC	;GET THE "ONCE ONLY" FUNCTION CODE
	XCT	FEKDSP(J)	;CALL THE "DISPATCH ROUTINE"
	HRRZKBLK(J)	;STEP TO THE NEXT FEK
FEKST3:	JUMPN	J,FEKST1(P2)	;IF NO MORE FEKS, GO CONTINUE SYSINI
> ;END OF FTDN60!FTNET
IFN FTDECNET,<
D36STR:!PUSHJ	P,D36INI##	;INITIALIZE DECNET
>; END IFN FTDECNET

IFN FTENET,<
LATSTR:!PUSHJ	P,LATINI##	;INITIALIZE LAT TERMINAL SERVICE
IFN FTKL10,<
LLMSTR:!PUSHJ	P,LLMINI##	;INITIALIZE LLMOP
>; END IFN FTKL10
>; END IFN FTENET

IFN FTKS10,<	;MUST BE AFTER CALL TO D36INI
	PUSHJ	P,DMRONC##	;AND THE DMR11 LINES
>;IFN FTKS10

IFE FTXMON,<PUSHJ P,RGMAP##>	;BACK TO REGULAR CONTEXT
	CONO	APR,AP0NUL##	;CLEAR ALL APR ERRORS (DO NOT DO RESET)
	CONO	PI,PI.CPI!PI.TNP!PI.ON!II.ACO!IFE FTKS10,<PI.EPE>  ;TURN ON ALL PI CHANNELS (ENABLE MEM PARITY)

IFN FTKL10,<
	PUSHJ	P,STAPPC##	;INITIALIZE PRIMARY PROTOCOL
>
IFN FTMP,<
	PUSHJ	P,BECOM0##	;ESTABLISH "CTY" ON BOOT PROCESSOR
IFN FTAUTC,<
	PUSHJ	P,T1CINI##	;MARK PAGTAB SO DX10 BASE BASE NEVER UNCACHED
>
	SETOM	.CPAID##	;ALREADY INITED DEVICES
>
IFN FTAUTC,<
	SETZM	CORLOC##	;ALLOCATION NOW FROM MONITOR FREE CORE
>
IFN FTKL10,<
	PUSHJ	P,RNXSAK##	;INSURE ALL RP20 DX20'S ARE RUNNING
>
	MOVEI	T1,.ERWHY	;MONITOR RELOAD CODE
	PUSHJ	P,DAERPT##	;TELL DAEMON MONITOR WAS RELOADED

	PUSHJ	P,CTXINI##	;COMPUTE SYSTEM CONTEXT QUOTAS BASED ON
				; THE NUMBER OF JOBS AND THE AMOUNT OF
				; SWAPPING SPACE AVAILABLE
	PUSHJ	P,FRCCPY##	;COPY ANY CRASHES
	JRST	SYSINH##	;INTO HIGH SEG

SAVITM=40
SUBTTL FILUUO INITIALIZATION
;ROUTINE TO RESTORE DDB CHAIN
;CALLED BY SYSINI ON 143 RESTART ONLY


ACCINI:	SETZM	DINITF##	;CLEAR "IN ONCE-ONLY CODE" FLAG
	PUSHJ	P,DSKINI(P2)	;CLEAN UP ALL DISK DDBS
	SETZM	SYSPPB##	;INSURE THAT SYSPPB
	SETZM	SYSDOR##	;AND SYSDOR ARE 0
	MOVE	T1,FREPTR##	;FREE-CORE WORD
	TRNE	T1,-1		;HAS IT BEEN SET UP YET?
	SETZM	(T1)		;YES, ZERO THE FREE CORE TABLE
	AOBJN	T1,.-2(P2)
	MOVEI	T1,SYSBG3##+1	;SET UP TO ZERO JOB TABLES
	CAILE	T1,SYSEN3##
	JRST	ACCIN6(P2)
	HRLI	T1,SYSBG3##	; WHICH ARE STORED IN COMMOD
	SETZM	SYSBG3##
	BLT	T1,SYSEN3##	;ZAP - THEY'RE ZERO

ACCIN6:
;-------NOTE THAT THE FOLLOWING CODE USES P1 AS THE BASE REGISTER-----------
	MOVE	P1,P2
	MOVE	T1,STRAOB##	;INITIZE ALL STR DATA BLOCKS
ACCIN4:	MOVE	T3,TABSTR##(T1)	;SETT2=STR D.B.ADDR.
	JUMPE	T3,ACCIN5(P1)	;   IF 0 THEN NO F.S. FOR THIS #
	SETZM	STRJOB##(T3)	;CLEAR STRJOB
	SETZM	STRMNT##(T3)	;SET MOUNT COUNT 0
	MOVE	P2,SYSSRC##	;IN SYSTEM SEARCH LIST?
	PUSHJ	P,SLFNA##
	  JRST	ACCIN5(P1)	;NO
	AOS	STRMNT##(T3)	;YES - BUMP MOUNT COUNT
ACCIN5:	AOBJN	T1,ACCIN4(P1)	;CHECK ALL STRS
	MOVE	P2,P1
;------END OF P1=BASE REGISTER CODE---------

	POPJ	P,		;AND RETURN
;INITIALIZE DISK CALLED BY 140 START, RESTART, 143 RESTART
;CALLED FROM ONCE ONLY CODE, ACCINI, SYSINI(DEVICE INIT.)

DSKINI::MOVEI	F,DSKDDB##	;PROTO. DDB LOC
	PUSHJ	P,SAVE2##	;SAVE P2 AND P1
	HRRZ	P2,SYSINA##	;SETUP RELOCATION REGISTER
	SUBI	P2,SYSINI	;ACTUAL SYSINI-LOADED SYSINI
	HLRZ	U,SYSUNI##	;LOC OF 1ST UNIT IN SYS
DSKIN3:	MOVE	T1,UNISTS##(U)
	CAIE	T1,O2COD##
	SETZM	UNISTS##(U)	;CLEAR OUT SOME STUFF
	SETZM	UNIQUE##(U)
	HRRZ	J,UNIKON##(U)	;GET ADR. OF KONTROLLER DATA BLOCK FOR THIS UNIT
	MOVSI	T1,KOPBSY##	;INDICATE KONTROLLER IS FREE
	ANDCAM	T1,KONBSY##(J)	;...
	LDB	T1,UNYUST##	;GET UNIT STATUS
	SKIPN	DINITF##	;DONT CHECK FOR KONTROLLER UP IF IN ONCE-ONLY CODE
	CAIN	T1,UNVDWN##	;IS IT DOWN?
	JRST	DSKIN5(P2)	;YES - DON'T CHECK WHETHER KONTROLLER IS UP OR DOWN
IFN FTMP,<
	MOVE	T1,KONCAM##(J)	;IF NOT ON THIS CPU
	TDNN	T1,.CPBIT##
	JRST	DSKI3A(P2)	; SKIP THIS TEST
>
	LDB	T1,UNYKTP##	;GET CONTROLLER TYPE
	CAIN	T1,TYPRN##	;RP20?
	PUSHJ	P,RNXMPS##	;YES, START THE MICRO PROCESSOR
	PUSHJ	P,@KONUPA##(J)	;CHECK WHETHER KONTROLLER FOR THIS UNIT IS UP
	  STOPCD .-1(P2),HALT,KID,	;KONTROLLER IS DOWN
DSKI3A:	SETOM	@KONCHN##(J)	;SET CHAN AVAILABLE
	HRRZ	T1,KONCHN##(J)	;LOC OF CHAN DATA BLOCK
	SETZM	CHNQUE##(T1)	;INDICATE CHAN QUEUE IS EMPTY
DSKIN5:	HLRZ	U,UNISYS##(U)	;STEP TO NEXT UNIT IN SYSTEM
	JUMPN	U,DSKIN3(P2)	;FIX IT UP
TSTHRU:	SKIPN	DINITF##	;IN ONCE ONLY CODE?
	PUSHJ	P,WTSATS(P2)	;NO. WRITE SATS WHICH HAVE CHANGED
	SETZM	DSKDDB##+DEVIOS	;ZERO THE S WORD IN PROTOTYPE DDB
	POPJ	P,		;AND RETURN

;SUBROUTINE TO WRITE ALL SATS FOR ALL UNITS IF THEY HAVE CHANGED
;THIS IS ONLY USED AT RESTART (140,143)
;THEN FIX IT UP AND RETURN)
WTSATS:	PUSHJ	P,SAVT##	;SAVE ALL ACS
	CONO	PI,DSKPIN##+200	;TURN ON PI
	MOVE	T1,[JRST ONCWAT##](P2)	;SET UP A FAKE PWAIT1
	MOVEM	T1,PWAIT1##	;TO USE DURING WRITING OF SATS
	MOVEI	F,DSKDDB##	;USE THE PROTOTYPE DDB TO  WRITE FROM
	HLRZ	U,SYSUNI##	;LOC OF 1ST UNIT DB
WTSAT2:	PUSHJ	P,WTUSAT##	;WRITE SATS FOR UNIT WHICH HAVE CHANGED
	HLRZ	U,UNISYS##(U)	;STEP TO NEXT
	JUMPN	U,WTSAT2(P2)	;GO IF THERE IS A UNIT
RSPWT1::MOVE	T1,PWAITZ##	;RESTORE REAL PWAIT1
	MOVEM	T1,PWAIT1##
	POPJ	P,
IFE FTKS10,<
;HERE TO SEE IF AN RC10 KONTROLLER IS UP

FHXUPA::LDB	T1,KOYPI##	;GET PI FOR THIS KONTROLLER
	TRO	T1,FHALCL##	;CLEAR ALL ERROR FLAGS
	XCT	FHXCOT##(J)	;CONO FH'N,(T1)
	XCT	FHXCI1##(J)	;CONI FH'N,T2
	TRNN	T2,1B23!1B31!1B32	;ANYTHING WRONG
	TRNN	T2,7		;ARE THE PI BITS THERE?
	POPJ	P,		;YES - ERROR RETURN
	JRST	CPOPJ1##	;OK RETURN


;HERE TO SEE IF AN RP10 KONTROLLER IS UP

DPXUPA::PUSHJ	P,SAVE2##	;SAVE P1-P2
	HRRZ	P2,SYSINA##	;SETUP RELOCATION REGISTER FOR SYSINI
	SUBI	P2,SYSINI	;ACTUAL SYSINI - LOADED SYSINI
	LDB	T2,KOYPI##	;PI CHANNEL FOR THIS KONTROLLER
	TRO	T2,DPCLR##	;CLEAR ALL ERROR FLAGS
	XCT	DPXCO1##(J)	;DO THE CONO
	MOVE	T1,[XWD 500000,DPATTN##](P2)
	XCT	DPXDOT##(J)
	XCT	DPXCIT##(J)
	TRNE	T1,7		;CONTROLLER ON-LINE?
	TRNE	T1,175770	;YES. TEST ALL BUT DISK NRDY
	POPJ	P,
	XCT	DPXDI1##(J)	;DATAI DP'N, T2
	TLNN	T2,1		;WRITE-HEADER LOCKOUT ON?
	SETZ	T1,		;NO, SO INDICATE
	JRST	CPOPJ1##


;HERE TO SEE IF AN RH10 KONTROLLER FOR RS04'S IS UP

FSXUPA::LDB	T4,KOYPI##	;PI
	TRO	T4,FSALCL##	;CLEAR ALL ERROR BITS
	XCT	FSXCO4##(J)	;CONO FSX,(T4)
	XCT	FSXCI2##(J)	;CONI FSX,T2
	TRNN	T2,2030		;PS FAIL, BUSY OR DONE UP?
	TRNN	T2,7		;NO, PI UP?
	POPJ	P,		;DOWN
	PJSP	T1,CPOPJ1	;UP, SET T1 NON-0 (WH LOCKOUT), AND RETURN
;HERE TO SEE IF AN RH10 OR RH20 KONTROLLER FOR RP0X'S IS UP

RPXUPA::PUSHJ	P,SAVE2##
	SETOM	RPXFLG##(J)
	LDB	T4,KOYPI##	;PI
IFN FTKL10,<
	PUSHJ	P,RPXSTW##	;SET P1=0 IF RH10, =1 IF RH20
	SKIPE	P1		;IF AN RH20,
	TROA	T4,4450		; CLEAR THESE BITS
>
	TRO	T4,RPALCL##+40	;CLEAR ALL ERROR BITS, ATTEN ENABLE
	XCT	RPXCO4##(J)	;CONO RPX,(T4)
	XCT	RPXCI2##(J)	;CONI RPX,T2
IFE FTKL10,<
	TRNN	T2,2030		;PS FAIL, BUSY OR DONE UP?
>
IFN FTKL10,<
	HRRZ	P2,SYSINA##
	SUBI	P2,SYSINI
	ADDI	P1,(P2)
	TDNN	T2,[2030
		515020](P1)
>
	TRNN	T2,7		;NO, PI UP?
	POPJ	P,		;DOWN
	PJSP	T1,CPOPJ1##	;UP, SET T1 NON-0 (WH LOCKOUT), AND RETURN


;HERE TO SEE IF AN RH20 KONTROLLER FOR RP20'S IS UP

RNXUPA::PUSHJ	P,RNXIVI##	;ASSIGN INTERRUPT VECTOR ADDRESS
	MOVSI	T1,RNPUPA##	;ALREADY BEEN THROUGH HERE FOR
	TDNE	T1,RNXFLG##(J)	;  THIS CONTROLLER?
	SJSP	T1,CPOPJ1##	;YES, IT'S UP
	SETZM	RNXCMD##(J)	;CLEAR COMMAND/FLAGS
	MOVEI	T2,4450		;GET BITS TO CLEAR ERROR IN RH20
	XCT	RNXCO2##(J)	;DO SO
	PUSHJ	P,RNXFKA##	;FIND DX20 CONTROLLER ADDRESS
	  POPJ	P,		;NOT FOUND
	LDB	T2,KOYPI##	;GET PIA FOR RH20
	TRO	T2,4450		;CLEAR RAE+MBE+ATTN ENA+CLEAR DONE
	XCT	RNXCO2##(J)	;CLEAR ERRORS AND ASSIGN A PI
	XCT	RNXCI2##(J)	;GET CONI
	TRNN	T2,515020	;ANY ERRORS?
	TRNN	T2,7		;  OR NO PIA?
	POPJ	P,		;DRIVE IS DOWN
	MOVSI	T1,RNPUPA##	;SET FLAG THAT WE HAVE
	IORM	T1,RNXFLG##(J)	;  BEEN HERE BEFORE
	SJSP	T1,CPOPJ1##	;AND GIVE SKIP RETURN WITH T1 NON-ZERO


;HERE TO SEE IF THE KONTROLLER FOR HSC-50 DISKS IS UP

RAXUPA::PJSP	T1,CPOPJ1##	;ALWAYS UP, SET T1 NON-ZERO (WH LOCKOUT), AND RETURN
>;END IFE FTKS10
IFN FTKS10,<
;HERE TO SEE IF RH11 KONTROLLER IS UP ON KS10

RPXUPA::MOVE	T1,RHXBAS##(J)	;GET BASE ADDRESS OF I/O REGISTERS
	PUSHJ	P,UBGOOD##	;IS RH11 ALIVE ?
	  POPJ	P,		;NO - RETURN OFF LINE
	SETOM	RPXFLG##(J)	;SET CONTROLLER IDLE
	MOVE	P1,KONCHN##(J)	;CHANNEL DATA BLOCK
	MOVE	T3,RHXVEC##(J)	;GET INTERRUPT VECTOR ADDRESS
	LSH	T3,-2		;DIVIDE BY 4
	HLRZ	T4,RHXBAS##(J)	;GET UBA NUMBER
	ADD	T3,.EPVIT##-1(T4) ;ADD INT VECTOR TABLE BASE ADDRESS
	MOVE	T4,RHXIVI##(J)	;GET INT VECTOR INSTRUCTION
	MOVEM	T4,(T3)		;SET UP VECTORED INTERRUPT JSR
	MOVE	W,RHXBAS##(J)	;GET RH11 BASE ADDRESS
	MOVEI	T4,40		;CONTROLLER CLEAR BIT
	WRIO	T4,10(W)	;WRITE CONTROLLER STATUS REGISTER
	MOVEI	T4,200		;READY BIT
	TION	T4,(W)		;SHOULD BE ON
	POPJ	P,		;NOT READY, ASSUME DOWN
	PJSP	T1,CPOPJ1##	;GOOD RETURN
>;END IFN FTKS10
SUBTTL SWPSER
;ROUTINE TO RE-INITIALIZE THE SWAPPING AVAILABILITY TABLE.  CALLED AT
; SYSTEM INITIALIZATION TIME.

SWPINI:	MOVEI	T1,ASSCON	;FLAG SWAPPER DDB AS ASSIGNED BY CONSOLE
	IORM	T1,SWPDDB##+DEVMOD ;SINCE IT APPEARS IN SYSTEM DDB LIST (BEFORE PROTOTYPE
				; ELSE USERS COULD INIT IT.
IFN FTMP,<
	MOVE	T1,DSKDDB##+DEVCPU ;INITIALIZE INTERLOCK POINTER
	HRRM	T1,SWPDDB##+DEVCPU
>
	SETZB	T1,R		;MAKE SURE ASSIGNED TO JOB 0
	DPB	T1,PJOBN##
	HLRZ	U,SWPUNI##	;GET ADDR OF FIRST UNIT FOR SWAPPING
	JUMPE	U,CPOPJ##	;EXIT IF NOT A UNIT DATA BLOCK
	HRLM	U,NXTSUN##	;INITIALIZE NEXT SWAPPING UNIT
	SETZM	SQREQ##		;CLEAR SWAPPPING LOCS
	SETZM	VIRTAL##	;START TOTAL VIRTUAL CORE FOR SYSTEM AT 0
IFN FTXMON,<
	LDB	R,UNYSNS##	;SECTION NUMBER FOR SWAPPING SATS
	MOVSS	R		;TO THE LEFT HALF
>

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	SE1ENT			;MUST BE IN SECTION 1
SWPIN1:	SETZM	UNIFKS##(U)	;CLEAR FREE J FOR SWAP
	SKIPL	T1,UNIPTR##(U)	;SKIP IF SWAPPING SPACE ON THIS UNIT
	JRST	SWPIN2(P2)	;NONE
	HLRE	T2,T1		;T2=-LENGTH OF SWAPPING SAT
	HRLS	T1		;T1=ADDR IN BOTH HALVES
	SUBB	T1,T2		;T1=BLT PTR
	MOVSS	T1
IFE FTXMON,<
	BLT	T1,-1(T2)	;COPY INITIAL SWAPPING SAT
>
IFN FTXMON,<
	HLRZ	T2,T1		;STARTING ADDRESS, SECTION RELATIVE
	HRRZ	T3,T1		;WHERE TO BLT TO, SECTION RELATIVE
	ADD	T2,R		;ADD IN SECTION NUMBER
	ADD	T3,R		; DITTO
	MOVSI	T1,400000	;MAKE LOGICAL BLOCK 0 BE UNAVAILABLE
	IORM	T1,(T2)
	HLRE	T1,UNIPTR##(U)	;NEGATIVE LENGTH
	MOVMS	T1		;LENGTH
	EXTEND	T1,[XBLT ](P2)	;MOVE IT
>
	MOVE	T1,UNIPTR##(U)	;PTR TO SWAPPING SAT
IFE FTXMON,<
	MOVSI	T2,400000	;MAKE LOGICAL BLOCK 0 BE UNAVAILABLE
	IORM	T2,(T1)		; SINCE SLOT=0 MEANS PAGE NOT IN USE AT ALL
>
	PUSHJ	P,SATCN##	;COUNT 0 BITS=FREE K
	ADDM	T2,VIRTAL##	;COUNT TOTAL IN SYSTEM
	MOVEM	T2,UNIFKS##(U)	;AND GET FOR UNIT
SWPIN2:	HLRZ	U,UNISWP##(U)	;NEXT UNIT IN SWAP LIST
	JUMPN	U,SWPIN1(P2)	;LOOP FOR ALL UNITS IN SWAP LIST
	MOVE	T1,VIRTAL##	;GET #K VIRTUAL CORE IN SYSTEM
	MOVEM	T1,K4SWAP##	;AS #K FOR SWAPPING IN SYSTEM
	MOVEM	T1,VMCMAX##	;SAVE AS MAX K FOR VIRTUAL JOBS
	POPJ	P,
SUBTTL SCHED1 INITIALIZATION
;INITIALIZE SCHEDULER  (CALLED FROM SYSINI BEFORE ALL OTHER
;	DEVICES ARE INITIALIZED)

NXTINI:	MOVEI	T1,AVLNUM##	;MAXIMUM NUMBER OF QUEUES
	SETZM	AVALTB##(T1)	;CLEAR SHARABLE DEVICE AVAIL. FLAGS
	SETZM	USRTAB##(T1)	;CLEAR SHARABLE RESOURCE OWNER
	SETOM	REQTAB##(T1)	;SET SHARABLE DEVICE REQUEST COUNT
				; TO -1,  I.E. NO JOB WAITING OR
				; USING DEVICE OTHER THAN INITIALIZATION
	SOJGE	T1,.-3(P2)
	SETZM	DAREQ##		;DA IS DIFFERENT
	SETZM	AUREQ##		;AU IS DIFFERENT
	SETZM	XJOB##		;CLEAR NUMBER OF JOBS NEEDING EXPANDING
	POPJ	P,
;QUEUE INITIALIZATION
;PUT ALL JOBS IN NULL QUEUE(JOB NO. NOT ASSIGNED)
;CALLED ON RESTART AT LOC. 143

QINI:	MOVNI	T1,MXQUE2##	;SET UP DOUBLE QUE HEADERS
	HRL	T1,T1		;BOTH HALVES POINT TO EMPTY SELF
	MOVEM	T1,JBTCQ##(T1)
	AOBJN	T1,.-1(P2)
	MOVNI	T1,OBQ##	;MAKE JBTOLS HEADERS POINT TO THEMSELVES
	HRL	T1,T1		;BACK POINTER ALSO
	MOVEM	T1,JBTOLS##(T1)
	AOBJN	T1,.-1(P2)
	MOVNI	T1,DISQ##	;MAKE DORMANT/IDLE QUEUE POINT TO SELF
	HRL	T1,T1		;
	MOVEM	T1,JBTDIH##	;
	MOVNI	T1,HSQ##	;MAKE JBTJIL HEADERS POINT TO THEMSELVES
	HRL	T1,T1		;BACK POINTER ALSO
	MOVEM	T1,JBTJIL##(T1)
	AOBJN	T1,.-1(P2)
IFN FTNSCHED,<
	MOVNI	T1,M.CLSN##	;MAKE CORE/NO-CORE SUBQUEUES POINT TO SELVES
	ASH	T1,1		;DOUBLE HEADERS
	HRL	T1,T1		;BOTH HALVES
	MOVEM	T1,JBTCSQ##(T1)
	AOBJN	T1,.-1(P2)
>;END FTNSCHED
	MOVEI	J,JOBMAX##	;MAX. JOB NO.
	MOVNI	T1,NCNULQ##	;PUT ALL JOBS IN NO CORE QUE
	MOVSM	T1,JBCQP1##	;BACK POINTER FOR JOB 1
	MOVEM	T1,JBTCQ##(J)	;FOR. POINTER OF JOBMAX JOB NO.
	HRLM	J,JBCQMN##	;SET NO CORE QUE HEADER TO POINT TO JOB 1
	MOVEI	T1,1		;AND JOBMAX
	HRRM	T1,JBCQMN##	;FORWARD POINTER
	MOVEI	T2,NULQ##		;SET UP QUE NUMBER
	SETZM	JBTCQ
QINI1:	DPB	T2,PJBST2##	;STORE INITIAL QUE NUMBER
	HRRM	J,JBCQM1##(J)	;JOB I-1 POINT TO JOB I
	SOJLE	J,CPOPJ		;FINISHED?
	HRLM	J,JBCQP1##(J)	;BACK POINTER JOB I+1 POINTS TO JOB I
	JRST	QINI1(P2)
SUBTTL KL10, KS10 60HZ INTERRUPT INITIALIZATION

;THIS ROUTINE CALLED AT THE POINT AT WHICH WE WOULD
; LIKE CLOCK TICKS TO START HAPPENING.

IFN FTKL10,<
TIMINI:
REPEAT 0,<
	MOVSI	T1,(ST%ITA)
	TDNE	T1,CNFST2##
	JRST	TIMIN1(P2)
>;END REPEAT 0
	CONI	MTR,T1
	CONO	MTR,AP0CHN##(T1)	;SETUP METER PI ASSIGNMENT
	MOVEI	T1,^D1666	;ASSUME 60HZ
	MOVE	T2,STATES##
	TLNE	T2,(ST.CYC)	;IS OUR ASSUMPTION CORRECT?
	MOVEI	T1,^D2000	;NO, 2000 IS INTERVAL
	CONO	TIM,TO.CTD!TO.CIT!TO.SIT(T1)	;START TIMER GOING
	POPJ	P,		;RETURN

REPEAT 0,<
;HERE IF 11 IS TO BE USED FOR 60HZ INTERRUPTS

TIMIN1:	MOVEI	T1,.DTCLK+1	;CLOCK CONTROL, ON
	SETZM	.C0IPI##	;INTERNAL TIMER HAS NO PI ASSIGNMENT
	JSR	SPCCMD##	;TURN ON INTERRUPTS
	POPJ	P,
>;END REPEAT 0

>;END IFN FTKL10
IFN FTKS10,<
TIMINI:	WRAPR	SP.SSF!SP.ITI	;TURN INTERVAL TIMER ON
	MOVEI	T1,^D17*10000	;ASSUME 60 HZ
	MOVE	T2,STATES##
	TLNE	T2,(ST.CYC)	;IS IT?
	MOVEI	T1,^D20*10000	;NO, 50HZ
	WRINT	T1		;SET UP INTERVAL REG
	POPJ	P,
>;END IFN FTKS10
SUBTTL KI10, KL10 OR KS10 INITIALIZATION

KIINI:	SE1ENT			;ENTER SECTION 1
	MOVE	T1,SYSSIZ##	;HIGHEST ADDRESS IN THE LOW SEGMENT
	LSH	T1,W2PLSH##	;HIGHEST PAGE
	MOVE	T2,.CPKPM##	;KEEP ME BIT OR 0
	MOVE	T3,.CPMAP##	;ADDRESS OF THIS CPU'S MAP
	IORM	T2,(T3)		;TURN ON "KEEP ME" IF THIS CPU HAS AN MCA25
	AOS	T3		;NEXT PAGE
	SOJG	T1,.-2(P2)	;FOR ALL LOW SEGMENT PAGES
	MOVEI	T1,NUPMPP##	;ADDRESS OF THE NULL JOB'S UPMP
	MOVEM	T1,JBTUPM##+0	;STORE IT
	MOVEI	T1,FYSORG
	CAMGE	T1,MONPFF##
	SKIPA	T1,MONPFF##
	MOVE	T1,SYSSIZ##
	MOVEM	T1,MONPFF##
	MOVE	T4,MEMSIZ##	;HIGHEST ADDRESS + 1
	CAMGE	T4,NWCORE##	;GREATER THAN HIGHEST ADDRESS SYSTEM WAS MONGENED FOR?
	MOVE	T4,NWCORE##	;NO, USE THAT TO SETUP PAGTAB AND MEMTAB
	MOVEM	T4,NWCORE##	;SAVE LARGER AS MAX CORE WHICH CAN BE SET ON LINE
	LDB	T1,[POINT 5,T4,17](P2)
	TRNE	T4,-1		;IF NOT A 256K BOUNDARY,
	ADDI	T1,1		;ANOTHER PAGE IS NEEDED
	PUSH	P,T1		;SAVE NUMBER OF PAGES REQUIRED FOR PAGTAB
	LSH	T1,P2WLSH##	;NUMBER OF WORDS
IFE FTXMON,<
	SETZM	PAGTAB		;ZERO THE FIRST WORD OF PAGTAB
	MOVE	T2,[PAGTAB,,PAGTAB+1](P2)
	BLT	T2,PAGTAB-1(T1)	;ZERO ALL OF PAGTAB
	SETZM	PT2TAB
	MOVE	T2,[PT2TAB,,PT2TAB+1](P2)
	BLT	T2,PT2TAB-1(T1)
	SETOM	MEMTAB		;SET MEMTAB TO - 1 WHICH DOESN'T LOOK LIKE A DSK ADDRESS
	MOVE	T2,[MEMTAB,,MEMTAB+1](P2)
	BLT	T2,MEMTAB-1(T1)	;ZAP, ITS ALL - 1
> ;END IFE FTXMON
IFN FTXMON,<
	DMOVE	T2,[EXP MS.MEM+PAGTAB,MS.MEM+PAGTAB+1](P2)
	PUSH	P,T1
	SOS	T1,(P)
	SETZM	(T2)
	EXTEND	T1,[XBLT](P2)	;ZERO PAGTAB
	DMOVE	T2,[EXP MS.MEM+PT2TAB,MS.MEM+PT2TAB+1](P2)
	MOVE	T1,(P)
	SETZM	(T2)
	EXTEND	T1,[XBLT](P2)
	POP	P,T1
	DMOVE	T2,[EXP MS.MEM+MEMTAB,MS.MEM+MEMTAB+1](P2)
	SETOM	(T2)		;SET MEMTAB TO -1 SO THAT USE WITHOUT SETUP
	EXTEND	T1,[XBLT](P2)	; WILL LIKELY CASE A STOPCD
> ;END IFN FTXMON

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	LDB	T2,[POINT 14,SYSSIZ##,26](P2)
	MOVSI	T1,MONTRB	;BIT WHICH SAYS THIS PAGE CONTAINS THE MONITOR
	MOVEI	T3,1		;STARTING AT PAGE 1,
	SSX	T3,MS.MEM	;PAGTAB SECTION
	SETZB	T4,PT2TAB-1(T3)	;FIRST PAGE IN PT2TAB
KIINI1:	HRRZM	T3,PAGTAB-1(T3)	;TURN IT ON
	HLLM	T1,PAGTAB-1(T3)	;+ MONTRB
	HRRZM	T4,PT2TAB(T3)
	AOS	T4
	CAIE	T2,1(T3)	;FOR ALL PAGES UP TO SYSSIZ
	AOJA	T3,KIINI1(P2)	; ..
	HRRZM	T3,LMPAG##	;SET LAST MONITOR PAGE SEEN
	MOVEI	T1,MONORG##	;WHERE TO START LOOKING
	MOVE	T4,MONVFF##	;FIRST FREE MONITOR VIRTUAL ADDRESS
	SUBI	T4,MONORG##	;MINUS MONITOR ORGIN
	LSH	T4,W2PLSH##	;EQUALS NUMBER OF MONITOR HI SEG PAGES
	PUSHJ	P,SETMRB(P2)	;MARK PAGES OF MONITOR CODE AND DATA
IFE FTXMON,<
	MOVEI	T1,PAGTAB	;MARK PAGTAB ITSELF AS TAKEN
	MOVE	T4,(P)		;NUMBER OF PAGES IN PAGTAB
	PUSHJ	P,SETMRB(P2)	;MARK THE ENTRIES IN PAGTAB FOR PAGTAB
	MOVEI	T1,PT2TAB	;MARK PT2TAB
	MOVE	T4,(P)
	PUSHJ	P,SETMRB(P2)	;MARK
	MOVEI	T1,MEMTAB	;AND MEMTAB TOO
	MOVE	T4,(P)		;SAME SIZE AS PAGTAB
	PUSHJ	P,SETMRB(P2)
	SKIPN	[M.DECN##](P2)	;MONITOR INCLUDE DECNET?
	JRST	KIIN1A(P2)	;NO, NO DECNET CORE ALLOCATED
	MOVE	T1,DCNAEB##+AEBADR ;ADDRESS OF START OF DECNET CORE
	LSH	T1,W2PLSH##	;PAGE NUMBER
	MOVEI	T4,.LPMC/PAGSIZ## ;HIGHEST POSSIBLE PAGE ALLOCATED FOR DECNET
	SUB	T4,T1		;NUMBER OF PAGES TO CONSIDER
IFN FTMP,<PRINTX ?FTMP VS .E0MP1...>
	ADDI	T1,.E0MP1##	;POINT AT THE MAP WE WANT
	PUSHJ	P,SETMRP(P2)	;MARK PAGES AS USED
	MOVEI	T1,.E0MP1##+MONORG/PAGSIZ## ;MAKE WRITE PROTECT CORRECT
	MOVE	T4,MONVFF##	; IN THE DECNET MAP
	SUBI	T4,MONORG
	LSH	T4,W2PLSH##
	PUSHJ	P,SETMRP(P2)	;SET/CLEAR WRITE ENABLE
;	PUSHJ	P,DNMAP##	;ALTERNATE MAP
;	PUSHJ	P,SETMRR(P2)	;MARK PAGES AS USED
;	PUSHJ	P,RGMAP##	;BACK TO REGULAR MAP
KIIN1A:>
IFN FTXMON,<
	MOVEI	T4,HLGSNO-3	;NUMBER OF SECTIONS TO CONSIDER
	MOVEI	T1,SECTAB+2	;SECTION 0, 1, AND 37 ARE SPECIAL
	ADD	T1,.CPEPT##	;STARTING ADDRESS IN THE SECTION TABLE
	PUSHJ	P,SETMRP(P2)	;MARK PAGES AS IN USE BY THE MONITOR
	HRROI	T1,[MOVEI T4,1	;ALSO MARK SKY HIGH SECTION MAPS FOR ALL OTHER CPUS
		    MOVEI T1,<SECTAB+(MS.HGH)>
		    ADD T1,.CPEPT##-.CPCDB##(P1)
		    PJRST SETMRP(P2)](P2)
	PUSHJ	P,CPUAPP##	;MARK PAGES AS TAKEN
	MOVEI	J,(MS.FMD)	;AS WAS STATED, SECTIONS 0 AND 1 ARE SPECIAL
KIINI2:	MOVE	T1,.CPEPT##	;ADDRESS OF OUR PROCESS TABLE
	ADDI	T1,SECTAB(J)	;ADDRESS OF THE ENTRY IN THE SECTION TABLE
	SKIPN	T2,(T1)		;HAS THIS SECTION BEEN ALLOCATED?
	JRST	KIINI3(P2)	;NO, SAVE TIME
	MOVE	T1,.CPMAP##	;ADDRESS OF OUR MAP
	MOVEM	T2,.EUPMP/PAGSIZ##(T1) ;SECTION MAP
	CLRPT	.EUPMP		;MAKE SECTION MAP ADDRESSABLE
	MOVEI	T1,.EUPMP	;VIRTUAL ADDRESS OF THE SECTION MAP
	MOVEI	T4,^D512	;NUMBER OF PAGES IN A SECTION
	PUSHJ	P,SETMRP(P2)	;MARK ALLOCATED PAGES IN THIS SECTION
KIINI3:	CAIGE	J,HLGSNO-1	;LOOKED AT ALL SECTIONS?
	AOJA	J,KIINI2(P2)	;NO, LOOP OVER ALL
>
IFN FTSCA,<
	SKIPN	T1,BHDADR##	;ADDRESS OF BUFFER HEADER DESCRIPTOR AREA
	JRST	KIIN3A(P2)	;NONE, SKIP ON
	LSH	T1,W2PLSH##	;GET STARTING PAGE NUMBER
	MOVE	T2,BHDPGS##	;GET NUMBER OF PAGES
	PUSHJ	P,SETCTB(P2)	;SET THE "PHYSICALLY CONTIGUOUS" BIT IN PAGTAB
KIIN3A:	SKIPN	T1,BSDADR##	;ADDRESS OF BUFFER SEGMENT DESCRIPTOR AREA
	JRST	KIIN3B(P2)	;NONE, SKIP ON
	LSH	T1,W2PLSH##	;GET STARTING PAGE NUMBER
	MOVE	T2,BSDPGS##	;GET NUMBER OF PAGES
	PUSHJ	P,SETCTB(P2)	;SET THE "PHYSICALLY CONTIGUOUS" BIT IN PAGTAB
KIIN3B:
>; END IFN FTSCA
	PUSHJ	P,BTAVAL##	;GET ADDRESS OF BOOTSTRAP VECTOR
	  JRST	KIIN3C(P2)	;BOOTSTRAP NOT AVAILABLE
	MOVE	T1,BOOTPA##	;GET PHYSICAL ADDRESS OF BOOTSTRAP
	LSH	T1,W2PLSH##	;GET STARTING PAGE NUMBER
	HLRE	T2,.BTSIZ(T2)	;GET -VE NUMBER OF PAGES IN BOOTSTRAP
	MOVMS	T2		;GET NUMBER OF PAGES
	PUSHJ	P,SETCTB(P2)	;SET THE "PHYSICALLY CONTIGUOUS" BIT IN PAGTAB
KIIN3C:	MOVE	T1,SYSSIZ##
	HRRZ	T3,.JBSYM##	;ADDRESS OF THE DDT SYMBOL TABLE
	JUMPE	T3,KIINI4(P2)	;OK IF NONE
	SUB	T1,T3
	SKIPGE	DEBUGF##	;DEBUGGING?
	SKIPG	T1		;YES, DOES THE SYMBOL TABLE OVERLAP THE MONITOR?
	JRST	KIINI4(P2)	;NO, ALL IS WELL
;HERE IF THE MONITOR AND DDTS SYMBOL TABLE OVERLAP.  SIGH, DISCARD SOME SYMBOLS
	HRLZ	T2,T1		;SET TO ADJUST SYMBOL TABLE POINTER
	ADD	T2,.JBSYM##	;NEW LENGTH IN THE LEFT HALF
	HRR	T2,SYSSIZ##	;NEW START ADDRESS IN THE RIGHT HALF
	MOVEM	T2,.JBSYM##	;STORE NEW POINTER TO THE SYMBOL TABLE
	TRNE	T1,PG.BDY##	;AN INTEGRAL NUMBER OF PAGES?
	ADDI	T1,PAGSIZ##	;NO, ROUND UP
	LSH	T1,W2PLSH##	;CONVERT TO NUMBER OF PAGES
	MOVE	T2,NXMPTR##	;AOBJN POINTER TO NXMTAB
	LSH	T3,W2PLSH##	;STARTING PAGE NUMBER
	PUSHJ	P,ZERBTS##	;MAKE DISCARDED S.T. PAGES APPEAR TO EXIST AGAIN
KIINI4:	MOVE	U,[POINT 1,NXMTAB##](P2)
	MOVE	T1,(P)		;NUMBER OF PAGES IN PAGTAB
	LSH	T1,P2WLSH##	;NUMBER OF WORDS IN PAGTAB
	SETZB	T2,T3		;INITIALIZE
	PUSH	P,T3		;SAVE BITS
KIINI5:	ILDB	T4,U		;NEXT PAGE IN NXMTAB
	JUMPE	T4,KIINI7(P2)	;JUMP IF PAGE EXISTS
	SKIPE	@[IW MS.MEM,PAGTAB(T3)](P2) ;IS THE PAGE FREE?
	STOPCD	.,STOP,MNM,	;++MONITOR IN NON-EXISTANT MEMORY
	TLO	T3,NXMBIT	;INDICATE NON-EXISTANT PAGE
	TLZ	T3,MONTRB
	JUMPE	T2,KIINI6(P2)	;JUMP IF NO PREDECESSOR
	SSX	T2,MS.MEM	;SET SECTION NUMBER IN INDEX
	HLLM	T3,(P)		;SAVE LATEST BITS
	MOVEM	T3,PAGTAB(T2)	;STORE THAT IN PAGTAB
KIINI6:	HRRZS	T2,T3		;PREDESSOR TO THIS PAGE
KIINI7:	CAIE	T1,1(T3)	;LOOKED AT EVERY PAGE IN PAGTAB?
	AOJA	T3,KIINI5(P2)	;NO, LOOP OVER ALL PAGES
	POP	P,T3		;RESTORE BITS
	SSX	T2,MS.MEM	;SECTION NUMBER
	TRNE	T2,-1		;ANY NON-EXISTANT PAGES AT ALL
	HLLZM	T3,PAGTAB(T2)	;YES, INDICATE THE LAST ONE
	SETZ	T2,		;NO PREDECESSOR
	SSX	T2,MS.MEM	;GIVE IT A FREE PAGTAB SECTION
	SETZB	T3,J		;NO FREE PAGES SEEN YET
	LDB	T1,[POINT 14,MEMSIZ##,26](P2)
IFN FTXMON,ADD	T1,[MS.MEM-1](P2) ;BUMP DOWN TO LAST PAGE
IFE FTXMON,SUBI	T1,1		;DITTO
KIINI8:	SKIPE	PAGTAB(T1)	;IS THIS PAGE FREE?
	JRST	KIIN10(P2)	;NO
	TRNN	T2,-1		;FIRST FREE PAGE?
	JRST	[HRRZM T1,PAGPTR## ;YES, STORE ORGIN OF THE FREE CORE LIST
		 SETZM PT2TAB(T1)
		 JRST KIINI9(P2)](P2)
	SPUSH	T1
	HRLI	T1,FREPAG	;INDICATE A FREE PAGE
	MOVEM	T1,PAGTAB(T2)	;STORE THAT IN PAGTAB
	SSX	T1,MS.MEM
	HRRZM	T2,PT2TAB(T1)
	SPOP	T1
KIINI9:	MOVE	T2,T1		;SAVE PREDECESSOR
	ADDI	T3,1		;NEXT PAGE
KIIN10:	TRNE	T1,-1   	;LOOKED AT ALL PAGES IN PAGTAB?
	SOJA	T1,KIINI8(P2)	;NO
	HRLI	T1,FREPAG	;LAST FREE PAGE
	HLLZM	T1,PAGTAB(T2)	;TERMINATE LINKED LIST OF FREE PAGES
	MOVEM	T3,BIGHOL##	;STORE THE NUMBER OF EXISTANT PHYSICAL PAGES
	MOVEM	T3,CORTAL##	; OF USER CORE SEEN
	MOVEM	T3,USRCOR##	;TOTAL AMOUNT OF USER CORE
	LSH	T3,P2WLSH##	;CONVERT TO NUMBER OF WORDS
	MOVEM	T3,MAXMAX##	;MAX CORMAX CAN BE SET TO
	MOVE	T2,T3
	SUBI	T2,NWMCP+PAGSIZ##
	MOVEM	T2,RMCMAX##	;REAL MAXIMUM CORMAX
	HRRZ	T1,CORLIM##	;MAXIMUM NUMBER OF PAGES ALLOWED A SINGLE
				; USER (MONGEN SPECIFIED)
	LSH	T1,P2WLSH##	;CONVERT TO NUMBER OF WORDS
	CAMGE	T1,T3		;.GE. THE NUMBER OF PAGES AVAILABLE TO USERS?
	MOVE	T3,T1		;NO, MAXIMUM AVAILABLE TO USERS
	CAMLE	T3,T2
	MOVE	T3,T2
	MOVEM	T3,CORMAX##	;NOONE CAN GET LARGER THAN THIS (HOPEFULLY)
	LDB	T1,[POINT 14,MEMSIZ##,26](P2)
	MOVEI	T1,PAGTAB-1(T1)	;HIGHEST PAGE IN THE MONITOR - 1
	SSX	T1,MS.MEM	;PAGTAB SECTION
	MOVEM	T1,CORLST##	;HIGHEST PAGE IN PAGTAB
	MOVEI	T1,DOORBL##	;ADDRESS OF DOORBELL
	LSH	T1,W2PLSH##	;CONVERT TO PAGE NUMBER
	TLO	T1,(<PM.DCD>B2+PM.WRT+PM.PUB)
	MOVEM	T1,NLUPMP##(T1)
	MOVE	T1,EVMPTR##	;AOBJN POINTER TO EVBTAB
	SETZM	(T1)		;INITIALIZE TO ALL BITS OFF
	AOBJN	T1,.-1(P2)	;SET EVERY WORD IN THE TABLE
	MOVE	T1,[-1_-<^D<512-36*<512/36>>>](P2)
	MOVEM	T1,EVBTAB##+^D<512/36>
	POP	P,(P)		;JUST JUNK HERE
	MOVE	T3,SYSSIZ##	;FROM 0 THROUGH SYSSIZ
	LSH	T3,W2PLSH##	;NUMBER OF PAGES
	MOVSI	T4,^D36		;STARTING AT PAGE 0
	HRRI	T4,EVBTAB##+0	;WHERE IN THE TABLE
	PUSHJ	P,CSETOS##	;MARK THE BITS (NOT AVAILABLE FOR EVM)
	MOVEI	T3,FYSORG/PAGSIZ## ;FIRST PAGE OF FUNNY SPACE
	IDIVI	T3,^D36		;WORD NUMBER AND BIT POSITION
	SUBI	T4,^D36
	MOVNS	T4		;BIT POSITION
	MOVSS	T4		;TO THE LEFT HALF
	HRRI	T4,EVBTAB##(T3)	;STARTING WORD WITHIN TABLE
	MOVEI	T3,<.LPPP-FYSORG>/PAGSIZ## ;NUMBER OF BITS TO SET
	PUSHJ	P,CSETOS##	;MARK OFF BITS REPRESENTING FS AND PP SLOTS
	MOVEI	T3,MONORG##-RHWEVM*PAGSIZ## ;ORIGIN OF TEMP MAPPING SLOTS
	LSH	T3,W2PLSH##	;PAGE NUMBER
	IDIVI	T3,^D36		;WORD NUMBER AND BIT POSITION
	SUBI	T4,^D36
	MOVNS	T4		;MAKE AN AOBJN POINTER
	MOVSS	T4
	HRRI	T4,EVBTAB##(T3)
	MOVE	T3,MONVFF##	;FIRST FREE VIRTUAL LOCATION ABOVE THE MONITOR
	SUBI	T3,MONORG##-RHWEVM*PAGSIZ## ;MINUS START OF THE MONITOR
	LSH	T3,W2PLSH##	;NUMBER OF BITS TO SET
	PUSHJ	P,CSETOS##	;MONITOR PAGES ARE NOT AVAILABLE AS EVM
	PUSH	P,P2		;SAVE SYSINI'S RELOCATION
	MOVE	P1,EVMPTR##	;AOBJN POINTER TO EVM TABLE
	MOVEI	P2,0
	MOVEI	P3,-1
	PUSHJ	P,GETZ##	;FIND THE LARGEST CONTIGUOUS PIECE OF EVM
	  MOVEM	P2,EVBMAX##	;STORE THAT AS THE LARGEST IOWD SIZE
	POP	P,P2		;RESTORE SYSINI'S RELOCATION
IFE FTXMON,<
REPEAT 0,<	;SOMEDAY, WE MAY WANT TO MAKE THIS WORK
	SKIPN	[M.DECN##]	;IF NO DECNET
	 JRST	KIN10D(P2)	;SKIP THIS NONSENSE
	MOVE	P1,EVMPTR##	;AOBJN POINTER TO EVM TABLE
KIN10A:	SETCM	T1,(P1)		;GET THIS WORD OF EVM BIT TABLE.
KIN10B:	JFFO	T1,.+2(P2)	;FIND FIRST ZERO
	 JRST	KIN10C(P2)	;NONE, TRY NEXT WORD
	MOVE	P3,BITTBL##(T2)	;GET THE CORRESPONDING BIT
	TDZ	T1,P3		;WE'VE SEEN THIS
	HRRZ	T3,P1		;ADDRESS OF CURRENT WORD
	HRRZ	T4,EVMPTR	;BASE ADDRESS OF TABLE
	SUBI	T3,(T4)		;WORD OFFSET OF THIS WORD
	IMULI	T3,^D36		;BITS BEFORE THIS WORD
	ADDI	T2,(T3)		;PAGE NUMBER OF THIS BIT
	MOVE	T3,SYSSIZ##	;GET SIZE OF TE LOW SEGMENT
	MOVE	T4,DCNCOR##	;AND BEGINNING OF DECNET CORE
	LSHC	T3,W2PLSH##	;PAGE NUMBERS
	CAML	T2,T3		;BELOW SYSSIZ?
	CAML	T2,T4		;OR ABOVE START OF DECNET CORE?
	JRST	[CAIGE T2,MONORG_W2PLSH## ;ABOVE TOP OF DECNET SPACE?
		 IORM P3,(P1)	;NO, CAN'T BE USED AS EVM
		 JRST KIN10B(P2)](P2) ;LOOP FOR ALL ZEROES
IFN FTMP,<PRINTX ?FTMP MUST FIX .E0MP1 REFERENCES HERE AND ELSEWHERE...>
	MOVE	T3,[<PM.ICD>B2+PM.WRT+PM.CSH+<SPTLOW##-SPTTAB##>](P2) ;@ POINTER
;	ADD	T3,.CPCPN	;INDEX SPTLOW BY CPU #
	TLO	T3,(T2)		;WE INDEX INTO REGULAR MAP BY IT'S PAGE #
	MOVEM	T3,.E0MP1##(T2)	;NO-STORE @ POINTER TO NORMAL MAP IN DECNET MAP
	JRST	KIN10B(P2)	;LOOP TILL FOUND ALL ZEROS

KIN10C:	AOBJN	P1,KIN10A(P2)	;LOOP FOR WHOLE TABLE
KIN10D:>
>
IFN FTKL10,<
	PUSHJ	P,GIVPMR##	;INITIALIZE PERFORMANCE METER
	SETOM	.CPPTF##	;INITIALIZE FLAG WHICH ALLOWS IO PAGE TABLE
IFN FTMP,<
	MOVE	P1,[CPUN##](P2)	;GET NUMBER OF CPUS MONITOR WAS BUILT FOR
	SOJLE	P1,KIIN11(P2)	;IF ONE CPU, TURN OFF CACHE FOR A FEW PAGES
	MOVSI	T1,(ST%LSC)	;LOW SEGMENT CACHED BIT
	ANDCAM	T1,CNFST2##	;NOT ON 1088'S
	SETZ	T1,		;ON 1088 SYSTEMS, MUST TURN OFF
	MOVEI	T2,FYSORG-1	; CACHE FOR ENTIRE LOWSEG
	PUSHJ	P,CCTRNG(P2)	;CLEAR
	MOVEI	T1,CSHFIR##	;START UP INTERRUPT LEVEL PDL'S AND STUFF
	MOVEI	T2,CSHLAS##	;CAN CACHE ALL OF THAT
	PUSHJ	P,CSBRNG(P2)	;SINCE NOT REALLY SHARED BETWEEN CPUS
	MOVE	T1,SYSLEN##	;SIZE OF HIGH SEGMENT CODE
	ADDI	T1,MONORG##	;FIRST LOC OF EXTENDED DATA ALLOCATIONS
	MOVE	T2,MONVFF##	;AND FIRST LOCATION NOT USED
	SOS	T2		;TO LAST ADDRESS ALLOCATED
	PUSHJ	P,CCTRNG(P2)	;CLEAR CACHE BITS FOR LDB'S ETC...
IFE FTXMON,<
	MOVE	T2,NWCORE##	;NUMBER OF WORDS IN PHYSICAL CORE
	ADDI	T2,777777	;ROUND UP TO 256K BOUNDARY
	HLRZS	T2		;NUMBER OF PAGES FOR PAGTAB & MEMTAB
	LSH	T2,P2WLSH##	;TO NUMBER OF WORDS
	PUSH	P,T2		;SAVE IF
	MOVEI	T1,PAGTAB	;START OF PAGTAB
	ADDI	T2,-1(T1)	;END OF PAGTAB
	PUSHJ	P,CCTRNG(P2)	;CLEAR CACHE BITS FOR PAGTAB
	POP	P,T2		;NUMBER OF WORDS AGAIN
	MOVEI	T1,MEMTAB	;START OF MEMTAB
	ADDI	T2,-1(T1)	;END OF MEMTAB
	PUSHJ	P,CCTRNG(P2)	;CLEAR CACHE BITS FOR MEMTAB
>
IFN FTXMON,<
	MOVE	U,[TLZ T1,(PM.CSH)](P2)	;CACHE OFF
	MOVE	P1,[TLO T2,TNCSHB](P2)	;ALWAY TEMPORARILY
	MOVE	J,.CPEPT##
	ADDI	J,<(MS.FMD)>+1	;START AT FIRST REAL DATA SECTION
KII10A:	SKIPE	T1,SECTAB(J)
	TLNN	T1,(PM.CSH)	;ALLOW FOR UNCACHED SECTION
	JRST	KII10B(P2)
	MOVE	T2,.CPMAP##
	MOVEM	T1,.EUPMP/PAGSIZ##(T2)
	CLRPGT	C0,.EUPMP
	MOVEI	T2,^D511	;HIGHEST PAGE
	MOVEI	T3,0		;STARTING PAGE
	MOVEI	T4,.EUPMP	;ADDRESS OF THE MAP
	PUSHJ	P,CCTRNS(P2)	;MARK PAGES
KII10B:	MOVE	T1,.CPEPT##
	CAIGE	J,MXSECN-1(T1)
	AOJA	J,KII10A(P2)
>
	MOVEI	T1,OUCHTB##	;OUCHTB MUST BE UNCACHED
	MOVEI	T2,OUCHTB##+7
	PUSHJ	P,CCTRNG(P2)
KIIN11:>;END IFN FTMP
	SETZ	P1,		;CLEAR LTINIT INDEX
KIIN12:	SKIPN	T1,LTINIT##(P1)	;LTINIT ENDS WITH A ZERO
	JRST	KIIN13(P2)	;DONE
	HLRZ	T2,T1		;GET NUMBER OF 4 WORD BLOCKS
	LSH	T2,2		;MAKE IT NUMBER OF WORDS
	ADDI	T2,-1(T1)	;GET END ADDRESS OF THIS CHUNK
	HRRZS	T1		;CLEAR LEFT HALF FOR CCBRNG
	PUSHJ	P,CCBRNG(P2)	;CLEAR CACHE BITS IN EXEC MAP
	AOJA	P1,KIIN12(P2)	;AND GET NEXT ENTRY IN LTINIT
KIIN13:	MOVE	T1,TAPDST##	;START OF TAPSER DATA BASE
	MOVE	T2,TAPDEN##	;END OF IT
	CAIE	T1,(T2)		;ANY EXTERNAL (DX10) TAPES
	PUSHJ	P,CCBRNG(P2)	;YES, UNCACHE CHANNEL COMMAND LISTS
	MOVEI	T1,DLXFST##	;CLEAR OUT CACHE BITS FOR DC75
	MOVEI	T2,DLXLST##
	CAIN	T1,(T2)		;ANY DL10 WINDOWS DEFINED
	JRST	KII10C(P2)	;NO, DON'T BOTHER
	PUSHJ	P,CCBRNG(P2)
	MOVEI	T1,.C0UPT##	;DC76 LOOKS AT UPTIME FOR CPU0
	MOVE	T2,T1		;UNCACHE JUST THIS
	PUSHJ	P,CCBRNG(P2)	;CLEAR OUT CACHE FOR UPTIME
	MOVEI	T1,.CPUPT##	;UNCACHE THE OTHER VIRTUAL MAPPING TOO
	MOVE	T2,T1		;ONLY THE ONE WORD
	SKIPN	.CPCPN##	;UNLESS WE'RE NOT CPU #0.
	PUSHJ	P,CCBRNG(P2)	;  (ONLY PLACE A DC76 CAN BE).
KII10C:
REPEAT 0,<
	SKIPL	DEBUGF##	;IF DEBUGGING WITH EDDT
	JRST	.+4		;NO-DONT BOTHER
	MOVEI	T1,DDT##	;CLEAR THE CACHE BITS FOR EDDT
	MOVEI	T2,DDTEND##	;TO DDTEND, SYMBOL TABLE IS NEVER WRITTEN
	PUSHJ	P,CCBRNG(P2)
;THE ABOVE CODE, IF ALLOWED TO ASSEMBLE (PUT ";" IN FRONT OF THE REPEAT
;AND THE CLOSING ANGLE BRACKET ABOVE) WILL KEEP DDT OUT OF THE CACHE. THIS IS HANDY IF YOU
;ARE DEBUGGING MONITOR PORTIONS WHICH HANDLE CACHE!!!
	MOVEI	T1,APRPAR##	;KEEP THE APR PARITY RECOVERY CODE
	MOVEI	T2,APPCP2##	;OUT OF THE CACHE UNTIL
				;THE CACHE HAS BEEN SWEPT BACK TO CORE
				;THIS WILL CLOSE DOWN (BUT NOT SHUT) THE WINDOW
				;OF RECURSIVE FAILURES
	PUSHJ	P,CCBRNG(P2)	;AND SHOULD IMPROVE RECOVERY CHANCES
>;END REPEAT 0
>;END IFN FTKL10
IFN FTKS10,<			;ONLY KS-10'S HAVE KMC/DUP-11S
	MOVEI	T1,KDLFST##	;GET THE ADDRESS OF THE FIRST KDL PAGE
	MOVEI	T2,KDLLST##	;GET ADDR OF LAST WORD OF THE LAST
	CAIE	T1,(T2)		;IF ANY KDL PAGES ARE DEFINED, THEN
	PUSHJ	P,CCBRNG(P2)	;  MAKE SURE THAT THEY ARE UNCACHED.
>
	MOVE	T1,SYSSIZ##	;NOW CLEAR CACHE BITS FROM
	MOVEI	T2,FYSORG-1	; SYSSIZ - 112K FOR LOCK/REAL TIME
	CAMG	T1,T2
	PUSHJ	P,CCBRNG(P2)
IFN FTLOCK,<
	SKIPN	[LOKINC##](P2)	;LOCK UUO INCLUDED AT MONGEN TIME?
	JRST	KIIN14(P2)	;NO, SKIP ON
	MOVEI	T1,EVLN##	;NUMBER OF PAGES AVAILABLE FOR LOCKING IN EVM
	MOVEM	T1,.C0EVM##	;STORE THAT FOR USER'S REFERENCE
	SETZM	.C0EVU##	;NUMBER OF PAGES IN USE FOR LOCKING IN EVM
>
KIIN14:
				;SET UP TAIL TABLE FOR NZS AND ONCE FREE CORE
	MOVE	T1,[NZSFCH##,,NZSFCE##](P2)	;SET UP END TABLE
	MOVEI	T2,NZSFCL##-1(T1)	;END OF TABLE
	BLT	T1,(T2)
	MOVEI	T1,0		;USER APR ENABLE BITS
IFE FTXMON,<
	PJRSTF	@[EXP IC.UOU+SETCNA##](P2)	;LIGHT USER IOT IN THE PC AND
				; SETUP APR ENABLE BITS AND CONSO MASK
>
IFN FTXMON,<
	XJRSTF	[IC.UOU
		 0,,SETCNA##](P2)	;SAME BUT ENTER SECTION 0
>
SUBTTL RTTRP INITIALIZATION
IFN FTRTTRP,<
;RTINI IS THE INITIALIZATION ROUTINE TO SET UP THE RT BLOCKS.
;IT IS CALLED EVERY TIME A 140 OR 143 RESTART IS DONE.
;THE FIRST TIME THROUGH RTINI, CHAINT IS LOADED WITH THE
;VALUES OF T4'PI+1.  THIS IS USED TO RESTORE THE PI CHAINS
;ON A 140 RESTART.
;THE RT BLOCK AREA IS ZEROED AND ALL OF THE BLOCKS
;ARE PUT ON THE FREE LIST.


RTINI:	PUSHJ	P,LOADTB(P2)	;FIRST TIME THROUGH, LOAD CHAINT
	MOVE	T1,[JRST RTINI1(P2)](P2)	;CHANGE FLOW OF PROGRAM
	MOVEM	T1,RTINI(P2)	;TO AVOID CALL TO LOADTB
RTINI1:	MOVEI	T1,.C0CDB##
RTINI2:	HRLI	T1,-6
INILOP:	MOVE	T2,.CPRIT##-.CPCDB##(T1)
	SKIPE	T3,.CPRCT##-.CPCDB##(T1)
	MOVEM	T2,1(T3)
	AOBJN	T1,INILOP(P2)
	HLRZ	T1,.CPCDB##-.CPCDB##-6(T1)
	JUMPN	T1,RTINI2(P2)
	SETZM	RTBLK##		;SET UP TO ZERO RTBLOCK AREA
	MOVE	T1,[XWD RTBLK##,RTBLK+1](P2)
	MOVEI	T2,RTBSIZ##	;GET LENGTH OF A BLOCK
	IMULI	T2,RTTRPN##	;CALCULATE LENGTH OF RT BLOCK AREA
	BLT	T1,RTBLK##-1(T2) ;ZERO THE AREA
	MOVEI	T1,RTBLK##	;NOW LINK THE BLOCKS TOGETHER
	MOVEI	T2,RTTRPN##	;GET NUMBER OF BLOCKS AVAILABLE
	MOVEM	T1,RTLINK##	;SET UP FIRST ENTRY
INILP1:	MOVEI	T3,RTBSIZ##(T1)	;GET ADDRESS OF NEXT BLOCK
	MOVEM	T3,(T1)		;STORE IN CURRENT BLOCK
	EXCH	T3,T1		;GET NEXT BLOCKADR IN T1
	SOJG	T2,INILP1(P2)	;GO FINISH LOOP
	SETZM	(T3)		;MAKE THE LAST BLOCK IN LIST HAVE 0 POINTER
	MOVEI	T1,.C0CDB##
INILP3:	SETZM	.CPRTT##-.CPCDB##(T1)
	HRLI	T1,-6
INILP4:	SKIPE	T2,.CPRCT##-.CPCDB##(T1)
	TLNN	T2,BLKENB##
	JRST	INILP5(P2)
	HRLI	T2,BLKENB##+400000
	MOVEM	T2,.CPRCT##-.CPCDB##(T1)
INILP5:	AOBJN	T1,INILP4(P2)
	HLRZ	T1,.CPCDB##-.CPCDB##-6(T1)
	JUMPN	T1,INILP3(P2)
	MOVSI	T1,MJOBN##	;GET NEGATIVE JOB NUMBER
	SETZM	JBTRTD##(T1)	;CLEAR OUT TABLE
	AOBJN	T1,.-1(P2)	;DO REST OF TABLE
	POPJ	P,		;RETURN
LOADTB:	MOVEI	T1,.C0CDB##
LOADT1:	HRLI	T1,-6
LOADT2:	SKIPE	T2,.CPRCT##-.CPCDB##(T1)
	MOVE	T2,1(T2)
	MOVEM	T2,.CPRIT##-.CPCDB##(T1)
	AOBJN	T1,LOADT2(P2)
	HLRZ	T1,.CPCDB##-.CPCDB##-6(T1)
	JUMPN	T1,LOADT1(P2)
	POPJ	P,		;RETURN
>	;END CONDITIONAL ON RTTRP
SUBTTL LOKCON INITIALIZATION
IFN FTLOCK,<
;CALLED FROM SYSINI ON 140 RESTARTS
;UNLOCKS ALL JOBS AND FREES UP THE CORE THEY OCCUPY



LOKINI:	SKIPN	J,LOCK##	;WAS A JOB BEING LOCKED ON THE RESTART?
	JRST	LOKI00(P2)	;NO
	SKIPN	JBTADR##(J)	;WAS IT BEING MOVED?
	STOPCD	.,HALT,JIT,	;++JOB IN TRANSIT
	SETZM	LOCK##		;SIGNAL NO JOB IS BEING LOCKED
LOKI00:	MOVEI	J,JBTMAX##	;UNLOCK ALL LOCKED JOBS
LOKI10:	MOVE	T1,JBTSTS##(J)	;IS THIS SEGMENT LOCKED?
	TLNE	T1,NSHF!NSWP
	PUSHJ	P,UNLOCK##	;YES, UNLOCK IT
	SOJG	J,LOKI10(P2)	;LOOK AT ALL SEGMENTS
LOKLIM::HRREI	T1,LOKMAX##	;SET GUARANTEED CORE FOR T-S JOBS
				;MODIFIED BY ONCE
	JUMPL	T1,LOKI20(P2)
	ASH	T1,P2WLSH##	;MAKE PAGES INTO WORDS
	CAML	T1,MEMSIZ##
LOKI20:	MOVE	T1,CORMAX##	;CORMIN_CORMAX
	MOVEM	T1,CORMIN##	;SAVE IT FOR TESTING
	MOVE	T1,SYSSIZ##	;INITIALIZE SIZE OF LARGEST CONTIGOUS HOLE
	MOVEM	T1,HOLEF1##	;TOP
	POPJ	P,		;RETURN
>	;END CONDITIONAL ON FTLOCK
SUBTTL PTYSER INITIALIZATION
;INITIALIZATION CODE. CALLED ON SYSTEM STARTS AND RESTARTS.
;CALLED BY PUSHJ FROM IOGO, WITH F SET UP.
;GIVE NON-SKIP RETURN SINCE ONLY WANT TO BE CALLED ONCE FOR ALL PTYS
;MUST RESPECT P3
;DDB'S EXIST AND HAVE 0 IN IOS.


PTYINI::MOVNI	T1,M.PTY##	;COMPUTE NUMBER OF PTY DDB'S
	HRLZS	T1		;MAKE AOBJN COUNTER
	MOVEI	F,PTYLST##	;FIRST IN LIST OF PTY DDB'S
PTYIIL:	MOVEM	F,PTYTAB##(T1)	;MAKE UP TABLE OF PTY DDB ADDRESSES
	MOVEI	T2,DEPEVM	;GET "DEVICE DOESN'T NEED EVM" BIT
	IORM	T2,DEVTYP(F)	;SET BIT
	HLRZ	F,DEVSER(F)	;FOLLOW CHAIN TO NEXT ONE.
	AOBJN	T1,PTYIIL(P2)	;GO STORE NEXT IF STILL A PTY
	POPJ	P,0		;DONE. RETURN TO IOGO
SUBTTL SCNSER INITIALIZATION

;CODE CALLED ON A 140 RESTART. CLEAR ANY UUO-LEVEL ACTIVITY, AND ALL
; LINKED CHARACTER BUFFERS AND THEIR POINTERS IN THE LDB'S.
;RE-INITIALIZES ALL OF TTCLST TO BE BLANK AND ALL LINKED TO TTFREE.

;CALLED BY PUSHJ FROM IOGO, WITH F SET UP.
; GIVE NON-SKIP RETURN, SINCE DON'T NEED TO CALL THIS ROUTINE AGAIN
; FOR EVERY TTY DDB
;MUST RESPECT P3
;DEVICE DATA BLOCKS EXIST, AND HAVE BEEN CLEARED TO 0 IN DEVIOS.


IFNDEF FTGPO2B,<XP FTGPO2B,0>	;MUST AGREE WITH SCNSER
CTY=120	;HARDWARE DEVICE NUMBER OF THE KA10 CONSOLE TTY

TTYINI::SE1ENT			;ENTER SECTION 1
	CONO	PI,PI.OFF

;HERE TO INITIALIZE SCNSER BUFFER SPACE (CHUNKS)
;

	MOVEI	T1,COMTIV	;GET ADDRESS OF THE INPUT CONTROL VECTOR
	MOVEM	T1,.CPTIV##	;  SO CALLS TO STOPCM WORK OK.
	HRRZ	T1,TTCLST##	;FWA STRING SPACE
	MOVEM	T1,TTBASE##	;SAVE
	HRLI	T1,(MS.SCN)	;DATA BASE SECTION
	SETZM	(T1)		;CLEAR FIRST WORD
	MOVEI	J,1(T1)		;
	HRLI	J,(T1)		;BLT POINTER
	HLRZ	T3,TTCLST##	;NUMBER OF CHUNKS
	IMULI	T3,TTCHKS##	;TIMES SIZE OF ONE
	MOVE	T2,T3		;NUMBER OF WORDS IN THE CHUNKS
	ADDI	T3,-1(T1)	;LAST WORD OF CHUNKS
IFN FTKS10,<
	BLT	J,(T3)		;CLEAR
>
IFN FTKL10,<
	EXCH	T1,T2		;T1=# OF WORDS TO CLEAR, T2=SA
	SOS	T1		;ONE WORD WAS ALREADY CLEARED
	MOVE	T3,T2
	AOS	T3		;DESTINATION ADDRESS
	EXTEND	T1,[XBLT](P2)	;ZERO ALL OF THE CHUNKS
	SUBI	T3,1		;BACK OFF TO END OF CHUNKS
>
	HRRZM	T3,RCCMAX##

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVEI	J,TTFTAK##	;LOC OF START OF CHAIN
IFN FTKL10,<
	HRRZ	T1,TTCLST##	;GET BACK SECTION RELATIVE START OF CHUNKS
	TLOA	T1,(MS.SCN)	;LIGHT SECTION BIT AND SKIP FIRST TIME
>
TTII4L:	HRLI	J,(MS.SCN)	;SECTION WHERE THE CHUNKS LIVE
	MOVEM	T1,(J)		;STORE POINTER TO THIS CHUNK
	HRRZS	J,T1		;ADVANCE PREVIOUS PTR
	ADDI	T1,TTCHKS##	;ADVANCE TO NEXT
	CAIGE	T1,(T3)		;REACHED THE END?
	JRST	TTII4L(P2)	;NO, CONTINUE
	HRLI	J,(MS.SCN)	;SET SECTION NUMBER
	MOVEM	J,TTFPUT##	;NOTE END OF CHAIN
	HLRZ	T1,TTCLST##	;CHUNK COUNT
	SUBI	T1,^D10		;SAFETY FACTOR
	MOVEM	T1,TTFREN##	;SAVE FOR ALLOCATION ROUTINES

;NOW CLEAR THE RECINT CHARACTER QUEUE

	SETZM	RCQCNT##	;NO CHARACTERS QUEUED
	MOVEI	T1,RCQBEG##	;START OF THE QUEUE
	MOVEM	T1,RCQPTR##	;INIT THE QUEUE PUTTER
	MOVEM	T1,RCQTKR##	;AND THE QUEUE TAKER AS WELL
;INITIALIZE LINE DATA BLOCKS (ASSUMED TO EXIST, POINTED TO BY LINTAB,
; BUT NOT TO CONTAIN ANYTHING USEFUL EXCEPT LDPLNO AND SOME OF LDBDCH)

	MOVSI	J,MTTYLN##	;MINUS LENGTH OF LINTAB, I.E., THE
				; SCANNER(S), CTY, PTY'S, AND REMOTES
TTII1L:	MOVE	U,LINTAB##(J)	;GET ADDRESS OF LINE DATA BLOCK
	DPB	J,LDPLNO##	;STORE LINE NUMBER
IFN FTKS10,<
	MOVSI	T1,LDICLR##(U)	;CLEAR OUT ALL POINTERS AND T2'S
	HRRI	T1,LDICLR##+1(U) ;IN THE LDB POINTER AREA
	SETZM	LDICLR##(U)	; ..
	BLT	T1,LDICLE##(U)	;..
>
IFN FTKL10,<
	MOVEI	T1,LDICLE##-LDICLR##
	MOVEI	T2,LDICLR##(U)
	HRLI	T2,(MS.SCN)
	MOVEI	T3,LDICLR##+1(U)
	HRLI	T3,(MS.SCN)
	SETZM	LDICLR##(U)
	EXTEND	T1,[XBLT](P2)
>
	SETZM	LDBPAG##(U)	;CLEAR LPLPOK TOO
	PUSHJ	P,LDBINI##	;CALL ROUTINE WHICH CLEARS IT UP
	AOBJN	J,TTII1L(P2)	;LOOP FOR ALL LDB'S
	MOVEI	T1,TCONLN##-CPUN## ;IN CASE JUNK GOT IN LINSAV
	MOVEM	T1,LINSAV##
	MOVEI	T1,COMTIV##	;SET UP COMMAND INPUT
	MOVEM	T1,.CPTIV##	;  DISPATCH VECTOR
	MOVEI	T1,CCTYO##	;FOR INPUT AND OUTPUT
	MOVEM	T1,.CPTOA##	; ..

;NOW GO THROUGH ALL THE TTY DDB'S VIA CHAIN, AND KILL ALL THOSE WHICH
; HAVE TTYATC AND ASSCON OFF, BY CALLING TTYREL

	SETOM	DINITF##	;TTYREL BEING CALLED FROM SYSINI
	MOVEI	F,TTYLST##	;FIRST TTY DDB IN DEVICE CHAIN
TTII2L:	PUSHJ	P,TTYREL##	;TTYREL WILL KILL IT (TTYKIL)
				; UNLESS TTYATC OR ASSCON ARE ON
	MOVEI	T2,DEPEVM	;GET "DEVICE DOESN'T NEED EVM" BIT
	IORM	T2,DEVTYP(F)	;SET BIT
	HLRZ	F,DEVSER(F)	;DO SAME FOR ALL TTY DDB'S
	MOVSI	T1,DVTTY	;IS THIS A TTY TOO?
	TDNE	T1,DEVMOD(F)	;CHECK IN DEVICE MODE WORD
	JUMPN	F,TTII2L(P2)	;JUMP IF YES.
;NOW CLEAR ANY PHONY LINKS IN THE LDB'S. I.E., ANY WHICH THINK
; THEY ARE POINTING TO DDB'S BUT THE DDB'S HAVE BEEN KILLED (TTYUSE=0)


	MOVSI	J,MTTYLN##	;COUNT OF LDB'S
TTII3L:	MOVE	U,LINTAB##(J)	;GET LDB ADDRESS
	PUSHJ	P,LDBCLR##	;NO DDB. CLEAR THIS LDB FROM THE TOP.
	MOVE	T1,LDBDCH##(U)	;GET DEVICE BITS
	MOVE	T2,LDBTTW##(U)	;GET LINE TYPE FLAGS
	TLNE	T2,LTLUSE##	;IS LDB "IN USE"?
	TRNE	T1,LDRPTY##	;YES, BUT IS IT A PTY-DRIVEN LINE?
	JRST	TTII3N(P2)	;LDB NOT IN USE (OR PTY), SKIP THIS LINE
	HRRZ	T1,J		;GET LINE # IN T1
	PUSHJ	P,XTCTTY##	;SEE IF DA28
	  JRST	TTII3N(P2)	;INACTIVE - IGNORE
	  JFCL			;ACTIVE - TREAT AS REGULAR
	MOVEI	T1,TTFCXI##	;YES, SET FOR STARTUP CUSP
	SKIPE	TTFCOM##+TTFCXI## ;STARTUP OPTION "N"?
	SKIPE	REFLAG##	;BUT IF DISK IS BEING REFRESHED?
	MOVEI	T1,TTFCXR##	;JUST GIVE NORMAL MESSAGE
	PUSHJ	P,TTFORC##	;FORCE THIS COMMAND
TTII3N:	AOBJN	J,TTII3L(P2)	;DO SAME FOR ALL LDB'S
	MOVE	T1,[CLKCMD##,,JIFSEC##*^D10](P2)
	IDPB	T1,CLOCK##	;IN 10 SECONDS
	MOVEI	T1,1		;SET TO SMASH COMCNT
	SKIPE	TTFCOM##+TTFCXI##
	EXCH	T1,COMCNT##	;GET NUMBER TO DO
	IDPB	T1,CLOCK##	;DO THEM IN 10 SECONDS
	MOVE	T1,[SIXBIT/INITIA/](P2)
	MOVEM	T1,TTFCOM##+TTFCXI##
	SKIPN	T1,DEVOPR##	;SET UP OPERATOR FOR ERROR MESSAGES
TTIOP1:	MOVSI	T1,(SIXBIT /CTY/) ;IF NONE, ASSUME CTY.
	PUSHJ	P,STDOPR##	;GET A DDB AND LDB FOR OPR AND SET OPRLDB
	  JRST	TTIOP1(P2)	;NO SUCH GUY. TRY CTY.
				; DONT REALLY WANT IT NOW
	SETZM	DINITF##	;DONE WITH TTYREL
;NOW INITIALIZE THE DATAPHONE HANDLING TABLE


	SKIPL	J,DSCPTR##	;GET THE DATAPHONE INDEX, IF ANY
	JRST	TTIDSX(P2)	;NONE IN THIS CONFIGURATION
	SETOM	TTYDDL##	;CLEAR TTY DIALLER DATA ADDRESS CELL (4 WD BLOCK)

	HLLZS	J		;CLEAR RIGHT HALF OF POINTER
TTIDSL:	MOVEI	T3,DSTREQ##	;TRANSACTION CODE FOR REQUEST
	MOVE	U,DSCTAB##(J)	;SET UP BACK POINTERS TO DATASET TABLE
	MOVE	U,LINTAB##(U)	;IN THE LDB'S
	DPB	J,LDPDSC##	;STORE THE INDEX
;CAN'T BELIEVE THE CARRIER FLAG ON A GPO 2B MODEM, SO MUST CLEAR IT FROM LINE
	MOVEI	U,0(J)		;TABLE INDEX AS LINE NUMBER
	PUSHJ	P,DSCCAL##	;GO GET STATE OF LINE
	CAIN	T3,DSTNAC##	;DC76 NO-ACTION?
	JRST	TTIDSN(P2)	;YES.  DC76 WILL TELL US ABOUT ALL LINES
				; (MAY HAVE ALREADY)
	CAIN	T3,DSTON##	;IS CARRIER ON?
	JRST	TTIDS1(P2)	;YES. GO SET ON STATE IN TABLE
	MOVSI	T1,DSCICL##	;HWC+SWC+FAI+TMM
	ANDCAM	T1,DSCTAB##(J)	;CLEAR ALL BITS. HE'S OFF
	MOVEI	T3,DSTOFF##	;SEND OFF CODE IN CASE WAS ON
	MOVEI	U,0(J)		;USING TABLE INDEX AS LINE
	PUSHJ	P,DSCCAL##	;SEND THE OFF CODE
TTIDSN:	AOBJN	J,TTIDSL(P2)	;COUNT THRU ALL DATAPHONES
	JRST	TTIDSX(P2)	;END OF TABLE

TTIDS1:	MOVSI	T1,DSCIC1##	;LINE IS ON. SET HWC+SWC BITS IN TABLE
	IORM	T1,DSCTAB##(J)	; ..
	MOVSI	T1,DSCIC2##	;AND CLEAR FAIL AND TIME BYTE TMM+FAI
	ANDCAM	T1,DSCTAB##(J)	; ..
	JRST	TTIDSN(P2)	;ON TO NEXT LINE

TTIDSX:!					;END OF ROUTINE

	MOVEI	J,TCONLN##	;START WITH CTY
TTII0L:	MOVEI	T1,ISRINI	;FUNCTION TO INIT A LINE
	MOVE	U,LINTAB##(J)	;POINT TO LDB
	DPB	J,LDPLNO##	;MAKE SURE LDPLNO SET UP
	PUSH	P,J
	PUSHJ	P,@LDBISR##(U)	;INIT THE LINE
	POP	P,J
	SOJGE	J,TTII0L(P2)	;LOOP OVER ALL LINES
				; HARDWARE FIRST, SINCE PI IS OFF
	CONO	PI,PI.ON
	POPJ	P,0		;END OF TTYINI
;SUBROUTINE TO MARK AND LINK PAGTAB FOR THE PHYSICAL PAGES ALLOCATED TO
;	THE MONITORS HIGH SEGMENT ( OR AT LEAST THINGS ABOVE 400000 )

;CALL:	T1 = VIRTUAL ADDRESS OF FIRST PAGE TO ACCOUNT FOR
;	T3 = LAST PAGE ACCOUNTED FOR ( RETURNED BY THIS ROUTINE )
;	T4 = NUMBER OF PAGES TO LOOK AT
;
;RETURNS T3 = SET UP FOR ANY SUBSEQUENT CALL
;ALSO WRITE PROTECTS THE HIGH SEGMENT ON THE WAY THROUGH UNLESS PM.SWB
;	IS LIT IN THE PAGE MAP ENTRY.

;THE SCREWY CONVENTIONS HAPPENED TO FALL OUT OF THE WAY KIINI USED TO WORK

SETMRB:	LSH	T1,W2PLSH##
SETMRR:	ADD	T1,.CPMAP##
SETMRP:	HRLI	T1,(POINT 36,0)
SETMR1:	ILDB	T2,T1		;GET PHYSICAL PAGE CONTAINING THE MONITOR
	JUMPE	T2,SETMR2(P2)	;OK IF NOT ALLOCATED
WRTLOK:	SKIP	DEBUGF##	;PATCH TO SKIPL IF DEBUGGING WITH MONITOR WRITE-ENABLED
	CAIA
	TDO	T2,[PM.SWB](P2)	;IF DEBUGING, DON'T WRITE LOCK
	TDZN	T2,[PM.SWB](P2)	;SKIP IF PAGE SHOULD BE WRITE ENABLED
	TDZ	T2,[PM.WRT](P2)	;CLEAR WRITE ENABLE
	DPB	T2,T1		;STORE IT BACK IN THE MAP
	TLNE	T2,(<PM.ACD>B2^!<PM.DCD>B2) ;ANYTHING BESIDES DIRECT POINTER?
	JRST	SETMR2(P2)	;YES, OTHER POINTERS USE SPT INDICES, SKIP THEM
	ANDI	T2,17777	;CLEAR THE ACCESS BITS
	TLO	T2,MONTRB	;INDICATE THIS PHYSICAL PAGE CONTAINS THE MONITOR
	MOVEM	T2,PAGTAB(T3)	; IN PAGTAB
	SSX	T2,MS.MEM
	HRRZM	T3,PT2TAB(T2)	;SET BACK LINK
	HRR	T3,T2		;SAVE LAST MONITOR PAGE SEEN
SETMR2:	SOJG	T4,SETMR1(P2)	;LOOP OVER ALL THE MONITORS PAGES
	MOVSI	T2,MONTRB	;IN CASE SOME PAGES WERE SKIPPED (T2=0)
	MOVEM	T2,PAGTAB(T3)	;INDICATE THE LAST PAGE OF THE MONITOR
	HRRZM	T3,LMPAG##	;..
	POPJ	P,


;SUBROUTINE TO MARK PAGES IN PAGTAB WITH THE "PHYSICALLY CONTIGUOUS" BIT.
;CALL:
;	T1/ STARTING PHYSICAL PAGE NUMBER
;	T2/ NUMBER OF PAGES
;	PUSHJ	P,SETCTB(P2)
;RETURN:
;	CPOPJ ALWAYS

SETCTB:	SSX	T1,MS.MEM	;THE PAGTAB SECTION
	MOVSI	T3,CONTGB	;THE BIT WE LIKE
SETCT1:	IORM	T3,PAGTAB(T1)	;LIGHT IT FOR THIS PAGE
	SOJLE	T2,CPOPJ##	;RETURN IF NO MORE PAGES TO MARK
	AOJA	T1,SETCT1(P2)	;ELSE LOOP FOR THE NEXT PAGE
;ROUTINE TO SET OR CLEAR CACHE BITS FOR A RANGE OF EXEC ADDRESSES.
; THE RANGE IS C(T1)R THROUGH C(T2)R INCLUSIVE.
; USES ALL T ACS, AC U WITHOUT RESTORING THEM. ORIGINAL ARGUMENTS
; IN T1 AND T2 ARE LOST.
; ARGUMENTS MUST NOT BE IN PER-PROCESS SPACE

IFN FTMP,<
CCTRNG:	PUSHJ	P,SAVE1##	;NEED P1
	MOVE	P1,[TLO	T2,TNCSHB](P2) ;SET TEMPORARY
	MOVE	U,[TLZ T1,(PM.CSH)](P2)	;CLEAR CACHE BIT
	JRST	CCBRN1(P2)	;JOIN CODE
>
CSBRNG:	SKIPA	U,[TLO T1,(PM.CSH)](P2)	;CLEAR CACHE BIT
CCBRNG:	MOVE	U,[TLZ T1,(PM.CSH)](P2)	;CLEAR CACHE BIT
IFN FTMP,<
	PUSHJ	P,SAVE1##
	MOVE	P1,[TLZ	T2,TNCSHB](P2) ;CLEAR TEMPORARY BIT
>
CCBRN1:	LSH	T2,W2PLSH##	;CONVERT TO PAGES
	LSH	T1,W2PLSH##
	HRRZ	T3,T1		;SAVE STARTING VIRTUAL PAGE
	MOVEI	T4,(T1)
	ADD	T4,.CPMAP##
CCTRNS:	HRLI	T4,(POINT 36,0)
CCBRN2:	ILDB	T1,T4		;GET CONTENTS OF SLOT
	JUMPE	T1,CCBRN3(P2)
	XCT	U		;SET OR CLEAR CACHE BIT ACCORDINGLY
	DPB	T1,T4		;AND PUT IT IN MAP
IFN FTMP,<
	ANDI	T1,17777	;GET PHYSICAL PAGE NUMBER
	SSX	T1,MS.MEM	;SECTION NUMBER
	EXCH	T2,PAGTAB(T1)	;GET ENTRY, SAVE T2
	TLNE	T2,MONTRB	;A MONITOR PAGE
	XCT	P1		;YES, SET/CLEAR TEMPORARY UNCACHED
	EXCH	T2,PAGTAB(T1)	;STORE NEW SETTING, RESTORE T2
>
CCBRN3:	CAIE	T3,(T2)		;DID WE JUST DO LAST PAGE?
	AOJA	T3,CCBRN2(P2)	;LOOP, WE HAVE MORE TO DO.
	POPJ	P,		;YES, BYE.
;SUBROUTINE TO SELECT PHYSICAL AND VIRTUAL ADDRESS FOR SPACE IN HIGH SEGMENT

;CALL:	MOVEI	T1,NUMBER-OF-WORDS-NEEDED
;	MOVEI	T2,PAGE-MAP-ACCESS-BITS-DESIRED
;NOTE THE USE OF T4 AS A RELOCATION REGISTER

ONCMAP::
IFN FTKL10,<
	IOR	T2,.CPKPM##	;LITE "KEEP ME" IF THE CPU HAS AN MCA25
>
	PUSH	P,P1		;SAVE P AC'S
	PUSH	P,P2		;...
	PUSH	P,P3		;...
	PUSH	P,P4		;...
	MOVE	T3,BOOTCP##	;BOOT CPU NUMBER
	LSH	T3,.CPSOF##	;OFFSET INTO BOOT CPU'S CDB
	PUSH	P,.C0MAP##(T3)	;ADDRESS OF THE BOOT CPU'S MAP
	HRRZ	T4,SYSINA##	;SET RELOCATION REGISTER
	SUBI	T4,SYSINI	;...
	ADDI	T1,PG.BDY##	;ROUND UP AMOUNT OF WORDS REQUESTED
	TRZ	T1,PG.BDY##	; TO FULL PAGES
	MOVE	T3,T1		;COPY NUMBER OF WORDS
	LSH	T3,W2PLSH##	;CONVERT TO PAGES NEEDED
	ADDB	T1,MONVFF##	;UPDATE FIRST FREE
	LSH	T1,W2PLSH##	;TO VIRTUAL PAGE NUMBER
	SOS	T1		;T1 = HIGHEST PAGE TO BE ALLOCATED NOW
	TRNE	T1,777000	;BETTER BE .LT. 256K
	STOPCD	.,STOP,OVA,	;++ OUT OF VIRTUAL ADDRESS SPACE
	MOVE	P1,SYSORG##	;GET WHERE TO START ALLOCATING PHYSICALLY
	LSH	P1,W2PLSH##	;CONVERT THAT TO PAGE NUMBER
	SOS	P2,P1		;P1 = WHERE TO START
	TDO	P1,T2		;P1 = MAP SLOT CONTENTS TO STORE
	IDIVI	P2,^D36		;COMPUTE BIT IN NXMTAB FOR THIS PAGE
	MOVNS	P3		;BIT POSITION
	MOVSI	P4,400000	;GET A BIT TO TEST
	LSH	P4,(P3)		;POSITION IT CORRECTLY IN WORD
ONCMA1:	TDNN	P4,NXMTAB##(P2)	;DOES THIS PAGE EXIST
	JRST	ONCMA3(T4)	;YES, SET UP THE MAP
ONCMA2:	SKIPG	P4		;NO, NEXT PAGE (SKIP IF ON A PAGE BOUNDRY)
	SOS	P2		;ON A WORD BOUNDRY, BACK UP ONE
	ROT	P4,1		;NEXT BIT IN NXMTAB
	SOJA	P1,ONCMA1(T4)	;SEE IF THAT EXISTS
ONCMA3:	ADD	T1,(P)
	MOVEM	P1,(T1)
	SUB	T1,(P)
	SOS	T1		;BACK DOWN 1 PAGE
	SOJG	T3,ONCMA2(T4)	;AND CONTINUE IF MORE PAGES TO MAP
	CLRPGT	(0)		;LET HARDWARE SEE THE CHANGES
	ANDI	P1,17777	;LOWEST PAGE MAPPED
	LSH	P1,P2WLSH##	;BACK TO WORDS
	MOVEM	P1,SYSORG##	;STORE FOR NEXT TIME THROUGH
	POP	P,(P)		;POP OFF JUNK
	POP	P,P4		;NOW RESTORE ACS
	POP	P,P3		;...
	POP	P,P2		;...
	POP	P,P1		;...
	POPJ	P,


;LIT AND VAR
XLIST
LIT
VAR
LIST


ENDSYL==:ENDSYS-SYSINI
ENDSYS::END			;STARTING ADDRESS OF MONITOR ON NORMAL LOADING
  & a