TITLE	TMPUUO -- TEMPORARY FILE STORAGE UUO - V031
SUBTTL	TONY LAUCK/TL/CDO  10 SEP 85
	SEARCH	F,S
	$RELOC
	$HIGH



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
.CPYRT<1973,1986>
;COPYRIGHT (C) 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986
;BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;ALL RIGHTS RESERVED.
;
;
;
XP VTMPUU,031		;PUT VERSION NUMBER IN GLOB AND MAP

REPEAT 0,<
		TEMPORARY FILE STORAGE FOR JOB UUO.

	THE "TMPCOR" UUO IS USED TO ENABLE A JOB TO LEAVE SEVERAL SHORT
FILES IN CORE FROM THE RUNNING OF ONE USER PROGRAM OR CUSP TO THE
NEXT. THESE FILES MAY BE REFERRED TO BY A THREE CHARACTER FILE NAME,
AND ARE UNIQUE TO EACH JOB, I.E. A JOB CAN ONLY REFERENCE ITS OWN
FILES. ALL FILES ARE ALWAYS DELETED WHEN A JOB IS KILLED.

	EACH FILE APPEARS TO THE USER AS ONE DUMP MODE BUFFER. THE ACTUAL SIZE OF A
TEMPORARY FILE, THE NUMBER OF TEMPORARY FILES A USER CAN HAVE,
AND THE TOTAL CORE SPACE A USER CAN TIE UP ARE PARAMETERS DETER-
MINED AT MONGEN TIME. ALL TEMPARARY FILES RESIDE IN A FIXED AREA
IN THE MONITOR, BUT THE SPACE IS DYNAMICALLY ALLOCATED AMOUNG
DIFFERENT JOBS AND THE SEVERAL DIFFERENT FILES OF ANY GIVEN JOB.

	THE PRIMARY PURPOSE OF THE TEMPORARY STORAGE SYSTEM IS FOR SHORT
CONTROL FILES, E.G. CCL FILES, TO LIVE IN CORE, THEREBY SPEEDING
UP RESPONSE TIMES AND REDUCING DISK OPERATIONS. ACCORDINGLY, 
SHOULD A PROGRAM ATTEMPT TO WRITE A FILE WHEN THERE IS 
INSUFFICIENT SPACE, EITHER IN THE ENTIRE BUFFER AREA OR BECAUSE
THE USER HAS EXCEEDED HIS QUOTA, THE UUO GIVES AN ERROR RETURN.
THE CUSP CAN THEN WRITE THE DATA AS A SHORT DISK FILE.
SIMILARLY, SHOULD A PROGRAM FAIL TO FIND A FILE UPON READING IT,
IT WILL GET AN ERROR RETURN AND CAN THEN LOOKUP A SHORT DISK FILE.

	IT IS VERY IMPORTANT TO REALIZE THE TEMPORARY NATURE OF THESE
FILES. FOR EXAMPLE, UPON WRITING, THE OLD FILE IS DELETED BEFORE
CHECKING FOR SPACE FOR A NEW VERSION. THE OLD FILE COULD BE LOST WITHOUT
A NEW ONE REPLACING IT. ALSO, THERE CAN BE NO GUARANTEE THAT FILES
WILL FIT IN CORE.
>
	REPEAT	0,<
	FORMAT	OF TEMPORARY FILE STORAGE UUO.

	CALL	AC, [SIXBIT /TMPCOR/]	;CALLI INDEX=44
	;ERROR RETURN
	;NORMAL RETURN

	C(AC) MUST ALWAYS BE SET UP BY THE USER PROGRAM PRIOR TO EXECUTING
THE UUO. IT IS CHANGED BY THE UUO AND RETURNS A VALUE THAT DEPENDS
ON THE PARTICULAR FUNCTION PERFORMED.

	C(AC) = XWD CODE,BLOCK

BLOCK:	XWD	NAME,0		;NAME IS FILE NAME
	IOWD	BUFLEN,BUFFER	;USER BUFFER AREA (ZERO  FOR NO BUFFER)
>
	REPEAT	0,<
		CODE-0	--  GET FREE SPACE

	THE	IS THE ONLY FORM OF THE TEMP UUO THAT DOES NOT USE A TWO
WORD PARAMETER BLOCK. C(AC) WOULD ORDINARLY BE SET TO ZERO FOR THE
GET FREE SPACE UUO. THE USER PROGRAM ALWAYS GETS A NORMAL RETURN
(UNLESS THE SYSTEM DOES NOT HAVE THE TEMP UUO). C(AC) IS SET TO
THE NUMBER OF WORDS OF FREE SPACE AVAILABLE TO THE USER.


		CODE=1	--  READ FILE

	IF	THE SPECIFIED FILE NAME IS NOT FOUND, C(AC) IS SET TO THE
NUMBER OF FREE WORDS OF SPACE AVIALABLE FOR TEMP FILES, AND THE
ERROR RETURN IS TAKEN.

	IF	THE FILE IS FOUND, C(AC) IS SET TO THE LENGTH OF THE
FILE IN WORDS, AND AS MUCH OF THE FILE AS WILL FIT IS COPIED INTO
THE USERS BUFFER. THE USER CAN CHECK FOR TRUNCATION BY COMPARING
C(AC) WITH BUFLEN UPON SUCCESSFUL RETURN FROM THE TEMP UUO.


		CODE=2	--  READ AND DELETE FILE

	THIS	IS THE SAME AS CODE=1, EXCEPT THAT IF A FILE WAS FOUND
IT IS ALSO DELETED AND ITS SPACE RECLAIMED.
>
	REPEAT	0,<
		CODE=3	--  WRITE FILE

	IF	THERE IS ALREADY A FILE OF THE SPECIFIED NAME, IT IS
DELETED AND ITS SPACE IS RECLAIMED.

	THE	REQUESTED SIZE OF THE FILE IS SPECIFIED BY BUFLEN. 
IF THERE IS NOT ENOUGH SPACE TO WRITE THE ENTIRE FILE, NOTHING
IS WRITTEN, C(AC) IS SET TO THE NUMBER OF FREE WORDS OF SPACE 
AVAILABLE TO THE USER, AND THE ERROR RETURN IS TAKEN.

	IF	TIS ENOUGH SPACE, THE FILE IS WRITTEN. C(AC) IS SET TO
THE AMOUNT OF SPACE LEFT AFTER THE FILE HAS BEEN WRITTEN AND THE
NORMAL RETURN IS TAKEN. FILES ARE ALWAYS FILLED UP WITH ZEROS TO THE
NEXT EVEN MULTIPLE OF THE BLOCK LENGTH (TMPBL).
	THIS	EVEN LENGTH IS READ BACK IN.


		CODE=4	--  READ DIRECTORY

	THE	ERROR RETURN IS NEVER TAKEN.

	C(AC) IS SET TO THE NUMBER OF DIFFERENT FILES IN THE JOB'S
TEMPORARY FILE AREA. IN ADDITION, AN ENTRY IS MADE FOR EACH FILE
IN THE USER BUFFER AREA UNTIL THERE IS NO MORE SPACE OR ALL FILES HAVE
BEEN LISTED. THE USER PROGRAM CAN CHECK FOR TRUNCATION BY COMPARING
C(AC) UPON RETURN WITH BUFLEN.

	DIRECTORY ENTRY FORMAT
	XWD  NAME,SIZE	;NAME=FILE NAME, SIZE =FILE LENGTH IN WORDS.


		CODE=5	--  READ AND CLEAR DIRECTORY

	THIS	IS THE SAME AS CODE=4 EXCEPT THAT ANY FILES IN THE JOB'S
TEMPORARY STORAGE AREA ARE ALSO DELETED AND THEIR SPACE RECLAIMED.

	THIS	UUO IS EXECUTED BY THE LOGOUT CUSP.
>
	REPEAT	0,<
		IMPLEMENTATION

	MASTER	DIRECTORY

	LEFT HALF OF .USFCC (CACHED LIST HEADER) IS LINK TO FIRST FILE


	USER	BLOCK FORMAT

	XWD	LINK,NAME
	EXP	SIZE
	BLOCK	SIZE		;USER DATA

	NAME	= USER FILE NAME.
	LINK	= LINK TO NEXT FILE FOR THIS USER

	A LINK OF 0 INDICATES NO MORE FILES



	MONITOR	BUFFER AND PARAMETERS

	ALL SPACE FOR A USER IS ACQUIRED FROM THE "FUNNY SPACE" POOL
>
	ENTRY	TMPUUO

TMPUUO::PUSHJ	P,SAVE4##	;SAVE P1-P4
	AOS	(P)		;SET FOR GOOD RETURN
	MOVE	P4,T1		;GET USERS AC
	TLNN	P4,-1		;IS CODE = 0?
	JRST	TMPSP		;YES, SO JUST RETURN SPACE LEFT
	HRR	M,P4		;SETUP M TO GET FIRST WORD OF BLOCK
	PUSHJ	P,GETWDU##	;GET FIRST WORD
	HLLZ	S,T1		;SAVE FILE NAME
	PUSHJ	P,GETWD1##	;GET SECOND WORD
	HLRE	U,T1		;GET USER'S BUFFER LENGTH
	MOVNS	U		;U = POSITIVE COUNT
	HRR	M,T1		;USER'S BUFFER ADDRESS
	HRRZS	T2,T1		;START OF USER'S BUFFER -1
	ADDI	T1,1		;START OF BUFFER
	ADDI	T2,(U)		;END OF BUFFER
	SKIPE	U		;IF NO WORDS TO TRANSFER,
				; WE DON'T CARE ABOUT THE ADDRESS.
				; LOGOUT DEPENDS ON THIS.
	PUSHJ	P,TRNGE##	;MAKE SURE THAT THE ENTIRE BUFFER IS IN CORE
	HLRZS	P4		;GET CODE
	CAILE	P4,TMPDL	;CHECK IF IT IS LEGAL
	JRST	UUOERR##	;NO
	JRST	@TMPDIS-1(P4)	;DISPATCH TO APPROPRIATE ROUTINE

TMPDIS:	JRST	TMPREA
	JRST	TMPREA
	JRST	TMPWR
	JRST	TMPDIR
	JRST	TMPDIR

	TMPDL= .-TMPDIS
;ROUTINE TO READ, OR READ AND DELETE A TEMPORARY FILE

TMPREA:	PUSHJ	P,TMPSRC	;FIND FILE
	  JRST	TMPSPB		;NONE, SO RETURN SPACE
	MOVE	P3,1(P1)	;GET LENGTH FOR RETURN TO USER
	MOVE	T1,P3		;LENGTH OF FILE
	CAMLE	T1,U		;BUFFER BIG ENOUGH?
	MOVE	T1,U		;NO, ONLY TRANSFER AS MUCH AS WILL FIT
	SUB	U,T1		;SIZE OF UNUSED PORTION OF BUFFER
IFE FTXMON,<
	MOVSI	T2,2(P1)	;ADDR OF 1ST DATA WORD IN FILE
	HRRI	T2,1(M)		;ADDR TO PUT 1ST WORD
	ADD	M,T1		;ADDR LAST WORD WILL GO
	SKIPE	T1		;ANYTHING TO TRANSFER?
	EXCTXU	<BLT T2,(M)>	;YES, COPY IT TO USER
> ;END IFE FTXMON
IFN FTXMON,<
	XMOVEI	T2,2(P1)	;ADDR OF 1ST DATA WORD IN FILE
	XSFM	T3		;GET PCS (AND OTHER KRUFT)
	HRLZ	T3,T3		;POSITION USER SECTION
	HRRI	T3,1(M)		;USER'S SECTION-LOCAL BUFFER ADDRESS
	ADD	M,T1		;ADDR LAST WORD WILL GO
	SKIPE	T1		;ANYTHING TO TRANSFER?
	XBLTXU	T1		;YES, COPY IT TO USER
>; END IFN FTXMON
	ERJMP	UADERR##	;MUST BE A WRITE LOCKED HISEG
	TRNN	P4,1		;SHOULD WE DELETE THE FILE?
	PUSHJ	P,TMPDEL	;YES, DO IT
TMPZBF:	JUMPLE	U,STOP3		;QUIT IF NONE TO ZERO
	HRRZI	T2,1(M)		;FIRST UNUSED USER DATA BUFFER WORD ADDRESS
	EXCTUU	<SETZM (T2)>	;ZERO THE 1ST WORD OF UNUSED PORTION
	ERJMP	UADERR##	;MUST BE A WRITE LOCKED HISEG
IFE FTXMON,<
	MOVSI	T2,1(M)		;SET UP A BLT
	HRRI	T2,2(M)
	ADD	M,U		;ADDR OF LAST WORD TO ZERO
	SOSE	U		;DON'T BLT IF ONLY ONE WORD TO ZERO
	EXCTUU	<BLT T2,(M)>	;ZERO THE REST OF THE BUFFER
> ;END IFE FTXMON
IFN FTXMON,<
	XSFM	T2		;GET PCS/ETC.
	HRLZ	T2,T2		;POSITION USER SECTION ADDRESS
	MOVE	T3,T2		;ANOTHER COPY OF USER SECTION
	HRRI	T2,1(M)		;SOURCE ADDRESS
	HRRI	T3,2(M)		;DESTINATION ADDRESS
	SOSE	T1,U		;ACCOUNT FOR "SETZM" ABOVE,
	XBLTUU	T1		;ZERO THE REST OF THE BUFFER
> ;END IFN FTXMON
	ERJMP	UADERR##	;MUST BE A WRITE LOCKED HISEG
	JRST	STOP3		;TELL USER THE SIZE OF THE FILE
;ROUTINE TO FIND A FILE

TMPSRC:	MOVEI	P2,.USFCC	;GET ADDRESS OF FIRST LINK
TMPSR1:	HLRZ	P1,(P2)		;CHAIN FORWARD
	JUMPE	P1,CPOPJ##	;NONE, FILE NOT FOUND
	HRLZ	T2,(P1)		;GET FILE NAME
	CAMN	T2,S		;MATCH?
	JRST	CPOPJ1##	;YES, SKIP RETURN
	MOVEI	P2,(P1)		;SAVE OLD POINTER
	JRST	TMPSR1		;AND KEEP ON LOOKING

;ROUTINE TO DELETE A BLOCK

TMPDEL:	HLRZ	T1,(P1)		;LINK AROUND BLOCK
	HRLM	T1,(P2)
	MOVE	T1,1(P1)	;GET LENGTH OF FILE
	ADDI	T1,2		;+ OVERHEAD
	MOVE	T2,P1		;AND WHERE IT IS
	PJRST	GVFWDS##	;RETURN TO FUNNY SPACE

;ROUTINE TO WRITE A FILE FOR USER

TMPWR:	JUMPE	S,TMPSPB	;DISALLOW NULL NAME
	PUSHJ	P,TMPSRC	;SEE IF THERE WAS AN OLD FILE
	  SKIPA			;NO, PROCEED
	PUSHJ	P,TMPDEL	;DELETE OLD FILE
	JUMPL	U,TMPSPB	;BAD IOWD FOR FILE?
	MOVEI	T2,2(U)		;SIZE + OVERHEAD
	CAILE	T2,^D510+2	;LARGEST FILE+ OVERHEAD
	JRST	TMPSPB		;TOO BIG
	PUSHJ	P,GFWDCH##	;GET THE SPACE
	  JRST	TMPWR2		;NOT AVAILABLE, RETURN
	MOVE	P1,T1		;PUT ADDRESS IN A SAFE PLACE
	HLLZ	P3,.USFCC	;SAVE LINK TO FIRST FILE
	HLR	P3,S		;INSERT THIS FILE NAME
	MOVEM	P3,(P1)		;STORE LINK AND NAME
	HRRZM	U,1(P1)		;STORE FILE LENGTH
	HRLM	P1,.USFCC	;NEW FILE IS NOW THE FIRST
	JUMPE	U,TMPSP		;QUIT IF ZERO LENGTH FILE
IFE FTXMON,<
	MOVSI	T2,1(M)		;ADDR OF 1ST DATA WORD
	HRRI	T2,2(P1)	;ADDR 1ST WORD GOES TO
	ADDI	U,1(P1)		;ADDR LAST WORD GOES TO
	EXCTUX	<BLT T2,(U)>	;COPY THE DATA
> ;END IFE FTXMON
IFN FTXMON,<
	MOVE	T1,U		;COUNT OF WORDS TO COPY
	XSFM	T2		;USER PCS
	HRLZ	T2,T2		;USER SECTION,,0
	HRRI	T2,1(M)		;USER BUFFER ADDRESS
	XMOVEI	T3,2(P1)	;EXEC BUFFER ADDRESS
	XBLTUX	T1		;COPY FILE DATA TO MONITOR
> ;END IFN FTXMON
	JRST	TMPSP		;GO TELL HOW MUCH SPACE LEFT

;HERE IF CAN'T GET ENOUGH FUNNY SPACE,
;TELL HIM THE SIZE OF THE BIGGEST HOLE
TMPWR2:	SOS	(P)		;FAIL RETURN
	SOSLE	T1,T2		;DEDUCT OVERHEAD
	SOSGE	T1		;...
	SETZ	T1,		;NONE LEFT
	JRST	STOTAC##	;RETURN MAX FILE

;ROUTINE TO GET SPACE AND RETURN TO USER (SKIP AND NO SKIP)

TMPSPB:	SOS	(P)		;NO SKIP RETURN
TMPSP:	MOVEI	P3,^D510	;LARGEST FILE
STOP3:	MOVE	T1,P3		;SET TO STORE P3
	JRST	STOTAC##	;RETURN IT
;READ DIRECTORY, READ AND CLEAR DIRECTORY

TMPDIR:	SETZ	P3,		;ZERO COUNT OF FILES
	HLRZ	P1,.USFCC	;POINT TO FIRST FILE BLOCK
	MOVEI	P2,.USFCC	;PRESET PREDECESSOR FOR READ AND DELETE
TMPDI1:	JUMPE	P1,TMPZBF	;IF NONE, ZERO REST OF USERS BUFFER
	HRLZ	T1,(P1)		;GET FILE NAME
	HRR	T1,1(P1)	;AND LENGTH OF FILE
	SOSL	U		;IS THERE SPACE LEFT IN USER AREA?
	PUSHJ	P,PUTWD1##	;YES, STOW ENTRY
	HLRZ	S,(P1)		;POINT TO NEXT BLOCK
	TRNE	P4,1		;DELETE?
	PUSHJ	P,TMPDEL	;YES, DELETE BLOCK
	MOVE	P1,S		;COPY LINK (DELETE MAY HAVE DESTROYED THE PAGE)
	AOJA	P3,TMPDI1	;COUNT FILES, GO ON FOR NEXT ONE
; HERE FROM CONTEXT SERVICE TO LINK IN A NEW TMPCOR FILE,
; DELETING ANY EXISTING FILE BY THE SAME NAME.  T1 POINTS
; TO THE ADDRESS OF THE NEW FILE ALREADY IN FUNNY SPACE.

TMPCTX::PUSHJ	P,SAVE2##	;SAVE P1 AND P2
	PUSH	P,T1		;SAVE NEW TMPCOR FILE ADDRESS
	PUSH	P,S		;SAVE S
	HLLZ	S,(T1)		;GET FILE NAME
	PUSHJ	P,TMPSRC	;SEE IF THE FILE ALREADY EXISTS
	  SKIPA			;IT DOESN'T
	PUSHJ	P,TMPDEL	;DELETE OLD COPY
	POP	P,S		;RESTORE S
	POP	P,T1		;GET NEW TMPCOR FILE ADDRESS BACK
	HLRE	T2,1(T1)	;GET -LENGTH
	MOVNS	T2		;MAKE POSITIVE
	HRRZM	T2,1(T1)	;SAVE IT
	HLLZ	T2,.USFCC	;GET ADDRESS OF FIRST FILE
	HLR	T2,(T1)		;GET FILE NAME
	MOVEM	T2,(T1)		;SAVE LINK,,NAME
	HRLM	T1,.USFCC	;NEW FILE IS NOW THE FIRST IN THE CHAIN
	POPJ	P,		;RETURN


	END
   