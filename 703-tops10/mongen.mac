TITLE	MONGEN - PROGRAM TO DEFINE MONITOR AND NETWORK CONFIGURATIONS - V060
SUBTTL	T. HASTINGS/TH/EP/DAL/JBS	26 NOV 85

EDITNO==306		;EDIT NUMBER (**MUST MATCH "M.GEN" IN COMMON.MAC**)
VERSION==057		;MAJOR VERSION NUMBER
VMINOR==0		;MINOR VERSION NUMBER
VWHO==0			;WHO LAST EDITED

	SALL
	.DIRECT	FLBLST

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
ASCIZ	&
COPYRIGHT (C) 1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
ALL RIGHTS RESERVED.
&


;

;DO NOT CHANGE BELOW NUMBER, IT IS A LOCATION, NOT A NUMBER!!!
JOBVER==137		;LOC OF VERSION NO IN JOB DATA AREA
	LOC	JOBVER
	BYTE	(3)VWHO(9)VERSION(6)VMINOR(18)EDITNO	;VERSION NUMBER
	RELOC

;SYMBOLS WHICH ARE PARAMETERS OF MONGEN ITSELF(PREFIX MP)
IFNDEF MP.MVN,<MP.MVN==^D703>	;MONITOR VERSION NUMBER
		;WHICH THIS MONGEN IS DESIGNED TO GENERATE
		;OTHER MONGEN VERSIONS GENERATE OTHER MONITOR VERSIONS
IFNDEF MP.PDL,<MP.PDL==40>	;PD LIST LENGTH
IFNDEF MP.AMX,<MP.AMX==^D10>	;MAX NO. OF ANSWERS INSIDE PARENS
IFNDEF MP.SMX,<MP.SMX==^D4>	;MAX SYSTEM SUPPORTED IN 7.02
		; 1070=0, 1080=1, 1090=2, 1091=3, 2020=4
IFNDEF MP.LMX,<MP.LMX==^D80>	;MAX. NO. OF CHAR ALLOWED IN INPUT LINE
		; NOT COUNTING EOL OR NULL
IFNDEF MP.FTA,<MP.FTA==^D25>	;MAX NUMBER OF FEATURE TEST SWITCHES THAT MAY BE ADDED

COMMENT	"

ASSEMBLY INSTRUCTIONS:
.COMPIL MONGEN

LOADING INSTRUCTIONS:
.LOAD MONGEN

DEBUGGING INSTRUCTION:
.DEBUG MONGEN
  BY DEPOSITING NON-ZERO IN LOCATION DEBUG WITH DDT, MONGEN WILL
  OUTPUT ALL FILE STUFF TO TTY TOO INSIDE <>.
"
;MONGEN IS A DIALOG PROGRAM(ACTUALLY 3 PROGRAMS IN ONE) WHICH
;ASKS THE CUSTOMER QUESTIONS ABOUT HIS CONFIGURATION.
;THE RESULTS OF THIS DIALOG ARE OUTPUT AS A FILE OF PARAMETER ASSIGNMENTS
;WHICH CAUSE CONDITIONAL ASSEMBLY IN THE DATA BASE MODULES OF THE MONITOR.
;THUS EACH CUSTOMER IS ABLE TO CUSTOM-MAKE HIS MONITOR FOR THE FEATURES
;HE WISHES DEPENDING ON HARDWARE AND SOFTWARE REQUIREMENTS.
;THESE PARAMETER ASSIGNMENTS TAKE THE FORM OF MACRO CALLS USING
; THE XP MACRO OF TWO ARGUMENTS AS DEFINED IN FILE S.MAC.  THE XP
; MACRO DEFINES THE FIRST SYMBOL TO BE EQUAL TO THE SECOND EXPRESSION
; AND DECLARES THE SYMBOL TO BE INTERNAL AND DDT OUTPUT SUPPRESSED.

;MONGEN CAN CONFIGURE ITSELF BY USING THE MONGEN DIALOG.  THE MONGEN
;DIALOG RESULTS IN A NEW .EXE FILE.  MONGENING MONGEN IS UNSUPPORTED.

;USER INSTRUCTIONS FOR RUNNING MONGEN:
;MONGEN WILL ASK YOU QUESTIONS ABOUT YOUR CONFIGURATION AND
; OUTPUT THEM IN A FILE.  TO HELP YOU ANSWER THESE QUESTIONS,
; MONGEN GIVES THREE LEVELS OF
; GUIDANCE.  SHORT MODE FOR THE VERY EXPERIENCED, PROMPT MODE
; WHERE YOU ARE GIVEN CHOICES, AND LONG MODE WHERE YOU
; ARE GIVEN THE CHOICES ALONG WITH AN EXPLANATION.  YOU MAY CHANGE
; THE MODE FOR A SINGLE QUESTION IF YOU DO NOT UNDERSTAND IT BY SIMPLY TYPING /H
; TO CHANGE THE MODE FOR THE REST OF THE QUESTIONS, TYPE /HELP:X
; WHERE X IS SHORT, PROMPT, OR LONG.  ACTUALLY MONGEN ALWAYS
; ALLOWS ABBREVIATIONS EVERYWHERE, SO S, P, AND L SUFFICE
; ALONG WITH H FOR HELP.
; QUESTIONS ASKING FOR A NUMBER(DECIMAL UNLESS SPECIFICALLY NOTED
; AS OCTAL) ALWAYS INDICATE THE RANGE INSIDE PARENS, IE (MIN-MAX).
; OTHER QUESTIONS ARE ASKING FOR ONE
; OF A LIST OF CHOICES.  THE CHOICES ARE LISTED INSIDE PARENS.
; STILL OTHER QUESTIONS ASK
; FOR Y OR N AND STILL OTHERS ASK FOR JUST A STRING.
; IN ALL QUESTIONS WHICH HAVE PROMPTING INSIDE PARENS, THE FIRST
; ITEM IN THE LIST IS CALLED THE DEFAULT AND IS ASSUMED IF YOU
; ANSWER JUST WITH CARRIAGE RETURN.  ALL THE YES/NO QUESTIONS
; HAVE PROMPTING OF (Y,N) SO CARRIAGE RETURN ALWAYS MEANS Y.
; (,ANS0,ANS1,...) MEANS NO DEFAULT ASSUMED ON JUST CR
; CALLER OF ASK ROUTINE MUST CHECK FOR N=0 IN THIS CASE AND TAKE
; APPROPRIATE ACTION.  (THIS FEATURE IS USED BY HELP ITSELF TO ALLOW
; JUST CR TO MEAN NEXT LONGER HELP MODE).


;RULE: ALL SYMBOLS ARE GENERATED ALL OF THE TIME,
; NO MATTER HOW DIALOG BRANCHES.  WHY?  SO USERS READING THE
; DATA BASE MODULES NEVER NEED TO LOOK AT MONGEN TO UNDERSTAND
; THE MONITOR.
;THE ONLY LOCAL STORAGE IN MONGEN IS USED TO STORE ANSWERS IF THE
; VALUES ARE NEEDED LATER FOR ERROR CHECKING.  MOST ANSWERS ARE OUTPUT
; IMMEDIATELY AND SO ARE NEVER STORED IN MEMORY.  BY CONVENTION THE NAMES
; OF VARIABLES WARE THE SAME AS THE ASSOCIATED SYMBOLS OUTPUT IN
; THE FILE.  OUTPUT SYMBOLS ALL START WITH THE TWO LETTERS "M."  OR "FT" THIS MAKES
; IT EASY TO RECOGNIZE SYMBOLS DEFINED BY MONGEN WHEN READING THE REST
; OF THE MONITOR.
;MONGEN IS STUPID AND SIMPLE MINDED.  IS KNOWS AS LITTLE ABOUT
; THE MONITOR AS POSSIBLE.  IT NEVER ADDS TWO ANSWERS TOGETHER, FOR EXAMPLE.
; IT ALWAYS GENERATES ALL SYMBOLS ALL THE TIME, NO MATTER
; HOW THE QUESTIONS ARE ANSWERED.  IT IS UP TO COMMON TO TAKE THE RAW DATA
; AND PERFORM COMPUTATION AND DEFINE NEW AND CONVENIENT SYMBOLS.
;THE FOLLOWING MACROS(AND SUBROUTINES BY THE SAME NAME) ARE USED TO ASK
; CUSTOMER QUESTIONS AND GET HIS ANSWERS:
;SOME ANSWERS ARE NUMERIC, WHILE OTHERS ARE CHOICES LIKE Y OR N
; OR AN ITEM OUT OF A LIST.  ALL ANSWERS ARE CHECKED FOR REASONABLENESS.
; THE GOAL IS TO PREVENT AS MANY ERRORS AS POSSIBLE, SINCE ERRORS
; ARE NOT USUALLY DISCOVERED UNTIL THE MONITOR IS LOADED AND SOMETIMES
; EVEN THEN IT IS HARD TO FIND THE PROBLEM.  ALL NUMERIC ANSWERS ARE
; CHECKED FOR MIN AND MAX AS INDICATED INSIDE PARENS WITH A -
; SEPARATING THE MIN AND MAX.  IF A NUMERIC QUESTION
; DOES NOT HAVE A RANGE SPECIFIED, MONGEN WILL PRINT
; ? INTERNAL MONGEN ERROR - ABOVE QUESTION MUST HAVE (...,MIN-MAX) -
; EDIT MONGEN.
; AND EXIT.  NOTE: (MIN-?) IS OK TO MEAN NO UPPER BOUND
;  THE PROGRAMMER MUST EDIT MONGEN TO FIX HIS BUG.
;  THE CUSTOMER SHOULD NEVER SEE THIS MESSAGE, SINCE IT IS A DEBUGGING
;  AID AND SHOULD BE CAUGHT DURING TESTING.
;EACH MACRO HAS A TEXT QUESTION AS AN ARGUMENT.  THE ANSWER IS RETURNED
; IN AC N.  IF AN ERROR IS DETECTED, THE QUESTION IS
; REASKED AT NEXT HIGHER LEVEL OF VERBOSITY.  RETURN IS ALWAYS WITH
; A SUCCESSFUL VALUE.  THE CUSTOMER MAY HAVE CHANGED LEVELS OF VERBOSITY
; USING THE /HELP: FEATURE.  LOCATION SAVLV HAS CURRENT PERMANENT LEVEL,
; WHILE LEVEL FOR CURRENT QUESTION IS KEPT IN AC LV.

;ASKYN  - ANSWER Y OR N, (Y=1, N=0) NOTE: OPPOSITE FROM ASKLST
;	  HOWEVER MORE USEFUL, SINCE CAN OUTPUT DIRECTLY IN XP MACRO
;	  WHERE XP SYMBOL,1 MEANS Y AND XP SYMBOL,0 MEANS N.
;	(Y,N) MUST APPEAR IN QUESTION AS A PROMPT.  FOR CONSISTENCY
;	THE Y MUST BE BEFORE THE N SO CR ALWAYS MEANS Y.
;ASKDEC - ANSWER DECIMAL NUMBER.  QUESTION SHOULD HAVE (DEFAULT,MIN-MAX).
;	IF NO DEFAULT IS REASONABLE(SUCH AS NUMBER OF JOBS), ONLY
;	(MIN-MAX) IS REQUIRED.
;ASKOCT - ANSWER OCTAL NUMBER.  QUESTION SHOULD HAVE (DEFAULT,MIN-MAX)
;	IF NO DEFAULT IS REASONABLE, ONLY (MIN-MAX) IS REQUIRED.
;ASKLIN - ANSWER OCTAL LINE NUMBER OR CTY
;ASKSTR - ANSWER ARBITRARY STRING.  STORED IN ASCSTR AS ASCIZ.
;	N=NO. OF CHARS IN STRING NOT COUNTING NULL OR CRLF.
;ASKLST - ANSWER ONE OF THE ITEMS IN THE PROMPTING LIST IN PARENS.
;	N=0,1,2,... IE POSITION OF ANSWER IN LIST.  IF ANSWER IS NOT
;	IN LIST OR ABBREVIATION IS NOT UNIQUE, THE QUESTION IS REASKED
;	AT HIGHER LEVEL OF VERBOSITY.  ERROR MESSAGES ARE:
;	? TYPE ENOUGH TO UNIQUELY DISTINGUISH ANSWER
;	? ANSWER WITH ONE OF THE CHOICES INSIDE ( )
;	? INTERNAL MONGEN ERROR - NO "(" IN ABOVE MESSAGE -
;	EDIT MONGEN AND ADD (ANS0,ANS1,...)
;	? INTERNAL MONGEN ERROR - TOO MANY POSSIBLE ANSWERS ABOVE -
;	EDIT MONGEN AND INCREASE MP.AMX
;TO ASK A MULTIPLE LINE QUESTION, THE FOLLOWING SPECIAL MACROS:
;ASKMN  - ANSWER M OR M,N WHERE M AND N ARE OCTAL LINE
;	NUMBERS OR JUST CTY
;ASKMNP - ANSWER M,P OR M-N,P WHERE M,N, AND P ARE OCTAL LINE NUMBERS
;
;ASKTMN - ANSWER M OR M,N OR ALL FOR 7 TRACK TAPE UNITS
;
;ASKTMN - ANSWER M OR M,N OR ALL FOR 7 TRACK TAPE UNITS

;TO OUTPUT TO TTY, FILE OR BOTH, USE THE FOLLOWING:
; USUAL FILE OUTPUT RADIX IS OCTAL, WHILE TTY OUTPUT RADIX IS DECIMAL,
; UNLESS NAME HAS OCT OR DEC IN IT, IN WHICH THE RADICES ARE THE SAME.

;BTHOUT - OUTPUT DECIMAL TO BOTH TTY AND FILE, FILE AS A COMMENT(IE ; INSERTED)
;BTHOCT - OUTPUT OCTAL TO BOTH TTY AND FILE, FILE AS A COMMENT
;FILEOUT - OUTPUT TO FIL ONLY
;FILCOM - OUTPUT TO FILE ONLY AS A MULTI-LINE COMMENT(IE ; INSERTED)
;TTYOUT - OUTPUT TO TTY ONLY(DECIMAL)(USUAL)
;TTYOCT - OUTPUT TO TTY ONLY(OCTAL)(UNUSUAL)
;FILSTR - OUTPUT STRING IN ASCSTR TO FILE
;FILDEC - OUTPUT TO FILE WITH RADIX DECIMAL INSTEAD OF OCTAL
;FILDC2 - OUTPUT TO FILE WITH RADIX DECIMAL, AT LEAST 2 CHARS
;ALL OF THE ABOVE MACROS(AND SUBROUTINES) CAN HAVE A SECOND
; ARGUMENT WHICH IS THE LOCATION OF A VALUE TO BE SUBSTITUTED FOR * IN
; THE FIRST ARGUMENT.  THE VALUE CAN BE LEFT JUSTIFIED SIXBIT OR A NUMBER.
; IF THE LOCATION OF THE VALUE IS AC N, NO EXTRA INSTRUCTION IS GENERATED
; SINCE THE MACRO USUALLY PICKS UP THE LOCATION AND PUTS IT IN N.
; HOWEVER IT IS RECOMENDED THAT N BE INCLUDED AS THE SECOND ARGUMENT
; TO INDICATE TO THE READER THAT A SUBSTITION IS GOING TO TAKE PLACE USING N.
; ELSE NEW CODE MAY BE INTRODUCED WHICH USES N BEFORE THE MACRO CALL.
; WHENEVER THE CHARACTER @ IS SEEN IT IS CONVERTED TO CRLF.  THIS
; MAKES IT NICER FOR FORMATTING THE MESSAGES INSIDE <>, SINCE
; THE <CLOSE ANGLE> CAN ALWAYS BE ON THE SAME LINE, EVEN WHEN CRLF IS WANTED.

;EXAMPLE:
;	ASKYN	<LPT(Y,N)[LINE PRINTER AT STATION *]>,OSN
;	FILOUT	<MACRLP	*@>,N

;ALL SUBROUTINES WHICH IMPLEMENT THE MACROS HAVE THE SAME CALLING
; SEQUENCE:
;CALL:	MOVE	LV,QUESTION LEVEL -1 FOR SHORT, 0 FOR PROMPT, 1 FOR LONG
;	MOVE	N,+NUMBER OR LEFT JUSTFIED SIXBIT TO BE
;				; SUBSTITUTED FOR *
;	MOVEI	T1,ADR OF ASCIZ MESSAGE
;	PUSHJ	P,ASKXXX OR FILXXX OR TTYXXX OR BTHXXX
;	ALWAYS RETURN WITH ANSWER IN N( AND STRING IN ASCSTR) OR
;	ORIGINAL CONTENTS OF N IF JUST OUTPUT ROUTINE.
;THE FGEN DIALOGUE MAKES USE OF AN AUXILIARY HELP FILE SYS:FGEN.HLP
;TO EXPLAIN THE USE OF FEATURE TEST SWITCHES AND TO INCLUDE COMMENTS
;IN THE OUTPUT FILE. THE FILE MUST BE IN THE FORM
;<TERMINATOR> <SWITCH> <TAB> <TEXT> <TERMINATOR>
;THE TERMINATOR IS DETERMINED BY SYMBOL C.TMFH AND IS CURRENTLY
;<CONTROL> A. IT MUST BE ONE CHARACTER.
;THE TEXT WILL BE COPIED FROM AFTER THE TAB TO THE NEXT TERMINATOR,
;SO IT SHOULD BE CONSTRUCTED CAREFULLY. NOTE PARTICULARLY THAT SINCE TO
;POSITION THE FILE THE CODE FIRST FINDS A TERMINATOR AND THEN READS TO
;A TERMINATOR IT WILL BE MORE EFFICIENT IF EACH SWITCH IS PRECEEDED BY
;TWO TERMINATORS.

;MACRO FHLPOS IS PROVIDED TO HELP POSITION THE HELP FILE.
; FHLPOS STRING,TAG POSITIONS THE FILE TO THE TEXT AFTER "STRING",
;AND TRANSFERS TO "TAG" IF THE STRING CANT BE FOUND. IF THE STRING
;HAS BEEN COMPUTED, IT SHOULD BE SIXBIT CHARACTERS LEFT JUSTIFIED IN
;ACCUMULATOR WD, AND THE FIRST ARGUMENT SHOULD BE *, E.G.
; FHLPOS *,ERROR

;FHLPOA IS THE SAME EXCEPT IT DOES NOT LOOK FOR A TAB AFTER THE TEXT

;SUBROUTINES HAVE BEEN PROVIDED TO COPY THE TEXT FROM THE HELP
;FILE TO THE OUTPUT FILE OR TTY.

;FHLPTT - COPIES TEXT FROM THE CURRENT POSITION OF THE HELP FILE TO
;THE NEXT TERMINATOR TO TTY

;FHLPFL - COPIES TEXT FROM THE CURRENT POSITION TO THE NEXT TERMINATOR
;TO THE OUTPUT FILE

;FHLPFC - COPIES TEXT FROM THE CURRENT POSITION TO THE NEXT TERMINATOR
;TO THE OUTPUT FILE AS A COMMENT, I.E. WITH A ; AT THE BEGINNING OF EACH LINE
;SOME CONVENTIONS:
;ALL SINGLE LINE ANSWERS ARE ANSWERED ON THE SAME LINE AS QUESTIONS.
; THIS SAVES PAPER. THE FORMAT IS QUESTION(WITHOUT QUESTION MARK)
; FOLLOWED BY COLON AND ONE SPACE.

;ONLY THE ASK MACROS ADD ANY CHARACTERS TO THE TEXT IN THE FIRST
; ARGUMENT.  THE BEGINNING OF THE MESSAGE IS INSERTED AN ";	" AS
; A COMMENT FOR THE FIL, AND ": " IS APPENDED TO THE END
; OF THE QUESTION SO THAT ALL QUESTIONS LOOK ALIKE.  NONE OF THE
; OUTPUT ONLY MACROS ADD ANY SPECIAL CHARACTERS.

;BY CONVENTION PROMPTING IN () APPEARS BEFORE LONG DIALOG IN [].
; THUS A USER CAN TYPE ^O IF THE USER GETS BORED, AND GET THE MOST USEFUL
; OUTPUT FIRST.

;IF JUST A CR IS GIVEN TO A QUESTION WHICH HAS A LIST, THE FIRST
; ITEM IS ASSUMED.  THIS IS TRUE FOR DECIMAL AND OCTAL QUESTIONS TOO.

;ALL NUMERIC QUESTIONS MUST HAVE A RANGE SUPPLIED.
; IF ONE IS NOT, THE USER GETS:
; ? INTERNAL MONGEN ERROR - NO (...,MIN-MAX) IN ABOVE QUESTION -
; EDIT MONGEN AND INCLUDE IN QUESTION.

;ALL ERRORS WHICH ARE MONGEN'S RATHER THAN THE CUSTOMER'S, ARE PRECEDED
; WITH ? INTERNAL MONGEN ERROR - FOLLOWED BY THE PROBLEM AND WHAT
; THE PROGRAMMER SHOULD DO TO FIX MONGEN.  NOTE THAT
; THE CUSTOMER SHOULD NEVER SEE THESE, SINCE THEY ARE DEBUGGING AIDS.

;ALL ERROR MESSAGES START WITH "? ". THE SPACE FOLLOWING ? MAKES THEM
; DISTINGUISHABLE FROM MONITOR ERRORS WHICH HAVE NO SPACE.

;ALL STRINGS ARE ASCIZ INCLUDING AS INPUT FROM TTY.
; ALL EOL CHARS(CR,LF,FF,VT,ESC,ALT1,ALT2,^Z,^C) ARE STRIPPED OUT
; AND ARE REPLACED BY A NULL.  THIS MAKES IT EASY TO SCAN STRINGS
; SINCE END IS ALWAYS DETECTED BY JUMPE CH,
; OUTPUT TO FILE MUST PUT CRLF BACK IN EXPLICITLY BY USING
; @ OR FCRLF ROUTINE.  THIS MAKES OUTPUT FILE MORE INDEPENDENT FROM
; USER INPUT.

;TO HELP THE READER OF MONGEN:
; ALL JUMPS ARE DOWN THE PAGE, EXCEPT LOOPS
; MOST PUSHJ ARE TO ROUTINES DOWN THE PAGE

;DEFINE THE MACROS:
; THE FOLLOWING MACROS SUFFIX ": " TO ASK QUESTION
; AND GET ANSWER ON SAME LINE
DEFINE	CAL	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVE	N,B>>	;;PICK UP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO BIG TO FIT
				;; IN REMOTE LITERAL.
	ASCIZ	\A: \		;;THE QUESTION WITH ": "
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE XXX
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>

DEFINE	ASKYN	(A,B)<
	CAL	ASKYN,<A>,B>

DEFINE	ASKDEC	(A,B)<
	CAL	ASKDEC,<A>,B>

DEFINE	ASKOCT	(A,B)<
	CAL	ASKOCT,<A>,B>

DEFINE	ASKLIN	(A,B)<
	CAL	ASKLIN,<A>,B>

DEFINE	ASKSTR	(A,B)<
	CAL	ASKSTR,<A>,B>

DEFINE	ASKLST	(A,B)<
	CAL	ASKLST,<A>,B>


;THE FOLLOWING MACROS DO NOT HAVE ANY CHARACTERS ADDED TO QUESTION

DEFINE	CAL2	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVE	N,B>>	;;PICKUP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO LONG FOR MACRO
				;; REMOTE LITERAL TABLE(14 WORDS)
	ASCIZ	\A\		;;THE QUESTION WITH NO ADDED CHARACTERS
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE TO JUST OUTPUT
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>
;OUTPUT IMMEDIATE VALUE

DEFINE	CAL3	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVEI	N,B>>	;;PICKUP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO LONG FOR MACRO
				;; REMOTE LITERAL TABLE(14 WORDS)
	ASCIZ	\A\		;;THE QUESTION WITH NO ADDED CHARACTERS
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE TO JUST OUTPUT
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>
DEFINE	ASKMN	(A,B)<
	CAL2	ASKMN,<A>,B>

DEFINE	ASKMNP	(A,B)<
	CAL2	ASKMNP,<A>,B>

DEFINE	ASKTMN	(A,B)<
	CAL2	ASKTMN,<A>,B>

DEFINE	BTHOUT	(A,B)<
	CAL2	BTHOUT,<A>,B>

DEFINE	BTHOCT	(A,B)<
	CAL2	BTHOCT,<A>,B>

DEFINE	FILOUT	(A,B)<
	CAL2	FILOUT,<A>,B>

DEFINE	FILCPU	(A,B)<
	CAL2	FILCPU,<A>,B>

DEFINE	FILCOM	(A,B)<
	CAL2	FILCOM,<A>,B>

DEFINE	FILOUD	(A,B)<
	CAL3	FILOUT,<A>,B>

DEFINE	TTYOUT	(A,B)<
	CAL2	TTYOUT,<A>,B
>
DEFINE	TTYOCT	(A,B)<
	CAL2	TTYOCT,<A>,B>

DEFINE	FILSTR	(A,B)<
	CAL2	FILSTR,<A>,B>

DEFINE	FILDEC	(A,B)<
	CAL2	FILDEC,<A>,B>

DEFINE	FILDC2	(A,B)<
	CAL2	FILDC2,<A>,B>

DEFINE	EREXIT	(A,B)<
	CAL2	EREXIT,<A>,B>
DEFINE	FHLPOS	(A,B)<
	XLIST
IFB <A>,<PRINTX FHLPOS MACRO MAY CLOBBER WD>
IFB <B>,<PRINTX FHLPOS MACRO MAY CLOBBER WD>
IFDIF <A>,<*>,<
	MOVE	WD,[SIXBIT \A\]
>
	INTERN	FHLPOS
	PUSHJ	P,FHLPOS
	  JRST	B
	LIST
>

DEFINE	FHLPOA	(A,B)<
	XLIST
IFB <A>,<PRINTX FHLPOA MACRO MAY CLOBBER WD>
IFB <B>,<PRINTX FHLPOA MACRO MAY CLOBBER WD>
IFDIF <A>,<*>,<
	MOVE	WD,[SIXBIT \A\]
>
	INTERN	FHLPOA
	PUSHJ	P,FHLPOA
	  JRST	B
	LIST
>
;DEFINE REMOTE MACROS WHICH ARE JUMPED TO ON UNUSUAL CASES
; INCLUDE CODE IN-LINE SO READABLE, BUT INDENT 2 TABS, JUST AS
; IF MULTI-LINE LITERAL.
;USED INSTEAD OF MULTI-LINE LITERAL BECAUSE MACRO LISTS
; SOURCE INSIDE OF MACROS INSIDE OF LITERALS
DEFINE	RJRST	(A,%B)<
	XLIST		;;TURN OFF LISTING SOURCE IN EXPANSION
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPA		;;ALLOW MACRO IN ERROR RETURN OR AFTER TEST INSTR.
	JRST	%B	;;BY PASS UNUSUAL CODE
	A		;;THE UNUSAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST		;;TURN LISTING BACK ON
>

DEFINE	RJUMPE	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPE	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST		;;TURN LISTING BACK ON
>

DEFINE	RJUMPL	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPL	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>

DEFINE	RJUMPN	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPN	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>
DEFINE	RJUMPGE	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPGE	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE AL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>

RJRSTF==0		;START FLAG AT 0 MEANING NOT INSIDE RJRST
;PARAMETERS:
;ACS
F=0		;FLAGS
  ;LH(DEFINED AS 36 BIT QUANTITIES):
  F.MTCH==1B0	;MATCH FOUND IN FNDASK ROUTINE
  F.OFO==1B1	;OUTPUT FILE OPEN.  FILE CALLS IGNORED IF 0
		; NEEDED SO ASK ROUTINES CAN BE USED TO ASK ABOUT FILE NAME
  F.TF==1B2	;TTY/FIL FLAG, 1 ON FIRST CHAR TO FILE
		; USED FOR DEBUG FEATURE TO PRINT <> ON TTY
		; SET BY TTYPUT ROUTINE, CLEARED BY FILPUT ROUTINE
  F.CTY==1B3	;CTY IS AN ACCEPTABLE OCTAL NUUMBER IF 1
		; SET BY ASKLIN, CLEARED BY ASKDEC,ASKOCT,ASKNUM ROUTINES
  F.FLF==1B4	;LAST CHAR ON FILE WAS LINE FEED
		; USED TO PRECEDE NEXT CHAR WITH ; TO MAKE A COMMENT IN FILE
		; IF F.COM IS ALSO ON.  SET, CLEARED AND LOOKED AT BY FILPUT ONLY
  F.COM==1B5	;MAKE ALL LINES TO FILE BE COMMENT IF THIS FLAG IS ON
		; USES F.FLF TO KNOW WHEN TO PUT ; OUT
		; SET AND CLEARED BY FILCOM AND TTYIN ROUTINES ONLY
		; LOKED AB BY FILPUT ROUTINE
  F.LPAR==1B6	;LEFT PAREN SEEN BY TTYOUT IN TTY OUTPUT STREAM.
		; USED TO SUPPRESS PROMPTING IF IN SHORT HELP MODE
		; CLEARED WHEN RIGHT PAREN SEEN.  SET, CLEARED,
		; AND USED BY TTYOUT ROUTINE ONLY.
  F.LBRK==1B7	;LEFT BRACKET SEEN BY TTYOUT IN TTY OUTPUT STREAM
		; YSED TO SUPPRESS EXPLANATION UNLESS IN LONG MODE
		; SET, CLEARED AND TESTED BY TTYOUT ROUTINE ONLY
  F.CONZ==1B8	;CONTROL Z TYPED IN ON TTY, SET BY TTYGET
  F.EXP==1B9	;IN LSTEXP, SET IF EXPLAIN, CLEARED IF LIST
  F.HOPN==1B10	;SET IF FGEN EXPLAIN FILE IS OPEN FOR READING
  F.HRRD==1B11	;SET IF READING EXPLAIN FILE A SECOND TIME
		; IF FILE WAS OPEN, MAY START SEARCHING PAST THE ENTRY DESIRED.
		; AT END OF FILE, REREAD FROM THE BEGINNING ONCE.
  F.2DEC==1B12	;SET IF WANT AT LEAST TWO CHARS IN DECIMAL OUTPUT
  F.FHLC==1B13	;SET IF LOOKING FOR TAB AFTER TEXT IN FGEN HELP FILE
  F.PER==1B14	;SET IF A PERIOD, DOLLAR SIGN  OR PERCENT CAN BE PART OF SYMBOL
		; USED TO DISTINGUISH BETWEEN FILE NAMES AND SYMBOLS
  F.INFO==1B15	;SET BY ASKMNP TO INDICATE MORE INFO WILL FOLLOW M-N OR CTY
		; RESET BY ASKMN TO INDICATE END OF STRING EXPECTED AFTER M,M-N, OR CTY
  F.BANG==1B16	;ALLOW THE INPUT LINE TO CONTAIN A "!" WITHOUT TAKING
		;  IT AS A COMMENT
;RH(F) BITS
  F.1FH==1B35	;1ST RC10 ON CPU
  F.1RP==1B34	;1ST RH10/RP04 ON CPU
  F.1FS==1B33	;1ST RH10/RS04 ON CPU
  F.1DP==1B32	;1ST RP10 ON CPU
  F.1TX==1B31	;1ST TX01 ON CPU
  F.1T1==1B30	;1ST TM10 ON CPU
  F.1T2==1B29	;1ST TM02 ON CPU
  F.1D2==1B28	;1ST DX20 ON CPU
  F.1RN==1B27	;1ST RH20/RP20 ON CPU
  F.KONS==F.1FH+F.1RP+F.1FS+F.1DP+F.1TX+F.1T1+F.1T2+F.1D2+F.1RN
 F.NORN==1B28	;NO SUPPORT FOR RP20S
 F.NOT2==1B29	;NO SUPPORT FOR TM02/TM03
 F.NOT7==1B30	;NO SUPPORT FOR TM78
 F.NOTD==1B31	;NO SUPPORT FOR DX20 TAPES
 F.NOTX==1B32	;NO SUPPORT FOR DX10
 F.NORA==1B33	;NO SUPPORT FOR CI DISKS

N=1		;NUMERIC VALUE OF ASKED QUESTION.
		; ALSO USED TO SUBSTITUTE FOR * IN ALL STRINGS.
		; CAN BE LEFT JUSTIFIED SIXBIT.
		; YES ANSWERS ARE 1, NO ANSWERS ARE 0.
T1=2		;TEMPORARY AC. USUALLY ADR OF ASCIZ MESSAGE ON SUB CALL.
T2=T1+1		;FOR REMAINDER IN DIVISION
WD=4		;WORD AC ON CALLS TO GETWRD(LEFT JUSTIFIED SIXBIT)
B=5		;BYTE POINTER TO TEXT STRING
R=6		;INPUT AND OUTPUT RADIX
LV=7		;MODE OF ASKING QUESTIONS(-1=SHORT,0=PROMPT,1=LONG)
I=10		;INDEX FOR LOOP COUNTS
CH=11		;CHARACTER AC
I2=12		;SECOND INDEX FOR LOOP COUNTS
I3=13		;3RD INDEX FOR LOOP COUNTS
RH12=14		;=0 FOR RH10, =1 FOR RH20
P1=15		;"PERMANENT" ACS. THE SAVE ROUTINES DON'T EXIST,
P2=16		; USE AT GEN LEVEL FOR LOOP VARIABLES, ETC.
P=17		;PD POINTER

;SPECIAL ASCII CHARACTERS(NEVER CODE IN OCTAL SO CAN USE CREF):
C.RUB==177	;RUBOUT
C.ALT1==175	;OLD ALT MODES
C.ALT2==176	;OLD ALT MODE ON SOME TTYS
C.ESC==33	;MAP ALTS INTO ESCAPE
C.CONZ==32	;CONTROL Z
C.FF==14	;FORM FEED
C.CR==15	;CARIAGE RETURN
C.LF==12	;LINE FEED
C.CONC==3	;CONTROL C
C.TMFH==1	;CONTROL A IS TERMINATOR IN FGEN AUXILIARY HELP FILE

;STANDARD MAXIMUMS FOR QUESTIONS

SM.CPU==3	;MAXIMUM NUMBER OF CPU'S
SU.CPU==6	;MAX UNSUPPORTED CPUS
SM.DF==^D8	;MAXIMUM NUMBER OF DF10 DATA CHANNELS
SM.RC==2	;MAXIMUM NUMBER OF RC10S PER CHANNEL
SM.RP==3	;MAXIMUM NUMBER OF RP10S PER CHANNEL
SM.KPC==10	;MAXIMUM NUMBER OF KONTROLLERS PER CHANNEL
SM.JOB==777	;MAXIMUM NUMBER OF JOBS SYSTEM MAY INCLUDE
SM.PI==7	;MAXIMUM PI CHANNEL NUMBER
SM.AC==17	;HIGHEST AC NUMBER FOR HIGHEST-AC-TO-SAVE
SM.RTD==^D77	;MAXIMUM NUMBER OF REAL TIME DEVICES
SM.HPQ==^D15	;MAXIMUM NUMBER OF HIGH PRIORITY QUEUES
SM.CDR==2	;MAXIMUM NUMBER OF CDRS
SM.DTA==2	;MAXIMUM NUMBER OF DTA CONTROLLERS
SM.LPT==3	;MAXIMUM NUMBER OF LPTS
SM.PLT==2	;MAXIMUM NUMBER OF PLOTTERS
SM.PTY==^D510	;MAXIMUM NUMBER OF PTYS
SM.DL10==2	;MAXIMUM NUMBER OF DL10'S
SM.CONN==^D512	;MAXIMUM NUMBER OF CONNECTS
SM.RMCR==^D512	;MAXIMUM NUMBER OF REMOTE TTY'S
SM.KDUP==^D2	;MAXIMUM NUMBER OF DUP-11S ON A KMC-11
SM.DMRN==^D8	;Maximum number of DMR11s on a 2020
SM.RXK==^D2	;Maximum number of RX211 controllers on a 2020
SM.RXD==^D2	;Maximum number of RX02 drives on an RX02
SM.TTG==^D8	;MAXIMUM NUMBER OF TTY 8-LINE GROUPS
SM.68L==^D100	;MAXIMUM NUMBER OF LINES ON DC68
SM.MPI==^D16384	;MAXIMUM NUMBER OF PAGES SUPPORTED ON KL10
SM.XTC==4	;MAXIMUM NUMBER OF DA28C CHANNELS
SM.D78==^D8	;MAXIMUM NUMBER OF DAS78'S (IBM 360,370,2780 SUPPORT)
SM.D60==^D7	;MAXIMUM NUMBER OF DN60'S (IBM BSC INTERFACES)
SM.XTC==4	;MAXIMUM NUMBER OF DA28C CHANNELS
SM.DLP==2	;MAXIMUM NUMBER OF LINE PRINTER ON 1091 FRONT END
SM.DCR==1	;MAXIMUM NUMBER OF CARD READERS ON 1091 FRONT END
;DEFAULT VALUES OUTPUT BY MONGEN, MOSTLY FOR OLD SYMBOLS

IFNDEF MD.PG,<MD.P6==0>		;NO PDP 6
IFNDEF MD.2RR,<MD.2RR==1>	;ALWAYS 2 RELOCATION REGISTERS
IFNDEF MD.SEG,<MD.SEG==0>	;ALWAYS NO EXTRA SEGMENTS
IFNDEF MD.DDT,<MD.DDT==1>	;ALWAYS LOAD EDDT
IFNDEF MD.MOV,<MD.MOV==0>	;NO MOVIE
IFNDEF MD.C10,<MD.C10==1>	;CDR IS ALWAYS CR10
IFNDEF MD.DTC,<MD.DTC==0>	;NO PDP 6 DECTAPE
IFNDEF MD.TMC,<MD.TMC==0>	;NO PDP 6 MAGTAPE
IFNDEF MD.TWJ,<MD.TWJ==0>	;STANDARD VALUE FOR TMPCOR PARAMETERS
IFNDEF MD.TLJ,<MD.TLJ==0>	;...

	SUBTTL	MACROS AND DEFINITIONS FOR MONGEN'S MONGEN DIALOG

;THE FOLLOWING MACRO DEFINES ALL OF THE UNSUPPPORTED QUESTIONS.
;THE ORDER OF ENTRIES IS NOT IMPORTANT TO MONGEN, BUT IT DOES EFFECT
;DOCUMENTATION/CONTROL FILES WHICH USE THE "ALL" MODE.

;TO ADD AN UNSUPPORTED FEATURE, ADD AN "FT" LINE BELOW, THEN USE
;SKPFTT	FEATURE 	SKIP IF FT TRUE
;SKPFTF FEATURE		SKIP IF FT FALSE

	DEFINE	UNSUPPORTED,<
	XLIST
FT	CD20,<CD20 Unibus card-readers>
FT	CR10,<I/O bus card reader>
FT	CP10,<I/O bus card punch>
FT	CPUS,<More than supported number of CPUs>
FT	CPUTYP,<Unsupported CPU types>
FT	DA28,<DA28 Interprocessor link>
FT	DAS78,<DAS78 IBM interface>
FT	DMR,<DMR-11 synchronous line controller>
FT	DN60,<IBM 2780/3780/HASP communications>
FT	DC10,<DC10 data line scanner>
FT	DC68,<680I PDP-8 based terminal concentrator>
FT	DC72,<DC72 PDP-8 remote stations>
FT	DC75,<DC75-NP network>
FT	DC76,<DC76 Asynchronous Front End>
FT	DIS,<VP series displays>
FT	DN87,<DN87 DL10-based ANF front end>
FT	DTA,<DECtapes>
FT	DX10,<DX10 Tape controller>
FT	EXTCHN,<External channels>
FT	KASER,<KA Floating-point simulator>
FT	METER,<Software performance meter>
FT	PLT,<Plotters>
FT	PTP,<Paper-tape punch>
FT	PTR,<Paper-tape reader>
FT	RTRXPW,<Control ROUTER's transmit password>
FT	RC10,<RC10 controller for RD10 disk>
FT	RX20,<RX20 Floppy disk controller for 2020>
FT	TM10,<TM10 I/0 bus magtape controller>
	LIST
		>
;BUILD THE MONGEN SYMBOL TABLE.  EACH ENTRY IS OF THE FORM
;	$FEATURE:	SIXBIT/FEATURE/
;			XWD	FLAGS,,STRING
;
;WHERE THE SIGN BIT OF FLAGS INDICATES WHETHER TO ASK THE QUESTION, AND
;STRING IS THE ADDRESS OF THE ASCIZ ASKYN STRING USED TO ASK IT.

	DEFINE	FT(DEVICE,STRING),<
$'DEVICE:	EXP	SIXBIT	/DEVICE/
	XWD	0,[ASCIZ ~'DEVICE'(Y,N)['STRING']: ~]
		>

UNSTAB:	UNSUPPORTED
	UNSTBL==<.-UNSTAB>/2

;MACROS TO MAKE IT OBVIOUS WHEN WE FIDDLE WITH UNSUPPORTED STUFF
;

;SKIP IF FEATURE TEST TRUE
	DEFINE	SKPFTT(FTX),<SKIPL	$'FTX+1>

;SKIP IF FEATURE TEST FALSE
	DEFINE	SKPFTF(FTX),<SKIPGE	$'FTX+1>
IFNDEF MD.DCS,<MD.DCS==0>	;NO PDP 6 SCANNER
;BITS IN FEATURE TEST SWITCH TABLE

FS.VAL==1B0	;CURRENT VALUE MUST BE SIGN BIT

ZZ==1		;CURRENT BIT

FS.0==1B<ZZ>	;LEFT MOST BIT FOR CONFIGURATION FIELD

	DEFINE	FTSDEF(A),<
IRP A,<FS'A==1B<ZZ>	;ON IF DEFAULT ON FOR A
ZZ==ZZ+1
>>

	FTSDEF	<1070,1080,1090,1091,2020>

IFG ZZ-^D12,<PRINTX TOO MANY CONFIGURATIONS - MUST CHANGE FEATURE TEST TABLE>
;IO CHANNELS:
TTYCHN==0	;TTY INPUT AND OUTPUT CHANNEL
FILCHN==1	;FILE OUTPUT CHANNEL
FHLPCH==2	;FGEN AUXILIARY HELP FILE CHANNEL

;IO STATUS BITS:
IO.EOF==20000	;END OF FILE

;NUMBER OF I/O BUFFERS
NFILBF==2	;NUMBER OF BUFFERS FOR FILE OUTPUT
NFHLPB==2	;NUMBER OF BUFFERS FOR FGEN AUXILIARY HELP FILE

;OPDEFS:
OPDEF	PJRST	[JRST]		;EQUIVALENT TO PUSHJ POPJ PAIR
OPDEF	PJUMPE	[JUMPE]		;EQUIVALENT TO JUMPE [PJRST]
OPDEF	GETTAB	[CALLI 41]	;READ MONITOR TABLE
OPDEF	SAVE.	[CALLI 210]	;SAVE. UUO

;UUOSYM SYMBOLS

.GTRDV==135			;DEVICE PROGRAM IS RUN FROM
.GTRDI==136			;DIRECTORY PROGRAM IS RUN FROM
.GTRFN==137			;FILE PROGRAM IS RUN FROM
.GTRS0==145			;SFD PROGRAM IS RUN FROM
.PTPPN==2			;PPN OF THE PATH
.PTSFD==3			;BEGIN SFDS IN PATH BLOCK
.PTMAX==11			;LENGTH OF PATH BLOCK
SUBTTL	INITIALIZATION, AND DISPATCH TO PROPER GEN, CLOSE FILES

BEGINA:	HLRZ	16,.JBSA##	;GET TRUE .JBFF
	CAME	16,.JBFF	;SEE IF SAME
	JRST	BEGIN		;NO--MUST BE ^C START
	HRROI	T1,.GTRDV	;GET DEVICE WE RAN FROM
	GETTAB	T1,
	  SETZ	T1,		;ERROR, ZERO THE AC
	MOVEM	T1,RUNDEV	;STORE
	HRROI	T1,.GTRDI	;GET THE PPN WE RAN FROM
	GETTAB	T1,
	  SETZ	T1,		;ERROR. ZERO THE AC
	MOVEM	T1,RUNPPN	;STORE
	MOVEM	T1,RUNPTH+.PTPPN;STORE PPN IN PATH BLOCK TOO
	MOVSI	T2,-5		;SET UP AOBJN FOR SFD GETTABS

BEGINB:	HRROI	T1,.GTRS0(T2)	;GET AN SFD NAME
	GETTAB	T1,
	  JRST	BEGINC		;NO MORE SFD'S
	JUMPE	T1,BEGINC	;END OF SFD'S
	MOVEM	T1,RUNPTH+.PTSFD(T2)	;STORE THE SFD NAME IN THE PATH BLOCK
	AOBJN	T2,BEGINB	;GET NEXT SFD

BEGINC:	SETZM	RUNPTH+.PTSFD(T2);ZERO NEEDS TO TERMINATE THE PATH BLOCK
	MOVEI	T1,RUNPTH	;GET ADDRESS OF PATH BLOCK
	SKIPE	RUNPTH+.PTSFD	;ANY SFDS?
	MOVEM	T1,RUNPPN	;YES. POINT TO PATH BLOCK FOR LOOKUP

BEGIN:	RESET			;RESET IO DEVICES
	AOS	.JBFF		;ADVANCE .JBFF TO FLAG BEGINA THAT AC'S WERE CLOBBERED
	MOVE	P,[IOWD MP.PDL,PDLIST]	;RESET PD PTR, SINCE HERE ON IO ERRORS
				; FROM ROUTINE DEEP IN STACK
	SETZB	F,VARBEG	;CLEAR ALL FLAGS AND VARIABLE AREA
				; EXCEPT SAVLV WHERE VERBOSCITY
				; LEVEL IS SAVED AND DEBUG AND HELPF
	MOVE	LV,SAVLV	;SETUP HELP LEVEL FOR NEXT QUESTION
				; FROM LONG TERM VALUE(INITIALLY PROMPT)
				; ^C START REMEMBERS LAST PERMANENT LEVEL
				; SINCE SAVLV IS NOT CLEARED
	MOVE	T1,[XWD VARBEG,VARBEG+1]
	BLT	T1,VAREND	;CLEAR VARIABLE AREA
	INIT	TTYCHN,1	;TTY IN LINE MODE
	SIXBIT	/TTY/
	XWD	TOBUF,TIBUF	;OUTPUT,INPUT BUFFER HEADERS
	  RJRST	<EREXIT	<Cannot INIT TTY>,,>	;TYPE ? INTERNAL ERR AND EXIT
	AOSLE	HELPF		;ALREADY TOLD USER ABOUT HELP?
	JRST	BEGINR		;YES, SKIP THIS
	MOVSI	N,-UNSTBL	;POINT TO TABLE
	SETZ	N+1,		;CLEAR ACCUMULATED FLAGS
BEGINP:	IOR	N+1,UNSTAB+1(N)	;SEE IF THIS IS ON
	AOJ	N,		;2 WORD ENTRIES
	AOBJN	N,BEGINP	;LOOP ON
	JUMPGE	N+1,BEGINQ	;ALL IS WELL, JUST ASK FOR HELP
	TTYOUT	<@@			CAUTION@
	This MONGEN includes dialog for UNSUPPORTED monitor options.
    Digital may not support a monitor generated with such code enabled.@@>
BEGINQ:	PUSHJ	P,TTYHLP	;NO, ASK USER FOR LEVEL OF VERBOSITY WITH /HELP
BEGINR:	TLZ	F,(F.CONZ)	;CLEAR CONTROL Z TYPED FLAG
	SKIPN	N+1,RUNDEV	;SKIP IF DEVICE FROM WHICH MONGEN WAS RUN
	MOVSI	N+1,'DSK'	;SPECIFIED, ELSDE START WITH DSK
	SETZB	N,N+2		;CLEAR MODE AND BUFFER HEADERS
	MOVEM	N+1,FGDEV	;STORE DEVICE IN CASE WINS
	OPEN	FILCHN,N	;OPEN DEVICE
	  JRST	FNDF1		;NO SUCH DEVICE?
	MOVE	N,FHNAME	;NAME OF FGEN HELP FILE
	HLLZ	N+1,FHNAME+1	;AND EXT
	MOVE	N+3,RUNPPN	;PPN FROM WHICH MONGEN WAS RUN
	MOVEM	N+3,FGPPN	;SAVE IN CASE WINS
	LOOKUP	FILCHN,N	;SEE IF FOUND HELP FILE
	  JRST	FNDF1		;NO, TRY SYS
	JRST	FNDFOK		;FOUND OUR HELP FILE
FNDF1:	MOVSI	N+1,'SYS'	;TRY DEVICE SYS
	MOVEM	N+1,FGDEV
	SETZB	N,N+2
	OPEN	FILCHN,N	;OPEN SYS
	  JRST	FNDF2		;NO SYS?
	MOVE	N,FHNAME	;NAME OF HELP FILE
	HLLZ	N+1,FHNAME+1	;AND EXT
	SETZB	N+3,FGPPN	;CLEAR PPN
	LOOKUP	FILCHN,N	;SEE IF FO[UND HELP FILE
	  JRST	FNDF2		;NO, GIVE UP
	JRST	FNDFOK		;OK, USE SYS VERSION
FNDF2:	SETZM	FGDEV		;CLEAR DEVICE SO ALWAYS FAILS
	TTYOUT	<%Can't find FGEN.HLP@>
FNDFOK:	ASKLST	<Which GEN(HDW,NET,F,MUNGEN)[
HDW to define hardware configuration
NET to define network configuration
F to define software features
MUNGEN to include UNSUPPORTED questions in the other dialogs]>
	TLNE	F,(F.CONZ)	;DID USER TYPE CONTROL Z?
	EXIT			;YES, EXIT TO MONITOR
	MOVEM	N,WCHGEN	;STORE WHICH GEN(0=HDW, 1=NET, 2=F, 3=MONGEN)

	CAIN	N,3		;MONGEN?
	 JRST	MUNGEN		;YES, DO MUNGEN STUFF

;LOOP TO ASK FOR FILE UNTIL SUCCESSFUL ENTER CAN BE DONE.  SO INIT VARIABLES.
ASKFIL:	MOVSI	T1,(SIXBIT /DSK/) ;ASSUME DSK
	MOVEM	T1,OUTDEV	;IF USER DOES NOT SPECIFY DEVICE
	MOVE	N,WCHGEN	;THE GEN NUMBER(0-2)
	MOVE	N,FILTAB(N)	;DEFAULT FILE NAME FOR THIS GEN
				; HDWCNF,NETCNF,F
	HLLZM	N,WCHNAM	;STORE NAME OF THIS GEN(NET,MON,F)
	MOVEM	N,OUTNAM	;ALSO SETUP DEFAULT FILE NAME FOR THIS GEN
	MOVSI	T1,(SIXBIT /MAC/) ;ASSUME EXTENSION OF MAC
	MOVEM	T1,OUTEXT	;FOR FILE EXTENSION
	SETZM	OUTDAT		;CLEAR DATE ARG
	SETZM	OUTPPN		;AND PROJECT,PROGRAMMER ARG
	ASKSTR	<Output(DSK:*.MAC)>,OUTNAM ;ASK FOR FILE SPEC
	MOVEI	WD,0		;SET WORD VALUE TO 0 AS FLAG THAT NO SPEC
	JUMPE	CH,OPNDEV	;IF CHARACTER IS 0, JUST CR TYPED
	PUSHJ	P,GETWRD	;GO GET WHAT MAY BE DEV: OR FILENAME
	CAIE	CH,":"		;IS BREAK DEVICE SEPARATOR?
	JRST	OPNDEV		;NO, SAVE FILE NAME AND GO INIT DEVICE
	MOVEM	WD,OUTDEV	;YES, STORE USER SUPPLIED DEVICE NAME
	PUSHJ	P,GETWRD	;GET NEXT WORD USER TYPED(FILE NAME)
OPNDEV:	INIT	FILCHN,1	;INIT FILE CHANNEL IN ASCII LINE MODE
OUTDEV:	SIXBIT	/DSK/		;DEVICE NAME
	XWD	FOBUF,0		;OUTPUT BUFER HEADER
	  RJRST	<TTYOUT <? Device * not available@>,OUTDEV ;TYPE ERROR
		 JRST	ASKFIL>	;GO ASK FOR FILE SPEC AGAIN
	PUSH	P,.JBFF##	;SAVE JOBFF
	MOVEI	T1,FILBUF	;ADDR OF FILE BUFFERS
	MOVEM	T1,.JBFF	;SET UP JOBFF TO ALLOCATE OUR BUFFERS
	OUTBUF	FILCHN,NFILBF	;ALLOCATE BUFFERS
	POP	P,.JBFF		;RESTORE JOBFF
	JUMPE	WD,OUTDV0	;WAS NO FILE NAME TYPED?
	MOVEM	WD,OUTNAM	;STORE CUSTOMER SUPPLIED FILE NAME

OUTDV0:	CAIE	CH,"."		;NO, WELL BETTER BE EXTENSION NEXT
	JRST	OUTDV3		;NO, GO CHECK FOR BRACKET FOR PPN
	PUSHJ	P,GETWRD	;GO GET EXTENSION
	HLLM	WD,OUTEXT	;AND STORE FOR ENTER
OUTDV3:	JUMPE	CH,OUTDV4	;END OF LINE(CR=0)?
	CAIE	CH,"["		;NO, BETTER BE LEFT BRACKET FOR PPN
OUTDV1:	JRST	FMTERR		;NO, INCREASE VERBOSITY LEVEL AND ASK AGAIN
	PUSHJ	P,GETOCT	;GET PROJ NUMBER
	CAIE	CH,","		;IS BREAK COMMA?
	JRST	FMTERR		;NO, INCREASE VERBOSITY AND ASK AGAIN
	HRLZM	N,OUTPPN	;YES, STORE PROJECT NO.
	PUSHJ	P,GETOCT	;GET PROG NUMBER
	JUMPE	CH,OUTDV2	;JUMP IF END OF LINE, END OF PPN
	CAIE	CH,"]"		;IS BREAK RIGHT BRACKET?
FMTERR:	RJRST	<TTYOUT	<? Not DEV:FILE.EXT[P,PN]@>
		AOJA	LV,ASKFIL>	;INCREASE LEV AND ASK AGAIN
OUTDV2:	HRRM	N,OUTPPN	;STORE PROG NUMBER
	JUMPE	CH,OUTDV4	;JUMP IF END OF LINE
	PUSHJ	P,GETWRD	;GET NEXT WORD
	JUMPN	WD,FMTERR	;BETTER NOT BE ANYTHING AFTER RIGHT BRACKET
	JUMPN	CH,FMTERR	;IS BREAK CR?
OUTDV4:	MOVE	N,OUTPPN	;GET PPN TYPED
	MOVEM	N,SAVPPN	;SAVE FOR LATER
	ENTER	FILCHN,OUTNAM	;TRY TO ENTER FILE ON DEVICE
	  RJRST	<HRRZ N,OUTEXT	;ENTER ERROR CODE FOR *
		 TTYOCT <? Enter error *@>,N
		 JRST ASKFIL>	;ASK FOR FILE NAME AGAIN
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
	TLO	F,(F.OFO!F.PER)	;FLAG THAT OUTPUT FILE IS NOW OPEN
				; SO FILPUT WONT BE A NO-OP
				; AND ALLOW PERIODS IN SYMBOLS
	MOVE	T1,WCHGEN	;ENTER OK, GET WHICH GEN THIS IS
	PUSHJ	P,@GENTAB(T1)	;DISPATCH TO PROPER GEN
				; HDWGEN, NETGEN, FGEN
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE USER TYPED /H<CR>
	FILCOM	<@END OF *>,OUTNAM
	HLLZ	N,OUTEXT	;EXTENSION OF FILE WRITTEN
	FILCOM	<.*@>,N
	MOVEI	CH,C.FF		;FORM FEED
	PUSHJ	P,FILPUT	;TO OUTPUT FILE
	CLOSE	FILCHN,		;CLOSE OUTPUT FILE
	TLZ	F,(F.OFO)	;FLAG THAT OUTPUT FILE IS NOT OPEN
				; SO FILPUT WILL BE A NO-OP
	STATZ	FILCHN,740000	;ANY ERRORS ON LAST BUFFER

;HERE ON ANY FILE ERRORS DURING EXECUTION
FILERR:	  RJRST	<TTYOUT <? File * error>,OUTNAM
		 GETSTS	FILCHN,N ;GET FILE STATUS FROM MONITOR
		 TLZ	N,-1	;MAKE SURE NO STUFF IN LH
		 TTYOCT	<*@>;OUTPUT STATUS NUMBER AND CR
		 JRST .+1>	;CONTINUE
	RELEASE	FILCHN,		;RELEASE FILE CHANNEL
	TTYOUT	<File >
	SKIPN	N,OUTDEV	;SKIP IF DEVICE SPECIFIED
	JRST	CLTY1		;NO, DONT TYPE DEVICE
	TTYOUT	<*:>,N
CLTY1:	TTYOUT	<*>,OUTNAM
	HLLZ	N,OUTEXT	;INCLUDE EXTENSION
	TTYOUT	<.*>,N
	SKIPN	N,SAVPPN	;SKIP IF PPN SPECIFIED
	JRST	CLTY2		;NO, DONT TYPE PPN
	PUSH	P,LV		;SAVE CURRENT HELP LEVEL
	MOVEI	LV,1		;ASSUME LONG SO PPN WILL PRINT
	HLRZS	N		;N=PROJECT
	TTYOCT	<[*,>,N
	HRRZ	N,SAVPPN	;N=PROGRAMMER
	TTYOCT	<*]>,N
	POP	P,LV		;RESTORE CURRENT HELP LEVEL
CLTY2:	MOVE	N,WCHGEN	;WHICH GEN RUN
	HLLZ	N,FILTAB(N)	;PICK UP NAME OF GEN
	TTYOUT	< Closed [*GEN finished]@@>,N ;ALSO WHICH GEN
	JRST	BEGIN		;GO BACK AND ASK FOR NEXT GEN
				; KEEP SAME HELP LEVEL AND DO NOT ASK /HELP
	SUBTTL	MUNGEN - DIALOG TO DEFINE MONGEN FEATURES

	COMMENT	@

If thou art in haste, remember the words of Mablung the seer, and the
Paths of the Dead....

		@

MUNGEN:	TTYOUT	<@@			CAUTION
    The MONGEN dialog alters MONGEN so that it includes dialog for devices
    not currently supported by Digital.  

    Digital may not support a monitor generated with such code enabled.@@>

MUNLUP:	ASKLST	<Mode(EXIT,ALL,INCLUDE,EXCLUDE,LIST)[
EXIT	Exits the MUNGEN configuration dialog
ALL	Asks about all known unsupported options
INCLUDE	Allows you to include a list of unsupported options by name
EXCLUDE	Allows you to exclude a list of unsupported options by name
LIST	Allows you to list unsupported option status]>
	PUSHJ	P,@[EXP	MUNXIT,MUNALL,MUNINC,MUNEXC,MUNLST](N)
	JRST	MUNLUP

;EXIT MUNGEN MODE
MUNXIT:	POP	P,(P)		;FIX STACK, NOT THAT IT MATTERS
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
	SETOM	HELPF		;MAKE SURE WE SAY WE'RE UNSUPPORTED
	SETZM	SAVLV		;RETURN TO 'PROMPT' MODE
	MOVE	T1,SAVBLK+1	;GET OUR NEW NAME
	SETNAM	T1,		;Ummm
	ASKYN	<Save(Y,N)[
Do you want to save this configured MONGEN on DSK:MUNGEN.EXE for later use]>
	JUMPE	N,BEGIN		;IF NOT, DON'T
	MOVE	LV,SAVLV
	SETOM	HELPF
	MOVEI	T1,SAVBLK	;POINT TO SAVE SPEC
	SAVE.	T1,		;SAVE OURSELF
	 HALT	.		;SIGH
	OUTSTR	[ASCIZ	/
[DSK:MUNGEN.EXE written]
/]
	JRST	BEGIN		;OFF WE GO.

SAVBLK:	SIXBIT	/DSK/
	SIXBIT	/MUNGEN/
	SIXBIT	/EXE/
	EXP	0,0,0
;SET ALL MODE
MUNALL:	MOVSI	I,-UNSTBL	;LENGTH OF UNSUPPORTED TABLE
MUNALP:	HRRZ	T1,UNSTAB+1(I)	;GET ADDRESS OF STRING
	PUSHJ	P,ASKZYN	;ASK
	SKIPN	N		;YES?
	 SKIPA	N,[ANDCAM T1,UNSTAB+1(I)] ;NO, CLEAR BIT
	MOVE	N,[IORM   T1,UNSTAB+1(I)];YUP, ENABLE QUESTION
	MOVSI	T1,(1B0)	;SO
	XCT	N		;DO WHAT WE'RE TOLD
	AOJ	I,		;BI-WORDS
	AOBJN	I,MUNALP	;DO FOR ALL OPTIONS
	MOVE	LV,SAVLV	;RESTORE HELP LEVEL
	POPJ	P,		;RETURN

;INCLUDE MODE
MUNINC:	MOVSI	N,'*  '		;ALLOW WILDCARDS
	ASKSTR	<Options(Name,Name...or "*")[
Enter one or more option names to be included, delimited by commas.@]>
	SETZ	WD,
	JUMPE	CH,MNIEND	;ALL DONE
MNILP1:	PUSHJ	P,GETWRD	;READ OPTION NAME
	JUMPN	WD,MNILP2	;LEGAL IF NON-ZERO
	CAIE	CH,"*"		;SEE IF WANT ALL
	 JRST	MNIERR		;ERROR
	ILDB	CH,B		;GET NEXT CHAR
	JUMPE	CH,SETOPT	;CLEAR ALL OPTIONS
	JRST	MNIERR		;ERROR IF NOT EOL
MNILP2:	PUSHJ	P,FNDOPT	;FIND THIS OPTION
	 JRST	MNIERR		;ERROR
	MOVSI	T1,(1B0)	;BIT
	IORM	T1,UNSTAB+1(I)	;SET IT FOR NAMED OPTION
	CAIN	CH,","		;BREAK ON COMMA
	 JRST	MNILP1		;COMMA,GET ANOTHER
	JUMPN	CH,MNIERR	;IF NOT EOL, ERROR
MNIEND:	JRST	MNEEND		;COMMON EXIT

MNIERR:	MOVE	N,WD		;GET LAST WORD
	TTYOUT	<@? Unknown option name "*"@>
	JRST	MUNINC		;TRY AGAIN
;EXCLUDE MODE
MUNEXC:	MOVSI	N,'*  '		;ALLOW WILDCARDS
	ASKSTR	<Options(Name,Name...or "*")[
Enter a list of option names to be excluded, delimited by commas@]>
	SETZ	WD,
	JUMPE	CH,MNEEND	;ALL DONE
MNELP1:	PUSHJ	P,GETWRD	;READ OPTION NAME
	JUMPN	WD,MNELP2	;LEGAL IF NON-ZERO
	CAIE	CH,"*"		;SEE IF WANT ALL
	 JRST	MNEERR		;ERROR
	ILDB	CH,B		;GET NEXT CHAR
	JUMPE	CH,CLROPT	;CLEAR ALL OPTIONS
	JRST	MNEERR		;ERROR IF NOT EOL
MNELP2:	PUSHJ	P,FNDOPT	;FIND THIS OPTION
	 JRST	MNEERR		;ERROR
	MOVSI	T1,(1B0)	;BIT
	ANDCAM	T1,UNSTAB+1(I)	;CLEAR IT FOR NAMED OPTION
	CAIN	CH,","		;BREAK ON COMMA
	 JRST	MNELP1		;COMMA,GET ANOTHER
	JUMPN	CH,MNEERR	;IF NOT EOL, ERROR
	JRST	MNEEND		;COMMON EXIT

MNEERR:	MOVE	N,WD		;GET LAST WORD
	TTYOUT	<@? Unknown option name "*"@>
	JRST	MUNEXC		;TRY AGAIN

;HELPER ROUTINE TO FIND AN OPTION NAME BLOCK (WD) IN UNSTAB
;RETURNS OFFSET TO FIRST WORD OF ENTRY IN I

FNDOPT:	MOVSI	I,-UNSTBL	;TABLE LENGTH
FNDOPL:	CAMN	WD,UNSTAB(I)	;MATCH THIS ENTRY
	 JRST	CPOPJ1		;YES, RETURN I
	AOJ	I,		;BIWORDS
	AOBJN	I,FNDOPL	;LOOP
	POPJ	P,		;ERROR RETURN

;HELPER ROUTINES TO SET/CLEAR ALL OPTIONS

SETOPT:	SKIPA	WD,[IORM T1,UNSTAB+1(I)]
CLROPT:	 MOVE	WD,[ANDCAM T1,UNSTAB+1(I)]
	MOVSI	I,-UNSTBL	;TABLE LENGTH
	MOVSI	T1,(1B0)	;BIT
OPTXXL:	XCT	WD		;SET/CLEAR
	AOJ	I,		;BIWORDS
	AOBJN	I,OPTXXL	;LOOP

MNEEND:	MOVE	LV,SAVLV
	TTYOUT	<@>
	POPJ	P,		;DONE
;LIST MODE
MUNLST:	MOVSI	I,-UNSTBL	;LENGTH OF TABLE
	TTYOUT	<
Option	 State		Option	 State		Option	 State@>
MUNLLP:	MOVE	N,UNSTAB(I)	;GET OPTION NAME
	TTYOUT	<*	>
	SKIPGE	UNSTAB+1(I)	;SET?
	 JRST	MUNLL1		;YES
	TTYOUT	< Excluded>
	JRST	MUNLL2		;NO
MUNLL1:	MOVSI	N,'*  '		;MAKE INCLUDED ENTRIES STICK OUT
	TTYOUT	<*Included>
MUNLL2:	HRRZ	N,I		;GET COLUMN
	LSH	N,-1		;MAKE TABLE INDEX INTO ITEM INDEX
	IDIVI	N,3		;COLUMNS
	CAIE	N+1,2		;IF COL 3, NEW LINE
	 JRST	[TTYOUT	<	>
		 JRST	MUNLL3]	;0-1
	TTYOUT	<@>
MUNLL3:	ADDI	I,1		;BIWORDS
	AOBJN	I,MUNLLP	;TRY ALL
IFN	UNSTBL-<<UNSTBL/3>*3>,<	;IF LAST LINE NOT FULL, END IT
	TTYOUT	<@>
>
	TTYOUT	<@>		;BLANK LINE
	MOVE	LV,SAVLV
	POPJ	P,
SUBTTL	FGEN - DIALOG TO DEFINE SOFTWARE FEATURES

FGEN:	FILOUT	<UNIVERSAL	F - SOFTWARE FEATURE TEST FILE OUTPUT BY MONGEN DIALOG@@@>
	MOVEI	N,VERSION	;PUT MONGEN VERSION IN FILE FOR COMMON TO CHECK
	FILOUT	<INTERN	M.F@M.F==*@XLIST@>,N	;OUTPUT TO FILE

;HERE TO FIND OUT WHAT TYPE OF SYSTEM
	SKPFTT	CPUTYP		;UNSUPPORTED CPUTYPES
	 JRST	FGENCP		;NO, USE REGULAR QUESTION
	ASKLST	<Feature set(KIFULL,KLFULL,KSFULL)[
KIFULL Includes all Tops-10 features supported for KI10 based systems
KLFULL	Same as KIFULL but for KL10 based systems
KSFULL  Same as KIFULL but for KS10 based systems]>
	JRST	FGENCZ		;OK
FGENCP:	ASKLST	<Feature set(KLFULL,KSFULL)[
KLFULL Includes all Tops-10 features supported for KL10 based systems
KSFULL  Same as KLFULL but for KS10 based systems]>
FGENCZ:	PUSH	P,.JBFF		;SAVE JOBFF SO WILL REUSE SPACE EVERY RERUN OF FGEN
;HERE TO READ HELP FILE AND ESTABLISH SWITCHES AND THEIR BEGINNING VALUES

	PUSH	P,ASKTAB(N)	;SAVE TYPE OF SYSTEM IN SIXBIT
	MOVE	T1,.JBFF	;FIRST AVAILABLE LOCATION FOR SWITCH TABLE
	HRLI	T1,T1		;ALWAYS INDEXED BY T1
	MOVEM	T1,FTTAB	;STORE POINTER TO TABLE

;HERE TO FIND NEXT SWITCH IN FILE

FSETDF:	HRRZ	T1,.JBFF	;SWITCH TABLE ADDRESS
	ADDI	T1,MP.FTA	;ADD SIZE OF SWITCH TABLE
	CAMG	T1,.JBREL##	;IN BOUNDS?
	JRST	FSETD0		;YES,PROCEED
	CORE	T1,		;NO, GET MORE CORE
	  RJRST	<EREXIT	<Insufficient user core@>,,>
FSETD0:	FHLPOA	FT,FTABEN	;POSITION FILE AT NEXT SWITCH
	MOVE	T1,[POINT 6,WD,11] ;BYTE POINTER TO BUILD SWITCH NAME
	SETZ	WD,		;START WITH FRESH AC

FSETD1:	PUSHJ	P,FHLPRC	;GET NEXT CHAR FROM FILE
	JUMPE	CH,FSETDN	;JUMP IF END OF FILE, END OF NAME
	CAIN	CH,"("		;SKIP IF NOT END OF NAME
	JRST	FSETDN		;JUMP IF FOUND BEGINNING OF SYSTEMS FOR DEFAULT ON
	CAIL	CH,"A"		;SKIP IF NOT A LETTER
	CAILE	CH,"Z"		;SKIP IF A LETTER
	SKIPA			;NOT A LETTER, SEE IF A NUMBER
	JRST	FSETD5		;A LETTER IS PART OF A SWITCH
	CAIL	CH,"0"		;SKIP IF NOT A NUMBER EITHER
	CAILE	CH,"9"		;SKIP IF A NUMBER
	SKIPA			;NOT EITHER, TRY SPECIAL CHARACTER
	JRST	FSETD5		;A NUMBER IS PART OF A SWITCH
	CAIE	CH,"$"		;SKIP IF "$"
	CAIN	CH,"%"		;SKIP IF NOT "%"
	JRST	FSETD5		;EITHER CHARACTER IS OK
	CAIE	CH,"."		;SKIP IF "."
	JRST	FSETD4		;NOT A NUMBER,LETTER OR ($,%,.),ASSUME END
FSETD5:	SUBI	CH,"0"-'0'	;CONVERT TO SIXBIT
	TLNE	T1,770000	;NO, MORE CHARS IN NAME, SKIP IF MORE THAN SIX
	IDPB	CH,T1		;STORE CHAR IN NAME
	JRST	FSETD1		;AND LOOP

FSETDN:	MOVEM	WD,@.JBFF	;STORE NAME IN SWITCH TABLE
FSETD2:	PUSHJ	P,GETWRF	;GET NEXT SYSTEM TYPE FOR WHICH SHOULD BE ON
	CAMN	WD,(P)		;SKIP IF NOT THIS TYPE OF SYSTEM
	JRST	FSETDO		;YES, TURN SWITCH ON
	CAIE	CH,")"		;SKIP IF END OF LIST OF SYSTEMS
	JRST	FSETD2		;NO, SEE IF NEXT IS OUR TYPE
	JRST	FSETD3		;YES, MUST BE OFF
;HERE IF SWITCH IS TO BE ON FOR THIS TYPE OF SYSTEM

FSETDO:	MOVSI	WD,400000	;SET SIGN BIT FOR CURRENT VALUE
	IORM	WD,@.JBFF	;STORE IN TABLE

	JRST	FSETD3		;MOVE TO NEXT SWITCH
FSETD4:	MOVEM	WD,@.JBFF	;STORE SWITCH NAME AND VALUE OFF
FSETD3:	AOS	.JBFF		;BUMP POINTER TO NEXT SWITCH
	JRST	FSETDF		;AND KEEP READING SWITCHES
;HERE WHEN NO MORE SWITCHES TO BE FOUND

FTABEN:	MOVE	T1,.JBFF	;END OF TABLE SO FAR
	HRLI	T1,N		;PLUS N FOR INDEXING TO ADD ENTRIES
	MOVEM	T1,FTADD	;STORE POINTER FOR ADDING ENTRIES
	SETZM	(T1)		;CLEAR EXTRA SPACE
	HRRZI	WD,1(T1)
	HRL	WD,T1		;MAKE BLT PTR
	BLT	WD,MP.FTA-1(T1)	;CLEAR THE SPACE
	MOVEI	T1,MP.FTA(T1)	;SAVE SOME SPACE FOR ADDING
	MOVEM	T1,.JBFF	;AND STORE THE NEW JOBFF
	HRRZ	WD,FTTAB	;LOCATION OF BEGINNING OF TABLE
	SUB	WD,T1		;MINUS LOC OF END+1=-LENGTH OF TABLE
	MOVEM	WD,FTLEN	;STORE MINUS LENGTH OF TABLE
	POP	P,(P)		;GET RID OF SYSTEM TYPE

;HERE TO ASK IF WANT STANDARD SETTING
ASKSTD:	ASKLST	<Standard setting(YES,NO,LIST,EXPLAIN)[
Standard values for all feature test switches for your configuration]>
	JUMPE	N,FNDSTD	;JUMP IF WANT STANDARD VALUES
	TTYOUT	<@Only standard settings have been tested by DEC
all other settings may produce incorrect operation. @@>
	SOJE	N,ASKFSD	;JUMP IF SAID NO
	PUSHJ	P,LSTEXP	;LIST OR EXPLAIN FEATURE TEST SWITCHES
	JRST	ASKSTD		;NOW ASK AGAIN ABOUT STANDARD SETTING
;HERE TO ASK FOR SWITCHES
ASKFSD:	BTHOUT	<Type "switch,value"(or LIST or EXPLAIN)[
For any feature test switch to define,
type "switch,value", value=0 for off or -1 for on, or
type LIST or EXPLAIN to list or explain switches.
Type one per line, extra carriage return when through.]@@>

FSDLOP:	PUSHJ	P,TTYIN		;GET NEXT LINE
	  JRST	ASKFSD		;/HELP TYPED, ASK AT PROPER HELP LEVEL
	JUMPE	CH,FSDEND	;JUMP IF END OF LINE
	PUSH	P,B		;SAVE POSITION BEFORE SWITCH
	PUSHJ	P,GETWRD	;GET SWITCH NAME
	POP	P,T1		;POSITION BEFORE READING SWITCH
	HLRZ	N,WD		;N=BEGINNING OF WORD
	TRZ	N,77		;CLEAR OUT LOWER CHAR
	CAIN	N,'FT '		;SKIP IF NOT "FT..."
	JRST	FSDLP0		;YES, DO THIS SWITCH
	MOVE	B,T1		;RESTORE BYTE POINTER TO BEFORE KEYWORD
	MOVEI	T1,[ASCIZ .(,LIST,EXPLAIN).] ;FIRST COMMA TO MAKE N COME OUT RIGHT
	PUSHJ	P,SETASK
	PUSHJ	P,FNDASK	;SEE IF LIST OR EXPLAIN
	  JRST	ASKFSD
	PUSHJ	P,LSTEXP	;DO LIST OR EXPLAIN
	JRST	ASKFSD		;AND BEGIN ASKING AGAIN

FSDLP0:	CAIE	CH,","		;SKIP IF FOLLOWED BY COMMA
	JRST	FSDERR		;JUMP IF IMPROPER FORMAT
	TLZ	WD,777700	;CLEAR "FT"
	JUMPE	WD,FSDERR	;JUMP IF NO SWITCH NAME
	PUSHJ	P,FNDSWT	;FIND SWITCH IN TABLE, RETURN INDEX IN N
	PUSH	P,WD		;SAVE SWITCH NAME
	PUSH	P,T1		;SAVE INDEX IN TABLE, EVEN IF NEW SWITCH
	PUSHJ	P,GETDEC	;GET VALUE
	JUMPE	CH,FSDLP2	;JUMP IF END OF LINE FOUND
	CAIE	CH,"-"		;SKIP IF FOUND MINUS SIGN
	JRST	FSDERR		;NO, ILLEGAL FORMAT
	PUSHJ	P,GETDEC	;GET ACTUAL VALUE
	JUMPN	CH,FSDERR	;ERROR IF NOT END OF LINE NOW
FSDLP2:	POP	P,T1		;RESTORE INDEX IN TABLE OF SWITCH
	POP	P,WD		;RESTORE SWITCH NAME IN CASE NEW
	JUMPGE	T1,FSDNEW	;JUMP IF NEW SWITCH
	MOVSI	T2,(FS.VAL)	;BIT FOR CURRENT VALUE
	ANDCAM	T2,@FTTAB	;TURN VALUE OFF
	SKIPE	N		;SKIP IF 0 SPECIFIED
	IORM	T2,@FTTAB	;NO, TURN VALUE ON
	JRST	FSDLOP		;LOOP FOR ALL SWITCHES USER TYPES
;HERE IF USER TYPED NEW SWITCH, MAKE SURE AND IF SO OUTPUT SWITCH DIRECTLY
FSDNEW:	MOVSI	T1,(FS.0)	;LEFT MOST DEFAULT BIT FOR SWITCH ENTRY
	MOVN	T2,CNFIND	;INDEX OF CONFIGURATION IN CNF TABLES
	LSH	T1,(T2)		;POSITION BIT FOR THIS CNF
	TDO	T1,WD		;ADD IN SWITCH NAME
	SKIPE	N		;SKIP IF SWITCH IS OFF
	TLOA	T1,(FS.VAL)	;SWITCH IS ON, SET VALUE BIT
	TLZ	T1,777700	;SWITCH IS OFF, CLEAR VALUE AND DEFAULT
	MOVE	N,WD		;N=SWITCH NAME
	TLO	N,'FT '		;ADD BACK "FT"
	PUSH	P,T1		;SAVE NEW SWITCH ENTRY
	ASKYN	<%New switch *(Y,N)[if Y, keep switch, else ignore it]>
	POP	P,T1		;RESTORE NEW SWITCH TABLE ENTRY
	JUMPE	N,ASKFSD	;JUMP IF IGNORE THE SWITCH
;HERE TO ADD SWITCH TO TABLE IF POSSIBLE
	MOVSI	N,-MP.FTA	;LENGTH OF EXTENDABLE TABLE
	SKIPE	@FTADD		;SKIP IF FOUND EMPTY PLACE
	AOBJN	N,.-1		;NO, KEEP LOOKING
	JUMPGE	N,FSDFUL	;JUMP IF EXTENDABLE TABLE IS FULL
	MOVEM	T1,@FTADD	;STORE NEW SWITCH IN TABLE
	JRST	ASKFSD		;GO BACK FOR MORE
FSDFUL:	FILSTR	<XP *@>
	JRST	ASKFSD

FSDERR:	TTYOUT	<? Not "switch,value" or keyword@>
	AOJA	LV,ASKFSD	;ASK AGAIN WITH NEW HELP LEVEL

FSDEND:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
ASKFSA:	ASKYN	<Set each switch(Y,N)[List each switch with its current value and ask for new value]>
	JUMPE	N,FSAEND	;JUMP IF NO
	HRLZ	T1,FTLEN	;AOBJN PTR TO SWITCHES

FSALOP:	SKIPN	N,@FTTAB	;N=SWITCH ENTRY
	JRST	FSAEN2		;END OF TABLE
	LSH	N,^D12		;N=SWITCH NAME
	PUSH	P,N		;SAVE NAME OF SWITCH IN CASE LOOP
	PUSH	P,T1		;SAVE AOBJN PTR
FSALP0:	MOVE	N,-1(P)		;RESTORE NAME OF SWITCH IN CASE LOOPING
	MOVE	T1,(P)		;RESTORE AOBJN PTR IN CASE LOOPING
	SKIPL	@FTTAB		;SKIP IF SWITCH IS ON
	JRST	FSALP1		;NO, ITS OFF
	ASKLST	<FT*,-1(ON,OFF,LIST,EXPLAIN,END)>
	JRST	FSATST
FSALP1:	ASKLST	<FT*,0(ON,OFF,LIST,EXPLAIN,END)>
FSATST:	MOVE	T1,(P)		;RESTORE AOBJN PTR
	CAIN	N,4		;NO SKIP IF END TYPED
	JRST	FSAEN1		;YES, DO NO MORE
	SOJG	N,FSALEX	;JUMP IF LIST OR EXPLAIN
	MOVSI	T2,(FS.VAL)	;VALUE BIT
	ANDCAM	T2,@FTTAB	;TURN VALUE OFF
	CAIE	N,0		;SKIP IF OFF TYPED
	IORM	T2,@FTTAB	;TURN SWITCH ON
	POP	P,T1		;RESTORE AOBJN PTR
	POP	P,N		;GET RID OF NAME ON STACK
FSAEN2:	AOBJN	T1,FSALOP	;LOOP FOR ALL SWITCHES IN TABLE
	JRST	FSAEND

FSAEN1:	POP	P,T1		;RESTORE AOBJN PTR
	POP	P,N		;GET RID OF NAME ON STACK
FSAEND:	JRST	FNDSTD

FSALEX:	PUSHJ	P,LSTEXP	;DO LIST OR EXPLAIN
	JRST	FSALP0		;AND REASK ABOUT THIS SWITCH

;HERE TO CREATE FGEN OUTPUT FILE
FNDSTD:	FILOUT	<@LIST@>
	TLZ	F,(F.HOPN)	;CLEAR OPEN FLAG, HEADER IS AT BEGINNING

;HERE TO POSITION FGEN HELP FILE AT HEADER
	FHLPOS	HEADER,FNDSTE
	PUSHJ	P,FHLPFL	;COPY HEADER TO OUTPUT FILE
	JRST	FNDST1		;GO DO THE FILE

;HERE IF CANT FIND HEADER
FNDSTE:	TTYOUT	<% Can't find file header in help file@>

;HERE TO OUTPUT SWITCHES FROM TABLE
FNDST1:	HRLZ	T1,FTLEN	;AOBJN PTR TO SWITCH TABLE

STDOUT:	SKIPN	N,@FTTAB	;N=SWITCH ENTRY
	JRST	STDOUL		;IGNORE 0 ENTRIES
	PUSH	P,T1		;SAVE AOBJN PTR
	TLZ	N,777700	;CLEAR JUNK
	TLO	N,'FT '		;AND MAKE FT...
	PUSH	P,N		;SAVE NAME OF SWITCH FOR COMMENT
	MOVE	N,(P)		;REMEMBER SWITCH NAME
	FILOUT	<XP *,>
	MOVE	T1,-1(P)
	SKIPL	@FTTAB		;SKIP IF SWITCH ON
	JRST	STDOU1		;NO, ITS OFF
	FILOUT	<-1>
	JRST	STDOU2
STDOU1:	FILOUT	<0>
;HERE TO COPY TEXT FROM HELP FILE ABOUT THIS SWITCH
STDOU2:	POP	P,WD		;RESTORE NAME OF SWITCH TO SEARCH AUX FILE
	FHLPOS	*,STDOU3
	PUSHJ	P,FHLPFC	;OUTPUT TEXT AS COMMENT
STDOU3:	FILOUT	<@>
	POP	P,T1		;RESTORE AOBJN PTR
STDOUL:	AOBJN	T1,STDOUT	;LOOP FOR ALL SWITCHES IN TABLE

FEND:	FILOUT	<	IF2 <PURGE XP,XPL,XPP>@@	END>
	POP	P,.JBFF		;RESTORE ORIGINAL JOBFF
	POPJ	P,
SUBTTL	HDWGEN - DIALOG TO DEFINE HARDWARE CONFIGURATION

HDWGEN:	FILOUT	<SUBTTL HDWCNF - HARDWARE CONFIGURATION DEFINITION FILE OUTPUT BY MONGEN@@@>
	FILOUT	<DEFINE XP(A,B),<A==:B>@@@>
	MOVEI	N,EDITNO	;MONGEN<=>COMMON "VERSION" NUMBER
	FILOUT	<XP M.GEN,*@>,N	;OUTPUT TO FILE


	PUSHJ	P,ASKSYS	;FIND OUT WHAT TYPE OF SYSTEM
	FILOUT	<XP M.KI10,*@>,M.P10I
	FILOUT	<XP M.KL10,*@>,M.KL10
	FILOUT	<XP M.KS10,*@>,M.KS10
	FILOUT	<XP M.1070,*@>,M.1070
	FILOUT	<XP M.1080,*@>,M.1080
	FILOUT	<XP M.1090,*@>,M.1090
	FILOUT	<XP M.1091,*@>,M.1091
	FILOUT	<XP M.2020,*@>,M.2020
	SKIPN	N,M.2020
	SKIPE	N,M.1091
	JRST	HDWGN1
	MOVEI	N,SM.CPU
	SKPFTF	CPUS		;UNSUPPORTED CPUS?
	 MOVEI	N,SU.CPU	;YES, USE UNSUPPORTED NUMBER
	ASKDEC	<Cpu's(1,1-*)[Total number of cpu's in the system]>
HDWGN1:	MOVEM	N,M.CPU
	FILOUT	<XP M.CPU,*@>,M.CPU


ASKNAM:	ASKSTR	<System name[24 characters or less]>
	CAILE	N,^D24		;24 OR LESS?
	RJRST	<TTYOUT <% More than 24 characters@>
		 JRST	ASKNMA>
ASKNMA:	MOVEI	N,0		;STORE 0 TO MAKE SURE ONLY 24 CHARS OUTPUT
	DPB	N,[POINT 7,ASCSTR+4,34]
	MOVSI	N,'*  '		;IN CASE "*" IS IN SYSNAM
	FILSTR	<DEFINE	SYSNAM
<	ASCIZ	&*&>@>
ASKDAT:	DATE	T1,		;GET TODAYS DATE
	IDIVI	T1,^D12*^D31	;YEAR + DAYS IN THIS YEAR
	ADDI	T1,^D64		;1964 IS YEAR 0
	PUSH	P,T1		;SAVE YEAR
	MOVE	T1,T2		;NO. DAYS IN CURRENT YEAR
	IDIVI	T1,^D31		;T1=MONTH-1, T2=DAY OF MONTH-1
	PUSH	P,T2		;SAVE DAYS-1 OF MONTH
	MOVEI	N,1(T1)		;MONTH (1-12)
	FILOUT	<DEFINE	SYSDAT> ;START MACRO DEFINITION IN FILE
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET TO FILE, CRLF
	FILDC2	<ASCIZ &*>,N		;OUTPUT MONTH
	MOVEM	N,M.MON		;SAVE FOR SYMBOL OUTPUT TOO
	POP	P,T1		;DAYS-1 IN MONTH
	MOVEI	N,1(T1)		;DAY OF MONTH(1-31)
	FILDC2	<-*>,N		;OUTPUT TO FILE
	MOVEM	N,M.DAY		;SAVE FOR SYMBOL OUTPUT TOO
	POP	P,N		;YEAR(64-99)
	FILDC2	<-*&>,N		;OUTPUT TO FILE
	MOVEM	N,M.YEAR	;SAVE FOR SYMBOL OUTPUT TOO
	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET,CRLF
	FILOUT	<XP M.MON,*@>,M.MON
	FILOUT	<XP M.DAY,*@>,M.DAY
	FILOUT	<XP M.YEAR,*@>,M.YEAR

ASKSER:	SETZB	I,CPU		;SET LOOP COUNTER TO 0

;LOOP TO ASK FOR SERIAL NUMBERS FOR ALL CPUS IN SYSTEM
ASKSLP:	ASKDEC	<CPU* serial #(1-10000)>,I ;ASK FOR CPUN
	MOVEM	N,M.C0SN(I)	;SAVE FOR CPU1 CHECK
	SOJL	I,ASKSN1	;ANY PREVIOUS CPUS ALREADY ANSWERED?

;LOOP TO SCAN ALL PREVIOUS CPU SERIAL NUMBERS TO SEE IF THE SAME
ASKSN0:	CAMN	N,M.C0SN(I)	;SAME AS PREVIOUS SERIAL NUMBER?
	RJRST	<TTYOUT	<? Cannot be same as CPU*@>,I
		 JRST	ASKSER>	;ASK ALL CPUS OVER AGAIN
	SOJGE	I,ASKSN0	;ANY MORE PREVIOUS CPUS?
ASKSN1:	SETZM	M.DN60		;CLEAR COUNT OF DN60 DEVICES IN SYSTEM
	MOVE	I,CPU		;CPU NUMBER

;ASK FOR DEVICES ON THIS CPU IO BUS:

	SETZ	N,		;IN CASE THIS IS A KL10 OR KS10
	SKIPN	M.KS10		;KS10 DOES NOT HAVE DK10'S
	SKIPE	M.KL10		;KL10 DOES NOT HAVE DK10'S
	JRST	ASKSN2
	ASKDEC	<# DK10's on CPU*(1,0-2)[Real time clock]>,CPU
ASKSN2:	MOVEM	N,M.RT0(I)	;STORE ANSWER FOR THIS CPU
	SKIPN	N		;THIS CPU HAVE A DK10?
	SETOM	SCPUNR		;NO, FLAG SOME CPU AS NO REAL-TIME CLOCK
	ADDM	N,M.RTX		;ACCUM. TOTAL NO. OF DK10S FOR SYSTEM
	AOS	I,CPU		;INCREMENT CPU ITERATION COUNTER
	CAMGE	I,M.CPU		;DONE FOR ALL CPUS IN THIS SYSTEM?
	JRST	ASKSLP		;NO, GO BACK AND ASK FOR ANOTHER
	FILOUT	<XP M.C0SN,*@>,M.C0SN
	FILOUT	<XP M.C1SN,*@>,M.C1SN
	FILOUT	<XP M.C2SN,*@>,M.C2SN
	FILOUT	<XP M.C3SN,*@>,M.C3SN
	FILOUT	<XP M.C4SN,*@>,M.C4SN
	FILOUT	<XP M.C5SN,*@>,M.C5SN
	FILOUT	<XP M.RT0,*@>,M.RT0
	FILOUT	<XP M.RT1,*@>,M.RT1
	FILOUT	<XP M.RT2,*@>,M.RT2
	FILOUT	<XP M.RT3,*@>,M.RT3
	FILOUT	<XP M.RT4,*@>,M.RT4
	FILOUT	<XP M.RT5,*@>,M.RT5
	FILOUT	<XP M.RTX,*@>,M.RTX
	SKPFTT	CPUTYP		;UNSUPPORTED CPU TYPE?
	 JRST	EXMZZ1		;NO
	ASKYN	<Exclude monitor overhead from user run time(Y,N)[
Overhead is CPU time spent clock queue processing, command
decoding, swapping, and scheduling.
User run time always includes UUO execution and
unless EBOX/MBOX runtime accounting is selected
(KL10 systems only) includes IO interrupt service time.
On KI systems, each CPU must have a DK10]>
	JRST	EXMZZ2

EXMZZ1:	ASKYN	<Exclude monitor overhead from user run time(Y,N)[
Overhead is CPU time spent clock queue processing, command
decoding, swapping, and scheduling.
User run time always includes UUO execution and
unless EBOX/MBOX runtime accounting is selected
(KL10 systems only) includes IO interrupt service time.]>

EXMZZ2:	FILOUT	<XP M.RTCO,*@>,N
ASKEMT:	SKIPN	M.KL10		;KL10 SYSTEM?
	JRST	NOEMRT		;NO, NO EBOX/MBOX TIME ACCOUNTING
	ASKYN	<EBOX/MBOX runtime accounting(Y,N)[
If EBOX/MBOX runtime accounting is selected in a KL10
based system, user runtime is computed using the KL10
internal accounting clocks]>
	MOVEM	N,M.EMRT	;SAVE FOR LATER
	FILOUT	<XP M.EMRT,*@>,M.EMRT
	SKIPN	M.EMRT
	JRST	NOEMR1		;NO PI EXCLUSION EITHER
	ASKYN	<Exclude PI time from user runtime(Y,N)[
An answer of "yes" to this question will cause the monitor
to set up the KL10 accounting meters in such a manner that
users will not be charged for cpu time used during interrupts]>
	MOVEM	N,M.XPI		;SAVE
	FILOUT	<XP M.XPI,*@>,M.XPI
	JRST	ASKRTC		;NOW GO ASK ABOUT DK10'S
NOEMRT:	FILOUT	<XP M.EMRT,0@>
NOEMR1:	FILOUT	<XP M.XPI,0@>
ASKRTC:	SKIPE	M.RTX		;ANY DK10'S ON SYSTEM?
	SKIPE	M.KL10		;SKIP IF NOT A KL10 SYSTEM
	JRST	OUTRTC		;NO, SKIP BUNCH OF QUESTIONS
	SKIPE	SCPUNR		;IS SOME CPU WITHOUT A DK10?
	JRST	ASKRCS		;YES, TOO BAD SKIP HIGH PREC QUESTION
	ASKYN	<High precision time accounting(Y,N)[Use DK10 clock for 
10 micro-second time accounting]>
	MOVEM	N,M.RTCA
	JUMPN	N,OUTRC1	;IF HIGH PRECISION NEED SERVICE ROUTINE
ASKRCS:	ASKYN	<DK10 software(Y,N)[Include real time clock service routine]>
OUTRC1:	MOVEM	N,M.RTC		;NON-ZERO IF NEED RTC CLOCK SERVICE
OUTRTC:	FILOUT	<XP M.RTCA,*@>,M.RTCA
	FILOUT	<XP M.RTC,*@>,M.RTC

	ASKYN	<Account verification(Y,N)[LOGIN and the batch system will
verify that the user has specified a valid account]>
	FILOUT	<XP M.ACV,*@>,N
	MOVEI	N,0		;ASSUME NO MOS MEMORY SUPPORT
	SKIPE	M.KL10		;A KL10?
	SKIPE	M.1080		;YES, BUT NOT 1080'S
	JRST	MOSEND		;NO, CAN'T HAVE RECONFIGURABLE MOS
	ASKYN	<MOS memory(Y,N)[Include support for the user mode MOS memory diagnostic THGA
which collects statistics on single bit memory errors and substitutes the spare
bit when a single bit error is determined to be hard]>
MOSEND:	FILOUT	<XP M.MOS,*@>,N	;OUTPUT THE ANSWER
	SKIPN	N,M.KL10	;A KL10?
	JRST	SCAEND		;NO, CAN'T HAVE SCA SUPPORT
	ASKYN	<SCA support(Y,N)[Load monitor modules needed to provide Systems
Communications Architecture support]>
SCAEND:	MOVEM	N,M.SCA		;SAVE FOR LATER QUESTION ABOUT RAXKON
	FILOUT	<XP M.SCA,*@>,N	;OUTPUT THE ANSWER
	SETOM	CPUN
	SKIPE	M.KS10		;KS10 SYSTEM?
	JRST	ASKKSI		;YES--GO ASK ABOUT KS10 IO
	SKPFTT	EXTCHN		;EXTERNAL CHANNELS?
	 JRST	DOAUT		;NO, DO AUTCON AUTOMATICALLY
				;YES, ASK IF AUTCON
	ASKYN	<Auto-Configure(Y,N)[Automatically determine disk/tape configuration when
system starts. Can only be used for RH10, RH20, DX10 devices]>
	JUMPE	N,NOAUTO	;NO AUTO CONFIG IF 0

DOAUT:	SKIPE	M.1070
	JRST	AUTCN1		;NO RP20S ON A KI
	ASKYN	<Include RNXKON(Y,N)[Support for RP20 disks]>
	SKIPN	N
AUTCN1:	TRO	F,F.NORN
	SKIPE	M.SCA		;SKIP IF SCA SUPPORT NOT INCLUDED
	SKIPE	M.1070
	JRST	AUTCN2		;NO CI DISK ON A KI
	ASKYN	<Include RAXKON(Y,N)[Support for disks on the CI bus]>
	SKIPN	N		;ANY?
AUTCN2:	TRO	F,F.NORA	;NO
	ASKYN	<Include TM2KON(Y,N)[Support for TU16/TU45/TU77 tape drives]>
	SKIPN	N
	TRO	F,F.NOT2
	SKPFTT	DX10		;SUPPORT DX10S
	 JRST	TX1ZZ1		;DON'T ASK
	ASKYN	<Include TX1KON(Y,N)[Support for DX10/TU7x tape drives]>
	SKIPN	N
TX1ZZ1:	 TRO	F,F.NOTX
	SKIPE	M.1070
	JRST	[TRO F,F.NOTD!F.NOT7
		 JRST AUTDFS]	;NO DX20, TM78 ON A KI
	ASKYN	<Include TD2KON(Y,N)[Support for DX20/TU7x tape drives]>
	SKIPN	N
	TRO	F,F.NOTD
	ASKYN	<Include T78KON(Y,N)[Support for TU78 tape drives]>
	SKIPN	N
	TRO	F,F.NOT7
AUTDFS:	AOS	N,CPUN		;NEXT CPU
	CAML	N,M.CPU		;OVER THE TOP?
	JRST	AUTDF1		;YES, FINISH UP
	FILCPU	<XP M.DPC,0@>	;NO. MAKE DEFINITIONS
	FILCPU	<XP M.FHD,0@>
	FILCPU	<XP M.FSD,0@>
	FILCPU	<XP M.MDF,0@>
	SKIPE	I,N		;FOR CPU0 SOME SYMBOLS ARE 1, 0 FOR OTHER CPUS
	TDZA	I,I
	MOVEI	I,1
	FILCPU	<XP M.RPX,*@>,I
	FILCPU	<XP M.TAPN,*@>,I
	MOVE	N,I		;COPY DIGIT TO N
	TRNN	F,F.NORN
	SKIPE	M.1070
	SETZ	N,		;NO RP20 ON A KI
	FILCPU	<XP M.RNX,*@>,N
	MOVE	N,I		;COPY DIGIT TO N
	TRNN	F,F.NORA	;WANT RAXKON?
	SKIPE	M.1070		;AND NOT A KI?
	SETZ	N,		;NO CI DISKS ON A KI
	FILCPU	<XP M.RAX,*@>,N
	JRST	AUTDFS
AUTDF1:	FILOUT	<XP M.P0T,1@>
	FILOUT	<XP M.N0T,1@>
	FILOUT	<RP0==650@>
	FILOUT	<RN0==650@>
	FILOUT	<RA0==650@>
	SETOM	MKON		;SO WON'T ASK ABOUT 7-TRACK, 6250 TAPES
	MOVEI	I,1
	MOVEM	I,CHN		;SET UP TME NON-0 M.XXX SYMBOLS
	MOVEM	I,M.RHP4
	TRNN	F,F.NOT2
	MOVEM	I,M.T210
	TRNN	F,F.NOTX
	MOVEM	I,M.TX01
	SKIPE	M.1070
	JRST	CHNEND		;NO TM78, DX20 ON A KI
	TRNN	F,F.NORN
	MOVEM	I,M.RP20
	TRNN	F,F.NOT7
	MOVEM	I,M.T78
	TRNN	F,F.NOTD
	MOVEM	I,M.DX20
	JRST	CHNEND		;MAKE ALL THE M.XXX DEF'S
NOAUTO:	AOSN	N,CPUN
	SETOM	MKON		;MAGTAPE CONTROLLER NUMBER
	SKIPGE	MKON
	SETOM	MKONP
	CAML	N,M.CPU
	JRST	CHNEND
	SKPFTT	EXTCHN		;EXTERNAL CHANNELS
	 JRST	CHNZZ1		;NO
	ASKDEC	<# Data Channels on CPU*(2,0-?)[DF10s, DF10Cs, DX10s or RH20s for disk and tape]>
	JRST	CHNZZ2

CHNZZ1:	ASKDEC	<# Data Channels on CPU*(2,0-?)[DX10s or RH20s for disk and tape]>

CHNZZ2:	FILCPU	<XP M.CHN,*@>,N
	JUMPE	N,NOCHNS
	MOVEM	N,M.CHN		;SAVE FOR CHANNEL LOOP
	SETZM	CCHN
	TRO	F,F.KONS	;INDICATE 1ST OF EVERYTHING
;LOOP ONCE FOR EACH CHANNEL
CHNLOP:	MOVEI	N,3		;ASSUME 1091, ONLY RH20'S
	SKIPE	M.1091		;IS IT A 1091?
	JRST	CHNLP1		;YES, ONLY RH20'S
	MOVE	N,CHN		;CHANNEL ITERATION COUNTER(0,1,...)
	SKPFTT	EXTCHN		;EXTERNAL CHANNELS?
	 JRST	CHNZZ3		;NO
	ASKLST	<Channel * Type (DF10,DF10C,DX10,RH20)>
	JRST	CHNLP1		;SKIP

CHNZZ3:	ASKLST	<Channel * Type (DX10,RH20)>
	ADDI	N,2		;ADJUST

CHNLP1:	CAILE	N,3		;ADJUST FOR GAP IN NUMBERS CAUSED BY
	ADDI	N,1		;RH11 CHN TYPE (SEE ASKKSI)
	MOVEM	N,CHNTYP
	FILOUT	<XP M.CH*T,>,CHN;OUTPUT CHANNEL TYPE
	FILOUT	<*@>,CHNTYP	;AND COMPLETE OUTPUT
	FILOUT	<XP M.*RH,0@>,CHN ;NO RH11'S IF WE'RE HERE
	FILCPU	<XP M.*RH,0@>,CHN ;...DITTO
	MOVE	N,CHN
	BTHOUT	<On channel # *:@>,CHN
	MOVE	N,CHNTYP	;TYPE OF CHANNEL
	CAIN	N,2		;DX10?
	JRST	DXLOOP		;YES, ASK ABOUT DX10, TX01, TU70'S
	MOVEI	RH12,0		;NO, ASSUME SOME FLAVOR FO RH10/DF10
	CAIN	N,3		;IS IT AN RH20?
	MOVEI	RH12,1		;YES
	ADDM	RH12,M.RH20	;COUNT NO OF RH20S
	ADDM	RH12,RH20CP	;COUNT RH20S ON THIS CPU
	FILOUT	<XP M.*TX,0@>,CHN ;NO TX01S ON THIS CHL
	FILCPU	<XP M.*TX,0@>,CHN ;NO TX01S ON THIS CPU
	SKIPE	N,RH12		;IF AN RH20,
	SOJA	N,NORD10	; THERE AREN'T ANY RD10S
	MOVEI	N,0		;NO RD10'S
	SKPFTT	RC10		;RC10 SUPPORT?
	 JRST	NORD10		;NO
	ASKDEC	<  # RC10s(0-2)[Controllers for RD10 Burroughs disks and
RM10B Bryant drums on channel *]>,CHN
NORD10:	MOVE	I,N		;SET UP ITERATION FOR THIS CONTROLLER
	FILOUT	<XP M.*FH,>,CHN ;FIRST PART OF CALL
	FILOUT	<*@>,I		;SECOND HALF
	MOVE	N,M.RC10
	TRZE	F,F.1FH		;IF 1ST KONTROLLER ON CPU
	MOVEM	N,FHCPUN	; SAVE NO ON PREVIOUS CPUS
	JUMPE	I,FHEND		;ANY CONTROLLERS AT ALL?

;LOOP FOR FH* ON THIS CHANNEL:
FHLOOP:	FILOUT	<XP M.FH*P,>,M.RC10 ;YES, DEFINE NO OF FHS ON PREVIOUS CPUS
	FILOUT	<*@>,FHCPUN
	FILOUT	<XP FH*CPU,>,M.RC10
	FILOUT	<*@>,CPUN
	AOS	N,M.RC10	;INCREMENT NO. OF RC10 IN SYSTEM
	ADDI	N,'A'-1		;MAKE SIXBIT LETTER
	ROT	N,-6		;LEFT JUSTIFIED
	ASKDEC	<  # Units on FH*(1-4)>,N
	PUSH	P,N		;SAVE NO. OF FH* UNIT ON THIS CONTROLLER
	MOVE	N,M.RC10	;MAKE SIXBIT CONTROLLER LETTER AGAIN
	ADDI	N,'A'-1
	ROT	N,-6
	FILOUT	<XP M.FH*,>,N	;FIRST HALF
	POP	P,N		;RESTORE NO OF FH* UNITS ON THIS CONTROLLER
	FILOUT	<*@>,N
	SOJG	I,FHLOOP
FHEND:	SKIPE	N,RH12		;IF AN RH20,
	SOJA	N,NORS04	; THERE AREN'T ANY RS04S
	ASKDEC	<  # RH10S for RS04'S(0-3)[Controllers for RS04 swapping
disks on channel *]>,CHN
NORS04:	MOVE	I,N
	FILOUT	<XP M.*FS,>,CHN
	FILOUT	<*@>,I
	TRNE	F,F.1FS		;1ST KONTROLLER ON CPU?
	SETZM	RSCPUN		;YES, CLEAR TOTAL RS04S ON CPU
	JUMPE	I,FSEND
;LOOP FOR FS* ON THIS CHANNEL:
FSLOOP:	FILOUT	<XP M.FS*F,>,M.RH1S
	MOVEI	N,1
	TRZE	F,F.1FS		;IF 1ST KONTROLLER
	SETZ	N,		;SET FS*F=0
	FILOUT	<*@>,N
	FILOUT	<XP FS*CPU,>,M.RH1S
	FILOUT	<*@>,CPUN
	AOS	N,M.RH1S	;INCREMENT NO. OF RH10 IN SYSTEM
	AOS	RSCPUN
	ADDI	N,'A'-1		;MAKE SIXBIT LETTER
	ROT	N,-6		;LEFT JUSTIFIED
	ASKDEC	<  # Units on FS*(1-8)>,N
	PUSH	P,N		;SAVE NO. OF FS* UNIT ON THIS CONTROLLER
	MOVE	N,M.RH1S	;MAKE SIXBIT CONTROLLER LETTER AGAIN
	ADDI	N,'A'-1
	ROT	N,-6
	FILOUT	<XP M.FS*,>,N	;FIRST HALF
	POP	P,N		;RESTORE NO. OF FS* UNITS ON THIS CONTROLLER
	FILCPU	<*@>,N
	SOJG	I,FSLOOP
FSEND:	JUMPN	RH12,ASKRP2
	ASKDEC	<  # RH10S for RP04'S,RP06'S(0-3)[Controllers for RP04,RP06
disk pack units on channel *]>,CHN
	JRST	ASKRP3
ASKRP2:	ASKDEC	<  # RH20S for RP04'S,RP06'S,RP07'S(0-1)[Controllers for RP04,RP06,RP07
disk pack units on channel *]>,CHN
ASKRP3:	MOVE	I,N
	FILOUT	<XP M.*RP,>,CHN
	FILOUT	<*@>,I
	MOVE	N,M.RHP4
	TRNE	F,F.1RP
	MOVEM	N,RPCPUN		;RHP'S ON PREVIOUS CPU'S
	JUMPE	I,RPEND

;LOOP FOR RP* ON THIS CHANNEL
RPLOOP:	FILOUT	<XP M.P*F,>,M.RHP4
	MOVEI	N,1
	TRZE	F,F.1RP
	SETZ	N,
	FILOUT	<*@>,N
	FILOUT	<XP RP*CPU,>,M.RHP4
	FILOUT	<*@>,CPUN
	AOS	M.RH1P(RH12)		;INCR COUNT OF RH10S OR RH20S
	AOS	N,M.RHP4
	ADDI	N,'A'-1
	ROT	N,-6
	PUSH	P,N
	ASKDEC	<  # Units on RP*(1-8)>,N
	EXCH	N,(P)
	FILOUT	<XP M.RP*,>,N
	POP	P,N
	FILOUT	<*@>,N
	MOVE	I2,M.RHP4
	SUBI	I2,1
	FILOUT	<XP M.P*T,>,I2		;INDICATE TYPE
	SKIPE	N,RH12
	MOVE	N,rh20cp		;0 FOR RH10, CONTROL NUMBER FOR RH20
	FILOUT	<*@>,N
	MOVE	N,M.RHP4
	SUBI	N,1
	FILOUT	<XP M.RS*P,>,N	;NO OF RS04S PREVIOUS ON THIS CPU
	FILOUT	<*@>,RSCPUN
	SOJG	I,RPLOOP
RPEND:	SKIPN	N,RH12		;RH20?
	JRST	ASKRN1		;NO, NO RP20'S POSSIBLE
	ASKDEC	<  # RH20S for RP20'S(0-1)[Controllers for RP20
disk units on channel *.]>,CHN
ASKRN1:	MOVE	I2,N		;SAVE VALUE IN I2
	MOVE	N,M.RP20	;GET NUMBER OF RP20 "KONTROLLERS"
	TRZE	F,F.1RN		;FIRST ON THIS CPU?
	MOVEM	N,RNCPUN	;RP20'S ON PREVIOUS CPU'S
	FILOUT	<XP M.*RN,>,CHN ;OUTPUT NUMBER OF "KONTROLLERS" ON THIS
	FILOUT	<*@>,I2		;  CHANNEL
	JUMPE	I2,RNEND
	MOVN	I,I2		;MAKE AN AOBJN POINTER
	HRLZS	I

;LOOP FOR RN* ON THIS CHANNEL
RNLOOP:	FILOUT	<XP RN*CPU,>,M.RP20
	FILOUT	<*@>,CPUN
	AOS	N,M.RP20
	ADDI	N,'A'-1
	ROT	N,-6
	PUSH	P,N
	ASKDEC	<  # Units on RN*(1-16)>,N
	EXCH	N,(P)
	FILOUT	<XP M.RN*,>,N
	POP	P,N
	FILOUT	<*@>,N
	MOVE	I2,M.RP20
	SUBI	I2,1
	FILOUT	<XP M.N*T,>,I2	;INDICATE TYPE
	MOVE	N,RH20CP	;CONTROL NUMBER FOR RH20
	FILOUT	<*@>,N
	AOBJN	I,RNLOOP
;NO CI DISKS IF NOT AUTO CONFIGURE

RNEND:	SETZ	N,		;GET A ZERO
	FILOUT	<XP M.*RA,>,CHN
	FILOUT	<*@>,N
	SKIPE	N,RH12
	SOJA	N,NORP10		;NO RP10S IF RH20
	ASKDEC	<  # RP10s(0-3)[Controllers for Memorex and ISS RP02 and RP03 
disk pack units on channel *]>,CHN
NORP10:	MOVE	I,N		;SETUP ITERATION COUNT FOR RP FOR THIS CHANNEL
	FILOUT	<XP M.*DP,>,CHN	;OUTPUT FIRST HALF
	FILOUT	<*@>,I		;NO. OF CONTROLLERS ON THIS CHANNEL
	MOVE	N,M.RP10
	TRZE	F,F.1DP
	MOVEM	N,DPCPUN
	JUMPE	I,DPEND		;ANY RP10S AT ALL ON THIS CHANNEL?

;LOOP FOR RP10S ON THIS CHANNEL
DPLOOP:	FILOUT	<XP M.DP*P,>,M.RP10	;NO OF RP10S ON PREVIOUS CPUS
	FILOUT	<*@>,DPCPUN
	FILOUT	<XP DP*CPU,>,M.RP10
	FILOUT	<*@>,CPUN
	AOS	N,M.RP10	;INCREMENT NO. OF RP10S ON SYSTEM
	ADDI	N,'A'-1		;FORM CONTROLER LETTER
	ROT	N,-6
	ASKDEC	<  # Units on DP*(1-8)>,N
	PUSH	P,N		;SAVE NO. UNITS ON THIS CONTROLLER
	MOVE	N,M.RP10	;NO. OF RP10S SO FAR
	ADDI	N,'A'-1		;FORM CONTROLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	FILOUT	<XP M.DP*,>,N
	POP	P,N		;RESTORE NO. UNITS ON THIS CONTROLLER
	FILOUT	<*@>,N		;AND OUTPUT
	SOJG	I,DPLOOP	;ANY MORE RP CONTROLLERS ON THIS CHANNEL?
DPEND:	SKIPE	N,RH12
	SOJA	N,NOT1B		;NO TM10B IF RH20
	ASKDEC	<  # TM10Bs(0-2)[Tape Controller for NRZI only drives
on channel  *]>,CHN
NOT1B:	MOVE	I,N		;SET UP ITERATION COUNTER
	FILOUT	<XP M.*TB,>,CHN	;FIRST PART OF CALL
	FILOUT	<*@>,I		;SECOND PART
	MOVE	N,M.TM10	;TOTAL NO OF TM10S SO FAR
	TRZE	F,F.1T1		;IF THIS IS THE 1ST TM10 ON CPU
	MOVEM	N,T1CPUN	;SAVE AS NO OF TM10S ON PREVIOUS CPUS
	JUMPE	I,TBEND		;ANY TM10B'S AT ALL?
;LOOP FOR TB* ON THIS CHANNEL
TBLOOP:	AOS	M.TM10		;COUNT OF TM10'S ON SYSTEM
	AOS	N,MKON		;CONTROLLER #
	FILOUT	<XP M.MT*T,1@>,N ;MARK AS TM10B
	FILOUT	<XP M.T1*P,>,N
	FILOUT	<*@>,T1CPUN
	PUSHJ	P,TAPSUB	;DO TAPE CONTROLLER SUBR
	SOJG	I,TBLOOP
TBEND:	SETZM	TAPUN		;START AT UNIT 0 ON ANY CONTROLLER
	SKIPN	N,RH12		;IF NOT AN RH20,
	JRST	NODX20		;CAN'T HAVE ANY DX20'S
	ASKDEC	<  # RH20's for DX20's (0-1)[Mass-bus tape controller for
DX20's on channel *]>,CHN
NODX20:	MOVE	I,N		;SAVE COUNT
	FILOUT	<XP M.*D2,>,CHN ;OUTPUT FIRST PART
	FILOUT	<*@>,I		;PLUS NUMBER OF RH20/DX20'S ON THIS CHN
	TRZE	F,F.1D2		;1ST DX20 ON THIS CPU?
	SETZM	D2RH20		;YES, CLEAR COUNT
	JUMPE	I,D2END		;GO IF NONE
	MOVEI	N,1		;WE ONLY OFFICIALLY SUPPORT 1 DX20/RH20
	JRST	ONEDX2		;SO SKIP THE QUESTION FOR NOW

	MOVE	N,RH20CP	;GET NUMBER OF RH20'S
	SUBI	N,1		;MAKE IT THE RH20 NUMBER
	ASKDEC	<  # DX20's on RH20 * (1-8)[Programmed Device Adapters
driving up to 8 TU7x tape drives through a TX02 Tape Control Unit]>,N
ONEDX2:	MOVE	I2,N		;SAVE COUNT OF DX20'S ON THIS RH20
D2LOOP:	AOS	I2,MKON		;BUMP CONTROLLER NUMBER
	FILOUT	<XP M.D2*T,>,I2	;MAKE M.D2?T BE THE RH20 NUMBER
	SOSN	I2,RH20CP	;IF ON 1ST RH20 ON CPU,
	MOVEI	I2,10		;MAKE IT 10
	AOS	RH20CP		;BACK TO WHERE IT STARTED
	FILOUT	<*@>,I2		;RH20 NUMBER FOR THIS CONTROLLER
	FILOUT	<XP M.MT*T,6@>,MKON ;CONTROLLER TYPE IS RH20/DX20/TX02
	FILOUT	<XP M.MT*C,>,MKON ;OUTPUT FIRST PART
	FILOUT	<*@>,CHN	 ;  PLUS CHN # FOR THIS CONTROLLER
	FILOUT	<XP M.MT*P,>,MKON ;OUTPUT FIRST PART
	FILOUT	<*@>,CPUN	;PLUS CPU NUMBER CONTROLLER IS ON
	FILOUT	<XP M.MT*U,>,MKON ;MAKE M.MT?U EQUAL RH20 UNIT NUMBER
	FILOUT	<*@>,TAPUN	; OUTPUT SECOND PART
	AOS	TAPUN		;BUMP UNIT NUMBER FOR NEXT TAPE
	AOS	M.DX20		;BUMP COUNT OF DX20 "KONTROLLERS"
	MOVE	N,D2RH20	;GET DX20 NUMBER
	ASKDEC	<  # Units on DX20 * (1-8)>,N
	MOVE	I2,N
	AOS	D2RH20		;BUMP COUNT OF DX20'S ON THIS CPU
	FILOUT	<XP M.MT*,>,MKON;OUTPUT TOTAL NUMBER OF DRIVES ON
	FILOUT	<*@>,I2		;  THIS CONTROLLER
	SOJG	I,D2LOOP	;LOOP FOR ALL DX20 UNITS ON THIS RH
D2END:	JUMPN	RH12,ASKT22
	ASKDEC	<  # RH10's for TM02'S (0-2)[Mass-Bus tape controller for
TU16's and TU45's on channel *]>,CHN
	JRST	ASKT23
ASKT22:	ASKDEC	<  # RH20's for TM02'S (0-1)[Mass-Bus tape controller for
TU16's and TU45's on channel *]>,CHN
ASKT23:	MOVE	I,N		;CHAN
	FILOUT	<XP M.*T2,>,CHN
	FILOUT	<*@>,I		;OUTPUT NUMBER OF RH'S
	TRZe	F,F.1T2		;1ST TMO2 ON CPU?
	SETZM	T2RH10
ASKT2X:	JUMPE	I,T2END		;GO IF NONE
	MOVE	N,M.T210
	JUMPN	RH12,T2LP1
	ASKDEC	<  How many TM02's on RH10 # * (1-8)[EACH UNIT CAN CONTROL
UP TO 8 SUB-UNITS = TAPE DRIVES]>,N
	JRST	T2LP2
T2LP1:	ASKDEC	<  How many TM02's on RH20 # * (1-8)[EACH UNIT CAN CONTROL
UP TO 8 SUB-UNITS = TAPE DRIVES]>,N
T2LP2:	MOVE	I3,N
	SETZ	I,
T2LOOP:	MOVE	I2,MKON		;MAKE M.T2?T = 0 IF RH10
	ADDI	I2,1		; OR = RH20 # IF AN RH20
	FILOUT	<XP M.T2*T,>,I2
	JUMPN	RH12,ASKT2Y
	MOVE	I2,M.RH1S	;NO OF RS04S
	ADD	I2,M.RH1P	;+RH10/RP04S
	ADD	I2,T2RH10	;+RH10/TM02S
	SUB	I2,T2RH1P	;-NO OF RH10S ON PREVIOUS CPUS
	FILOUT	<-*@>,I2
	JRST	T2LP3
ASKT2Y:	SOSN	I2,RH20CP	;IF ON 1ST RH20 ON CPU,
	MOVEI	I2,10		; MAKE IT 10
	AOS	RH20CP
	FILOUT	<*@>,I2
T2LP3:	AOS	M.T210
	AOS	N,MKON
	FILOUT	<XP M.MT*T,4@>,N
	FILOUT	<XP M.MT*C,>,MKON
	FILOUT	<*@>,CHN
	FILOUT	<XP M.MT*P,>,MKON ;OUTPUT CPU NUMBER
	FILOUT	<*@>,CPUN
	FILOUT	<XP M.MT*U,>,MKON ;MAKE M.MT?U EQUAL RH20 UNIT NUMBER
	FILOUT	<*@>,TAPUN	; OUTPUT SECOND PART
	AOS	TAPUN		;BUMP UNIT NUMBER FOR NEXT TAPE
	ASKDEC	<How many drives on TM02 * (1-8)>,I
	MOVE	I2,N
	ADDI	I,1
	FILOUT	<XP M.MT*,>,MKON
	FILOUT	<*@>,I2
	SOJG	I3,T2LOOP
	AOS	T2RH10
T2END::
	SKIPN	N,RH12
	JRST	NOTT78
	ASKDEC	<  # RH20's for TM78'S (0-1)[Mass-Bus tape controller for
TU78's on channel *]>,CHN
NOTT78:	MOVE	I,N		;CHAN
	FILOUT	<XP M.*T7,>,CHN
	FILOUT	<*@>,I		;OUTPUT NUMBER OF RH'S
	JUMPE	I,DXEND		;GO IF NONE
	MOVE	N,M.T78
	ASKDEC	<  How many TM78's on RH20 # * (1-8)[Each unit can control
up to 8 sub-units = tape drives]>,N
	SETZ	I,
	MOVE	I3,N
T7LOOP:	MOVE	I2,MKON		;MAKE M.T7?T = RH20 NUMBER
	ADDI	I2,1
	FILOUT	<XP M.T7*T,>,I2
	SOSN	I2,RH20CP	;IF ON 1ST RH20 ON CPU,
	MOVEI	I2,10		; MAKE IT 10
	AOS	RH20CP
	FILOUT	<*@>,I2
	AOS	M.T78
	AOS	N,MKON
	FILOUT	<XP M.MT*T,7@>,N
	FILOUT	<XP M.MT*C,>,MKON
	FILOUT	<*@>,CHN
	FILOUT	<XP M.MT*N,>,MKON
	FILOUT	<*@>,I
	FILOUT	<XP M.MT*P,>,MKON ;OUTPUT CPU NUMBER
	FILOUT	<*@>,CPUN
	FILOUT	<XP M.MT*U,>,MKON ;MAKE M.MT?U EQUAL RH20 UNIT NUMBER
	FILOUT	<*@>,TAPUN	; OUTPUT SECOND PART
	AOS	TAPUN		;BUMP UNIT NUMBER FOR NEXT TAPE
	ASKDEC	<How many drives on TM78 * (1-4)>,I
	MOVE	I2,N
	ADDI	I,1
	FILOUT	<XP M.MT*,>,MKON
	FILOUT	<*@>,I2
	SOJG	I3,T7LOOP
T7END:	JRST	DXEND
;ROUTINE TO ASK FOR # OF UNITS ON EACH KONTROLLER

TAPSUB:	FILOUT	<XP M.MT*C,>,MKON ;CHL NUMBER
	FILOUT	<*@>,CHN
TAPSB0:	FILOUT	<XP M.MT*P,>,MKON
	FILOUT	<*@>,CPUN
	FILOUT	<XP M.MT*U,400000@>,MKON ;MAKE M.MT?U NEG FOR NON-TM02, TM78, DX20 TAPES

	MOVE	N,MKON		;GET KONROLLER #
	ADDI	N,'A'		;MAKE INTO SIXBITCH
	ROT	N,-6
	ASKDEC	<  # Units on MT*(1-8)>,N
	PUSH	P,N		;SAVE ANSWER
	FILOUT	<XP M.MT*,>,MKON ;NUMBER OF UNITS
	MOVE	N,(P)
	FILOUT	<*@>,N		;ON EACH KONTROLLER
	POP	P,N
	POPJ	P,		;RETURN
DXLOOP:	ASKDEC	<  # Controllers(0-1)[TX01's or TX02's for TU70 Tape Drives on channel *]>,CHN
	MOVE	I,N
	FILOUT	<XP M.*FH,0@>,CHN ;NO FH,DP,FS,TB,TC
	FILOUT	<XP M.*DP,0@>,CHN
	FILOUT	<XP M.*RP,0@>,CHN
	FILOUT	<XP M.*RN,0@>,CHN
	FILOUT	<XP M.*FS,0@>,CHN
	FILOUT	<XP M.*TB,0@>,CHN
	FILOUT	<XP M.*TC,0@>,CHN
	FILOUT	<XP M.*T2,0@>,CHN
	FILOUT	<XP M.*D2,0@>,CHN
	FILOUT	<XP M.*TX,>,CHN ;OUTPUT FIRST PART OF CALL
	FILOUT	<*@>,I		;SECOND PART
	MOVE	N,M.TX01
	TRZE	F,F.1TX
	MOVEM	N,TXCPUN	;NO OF TX10S ON PREVIOUS CPUS
	JUMPE	I,DXEND

TXLOOP:	AOS	M.TX01		;INCREMENT NUMBER OF TX01'S ON SYSTEM
	AOS	N,MKON		;INCR KONTROLLER ID
	FILOUT	<XP M.MT*T,3@>,N ;MARK AS TX01
	FILOUT	<XP M.TX*P,>,N
	FILOUT	<*@>,TXCPUN
	PUSHJ	P,TAPSUB	;ASK FOR UNITS
	SOJG	I,TXLOOP

DXEND:	AOS	N,CCHN		;INCREMENT CHANNEL LOOP COUNTER
	AOS	CHN
	CAMGE	N,M.CHN		;FINISHED WITH ALL CHANNELS?
	JRST	CHNLOP		;NO, ASK FOR CONTRLLERS ON THIS CHANNEL
	SKIPE	M.1091
	JRST	TAEND
	SKPFTT	TM10		;TM10S
	 JRST	TAEND		;NO
	ASKDEC	< # TM10As on CPU*(0,0-2)[I/O Bus type Controller for NRZI only drives]>,CPUN
	MOVE	I,N		;SET UP ITERATION COUNTER
	JUMPE	I,TAEND		;ANY TM10A'S AT ALL?

TALOOP:	AOS	M.TM10		;COUNT OF TM10'S ON SYSTEM
	AOS	N,MKON		;INCR KONTROLLER ID
	FILOUT	<XP M.MT*T,0@>,N ;MARK AS TM10A
	FILOUT	<XP M.T1*P,>,N
	FILOUT	<*@>,T1CPUN
	PUSHJ	P,TAPSB0	;GET UNIT INFO
	SOJG	I,TALOOP
TAEND:	MOVE	N,M.RC10	;NO OF FHD'S
	SUB	N,FHCPUN	;- NO ON PREVIOUS CPU'S
	FILCPU	<XP M.FHD,*@>,N ;=NO OF FHD'S ON THIS CPU
	FILCPU	<XP M.FSD,*@>,RSCPUN ;NO OF FSD'S ON THIS CPU
	MOVE	N,M.RHP4
	SUB	N,RPCPUN
	FILCPU	<XP M.RPX,*@>,N ;NO OF RP04/6 ON THIS CPU
	MOVE	N,M.RP10
	SUB	N,DPCPUN
	FILCPU	<XP M.DPC,*@>,N ;NO OF RP10'S ON THIS CPU
	MOVE	N,M.RP20
	SUB	N,RNCPUN
	FILCPU	<XP M.RNX,*@>,N ;NO OF RP20'S ON THIS CPU
	FILCPU	<XP M.RAX,*@>,[0] ;NO CI DISKS
	FILCPU	<XP M.MDF,*@>,[0] ;NO MOBY DISKS
	MOVE	N,MKON		;NO. OF TAPE CONTROLS ON ALL CPUS
	SUB	N,MKONP		;NO. ON THIS CPU
	FILCPU	<XP M.TAPN,*@>,N
	MOVE	N,MKON
	MOVEM	N,MKONP
	MOVE	N,M.RH1S
	ADD	N,M.RH1P		;TOTAL # RH10S SEEN SO FAR
	MOVEM	N,T2RH1P		;SAVE
	SETZM	RH20CP
	JRST	NOAUTO

NOCHNS:	FILCPU	<XP M.FHD,0@>
	FILCPU	<XP M.FSD,0@>
	FILCPU	<XP M.RPX,0@>
	FILCPU	<XP M.RNX,0@>
	FILCPU	<XP M.RAX,0@>
	FILCPU	<XP M.DPC,0@>
	FILCPU	<XP M.MDF,0@>
	FILCPU	<XP M.TAPN,0@>
	JRST	NOAUTO
ASKKSI:	SETZM	CHN			;START AT CHANNEL 0
	AOS	CPUN			;COUNT CPU NUMBER
	SETOM	MKON			;INIT THIS GUY
	ASKDEC	<Disk drives(1,1-8)[Total number of RP06's and/or RM03's
on your system]>,N
	PUSH	P,N			;SAVE N
	FILOUT	<XP M.CH*T,4@>,CHN	;CHANNEL TYPE 4
	FILOUT	<XP M.*RH,1@>,CHN	;DISK RH11 ON FIRST CHANNEL
	FILOUT	<XP RH0CPU,*@>,CPUN	;CPU THIS RH ATTACHED TO
	FILCPU	<XP M.RHX,1@>,CHN	;NO. DISK RH11'S THIS CPU
	FILOUT	<XP M.*TR,0@>,CHN	;NOT TAPE RH11
	POP	P,N			;RESTORE N
	FILOUT	<XP M.RHA,*@>,N		;NUMBER OF DRIVES
	PUSHJ	P,KSCHNO		;OUTPUT SYMBOLS FOR NON-EXISTENT STUFF
	AOS	CHN			;NEXT CHANNEL
	ASKDEC	<Tape drives(1,1-4)[Total number of TU45's on your system]>,N
	PUSH	P,N			;SAVE N
	AOS	M.T210			;INCREMENT # TM02'S
	FILOUT	<XP M.CH*T,4@>,CHN	;CHANNEL TYPE 4
	FILOUT	<XP M.*RH,0@>,CHN	;NOT DISK RH11
	FILOUT	<XP M.*TR,1@>,CHN	;TAPE RH11 ON SECOND CHANNEL
	FILCPU	<XP M.TAPN,1@>,CHN	;NO. TAPE RH11'S THIS CPU
	FILOUT	<XP M.MT0T,5@>		;TAPE CTRL TYPE
	FILOUT	<XP M.MT0C,*@>,CHN	;CHANNEL TAPE CTRL IS ON
	FILOUT	<XP M.MT0P,*@>,CPUN	;CPU TAPE CTRL IS ON
	FILOUT	<XP M.MT0U,400000@>	;NO MULTI-SLAVE UNITS
	POP	P,N			;RESTORE N
	FILOUT	<XP M.MT0,*@>,N		;TOTAL # DRIVES
	PUSHJ	P,KSCHNO		;OUTPUT SYMBOLS FOR NON-EXISTENT STUFF
	AOS	CHN			;NEXT CHANNEL
	FILOUT	<DEFINE MACKN0 (X)>	;NO 7-TRACKS
	PUSHJ	P,FILLAB
	PUSHJ	P,FILRAB
	FILOUT	<DEFINE MACK60 (X)>	;NO 6250 BPI'S
	PUSHJ	P,FILLAB
	PUSHJ	P,FILRAB
	SKPFTT	RX20		;RX02S
	 JRST	RXEND		;NO
ASKRX2:	MOVEI	N,SM.RXK	;Maximum number of RX02 controllers
	ASKDEC	<# RX211s(0,0-*)[Double density "floppy disk" controls]>
	FILCPU	<XP M.RX20,*@>,N
	MOVE	I,N		;SETUP RX02 UNIT ITERATION COUNTER
	JUMPE	I,RXEND		;ANY RX02 UNITS AT ALL?
RXLOOP:	AOS	N,RX20		;YES, INCREMENT COUNT OF RX CONTROLLERS IN SYSTEM
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	ASKDEC	<  # Units on RX*(1-2)>,N
	PUSH	P,N		;SAVE ANSWER(NO OF UNITS ON THIS CONTROLER
	MOVE	N,RX20		;CONTROLLER NUMBER
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	FILOUT	<XP M.RX*,>,N	;FIRST HALF
	EXCH	N,(P)
	FILOUT	<*@>,N		;OUTPUT
	EXCH	N,(P)
	FILCPU	<XP M.RX*,>,N	;FIRST HALF
	POP	P,N		;RESTORE NO. OF UNITS ON THIS CONTROLER
	FILCPU	<*@>,N		;OUTPUT
	SOJG	I,RXLOOP	;ANY MORE CONTROLLERS?
RXEND:
	SKPFTF	RX20		;RX20?
	 JRST	CHNEND		;YES
	FILCPU	<XP M.RX20,0@>
	JRST	CHNEND			;GO TO TOTALS PROCEDURE

KSCHNO:	FILOUT	<XP M.*FH,0@>,CHN ;NO FH,DP,FS,TB,TC
	FILOUT	<XP M.*DP,0@>,CHN
	FILOUT	<XP M.*RP,0@>,CHN
	FILOUT	<XP M.*RN,0@>,CHN
	FILOUT	<XP M.*RA,0@>,CHN
	FILOUT	<XP M.*FS,0@>,CHN
	FILOUT	<XP M.*TB,0@>,CHN
	FILOUT	<XP M.*TC,0@>,CHN
	FILOUT	<XP M.*T2,0@>,CHN
	FILOUT	<XP M.*TX,0@>,CHN
	FILCPU	<XP M.FHD,0@>,CHN
	FILCPU	<XP M.FSD,0@>,CHN
	FILCPU	<XP M.RPX,0@>,CHN
	FILCPU	<XP M.RNX,0@>,CHN
	FILCPU	<XP M.RAX,0@>,CHN
	FILCPU	<XP M.DPC,0@>,CHN
	FILCPU	<XP M.MDF,0@>,CHN
	POPJ	P,		;RETURN
CHNEND:	FILOUT	<XP M.CHN,*@>,CHN
	FILOUT	<XP M.RC10,*@>,M.RC10 ;OUTPUT NO. OF RC10 IN SYSTEM
	FILOUT	<XP M.RH1S,*@>,M.RH1S	;OUTPUT NO. OF RH10/RP04'S IN SYSTEM
	FILOUT	<XP M.RH1P,*@>,M.RH1P ;OUTPUT NO. OF RH10/RP04'S IN SYSTEM
	FILOUT	<XP M.RH2P,*@>,M.RH2P	;OUTPUT NO. OF RH20/RP04'S IN SYSTEM
	FILOUT	<XP M.RH20,*@>,M.RH20	;OUTPUT NUMBER OF RH20S IN SYSTEM
	FILOUT	<XP M.RHP4,*@>,M.RHP4	;OUTPUT NO. OF RP04 CONTROLLERS IN SYSTEM
	FILOUT	<XP M.RP20,*@>,M.RP20	;OUTPUT NO. OF RP20 CONTROLLERS
	FILOUT	<XP M.RP10,*@>,M.RP10 ;OUTPUT NO. OF RP10S IN SYSTEM
	FILOUT	<XP M.TX01,*@>,M.TX01 ;OUTPUT N0. OF TX01S IN SYSTEM
	FILOUT	<XP M.TM02,*@>,M.T210	;OUTPUT NO. OF TM02'S IN SYSTEM
	FILOUT	<XP M.DX20,*@>,M.DX20	;OUTPUT NO. OF DX20'S IN SYSTEM
	FILOUT	<XP M.TM78,*@>,M.T78	;OUTPUT NO. OF TM78'S IN SYSTEM
	FILOUT	<XP M.TM10,*@>,M.TM10	;OUTPUT NO. OF TM10'S IN SYSTEM
	SKIPN	M.KS10			;KS10?
	JRST	CHNEN0			;NO--GO ON
	FILOUT	<XP M.R11D,1@>		;TOTAL # RH11'S FOR DISKS
	FILOUT	<XP M.TRH1,1@>		;TOTAL # OF RH11'S FOR TAPE
	JRST	CHNEN1			;CONTINUE
CHNEN0:	FILOUT	<XP M.R11D,0@>		;THESE ARE ZERO FOR NON-KS10
	FILOUT	<XP M.TRH1,0@>
CHNEN1:	MOVE	I,MKON		;GET # TAPE KONTROLLERS
	JUMPL	I,ASKDTE	;JUMP IF ZERO
	BTHOUT	<Specify which drives (M-N) are 7 track drives.
[Type one number (M) or one range(M-N) or ALL on separate lines.
Type extra carriage return when through.]@>
TAP7LP:	MOVE	N,MKON
	SUB	N,I		;START FROM ZERO
	PUSH	P,N		;SAVE NUMBER
	FILOUT	<DEFINE	MACKN* (X)>,N
	POP	P,N		;RESTORE N
	ADDI	N,'A'		;CONVERT TO SIXBIT
	ROT	N,-6
	ASKTMN	<For controller MT*@>,N
	SOJGE	I,TAP7LP	;LOOP TILL DONE
	BTHOUT	<Specify which tape drives (M-N) are capable of 6250 BPI densities.
[Type one number (M) or one range (M-N) or ALL on separate lines.
Type an extra carriage return when through.]@>
	MOVE	I,MKON		;PICK UP THE NUMBER OF CONTROLLERS
TAP6LP:	MOVE	N,MKON
	SUB	N,I		;START FROM ZERO
	PUSH	P,N		;SAVE NUMBER
	FILOUT	<DEFINE MACK6* (X)>,N
	POP	P,N		;RESTORE N
	ADDI	N,'A'		;CONVERT TO SIXBIT
	ROT	N,-6
	ASKTMN	<For controller MT*@>,N
	SOJGE	I,TAP6LP	;LOOP TILL DONE
;CODE TO ASK ABOUT DTE-20'S ON KL-10'S

ASKDTE:	SKIPN	M.KL10			;IF THIS ISN'T A KL-10,
	JRST	ASKTTY			; THEN DON'T GENERATE ANY SYMBOLS
	SETZM	M.DN6S			;INITIAL TO NO DN-60S
	SETZM	M.DN8S			; AND NO DN87S
	SETZM	M.DDCN			; AND NO DECNET FRONT-ENDS
	PUSH	P,P1			;P1 WILL BE THE NUMBER OF DTES ON CPUN
	PUSH	P,P2			;P2 WILL BE THE CURRENT DTE
	SETOM	CPUN			;WE START WITH CPU #0
ASKDT1:	AOS	N,CPUN			;STEP TO THE NEXT CPU
	CAML	N,M.CPU			;IF WE HAVE CHECKED ALL CPU'S
	JRST	ASKDT4			; THEN CLEAN UP AND GO TO NEXT QUESTION
	ASKDEC	<# of DTEs on CPU*(1,1-4)[Interfaces for front-end PDP-11s]>
	MOVE	P1,N			;SAVE THE NUMBER OF DTES
	SETZ	P2,			;START ASKING ABOUT DTE0

	FILCPU	<XP M.DTEN,*@>,P1	;NUMBER OF DTE'S ON THIS CPU

ASKDT2:	CAML	P2,P1			;ANY MORE DTE'S TO DO
	JRST	ASKDT3			; IF NOT, THEN DEFAULT THE REST
	MOVE	N,CPUN			;BUILD A STANDARD CPU-DTE
	IMULI	N,^D10			; DTE IDENTIFIER
	ADD	N,P2			; FOR USE IN THE NEXT QUESTION
	ASKLST	<  Type of front end on DTE* (RSX20F,ANF10,IBM,DECNET)>,N
	PUSH	P,N			;SAVE THIS FOR A SECOND
	FILCPU	<XP M.*DTE,>,P2		;A SYMBOL THAT GIVES THE TYPE
	MOVE	N,(P)			; OF THIS DTE
	AOS	N			; OF THE FORM M'CPU'DTEN'DTE
	FILOUT	<*@>,N			;WRITE THE DTE TYPE
	POP	P,N			;GET THE FRONT END TYPE BACK
	PUSHJ	P,@[EXP DTERSX,DTEANF,DTEIBM,DTEDCN](N)	;DISPATCH BY TYPE
	AOJA	P2,ASKDT2		;LOOP OVER ALL DTE'S ON THIS CPU

ASKDT3:	CAIL	P2,4			;HAVE WE DEFINED SYMS FOR ALL DTES?
	JRST	ASKDT1			; IF SO, GO TO THE NEXT CPU
	FILCPU	<XP M.*DTE,0@>,P2	;IF NOT, SAY NO FRONT END
	AOJA	P2,ASKDT3		; AND STEP TO NEXT DTE

ASKDT4:	FILOUT	<XP M.TTDN,*@>,M.TTDN	;TOTAL FROMT END TTY'S
	FILOUT	<XP M.DLP,*@>,M.DLP	;TOTAL FRONT END LPT'S
	FILOUT	<XP M.DCR,*@>,M.DCR	;TOTAL FRONT END CDR'S
	FILOUT	<XP M.DN6S,*@>,M.DN6S	;NUMBER OF DN60'S ON THE SYSTEM
	FILOUT	<XP M.DN8S,*@>,M.DN8S	;NUMBER OF DN87'S ON THE SYSTEM
	FILOUT	<XP M.DDCN,*@>,M.DDCN	;NUMBER OF DECNET FRONT-ENDS
	POP	P,P2			;RESTORE
	POP	P,P1			; SEMI-PERMANENT REGISTERS
	JRST	ASKTTY			; AND GO TO THE NEXT QUESTION
DTERSX:	MOVE	N,CPUN		;GET THE CPU NUMBER
	IMULI	N,^D10		;PUT IN THE CPU POSITION
	ADD	N,P2		; ADD IN THE DTE NUMBER
	PUSH	P,N		;SAVE FOR THE NEXT FEW QUESTIONS
	ASKDEC	<  # terminals on front end #*(0,0-128)[include
only timesharing (DH11) lines, not CTY or KLINIK]>,N
	SKIPN	N		;ANY LINES ON FRONT END
	SKIPA	N,P1		;NO, NEED ONLY 1 DL11 FOR EACH
	ADDI	N,4		;ACCOUNT FOR ALL DL11 LINES (-CTY)
	ADDM	N,M.TTDN	;UPDATE THE TOTAL NUMBER OF 20F LINES
	FILCPU	<XP M.TTDN,*@>,N;WRITE THE NUMBER OF LINES ON THIS CPU
	MOVE	N,0(P)		;GET THE DTE ID BACK
	ASKDEC	<  # line printers on front end #*(0,0-2)>,N
	ADDM	N,M.DLP		;UPDATE THE TOTAL NUMBER OF 20F LPTS
	FILCPU	<XP M.LP0N,*@>,N
	FILCPU	<XP M.LP1N,0@>
	FILCPU	<XP M.LP2N,0@>
	FILCPU	<XP M.LP3N,0@>
	JUMPE	N,DTERS2	;DON'T ASK IF THERE AREN'T ANY PRINTERS
	MOVN	I,N		;GET -NUMBER OF PRINTERS
	HRLZ	I,I		;MAKE AN AOBJN POINTER
DTERS1:	HRRZ	N,I		;GET LPT NUMBER
	ASKYN	<     Front end printer * lower case(Y,N)[Does printer * have lower case capability]>,N
	PUSH	P,N		;SAVE ANSWER
	HRRZ	N,I		;GET PRINTER NUMBER AGAIN
	FILCPU	<XP M.FL*L,>,N
	POP	P,N		;RESTORE ANSWER
	FILCPU	<*@>,N
	AOBJN	I,DTERS1	;TRY FOR NEXT PRINTER
DTERS2:
	MOVEI	N,0
	SKPFTT	CD20		;CD20 SUPPORT
	 JRST	NOCD20		;NO
	MOVE	N,0(P)		;GET THE DTE ID BACK
	ASKDEC	<  # card readers on front end #*(0,0-1)>,N
	ADDM	N,M.DCR		;UPDATE TOTAL NUMBER OR 20F CDRS
NOCD20:	FILCPU	<XP M.CR0N,*@>,N
	FILCPU	<XP M.CR1N,0@>
	FILCPU	<XP M.CR2N,0@>
	FILCPU	<XP M.CR3N,0@>
	POP	P,N		;FIXUP THE STACK
	POPJ	P,		;RETURN TO ASKDTE

DTEANF:	AOS	M.DN8S		;COUNT UP ONE MORE DN87S
	POPJ	P,

DTEDCN:	AOS	M.DDCN		;COUNT UP ONE MORE DECNET FRONT-END
	POPJ	P,

DTEIBM:	AOS	M.DN6S		;COUNT UP ONE MORE DN60S
	AOS	M.DN60		;INCREMENT GENERIC DN60 DEVICE COUNTER
	POPJ	P,
ASKTTY:	SKIPE	M.KS10			;KS10?
	JRST	TKSGEN			;YES--DO DIFFERENT THINGS
	SETOM	CPUN			;NO, START AT CPU0
ASKTT1:	AOS	T1,CPUN			;STANDARD CPU LOOP
	CAML	T1,M.CPU			;IF DONE,
	JRST	ASKOPR			;FIND THE OPR TERMINAL
	SKPFTT	DC10			;DC10
	 SKPFTF	DC68			;OR DC76
	JRST	TTYCPX			;THESE ARE MULTI CPU STUFF
	SKPFTT	DC76			;SO IS THIS
	JUMPN	T1,ASKOPR		;NO MULTI-CPU STUFF HERE IF SUPPORTED
TTYCPX:	MOVEI	N,0			;NO DC10
	SKPFTT	DC10
	 JRST	NODC10
	MOVE	N,CPUN
	ASKDEC	<How many DC10s on CPU*(1,0-2)[
The DC10 is a data line scanner]>
NODC10:	SKIPN	CPUN
	MOVEM	N,M.DC10
	MOVEI	N,0			;NO DC68
	SKPFTT	DC68
	 JRST	NODC68
	MOVE	N,CPUN
	ASKDEC	<How many DC68s on CPU*(1,0-2)[
The DC68 is a PDP-8 680 or 680I communications system]>

NODC68:	SKIPN	CPUN
	MOVEM	N,M.DC68
	MOVEI	N,0		;NO DC76S
	SKPFTT	DC76		;DC76 SUPPORT
	 JRST	NODC76		;NO
	MOVE	N,CPUN
	ASKDEC	<How many DC76s on CPU*(1,0-8)[
The DC76 is a PDP-11 communications system]>

NODC76:	SKIPE	CPUN
	JRST	ASKTT1
	MOVEM	N,M.DC76
	FILOUT	<XP M.DC10,*@>,M.DC10
	FILOUT	<XP M.DC68,*@>,M.DC68
	FILOUT	<XP M.DC76,*@>,M.DC76
	FILOUD	<XP MD.DCS,*@>,MD.DCS
	SKIPN	M.DC10		;HAVE A DC10?
	JRST	ASK68		;NO--DO NOT ASK ABOUT IT
ASKDG:	SKIPN	M.DC10		;ANY DC10 HARDWARE?
	JRST	ASK68
	PUSH	P,[0]		;ASK ABOUT DC10 #0
	PUSHJ	P,ASKDCX	; ..
	AOS	(P)		;ASK ABOUT DC10 #1
	MOVE	N,M.DC10	;GET # OF DC10'S
	CAME	N,(P)		;ALL DONE
	PUSHJ	P,ASKDCX	; ..
	POP	P,(P)		;CLEAN UP THE STACK

ASK68:	SKIPN	M.DC68		;ANY DC68 HARDWARE
	JRST	ASK76		;NO--ASK ABOUT DC76
	PUSH	P,[0]		;ASK ABOUT DC68 #0
	PUSHJ	P,ASKD68	; ..
	AOS	(P)		;ASK ABOUT DC68 #1
	SOSE	M.DC68		; IF THERE ARE 2 DC10'S
	PUSHJ	P,ASKD68	; ..
	POP	P,(P)		;CLEAN UP THE STACK
ASK76:	SKIPN	M.DC76		;HAVE A DC76?
	JRST	ASKH3		;NO--DO NOT ASK DC76 QUESTIONS
	PUSH	P,[0]
	PUSHJ	P,ASKD76
	AOS	(P)
	SOSE	M.DC76
	JRST	.-3
	POP	P,(P)
	JRST	ASKH3
TKSGEN:	FILOUT	<XP M.DC10,0@>
	FILOUT	<XP M.DC68,0@>
	FILOUT	<XP M.DC76,0@>
	FILOUT	<XP MD.DCS,0@>
	ASKDEC	<TTY lines(0-32)[Total number of TTY lines]>,N
	MOVEM	N,M.DZNL
ASKH3:	FILOUT	<XP M.D70N,*@>,M.D70N
	FILOUT	<XP M.D71N,*@>,M.D71N
	FILOUT	<XP M.D72N,*@>,M.D72N
	FILOUT	<XP M.D73N,*@>,M.D73N
	FILOUT	<XP M.D74N,*@>,M.D74N
	FILOUT	<XP M.D75N,*@>,M.D75N
	FILOUT	<XP M.D76N,*@>,M.D76N
	FILOUT	<XP M.D77N,*@>,M.D77N
	FILOUT	<XP M.D78N,0@>	;DUMMY SYMBOLS SINCE DC76 ONLY ON DL10
	FILOUT	<XP M.D79N,0@>
	FILOUT	<XP M.D7AN,0@>
	FILOUT	<XP M.D7BN,0@>
	FILOUT	<XP M.TTG0,*@>,M.TTG0
	FILOUT	<XP M.TTG1,*@>,M.TTG1
	FILOUT	<XP M.DSG0,*@>,M.DSG0
	FILOUT	<XP M.DSG1,*@>,M.DSG1
	FILOUT	<XP M.68L0,*@>,M.68L0
	FILOUT	<XP M.68L1,*@>,M.68L1
	FILOUT	<XP M.DZNL,*@>,M.DZNL
	FILCPU	<XP M.DZNL,*@>,M.DZNL


	MOVE	N,M.TTG0	;NUMBER OF 8-LINE GROUPS
	ADD	N,M.TTG1	; PLUS NUMBER OF LINES ON DC10 #1
	LSH	N,3		;TIMES 8=NUMBER OF LINES
	ADD	N,M.D70N	;PLUS LINES ON DC76
	ADD	N,M.D71N
	ADD	N,M.D72N
	ADD	N,M.D73N
	ADD	N,M.D74N
	ADD	N,M.D75N
	ADD	N,M.D76N
	ADD	N,M.D77N
	ADD	N,M.DZNL
	ADD	N,M.68L0	;PLUS LINES ON DC68
	ADD	N,M.68L1	; = TOTAL NUMBER OF LINES
	FILOUT	<XP M.TLTL,* ;TOTAL LOCAL TTY LINES@@>
	SKIPN	M.KS10		;UNLESS A KS10,
	JRST	ASKTT1		;LOOP OVER ALL CPUS
;ELSE, FALL INTO ASKOPR ON NEXT PAGE
ASKOPR:	SKIPE	M.KL10		;KL10?
	ADD	N,M.TTDN	;YES, ADD IN 20F LINES
	SOJ	N,		;ADJUST TO GET HIGHEST LINE
	ASKLIN	<OPR octal line #(CTY,0-*)[OPR is privileged operator terminal]>
	FILOUT	<DEFINE	OPRLIN>
	PUSHJ	P,FILLAB
	FILOUT	<@	OPRL	*@>,N
	PUSHJ	P,FILRAB
	FILOUT	<@>
;ASKTT2: BTHOUT	<Answer the following questions about your TTY lines(M-N).
;[Type one octal line #(M) or one range(M-N) or CTY on separate
;lines.  Type extra carriage return when through.]@>


ASKDSD:	FILOUT	<DEFINE	MACDSD>	;START MACRO DEFINITION
	ASKMN	<Data set lines
[Class of terminal for LOGIN, LOGIN resets line
to computer echoing and no hardware tabs.
Type one octal line #(M) or one range(M-N) on separate
lines.  Type extra carriage return when through.]@>


TTYEND:	JRST	ASKJOB			;DONE HERE, ON TO NEXT QUESTION
;SUBROUTINE TO ASK ABOUT DC10 HARDWARE
;CALL WITH:
;	PUSHJ	P,[DC10 NUMBER]
;	PUSHJ	P,ASKDCX

ASKDCX:	MOVE	N,-1(P)		;PICK UP DC10 NUMBER
	TTYOCT	<@For DC10 *:@@>
	MOVEI	N,SM.TTG	;MAX TTY GROUPS
	ASKDEC	<# DC10B[ or 632] 8 line data groups(1-*)[
1 is TTY0-7, 2 is TTY0 - 17, ... 8 is TTY0 - 77]>
	MOVE	T1,-1(P)	;STORE FOR CORRECT DC10
	MOVEM	N,M.TTG0(T1)	; ..
	ASKDEC	<# DC10E Data set control groups(0-*)>
	MOVE	T1,-1(P)
	MOVEM	N,M.DSG0(T1)	;STORE FOR CORRECT DC10


ASKCRR:	MOVE	N,-1(P)		;WHICH DC10
	FILOUT	<DEFINE	MACCR*>
	MOVE	T1,-1(P)
	SKIPN	M.DSG0(T1)	;DATA SETS?
	JRST	ASKCR1		;NO, SKIP THIS QUESTION
	ASKMNP	<Correspondence of DC10E lines to the DC10B lines(M-N,P)[
Type M,P for one pair and M-N,P for a range of pairs
where M is octal DC10E line, M-N is octal range of DC10E
lines, and P is octal DC10B line]@>
	POPJ	P,0		;RETURN
ASKCR1:	PUSHJ	P,FILLAB	;OUTPUT NULL MACRO IF DIDNT ASK
	PJRST	FILRAB		;FINISH MACRO IF DIDNT ASK
;SUBROUTINE TO ASK ABOUT DC68 LINES
;CALL WITH:
;	PUSH	P,[DC68 NUMBER]
;	PUSHJ	P,ASKD68

ASKD68:	MOVE	N,-1(P)
	TTYOCT	<@FOR DC68 *:@@>
	MOVEI	N,SM.68L
	ASKOCT	<# Octal lines on DC68, including its console TTY(1-*)>
	MOVE	T1,-1(P)
	MOVEM	N,M.68L0(T1)
	POPJ	P,
;SUBROUTINE TO ASK ABOUT A DC76
;CALL WITH
;	PUSH	P,[DC76 NUMBER]
;	PUSHJ	P,ASKD76

ASKD76:	MOVE	N,-1(P)
	TTYOCT	<@For DC76 *:@@>
	ASKDEC	<Which DL10 port is the DC76 connected to(0,1-7)[Each PDP-11
is connected to a DL10 port. If there is only one -11 it
is always connected to port 0. If there are 2 -11's one is
connected to port 0 and the other to port 1]>
	PUSH	P,N
	ASKDEC	<Decimal lines on DC76(1-129)[
Each DC76F is 16 lines and the console teletype is
one line. A DC76 with 2 DC76Fs has 33 lines]>
	MOVE	T1,(P)
	MOVEM	N,M.D70N(T1)
	POP	P,(P)
	POPJ	P,0
ASKJOB:	MOVEI	N,SM.JOB	;MAXIMUM NUMBER OF JOBS
	ASKDEC	<# Jobs(1-*)[Maximum number attached and detached, not
counting null job]>
	FILOUT	<XP M.JOB,*@>,N


	FILOUD	<XP MD.2RR,*@>,MD.2RR
	FILOUD	<XP MD.SEG,*@>,MD.SEG
	FILOUD	<XP MD.DDT,*@>,MD.DDT

ASKCOR:	MOVEI	N,SM.MPI	;MAX NO. OF PAGES ON KI10
	ASKDEC	<Maximum P of core for each job(0,0-*)[0 means all of core]>,N
	FILOUT	<XP M.CORE,*@>,N
	MOVEI	N,^D4096	;UP TO 4 MILLION WORDS ALLOWED




ASKNKC:	ASKDEC	<# K total system core(512-*)[ONCE-only reports if
less core at startup]>
	FILOUT	<XP M.NKC,*@>,N
ASKTPS:	ASKLST	<Clock ticks per second(60,50)[Power line frequency]>
	SKIPN	N		;SKIP IF 50
	TROA	N,^D60		;NO, 60
	MOVEI	N,^D50		;50
	FILOUT	<XP M.TPS,*@>,N
ASKRTD:	SKIPN	M.KS10		;KS10?
	JRST	ASKRT0		;NO--GO ON
	FILOUT	<XP M.RTD,0@>	;YES--NO REAL TIME
	JRST	ASKLOK		;GO ON
ASKRT0:	MOVEI	N,SM.RTD	;MAXIMUM NUMBER OF REAL TIME DEVICES
	ASKDEC	<# Real-time devices(0,0-*)[Max. # which can be put
on PI channels simultaneously]>
	FILOUT	<XP M.RTD,*@>,N
	JUMPN	N,ASKLK1	;DO NOT ASK ABOUT LOCKING IF REAL TIME
				; SINCE MUST HAVE LOCKING FOR REAL TIME

ASKLOK:	ASKYN	<Allow jobs to be locked in core(Y,N)>
ASKLK1:	FILOUT	<XP M.LOK,*@>,N
	JUMPE	N,ASKMG1
ASKMGC:	MOVEI	N,SM.MPI	;MAXIMUM NUMBER OF PAGES ON KI10
	ASKDEC	<# Pages min guaranteed among jobs not locked in core(0,0-*)[
minimum free core pool for unlocked jobs, 0 assumes all of core]>
ASKMG1:	FILOUT	<XP M.MGC,*@>,N


ASKHPQ:	MOVEI	N,SM.HPQ	;MAXIMUM NUMBER OF HIGH PRIORITY QUEUES
	ASKDEC	<# High priority queues(0,0-*)>
	FILOUT	<XP M.HPQ,*@>,N

ASKMET:	SETZ	N,		;NO METER UUO
	SKPFTT	METER
	 JRST	NOMETR
	ASKYN	<Meter(Y,N)[Performance analysis metering(METER UUO)]>

NOMETR:	FILOUT	<XP M.METR,*@>,N

ASKKAS:	SKIPN	N,M.KL10
	SKIPE	N,M.KS10
	CAIA
	JRST	ASKKA1
	SETZ	N,
	SKPFTT	KASER
	 JRST	ASKKA1		;NO
	ASKYN	<KASER(Y,N)[Include support for simulation of KA10
long floating point instructions]>

ASKKA1:	FILOUT	<XP M.FPS,*@>,N

ASKMSG:	ASKYN	<MSGSER(Y,N)[Support for device MPX. (more than one device
on an I/O channel). This feature is required for MCS-10]>
	FILOUT	<XP M.MSG,*@>,N
ASKPSI:	ASKYN	<PSISER(Y,N)[Advanced programmed software interrupt service -
Support for the PISYS. UUO. This provides an easy
and powerful interrupt method for program to trap asynchronous
events. Required by GALAXY-10]>
	FILOUT	<XP M.PSI,*@>,N

ASKIPC:	ASKYN	<IPCF(Y,N)[Inter process communication facility]>
	FILOUT	<XP M.IPCF,*@>,N

ASKENQ:	ASKYN	<ENQ/DEQ(Y,N)[Sychronization primitives to allow
simultaneous file update by multiple co-operating processes]>
	FILOUT	<XP M.EQDQ,*@>,N
	FILOUT	<XP M.SYSC,0@>

	SKIPE	M.KS10		;KS10?
	JRST	KSGEN		;YES--GO DO KS10 SPECIFIC GEN
	SETOM	CPUN
ASKCDR:	AOS	N,CPUN
	CAML	N,M.CPU
	JRST	DEVEND
	MOVE	I,M.CPU
	CAIG	I,1
	JRST	ASKCD1
	BTHOUT	<on CPU*:@>,N
ASKCD1:
	MOVEI	N,0		;NO CDRS
	SKPFTT	CR10		;IO-BUS CDRS?
	 JRST	ASKCDZ		;NO
	MOVEI	N,SM.CDR	;MAXIMUM NUMBER OF CDRS
	ASKDEC	<# CDRs(1,0-*)[Card reader on the I/O Bus]>
	ADDM	N,M.CDR

ASKCDZ:	FILCPU	<XP M.CDR,*@>,N
	SKIPE	N		;SKIP IF NO CDR
	MOVEI	N,MD.C10	;YES, GET DEFAULT VALUE FOR CR10
	FILOUT	<XP MD.C10,*@>,N
	FILCPU	<XP MD.C10,*@>,N


ASKCDP:	MOVEI	N,0
	SKPFTT	CP10
	 JRST	NOCP10

	ASKYN	<CDP(Y,N)[Card punch]>
	ADDM	N,M.CDP

NOCP10:	FILCPU	<XP M.CDP,*@>,N
	JUMPE	N,ASKDIS
	ASKYN	<CP10D(Y,N)[Special Systems unbuffered card punch]>
	FILCPU	<XP M.CP1D,*@>,N

ASKDIS:	MOVEI	N,0		;NO DISPLAYS
	SKPFTT	DIS
	 JRST	NODIS		;NO

	ASKYN	<DIS(Y,N)[Display device(VP10,340,30,VB10C) as distinguished from
display terminals]>

NODIS:	JUMPE	N,ASKDS1	;ANY DISPLAYS?
	ASKLST	<Type(VP10,340,VB10C)[Answer VP10 for Type 30]>
	AOS	M.VP10(N)	;SET M.VP10, M.340 OR M.VBXC TO 1
ASKDS1:	FILOUT	<XP M.VP10,*@>,M.VP10
	FILCPU	<XP M.VP10,*@>,M.VP10
	FILOUT	<XP M.340,*@>,M.340
	FILCPU	<XP M.340,*@>,M.340
	FILOUT	<XP M.VBXC,*@>,M.VBXC
	FILCPU	<XP M.VBXC,*@>,M.VBXC
	SETZ	N,		; FOR FILOUT OF M.DIS
	SKIPN	M.VP10		;SKIP IF VP10 DISPLAY
	SKIPE	M.340		;SKIP IF NOT 340 DISPLAY
	MOVEI	N,1		;FILOUT M.DIS=1 IF EITHER 340 OR VP10
	FILOUT	<XP M.DIS,*@>,N	;
	FILCPU	<XP M.DIS,*@>,N	;

ASKDTA:	MOVEI	N,0		;NO DECTAPES
	SKPFTT	DTA		;DECTAPE?
	 JRST	NODTAS		;NO

	MOVEI	N,SM.DTA	;MAXIMUM NUMBER OF DTA CONTROLLERS
	ASKDEC	<# TD10s(1,0-*)[DECtape controls]>

NODTAS:	FILCPU	<XP M.TD10,*@>,N
	MOVE	I,N		;SETUP DTA UNIT ITERATION COUNTER
	JUMPE	I,DTEND		;ANY DTA UNIT AT ALL?
DTLOOP:	AOS	N,DTA		;YES, INCREMENT COUNT OF DT CONTROLLERS IN SYSTEM
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	ASKDEC	<  # Units on DT*(1-8)>,N
	PUSH	P,N		;SAVE ANSWER(NO OF UNITS ON THIS CONTROLER
	MOVE	N,DTA		;CONTROLLER NUMBER
	ADDI	N,'A'-1		;FORM SIXBIT CONTROLLER LETTER
	ROT	N,-6		;LEFT JUSTIFY
	FILOUT	<XP M.DT*,>,N	;FIRST HALF
	EXCH	N,(P)
	FILOUT	<*@>,N		;OUTPUT
	EXCH	N,(P)
	FILCPU	<XP M.DT*,>,N	;FIRST HALF
	POP	P,N		;RESTORE NO. OF UNITS ON THIS CONTROLER
	FILCPU	<*@>,N		;OUTPUT
	SOJG	I,DTLOOP	;ANY MORE CONTROLLERS?
DTEND:

ASKLPT:	MOVEI	N,SM.LPT	;MAXIMUM NUMBER OF LPTS
	ASKDEC	<LPTs(1,0-*)[Line printers on the I/O Buss]>
	FILCPU	<XP M.LPT,*@>,N
	PUSH	P,N		;SAVE # OF LPTS
	SKIPE	N		;SKIP IF NO LPT
	MOVEI	N,MD.MOV	;GET DEFAULT VALUE FOR MOVIE
	FILOUT	<XP MD.MOV,*@>,N
	POP	P,N		;GET # OF LPTS
	JUMPE	N,NOLPT		;DON'T WORRY ABOUT LC IF NO LPTS
	MOVE	I,N		;SET UP LOOP COUNTER
MORLPT:	MOVE	N,LPTCNT	;GET CURRENT NUMBER OF  LPT
	ASKYN	<LPT* Lower case(Y,N)[Does LPT* have lower case capability]>,N
	PUSH	P,N		;SAVE ANSWER
	MOVE	N,LPTCNT	;GET NUMBER OF THIS LPT
	ADDI	N,'0'		;CONVERT TO PRINTABLE FORM
	ROT	N,-6		;LEFT-JUSTIFY IT
	FILOUT	<XP M.LP*L,>,N	;OUTPUT SYMBOL NAME
	EXCH	N,(P)
	FILOUT	<*@>,N		;OUTPUT IT AS SYMBOL VALUE
	EXCH	N,(P)
	FILCPU	<XP M.LP*L,>,N	;OUTPUT SYMBOL NAME
	POP	P,N		;GET ANSWER BACK AGAIN
	FILCPU	<*@>,N		;OUTPUT IT AS SYMBOL VALUE
	AOS	LPTCNT		;BUMP COUNT OF LPTS
	SOJG	I,MORLPT	;LOOP THRU ALL LPTS
NOLPT:


ASKPLT:	MOVEI	N,0
	SKPFTT	PLT
	 JRST	NOPLTS

	MOVEI	N,SM.PLT	;MAX NUMBER OF PLOTTERS
	ASKDEC	<PLTS(0,0-*)[Plotters]>
	ADDM	N,M.PLT

NOPLTS:	FILCPU	<XP M.PLT,*@>,N


ASKPTP:	MOVEI	N,0
	SKPFTT	PTP
	 JRST	NOPTP

	ASKYN	<PTP(Y,N)[Paper tape punch]>
	ADDM	N,M.PTP

NOPTP:	FILCPU	<XP M.PTP,*@>,N


ASKPTR:	MOVEI	N,0
	SKPFTT	PTR
	 JRST	NOPTR

	ASKYN	<PTR(Y,N)[Paper tape reader]>
	ADDM	N,M.PTR

NOPTR:	FILCPU	<XP M.PTR,*@>,N
	FILCPU	<XP M.RX20,0@>	;CERTAINLY NOT ON A KL!

	FILCPU	<XP M.RX20,0@>	;CERTAINLY NOT ON A KL!


ASKXTC:
	MOVEI	N,0		;NO DA28S
	SKPFTT	DA28
	 JRST	NODA28		;NO

	MOVEI	N,SM.XTC	;MAX # OF DA28S
	ASKDEC	<# of DA28s(0,0-*)[Interprocessor channels for PDP8/11/15]>

NODA28:	FILOUT	<XP M.XTC,*@>,N
	FILCPU	<XP M.XTC,*@>,N
	JUMPE	N,XTCEND
	ASKDEC	<# of lines for TTY pool(8,0-512)[Lines reserved for use on DA28 channels]>
	FILOUT	<XP M.XTL,*@>,N

XTCEND:	FILCPU	<XP M.XTL,*@>,N
ASKD78:	MOVEI	N,0
	SKPFTT	DAS78
	 JRST	NODS78
	MOVEI	N,SM.D78	;MAXIMUM NUMBER OF DAS78'S
	ASKDEC	<# DAS78s(0,0-*)[IBM 360, 370, and/or 2780 support]>
	ADDM	N,M.DAS78	;ACCUMULATE TOTAL NUMBER IN SYSTEM
NODS78:	MOVEM	N,M.D78N	;SAVE NUMBER ON THIS CPU FOR COUNT DOWN
	JUMPE	N,ASK78B	;SEE IF ANY DAS78S
	PUSH	P,[0]		;PUT A 0 ON THE STACK TO COUNT UP
ASK78A:	PUSHJ	P,ASK78S	;ASK ABOUT THE DAS78'S
	AOS	(P)		;SET UP TO ASK ABOUT NEXT ONE
	SOSE	M.D78N		;ASKED ABOUT ALL DAS78'S?
	JRST	ASK78A		;NO, ASK ABOUT ANOTHER ONE
	POP	P,(P)		;CLEAN THE STACK
ASK78B:	FILCPU	<XP M.0D78,*@>,M.0D78
	FILCPU	<XP M.1D78,*@>,M.1D78
	FILCPU	<XP M.2D78,*@>,M.2D78
	FILCPU	<XP M.3D78,*@>,M.3D78
	FILCPU	<XP M.4D78,*@>,M.4D78
	FILCPU	<XP M.5D78,*@>,M.5D78
	FILCPU	<XP M.6D78,*@>,M.6D78
	FILCPU	<XP M.7D78,*@>,M.7D78
	FILCPU	<XP M.D78L,*@>,M.D78L
	FILCPU	<XP M.XXI,*@>,M.D78L
	FILCPU	<XP M.XXO,*@>,M.D78L
	JRST	ASK78C		;DONE DAS78'S.

ASK78S:	MOVE	N,-1(P)		;GET A NUMBER FOR DAS78
	TTYOCT	<@For DAS78 *:@@>
	ASKDEC	<Which DL10 port is the DAS78 connected to (0,0-7)]
Each DAS78 PDP11 is connected to a DL10 port]>
	PUSH	P,N		;SAVE PORT NUMBER ON STACK
	ASKDEC	<Decimal lines on the DAS78 (1-16)[
Each DAS78 can support up to 16 IBM 360s, 370s, and/or 2780s]>
	ADDM	N,M.D78L	;KEEP A SUM OF THE DAS78 LINES
	MOVE	T1,(P)		;GET DAS78 NUMBER
	MOVEM	N,M.0D78(T1)	;SAVE LINES IN PROPER PORT LOC
	POP	P,(P)		;CLEAN STACK
	POPJ	P,		;EXIT
ASK78C:
ASKD60:	MOVE	T1,[M.DN6D,,M.DN6D+1]
	SETZM	M.DN6D
	BLT	T1,M.BD60
	SETZ	N,
	SKPFTF	DN60		;SKIP IF NO DN60S
	 SKIPE	CPUN
	JRST	ASK60A

	MOVEI	N,SM.D60	;MAXIMUM NUMBER OF DN60'S
	ASKDEC	<# DN60s(0,0-*)[IBM BSC interfaces]>
ASK60A:	MOVEM	N,M.DN6D	;SAVE NUMBER FOR COUNT DOWN
	ADDM	N,M.DN60	;ADD TO GENERIC DN60 DEVICE COUNTER TOO
	SKIPE	CPUN
	JRST	ASK60C
	FILOUT	<XP M.DN6D,*@>,M.DN6D
	SKIPN	M.DN6D		;SEE IF ANY DN60'S
	JRST	ASK60C		;NO DN60'S
	PUSH	P,[0]		;PUT A 0 ON THE STACK TO COUNT UP
ASK60B:	PUSHJ	P,ASK60S	;ASK ABOUT THE DN60'S
	AOS	(P)		;SET UP TO ASK ABOUT NEXT ONE
	SOSE	M.DN6D		;ASKED ABOUT ALL DN60'S?
	JRST	ASK60B		;NO, ASK ABOUT ANOTHER ONE
	POP	P,(P)		;CLEAN THE STACK
ASK60C:	FILCPU	<XP M.0D60,*@>,M.0D60
	FILCPU	<XP M.1D60,*@>,M.1D60
	FILCPU	<XP M.2D60,*@>,M.2D60
	FILCPU	<XP M.3D60,*@>,M.3D60
	FILCPU	<XP M.4D60,*@>,M.4D60
	FILCPU	<XP M.5D60,*@>,M.5D60
	FILCPU	<XP M.6D60,*@>,M.6D60
	FILCPU	<XP M.7D60,*@>,M.7D60
	FILCPU	<XP M.D60L,*@>,M.D60L
	SKIPE	CPUN
	JRST	ASK60D
	FILOUT	<XP M.0D60,*@>,M.0D60
	FILOUT	<XP M.1D60,*@>,M.1D60
	FILOUT	<XP M.2D60,*@>,M.2D60
	FILOUT	<XP M.3D60,*@>,M.3D60
	FILOUT	<XP M.4D60,*@>,M.4D60
	FILOUT	<XP M.5D60,*@>,M.5D60
	FILOUT	<XP M.6D60,*@>,M.6D60
	FILOUT	<XP M.7D60,*@>,M.7D60
	FILOUT	<XP M.D60L,*@>,M.D60L
	JRST	ASK60D		;DONE DN60'S.

ASK60S:	MOVE	N,-1(P)		;GET A NUMBER FOR DN60
	TTYOCT	<@For DN60 *:@@>
	ASKOCT	<Which port is the DN60 connected to (0,0-7)[
DL10 number 1 has ports 0-3, DL10 number 2 has ports 4-7]>
	PUSH	P,N		;SAVE PORT NUMBER ON STACK
	ASKDEC	<Decimal lines on the DN60 (1-12)[
Each DN60 can support up to 12 IBM BSC interfaces]>
	ADDM	N,M.D60L	;KEEP A SUM OF THE DN60 LINES
	MOVE	T1,(P)		;GET DN60 NUMBER
	MOVEM	N,M.0D60(T1)	;SAVE LINES IN PROPER PORT LOC
	POP	P,(P)		;CLEAN STACK
	POPJ	P,		;EXIT
ASK60D:	FILOUT	<XP M.DN6K,0@>	;NO DN60 DEVICES ON KMC/DUP-11S
	FILOUT	<XP M.DN6R,0@>	;NO DN60 DEVICES ON DMRS
	FILOUT	<XP M.DN60,*@>,M.DN60 ;DUMP COUNT OF GENERIC DN60 DEVICES
	JRST	ASKCDR
DEVEND:	FILOUT	<XP M.CDR,*@>,M.CDR
	FILOUT	<XP M.CDP,*@>,M.CDP
	FILOUT	<XP M.TD10,*@>,DTA
	FILOUT	<XP M.LPT,*@>,LPTCNT
	FILOUT	<XP M.PLT,*@>,M.PLT
	FILOUT	<XP M.PTP,*@>,M.PTP
	FILOUT	<XP M.PTR,*@>,M.PTR
	FILOUT	<XP M.DAS78,*@>,M.DAS78
	FILOUT	<XP M.XXI,*@>,M.D78L
	FILOUT	<XP M.XXO,*@>,M.D78L
	FILOUT	<XP M.RX20,0@>
ASKPTY:	MOVEI	N,SM.PTY	;MAXIMUM NUMBER OF PTYS
	ASKDEC	<# PTYs(20,1-*)[Pseudo-terminals - each operator
service program and Batch stream needs one]>
	FILOUT	<XP M.PTY,*@>,N
	JRST	ASKDSY
KSGEN:	SETZM	CPUN		;ALWAYS CPU 0
	MOVEI	N,SM.PTY	;MAXIMUM NUMBER OF PTYS
	ASKDEC	<# PTYs(20,1-*)[Pseudo-terminals - each operator
service program and Batch stream needs one]>
	FILOUT	<XP M.PTY,*@>,N
	ASKDEC	<LPT(0,0-1)[Line printer]>,N
	FILOUT	<XP M.LPT,*@>,N
	FILCPU	<XP M.LPT,*@>,N
	JUMPE	N,KSGEN0	;JUMP IF NO LPT
	FILOUT	<XP M.CH*T,5@>,CHN	;CHANNEL TYPE 5
	FILOUT	<XP M.LP0C,*@>,CHN	;LPT CHANNEL NUMBER
	FILOUT	<XP M.*RH,0@>,CHN	;NO DISK RH11 THIS CHANNEL
	FILOUT	<XP M.*TR,0@>,CHN	;NO TAPE RH11 THIS CHANNEL
	PUSHJ	P,KSCHNO		;OUTPUT OTHER SYMBOLS FOR THIS CHANNEL
	AOS	CHN			;NEXT CHANNEL
	ASKYN	<Lower case(Y,N)[Does LPT have lower case]>,N
	FILOUT	<XP M.LP0L,*@>,N

KSGEN0:	MOVEI	N,0
	SKPFTT	CD20
	 JRST	NOCD2S

	ASKDEC	<CDR(0,0-1)[Card reader]>,n

NOCD2S:	FILOUT	<XP M.CDR,*@>,N
	FILCPU	<XP M.CDR,*@>,N
	JUMPE	N,KSGEN1		;JUMP IF NO CDR
	FILOUT	<XP M.CH*T,6@>,CHN	;CHANNEL TYPE 6
	FILOUT	<XP M.CD0C,*@>,CHN	;CDR CHANNEL NUMBER
	FILOUT	<XP M.*RH,0@>,CHN	;NO DISK RH11 THIS CHANNEL
	FILOUT	<XP M.*TR,0@>,CHN	;NO TAPE RH11 THIS CHANNEL
	PUSHJ	P,KSCHNO		;OUTPUT OTHER SYMBOLS FOR THIS CHANNEL
	AOS	CHN			;NEXT CHANNEL
KSGEN1:	FILOUT	<XP M.CHN,*@>,CHN	;TOTAL NUMBER OF CHANNELS

ASKPPS:	SETZ	N,
	SKPFTT	PTP
	 JRST	NOPTPS
	ASKYN	<PTP(Y,N)[Paper tape punch]>
	ADDM	N,M.PTP

NOPTPS:	FILCPU	<XP M.PTP,*@>,N

ASKPRS:	SETZ	N,
	SKPFTT	PTR
	 JRST	NOPTRS
	ASKYN	<PTR(Y,N)[Paper tape reader]>
	ADDM	N,M.PTR

NOPTRS:	FILCPU	<XP M.PTR,*@>,N
	MOVEI	N,SM.KDUP		;MAXIMUM NUMBER OF DUP-11S
	ASKDEC	<# KMC/DUP Lines(0,0-*)[Number of DUP-11 synchronous
line units attached to a KMC-11 controller.]>,N
	FILOUT	<XP M.KDUP,*@>,N
	SETZB	I,M.DN6K		;START AT DUP NUMBER 0
	JUMPE	N,KSDMR			;IF NO KMCS, JUST SEE ABOUT DMRS
	MOVE	P1,N			;COPY NUMBER OF DUP-11'S
KSDUP0:	CAML	I,P1			;ARE WE STILL IN RANGE?
	 JRST KSDMR			;NO, WRITE OUT ACCUMULATED STUFF
	MOVE	N,I			;Copy to where it will find it
	SKPFTF	DN60			;DN60 SUPPORT
	 JRST	DN60KS			;YES
	ASKLST	<Type of line for KDP* (ANF10,DECNET,USER)>
	JRST	D60SZ			;SKIP

DN60KS:	ASKLST	<Type of line for KDP* (ANF10,DECNET,USER,IBM)>

D60SZ:	CAIN	N,4-1			;IS THIS AN IBM LINE?
	 AOS	M.DN6K			;NOTE THAT WE HAVE A DN60 LINE
	AOS	P2,N			;BUMP TO MAKE DD.XXX SYMBOL
	FILOUT	<XP M.*KDP,>,I		;OUTPUT SYMBOL
	FILOUT	<*@>,P2			;OUTPUT VALUE FOR THE SYMBOL
	AOJA	I,KSDUP0		;GO TRY FOR THE NEXT LINE
KSDMR:	MOVEM	P1,M.KDPN		;SAVE NUMBER OF KDPS
	SETZM	M.DN6R			;NO DMR IBMCOMM...YET
	SETZ	N,			;ASSUME NONE
	SKPFTT	DMR
	 JRST	NODMRS			;NO
	MOVEI	N,SM.DMRN		;MAXIMUM NUMBER OF DMR11S
	ASKDEC	<# DMR11 Lines(0,0-*)[Number of DMR11 synchronous line
controllers.]>,N

NODMRS:	FILOUT	<XP M.DMRN,*@>,N
	ADD	P1,N			;GET TOTAL COMM LINES
	JUMPE	P1,KSGEN2		;IF NONE, TURN OF DN60, DECNET
	MOVE	P1,N			;SAVE NUMBER OF DMRs
	MOVEM	P1,M.DMRN		;SAVE NUMBER OF DMRS
	SETZ	I,			;START WITH DMR0
KSGENR:	CAML	I,P1			;DONE WITH ALL DMRs?
	 JRST	KSDUP7			;YES
	MOVE	N,I			;GET CURRENT DMR NUMBER
	SKPFTT	DN60			;DN60 SUPPORT?
	 JRST	NODN6R			;NO
	ASKLST	< DMR* line type(ANF10,DECNET,USER,IBM)>
	JRST	NODN6Y			;SKIP

NODN6R:	ASKLST	< DMR* line type(ANF10,DECNET,USER)>

NODN6Y:	CAIN	N,4-1			;IS THIS AN IBM LINE?
	 AOS	M.DN6R			;NOTE THAT WE HAVE A DN60 LINE
	AOS	P2,N			;BUMP TO MAKE DD.XXX SYMBOL
	FILOUT	<XP M.*DMR,>,I		;OUTPUT SYMBOL
	FILOUT	<*@>,P2			;OUTPUT VALUE FOR THE SYMBOL
	MOVE	N,I			;GET CURRENT DMR NUMBER
	ASKYN	< DMR* switched line(Y,N)[
 Does DMR* control a switched (dial-up) line]>,N
	EXCH	I,N			;NEED TO OUTPUT DMR #
	FILOUT	<XP DMR*SW,>,N
	EXCH	I,N			;RESTORE RESPONSE
	FILOUT	<*@>,N
	JUMPE	N,KSGENX		;IF NOT, SKIP REST
	MOVE	N,I
	ASKYN	< DMR* half duplex(Y,N)[
 Does DMR* control a half duplex line]>,N
	EXCH	I,N
	FILOUT	<XP DMR*HD,>,N
	EXCH	I,N
	FILOUT	<*@>,N
	JUMPE	N,KSGENX		;IF NOT, LONG START IS MEANINGLESS
	MOVE	N,I
	ASKYN	< Is DMR* secondary(Y,N)[
 Exactly one end of this link should be a secondary station.  Secondary
 status controls link startup only.]>,N
	EXCH	I,N
	FILOUT	<XP DMR*LS,>,N
	EXCH	I,N
	FILOUT	<*@>,N
KSGENX:	TTYOUT	<@>			;SEPERATE DMRS
	AOJA	I,KSGENR		;LOOP FOR NEXT

KSDUP7:	MOVE	T1,M.DN6K		;GET COUNT OF IBMCOM DEVICES
	ADD	T1,M.DN6R		;ADD IN DMR STYLE DN22S
	ADDM	T1,M.DN60		;ACCUMULATE
	SKIPE	M.DN60			;IF SOME LINE WANTED IBMCOMM
	 JRST	KSIBMQ			;FORCE IT TO LOAD, DON'T ASK
	SKPFTT	DN60			;DN60 SUPPORT
	 JRST	KSIBMQ			;NO
	ASKYN	<Load IBM communications software (Y,N)[
Allows using a KDP or DMR to talk to a DN22 IBM communications front-end.]>,N
	SKIPE	M.KDPN			;IF KDPS, CONSIDER
	 ADDM	N,M.DN6K		; THAT D6KINT WANTED
	SKIPE	M.DMRN			;IF DMRS, CONSIDER
	 ADDM	N,M.DN6R		; THAT D6RINT IS WANTED
	MOVE	T1,M.DN6K		;NUMBER OF KDP IBM LINES
	ADD	T1,M.DN6R		;GET TOTAL NUMBER OF COMM LINES
	MOVEM	T1,M.DN60		;THIS IS HOW MANY IBM LINES WE WANT

KSIBMQ:	FILOUT	<XP M.DN60,*@>,M.DN60	;TELL COMNET ABOUT IBMCOM
	FILOUT	<XP M.DN6K,*@>,M.DN6K	;LOAD D6KINT??
	FILOUT	<XP M.DN6R,*@>,M.DN6R	;LOAD D6RINT??
	JRST KSGEN3			;SKIP OVER DEFAULT CODE

KSGEN2:	FILOUT	<XP M.DECN,0@>		;SAY NO DECNET CODE
	FILOUT	<XP M.DN60,0@>		;NO IBM CODE
	FILOUT	<XP M.DN6K,0@>
	FILOUT	<XP M.DN6R,0@>
KSGEN3:	FILOUT	<XP MD.MOV,0@>	
	FILOUT	<XP MD.C10,0@>
	FILOUT	<XP M.CDP,0@>
	FILCPU	<XP M.CDP,0@>
	FILOUT	<XP M.VP10,0@>
	FILOUT	<XP M.340,0@>
	FILOUT	<XP M.VBXC,0@>
	FILOUT	<XP M.DIS,0@>
	FILOUT	<XP M.TD10,0@>
	FILCPU	<XP M.TD10,0@>
	FILOUT	<XP MD.DTC,0@>
	FILOUT	<XP M.PLT,0@>
	FILCPU	<XP M.PLT,0@>
	FILOUT	<XP M.PTP,*@>,M.PTP
	FILOUT	<XP M.PTR,*@>,M.PTR
	FILOUT	<XP M.DC44,0@>
	FILOUT	<XP M.XTC,0@>
	FILOUT	<XP M.XTL,0@>
	FILOUT	<XP M.DAS78,0@>
	FILCPU	<XP M.0D78,0@>
	FILCPU	<XP M.1D78,0@>
	FILCPU	<XP M.2D78,0@>
	FILCPU	<XP M.3D78,0@>
	FILCPU	<XP M.4D78,0@>
	FILCPU	<XP M.5D78,0@>
	FILCPU	<XP M.6D78,0@>
	FILCPU	<XP M.7D78,0@>
	FILOUT	<XP M.DN6D,0@>
	FILOUT	<XP M.0D60,0@>
	FILOUT	<XP M.1D60,0@>
	FILOUT	<XP M.2D60,0@>
	FILOUT	<XP M.3D60,0@>
	FILOUT	<XP M.4D60,0@>
	FILOUT	<XP M.5D60,0@>
	FILOUT	<XP M.6D60,0@>
	FILOUT	<XP M.7D60,0@>
	FILOUT	<XP M.8D60,0@>
	FILOUT	<XP M.9D60,0@>
	FILOUT	<XP M.AD60,0@>
	FILOUT	<XP M.BD60,0@>
	FILOUT	<XP M.RX20,*@>,RX20
	JRST	ASKDSY		;CONTINUE WITH NORMAL PATH
ASKDSY:	FILOUT	<@RADIX	10@>;	;SET RADIX TO DECIMAL IN FILE
	BTHOUT	<Decimal "symbol,value"[
For any symbols to be defined.
Type one per line, extra carriage return when through]@>
DSYLOP:	TLO	F,(F.BANG)	;ALLOW "!" IN EXPRESSIONS
	PUSHJ	P,TTYIN		;GET NEXT LINE
	  JRST	ASKDSY		;/HELP TYPED, ASK AT PROPER HELP MODE
	JUMPE	CH,DSYEND	;JUST A CR?
	PUSHJ	P,GETWRD	;GET FIRST WORD
	CAIE	CH,","		;IS IT FOLLOWED BY ,
	JRST	DSYERR		;NO, ERROR
	MOVE	CH,B		;COPY PLACE IN LINE
	ILDB	CH,CH		;GET NEXT CHAR
	CAIE	CH,"<"		;AN EXPRESSION? (>)
	 JRST	DSYDEC		;NO, CONTINUE NORMALLY
	PUSHJ	P,WIGEXP	;YES, GET A WIDGETED EXPRESSION
	 JRST	DSYERR		;OOPS.
	JRST	DSYLOP		;OK, STORE THE MESS
DSYDEC:	PUSHJ	P,GETDEC	;GET SECOND WORD AS DECIMAL
	JUMPN	CH,DSYERR	;IS IT LAST WORD ON LINE?
DSYPUT:	FILSTR	<XP *@>;	;YES, WRITE IT OUT
	JRST	DSYLOP		;LOOP BACK FOR NEXT LINE

DSYERR:	TTYOUT	<? Not symbol,value@>
	AOJA	LV,ASKDSY	;TRY AGAIN

DSYEND:	FILOUT	<RADIX	8@>;	;SET RADIX BACK TO NORMAL IN FILE
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>


ASKOSY:	BTHOUT	<@Octal "symbol,value"[
For any symbol to be defined.
Type one per line, extra carriage return when through]@>
OSYLOP:	TLO	F,(F.BANG)	;ALLOW "!" IN EXPRESSIONS
	PUSHJ	P,TTYIN		;GET NEXT LINE FOR USER
	  JRST	ASKOSY		;/HELP TYPED, ASK IN DESIRED HELP MODE
	JUMPE	CH,OSYEND	;JUST A BLANK LINE?
	PUSHJ	P,GETWRD	;NO, GET FIRST WORD
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	OSYERR		;NO, ERROR
	MOVE	CH,B		;COPY PLACE IN LINE
	ILDB	CH,CH		;GET NEXT CHAR
	CAIE	CH,"<"		;AN EXPRESSION? (>)
	 JRST	OSYOCT		;NO, CONTINUE NORMALLY
	PUSHJ	P,WIGEXP	;YES, GET A WIDGETED EXPRESSION
	 JRST	OSYERR		;OOPS.
	JRST	OSYLOP		;OK, STORE THE MESS
OSYOCT:	PUSHJ	P,GETOCT	;YES, GET VALUE IN OCTAL
	JUMPN	CH,OSYERR	;IS THIS END OF LINE?
OSYPUT:	FILSTR	<XP *@>		;YES, WRITE IT OUT
	JRST	OSYLOP		;LOOP BACK FOR MORE

OSYERR:	TTYOUT	<? Not symbol,value@>
	AOJA	LV,ASKOSY	;GO TRY AGAIN
;HELPER ROUTINE FOR DECIMAL AND OCTAL INPUT TO PROCESS EXPRESSIONS
;
;CALL KNOWING THAT THE NEXT CHAR IS A LEFT WIDGET
;
;RETURN: CPOPJ IF ERROR, CPOPJ1 IF OK

WIGEXP:	SETZ	I,		;AT LEVEL ZERO
WIGEX0:	ILDB	CH,B		;GET NEXT WIDGET
	JUMPE	CH,CPOPJ	;END OF LINE, ERROR
	CAIN	CH,"<"		;OPEN WIDGET
	 AOJA	I,WIGEX0	;YES, COUNT DEEPER (ALWAYS FIRST CHAR)
	CAIE	CH,">"		;CLOSE WIDGET?
	 JRST	WIGEX0		;NO, JUST WALK ALONG
	SOJG	I,WIGEX0	;YES, LESS DEEP.  CONTINUE IF NOT LAST ONE
	PUSHJ	P,SKBLNK	;SKIP TRAILING BLANKS
	JUMPN	CH,CPOPJ	;RETURN IF NOT AT EOL
	MOVSI	N,'*  '		;IF EXPRESSION MULTIPLIES, INCLUDE IT
	FILSTR	<XP *@>		;WRITE OUT THE ANSWER
	JRST	CPOPJ1		;SUCCESS

OSYEND:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>
ASKSSY:	BTHOUT	<@SIXBIT "symbol,value"[
For any sixbit symbol to be defined.
Type one per line, extra carriage return when through]@>
SSYLOP:	PUSHJ	P,TTYIN		;GET NEXT LINE
	  JRST	ASKSSY		;/HELP TYPED, ASK IN PROPER MODE
	JUMPE	CH,SSYEND	;CARRIAGE RETURN?
	PUSH	P,B		;SAVE BYTE POINTER TO STRING
	PUSHJ	P,GETWRD	;GET FIRST WORD
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	SSYERR		;NO, ERROR
	PUSHJ	P,GETWRD	;GET SECOND WORD
	JUMPN	CH,SSYERR	;ERROR IF MORE TYPE-IN
	POP	P,B		;RESTORE BYTE POINTER
	PUSHJ	P,GETWRD	;GET FIRST WORD AGAIN
	FILOUT	<XP *>,WD	;OUTPUT FIRST WORD
	PUSHJ	P,GETWRD	;GET SECOND WORD
	FILOUT	<,<SIXBIT/*/>@>,WD	;OUTPUT SIXBIT VALUE
	JRST	SSYLOP		;AND LOOK FOR MORE

SSYERR:	POP	P,B		;RESTORE PDL
	TTYOUT	<? Not symbol,value@>
	AOJA	LV,ASKSSY	;GO TRY AGAIN

SSYEND:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE USER TYPED /H<CR>
ASKSP1:	FILOUT	<@DEFINE	SPCINT>
	PUSHJ	P,FILLAB	;LEFT ANGLE BRACKET,CRLF TO FILE
ASKS1A:	BTHOUT	<Type "device-mnemonic,PI-channel" for special devices[
With neither channel AC save routine nor device data block,
the "device-mnemonic" must be 3 characters or less.
Type extra carriage return when through.]@>
SP1LOP:	PUSHJ	P,GETDPI	;GET NEXT LINE AND SCAN FOR DEV:PI
	  AOJA	LV,ASKS1A	;ERROR OR /HELP
	JUMPE	WD,SP1END	;JUST CR TYPED?
	RJUMPN	CH,<TTYOUT <? Not device-mnemonic,PI-channel@>
		AOJA	LV,ASKS1A>  ;GO ASK FOR MORE
	FILSTR	<SPASGINT *@>;	;OUTPUT ANSWER TO FILE
	JRST SP1LOP		;GO GET ANOTHER LINE

SP1END:	PUSHJ	P,FILRAB	;RIGHT ANGLE BRACKET,CRLF TO FILE
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>


ASKSP2:	FILOUT	<@DEFINE	SPCDDB>	;START MACRO DEFINITION
	PUSHJ	P,FILLAB	;LEFT ANGLE BRACKET,CRLF TO FILE
ASKS2A:	BTHOUT	<Type "device-mnemonic,PI-channel,no.-of-devices"[
For special devices with device data blocks.
the "device-mnemonic" must be 3 characters or less.
Type extra carriage return when through.]@>
SP2LOP:	PUSHJ	P,GETDPI	;GET NEXT LINE, AND SCAN FOR DEV:PI
	  AOJA	LV,ASKS2A	;/HELP OR ERROR, REASK QUESTION
	JUMPE	WD,SP2END	;JUST CR TYPED?
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	SP2ERR		;END OF LINE TOO SOON?
	PUSHJ	P,GETDEC	;GET NO. OF DEVICES
	JUMPN	CH,SP2ERR	;IS THIS LAST WORD ON LINE?
	FILSTR	<SPASGDDB *@>;	;YES, OUTPUT TRIPLE
	JRST	SP2LOP		;GO GET ANOTHER LINE

SP2ERR:	TTYOUT	<? Not device-mnemonic,PI-channel, no.-of-devices@>
	AOJA	LV,ASKS2A	;GO GET MORE

SP2END:	PUSHJ	P,FILRAB	;RIGHT ANGLE BRACKET,CRLF TO FILE
	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
				; IN CASE HE TYPED /H<CR>
ASKSP3:	FILOUT	<@DEFINE	SPCSAV>	;START MACRO DEFINITION
	PUSHJ	P,FILLAB	;LEFT ANGLE BRACKET,CRLF
ASKS3A:	BTHOUT	<Type "device-mnemonic,PI-channel,highest-ac-to-save"[
For special devices with channel save routines to save acs up to
the "highest-ac-to-save".  "Device" must be 3 char or less.
Type extra carriage return when through.]@>
SP3LOP:	PUSHJ	P,GETDPI	;GET NEXT LINE AND SCAN FOR DSK:PI
	  AOJA	LV,ASKS3A	;/HELP OR ERROR, REASK QUESTION
	JUMPE	WD,SP3END	;JUST CR TYPED?
	CAIE	CH,","		;IS BREAK AFTER PI A COMMA?
	JRST	SP3ERR		;NO, ERROR
	PUSHJ	P,GETOCT	;GET HIGHEST AC TO SAVE
	JUMPN	CH,SP3ERR	;IS THIS LAST ITEM ON LINE?
	CAILE	N,SM.AC		;SKIP IF LEGAL AC
	RJRST	<MOVEI	N,SM.AC
		TTYOCT	<? Highest-ac-to-save must be * or less@>
		AOJA	LV,ASKS3A>
	FILSTR	<SPASGSAV *@>;	;OUTPUT TRIPLE TO FILE
	JRST	SP3LOP		;GO GET NEXT LINE

SP3ERR:	TTYOUT	<? Not device-mnemonic,PI-channel,highest-ac-to-save@>
	AOJA	LV,ASKS3A	;GO ASK  FOR MORE
SP3END:	PUSHJ	P,FILRAB	;FILL IN A RIGHT ANGLE BRACKET


ASKEDN:	FILOUT	<@DEFINE	SPCEDN>	;START MACRO DEFINITION
	PUSHJ	P,FILLAB	;ADD LEFT ANGLE BRACKET
ASKEDA:	BTHOUT	<Type "ersatz-device,P,Pn,search-list-type"[
For customer defined ersatz devices.
The "esratz-device" must be exactly 3 characters long.
"P,Pn" is the Project/Programmer number associated.
"search-list-type" is one of ALL,SYS,JOB.
Type extra carriage return when through.]@>
EDNLOP:	PUSHJ	P,TTYIN		;GET NEXT INPUT LINE
	  AOJA	LV,ASKEDA	;/HELP OR ERROR
	JUMPE	CH,EDNEND	;ALL DONE
	PUSHJ	P,GETWRD	;GET ERSATZ DEVICE NAME
	CAIE	CH,","		;BREAK ON COMMA
	JRST	EDNER1		;NO, COMMAND ERROR
	TRNN	WD,770000	;MUST BE EXACTLY 3 CHARACTERS
	TLNN	WD,77		;...
	JRST	EDNER1		;ISN'T, GIVE ERROR
	PUSHJ	P,GETOCT	;GET PROJECT NUMBER
	JUMPE	CH,EDNER1	;MUST BE MORE FOLLOWING
	CAIE	CH,","		;BREAKON COMMA
	JRST	EDNER1		;NO, COMMAND ERROR
	PUSHJ	P,GETOCT	;GET PROGRAMMER NUMBER
	JUMPE	CH,EDNER1	;STILL MORE AFTER THAT
	CAIE	CH,","		;BREAKON COMMA
	JRST	EDNER1		;NO, COMMAND ERROR
	PUSHJ	P,GETWRD	;GET SEARCH LIST TYPE
	JUMPN	CH,EDNER1	;NOW THAT MUST BE THE LAST
	CAME	WD,[SIXBIT/ALL/] ;CHECK CHOICES
	CAMN	WD,[SIXBIT/SYS/] ;...
	JRST	EDNLO1		;OK, GO WRITE FILE
	CAME	WD,[SIXBIT/JOB/] ;LAST CHANCE
	JRST	EDNER1		;BAD ARGUMENT
EDNLO1:	FILSTR	<UERSTZ	*@>	;OUTPUT TO FILE
	JRST	EDNLOP

EDNER1:	TTYOUT	<?Not ersatz-device,P,Pn,search-list-type@>
	AOJA	LV,ASKEDA	;ASK AGAIN

EDNEND:	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET
ASKCMD:	FILOUT	<@DEFINE	SPCCMD> ;DEFINE THE MACRO
	PUSHJ	P,FILLAB	;PUT OUT THE LEFT ANGLE BRACKET
ASKCM1:	BTHOUT	<Type "command-name,dispatch,flags,unique-bits,PRVTAB-name"[
For customer defined commands.
The "command-name" is the name of the monitor command to be added.
"dispatch" is one of:
	omitted to run the program with the same name as the command
	the SIXBIT name of the program to run if different
	#address to use the already existing monitor location "address"
		as the dispatch routine for this command, e.g., #RUNQUE
"flags" are the flags used in the command table macros, e.g., RUNFLG
"unique-bits" are the command table unique bits, e.g., UNIQ.1
"PRVTAB-name is the name of the program to be added to PRVTAB, if any
Type extra carriage return when through.]@>
ASKCM2:	SETZM	UCMBGN		;ZERO FIRST WORD OF DATA
	MOVE	CH,[UCMBGN,,UCMBGN+1] ;SETUP BLT POINTER
	BLT	CH,UCMEND	;ZERO IT ALL
	TLO	F,(F.BANG)	;ALLOW "!" IN INPUT LINE
	PUSHJ	P,TTYIN		;GET THE LINE
	  AOJA	LV,ASKCM1	;/HELP TYPED
	JUMPE	CH,ASKC10	;GO IF NO COMMANDS SPECIFIED
	PUSHJ	P,GETWRD	;GET THE COMMAND NAME
	JUMPE	WD,ASKCME	;MUST NOT BE NULL
	CAIE	CH,","		;TERMINATOR A COMMA?
	JRST	ASKCME		;NO
	MOVEM	WD,UCMCMD	;STORE FOR LATER
	PUSHJ	P,GETWRD	;GET THE DISPATCH
	CAIE	CH,"#"		;WAS IT AN ADDRESS?
	JRST	ASKCM3		;NO, MUST BE A PROGRAM NAME OR NULL
	JUMPN	WD,ASKCME	;CAN'T HAVE XXX*
	PUSHJ	P,GETWRD	;GET THE ADDRESS
	JUMPE	WD,ASKCME	;MUST NOT BE NULL
	CAIE	CH,","		;TERMINATOR A COMMA?
	JRST	ASKCME		;NO
	MOVEM	WD,UCMADR	;STORE FOR LATER
	JRST	ASKCM4		;SKIP PROGRAM NAME STUFF
ASKCM3:	CAIE	CH,","		;TERMINATOR A COMMA?
	JRST	ASKCME		;NO
	MOVEM	WD,UCMPRG	;SAVE PROGRAM NAME OR NULL
ASKCM4:	MOVEM	B,UCMBP1	;SAVE BYTE POINTER POSITION
ASKCM5:	ILDB	CH,B		;GET NEXT CHARACTER
	JUMPE	CH,ASKCME	;CAN'T HAVE EOL HERE
	CAIE	CH,","		;SKIP THE FLAGS
	JRST	ASKCM5		;CONTINUE
ASKCM6:	ILDB	CH,B		;GET NEXT CHARACTER OF UNIQUE BITS
	JUMPE	CH,ASKCME	;CAN'T HAVE EOL HERE
	CAIE	CH,","		;FIND THE END?
	JRST	ASKCM6		;NO, CONTINUE
	MOVEM	B,UCMBP2	;STORE ENDING BYTE POINTER
	PUSHJ	P,GETWRD	;GET THE PRVTAB NAME
	JUMPN	CH,ASKCME	;MUST HAVE EOL HERE
	PUSH	P,WD		;SAVE FOR LATER
	FILOUT	<UCMDNM *>,UCMCMD ;START THE LINE
	FILOUT	<,>		;SEPARATE FIELDS WITH A COMMA
	SKIPN	N,UCMPRG	;GET THE PROGRAM NAME
	JRST	ASKCM7		;NULL
	FILOUT	<*>		;PUT IT OUT
ASKCM7:	FILOUT	<,>
	SKIPN	N,UCMADR	;GET THE ADDRESS
	JRST	ASKCM8		;NULL
	FILOUT	<*>		;PUT IT OUT
ASKCM8:	FILOUT	<,>
	MOVE	T1,UCMBP1	;GET THE INITIAL BYTE POINTER
ASKCM9:	ILDB	CH,T1		;GET NEXT CHARACTER
	CAIE	CH," "		;SKIP SPACES AND
	CAIN	CH,"	"	;  TABS
	JRST	ASKCM9
	PUSHJ	P,FILPUT	;PUT IT OUT
	CAME	T1,UCMBP2	;END OF STRING?
	JRST	ASKCM9		;NO, GET NEXT
	POP	P,N		;GET BACK PRVTAB NAME
	JUMPE	N,ASKC11	;GO IF NO PRVTAB NAME
	FILOUT	<*>		;PUT IT OUT
ASKC11:	FILOUT	<@>		;END THE LINE
	JRST	ASKCM2		;GET NEXT LINE
ASKCME:	TTYOUT	<?Incorrect syntax for user defined command@>
	AOJA	LV,ASKCM1
ASKC10:	PUSHJ	P,FILRAB	;END THE MACRO
ASKTRM:	FILOUT	<@DEFINE	SPCTRM>	;START THE MACRO
	PUSHJ	P,FILLAB	;ADD LEFT ANGLE BRACKET
ASKTRA:	BTHOUT	<Type "terminal-type/Alias,WIDTH,LENGTH,FF,TAB,LC,ALT,DISPLAY,CRLF,XON,8BIT,FILL,erase-to-EOL,backspace-space-backspace"[
For customer defined terminal types.

Terminal-type is the SIXBIT name of the terminal.
/Alias is optional.  Alias is the SIXBIT name sent to other systems on
set host.
WIDTH is the width of the terminal
LENGTH is the length/pagesize of the terminal
FF/NOFF is whether or not the terminal has hardware form feeds
TAB/NOTAB is wheither or not the terminal has hardware tabs
LC/NOLC is wheither or not the terminal is capabile of lower case
ALT/NOALT is wheither or not the terminal generates old altmodes
DIS/NODIS is wheither or not the terminal is a display terminal
CRLF/NOCRLF is wheither or not the terminal needs a CRLF at right margin
XON/NOXON is wheither or not ^S/^Q should pause the terminal
8BIT/NO8BIT is whether the terminal handles the 8-bit ASCII character set
FILL is the number of fill characters required for the terminal
Erase-to-EOL is address of sequences to cursor right and erase to EOL
Backspace-space-backspace is address of sequences to backspace, space, backspace

Type extra carriage return when through.]@>
TRMLOP:	PUSHJ	P,TTYIN		;GET NEXT INPUT LINE
	  AOJA	LV,ASKTRM	;/HELP OR ERROR
	JUMPE	CH,TRMEND	;ALL DONE
	PUSHJ	P,GETWRD	;READ TERMINAL TYPE
	JUMPE	WD,TRMERR	;AS IS NULL NAME
	CAIE	CH,"/"		;ALIAS?
	 JRST	TRMLP1		;NO, NORMALCY
	MOVEI	CH,","		;ALIAS
	DPB	CH,B		;REPLACE "/"
	PUSHJ	P,GETWRD	;SCAN THE ALIAS
	JUMPE	WD,TRMERR	;AS IS NULL NAME
TRMLP1:	CAIE	CH,","		;BREAK ON COMMA
	JRST	TRMERR		;NO--COMMAND ERROR
	PUSHJ	P,GETDEC	;READ WIDTH
	CAIE	CH,","		;BREAK ON COMMA
	JRST	TRMERR		;NO--COMMAND ERROR
	PUSHJ	P,GETDEC	;READ LENGTH 
	CAIE	CH,","		;BREAK ON COMMA
	JRST	TRMERR		;NO--COMMAND ERROR
	MOVSI	I,-TRMLEN	;LENGTH OF TERMINAL ATTRIBUTES
TRMLO1:	PUSHJ	P,GETWRD	;READ ATTRIBUTE
	CAIE	CH,","		;BREAK ON COMMA
	JRST	TRMERR		;NO--COMMAND ERROR
	JUMPE	WD,TRMERR	;AS IS NULL NAME
	CAMN	WD,TRMATT(I)	;MATCH ATTRIBUTE?
	 JRST	TRMLO2		;YES--OK
	TLC	WD,'NO '	;SEE IF /NOXYZ
	TLCE	WD,'NO '	;..
	JRST	TRMERR		;NO--ERROR
	LSH	WD,^D12		;SHIFT 'NO' OFF
	CAME	WD,TRMATT(I)	;MATCH NOW?
	 JRST	TRMERR		;NO--ERROR
TRMLO2:	AOBJN	I,TRMLO1	;LOOP FOR ALL
	PUSHJ	P,GETDEC	;READ FILL
	CAIE	CH,","		;BREAK ON COMMA
	JRST	TRMERR		;NO--COMMAND ERROR
	PUSHJ	P,GETWRD	;READ ERASE SEQUENCE
	CAIE	CH,","		;BREAK ON COMMA
	JRST	TRMERR		;NO--COMMAND ERROR
	PUSHJ	P,GETWRD	;READ BACKSPACE SEQUENCE
	JUMPN	CH,TRMERR	;NOW THAT MUST BE THE LAST
	FILSTR	<TERMCR	*@>	;OUTPUT TO FILE
	JRST	TRMLOP		;LOOP FOR ALL

TRMERR:	TTYOUT	<?Not a valid terminal attribute list format@>
	AOJA	LV,ASKTRA	;ASK AGAIN

;TABLE OF VALID TERMINAL ATTRIBUTES (SAME ORDER AS MACRO IN COMDEV)
TRMATT:	SIXBIT	/FF/
	SIXBIT	/TAB/
	SIXBIT	/LC/
	SIXBIT	/ALT/
	SIXBIT	/DIS/
	SIXBIT	/CRLF/
	SIXBIT	/XON/
	SIXBIT	/8BIT/
TRMLEN==.-TRMATT

TRMEND:	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET
	MOVE	LV,SAVLV	;RESTORE  PERMANENT HELP LEVEL
HDWEND:	POPJ	P,		;END OF HDWGEN, RETURN AND CLOSE FILE
SUBTTL	NETGEN - DIALOG TO DEFINE NETWORK CONFIGURATIONS

NETGEN:	FILOUT	<SUBTTL	NETCNF - NETWORK CONFIGURATION DEFINITION FILE OUTPUT BY MONGEN DIALOG@@@>
	FILOUT	<DEFINE XP(A,B),<A==:B>@@@>
	MOVEI	N,VERSION	;MONGEN PROGRAM VERSION NUMBER
	FILOUT	<XP M.NET,*@>,N ;OUTPUT TO FILE FOR COMMON TO CHECK FOR
	FILOUT	<XP M.RSS,0@>;	;OLD REMOTE STATION CODE SWITCH OFF
	FILOUT	<XP M.DS10,0@>;	;NO DS10
	FILOUT	<XP M.DP01,0@>;	;OR DP01
ASKNET:	SKPFTT	DC72		;PDP8-SUPPORT?
	 JRST	NODC72
	ASKYN	<Network software(Y,N)[
Software to support remote computers: DECsystem-10's,
PDP-11's, PDP-8's (requires FTNET to be -1)]>
	JRST	DC72Z1

NODC72:	ASKYN	<Network software(Y,N)[
Software to support remote computers: DECsystem-10's and
PDP-11's (requires FTNET to be -1)]>

DC72Z1:	FILOUT	<XP M.NET,*@>
	JUMPE	N,NETNON
	SETZM	M.DL10		;ASSUME NO DL10'S
	MOVEI	P1,1		;COUNT FRONT ENDS STARTING AT 1
	MOVEI	N,SM.CPU
	SKPFTF	CPUS		;MORE?
	 MOVEI	N,SU.CPU	;YES
	SKPFTT	DN87
	 SKPFTF	DC75
	CAIA
	 JRST	NO76Z2

	ASKDEC	<Cpu's(1,1-*)[Total number of cpu's in the system]>

NO76Z2:	MOVEM	N,M.CPU
	SETOM	CPUN
ASKNT1:	AOS	N,CPUN
	CAML	N,M.CPU
	JRST	ASKCEN
	SKIPE	CPUN
	JRST	ASK85B
	SKPFTT	DC75
	 SKPFTF	DN87
	CAIA
	JRST	ASK85B		;NONE
	ASKDEC	<How many DC75NP's or DN87's on CPU*(1,0-8)[Network
front-ends connected to DL10's.]>
	MOVEM	N,M.DC75	;store number of 75/87's
	FILOUT	<XP M.DC75,*@>,M.DC75
	SKIPN	M.DC75		;ask which ports if non-zero
	JRST	ASK85B		;if none, write out symbols as zeros
	SETZ	P2,		;P2=0 SAYS DL10 INTERFACE
ASK85A:	PUSHJ	P,ASK85S	;ask which port
	ADDI	P1,1		;increment counter
	SOSE	M.DC75		;are we done?
	JRST	ASK85A		;no, continue
ASK85B:	FILCPU	<XP M.0D85,*@>,M.0D85 ;OUTPUT ALL SYMBOLS

	FILCPU	<XP M.1D85,*@>,M.1D85
	FILCPU	<XP M.2D85,*@>,M.2D85
	FILCPU	<XP M.3D85,*@>,M.3D85
	FILCPU	<XP M.4D85,*@>,M.4D85
	FILCPU	<XP M.5D85,*@>,M.5D85
	FILCPU	<XP M.6D85,*@>,M.6D85
	FILCPU	<XP M.7D85,*@>,M.7D85
	JRST	ASKNT1
ASKCEN:	ASKOCT	<ANF node number of central site(1,1-77)[
Unique octal number identifying system to ANF network.]>
	FILOUT	<XP OURNNM,*@>,N
ASKNNM:
	ASKSTR	<Name of central site[Six characters or less.]>
	CAILE	N,^D6	;CORRECT NUMBER?
	RJRST	<TTYOUT		<%More than 6 characters.@>
		JRST	ASKNNM>
	FILSTR	<@DEFINE	SYSNDE
	<SIXBIT	&*&>@>

	MOVEI	N,SM.RMCR	;MAX REMOTE TTY'S
	ASKDEC	<# of remote TTY's(1,1-*)[
Maximum number of teletypes on ANF network nodes to be
handled at any given time.]>,N
	FILOUT	<XP M.RMCR,*@>,N

	ASKYN	<ANF Network virtual terminals(Y,N)[
Code to allow local terminals to "SET HOST" to other systems.]>,N
	FILOUT	<XP M.RVTM,*@>,N

	ASKYN	<Remote card readers(Y,N)[
Code to allow access to card readers on ANF remote stations.]>,N
	FILOUT	<XP M.RCDR,*@>,N

	ASKYN	<Remote line printers(Y,N)[
Code to allow access to line printers on ANF remote stations.]>,N
	FILOUT	<XP M.RLPT,*@>,N

REPEAT 0,<			;FOR NOW, TILL DRIVERS ARE WRITTEN
	ASKYN	<Remote paper tape punches(Y,N)[
Code to allow access to paper tape punches on ANF remote stations.]>,N
	FILOUT	<XP M.RPTP,*@>,N

	ASKYN	<Remote paper tape readers(Y,N)[
Code to allow access to paper tape readers on ANF remote stations.]>,N
	FILOUT	<XP M.RPTR,*@>,N

	ASKYN	<Remote plotters(Y,N)[
Code to allow access to plotters on ANF remote stations.]>,N
	FILOUT	<XP M.RPLT,*@>,N
>				;END REPEAT 0

	ASKYN	<Remote DN8x DDCMP devices(Y,N)[
Code to allow access to DN8x LBLK-to-DDCMP devices on ANF remote stations.]>,N
	FILOUT	<XP M.RDDP,*@>,N
	ASKYN	<Remote data entry terminals(Y,N)[
Code to allow access to remote data entry terminals (RDX devices).]>,N
	FILOUT	<XP M.RDX,*@>,N

	ASKYN	<Remote task-to-task through ANF(Y,N)[
Code to allow access to remote jobs (TSKSER).]>,N
	FILOUT	<XP M.RJOB,*@>,N

	MOVEI	N,SM.CONN/2	;DEFAULT TO HALF THE MAX.
	ASKDEC	<# of ANF connects(*,1-512)[
Maximum number of simultaneous connections.]>,N
	FILOUT	<XP M.CONN,*@>
	ASKYN	<DECnet software(Y,N)[
Load monitor modules needed to communicate with other DECnet nodes]>
	FILOUT	<XP M.DECN,*@>,N ;TELL COMMONS IF DECNET WANTED
	JUMPE	N,ASKETH	;NO, SKIP OVER ALL THIS STUFF
	ASKDEC	<DECnet area number of central site(1,1-63)[
Decimal area number for multi-area DECnet network configurations.]>
	FILOUT	<XP %RTHOM,*@>,N
	ASKDEC	<DECnet node number of central site(1,1-1023)[
Unique decimal number identifying system to DECnet network.]>
	FILOUT	<XP %RTADR,*@>,N
	ASKLST	<DECnet router type(ROUTING,NONROUTING)[
ROUTING nodes can have multiple circuits and perform DECnet routing.
NONROUTING nodes have only an ethernet circuit and perform no DECnet routing.]>
	ADDI	N,4		;CONVERT TO VALUES 4(ROUTING) AND 5(NONROUTING)
	FILOUT	<XP %RTRTY,*@>,N

	SKPFTT	RTRXPW		;Question enabled?
	 JRST ASKETH		;NO
ASKXPW:	ASKSTR	<Transmit password(DECNET20)[
Password used when initializing a point-point --KDP, DTE, or DMR-- link.
64 characters or less]>
	CAILE	N,^D64		;24 OR LESS?
	RJRST	<TTYOUT <? More than 64 characters@>
		 JRST	ASKXPW>
	MOVSI	N,'*  '		;IN CASE "*" IS IN PASSWORD
	FILSTR	<DEFINE	%RTXPW<RTRPW <*>>@>

ASKETH:	ASKYN	<Ethernet software(Y,N)[
Load monitor modules needed to communicate via Ethernet]>
	FILOUT	<XP M.ENET,*@>,N ;TELL COMMONS IF DECNET WANTED
	JUMPN	N,ASKLAT	;YES, GO ASK ABOUT LAT TERMINALS
	FILOUT	<XP M.LATN,0@>
	JRST	NETEND
ASKLAT:	ASKYN	<Include LATSER(Y,N)[
Load monitor module to communicate with
terminal concentrators via Ethernet]>
	FILOUT	<XP M.LATN,*@>,N
	JRST	NETEND
NETNON:				;DEFINE ALL SYMBOLS AS ZERO
	FILOUT	<XP M.NODE,0@>
	FILOUT	<XP M.DC75,0@>
	FILCPU	<XP M.0D85,0@>
	FILCPU	<XP M.1D85,0@>
	FILCPU	<XP M.2D85,0@>
	FILCPU	<XP M.3D85,0@>
	FILCPU	<XP M.4D85,0@>
	FILCPU	<XP M.5D85,0@>
	FILCPU	<XP M.6D85,0@>
	FILCPU	<XP M.7D85,0@>
	FILOUT	<XP OURNNM,0@>
	FILSTR	<@DEFINE SYSNDE<>@>
	FILOUT	<XP M.CONN,0@>
	FILOUT	<XP M.RMCR,0@>
	FILOUT	<XP M.RVTM,0@>
	FILOUT	<XP M.RCDR,0@>
	FILOUT	<XP M.RLPT,0@>
	FILOUT	<XP M.RPTR,0@>
	FILOUT	<XP M.RPTP,0@>
	FILOUT	<XP M.RPLT,0@>
	FILOUT	<XP M.RDDP,0@>
	FILOUT	<XP M.RJOB,0@>
	FILOUT	<XP M.RDX,0@>
	FILOUT	<XP M.DECN,0@>
	FILOUT	<XP M.ENET,0@>
	FILOUT	<XP M.LATN,0@>
NETEND:	POPJ	P,		;END OF NETGEN, RETURN AND CLOSE FILES
ASK85S:	MOVE	N,P1		;GET FRONT END #
	TTYOCT	<For front end number *:@>;identify which PDP11
	JUMPN	P2,ASK851	;DO RIGHT MESSAGE FOR DL10/DTE-20
	ASKDEC	<To which DL10 port is the DC75 or DN87 connected (0,0-7)[]>;ask port
	JRST	ASK852		;SKIP DTE-20 QUESTION

ASK851:	ASKDEC	<To which DTE20 is the DN87S connected (1,1-3)[]>
ASK852:	MOVE	T1,N		;use answer as index
	MOVEI	N,1		;value to set word M.nD85 to
	MOVEM	N,M.0D85(T1)	;set word to 1 indicating port in use as 85
	POPJ	P,		;return
SUBTTL	ASK ROUTINES - ASK QUESTION ON TTY, FILE AND GET ANSWER

;LSTEXP - ROUTINE TO DO LIST OR EXPLAIN MODE FOR FGEN
;CALL:	MOVEI	N,1 OR 2 FOR LIST OR EXPLAIN
;	PUSHJ	P,LSTEXP
;	RETURNS WHEN DONE

LSTEXP:	CAIE	N,1		;SKIP IF LIST, NOT IF EXPLAIN
	TLOA	F,(F.EXP)	;SET EXPLAIN FLAG FOR EXPLAIN
	TLZ	F,(F.EXP)	;CLEAR EXPLAIN FLAG FOR LIST
ASKLEX:	TTYOUT	<Switch(switch to list or explain)[
Type name of switch to be listed or explained or ALL or /HELP.
Type extra carriage return when through.]@@>
LEXLOP:	PUSHJ	P,TTYIN		;GET SWITCH TYPED
	  JRST	ASKLEX		;/HELP TYPED
	JUMPE	CH,LEXXIT	;EXIT IF BLANK LINE
	PUSHJ	P,GETWRD	;GET SWITCH NAME
	RJUMPN	CH,<MOVE N,WD	;;N=SWITCH NAME TYPED
		    TTYOUT <? Unknown switch *@>
		    JRST ASKLEX>
	CAMN	WD,[SIXBIT .ALL.]	;SKIP IF NOT "ALL"
	JRST	ALLLEX		;DO ALL SWITCHES IN TABLE AND EXIT
	PUSHJ	P,LEXSWT	;LIST OR EXPLAIN THIS SWITCH
	  JRST	ASKLEX		;ILLEGAL SWITCH, RETYPE PROMPT
	JRST	LEXLOP		;OK, WAIT FOR ANOTHER

LEXXIT:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
	POPJ	P,		;AND RETURN

;HERE IF WANT ALL SWITCHES
ALLLEX:	HRLZ	T1,FTLEN	;AOBJN PTR TO TABLE
ALLLE1:	PUSH	P,T1		;SAVE AOBJN PTR
	SKIPN	WD,@FTTAB	;SKIP IF HAVE A SWITCH HERE
	JRST	ALLLE2		;NO, IGNORE IT
	TLZ	WD,777700	;CLEAR JUNK
	TLO	WD,'FT '	;MAKE SWITCH BE FT...
	PUSHJ	P,LEXSWT	;LIST OR EXPLAIN THIS SWITCH
	  JFCL			;IGNORE ERRORS THAT SHOULDN'T HAPPEN
ALLLE2:	POP	P,T1		;RESTORE AOBJN PTR
	AOBJN	T1,ALLLE1	;LOOP FOR WHOLE TABLE
	POPJ	P,		;RETURN
;LEXSWT - ROUTINE TO LIST OR EXPLAIN ONE SWITCH
;CALL:	MOVE	WD,SWITCH NAME
;	PUSHJ	P,LEXSWT
;	RETURN HERE IF UNKNOWN SWITCH
;	RETURN HERE IF FOUND, LIST OR EXPLAIN DONE

LEXSWT:	HLRZ	N,WD		;N=FIRST THREE CHARS
	TRZ	N,77		;ONLY LOOK AT FIRST TWO
	CAIE	N,'FT '		;SKIP IF FT...
	RJRST	<MOVE N,WD
		 TTYOUT <? Unknown switch *@>
		 POPJ P,>
	TLZ	WD,777700	;CLEAR UNWANTED JUNK
	RJUMPE	WD,<TTYOUT <? Unknown switch@>
		    POPJ P,>
	PUSHJ	P,FNDSWT	;FIND SWITCH IN TABLE
	MOVE	N,WD		;N=SWITCH NAME, WT1=INDEX IN TABLE
	TLO	N,'FT '		;ADD BACK "FT"
	RJUMPGE	T1,<TTYOUT <? Unknown switch *@>
		    POPJ P,>
	PUSH	P,N		;SAVE NAME OF SWITCH IN CASE EXPLAINING
	SKIPL	@FTTAB		;SKIP IF VALUE IS ON
	JRST	LEXSW1		;NO, SWITCH IS OFF
	TTYOUT	<*,-1>
	JRST	LEXSW2
LEXSW1:	TTYOUT	<*,0>
LEXSW2:	POP	P,WD		;RESTORE NAME OF SWITCH TO LOOKUP EXPLANATION
	AOS	(P)		;OK, GIVE SKIP RETURN AND FINISH UP
	TLNE	F,(F.EXP)	;SKIP IF LIST, NOT IF EXPLAIN
	PJRST	LEXSW3		;DO EXPLAIN
	TTYOUT	<@>
	POPJ	P,

;HERE TO EXPLAIN SWITCH
;HERE TO POSITION FGEN HELP FILE AT EXPLANATION FOR THIS SWITCH, WD IS SET UP
LEXSW3:	FHLPOS	*,LEXSWE
	PUSHJ	P,FHLPTT	;COPY TO TTY
LEXSWE:	TTYOUT	<@>
	POPJ	P,		;RETURN
;FNDSWT - ROUTINE TO FIND A SWITCH IN THE TABLE
;CALL:	MOVE	WD, SWITCH NAME WITH "FT" CLEARED
;	PUSHJ	P,FNDSWT
;	RETURN	N=INDEX OF SWITCH IN TABLE, OR GE 0 IF NOT IN TABLE

FNDSWT:	HRLZ	T1,FTLEN	;AOBJN PTR TO SWITCH TABLE

FNDSW1:	HRLOI	N,77		;N=MASK FOR 4 CHARS
	AND	N,@FTTAB	;N=NEXT SWITCH NAME IN TABLE
	CAME	N,WD		;SKIP IF FOUND MATCH
	AOBJN	T1,FNDSW1	;NO, TRY NEXT IN TABLE
	POPJ	P,
;ASKSYS - ROUTINE TO FIND OUT WHAT TYPE OF SYSTEM
;CALL:	PUSHJ	P,ASKSYS
;	RETURN	N=INDEX OF TYPE OF SYSTEM

ASKSYS:
	SKPFTT	CPUTYP		;SKIP IF UNSUPPORTED TYPES
	 JRST	ASKSYX		;SUPPORTED
	ASKLST	<DECsystem10(1070,1080,1090,1091,2020)[
1070 is a system with KI10 cpu's
1080 is a system with KL10 cpu's
1090 is a system with KL10 cpu's and internal channels
1091 is a system with a KL10 cpu, internal memory, and devices
 on the front end
2020 is a system with a KS10 cpu]>
	JRST	ASKSYY		;SKIP
ASKSYX:	ASKLST	<DECsystem10(KL,KS)[
KL is a system with KL10 cpu's and internal channels
KS is a system with a KS10 cpu]>
	CAIN	N,0		;ALL KL'S
	MOVEI	N,2		; MAP TO 2
	CAIN	N,1		;AND KS'S
	MOVEI	N,4		; MAP TO 4
ASKSYY:	CAILE	N,MP.SMX	;IS THIS A PDP10I SYSTEM?
	RJRST	<MOVEI	N,MP.MVN  ;MONITOR VERSION NUMBER
		TTYOUT <? Not available in * monitor@>,N
		 JRST	ASKSYS>
	MOVEM	N,CNFIND	;SAVE INDEX OF SYSTEM TYPE
	AOS	M.1070(N)	;SET ONE OF THE VARIABLES TO 1
				; M.1070, M.1080, M.1090, M.1091, M.2020
	CAIE	N,4		;2020?
	JRST	ASKSY1		;NO--GO ON
	AOS	M.KS10		;YES--SET RIGHT FLAG
	POPJ	P,		;RETURN
ASKSY1:	SKIPN	N
	AOSA	M.P10I
	AOS	M.KL10
	POPJ	P,		;RETURN
;ASKYN - ROUTINE TO ASK AND ACCEPT A Y OR N ANSWER
; USED WHEN ONLY CHOICE OF PRESENCE OR ABSENCE IS POSSIBLE
;CALL:	ASKYN	<...(Y,N)[...]>
;	RETURN	N=1 IF Y, N=0 IF N
; NOTE: (Y,N) MUST BE IN THIS ORDER, SO USER KNOWS DEFAULT ALWAYS IS Y

ASKZYN:
ASKYN:	PUSHJ	P,ASKLS1	;ASK QUESTION, GET ANSWER POSITION IN N
	MOVS	T1,ASKTAB+0	;IS FIRST PROMPT
	CAIE	T1,'Y  '	;Y FOR YES?
	JRST	ASKYNE		;NO, ERROR
	MOVS	T1,ASKTAB+1	;YES, IS SECOND PROMPT
	SKIPN	ASKTAB+2	;ARE THERE MORE THAN TWO CHOICES?
	CAIE	T1,'N  '	;NO, IS IT N?
ASKYNE:	RJRST	<EREXIT	<ASKYN called without (Y,N) in above message>,>
	JUMPE	N,ASKY		;FIRST ITEM IN LIST(Y)?

;HERE ON N ANSWER
	TDZA	N,N		;RETURN 0

;HERE ON Y ANSWER
ASKY:	MOVEI	N,1		;RETURN 1
	POPJ	P,
;ROUTINE TO ASK QUESTON WITH PROMPTING ANSWERS IN A LIST IN PARENS
;CALL:	ASKLST	<...(ANS0,ASN1,ANS2,...)[...]>
;	RETURN HERE WITH N=0,1,2,...
;	IF JUST CR TYPED, N=0 TO MEAN FIRST ITEM BY DEFAULT
;ABBREVIATIONS ARE ALLOWED LIKE MONITOR COMMANDS
; IF WRONG ANSWER IS GIVEN, THE FOLLOWING ERROR MESSAGE IS TYPED:
; ? ANSWER MUST BE ONE OF (ANS0,ANS1,ANS2,...)
; FOLLOWED BY A REPEAT OF QUESTION IN NEXT LONGEST MODE
;IF A LIST OF PROMPTINGS IS NOT INCLUDED IN PARENS,
; ? INTERNAL MONGEN ERROR  - NO CHOICES IN PARENS - EDIT MONGEN


ASKLST:	PUSHJ	P,ASKLS1	;ASK AND GET ANSWER
	MOVS	T1,ASKTAB+0	;IS FIRST PROMPT
	CAIE	T1,'Y  '	;Y
	CAIN	T1,'N  '	; OR N?
	JRST	ASKLSE		;YES, ERROR SHOULD USE ASKYL INSTEAD
	MOVS	T1,ASKTAB+1	;IS SECOND PROMPT
	CAIE	T1,'Y  '	;Y
	CAIN	T1,'N  '	;OR N?
ASKLSE:	RJRST	<EREXIT	<ASKLST called with (Y,N) in above question
- Edit MONGEN to call ASKYN instead of ASKLST@>,>
	POPJ	P,		;RETURN WITH N SET TO POSITION OF ANSWER

;SUBROUTINE TO DO THE WORK OF ASKING AND GETTING ANSWER.
;CALLED BY ASKLST AND ASKYN

ASKLS1:	MOVEI	R,^D10		;SET RADIX TO 10(IN CASE * SUBS.)
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION OVER AGAIN AFTER ERROR OR /HELP
ASKOVR:	MOVE	N,(P)		;REESTORE ORIGINAL N INCASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO TTY
	HRRZ	T1,-1(P)	;ADR OF ASK MESSAGE
	PUSHJ	P,SETASK	;SET UP LIST OF CHOICES IN ASKTAB
				; FROM SCANNING LIST OF PROMPTINGS
	PUSHJ	P,TTYIN		;ASK FOR INPUT LINE, OUTPUT TO FILE AS COMMENT
	  JRST	ASKOVR		;/HELP TYPED, REASK IN DESIRED HELP MODE
	PUSHJ	P,FNDASK	;NO, LOOK FOR HIS ANSWER IN ASKTAB
	  AOJA	LV,ASKOVR	;NOT THERE, ASK QUESTION AGAIN WITH MORE HELP
				; BY MAKIN LEVEL ONE HIGHER
	JRST	ASKXIT		;FOUND, RESTORE LEVEL
				; TO THAT BEFORE QUESTION AND RETURN
;ROUTINE TO SCAN MESSAGE FOR PROMPTING ANSWERS
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,SETLST
;	  RETURN ONLY IF ANSWERS IN PARENS FOUND
;	ELSE PRINT ? INTERNAL MONGEN ERROR - NO ( IN ABOVE MESSAGE,
; ADD (ANS0,ASN1,ASN2...) TO MONGEN BY EDITING
; B IS PRESERVED

SETASK:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,B		;SAVE BYTE POINTER(NOT AN ARGUMENT)
				; CALLER MAY HAVE SOMETHING IN IT
	PUSH	P,N		;SAVE POSSIBLE SUBSTITUTION

;LOOP TO FIND LEFT PAREN
ASK0:	ILDB	CH,T1		;GET NEXT CHAR IN ASK MESSAGE
	RJUMPE	CH,<EREXIT <? No (ANS0,ASN1,...) in above question - Edit MONGEN>,>
	CAIE	CH,"("		;LEFT PAREN?
	JRST	ASK0		;NO, KEEP LOOKING
	MOVEI	N,0		;SET ANSWER INDEX TO 0
	MOVE	B,T1		;SETYUP BYTE POINTER TO PROMPTING LIST FOR GETWRD

;LOOP TO BREAK PROMPTING ANSWERS - N=0,1,... FOR EACH ANSWER
ASK2:	PUSHJ	P,GETWRD	;GET NEXT WORD INSIDE PARENS
	CAIE	CH,"*"		;SKIP IF WANT SUBSTITUTION
	JRST	ASK2A		;NO, KEEP CHECKING
	JUMPN	WD,ASK2E	;JUMP IF SOMETHING PRECEEDED *, ERROR
	MOVE	WD,(P)		;RESTORE SUBSTITUTION
ASK2A:	MOVEM	WD,ASKTAB(N)	;ANS STORE ANSWER AWAY
	CAILE	N,MP.AMX	;MORE THAN MAX. NO. OF ANSWERS FOR MONGEN?
	RJRST	<EREXIT <Too many prompts in above question - Edit MONGEN@>,>
	CAIN	CH,","		;WAS BREAK CHAR A COMMA?
	AOJA	N,ASK2		;YES, GO BACK AND GET NEXT PROMPTING WORD
	SETZM	ASKTAB+1(N)	;CLEAR LAST ARG PLUS 1 AS END FLAG
	POP	P,N		;RESTORE N
	POP	P,B		;RESTORE CALLERS BYTE POINTER
	CAIN	CH,")"		;NO, WAS BREAK RIGHT PAREN?
	POPJ	P,		;YES, RETURN
ASK3E:	EREXIT	<Special character inside () above
Edit MONGEN and remove it.>,

ASK2E:	EREXIT	<Error in above question - Edit MONGEN@>,
;ROUTINE TO FIND ONE OF A LIST OF ANSWERS IN ASKTAB USING ASCIZ STRING
;CALL:	MOVE	POSSIBLE ANSWERS TO ASKTAB+0,+1,... STORE 0 IN LAST+1
;				(SEE SETASK ROUTINE)
;	MOVE	B,BYTE POINTER TO ASCIZ STRING
;	PUSHJ	P,FNDASK(BREAK = CR) OR FNDAS1(BREAK = ANY)
;	  NOT FOUND RETURN, ERROR MESSAGE PRINTED
;	OK RETURN, N = POSITION OF ANSWER IN LIST = 0,1,2
;	N=0 IF JUST A CR TYPED
; ALLOW 0 IN ASKTAB+0 AS LEGAL ANSWER TO MEAN NO DEFAULT

FNDAS1:	PUSHJ	P,GETWRD	;GET USER SUPPLIED ANSWER
	JRST	FNDAS2		;SKIP CHECK FOR BREAK MUST BE EOL

FNDASK:	PUSHJ	P,GETWRD	;GET USER SUPPLIED ANSWER
	RJUMPN	CH,<TTYOUT <? Type one answer followed by carriage return@>
		popj p,>	;error return, so ask question again
FNDAS2:	TLZ	F,(F.MTCH)	;CLEAR MATCH FOUND FLAG
	SETZB	N,SAVN		;SET ANSWER INDEX TO 0
	JUMPE	WD,ASK8		;JUST A CR TYPED?
	MOVEI	T1,0		;NO, FORM MASK FOR ABBREVIATION
ASK5:	ROT	T1,6		;MOVE MASK LEFT 1 CHAR POSITION
	IORI	T1,77		;SET LOW ORDER CHAR MASK
	TDNN	WD,T1		;ANY CHARS IN THESE LOW ORDER POSITIONS?
	JRST	ASK5		;NO, LOOK AT NEXT CHAR TO LEFT
	LSH	T1,-6		;YES, MOVE MASK SO ONLY COVERS CHARS NOT TYPED
	MOVE	T2,ASKTAB(N)	;GET FIRST POSSIBLE ANSWER. MAYBE 0 IF
				; NO DEFAULT ALLOWED, IE (,ANS0,ANS1,...)

;LOOP TO SCAN FOR MATCH WITH PROMPTING ANSWERS STORED IN ASKTAB
ASK6:	CAMN	T2,WD		;SKIP IF NOT EXACT MATCH
	JRST	ASK9		;YES, TAKE THIS IMMEDIATELY
	TDZ	T2,T1		;CLEAR OUT CHARS USER DID NOT TYPE
	CAME	T2,WD		;MATCH THE CHARS HE DID TYPE?
	JRST	ASK7		;NO, GO GET NEXT ANSWER
	MOVEM	N,SAVN		;YES, SAVE ANSWER INDEX
	TLOE	F,(F.MTCH)	;ALREADY FOUND A MATCH?
	RJRST	<TTYOUT	<? Type enough to uniquely distinguish answer@>
		 POPJ	P,>	;ERROR RETURN
ASK7:	SKIPE	T2,ASKTAB+1(N)	;GET NEXT PROMPT, IS THERE ONE?
	AOJA	N,ASK6		;YES, BUMP ANSWER INDEX
	TLNN	F,(F.MTCH)	;NO, WAS A MATCH FOUND?
	RJRST	<TTYOUT	<? Answer with one of the choices inside parens@>
		 POPJ	P,>	;ERROR RETURN
ASK8:	MOVE	N,SAVN		;YES, RETURN THE MATCH INDEX
ASK9:	SKIPN	ASKTAB(N)	;SKIP IF DEFAULT ALLOWED
	RJRST	<TTYOUT <? No default allowed@>
		POPJ P,>
	JRST	CPOPJ1		;GIVE OK RETURN
;ROUTINE TO ASK QUESTION AND GET DECIMAL ANSWER AND CHECK FOR LIMITS
;CALL:	ASKDEC	<QUESTION(DEFAULT,MIN-MAX)[...]>
;	RETURN HERE WITH N AS VALUE OF ANSWER, CR ASSUMES DEFAULT

ASKDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	JRST	ASKNUM		;GO ASK QUESTION AND CHECK ANSWER

;ROUTINE TO ASK QUESTION AND GET OCTAL LINE NUMBER OR CTY
;CALL:	ASKLIN	<QUESTION(DEFAULT,MIN-MAX)[...]>
;	RETURN HERE WITH N AS VALUE OR 'CTY', CR ASSUMES DEFAULT

ASKLIN:	MOVEI	R,10		;SET RADIX TO OCTAL
	TLO	F,(F.CTY)	;FLAG THAT CTY IS OK OCTAL NUMBER
	JRST	ASKNM1		;ASK QUESTION, ETC

;ROUTINE TO ASK QUESTION AND GET OCTAL ANSWER AND CHECK FOR LIMITS
;CALL:	SAME AS ASKDEC, EXCEPT ANSWER CONVERTED AS OCTAL

ASKOCT:	MOVEI	R,10		;SET RADIX TO OCTAL
ASKNUM:	TLZ	F,(F.CTY)	;FLAG THAT CTY IS NOT ACCEPTABLE NUMBER
ASKNM1:	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTON AGAIN IF SYNTAX ERROR OR OUT OF RANGE OR /HELP
ASKAGN:	MOVE	N,(P)		;REESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;ASK USER ON TTY
	SETOM	DFAULT		;SET DEFAULT TO NONE FOUND YET
				; USER CANNOT TYPE IN -1
	SETZM	MINLIM		;SET MIN LIMIT TO 0
	MOVSI	T1,'?  '	;SET MAX LIMIT TO BIG POS. NO.
				; WHICH WILL ALSO PRINT IF BELOW MIN
	MOVEM	T1,MAXLIM	;TO VERY BIG NUMBER
	HRRZ	B,-1(P)		;ADR OF QUESTION
	HRLI	B,440700	;FORM BYTE POINTER TO IT

;LOOP TO FIND FIRST PAREN
ASKN0:	ILDB	CH,B		;GET NEXT CHAR
	JUMPE	CH,ASKN2	;ERROR IF END OF STRING FOUND
	CAIE	CH,"("		;LEFT PAREN?
	JRST	ASKN0		;NO, KEEP LOOKING
;LOOP TO LOOK FOR DEFAULT, MIN AND MAX INSIDE PARENS
ASKN1:	PUSHJ	P,GETNUM	;GET NUMERIC FIELD
ASKN1B:	CAIE	CH,"*"		;SKIP IF * FOUND
	JRST	ASKN1C		;NO, PROCEED
	JUMPN	N,ASKN2		;JUMP IF SOMETHING BEFORE THE *
	MOVE	N,(P)		;PICK UP VALUE FOR SUBSTITUTION
	PUSHJ	P,SKBLNK	;SKIP TO NEXT TERMINATOR
	JRST	ASKN1B		;AND LOOP
ASKN1C:	CAIN	CH,"-"		;DASH TO SEPARATE MIN-MAX
	JRST	ASKN3		;YES, FOUND MIN
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIE	CH,"C"		;YES, AND IS BREAK A C?
	JRST	ASKN1A		;NO, GO CHECK OTHER BREAK CHARS
	JUMPN	N,ASKN2		;JUMP IF SOMETHING BEFORE THE *
	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	MOVEI	N,'CR '		;GET READY IF CR TO STORE CR AS DEFAULT
	CAME	WD,[SIXBIT /R/]	;IS IT R AFTER C?
				;YES,  STORE DEFAULT CR
	TLNN	F,(F.CTY)	;NOT CR, IS CTY A LEGAL ANSWER?
	JRST	ASKN1A		;NO, GO CHECK OTHER BREAKS
	CAME	WD,[SIXBIT /TY/] ;IS REST OF WORD "TY"?
	JRST	ASKN2		;NO, PRINT ERROR
	MOVEI	N,'CTY'		;STORE ARG AS TYPED
ASKN1A:	SKIPGE	DFAULT		;ALREADY STORED DEFAULT?
	MOVEM	N,DFAULT	;NO, STORE DEFAULT, IN CASE JUST TYPES CR
	CAIN	CH,")"		;IS THIS THE ONLY NUMBER
	JRST	ASKN4		;YES, GO GET USER ANSWER
	CAIN	CH,","		;IS BREAK A COMMA?
	JRST	ASKN1		;YES, GO GET NEXT NUMBER IN LIST
ASKN2:	EREXIT	<Above question must have(...,min-max) - Edit MONGEN>,

;HERE WHEN MIN FOUND
ASKN3:	MOVEM	N,MINLIM	;STORE MINIMUM LIMIT
	PUSHJ	P,GETNUM	;GET NEXT NUMBER
	CAIN	CH,"?"		;NO MAX SPECIFIED?
	JRST	ASKN3A		;YES, SET TO INFINITY
	CAIE	CH,"*"		;NO, IS MAX. SUBSTITUTABLE ARG?
	JRST	ASKN3B		;NO, GO CHECK FOR RIGHT PAREN
	SKIPA	N,(P)		;YES, USE VALUE WHICH WAS SUBSTITUTED
ASKN3A:	MOVSI	N,'?  '		;SET MAX TO PLUS INFINITY
	PUSHJ	P,SKBLNK	;SKIP TO NEXT NON-BLANK
ASKN3B:	CAIE	CH,")"		;BETTER BE RIGHT PAREN
	JRST	ASKN2		;NO, ERROR
	MOVEM	N,MAXLIM	;STORE MAX LIMIT

;HERE WHEN FIRST () ALL SCANNED FOR DEFAULT, MIN AND MAX
ASKN4:	PUSHJ	P,TTYIN		;GET USER ANSWER FROM TTY, OUTPUT TO FILE
				; AS COMMENT
	  JRST	ASKAGN		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKN5	;JRST CR TYPED?(GO USE DEFAULT IF YES)
	PUSHJ	P,GETNUM	;NO, GET NUMBER USER TYPED
	JUMPE	CH,ASKN5A	;END OF STRING?
	TLNN	F,(F.CTY)	;NO, IS CTY A POSSIBLE OCTAL NUMBER?
	RJRST	<TTYOUT	<? Type single number followed by carriage return@>
		 AOJA	LV,ASKAGN>  ;ASK AGAIN AT HIGHER LEVEL
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIE	CH,"C"		;YES, WAS BREAK C?
	JRST	ASKN4A		;NO, PRINT ERROR
	JUMPN	N,ASKN4A	;ERROR IF SOMETHING PRECEDED C
	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	CAMN	WD,[SIXBIT /TY/] ;IS WORD REST OF CTY?
	JRST	ASKN4B		;YES, ALLOW IT
ASKN4A:	RJRST	<TTYOCT	<? Type octal line number or CTY followed by carriage return@>
		 AOJA	LV,ASKAGN> ;ASK AGAIN AT HIGHER LEVEL
ASKN4B:	MOVSI	N,'CTY'		;RETURN LEFT JUSTFIED CTY AS OCTAL NO.
	JRST	ASKN6		;SKIP RANGE CHECK
;HERE IF JUST CR TYPED AS ANSWER, USE DEFAULT IF THERE IS ONE
ASKN5:	MOVS	N,DFAULT	;GET DEFAULT IF ONE SPECIFIED
	CAME	N,[SIXBIT /CR/]	;WAS DEFAULT CR?
	CAMN	N,[SIXBIT /CTY/] ;WAS DEFAULT CTY?
	JRST	ASKN6		;YES, BY PASS RANGE CHECK
	MOVSS	N		;RESTORE TO UNSWAPPED STATE
	RJUMPL	N,<TTYOUT <? No default allowed, type a number@>
		 AOJA	LV,ASKAGN> ;ASK AGAIN AT HIGHER LEVEL
;HERE TO CHECK RANGE OF ANSWER
ASKN5A:	CAMN	N,DFAULT	;SKIP IF NOT DEFAULT VALUE
	JRST	ASKN6		;IF DEFAULT NOT IN RANGE, MUST BE SPECIAL TERMINATOR
	CAML	N,MINLIM	;LESS THAN MIN?
	CAMLE	N,MAXLIM	;NO, EXCEED MAX?
	RJRST	<TTYOUT	<? Must be in range *>,MINLIM
	 	TTYOUT	<-*@>,MAXLIM
	 	AOJA	LV,ASKAGN>  ;ASK AGAIN AT NEXT LONGER MODE
ASKN6:	JRST	ASKXIT		;STANDARD ASK EXIT - RESTORE ORIGINAL
				; HELP LEVEL, POP QUESTION ADR, AND RETURN

;ROUTINE TO ASK QUESTION AND GET STRING FOR ANSWER
;CALL:	ASKSTR	<QUESTION*>,X

ASKSTR:	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION OVER AGAIN AFTER REQUEST FOR HELP
ASKST1:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADDRESS OF MESSAGE
	PUSHJ	P,TTROUT	;TYPE IT ON TTY
	PUSHJ	P,TTYIN		;WAIT FOR INPUT, OUTPUT TO FILE
				; AS COMMENT
	  JRST	ASKST1		;/HELP TYPED, REASK AT DESIRED HELP MODE
	JRST	ASKXIT		;COMMON EXIT FROM ASK ROUTINES
				; POP OLD N AND QUESTION ADR, RESTORE HELP LEVEL
;ROUTINE TO ASK FOR M-N<EOL> OR M<EOL> ON REPEATED LINES UNTIL BLANK LINE
; SYNTAX AND OUTPUT TO FILE
;CALL:	FILOUT	<DEFINE	MAC???>	;START MACRO DEFINITION IN FILE
;	ASKMN	<ASK MESSAGE@>
;	RETURN WHEN ALL ANSWERS HAVE BEEN CHECKED AND OUTPUT

ASKMN:	MOVEI	R,^D8		;ASSUME OCTAL RADIX FOR IO
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET, CRLF TO FILE
				; AS BEG OF MACRO DEFINITION
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION IN CASE OF ERROR OR /HELP
ASKM0:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO TTY

;LOOP TO GET NEXT LINE OF INPUT
ASKMLP:	PUSHJ	P,TTYIN		;GET TTY LINE
	  JRST	ASKM0		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKPXT	;NO, DID HE TYPE A BLANK LINE MEANING ALL DONE?
	TLZ	F,(F.INFO);
	PUSHJ	P,GETMN		;NO, SCAN FOR M OR M-N AND STOP ON NON-BREAK
	RJUMPN	CH,<TTYOCT <? Type octal M-N or M@>
		AOJA	LV,ASKM0>  ;RAISE LEVEL OF VERBOSCITY AND ASK AGAIN
	FILSTR	<L *@>;	;OUTPUT SAME STRING HE TYPED IN WITH MACRO
				; NAME PRECEDING IT SO COMMON CAN
				; REDEFINE AS IT PLEASES.
	JRST	ASKMLP		;AND GO GET NEXT LINE OF INPUT


;ROUTINE TO ASK FOR M-N,P<EOL>, GET REPEATED LINES OF INPUT
; UNTIL BLANK LINE, ANS OUTPUT TO FILE
;CALL:	FILOUT	<DEFINE	MAC???>	;START MACRO DEFINITON IN FILE
;	ASKMNP	<ASK MESSAGE@>
;	RETURN WHEN ALL ANSWERS HAVE BEEN CHECKED AND OUTPUT

ASKMNP:	MOVEI	R,^D8		;ASSUME OCTAL RADIX FOR IO
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET, CRLF TO FILE
				; AS BEG OF MACRO DEFINITION
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK FOR MULTI LINE INPUT AGAIN IN CASE OF ERROR
ASKP0:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO  TTY
;LOOP TO GET NEXT LINE OF INPUT
ASKPLP:	PUSHJ	P,TTYIN		;GET NEXT LINE FROM TTY
	  JRST	ASKP0		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKPXT	;NO, BLANK LINE MEANING END
	TLO	F,(F.INFO)
	PUSHJ	P,GETMN		;NO, GET M OR M-N
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	ASKPE		;NO, ERROR, PRINT MESAGE AND ASK AGAIN
	PUSHJ	P,GETOCT	;GET OCTAL P
	JUMPE	CH,ASKP1	;IS THIS END OF STRING?
ASKPE:	TTYOUT	<? Type octal M-N,P or M,P@>
	AOJA	LV,ASKP0	;RAISE LEVEL AND ASK AGAIN

ASKP1:	FILSTR	<L *@>;	;OUTPUT TO FILE ENTIRE ANSWER WITH MACRO
				; NAME PRECEDING IT WHICH COMMON WILL DEFINE
				; AS IT PLEASES.
	JRST	ASKPLP		;AND GO GET ANOTHER LINE OF INTPUT
;ROUTINE TO ASK FOR M-N OR ALL, GET REPEATED LINES OF INPUT
;UNTIL BLANK LINE, AND OUTPUT TO FILE
;CALL: - SEE ASKMN

ASKTMN:	MOVEI	R,^D8		;RADIX 8
	PUSHJ	P,FILLAB	;PUT OUT RIGHT BRACKET
	PUSHJ	P,ASKBG		;STD BEGINNING

ASKTM0:	MOVE	N,(P)		;RESTORE N
	HRRZ	T1,-1(P)	;ADDR OF MSG
	PUSHJ	P,TTROUT	;OUTPUT TO TTY

ASKTLP:	PUSHJ	P,TTYIN		;GET LINE OF INPUT
	  JRST	ASKTM0		;/HELP WAS TYPED
	JUMPE	CH,ASKPXT	;EXIT IF NULL LINE
	PUSHJ	P,GETTMN	;GET ANSWERS
	RJUMPN	CH,<TTYOCT <? Type octal M-N or M@>
		     AOJA LV,ASKTM0>	;GIVE HIM HELP
	FILSTR	<KN X,*@>
	JRST	ASKTLP		;ASK AGAIN

;ROUTINE TO GET M-N OR "ALL"

GETTMN:	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	CAIN	CH,"A"		;SEE IF START OF ALL
	JRST	GETTM1
	CAIE	CH,"-"		;CHECK DASH
	POPJ	P,		;NO - ERROR RETURN
	MOVEI	CH,","		;CONVERT TO MAKE MACRO HAPPY
	DPB	CH,B		;PUT IN STRING
	PJRST	GETOCT		;GET 2ND AND RETURN

GETTM1:	PUSHJ	P,GETWRD	;GET REST OF WORD
	MOVSI	N,'ALL'		;CORRECT ANSWER
	CAME	WD,[SIXBIT "LL"] ;REMAINDER CORRECT?
	MOVEI	CH,"A"		;NO - GIVER ERROR
	POPJ	P,		;RETURN
;ROUTINE TO SETUP ALL ASK ROUTINES
; OUTPUTS CRLF TO FILE, OUTPUT QUESTION AS COMMENT, PUT ADR OF QUESTION ON STACK
; PUT ARG FOR * SUBSTITUTION (N) ON STACK SO QUESTION CAN BE REASKED.
;CALL:	MOVEI	T1,ADR OF QUESTION
;	PUSHJ	P,ASKBG
;	RETURN HERE WITH T1 ON END OF LIST

ASKBG:	EXCH	T1,(P)		;SAVE ADR OF MESSAGE ON STACK
	PUSH	P,N		;SAVE ARG FOR * SUBSTITUTION IN CASE
				; OF ERROR AND QUESTION MUST BE REASKED
				; COMMON ASK EXIT(ASKXIT) WILL POP THESE OFF
	PUSH	P,T1		;SAVE RETURN ON END
	PUSHJ	P,FCRLF		;OUTPUT CRLF TO FILE
	HRRZ	T1,-2(P)	;ADR OF QUESTION
	PJRST	FILCOM		;OUTPUT AS A COMMENT, PUTTING ; IN FRONT
				; OF EVERY LINE IN QUESTION

;HERE TO EXIT ASKMN AND ASKMNP
ASKPXT:	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET,CRLF TO FILE

;HERE TO EXIT FROM ALL ASK ROUTINES
ASKXIT:	MOVE	LV,SAVLV	;RESTORE VERBOSCITY LEVEL BEFORE QUESTION ASKED
				; OR AS SET BY /HELP:XXX
	POP	P,T1		;THROW AWAY * SUBSTITUTION ARG( AC N)
				; N HAS ANSWER IN IT NOW
	POP	P,T1		;POP OFF T1
	JRST	FILOT2		;CLEAR LF FLAG SO FOLLOWING OUTPUT WONT
				; ACCIDENTALLY GET ; IN FRONT. THEN RETURN.
SUBTTL	GET ROUTINES - SCAN AND CHECK IN CORE STRINGS

;ROUTINE TO GET OCTAL LINE NUMBER OR "CTY"
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETLIN
;	ALWAYS RETURN, N=VALUE OR SIXBIT CTY
;	STOP IN FIRST NON-OCTAL CHAR OR NON-CTY
;	CALLER MUST CHECK FOR LEGAL BREAK CHARACTER

GETLIN:	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	JUMPN	N,CPOPJ		;RETURN IF GOT SOME VALUE
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIE	CH,"C"		;IS BREAK "C"?
	POPJ	P,		;NO, MAYBE 0 OR CR, LET CALLER CHECK
	PJRST	GETMN1		;SEE IF REST IS CTY

;ROUTINE TO SYNTAX CHECK M-N OR M FOLLOWED BY ANY BREAK
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETMN
;	ALWAYS RETURN HERE, BREAK IN CH

GETMN:	PUSHJ	P,GETOCT	;GET OCTAL LINE NUMBER
	CAIN	CH,"C"+40	;IS IT LOWER CASE C?
	TRC	CH,40		;YES, CONVERT IT
	CAIN	CH,"C"		;SKIP IF NOT START OF CTY
	JRST	GETMN1		;YES, SEE IF IS CTY
	CAIE	CH,"-"		;IS BREAK -?
	POPJ	P,		;NO, LET CALLER CHECK FURTHER
	MOVEI	CH,","		;YES, CHANGE TO , SO MACRO WILL ACCEPT
	DPB	CH,B		;IN OUTPUT FILE
	PJRST	GETOCT		;GET SECOND OCTAL DIGIT

GETMN1:	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	MOVSI	N,'CTY'		;ASSUME CTY
	CAMN	WD,[SIXBIT /TY/]  ;IS IT REST OF CTY?
	JRST	NULL		;INSERT A NULL
	MOVEI	CH,"C"		;NO, RETURN ORIGINAL BREAK FOR CALLER
				; TO GET ERROR WHEN CHECKS IT
	POPJ	P,		;RETURN, CALLER CHECK FOR BREAK
NULL:	TLNN	F,(F.INFO)	;ARE WE EXPECTING MORE INFO TO FOLLOW "CTY"?
	MOVEI	CH,0		;PUT A NULL IN THE BUFFER
	DPB	CH,B		; TO BE AN EOL
	POPJ	P,		;RETURN

;ROUTINE TO GET DECIMAL FROM STRING
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETDEC
;	ALWAYS RETURN HERE, BREAK IN CR, VALUE IN N
;CALLER MUST CHECK FOR PROPER BREAK

GETDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	PJRST	GETNUM		;GET NUMBER


;ROUTINE TO GET OCTAL NUMBER FROM STRING
;SAME CALL AS GETDEC

GETOCT:	MOVEI	R,10		;SET RADIX TO OCTAL
				; FALL INTO GETNUM

;ROUTINE TO GET NUMBER FROM STRING
;CALL:	MOVE	R,RADIX
;	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETNUM
;	ALWAYS RETURN HERE, BREAK IN CH, VALUE IN N
;CALLER MUST CHECK FOR PROPER BREAK, GETNUM STOPS ON FIRST NON-NUMERIC

GETNUM:	MOVEI	N,0		;SET VALUE TO 0
	PUSHJ	P,SKBLNK	;SKIP LEADING BLANKS(SPACES AND TABS)
GETN0:	JUMPE	CH,CPOPJ	;IS THIS END OF STRING
	CAIL	CH,"0"		;LESS THAN 0?
	CAIL	CH,"0"(R)	;LESS THAN RADIX
	PJRST	SKBLK1		;YES, RETURN - SKIP TO FIRST NON-BLANK
	IMUL	N,R		;MULTIPLY OLD NUMBER BY RADIX
	ADDI	N,-"0"(CH)	;ADD IN VALUE OF THIS CHAR
	ILDB	CH,B		;GET NEXT CHAR IN STRING
	JRST	GETN0		;GET ANOTHER CHAR
;ROUTINE TO GET A WORD FROM AN ASCIZ STRING.  FILTERS OUT TAB, SPACE
; STOPS ON ANY NON-ALPHA NUMERIC, EXCEPT DOT, CALLER MUST CHECK FOR LEGAL BREAK
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETWRD
;	RETURN WITH SIXBIT WD LEFT JUSTIFIED, BREAK IN CH

GETWRF:	PUSH	P,[PUSHJ P,FHLPRC] ;INSTRUCTION TO GET NEXT CHAR
	JRST	GETWR1		;READ ASCIZ STRING FOR SIXBIT

GETWRD:	PUSH	P,[ILDB CH,B]	;INSTRUCTION TO GET NEXT CHAR
GETWR1:	PUSHJ	P,GETSKB	;SKIP LEADING BLANKS(SPACES, TABS)
	MOVEI	WD,0		;SET WORD TO 0 FOR RETURN
	MOVE	T1,[XWD	440600,WD] ;SET SIX BIT BYTE POINTER TO WD

;LOOP TO ACCUMULATE AFTER LEADING SPACES AND TABS
GETWLP:	JUMPE	CH,GETWX1	;END OF STRING?
	TLNN	F,(F.PER)	;ARE SYMBOL CHARACTERS ALLOWED IN NAMES?
	JRST	GETWD1		;NO, (MUST BE SCANNING FILE NAMES)
	CAIN	CH,"."		;PERIOD(CAN BE PART OF SYMBOL)
	JRST	GETWD3		;YES, ACCEPT AS PART OF SYMBOL
	CAIE	CH,"%"		;CHECK FOR PERCENT SIGN
	CAIN	CH,"$"		;CHECK FOR DOLLAR SIGN
	JRST	GETWD3		;YES, ACCEPT AS PART OF SYMBOL
GETWD1:	CAIL	CH,"0"		;LESS THAN 0?
	CAILE	CH,"9"		;LESS THAN OR EQUAL TO 9?
	JRST	GETWD2		;YES, SEE IF LETTER?
	JRST	GETWD3		;NO, NUMBER, STORE

;HERE IF NOT NUMBER
GETWD2:	CAIL	CH,"A"+40	;LOWER CASE?
	TRC	CH,40		;YES, CONVERT TO UPPER CASE
	CAIL	CH,"A"		;LESS THAN A
	CAILE	CH,"Z"		;LESS THAN OR EQUAL TO Z?
	PJRST	GETWRX		;SKIP TRAILING BLANKS TO FIRST NON-BLANK
				; AND RETURN TO CALLER
;HERE IF A LETTER OR NUMBER - CONVERT TO SIXBIT AND STORE
GETWD3:	SUBI	CH,40		;CONVERT TO SIXBIT
	TLNE	T1,770000	;OVERFLOWED WD YET?
	IDPB	CH,T1		;NO, STORE NEXT SIXBIT CHAR
	XCT	(P)		;GET NEXT CHAR
	JRST	GETWLP		;AND CHECK IT

GETWRX:	PUSHJ	P,SKBLK1	;RETURN FIRST NON-BLANK AFTER TRAILING SPACES
GETWX1:	POP	P,(P)
	POPJ	P,
GETSKB:	XCT	-1(P)		;GET NEXT CHAR
GETSK1:	CAIE	CH," "		;SPACE?
	CAIN	CH,"	"	;TAB?
	JRST	GETSKB		;YES, GET NEXT CHAR
	POPJ	P,		;NO, FOUND NON-BLANK
;ROUTINE TO GET TTY LINE, AND SCAN FOR DEV:PI
; WHERE DEV IS 3 CHAR OR LESS AND PI IS # FOR 0-7
;CALL:	PUSHJ	P,GETDPI
;	  ERROR RETURN, /HELP , DEV TOO LONG, OR PI TOO BIG
;	OK RETURN, BREAK IN CH, WD=0 IF JUST CR TYPED

GETDPI:	PUSHJ	P,TTYIN		;GET NEXT LINE
	  POPJ	P,		;/HELP TYPED, REASK IN DESIRED HELP MODE
	MOVEI	WD,0		;SET JUST CR TYPED INDICATION
	JUMPE	CH,CPOPJ1	;JUST A BLANK LINE?
	PUSHJ	P,GETWRD	;NO, GET FIRST WORD
	JUMPE	WD,ASKDPE	;ARE THERE ANY CHAR IN DEVICE NAME?
	CAIE	CH,","		;IS BREAK CHAR COMMA?
	POPJ	P,		;NO, ERROR
	TRNE	WD,777777	;IS DEVICE 3 CHAR OR LESS?
ASKDPE:	RJRST	<TTYOUT	<? Device-mnemonic must be 3 char or less@>
		 POPJ	P,>	;GO TRY AGAIN
	PUSHJ	P,GETDEC	;GET PI NO.
	CAILE	N,SM.PI		;LEGAL PI?
	RJRST	<MOVEI N,SM.PI	;GET MAXIMUM LEGAL PI
		 TTYOUT	<? PI-channel must be * or less@>
		 POPJ	P,>	;GO TRY AGAIN
	JRST	CPOPJ1		;YES, GIVE LEGAL RETURN


;ROUTINE TO SKIP LEADING BLANKS(SPACES AND TABS)
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,SKBLNK	OR SKBLK1 IF FIRST CHAR ALREADY IN CH
;	FIRST NON-BLANK RETURNED IN CH

SKBLNK:	ILDB	CH,B		;GET NEXT CHAR
SKBLK1:	CAIE	CH," "		;SPACE?
	CAIN	CH,"	"	;TAB?
	JRST	SKBLNK		;YES, GET NEXT CHAR
	POPJ	P,		;NO, RETURN WITH FIRST NON-BLANK IN CH
SUBTTL	FGEN AUXILIARY HELP FILE ROUTINES

;ROUTINE TO OUTPUT FROM THE AUXILIARY FILE TO TTY

FHLPTT:	PUSH	P,[PUSHJ P,FHLPRC] ;INSTRUCTION TO GET NEXT CHAR TO OUTPUT
	MOVSI	N,'*  '		;EASY WAY TO MAKE SURE * COMES OUT RIGHT
	JRST	TTYOLP		;TYPE OUT STRING

;ROUTINE TO OUTPUT FROM THE AUXILIARY FILE TO THE OUTPUT FILE
;CALL:	PUSHJ	P,FHLPFC TO OUTPUT AS A COMMENT
;	PUSHJ	P,FHLPFL TO OUTPUT AS TEXT

FHLPFC:	TLO	F,(F.COM)	;NOTE OUTPUT AS A COMMENT
FHLPFL:	PUSH	P,[PUSHJ P,FHLPRC] ;INSTRUCTION TO GET NEXT CHAR TO OUTPUT
	MOVSI	N,'*  '		;EASY WAY TO MAKE SURE * COMES OUT RIGHT
	JRST	FILOLP		;OUTPUT TO FILE

;ROUTINE TO POSITION THE AUXILIARY FILE
;CALL:	MOVE	WD,SIXBIT TEXT TO FIND
;	PUSHJ	P,FHLPOS
;	ERROR RETURN - CANT FIND IT
;	OK RETURN - FILE POSITIONED AFTER TAB
;
;	NOTE LOOKS FOR TERMINATOR FIRST, TO BE FOLLOWED IMMEDIATELY BY TEXT IN WD

FHLPOA:	TLZA	F,(F.FHLC)	;NOTE DONT WANT TAB AFTER TEXT
FHLPOS:	TLO	F,(F.FHLC)	;NOTE LOOKING FOR A TAB AFTER TEXT
	TLZ	F,(F.HRRD)	;CLEAR REREADING FLAG
FHLPS0:	PUSHJ	P,FHLPRD	;READ NEXT CHAR FROM AUX FILE
FHLPS3:	JUMPL	CH,FHLPEF	;JUMP IF END OF AUX FILE
	JUMPN	CH,FHLPS0	;LOOK FOR TERMINATOR
FHLPS1:	MOVE	T1,[POINT 6,WD]	;BYTE PTR FOR DESIRED STRING
FHLPS2:	TLNN	T1,770000	;SKIP IF NEED MORE CHARS TO MATCH
	JRST	FHLPFN		;FOUND WHAT WAS DESIRED
	ILDB	N,T1		;N=NEXT CHAR NEEDED (IN SIXBIT)
	JUMPE	N,FHLPFN	;JUMP IF THAT'S ALL THATS NEEDED
	PUSHJ	P,FHLPRD	;GET NEXT CHAR FROM AUX FILE
	JUMPL	CH,FHLPEF	;JUMP IF END OF FILE
	JUMPE	CH,FHLPS1	;IF TERMINATOR, START LOOKING AGAIN
	CAIL	CH,140		;SKIP IF NOT LOWER CASE
	SUBI	CH,40		;MAKE UPPER CASE FOR COMPARISON
	CAIE	N,' '-" "(CH)	;SKIP IF THIS CHAR MATCHES
	JRST	FHLPS0		;NO, MOVE TO NEXT TERMINATOR
	JRST	FHLPS2		;YES, KEEP ON
;HERE IF FOUND END OF AUX FILE
FHLPEF:	TLNE	F,(F.FHLC)	;SKIP IF NOT LOOKING FOR TAB AFTER TEXT
	TLOE	F,(F.HRRD)	;SKIP IF NOT ALREADY REREADING THE FILE
	POPJ	P,		;CANT FIND DESIRED STRING
	TLZ	F,(F.HOPN)	;CLEAR OPEN FLAG TO RESTART AT BEGINNING OF FILE
	JRST	FHLPS0		;NO, MAY HAVE STARTED PAST THE PLACE
;HERE WHEN FILE POSITIONED AS REQUESTED
FHLPFN:	TLNN	F,(F.FHLC)	;SKIP IF LOOKING FOR TAB AFTER STRING
	JRST	CPOPJ1		;NO, ALL SET
FHLPF1:	PUSHJ	P,FHLPRD	;SKIP TO TAB
	JUMPLE	CH,FHLPS3	;JUMP IF TERMINATOR FOUND
	CAIE	CH,"	"	;SKIP IF FOUND TAB
	JRST	FHLPF1		;KEEP ON
	JRST	CPOPJ1		;GIVE GOOD RETURN

;THIS ROUTINE READS A CHAR FROM THE AUXILIARY HELP FILE FOR MESSAGES
FHLPRC:	PUSHJ	P,FHLPRD	;GET NEXT CHAR
	JUMPGE	CH,CPOPJ	;OK IF REAL CHAR
	SETZ	CH,		;TURN EOF INTO END OF STRING
	POPJ	P,
;ROUTINE TO READ NEXT CHAR FROM FGEN AUXILIARY HELP FILE

FHLPRD:	TLNE	F,(F.HOPN)	;SKIP IF HELP FILE IS NOT YET OPEN
	JRST	FHLPR1		;ALREADY OPEN, GO AHEAD
	INIT	FHLPCH,0
FGDEV:	SIXBIT	.SYS.
	XWD	0,FHIBUF
	  JRST	FHLPE1		;CANT INIT SYS?
	MOVE	CH,FGPPN	;PPN FOR HELP FILE
	MOVEM	CH,FHNAME+3	;STORE FOR LOOKUP
	LOOKUP	FHLPCH,FHNAME	;LOOKUP FILE
	  JRST	FHLPE1		;CANT FIND FILE
	TLO	F,(F.HOPN!F.HRRD) ;NOTE OPEN AND ON SECOND PASS
	PUSH	P,.JBFF##	;SAVE JOBFF
	MOVEI	CH,FHLPBF	;ADDR OF FHELP FILE BUFFERS
	MOVEM	CH,.JBFF	;SET UP TO ALLOCATE BUFFERS
	INBUF	FHLPCH,NFHLPB	;ALLOCATE INPUT BUFFERS
	POP	P,.JBFF		;RESTORE JOBFF
FHLPR1:	SETZ	CH,		;CLEAR CH IN CASE ERROR IN IN SUBROUTINE
	SOSG	FHIBUF+2
	PUSHJ	P,[IN FHLPCH,
		   POPJ P,
		   JRST	FHLPER]
	JUMPL	CH,CPOPJ	;GIVE UP IF ERROR READING
	ILDB	CH,FHIBUF+1	;GET NEXT CHAR
	JUMPE	CH,FHLPR1	;IGNORE NULLS
	CAIN	CH,C.RUB	;AND RUBOUTS
	JRST	FHLPR1
	CAIL	CH,175		;DO THE ALTMODE THING
	MOVEI	CH,C.ESC
	CAIN	CH,C.TMFH	;SKIP IF NOT OUR TERMINATOR
	SETZ	CH,		;RETURN 0 FOR TERMINATOR FOR CONVENIENCE
	POPJ	P,
FHLPER:	TLZ	F,(F.HOPN)	;CLEAR OPEN FLAG
	RELEASE	FHLPCH,
FHLPE1:	SETO	CH,
	POPJ	P,
SUBTTL	TTY INPUT ROUTINES

;ROUTINE TO ACCEPT 1 LINE FROM TTY, MOVE IT TO ASCSTR
;REMOVE EOLS, AND COMMENTS, AND ADD A NULL TO MAKE IT ASCIZ
; LOOK FOR /H AND HANDLE IT
;OUTPUT LINE WITH PRECEDING ; TO FILE
;CALL:	PUSHJ	P,TTYIN
;	  NON SKIP RETURN IF USER TYPES /HELP, CALLER MUST REASK QUESTION
;	    LEVEL SET AS USER WISHES IN LV FOR THIS QUESTION,
;	    AND IN SAVLV FOR FUTURE
;	SKIP RETURN WITH B SETUP AS BYTE POINTER TO BEG OF STRING
;	CH = 0 IF JUST A BLANK LINE TYPED
;	N = NUMBER OF CHARACTERS NOT COUNTING EOLS OR NULLS
;	B = BYTE POINTER TO STRING JUST READ IN


TTYIN:	TLO	F,(F.COM)	;FLAG OUTPUT TO FILE AS COMMENTS SO ALL
				; CALLS TO FILOUT WILL PUT PRECEDING ;
	PUSHJ	P,TTYGET	;GET NEXT CHAR, OUTPUT TO FILE, SKIP COMMENTS, EOL=0
	MOVEI	N,0		;SETUP LENGTH OF STRING TO 0
	MOVE	B,[XWD 440700,ASCSTR] ;BYTE POINTER

;LOOP TO COPY CHARS FROM TTY TO CORE BUFFER(ASCSTR)
TTYINB:	IDPB	CH,B		;STORE AWAY
	JUMPE	CH,TTYINC	;IF EOL CHAR, RETURN
	PUSHJ	P,TTYGET	;GET NEXT CHAR
	CAIGE	N,MP.LMX	;LESS THAN MAX LINE LENGTH?
				; ASCSTR ALWAYS HAS ROOM FOR NULL
	AOJA	N,TTYINB	;YES, OK TO STORE NEXT CHAR
	TLZ	F,(F.COM!F.BANG) ;CLEAR FLAG FOR FILE COMMENTS
	TTYOUT	<? Line too long@>
	AOJA	LV,FILOT2	;INCREASE LEVEL BY 1 FOR THIS QUESTION
				; AND PRETEND /HELP TYPED BY GIVING NO-SKIP
				; RETURN SO CALLER WILL REASK QUESTION

;HERE WHEN STRING ALL STORED IN CORE BUFFFER
TTYINC:	TLZ	F,(F.COM!F.BANG) ;CLEAR FLAG FOR FILE COMMENTS
	MOVE	B,[XWD 440700,ASCSTR] ;BYTE POINTER TO CORE BUFFER
	PUSHJ	P,SKBLNK	;SKIP BLANKS(SPACE, TAB)
	CAIN	CH,"/"		;IS FIRST NON-BLANK A SLASH?
	JRST	TTYINH		;YES, GO DO /HELP
	MOVE	B,[XWD 440700,ASCSTR] ;SETUP BYTE POINTER TO
				; BEG OF CORE BUFFER FOR CALLER
	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	JRST	CPOPJ1		;GIVE NON-HELP RETURN
;HERE ON LEADING / FROM TTYIN ROUTINE - SEE IF /HELP
; REST OF INPUT LINE ALEADY COPIED TO FILE AND CORE BUFFER(ASCSTR)
; OK TO DESTROY ASKTAB+0,... SINCE GOING TO GIVE NON-SKIP RETURN
TTYINH:	PUSH	P,N		;SAVE CCALLERS N IN CASE * SUBSTITUTION
				; WHEN QUESTION REASKED
	MOVEI	T1,[ASCIZ /(HELP)/] ;SETUP ONLY CHOICE AS IF PROMPT
	PUSHJ	P,SETASK	;IN CHOICES TABLE(ASKTAB)
	PUSHJ	P,FNDAS1	;SCAN CHARS AFTER / TO SEE IF HELP
				; OR ABBREV(ALLOW ANY BREAK)
	AOJA	LV,TTYIH1	;NO, GIVE HIM HELP WITH HELP
				; AT NEXT LONGER HELP LEVEL
	PJUMPE	CH,RAISE1	;IS BREAK EOL?(IF YES, JUST INCREASE
				; LEVEL OF VERBOSCITY BY 1 FOR THIS QUESTION
				; BY ADDING TO LV BUT NOT TO SAVLV
	CAIE	CH,":"		;IS BREAK COLON?
	AOJA	LV,TTYIH1	;NO, ASK HELP QUESTION
				; AT NEXT LONGER MODE
	MOVEI	T1,[ASCIZ /(,SHORT,PROMPT,LONG)/] ;SETUP UP CHOICES TO /HELP:
				; N=0 MEANS JUST CR TYPED
	PUSHJ	P,SETASK	;IN ASKTAB+0,1,...
	PUSHJ	P,FNDASK	;FIND THE ONE HE TYPED
	  AOJA	LV,TTYIH1	;NOT FOUND, INCREASE HELP LEVEL
	JUMPE	N,RAISE1	;DID HE TYPE JUST CR?
				; IF YES, JUST INCREASE LEVEL FOR THIS QUESTION
	SUBI	N,2		;NO, FORM -1,0,1 FOR SHORT,PROMPT,LONG
	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	JRST	HELP0		;GO STORE NEW PERMANENT HELP LEVEL

;HERE TO RAISE LEVEL 1 FOR THIS QUESTION ONLY
RAISE1:	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	AOJA	LV,HELP1	;INCREMENT LEVEL BY ONE, BUT DO NOT
				; REMEMBER IN MEMORY(SAVLV)
				; AND RETURN
TTYIH1:	TLZA	F,(F.COM)	;CLEAR COMMENT FLAG AND GO TO TTYHP1

;ROUTINE TO TYPE HELP QUESTION
; CALLED AT BEGINNING ONCE ONLY AND WHENEVER /HELP:XXX MISTYPED
;CALL:	PUSHJ	P,TTYHLP

TTYHLP:	PUSH	P,N		;SAVE CALLER N INCASE * SUBSTITUTION
				; WHEN QUESTION REASKED
TTYHP1:	MOVEI	N,MP.MVN	;MONITOR VERSION NUMBER FOR THIS MONGEN
				; TELL USER SO HE GETS PROPER MONGEN
	ASKLST	<MONGEN for * monitors
/HELP(PROMPT,SHORT,LONG)[
All # are decimal unless stated otherwise
Unique abbrivation allowed everywhere to all questions
/HELP reasks a question in next longer mode
/HELP:xxx sets mode permanently.  Modes are:
SHORT is short
PROMPT has choices in ()
LONG has choices in () and explanation in []]>
	CAIN	N,1		;ANSWER 1(SHORT)
	SETOM	N		;YES, SET LEVEL TO SHORT
	CAIN	N,2		;ANSWER 2(LONG)?
	MOVEI	N,1		;YES, SET LEVEL TO LONG

;HERE TO STORE NEW PERMANENT HELP LEVEL
HELP0:	MOVEM	N,SAVLV		;SET PERMANENT LEVEL OF HELP
	MOVE	LV,N		;SET CURRENT LEVEL TO THE SAME
HELP1:	POP	P,N		;RESTORE ORIGINAL N(IN CASE THIS
				; IS HELP IN MIDDLE OF A QUESTION)
	POPJ	P,		;GIVE NON-SKIP RETURN SO QUESTION
				; WILL BE REASKED

;ROUTINE TO GET ONE CHAR FROM TTY, CHECK FOR EOLS, PUT CHAR IN  FILE
; AND SKIP OVER COMMENTS. ALSO CHECK FOR /HELP

TTYGET:	PUSHJ	P,TTYGT1	;GET NEXT CHAR FROM TTY AND PUT IN FILE
	  POPJ	P,		;IT WAS AN EOL, RETURN, F.COM CLEARED
	TLNN	F,(F.BANG)	;"!" LEGAL IN THIS INPUT LINE?
	CAIE	CH,"!"		;NO, DO WE HAVE ONE TO START A COMMENT?
	CAIN	CH,";"		;CHECK FOR SEMI-COLON ALSO
	JRST	TTYGT0		;READ COMMENT
	POPJ	P,		;NO, RETURN

;LOOP TO THROW AWAY COMMENTS USER TYPED IN AFTER ANSWER
TTYGT0:	PUSHJ	P,TTYGT1	;YES, GET NEXT CHAR
	  POPJ	P,		;IT WAS AN EOL, RETURN WITH F.COM CLEARED
	JRST	TTYGT0		;NOT AN EOL, THROW IT AWAY AND GET NEXT CHAR

;ROUTINE TO GET ONE CHAR FROM TTY, CHECK FOR EOL, PUT CHAR IN FILE
;CALL:	PUSHJ	P,TTYGT1
;	  EOL RETURN CH=0, F.COM CLEARED(MAKE FILE OUTPUT NO LONGER BE COMMENTS)
;	NOT AN EOL RETURN, CH IS CHAR

TTYGT1:	SOSG	TIBUF+2		;DECREMENT INPUT TTY BUFFER COUNT
	RJRST	<IN	TTYCHN,	;GET NEXT BUFFER FROM MONITOR
		 JRST	TTYGT2	;NO ERRORS
		 STATO	TTYCHN,IO.EOF ;END OF FILE ON TTY?
		 JRST	TTYGT2	;NO, IGNORE ERROR
		 JRST	TTYZ>	;YES, SET CONTROL Z FLAG
TTYGT2:	ILDB	CH,TIBUF+1	;GET NEXT CHAR FROM BUFFER
	JUMPE	CH,TTYGT1	;IS IT NULL?
	CAIE	CH,C.RUB	;IGNORE RUBOUTS
	CAIN	CH,C.CR		;IS IT CR?
	JRST	TTYGT1		;YES, SKIP
	CAIL	CH,C.LF		;LESS THAN LINE FEED?
	CAILE	CH,C.CR		;NO, LESS THAN CARRIAGE RETURN?
	SKIPA			;NO, NOT AN EOL
	JRST	TTYEOL		;YES, CONSIDER AS EOL
	CAIE	CH,C.ESC	;ESCAPE?
	CAIL	CH,C.ALT1	;OLD ALTMODE?
	JRST	TTYEOL		;YES, TREAT AS EOL
	CAIE	CH,C.CONC	;CONTROL C?
	CAIN	CH,C.CONZ	;CONTROL Z?
	JRST	TTYZ		;YES, SET FLAG(OLDER MONITORS STORE ^Z IN BUFFER)
	PUSHJ	P,FILPUT	;STORE CHAR IN FILE
	JRST	CPOPJ1		;AND SKIP RETURN

;HERE WHEN CONTROL Z SEEN OF END OF FILE SET ON TTY
TTYZ:	CLOSE	TTYCHN,		;TURN OFF EOF FOR TTY
				; CLEAR EOF SO CAN DO MORE INPUTS
	TLO	F,(F.CONZ)	;FLAG CONTROL Z SEEN
TTYEOL:	PUSHJ	P,FCRLF		;OUTPUT CRLF TO FILE
	MOVEI	CH,0		;RETURN 0 AS EOL CHAR
	POPJ	P,		;GIVE EOL RETURN
SUBTTL	OUTPUT ROUTINES - TTY AND FILE

;ROUTINE TO TYPE INTERNAL MONGEN ERROR ON TTY AND FILE, THEN EXIT TO MONITOR
;USE TTCALL IN CASE TTY COULD NOT BE INITED
;CALL:	EREXIT	<MESSAGE>,

EREXIT:	PUSH	P,T1		;SAVE ADR OF MESSAGE
	OUTSTR	[ASCIZ /
? Internal MONGEN error - /]
	OUTSTR	(T1)		;THE CALLERS MESSAGE
	FILOUT	<@? Internal MONGEN error - >
	POP	P,T1		;RESTORE MESSAGE ADR
	PUSHJ	P,FILOUT	;OUTPUT TO FILE
	EXIT			;EXIT TO MONITOR


;ROUTINE TO OUTPUT TO FILE IN DECIMAL AND SUBSTITUTE FOR *
;CALL:	MOVEI	T1,ADR OF MESSAGE
;	PUSHJ	P,FILDEC
;	ALWAYS RETURN HERE, N PRESERVED

FILDC2:	TLO	F,(F.2DEC)	;ASK FOR AT LEAST TWO CHARS OUTPUT
FILDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	PJRST	FILOT1		;DO OUTPUT AND SUBSTITUTION

;ROUTINE TO OUTPUT TO FILE AND SUBSTITUTE FOR *
; VALUE OR SIXBIT IN N
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING TO OUTPUT
;	MOVE	N,NUMBER OR LEFT JUSTIFIED SIXBIT
;	PUSHJ	P,FILOUT
;	ALWAYS	RETURN HERE, N PRESERVED

FILCOM:	TLOA	F,(F.COM)	;SET FLAG TO PRECEDE ALL LINE WITH ;
				; AS A COMMENT IN FILE
FILOUT:	MOVEI	R,10		;SET OUTPUT RADIX TO OCTAL FOR MACRO
FILOT1:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,[ILDB CH,T1]	;INSTRUCTION TO GET NEXT CHAR
FILOLP:	XCT	(P)		;GET NEXT CHAR IN OUTPUT MESSAGE
	PJUMPE	CH,FILT2A	;RETURN IF END OF STRING
	CAIN	CH,"*"		;NOT EOS, IS IT ASTERISK?
	PUSHJ	P,EITAST	;YES, SUBSTITUTE N FOR IT
	  PUSHJ	P,FILPUT	;ARG TO EITAST OR OUTPUT CHAR
	JRST	FILOLP		;LOOP AND GET NEXT CHAR


;ROUTINE TO REPLACE A "DOT" IN A SYMBOL WITH THE VALUE OF CPUN

FILCPU:	MOVEI	R,10		;OUTPUT RADIX
FILCP0:	HRLI	T1,440700	;FORM A BYTE POINTER
	PUSH	P,T1		;SAVE IT
FILCP1:	ILDB	CH,(P)		;GET NEXT CHARACTER IN OUTPUT
	PJUMPE	CH,FILT2A	;JUMP IF LAST
	PUSH	P,N		;SAVE ARGUMENT
	CAIN	CH,"*"		;SUBSTITUTE N?
	JRST	FILCP2		;YES
	MOVE	N,CPUN		;CURRENT CPU NUMBER
	CAIN	CH,"."		;A DOT?
FILCP2:	PUSHJ	P,EITAST	;YES, CONVERT CPU NUMBER
	  PUSHJ	P,FILPUT	;OUTPUT CHARACTER OR CPU NUMBER
	POP	P,N		;RESTORE ARGUMENT
	JRST	FILCP1		;LOOP OVER ENTIRE STRING

;HERE ON END OF STRING
FILT2A:	POP	P,(P)		;REMOVE INSTRUCTION FROM STACK
FILOT2:	TLZ	F,(F.COM!F.2DEC) ;NOW CLEAR FLAG SO NEXT CALLER CAN USE
				; FILOUT OR FILCOM WITHOUT HAVING TO SET OR CLEAR
				; TO INDICATE COMMENT OR NOT
	POPJ	P,		;RETURN


;ROUTINE TO OUTPUT TO BOTH FILE AND TTY
; SUBSTITUTE FOR * VALUE OR SIXBIT IN N, PRECEDE EACH
; LINE IN FILE WITH ; SO A COMMENT
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,BTHOUT	FOR DECIMAL OR BTHOCT FOR OCTAL
;	ALWAYS RETURN HERE, N PRESERVED

BTHOCT:	SKIPA	R,[EXP 10]	;OCTAL RADIX
BTHOUT:	MOVEI	R,12		;OCTAL OUTPUT FOR FILE
	PUSH	P,T1		;SAVE ADR OF ASCIZ MESSAGE
	PUSHJ	P,FILCOM	;OUTPUT TO FILE AS A COMMENT
	POP	P,T1		;RESTORE ADR OF MESSAGE AND
	JRST	TTROUT		;REPEAT OUTPUT, BUT TO TTY: THIS TIME


;ROUTINE TO OUTPUT TO TTY IN DECIMAL
; SUBSTITUTE FOR * VALUE OR SIXBIT IN N
; OUTPUT INSIDE PARENS AND BRACKETS DEPENDING ON HELP LEVEL
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,TTYOUT
;	ALWAYS RETURN HERE, N PRESERVED

TTYOCT:	MOVEI	R,10		;OCTAL RADIX(RARE) FOR TTY
	JRST	TTROUT		;GO DO REST OF TTYOUT

TTYOUT:	MOVEI	R,12		;SET RADIX TO DECIMAL FOR PEOPLE
TTROUT:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,[ILDB CH,T1]	;INSTRUCTION TO GET NEXT CHAR
TTYOLP:	XCT	(P)		;GET NEXT CHAR INTO CH
	PJUMPE	CH,TTYNOW	;IF EOL, FORCE OUT TTY NOW
	CAIN	CH,"["		;LEFT BRACKET?
	TLO	F,(F.LBRK)	;YES, FLAG INSIDE EXPLANATION
	TLNE	F,(F.LBRK)	;ARE WE INSIDE AN EXPLANATION?
	JUMPLE	LV,TTYSBK	;YES, IS HELP LEVEL SHOR OR PROMPT?
	CAIN	CH,"("		;NO, LONG MODE, IS THIS CHAR LEFT PAREN?
	TLO	F,(F.LPAR)	;YES, FLAG INSIDE PROMPTING
	TLNE	F,(F.LPAR)	;ARE WE INSIDE PROMPTING?
	JUMPL	LV,TTYSPR	;YES, IS HELP LEVEL SHORT?

;HERE IF HELP LEVEL PERMITS THESE CHARS TO BE OUTPUT
	CAIN	CH,"*"		;NO, IS IT ASTRISCK?
	PUSHJ	P,EITAST	;YES, SUBSTITUTE N FOR IT
	  PUSHJ	P,TTYPUT	;ARG TO EITAST OR OUTPUT CHAR ROUTINE

;HERE TO SUPPRESS PROMPTING INSIDE PARENS(SHORT MODE ONLY)
TTYSPR:	CAIN	CH,")"		;WAS CHAR JUST OUTPUT RIGHT PAREN?
	TLZ	F,(F.LPAR)	;YES, CLEAR INSIDE PROMPTING FLAG

;HERE TO SUPPRESS EXPLANATION INSIDE BRACKETS(SHORT AND PROMPT MODES)
TTYSBK:	CAIN	CH,"]"		;WAS CHAR JUST OUTPUT RIGHT BRACKET?
	TLZ	F,(F.LBRK)	;YES, CLEAR INSIDE EXPLANATION
	JRST	TTYOLP		;LOOP AND GET NEXT CHAR
;ROUTINE TO SUBSTITUTE FOR * IN OUTPUT TO FIL OR TTY USING N
;CALL:	MOVE	N,[SIXBIT / /] OR DECIMAL NUMBER
;	MOVEI	R,RADIX
;	MOVE	T1,BYTE POINTER
;	CAIN	CH,"*"
;	PUSHJ	P,EITAST
;	  PUSHJ	P,FILPUT OR TTYPUT
;	RETURN	HERE WITH T1 AND N PRESERVED

EITAST:	PUSH	P,T1		;SAVE BYTE POINTER TO STRING
	TLNN	N,770000	;DOES N HAVE A SIXBIT ARG?
	JRST	EITAS2		;NO, OUTPUT AS A NUMBER

;HERE TO OUTPUT N AS SIXBIT FOR *
	MOVE	WD,[XWD 440600,N] ;SETUP BYTE POINTER TO SIXBIT ARG
EITAS1:	ILDB	CH,WD		;GET NEXT SIXBIT CHAR
	JUMPE	CH,TPOPJ1	;IS IT END OF SIXBIT?
	ADDI	CH,40		;CONVERT TO ASCII
	XCT	@-1(P)		;OUTPUT CHAR TO TTY OR FIL ACCORDING
				; TO ARG IN CALLING SEQUENCE
	TLNE	WD,770000	;BYTE POINTER EXHAUSTED WD?
	JRST	EITAS1		;NO, KEEP GETTING SIXBIT CHARS
	JRST	TPOPJ1		;YES, RETURN

;HERE TO CONVERT N AND OUTPUT ACCORDING TO CURRENT RADIX
EITAS2:	MOVE	WD,@-1(P)	;GET ADR OF CHAR PUT ROUTINE FOR TTY OR FILE
				; (TTYPUT OR FILPUT)
	MOVE	T1,N		;MOVE NO. TO DOUBLE AC
	CAIG	N,^D9		;SKIP IF GREATER THAN TWO CHARS
	TLNN	F,(F.2DEC)	;ONE CHAR, SKIP IF WANT AT LEAST TWO
	JRST	EITAS3		;GO AHEAD AS PLANNED
	MOVEI	CH,"0"		;OUTPUT LEADING ZERO
	PUSHJ	P,(WD)		;OUTPUT IT
EITAS3:	PUSHJ	P,EITSUB	;CALL RECURSIVE OUTPUT ROUTINE
TPOPJ1:	POP	P,T1		;RSTORE BYTE POINTER
CPOPJ1:	AOS	(P)		;SET FOR SKIP RETURN
CPOPJ:	POPJ	P,		;RETURN

EITSUB:	IDIVI	T1,(R)		;DIVIDE REMAINING NUMBER BY RADIX
	HRLM	T2,(P)		;SAVE REMAINDER ON STACK
	JUMPE	T1,EITSB1	;REMAINING NUMBER ALL GONE?
	PUSHJ	P,EITSUB	;NO, DIVIDE REMAINING NUMBER BY RADIX AGAIN
EITSB1:	HLRZ	CH,(P)		;GET MOST RECENT CHAR CONVERTED
	ADDI	CH,"0"		;CONVERT TO ASCII
	PJRST	(WD)		;OUTPUT CHAR TO TTY OR FIL AS SPECIFIED
				; IN CALLING SEQUENCE
				; RETURN TO EITSB1 UNTIL ALL CHAR OUTPUT
;ROUTINE TO OUTPUT JUST A STRING AND SUBSTITUTE ASCSTR FOR *
;CALL:	FILSTR	<MESSAGE*MESSAGE@>

FILSTR:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
STRLOP:	ILDB	CH,T1		;GET NEXT CHAR
	JUMPE	CH,CPOPJ	;END OF STRING?
	CAIN	CH,"*"		;IS THIS ASTERISK?
	JRST	STRSUB		;YES, SUBSTITUTE STRING IN ASCSTR
	PUSHJ	P,FILPUT	;NO, STORE THIS CHAR IN FILE OUTPUT BUFFER
	JRST	STRLOP		;GO GET NEXT CHAR

STRSUB:	PUSH	P,T1		;SAVE BYTE POINTER SO FAR
	MOVEI	T1,ASCSTR	;SETUP TO OUTPUT FROM WHERE USER TYPED IN
	PUSHJ	P,FILOUT	;OUTPUT STRING TO FILE
	POP	P,T1		;RESTORE BYTE POINTER TO WHERE LEFT OFF
	JRST	STRLOP		;GO GET NEXT CHAR(SKIP OVER * ITSELF)

;ROUTINE TO OUTPUT LEFT ANGLE BRACKET CRLF TO FILE
;CALL:	PUSHJ	P,FILLAB

FILLAB:	MOVEI	CH,"<"		;LEFT ANGLE BRACKET
	PUSHJ	P,FILPUT	;PUT IN OUTPUT FILE
	PJRST	FCRLF		;OUTPUT CRLF TO FILE

;ROUTINE TO OUTPUT RIGHT ANGLE BRACKET CRLF TO FILE
;CALL:	PUSHJ	P,FILRAB

FILRAB:	MOVEI	CH,">"		;RIGHT ANGLE BRACKET
	PUSHJ	P,FILPUT	;PUT IN OUTPUT FILE
				; FALL INTO FCRLF

;ROUTINE TO OUTPUT CRLF TO FILE
;CALL:	PUSHJ	P,FCRLF

FCRLF:	MOVEI	CH,C.CR		;OUTPUT CR
	PUSHJ	P,FILPUT	;TO FILE
	MOVEI	CH,C.LF		;THEN LINE FEED
				; FALL INTO FILPUT
;ROUTINE TO OUTPUT 1 CHAR TO OUTPUT FILE, IF @ SUBSTITUTE CRLF
; OUTPUT TO TTY TOO IF DEBUGGING FLAG IS SET(DEBUG)
;INSERT PRECEDING ; IF FIRST CHAR ON A LINE AND F.COM SET
;CALL:	MOVEI	CH,CHAR
;	PUSHJ	P,FILPUT
;	RETURN CH PRESERVED

FILPUT:	TLNN	F,(F.OFO)	;OUTPUT FILE OUTPUT YET?
	POPJ	P,		;NO, MUST BE ASKING QUESTION ABOUT OUTPUT FILE
	CAIN	CH,"@"		;YES, IS THIS CHAR THE CRLF CHAR?
	PJRST	FCRLF		;YES, OUTPUT CRLF TO FILE AND RETURN
	SKIPE	DEBUG		;NO, ARE WE DEBUGGING?
	TLOE	F,(F.TF)	;YES, IS THIS THE FIRST CHAR TO FIL
				; AFTER TTY OUTPUT?
	JRST	FILPU1		;NO, LEFT ANGLE ALREADY OUTPUT
	PUSH	P,CH		;YES, SAVE CHAR
	MOVEI	CH,"<"		;FLAG START OF OUTPUT WITH LEFT ANGLE
	PUSHJ	P,TTYPU1	;ON TTY
	POP	P,CH		;RESTORE REAL FIRST CHAR TO FILE
FILPU1:	TLZE	F,(F.FLF)	;WAS LAST CHAR OUTPUT TO FILE A LF?
	TLNN	F,(F.COM)	;YES, SHOULD THIS LINEN BE A COMMENT IN FILE?
	JRST	FILPU2		;NO, SO OUTPUT IT
	PUSH	P,CH		;YES, SAVE FIRST CHAR OF LINE
	MOVEI	CH,";"		;INSTEAD PUT OUT SEMI-COLON AS COMMENT CHAR
	PUSHJ	P,FILPU3	; AS FIRST CHAR ON LINE
	MOVEI	CH,";"		;OUTPUT 2 ; IN CASE COMMENT IS IN MACRO
	PUSHJ	P,FILPU3	;SO WONT SAVE COMMENT IN MACRO EXPANSION
	MOVEI	CH,"	"	;TAB
	PUSHJ	P,FILPU3	;OUTPUT TAB
	POP	P,CH		;RESTORE FIRST CHAR OF COMMENT
FILPU2:	CAIN	CH,C.LF		;IS THIS CHAR A LINE FEED?
	TLO	F,(F.FLF)	;YES, FLAG LAST CHAR OUTPUT WAS A LINE FEED
				; FOR NEXT CALL TO FILPUT
FILPU3:	SKIPE	DEBUG		;DEBUGGING SO WANT TO SEE FILE OUTPUT
	PUSHJ	P,TTYPU1	;YES, OUTPUT TO TTY TOO
	SOSG	FOBUF+2		;DECREMENT BUFFER COUNTER
	PUSHJ	P,[OUT	FILCHN,	;BUFFER FULL, GIVE TO MONITOR
		   POPJ	P,	;NO ERRORS
		   JRST FILERR]	;FILE ERROR, COMPLAIN AND START OVER
	IDPB	CH,FOBUF+1	;STORE CHAR IN BUFFER
	POPJ	P,		;RETURN
;ROUTINE TO OUTPUT CRLF TO TTY
;CALL:	PUSHJ	P,TCRLF

TCRLF:	MOVEI	CH,C.CR		;CR CHAR
	PUSHJ	P,TTYPUT	;OUTPUT TO TTY
	MOVEI	CH,C.LF		;LINE FEED CHAR
				; FALL INTO TTYPUT ROUTINE

;ROUTINE TO OUTPUT 1 CHAR TO TTY, IF @ SUBSTITUTE CRLF
;CALL:	MOVEI	CH,CHAR
;	PUSHJ	P,TTYPUT
;	RETURN CH PRESERVED

TTYPUT:	CAIN	CH,"@"		;IS THIS THE CRLF CHAR?
	PJRST	TCRLF		;YES, OUTPUT CRLF ON TTY AND RETURN
	SKIPE	DEBUG		;NO, ARE WE DEBUGGING?
	TLZN	F,(F.TF)	;YES, IS THIS FIRST CHAR ON TTY AFTER FIL?
	JRST	TTYPU1		;NO, OK TO OUTPUT
	PUSH	P,CH		;YES, SAVE REAL FIRST CHAR
	MOVEI	CH,">"		;AND INDICATE TERMINATION OF FILE OUTPUT
	PUSHJ	P,TTYPU1	;OUTPUT TO TTY
	POP	P,CH		;RESTORE REAL FIRST TTY CHAR

;SUBROUTINE TO REALLY OUTPUT 1 CHAR TO TTY
TTYPU1:	SOSG	TOBUF+2		;ROOM IN THIS OUTPUT BUFFER?
	OUTPUT	TTYCHN,		;NO, SO OUTPUT 
	IDPB	CH,TOBUF+1	;THEN STORE THIS CHAR IN BUFFER
	POPJ	P,		;RETURN

;SUBOURINTE TO FORCE OUT CURRENT BUFFER NOW
;CALL:	PUSHJ	P,TTYNOW

TTYNOW:	OUTPUT	TTYCHN,		;GIVE BUFFER TO MONITOR
	POP	P,(P)		;REMOVE INSTRUCTION FROM STACK
	POPJ	P,		;RETURN
SUBTTL	DATA STORAGE

;CONSTANTS:

;DEFAULT FILE NAMES:
FILTAB:	SIXBIT	/HDWCNF/	;HDWCNF
	SIXBIT	/NETCNF/	;NETGEN
	SIXBIT	/F/		;FGEN
	SIXBIT	/MONGEN/	;MONGEN

;DISPATCH TABLE:
GENTAB:	EXP	HDWGEN		;HDWGEN
	EXP	NETGEN		;NETGEN
	EXP	FGEN		;FGEN


LSTD44:	I,,PAR			;INDEX BY DC44 NUMBER
	I,,PAP			;PA611R AND PA611P
	I,,LPC			;END LPC11
	I,,PCR			;END PC11 READERS
	I,,PCP			;AND PC11 PUNCHES
TYPDEV=.-LSTD44-1
;VARIABLES:
; THESE ARE STRICTLY INTERNAL TO MONGEN AND ARE NEVER OUTPUT IN FILE
;ONES NOT CLEARED IN MAIN LOOP, INSTEAD SET TO INITIAL VALUES ONLY ON GET.
; THUS ^C START DOES NOT INITIALIZE:


HELPF:	-1		;FLAG TO TYPE /HELP ONLY ONCE THRU LOOP OR START
DEBUG:	0		;PATCH NON-ZERO TO DEBUG BY HAVING FIL OUTPUT TO TTY TOO
			; COME OUT ON TTY INSIDE <>
SAVLV:	0		;CURRENT PERMANENT VERBOSICITY LEVEL FOR ASKING QUESTIONS
			; AC LV MAY BE DIFFERENT IF USER HAS CHANGED
			; LEVEL FOR THIS QUESTION ONLY
			; LEVELS ARE -1 FOR SHORT, 0 FOR PROMPT,
			; AND 1 OR GREATER FOR LONG
			; INITIALLY SET TO PROMPT ON A GET
FHNAME:	SIXBIT	.FGEN.	;LOOKUP BLOCK FOR FGEN AUXILIARY HELP FILE
	SIXBIT	.HLP.
	0
	0

RUNDEV:	BLOCK	1	;DEVICE FROM RUN OR GET
RUNPPN:	BLOCK	1	;DIRECTORY FROM RUN OR GET
FGPPN:	BLOCK	1	;DIRECTORY TO USE FOR HELP FILE
RUNPTH:	BLOCK	.PTMAX	;PATH BLOCK POINTED TO BY RUNPPN IF SFD

;VARIABLES CLEARED EACH TIME THROUGH MAIN LOOP FOR A NEW GEN:

VARBEG:			;FIRST LOC CLEARED ON MAIN LOOP
PDLIST:	BLOCK	MP.PDL+1	;PD LIST
ASKTAB:	BLOCK	MP.AMX+1	;TABLE TO STOR POSSIBLE ANSWERS
				; SETUP BY ASKLST WITH PROMPTING INSIDE ()
				; LAST ENTRY MUST BE ZERO AS FLAG OF END
				; FIRST ENTRY MAYBE 0 TO MEAN NO DEFAULT
				; IE (,ANS0,ANS1,...)
ASCSTR:	BLOCK	<MP.LMX+4+1>/5	;STRING FOR TTY INPUT LINE(SEE TTYIN)
			; ENOUGH ROOM FOR MP.LMX CHAR, PLUS NULL
SAVN:	BLOCK	1	;PLACE TO SAVE MATCH INDEX IN ASKLST SUB
CNFIND:	BLOCK	1	;INDEX OF SYSTEM TYPE
MINLIM:	BLOCK	1	;MIN VALUE FOR ASK QUESTION.  SET BY NOS. INSIDE ()
			; WHICH PRECED A DASH.
MAXLIM:	BLOCK	1	;MAX VALUE FOR ASK QUESTION.  SET BY NOS. INSIDE
			; WHICH FOLLOW A DASH.
DFAULT:	BLOCK	1	;DEFAULT FOUND FIRST INSIDE () IN ASK QUESTION
			; BY SETLST ROUTINE
WCHGEN:	BLOCK	1	;WHICH GEN, 0=HDW, 1=NET, 2=F
WCHNAM:	BLOCK	1	;WHICH GEN NAME, LH=SIXBIT HDW, NET, OR F
CPU:	BLOCK	1	;LOOP COUNTER FOR CPU LOOP
SCPUNR:	BLOCK	1	;NON-ZERO IF SOME CPU HAS NO REAL-TIME CLOCK
CHNTYP:	BLOCK	1	;CHANNEL TYPE 0=DF10,1=DF10C,2=DX10
CHN:	BLOCK	1	;LOOP COUNTER FOR CHANNEL LOOP
CCHN:	BLOCK	1	;LOOP COUNTER FOR CHANNELS ON A CPU
CPUN:	BLOCK	1	;LOOP COUNTER FOR DEVICES ON CPU'S OTHER THAN 0
TAPUN:	BLOCK	1	;UNIT NUMBER FOR TM02/TM78/DX20 TAPES
DTA:	BLOCK	1	;LOOP COUNTER FOR DTA LOOP
RX20:	BLOCK	1	;LOOP COUNTER FOR RX20 LOOP
MKON:	BLOCK	1	;COUNTER FOR MAG-TAPE KON ID
MKONP:	BLOCK	1	;NUMBER OF TAPE CONTROLS ON PREVIOUS CPUS
OSN:	BLOCK	1	;OCTAL STATION NO. CURRENTLY BEING DEFINED
LPTCNT:	BLOCK	1	;# OF LPTS
T2RH10:	BLOCK	1	;# OF RH10/TM02S ON CPU
T2RH1P:	BLOCK	1	;# OF RH10S ON PREVIOUS CPUS
D2RH20:	BLOCK	1	;# OF DX20S ON RH20S ON THIS CPU
TXCPUN:	BLOCK	1	;# TX10S
T1CPUN:	BLOCK	1	;# TM10S
RSCPUN:	BLOCK	1	;# OF RS04S ON THIS CPU
RPCPUN:	BLOCK	1	;# OF RP04S ON PREVIOUS CPUS
RNCPUN:	BLOCK	1	;# OF RP20S ON PREVIOUS CPUS
DPCPUN:	BLOCK	1
FHCPUN:	BLOCK	1
RH20CP:	BLOCK	1	;#OF RH20S ON THIS CPU
UCMBGN:			;FIRST WORD OF USER DEFINED COMMAND BLOCK
UCMCMD:	BLOCK	1	;COMMAND NAME
UCMPRG:	BLOCK	1	;PROGRAM NAME
UCMADR:	BLOCK	1	;DISPATCH ADDRESS
UCMBP1:	BLOCK	1	;INITIAL BYTE POINTER TO FLAGS/UNIQUE BITS
UCMBP2:	BLOCK	1	;FINAL BYTE POINTER TO FLAGS/UNIQUE BITS
UCMEND==.-1		;END OF BLOCK

;FILE 4 WORD ENTER BLOCK:
OUTNAM:	BLOCK	1	;FILE NAME
OUTEXT:	BLOCK	1	;FILE EXTENSION
OUTDAT:	BLOCK	1	;FILE DATE
OUTPPN:	BLOCK	1	;FILE PROJECT, PROGRAMMER NUMBER
SAVPPN:	BLOCK	1	;SAVE PPN FOR MESSAGE AFTER ENTER
;BUFFER HEADERS:
TIBUF:	BLOCK	3	;TTY INPUT BUFFER HEADER
TOBUF:	BLOCK	3	;TTY OUTPUT BUFFER HEADER
FOBUF:	BLOCK	3	;FILE OUTPUT BUFFER HEADER
FHIBUF:	BLOCK	3	;FGEN AUXILIARY HELP FILE INPUT BUFFER HEADER

;BUFFERS
FILBUF:	BLOCK	NFILBF*203	;BUFFERS FOR OUTPUT FILE
FHLPBF:	BLOCK	NFHLPBF*203	;BUFFERS FOR FHELP FILE

;POINTERS TO FGEN SWITCH TABLE
FTTAB:	BLOCK	1	;POINTER TO TABLE READ FROM FILE
FTADD:	BLOCK	1	;POINTER TO TABLE OF USER ADDED SWITCHES
FTLEN:	BLOCK	1	;MINUS LENGTH OF WHOLE TABLE
;VARIABLES WHICH ARE ALSO OUTPUT IN FILE AS SYMBOLS

;***************************************************************
;NOTE:	MACRO REQUIRES A ; AFTER ANGLE BRACKET IN CALL, ELSE TAB
; SNEAKS IN BETWEEN SYMBOL AND ;
;***************************************************************

;MACRO TO DEFINE CONSECUTIVE VARIABLES USED BY AOS(N) TRICK
;ORDER MUST BE THE SAME AS IN PROMPTING ANSWERS INSIDE PARENS

DEFINE	V (A)<
IRP (A) <M.'A:	BLOCK	1
>>

V <1070,1080,1090,1091,2020>;	;WHICH TYPE OF DECSYSTEM10
V <RT0,RT1,RT2,RT3,RT4,RT5>;	;NO OF DK-10S ON CPU'N
V <RTX>;			;TOTAL DK-10S ON SYSTEM
V <RTCA>;			;HIGH PRECISION TIME ACCOUNTING
V <RTCO>;			;INCLUDE MONITOR OVERHEAD IN RUNTIME
V <RTC>;			;INCLUDE DK10 SERVICE ROUTINE
V <EMRT>;			;EBOX/MBOX RUNTIME ACCOUNTING
V <XPI>;			;EXCLUDE PI TIME FROM USER RUNTIME
V <CPU>;			;NO. OF CPUS
V <P10>;			;PDP-10
V <P10I>;			;PDP-10I
V <KL10>;			;KL10 CPU
V <KS10>;			;KS10 CPU
V <C0SN,C1SN,C2SN,C3SN,C4SN,C5SN>;  ;CPU SERIAL NOS.
V <MON,DAY,YEAR>;		;MONTH, DAY, YEAR SYMBOLS
V <CHN>;			;NO. OF DISK CHANNELS
V <RC10>;			;NO. OF RC10 CONTROLLERS
V <RH1S>;			;NO OF RH10/RS04 CONTROLLERS
V <RH1P>;			;NO OF RH10/RP04 CONTROLLERS
V <RH2P>;			;NO. OF RH20/RP04 CONTROLLERS
				;MUST IMMEDIATELY FOLLOW RH1P
V <RHP4>;			;TOTAL NO OF RHP04'S (RH10 AND RH20)
V <RP20>;			;TOTAL NO OF RP20'S (RH20)
V <RH20>;			;NO. OF RH20S (RP04, TM02)
V <RP10>;			;NO. OF RP10 CONTROLLERS
V <TX01>;			;NO. OF TX01 CONTROLLERS
V <TM10>;			;NO. OF TM10 CONTROLLERS
V <T210>;			;NO. OF TM02 CONTROLLERS
V <DX20>;			;NO. OF DX20 CONTROLLERS
V <T78>;			;NO OF TM78 CONTROLLERS

V <HRSN>;			;HIGHEST REMOTE STATION NUMBER
V <TTDN>;			;TOTAL NUMBER OF RSX20-F TERMINALS
V <DLP>;			;TOTAL NUMBER OF RSX20-F LPTS
V <DCR>;			;TOTAL NUMBER OF RSX20-F CDRS
;HDWGEN:
V <VP10,340,VBXC>;		;TYPE OF DISPLAY
V <DAS78,D78L,0D78,1D78,2D78,3D78,4D78,5D78,6D78,7D78>;	;DAS78
V <DN6D,D60L,0D60,1D60,2D60,3D60,4D60,5D60,6D60,7D60,8D60,9D60,AD60,BD60>;	;DN60

;TTYGEN:
V <DC10,DC68,DC76>;		;TYPE OF TERMINAL COMMUNICATIONS EQUIPMENT
V <TTG0,TTG1,DSG0,DSG1,68L0,68L1,D70N,D71N,D72N,D73N,D74N,D75N,D76N,D77N>
V <DZNL>;
	DEFINE	BLOK4(PREFIX,POSTFX)
<	IRP	PREFIX
<
PREFIX:
ZZZ=0
	REPEAT	8,<
	WORD	(PREFIX,\ZZZ,POSTFX)
ZZZ=ZZZ+1
>	;;END OF REPEAT 4
	WORD	(PREFIX,8,POSTFX)
	WORD	(PREFIX,9,POSTFX)
	WORD	(PREFIX,A,POSTFX)
	WORD	(PREFIX,B,POSTFX)
>	;;END OF IRP PREFIX
>	;;END OF DEFINE BLOK4

	DEFINE	WORD(A,B,C)
<A'B'C:	EXP	0
>

;NOTE THE POSTFIX IS A NOOP FOR PREFIXES OF 5 CHARACTERS E.G. TYPNU
M.DC44:	EXP	0	;NUMBER OF DC44'S
TYPNUM:	EXP	0	;TOTAL NUMBER OF DC44 FRONT END DEVICES
	BLOK4	<TYPNU,PAR,PAP,LPC,PCR,PCP>,N

M.DC75:	EXP	0	;NUMBER OF DC75'S OF DAS85'S
M.DL10:	EXP	0
M.0D85:	EXP	0	;SYMBOL INDICATING PORT PRESENT
M.1D85:	EXP	0
M.2D85:	EXP	0
M.3D85:	EXP	0
M.4D85:	EXP	0
M.5D85:	EXP	0
M.6D85:	EXP	0
M.7D85:	EXP	0
M.D78N:	EXP	0	;COUNT OF NUMBER OF DAS78S IN THE SYSTEM
M.DN60:	EXP	0	;COUNT OF GENERIC DN60 DEVICES
M.DN6K:	EXP	0	;COUNT OF KS10/DUP DN60 DEVICES
M.DN6R:	EXP	0	;COUNT OF KS10 DMR DN60 DEVICES
M.DN6S:	EXP	0	;COUNT OF KL10/DTE BASED DN60 DEVICES
M.KDPN:	EXP	0
M.DMRN:	EXP	0
M.DN8S:	EXP	0
M.DDCN:	EXP	0
M.CONN:	EXP	0	;ACCUMULATES DEFAULT # OF CONNECTS
M.CDR:	EXP	0
M.CDP:	EXP	0
M.PLT:	EXP	0
M.PTP:	EXP	0
M.PTR:	EXP	0
M.SCA:	EXP	0
VAREND==.-1		;LAST LOC TO CLEAR IN MAIN LOOP FOR NEW GEN
	END	BEGINA
   q7SE