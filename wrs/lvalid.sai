begin "outerblock"

require "(KS2020)sail.def" source!file;


COMMENT version 1.0 E.L. Bolton;
comment DVALID "Distributed TYMCOM-X systems User Validation Program";
COMMENT version 2.0 Greg Lyons  September 1980 [20VALI ==> DVALID];

comment LVALID "Local TYMCOM-X systems User Validation Program";
COMMENT version 1.0 Greg Lyons  November 1980 [DVALID ==> LVALID];
COMMENT		renamed to LVALID and XMITed as version 1.0;

!  define ! = "comment";
! require "{}{}" delimiters;
! define crlf = {('15&'12)};
require "hash"  load!module;  ! Hash for usernames. Requires the username
				in SIZBIT and puts the locator in blknum;
require "hashpa"  load!module;  ! Hash for password. Requires the
				  in SIXBIT and puts the locotor in Pblknum;

  require "(sailib)brkfns.hdr" source!file;  ! contains rvscan;
! require "brkfns.hdr" source!file;  ! contains rvscan;
! globals;
string uname;
integer array buf[0:127], Dbuf[0:127], Pbuf[0:127];   ! these are the buffers for LUD,DUL 
                           and PAS files respectively;
integer bufptr, ludchan, siz, dulchan, Dbufptr, Dblknum;
integer Pbufptr, paschan;
integer eof;
internal integer hun, blknum, lftnam, rtnam; !  these internals are for HASH (username);
internal integer hpw, Pblknum, lftpas, rtpas;   !  these internals are for HASHPA (password) ;
string array mode[0:3], discon[0:3], zone[0:27]; !  these are the global arrys for EXEC MODES,
                            DISCONNECT ACTIONS andTIME ZONES;

define
  bufppn = {buf[bufptr+0]},  
  bufdst = {buf[bufptr+1]},  
  bufjnk = {buf[bufptr+2]},  
  bufprv = {buf[bufptr+3]},  
  bufhun = {buf[bufptr+4]};  
define buf!siz = {bufjnk land '177};
! rh(x) = {(x land '777777)},
! lh(x) = {(x lsh -18)};
define
	name!byt = {point(36,bufhun,35)},
	gan!byt = {point(18,bufppn,17)},
	uun!byt = {point(18,bufppn,35)},
  	rub!byt = {point(1,bufjnk,2)},
	gfd!byt = {point(1,bufjnk,3)},
	tru!byt = {point(1,bufjnk,4)},
	orid!byt = {point(1,bufjnk,19)},
	bill!byt = {point(1,bufjnk,20)},
	init!byt = {point(1,bufjnk,27)},
	siz!byt = {point(7,bufjnk,35)},
	dist!byt = {point(8,bufdst,35)},
	day!byt ={point(1,bufprv,2)},
	zon!byt ={point(5,bufprv,7)},
	cor1!byt = {point(7,bufprv,17)},
	discc!byt = {point(2,bufprv,20)},
	tym!byt = {point(1,bufprv,21)},
	accs!byt = {point(1,bufprv,22)},
	rcm!byt = {point(1,bufprv,26)},
	mode!byt = {point(2,bufprv,28)},
	cor2!byt = {point(7,bufprv,35)};
	
define
	Dbufppn = {Dbuf[Dbufptr + 0]},
	Dbuflun = {Dbuf[Dbufptr + 1]},
	Dbufrun = {Dbuf[Dbufptr + 2]};
define
	Dgan!byt= {point(18,Dbufppn,17)},
	Duun!byt= {point(18,Dbufppn,35)},
	lun!byt = {point(36,Dbuflun,35)},
	run!byt = {point(36,Dbufrun,35)};
define
	Pbufhun = {Pbuf[Pbufptr + 0]},  
	Pbufpwd = {Pbuf[Pbufptr + 1]};  
define
	Phun!byt = {point(36,Pbufhun,35)},
	Ppwd!byt = {point(36,Pbufpwd,35)};

	define sysppn = '1000004;

external simple procedure hash;  ! Hash for usernames;
external simple procedure hashpa;  ! hash for passwords;

forward procedure help!msg(integer msgnum);


!	simple procedure auxcli(integer port,arg,function); !  this is a piece of macro code ;
!	start!code  jrst auxclr; !  to facilitate turning the echo ;
!	end;			 !   on and off.  ;

! Routine to set the break table to allow for stripping blanks
  from the input commands;

integer notspc;		! number of break table for stripping blanks;
integer nxtwordtbl;	! number of break table for nxtword;

simple procedure makeBreaks;
  begin
    setbreak(notspc_getbreak," "& '11 & 0,null,"XNR");
	! stop on 1st char not a space, tab, or null;
    setbreak (nxtwordtbl_getbreak,", "&CR,CRLF&HT&", ","ISN");
	! stop on CR, comma, or space, throwout cr,lf,ht," ",and "," ;
    end;
require makeBreaks initialization [0];

! routine that strips first leading blanks and then trailing blanks;

simple string procedure strip ( string s);
  begin integer temp;
    scan(s,notspc,temp) ;	! remove leading spaces;
    rvscan(s,notspc,temp) ;	! remove trailing spaces;
    return(s) ;
  end;

! Procedure to Pull individual words from tty input;

string procedure nxtword;
begin "get word"
string s;
s _ "";
eof _ 0;
while length(s)=0 and not eof=cr do
	s _ (ttyinl(nxtwordtbl,eof));
if eof=cr then instr(lf);
return(s);
end "get word";

simple integer procedure gettab(integer index,table);
start!code
	SETOM !SKIP!;
	HRL 1,INDEX;
	HRR 1,TABLE;
	CALLI 1,'41;
	  SETZM !SKIP!;
END;

simple boolean procedure JL!lic;
if (gettab(-1,-'20) land '1000000000)=0 then return(false)
else return(true);

simple integer procedure WR!lic;
return((gettab(-1,-'20) lsh -18) land 3);

simple integer procedure RD!lic;
return(((gettab(-1,-'20) lsh -20) land 3) max WR!lic);


!  this procedure will type out the complete help file if requested and
   returns to the command prompt level when completed. ;


procedure type!help;
begin "type!help"
integer chan, eof, brchar, eol;
string this!line,more!help;

  setbreak(eol_getbreak,"'15&'12",null,"ina");
  open( chan_getchan, "dsk", 0,2,0,200,brchar,eof);
  lookup(chan,"VALID.DOC",eof);
  if eof then print(crlf,"Cannot find file - VALID.DOC",crlf);		  
  while not eof do
  begin
   this!line_input(chan,eol);
   print(this!line);
  end;
  release(chan);
end "type!help";
!  this procedure will type out the appropriate short help message about
   a command by the number supplied to it from the calling procedure, and
   then returns in line. ;


procedure help!msg(integer msgnum);
begin
preset!with

! msg[0]_ ;
"The QUIT command will return you to the exec level.",
! msg[1]_ ;
"The NEW command is used to establish the first user in a new global account.",
! msg[2]_ ;
"The CHECK command is used to see if USER NAMES and PPNs already exist.",
! msg[3]_ ;
"The ADD command is used to validate a new user to an existing global account.
You must have supervisor status to use this command.",
! msg[4]_ ;
"The CANCEL command is used by a supervisor to delete:
     1.	A single user, or
     2.	All users in a specified global account
The user's file directory (ufd) should be empty and the user should not
be logged into the system under a username to be deleted.

Subcommands are: ACCOUNT(by number)
		 USER(by username)",
! msg[5]_ ;
"The SET command is used to change bits for OVERRIDE, GFD, BILLABLE,
SUPERVISOR, RESTRICTED USER and/or the RESTRICTED COMMAND BIT.
You must have supervisor status over the user to be changed.",

! msg[6]_ ;
"The LIST command is used to list any of the following:
     1.	The LUD information for a specific user name.
     2. All of the NAMES (and UUNs) in a specific GAN.
     3. The LUD information for ALL USERS in a specific GAN.",

! msg[7]_ ;
"The CHANGE command is used to change a user's password, mode, or quota.
Subcommands are: 1)PASSWORD (passwords must be at least seven and not
			     more than thirty six characters in length.)
		 3)QUOTA
		 4)MODE     (XEXEC,PDP,JAPAN,SUDS)

to make other changes see the SET command.",

! msg[8]_ ;
"Valid commands are:
	HELP  	Types this list				(no /?HELP)
	?	Same as HELP
	DOC	Types entire command documentation file	(no /?DOC)
	NEW	Creates a new account
	ADD	Adds additional users to an account
	LIST	(A USER, ACCOUNT NAMES, ACCOUNT USERS)
	CANCEL	(ACCOUNT OR USER)
	CHANGE	(PASSWORD,MODE,QUOTA)
	CHECK	(NAME,PPN)
	SET	Used for Y/N parameters
	QUIT	To exit this program

Preceding a command with '/?' (as in '/?ADD') will give a short
description for that command.
A question mark given in response to a prompt will get the user
information about what kind of response(s) would be appropriate.
All commands may be typed in Upper OR lower case.";


own string array msg[0:8];

print (msg[msgnum]);
end;
!  almost all of the prompting in this program is done by
   number. Then all information is gathered into an array in the same numbered
   order and the arrays are passed from one procedure to another. ;

!  this is the list of prompts for the program;

procedure prompt(integer prmptnum);
begin "prompt"
preset!with

! prmpt[0]_; "USER NAME: ",
! prmpt[1]_; "GLOBAL ACCOUNT NUMBER (GAN): ",
! prmpt[2]_; "UNIVERSAL USER NUMBER: ",
! prmpt[3]_; "DISTRICT: ",
! prmpt[4]_; "TYMSHARE? ",
! prmpt[5]_; "BILLABLE? ",
! prmpt[6]_; "ACCOUNT SUPERVISOR? ",
! prmpt[7]_; "SET GET FILE DIRECTORY? ",
! prmpt[8]_; "SET RESTRICTED COMMAND MODE(RCM)? ",
! prmpt[9]_;  "DISK QUOTA  IN: ",
! prmpt[10]_; "DISK QUOTA OUT: ",
! prmpt[11]_; "SET DISCONNECT ACTION: ",
! prmpt[12]_; "SET RESTRICTED USER BIT? ",
! prmpt[13]_; "EXEC MODE: ",
! prmpt[14]_; "SET OVERIDE BIT? ",
! prmpt[15]_; "USER SUBJECT TO DAYLIGHT SAVINGS? ",
! prmpt[16]_; "TIME ZONE: ",
! prmpt[17]_; "PASSWORD: ",
! prmpt[18]_; "ENTER PASSWORD AGAIN: ";

own string array prmpt[0:18];
outstr(prmpt[prmptnum]);
end "prompt";


integer	PROCEDURE UFD!FILES(integer ppn);
begin "READ UFD"
integer filecount;
integer i, chan;
integer array UFDBLK[0:7];
integer array UFDBUF[0:127];
INTEGER ARRAY LKB[0:3];		! BLOCK FOR EXTENDED LOOKUP;

filecount _ 0;
LKB[0] _ ARRINFO(LKB,2);	! SIZE OF LKB;
LKB[1] _ CALLI('16,'41);	! MFD PPN;
LKB[2] _ PPN;
LKB[3] _ CVSIX("UFD");		! EXTENTION;

OPEN (CHAN _ getchan,"DSK",'17,0,0,0,0,EOF);
IF EOF THEN filecount _ -1
else begin "lookup ufd"
	CHNIOR (CHAN, LKB[0], 4);	! LOOKUP UFD TO GET PPN;
	IF NOT !SKIP! THEN filecount _ -2;
end "lookup ufd";

if filecount = 0 then begin "start count"
ufdblk[0] _ xwd(-128,location(ufdbuf[0]));
ufdblk[1] _ cvsix("*");
ufdblk[2] _ cvsix("*");
ufdblk[3] _ 0;	! return only filename and extention;
ufdblk[5] _ 0;	! start name/name of last file returned;
ufdblk[6] _ 0;	! start ext/ext of last file returned;
ufdblk[7] _ 0;	! # of filenames returned;

!SKIP! _ true;
while !SKIP! do begin "count all"
chnior(chan,ufdblk[0],'33);	! CHUFD: read UFD (CHANIO fn 33);
filecount _ filecount+ufdblk[7];
! begin "list files"

	! Starting with ",cv6str(ufdbuf[0]),".",cv6str(ufdbuf[1]),nl);
	! " and ending with ",cv6str(ufdblk[5]),".",cv6str(ufdblk[6]),nl);
	! for I_0 step 2 until (ufdblk[7]*2)-1 do begin
	!	if I mod 5 = 0 then print(nl);
	!	print(cvxstr(ufdbuf[i]),".",cvxstr(ufdbuf[i+1]));
	! end;
! end "list files";
! print(nl,cvs(ufdblk[7])," files.");
end "count all";
end "start count";
release (chan);
return(filecount);
end "READ UFD";


boolean procedure DEL!FILE(integer ppn,fn,ext);
begin "DEL!FILE"
integer chan, flag, prot;
boolean retflag;
string filespec;

filespec_cv6str(fn)&"."&cv6str(ext)&"["&cvos(lh(ppn))&","&cvos(rh(ppn));
!	print(HT,filespec);
OPEN (CHAN _ getchan,"DSK",'17,0,0,0,0,EOF);
LOOKUP (CHAN,filespec,flag);
retflag _ false;
if flag=0 then begin "rename"
 retflag _ true;
 prot _ 0;
!	 print ("]");
 RENAME (CHAN,"",prot,flag);		! DELETE THE FILE;
 if not flag=0 then begin "ren err"
	print(rh(cvos(flag)));
	retflag _ false;
 end "ren err";
end "rename";
release (chan);
return(retflag);
end "DEL!FILE";

! Delete ALL files in a UFD.  Return # of files not deleted;

integer	PROCEDURE DEL!UFD(integer ppn);
begin "DEL!UFD"
integer delfail;
integer i, chan;
boolean more;
integer array UFDBLK[0:7];
integer array UFDBUF[0:127];
INTEGER ARRAY LKB[0:3];		! BLOCK FOR EXTENDED LOOKUP;

delfail _ 0;
LKB[0] _ ARRINFO(LKB,2);	! SIZE OF LKB;
LKB[1] _ CALLI('16,'41);	! MFD PPN;
LKB[2] _ PPN;
LKB[3] _ CVSIX("UFD");		! EXTENTION;

OPEN (CHAN,"DSK",'17,0,0,0,0,EOF);
IF EOF THEN delfail _ -1
else begin "lookup ufd"
	CHNIOR (CHAN, LKB[0], 4);	! LOOKUP UFD TO GET PPN;
	IF NOT !SKIP! THEN delfail _ -2;
end "lookup ufd";

if delfail = 0 then begin "start count"
ufdblk[0] _ xwd(-128,location(ufdbuf[0]));
ufdblk[1] _ cvsix("*");
ufdblk[2] _ cvsix("*");
ufdblk[3] _ 0;	! return only filename and extention;
ufdblk[5] _ 0;	! start name/name of last file returned;
ufdblk[6] _ 0;	! start ext/ext of last file returned;
ufdblk[7] _ 0;	! # of filenames returned;

more _ true;
while more do begin "count all"
chnior(chan,ufdblk[0],'33);	! CHUFD: read UFD (CHANIO fn 33);
more _ !skip!;
for I_0 step 2 until (ufdblk[7]*2)-1 do
 if not DEL!FILE(ppn,ufdbuf[i],ufdbuf[i+1]) then delfail _ delfail + 1;
end "count all";
end "start count";

if delfail=0 then begin "del directory"
  LKB[2] _ 0;				! ZERO THE FILENAME;
  CHNIOR (CHAN, LKB[0], '11);		! RENAME TO DELETE UFD;
  IF NOT !SKIP! THEN delfail _ -3;
end "del directory";
release (chan);
return(delfail);
end "DEL!UFD";


!  this is the output routine for a complete entry;

procedure format(string array insert);
begin "format"
print("
USERNAME: ",insert[0],"		TYMSHARE: ",insert[4],"
GAN: ",insert[1],"				BILLABLE: ",insert[5],"
UUN: ",insert[2]," 			SUPERVISOR: ",insert[6],"
DIST: ",insert[3],"				RUB: ",insert[12],"
MODE: ",insert[13],"			GFD: ",insert[7],"
QUOTA  IN: ",insert[9], "		RCM: ",insert[8],"
QUOTA OUT: ",insert[10],"		OVERRIDE: ",insert[14],"
DAYLIGHT SAVINGS: ",insert[15],"		TIME ZONE: ",insert[16],"
DISCONNECT: ",insert[11],"		PPN: ",insert[1],",,",insert[2],crlf);
end "format";
!  the information in this procedure will be supplied to the user
   in response to a question mark being type after a prompt for information
   has been issued ;

procedure prmsg(integer prmsgnum);
begin "prmsg"
preset!with

! prmsg[0]_; "User names are alphanumeric's only between two and twelve
characters in length.",
! prmsg[1]_; "must be an octal number, one to six characters in length.",
! prmsg[2]_; "must be a unique octal number, one to six characters in length.",
! prmsg[3]_; "must be a decimal number, not larger than 255.",
! prmsg[4]_; "is this a TYMSHARE employee or not? ",
! prmsg[5]_; "is this a username to be charged for time? ",
! prmsg[6]_; "do you want this user to have supervisory status in this gan?",
! prmsg[7]_; "allows one user to gain acces to another user's storage area or directory.",
! prmsg[8]_; "when this bit is set, programs can be run that want to handle everything that is typed on the terminal.",
! prmsg[9]_; "prompt is requesting the number of blocks. There are four 
blocks per page and 512 words per page.",
! prmsg[10]_; "prompt is requesting the number of blocks. There are four
blocks per page and 512 words per page.",
! prmsg[11]_; "what you want to happen if the terminal becomes disconnected. options are:
logout
detach
continue
detach, logout after 15 minutes.",
! prmsg[12]_; "this bit is used to restrict the number of users allowed to access a specific job.",
! prmsg[13]_; "types of mode are:
xexec
pdp
japan
suds",
! prmsg[14]_; "allows the user to override the system when it's shut.",
! prmsg[15]_; "is the user in an area subject to daylight savings time",
! prmsg[16]_; "valid zones are:
gmt
hawaii and alaska
pacific
mountain
central
eastern
atlantic
london
western europe
tokyo
brisbane";

own string array prmsg[0:16];
print(prmsg[prmsgnum]);
end "prmsg";
integer procedure lud!overflo;
begin "ludoverflow"  ! Extended lookup to obtain file size. Size is returned
         in LUB[5] in words. See page 93 of the MURRAY. ;
integer array lub[0:5];
integer lubchan, ppn;  string protection;

lubchan _ getchan;
lub[0] _ lub[2] _ 0;
lub[1] _ cvsix("DSK");
chnior(lubchan, lub[0], '13);

lub[0] _ 6;
lub[1] _ sysppn;
lub[2] _ cvsix("LUD");
lub[3] _ cvsix("SYS");
lub[4] _ protection;
lub[5] _ 0;
chnior(lubchan, lub[0], 4);
chniov(lubchan, 0, 0);
release(lubchan);

return(lub[5] ash -7 +1);
end "ludoverflow";



integer procedure dul!overflo;
begin "duloverflow"  ! Another extended lookup like above. ;
integer array lub[0:5];
integer lubchan, ppn;  string protection;

lubchan _ getchan;
lub[0] _ lub[2] _ 0;
lub[1] _ cvsix("DSK");
chnior(lubchan, lub[0], '13);

lub[0] _ 6;
lub[1] _ sysppn;
lub[2] _ cvsix("DUL");
lub[3] _ cvsix("SYS");
lub[4] _ protection;
lub[5] _ 0;
chnior(lubchan, lub[0], 4);
chniov(lubchan, 0, 0);
release(lubchan);

return(lub[5] ash -7 + 1);
end "duloverflow";

integer procedure pas!overflo;
begin "pasoverflow"  ! Another extended lookup like above. ;
integer array lub[0:5];
integer lubchan, ppn;  string protection;

lubchan _ getchan;
lub[0] _ lub[2] _ 0;
lub[1] _ cvsix("DSK");
chnior(lubchan, lub[0], '13);

lub[0] _ 6;
lub[1] _ sysppn;
lub[2] _ cvsix("PAS");
lub[3] _ cvsix("SYS");
lub[4] _ protection;
lub[5] _ 0;
chnior(lubchan, lub[0], 4);
chniov(lubchan, 0, 0);
release(lubchan);

return(lub[5] ash -7 + 1);
end "pasoverflow";
!  these are dummy procedures to allow for the future implementation of TRU budgeting and/or
   init files. what they return has a direct effect on
   the size of the particular LUD entry. see procedure GET!READY;


boolean procedure tru;
begin
return(false);
end;

boolean procedure init;
begin
return(false);
end;

!  these procedures do the entering of the finished buffers for the files
   LUD, DUL and PAS.;
procedure ntr!lud;
begin "enter lud"
integer eof;


enter(ludchan,"(SYS)LUD.SYS",eof);
useto(ludchan,blknum);
arryout(ludchan,buf[0],128);
close(ludchan);
end "enter lud";

procedure ntr!dul;
begin "enter dul"
integer eof;

enter(dulchan,"(SYS)DUL.SYS",eof);
useto(dulchan,Dblknum);
arryout(dulchan,Dbuf[0],128);
close(dulchan);
end "enter dul";

procedure ntr!pass;
begin "enter password"
integer eof;

enter(paschan,"(SYS)PAS.SYS",eof);
useto(paschan,Pblknum);
arryout(paschan,Pbuf[0],128);
close(paschan);
end "enter password";
!  these next four procedures  wrt!dul,fnd!Dhole,fnd!ppn,fnd!gan  
   all relate to the DUL file. the first one writes the DUL buffer
   and the other three are searches through the DUL. the three search files
   do "open and lookups" for reading only.;


procedure wrt!dul(string dentry0,dentry1,dentry2);
begin "write dul"
integer lnam, rnam;

lnam _ cvsix(dentry0[1 for 6]);
rnam _ cvsix(dentry0[7 for 6]);

dpb(cvo(dentry1),Dgan!byt);
dpb(cvo(dentry2),Duun!byt);
dpb(lnam,lun!byt);
dpb(rnam,run!byt);

ntr!dul;
end "write dul";
!  returns TRUE if it can find a hole for a new entry. It should always
   return TRUE as it can create overflow blocks as needed. ;


boolean dure fnd!Dhole(string pp1,pp2);
begin "find Dhole"
integer eof, this!ppn, cnt, svblknum;

this!ppn _(cvo(pp1) lsh 18) + cvo(pp2);
! print ("This!ppn- ",cvos(this!ppn),crlf);  ! **d*;

lookup(dulchan,"(SYS)DUL.SYS",eof);

Dblknum _ this!ppn mod 101 + 1;
while true do
  begin "block"
    useti(dulchan,Dblknum);
    arryin(dulchan,Dbuf[0],128);
    Dbufptr _ 0;
    while Dbufptr < 128 do
      begin "record"
        if Dbufppn = 0 then
          begin "which case"
            if Dbufptr + 3 < 128 then return(true)
            else begin "overflow block"
                   svblknum _ dul!overflo;
                   Dbufppn _ svblknum;
		   ntr!dul;   ! write pointer out;
		   lookup(dulchan,"(SYS)DUL.SYS",eof);
		   arrclr(Dbuf);
		   done "record";
                 end "overflow block";
          end "which case";
        Dbufptr _ Dbufptr + 3;
      end "record";
    Dblknum _ rh(Dbufppn);
  end "block";
return(false);
end "find Dhole";
!  this procedure does a sequential search of the block obtained from the
   formula (ppn mod 101 + 1) and returns TRUE on a match with the ppn
  passed to it. ;



boolean procedure fnd!ppn(integer ppn);
begin "find ppn"
integer eof;

lookup(dulchan,"(SYS)DUL.SYS",eof);

Dblknum _ ppn mod 101 + 1;
do begin "ppnblock"
  useti(dulchan, Dblknum);
  arryin(dulchan, Dbuf[0], 128);
  Dbufptr _ 0;
  while lh(Dbufppn) >0 do 
    begin "ppnrecord"
      if Dbufppn = ppn then return(true);
      Dbufptr _ Dbufptr + 3;
    end "ppnrecord";
if lh(Dbufppn) = 0 and rh(Dbufppn) >0 then Dblknum _ rh(Dbufppn);
end "ppnblock" until Dbufppn leq 0;
return(false);
end "find ppn";
!  this procedure does a sequential search of the complete DUL file starting
    at block 1 looking for a match on the GAN only. calls the procedure
   specified to it in it's argument list for each match found.;


procedure fnd!gan(integer Dgan; procedure where);
begin "find Dgan"
integer eof;

lookup(dulchan,"(SYS)DUL.SYS",eof);

for Dblknum _ 1 step 1 until dul!overflo do
  begin "read"
    useti(dulchan,Dblknum);
    arryin(dulchan,Dbuf[0],128);
    Dbufptr _ 0;
    if eof then print("?end of file");
    while Dbufppn > 0 do 
      begin "search"
         if lh(Dbufppn) = Dgan then where;
        Dbufptr _ Dbufptr + 3;
      end "search";
  end "read";
close(dulchan);
end "find Dgan";

procedure fnd!all(integer Dgan; procedure where);
begin "find Dall"
integer eof;

lookup(dulchan,"(SYS)DUL.SYS",eof);

for Dblknum _ 1 step 1 until dul!overflo do
  begin "read"
    useti(dulchan,Dblknum);
    arryin(dulchan,Dbuf[0],128);
    Dbufptr _ 0;
    if eof then print("?end of file");
    while Dbufppn > 0 do 
      begin "search"
	where;
        Dbufptr _ Dbufptr + 3;
      end "search";
  end "read";
close(dulchan);
end "find Dall";
!  these next three procedures   wrt!lud,fnd!Lhole,fnd!name   are for
   the LUD. ths first one writes the LUD buffer and the other two are searches
   through the LUD. the two search files do open and lookups for
   reading only. ;

procedure wrt!lud(string array lud!entry);
begin "write lud"
integer eof;
define
	bufstr = {buf[bufptr+(siz-3)]},
	bufqin = {buf[bufptr+(siz-2)]},
        bufqot = {buf[bufptr + (siz-1)]};

define
	str!byt = {point(36,bufstr,35)},
	qin!byt = {point(36,bufqin,35)},
	qot!byt = {point(36,bufqot,35)};

dpb(hun,name!byt);
dpb(cvo(lud!entry[1]),gan!byt);
dpb(cvo(lud!entry[2]),uun!byt);
dpb(cvd(lud!entry[3]),dist!byt);
dpb(lud!entry[4],tym!byt);
dpb(lud!entry[5],bill!byt);
dpb(lud!entry[6],accs!byt);
dpb(lud!entry[7],gfd!byt);
dpb(lud!entry[8],rcm!byt);
dpb(cvd(lud!entry[9]),qin!byt);
dpb(cvd(lud!entry[10]),qot!byt);
dpb(lud!entry[11],discc!byt);
dpb(lud!entry[12],rub!byt);
dpb(lud!entry[13],mode!byt);
dpb(lud!entry[14],orid!byt);
dpb(lud!entry[15],day!byt);
dpb(lud!entry[16],zon!byt);
dpb('177,cor1!byt);
dpb('177,cor2!byt);
dpb(siz,siz!byt);
dpb(cvsix("DSKB"),str!byt);

ntr!lud;
end "write lud";
!  returns TRUE if it can find a hole for a new entry. It should always
   return TRUE as it can create overflow blocks as needed. ;

boolean procedure fnd!Lhole(string username);
begin "find hole"
integer eof, cnt, svblknum;

lookup(ludchan,"(SYS)LUD.SYS",eof);

lftnam_cvsix(username[1 for 6]);
rtnam_ cvsix(username[7 for 6]);

hash;
while true do 
  begin "block"
    useti(ludchan,blknum);
    arryin(ludchan,buf[0],128);
    bufptr_0;
    cnt_0;
    while bufppn > 0 do 
      begin "record"
        if bufhun = 0 and buf!siz=siz then return(true);
        bufptr_bufptr + buf!siz;
        cnt_1;
      end "record";
    if bufppn = 0 and bufptr + siz > 128 then 
      begin "newblock"
         svblknum_ lud!overflo;
         bufppn_'400000000000 lor svblknum;
	 ntr!lud;    ! rewrite block with overflow pointer;
	 lookup(ludchan,"(SYS)LUD.SYS",eof);
	arrclr(buf);
         end "newblock"
    else return(true);
    blknum _ rh(bufppn);
  end "block";
return(false);
end "find hole";
!  this procedure does a sequential search of the block obtained from the
   hash locator and returns TRUE on a match with the hashed user name;


boolean procedure fnd!name(string username);
begin "find name"
integer eof;

lookup(ludchan,"(SYS)LUD.SYS",eof);

lftnam_cvsix(username[1 for 6]);
rtnam_ cvsix(username[7 for 6]);

hash;
while true do 
  begin "block"
    useti(ludchan,blknum);
    arryin(ludchan,buf[0],128);
    bufptr_0;
    while bufppn > 0 do 
      begin "record"
        if bufhun = hun then return(true);
        bufptr_bufptr + buf!siz;
      end "record";
    if bufppn = 0 then return(false);
    blknum _ rh(bufppn);
  end "block";

end "find name";

!  these next three procedures   wrt!pass,fnd!Phole,fnd!Pname  are for
   the password file. wrt!pass writes the buffer for PAS.
   the other two are searches through PAS  and do "open and lookups" for reading only.;

procedure wrt!pass;
begin "write password"

dpb(hun,Phun!byt);
dpb(hpw,Ppwd!byt);

ntr!pass;
end "write password";

!  this procedure does a  search of the file starting at
   block for hashed user name and scans for match;

boolean procedure fnd!Pname;
begin "find password entry"
integer eof;

lookup(paschan,"(SYS)PAS.SYS",eof);

Pblknum _ blknum;   ! use hashed user name block;
while true do
  begin "read"
    useti(paschan,Pblknum);
    arryin(paschan,Pbuf[0],128);
    Pbufptr _ 0;
    while Pbufptr < 128-2 do 
      begin "search"
         if Pbufhun = hun then return(true);
        Pbufptr _ Pbufptr + 2;
      end "search";
    if Pbufhun = 0 then return(false);
    Pblknum _ pbufhun;		! advance to overflow block;
  end "read";
return(false);
end "find password entry";


!  returns TRUE if it can find a hole for a new entry. It should always
   return TRUE as it can create overflow blocks as needed. ;

boolean procedure fnd!Phole(string password);
begin "find Phole"
integer eof, svblknum;

lookup(paschan,"(SYS)PAS.SYS",eof);

lftpas _ cvsix(password[1 for 6]) xor (cvsix(password[13 for 6]) rot 2) xor (cvsix(password[25 for 6]) rot 4);
rtpas _ cvsix(password[7 for 6]) xor (cvsix(password[19 for 6]) rot 2) xor (cvsix(password[31 for 6]) rot 4);

hashpa;
Pblknum _ blknum; 	! use hashed user name block;

while true do
  begin "block"
    useti(paschan,Pblknum);
    arryin(paschan,Pbuf[0],128);
    Pbufptr _ 0;
    while Pbufptr < 128-2 do
      begin "record"
        if Pbufhun = 0 then return(true)
        else Pbufptr _ Pbufptr + 2;
      end "record";
    if Pbufhun = 0 then
      begin "overflow block"
        svblknum _ pas!overflo;
	Pbufhun _ svblknum;
	ntr!pass;  ! rewrite with overflow pointer;
	Pblknum _ svblknum;   ! advance to overflow block;
	lookup(paschan,"(SYS)PAS.SYS",eof);
	arrclr(Pbuf);
      end "overflow block"
    else Pblknum _ rh(Pbufhun);
  end "block";
return(false);
end "find Phole";
!  this is a very simple verification of user input to a prompt called
   mostly from "new" or "add". it will print an error message and return
   FALSE if necessary. the two globals pswd and vergan are for verifying
   correct entering of the passwrod twice, and to check for uniqueness of the ppn.;



	! globals for this procedure only;
string pswd;
string vergan;

boolean procedure verify(integer chkit; string info);
begin "verify"
string char;
integer count,len;

char_0;
len_length(info);
if len = 0 then
  begin "null error"
    print(crlf, "all prompts must be supplied information.",crlf);
    return(false);
  end "null error";
case chkit of
begin "do one"
  [0] begin "verify username"
	if fnd!name(info) then
	  begin "duplicate error"
	    print(crlf,info, " already in use. pick another.",crlf);
	    return(false);
	  end "duplicate error";
	for count _ 1 step 1 until length(info) do
	  begin "isit alpha"
	    char_lop(info);
	    if char geq"0" or char leq"Z" then
              begin "isit numeric"
                if char > "9" and char <"A" then
                  begin "error"
                    print(crlf,"username must be alphanumerics only.",crlf);
                    return(false);
                  end "error";
              end "isit numeric"
                else begin "another error"
                       print(crlf, "username must be alphanumeric only.",crlf);
                       return(false);
                     end "another error";
	  end "isit alpha";
	if len < 2 or len > 12 then
	  begin "length error"
	    print(crlf, "username must be at least two characters and not more than twelve.",crlf);
	    return(false);
	  end "length error";
	return(true);
      end "verify username";
  [1] begin "verify gan"
	vergan _ info;
	for count_1 step 1 until length(info) do
	  begin "isit digit"
	    char_lop(info);
	    if char < "0" or char > "7" then
	      begin "error"
	        print(crlf, "gan must be an octal integer.",crlf);
	        return(false);
	      end "error";
	    if len > 6 then
	      begin "length error"
	        print(crlf,"gan must be not more than 6  digits",crlf);
	        return(false);
	      end "length error";
	  end "isit digit";
	return(true);
      end "verify gan";
  [2] begin "verify uun"
	if fnd!ppn((cvo(vergan) lsh 18) + cvo(info))then
	  begin "duplicate error"
	    print(crlf,info," already in use. pick another.",crlf);
	    return(false);
	  end "duplicate error";
	for count _ 1 step 1 until length(info) do
	  begin "isit digit"
	    char _ lop(info);
	    if char < "0" or char > "7" then
	      begin "error"
	        print(crlf, "uun must be an octal integer.",crlf);
	        return(false);
	      end "error";
	  end "isit digit";
	if len > 6 then
	  begin "length error"
	    print(crlf,"uun must be not more than six digits long.", crlf);
	    return(false);
	  end "length error";
	return(true);
      end "verify uun";
   [3] begin "verify district"
	if cvd(info) > 255 then
          begin "too big"
            print(crlf,"district number may not be larger than 255.",crlf);
            return(false);
          end "too big";
	for count _ 1 step 1 until length(info) do
	  begin "isit digit"
	    char _ lop(info);
	    if char <"0" or char > "9" then
	      begin "error"
	        print(crlf,"district must be an integer.",crlf);
	        return(false);
	      end "error";
	  end "isit digit";
	return(true);
       end "verify district";
[4][5][6][7][8][12][14][15]begin "verify y/n"
	if info = "Y" or info = "N" then return(true)
	else
	  begin "error"
	    print(crlf,"answer yes or no",crlf);
	    return(false);
	  end "error";
	end "verify y/n";
  [9][10] begin "verify quota"
	for count _ 1 step 1 until length(info) do
	  begin "isit digit"
	    char _ lop(info);
	    if char <"0" or char > "9" then
	      begin "error"
	        print(crlf,"quota must be an integer.",crlf);
	        return(false);
	      end "error";
	  end "isit digit";
	return(true);
      end "verify quota";
  [11] begin "verify disconnect"
	integer i;
	for i _ 0 step 1 until 3 do
	  begin "isit one"
	    if equ(info,discon[i][1 for length(info)]) then
	      return(true);
	  end "isit one";
	print(crlf, info," is an incorrect disconnect action.",crlf);
	return(false);
	
      end "verify disconnect";
  [13] begin "verify mode"
	integer i;
	for i _ 0 step 1 until 3 do
	  begin "isit one"
	    if equ(info,mode[i][1 for length(info)]) then
	      return(true);
	  end "isit one";
	print(crlf, info," is an incorrect mode.",crlf);
	return(false);
      end "verify mode";
  [16] begin "verify zone"
	integer i;
	for i _ 0 step 1 until 27 do
	  begin "isit one"
	    if equ(info,zone[i][1 for length(info)]) then
	      return (true);
	  end "isit one";
	print(crlf,info," is an incorrect zone.",crlf);
	return(false);
      end "verify zone";
  [17] begin "verify first password"
       pswd _ info;
       if len <7 or len > 36 then
         begin "length error"
           print(crlf,"password must be between seven and thirty six characters in length.",crlf);
           return(false);
         end "length error";
       return(true);
       end "verify first password";
  [18] begin "verify second typing of password"
       if equ(pswd,info) then return(true)
       else
         begin "error"
           print(crlf,"passwords do not match.",crlf);
           return(false);
         end "error";
       end "verify second typing of password"
end "do one";
end "verify";
!  this procedure takes an array of information and converts the strings
   to their appropriate integer representation. this procedure also
   does the calculation for determining the size of the entry in words.;

procedure get!ready(string array info!ready);
begin "get ready"
integer i, j, k;

for i _ 4 step 1 until 8, 12, 14, 15 do
begin "y/n"
  if equ(info!ready[i],"YES"[1 for length(info!ready[i])])
    then info!ready[i] _ 1
   else info!ready[i] _ 0;
end "y/n";


for j _ 0 step 1 until 3 do
begin
  if equ(info!ready[13],mode[j][1 for length(info!ready[13])])
    then info!ready[13] _ j;
  if equ(info!ready[11],discon[j][1 for length(info!ready[11])])
    then info!ready[11] _ j;
end;
for k _ 0 step 1 until 27 do
begin
if equ(info!ready[16],zone[k][1 for length(info!ready[16])])
  then info!ready[16] _ k;
end;

if tru and init then siz_12
else if tru and not init then siz_9
else if not tru and init then siz_11
else if not tru and not init then siz _ 8;

if fnd!Lhole(info!ready[0]) then 
  begin
    if fnd!Dhole(info!ready[1],info!ready[2]) then 
      begin
        if fnd!Phole(info!ready[17]) then 
           begin
             wrt!lud(info!ready);
             wrt!dul(info!ready[0],info!ready[1],info!ready[2]);
             wrt!pass;
           end
        else print("no room in password file");
      end
    else print("DUL ain't got room either");
  end
else print("no room at the inn.");
end "get ready";
!  this procedure converts the bufferd information about an entry into string
   form for printing a user's LUD entry.;

procedure list!ready(string uname);
begin "list ready"

integer i, j, k;
string array info!list[0:16];
  define
  	bufstr = {buf[bufptr+(buf!siz-3)]},
  	bufqin = {buf[bufptr+(buf!siz-2)]},
        bufqot = {buf[bufptr +( buf!siz-1)]};
  define
  	str!byt = {point(36,bufstr,35)},
  	qin!byt = {point(36,bufqin,35)},
  	qot!byt = {point(36,bufqot,35)};
  
  info!list[0]_uname;
  info!list[1]_cvos(ldb(gan!byt));
  info!list[2]_cvos(ldb(uun!byt));
  info!list[3]_cvs(ldb(dist!byt));
  info!list[4]_ldb(tym!byt);
  info!list[5]_ldb(bill!byt);
  info!list[6]_ldb(accs!byt);
  info!list[7]_ldb(gfd!byt);
  info!list[8]_ldb(rcm!byt);
  info!list[9]_cvs(ldb(qin!byt));
  info!list[10]_cvs(ldb(qot!byt));
  info!list[11]_ldb(discc!byt);
  info!list[12]_ldb(rub!byt);
  info!list[13]_ldb(mode!byt);
  info!list[14]_ldb(orid!byt);
  info!list[15]_ldb(day!byt);
  info!list[16]_ldb(zon!byt);

  for j _ 4 step 1 until 8, 12, 14, 15 do begin
    if info!list[j]=1 then info!list[j]_"YES"
    else info!list[j]_"NO";
    end;
  for k _0 step 1 until 3 do begin
    if info!list[13]=k then info!list[13]_mode[k];
    if info!list[11]=k then info!list[11]_discon[k];
  end;
  for i _ 1 step 1 until 27 do
  begin
    if info!list[16] = i then info!list[16] _ zone[i];
    end;
  close(ludchan);
  format(info!list);
  end "list ready";
!  this procedure checks to see if the user logged in has supervisor status;


boolean procedure is!super;
begin "check super"
integer supppn;
string super;

supppn _ calli((-1 lsh 18) lor -'23, '41); ! this CALLI reads the ppn of the user loged in;

if fnd!ppn(supppn) then begin "dul lookup"
  super _ (cv6str(ldb(lun!byt))&cv6str(ldb(run!byt)));
  if fnd!name(super) then begin "lud lookup"
    if ldb(accs!byt) = 1 then 
      begin "true"
        close(dulchan);
        close(ludchan);
        return(true);
      end "true"
    else begin "false"
           close(ludchan);
           close(dulchan);
           return(false);
         end "false";
    end "lud lookup"
    else close(ludchan);
    end "dul lookup"
    else close(dulchan);
  return(false);
end "check super";













!  end of utilities.  beginning of command procedures.;
!  when completed this procedure calls get!ready with the whole array;

procedure new!acc;
begin "new account"
string array info[0:18];
integer i;
string answer;
label startloop, tryagain;

tryagain:    ! loop for the case that the user decides the entry is not correct;
for i_0 step 1 until 18 do
  begin "prompt"
  startloop:   ! loop for the case where a response is inappropriate, or a question mark was typed;
    prompt(i);
    if i = 17 or I = 18 then auxcli(-1, '200, '32); ! turn off echo;
    ttyup(true); info[i]_strip( inchwl ); ttyup(false);
    if equ(info[i],"?") then
      begin "help"
        prmsg(i);
        print(crlf);
        goto startloop;
      end "help";
    if not verify(i,info[i]) then 
      begin
        if i = 18 then i _ 17;
        goto startloop;
      end;
    if i = 17 or i = 18 then auxcli(-1, 0, '32); ! turn on echo; 
  end "prompt";
print(crlf,"YOU HAVE ENTERED: ");
format(info);

outstr("ALL ENTRIES CORRECT? ");

ttyup(true); answer_strip( inchwl ); ttyup(false);
if equ(answer,"YES"[1 for length(answer)]) then get!ready(info)
  else begin
    answer_null;
    goto tryagain;
    end;

end "new account";
!  this procedure is basically the same as "new" except the info for prompts 12-16
   are taken from the supervisor entry;


procedure add!user;
begin "add user"
string array info[0:18];
integer i, supppn;
string answer, super;
label startloop, tryagain;

tryagain:
for i_0 step 1 until 18 do
  begin "prompt"
  startloop:
    if i < 12 or i >16 then begin
    prompt(i);
    if i = 17 or I = 18 then auxcli(-1, '200, '32);
    ttyup(true); info[i]_strip( inchwl ); ttyup(false);
    if equ(info[i],"?") then
      begin "help"
        prmsg(i);
        print(crlf);
        goto startloop;
      end "help";
    if not verify(i,info[i]) then 
      begin
        if i = 18 then i _ 17;
        goto startloop;
      end;
    end;
    if i = 17 or i = 18 then auxcli(-1, 0, '32); 
  end "prompt";
supppn _ calli((-1 lsh 18) lor -'23, '41);

if fnd!ppn(supppn) then 
  super _ (cv6str(ldb(lun!byt))&cv6str(ldb(run!byt)))
else close(dulchan);
if fnd!name(super) then 
  begin "lud lookup"
    info[12] _ ldb(rub!byt);
    info[13] _ ldb(mode!byt);
    info[14] _ ldb(orid!byt);
    info[15] _ ldb(day!byt);
    info[16] _ ldb(zon!byt);
    close(ludchan);
  end "lud lookup"
else close(ludchan);
begin "set default"
  integer j,k,l;
    for j _ 12 step 2 until 14, 15 do
    begin
     if info[j]=1 then info[j]_"YES"
       else info[j]_"NO";
    end;
  for k _0 step 1 until 3 do begin
    if info[13]=k then info[13]_mode[k];
  end;
  for l _ 1 step 1 until 27 do
  begin
    if info[16] = l then info[16] _ zone[l];
    end;
end "set default";

print(crlf,"YOU HAVE ENTERED: ");
format(info);

outstr("ALL ENTRIES CORRECT? ");

ttyup(true); answer_strip( inchwl ); ttyup(false);
if equ(answer,"YES"[1 for length(answer)]) then get!ready(info)
  else begin
    answer_null;
    goto tryagain;
    end;
end "add user";
!  this procedure allows a supervisor to change certain bits in a
   users LUD entry;


procedure set!bit;
begin "set bit"
string array ans[1:8];
string response, user;
integer l, i, endlist, num, answer;

ans[1]_"OVERRIDE";
ans[2]_"RCM";
ans[3]_"RUB";
ans[4]_"GFD";
ans[5]_"SUPERVISOR";
ans[6]_"BILLABLE";
ans[7]_"?";

endlist_7;
num_0;

outstr("user name = ");
ttyup(true); user _ strip( inchwl ); ttyup(false);
if fnd!name(user) then 
  begin "change"
    
    outstr("OVERRIDE,RCM,RUB,GFD,SUPERVISOR, OR BILLABLE? ");
    ttyup(true);response_strip( inchwl );ttyup(false);
    l_length(response);
    
    for i_1 step 1 until endlist do
      begin "get one"
        if equ(response,ans[i][1 for l]) then
          begin
          num_num+1;
          answer_i;
          end;
      end "get one";
    
    if num=1 then case answer of
      begin "do one"
      [1]   begin "override"
            prompt(14);
            ttyup(true); response_strip( inchwl ); ttyup(false);
            if equ(response,"YES"[1 for length(response)])
              then response _ 1
              else response _ 0;
            dpb(response,orid!byt);
            ntr!lud;
            end "override";
      [2]   begin "rcm"
            prompt(8);
            ttyup(true); response_strip( inchwl ); ttyup(false);
            if equ(response,"YES"[1 for length(response)])
              then response _ 1
              else response _ 0;
            dpb(response,rcm!byt);
            ntr!lud;
            end "rcm";
      [3]   begin "rub"
	    prompt(12);
	    ttyup(true); response_strip( inchwl ); ttyup(false);
	    if equ(response,"YES"[1 for length(response)])
	      then response _ 1
	      else response _ 0;
	    dpb(response,rub!byt);
	    ntr!lud;
	    end "rub";
      [4]   begin "gfd"
	    prompt(7);
	    ttyup(true); response_strip( inchwl ); ttyup(false);
	    if equ(response,"YES"[1 for length(response)])
	      then response _ 1
	      else response _ 0;
	    dpb(response,gfd!byt);
            ntr!lud;
	    end "gfd";
      [5]   begin "supervisor"
	    prompt(6);
	    ttyup(true); response_strip( inchwl ); ttyup(false);
	    if equ(response,"YES"[1 for length(response)])
	      then response _ 1
	      else response _ 0;
	    dpb(response,accs!byt);
            ntr!lud;
            end "supervisor";
      [6]   begin "billable"
	    prompt(5);
	    ttyup(true); response_strip( inchwl ); ttyup(false);
	    if equ(response,"YES"[1 for length(response)])
	      then response _ 1
	      else response _ 0;
	    dpb(response,bill!byt);
	    ntr!lud;
	    end "billable";
      [7] help!msg(5)
      end "do one"
      else help!msg(5);
    end "change"
else print(crlf,"not a valid user");
end "set bit";
!  this procedure will list all of the users LUD entries in a given account;

procedure list!accu;
begin "list acc users"
string username;

username _ (cv6str(ldb(lun!byt))&cv6str(ldb(run!byt)));
if fnd!name(username) then list!ready(username) 
else print(crlf, username, " not found");
end "list acc users";


!  this procedure will list the NAME and UUN of all users in an account;


procedure list!accnb(boolean listnoufd);
begin "list acc names"
string  lun, run, uun, gan, fstatus;
integer files;

lun _ cvxstr(ldb(lun!byt));
run _ cvxstr(ldb(run!byt));
setformat(6,7);
uun _ cvos(ldb(duun!byt));
gan _ cvos(ldb(dgan!byt));
fstatus _ cvs(files _ UFD!FILES(dbufppn));
setformat(0,7);
if not files<0 then fstatus _ " "&fstatus&" files. "
else if RD!lic>1 then fstatus _ "      No UFD "
     else fstatus _ " Can't read UFD. ";
if listnoufd or (RD!lic>1 and not files<0) then
	print(lun,run," ",gan,",,",uun,fstatus,nl);
end "list acc names";

procedure list!accn;
begin
list!accnb(true);
end;

procedure list!accnwufds;
begin
list!accnb(false);
end;
!  this procedure will list one user's LUD entry;

simple boolean procedure list!user;
begin "list user"
string user!name;
boolean rptflg;

prompt(0);
ttyup(true); user!name_strip( inchwl ); ttyup(false);
rptflg _ false;
if length(user!name)>0 then begin
	if fnd!name(user!name) then list!ready(user!name)
	else print("not found");
	rptflg _ true;
	end;
return (rptflg);
end "list user";


!  this procedure decides which list you want to see;

procedure list!what;
begin "list what"
string response, answer, gan;

outstr("Account or User? ");
ttyup(true);response_strip( inchwl );ttyup(false);

if equ(response,"ACCOUNT"[1 for length(response)]) then
  begin "prompt"
    print("Type global account number (GAN): ");
    ttyup(true); gan _ strip( inchwl ); ttyup(false);
    print("Do you need more information than just NAMES and UUNs? ");
    ttyup(true); answer _ strip( inchwl ); ttyup(false);
    if equ(answer,"NO"[1 for length(answer)]) then
    begin
	print("Do you need those with no UFDs? ");
	ttyup(true); answer _ strip( inchwl ); ttyup(false);
	if equ(answer,"NO"[1 for length(answer)]) then fnd!gan(cvo(gan), list!accnwufds)
	else fnd!gan(cvo(gan), list!accn);
    end
    else fnd!gan(cvo(gan),list!accu);
  end "prompt"
else if equ(response,"USER"[1 for length(response)]) then
	while list!user do print(crlf)
else help!msg(6);

end "list what";


! this procedure does the actual deleting of entries in all three files  
  LUD, DUL and PAS when an account is cancelled;

procedure go!ahead;
begin "go ahead"
string username,answer;
integer j,k,eof,files;
username _ (cv6str(ldb(lun!byt))&cv6str(ldb(run!byt)));
if fnd!name(username) then begin "try this"
files _ UFD!FILES(bufppn);

print(nl,"Cancelling ",username);
if (files=0 or files=-2) then answer _ "YES"
else begin "ask first"
	print(" and ",files," files.  Okay? ");
	ttyup(true); answer _ strip( inchwl ); ttyup(false);
end "ask first";

if equ(answer,"YES"[1 for length(answer)]) then begin "DEL YES"
files _ DEL!UFD(bufppn);
if not (files=-2 or files=0) then
 print(nl,files," files not deleted.  ",username," not canceled.")
else begin "UFD GONE"

if fnd!Pname then
  begin "del lentry"
    bufhun _ 0;
    ntr!lud;
    for j _ Dbufptr step 1 until 127-3 do
      begin "del dentry"
        Dbuf[j] _ Dbuf[j+3];
      end "del dentry";
    enter(dulchan,"(SYS)DUL.SYS",eof);
    useto(dulchan,Dblknum);
    arryout(dulchan,Dbuf[0],128);
    for k _ Pbufptr step 1 until 127-2-2 do
      begin "del pentry"
        Pbuf[k] _ Pbuf[k+2];
      end "del pentry";
    ntr!pass;
  end "del lentry"
else print(crlf,"files do not match, did not cancel.");

 end "UFD GONE";
 end "DEL YES";
 end "try this"
else print(crlf,"files do not match, did not cancel.");
end "go ahead";

!  this procedure prints out the names of the users in an account who
   would be deleted  before deleting them;

procedure can!acc;
begin "cancel account"
string lun, run, fstatus, answer;
integer files;

lun _ cv6str(ldb(lun!byt));
run _ cv6str(ldb(run!byt));
			! files _ UFD!FILES(DBUFPPN);
print(lun,run,nl);	! " ",cvs(files)," files ",crlf);
end "cancel account";
!  this procedure cancels just one username from all three files;

procedure can!user;
begin "cancel user"
string uname, answer;
integer j, k, gan, findg, files;

prompt(0);
ttyup(true); uname_strip( inchwl ); ttyup(false);
if not fnd!name(uname) then print("Can't find that user in the DUL",nl)
else begin "can uname"

files _ UFD!FILES(bufppn);
if not files>0 then print("Cancelling ",uname,"  okay? ")
else print("Cancelling ",uname," and ",files," files,  okay? ");
ttyup(true); answer_strip( inchwl ); ttyup(false);

if equ(answer,"YES"[1 for length(answer)]) then 
  begin "delete all" 
    files _ DEL!UFD(bufppn);
    if (not files=-2) and (not files=0) then 
	print(nl,files," files can't be deleted.  Aborting",nl)
      else begin "delete"
        if fnd!ppn(bufppn) then
          begin "check dul"
            if fnd!Pname then
            begin "del entry"
              for k _ Pbufptr step 1 until 127-2-2 do
                begin "del pentry"
                  Pbuf[k] _ Pbuf[k+2];
                end "del pentry";
              ntr!pass;
              close(paschan);
            end "del entry"
            else print("could not find user in PAS");
            bufhun _ 0;
            ntr!lud;
            close(ludchan);
            for j _ Dbufptr step 1 until 127-3 do
              begin "del dentry"
                Dbuf[j] _ Dbuf[j+3];
              end "del dentry";
            ntr!dul;
            close(dulchan);
            print(crlf, uname, " deleted - no longer valid.");
          end "check dul"
        else print("could not find user in DUL");
  end "delete";
  end "delete all";
end "can uname";
end "cancel user";


!  this procedure is the prompter for which kind of cancel to
   implement;


procedure can!what;
begin
string response, gan, answer;

if WR!lic<2 or not JL!lic then print(nl,"Insufficient Licence.",nl)
else begin "can a or u"
outstr("Account or User? ");
ttyup(true);response_strip( inchwl );ttyup(false);

if equ(response,"ACCOUNT"[1 for length(response)])
  then begin "prompt"
    prompt(1);
    ttyup(true); gan _ strip( inchwl ); ttyup(false);
    print("Cancelling account ",gan,".  Okay? ");
!   fnd!gan(cvo(gan),can!acc);
ttyup(true); answer_strip( inchwl ); ttyup(false);

if equ(answer,"YES"[1 for length(answer)]) then fnd!gan(cvo(gan),go!ahead) 
else print("account not deleted");
    end "prompt"
else if equ(response,"USER"[1 for length(response)])
  then can!user
else help!msg(4);
end "can a or u";
end;
!  this procedure deletes the old password entry and puts in the new one;

procedure cha!pass;
begin "change password"
string uname, firstpass, secpass;
label rerun, startover;
integer k;

startover:
prompt(0);
ttyup(true); uname_strip( inchwl ); ttyup(false);
if fnd!name(uname) then 
  begin "password"
rerun:

prompt(17);
auxcli(-1,'200,'32);
firstpass_strip( inchwl );
if length(firstpass) <6 or length(firstpass) > 36 then
  begin "length error"
    print(crlf,"password must be between 7 and 36 characters in length.",crlf);
    goto rerun;
  end "length error";
print(crlf);
prompt(18);
secpass_strip( inchwl );
auxcli(-1,0,'32);
if equ(firstpass,secpass) then
  begin "set password"
  if fnd!Pname then begin
              for k _ Pbufptr step 1 until 127-2-2 do
                begin "del pentry"
                  Pbuf[k] _ Pbuf[k+2];
                end "del pentry";
            ntr!pass;
          end;
    if fnd!Phole(firstpass) then wrt!pass
      else print("no room in password file");
  end "set password"
else begin "rerun"
  print("passwords do not match. try again.",crlf);
  goto rerun;
end "rerun";
end "password"
else
  begin "startover"
    print(crlf,"not a valid username",crlf);
    goto startover;
  end "startover";
end "change password";
!  this procedure changes a user's EXEC MODE;


procedure cha!mode;
begin "change mode"
string uname, newmod;
integer i;

prompt(0);
ttyup(true); uname_strip( inchwl ); ttyup(false);
prompt(13);
ttyup(true); newmod_strip( inchwl ); ttyup(false);

if verify(13,newmod) then
  begin "search"
    if fnd!name(uname) then
      begin "make change"
        for i _ 0 step 1 until 3 do
          begin "which mode"
            if equ(newmod,mode[i][1 for length(newmod)])
              then newmod_i;
          end "which mode";
        dpb(newmod,mode!byt);
        ntr!lud;
      end "make change"
    else
      begin "error"
        close(ludchan);
        print(crlf,uname," not found",crlf);
      end "error";
  end "search";
end "change mode";
!  this procedure changes a user's QUOTA;


procedure cha!quota;
begin "change quota"
string uname,quotain, quotaout;

define
	siz = {bufjnk land '177};
define
	bufqin = {buf[bufptr+(siz-2)]},
        bufqot = {buf[bufptr + (siz-1)]};

define
	qin!byt = {point(36,bufqin,35)},
	qot!byt = {point(36,bufqot,35)};

prompt(0);
ttyup(true); uname_strip( inchwl ); ttyup(false);
prompt(9);
quotain_strip( inchwl );
prompt(10);
quotaout_strip( inchwl );

if verify(9,quotain) and verify(10,quotaout) then
  begin "search"
    if fnd!name(uname) then
      begin "make change"
        dpb(cvd(quotain),qin!byt);
        dpb(cvd(quotaout),qot!byt);
        ntr!lud;
      end "make change"
    else
      begin "error"
        close(ludchan);
        print(crlf,uname," not found",crlf);
      end "error";
  end "search";
end "change quota";
!  this procedure calls a specified change procedure;


procedure change!what;
begin "change what"
string array ans[1:5];
string response;
integer l, i, endlist, num, answer;

ans[1]_"PASSWORD";
ans[2]_"QUOTA";
ans[3]_"MODE";
ans[4]_"?";

endlist_4;
num_0;
outstr("PASSWORD, QUOTA, MODE? ");
ttyup(true);response_strip( inchwl );ttyup(false);
l_length(response);

for i_1 step 1 until endlist do
begin "pick one"
  if equ(response,ans[i][1 for l]) then
    begin
    num_num+1;
    answer_i;
    end;
end "pick one";

if num=1 then case answer of
  begin "which one"
  [1] cha!pass;
  [2] cha!quota;
  [3] cha!mode;
  [4] help!msg(7)
  end "which one"
else help!msg(7);
end "change what";
!  this procedure checks the ppn for uniqueness;

simple boolean procedure chec!ppn;
begin "check ppn"
string ppn,gan,uun;
integer files;
boolean repflg;

clrbuf;			! clear tty input;
print(nl,"Type GAN,UUN ");
gan _ nxtword;

repflg _ false;
if length(gan)>0 then begin "got gan"
gan _ cvos(cvo(gan));
uun _ cvos(cvo(nxtword));

ppn _ cvos( (cvo(gan) lsh 18) + ('777777 land cvo(uun)) );
files _ UFD!FILES(cvo(ppn));

if fnd!ppn(cvo(ppn)) then begin "found ppn"
	print(crlf,"PPN ",gan,",,",uun," is already being used by ",
		cv6str(dbuflun),cv6str(dbufrun));
	if not files<0 then print(" and owns ",FILES," files.",nl)
	else if RD!lic>1 then print(" but has no UFD.",nl)
	     else print(".  Can't read UFD. ",nl);
	end "found ppn"
   else begin
     print(nl,"PPN ",gan,",,",uun," ");
     if files=-2 then print("is available for use.",nl)
     else print("is not in DUL but has a UFD with ",files," files.",nl);
   end;	
close (dulchan);
repflg _ true;
end "got gan";
return(repflg);
end "check ppn";

!  this procedure checks the username for uniqueness;

boolean procedure chec!name;
begin "check name"
string uname, fstatus;
boolean	rptflg;
integer files;

rptflg _ true;
outstr(nl&"USER NAME = ");
ttyup(true); uname_strip( inchwl ); ttyup(false);

  if length(uname)>0 then
	if fnd!name(uname) then begin "exists"
	     files _ UFD!FILES(bufppn);
	     if not files<0 then fstatus _ "  UFD has "&cvs(files)&" files."
	     else if RD!lic>1 then fstatus _ "  No UFD."
		  else fstatus _ "  Can't read UFD.";
	     print(crlf,uname," is already in use.  PPN = ",
		cvos(lh(bufppn)),",,",cvos(rh(bufppn)),fstatus,nl);
	  end "exists"
	else print(crlf,uname," is available for use.",crlf)
  else rptflg _ false;
close(ludchan);
return(rptflg);
end "check name";


!  this procedure calls the check procedure desired;

procedure chec!what;
begin "check what"
string response;
boolean rptflg;

rptflg _ true;
while rptflg do rptflg _ chec!name;
rptflg _ true;
while rptflg do rptflg _ chec!ppn;

end "check what";

! The following are outer block declarations;
integer ufdx,ufd0,ufd1,ufdfiles;
define maxgans = 200;
integer array gandat[1:3, 0:maxgans];
! end outer block declarations for dul!stats;


procedure dul!stats;
begin "dul!stats"
integer files, gan, j;

gan _ lh(dbufppn);
j _ 0;
gandat[1,maxgans] _ 0;
while not (gandat[1,j]=0 or gandat[1,j]=gan) do j_j+1;
gandat[1,j] _ gan;
gandat[2,j] _ gandat[2,j] + 1;

files _ UFD!FILES(dbufppn);

if files<0 then ufdx _ ufdx + 1
else begin
	gandat[3,j] _ gandat[3,j] + files;
	ufdfiles _ ufdfiles + files;
	if files=0 then ufd0 _ ufd0 + 1 else ufd1 _ ufd1 + 1;
end;
end "dul!stats";

! NULL!UFD lists all empty UFDs and deletes them if user agrees;

procedure NULL!UFD;
begin "null!ufd"
integer files;
string ppn, uname, answer;

files _ UFD!FILES(dbufppn);
if files=0 then begin "ask to kill"
ppn _ cvos(lh(dbufppn))&",,"&cvos(rh(dbufppn));
uname _ cv6str(dbuflun)&cv6str(dbufrun);
print(nl,"Deleteing empty ",ppn,".UFD for user ",uname,".  Okay? ");
ttyup(true); answer_strip( inchwl ); ttyup(false);
if length(answer)<1 then answer _ "NO";
if equ(answer,"YES"[1 for length(answer)]) then DEL!UFD(dbufppn)
else print("Not Deleted.",nl);
end "ask to kill";
end "null!ufd";

!	this is my current test procedure;

procedure test!proc;
begin "test proc"
string s;

print(nl,"Welcome to TEST PROCEDURES",nl);

print(nl,"Do you want all the user statistics? ");
clrbuf; 
s _ nxtword;
if equ("Y",lop(s)) then
begin "USER STATS"
integer i,j;
string gan;
PRINT (nl,"Collecting User statistics.  This may take a few minutes.",nl);
ufdx _ 0; ufd0 _ 0; ufd1 _ 0; ufdfiles _ 0;
for i_1 upto 3 do for j_0 upto maxgans do gandat[i,j] _ 0;
fnd!all(0,dul!stats);
print(nl,ufdx+ufd0+ufd1," total users, ",ufdfiles," total files.");
print(nl,ufd1," users own files, ",ufd0," have empty UFDs.");
print(nl,ufdx," users have no UFD.");
print(nl,nl,nl,"   GAN   USERS  FILES");
print      (nl," ------ ------ ------");
setformat(7,7);
j _ 0;
while (not gandat[1,j]=0) and (j < maxgans+1) do begin
  if gandat[3,j]>0
    then print(nl,cvos(gandat[1,j]),cvs(gandat[2,j]),cvs(gandat[3,j]));
  j _ j + 1;
end;
j _ 0;
while (not gandat[1,j]=0) and (j < maxgans+1) do begin
  if gandat[3,j]=0 then print(nl,cvos(gandat[1,j]),cvs(gandat[2,j]));
  j _ j + 1;
end;
setformat(0,7);
if j>maxgans then print(nl,nl,"Overflow at ",cvs(j)," GANs.",nl)
else print(nl,nl,"Number of GANs = ",cvs(j),nl);
end "USER STATS";

print(nl,"Do you want to delete all UFDs which don't have any files? ");
clrbuf; 
s _ nxtword;
if equ("Y",lop(s)) then
begin "del empty UFDs"
print(nl,"Scanning for empty UFDs.  This may take a few minutes.",nl);
fnd!all(0,NULL!UFD);
end "del empty UFDs";
 
print(nl,"Do you need to delete any UFDs which don't have a DUL entry? ");
clrbuf; 
s _ nxtword;
if equ("Y",lop(s)) then
BEGIN "BASIC LOOKUP"
integer PPN, files;

clrbuf;					! clear the input buffer;
print(nl,"Type GAN,UUN of UFD to be canceled > ");
PPN _ xwd(cvo(nxtword),cvo(nxtword));

files _ DEL!UFD(ppn);
if files>0 then PRINT (nl,files," files not deleted",nl)
else begin
	if files=-1 then print (nl,"Can't OPEN a Channel",nl);
	if files=-2 then print (nl,"UFD not found",nl);
	if files=-3 then print (nl,"UFD delete error",nl);
	if files=0 then print (nl,"UFD deleted",nl);
     end;
END "BASIC LOOKUP";
end "test proc";

!  this procedure is the command dispatcher. it keeps looping through
   here until the user types QUIT;


procedure com!dis;
begin "command dispatcher"

string command;
integer l, i, endlist, no!of!com, com;
string array com!list[1:22];

com!list[1]_"NEW";
com!list[2]_"ADD";
com!list[3]_"HELP";
com!list[4]_"SET";
com!list[5]_"QUIT";
com!list[6]_"LIST";
com!list[7]_"CANCEL";
com!list[8]_"CHANGE";
com!list[9]_"CHECK";
com!list[10]_"DOC";
com!list[11]_"/?NEW";
com!list[12]_"/?ADD";
com!list[13]_"?";
com!list[14]_"/?SET";
com!list[15]_"/?QUIT";
com!list[16]_"/?LIST";
com!list[17]_"/?CANCEL";
com!list[18]_"/?CHANGE";
com!list[19]_"/?CHECK";
com!list[20]_"\TEST";	! undocumented functions;
endlist_20;



while true do
begin "get one"
  clrbuf;	! CLEAR TTY INPUT BUFFER AT COMMAND LEVEL;
  outstr(nl&"*");
  ttyup(true); command_strip( inchwl ); ttyup(false);

  no!of!com_0;
  l_length(command);
  for i_1 step 1 until endlist do
  begin "pick one"
    if equ(command,com!list[i][1 for l]) then
      begin "command"
      no!of!com_no!of!com+1;
      com_i;
      end "command";
  end "pick one";
  if no!of!com=1 then case com of 
    begin "which one"
    [0] done "get one";
    [1] new!acc;
    [2] add!user;
    [3] help!msg(8);
    [4] set!bit;
    [5] done "get one";
    [6] list!what;
    [7] can!what;
    [8] change!what;
    [9] chec!what;
    [10] type!help;
    [11] help!msg(1);
    [12] help!msg(3);
    [13] help!msg(8);
    [14] help!msg(5);
    [15] help!msg(0);
    [16] help!msg(6);
    [17] help!msg(4);
    [18] help!msg(7);
    [19] help!msg(2);
    [20] test!proc
    end "which one";
  if l>0 then begin
   if no!of!com>1 then print("AMBIQUOUS COMMAND");
   if no!of!com=0 then print("UNRECOGNIZED COMMAND");
  end;
end "get one";

end "command dispatcher";
! global arrays;
mode[0] _ "PDP";
mode[1] _ "XEXEC";
mode[2] _ "JAPAN";
mode[3] _ "SUDS";

discon[0] _ "LOGOUT";
discon[1] _ "DETACH";
discon[2] _ "CONTINUE";
discon[3] _ "DETACH, LOGOUT AFTER 15 MINUTES";

zone[0]_"GMT";
zone[6]_"HAWAII AND ALASKA";
zone[8]_ "PACIFIC";
zone[9]_"MOUNTAIN";
zone[10]_"CENTRAL";
zone[11]_"EASTERN";
zone[12]_"ATLANTIC";
zone[16]_"LONDON";
zone[17]_"WESTERN EUROPE";
zone[25]_"TOKYO";
zone[26]_"BRISBANE";

ifc compiler!switch("B") thenc usererr(0,0,0,"b"); endc

! open the dul,lud, and pas channels;

open(dulchan_getchan,"dsk", '17,0,0,0,0,eof);
open(ludchan_getchan,"dsk", '17,0,0,0,0,eof);
open(paschan_getchan,"dsk", '17,0,0,0,0,eof);

 !   this call starts the program;
if is!super then 
  begin
	! last update (v1.0) by	GLYONS 11-6-80 renamed to LVALID v1.0];
	print(nl,"LVALID - LOCAL USER VALIDATION PROGRAM v1.0",nl);
	com!dis;
  end
else print(crlf,"you're not a supervisor and may not run this program.");

end "outerblock";
  v@5