;+
;.title AUXLIB - Auxiliary Circuit FORTRAN Interface
;.LITERAL
;
;       NAME:   AUXLIB.MAC
;
;       AUTHOR: SOFTWARE PRODUCT SUPPORT
;
;       PURPOSE:THESE ROUTINES PROVIDE FOR THE INITIALIZATION
;               OF AUXILIARY CIRCUITS,READING FROM THE AUXILIARY CIRCUIT
;               AND WRITING TO THE AUXILIARY CIRCUIT.
;
;       USE:
;
;              TO ACCESS THESE ROUTINES, ADD TO YOUR LOAD
;              STRING (UPL)AUXLIB
;
;       RELEASE: 14.0 07-FEBRUARY-1980
;
;       CHANGE LOG:
;
;               5/25/79 - BUFSIZ INCREASED TO 10000 FROM 4000
;
;               7/10/79 - MODIFIED CIRZAP TO DISABLE CIRCUIT ZAP INTERRUPT.
;                         THIS ELIMINATES A PDL OVERFLOW PROBLEM WHEN A
;                         USER TEARS DOWN 20 OR MORE CIRCUITS.  CIRZAP WAS
;                         NOT EXECUTING THE POPJ 17, THUS LEAVING ITS CALL
;                         ON THE STACK.  THIS COULD HAVE CAUSED SEVERE PROBLEMS
;                         IN F10.  A CHANGE WAS ALSO MADE IN AUXINI TO ELIMINATE
;                         RE-INITIALIZATION OF THE INTERRUPT SYSTEM ON 
;                         RECURSIVE CALLS TO AUXINI.  THIS WAS DONE IN ORDER
;                         TO PRESERVE INTERRUPT ESTABLISHED BY
;                         THE TIMOUT ROUTINE.
;
;               8/7/79 -  MODIFIED AUXINI TO REINITIALIZE POINTERS AND
;                         INPUT BUFFER AREA ON RECURSIVE CALLS TO AUXINI
;
;               2/7/80 - ADDED THE ROUTINE ONINT DUE TO THE FACT THAT
;                        ONINT IN LIB40 WAS CLOBBERING THE INTERRUPT VECTORS.
;
;.END LITERAL
;-

        TITLE AUXLIB AUXILIARY CIRCUITS LIBRARY

        ENTRY AUXINI,AUXRED,AUXWRT,NOAXIN,QCHRIN,CIRZAP,TIMDEL,ONCZAP
        ENTRY TIMOUT,ONINT,OFFINT
        ;
        ;BEGIN SYMBOL DEFINITIONS
        ;

SIXNAM: BLOCK 2         ;SIXBIT USER NAME
ASCNAM: BLOCK 5         ;ASCII USER NAME
PTR1= 5                 ; WILL HOLD PTR5 
PTR2= 6                 ; WILL HOLD PTR6 
PTR3:   0               ;WORKING BYTE POINTER FOR LINE SCAN IN AUXWRT
PTR4:   POINT 7,,       ;BYTE POINTER TO REFERENCE CHARS TO SEND OVER AUX
                        ;CIRCUIT
PTR5:   POINT 6,SIXNAM, ;BYTE POINTER FOR SIXBIT USER NAME
PTR6:   POINT 7,ASCNAM, ;BYTE POINTER FOR ASCII USER NAME
PTR7:   0               ;BYTE POINTER FOR CHARACTER FOLLOWING CR IN AUXWRT
SPCMSK: 001004,,020100  ;PAD SPACES FOR CHAR RETURN TO CALLING PROGRAM
PORT:   0               ;STORE ACTIVE PORT NO.
BUFSIZ== 10000          ;BUFFER SIZE FOR AUX INPUT BUFFER
BUFSZ1=BUFSIZ-1         ;LAST WORD OF AUX INPUT BUFFER
AUXINP: BLOCK BUFSIZ    ;AUX INPUT BUFFER
AUXPTI: 0               ;BYTE POINTER TO PLACE CHAR INTO AUX INPUT BUFFER
AUXPTO: 0               ;BYTE POINTER TO REMOVE CHAR FROM AUX OUTPUT BUFFER
AC1SAV: 0               ;SAVE CONTENTS OF AC1 WHILE PROCESSING INTERRUPT
AC2SAV: 0               ;SAVE CONTENTS OF AC2 WHILE PROCESSING INTERRUPT
AC3SAV: 0               ;SAVE CONTENTS OF AC3 WHILE PROCESSING INTERRUPT
SAVCHR: 0               ;CHARACTER AFTER THE CARRIAGE RETURN
CHARIN: 0               ;COUNT OF CHARACTERS CURRENTLY IN AUX BUFFER AREA
INTTAB: 0               ;INTERRUPT TABLE CHANNEL 1 OLD PC
        CHZAP           ;AUX CIRCUIT ZAP GO TO CHZAP
        0               ;CHANNEL 2 OLD PC
        AXCHRI          ;GO TO AXCHRI UPON RECEIPT OF CHAR  AUX CIRCUIT
TIMER:  0               ;OLD PC WHEN A TIMOUT OCCURS (TIMOUT ENTRY)
        TIMINT          ; ADDRESS OF TIMOUT INTERRUPT HANDLER
TIMCHN==<.-INTTAB>/2    ; COMPUTE INTADR CHANNEL FOR TIMOUT
BREAKC: 0               ;OLD PC WHEN A BREAK CHAR RECEVIED FOR TIMOUT
        BRKINT          ;ADDRESS TO GO TO ON A BREAK CHAR
BRKCHN==<.-INTTAB>/2    ; COMPUTE CHANNEL FOR BREAK CHAR INTERRUPT
ESCCHR: 0               ;OLD PC WHEN AN ESCAPE CHARACTER RECEIVED FROM TERM
        ESCINT          ;ADDRESS TO GO TO ON AN ESCAPE CHARACTER
ESCCHN==<.-INTTAB>/2    ;COMPUTE CHANNEL FOR ESCAPE CHAR INTERRUPT
        RELOC   INTTAB  ;INSURE INTTAB IS 72 WORDS LONG.
        BLOCK   ^D72
ZAPPC:  0               ;STORE ADDRESS WHERE USER WISHES TO GO UPON CIRCUIT ZAP
TDELAY: ^D4000          ;TIME DELAY FOR CHARACTERS ECHOED ACROSS AUX CIRCUIT.
                        ;THIS IS THE DEFAULT NO. OF MILLISECONDS. USER
                        ;CHANGEALBE.
TCHRFL: 0               ;FLAG FOR TRAILING CHAR BETWEEN CR AND NULL TERMINATOR
INTFLG: 0               ;FLAG INDICATING INTADR TURNED ON
TIMJMP: 0               ;ADDRESS TO JUMP ON TIMOUT
.IABRK==2B8             ;RECEIPT OF BREAK CHARACTER CAUSE
.IATIM==4B17            ; TIMER INTERRUPT CAUSE
.IAESC==0B17            ; RECEIPT OF ESCAPE CHARACTER CAUSE.
TIMVAL: Z               ; STORAGE TO TIMOUT QUANTITY AND UNITS
INTJMP: 0               ;ADDRESS TO JUMP ON ESCAPE CHAR

;+
;.PG.S 3.LITERAL
;                              SUBROUTINE AUXINI
;
;       PURPOSE:THIS ROUTINE INITIALIZE THE AUXILIARY CIRCUIT
;               TO THE SPECIFIED SYSTEM AND RETURNS THE PORT NO.
;               FOR FUTURE READS AND WRITES.
;
;       CALLING SEQUENCE:
;
;               CALL AUXINI(ISYS,IPORT,IERR)
;
;       WHERE:
;
;               ISYS = THE SYSTEM TO BUILD A CIRCUIT TO
;               IPORT= THE PORT ADDRESS FOR THE CIRCUIT 
;               IERR = THE ERROR CODE FOR A FAILURE
;
;       ERROR-CODES
;
;               00 = NO ERROR, AUX CIRCUIT BUILT
;               01 = UNABLE TO GET JOB PRIVLEDGE WORD
;               02 = EXECJ USERS ARE NOT ALLOWED TO BUILD AUX CIRCUITS
;               03 = UNABLE TO GET USER USERNAME THRU GETTABS
;               04 = ERROR RETURNED BY SUPERVISOR. UNABLE TO BUILD CIRCUIT
;               05 = PROCESS ALREADY HAS 2 AUX CIRCUITS AND NO AC LICENSE
;               06 = ATTEMPT TO BUILD AUX CIRCUIT TO ANOTHER USER NAME
;               07 = NO ROOM IN THE MONITOR FOR ANY MORE AUX CIRCUITS
;               08 = THE SUPERVISOR DID NOT RESPOND TO THE ORIGINAL REQUEST
;               09 = THE SUPERVISOR DID NOT RESPOND TO THE LOGIN MESSAGE
;               10 = THE SUPERVISOR DID NOT SUPPLY A CIRCUIT
;               11 = THE SUPERVISOR GAVE AN ERROR RESPONSE TO THE ORIGINAL
;                    REQUEST
;               12 = UNABLE TO INITIATE THE SOFTWARE INTERRUPT SYSTEM
;               13 = UNABLE TO ESTABLISH SOFTWARE INTERRUPT CAUSE FOR A
;                    CIRCUIT ZAP(LOGOUT)
;               14 = UNABLE TO ESTABLISH SOFTWARE INTERRUPT CAUSE FOR A
;                    RECEIPT OF CHARACTER ON AUX CIRCUIT.
;               15 = UNABLE TO ENABLE SOFTWARE INTERRUPTS
;
;       NOTE:   EXECJ USERS MAY NOT USE THESE ROUTINES.
;.END LITERAL
;-
AUXINI: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE
                        ;NEXT INSTRUCTION.
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVE 1,[POINT 7,,]
        MOVEM 1,PTR4
        MOVE 1,[POINT 6,SIXNAM,]
        MOVEM 1,PTR5
        MOVE 1,[POINT 7,ASCNAM,]
        MOVEM 1,PTR6
        MOVEI 1,^D4000
        MOVEM 1,TDELAY
        MOVE 1,[AUXINP,,AUXINP+1] ; ZERO OUT AUXINP
        SETZM AUXINP
        BLT 1,AUXINP+BUFSZ1
        MOVE PTR1,PTR5  ; GET THE SIXBIT BYTE POINTER INTO A REGISTER
        MOVE PTR2,PTR6  ; GET THE ASCII BYTE POINTER INTO A REGISTER
        MOVE 0,[-1,,6]  ;SET UP AC0 TO DO GETTAB FOR JOB PRIVLEDGE WORD
        GETTAB 0,       ;ATTEMPT TO GET JOB PRIVLEDGE WORD
        JRST ERR1       ;ERROR RETURN GO TO ERR1
        LSH 0,-7        ;SHIFT THE BITS IA AC0 7 BITS RIGHT
        ANDI 0,3        ;AND THE CONTENTS OF AC0 WITH 3
        CAIN 0,2        ;SKIP THE NEXT INS IF THE CONTENTS OF AC0 ARE NOT 
                        ;EQUAL TO 2
        JRST ERR2       ;IF CONTENTS OF AC0 ARE 2, THIS USER IS AN EXECJ
                        ;USER, THEREFORE GO TO ERR2 AND BUILD NO CIRCUIT.

        MOVE 0,[-1,,-22];SET UP AC0 TO DO GETTAB FOR THE 1ST 6CHARS OF THE
                        ;CURRENT JOBS USERNAME IN 6BIT.
        GETTAB 0,       ;ATTEMPT TO GET 1 6CHAR OF USERNAME
        JRST ERR3       ;ERROR RETURN. GO TO ERR3
        MOVEM 0,SIXNAM  ;MOVE THE CONTENTS OF AC0 TO ADDRESS SIXNAM
        MOVE 0,[-1,,-21];SET UP AC0 TO DO GETTAB FOR THE 2ND 6CHARS OF THE
                        ;CURRENT JOBS USERNAME IN 6BIT
        GETTAB 0,       ;ATTEMPT TO GET 2ND 6CHARS OF USERNAME
        JRST ERR3       ;ERROR RETURN. GO TO ERR3
        MOVEM 0,SIXNAM+1;MOVE THE CONTENTS OF AC0 TO ADDRESS SIXNAM+1
        MOVEI 0,^D12    ;MOVE THE VALUE OF 12 TO AC0(12CHARS TO CONVERT TO
                        ;ASCII.
NAMLOOP:ILDB 1,PTR1     ;LOAD A CHAR ADDRESSED BY BYTE POINTER PTR1
                        ;(BYTE POINTER 1 POINTS TO SIXNAM) INTO AC1
        JUMPE 1,NAMEND  ;IF THE CONTENTS OF AC1 EQ A 0(NULL CHAR) THEN
                        ;JUMP TO ADDRESS NAMEND.
        ADDI 1," "      ;ADD THE VALUE OF A SPACE TO THE CONTENTS OF AC1 IN
                        ;ORDER TO CONVERT THE SIXBIT VALUE IN AC1 TO ASCII.
        IDPB 1,PTR2     ;DEPOSIT THE CONTENTS OF AC1 INTO THE ADDRESS 
                        ;REFERENCED BY BYTE POINTER PTR2(BYTE POINTER PTR2
                        ;POINTS TO ASCNAM).
        SOJG 0,NAMLOOP  ;SUBTRACT ONE FROM AC0 AND IF THE CONTENTS OF AC0
                        ;ARE GREATER THAN 0, GO TO NAMLOOP
NAMEND: MOVEI 1,":"     ;SIXBIT CONVERSION COMPLETED. MOVE A : INTO AC1.
        IDPB 1,PTR2     ;DEPOSIT THE COLON IN AC1 BEHIND THE USERNAME
                        ;STRING IN ASCNAM.
        MOVE 0,@(16)    ;MOVE THE SYSTEM NO FROM THE CALLING ROUTINE INTO AC0
        IDIVI 0,^D100   ;DIVIDE THE CONTENTS OF AC0 BY 100 AND PLACE THE 
                        ;REMAINDER INTO AC1 WITH THE QUOTIENT IN AC0
        JUMPE 0,DIV10   ;IF THE CONTENTS OF AC0 ARE 0 THEN JUMP TO DIV10
        ADDI 0,"0"      ;ADD THE VALUE OF AN ASCII 0 TO THE CONTENTS OF AC0
                        ;IN ORDER TO CONVERT A NUMBER INTO THE APPROPRIATE
                        ;ASCII REPRESENTATION
        IDPB 0,PTR2     ;DEPOSIT THE CONTENTS OF AC0 INTO ASCNAM
DIV10:  IDIVI 1,^D10    ;DIVIDE THE CONTENTS OF AC1 BY 10 AND PLACE THE 
                        ;REMAINDER IN AC2 AND THE QUOTIENT INTO AC1
        ADDI 1,"0"      ;ADD THE VALUE OF AN ASCII 0 TO THE CONTENTS OF AC0
                        ;IN ORDER TO CONVERT A NUMBER INTO THE APPROPRIATE
                        ;ASCII REPRESENTATION
        IDPB 1,PTR2     ;DEPOSIT THE CONTENTS OF AC0 INTO ASCNAM
        ADDI 2,"0"      ;ADD THE VALUE OF AN ASCII 0 TO THE CONTENTS OF AC0
                        ;IN ORDER TO CONVERT A NUMBER INTO THE APPROPRIATE
                        ;ASCII REPRESENTATION
        IDPB 2,PTR2     ;DEPOSIT THE CONTENTS OF AC0 INTO ASCNAM
        MOVEI 0,";"     ;MOVE A ; INTO AC0
        IDPB 0,PTR2     ;DEPOSIT THE SEMI-COLON INTO ASCNAM
        ;
        ;LOGIN STRING COMPLETE.
        ;

        MOVEI 1,ASCNAM  ;MOVE THE ADDRESS OF THE LOGIN STRING INTO AC1
        CREAUX 1,       ;ATTEMPT TO ESTABLISH THE AUX CIRCUIT
        JRST ERR4       ;ERROR RETURN. GO TO ERR4
        MOVEM 1,@1(16)  ;AC1 CONTAINS THE PORT NO IF SUCCESSFUL, PLACE THE
                        ;CONTENTS OF AC1 AT THE SECOND CALLING ARGUMENTS 
                        ;ADDRESS.
        MOVEM 1,PORT    ;STORE PORT NO FOR INTERRUPT PROCESSING
        SETZM @2(16)    ;PLACE A ZERO AT THE THIRD CALLING ARGUMENTS ADDRESS
        SKIPE INTFLG    ;IF THE INTERRUPT FLAG IS ZERO, WE HAVE NOT ESTABLISHED
                        ;THE INTERRUPT TABLE,SKIP NEXT INST. AND INITIALIZE
                        ;THE INTERRUPT SYSTEM. OTHERWISE GO TO GETINT AND 
                        ;ASSIGN THE INTERRUPT CAUSES.
        JRST GETINT     ;GO TO GETINT AND ASSIGN INTERRUPT CAUSES
        MOVEI 1,INTTAB  ;STORE ADDRESS OF INTERRUPT TABLE IN AC1
        HRLI 1,6        ;BITS TO ENABLE & CLEAR INTERRUPTS IN LEFT HALF AC1
        INTADR 1,       ;INITIALIZE INTERRUPT SOFTWARE
        JRST ERR6       ;GO TO ERR6 IF FAIL
        SETOM INTFLG    ;INTERRUPT SYSTEM INITIALIZED, SET FLAG.
GETINT: MOVE 1,PORT     ;PLACE PORT NO IN AC1
        HRLI 1,007001   ;PLACE CIRCUIT ZAP CAUSE IN LEFT HALF AC1
        TINASS 1,       ;ASSIGN SOFTWARE INTERRUPT CAUSE FOR CHANNEL 1
        JRST ERR7       ;GO TO ERR7 IF FAIL
        MOVE 1,PORT     ;PLACE PORT NO IN AC1
        HRLI 1,001002   ;PLACE AUX CIRCUIT CHAR RECEIVED CAUSE IN LEFT HALF AC1
        TINASS 1,       ;ASSIGN SOFTWARE INTERRUPT CAUSE FOR CHANNEL 2
        JRST ERR8       ;GO TO ERR8 IF FAIL
        MOVE 1,[POINT 7,AUXINP+BUFSZ1,34];STORE BYTE POINTER TO END OF AUX
                        ;BUFFER AREA INTO AC1
        MOVEM 1,AUXPTI  ;STORE AC1 INTO AUXPTI
        MOVEM 1,AUXPTO  ;STORE AC1 INTO AUXPTO
        SETZM CHARIN    ;ZERO OUT CHARACTER COUNT
        MOVSI 1,(1B0+1B1);;SET UP BIT CONFIGURATION TO ENABLE SOFTWARE
                        ;INTERRUPTS FOR CHANNEL 1
        INTENB 1,       ;ENABLE SOFTWARE INTERRUPT SYSTEM
        JRST ERR9
HBRINI: MOVE 2,PORT     ;GET PORT NO.
        LSH 2,^D9       ;SHIFT PORT NO LEFT 9 BITS
        ADDI 2,110      ;ADD BITS FOR CHAR IN AND MILLISECONDS TIME OUT
        LSH 2,^D18      ;SHIFT BIT CONFIGURATION INTO LEFT HALF OF AC2
        HRRI 2,^D2000   ;2000 MILLISECONDS (2SECONDS)

        HIBER 2,        ;GO TO SLEEP
        JRST HIBERR     ;UNABLE TO EXECUTE HIBER UUO
        MOVE 3,PORT     ;GET PORT NO.
        LSH 3,^D18      ;PLACE PORT NO IN LEFT HALF OF AC3
        HRRI 3,1        ;PLACE 1 IN RIGHT HALF OF AC3

        AUXCAL 3,1      ;GET A CHARACTER FROM THE PORT IF ANY
        JRST ENBINT     ;ENABLE CHARACTER OVER CIRCUIT INTERRUPT

        MOVE 4,AUXPTI   ;PLACE THE CURRENT INPUT BYTE POINTER IN AC4
INIWRT: CAIE 1,23       ;SKIP NEXT INS IF CHAR IS NOT XOFF

        CAIN 1,21       ;SKIP NEXT INS IF CHAR IS NOT XON
        JRST INIREA     ;EAT THE CHAR AND PRESS ON

        IBP 4           ;INCREMENT THE BYTE POINTER IN AC4
        CAMN 4,[POINT 7,AUXINP+BUFSIZ,6] ;ARE WE AT THE END OF THE BUFFER
        MOVE 4,[POINT 7,AUXINP,6];YES, STORE A BYTE POINTER TO THE BEGINNING
                        ;OF THE BUFFER AREA
        CAMN 4,AUXPTO   ;ARE WE CAUGHT UP TO WHERE WE HAVE OUTPUT THE LAST CHAR?
        JRST NOROOM     ;YES, GOTO NOROOM
        AOS CHARIN      ;ADD ONE TO CHARIN
        DPB 1,4         ;;DEPOSIT THE CHARACTER IN AC1 INTO AUXINP AS PER THE 
                        ;BYTE POINTER IN AC4
        MOVEM 4,AUXPTI  ;STORE THE BYTE POINTER IN AC4 INTO AUXPTI

INIREA: AUXCAL 3,1      ;GET NEXT CHARACTER FROM PORT
        JRST HBRINI     ;NO MORE CHARACTER SO SLEEP SOME
        JRST INIWRT     ;GO PROCESS THE CHARACTER AT INIWRT

ERR1:   MOVEI 0,1       ;MOVE 1 INTO AC0
        MOVEM 0,@2(16)  ;MOVE THE 1 FROM AC0 TO THE ADDRESS OF THE THIRD CALLING
                        ;ARGUMENT
        JRST RET        ;GO TO RET
ERR2:   MOVEI 0,2       ;MOVE 2 INTO AC0
        MOVEM 0,@2(16)  ;MOVE THE 2 FROM AC0 TO THE ADDRESS OF THE THIRD CALLING
                        ;ARGUMENT
        JRST RET        ;GO TO RET
ERR3:   MOVEI 0,3       ;MOVE 3 INTO AC0
        MOVEM 0,@2(16)  ;MOVE THE 3 FROM AC0 TO THE ADDRESS OF THE THIRD CALLING
                        ;ARGUMENT
        JRST RET        ;GO TO RET
ERR4:   LSH 0,^D-18     ;SHIFT THE ERROR RETURN CODE FROM THE CREAUX UUO STORED
                        ;IN AC0 RIGHT 18 BITS.
        ADDI 0,4        ;ADD 4 TO AC0 TO COMPENSATE FOR THE THREE PREVIOUSLY
                        ;DEFINED ERROR CODES.
        MOVEM 0,@2(16)  ;MOVE THE CONTENTS OF AC0 TO THE ADDRESS OF THE THIRD
                        ;CALLING ARGUMENT
        JRST RET        ;GO TO RET
ERR6:   MOVEI 0,^D12    ;MOVE 12 INTO AC0
        MOVEM 0,@2(16)  ;MOVE THE 12 FROM AC0 TO THE ADDRESS OF THE THIRD
                        ;CALLING ARGUMENT
        JRST RET        ;GO TO RET
ERR7:   MOVEI 0,^D13    ;MOVE 13 INTO AC0
        MOVEM 0,@2(16)  ;MOVE THE 13 FROM AC0 TO THE ADDRESS OF THE THIRD
                        ;CALLING ARGUMENT
        JRST RET        ;GO TO RET
ERR8:   MOVEI 0,^D14    ;MOVE 14 INTO AC0
        MOVEM 0,@2(16)  ;MOVE THE 14 FROM AC0 TO THE ADDRESS OF THE THIRD
                        ;CALLING ARGUMENT
        JRST RET        ;GO TO RET
ERR9:   MOVEI 0,^D15    ;MOVE 15 INTO AC0
        MOVEM 0,@2(16)  ;MOVE THE 15 FROM AC0 TO THE ADDRESS OF THE THIRD
                        ;CALLING ARGUMENT
        JRST RET        ;GO TO RET


;+
;.PG.S 3.LITERAL
;                              SUBROUTINE AUXRED
;
;       PURPOSE:THIS ROUTINE READS A CHARACTER FROM THE AUXILIARY CIRCUIT
;               AND RETURNS IT TO THE CALLING PROGRAM. IF THERE
;               IS NO CHARACTER IN THE PORTS BUFFER, THE ROUTINE
;               WILL RETURN A VALUE OF ONE AS THE ERROR CODE.
;
;       CALLING SEQUENCE:
;
;               CALL AUXRED(IPORT,ICHAR,IERR)
;
;       WHERE:
;
;               IPORT = A VALID PORT NO FOR THIS PROCESS
;               ICHAR = THE CHARACTER RECEIVED FROM THE PORT
;               IERR  = AN ERROR RETURN
;
;       ERROR-CODES
;
;               00 = NO ERROR, CHARACTER RETURNED FROM PORT
;               01 = NO CHARACTERS IN BUFFER
;               02 = PORT NO. SUPPLIED BY USER PROGRAM DOES NOT MATCH PORT
;                    NO. FROM LAST CALL TO AUXINI
;               03 = UNABLE TO RE-ENABLE SOFTWARE INTERRUPT CHANNEL 2
;.END LITERAL
;-

AUXRED: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE
                        ;NEXT INSTRUCTION.
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVE 1,@(16)    ;PICK UP 1ST ARGUMENT(PORT.NO)
        CAME 1,PORT     ;SEE IF ARGUEMENT AGREES WITH WHAT WE THINK IT IS
        JRST ERR5       ;GO TO ERR5 IF THEY DO NOT MATCH
        MOVE 2,AUXPTO   ;STORE AUXPTO IN AC2
AXLP:   CAMN 2,AUXPTI   ;SEE IF AUXPTO EQ AUXPTI
        JRST RDFAIL     ;GO TO RDFAIL IF THEY ARE EQUAL (NO CHARS TO READ)
        ILDB 1,2        ;PLACE A CHAR FROM AUX BUFFER AREA USING BYTE POINTER
                   ;AUXPTO STORED IN AC2 INTO AC1
        CAMN 2,[POINT 7,AUXINP+BUFSIZ,6];ARE WE AT THE END OF THE BUFFER
        JRST REINIT     ;IF YES THE GO TO REINIT TO REINITIALIZE THE BYTE 
                        ;POINTER
        MOVEM 2,AUXPTO  ;PLACE THE CURRENT BYTE POINTER CONTENTS OF AC2 INTO
                        ;AUXPTO
        LSH 1,^D29      ;SHIFT THE CHARACTER TO THE LEFT SIDE
        IOR 1,SPCMSK    ;PAD THE CHARACTER WITH TRAILING BLANKS
        MOVEM 1,@1(16)  ;PLACE THE CHARACTER INTO THE ADDRESS OF THE SECOND
                        ;CALLING ARGUMENT
        SETZM @2(16)    ;PLACE A ZERO IN THE THIRD CALLING ARGUMENT
        MOVE 1,CHARIN   ;PLACE THE CHAR COUNT INTO AC1
        SUBI 1,1        ;SUBTRACT ONE FROM AC1
        MOVEM 1,CHARIN  ;STORE AC1 INTO CHARIN
        MOVEI 2,<BUFSIZ*5>-1 ;PLACE MAX CHAR COUNT INTO AC2
        CAMN 1,2        ;IS THE CURRENT CHAR COUNT EQ TO THE MAXIMUM -1 ?
        JRST AUXRNB     ;THEN IT IS NECESSARY TO RE-ENABLE SOFTWARE INTERRUPT
                        ;FOR CHANNEL 2 (CHAR RECEIVED AUX CIRCUIT)
        JRST RET        ;OTHERWISE GO TO RET
REINIT: MOVE 2,[POINT 7,AUXINP];PLACE A BYTE POINTER TO THE BEGINNING OF THE
                        ;AUX BUFFER AREA INTO AC2
        JRST AXLP       ;GO TO AXLP
RDFAIL: MOVEI 1,1       ;PLACE THE VALUE 1 INTO AC1
        MOVEM 1,@2(16)  ;STORE THE 1 IN AC1 INTO THE ADDRESS OF THE THIRD
                        ;CALLING ARGUMENT
        JRST RET        ;GO TO RET
AUXRNB: MOVSI 1,(1B0+1B2);SET UP AC1 WITH BIT PATERN TO RE-ENABLE SOFTWARE
                        ;INTERRUPT CHANNEL 2
        INTENB 1,       ;RE-ENABLE CHANNEL 2
        JRST ERR10      ;GO TO ERR10 IF FAIL
        JRST RET        ;GO TO RET

ERR5:   MOVEI 4,2       ;MOVE 2 INTO AC4
        MOVEM 4,@2(16)  ;MOVE THE CONTENTS OF AC4 TO THE ADDRESS OF THE
                        ;THIRD CALLING ARGUMENT
        JRST RET        ;GO TO RET
ERR10:  MOVEI 4,3       ;PLACE THE VALUE 3 INTO AC4
        MOVEM 4,@2(16)  ;MOVE THE CONTENTS OF AC4 TO THE ADDRESS OF THE
                        ;THIRD CALLING ARGUMENT
        JRST RET        ;GO TO RET


;+
;.PG.S 3.LITERAL
;                              SUBROUTINE AUXWRT
;
;       PURPOSE:THIS ROUTINE WRITES A STRING OF CHARACTERS TO THE SPECIFIED
;               AUXILIARY CIRCUIT PORT. THE LAST WORD OF THE CHARACTER
;               STRING MUST BE A NULL CHARACTER.
;
;       CALLING SEQUENCE:
;
;               CALL AUXWRT(IPORT,ISTRING)
;
;       WHERE:
;
;               IPORT = THE PORT NO. FOR THE CIRCUIT
;               ISTRING = THE STRING OF CHARACTERS DELIMITED BY A NULL CHARACTER
;
;       RETURN CODES - NONE.
;
;       NOTE:   THE STRING MUST INCLUDE ALL OF ITS OWN CARIAGE RETURNS.
;.END LITERAL
;-

AUXWRT: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE
                        ;NEXT INSTRUCTION
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVSI 1,(0B0+1B2);SET UP BIT CONFIGURATION  IN AC1 TO DISABLE CHANNEL 2
        INTENB 1,       ;DISABLE SOFTWARE INTERRUPT CHANNEL 2
        JRST ERR11      ;GO TO ERR11 IF FAIL
        MOVE 1,@(16)    ;MOVE THE PORT NO. INTO AC1
        HRLZS 1,1       ;MOVE THE PORT NO. FROM THE RIGHT HALF OF AC1 TO THE
                        ;LEFT HALF
        HRRI 1,5        ;PLACE 5 IN THE RIGHT HALF OF AC1
        MOVE 2,[POINT 7,,] ;BEGIN BUILDING A 7BIT BYTE POINTER IN AC2 FOR
                        ;PASSING THE STRING ARRAY SEND BY THE USER, WE EILL
                        ;BE SENDING A LINE AT A TIME.
        HRRI 2,@1(16)   ;STORE THE ADDRESS OF THE STRING ARRAY IN THE RIGHT
                        ;HALF OF AC2
        MOVEM 2,PTR4    ;STORE THE COMPLETED POINTER IN AC2 INTO PTR4 LINE BEGIN
        MOVEM 2,PTR3    ;STORE THE COMPLETED POINTER IN AC2 INTO PTR3 WORKING
        SETZM TCHRFL    ;SET THE TRAILING CHARACTER FLAG TO ZERO
        MOVEI 5,0       ;ZERO OUT THE CHAR. COUNT PER LINE IN AC5

WRTLP:  ILDB 2,PTR3     ;GET A CHAR USING THE WORKING BYTE POINTER AND STORE
                        ;THE CHARACTER IN AC2
        ADDI 5,1        ;ADD 1 TO CHAR COUNT PER LINE
WRTLP1: CAIN 2,15       ;IF THE CHARACTER IS A CR, DO THE NEXT INS ELSE SKIP
        JRST CR         ;PROCESS THE CARRIAGE RETURN
        CAIE 2,0        ;IF NULL TERMINATOR SKIP NEXT INS. ALL OTHER NEXT INS.
        JRST WRTLP      ;GET ANOTHER CHARACTER
        CAIG 5,1        ;IF WE HAVE ONLY THE NULL TERMINATOR,EXE NEXT INS
        JRST ENBINT     ;ENABLE CHARACTER OVER CIRCUIT INTERRUPT
        AUXCAL 1,PTR4   ;SEND THE CHARACTER NOT DELIMITED BY A CR DOWN THE CIR
        SETOM TCHRFL    ;SET THE TRAILING CHARACTER FLAG TO ONES
        JRST HBR        ;GO TO SLEEP AND PICK UP ECHOED CHARS.

CR:     MOVE 2,PTR3     ;PLACE THE CURRENT POINTER INTO AC2(CR LOCATION)
                        ;THIS POINTER WILL BE NEEDED FOR THE PTR4 FOR NEXT LINE
        MOVEM 2,PTR7    ;STORE IT IN PTR7
        ILDB 2,PTR3     ;GET NEXT CHARACTER AFTER CR
        MOVEM 2,SAVCHR  ;SAVE THE CHARACTER
        MOVEI 2,0       ;PUT 0 INTO AC2
        DPB 2,PTR3      ;PUT NULL TERMINATOR INTO THE STRING ARRAY

        AUXCAL 1,PTR4   ;SEND LINE

HBR:    MOVE 2,@(16)    ;GET PORT NO.
        LSH 2,^D9       ;SHIFT PORT NO LEFT 9 BITS
        ADDI 2,110      ;ADD BITS FOR CHAR IN AND MILLISECONDS TIME OUT
        LSH 2,^D18      ;SHIFT BIT CONFIGURATION INTO LEFT HALF OF AC2
        HRR 2,TDELAY    ;DELAY TDELAY MILLISECONDS(4000 IS DEFAULT)

        HIBER 2,        ;GO TO SLEEP
        JRST HIBERR     ;UNABLE TO EXECUTE HIBER UUO
        MOVE 3,@(16)    ;GET PORT NO.
        LSH 3,^D18      ;PLACE PORT NO IN LEFT HALF OF AC3
        HRRI 3,1        ;PLACE 1 IN RIGHT HALF OF AC3

        AUXCAL 3,2      ;GET A CHARACTER FROM THE PORT IF ANY
        JRST RESTOR     ;NO CHARACTERS IN BUFFER

        MOVE 4,AUXPTI   ;PLACE THE CURRENT INPUT BYTE POINTER IN AC4
BUFWRT: CAIE 2,23       ;SKIP NEXT INS IF CHAR IS NOT XOFF

        CAIN 2,21       ;SKIP NEXT INS IF CHAR IS NOT XON
        JRST READIN     ;EAT THE CHAR AND PRESS ON

        IBP 4           ;INCREMENT THE BYTE POINTER IN AC4
        CAMN 4,[POINT 7,AUXINP+BUFSIZ,6] ;ARE WE AT THE END OF THE BUFFER
        MOVE 4,[POINT 7,AUXINP,6];YES, STORE A BYTE POINTER TO THE BEGINNING
                        ;OF THE BUFFER AREA
        CAMN 4,AUXPTO   ;ARE WE CAUGHT UP TO WHERE WE HAVE OUTPUT THE LAST CHAR?
        JRST NOROOM     ;YES, GOTO NOROOM
        AOS CHARIN      ;ADD ONE TO CHARIN
        DPB 2,4         ;;DEPOSIT THE CHARACTER IN AC2 INTO AUXINP AS PER THE 
                        ;BYTE POINTER IN AC4
        MOVEM 4,AUXPTI  ;STORE THE BYTE POINTER IN AC4 INTO AUXPTI

READIN: AUXCAL 3,2      ;GET NEXT CHARACTER FROM PORT
        JRST HBR        ;NO MORE CHARACTER SO SLEEP SOME
        JRST BUFWRT     ;GO PROCESS THE CHARACTER AT BUFWRT

RESTOR: SKIPE TCHRFL    ;SKIP NEXT INS IF TCHRFL IS EQUAL TO ZERO
        JRST ENBINT     ;ENABLE CHARACTER OVER CIRUIT INTERRUPT
        MOVE 2,SAVCHR   ;RETRIEVE SAVCHR INTO AC2
        DPB 2,PTR3      ;REPLACE SAVCHR TO ITS FORMER POSITION
        MOVE 2,PTR7     ;RESTORE BYTE POINTER POINTING TO CR LOC
        MOVEM 2,PTR4    ;PLACE THIS POINTER INTO PTR4
        MOVE 2,SAVCHR   ;GET THE FIRST CHAR OF NEW LINE
        MOVEI 5,1       ;SET CHAR COUNT TO ONE FOR CHAR IN AC2
        JRST WRTLP1     ;BEGIN PROCESSING NEW LINE

ERR11:  OUTSTR [ASCIZ/
** UNABLE TO DISABLE THE INTERRUPT SYSTEM FROM AUXWRT **
/]
        EXIT

;
;       AUXINP BUFFER AREA EXCEEDED

NOROOM: OUTSTR [ASCIZ/
** I AM IN A LOT OF TROUBLE, THERE IS NO PLACE TO PUT ANY MORE CHARACTER **
/]
        HALT

;       UNABLE TO EXECUTE HIBERR

HIBERR: OUTSTR [ASCIZ/
** UNABLE TO EXECUTE HIBER UUO IN AUXWRT **
/]
        HALT


;
        ;THIS BEGINS THE SOFTWARE INTERRUPT ROUTINE TO INTERCEPT A CIRCUIT
        ;ZAP AND TRANSFER CONTROL TO THE USERS PROGRAM ADDRESS SETUP BY A
        ;CALL TO ONCZAP OR IF NOT SET, WILL ISSUE A MESSAGE AND EXIT.

CHZAP:  MOVEM 1,AC1SAV  ;SAVE CURRENT CONTENTS OF AC1 INTO AC1SAV
        SETZM SIXNAM    ;ZERO OUT THE FIRST WORD OF SIXNAM
        SETZM SIXNAM+1  ;ZERO OUT THE SECOND WORD OF SIXNAM
        SETZM ASCNAM    ;ZERO OUT THE FIRST WORD OF ASCNAM
        MOVEI 1,ASCNAM+1;STORE THE ADDRESS OF THE SECOND WORD OF ASCNAM IN THE
                        ;RIGHT HALF OF AC1
        HRLI 1,ASCNAM   ;STORE THE ADDRESS OF ASCNAM IN THE LEFT HALF OF AC1
        BLT 1,ASCNAM+4  ;PLACE THE VALUE OF ASCNAM STARTING IN ASCNAM+1 THROUGH
                        ;ASCNAM+4
        MOVE 1,[POINT 6,SIXNAM,];PLACE A BYTE POINTER ADDRESSING THE BEGINNING
                        ;OF SIXNAM INTO AC1
        MOVEM 1,PTR5    ;STORE THE BYTE POINTER IN AC INTO PTR5
        MOVE 1,[POINT 7,ASCNAM,];PLACE A BYTE POINTER ADDRESSING THE BEGINNING
                        ;OF ASCNAM INTO AC1
        MOVEM 1,PTR6    ;STORE THE BYTE POINTER IN AC1 INTO PTR6
        MOVE 1,[POINT 7,,];PLACE A SEVEN BIT BYTE POINTER INTO AC1
        MOVEM 1,PTR4    ;STORE THE BYTE POINTER IN AC1 INTO PTR4
        SETZM PORT      ;ZERO OUT THE PORT NO.
        SETZM AUXINP    ;ZERO OUT THE FIRST WORD OF THE AUXINP BUFFER AREA
        MOVEI 1,AUXINP+1;STORE THE ADDRESS OF AUXINP+1 IN RIGHT HALF AC1
        HRLI 1,AUXINP   ;STORE THE ADDRESS OF AUXINP IN THE LEFT HALF AC1
        BLT 1,AUXINP+BUFSZ1;PLACE THE VAULE OF AUXINP STARTING IN AUXINP+1
                        ;THROUGH AUXINP+BUFSIZ1
        SETZM AUXPTI    ;ZERO OUT THE AUXPTI BYTE POINTER
        SETZM AUXPTO    ;ZERO OUT THE AUXPTO BYTE POINTER
        SETZM CHARIN    ;ZERO OUT THE CHARACTER COUNT
        MOVE 1,ZAPPC    ;STORE THE USER REQUEST PC TO GO TO ON A CIR ZAP
        CAIN 1,0        ;IS THE ADDRESS EQ TO ZERO?
        MOVEI 1,DEFZAP  ;YES THEN STORE THE DEFZAP ADDRESS IN AC1
        MOVEM 1,INTTAB  ;STORE THE CONTENTS OF AC1 INTO INTTAB+0
        MOVE 1,AC1SAV   ;RESTORE AC1
        DISMIS          ;DISMISS THE INTERRUPT(I.E. GO TO THE USER REQUEST 
                        ;PROGRAM LOCATION


;
;       THIS BEGINS THE DEFAULT CODE FOR A CIRZAP RECEIVED.

DEFZAP: OUTSTR [ASCIZ / 
AUXILIARY CIRCUIT HAS BEEN ZAPPED
/]                      ;DEFAULT CIRCUIT ZAP ROUTINE. OUTPUT THE PRECEDING
                        ;MESSAGE TO THE TERMINAL
        EXIT            ;EXIT THE USERS PROGRAM.


;+
;.PG.S 3.LITERAL
;                              SUBROUTINE ONCZAP
;
;       PURPOSE:THIS ROUTINE ALLOWS THE USER TO SPECIFY A PROGRAM STATEMENT
;               LABEL TO TRANSFER CONTROL TO WHEN THE LOSS OF THE AUXILLIARY
;               CIRCUIT IS DETECTED.  IF THE USER DOES NOT SPECIFY A 
;               LOCATION IN HIS CODE TO TRANSFER TO, THE DEFAULT
;               IS TO ISSUE THE FOLLOWING MESSAGE TO THE TERMINAL:
;                       AUXILIARY CIRCUIT HAS BEEN ZAPPED
;               AND RETURN TO XEXEC LEVEL.
;
;       CALLING SEQUENCE:
;
;               CALL ONCZAP($LABL)
;
;       WHERE:
;
;               $LABEL IS A VALID STATEMENT LABEL IN THE USERS PROGRAM
;                 PRECEDED BY A $.
;
;       RETURN CODES - NONE.
;.END LITERAL
;-

ONCZAP: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE
                        ;NEXT INSTRUCTION
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVEI 1,@(16)   ;PICK UP THE ADDRESS FOR CIRCUIT ZAP
        MOVEM 1,ZAPPC   ;STORE THE ADDRESS IN ZAPPC
        JRST RET        ;GO TO RET


;+
;.PG.S 3.LITERAL
;                       SUBROUTINE CIRZAP
;
;       PURPOSE:THIS ROUTINE WILL TEAR DOWN(I.E. ZAP) AN AUXILIARY CIRCUIT
;               IF THE PORT SO DESIGNATED BELONGS TO THE USER.
;
;       CALLING SEQUENCE:
;
;               CALL CIRZAP(IPORT)
;
;       RETURN CODES - NONE
;.END LITERAL
;-

CIRZAP: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE 
                        ;NEXT INSTRUCTION
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVE 1,@(16)    ;GET THE PORT NO AND STORE IN RIGHT HALF AC1
        HRLI 1,007000   ;PLACE CIRCUIT ZAP CAUSE IN LEFT HALF AC1
        TINASS 1,       ;ASSIGN SOFTWARE INTERRUPT CAUSE FOR CHANNEL 0
                        ;THUS DISABLING CIRCUIT ZAP INTERRUPT
        JRST ERR12      ;GO TO ERR12 IF FAIL
        MOVE 1,@(16)    ;GET THE PORT NO. AND STORE IN RIGHT HALF OF AC1
        ZAPCIR 1,       ;ZAP THE CIRCUIT IF THE USER OWNS IT NO OTHER RETURN
        JRST RET        ;GO TO RET
ERR12:  OUTSTR [ASCIZ/
** UNABLE TO DISABLE THE INTERRUPT SYSTEM FROM CIRZAP **
/]
        EXIT

;
;+
;.PG.S 3.LITERAL
;                               FUNCTION NOAXIN
;
;       PURPOSE:THIS IS A FORTRAN FUNCTION TO RETURN TO THE USER THE
;               CURRENT NUMBER OF CHARACTERS IN THE INPUT/OUTPUT BUFFER
;               AREA OF THE AUXILIARY CIRCUIT.
;
;       CALLING SEQUENCE:
;
;               IA = NOAXIN(X)
;
;       RETURN CODES - NONE.
;
;       NOTE:   THIS IS AN INTEGER FUNCTION.
;.END LITERAL
;-

NOAXIN: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE
                        ;NEXT INSTRUCTION
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVE 0,CHARIN   ;STORE THE CHARACTER COUNT IN AC0
        JRST RET        ;GO TO RET

;
;+
;.PG.S 3.LITERAL
;                               FUNCTION QCHRIN
;
;       PURPOSE:THIS ROUTINE TELLS THE USER PROGRAM WHETHER OR NOT THERE
;       ARE ANY CHARACTERS WAITING IN THE TERMINAL INPUT BUFFER
;       THIS IS A FUNCTION.
;
;       CALLING SEQUENCE:
;
;               I = QCHRIN(I)
;
;       WHERE:
;
;               I = 0 IF THERE ARE NO CHARACTERS IN THE TERMINAL BUFFER
;               I = 1 IF THERE ARE CHARACTERS IN THE TERMINAL BUFFER
;
;       NOTE: THIS IS AN INTEEGER FUNCTION.
;.END LITERAL
;-

QCHRIN: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE
                        ;NEXT INSTRUCTION.
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVEI 0,0       ;PLACE A ZERO IN AC0
        SKPINC          ;ARE THERE CHARACTERS IN THE TERMINAL INPUT BUFFER
        SKIPA           ;NO, THEN LEAVE AC0 WITH A 0 VALUE
        MOVEI 0,1       ;YES, THEN PLACE THE VALUE 1 IN AC1
        JRST RET

;
;+
;.PG.S 3.LITERAL
;                       SUBROUTINE TIMDEL
;
;       PURPOSE:THIS ROUTINE INITIALIZES THE TIME DELAY AFTER EACH LINE IS
;               SENT DOWN THE AUXILIARY CIRCUIT. THE DEFAULT TIME DELAY
;               IS 4 MILLISECONDS. THE TIME MUST BE GREATER THAN OR EQUAL TO 1.
;
;       CALLING SEQUENCE:
;
;               CALL TIMDEL(ITMDEL)
;
;       WHERE:
;
;               ITMDEL = THE TIME TO DELAY AFTER EACH LINE IS SENT DOWN
;                        THE AUXILIARY CIRCUIT. IF ITMDEL IS LESS THAN OR
;                        EQUAL TO ZERO, THE DEFAULT TIME DELAY IS USED(4 
;                        MILLISECONDS).
;
;       NOTE:ITMDEL IS THE TIME SPECIFIED IN MILLISECONDS.
;            MAXIMUM VALUE FOR ITMDEL IS 2^18 -1 OR 262143 MILLISECONDS.
;.END LITERAL
;-
TIMDEL: CAIA            ;SUBROUTINE ENTRY,F10 WILL SKIP NEXT INSTRUCTION
                        ;F40 WILL DEPOSIT INTO THIS ADDRESS AND EXECUTE
                        ;NEXT INSTRUCTION
        PUSH 17,16      ;SAVE RETURN ADDRESS IN AC17 FOR RETURN
        MOVE 1,@(16)    ;GET TIME DELAY INTO AC1
        SKIPLE 1        ;DO NOT STORE A TIME DELAY LE 0
        MOVEM 1,TDELAY  ;STORE INTO TDELAY
        JRST RET        ;GO TO RETURN



;+
;.PG.S 3.LITERAL
;                       SUBROUTINE TIMOUT
;
;       PURPOSE:THIS ROUTINE IS USED TO SET UP A TIMOUT SITUATION
;               AFTER A CERTAIN AMOUNT OF CLOCK TIME HAS PASSED.  THE
;               ROUTINE IS RETRIGGERABLE - EACH TIME IT IS CALLED
;               AN INTERRUPT IS SET FOR THE NUMBER OF UNITS IN THE
;               FUTURE REQUESTED.
;
;       CALLING SEQUENCE:
;
;               CALL TIMOUT(IUNITS,IQUAN,IPORT,$LABEL,IERR)
;
;       WHERE:
;
;               IUNITS = UNITS OF THE TIME AS:
;                               0 = MILLISECONDS (MAX 2^18-1)
;                               1 = SECONDS      (MAX 2^16 - 1)
;                               2 = MINUTES      (MAX 2^16 - 1)
;               IQUAN  = NUMBER OF UNITS TILL TIMEOUT
;               IPORT  = PORT NUMBER TO CHECK FOR BREAK CHARACTER
;                        AND RETRIGGER UPON RECEIPT.
;                        THE TERMINAL (COMMAND PORT) CAN BE SPECIFIED AS -1.
;               $LABEL = LABEL TO BRANCH TO ON TIMEOUT
;               IERR   = RETURNED ERROR CODE AS:
;                            0 = ALL OK
;                            4 = ERROR INTIALIZING INTERRUPTS
;                            8 = ERROR ASSIGNING CAUSE
;                           12 = ERROR ENABLING CHANNEL
;
;
;       NOTE:
;               IF IQUAN = 0 THE TIMOUT WILL BE TURNED OFF
;.END LITERAL
;-
DEFINE TIMERR(ECODE)<JRST [MOVEI ECODE
                           MOVEM @4(16)
                           JRST  RET]>


TIMOUT: CAIA                    ; MAKE F40/F40 COMPATIBLE
        PUSH    17,16           ; ONLY FOR F40
        SETZM   @4(16)          ; DEFAULT NO ERROR RETURN
        SKIPE   INTFLG          ; CHECK FOR INTADR ALREADY INIT'ED
          JRST  SETINT          ; ALREADY GOT INTADR
        MOVE    1,[6,,INTTAB]   ; INITIALIZE AND CLEAR EVERYTING
        INTADR  1,
          TIMERR 4
        SETOM   INTFLG          ; SET FLAG THAT INTADR IS ON

SETINT: SKIPE   TIMJMP          ; IF AN ADDRESS, CAUSE ALREADY SET
          JRST  TIMSET          ; SET INTERVAL AND ADDRESS
        MOVE    1,[.IATIM+TIMCHN] ; ASSIGN CAUSE AND CHANNEL
        INTASS  1,
          TIMERR ^D8
        MOVE    1,[1B0+1B<TIMCHN>] ; ENABLE THE INTERRUPT CHANNEL
TIMSET: INTENB  1,
          TIMERR ^D12

        HRLZ    1,@0(16)        ; GET THE UNITS IN LEFT HALF
        HRR     1,@1(16)        ; GET THE QUANTITY
        MOVEM   1,TIMVAL        ; SAVE THE TIME VALUE
        SETTIM  1,              ; DO IT
          HALT                  ; NEVER HAPPENS
        MOVEI   1,@3(16)        ; ADDRESS OF LABEL
        MOVEM   1,TIMJMP        ; SAVE IT


;
;  CHECK THE PORT NUMBER, IF ZERO DO NOTHING BUT DISABLE THE RESET
;  ON BREAK CHARS INTERRUPT -- OTHERWISE, SET UP THE INTERRUPT
;
        HRRZ    1,@2(16)        ;GET THE PORT NUMBER
        JUMPE   1,TIMRST        ; IT'S ZERO SO DISABLE INTERRUPT
        ADD     1,[.IABRK+<BRKCHN>B17] ; BUILD THE COMMAND WORD
        TINASS  1,              ; ASSIGN THE CAUSE 
          TIMERR 16
        MOVE    1,[1B0+1B<BRKCHN>] ; SET UP FOR THE ENABLE
        INTENB  1,
          TIMERR 20
        JRST    RET

;
;  WE WERE PASSED A ZERO PORT, SO JUST DISABLE THE INTERRUPT IF ANY
;
TIMRST: MOVE    1,[0B0+1B<BRKCHN>]      ; SET UP FOR DISABLE
        INTENB  1,
          CAIA                  ; IGNORE ALL ERRORS (WHO CARES???)
        JRST    RET             ; ALL DONE
;
;
;  TIMER INTERRUPT OCCURRED, RESET OLD PC AND GO TO PROGRAM IF ADDRESS
;  IS NOT ZERO
;
TIMINT: MOVE    1,TIMJMP        ; GET REQUESTED JMP ADDRESS
        MOVEM   1,TIMER         ; PUT IN INTTAB
        CAIE    1,              ; DON'T DISMIS TO ZERO
          DISMIS
        OUTSTR  [ASCIZ/!! FATAL ERROR IN "TIMOUT" -- NO RETURN ADDRESS !!
/]
        HALT

;
;  INTERRUPT ON A BREAK CHAR, SIMPLY RESET THE TIMER INTERRUPT
;  TO GO OFF "TIMVAL" UNITS LATER
;
BRKINT: MOVEM   1,AC1SAV        ; SAVE AC1
        MOVE    1,TIMVAL        ; GET THE VALUES
        SETTIM  1,              ; DO IT
          HALT                  ;  NEVER HAPPENS! (I HPE)
        MOVE    1,AC1SAV        ; RESTORE THE AC
        DISMIS                  ; LET EVERYONE CONTINUE RUNNING


        ;THIS BEGINS THE SOFTWARE INTERRUPT ROUTINE TO INTERCEPT CHARACTERS
        ;COMING ACCROSS THE AUXILIARY CIRCUIT.  CHARACTERS ARE STORED
        ;IN AUXINP AND ARE REFERENCED BY BYTE POINTERS AUXPTI AND AUXPTO.
        ;THE NUMBER OF CHARACTERS IN THE BUFFER TO BE PROCESSED IS STORED
        ;IN CHARIN.

AXCHRI: MOVEM 1,AC1SAV  ;SAVE THE CURRENT CONTENTS OF AC1 IN AC1SAV
        MOVEM 2,AC2SAV  ;SAVE THE CURRENT CONTENTS OF AC2 IN AC2SAV
        MOVEM 3,AC3SAV  ;SAVE THE CURRENT CONTENTS OF AC3 IN AC3SAV
        MOVE 2,AUXPTI   ;PLACE THE CURRENT INPUT BYTE POINTER IN AC2
AXLP1:  IBP 2           ;INCREMENT THE BYTE POINTER IN AC2
        CAMN 2,[POINT 7,AUXINP+BUFSIZ,6];ARE WE AT THE END OF THE BUFFER
        MOVE 2,[POINT 7,AUXINP,6];YES,STORE A BYTE POINTER TO THE BEGINNING
                        ;OF THE BUFFER AREA IN AC2
        CAMN 2,AUXPTO   ;ARE WE CAUGHT UP TO WHERE WE HAVE OUTPUT THE LAST CHAR?
        JRST NOROOM     ;YES, GOTO NOROOM
        MOVE 3,PORT     ;STORE THE PORT NO IN AC3
        HRLZS 3,3       ;MOVE THE RIGHT HALF OF AC3 TO THE LEFT HALF
        HRRI 3,1        ;PLACE A 1 IN THE RIGHT HALF OF AC3
CHRIN:  AUXCAL 3,1      ;READ A CHARACTER FROM THE AUX CIRCUIT AND STORE IN AC1
        JRST AXFIN      ;GO TO AXFIN IF THERE ARE NO CHARACTERS
        CAIE 1,23       ;SKIP NEXT INS IF CHAR EQUALS XOFF
        CAIN 1,21       ;SKIP NEXT INS IF CHAR IS NOT EQUALS XON
        JRST CHRIN      ;GO GET ANOTHER CHARACTER
        AOS CHARIN      ;ADD ONE TO CHARIN
        DPB 1,2         ;DEPOSIT THE CHARACTER IN AC1 INTO AUXINP AS PER THE
                        ;BYTE POINTER IN AC2
        MOVEM 2,AUXPTI  ;STORE THE BYTE POINTER IN AC2 INTO AUXPTI
        JRST AXLP1      ;GO TO AXLP1(TRY AND GET SOME MORE CHARS)
AXFIN:  MOVE 1,AC1SAV   ;RESTORE AC1 FROM AC1SAV
        MOVE 2,AC2SAV   ;RESTORE AC2 FROM AC2SAV
        MOVE 3,AC3SAV   ;RESTORE AC3 FROM AC3SAV
        DISMIS          ;DISMIS THE CURRENT INTERRUPT AND RETURN TO THE OLD PC

;
;+
;.PG.S 3.LITERAL
;                       SUBROUTINE ONINT
;
;       PURPOSE:THIS SUBROUTINE ACTIVATES ESCAPE TRAPPING.
;
;       CALLING SEQUENCE:
;
;               CALL ONINT($N)
;
;       WHERE:
;
;               N = THE LABEL OF A STATEMENT WITHIN THE CALLING PROGRAM.
;                   AFTER THIS SUBROUTINE IS EXECUTED, TYPING AN ALT MODE/ESC
;                   DURING THE REMAINDER OF EXECUTION TRANSFERS CONTROL TO THE
;                   STATEMENT LABELED N FROM ANYWHERE IN THE ENTIRE PROGRAM,
;                   INCLUDING POINTS IN SUBPROGRAMS AND LIBRARY FUNCTIONS.
;                   WHENEVER THE ONINT SUBROUTINE IS EXECUTED, THE SPECIFIED
;                   STATEMENT BECOMES THE DESTINATION FOR ESCAPE TRAPPING,
;                   SUPERSEDING ANY DESTINATION STATEMENT SPECIFIED IN A
;                   PREVIOUS CALL TO THE ONINT SUBROUTINE.
;.END LITERAL
;-
ONINT:  CAIA            ; MAKE F40/F10 COMPATIBLE
        PUSH 17,16      ; ONLY FOR F40
        MOVEI 0,@0(16)  ; GET ADDRESS TO JUMP ON ESC
        MOVEM 0,INTJMP  ; STORE ESCAPE BRANCH ADDRESS
        SKIPE INTFLG    ; CHECK FOR INTADR ALREADY INITED
        JRST SETESC     ; ALREADY GOT INTADR
        MOVE 1,[6,,INTTAB] ; INITIALIZE AND CLEAR EVERYTHING
        INTADR 1,
        JRST [OUTSTR [ASCIZ/!! FATAL ERROR IN "ONINT". UNABLE TO ESTABLISH
INTERRUPT VECTOR/]
        JRST RET]

        SETOM INTFLG    ;SET FLAG THAT INTADR IS ON

SETESC: MOVEI 1,-1              ;ASSIGN COMMAND PORT
        HRLI 1,ESCCHN            ;ASSIGN CHANNEL
        TINASS 1,
        JRST [OUTSTR [ASCIZ/!! FATAL ERROR ON ONINT. UNABLE TO ASSIGN ESC CAUSE!!
/]
        JRST RET]
        MOVE 1,[1B0+1B<ESCCHN>] ;ENABLE THE INTERRUPT CHANNEL
        INTENB 1,
        JRST [OUTSTR [ASCIZ/!! FATAL ERROR ON ONINT. UNABLE TO ENABLE ESC INT!!
/]
        JRST RET]
        JRST RET

;       INTERRUPT HANDLING ROUTINE FOR ESCAPE
;
ESCINT: MOVEM 1,AC1SAV
        MOVE 1,INTJMP
        MOVEM 1,ESCCHR
        MOVE 1,AC1SAV
        DISMIS
        HALT
;

;+
;.PG.S 3.LITERAL
;               SUBROUTINE OFFINT
;
;       PURPOSE: THIS ROUTINE IS USED TO DE-ACTIVATE ESCAPE TRAPPING CAUSED
;                BY A PREVIOUS CALL TO ONINT.
;
;       CALLING SEQUENCE:
;
;               CALL OFFINT
;
;.END LITERAL
;-

OFFINT: CAIA            ;MAKE F10/F40 COMPATIBLE
        PUSH 17,16      ;ONLY FOR F40
        HRRZI 0,-1
        TINASS 0,
        JRST [OUTSTR [ASCIZ/!! FATAL ERROR IN OFFINT. UNABLE TO DE-ASSIGN
ESC CAUSE !!/]
        JRST RET]
        POPJ 17,


;
;       THIS BEGINS THE CODE TO RE-ENABLE THE INTERRUPT FOR CHANNEL 2
;       AND JRST TO RET
;

ENBINT: MOVSI 1,(1B0+1B2);SET UP BIT CONFIGURATION IN AC1 TO ENABLE CHANNEL 2
        INTENB 1,
        JRST [OUTSTR [ASCIZ/
** UNABLE TO ENABLE INTERRUPT SYSTEM **
/]]
        JRST RET
;
;       COMMON RETURN FOR ALL SUBROUTINES AND FUNCTIONS

RET:    POPJ 17,        ;RETURN TO THE CALLING PROGRAM
        END
   oP