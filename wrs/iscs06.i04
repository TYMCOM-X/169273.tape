: *******************************************************************
: **                  PROPRIETARY INFORMATION                      **
: **                                                               **
: **  This  source code listing constitutes the proprietary pro-   **
: **  perty of TYMNET, Incorporated. The recipient, by receiving   **
: **  this program listing, agrees that neither this listing nor   **
: **  the   information  disclosed herein nor any  part  thereof   **
: **  shall be  reproduced or transferred to other documents  or   **
: **  used  or  disclosed to others for manufacturing or for any   **
: **  other purpose except as specifically authorized in writing   **
: **  by TYMNET, Incorporated.                                     **
: *******************************************************************
: **                   PROGRAM IDENTIFICATION                      **
: **                                                               **
: **  Version Number     :6.02           Release Date: 12/12/86    **
: **                                                               **
: **  File Name          :ISCS06.I02				   **
: **                                                               **
: **  File Description   :CONSAT INITIALIZATION                    **
: **                                                               **
: **  File Abstract      :CONSAT equates and macros                **
: **                                                               **
: *******************************************************************
: **                CONFIGURATION SPECIFICATION                    **
: **                                                               **
: **         see (DNDSPEC)ISCS06.ERS                               **
: **                                                               **
: *******************************************************************
: **                   DOCUMENT SPECIFICATION                      **
: **                                                               **
: **  Functional Specification:         (DNDSPEC)ISCS06.ERS        **
: **                                                               **
: *******************************************************************
: **                    CHANGE LOG                                 **
: **                                                               **
: **  Ver   Date    By   PIR/NSR  Changes (most recent at top)     **
: ** ----- -------- ---  -------- ---------------------------------**
: ** 07.00 12/12/86 sdw           added message to .SETPA          **
: ** 06.04 01/08/87 WRS		  Added 600 baud async support     **
: ** 06.02 10/24/86 DLG		  Added GL to SETFLA so CRTID works**
: ** 06.02 10/17/86 CAB		  Changed LTEXT(TIDM,...) to set   **
: **				  delay defaults if text specified **
: **				  wihtout delay parameters.	   **
: ** 06.02 10/08/86 CAB		  Changed .H.DEF and .SETPA macros **
: **				  by adding IIX parameter.	   **
: ** 06.02 10/01/86 CAB		  Added .30T into DECLARE macro.   **
: ** 06.01 09/19/86 CAB		  Fixed OUTGREET bug and changed   **
: **				  OUTGREET and OUTPROMPT defaults. **
: ** 06.01 09/18/86 LH		  Changed 9 digits to 8 digits of  **
: **				  flag for no ASYNC & no SIO support*
: ** 06.01 09/16/86 DLG		  Modified message text of some msg**
: ** 06.01 09/15/86 CAB		  Changed ISISring default back to **
: **				  old default of 1024 bytes.	   **
: ** 06.01 09/04/86 DLG		  Added IF X3ON to all PAD macros  **
: ** 06.01 08/28/86 CAB	  	  BFRSIZE macro declares bufferlet **
: **				  allocation (overrides default).  **
: ** 06.01 08/08/86 dlg	  	  Made ACHOST same as old version  **
: **				  that checks for host > 0.        **
: ** 06.01 07/23/86 sdw           OUTPROMPT defines outdial prompt **
: ** 06.01 07/21/86 cab  NSR 829  Increased SIO buffer size default**
: ** 06.00 07/15/86 cab		  Defined A.RING, A.ASYN, A.BUFF   **
: ** 06.00 07/08/86 LH		  Rewrote macro ISISRING.          **
: ** 06.00 07/08/86 CAB		  Obsoleted DATABUFFER macro.	   **
: ** 06.00 06/25/86 LH		  Default NCRSAV,EXCRSH,CHIST	   **
: ** 06.00 06/19/86 dlg		  Redefined NX3PRO as last valid   **
: **				  profile number.		   **
: ** 06.00 06/09/86 dlg		  Corrected AUTOCALL macro to	   **
: **				  prevent assembly error	   **
: ** 06.00 06/01/86 sdw		  Created INITANSWER which sets	   **
: **				  those ports not hung at startup  **
: ** 06.00 05/22/86 dlg	  	  Obsoleted BRKRPL macro and changed*
: **				  PRFNDF to override 103 setting if**
: **				  BRKRPL defined                   **
: ** 06.00 05/15/86 LH   PIR 1824 Added bit array TOIIX of buffer  **
: ** 05.00 04/29/86 sdw           C.FIX and PADRELATED changed to  **
: **                              eaiser assembly                  **
: ** 05.00 04/21/86 sdw           Changed CUDUSE to make byte table**
: ** 05.00 04/21/86 sdw           Created AUTOCALL macro to create **
: **                              login string.                    **
: ** 05.00 04/14/86 sdw           TID240 & TID480 added            **
: ** 05.00 04/10/86 sdw           CUDUSE creates but one byte of   **
: **                              control info and lets the data   **
: **                              structure be defined in IDEFS    **
: ** 05.00 04/04/86 sdw           ACHOST checks validity of host # **
: ** 05.00 04/01/86 sdw           Rewrote INCOMINGCALLS to set up  **
: **                              port addressing. No longer a     **
: **                              ranging macro.                   **
: ** 05.00 03/30/86 sdw           removed NOTRS as an option       **
: ** 05.00 03/07/86 sdw           Added consistency to INITMODE    **
: **                              and POSMODES macros.             **
: ** 04.03 02/24/86 LH   NSR#0228 Add macro BAUDQS to have untrans **
: **				  -lateable char. sent as a ? mark **
: **			          and to expand specific char. to  **
: **				  text strings.   		   **
: ** 04.03 01/21/86 SDW  PIR#1651 Add macroes for Outdial          **
: ** 04.02 01/21/86 DLG    n/a    Add configuration macro C.FIX to **
: **                              the PADREL macro and specified   **
: **                              requirement that PADREL macro    **
: **                              be first PAD macro in tymfile,   **
: **				  All X3ON setting by other macros **
: **				  replaced by IF X3ON statements,  **
: **				  All references to NAPORT         **
: **			  	  replaced with NPORT, C.FIX       **
: **			  	  removed from some macros and     **
: **				  added to  .VPRNG macro           **
: ** 04.02 01/16/86 JH     n/a    Add configuration macro C.FIX    **
: **                              into CUDUSE at the beginning for **
: **                              NPORT to be define properly      **
: ** 04.02 01/15/86 CAB    n/a    Increase default async ring size **
: **                              for PC file transfers at 4800    **
: ** 04.02 01/15/86 CAB    n/a    Add proprietary banner           **
: *******************************************************************
	TITLE	CONsolidated tymSAT INITIALIZATION		
	SUBTTL	DESCRIPTION & ERROR-MACRO DEFINITIONS
	LIST	-X,F,-R,L
:	Tymnet-II compatability items -
:	 . set Radix to hex
:	 . Kill all the labels which will be used to name macros.
:	   (Prevents label collision errors. Does not include names
:	     that start with a period.)

	RA	0
	KILL	ERROR,SERROR,ERRLIN,ERREND,WARNING,WARLIN,WAREND,DEFAULT
	KILL	GLOBAL,IFEQ,DEFBIT,KILBIT,DEFIND
	KILL	BSTORAG,HSTORAG,WSTORAG,C.FIX,DECLAR,P.FIX
	KILL	SHOWME,LOCATI,TIDDEF,PVCRNG,SPVRNG,PVCDF,PVCEX,SPVCEX
	KILL	PTEXT,STEXT,STEXT0,UTEXT,UTXRNG,SUTXRG,MUTXRG,MPVCUS
	KILL	MPVCFO,LTEXT,TID120,HD202,NOBUSY,NO.CP,ACHOST,AHRNG
	KILL	SHRNG,MHRNG,ACCODE,ACRNG,SCRNG,MCRNG,TIDSPP
        KILL    T.OPT,T.FLAG,T.NOP,SIOIO,DS.CMD,PRINT,ABORT,D.STRU,BA
        KILL    SIGBGN,SIGEXC,SIGEND,BARRAY,MINH,MDCH,BFA,EA,VID
        KILL    SAY,MAC,MAC,MAC,MAC,MAC,LSELEM,SCHED,P.SYMB
        KILL    SYMBOL,REQUIRE,ENDREQ,N.PRIN,PRANGE,PSET,SAY.P,BSAY,OPTION
	KILL	NPAPRT,.SETPA,ADRPRT,SADPRT
	KILL	.EQ.,.NE.,.GT.,.LT.,.GE.,.LE.
	KILL	TBLENT,ABACK,BAUDQS,TID480,TID240

:    ***   ***  *   *  ****  ***  *     ***** ****    *   ***** ***** ****
:   *   * *   * **  * *     *   * *       *   *   *  * *    *   *     *   *
:   *     *   * * * *  ***  *   * *       *   *   * *****   *   ****  *   *
:   *   * *   * *  **     * *   * *       *   *   * *   *   *   *     *   *
:    ***   ***  *   * ****   ***  ***** ***** ****  *   *   *   ***** ****


:                     ***** *   * *   *  ****   *   *****
:                       *    * *  ** ** *      * *    *
:                       *     *   * * *  ***  *****   *
:                       *     *   *   *     * *   *   *
:                       *     *   *   * ****  *   *   *


:  ***** *   * ***** ***** *****   *   *     ***** *****   *  ***** *****  ***  *   *
:    *   **  *   *     *     *    * *  *       *      *   * *   *     *   *   * **  *
:    *   * * *   *     *     *   ***** *       *     *   *****  *     *   *   * * * *
:    *   *  **   *     *     *   *   * *       *    *    *   *  *     *   *   * *  **
:  ***** *   * *****   *   ***** *   * ***** ***** ***** *   *  *   *****  ***  *   *






:	SYSGEN CONVENTIONS.

:		All numeric option values are decimal unless otherwise stated.

:		Almost every option has a default value.  Therefore, very few
:	options must actually be specified in the TYM or CON files.
:		The only exception to this are the statements that associate
:	host numbers with port numbers (ACHOST and AHRNG).

:	MACRO NAMING CONVENTIONS.

:		All macros intended for internal use start with ".".


:	RANGING MACROS.

:	There are a number of macros which accept a set of RANGE parameters.
:		The generic form for these macros is:

:			MACRO(A,B,C-D,E,F-G)

:	where A,B and E are single ports selected, and the ranges C through
:		D and F through G are selected.
	SUBTTL	ERRORS...fatal diagnostics


: **	ERROR(text,cont)	Output configuration error to local TTY
: **	SERROR(text,cont)	Like ERROR, but specify source line number
: **	ERRLIN(text,cont)	Continue an error message on a new line
: **	ERREND(text)		End an error message

:	If text > 51 characters, it should be broken at a convenient place
:	and continued with the ERRLIN macro.

:	Format will be:
:	ERROR:	[CR:LF]!!!! **** text ****[CR:LF]
:	SERROR:	[CR:LF]!!!! ERROR at line nnn:
:		[CR:LF]!!!!	 text ****[CR:LF]

:	If cont>0 then message will end with text without a CR:LF, and then
:	numbers or other special things can be added.

:	ERRLIN(text) will print "..." at the end of the current line, then:
:	[CR:LF]!!!!            text ****[CR:LF]
:	and can be used for continuation lines when cont>0

:	ERREND(text) will add ****[CR:LF] on the current line

	GL	ERRCNT
ERRCNT	EQ	0			:Number of errors so far

ERROR	MACRO(txt,cont)[
ERRCNT	EQ	ERRCNT+1
	REMARK	%!!!! ERROR **** txt
	IF	cont 0
	ELSE
	 ERREND
	EI
]

SERROR	MACRO(txt,cont)[
ERRCNT	EQ	ERRCNT+1
	REMARK	%!!!! ERROR at line 
QE	LINENO
	NUMBER	$A QE
	KILL	QE
	ERRLIN(txt,cont)
]

ERRLIN	MACRO(txt,cont)[
	REMARK	 ...%!!!!            txt
	IF	cont 0
	ELSE
	 ERREND
	EI
]

ERREND	MACRO(txt)[
	REMARK	txt ****%
]
	SUBTTL	WARNINGS...non-fatal diagnotics


: **	WARNING(text,cont)	Output configuration warning to local TTY
: **	WARLIN(text,cont)	Continue a warning message on a new line
: **	WAREND(text)		End a warning message

:	If text > 51 characters, it should be broken at a convenient place
:	and continued with the WARLIN macro.

:	Format will be:
:	[CR:LF]>>>> WARNING **** text ****[CR:LF]

:	If cont>0 then message will end with text without a CR:LF,and then
:	numbers or other special things can be added.

:	WARLIN(text) will print "..." at the end of the current line, then:
:	[CR:LF]>>>>            text ****[CR:LF]
:	and can be used for continuation lines when cont>0

:	WAREND(text) will add ****[CR:LF] on the current line

WARCNT	EQ	0			:Number of warnings so far

WARNING	MACRO(txt,cont)[
WARCNT	EQ	WARCNT+1
	REMARK	%>>>> WARNING **** txt
	IF	cont 0
	ELSE
	 WAREND
	EI
]

WARLIN	MACRO(txt,cont)[
	REMARK	 ...%>>>>            txt
	IF	cont 0
	ELSE
	 WAREND
	EI
]

WAREND	MACRO(txt)[
	REMARK	txt ****%
]
	SUBTTL	Final output	

: **	.ABORT		Finally (unconditionally), generate warning
:				about warnings and errors...
.ABORT	MACRO[
	IF	WARCNT+ERRCNT		:if any conditions
	 REMARK	%**********************************************************
	 REMARK	%**********************************************************
	 IF	WARCNT
	  REMARK %****	
	  NUMBER $A WARCNT
	  REMARK  NON-FATAL WARNINGS encountered during assembly
	 EI	:WARCNT

	 IF	ERRCNT
	  REMARK %****	
	  NUMBER $A ERRCNT
	  REMARK  FATAL ERRORS encountered during assembly
	 EI	:ERRCNT
	 REMARK	%**********************************************************
	 REMARK	%**********************************************************
	 QUIT
	EI	:WARCNT+ERRCNT ]


	SUBTTL	PRIMITIVE DEFINITION MACROS

: **	Define macro for easy defaults
DEFAULT	MACRO(ID,VAL)[
	IF	1-\ID
ID	 EQ	VAL
	EI
]


: **	... and macro for easy globals
GLOBAL	MACRO(ID,VAL)[
	GL	ID
	DEFAULT(ID,VAL)
]

: **	IFEQ(SWITCH,LABEL,ZERODEF,DEFALT)
:	  Sets LABEL To ZERODEF if SWITCH = 0 -
:	   else, if LABEL undefined, sets it to DEFALT
:	   -- useful for setting debugging switches which are
:	      dependent upon other assembly switches (e.g. AHIST).
IFEQ	MACRO(SWITCH,LABEL,ZERODEF,DEFALT)[
	IF	1-SWITCH
	 GL	LABEL
LABEL	 EQ	ZERODEF
	ELSE
	 GLOBAL(LABEL,DEFALT)
	EI
]


: **	DEFIND(NAME,NBITS)	Defines name with index #, port range
:				to be 0, global.
DEFIND	MACRO(NAME,NBITS)[
	RA	0
QQ	EQ	(NBITS+1F)/20
.DOB.(LL,0,63)			:Max allowable index number for CUG is 99d
 .DOB.(JJ,0,QQ)
	GL NAME`|LL|`|JJ|
NAME`|LL|`|JJ| EQ 0
  .DOE.1
.DOE.0
]





: **	DEFBIT(NAME,NBITS)	Defines symbols NAMEi to be 0, GLOBAL
DEFBIT	MACRO(NAME,NBITS) [
	RA	0
QQ	EQ	(NBITS+1F)/20
	IF	QQ
Q	 EQ	0
	 RE	QQ
	  GL	NAME`|Q|
NAME`|Q|  EQ	0
Q	  EQ	Q+1
	 ER
	EI
]

: **	KILBIT(NAME,NBITS)	Kills bit-symbols NAMEi
KILBIT	MACRO(NAME,NBITS) [
	RA	0
QQ	EQ	(NBITS+1F)/20
	IF	QQ
Q	 EQ	0
	 RE	QQ
	  KILL	NAME`|Q|
Q	  EQ	Q+1
	 ER
	EI
]


: **	.RANGE(LABEL,RX,MX,P)	Called to check a range of values

:	P	may be a single # N, a range of #s Ni-Nj with 0=<Ni<Nj,
:		or null
:	RX	is radix of #s N
:	MX	is max value of N (given in radix RX),
:		range is 0 to $0 0FFFFFFFF
:	LABEL	is a label for diagnostics

:	returns QR = 0 if nothing to do,
:	else returns QR = number of iterations..
:			QI = first port to do.

.RANGE	MACRO(LABEL,RX,MX,P)[
Q	EQ	$`RX -(0/P+0)		:FOR .P. = "Ni-Nj", Q = -(0/Ni-Nj) = Nj
					: else 0
QI	EQ	$`RX Q+(P+0)		:FOR .P. = "Ni-Nj", Q=Nj, QI = Nj+(Ni-Nj) = Ni
					:FOR .P. = "Ni", Q=0, QI = Ni
					:FOR .P. = null,  QI = 0
QQ	EQ	$`RX P $0 100000000	:FOR .P. = null, QQ = $0100000000
QR	EQ	1
	IF	-QI
QI	 EQ	-QI
QQ	 EQ	$0100000000
	 ERROR(LABEL`: Parameter -,1)
	 NUMBER $`RX QI
	 ERREND( not positive)
	EI
	IF	$0 QQ&1FFFFFFFF%100000000	:IF .P. NOT NULL
	 IF	QI-($`RX`MX-1)
	  ERROR(LABEL`: Parameter ,1)
	  NUMBER $`RX QI
	  REMARK	 greater than 
	  NUMBER $`RX`MX-1; ERREND
QR	  EQ	0
	 EI
	 IF	Q			:IF M NOT NULL
QR	  EQ	Q-QI+1
	  IF	Q-($`RX`MX-1)
	   ERROR(LABEL`: Parameter ,1); NUMBER $`RX Q
	   REMARK	 greater than ; NUMBER $`RX`MX-1; ERREND
QR	   EQ	0
	  EI
	  IF	QI-Q
	   ERROR(LABEL`: Range ,1); NUMBER $`RX QI
	   REMARK	-; NUMBER $`RX Q; ERREND( Backward)
QR	   EQ	0
	  EI
	 EI
	ELSE
QR	 EQ	0
	EI
	KILL	Q,QQ
]


: **	.SETNM(NAME,VAL)	Called to set range of names to VAL
:			Expects QI and QR to be set to initial number and range.
.SETNM	MACRO(NAME,VALUE) [
	IF	QR
	 RE	QR
	 GLOBAL(NAME`|QI|,VALUE)
QI	 EQ	QI+1
	 ER
	EI
]

: **	.SETNN(NAME,VAL)	Called to set range of names to VAL
:			Expects QI and QR to be set to initial number and range
QY	EQ	0
.SETNN	MACRO(NAME,VALUE) [
	IF	NPORT
	 RE	NPORT
	 GLOBAL(NAME`.|QY|,VALUE)
QY	 EQ	QY+1
	 ER
	EI
]



: **	.S.RNG(BITS,ST,RG)	Set range of bits in symbolic array
:					BITS starting at ST, range RG.
.S.RNG	MACRO(BITS,ST,RG) [
QI	EQ	ST
QR	EQ	RG
	.S.BIT(BITS)
]


: **	.R.RNG(BITS,ST,RG)	Reset range of bits in symbolic array
:					BITS starting at ST, range RG.
.R.RNG	MACRO(BITS,ST,RG) [
QI	EQ	ST
QR	EQ	RG
	.R.BIT(BITS)
]


: **	.S.BIT(BITS)	Set range of bits in symbolic array BITS
:			Expects QI and QR to be set to initial number
:			and range, respectively.
.S.BIT	MACRO(BITS) [
	IF	QR
Q	EQ	QI
	 RE	QR
	.S1BIT(BITS,Q)
Q	 EQ	Q+1
	 ER
	KILL	Q
	EI
]


: **	.R.BIT(BITS)	Reset range of bits in symbolic array BITS
:			Expects QI and QR to be set to initial number
:			and range, respectively.
.R.BIT	MACRO(BITS) [
	IF	QR
Q	EQ	QI
	 RE	QR
	.R1BIT(BITS,Q)
Q	 EQ	Q+1
	 ER
	KILL	Q
	EI
]


: **	.S1BIT(BITS,POS)	Set bit at POS in symbolic array BITS.
.S1BIT	MACRO(BITS,POS) [
BITS`|POS/20| EQ BITS`|POS/20|!(1^(1F-(1F&POS)))]


: **	.R1BIT(BITS,POS)	Reset bit at POS in symbolic array BITS.
.R1BIT	MACRO(BITS,POS) [
BITS`|POS/20| EQ BITS`|POS/20|&(-1%(1^(1F-(1F&POS))))]


: **	Macro .BIT.(NAME,POS)	Called to locate bit at POS in NAME

.BIT.	MACRO(NAME,POS) [(NAME`|POS/20|^((POS&1F)-1F)&1)]

:	STORAGE MACROS -
:	 All data are given relative addresses.  In the Isis-II environment
:	 this address is 0.  In Tymnet-II, the address will be the start
:	 a segment which contains the CONSAT data areas.  Tymnet-II
:	 will be able to change the MAC register for that segment, so that
:	 while in CONSAT mode, it will treat the data area as segment 0,
:	 and hence, be able to access the data with RX1, instead of RX3
:	 addressing.


BSTORAG	MACRO(NAME,NUMBER,OFFSET) [
NAME	EQ	.-OFFSET
	BS	NUMBER
]

HSTORAG	MACRO(NAME,NUMBER,OFFSET) [
	HS	0
NAME	EQ	.-OFFSET
	HS	NUMBER
]

WSTORAG	MACRO(NAME,NUMBER,OFFSET) [
	WS	0
NAME	EQ	.-OFFSET
	WS	NUMBER
]

	SUBTTL	DECLARATION MACROS

C.FIXD	EQ	1			:Configuration fwhen = 0
P.FIXD	EQ	1			:PVC Configuration fixed when = 0



: **	Macro to fix the configuration
:		Set up defaults
:	Force NAPORT to multiple of 16d, bitch if not
:	Compute number of ports, check for conflict
:	Define first port for each range
:	Initialize various symbolic bit arrays
:		For MPVC, we do the following:
:	First, define a pair of bit arrays to keep track of user-name and
:	format assignments.  We'll SET these bits, and turn them OFF as
:	defined, so we can easily determine if any were left undefined.
:	Define counter for MPVCUS definitions.
:	Insure PVC on for MPVC
:	Declare Multiplexed PVC ports.  ALL are identical exceptions!
C.FIX	MACRO[
	IF	C.FIXD
C.FIXD	 EQ	0			:won't do this again
	KILL	ASYNC,SIO,MPVC,PRINT,DECLARE,DIAOUT
DECLAR	MACRO(NAME)[
	ERROR(DECLARE{NAME} -- declarations MUST occur before exceptions)]
	GLOBAL(NAPORT,0)		:number of ASYNC ports
	GLOBAL(NUMPRN,0)		:number of Printers
	GLOBAL(NSPORT,0)		:number of SIO ports
	GLOBAL(NMPVC,0)			:number of Multiplexed PVC ports
	GLOBAL(NOPORT,0)		:number of Oudial command ports *sdw 403
	GLOBAL(NHOST,0)			:default number of (real) hosts
	GLOBAL(NPAPRT,0)		:number of addressable-port options
	GLOBAL(PVC,0)			:PVC default off
	IF	NAPORT&0F
NAPORT	 EQ	((-10)&NAPORT)+10
	 WARNING(NAPORT not multiple of 16 -- forced to ,1)
	 NUMBER	$A NAPORT;	WAREND
	EI
NPORT	EQ	NAPORT+NSPORT+NMPVC+NOPORT
	GL	NPORT,MAXPRT
MAXPRT	EQ	NPORT
	SI.FIX
	GLOBAL(.SPORT,NAPORT)
	GLOBAL(.MPORT,.SPORT+NSPORT)
	GLOBAL(.OPORT,.MPORT+NMPVC)
	DEFBIT(.30T,NAPORT)		:ASYNC ports identified at 30 CPS
	DEFBIT(.120T,NAPORT)		:ASYNC ports identified at 120 CPS
	DEFBIT(.240T,NAPORT)		:ASYNC ports identified at 240 CPS
	DEFBIT(.480T,NAPORT)		:ASYNC ports identified at 480 CPS
	DEFBIT(.ANSW,NAPORT)		:Don't hang these at startup *600.sdw
	DEFBIT(.BQSP,NAPORT)		:Non-transparent TELEX ports which
				:support ? mark replacing untranslateable chars
	DEFBIT(.SPPT,NAPORT)		:ASYNC ports with 0 parity TIDM
	DEFBIT(.2HD,NPORT)		:Bell 202S ports (all ports)
	DEFBIT(.BAUD,NPORT)		:BAUDOT ports (all ports)
	DEFBIT(.STP2,NPORT)		:ASCII 2 stop bits for SIO
	DEFBIT(.AP,NPORT)		:addressable-ports (all ports)
	DEFBIT(.BSY,NAPORT)		:Ports which support BUSY-OUT
	DEFBIT(.TLXP,NAPORT)		:Async ports that are TELEX ports
	DEFBIT(.BTLX,NAPORT)		:Async ports that are non-transparent
					:TELEX port
	DEFBIT(.TTLX,NAPORT)		:Async ports for SPEEDLINK TELEX ports
	.S.RNG(.BSY,0,NAPORT)		:...initially all ASYNC ports
	DEFBIT(.CP.,NPORT)		:Ports which support CP
	.S.RNG(.CP.,0,NAPORT)		:...initially all ASYNC ports
	DEFBIT(.NPI,NPORT)		:ports which DON'T want node-port ID
	.S.RNG(.NPI,.MPORT,NMPVC)	:	Include MPVC ports
	DEFBIT(PVCG,NPORT)		:ports with PVC options
	GL	PVCCNT			:Count of all ports desiring any kind
PVCCNT	EQ	NMPVC			:   of PVC service (init'ed to NMPVC)
	 IF	NMPVC
	  IF	NSPORT
TID.MP	TIDDEF(2*TIDMAX,0)		:Multiplexed PVC
	  ELSE
TID.MP	TIDDEF(TIDMAX,0)		:Multiplexed PVC
	  EI	:NSPORT
	.S.RNG(PVCG,.MPORT,NMPVC)	:default all MPVC ports to PVC
	DEFBIT(.MPMU,NMPVC)
	.S.RNG(.MPMU,0,NMPVC)
	DEFBIT(.MPMF,NMPVC)
	.S.RNG(.MPMF,0,NMPVC)
	GL	.NMUS
.NMUS	EQ	-1
PVC	EQ	1			:Force PVC on for MPVC
	.PVCDF(** BUG1 **,TID.MP,AID,NOTXT,ALO,PCO,NOPAR,HDX,NOCRLF,NOLFCR,TRS,NOHNG)
	.PXRNG(** BUG2 **,NMPVC,.MPORT,0-`(NMPVC-1`),QV)
	 EI	NMPVC

GLOBAL(SPECFE,8000)			:allow IIX
GLOBAL(ODN.00,03106)			:our dnic
DEFBIT(.CMMD,NPORT)			:Ports allowed to enter command mode
DEFBIT(.LGMD,NPORT)			:Ports allowed to enter login mode
.S.RNG(.LGMD,0,NPORT)			:... initially all ports
DEFBIT(.IPMD,NPORT)			:Initial port mode
DEFBIT(.PTYP,NPORT)			:Command types accepted (1=TYMNET 
					: Extended, 0=CCITT)
DEFBIT(.DBUF,NPORT)			:Presence of data editing buffer
DEFBIT(.ICO,NPORT)			:ports initted to accept incoming calls
					:...answer for incoming calls
DEFBIT(.CUGS,NPORT)			:Closed User Group subscription flag
DEFBIT(.CUGI,NPORT)			:CUG with incoming access flag
DEFBIT(.CUGO,NPORT)			:CUG with outgoing access flag
DEFIND(.CU,NPORT)		:Define CUGROUP's index #,port range flag
DEFIND(.AC,NPORT)

	EI	:C.FIXD]



: **	Macro to fix PVCs
P.FIX	MACRO[ C.FIX
	IF	P.FIXD
PVC	EQ	1			:turn PVC on
P.FIXD	 EQ	0			:won't do this again
	EI	:P.FIXD]

:	The following bit arrays are used to indicate types of buffers
:	 into which Consat processes may put data into, or pull data
:	 out from:
:	  Vanilla Consat:  TOPORT, TOLOG and GOLOG
:	   Isis   Consat:  TOISIS
:	   if MPVC      :  TOMPVC
:	   if IIX capable : TOIIX
:          if Outdial : TOTRAN - data to command translator *sdw 403
:	 Others may be added as time goes along.
:	 In order to allocate the correct amount of storage, the label
:	 NBTARY is defined ('Number of Bit arrays').  This is later used
:	  to define the amount of storage immediately after FLAGS for these
:	  bit arrays.  Storage is then labeled in various parts of the code
:	  by using the NXBTARY Macro, as required.  This allows for far greater
:	  bit array storage allocation without BF overflowing its Halfword.
:	ISIS portion of the code will add its 1 in dependent code.
BT.FIX MACRO [
	GL	NBTARY
NBTARY	EQ	4	:**6.00 LH
	IF	NMPVC
NBTARY	EQ	NBTARY+1
	EI

  IF	X3ON
: IF PAD : FRECHO, FREDIT
;
NBTARY	EQ	NBTARY+2
	EI

        IF      OUTDIA
NBTARY  EQ      NBTARY+1                :.OTBUF
        EI
]

SI.FIX	MACRO [
	IF NSPORT
GLOBAL(NSBFSH,2)		:shift count
GLOBAL(NSIOBF,10)		:number of input buffers
GLOBAL(SIBFSZ,10)		:input buffer size
GLOBAL(SOBFSZ,40)		:output buffer size
GLOBAL(SCBFSZ,40)		:command/status buffer size
	ELSE
	 IF \NSIOBF
	  WARNING(SIOBUF called, but no SIO ports declared,1)
	  WARLIN(setting Number of SIO buffers to zero)
	 EI
	EI
]


: **	Internal macro to define another host number
:	H.POS is <0 if not a valid (real) host...else set to NHOST for the host
.H.DEF	MACRO(H.NO,H.IIX) [
H.MODE	EQ	H.IIX 0			:6.02 cab - DEFAULT TO NO IIX ABILITY
        IF      1-H.NO
        ERROR(INVALID HOST NUMBER)
        QUIT
        EI
H.POS	EQ	-1
	IF	4000-H.NO		:(only for hostno < 16384d)
QQQ	EQ	1			:turn on switch to allocate new host
	 IF	NHOST			:have any hosts been declared before?
QQ	 EQ	0
	  RE	NHOST
	   IF	1-(HOST|QQ|%H.NO)	:H.NO = previously defined host no.?
QQQ	   EQ	0			:if so, don't allocate a new host
H.POS	   EQ	QQ			:...but record which one it is
	   EI
QQ	  EQ	QQ+1
	  ER
	 EI
	 IF	QQQ
HOST|NHOST| EQ	H.NO
HIIX|NHOST| EQ	H.MODE			:6.02 cab
HPRT|NHOST| EQ	0
	 GL	HPRT|NHOST|,HOST|NHOST|,HIIX|NHOST|
H.POS	 EQ	NHOST
NHOST	 EQ	NHOST+1
	 EI
	EI]


SIOBUF	MACRO(NUMBER) [
NSIOBF	EQ	$A NUMBER
	IF	NSIOBF-10
	 REMARK % (SIO Buffers must be less than 16 !)
	ELSE 1-(NSIOBF%10)
NSBFSH	EQ	2
	ELSE 1-(NSIOBF%8)
NSBFSH	EQ	1
	ELSE 1-(NSIOBF%4)
NSBFSH	EQ	0
	ELSE
	 REMARK % (Number of SIO buffers must be equal to 4, 8 or 16!)
	EI
]


:	Macro to specify configuration-level display desired
SHOWME	MACRO(LEV) [DEFAULT(CONFIG,LEV)]


        GLOBAL(MACHNM,0)        :redefined in solo. not used in isis

:	Macro to declare the location
LOCATI	MACRO(N1,S1)[
	GLOBAL(NODE,$8 N1 0)
	GLOBAL(SLOT,$A S1 0)
	IF	1-NODE;	 KILL	NODE;	EI
	IF	1-SLOT;	 KILL	SLOT;	EI]



:	Macro to declare a parameter by name
ASYNC	EQ	1			:name for ASYNC
SIO	EQ	2			:name for SIO
MPVC	EQ	3			:name for MPVC
PRINT	EQ	4			:name for PRINTER
DIAOUT	EQ	5			:name for OUTDIAL *sdw 403
DECLAR	MACRO(NAME,V)[
	IF	\NAME
	 IF	NAME-DIAOUT
	  WARNING(DECLARE identifier NAME unrecognized...ignored)
        ELSE    NAME-DIAOUT+1
NOPORT  EQ      $A V
	 ELSE	NAME-PRINT+1
NUMPRN	  EQ	$A V
	 ELSE	NAME-MPVC+1
NMPVC	  EQ	$A V
	 ELSE	NAME-SIO+1
NSPORT	  EQ	$A V
	 ELSE	NAME-ASYNC+1
NAPORT	  EQ	$A V
	 ELSE
	  WARNING(DECLARE identifier NAME unrecognized...ignored)
	 EI
	ELSE	:\NAME
	 WARNING(DECLARE identifier NAME unrecognized...ignored)
	EI	:\NAME
]
:MACRO TO SET NONDEBUGGING TYMFILE FLAGS
:OLD EQUATES WILL STILL WORK
: SETFLAG(FLAGNAME,ON/OFF or 1/0)
:WRITTEN BY SDW 5-85

ON      EQ      1
OFF     EQ      0

        GL      SLODTR,OMRON,YTID,KANA,CRTID,AEQCR
SLODTR  EQ      0
CRTID   EQ      0
AEQCR   EQ      0
OMRON   EQ      0
YTID    EQ      0
KANA    EQ      0

SETFLA  MACRO(Y1,Y2)[
        GL	Y1
	 IF Y2+1
          IF 2-Y2
Y1      EQ      Y2
         ELSE
          WARNING(Y1  flag greater than 1 ...setting to 1)
Y1      EQ      1
          EI
        ELSE
        WARNING(Y1  flag negative  ... ignored)
        EI]

:       MACRO TO SET PCO PARAMETERS
:   VALID PARMS ARE RETRYDELAY, TRYDELAY
:   TIME IS IN DECIMAL
:  WRITTEN BY SDW 5-85

        GL PCOTRY,PCORTY,PCOWAT		:** 4.02 LH
PCORTY  EQ      $A 90                   :SET DEFAULTS
PCOTRY  EQ      $A 90
PCOWAT  EQ      0

PCWAIT  EQ      2                       :PCOWAT 
RETRYD  EQ      1                       :PCORTY BY ANOTHER NAME
TRYDEL  EQ      0                       :PCOTRY ALIAS

PCOPAR  MACRO(Y1,Y2)[
  IF 1-\Y1;WARNING(PCOPAR ... unrecognized symbol Y1 ... ignored)
  ELSE
          IF 1-Y1
PCOTRY  EQ      $A Y2
          ELSE
           IF 2-Y1
PCORTY  EQ      $A Y2
           ELSE
            IF 3-Y1
PCOWAT  EQ      $A Y2
            EI :PCOWAT
          EI :PCORTY
         EI :PCOTRY
         EI :DEFINED SYMBOL
]

	GL	A.RING,A.ASYN,A.BUFF,AR.RS,ORSIZE,IRSIZE

A.RING	EQ	2		:ISIS RINGS  IN SEGMENT 2
A.ASYN	EQ	3		:ASYNC RINGS IN SEGMENT 3
A.BUFF	EQ	4		:BUFFERLETS  IN SEGMENT 4

AR.RS	EQ	$A 64		:default async ring size
ORSIZE	EQ	$A 1024-4	:default ISIS Output ring size
IRSIZE	EQ	$A 1024-4	:default ISIS Input  ring size

:
: ASYNCRING(SIZE)		:DECLARE RING SIZE IN DECIMAL
:
ASYNCRING MACRO(SIZE)[
AR.RS	EQ	$A SIZE 64	:**4.02 CAB
	GL	AR.RS
]

:
: ISISRING(SIZE)		:DECLARE RING SIZE IN DECIMAL
:
ISISRING MACRO(SIZE)[
ORSIZE	EQ	$A SIZE-4	:**4.02 CAB
IRSIZE	EQ	$A SIZE-4	:**4.02 CAB
	GL	ORSIZE,IRSIZE
]

:
: BFRSIZE(SIZE)		:DECLARE BUFFERLET SIZE IN DECIMAL
:
BFRSIZE MACRO(SIZE)[
Q	EQ	$A SIZE 0
NBBFLT	EQ	Q/10-1		:**6.01 CAB
	GL	NBBFLT
]

	SUBTTL	PVC PARAMETERS

:	List port attributes.  A mnemonic is provided for each characteristic
:	which may be selected as a function of AID or ALO.  The default option
:	for each parameter is signified by '**'.
AID	EQ	1	:    Automatic terminal identification
NOAID	EQ	0	: ** AID not desired
ALO	EQ	1^1	:    Automatic logon
NOALO	EQ	0	: ** ALO not desired
NPI	EQ	0	: ** Print node/port identifier for AID port
NONPI	EQ	1^2	:    NPI not desired
SLO	EQ	1^3	:    Subsequent logon to alternate host for ALO port
NOSLO	EQ	0	: ** SLO not desired
PAR	EQ	1^4	:    Even parity
NOPAR	EQ	0	: ** Mark parity (normal)
PCO	EQ	1^5	:    Permanent circuit for ALO port
NOPCO	EQ	0	: ** PCO not desired
HNG	EQ	0	: ** Allow port to be hung by network command
NOHNG	EQ	1^6	:    Do not allow port to be hung by network command
HDX	EQ	1^7	:    TYMNET H-DUX (no echo except for CR/LF pairs)
NOHDX	EQ	0	: ** HDX not desired
CRLF	EQ	0	: ** Echo LF with CR (normal)
NOCRLF	EQ	1^8	:    Do not echo LF with CR
LFCR	EQ	0	: ** Echo CR with LF (normal)
NOLFCR	EQ	1^9	:    Do not echo CR with LF
TRS	EQ	0	:    option no longer valid.  (now auto)500.sdw
NOTRS	EQ	1^0A	:    option only set to detect error 500.sdw*
RBP	EQ	1^0B	:    Allow Reverse-Backpressure
NORBP	EQ	0	: ** Reverse-Backpressure not allowed
TXT	EQ	0	: ** Text-Output permitted
NOTXT	EQ	(1^0C)!NONPI :Text-output not permitted
DSC	EQ	(1^0D)	:    Disconnect on ZAPPER
NODSC	EQ	0	: ** No disconnect on ZAPPER
MPC	EQ	(1^0E)	:    MPVC Candidate
NOMPC	EQ	0	: ** Not a MPVC candidate
TLX	EQ	(1^0F)	:    Telex port
NOTLX	EQ	0	: ** Not a Telex port
BTLX	EQ	(1^10)	:    Non-transparent Telex port
NOBTLX	EQ	0	: ** Not a Non-transparent Telex port
WRU	EQ	0	: ** Answer back "who are you"
NOWRU	EQ	(1^11)	:    Do not answer back "who are you"
SPAR	EQ	(1^12)	:    Space parity on data (until enter trans.) 4.01U
NOSPAR	EQ	0	: ** No data masking
KAT     EQ      (1^13)  :    Katakana port
NOKAT   EQ      0       : ** Not a Katakana port
UPC     EQ      (1^14)  :    Uppercase only
NOUPC   EQ      0       : ** Both upper and lower case
RCV	EQ	(1^15)	:    Addressable ports as receive-only ones **4.02 LH
NORCV	EQ	0	: ** Addressable ports as receiving & xmitting ones
PROBE	EQ	(1^16)	:    Probe message is desired ** 4.02 LH
NOPRB	EQ	0	: ** No Probe message is desired

:	List TID equivalents - 8 bit TID value is left-justified in 32-bit word.
TS	EQ	$A 24			:TID shift value
TSMASK	EQ	0FF^TS			:TID Mask
NO.A	EQ	40000000		:flag for no ASYNC support
NO.S	EQ	80000000		:flag for no SIO support

:	Define a macro to declare TID constants:
TIDDEF	MACRO(NO,OPT) [EQ (NO^TS)!OPT]

:Mnemonic		Description	    Network TID
TID1	TIDDEF(1,0)	110 baud ASCII		D
TID2	TIDDEF(2,NO.S)	EBCD 2741		P,CR
TID3	TIDDEF(3,NO.S)	CORRESPONDENCE 2741	P,CR
TID4	TIDDEF(4,NO.S)	150 baud ASCII		B
TID5	TIDDEF(5,NO.S)	150 baud ASCII		F
TID6	TIDDEF(6,NO.S)	EBCD 3767		P,CR
TID7	TIDDEF(7,NO.S)	CORRESPONDENCE 3767	P,CR
TID8	TIDDEF(8,0)	50 baud BAUDOT		 -
TID9	TIDDEF(9,0)	75 baud BAUDOT		 -
TID10	TIDDEF(0A,0)	300 baud ASCII		A
TID11	TIDDEF(0B,NO.S)	300 baud ASCII		C
TID12	TIDDEF(0C,NO.S)	300 baud ASCII		E
TID13	TIDDEF(0D,NO.S)	300 baud ASCII		G
TID14	TIDDEF(0E,0)	300 baud TRANSACTION
:			 TELEPHONE		Y
TID15	TIDDEF(0F,0)	1200 baud ASCII		A
TID16	TIDDEF(10,NO.S)	1200 baud ASCII		I
TID17	TIDDEF(11,NO.S)	1200 baud ASCII		G
TID18	TIDDEF(12,NO.S)  600 baud ASCII		A	: 6.04 WRS 1/8/87
TID19	TIDDEF(13,NO.S)  600 baud ASCII		I	: 6.04 WRS 1/8/87
TID20	TIDDEF(14,0)	2400 baud ASCII		A
TID21	TIDDEF(15,0)	4800 baud ASCII		A
TID22	TIDDEF(16,0)	9600 baud ASCII		A
TID23	TIDDEF(17,NO.S)	2400 baud ASCII		I
TID24	TIDDEF(18,NO.S)	4800 baud ASCII		I
TID25	TIDDEF(19,NO.S)	9600 baud ASCII		I
TID26	TIDDEF(1A,NO.S)	2400 baud ASCII		G
TID27	TIDDEF(1B,NO.S)	4800 baud ASCII		G
TID28	TIDDEF(1C,NO.S)  300 baud ASCII		I
TID29	TIDDEF(1D,NO.S)  600 baud ASCII		G	: 6.04 WRS 1/8/87
TID30	TIDDEF(1E,NO.S)	9600 baud ASCII		G
TID31	TIDDEF(1F,NO.S)	75/1200 baud ASCII (transparant) -
TID32	TIDDEF(20,NO.S)	75/1200 baud ASCII (non-transparant) -
TID33	TIDDEF(21,NO.S) 50 baud BAUDOT TELEX (transparent)
TID34	TIDDEF(22,NO.S) 50 baud BAUDOT VIRTUAL TELEX
TID35	TIDDEF(23,NO.S) 75 baud BAUDOT VIRTUAL TELEX	** 4.02 LH
TID36	TIDDEF(24,NO.S) 50 baud BAUDOT SPEEDLINK TELEX	** 4.02 LH
TID37	TIDDEF(25,NO.S) 75 baud BAUDOT SPEEDLINK TELEX	** 4.02 LH
TID38   TIDDEF(26,NO.S) 300 baud ASCII for SPEEDLINK    ** 4.03 LH
TID41	TIDDEF(29,NO.S)  300 baud ASCII (space parity)         4.01U
TID42	TIDDEF(2A,NO.S) 1200 baud ASCII (space parity)         4.01U
TID43	TIDDEF(2B,NO.S) 2400 baud ASCII (space parity)         4.01U
TID44	TIDDEF(2C,NO.S) 4800 baud ASCII (space parity)         4.01U
TID45	TIDDEF(2D,NO.S) 9600 baud ASCII (space parity)         4.01U

	GLOBAL(TIDMAX,2F)		:max TID implemented   4.01U
:: WARNING!!!!!  These parameters are linked to both the PVCTID tables
::	and the T.OPT, T.NOP, and T.FLAG verification macros !!!

TIDSIO	TIDDEF(TIDMAX,0)		:table-bias for SIO

	SUBTTL	PVC MACROS

:	Declare all ports which require PVC service.  The macros PVCRNG and
:	SPVRNG are "RANGING" format.

:	The PVCRNG macro creates 32-bit arrays.  A one bit in the array
:	defines the specified relative port as requiring some kind of PVC
:	service.  The 32-bit arrays are in the form of EQuates, named
:	PVCG0,PVCG1,...  Since a macro supports only up to 16 arguments,
:	the capability exists to declare the macro as many times as
:	necessary to get the desired configuration.  The PVCRNG macro
:	or's each occurance with the identical name, so all names must
:	be previously defined and initialized to 0.


: **	.PVRNG(NAM,RNG,OFF,P)	Internal macro to perform all processing
:				for parameter P in macro NAM, with range
:				RNG, and offset OFF.  Defined to reduce
:				macro storage requirements.

.PVRNG	MACRO(NAM,RNG,OFF,P) [
	.RANGE(NAM,A,RNG,P)
PVCCNT	EQ	PVCCNT+QR
	IF	OFF
QI	 EQ	QI+OFF
	EI
	.S.BIT(PVCG)
]


:	PVCRNG(Rp...)	Declare async PVC ports

PVCRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [ P.FIX
	 IF	NAPORT
	.PVRNG(PVCRNG,NAPORT,0,P0)
	.PVRNG(PVCRNG,NAPORT,0,P1)
	.PVRNG(PVCRNG,NAPORT,0,P2)
	.PVRNG(PVCRNG,NAPORT,0,P3)
	.PVRNG(PVCRNG,NAPORT,0,P4)
	.PVRNG(PVCRNG,NAPORT,0,P5)
	.PVRNG(PVCRNG,NAPORT,0,P6)
	.PVRNG(PVCRNG,NAPORT,0,P7)
	.PVRNG(PVCRNG,NAPORT,0,P8)
	.PVRNG(PVCRNG,NAPORT,0,P9)
	.PVRNG(PVCRNG,NAPORT,0,PA)
	.PVRNG(PVCRNG,NAPORT,0,PB)
	.PVRNG(PVCRNG,NAPORT,0,PC)
	.PVRNG(PVCRNG,NAPORT,0,PD)
	.PVRNG(PVCRNG,NAPORT,0,PE)
	.PVRNG(PVCRNG,NAPORT,0,PF)
	 ELSE
	ERROR(PVCRNG -- No ASYNC ports - Ignored,0)
	 EI	:NAPORT
]


:	SPVRNG(Rp...)	Declare SIO PVC ports

SPVRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [ P.FIX
	 IF	NSPORT
	.PVRNG(SPVRNG,NSPORT,.SPORT,P0)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P1)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P2)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P3)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P4)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P5)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P6)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P7)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P8)
	.PVRNG(SPVRNG,NSPORT,.SPORT,P9)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PA)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PB)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PC)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PD)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PE)
	.PVRNG(SPVRNG,NSPORT,.SPORT,PF)
	 ELSE
	ERROR(SPVRNG -- No SIO ports - Ignored,0)
	 EI	:NSPORT
]

:  break up checking routines to prevent 640 char macro (too big)

.QVAID  MACRO(QV)[
	IF	QV&AID
	 IF	1-(TSMASK&QV)^-TS)
	 ERROR(NAME - AID requested but no TID specified,1)
	 EI
	EI	:QV&AID
]

.QVALO  MACRO(QV)[
	IF	ALO&QV
	 IF	RCV&QV
	  ERROR(NAME - ALO and RCV mutually exclusive options,1)
	 EI	:RCV&QV
	 IF	PCO&QV
	  IF	SLO&QV
	   ERROR(NAME - PCO and SLO mutually exclusive options,1)
	  EI	:PCO&QV
	 EI	:SLO&QV
	 IF	1-((PCO&QV)!(SLO&QV))
	  ERROR(NAME - ALO specified but no SLO or PCO,1)
	 EI	:1-((PCO&QV)!(SLO&QV))
	EI	:ALO&QV
        IF      (QV&PCO)!(QV&SLO)
         IF     1-(ALO&QV)
          ERROR(NAME - PCO or SLO specified but no ALO,1)
         EI     :1-(ALO&QV)
        EI      :(QV&PCO)!(QV&SLO)
]

.QVTRS   MACRO(QV)[
        IF      QV&NOTRS :notrs
        ERROR(NOTRS is no longer a valid option - default is TRS)
        EI
]


: **	.PVCDF(...)	Define macro for setting up and checking PVC port values.

.PVCDF	MACRO(NAME,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC) [
Q0	EQ	P0
Q1	EQ	P1
Q2	EQ	P2
Q3	EQ	P3
Q4	EQ	P4
Q5	EQ	P5
Q6	EQ	P6
Q7	EQ	P7
Q8	EQ	P8
Q9	EQ	P9
QA	EQ	PA
QB	EQ	PB
QC	EQ	PC

QV	EQ	Q0!Q1!Q2!Q3!Q4!Q5!Q6!Q7!Q8!Q9!QA!QB!QC

        .QVAID(QV)
        .QVALO(QV)
        .QVTRS(QV)
]


:	Define macro for setting ASYNC PVC default values.
PVCDF	MACRO(Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC) [ P.FIX
	IF	\PVCDEF
	 WARNING(PVCDF already defined)
	EI	:\PVCDEF
	.PVCDF(PVCDF,Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC)
	IF	QV&NO.A
	 ERROR(PVCDF -- Non-ASYNC TID specified - Ignored,0)
	ELSE
PVCDEF	 EQ	QV
	 GL	PVCDEF
	EI
]


: **	.PXRNG(NAM,RNG,OFF,P,VAL)  Internal macro to perform all processing
:				   for range parameter P in macro NAM, with
:				   range RNG, and offset OFF.  Sets PVCXp
:				   to VAL.  Defined to reduce macro storage
:				   requirements.

.PXRNG	MACRO(NAM,RNG,OFF,P,VAL) [
	.RANGE(NAM,A,RNG,P)
QI	EQ	QI+OFF
	IF	QR
	 RE	QR
	  IF	.BIT.(PVCG,QI)
	  ELSE
	   .S1BIT(PVCG,QI)
PVCCNT	   EQ	PVCCNT+1
	  EI
	  IF	\PVCX|QI|
	   ERROR(NAM - Port ,1)
	   NUMBER $A QI-OFF
	   ERRLIN( already defined,0)
	  ELSE
PVCX|QI|   EQ	VAL
	  EI
QI	 EQ	QI+1
	 ER
	EI
]


:	Define PVCEX macro, which specifies exceptions to PVCDF options.
:	The first argument is the exception port number range, in decimal.
PVCEX	MACRO(Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD) [ P.FIX
	 IF	NAPORT
	.PVCDF(PVCEX{Y0},Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD)
	IF	QV&NO.A
	ERROR(PVCEX{Y0} -- TID specified is not supported - Ignored,0)
	ELSE
	.PXRNG(PVCEX{Y0},NAPORT,0,Y0,QV)
	EI
	 ELSE
	ERROR(PVCEX -- No ASYNC ports - Ignored,0)
	 EI
]


:	Define SPVCEX macro, which specifies exceptions to PVCDF options
:	for SIO ports.  The first argument is the exception port number
:	range, in decimal.
SPVCEX	MACRO(Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD) [ P.FIX
	 IF	NSPORT
	.PVCDF(SPVCEX{Y0},Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,YA,YB,YC,YD)
	IF	QV&NO.S
	ERROR(SPVCEX{Y0} -- TID specified is not supported - Ignored,0)
	ELSE
QV	EQ	QV+TIDSIO		:bias range
	.PXRNG(SPVCEX{Y0},NSPORT,.SPORT,Y0,QV)
	EI
	 ELSE
	ERROR(SPVCEX -- No SIO ports - Ignored,0)
	 EI
]


:	Define text macros so user may supply text for PVC conditions.  The
:	PTEXT macro is supplied for the user to specify a PVC message number,
:	and the text that the PVC process should use for the message.  If no
:	PTEXT macro is specified for a PVC message, default text is used.
:	The PVC messages and their defaults are:
:	1. CIRCUIT BUILDING IN PROGRESS
:	2. CIRCUIT LOST - REBUILDING
:	3. ALO USER NAME CONFIGURATION ERROR
:	4. ALO PASSWORD CONFIGURATION ERROR
:	5. ALO LOGIN STRING CONFIGURATION ERROR
:	6. CIRCUIT LOST, WILL TRY LATER

:	The PTEXT macro call is of the format:
:	PTEXT(<MESSAGE NUMBER>,<MESSAGE TEXT>)

PTEXT	MACRO(Y1,Y2) [
PVCMX`Y1 EQ	1
PTEXT`Y1 MACRO [
	AC	/"8D"8A/
	AC	/Y2/
	AC	/"8D"8A"00/
	]
	]


:	The STEXT macro is supplied for the user to define optional security
:	characters which will be included in the generated user name and
:	password for ports with the ALO option.  The format of the macro
:	call is:

:		STEXT(<CHARS>)

:	Where <CHARS> is a character string of from 1 to 4 characters, which
:	are legal ASCII user name and password values.
:	Defines symbol PVCS0 so PVC code can detect this option.

STEXT	MACRO(Y1) [
PVCS0	EQ	1
STEXT0	MACRO [
	AC	/Y1/
	]
	]

:	The UTEXT macro permits a specific login string (user name and
:	password) may be supplied to be used instead of the generated
:	user name and password.  The format of the macro call is:
:	UTEXT(<CHARS>)
:	Where <CHARS> is any login string.

	GLOBAL(NUTXT,0)
UTEXT	MACRO(Y1) [
UTXM|NUTXT|	MACRO [
	AC	/Y1/
	BC	0
	]
NUTXT	EQ	NUTXT+1
	]


: **	.UTRNG(NAM,RNG,OFF,P)	Internal macro to perform all processing
:				for parameter P in macro NAM, with range
:				RNG, and offset OFF.  Defined to reduce
:				macro storage requirements.

.UTRNG	MACRO(NAM,RNG,OFF,P) [
	.RANGE(NAM,A,RNG,P)
	IF	OFF
QI	 EQ	QI+OFF
	EI
	.SETNM(UTAP,NUTXT-1)
]

:	The UTXRNG macro defines the ports which will use the most recently
:	defined UTEXT login string.  Each parameter is either a single port
:	or a range seperated by a minus sign.  Up to 16 parameters may be
:	specified in each call.  Any PVC ports not listed in any UTXRNG call
:	will default to the standard (computed) username and password.

UTXRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [ P.FIX
	 IF	NAPORT
	.UTRNG(UTXRNG,NAPORT,0,P0)
	.UTRNG(UTXRNG,NAPORT,0,P1)
	.UTRNG(UTXRNG,NAPORT,0,P2)
	.UTRNG(UTXRNG,NAPORT,0,P3)
	.UTRNG(UTXRNG,NAPORT,0,P4)
	.UTRNG(UTXRNG,NAPORT,0,P5)
	.UTRNG(UTXRNG,NAPORT,0,P6)
	.UTRNG(UTXRNG,NAPORT,0,P7)
	.UTRNG(UTXRNG,NAPORT,0,P8)
	.UTRNG(UTXRNG,NAPORT,0,P9)
	.UTRNG(UTXRNG,NAPORT,0,PA)
	.UTRNG(UTXRNG,NAPORT,0,PB)
	.UTRNG(UTXRNG,NAPORT,0,PC)
	.UTRNG(UTXRNG,NAPORT,0,PD)
	.UTRNG(UTXRNG,NAPORT,0,PE)
	.UTRNG(UTXRNG,NAPORT,0,PF)
	 ELSE
	ERROR(UTXRNG -- No ASYNC ports - Ignored,0)
	 EI
]


:	The SUTXRG macro is like UTXRNG, except it applies to SIO ports.

SUTXRG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [ P.FIX
	 IF	NSPORT
	.UTRNG(SUTXRG,NSPORT,.SPORT,P0)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P1)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P2)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P3)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P4)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P5)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P6)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P7)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P8)
	.UTRNG(SUTXRG,NSPORT,.SPORT,P9)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PA)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PB)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PC)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PD)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PE)
	.UTRNG(SUTXRG,NSPORT,.SPORT,PF)
	 ELSE
	ERROR(SUTXRG -- No SIO ports - Ignored,0)
	 EI
]


:	The MUTXRG macro is like UTXRNG, except it applies to MPVC ports.

MUTXRG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [ P.FIX
	 IF	NMPVC
	.UTRNG(MUTXRG,NMPVC,.MPORT,P0)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P1)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P2)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P3)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P4)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P5)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P6)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P7)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P8)
	.UTRNG(MUTXRG,NMPVC,.MPORT,P9)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PA)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PB)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PC)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PD)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PE)
	.UTRNG(MUTXRG,NMPVC,.MPORT,PF)
	 ELSE
	ERROR(MUTXRG -- No MPVC ports - Ignored,0)
	 EI
]
	SUBTTL	MPVC MACROS



: **	The MPVCUS macro is used to specify a MPVC username match string.

:	The MPVCUS macro invocation is of the format:
:	MPVCUS(MPVC port range,<MPVCUS STRING>)

:	Where the MPVC port range defines the context of the MPVCUS STRING.
:	The MPVCUS STRING may contain the following "wild" characters:
:	"|"	Match ANY valid user-name character.  Will not match
:		user-name terminator characters (":", "semi-:", <CR>).
:	"}"	END-OF-MPVCUS!  Encountering this character during the
:		matching process signals successful matching of username,
:		even if entire username has not yet been scanned.  (Also
:		matches user-name terminator characters).

:	Each invocation of the MPVCUS macro causes the creation of a
:	new macro .MMi, i=0, .NMUS...also variables .MMBi, .MMLi

MPVCUS	MACRO(Y1,Y2) [ P.FIX
	IF	NMPVC
	 .RANGE(MPVCUS,A,NMPVC,Y1)
	 .R.BIT(.MPMU,Y1)
	 IF	QR
.NMUS	  EQ	.NMUS+1
.MMB|.NMUS| EQ	QI
.MML|.NMUS| EQ	QI+QR-1
	  GL	.MMB|.NMUS|,.MML|.NMUS|
.MM|.NMUS| MACRO [ AC /Y2/; BC 0 ]
	 EI
	ELSE
	 ERROR(MPVCUS invoked with NMPVC = 0,0)
	EI
	]


: **	The MPVCFO macro is used to specify a MPVC-port format conventions.

:	The MPVCFO macro invocation is of the format:
:	MPVCFO(MPVC port #,BID,SID,EID,SUC,FAI,IN)

:	Where:
:		MPVC port # -	MPVC port to which this set of format
:					conventions is assigned.
:		BID -		Block-ID...numeric value of a single
:					character used to delimit
:					MPVC-channel blocks.
:		SID -		Signal-ID...Numeric value of a single
:					character used to delimit
:					MPVC-channel signals.
:		EID -		Escape-ID...numeric value of a single
:					character used to escape MPVC-
:					channel data.
:		SUC -		Success-message...form "MPVCx", output on
:					successful MPVC connection.
:		FAI -		Failure-message...form "MPVCx", output on
:					unsuccessful MPVC connection.
:		IN -		Inactivity timeout.

:	Each invocation of the MPVCUS macro causes the creation of a
:	new macro .MMFi, i=port #

:	(here is what the macro does:
:		1.	Verify MPVC usage,
:		2.	Verfiy MPVC port usage,
:		3.	Verfiy MPVC Success-text has already been defined,
:		4.	Verfiy MPVC Failure-text has already been defined,
:		5.	Then define macro .MMF, which in turn:
:			1.	saves text-string for Success if not already done,
:			2.	saves text-string for Failure if not already done,
:			3.	builds a table entry, of form:
:				.MPFn	WC	SUCcess text-string,
:					WC	FAIlure text-string,
:					HC	INactivity timeout,
:					BC	ESCape character,
:					BC	BLock character,
:					BC	SIgnal character.
:			5.	kills various macros.

MPVCFO	MACRO(Y1,BID,SID,EID,SUC,FAI,IN) [ P.FIX
	IF	NMPVC
	 IF	Y1+1-NMPVC
	  ERROR(MPVCFO -- Port number Y1 exceeds NMPVC,0)
	 ELSE	1-\SUC`X
	  ERROR(MPVCFO -- Success text must be defined before invocation,0)
	 ELSE	1-\FAI`X
	  ERROR(MPVCFO -- Failure text must be defined before invocation,0)
	 ELSE	.BIT.(.MPMF,Y1)
	  .R1BIT(.MPMF,Y1)

:	Before building an entry for this MPVC port, check the
:	following:
:	 .That the ESCape, Block, and Signal Characters are defined.
:	 .That the ESCape, Block, and Signal Characters are different.
:	 .That the INactivity timer is defined and not Zero.
	  IF 1-\BID
	   ERROR(BLOCK character not defined for MPVC port Y1!!!)
	  ELSE
MP.B|Y1|	EQ	BID
	  EI

	  IF 1-\SID
	   ERROR(SIGNAL character not defined for MPVC port Y1!!!)
	  ELSE
MP.S|Y1|	EQ	BID
	  EI

	  IF 1-\EID
	   ERROR(ESCAPE character not defined for MPVC port Y1!!!)
	  ELSE
MP.E|Y1|	EQ	BID
	  EI


	  IF	1-((BID-SID)*(BID-SID))
	   ERROR(BLOCK and SIGNAL Characters are the same on MPVC port Y1!)
	  EI
	  IF	1-((BID-EID)*(BID-EID))
	   ERROR(BLOCK and ESCAPE Characters are the same on MPVC port Y1!)
	  EI
	  IF	1-((EID-SID)*(EID-SID))
	   ERROR(ESCAPE and SIGNAL Characters are the same on MPVC port Y1!)
	  EI
POMONA	EQ	IN
	  IF	1-POMONA
	   ERROR(INACTIVITY Timer either not defined or equals zero on port Y1!)
	  ELSE
MP.I|Y1|	EQ	IN
	  EI
.MMF|Y1|  MACRO [
	  IF	SUC`X-1
SUC	   SUC`M
	   KILL	SUC`M
SUC`X	   EQ	1
	  EI	:SUC`X-1
	  IF	FAI`X-1
FAI	   FAI`M
	   KILL	FAI`M
FAI`X	   EQ	1
	  EI	:FAI`X-1
.MPF|Y1|  WC	SUC,FAI
	  HC	IN
	  BC	EID
	  BC	BID
	  BC	SID
	  ]
	 ELSE	:.BIT.(.MPMF,Y1)
	  ERROR(MPVCFO -- Multiple invocation for port ,1)
	  NUMBER	$A Y1
	  ERREND(`, Ignored)
	 EI	:.BIT.(.MPMF,Y1)
	ELSE
	 ERROR(MPVCFO Invoked with NMPVC = 0)
	EI
	]
	SUBTTL	NON-TRANSPARENT VIRTUAL TELEX MACRO

:	The ANSBAK macro allows a user to specify answer back message
	GL	SEEGEN
	IF	1-\SEEGEN		:if SEEGEN not defined
SEEGEN 	EQ	0			:  then define and set to 0
	EI	:1-\SEEGEN

:	TABLE BUILDING LOOP MACRO
:	defines a macro for later use of the form tbln|xn| for building
:	table entries of a fixed length xs.
: 	 tbln  -- 1 to 3 character table name
:	 xn    -- entry number in table (loop variable)
:	 xs    -- size in bytes of table entry
:	 xtext -- ascii text table entry

TBLENT	MACRO(tbln,xn,xs,xtext)[

tbln|xn|	MACRO[
Q	AC	/xtext/
Q	EQ	.-Q
 IF .GT.(Q,xs)
	REMARK %>>> ERROR **** TABLE ENTRY OVERFLOW -- tbln
	NUMBER xn;
	REMARK %>>>	  **** xtext%
 ELSE	
  IF .LT.(Q,xs)
   RE xs-Q
	BC	0		:fill with zeroes
   ER	:xs-Q
  EI	:.LT.(Q,xs)
 EI	:.GT.(Q,XS)
]
]

:	ABACK(pn,anbk) --assign stored answerback to this
:	port. Special characters: "8d = .CR., "8A = .LF.,
:	"9D = LTRS, "9C = FIGS, "DD = ')'. This answerback
:	will be translated to BAUDOT when necessary, with
:	proper LTRS/FIGS shifts added, so when counting
:	answerback characers, include these.
:	i.e., 'TYM001 CUP" = [LTR]TYM[FIG]001 [LTR]CUP

	GL	ASBLEN
ASBLEN	EQ	$A 20

ABACK	MACRO(pn,anbk)[	

pn1	EQ	 $A pn
 IF SEEGEN;  REMARK %ABACK(pn1,anbk); EI
	GL	ASF|pn1|,pn1
ASF|pn1|	EQ	pn1*ASBLEN

:	internal macro ASBpn1 for building answerback table

	TBLENT(ASB,pn1,ASBLEN,anbk)

:	internal macro ANXpn1 for seegen information later

	IF	SEEGEN
ANX|pn1|	MACRO[
	REMARK % Answerback: (anbk)
]
	EI	:SEEGEN
]


	SUBTTL	OTHER MACROS


:	The LTEXT macro invocation is of the format:
:	LTEXT(<MESSAGE NAME>,<MESSAGE TEXT>)

:	Where the MESSAGE NAME defines the context of the MESSAGE TEXT.
:	The MESSAGE NAME may not be greater than 5 characters.

:	Currently supported contexts are:
:	1. ULMSG - Text is inserted in front of 'PLEASE LOG IN:' prompt.
:	2. TIDM - Text is substituted for 'PLEASE TYPE YOUR TERMINAL
:		IDENTIFIER' message.
:       3.  MPVCx where x is used to differenciate between messages.
:       added definable delays for TIDM.  Y3 is primary delay.  Y4 is
:       for how many characters.  Y5 is the secondary delay  *500.sdw

        GL      ULMSG,TIDM
TIDM    EQ      1
ULMSG   EQ      0

LTEXT	MACRO(Y1,Y2,Y3,Y4,Y5) [
	GL	Y1`X
Y1`X	EQ	2			:Let code know this macro called
Y1`M	MACRO [
	AC	/"0D"0A/
	AC	/Y2/
	BC	0
	]
       IF \Y1
        IF  Y1   :TIDM
          IF  Y4+1   :number of chars 
TIDLG1  EQ      $A Y4 2			:6.02 cab
          ELSE    :negative so they asked for all to have primary delay
TIDLG1  EQ      100
          EI
TID.D1  EQ      $A Y3 45		:6.02 cab 
TID.D2  EQ      $A Y5 3			:6.02 cab
  IF TID.D1-80 ; ERROR(d1 TID delay cannot exceed 128 thirtieths of a sec) ; EI
  IF TID.D2-80 ; ERROR(d2 TID delay cannot exceed 128 thirtieths of a sec) ; EI
        EI
       EI
]

: **	.SPRNG(NAM,RNG,LABEL,P)	Internal macro to perform all range processing
:				for range parameter P in macro NAM, with valid
:				port range RNG, and bit array LABEL.  Bits are
:				turned ON.  Designed to reduce macro storage
:				requirements.

.SPRNG	MACRO(NAM,RNG,LABEL,P) [ C.FIX
	.RANGE(NAM,A,RNG,P)
	.S.BIT(LABEL)
]




: **	.RPRNG(NAM,RNG,LABEL,P)	Internal macro to perform all range processing
:				for range parameter P in macro NAM, with valid
:				port range RNG, and bit array LABEL.  Bits are
:				turned OFF!  Designed to reduce macro storage
:				requirements.

.RPRNG	MACRO(NAM,RNG,LABEL,P) [ C.FIX
	.RANGE(NAM,A,RNG,P)
	.R.BIT(LABEL)
]


:	TID120(Rp...)	Define async ports which are to receive 120 cps
:			TID message.

TID120	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.SPRNG(TID120,NAPORT,.120T,P0)
	.SPRNG(TID120,NAPORT,.120T,P1)
	.SPRNG(TID120,NAPORT,.120T,P2)
	.SPRNG(TID120,NAPORT,.120T,P3)
	.SPRNG(TID120,NAPORT,.120T,P4)
	.SPRNG(TID120,NAPORT,.120T,P5)
	.SPRNG(TID120,NAPORT,.120T,P6)
	.SPRNG(TID120,NAPORT,.120T,P7)
	.SPRNG(TID120,NAPORT,.120T,P8)
	.SPRNG(TID120,NAPORT,.120T,P9)
	.SPRNG(TID120,NAPORT,.120T,PA)
	.SPRNG(TID120,NAPORT,.120T,PB)
	.SPRNG(TID120,NAPORT,.120T,PC)
	.SPRNG(TID120,NAPORT,.120T,PD)
	.SPRNG(TID120,NAPORT,.120T,PE)
	.SPRNG(TID120,NAPORT,.120T,PF)
]

:   TID240 and TID480 added in v5.00 by sdw
:	TID240(Rp...)	Define async ports which are to receive 240 cps
:			TID message.

TID240	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.SPRNG(TID240,NAPORT,.240T,P0)
	.SPRNG(TID240,NAPORT,.240T,P1)
	.SPRNG(TID240,NAPORT,.240T,P2)
	.SPRNG(TID240,NAPORT,.240T,P3)
	.SPRNG(TID240,NAPORT,.240T,P4)
	.SPRNG(TID240,NAPORT,.240T,P5)
	.SPRNG(TID240,NAPORT,.240T,P6)
	.SPRNG(TID240,NAPORT,.240T,P7)
	.SPRNG(TID240,NAPORT,.240T,P8)
	.SPRNG(TID240,NAPORT,.240T,P9)
	.SPRNG(TID240,NAPORT,.240T,PA)
	.SPRNG(TID240,NAPORT,.240T,PB)
	.SPRNG(TID240,NAPORT,.240T,PC)
	.SPRNG(TID240,NAPORT,.240T,PD)
	.SPRNG(TID240,NAPORT,.240T,PE)
	.SPRNG(TID240,NAPORT,.240T,PF)
]

:	TID480(Rp...)	Define async ports which are to receive 480 cps
:			TID message.

TID480	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.SPRNG(TID480,NAPORT,.480T,P0)
	.SPRNG(TID480,NAPORT,.480T,P1)
	.SPRNG(TID480,NAPORT,.480T,P2)
	.SPRNG(TID480,NAPORT,.480T,P3)
	.SPRNG(TID480,NAPORT,.480T,P4)
	.SPRNG(TID480,NAPORT,.480T,P5)
	.SPRNG(TID480,NAPORT,.480T,P6)
	.SPRNG(TID480,NAPORT,.480T,P7)
	.SPRNG(TID480,NAPORT,.480T,P8)
	.SPRNG(TID480,NAPORT,.480T,P9)
	.SPRNG(TID480,NAPORT,.480T,PA)
	.SPRNG(TID480,NAPORT,.480T,PB)
	.SPRNG(TID480,NAPORT,.480T,PC)
	.SPRNG(TID480,NAPORT,.480T,PD)
	.SPRNG(TID480,NAPORT,.480T,PE)
	.SPRNG(TID480,NAPORT,.480T,PF)
]
:	INITANSWER(Rp...)  Define which ports are not to be hung at
:			startup.  Somewhat useful for hardwired ports *600.sdw
INITAN	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.SPRNG(INITAN,NAPORT,.ANSW.P0)
	.SPRNG(INITAN,NAPORT,.ANSW.P1)
	.SPRNG(INITAN,NAPORT,.ANSW.P2)
	.SPRNG(INITAN,NAPORT,.ANSW.P3)
	.SPRNG(INITAN,NAPORT,.ANSW.P4)
	.SPRNG(INITAN,NAPORT,.ANSW.P5)
	.SPRNG(INITAN,NAPORT,.ANSW.P6)
	.SPRNG(INITAN,NAPORT,.ANSW.P7)
	.SPRNG(INITAN,NAPORT,.ANSW.P8)
	.SPRNG(INITAN,NAPORT,.ANSW.P9)
	.SPRNG(INITAN,NAPORT,.ANSW.PA)
	.SPRNG(INITAN,NAPORT,.ANSW.PB)
	.SPRNG(INITAN,NAPORT,.ANSW.PC)
	.SPRNG(INITAN,NAPORT,.ANSW.PD)
	.SPRNG(INITAN,NAPORT,.ANSW.PE)
	.SPRNG(INITAN,NAPORT,.ANSW.PF)
]
: 4.03 LH
:	BAUDQS(Rp...)   Define async ports which have "ASCII to BAUDOT"
:			untranslateable characters sent as BAUDOT
:			question marks (?) instead of discarding them.

	GLOBAL(.BQSP,0)
BAUDQS  MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.SPRNG(BAUDQS,NAPORT,.BQSP,P0)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P1)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P2)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P3)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P4)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P5)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P6)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P7)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P8)
	.SPRNG(BAUDQS,NAPORT,.BQSP,P9)
	.SPRNG(BAUDQS,NAPORT,.BQSP,PA)
	.SPRNG(BAUDQS,NAPORT,.BQSP,PB)
	.SPRNG(BAUDQS,NAPORT,.BQSP,PC)
	.SPRNG(BAUDQS,NAPORT,.BQSP,PD)
	.SPRNG(BAUDQS,NAPORT,.BQSP,PE)
	.SPRNG(BAUDQS,NAPORT,.BQSP,PF)
]

: 4.01U
:	TIDSPP(Rp...)	Define async ports which are to receive
:			TID message forced to space parity.

TIDSPP	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.SPRNG(TIDSPP,NAPORT,.SPPT,P0)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P1)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P2)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P3)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P4)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P5)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P6)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P7)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P8)
	.SPRNG(TIDSPP,NAPORT,.SPPT,P9)
	.SPRNG(TIDSPP,NAPORT,.SPPT,PA)
	.SPRNG(TIDSPP,NAPORT,.SPPT,PB)
	.SPRNG(TIDSPP,NAPORT,.SPPT,PC)
	.SPRNG(TIDSPP,NAPORT,.SPPT,PD)
	.SPRNG(TIDSPP,NAPORT,.SPPT,PE)
	.SPRNG(TIDSPP,NAPORT,.SPPT,PF)
]


:	HD202(Rp...)	Define async ports which are to be configured
:			for HD202 half-duplex modems.
	GLOBAL(.2HD,0)			:symbol set to 1 if HD202 invoked

HD202	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
.2HD	EQ	1
	.SPRNG(HD202,NAPORT,.2HD,P0)
	.RPRNG(HD202,NAPORT,.BSY,P0)
	.RPRNG(HD202,NAPORT,.CP.,P0)
	.SPRNG(HD202,NAPORT,.2HD,P1)
	.RPRNG(HD202,NAPORT,.BSY,P1)
	.RPRNG(HD202,NAPORT,.CP.,P1)
	.SPRNG(HD202,NAPORT,.2HD,P2)
	.RPRNG(HD202,NAPORT,.BSY,P2)
	.RPRNG(HD202,NAPORT,.CP.,P2)
	.SPRNG(HD202,NAPORT,.2HD,P3)
	.RPRNG(HD202,NAPORT,.BSY,P3)
	.RPRNG(HD202,NAPORT,.CP.,P3)
	.SPRNG(HD202,NAPORT,.2HD,P4)
	.RPRNG(HD202,NAPORT,.BSY,P4)
	.RPRNG(HD202,NAPORT,.CP.,P4)
	.SPRNG(HD202,NAPORT,.2HD,P5)
	.RPRNG(HD202,NAPORT,.BSY,P5)
	.RPRNG(HD202,NAPORT,.CP.,P5)
	.SPRNG(HD202,NAPORT,.2HD,P6)
	.RPRNG(HD202,NAPORT,.BSY,P6)
	.RPRNG(HD202,NAPORT,.CP.,P6)
	.SPRNG(HD202,NAPORT,.2HD,P7)
	.RPRNG(HD202,NAPORT,.BSY,P7)
	.RPRNG(HD202,NAPORT,.CP.,P7)
	.SPRNG(HD202,NAPORT,.2HD,P8)
	.RPRNG(HD202,NAPORT,.BSY,P8)
	.RPRNG(HD202,NAPORT,.CP.,P8)
	.SPRNG(HD202,NAPORT,.2HD,P9)
	.RPRNG(HD202,NAPORT,.BSY,P9)
	.RPRNG(HD202,NAPORT,.CP.,P9)
	.SPRNG(HD202,NAPORT,.2HD,PA)
	.RPRNG(HD202,NAPORT,.BSY,PA)
	.RPRNG(HD202,NAPORT,.CP.,PA)
	.SPRNG(HD202,NAPORT,.2HD,PB)
	.RPRNG(HD202,NAPORT,.BSY,PB)
	.RPRNG(HD202,NAPORT,.CP.,PB)
	.SPRNG(HD202,NAPORT,.2HD,PC)
	.RPRNG(HD202,NAPORT,.BSY,PC)
	.RPRNG(HD202,NAPORT,.CP.,PC)
	.SPRNG(HD202,NAPORT,.2HD,PD)
	.RPRNG(HD202,NAPORT,.BSY,PD)
	.RPRNG(HD202,NAPORT,.CP.,PD)
	.SPRNG(HD202,NAPORT,.2HD,PE)
	.RPRNG(HD202,NAPORT,.BSY,PE)
	.RPRNG(HD202,NAPORT,.CP.,PE)
	.SPRNG(HD202,NAPORT,.2HD,PF)
	.RPRNG(HD202,NAPORT,.BSY,PF)
	.RPRNG(HD202,NAPORT,.CP.,PF)
]


:	NOBUSY(Rp...)	Define async ports which are NOT to be considered
:			for NOBUSY-OUT control (e.g. non-VADIC modems).

NOBUSY	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.RPRNG(NOBUSY,NAPORT,.BSY,P0)
	.RPRNG(NOBUSY,NAPORT,.BSY,P1)
	.RPRNG(NOBUSY,NAPORT,.BSY,P2)
	.RPRNG(NOBUSY,NAPORT,.BSY,P3)
	.RPRNG(NOBUSY,NAPORT,.BSY,P4)
	.RPRNG(NOBUSY,NAPORT,.BSY,P5)
	.RPRNG(NOBUSY,NAPORT,.BSY,P6)
	.RPRNG(NOBUSY,NAPORT,.BSY,P7)
	.RPRNG(NOBUSY,NAPORT,.BSY,P8)
	.RPRNG(NOBUSY,NAPORT,.BSY,P9)
	.RPRNG(NOBUSY,NAPORT,.BSY,PA)
	.RPRNG(NOBUSY,NAPORT,.BSY,PB)
	.RPRNG(NOBUSY,NAPORT,.BSY,PC)
	.RPRNG(NOBUSY,NAPORT,.BSY,PD)
	.RPRNG(NOBUSY,NAPORT,.BSY,PE)
	.RPRNG(NOBUSY,NAPORT,.BSY,PF)
]


:	NO.CP(Rp...)	Define async ports which do NOT support CP

NO.CP	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	.RPRNG(NO.CP,NAPORT,.CP.,P0)
	.RPRNG(NO.CP,NAPORT,.CP.,P1)
	.RPRNG(NO.CP,NAPORT,.CP.,P2)
	.RPRNG(NO.CP,NAPORT,.CP.,P3)
	.RPRNG(NO.CP,NAPORT,.CP.,P4)
	.RPRNG(NO.CP,NAPORT,.CP.,P5)
	.RPRNG(NO.CP,NAPORT,.CP.,P6)
	.RPRNG(NO.CP,NAPORT,.CP.,P7)
	.RPRNG(NO.CP,NAPORT,.CP.,P8)
	.RPRNG(NO.CP,NAPORT,.CP.,P9)
	.RPRNG(NO.CP,NAPORT,.CP.,PA)
	.RPRNG(NO.CP,NAPORT,.CP.,PB)
	.RPRNG(NO.CP,NAPORT,.CP.,PC)
	.RPRNG(NO.CP,NAPORT,.CP.,PD)
	.RPRNG(NO.CP,NAPORT,.CP.,PE)
	.RPRNG(NO.CP,NAPORT,.CP.,PF)
]




	GLOBAL(BAUDY,0)			:turn BAUDY off
	GLOBAL(BAUDA,0)			:turn BAUDA off
	GLOBAL(VTEXT,0)			:turn Video-text off
	GLOBAL(NHOST,0)			:start with zero hosts
	GLOBAL(STOP2,0)			:turn off 2 stop bits
	GLOBAL(TELEX,0)			:turn TELEX off
	GLOBAL(BTELEX,0)		:turn non-transparent TELEX off
	GLOBAL(IIX,0)			:turn IIX off
	GLOBAL(TTELEX,0)		:turn SPEEDLINK TELEX off **4.02 LH
	GLOBAL(CHIST,0)			:turn crash-history switch off **6.00 LH	
	GLOBAL(NCRSAV,3)		:number of crash tables **6.00 LH
	GLOBAL(EXCRSH,1)		:turn extended crash handling routine
					:on **6.00 LH
	GLOBAL(FREEZE,0)		:turn FREEZE switch off **6.00 LH

:	ACHOST(NO)	This macro is used to define another accounting
:			host

ACHOST	MACRO(P1) [
Q	EQ	$A P1
      IF      Q
.AHOST	EQ	Q
      ELSE
        ERROR(ACHOST -- host number MUST be > 0!)
        QUIT
      EI
]




: **	.AHRNG(NAM,RNG,OFF,P)	Internal macro to perform all processing
:				for parameter P in macro NAM, with range
:				RNG, and offset OFF.  Defined to reduce
:				macro storage requirements.

.AHRNG	MACRO(NAM,RNG,OFF,P) [ C.FIX
	.RANGE(NAM,A,RNG,P)
	IF	OFF
QI	 EQ	QI+OFF
	EI
	.SETNM(.ACH,.AHOST)
]


:	AHRNG(Rp...)	Specify Accounting-host range
AHRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.AHOST
	 .AHRNG(AHRNG,NAPORT,0,P0)
	 .AHRNG(AHRNG,NAPORT,0,P1)
	 .AHRNG(AHRNG,NAPORT,0,P2)
	 .AHRNG(AHRNG,NAPORT,0,P3)
	 .AHRNG(AHRNG,NAPORT,0,P4)
	 .AHRNG(AHRNG,NAPORT,0,P5)
	 .AHRNG(AHRNG,NAPORT,0,P6)
	 .AHRNG(AHRNG,NAPORT,0,P7)
	 .AHRNG(AHRNG,NAPORT,0,P8)
	 .AHRNG(AHRNG,NAPORT,0,P9)
	 .AHRNG(AHRNG,NAPORT,0,PA)
	 .AHRNG(AHRNG,NAPORT,0,PB)
	 .AHRNG(AHRNG,NAPORT,0,PC)
	 .AHRNG(AHRNG,NAPORT,0,PD)
	 .AHRNG(AHRNG,NAPORT,0,PE)
	 .AHRNG(AHRNG,NAPORT,0,PF)
	ELSE
	 ERROR(AHRNG used without previous declaration of ACHOST!)
	EI
]


:	SHRNG(Rp...)	Declare SIO ports which are to be assigned to
:				last previous ACHOST specified.

SHRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.AHOST
	 .AHRNG(SHRNG,NSPORT,.SPORT,P0)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P1)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P2)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P3)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P4)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P5)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P6)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P7)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P8)
	 .AHRNG(SHRNG,NSPORT,.SPORT,P9)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PA)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PB)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PC)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PD)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PE)
	 .AHRNG(SHRNG,NSPORT,.SPORT,PF)
	ELSE
	 ERROR(SHRNG used without previous declaration of ACHOST!)
	EI
]


:	MHRNG(Rp...)	Declare MPVC ports which are to be assigned to
:				last previous ACHOST specified.

MHRNG	MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF) [
	IF	\.AHOST
	 .AHRNG(MHRNG,NMPVC,.MPORT,P0)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P1)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P2)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P3)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P4)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P5)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P6)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P7)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P8)
	 .AHRNG(MHRNG,NMPVC,.MPORT,P9)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PA)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PB)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PC)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PD)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PE)
	 .AHRNG(MHRNG,NMPVC,.MPORT,PF)
	ELSE
	 ERROR(MHRNG used without previous declaration of ACHOST!)
	EI
]



:	ACCODE(NO)	No longer required!
ACCODE	MACRO[
	WARNING(ACCODE no longer required!)
]


:	ACRNG(Rp...)	No longer required!
ACRNG	MACRO[
	WARNING(ACRNG no longer required!)
]


:	SCRNG(Rp...)	No longer required!
SCRNG	MACRO[
	WARNING(SCRNG no longer required!)
]


:	MCRNG(Rp...)	No longer required!
MCRNG	MACRO[
	WARNING(MCRNG no longer required...ignored!)
]
	SUBTTL	Port-Addressing Macros and definitions


:	NPAPRT is the counter for the number of addressable port options
:	declared...it enables port addressing if >0

: ** .SETPA(NAM,RNG,OFF,PRTS,ADDR,HOST,ATTR,IIX,TXT)   Internal macro to set up
:				Port-addressing parameter structures.
:				NAM -	The name of the invoking macro (for
:					errors)
:				RNG -	The maximum valid port of range
:				OFF -	The offset between physical port and
:					specified port
:				PRTS -	The specified port (or range of ports)
:					to assign
:				ADDR -	The specified address (or range of
:					addresses) to assign
:				ATTR -	The attribute to assign to the host
:				IIX  -	1 if IIX host
:				TXT  -	Message sent to circuit originator
:			Invoked after configuration fixed.
:			Creates symbols PACnnn for each definition...Format:
:				HOST(16)|ADDR(8)|PORT(8)

.SETPA	MACRO(NAM,RNG,OFF,PRTS,ADDR,HOST,ATTR,IIX,TXT) [ C.FIX
.AHOST  EQ      $A HOST
        .H.DEF(.AHOST,IIX)		:6.02 cab
	IF	-H.POS
	 SERROR(NAM`: valid host number required,0)
	ELSE
	 .RANGE(NAM,A,256,ADDR)
QQI	 EQ	QI
QQR	 EQ	QR
	 .RANGE(NAM,A,RNG,PRTS)
	 IF	1-QQR
QQI	  EQ	QI
QQR	  EQ	0
	 EI	:QQR
	 IF	QR
QI	  EQ	QI+OFF
	  RE	QR
PAC|NPAPRT| EQ	$A (HOST^16)!(QQI^8)!QI
	  GL	PAC|NPAPRT|
	  IF	.BIT.(.AP,QI)
	  ELSE
HPRT|H.POS| EQ	HPRT|H.POS|+1
	   .S1BIT(.AP,QI)
	  EI	:.BIT.
QQR	   EQ	QQR-1
	   IF	QQR
QQI	    EQ	QQI+1
	   EI	:QQR
QI	   EQ	QI+1
NPAPRT	   EQ	NPAPRT+1
	  ER
NULL	  EQ	-1
ZERO	  EQ	0
ANY	  EQ	1
H.AD|H.POS| EQ	ATTR NULL
H.MS|H.POS| EQ 1
H.MG|H.POS| MACRO[   AC     /TXT/
]
	  GL	H.AD|H.POS|,H.MS|H.POS|
	  KILL	NULL,ZERO,ANY
	  .AHRNG(NAM,RNG,OFF,PRTS)
	 ELSE
	  SERROR(NAM`: bad port specification,0)
	 EI	:QI
	 KILL	QQI,QQR
	EI	:-H.POS
]


:	ADRPRT(PR,H,AR,AT)	Declare Port-addressable ASYNC ports
:			PR -	Decimal Port number (or range of ports)
:			H -	Decimal Host number
:			AR -	Decimal Address (or range of addresses)
:			AT -	Attribute (one of NULL,ZERO,ANY)
:			TXT-	Message sent to circuit originator

ADRPRT	MACRO(PR,H,AR,AT,TXT) [
	.SETPA(ADRPRT,NAPORT,0,PR,AR,H,AT,0,TXT)
]


:	SADPRT(PR,H,AR,AT)	Declare Port-addressable SIO ports
:			PR -	Decimal Port number (or range of ports)
:			H -	Decimal Host number
:			AR -	Decimal Address (or range of addresses)
:			AT -	Attribute (one of NULL,ZERO,ANY)
:			TXT-	Message sent to circuit originator

SADPRT	MACRO(PR,H,AR,AT,TXT) [
	.SETPA(SADPRT,NSPORT,.SPORT,PR,AR,H,AT,0,TXT)
]


        SUBTTL    OUTDIAL MACROS
:       
:       OUTHOST defines the host number and sets OUTDIA switch on.
:       OUTHOST may only define one host and can only be called once.
:               Also sets the number of command ports.
:               Third parameter sets how much time of inactivity before zapped
:               (Inactivity for command port)

        GLOBAL(OUTDIA,0)
        GLOBAL(OUTIME,$A 120)

OUTHOST MACRO(X,PO,TIME)[
        IF      TIME
OUTIME	EQ	$A TIME
        ELSE
OUTIME  EQ      $A 120
        EI
Q       EQ      $A X
        IF      OUTDIA
        ERROR(OUTHOST CAN ONLY BE USED ONCE)
        ELSE
OUTDIA  EQ      1
QQ      EQ      $A PO
        IF      1-QQ            :if no command port defined give them 16d
QQ      EQ      $A 16
        EI
        IF      QQ-20 
    WARNING(NO MORE THAN 32d OUTDIAL COMMAND PORTS ALLOWED - CHANGING TO 32d)
QQ      EQ      20
        EI
        DECLARE(DIAOUT,QQ)
        .H.DEF(Q,0)
        IF      -H.POS
        WARNING(ILLEGAL OUTDIAL HOST NUMBER DECLARED)
        ELSE
HPRT|H.POS| EQ  NOPORT
        GLOBAL(OH.POS,H.POS)
        EI
        GLOBAL(OTHOST,Q)      :know which is for Outdial vs prt adr
        EI
]

:       OUTGREET sets the outdial greeting message.
:

OUTGREET  MACRO(Q)[
        KILL    O.MSGM
O.MSGM  MACRO[
        AC      /"0D"0A/
        AC      /Q/
        AC      /"0D"0A/
	.MOPRM
]
]

:  OUTPROMPT(text) defines the outdial command prompt
:
OUTPROMPT  MACRO(Q)[
        KILL    .MOPRM
.MOPRM  MACRO[
        AC      /Q/
        BC      0
]
]

:	default greeting is "Public Outdial"
:	default prompt is ">"

	OUTGREET(Public Outdial)
	OUTPROMPT(>)

:       NUMASC  takes a three digit numeric area code and converts
:               it to its ascii equivalent.(415 to B4B1B5)
:
NUMASC  MACRO(Q)[
QQ      EQ      Q
QQQQ    EQ      Q
        IF      Q-0A00; REMARK%AREA CODE OUT OF RANGE - 
        NUMBER Q
        REMARK %
Q       EQ      0
        ELSE
QQQ     EQ      QQ/100
QQ      EQ      QQ-100*QQQ
Q       EQ      0B00000+QQQ*10000       :Bx0000
QQQ     EQ      QQ/10
QQ      EQ      QQ-10*QQQ
Q       EQ      Q+0B000+QQQ*100+0B0+QQ :Q + Bx00 + Bx
        IF      QQQ-1
        REMARK% THE NUMBER  
        NUMBER QQQQ
        REMARK    IS NOT AN AREA CODE.%
Q       EQ      0
        EI
        EI
]


:       .SORT(label,count)              internal macro which assumes the
:                                       value at label|count| is not order
:                                       and bubbles sorts it

.SORT   MACRO(LA,C)[
        IF      C
Q       EQ      0
        RE      C
        IF      LA|C|-LA|Q|
Q       EQ      Q+1
        ELSE
QQ      EQ      LA|C|
LA|C|   EQ      LA|Q|
LA|Q|   EQ      QQ
Q       EQ      Q+1
        EI
        ER
        EI   :C
]

:       .OTBAD(VALUE) is an internal macro which checks for
:                           OKINTER and calls .SORT

.OTBAD  MACRO(Q) [
        IF      Q
.OBNUM  EQ      .OBNUM+1
        GLOBAL(.OB|.OBNUM|,Q)
        NUMASC(.OB|.OBNUM|)
        .SORT(.OB,.OBNUM)
        ELSE 1+Q
        ELSE 2+Q
        GLOBAL(.OKINT,1)
        EI
]

:       OUTBAD is used to define prefixes which are not to be dialed
:               It calls a sort macro so all the elements are ordered

        GLOBAL(.OKINT,0)        :flag of international numbers
        GLOBAL(.OBNUM,-1)
        GLOBAL(OKINTER,-1)          :label used in tymfile for international
        GLOBAL(BADINTER,0)      :label to prevent international calls (default)

OUTBAD  MACRO(V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB,VC,VD,VE,VF) [
        IF      \.OG0
        ERROR(OUTBAD and OUTGOOD are mutually exclusive macros)
        ELSE
        .OTBAD(V0)
        .OTBAD(V1)
        .OTBAD(V2)
        .OTBAD(V3)
        .OTBAD(V4)
        .OTBAD(V5)
        .OTBAD(V6)
        .OTBAD(V7)
        .OTBAD(V8)
        .OTBAD(V9)
        .OTBAD(VA)
        .OTBAD(VB)
        .OTBAD(VC)
        .OTBAD(VD)
        .OTBAD(VE)
        .OTBAD(VF)
        EI  :\.OG0
]

:       .OTGOD          internal macro which orders prefixes for OUTGOOD
: 
.OTGOD  MACRO(Q)[
        IF      Q
.OGNUM  EQ      .OGNUM+1
        GLOBAL(.OG|.OGNUM|,Q)
        NUMASC(.OG|.OGNUM|)
        .SORT(.OG,.OGNUM)
        ELSE 1+Q
        ELSE 2+Q
        ERROR(OKINTER is only for OUTBAD macro)
        ELSE -Q
        ERROR(Only positive numbers are recognized by OUTGOOD)
        EI
]


:       OUTGOOD         accepts the list of prefixes that can be
:                       dialed.  No other prefixes will be dialed.

        GLOBAL(.OGNUM,-1)

OUTGOOD MACRO(V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,VA,VB,VC,VD,VE,VF)[
        IF      \.OB0
        ERROR(OUTBAD and OUTGOOD are mutually exclusive macros)
        ELSE
.OKINT  EQ      1 :actually international is not BAD
        .OTGOD(V0)
        .OTGOD(V1)
        .OTGOD(V2)
        .OTGOD(V3)
        .OTGOD(V4)
        .OTGOD(V5)
        .OTGOD(V6)
        .OTGOD(V7)
        .OTGOD(V8)
        .OTGOD(V9)
        .OTGOD(VA)
        .OTGOD(VB)
        .OTGOD(VC)
        .OTGOD(VD)
        .OTGOD(VE)
        .OTGOD(VF)
        EI
]



	SUBTTL	ACCOMMODATING TYMNET II
:	Set up defalt value of 0 for label, SOLOCS, which is
:	used to IF in the solo consat modules and IF out the
:	ISIS CONSAT environmentally dependant modules
	
	GLOBAL(SOLOCS,0)		:default to 0


:	!!!!--THE FOLLOWING SHOULD EVENTUALLY BE REMOVED--!!!!

:	INITIALIZE TAM VALUE TO 7 - ORIGIONALLY HARDCODED TO 7
:	THIS ALLOWS IT TO BE CHANGED TO A LOWER VALUE IN TYMFILE
:	FOR QUICK FIX FOR STAT-MUX REVERSE BACKPRESSURE PROBLEM
:	OF TNSC CUSTOMER

	GL	TAMVAL
TAMVAL	EQ	7
	SUBTTL	PAD RELATED FUNCTION MACROS

:	HANDY GLOBAL SYMBOLS
	GL	ON,OFF
ON	EQ	1
OFF	EQ	0

:	HANDY MACROS

::	.XX. MACROS
:	THE FOLLOWING MACROS EVALUATE THE RELATIONSHIP BETWEEN TWO
:	EXPRESSIONS.  THEY EVALUATE TO 0 FOR FALSE AND 1 FOR TRUE.
:	THEY MAY BE USED IN ANY EXPRESSION AND ARE PARTICULARLY USEFUL
:	FOR IF STATMENTS.
:
:	E.G.	IF	.LE.(.-LABEL,30)
:		REMARK %>>>> ERROR **** LABEL AREA NOT > 30 BYTES ****%
:		EI

	GL	.35.
.35.	EQ	$a 35
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
.EQ.	MACRO(P1,P2)[((((P1)-(P2))!((P2)-(P1)))%(1^.35.))^-.35.]
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]
.LT.	MACRO(P1,P2)[((P1)-(P2))^-.35.]
.GE.	MACRO(P1,P2)[((P2)-(P1)-1)^-.35.]
.LE.	MACRO(P1,P2)[((P1)-(P2)-1)^-.35.]


::	DO LOOP MACROS
:
:	.DOB.(di,i,j,k)	DO BEGIN
:		di	DO LOOP INDEX, ANY SYMBOL UP TO 4 CHARACTERS
:		i	INITIAL VALUE OF di, ANY LEGAL EXPRESSION, DEF 0
:		j	FINAL VALUE OF di, ANY LEGAL EXPRESSION,
:			DEFAULT 10 IN CURRENT RADIX
:		k	INCREMENT FOR di, ANY LEGAL EXPRESSION, DEF 1
:		di IS INCREMENTED BY k AND THEN A TEST IS MADE AT
:		THE END OF EACH LOOP.  IF di >= j THE LOOP IS EXITED.
:		THEREFORE, 1. THE LOOP IS ALWAYS EXECUTED AT LEAST ONE TIME,
:		2. THE LAST EXECUSION IS WITH di<j EXCEPT POSSIBLY FOR
:		ONE TRIP LOOPS.
:
:	.DOE.l	DO END FOR DO AT LEVEL l, l=0,1,...
:
:	.DOB. AND .DOE.l MAY START IN ANY COLUMN INCLUDING COLUMN 1.
:	INITIALLY, di WILL BE SET TO i.  IN ADDITION TO di, THREE OTHER
:	VARIABLES ARE DEFINED BY .DOB.
:		di.I	VALUE OF EXPRESSION i
:		di.J	VALUE OF EXPRESSION j
:		di.K	VALUE OF EXPRESSION k
:		.DOL.	CURRENT DO LEVEL (THEREFORE .DOE.|.DOL.| MAY
:			BE USED TO END THE CURRENT LOOP)
:
:	E.G.
:		.DOB.(Q,FIRST+7,LAST/2+4)
:			HC	Q
:		.DOE.0

	GL	.DOL.
.DOL.	EQ	-1	:INITIALLY NO LOOPS
.DOB.	MACRO(di,i,j,k)[
.DOL.	EQ	.DOL.+1
di	EQ	i 0
di`.I	EQ	di
di`.J	EQ	j 10
di`.K	EQ	k 1
	KILL	.DOE.|.DOL.|
.DOE.|.DOL.|	MACRO[
di	EQ	di+di`.K
  IF	1-(di`.J-di)
.DOL.	EQ	.DOL.-1
  EI
	ER	di`.J-di]
	RE]

:	The following list of macros allow ports to exhibit "enhanced"
:	functions. These functions include: building circuits to packet
:	mode interfaces (eg. X.25 and X.75), editing command strings
:	and user data, and dynamically altering terminal characteristics.
:		The main purpose of these enhanced functions is CONSAT
:	support of the CCITT X.3/X.28/X.29 Recommendations


GLOBAL(X3ON,OFF)
GLOBAL(ICATST,OFF)			:testing switch for inc calls
GLOBAL(DDTDIA,OFF)			:presence of debug routines


:	PADRELATEDFUNCTIONS(switch)	Turn on enhanced capabilities
:
:			The enhanced capabilities of the CONSAT may
:			be enabled by this option. These capabilities
:			include control of the full X.3 set of terminal
:			parameters, support of thre X.28 terminal protocol,
:			and the ability of the CONSAT to communicate
:			with other interfaces in the packet mode.
:
:			This macro must always be the first PAD macro in
:			the tymfile.  It calls  the Declaration macro C.FIX
:			that checks the	range in the DECLAR statements of
:			the tymfile and	calculates NPORT (NPORT = NAPORT+
:			NSPORT+NMPVC).  This prevents assembly errors if
:			PAD macros reference these sysmbols.
:
:		switch	- on or off
:
:		Default: off

PADRELATEDFUNCTIONS	MACRO(swi)[

X3ON	EQ	swi
]


::	MTEXT(num,text)		Redefine global numbered message text
:
:	num	MESSAGE NUMBER TO REDEFINE (DECIMAL)
:	text	NEW TEXT FOR MESSAGE, MUST BE < 240 CHARACTERS AND
:		FOLLOW THE NAD CONVENTION FOR STRING CONSTANTS
:		(This limitation allows for headers and
:		trailers which may not be changed)
:		BACKSLASH MAY ONLY BE ENTERED AS "DC.
:
:		DEFAULT: see x3usr.doc

MTEXT	MACRO(NUM,TXT)[
  IF	X3ON

.T|$A num|	MACRO	[AC \txt\]
GLOBAL(.D|$A num|,1)

  EI	:X3ON
]


::	PADCOMMANDS(type,p0,...,pe)	CCITT or TYMNET Extended PAD Operation
:
:			The ability of the CONSAT to understand Extended
:			commands is determined by this option.
:
:		type =0, if pure CCITT mode (no Extended commands)
:		     =1, if TYMNET Extended commands allowed
:
:		Default: 0 (pure CCITT)

PADCOM	MACRO(type,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON                                                    

    IF	type
.SPRNG(PADCOM,NPORT,.PTYP,p0)
.SPRNG(PADCOM,NPORT,.PTYP,p1)
.SPRNG(PADCOM,NPORT,.PTYP,p2)
.SPRNG(PADCOM,NPORT,.PTYP,p3)
.SPRNG(PADCOM,NPORT,.PTYP,p4)
.SPRNG(PADCOM,NPORT,.PTYP,p5)
.SPRNG(PADCOM,NPORT,.PTYP,p6)
.SPRNG(PADCOM,NPORT,.PTYP,p7)
.SPRNG(PADCOM,NPORT,.PTYP,p8)
.SPRNG(PADCOM,NPORT,.PTYP,p9)
.SPRNG(PADCOM,NPORT,.PTYP,pa)
.SPRNG(PADCOM,NPORT,.PTYP,pb)
.SPRNG(PADCOM,NPORT,.PTYP,pc)
.SPRNG(PADCOM,NPORT,.PTYP,pd)
.SPRNG(PADCOM,NPORT,.PTYP,pe)
    EI	:type

  EI	:X3ON
]


::	POSMODES(modes,p0,...,pe)	Select possible port modes of 
:					operation. These are:
:		modes	- 1, login mode
:			  2, command mode
:			  3, login and command modes
:
:		Default: 1 (login mode)

POSMODES	MACRO(modes,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF  	X3ON

    IF	modes-1			:command mode only or both
.SPRNG(POSMOD,NPORT,.CMMD,P0)
.SPRNG(POSMOD,NPORT,.CMMD,P1)
.SPRNG(POSMOD,NPORT,.CMMD,P2)
.SPRNG(POSMOD,NPORT,.CMMD,P3)
.SPRNG(POSMOD,NPORT,.CMMD,P4)
.SPRNG(POSMOD,NPORT,.CMMD,P5)
.SPRNG(POSMOD,NPORT,.CMMD,P6)
.SPRNG(POSMOD,NPORT,.CMMD,P7)
.SPRNG(POSMOD,NPORT,.CMMD,P8)
.SPRNG(POSMOD,NPORT,.CMMD,P9)
.SPRNG(POSMOD,NPORT,.CMMD,PA)
.SPRNG(POSMOD,NPORT,.CMMD,PB)
.SPRNG(POSMOD,NPORT,.CMMD,PC)
.SPRNG(POSMOD,NPORT,.CMMD,PD)
.SPRNG(POSMOD,NPORT,.CMMD,PE)
      IF	3-modes			:IF command mode only
.RPRNG(POSMOD,NPORT,.LGMD,p0)
.RPRNG(POSMOD,NPORT,.LGMD,p1)
.RPRNG(POSMOD,NPORT,.LGMD,p2)
.RPRNG(POSMOD,NPORT,.LGMD,p3)
.RPRNG(POSMOD,NPORT,.LGMD,p4)
.RPRNG(POSMOD,NPORT,.LGMD,p5)
.RPRNG(POSMOD,NPORT,.LGMD,p6)
.RPRNG(POSMOD,NPORT,.LGMD,p7)
.RPRNG(POSMOD,NPORT,.LGMD,p8)
.RPRNG(POSMOD,NPORT,.LGMD,p9)
.RPRNG(POSMOD,NPORT,.LGMD,pa)
.RPRNG(POSMOD,NPORT,.LGMD,pb)
.RPRNG(POSMOD,NPORT,.LGMD,pc)
.RPRNG(POSMOD,NPORT,.LGMD,pd)
.RPRNG(POSMOD,NPORT,.LGMD,pe)
.SPRNG(POSMOD,NPORT,.IPMD,p0)	:init command mode if login mode not allowed
.SPRNG(POSMOD,NPORT,.IPMD,p1)	:sdw500
.SPRNG(POSMOD,NPORT,.IPMD,p2)
.SPRNG(POSMOD,NPORT,.IPMD,p3)
.SPRNG(POSMOD,NPORT,.IPMD,p4)
.SPRNG(POSMOD,NPORT,.IPMD,p5)
.SPRNG(POSMOD,NPORT,.IPMD,p6)
.SPRNG(POSMOD,NPORT,.IPMD,p7)
.SPRNG(POSMOD,NPORT,.IPMD,p8)
.SPRNG(POSMOD,NPORT,.IPMD,p9)
.SPRNG(POSMOD,NPORT,.IPMD,pa)
.SPRNG(POSMOD,NPORT,.IPMD,pb)
.SPRNG(POSMOD,NPORT,.IPMD,pc)
.SPRNG(POSMOD,NPORT,.IPMD,pd)
.SPRNG(POSMOD,NPORT,.IPMD,pe)
    ELSE
      EI	:3-modes
  ELSE	modes			:IF login mode only...default already set
    EI	:modes-1

  EI	:X3ON                                                   
]


::	INITMODE(mode,p0,...,pe)	Initial port mode. May be:
:
:		mode	- 0, login
:			  1, command
:
:		Default: 0 (login mode)

INITMO	MACRO(mode,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON

    IF	mode
.SPRNG(INITMO,NPORT,.IPMD,p0)
.SPRNG(INITMO,NPORT,.IPMD,p1)
.SPRNG(INITMO,NPORT,.IPMD,p2)
.SPRNG(INITMO,NPORT,.IPMD,p3)
.SPRNG(INITMO,NPORT,.IPMD,p4)
.SPRNG(INITMO,NPORT,.IPMD,p5)
.SPRNG(INITMO,NPORT,.IPMD,p6)
.SPRNG(INITMO,NPORT,.IPMD,p7)
.SPRNG(INITMO,NPORT,.IPMD,p8)
.SPRNG(INITMO,NPORT,.IPMD,p9)
.SPRNG(INITMO,NPORT,.IPMD,pa)
.SPRNG(INITMO,NPORT,.IPMD,pb)
.SPRNG(INITMO,NPORT,.IPMD,pc)
.SPRNG(INITMO,NPORT,.IPMD,pd)
.SPRNG(INITMO,NPORT,.IPMD,pe)
.SPRNG(INITMO,NPORT,.CMMD,p0)
.SPRNG(INITMO,NPORT,.CMMD,p1)
.SPRNG(INITMO,NPORT,.CMMD,p2)
.SPRNG(INITMO,NPORT,.CMMD,p3)
.SPRNG(INITMO,NPORT,.CMMD,p4)
.SPRNG(INITMO,NPORT,.CMMD,p5)
.SPRNG(INITMO,NPORT,.CMMD,p6)
.SPRNG(INITMO,NPORT,.CMMD,p7)
.SPRNG(INITMO,NPORT,.CMMD,p8)
.SPRNG(INITMO,NPORT,.CMMD,p9)
.SPRNG(INITMO,NPORT,.CMMD,pa)
.SPRNG(INITMO,NPORT,.CMMD,pb)
.SPRNG(INITMO,NPORT,.CMMD,pc)
.SPRNG(INITMO,NPORT,.CMMD,pd)
.SPRNG(INITMO,NPORT,.CMMD,pe)
    EI	:mode

  EI	:X3ON
]


::	PROFILE(profno,p0,p1,...,pe)		Select an initial X.3 terminal
:						parameter profile
:
:		profno	-
:			  1, CCITT Simple Standard
:			  2, CCITT Transparent Standard
:
:			More can be defined in Tymfile
: 
:		DEFAULT:  1, CCITT Simple Standard,    

PROFIL	MACRO(prn,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON

    IF	1-prn
ERROR(profile number ,1)
	NUMBER	$A prn
ERREND( is invalid )
    ELSE	(NX3PRO+1)-prn
.VPRNG(PROFIL,NPORT,0,p0,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p1,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p2,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p3,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p4,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p5,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p6,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p7,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p8,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,p9,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,pa,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,pb,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,pc,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,pd,X3PR,prn)
.VPRNG(PROFIL,NPORT,0,pe,X3PR,prn)
    ELSE
ERROR(profile number ,1)
	NUMBER	$A prn
ERREND( does not exist)
    EI	:1-prn

  EI	:X30N
]


::	EDITBUFFERSIZE(size,p0,...,pe)		Size of editing buffer
:
:			This option determines the size of the editing
:			buffer used in command mode and, optionally,
:			in data mode (see DATABUFFER option).
:
:			If more than "size" characters are input in command
:			mode before a delimiter, an error message will be
:			issued to the port and the editing buffer must be 
:			reset (with a <CR>) before additional commands
:			will be accepted.
:
:			If more than "size" characters are input in data mode
:			and editing is enabled (X.3 parameter 15 is 1) and
:			no data forwarding conditions have resulted in data
:			being sent, then the entire editing buffer will be
:			sent and a new editing buffer created. This will
:			occur automatically and without the port being
:			notified.
:
:		size	- up to 255 characters
:
:		DEFAULT: 128 characters

EDITBU	MACRO(size,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON

    IF	$A256-size+1
.VPRNG(EDITBU,NPORT,0,p0,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p1,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p2,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p3,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p4,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p5,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p6,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p7,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p8,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,p9,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,pa,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,pb,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,pc,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,pd,EBSZ,$a size)
.VPRNG(EDITBU,NPORT,0,pe,EBSZ,$a size)
  ELSE
ERROR(Edit buffer size must be smaller than 256 characters)
    EI	:$A256-size+1

  EI	:X3ON
]


::	DATABUFFER(switch,p0,...,pe)		
:						
:			This option determines whether a port
:			may ever use the editing function on data.
:			(ie. whether X.3 parameter 15 may ever be equal to 1)
:
:		Obsoleted in version 6.00
:

DATABU	MACRO(switch,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON 

	REMARK	 >> The DATABUFFER macro has been obsoleted. <<%
	REMARK  >					      <%
	REMARK  >    For compatibility, data editing is      <%
	REMARK  >    always allowed if parameter 15 is 1.    <%
	REMARK  >					      <%

  EI	:X3ON
]


::	INCOMINGCALLS(init,ports,host,addresses,attribute)
:
:		 This was rewritten for ver 5.00 by sdw
:               The addressable ports capability is defined by this macro.
:               Incoming call are automatically answerred by ports configured
:               with the AUTO option (default).  The MANUAL or OFF option
:               has the port reject all incoming calls until the RECIEVE 
:               command is issued.  The REJECT command rejects incoming calls.
:               INCOMINGCALLS accepts the option, then a port range, then
:               the host number, then the address, then attribute.  If just
:               the option and a range is present then it will only set the 
:               option for those ports.

MANUAL	EQ	0	:set up mneumonics
AUTO	EQ	1

INCOMI	MACRO(init,pr,h,ar,at,TXT)[
  IF	X3ON

    IF	init			:if incoming calls permitted at all
.SPRNG(INCOMI,NPORT,.ICO,pr)	:...indicate they are allowed
    ELSE
.RPRNG(INCOMI,NPORT,.ICO,PR)    :or not allowed
    EI	:INIT
    IF   H   :if they are declaring the addressable ports
.SETPA(INCOMI,NAPORT,0,PR,AR,H,AT,1,TXT)
    EI	:H

  EI	:X3ON
]


::	COMTIMER(min,p0,...,pe)
:
:		The command timer is started when the port enters command
:		state and has no calls in progress.
:		The timer is halted when a call is being established.
:		On expiration of the timer, the port is given a diagnostic
:		 message and hung.
:
:		min	- timer value, in minutes
:
:		Range: 0 to 255 minutes (0 is off)
:
:		Default: 0 (off)

COMTIM	MACRO(min,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON

    IF	0FF-min
 .VPRNG(COMTIM,NPORT,0,p0,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p1,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p2,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p3,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p4,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p5,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p6,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p7,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p8,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,p9,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,pa,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,pb,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,pc,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,pd,COM.,min)                             :DLG 21-Jan-86
 .VPRNG(COMTIM,NPORT,0,pe,COM.,min)                             :DLG 21-Jan-86
    ELSE
 ERROR(COMTIMER setting must be less than 256 minutes)
    EI	:off-min

  EI	:X3ON
]


::	MAXASSEMBLYTIMER(min,p0,p1,...,pe)
:
:		The maximum period of time the CONSAT will wait before 
:		forwarding a packet is determined by this timer.
:		The timer is started upon receipt of the 1st character of a 
:		packet and halted when a packet is sent.
:
:		min	- maximum assembly timer value, in minutes
:
:		Range:	0 - 255 minutes
:
:		Default:	15 minutes

MAXASS	MACRO(min,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON

    IF	0FF-min
 .VPRNG(MAXASS,NPORT,0,p0,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p1,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p2,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p3,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p4,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p5,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p6,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p7,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p8,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,p9,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,pa,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,pb,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,pc,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,pd,MXA.,min)                             :DLG 21-Jan-86
 .VPRNG(MAXASS,NPORT,0,pe,MXA.,min)                             :DLG 21-Jan-86
    ELSE
 ERROR(MAXASSEMBLY setting must be less than 256 minutes)
    EI	:OFF-min

  EI	:X3ON
]


::	INACTIVITYTIMER(min,p0,p1,...,pe)
:		This timer may be used to disconnect a port which has
:		no calls in progress and has
:		been idle for a prescribed period of time.
:		The timer is started when no traffic is present either
:		to or from a port. It is halted upon transmission or
:		reception of data.
:		Upon timer expiration, an inactivity diagnostic message
:		is issued to a port (if X.3 parameter 6 <>0) and the
:		port is disconnected.
:
:		min	- inactivity timer value, in minutes
:
:		Range: 0 to 255 minutes (0 is off)
:
:		Default: 0 (off)

INACTI	MACRO(min,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe)[
  IF	X3ON

    IF	0FF-min
 .VPRNG(INACTI,NPORT,0,p0,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p1,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p2,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p3,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p4,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p5,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p6,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p7,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p8,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,p9,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,pa,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,pb,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,pc,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,pd,INA.,min)                             :DLG 21-Jan-86
 .VPRNG(INACTI,NPORT,0,pe,INA.,min)                             :DLG 21-Jan-86
    ELSE
 ERROR(INACTIVITYTIMER setting must be less than 256 minutes)
    EI	:OFF-min

  EI	:X3ON
]


::	CUG	MACRO(submode,inmode,outmode,p0,....,pc)
:		
:		initial port mode may be:
:		submode - 0, not subscribed to CUG facility
:			  1, subscribed to CUG facility
:
:		inmode  - 0, subscribed to CUG without incoming access
:		          1, subscribed to CUG with incoming access
:		
:		outmode - 0, subscribed to CUG without outgoing access
:			  1, subscribed to CUG with outgoing access
:
:		Default: 0 for above three modes
:

CUG	MACRO(submode,inmode,outmode,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc)[
  IF	X3ON

    IF	submode
.SPRNG(CUG,NPORT,.CUGS,p0)
.SPRNG(CUG,NPORT,.CUGS,p1)
.SPRNG(CUG,NPORT,.CUGS,p2)
.SPRNG(CUG,NPORT,.CUGS,p3)
.SPRNG(CUG,NPORT,.CUGS,p4)
.SPRNG(CUG,NPORT,.CUGS,p5)
.SPRNG(CUG,NPORT,.CUGS,p6)
.SPRNG(CUG,NPORT,.CUGS,p7)
.SPRNG(CUG,NPORT,.CUGS,p8)
.SPRNG(CUG,NPORT,.CUGS,p9)
.SPRNG(CUG,NPORT,.CUGS,pa)
.SPRNG(CUG,NPORT,.CUGS,pb)
.SPRNG(CUG,NPORT,.CUGS,pc)
    EI	:submode
    IF	inmode
.SPRNG(CUG,NPORT,.CUGI,p0)
.SPRNG(CUG,NPORT,.CUGI,p1)
.SPRNG(CUG,NPORT,.CUGI,p2)
.SPRNG(CUG,NPORT,.CUGI,p3)
.SPRNG(CUG,NPORT,.CUGI,p4)
.SPRNG(CUG,NPORT,.CUGI,p5)
.SPRNG(CUG,NPORT,.CUGI,p6)
.SPRNG(CUG,NPORT,.CUGI,p7)
.SPRNG(CUG,NPORT,.CUGI,p8)
.SPRNG(CUG,NPORT,.CUGI,p9)
.SPRNG(CUG,NPORT,.CUGI,pa)
.SPRNG(CUG,NPORT,.CUGI,pb)
.SPRNG(CUG,NPORT,.CUGI,pc)
    EI	:inmode
    IF	OUTMODE
.SPRNG(CUG,NPORT,.CUGO,P0)
.SPRNG(CUG,NPORT,.CUGO,P1)
.SPRNG(CUG,NPORT,.CUGO,P2)
.SPRNG(CUG,NPORT,.CUGO,P3)
.SPRNG(CUG,NPORT,.CUGO,P4)
.SPRNG(CUG,NPORT,.CUGO,P5)
.SPRNG(CUG,NPORT,.CUGO,P6)
.SPRNG(CUG,NPORT,.CUGO,P7)
.SPRNG(CUG,NPORT,.CUGO,P8)
.SPRNG(CUG,NPORT,.CUGO,P9)
.SPRNG(CUG,NPORT,.CUGO,Pa)
.SPRNG(CUG,NPORT,.CUGO,Pb)
.SPRNG(CUG,NPORT,.CUGO,Pc)
    EI	:OUTMODE

  EI	:X3ON
]


:	ADD CUDUSE MACRO FOR XCOMPAD TO EXTRACT USERNAME AND PUT
:	INTO CALL USER DATA FIELD FOR CALL REQUEST PACKET JH 10-30-85
:	THE snchar IS A SIGNED INTEGER THAT INDICATES THE NUMBER
:	OF CHARACTERS TO EXTRACT FROM THE USERNAME AND PLACE IN THE
:	CALL USER DATA FIELD. A POSITIVE VALUE INDICATES THAT CHARACTERS
:	SHOULD BE EXTRACTED FROM THE FRONT. A NEGATIVE VALUE INDICATES THAT
:	CHARACTERS SHOULD BE EXTRACTED FROM THE END OF THE USERNAME. 
:       Changed to create a one byte macro of the control info to be put
:       in the port table instead of previous 16 byte array per port *500.sdw
	GL	CUD.MX,CUD.UR,CUD.UI,CUD.UL
CUD.MX	EQ	0	:CUDUSE MACRO DEFINE
CUD.UI	EQ	80	:FLAG FOR USER INPUT REQUIRED
CUD.UL	EQ	40	:FLAG FOR USERNAME LEFT EXTRACTION
CUD.UR	EQ	20	:FLAG FOR USERNAME RIGHT EXTRACTION

CUDUSE MACRO(slen)[ 
  IF	X3ON                                                    :DLG 21-Jan-86

C.FIX  			:C.FIX is used to define nport JH - 1/16/85
    IF SEEGEN; REMARK %CUDUSE(slen); EI
cud.mx	eq	cud.mx+1
QG	EQ	$A slen 12
    IF 	QG
Q	EQ	QG!CUD.UL
    ELSE
QG	EQ	-QG
Q	EQ	QG!CUD.UR
    EI	:QG
    IF	QG-$A12
  ERROR(CALL USER DATA CUDUSERNAME > 12 DIGITS)
    EI	:QG-$A12
	.SETNN(CUD,Q)  :set same for all ports for now 

  EI	:X3ON                                                   :DLG 21-Jan-86
]


::	CUGPREF(index,p0,...pc)		preferential CUG index #
:
:		Default: 0
:		Range  : 99 decimal 

CUGPREF	MACRO(ind,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc)[
  IF	X3ON                                                    :DLG 21-Jan-86

    IF	ind
.VPRNG(CUGPREF,NPORT,0,p0,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p1,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p2,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p3,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p4,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p5,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p6,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p7,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p8,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,p9,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,pa,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,pb,CUGP,$a ind)
.VPRNG(CUGPREF,NPORT,0,pc,CUGP,$a ind)
    EI	:ind

  EI	:X3ON                                                   :DLG 21-Jan-86
]


::	CUGROUP(inde,cda,cdb,p0,...,pc)
:
:	inde	closed user group index
:	cda	DNIC part of the interlock code
:		0 if national CUG
:		2000-7999 (4 digit BCD) if international CUG
:	cdb	the rest of interlock code, 1 to 5 digits of decimal
:		number, less than 65535 decimal

CUGROUP	MACRO(inde,cda,cdb,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc)[
  IF	X3ON

ind	EQ	$a inde
   IF  .NE.(cda,0)
     IF .LT.(cda,2000)!.GT.(cda,7999)
ERROR(DNIC part of interlock code must be in the range 2000-7999)
     EI	
   EI
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p0)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p1)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p2)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p3)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p4)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p5)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p6)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p7)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p8)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,p9)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,pa)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,pb)
.SPRNG(CUGROUP,NPORT,.CU`|ind|,pc)
.CAB`|ind|	EQ	cda^10!$a`cdb

  EI	:X3ON
]

:  AUTOCALL(command name,call string,prt rng,prt rng,etc)
:  Done by sdw for fun.  port range is ports which may use this username.
:  command is what is typed to get this call.
:  call string is everything normally typed to make a call except for the
:  actual command "CALL ".
:  all that happens is that the call string is put into the CMDBUF as if it
:  was typed.  It is all done by macroes and mirrors.  Thank you Karen SS.

	GL	ATOCAL
ATOCAL	EQ	0

AUTOCALL	MACRO(CMD,STR,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD)[
  IF	X3ON

AQ	EQ	ATOCAL
ATCM|AQ| MACRO[
        SC      /CMD/
]
ATCL|AQ| MACRO[
	SC	/STR/
]
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P0)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P1)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P2)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P3)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P4)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P5)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P6)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P7)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P8)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,P9)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,PA)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,PB)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,PC)
.SPRNG(AUTOCA,NPORT,.AC`|aq|,PD)
ATOCAL	EQ	ATOCAL+1

  EI	:X3ON
]



::	ODNIC(dnic)			dnic used to address the network
:
:		Default: 3106
:		Range: 4 decimal digits

ODNIC	MACRO(dnic)[
  IF 	X3ON

ODN.00	EQ	dnic

  EI	:X3ON
]

: Obsoleted with fix concerning Tymnet Natl Parm 103 	DLG 22-May-86
::	BRKRPL(key)		Break key substitution by any key in the key
:				board
:		DEFAULT: break key
:		RANGE: 0 to 255 Decimal value
:
GLOBAL(BRK.00,0)		:macro not called yet
:
BRKRPL	MACRO(key)[
  IF	X3ON 

BRK.00	EQ	1
	REMARK	 >>>> The BRKRPL macro has been obsoleted. <<<<%
	REMARK  >					      <%
	REMARK  >      Break emulation may be defined by     <%
	REMARK  >        TYMNET national parameter 103       <%
	REMARK  >					      <%
	REMARK  >    For compatibility, the BRKRPL macro     <%
	REMARK  > overrides the setting by the PRFNDF macro  <%
	REMARK  >     of TYMNET national parameter 103       <%
	REMARK  >					      <%
Q	EQ	3
	RE	20
	GL	P|Q|N03
P|Q|N03	EQ	$A key
Q	EQ	Q+1
	ER

  EI	:X3ON           
]
:


::	UUNUMB(ON/OFF)		Provide implementation of National Numbering
:				Plan for Datapak Network
:		DEFAULT: off	This implementation is used to permit user
:				seletion of the UUN (Universal User Number)
:				associated with a particular user name
GLOBAL(UUNON,OFF)

UUNUMB	MACRO(SWITCH)[
  IF	X3ON                                                    :DLG 21-Jan-86

UUNON	EQ	SWITCH

  EI	:X3ON                                                   :DLG 21-Jan-86
]


::	NNUICAL(ON/OFF)		Provide the characteristic of circuit 
:				building  without the use of 'NUI' in
:		DEFAULT: off	command mode
:				Login string (user name only) must be
:				alphanumeric character
GLOBAL(NNUIC,OFF)

NNUICAL	MACRO(SWITCH)[
  IF	X3ON

NNUIC	EQ	SWITCH

  EI	:X3ON
]


::	LESSHELP(on/off)		Provide only minimal help. Reduces
:				storage requirements by xxK bytes.
:		DEFAULT: off
GLOBAL(LESHLP,OFF)

LESSHE	MACRO(switch)[
  IF	X3ON

LESHLP	EQ	switch

  EI	:X3ON
]


::	SEGAC(nchar)	number of characters in a segment for accounting
:		DEFAULT: 64
:		RANGE: 0-1024 (WHERE 0=NO SEGMENT ACCTING)
GLOBAL(SEGACT,$A64)			:64 character segment accounting

SEGAC	MACRO(nchar)[
  IF	X3ON

SEGACT	EQ	$A nchar 64

  EI	:X3ON
]


:: 	.VPRNG(MNAM,RNG,OFF,p,LNAM,val)		Internal macro to perform all
:					processing for parameter P in macro
:					MNAM with range RNG and offset OFF.
:					Sets a label of the form LNAM`p to
:					the value VAL

.VPRNG	MACRO(MNAM,RNG,OFF,P,LNAM,VAL)[

C.FIX                                                           :DLG 21-Jan-86
.RANGE(MNAM,A,RNG,P)
  IF	OFF
QI	EQ	QI+OFF
  EI	:OFF
.SETNM(LNAM,VAL)			:set for range of P values
]


	GL	NX3PRO
NX3PRO	EQ	-1
:	PROFILE DEFINITION MACRO - PRFDEF
:
:	PNO - PROFILE INDEX NUMBER
:	PNAM- SYMBOLIC NAME OF THE PROFILE
:	P1,...,P18 - A SET OF X.3 PARAMETER VALUES TO BE ASSOCIATED TO A 
:		PROFILE.
:
:	*** NOTE *** 
:	    X.3 Par.  8 (Discard output, alway default to zero),
:		Par.  9 (Padding after CR),
:		PAR. 11 (Speed of the terminal) and
:		PAR. 14 (Padding after LF) are not in the augument list of
:		   this macro.  The latter three will be determined by TID.
:
PRFDEF  MACRO(PNO,PNAM,P1,P2,P3,P4,P5,P6,P7,P10,P12,P13,P15,P16,P17,P18)[
  IF	X3ON

	RA	0A
NX3PRO	EQ	NX3PRO+1
  IF	.NE.(PNO,NX3PRO)
	ERROR(Profile Definition Sequence Error - Make correction in Tymfile)
  EI	
	GL	P|PNO|F01,P|PNO|F02,P|PNO|F03,P|PNO|F04,P|PNO|F05,P|PNO|F06
	GL	P|PNO|F07,P|PNO|F10,P|PNO|F12,P|PNO|F13,P|PNO|F15,P|PNO|F16
	GL	P|PNO|F17,P|PNO|F18
P|PNO|NAM	MACRO[	SC	/PNAM/]
P|PNO|F01	EQ	P1
P|PNO|F02	EQ	P2
P|PNO|F03	EQ	P3
P|PNO|F04	EQ	P4
P|PNO|F05	EQ	P5
P|PNO|F06	EQ	P6
P|PNO|F07	EQ	P7
P|PNO|F10	EQ	P10
P|PNO|F12	EQ	P12
P|PNO|F13	EQ	P13
P|PNO|F15	EQ	P15
P|PNO|F16	EQ	P16
P|PNO|F17	EQ	P17
P|PNO|F18	EQ	P18
	RA	0

  EI	:X3ON
]


:	CONTINUATION OF PROFILE DEFINITION MACRO - PRFNDF
:
:		HAVE TO DO THIS BECAUSE NAD CAN ONLY TAKE 16
:		 PARAMETERS FOR A MACRO.
:		THIS MACRO SPECIFY THE TYMNET NATIONAL PARAMETER VALUES
:		 FOR A GIVEN TERMINAL PROFILE.
:
:	TYMNET NATIONAL PARAMETERS HAVE THE FOLLOWING MEANING :
:
:	1 : =1, ECHO CONTROL-I
:	    =0, DO NOT ECHO CONTROL-I
:	2 : =1, REPLACE CONTROL-I GOING TOWARD THE START-STOP MODE DTE
:		WITH ONE OR MORE SPACES FOR EIGHTH COLUMN ALIGNMENT.
:	    =0, DO NOT REPLACE CONTROL-I WITH SPACES.
:	3 : =1 - 127, THE CHARACTER FROM IA5 REPRESENTED BY THE VALUE OF 
:		THIS PARAMETER IS INTERPRETED AS THE BREAK SIGNAL.
:		SOME WEIRD TERMINALS DON'T HAVE A BREAK KEY.
:	    =0, NO INPUT IS CONSIDERED AS THE BREAK SIGNAL.
:
:

PRFNDF	MACRO	(PNO,N1,N2,N3)[
  IF	X3ON

	RA	0A
	GL	P|PNO|N01,P|PNO|N02
P|PNO|N01	EQ	N1
P|PNO|N02	EQ	N2
    IF	1-BRK.00
	GL	P|PNO|N03
P|PNO|N03	EQ	N3
    EI
	RA	0

  EI	:X3ON
]


:.............................................................................
:......................MACROS CALLED FROM I FILE..............................
:.............................................................................
:	TURN PAD RELATED FUNCTIONS ON

 PADRELATEDFUNCTIONS(ON)

:.........   PROFILE DEFINITIONS   ...........................................
:
:	CCITT PARAMETERS 1 - 18
:
:       I                                                   P P P P  P   P  P
:       D                              P P  P    P P P  P   1 1 1 1  1   1  1
:       X,     Prifile name          , 1,2, 3 ,  4,5,6, 7,  0,2,3,5, 6 , 7, 8
:--------+---------------------------+--+-+---+---+-+-+--+---+-+-+-+---+--+---

 PRFDEF(0,Tymnet Transparent Standard, 0,0,255,  0,0,0,04,  0,0,4,0,127,24,18)
 PRFDEF(1,CCITT Simple Standard,       1,1,126,  0,1,1,02,  0,1,0,0,127,24,18)
 PRFDEF(2,CCITT Transparent Standard,  0,0,  0, 20,0,0,02,  0,0,0,0,127,24,18)

:.............................................................................
:
:	TYMNET NATIONAL PARAMETERS 1 - 3
:
:	I 
:	D N N  N
:	X,1,2, 3
:--------+-+-+--+-------------------------------------------------------------

 PRFNDF(0,0,0, 0)
 PRFNDF(1,1,0, 0)
 PRFNDF(2,0,0, 0)

:.............................................................................
:	TURN PAD RELATED FUNCTIONS OFF

 PADRELATEDFUNCTIONS(OFF)
:.............................................................................

        KILL    .EQ.                    :REDEFINED IN SOLO. ALSO IS NOT USED.
 H 
X