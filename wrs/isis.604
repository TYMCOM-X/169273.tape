    SUBTTL  ISIS.602  ... GETS AND PUTS MESSAGES TO THE DISPATCHER
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by  TYMNET, Incorporated.                                   **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **  File Name          :  ISIS.602       last change: 12/11/86  **
: **                                                              **
: **  File Description   :  The routines which put and get messages*
: **			    from the dispatcher are contained in  **
: **			    module.  The connection and disconnect**
: **			    of a port are also included.  Data is **
: **			    taken (or put) from the appropiate    **
: **			    bufferlet and put (or taken) in the   **
: **			    dispatcher.                           **
: **                                                              **
: **  File Abstract      :  This module handles the interactions  **
: **			    between the slot and the ISIS rings.  **
: **                                                              **
: ******************************************************************
: **                    CHANGE LOG                                **
: **                                                              **
: **  Ver   Date    By   PIR/NSR  Changes (most recent at top)    **
: ** ----- -------- ---  -------- ------------------------------- **
: ** 06.02 12/11/86 DLG		  Initialized P.BCT to zero in	  **
: **				  INZAP1, CIRDE0, and CIRDIS	  **
: ** 06.02 12/08/86 DLG		  Added check to INPZAP for hold  **
: **				  on reading of async rings	  **
: ** 06.02 12/04/86 dlg		  Included check for pad act port **
: **				  in CIROK2 to prevent CONSAT port**
: **				  from reinitializing term parms  **
: **				  when no X.25 host called.	  **
: ** 06.02 11/26/86 dlg		  Removed resetting IIXCAL from   **
: **				  CIROK, placed in CIRDIS.	  **
: ** 06.02 11/25/86 dlg		  Removed emptying of echo buffer **
: **				  when ZAPPER is received by PAD  **
: ** 06.02 11/20/86 dlg		  Changed check regarding incoming**
: **				  calls to use CMMODE array-NEED62**
: ** 06.02 11/13/86 DLG		  Changed CIROK7, if X3ON to JAL  **
: **				  to CALOK			  **
: ** 06.02 11/07/86 dlg		  Added J to INPUT in port        **
: **				  addressing-PAD inc call area.	  **
: ** 06.02 10/13/86 CAB           Fixed port addressing to call PAD*
: **				  incoming call processor only if **
: **				  port is a PAD port.		  **
: ** 06.02 10/08/86 LH            Fixed extra data sent to network**
: **				  prior to IIX negotiation causing**
: **				  X25 slot crash.                 **
: ** 06.02 10/04/86 LH   NSR 988  Fixed Telex ports not working   **
: **				  with PAD on.			  **
: ** 06.02 09/26/86 LH   NSR 958  Fixed crash type 03 by changing **
: **			 	  IIXCAL(not under X3ON) to IIXCAP**
: ** 06.01 09/10/86 LH   	  Changed RX1 to RX3 in ESTPT2    **
: ** 06.01 09/03/86 cab		  Changed IHSEC to NETBP	  **
: ** 06.01 09/03/86 LH	 NSR 901  Set "vanilla" for non-IIX capable*
: **				  SIO and TELEX ports in ESTPRT.  ** 
: ** 06.01 08/14/86 cab		  Moved small ISIS ring routines  **
: **				  geth/getch/putch inline to save **
: **				  call/return overhead.           **
: ** 06.01 07/29/86 dlg		  Added jump to OUTCRA if no dport**
: **				  when trying to process ISIS cntl**
: **				  signal.  per SDW		  **
: ** 06.00 07/15/86 cab           Added POLLIO to force sequence  **
: **				  J INPUT, J POLL, J OUTPUT       **
: ** 06.00 07/15/86 cab/dlg       Made backpressure logic smarter.**
: ** 06.00 07/08/86 SDW           Dumb circuits get old PABLE list**
: ** 06.00 06/24/86 CAB	 NSR 776  Allow PAD to handle orange balls**
: ** 06.00 06/20/86 DLG		  Changed JAL to SETALL to	  **
: **				  JAL to INITCS and JAL to INITX3 **
: ** 06.00 05/29/86 LH		  Change RX1 instruction to RX3   **
: ** 06.00 05/21/86 sdw		  CIRDET resets RLA for OUTDIAL   **
: ** 06.00 05/15/86 LH   PIR 1824 Implement S-mode on ckt establish*
: ** 06.00 05/15/86 LH		  Remove PROBMG out of PVC switch **
: **				  and make it as general routine. **
: ** 05.00 05/09/86 dlg		  Set up RPI in PKTACT to prevent **
: ** 				  crash from PCTRPT
: ** 05.00 05/06/86 sdw           ECR.LF is now set properly for  **
: **                              pad port talking to dumb host   **
: ** 05.00 05/06/86 sdw           CIRDET and CIRDIS clear OUTDIAL **
: **                              buffers.                        **
: ** 05.00 04/02/86 sdw           PAD doesn't set up PMAPIA before**
: **                              possibly rejecting needle       **
: ** 05.00 03/18/86 sdw           PAD cleans up in CIRDIS instead **
: ** 05.00 03/18/86 CAB  NSR  647 if KANA, force SPAR during login**
: **                              of ZAPACK (no more zapper ack)  **
: ** 04.03 03/03/86 SDW           cleaned up crash codes          **
: ** 04.02 02/27/86 sdw           OUTPUT now crashes if outputting**
: **                              without a dport.                **
: ** 04.02 02/27/86 sdw           use SENDON to backpressure ISIS **
: **                              ports until have circuit.       **
: ** 04.02 02/17/86 SDW  n/a      Reset SENDON in CIRDIS to stop  **
: **                              dispatcher crash.               **
: ** 04.03 02/13/86 LH   n/a      Change product ID from 25 to 45.**
: ** 04.03 02/13/86 SDW  n/a      Crash if host is rejected       **
: ** 04.03 02/04/86 SDW  PIR 1653 INPZAP for OUTDIAL              **
: ** 04.03 01/20/86 SDW  PIR 1653 Output recognizes a Detach msg  **
: ** 04.03 01/20/86 SDW  PIR 1653 Needle processing for Outdial   **
: ** 04.03 01/20/86 SDW  n/a      Created from Envir.402          **
: ** 04.02 01/16/86 LH		  Make INPZAP clear mapping imme- **
: **				  diately on ISIS port zapped.    **
: ** 04.02 01/07/86 LH   PIR 1869 Output Probe message on circuit **
: **				  zapped or built for TTLXP ports.**
: **  ''      ''    ''      ''    Emit mark signal to TELEX device**
: **				  when successful circuit and the **
: **				  accounting signal are received. **
: **  ''      ''    ''            Add proprietary banner.         **
: **                                                              **
: ******************************************************************
	SUBTTL  (ISIS) ISIS RING I/O...MESSAGE DEFINITIONS
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			I S I S   I N T E R F A C E			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        GL      IOPOLL,IOPOL2,IOPOL3,IOPOL4,INPUT,OUTPUT,POLL
	MO	.,ISIS
NOWRAP	EQ	1			:equate to omit wrap check
:
:	.GETCH	- macro for inline execution of GETCH code
:
:	.GETCH		:get char and check for wrap
:	.GETCH(NOWRAP)	:get char and omit check for wrap
:
.GETCH	MACRO(ckwrap)[
	LB	R0,EIRING,R15,		:get the character
	AIS	R15,1			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-IRSIZE		:else fold it
  EI
]
:	.GETR1(NOWRAP)	:get char in RBC and omit check for wrap
:
.GETR1	MACRO(ckwrap)[
	LB	RBC,EIRING,R15,		:get the character
	AIS	R15,1			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-IRSIZE		:else fold it
  EI
]
:
:	.PUTCH		- macro for inline execution of PUTCH code
:
:	.PUTCH			:get char and check for wrap
:	.PUTCH(NOWRAP)	:get char and omit check for wrap
.PUTCH		MACRO(ckwrap)[
	STB	R0,EORING,R15,		:Place the character
	AIS	R15,1			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-ORSIZE		:else fold it
  EI
]
:
:	.PUTR1(NOWRAP)	:get char in RBC and omit check for wrap
.PUTR1		MACRO(ckwrap)[
	STB	RBC,EORING,R15,		:Place the character
	AIS	R15,1			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-ORSIZE		:else fold it
  EI
]
:
:	.GETH	- macro for inline execution of GETH code
:
:	.GETH		:get halfword and check for wrap
:	.GETH(NOWRAP)	:get halfword and omit check for wrap
:
.GETH	MACRO(ckwrap)[
	LHL	R0,EIRING,R15,		:get the halfword
	AIS	R15,2			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-IRSIZE		:else fold it
  EI
]
:
:	.PUTH	- macro for inline execution of PUTH code
:
:	.PUTH		:get halfword and check for wrap
:	.PUTH(NOWRAP)	:get halfword and omit check for wrap
.PUTH	MACRO(ckwrap)[
	STH	R0,EORING,R15,		:Place the character
	AIS	R15,2			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-ORSIZE		:else fold it
  EI
]
:
:	.GETW	- macro for inline execution of GETW code
:
:	.GETW	:get word and check for wrap
:	.GETW(NOWRAP)	:get word and omit check for wrap
:
.GETW	MACRO(ckwrap)[
	L	R0,EIRING,R15,		:get the halfword
	AIS	R15,4			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-IRSIZE		:else fold it
  EI
]
:
:	.PUTW	- macro for inline execution of PUTW code
:
:	.PUTW		:get word and check for wrap
:	.PUTW(NOWRAP)	:get word and omit check for wrap
.PUTW	MACRO(ckwrap)[
	ST	R0,EORING,R15,		:Place the character
	AIS	R15,4			:bump cursor
check	eq	ckwrap 0
  IF 	1-check
	JLFS	.+6			:skip if not
	LHI	R15,-ORSIZE		:else fold it
  EI
]

	LO	DATA
        SEG     A.CODE

:       Crash codes used by ISIS
C.INDM	EQ	82			:Illegal Non-data message to IFAN
C.IINM	EQ	83			:Illegal Intra-node message to INSPT
C.IIHR	EQ	8C			:host rejected by node/supe

:	Interface message types - ISIS-II
NEDMSG	EQ	0			:NEEDLE
FIRST	EQ	9E			:FIRST MESSAGE IN LIST
DETMSG	EQ	9E			:DETACH MESSAGE
ZAPMSG	EQ	9F			:DISCONNECT MESSAGE
NOSMSG	EQ	0A0			:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1			:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2			:FLUSH OUTPUT
BKGMSG	EQ	0A3			:FLUSH INPUT
BLKMSG	EQ	0A4			:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5			:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6			:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7			:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8			:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9			:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA			:GREEN BALL
RBMSG	EQ	0AB			:RED BALL
YBMSG	EQ	0AC			:YELLOW BALL
OBMSG	EQ	0AD			:ORANGE BALL
BRKMSG	EQ	0AE			:BREAK DETECTED
HNGMSG	EQ	0AF			:HANG UP
QTPMSG	EQ	0B0			:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1			:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2			:PSEUDO NEEDLE
NLOGCH	EQ	0B3			:NORMAL LOGON CHAR
NLOGST	EQ	0B4			:NORMAL LOGON STATUS
LOGFAL	EQ	0B5			:LOGON FAILURE
LOGOK	EQ	0B6			:SUCCESSFUL LOGON
ADAMSG	EQ	0B7			:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8			:SUPER-HANG UP
TLMMSG	EQ	0B9			:SET TRANSMIT LIMIT
BNDMSG	EQ	0BA			:BREAK-END
ZAKMSG	EQ	0BB			:ZAP ACKNOWLEDGE
EADMSG	EQ	0BC			:ENTER ALTERNATE OUTPUT DEVICE MODE
LADMSG	EQ	0BD			:LEAVE ALTERNATE OUTPUT DEVICE MODE
ZWRMSG	EQ	0BE			:ZAP W/REASON
SIXMSG	EQ	0BF			:SIIX COMMAND
TIXMSG	EQ	0C0			:TIIX COMMAND
  IF	UUNON
UUNMSG	EQ	0C1			:UNIVERSAL USER NAME DETECTED 
MAXTYP	EQ	UUNMSG			:MAXIMUM TYPE DEFINED
  ELSE
MAXTYP	EQ	TIXMSG			:MAXIMUM TYPE DEFINED
  EI	:UUNON

:	Special (port 0) message types
INDNON	EQ	9			:Unable to provide pseudo-needle
INDREJ	EQ	0B			:Host rejected<
INDREM	EQ	0E			:1-down remote

:	Back-Pressure tables
:
:	BPOFLM specifies speed-dependent backpressure limit.
:	Consat will release backpressure when the
:	bufferlets have less than a half-second of data.
:
:	Note: 4800 and 9600 limit is .75 second of data
:	for better PC file transfer support.
:
BPOFLM	HC	5			:10 CPS
	HC	7			:15
	HC   $A	15			:30
	HC   $A 20			:40
	HC   $A 30			:60
	HC   $A 60			:120
	HC   $A 15			:30
	HC  	7			:14.5
	HC	5			:10
	HC	5			:10
	HC   $A	120			:240
	HC   $A 240+120			:480 (0.75 SECOND)
	HC   $A 480+240			:960 (0.75 SECOND)
	HC   	5			:50 BAUD BAUDOT
	HC    	5			:75 BAUD BAUDOT
	HC      5			:75 BAUD ASCII

:	BPONLM specifies speed-dependent backpressure limit.
:	Consat will backpressure the network when the
:	bufferlets have more than a second of data.
:
:	Note: 4800 and 9600 limit is 1.5 second of data
:	for better PC file transfer support.
:
BPONLM	HC   $A 10			:10 CPS
	HC   $A 15			:15
	HC   $A	30			:30
	HC   $A 40			:40
	HC   $A 60			:60
	HC   $A 120			:120
	HC   $A 30			:30
	HC   $A 14			:14.5
	HC   $A 10			:10
	HC   $A 10			:10
	HC   $A	240			:240
	HC   $A 480+240			:480 (1.5 SECOND)
	HC   $A 960+480			:960 (1.5 SECOND)
	HC   	7			:50 BAUD BAUDOT
	HC   $A 10			:75 BAUD BAUDOT
	HC      7			:75 BAUD ASCII

	SUBTTL	(ISIS) SPECIAL ISIS FUNCTIONS

:	Routine to establish a port, used upon circuit zapped or TID
:	RLINK -	link register
:	RP -	port number
:	RPI -	port-table pointer
:	R5 -	Special features:
:		0 -	"vanilla"
:		8000 -	IIX
:		4000 -	"Extended-messages" requested
ESTPRT				:don't changed SENDON until have circuit*402sdw
	RBT	RP,GOT.PN		:we haven't got a circuit here
  IF	X3ON
    IF	TELEX				:**6.02 LH
  	TBT	RP,TLXP,,		:check if TELEX ports
  	JN	ESTPT0			:yes, jump out to send 07 message
    EI	:TELEX
    IF	BTELEX
    	TBT	RP,BTLXP,,		:check if virtual TELEX ports
        JN	ESTPT0			:yes, jump out to send 07 message
    EI	:BTELEX
    IF	TTELEX
    	TBT	RP,TTLXP,,		:check if Speedlink TELEX ports
    	JN	ESTPT0			:yes, jump out to send 07 message
    EI	:TTELEX
	TBT	RP,PNMODE
	JE	IX3PRT,,		:if no circuit yet...just init
  EI
ESTPT0	L	RBP,.FTBUF,RPI		:from-port buffer-pointer
	MAKEBF(R1,TOLOG,RP)		:connect port to logger
	JAL	R3,CHNGBF
	L	RBP,.LGBUF,RPI		:**6.00 LH logon buffer-pointer
	MAKEBF(R1,GOLOG,RP)		:reconnect port to GOLOG for
	JAL	R3,CHNGBF		:subsequent login again

	 IF	NPAPRT
	TBT	RP,AD.PRT,,		:addressing port?
	JE	ESTPT2			:no, skip
        IF      PVC                     :PORCV only for PVC *sdw
	L	R6,.PVCX,RPI		:PVC exceptions
	TI	R6,PORCV		:addressable port as receive only
        JE	ESTPT1			:no receive only option
	MAKEBF(R1,TOISIS,RP)		:for RCV port, no login string.
	JAL	R3,CHNGBF		:so directly connect to "TOISIS"
	J	CIRBLT			:** 4.02 LH
       EI :PVC  PORCV only for PVC *sdw
ESTPT1	TBT	RP,LIMBO		:is this an addressable port in limbo?
	JN	CIRBLT			:yes...just exit via CIRBLT
	 EI	:NPAPRT
ESTPT2	LIS	R0,0B			:11d byte message
	LIS	R1,0			:...to ISIS port 0
	LIS	R2,7			:--Request Normal Needle
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0
	.PUTCH				:pad
	LB	R0,SEQKEY,RP		:Get sequence number of port for key
	AIS	R0,1
	STB	R0,SEQKEY,RP
	EXBR	R0,R0			:Key R0 is /SEQ|PHY PORT/
	STBR	RP,R0
	.PUTH
	LIS	R0,0			:set "vanilla" for special feature
	CLHI	RP,.SPORT		:check if SIO ports **6.01 LH
	JGE	ESTPT4			:yes, skip
	 IF	BTELEX
	TBT	RP,BTLXP,,		:no, check if virtual-telex ports
	JNFS	ESTPT4			:yes, it is virtual-telex port
	 EI	:BTELEX
	 IF	TTELEX
	TBT	RP,TTLXP,,		:no, check if SPEEDLINK telex ports
	JNFS	ESTPT4			:yes, skip
	 EI	:TTELEX
	 IF	TELEX
	TBT	RP,TLXP,,		:no, check if "extension cord" telex
	JEFS	ESTPT3			:no, not "extension cord" telex
	LHI	R0,SPECFE+4000		:IIX and extended-logon-status bit set
	JFS	ESTPT4
	 EI	:TELEX			:**6.01 LH
ESTPT3	NHI	R5,0FFFC		:don't care if from PSTATE or PA.CL
	LR	R0,R5			:special handling
ESTPT4	.PUTH	
	LHL	R0,ACHOST,RP,RP
	.PUTH				:Output Origination Host
	LH	R5,.TERMT,RPI		:Get terminal type-pointer
	LB	R0,VID.ID,R5,		:Now get TID
	.PUTCH		
	JAL	R4,ELOR			:End-Logical-Output-Record
	IF	PVC
	SBT	RP,PSNT1		:set time-out for sending psudo needle
	EI	:PVC
	JR	RLINK



:	Disconnect circuit routine
:	RLINK -	link register
CIRDIS	HS	0			
DT.PRT	EQ	CIRDIS			:for Tymnet-II, two different routines
	IF 	PVC
	RBT	RP,PSNT1		:cancel time-out for psudo needle
	RBT	RP,PSNT0		
	EI	:PVC
	L	RBP,.FTBUF,RPI		:get from-terminal buffer-pointer
	JAL	RCH,EMPTY		:empty it
	LIS	R1,0
	JAL	R3,CHNGBF		:disconnect buffer from processes
  IF	X3ON            :port clearing moved from ZAPACK to here *500.sdw
	LIS	R0,0			:prepare to init character counter
	STH	R0,P.BCT,RPI		:init char counter to zero *6.02 dlg
	L	RBP,.FEDBF,RPI
	JAL	RCH,EMPTY
  EI	(X3ON)
        IF      OUTDIA
        L       RBP,.OTBUF,RPI          :empty buffer
        JAL     RCH,EMPTY
        EI
	RBT	RP,LOGER		:Disable LOGIN output processor

:	Alternate entry, disconnect port from ISIS, but doesn't diddle port itself
CIRDSC	LHI     R2,ZAPMSG
CIRDS1  LH	R1,PMAPAI,RP,RP		:ISIS port num *entry for CIRDET sdw
	JLR	RLINK
	LIS	R0,3			:Send ZAPPER to ISIS
	JAL	R4,SLOR
	JAL	R4,ELOR
	TS	PMAPIA,R1,R1
	TS	PMAPAI,RP,RP,		:Kill mapping entries
	MDCH(R4,IPORTS)			:Decrement ISIS port-count
        RBT	RP,BKPRSR		:Reset input-backpressure to ISIS
	RBT	RP,SENDON		:Don't send to nonexistent dport*402sdw
	RBT	RP,GOT.PN		:we have no circuit
	RBT	RP,IIXCAL		:No longer IIX circuit, reset
	 IF	PVC			:** 4.02 LH
	L	R0,.PVCX,RPI		:PVC exceptions
	TI	R0,POPRB		:Probe message required?
	JER	RLINK			:exit to polling routine
	TBT	RP,LOGING		:in login mode now?
	JNR	RLINK			:after login mode, don't send msg again
	LHI	R0,11			:11= ckt zap, 12 = ckt sucessful
	STB	R0,PROBVL		:store value
	JAL	RCH,PROBMG		:send out Probe msg
	 EI	:PVC			:** 4.02 LH
	JR	RLINK			:and return

:	Send out message to PROBE via the intra-ISIS report to supervisor's
:	log message,sub-type 03
:	RCH - LINK register ** 4.02 LH	
	GL PROBMG
PROBMG	LIS	R0,9			:9 byte-long message
	LIS	R1,0			:TO ISIS slot 0
	LIS	R2,3			:Intra-ISIS sub-type 03
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0			:Key
	.PUTCH		
	LHR	R0,RP			:report port number (DATA2)
	.PUTH	
	LB	R0,PROBVL		:report type (R TYPE)TCH		
	LIS	R0,0
	.PUTCH				:(DATA1) for PROBE
	LHI	R0,PRODID		:product ID (45) for ISCS.  **4.03 LH
	.PUTCH		
	JAL	R4,ELOR			:End-Logical-Output-Record
	JR	RCH



CIRDET		                        :4.03sdw
       IF OUTDIA
        LHI     R2,(-.OPORT),RP         :and set outdial command port free
	JLFS	CIRDE0			:only if an outdial port
	RBT	RP,RLA			:port is no longer active
        SBT     R2,OT.COM
CIRDE0  L       RBP,.OTBUF,RPI
        JAL     RCH,EMPTY
       EI  :OUTDIA
  IF	X3ON            :port clearing moved from ZAPACK to here *500.sdw
	LIS	RBP,0			:prepare to init character counter
	STH	RBP,P.BCT,RPI		:init char counter to zero *6.02 dlg
	L	RBP,.FEDBF,RPI		:get edit buffer pointer
	JAL	RCH,EMPTY		:empty buffer
  EI	(X3ON)
        L       RBP,.FTBUF,RPI
        JAL     RCH,EMPTY
        LIS     R1,0
        JAL     R3,CHNGBF
        LHI     R2,DETMSG               :just send detach
        J       CIRDS1                  :now late msgs get out


	SUBTTL	(ISIS) LOGGER/FLUSHER

	LO	DATA

:		LOGGER/FLUSHER
:		====== =======
:	Periodically, flush the logon-buffer to ISIS
:	run every 50 ms. from timeout list.
SNDLOG	LHI	RPOL,(NGRP-2)*2		:word index into bit arrays
SNDLG1	L	R0,GOLOG,RPOL		:data present
	N	R0,FL.LOG,RPOL		:should be flushed
	N	R0,GOT.PN,RPOL		:we have a pseudo-needle
	JFFO	R0,SNDLG2
	SIS	RPOL,4
	JGEBS	SNDLG1			:Next port-group:
	J	EXDISM		:done...exit timeout

SNDLG2	LR	RP,RPOL			:Compute port number
	SLLS	RP,3
	AR	RP,R1
	GETPTP(RPI,RP,RP)		:set up Port-Table-Pointer
	RBT	RP,FL.LOG		:cancel flush request

:	Transmit LOGON-string for port specified by RP
SNDLG3	TBT	RP,GOLOG		:Any more there?
	JE	SNDLG1			:no...just quit for now
	L	RBP,.LGBUF,RPI		:Logon buffer
	JAL	RCH,GETCHR		:get the next char
	 J	.			:don't expect skip returns!
	LR	R9,RBC			:data-char...copy it
	JAL	RLINK,LOGCH		:send character
	JBS	SNDLG3			:go to see if any more

:	Pass a LOGON character to ISIS
:	R9 -	Character
:	RP -	Port number
:	RLINK -	Link register
LOGCH	LIS	R0,4			:4 Character ISIS-message
	LH	R1,PMAPAI,RP,RP		:ISIS port number
	JLR	RLINK			:abort if no port
	LHI	R2,NLOGCH		:New LOGON Character
	JAL	R4,SLOR			:Start Logical Output Record
	LR	R0,R9			:Character input
	OHI	R0,80
	.PUTCH		
	JAL	R4,ELOR			:End Logical Output Record
	JR	RLINK

:	IZ.PRT -- called by Async A/Hang, MPVC, TeLex, maybe SIO A/Hang
IZ.PRT	JR	RLINK			:Something needed for Tymnet-II

  IF	X3ON
:	Periodic packet/ segment accounting report
:	Report on 1/15 of the total port every 64 second so that each port
:	will get reported once every 16 minutes.

AAGRP	EQ	(NPORT-1+$A8)/$A15

        GL      PKTACT
PKTACT	LHI	R9,AAGRP	:NO. OF PORTS TO PUT OUT IN THIS TIME PERIOD
	LHL	RP,AAPORT,,	:PORT NO. TO START
PKTA10	TBT	RP,TURKEY,,
	JEFS	PKTA20			:if not in packet mode
	GETPTP(RPI,RP,RP)		:set up Port-Table-Pointer	
	JAL	R6,PCTRPT,,	:report packet count
	JAL	R6,SCTRPT,,	:report segment count
PKTA20	SIS	RP,1
	JGFS	PKTA30
	LHI	RP,NPORT-1		:start from top again
PKTA30	SIS	R9,1
	JG	PKTA10			:if more ports to process
	STH	RP,AAPORT,,		:save port index for next time
	J	EXDISM


        EI     :(X3ON)

        IF      X3ON+OUTDIA     :if either

	GL	GENRPT
:	Output accounting message.
:	R7 - full word of accounting info
:	R5 - link resigster
:	Uses R0-R4,R7,R15

GENRPT	LH	R1,PMAPAI,RP,RP		:look up ISIS port number
	JLR	R5
	LIS	R0,8			:space needed in ring
	LHI	R2,ADAMSG		:accounting message code
	JAL	R4,SLOR
	LIS	R0,0
	.PUTCH				:enter ignored byte
	LR	R0,R7			:get message to send
	.PUTW			
	JAL	R4,ELOR
	JR	R5			:return
  EI	X3ON OR OUTDIA


	SUBTTL  (ISIS) Multiplexed PVC -- Accounting processes
	
	 IF	NMPVC

	GL	M.ACCT,M.SACT		:definitions

:	RP -	MPVC port number
:	RPOL -	Polling index
:	RLINK -	MPVC port format-table pointer
:	R9 -	MPVC port variable-block pointer


:		MPVC ACCounTing processes
:		==== ========== =========
:	On time-out list, runs every 17 minutes
M.ACCT	LHI	RP,.MPORT		:for all MPVC ports...
M.ACT1	TBT	RP,RLA			:is this port active?
	JNFS	M.ACT3			:yes...service it
M.ACT2	AIS	RP,1			:done...next MPVC port
	CLHI	RP,.MPORT+NMPVC
	JLBS	M.ACT1
	J	EXDISM			:done...exit

:	active MPVC port...service it
M.ACT3	LR	R13,RP
	AR	R13,R13
	L	RLINK,MPVCFO-(4*.MPORT),R13,R13 :set format-table pointer
	LHL	R9,MP.VAR,RLINK		:set variable-area pointer
	JAL	R5,M.SACT		:send accounting
	J	M.ACT2			:and quit


:	Send MPVC accounting
:	R5 -	Link Register
:	R9 -	MPVC accounting data
M.SACT	LIS	R0,8			:8-byte message
	LH	R1,PMAPAI,RP,RP		:for port...
	JLR	R5			:abort if port not connected
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0			:pad
	.PUTCH		
	LHL	R0,MPV.LP,R9		:Logon-ports
	OI	R0,0E0100000
	.PUTW	
	JAL	R4,ELOR			:End-Logical-Output-Record
	LIS	R0,8			:8-byte message
	LHL	R1,PMAPAI,RP,RP		:for port...
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR			:Start-Logical-Output-Record
	LIS	R0,0			:pad
	.PUTCH		
	L	R0,MPV.PS,R9		:port seconds
	AHI	R0,$A 30		:round port seconds 
	LHI	R1,$A 60		:convert to port minutes
	DHR	R0,R1
	LI	R0,0E0110000,R1
	.PUTW	
	JAL	R4,ELOR			:End-Logical-Output-Record
	JR	R5			:and exit

:	M.ASNP - routine picks up physical port number of port that
:	initiated building of the MPVC port and reports that as the
:	physical port number for the MPVC port.
:	R0 	Link register
:	R1	Logical subport number
:	RP	MPVC Logical port number
M.ASNP	LHL	R1,ASNPUT,R1,R1		:get physical port number 
	STH	R1,ASNPUT,RP,RP		:store as MPVC port number
	JR	R0			:and return
	 EI	:NMPVC


	SUBTTL (ISIS) ISIS PERIODIC STUFF

:	ISIS network backpressure
:	==== ======== ==========
:	Check all buffers for backpressure applied,
:		release where possible.
        GL      NETBP
NETBP	LHI	RPOL,(NGRP-2)*2		:word index...
NETBP1	L	R0,BKPRSR,RPOL		:backpressure applied
	ST	R0,P.DONE		:candidates examined
NETBP2	L	R0,P.DONE		:backpreassured and not serviced
	JFFO	R0,NETBP3		:find it
	SIS	RPOL,4			:else proceed to next group
	JGEBS	NETBP1			:
	J	EXDISM			:

NETBP3	RBT	R1,P.DONE		:mark port as serviced
	LR	RP,RPOL			:
	SLLS	RP,3			:
	AR	RP,R1			:Compute port-number
	GETPTP(RPI,RP,RP)			:get pointer to table entry
	L	RBP,.TTBUF,RPI		:To-terminal buffer-pointer
	LB	R1,OBRATE,RP		::dlg 6.00 - get output baud rate
	LH	R0,BPOFLM,R1,R1		::get release backpressure limit
	SH	R0,BCT,RBP,		::check against buffer count
	JL	NETBP2			::not yet
	RBT	RP,BKPRSR		:
	LIS	R0,3			:3-byte message
	LH	R1,PMAPAI,RP,RP		:look up ISIS port #
	LHI	R2,SNDMSG		:release backpressure
	JAL	R4,SLOR			:Start-Logical-Output-Record
	JAL	R4,ELOR			:End-Logical-Output-Record
	J	NETBP2			:and proceed


:	20 SECOND LOGIC
:	---------------
:	Check for DDT user requesting to ZAP an ISIS port
        GL      SEC20
SEC20	LHL	R1,ZAPIT
	JE	EXDISM
	LIS	R0,3
	LHI	R2,ZAPMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	LIS	R0,0
	STH	R0,ZAPIT
	J	EXDISM			:Quit
	SUBTTL  (ISIS) ISIS RING I/O...INPUT INTERFACE
:
:	basic poll loop - scheduled every 25 milliseconds
:	1) process ISIS input ring
:	2) process async input and output rings
:	3) process ISIS output ring every other time (50 ms)
:
IOPOLL	J	INPUT			:
IOPOL2	LHI	RPOL,(NGRP-1)*2		:
IOPL2A	LH	R0,TOPRT3,RPOL		:6.00 CAB - UPDATE HISTORY
	STH	R0,TOPRT4,RPOL		:
	OR	R1,R0			:
	LH	R0,TOPRT2,RPOL		:
	STH	R0,TOPRT3,RPOL		:
	LR	R1,R0			:
	LH	R0,TOPRT1,RPOL		:
	STH	R0,TOPRT2,RPOL		:
	OR	R1,R0			:
	LH	R0,TOPORT,RPOL		:
	STH	R0,TOPRT1,RPOL		:
	OR	R1,R0			:
	STH	R1,TOPRTP,RPOL		:UPDATE TO PORT PENDING
	SIS	RPOL,2			:
	JGE	IOPL2A			:
	J	POLL			:POLL ASYNC INPUT/OUTPUT RINGS
IOPOL3
	TS	POLFLG			:
	JEFS	IOPOL4			:
	LIS	R0,0			:
	STH	R0,POLFLG		:EVERY OTHER TIME
	J	OUTPUT			:FILL ISIS OUTPUT RING
IOPOL4	J	EXDISM			:EXIT TO CONSAT SCHEDULER
:
:	INPUT from ISIS
:	===== ==== ====
INPUT	LH	R0,TMDATA		:how many chars have been processed
	CHI	R0,IRLMT
	JLFS	INPUT1			:if less than IRLMT (200 hex),continue
	LIS	R0,0
	STH	R0,TMDATA
	J	IOPOL2
INPUT1	JAL	R4,LOOK		:is there anything in ring?
	LIS	R0,0			:clear character count before dismiss
	STH	R0,TMDATA			
	 J	IOPOL2			:normal return...just exit
LOKRET	JE	INSPEC			:'skipped' return from LOOK. 
                                        :jump to service special message
	LR	R10,R1			:copy ISIS port
	LH	RP,PMAPIA,R10,R10	:look up internal port number
	JGE	INPUT2			:skip...active port
	CLHI	R2,PNDMSG		:Pseudo-needle ?
	JE	NPNEED			:yes...service new circuit
	LR	R2,R2			:check for needle
	JE	NEEDLE			:yes...service needle
	.GETCH				:eat message type-byte

:	toss a message
TOSS	LR	R2,R0			:copy message type to index register
	LB	R0,LENGTH,R2,		:pick up message length
	SIS	R0,1			:already read type byte
	JAL	R4,FLUSH		:delete remainder of message
	J	INPUT

INPUT2
	GETPTP(RPI,RP,RP)			:set pointer to port-table
	L	RBP,.TTBUF,RPI		:get to-terminal buffer-pointer
	.GETCH(NOWRAP)			:fetch and examine type
INP2A	CLHI	R0,FIRST		:is it data?
	JGE	INPUT7			:no...go process control information

	LR	R9,R0			:yes...save count of chars

	AHM	R9,TMDATA		:keep count of bytes processed
INPUT3	.GETR1				:get next byte in RBC
  IF	KANA				:**CAB 5.00 - force space parity
	TBT	RP,LOGING,,		:**while user is logging in
	JEFS	INP3A			:**
	NHI	RBC,7F			:**original patch for Japanese
INP3A					:**market by Mimi Wang
  EI					:**CAB 5.00
	JAL	RCH,PUTCHR		:put it into the buffer
	SIS	R9,1
    IF  KANA                            :tight loop
	JG	INPUT3			:repeat for all data characters
     ELSE
        JGBS    INPUT3                  :save on each char
     EI
	JAL	R4,ELIR			:End-Logical-Input-Record

:	Check BACKPRESSURE limit to ISIS
	LB	R1,OBRATE,RP		::DLG 6.00 - get output speed
	LH	R0,BPONLM,R1,R1		::get backpressure limit
	SH	R0,BCT,RBP,		::check against buffer count
	JG	INPUT			:jump...backpressure-limit not exceeded
	SBT	RP,BKPRSR		:Check if we've applied backpressure
	JN	INPUT			:jump...already applied
	LHI	R2,NOSMSG		:back-pressure-ISIS message

:	Send a 3-byte message to ISIS
INPUT4	LIS	R0,3			:set message size
	LR	R1,R10
	JAL	R4,SLOR			:Start-Logical-Output-Record
	JAL	R4,ELOR			:End-Logical-OUTPUT Record
	J	INPUT			:and continue

:	Table of direct translations from ISIS to SIGNALS
:		(ordered in ISIS order, offset by FIRST)
	LO	SIGNAL
ISIS.S	BC	0,0			:9E,9F
	BC	0,0,0,0			:A0-A3
	BC	BLBSIG,0,EDMSIG,LDMSIG	:A4-A7
	BC	ETMSIG,LTMSIG,GBSIG,RBSIG :A8-AB
	BC	YBSIG,OBSIG,BBSIG,HNGSIG :AC-AF
	BC	0,0,0,0			:B0-B3
	BC	0,0,0,0			:B4-B7
	BC	SHGSIG,0,BESIG,0	:B8-BB
	BC	EADSIG,LADSIG,0,SIXSIG	:BC-BF
	BC	TIXSIG,0,0,0		:C0-C3
	BC	0,0,0,0			:C4-C7
	FO	SIGNAL

:	BIT array to identify messages to be passed directly to filters
BSPEC	HC	0,0			:00
	HC	0,0			:20
	HC	0,0			:40
	HC	0,0			:60
	HC	0,0			:80
	IF	NMPVC+X3ON		:pass orange balls for MPVC and PAD
	HC	$2 0000101111111101	:A0 - A4, A6-AD, AF
	ELSE				:else , toss em
	HC	$2 0000101111111001	:A0 - A4, A6-AD,AF
	EI	:NMPVC+X3ON
	HC	$2 0000000010001101	:B0 - B8, BC-BD,BF
	HC	$2 1000000000000000	:C0
	HC	0,0			:E0

:	Control Information
INPUT7	TBT	R0,BSPEC		:can it be translated and passed directly?
	JE	ISSMSG			:no...go do special processing
	LR	R4,R0			:yes, just translation...copy type
	LB	R4,ISIS.S-FIRST,R4	:translate it
	JE	CRASH,,			:unrecognized...crash
	JAL	RCH,PUTSIG		:Send signal on

:	Done...Terminate Record
INPUT9	JAL	R4,ELIR			:End-Logical-Input-Record
	J	INPUT			:then go back for another record



:	Apply Backpressure
NOSEND	RBT	RP,SENDON		:do it
	JBS	INPUT9			:...and go close record

:	Release backpressure
RESEND	SBT	RP,SENDON		:turn on for port
	JBS	INPUT9			:...and go close record



:	Not data...process it

ISSMSG	LHI	R4,ISMSZ		:set index for table
ISMS1	CLB	R0,IFAN,R4		:check for match
	JNFS	ISMS2			:skip if not
	L	R4,IFAN,R4		:yes...get the address
	JR	R4			:...and go do it
ISMS2	SIS	R4,4			:else go to next entry
	JGEBS	ISMS1			:...until done
	J	TOSS			:can't find it, so toss it

:	Input fanout for special port-message processing -- ISIS-II
:		Fan out with:
:	RP -	Filter/port index
:	R10 -	ISIS port
:	RBP -	to-terminal buffer-pointer
:	RPI -	pointer to this port-table
IFAN	BA(NEDMSG,IFANCR)		:00 - Needle...crash if we get one
	BA(DETMSG,INPZAP)		:9E - ZAPPER
	BA(ZAPMSG,INPZAP)		:9F - DISCONECT
	BA(NOSMSG,NOSEND)		:A0 - APPLY BACKPRESSURE
	BA(SNDMSG,RESEND)		:A1 - RELEASE BACKPRESSURE
	BA(GOBMSG,GOBBLE)		:A2 - FLUSH OUTPUT
	BA(BKGMSG,RGOBBL)		:A3 - FLUSH INPUT
	BA(QTPMSG,QTP)			:B0 - QUERY TERMINAL PARAMETER
	BA(STPMSG,STP)			:B1 - SET TERMINAL PARAMETER
	BA(NLOGST,L.STAT)		:B4 - NORMAL LOGON STATUS
	BA(LOGFAL,L.FAIL)		:B5 - LOGON FAILURE
	BA(LOGOK,CIROK)			:B6 - SUCCESSFUL LOGON
	BA(TLMMSG,STXLIM)		:B9 - TRANSMIT LIMIT
	BA(ZAKMSG,ZAPACK)		:BB - ZAPPER ACKNOWLEDGEMENT
  IF	UUNON
	BA(UUNMSG,GETUUN)		:C1 - DETECT UNIVERSAL USER NAME 
  EI	:UUNON
ISMSZ	EQ	.-IFAN-4


:	Illegal port-control message decoded by IFAN
IFANCR	ABORT(R4,C.INDM)

	IF	1-(NPAPRT!OUTDIA)
NEEDLE	EQ	IFANCR			:Don't expect one...crash if we get it
	ELSE

:	Process needle, connect to port or break circuit
NEEDLE	.GETH				:skip length
	.GETW			:Invoice number...toss
	.GETH				:destination host
	LR	R6,R0
	.GETH				:Orig. node number
	LR	R7,R0			:save copy
	.GETH				:Orig. host number
:	LR	R0,R0			:check if null
	NHI	R0,7FFF			:mask off possible extra bit
	JNFS	NEED1			:no
	SR	R0,R7			:yes...use node number instead (neg)
NEED1	ST	R0,ORIGH,,		:save it for later
	.GETH				:Orig. port number
	.GETW				:skip XXX, TPC
	.GETH				:IIX flag
    IF	X3ON
	NHI	R0,8000
	EXBR	R0,R0
	STB	R0,XPTEMP+1,,		:save IIX flag (upper t)
    EI
	.GETCH				:NID
        IF OUTDIA
        STH     R0,O.TMP2               :outdial is interested in CCT type
        EI
	NHI	R0,01F			:mask it down
	STH	R0,CCTTMP		:save it
	.GETCH				:user-name size byte
	LR	R5,R0			:save username size
         IF    OUTDIA
        CHI     R6,OTHOST               :do they want Outdial?
        JE      OT.NED                  :yes, process it
         EI     :OUTDIAL 
         IF     1-NPAPRT
        ABORT(R10,8B)
        ELSE    :it wasn't for Outdial so it is for addressable ports
	LCS	R7,1			:assume address will be null
	LA	R8,ORIGID,,		:set pointer to accumulate user name
:	Scan user name for occurance of ":"
NEED2	SIS	R5,1			:count another byte gone
	JLE	NEED5			:quit if no more
	.GETCH				:else get a byte of user-name
	THI	R0,80			:special chars have high-bit set...
	JN	NEED2			:...ignore these
	STB	R0,0,R8			:save it
	AIS	R8,1			:...and advance pointer
	CLHI	R0,3A			:looking for ":"
	JN	NEED2			:and keep scanning
	SIS	R8,1			:got ":", back up pointer
:	Now scan user name for occurance of "."
NEED3	SIS	R5,1			:count another byte gone
	JLE	NEED5			:quit if no more
	.GETCH				:else get a byte of user-name
	CLHI	R0,2E			:looking for "."
	JNBS	NEED3			:and keep scanning
:	Now scan user name for occurance of address digits
	LIS	R7,0			:accumulate address here
NEED4	SIS	R5,1			:count another byte gone
	JLEFS	NEED5			:quit if no more (allow for CR)
	.GETCH				:else get a byte of user-name
	SHI	R0,30			:"0"
	LIS	R1,$A 10
	MHR	R7,R1
	AR	R7,R0			:accumulate digits
	JBS	NEED4			:and keep scanning

:	Here with address in R7
NEED5	.GETCH				:get terminator char
	LR	R9,R0			:save copy
	JAL	R4,ELIR			:End-logical-input-record
	LR	R3,R7			:copy address
	LR	R4,R6			:copy host number
	JAL	R5,PA.FP,,		:find the port
	LR	RP,R0			:copy the portnumber found
	JGE	NEED6			:it was good...process it

        EI   :1-NPAPRT ndlcan is used by both Outdial and PA
:	Failure...cancel circuit
NDLCAN	LHL	R6,CCTTMP		:get network CCT
	TBT	R6,ASCMSG		:check if ASCII msg OK
	JEFS	NLCAN1			:skip if not
	LR	R1,R10			:...for port
	LB	R5,NEEDM,RP		:look up message to return
	LA	R5,NEEDM1,R5		:actual address
	JAL	R6,OCS			:output-canned-string
NLCAN1	LR	R1,R10			:...for port
	LHI	R2,DETMSG		:...detach
	JAL	R4,SLOR			:start-logical-output-record
	JAL	R4,ELOR			:end-logical-output-record
	J	INPUT			:and proceed with next message

:	Success...R9 has terminating char
:                 R15 has message(-BASE) to be sent to origination port
        IF      NPAPRT                  :used only by Port Addressing
NEED6	
	GETPTP(RPI,RP,RP)	 		:get port-table pointer
        STH     R15,HSTMSG,RPI          :save the location of message to orig
  IF	X3ON
        GL      ICAAU
X3CIP   EQ      1
        TBT     RP,ICAAU                :accept incoming calls?
        JEFS    NEED62                  :NO
	LB      R5,X3STAT,RPI           :YES, next test
        SIS     R5,X3CIP                :call in progress?
        JNFS    NEED64
NEED62  LCS     RP,4
        J       NDLCAN                  :no can it
  EI	:X3ON			:*500.sdw*
NEED64
	MINH(R0,IPORTS)			:update front-panel display
	STH	RP,PMAPIA,R10,R10	:set up maps
	STH	R10,PMAPAI,RP,RP
	LHI	R0,FIRST-1		:use FIRST-1...
	STB	R0,XLIMIT,RP		:...to set initial transmit-limit
	LIS	R0,8			:return message...8 bytes long,
	LR	R1,R10			:...origination port,
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR			:
	LIS	R0,0			:
	.PUTCH				:pad
	LHL	R0,ASNPUT,RP,RP		:Physical unit adjust factor
	OI	R0,0E0010000		:/TYPE/MESSAGE/SUB-MESSAGE/PORT
	.PUTW	
	JAL	R4,ELOR
  IF	PVC			:** 4.02LH
	L	R0,.PVCX,RPI		:PVC parameters?
	TI	R0,POPRB		:Probe message required?
	JEFS	NEED66			:no, skip
	LHI	R0,12			:12 = ckt successful
	STB	R0,PROBVL		:store value
	JAL	RCH,PROBMG		:send out probe message
  EI	:PVC			:** 4.02 LH
NEED66
  IF	TTELEX			:** 4.02 LH
	TBT	RP,TTLXP,,		:transparent telex ports?
	JEFS	NEED68			:no, skip
	RBT	RP,EMTBRK		:ckt successful, don't emit space to devices
	SBT	RP,MRKING		:marking both directions
  EI	:TTELEX			:** 4.02 LH
NEED68	SBT	RP,SENDON		:Release backpressure
	RBT	RP,LOGING		:no longer a logger
	RBT	RP,NEWLOG		:...and certainly no longer first time
	SBT	RP,GOT.PN		:port has circuit
	L	RBP,.FTBUF,RPI		:from-port buffer-pointer
	MAKEBF(R1,TOISIS,RP)		:reconnect to ISIS output process
	JAL	R3,CHNGBF
  IF	X3ON
	STB	R9,XPTEMP,,		:save terminator (for ACK to caller)
	TBT	RP,CMMODE,,		:is port PAD capable?
	JEFS	NEED69			:no - treat port like consat port
	JAL	R9,XINCAL,,		:yes - treat like PAD port
	J	INPUT			:and now go back for more data
  EI
NEED69	LHI	R0,3A			: ":"
	STB	R0,0,R8			:append to username
	LHI	R3,1,R8			:update and copy pointer
	L	R0,ORIGH,,		:now install host number
	JGE	NEED7			:real host number
	LHI	R0,4E			:"N"
	STB	R0,0,R3			:no host number, so append "Nnnnn"
	AIS	R3,1
	LIS	R0,0
	STB	R0,4,R3			:append terminator
	S	R0,ORIGH,,		:get node number back
	LIS	R4,4			:4 bytes
	JAL	R6,OOS,,		:output-octal-string
	JFS	NEED8			:and skip
NEED7	LIS	R4,0			:host...append terminator
	STB	R4,5,R3
	LIS	R4,5			:5 bytes
	JAL	R6,ODS,,		:output-decimal-string
NEED8	HS
: Below is to avoid last char ack which is useless have msg definable by host
: IF	PVC			:** 4.02 LH
:	L	R6,.PVCX,RPI		:PVC exceptions
:	TI	R6,POTXT		:if NOTXT set
:	JN	NEED9			:then no CR/LF
: EI	:PVC			:** 4.02 LH
:	LR	RBC,R9
:  It seems useless to use the last char of the username as an ack when we
:  have a whole definable message.  The only chars it could be is semicolon or
: CR (swedel:39;:pw =semi  swedel:39cr (default password or get prompted for it
:	JAL	RCH,PUTCHR
:	NHI	R9,7F
:	SIS	R9,0D			:CR?
:	JNFS	NEED9			:no
:	LIS	RBC,0A			:yes...output LF
:	JAL	RCH,PUTCHR
        LHL     R6,HSTMSG,RPI           :address of ack messge
        AI      R6,BASE
        JAL     R9,MSG,,                :to .ftbuf
NEED9	JAL	RLINK,PA.SP,,		:seize the port
	J	INPUT			:and now go back for more data

        EI  :NPAPRT -message used by both Outdial and Port Addressing
:	Needle messages and message table
NEEDM1	SC	'"8D"8Ano ports'
NEEDM2	SC	'"8D"8Anot a valid address'
NEEDM3	SC	'"8D"8Anot available'
NEEDM4	SC	'"8D"8Aaddressed port busy'

	BC	(NEEDM4-NEEDM1),(NEEDM3-NEEDM1),(NEEDM2-NEEDM1),0
NEEDM	BS	0			:label for message addressing

ASCMSG  HC	0FFFE,0FFFF		:ASCII msg ok
					:only bar BAUDOT/TELEX for now
	EI	OUTDIA or NPAPRT


         IF     OUTDIA
:       OT.NED  NEEDLE jumped here after processing to username
:               bytes (in R0).  Routine must find a free port
:               , output greeting message, and connect to OT.BUF
:               When done it jumps to INPUT.

OT.NED  JAL     R4,FLUSH                :finish off needle
        L       R0,OT.COM               :list of free command ports
        JFFO    R0,OT.NE1
        J       OTBYE                   :no free ports
OT.NE1  CHI     R1,NOPORT       :against number of ports
        JGE     OTBYE
        RBT     R1,OT.COM               :set port use
        LHI     RP,.OPORT,R1            :PORT NUMBER
        SBT     RP,SENDON               :release backpressure to net
        SBT     RP,TAM                  :allow info to get to Outdial
        GETPTP(RPI,RP,RP)                 :get port table pointer
        MINH(R0,IPORTS)                 :update front panel display
        STH     RP,PMAPIA,R10,R10       :set isis to async mapping
        STH     R10,PMAPAI,RP,RP        :set async to isis mapping
        L       RBP,.FTBUF,RPI          :connect from terminal buffer
        MAKEBF(R1,TOISIS,RP)            :to isis output
        JAL     R3,CHNGBF
        LHI     R0,FIRST-1
        STB     R0,XLIMIT,RP            :set transmit limit
        JAL     R0,OTDNED,,             :continue needle in module
        J       INPUT

OTBYE   LCS     RP,1                    :no ports
        J       NDLCAN

         EI     :OUTDIA


:	ISIS port zapped!  Clear mapping immediately so ISIS can
:	reuse the port number with safety.

INPZAP	JAL	R4,ELIR			:close input record
	TS	PMAPIA,R10,R10		:CLEAR ISIS-->filter
	RBT	RP,SENDON		:backpressure until have circuit*402sdw
	RBT	RP,GOT.PN		:no circuit
	JAL	RCH,EMPTY		:empty to-port buffer
	JAL	RLINK,CIRDSC		:zap ckt immediately **4.02 LH
	LO	SIGNAL
	LHI	R4,ZAPSIG		:send on Zapper
	FO	SIGNAL
	L	RBP,.TTBUF,RPI		:to terminal buffer  **4.02 LH
	JAL	RCH,PUTSIG		:send on to filter
	L	RBP,.FTBUF,RPI		:empty from-port buffer
	JAL	RCH,EMPTY
	TBT	RP,TOIIX		:**6.00 LH if IIX capable port,
	JNFS	INZAP1			:don't empty logon buffer
	L	RBP,.LGBUF,RPI		:clear logon buffer
	JAL	RCH,EMPTY
INZAP1
  IF	X3ON			
	LIS	RBP,0			:prepare to init character count 
	STH	RBP,P.BCT,RPI		:init character count to zero *6.02 dlg
	L	RBP,.FEDBF,RPI		:get edit buffer pointer
	JAL	RCH,EMPTY		:empty buffer
  EI	(X3ON)
        IF      OUTDIA
        L       RBP,.OTBUF,RPI
        JAL     RCH,EMPTY
        EI      :OUTDIA
	L	RBP,.VSTAT,RPI		:what is current receiver routine ptr?
	CI	RBP,P.VASC		:are we reading async ring? *6.02 DLG
	JNFS	INZAP2			:yes
	L	RBP,.VSAVE,RPI		:no, restore receiver routine ptr
	ST	RBP,.VSTAT,RPI		:resume reading async ring
INZAP2	J	INPUT			:go on to next record
:	Acknowlegement from detach... clear mapping to ISIS.
ZAPACK  JAL     R4,ELIR                 :should no get it, but do handle it
        J       INPUT                   :changed so PAD does not need or ask
                                        :for zapper ack   *500.sdw

:	Set Terminal Parameter
STP	.GETCH				:which parameter
	LR	R6,R0			:copy parameter number
	.GETCH				:get value
	LR	RBC,R0
	LB	R4,P.SIG,R6		:look up signal number
	JE	INPUT9			:abort if null
	JAL	RCH,PUTSIG		:else send the signal
	J	INPUT9			:and close record


:	Query Terminal Parameter
QTP	.GETCH				:which parameter?
	LR	R6,R0			:copy parameter number
	LB	R4,P.SIG,R6		:look up signal number
	JE	INPUT9			:abort if null
	AIS	R4,1			:Query N = set N + 1
	JAL	RCH,PUTSIG		:else send the signal
	J	INPUT9			:and close record

	LO	SIGNAL

:	Table of expansions of Query and Set terminal parameters
:	(Makes use of fact that Query-signals = Set-signals + 1)
P.SIG	BC	SECSIG,SCISIG,SLCSIG,SCLSIG,SCRSIG,SIRSIG	:0-5
	BC	SORSIG,SPRSIG,SHDSIG,SPASIG,SPBSIG,SPCSIG	:6-B
	BC	SXESIG,SCHSIG,SRXSIG,SPDSIG,SKKSIG,STBSIG	:C-11
	BC	SEXSIG,SQMSIG,SSPSIG,0,0,0			:12-17

	FO	SIGNAL


:	GOBBLER
GOBBLE	JAL	RCH,EMPTY		:empty to-terminal buffer
	LO	SIGNAL
	LIS	R4,GOBSIG
	FO	SIGNAL
	JAL	RCH,PUTSIG		:send it
	RBT	RP,BKPRSR		:check if we've applied backpressure
	JE	INPUT9			:continue if not
	LHI	R2,SNDMSG		:else release back-pressure from ISIS

:	Close input record and return new message
GOB200	JAL	R4,ELIR			:close input record
	J	INPUT4

:	Reverse Gobbler
RGOBBL	L	RBP,.FTBUF,RPI		:locate buffer
	JAL	RCH,EMPTY		:empty buffer
	J	INPUT9			:and close record

:	NEW PSEUDO-NEEDLE
NPNEED	.GETH				:skip Type|ISIS-key
	.GETH				:get internal key
	LHI	R2,ZAPMSG		:prepare to zap if not current sequence
	LBR	RP,R0			:save physical-port portion
	SRLS	R0,8			:isolate sequence number
	CLB	R0,SEQKEY,RP		:is Pseudo-needle good?
	JN	GOB200
	TBT	RP,RLA			:is port still active?
	JE	GOB200			:go zap if not
	JAL	R4,ELIR			:else End-Logical-Input-Record
	MINH(R0,IPORTS)			:update front-panel display
	STH	RP,PMAPIA,R10,R10	:set up maps
	STH	R10,PMAPAI,RP,RP
	GETPTP(RPI,RP,RP)			:set port-table
	SBT	RP,GOT.PN		:we have a circuit
	LHI	R0,FIRST-1		:use FIRST-1...
	STB	R0,XLIMIT,RP		:...to set initial transmit-limit
	JAL	RLINK,CIRBLT		:inform CONSAT to proceed
	J	INPUT			:go back for another message

:	Set transmit-limit
STXLIM	.GETCH				:get limit in R0
	LR	R0,R0			:first test
	JLEFS	STXLM1			:can't set to 0
	CLHI	R0,FIRST-1		:range check
	JLFS	STXLM2
STXLM1	LHI	R0,FIRST-1		:use MIN(given, FIRST-1)
STXLM2	STB	R0,XLIMIT,RP		:and set limit
	J	INPUT9			:go close input record


:	LOGON Status
L.STAT	.GETCH				:get the status
	LR	R9,R0
	JAL	R4,ELIR			:End-Logical-Input-Record
.LSTA1	JAL	RLINK,LSTAT,,		:go process it
	J	INPUT			:Done - go get another message

:	Logon Failure
L.FAIL	.GETCH				:get error code
	LBR	R5,R0			:copy error
	JAL	R4,ELIR			:...and terminate record
	LA	RLINK,INPUT		:set exit address
	JAL	RCH,EMPTY		:empty to-terminal buffer
	LCS	R9,4			:yes...status reason -4
	J	XLSTAT,,		:invoke special handler

:	SUCCESSFUL NEW LOGON
CIROK	HS
  IF	PVC
	RBT	RP,PSNT1		:cancel time-out for psudo needle
	RBT	RP,PSNT0
  EI	:PVC

	.GETCH				:**6.00 LH
	RBT	RP,IIXCAP		:**6.02 LH
:	RBT	RP,IIXCAL		:moved 6.02 - to CIRDIS dlg
	THI	R0,1
	JE	CIROK2			:if did not reach smart host
	SBT	RP,IIXCAP		:else set IIXCAP to talk IIX **6.02 LH
	SBT	RP,IIXCAL
	L	R1,.VSTAT,RPI		:**6.02 LH
	ST	R1,.VSAVE,RPI		:save the current receiver pointer
	LA	R1,P.VASC		:load new receiver filter
	ST	R1,.VSTAT,RPI		:to current receiver state
	J	CIROK5	

  :  If did not reach smart host then reset to
  :  default profile 0 which is Tymnet transparent
CIROK2	HS
  IF	X3ON			
  	TBT	RP,PADACT		:was call made from PAD port?
	JE	CIROK5			:no, do not reinitialize term parms
	STM	R0,TEMPA		:save register
        LR      R1,RP                   :this saving should work for all prts
        SRHLS   R1,4                    :*sdw.500
	L	R10,YONENA,R1		:save reverse XON/XOFF in R10
	L	R11,XONENA,R1		:save XON/XOFF in R11
	LIS	R1,0			:reset current profile to
	STB	R1,X3CPRO,RPI		:profile #0 (tymnet transparent)
	JAL	R9,INITCS,,		:together with its CONSAT arrays
	JAL	R9,INITX3,,		:together with its parameters
        LR      R1,RP                   :and restore them
        SRHLS   R1,4                    :*sdw.500
	ST	R10,YONENA,R1		:restore back reverse XON/XOFF value
	ST	R11,XONENA,R1		:restore back XON/XOFF value
	LHL     R4,.TERMT,RPI           :set ECR.LF as term type
	GL	XTGATE
	RBT	RP,XTGATE		:not talking gateway IIX *500.sdw
        LHL     R2,VID.FL,R4,           :get flags
        THI     R2,2                    :flag for ECR.LF
        JEFS    CIROK4
        SBT     RP,ECR.LF               :now all is ok *500.sdw
CIROK4	LR      R1,RPI
        LM      R12,PABLE,,
        STM     R12,.ECHT1,R1
        STM     R12,.ECHT2,R1
	LM	R0,TEMPA		:restore back register
  EI  :X3ON
CIROK5	LIS	R0,6			:eat rest of message
	JAL	R4,FLUSH
	LIS	R0,8			:return message...8 bytes long,
	LR	R1,R10			:...origination port,
	LHI	R2,ADAMSG		:...addendum to accounting
	JAL	R4,SLOR
	LIS	R0,0
	.PUTCH				:pad
	LHL	R0,ASNPUT,RP,RP		:Physical unit adjust factor
	OI	R0,0E0090000		:/TYPE/MESSAGE/SUB-MESSAGE/PORT
	.PUTW	
	JAL	R4,ELOR
	 IF	PVC			:** 4.02 LH
	L	R0,.PVCX,RPI		:PVC exceptions
	TI	R0,POPRB		:Is PROBE-message desired?
	JE	CKTOK1			:No, skip
	LHI	R0,12			:Yes,desire PROBE-message
	STB	R0,PROBVL		:PROBVL=12 -- complete network ckt
	JAL	RCH,PROBMG		:Send message out
	 EI	:PVC
CKTOK1
	 IF	TTELEX			:** 4.02 LH
	TBT	RP,TTLXP,,		:Transparent telex ports?
	JEFS	CKTOK2			:no, skip
	RBT	RP,EMTBRK		:otherwise, don't emit space to devices
	SBT	RP,MRKING		:marking both directions
	 EI	:TTELEX
CKTOK2	SBT	RP,SENDON		:Release backpressure
        TBT     RP,KATERM               :control-K typed at login?
        JEFS    CIROK6
        SBT     RP,KATAKN               :yes set
        RBT     RP,KATERM
CIROK6	RBT	RP,LOGING		:no longer a logger
	RBT	RP,NEWLOG		:...and certainly no longer first time
	TBT	RP,IIXCAP		:**6.02 LH, check if IIX capable
	JEFS	CIROK7
	L	RBP,.LGBUF,RPI		:no longer use logger buffer on ckt ok
	MAKEBF(R1,TOIIX,RP)		:connect to IIX buffer process
	JAL	R3,CHNGBF
CIROK7
  IF	NMPVC
	RBT	RP,MPCLOG		:MPVC circuit is built
  EI	:NMPVC

  IF	X3ON
	JAL	RLINK,CALOK,,		:make sure valid login
  ELSE
	L	RBP,.FTBUF,RPI		:from-port buffer-pointer
	MAKEBF(R1,TOISIS,RP)		:reconnect to ISIS output process
	JAL	R3,CHNGBF
  EI

	J	INPUT			:and quit


:	Get UUN (Universal User Name) value from ISIS Ring
:	    R0 = UUN value in binary form
:	    R2 = UUN value in BCD form	
:	    R4,R9 = return address
GETUUN
  IF	UUNON
	.GETCH				:skip the unused field	
	.GETW				:get UUN value from the Input ring
	JAL	R4,ELIR			:end logical input record
	JAL	R9,GETBCD		:convert binary UUN value into BCD
	ST	R2,UUNVAL,RPI		:save the UUN value in BCD form
	LA	R3,DTECLG,RPI
	JAL	RCH,DEFADR,,		:set calling address  	
	J	INPUT			:go back for another message 
  EI 

:  PRTSWI       switches ISIS I/O from R9 to RP
PRTSWI  LHL     R1,PMAPAI,R9,R9 :get ISIS (rings) number
        STH     R1,PMAPAI,RP,RP   :now here
        TS      PMAPAI,R9,R9    :clear old
        STH     RP,PMAPIA,R1,R1 :have ISIS send here
        SBT     RP,SENDON       :and be able to use port
        LB      R1,XLIMIT,R9    :old transmit limit is new one
        STB     R1,XLIMIT,RP
        JR      R7


:	Special ISIS-internal messages (ISIS port 0)
INSPEC	LHI	R4,INSPS		:search the table
INSP1	CLB	R2,INSPT,R4		:...for a match
	JNFS	INSP2			:skip if not
	L	R4,INSPT,R4		:else get address
	JR	R4			:...and go do it
INSP2	SIS	R4,4			:do next
	JGEBS	INSP1
	LB	R0,INDLGT,R2,		:get length and check if it can be flushed
	JEFS	INSPCR			:no, so crash
	JAL	R4,FLUSH		:else flush it
	J	INPUT

:	Illegal intra-node message decoded by INSPT
INSPCR	ABORT(R8,C.IINM)

INSPT	BA(INDNON,NONEDL)		:unable to provide pseudoneedle
	BA(INDREJ,REJHST)		:host rejected by supe/node
	BA(INDREM,REMOT)		:1-down remote
INSPS	EQ	.-INSPT-4		:size of table

:	Intra-node message length
:	(0 denotes variable length, can't be flushed)
INDLGT	BC	$A 1,1,1,7		:0-3
	BC	$A 10,6,6,9		:4-7
	BC	$A 0,5,8,5		:8-11d
	BC	$A 8,1,0,1		:13d-15d
	BC	$A 12,0,0,0		:16d-19d

REJHST  ABORT(R8,C.IIHR)                :host rjected by supe/node 403*sdw

:	REMOTE message
REMOT	.GETH				:get type and key
	.GETCH				:Flush sub-type
	.GETCH				:get size
	LR	R5,R0			:save copy
	JE	REMO2			:skip if = 0
	LIS	R6,0			:set index
REMO1	.GETCH				:for each character...
	STB	R0,ULMSG,R6
	AIS	R6,1			:bump index
	SIS	R5,1			:count it gone
	JGBS	REMO1
	STB	R5,ULMSG,R6		:...then terminate
	J	INPUT9			:and continue
:	count was 0...restore original message
REMO2	LHI	R1,80-4			:There's 80 bytes to move
REMO3	L	R0,IULMSG,R1,		:Copy 4 bytes
	ST	R0,ULMSG,R1
	SIS	R1,4
	JGEBS	REMO3			:repeat
	J	INPUT9			:and continue

:	Unable to provide normal-needle
NONEDL	.GETH				:skip message type & ISIS key
	.GETH				:get our key
	LBR	RP,R0			:copy port number
	EXBR	R5,R0			:extract key
	LBR	R5,R5
	.GETH				:skip error code
	JAL	R4,ELIR			:...and terminate record
	LA	RLINK,INPUT		:set exit address
	CLB	R5,SEQKEY,RP		:Pseudo-needle good?
	JNR	RLINK			:ignore if not
	GETPTP(RPI,RP,RP)			:get pointer to port-table
	L	RBP,.TTBUF,RPI		:set to-terminal buffer-pointer
	JAL	RCH,EMPTY		:empty the buffer
	LCS	R9,3			:yes...status reason -3
	J	XLSTAT,,		:invoke special handler
	SUBTTL	(ISIS) ISIS RING I/O...OUTPUT INTERFACE

:	OUTPUT TO ISIS
:	--------------
:	Run off timeout, every 25 ms.

OUTCRA	ABORT(RLINK,8D)		:no dport on output

OUTPUT	LHI	RPOL,(NGRP-2)*2		:word index...
OUT1	L	R0,SENDON,RPOL		:ports not backpressured
	ST	R0,P.DONE,RPOL		:ports neither backpressured nor serviced
OUT2	L	R0,P.DONE,RPOL		:port not yet serviced
	N	R0,TOISIS,RPOL		:...and Data-present for ISIS
	JFFO	R0,OUT3			:Any candidates?
	SIS	RPOL,4			:no...repeat for all groups
	JGEBS	OUT1
	J	IOPOL4			:Then exit

OUT3	LR	RP,RPOL			:Got one...construct internal port-number
	SLLS	RP,3
	AR	RP,R1			:RP is port number
	GETPTP(RPI,RP,RP)			:pointer to port-table
	L	RBP,.FTBUF,RPI		:Set from-terminal buffer-pointer
	JAL	RCH,GETCHR		:Check out first character
	 J	OUT8			:control signal...skip to send
	LR	R7,RBC			:data-char
	LB	R9,XLIMIT,RP		:construct a data message
	LHI	R0,3,R9			:How big the record will be
	RBT	RP,P.DONE		:mark port as serviced
	LH	R1,PMAPAI,RP,RP		:look up ISIS port number
	JL	OUTCRA			:crash if have no dport
	JAL	R4,SLOR			:Start-Logical-Output-Record
	L	RBP,.FTBUF,RPI		:locate From-terminal buffer
	LR	RBC,R7			:send first data-character

OUT4	.PUTR1
	SIS	R9,1			:count another character placed
	JGFS	OUT6			:don't make message too big

OUT5	JAL	R4,ELODR		:big enough...stop now
	J	OUT2

OUT6	TBT	RP,TOISIS		:Any more data?
	JEBS	OUT5			:...if not, end data record
	JAL	RCH,GETCHR		:OK...look at next character
	 J	OUT7			:Control-signal, so send it on
	J	OUT4			:pass it

:	Control signal detected in input, terminate output, then process
OUT7	JAL	R4,ELODR		:End-Logical-Output-Data-Record

:	We got a control-signal...process it
	 LO	SIGNAL
OUT8	CLHI	R5,ZAPSIG		:zapper?
	JNFS	OUT12			:no...skip
	JAL	RLINK,CIRDIS		:yes...disconnect the circuit
        J       OUT2
OUT12   CLHI    R5,DETSIG               :detach?
        JNFS    OUT9                    :no, skip
        JAL     RLINK,CIRDET            :disconnect circuit
	J	OUT2			:and proceed with next port

:	non-zapper...process it

OUT9	LR	R7,RBC			:copy value (if any)
	LIS	R0,8			:set excessive length for now
	LH	R1,PMAPAI,RP,RP		:look up ISIS port number
	JL	OUTCRA			:crash if have no dport
	LB	R2,OUT.T1,R5		:look up ISIS message type
	JAL	R4,SLOR			:Start-Logical-Output-Record
	SHI	R5,SIRSIG		:Check for Set/Query
	 FO	SIGNAL
	JL	OUT10			:skip if not
	LB	R0,OUT.T2,R5		:Query/set...translate type-number
	.PUTCH		
	THI	R5,1			:is it Query?
	JNFS	OUT10			:yes...just clean up
	EXBR	R0,R7			:set...copy value
	.PUTH				:...and send it too

OUT10	JAL	R4,ELOR			:Done...End-Logical-Output-Record
	J	OUT2			:then go process next port


:	Table of translation from Signals to ISIS
OUT.T1	BC	0,0,BRKMSG,BNDMSG,0,ZAPMSG			:0-5
	BC	0,0,EDMMSG,LDMMSG,HNGMSG,SHGMSG			:6-0B
	BC	ZAPMSG,GOBMSG,RBMSG,GBMSG,OBMSG,YBMSG		:0C-11
	BC	GRYMSG,BLKMSG,ETMMSG,LTMMSG,EADMSG,LADMSG	:12-17
	BC	SIXMSG,TIXMSG,DETMSG,0,0,0			:18-1D
	BC	0,0						:1E-1F
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:20-25
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:26-2B
	BC	0,0,0,0						:2C-2F
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:30-35
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:36-3B
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:3C-41
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:42-47
	BC	STPMSG,QTPMSG,STPMSG,QTPMSG,STPMSG,QTPMSG	:48-4D  4.01U
	BC	0,0						:4E-4F

:	Translation of signal type to parameters
:	(relative to SIRSIG)
OUT.T2	BC	$A  5,  5,  6,  6,  9,  9			:20-25
	BC	$A 10, 10, 11, 11, 15, 15			:26-2B
	BC	$A  0,  0,  0,  0				:2C-2F
	BC	$A  0,  0,  1,  1, 13, 13			:30-35
	BC	$A  3,  3,  2,  2,  4,  4			:36-3B
	BC	$A  7,  7,  8,  8, 12, 12			:3C-41
	BC	$A 14, 14, 16, 16, 17, 17			:42-47
	BC	$A 18, 18, 19, 19, 20, 20			:48-4D 4.01U
	BC	$A  0,  0					:4E-4F

	FO	DATA
	SUBTTL	(ISIS) ISIS-Ring Handling Routines

:	ISIS-ring handlers

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 15 is dedicated to that operation,
:		until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.

:		R15 is used for input and output operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15' to 'LH R15'.

:	The package contains primitive routines:

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (0C) [CHANGED FROM (0A)] return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R15,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	Routines use dedicated register:
:	R15	ISIS ring index

:	NOTE....
:		IRSIZE and ORSIZE must each be less than 32K.


	GL	IRING,ORING,IRSIZE,ORSIZE

:	Define Ring-structure:
	D.STRU(0)
NFMI	HS	1			:next-fill-message-index
CEI	HS	1			:Current-Empty-Index
RING	BS	4			:start-of-ring-data
	D.STRU(-1)

:	Define data area
	SEG	A.RING			:rings in ring area

:	The dispatcher output ring
ORING	WS	0			:Output Block Start Address
	HS	1			:output next fill message cursor
	HS	1			:output current entry cursor
	BS	ORSIZE			:the output ring
EORING	HS	0			:End of output ring

:	The DISPATCHER input ring
IRING	WS	0			:Input-Block start address
	HS	1			:input next fill message cursor
	HS	1			:input current empty cursor
	BS	IRSIZE			:the input ring
EIRING	HS	0			:End-of-input ring

:	DISPATCHER TIMING HISTORY

	IF	ORTIME!IRTIME
	SEG	A.DATA
ITIMGO	HC	-1			:init to not run
OTIMGO	HC	-1			:init to not run
RTMSAV	WS	1			:return register save
RTIMEX	HS	1			:index of history buffer
RTMBUF	WS	100			:BUFFER
	EI			:ORTIME!IRTIME


:	Code area
	SEG	A.CODE
:	Input Routines

:	LOOK at a ring entry
:       Called only by INPUT
:	Normal return if ring empty
:	Else return R4 + 0C, PORT returned in R1
:	Message-Type returned in R2
:	All registers set up for transfer
:	Position is advanced past port-number
	 IF	\LOOK;.LOOK.	  HS	0;	 ELSE;LOOK	  HS	0;	 EI
	LHL	R15,CEI+IRING,,		:Get current-empty-cursor
	CLH	R15,NFMI+IRING,,	:test if caught up
	JER	R4			:empty...normal return

	IF	IRTIME

	TS	ITIMGO			:do we take history?
	 JL	.LO10.			:negative - don't save info
	LHL	R15,RTIMEX		:get index
	STH	R4,RTMBUF+4,R15		:  store caller
	ST	R4,RTMSAV		:now we can save it
	LR	R4,R15			:exchange index registers
	L	R15,FASTC,,		:get the time
	ST	R15,RTMBUF,R4		:  store it
	LHL	R15,CEI+IRING,,		:get ring pointer
	OHI	R15,8000		:indicate this is 'input' from isis
	STH	R15,RTMBUF+6,R4		:  store it
	LHL	R15,CEI+IRING,,		:return ring pointer
	AIS	R4,8			:increment index
	NHI	R4,3F8			:take care of wraps
	STH	R4,RTIMEX		:store away index
	STH	R4,ITIMGO		:make switch non-zero
	L	R4,RTMSAV		:return return-address

.LO10.	EI			:IRTIME

	SHI	R15,IRSIZE		:*: Convert to negative cursor
	LHL	R1,EIRING,R15,		:get port number
	AIS	R15,2			:bump cursor past port number
	LB	R2,EIRING,R15,		:get message type
	LR	R1,R1			:set condition codes
	J	(LOKRET-INPUT1-4),R4	:skip return back to INPUT

:	GET a CHaracter from the input ring
:	Character returned in R0
GETCH	LB	R0,EIRING,R15,		:get the character
	AIS	R15,1			:bump cursor
	JLR	R4			:return if not
	LHI	R15,-IRSIZE		:else fold it
	JR	R4			:and exit

:	GET a Half-Word from the input ring
:	Assume have removed an INTEGRAL NUMBER of HALF-WORDS from record
:	Half-word returned in R0
GETH	LHL	R0,EIRING,R15,		:get the half-word data
	AIS	R15,2			:bump cursor
	JLR	R4			:return if not
	LHI	R15,-IRSIZE		:else fold it
	JR	R4			:and exit

:	GET a Word from the input ring
:	Assume have removed an INTEGRAL NUMBER of WORDS from record
:	Word returned in R0
GETW	L	R0,EIRING,R15,		:get the word data
	AIS	R15,4			:bump cursor
	JLR	R4			:return if not
	LHI	R15,-IRSIZE		:else fold it
	JR	R4			:and exit

:	FLUSH an input record
:	Number of characters to flush in R0
FLUSH	AR	R15,R0			:Advance ring and fall through

:	End-Logical-Input-Record
ELIR	AIS	R15,3			:Force to next word
	NHI	R15,-4
	JLFS	ELIR2			:no
	SHI	R15,IRSIZE		:yes
ELIR2
	AHI	R15,IRSIZE		:*: convert to posative cursor
	STH	R15,CEI+IRING,,
	JR	R4			:and exit

:	OUTPUT Routines

:	OCS -	Output Canned String
:		OCS will output string as a data message to the specified
:		port.  OCS goes to completion, and "ends" the operation.
:	R6 -	link
:	R1 -	port #
:	R5 -	pointer to SC text string
OCS	LB	R2,0,R5			:get count N (also message type)
	LHI	R0,6,R2			:Compute space required
	JAL	R4,SLOR			:start-logical-output-record
OCS1	AIS	R5,1			:Bump source character pointer
	LB	R0,0,R5			:get the next character
	.PUTCH				:place into ring
	SIS	R2,1			:reduce count
	JGBS	OCS1			:repeat until all characters placed
	JAL	R4,ELOR			:end-logical-output-record
	JR	R6			:then exit

:	Find SPACE in the ring (How big a message it will take)
:	Returns R0 = Number of characters of space
SPACE	LCS	R0,4			:set mask
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,		:force emptier to Word boundary
	SR	R0,R15			:space between us and emptier
	JGFS	SPACE1			:skip if no wrap-around
	AHI	R0,ORSIZE		:else correct for wrap
SPACE1	SIS	R0,4			:Correct for possible overflow
	SHI	R15,ORSIZE		:*: convert to negative cursor
	JR	R4			:and return

:	Start-Logical-Output-Record
:	Provides function of ROOM, PUTH, & PUTCH for first 3 characters of message
:	R0 = number of characters of space required
:	R1 = port number
:	R2 = Message character code
SLOR	LHL	R15,NFMI+ORING,,
SLOR1	LCS	R3,4			:set a mask
	NH	R3,CEI+ORING,,		:force receiver to word boundary
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE		:account for possible ring folding
SLOR2	SIS	R3,4			:allow for potential overflow
	CR	R3,R0
	JGEFS	SLOR3			:skip if we can go
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	

	IF	ORTIME

	TS	OTIMGO			:do we take history?
	 JL	SLOR4			:negative - store
	LHL	R15,RTIMEX		:get index
	STH	R4,RTMBUF+4,R15		:  store caller
	ST	R4,RTMSAV		:now we can save it
	LR	R4,R15			:exchange index registers
	L	R15,FASTC,,		:get the time
	ST	R15,RTMBUF,R4		:  store it
	LHL	R15,NFMI+ORING,,	:get ring pointer
	STH	R15,RTMBUF+6,R4		:  store it
	AIS	R4,8			:increment index
	NHI	R4,3F8			:take care of wraps
	STH	R4,RTIMEX		:store away index
	STH	R4,OTIMGO		:make switch non-zero
	L	R4,RTMSAV		:return return-address

SLOR4	EI			:ORTIME

	SHI	R15,ORSIZE		:*: convert to negative cursor
	STH	R1,EORING,R15,		:OK...Place message
	STB	R2,2+EORING,R15,
	AIS	R15,3			:bump past these characters
	JR	R4			:and exit

:	PUT a CHaracter into the ring
:	R0 = Character
PUTCH	STB	R0,EORING,R15,		:Place the character
	AIS	R15,1			:bump cursor
	JLR	R4			:skip if not
	LHI	R15,-ORSIZE		:else wrap around
	JR	R4			:and exit

:	PUT a Half-Word into the ring
:	R0 = half-word
PUTH	STH	R0,EORING,R15,		:Place the half-word
	AIS	R15,2			:bump cursor
	JLR	R4			:exit if not
	LHI	R15,-ORSIZE		:else wrap around
	JR	R4			:and exit

:	PUT a Word into the ring
:	R0 = word
PUTW	ST	R0,EORING,R15,		:Place the word
	AIS	R15,4			:bump cursor
	JLR	R4			:skip if not
	LHI	R15,-ORSIZE		:else wrap around
	JR	R4			:and exit

:	End-Logical-Output-Data-Record
ELODR	LHL	R1,NFMI+ORING,,		:Get start of this message
	SHI	R1,ORSIZE		:*: convert to negative cursor
	LR	R0,R15			:copy message end
	SR	R0,R1			:compute size of this message
	JGEFS	ELODR2			:skip if no wrap-around
	AHI	R0,ORSIZE		:else correct for wrap
ELODR2	SIS	R0,3			:Make allowance for header
	JER	R4			:exit if zero-length message
	STB	R0,2+EORING,R1,		:insert message type into message
					:and fall through

:	End-Logical-Output-Record
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE		:fold if necessary
ELOR2
	AHI	R15,ORSIZE		:*: convert back
	STH	R15,NFMI+ORING,,	:now advance cursor to next message
	JR	R4			:and exit

	EM	:ISIS
	SUBTTL	(ISIS) PORT TABLE

:	We're finally able to define the port discriptor tables:

:	Firstly, generate a table of halfword pointers to port descriptors.
.PTP.	HS	0
Q	EQ	0
	RE	NPORT			:For each port
	 HC	Q*.PTLEN+.PTABL
Q	 EQ	Q+1
	ER

	SEG	A.DATA


:	Now define the space for the port descriptors
.PTABL	HS	NPORT*.PTLEN/2


:	ALL DONE!!
	SEG	A.CODE
:	KILL	TOISIS
  $+