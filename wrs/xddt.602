    SUBTTL	XDDT.602 - THE EXTENDED DDT FUNCTIONS
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by  TYMNET, Incorporated.                                   **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **  File Name          :  XDDT.602       last change: 11/20/86  **
: **                                                              **
: **  File Description   :  The extended DDT uses slot code and   **
: **			    this code uses port data to describe  **
: **			    the status for each port.             **
: **                                                              **
: **  File Abstract      :  This module is used to handle the     **
: **			    extended DDT commands which is invoked**
: **			    by the ?STAT command.                 **
: **                                                              **
: ******************************************************************
: **                    CHANGE LOG                                **
: **                                                              **
: **  Ver   Date    By   PIR/NSR  Changes (most recent at top)    **
: ** ----- -------- ---  -------- ------------------------------- **
: ** 06.02 11/20/86 cab		  Disable MODIZ until race fixed. **
: ** 06.02 11/07/86 DLG		  Changed PMODE to PADACT.	  **
: ** 06.01 09/22/86 cab           MODIZ cmd now exits via OPORT and*
: **				  display outdial capable ports.  **
: ** 06.01 09/18/86 cab           Fixed Outdial crash in MODIZ cmd**
: ** 06.01 08/20/86 cab           Shortened symb display and added**
: **				  flag TRANHX to control hex to   **
: **				  ASCII translation for security. **
: ** 06.00 07/08/86 cab           Deleted DATEDT.		  **
: ** 06.00 06/28/86 sdw           Commands PVC and APVC to display**
: **                              PVC options set for all port and**
: **                              a single port, respectively.    **
: ** 06.00 06/24/86 LH		  Minor changes for CODE routine  **
: ** 06.00 06/24/86 LH		  Add new symbols for I/O ring    **
: **				  pointer at time of crash.       **
: ** 06.00 06/24/86 sdw           CRAT displays crash table       **
: ** 06.00 05/30/86 sdw           CODE displays time of startup,  **
: **                              last crash and current time     **
: ** 06.00 05/29/86 LH   	  Added new symbols for S-mode.   **
: ** 06.00 05/21/86 sdw           Port displays more info         **
: ** 06.00 05/21/86 sdw           Command MODIZ to find outdial   **
: **                              modems without restarting slot  **
: ** 05.00 04/06/86 sdw           Created Symbol command          **
: ** 05.00 03/06/86 sdw           Added MONIO which dumps rings   **
: **                              from present only.              **
: ** 04.03 02/24/86 sdw           Added command Aring to display  **
: **                              the async rings                 **
: ** 04.03 02/20/86 sdw           Added XCOMDI module into XDDT   **
: ** 04.03 01/20/86 sdw  n/a      Created from ENVIR.402          **
: ** 04.03 01/20/86 SDW  PIR 1653 Added Outdial DDT commands      **
: **                                                              **
: ******************************************************************
	SUBTTL  (XDDT) STAT Command Handlers:  HELP, CODE


	GL	CS.VER,CS.REV
GLOBAL(TRANHX,0)			:default-hex xlate is off
        SEG A.XDDT
	MO	.,STATUS
        LO      ISIS
        IF      OUTDIA
        LO      OUTDIA
        EI

X.BASE  EQ      .       :BASE FOR EXTENDED DDT

XEA     MACRO(X)[
        HC      X-X.BASE
]


:   SyMBol to ADdRess  takes a label and stores in in a form suitable for
:                      tty output.  Q is the symbol and N is the maximum
:                      field size.  It pads the field size with blanks if
:                      room.  It also prints negative numbers with a
:                      negative sign.
SMBADR  MACRO(Q,N)[
QQ      EQ      Q
QQQQ    EQ      1  :for first ch
QQQQQ   EQ      1  :put neg sign when 0
        IF      -Q
QQ      EQ      -QQ
QQQQQ   EQ      -1
        EI
        
        BS      N+1
        RE      N
        ORG  .-2
      IF QQ
QQQ     EQ      QQ-10*(QQ/10)
QQ      EQ      QQ/10
       IF  QQQ-9
        BC      QQQ+0B7 :letters
       ELSE 
        BC      QQQ+0B0
       EI
      ELSE  QQQQ
        AC      /0/
      ELSE QQQQQ
          AC    / /
      ELSE -QQQQQ
        AC / /
QQQQQ   EQ      0
        ELSE
QQQQQ   EQ      1
            AC  /-/
        EI
QQQQ    EQ      0
        ER  :end repeat
        ORG .+N-1
]

:  SMB6SP makes a symbols take 6 spaces by padding on right
SMB6SP  MACRO(Q)[
QQ      EQ      .
        AC      /Q/
        IF      6-.+QQ
        RE      6-.+QQ
        AC      / /
        ER
	EI
	AC	/ =/
]


:  SyMBol TeXT takes a serious of symbols and sets up a SC string to be output
:             by the SYMBOLS command    *5.00 sdw

SMBTXT  MACRO(NAME,A,B,C,D)[
NAME    BC      0
   IF \A ; SMB6SP(A)  ;  SMBADR(A,8) ; AC /   / ; EI
   IF \B ; SMB6SP(B)  ;  SMBADR(B,8) ; AC /   / ; EI
   IF \C ; SMB6SP(C)  ;  SMBADR(C,8) ; AC /   / ; EI
   IF \D ; SMB6SP(D)  ;  SMBADR(D,8) ; EI
QQ      EQ      .
	IF	QQ-NAME-1
        BC      8D,8A
	ORG	NAME
        BC      QQ-NAME+1
        ORG	QQ+2
        ELSE
        BC	01,00  :null SC string
        EI
]


	LO	DATA
        LO      CONSAT

	DS.CMD(HELP,HELP)		:Print Command List
	DS.CMD(IORING,XDRING)		:*****DECODE ISIS RING *****
	DS.CMD(MONIO,XDRMON)		:*****DECODE ISIS RING *****
        DS.CMD(IMON,XDRIMN)             :monitor one ISIS dport
	DS.CMD(?,HELP)			:Print Command List
	DS.CMD(CODE,CODE)		:Print Banner (which code this is).

HELP	SVC	K.OUT,BANNER
	SVC	K.OUT,HELPM1
	SVC	K.OUT,HELPM2
	SVC	K.OUT,HELPM3
	SVC	K.OUT,HELPM4
	SVC	K.OUT,HELPM5
	SVC	K.OUT,HELPM6
	SVC	K.OUT,HELPM7
	SVC	K.OUT,HELPM8
	SVC	K.OUT,HELPM9
	SVC	K.OUT,HELPMA
	SVC	K.OUT,HELPMB
	SVC	K.OUT,HELPMC
	SVC	K.OUT,HELPMD
	SVC	K.OUT,HELPME
	SVC	K.OUT,HELM10
	SVC	K.OUT,HELM11
	SVC	K.OUT,HELPMF
	SVC	K.OUT,HELM00
	SVC	K.OUT,HELM01
	SVC	K.OUT,HELM02
	SVC	K.OUT,HELM03
	SVC	K.OUT,HELM04
	SVC	K.OUT,HELM05
        SVC     K.OUT,HELM06
        SVC     K.OUT,HELM07
        SVC     K.OUT,HELM08
        SVC     K.OUT,HELM09
        SVC     K.OUT,HELM12
        SVC     K.OUT,HELM13
        SVC     K.OUT,HELM14
	J	DS.NXT

        LO      CRASH           :for tiem values
CODE	SVC	K.OUT,BANNER		:display banner
        JAL     R10,X.TIME
        J       DS.NXT

X.TIME  LO      DATIME
        L       R3,UPTIME,,             :time of slot loaded
        NI      R3,7FFFFFFF             :knock of high bit (unsure of time bit)
        LIS     R4,$A 13                :time without seconds
        STB     R4,TIMMSG,,             :number of characters
        LA      R5,TIMMSG+1,,           :where to put the time
        JAL     R6,DATIME,,             :lib to calculate DDMMMYY HH:MM
        SVC     K.OUT,CODEM0            :slot started msg
        SVC     K.OUT,TIMMSG,,          :time of start
        SVC     K.OUT,M.GMT             :tell em it is GMT
        SVC     K.OUT,CODEM1            :timeof last crash msg
        L       R3,CTIME,,              :and time of crash **6.00 LH
        NI      R3,7FFFFFFF             :ignore high bit
        JEFS    X.TIM1                   :no last crash if 0
        LIS     R4,$A 13
        LA      R5,TIMMSG+1,,
        JAL     R6,DATIME,,
        SVC     K.OUT,TIMMSG,,          :output time of last crash
        SVC     K.OUT,M.GMT
        J       X.TIM2
X.TIM1  LIS     R0,0                    :no last crash so put zeroes
        LHI     R1,750                  :seven of space fill
        SVC     KIO,0A
        LHI     R0,0A0                  :a space
        SVC     KIO,0E
        LIS     R0,0
        LHI     R1,250                  :two of zero fill
        SVC     KIO,0A
        LHI     R0,0BA                  :A colon
        SVC     KIO,0E
        LIS     R0,0                    :and no zeros of min
        SVC     KIO,0A
        SVC     K.OUT,M.GMT
X.TIM2  SVC     K.OUT,CODEM2            :and current time
        L       R3,GMT,,
        NI      R3,7FFFFFFF             :high bit is set if node out of net
        LIS     R4,$A 13
        LA      R5,TIMMSG+1,,
        JAL     R6,DATIME,,
        SVC     K.OUT,TIMMSG,,
        SVC     K.OUT,M.GMT
        FO      DATIME
        SVC     K.OUT,M.CRLF
	JR	R10

        FO      CRASH

CODEM0  SC      /"8D"8ASlot started at /
CODEM1  SC      /"8d"8aLast crash at   /
CODEM2  SC      /"8d"8aCurrent time is /
M.GMT   SC      /   GMT/

QSREV   EQ      CS.REV+1000     :display is 2 digits so force leading 0s
BANNER	BC	0   : setup banner with version number
 AC /"8A"8D"8ACONSAT -- CONsolidated tymSAT/ ; SMBADR(CS.VER,3); AC /./ ; SMBADR(QSREV,2) ; BC 8D
Q       EQ  .  ; ORG BANNER ; BC Q-BANNER-1 ; ORG Q ;
HELPM1	SC	/"8D"8AValid commands are:/
HELPM2	SC	/"8D"8AEXIT or EXI - log off/
HELPM3	SC	/"8D"8AQUIT or Q   - exit ?STAT (back to DDT)/
HELPM4	SC	/"8D"8AHELP or ?   - print this list/
HELPM5	SC	/"8D"8ACODE        - Describe the code in this slot/
HELPM6	SC	/"8D"8APORT        - Query status of all ports/
HELPM7	SC	/"8D"8AIPORT       - Query status of specific ISIS port/
HELPM8	SC	/"8D"8AAPORT       - Query status of specific physical port/
HELPM9	SC	/"8D"8AQBUSY       - Query status of busy ports/
HELPMA	SC	/"8D"8ABUSY        - busy a port/
HELPMB	SC	/"8D"8AUNBUSY      - unbusy a port/
HELPMC	SC	/"8D"8ABUFFS       - display all bufferlets/
HELPMD	SC	/"8D"8ABUFASC      - dump nonempty bufferlets in ascii/
HELPME	SC	/"8D"8ABUFHEX      - dump nonempty bufferlets in hex/
HELPMF	SC	/"8D"8AIORINGS     - gives prompt for following subcommands/
HELM10	SC	/"8D"8AMONIO       - monitors ISIS rings from present/
HELM11	SC	/"8D"8AIMON <num>  - monitors ISIS rings for a port/
HELM00	SC	/"8D"8A    Ixxxx   - IRING for xxxx hex seconds/
HELM01	SC	/"8D"8A    Oxxxx   - ORING for xxxx hex seconds/
HELM02	SC	/"8D"8A    Bxxxx   - Both for xxxx hex seconds/
HELM03	SC	/"8D"8A            - typing any key exits/
HELM04	SC	/"8D"8AARING <num> - displays the async ring for a specific port/
HELM05	SC	/"8D"8ASYMBOLS     - displays the values of many symbols/
HELM06	SC	/"8D"8AOBUSY       - busy Outdial port/
HELM07	SC	/"8D"8AUNOBUSY     - unbusy Outdial port/
HELM08	SC	/"8D"8AOPORT       - list Outdial capable ports/
HELM09	SC	/"8D"8AMODIZ       - reinitializes Outdial capable ports/
HELM12	SC	/"8D"8ACRAT        - displays crash table/
HELM13	SC	/"8D"8APVC         - displays pvc options for all ports/
HELM14	SC	/"8D"8AAPVC        - displays pvc options for specified port/

	SUBTTL  (XDDT)	?STAT Command Handlers:  QBUSY, BUSY, UNBUSY

	DS.CMD(QBUS,QBUSY)		:Query busy-status
	DS.CMD(BUSY,SBUSY)		:busy port
	DS.CMD(UNBU,RBUSY)		:un-busy port

:	Query busy ports
QBUSY	HS	0
	SVC	K.OUT,QBM1		:"port busy status"
	 IF	NAPORT
	LIS	RP,0			:start from port 0
	LIS	R2,0			:listing format control
QBUSY1	TBT	RP,BUSY.C,,		:find a busy-able port
	JNFS	QBUSY3			:got one...do it
QBUSY2	AIS	RP,1			:next port
	CLHI	RP,NAPORT
	JLBS	QBUSY1			:repeat until done
	LR	R2,R2			:Check for new line
	JE	DS.NXT		:no
	SVC	K.OUT,M.CRLF		:else output new line
	J	DS.NXT		:and exit

QBUSY3	LR	R0,RP			:got such a port...copy number
	LHI	R1,62A			:six decimal digits, blank fill
	SVC	KIO,$A 10
	LHI	R0,20			:" "
	TBT	RP,BUSY.H		:is the port busy?
	JEFS	QBUSY5			:no
        LHI     R0,2A                   :"*"
        JFS     QBUSY4
       IF OUTDIA
QBUSY5  TBT     RP,BUSY.O               :outdial busy?
        JEFS    QBUSY4
        LHI     R0,6F                   :"o"
       ELSE
QBUSY5
       EI
QBUSY4	SVC	KIO,$A 14		:suffix port number with "*" if busy
	AIS	R2,1			:count for format control
	NHI	R2,07			:do line folding
	JN	QBUSY2			:not yet
	SVC	K.OUT,M.CRLF		:else go to new line
	J	QBUSY2			:and proceed

	ELSE
	J	DS.NXT			:do nothing if no async
	EI			:NAPORT
QBM1	SC	/"8D"8APort-busy status"8D"8A(busy port suffixed with "22*"22)(outdial busy suffixed with "22o"22)"8D"8A/

:	Set unbusy
RBUSY	IF	NAPORT
	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM		:get the port number
	CLHI	R0,NAPORT		:range check
	JG	SBUSY3			:bad range
	TBT	R0,BUSY.C,,		:is it a controllable port?
	JE	SBUSY3			:no...bad port
	RBT	R0,BUSY.H		:yes...make it unbusy
	JE	SBUSY2			:already was
	J	SBUSY1			:OK
	EI			:NAPORT

:	Set busy
SBUSY	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM		:get the port number
	 IF	NAPORT
	CLHI	R0,NAPORT		:range check
	JG	SBUSY3			:bad range
	TBT	R0,BUSY.C,,		:is it a controllable port?
	JE	SBUSY3			:no...bad port
	SBT	R0,BUSY.H		:yes...make it busy
	JNFS	SBUSY2			:already was

SBUSY1	SBT	R0,BUSY.A		:flag action required
	SVC	K.OUT,SBM1		:"OK"
	J	DS.NXT		:and exit

SBUSY2	SVC	K.OUT,SBM2		:"Already is..."
	J	DS.NXT		:and exit

	 EI			:NAPORT
SBUSY3	SVC	K.OUT,SBM3		:"not a valid port number"
	J	DS.NXT		:and exit

SBM1	SC	/"8D"8AOK"8A/
SBM2	SC	/"8D"8A..Already is"8A/
SBM3	SC	/"8D"8ANot a valid port number"8A/
	SUBTTL  (XDDT)	?STAT Command Handlers:  PORTS, IPORT, APORT

	DS.CMD(PORT,QALL)		:Query ALL ports
	DS.CMD(IPOR,QISIS)		:Query ISIS port
	DS.CMD(APOR,QPORT)		:Query port

:	Query ALL ports
QALL	LIS	RP,0			:start from port 0
        SVC     K.OUT,QPM1
QALL1   TBT     RP,RLA
        JEFS    QALL2
	LH	R0,PMAPAI,RP,RP	:look up ISIS port
	JAL	RLINK,DPORT		:display port information
        JFS     QALL4           :next port
QALL2   LH      R0,PMAPAI,RP,RP :could have isis mapping too
        JLFS    QALL4           :no isis mapping so next port
        JAL     RLINK,DPORT
QALL4   AIS     RP,1
	CLHI	RP,NPORT		:Done yet?
	JL	QALL1			:no..continue
	SVC	K.OUT,M.CRLF		:yes...clean up
	J	DS.NXT		:and exit

:	Query ISIS port
QISIS	LHI	R4,$A 16		:set radix
	JAL	R5,DS.NUM		:get the port number
        SVC     K.OUT,QPM1
	LR	RP,R0			:copy port number
	LH	RP,PMAPIA,RP,RP		:look up physical port
	JAL	RLINK,DPORT		:display it
	SVC	K.OUT,M.CRLF		:clean up
	J	DS.NXT		:and exit

:	Query port
QPORT	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM		:get the port number
        SVC     K.OUT,QPM1
	LR	RP,R0			:copy port number
	LH	R0,PMAPAI,RP,RP		:look up physical port
	JAL	RLINK,DPORT		:display it
	SVC	K.OUT,M.CRLF		:clean up
	J	DS.NXT		:and exit

:	Display the port information
:	RP -	Internal port number
:	R0 -	ISIS port number
:	RLINK -	Link register
DPORT	SVC	K.OUT,M.CRLF		:new line
        CLHI    RP,NPORT
        JLFS    DPORT1
DPORT0  SVC     K.OUT,QPM3      :not a valid port number
        JR      RLINK
DPORT1	LR      RP,RP
        JLBS    DPORT0
        LR	R0,R0			:check ISIS port number
	JGEFS	DPORT3
        TBT     RP,RLA      :or port active
        JNFS    DPORT3
DPORT2	SVC	K.OUT,QPM4		:else bitch
	JR	RLINK			:and return

DPORT3	LHI	R1,32A			:3 decimal digits, blank fill
        LR      R2,R0
        LR      R0,RP
	SVC	KIO,$A 10
        LHI     R0,4320                 :'C '
       IF       OUTDIA
        TBT     RP,OT.AP                :outdial active
        JEFS    DPORT4
        EXBR    R0,R0
       EI :OUTDIA
DPORT4  SVC     KIO,$A 14               :fill with C for call or space
        SVC     K.OUT,SPACEA    :and a space
	LHI	R1,430			:4 hex digits, blank fill
        LR      R0,R2           :get isis port back
	SVC	KIO,$A 10

        SVC     K.OUT,SPACE2
        LHI     R1,250                  :2chars zero fill
        LHI     R0,00FF                 :output FF if one
        TBT     RP,RLA          :output RLA stat
        JNFS    DPORT6
        EXBR    R0,R0
DPORT6  SVC     KIO,0A                  :output number
        LIS     R6,0
DPORT7  SVC     K.OUT,SPACE2            :space fill
        LHI     R0,00FF
        LHL     R7,DPRTAR,R6    :bit arrays (active if 0)
        JEFS    DPORT9          :0 terminates list
        TBT     RP,0,R7
        JEFS    DPORT8                  :FF if active
        EXBR    R0,R0
DPORT8  SVC     KIO,0A
        AIS     R6,2            :next array
        J       DPORT7
DPORT9  GETPTP(RPI,RP,RP)               :do CCT next
        LHL     R6,.TERMT,RPI
        LB      R0,VID.ID,R6,           :get cct
        NHI     R0,3F
        SVC     KIO,0A
        SVC     K.OUT,SPACEA
        LHI     R1,450          :four chars with hex radix
        L       R0,.TTBUF,RPI
        SVC     KIO,0A
        SVC     K.OUT,SPACEA
        L       R0,.FTBUF,RPI
        SVC     KIO,0A
        SVC     K.OUT,SPACEA
        L       R0,.LGBUF,RPI
        SVC     KIO,0A
        SVC     K.OUT,SPACEA
       IF      X3ON
        L       R0,.ECOBF,RPI
        SVC     KIO,0A
        SVC     K.OUT,SPACEA
        L       R0,.FEDBF,RPI
        SVC     KIO,0A
        SVC     K.OUT,SPACEA
       ELSE
        SVC     K.OUT,SPACE4
        SVC     K.OUT,SPACE4
        SVC     K.OUT,SPACE2
       EI
       IF      OUTDIA
        L       R0,.OTBUF,RPI
        SVC     KIO,0A
        SVC     K.OUT,SPACEA
       ELSE
        SVC     K.OUT,SPACE4
        SVC     K.OUT,SPACEA
       EI
        L       R0,SLOWC,,
        S       R0,.TIME,RPI    :output time of connect
        LHI     R1,850          :output it in hex
        SVC     KIO,0A
        JR      RLINK

QPM1	SC	/"8D"8APORT ISIS RLA DTR  CP DSR CCT TTBF FTBF LGBF FEBF OTBF     TIME"8A"8D/
QPM3	SC	/    Not a valid port number/
QPM4	SC	/    Not in use/
SPACEA  SC      / /
SPACE2  SC      /  /            :two spaces
SPACE4  SC      /    /          :four spaces
SPACE5  SC      /     /
        IF   NAPORT
DPRTAR  HC      DTR,CP,DSR,0
        ELSE
DPRTAR  HC      RLA,RLA,RLA,0   :have do something 
        EI
DPRTBF  HC      .TTBUF,.FTBUF,.LGBUF


:       commands are always defined but error is returned if outdia
:       not defined (friendly error).
        DS.CMD(OPORT,OPORT)
        DS.CMD(OBUS,O.BUSY)
:       DS.CMD(MODIZ,X.MODZ)		:11/18/86 cab - temp until race fixed
        DS.CMD(UNOB,UNOBSY)



        IF      1-OUTDIA
UNOBSY
O.BUSY
X.MODZ
OPORT   SVC     K.OUT,XDNOUT    :no outdial defined
        J       DS.NXT

XDNOUT  SC      /Outdial was not included in this slot"A7s configuration"8d"8a/

        ELSE    :if outdial is defined
:	Set unbusy
UNOBSY	IF	NAPORT
	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM		:get the port number
	CLHI	R0,NAPORT		:range check
	JG	OBUSY3			:bad range
	TBT	R0,BUSY.C,,		:is it a controllable port?
	JE	OBUSY3			:no...bad port
        TBT     R0,OT.CAP               :outdial capable?
        JE      OBUSY3
	RBT	R0,BUSY.O		:yes...make it unbusy
	JE	SBUSY2			:already was
	J	OBSY1			:OK
	EI			:NAPORT

:	Set busy
O.BUSY	LIS	R4,$A 10		:set radix
	JAL	R5,DS.NUM		:get the port number
	 IF	NAPORT
	CLHI	R0,NAPORT		:range check
	JG	OBUSY3			:bad range
        TBT     R0,OT.CAP               :outdia capable
        JE      OBUSY3
	TBT	R0,BUSY.C,,		:is it a controllable port?
	JE	OBUSY3			:no...bad port
	SBT	R0,BUSY.O		:yes...make it busy
	JN	SBUSY2			:already was

OBSY1
	SVC	K.OUT,SBM1		:"OK"
	J	DS.NXT		:and exit

	 EI			:NAPORT
OBUSY3	SVC	K.OUT,OSBM3		:"not a valid port number"
	J	DS.NXT		:and exit

OSBM3	SC	/"8D"8ANot a valid Outdial port number"8A/


:	Query busy ports
OPORT	HS	0		:
	SVC	K.OUT,OBM1	:"outdial capable ports
   IF	NAPORT
	LIS	RP,0		:start from port 0
	LIS	R2,0		:listing format control
OPORT1	TBT	RP,OT.CAP	:find an outdial port
	JNFS	OPORT3		:got one...do it
OPORT2	AIS	RP,1		:next port
	CLHI	RP,NAPORT	:
	JLBS	OPORT1		:repeat until done
	LR	R2,R2		:Check for new line
	JE	DS.NXT		:no
	SVC	K.OUT,M.CRLF	:else output new line
	J	DS.NXT		:and exit

OPORT3	LR	R0,RP		:got such a port...copy number
	LHI	R1,62A		:six decimal digits, blank fill
	SVC	KIO,$A 10	:
	LHI	R0,20		:" "
	TBT	RP,MODEAD	:is the modem not responding?
	JEFS	OPORT5		:no
        LHI     R0,44           :"D"
        JFS     OPORT4		:
OPORT5  TBT     RP,NOTONE       :not connected to phone?
        JEFS    OPORT4		:
        LHI     R0,50           :"P"
OPORT4	SVC	KIO,$A 14	:suffix port number with "D" if dead
	AIS	R2,1		:count for format control
	NHI	R2,07		:do line folding
	JN	OPORT2		:not yet
	SVC	K.OUT,M.CRLF	:else go to new line
	J	OPORT2		:and proceed

  ELSE
	J	DS.NXT		:do nothing if no async
  EI	:NAPORT
OBM1	SC	/"8D"8AOutdial capable ports"8d"8aPort number suffixed with "22D"22 if modem not responding"8d"8a"22P"22 if modem cannot detect dial tone"8d"8a/


X.MODZ  LHI     RPOL,(NAGRP-1)*2
        LCS     R0,1		:
        STH     R0,XRSAVE,,     :don't get stuck looping
XMODZ1  LHL     R0,RLA,RPOL	:
        XHI     R0,-1           :reinit ports not in use
        NH      R0,XRSAVE,,	:
        JFFOH   R0,XMODZ3	:
        SIS     RPOL,2		:
        JGE     XMODZ1		:
	J	OPORT		:now go display outdial capable ports

XMODZ3  STH     R0,XRSAVE,,	:
        RBT     R1,XRSAVE,,	:
        LR      RP,RPOL		:
        SLLS    RP,3		:
        AR      RP,R1		:
        LR      RP2,RP		:
        AR      RP2,RP		:
        JAL     RLINK,MODIZ,,	:
        J       XMODZ5          :modiz found CP so it is active port
        RBT     RP,OT.CAP       :it must show it still is capable
        JEFS    XMODZ4          :and it wasn't cap
        LCS     R0,1            :and dec number of capable
        AHM     R0,O.NCAP	:
XMODZ4  LHL     R0,XRSAVE,,	:
        J       XMODZ1          :next port
XMODZ5  JAL     R15,ZAPMOD,,	:
        JBS     XMODZ4		:

       EI       :OUTDIA

        DS.CMD(CRAT,X.CRAT)

MCRAT0  SC      /"8D"8ACount  Code  Location  Called from"8d"8a/
MCRAT1  SC      /"8d"8a"8d"8aRegisters/

X.CRAT  JAL     R10,X.TIME	:
        SVC     K.OUT,MCRAT0	:
        LHI     R1,52A          :five chars blank fill and decimal
        LHL     R0,CRAT,,       :crash count
        SVC     KIO,0A          :output it
        LHL     R0,CRAT+2,,     :crash code
        LHI     R1,630          :six chars blank fill and hex
        SVC     KIO,0A		:
        SVC     K.OUT,SPACE2	:
        L       R0,CRAT+4,,     :crash location
        LHI     R1,830		:
        SVC     KIO,0A		:
        SVC     K.OUT,SPACE5	:
        L       R0,CRAT+8,,     :called from (jumps to crash know this)
        SVC     KIO,0A		:
        SVC     K.OUT,MCRAT1	:
        LIS     R3,0		:
        LHI     R1,450          :zero fill
X.CRA1  SVC     K.OUT,M.CRLF	:
X.CRA2  LHL     R0,CRAT+0C,R3,  :do registers
        SVC     KIO,0A          :output the register
        SVC     K.OUT,SPACEA	:
        LHL     R0,CRAT+0E,R3,  :other halfword of register
        SVC     KIO,0A		:
        AIS     R3,4		:
        CLHI    R3,40           :done?
        JGE     DS.NXT		:
        LR      R4,R3		:
        NHI     R4,0F           :multiple of 16?
        JE      X.CRA1          :yes, new line
        SVC     K.OUT,SPACE2	:
        J       X.CRA2		:

        DS.CMD(PVC,X.PVC)
        DS.CMD(APVC,X.1PVC)

        IF PVC

X.PVC   LIS     RP,0
X.PVC1  TBT     RP,PVCARY,,   :PVC port?
        JEFS    X.PVC2
        JAL     RLINK,X.DPVC    :display pvc for this port
X.PVC2  AIS     RP,1
        CLHI    RP,MAXPRT
        JLE     X.PVC1
        SVC     K.OUT,M.CRLF
        J       DS.NXT

X.PVM0  SC      /"8D"8Aport is not a pvc port"8d"8a/

X.1PVC  LIS     R4,0A           :get number in radix
        JAL     R5,DS.NUM
        LR      RP,R0
        TBT     RP,PVCARY,,   :PVC PORT?
        JEFS    X.1PV1
        JAL     RLINK,X.DPVC
        J       DS.NXT
X.1PV1  SVC     K.OUT,X.PVM0
        J       DS.NXT

X.DPVC  LHI     R1,42A
        LR      R0,RP
        SVC     KIO,0A
        GETPTP(RPI,RP,RP)       :get port table pointer
        L       R9,.PVCX,RPI    :get PVC info
        THI     R9,1            :replace with POAID once globalled
        JEFS    X.DPV1
        LR      R0,R9
        SVC     K.OUT,X.PVM2    :AID PORT
        SRL     R0,$A 24        :EXTRACT PVC TID VALUE
        SVC     K.OUT,X.PVM1    :SAY IT IS TID
        LHI     R1,24A
        SVC     KIO,0A  :OUTPUT THE NUMBER
X.DPV1  LIS     R8,0            :message number
        LIS     R7,2            :BIT WE ARE TESTING
X.DPV2  THI     R9,0,R7         :OPTION SET?
        JEFS    X.DPV3          :NOT SET, NEXT BIT
        LHL     R2,X.PVMT,R8    :MESSAGE FOR THIS OPTION
        SVC     K.OUT,X.BASE,R2
X.DPV3  SLLS    R7,1            :test next bit
        AIS     R8,2
        CLHI    R8,$A 46        :high byte not options (2*24)
        JL      X.DPV2
        SVC     K.OUT,M.CRLF
        JR      RLINK
X.PVM1  SC      /  TID/
X.PVM2  SC      /  AID/
X.PVM3  SC      /  ALO/
X.PVM4  SC      /  NONPI/
X.PVM5  SC      /  SLO/
X.PVM6  SC      /  PAR/
X.PVM7  SC      /  PCO/
X.PVM8  SC      /  NOHNG/
X.PVM9  SC      /  HDX/
X.PM10  SC      /  NOCRLF/
X.PM1A  SC      /  NOLFCR/
X.PM11  SC      /  NOTRS/
X.PM12  SC      /  RBP/
X.PM13  SC      /  NOTXT/
X.PM14  SC      /  DSC/
X.PM15  SC      /  MPC/
X.PM16  SC      /  TLX/
X.PM17  SC      /  BTLX/
X.PM18  SC      /  NOWRU/
X.PM19  SC      /  SPAR/
X.PM20  SC      /  KAT/
X.PM21  SC      /  UPC/
X.PM22  SC      /  RCV/
X.PM23  SC      /  PROBE/

X.PVMT  HS      0       :STATUS'S BASE
        XEA(X.PVM3)
        XEA(X.PVM4)
        XEA(X.PVM5)
        XEA(X.PVM6)
        XEA(X.PVM7)
        XEA(X.PVM8)
        XEA(X.PVM9)
        XEA(X.PM10)
        XEA(X.PM1A)
        XEA(X.PM11)
        XEA(X.PM12)
        XEA(X.PM13)
        XEA(X.PM14)
        XEA(X.PM15)
        XEA(X.PM16)
        XEA(X.PM17)
        XEA(X.PM18)
        XEA(X.PM19)
        XEA(X.PM20)
        XEA(X.PM21)
        XEA(X.PM22)
        XEA(X.PM23)

        ELSE    :no pvc ports defined
X.PVC
X.1PVC  SVC     K.OUT,X.PM0
        J       DS.NXT
X.PM0  SC      /No PVC ports defined for this slot"8d"8a/
        EI

        DS.CMD(SYMBOL,XDSYMB)

:   prints out symbols of interest

XDSYMB  LIS     R5,0            :print out symbols and such
XDSYM1  LHL     R1,XDSYML,R5    :get address
        JE      DS.NXT          :quit if zero
        SVC     K.OUT,X.BASE,R1 :basic address to be changed
        AIS     R5,2
        SVC     DISMISS
        JAL     R4,DS.CHK       :check if to quit
        J       XDSYM1
        J       DS.NXT                  :estore write protect

SYMBT0	SC	/"8D"8AConfiguration equates"8d"8a/
SYMBT1	SC	/"8D"8AAddresses"8d"8a/
SYMBT2	SC	/"8D"8APort table data structure"8d"8a/

	SMBTXT(SYMB00,NAPORT,NSPORT,PVC,NMPVC)
	SMBTXT(SYMB01,NPAPRT,X3ON,OUTDIA,NUMPRN)
	SMBTXT(SYMB02,TELEX,BTELEX,TTELEX,VTEXT)
	SMBTXT(SYMB03,.2HD,BAUDA,ZZZZZZ,ZZZZZZ)
:  now memory locations
	SMBTXT(SYMB10,RLA,.PTP.,EXEC,CRAT)
	SMBTXT(SYMB11,PMAPIA,PMAPAI,TOISIS,TOPORT)
	SMBTXT(SYMB1A,ORING,IRING,BB,BE)
	SMBTXT(SYMB1B,BCT,BF,REBC1,REBC2)
  IF 0
	SMBTXT(SYMB12,TOLOG,GOLOG,SENDON,HANGWT)
	SMBTXT(SYMB13,C.ACP,FL.LOG,LOGER,LOGING)
	SMBTXT(SYMB14,UNAME,LGECHO,NEWLOG,P.DONE)
	SMBTXT(SYMB15,MPVC.C,Q.MODE,HAFDUX,ECHO)
	SMBTXT(SYMB16,ECTLI,ECTLH,E.ESC,ECR.LF)
	SMBTXT(SYMB17,ELF.CR,PARITY,SEVBIT,TOSING)
	SMBTXT(SYMB18,TSNBRK,CRDE,ASYNC,ASCII)
	SMBTXT(SYMB19,XONENA,YONENA,XONOUT,RXON)
	SMBTXT(SYMB20,NBO,DEM,TBOA,TBOB)
	SMBTXT(SYMB21,GBO,AH.TO,AH.TO1,AH.TO2)
	SMBTXT(SYMB22,PSNT0,PSNT1,BRK,BRKTO)
	SMBTXT(SYMB23,BRKTO1,MARGE,LASTCH,IBRATE)
	SMBTXT(SYMB24,OBRATE,PAR.A,PAR.B,PAR.C)
	SMBTXT(SYMB25,TRNCH,XMTF,ATTN,RTS)
	SMBTXT(SYMB26,LIMBO,BUSY.H,BUSY.A,DTR)
	SMBTXT(SYMB27,DSR,NEWDSR,CP,CPSAMP)
	SMBTXT(SYMB28,HDWDTR,HDWCP,A.SPED,DQ)
	SMBTXT(SYMB29,PVCSTD,TATBIN,MPV.CI,MPCLOG)
	SMBTXT(SYMB30,MPVCFO,PVCARY,AD.PRT,.BAUD)
	SMBTXT(SYMB31,MRKING,EMTBRK,FWDPTH,WRUT0)
	SMBTXT(SYMB32,WRUT1,RECWRU,VB.ACP,HD202)
	SMBTXT(SYMB33,T120,T240,T480,BUSY.C)
	SMBTXT(SYMB34,.NO.CP,TLXP,BTLXP,FWDPT0)
	SMBTXT(SYMB35,TTLXP,BKPRSR,GOT.PN,DQDAT)
	SMBTXT(SYMB36,TAM,AR.RS,TAMMER,OUTMSK)
	SMBTXT(SYMB37,QDDAT,IPORTS,ZAPIT,TOPRINT)
	SMBTXT(SYMB38,PRTBSY,ASNPUT,XLIMIT,SEQKEY)
	SMBTXT(SYMB39,PADARY,X3.P2,X3.P15,ECHOON)
	SMBTXT(SYMB40,LOCDEM,FLUNCR,IIXCAL,RPOA.F)
	SMBTXT(SYMB41,RVCG.F,PADACT,PNMODE,ICOD.F)
	SMBTXT(SYMB42,COMTO,INATO,MXATO,IDLETO)
	SMBTXT(SYMB43,EXTCAL,ICAPND,CALPRG,NUINAM)
	SMBTXT(SYMB44,CALCMD,ALLOWU,CUDTIM,CUDHEX)
	SMBTXT(SYMB45,CMDMOD,MULCMD,PARTYP,WHOSIT)
	SMBTXT(SYMB46,NALPNU,NNUMRU,TOIIX,GETIIX)
	SMBTXT(SYMB47,WIIXT1,WIIXT2,WIIXT3,DNDPROG)
	SMBTXT(SYMB48,TURKEY,IIXDIA,RESOUT,INTOUT)
	SMBTXT(SYMB49,XTGATE,GATCAL,XASCII,X29RED)
	SMBTXT(SYMB50,X29SET,WTPREF,WTMSG,X29OUT)
	SMBTXT(SYMB51,SETERR,LGMODE,CMMODE,IPMODE)
	SMBTXT(SYMB52,PADTYP,ICAON,ICAAU,ZZZZZZ)
	SMBTXT(SYMB53,A.VID,VASCI,XASCI,Z2741)
	SMBTXT(SYMB54,X2741,V2741,XOTDIA,VMODEM)
	SMBTXT(SYMB55,OTPMAP,OT.AP,OT.CAP,OT.MOD)
	SMBTXT(SYMB56,ASCIIX,GATIIX,PADIIX,TLXIIX)
	SMBTXT(SYMB57,SMDIIX,SVIRPT,SVORPT,ZZZZZZ)
  EI
:  now the offsets into the port table
	SMBTXT(SYMB70,.PORT,.TERMT,.TTBUF,.FTBUF)
	SMBTXT(SYMB71,.LGBUF,.VSTAT,.VSAVE,.XSTAT)
	SMBTXT(SYMB72,.XSAVE,.LSTAT,.ECOBF,.FEDBF)
	SMBTXT(SYMB73,.ECHRF,.ESIGF,.XPADF,.XPADS)
	SMBTXT(SYMB74,.DNCNT,X3.N3,CUDLNG,CUDSAV)
	SMBTXT(SYMB75,CUD.LT,POCNT,PICNT,SICNT)
	SMBTXT(SYMB76,SOCNT,TURLEV,EMTSAV,X29MSG)
	SMBTXT(SYMB77,X29PAR,X29CNT,COM.CU,MXA.CU)
	SMBTXT(SYMB78,INA.CU,IDL.CU,X3CPRO,X3STAT)
	SMBTXT(SYMB79,NRENTR,PREVCH,UUNVAL,DTECLG)
	SMBTXT(SYMB80,DTECLD,TCLASS,CUGIND,RVCG.R)
	SMBTXT(SYMB81,FLGBYT,PSIZE,PSDIAG,RPOA.R)
	SMBTXT(SYMB82,X3.P1,X3.P3,X3.P4,X3.P6)
	SMBTXT(SYMB83,X3.P7,X3.P9,X3.P10,X3.P13)
	SMBTXT(SYMB84,X3.P14,X3.P16,X3.17,X3.P18)
	SMBTXT(SYMB85,.TBHTX,.OFHTX,HTXSIZ,ZZZZZZ)
	SMBTXT(SYMB86,.PVCX,.PVCTO,.PVCLH,.PVCDO)
	SMBTXT(SYMB87,.IIXBF,.IIXVL,.IIXID,.IIXSV)
	SMBTXT(SYMB88,.IXSAV,.IIXST,.IXLEN,.IXPAR)
	SMBTXT(SYMB89,.IIXMD,.IIXSM,ZZZZZZ,ZZZZZZ)
	SMBTXT(SYMB90,.OTBUF,ZZZZZZ,ZZZZZZ,ZZZZZZ)

XDSYML  HS      0
        XEA(SYMBT0);XEA(SYMB00);XEA(SYMB01);XEA(SYMB02);XEA(SYMB03)
	XEA(SYMBT1);XEA(SYMB10);XEA(SYMB11);XEA(SYMB1A);XEA(SYMB1B)
  IF 0
	XEA(SYMB12);XEA(SYMB13);XEA(SYMB14);XEA(SYMB15)
        XEA(SYMB16);XEA(SYMB17);XEA(SYMB18);XEA(SYMB19);XEA(SYMB20);XEA(SYMB21)
        XEA(SYMB22);XEA(SYMB23);XEA(SYMB24);XEA(SYMB25);XEA(SYMB26);XEA(SYMB27)
        XEA(SYMB28);XEA(SYMB29);XEA(SYMB30);XEA(SYMB31);XEA(SYMB32);XEA(SYMB33)
        XEA(SYMB34);XEA(SYMB35);XEA(SYMB36);XEA(SYMB37);XEA(SYMB38);XEA(SYMB39)
        XEA(SYMB40);XEA(SYMB41);XEA(SYMB42);XEA(SYMB43);XEA(SYMB44);XEA(SYMB45)
        XEA(SYMB46);XEA(SYMB47);XEA(SYMB48);XEA(SYMB49);XEA(SYMB50);XEA(SYMB51)
        XEA(SYMB52);XEA(SYMB53);XEA(SYMB54);XEA(SYMB55);XEA(SYMB56);XEA(SYMB57)
  EI
	XEA(SYMBT2);XEA(SYMB70)
        XEA(SYMB71);XEA(SYMB72);XEA(SYMB73);XEA(SYMB74);XEA(SYMB75);XEA(SYMB76)
        XEA(SYMB77);XEA(SYMB78);XEA(SYMB79);XEA(SYMB80);XEA(SYMB81);XEA(SYMB82)
        XEA(SYMB83);XEA(SYMB84);XEA(SYMB85);XEA(SYMB86);XEA(SYMB87);XEA(SYMB88)
	XEA(SYMB89);XEA(SYMB90)
        HC      0



	FO	DATA

    SUBTTL	(XDDT) X CODE DIAGNOSTIC ROUTINE PACKAGE
:************************************************************************:
:                                                                        :
:                    X CODE DIAGNOSTIC ROUTINE PACKAGE                   :
:                                                                        :
:************************************************************************:


L.ISCT	EQ	22


:	BUFFERLET TRACE MESSAGES AND TABLES

XDBEQ	SC	/"2D"2D"3E/	: -->
SIAASC	AC	/0123456789ABCDEF/
XDBUFL	SC	/"8D"8ABUF /
XDBEM	SC	/ EMPTY/

:	IRING/ORING TRACE MESSAGES AND TABLES
XDRPLU	SC	/"2B/		:+
M.I	SC	/I /
M.O	SC	/O /
XDRMS5	SC	/    /
XDRMS4	SC	/NDL/		:NEEDLE
XDRMS3	SC	/DTA/		:DATA

	BND	2

CAPITT	HC	0,0,0,0,0,0,7FFF,0FFE0
XDRECH	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDRVL	HC	0082,0000	:VARIABLE LENGTH MESSAGE FLAGS

	SEG	A.DATA
XRSAVE	WS	10		:REGISTER STORAGE
MNCPRT  HS      1               :current port being monitored
XDRSEC	HS	2		:SLOWC TIME TO END TRACE
XDRCEI	HS	1		:OUR CEI
XDRWFL	HS	1		:USER SAYS RING WRAPPED ALREADY
IORING	HS	1		:"BOTH RINGS" FLAG
INFMI	HS	1		:STORAGE FOR IRING NFMI
ONFMI	HS	1		:STORAGE FOR ORING NFMI
XDRASC	SC	/  *                */
TIMMSG  BS      $A 14           :for displaying current time

:	ISIS CONTROL MESSAGES
	SEG	A.XDDT
XDRICA	HS	0
	SC	/DET/	:DETACH MESSAGE TYPE
	SC	/ZAP/	:DISCONNECT MESSAGE
	SC	/NOS/	:APPLY BACK-PRESSURE (NO SEND)
	SC	/SND/	:RELEASE BACK-PRESSURE (SEND)
	SC	/ICM/	:FLUSH OUTPUT (GOBBLER)
	SC	/BKG/	:FLUSH INPUT (BACK GOBBLER)
	SC	/BLK/	:DATA LOST IN THIS DIRECTION (BLACK BALL)
	SC	/GRY/	:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	SC	/EDE/	:ENTER DEFERED ECHO MESSAGE
	SC	/LDE/	:LEAVE DEFERED ECHO MESSAGE
	SC	/ETM/	:ENTER TRANSPARENCY MODE
	SC	/LTM/	:LEAVE TRANSPARENCY MODE
	SC	/GB /	:GREEN BALL
	SC	/RB /	:RED BALL
	SC	/YB /	:YELLOW BALL
	SC	/OB /	:ORANGE BALL
	SC	/BRK/	:BREAK DETECTED
	SC	/HNG/	:HANG UP
	SC	/QTP/	:QUERY TERMINAL PARAMETER
	SC	/STP/	:SET TERMINAL PARAMETER
	SC	/PSN/	:PSEUDO NEEDLE
	SC	/NLC/	:NORMAL LOGON CHAR
	SC	/NLS/	:NORMAL LOGON STATUS
	SC	/LOF/	:LOG ON FAILURE
	SC	/NCC/	:NORMAL CIRCUIT COMPLETE
	SC	/ADA/	:ADDENDUM TO ACCOUNTING
	SC	/SHG/	:SUPER-HANG UP
	SC	/TLM/	:SET TRANSMIT LIMIT
	SC	/EBK/	:END OF BREAK
	SC	/ZAK/	:ZAP ACK
	SC	/EAO/	:ENTER ALTERNATE OUTPUT DEVICE MODE
	SC	/LAO/	:LEAVE ALTERNATE OUTPUT DEVICE MODE
	SC	/ZAR/	:ZAP WITH REASON
	SC	/SIX/	:START INTERFACE INFORMATION EXCHANGE
	SC	/TIX/	:TERMINATE INTERFACERFACE INFORMATION EXCHANGE
	SC	/UUN/	:UNIVERSAL USER NUMBERING PLAN
	SC	/***/	:UNDEFINED TYPE

:	ISIS CONTROL MESSAGE LENGTHS
:	----------------------------

	BND	2

XDRILA	HS	0
	BC	3	:DETACH MESSAGE TYPE
	BC	3	:DISCONNECT MESSAGE
	BC	3	:APPLY BACK-PRESSURE (NO SEND)
	BC	3	:RELEASE BACK-PRESSURE (SEND)
	BC	3	:FLUSH OUTPUT (GOBBLER)
	BC	3	:FLUSH INPUT (BACK GOBBLER)
	BC	3	:DATA LOST IN THIS DIRECTION (BLACK BALL)
	BC	3	:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	BC	3	:ENTER DEFERED ECHO MESSAGE
	BC	3	:LEAVE DEFERED ECHO MESSAGE
	BC	3	:ENTER TRANSPARENCY MODE
	BC	3	:LEAVE TRANSPARENCY MODE
	BC	3	:GREEN BALL
	BC	3	:RED BALL
	BC	3	:YELLOW BALL
	BC	3	:ORANGE BALL
	BC	3	:BREAK DETECTED
	BC	3	:HANG UP
	BC	4	:QUERY TERMINAL PARAMETER
	BC	5	:SET TERMINAL PARAMETER
	BC	6	:PSEUDO NEEDLE
	BC	4	:NORMAL LOGON CHAR
	BC	4	:NORMAL LOGON STATUS
	BC	4	:LOG ON FAILURE
	BC	0A	:NORMAL CIRCUIT COMPLETE
	BC	8	:ADDENDUM TO ACCOUNTING
	BC	3	:SUPER-HANG UP
	BC	4	:SET TRANSMIT LIMIT
	BC	3	:END OF BREAK
	BC	3	:ZAP ACK
	BC	3	:ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	3	:LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	4	:ZAP WITH REASON
	BC	3	:START INTERFACE INFORMATION EXCHANGE
	BC	3	:TERMINATE INTERFACE INFORMATION EXCHANGE
	BC	8	:UNIVERSAL USER NUMBERING PLAN



:	INTRA NODE MESSAGES
:	-------------------
	BND	2

XDRICB	HS	0
	SC	/RQR/	:RESTART REQUEST
	SC	/RST/	:RESTART INTERFACE
	SC	/NTO/	:NODE HAS BEEN TAKEN OVER
	SC	/REP/	:REPORT TO SUPERVISOR'S LOG
	SC	/RHS/	:REPORT HOST STATUS (OBSOLETE)
	SC	/RAC/	:REPORT ACCOUNTING
	SC	/TIM/	:GMT TIME
	SC	/RNP/	:REQUEST FOR NORMAL PSEUDO NEEDLE
	SC	/RAP/	:REQUEST AUX PSEUDO-NEEDLE
	SC	/PSR/	:PSEUDO-NEEDLE REJECTED
	SC	/HPA/	:HOST PORT AVAILABILITY
	SC	/HNA/	:HOST NOT ACCEPTABLE
	SC	/RHC/	:REPORT HOST COST
	SC	/NSU/	:NO SUPERVISOR
	SC	/ODN/	:1-DOWN TEXT
	SC	/RAH/	:REPORT ALL HOSTS
	SC	/HSR/	:HOST STATUS REPORT
	SC	/***/	:UNDEFINED TYPE


:	INTRANODE MESSAGE LENGTHS
:	-------------------------
	BND	2

XDRILB	HS	0
	BC	3	:RESTART REQUEST
	BC	3	:RESTART INTERFACE
	BC	4	:NODE HAS BEEN TAKEN OVER
	BC	9	:REPORT TO SUPERVISOR'S LOG
	BC	0C	:REPORT HOST STATUS (OBSOLETE)
	BC	8	:REPORT ACCOUNTING
	BC	8	:GMT TIME
	BC	0B	:REQUEST FOR NORMAL PSEUDO NEEDLE
	BC	0E	:REQUEST AUX PSEUDO-NEEDLE
	BC	7	:PSEUDO-NEEDLE REJECTED
	BC	0A	:HOST PORT AVAILABILITY
	BC	07	:HOST NOT ACCEPTABLE
	BC	0A	:REPORT HOST COST
	BC	3	:NO SUPERVISOR
	BC	9	:1-DOWN TEXT
	BC	3	:REPORT ALL HOSTS
	BC	0E	:HOST STATUS REPORT
	BC	0
M.CRLF	SC	/"8A"8D/

	SEG	A.DATA

	BND	2
XSTRSH	HS	1

XXTBL1	BS	300		:INDEX MESSAGES

MSGSPC	BS	100

	SEG	A.XDDT
	LO	ISIS
	LO	BUFFER

:	UTILITY ROUTINES

:	MOVE MESSAGE TO STORAGE

:	R3  = SCRATCH REGISTER
:	R4  = USED AS MESSAGE STORE POINTER
:	R9  = ENTER WITH POINTER TO MESSAGE
:	R10 = USED AS BYTE COUNT OF MESSAGE 
:	R12 = LINK REGISTER

MSGMOV	LB	R10,0,R9	:GET MESSAGE LENGTH
	JER	R12		:GET OUT IF NULL
	LB	R4,MSGSPC,,	:GET CURRENT LENGTH OF MESSAGE STORE
	LR	R3,R4	
	AR	R3,R10		:CALCULATE NEW STORE LENGTH
	STB	R3,MSGSPC,,	:SET NEW LENGTH
MSMV10	LB	R3,0,R9,R10	:GET BYTE OF MESSAGE
	STB	R3,MSGSPC,R4,R10	:MOVE TO STORE
	SIS	R10,1		:DECREMENT BYTE COUNT
	JNBS	MSMV10		:IF MORE TO DO
	JR	R12

:	MOVE BYTE TO STORAGE

:	R5 = BYTE TO BE MOVED
:	R10 = SCRATCH REGISTER
:	R11 = LINK REGISTER

BYTMOV	LB	R10,MSGSPC,,	:GET BYTE COUNT
	AIS	R10,1		:BUMP COUNT
	STB	R10,MSGSPC,,	:REPLACE
	STB	R5,MSGSPC,R10,	:PUT BYTE INTO STORAGE
	JR	R11		:RETURN

:	MOVE NUMBER TO STORAGE

:	R5  = NUMBER TO BE CONVERTED AND MOVED
:	R1  = FIELD WIDTH
:	R3 = SCRATCH REGISTER
:	R4 = SCRATCH REGISTER
:	R10 = SCRATCH REGISTER
:	R11 = LINK REGISTER

NUMMOV	LB	R3,MSGSPC,,	:GET OLD MESSAGE LENGTH
	AR	R3,R1		:COMPUTE NEW LENGTH
	STB	R3,MSGSPC,,	:SAVE NEW LENGTH
NUMM00	LIS	R4,0F		:GET MASK
	NR	R4,R5		:GET LAST DIGIT
	LB	R4,SIAASC,R4	:CONVERT TO ASCII
	STB	R4,MSGSPC,R3,	:PUT INTO STORE
	SIS	R1,1		:BUMP COUNT
	JER	R11
	SIS	R3,1		:MOVE POINTER
	SRLS	R5,4		:DISCARD USED DIGIT
	J	NUMM00		:GO DO IT AGAIN

:	OUTPUT A BYTE AS 2 DIGITS TO TTY

:	R0  = SCRATCH REGISTER
:	R3  = SCRATCH REGISTER
:	R4  = SCRATCH REGISTER
:	R5  = BYTE TO BE OUTPUT.  REMAINS INTACT
:	R7  = BYTE COUNTER (INPUT)
:	R11 = LINK REGISTER

XDTPUT	LBR	R4,R5		:COPY IT
	LBR	R3,R5		:COPY AGAIN
	SRHLS	R4,4		:LEFT NIBBLE
	LB	R0,SIAASC,R4	:CONVERT TO ASCII
	SVC	KIO,0E		:PUT IT OUT TO TTY
	NHI	R3,0F		:RIGHT NIBBLE
	LB	R0,SIAASC,R3	:CONVERT TO ASCII
	SVC	KIO,0E		:PUT IT OUT TO TTY
	LBR	R3,R7		:GET BYTE COUNTER
	NHI	R3,1		:EVERY OTHER BYTE, PUT OUT EXTRA SPACE
	JER	R11		:IF EVEN
	SVC	K.OUT,SPACEA		:PUT IT OUT TO TTY
	JR	R11		:RETURN

:	OUTPUT A BYTE AS 2 DIGITS TO STORAGE

:	R3  = SCRATCH REGISTER
:	R5  = BYTE TO BE OUTPUT
:	R10, R11 DESTROYED
:	R12 = LINK REGISTER

XDSPUT	LBR	R3,R5		:COPY IT
	SRHLS	R5,4		:LEFT NIBBLE
	LB	R5,SIAASC,R5	:CONVERT TO ASCII
	JAL	R11,BYTMOV	:MOVE BYTE TO STORAGE
	NHI	R3,0F		:RIGHT NIBBLE
	LB	R5,SIAASC,R3	:CONVERT TO ASCII
	JAL	R11,BYTMOV	:MOVE BYTE TO STORAGE
	JR	R12		:RETURN


:	DUMP CONTENTS OF ALL BUFFERLET CHAINS IN HEX.
:	"::G XDBUF"	 TO EXECUTE THIS ROUTINE
:	"BUFFS"	 TO SEE NON-EMPTY BUFFERS ONLY
        DS.CMD(BUFFS,XDBUF)

XNBUF	STM	R0,XRSAVE,,	:SAVE REGISTERS
	LIS	R4,0
	STB	R4,XSTRSH,,	:SET "NON-EMPTY BUFFERLETS ONLY" FLAG
	JFS	XDBF00
XDBUF	STM	R0,XRSAVE,,	:SAVE REGISTERS
	LIS	R4,1
	STB	R4,XSTRSH,,	:SET "ALL BUFFERLETS" FLAG
XDBF00	LIS	R6,0		:INITIALIZE BUFFER #
XDBF20	LIS	R3,0
	STB	R3,MSGSPC,,	:INIT STORAGE
	LIS	R1,3		:BUFFER NUMBER FIELD WIDTH
:	R6=BUFFER NUMBER*4 (INDEX)
	CLHI	6,NBUF*4	:RANGE CHECK BUFFER #
	JGE	XDBF99		:TOO BIG
	LA	R9,XDBUFL	:"BUF" MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
	LR	R5,R6		:MOVE BUFFER NUMBER
	JAL	R11,NUMMOV	:MOVE TO STORE
	L	R2,BB,6,	:BUFFER BEGINNING
	LHL	R7,BCT,R6,		:LOOK AT BYTE COUNT OF BUFFER
	LR	R7,R7
	JN	XDBF22		:IF NOT EMPTY
	LB	R9,XSTRSH,,	:CHECK IF EMPTY BUFFERS TO BE PRINTED
	JNFS	XDBF21		:IF SO
	STB	R9,MSGSPC,,	:CLEAR STORE
	AIS	R6,4		:GO TO NEXT BUFFER
	J	XDBF20

XDBF21	LA	R9,XDBEM	:POINT TO "EMPTY"
	JAL	R12,MSGMOV	:MOVE TO STORE
	J	XDBF50		:CHECK NEXT ONE

XDBF22	LA	R9,XDBEQ	:POINT TO COLON MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
	LIS	R1,2		:SET FIELD WIDTH = 2
XDBF30	LB	R5,,R2,		:GET NEXT CHARACTER FROM BUFFER
	JAL	R12,XDSPUT	:CONVERT TO ASCII AND STORE
	AIS	R2,1		:NEXT CHARACTER IN BUFFERLET
	THI	R2,0F		:END OF BUFFERLET ??
	JN	XDBF40		:IF NOT
	SVC	0B,MSGSPC,,	:PRINT WHAT WE HAVE NOW
	LIS	R3,0
	STB	R3,MSGSPC,,	:CLEAR OUT ACCUMULATED MSG
	LHL	R2,,R2,		:STEP TO NEXT BUFFERLET
	SLLS	R2,4		:CONVERT TO BUFFERLET POINTER
	AI	R2,BUFERS-0E	:ADJUST TO ITS START
	LA	R9,M.CRLF	:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
XDBF40	SIS	R7,1		:DECREMENT CHARACTER COUNT
	JG	XDBF30		:IF NOT DONE YET
XDBF50	AIS	R6,4		:TO NEXT BUFFER
	SVC	0B,MSGSPC,,	:PRINT CONTENTS OF BUFFER
	J	XDBF20

XDBF99	LA	R9,M.CRLF	:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
	SVC	0B,MSGSPC,,	:PRINT STORE
	LM	R0,XRSAVE,,	:RESTORE REGISTERS
	J	DS.NXT	:RETURN TO DDT


:	DUMP CONTENTS OF ALL BUFFERLET CHAINS IN ASCII.
:	"::G XDBUFA"	 TO EXECUTE THIS ROUTINE
:	"::G XNBUFA"	 TO SEE NON-EMPTY BUFFERS ONLY

        DS.CMD(BUFASC,XNBUFA)
        DS.CMD(BUFHEX,XNBUF)

XNBUFA	STM	R0,XRSAVE,,	:SAVE REGISTERS
	LIS	R4,0
	STB	R4,XSTRSH,,	:SET "NON-EMPTY BUFFERLETS ONLY" FLAG
	JFS	XDBA00
XDBUFA	STM	R0,XRSAVE,,	:SAVE REGISTERS
	LIS	R4,1
	STB	R4,XSTRSH,,	:SET "ALL BUFFERLETS" FLAG
XDBA00	LIS	R6,0		:INITIALIZE BUFFER #
XDBA20	LIS	R3,0
	STB	R3,MSGSPC,,	:INIT STORAGE
	LIS	R1,3		:BUFFER NUMBER FIELD WIDTH
:	R6=BUFFER NUMBER*4 (INDEX)
	CLHI	6,NBUF*4	:RANGE CHECK BUFFER #
	JGE	XDBA99		:TOO BIG
	LA	R9,XDBUFL	:"BUF" MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
	LR	R5,R6		:MOVE BUFFER NUMBER
	JAL	R11,NUMMOV	:MOVE TO STORE
	L	R2,BB,6,	:BUFFER BEGINNING
	LHL	R7,BCT,R6,		:LOOK AT BYTE COUNT OF BUFFE
	LR	R7,R7
	JN	XDBA22		:IF NOT EMPTY
	LB	R9,XSTRSH,,	:CHECK IF EMPTY BUFFERS TO BE PRINTED
	JNFS	XDBA21		:IF SO
	STB	R9,MSGSPC,,	:CLEAR STORE
	AIS	R6,4		:GO TO NEXT BUFFER
	J	XDBA20

XDBA21	LA	R9,XDBEM	:POINT TO "EMPTY"
	JAL	R12,MSGMOV	:MOVE TO STORE
	J	XDBA50		:CHECK NEXT ONE

XDBA22	LA	R9,XDBEQ	:POINT TO COLON MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
	LIS	R1,2		:SET FIELD WIDTH = 2
XDBA30	LB	R5,,R2,		:GET NEXT CHARACTER FROM BUFFER
	JAL	R11,BYTMOV	:MOVE TO STORE
	AIS	R2,1		:NEXT CHARACTER IN BUFFERLET
	THI	R2,0F		:END OF BUFFERLET ??
	JN	XDBA40		:IF NOT
	SVC	0B,MSGSPC,,	:PRINT WHAT WE HAVE NOW
	LIS	R3,0
	STB	R3,MSGSPC,,	:CLEAR OUT ACCUMULATED MSG
	LHL	R2,,R2,		:STEP TO NEXT BUFFERLET
	SLLS	R2,4		:CONVERT TO BUFFERLET POINTER
	AI	R2,BUFERS-0E	:ADJUST TO ITS START
	LA	R9,M.CRLF	:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
XDBA40	SIS	R7,1		:DECREMENT CHARACTER COUNT
	JG	XDBA30		:IF NOT DONE YET
XDBA50	AIS	R6,4		:TO NEXT BUFFER
	SVC	0B,MSGSPC,,	:PRINT CONTENTS OF BUFFER
	J	XDBA20

XDBA99	LA	R9,M.CRLF	:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV	:MOVE TO STORE
	SVC	0B,MSGSPC,,	:PRINT STORE
	LM	R0,XRSAVE,,	:RESTORE REGISTERS
        J       DS.NXT          :return to ddt



:	DUMP I/O RINGS
:
RR	EQ	8		:REGISTER ADDRESS OF RING
RS	EQ	9		:REGISTER RING SIZE
MAXINM	EQ	10		:MAX NUMBER OF INTRA NODE MESSAGE TYPES

XDRMON  STM     R0,XRSAVE,,
        LCS     R0,1
        STH     R0,MNCPRT,,     :monitor all ports
XDRMOG  LHL     R0,ORING,NFMI,  :general enter monitor
        STH     R0,ONFMI,,
        LIS     R0,0
        STH     R0,XDRWFL,,
        LIS     R0,1
        STH     R0,IORING,,
        L       R1,SLOWC,,
        AI      R1,8FFF         :monitor for essentailly forver
        ST      R1,XDRSEC,,       :monitor for essentailly forver
        LHL     R1,IRING+NFMI,,
        STH     R1,INFMI,,
        LA      RR,IRING,,
        LI      RS,IRSIZE
        J       XDR0A1

XDRIMN  LHI     R4,10           :set radix
        JAL     R5,DS.NUM       :get port to monitor
        CLHI    R0,NPORT        :check port range
        JG      SBUSY3          :invalid port number
        STH     R0,MNCPRT,,     :port currently mon
        J       XDRMOG          :now set up to monitor

XDRING	STM	R0,XRSAVE,,	:SAVE REGISTERS
        LCS     R0,1            :mon all prts
        STH     R0,MNCPRT,,
	SVC	0B,XDRPLU	:+ PROMPT
	LIS	R0,0
	STH	R0,XDRWFL,,	:CLEAR WRAPPED FLAG
	STH	R0,IORING,,	:CLEAR "BOTH RINGS" FLAG
	STH	R0,INFMI,,	:CLEAR STORAGE FOR IRING POINTER
	STH	R0,ONFMI,,	:CLEAR STORAGE FOR ORING POINTER
XDRMN1	SVC	0A,0010		:TTY INPUT INTO R0, 16 SEC TIMEOUT
	J	XDR0FF		:TIMEOUT, RETURN TO DDT
	NHI	R0,7F		:OFF THE PARITY
	JAL	R1,CAPIT	:CAPITALIZE IT
	CLHI	R0,57		:W ??
	JNFS	XDR004		:IF NOT
	STH	R0,XDRWFL,,	:ASSUME TO HAVE WRAPPED
	SVC	0A,0010		:GET NEXT CHARACTER
	J	XDR0FF		:TIMEOUT, EXIT
	JAL	R1,CAPIT	:CAPITALIZE IT 
XDR004	CHI	R0,49		:I ??
	JE	XDR020		:IF SO DO IRING
	CHI	R0,4F		:O ??
	JE	XDR030		:IF SO DO ORING
XDR010	LIS	R1,1
	STH	R1,IORING,,	:SET "BOTH RINGS" FLAG
	LA	RR,ORING,,	:SET UP ORING FOR LATER
	LHI	RS,ORSIZE	:RING SIZE
	LH	R1,XDRWFL,,	:RING WRAP?
	JE	XDR015		:IF NOT
	LH	R1,NFMI,RR	:GET CURRENT POINTER
XDR015	JAL	R10,BEGMSG	:GUESS AT FIRST MESSAGE
	STH	R1,ONFMI,,	:SAVE GUESS
XDR020	LA	RR,IRING,,	:HANDLE IRING
	LHI	RS,IRSIZE	:RING SIZE
	JFS	XDR040
XDR030	LA	RR,ORING,,	:HANDLE ORING
	LHI	RS,ORSIZE	:RING SIZE
XDR040	SR	R1,R1		:CLEAR ACCUMULATOR
XDR050	SVC	0A,0008		:NEXT CHARACTER INTO R0
	J	XDR060		:TIMEOUT, CONTINUE
	NHI	R0,7F		:FORGET PARITY
	CLHI	R0,0D		:CR ??
	JE	XDR060		:DONE INPUTTING IF SO
	NHI	R0,0F		:REDUCE TO 0-F
	SLLS	R1,4		:POSITION ACCUMULATOR 
	OR	R1,R0		:ACCUMULATE ADDRESS
	J	XDR050
XDR060	A	R1,SLOWC,,	:ADD CURRENT TIME
	ST	R1,XDRSEC,,	:SAVE TIME TO QUIT
	LIS	R1,0		:ASSUME START AT BEG OF RING
	JAL	R10,BEGMSG	:GUESS AT FIRST MESSAGE
	LH	R2,XDRWFL,,	:DO WE KNOW IT WRAPPED ??
	JE	XDR0A0		:IF NOT
	LH	R1,NFMI,RR	:USE OLDEST ENTRY
	JAL	R10,BEGMSG	:GUESS AT FIRST MESSAGE
	SVC	0B,M.CRLF	:NEW LINE
	J	XDR0A4
XDR090	AIS	R1,3		:ROUND UP TO FULL WORD
	NHI	R1,-4		:AND I.E., NEXT MESSAGE
	CR	R1,RS		:TO END OF RING ??
	JLFS	XDR0A0		:IF NOT
	SR	R1,RS		:FOLD TO START OF RING
XDR0A0	SVC	0B,M.CRLF	:CR LF
XDR0A1  CLH     R1,NFMI,RR      :caught up?
	JN	XDR0A4		:NOT YET
	LHL	R0,IORING,,	:GET "BOTH RINGS" FLAG
	JE	XDR0A3		:IF NOT SET
	CLI	RR,IRING	:SEE IF JUST FINISHED IRING
	JN	XDR0A2		:GO DO IRING NEXT
	LA	RR,ORING,,	:GET SET TO DO ORING
	LHI	RS,ORSIZE
	STH	R1,INFMI,,	:SAVE IRING POINTER
	LHL	R1,ONFMI,,	:GET ORING POINTER
	J	XDR0A1		:GO DO IT
XDR0A2	LA	RR,IRING,,	:GET SET TO DO IRING
	LHI	RS,IRSIZE
	STH	R1,ONFMI,,	:SAVE ORING POINTER
	LHL	R1,INFMI,,	:GET IRING POINTER
XDR0A3	L	R0,XDRSEC,,	:TIME TO END THIS 
	CL	R0,SLOWC,,	:COMPARE TO ENDING SECOND
	JL	XDR0FF		:YES, RETURN TO DDT
	SVC	DISMIS,0	:DISMISS A BIT
        LR      R10,R1
        JAL     R4,DS.CHK       :get char to quit
        JFS     XDRA31          :pad for skip+4 return
        JFS     XDRA31          :pad for skip+4 return
        J       DS.NXT          :got the char
XDRA31
        LR      R1,R10  :restore reg
	J	XDR0A1		:WATCH FOR A CHANGE IN RING
XDR0A4	SVC	0A,0            :get char to quit
        JFS     XDRAA4
        JFS     XDRAA4
        J       DS.NXT
XDRAA4  LH      R2,MNCPRT,,     :port currently mon
        JLFS    XDR0A5          :-1so mon all
        CH      R2,RING,R1,RR   :check as port number in ring
        JN      XDRFLS          :jump to message flush
XDR0A5  CLI	RR,ORING	:IS THIS THE ORING?
	JEFS	XDR0A6		:IF SO
	SVC	0B,M.I	:OUTPUT "I "
	JFS	XDR0A8		:CONTINUE
XDR0A6	SVC	0B,M.O	:OUTPUT "O "
XDR0A8	LB	R2,RING+2,R1,RR	:GET MESSAGE CODE
	LHL	R3,RING,R1,RR	:GET PORT #
	JE	XDR0C0		:IF INTRANODE MESSAGE
	LR	R2,R2		:CHECK FOR NEEDLE
	JE	XDR0F0		:IF SO
	CLHI	R2,9E		:DATA MESSAGE ??
	JL	XDR0B0		:IF SO
	SHI	R2,9E		:BIAS TO 0
	CLHI	R2,L.ISCT	:CHECK MAX MSG TYPE
	JLE	XDR0A9		:IF OK
	LHI	R2,L.ISCT+1	:GET "UNDEFINED" MESSAGE
XDR0A9	LA	R4,,R2,R2	:FOR INDEXING
	SVC	0B,XDRICA,R4,R4	:ASCII MESSAGE LABEL
	JAL	R10,XDRISB	:GO DUMP ISIS CONTROL MESSAGE
	J	XDR090		:GO TO NEXT MESSAGE
XDR0B0	SVC	0B,XDRMS3	:"DATA" MESSAGE HEADER
	JAL	R10,XDRISA	:GO DUMP ISIS DATA MSG
	J	XDR090		:GO TO NEXT MESSAGE
XDR0C0	CLHI	R2,MAXINM	:CHECK MAX MSG TYPE
	JLE	XDR0C1		:IF OK
	LHI	R2,MAXINM+1	:GET "UNDEFINED" MESSAGE
XDR0C1	LA	R4,,R2,R2	:FOR INDEXING
	SVC	0B,XDRICB,R4,R4	:ASCII MESSAGE LABEL
	TBT	R2,XDRVL  	:VARIABLE LENGTH MESSAGE ??
	JNFS	XDR0D0		:IF SO BECAUSE CAN'T HANDLE YET
	JAL	R10,XDRISC	:GO DUMP ISIS INTRANODE MESSAGE
	J	XDR090		:GO TO NEXT MESSAGE
XDR0D0	CLHI	R2,8		:AUX CIRCUIT REQUEST ??
	JN	XDR0E0		:MUST BE "1-DOWN"
	LA	R4,0A,R1	:STEP TO SIZE BYTE
	CR	R4,RS		:CHECK FOR WRAP AROUND
	JLFS	XDR0D4		:IF NOT
	SR	R4,RS		:IF SO
XDR0D4	LB	R6,RING,RR,R4	:GET VARIABLE STRING SIZE
	AIS	R6,0B		:ADD CONSTANT PORTION
	SVC	K.OUT,SPACEA
	JAL	R10,XDRISE	:TO PUT OUT MESSAGE
	J	XDR090
XDR0E0	LA	R4,5,R1		:STEP TO 1-DOWN STRING SIZE
	CLHI	R4,RS		:CHECK FOR WRAP AROUND
	JLFS	XDR0E4		:IF NOT
	SHI	R4,RS		:IF SO
XDR0E4	LB	R6,RING,RR,R4	:GET VARIABLE MESSAGE SIZE
	AIS	R6,6		:ADD FIXED MESSAGE LENGTH
	SVC	K.OUT,SPACEA
	JAL	R10,XDRISE	:TO PUT OUT MESSAGE
	J	XDR090		:TO CONTINUE
XDR0F0	SVC	0B,XDRMS4	:NEEDLE MESSAGE
	LB	R6,RING+3,R1,RR	:GET ADDITIONAL LENGTH
	AIS	R6,4		:ADD FIXED PORTION
	LHI	R0,20		:INSERT A BLANK
	SVC	KIO,0E		:PUT IT OUT
	JAL	R10,XDRISE	:TO PUT REST OF MESSAGE
	J	XDR090

XDR0FF	LM	R0,XRSAVE,,	:RESTORE REGISTERS
	J	DS.NXT1		:RETURN TO DDT

CAPIT	TBT	R0,CAPITT  	:TEST FOR LOWER CASE CHARACTER
	JER	R1		:IF NOT
	SHI	R0,20		:ADJUST TO CAPITALIZE
	JR	R1		:RETURN

:	GUESS AT FIRST MESSAGE IN RING

BEG000	AIS	R1,1		:BUMP POINTER
BEG010	CR	R1,RS		:SEE IF AT END OF RING
	JLFS	BEGMSG		:IF NOT
	LIS	R1,0		:START FRESH
BEGMSG	LB	R3,RING,R1,RR	:GET BYTE
	JN	BEG000		:IF NOT ZERO
	THI	R1,3		:LOOKING FOR ZERO BYTE ON WORD BOUNDARY
	JE	BEG050		:JUMP IF FOUND CANDIDATE
	AIS	R1,3		:MOVE PAST NEXT WORD
	NHI	R1,-4		:ROUND DOWN TO WORD BOUNDARY
	J	BEG010		:DO IT AGAIN
BEG050	L	R3,RING,R1,RR	:IS WHOLE WORD NONZERO?
	JNR	R10		:IF SO, SHOULD DO FOR A GUESS
	AIS	R1,4		:SKIP FULL WORD OF ZERO
	J	BEG010		:TEST NEXT WORD 

XDRFLS  LB      R2,RING+2,R1,RR :message code
        LHL     R3,RING,R1,RR   :port number
        JE      XDRF30          :flush intra node msg
        LR      R2,R2           :needle?
        JE      XDRF40          :flush needle
        CLHI    R2,9E           :data message?
        JL      XDRF20
        SHI     R2,9E           :bias to 0
        LB      R6,XDRILA,R2    :get length of control msg
        J       XDRF90          :continue
XDRF20  LHI     R6,3,R2         :msg length=3+num of data
        J       XDRF90
XDRF30  TBT     R2,XDRVL        :variable length?
        JNFS    XDRF32
        LB      R6,XDRILB,R2    :get length
        J       XDRF90
XDRF32  CLHI    R2,8            :aux circuit request?
        JN      XDRF36          :then is 1-down
        LHI     R4,0A,R1        :step to size byte
        CR      R4,RS           :wrap around?
        JLFS    XDRF33
        SR      R4,RS
XDRF33  LB      R6,RING,RR,RS   :string size
        AIS     R6,0B           :plus constant portion
        J       XDRF90
XDRF36  LHI     R4,5,R1
        CLHI    R4,RS           :wrap around
        JNFS    XDRF37
        SR      R4,RS
XDRF37  LB      R6,RING,RR,R4   :message size
        AIS     R6,6            :plus fixed length
        J       XDRF90
XDRF40  LB      R6,RING+3,RR,R1
        AIS     R6,4
XDRF90  AR      R1,R6           :how many bytes read
        AIS     R1,3            :put to word boundary
        NHI     R1,-4
        CR      R1,RS
        JL      XDR0A1          :continue
        SR      R1,RS
        J       XDR0A1

:	R1 - RING INDEX
:	R2 - MSG CODE TYPE
:	RS - RING SIZE
:	RR - RING START

:	DATA MESSAGE
XDRISA	LA	R6,3,R2		:MESSAGE LENGTH=MESSAGE TYPE+3
	SVC	K.OUT,SPACEA		:LETS BE TIDY
	J	XDRISE
:	CONTROL MESSAGE
XDRISB	LB	R6,XDRILA,R2 	:MESSAGE LENGTH FROM TABLE
	SVC	K.OUT,SPACEA
	J	XDRISE
:	INTRANODE MESSAGE TYPE
XDRISC	LB	R6,XDRILB,R2 	:MESSAGE LENGTH FROM TABLE
	SVC	K.OUT,SPACEA
	JFS	XDRISE
XDRISD
  IF	TRANHX
	SVC	0B,XDRASC,,	:ASCII EQUIVALENT OF LINE
  EI
	SVC	0B,M.CRLF	:NEW LINE
	SVC	0B,XDRMS5	:4 BLANKS FOR ALIGNMENT
XDRISE	LIS	R7,0		:LINE LENGTH COUNTER
XDRISF	LB	R5,RING,R1,RR	:NEXT BYTE FROM RING
	LHI	R0,20		:DEFAULT BLANK CHARACTER
	TBT	R5,XDRECH  	:PRINTABLE ??
	JEFS	XDRISH		:IF NOT, USE BLANK
	LR	R0,R5		:ELSE IF OK TO PRINT IT
XDRISH	LR	R4,R7		:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F		:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,,:PUT 'ER THERE
	JAL	R11,XDTPUT,,	:PUT IT OUT
	AIS	R1,1		:BUMP RING INDEX
	CR	R1,RS		:END OF RING ??
	JLFS	XDRISG		:IF NOT
	SR	R1,RS		:FOLD TO RING START
XDRISG	AIS	R7,1		:LINE LENGTH
	CLH	R1,NFMI,RR	:SEE IF AT RING POINTER
	JE	XDRISI		:IF SO GET OUT
	SIS	R6,1		:CHECK FOR END OF MSG
	JLE	XDRISI		:FINISH BLANKING AND PRINT	
	THI	R7,0F		:END OF LINE
	JE	XDRISD		:IF SO
	THI	R7,1		:END OF HALFWORD
	JN	XDRISF		:IF NOT TO CONTINUE
	SVC	K.OUT,SPACEA		:TO FORMAT WORDS
	J	XDRISF
XDRISI	LHI	R0,20		:BLANK
XDRISJ	NHI	R7,0F		:LINE LENGTH OF 16
	JEFS	XDRISK		:IF TO END OF LINE
	STB	R0,XDRASC+4,R7,,:PUT IN A BLANK
	AIS	R7,1		:COUNT ON UP
	JBS	XDRISJ		:AND SEE IF DONE
XDRISK
  IF	TRANHX
	SVC	0B,XDRASC,,	:PUT IT OUT
  EI
	JR	R10		:DONE

XFRMSG  SC      /From terminal async ring"0d"0a/
XTOMSG  SC      /To terminal async ring"0d"0a/
XAR.RS  HC      2*AR.RS

XARERR  SVC     K.OUT,QPM3      :not a valid port
        J       DS.NXT

        DS.CMD(ARING,XARING)

        IF      NAPORT

XARING  LIS     R4,$A 10        :set radix
        JAL     R5,DS.NUM       :get the desired port number
        CHI     R0,NAPORT       :make sure in range
        JGE     XARERR
        LR      R7,R0           :copy port number to scratch reg
        MH      R7,XAR.RS       :get relative start of async ring
        SVC     K.OUT,M.CRLF
        SVC     K.OUT,XFRMSG
        JAL     R9,XARI02       :do async ring
        SVC     K.OUT,M.CRLF
        SVC     K.OUT,XTOMSG    :and to terminal ring
        AHI     R7,AR.RS        :bump to next ring
        JAL     R9,XARI02       :do ring
        J       DS.NXT

XARI02  LIS     R6,0            :number in ring
XARI04  LIS     R8,0            :bytes per line
        STB     R8,MSGSPC,,
        ST      R8,XDRASC+4,,
        ST      R8,XDRASC+8,,
        ST      R8,XDRASC+0C,,
        ST      R8,XDRASC+10,,
        LO      CONSAT
XARI03  LB      R5,DQ,R7,R6     :r7 is ring, r6 is char
        JAL     R4,XARI06
        JAL     R12,XDSPUT
        AIS     R8,1
        AIS     R6,1            :next byte
        LB      R5,DQ,R7,R6     :output halfwords
        JAL     R4,XARI06
        JAL     R12,XDSPUT
        FO      CONSAT
        LHI     R5,20           :output a space
        JAL     R11,BYTMOV      :puts a byte in the msg
        AIS     R6,1
        CHI     R6,AR.RS       :finished with ring
        JGE     XARI05          :Finished with ring
        AIS     R8,1
        CHI     R8,10           :16 chars per line
        JL     XARI03          :still in line
        SVC     K.OUT,MSGSPC,,  :send the bytes
  IF	TRANHX
        SVC     K.OUT,XDRASC,,  :and the ascii chars
  EI
        SVC     K.OUT,M.CRLF    :give them a new line
        J       XARI04          :continue with next line

XARI05  SVC     K.OUT,MSGSPC,,  :then output the partial ring
  IF	TRANHX
        SVC     K.OUT,XDRASC,,  :then output the partial ring
  EI
        SVC     K.OUT,M.CRLF    :and a next line
        JR      R9

XARI06  LBR     R0,R5
        NHI     R0,7F
        CLHI    R0,7F           :delete char to mess us up
        JEFS    XARI77
        CHI     R0,20           :printable
        JGEFS   XARI07
XARI77  LHI     R0,20
XARI07  STB     R0,XDRASC+4,R8,   :put char
        JR      R4

        ELSE  :no async
XARING  SVC     K.OUT,NOASYN
        J       DS.NXT
NOASYN  SC      /No Async ports"8d"8a/
        
        EI   :NAPORT

	FO	BUFFER
	FO	ISIS

:	SET UP INDEX TABLE

	SEG	A.DATA
	ORG	XXTBL1

	BC	0		:NUMBER OF BYTES IN TABLE
	AC	/"8A"8D/
QQ	EQ	(XDBUF^-10)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDBUF^-0C)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDBUF^-8)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDBUF^-4)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	XDBUF&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
	AC	/    XDBUF     bufferlet dump in hex"8A"8D/
QQ	EQ	(XDBUFA^-10)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDBUFA^-0C)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDBUFA^-8)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDBUFA^-4)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	XDBUFA&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
	AC	/    XDBUFA    bufferlet dump in ASCII"8A"8D/
QQ	EQ	(XNBUF^-10)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XNBUF^-0C)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XNBUF^-8)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XNBUF^-4)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	XNBUF&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
	AC	/    XNBUF     non-empty bufferlet dump in hex"8A"8D/
QQ	EQ	(XNBUFA^-10)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XNBUFA^-0C)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XNBUFA^-8)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XNBUFA^-4)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	XNBUFA&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
	AC	/    XNBUFA    non-empty bufferlet dump in ASCII"8A"8D/
XXTEND	EQ	.

	ORG	XXTBL1

	BC	XXTEND-XXTBL1-1

	ORG	XXTEND

XXTBL3	BC	0		:NUMBER OF BYTES IN TABLE

QQ	EQ	(XDRING^-10)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDRING^-0C)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDRING^-8)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	(XDRING^-4)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
QQ	EQ	XDRING&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
	BC	QQ+30
	AC	/    XDRING    IRING or ORING dump"8A"8D/

	SEG	A.XDDT          :nice format for module display
        EM      :STATUS
  [_4i8