SUBTTL OUTPUT DISPATCHER

;HERE AT CH7 TO SCAN LINTAB FOR PORTS NEEDING OUTPUT, SCAN
;LDBOUT FOR THOSE PORTS, AND DISPATCH TO THE APPROPRIATE
;OUTPUT ROUTINES

SCNOUT:	PUSHJ	P, SETOUT	;PREPARE FOR TYMNET OUTPUT
	  SKIPLE MULCNT+1	;IF NO ROOM FOR TYMNET OR PTY OUTPUT,
	JRST	.+2
	JRST	FINOUT		;  DO NOTHING THIS CYCLE

    ;FIND THE NEXT PORT (IN A ROUND-ROBIN FASHION) THAT WANTS
    ;TO DO OUTPUT

	SKIPL	T1, LINPTR	;IF NO ROUND-ROBIN PTR EXISTS,
	MOVSI	T1, NMXFLG	;  SET TO START AT PORT 0
SCOLP1:	MOVEM	T1, LINPTR
	SKIPN	U, LINFLG(T1)	;IF NO NEED-OUTPUT BITS IN THIS WORD,
	JRST	NOLIN2		;  GO ON TO THE NEXT ONE
	MOVE	T4, BITNTB(T1)	;T4/ PORT# CORRESPONDING TO BIT 0
SCOLP:	JFFO	U, .+2		;T1/ BIT# OF FIRST. IF NONE,
	JRST	NOLIN2		;  GO ON TO THE NEXT WORD
	LSH	U, 1(T1)	;GET RID OF THE BIT WE JUST FOUND
	MOVEM	U, LINFSV	;SAVE THE REST OF THE WORD
	ADD	T1, T4		;T1/ PORT# FOR THE BIT WE JUST FOUND
	MOVEM	T1, LINPNM	;SAVE THAT TOO
	MOVE	U, LINTAB(T1)	;U/ LDB ADDR
	HLL	U, LDBDCH(U)	;U/ DCH BITS,,LDB ADDR
	TLNN	U, LDLPTY	;P(SEUDO)TY OR R(EAL)TY?
	JRST	SCORTY
   ;PREPARE TO DO OUTPUT ON A PSEUDO-PORT

SCOPTY:	MOVE	T1, TTFREN
	CAILE	T1, TIRSVD	;IF NO SYSTEM BUFFERLETS
	SKIPG	MULCNT+1	;OR PTY "FLOW" QUOTA EXCEEDED,
	JRST	NOLIN		;  MAYBE THE NEXT PORT'S A REAL TTY
	PUSHJ	P, SETPTL	;T1/ MAX CHARS TO XFER
	MOVEI	W, 1		;W = 1 => PTY
	JRST	SCOTTY

    ;PREPARE TO DO OUTPUT ON A REAL PORT

SCORTY:	SKIPG	MULCNT+0	;IF NO ROOM FOR REAL TTY OUTPUT,
	JRST	NOLIN		;  MAYBE THE NEXT PORT'S A PTY
	MOVEI	T1, %CHRMX	;T1/ MAX CHRS TO XMIT
	SETZ	W,		;W = 0 => REAL TTY
	;JRST	SCOTTY

    ;LOOK FOR THE HIGHEST-PRIORITY OUTPUT REQUEST ON THE LINE

SCOTTY:	MOVEM	T1, CHQTA
	MOVEM	T1, CHCNT
	MOVE	T1, LDBOUT(U)	;T1/ OUTPUT BITS
	JFFO	T1, GOLIN
	JRST	MORLN2		;NOTHING (THAT'S FUNNY...)
GOLIN:	JUMPGE	U, GOLIN1	;IF PORT'S BACKPRESSURED
	CAIG	T2,BPOKBN	; AND OUTPUT TYPE IS HIGH ENOUGH PRI
	JRST	GOLIN1		; THEN OUTPUT IS OK
        CAILE   T2,LAPBIT       ;BEYOND LAST LEGAL PRIORITY BIT?
         JRST   MORLN2          ;YES.  ASSUME NO OUTPUT
	LDB	T1,LOPECO
	JUMPN	T1,GOLIN2	;ATTEMPT ECHO EVEN IF BACKPRESSURE ON
Golin3:	SETZ	T1,
	DPB	T1, LDBOPB(U)	;  CLEAR NEED-OUTPUT
	JRST	FULLIN		;  AND SAY WE'RE THROUGH
GOLIN2:	MOVEI	T2,NUMECO	;ECHO BIT NUMBER
GOLIN1:	MOVEM	T2, SVOJFF	;SAVE THE BIT NUMBER
	JUMPE	W, @OUTTRN(T2)	;REAL TTY DISPATCH
	JRST	@PTYTRN(T2)	;PSEUDO-TTY DISPATCH
    ;OUTPUT SUCCESSFUL, ROOM FOR MORE

MORLIN:	MOVN	T2, SVOJFF	;T2/ -(BIT# WE DISPATCHED FOR)
	MOVSI	T1, (1B0)
	LSH	T1, (T2)	;T1/ BIT WE DISPATCHED FOR
	ANDCAB	T1, LDBOUT(U)	;CLEAR IT AND PICK UP THE REST
	JFFO	T1, GOLIN	;IF THERE'S MORE TO DO, DO IT

    ;FINISHED WITH THE LAST OUTPUT REQUEST FOR THIS PORT

MORLN2:	DPB	T1, LDBOPB(U)	;CLEAR NEED-OUTPUT BIT
	PUSHJ	P, XMTWAK	;WAKE UP THE JOB FOR GOOD MEASURE
	JRST	FULLIN

    ;OUTPUT SUCCESSFUL, NO ROOM FOR MORE

FINLIN:	MOVN	T2, SVOJFF
	MOVSI	T1, (1B0)
	LSH	T1, (T2)
	ANDCAB	T1, LDBOUT(U)
	JUMPE	T1, MORLN2
	JRST	FULLIN

    ;OUTPUT NOT DONE BECAUSE WE'RE WAITING FOR SOMETHING
    ;(E.G., CAN'T OUTPUT ECHO CHARACTERS IF THE PORT'S NOT
    ;IN INPUT WAIT). CODE FOR "SOMETHING"S MUST TURN
    ;THE NEED-OUTPUT BIT BACK ON

WATLIN:	MOVEI	T1, 0
	DPB	T1, LDBOPB(U)
	PUSHJ	P, XMTWAK
	JRST	FULLIN
    ;OUTPUT NOT DONE AND/OR FINISHED WITH THIS PORT

FULLIN:	HRRZ	F, LDBDDB(U)
	JUMPE	F, FULLN2
	LDB	T1, PJOBN
	MOVE	T4, CHQTA
	SUB	T4, CHCNT
	ADDB	T4, JBTCOT(T1)
	MOVEM	T4, JBTCOT
FULLN2:	JUMPN	W, FULLN3

    ;DONE WITH A REAL TTY

	PUSHJ	P, CLSCHR	;FINISH CHARACTER-OUTPUT MESSAGE
	  SKIPLE MULCNT+1	;IF NO TYMNET OR PTY ROOM,
	JRST	NOLIN
	JRST	FINOUT		;  QUIT

    ;DONE WITH A PTY

FULLN3:	CAIE	W, 1
	 STOPCD
	PUSHJ	P, CLSPTL	;FINISH CHARACTER OUTPUT
	SKIPG	MULCNT+0	;IF THERE'S ROOM FOR REAL PORTS
	SKIPLE	MULCNT+1	;OR PTYS,
	JRST	NOLIN		;  GO ON
	JRST	FINOUT		;ELSE QUIT

    ;GO ON TO THE NEXT PORT

NOLIN:	AOS	T4, LINPNM
	MOVE	U, LINFSV
	JUMPN	U, SCOLP	;TRY TO FIND ANOTHER IN GROUP
NOLIN2:	MOVE	T1, LINPTR
	AOBJN	T1, SCOLP1	;TRY ANOTHER GROUP
	SETZM	LINPTR		;(START FROM BEGINNING NEXT TIME)
FINOUT:	AOSG	FSCN	;(IF IT WAS 0 (NOW 1), THERE WAS NO I/O)
	JRST	SCNIN	;IF I/O DONE THIS CYCLE, GO CHECK INPUT AGAIN
	SETZM	FSCN	;OTHERWISE, CLEAR FSCN
	POPJ	P,	;AND RETURN (FROM SCNINT) TO THE TICK LOGIC
;OUTPUT DISPATCH TABLES

DEFINE ZZZ(NAME), <GO'NAME>
OUTTRN:	OUTBIT

DEFINE ZZZ(NAME), <PG'NAME>
PTYTRN:	OUTBIT
SUBTTL PTY "OUTPUT" ROUTINES

PTBSIZ==^D120
ARRAY PTYBUF[<PTBSIZ+4>/5]
INTEGER PBDISC
INTEGER DIDPBI

;SETPTL -- CALLED WITH U/ PTY LDB TO SET UP FOR OUTPUT THENCE
;	IF THE OTHER END IS IN BLOCK INPUT WAIT, IT SETS
;	CHRWRP+1 TO POINT TO THE NEXT FREE BYTE IN THE
;	BLOCK INPUT BUFFER
;	OTHERWISE, IT SETS CHRWRP+1 TO POINT TO THE
;	PTY BUFFER
;	SETS T1/ MAX # CHARS TO MOVE

SETPTL:	SETZM	PBDISC		;CHARIO DISCOUNT FOR BLOCK OUTPUT
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;IF BLOCK INPUT IS IN PROGRESS,
	JRST	SETPTB		;  DO THINGS DIFFERENTLY

    ;HERE WHEN OTHER END IS NOT IN BLOCK INPUT WAIT

	SETZM	DIDPBI
	MOVE	T1, [POINT 8, PTYBUF]
	MOVEM	T1, CHRWRP+1
	MOVE	T1, TIWRNN	;T1/ # CHARS ALLOWED BEFORE BACKPRESSURE
	SUB	T1, LDBTIC(U)
	SUB	T1, LDBECC(U)	;T1/ # MORE CHARS THAT WILL FIT
	SKIPGE	T1		;IF WE'LL BE BACKPRESSURED,
	MOVEI	T1, %CHRMX	;  T1/ NORMAL (REAL TTY) LIMIT
	CAILE	T1, PTBSIZ
	MOVEI	T1, PTBSIZ	;MUSTN'T BE > THAN THE PTY BUFFER SIZE
	POP	P, U
	POPJ	P,

    ;HERE WHEN THE OTHER END IS IN BLOCK INPUT WAIT

SETPTB:	SETOM	DIDPBI
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1		;IF NONE,
	SKIPL	BIOCHR(T1)	;OR IF NO INPUT PENDING,
	 STOPCD 		;  DIE
	MOVE	T2, BIOPBP(T1)	;T2/ BLOCK IDPB POINTER
	MOVEM	T2, CHRWRP+1
	MOVE	T1, BIOPBC(T1)	;T1/ # BYTES LEFT THERE
	POP	P, U
	POPJ	P,
;CLSPTL -- CALLED WITH U/ PTY LDB TO FINISH UP OUTPUT THITHER
;	IF OTHER END WAS DOING BLOCK INPUT, THE CHARACTERS ARE
;	ALREADY MOVED -- WE JUST NEED TO UPDATE THE BUFFER
;	POINTER&COUNT AND SEE IF WE'VE FILLED IT YET
;	OTHERWISE WE NEED TO MOVE THE CHARACTERS TO THE
;	OTHER END

CLSPTL:	MOVE	T1, PBDISC
	ADDM	T1, CHCNT	;ADJUST CHARIO COUNT FOR BLOCK OUTPUT
	SKIPE	DIDPBI		;IF OTHER END WAS DOING BLOCK INPUT,
	JRST	CLSPTB		;  HANDLE THINGS DIFFERENTLY

	MOVE	T1, CHRWRP+1	;T1/ BYTE POINTER
	CAMN	T1, [POINT 8, PTYBUF]
	POPJ	P,		;(NOTHING TO OUTPUT)

	PUSH	P, U
	PUSH	P, [0]
	PUSH	P, T1
	PUSH	P, [POINT 8, PTYBUF]

    ;-2(P) = 0 IF REM. ECHO, -1 IF DEFERRED
    ;-1(P) IS ORIGINAL ENDING BYTE POINTER
    ;  (P) IS SOURCE BYTE POINTER

	PUSHJ	P, PTYBUD	;U/ BUDDY'S LDB
CLSLP1:	UUILDB	T3, (P)		;T3/ CHAR
	PUSHJ	P, MOVCHR	;DEPOSIT IT
	  JRST	.+2
	SETOM	-2(P)		;(ENTERED DEFERRED ECHO MODE)
	MOVE	T1, (P)
	CAME	T1, -1(P)
	JRST	CLSLP1

	SKIPN	T1, -2(P)	;IF IT ENTERED DEFERRED ECHO MODE,
	JRST	CLSLP2
	DPB	T1, LOPECO	;  SET NEED-ECHO
	DPB	T1, LDBOPB(U)	;  AND NEED-OUTPUT
CLSLP2:	SUB	P, [3,,3]	;DISCARD THE THREE LOCALS
	POP	P, U		;RESTORE U
	POPJ	P,
    ;HERE WHEN THE OTHER END WAS DOING BLOCK INPUT

CLSPTB:	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLKI NO LONGER IN PROGRESS,
	JRST	UPOPJ		;  NOTHING TO DO
	HRRZ	T1, LDBBIO(U)	;T1/ BLOCK INPUT BUFFER ADDRESS
	SKIPN	T1
	 STOPCD
	MOVE	T3, CHRWRP+1
	MOVEM	T3, BIOPBP(T1)	;UPDATE BYTE POINTER
	MOVE	T3, CHCNT
	SUB	T3, CHQTA	;T3/ - # OF CHARACTERS MOVED
	ADDB	T3, BIOPBC(T1)	;UPDATE BYTES-LEFT COUNT
	JUMPE	T3, CLSPBF	;(BUFFER FILLED)

    ;HERE WHEN WE HAVEN'T FINISHED FILLING THE BUFFER YET

	SKIPG	T3
	 STOPCD 		;(WENT TOO FAR)
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;RESET BLOCK-INPUT TIMER
UPOPJ:	POP	P, U
	POPJ	P,

    ;HERE WHEN WE'VE JUST FILLED A BLOCK INPUT BUFFER

CLSPBF:	HRRZ	T4, BIOCHR(T1)	;T4/ (PRESUMABLY) # CHARS MOVED
	PUSHJ	P, FRCIBF	;SIMULATE BUFFER-FULL MESSAGE
	SETZ	T1,
	DPB	T1, LDPTIM	;CLEAR BLOCK-INPUT TIMER
	MOVEI	T1, LDRBIP
	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	POPJ	P,
    ;IMPOSSIBLE OUTPUT BITS

PGSRD:	;RED BALL
PGGBF:	;GREEN BALL
	 STOPCD

    ;IGNORED OUTPUT BITS

PGSEC:	;SET ECHO MODE (SHOULD ALWAYS BE OFF)
PGSTP:	;TERMINAL CHARACTERISTICS PROBE
PGHNG:	;HANG UP DATA SET
	JRST	MORLIN

    ;NOT IMPLEMENTED YET -- IGNORE

PGSTC:	;SET TERMINAL CHARACTERISTICS
	JRST	MORLIN
;MSGSIM -- SIMULATE INPUT-MESSAGE ARRIVAL
;	CALLED WITH T1/ ADDR OF A FRC--- ROUTINE
;	CALLS <T1> WITH U/ THE CURRENT PTY'S "BUDDY"

MSGSIM:	PUSH	P, U		;SAVE U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB
	HLL	U, LDBDCH(U)
	PUSHJ	P, (T1)		;SIMULATE A <T1>-ARRIVAL
	POP	P, U
	JRST	MORLIN

;CHARACTER GOBBLER

PGCGB:	MOVEI	T1, FRCCGB
	PJRST	MSGSIM


;ORANGE BALL

PGSOG:	MOVSI	T2, L2LDEL
	TDNN	T2, LDBBYT(U)	;IF WE'RE IN \...
	PUSHJ	P, WTCHK	;OR WE'RE IN INPUT WAIT,
	JRST	WATLIN		;  WAIT
	MOVEI	T1, FRCORG
	PJRST	MSGSIM

;BACKPRESSURE ON

PGBPN:	MOVEI	T1, LDRXOS
	TDNE	T1, LDBDCH(U)	;IF WE'VE ALREADY SENT AN XOFF,
	JRST	MORLIN		;  DON'T SEND ANOTHER
	IORM	T1, LDBDCH(U)
	MOVEI	T1, FRCNOO
	PJRST	MSGSIM

;BACKPRESSURE OFF

PGBPF:	MOVEI	T1, LDRXOS
	ANDCAM	T1, LDBDCH(U)	;CLEAR BACKPRESSURE-SEND FLAG
	MOVEI	T1, FRCDOO
	PJRST	MSGSIM
;YELLOW BALL

PGSYL:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IS OTHER END DOING BLOCK INPUT?
	JRST	PGSYLN		;(NO)

    ;HERE WHEN THE OTHER END'S DOING BLOCK INPUT

	ANDCAM	T1, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T2, BIOCHR(T1)
	 STOPCD
	HRRZ	T4, T2		;T4/ # CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;T4/ # CHARS TRANSFERRED
	PUSHJ	P, FRCEOT	;FAKE A BLKI-EOT
	POP	P, U
	PUSHJ	P, FRCNOO	;BACKPRESSURE OURSELVES
	JRST	WATLIN		;(SEND YLB WHEN BKP RELIEVED)

    ;HERE IN THE NORMAL CASE

PGSYLN:	MOVSI	T1, L2LOWT
	IORM	T1, LDBBYT(U)	;SAY WE'RE WAITING
	MOVSI	T1, L2LOWS
	ANDCAM	T1, LDBBYT(U)	;AND THAT WE HAVEN'T SEEN ONE
	PUSHJ	P, FRCYEL
	POP	P, U
	JRST	MORLIN
;WHEN THE PTY OUTPUT CODE FILLS UP A BLOCK INPUT BUFFER, IT
;FORCES BACKPRESSURE ON THE LINE DOING THE OUTPUT -- THE
;REQUEST-BLOCK-INPUT AND REQUEST-BLOCK-INPUT-TERMINATION
;OUTPUT ROUTINES CLEAR THE BACKPRESSURE

;TERMINATE BLOCK INPUT

PGTRI:	MOVEI	T1, LDRBIP
	TDNN	T1, LDBDCH(U)	;IF BLOCK INPUT'S IN PROGRESS,
	 JRST	PGTRI1
	ANDCAM	T1, LDBDCH(U)	;  CLEAR IN-PROGRESS FLAG
	HRRZ	T1, LDBBIO(U)	;  T1/ BLOCK INPUT BUFFER ADDR
	SKIPE	T1
	SKIPL	T2, BIOCNT(T1)
	 STOPCD (,XCT,TTYNPB)	;No PTY Buffer for block IO  ;;PGTRI+7
	HRRZ	T4, T2		;  T4/ # OF CHARS TO TRANSFER
	SUB	T4, BIOPBC(T1)	;  T4/ # OF CHARS TRANFERRED
	JRST	.+2		;OTHERWISE
PGTRI1:	SETZ	T4,		;  T4/ 0 CHARS
	PUSHJ	P, FRCIHR	;FAKE A TERMINATED-BY-REQUEST
	JRST	PGBIN1		;CLEAR BACKPRESSURE ON THE OTHER END

;REQUEST BLOCK INPUT

PGBIN:	MOVEI	T1, LDRBIP
	IORM	T1, LDBDCH(U)	;MARK INPUT IN PROGRESS
	MOVEI	T1, %PBTIM
	DPB	T1, LDPTIM	;SET BLOCK-INPUT TIMEOUT
	HRRZ	T1, LDBBIO(U)	;T1/ INPUT BUFFER ADDRESS
	SKIPN	T1
TTYNPB:: STOPCD (.,JOB,TTYNPB,,<No PTY Buffer for block IO>) ;;PGBIN+6
	HRRZ	T2, BIOCHR(T1)	;T2/ # CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE PTY COUNT
	MOVE	T2, [POINT 8,BIODAT]
	ADD	T2, T1
	MOVEM	T2, BIOPBP(T1)	;STORE PTY BYTE POINTER

    ;HERE FROM ABOVE AND FROM PGTRI TO CLEAR BACKPRESSURE

PGBIN1:	PUSH	P, U
	PUSHJ	P, PTYBUD
	HLL	U, LDBDCH(U)
	PUSHJ	P, FRCDOO	;CLEAR BACKPRESSURE ON OTHER END
	POP	P, U
	JRST	MORLIN
;PBTIMO -- CALLED BY SCNSEC WHEN A PORT DOING BLOCK INPUT
;	   TIMES OUT.
;	   SAVES P1-P4.
;	   ASSUMES THAT FRCITM PRESERVES U AND F.

PBTIMO:	PUSH	P, P1
	PUSH	P, P2
	PUSH	P, P3
	PUSH	P, P4

	HRRZ	T1, LDBBIO(U)
	SKIPE	T1
	SKIPL	T4, BIOCHR(T1)
	 STOPCD 		;NO BUFFER OR NO INPUT PENDING
	MOVEI	T2, LDRBIP
	ANDCAM	T2, LDBDCH(U)	;CLEAR IN-PROGRESS FLAG
	HRRZ	T4, T4		;T4/ # BYTES REQUESTED
	SUB	T4, BIOPBC(T1)	;T4/ # BYTES TRANSFERRED
	PUSHJ	P, FRCITM	;FAKE A TIMEOUT MESSAGE
	PUSH	P, U
	PUSHJ	P, PTYBUD
	PUSHJ	P, FRCNOO	;BACKPRESSURE OTHER END
	POP	P, U

	POP	P, P4
	POP	P, P3
	POP	P, P2
	POP	P, P1
	POPJ	P,
;BLOCK OUTPUT

PGBOT:	SKIPN	DIDPBI		;IF THE OTHER END WAS DOING BLOCK INPUT,
	JRST	PGBOTC
	MOVE	T1, CHCNT
	CAME	T1, CHQTA	;AND IT HASN'T GOTTEN ANY CHARS YET,
	JRST	PGBOTC
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, LDRBIP
	TDNE	T1, LDBDCH(U)	;AND IT'S STILL IN BLOCK INPUT WAIT,
	JRST	PGBOT1
	POP	P, U
	JRST	PGBOTC
PGBOT1:	HRRZ	T1, LDBBIO(U)	;  T1/ ITS BLOCK INPUT BUFFER
	SKIPN	T1
	 STOPCD
	HRRZ	T2, (P)		;  T2/ OUR LDB ADDR
	HLRZ	T3, LDBBIO(T2)	;  T3/ OUR BLOCK OUTPUT BUFFER
	SKIPN	T3
	 STOPCD
	HRRM	T3, LDBBIO(U)	;  OUR OUTPUT => ITS INPUT
	HRLM	T1, LDBBIO(T2)	;  ITS INPUT => OUR OUTPUT
	MOVE	T4, BIOREQ(T1)
	EXCH	T4, BIOREQ(T3)
	MOVEM	T4, BIOREQ(T1)	;  BUT KEEP THE OLD BIOREQ'S
	SKIPL	T1, BIOCHR(T1)	;  T1/ -1,,# CHARS "TRANSMITTED"
	 STOPCD
	MOVEM	T1, BIOCHR(T3)	;  INPUT SIDE WANTS THE -1 FLAG
	HRRZS	BIOCHR(T1)	;  OUTPUT SIDE DOESN'T
	HRRZM	T1, PBDISC	;  ALREADY CHARGED (JBTBIO), SO DISCOUNT
	POP	P, U
	SETZM	CHCNT		;  WE'VE FILLED ITS BUFFER
	PUSHJ	P, FRCOHR	;  WE'VE DONE OUR BLOCK OUTPUT
	JRST	FINLIN		;  NO MORE THIS CYCLE

    ;HERE WHEN THE OTHER END'S NOT COOPERATING BY DOING BLOCK INPUT

PGBOTC:	HLRZ	T1, LDBBIO(U)	;T1/ BLOCK OUTPUT BUFFER
	SKIPN	T1
	 STOPCD
	HRRZ	T2, BIOCHR(T1)	;T2/ TOTAL CHARS TO TRANSFER
	MOVEM	T2, BIOPBC(T1)	;STORE IT
	MOVE	T3, [POINT 8,BIODAT]
	ADD	T3, T1		;T3/ BYTE POINTER
	MOVEM	T3, BIOPBP(T1)	;STORE IT
	MOVEI	T1, 1
	DPB	T1, LOPBOP	;SET BLOCK-OUTPUT-IN-PROGRESS
	JRST	MORLIN		;(DISPATCH WILL GO DO IT)
;BLOCK OUTPUT IN PROGRESS

PGBOP:	HLRZ	T1, LDBBIO(U)
	SKIPN	T1
	 STOPCD
	MOVE	T2, BIOPBC(T1)	;T2/ COUNT
	MOVE	T3, BIOPBP(T1)	;T3/ POINTER
	MOVE	T4, MULCNT+1
	CAMLE	T4, CHCNT
	MOVE	T4, CHCNT	;T4/ MIN(MULCNT+1,CHCNT)
	PUSH	P, T4		;SAVE IT
	CAMLE	T2, T4
	MOVE 	T2, T4		;T4/ MIN(# TO XFER,# THAT'LL FIT)
	PUSH	P, T2		;SAVE IT

	JUMPE	T2, PGBOP2
PGBOP1:	UUILDB	T4, T3
	UUIDPB	T4, CHRWRP+1
	SOJG	T2, PGBOP1

PGBOP2:	POP	P, T2
	ADDM	T2, PBDISC	;(TO BE DISCOUNTED FROM CHARIO CHARGE)
	MOVN	T4, T2
	ADDM	T4, MULCNT+1	;DECREMENT MULCNT
	ADDM	T4, CHCNT	;AND CHCNT
	ADDM	T4, (P)		;AND SAVED # THAT'LL FIT
	ADDB	T4, BIOPBC(T1)	;AND BLOCK-BUFFER COUNT
	JUMPG	T4, PGBOP3	;IF WE'RE DONE
	PUSHJ	P, FRCOHR	;  FAKE AN OUTPUT-TERMINATED
	POP	P, T1
	JUMPLE	T1, FINLIN
	JRST	MORLIN
				;OTHERWISE,
PGBOP3:	MOVEM	T3, BIOPBP(T1)	;  UPDATE CHARACTER POINTER
	POP	P, T1
	JRST	FULLIN
;TERMINATE BLOCK OUTPUT

PGTRO:	SETZ	T1,
	DPB	T1, LOPBOP	;CLEAR BLKO-IN-PROGRESS
	PUSHJ	P, FRCOHR	;FAKE AN OUTPUT-TERMINATED
	JRST	MORLIN
;CIRCUIT ZAPPER

PGZAP:	MOVSI	T1, L2LOWT
	TDNN	T1, LDBBYT(U)	;IF WAITING FOR ORANGE BALL,
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEANING-UP,
	JRST	WATLIN		;  WAIT
	SETZM	LDBLOG(U)	;MARK THIS PORT GONE
	SETZM	LDBMOD(U)
	PUSHJ	P, TSETBO
	PUSHJ	P, TSETBI
	SETZ	T1,
	DPB	T1, LDBOPB(U)	;CLEAR NEED-OUTPUT
	PUSH	P, U
	PUSHJ	P, PTYBUD	;U/ "BUDDY" LDB
	SKIPN	LDBLOG(U)	;IF IT'S ALREADY GONE,
	JRST	PGZAP1		;  THERE'S NOTHING MORE TO DO
	HLL	U, LDBDCH(U)
	PUSHJ	P, FRCZAP	;FAKE A ZAPPER THERE
PGZAP1:	POP	P, U
	JRST	FINLIN

;BELL (SHOULDN'T REALLY HAPPEN) -- SIMULATE BLACK BALLS

PGSBL:	AOS	PTYLOS		;COUNT CHARACTER LOST BY US
	MOVEI	T1, 1
	PUSHJ	P, FRCLOS	;"INPUT LOST" TO BELL SENDER
	PUSH	P, U
	PUSHJ	P, PTYBUD
	MOVEI	T1, 0
	PUSHJ	P, FRCLOS	;"OUTPUT LOST" TO OTHER END
	POP	P, U
	POPJ	P,
SUBTTL TYMNET OUTPUT ROUTINES

;THIS ROUTINE IS CALLED TO SET THINGS UP FOR CHARACTER
;OUTPUT. NON-SKIP RETURN MEANS NO ROOM IN OUTPUT BUFFER

SETOUT:	SETOM MXMCNT		;FLAG THAT NO ROOM THERE
	MOVE P4,ORP620
	SUB P4,ORPPDP	;SIZE OF SPACE IN OUTPUT RING
	SOJL P4,[MOVEI P4,MSKORG+1
		SKIPN ORP620	;IF 620 AT 0 CAN NOT
		MOVEI P4,MSKORG	;USE LAST WORD
		SUB P4,ORPPDP	;FIND SPACE TO END OF BUFFER
		JUMPN P4,.+2	;SOME REALLY THERE
		POPJ P,]	;NOT REALLY ANY THERE
	JUMPE P4,CPOPJ		;REALLY NO ROOM
	LSH P4,2	;CONVERT TO NUMBER OF CHARACTERS
	SUBI P4,2	;TAKES TWO FOR COUNT AND PORT
	CAILE P4,177	;COUNT MUST FIT IN BYTE SIZE-1
	MOVEI P4,177
	MOVEM P4,MULCNT+0	;SAVE COUNT
	MOVEM P4,MXMCNT	;AND ORIGINAL (SO KNOW HOW MANY SENT)
	MOVE P4,ORPPDP
	MOVEI T1,ORING(P4)
	HRLI T1,(POINT 8,0,BYP2);SET TO PUT FIRST IN 3RD BYTE
	MOVEM T1,CHRWRP+0	;SET BYTE POINTER
	JRST CPOPJ1

;THIS ROUTINE IS CALLED TO FINISH UP OUTPUT. IT NONSKIP-RETURNS
;IF THERE IS NO BUFFER SPACE NOW.

CLSCHR:	SKIPGE T1,MXMCNT
	JRST SETOUT	;WE REALLY DON'T THINK ANY CHRS THERE
	SUB T1,MULCNT+0	;COMPUTE NUMBER OUTPUT
	JUMPE T1,CPOPJ1	;NONE SO MUST STILL BE SPACE
	SKIPG MULCNT+0	;DID WE RUN OUT OF ROOM IN RING
	SOS CHCNT+0		;YES, ACTUALLY 1 MORE CHR OUT
	SETOM FSCN	;FLAG AS SOME OUTPUT
	TRO T1,200	;SET BIT TO FLAG AS DATA TYPE
	DPB T1,OUPTYP	;SET IN TYPE FIELD
	LDB T3,LDPLNO
	DPB T3,OUPLIN	;AND THE PORT NUMBER
	SUBI T1,200-5	;COMPUT NUMBER OF WORDS USED
	LSH T1,-2
	ADD P4,T1
ADVPTR:	ANDI P4,MSKORG
	MOVEM P4,ORPPDP	;SET FOR 620 TO FIND
	PJRST SETOUT	;AND FIND OUT ABOUT MORE SPACE
COMMENT !
TO OUTPUT A CHARACTER INTO THE RING (OR TO A PTY), USE THE CODE:
	UUIDPB T3,CHRWRP(W)	;CHR. IN T3
	SOSLE MULCNT(W)		;SEE IF OUT OF ROOM
	SOSG CHCNT		;OR TIME TO STOP AND CHECK INPUT RING
	 HERE IF WE SHOULD STOP
	 HERE IF WE SHOULD NOT STOP
!

;OUTPUT A FULL WORD FOR SPECIAL TYPES

WRDOUT:	JUMPE W, .+2		;IF IT'S A PTY,
	 STOPCD 		;  THERE SHOULD BE ONLY CHAR. OUTPUT
	MOVEM P3,ORING(P4)	;PUT THE WORD IN THE OUTPUT BUFFER
	SETOM FSCN
	MOVNI P3,4
	ADDM P3,MULCNT+0	;UPDATE REAMAINING COUNTS
	ADDB P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT
	AOS CHRWRP+0
	AOS P4,ORPPDP	;JUST ADVANCE OUTPUT POINTER
	JRST CPOPJ1

;OUTPUT 2 WORDS FOR SPECIAL TYPES.

WRDOT2:	JUMPE W,.+2	;IF IT'S A PTY,
	 STOPCD 	;  THERE SHOULD BE ONLY CHARACTER OUTPUT
	MOVEM P3,ORING(P4) ;PUT 2ND WORD IN THE OUTPUT BUFFER.
	SETOM FSCN	;FLAG THAT THERE'S SOMETHING TO DO.
	MOVNI P3,8	;2 WDS (8 CHARS) TO OUTPUT.
	ADDM P3,MULCNT+0	;UPDATE REMAINING COUNTS
	ADDB P3,MXMCNT	;IN CASE WE GO TO CHR OUTPUT
	JUMPL P3,[AOJA P4,ADVPTR]	;WILL GET TO SETOUT.
	AOS CHRWRP+0	;INCREMENT CHAR BYTE POINTER.
	AOS CHRWRP+0	;INCREMENT IT AGAIN (PAST 2 WORDS).
	ADDI P4,1	;INCREMENT P4
	MOVEM P4,ORPPDP	;AND INFORM THE BASE.
	JRST CPOPJ1	;SKIP RETURN.
SUBTTL NON-CHARACTTPUT MESSAGE HANDLERS

;DON'T SEND ANY MESSAGES FROM THIS LINE

PGHSH:	 STOPCD			;HSH NOT USED ON PTYs
GOHSH:	LDB	T1,LOPZAP	;SEE IF ZAP SET
	SKIPN	T1
	  JRST	[AOS BADGUY	;COUNT BADGUYS THAT TRY TO SEND MESSAGES
		JRST WATLIN]	;	FROM THIS PORT
	PUSHJ	P,CLRTTY	;DO FALSE ZAP STUFF
	JRST	FINLIN

;SEND TERMINAL CHARACTERISTIC(S)

GOSTC:	PUSHJ	P, CLSCHR
	  JRST	FULLIN		;NO ROOM
GOSTC1:	MOVE	T3, LDBTMT(U)	;T3/TRANSMIT BITS
	JFFO	T3, .+2		;T4/T.C # TO SEND THIS TIME
	JRST	MORLIN		;NONE OR NO MORE
	MOVSI	P3, TYPI TYPTCS	;MESSAGE TYPE
	DPB	T4, WRPCHR	;CHARACTERISTIC NUMBER
	LDB	T1, TABTMS(T4)
	DPB	T1, WRPCH2	;CHARACTERISTIC VALUE
	MOVSI	T1, (1B0)
	MOVNS	T4
	LSH	T1, (T4)
	ANDCAM	T1, LDBTMT(U)	;CLEAR THE TRANSMIT BIT
	LDB T3,LDPLNO
	DPB T3,WRPLIN		;SET PORT NUMBER IN OUTPUT WORD
	PUSHJ P,WRDOUT		;SEND IT. IF THERE'S ROOM FOR MORE,
	JRST .+2
	JRST GOSTC1		;  GO SEE IF THERE'S MORE TO SEND.
	SKIPE LDBTMT(U)		;(NO ROOM) IF THERE WERE MORE TO DO,
	JRST FULLIN		;  SAY WE'RE NOT DONE
	JRST FINLIN
;SEND A RED BALL

GOSRD:	MOVSI P3,TYPI TYPRED
	JRST FMTB

;SEND A CHARACTER GOBBLER

GOCGB:	MOVSI P3,TYPI TYPGOB
	JRST FMTB

;SEND A TERMINAL CHARACTERISTICS PROBE

GOSTP:	MOVSI P3,TYPI TYPTCP	;PROBE
	MOVEI T3,TMCALL		;FOR ALL
	DPB T3,WRPCHR
	JRST FMTB

;SET ECHO MODE

GOSEC:	MOVSI P3,TYPI TYPECN	;ECHO ON
	MOVE T1,LDBDCH(U)	;GET BOTH HALVES OF DCH
	TDNE T1,[LDLNEC,,LDRDEM];DO WE WANT IT OFF INSTEAD?
	MOVSI P3,TYPI TYPECF	;(YES)
	JRST FMTB

;SEND SOFT ZAP (HANG UP PHONE, KEEP CIRCUIT)

GOHNG:	MOVSI	P3, TYPI TYPHNG
	JRST	FMTB

;FMTB -- CALLED WITH P3/ BYTE (8) TYPE, 0, XXX, XXX
;	 CLOSES CHARACTER MODE, RETURNING TO FULLIN IF NO ROOM,
;	 DEPOSITS PORT# INTO SECOND BYTE, TRANSMITS THE
;	 1-WORD MESSAGE, AND RETURNS TO THE OUTPUT DISPATCH
;FMTB1 -- ASSUMES CALLER HAS ALREADY DONE A CLSCHR

FMTB:	PUSHJ	P, CLSCHR	;LEAVE CHARACTER MODE. IF NO MORE ROOM,
	JRST	FULLIN		;  RETURN TO OUTPUT DISPATCH
FMTB1:	LDB	T3, LDPLNO	;T3/ PORT #
	DPB	T3, WRPLIN	;DEPOSIT IT
	PUSHJ	P, WRDOUT	;SEND IT. ROOM FOR MORE?
	  JRST	FINLIN		;NO
	JRST	MORLIN		;YES
;SEND BELL

GOSBL:	MOVE	T2, LDBDCH(U)
	TLNN	U, LDLIMI	;IF IN IMAGE STATE,
	TRNE	T2, LDRNXO	;OR USER SAYS NO XOFF/XON,
	JRST	MORLIN		;  AVOID SENDING BELLS
	MOVEI	T3, 7		;T3/ ASCII BELL
	;JRST	COMXON

;COMXON -- CALLED WITH T3/ A CHARACTER AND THE PORT OPEN FOR
;	   CHARACTER OUTPUT. DEPOSIT THE CHARACTER IN THE BUFFER
;	   RING AND RETURN TO THE OUTPUT DISPATCH

COMXON:	UUIDPB	T3, CHRWRP(W)	;DEPOSIT THE CHARACTER
	SOSLE	MULCNT(W)
	SOSG	CHCNT
	 JRST	FINLIN		;NO ROOM FOR MORE
	JRST	MORLIN		;ROOM FOR MORE

;BACKPRESSURE OFF

GOBPF:	MOVEI	T2, LDRXOS
	TDNE	T2, LDBDCH(U)	;IF WE SENT AN XOFF,
	JRST	GOXON		;  GO SEND AN XON
	PUSHJ	P, CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2, LDRBPS
	ANDCAM	T2, LDBDCH(U)	;TURN OFF BACKPRESSURE-SENT FLAG
	MOVSI	P3, TYPI TYPOUP	;P3/ MESSAGE TYPE
	JRST	FMTB1

    ;HERE TO SEND AN XON

GOXON:	ANDCAM	T2, LDBDCH(U)	;CLEAR BACKPRESSURE-SENT FLAG
	MOVEI	T3, 21		;T3/ ASCII XON
	JRST	COMXON		;GO SEND IT

;BACKPRESSURE ON

GOBPN:	LDB	T1, TRMBYP	;T1/ TERMINAL ID #
	JUMPE	T1, GOBPN1	;IF AUX CIRCUIT (0), BACKPRESSURE
	TLNN	U, LDLIMI	;OTHERWISE, IF NOT IMAGE STATE,
	JRST	GOXOFF		;  SEND AN XOFF
GOBPN1:	PUSHJ	P, CLSCHR
	  JRST	FULLIN		;NO ROOM FOR MESSAGE
	MOVEI	T2, LDRBPS
	IORM	T2, LDBDCH(U)	;SET BACKPRESSURE-SENT FLAG
	MOVSI	P3, TYPI TYPNOP	;P3/ MESSAGE TYPE
	JRST	FMTB1

   ;HERE TO SEND AN XOFF

GOXOFF:	MOVEI	T1, LDRNXO
	MOVEI	T3, LDRXOS
	TDNN	T3, LDBDCH(U)	;IF WE'VE ALREADY SENT ONE XOFF
	TDNE	T1, LDBDCH(U)	;OR IF WE MUSTN'T SEND ANY,
	JRST	MORLIN		;  JUST SAY WE'VE DONE IT
	IORM	T3, LDBDCH(U)	;SET XOFF-SENT FLAG
	MOVEI	T3, 23		;T3/ ASCII XOFF
	JRST	COMXON		;GO SEND IT
;SEND CIRCUIT ZAPPER

GOZAP:	MOVSI	T1, L2LOWT
	TDNN	T1, LDBBYT(U)	;IF SOMEONE'S WAITING FOR ORANGE BALL
	SKIPE	LDBBIO(U)	;OR IF BLOCK I/O NEEDS CLEEANING-UP,
	JRST	WATLIN		;  WAIT
	PUSHJ P,CLSCHR		;LEAVE CHAR MODE. SKIP IF ROOM.
	JRST FULLIN		;  MUST WAIT OR NO ROOM
	HRRZ T1,U
	CAME T1,OPRLDB
	JRST NOTOPR
	SETZM OPRLDB
	SETZM DEVOPR
	PUSHJ P,OPRFRE
	MOVEI T1,400000
	TDNE T1,STATES		;IS SYSTEM SHUT?
	JRST NOTOPR		;YES
	MOVEI T1,^D90
	MOVEM T1,OPRTIM		;NO, SET TIMER FOR UNHAPPY MSG
NOTOPR:	TLNN U,LDLAUX!LDLPTY	;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL LDBLOG(U)
	JRST NOTLIN		;NOT REALLY IN
	MOVEI T1,200000
	SOSG INTERM
	SKIPE DWNFLG
	SKIPA			;DO NOT RESET IF COMING DOWN
	ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
NOTLIN:	SETZM LDBLOG(U)		;CLEAR LOGGED IN INFO
	SETZM LDBMOD(U)		;RESET MODE TO LOGIN MODE
	PUSHJ P,TSETBO
	PUSHJ P,TSETBI		;ALSO CLEAR INPUT
	MOVE T1,LDBLIN(U)
	TLZE T1,LNLZIN
	AOS NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM T1, LDBLIN(U)
	MOVEI T1,0
	DPB T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	MOVSI P3,TYPI TYPZAP
	LDB T2,LDPLNO
	DPB T2,WRPLIN
	CAILE T2,RPORTN
	 STOPCD 		;CRASH- ZAPPING BEYOND HIGHEST REAL PORT
	PUSHJ P,WRDOUT
	 JRST FINLIN
	JRST FINLIN		;NOBODY LEFT TO TALK TO

CLRTTY:	HRRZ T1,U		;FALSE ZAP STUFF FOR REAL TTYs
	CAME T1,OPRLDB
	JRST NTTOPR
	SETZM OPRLDB
	SETZM DEVOPR
	PUSHJ P,OPRFRE
	MOVEI T1,400000
	TDNE T1,STATES		;IS SYSTEM SHUT?
	JRST NTTOPR		;YES
	MOVEI T1,^D90
	MOVEM T1,OPRTIM		;NO, SET TIMER FOR UNHAPPY MSG
NTTOPR:	TLNN U,LDLAUX		;THIS ONE WAS NOT COUNTED ANYWAY
	SKIPL LDBLOG(U)
	JRST CLRPTY		;NOT REALLY IN
	MOVEI T1,200000
	SOSG INTERM
	SKIPE DWNFLG
	SKIPA			;DO NOT RESET IF COMING DOWN
	ANDCAM T1,STATES	;CAN'T BE SUPER SHUT WITH EVERYONE GONE
CLRPTY:				;FALSE ZAP ENTRY FOR PTYs
	SETZM LDBLOG(U)		;CLEAR LOGGED IN INFO
	SETZM LDBMOD(U)		;RESET MODE TO LOGIN MODE
	PUSHJ P,TSETBO
	PUSHJ P,TSETBI		;ALSO CLEAR INPUT
	MOVE T1,LDBLIN(U)
	TLZE T1,LNLZIN
	AOS NZAPOT		;AN IN-ZAP WAS RESPONDED TO
	MOVEM T1, LDBLIN(U)
	SETZM	LDBOUT(U)	;CLEAR 'SEND SPECIAL MESSAGE' FLAGS
	MOVEI T1,0
	DPB T1,LDBOPB(U)	;NOTHING MORE TO DO ON OUTPUT
	POPJ	P,
;HERE ON A DETECTED ZAPPER ANOMALY TO STORE STUFF ABOUT THE PORT

ZBGBUG:	0	;ADDRESS OF THE COUNT INCREMENTED

ZBGLIN:	0	;LDBLIN OF THE OFFENDING PORT
ZBGDCH:	0	;LDBDCH
ZBGDDB:	0	;LDBDDB
ZBGOUT:	0	;LDBOUT
ZBGBIT:	0	;OUTPUT BIT
ZBGBYT:	0	;LDBBYT
ZBGMOD:	0	;LDBMOD
ZBGDCX:	0	;LDBDCX
	0
	0
	0
	0

ZAPBUG:	PUSH	P, T2
	HRRZI	T2, ZBGBUG-1	;(PDL POINTER)
	PUSH	T2, T1		;STORE THE COUNTER'S ADDRESS
	AOS	(T1)		;INCREMENT THE COUNTER
	PUSH	T2, LDBLIN(U)
	PUSH	T2, LDBDCH(U)
	PUSH	T2, LDBDDB(U)
	PUSH	T2, LDBOUT(U)
	LDB	T1, LDBOPB(U)
	PUSH	T2, T1
	PUSH	T2, LDBBYT(U)
	PUSH	T2, LDBMOD(U)
ZAPBG1:	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	POP	P, T2
	POPJ	P,
\z)