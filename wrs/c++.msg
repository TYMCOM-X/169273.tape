Received: from C57.Tymnet by B39.Tymnet; Thu, 27 Mar 86 15:57:40 PST
Received: from tymix.Tymnet by C57.Tymnet; Thu, 27 Mar 86 15:54:57 PST
Received: by tymix.Tymnet (4.12/4.7) id AA21781; Thu, 27 Mar 86 15:54:35 pst
Return-path: <kanner@tymix.Tymnet> 
From: kanner@tymix.Tymnet (Herb Kanner) 
Date: Thu, 27 Mar 86 15:54:35 pst 
To: wrs@tymix.Tymnet 
Message-id: <8603272354.AA21781@tymix.Tymnet> 
Subject: C++ 

Here is the News item I mentioned to you:


Ok, it is time for another dump of general C++ information:

	With very minor exceptions C is a subset of C++.
	The key concept added to C to get C++ is a Simula-like class.
	C++ is link compatible with C.
	No run time efficiency is lost compared to C.

C++
	- is a better C
		- function argument type checking and coercion
		- scoped & types constants
		- inline functions
		- overloaded function names
		- free store operators (new & delete)
		...
	- supports Data Abstraction
		- data hiding
		- optional guaranteed initialization (constructors)
		- optional guaranteed cleanup (destructors)
		- operator overloading
		- references
		...
	- supports Object Oriented Programming
		- derived classes (single inheritance)
		- virtual functions

You can read about the language in

		Bjarne Stroustrup: The C++ Programming Language
		Addison Wesley, 1986, ISBN 0-201-12078-X
		336 Pages. Recommended price $22.95

You get an implementation from

		AT&T Software Sales and Marketing
			Post Office Box 25000
		Greensboro, North Carolina  27420
		(800) 828-UNIX or (919) 279-3666)
Or
		AT&T Unix Pacific Co.,Ltd.
		Nippon Press Center Bldg.
		2-2-1, Uchisaiwai-cho
		Chiyoda-ku, Tokyo 100 Japan
Or
		UNIX Europe Limited,
		27A Carlton Drive, London SW15 2BS, England.
		Tel: +44 1 785-6972, fax: +44 1 785-6916,
		EUnet: mcvax!ukc!uel!uel.

They charge universities $250 others $2K
(so, yes, it is commercially available).

The main part of implementation is a compiler front-end that
translates C++ into C. This front-end (called ``The AT&T C++
Translator'' or colloquially, cfront) performs all syntax and
type checking, the underlying C compiler is used as a code
generator only. This two stage compilation process has two main
effect:
	- errors are found about 3 times faster by the C++ compiler
		than by the C compiler.
	- when there is no bugs the compilation takes 50% to 100%
		longer than for a C program.

The version shipped by AT&T is for a VAX or an AT&T 3B running UNIX
(SysV and BSD). Once you have it running on such a machine porting
to any machine with a good C compiler is easy provided the target has

	- enough memory (about 1Mb to compile cfront)
	- long names (both in the C compiler and the linker)

Porting cfront without first bringing C++ up on a VAX or 3B is possible,
but probably hard work.

C++ is in use on
	- Amdahls
	- AT&T 3Bs
	- M68Ks (Suns, Apollos, etc.)
	- Pyramids
	- VAXs
	and several other other UNIX boxes.

- Bjarne Stroustrup (AT&T Bell Labs, Murray Hill)

My list of questions follows:

1)	What is the actual form of the released product?  Is it C source for
	what is in effect a compiler for the C++ language, i.e. a compiler that
	eats C++ source and produces a.out object linkable by UNIX "ld"?

2)	How is "high-level" debugging currently done?  Is there any obvious
	way to use products such as dbx?

3)	Is there any serious problem porting to systems that have C compilers
	with run-time libraries that approximate but do not really coincide
	with the standard UNIX library?
Herb
From: William R. Soley <WRS@C39.Tymnet> 
Date: Thu, 27 Mar 86 16:02:07 PST 
To: kanner@tymix.Tymnet (Herb Kanner) 
Subject: Re: C++ 
In-reply-to: <8603272354.AA21781@tymix.Tymnet> of Thu, 27 Mar 86 15:54:35 pst

Having read the message from Bjarne, I think the answer to your question (1)
is obviously that the C++ compiler translates C++ to C and is really quite
removed from the internals of the compiler.  The only restriction about the
target compiler is that it implement long names, even at link time.  I'm
sure the answer to (2) is that you really debug the output of C++, i.e. the
C program.  I would reword question (3) to be more specific, perhaps:

-	Since we are planning to use C++ to cross compile for a stand alone
	(non-Unix) environment, what runtime functions must be implemented
	in order to support code generated by 'cfront'?  Should we expect
	any other problems building such a cross compiler?

-Bill
From: William R. Soley <WRS@C39.Tymnet> 
Date: Thu, 27 Mar 86 19:41:35 PST 
To: kanner@tymix.Tymnet (Herb Kanner) 
Subject: Re: copy of posted item 
In-reply-to: <8603280124.AA22646@tymix.Tymnet> of Thu, 27 Mar 86 17:24:23 pst

This looks good, except that from your quotes in question 2, I think it is
quite clear that its a front end.  I realize that the language is a little
informal, but consider it in light of what active role each phase has in
production of the end product.  If the front end checks all aspects of the
syntax and whatever symantics are checkable, then one can say that the syntax
checking is done there and not in the C compiler since (1) it could be removed
from the C compiler with no adverse effect, (2) since C++ only outputs correct
programs, then whatever checking the C compiler does is a no-op, (3) the C
compiler generally only complains about things it happens to notice as a side
effect of building the parse trees - the real syntax and symantic checking is
done by lint - one could say the C compiler never did do any syntax checking.
In fact the Berkeley version of C does much more checking than most.  I would
replace question (2) with something like below:

----------------------------------------------------------------
1) Is the assumption that the compiler is released in the form of C source
a correct one?

2) Are there any runtime routines used by C++ other than those included
in the standard C library?

3) How do you do debugging with the current product?  Is it to set dbx or 
sdb flags on the C compiler, capture a copy of the intermediate C, and work
with that?

4) We are planning to use C++ to cross compile for a stand-alone (non-UNIX)
environment.  What runtime functions must we implement in order to support
code generated by cfront?  What other problems in building such a cross
compiler might we expect?
----------------------------------------------------------------

-Bill

PS - the more I think about it, the fact that C++ would generate C code
seems to me to eliminate most of my concerns about standards.  All that
would be necessary is to update C++ to include any new standards which
are not already covered.  The real brawn of the compiler would still be
provided seperately as C.  Portability may not be an issue since we can
just transmit the 'C' output in the baseline - it could be compiled for
anything the user wishes.  Original C++ would be provided as well, but
the user would not need to be able to compile it.
From: William R. Soley <WRS@C39.Tymnet> 
Date: Thu, 27 Mar 86 19:56:49 PST 
To: kopfj 
Subject: C++ 

Herb and I are interested in getting C++, partially for experimentation, and
partially because it might be a good replacement for Concurrent PASCAL.  He
has also made me aware that the C++ compiler available from Bell outputs
standard C source code.  This solves the compiler upgrade problem since it
would not represent another code generator to maintain.  Now, given the
choice between Concurrent PASCAL (talk about non-standard) and C++, I will
cast my lot with C++, both from an aesthetic view, and from a maintainability
view.  Essentially, if we had the C++ compiler, we would automatically have
a C++ for any machine we had a good C compiler for, with little or no
programming or support effort.  In this way, software which needed the extra
functionality of C++ could use it, and those that didn't could save the added
overhead at compilation time by bypassing the C++ pass.  What do you think?
Of course we have to decide how well C++ will fill the shoes of C-PASCAL.

-Bill
Received: from C36.Tymnet by B39.Tymnet; Tue, 1 Apr 86 21:50:38 PST
Received: from tymix.Tymnet by C36.Tymnet; Tue, 1 Apr 86 21:49:05 PST
Received: by tymix.Tymnet (4.12/4.7) id AA19660; Tue, 1 Apr 86 21:48:53 pst
Return-path: <kanner@tymix.Tymnet> 
From: kanner@tymix.Tymnet (Herb Kanner) 
Date: Tue, 1 Apr 86 21:48:53 pst 
To: wrs@tymix.Tymnet 
Message-id: <8604020548.AA19660@tymix.Tymnet> 
Keywords: C++ 
Subject: reply from B.S. on C++ 

Article 135 of net.lang.c++:
Relay-Version: version B 2.10.2 9/18/84; site tymix.UUCP
Posting-Version: version B 2.10.1 6/24/83; site alice.UUCP
Path: tymix!oliveb!hplabs!pesnta!pyramid!decwrl!decvax!bellcore!ulysses!allegra!alice!bs
From: bs@alice.UucP (Bjarne Stroustrup)
Newsgroups: net.lang.c++
Subject: Query to Bjarne (answer)
Message-ID: <5227@alice.uUCp>
Date: 1 Apr 86 02:33:23 GMT
Date-Received: 2 Apr 86 03:40:13 GMT
Organization: Bell Labs, Murray Hill
Lines: 73

> From: kanner@tymix.UUCP (Herb Kanner)
> Newsgroups: net.lang.c++
> Subject: Query to Bjarne
> Organization: Tymnet Inc., Cupertino CA
> 
> Here are a few questions, probably addressed to Bjarne Stroustrup, with
> respect to the released version of the C++ compiler.

> 1) Is the assumption that the compiler is released in the form of C source
> a correct one?

The released version of the C++ translator (commonly known as cfront) comes in
C++ source form together with a C version of of cfront (generated by itself) for
a VAX or a 3B.

> 2) It is described as a front end, and in one of your news items you refer
> to inspection of its C output.  You also specifically call it "a front-end
> that translates C++ into C."  Later in the same sentence, you say that
> cfront does all syntax and type checking and that the underlying C compiler
> is used as a code generator only.  Superficially, this sounds like a
> contradiction.  Is it that some options are set so that unnecessary
> checking steps on the part of the C compiler are skipped because its input
> is guaranteed to be clean?

No, the C compiler goes through a ``completely unnecessary'' syntax and type
checking step. I wish I could turn that off and go directly to the code
generation part of cc. However, that would take away the portability that was
the reason for generating C in the first place. You gain portability and
lose cpu time when you must generate code. What you can reasonably hope for is
that you re-gain that cpu time by using a better language and because the two
pass approach (cfront + cc) yields error messages about 3 times faster than a
one pass approach (such as ``plain'' cc).

> 3) How do you do debugging with the current product?  Is it to set dbx or 
> sdb flags on the C compiler, capture a copy of the intermediate C, and work
> with that?

That is ``approach number one''. It is not ideal, but it has been done. A better
approach involves a debugger that can relate the object code to the C++ source.
This has been done, but I don't know of any commercially available debuggers
that does that.

> 4) We are planning to use C++ to cross compile for a stand-alone (non-UNIX)
> environment.  What runtime functions must we implement in order to support
> code generated by cfront?

malloc() and free(). The C++ library contains a few more functions _main(),
_ctors(), _dtors(), operator new(), and operator delete(), but they are trivial
portable, and supplied in C++ source form.

You will also have to provide an I/O library (printf and/or stream I/O).

> What other problems in building such a cross compiler might we expect?

Cfront needs to know the sizes and alignments used by the C compiler on the
target machine. Typically, you get them wrong first time. Have a look at the
description of how to port release 1.0 of C++ to a variety of machines
posted to net.lang.c++ by Jonathan P. Leech at California Institute of Technology.
It mentions most snags and their fixes.

> Herb Kanner, McDonnell Douglas (TYMNET), ...!hplabs!oliveb!tymix!kanner
> 
> An additional question suggested by a colleague:
> 
> Are there any runtime routines used by C++ other than those included
> in the standard C library?

None that are essential for running programs, but C++ does come with a
``stream I/O library'' as described in the C++ book. There is also a
library of functions and operators for complex arithmetic. Some rudementary
facilities for creating generic types, and a library for writing event
driven simulations a la Simula67. This ``task libray'' contains machine
dependent code and a few lines of assembler so it will only run on a VAX.




Herb
Received: from C36.Tymnet by B39.Tymnet; Thu, 3 Apr 86 10:06:02 PST
Received: from tymix.Tymnet by C36.Tymnet; Thu, 3 Apr 86 9:48:52 PST
Received: by tymix.Tymnet (4.12/4.7) id AA29850; Thu, 3 Apr 86 09:52:18 pst
Return-path: <kanner@tymix.Tymnet> 
From: kanner@tymix.Tymnet (Herb Kanner) 
Date: Thu, 3 Apr 86 09:52:18 pst 
To: wrs@tymix.Tymnet 
Message-id: <8604031752.AA29850@tymix.Tymnet> 
Keywords: C++ 
Subject: Porting C++ 

Date: Sun, 30 Mar 86 12:26:21 PST
From: oliveb!hplabs!caip!cit-vax!jon (Jonathan P. Leech)
Message-Id: <8603302026.AA07458@csvax.caltech.edu>
To: caip!hplabs!oliveb!tymix!kanner
Subject: Re: Query to Bjarne
Newsgroups: net.lang.c++
In-Reply-To: <723@tymix.UUCP>
Organization: California Institute of Technology
Status: RO

    Since I've had a fair amount  of  C++  porting  experience	I  can
answer some of these:

In article <723@tymix.UUCP> you write:
>
>Here are a few questions, probably addressed to Bjarne Stroustrup, with
>respect to the released version of the C++ compiler.
>
>1) Is the assumption that the compiler is released in the form of C source
>a correct one?

    Yes, BUT: the C source is only promised to work on a VAX  or  3Bxx
machine. To get C++ running  elsewhere,  you  need  to	bootstrap  the
compiler and then cross-compile down to C for the target architecture.

>
>2) It is described as a front end, and in one of your news items you refer
>to inspection of its C output.  You also specifically call it "a front-end
>that translates C++ into C."  Later in the same sentence, you say that
>cfront does all syntax and type checking and that the underlying C compiler
>is used as a code generator only.  Superficially, this sounds like a
>contradiction.  Is it that some options are set so that unnecessary
>checking steps on the part of the C compiler are skipped because its input
>is guaranteed to be clean?
>

    C++ is a true compiler. The C code coming  out  the  back  end  is
dependent on the target machine (a pity), and not very readable.   For
example, sizeof() and  enumerations  turn  into  hardwired  constants.
Variable and procedure names are horribly mangled; for	example,  'int
thing' turns into 'int _auto_thing' (and  this	is  one  of  the  less
extreme cases).

>3) How do you do debugging with the current product?  Is it to set dbx or
>sdb flags on the C compiler, capture a copy of the intermediate C, and work
>with that?

    With an appropriate option to CC, I've set dbx  up	to  work  with
either the C++ source code or the C code  it  generates.  The  problem
with the first is that all the variable names change; the problem with
the second is trying to figure out where in the original  source  code
you are.  The  C  compiler  and  debugger  need  to  share  additional
information (such as the mapping of C++=>C names) and be able to  look
at both forms of source, but that will be a lot of work.

>
>4) We are planning to use C++ to cross compile for a stand-alone (non-UNIX)
>environment.  What runtime functions must we implement in order to support
>code generated by cfront?  What other problems in building such a cross
>compiler might we expect?
>--

    You will need to implement the  memory-allocation  functions  from
the C++ library. If you want to use  the  complex  arithmetic,	stream
I/O, etc. classes, you will have to compile their code also.

    The C++ compiler is actually  two  programs  invoked  by  a  shell
script. The first, 'cfront', is the C++=>C compiler.   The  second  is
called 'munch' and handles the problem of calling  class  constructors
and destructors for static objects by looking through  the  name  list
of the executable generated  by  cfront  and  cc  for  static  objects
requiring constructors and destructors (their names contain  a	unique
string), then relinking so that the constructors and destructors  thus
found are called at the right time.

    Thus you will have to  rewrite  the  'CC'  shell  script  and  the
'munch' program. If you can't extract the name list and relink on your
target architecture, you're in trouble. You can  live  without	static
class members except that the stream I/O facility requires them.

    Finally, the C compiler and linker for  the  target  must  support
structure assignment and long variable names.

    -- Jon Leech (jon@csvax.caltech.edu || ...seismo!cit-vax!jon)
    __@/

From: William R. Soley <WRS@C39.Tymnet> 
Date: Fri, 4 Apr 86 1:52:40 PST 
To: kanner@tymix.Tymnet (Herb Kanner) 
Keywords: C++ 
Subject: Re: Porting C++ 
In-reply-to: <8604031752.AA29850@tymix.Tymnet> of Thu, 3 Apr 86 09:52:18 pst

Well, I think that all sounds pretty positive.  Its too bad that the ident-
ifiers get munged, but at least its better than HEX.  I think we should go
ahead and write a P.O. with a justification memo.  I know somebody at
Tektronix (Scott Daniels, in fact) that has a copy.  I'm having dinner with
him tonight so I'll see if he's had a chance to play with it any.  He hadn't
had last time we talked.  What's your opinion so far?  -Bill
Received: from C57.Tymnet by B39.Tymnet; Fri, 4 Apr 86 9:28:41 PST
Received: from tymix.Tymnet by C57.Tymnet; Fri, 4 Apr 86 9:27:03 PST
Received: by tymix.Tymnet (4.12/4.7) id AA06916; Fri, 4 Apr 86 09:26:48 pst
Return-path: <kanner@tymix.Tymnet> 
From: kanner@tymix.Tymnet (Herb Kanner) 
Date: Fri, 4 Apr 86 09:26:48 pst 
To: WRS@C39.Tymnet, kanner@tymix.Tymnet 
Messa: <8604041726.AA06916@tymix.Tymnet> 
Subject: Re: Porting C++ 

So far, my opinion is that we should get it.  The notion of participation in
a justification memo is a bit embarrassing, because my objective would be to
create a C++ cross compiler for Engine, and that requires building a) a C cross compiler for Engine (relatively easy), and b) a linker and library manager
(much harder).  If your justification is immediate, I am happy to add my 
justification, with the caveat that it does not become operative until the
prerequisite software has been built.

Romulo could be a potential user of the language in the long run.  I am having
a hard time keeping him from borrowing my copy of the C++ book.  Maybe you would
like to lend him yours :-) .

Herb

 @Œ