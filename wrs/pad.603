	SUBTTL	PAD.602 - MODULE FOR X.3/X.28/X.29 PAD FUNCTIONS
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated The recipient, by receiving   **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other purpose except as specifically authorized in writing  **
: **  by  TYMNET, Incorporated.                                   **
: ******************************************************************
: **                   MODULE IDENTIFICATION                      **
: **                                                              **
: **  File Name          :  PAD.602        last change: 12/11/86  **
: **                                                              **
: **  File Description   :  This module provides X.28 PAD functions*
: **			    that allow async terminals to access a**
: **			    X.25 host DTE.  It really acts like a **
: **			    protocol converter that handles IIX   **
: **			    packets.  The X.28 PAD converts async **
: **			    to/from IIX packets.  At the other end,*
: **			    the X.25/X.75 host interface converts **
: **			    IIX packets to/from X.25 packets.     **
: **                                                              **
: **  File Abstract      :  This CONSAT X.28 PAD module allows full*
: **			    duplex ASCII terminals to access X.25 **
: **			    hosts via a Tymnet X.25 interface slot.*
: ******************************************************************
: ******************************************************************
: **                    CHANGE LOG                                **
: **                                                              **
: **  Ver   Date    By   PIR/NSR  Changes (most recent at top)    **
: ** ----- -------- ---  -------- ------------------------------- **
: ** 06.02 12/11/86 dlg		  Added jal to IGCSCN and GCSCN to**
: **				  correctly count char in .FEDBF  **
: **				  (NULLS only increase cout by 1) **
: ** 06.02 12/11/86 DLG		  Added P.BCT to count characters **
: **				  in edit buffer, to avoid 	  **
: **				  counting null as 2 char's 	  **
: ** 06.02 12/01/86 DLG		  Removed NPAPRT check from XICA20**
: **				  placing it on LIMBO in same	  ** 
: **				  to prevent assembly error	  **
: ** 06.02 11/26/86 dlg		  Removed jump to CMDRTN from CLR **
: **				  caused double pad prompt	  **
: ** 06.02 11/26/86 DLG		  Corrected accounting routines   **
: **				  to only send acct msg's when    **
: **				  circuit is present.		  **
: ** 06.02 11/25/86 dlg		  Modified SENCLR to call XP.ZAK  **
: **				  which sends clr msg to term and **
: **				  resets terminal parameters and  **
: **				  send PAD's prompt.		  **
: ** 06.02 11/20/86 dlg		  Added fix GIR.10 to allow inc.  **
: **				  calls from SMART CONSAT	  **
: ** 06.02 11/19/86 dlg		  Changed XINCAL to switch port to**
: **				  command mode if in login mode   **
: **				  when smart host calls.	  **
: ** 06.02 11/18/86 DLG		  Fixed race condition when going **
: **				  from command to login mode.	  **
: ** 06.02 11/17/86 DLG		  Restructured IXPROF, created	  **
: **				  another entry IXPRLG for ports  **
: **				  entering CONSAT login mode.	  **
: ** 06.02 11/14/86 SDW		  Added the restoring of .VSTAT   **
: **				  after receipt of IIX neg.	  **
: ** 06.02 11/13/86 dlg		  Made possible chg from cmd to	  **
: **				  login mode for ports without	  **
: **				  Tymnet Extended Cmd capability. **
: ** 06.02 11/07/86 dlg		  Reset CLAPRG array in IX3PRT,	  **
: **				  Added jump to subroutine to put **
: **				  port in cmd mode if it rec inc  **
: **				  call while in login mode & X3ON.**
: ** 06.02 11/06/86 DLG		  Changed PMODE to PADACT, copied **
: **				  contents of echo to to-term buf **
: **				  prior to changing pointer value **
: **				  of .TPBUF and removing PAD 	  **
: **				  filters, when going from cmd to **
: **				  login mode.	  **
: ** 06.02 11/03/86 DLG		  Removed PAD filters from port   **
: **				  initially in login mode (IXPROF)**
: ** 06.02 10/13/86 CAB		  Added echo for semicolon (EDCM72)*
: ** 06.02 10/13/86 CAB		  Added PROFILE AND PROFILE? to   **
: **				  command lookup table.		  **
: ** 06.01 09/22/86 dlg		  Added check to IXPROF to exit if**
: **				  port can not enter cmd mode	  **
: ** 06.01 09/19/86 cab		  Moved ICAAU init ahead of IXPROF**
: **				  exit for unsupported device type.*
: ** 06.01 09/11/86 dlg		  Changed instr to RX3 format, at **
: **				  ABBA30+3 to stop assembly error **
: ** 06.01 08/28/86 dlg		  Corrected TBR.CC entries per CAB**
: ** 06.01 08/28/86 DLG 	  IXPROF-moved reset of PMODE and **
: **				  setting of PNMODE before exits, **
: **				  replaced check for .SPORT with  **
: **				  check for .MPORT, allowing SIO  **
: ** 06.01 08/19/86 DLG  NSR 873  Changed CHOST to be a table of  **
: **				  BCD host numbers indexed by RP2 **
: ** 06.01 08/11/86 dlg  NSR 856  Placed X.MAPZ in line and 	  **
: **				  removed lable, also placed 	  **
: **				  X.MAPY in line and changed to   **
: **				  X.MAP3 AND X.MAP4 with R4 not   **
: **				  used.  			  **
: ** 06.01 08/10/86 dlg		  Saved and restored R1 prior to  **
: **				  calling EDSFWD		  **
: ** 06.00 07/14/86 CAB		  Fixed X29 set/read error codes  **
: ** 06.00 07/11/86 DLG		  Added NOMERR check so parameters**
: **				  following a bad national option **
: **				  marker are rejected.            **
: ** 06.00 07/11/86 DLG		  Corrected break handling logic  **
: **				  for packet mode so parm 7:2 does**
: **				  not affect parm 8, and interrupt**
: **				  packet won't get gobbled.	  **
: **				  Generalized parm 7 logic to 	  **
: **				  allow all legal settings	  **
: ** 06.00 07/10/86 DLG		  Corrected crash on bad X.29 msg **
: ** 06.00 07/10/86 dlg	  	  Corrected Natl parm 102 read 	  **
: **				  logic to return parm val 	  **
: ** 06.00 07/08/86 sdw           echo BS in data mode without    **
: **                              affecting the com or data editor**
: ** 06.00 07/08/86 CAB	 	  Changed CCCLR to allow diag code**
: ** 06.00 07/08/86 CAB	 	  Deleted DATEDT from par 15 logic**
: ** 06.00 06/30/86 CAB	 	  Fixed problem of bs/sp/bs not   **
: **				  sent for char delete if par 6 off*
: ** 06.00 06/30/86 CAB		  Fixed XPLFIN problem of double LF*
: **				  when connected to non-X.25 host.**
: ** 06.00 06/24/86 CAB	 NSR 781  Changed CLRCAL to not set echo. **
: ** 06.00 06/23/86 dlg	 NSR 796  Incorporated Krumviede's patch  **
: **				  to correct Q-mode problems	  ** 
: **				  PAD endless loop and DEM signal **
: **				  not sent to host on CR	  **
: ** 06.00 06/23/86 dlg		  Converted PARALL/PARTYM into	  **
: **				  callable subroutines.		  **
: ** 06.00 06/20/86 dlg	 NSR 781  Changed SETALL into three parts **
: **				  INITCS, INITX3, and INITN3	  **
: **				  Corrected SET? 0:0 logic	  **
: ** 06.00 06/17/86 dlg		  Clearified SETALL code and 	  **
: ** 				  consolidated X3.FL1 and X3.FL2  **
: **				  into one table X3.FLG		  **
: ** 06.00 06/16/86 CAB	  	  Optimized X3.P13 code in XPADFI.**
: ** 06.00 06/16/86 CAB	  	  Cleaned up COSP/COP/CISP/CIP.   **
: ** 06.00 06/16/86 CAB	  	  Cleaned up CCPROR and CCPROS.   **
: ** 06.00 06/16/86 CAB	  	  Changed IXPROF so non-PAD ports **
: **				  can be handled by vanilla Consat**
: **				  (reset PADARY and zero filters) **
: ** 06.00 06/13/86 DLG	  	  Deleted CESETT/CESERT/CEREAT and**
: **				  modified CESETC/CESERC/CEREAC,  **
: **				  CCSET/CCPAR, and PARSET/PARRED  **
: **				  to use new X3 dispatch tables.  **
: ** 06.00 06/12/86 CAB		  Integrated X3 dispatch tables   **
: **				  XSETTB/TSETTB and XREATB/TREATB **
: **				  so they could be indexed by X3  **
: **				  parameter number (1-18,101-103).**
: ** 06.00 06/11/86 CAB		  Changed X3 set and read routines**
: **				  for EXSVAL/EXRVAL, EXSSWI/EXRSWI.*
: ** 06.00 06/10/86 CAB  NSR 778  Made X3.P11 logic work correctly**
: ** 06.00 06/09/86 DLG	 NSR 784  Now the CONSAT echo table is	  **
: **				  placed in the port table before **
: **				  going from cmd to login mode	  **
: ** 06.00 06/06/86 CAB	 NSR 779  Made X3.P13 logic work correctly**
: ** 06.00 06/06/86 CAB	 NSR 782  Made timeout logic work correctly*
: ** 06.00 05/30/86 DLG		  Fixed bug in Set All that caused**
: **				  missing line feed.		  **
: ** 06.00 05/29/86 DLG		  Removed TR.BYT, TR.BIT, TS.BIT  **
: **				  placed inline.		  **
: ** 			  	  Changed X3.N3 logic to handle HW**
: **				  Removed X3.BA1 and X3.BA2.	  **
: ** 			 NSR 776  Changed handling of X3.P7 when  **
: **				  tossing of data required.  	  **
: **			 NSR 777  Replaced TOSING with X3.P8 and  **
: **				  changed logic to only toss data **
: **				  from Network when X3.P8=1.	  **
: ** 06.00 05/25/86 sdw		  incoming calls set up PSIZE	  **
: ** 06.00 05/25/86 sdw		  EBSIZE is not used for command  **
: **				  line character check		  **
: ** 05.00 05/10/86 sdw           Made pad able to make a call to **
: **                              an IIX capable host through a   **
: **                              Gateway.  Internally, a new mode**
: **                              just for gateways was added.    **
: ** 05.00 04/30/86 sdw           Logon stat through gateway gets **
: **                              special handler in LOGGER cause **
: **                              PVC logic has hooks in current 1**
: ** 05.00 04/27/86 sdw           IXPROF uses SETALL -duplicate   **
: **                              code.                           **
: ** 05.00 04/27/86 sdw           Added quit command to drop self **
: ** 05.00 04/24/86 sdw           Changed XPFOLD to handle 8 bits **
: ** 05.00 04/22/86 sdw           Moved and rewrote CUD logic     **
: ** 05.00 04/22/86 sdw           Added AUTOCALL feature which    **
: **                              creates a command and if it     **
: **                              matches sends the genned login  **
: **                              string.                         **
: ** 05.00 04/14/86 sdw           Tell user in data transfer mode **
: ** 05.00 04/11/86 dlg  	  Corrected call user data handler**
: **				  to send all hex pairs given and **
: **				  display error if odd no. of     **
: **				  digits given.			  **
: ** 05.00 04/11/86 dlg		  Added error message for PAR?    **
: ** 				  if parm#>128 is given           **
: ** 05.00 04/11/86 dlg  NSR 0656 Corrected PSIZE at CALC10+6 to  **
: **				  enable data forwarding of	  **
: **				  packets with 128 characters.	  **
: ** 05.00 04/11/86 dlg  NSR 0657 Fixed incorrect return from     **
: **			  	  PARSET, made hook for 2nd type  **
: **				  error				  **
: ** 05.00 04/11/86 dlg  	  Correction made to the SET and  **
: **				  READ cmd to display the correct **
: **				  parm# when invalid parm value   **
: **				  given.			  **
: ** 05.00 04/10/86 sdw           Changed CUD.LT to port table    **
: ** 05.00 04/10/86 sdw           CPARSE allows spaces before cmd **
: ** 05.00 04/09/86 sdw  NSR 0655 Fix break crash by movin xp.go4 **
: ** 05.00 04/02/86 sdw           New command REJECT and redid old**
: **                              command RECEIVE to do that for  **
: **                              incoming calls.                 **
: ** 05.00 03/21/86 sdw           Say hello when enter cmd mode   **
: ** 05.00 03/21/86 sdw           remove seg protection SVCs and  **
: **                              just move the data to data seg  **
: ** 05.00 03/21/86 sdw           Port data is now in port table  **
: ** 05.00 03/17/86 sdw           PVC options are set upon enterin**
: **                              login mode.                     **
: ** 05.00 03/17/86 sdw           Calls are not newlogons.  This  **
: **                              used to mess up calls on PVC prt**
: ** 05.00 03/16/86 sdw           PAD no longer expects zap acks  **
: **                              to clear port.                  **
: ** 05.00 03/14/86 DLG           Chngd crash codes 13&14 to 92&93**
: ** 04.03 02/17/86 DLG           Removed unnecessary RX3 instr's **
: ** 04.03 01/28/86 sdw  n/a      Moved data definitions to DATA  **
: ** 04.02 01/07/86 DLG           Sup Accnting Msg for ciruit zap **
: ** 04.02 12/10/85 JH   PIR 1725 Add userid suffix               **
: ** 04.02 12/10/85 JH            Add proprietary banner          **
: **								  **
: ******************************************************************

	SUBTTL	(PAD) X.3/X.28/X.29 Related Functions

  IF	X3ON

	SUBTTL	(PAD) Terminal Profile Expansion

	SEG	A.CODE
	MO	.,DATA

	RA	0A

I	EQ	0
	RE	NX3PRO+1
PNS|I|	P|I|NAM		:EXPAND PROFILE NAME STRING WITH SC DIRECTIVE
I	EQ	I+1
	ER

:	The CCITT X.3 terminal parameter table is of the form:
:
X3.PRO	WS		:Begining of profile definition table, FW ALIGNMENT
X3.REC	BS	1	:X3.P1, PAD RECALL CHARACTER
X3.FWD	BS	1	:X3.P3, DATA FORWARDING SIGNAL
X3.IDL	BS	1	:X3.P4, IDLE TIMER
X3.SER	BS	1	:X3.P6, SERVICE SIGNAL CONTROL
X3.BRK	BS	1	:X3.P7, OPERATION ON BREAK
X3.LW	BS	1	:X3.P10, LINE WIDTH (LINE FOLDING)
X3.CRL	BS	1	:X3.P13, <LF> INSERTION AFTER <CR>
X3.CHD	BS	1	:X3.P16, CHARACTER DELETE CODE
X3.LDE	BS	1	:X3.P17, LINE DELETE CODE
X3.LDI	BS	1	:X3.P18, LINE RETYPE CODE
X3.BKC	HS	1	:X3.N3,  ASCII code for key to be treated as <BREAK>
X3.FLG	HS	1	:Those X.3 and Tymnet National parameters that can be
			:represented by a bit:
			:  bits stored are: 
			:0800 =	X3.P15, EDITING ENABLE
			:0400 =	X3.P12, FLOW CONTROL OF PAD (REVERSE X-ON)
			:0200 =	X3.P5, ANCILLARY DEVICE CONTROL (X-ON)
			:0100 =	X3.P2, ECHO ON
			:0002 =	X3.N2, <TAB> expansion with <SPACE>s
			:0001 =	X3.N1, echo <TAB>
X3.NAM	WS	1	:PROFILE NAME STRING POINTER

X3.SIZ	EQ	.-X3.PRO
	ORG	X3.PRO


I	EQ	0
	RE	NX3PRO+1
	WS			:full word alignment
  IF	P|I|F01-1
	BC	P|I|F01		:normal recall character
  ELSE	P|I|F01
	BC	$A16		:1=DLE stored as actual ASCII value
  ELSE
	BC	$A255		:0=off stored as FF (flag)
  EI
	BC	P|I|F03
	BC	P|I|F04
	BC	P|I|F06
	BC	P|I|F07
	BC	P|I|F10
	BC	P|I|F13
	BC	P|I|F16
	BC	P|I|F17
	BC	P|I|F18
	HC	P|I|N03		:profile value for break emulation
	BC	P|I|F15^3!P|I|F12^2!P|I|F05^1!P|I|F02
	BC	P|I|N02^1!P|I|N01
	WC	PNS|I|
I	EQ	I+1
	ER

	RA	0


	SEG	A.CODE

:	SERSIG(msg,pr,buf)	Output a PAD sevice signal message
:
:	msg = address of message text, if null, address already in (R6)
:	pr = PROMP if it is a prompt, else null
:	buf = TTBUF if output to to-terminal-buffer, else to echo buffer
:	input	RP,RPI
:	destroys R0, plus registers destroyed by OUTSTR

PROMP	EQ	1
TTBUF	EQ	1

SERSIG	MACRO(msg,pr,buf)[
	KILL	Q
Q	EQ	pr -1
  IF	msg -1
	LA	R6,`msg,,
  EI
	LB	R0,X3.P6,RPI
  IF	buf -1
	L	RBP,.TTBUF,RPI
  ELSE
	L	RBP,.ECOBF,RPI
  EI
  IF	Q
	THI	R0,X3.6P		:see if ok to send service signal
  ELSE
	THI	R0,X3.6NP		:see if ok to send prompt service sig
  EI
	JEFS	.+08
	JAL	R5,OUTSTR,,
]


	SUBTTL	(PAD) Constant Storage
:	Constant Storage
:	================

:	Terminal-Related Variables

EBSIZE	HS
Q	EQ	0
	RE	NPORT
	HC	EBSZ|Q|			:Edit buffer sizes
Q	EQ	Q+1
	ER

X3OPRO	BS
Q	EQ	0
	RE	NPORT
	BC	X3PR|Q|			:original terminal profile
Q	EQ	Q+1
	ER

COM.IN	BS
Q	EQ	0
	RE	NPORT
	BC	COM.|Q|			:Initial cmd state timer value (0=off)
Q	EQ	Q+1
	ER

MXA.IN	BS				:initialize maximum assembly timer
Q	EQ	0
	RE	NPORT
	BC	MXA.|Q|
Q	EQ	Q+1
	ER

	IF  CUD.MX
CUD.LG	BS	0		:CUD control byte *500.sdw
Q	EQ	0
	RE	NPORT
	BC	CUD.|Q|
Q	EQ	Q+1
	ER
	EI :CUD.MX

CUGS.F	BARRAY(.CUGS,NPORT)		:1 if port has subscribed to CUG
CUGI.F	BARRAY(.CUGI,NPORT)		:1 if port has incomming access
CUGO.F	BARRAY(.CUGO,NPORT)		:1 if port has outgoing access

:
:	Allocate each port with a byte storage
:	of preferential CUG index
:

CUP.PT	BS	0			:
Q	EQ	0
	RE	NPORT
	BC	CUGP|Q|
Q	EQ	Q+1
	ER

:
:	Generate a table with 99 entries for index 0 to 98.  Each entry
:	contains a bit array to define which port has used the associate
:	index.
:	Refer to macro CUGROUP.
:

CUI.PT	WS	0
	RA	0
QQ	EQ	(NPORT+1F)/20	:Get length of storage for each index
.DOB.(II,0,63)				:Max index is 99 decimal
  .DOB.(JJ,0,QQ)
	WC	.CU`|II|`|JJ|
  .DOE.1
.DOE.0

:
:	Generate a table with 99 entries for index 0 to 98.  Each entry  
:	contains a 1 word storage to store the associate interlock code
:	for that index
:

CUGTAB	WS	0
.DOB.(II,0,63)
	WC	.CAB`|II|
.DOE.0

:	X.3 to TYMNET and TYMNET to X.3 Mapping Tables

	RA	$0 0A

:	CCITT Binary Rate to CPS
XBRMAP	HC	10,10,30,120,60,7,15,180,20,10
	HC	5,120,240,480,960,1920,4800,5600,6400

:	30 times (sec/char) for TYMNET Baud Rate Code
TBRMAP	BC	3,2,1,1,1,0,1,2,3,3,0,0,0,1,1,1

:	TYMNET BAUD RATE CODE TO X.3 SPEED CODE TRANSLATION
:	REFERENCE: TYMNET CIRCUIT PROTOCOL  (CIRCUI.DOC)
:
:	TYMNET to CCITT Baud Rate. Use TYMNET value as an index to get
:	CCITT terminal baud rate equivalent

TY.CC	BC	0,6,2,255,4,3,255,1,2,3,12,13,14,10,5,5
TBRMAX	EQ	$A15
TBR.CC	BC	0		:  110 BPS, TYMNET 0 ==> X3.P11=0
	BC	6		:  150 BPS, TYMNET 1 ==> X3.P11=6
	BC	2		:  300 BPS, TYMNET 2 ==> X3.P11=2
	BC	0		:  400 BPS, TYMNET 3 ==> X3.P11=0 (INVALID)
	BC	0		:  600 BPS, TYMNET 4 ==> X3.P11=4 (INVALID)
	BC	3		: 1200 BPS, TYMNET 5 ==> X3.P11=3
	BC	2		:  300 BPS, TYMNET 6 ==> X3.P11=2 (SPECIAL)
	BC	1		:    134.5, TYMNET 7 ==> X3.P11=1
	BC	0		:  300 BPS, TYMNET 8 ==> X3.P11=0 (INVALID)
	BC	0		: 1200 BPS, TYMNET 9 ==> X3.P11=0 (INVALID)
	BC	12		: 2400 BPS, TYMNET A ==> X3.P11=12
	BC	13		: 4800 BPS, TYMNET B ==> X3.P11=13
	BC	14		: 9600 BPS, TYMNET C ==> X3.P11=14
	BC	10		:   50 BPS, TYMNET D ==> X3.P11=10 (BAUDOT)
	BC	5		:   75 BPS, TYMNET E ==> X3.P11=5  (BAUDOT)
	BC	11		:  75/1200, TYMNET F ==> X3.P11=11 (V-TEXT)

00

:	CCITT to TYMNET Baud Rate. Use CCITT value as index to get TYMNET
:	terminal baud rate equivalent
CC.TY	BC	0,7,2,5,4,0,1,5,1,0,0,5,0A,0B,0C,0C,0C,0C,0C
CBRMAX	EQ	$A18


:	CCITT throughput class to TYMNET Gouging Level Mapping
CTCTOG	BC	81,81,81,81,81,81,81,82,83,83,84,84,84,84,84,84

:	TYMNET NID to CCITT Throughput Class Mapping (5 bit TID)
NIDTCL	BC	9,5,5,5,5,4,4,4,5,4,4,7,7,7,9,9
	BC	9,9,0,9,0B,0,0,7,0,0,0,0,0,0,0,0

:	TYMNET Gouging Level to CCITT Throughput Class Mapping
GLEVTC	BC	0,6,7,9,0B		:^A=6, ^B=7,^C=9,^D=11


:	Dtat forwarding transmit masks
:	Indexed by character, the masks indicate what value X3.P4 must
:	have in order for the character to be a data forwarding condition
:FOLLOWING IS A TABLE USED TO DETERMINE IF A CHARACTER INPUT FROM
:A HOST OR TERMINAL IS A PACKET TRANSMISSION CHARACTER.
:THE 7 BIT ASCII CHAR IS USED AS AN INDEX INTO THE TABLE. THE BYTE
:FOR EACH CHAR HAS THE BIT SET IN IT THAT CORRESPONDS TO THE ENABLE BIT
:IN THE TRANSMIT MASK.	THIS BYTE IS ANDED WITH THE TRANSMIT MASK
:SET ON THE LOGICAL CHANNEL AND IF THE RESULT IS NON ZERO THE
:CHARACTER IS AN ACCEPTABLE TERMINATOR AND THE PACKET IS FINISHED.
:

:		 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
XMTASC	BC	40,40,40,10,10,04,04,04,40,20,20,20,20,02,40,40
	BC	40,40,08,40,40,40,40,40,08,40,40,04,40,40,40,40
	BC	80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80
	BC	01,01,01,01,01,01,01,01,01,01,80,80,80,80,80,80
	BC	80,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01
	BC	01,01,01,01,01,01,01,01,01,01,01,80,80,80,80,80
	BC	80,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01
	BC	01,01,01,01,01,01,01,01,01,01,01,80,80,80,80,08




:	Special Classes of characters

ALPNUM	WC	0
	WC	0000FFC0	:0-9
	WC	7FFFFFE0	:A-Z
	WC	7FFFFFE0	:a-z

LETIGR	WC	00200000	:chars to ignore if before command *500.sdw
	WC	80000000	:LF & SP
			:first two words of LETTER always 0 so use em
LETTER	WC	0
	WC	0
	WC	7FFFFFE0	: A-Z
	WC	7FFFFFE0	: a-z

DELIM	WC	00040000	: <CR>
	WC	00100000	: "+"
	WC	0
	WC	0

CALLCM	WC	0C3C1CCCC	: "CALL"
	WC	0C3C1CC		: "CAL"
	WC	0C3C1		: "CA"
	WC	0C3		: "C"

ASDIG	WC	0
	WC	0000FFC0	: 0-9
	WC	0
LDELIM	WC	0		:end of ASDIG and start of LDELIM
	WC	000E0018		:, . - ; :  
				:and use UASHEX's 2 words as our end

UASHEX	WC	0
	WC	0
	WC	07E000000	: A - F, HEX DIGITS 
	WC	0

LASHEX	WC	0
	WC	0
	WC	0
	WC	07E000000	: LOWER CASE A - F, HEX DIGITS 

:	Characters to ignore after escape from data transfer(not incl. delimiters)
CIGNOR	WC	0FFFFFFFF		:all columns 0 and 1
	WC	0
	WC	0
	WC	1			:...and 7/15(DEL)

:	Fake PAR?0:0,4,8,9,10,12 for CR Delay command
CRDSTR	SC	/"30"3A"30"2C"38"2C"39"2C"31"30"2C"31"31"2C"31"32/



:	Create table of BCD host numbers to be used as calling addresses
CHOST	WS	0
Q	EQ	0
	RE	NPORT
	 IF	\.ACH|Q|
Q1	EQ	.ACH|Q|
	 ELSE
Q1	EQ	.AHOST
	 EI	:\.ACH|Q|
Q6	EQ	Q1/$A100000
Q1	EQ	Q1-Q6*$A100000
Q5	EQ	Q1/$A10000
Q1	EQ	Q1-Q5*$A10000
Q4	EQ	Q1/$A1000
Q1	EQ	Q1-Q4*$A1000
Q3	EQ	Q1/$A100
Q1	EQ	Q1-Q3*$A100
Q2	EQ	Q1/$A10
Q1	EQ	Q1-Q2*$A10
	WC	$AQ6^20!Q5^16!Q4^12!Q3^8!Q2^4!Q1
Q	EQ	Q+1
	ER
OURDNI	HC	ODN.00


:	Enhanced Function Arrays
:  moved to SEG A.code since tymfile parameters should never changed *500.sdw
LGMODE	BARRAY(.LGMD,NPORT)		:1 if port can enter login mode
CMMODE	BARRAY(.CMMD,NPORT)		:1 if port can enter command mode
IPMODE	BARRAY(.IPMD,NPORT)		:1 if port initially in command mode
					:0 if login mode (unless *TIMODE*=1)
PADTYP	BARRAY(.PTYP,NPORT)		:1 if can use Extended TYMNET commands
ICAON	BARRAY(.ICO,NPORT)		:1 if port currently allows inc calls




	SUBTTL	(PAD) Symbols
:	Define symbols for enhanced functions
:	=====================================


:	Interface States
:X3LOG	EQ	0			:Login
X3CIP	EQ	1			:Connection in progress
X3SER	EQ	2			:Service signals
X3PAW	EQ	3			:PAD Waiting
X3GAT	EQ	4			:talking to a gateway *500.sdw
:X3WFC	EQ	5			:Waiting for Command*500.sdw-obsoleted
X3DAT	EQ	6			:Data Transfer
X3WCL	EQ	7			:Wait for clear confirmation
:X3WTR	EQ	8		:Waiting to receive a call*obsoleted.sdw


:	Mneumonics
BS	EQ	08
CR	EQ	0D
LF	EQ	0A
DLE	EQ	10
SP	EQ	20
STAR	EQ	2A
COMMA	EQ	2C
DASH	EQ	2D
DOT	EQ	2E
ZERO	EQ	30			:ASCII 0
NINE	EQ	39			:ASCII 9
COLON	EQ	3A
SEMIC	EQ	3B
EQUALS	EQ	3D			:"="
SUDNIC	EQ	47			:prefix for DNIC in username
SURPOA	EQ	54			:prefix for RPOA in username
BEEP	EQ	87
FEFFEC	EQ	8A8D
SWON	EQ	4F4E			:ASCII "ON "
SWOFF	EQ	4F4646			:ASCII "OFF "
FL.P15	EQ	800			:bit position in X3.FLG for X.3 parm 15
FL.P12	EQ	400			:bit position in X3.FLG for X.3 parm 12
FL.P05	EQ	200			:bit position in X3.FLG for X.3 parm 5
FL.P02	EQ	100			:bit position in X3.FLG for X.3 parm 2
FL.N01	EQ	1			:bit position in X3.FLG for Natl parm 1
FL.N02	EQ	2			:bit position in X3.FLG for Natl parm 2

:	X.3 Parameter Bit Masks and Values
:	Recall limits
X3.1MN	EQ	$A32		:min for CCITT mode (excl. off and DLE)
X3.1MX	EQ	$A126


:	Service signal masks
X3.6NP	EQ	1
X3.6P	EQ	4

:Bits of Break action byte
X3.7I	EQ	1		:Interrupt
X3.7R	EQ	2		:Reset
X3.7B	EQ	4		:Indication of break
X3.7E	EQ	8		:Escape from data transfer state
X3.7D	EQ	10		:Discard output
s
:	CR Padding limit
X3.9MX	EQ	7

:Bits of linefeed insertion byte
X3.13E	EQ	4		:Insert LF after CR on echo
X3.13F	EQ	2		:Insert LF after CR in data from terminal
X3.13T	EQ	1		:Insert LF after CR in data from terinal

: Maximum values of parameters
PA.MAX	EQ	$A15		:Parameter A
PB.MAX	EQ	$A15
PC.MAX	EQ	$A15
PD.MAX	EQ	$A15

:	Break Signal Masks
BB.NOT	EQ	0
BB.INT	EQ	1			:Interrupt
BB.RES	EQ	2
BB.IND	EQ	4
BB.ESC	EQ	8
BB.DIS	EQ	10

:	Packetizer related symbols.
QBIT	EQ	80			:Q-bit in data packet
MBIT	EQ	01			:M-bit in data packet
OURLEV	EQ	1			:turkey level number we are talking
:	XCOM dialect message types
EXM4	EQ	084		:CLEAR CAUSE (LEVEL 0)
EXM5	EQ	085		:SHORT CALL CONNECT (LEVEL 0)
EXM6	EQ	086		:RESET CAUSE (LEVEL 0)
EXM7	EQ	087		:CALLED PARTY ADDRESS
EXM8	EQ	088		:CALLING PARTY ADDRESS
EXM9	EQ	089		:CALL USER DATA, FIRST BYTE AFTER 89 IS SIZE
EXMA	EQ	08A		:SEND AN INTERRUPT PACKET
EXMB	EQ	08B		:SEND AN INTERRUPT CONFIRMATION
EXMC	EQ	08C		:NETWORK UTILITY FIELD
EXMD	EQ	08D		:USER FACILITY FIELD
EXME	EQ	08E		:CLEAR DIAGNOSTIC (LEVEL 0)
EXMF	EQ	08F		:CALL CONNECT (LEVEL 0)
EXM10	EQ	090		:RESET DIAGNOSTIC
EXM11	EQ	091		:RESET CONFIRMATION
EXM12	EQ	092		:EXTENTED CALL ACCEPTED PACKET INFO
EXM13	EQ	093		:TURKEY LEVEL NUMBER
EXM14	EQ	094		:ESCAPED DATA MESSAGE
:				(1 FLAG BYTE,2 BYTES OF LENGTH, FOLLOWS)
EXM15	EQ	095		:ESCAPED CLEAR REQUEST
:				(CAUSE BYTE, DIAGNOSTIC BYTE FOLLOWS)
EXM16	EQ	096		:ESCAPED RESET INDICATION
:				(CAUSE BYTE, DIAGNOSTIC BYTE FOLLOWS)
EXM17	EQ	097		:ESCAPED CLEAR INFORMATION
:				(2/LEN, CLEAR INFO FOLLOWS)
EXM18	EQ	098		:ESCAPED RPOA FIELD
:				(2/LEN, RPOA OF 4-BCD DIGITS IN TWO BYTES)

::	IIX MESSAGE TYPES
IX.CIQ	EQ	1	:CIRCUIT'S IQ (FROM CM.NCC MESSAGE)
IX.HIQ	EQ	8000	:HOST IQ POSITION
IX.SDC	EQ	8080	:SELECT DIALECT COMMAND
IX.SDR	EQ	8081	:SELECT DIALECT RESPONSE
IX.GSH	EQ	8082	:GATEWAY TO SMART HOST
IX.GDH	EQ	8083	:GATEWAY TO DUMB HOST
IX.DMM	EQ	0C080	:DIALECT MESSAGE MASK

:	IIX DIALECT CODES
ID.ASC	EQ	8081	:ASCII DATA ONLY
ID.XGT	EQ	8082	:GATEWAY INTERFACE
ID.XCM	EQ	8083	:X25/X75 COMMUNICATIONS INTERFACE
ID.DSP	EQ	8084	:DSP

:	Accounting messages.
AA.OIP	EQ	0E1000000		:origination input packet count
AA.OOP	EQ	0E2000000		:origination output packet count
AA.OIS	EQ	0E3000000		:origination input segment count
AA.OOS	EQ	0E4000000		:origination output segment count
AA.CTM	EQ	0E0000000		:circuit termination msg. :DLG 7-Jan-86
AA.COP	EQ	0E0090000		:circuit originating (physical port no.
AA.MPC	EQ	0E0100000		:multiplexed PVC port count
AA.MPT	EQ	0E0110000		:multiplexed PVC session time

::	TURMSG(type,cause,diag)OUTPUT TURKEY CLEAR OR RESET MSG TO THE NETWORK
:
:		FOR TURLEV=0, USE	(EXM6,EXM10) FOR RESET
:					(EXM4,EXME) FOR CLEAR
:		FOR TURLEV>0, USE	(EXM16) FOR RESET
:					(EXM15) FOR CLEAR
:	INPUT	type= "RESET" OR "CLEAR", IF NULL, ASSUMES "CLEAR"
:		cause= CAUSE BYTE, IF NULL, USE (PSDIAG)
:		diag= DIAGNOSTIC BYTE, IF NULL, USE (PSDIAG+1)
:		(RP)= PORT INDEX
:
:	USES	ALL BUT R5,R6,R8
:	CALLS	BEGDIA

RESET	EQ	0
CLEAR	EQ	1

TURMSG	MACRO(type,cause,diag)[
	KILL	QD,QC,QQ1,QQ2,QQ3,QQ4
QC	EQ	cause -2
QD	EQ	diag -2
QQ	EQ	type 1

	LB	R2,TURLEV,RPI
	JN	QQ3		:if turkey level > 0
  IF	QQ
	LHI	R6,EXM4
  ELSE
	LHI	R6,EXM6
  EI
	JAL	R9,BEGDIA,,
  IF	QC+2
	LHI	RBC,cause
  ELSE
	LB	RBC,PSDIAG,RPI	:get cause byte from cell
  EI
	JAL	RCH,PUTCHR,,
  IF	QQ
	LHI	R6,EXME
  ELSE
	LHI	R6,EXM10
  EI
	JAL	R9,BEGDIA,,
  IF	QD+2
	LHI	RBC,diag
  ELSE
	LB	RBC,PSDIAG+1,RPI	:get diagnostic byte from cell
  EI
	JAL	RCH,PUTCHR,,
	J	QQ4

QQ3	HS
  IF	QQ
	LHI	R6,EXM15
  ELSE
	LHI	R6,EXM16
  EI
	JAL	R9,BEGDIA,,
  IF	QC+2
	LHI	RBC,cause
  ELSE
	LB	RBC,PSDIAG,RPI		:get cause byte from cell
  EI
	JAL	RCH,PUTCHR,,
  IF	QD+2
	LHI	RBC,diag
  ELSE
	LB	RBC,PSDIAG+1,RPI		:get diagnostic from cell
  EI
	JAL	RCH,PUTCHR,,
QQ4	HS
]


	SUBTTL	(PAD) Initialization -- Startup and per call

	SEG	A.CODE

	MO	.,X3PAD

	LO	DATA

:	Initialization
:	==============

:	Port Answered
:	Called BY *AHNGAN* when port 1st answered
:	Link on R9
IZ.X3	LIS	R0,0
	STB	R0,NRENTR,RPI		:# times command state re-entered
	LA	R3,DTECLG,RPI
	JAL	RCH,DEFADR		:set up calling address of port
	J	CLRCAL			:reset per call parameters...and exit



:	X.3 Terminal Parameter and PAD Filter Initialization
:	Called when PAD terminal parameters are being set-up (as AVID)
:	Linked on RBF
:	Destroys R0-3,R6,RCH

:	initialization arrays
IXPROF	RBT	RP,PADARY		:assume vanilla consat port
	SBT	RP,ICAAU		:accept incoming calls
	TS	X3.N3,RPI		:initialize break key value
	TBT	RP,ASCII		:PAD port must be ASCII port
	JE	IXPRLG			:not ASCII, let consat handle port
	TBT	RP,HAFDUX		:PAD port must be full duplex port
	JN	IXPRLG			:half duplex, let consat handle port
	CLHI	RP,.SPORT		:PAD port must be async port
	JGE	IXPRLG			:SIO, let consat handle port
	CLHI	RP,.MPORT		:PAD port must be async port
	JGE	IXPRLG			:MPVC, let consat handle port
	TBT	RP,CMMODE,,		:PAD capable?
	JE	IXPRLG			:no, always in CONSAT login mode, exit
	SBT	RP,PADARY		:indicate port using PAD functions 
	LIS	R1,0			:prepare to init chr byte cnt
	STH	R1,P.BCT,RPI		:init chr byte cnt to zero  *6.02 dlg
	RBT	RP,ICAAU		:disable incomingcalls *500.sdw
	TBT	RP,ICAON		:can port currently accept inc calls
	JEFS	IXPR10			:no, 
	SBT	RP,ICAAU		:yes, enable incomingcalls

IXPR10	TBT	RP,IPMODE               :is port initially in command mode?
	JN	IXPRCD			:yes, set up terminal parameters
					:for PAD's command mode

:	Set terminal up for CONSAT login mode
:	returns on R8 = RBF
:	initialize break emulation key - only PAD parameter that applies
	LB	R1,X3OPRO,RP		:get default terminal profile no.
	LHI	R6,X3.SIZ		:get table entry size
	MHR	R6,R1			:calculate displacement into table	
	LH	R1,X3.BKC,R6		:get break value from default profile
	JEFS	IXPRLG			:break emulation disabled
	STH	R1,X3.N3,RPI		:store break value for this port

:	port initialization for login mode - is also called from CMDLOG
:	when port is transfering from command to login mode.
IXPRLG	RBT	RP,PADACT		:port is no longer in command mode
	SBT	RP,PNMODE		:pseudoneedle desired   

:	remove PAD filters
	LIS	R1,0			:zero R1 used to remove PAD filters
	ST	R1,.ESIGF,RPI		:remove PAD input signal filter 
	ST	R1,.ECHRF,RPI		:remove PAD input character filter 
	ST	R1,.XPADFI,RPI		:remove PAD transmit filter 

:	replace echo buffer with .TTBUF
	L	R1,.TTBUF,RPI		:get .TTBUF pointer and save
	ST	R1,.TPBUF,RPI		:as echo buffer pointer
	JR	RBF			:return

:	Set up PAD's default terminal parameter profile
:	port is initially in PAD command mode
IXPRCD	SBT	RP,PADACT		:indicate port in command mode   
	RBT	RP,PNMODE		:and no pseudoneedle desired(yet)   

:	set PAD terminal paramters and profile
	LB	R1,X3OPRO,RP		:get original terminal profile no.
	STB	R1,X3CPRO,RPI		:store in port table
	JAL	R9,INITX3		:use set routine to set par*500.sdw

:	store PAD filters in port table
	LA	R1,EASCID               :yes, get EASCID address, and save
	ST	R1,.ECHRF,RPI		:as input character filter pointer
	LA	R1,EASCIS               :get EASCIS address, and save
	ST	R1,.ESIGF,RPI		:as input signal filter pointer
	LA	R1,XPADFI 		:get XPADFI address, and save
	ST	R1,.XPADF,RPI		:as transmit filter pointer

:	replace echo buffer pointer with .ECOBF
	L	R1,.ECOBF,RPI		:get .ECOBF pointer and save
	ST	R1,.TPBUF,RPI		:as echo buffer pointer

:	initialize PAD's echoable character table in port table
	LR	R1,R12			:preserve RPI, use R1 as index reg
	STM	R12,TEMPA		:save registers 12-15
	LM	R12,PPABL,,		:get PAD-ASCII echoable char set
	STM	R12,.ECHT1,R1		:place 1st 1/2 (0-127) in port table
	STM	R12,.ECHT2,R1		:place 2nd 1/2 (127-255) in port table
	LM	R12,TEMPA		:restore registers 12-15

	LIS	RBC,X3PAW		:initially in PAD waiting state
	STB	RBC,X3STAT,RPI		:store state in port table 
	JR	RBF			:return


:	Initialization when port 1st established (but no psn requested)
:	Called by *ESTPRT*
:	Exits thru *CIRBLT*
IX3PRT	RBT	RP,CALCMD		:no call setup in progress
	RBT	RP,CALPRG		:no call in progress
	RBT	RP,IIXCAL		:...and not conn to packet mode int
	RBT	RP,PIIX			:
	RBT	RP,XTGATE		:
	RBT	RP,GATCAL		:
	RBT	RP,TURKEY		:
	RBT	RP,XASCII		:
	RBT	RP,DPLOGN		:
	RBT	RP,LOCDEM		:
	LIS	R0,0			:
	STH	R0,PSDIAG,RPI		:clear cause/diagnostic
	ST	R0,POCNT,RPI		:clear accounting counts
	ST	R0,PICNT,RPI		:
	ST	R0,SICNT,RPI		:
	ST	R0,SOCNT,RPI		:
	STB	R0,DTECLD,RPI		:
	TBT	RP,HAFDUX		:
	JNFS	IX3PR4			:if port echoing locally...don't echo
	TBT	RP,X3.P2		:
	JEFS	IX3PR4			:if no echo wanted by port
	SBT	RP,ECHO			:
IX3PR4	LIS	R0,X3PAW		:put port in waiting state
	STB	R0,X3STAT,RPI		:store state in port table
	LB	R0,COM.IN,RP		:PAD timer for no calls
	JEFS	IX3PR6			:
	STB	R0,COM.CU,RPI		:
	SBT	RP,COMTO		:
IX3PR6	LIS	RBP,0			:prepare to initialize chr byte cnt
	STH	RBP,P.BCT,RPI		:init chr byte cnt to zero *6.02 dlg
	L	RBP,.FEDBF,RPI		:
	JAL	RCH,EMPTY		:empty editing buffer
	L	RBP,.FTBUF,RPI		:
	MAKEBF(R1,TOISIS,RP)		:connect from-terminal buffer to ISIS
	JAL	R3,CHNGBF,,		:
	J	CIRBLT,,		:send prompt to port




:	General PAD-Related Subroutines
:	===============================

:	XPADSV	- Save current transmit filter in .XPADS
:	XPADST	- Restore saved PAD transmit filter
:		R0 becomes new transmit filter in either case
:		Link on RCH
XPADSV	L	R1,.XPADF,RPI		:
	ST	R1,.XPADS,RPI		:

XPADST	ST	R0,.XPADF,RPI		:
	JR	RCH			:


  IF	NPAPRT
::	XINCAL	- Incoming call preprocessor (make sure port can receive call)
:	 Link on R9 (to cancel) or 4,R9 (if OK)
:		 XPTEMP= char for ACK to caller
:		 ORIGH= orig host number
:	 Destroys R0-7,TEMP1
:	 Calls	 DEFADR, GETBCD, OUTBCD, PUTCHR, OUTSTR

XINCAL                  :accept logic moved to earlier needle logic *500.sdw
	L	R0,ORIGH		:get origination host #
	ST	R0,XORIGH,RPI		:store in port table
	LB	R0,XPTEMP		:get char for ACK to caller
	STB	R0,XICACK,RPI		:store in port table
	SBT	RP,EXTCAL		:indicate call came from elsewhere
	SBT	RP,ICAPND		:indicate trying to hook up call
	LB	R0,XPTEMP+1		:IIX flag
	JE	XICA20			:if dumb caller...try to connect

:	Smart caller...just send IIX messages
:
:	If the port is in login mode and receives an incoming call from
:	a smart host, it is switched to command mode by LOGCMD to replace
:	PAD filters.
	ST	R9,XICSAV,RPI		:save return address
	TBT	RP,PADACT		:is port in command mode?
	JNFS	XICA10			:yes, 
	JAL	RLINK,LOGCMD,,		:no, switch port to command mode
XICA10	SBT	RP,IIXCAL		:else indicate smart caller
	JAL	R9,IG.SDI		:send select dialect command
	L	R9,XICSAV,RPI		:restore link register
	JR	R9			:return
  EI	:NPAPRT


:	Dumb Host is calling...connect up
:	called from XINCAL and from GIR.10 when port receives call from
:	a dumb host.
XICA20	ST	R9,XICSAV,RPI		:save return addres
	LIS	R0,X3DAT		:set interface in data state
	STB	R0,X3STAT,RPI		:save interface state in port table
  IF	NPAPRT
	RBT	RP,LIMBO		:take port out of limbo
  EI	:NPAPRT
	RBT	RP,ICAPND		:call no longer pending
	SBT	RP,CALPRG		:but in progress
	SERSIG(SS.INC)			:announce incoming call
	LA	R3,DTECLD,RPI
	JAL	RCH,DEFADR		:set up called address (this port)
	L	R0,XORIGH,RPI		:orig host #
	JAL	R9,GETBCD		:convert to BCD
	EXHR	R1,R2			:R2=BCD host #, R1=5th digit of #
	LBR	R1,R1			:
	OHI	R1,70			:
	STB	R1,DTECLG+3,RPI		:clgadr= "7" + 
	STH	R2,DTECLG+4,RPI		:other 4 digits of host #
	L	RBP,.TTBUF,RPI		:get to-terminal buffer pointer
	JAL	R9,OUTBCD		:announce calling address
	LHI	RBC,SP			:space
	JAL	RCH,PUTCHR		:send space
	SERSIG(SS.COM)			:then rest of message
	LA	R6,SS.FEF,,		:get address of message
	JAL	R5,OUTSTR,,		:send message
        LHL     R6,HSTMSG,RPI           :address of host message (send to orig)
        AI      R6,BASE
        L       RBP,.FTBUF,RPI          :not to term but to originator
        JAL     R9,MSG,,
	L	RBP,.TTBUF,RPI		:get to-terminal buffer pointer
	LB	RBC,XICACK,RPI		:get character for ACK to caller
	JAL	RCH,PUTCHR		:send ACK to caller       
	L	R9,XICSAV,RPI		:restore return address
	JR	R9			:return



:	Convert a binary number to an ASCII decimal string
:		and store in R6 in reverse order
:	Input R2 - number to be converted (binary)
:		 - Maximum Value= 9999 decimal
:	Output R6 - ASCII digits (up to 4)
:	DESTROYS R0-2,R6
:	Link on R7

CBAASC	AC/0123456789ABCDEF/

XCBA	LIS	R0,0A
	LIS	R6,0
XCBA10	LIS	R1,0
	DR	R1,R0
	LB	R1,CBAASC,R1
	SLLS	R6,8
	OR	R6,R1
	LR	R2,R2
	JGBS	XCBA10
	JR	RCH


::	CBA	CONVERT BINARY TO ASCII
:
:	ASCII NUMBER WILL BE OUTPUT IN REQUESTED RADIX RIGHT
:	JUSTIFIED WITH BLANK FILL IN A GIVEN FIELD IN MEMORY.
:
:	ENTRY	R0	RADIX (2 TO 10 HEX)
:		R1	ADDRESS TO DEPOSIT STRING
:		R3	BINARY #
:		R4	SIZE OF FIELD IN CHARACTERS
:		R5	LINK
:
:	DESTROYS R2,3,4

CBA	HS
CBA010	LIS	R2,0		:CLEAR UPPER HALF
	DR	R2,R0		:DIVIDE BY RADIX
	LB	R2,CBAASC,R2	:CONVERT TO ASCII
CBA020	STB	R2,-1,R1,R4	:SAVE CHARACTER
	SIS	R4,1		:COUNT CHARACTER IN STRING
	JLER	R5		:IF FIELD FULL
	LR	R3,R3
	JGBS	CBA010		:IF NUMBER NOT FULLY PROCESSED
	LHI	R2,0A0		:BLANK
	JBS	CBA020		:GO BLANK FILL


::	GETBCD IS USED TO CONVERT A BINARY NUMBER TO A
:	BINARY CODED DECIMAL NUMBER FOUR BITS PER DIGIT.
:
:R0=DATA TO CONVERT.
:R9 IS RETURN ADDRESS
:R2 HAS CONVERYTED NUMBER ON RETURN
:
GETBCD	LIS	R4,0
	LIS	R2,0
	LIS	R3,0A
BCD010	DHR	R0,R3
	SLL	R0,0,R4
	OR	R2,R0
	AIS	R4,4
	LR	R0,R1
	JGBS	BCD010
	JR	R9



	SUBTTL	(PAD) Timers


:	PAD Timers
:	==========

:	Idle Timer Logic
:	Runs every 4/20ths of a second
:	Checks idle timer (set by X.3 parameter 4) 
:	and forwards packet if timer expired

IDLETM	LHI	RPOL,(NGRP-1)*2		:
IDLE10	LCS	R1,1			:
	XH	R1,X3.P15,RPOL		:ports that cannot edit...
	NH	R1,IDLETO,RPOL		:and have their idle timers on
	STH	R1,TEMP			:
IDLE20	LHL	R1,TEMP			:
	JFFOH	R1,IDLE30		:find port that needs service
	SIS	RPOL,2			:done with this port group
	JGEBS	IDLE10			:so process next port group
	J	EXDISM			:

IDLE30	RBT	R2,TEMP			:indicate servicing
	LR	RP,RPOL			:get table offset (in bytes)
	SLLS	RP,3			:convert to bit offset
	AR	RP,R2			:get port number
	LR	RP2,RP			:
	AR	RP2,RP2			:and get port number*2
        LHL     RPI,.PTP.,RP,RP         :table pointer*500.sdw
	LB	R0,IDL.CU,RPI		:current timer value (in 1/20ths)
	SIS	R0,4
	JLEFS	IDLE40			:timer expired?
	STB	R0,IDL.CU,RPI		:no, update timer
	J	IDLE20			:go find next port

IDLE40	TBT	RP,SENDON		:is network backpressuring?
	JE	IDLE20			:yes, go find next port
	RBT	RP,IDLETO		:no, turn off timer
	JAL	RCH,EDSFWD		:and forward data
	J	IDLE20			:and then go find next port


:	One Minute Timers
:	Service for Maximum Assembly, and Command State
:	(with no calls in progress) Timers
:
:	Maximum assembly timer forwards the edit buffer(subject to flow 
:	 control) after MXA.IN minutes
:	Command state timner hangs a user who has no calls in progress
:	 after COM.IN minutes


:	Check max assembly timer
T1MIN	LHI	RPOL,(NGRP-1)*2		:
T1M010	LH	R1,MXATO,RPOL		:get max assembly timer bits
	STH	R1,TEMP			:
T1M020	LHL	R1,TEMP			:
	JFFOH	R1,T1M030		:find port that needs service
	SIS	RPOL,2			:done with this port group
	JGEBS	T1M010			:so process next port group
	J	T1M100			:

T1M030	RBT	R2,TEMP			:indicate servicing
	LR	RP,RPOL			:get table offset (in bytes)
	SLLS	RP,3			:convert to bit offset
	AR	RP,R2			:calculate port number
	LR	RP2,RP			:
	AR	RP2,RP2			:and get port number*2
        LHL     RPI,.PTP.,RP,RP         :table pointer*500.sdw
	LB	R0,MXA.CU,RPI		:current timer value 
	SIS	R0,1			:
	JLEFS	T1M040			:timer expired?
	STB	R0,MXA.CU,RPI		:no, update timer
	J	T1M020			:and go find next port

T1M040	TBT	RP,SENDON		:is network backpressuring?
	JE	T1M020			:yes, go find next port
	RBT	RP,MXATO		:no, turn off timer
	JAL	RCH,EDSFWD		:and forward data
	J	T1M020			:and then go find next port

:	Command State Timer
T1M100	LHI	RPOL,(NGRP-1)*2		:
T1M110	LH	R1,COMTO,RPOL		:get command timer bits
	STH	R1,TEMP			:
T1M120	LHL	R1,TEMP			:
	JFFOH	R1,T1M130		:find port that needs service
	SIS	RPOL,2			:done with this port group
	JGEBS	T1M110			:so process next port group
	J	EXDISM			:

T1M130	RBT	R2,TEMP			:indicate servicing
	LR	RP,RPOL			:get table offset (in bytes)
	SLLS	RP,3			:convert to bit offset
	AR	RP,R2			:calculate port number
	LR	RP2,RP			:
	AR	RP2,RP2			:and get port number*2
        LHL     RPI,.PTP.,RP,RP         :table pointer*500.sdw
	LB	R0,COM.CU,RPI		:current timer value 
	SIS	R0,1			:
	JLEFS	T1M140			:timer expired?
	STB	R0,COM.CU,RPI		:no, update timer
	J	T1M120			:and find next port

T1M140	RBT	RP,COMTO		:handle timeout
	L	RBP,.ECOBF,RPI		:get echo buffer pointer
	LB	R0,X3.P6,RPI		:get prompt parameter
	THI	R0,X3.6NP		:
	JEFS	T1M150			:send prompt?
	LA	R6,SS.E30,,		:yes,
	JAL	R5,OUTSTR,,		:go output string
T1M150	L	RBP,.TTBUF,RPI		:get to-terminal buffer pointer
	 LO	SIGNAL			:
	LIS	R4,HNGSIG		:
	 FO	SIGNAL			:
	JAL	RCH,PUTSIG		:and send hang signal
	J	T1M120			:then go find next port


	SUBTTL	(PAD) Signal Editor
:	Editor - Lookup Processor for Signals in All States
:	===================================================
:	===================================================
:	Possible Signals : <Break>, <Enter DEM>, <Red Ball>
EASCIS	LB	R3,X3STAT,RPI                                      
	LHL	R3,ESTABL,R3,R3
	JER	RCH			:if no edit processor for this state
	ST	RCH,EDSAVE
	ST	RBP,EDSAVE+4
	ST	R9,EDSAVE+8
	J	BASE,R3,

:	State Lookup Table for Processing Signals
ESTABL	HC	0
	HC	ESCIP-BASE		:connection in progress
	HC	0			:service signals
	HC	ESCMD-BASE		:PAD Waiting
	HC	ESGAT-BASE		:talking to a gateway *500.sdw
	HC	ESCMD-BASE		:Waiting for Command
	HC	ESDAT-BASE		:Data Transfer
	HC	0			:Wait for clear confirmation
	HC	0			:waiting to receive *obsoleted.500.sdw




:	Signal Editor - Connection in Progress State
:	============================================
ESCIP	 LO	SIGNAL
	CLHI	R4,BBSIG		:
	 FO	SIGNAL
	JN	PUTSIG			:if not a BREAK...pass it on
	LIS	R0,0			:
	ST	R0,.LSTAT,RPI		:remove PAD login status handler
	J	CCCLR4			:...and clear call


:       Signal Editor for talking to gateways  *500.sdw
ESGAT   LO      SIGNAL
        CLHI    R4,BBSIG		:
        FO      SIGNAL
        JN      PUTSIG			:
        LB      R8,X3.P7,RPI		:could enter command mode on break
        THI     R8,BB.ESC       	:is it requested?
        JN      EDDESC          	:to command mode
        J       PUTSIG          	:if not command then pass it

:	Signal Editor - Command State
:	=============================
ESCMD	 LO	SIGNAL
	CLHI	R4,EDMSIG		:
	JEFS	EDCMD2			:if enter DEM...process it
	CLHI	R4,BBSIG		:
	JER	RCH			:if BREAK...eat it
	TBT	RP,CALPRG		:
	JER	RCH			:if no calls...eat it
	J	PUTSIG			:  else exit via putsig
	 FO	SIGNAL
EDCMD2	RBT	RP,DEM			:
	SBT	RP,ECHO			:
	SBT	RP,LOCDEM		:tell editor to echo this char
	JR	RCH			:...(on next editor call)



:	Signal Editor - Waiting for Command State
:	=========================================
:ESWFC	 LO	SIGNAL
:	CLHI	R4,BBSIG
:	 FO	SIGNAL
:	JER	RCH			:if BREAK...eat it
:	JN	PUTSIG			:  else pass it on


:	Signal Editor - Data Transfer State
:	===================================
ESDAT	LO	SIGNAL
	CLHI	R4,BBSIG		:
	FO	SIGNAL
	JN	ESDA20			:if not a break
:	Process Break Signal

:	X3.P7 values are:
:	 0 - Nothing
:	 1 - Interrupt packet
:	 2 - Reset packet
:	 4 - Indication of Break
:	 8 - Escape from data transfer
:	 16- Discard output
:	 21- and other possible combinations

:	Supported values are:
:	 Non-packet mode - 0,2,4,8
:	 Packet Mode - 0,1,2,8,10, and comblinations

	LB	R0,X3.P7,RPI		:
	JER	RCH			:if doing "nothing"
	JAL	RCH,EDSFWD		:break is data forwarding condition
	LB	R8,X3.P7,RPI		:
	TBT	RP,TURKEY		:
	JN	EBRK60			:if packet mode operation

:	Break Handling - Non-packet Mode
	THI	R8,BB.ESC		:Escape from data transfer mask
	JN	EDDESC			:if break interpreted as escape
	THI	R8,BB.RES		:Reset mask
	JE	EBRK10			:if no reset wanted
:	...Reset
	L	RBP,.ECOBF,RPI		:...and alternate echo buffer
	JAL	RCH,EMPTY		:
	L	RBP,.FTBUF,RPI		:...and from-terminal buffer
	JAL	RCH,EMPTY		:
	 LO	SIGNAL
	LIS	R4,GOBSIG		:
	JAL	RCH,PUTSIG		:send a gobbler
	LHI	R4,YBSIG		:
	JAL	RCH,PUTSIG		:...followed by a yellow ball to reset
	 FO	SIGNAL
	SBT	RP,RESOUT		:indicate awaiting reset conf. (GOB/OB)
	J	EDRTN			:
:	...Indication of Break
EBRK10	THI	R8,BB.IND		:indication of break mask
	JE	EDRTN			:if no ind. of break wanted
	L	RBP,.FTBUF,RPI		:
	LO	SIGNAL
	LIS	R4,BBSIG		:
	JAL	RCH,PUTSIG		:
EBRK14	LB	R0,X3.P7,RPI		:
	THI	R0,BB.DIS		:
	JE	EDRTN			:if no need to discard output
	SBT	RP,X3.P8		:else discard
	LHI	R4,YBSIG		:
	JAL	RCH,PUTSIG		:always send Y.B. so O.B. resets 
	FO	SIGNAL
	J	EDRTN			:...and make common return

:	Break Handling - Packet Mode
:	NOTE: Discard output done in receiver
EBRK60	ST	RLINK,ETEMP		:free up RLINK
	LR	RLINK,R8		:
	THI	RLINK,BB.RES		:
	JE	EBRK70			:if no reset wanted
	L	RBP,.ECOBF,RPI		:
	JAL	RCH,EMPTY		:
	L	RBP,.FTBUF,RPI		:
	JAL	RCH,EMPTY		:
  	 LO	SIGNAL
	LIS	R4,GOBSIG		:send a gobbler
	 FO	SIGNAL
	JAL	RCH,PUTSIG		:
	JAL	R4,COP,,		:count output packet
	TURMSG(RESET,RNETCG,DIA144)	:send turkey reset
	SBT	RP,RESOUT		:indicate awaiting reset conf 
EBRK70	THI	RLINK,BB.INT		:Interrupt packet desired
	JE	EBRK80			:no
	SBT	RP,INTOUT		:yes, indicate interrupt out
	JN	EBRK80			:if interrupt already out
	JAL	R4,COP,,		:count output packet
	LHI	R6,EXMA			:send an interupt packet
	JAL	R9,BEGDIA		:
	LIS	RBC,1			:interrupt data of 1
	JAL	RCH,PUTCHR		:
					:
EBRK80	THI	RLINK,BB.IND		:Indication of break desired
	JE	EBRK90			:no
	LHI	R0,QBIT			:flag byte
	LIS	R6,1			:length
	THI	RLINK,BB.DIS		:discard data desired
	JEFS	EBRK85			:if without discard output
	LIS	R6,3			:increase length
EBRK85	JAL	R9,OUTPKT		:output packet
	LIS	RBC,X29.3		:indication of break PAD message
	JAL	RCH,PUTCHR		:
	THI	RLINK,BB.DIS		:
	JE	EBRK90			:
	LIS	RBC,X3.8		:discard output X.3 message
	JAL	RCH,PUTCHR		:
	LIS	RBC,1			:1=ON
	JAL	RCH,PUTCHR		:
EBRK90	THI	RLINK,BB.DIS		:discarding output?
	JE	EBRK99			:no
	SBT	RP,X3.P8		:set parameter 8 to 1

EBRK99	L	RLINK,ETEMP		:restore RLINK
	LB	R8,X3.P7,RPI		:get value of pram 7
	THI	R8,BB.ESC		:break = escape from data transfer?
	JN	EDDESC			:yes
	J	EDRTN			:

:	Non-break Processors
ESDA20	 LO	SIGNAL
	CLHI	R4,EDMSIG		:Deferred echo mode
	 FO	SIGNAL
	JN	PUTSIG			:if not EDEM

:	Process Enter Deferred Echo Mode (DEM) Signal
	LR	RBC,R9			:get char back since may be destroyed
	JGE	EDEM05			:if invoked from printer logic
	JAL	RCH,EDSFWD		:data forward
	L	RBP,.FTBUF,RPI		:
	J	EDEM25			:enter DEM
EDEM05	NHI	RBC,7F			:strip parity bit for lookup
	CLB	RBC,X3.P1,RPI		:
	JE	EDEM30			:if escape...handle locally
	TBT	RP,TURKEY		:
	JN	EDEM30			:if turkey-IIX...can't EDEM
	TBT	RP,X3.P15		:
	JE	EDEM20			:if can't edit...may want DEM
	CLB	RBC,X3.P16,RPI		:
	JE	EDEM30			:if char delete...handle locally
	CLB	RBC,X3.P17,RPI		:
	JE	EDEM30			:if line delete...handle locally
	CLB	RBC,X3.P18,RPI		:
	JE	EDEM30			:if edit char...handle locally

:	Enter DEM if data forwarding character
EDEM20	LB	R0,XMTASC,RBC		:get transmit mask for this char
	LB	R3,X3.P3,RPI		:data forwarding combo for port
	NR	R0,R3			:
	JE	EDEM30			:if can't data fwd...don't enter DEM
:	Place DEM signal -- char will cause forwarding
:			    on next editor call (always)
	L	RBP,.FEDBF,RPI		:
EDEM25	RBT	RP,IDLETO		:shut off idle timer (X3.P4)
	RBT	RP,X3.P2		:don't echo in editor (since in DEM)
	SBT	RP,ECHOON		:...but allow green ball to LDEM
	JAL	RCH,PUTSIG		:append DEM signal
	LA	RCH,EDRTN		:return adr...restores regs
	J	EDSFWD			:exit via EDSFWD

:	Escape or edit char...process locally
EDEM30	RBT	RP,DEM			:don't go into DEM
	SBT	RP,ECHO			:restore rcvr's echo (for next char)
	SBT	RP,LOCDEM		:...force editor to echo this char
	JR	RCH			:...and return to receiver
	

	SUBTTL	(PAD) Data Editor
:	Editor - Non-Signal Lookup Processor
:	====================================
:	====================================
:
EASCID	LB	R3,X3STAT,RPI		:
	LHL	R3,EDTABL,R3,R3		:processor for this state
	JER	RCH			:if none
	NHI	RBC,7F			:strip parity
	ST	RCH,EDSAVE		:
	ST	RBP,EDSAVE+4		:
	ST	R9,EDSAVE+8		:
	J	BASE,R3,		:

:	State Processor Table
EDTABL	HC	0
	HC	EDCIP-BASE		:connection in progress
	HC	0			:service signal
	HC	EDCMD-BASE		:pad waiting
	HC	EDGAT-BASE	:talking to gateway *500.sdw
	HC	0		:state removed *500.sdw
	HC	EDDAT-BASE		:data
	HC	0			:Wait for clear confirmation
	HC	0		:state removed *500.sdw



:	Common Editor (and command processor, eventually) Return
:	++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EDRTN	L	RCH,EDSAVE		:
	L	RBP,EDSAVE+4		:
	L	R9,EDSAVE+8		:
	JR	RCH			:



:       Non-Signal Editor - Connection in Progress State
:	================================================
EDCIP	CLB	RBC,X3.P1,RPI		:escape from data transfer character??
	JN	EDRTN			:
	LIS	R0,0			:
	ST	R0,.LSTAT,RPI		:switch from PAD logger
	J	CCCLR4			:act like "clear" command issued

:       EDGAT   talking to gateway-no editing but can get to command state
:       *500.sdw
EDGAT   CLB     RBC,X3.P1,RPI           :to command mode
        JE      EDDESC                  :to command mode
        JAL     RCH,PUTCHR              :pass char for gateway login
        J       EDRTN                   :and done



:	Editor - PAD Command State
:	==========================
EDCMD	TBT	RP,FLUNCR		:
	JEFS	EDCM10			:if ignoring until <CR> found
:	Flushing editing buffer
	CLHI	RBC,CR			:
	JNR	RCH			:if not terminator
	RBT	RP,FLUNCR		:  else reset flush flag
	JAL	RCH,EDECHO		:
	J	EDRTN			:finish up
EDCM10	CLB	RBC,X3.P1,RPI		:
	JN	EDCM30			:

:	Restart the command mode
	TBT	RP,CALCMD		:
	JEFS	EDCM20			:if not in call set up
	TBT	RP,NUINAM		:
	JEFS	EDCM20			:if not in NUI
	TBT	RP,UNAME		:
	JE	EDCM30			:if in password subfiled
EDCM20	L	RBP,.FEDBF,RPI		:dump edit buffer
	JAL	RCH,EMPTY		:empty editing buffer   :DLG 11-Sep-85
	RBT	RP,CALCMD		:in case call setup was in progress
	RBT	RP,NUINAM		:...eliminate remains
	JAL	RCH,EDECHO		:
	LIS	R0,X3PAW		:
EDCM24	STB	R0,X3STAT,RPI		:
:	Issue a prompt, if allowed
EDPMT	SERSIG(SS.PMT,PROMP)
	J	EDRTN			:

:	No escape - Check for command delimiter
EDCM30	TBT	RBC,DELIM		:
	JE	EDCM40			:if command name or editing char
:	Go process command
	RBT	RP,NUINAM		:no longer processing NUI
	STB	RBC,PREVCH,RPI		:
	JAL	RCH,EDECHO		:
	TBT	RP,CALCMD		:
	JN	CCCAL			:if call setup, handle separately
	J	CPARSE			:else parse command as usual

:	Char must be either : 1) editing char, or 2) cd name or parameter
EDCM40	L	RBP,.FEDBF,RPI		:
	LHL	R0,BCT,RBP,		:
:   Following was added to still have a command line check while removing
:   EBSIZE since EBSIZE is used to set up Packet SIZE (PSIZE)  *600.sdw
	CLHI	R0,80		:error if more than eighty chars  *600.sdw
	JG	EDCM56			
:   Following two lines removed by sdw.600 to allow PSIZE not meesup commands
:	CLH	R0,EBSIZE,RP,RP		:editted out since could be set too
:	JG	EDCM56		:small for command line and is for data mode
	CLB	RBC,X3.P16,RPI		:
	JE	EDCM42			:if character delete code
	CLB	RBC,X3.P17,RPI		:
	JE	EDCM52			:if line delete code
	CLB	RBC,X3.P18,RPI		:
	JN	EDCM60			:if not line display
:	...Line Display
	TBT	RP,CALCMD		:
	JN	EDCRTN			:cannot display call setup
	JAL	RCH,EDECHO		:
	JAL	RCH,EDSLID		:
	J	EDRTN			:

EDCM42	LR	R0,R0			:
	JE	EDCRTN			:if nothing to edit
:	...Character Delete Symbol
	TBT	RP,CALCMD		:
	JN	EDCRTN			:if call setup...ignore char delete
	JAL	RCH,EDECHO		:
	L	RBP,.FEDBF,RPI		:buffer to delete from
	JAL	RCH,GCD			:delete last char WCI'd
	J	EDRTN			:

: erase the last character on the terminal, call by (ENVIR)GCD
:
: EDERAS :  LINK REG = R0,   LAST CHARACTER TO BE ERASED = (R1)
:

	SEG	A.CODE
EDERAS	ST	R0,ERSAVE	:SAVE REGISTERS
	ST	RCH,ERSAVE+4	:
	ST	RBP,ERSAVE+8	:
	LR	R1,R1
	JNFS	EDERS1
	JAL	RCH,GCDALT
	L	R0,ERSAVE	:restore register, distroyed by GCDALT
EDERS1	TBT	RP,X3.P2	:IF TERMINAL WASN'T ECHOING
	JER	R0		:JUST RETURN
	NHI	R1,7F		:CLEAR MSB
	CHI	R1,09		:IS IT <TAB>?
	JE	EDERS4		:YES, BRANCH
	TBT	R1,.ECHT1,RPI	:IS IT PRINTABLE?
	JNR	R0		:NO, RETURN
	CHI	R1,08		:
	JER	R0		:IF BACKSPACE SKIP <BS><SP><BS>
	L	RBP,.ECOBF,RPI	:
	LA	R6,SS.ERS,,	:
	JAL	R5,OUTSTR,,	:OUTPUT THE <BS><SP><BS> SEQUENCE
EDERS2	L	RBP,ERSAVE+8	:
	L	RCH,ERSAVE+4	:
	L	R0,ERSAVE	:RESTORE LINK REGISTER
	JR	R0		:AND RETURN

: LAST CHARACTER IS A <TAB>, PUT A <BACKWARD TAB> IN ECHO BUFFER
EDERS4	L	RBP,.ECOBF,RPI
	TBT	RP,X3.N2		:IS NATIONAL PAR 102 SET?
	JN	EDERS5			:YES, BEEP UNNECESSARY
	LHI	RBC,BEEP		:NO, BEEP TERMINAL
	LB	R0,X3.P6,RPI		:TYPE OF SERVICE SIGNALS SENT
	THI	R0,X3.6NP       	:SERVICE SIGNAL WANTED?
	JE	EDERS2			:NO, RESTORE REG'S AND RETURN
	JAL	RBF,WCI			:YES, PUT CHAR. INTO BUFFER
	J	EDERS2			:RESTORE REG'S AND RETURN
         LO SIGNAL
EDERS5	LHI	R4,BTBSIG		:BEEP UNNECESSARY USE BTBSIG   
         FO SIGNAL
	JAL	RCH,PUTSIG		:
	J	EDERS2			:RESTORE REGISTERS AND RETURN

:	Line Delete
EDCM52	JAL	RCH,EDECHO		:
	SERSIG(SS.LID)
	L	RBP,.FEDBF,RPI		:dump edit buffer
	JAL	RCH,EMPTY		:empty editing buffer
	RBT	RP,CALCMD		:no longer proc call setup
	RBT	RP,NUINAM		:...and not in NUI
	J	EDRTN

:	Too many chars in buffer -- dump it
EDCM56	L	RBP,.FEDBF,RPI		:
	JAL	RCH,EMPTY		:
	SERSIG(SS.EBO)
	SBT	RP,FLUNCR		:
	J	EDRTN			:

:	Char is in command name or parameters
EDCM60	TBT	RBC,LETTER		:
	JEFS	EDCM61			:if not a letter
	NHI	RBC,5F			:  else make UPPER CASE
EDCM61	TBT	RP,CALCMD		:
	JN	EDCM70			:if proxcessing a call setup
	CLHI	RBC,SP			:
	JN	EDCM85			:if doesn't look like call setup

:	Check for Call Setup
	L	RBP,.FEDBF,RPI		:
	JAL	RBF,IGCSCN		:get ready to examine buffer
	J	EDCM85			:if empty
	LIS	R3,4			:lokk at 4 chars max
	LIS	R4,0			:init save area for chars
EDCM62	JAL	RBF,GCSCN		:get a char
	J	EDCM64			:if all out of chars
	SLLS	R4,8			:
	OR	R4,RBC			:
	SIS	R3,1			:
	JGEBS	EDCM62			:if haven't gotten 4 chars yet
	J	EDCM85			:  else too many chars for call setup

:	Found 4 or less chars followed by a blank - may be call setup
:	R3=4-N, N=# chars in buffer
EDCM64	LI	R0,05F5F5F5F		:UPPER CASE mask
	SLLS	R3,3			:shift count to properly mask N chars
	SRL	R0,0,R3			:mask for exactly N chars
	NR	R4,R0			:make UPPER CASE
	LI	R0,080808080		:Mark Parity mask
	SRL	R0,0,R3			:...for exactly N chars
	OR	R4,R0			:
	SRLS	R3,1			:index call command table
	CL	R4,CALLCM,R3		:
	JN	EDCM85			:if not call setup
:	Initialize editor call setup variables
	SBT	RP,CALCMD               :else indicate it is
	RBT	RP,NUINAM		:
	RBT	RP,UNAME		:
	RBT	RP,CUDTIM		:not yet time to look for CUD
	J	EDCM85			:

EDCM70	CLHI	RBC,DASH		:Process Call Setup
	JNFS	EDCM72			:if not end of facilities delimiter
	SBT	RP,CUDTIM		:else may now start CUD search
	SBT	RP,UNAME		:and assume not private CUD
	J	EDCM75			:and finish off NUI

EDCM72	TBT	RP,NUINAM		:
	JE	EDCM76			:if not processing NUI
	TBT	RP,UNAME		:
	JE	EDCM74			:if in password subfield
	CLHI	RBC,SEMIC		:else process Username
	JN	EDCM85			:if not username subfield delimiter
	RBT	RP,UNAME		:..else indicate in password now
	RBT	RP,ECHO			:turn echo off for password
	JN	EDCM90			:was on, don't echo semi-colon again
	TBT	RP,X3.P2		:
	JE	EDCM90			:
	SBT	RP,LOCDEM		:was off, but user wants echo
	J	EDCM85			:so, need to echo the semi-colon

EDCM74	CLHI	RBC,COMMA		:Process Password
	JN	EDCM90			:if still in password

EDCM75	RBT	RP,NUINAM		:done password and NUI
	TBT	RP,X3.P2		:
	JE	EDCM90			:if command state echo off
	SBT	RP,ECHO			:  else let receiver do it
	JN	EDCM90			:  if receiver already echoing
	SBT	RP,LOCDEM		:    else force echo for terminator
	J	EDCM85

:	Processing call setup - Non-NUI field
EDCM76	CLHI	RBC,4E			:
	JN	EDCM80			:If not "N" of NUI
	LB	R0,PREVCH,RPI		:
	CLHI	R0,COMMA		:
	JEFS	EDCM78			:if assuming NUI just began
	CLHI	R0,SP			:
	JN	EDCM85			:if assuming not NUI
EDCM78	SBT	RP,NUINAM		:
	SBT	RP,UNAME		:username is 1st subfield
	J	EDCM85			:

EDCM80	TBT	RP,CUDTIM		:See if processing call user data
	JE	EDCM85			:if not past facilities...don't look
	TBT	RP,UNAME		:
	JE	EDCM90			:if not echoing CUD (private)
	CLHI	RBC,50			:
	JN	EDCM85			:if not "P" of CUD
	LB	R0,PREVCH,RPI		:
	CLHI	R0,STAR			:
	JEFS	EDCM82			:if "*" just ended adr...assume CUD
	CLHI	R0,DASH			:
	JEFS	EDCM82			:if "-" just ended facilities
	CLHI	R0,39			:
	JGFS	EDCM85			:if not an adr digit, not CUD
	CLHI	R0,30			:
	JLFS	EDCM85			:if not an adr digit, not CUD

EDCM82	RBT	RP,ECHO			:"P"-type CUD is never echoed
	RBT	RP,UNAME		:
	JFS	EDCM90			:

EDCM85	LR	RBC,R9			:Echo character
	JAL	RCH,EDECHO		:

EDCM90	LR	RBC,R9			:Put character in edit buffer
	L	RBP,.FEDBF,RPI		:
	JAL	RCH,PUTCHR		:
	NHI	RBC,7F			:
	STB	RBC,PREVCH,RPI		:

:	Make sure local DEM only applies to current character
EDCRTN	RBT	RP,LOCDEM		:
	J	EDRTN			:


:	Non-Signal Editor - Data Transfer State
:	=======================================
EDDAT
	JAL	RCH,EDECHO		:may need to echo
	CLB	RBC,X3.P1,RPI		:is it a data link escape character?
	JE	EDDESC			:yes, escaping from data transfer
	L	RBP,.FEDBF,RPI		:no, get edit buffer pointer
	LHL	R3,P.BCT,RPI		:get character byte count  *6.02 dlg
	TBT	RP,X3.P15		:is editing enabled?
	JE	EDDA15			:no, cannot edit now
	CLB	RBC,X3.P16,RPI		:char delete?
	JNFS	EDDA05			:no
	LR	R3,R3			:nothing in buffer
	JE	EDRTN			:if nothing to edit...ignore
	SIS	R3,1			:decrement character byte count 
	STH	R3,P.BCT,RPI		:store count in port table  *6.02 dlg
	JAL	RCH,GCD			:erase last character
	J	EDRTN			:return

EDDA05	CLB	RBC,X3.P17,RPI		:line delete?
	JN	EDDA10			:no, continue
	LIS	R3,0			:yes, clear character byte count
	STH	R3,P.BCT,RPI		:store in port table
	JAL	RCH,EMPTY		:empty edit buffer
	SERSIG(SS.LID)
	SERSIG(SS.FEF)
	J	EDRTN			:return

EDDA10	CLB	RBC,X3.P18,RPI		:line redisplay?
	JNFS	EDDA15			:no, continue
	JAL	RCH,EDSLID		:yes, display line 
	J	EDRTN			:return

:	Not an editing char
EDDA15	CLH	R3,PSIZE,RPI		:has max packet size been exceeded?
	JGE	EDDA20			:yes, 
	CLH	R3,EBSIZE,RP,RP		:has max packet size been exceeded?
	JL	EDDA30			:no,

:	Edit buffer full...forward then save current character
EDDA20	RBT	RP,IDLETO		:reset idle timer, not idle
	STB	RBC,PREVCH,RPI		:save current char
	ST	R9,ETEMP+4		:save (R9)
	JAL	RCH,EDSFWD		:
	L	R9,ETEMP+4		:
	L	RBP,.FEDBF,RPI		:
	LB	RBC,PREVCH,RPI		:

EDDA30	LB	R0,X3.P4,RPI		:idle timer enabled?
	JEFS	EDDA40			:if no idle timer
	SBT	RP,IDLETO		:else data restarts idle timer
	STB	R0,IDL.CU,RPI		:timer expiration value
EDDA40	LR	RBC,R9			:
	LIS	R3,1			:prepare to increase char byte count
	AHM	R3,P.BCT,RPI		:increase character byte count*6.02 dlg
	JAL	RCH,PUTCHR		:place character in buffer
	NHI	RBC,7F			:remove high order bit
	CLHI	RBC,0D			:is it a cr?
	JN	EDDA60			:no, skip

:	CR in stream...see if need to append LF
	LB	R0,XMTASC,RBC		:this could be more efficient(CAB)
	LB	R3,X3.P3,RPI		:get parameter 3
	NR	R0,R3			:data forwarding char?
	JEFS	EDDA50			:no
	RBT	RP,IDLETO		:yes, reset idle timer
	ST	R1,EDR1SV		:R1 trashed by EDSFWD, save it
	JAL	RCH,EDSFWD		:forward the packet
	L	R1,EDR1SV		:restore R1
EDDA50	LB	R0,X3.P13,RPI		:get parameter 13
	THI	R0,X3.13F		:insert LF into data stream?
	JE	EDDA60			:no
	LIS	RBC,0A			:yes
	L	RBP,.FEDBF,RPI		:get buffer pointer
	LIS	R3,1			:prepare to increase char byte count
	AHM	R3,P.BCT,RPI		:increase char byte count  *6.02 dlg
	JAL	RCH,PUTCHR              :put LF into buffer

:	Check for data forwarding char
EDDA60	LB	R0,XMTASC,RBC		:data forwarding mask for this char
	LB	R3,X3.P3,RPI		:data forwarding combo for port
	NR	R0,R3			:
	JE	EDRTN			:if no data forward on this char
:	Forward edit buffer
	RBT	RP,IDLETO		:sending data turns off idle timer
	JAL	RCH,EDSFWD		:
	J	EDRTN			:


:	Escape from data transfer 
:		1) Recall character or
:		2) Break with X3.P7=BB.ESC
EDDESC
        SERSIG(XHELLO)          	:stay in command mode *500.sdw
	SERSIG(SS.PMT,PROMP)		:issue promp for command mode
	LIS	R0,X3PAW		:put PAD in wait state
	STB	R0,X3STAT,RPI           :store in port table
	STB	RBC,PREVCH,RPI		:
	LA	R0,XPADBK		:backpressure data till in data mode
	JAL	RCH,XPADSV		:..by invoking backpressure xmit filter
        JAL     RCH,EDSFWD              :forward data upon entering cmd mode
	J	EDRTN			:





:	Editor Utilities
:	================

:	EDSFWD	- Data Forwarding Subroutine
:		DESTROYS R0-6,RBF,R9
:		Link on RCH
EDSFWD	TBT	RP,TURKEY		:speaking 8083 dialect?
	JE	EDSFW2			:no, not in packet mode
	TBT	RP,FREDIT		:data present?
	JER	RCH			:no, return
	ST	RCH,ETEMP		:yes, save link
	L	R5,.FEDBF,RPI		:get edit buffer pointer
	LHL	R6,P.BCT,RPI		:get character byte count  *6.02 dlg
	LIS	R0,0			:flag byte
	STH	R0,P.BCT,RPI		:reset char byte count to zero
	JAL	R9,OUTPKT		:output data in packet mode
	L	RCH,ETEMP               :
EDSFW2	L	R6,.FTBUF,RPI		:dest buffer
	L	R5,.FEDBF,RPI		:...and source buffer
	J	MCI			:copy and return



:	EDSLID	-	Display Contents of Editing Buffer
:		(Format effector placed before and after)
:		DESTROYS	R0-8, ETEMP
:		Link on RCH
EDSLID	ST	RCH,ETEMP		:save link
	SERSIG(SS.FEF)
	L	RBP,.FEDBF,RPI		:SOURCE BUFFER
	JAL	RBF,IGCSCN		:ready to look at it
	 J	EDSLI6			:if nothing to display
EDSLI4	JAL	RBF,GCSCN		:get a character
	 J	EDSLI6			:
	L	RBP,.ECOBF,RPI		:...and put in here
	JAL	RCH,PUTCHR              :
	L	RBP,.FEDBF,RPI		:restore ptr to source
	JBS	EDSLI4			:...and look for more chars

EDSLI6	L	RCH,ETEMP               :
	JR	RCH			:


:	EDECHO - Echo command or data characters to Alternate Echo Buffer
:		Input - RBC=char to be echoed
:			R9=actual char (maybe with parity bit)
:		DESTROYS - R0, ETEMP
:		Link on RCH
EDECHO	TBT	RP,LOCDEM		:
	JNFS	EDEC10			:if receiver gave us the echo
	TBT	RP,ECHO			:
	JNR	RCH			:if echoing...don't do it again
	TBT	RP,X3.P2		:
	JER	RCH			:if terminal didn't set echo...don't
EDEC10	ST	RCH,ETEMP		:save link                
	RBT	RP,LOCDEM		:
	TBT	RP,HAFDUX		:Half-Duplex?
	JN	EDVAHD			:
	TBT	RBC,.ECHT1,RPI		:Is it easily printable?
	JN	EDVAN			:No, Check special cases

:	Echo (single) character
EDVAK1	LR	RBC,R9			:Get the character
EDVAK2	L	RBP,.ECOBF,RPI		:set alternate echo buffer-pointer
	JAL	RCH,PUTCHR		:...and echo it           
	NHI	RBC,7F			:get rid of parity bit

EDECRT	L	RCH,ETEMP		:Return to caller
	JR	RCH			:

:	Handler for "Q"-mode
:	Echo "~" and "}"
:	Don't echo LF
:	Echo Cr (with LF) if Echo_on_LF set...
:		THEN ENTER DEM!!!
EDVAQ	LHI	R0,-7D,RBC		:is it "}"?
	JE	EDVAK1			:yes...echo it
	SIS	R0,7E-7D		:is it "~"?
	JE	EDVAK1			:yes...echo it
	LHI	R0,-0A,RBC		:LF?
	JER	RCH			:yes...ignore it for now
	LR	R0,RBC			:copy so RBC not destroyed
	SIS	R0,0D			:CR?
	JN	EDVAN2			:no...treat as non-Q char
	TBT	RP,ELF.CR		:yes...should we echo?
	JER	RCH			:no
	L	RBP,.ECOBF,RPI		:yes...set alt echo buffer-pointer
	LR	RBC,R9			:echo CR
	JAL	RCH,PUTCHR		:
	NHI	RBC,7F			:mask out parity bit
	TBT	RP,ECR.LF		:Line-feed needed too?
	JE	EDECRT			:no
	LIS	RBC,0A			:yes...echo it
	JAL	RCH,PUTCHR		:echo CR/LF for CR        
	LR	RBC,R9			:and send the CR
	NHI	RBC,7F			:
	J	EDECRT			:


:	non-printable (?) char on echo...
EDVAN	TBT	RP,Q.MODE		:"non-printable"...is port in "Q"-mode?
	JN	EDVAQ			:yes...do it
	TBT	RBC,SPABLE,,		:special?
	JER	RCH			:yes...ignore it for now
	LR	R0,RBC			:
	SIS	R0,0A			:
	JNFS	EDVAN1			:Not a LF
	TBT	RP,ELF.CR		:Carriage return needed too?
	JE	EDVAK1			:echo LF for LF
	LI	R6,7F0D00,R9		:
	J	EDVAE1			:echo LF/CR/RUBOUT

EDVAN1	SIS	R0,0D-0A		:CR?
	JNFS	EDVAN2			:not a CR
	TBT	RP,ECR.LF		:Line-feed needed too?
	JE	EDVAK1			:Echo CR for CR
	LI	R6,0A00,R9		:
	J	EDVAE1			:echo CR/LF for CR


EDVAN2	AIS	R0,0D-9			:^I? (may also enter from VAQ)
	JNFS	EDVAN3			:no, branch
	TBT	RP,ECTLI		:need to echo it?
	JER	RCH			:no, return
	J	EDVAK1			:yes, go put it in echo buffer.

EDVAN3	AIS	R0,9-8			:^H?
	JNFS	EDVAN4			:
        LIS     R0,X3DAT                :logic is to echo if in data mode and
        CLB     R0,X3STAT,RPI           :is not same as editor's char delete
        JNR     RCH                     :don't echo since not data mode
        TBT     RP,X3.P15               :editing allowed?
	JE	EDVAK1			:data mode and not edi char so echo
        LIS     R0,8
        CLB     R0,X3.P16,RPI           :see if data editing char
        JER     RCH                     :they match so editor handles it
	J	EDVAK1			:

EDVAN4	SHI	R0,1B-8			:ESC?
	JNR	RCH			:
	TBT	RP,E.ESC		:
	JN	EDVAK1			:Echo-ESC
	JR	RCH			:don't echo

:	Echo a (reverse) string of characters in R6
:	(original char in R9)
EDVAE1	L	RBP,.ECOBF,RPI		:alternate echo buffer-pointer
EDVAE2	LR	RBC,R6			:get a copy
	JAL	RCH,PUTCHR,,		:echo it
	SRLS	R6,8			:get next character...
	JNBS	EDVAE2			:...If any (up to three)
	LR	RBC,R9			:
	NHI	RBC,7F			:
	J	EDECRT			:...then go send char and exit

EDVAHD	TBT	RBC,SPABLE,,		:Half-duplex...special char?
	JER	RCH			:no...just go send it
	CLHI	RBC,0D			:Carriage return?
	JNFS	EDVAH1			:skip if not
	TBT	RP,ECR.LF		:yes...echo line-feed?
	JER	RCH			:no...just send char
	LIS	RBC,0A			:else return line-feed
	J	EDVAK2			:echo it

EDVAH1	CLHI	RBC,0A			:line-feed?
	JNR	RCH			:no, just send char
	TBT	RP,ELF.CR		:yes...echo with CR|RUB?
	JER	RCH			:no, just send it
	LHI	R6,7F0D			:yes
	J	EDVAE1			:echo string of characters



	SUBTTL	(PAD) COMMAND PARSER


:	Command Name Parser
:	===================
:	===================
:	Both extended and straight CCITT command names are handled here
:	with the exception of the Call set-up command, which is
:	called directly by the editor.
:	Blanks are ignored for the CCITT commands.
:	If a port is capable of issuing Extended commands, a check for
:	a match in these is made first, then a fallback to CCITT command 
:	names is done if no match appears.
:	Extended command names MUST be at least 3 letters in length and
:	followed by a blank.
:	CCITT command names must appear exactly as specified in the
:	X.28 Recommendation (1980).
:	The HELp command gives a short listing of available commands.

:	Entry:	EDSAVE - RCH (link)
:		EDSAVE+4 - RBP
:		EDSAVE+8 - R9 (character from receiver)




:	TYMNET Extended Command Lookup Table (1st Letter)

CMDEXT	HC	CMDEA-BASE			:"A" (ANCILLARY)
	HC	CMDEB-BASE
	HC	CMDEC-BASE
	HC	CMDED-BASE
	HC	CMDEE-BASE
	HC	CMDEF-BASE
	HC	0
	HC	CMDEH-BASE
	HC	CMDEI-BASE
	HC	0
	HC	CMDEK-BASE
	HC	CMDEL-BASE
	HC	0
	HC	0
	HC	0
	HC	CMDEP-BASE
	HC	CMDEQ-BASE		:*500.sdw for quit
	HC	CMDER-BASE
	HC	CMDES-BASE
	HC	CMDET-BASE
	HC	0
	HC	0
	HC	CMDEW-BASE
	HC	0
	HC	0
	HC	0


:	TYMNET Extended Command Name Strings (2nd thru Nth letters)

CMDEA	SC	/NCILLARY/	;	HC	EXS050-BASE
	SC	/NCILLARY?/	;	HC	EXR050-BASE
	BC	0
CMDEB
:	SC	/ACKSPACE/
:	HC	ETS020-BASE
:	SC	/ACKSPACE?/
:	HC	ETR020-BASE
	SC	/REAK/		;	HC	EXS070-BASE
	SC	/REAK?/		;	HC	EXR070-BASE
	SC	/RKEY/		;	HC	ETS030-BASE
	SC	/RKEY?/		;	HC	ETR030-BASE
	BC	0

CMDEC	SC	/HARACTERDELETE/	;	HC	EXS160-BASE
	SC	/HARACTERDELETE?/	;	HC	EXR160-BASE
	SC	/LEAR/			;	HC	CCCLR-BASE
:	SC	/RDELAY/
:	HC	CECRDS-BASE
:	SC	/RDELAY?/
:	HC	CECRDR-BASE
	SC	/RLF/		;	HC	EXS130-BASE
	SC	/RLF?/		;	HC	EXR130-BASE
	SC	/RPADDING/	;	HC	EXS090-BASE
	SC	/RPADDING?/	;	HC	EXR090-BASE
	BC	0

CMDED	SC	/ISPLAYLINE/	;	HC	EXS180-BASE
	SC	/ISPLAYLINE?/	;	HC	EXR180-BASE
	BC	0

CMDEE	SC	/CHO/		;	HC	EXS020-BASE
	SC	/CHO?/		;	HC	EXR020-BASE
	SC	/DIT/		;	HC	EXS150-BASE
	SC	/DIT?/		;	HC	EXR150-BASE
	SC	/SCAPE/		;	HC	EXS010-BASE
	SC	/SCAPE?/	;	HC	EXR010-BASE
	SC	/XPAND/		;	HC	ETS020-BASE
	SC	/XPAND?/	;	HC	ETR020-BASE
	BC	0

CMDEF	SC	/LOW/		;	HC	EXS120-BASE
	SC	/LOW?/		;	HC	EXR120-BASE
	SC	/LUSH/		;	HC	EXS080-BASE
	SC	/LUSH?/		;	HC	EXR080-BASE
	SC	/ORWARD/	;	HC	EXS030-BASE
	SC	/ORWARD?/	;	HC	EXR030-BASE
	BC	0

CMDEH
:	SC	/ALFDUPLEX/
:	HC	ETS070-BASE
:	SC	/ALFDUPLEX?/
:	HC	ETR070-BASE
	SC	/ELP/		;	HC	CEHEL-BASE
	BC	0

CMDEI
:	SC	/BAUDRATE/
:	HC	ETS040-BASE
:	SC	/BAUDRATE?/
:	HC	ETR040-BASE
	SC	/DLE/		;	HC	EXS040-BASE
	SC	/DLE?/		;	HC	EXR040-BASE
	SC	/NTERRUPT/	;	HC	CCINT-BASE
	BC	0

CMDEK
:	SC	/ATAKANA/
:	HC	ETS130-BASE
:	SC	/ATAKANA?/
:	HC	ETR130-BASE
	BC	0

CMDEL
:	SC	/FCR/
:	HC	ETS030-BASE
:	SC	/FCR?/
:	HC	ETR030-BASE
	SC	/FPADDING/	;	HC	EXS140-BASE
	SC	/FPADDING?/ 	;	HC	EXR140-BASE
	SC	/INEDELETE/	;	HC	EXS170-BASE
	SC	/INEDELETE?/	;	HC	EXR170-BASE
	SC	/OGIN/		;	HC	CMDLOG-BASE
	BC	0

CMDEQ	SC	/UIT/		;	HC	CCQUI-BASE  :quit *500.sdw
	BC	0

CMDEP	SC	/ROF/		;	HC	CCPROR-BASE
	SC	/ROF?/		;	HC	CCPROS-BASE
	SC	/ROFILE/	;	HC	CCPROR-BASE
	SC	/ROFILE?/	;	HC	CCPROS-BASE
	BC	0

CMDER	HS
	SC	/ECEIVE/	;	HC	CERCV-BASE
	SC	/EJECT/		;	HC	CERJT-BASE
	SC	/ESET/		;	HC	CCRES-BASE
	BC	0

CMDES	SC	/ERVICE/	;	HC	EXS060-BASE
	SC	/ERVICE?/	;	HC	EXR060-BASE
	SC	/PEED/		;	HC	EXS110-BASE
	SC	/PEED?/		;	HC	EXR110-BASE
	SC	/TATUS/		;	HC	CCSTA-BASE
	BC	0

CMDET	SC	/AB/		;	HC	ETS010-BASE
	SC	/AB?/		;	HC	ETR010-BASE
	BC	0

CMDEW	SC	/IDTH/		;	HC	EXS100-BASE
	SC	/IDTH?/		;	HC	EXR100-BASE
	BC	0


:	CCITT Command Lookup Table (1st Letter)
CMDCCI	HC	0
	HC	0
	HC	CMDCC-BASE
	HC	0
	HC	0
	HC	0
	HC	0
	HC	0
	HC	CMDCI-BASE
	HC	0
	HC	0
	HC	CMDCL-BASE			:6.02 DLG
	HC	0
	HC	0
	HC	0
	HC	CMDCP-BASE
	HC	0
	HC	0
	HC	CMDCS-BASE
	HC	0
	HC	0
	HC	0
	HC	0
	HC	0
	HC	0
	HC	0


:	CCITT Command Name Strings (2nd thru Nth Letters)
:	NOTE: Command strings are arranged alphabetically!!
:	Any changes to command names must be inserted in order!!
CMDCC	SC	/LR/		;	HC	CCCLR-BASE
	BC	0

CMDCI	SC	/NT/		;	HC	CCINT-BASE
	BC	0

CMDCL	SC	/OGIN/		;	HC	CCLOG-BASE
	BC	0

CMDCP	SC	/AR?/		;	HC	CCPAR-BASE
	SC	/ROF/		;	HC	CCPROR-BASE
	SC	/ROF?/		;	HC	CCPROS-BASE
	SC	/ROFILE/	;	HC	CCPROR-BASE
	SC	/ROFILE?/	;	HC	CCPROS-BASE
	BC	0

CMDCR	SC	/ESET/		;	HC	CCRES-BASE
	BC	0

CMDCS	SC	/ET/		;	HC	CCSET-BASE
	SC	/ET?/		;	HC	CCSER-BASE
	SC	/TAT/		;	HC	CCSTA-BASE
	BC	0
:


:  this defines the text strings which are checked for a match.
:  if a match occurrs it then jumps to the routine which then puts
:  the genned in string into the CMDBUF as if the whole call command was
:  typed
	IF	ATOCAL
ATOCCS
Q	EQ	0
	RE	ATOCAL
	ATCM|Q|   ;		HC	CCAC|Q|-BASE
Q	EQ	Q+1
	ER
	BC	0
	EI


        HS 0
CPARAB	ABORT(RBF,92)


:	Command Name Parse
:		Uses R8 - # chars put into *CMDBUF*
:		     R7 - index into *CMDBUF*
CPARSE	RBT	RP,CMDMOD
	IF	ATOCAL
	SBT	RP,CMDMOA		:command mode to find autocall command
	EI
  IF	NNUIC
	RBT	RP,NALPNU		:initializing
  EI
	TBT	RP,PADTYP
	JEFS	CPAR02			:if must only parse CCITT commands
	SBT	RP,CMDMOD		:..else do Extended command names 1st
:	Move command line into command buffer
CPAR02	L	RBP,.FEDBF,RPI
	LIS	R9,0
CPAR04	TBT	RP,FREDIT
	JE	CPAR10			:if no more edit chars
	JAL	RCH,GETCHR,,
	J	CPARAB			:if a signal (shouldn't happen!!)
	NHI	RBC,7F			:remove parity bit
  IF	NNUIC
	TBT	RBC,ALPNUM
	JNFS	CPAR05			:if a alpha-numeric
	SBT	RP,NALPNU		:if not,bad user name, set NALPNU to 1
  EI
CPAR05	TBT	RBC,LETTER
	JEFS	CPAR06			:if not a letter
	NHI	RBC,5F			:  else make it UPPER CASE
CPAR06	STB	RBC,CMDBUF,R9		:save char in comand buffer   
	AIS	R9,1			:increment index
	J	CPAR04

CPAR10
	LR	R8,R9			:more characters than terminator?
	JNFS	CPAR12			:yes, process 
	TBT	RP,CALPRG		:is call already in progress?
	JE	CMDRTN			:no
	J	CMDDAT			:yes, back to data mode

:	Apply lookup table on 1st command name letter
CPAR12	LCS	R7,1		:allow ignore of some leading chars *500.sdw
CPAR14	AIS	R7,1
	CR	R7,R8
	JE	CMDRTN		:not error but not null cmd
	LB	RBC,CMDBUF,R7
	TBT	RBC,LETIGR		:ignore some leading chars *500.sdw
	JNBS	CPAR14
	TBT	RBC,LETTER
	JE	CMDER2		:if invalid 1st character of cmd name
	AIS	R7,1		:another char gone
	STH	R7,TEMP		:save offset into CMDBUF
	SR	R8,R7		:no one letter commands
	JE	CMDER1		:no one char commands
	LR	R9,R8		:now R9 has chars to check *r9 had to be loaded
				:here since CMDER1 would call CPAR11 and
				:then it would look like a null command*500.sdw
				:then check valid user name
	SHI	RBC,041		:make letter index lookup table
	TBT	RP,CMDMOD
	JE	CPAR18		:if currently parsing CCITT commands
:	Extended Command Lookup
	LHL	R3,CMDEXT,RBC,RBC
	JE	CMDER1			:if no command begins with this letter
					:then check valid user name
	AI	R3,BASE			:turn offset into absolute address
CPAR17	LIS	R6,2			:(min) # chars left to match name
	J	CPAR20

:	CCITT Lookup
CPAR16	LHL	R7,TEMP			:jump here from CMDER1 after tried
	LB	RBC,CMDBUF-1,R7		:to find extended command
	SHI	RBC,41
CPAR18	LHL	R3,CMDCCI,RBC,RBC
	JE	CMDER1			:if no commands start with this letter
					:then check valid user name
	AI	R3,BASE			:turn offset into absolute address
	LB	R6,0,R3			:  else # chars to match
	JE	CMDER1			:if no more chars..bad news
					:then check valid user name

	IF	ATOCAL 	:command which calls call faker of genned string
	J	CPAR20	:catch and send fall though logic of above


CPAR19	AIS	R9,1	:autocal has no first char check
	LCS	R3,1
	AHM	R3,TEMP
	LA	R3,ATOCCS	:where the call strings are
	LB	R6,0,R3		:make them all match
	EI


:	Common parser for Extended and CCITT commands
:	---------------------------------------------
:	R3 - index to start of SC string (ie. ptr to length of string)
:	R4 - offset into SC string
:	R5 - # chars left in SC string
:	R6 - # chars in *CMDBUF* that must match chars in SC string

CPAR20	LB	R5,0,R3			:# chars in stored command string
	LIS	R4,1			:index cmd name SC string
	LHL	R7,TEMP		:offset into array
	LR	R8,R9		:chars left to process
CPAR22	LR	R8,R8
	JG	CPAR30			:if more chars in cmd buffer
CPAR24	LR	R6,R6
	JG	CPAR40			:if not enough matching chars found

:	Found a command name match!
	LB	R5,0,R3			:SC count
	AHI	R3,2,R5			:skip over command name
	LCS	R0,2			:...to adr of command processor adr
	NR	R3,R0			:...but make sure adr is even
	SIS	R7,1			:backup ptr to char after cmd name
	LHL	RBC,0,R3		:get address of command processor
	J	BASE,RBC,		:...and go process command!!

:	Keep searching for a match
CPAR30	SIS	R8,1			:# chars left in cmd buffer
	LB	RBC,CMDBUF,R7		:get next command name char   
	AIS	R7,1			:...and adjust index
	OHI	RBC,80			:mark parity for AC string lookup
	CLHI	RBC,0A0
	JNFS	CPAR35			:if not a blank
	TBT	RP,CMDMOD
	JE	CPAR22			:if CCITT cmd...ignore blanks
	AIS	R8,1			:..else don't count blank yet
	J	CPAR24			:...and see if cmd recognozed

CPAR35	CLHI	RBC,0BF
	JNFS	CPAR38			:if not "?"
:	"?" is end of READ (PAR?) or SET and READ command
:	(it is assumed to be last letter of stored cmd name string)
	LB	R4,0,R3			:length of cmd
	TBT	RP,CMDMOD
	JEFS	CPAR36			:if CCITT mode..."?" counts as a char
	AIS	R6,1			:  else don't count as (1 of 3)letters
CPAR36	LIS	R5,1			:only 1 letter left
	JFS	CPAR39			:see if match

CPAR38	AIS	R8,1			:don't count non-letters
	IF	ATOCAL	:atocall names mayhave numbers*500.sdw
	TBT	RP,CMDMOA	:0 if searching for autocall
	JEFS	CPAR37
	EI
	TBT	RBC,LETTER-10	:10 isoffset of letter with high bit on char
	JE	CPAR24			:if not a letter...try to find cmd name
CPAR37	SIS	R8,1			:..else count it
	LR	R5,R5
	JE	CPAR40			:if no more chars in SC string
CPAR39	CLB	RBC,0,R3,R4
	JN	CPAR40			:if cmd char not stored char..next cmd
	AIS	R4,1			:  else offset for next letter
 	SIS	R5,1			:...and 1 less char in cmd name
	SIS	R6,1			:...and 1 less char to match
	J	CPAR22			:try to keep hot streak going

:	No more command characters specified by terminal or no match
:	of terminal command name with stored command string
:	see if another command starts with the same letter
CPAR40	AR	R3,R4			:index to current letter of name
	AR	R3,R5			:...then end of name
	AIS	R3,1
	LCS	R0,2
	NR	R3,R0			:...to even boundary
	AIS	R3,2			:...and past cmd processor adr
	LB	R0,0,R3			:see if end of cmd strings
	JE	CMDER1			:if no more cmd strings with same letter
					:then check valid user name
:	Set up to check another command name with same 1st letter
	LIS	R6,2			:(min) # chars to match for Extended
	TBT	RP,CMDMOD
	JN	CPAR20			:if parsing in Extended mode
	LB	R6,0,R3			:  else must match entire SC string
	J	CPAR20

:	Out of command names -- if we were checking Extended commands, then
:	do CCITT ones
CMDER1	LA	R6,SS.E10,,		:we didn't recognise command error
	RBT	RP,CMDMOD		:if already tried Extended & CCITT cmd
	JN	CPAR16		:search for CCITT command

	IF	ATOCAL
	RBT	RP,CMDMOA	:already looked for it
	JN	CPAR19	:first search
	EI


:	Command Parser Exits
:	====================

:	Made a login in command parse without the use of NUI facility
:	Circuit building is processed exactly like a CALL command with
:	a NUI facility

  IF	NNUIC
BLTCIR	TBT	RP,NALPNU		:test if user name is alpha-numeric
	JN	CMDERR			:no, error message
	TBT	RP,CALPRG		:if circuit is in progress
	JN	CALERD			:yes, error message
	LR	R8,R9			:# of char in CMDBUF      
	AIS	R9,1			:increase R9 to reflct N  
	SIS	R8,1			:decrease R8 for last     
BLTCI1	LB	RBC,CMDBUF,R8		:load last char in R1     
	STB	RBC,CMDBUF+1,R8		:move last char over 1    
	SIS	R8,1			:point to next char       
	JGEBS	BLTCI1			:no, get next char        
	LHI	RBC,4E			:place N in R1            
	STB	RBC,CMDBUFF		:place N in CMDBUF        
	J	CALL30			:set up default values    
  EI

CMDER2	LA	R6,SS.E10,,		:fatal syntax error  *500.sdw
CMDERR	SERSIG

:	Common Parser Return
CMDRTN
	LIS	R0,X3PAW		:back in waiting state
	STB	R0,X3STAT,RPI                                      
	LA	R6,SS.FEF,,		:linfeed if no prompt
	LB	R0,X3.P6,RPI
	THI	R0,X3.6P		:issue prompt?
	JEFS	CMDRT1		:skip if no
	LA	R6,SS.PMT,,
CMDRT1	L	RBP,.ECOBF,RPI
	JAL	R5,OUTSTR,,		:send it
	J	EDRTN

:	Return to Data Transfer mode
CMDDAT
	LIS	R0,X3DAT		:put interface in data transfer state
	TBT	RP,XTGATE		:gateway has special state
	JEFS	CMDDA1			:not a gateway
	LIS	R0,X3GAT		:put interface in gateway state
CMDDA1	STB	R0,X3STAT,RPI		:store interface status
	L	R0,.XPADS,RPI		:no longer ignoring data
	ST	R0,.XPADF,RPI		:so restore normal PAD xmit filters
	SERSIG(DHELLO)			:send msg - in data transfer mode
	J	EDRTN			:return

:	Switch to login mode --- if possible
:	This routine does not follow CCITT rec.  It needs to be changed
:	to return to data mode if an error occurs.  
CMDLOG
	TBT	RP,LGMODE               :can port enter login mode?
	JNFS	CMDLG1			:yes
	LA	R6,SS.E10,,		:no, command name unknown, try a 
					:different syntax
	J	CMDERR			:send error message and return to
					:command mode

CMDLG1
	TBT	RP,CALPRG		:call in progress?
	JE	CMDLG2			:no, switch port to login mode
	LA	R6,SS.CSD,,		:yes, send error message
	J	CMDERR			:send error message and return to 
					:command mode

CMDLG2	RBT	RP,ECHO			:turn off editor echo
	RBT	RP,FLUNCR		:...but take future input
	RBT	RP,COMTO		:disable command state timout
        SBT     RP,LOGING               :let data be read *500.sdw

:	initialize CONSAT terminal parameters and bit arrays
        LHL     R4,.TERMT,RPI		:get terminal-type cursor
	JAL	R5,IZPORT,,		:initialize CONSAT parm and arrays

:	initialize PAD terminal parameters and bit arrays
	L	R5,.ECOBF,RPI		:copy data from echo buffer
	L	R6,.TTBUF,RPI		:to the to-terminal buffer
	JAL	RCH,MCI,,		:move the data
	JAL	RBF,IXPRLG		:initialize PAD parm and arrays

  IF	PVC
        LO      PVC
        TBT     RP,PVCARY,,
        JEFS    CMDLG3
        JAL     R9,PVCSOP,,             :for pvc set the selected options
        L	R6,.PVCX,RPI		:NEWLOG must be set for PAD ALO
        THI	R6,POALO
        JEFS	CMDLG3
        SBT	RP,NEWLOG		:look as if terminal just turned on
CMDLG3
        FO      PVC
  EI    :PVC			:5.00.sdw

	LHI	R5,8000
	J	ESTPRT			:establish port


:	Message clean up will require separate routines to handle LOGIN cmd
CCLOG
	J	CMDLOG			:use Tymnet Extended Command for now


	SUBTTL (PAD) COMMAND PROCESSORS

:	commands defined to call using tymfile call string
:	This is autocall and is called programming by macro

	IF	ATOCAL
AQ	EQ	0
	RE	ATOCAL
ATB|AQ|	BARRAY(.AC|AQ|,NPORT)
CCAC|AQ|	TBT	RP,ATB|AQ|	:port have this one?
	JE	CMDER1		:no, error msg
	TBT	RP,CALPRG		:not if call in prog
	JN	CALERD
	LA	R6,ATLG|AQ|,,
	J	ATCMPT	:put the string in command buf
AQ	EQ	AQ+1
	ER

ATCMPT	LIS	R9,0	:routine to put login sstring into cmdbuf
	LB	R7,0,R6		:count of chars to put
ATCMP1	LB	R0,1,R6,R9
	NHI	R0,7F
	STB	R0,CMDBUF,R9	:get and store as seven bit
	AIS	R9,1		:count how many in
	SIS	R7,1		:how many left
	JGBS	ATCMP1
	J	CALL30		:let call logic take over *500.sdw

	EI :ATOCAL


:	Call Setup Processor
:	====================
:	Entry directly from editor (does not use parser)
:	Returns to *CMDRTN*
:
CCCAL	TBT	RP,CALPRG
	JN	CALERD			:if wizeass thinks this is a mux
        RBT     RP,NEWLOG               :a call isnot a NEWLOG  *5.00.sdw
	LIS	R9,0			:init count of command chars
	L	RBP,.FEDBF,RPI
CALL04	TBT	RP,FREDIT
	JE	CMDER1			:if out of chars...invalid command
	JAL	RCH,GETCHR,
	J	CPARAB			:never gets signals!!
	NHI	RBC,7F
	CLHI	RBC,SP
	JNBS	CALL04			:if not cmd name delimiter
:	Found command name delimiter
CALL19	TBT	RP,FREDIT		:eat extra spaces*500.sdw
	JE	CALL30
	JAL	RCH,GETCHR,		:either eat it or seed CALL20
	J	CPARAB
	NHI	RBC,7F
	CLHI	RBC,SP
	JEBS	CALL19		:it was a space so eat it
	JFS	CALL21		:else store for parse
CALL20	TBT	RP,FREDIT
	JE	CALL30			:if all cmd chars copied
	JAL	RCH,GETCHR,
	J	CPARAB
	NHI	RBC,7F		:*500.sdw
CALL21	STB	RBC,CMDBUF,R9		:save cmd char            
CALL22	AIS	R9,1
	J	CALL20			:get the rest of login string

CALL30	LR	R9,R9
	JE	CALER1			:if missing facility
:	Initialize call parameters (defaults, etc.)
	RBT	RP,RPOA.F		:initially...no RPOA
	RBT	RP,ICOD.F		:initially no CUG interlock code
	LHL	RBC,.TERMT,RPI		:terminal type
	LB	RBC,VID.ID,RBC,		:NID
	SHI	RBC,0C0			:remove bias
	LB	RBC,NIDTCL,RBC		:default throughput class
	STB	RBC,TCLASS,RPI		:set in case no tclass facility
	LHI	R6,0FF			
	STB	R6,CUGIND,RPI		:mark CUG not received
	LIS	R6,0			:init index into cmd save buffer
	STB	R6,RVCG.R,RPI		:NO REVERSE CHARGING VALUE.
	RBT	RP,RVCG.F		:NO REVERSE CHARGING

CALL40	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	TBT	RBC,LETTER
	JE	CALER1			:if unrecognized facility
	NHI	RBC,5F			:..else convert letter to UPPER CASE
	CLHI	RBC,4E			:"N" of NUI
	JE	NUI000			:if NUI treat separately
	LIS	R3,3			:..else need 3 chars to recognize fac
	LIS	R4,0			:init facility name accumulator
:	Accumulate 3 facility name characters
CALL50	NHI	RBC,5F			:always UPPER CASE
	OHI	RBC,80			:and mark parity
	SLLS	R4,8
	OR	R4,RBC
	SIS	R3,1
	JLE	CALL60			:if enuf letters to recognize fac
	SIS	R9,1
	JLE	CALER1			:if fac name too short
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	TBT	RBC,LETTER
	JE	CALER1			:if fac name not all letters
	J	CALL50			:..else keep gathering fac name

CALL60	SLLS	R4,8			:pad out fac name with a blank
	OHI	R4,SP!80
:	Find facility type and call its processor
	LHI	R3,FACSIZ
CALL70	SIS	R3,4			:index next facility name
	JL	CALER1			:if no name match
	CL	R4,FACTAB,R3
	JNBS	CALL70			:if not this fac
	SRLS	R3,1			:..else index fac address table
	LHL	RCH,FACADR,R3
	J	BASE,RCH,		:...and go process facility

:	Table of Facility Names
FACTAB	WS
	AC	\REV \
:	AC	\FAS \
	AC	\RPO \
	AC	\CUG \
	AC	\TCL \
:	AC	\RES \
FACSIZ	EQ	(.-FACTAB)

:	Tble of Facility Processor Addresses
FACADR	WS
	HC	REV000-BASE		:REVERSE CHARGING
:	HC	NUI000-BASE		:FAST SELECT
	HC	RPO000-BASE		:RPOA
	HC	CUG000-BASE		:CUG
	HC	TCL000-BASE		:THROUGHPUT CLASS
:	HC	NUI000-BASE		: ?

:	If another facility expected...return here
:	 Otherwise transfer to *FACEND*
FACRTN	SIS	R9,1
	JLE	CALER2			:if expected a fac...but nothing left
	J	CALL40			:..else try for another good fac

:	Facility Processors
:	-------------------

:	NUI
NUI000	SIS	R9,1
	JLE	CALERA
   IF  CUD.MX		:moved and redone *500.sdw
	LIS	R0,0
	ST	R0,CUD.LT,RPI
	ST	R0,CUD.LT+4,RPI
	ST	R0,CUD.LT+8,RPI
	LR	R3,R9		:count of remaining
	LR	R2,R6		:position in CMDBUF
	LB	R0,CUD.LG,RP	:CUD chars and from which side
	THI	R0,CUD.UL
	JN	NUI120		:from left
NUI100	LB	R1,CMDBUF,R2	:from right - search for end to find where to
	NHI	R1,7F		
	TBT	R1,LDELIM		:logon delimiters
	JNFS	NUI121		:go for forward fill
	AIS	R2,1		:another char read
	SIS	R3,1
	JGBS	NUI100
NUI121	NHI	R0,0F		:get desired count
	LR	R4,R2		:r4 is length of username
	SR	R4,R6		:number processed
	LR	R1,R0		:find how many to do (between can and want)
	CR	R1,R4
	JLEFS	NUI125
	LR	R1,R4		:R1 is how many to process
NUI125	AR	R3,R1		:have that many to do now
	SR	R2,R1		:move back how many we are doing
		:now r2 and r3 are setup to do right fill from the left side

:  NUI120 is fill from left   NUI122 is general get and put in CUD
NUI120	NHI	R0,0F		:get count from right
	LIS	R4,0		:where to start putting the chars in CUD.LT
NUI122	LB	R1,CMDBUF,R2	:get the char
	NHI	R1,7F
	TBT	R1,LDELIM		:end our log name
	JNFS	NUI150	:done-let nui logic setup logon string
	STB	R1,CUD.LT,RPI,R4
	AIS	R4,1		:inc counter in CUD.LT
	CR	R4,R0		:how many to do?
	JGEFS	NUI150		:done with CUD
	AIS	R2,1		:inc pos in CMDBUF
	SIS	R3,1		:dec count left
	JGE	NUI122		:get next if there
NUI150	EQ	.
  EI  :CUD.MX

  IF	UUNON
	RBT	RP,NNUMRU		:reset non numeric bit flag to 0
  EI
NUI005	L	RBP,.FTBUF,RPI
	MAKEBF(R1,TOLOG,RP)		:connect from-terminal buffer to logger
	JAL	R3,CHNGBF,,
	RBT	RP,LGECHO		:don't let logger echo
	SBT	RP,UNAME		:username is 1st
	L	RBP,.FEDBF,RPI		:temporary buffer for logon string
NUI010	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	CLHI	RBC,COMMA
	JE	FACRTN			:if end of NUI
	CLHI	RBC,DASH
	JE	FACEND			:if end of NUI and no more facilities
  IF	UUNON
	TBT	RBC,ASDIG		:check whether non-numeric user name
	JN	NUI011			:if numeric user name
	SBT	RP,NNUMRU		:else turn non numeric bit flag to 1
  EI
NUI011	TBT	RP,UNAME
	JE	NUI030			:if in password field...all chars OK
	CLHI	RBC,SEMIC
	JNFS	NUI020			:if not uname terminator
	RBT	RP,UNAME		:  else indicate in password field
	JFS	NUI030			:  and all chars (in CMDBUF) valid

NUI020	CLHI	RBC,COLON
	JE	CALERC			:if "beg of host #"...invalid in cmd mode
	CLHI	RBC,20
	JL	CALERC			:if control char...invalid in cmd mode
NUI030	JAL	RCH,PUTCHR,,		:..else save logon char
	SIS	R9,1
	JLE	FACEND			:if cmd ended...create an address
	J	NUI010			:..else get next logon char

:	RPOA 
RPO000	SIS	R9,1
	JLE	CALERA			:if incomplete RPOA facility
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	CLHI	RBC,EQUALS
	JNBS	RPO000			:if not ready for value
	SIS	R9,1
	JLE	CALERA			:if incomplete RPOA facility
	LIS	R4,0			:accumulate RPOA value here
	LIS	R3,4			:...up to 4 digits
RPO030	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	CLHI	RBC,DASH
	JE	RPOEN1			:if done RPOA and all facilities
	CLHI	RBC,COMMA
	JE	RPOEN2			:if done RPOA...but more facilities
	TBT	RBC,ASDIG
	JE	CALERA			:if not an RPOA digit
	SHI	RBC,ZERO
	SLLS	R4,4
	OR	R4,RBC			:add another BCD digit
	SIS	R3,1
	JL	CALERA			:if >4 digits...bad RPOA value
	SIS	R9,1
	JG	RPO030			:if could be more
RPOEN1	LA	RCH,FACEND		:go here since done facilities
	JFS	RPOEN4

RPOEN2	LA	RCH,FACRTN		:go here to do next facility
RPOEN4	CLHI	R3,4
	JE	CALERA			:if no RPOA digit given...error
	SBT	RP,RPOA.F		:indicate RPOA wanted for this call
	STH	R4,RPOA.R,RPI		:this is the RPOA
	JR	RCH

:	Closed User Group
CUG000	JAL	RCH,FACEQU		:look for "=" sign
	J	CALERA			:if bad facility spec
	JAL	RCH,FACVAL		:look for value
	J	CALERA			:if bad value or no value
	J	CUG020			:if good value...ready for next fac
	NOP	0,0			:if good vaule...done fac
	LA	RCH,FACEND		:if good value...done command
:	RBC contains the index #, RP contains port #
CUG010	STB	RBC,CUGIND,RPI		:save the CUG index #
	CLHI	RBC,MAXCUG
	JG	CALE14			:value not acceptable
	TBT	RP,CUGS.F		:subscribed to CUG?
	JNR	RCH			:yes
	J	CALE15			:CUG not subscribed

CUG020	LA	RCH,FACRTN		:go here for next facility
	J	CUG010

:	Throughput Class
TCL000	JAL	RCH,FACEQU		:look for "=" sign
	 J	CALERA			:if bad facility spec
	JAL	RCH,FACVAL		:look for value
	 J	CALERA			:if bad value or no value
	 J	TCL020			:if good value...ready for next fac
	 NOP	0,0			:if good value...done facs
:	Done facilities or command...good value
	 LA	RCH,FACEND		:if good value...done command
TCL010	STB	RBC,TCLASS,RPI		:save throughput class
	CLHI	RBC,MAXTC
	JLER	RCH			:if value ok
	J	CALE10			:value not acceptable
	JR	RCH

TCL020	LA	RCH,FACRTN		:go here for next facility
	JBS	TCL010


:	REVERSE CHARGING FACILITY REQUEST	REV(ERSE)=0/1
REV000	JAL	RCH,FACEQU		:look for "=" sign
	 J	CALERA			:if bad facility spec
	JAL	RCH,FACVAL		:look for value
	 J	CALERA			:if bad value or no value
	 J	REV020			:if good value...ready for next fac
	 NOP	0,0			:if good value...done facs
	 LA	RCH,FACEND		:if good value...done command

REV010	LB	R3,RVCG.R,RPI		:GET CURRENT REVERSE CHARGE (+ FAST
					: SELECT IN THE FUTURE)
	CLHI	RBC,1			:REVERSE CHARGE CAN ONLY BE 0 OR 1
	JLFS	REV014			:BRANCH IF ZERO
	JEFS	REV012			:BRANCH IF ONE
	J	CALE10			:INVALID VALUE FOR REVERSE CHARGING
REV012
	OHI	R3,01			:SET REVERSE CHARGE BIT
	JFS	REV015			:
REV014	NHI	R3,0F7			:RESET REVERSE CHARGE BIT
REV015	SBT	RP,RVCG.F		:USER SPECIFIED EXPLICITLY SO WE WILL SEND
	STB	R3,RVCG.R,RPI		:SAVE IT FOR DIALECT PROCESSING
	JR	RCH			:AND CONTINUE

REV020	LA	RCH,FACRTN
	J	REV010


:	FACEQU	- Search for equals sign in a  facility
:		Input - R6 = index to *CMDBUF*
:			R9 = count of characters left in *CMDBUF*
:		Returns on RCH, if equals sign not found and R9=0
:			 4,RCH if OK (R6, R9 are updated)
FACEQU	SIS	R9,1
	JLER	RCH			:if incomplete facility
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	CLHI	RBC,EQUALS
	JNBS	FACEQU			:if not ready for value
	SIS	R9,1
	JG	4,RCH			:if still may be a value, OK
	JR	RCH			:  else incomplete facility


:	FACVAL	- Subroutine to get a value for a facility
:		Input - R6 = index to *CMDBUF*
:			R9 = ## chars left
:		Output- RBC = value
:			R6, R9 are updated
:
:		Returns RCH, if error (value>255, non-digit, no value)
:			4,RCH if ready for next facility (comma, RBC=value)
:			8,RCH if end of facilities (dash, RBC=value)
:			C,RCH if end of command (RBC=value)

FACVAL	LCS	RBC,1			:flag to detect no value found
	LIS	R3,0A			:multiplier to accumulate decimal value
FACVA2	LB	R0,CMDBUF,R6                                      
	AIS	R6,1
	NHI	R0,7F
	CLHI	R0,COMMA
	JE	FACVA6			:if ready for next facility...check value
	CLHI	R0,DASH
	JE	FACVA8			:if done facs...check value
	TBT	R0,ASDIG
	JER	RCH			:if non-digit...error
	LR	RBC,RBC
	JGEFS	FACVA4			:if started to accumulate value
	LIS	RBC,0			:  else remove flag since digit found
FACVA4	SHI	R0,ZERO			:convert to decimal
	MHR	RBC,R3			:multipy last value by 10
	AR	RBC,R0			:...and add in new digit
	CLHI	RBC,0FF
	JGR	RCH			:if value > 255...error
	SIS	R9,1
	JG	FACVA2			:if still more chars in buffer
	J	0C,RCH			:  else done with command...good value

FACVA6	LR	RBC,RBC
	JLR	RCH			:if no value...error
	J	4,RCH

FACVA8	LR	RBC,RBC
	JLR	RCH			:if no value...error
	J	8,RCH



:	If no more facilities expected...return here
FACEND

:	Find the corresponding interlock code if subscribed to CUG
CALCUG
	TBT	RP,CUGS.F		:subscribed to CUG?
	JE	CALTCL			:no
	LB	RBC,CUGIND,RPI		:CUG = nn received in call command?
	CLHI	RBC,0FF		
	JNFS	CCUG10			:CUG=nn received in call command
	LB	RBC,CUP.PT,RP		:use preferential CUG
	STB	RBC,CUGIND,RPI		:store it
CCUG10	LHI	R5,(NPORT+1F)/20	:get # of words storage for each
					: index bit array
	SIS	R5,1
	SLL	RBC,0,R5
	SLLS	RBC,2			:get index into CUI.PT table
	TBT	RP,CUI.PT,RBC		:check bit array for this port
	JE	CALE16			:this port is not configured to use
					: such index
	LB	R5,CUGIND,RPI		:get cug index
	SLLS	R5,2			:get index into CUGTAB table
	L	R3,CUGTAB,R5		:get interlock code
	JE	CALE16			:error if no interlock code present
	SBT	RP,ICOD.F		:set bit flag for later sending out
					: interlock code

:	Set throughput class by putting gouging level in .FTBUF
CALTCL	L	RBP,.FTBUF,RPI
	LB	RBC,TCLASS,RPI		:CCITT throughput class
	LB	RBC,CTCTOG,RBC		:...and corresponding gouging level
	JAL	RCH,PUTCHR,,


:	Full Address Processor
:	----------------------
CALADR	SIS	R9,1
	JG	CALA40			:if address or CUD may be present
:	No address given...use NUI
CALA04	TBT	RP,FREDIT
	JE	CALER3			:if no NUI
	L	RBP,.FEDBF,RPI
	JAL	RBF,IGCSCN
	J	CPARAB
	JAL	RBF,GCSCN
	J	CPARAB
	CLHI	RBC,NINE
	JN	CALA32			:if non-numeric username
:	Numeric username... rest of Calling adr is 9 + NUN
	LIS	R3,4			:Calling addr length for now
	LIS	R4,3			:offset into port's Clg addr array
CALA15	SHI	RBC,ZERO		:convert to BCD
	LR	RCH,RBC			:1st digit of a pair
	JAL	RBF,GCSCN
	J	CALA20			:if done sacn
	TBT	RBC,ASDIG
	JE	CALER4			:if not totally numeric username
	SHI	RBC,ZERO		:..else convert digit to BCD
	SLLS	RCH,4
	OR	RCH,RBC
	STB	RCH,DTECLG,R5,R4
	AIS	R4,1
	AIS	R3,2
	JAL	RBF,GCSCN
	J	CALA30
	TBT	RBC,ASDIG
	JN	CALA15			:if got another digit
	J	CALER4

:	Odd # adr digits
CALA20	SLLS	RCH,4			:put single digit in left nibble
	STB	RCH,DTECLG,R5,R4
	AIS	R3,1
:	Even # adr digits
CALA30	STB	R3,DTECLG,R5		:update length
CALA32	LIS	R0,0
	STB	R0,DTECLD,R5,		:use no called address
:	Copy NUI to buffer for logger
	JAL	RCH,COPNUI		:copy NUI and append a <CR>
	J	CALEND			:wrap up call setup

:	Address or CUD present
CALA40	LR	R5,RPI
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	CLHI	RBC,DOT
	JE	ABBADR			:if start of abbreviated address
	TBT	RBC,ASDIG
	JE	CALA74			:if not adr...see if CUD
	SHI	RBC,ZERO		:..else convert to BCD
	JN	CALA80			:if not start of host #
	SIS	R6,1			:BACK UP POINTER TO PICK LEADING ZERO
:	Called address must be OURDNI + 0 + <up to 5 digit host #> + <subadr>
CALA42	TBT	RP,RPOA.F
	JN	CALERE			:if RPOA on our (intra)net...error
	LR	R2,R6			:copy index
	LR	R3,R9			:copy count
	LIS	R0,0			:adr length accumulator
CALA45	LB	RBC,CMDBUF,R2                                     
	AIS	R2,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JEFS	CALA48			:if not a digit...assume adr just ended
	AIS	R0,1			:..else count another digit
	SIS	R3,1
	JGBS	CALA45			:if more chars left
:	Copy username to logon buffer
CALA48	TBT	RP,FREDIT
	JE	CALA52
	L	RBP,.FEDBF,RPI
	JAL	RCH,GETCHR,
	J	CPARAB
	CLHI	RBC,SEMIC
	JEFS	CALA52			:if username delimiter
	L	RBP,.FTBUF,RPI
	JAL	RCH,PUTCHR,,
	J	CALA48

CALA52	L	RBP,.FTBUF,RPI
	LHI	RBC,COLON
	JAL	RCH,PUTCHR,,
:	Called Address = OURDNI + 0 + <5 digit host #> [+ . + subaddress]
	LR	R5,RPI
	LIS	R0,4
	STB	R0,DTECLD,R5
	LHL	R0,OURDNI
	EXBR	RBC,R0
	STB	RBC,DTECLD+1,R5
	STB	R0,DTECLD+2,R5
:	Copy address into logon buffer and save cells until done or non-digit
	LIS	R0,6			:# host adr digits 
	STH	R0,TEMP			:...after this will be subaddress
CALA54	SIS	R9,1
	JL	CALA68			:if already taken last char
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JE	CALA68			:if address just ended
:	Save called address digit
	SHI	RBC,ZERO		:convert to BCD
	LR	R5,RPI
	LB	R4,DTECLD,R5
	AIS	R4,1
	CLHI	R4,0E
	JG	CALER5
	STB	R4,DTECLD,R5
	SRLS	R4,1			:form offset into save cell
	JCFS	CALA56			:if this digit is 1st of a pair
	LB	R0,DTECLD,R5,R4
	OR	RBC,R0
	JFS	CALA60

CALA56	AIS	R4,1
	SLLS	RBC,4
CALA60	STB	RBC,DTECLD,R5,R4
	LB	RBC,CMDBUF-1,R6		:get digit back           
	JAL	RCH,PUTCHR,,		:...and put it in buffer for logger
	LHL	R0,TEMP                                           
	SIS	R0,1
	STH	R0,TEMP                                           
	JG	CALA54			:if no subaddr yet
	LIS	R0,0F			:..else never another dot
	STH	R0,TEMP                                           
	LHI	RBC,DOT
	JAL	RCH,PUTCHR,,		:subaddress delimiter for SUP
	J	CALA54

:	Copy rest of NUI to logon buffer
CALA68	LIS	RBC,CR
	TBT	RP,FREDIT
	JEFS	CALA70			:if no password...terminate logon string
	LHI	RBC,SEMIC		:  else terminate host number
CALA70	JAL	RCH,PUTCHR,,
	JAL	RCH,COPNUI		:copy pw and append a terminator(CR)
	LR	R9,R9
	JL	CALEND			:if done call setup command
CALA74	SIS	R6,1			:..else back up ptr to next char
	J	CALCUD			:...and go process Call user data

:	See if DNIC given or direct call
CALA80	CLHI	RBC,9
	JNFS	CALA82			:if DNIC given
	SIS	R9,1
	JG	CALER6			:if direct call and more than 1 digit
	J	CALA04			:..else process as if no address given

:	DNIC given - see if it is ours
CALA82	LR	R4,RBC
	LIS	R3,3			:need # more DNIC digits
CALA84	SIS	R9,1
	JLE	CALER7			:if DNIC too short
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JE	CALER7			:if DNIC not all numeric
	SHI	RBC,ZERO		:..else convert digit to BCD
	SLLS	R4,4
	OR	R4,RBC
	SIS	R3,1
	JG	CALA84			:if need more DNIC digits
	LIS	R3,4			:Called adr length for now
	EXBR	RBC,R4
	STB	RBC,DTECLD+1,R5
	STB	R4,DTECLD+2,R5
	CLH	R4,OURDNI
	JNFS	CALA86			:if not our DNIC
	SIS	R9,1
	JL	CALERB			:if called adr is too short
	J	CALA42

:	Not our DNIC - finish called address
CALA86	LIS	R4,3			:cld adr digit offset (past DNIC)
CALA88	SIS	R9,1
	JLE	CALA95
	LB	R0,CMDBUF,R6                                      
	AIS	R6,1
	NHI	R0,7F
	TBT	R0,ASDIG
	JE	CALA94
	SHI	R0,ZERO
	SIS	R9,1
	JLE	CALA92
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JE	CALA91
	SHI	RBC,ZERO
	SLLS	R0,4
	OR	R0,RBC
	STB	R0,DTECLD,R5,R4
	AIS	R4,1
	AIS	R3,2
	J	CALA88

:	Odd number of adr digits
CALA91	SIS	R6,1
CALA92	SLLS	R0,4
	STB	R0,DTECLD,R5,R4
	AIS	R3,1
	JFS	CALA95

:	Even # adr digits
CALA94	SIS	R6,1
CALA95	STB	R3,DTECLD,R5		:save length
	STH	R6,CATEMP		:save *CMDBUF* index
:	Construct logon string
CALA96	TBT	RP,FREDIT
	JE	CALA98
	L	RBP,.FEDBF,RPI
	JAL	RCH,GETCHR,,
	J	CPARAB
	CLHI	RBC,SEMIC
	JEFS	CALA98
	L	RBP,.FTBUF,RPI
	JAL	RCH,PUTCHR,,
	J	CALA96

CALA98	L	RBP,.FTBUF,RPI
	LHI	RBC,COLON
	JAL	RCH,PUTCHR,,
	LHI	RBC,SUDNIC		:DNIC prefix in username address
	JAL	RCH,PUTCHR,,
	LA	R6,DTECLD+1,RPI		:ptr to DNIC digits
	LIS	RBC,4			:always 4
	JAL	RCH,COPADR		:append to login string
:	If RPOA present add it as a subaddress
	TBT	RP,RPOA.F
	JE	CALA99
	LHI	RBC,SURPOA		:RPOA prefix in username address
	JAL	RCH,PUTCHR,,
	LA	R6,RPOA.R,RPI		:ptr to RPOA digits
	LIS	RBC,4			:always 4
	JAL	RCH,COPADR		:append to login string
CALA99	L	RBP,.FTBUF,RPI
	LIS	RBC,CR
	TBT	RP,FREDIT
	JEFS	CALA9A			:if no password...terminate logon str
	LHI	RBC,SEMIC		:  else terminate address
CALA9A	JAL	RCH,PUTCHR,,
:	Copy password (if present, also terminate logon string)
	JAL	RCH,COPNUI		:copy rest of NUI and append a CR
	LR	R9,R9
	JLE	CALEND
	LHL	R6,CATEMP		:restore *CMDBUF* index
	J	CALCUD

:	Abbreviated Address Processor
:	-----------------------------
ABBADR	SIS	R9,1
	JLE	CALER1
	TBT	RP,RPOA.F
	JN	CALERE			:if RPOA used...error
:	Count host # digits (to calculate zero fill)
	LR	R2,R6			:index
	LR	R3,R9			:count
	LCS	R4,1			:flag indicates counting host adr digits
	LIS	R0,0			:# host adr digits
ABBA04	LB	RBC,CMDBUF,R2                                     
	AIS	R2,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JEFS	ABBA10
	AIS	R0,1
	J	ABBA12

ABBA10	CLHI	RBC,DOT
	JN	ABBA20			:if not start of subaddress
	LR	R4,R4
	JGE	CALER8			:if >1 subaddress delimiter
	CLHI	R0,5
	JG	CALER5			:if too many host adr digits
	STH	R0,TEMP		:save # of host address digits
	LIS	R4,0			:indicate done with host adr scan
	LIS	R0,0			:start subaddress digit count
ABBA12	SIS	R3,1
	JLEFS	ABBA21			:if done call setup
	J	ABBA04

ABBA20	CLHI	RBC,STAR
	JN	CALER8			:if not adr digit or adr terminator
ABBA21	LR	R4,R4
	JGEFS	ABBA22			:if subaddress was present
	CLHI	R0,5
	JG	CALER5			:if too many host adr digits
	STH	R0,TEMP			:..else save # host adr digits
	JFS	ABBA23

ABBA22	CLHI	R0,4
	JG	CALER5			:if too many subadr digits
:	Called adr = OURDNI + (6- # of host adr digits) of zero fill + subadr
ABBA23	LR	R5,RPI
	LHL	R0,OURDNI
	EXBR	RBC,R0
	STB	RBC,DTECLD+1,R5
	STB	R0,DTECLD+2,R5
:	Calculate zero fill  (to make a 6-digit host number)
	LIS	RBC,0
	LHL	R0,TEMP			:# host adr digits
	LIS	R2,6
	SR	R2,R0
	STH	R2,TEMP			:no. of zero digits to add
	JLEFS	ABBA28			:if full host adr
	SRLS	R2,1			:..else index for zero filling
ABBA26	STB	RBC,DTECLD+3,R5,R2
	SIS	R2,1
	JGEBS	ABBA26			:if more zero filling needed
ABBA28	LIS	R0,4
	AHM	R0,TEMP			:count DNIC in called address
:	Copy username and a : TO logon buffer
ABBA30	TBT	RP,FREDIT
	JE	ABBA34
	L	RBP,.FEDBF,RPI
	JAL	RCH,GETCHR,,
	J	CPARAB
	CLHI	RBC,SEMIC
	JEFS	ABBA34			:if username terminator
	L	RBP,.FTBUF,RPI
	JAL	RCH,PUTCHR,,
	J	ABBA30

ABBA34	L	RBP,.FTBUF,RPI
	LHI	RBC,COLON
	JAL	RCH,PUTCHR,,
:	Copy host adr and subaddress to logon buffer and save cells
ABBA36	LR	R5,RPI
	LB	RBC,CMDBUF,R6                                     
	AIS	R6,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JE	ABBA42
	LR	R4,RBC
	SHI	R4,ZERO
	LHL	R3,TEMP                                           
	AIS	R3,1			:count another called address digit
	STH	R3,TEMP                                           
	SIS	R3,1			:...but not for indexing purposes
	SRLS	R3,1
	JNCFS	ABBA38			:if this digit is 1st of a pair
	LB	R0,DTECLD+1,R5,R3
	OR	R4,R0
	JFS	ABBA39

ABBA38	SLLS	R4,4
ABBA39	STB	R4,DTECLD+1,R5,R3
ABBA40	JAL	RCH,PUTCHR,,		:put digit in logon buffer (Uses R5!)
	SIS	R9,1
	JLEFS	ABBA43
	J	ABBA36

ABBA42	CLHI	RBC,DOT
	JE	ABBA40			:if start of subaddress
ABBA43	LHL	R0,TEMP                                           
	LR	R5,RPI
	STB	R0,DTECLD,R5,		:save called address length
	LIS	RBC,CR
	TBT	RP,FREDIT
	JEFS	ABBA50			:if no pword...terminate logon string
	LHI	RBC,SEMIC		:  else terminate address
ABBA50	JAL	RCH,PUTCHR,,
	JAL	RCH,COPNUI		:append password and <CR>
	SIS	R9,2			:count last adr digit and terminator
	JLE	CALEND
	J	CALCUD

:	Call User Data Handler
:	------------------------
: upper nibble - CUDHEX bit set
: lower nibble - CUDHEX bit off
: R0 - scratch
: R6 - index into CMDBUF
: R9 - number of characters in CMDBUF
: RBC - Hex character
:
CALCUD	JAL	RCH,COPNUI		:make sure NUI sent to logger
	L	RBP,.FEDBF,RPI		:locate From Edit Buffer
	RBT	RP,CUDHEX		:clear first char - upper digit
	LB	RBC,CMDBUF,R6           :get first character
	AIS	R6,1			:increment index into CMDBUF
	NHI	RBC,7F			:clear high order bit
	TBT	RBC,LETTER		:is character a letter?
	JE	CALER9			:no, error-unknown call user data type
	NHI	RBC,5F			:convert to UPPER CASE
	CLHI	RBC,50			:"P", ascii - not echoed at term?
	JEFS	CALCU2			:yes, process P data
	CLHI	RBC,44			:"D", ascii - echoed at term?
	JEFS	CALCU2			:yes, process D data
	CLHI	RBC,48			:"H", hexadecimal, echo if X.3P2=1?
	JN	CALER9			:no, error-unknown call user data type
	J	CALCU6			:yes, process "H" data

: ASCII CHARACTER IN CUD
CALCU2	CLHI	R9,$A12			:CUD > 12 characters?
	JG	CALERF			:yes, error-CUD data too long
CALCU4	SIS	R9,1		:dec # of characers in CMDBUF, completed?
	JL	CALEND			:yes, go to cleanup for call set up
	LB	RBC,CMDBUF,R6           :no, get next character
	AIS	R6,1			:increment index into CMDBUF 
	JAL	RCH,PUTCHR,,		:put character into buffer
	JBS	CALCU4			:return for next character

: HEX DIGITS IN CUD

CALCU6	CLHI	R9,$A24		: >24 ?
	JG	CALERF		: CUD TOO LONG
	THI	R9,1		:IS # OF DIGITS ODD?            :DLG 11-Apr-86
	JG	CALE17		:YES, ERROR MUST BE GIVEN IN PAIRS
CALCU8	SIS	R9,1		:DONE WITH CUD?
	JL	CALEND		:YES, GO TO CLEANUP FOR CALL SETUP
	LB	R0,CMDBUF,R6	:NO, GET NEXT CHAR             
	AIS	R6,1		:INCREMENT INDEX
	NHI	R0,7F		:CLEAR HIGH ORDER BIT
	TBT	R0,ASDIG	:IS IT A DIGIT?
	JNFS	CALCUA		:YES, PROCESS DIGIT
	TBT	R0,UASHEX	:NO, IS IT UPPER CASE A-F ?
	JNFS	CALCU9		:YES, PROCESS UPPER CASE CHAR
	TBT	R0,LASHEX	:NO, IS IT LOWER CASE A-F
	JE	CALERH		:NO, ERROR MSG ILLEGAL HEX DIGIT
	SHI	R0,20		:CHANGE LOWER CASE TO UPPER
CALCU9	SHI	R0,37		:ASCII TO BINARY (A -> 1010 ETC.)
	JFS	CALCUB		:JUMP TO COMMON ROUTINE

CALCUA	SHI	R0,ZERO		:ASCII TO BINARY
CALCUB	TBT	RP,CUDHEX	:THIS DIGIT IN UPPER NIBBLE ?
	JNFS	CALCUE		:NO, LOWER NIBBLE
	SBT	RP,CUDHEX	:TOGGLE FLAG
	LR	RBC,R0		:COPY
	SLLS	RBC,4		:SHIFT LEFT BY 4
	J	CALCU8		:AND TRY TO GET ANOTHER CHAR

: GET TWO DIGITS AND MOVE INTO BUFFER
CALCUE	RBT	RP,CUDHEX	:TOGGLE THE FLAG
	OR	RBC,R0		:COMBINE TWO DIGITS
	JAL	RCH,PUTCHR,,
	J	CALCU8		:GO GET ANOTHER CHAR

: REMOVED 44/11/86 USER MUST SPECIFY HEX PAIRS OF DIGITS, IF THEY DO NOT
: ERROR MESSAGE(304) WILL BE DISPLAYED ON THEIR TERMINAL.
: HERE IF DONE WITH C.U.D., SEE IS THERE A LEFT-OVER DIGIT IN RBC
:CALCUF	TBT	RP,CUDHEX	:WAS LAST NIBBLE THE UPPER ONE?
:	JEFS	CALCUI		:NO, JUMP
:	JAL	RCH,PUTCHR,,	:YES, SEND IT WITH ZERO IN LOWER NIBBLE
:CALCUI	J	CALEND

::	DEFADR	- place default address in an array for port
:			(default adr= OURDNI + "7" + host number)
:		Input - RP = port-number
:			R3 = base of adr array (calling or called)
:		       RP2 = port-number*2
:		       RPI = port-table pointer
:			(CHOST)= table of host numbers in BCD
:		Link on RCH
:		Destroys R0,R3

DEFADR
	LIS	R0,0A
	STB	R0,0,R3
	LB	R0,OURDNI
	STB	R0,1,R3
	LB	R0,OURDNI+1
	STB	R0,2,R3
  IF	UUNON
	TBT	RP,NNUMRU		:check whether non numeric user name
	JE	DEFA00			:if not
  :Using UUN value for calling address
	LR	R2,RP
	LB	R0,UUNVAL+1,RPI		:get the second byte of UUN value
	STB	R0,3,R3
	LHL	R0,UUNVAL+2,RPI		:get the rest of UUN val   
	J	DEFA10
  EI
  :Normal calling address processing
DEFA00
	LR	RP2,RP			:compute 2*port number
	AR	RP2,RP2
	LB	R0,CHOST+1,RP2,RP2	:get first byte of host number
	OHI	R0,70			:insert 7
	STB	R0,3,R3			:store
	LHL	R0,CHOST+2,RP2,RP2	:get last part of host number
DEFA10	STH	R0,4,R3			:store
	JR	RCH			:return


::	COPNUI	- if anything in *.FEDBF* (eg. NUI) copy to *.FTBUF*
:			and append a <CR>
:		Input - RP = port number
:		Link on RCH
:		Destroys R0-5,R8,TEMP,TEMP+4

COPNUI	TBT	RP,FREDIT
	JER	RCH			:if nothing to copy...return
	ST	R6,TEMP                                           
	ST	RCH,TEMP+4                                        
	L	RBP,.FEDBF,RPI
	LHI	RBC,CR
	JAL	RCH,PUTCHR,,		:terminate string in *.FEDBF*
	L	R5,.FEDBF,RPI		:source buffer
	L	R6,.FTBUF,RPI		:dest buffer
	JAL	RCH,MCI,,		:copy and return
	L	R6,TEMP                                           
	L	R7,TEMP+4                                         
	JR	RCH

::	COPADR	- convert a string of BCD digist to ASCII and copy to buffer
:		Input - RBC = # digits to convert and copy
:			RBP = buffer to copy into
:			R6  = pointer to start of digits
:		Link on RCH
:		Destroys R0-8,TEMP,TEMP+4

COPADR	LR	R0,RBC
	JER	RCH			:if nothing to copy
	ST	RCH,TEMP		:save link
COPAD2	STH	R0,TEMP+4		:save # digits left
	LB	RBC,0,R6		:digit pair
	SRLS	RBC,4			:1st BCD digit
	AHI	RBC,30			:convert to ASCII
	CLHI	R0,1
	JEFS	COPAD6			:if last digit...copy and return
	JAL	RCH,PUTCHR,,
COPAD4	LB	RBC,0,R6		:same digit pair
	NHI	RBC,0F			:2nd digit
	AHI	RBC,30			:convert to ASCII
COPAD6	JAL	RCH,PUTCHR,,
	AIS	R6,1			:point at next pair
	LHL	R0,TEMP+4
	SIS	R0,2
	JG	COPAD2			:if more digits to copy
	L	RCH,TEMP                                          
	JR	RCH



:	Cleanup for Call setup
:	---------------------
CALEND	SBT	RP,PNMODE                                         
	SBT	RP,LOGER
	SBT	RP,LOGING
:	RBT	RP,ECHO
:	RBT	RP,X3.P2,,
	RBT	RP,COMTO		:turn off command state timout
  IF	NPAPRT
:
: TURN OFF LIMBO SO THAT HOST WILL BE MARKED AS SMART IN PSEUDO NEEDLE REQ
	RBT	RP,LIMBO
:
  EI
	LHI	R5,SPECFE+$04000	:special features to use upon...
					:Talk IIX and want extended
					:  login status
  IF	UUNON
	TBT	RP,NNUMRU		:check whether non numeric user name
	JEFS	CALEN0			:if not, "U"  bit is off
	AHI	R5,2000			:else, turn the "U" bit on
  EI
CALEN0	JAL	RLINK,ESTPRT		:request a pseudo needle
	LIS	R0,X3CIP
	STB	R0,X3STAT,RPI                                     
	LA	R0,XLOGIN 		:Transfer address for...
	ST	R0,.LSTAT,RPI		:special logon status handler
	J	EDRTN

:	Errors in Call Setup Command Processing
:	---------------------------------------
CALER1	LA	R6,SS.CS1,,		:facility name not recognized
	J	CALERR

CALER2	LA	R6,SS.CS2,,		:Missing facility
	J	CALERR

CALER3	LA	R6,SS.CS3,,		:No address and no NUI
	J	CALERR

CALER4	LA	R6,SS.CS4,,		:Numeric username not completely numeric
	J	CALERR

CALER5	LA	R6,SS.CS5,,		:Too many host or subaddress digits
	J	CALERR

CALER6	LA	R6,SS.CS6,,		:Incorrect direct call address
	J	CALERR

CALER7	LA	R6,SS.CS7,,		:Incomplete DNIC specified
	J	CALERR

CALER8	LA	R6,SS.CS8,,		:Missing abbreviated address terminator
	J	CALERR			:...or inavlid host or subaddress char

CALER9	LA	R6,SS.CS9,,		:Invalid address digit
	J	CALERR

CALERA	LA	R6,SS.CSA,,		:fac used without value
	J	CALERR

CALERB	LA	R6,SS.CSB,,		:called address < 6 digits
	J	CALERR

CALERC	LA	R6,SS.CSC,,		:ptr to text string
	J	CALERR

CALERD	LA	R6,SS.CSD,,		:call already in progress
	J	CALERR

CALERE	LA	R6,SS.CSE,,		:RPOA invalid on intranetwork calls
	J	CALERR

CALERF	LA	R6,SS.CSF,,		:call user data too long
	J	CALERR

CALE10	LA	R6,SS.C10,,		:invalid througput class value
	J	CALERR

CALE14	LA	R6,SS.C14,,		:invalid CUG index value
	J	CALERR		

CALE15	LA	R6,SS.C15,,		:CUG not subscribed
	J	CALERR

CALE16	LA	R6,SS.C16,,		:undefined CUG index
	J	CALERR

CALE17	LA	R6,SS.CSG,,  :odd no. of digits-must be in pairs :DLG 11-Apr-86
	J	CALERR

CALERH	LA	R6,SS.CSH,,		:illegal hex digit in CUD
:	J	CALERR

CALERR	L	RBP,.FEDBF,RPI
	JAL	RCH,EMPTY,,
	L	RBP,.LGBUF,RPI
	JAL	RCH,EMPTY,,
	L	RBP,.FTBUF,RPI
	JAL	RCH,EMPTY,,
	RBT	RP,CALCMD		:no longer proc call setup
	TBT	RP,CALPRG
	JNFS	CALE50			:if call in prog...don't reset cldadr
	LIS	R0,0
	STB	R0,DTECLD,RPI
CALE50	TBT	RP,X3.P2
	JE	CMDERR			:if don't need to turn echo back on
	SBT	RP,ECHO
	J	CMDERR			:go send service signal


:	Alternate logon status handler for calls placed in command mode
:	---------------------------------------------------------------

:	Entry from *XLSTAT* or from *INPUT* (via *CALABT*)
:	Link on R8 (or on RLINK)
:	Maps SUP messages into X.28 service signals
:	Input - R9=message number
:	Output - R9=0 (so *XLSTAT* falls thru)

:	Table of pointers to service signals for SUP messages
	HC	SS.LS1-BASE		:login aborted
	HC	SS.LS2-BASE		:no paths
	HC	SS.LS3-BASE		:zapper
	HC	SS.LS4-BASE		:got a psn
X3LMSG	HC	0
	HC	SS.LS6-BASE		:please login
	HC	SS.LS7-BASE		:error, username
	HC	SS.LS8-BASE		:error, password
	HC	SS.LS9-BASE		:username
	HC	SS.LSA-BASE		:password
	HC	0
	HC	0
	HC	SS.C5-BASE		:pls see your rep... 
	HC	SS.C5-BASE		:bad mud
	HC	SS.C5-BASE		:circuit busy
	HC	SS.CD-BASE		:host not available
	HC	SS.C1-BASE		:host out of ports
	HC	SS.C9-BASE		:host down
	HC	SS.C9-BASE		:host shut
	HC	SS.C5-BASE		:try again in 2 minutes
	HC	SS.CB-BASE		:access not permitted
	HC	SS.CD-BASE		:no host specified
	HC	SS.CD-BASE		:bad host number
	HC	SS.C5-BASE		:mud error
MXLMSG	EQ	(.-X3LMSG)/2

XLOGMG  WC      03000100        :bad logons (bad username, pw or host)*500.sdw

XLOGIN	LR	R9,R9			:
	JLER	R8			:if zero or neg, then ignore
	CHI	R9,MXLMSG		:check R9 upper limit
	JGER	R8			:if error, just ignore and exit
	LR	RLINK,R8		:copy link reg
	L	RBP,.FTBUF,RPI		:
	JAL	RCH,EMPTY,,		:flush input to logger
	L	RBP,.FEDBF,RPI		:
	JAL	RCH,EMPTY,,		:...and editing buffer
	LHL	RCH,X3LMSG,R9,R9	:get message poinrter
	JER	RLINK			:exit if no service signal
        LHI     R0,4,R9			:make r0 pos index for TBT *sdw.500
	TBT	R0,XLOGMG		:invalid logon attempt?
	JE	XLOGI4			:
	LB	R0,NRENTR,RPI		:count invalid attempts
	AIS	R0,1			:
	CLHI	R0,MAXREN		:reached max retries?
	JGE	XLOGI8			:if entered command state > max times
	STB	R0,NRENTR,RPI		:
XLOGI4	LB	R9,X3.P6,RPI		:get X.3 parameter 6 
	THI	R9,X3.6NP		:service signal wanted?
	JEFS	XLOGI5			:no, skip
	L	RBP,.TTBUF,RPI		:yes, process
	LA	R6,BASE,RCH,		:get pointer to service signal
	JAL	R5,OUTSTR,,		:send msg to user
XLOGI5	THI	R9,X3.6P		:prompt wanted?
	JEFS	XLOGI6			:no, skip
	LA	R6,SS.PMT,,		:yes get pointer
	JAL	R5,OUTSTR,,		:send msg
XLOGI6	LIS	R0,0			:
	ST	R0,.LSTAT,RPI		:remove special logon status handler
	JAL	R9,CLRCAL		:cancel call - reset flags
	LIS	R9,0			:suppress normal logon status messages
	J	CIRDSC			:disconnect port from network

:	Command state re-entry count exceeded...hang port
XLOGI8	SERSIG(SS.E80,,TTBUF)		:entered cmd state too many times
	 LO	SIGNAL
	LIS	R4,HNGSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:put hang signal in buffer
	LIS	R9,0			:may need to suppress logon msgs
	J	CIRDSC			:disconnect circuit


:	Successful Logon Handler 
:	------------------------
:	Returns to *INPUT*
CALOK	TBT	RP,PADACT		:port in command mode?
	JEFS	CALOK2			:no, login mode...allow typeahead
	TBT	RP,TOLOG		:
	JN	CALABT			:if user gave unneeded password...error
CALOK2	L	RBP,.FTBUF,RPI		:
	MAKEBF(R1,TOISIS,RP)		:
	JAL	R3,CHNGBF,,		:re-connect logon buffer to net
	TBT	RP,IIXCAL		:
	JNR	RLINK			:if smart...will connect later
:	Entry point for *IIXCAL* calls (called by depacketizer)
CALCON	SBT	RP,CALPRG		:indicate call in progress
	RBT	RP,CALCMD		:...and end of call setup command
	RBT	RP,ALLOWU		:username is OK
	LIS	R0,0			:
	STB	R0,NRENTR,RPI		:reset re-entry count for cmd state
	LHL	R0,EBSIZE,RP,RP		:
	STH	R0,PSIZE,RPI		:"packet size" is edit buffer size
	LIS	R0,X3DAT		:
	STB	R0,X3STAT,RPI		:now in data state        
	TBT	RP,PADACT		:test if call setup made in cmd mode
	JEFS	CALC50			:no, call made in login mode
	LIS	R0,0			:yes, call made in command mode
	ST	R0,.LSTAT,RPI		:clear logon status filter pointer
	LA	R6,SS.CON,,		:
	L	RBP,.ECOBF,RPI		:
	JAL	R5,OUTSTR,,		:send connect msg to echo buffer
CALC50	JR	RLINK			:return


:	Call aborted -- unnecessary password given
:	------------------------------------------
CALABT	L	RBP,.FTBUF,RPI		:
	JAL	RCH,EMPTY,,		:flush data to-logger
	L	RBP,.TTBUF,RPI		:
	JAL	RCH,EMPTY,,		:flush data to-terminal
	LR	R8,RLINK		:return address for logon stat handler
	LIS	R9,3			:bad password error type
	J	XLOGIN			:tell DTE and can circuit




:	Clear Call Command Processor (CCITT and Extended)
:	============================

CCCLR	TBT	RP,CALPRG		:check if call in progress
	JE	CLRER1			:no, must be error
	LIS	R0,0			:for now just give 0,0 as
	STH	R0,PSDIAG,RPI		:cause and diagnostic values
	JAL	R9,GETVAL		:..else get user diag value
	 J	CCCLR4			:if no user value
	STB	RBC,PSDIAG+1,RPI	:set diag value
CCCLR4	LA	R0,XPADFI		:restore normal xmit filter
	ST	R0,.XPADF,RPI		:
	LIS	R0,0			:prepare to initialize char byte cnt
	STH	R0,P.BCT,RPI		:init char byte cnt to zero  *6.02 dlg
	L	RBP,.TTBUF,RPI		:
	JAL	RCH,EMPTY,,		:flush to-terminal buffer
	L	RBP,.FEDBF,RPI		:
	JAL	RCH,EMPTY,,		:flush edit buffer
	L	RBP,.FTBUF,RPI		:
	JAL	RCH,EMPTY,,		:flush input buffer
	SBT	RP,PADACT   		:"CLR" always returns to command mode   
	TBT	RP,TURKEY		:check if packet mode
	JE	CCCLR6			:skip if not packet mode
	ST	R9,CATEMP		:
	JAL	R9,SENCLR		:send clear toward network 
	L	R9,CATEMP		:
	LIS	R0,X3PAW		:back in waiting state
	STB	R0,X3STAT,RPI                                      
	J	EDRTN

CCCLR6	SERSIG(SS.CC1)
	JAL	R9,CLRCAL		:reset call parameters
	LIS	R0,X3PAW		:
	STB	R0,X3STAT,RPI		:insure PAD waiting state   
	JAL	RLINK,CIRDIS,,		:disconnect circuit
	LA	RLINK,EDRTN		:prepare for return to EDRTN
	LIS	R0,X3PAW		:back in waiting state
	STB	R0,X3STAT,RPI                                      
	LHI	R5,SPECFE		:special features wanted
	J	ESTPRT,,		:request a psn

CLRER1	LA	R6,SS.NOC,,		:no calls in progress error
	J	CMDERR			:


:	CLRCAL	- Reset call parameters and initial state
:		Since we are originating a zapper, we must reset the
:		 same parameters as would be reset if a zapper were received
:		 (see *ZAPPER* if making changes in this routine)
:		DESTROYS R0
:		Link on R9
:
:	clear call but leave profile parameter untouched
CLRCAL	RBT	RP,DEM			:Turn off DEM
	RBT	RP,GBO			:no green-ball out
	SBT	RP,NBO			:no ball out
	RBT	RP,E.ESC		:turn off Echo-ESC
	RBT	RP,Q.MODE		:turn off Q-mode
	SBT	RP,LGECHO		:
	TBT	RP,HAFDUX		:
	JEFS	CANC10			:if port not echoing local
	RBT	RP,LGECHO		:  else turn off logger echo
CANC10	RBT	RP,CALPRG		:no calls in progress
	RBT	RP,IIXCAL		:no IIX calls in progress
	RBT	RP,TURKEY		:
	RBT	RP,XTGATE		:no gateway calls in prog
	RBT	RP,CALCMD		:
	RBT	RP,X3.P8		:not discarding data from Network
	RBT	RP,DNPROG		:
	RBT	RP,PIIX			:
	RBT	RP,RESOUT		:no resets out
	RBT	RP,FLUNCR		:don't flush any input
	RBT	RP,EXTCAL		:
	JEFS	CANC15			:if call was not incoming
	LA	R3,DTECLG,RPI		:  else port becomes clgadr (again)
	JAL	RCH,DEFADR		:
CANC15
    IF	NPAPRT
	JAL	R0,PA.SL,,		:port may be back in limbo
    EI
	LIS	R0,0			:
	STH	R0,PREVCH,RPI		:unlikely last character was a "null"
	STB	R0,DTECLD,RPI		:clear called address
					:reset carriage position too
	RBT	RP,MXATO		:
	RBT	RP,INATO		:
	RBT	RP,ICAPND		:
	JNR	R9			:if incomplete inc call...done now
	TBT	RP,PADACT               :check mode
	JEFS	CANC20			:login state, skip
	RBT	RP,PNMODE   		:command mode, don't get pseudoneedle
	LIS	R0,X3PAW		:pad waiting for command state
CANC20	STB	R0,X3STAT,RPI		:set state
	JR	R9			:and exit


:	Send Interrupt Command Processor (CCITT and Extended)
:	================================
CCINT	TBT	RP,CALPRG		:
	JE	CLRER1			:
	LA	R6,SS.INE,,		:no interrupts on non-packet mode calls
	TBT	RP,TURKEY		:
	JE	CMDERR			:if not a packetizer
	LA	R6,SS.FEF,,		:
	SBT	RP,INTOUT		:
	JN	CMDERR			:if interrupt already out
	LHI	R6,EXMA			:send an interupt packet
	JAL	R9,BEGDIA		:
	LIS	RBC,1			:interrupt data of 1
	JAL	RCH,PUTCHR,,		:
	LA	R6,SS.FEF,,		:
	J	CMDERR			:send ACK


CCQUI	SBT	RP,HANGWT		:quit by hanging em up *sdw.500
	J	EDRTN			:send no msg since dey be gone

:	Receive Incoming Calls Command
:	==============================
CERCV
    IF	NPAPRT
	TBT	RP,AD.PRT,,		:addressable port?
	JE	CERCV4			:if port not allowed to rcv
	SBT	RP,LIMBO		:set LIMBO
					:*sdw500 - do PA.SL manually
        SBT     RP,ICAAU                :answer incoming calls *500.sdw
	J	CMDRTN
    EI
CERCV4	SERSIG(SS.IN1)			:indicate no incoming calls allowed
	J	CMDRTN

:       Reject incoming calls
:       =====================
CERJT
  IF	NPAPRT
        TBT     RP,AD.PRT,,
        JE      CERCV4          :not addressable port
        RBT     RP,ICAAU
        J       CMDRTN
  ELSE
        J       CERCV4
  EI


:	Send a Reset Command Processor (CCITT and Extended)
:	==============================
CCRES	TBT	RP,CALPRG
	JE	CLRER1
	LIS	R0,0
	STH	R0,PSDIAG,RPI		:null cause and diag...for now
	TBT	RP,CMDMOD
	JEFS	CCRES4
	JAL	R9,GETVAL
	J	CCRES4
	STB	RBC,PSDIAG+1,RPI
CCRES4	L	RBP,.TTBUF,RPI		:empty to term. buffer
	JAL	RCH,EMPTY,,
	L	RBP,.FTBUF,RPI		:empty from term. buffer
	JAL	RCH,EMPTY,,
	RBT	RP,INTOUT		:
	 LO	SIGNAL
	LIS	R4,GOBSIG		:gobble data to host
	JAL	RCH,PUTSIG,,
	LHI	R4,YBSIG		:send yellow ball-
	JAL	RCH,PUTSIG,,		:host will echo orange ball
	 FO	SIGNAL
	SBT	RP,X3.P8		:flush data from net until gobbler/OB
	SBT	RP,RESOUT		:indicate awaiting reset conf (gob/OB)
	LIS	R0,X3SER
	STB	R0,X3STAT,RPI  :in service signal state until then   
	TBT	RP,TURKEY
	JE	CCRES5			:if an IIX call
	TURMSG(RESET)			:send a reset packet to network
CCRES5	J	EDRTN


:	Status Command Processor (CCITT and Extended)
:	========================
CCSTA	LB	R0,X3.P6,RPI
	THI	R0,X3.6NP
	JE	CMDRTN
	L	RBP,.ECOBF,RPI
	TBT	RP,CALPRG
	JN	CCSTA6			:if a call in progress
	LA	R6,SS.FEF,,		:  else start service sig with CR/LF
	JAL	R5,OUTSTR,,
	LA	R6,SS.FRE,,
	TBT	RP,CMDMOD
	JE	CCSTA5			:if CCITT status
	LA	R6,DTECLG,RPI
	JAL	R9,OUTBCD		:display calling address
	LHI	RBC,SP
	JAL	RCH,PUTCHR,,		:separate from message
	LA	R6,SS.FRE,,
CCSTA5	JAL	R5,OUTSTR,,		:port is "FREE"
	J	CMDRTN

:	"ENGAGED"
CCSTA6	LA	R6,SS.FEF,,
	JAL	R5,OUTSTR,,
	LA	R6,SS.ENG,,
	TBT	RP,CMDMOD
	JE	CCSTA8			:if CCITT status
	LA	R6,DTECLG,RPI
	JAL	R9,OUTBCD		:display calling address
	LHI	RBC,SP
	JAL	RCH,PUTCHR,,		:...then separator
	LA	R6,SS.ENG,,
CCSTA8	JAL	R5,OUTSTR,,		:"ENGAGED"
	TBT	RP,CMDMOD
	JEFS	CCSTA9			:if CCITT status...finish msg
	LHI	RBC,SP
	JAL	RCH,PUTCHR,,		:  else display separator
	LA	R6,DTECLD,RPI
	JAL	R9,OUTBCD		:  display called address
CCSTA9	LA	R6,SS.FEF,,
	JAL	R5,OUTSTR,,		:...then CR/LF
	J	CMDRTN

:	OUTBCD	-	display a string of BCD digits in ASCII
:	Inputs	- RBP= buffer ptr for string to be put into
:		  R6= ptr to length of string (digits follow)
:		  Link on R9
:	DESTROYS  R0-5,7,8,TEMP,TEMP+4

OUTBCD	ST	R9,TEMP			:save link
	LB	R9,0,R6			:string length
	JE	OUTBC9			:if no string...return
OUTBC2	AIS	R6,1			:bump index to digits
	LB	RBC,0,R6
	SRLS	RBC,4			:1st digit of a pair
	AHI	RBC,ZERO		:...in ASCII
	JAL	RCH,PUTCHR,,
	SIS	R9,1
	JEFS	OUTBC9			:if done...return
	LB	RBC,0,R6
	NHI	RBC,0F			:2nd digit of pair
	AHI	RBC,ZERO		:...in ASCII
	JAL	RCH,PUTCHR,,
	SIS	R9,1
	JG	OUTBC2			:if more digits in string

OUTBC9	L	R9,TEMP                                           
	JR	R9



:	Help Command Processor
:	======================
CEHEL	JAL	R9,GETVAL		:RBC=help cmd # on return
	 LIS	RBC,0			:if no help number
	 JFS	HLPPRT			:...use 0

  IF	LESHLP
	CLHI	RBC,0
  ELSE
	CLHI	RBC,6			:max help number available
  EI	
	JG	CMDER1			:if no such help subcommand
:	Display help information
HLPPRT	LB	R0,X3.P6,RPI
	THI	R0,X3.6NP
	JE	CMDRTN			:if port doesn't want service signals
	LHL	R5,HPTRS,RBC,RBC
	AI	R5,BASE			:start of text ptrs for this help cmd
	L	RBP,.ECOBF,RPI		:put help info in alternate echo buffer
HLPPR2	LHL	R6,0,R5			:get ptr to next help string
	JE	CMDRTN			:if done helping
	AIS	R5,2			:index for next ptr
	AI	R6,BASE			:absolute address of help string
	JAL	R9,MSG,,		:show user how to use PAD
	JBS	HLPPR2			:see if more info to display



:	Profile Selection Command Processor
:	===================================

	SEG	A.CODE

CCPROS	JAL	R9,GETVAL		:
	J	CCPR10			:if just a READ
	LA	R6,SS.E10,,		:command unknown
	J	CMDERR			:

CCPROR	JAL	R9,GETVAL		:see if setting a new profile
	J	CCPR10			:if only a simple read
	CLHI	RBC,NX3PRO		:PROFILE # IN RANGE ?
	JG	PROER1			:NO, BRANCH
	LR	RBC,RBC			:PROFILE #=0 ?
	JE	PROER1			:YES
	STB	RBC,X3CPRO,RPI		:new profile (current one)
	JAL	R9,INITX3		:set parameters
	J	CMDRTN			:exit

CCPR10	LB	R0,X3.P6,RPI		:
	THI	R0,X3.6NP		:
	JE	CMDRTN			:if no service signals
	LA	R6,SS.PRO,,		:
	L	RBP,.ECOBF,RPI		:
	JAL	R5,OUTSTR,,		:
	LA	R2,X3.NAM,,		:GET ADDR OF PROFILE ZERO ENTRY
	ST	R2,APNSPR		:AND SAVE IT FOR LATER
	LIS	R2,0			:INITIALIZE PROFILE NUMBER
CCPR20	AIS	R2,1			:INCREMENT BY 1
	STH	R2,PRFIDX		:AND SAVE IT AGAIN
	L	R2,APNSPR		:
	AHI	R2,X3.SIZ		:COMPUTE ADDRESS TO NEXT PROFILE NAME
	ST	R2,APNSPR		:POINTER AND SAVE IT
	L	RBP,.ECOBF,RPI		:SET UP BUFFER POINTER
	LHI	RBC,SP			:
	JAL	RCH,PUTCHR,,		:OUTPUT A SPACE
	LHI	RBC,SP			:
	JAL	RCH,PUTCHR,,		:OUTPUT A SPACE
	LH	RBP,PRFIDX		:GET PROFILE INDEX SAVED EARLIER.
	JAL	RCH,XCBA		:CONVERT PROFILE INDEX TO DECIMAL
	L	RBP,.ECOBF,RPI		:SET UP BUFFER POINTER
CCPR30	LR	RBC,R6			:
	JAL	RCH,PUTCHR,,		:OUTPUT PROFILE NUMBER
	SRLS	R6,8			:
	JGBS	CCPR30			:REPEAT IF MORE DIGITS
	LHI	RBC,SP			:
	JAL	RCH,PUTCHR,,		:OUTPUT A SPACE
	LHI	RBC,EQUALS		:
	JAL	RCH,PUTCHR,,		:OUTPUT AN "="
	LHI	RBC,SP			:
	JAL	RCH,PUTCHR,,		:OUTPUT A SPACE
	L	R6,APNSPR		:GET ADDRESS OF PROFILE NAME POINTER
	L	R6,0,R6			:GET THE PROFILE NAME POINTER
	JAL	R5,OUTSTR,,		:OUTPUT THE STRING
	LA	R6,SS.FEF,,		:GET THE ADDRESS OF FORM EFFECTOR
	JAL	R5,OUTSTR,,		:OUTPUT IT
	LH	R2,PRFIDX		:GET PROFILE INDEX 
	CHI	R2,NX3PRO		:HAS LAST PROFILE BEEN PROCESSED
	JL	CCPR20			:NO, LOOP
	J	CMDRTN			:YES, EXIT

PROER1	LA	R6,SS.PR1,,		:invalid profile number
	J	CMDERR



:	PAR? Command Processor
:	======================
:	
CCPAR	LIS	R4,0			:initialize output buffer index
	LIS	R0,1			:indicate set and read
	STB	R0,SANDR		:record what parameter indication
	RBT	RP,PARTYP		:CCITT X.3 parameters 1st
	RBT	RP,NOMERR		:
	LR	R8,R8			:references present?
	JNFS	PAR010			:yes, go process	
	JAL	RLINK,PARALL		:no references...this means do all
	J	PARSND			:send parameter read to terminal
PAR010	JAL	R9,PARARG		:get a parameter reference
	 J	PAR035			:if done
	 J	CMDERR			:if something wrong
	 J	PAR020			:if numeric reference value
:	Found Nat'l Options Marker
	SBT	RP,PARTYP		:indicate doing TYMNET pars
	JN	PARER1			:if duplicate NOM
	STH	R2,CMDBUF,R4		:else save options marker   
	AIS	R4,2			:increment index into CMDBUF
	J	PAR010			:process next parameter

:	Check parameter reference value
PAR020	TBT	RP,NOMERR		:if bad national option marker
	JN	PAR027			:dont trust parameter number
	LA	R9,CPAROK		:assume CCITT parameter
	TBT	RP,PARTYP		:CCITT or tymnet parameter?
	JEFS	PAR025			:
	LA	R9,TPAROK		:assume tymnet parameter
PAR025	TBT	R2,0,R9			:valid parameter reference?
	JNFS	PAR030			:yes, parameter reference ok
PAR027	OHI	R2,80			:no, set invalid bit
	EXBR	R2,R2			:for parameter reference
	STH	R2,CMDBUF,R4		:and don't care about value   
	AIS	R4,2			:increment index into CMDBUF
	J	PAR010			:process next parameter

PAR030	STB	R2,CMDBUF,R4            :place parameter ref in buffer
	LHL	R9,XREAD,R2,R2		:get dispatch address
	JAL	R9,BASE,R9,		:go to read routine
	STB	R3,CMDBUF+1,R4          :save parameter setting read       
	AIS	R4,2			:increment index into CMDBUF
	J	PAR010			:process next parameter

PAR035	LB	R6,CMDBUF-2,R4		:was last parm ref a Tym Natl Mrk Opt?
	JNFS	PAR040			:no, display parameter refs and vals
	SIS	R4,2			:adjust index to prevent dup 0:0
	JAL	RLINK,PARTYM		:read all Tymnet Natl Parms
PAR040	J	PARSND			:display parameter refs and values

:	Read all X.3 and TYMNET terminal parameters
:		Destroyes R3, R6, and R9.  R4 = CMDBUF index
:		linked on RLINK
:	
PARALL	LIS	R6,0			:start with 1st parameter reference
PARAL2	AIS	R6,1			:parameter reference (number)
	STB	R6,CMDBUF,R4            :store parameter reference in CMDBUF
	LHL	R9,XREAD,R6,R6		:get addresss from dispatch table
	JAL	R9,BASE,R9,		:go read parameter setting
	STB	R3,CMDBUF+1,R4          :store parameter setting in CMDBUF
	AIS	R4,2			:parameter save index
	CHI	R6,XSETMX		:completed last parameter?
	JLBS	PARAL2			:no, read next parameter setting

:	Entry point to read all TYMNET terminal parameters
PARTYM	LIS	R6,0			:place national option marker
	STB	R6,CMDBUF,R4		:in CMDBUF
	STB	R6,CMDBUF+1,R4                                    
	AIS	R4,2
	LHI	R6,$A100		:start with 1st parameter reference
PARTY2	AIS	R6,1			:parameter reference (number)
	STB	R6,CMDBUF,R4            :store parameter reference in CMDBUF
	LHL	R9,XREAD,R6,R6		:get addresss from dispatch table
	JAL	R9,BASE,R9,		:go read parameter setting
	STB	R3,CMDBUF+1,R4          :store parameter setting in CMDBUF
	AIS	R4,2			:parameter save index
	CHI	R6,$A100+TSETMX		:completed last parameter?
	JLBS	PARTY2			:no, read next parameter setting
	JR	RLINK			:return to caller	

:	PARARG	- Subroutine to get an argument for the PAR? command
:
:		Input	R8= # chars in *CMDBUF*
:			R7=Index of next char
:		Output	R2= Par Ref
:		Returns	0 - Done
:			+4 - Error (R6 holds ptr)
:			+8 - "nn" or "nn," encountered
:			+0C - "0:0" or "0:0," encountered
PARARG	AIS	R8,1
PARA10	SIS	R8,1
	JER	R9
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	CLHI	RBC,SP
	JEBS	PARA10
	LIS	R2,0
	TBT	RBC,ASDIG
	JE	PARER2			:if 1st char not number
PARA20	SHI	RBC,ZERO		:convert ascii digit to binary
	LIS	R0,0A
	MHR	R2,R0
	AR	R2,RBC
	CLHI	R2,7F
	JG	PARER5                  :error, parm ref < 128  :DLG 11-Apr-86
	SIS	R8,1
	JLE	8,R9
PARA30	LB	RBC,CMDBUF,R7                                  
	AIS	R7,1
	TBT	RBC,ASDIG
	JN	PARA20
	SIS	R8,1
	CLHI	RBC,COMMA
	JE	8,R9
	CLHI	RBC,COLON
	JN	PARER4
	LR	R2,R2
	JN	PARER4
	LR	R8,R8
	JE	PARER4
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	CLHI	RBC,ZERO
	JN	PARER4
PARA50	SIS	R8,1
	JLE	0C,R9
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	CLHI	RBC,SP
	JE	PARA50
	CLHI	RBC,COMMA
	JN	PARER4
	SIS	R8,1			:adjust # chars left
	J	0C,R9			:...and make Nat'l Options return



:	PARSND	-	Subroutine to send SET, READ, OR SET and READ Service 
:			signals to terminal
:
:		Input	R4= # chars in *CMDBUF* (set up in REF, VAL pairs)
:			SANDR = 0, if SET
:				1, if READ or SET & READ
:
:		Output	Par Ind signal to .ECOBF
:
PARSND	LB	R0,X3.P6,RPI
	THI	R0,X3.6NP
	JE	CMDRTN			:if no service signals...exit
	STH	R4,TEMP			:save number of read parameters
	LIS	R9,0			:init index to parameter list
	LA	R6,SS.PAR,,		:
	LB	R0,SANDR		:
	JN	PARS10			:if always sending par ind service signal
	LR	RBC,R4			:..else number of parameters to check
PARS04	LB	R0,CMDBUF,R9		:...for invalid value or ref   
	THI	R0,80			:
	JN	PARS06			:if invalid must send service signal
	AIS	R9,2			:..else check another parameter
	SIS	RBC,2			:
	JG	PARS04			:
	J	CMDRTN			:no service signal on valid SET

PARS06	LIS	R9,0			:reset *CMDBUF* index
	LA	R6,SS.SET,,		:SET parameter indication header
PARS10	L	RBP,.ECOBF,RPI		:
	JAL	R5,OUTSTR,,		:
	LIS	RCH,0			:indicate no comma 1st time
PARS20	LB	R2,CMDBUF,R9		:
	THI	R2,80			:
	JNFS	PARS30			:
	LB	R0,SANDR		:
	JE	PARS70			:
PARS30	LR	RCH,RCH			:
	JE	PARS32			:if no comma
	L	RBP,.ECOBF,RPI		:
	LHI	RBC,COMMA		:
	JAL	RCH,PUTCHR,,		:
	LHI	RBC,SP			: put a SPACE following COMMA
	JAL	RCH,PUTCHR,,		:
	LB	R2,CMDBUF,R9		:reload terminal parameter   
PARS32	NHI	R2,7F			:
	JAL	RCH,XCBA		:
	L	RBP,.ECOBF,RPI		:
PARS40	LR	RBC,R6			:
	JAL	RCH,PUTCHR,,		:
	SRLS	R6,8			:
	JGBS	PARS40			:
	LHI	RBC,COLON		:
	L	RBP,.ECOBF,RPI		:
	JAL	RCH,PUTCHR,,		:
	LB	R2,CMDBUF,R9		:
PARS44	THI	R2,80			:
	JE	PARS50			:
	L	RBP,.ECOBF,RPI		:
	LA	R6,SS.INV,,		:
	JAL	R5,OUTSTR,,		:
	J	PARS70			:

PARS50	LB	R2,CMDBUF+1,R9		:
	JAL	RCH,XCBA		:
	L	RBP,.ECOBF,RPI		:
PARS60	LR	RBC,R6			:
	JAL	RCH,PUTCHR,,		:
	SRLS	R6,8			:
	JGBS	PARS60			:
PARS70	AIS	R9,2			:
	LHL	R4,TEMP			:
	SIS	R4,2			:
	JLEFS	PARS80			:
	STH	R4,TEMP			:
	J	PARS20			:

PARS80	LA	R6,SS.FEF,,		:end of service signal is CR/LF
	JAL	R5,OUTSTR,,		:
	J	CMDRTN			:

:	PAR error Routines
PARER1	LA	R6,SS.E50,,		:duplicate natl optn mark found
	J	CMDERR

PARER2	LA	R6,SS.E55,,		:parm ref or value must be digits
	J	CMDERR

PARER3	LA	R6,SS.E60,,		:parm ref <256
	J	CMDERR

PARER4	LA	R6,SS.E65,,		:incomplete/incorrect natl optn mrk
	J	CMDERR

PARER5	LA	R6,SS.E61,,   		:parm ref <128  :DLG 11-Apr-86
	J	CMDERR

:	SET and READ terminal parameters
:	================================
CCSER	LIS	R0,1			:set and read parameters
	JFS	SET002			:continue

:	SET terminal parameters
CCSET	LIS	R0,0			:only set parameters
SET002	STB	R0,SANDR		:1=set and read parameters
	RBT	RP,WHOSIT		:local DTE is setting parameters
	RBT	RP,PARTYP		:initially looking at X.3 parameters
	RBT	RP,NOMERR		:
	LR	R8,R8			:char's in CMDBUF(0=set all)?
	JNFS	SET010			:yes, set specified parameters
	JAL	R9,INITX3		:no, set all parameters
	LB	R0,SANDR		:set and read parameters?
	JE	CMDRTN			:no, just return
	LIS	R4,0			:yes, reset CMDBUF index
	JAL	RLINK,PARALL		:read all parameters
	J	PARSND			:display all parameters

:	translate list of parameter numbers and settings
SET010	LIS	R4,0			:initialize index into CMDBUF
SET015	JAL	R9,SETARG		:translate input characters
	 J	SET020			:if done
	 J	CMDERR			:if fatal error
:	if values returned...save for later processing
	STB	R2,CMDBUF,R4           	:place parm ref in CMDBUF    
	STB	R3,CMDBUF+1,R4          :place parm setting in CMDBUF 
	AIS	R4,2			:increment index
	JBS	SET015			:return for next

:	process translated list
SET020	STH	R4,PARCNT		:save count of parm refs and values
	LIS	R4,0			:initialize CMDBUF index
SET025	LB	R2,CMDBUF,R4            :get parameter reference         
	STH	R2,PARREF		:save parameter number
	LB	RBC,CMDBUF+1,R4    	:get setting for parameter  
	LR	R2,R2			:Tymnet Natl Opt Marker?
	JN	SET030			:no

:	Validate Nat'l Opts
	SBT	RP,PARTYP		:assume good NOM
	LR	RBC,RBC			:valid value? (0:0)
	JE	SETRTN			:yes, save marker for later
	SBT	RP,NOMERR		:no, set err flag
	J	SETINV			:

SET030	TBT	RP,NOMERR		:if bad national option marker
	JN	SETINV			:dont trust parameter number
	LA	R9,CPAROK		:assume CCITT parameter
	TBT	RP,PARTYP		:CCITT or tymnet parameter?
	JEFS	SET035			:
	LA	R9,TPAROK		:assume tymnet parameter
SET035	TBT	R2,0,R9			:valid parameter reference?
	JEFS	SETINV			:no
	LHL	R9,XSET,R2,R2		:yes, get address from dispatch table
	JAL	R9,BASE,R9,		:go set parameter
	 J	SETINV			:bad value
	J	SETRTN			:good value


:	SET Command Exits
:	=================
:
:	Handle invalid SETs
SETINV	LHL	R2,PARREF            	:restore reg with parm no. 
	OHI	R2,80			:set high order bit
	STB	R2,CMDBUF,R4        	:place in CMDBUF

:	Return for all SETs
SETRTN	AIS	R4,2			:increment CMDBUF index
	CH	R4,PARCNT		:is there another?
	JL	SET025			:yes, return to process it
	LB	R2,CMDBUF-2,R4		:get last parameter ref, Natl Opt Mrk?
	JNFS	SETRR1			:no, skip setting all Tymnet Natl parms
	JAL	R9,INITN3		:yes, set all national parameters
	SIS	R4,2			:backup index to prevent double 0:0
	JAL	RLINK,PARTYM		:read all national parameters
	
SETRR1	J	PARSND			:send service signal...if allowed to

:	INITCS	- Initializes CONSAT Terminal arrays
:		DESTROYS R0-4,R6,TEMP
:		Linked on R9

INITCS	LHL	R4,.TERMT,RPI
	LB	R0,VID.IB,R4,
	STB	R0,IBRATE,RP		:set up input baud-rate
	LB	R0,VID.OB,R4,
	STB	R0,OBRATE,RP		:set up output baud-rate
	LB	R0,VID.PA,R4,		:set parameters A,B,C,D
	STB	R0,PAR.A,RP		:Parameter A
	LB	R0,VID.PB,R4,
	STB	R0,PAR.B,RP		:Parameter B
	LB	R0,VID.PC,R4,
	STB	R0,PAR.C,RP		:Parameter C
	LB	R0,VID.PD,R4,
	STB	R0,PAR.D,RP		:Parameter D
	LHL	R2,VID.FL,R4,		:Initialize bit arrays
	LCS	R3,2
INCS10	AIS	R3,2
	LHL	R1,VIDBA,R3,
	JNFS	INCS15			:do we have a zero?
	JR	R9			:return to caller
INCS15	CLHI	R1,ECHO
	JEFS	INCS20			:if echo flag...set it later
	RBT	RP,0,R1			:turn the bit off
	SRLS	R2,1			:test what it should be
	JNCBS	INCS10
	SBT	RP,0,R1			:else set it
	J	INCS10
INCS20	SRLS	R2,1
	J	INCS10			:continue with bit flags

:	INITX3 - Sets all CCITT X.3 and TYMNET Natl parameters 
:	to profile.
:		Destroys R0-R4, R6, TEMP
:		Linked on R9

INITX3	LIS	R6,0			:offset of profile 0 in list
	LB	R1,X3CPRO,RPI		:current port profile
	JEFS	INX310			:if profile # = 0
	AHI	R6,X3.SIZ		:
	MHR	R6,R1			:
INX310	LB	R0,X3.REC,R6		:get command mode recall char
	STB	R0,X3.P1,RPI		:and init parameter 1
	LB	R0,X3.FWD,R6		:get data forwarding setting
	STB	R0,X3.P3,RPI		:and init parameter 3
	LB	R0,X3.IDL,R6		:get idle timer value
	STB	R0,X3.P4,RPI		:and init parameter 4
	LB	R0,X3.SER,R6		:get service prompt setting
	STB	R0,X3.P6,RPI		:and init parameter 6
	ST	R9,INX3SV		:save link register
	JAL	RCH,TY.MAP		:Compute X.3 pars 9 and 14
	L	R9,INX3SV               :restore link register
	LB	R0,X3.BRK,R6		:get break action setting
	STB	R0,X3.P7,RPI		:and init parameter 7
	LB	R0,X3.LW,R6		:get line folding value
	STB	R0,X3.P10,RPI		:and init parameter 10
	LB	R1,OBRATE,RP		:get output baud rate
	LB	R0,TBR.CC,R1		:translate to CCITT value
	STB	R0,X3.P11,RPI		:and init parameter 11
	LB	R0,X3.CRL,R6		:get LF insertion value
	STB	R0,X3.P13,RPI		:and init parameter 13
	RBT	RP,ECR.LF		:clear consat CR/LF flag
	LB	R0,X3.CHD,R6		:get character delete char
	STB	R0,X3.P16,RPI		:and set parameter 16
	LB	R0,X3.LDE,R6		:get line delete char
	STB	R0,X3.P17,RPI		:and set parameter 17
	LB	R0,X3.LDI,R6		:get line display char
	STB	R0,X3.P18,RPI		:and set parameter 18
	LHL	R0,X3.FLG,R6		:get bit values

:	set bit values (on/off) for X.3 and Tymnet National parameters
:	   X3.P2, X3.P5, X3.P8, X3.P12, X3.P15, and X3.N1, X3.N2

	SBT	RP,X3.P2		:set echo on
	THI	R0,FL.P02		:is echo desired?
	JNFS	INX340			:yes, test next setting
	RBT	RP,X3.P2		:no, set echo off
:	Logic needs design review. ECHO should not effect
:	PAD X.3 parameter 2.***************************
:	Handle echo serarately (as host echo must be considered)
INX340	TBT	RP,X3.P2
	JNFS	INX345			:if profile says echo on
	RBT	RP,ECHO			:  else turn off rcvr echo
	TBT	RP,DEM
	JEFS	INX350			:if not deferring echo...done
	RBT	RP,ECHOON		:  else indicate DTE wants echo off
	JFS	INX350
INX345	TBT	RP,ECHO
	JNFS	INX350			:if echo already on
	SBT	RP,ECHOON		:  else indicate DTE wants echo on
	SBT	RP,ECHO			:turn echo on
INX350	SBT	RP,X3.P5		:enable XON/XOFF
	THI	R0,FL.P05		:is XON/XOFF desired?
	JNFS	INX355			:yes, test next setting
	RBT	RP,X3.P5		:disable XON/XOFF
INX355	SBT	RP,X3.P12		:enable reverse XON/XOFF
	THI	R0,FL.P12		:is reverse XON/XOFF desired?
	JNFS	INX360			:yes, test next setting
	RBT	RP,X3.P12		:disable reverse XON/XOFF
INX360	SBT	RP,X3.P15		:enable editing in data transfer mode
	THI	R0,FL.P15		:is editing desired?
	JNFS	INX365			:yes, continue
	RBT	RP,X3.P15		:no, disable editing in data trans mode
INX365	RBT	RP,X3.P8		:resent X3.P8 (discarding output)

:	INITN3	Sets TYMNET Natl parameters
:		Destroys R0-R4, and R6
:		Linked on R9
INITN3	SBT	RP,X3.N1		:set echo^i on
	THI	R0,FL.N01		:is echo^i desired?
	JNFS	INN310			:yes, test next setting
	RBT	RP,X3.N1		:no, set echo^i off
INN310	SBT	RP,X3.N2		:set expand ^i on
	THI	R0,FL.N02		:is expand ^i desired?
	JNFS	INN315			:yes, test next setting
	RBT	RP,X3.N2		:no, set expand ^i off
INN315	LH	R0,X3.BKC,R6		:get break value from default profile
	JNFS	INN320			:is break emulation to be on?
	LCS	R0,1			:off so set to -1
INN320	STH	R0,X3.N3,RPI		:store for this port

	JR	R9			:return to caller

:	SETARG	-	Subroutine to get arguments for the SET and SET &
:			READ commands
:		Returns		0	- done
:			+4 - Error (ptr in R6)
:			+8 - "," or "nn:mm"
:		Link On R9
:		Register Usage
:			R0 - scratch
:			R1 - scratch
:			R2 - Par Ref
:			R3 - Par Val
:			R4 - Preserved
:			R7 - index to next char in *CMDBUF*
:			R8 - # chars left in *CMDBUF*

SETARG	LIS	R0,0
	LIS	R2,0
	LIS	R3,0
	AIS	R8,1
SETA06	SIS	R8,1			:dec no. of char left in CMDGUF
	JER	R9			:none left, return
SETA10	LB	RBC,CMDBUF,R7           :get char 
	AIS	R7,1			:increment index
	NHI	RBC,7F			:remove high order bit  :DLG 11-Apr-86
	CLHI	RBC,SP			:space?
	JEBS	SETA06			:yes, get next char
	TBT	RBC,ASDIG		:ascii digit 0-9?
	JE	SETA90			:no
	J	SETA40			:yes

:	Process 2nd, 3rd,... digits
SETA30	TBT	RBC,ASDIG		:ascii digit 0-9?
	JN	SETA40			:yes, a number
	CLHI	RBC,COLON		:no, colon?
	JEFS	SETA34			:yes, process
	CLHI	RBC,SP			:no, space?
	JN	SETA90			:no, unrecognized error 
	JFS	SETA36			:yes, continue

SETA34	LR	R0,R0			:colon, first char s/b 0
	JN	SETA90			:no, error
	LIS	R0,1			:one char ok
SETA36	SIS	R8,1			:decrement char count for CMDBUF
	JE	SETA92		:last char in CMDBUF - error only one aug
	LB	RBC,CMDBUF,R7           :get next char
	AIS	R7,1			:increment index
	NHI	RBC,7F			:clear high order bit
	J	SETA30			:process

SETA40	SHI	RBC,ZERO
	LR	R0,R0
	JN	SETA50
	LIS	R6,0A
	MHR	R2,R6
	AR	R2,RBC
	LA	R6,SS.E25,,
	CLHI	R2,7F
	JG	4,R9			:if larger than max ref of 127
SETA44	SIS	R8,1			:more than 1 char in CMDBUF?
	JE	SETA92			:no, missing arg
	LB	RBC,CMDBUF,R7           :yes, get char
	AIS	R7,1			:increment ptr
	NHI	RBC,7F			:remove high order bit  :DLG 11-Apr-86
	CLHI	RBC,SP			:space?
	JEBS	SETA44			:yes, get next char
	J	SETA30			:no, process next digit

:	Process parameter value
SETA50	LIS	R6,0A
	MHR	R3,R6
	AR	R3,RBC
	CLHI	R3,0FF
	JLE	SETA60
:	Bad par value
	OHI	R2,80			:set error bit in ref to indicate bad valueV
SETA54	SIS	R8,1
	JLE	8,R9
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JNBS	SETA54			:if a number
	CLHI	RBC,SP
	JEBS	SETA54
	SIS	R8,1			:1 less ASCII digit or delimiter left
	CLHI	RBC,COMMA
	JE	8,R9
	J	SETA90

SETA60	SIS	R8,1
	JLE	8,R9
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	NHI	RBC,7F
	TBT	RBC,ASDIG
	JN	SETA40			:if a number
	CLHI	RBC,SP
	JE	SETA60			:if a blank...ignore it
	SIS	R8,1			:..else 1 less ASCII digit or delimiter
	CLHI	RBC,COMMA
	JE	8,R9

SETA90	LA	R6,SS.E15,,		:Unrecognized arg error
	J	4,R9

SETA92	LA	R6,SS.E20,,		:Missing argument error
	J	4,R9

SETER1	LA	R6,SS.E75,,		:user cannot set this parameter
	J	CMDRTN

:	SET and READ Terminal Parameter Command Processor Lookup Tables
:	===============================================================
:	These tables are based on X.3 and TYMNET National terminal
:	 numbers --- the TYMNET National parameter numbers are NOT those
:	 of the ISIS STP/QTP messages (ie. ISIS message #'s should never
:	 index these tables to get SET/READ terminal parameter routine
:	 addresses).
:
:	NOTE--THE MEMORY LAYOUT IS SIGNIFICANT (CAB 6.00)
:
:	The layout consists of 3 interleaved tables: XSET, XMINMX, XREAD.
:	Each is addressed as if it were completely independent.  Before
:	addressing the tables, the index is checked using CPAROK and TPAROK.
:
:	THE LAYOUT IS AS FOLLOWS:
:
:	XSET	+----+
:		+    + PAR 1
:		+    + ...
:		+    + PAR 18
:		+----+
:		.    .
:		.    .	XMINMX	+----+
:		.    .		+    + PAR 1
:		.    .		+    + ...
:		.    .		+    + PAR 18
:		.    .		+----+
:		.    .		.    .
:		.    .		.    .	XREAD	+----+
:		.    .		.    .		+    + PAR 1
:		.    .		.    .		+    + ...
:		.    .		.    .		+    + PAR 18
:		.    .		.    .		+----+
:		.    .		.    .		.    .
:	TSET	+----+		.    .		.    .
:		+    + PAR 101	.    .		.    .
:		+    + ...	.    .		.    .
:		+    + PAR 103	.    .		.    .
:		+----+		.    .		.    .
:				.    .		.    .
:			TMINMX	+----+		.    .
:				+    + PAR 101	.    .
:				+    + ...	.    .
:				+    + PAR 103	.    .
:				+----+		.    .
:						.    .
:					TREAD	+----+
:						+    + PAR 101
:						+    + ...
:						+    + PAR 103
:						+----+
:
:	CCITT parameter validity table
:	1=CCITT parameter (1-18)
CPAROK	WC	7FFFE000	:0-31, ONLY 1-18 OK (CCITT)
	WC	0		:32-63
	WC	0		:64-95
	WC	00000000	:96-127

:	Tymnet national parameter validity table
:	1=tymnet parameter (101-103)
TPAROK	WC	0		:0-31
	WC	0		:32-63
	WC	0		:64-95
	WC	07000000	:96-127, ONLY 101-103 OK

:	SET X.3 Parameters
XSET	HC	0		:parameter 0
XSETTB	HC	XS.010-BASE	:parameter 1
	HC	XS.020-BASE	:parameter 2
	HC	XS.030-BASE	:parameter 3
	HC	XS.040-BASE	:parameter 4
	HC	XS.050-BASE	:parameter 5
	HC	XS.060-BASE	:parameter 6
	HC	XS.070-BASE	:parameter 7
	HC	XS.080-BASE	:parameter 8
	HC	XS.090-BASE	:parameter 9
	HC	XS.100-BASE	:parameter 10
	HC	XS.110-BASE	:parameter 11
	HC	XS.120-BASE	:parameter 12
	HC	XS.130-BASE	:parameter 13
	HC	XS.140-BASE	:parameter 14
	HC	XS.150-BASE	:parameter 15
	HC	XS.160-BASE	:parameter 16
	HC	XS.170-BASE	:parameter 17
	HC	XS.180-BASE	:parameter 18
XSETMX	EQ	(.-XSETTB)/2

	ORG	XSET+2*$A30
:	SET MIN/MAX LIMITS
XMINMX	HS	
	BC	0,0		:parameter 0
	BC	0,$A126		:parameter 1
	BC	0,1		:parameter 2
	BC	0,$A255		:parameter 3
	BC	0,$A255		:parameter 4
	BC	0,1		:parameter 5
	BC	0,5		:parameter 6
	BC	0,$A21		:parameter 7
	BC	0,1		:parameter 8
	BC	0,7		:parameter 9
	BC	0,$A255		:parameter 10
	BC	0,0		:parameter 11
	BC	0,1		:parameter 12
	BC	0,7		:parameter 13
	BC	0,7		:parameter 14
	BC	0,1		:parameter 15
	BC	0,$A127		:parameter 16
	BC	0,$A127		:parameter 17
	BC	0,$A127		:parameter 18

	ORG	XSET+2*$A60
:	READ X.3 Parameters
XREAD	HC	0		:parameter 0
XREATB	HC	XR.010-BASE	:parameter 1
	HC	XR.020-BASE	:parameter 2
	HC	XR.030-BASE	:parameter 3
	HC	XR.040-BASE	:parameter 4
	HC	XR.050-BASE	:parameter 5
	HC	XR.060-BASE	:parameter 6
	HC	XR.070-BASE	:parameter 7
	HC	XR.080-BASE	:parameter 8
	HC	XR.090-BASE	:parameter 9
	HC	XR.100-BASE	:parameter 10
	HC	XR.110-BASE	:parameter 11
	HC	XR.120-BASE	:parameter 12
	HC	XR.130-BASE	:parameter 13
	HC	XR.140-BASE	:parameter 14
	HC	XR.150-BASE	:parameter 15
	HC	XR.160-BASE	:parameter 16
	HC	XR.170-BASE	:parameter 17
	HC	XR.180-BASE	:parameter 18

	ORG	XSET+2*$A101
:	SET TYMNET Parameters
TSETTB	HC	TS.010-BASE	:parameter 101
	HC	TS.020-BASE	:parameter 102
	HC	TS.030-BASE	:parameter 103
TSETMX	EQ	(.-TSETTB)/2

	ORG	XMINMX+2*$A101
:	Tymnet national parameters min/max values
TMINMX	HS
	BC	0,1		:parameter 101
	BC	0,1		:parameter 102
	BC	0,$A127		:parameter 103

	ORG	XREAD+2*$A101
:	READ Tymnet national parameters
TREATB	HC	TR.010-BASE	:parameter 101
	HC	TR.020-BASE	:parameter 102
	HC	TR.030-BASE	:parameter 103


:************************************************
:	TYMNET Parameter 1 - Echo Control-I	*
:************************************************

:	SET
TS.010	SIS	RBC,1		:is echo ^i to be on?
	JEFS	TS.011		:yes
	JGR	R9		:invalid value, error return
	RBT	RP,ECTLI	:no, set echo ^i off
	J	4,R9		:normal return
TS.011	SBT	RP,ECTLI	:set echo ^i on
	J	4,R9		:normal return

:	EXTENDED SET
ETS010	LHI	R2,$A101
	J	EXSSWI

:	READ
TR.010	LIS	R3,0		:assume zero, echo ^i - off
	TBT	RP,ECTLI	:is it on?
	JER	R9		:no, just return
	LIS	R3,1		:yes, return one, echo ^i - on
	JR	R9		:return

:	EXTENDED READ
ETR010	LHI	R2,$A101
	J	EXRSWI

:************************************************
:	TYMNET Parameter 2 - <TAB> expansion	*
:************************************************

:	SET
TS.020	SIS	RBC,1		:is tab expansion to be on?
	JEFS	TS.021		:yes
	JGR	R9		:invalid value, error return
	RBT	RP,X3.N2	:no, set tab expansion off
	J	4,R9		:normal return
TS.021	SBT	RP,X3.N2	:set tab expansion on
	J	4,R9		:normal return

:	EXTENDED SET
ETS020	LHI	R2,$A102
	J	EXSSWI

:	READ
TR.020	LIS	R3,0			:assume zero, tab expansion - off
	TBT	RP,X3.N2		:is it on?
	JER	R9			:no, just return
	LIS	R3,1			:yes, return one, tab expansion - on
	JR	R9			:return

:	EXTENDED READ
ETR020	LHI	R2,$A102
	J	EXRSWI

:************************************************
:	TYMNET Parameter 3 - code for <BREAK>	*
:************************************************
:	SET
TS.030	CLHI	RBC,$A127		: > MAX. ALLOWED?
	JGR	R9			: YES, ERROR RETURN
	LR	RBC,RBC			: SET FLAGS
	JNFS	TS.031			: CHECK IF ON
	LCS	RBC,1			: IF OFF, SET TO -1	
TS.031	STH	RBC,X3.N3,RPI
	J	4,R9			: NORMAL RETURN

:	EXTENDED SET
ETS030	LHI	R2,$A103
	J	EXSVAL

:	READ
TR.030	LH	R3,X3.N3,RPI	:get value of Natl parm 3 from port table
	JGR	R9		:is value 1-127, return
	LIS	R3,0		:no, must be a -1 replace with zero
	JR	R9		:return

:	EXTENDED READ
ETR030	LHI	R2,$A103
	J	EXRVAL

	SUBTTL	(PAD) X.3 Terminal Parameters

:******************************************************
:	X.3 Parameter 1 - Escape from Data Trnasfer
:******************************************************

:	SET
XS.010	LCS	R0,1
	CLHI	RBC,1
	JL	XS.014			:if turning off...use FF internally
	JNFS	XS.012			:if not DLE (ie 1)
	LHI	R0,10			:  else convert DLE to actual ASCII
	JFS	XS.014

XS.012	CLHI	RBC,X3.1MX
	JGR	R9
	CLHI	RBC,10
	JER	R9			:if ctl-a...not allowed
	TBT	RP,PADTYP
	JNFS	XS.013			:if extended mode... allow 2 thru 31
	CLHI	RBC,X3.1MN
	JLR	R9			:if invalid escape for CCITT mode
XS.013	LR	R0,RBC
XS.014	STB	R0,X3.P1,RPI
	J	4,R9

:	EXTENDED SET
EXS010	LIS	R2,1
	J	EXSVAL

:	READ
XR.010	LIS	R3,0
	LB	R0,X3.P1,RPI
	CLHI	R0,0FF
	JER	R9			:if internal off flag...send 0
	LIS	R3,1
	CLHI	R0,DLE
	JER	R9			:if internal DLE...send 1
	LR	R3,R0
	JR	R9			:  else internal value is actual value

:	EXTENDED READ
EXR010	LIS	R2,1
	J	EXRVAL

:************************************************
:	X.3 Parameter 2 - Echo			*
:************************************************
:	SET
XS.020	SIS	RBC,1		:turn echo on or off?
	JE	XS.022		:set echo on
	JGR	R9		:error return, invalid parm value
	RBT	RP,X3.P2	:reset X3.P2 to echo off
	TBT	RP,DEM		:in DEM?
	JNFS	XS.021		:yes
	RBT	RP,ECHO		:reset echo to echo off
	J	4,R9		:normal return

XS.021	RBT	RP,ECHOON	:green ball will not turn echo on
	J	4,R9		:normal return

XS.022	TBT	RP,ECHO		:is echo already on?
	JN	4,R9		:yes, normal return
	TBT	RP,DEM		:no, is DEM on?
	JN	4,9		:yes, normal return
:	TBT	RP,WHOSIT,,
:	JEFS	XS.024		:if local DTE is calling
:	Echo on --- set by remote interface
:	SBT	RP,DEM		:turn on echo via DEM
:	JFS	XS.026		:..and allow GB to cause LDEM

:	Echo on --- set by DTE
XS.024	SBT	RP,X3.P2
	SBT	RP,ECHO
XS.026	SBT	RP,ECHOON
	J	4,R9

:	EXTENDED SET
EXS020	LIS	R2,2
	J	EXSSWI

:	READ
XR.020	LIS	R3,1
	TBT	RP,ECHO
	JNR	R9			:if echoing in toto...echo is on
	TBT	RP,DEM
	JNR	R9			:if in DEM...echo is on
	TBT	RP,WHOSIT
	JNFS	XR.022			:if host...don't care about local echo
	TBT	RP,X3.P2
	JNR	R9			:if echoing locally...echo is on
XR.022	LIS	R3,0			:  else echo is off
	JR	R9

:	EXTENDED READ
EXR020	LIS	R2,2
	J	EXRSWI

:************************************************
:	X.3 Parameter 3 - Data Forwarding	*
:************************************************
:	SET
XS.030	STB	RBC,X3.P3,RPI		:update forwarding mask
	J	4,R9

:	EXTENDED SET
EXS030	LIS	R2,3
	J	EXSVAL

:	READ
XR.030	LB	R3,X3.P3,RPI		:get value of parm 3 from port table
	JR	R9			:return

:	EXTENDED READ
EXR030	LIS	R2,3
	J	EXRVAL

:************************************************
:	X.3 Parameter 4 - Idle Timer		*
:************************************************
:	SET
XS.040	STB	RBC,X3.P4,RPI
	J	4,R9

:	EXTENDED SET
EXS040	LIS	R2,4
	J	EXSVAL

:	READ
XR.040	LB	R3,X3.P4,RPI		:get value of parm 4 from port table
	JR	R9			:return

:	EXTENDED READ
EXR040	LIS	R2,4
	J	EXRVAL

:************************************************
:	X.3 Parameter 5 - Ancillary Device Ctl	*
:************************************************
:	SET
XS.050	SIS	RBC,1			:is XON/XOFF to be enabled?
	JEFS	XS.051			:yes
	JGR	R9			:invalid value, error return
	RBT	RP,X3.P5		:no, disable XON/XOFF
	J	4,R9			:normal return
XS.051	SBT	RP,X3.P5		:set XON/XOFF enabled
	J	4,R9			:normal return

:	EXTENDED SET
EXS050	LIS	R2,5
	J	EXSSWI

:	READ
XR.050	LIS	R3,0			:assume XON/XOFF disabled
	TBT	RP,X3.P5		:is it on?
	JER	R9			:no, just return
	LIS	R3,1			:yes, XON/XOFF enabled
	JR	R9			:return

:	EXTENDED READ
EXR050	LIS	R2,5
	J	EXRSWI

:************************************************
:	X.3 Parameter 6 - PAD Service Signals	*
:************************************************
:	SET
XS.060	LR	R0,RBC
	OHI	R0,X3.6NP!X3.6P		:allowable values
	XHI	R0,X3.6NP!X3.6P
	JNR	R9
	STB	RBC,X3.P6,RPI
	J	4,R9

:	EXTENDED SET
EXS060	LIS	R2,6
	J	EXSVAL

:	READ
XR.060	LB	R3,X3.P6,RPI		:get value of parm 6 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR060	LIS	R2,6
	J	EXRVAL

:************************************************
:	X.3 Parameter 7 - Break Action		*
:************************************************
:	SET
XS.070	CLHI	RBC,$A31
	JGR	R9			:if greater than max combo
	STB	RBC,X3.P7,RPI
	J	4,R9

:	EXTENDED SET
EXS070	LIS	R2,7
	J	EXSVAL

:	READ
XR.070	LB	R3,X3.P7,RPI		:get value of parm 7 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR070	LIS	R2,7
	J	EXRVAL

:************************************************
:	X.3 Parameter 8 - Discard Output	*
:************************************************
:	SET
XS.080	SIS	RBC,1		:is discarding output to be set on?
	JEFS	XS.081		:yes
	JGR	R9		:invalid value, error return
	RBT	RP,X3.P8	:no, set discarding output off
	J	4,R9		:normal return
XS.081	SBT	RP,X3.P8	:set discarding output on
	J	4,R9		:normal return

:	EXTENDED SET
EXS080	LIS	R2,8
	J	EXSSWI

:	READ
XR.080	LIS	R3,0			:assume discarding output = off
	TBT	RP,X3.P8		:is it on?
	JER	R9			:no, just return
	LIS	R3,1			:yes, discarding output = on
	JR	R9			:return

:	EXTENDED READ
EXR080	LIS	R2,8
	J	EXRSWI

:************************************************
:	X.3 Parameter 9 - Padding after CR	*
:************************************************
:	SET
XS.090	CLHI	RBC,X3.9MX
	JGR	R9
	STB	RBC,X3.P9,RPI
	JAL	RCH,X.MAP
	J	4,R9

:	EXTENDED SET
EXS090	LIS	R2,9
	J	EXSVAL

:	READ
XR.090	LB	R3,X3.P9,RPI		:get value of parm 9 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR090	LIS	R2,9
	J	EXRVAL

:************************************************
:	X.3 Parameter 10 - Line Folding		*
:************************************************
:	SET
XS.100	STB	RBC,X3.P10,RPI		:any value is OK
	LIS	R0,0
	STB	R0,CARPOS+1,RPI	:start out at carriage position 0
	J	4,R9

:	EXTENDED SET
EXS100	LIS	R2,$A10
	J	EXSVAL

:	READ
XR.100	LB	R3,X3.P10,RPI		:get value of parm 10 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR100	LIS	R2,$A10
	J	EXSVAL

:************************************************
:	X.3 Parameter 11 - Binary Speed		*
:************************************************
:	SET
XS.110	JR	R9			:not user selectable

:	EXTENDED SET
EXS110	LIS	R2,$A11
	J	EXSVAL

:	READ
XR.110	LB	R3,X3.P11,RPI		:get value of parm 11 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR110	LIS	R2,$A11
	J	EXRVAL

:************************************************
:	X.3 Parameter 12 - Flow Control of PAD	*
:************************************************
:	SET
XS.120	RBT	RP,RXON		:release backpressure (??CHECK THIS)
	SIS	RBC,1		:is reverse XON/XOFF to be enabled?
	JEFS	XS.121		:yes
	JGR	R9		:invalid value, error return
	RBT	RP,X3.P12	:no, disable reverse XON/XOFF
	J	4,R9		:normal return
XS.121	SBT	RP,X3.P12	:set REVERSE XON/XOFF enabled
	J	4,R9		:normal return

:	EXTENDED SET
EXS120	LIS	R2,$A12
	J	EXSSWI

:	READ
XR.120	LIS	R3,0			:assume reverse XON/XOFF disabled
	TBT	RP,X3.P12		:is it on?
	JER	R9			:no, just return
	LIS	R3,1			:yes, reverse XON/XOFF enabled
	JR	R9			:return

:	EXTENDED READ
EXR120	LIS	R2,$A12
	J	EXRSWI

:************************************************
:	X.3 Parameter 13 - LF insertion after CR*
:************************************************
:	SET
XS.130	CLHI	RBC,7			:check max value
	JGR	R9			:if too big, take error exit
	RBT	RP,ECR.LF		:reset consat flag
	STB	RBC,X3.P13,RPI		:set parameter 13
	J	4,R9			:and take normal exit

:	EXTENDED SET
EXS130	LIS	R2,$A13
	J	EXSVAL

:	READ
XR.130	LB	R3,X3.P13,RPI		:get value of parm 13 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR130	LIS	R2,$A13
	J	EXRVAL

:************************************************
:	X.3 Parameter 14 - LF padding		*
:************************************************
:	SET
XS.140	CLHI	RBC,7
	JGR	R9
	STB	RBC,X3.P14,RPI
	JAL	RCH,X.MAP
	J	4,R9

:	EXTENDED SET
EXS140	LIS	R2,$A14
	J	EXSVAL

:	READ
XR.140	LB	R3,X3.P14,RPI		:get value of parm 14 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR140	LIS	R2,$A14
	J	EXRVAL

:************************************************
:	X.3 Parameter 15 - Data Editing Switch	*
:************************************************
:	SET
XS.150	SIS	RBC,1
	JL	XS.152			:if turning off
	JGR	R9	
	SBT	RP,X3.P15
	J	4,R9

XS.152	RBT	RP,X3.P15
	J	4,R9

:	EXTENDED SET
EXS150	LIS	R2,$A15
	J	EXSSWI

:	READ
XR.150	LIS	R3,0			:assume zero, editing - disabled
	TBT	RP,X3.P15		:is it on?
	JER	R9			:no, just return
	LIS	R3,1			:yes, return one, editing - enabled
	JR	R9			:return

:	EXTENDED READ
EXR150	LIS	R2,$A15
	J	EXRSWI

:************************************************
:	X.3 Parameter 16 - Character Delete	*
:************************************************
:	SET
XS.160	CLHI	RBC,$A127
	JGR	R9
	STB	RBC,X3.P16,RPI
	J	4,R9

:	EXTENDED SET
EXS160	LHI	R2,$A16
	J	EXSVAL

:	READ
XR.160	LB	R3,X3.P16,RPI		:get value of parm 16 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR160	LHI	R2,$A16
	J	EXRVAL

:************************************************
:	X.3 Parameter 17 - Line Delete		*
:************************************************
:	SET
XS.170	CLHI	RBC,$A127
	JGR	R9
	STB	RBC,X3.P17,RPI
	J	4,R9

:	EXTENDED SET
EXS170	LHI	R2,$A17
	J	EXSVAL

:	READ
XR.170	LB	R3,X3.P17,RPI		:get value of parm 17 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR170	LHI	R2,$A17
	J	EXRVAL

:************************************************
:	X.3 Parameter 18 - Line Display		*
:************************************************
:	SET
XS.180	CLHI	RBC,$A127
	JGR	R9
	STB	RBC,X3.P18,RPI
	J	4,R9

:	EXTENDED SET
EXS180	LHI	R2,$A18
	J	EXSVAL

:	READ
XR.180	LB	R3,X3.P18,RPI		:get value of parm 18 from port table
	JR	R9			:normal return

:	EXTENDED READ
EXR180	LHI	R2,$A18
	J	EXRVAL

: EXTENDED PARAMETER SET AND EXTENDED PARAMETER READ 

EXSVAL	JAL	R9,GETVAL		:R2 = parameter number
	 J	CEREAC			:read CCITT parameter
	J	CESETC			:set  CCITT parameter

EXRVAL	JAL	R9,GETVAL		:R2 = parameter number
	 J	CEREAC			:read CCITT parameter
	J	CESERC			:set and read CCITT parameter

EXSSWI	JAL	R9,GETSWI		:R2 = parameter number
	 J	CEREAC			:read CCITT parameter
	J	CESETC			:set  CCITT parameter

EXRSWI	JAL	R9,GETSWI		:R2 = parameter number
	 J	CEREAC			:read CCITT parameter
	J	CESERC			:set and read CCITT parameter


:	Set up for Extended SET , READ, and SET & READ Commands
:	Prepare to SET an X.3 parameter
CESERC	LIS	R0,1			:set and read
	JFS	CESETX			:

CESETC	LIS	R0,0			:set only
CESETX	STB	R0,SANDR		:continue
	LIS	R4,0			:index to *CMDBUF*
	STH	R2,PARREF		:save parm ref for future use
	STB	R2,CMDBUF		:save ref                 
	STB	RBC,CMDBUF+1		:save par value           
	LHL	R9,XSET,R2,R2		:get dispatch address
	JAL	R9,BASE,R9,		:go set the parameter
	 J	CESINV			:if the value was bad
	J	CESRTN			:else proper return

:	Handle invalid SETs
CESINV	LHL	R2,PARREF            	:restore reg with parm no. 
	OHI	R2,80			:set high order bit
	STB	R2,CMDBUF,R4        	:place in CMDBUF

:	Return for all SETs
CESRTN	AIS	R4,2			:setup R4 for PARSND
	J	PARSND			:

:	Prepare to READ an X.3 parameter
CEREAC	LIS	R0,1			:
	STB	R0,SANDR		:indicate READ
	LIS	R4,0			:
	STB	R2,CMDBUF,R4		:
	LHL	R9,XREAD,R2,R2		:get dispatch address
	JAL	R9,BASE,R9,		:go read parameter setting
	STB	R3,CMDBUF+1,R4		:save setting
	AIS	R4,2			:setup R4 for PARSND
	J	PARSND			:send values out to user


::	PARRED	-	read a terminal parameter (X.29)
:
:		Input -	R2 = reference (parameter number)
:			R3 = value (returned)
:
:		Return R9, if error (bad ref)
:		     4,R9  if OK
:
:		Destroys R2,RCH

PARRED	LR	R2,R2			:
	JL	PARRE1			:if invalid ref (negative)
	JNFS	PARR05			:if not zero
	SBT	RP,PARTYP		:GOT A NATIONAL MARKER.
	TBT	RP,NOMERR		:
	JN	PARRE2			:
	LIS	R3,0			:SET IT UP SO 0:0 WILL BE RETURNED
	JE	4,R9			:TAKE NORMAL RETURN

PARR05	TBT	RP,NOMERR		:invaled Natl Opt Mrk found?
	JN	PARRE5			:error, exit
	LA	R3,CPAROK		:assume CCITT parameter
	TBT	RP,PARTYP		:CCITT or tymnet parameter?
	JEFS	PARR10			:
	LA	R3,TPAROK		:assume tymnet parameter
PARR10	TBT	R2,0,R3			:check for valid parameter
	JEFS	PARRE1			:no, take error exit
	AIS	R9,4			:adjust link for good return
	LHL	R3,XREAD,R2,R2		:get dispatch ADDRESS
	J	BASE,R3,		:go read parameter setting
					:and return via R9

PARRE1	LIS	R3,1			:ERR 1 - invalid parameter ref
	JR	R9

PARRE2	LIS	R3,2			:ERR 2 - invalid parameter val
	JR	R9			:(only occurs for NOM on read)

PARRE5	LIS	R3,5			:ERR 5 - parameter follows a
	JR	R9			:if bad national option marker

::	PARSET	- set a terminal parameter (X.29)
:
:		Input - RBC= value
:			R2 = parameter number (parameter reference)
:
:		Return  R9 if invalid parameter number
:		      4,R9 if invalid parameter value
:		      8,R9 if OK normal return
:
:		Destroys R3,RCH

PARSET	LR	R2,R2			:check parameter number
	JLR	R9			:error return, none
	JGFS	PARST1			:value not 0, not tym natl parm opt mkr
	SBT	RP,PARTYP		:assume 0:0, doing TYM Natl parms
	LR	RBC,RBC			:check if really 0:0 TYM Natl parm
	JE	8,R9			:take normal return
	SBT	RP,NOMERR		:invalid Tymnet Natl Opt Mark
	J	4,R9			:no, error return, value must be 0

PARST1	TBT	RP,NOMERR		:if NOMERR don't trust parm number
	JNR	R9			:error return
	LA	R3,CPAROK		:assume CCITT parameter
	TBT	RP,PARTYP		:CCITT or tymnet parameter?
	JEFS	PARST2			:
	LA	R3,TPAROK		:assume tymnet parameter
PARST2	TBT	R2,0,R3			:valid parameter reference?
	JER	R9			:error return
	SBT	RP,WHOSIT		:indicate remote interface calling
	AIS	R9,4			:adjust link for good return
	LHL	R3,XSET,R2,R2		:get dispatch address
	J	BASE,R3,		:go set parameter


:	GETSWI	-	get an ON or an OFF switch from *CMDBUF*
:		Input - R7=index to *CMDBUF*
:			R8=# chars left
:		Output	RBC=0, if OFF
:			   =1, if ON
:		DESTROYS R0,R3
:		Link on R9 (if done and no value found), 4+R9 (if value)
:		 Else Error Message sent and exit to *CMDRTN*
GETSWI	SIS	R8,1
	JLR	R9			:if done and no value
	LB	R0,CMDBUF,R7                                      
	AIS	R7,1
	CLHI	R0,SP
	JEBS	GETSWI			:if a blank...ignore it
	TBT	R0,LETTER
	JE	GETSW6			:if not a letter...check for 0 or 1
:	"off" or "on"
	LIS	R3,2			:need 2 more chars at most
GETSW2	SIS	R8,1
	JL	GETSW4			:if done...check value found
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	CLHI	RBC,COMMA
	JE	GETSW4			:if done...check value found
	TBT	RBC,LETTER
	JE	GETSW8			:if not a letter then not a switch
	NHI	RBC,5F			:..else make it UPPER CASE
	SLLS	R0,8
	OR	R0,RBC
	SIS	R3,1
	JG	GETSW2			:if may need more chars
	LR	R8,R8
	JLEFS	GETSW4			:if done...don't check for separator
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	CLHI	RBC,COMMA
	JN	GETSW8			:if not par separator...error
GETSW4	LIS	RBC,0
	CLI	R0,SWOFF
	JE	4,R9			:if switch is OFF then return 0
	LIS	RBC,1
	CLI	R0,SWON
	JE	4,R9			:if switch is ON, return 1
	J	GETSW8			:  else error

:	0 or 1
GETSW6	SHI	R0,ZERO			:convert ASCII to hex
	SIS	R8,1
	JLFS	GETSW7			:if done...don't check for separator
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	CLHI	RBC,COMMA
	JNFS	GETSW8			:if not separator...error
GETSW7	LR	RBC,R0
	JE	4,R9			:if OFF...return RBC=0
	SIS	R0,1
	JE	4,R9			:if ON...return RBC=1

:	Error return
GETSW8	LA	R6,SS.SE1,,		:invalid switch error msg
	J	CMDERR			:send error message and return


:	GETVAL	-	get a numeric value from *CMDBUF*
:		Input - R7=index to *CMDBUF*
:			R8=# chars left
:		Output	RBC=Value
:		Link on R9 (if done and no value found) or 4+R9 (if done 
:			or a blank follows value) or CMDERR (if non-digit)
GETVAL	SIS	R8,1
	JLR	R9
	LB	RBC,CMDBUF,R7                                     
	AIS	R7,1
	CLHI	RBC,SP
	JEBS	GETVAL
	TBT	RBC,ASDIG
	JE	PARER2			:if a non-digit seen
	LIS	R3,0A			:decimal to binary conversion multiplier
	SHI	RBC,ZERO		:convert ASCII to binary
GETVA2	SIS	R8,1
	JL	4,R9			:if done and found a value
	LB	R0,CMDBUF,R7                                      
	AIS	R7,1
	CLHI	R0,SP
	JE	4,R9			:if complete value found
	CLHI	R0,COMMA
	JE	4,R9
	TBT	R0,ASDIG
	JE	PARER2
	SHI	R0,ZERO
	MHR	RBC,R3			:mult last digits by ten
	AR	RBC,R0			:...and add in least signifivant digit
	CLHI	RBC,0FF
	JG	PARER3			:if bigger than 255 no goodnik
	J	GETVA2			:..else look for more digits


:	TY.MAP	- Map TYMNET CR Delay parameters A B C D into X3.P9 and X3.P14
:	When CRDE=1
:		X3.P9= F(C)
:		X3.P14= # characters in F(D), rounded up (7 is max)
:
:	When CRDE=0
:		X3.P9= # characters in F(D), rounded up
:		X3.P14= forced to 0 since delay occurs before LF
:			 in this case
:		DESTROYS R0-2,R9
:		Link on RCH

TY.MAP	LB	RBC,PAR.D,RP
	LB	R2,CPARAM,RBC,		:F(D)
	JAL	R0,TY.CPS		:F(D) in character times
	TBT	RP,CRDE
	JN	TY.M20			:if CRDE=1...use 2nd algorithm
:	CRDE=0
	STB	R2,X3.P9,RPI		:CR Padding = F(D)
	LIS	R0,0
	STB	R0,X3.P14,RPI		:LF Padding forced to 0
	JR	RCH

:	CRDE=1
TY.M20	STB	R2,X3.P14,RPI		:LF padding = F(D)
	LB	R2,CPARAM,RBC,		:F(C)
	JAL	R0,TY.CPS		:R2=worst case CR padding
	STB	R2,X3.P9,RPI
	JR	RCH

:	Convert delay in 1/30ths of a second to delay in character times
C.30	WC	1E
TY.CPS	LB	RBC,OBRATE,RP		:binary speed (TYMNET index)
	LB	RBC,TY.CC,RBC		:CCITT index
	LHL	RBC,XBRMAP,RBC,RBC	:characters per second
	MHR	R2,RBC			:cps*seconds/30
	LIS	RBC,0			:sign extend for divide
	D	R1,C.30
	LR	R1,R1
	JEFS	TY.CP2			:if no remainder
	AIS	R2,1			:..else round upward
TY.CP2	CLHI	R2,7
	JLER	R0
	LIS	R2,7
	JR	R0


:	X.MAP	- Map CCITT X3.P9 and X3.P14 into TYMNET Parameters
:		CR Delay  and A B C D
:
:	CR Delay is forced to 1 so that LF padding occurs after a LF
:	and not before (the so-called "alternate delay")
:
:		A=0
:		B=MIN(# 1/30ths of a sec in X3.P9, PB.MAX)
:		F(C)>=# 1/30ths of a sec in X3.P9
:		D=MIN(# 1/30ths of a sec in X3.P14, PD.MAX)
:	DESTROYS R0,RBC,R3,R9
:	Link on RCH
X.MAP	SBT	RP,CRDE			:indicate carriage return delay
	LB	RBC,X3.P9,RPI		:get setting from port table

:	Convert delay from char times to 1/30ths of a second
	LB	R3,OBRATE,RP		:use output baud rate
	LB	R3,TBRMAP,R3		:(sec/char)*30
	MHR	RBC,R3			:RBC = delay in 1/30ths of a second

	LR	R0,RBC			:save delay
	CLHI	RBC,PB.MAX		:> maximum value (15)?
	JLEFS	X.MAP2			:no
	LHI	RBC,PB.MAX		:else use max value of par 
X.MAP2	STB	RBC,PAR.B,RP		:save 
	LR	RBC,R0			:restore original value

:	Find R3 such that F(R3) >= RBC. If remainder >0, RBC=rem. Else RBC=0
	LIS	R3,0			:function argument from 0 to F
X.MAP3	LB	R0,CPARAM,R3,		:F(R3)
	CR	RBC,R0			:RBC<F(R3)?
	JLEFS	X.MAP4			:yes
	AIS	R3,1			:no, add one
	CLHI	R3,0F			:completed?
	JLEBS	X.MAP3			:no, return

X.MAP4	SR	RBC,R0			:RBC=remainder
	JGEFS	X.MAP5			:rem GE zero
	LIS	RBC,0			:rem less than zero, set RBC=0

X.MAP5	STB	R3,PAR.C,RP		:save PAR.C
	LB	RBC,X3.P14,RPI		:CCITT LF Padding

:	Convert delay from char times to 1/30ths of a second
	LB	R3,OBRATE,RP		:use output baud rate
	LB	R3,TBRMAP,R3		:(sec/char)*30
	MHR	RBC,R3			:RBC = delay in 1/30ths of a second

	CLHI	RBC,PD.MAX		:reached max?
	JLEFS	X.MAP6			:no, not too large
	LHI	RBC,PD.MAX		:else use max value of par D
X.MAP6	STB	RBC,PAR.D,RP		:store in port table
	JR	RCH			:exit


	SUBTTL	(PAD) Transmit Filters

:	PAD Related Function Transmit Filter--Backpressure Applied
:	==========================================================
:
:	Called by transmitter when a character is needed
:	Only supplies data characters from alternate-echo buffer
:	Processes some signals in .TTBUF
XPADBK	ST	RCH,EDSAVE
	TBT	RP,FRECHO
	JE	XPBK10
	L	RBP,.ECOBF,RPI
	JAL	RCH,GETCHR,,
	J	XPAD08			:signal...just pass it normally
	J	XPFOLD			:data...check line folding

XPBK10	TBT	RP,TOPORT
	JER	RLINK			:if nothing in to-terminal buffer
	JAL	RCH,CPEEK,,
	J	XPBK20			:if not a signal...ignore it
	LO	SIGNAL
	CLHI	RBC,ZAPSIG
	FO	SIGNAL
	JEFS	XPBK15			:if a zapper...handle specially
	JAL	RCH,GETCHR,,
	J	SIG.XP			:  else pass it normally
XPBK15	L	R1,.XPADS,RPI
	ST	R1,.XPADF,RPI		:restore normal PAD xmit filter
	JR	R1			:...and go to it

XPBK20	J	XDEF,,

:	PAD bit tables for efficient character processing by filter
CRTBL	WC	00040000,0,0,0		:CR with SPACE (0) parity
	WC	00040000,0,0,0		:CR with MARK (1) parity


:	PAD Related Function Transmit Filter
:	====================================
:
:	Called by Transmitter when a character is needed
XPADFI	ST	RCH,EDSAVE		:save the link register
	TBT	RP,FRECHO		:test if echo wanted
	JE	XPAD10			:no, go check for data in .TTBUF
	L	RBP,.ECOBF,RPI		:yes, get data from .ECOBF
	JAL	RCH,GETCHR,,		:
	J	XPAD08			:signal...just pass it
	TBT	RBC,CRTBL		:data...check if CR
	JE	XPFOLD			:no, go check line folding
	LB	R0,X3.P13,RPI		:yes, get parameter 13
	THI	R0,X3.13E		:and check LF after CR echo
	JE	XPFO10			:no
	J	XPLFIN			:yes, go do LF insertion

XPAD08	L	RCH,EDSAVE		:DUMB PLACE TO PUT EXIT
	JR	RCH

XPAD09	RBT	RP,PIIX			:return to data mode
XPAD10	TBT	RP,TOPORT		:
	JER	RLINK			:
	L	RBP,.TTBUF,RPI		:
	JAL	RCH,GETCHR,,		:
	J	SIG.XP			:signal...reset IIX flags
	TBT	RP,PIIX			:data...
	JN	XPAD18			:if packet mode interface involved
	TBT	RP,X3.P8		:discarding data?
	JNR	RLINK			:yes, eat it, just return

:	Check Linefeed Insertion after CR
	TBT	RBC,CRTBL		:check if CR
	JE	XPFOLD			:no, go check line folding
	LB	R0,X3.P13,RPI		:yes, get parameter 13
	THI	R0,X3.13T		:and check LF insertion after CR
	JE	XPFO10			:no

:	Linefeed Insertion after CR to DTE
XPLFIN	LHI	R0,X3DAT		:
	CLB	R0,X3STAT,RPI           :check current state
	JN	XPFOLD			:if not data state...don't insert LF
	TBT	RP,ECR.LF		:if consat XASCI handling it
	JN	XPFO10			:then skip LF insertion
	LR	R9,RBC			:preserve char
	LIS	RBC,0A			:LF
	JAL	RCH,WCD,,		:put in front of buffer
	LR	RBC,R9			:restore char

:	CR ==> reset carriage position
XPFO10	LIS	R0,0			:
	STB	R0,CARPOS+1,RPI		:
XPFO20	L	RCH,EDSAVE		:
	J	4,RCH			:

XPFO25					:OUTPUT A <BACKSPACE>
	LB	R0,CARPOS+1,RPI		:GET CURRENT POSITION
	JE	XPFO20			:IF ALREADY ZERO
	SIS	R0,1			:DECREMENT IT
	STB	R0,CARPOS+1,RPI		:AND SAVE IT
	J	XPFO20			:AND RETURN

XPFOLD	LR	R0,RBC		:rewritten to pass 8 bit data *500.sdw
	NHI	R0,7F			:
	CLHI	R0,09			:TAB?
	JN	XPFO28			:no, branch
	TBT	RP,X3.N2		:need to expand TAB with spaces?
	JE	XPFO20			:No, pass it.

EXPTAB	LB	R5,CARPOS+1,RPI		:load the carriage counter
	LR	R6,R5			:save in R6
	AIS	R5,8			:convert into the factor of 8
	NHI	R5,0FFF8		:for TAB expanding space counter
	SR	R5,R6			:number of expanded spaces is in R5

	LB	R4,.OFHTX,RPI		:GET OFFSET TO TAB EXP. COUNT TABLE
	L	R3,.TBHTX,RPI		:AND THE ADDRESS OF THE TABLE
	AR	R3,R4			:ADDRESS OF BYTE TO USE
	STB	R5,0,R3			:SAVE THE EXPANSION COUNT
	AIS	R4,1			:INCREMENT OFFSET TO TABLE
	CLHI	R4,HTXSIZ		:END OF TABLE (IN OTHER WORD, A RING)?
	JNFS	EXPTB5			:NOT YET, BRANCH
	LIS	R4,0			:WRAP AROUND
EXPTB5	STB	R4,.OFHTX,RPI		:SAVE THE OFFSET
XTAB20	LHI	RBC,SP			:store blank into character register
XTAB30	SIS	R5,1			:decrement by 1 after expand a space
	JLE	XTAB40			:if finish expanding
	ST	R5,TEMP1		:save R5 for this routine
	ST	R6,TEMP2		:save R6 for this routine
	JAL	RCH,WCD,,		:go to routine WCD
	L	R6,TEMP2		:restore back R5 and R6
	L	R5,TEMP1
	J	XTAB30			:continue expanding

XTAB40	LHI	R9,SP			:IN CASE THE LINE GETS FOLDED.
	J	XPFO30			:

XPFO28	CLHI	R0,0A			:
	JE	XPFO20			:if LF... just pass it as is
	CLHI	R0,0D			:
	JE	XPFO10			:if CR...reset carriage and pass it
	CLHI	R0,08			:
	JE	XPFO25			:IF <BS>
	TBT	R0,.ECHT1,RPI		:
	JN	XPFO20			:IF NON-PRINTABLE
: examine X3.P10 (line folding) and current cursor position to see if
: line folding is needed.
XPFO30
	LB	R0,X3.P10,RPI		:
	JEFS	XPFO35			:NO LINE FOLDING IN EFFECT
	SIS	R0,1			:CURSOR POSITION STARTS FROM ZERO
	CLB	R0,CARPOS+1,RPI		:
	JEFS	XPFO40			:if folding after this charater
XPFO35	LIS	R0,1			:  else just bump position
	AHM	R0,CARPOS,RPI		:
	J	XPFO20			:  and pass character

XPFO40	LR	R9,RBC			:
	LHI	RBC,8D			:CR of format effector
	JAL	RCH,WCD,,		:
	LHI	RBC,8A			:LF of format effector
	JAL	RCH,WCD,,		:
	LR	RBC,R9			:restore character
	J	XPFO20			:...and pass it


:	Process IIX Header 
:	==================
:
:	check for beginning of IIX message
XPAD18	RBT	RP,WIIXT0		:processed lst byte of msg
	JE	XPAD20			:if already got 1st byte of IIX prefix
	RBT	RP,IIXDIA		:initially processing global IIX msg
	CLHI	RBC,IX.DMM^-8		:non global IIX msg?
	JL	XPAD10			:no, global IIX msg (80)
	SBT	RP,IIXDIA		:yes, processing non-global IIX msg
	J	XPAD10			:return for next byte

:	processing 2nd byte of IIX msg prefix.  (message type)
XPAD20	TBT	RP,IIXDIA		:processing global IIX msg?
	JE	XPAD40			:yes
	SBT	RP,DNPROG		:no, indicate message in progress
	JN	XPAD30			:already processed 2nd byte of msg
	SHI	RBC,080			:valid msg type? >80
	JL	XPACL0			:no, error, clear call
	STB	RBC,EMTSAV,RPI		:save msg type
	CLHI	RBC,EXMMAX		:if unrecognized msg
	JG	XPACL0			:
	TBT	RBC,EXMZLN		:
	JE	XPAD10			:if not zero length msg

XPAD30	LB	R9,EMTSAV,RPI		:get saved message type
	LHL	R9,EXMDIA,R9,R9		:processor address
	JN	EXMDIA,R9		:jump to processor
	J	XPAD10			:ignore it

:	Global IIX messages.
XPAD40	SBT	RP,DNPROG		:
	JN	XPAD50			:if already started processing
	SHI	RBC,080			:
	JL	XPACL0			:if error
	STB	RBC,EMTSAV,RPI		:save message code
	CLHI	RBC,GLBMAX		:
	JG	XPACL0			:if unrecognizable message
	TBT	RBC,GLBZLN		:
	JE	XPAD10			:defer o backpressure can work*500.sdw
XPAD50	LB	R9,EMTSAV,RPI		:get saved message code
	LHL	R9,GLBIIX,R9,R9		:get routine address
	JN	GLBIIX,R9		:jump to processor
	J	XPAD10			:defer so backprs works *500.sdw


:	Here to clear the call.
:	(R9)= cause/ diagnostic to use
XPACL0	LHI	R9,CNETCG^8!DIA175	:network congestion, invalid dialect msg
XPACLR	STH	R9,PSDIAG,RPI		:
	L	RBP,.TTBUF,RPI		:
	JAL	RCH,EMPTY,,		:
	TBT	RP,TURKEY		:
	JE	XP.ZA4			:if non-turkey...zap circuit
	JAL	R9,SENCLR		:  else send clear indication
	J	XPAD10			:


	SUBTTL	(PAD) IIX Message Tables 

:	IIX Global and Dialect Message Processors
:	=========================================

:	Global IIX message processing table.
GLBIIX	HS	0
	HC	GIS.10-GLBIIX		:8080  select dialect command
	HC	GIR.10-GLBIIX		:8081  dialect response
	HC	GGS.10-GLBIIX		:8082  gateway reached smart host
	HC	GGD.10-GLBIIX		:8083  gateway reached dumb host
	HC	GNL.10-GLBIIX		:8084  normal logon status
GLBMAX	EQ	(.-GLBIIX)/2
GLBZLN	HC	$2 0011000000000000

:	XCOM dialect message processing table.
EXMDIA	HS	0
	HC	EX0D-EXMDIA		:EXM0 - level 0 data, M=0, Q=0
	HC	EX0DM-EXMDIA		:EXM1 - level 0 data, M=1, Q=0
	HC	EX0DQ-EXMDIA		:EXM2 - level 0 data, M=0, Q=1
	HC	EX0DMQ-EXMDIA		:EXM3 - level 0 data, M=1, Q=1
	HC	EX0CLC-EXMDIA		:EXM4 - level 0 clear cause
	HC	EX0CAS-EXMDIA		:EXM5 - level 0 short call connect
	HC	EX0RSC-EXMDIA		:EXM6 - level 0 reset cause
	HC	EXMCDA-EXMDIA		:EXM7  called address
	HC	EXMCGA-EXMDIA		:EXM8  calling address
  IF	NPAPRT  
	HC	EXMCUD-EXMDIA		:EXM9  call user data
  ELSE
	HC	0
  EI
	HC	EXMINT-EXMDIA		:EXMA  interrupt data
	HC	EXMINC-EXMDIA		:EXMB  interrupt confirmation
	HC	0			:EXMC  utilities
	HC	EXMFAC-EXMDIA		:EXMD  facilities
	HC	EX0CLD-EXMDIA		:EXME  level 0 clear diagnostic
	HC	EX0CAC-EXMDIA		:EXMF  level 0 call connect info
	HC	EX0RSD-EXMDIA		:EXM10  level 0 reset diagnostic
	HC	EX0RCO-EXMDIA		:EXM11  level 0 reset confirmation
	HC	EXMCAC-EXMDIA		:EXM12  call accept
	HC	EXMTUR-EXMDIA		:EXM13  turkey level number
	HC	EXMDTA-EXMDIA		:EXM14  data
	HC	EXMCLR-EXMDIA		:EXM15  clear
	HC	EXMRES-EXMDIA		:EXM16  reset
	HC	0			:EXM17  rpoa
EXMMAX	EQ	(.-EXMDIA)/2
EXMZLN	HC	$2 0000010000010000	:EXM0 - 0F
	HC	$2 0100000000000000	:EXM10 - 17
	HC	0			:EXM10 - 17

:	Dialect message length
	HS	0
LMMSIZ	BC	0		:EXM0
	BC	0		:EXM1
	BC	0		:EXM2
	BC	0		:EXM3
	BC	1		:EXM4
	BC	0		:EXM5
	BC	1		:EXM6
	BC	8		:EXM7
	BC	8		:EXM8
	BC	0		:EXM9
	BC	1		:EXMA
	BC	0		:EXMB
	BC	0		:EXMC
	BC	0		:EXMD
	BC	1		:EXME
	BC	0		:EXMF
	BC	1		:EXM10
	BC	0		:EXM11
	BC	0		:EXM12
	BC	2		:EXM13
	BC	0		:EXM14
	BC	2		:EXM15
	BC	2		:EXM16
	BC	0		:EXM17
	BC	2		:EXM18



	SUBTTL (PAD) Message Processors for IIX Dialects

:	XCOM dialect message processors.

:	Called address
EXMCDA	LA	R9,DTECLD,RPI		:
	J	EXMCG2			:treat same as calling address

:	Calling address
EXMCGA	LA	R9,DTECLG,RPI		:
EXMCG2	RBT	RP,WIIXT1		:
	JN	XCG.10			:if proc clgadr length
	LHL	R6,DNCNT,RPI		:
	SIS	R6,1			:
	STH	R6,DNCNT,RPI		:
	JLE	DIAERR			:if dialect msg too long...error
	LIS	R5,8			:max length of adr array entry for port
        SR      R5,R6			:
	STB	RBC,0,R9,R5		:save address (BCD) digit pair
	J	XPAD10			:

XCG.10
	STB	RBC,0,R9		:save cldadr length
	LB	RBC,EMTSAV,RPI		:index for msg length
	LB	RBC,LMMSIZ,RBC		:
	STH	RBC,DNCNT,RPI		:save length of dialect msg
	J	XPAD10			:

:	Dialect error
: REMARK	%>>>DIAERR   what do we do on dialect error?
DIAERR	ABORT(RBF,93)

:	Call user data
  IF	NPAPRT
EXMCUD	RBT	RP,WIIXT1		:
	JN	XCU.10			:if proc CUD length
	L	RBP,.ECOBF,RPI		:
	JAL	RCH,PUTCHR,,		:send a byte towards port
	LHL	R0,DNCNT,RPI		:
	SIS	R0,1			:
	STH	R0,DNCNT,RPI		:
	JG	XPAD10			:
	JAL	R9,IT.CAC		:send back a call accept
	J	XPAD09			:

XCU.10	STH	RBC,DNCNT,RPI		:save CUD length
: REMARK	%>>>XCU.10   what is diag?
	LHI	R9,CNETCG^8!0		:
	RBT	RP,LIMBO		:
	JE	XPACLR			:if port busy...must clear call
                        :calls allowed as long as limbo is set *sdw.500
XCU.50	SBT	RP,CALPRG		:call now in progress...
	RBT	RP,ICAPND		:and no longer pending
	LIS	R0,X3DAT		:
	STB	R0,X3STAT,RPI		:now in data transfer state   
	LHL	R0,EBSIZE,RP,RP		:have a packet size *600.sdw
	STH	R0,PSIZE,RPI		:to be stored
	SERSIG(SS.INC)			:announce incoming call
	LA	R6,DTECLG,RPI		:
	JAL	R9,OUTBCD		:
	LHI	RBC,SP			:
	JAL	RCH,PUTCHR,,		:
	SERSIG(SS.COM)			:
	LA	R9,XPAD10		:return addr
	LHL	R0,DNCNT,RPI		:
	JGR	R9			:if CUD...wait for it
	J	IT.CAC			:  else accept call


  EI
:	Turkey level number .
EXMTUR	RBT	RP,WIIXT1		:
	JN	XPAD10			:if processing 1st byte
	TBT	RP,EXTCAL		:
	JN	EXMTU4			:if incoming call...check level
:	process turkey level response.
	LHI	R9,CNETCG^8!DIA170	:
	CLHI	RBC,OURLEV		:
	JG	XPACLR			:if response > ours, clear(c,170)
	STB	RBC,TURLEV,RPI		:response is <= ours
	J	XPAD09			:continue via data mode

EXMTU4	CLHI	RBC,OURLEV		:
	JLEFS	EXMTU5			:if inc call < our level...use ours
	LHI	RBC,OURLEV		:
EXMTU5	STB	RBC,TURLEV,RPI		:
	LHI	R6,EXM13		:
	JAL	R9,BEGDIA		:start turkey level response
	LIS	RBC,0			:
	JAL	RCH,PUTCHR,,		:
	LB	RBC,TURLEV,RPI		:
	JAL	RCH,PUTCHR,,		:
	J	XPAD09			:

:	Following group of dialect messages are used only for Turkey level
:	zero.  It is used to talk to XCOM interfaces release 1.15.
:	Level 0 data messages.
EX0D	LIS	R0,0			:
	J	EX0D10			:

EX0DM	LHI	R0,MBIT			:
	J	EX0D10			:

EX0DQ	LHI	R0,QBIT			:
	J	EX0D10			:

EX0DMQ	LHI	R0,QBIT!MBIT		:
EX0D10	STB	R0,FLGBYT,RPI		:store flag byte
	RBT	RP,WIIXT1,,		:
	JE	XCD.60			:must be Q packets

EX0D20	STH	RBC,DNCNT,RPI		:store packet length
	J	XCD.40			:go process it

:	Clear/ reset diagnostic.
EX0RSD	HS
EX0CLD	STB	RBC,PSDIAG+1,RPI	:store clear diagnostic
	J	XPAD10			:

:	Reset.
EX0RSC	STB	RBC,PSDIAG,RPI		:store reset cause
	J	XRE.10			:do reset processing

:	Reset confirmation.
EX0RCO	TBT	RP,RESOUT		:
	JE	XPAD10			:if not in reset state
	J	XP.GO2			:

:	Clear cause.
EX0CLC	J	XCC.10			:

:	Short call connect
EX0CAS	J	GIS.40			:go connect call

:	Call connect
EX0CAC	LIS	R0,0			:
	STB	R0,DNCNT,RPI		:
	J	XCA.05			:

:	Clear cause/diag.
EXMCLR	RBT	RP,WIIXT1		:
	JN	XCC.10			:if processing cause byte
	STB	RBC,PSDIAG+1,RPI	:
	J	XPAD10			:

XCC.10	STB	RBC,PSDIAG,RPI		:
	J	XPAD10			:

:	Call accept.
EXMCAC	RBT	RP,WIIXT1		:
	JN	XCA.10			:if processing 1st byte of len
XCA.05	RBT	RP,WIIXT2		:
	JN	XCA.20			:if processing 2nd byte of len
	LHL	R6,DNCNT,RPI		:get current length count
	SIS	R6,1			:
	STH	R6,DNCNT,RPI		:
	JN	XPAD10			:if not at the end yet
:   Immediately send an accounting message if PAD receives a call
:   accept packet from the host
	SBT	RP,POCHNG		:
	SBT	RP,PICHNG		:
	SBT	RP,SOCHNG		:
	SBT	RP,SICHNG		:
	JAL	R6,PCTRPT		:Processs packet count
	JAL	R6,SCTRPT		:Process segment count   
	J	GIS.40			:go and connect call

XCA.10	STB	RBC,DNCNT,RPI		:store 1st byte of length
	J	XPAD10			:continue

XCA.20	STB	RBC,DNCNT+1,RPI		:store 2nd byte of length
	LHL	R6,DNCNT,RPI		:
	JN	XPAD10			:if more data to follow
	J	GIS.40			:go connect up


:	Interrupt data
EXMINT	LHI	R6,EXMB			:send back an interrupt confirmation
	JAL	R9,BEGDIA		:
	JAL	R4,CIP			:count input packet
	JAL	R4,COP			:count output packet
	J	XPAD09			:

:	Interrupt Confirmation
EXMINC	RBT	RP,INTOUT		:reset interrupt outstanding flag
	JAL	R4,CIP			:count input packet
	J	XPAD09			:


:	Facilities
: REMARK	%>>>EXMFAC  what do we do with facilities?
EXMFAC	RBT	RP,WIIXT1		:
	JN	XPAD10			:if Proc "len+1" byte
	RBT	RP,WIIXT2		:
	JN	XFA.20			:if proc facility length
	LHL	R0,DNCNT,RPI		:
	SIS	R0,1			:
	STH	R0,DNCNT,RPI		:
	J	XPAD10			:

XFA.20	STH	RBC,DNCNT,RPI		:
	J	XPAD10			:

:	Reset
EXMRES	RBT	RP,WIIXT1		:
	JN	XRE.30			:if processing cause byte
	STB	RBC,PSDIAG+1,RPI	:
XRE.10	JAL	R4,CIP			:count input packet
	TBT	RP,CALPRG		:is there a call in progress?
	JE	XPAD10			:no, ignore reset-non data trans mode
:	P.BCT added to code, must be reinitialized to zero *6.02 dlg
	LIS	RBP,0			:prepare to init character byte count
	STH 	RBP,P.BCT,RPI		:init character byte count to zero
	L	RBP,.TTBUF,RPI		:get to-terminal buffer pointer
	JAL	RCH,EMPTY,,		:empty buffer
	L	RBP,.FEDBF,RPI		:get edit buffer pointer
	JAL	RCH,EMPTY,,		:empty buffer
	L	RBP,.FTBUF,RPI		:get from-terminal buffer pointer
	JAL	RCH,EMPTY,,		:empty buffer
	RBT	RP,INTOUT		:cancel interrupt status
	 LO	SIGNAL
	LIS	R4,GOBSIG		:
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:
	LB	R0,TURLEV,RPI		:get turkey level
	JNFS	XRE.20			:if not level 0
	LHI	R6,EXM11		:send back a reset confirmation
	JAL	R9,BEGDIA		:
XRE.20	SERSIG(SS.RES)			:put out reset header
	LIS	R4,1			:indicate reset
	JAL	R9,OUTCDL		:fill in cause and diagnostic
	JR	RLINK			:bypass transmitter

XRE.30	STB	RBC,PSDIAG,RPI		:store diagnostic byte
	J	XPAD10			:

:	Data packet.
EXMDTA	RBT	RP,WIIXT1		:
	JN	XCD.10			:if processing flag byte
	RBT	RP,WIIXT2		:
	JN	XCD.20			:if processing 1st byte of len, ignore
	RBT	RP,WIIXT3		:
	JN	XCD.40			:if processing 2nd byte of len
	J	XCD.60			:must be X.29 packet

XCD.10	STB	RBC,FLGBYT,RPI		:store flag byte
	J	XPAD10			:

XCD.20	STB	RBC,DNCNT,RPI		:
	J	XPAD10			:

XCD.40	STB	RBC,DNCNT+1,RPI		:store length
	LHL	R0,DNCNT,RPI		:
	JAL	R4,CISP			:count input packet and segment
	LB	R6,FLGBYT,RPI		:
	RBT	RP,PIIX			:set data mode
XCD.50	SBT	RP,WTMSG		:set to expect message code next
	THI	R6,QBIT			:
	JE	XRET,,			:let backprs work*500.sdw
	SBT	RP,PIIX			:keep in non data mode
	SBT	RP,WTPREF		:set to expect parameter reference
	RBT	RP,X29RED		:
	RBT	RP,X29SET		:
	LIS	R0,0			:
	STH	R0,X29CNT,RPI		:initiate response count
	J	XRET,,			:let backprs work*500.sdw

	SUBTTL	(PAD) XCOM (turkey) Dialect Message Senders

:	Generate a Call Accept
IT.CAC	ST	R9,TEMP			:
	LHI	R6,EXM12		:
	LB	R2,TURLEV,RPI		:
	JNFS	IT.CA2			:if not turkey level 0
	LHI	R6,EXMF			:
	JAL	R9,BEGDIA		:
	J	IT.CA4			:

IT.CA2	JAL	R9,BEGDIA		:start call accept
	LIS	RBC,0			:
	JAL	RCH,PUTCHR,,		:send 1st byte of length
IT.CA4	LIS	RBC,1+1			:calc len of clgadr/cldadr, facs
	LR	R6,RPI			:
	LB	R0,DTECLG,R6		:# clgadr digits
	AIS	R0,1			:
	SRLS	R0,1			:# clgadr bytes (digit pairs)
	AR	RBC,R0			:
	LB	R9,DTECLD,R6		:# cldadr digits
	LHI	R0,1,R9			:
	SRLS	R0,1			:# cldadr bytes (digit pairs)
	AR	RBC,R0			:
	JAL	RCH,PUTCHR,,		:send 2nd byte of length
	LB	RBC,DTECLG,R6		:
	SLLS	RBC,4			:
	OR	RBC,R9			:
	JAL	RCH,PUTCHR,,		:send clgadr/cldadr lengths
	LR	R9,R9			:
	JLEFS	IT.CA6			:if no cldadr...skip it
IT.CA5	LB	RBC,DTECLD+1,R6		:
	JAL	RCH,PUTCHR,,		:2 address digits
	AIS	R6,1			:
	SIS	R9,2			:
	JGBS	IT.CA5			:
	LR	R6,RPI			:
IT.CA6	LB	R9,DTECLG,R6		:
	JLEFS	IT.CA8			:if no clgadr...skip it
IT.CA7	LB	RBC,DTECLG+1,R6		:
	JAL	RCH,PUTCHR,,		:
	AIS	R6,1			:
	SIS	R9,2			:
	JGBS	IT.CA7			:
IT.CA8	LIS	RBC,0			:
	JAL	RCH,PUTCHR,,		:
	L	R9,TEMP			:
	JR	R9			:




	SUBTTL	(PAD) X.29 IIX Message Processors and Tables

:	X.29 packet procesisng table

X29ER1	EQ	1			:X.29 error message type 1
X29ER2	EQ	2			:X.29 error message type 2

:	preprocess message
X29TBL	HS
	HC	X29IGN-X29TBL		:0  parameter indication
	HC	X29CL0-X29TBL		:1  invitation to clear
	HC	X29SE0-X29TBL		:2  set
	HC	X29BRK-X29TBL		:3  indication of break
	HC	X29RE0-X29TBL		:4  read
	HC	X29IGN-X29TBL		:5  error
	HC	X29SR0-X29TBL		:6  set and read
X29MAX	EQ	(.-X29TBL)/2

:	message in progress
	HC	X29IGN-X29TBL		:0  parameter indication
	HC	X29.E2-X29TBL		:1  invitation to clear
	HC	X29SNR-X29TBL		:2  set
	HC	X29BRK-X29TBL		:3  indication of break
	HC	X29SNR-X29TBL		:4  read
	HC	X29IGN-X29TBL		:5  error
	HC	X29SNR-X29TBL		:6  set and read

:	Processing X.29 messages
XCD.60	LHI	R9,X29MAX*2		:
	RBT	RP,WTMSG		:
	JE	XCD.70			:if already got message code
	RBT	RP,PARTYP		:start out with X.3 parameters
	RBT	RP,NOMERR		:clear Natl Opt Mrk error flag
	LHL	R4,DNCNT,RPI		:
	SIS	R4,1			:
	STH	R4,DNCNT,RPI		:decrement packet count
	LIS	R9,0			:use preprocessing table
	NHI	RBC,07F			:mask out high bit
	STB	RBC,X29MSG,RPI		:save message code
	SBT	RP,WTPREF		:set to expect par ref next
XCD.70	LB	R4,X29MSG,RPI		:get saved message code
	CLHI	R4,X29MAX		:check if valid
	JGE	X29.E1			:if message code out of range
	AR	R4,R4			:
	LHL	R4,X29TBL,R9,R4		:get routine name
	J	X29TBL,R4		:jump to processor

:	Ignore following messages:
:	Parameter indication
:	Error PAD message
X29IGN	J	XPAD10			:ignore

:	Invitation to clear
X29CL0	LIS	R9,0			:clear (0,0)
	J	XPACLR			:go to clear processing

:	send PAD error message
X29.E1	LIS	R4,X29ER1		:error type 1 - bad parameter ref
	JFS	X29.ER
X29.E2	LIS	R4,X29ER2		:error type 2 - bad parmeter value
X29.ER	STB	R4,TEMP			:
	LIS	R6,2			:length of 2
	LHI	R0,QBIT			:flag byte
	JAL	R9,OUTPKT		:output data packet
	LIS	RBC,X29.5		:error message
	JAL	RCH,PUTCHR,,		:
	LB	RBC,TEMP		:get error type to send
	JAL	RCH,PUTCHR,,		:
	LB	RBC,X29MSG,RPI		:get saved message code
	JAL	RCH,PUTCHR,,		:
	J	XPAD10			:


:	Indication of break
X29BRK	SBT	RP,WTPREF		:set to expect discard output
	L	RBP,.ECOBF,RPI		:
	 LO	SIGNAL
	LHI	R4,BBSIG		:send a break signal to terminal
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:
	J	XPAD10			:

:	process discard output
X29BR1	RBT	RP,WTPREF		:
	JEFS	X29BR2			:if alrady got discard output
	CLHI	RBC,X3.8		:
	JN	X29.E2			:if not discard output
	J	XPAD10			:

X29BR2	SIS	RBC,1			:
	JN	X29.E2			:if not 'ON'
:	do discard output and put out discard output off msg
	LHI	R0,QBIT			:
	LIS	R6,3			:length
	LIS	RBC,X29.2		:set message
	JAL	RCH,PUTCHR,,		:
	LIS	RBC,X3.8		:discard output
	JAL	RCH,PUTCHR,,		:
	LIS	RBC,OFF			:...OFF
	JAL	RCH,PUTCHR,,		:
	J	XPAD10			:

:	Set
X29SE0	JAL	RCH,EDSFWD		:data forward
	SBT	RP,X29SET		:
	SBT	RP,X29OUT		:no need to send response unless error
	RBT	RP,SETERR		:no error yet
	LHL	R4,DNCNT,RPI		:
	JN	XPAD10			:if parameter following
:	Set all message.
	JAL	R9,INITX3		:set all parameters
	J	XPAD10			:

:	Read
X29RE0	JAL	RCH,EDSFWD		:data forward
	RBT	RP,X29OUT		:set to start parameter indication
	SBT	RP,X29RED		:
	LHL	R4,DNCNT,RPI		:
	JN	XPAD10			:if more parameters to follow
	J	X29SR2			:read all parameters

:	Set and Read
X29SR0	JAL	RCH,EDSFWD		:data forward
	RBT	RP,X29OUT		:set to start parameter indication
	SBT	RP,X29RED		:
	SBT	RP,X29SET		:
	LHL	R4,DNCNT,RPI		:
	JN	XPAD10			:if more parameters to follow
:	set and read all parameters.
	JAL	R9,INITX3		:set all parameters
:	read all parameters.
X29SR2	LHI	R0,QBIT			:
	LHI	R6,X3MAX*2+1		:length to use
	JAL	R9,OUTPKT		:
	LIS	RBC,X29.0		:parameter indication message
	JAL	RCH,PUTCHR,,		:
	LIS	R6,1			:start from parameter 1
X29SR4	LR	RBC,R6			:
	JAL	RCH,PUTCHR,,		:
	LR	R2,R6			:parameter reference
	JAL	R9,PARRED		:
	NOP				:error return
	L	RBP,.FTBUF,RPI		:restore from terminal buffer
	LR	RBC,R3			:value returned
	JAL	RCH,PUTCHR,,		:
	AIS	R6,1			:
	CLHI	R6,X3MAX		:
	JLE	X29SR4			:
	J	XPAD10			:

:	Process set, read, and set and read messages
X29SNR	RBT	RP,WTPREF		:
	JE	X29S10			:if this is the parameter value
	STB	RBC,X29PAR,RPI		:store parameter reference
	LHL	RBC,DNCNT,RPI		:
	SIS	RBC,1			:decrement packet count
	STH	RBC,DNCNT,RPI		:
	JN	XPAD10			:if more data
	J	X29.E2			:...error

:	Do set and/or read for given parameter and value.
X29S10	LHL	R4,DNCNT,RPI		:
	SIS	R4,1			:
	STH	R4,DNCNT,RPI		:
	SBT	RP,WTPREF		:expect another parameter reference
	LB	R2,X29PAR,RPI		:get saved parameter reference
	JNFS	X29S15			:is this a Natl Opt Mrk?
	LR	RBC,RBC			:is this a valid Natl Opt Mrk?
	JEFS	X29S15			:yes
	SBT	RP,NOMERR		:no, indicate invalid
	LIS	RBC,2			:ERR 2
	STB	RBC,X29PER,RPI		:
X29S15	TBT	RP,X29SET		:
	JE	X29S20			:if not to set value
	JAL	R9,PARSET		:set parameter
	 J	X29S16			:error return, bad parm no
	 J	X29S17			:error return, bad parm value
	 J	X29S20			:normal return
:	send a parameter indication message
:	Error in set terminal parameter, invalid parameter number
X29S16	LIS	R3,1			:ERR 1 - invalid parameter
	TBT	RP,NOMERR		:
	JEFS	X29S18			:
	LIS	R3,5			:ERR 5 - parameter follows bad NOM
	JFS	X29S18
:	Error in set terminal parameter, invalid parameter value
X29S17	LIS	R3,2			:ERR 2
X29S18	STB	R3,X29PER,RPI		:save error code
	LB	RBC,X29PAR,RPI		:
	OHI	RBC,80			:add in error bit
	STB	RBC,X29PAR,RPI		:
	LB	RBC,X29MSG,RPI		:get message type
	CLHI	RBC,X29.2		:
	JNFS	X29S25			:if not set message
	SBT	RP,SETERR		:
	JNFS	X29S25			:if alrady started error response
	RBT	RP,X29OUT		:send indication for the first time
	JFS	X29S25			:
X29S20	TBT	RP,X29RED		:
	JE	XPAD10			:if not to read parm
:	initiate X.29 packet
X29S25	LHL	R4,X29CNT,RPI		:
	AIS	R4,2			:update X.29 response count
	STH	R4,X29CNT,RPI		:
	LB	R9,FLGBYT,RPI		:get original flag byte
	LHL	R4,DNCNT,RPI		:
	JEFS	X29S30			:if the end of packet
	OHI	R9,MBIT			:add in M-bit
	JFS	X29S35			:

X29S30	RBT	RP,PIIX			:RESET "PROCESSING IIX FLAG"
	LHL	R0,X29CNT,RPI		:get count to use for segment accounting
	JAL	R4,COSP			:count output packet, segment
X29S35	LR	R0,R9			:flag byte to use
	LI	R6,8002			:length of 2, indicate no acct
	TBT	RP,X29OUT		:
	JNFS	X29S38			:if indication already out
	AIS	R6,1			:account for indication
X29S38	JAL	R9,OUTPKT		:output data packet, no accounting
	SBT	RP,X29OUT		:
	JNFS	X29S50			:if indication already out
	LIS	RBC,X29.0		:pad indication message
	JAL	RCH,PUTCHR,,		:
:	read parameter
X29S50	LB	R3,X29PER,RPI		:force value if error
	LB	R2,X29PAR,RPI		:get parameter reference
	THI	R2,80			:
	JNFS	X29S60			:if error 
	JAL	R9,PARRED		:read parameter
	 J	X29S55			:+0 ...error return
	JFS	X29S60			:+4 ...normal return
	
:	Error in read, set error bit on parameter reference
X29S55	LB	RBC,X29PAR,RPI		:
	OHI	RBC,80			:
	STB	RBC,X29PAR,RPI		:
X29S60	L	RBP,.FTBUF,RPI		:
	LR	R9,R3			:save result
	LB	RBC,X29PAR,RPI		:get parm
	JAL	RCH,PUTCHR,,		:
	LR	RBC,R9			:value returned
	JAL	RCH,PUTCHR,,		:
	J	XPAD10			:




	SUBTTL	(PAD) IIX Global Message Processors

:	Global Message Receivers
:	------------------------

:	Origination Host -  Process select dialect command.
GIS.10
        SBT	RP,WIIXT1
	JN	GIS.50			:if processing 1st byte of dialect type
	CLHI	RBC,ID.XGT&0FF
	JE	GIS.30			:if gateway reached
	CLHI	RBC,ID.XCM&0FF
	JN	GIS.25			:if not the XCOM dialect
	TBT	RP,PADACT		:port in command mode?
	JE	GIS.25			:no in login mode, cannot talk turkey
	L	R0,.VSAVE,RPI		:get saved state
	ST	R0,.VSTAT,RPI		:restore it

        RBT     RP,GATCAL       :not talking to gateway *500.sdw
        RBT     RP,XTGATE
        JEFS    GIS.18          :if was talking to gate then special
        LIS     R0,X3DAT        :switch to data mode 
        STB     R0,X3STAT,RPI	:store state of port
        LA      R6,SS.CON,,     :give them another connect msg
        L       RBP,.ECOBF,RPI  :so know that finally there
        JAL     R5,OUTSTR,,
GIS.18	SBT	RP,TURKEY		:indicate dialect found
	J	XPAD10			:continue

GIS.25	L	R0,.VSAVE,RPI		:get saved state
	ST	R0,.VSTAT,RPI		:restore it
	RBT     RP,XTGATE       	:500.sdw
        RBT	RP,GATCAL		:not talking to gateway
        CLHI    RBC,ID.ASC&0FF
	JN	XPAD10			:if not ascii dialect, continue search

:	ASCII dialect, send response and connect call.
	SBT	RP,XASCII		:talk ASCII dialect
	J	XPAD10

GIS.30	L	R0,.VSAVE,RPI		:get saved state
	ST	R0,.VSTAT,RPI		:restore it
	SBT	RP,XTGATE	:indicate reached T-T gateway the smart way
	SBT	RP,GATCAL		:indicate call through gateway
	RBT	RP,ECHO			:turn off echo
        TBT     RP,CALPRG
        JNFS    GIS.31                  :process like GIS.40 but end in Gat mod
        ST      RLINK,TEMP
        JAL     RCH,EDSFWD              :forward whatever is
        JAL     RLINK,CALCON            :connect (but it puts us Data mode)
        L       RLINK,TEMP
GIS.31  LIS     R0,X3GAT                :and gateway iix mode
        STB     R0,X3STAT,RPI           :*500.sdw
        J       XPAD10

GIS.40	TBT	RP,CALPRG		:call already in progress?
	JN	XPAD10			:yes, get next character
	ST	RLINK,TEMP		:store return to xmit
	JAL	RCH,EDSFWD		:forward call user data, if any
	JAL	RLINK,CALCON		:connect the call
	L	RLINK,TEMP                                        
	J	XPAD10

GIS.50	RBT	RP,WIIXT1
	CLHI	RBC,80
	JN	XPACL0			:clear the call (C,148)
	J	XPAD10			:continue


:	Destination Host -  process Select dialect response
GIR.10	SBT	RP,WIIXT1
	JN	GIS.50			:if processing 1st byte of dialect type
	CLHI	RBC,ID.XCM&0FF		:is this XCOM dialect, 8083
	JEFS	GIR.11			:yes,  
        CLHI    RBC,ID.ASC&0FF		:no, is the ASCII dialect, 8081
	JN	XPACL0			:if response is neither
	SBT	RP,XASCII		:talk ASCII dialect
	JAL	R9,XICA20		:set up for dumb host calling
	J	XPAD09			:return
GIR.11	SBT	RP,TURKEY		:talk XCOM dialect
	J	XPAD09			:return

:	Gateway reached dumb host
GGD.10	RBT	RP,IIXCAL
: moved here from GIS.30  *500.sdw
  :  reset to default profile 0 (Tymnet transparent)
  :  to match Tymnet assumptions
 	STM	R0,TEMPA		:save register
 	LIS	R1,0			:reset current profile to 
 	STB	R1,X3CPRO,RPI		:profile 0 (Tymnet transparent)
 	JAL	R9,INITCS		:together with its CONSAT arrays
 	JAL	R9,INITX3		:together with its parameters
 	SBT	RP,X3.P12		:set Reverse X-ON and X-OFF
        LR      R1,RPI                  :Profile 0 includes old printable list
 	SBT	RP,X3.P5		:set X-ON, X-OFF
        LM      R12,PABLE,,             :consat's printable set
        STM     R12,.ECHT1,R1           :0-7F into port table
        STM     R12,.ECHT2,R1           :80-FF into port table
 	LM	R0,TEMPA		:restore back register

GGD.20	SBT	RP,SENDON		:release backpressure
	RBT	RP,XTGATE		:not talking to gateway anymore
	J	XPAD09

:	Gateway reached smart host
GGS.10	SBT	RP,IIXCAL
	JBS	GGD.20

:	Gateway Normal logon response
GNL.10	TBT	RP,XTGATE
	JE	XPACL0			:if not talking to gateway
	LR	R9,RBC			:set up status byte
	ST	RLINK,TEMP		:save return to xmit
	JAL	RLINK,L3STAT,,		:logon stat for gateway*500.sdw
	L	RLINK,TEMP		:restore rlink
	RBT	RP,PIIX			:return to data mode
	JR	RLINK


:	Global Message Senders
:	----------------------

:	Send Global Select Dialect Command
IG.SDI	L	RBP,.FTBUF,RPI
	 LO	SIGNAL
	LHI	R4,SIXSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:SIIX
	LHI	RBC,IX.SDC^-8
	JAL	RCH,PUTCHR,,
	LHI	RBC,IX.SDC&0FF
	JAL	RCH,PUTCHR,,		:Select Dialect Command
	LHI	RBC,ID.XCM^-8
	JAL	RCH,PUTCHR,,
	LHI	RBC,ID.XCM&0FF
	JAL	RCH,PUTCHR,,		:XCOM
	LHI	RBC,ID.ASC^-8
	JAL	RCH,PUTCHR,,
	LHI	RBC,ID.ASC&0FF
	JAL	RCH,PUTCHR,,		:ASCII
	 LO	SIGNAL
	LHI	R4,TIXSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:TIIX
	JR	R9


	LO	CONSAT
	LO	SIGNAL

SIG.XP	RBT	RP,PIIX
	RBT	RP,DNPROG
	CLHI	R5,SIXSIG
	JE	XP.SIX
	CLHI	R5,TIXSIG
	JE	XP.TIX
	CLHI	R5,ZAPSIG
	JE	XP.ZAP
:	CLHI	R5,ZAKSIG		:no longer needed because PAD does
:	JE	XP.ZAK			:not wait for ZAP ACK
	CLHI	R5,HNGSIG
	JE	XP.HNG
	CLHI	R5,GBSIG
	JE	XP.GB
	CLHI	R5,SECSIG
	JE	XP.SEC
	CLHI	R5,GOBSIG
	JE	XP.GOB
	CLHI	R5,OBSIG
	JE	XP.OB
	L	RCH,EDSAVE
	JR	RCH	


:	Start IIX message.
XP.SIX	RBT	RP,DNPROG
	SBT	RP,PIIX
	SBT	RP,WIIXT0
	SBT	RP,WIIXT1
	SBT	RP,WIIXT2
	SBT	RP,WIIXT3
	J	XPAD10			:continue

XP.TIX	TBT	RP,XTGATE		:through Tymnet gateway?
	JEFS	XP.TI2			:no
	RBT	RP,PIIX		:yes, pass any message text from gateway
	J	XPAD10			:return, and check for more data

XP.TI2	TBT	RP,TURKEY		:talking XCON (8083) dialect?
	JN	TURKOK			:yes, go send call request
	TBT	RP,XASCII		:using ASCII (8081)dialect?
	JE	XPACL0		:did not accept any dialect choices, clear call
	LHI	R6,ID.ASC		:select dialect response = 8081
	JAL	R9,SENDDR		:send dialect response
	J	GIS.40			:go connect call

XPEND	RBT	RP,PIIX
	RBT	RP,DNPROG
XP.HNG	L	R9,EDSAVE		:ret adr
	J	CLRCAL			:reset data arrays


:	The PAD has sent a ZAP out (Zap Acknowledgement)
XP.ZAK	TBT	RP,ICAPND		:incomplete inc call?
	JEFS	XP.ZK2			:no
	JAL	R9,CLRCAL		:yes, just reset arrays
	JR	RLINK			:return, don't send a zapper

XP.ZK2	SERSIG(SS.CC1)			:send user clear confirmation message
	J	XP.ZA5			:reset to original profile

:	The PAD has received a ZAPPER
XP.ZAP	TBT	RP,TURKEY		:non XCOM dialect?
	JE	XP.ZA4			:yes, not packet mode
	SERSIG(SS.CLR)			:output clearing header
	LIS	R4,0			:indicate clear - clr
	JAL	R9,OUTCDL		:fill in cause and diagnostic info
	JAL	R6,PCTRPT		:report final packet count
	JAL	R6,SCTRPT		:report final segment count
	L	RBP,.ECOBF,RPI		:get echo buffer pointer
	J	XP.ZA5			:initialize term parm and send prompt

XP.ZA4	L	RBP,.ECOBF,RPI		:get echo buffer pointer
	TBT	RP,PADACT               :was call made from command mode
	JE	XP.ZA6			:if back to login mode...no msg
	LA	R6,SS.CC0,,		:get address of msg - clr dte
	JAL	R5,OUTSTR,,		:send msg

XP.ZA5	STM	R0,TEMPA		:save all registers
	LB	R1,X3OPRO,RP,		:reset the original default profile
	STB	R1,X3CPRO,RPI		:to the current profile
	JAL	R9,INITCS		:also with it CONSAT arrays
	JAL	R9,INITX3		:also with its parameters
	LM	R0,TEMPA		:restore back all registers
	SERSIG(SS.PMT,PROMP)		:issue promp for command mode

XP.ZA6	JAL	R9,CLRCAL		:reset data arrays
	JR	RLINK			:and bypass transmitter

:	Green Ball Preprocessor
:	Used to coordinate DTE and host echo on requests
XP.GB	TBT	RP,GBO
	JE	XPAD08			:if no green balls out...pass it
	RBT	RP,ECHOON
	JN	XPAD08			:if DTE or host wants echo turned on
	SBT	RP,NBO			:  else just leave DEM (with echo off)
	RBT	RP,DEM
	LIS	R4,LDMSIG
	L	RCH,EDSAVE
	J	SIGRSP,,

:	Set Echo Control Preprocessor
:	Used to coordinate DTE and host echo requests
XP.SEC	THI	RBC,1
	JEFS	XP.SE2			:if turning off
	SBT	RP,ECHOON		:indicate echo on wanted by host
	J	XPAD08			:...and pass on signal

XP.SE2	RBT	RP,X3.P2		:turn off DTE echo on host request
	J	XPAD08			:...and pass on signal (so rcvr echo
					:	is also turned off)


XP.GOB	TBT	RP,RESOUT
	JE	XPAD08			:if not a reset conf...pass it

:   this code looks brain damaged.......
XP.GO2	RBT	RP,RESOUT
	L	RBP,.ECOBF,RPI
	LIS	R4,GOBSIG
	JAL	RCH,PUTSIG,,		:  else pass it (to stop flushing)
	LIS	RBC,CR
	JAL	RCH,PUTCHR,,		:1st echo cmd delimiter (since flushed)
	TBT	RP,ECR.LF
	JEFS	XP.GO4			:if not echoing CR with CR/LF
	LIS	RBC,LF
	JAL	RCH,PUTCHR,,
XP.GO4	LB	R0,X3STAT,RPI	:xp.go4 should be here *500.sdw
	CLHI	R0,X3DAT
	JER	RLINK
	SERSIG(SS.FEF)			:xp.go4 was here *500.sdw
	LIS	R0,X3DAT
	STB	R0,X3STAT,RPI		:  else back in data transfer state   
	L	R0,.XPADS,RPI
	ST	R0,.XPADF,RPI		:  restore normal PAD transmit filter
	JR	RLINK


:	Received an Orange Ball to our Yellow Ball
:	 Currently this is done when:
:		1)  we send a gobbler/yellow ball to reset the circuit
:		2)  we send a break/yellow ball and OB acks the break
:		     (ie. host doesn't send a gobbler back to our break)
XP.OB
	RBT	RP,X3.P8		:no longer discard output
	TBT	RP,RESOUT
	JN	XP.GO2			:if OB is reset conf...send ACK
	JR	RLINK


	FO	SIGNAL
	FO	CONSAT

	SUBTTL	(PAD) Packet Logic Subroutines


:	OK to talk XCOM dialect to the destination host.
:	Send IIX dialect response followed by:
:	Turkey level number
:	Called party address
:	Calling party address
:	Facility
:	Network utility if any
:	Call user data
:	XCOM dialect messages

TURKOK	HS
:	Send dialect response to accept XCOM.
	LHI	R6,ID.XCM
	JAL	R9,SENDDR		:send dialect response
:	Send our turkey level number.
	LHI	R6,EXM13
	JAL	R9,BEGDIA
	LIS	RBC,0
	JAL	RCH,PUTCHR,,
	LIS	RBC,OURLEV
	STB	RBC,TURLEV,RPI
	JAL	RCH,PUTCHR,,
:	Send called/calling addresses
	LHI	R6,EXM7
	JAL	R9,BEGDIA
	LR	R6,RPI
	LIS	R9,8
TURK10	LB	RBC,DTECLD,R6	:get 1 byte of called address
	JAL	RCH,PUTCHR,,
	AIS	R6,1
	SIS	R9,1
	JNBS	TURK10
	LHI	R6,EXM8
	JAL	R9,BEGDIA
	LR	R6,RPI
	LIS	R9,8
TURK20	LB	RBC,DTECLG,R6	:get 1 byte of calling address
	JAL	RCH,PUTCHR,,
	AIS	R6,1
	SIS	R9,1
	JNBS	TURK20
:	Send RPOA facility, if any.
	TBT	RP,RPOA.F
	JE	TURK30			:if no RPOA requested
	LHI	R6,EXM18
	JAL	R9,BEGDIA
	LB	RBC,RPOA.R,RPI
	JAL	RCH,PUTCHR,,
	LB	RBC,RPOA.R+1,RPI
	JAL	RCH,PUTCHR,,
:	Send faclity field.
TURK30	LHI	R6,EXMD			:X.25 USER FACILITY FIELD
	JAL	R9,BEGDIA
	LIS	RBC,1+2			:always include throughput class
:	INCLUDE REVERSE CHARGING (=0/1) IF SPECIFIED BY USER
	TBT	RP,RVCG.F		:WAS IT SPECIFIED?
	JE	TURK32			:NO, CHECK NEXT FACILITY
	AIS	RBC,2			:TWO MORE BYTES FOR REVERSE CHARGING
TURK32

:	AFTER ALL POSSIBLE FACILITIES ARE CHECKED, THE LENGTH OF THIS IIX
:	 IS IN RBC
TURK60	
	JAL	RCH,PUTCHR,,
	SIS	RBC,1			:DECREMENT ONE FOR FACILITY BYTE COUNT
	JAL	RCH,PUTCHR,,

	LIS	RBC,FC.TC		:throghput class facility code
	JAL	RCH,PUTCHR,,
	LB	RBC,TCLASS,RPI
	LR	R5,RBC
	SLLS	R5,4			:create transmit and receive values
	OR	RBC,R5
	JAL	RCH,PUTCHR,,

:	SEND REVERSE CHARGE (0/1) IF SPECIFIED
	TBT	RP,RVCG.F		:WAS IT SPECIFIED?
	JE	TURK62			:NO, CHECK NEXT ONE
	LIS	RBC,FC.RC		:REVERSE CHARGING FACILITY CODE
	JAL	RCH,PUTCHR,,		:
	LB	RBC,RVCG.R,RPI		:REVERSE CHARGING FACILITY VALUE
	JAL	RCH,PUTCHR,,
TURK62
:	Send network utility, if any
	TBT	RP,ICOD.F		:interlock code present?
	JE	TURK80			:no, skip
	LHI	R6,EXMC			:network utility field
	JAL	R9,BEGDIA		
	LIS	RBC,1+6			:CUG utility + 1 length
	JAL	RCH,PUTCHR,,		:put in 1st length
	SIS	RBC,1			:decrement 1 for utility byte count
	JAL	RCH,PUTCHR,,		:2nd length
	LHI	RBC,UT.CUG		:CUG utility code C3
	TBT	RP,CUGO.F,,		:CUG with outgoing access?
	JEFS	TURK65			:no
	LHI	RBC,UT.CUO		:get C7
TURK65	JAL	RCH,PUTCHR,,		:put in utility code
	LIS	RBC,4			:length of CUG utility
	JAL	RCH,PUTCHR,,
	LB	R9,CUGIND,RPI		:get index #
	SLLS	R9,2			:make into full word index
	LIS	R6,4			:counter for loop
TURK68	LB	RBC,CUGTAB,R9,		:get interlock code	
	JAL	RCH,PUTCHR,,		:put in one byte at a time
	AIS	R9,1			:bump index
	SIS	R6,1			:decrement counter
	JN	TURK68			:loop until done

:	Send call user data field.
TURK80	LHI	R6,EXM9
	JAL	R9,BEGDIA
	L	R5,.FEDBF,RPI

:	Calculate number of characters in edit buffer - without counting nulls
:	twice							*6.02 dlg
	LIS	R9,0			:initialize counter
	L	RBP,.FEDBF,RPI		:get buffer pointer
	JAL	RBF,IGCSCN,,		:initialize for scan through buffer
	 J	TURK82			:finished
TURK81	JAL	RBF,GCSCN,,		:scan buffer
	 J	TURK82			:finished
	AIS	R9,1			:increment counter
	LR	RBC,RBC			:is it a null (00 00)?
	JNBS	TURK81			:no, return for next character
	JAL	RBF,GCSCN,,		:yes, don't count second pair of 00
	 J	TURK82			:finished
	J	TURK81			:return for next character
TURK82	L       RBP,.FTBUF,RPI          :restore RBP
        LR	RBC,R9			:get length in editing buffer
	AIS	RBC,4			:add length for protocl id
  IF CUD.MX				:JH NOV-12-85
	LB	RCH,CUD.LG,RP,		:get CUD length field
	NHI	RCH,0F			:mask out
	AR	RBC,RCH			:add with protocol id.
  EI
	JAL	RCH,PUTCHR,,		:put in length of c.u.d.
	LIS	RBC,PI.PAD
	JAL	RCH,PUTCHR,,
	LIS	RBC,0
	JAL	RCH,PUTCHR,,
	JAL	RCH,PUTCHR,,
	JAL	RCH,PUTCHR,,
  IF CUD.MX
	LB	R9,CUD.LG,RP,
	NHI	R9,0F
	JE	TURK84
	LIS	R6,0		:index into CUD.LT
TURK83	LB	RBC,CUD.LT,RPI,R6	:get CUD content
	JAL	RCH,PUTCHR,,		:put into Ring
	SIS	R9,1			:decrement length field
	JLEFS	TURK84			:done, skip
	AIS	R6,1			:increment index
	JBS	TURK83			:continue output
  EI
TURK84	EQ	.
	LR	R6,RBP			:destination
	L	R5,.FEDBF,RPI		:get edit buffer pointer - source
	TBT	RP,FREDIT		:is there something in the edit buffer
	JER	RLINK			:if nothing in it
	JAL	RCH,MCI,,		:copy from editing buffer
	JR	RLINK

:	Begin a dialect message.
:	RPI -	port table pointer
:	RP -	port number
:	R9 -	link register
:	R6-	XCOM dialect message type

BEGDIA	L	RBP,.FTBUF,RPI
	 LO	SIGNAL
	LHI	R4,SIXSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:precede dialect msg with a SIIX
	LHI	RBC,IX.DMM^-8
	JAL	RCH,PUTCHR,,		:dialect message prefix
	LR	RBC,R6			:dialect msg code
	JAL	RCH,PUTCHR,,
	JR	R9			:return


::	OUTPKT - output data in packet format.
:		count up packet and segment
:
:	INPUT	(R0)= flag byte to use
:		(R6)= xx+ length of data,
:			xx=8000 if to supress accounting, else xx=0
:	Destroy	R0-R7,R9, TEMP,TEMP1

OUTPKT	ST	R9,TEMP1		:save return address
	STH	R0,TEMP+6		:store flag byte
	LR	R0,R6
	NHI	R6,7FFF			:ignore high bit
	STH	R6,TEMP+4		:store length
	SRHLS	R0,0F
	JNFS	OUTP05			:if to skip packet accounting
	LR	R0,R6
	JAL	R4,COSP			:count packet and segment
OUTP05	LB	R0,TURLEV,RPI		:get turkey level in effect
	JE	OUTP20			:if level = 0
	LHI	R6,EXM14		:data message
	JAL	R9,BEGDIA		:get message started
	LHL	RBC,TEMP+6		:get flag byte to use
	JAL	RCH,PUTCHR,,
	LB	RBC,TEMP+4		:get length to use
	JAL	RCH,PUTCHR,,
OUTP10	LB	RBC,TEMP+5		:length, 2nd byte
	JAL	RCH,PUTCHR,,
	L	R9,TEMP1	
	JR	R9

:	Use EXM0 - EXM3 for data message depending on flag byte.
:	(this code assumes MBIT=1, QBIT=80, )
OUTP20	LHL	R9,TEMP+6		:get flag byte
	LR	R6,R9
	NHI	R9,1			:isolate M-bit
	SRHLS	R6,6			:move Q-bit 
	AHI	R6,80,R9		:create EXM0 - EXM3
OUTP50	JAL	R9,BEGDIA
	J	OUTP10			:go put in byte length

::	SENCLR	- Send a clear packet, detach, and update packet & segment
:		counts
:
:	Link on R9
:	Destroys R0-4,R6-8,XPTEMP

SENCLR	ST	R9,XPTEMP,,		:save link register
	TURMSG(CLEAR)			:output clear cause/diag msg
	 LO	SIGNAL
	LHI	R4,DETSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:detach
	JAL	R6,PCTRPT
	JAL	R6,SCTRPT
	LIS	R0,X3PAW		:interface status = PAD wait state
	STB	R0,X3STAT,RPI		:store in port table
	ST	RLINK,XPTMP2		:save register
	JAL	RLINK,XP.ZAK		:send message to term & reinit parm's
	L	RLINK,XPTMP2		:restore register
	L	R9,XPTEMP		:restore link register
	JR	R9			:return
	


::	OUTCDL	- fill in cause and dignostic field of message
:
:	ENTRY	(R9)	LINK
:		(R4)= 0 if clear, =1 if reset
:		(PSDIAG)	cause and diagnostic field
:	destroy	R0-R5, TEMP

OUTCDL	LA	R2,CLRMSG,,		:clear message look up table
	LHI	R5,CLRMAX
	LR	R4,R4
	JEFS	OUTC10			:if it is clear
	LA	R2,RESMSG,,		:reset message look up table
	LHI	R5,RESMAX
OUTC10	LB	R3,PSDIAG,RPI		:get cause value
	LA	R6,SS.UNK-BASE		:'cause unknown' message
	CR	R3,R5
	JGFS	OUTC20			:if unknown cause
	AR	R3,R3
	LHL	R6,,R2,R3		:look up mesage to send
OUTC20	AI	R6,BASE
	SERSIG				:output cause message
	LB	R3,PSDIAG+1,RPI		:get diagnostic value
	LIS	R0,$A10
	LIS	R4,3			:3 digit number
	LA	R1,SS.DIA+1,,
	JAL	R5,CBA,, 		:convert to ASCII and store
	SERSIG(SS.DIA)			:output diagnostic
	JR	R9



:	Send IIX dialect response.
:	(R6)= dialect type
:	(R9)= link register

SENDDR	L	RBP,.FTBUF,RPI
	 LO	SIGNAL
	LHI	R4,SIXSIG
	 FO	SIGNAL
	JAL	RCH,PUTSIG,,		:SIIX header
	LHI	RBC,(IX.SDR^-8)
	JAL	RCH,PUTCHR,,
	LHI	RBC,IX.SDR&0FF
	JAL	RCH,PUTCHR,,
	LHI	RBC,80
	JAL	RCH,PUTCHR,,
	LBR	RBC,R6
	JAL	RCH,PUTCHR,,
	JR	R9

	SUBTTL	(PAD) Packet/Segment/Circuit-Termination Accounting routines

:	Report input and output packet count accounting message.
:	RP, RP2 set
:	R6 - link register

PCTRPT	TBT	RP,IIXCAL	:IIX circuit up?
	JER	R6		:no, accounting report prohibited at this time

:	REPORT OUTPUT PACKET COUNT.
	LI	R7,AA.OOP		:origination output packet count msg
	RBT	RP,POCHNG
	JE	PCTR30			:if output count has not changed
	L	R0,POCNT,RPI	:get output packet count
	OR	R7,R0
	JAL	R5,GENRPT,,		:go report it
PCTR30	RBT	RP,PICHNG
	JER	R6			:if input count did not change
	LI	R7,AA.OIP		:origination input packet count msg
	L	R0,PICNT,RPI	:get input packet count
	OR	R7,R0
	JAL	R5,GENRPT,,
	JR	R6

:	Report input and output segment count accounting message.
:	RP, RP2 set
:	Uses R0-R7
:	Link on R6

SCTRPT	HS
  IF	SEGACT				:if segment accounting
	TBT	RP,IIXCAL		:IIX circuit up?
	JER	R6		:no, accounting report prohibited at this time
	LI	R7,AA.OOS		:originating output segment count

:	Report output segment count.
SCTR10	RBT	RP,SOCHNG
	JE	SCTR30			:if output count has not changed
	L	R0,SOCNT,RPI
	OR	R7,R0
	JAL	R5,GENRPT,,		:go report it

:	REPORT INPUT SEGMENT COUNT.
SCTR30	RBT	RP,SICHNG
	JER	R6			:if input count has not changed
	L	R0,SICNT,RPI	:	get input segment count
	LI	R7,AA.OIS		:originating input segment count
	OR	R7,R0
	JAL	R5,GENRPT,,		:go report it
  EI	SEGACT
	JR	R6

:	report sub-host down, translated means terminal powered 
:	off or the line between terminal and PAD is down.       
:	RP, RP2 set, RP=terminal port #, RP2=2*RP               
:	R6, Link register                                       

CTARPT	HS                                                      
	TBT	RP,IIXCAL	:IIX circuit up?
	JER	R6		:no, acct report prohibited at this time

:	Report Sub-host down, to be followed by a circuit disconnect
	LI	R7,AA.CTM	:Circuit terminated message     
	LI	R0,5		:Reason, Sub-host down          
	OR	R7,R0                                           
	JAL	R5,GENRPT,,	:go and report it               
	JR	R6		:return                         

:	Count input segment and packet.
:
:	R0 - no. chars of data
:	USES	R0-R4
:	(r4) = link register

CISP	SBT	RP,SICHNG	:set input segment count changed
	LHI	R1,SEGACT	:
	AHI	R0,SEGACT-1	:for rounding
	DHR	R0,R1		:do division
	AM	R1,SICNT,RPI	:update input segment count

:	Count input packet.
:
:	LINK IS R4
:	ENTRY FROM CISP ALSO

CIP	SBT	RP,PICHNG	:set input packet count changed
	LIS	R3,1		:
	AM	R3,PICNT,RPI	:update input packet count
	JR	R4		:


:	Count output segment and packet.
:	
:	R0 - no. of chars of data in packet
:	USES	R0-R4
:	LINK IS R4

COSP	SBT	RP,SOCHNG	:set output segment count changed
	LHI	R1,SEGACT	:
	AHI	R0,SEGACT-1	:for rounding
	DHR	R0,R1		:
	AM	R1,SOCNT,RPI	:

::	COP-	COUNT OUTPUT PACKET.
:	ENTRY FROM COSP ALSO
:	LINK IS R4

COP	SBT	RP,POCHNG	:set output count changed flag
COP010	LIS	R3,1		:
	AM	R3,POCNT,RPI	:
	JR	R4		:


	FO	DATA
	EM	:X3PAD
  EI	(X3ON)
    @EL