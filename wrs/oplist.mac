TITLE OPLIST - utility for cleaning up OPER PASSWORD file

T1=1
T2=2
T3=3
T4=4
T5=5
C=6
C1=7

BLK=12	;BLOCK NUMBER (1000 WORD BLOCKS) TO ACCESS
BUFP=13	;POINTER TO BUFFER WITH BLOCK IN IT
NM1=14	;FIRST WORD OF NAME
NM2=15	;SECOND WORD OF NAME
PNTR=16	;POINTER INTO BUFFER FOR SEARCHES ETC
P=17

PSW==1	;CHANNEL FOR PASSWORD FILE
TTY==2	;FOR TTY
DIC==3	;CHANNEL FOR DICTIONARY
RPT==4	;CHANNEL FOR REPORT

JBTLIC==-20	;FOR GETTABS
JBTAUN==-23	;AUN
JBTPRV==6	;PRV WORD

JBSMOD==2	;SIZE OF MODE FIELD
JBNMOD==^D28	;LOCATION OF MODE FIELD
LICWC==(1B0)
BITDMP==1B4	;FILE DUMPED BIT
LICLOK==14	;LICENSE HERE ON LOOKUP
%TIME==^D60000	;TIMEOUT TIME (1 MIN)

;LOCATIONS OF WORDS IN BUFFER AREA

BFNM1==0	;FIRST WORD OF NAME
BFNM2==1	;SECOND WORD OF NAME
BFPSW==2	;CIPHERED PASSWORD
BFLIC==3	;LICENSE WORD
BFDST==4	;DISTRICT NUMBER
BFMAN1==5	;FIRST WORD OF MANAGER NAME
BFMAN2==6	;SECOND WORD OF MANAGER NAME

JOBVER==137
INTERNAL JOBVER
	LOC JOBVER
	13
	RELOC

ARRAY PDL[40],MANSAV,SAVNAM,LICBLK,MANNAM[2]
INTEGER LINPOS

array	DICBUF[3],RPTBUF[3]

STPT:	RESET
	MOVE P,[IOWD 40,PDL]
	INIT PSW,16
	 SIXBIT /SYS/
	 0
	  JRST NODSK
	INIT TTY,0
	 SIXBIT /TTY/
	 0
	  JRST GETOUT		;JUST SO WE CAN TURN ECHO ON AND OFF
	INIT DIC,0
	 SIXBIT /DSK/
	 XWD 0,DICBUF
	  JRST GETOUT
	INIT RPT,0
	 SIXBIT /DSK/
	 XWD RPTBUF,0
	  JRST GETOUT

	PUSHJ P,OPNFIL		;OPEN THE PASSWORD FILE
	 JRST ERROUT		;NOT THERE, MUST CREATE IT
	PUSHJ P,BUFINI		;SET UP BUFFERS
	PUSHJ P,MANINI		;INIT MANAGER LIST
	JRST CMDLP

OPNFIL:	LOOKUP PSW,PASNAM
	 POPJ P,		;NOT THERE
	MOVE T1,PASNAM+LICLOK	;HERE IS WHERE LIC ON FILE IS
	TRNN T1,LICWC
	 POPJ P,		;SAY FILE NOT THERE
CPOPJ1:	AOS (P)
CPOPJ:	POPJ P,

PASNAM:	14
	0
	SIXBIT /DRWSPR/
	SIXBIT /EPO/
	REPEAT 11,<0>

CMDLP:	OUTSTR [BYTE (7)15,12,"*"]
	SETZM SAVCHR
	PUSHJ P,SCAN
	 JRST CMDLP
	MOVE T3,ACCUM
	MOVSI T2,-NAMLEN	;SCAN NAMES
	CAME T3,NAMES(T2)
	AOBJN T2,.-1
	JUMPGE T2,HELP
	PUSHJ P,@GOTO(T2)
	 JRST CMDLP		;SO CAN HAVE MORE THAN 1 IF GOD ON ERRORS
	JRST CMDLP

	DEFINE NAMSTR
<
	X LIST,LISTOP
	X TRY,TRYPAS
	X HASH,UHASH
	X GUESS,GUESS
	X MANAGED,LSTSUP
	X REPORT,RPTFIL
	X DETACH,DETACH
	X QUIT,QUIT
	X Q,QUIT
>

	DEFINE X (A,B)
<	<SIXBIT /A/>>

NAMES:	NAMSTR
NAMLEN==.-NAMES

	DEFINE X (A,B)
<	B>

GOTO:	NAMSTR

QUIT:	PUSHJ P,FINCR
	CLOSE RPT,
	EXIT

HELP:	PUSHJ P,FINCR
	OUTSTR HELPMS
	JRST CMDLP

HELPMS:	ASCIZ \Commands are:
LIST		list all names
LIST <name>	list this name
MANAGED	<name>	list names having this manager
HASH <password> print the hash code for this password
TRY <password>	list names with this password
GUESS <file>	guess passwords from file
DETACH <file>	same as GUESS, but detach
REPORT <file>	define a report file
QUIT 		terminate session
\

LSTSUP:	PUSHJ P,NAMPMT
	 JRST BADNAM
	PUSHJ P,FNDNAM
	 JRST NONAM
	DMOVE NM1,BFNM1(PNTR)
	DMOVEM NM1,SAVNAM
	MOVSI T1,L.MG
	TDNN T1,BFLIC(PNTR)
	POPJ P,		;NOT A MANAGER
	PUSHJ P,FRSUSR	;INITIALIZE FOR SEARCH
LSUP1:	PUSHJ P,NXTMAN	;GET THE NEXT USER MANAGED
	 POPJ P,	;NONE
	PUSHJ P,LSTUSR	;LIST IT
	JRST LSUP1

NONAM:	OUTSTR [ASCIZ /NAME NOT FOUND/]
	POPJ P,

;FIND NEXT PERSON MANAGED BY NAMEE IN SAVNAM

NXTMAN:	PUSHJ P,NXTUSR
	 POPJ P,	;NO MORE USERS
	DMOVE NM1,BFMAN1(PNTR)
	CAMN NM1,SAVNAM
	CAME NM2,SAVNAM+1
	JRST NXTMAN	;NOT THIS ONE
	JRST CPOPJ1	;FOUND ONE

BPDATE:	POINT 15,BFDST(PNTR),27
BPDST:	POINT 8,BFDST(PNTR),35

NOTMG:	OUTSTR [ASCIZ /Not a manager/]
	PUSHJ P,BUFULK	;UNLOCK
	POPJ P,		;AND RETURN

NONM1:	PUSHJ P,BUFULK
	JRST NONAM	;NAME NOT THERE

INCHR:	SOSGE DICBUF+2
	 JRST  [IN DIC,
		 JRST INCHR
		CLOSE DIC,
	 	POPJ P,]
	ILDB T1,DICBUF+1
	JUMPE T1,INCHR		; ignore nulls
	AOS (P)
	POPJ P,

integer	REPORT
CHROUT:	HRROI C1,51
	AUXCAL C1,(C)
	SKIPN REPORT
	 POPJ P,
CHROU1:	SOSGE RPTBUF+2
	 JRST  [OUT RPT,
		 JRST CHROU1
		OUTSTR [ASCIZ "
REPORT FILE ERROR"]
		HALT .]
	IDPB C,RPTBUF+1
	POPJ P,

RPTFIL:	PUSHJ P,RDFILE
	CLOSE RPT,
	ENTER RPT,FILBLK
	 JRST [OUTSTR [ASCIZ "?cant enter report file"]
		SETZM REPORT
		POPJ P,]
	SETOM REPORT
	SETZM RPTBUF+2
	POPJ P,
	
CRLF:	MOVEI C,[BYTE (7)15,12]

STROUT:	HLL C,[POINT 7,0]
	PUSH P,C
STROU1:	ILDB C,(P)
	JUMPE C,[POP P,C1
		POPJ P,]
	PUSHJ P,CHROUT
	JRST STROU1
	
DETACH:	PUSHJ P,RDFILE
	SKIPN REPORT
	  JRST [OUTSTR [ASCIZ "Use REPORT command first!"]
		POPJ P,]
	CLOSE DIC,
	LOOKUP DIC,FILBLK
	 JRST [OUTSTR [ASCIZ "?cant open dictionary"]
		POPJ P,]
	SETZM DICBUF+2
	SETZ T1,
	ATTACH T1,
	 JFCL
	PUSHJ P,GUESS1
	CLOSE RPT,
	MOVSI T1,1
	LOGOFF T1,
	 HALT .

GUESS:	PUSHJ P,RDFILE
	CLOSE DIC,
	LOOKUP DIC,FILBLK
	 JRST [OUTSTR [ASCIZ "?cant open dictionary"]
		POPJ P,]
	SETZM DICBUF+2
GUESS1:	PUSHJ P,INPAS
	 POPJ P,
	PUSHJ P,FRSUSR
GUESS2:	PUSHJ P,NXTUSR
	 JRST GUESS1
	MOVE T1,X
	CAMN T1,BFPSW(PNTR)
	 PUSHJ P,LSTPUS
	JRST GUESS2

PASWRD==20
PASSIZ==PASWRD*5
array 	PASBUF[PASWRD]
INPAS:	MOVE T2,[point 7,PASBUF]
	MOVEI T3,PASSIZ
INPAS1:	PUSHJ P,INCHR
	 POPJ P,
	IDPB T1,T2
	CAIE T1,12
	 SOJG T3,INPAS1
	AOS (P)
	JRST RDPAS2

LSTPUS:	SETZM LINPOS
	PUSHJ P,PASPR
	MOVEI T1,^D20
	PUSHJ P,POS
	JRST LSTUSR

PASPR:	MOVE T2,[point 7,PASBUF]
PASPR1:	ILDB T1,T2
	CAIGE T1,40
	 POPJ P,
	MOVEI C,(T1)
	PUSHJ P,CHROUT
	AOS LINPOS
	JRST PASPR1

array 	USRNAM[2],FILBLK[4]
RDFILE:	SETZM USRNAM
	SETZM USRNAM+1
	SETZM FILBLK
 	SETZM FILBLK+1
 	SETZM FILBLK+3
S1:	MOVE T1,[POINT 6,FILBLK]
	MOVEI T2,6
	SETZM FILBLK
S2:	INCHWL T3
	CAIN T3,15	; IF <CR> EAT LF
	  INCHWL T3
	CAIL T3,140
	  SUBI T3,40
	CAIN T3,"("
	  JRST [MOVE T1,[POINT 6,USRNAM]
		MOVEI T2,USRNAM
		MOVEM T2,FILBLK+3
		MOVEI T2,14
		SETZM USRNAM
		SETZM USRNAM+1
		JRST S2]
	CAIN T3,")"
	  JRST S1
	CAIN T3,"."
	  JRST [MOVE T1,[POINT 6,FILBLK+1]
		MOVEI T2,3
		SETZM FILBLK+1
		JRST S2]
	SUBI T3,40
	JUMPL T3,CPOPJ
	JUMPE T3,S2
	SOJL T2,S2
	IDPB T3,T1
	JRST S2

UHASH:	PUSHJ	P,RDPAS
	SETZM LINPOS
	PUSHJ P,PASPR		; print the password
	MOVEI T1,^D20
	PUSHJ P,POS
	MOVE	T1,X
	PUSHJ	P,OUTOCT	; print the hased password value
	PUSHJ	P,CRLF
	POPJ	P,

TRYPAS:	PUSHJ 	P,RDPAS
	PUSHJ 	P,FRSUSR	;SET UP TO INITIALIZE USER SEARCH
TRY1:	PUSHJ 	P,NXTUSR	;GET THE NEXT ONE
	 POPJ 	P,		;FINISHED
	MOVE 	T1,X
	CAMN 	T1,BFPSW(PNTR) ; PASSWORD MATCH?
	 PUSHJ 	P,LSTUSR
	JRST 	TRY1		;CONTINUE

LSTALL:	PUSHJ P,FRSUSR	;SET UP TO INITIALIZE USER SEARCH
LSALP:	PUSHJ P,NXTUSR	;GET THE NEXT ONE
	 POPJ P,	;FINISHED
	PUSHJ P,LSTUSR
	JRST LSALP	;CONTINUE

LISTOP:	PUSHJ P,RDNAM
	 JRST LSTALL	;WANTS TO LIST ALL
	PUSHJ P,FNDNAM	;FIND THE NAME
	 JRST NONAM	;NOT THERE
LSTUSR:	SETZM LINPOS
	DMOVE NM1,BFNM1(PNTR)
	PUSHJ P,NAMPR
	MOVEI T1,^D14
	PUSHJ P,POS
	DMOVE NM1,BFMAN1(PNTR)
	PUSHJ P,MANPR
	MOVEI T1,^D28
	PUSHJ P,POS
	LDB T1,BPDST
	PUSHJ P,OUTDEC
	MOVEI T1,^D34
	PUSHJ P,POS
	LDB T1,BPDATE
	PUSHJ P,OUTDAT
	PUSHJ P,CRLF
	MOVE T1,BFLIC(PNTR)
	MOVEM T1,DESLIC
	PUSHJ P,LICPR	;NOW THE LICENSE
LSTUS3:	PUSHJ P,CRLF
	POPJ P,

MANPR:	JUMPN NM1,NAMPR
	MOVEI C,"["
	PUSHJ P,CHROUT
	AOS LINPOS
	HLRZ T1,NM2
	PUSHJ P,OUTOCT
	MOVEI C,","
	PUSHJ P,CHROUT
	AOS LINPOS
	HRRZ T1,NM2
	PUSHJ P,OUTOCT
	MOVEI C,"]"
	PUSHJ P,CHROUT
	AOS LINPOS
	POPJ P,

OUTOCT:	MOVE T2,T1
	ANDI T2,7
	HRLM T2,(P)
	LSH T1,-3
	SKIPE T1
	PUSHJ P,OUTOCT
	HLRZ T1,(P)
	MOVEI C,"0"(T1)
	PUSHJ P,CHROUT
	AOS LINPOS
	POPJ P,

NAMPR:	MOVE T1,NM1	;DO A DOUBLE PRECISION DIVIDE
	IDIVI T1,^D45
	MOVE NM1,T2
	DIVI NM1,^D45
	EXCH NM1,NM2
	EXCH T1,NM1	;T1 NOW HAS REMAINDER
	JUMPE T1,NAMPR	;IGNORE SPACES AT END
	HRLM T1,(P)	;SAVE REMAINDER
	SKIPN NM1
	SKIPE NM2	;FINISHED?
	PUSHJ P,NAMPR	;NO
	HLRZ T1,(P)
	MOVE C,ASCOTB(T1)
	PUSHJ P,CHROUT
	AOS LINPOS
	POPJ P,

	DEFINE X1(A,B)
<	RELOC ASCOTB+B
	A
	RELOC>

	DEFINE X2(A,B,C)
<	XX==A
	RELOC ASCOTB+C
	REPEAT B-A+1,<XX
	XX==XX+1>
	RELOC>

;THE OUTPUT TABLE

;NOW CHARACTER CONVERSION

	DEFINE CHRCNV
<	X1 (40,0)
	X1 (100,52)
	X1 (52,52)
	X1 (47,53)
	X1 (44,54)
	X2 (54,72,33)
	X2 (101,132,1)
>

ASCOTB:	REPEAT ^D45,<"$">
	CHRCNV

OUTDEC:	IDIVI T1,^D10
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTDEC
	HLRZ T1,(P)
	MOVEI C,"0"(T1)
	PUSHJ P,CHROUT
	AOS LINPOS
	POPJ P,

LICPR:	MOVSI T3,-LICLEN	;GET SET TO PRINT OUT LICENSE
LICPLP:	MOVEI T1,3
	ADDM T1,LINPOS
	LDB T1,LICBP(T3)
	CAME T1,LICVL1(T3)
	 JRST  NOLICP
	MOVE T2,LICSIX(T3)
	PUSHJ P,OUTSIX
	MOVEI C," "
	PUSHJ P,CHROUT
NOLICP:	AOBJN T3,LICPLP
	POPJ P,

FRSUSR:	SETZB BLK,PNTR	;SET UP FOR USER SEARCH
	POPJ P,

NXTUBK:	ADDI BLK,1	;NEXT BLOCK
	PUSHJ P,FNDBLK
	 POPJ P,	;NO BLOCK, MUST BE FINISHED
	HRR PNTR,BUFP
	HRLI PNTR,-^D73
	JRST NXTUS1
NXTUSR:	ADDI PNTR,6
	AOBJP PNTR,NXTUBK	;OUT OF SPACE IN THIS BLOCK?
NXTUS1:	SKIPN BFNM1(PNTR)	;SOMEONE THERE?
	JRST NXTUSR	;NO
	JRST CPOPJ1	;YES

RDNUM:	INCHWL T1
	CAIGE T1,40
	JRST FINCR	;FINISH UP AND NON-SKIP RETURN
	CAIG T1,"9"
	CAIGE T1,"0"
	JRST RDNUM
	MOVEI T2,0	;SET TO ACCUMULATE NUMBER
	AOS (P)		;AND FOR SKIP RETURN
RDNLP:	ADDI T2,-"0"(T1)
	INCHWL T1
	CAIG T1,"9"
	CAIGE T1,"0"
	JRST FINCR	;FINISHED
	IMULI T2,^D10
	JRST RDNLP

COMMENT ; THIS CODE BUILDS A LIST OF ALL MANAGERS IN CORE. THERE
IS A FLAG FOR EACH TO TELL IF WE MANAGE HIM. INITIALIZED WITH
OUR NAME IN LIST. 3 WORDS PER ENTRY. 2 OF NAME AND -1 IF WE
ARE HIS MANAGER ;

MANINI:	HRRZ T1,JOBFF
	MOVEM T1,LSTPTR#
	DMOVE NM1,MANNAM
	PUSHJ P,LSTINS
	SETOM 2(T5)	;FLAG HIM AS ON LIST
	POPJ P,

LSTINS:	MOVEI T5,3	;ADD NAME TO LIST
	ADDB T5,JOBFF
	CAMG T5,JOBREL
	 JRST COROK	;ENOUGH CORE TO ADD ONE
	IORI T5,1777
	CORE T5,	;GET MORE CORE
	 JRST NOCOR	;LOSE
	MOVE T5,JOBFF
COROK:	DMOVEM NM1,-3(T5)
	SETZM -1(T5)
	MOVSI T5,-1
	ADDB T5,LSTPTR
	POPJ P,

NOCOR:	OUTSTR [ASCIZ /
Not enough core!/]
	JRST GETOUT

EXTERNL JOBFF,JOBREL

MANERR:	OUTSTR [ASCIZ /
Program error, file not consistant!/]
	JRST GETOUT

;HERE TO SEARCH LIST FOR NAME IN NM1,NM2

LSTSRC:	SKIPL T5,LSTPTR
	 POPJ P,	;NO LIST TO SEARCH
LSTSR1:	CAMN NM1,(T5)
	 CAME NM2,1(T5)
	  SKIPA
	   JRST CPOPJ1	;FOUND HIM
	ADDI T5,2
	AOBJN T5,LSTSR1
	POPJ P,		;NOT THERE

ISMAN:	PUSHJ P,BUFLOK		;LOCK CURRENT BUFFER
	SETZM LSTADD#
	MOVSI T1,L.MG
	TDNN T1,BFLIC(PNTR)
	 JRST ISMAN4		;NOT A MANAGER
	DMOVE NM1,BFNM1(PNTR)	;GET NAME FOR SEARCH
ISMAN2:	PUSHJ P,LSTSRC
	 JRST	[PUSHJ P,LSTINS
		AOS LSTADD
		JRST ISMAN1]
	MOVE T3,2(T5)		;GET IN OR OUT OF CHAIN FLAG
ISMAN3:	PUSHJ P,BUFULK		;UNLOCK BUFFER
	SKIPN T4,LSTADD
	 JRST NOLUP		;NO LIST UPDATE
	MOVE T5,JOBFF
	MOVEM T3,-1(T5)
	SUBI T5,3
	SOJG T4,.-2
NOLUP:	JUMPN T3,CPOPJ1
	POPJ P,			;NOT IN LIST
ISMAN1:	PUSHJ P,FNDNAM		;NOW FIND IT
	 JRST MANERR
ISMAN4:	DMOVE NM1,BFMAN1(PNTR)
	JUMPE NM1,[MOVEI T3,0
		JRST ISMAN3]	;FINISH UP
	JRST ISMAN2

OUTDAT:	IDIVI T1,^D31	;NOW DAY-1 IN T2, MON AND YR IN T1
	PUSH P,T1
	MOVEI T1,1(T2)
	PUSHJ P,OUTDEC	;PRINT DAY
	POP P,T1
	MOVEI T2,5
	ADDM T2,LINPOS
	IDIVI T1,^D12	;YEAR-64 IN T1, MONTH-1 IN T2
	MOVEI C,@DATTAB(T2)
	PUSHJ P,STROUT
	ADDI T1,^D64
	JRST OUTDEC

DEFINE 	DAT (A) <IRP A,<[ASCIZ /-A-/]>>
DATTAB:	DAT <JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC>

NODSK:	OUTSTR [ASCIZ /Can not init DSK:/]
GETOUT:	CLOSE PSW,0
	CLRBFI
	CLOSE RPT,
	EXIT 1,
	JRST .-1

BADNAM:	OUTSTR [ASCIZ /No name entered/]
	POPJ P,		;RETURN TO CALLER

NOPSFL:	OUTSTR [ASCIZ /No password file/]
	JRST GETOUT

ERROUT:	OUTSTR [ASCIZ /
?/]
	JRST GETOUT

;BUFFER CODE FOR INPUT AND OUTPUT

BUFNUM==3

BUFIOW==-2	;IOWD FOR INPUT AND OUTPUT TO BUFFER
BUFLNK==-3	;LINK TO NEXT BUFFER. SIGN BIT BUFFER LOCKED
BUFBLK==-4	;BLOCK NUMBER

	DEFINE CAT (A,B)
	<A'B>

	DEFINE BUFER (N)<
	0	;BLOCK
	CAT (BUFR,\<N+1>)	;LINK
	IOWD 1000,.+2
	0			;END OF COMMAND LIST
BUFR'N:	BLOCK 1000
>
	ZZ==0
	REPEAT BUFNUM,<BUFER (\ZZ)
	ZZ==ZZ+1>
	CAT (BUFR,\BUFNUM)==BUFR0

BUFINI:	MOVEI BUFP,BUFR0	;SET UP FREE POINTER
	MOVEM BUFP,FREBUF#
SETZBK:	SETZM BUFBLK(BUFP)	;CLEAR BLOCK NUMBERS
	HRRZS BUFP,BUFLNK(BUFP)
	CAME BUFP,FREBUF
	JRST SETZBK	;GO THROUGH ALL BUFFERS
	POPJ P,		;BACK WHERE WE STARTED

COMMENT ; THERE ARE SEVERAL BUFFERS IN CORE. THEY ACT LIKE A CASH
MEMORY EXCEPT THAT WRITES GO THROUGH IMMEDIATELY. BLK TELLS
THE (512 WORD) BLOCK TO PROCESS. REUTRN FROM SEARCH ROUTINES WITH
BUFP SET TO POINT TO BUFFER ;

FNDBUF:	HRRZ BUFP,FREBUF
SRCBUF:	CAMN BLK,BUFBLK(BUFP)
	 JRST CPOPJ1		;FOUND A BUFFER WITH THAT BLOCK IN IT
	HRRZ BUFP,BUFLNK(BUFP)	;NOT THIS ON, SEARCH
	CAME BUFP,FREBUF
	 JRST SRCBUF		;MORE TO LOOK AT
	POPJ P,

FNDBLK:	PUSHJ P,FNDBUF
	 SKIPA			;NO BUFFER FOUND
	JRST CPOPJ1		;FOUND IT, ALL OK
	MOVEI T1,-1(BLK)	;GET THE DESIRED BLOCK
	LSH T1,2
	USETI PSW,1(T1)
	STATZ PSW,20000		;DID IT SET EOF?
	 JRST FNDBDN		;YES, RESET EOF BIT AND EXIT
	PUSHJ P,SRCFBF
	HRRZ T1,BUFLNK(BUFP)
	MOVEM T1,FREBUF		;START LOOKING WITH NEXT BUFFER
	MOVEM BLK,BUFBLK(BUFP)
	INPUT PSW,BUFIOW(BUFP)
	AOS (P)
	STATZ PSW,740000
	 OUTSTR [ASCIZ /
Read error on password file!
/]
FNDBDN:	SETSTS PSW,16
	POPJ P,

;SEARCH FOR A FREE BUFFER

SRCFBF:	SKIPL BUFLNK(BUFP)	;SEARCH FOR ONE NOT LOCKED
	 POPJ P,	;FOUND A FREE ONE
	HRRZ BUFP,BUFLNK(BUFP)
	CAME BUFP,FREBUF
	 JRST SRCFBF
	OUTSTR [ASCIZ /
Program error, no free buffers!/]
	CLOSE RPT,
	EXIT

ZERBLK:	MOVE BUFP,FREBUF
	PUSHJ P,SRCFBF		;FIND A FREE ONE
	MOVEM BLK,BUFBLK(BUFP)
	SETZM (BUFP)
	HRL T1,BUFP
	HRRI T1,1(BUFP)
	BLT T1,777(BUFP)
	POPJ P,			;NOW HAVE A BLOCK OF 0'S

BUFLOK:	EXCH PNTR,(P)		;SAVE PNTR
	PUSH P,BUFLNK(BUFP)	;AND THE ORIGINAL BLOCK-LOCK WORD
	MOVSI T1,400000
	IORM T1,BUFLNK(BUFP)	;LOCK BUFFER
	PUSH P,BUFP
	MOVE T1,PNTR
	MOVE PNTR,-2(P)		;RESTORE PNTR FOR CALLER
	JRST (T1)

BUFULK:	POP P,PNTR		;RETURN ADDRESS
	EXCH PNTR,-2(P)		;RESTORE POINTER
	POP P,BUFP
	HRRZ BLK,BUFBLK(BUFP)
	POP P,BUFLNK(BUFP)
	POPJ P,			;AND RETURN

LOKERR:	OUTSTR [ASCIZ /
Program error, can not find locked buffer/]
	JRST GETOUT

;READ AN OPERATOR NAME AND PRODUCE THE RADIX 45. REPRESENTATION

RDNAM:  SETZB NM1,NM2
	MOVEI T2,^D12	;12 CHARACTERS
RDNM0:	INCHWL T1
	CAIN T1," "
	JRST RDNM0	;SKIP LEADING SPACES
	SKIPA
RDNM1:	INCHWL T1
	CAIGE T1,40
	JRST FINNAM	;FINISH READING NAME
	PUSHJ P,ACMCHR	;CONVERT CHR AND ADD IN
	SOJG T2,RDNM1
	JRST FINCR1	;FINISH READING LINE

FINNAM:	CAIN T2,^D12	;DETECT NO NAME TYPED
	JRST FINCR	;AND NON-SKIP EXIT
	PUSH P,T1	;SAVE CHR READ
FINM1:	MOVEI T1," "
	PUSHJ P,ACMCH2
	SOJG T2,FINM1
	POP P,T1
FINCR1:	AOS (P)
FINCR:	CAIE T1,12
	JRST	[INCHWL T1
		JRST FINCR]
	POPJ P,

NAMPMT:	PUSHJ P,RDNAM	;TAKE POSSIBLE NAME ON SAME LINE AS CMD
	 SKIPA		;NO NAME GIVEN THERE, PROMPT
	JRST CPOPJ1	;OK
	OUTSTR [ASCIZ /Enter operator name: /]
	JRST RDNAM	;GO READ IT

ACMCHR:	CAILE T1,140
	SUBI T1,40	;CONVERT UPPER CASE
ACMCH2:	MOVE T3,NM1	;SAVE HIGH ORDER PART
	MOVE NM1,NM2
	IMULI T3,^D45
	MULI NM1,^D45
	ADD NM1,T3	;DOUBLE PRECISION MULTIPLY
	ADD NM2,CHRTAB-40(T1)
	POPJ P,

	DEFINE X1 (A,B)
<	RELOC CHRTAB+A-40
	B
	RELOC>

	DEFINE X2(A,B,C)
<	XX=C
	RELOC CHRTAB+A-40
	REPEAT B-A+1,<XX
	XX==XX+1>
	RELOC>

CHRTAB:	REPEAT 100,<54>
	CHRCNV

;FIND A NAME IN THE FILE

FNDNAM:	MOVEI BLK,1
FNDNM2:	PUSHJ P,FNDBLK	;GET THAT BLOCK
	 POPJ P,	;EOF, NO NAME
	MOVE PNTR,BUFP
	HRLI PNTR,-^D73	;73 NAMES PER BLOCK
FNDNM1:	CAMN NM1,BFNM1(PNTR)
	CAME NM2,BFNM2(PNTR)
	SKIPA
	JRST CPOPJ1	;FOUND
	ADDI PNTR,6
	AOBJN PNTR,FNDNM1	;NEXT NAME ENTRY
	AOJA BLK,FNDNM2	;NEXT BLOCK

FNDSPC:	MOVEI BLK,1
FNDSP2:	PUSHJ P,FNDBLK
	 PUSHJ P,ZERBLK	;NO MORE BLOCKS, GENERATE BLOCK OF 0'S
	MOVE PNTR,BUFP
	HRLI PNTR,-^D73
FNDSP1:	SKIPN BFNM1(PNTR)
	POPJ P,		;FOUND IT
	ADDI PNTR,6
	AOBJN PNTR,FNDSP1	;NEXT ENTRY IN BLOCK
	AOJA BLK,FNDSP2	;NEXT BLOCK

ARRAY X[5]

RDPAS:	MOVE T2,[point 7,PASBUF]
RDPAS1:	INCHWL T1
	IDPB T1,T2
	CAIE T1,12
	 JRST RDPAS1
RDPAS2:	MOVE T1,[point 7,PASBUF]
	MOVEM T1,PASPTR#
	MOVE T1,[555555555555]
	MOVEM T1,X
	MOVEM T1,X+2
	MOVEM T1,X+4
	MOVE T1,[361275431652]
	MOVEM T1,X+1
	MOVEM T1,X+3
	MOVEI T3,0
	MOVEI T5,7
PSWLP:	ILDB T1,PASPTR
	CAIE T1,15
	 CAIN T1,12
	  POPJ P,
	CAIL T1,140
	 SUBI T1,40
	ADDM T1,X
	ADDM T1,X+3
	MOVEI T4,40
RAND:	MOVE T1,X(T3)
	MUL T1,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM T2,X+1(T3)
	CAIE T3,3
	 AOJA T3,RAND1
	MOVE T3,X+4
	ADDM T3,X
	LSH T3,-42
RAND1:	SOJG T4,RAND
	SOJA T5,PSWLP

SETLIC:	OUTSTR [ASCIZ /License: /]
	SETZM SAVCHR#
	SETZM DESLIC#
	PUSHJ P,SCAN
	 JRST LICPMT	;JUST RETURN, PROMPT
SETLC1:	MOVSI T3,-LICLEN
	MOVE T2,ACCUM
LICSR1:	CAMN T2,LICSIX(T3)	;LOOK FOR THE LICENSE HE TYPED IN
	JRST FNDLIC	;GO IT
	AOBJN T3,LICSR1
	PUSHJ P,FINCR	;DID NOT TYPE SOMETHING WE RECOGNIZE
	OUTSTR [ASCIZ "?
"]
	JRST SETLIC	;LET HIM TRY AGAIN

POS:	MOVEI C," "		; go to line position (T1)
	PUSHJ P,CHROUT
	AOS LINPOS
	CAMLE T1,LINPOS
	  JRST POS
	POPJ P,

OUTSIX:	MOVEI T1,0		; output sixbit from T2
	LSHC T1,6
	MOVEI C," "(T1)
	PUSHJ P,CHROUT
	AOS LINPOS
	JUMPN T2,OUTSIX
	POPJ P,

FNDLIC: LDB T2,LICBP(T3)	;GET CURRENT SETTING OF FIELD
	CAMGE T2,LICVL1(T3)	;IN CASE OF RF RP ETC.
	MOVE T2,LICVL1(T3)	;SETTING HIGHER THAN IT WAS
	DPB T2,LICBP(T3)	;SAVE IT AWAY
	PUSHJ P,SCAN		;SCAN FOR MORE
	 JRST	[MOVE T2,DESLIC	;RETURN LICENSE SET
		POPJ P,]
	JRST SETLC1		;ANOTHER, LOOP SOME MORE

LICPMT:	MOVSI T3,-LICLEN
LICPM1:	LDB T2,LICBP(T3)
	CAML T2,LICVL1(T3)	;ALREADY SET THAT MUCH OR MORE?
	 JRST NXTPMT		;YES. DONT ASK RP AFTER YES TO RF
	OUTSTR @LICFUL(T3)	;ASK FOR LICENSE BY NAME
	INCHWL T1
	CAIE T1,"Y"
	 CAIN T1,"y"
	  JRST	[MOVE T2,LICVL1(T3)	;SAID YES
		DPB T2,LICBP(T3)
		JRST .+1]
	PUSHJ P,FINCR
NXTPMT:	AOBJN T3,LICPM1
	MOVE T2,DESLIC
	POPJ P,

;SCANNER TO SCAN TO IDENT

SCAN:	SETZM ACCUM#
	MOVE T2,[POINT 6,ACCUM]
	SKIPN T1,SAVCHR
SCAN1:	INCHWL T1
	CAIGE T1,40
	JRST FINCR	;FINISH LINE AND NON-SKIP RETURN
	CAILE T1,140
	SUBI T1,40	;CONVERT LOWER TO UPPER
	CAIG T1,"Z"	;LOOK FOR LETTERR
	CAIGE T1,"A"
	JRST SCAN1
SCAN2:	SUBI T1,40	;CONVERT TO SIXBIT
	TLNE T2,770000
	IDPB T1,T2
	INCHWL T1
	CAILE T1,140
	SUBI T1,40
	CAIG T1,"Z"
	CAIGE T1,"A"
	SKIPA
	JRST SCAN2
	MOVEM T1,SAVCHR	;END OF IDENT
	JRST CPOPJ1

;TABLES FOR LICENSE

	DEFINE LICENS
<
	X WC,1,18,1,<Write>
	X RC,1,19,1,<Read core>
	X OP,1,20,1,<Operator>
	X SY,1,21,1,<Systat>
	X GD,1,22,1,<Get devices>
	X TD,1,23,1,<Transfer devices>
	X ST,1,24,1,<Structures>
	X JL,1,26,1,<Jacct-login>
	X AC,1,27,1,<Aux circuits>
	X XC,1,28,1,<Modify charges>
	X RA,3,33,2,<Read absolute>
	X RF,2,33,2,<Read files>
	X RP,1,33,2,<Read project>
	X WA,3,35,2,<Write absolute>
	X WF,2,35,2,<Write files>
	X WP,1,35,2,<Write project>
	X MG,1,17,1,<Manager>
	X HU,1,16,1,<Hang user>
	X CS,1,15,1,<Customer services>
	X AP,1,14,1,<Accounting programs>
	X MT,1,13,1,<Maintenance>
	X SP,1,12,1,<Spooling>
	X RL,1,11,1,<Remote license>
>

	DEFINE X (A,B,C,D,E)
<	SIXBIT /A/>

LICSIX:	LICENS
LICLEN==.-LICSIX

	DEFINE X(A,V,C,D,E)
<	V'B'C>

LICVAL:	LICENS

	DEFINE X(A,B,C,D,E)
<	POINT D,DESLIC,C>

LICBP:	LICENS

	DEFINE X(A,B,C,D,E)
<	[ASCIZ /E (A) /]>

LICFUL:	LICENS

	DEFINE X(A,V,C,Q,E)
<	IFL ^D'C-^D18,<L.'A==(V'B'C)>
	IFGE ^D'C-^D18,<L.'A==V'B'C>>

	LICENS

	DEFINE X(A,B,C,D,E)
<	B>

LICVL1:	LICENS

	END STPT
mW9a