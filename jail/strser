COMMENT \ HISTORY
AUTHOR,REASON
023  102300000004 \;

COMMENT \
VERSION 19-1(4)  24-SEP-81 by SDD CMPSTR/KMPSTR fixes p14,16
VERSION 19-1(3)  23-SEP-81 by SDD GETBREAK/UNOMIT bit in wrong half p22,24
VERSION 19-1(2)  06-APR-80 by SDD start the multi-width changes
VERSION 19-1(1)  05-FEB-80 by SDD remove less and greater comments
VERSION 19-1(0)  04-FEB-80 by SDD remove HEREFKs for new version
VERSION 17-1(52) 11-SEP-79 by SDD [CLH] changes for stdbrk file
			also fix "misaligned string" in CVx:CVSET
VERSION 17-1(51) 18-MAY-78 by SDD fix break table 0 alloc in BKTCHK p16
VERSION 17-1(50) 11-JAN-78 by SDD make CVEL really BILTIN p29
VERSION 17-1(49) 9-JAN-78 by SDD make CVEL use DMOVN and expchr(user) p 30,31
VERSION 17-1(48) 11-13-74 BY JFR GETBREAK BUG P.21
VERSION 17-1(47) 11-7-74 BY RHT FEAT %BW% CV6STR
VERSION 17-1(46) 11-2-74 BY JFR MODS TO HANDLE BREAKTABLE 0(P.16)
VERSION 17-1(45) 10-26-74 BY JFR GETBREAK
VERSION 17-1(44) 10-26-74 BY JFR BUG #TP GETBREAK FIXES
VERSION 17-1(43) 10-14-74 BY JFR CHECK FOR HACK'S--NONE FOUND
VERSION 17-1(42) 10-13-74 BY JFR FIX MINOR LOSSAGE IN SCAN
VERSION 17-1(41) 10-13-74 BY    
VERSION 17-1(40) 10-11-74 BY JFR CORRECT TYPOS %BS%
VERSION 17-1(39) 10-11-74 BY JFR INSTALL GETBREAK, RELBREAK
VERSION 17-1(38) 10-11-74 
VERSION 17-1(37) 10-11-74 BY JFR BETTER ERROR TRACING FOR %BS% BKTCHK
VERSION 17-1(36) 10-11-74 BY JFR FEAT %BS% (SECOND HALF) NEW WAY TO DO BREAK TABLES
VERSION 17-1(35) 10-10-74 BY JFR FEAT %BS% (FIRST HALF) NEW WAY TO DO BREAK TABLES
VERSION 17-1(34) 10-10-74 
VERSION 17-1(33) 10-10-74 
VERSION 17-1(32) 10-10-74 
VERSION 17-1(31) 10-10-74 
VERSION 17-1(30) 10-10-74 
VERSION 17-1(29) 9-16-74 BY RHT BUG #TH# OVERFLOW IN SCAN
VERSION 17-1(28) 9-8-74 BY RHT BUG #TF# NEW SCAN LOSING WHEN NO BRK CHR
VERSION 17-1(27) 7-29-74 BY RHT BUG #SW# NEW SCAN PROBLEM
VERSION 17-1(26) 7-19-74 BY RHT FEAT %BK% MAKE SCAN BETTER FOR NON-OMIT CASE
VERSION 17-1(25) 5-30-74 BY RHT FIX UP SOME COMPILS
VERSION 17-1(24) 5-29-74 BY RHT FIX STDBRK
VERSION 17-1(23) 5-25-74 BY RLS EDIT
VERSION 17-1(22) 5-25-74 BY rls edit
VERSION 17-1(21) 5-25-74 BY rls edit
VERSION 17-1(20) 5-25-74 
VERSION 17-1(19) 5-25-74 BY RLS EDIT
VERSION 17-1(18) 5-24-74 BY RLS EDIT
VERSION 17-1(17) 5-24-74 BY RLS MAKE STDBRK SYSTEM INDEPENDENT
VERSION 17-1(16) 5-24-74 
VERSION 17-1(15) 5-24-74 BY rht move some routines over from ioser
VERSION 17-1(14) 5-24-74 
VERSION 17-1(13) 5-24-74 
VERSION 17-1(12) 5-24-74 
VERSION 17-1(11) 5-24-74 
VERSION 17-1(10) 5-24-74 
VERSION 17-1(9) 5-24-74 
VERSION 17-1(8) 5-24-74 
VERSION 17-1(7) 1-13-74 BY JRL BUG QI CVO DIDN'T WORK WITH INTERRUPTS ENABLED
VERSION 17-1(6) 1-13-74 
VERSION 17-1(5) 12-14-73 BY RFS BUG #QB# MAKE CVG DO LARGEST NEG RIGHT
VERSION 17-1(4) 12-8-73 BY JRL REMOVE SPECIAL STANFORD CHARACTERS(WHERE POSSIBLE)
VERSION 17-1(3) 11-28-73 BY RLS BUG #PG# CVS OF '400000000000
VERSION 17-1(2) 11-28-73 
VERSION 17-1(1) 11-25-73 BY RHT BUG #LA# MAKE CVSIX HONEST
VERSION 17-1(14) 7-26-73 BY RHT **** VERSION 17 ****
VERSION 16-2(13) 3-18-73 BY RHT PROTECT RPH FROM USERERR 
VERSION 16-2(12) 5-11-72 BY DCS BUG #GY# BE SURE ALIGNED IF SGLIGN & ALREDY CATED
VERSION 15-2(6-11) 5-11-72 
VERSION 15-2(5) 2-8-72 BY DCS BUG #GL# -- CANCEL SAME -- COULDN'T GET RIGHT
VERSION 15-2(4) 2-6-72 BY DCS BUG #GL# CVF, CVG, CVE DON'T PUT OUT EXTRA SPACE WHEN NON-NEGATIVE
VERSION 15-2(3) 2-5-72 BY DCS BUG #GI# OPTIMIZE CAT, REMOVE TOPSTR
VERSION 15-2(2) 12-21-71 BY DCS BUG #FS# REMOVE SAILRUN CONDITIONAL
VERSION 15-2(1) 12-2-71 BY DCS INSTALL VERSION NUMBER

\;

SUBTTL	Discussion
	LSTON	(STRSER)
DSCR BEGIN STRSER

IFN ALWAYS,<BEGIN STRSER>

DSCR STRSER DISCUSSION


Comment  These routines manipulate entities known to
	SAIL/GOGOL users as STRINGS. A string is described by
	a two-word string descriptor with the following format:
   WD1:	string no,,# of characters
   WD2:	byte pointer to string

String no. is incremented whenever a new string is created at
	the top of string space. (SUBSTR does not increment it).  An
	ILDB on WD2 gets the first character of the string.

All parameters necessary for string operations are in the user's
	parameter table (GOGTAB pnts  at it):
  TOPBYTE: byte pointer to next available character
  REMCHR:  negative count of free characters remaining
  ST:	   addr of first string space word
  STTOP:   addr of last word.

STRNGC is the compacting string garbage collector, called when not
	enough space remains. The number of characters desired by the
	operation detecting the lack is in register A on entry.

Strings are concatenated by copying both operands to the top
	of string space (or only the 2nd if the first is already
	on top), and creating a descriptor for the new string.  
	SUBSTR operations simply create new descriptors.
	GETCH and PUTCH handle numeric to string conversions (vice-versa)


COMPIL(CAT,<CAT,CMCAT,CATCHR,CHRCAT,CHRCHR,CAT.RV,CMC.RV>
	  ,<SAVE,RESTR,X22,X33,STRNGC,INSET,GOGTAB,CONFIG,PUTCH,SELWID>
	  ,<CAT -- CONCATENATION ROUTINES>)

;;#GI# DCS 2-5-72 OPTIMIZE CAT SOME MORE, REMOVE TOPSTR
DSCR "STRING"_CAT("STR1","STR2");
CAL SAIL
DES CALL GENERATED BY COMPILER FOR & OPERATOR

ki10 <
IFN TEMP-LPSA-1,<
PRINTX "Bad assumption: LPSA+1=TEMP"
>
HERE (CAT.RV)
	DMOVE	LPSA,-3(SP)	;arguments are in reverse order,
	EXCH	LPSA,-1(SP)	; put them right
	EXCH	LPSA+1,(SP)
	DMOVEM	LPSA,-3(SP)
	JRST	CAT
HERE (CMC.RV)
	DMOVE	LPSA,-3(SP)	;arguments are in reverse order,
	EXCH	LPSA,-1(SP)	; put them right
	EXCH	LPSA+1,(SP)
	DMOVEM	LPSA,-3(SP)
	JRST	CMCAT
>;ki10
noki10 <
HERE (CAT.RV)
	TDZA	LPSA,LPSA	;flag this as "widths must match"
HERE (CMC.RV)
	 SETO	LPSA,		;this is "Compatible concatenate"
	MOVE	TEMP,-3(SP)	;arguments are in reverse order,
	EXCH	TEMP,-1(SP)	;switch lengths
	MOVEM	TEMP,-3(SP)
	MOVE	TEMP,-2(SP)	;and switch byte pointers
	EXCH	TEMP,(SP)
	MOVEM	TEMP,-2(SP)
	JRST	ST.CAT
>;noki10

HERE (CAT)
	TDZA	LPSA,LPSA	;flag this as "widths must match"
HERE (CMCAT)
	 SETO	LPSA,		;this is "Compatible concatenate"
ST.CAT:	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)		;SAVE FOR STRNGC ERR MESSAGE
	HRRZ	TEMP,-3(SP)		;FIRST STRING NULL?
	JUMPE	TEMP,RETSEC		;YES, RETURN SECOND STRING
	HRRZ	TEMP,-1(SP)		;SECOND STRING NULL?
	JUMPE	TEMP,RETFRS		;YES, RETURN FIRST STRING
CATGO:
	MOVEI	TEMP,RACS(USER)
	BLT	TEMP,RACS+4(USER)
	MOVEM	RF,RACS+RF(USER)	;SAVE F-REGISTER
	LDB	D,[POINT 6,-2(SP),11]	;get width of first arg MAX
	LDB	TEMP,[POINT 6,(SP),11]	;     width of second arg
	CAIN	D,(TEMP)
	 JRST	WID.OK			;widths match, no problem
	CAIGE	D,(TEMP)
	 MOVEI	D,(TEMP)
	JUMPN	LPSA,WID.OK		;moan on width mis-match?
	CAI	D,			;provide ac for error uuo
	ERR <Incompatible string widths to CAT, will use MAXIMUM >,7
WID.OK:	PUSHJ	P,SELWID		;select appropriate WCR (in A)
CATGO1:
KL10 <
	HRRZ	LPSA,-3(SP)	;get size of first arg (will use later)
	MOVEI	A,(LPSA)
	ADJBP	LPSA,-2(SP)	;get byte address of last byte of arg1
	SETZB	C,B
	ADJBP	C,(SP)		;and byte address of byte preceding arg2
	CAMN	C,LPSA
	 JRST	ADJRET		;Wow! they are the same, no move needed
	ADJBP	B,TOPBYTE(USER)	;get byte address of last used byte
	CAMN	B,LPSA
	 JRST	ONLY1		;first arg already at top, move #2
>;kl10
nokl10 <
	MOVE	B,-2(SP)	;bytePtr word of first string
	XOR	B,TOPBYTE(USER)	;STR1 must be result width
	TLNE	B,007777	;in order to use it in result at all
	 JRST	MOVTWO
	SKIPE	SGLIGN(USER)
	 JRST	[HLLZ	C,-2(SP) ;save some effort if must align them
		 HRRI	C,[1B0
			   1B0]
		 ILDB	C,C	;by checking for word alignment here
		 JUMPN	C,.+1
		 JRST	MOVTWO]
	MOVE	A,STWCRA(USER)	;get the WCR for this size
	MOVE	A,$STHAN(A)	;and from it a valid SPC (for consts)
	HRRZ	B,-3(SP)	;get size of first arg
	IDIV	B,.BYPWD(A)	;convert to word advance and bytes
	ADD	B,-2(SP)	;advance by the word part
	JUMPE	C,GOTEND	;short circuit some calculation
	IMUL	C,.BYSIZ(A)	;figure extra bits to advance
	LDB	TEMP,[POINT 6,B,5] ;get bits remaining in eff word
	SUBM	TEMP,C		;reduce  P-field
	JUMPL	C,[LDB TEMP,[POINT 6,.STTOP(A),5];passed word boundary
		   SUBI C,-44(TEMP)	;add a wordfull of (usable) bits
		   AOJA B,.+1]		;advance by a word
	DPB	C,[POINT 6,B,5]
GOTEND:	IBP	B	;make sure we do not compare
	MOVE	C,(SP)	;a pair of pointers like: POINT 7,e,-1
	IBP	C	; and POINT 7,e,34
	CAMN	B,C	;well, are the args ajacent?
	 JRST	ADJRET	;yup, just bump the count

	MOVE	C,TOPBYTE(USER)	;well perhaps we only need to copy the
	IBP	C	;the second string. See if string 1 is on top
	CAMN	B,C	;well, does it match?
	 JRST	ONLY1	;yes, all we need is copy the second
>;NOKL10
; TWO STRINGS TO MOVE

MOVTWO:	HRRZ	A,-1(SP)	;#CHARS(2)
	HRRZ	B,-3(SP)	;#CHARS(1)
	ADD	A,B		;plus size of first
	ADDM	A,REMCHR(USER)	;#CHARS(NEW) - REMAINING #CHARS
	SKIPLE	REMCHR(USER)	;ENOUGH ROOM?
	 PUSHJ	P,STRNGC	;NO, GO MAKE SOME
	SKIPE	SGLIGN(USER)	;IF ALIGNING,
	 PUSHJ	P,INSET		; ALIGN (will not cause collect)
	HRROM	A,-3(SP)	;store size of result
	MOVE	LPSA,TOPBYTE(USER);WILL BE NEW BYTE POINTER
	MOVE	A,-2(SP)	;GET FIRST BYTE POINTER
	MOVEM	LPSA,-2(SP)	;WILL BE RESULT
	ILDB	C,A		;KNOWN NOT TO BE NULL STRING
	IDPB	C,LPSA		;MOVE THE STRING
	SOJG	B,.-2		;RAPIDLY
	HRRZ	A,-1(SP)	;#CHARS(2)
	JRST	CATB


ONLY1: ;  only one string to move
KL10 <;KIs already checked this
	SKIPE	SGLIGN(USER)	;CHECK ALIGNMENT?
	 JSP	C,CHKLGN	;YES, DON'T RETURN IF MISALIGNED
>;KL10
	HRRZ	A,-1(SP)	;#CHARS(2)
	ADDM	A,REMCHR(USER)	; - REMAINING CHARS
	SKIPLE	REMCHR(USER)	;ROOM?
	 JRST  [HRRZ	B,-3(SP)	;better make sure room
		ADD	A,B		;for the entire string
		PUSHJ	P,STRNGC	;collect then start from scratch
		MOVNS	A		;since new string space may void
		ADDM	A,REMCHR(USER)	;the ONLY1 condition.
		JRST	CATGO1]		;CATGO1 is new for this fix.
	ADDM	A,-3(SP)	;NEW #CHARS
	MOVE	LPSA,TOPBYTE(USER);EXTEND FROM HERE

CATB: ;  move second ARG (length in A)
	MOVE	B,(SP)		;2D BYTE POINTER
	ILDB	C,B		;MOVE THIS STRING
	IDPB	C,LPSA		;AND MOVE IT
	SOJG	A,.-2		; FAST
	MOVEM	LPSA,TOPBYTE(USER);PUT THIS AWAY, BY ALL MEANS
REST.G:	SETZ	D,		;restore normal Byte width
	PUSHJ	P,SELWID	;(and deselect the one just used)
	MOVSI	TEMP,RACS(USER)
	BLT	TEMP,D
RETFRS:	SUB	SP,X22		;REMOVE NON-RESULT
	JRST	@UUO1(USER)	;RETURN

RETSEC:	POP	SP,-2(SP)
	POP	SP,-2(SP)
	JRST 	@UUO1(USER)	;DIDN'T SAVE THEM

;;#GY# DCS 5-11-72 ASSURE FULL-WORD ALIGN IF SGLIGN AND ALREADY CATTED
ADJRET:
KL10 <;KAs and KIs already checked this
	SKIPE	SGLIGN(USER)	;CHECK ALIGNMENT?
	 JSP	C,CHKLGN	;YES, DON'T RETURN IF MISALIGNED
>;KL10
OKLG:	HRRZ	TEMP,-1(SP)	;COUNT OF 2D
	ADDM	TEMP,-3(SP)	;INCREASE COUNT OF FIRST
	JRST	REST.G

KL10 <
CHKLGN:	HLLZ	TEMP,-2(SP)	;Check to see if Word-aligned, return
	HRRI	TEMP,[1B0	;only if so (otherwise must copy both)
		      1B0]
	ILDB	TEMP,TEMP	;only word-aligned will find those bits
	JUMPN	TEMP,(C)	;picked up one of the bits! its OK
	JRST	 MOVTWO		;Not aligned, move both
>;KL10

DSCR "STRING"_CHRCAT(CHAR,"STR")

HERE (CHRCAT)
	MOVEI	LPSA,-2(SP)	;Where to eventually put 1-char string
	JRST	CATCGO		;GO DO SPECIAL CAT

DSCR "STRING"_CATCHR("STR",CHAR)

HERE (CATCHR)
	MOVEI	LPSA,(SP)	;Where to eventually put 1-char string
CATCGO:	HRRZ	TEMP,-1(SP)
	JUMPE	TEMP,ITSNUL
	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)	;RETURN ADDRESS
	POP	P,RACS+5(USER)	;PUT IT SOMEWHERE SAFE
	PUSH	SP,-1(SP)	;copy string
	PUSH	SP,-1(SP)	;copy string
	PUSH	LPSA,[1]	;PUT ONE-CHAR DESCRIPTOR ON
	MOVEI	TEMP,RACS+5(USER) ;make new byte pointer
	HLL	TEMP,(SP)	;same width as old one
	TLZ	TEMP,770000
	TLO	TEMP,440000	;but must be backed up (use -1-style)
	MOVEM	TEMP,1(LPSA)	;as byte pointer for the (new) constant
	MOVE	LPSA,(TEMP)	;get the byte he specified
	IDPB	LPSA,TEMP	;and store it for him
	JRST	CATGO		;EVERYBODY'S NON-NULL
				;(LPSA ignorable, WILL be compatible)
ITSNUL:	SUB	SP,X22
	JRST	PUTCH		;ZAP

DSCR "STRING"_CHRCHR(CHAR,CHAR)

HERE (CHRCHR)
	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)	;in case GC needs address
	MOVEM	RF,RACS+RF(USER)
	MOVEM	A,RACS+A(USER)
	MOVEI	A,2		;NEED 2 CHARS
	ADDM	A,REMCHR(USER)
	SKIPLE	REMCHR(USER)
	 PUSHJ	 P,STRNGC	;THE USUAL
	SKIPE	SGLIGN(USER)	;may have to word-align it
	 PUSHJ	P,INSET
	PUSH	SP,[XWD 40,2]	;resulting length word
	PUSH	SP,TOPBYTE(USER);and its byte pointer word
	POP	P,A		;get second character
	POP	P,TEMP		;and first
	IDPB	TEMP,TOPBYTE(USER);deposit the first
	IDPB	A,TOPBYTE(USER)	;and then the second
	MOVE	A,RACS+A(USER)	;recover A
	JRST	@UUO1(USER)	;And return

ENDCOM (CAT)

COMPIL(WD1,<WIDTH>,<X22>,<WIDTH: byte size of string or 0 if NULL>)
HERE(WIDTH)
;byteSize _ WIDTH("string")
;arg: string on SP stack.  res: WIDTH in A
	HRRZ	A,-1(SP)	;get length
	JUMPE	A,.+2		;zero length is zero width
	LDB	A,[POINT 6,(SP),11]	;     width of byte pointer
	SUB	SP,X22
	POPJ	P,
ENDCOM(WD1)

COMPIL(WD2,<STMAKE,STR.W,CHAR.W>,<GOGTAB,STRNGC,INSET,SELWID,X22,X33,X44>
	,<arbitrary width string constructors>)
SAVE.D:	MOVE	USER,GOGTAB
	MOVEI	TEMP,RACS(USER)
	BLT	TEMP,RACS+D(USER)
	MOVEM	RF,RACS+RF(USER)	;save this for GC use
	MOVE	TEMP,-1(P)	;save return address
	MOVEM	TEMP,UUO1(USER)	;for error messages
	POPJ	P,

RESTWD:	SETZ	D,		;restore normal width
	PUSHJ	P,SELWID	;and return

REST.D:	HRLZI	TEMP,RACS(USER)	;restore acs 0:D and return
	BLT	TEMP,D
	SUB	P,LPSA
	JRST	@UUO1(USER)

HERE(STMAKE)
;"aString"_ STMAKE(bytePointer,Length,width(0))
;width=0 means use byte size of byte pointer
	PUSHJ	P,SAVE.D	;save needed ACs
	MOVE	LPSA,X44
	PUSH	SP,-2(P)	;length word
	PUSH	SP,-3(P)	;byte pointer
	SKIPN	A,-1(SP)	;if 0 length
	 JRST	REST.D		; then we are all done
	TLNE	A,-1		;if any LH bits set
	 JRST	[SETZM	A,-1(SP)	;AC to show val in error message
		  ERR <STMAKE: Illegal length >,7
		 JRST	REST.D]
	SKIPN	D,-1(P)		;get desired width
	 LDB	D,[POINT 6,(SP),=11] ;default to byte pointers byte size

WIDCOP:	;Copy "string" on SP into string space of width D
	CAIG	D,44		;check out the range
	 JUMPG	D,WIDOK
	SETZM	D,-1(SP)	;AC to show val in error message
	ERR <STMAKE: Illegal width >,7
	JRST	REST.D
WIDOK:	PUSHJ	P,SELWID	;set appropriate string space
	HRRZ	A,-1(SP)	;make sure enough room
	ADDM	A,REMCHR(USER)
	SKIPLE	REMCHR(USER)
	 PUSHJ	P,STRNGC
	SKIPE	SGLIGN(USER)	;must be word-aligned?
	 PUSHJ	P,INSET
	MOVE	D,TOPBYTE(USER)	;where chars go
	MOVE	B,(SP)		;where they come from
	MOVEM	D,(SP)		;will be new string start BP
	ILDB	C,B		;transfer those bytes
	IDPB	C,D
	SOJG	A,.-2
	HRROS	-1(SP)		;mark result dynamic
	MOVEM	D,TOPBYTE(USER)	;update end of string space
	JRST	RESTWD		;restore byte size and go

HERE(STR.W)
;"copy"_ STR.C("string",desiredWidth)
	HRRZ	TEMP,-1(SP)	;if 0 length
	JUMPE	TEMP,NOCOPY	;then string is just fine, thanks
	LDB	TEMP,[POINT 6,(SP),=11] ;get actual width of string
	CAMN	TEMP,-1(P)	;is it the same as the desired width?
	 JRST	NOCOPY		;how about that, save some effort
	PUSHJ	P,SAVE.D	;save a bunch of ACs, this takes a bit
	MOVE	LPSA,X22	;set up to restore on exit
	MOVE	D,-1(P)		;get desired result width
	JRST	WIDCOP
NOCOPY:	SUB	P,X22
	JRST	@2(P)

HERE(CHAR.W)
;"Char"_ CHAR.W( characterValue, Width(0) )
	PUSHJ	P,SAVE.D
	MOVE	LPSA,X33
	MOVE	D,-1(P)		;get desired result width
	CAIG	D,44		;insure safe byte size specified
	 JUMPGE	D,D.OK		;yup (allow zero to mean system normal)
	 ERR <CHAR.W called with illegal byte size >,7
D.OK:	PUSHJ	P,SELWID
	AOSLE	REMCHR(USER)
	 PUSHJ	P,[MOVEI A,1			;Size needed
		   JRST	 STRNGC]		;do GC
	SKIPE	SGLIGN(USER)
	 PUSHJ	P,INSET
	PUSH	SP,[XWD 40,1]		;length word
	PUSH	SP,TOPBYTE(USER)	;and byte pointer
	MOVE	TEMP,-2(P)		;get the byte
	IDPB	TEMP,TOPBYTE(USER)	;and put it out
	JRST	RESTWD		;restore byte size and go
ENDCOM(WD2)
COMPIL(PTC,<PUTCH>,<GOGTAB,STRNGC,INSET>,<PUTCH -- PUT 1 CHARACTER ROUT>)

DSCR "1-CHR STRING"_PUTCH(INTEGER);
CAL SAIL
DES CALL GENERATED BY SAIL TO MAKE A 1 CHAR STRING FROM AN INTEGER


HERE(PUTCH)	
	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)
	AOSLE	REMCHR(USER)	;DECREASE FREE CHARS
	 JRST	[;have to GC, better set up for it 
		MOVEM	RF,RACS+RF(USER) ;GC needs this
		PUSH	P,A		;SAVE A
		MOVEI	A,1		;COUNT of needed for STRNGC
		PUSHJ	P,STRNGC	;go do the GC
		POP	P,A		;restore A
		JRST	.+1]
	SKIPE	SGLIGN(USER)	;if we are aligning
	 PUSHJ	P,INSET		;START ON FW BDRY (wont cause GC ever)
	PUSH	SP,[XWD 40,1]	;#CHARS
	PUSH	SP,TOPBYTE(USER);HERE'S WHERE IT GOES
	POP	P,TEMP		;GET CHARACTER
	IDPB	TEMP,TOPBYTE(USER) ;STORE CHAR, UPDATE TOPBYTE(USER)
	JRST	@UUO1(USER)	;RETURN

ENDCOM (PTC)

COMPIL(PNT,<POINT,BBPP.>,<GOGTAB,X22,X44>,<POINT, BBPP.>)

; GETCH AND LOP NOW DONE IN LINE, NO LONGER NEEDED

HERE (BBPP.)
HERE (POINT) 
	MOVEI	A,43		;GET LOW BIT
	SUB	A,-1(P)
	ROT	A,-6		;NOW IN HIGH BITS
	MOVE	TEMP,-3(P)	;BYTE SIZE
	DPB	TEMP,[POINT 6,A,11]
	HRR	A,-2(P)		;EFFECTIVE ADDRESS.
	SUB	P,X44
	JRST	@4(P)

ENDCOM(PNT)

COMPIL(CVF,<CVF,CVG,CVE>
	  ,<SAVE,STRNGC,RESTR,X22,X11,X33,.MT.,.CH.,.TEN.>
	  ,<CVF, CVG, CVE>)

DSCR "STRING"_CVF(REAL);
CAL SAIL


HERE (CVF)	PUSHJ P,SAVE
	PUSH P,[-1]
	JRST SSCONV

DSCR "STRING"_CVG(REAL);
CAL SAIL


HERE (CVG)	PUSHJ P,SAVE
	PUSH P,[1]
	JRST SSCONV

DSCR "STRING"_CVE(REAL);
CAL SAIL


HERE (CVE)	PUSHJ P,SAVE
	PUSH P,[0]
	JRST SSCONV

	BEGIN NUMOUT
^SSCONV:MOVE LPSA,X33
	PUSHJ P,BOUND

;BOUND RETURNS AN INTEGER IN B WHICH WILL CONVERT
;TO 8 DECIMAL DIGITS.
;AN EXPONENT OF TEN IN D AND THE SIGN OF THE NUMBER IN FF
	MOVM X,DIGS(USER)	;NUMBER OF DECIMALS
	SKIPGE (P)		;IF F FORMAT
	ADD X,D			;ADD THE TEN EXPONENT
	JUMPN B,E0
	JUMPN X,E0
	MOVEI A,2
	SKIPL (P)
	MOVEM A,(P)
E0:	JUMPGE X,E1
	MOVEI	B,0		;THIS FIXES A BUG
	JRST E2
E1:	CAIL X,10
	JRST E2
	MOVEI Y,10		; 0  LEQ  X LESS THAN 8
	SUB Y,X			;Y IS THE EXPONENT OF DIVISOR
	MOVE Z,.TEN.(Y)		;Z IS THE DIVISOR
	IDIV B,Z
	ASH Z,-1
	CAML C,Z
	AOJ B,			;ROUND
	CAMGE B,.TEN.(X)	;CHECK IF ROUND CAUSED ANOTHER DIGIT
	JRST E2
	SKIPGE (P)		;IF F FORMAT
	AOJA X,E2		;INCREASE DIGIT COUNT
	IDIVI B,=10		;OTHERWISE REMOVE IT
	AOJ D,			;AND INCREASE EXPONENT
E2:	MOVM A,DIGS(USER)
	CAMGE A,X
	MOVE A,X		;A CONTAINS NUMBER OF DIGITS
	ADDI A,2		;SIGN AND DECIMAL POINT
	SKIPL (P)
	ADDI A,4		;IF NOT F FORMAT @-DD
	MOVE ;SAVE CHARACTER COUNT
	MOVM Y,WDTH(USER)	;MINIMUN STRING LENGTH
	CAMG A,Y
	MOVE A,Y

; THE STRING GARBAGE COLLECTOR GOODIES

	ADDM A,REMCHR(USER)	;CHECK THERE IS ROOM
	SKIPLE REMCHR(USER)
	PUSHJ P,STRNGC		;NO ROOM
	HRRO C,A		;NON-ZERO, WITH COUNT
	PUSH SP,C
	PUSH SP,TOPBYTE(USER)

; INSERT LEADING SIGNS, BLANKS, ZEROES

	SUB A,Z			;NUMBER OF LEADING SPACES
	MOVEI C," "
	JUMPE A,E4		;NO LEADING SPACES
	SKIPL WDTH(USER)	;F FORMAT
	JRST E3
	JUMPE FF,.+2		;LEADING ZEROS - NO SIGN, GO DO ZEROES
	MOVEI C,"-"
	IDPB C,TOPBYTE(USER)
	MOVEI C,"0"
E5:	IDPB C,TOPBYTE(USER)	;FILL WITH ZEROS
	SOJG A,E5
	JRST C1
E3:	IDPB C,TOPBYTE(USER)	;FILL WITH BLANKS
	SOJG A,E3
;; #GL#
E4:	JUMPE FF,.+2		;NO SIGN, BLANKS ALL DONE
;;#GL#
	MOVEI C,"-"		;THEN THE SIGN
	IDPB C,TOPBYTE(USER)

;   CVF,CVE,CVG CONTD.

C1:	MOVEI Z,10
	SKIPL (P)
	JRST C6
	MOVE Y,X		;CVF NUMBER OF DIGITS
	MOVM A,DIGS(USER)	;NUMBER OF DECIMALS
	SUB Y,A			;POS OF DECIMAL POINT
	JUMPGE Y,C5		;IF POSITIVE
	SUB Z,Y
	MOVM X,DIGS(USER)
	SETZ Y,			;OTHERWISE ZERO
	JRST C5
C6:	SETZ Y,
	SKIPG (P)
	JRST C5
	JUMPL D,C5		;CVG IF NEG TAKE CVE
	CAMLE D,X		;IF ENOUGH DIGITS 
	JRST C5
	MOVE Y,D		;SHIFT DECIMAL POINT
	MOVEI	D,0		;AND ADJUST EXPONENT
C5:	PUSH P,[D1]		;RECURSIVE NUMBER PRINTER
C2:	CAIE X,(Y)		;DECIMAL POINT NOW 
	JRST C3
	SOJ Z,
	MOVEI C,"."		;YES
	SKIPE DIGS(USER)	;IF ZERO DIGITS
	JRST C4
	JUMPN B,C4
	MOVEI C," "
	SKIPL -1(P)
	JRST C9
	SOJA X,C3
C9:	MOVE Y,-1(P)
	CAIE Y,2
	JRST C4
	POP P,Y
	MOVE Y,[ASCII/ 0   /]
	JRST D8
C3:	CAILE X,(Z)		;IF MORE THAN 8 DIGITS
	JRST	[MOVEI C,"0"	;PUSH A ZERO
		JRST C4]
	IDIVI B,=10
	IORI C,"0"
C4:	HRLM C,(P)
	SOSL X
C8:	PUSHJ P,C2
C7:	HLRZ C,(P)		;PUSH NUMBER OUT
	IDPB C,TOPBYTE(USER)
	POPJ P,
D1:	SKIPGE (P)
	JRST D7
	SKIPN DIGS(USER)
	SOJA D,D2
	JUMPE D,	[MOVE Y,[ASCIZ /    /] ;EXPONENT ZERO SO STORE 
			JRST D8]		;FOUR BLANKS
D2:	SETZ Y,			;ACCUMULATE EXPONENT STRING
	SETZ FF,		;EXPONENT SIGN
	JUMPL D,	[SETO FF,	;NEGATIVE
			MOVN D,D	;MAKE POSITIVE
			JRST D4]
	HRLI Y," "=11		;NUMBER POS SO TRILING BLANK
D4:	CAIGE D,=10
	JRST 		[MOVEI X," "
			LSHC X,-7
			JRST D5]
D5:	IDIVI D,=10
	IORI X,"0"
	LSHC X,-7		;PUSH INTO Y
	JUMPG D,D5
;;%DY% 2! GJA/JFR 1-13-77
	SKIPN X,EXPCHR(USER)	;WHAT THE LOSER WANTED
	 MOVEI X,"@"		;NOT THERE, USE DEFAULT
	IDPB X,TOPBYTE(USER)
	MOVEI X,"-"		;MINUS SIGN
	SKIPE FF
D6:	IDPB X,TOPBYTE(USER)	;AND EXPONENT
	JUMPE Y,D7
D8:	LSHC X,7
	JRST D6
D7:	JRST RESTR		; RETURN

;  CVF,CVG,CVE CONTD.

BOUND:	SETZB FF,D		;TENS EXPONENT
	MOVE B,-3(P)		;INPUT NUMBER
	JUMPE B,ZERO
	JUMPG B,POS
;;#QB# RFS MAKE LARGEST NEG NUMBER WORK
	SETOB FF,A		;NUM IS NEG
	LSHC A,11		;SEPERATE BIN EXPONENT
	LSH B,-1
	SETCA A,		;BIN EXPONENT + 200
	JUMPE B,LARN		;LARGEST NEGATIVE???
	TLO B,400000		;
	MOVNS B
	JRST OK
LARN:	HRLOI B,177777		; LARGEST NEG SHIFTED RIGHT 1 BIT
	AOJA A,OK
;;#QB#
POS:	SETZ A,
	LSHC A,11		;SEPERATE BIN EXPONENT
	LSH B,-1
OK:	SUBI A,200		;BIN EXP IN A, ABS (BIN FRACT) IN B,
	;BINARY POINT LEFT OF BIT 1 SIGN OF NUMBER IN FF
	CAIL A,34
	JRST MULTI		;USE NEGATIVE POWERS OF TEN
	CAIG A,27		;N LESS THAN 34
	JRST FRACT		;USE POSITIVE POWERS OF TEN
	CAIL A,33		;30.2 LEQ N LESS THAN 34
	JRST TOPQ
	CAIG A,30		;30.2 LEQ N LESS THAN 33
	JRST BOT
DONE:	SUBI A,43		;31.2 LEQ N LESS THAN 33
	ASHC B,(A)
	TLNE C,200000		;ROUND
	AOJ B,
	ADDI D,10
ZERO:	POPJ P,
TOPQ:	CAMLE B,MF		;33.2 LEQ N LESS THAN 34
	JRST MULTI 		;33.276 LESS THAN N LESS THAN 34
	JRST DONE		;33.2 LEQ N LEQ 33.276
BOT:	CAMGE B,LF		;30.2 LEQ N LEQ 30
	JRST FRACT		;30.2 LEQ N LESS THAN 30.230
	JRST DONE		;30.230 LEQ N LESS THAN 30

;  CVF,CVG,CVE CONTD.

MULTI:	MOVEI X,13		;33.276 LESS THAN N
M2:	ASH D,1
	ADD A,.CH.(X)		;NEGATIVE POWERS OF TEN
	CAIG A,31
	JRST M1			;N LESS THAN 32
	PUSHJ P,LFMP		;31.2 LESS THAN N
M6:	IORI D,1		;SET EXPONENT BIT
	CAIL A,34
	SOJA X,M2		;35.2 LESS THAN N STILL TOO LARGE
	CAIE A,33		;31.2 LESS THAN N LESS THAN 34
	JRST M3			;31.2 LESS THAN N LESS THAN 33
	CAMLE B,MF		;33.2 LESS THAN N LESS THAN 34
	JRST M4			;33.276 LESS THAN N LESS THAN 34
M3:	ASH D,-6(X)		;33.2 LESS THAN N LEQ 33.276
	JRST DONE
M1:	CAIL A,30		;N LESS THAN 32
	JRST M5			;29.2 LESS THAN N LESS THAN 32
M8:	SUB A,.CH.(X)		;N LESS THAN 30 NO GOOD
	SOJA X,M2		;TRY NEXT POWER
M4:	CAIE X,6		;33.276 LESS THAN N LESS THAN 34
	SOJA X,M2
	MOVE B,MF		;33.276=N
	JRST DONE
M5:	MOVE Y,B		;SAVE B AND A
	MOVE Z,A
	PUSHJ P,LFMP
	CAIL A,31		;29.2 LESS THAN N LESS THAN 32
	JRST M6			;31.2 LESS THAN N LESS THAN 32
	CAIG A,27		;29.2 LESS THAN N LESS THAN 31
	JRST M7			;29.2 LESS THAN N LESS THAN 30
	CAML B,LF		;30.2 LESS THAN N LESS THAN 31
	JRST M6			;30.230 LESS THAN N LESS THAN 31
	CAILE X,6		;30.2 LESS THAN N LESS THAN 30.230
	JRST M7			;STILL SOME TO GO
	MOVE B,LF		;B=30.230
	JRST M6
M7:	MOVE B,Y		;RESTORE
	MOVE A,Z
	JRST M8

;  CVF,CVG,CVE CONTD.

FRACT:	MOVEI X,5		;N LESS THAN 30.230
L2:	ASH D,1
	ADD A,.CH.(X)
	CAIL A,33
	JRST L1			;32.2 LEQ N
	PUSHJ P,LFMP		;N LESS THAN 33
L6:	IORI D,1
	CAIGE A,30
	SOJA X,L2		;N LESS THAN 30
	CAIE A,30		;30.2 LEQ N LESS THAN 33
	JRST L3			;31.2 LEQ N LESS THAN 33
	CAMGE B,LF		;30.2 LEQ N LESS THAN 31
	JRST L4			;30.2 LEQ N LESS THAN 30.230
L3:	ASH D,(X)		;30.2300 LEQ N LESS THAN 31
L9:	MOVNS D
	JRST DONE
L1:	CAIG A,34		;32.2 LEQ N
	JRST L5			;32.2 LEQ N LESS THAN 35
L8:	SUB A,.CH.(X)		;34.2 LEQ N
	SOJA X,L2
L4:	SOJGE X,L2		;30.230 LEQ N LESS THAN 31
	MOVE B,LF		;N30.230
	JRST L9
L5:	MOVE Y,B		;SAVE B AND A
	MOVE Z,A
	PUSHJ P,LFMP
	CAIG A,32		;32.2 LEQ N LESS THAN 35
	JRST L6			;32.2 LEQ N LESS THAN 33
	CAIL A,34		;33.2 LEQ N LESS THAN 35
	JRST L7			;34.2 LEQ N LESS THAN 35
	CAMG B,MF		;33.2 LEQ N LESS THAN 34
	JRST L6			;33.2 LEQ N LESS THAN 34
	JUMPG X,L7		;33.276 LESS THAN N LESS THAN 34
	MOVE B,MF		;N=33.276
	JRST L6
L7:	MOVE B,Y		;RESTORE
	MOVE A,Z
	JRST L8
LFMP:	MUL B,.MT.(X)
	TLNE B,200000
	POPJ P,
	ASHC B,1
	SOJA A,.+1
	POPJ P,
LF:	230455000000
MF:	276570177400
	BEND NUMOUT

ENDCOM(CVF)

COMPIL(SUB,<SUBST,SUBSR>,<SAVE,RESTR,X22,.SKIP.,GOGTAB>,<SUBSTRING ROUTINES>)

DSCR "STRING"_SUBST("STRING",END CHAR,STARTING CHAR);
CAL SAIL
DES CALL GENERATED BY SAIL FOR STR[X FOR Y] OPERATION


HERE (SUBST)
	MOVE	LPSA,-2(P)		;END LOC
	JRST	SBSTR			;GO FINISH UP

; SUBSI NO LONGER NEEDED, REMOVED

DSCR "STRING"_SUBSR("STRING",#CHARS, START CHAR #);
CAL SAIL
DES CALL GENERATED BY SAIL FOR STR[X TO Y] OPERATION
 ALGORITHM IS AS FOLLOWS:
 	1) !SKIP!_FALSE; "NOSKIP" IF ALL OK
<	2) IF END LOC > LENGTH, REPLACE IT BY LENGTH, (RH(!SKIP!)_TRUE;
 	3) NOW IF START < 1 OR END-START < -1 (-1 means ZERO LENGTH REQUEST),>>
		LH(!SKIP!)_TRUE, SET START TO 1 OR LENGTH+1
 	4) ADJUST LENGTH AND BP IN DESCRIPTOR
 NOTICE THAT STR[INF+1 TO INF+1+(non-neg integer)] IS LEGAL, RETURNING NULL,
 	AND TURNING ON !SKIP!


HERE (SUBSR)
	SOS	LPSA,-2(P)		;#CHARS
	ADD	LPSA,-1(P)		;-1 + START = END

SBSTR:	MOVE	USER,GOGTAB	;FOR A MOMENT
	POP	P,UUO1(USER)	;SAVE RETURN -- NONSTANDARD!!
	SETZM	.SKIP.		;ASSUME ALL OK
	HRRZ	TEMP,-1(SP)	;LENGTH OF STRING
	CAMG	LPSA,TEMP	;END LOC CANNOT BE GREATER THAN LENGTH
	 JUMPGE	LPSA,OKS1	;it had better be positive
	JUMPL	LPSA,.+2	;END LOC CANNOT BE NEGATIVE 
	SKIPA	LPSA,TEMP	;NOR GREATER THAN LENGTH
	 SETZ	LPSA,		
	HLLOS	.SKIP.		;TELL THE USER END WAS WRONG
OKS1:	SOSGE	USER,(P)	;START LOC 0-based
	 JRST	NEGBEG		;Better start at character 1 or later
	CAIG	USER,(LPSA)	;NEW STRING MUST HAVE NON-NEG LENGTH
	 JRST	OKS		;ADJUST TO (LPSA)
	SETZ	LPSA,		;starts PAST END OF REQUEST, set to NULL
NEGBEG:	SETZ	USER,		;NON-POS, ADJUST TO beginning of string
	HRROS	.SKIP.		;TELL USER START IS BAD
				;NOW CAN DO SUBSTRING
OKS: ;;USER is number of bytes to advance start
	SUBI	LPSA,(USER)	;NEW STRING LENGTH
	HRRM	LPSA,-1(SP)	;GET RID OF IT, FORGET IT
	JUMPE	LPSA,RET.GO	;zero length doesn't need byte pointer
				;-- it may not have a valid byte pointer
KL10 <	;this machine has the ideal instruction for this garbage
	 ADJBP	USER,(SP)	;do an adjust byte pointer
	 MOVEM	USER,(SP)		;RESULT BP
RET.GO:	SUB	P,X22			;RID SELF OF ARGUMENTS
	JRST	@3(P)			;RETURN
>;KL10
NOKL10 <
	MOVE	TEMP,(SP)		;BP
	CAILE	USER,5
	 JRST	FANCY
	JUMPE	USER,RET.GO	;no advance necessary, dont bother
	IBP	TEMP
	SOJG	USER,.-1
PTWAY:	MOVEM	TEMP,(SP)	;RESULT BP
RET.GO:	SUB	P,X22		;RID SELF OF ARGUMENTS
	JRST	@3(P)		;RETURN

FANCY:	MOVEM	USER,(P)	;save amount to advance by
	SETZB	LPSA,USER
	LSHC	LPSA,6		;get P-field into LPSA
	ROTC	TEMP,6		;and size field into USER
	IDIVI	LPSA,(USER)	;convert P-field to remaining bytes
	SUB	LPSA,(P)	;calculate "remaining bytes in word"
	JUMPGE	LPSA,[;same word, should be easy
			IMULI	LPSA,(USER)	;convert to bits
			ADDI	LPSA,(TEMP)	;restore alignment
			DPB	LPSA,[POINT 6,(SP),5]	;set Pos field
			JRST	RET.GO]
	MOVEM	USER,(P)	;save byte size
	MOVEI	TEMP,=36
	IDIVI	TEMP,(USER)	;figure out bytes per word
	IDIVI	LPSA,(TEMP)	;-words to advance // bytes remaining
	IMUL	TEMP,(P)	;convert bytes remaining (LEQ 0) to bits
	ADDI	TEMP,=36	;in next word by appropriate amount
	AOS	USER,(SP)	;adjust eff addr part (advance 1)
	SUB	USER,LPSA	;adjust eff addr part
	DPB	TEMP,[POINT 6,USER,5]	;set POS field
	MOVEM	USER,(SP)
	JRST	RET.GO
>;NOKL10
ENDCOM (SUB)

COMPIL(EQU,<EQU>,<X44>,<EQU string equality check>)

DSCR BOOLEAN_EQU("STR1","STR2");
CAL SAIL
RES A: TRUE iff same length (Not necessarily width) and bytes are equal
SID TEMP,LPSA,USER (note USER NOT set to GOGTAB)


HERE (EQU)	
; NOTE USER NOT SET UP BECAUSE CAN BE NO ERROR MESSAGES
	HRRZ	A,-3(SP)	;LENGTH OF ONE STRING
	EXCH	B,-1(SP)	;LENGTH OF THE OTHER, save extra AC
	CAIE	A,(B)		;SAME LENGTH? (ignore LH of B)
	 JRST	NOTEQ		; NO, NOT EQUAL STRINGS
	MOVE	LPSA,(SP)	;ONE BYTE POINTER,
	MOVE	USER,-2(SP)	;THE OTHER BYTE POINTER 
				;drop into the loop
	SOJL	A,EQURET	;A will be -1=TRUE on loop termination
EQULUP:	ILDB	TEMP,USER	;ONE CHAR
	ILDB	B,LPSA		;ANOTHER
	CAMN	B,TEMP		;stop if not equal
	 SOJGE	A,EQULUP	;or if all done

	JUMPL	A,EQURET	;if stopped on count, A=-1=TRUE, done
NOTEQ:	MOVEI	A,0		;oops, character mismatch, return false
EQURET:	MOVE	B,-1(SP)	;RESTORE AC
	SUB	SP,X44		;GET RID OF ARGS
	POPJ	P,		;RETURN

ENDCOM (EQU)

COMPIL(CMP,<CMPSTR>,<X44>,<CMPSTR string order comparison>)

DSCR INTEGER_CMPSTR("STR1","STR2");
	Returns 0 if two strings are identical except that one has 0s 
    appended to it.  If they differ, ABS CMPSTR(s1,s2) is the character 
    position where the first difference occurs.  The result is negative 
    if the first string is "less" than the second string, and positive 
    otherwise.  The ordering is that of the characters of the string.
    functionally equivalent to: 
	FOR i _ 1 STEP 1 WHILE LENGTH(st1) AND LENGTH(st2)
	   DO IF (ch1_LOP(st1)) NEQ (ch2_LOP(st2))
		 THEN RETURN( IF ch1 LEQ ch2 THEN -i ELSE i )
	RETURN(0)

CAL SAIL
RES A: 0 if "equal" (presuming 0 padding)
    otherwise: ABS A = character position where differ
		A is negative iff ST1 is "less" than ST2
SID TEMP,LPSA,USER (note USER NOT set to GOGTAB)


HERE(CMPSTR)
	HRRZS	LPSA,-1(SP)	;get length of both 
	HRRZS	A,-3(SP)	;(clearing off the dynamic flags)
	CAILE	A,(LPSA)	; A := minimum length;
	 MOVE	A,LPSA
	MOVE	USER,A		; save length of shorter string
	SOJL	A,CMPLOK
CMPLUP:	ILDB	TEMP,-2(SP)	; Compare the next character;
	ILDB	LPSA,(SP)
	CAMN	LPSA,TEMP	; see if they are different
	 SOJGE	A,CMPLUP	; keep running, we are still ok;
	JUMPGE	A,CMPDIF	; if we stopped on difference, calc res

CMPLOK:				;decide which string is longest (if any)
	CAME	USER,-1(SP)	;is the second string minimum length?
	 SKIPA	LPSA,SP		;no: set sign=-, address of long string
	 MOVEI	LPSA,-2(SP)	;yes:set sign=+, address of first string
CLSCHK:	MOVEI	A,(USER)	;get the saved min length
	SUB	A,-1(LPSA)	;make that -# of remaining characters
	JUMPE	A,CMPRET	; none left means they match (return 0)

	ILDB	TEMP,(LPSA)	;read from the tail of the long string
	JUMPN	TEMP,CXDIFS	;until non-null found
	AOJL	A,.-2		;or end-of-string
;;SDD 24-SEP-81 -- preceding was mistakenly AOJG A,.-2
	JRST	CMPRET		;how about that, a full match
CXDIFS:	ADD	A,-1(LPSA)	;figure out how many characters passed
;;SDD 24-SEP-81 added next: A needs +1 (since loop increments at bottom)
	ADDI	A,1		;convert to character number of differ
	XOR	TEMP,LPSA	;if from second string, invert sign of 
				; character (36-bitters?)
	JUMPL	TEMP,CMPXRT	;leave with inverted order if char neg
	JRST	CMPRET		;or just plain leave

CMPDIF:	SUB	A,USER		; figure out how far from the start;
				; presumes st2 GTR st1: result negative;
	LDB	LPSA,(SP)	; TEMP already has ST1s character;
	CAMG	LPSA,TEMP	; in the correct order? (never equal);
CMPXRT:	 MOVN	A,A		; right magnitude, wrong sign, fix it;
CMPRET:	SUB	SP,X44		;strip off two value string args
	POPJ	P,		;and return
ENDCOM(CMP)
COMPIL(KEQ,<KEQU>,<KMPSTR,X44>,<KEQU case independent equality check>)

DSCR BOOLEAN_KEQU("STR1","STR2");
	Caseless string equality check.  like EQU but ignores case
    Functionally equivalent to: 
	EQU( SCANC(str1, NULL,NULL,"IK"), SCANC(str2, NULL,NULL,"IK") )

CAL SAIL
RES A: TRUE if they match
SID TEMP,LPSA,USER (note USER NOT set to GOGTAB)


HERE(KEQU)
; NOTE USER NOT SET UP BECAUSE CAN BE NO ERROR MESSAGES
	HRRZ	A,-3(SP)	;LENGTH OF ONE STRING
	EXCH	B,-1(SP)	;LENGTH OF THE OTHER, save extra AC
	CAIE	A,(B)		;SAME LENGTH? (ignore LH of B)
	 JRST	NOTKEQ		; NO, NOT EQUAL STRINGS
	MOVE	LPSA,(SP)	;ONE BYTE POINTER,
	MOVE	USER,-2(SP)	;THE OTHER BYTE POINTER 
	JRST	KLUP		;go start the loop

KASCHK:	TRZ	B,40		;clear case bit and check for alphabetic
	CAIL	B,"A"		;this makes it upper case when it was 
	 CAILE	B,"Z"		; either upper case or lower case
	  JRST	NOTKEQ		;well, not alphabetic, must be mis-match
KLUP:	SOJL	A,KEQRET	;A will be -1=TRUE on loop termination
	ILDB	TEMP,USER	;ONE CHAR
	ILDB	B,LPSA		;ANOTHER
	XOR	TEMP,B		;compare values
	JUMPE	TEMP,KLUP	;exactly equal
	CAIN	TEMP,40		;differ only by case bit?
	 JRST	KASCHK		;yup, go check more carefully

NOTKEQ:	MOVEI	A,0		;oops, character mismatch, return false
KEQRET:	MOVE	B,-1(SP)	;RESTORE AC
	SUB	SP,X44		;GET RID OF ARGS
	POPJ	P,		;RETURN
ENDCOM(KEQ)
COMPIL(KMP,<KMPSTR>,<X44>,<KMPSTR caseless string order comparison>)

DSCR INTEGER_KMPSTR("STR1","STR2");
	Just like CMPSTR except lower case letters are treated as if
    they are upper case.
    Note that KMPSTR("a","\") = KMPSTR("A","\") = -1
    Functionally equivalent to: 
	CMPSTR( SCANC(str1,NULL,NULL,"IK"), SCANC(str2,NULL,NULL,"IK") )

CAL SAIL
RES A: 0 if "equal" (presuming 0 padding)
    otherwise: ABS A = character position where differ
		A is negative iff ST1 is "less" than ST2
SID TEMP,LPSA,USER (note USER NOT set to GOGTAB)


HERE(KMPSTR)
	HRRZS	LPSA,-1(SP)	;get length of both 
	HRRZS	A,-3(SP)
;SDD 24-SEP-81 was (mistakenly) CAIG A,(LPSA) below
	CAILE	A,(LPSA)	; A := minimum length;
	 EXCH	A,LPSA
	MOVE	USER,A		; save length of shorter string
TSTLUP:	SOJL	A,KMPLOK
GOLUP:	ILDB	TEMP,-2(SP)	; Compare the next character;
	ILDB	LPSA,(SP)
	XOR	LPSA,TEMP	; find all bits where they differ;
	JUMPE	LPSA,TSTLUP	; they dont differ, go do another;
	CAIE	LPSA,40		; must only differ by case bit;
	 JRST	KASDIF
	IOR	LPSA,TEMP	; get character with case bit set;
	CAIL	LPSA,"a"	; well, was it alphabetic?;
	 CAILE	LPSA,"z"
	  JRST	KASDIF		; nope, they really differ;
	SOJGE	A,GOLUP		; kepp running, we are still ok;

KMPLOK:	MOVE	A,USER		;get the saved min length
				;(decide which string is long one)
	CAME	A,-1(SP)	;is the second string minimum length?
	 SKIPA	LPSA,SP		;no: set sign=-, address of long string
	 HRRZI	LPSA,-2(SP)	;yes:set sign=+, address of first string
KLSCHK:	SUB	A,-1(LPSA)	;get -length of remaining characters
	JUMPE	A,KASRET	; none left means they match (return 0)

	ILDB	TEMP,(LPSA)	;read from the tail of the long string
	JUMPN	TEMP,XDIFS	;until non-null found
	AOJL	A,.-2		;or end-of-string
;;SDD 24-SEP-81 -- preceding was mistakenly AOJG A,.-2
	JRST	KASRET		;how about that, a full match
XDIFS:	ADD	A,-1(LPSA)	;figure out how many characters passed
;;SDD 24-SEP-81 added next: A needs +1 (since loop increments at bottom)
	ADDI	A,1		;convert to character number of differ
	XOR	TEMP,LPSA	;if from second string, invert sign of 
				; character (36-bitters?)
	JUMPL	TEMP,KASXRT	;leave with inverted order if char neg
	JRST	KASRET		;or just plain leave

KASDIF:	SUB	A,USER		; figure out how far from the start;
				; presumes st2 GTR st1: result negative;
	LDB	LPSA,(SP)	; TEMP already has ST1s character;

	CAIL	LPSA,"a"	; force to UPPER case;
	 CAILE	LPSA,"z"	; for the comparison (which is bigger);
	  CAIA
	  MOVEI	LPSA,"A"-"a"(LPSA)	; convert letter to upper case;

	CAML	LPSA,TEMP	; in the correct order? (never equal);
	 JRST	KASRET		; yes. On case mismatch, TEMP is bigger;
			; if TEMP is lower-case, order may differ;
			; (we may have TEMP:"a"  greater than  LPSA:"B")
	CAIL	TEMP,"a"     ; order reversed unless TEMP is lowerCase;
	 CAILE	TEMP,"z"	; for the comparison (which is bigger);
	  JRST	KASXRT
	CAIG	LPSA,"A"-"a"(TEMP) ; TEMP was lc, compare UC version;
KASXRT:	 MOVN	A,A		; right magnitude, wrong sign, fix it;
KASRET:	SUB	SP,X44		;strip off two value string args
	POPJ	P,		;and return
ENDCOM(KMP)
COMPIL(CVD,<CVD,CVO>,<SAVE,RESTR,X11,X22>,<CVD AND CVO ROUTINES>)

DSCR INTEGER_CVD("STRING");
CAL SAIL


HERE (CVD)	
	PUSHJ	P,SAVE
	MOVEI	A,=10
	JRST	CV

DSCR INTEGER_CVO("STRING");
CAL SAIL


HERE (CVO)	
	PUSHJ	P,SAVE
	MOVEI	A,10
CV:	SETZB	B,Y		;COLLECT RESULT IN B, Y IS +/- FLAG
	JOV	.+1		;CLEAR ANY OVERFLOWS
	MOVE	LPSA,X11
	HRRZ	C,-1(SP)	;STRING COUNT
	MOVE	D,(SP)		;BYTE POINTER
CVL:	SOJL	C,CVDUN
	ILDB	X,D		;GET A CHAR
	CAIG	X," "		;IGNORE LEADING " "s  AND SUCH
	 JRST	 CVL
	CAIN	X,"-"		;NEGATIVE?
	TLCA	Y,10000		;NEGATE PREVIOUS NOTION
	CAIN	X,"+"		;PLUS?
	 JRST	 CVL		; GO BACK FOR MORE LEADING "BLANKS"

; NOW IT IS A DIGIT OR THE END

CNV:	CAIL	X,"0"		;IN RANGE?
	CAIL	X,"0"(A)	;A IS RADIX
	 JRST	 CVDUN		;NOT IN RANGE, DONE
	IMUL	B,A		;NUM=NUM*10+NEWDIG
;; #QI# THESE THREE USED TO BE DOWN AT CVDUN
	JOV	[CAIN	A,10	;CVO?
		 TLC	B,400000 ;YES, THIS SPECIAL HACK ALLOWS TYPING AN
		 JRST	.+1]	;UNSIGNED OCTAL NO. WITH BIT 0 ON
;; #QI#
	SUBI	B,-"0"(X)	;collect negative, (allows -1B0)
	SOJL	C,CVDUN		;DONE WHEN NEGATIVE
	ILDB	X,D
	JRST	CNV

CVDUN:
	XOR	Y,[MOVNM B,RACS+1(USER)] ;MOVEM OR MOVNM
	XCT	Y
	SUB	SP,X22
	JRST	RESTR

ENDCOM(CVD)

COMPIL(CVS,<GETFORMAT,SETFORMAT,CVS,CVOS>
	,<GOGTAB,INSET,X33,SAVE,RESTR,X11,X22,STRNGC>
	,<GETFORMAT, SETFORMAT, CVS, CVOS ROUTINES>)

DSCR "STR"_CVS(INTEGER);
CAL SAIL


HERE(CVS)	PUSHJ	P,SAVE
	PUSHJ	P,CVSET		;SET UP FOR CONVERSION
	MOVEI	D,=10		;WILL DIVIDE DECIMAL
	SKIPL	B,-2(P)		;IF NUMBER IS NEGATIVE,
	 JRST	 FRNP		; PRINT A MINUS SIGN,
	MOVM	B,B		;PRINT ABS VALUE
	JFCL	10,.+1		;
	MOVEI	Y,"-"		;Y IS NOT ZERO, SIGNALS BLKIN BELOW
	MOVEI	A,1		;ACCOUNT FOR EXTRA CHARACTER
;; #PG# (1 OF 2) MAKE CVS WORK FOR '400000000000
	JUMPGE	B,FRNP		;GO PRINT
; ACCOUNT FOR  LARGEST NEGATIVE NUMBER ('400000,0)
	MOVE	B,[=3435973836] ;34359738368 IS LARGEST NUMBER REP IN MACHINE
	MOVEI	C,"8"
	HRLM	C,(P)		;PUT ON STACK
	AOJA	A,FRNP1		;ACCOUNT FOR CHARACTER
;; #PG#

DSCR "STR"_CVOS(INTEGER);
CAL SAIL


HERE (CVOS)	PUSHJ	P,SAVE
	PUSHJ	P,CVSET
	MOVEI	D,10		;OCTAL DIVIDE
	MOVE	B,-2(P)		;GET THE DATA
	LSHC	B,-3		;MAKE SURE NUMBER BEING
	LDB	C,[POINT 3,C,2]	;DIVIDED IS + BY SIMULATING
	JRST	FRNX		; THE FIRST RESULT.

FRNP:	IDIV	B,D		;FAMOUS RECURSIVE NUMBER PRINTER
FRNX:	IORI	C,"0"
	HRLM	C,(P)
	ADDI	A,1
	JUMPE	B,BLKIN		;GO TEST FOR LEADING BLANKS
;; #PG# ! LABEL OTHER ENTRY POINT

FRNP1:	PUSHJ	P,FRNP
POPOFF:	HLRZ	C,(P)
	IDPB	C,TOPBYTE(USER)
	POPJ	P,

BLKIN:	MOVEI	D," "		;GIVE LEADING BLANKS IF WDTH POS,
	SKIPL	WDTH(USER)	; LEADING 0'S IF NEG.
	 JRST	 LEDBLK		;BLANKS
	MOVEI	D,"0"
	JUMPE	Y,LEDBLK	;NEGATIVE?
	IDPB	Y,TOPBYTE(USER)	;YES, PUT IN SIGN
	MOVEI	Y,0		;DON'T DO IT AGAIN!
LEDBLK:	CAML	A,X		;NEED MORE FILL?
	 JRST	 POPOF1		; NO
	IDPB	D,TOPBYTE(USER)	; YES, DROP IN ONE MORE
	AOJA	A,LEDBLK	;AND CONTINUE
POPOF1:	JUMPE	Y,POPOFF	;NEGATIVE, WERE FILLING BLANKS
	IDPB	Y,TOPBYTE(USER)	; YES, PUT SIGN IN AFTER BLANKS
	JRST	POPOFF		;GO PUT OUT NUMBER


FRNPDN:	HRROM	A,-1(SP)	;CHAR COUNT, NON-CONST STRING
	MOVEI	TEMP,=15	;GIVE BACK WHAT WASN'T USED
	CAMGE	TEMP,X		; (15 IF GT WDTH, ELSE WDTH
	MOVE	TEMP,X		;    USED FOR CALCULATION)
	SUB	A,TEMP
	ADDM	A,REMCHR(USER)	;UPDATE REMCHR
	JRST	RESTR


CVSET:
	SKIPE	SGLIGN(USER)	;IF ALIGNING,
	 PUSHJ	 P,INSET	; ALIGN
	MOVE	LPSA,X22
	MOVM	X,WDTH(USER)	;TOTAL FIELD SIZE, UNLESS NUMBER IS BIGGER
	MOVEI	A,=15		;CHECK THAT THERE WILL
	CAMGE	A,X		; BE ROOM FOR THE NUMBER
	MOVE	A,X		; (USE 15 OR WDTH, WHICHEVER IS BIGGER
	ADDM	A,REMCHR(USER)	
	SKIPLE	REMCHR(USER)
	PUSHJ	P,STRNGC	;NO ROOM
	MOVEI	A,0
	MOVEI	Y,0		;NOT NEG AS OF YET
	PUSH	SP,A		;A IS COUNT, SAVE STRING NO WORD SPACE
	PUSH	SP,TOPBYTE(USER);AND RESULTANT BYTE POINTER
	POP	P,D		;RETURN ADDR
	PUSH	P,[FRNPDN]	;CALLED IN-LINE FIRST TIME
	JRST	(D)



HERE (SETFORMAT)
	MOVE	USER,GOGTAB
	POP	P,TEMP		;RETURN ADDRESS
	POP	P,DIGS(USER)	;#DIGS TO RIGHT OF .
	POP	P,WDTH(USER)	;TOTAL FIELD WIDTH
	JRST	(TEMP)

DSCR GETFORMAT(@WIDTH,@DIGS);
CAL SAIL


HERE(GETFORMAT)
	MOVE	USER,GOGTAB
	MOVEW	(<@-1(P)>,<DIGS(USER)>)
	MOVEW	(<@-2(P)>,<WDTH(USER)>) ;GIVE USER RESULTS
	SUB	P,X33
	JRST	@3(P)			;RETURN

ENDCOM(CVS)

COMPIL(SCC,<SCANC>,<GETBREAK,SETBREAK,RELBREAK,SCAN>,<SCANC ROUTINE>)

DSCR
	STRING PROCEDURE SCANC(STRING ARG,BRK,OMIT,MODE); BEGIN "SCANC"
	INTEGER TBL,BRCHAR;
	TBL_GETBREAK; SETBREAK(TBL,BRK,OMIT,MODE);
	RSLT_SCAN(ARG,TBL,BRCHAR);
	RELBREAK(TBL);
	RETURN(RSLT) END "SCANC";


;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(SCANC,SCANC.)
HERE(SCANC)
	PUSHJ	P,GETBREAK;
	PUSH	P,A		;SAVE TABLE NUMBER
	PUSH	P,A		;TABLE
	PUSHJ	P,SETBREAK	;GOBBLE DOWN ALL STRINGS BUT ARG
	PUSH	P,[0]		;SPACE FOR BRCHAR;
	MOVEI	A,(SP)
	PUSH	P,A		;LOC(ARG)
	PUSH	P,-2(P)		;TABLE #
	MOVEI	A,-2(P)		;LOC(BRCHAR)
	PUSH	P,A
	PUSHJ	P,SCAN
	POP	SP,-2(SP)	;CLOBBER ARG WITH RSLT
	POP	SP,-2(SP)
	POP	P,(P)		;REMOVE BREAK CHARACTER
	PUSHJ	P,RELBREAK	;GOBBLE SAVED TABLE NUMBER
	POPJ	P,
ENDCOM(SCC)

COMPIL(SCN,<SCAN,BKTCHK>
	,<INSET,SAVE,RESTR,X44,STRNGC,SELWID,BRKMSK,CORGET>
	,<SCAN ROUTINE>)
DSCR "STR"_SCAN(@"STRING",BRKTBL,@BRCHAR);
CAL SAIL


HERE (SCAN)
..SCAN:	PUSHJ	P,SAVE
	MOVE	LPSA,X44
	SETZB	Z,@-1(P)	;result size and BREAK CHAR WORD
	SOS	X,-3(P)		;PTR TO STRING TO BE SCANNED
	HRRZ	A,(X)		;#CHARS IN INPUT STRING
	JUMPE	A,NULSCN	;IF NO CHARS TO SCAN
	MOVE	B,1(X)		;INPUT BYTE POINTER
	SKIPN	X,-2(P)		;TABLE #
	 JRST	[EXCH	X,@-3(P)	;break table zero is simple
		 PUSH	SP,X		;you just pass entire string
		 PUSH	SP,B		;and clear the result
		 JRST	RESTR]	;and return (break variable set to zero)
	MOVEI	TEMP,-1		;ERROR IF BLOCK NOT THERE OR NOT INIT'ED
	PUSHJ	P,BKTCHK	;CHECK OUT TABLE #
	 JRST	NULSCN		;ERROR OF SOME SORT
			;CHNL IS NOW 1 TO 18, CDB POINTS AT CHAR TABLE
;; FF: bits (both left and right) for how to look at bit tables
;; A: chars left to scan
;; B: byte pointer for getting characters
;; D: will hold characters as they are obtained from the input
;; C: case conversion code address (None, RAISE, or lower)
;; X(=E): location of input source
;; Y: if "token"-style scan, it is 0,,mask bit (to check for omitness)
;; Z: length of result string
;; CDB: xwd D,CHAR.TABLE  (so @CDB will get characters bits word)
;; CHNL: will hold the "bounds mask" for this table

	MOVE	FF,BRKMSK(CHNL)	;HAS BITS ON FOR THIS TABLE
	HRLI	CDB,D		;and index by D (which will be the char)
	HRRZ	X,-3(P)		;recover PTR TO STRING TO BE SCANNED
	HRRZ	Y,BKTOKN(CDB)	;get the "token-style" bit into RH
	AND	Y,FF		;only this table's bit used
;;%BK%	SEE IF WE MUST COPY
	TDNN	FF,BKOMCV(CDB)	;COPY IF OMIT CHARS or doing conversion
	 JRST	NOCPY		;otherwise, this is a substring function

	LDB	D,[POINT 6,B,=11] ;get width of result (cannot be null)
	PUSHJ	P,SELWID	;and swap in that SPC
;;***	MOVE	FF,BRKMSK(CHNL)	;HAS BITS ON FOR THIS TABLE
	ADDI	CHNL,(CDB)	;RELOCATE 1 TO 18 (for character mask)
	HRRO	CHNL,LNMSTB(CHNL)

	HRRZ	C,BKOMCV(CDB)	;check for conversion desired
	HLL	C,BKLCZR(CDB)	;including the lower case code
	AND	C,FF		;just get the bits for this table
;; C: case conversion code (0=none, 1=RAISE, 2=lower)
	TRZE	C,-1		;any conversion at all? (no makes 0)
	 TROA	C,SCN.UP	; assume RAISE (force to upper case)
	 MOVEI	C,NOCNVS	;  well, no conversion at all
	TLZE	C,-1		;does he want to go to LC?
	 MOVEI	C,SCN.DN	;yup, help him out (conversion 2)
	HRRZ	A,(X)		;get back the length

	ADDM	A,REMCHR(USER)	;WE MUST COPY THE STRING
	SKIPLE	REMCHR(USER)	;THE "OUT OF SPACE DANCE"
	 PUSHJ	P,STRNGC
	SKIPE	SGLIGN(USER)	;must we align the result?
	 PUSHJ	P,INSET		;you betchum
	PUSH	SP,A
	PUSH	SP,TOPBYTE(USER) ;RESULT BYTE POINTER
;;%SW% ! the garbage collector may get in
	MOVE	B,1(X)		;GET BYTE POINTER BACK
	HLLZ	TEMP,FF		;this just has the "break" bit

SCNLUP:	SOJL	A,ENDSCN	;STRING EXHAUSTED (no break character)
	ILDB	D,B		;GET A CHAR
	JRST	(C)		;ONLY CONVERT IF WANTED
SCN.DN:	CAIL	D,"A"		;Force to lower case
	 CAILE	D,"Z"
	  JRST	NOCNVS
	  JRST	SCNCCS
SCN.UP:	CAIL	D,"a"		;force to UPPER Case
	 CAILE	D,"z"
	  JRST	NOCNVS
SCNCCS:	  TRC	D,40		;FLIP THE CASE BIT
NOCNVS:	TDNE	D,CHNL		;well, does byte exceed table size?
	 JRST	[TDNN	FF,BKOBND(CDB)	;yup, do we break or ignore?
		  JRST	DEPOGO		;nope, just pass it on
		 TDNN	TEMP,BKOBND(CDB);is it a break?
		  JRST	SCNLUP		;not a break, must be an ignore
		 TDNE	Y,BKOBND(CDB)	;if "tokening" and is break+omit
		  JUMPE	Z,SCNLUP	;and no output yet, ignore it
		 JRST	SCNBRK]		;nope, break on it
	TDNE	FF,@CDB		;TDNE FF,BRKTBL+RLC(D)
	 JRST	 SCNSPC		;OMIT OR BREAK
DEPOGO:	IDPB	D,TOPBYTE(USER)
	AOJA	Z,SCNLUP

SCNSPC:	TDNN	TEMP,@CDB	;is it a BREAK
	 JRST	 SCNLUP		; not a break, must be OMIT
	TDNE	Y,@CDB		;if "tokening" and is break+omit
	 JUMPE	Z,SCNLUP	;and no output yet, ignore it

SCNBRK:	MOVEM	D,@-1(P)	;SET BREAK CHAR WORD
	AND	FF,BKDISP(CDB)	;WHAT DO WE DO WITH BRCHAR? 
	JUMPE	FF,ENDSCN	;nothing -- "S" mode
	TRNN	FF,-1		; 1/0 is "Append" mode
	 AOJA	Z,SCNAPN	;	APPEND TO END OF RESULT STRING
				; 0/1 is "Retain" mode
SCNRET:
KL10 <
	MOVEM	B,1(X)		;SAVE NEW SOURCE BYTE POINTER +1
	SETO	B,		;And then back up this by one
	ADJBP	B,1(X)		;leaving result in B
>;KL10
NOKL10 <;back up "normal" byte pointer one byte. Point s,l,-1 result OK
	MOVSS	TEMP,B	;remove P field from sign bit (prevent overflow)
	LSH	TEMP,6	;shift size field, SAIL strings dont index/indir
	ADDI	B,(TEMP)	;this wont carry, max sum is 44
	MOVS	B,B	;replace halves where they belong
>;NOKL10
	AOJA	A,ENDSCN	;PUT ONE BACK on source string

SCNAPN:	IDPB	D,TOPBYTE(USER)	;put break character on result string

ENDSCN:	MOVE	TEMP,Z		;#CHARS IN NEW STRING
	SUB	TEMP,-1(SP)	;NUMBER RESERVED BUT NOT USED
	ADDM	TEMP,REMCHR(USER);UNRESERVE THEM
	HRROM	Z,-1(SP)	;NOT A CONSTANT, NEW STRING SIZE
	CAIG	A,0		;IF EXHAUSTED, USE 0
	 SETZB	A,(X)		;nulls are not dynamic, clean it now
	HRRM	A,(X)		;UPDATE OLD COUNT
	MOVEM	B,1(X)		;UPDATED ORIGINAL BYTE POINTER

	SETZ	D,		;restore normal width
	PUSHJ	P,SELWID	;probably???
	JRST	RESTR		;POPJ	P,

NULSCN:	PUSH	SP,[0]		;NULL STRING RESULT ;;%BK% 
	PUSH	SP,[0]		;
	JRST	RESTR

NOCPY:	;"no copy" strings.  Fullcase and any Ignores are also Breaks.
	ADDI	CHNL,(CDB)	;RELOCATE 1 TO 18 (for character mask)
	HRRO	CHNL,LNMSTB(CHNL)
	PUSH	SP,(X)		;copy string to result (including the
	PUSH	SP,B		; "dynamic string" flag)
SCNLD2:	MOVEM	B,(SP)		;here we ignore a leading char, adv BPTR
SCNLP2:	SOJL	A,ENDSC2	;COUNT DOWN
	ILDB	D,B		;GET NEXT CHAR
	TDNE	D,CHNL		;well, does byte exceed table size?
	 JRST	[TDNN	FF,BKOBND(CDB)	;yup, do we break or ignore?
		  AOJA	Z,SCNLP2	;nope, just pass em on
		 TDNE	Y,BKOBND(CDB)	;if "tokening" and is break+omit
		  JUMPE	Z,SCNLD2	;and no output yet, ignore it
		 JRST	SCNBK2]		;must break
	TDNN	FF,@CDB		;IS BREAK CHAR ON (KNOW NOT Konv, OMIT)
	 AOJA	Z,SCNLP2	;JUST REGULAR
	TDNE	Y,@CDB		;if "tokening" and is break+omit
	 JUMPE	Z,SCNLD2	;and no output yet, ignore it

SCNBK2:	MOVEM	D,@-1(P)	;IT WAS THE BREAK CHAR
	AND	FF,BKDISP(CDB)	; FIGURE OUT WHAT TO DO WITH BRK CHR
	JUMPE	FF,ENDSC2	;NICHTS (0,0 is "Skip" mode)
	TRNN	FF,-1		;1/0 is "Append" mode
	 AOJA	Z,ENDSC2	; (just have to bump size of result)
				;0/1 is "Retain" mode
KL10 <
	MOVEM	B,1(X)		;SAVE NEW SOURCE BYTE POINTER +1
	SETO	B,		;and then back up this by one
	ADJBP	B,1(X)		;leaving result in B
>;KL10
NOKL10 <;back up "normal" byte pointer one byte. Point s,l,-1 result OK
	MOVSS	TEMP,B	;remove P field from sign bit (prevent overflow)
	LSH	TEMP,6	;shift size field, SAIL strings dont index/indir
	ADDI	B,(TEMP)	;this wont carry, max sum is 44
	MOVS	B,B	;replace halves where they belong
>;NOKL10
	AOJA	A,ENDSC2	;& WE HAVE ONE MORE LEFT

ENDSC2:	HRRM	Z,-1(SP)	;save size of result
	CAIG	A,0		;NEVER PUT NEG COUNT
	 SETZB	A,(X)		;a null string (show not dynamic)
	HRRM	A,(X)		;FIX INPUT BYTE CNT
	MOVEM	B,1(X)		;NEW INPUT BYTE PTR
	JRST	RESTR		;ALL DONE
;;%BK%


DSCR BKTCHK
	Checks break table number for break table routines
	(SCAN,INPUT,TTYIN,PTYIN,BREAKSET,STDBRK)
CAL  PUSHJ P,BKTCHK
PAR	USER set up
	X    break table number
	TEMP flags
	     left half: what to do if CORGET block is not there
		0 is error, -1 is get a block
	     right half: whether table must be initialized
		0 is no, -1 is yes
SID  uses X,Y,CDB,CHNL  (also B,C if it is necessary to call CORGET)
RET  +1	error of some sort
     +2 no error.  CDB points at the character table
		   CHNL is the table number modulo 18 in the range 1:18


HERE(BKTCHK)
	JUMPE	X,.BKCKZ	; MAKE BREAKTABLE 0 A SPECIAL CASE -JFR
	ADDI	X,=17		;TABLE # NOW IN RANGE 0 THROUGH 71
	SKIPN	BKTPRV(USER)	;PRIVILEGED?
	CAIL	X,=18		;LOWEST FOR ORDINARY USERS
	CAILE	X,=71		;MAX FOR EVERYBODY
	 JRST	[SUBI	X,=17		;restore calling value for error
		 ERR <BKTCHK: Breaktable out of range: >,7
		 JRST	CPOPJ]
	JUMPL	X,.-1		;save privileged users from evil vals
	IDIVI	X,=18
	MOVEI	CHNL,1(Y)	;CHNL NOW IN RANGE 1 TO 18
	MOVE	Y,X		;SAVE FOR POSSIBLE ERROR MESSAGE
	ADD	X,USER		;RELOCATE GROUP NUMBER
	SKIPN	CDB,BKTPTR(X)	;POINTER TO COREGET BLOCK
	 JRST	.BKCKN		;BLOCK NOT THERE
	TRNN	TEMP,-1		;NEED INITIALIZATION?
	 JRST	CPOPJ1		;NO
	HRRZ	X,BKJFFO(CDB)	;INITIALIZATION BITS
	TDNN	X,BRKMSK(CHNL)	;WAS IT INIT'ED?
	 JRST	.BKCKE		;nope, give error
CPOPJ1:	AOS	(P)		;SUCCESS, SKIP RETURN
CPOPJ:	POPJ	P,

.BKCKN:	JUMPGE	TEMP,.BKCKE	;IF INIT REQ'D AND BLOCK NOT THERE, ERROR
	MOVEI	C,=128+BKTOVH	;AMOUNT TO GET
	PUSHJ	P,CORGET
	 ERR <BKTCHK: CORGET failed>
	MOVEI	CDB,BKTOVH(B)	;ADDR OF character table in block
	SETZM	(B)		;CLEAN OUT THE BREAK TABLE
	HRLI	B,(B)		;standard zeroing BLT
	HRRI	B,1(B)		;to help us start with a virgin table
	BLT	B,=127(CDB)
	MOVEI	B,LNMSTB+1(CDB)	;set the line number dispatch,,byte size
	HRLI	B,-=128		;mark group for 7-bit bytes,
	HLRZM	B,-1(B)		;  and line dispatch 0 (=Pass)
	HRLI	B,-1(B)		;set up the BLT ac
	BLT	B,LNMSTB+=18(CDB)	;for all of its break tables
	MOVEM	CDB,BKTPTR(X)	;SAVE FOR FUTURE REFERENCE
	JRST	CPOPJ1		;SUCCESS

.BKCKE:	IMULI	Y,=18	;RECONSTRUCT THE TABLE NUMBER 
	ADD	Y,CHNL	;SO WE CAN DISPLAY IT IN THE
	SUBI	Y,=18	;ERROR MESSAGE
	ERR <BKTCHK: Uninitialized break table: >,7
	POPJ	P,

.BKCKZ:	SETZ	CHNL,		;CHEAT ON "RANGE 1 TO 18"
	MOVEI	X,1(USER)
	SKIPE	CDB,BKTPTR(X)	;make sure corget block there, get ptr
	 JRST	CPOPJ1		;it was, return with success CDB+X set
	MOVE	CHNL,B		;we need to do a coreget, save B&C
	PUSH	P,C
	PUSHJ	P,.BKCKN+1	;go allocate store
	 ERR <BKTCHK: break block allocation failure on 0?>
	POP	P,C
	MOVE	B,CHNL
	MOVEI	CHNL,0		;clear chnl (we know this was 0)
	JRST	CPOPJ1		;and return success

ENDCOM(SCN)

COMPIL(CVC,<CVSIX,CVASC,CVSTR,CVXSTR,CV6STR,CVASTR>,<SAVE,RESTR,X11,X22,INSET,STRNGC,FLSCAN>
	  ,<CVSIX, CVASC, CVSTR, CVXSTR, CV6STR -- CHARACTER CONVERSION ROUTINES>)

DSCR SIXBIT INTEGER_CVSIX("STRING");
CAL SAIL

;;#LA# THIS ROUTINE USED TO CALL FILNAM

HERE (CVSIX)
	MOVEI	A,0		;WILL DPB THE SIXBIT INTO HERE
	HRRZ	TEMP,-1(SP)	;BYTE COUNT
	JUMPE	TEMP,CVSXX	;NULL
	CAILE	TEMP,6		;ONLY USE FIRST SIX CHARS
	MOVEI	TEMP,6		;
	MOVE	LPSA,[POINT 6,A];
	PUSH	P,B		;NEEDED 1 MORE AC
	MOVE	B,(SP)		;BYTE POINTER
CVSXXL:	ILDB	USER,B		;THE CHARACTER
	TRZN	USER,100	;MOVE 100 BIT TO 40
	TRZA	USER,40		;
	TRO	USER,40		;
	IDPB	USER,LPSA	;PUT AWAY
	SOJG	TEMP,CVSXXL	;LOOP
	POP	P,B		;GET BACK THE EXTRA AC
CVSXX:	SUB	SP,X22		;EXIT
	POPJ	P,

DSCR ASCII INTEGER_CVASC("STRING");
CAL SAIL


HERE (CVASC)
	PUSHJ	P,SAVE
	POP	SP,X
	POP	SP,B
	HRRZS	B		;STRING  ARG
	MOVEI	C,5
	MOVE	D,[POINT 7,A]
	MOVEI	A,0

LUP:	SOJL	B,DUNN
	ILDB	Y,X
	IDPB	Y,D
	SOJG	C,LUP		;COLLECT CHARS IN A

DUNN:	MOVEM	A,RACS+1(USER)	;RESULT
	MOVE	LPSA,X11
	JRST	RESTR

DSCR "STR"_CVSTR(ASCII INTEGER);
CAL SAIL


HERE (CVSTR)
;used to just store in String Space, but we may fiddle byte size
	PUSHJ	P,SAVE
	MOVEI	A,5
	ADDM	A,REMCHR(USER)
	SKIPLE	REMCHR(USER)
	 PUSHJ	P,STRNGC
	SKIPE	SGLIGN(USER)	;need word-aligned result?
	 PUSHJ	P,INSET		;ALIGN TO FW BDRY
	PUSH	SP,[XWD 40,5]	;BEST NON-CONSTANT STRING REP
	PUSH	SP,TOPBYTE(USER)
        MOVE    TEMP,-1(P)	;get source of characters
	ROT	TEMP,7
	IDPB	TEMP,TOPBYTE(USER)
	SOJG	A,.-2
	MOVE	LPSA,X22
	JRST	RESTR

DSCR "STR"_CVXSTR(SIXBIT INTEGER);
CAL SAIL


HERE (CVXSTR)
	PUSHJ	P,SAVE
	MOVEI	C,0			;A FLAG
CVXST1:	SKIPE	SGLIGN(USER)
	 PUSHJ	P,INSET
	MOVEI	A,6
	ADDM	A,REMCHR(USER)		;UPDATE REMAINING CHAR COUNT
	SKIPLE	REMCHR(USER)		;IS THERE ROOM FOR THIS STRING?
	 PUSHJ	 P,STRNGC		;NO, TRY TO GET IT
	PUSH	SP,[XWD 40,6]		;NON-CONST,,COUNT FOR RESULT
	PUSH	SP,TOPBYTE(USER)	;RESULT STARTS HERE
	MOVEI	A,6
	MOVE	B,[POINT 6,-1(P)]	;POINT AT INPUT SIXBIT
	
;;%BW% MAKE THIS CODE WORK FOR CV6STR TOO
CVXLP:	ILDB	TEMP,B			;GET A SIXBIT CHAR
	JUMPE	C,CVXST2
	JUMPE	TEMP,CVXST3
CVXST2:	ADDI	TEMP,40			;CONVERT TO ASCII
	IDPB	TEMP,TOPBYTE(USER)	;PUT IN RESULT STRING, UPDATE TOPBYTE
	SOJG	A,CVXLP			;DO IT ALL
CVXST3:	MOVN	A,A			;MAKE REMCHR HONEST
	ADDM	A,-1(SP)		;AS WELL AS BYTE CNT IN STRING
	ADDM	A,REMCHR(USER)
	
	MOVE	LPSA,X22		;REMOVE ARG, RETURN ADDRESS
	JRST	RESTR			;AND RETURN

DSCR "STR"_CV6STR(SIXBIT INTEGER);
CAL SAIL
DES LIKE CVXSTR BUT STOPS ON SPACE.


HERE(CV6STR)
	PUSHJ	P,SAVE
	MOVEI	C,1
	JRST	CVXST1

DSCR "STR"_CVASTR(INTEGER)
CAL SAIL
DES LIKE CVSTR BUT STOPS ON A NULL CHARACTER


HERE(CVASTR)
	PUSHJ	P,SAVE
	MOVEI	A,5			;BE SURE HAVE ENOUGH ROOM
	ADDM	A,REMCHR(USER)
	SKIPLE	REMCHR(USER)
	PUSHJ	P,STRNGC
	PUSH	SP,[XWD 40,5]		;STERILE STRING CNT WD
	PUSH	SP,TOPBYTE(USER)	;WHAT THE DESCR WILL BE
	MOVE	4,-1(P);		;
	MOVEI	5,0			;
	MOVNI	A,5			;
	MOVE	TEMP,[POINT 7,4]	;
CVALP:	ILDB	C,TEMP			;PICK UP A CHARACTER
	JUMPE	C,CVALDN		;DONE WHEN SEE NULL
	IDPB	C,TOPBYTE(USER)		;PUT IT DOWN
	AOJA	A,CVALP	
CVALDN:					;CORRECT REMCHR
	ADDM	A,REMCHR(USER)
	ADDM	A,-1(SP)		;AND STRING DESCR
	MOVE	LPSA,X22		;RETURN
	JRST	RESTR

ENDCOM(CVC)


COMPIL(CVL,<CVFIL>,<SAVE,RESTR,X22,X33,FILNAM,.SKIP.>,<CVFIL>)

DSCR SIXBIT INTEGER_CVFIL("FILE STRING",@RESULT EXTENSION,@RESULT PPN);
CAL SAIL


HERE (CVFIL)
	PUSHJ	P,SAVE
	SETZM	.SKIP.		;ASSUME NO PROBLEMS
	PUSHJ	P,FILNAM	;GET FILENAME COMPONENTS FROM STRING ARG
	SETOM	.SKIP.		;NO GOOD SPEC, REPORT IF HE'S INTERESTED
	MOVE	TEMP,FNAME(USER)
	MOVEM	TEMP,RACS+1(USER)	;MAJOR RESULT (NAME) TO R1
	MOVE	TEMP,FNAME+1(USER)
	MOVEM	TEMP,@-2(P)		;EXTENSION TO REF ARG.
	MOVE	TEMP,FNAME+3(USER)
	MOVEM	TEMP,@-1(P)		;PPN TO REF ARG.
SFDS< ;;=I09=	IF SFD POINTER, SET .SKIP. = 1, FOR OLD PROGRAMS
	SKIPE	.SKIP.		;IF REAL ERROR, DON'T DO THIS
	 JRST	.+4
	JUMPE	TEMP,.+3
	TLNN	TEMP,777777	;IF NOT REAL PPN
	AOS	.SKIP.		;SET .SKIP. = 1
> ;SFDS
	MOVE	LPSA,X33
	JRST	RESTR
ENDCOM(CVL)


COMPIL(BRK,<BREAKSET,SETBREAK>
	,<SAVE,RESTR,BRKMSK,BKTCHK,CORINC,CORGET,CORREL,X22,X33>
	,<BREAKSET, SETBREAK ROUTINES>)
DSCR BREAKSET(TABLE #,"STRING",WAY);
CAL SAIL


HERE(BREAKSET)
	PUSHJ	P,SAVE		;SAVE ACS AND THINGS
	MOVE	LPSA,X33
	SUB	SP,X22		;take arg off stack for later restore
	MOVE	X,-2(P)		;TABLE #
	MOVSI	TEMP,-1		;GET BLOCK IF NOT THERE, NO NEED TO INIT
	PUSHJ	P,BKTCHK	;CHECK OUT TABLE #
	 JRST	RESTR		;ERROR RETURN
	MOVE	B,BRKMSK(CHNL)	;BITS FOR THIS TABLE
	IORM	B,BKJFFO(CDB)	;MARK THIS TABLE RESERVED & INIT'ED
	HLLZS	B		;LEFT HALF ONLY
	ADD	CHNL,CDB	;RELOCATE RANGE 1-18
	MOVE	X,-1(P)
	TDNE	X,[XWD -1,-200]	;make sure no stray bits were specified
	 JRST	ILLGLC
	CAIL	X,"a"
	 SUBI	X,"a"-"A"	;was lower case, fix it
	MOVEI	C,[;line number disposition (only group OK for table 0)
		 XWD 400000+"P",PASLINS	;P:Pass line numbers as text
		 XWD 400000+"N",NOLINS	;N:Nolines, ignore line numbers
		 XWD 400000+"L",BRKLIN	;L:Linenumber break,then as text
		 XWD 400000+"E",ERMAN	;E:Erman break and ignore
		 XWD 400000+"D",RESTR	;D: obsolete (display)
		;break specification
		   XWD	"I",INCL	;I:Inclusive breaks specified
		   XWD	"X",XCLUDE	;X:eXclusive breaks specified 
		;omit specification
		   XWD	"O",OMIT	;O:Omits by Inclusion
		   XWD	"U",UNOMIT	;U:Un-omits (omit by exclusion)
		;conversions desired
		   XWD	"F",FCASE	;F:full Character Set
		   XWD	"K",UCASE	;K:Konvert to UPPER case
		   XWD	"C",LCASE	;C:Coerce to lower case
		   XWD	"Z",ZSET	;Z:JFR- to let INPUT handle NULs
		;break character disposition (0 has no break chars)
		   XWD	"S",SKIPCH	;S:Skip break (drop on floor)
		   XWD	"R",RETCH	;R:Retain break for next time
		   XWD	"A",PENDCH	;A:Append break to result
		;"tokenizing" what to do on initial break+omits
		   XWD	"T",TOKNON	;T:Token-style (ignore them)
		   XWD	"B",TOKNOF	;B:Break-style (they are breaks)
		   0]
CMDCHK:	SKIPN	TEMP,(C)	;get command list entry
	 JRST	SIZTST		; -- ran out, see if size specification
	TLC	TEMP,(X)	;invert bits for command character
	TLNE	TEMP,377777	;well, is it zero (command match)?
	 AOJA	C,CMDCHK	;  -- nope, loop for another command
	JUMPL	TEMP,(TEMP)	;sign bit on means OK for channel 0
	JUMPN	B,(TEMP)	;non-0 break tables use all operations
	CAI	X,		;provide Ac for error code
ILLGL0:	ERR <WARNING: Useless BREAKSET for break table 0>,7
	JRST	RESTR

SIZTST:	CAIL	X,"0"	;digits are "set break table size" commands
	 CAILE	X,"9"	;set break table for N-bit bytes
	  JRST	ILLGLC	;well, must not be a legal command
	JUMPE	B,ILLGL0	;makes no sense for byte size 0
	MOVNI	D,1		;get the mask that he means to use
	LSH	D,-"0"(X)
	HRRO	A,LNMSTB(CDB) ;get break GROUP table size
	CAMG	A,D		;make sure group can hold the new table
	 JRST	ROOM		;well, folks, got the room
	MOVN	C,D		;get size desired for block
	ADDI	C,BKTOVH
	PUSH	P,B		;save the table bit
	MOVEI	B,-BKTOVH(CDB)	;get to base of CORGET BLOCK
	PUSHJ	P,CORINC	;expand it to new size if possible
	 JRST	[;...cant expand, must replace
		 PUSHJ	P,CORGET	;allocate a new block
		  ERR <Cant get enough room for expanded break table>,0
		 ADDI	B,BKTOVH	;fiddle offset for break table
		 MOVEI	X,(USER)	;figure out where the table goes
		 HRLI	X,-4		;by running down the table list
		 CAME	CDB,BKTPTR(X)	;looking for the old entry
		  AOBJN	X,$.-1
		 JUMPG	X,[ERR <Missing GOGTAB entry for break table>,0]
		 MOVEI	TEMP,-BKTOVH(B)	;set up BLT ac to copy table
		 HRLI	TEMP,-BKTOVH(CDB) ;from old block
		 SUBM	B,A		;copy old length worth of words
		 BLT	TEMP,(A)
		 SUBI	CHNL,(CDB)	;make CHNL block-relative
		 ADDI	CHNL,(B)	;point CHNL into new block
		 EXCH	B,CDB		;new break table GROUP now
		 HRRM	D,LNMSTBL(CDB)	;new length of the break GROUP
		 MOVEM	CDB,BKTPTR(X)	;mark new block as authentic
		 HRRZI	B,-BKTOVH(B)	;get the address of old block
		 PUSHJ	P,CORREL	;and release its storage
		 JRST	.+1]		;now we have enough room
	POP	P,B		;recover table bit
ROOM:	HRRO	C,LNMSTB(CHNL)	;get this breaktables previous size
	HRRM	D,LNMSTB(CHNL)	;store the new size for the table
	CAMN	C,D		;do we need to change the table?
	 JRST	RESTR		;no change needed, get out
	CAMG	C,D		;do we need to shrink the table?
	 JRST	SHRINK		;yup, the OMIT speedup may change
	HLR	B,B		;we will need both bits to copy omit/brk
	MOVE	FF,B
	AND	FF,BKOBND(CDB)	;get behaviour desired for outabounders
	SUB	CDB,C		;advance CDB by size of good table data
	SUB	D,C		;calculate -remaining table entries
	HRL	CDB,D		;now we have an AOBJN pointer
OB.COP:	ANDCAM	B,BRKTBL(CDB)	;clear the bits for this table
	IORM	FF,BRKTBL(CDB)	;and set the ones we want on
	AOBJN	CDB,OB.COP
	JRST	RESTR
SHRINK: ;here we have clipped a break table, re-calculate OMIT speedup
	;the bit is on if any "omit"s in the table
	MOVS	FF,B		;get the "omit" bit
	TDNE	B,BKOMCV(CDB)	;if none on before, shrink wont add any
	 TDNE	FF,BKOBND(CDB)	;if outabounds are omits, still OMITS
	  JRST	RESTR		;in either case, just leave bit alone
	MOVE	C,CDB		;get the table base for omit check
	HRL	C,D		;run for full length of new table
CHKOMT:	TDNE	FF,BRKTBL(C)	;if we encounter an OMIT
	 JRST	RESTR		;then bit stays on
	AOBJN	C,CHKOMT	;loop while table left
	ANDCAM	B,BKOMCV(CDB)	;no omits, clear out the bit
	JRST	RESTR

ILLGLC:	CAI	X,	;provide original value for error message
	ERR <ILLEGAL COMMAND TO BREAKSET>,7
	JRST	RESTR

UNOMIT:	IORM	B,BKOMCV(CDB)	;assumes at least one char specified
;;23-SEP-81 by SDD following was accidentally MOVSS B,
	MOVSS	B		;actual table is on the RH
	JRST	XCLUDE
OMIT:	HRRZ	A,1(SP)		;SET BIT ONLY IF HAVE SOME OMIT CHARS
	IORM	B,BKOMCV(CDB)	;ASSUME HAVE SOME
	CAIN	A,0		;HAVE ANY
	 ANDCAM	B,BKOMCV(CDB)	;NO
	MOVSS	B		;OMIT HAS BIT IN RH WITHIN TABLE
INCL:	SKIPA	C,[ANDCAM B,(D)]  ;USUAL CLEARING INSTR
XCLUDE:	 MOVSI	C,(<IORM B,(D)>)  ;EXCLUSION MEANS YOU FIRST SET TO ONE
	HRRI	C,BRKTBL(CDB)	;base of character table
	HRRO	CHNL,LNMSTB(CHNL) ;get valid characters mask for table
	SETCM	D,CHNL		;and make D the largest valid character
BRKLUP:	XCT	C		;CLEAR (OR SET) PROPER TABLE BIT(S)
	SOJGE	D,BRKLUP	;this sets up the background pattern
	MOVEI	D,BKOBND-BRKTBL	;also the "outabounds characters"
	XCT	C
	TLC	C,(<IORM>  <ANDCAM>)  ;rest is foreground setting
	HRRZ	A,1(SP)		;LENGTH OF STRING
	MOVE	X,2(SP)		;BYTE POINTER
	JRST	BRKL2
BRKL1:	ILDB	D,X		;GET A CHAR
	TDNE	D,CHNL		;beyond range of table?
	 MOVEI	D,BKOBND-BRKTBL	;then set as outabounds character
	XCT	C		;DO RIGHT THING TO RIGHT BIT
BRKL2:	SOJGE	A,BRKL1		;JFR- IF "I" OR "X" THEN CLEAR "Z"
	HLRZ	B,B		;B= IF "O" THEN 0 ELSE BIT in RH
	ANDCAM	B,BKLCZR(CDB)	;CLEAR "Z" if B non-zero
	JRST	RESTR


PASLINS: TDZA	B,B		;PASS LINE NOS. SINE COMMENT
NOLINS:	MOVEI	B,2		;"Ignore" (drop) line numbers
	HRLM	B,LNMSTB(CHNL)	;save in Line number disposition
	JRST	RESTR

BRKLIN:	SKIPA	B,[1]		;MARK BREAK ON LINE NOS. FOR THIS TBL
ERMAN:	 MOVEI	B,3		;3 means ERMAN'S SCHEME
	HRLM	B,LNMSTB(CHNL)	;save in Line number disposition
	JRST	RESTR

PENDCH:	HLLZ	D,B	;"Append" - APPEND TO END OF INPUT (=1/0)
	JRST	RETCH+1
SKIPCH:	TDZA	D,D	;"Skip" - CHAR NOT SEEN IN INPUT STRING (=0/0)
RETCH:	 HLRZ	D,B	;"Retain" - RETAIN FOR NEXT TIME (=0/1)
	HLR	B,B		;begin by clearing both bits
	ANDCAM	B,BKDISP(CDB)	;turn off both bits
	IORM	D,BKDISP(CDB)	;then turn on the desired bits
	JRST	RESTR

UCASE: ;"Konvert" - Upper case convert
	ANDCAM	B,BKLCZR(CDB)	;clears "conversion is to lower case"
	MOVSS	B		;and sets "conversion required"
	IORM	B,BKOMCV(CDB)
	JRST	RESTR

LCASE: ;"Lowercase" -- Lower case convert [NOTE: not yet accessible]
	IORM	B,BKLCZR(CDB)	;sets "conversion is to lower case"
	JRST	UCASE+1		;and sets "conversion required"

FCASE: ;"Fullcase" - do not convert case
	ANDCAM	B,BKLCZR(CDB)	;clears "conversion is to lower case"
	MOVSS	B		;and clears "conversion required"
	ANDCAM	B,BKOMCV(CDB)
	JRST	RESTR

ZSET:	MOVSS	B	;"Z mode" - believe break table about 0 on input
	IORM	B,BKLCZR(CDB)
	JRST	RESTR

TOKNON:	;"Token-style" ignore any leading chars that are Break and Omit
	MOVSS	B
	IORM	B,BKTOKN(CDB)
	JRST	RESTR

TOKNOF:	;"Break-style" chars that are Break and Omit always break
	MOVSS	B
	ANDCAM	B,BKTOKN(CDB)
	JRST	RESTR

COMMENT \Setbreak 

  TBL IS AS IN BREAKSET
  BRKSTRNG IS USED FOR ANY "I" OR "X" APPEARING IN MODESTRNG
  OMITSTRNG (IF NOT NULL) IS USED TO SET THE "OMIT" SIDE OF THE TABLE
  MODESTRNG CAN CONTAIN ANY OF THE VALID BREAKSET "MODE" CHARACTERS
     I,X,O,N,R,A,P, or S or K,C or F.
	[note: mode O will do extremely funny things, no way to clear]
This function is not attainable by the user unless he declares it.
\

DSCR SETBREAK(TABLE,"BREAKSTRING","OMITSTRING",MODESTRING");
CAL SAIL

HERE (SETBREAK)
;;SDD check omits last to allow "8" and so on for mask setting
	HRRZ	TEMP,-1(SP)		;COUNT OF # OF COMMANDS
	SOJL	TEMP,MAYOMT		;skip loop if no commands
BKSLUP:	HRRM	TEMP,-1(SP)		;	
	ILDB	TEMP,(SP)		;COMMAND := LOP(MODESTRING)
	PUSH	P,-1(P)			;TABLE #
	PUSH	P,TEMP			;COMMAND
	CAIE	TEMP,"U"
	 CAIN	TEMP,"u"
	  JRST	[PUSH	SP,-3(SP)	;Un-omit uses the "OMIT" string
		 PUSH	SP,-3(SP)	;in the BREAKSET
		 SETZM	-5(SP)		;and then clears it
		 JRST	BKS1GO]		;(to prevent the final OMIT)
	PUSH	SP,-5(SP)
	PUSH	SP,-5(SP)		;STRING TO USE IF NECESSARY
BKS1GO:	PUSHJ	P,BREAKSET
	HRRZ	TEMP,-1(SP)		;COUNT OF # OF COMMANDS
	SOJGE	TEMP,BKSLUP	;repeat loop until no commands left

MAYOMT:	HRRZ	TEMP,-3(SP)		;DO OMIT STRING, IF PRESENT
	JUMPE	TEMP,BKSDUN		;NULL STRING DOESN'T COUNT
	PUSH	P,-1(P)			;TABLE #
	PUSH	SP,-3(SP)		;OMIT CHARACTERS
	PUSH	SP,-3(SP)
	PUSH	P,["O"]			;OMIT!
	PUSHJ	P,BREAKSET		;DO THAT

BKSDUN:	SUB	SP,[XWD 6,6]
	SUB	P,X22
	JRST	@2(P)
ENDCOM(BRK)

COMPIL(SBK,<STDBRK>,<.SKIP.,OPEN,LOOKUP,GOGTAB,BKTCHK,ARRYIN,WORDIN,RELEASE,X22>,<STDBRK>)
IFE ALWAYS,<
TENX<
EXTERNAL $OSTYP
>;TENX
>;IFE ALWAYS

DSCR STDBRK(CHANNEL);
CAL SAIL

HERE(STDBRK)
	PUSH	P,-1(P)			;CHANNEL
	GSYSIN
	PUSH	SP,STDBDV(SYSIND)	;Pick up file name [BKTBL.BKT]
	PUSH	SP,STDBDV+1(SYSIND)	;(sysind=0 for TENEX, 2 for 20) 
	PUSH	P,[14]			;MODE 14
	PUSH	P,[2]			;INPUT BUFFERS
	PUSH	P,[0]			;OUTPUT BUFFERS
	PUSH	P,[0]			;COUNT
	PUSH	P,[0]			;BRCHAR
	PUSH	P,[.SKIP.]		;EOF
	SETOM	.SKIP.			;[CLH] handle errors (was SETZM)
	PUSHJ	P,OPEN			;OPEN CHANNEL
	SKIPE	.SKIP.			;ERROR?
	  ERR	<Can't open STDBRK channel>,1,STDEXT
	PUSH	P,-1(P)
	GSYSIN
	PUSH	SP,STDBFL(SYSIND)	;Pick up file name [BKTBL.BKT]
	PUSH	SP,STDBFL+1(SYSIND)	;(sysind=0 for TENEX, 2 for 20) 
	PUSH	P,[.SKIP.]
	SETZM	.SKIP.
	PUSHJ	P,LOOKUP
	SKIPE	.SKIP.
	  ERR	<Can't lookup STDBRK file>,1,STDEXT
	PUSH	P,-1(P)		;CHANNEL
	PUSHJ	P,WORDIN	;read the file type/version number
	CAME	A,STDBVN	;is it the correct format
	 JRST	[CAI	A,	;for the error message
		 ERR <Invalid version of STDBRK file >,7
		 JRST	STDEXT]
	MOVE	USER,GOGTAB
	MOVEI	X,1		;ORDINARY USER TABLE #
	SKIPE	BKTPRV(USER)	;PRIVILEGED?
	 MOVNI	X,1		;YES [SDD was 0, but want a priv number]
	MOVSI	TEMP,-1		;GET BLOCK IF NOT THERE, NO NEED TO INIT
	PUSHJ	P,BKTCHK	;CHECK OUT SITUATION
	 JRST	STDEXT		;ERROR OF SOME SORT
	MOVEI	CDB,LNMSTB(CDB)	;read in block for break tables
	PUSH	P,-1(P)		;CHANNEL
	PUSH	P,CDB		;WHERE TO PUT IT
	PUSH	P,[=128-LNMSTB]	;HOW MUCH TO READ
	PUSHJ	P,ARRYIN	;READ IN ARRAY
	PUSH	P,-1(P)			;CHANNEL
	PUSH	P,[0]			;dont CLOSE INHIBIT
	PUSHJ	P,RELEASE		;RELEASE THE FILE
STDEXT:
	SUB	P,X22			;CLEAR STACK
	JRST	@2(P)
STDBVN: SIXBIT /TYMSHR/		;as good a key as any
STDBFL: BKTFIL				;DEFINED IN HEAD
STDBDV:	BKTDEV				;ALSO DEFINED IN HEAD
ENDCOM(SBK)


COMPIL(ABK,<GETBREAK,RELBREAK>,<SAVE,RESTR,BKTCHK,BRKMSK,CORREL,X11,X22>
,<BREAK TABLE ALLOCATION>)
DSCR GETBREAK
    returns the number of a free break table
CAL  SAIL

HERE (GETBREAK)
	PUSHJ	P,SAVE
	MOVSI	D,-4			;PRESUME, SEARCH ALL 4 GROUPS
	HRRI	D,BKTPTR(USER)		;STARTING AT FIRST GROUP
	SKIPN	BKTPRV(USER)		;PRIVILEGED?
	 AOBJN	D,.+2			;NO, advance pointer
	TDZA	A,A			;INITIALIZE RESULT for priv
	 MOVEI	A,=18			;INITIALIZE RESULT for normal
GTBK02:	SKIPN	CDB,(D)		;POINTER TO GROUP OF 18 TABLES
	 JRST	GTBK18		;NO POINTER, SO WHOLE BLOCK OF 18 FREE
	SETCM	B,BKJFFO(CDB)	;GET RESERVATION WORD
	TRZ	B,-1		;CHECK ONLY RESERVATIONS, NOT INIT'S
	JFFO	B,GOTBGO	;FIND FIRST UNRESERVED TABLE
				;ALL 18 RESERVED if JFFO stays still
	ADDI	A,=18
	AOBJN	D,GTBK02		;TRY NEXT GROUP OF 18
GTBKF:	MOVNI	A,1			;FAILURE
	JRST	GTBKF2

GOTBGO:	ADD	A,C			;FOUND ONE
	ADDI	C,1
GTBKRT:	MOVE	B,BRKMSK(C)	;make a virgin table (get bits to clear)
	ANDCAM	B,BKJFFO(CDB)	;CLEAR RESERVED, INIT'd
	ANDCAM	B,BKLCZR(CDB)	;clear "conversion is LC", "Z" mode
	ANDCAM	B,BKOMCV(CDB)	;clear the "Omit" speedup, "Conversion"
	ANDCAM	B,BKDISP(CDB)	;set the break handling mode to "S"
	ANDCAM	B,BKTOKN(CDB)	;set the break+omit handling mode to "B"
	ANDCAM	B,BKOBND(CDB)	;outabounds entries are "normal"
	HLLZ	B,B		;RESERVE THIS TABLE
	IORM	B,BKJFFO(CDB)	;(but dont INIT it)
	ADDI	C,(CDB)		;RELOCATE 1 TO 18
	HRL	CDB,LNMSTB(CDB)	;get character mask for group
	TLO	CDB,-=128	;and OR in to make 7-bit minimum
;*** WARN: may need to expand table here if any of XWD 177,0 are on
	HLRZM	CDB,LNMSTB(C)	;store line disp=0 (Pass), mask
				;note the dandy AOBJN pointer in CDB
;;23-SEP-81 by SDD following was accidentally HRLI B,(B)
	HLR	B,B			;BIT IN EACH HALF
	ANDCAM	B,BRKTBL(CDB)		;ZAP!
	AOBJN	CDB,.-1			;until we run out of table
GTBKF2:	SUBI	A,=17		;ADJUST FOR INITIAL OFFSET
	MOVEM	A,RACS+A(USER)	;RESULT
	MOVE	LPSA,X11
	JRST	RESTR		;DONE

GTBK18:	MOVE	X,A			;TABLE NUMBER
	SUBI	X,=17			;CORRECT
	MOVSI	TEMP,-1			;CALL CORGET, NO INIT CHECK
	PUSHJ	P,BKTCHK
	 JRST	GTBKF			;ERROR RETURN
	MOVE	C,CHNL
	JRST	GTBKRT

DSCR RELBREAK
      release a break table
CAL SAIL


HERE (RELBREAK)
	PUSHJ	P,SAVE
RLBK01:	MOVE	X,-1(P)			;TABLE #
	jumpe	x,rlbkrt	;dont cause trouble by releasing 0
	ADDI	X,=17		;NEG TAB NUMS FOR PRIV USERS CAUSE PROBS
	SKIPN	BKTPRV(USER)	;PRIVILEGED?
	CAIL	X,=18		;LOWEST FOR ORDINARY USER
	CAILE	X,=71		;MAX FOR EVERYBODY
	 JRST	RLBKRT		;RELEASE ALWAYS WORKS
	IDIVI	X,=18
	MOVEI	A,1(Y)		;A NOW IN RANGE 1 TO 18
	ADD	X,USER		;RELOCATE GROUP NUMBER
	SKIPN	B,BKTPTR(X)	;B GETS POINTER TO CORRECT TABLE GROUP
	 JRST	RLBKRT		;NON-FATAL ERROR
	MOVE	TEMP,BRKMSK(A)	;BITS FOR THE TABLE
	ANDCAB	TEMP,BKJFFO(B)	;UNRESERVE, DE-INIT
	JUMPN	TEMP,RLBKRT	;IF STILL SOME RESERVED
	SETZM	BKTPTR(X)	;THIS GROUP DEFUNCT
	MOVEI	B,-BKTOVH(B)	;get to base of CORGET BLOCK
	PUSHJ	P,CORREL	;RELEASE BLOCK POINTED TO BY  B
RLBKRT:	MOVE	LPSA,X22	
	JRST	RESTR

ENDCOM(ABK)
COMPIL(PRN,<$PRINT,$$PRIN,SETPRINT,GETPRINT,$PINT,$PREL,$PITM,$PSET,$PLST,$PREC,$PSTR,$PLRL>
	,<GOGTAB,X22,OUT,OUTSTR,INCHWL,OPEN,GETCHAN,ENTER,.SKIP.,RELEASE,CAT,GETFOR,SETFOR,CATCHR,CVIS,X33,CVS,CVG,CVEL>
	,<STRING PRINTING ROUTINE>)


COMMENT $print

NOTTTY __ 400000		; WANT PRINT OUTPUT TO THE TELETYPE
WNTFLE __ 200000		; WANT PRINT OUTPUT TO A FILE
HAVFLE __ 100000		; HAVE A FILE FOR OUTPUT
WNTTTY __ 000000		; DONT WANT ANY OUTPUT AT ALL

;;%BF% GENERAL STRING OUTPUT ROUTINE

BEGIN STRPRN
;; CONTROL BITS:
UROUTB __ 400000		; IF ON THEN JRST (CTRL)
RTNSTR __ 200000		; IF ON THEN RETURN(S) ELSE RETURN (NULL)
TTYYES __ 100000		; IF ON THEN ALWAYS DO OUTSTR
TTYNOT __ 040000		; IF ON THEN DONT OUTSTR UNLESS TTYYES ON
CHNSPC __ 020000		; IF ON THEN RH(CTRL) IS CHANNEL (OR JFN)
CHNNOT __ 010000		; IF ON THEN DO NOT PUT OUT ANYTHING ON DEFAULT
				; CNANNEL

;ALSO THERE IS A WORD PRNINF(USER) THAT CONTAINS SOME "DEFAULTS"

DSCR STRING PROC $PRINT("S",CTRL(0))

DES	ROUTINE (ROUGHLY) IS:

	BEGIN
	I_PRNINF(USER);
	IF UROUTB LAND CTRL THEN JRST @RH(CTRL);
	IF UROUTB LAND I THEN JRST @RH(I);
$$PRIN: COMMENT THE ENTRY POINT AFTER TRAPPING OUT TO THE USER;
	IF (TTYYES LAND CTRL) THEN 
		OUTSTR(S)
	ELSE IF NOT (TTYNOT LAND CTRL) THEN
		BEGIN
		IF NOT ( (TTYYES!TTYNOT) LAND I) THEN
			<SET TTY DEFAULTS>;
		IF TTYYES LAND I THEN OUTSTR(S);
		END;
	IF CHNSPC LAND CTRL THEN OUTF(RH(CTRL),S);
	IF NOT (CHNNOT LAND CTRL) THEN
		BEGIN
		IF NOT ( (CHNNOT!CHNSPC) LAND I) THEN
			<SET OUTPUT CHANNEL DEFAULTS>;
		IF CHNSPC LAND I THEN OUTF(RH(I),S);
		END;
	IF RTNSTR LAND CTRL THEN RETURN(S) ELSE RETURN(NULL);
	END;


;; $PRINT ACTUAL CODE

HERE($$PRIN)
	TDZA	A,A
HERE($PRINT)
	MOVEI	A,1
	MOVE	C,-1(P)		;CONTROL BITS
	MOVE	USER,GOGTAB	;
	MOVE	B,PRNINF(USER)	;"DEFAULT" BITS
	JUMPE	A,SPRN.1	;CAME FROM STRPR1?
	TLNE	C,UROUTB	;USER ROUTINE?
	JRST	(C)		;YES
	TLNE	B,UROUTB	;USER SPEC ONE HERE?
	JRST	(B)		;YES

SPRN.1:			;STRPR1 COMES IN HERE
	TLNE	C,TTYYES	;DID HE DEMAND OUTSTR?
	JRST	.OSTRC		;YES
	TLNE	C,TTYNOT	;DID HE DEMAND NOT?
	JRST	SPRN.3		;YES
	TLNN	B,TTYNOT!TTYYES ;IS A DEFAULT ESTABLISHED?
	PUSHJ	P,PDFSET	;NO, DO SO
SPRN.2:	TLNN	B,TTYYES	;DOES HE WANT IT?
	JRST	SPRN.3		;NO
.OSTRC:	PUSH	SP,-1(SP)	;
	PUSH	SP,-1(SP)	;
	PUSHJ	P,OUTSTR	;OUTSTR(S);
SPRN.3:	TLNE	C,CHNSPC	;SPECIFIED CHANNEL?
	JSP	D,OUTFN		;OUT(SPEC CHAN,S);
	JUMP	(C)		;EFFECTIVE ADDRESS IS CHANNEL NO
SPRN.4:	TLNE	C,CHNNOT	;DID HE SAY THAT IS ALL?
	JRST	SPRN.5		;YES
	TLNN	B,CHNNOT!CHNSPC	;DEFAULTS SET YET?
	PUSHJ	P,PDFSET	;NOPE DO IT NOW
	TLNE	B,CHNSPC	;CHANNEL SPECIFIED NOW?
	JSP	D,OUTFN		;OUTPUT FUNCTION
	JUMP	(B)		;PASS CHANNEL NUMBER THIS WAY
SPRN.5:	TLNN	C,RTNSTR	;DID WE WANT S KEPT?
	SETZM	-1(SP)		;RETURN A NULL INSTEAD OF S
	SUB	P,X22		;RETURN
	JRST	@2(P)		;

OUTFN:	MOVEI	A,@(D)		;GET CHANNEL NUMBER
	PUSH	P,A		;PUSH IT
	PUSH	SP,-1(SP)	;
	PUSH	SP,-1(SP)	;COPY IS LIKELY FOOLISH
	PUSHJ	P,OUT		;
	JRST	1(D)		;RETURN --RELY ON OUT TO SAVE ACS

PDFSET:	PUUO	3,[ASCIZ/
$PRINT called without initialization.
Output to teletype?/]
	MOVSI	B,TTYYES!CHNNOT	;INITIALLY, ASSUME TTYON
	PUSHJ	P,$YN
	 MOVSI	B,TTYNOT!CHNNOT	;NO WE DONT
	PUUO	3,[ASCIZ/Output to file?/];
	PUSHJ	P,$YN		;ASK ABOUT IT
	 JRST	OPTSET		;NO
	TLC	B,CHNNOT!CHNSPC	;YES, WE WILL
DOOP:	PUSHJ	P,GETCHAN	;CHANNEL NUMBER
	HRR	B,A		;REMEMBER HERE,TOO
	PUSH	P,A		;CHANNEL NO
	PUSH	SP,[3]		;DSK
	PUSH	SP,[ POINT 7,[ASCIZ/DSK/]]
	PUSH	P,[0]		;MODE 0
	PUSH	P,[0]		;NO INPUT
	PUSH	P,[3]		;3 OUTPUT BUFFERS
	PUSH	P,[0]
	PUSH	P,[0]
	PUSH	P,[.SKIP.]	;EOF VAR 
	SETZM	.SKIP.
OPIT:	PUSHJ	P,OPEN		;OPEN THE CHANNEL
	SKIPE	.SKIP.
	ERR	<OPEN LOST>,1,DOOP

ENIT:	PUUO	3,[ASCIZ /File Id=/]
	PUSH	P,A
	PUSHJ	P,INCHWL
	PUSH	P,[.SKIP.]
	PUSHJ	P,ENTER
	SKIPE	.SKIP.
	JRST	ENIT
OPTSET:	MOVEM	B,PRNINF(USER)
	POPJ	P,

$YN:	PUSHJ	P,INCHWL
	HRRZ	FF,-1(SP);
	JUMPE	FF,YNRET;
	ILDB	FF,(SP)
	CAIE	FF,"Y"
	CAIN	FF,"y"
	AOS	(P)		;SKIP RET IF YES
YNRET:	SUB	SP,X22
	POPJ	P,

INTERNAL P.FIN

HERE(P.FIN)
	BEGIN 	P.FIN
	MOVE	USER,GOGTAB
	SKIPE	B,PRNINF(USER)			;FIRST CLOSE $PRINT FILE
	TLNE	B,UROUTB
	  JRST	CONTIN
	TLNN	B,CHNSPC
	  JRST	CONTIN
	HRRZS	B
	PUSH	P,B
	PUSH	P,[0]
	PUSHJ	P,RELEASE
CONTIN:	SKIPE	B,PRTINF(USER)		;NOW CLOSE PRINT FILE (WOW!)
	TLNN	B,HAVFLE
	  POPJ	P,
	HRRZS	B
	PUSH	P,B
	PUSH	P,[0]
	PUSHJ	P,RELEASE
	POPJ	P,

	BEND	P.FIN

BEND STRPRN

DSCR	PRINT routines
	The SETPRINT and GETPRINT change the output conditions for
the PRINT statement (not CPRINT).
	There are three things that may be happening:  the user
may or may not have a file open, if so it may or may not be
selected for output; and the user may want output to go to the
terminal.  This makes 6 possibilites.  Each is represented by
a letter that suggests the meaning.
	Bits indicating what is happening are stored in the
left half of user table entry PRTINF; the right half contains
the channel number.  Bits indicate if the teletype is NOT selected,
if a file is open, and if the file is selected.  These are, 
symbolically, WNTTTY, HAVFLE, and WNTFLE.  Note that 0 for the entire 
word means to just use the teletype for output.  This is because the 
user table gets zeroed at the start, and so it is given the meaning
of the letter "T".


HERE(SETPRINT)
	BEGIN	SETPRINT

DEFINE TST(X,Y) <
	CAIN	D,"X"
	  MOVSI	B,Y
>;
	MOVE	USER,GOGTAB
	MOVE	TEMP,(P)
	MOVEM	TEMP,UUO1(USER)
	MOVE	D,-1(P)				;GET ARGUMENT
	CAIL	D,"a"
	CAILE	D,"z"
	  SKIPA
	  SUBI	D,40				;CONVERT TO UPPER CASE
	SETO	B,
	CAIN	D,"C"				;CONSOLE?
	  JRST	[MOVE	B,PRTINF(USER)
		TLZ	B,NOTTTY		;TURN ON TELETYPE
		 JRST	SETRET]
	CAIN	D,"I"				;IGNORE TERMINAL
	  JRST	[MOVE	B,PRTINF(USER)
		TLO	B,NOTTTY
		 JRST	SETRET]
	TST	T,WNTTTY
	TST	F,NOTTTY+WNTFLE+HAVFLE
	TST	B,WNTTTY+WNTFLE+HAVFLE
	TST	N,NOTTTY
	TST	S,NOTTTY+HAVFLE
	TST	O,WNTTTY+HAVFLE
	CAME	B,[-1]				;NOT LEGAL OPTION
	  JRST	OKSET
	PUUO	1,D				;PRINT A CHAR
	ERR	<
SETPRINT:  Above mode is not legal>,1
	MOVSI	B,WNTTTY			;FOR DEFAULT ASSUME TTY
	JRST	SETRET
OKSET:	
	MOVE	D,PRTINF(USER)			;GET OLD VALUE
	TLNE	D,HAVFLE			;IF HAVE A FILE
	TLNE	B,HAVFLE			;BUT DONT WANT IT
	  JRST	OKREL
	HRRZS	D
	PUSH	P,D
	PUSH	P,[0]				;CLOSE INHIBIT BITS
	PUSHJ	P,RELEASE			;RELEASE FILE
	JRST	SETRET				;AND RETURN
OKREL:
	TLNE	D,HAVFLE			;IF WE HAVE A FILE
	TLNN	B,HAVFLE			;AND WANT A FILE
	  JRST	CHKNEED				
	HRR	B,D				;THEN USE IT
	JRST	SETRET
CHKNEED:
	TLNN	B,HAVFLE			;WANT A FILE?
	  JRST	SETRET
NOTENX<
	HRRZ	A,-1(SP)
	JUMPG	A,.+2				;HAVE A FILE NAME?
	PUSHJ	P,GETNAME			;NEED A NAME
GETDSK:
	PUSHJ	P,GETCHAN			;GET A CHANNEL
	CAMN	A,[-1]
	  ERR	<SETPRINT:  GETCHAN failed>
	HRR	B,A				;PUT CHANNEL NUMBER IN RH(B)
	PUSH	P,A				;CHANNEL ARG
	PUSH	SP,[3]
	PUSH	SP,[POINT 7,[ASCIZ/DSK/],-1]
	PUSH	P,[0]				;MODE 0
	PUSH	P,[0]				;INPUT BUFFERS
	PUSH	P,[3]				;OUTPUT BUFFERS
	PUSH	P,[0]				;COUNT WORD
	PUSH	P,[0]				;BRCHAR
	SETZM	.SKIP.
	PUSH	P,[.SKIP.]			;END OF FILE
	PUSHJ	P,OPEN				;CALL FUNCTION
	SKIPE	.SKIP.				;A PROBLEM
	  ERR 	<SETPRINT:  OPEN to the DSK has failed>,1,GETDSK
DOENT:	PUSH	P,A				;CHANNEL
	PUSH	SP,-1(SP)
	PUSH	SP,-1(SP)			;FILE NAME
	PUSH	P,[.SKIP.]
	PUSHJ	P,ENTER
	SKIPE	.SKIP.
	  JRST	[PUUO 3,[ASCIZ/SETPRINT:  ENTER failed, type file name
/]
		 PUSHJ	P,GETNAME
		 JRST	DOENT]
	
	JRST	SETRET

GETNAME:
	PUUO	3,[ASCIZ/
File for PRINT output  */]
	PUSHJ	P,INCHWL
	POP	SP,-2(SP)
	POP	SP,-2(SP)
	POPJ	P,
>;NOTENX
TENX<
EXTERNAL OPENFILE
GETDSK:
	PUSH	P,B
	HRRZ	A,-1(SP)			;COUNT OF FILENAME
	JUMPG	A,.+2				;CHECK LENGTH
	PUUO	3,[ASCIZ/
File for PRINT output  */]
	PUSH	SP,-1(SP)
	PUSH	SP,-1(SP)			;FILE NAME
	PUSH	SP,[2]
	PUSH	SP,[POINT 7,[ASCIZ/WC/],-1]
	PUSHJ	P,OPENFILE
	POP	P,B
	HRR	B,A				;CHANNEL NUMBER
	JRST	SETRET
>;TENX

SETRET:	
	MOVEM	B,PRTINF(USER)
	SUB	SP,X22
	SUB	P,X22
	JRST	@2(P)				;RETURN
	BEND SETPRINT

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(GETPRINT,GETPR.)
HERE(GETPRINT)
	BEGIN 	GETPRINT
DEFINE TST(X,Y) <
	CAIN	TEMP,X
	  MOVEI	A,"Y"
>;
	MOVE	USER,GOGTAB
	MOVE	TEMP,(P)
	MOVEM	TEMP,UUO1(USER)
	HLRZ	TEMP,PRTINF(USER)
	SETO	A,
	TST	WNTTTY,T
	TST	NOTTTY+WNTFLE+HAVFLE,F
	TST	WNTFLE+WNTTTY+HAVFLE,B
	TST	NOTTTY,N
	TST	NOTTTY+HAVFLE,S
	TST	HAVFLE+WNTTTY,O
	CAMN	A,[-1]
	  ERR	<GETPRINT:  Illegal mode>,1
	POPJ	P,

	BEND 	GETPRINT

DSCR $PRSTR -- final string printer

PROCEDURE $PRSTR(STRING S)

Called for either PRINT or CPRINT.  Actually does the final output.

CAL	PUSHJ (EFFECTIVELY -- ACTUALLY JRST)
ARG	STRING ON SP STACK
	CHANNEL ON P STACK, -1 FOR TELETYPE
RET	THE STRING IS CLEARED FROM THE SP STACK, AND POPJ RETURN
SID	NOTHING IS SAFE IF USER ROUTINE CALLED




$PRSTR:	
	BEGIN $PRSTR

	MOVE	USER,GOGTAB
	SKIPE	TEMP,$$PROU(USER)
	  JRST	WNTOWN				;OWN OUTPUTTING FN.

PRINT1:	MOVE	TEMP,-1(P)			;GET CHANNEL NUMBER
	CAME	TEMP,[-1]			;IS IT -1?
	  JRST	WNTCHN				;NO, MUST BE A CHANNEL

	SKIPN	B,PRTINF(USER)			;SEE IF SETPRINT DONE
	  JRST	OUTSTR				;JUST DEFAULT SETPRINT, THAT'S ALL
	TLNE	B,NOTTTY			;TELETYPE WANTED?
	  JRST	NOTTY				;NO
	PUSH	SP,-1(SP)
	PUSH	SP,-1(SP)
	PUSHJ	P,OUTSTR
NOTTY:	TLNN	B,WNTFLE			;FILE WANTED?
	  JRST	[SUB	SP,X22
		 POPJ	P,]
	HRRZS	B
	PUSH	P,B
	JRST	WNTCH1

WNTCHN:	PUSH	P,TEMP				;THE CHANNEL NUMBER
WNTCH1:	PUSHJ	P,OUT				;STRING ON STACK
	POPJ	P,				;AND RETURN

WNTOWN:	PUSH	P,-1(P)				;PUSH CHANNEL NO.
	PUSHJ	P,(TEMP)			;CALL USER FUNCTION
	POPJ	P,


	BEND $PRSTR

DSCR
	These funtions are the top-level functions called from SAIL
for the PRINT and CPRINT statement, for argument types that
are passed on the P stack.  The other case, of course, is
a string value, which follows directly.
	The calls for the PRINT or CPRINT statement are generated 
by first pushing the channel number onto the P stack (-1 for Teletype),
then calling a special routine for each basic syntactic type
encountered.  After all calls for the syntactic types, the
channel is removed from the P stack, by a SUB P,[xwd 1,1] instruction
following the calls to the PRINT routines.

CAL	PRINT or CPRINT statements
ARG	standard SAIL argument passing
	CHANNEL is on the P stack, -1 if Teletype
	ARG	is on the P stack

SID	nothing saved
RES	nothing



DEFINE PMAK ! (X,Y,Z) <
HERE(X)
	MOVE	USER,GOGTAB
	MOVE	TEMP,(P)
	MOVEM	TEMP,UUO1(USER)
	PUSH	P,-1(P)			;PUSH THE ARGUMENT
	SKIPE	TEMP,Z(USER)		;USER FORMATTING FUNCTION
	   JRST	PRTOWN
	PUSHJ	P,Y			;NO, CALL STANDARD FORMATTING
	JRST	PRRET			
>;PMAK
					;FUNCTION
;CODE COMMON TO ALL PRINTING FUNCTIONS

PRTOWN:	PUSHJ	P,(TEMP)
PRRET:	POP	P,-1(P)			;SPLICE ARG OUT FROM STACK
	JRST	$PRSTR			;AND RETURN

PMAK	$PINT,CVS,$$FINT
PMAK	$PREL,CVG,$$FREL
PMAK	$PITM,PN,$$FITM
PMAK	$PSET,PSET1,$$FSET
PMAK	$PLST,PLST1,$$FLST
PMAK	$PREC,PREC,$$FREC

HERE($PLRL)
	MOVE	USER,GOGTAB
	MOVE	TEMP,(P)
	MOVEM	TEMP,UUO1(USER)
	PUSH	P,-2(P)			;PUSH THE ARGUMENT
	PUSH	P,-2(P)
	SKIPN	TEMP,$$FLRL(USER)	;USER FORMATTING FUNCTION
	 MOVEI	TEMP,CVEL		;NONE, USE STANDARD
	PUSHJ	P,(TEMP)
	POP	P,-1(P)			;SPLICE OUT ARG
	POP	P,-1(P)
	JRST	$PSTR

HERE($PSTR)
	MOVE	USER,GOGTAB
	MOVE	TEMP,(P)
	MOVEM	TEMP,UUO1(USER)
	SKIPE	TEMP,$$FSTR(USER)	;SPECIAL STRING FORMATTER?
	  PUSHJ	P,(TEMP)		;YES
	JRST	$PRSTR			;PRINT AND RETURN


DSCR	Utility routines for PRINT statement.


DSCR	PN

STRING PROCEDURE PN(ITEM X)

returns the PNAME of X if one exists, else ITEM!XXX, where XXX is the item number.
Special provision is made for the special items of the SAIL runtime system.



PN:	
	BEGIN PN
	PUSH	P,[0]			;USE STACK FOR VARIABLE
	MOVEI	A,(P)
	PUSH	P,-2(P)			;ARGUMENT X NOW
	PUSH	P,A			;ADDRESS OF FLAG
	PUSHJ	P,CVIS			;GET STRING ON STRING STACK	
	SKIPN	(P)			;FLAG OK?
	  JRST	RET			;YES OK
	SUB	SP,X22			;CLEAR OFF STACK
	MOVE	A,-2(P)			;GET ITEM NUMBER
	CAILE	A,3			;BIGGER THAN BUILTIN RANGE?
	  JRST	USENUM			;YES, USE THE NUMBER
	PUSH	SP,[3
		    6
		    6
		    12](A)
	PUSH	SP,[440700,,STRN
		    170700,,STRN
		    100700,,STRN+1
		    440700,,STRN+3](A)
	JRST	RET
USENUM:	PUSH	SP,[5]
	PUSH	SP,[POINT 7,[ASCII/ITEM!/],-1]
	PUSH	P,-2(P)			;ARGUMENT AGAIN
	PUSH	P,[-4]			;FOR ACVS
	PUSHJ	P,ACVS			;GO OFF AND DO IT
	PUSHJ	P,CAT			;CONCATENATE
RET:	SUB	P,X33			;CLEAR OFF EVERYTHING
	JRST	@2(P)			;AND RETURN


STRN:	ASCII/ANYMAINPIBINDITEVENT!TYPE/
	BEND PN

DSCR ACVS
	
STRING PROCEDURE ACVS(INTEGER I,F)

Returns the CVS representation of I by first setting the format
control to F.  Used to ensure that there are no leading spaces etc.



ACVS:
	PUSH	P,[0]
	PUSH	P,[0]
	MOVEI	A,-1(P)
	PUSH	P,A
	MOVEI	A,-1(P)
	PUSH	P,A
	PUSHJ	P,GETFORMAT		;GET FORMAT INTO STACK LOCATIONS
	PUSH	P,-3(P)			;F ARGUMENT
	PUSH	P,[0]			;DOESNT MATTER
	PUSHJ	P,SETFORMAT
	PUSH	P,-4(P)			;I ARGUMENT
	PUSHJ	P,CVS			;GET STRING ONTO STRING STACK
	PUSHJ	P,SETFORMAT
	SUB	P,X33			;CLEAR OFF STACK
	JRST	@3(P)			;AND RETURN

DSCR GODOWN
	
STRING PROCEDURE GODOWN(LIST or SET S)

CDR's down S creating a string of the PN's of the items in S.
Does not copy structure etc.  Returns the string representing
this list, sans braces, which are added in the calling function.


GODOWN:	BEGIN GODOWN

	PUSH	SP,[0]
	PUSH	SP,[0]			;PREPARE FOR STRING
	MOVE	1,-1(P)
	HRRZ	1,(1)
LOOP:	JUMPE	1,DONE
	HLRZ	2,(1)			;J _ CAR(I)
	HRRZ	1,(1)			;I _ CDR(I)
	PUSH	P,1			;SAVE
	PUSH	P,2			;SAVE
	PUSH	P,2			;ARGUMENT
	PUSHJ	P,PN			;GET STRING
	PUSHJ	P,CAT			;HOOK ON STRING
	POP	P,2			;RESTORE
	POP	P,1
	JUMPE	1,DONE			
	PUSH	SP,[2]
	PUSH	SP,[POINT 7,[ASCIZ/, /],-1]
	PUSHJ	P,CAT
	JRST	LOOP

DONE:	SUB	P,X22
	JRST	@2(P)			;RETURN
	BEND GODOWN


DSCR	PSET1  -- default formatter for sets


PSET1:	BEGIN PSET1
	SKIPN	-1(P)			;EMPTY?
	  JRST	RETPHI			;YES
	PUSH	SP,[1]
	PUSH	SP,[POINT 7,[BYTE (7) 173,173],-1]
	PUSH	P,-1(P)
	PUSHJ	P,GODOWN
	PUSHJ	P,CAT
	PUSH	SP,[1]
STANFO <
	PUSH	SP,[POINT 7,[BYTE (7) 176,176],-1]
>
NOSTANFO <
	PUSH	SP,[POINT 7,[BYTE (7) 175,175,0,0,0],-1]
>
	PUSHJ	P,CAT	
RET:	SUB	P,X22
	JRST	@2(P)
	
RETPHI:	PUSH	SP,[3]
	PUSH	SP,[POINT 7,[ASCIZ/PHI/],-1]
	JRST	RET

	BEND PSET1


DSCR	PLST1  -- default formatter for lists

PLST1:	BEGIN PLST1
	SKIPN	-1(P)				;ANYTHING THERE?
	  JRST	RETNIL				;NO
	PUSH	SP,[2]
	PUSH	SP,[POINT 7,[BYTE (7) 173,173],-1]
	PUSH	P,-1(P)
	PUSHJ	P,GODOWN
	PUSHJ	P,CAT
	PUSH	SP,[2]
STANFO <
	PUSH	SP,[POINT 7,[BYTE (7) 176,176],-1]	;STANFORD CROCK "ASCII"
>
NOSTANFO <
	PUSH	SP,[POINT 7,[BYTE (7) 175,175,0,0,0],-1]
>
	PUSHJ	P,CAT
RET:	SUB	P,X22
	JRST	@2(P)
	
RETNIL:	PUSH	SP,[3]
	PUSH	SP,[POINT 7,[ASCIZ/NIL/],-1]
	JRST	RET

	BEND PLST1

DSCR	PREC -- default printer for record pointers

PREC:	BEGIN PREC

	MOVE	3,-1(P)			;RECORD
	JUMPE	3,NULLREC		;SPECIAL FOR NULL!RECORD
	MOVE	3,(3)			;POINTER TO CLASS
	MOVE	3,5(3)			;POINTER TO WD2 OF STRING
					;DESCR FOR CLASS NAME
	PUSH	SP,-1(3)
	PUSH	SP,(3)			;STRING TO STACK
	PUSH	P,["."]
	PUSHJ	P,CATCHR
	PUSH	P,-1(P)
	PUSH	P,[0]
	PUSHJ	P,ACVS
	PUSHJ	P,CAT

RECRET:	SUB	P,X22
	JRST	@2(P)
	

NULLREC:
	PUSH	SP,[=11]
	PUSH	SP,[POINT 7,[ASCIZ/NULL!RECORD/],-1]
	JRST	RECRET


	BEND PREC

ENDCOM(PRN)

IFE ALWAYS,<
COMPIL(DM5,<P.FIN>,,<DUMMY $PRINT FINISHER>)
^^P.FIN:
	POPJ	P,
ENDCOM(DM5)
>;IFE ALWAYS


COMPIL(DVF,<CVEL>,<GOGTAB,STRNGC,SAVE,RESTR>,<LONG REAL TO STRING CONVERSION>)
;TITLE DOUBT.  V.030.0.140    DOUBLE PRECISION OUTPUT PDP-10
;SUBTTL	28-APR-71	/DMN
		;FROM	V.027U	9-NOV-70	/DMN
		;FROM	V.022- 1-DEC-69	/TWE
		;FROM V.020-APRIL 23,1969	/TWE
		;V.005  10-MAR-67

;	DOUBT. OUTPUTS ONE DOUBLE PRECISION WORD.  IT IS
;	CALLED BY 

;	PUSH	17,FMTWRD
;	MOVE	0,A
;	MOVE	1,A+1
;	PUSHJ	P,DOUBT.

;	WHERE A IS THE ADDRESS OF THE DOUBLE PRECISION WORD
;	AND FMTWRD IS A FORMAT WORD AS DESCRIBED IN FLOUT.

BEGIN CVEL
AC__0		;AC+1 IS ALSO USED
MUL__AC+1	;MUL+1 IS ALSO USED
BITS__3
IN__5
XP__4
D$__5
W__1
FR__10		;FR+1 IS ALSO USED
IGN__6	;*****
S__13
DIG__14
R__7	;*****
Q__7	;*****

NAC__15

MAXDIG__=18				; *EJG* 06/26/76
MINDIG__=9	;NO. OF DIGITS IF LS. WORD NOT SIGNIFICANT

BITNEG__40000
BITZ__100000
LZEROB__200000

ABLANK__40
APLUS__53
AMINUS__55
APOINT__56
AZERO__60
AD__104
AO__117


HERE(CVEL)
	PUSHJ	P,SAVE		;SDD: well #ZF# was almost right
ki10 <
	DMOVE	AC,-2(P)	;FETCH THE ARGUMENT
>;ki10
noki10 <
	MOVE	AC,-2(P)	;FETCH THE ARGUMENT
	MOVE	AC+1,-1(P)	;FETCH THE ARGUMENT
>;noki10
	PUSHJ	P,DOUBT.	;CONSTRUCT STRING
	MOVE LPSA,[3,,3]	;RET. WD AND LONG REAL	#ZF#
	JRST RESTR		;#ZF#
DOUBT.:
	MOVE	BITS,-1(P)	;GET FORMAT WORD
	TLZ	BITS,BITNEG+BITZ+LZEROB	;SET INDICATORS OFF
	JUMPE	AC,ZERO		;THE TRIVIAL CASE
	JUMPG	AC,POS		;IS NUMBER NEGATIVE?
ki10 <
	DMOVN	AC,AC		;YES, MAKE IT POSITIVE
>;ki10
noki10 <
	DFN	AC,AC+1		;YES, MAKE IT POSITIVE
>;noki10
	TLO	BITS,BITNEG	;REMEMBER THE MINUS
POS:	JUMPN	AC+1,POS1	;IF LS. WORD _ 0
	LDB	S,[POINT 9,AC,8] ;AND EXPONENT OF MS. WORD GT. 33
	CAIG	S,33
	TLO	BITS,LZEROB	;SET LZEROB
POS1:	MOVEI	IN,13		;TOP OF COMPARE TABLE
	MOVEI	XP,0		;INITIAL DECIMAL EXPONENT
	CAML	AC,TAB.P2	;IS NUMBER geq 1.0?
	 JRST	LUPP		;YES, BRING IT DOWN
	CAMN	AC,TAB.M1	;...
	 CAML	AC+1,TAB.M2	;...
	  CAMGE	AC,TAB.M1	;...
	   JRST	LUPM		;YES, BRING IT UP
REND:	LDB	S,[POINT 9,AC,8];GET BINARY EXP
	TLZ	AC,777000	;CLEAR EXP OUT OF FRACTION
	ASHC	AC,8-200(S)	;MOVE FRACTION TO BINAL POINT
	MOVE	FR,AC		;PLACE IN FRACTION REGISTER
	MOVE	FR+1,AC+1	;...
ZEROH:
	MOVM	D$,DIGS(USER)	;DIGITS OF SIGNIFICANCE
	MOVM	W,WDTH(USER)	;WIDTH OF FIELD
	SETZ	S,		;SCALING
	JUMPN	W,DIGITS	;IS THIS UNSPECIFIED FORMAT?
	MOVEI	D$,MAXDIG	;YES, SET TO D$<MAXDIG>+8.<MAXDIG>
	MOVEI	W,MAXDIG+=8	;...
DIGITS:
	MOVEI	1,(W)
	ADDM	1,REMCHR(USER)
	SKIPLE	REMCHR(USER)
	 PUSHJ	P,STRNGC
	PUSH	SP,[-1,,0]	;INITIAL STRING
	PUSH	SP,TOPBYTE(USER)
	
	JUMPLE	S,.+2		;+ SCALE IMPLIES D$+1 DIGITS SIGNIFICANCE
	ADDI	D$,1
	MOVM	DIG,S		;DIGITS OF SCALING
	CAILE	D$,MAXDIG	;MAXIMUM SIGNIFICANCE EXCEEDED?
	MOVEI	D$,MAXDIG	;NO IT ISN'T.
	TLZN	BITS,LZEROB	;IF LZEROB SET
	JRST	.+3
	CAILE	D$,MINDIG	;CHECK NO MORE THAN
	MOVEI	D$,MINDIG	;ONE WORD OF DIGITS
	MOVE	R,D$		;SET ROUNDING POINT
	CAMGE	DIG,D$		;MAXF (S,D$)
	MOVE	DIG,D$		;...
	HRREI	IGN,-7(W)	;W-7-DIGITS	#ZF# CHANGE 6 TO 7
	SUBB	IGN,DIG		;...
	JUMPG	S,SCAL		;IF PLUS SCALE, THEN LEFT ROUTINE


SCAR:	JUMPLE	IGN,RNBLK	;JUMP IF NO LEADING BLANKS
	TLO	BITS,LZEROB	;SPACE FOR LEADING ZERO
	SOJE	DIG,RNBLK	;JUMP IF LEADING ZERO WAS ONLY SPACE
	MOVEI	AC,ABLANK	;ASCII BLANK
	PUSHJ	P,OUTCH		;OUTPUT IT
	SOJG	DIG,.-2		;JUMP IF MORE BLANKS
RNBLK:	ADD	R,S		;ONLY ROUND ON SIGNIFICANT DIGITS
	PUSHJ	P,SGNRND	;OUTPUT SIGN AND ROUND
	MOVEI	AC,AZERO	;LEADING ZERO
	TLNE	BITS,LZEROB	;WAS THERE SPACE FOR IT?
	PUSHJ	P,OUTCH		;YES, OUTPUT
	MOVEI	AC,APOINT	;MAY THERE ALWAYS BE A DECIMAL POINT
	PUSHJ	P,OUTCH		;...
	ADD	D$,S		;SCALE FACTOR IMPLIES EXTRA ZEROS
	JUMPGE	S,OGDIG		;NOT FOR THIS NUMBER
	MOVEI	AC,AZERO	;ASCII 0
	PUSHJ	P,OUTCH		;OUTPUT
	AOJL	S,.-2		;ANY MORE ZEROS?
	JRST	OGDIG		;NO.

SGNRND:	MOVEI	AC,ABLANK	;ASCII BLANK
	TLNE	BITS,BITNEG	;WAS NUMBER -?
	MOVEI	AC,100000+AMINUS	;ASCII MINUS
	PUSHJ	P,OUTCH		;OUTPUT SIGN
	JUMPL	R,NORND		;NOT ENUF TO ROUND
	CAILE	R,MAXDIG	;PERHAPS NO ROUND REQUIRED
	JRST	NORND		;ALL DIGITS OUTPUT
				;V.005 TO V.020 ON NEXT INSTRUCTION
	TLO	FR+1,400000	;SET SIGN BIT TO AVOID OVERFLOW
			;ON NEXT ADD. RNDL ENTRIES ARE ALWAYS .GE.0
	ADD	FR+1,RNDL(R)	;LO ORDER ROUND
				;V.005 TO V.020 ON NEXT 2 INSTRCTNS.
	TLO	FR,(1B0)	;TAKE CARE OF OVERFLOW TO HIGH WORD
	TLZN	FR+1,400000	;CLEAR BIT. WAS THERE CRY1?
	ADDI	FR,1		;YES. PROPOGATE CARRY
RND1:	ADD	FR,RNDH(R)	;HI ORDER ROUND
	TLC	FR,(1B0)	;BACK AS IT WAS UNLESS OVERFLOW
	JUMPGE	FR,NORND	;DID ROUND OVERFLO?
	MOVE	FR,[31463146314];YES,SET TO 0.1
	MOVE	FR+1,[314631463147]
	AOJA	XP,NORND	;INDICATE TO EXP


SCAL:	JUMPLE	IGN,LNBLK	;IS THERE SPACE FOR BLANKS?
	MOVEI	AC,ABLANK	;YES, OUTPUT SOME
	PUSHJ	P,OUTCH		;...
	SOJG	DIG,.-2		;OUTPUT SOME MORE
LNBLK:	SUB	D$,S		;SCALE DIGITS OF SIGNIF.
	HRREI	DIG,-MAXDIG(S)	;S-MAXIMUM SIGNIF
	JUMPLE	DIG,.+2		;IS S above MAXDIG?
	MOVEI	S,MAXDIG	;PROHIBIT PRINTOUT OF GIGO
	ADD	R,S		;ROUND AFTER SCALING DIGITS
	PUSHJ	P,SGNRND	;OUTPUT SIGN AND ROUND
	PUSHJ	P,OUTDIG	;DIGITS BEFORE DECIMAL POINT
	SOJG	S,.-1		;OUTPUT MOST OF SCALE DIGITS
	JUMPLE	DIG,DECPNT	;MORE SCALE DIGITS?
	MOVEI	AC,AO		;MAKE SURE THEY'RE INSIGNIFICANT
	PUSHJ	P,OUTCH		;...
	SOJG	DIG,.-2		;UNTIL SCALE FULFILLED
DECPNT:	MOVEI	AC,APOINT	;DECIMAL POINT
	PUSHJ	P,OUTCH		;...
OGDIG:	TLNE	BITS,BITZ	;IS THE NUMBER 0?
	JRST	ZEROP		;YES, PRINT 0
	JUMPLE	D$,EXPP		;ANY DIGITS REMAINING?
	PUSHJ	P,OUTDIG	;OUTPUT NEXT DIGIT
	SOJG	D$,.-1		;LOOP IF MORE DIGITS
EXPP:				;EXPONENT PRINT
	SKIPN	AC,EXPCHR(USER)	;SDD should also allow exp char changes
	 MOVEI	AC,"@"
	PUSHJ	P,OUTCH
	SKIPN	AC,EXPCHR(USER)	;SDD should also allow exp char changes
	 MOVEI	AC,"@"
	PUSHJ	P,OUTCH
	MOVEI	AC,APLUS	;ASCII +
	JUMPGE	XP,XTEN		;IS EXP +?
	MOVEI	AC,AMINUS	;NO, ASCII -
	MOVNS	XP		;MAKE EXP +
XTEN:	PUSHJ	P,OUTCH		;OUTPUT SIGN OF EXP
	IDIVI	XP,=100	;EXP MODULO 100.
	MOVE	XP,XP+1		;...
	IDIVI	XP,=10		;SPLIT INTO TWO DIGITS
	MOVEI	AC,"0"(XP)	;OUTPUT TENS DIGIT ("0",not 60)
	PUSHJ	P,OUTCH		;TENS POSITION
	MOVEI	AC,"0"(XP+1)	;OUTPUT UNITS DIGIT (also was 60(...))
	PUSHJ	P,OUTCH		;...
OVT:
NORND:	POPJ	P,


LUPP:	ASH	XP,1		;DECIMAL EXPONENT *02
	CAMN	AC,TAB.P(IN)	;IS NUMBER NOW geq TABLE
	 CAML	AC+1,TAB.P1(IN)	;...
	  CAMGE	AC,TAB.P(IN)	;...
	   JRST	PNO		;NO, DON'T MULTIPLY
	MOVEI	Q,TAB.M(IN)	;MULTIPLY BY SELECTED NEGATIVE
	CAIE	IN,13		;E-32?
	JRST	NOTE32		;NO
	SUBI	Q,2		;USE E-16
	PUSHJ	P,DFM..		;TWICE
NOTE32:	PUSHJ	P,DFM..		;...
	ADDI	XP,1		;INDICATE MULTIPLICATION
PNO:	SOJL	IN,REND		;END OF TABLE?
	SOJG	IN,LUPP		;MOVE TABLE POINTER AND LOOP
	JRST	LUPP+1		;EXP IN RIGHT PLACE

LUPM:	ASH	XP,1		;DECIMAL EXPONENT * 2
	CAMN	AC,TAB.M(IN)	;IS NUMBER less TABLE?
	 CAMGE	AC+1,TAB.M1(IN)	;...
	  CAMLE	AC,TAB.M(IN)	;...
	   JRST	MNO		;NO, DON'T MULTIPLY
	MOVEI	Q,TAB.P(IN)	;MULTIPLY BY SELECTED POSITIVE
	PUSHJ	P,DFM..		;...
	SUBI	XP,1		;INDICATE MULTIPLICATION
MNO:	SOJLE	IN,REND		;END OF TABLE?
	SOJA	IN,LUPM		;NO, MOVE TABLE POINTER AND LOOP
								; *EJG* 06/26/76
DFM..:	DFMP	AC,(Q)						; *EJG* 06/26/76
	JOV	.+1						; *EJG* 06/26/76
	POPJ	P,						; *EJG* 06/26/76


ZERO:	TLO	BITS,BITZ	;SET INDICATOR
	SETZB	FR,FR+1		;MAKE FRACTION PART 0
	JRST	ZEROH		;SCALING,IF NEEDED

ZEROP:	MOVEI	AC,"0"		;OUTPUT A ZERO
	PUSHJ	P,OUTCH		;...
	MOVEI	IN,3(D$)		;OUTPUT ENUF BLANKS
	MOVEI	AC,ABLANK	;ASCII BLANK
	PUSHJ	P,OUTCH		;...
	SOJG	IN,.-2		;...
	JRST	OVT		;GO RETURN

			;NEXT 11 INSTRUCTIONS CHANGE V.005 TO V.020
OUTDIG:	MOVE	MUL,FR+1	;MULTIPLY FRACTION BY 10.
	MULI	MUL,=10	;*LOW HALF BY 10.
	MOVE	FR+1,MUL+1	;STORE NEW LOW HALF IN FR+1
	MOVE	MUL+1,MUL	;SAVE LOW HALF CARRIES
	MOVE	AC,FR		;GET HIGH HALF OF FRACTION
	MULI	AC,=10		;* HIGH HALF BY 10.
	TLO	MUL,400000	;SET SIGN TO STOP OVERFLOW
	ADD	MUL,MUL+1	;ADD LOW HALF CARRIES TO HIGH HALF
	TLZN	MUL,400000	;CLEAR SIGN. WAS THERE CRY1?
	ADDI	AC,1		;YES, PROPOGATE CARRY
	MOVE	FR,MUL		;PUT HIGH PART OF NEW FRACTION BACK
	ADDI	AC,AZERO	;ASCII NUMBERS START AT 0

OUTCH:	AOJG	IGN,DEPOT.	;OUTPUT OR IGNORE?
	POPJ	P,		;RETURN

DEPOT.:	IDPB	AC,TOPBYTE(USER)
	AOS	-1(SP)
	POPJ	P,


	SUBTTL	ROUNDING TABLES
RNDH:	OCT	200000000000
	OCT	14631463146
	OCT	1217270243
	OCT	101422335
	OCT	6433342
	OCT	517426
	OCT	41433
	OCT	3265
	OCT	253
	OCT	21
	OCT	1
	OCT	0,0,0,0,0,0,0,0,0
RNDL:	OCT	0
	OCT	146314631464
	OCT	327024365604
	OCT	57065176763
	OCT	353070414545
	OCT	261070664360
	OCT	336405536661
	OCT	374515274536
	OCT	314356106043
	OCT	56027640466
	OCT	267633766353
	OCT	53765777027
	OCT	4313631402
	OCT	341134115
	OCT	26411156
	OCT	2200727
	OCT	163225
	OCT	13416
	OCT	1116
	OCT	73

DEFINE DEXP(A,B)<AB>

TAB.M=.+1							; *EJG* 07/01/76
	DEXP	175631463146,146314631463	;1.0E-1		; *EJG* 07/01/76
TAB.M2=.+1							; *EJG* 07/01/76
TAB.M1:	DEXP	175631463146,146314631463	;1.0E-1		; *EJG* 07/01/76
	DEXP	172507534121,353412172703	;1.0E-2		; *EJG* 07/01/76
	DEXP	163643334272,307041454513	;1.0E-4		; *EJG* 07/01/76
	DEXP	146527461670,214106071677	;1.0E-8		; *EJG* 07/01/76
	DEXP	113715126245,366104674127	;1.0E-16	; *EJG* 07/01/76
	DEXP	026637304365,152123462457	;1.0E-32	; *EJG* 07/01/76
								; *EJG* 07/01/76
TAB.P=.+1							; *EJG* 07/01/76
TAB.P2:	DEXP	201400000000,0			;1.0		; *EJG* 07/01/76
TAB.P1:	DEXP	204500000000,0			;1.0E+1		; *EJG* 07/01/76
	DEXP	207620000000,0			;1.0E+2		; *EJG* 07/01/76
	DEXP	216470400000,0			;1.0E+4		; *EJG* 07/01/76
	DEXP	233575360400,0			;1.0E+8		; *EJG* 07/01/76
	DEXP	266434157115,370100000000	;1.0E+16	; *EJG* 07/01/76
	DEXP	353473426555,101267026547	;1.0E+32	; *EJG* 07/01/76

BEND CVEL
ENDCOM(DVF)

IFN ALWAYS,<
BEND STRSER>
SUBTTL	IO SERVICE ROUTINES

7 