BEGIN "PROFILE" 
REQUIRE 3 VERSION;
let using!records=true, dynamic!storage=true;

COMMENT A PROGRAM TO PRODUCE PROGRAM PROFILES USING THE
 LIST AND COUNTER FILES CREATED BY USING THE /K OPTION
 OF SAIL;

define	EMRK="132",OFILE="BIN",TAB="'11";
define	FINDFF="4",FINDSEMI="5",FINDLF="6",FINDTAB="7",CMNTCODE="133";

REQUIRE 400 STRING!PDL; REQUIRE 600 SYSTEM!PDL;
COMMENT	This page is "PFLSCN.COM" a file needed by the sources of
	both the scanner (PFLSCN.SAI) and the actual program (PROFIL).
;
define CRLF="('15&'12)";
define DELIM="32";
define TOKENCODE="128", STRCONCODE="129", ILLEGALCODE="130",
     EOFCODE="131";

define swtsiz=20;
IFCR DECLARATION(GTJFN) THENC
   let DECSW = false, TENXSW=true, WANTBANGSW = true;
   REQUIRE " COMPILING TENEX VERSION" MESSAGE;
ELSEC
   IFCR DECLARATION(IFGLOBAL) THENC
      let DECSW = false, TENXSW = false, WANTBANGSW = false;
      REQUIRE " COMPILING STANFORD AI VERSION" MESSAGE;
ELSEC
   let DECSW = true, TENXSW=false, WANTBANGSW = true;
   REQUIRE " COMPILING DEC-SYSTEM 10 VERSION" MESSAGE;
ENDC
ENDC


define GOODSWT="""BCKIKLNST""";
define PROCESSOR="""PROFILE""";
define RELMODE=0, LSTMODE=0, SRCMODE='17;
define RELEXT="""PFL""", LSTEXT="NULL", SRCEXT="""KNT""";

COMMENT end of "PFLSCN.COM";
COMMENT	This page is "PFLSCN.REQ" a file needed by the source of
	the actual program (PROFIL) if separate compilation is to work.
	it contains "external" declarations for things in the scanner.
;
ifcr false thenc
comment stub for scanner stuff:
;
    EXTERNAL INTEGER RPGSW;	comment not really in the scanner;
 external     INTEGER WANTBIN,WANTLST,SRCBRK,SRCEOF,CMDBRK,ON!ETIME,NX!TFIL;
 external     INTEGER SOURCECOUNT,SWTP;
 external     STRING BINFIL,SRCFIL,SWTSTR;
 external     INTEGER ARRAY SWTVAL[1:SWTSIZ];
 external 	INTEGER ARRAY BUF[0:'377];
 external INTEGER SRC,BIN,LST,CMND,DELCHNL;

external PROCEDURE COMMAND!SCAN;


external     SAFE INTEGER ARRAY SCANTABLE[0:127];

external     INTEGER TEMP,TEMP1,RESCAN,TOKLEN;
external     STRING STEMP,STEMP1;
external string procedure uppercase(string s);
external string procedure yes!bang(string s);
external     PROCEDURE ATOMINIT(
     STRING  DELIMITER!STRING,
     TOKEN!START,
     TOKEN!CONTINUE,
     partialIGNORE!STRING,
     IGNORE!STRING;
    INTEGER STRING!START,
     NUMBER!FLAG		);
external     INTEGER PROCEDURE ATOM(REFERENCE STRING TOSSED,TOKEN);

ENDC

COMMENT end of file PFLSCN.REQ;
COMMENT this is file PFLSCN.SAI coming up
	you will have to surround it in a block to use it;

Comment	This is the scanner stuff from PROFIL.
;
    DEFINE DSCR="COMMENT ";
    DEFINE #=" "; #
DSCR SCNCMD.SAI -- a package for scanning CUSP-like commands.

DES This package provides a function COMMAND!SCAN, and a set
 of variables and defined values with the following proerties:
PAR The following values must be DEFINEd:
  SRCMODE, LSTMODE, RELMODE the data modes for the approp. files
   (define them all, even if you don't use them)
  SRCEXT, LSTEXT, RELEXT default extension names (they should
   expand to string constants) for the appropriate files.  Blank
   will also be checked as a possible extension for source files.
  PROCESSOR should expand to a string constant.  QQprocessor.RPG
   will be the RPG file looked up (at Stanford).
 The following variables must be set:
  ON!ETIME should be made 0 once only, to force opening of
   the command file.
  NX!TFIL should be made 0 to force COMMAND!SCAN to expect
   a new FILE_FILE command next, instead of more source files.
  WANTBIN should be made true if a `.REL' file is to be
   opened if a file is specified for it.
  WANTLST should be made true if a `.LST' file is to be
   opened if a file is specified for it.
  SOURCECOUNT, after the call on COMMAND!SCAN, may be changed,
   either permanently or temporarily, to control input.
RES on returning from COMMAND!SCAN, the following are available:
 WANTBIN, WANTLST -- true if a file was opened in the approp.
  position, false if false coming in, or no file specified.
 BINFIL, SRCFIL -- the file, extension, and PPN for the approp.
  files (strings).
 SRC, BIN, LST, CMD, DELCHNL (1-5) are channels reserved for
  the obvious functions.  You should use these names.
 CMDTBL, LINTBL, RBRK (15-17) are break tables used by
  COMMAND!SCAN.  Use them if you wish, but don't expect
  them to be there when you get back.
 CRLF,DSCR, and BLANKS are the obvious macros.  Redefine any but DSCR
  if you wish.
SID Channels 1-5, Break Tables 15-17 are reserved by
 COMMAND!SCAN.  Do GETCHANs to obtain channels, or
 be careful.
CAL call COMMAND!SCAN with no parameters.  The first time, and
 any time subsequently that it is called with NX!TFIL=0, it
 will expect optional LST and REL specs, separated by comma,
 followed by a left arrow in the command file, then one or
 more source file names separated by commas, terminated by
 a CRLF.  Only one source file is read the first time.  Subse-
 quent calls on COMMAND!SCAN (without touching NX!TFIL) will
 cause subsequent source files to be looked up--if no more exist
 an error message will be printed.  Set this to FALSE when you
 want a brand new command.  Set ON!ETIME once for every time
 the entire program is restarted.
;

    EXTERNAL INTEGER RPGSW;
    internal INTEGER WANTBIN,WANTLST,SRCBRK,SRCEOF,CMDBRK,ON!ETIME,NX!TFIL;
    internal INTEGER SOURCECOUNT,SWTP;
    internal STRING BINFIL,SRCFIL,SWTSTR;
    internal INTEGER ARRAY SWTVAL[1:SWTSIZ];
	internal INTEGER ARRAY BUF[0:'377];
    DEFINE BLANKS="(""                                      "")";
internal INTEGER SRC,BIN,LST,CMND,DELCHNL;
    DEFINE LINTBL="17",	CMDTBL="16", RBRK="15";

    internal PROCEDURE COMMAND!SCAN;
    BEGIN "COMMAND SCAN"
       INTEGER EOF,FG,TIA,TIB,TIC,TID,SPCFIL,TIE,TIF;
       STRING CMNDFIL,LSTFIL,LINE,TSA,TSB,TSC,BKSTRNG,TSD,CMNDSTR;

    IFCR NOT TENXSW THENC
	SIMPLE INTEGER PROCEDURE TMPCORSTR
	    (INTEGER CODE; STRING FIL; REFERENCE STRING TEXT);
	BEGIN COMMENT Performs TMPCOR function CODE on FIL, transfering TEXT.
		Only functions 1 (read), 2 (read and delete), 3 (write) are legal.
		Value returned is that returned in AC by the UUO, !SKIP! is
		zero if no error, else !SKIP! is -1;
	EXTERNAL INTEGER !SKIP!;
	START!CODE LABEL FOOEY,WRLUP,WRBOT,WRCLR,NOTWRITE;
	DEFINE P="'17",SP="'16",!="COMMENT";
		MOVE	1,CODE;		! CHECK VALID CODES;
		CAIL	1,1;
		CAILE	1,3;
		 JRST	FOOEY;		! YOU LOSE;
		MOVE	2,BUF;		! FWA;
		MOVEI	2,-1(2);	! FWA-1 FOR IOWD;
		HRLI	2,-'400;	! COMPLETE THE IOWD;
		PUSHJ	P,CVSIX;	! CONVERT FIL TO SIXBIT IN AC1;
		TRZ	1,-1;		! PUT ZEROES IN RIGHT HALF;
				! FILE NAME AND IOWD NOW IN 1 AND 2;
		MOVSI	5,'440700;
		HRRI	5,1(2);		! BP TO BUF;
		MOVE	3,CODE;
		MOVE	4,-1(P);! PTR TO WD2;
		CAIE	3,3;
		 MOVEM	5,(4);		! SET RESULT BP IF SOME SORT OF READ;
		CAIE	3,3;
		 JRST	NOTWRITE;
		HRRZ	3,-1(4);	! LENGTH(TEXT);
		CAILE	3,'400*5;	! CHECK MAX LENGTH;
		 JRST	FOOEY;
		MOVE	4,(4);		! COUNT IN 3, BP IN 4;
		JRST	WRBOT;
	WRLUP:	ILDB	6,4;
		IDPB	6,5;
	WRBOT:	SOJGE	3,WRLUP;
		TDZA	6,6;	! CLEAR REMAINDER OF LAST WORD;
	WRCLR:	IDPB	6,5;
		TLNE	5,'760000;
		 JRST	WRCLR;
	NOTWRITE:MOVS	3,CODE;
		HRRI	3,1;	! PARAM AC FOR TMPCOR;
		SETZM	!SKIP!;
		CALLI	3,'44;
	FOOEY:	 SETOB	3,!SKIP!;
		SKIPGE 1,3;
		MOVEI 3,0;!	SET TO 0 IF NEGATIVE;
		IMULI	3,5;	! CONVERT TO CHAR COUNT;
		MOVE	2,CODE;
		MOVE	4,-1(P);! PTR TO WD 2;
		CAIE	2,3;
		 MOVEM	3,-1(4);! STORE CHAR COUNT IF SOME SORT OF READ;
		SUB	P,['3000003];
		JRST	@3(P);
	END; END;

     ENDC

       PROCEDURE FILENAME(REFERENCE STRING DEVICE,FILE);
       BEGIN "FILENAME"
	  PROCEDURE SWTGET;
	  BEGIN	"SWTGET"
		COMMENT mode "K" added by JFR 6-4-75;
	     SETBREAK(RBRK,"0123456789",NULL,"XAK");
	     TSC_SCAN(LINE,RBRK,CMDBRK);
	     SWTVAL[SWTP_SWTP+1]_CVD(TSC[1 TO  inf -1]);
	     TID_TSC[ inf  FOR 1];
	     TSD_GOODSWT;
	     FOR TIE_1 STEP 1 WHILE (TIF_LOP(TSD)) and TID neq TIF DO;
	     SWTSTR_SWTSTR&TIE;
	     IF	(CMDBRK_LINE)="/"  or  CMDBRK=")" THEN CMDBRK_LOP(LINE)
	  END "SWTGET";
	  SPCFIL_FALSE;
	  FILE_SCAN(LINE,CMDTBL,CMDBRK)	;COMMENT GET A DEVICE OR FILENAME;
	  IF CMDBRK = ":" THEN BEGIN
	     DEVICE_FILE; SPCFIL_TRUE; COMMENT FILE SPECIFIED, NOT INVENTED;
	     FILE_SCAN(LINE,CMDTBL,CMDBRK)
	  END ELSE
	  IF EQU(FILE,"LPT")  or  EQU(FILE,"LPT.")	THEN DEVICE_"LPT" ELSE
	   DEVICE_"DSK";
	  IF CMDBRK="["	THEN BEGIN
	     SETBREAK(RBRK,"]",NULL,"IA");
	     FILE_FILE&"["&SCAN(LINE,RBRK,CMDBRK);
	     FILE_FILE&SCAN(LINE,CMDTBL,CMDBRK)
	  END;
	  WHILE	CMDBRK="/" DO SWTGET;
	  IF CMDBRK="("	THEN BEGIN
	     DO	SWTGET UNTIL CMDBRK=")";
	     CMDBRK_LOP(LINE)
	  END;
       END "FILENAME";

       LABEL NXTIME;
       SWTP_0; SWTSTR_NULL;
       IF NX!TFIL THEN GO TO NXTIME;
       SETBREAK(CMDTBL,"_:,(!/["&'12,'15&" "&'11,"I");
       SETBREAK(LINTBL,'12,'15,"INA"); SETBREAK(RBRK,"]",NULL,"IA");
       RELEASE(BIN); RELEASE(LST);

    COMMENT FIRST GET COMMAND DEVICE;

       IF  not RPGSW THEN OUTSTR(CRLF&"*");
       TSA_ IF RPGSW THEN "DSK"	ELSE "TTY";

       IF  not ON!ETIME THEN BEGIN
	  EOF_0;
	  COMMENT TRY TMPCOR FIRST BEFORE FILE, USE LENGTH OF CMNDSTR
		AS FLAG THAT COMMAND IS IN CMNDSTR RATHER THAN FILE;
	  CMNDSTR_NULL;
    IFCR NOT TENXSW THENC
	  IF RPGSW THEN TMPCORSTR(2,PROCESSOR,CMNDSTR);
    ENDC
	  IF NOT(LENGTH(CMNDSTR)) THEN BEGIN
	    OPEN(CMND_GETCHAN,TSA,0,1,1,100,CMDBRK,EOF_-1);
	    IF EOF THEN USERERR(0,0,"COMMAND DEVICE NOT AVAILABLE");
	    TSB_("000"&CVS(CALL(0,"PJOB")))[INF-2 FOR 3]&PROCESSOR&".TMP";
	    LOOKUP(CMND,TSB,FG);
	    IF FG	THEN USERERR(0,0,"COMMAND FILE NOT FOUND");
	  END;

	  IF RPGSW AND NOT LENGTH(CMNDSTR) THEN	BEGIN "DELETE COMMAND FILE"
	     OPEN(DELCHNL_GETCHAN,"DSK",0,2,0,100,TIA,TIA);
	     LOOKUP(DELCHNL,TSB,FG);
	     RENAME(DELCHNL,NULL,0,FG);
	     RELEASE(DELCHNL)
	  END "DELETE COMMAND FILE";

	  CMNDFIL_TSA&":"&(IF RPGSW THEN TSB ELSE NULL);
	  ON!ETIME_TRUE;
       END;
       LINE_NULL;
       WHILE  not EOF and (LENGTH(LINE) leq 1  or  LENGTH(LINE)<5 and 
	EQU (LINE,BLANKS[1 FOR LENGTH(LINE)-1]&'12)) DO
	 BEGIN COMMENT HANDLE TMPCOR VS. FILE;
	  IF LENGTH(CMNDSTR) THEN BEGIN
	    LINE_SCAN(CMNDSTR,LINTBL,CMDBRK);
	    EOF_NOT(LENGTH(CMNDSTR)) END
	  ELSE
	  LINE_INPUT(CMND,LINTBL); COMMENT GET RID OF BLANK LINES;
	 END;
       IF EOF THEN TIA_CALL(0,"EXIT");

       FILENAME(TSA,TSB);

       IF CMDBRK = "!" THEN BEGIN "NEW!PROGRAM"
	  INTEGER ARRAY	SWPTBL[1:5];
	  SWPTBL[1]_CVSIX(TSA);
	  SWPTBL[2]_CVFIL(TSB,SWPTBL[3],SWPTBL[5]);
	  IF  not SPCFIL THEN SWPTBL[5]_CVSIX("  1  3");
	  IF RPGSW THEN	SWPTBL[4]_1;
	  START!CODE
	     MOVE '14,SWPTBL; MOVEM '14,TIA;
	  END;
	  CALL(TIA,IFC TENXSW OR DECSW THENC "RUN" ELSEC "SWAP" ENDC);
       END "NEW!PROGRAM"

       ELSE IF CMDBRK =	"_" OR CMDBRK =	"," THEN
	IF SPCFIL  or  LENGTH(TSB)	THEN BEGIN "BINARY"
	   TIA_CVFIL(TSB,TIB,TIC);
	   IF TIB=0 THEN TSB_CV6STR(TIA)&"."&RELEXT;
	   TID_-1;
	   IF WANTBIN THEN BEGIN "OPNBIN"
	      OPEN(BIN_GETCHAN,TSA,RELMODE,0,2,0,TIC,TID);
	      IF TID THEN USERERR(0,0,RELEXT&" DEVICE NOT AVAILABLE");
	      ENTER(BIN,TSB,FG);
	      IF FG THEN USERERR(0,0,"CANT ENTER "&RELEXT&" FILE");
	   END "OPNBIN";
	   BINFIL_TSA&":"&TSB;
	END "BINARY" ELSE WANTBIN_0  ELSE USERERR(0,0,PROCESSOR&
	 " COMMAND ERROR");

       IF CMDBRK = "," THEN BEGIN "LISTING"
	  FILENAME(TSA,TSB);
	  TIA_CVFIL(TSB,TIB,TIC);
	  IF TIB = 0 THEN TSB_CV6STR(TIA)&"."&LSTEXT;

	  IF WANTLST THEN BEGIN
	     OPEN(LST_GETCHAN,TSA,LSTMODE,0,2,0,TIC,TIC);
	     ENTER(LST,TSB,FG);
	     IF	FG THEN	USERERR(0,0,"CAN'T ENTER "&LSTEXT&" FILE");
	  END;
	  LSTFIL_TSA&":"&TSB;
	  IF CMDBRK  neq  "_" THEN USERERR(0,0,PROCESSOR & " COMMAND ERROR");
       END "LISTING" ELSE WANTLST_0;
       FILENAME(TSA,TSB);
       OPEN(SRC_GETCHAN,TSA,SRCMODE,2,0,SOURCECOUNT_200,SRCBRK,SRCEOF);

       WHILE TRUE DO BEGIN "SOURCE FILE LOOP"
	  IF CMDBRK neq '12	AND CMDBRK neq "," THEN USERERR(0,0,PROCESSOR&
	   " COMMAND ERROR");
	  CLOSE(SRC);
	  TID_CVFIL(TSB,TIC,TIE);
	  TSC_CVXSTR(TID)&"."&SRCEXT&
	   (IF TIE THEN "["&(TSC_CVXSTR(TIE))[1 FOR 3]&","&TSC[4 FOR 3]&"]"
	    ELSE NULL);
	  FG_-1;
	  IF TIC=0 THEN	LOOKUP(SRC,TSC,FG);
	  IF FG	THEN LOOKUP(SRC,TSB,FG);
	  IF FG	THEN USERERR(0,0,TSB &" FILE NOT FOUND");
	  SRCFIL_TSA&":"&TSB;
	  IF RPGSW THEN
	   OUTSTR(PROCESSOR&":	"&(IF EQU(TSA,"DSK") THEN NULL ELSE TSA)&TSB&
	    '15&'12);
	  NX!TFIL_TRUE;	  RETURN;

	  NXTIME:

	   IF CMDBRK='12  THEN USERERR(0,0,"END OF FILE ON SOURCE FILE");
	  FILENAME(TSA,TSB);
       END "SOURCE FILE LOOP";
    END	"COMMAND SCAN";

    COMMENT Swinehart's scanner package (an old version);


DSCR SCNSER.SAI -- a package to provide SCANNER operations
DES This insert provides a token-scanning service more 
   extensive than the SAIL SCAN function can handle. It
   can handle delimiters, identifiers, and string constants,
   as well as filler characters, and characters which are
   to be ignored completely.  There is provision for extension
   to handle numbers.
CAL Call ATOMINIT("DEL", "TS", "TC", "partialIGN", "IGN", SS, NUMF)
  to parameterize the scanner.  All characters in DEL will be
  considered delimiters.  The characters in TS are valid characters
  for the start of an identifier.  Those in TC are valid identifier
  characters after the first.  The characters in IGN are fillers --
  they are returned separately, and never appear in a token, but
  will break an identifier scan.  Those in IGN will be ignored on
  input.  SS is the string constant quote character -- otherwise,
  string constants are scanned like SAIL scans them.  NUMF is true
  if numbers are to be handled (not implemented).
 Call I_ATOM(@"TOSS",@"TOKEN") to scan from the input file
  (ignoring line numbers).  See Results below for exact returns.
RES The result of ATOM is a code -- the character code in ASCII
  for a delimiter -- otherwise an integer >127 -- TOKENCODE for
  identifiers (numbers currently returned in string form as IDs),
  STRCONCODE for string constants, ILLEGALCODE for illegal characters,
  EOFCODE when EOF is seen.  TOSSED contains all those fill
   (IGN) characters passed over before reaching the token.  TOKEN
   contains the character(s) of the token itself.  TOKLEN (a local
   variable, see below) contains the length of the token (for string
   constants, the length of the string from the last LF to the end).
PAR The following will be local to the REQUIRing block:
  SETBIT, SELSTR procedures, SCANTABLE(SCT) array,
   TEMP, TEMP1, STEMP, STEMP1 variables, LETTER, LETDIG ... defs.
 The following are also local, and possibly useful:
  DOLAND, DOLOR, UPPERCASE routines (uses obvious on inspection),
  RESCAN variable, if set, causes same token to be returned again
  TOKLEN (see above), OVERDEL, NOTATOM, ... break tables (14-10),
  TOKENCODE, STRCONCODE ... (see above) return codes.
 The following should be set to affect the ATOM routine:
  RESCAN -- set to rescan -- TOKEN and TOSSED will NOT be 
   set during a rescan -- only the return code is saved!!!!!
SID SCNCMD.SAI is required
  Other side effects should be limited to changes to the variables
  described above.
;

    DEFINE OVERDEL="14", NOTATOM="13", STRSTOP="12", STRTEST="11";
    DEFINE CHKLEN="10";

    DEFINE LETTER="1", LETDIG="2", DIGIT="4", PARTOFNUMBER="8",
     STRINGSTART="16", IGNORE="64",
     partialIGNORE="128", ILLEGAL="256",LOWERCASE="512";



 COMMENT These values go into the scan table, which controls all,
    iff default is indicated by the user
    ;
#

PRELOAD!WITH
 	ILLEGAL,		Comment 0;
 [8]	DELIM,			Comment     and   not    ;
	partialIGNORE,		Comment TAB;
	DELIM,			Comment LF;
	IGNORE,			Comment VT;
	DELIM,			Comment FF;
	IGNORE,			Comment CR;
 [10]	DELIM,			Comment  inf           swap  ;
	LETDIG LOR LETTER,	Comment UNDERLINE;
 [7]	DELIM,			Comment    neq   leq   geq    or  ;
	partialIGNORE,		Comment SPACE;
	LETDIG LOR LETTER,	Comment ! -- SAME AS ;
	STRINGSTART,		Comment " ;
 [13]	DELIM,			Comment # # $ % & ' ( ) * + - . /;
 [10]	DIGIT LOR
       LETDIG LOR PARTOFNUMBER,	Comment 0-9;
 [7]	DELIM,			Comment : SEMIC < = > ? @ ;
 [26]	LETDIG LOR LETTER,	Comment A-Z;
 [6]	DELIM,			Comment [ \ ] ^ _ ` ;
 [26]	LETDIG LOR LETTER
	       LOR LOWERCASE,	Comment a-z;
 [2]	DELIM,			Comment { | ;
	ILLEGAL,		Comment ALTMODE;
	DELIM,			Comment ~ ;
	ILLEGAL;		Comment DELETE;

#
    internal SAFE INTEGER ARRAY SCANTABLE[0:127];
    DEFINE SCT="SCANTABLE";

    internal INTEGER TEMP; integer TEMP1,RESCAN,TOKLEN;
    STRING STEMP,STEMP1;

    PROCEDURE DOLAND(REFERENCE INTEGER I; INTEGER MASK);
    I_I	LAND MASK;

    PROCEDURE DOLOR(REFERENCE INTEGER I; INTEGER MASK);
    I_I	LOR MASK;

    PROCEDURE CLEAR(INTEGER MASK);
    BEGIN "CLEAR"
       TEMP1_-1	XOR MASK;
       FOR TEMP_0 STEP 1 UNTIL 127 DO
	DOLAND(SCT[TEMP],TEMP1);
    END	"CLEAR";

    PROCEDURE SETBIT(STRING S;INTEGER MASK);
    IF S neq '177 THEN BEGIN "SETBIT"
       CLEAR(MASK);
       WHILE TEMP_LOP(S) DO DOLOR(SCT[TEMP],MASK)
    END	"SETBIT";

    STRING PROCEDURE SELSTR(INTEGER MASK);
    BEGIN "SELSTR"
       STEMP_NULL;
       FOR TEMP_0 STEP 1 UNTIL 127 DO
	IF SCT[TEMP] LAND MASK THEN STEMP_STEMP&TEMP;
       RETURN(STEMP)
    END	"SELSTR";

    internal STRING PROCEDURE UPPERCASE(STRING S);
    BEGIN "UPPERCASE"
       STEMP_NULL;
       WHILE LENGTH(S) DO STEMP_STEMP&
	(IF LOWERCASE LAND (TEMP1_SCT[TEMP_LOP(S)]) THEN
	 (TEMP1	LSH -18) ELSE TEMP);
       RETURN(STEMP)
    END	"UPPERCASE";

    internal PROCEDURE ATOMINIT(
     STRING  DELIMITER!STRING,
     TOKEN!START,
     TOKEN!CONTINUE,
     partialIGNORE!STRING,
     IGNORE!STRING;
    INTEGER STRING!START,
     NUMBER!FLAG		);

    BEGIN "ATOMINIT"
       FOR TEMP_"a" STEP 1 UNTIL "z" DO
	DOLOR(SCT[TEMP],(TEMP-"a"+"A") LSH 18);

       SETBIT(DELIMITER!STRING,DELIM);
       SETBIT(TOKEN!START,LETTER);
       SETBIT(TOKEN!CONTINUE,LETDIG);
       IF STRING!START neq '177 THEN BEGIN
	  CLEAR(STRING);
	  DOLOR(SCT[STRING!START],STRINGSTART)
       END ELSE	STRING!START_"""";
       SETBIT(IGNORE!STRING,IGNORE);
       SETBIT(partialIGNORE!STRING,partialIGNORE);

       STEMP1_SELSTR(IGNORE); "ALWAYS IGNORED COMPLETELY"

       SETBREAK(OVERDEL,SELSTR(partialIGNORE)&STEMP1,STEMP1,"XNR");
       SETBREAK(NOTATOM,SELSTR(LETDIG)&STEMP1,STEMP1,"XNR");
       SETBREAK(STRSTOP,STRING!START,NULL,"INA");
       SETBREAK(STRTEST,NULL,NULL,"XNR");
       SETBREAK(CHKLEN,'12,'15,"I");
       RESCAN_FALSE;
    END	"ATOMINIT";

    SIMPLE STRING PROCEDURE NO!BANG(STRING S);
    BEGIN INTEGER C; STRING T;
    T _ NULL;
    WHILE (C _ LOP(S)) DO T _ T & (IF C="!" THEN "" ELSE C);
    RETURN(T);
    END;

IFCR WANTBANGSW THENC
    internal SIMPLE STRING PROCEDURE YES!BANG(STRING Y);
    BEGIN "YES!BANG"
          STRING Q; INTEGER TEMP;
          Q _ NULL;
          WHILE LENGTH(Y) DO
             IF (TEMP _ LOP(Y)) = ("X"-'100) THEN
                Q _ Q & "!"
             ELSE
                Q _ Q & TEMP;
          RETURN(Q);
    END "YES!BANG";
ELSEC
    DEFINE YES!BANG(S) = "S";
ENDC


    INTEGER PROCEDURE ATOM(REFERENCE STRING TOSSED,TOKEN);
    BEGIN "ATOM"
       INTEGER RET;
       IF RESCAN THEN BEGIN
	  RESCAN_FALSE;
	  RETURN(RET)
       END;
       SOURCECOUNT_200;	TOKLEN_1;
       TOSSED_INPUT(SRC,OVERDEL);		"BLANKS AND SUCH"
       IF SRCEOF THEN RETURN(RET_EOFCODE);
       TEMP_SCT[SRCBRK];			"SCANNER TABLE BITS"
       IF TEMP LAND LETTER THEN	BEGIN "TOKEN"
	  TOKEN_NO!BANG(INPUT(SRC,NOTATOM));	"GET IDENTIFIER"
	  TOKLEN_LENGTH(TOKEN);
	  RETURN(RET_TOKENCODE)
       END "TOKEN";

       IF TEMP LAND STRINGSTART	THEN BEGIN "STRCON"
	  TOKEN_NULL;
	  DO BEGIN "GET STRING"
	     SOURCECOUNT_1;
	     TOKEN_TOKEN&INPUT(SRC,0);	"PICK UP STRINGSTART"
	     SOURCECOUNT_200;
	     DO	TOKEN_TOKEN&
	      INPUT(SRC,STRSTOP) UNTIL SRCBRK; "GO UNTIL STRINGSTART"
	     INPUT(SRC,STRTEST);		"CHECK FOR 2 STRINGSTARTS";
	  END "GET STRING" UNTIL  not (SCT[SRCBRK] LAND STRINGSTART);
	  STEMP1_TOKEN;	"COMPUTE TOKLEN"
	  DO STEMP_SCAN(STEMP1,CHKLEN,TEMP) UNTIL TEMP neq '12;
	  TOKLEN_LENGTH(STEMP);	IF TOKLEN neq LENGTH(TOKEN)	THEN TOKLEN_-TOKLEN;
	  RETURN(RET_STRCONCODE)
       END "STRCON";

       "MUST NOW BE EITHER DELIMITER OR ILLEGAL"

       SOURCECOUNT_1; TEMP1_SRCBRK;
       TOKEN_INPUT(SRC,0);			"GET THE CHARACTER"
       "HACK HERE TO ALLOW := FOR _"
       IF TOKEN = ":" THEN
          BEGIN
             STRING TOSS2;
             TOSS2 _ INPUT(SRC,OVERDEL);
             IF SRCBRK = "=" THEN
                BEGIN
                   TOKEN _ "_";
                   TOSS2 _ INPUT(SRC,0);
                   RETURN(RET_"_");
                END;
          END;
       IF TEMP LAND ILLEGAL THEN RETURN(RET_ILLEGALCODE)
	ELSE RETURN(RET_TEMP1)

    END	"ATOM";
DSCR END OF SCNSER
;

COMMENT that was file PFLSCN.SAI, now back to PROFIL.SAI;
IFCR using!records THENC
 record!class let! ( string name; integer val;
			record!pointer (let!) link );
 record!class class! (string name; record!pointer (class!) link);

 record!pointer (let!) let!head;
 record!pointer (class!) class!head;
ELSEC
 INTEGER ARRAY LETVAL[1:20];  STRING ARRAY LETS[1:20];  INTEGER NLETS;
 STRING ARRAY RPSTR[1:40];	INTEGER NRPC;
ENDC
string str1;
COMMENT RESERVED WORD SYMBOL TABLE

THE ARRAY STAB CONTAINS THE NAMES OF ALL THE IMPORTANT RESERVED WORDS
(THOSE NEEDED TO DISTINGUISH DECLARATIONS AND OTHER NON-EXECUTABLE 
STATEMENTS FROM EXECUTABLE STATEMENTS, THUS "PUT" IS NOT IN THE TABLE
BECAUSE IT MERELY INDICATES AN EXECUTABLE STATEMENT, MUCH AS ANY
OTHER IDENTIFIER NOT FOLLOWED BY A COLON).

THE ARRAY LETS CONTAINS THE NAMES OF ALL USER DEFINED RESERVED WORDS
(BY MEANS OF "LET" DECLARATIONS).

THE PROCEDURE LOOKR LOOKS UP A SYMBOL AS FOLLOWS:

	1. IF ANY "LET" DECLARATIONS HAVE BEEN SEEN (THE NUMBER SEEN
	   IS KEPT IN THE INTEGER NLETS) THEN LOOKR
	   DOES A LINEAR SEARCH THROUGH THE LETS ARRAY FOR THE
	   SYMBOL. IF THE SYMBOL IS FOUND, THE "VALUE" OF THE SYMBOL RETURNED
	   IS THE CORRESPONDING ELEMENT OF THE ARRAY LETVAL. THUS, IF
	   LETS[3] WAS THE SYMBOL, LETVAL[3] WOULD BE RETURNED.

	2. OTHERWISE WE USE THE ASCII CODE FOR THE FIRST LETTER OF THE
	   SYMBOL AS AN INDEX INTO THE ARRAY XFERTAB. AN XFERTAB ENTRY
	   CONTAINS TWO INTEGERS PACKED IN A SINGLE WORD. THEY
	   ARE THE INDEX OF THE FIRST ELEMENT OF THE ARRAY STAB WHICH STARTS
	   WITH THE CORRESPONDING LETTER, AND THE INDEX OF THE LAST ELEMENT
	   OF THE ARRAY STAB WHICH STARTS WITH THE SAME LETTER.
	   IF THERE IS NO ENTRY IN STAB STARTING WITH  A GIVEN LETTER
	   THEN THE ENTRIES IN XFERTAB FOR THAT LETTER ARE BOTH 0.
	   IF THERE IS ONLY ONE ENTRY IN STAB STARTING WITH A GIVEN LETTER
	   THEN (FOR SOME UNEXPLAINED REASON) THE ENDING INDEX IS ZERO
	   INSTEAD OF BEING THE SAME AS THE STARTING INDEX. IF THE
	   STARTING INDEX IS NON-ZERO LOOKR DOES A LINEAR SEARCH FROM
	   THAT POSITION IN STAB TO THE ENDING POSITION IN STAB. IF
	   THE SYMBOL IS FOUND THE CORRESPONDING ENTRY IN SVAL IS RETURNED.
	   THUS, IF THE DESIRED SYMBOL IS STAB[5], THEN SVAL[5] WILL
	   BE RETURNED.

	3. IF THE SYMBOL IS NOT FOUND THEN IT IS NOT A CRUCIAL RESERVED
	   WORD AND THE VALUE 0 IS RETURNED.
;

INTEGER PROCEDURE LOOKR;
begin "LOOKR"
COMMENT PRELOADED ARRAYS FOR SYMBOL TABLE-- LOOKR;

PRELOAD!WITH
"ASSIGNC",	"ARRAY",	"BEGIN",	"BOOLEAN",	"CASE",
"CLEANUP",	"CONTEXT",	"CONTINUE",	"DEFINE",	"DO",
"DONE",		"END",		"ELSE",		"EXTERNAL",	"FOR",
"FOREACH",	"FORTRAN",	"FORWARD",	"GLOBAL",	"GO",
"GOTO",		"IF",		"INTEGER",	"INTERNAL",	"ITEM",
"ITEMVAR",	"LABEL",	"LET",		"LIST",		"LONG",
"MATCHING",	"MESSAGE",	"NEEDNEXT",	"OF",		"OWN",
"PRELOADWITH","PRESETWITH",	"PROCEDURE",	"QUICKCODE",	"REAL",
"RECURSIVE",	"REQUIRE",	"RETURN",	"RECORDCLASS","RECORDPOINTER",
"SAFE",		"SET",		"SHORT",	"SIMPLE",	"STARTCODE",
"STRING",	"UNTIL",	"WHILE";
own STRING ARRAY STAB[1:53];

PRELOAD!WITH
  3,  3,  7,  4,  8,  3,  4, 10,  3,  9,
 10, 16, 17,  2, 11, 11,  1,  1,  4, 13,
 13, 14,  4,  4,  4,  4,  3, 20,  4,  4,
  4,  4,  6, 19,  3,  3,  3,  5, 15,  4,
  4,  3, 10, 21, 22,  3,  4,  4,  4, 15,
  4, 18, 12;
own INTEGER ARRAY SVAL[1:53];

PRELOAD!WITH [65]0,
'0102,	'0304,	'0510,	'1113,	'1416,	'1722,	'2325,	0,	'2632,	0,
0,	'3336,	'3740,	'4100,	'4243,	'4446,	'4700,	'5055,	'5663,	0,
'6400,	0,	'6500,	[40]0;
own SAFE INTEGER ARRAY XFERTAB[0:127];

COMMENT RESERVED WORDS ARE CLASSIFIED AS FOLLOWS:
	1-	"FORWARD" AND "FORTRAN"
	2-	"EXTERNAL"
	3-	NECESSARILY DETERMINES A NON-EXECUTABLE STATEMENT
	4-	A TYPE, THIS MIGHT BE A PROCEDURE DECL.
	5-	"PROCEDURE"
	6-	"NEEDNEXT"
	7-	"BEGIN"
	8-	"CASE"
	9-	"DO"
	10-	"DONE","RETURN","CONTINUE"
	11-	"FOR","FOREACH"
	12-	"WHILE"
	13-	"GO","GOTO"
	14-	"IF"
	15-	"QUICKCODE","STARTCODE"
	16-	"END"
	17-	"ELSE"
	18-	"UNTIL"
	19-	"OF"
	20-	"LET"
	21-	"RECORDCLASS"
	22-	"RECORDPOINTER"
;

Comment here begins "LOOKR";
		INTEGER I,I1,I2;
IFCR using!records THENC
		record!pointer (let!) chase;
	if chase_ let!head
	 then do if equ(str1,let!:name[chase])
		  then return(let!:val[chase])
		until null!record = (chase_ let!:link [chase]);
ELSEC
	IF NLETS >0 THEN
	    BEGIN FOR I_ 1 STEP 1 UNTIL NLETS DO 
		IF EQU(STR1,LETS[I]) THEN RETURN (LETVAL[I]);
	    END;
ENDC
	I1_(I2_XFERTAB[STR1]) LSH (-6);
	IF I1=0 THEN RETURN(0);
	I2_I2 LAND '77;
	IF I2=0 THEN RETURN(IF EQU(STR1,STAB[I1]) THEN SVAL[I1] ELSE 0);
	FOR I_I1 STEP 1 UNTIL I2 DO
		IF EQU(STR1,STAB[I]) THEN RETURN(SVAL[I]);
	RETURN(0);
	END "LOOKR";

COMMENT FINITE STATE PARSER


IN THE FOLLOWING TRANSITION TABLE, THE POSITIVE ENTRIES INDICATE
	STATE TRANSITIONS AND THE NEGATIVE ONES INDICATE EXITS AS FOLLOWS:
	(-2)	EXECUTABLE STATEMENT
	(-3)	NON-EXECUTABLE STATEMENT
	(-4)	FORWARD OR EXTERNAL PROCEDURE DECL.
	(-5)	ACTUAL PROCEDURE DECL.
	(-6)	ERROR
;
PRELOAD!WITH
-2,-4,2,-3,3,-5,4,[6] -6,		COMMENT ROW 1 BEGINNING OF STATEMENT;
-3,-4,-6,-3,2,-4,-6,[6] -6,		COMMENT ROW 2 SEEN "EXTERNAL" LOOKING FOR "PROCEDURE";
-3,-4,2,-3,3,-5,-6,[6] -6,		COMMENT ROW 3 SEEN TYPE LOOKING FOR "PROCEDURE";
[11] -6,-11,-12;

INTEGER ARRAY XITION[1:4,0:12];


integer curcount;
INTEGER I,J,N,Q,NTABS,NT,NLEN,OLEN,TYP1,TYP2,
  NTYPE,OTYPE,NLINES,SEMICOL,FFLAG,PLVL,STPFLG,
  CONIND,BLKIND,LASCOL,CTRCOL,MAXCOL,TI1,TI2,TI3,
  SPAC1,SPAC2,SPACO,SPACT,SPACN,FIRSTSCAN,TIA,IGNCMT;
STRING HEAD1,HEADNG,TABS,NLINE,OLINE,STR2,STR1A,STR2A,BLANX,BFILL,
  CONFIL,TS1,TS2,IGN;
integer mxktr;

string current!file!name;	comment for error messages (only);
procedure complain( string troubleMessage );
usererr(0,0, troubleMessage & "
FILE= " & current!file!name & "
OLINE= """ & OLINE & """
NLINE= """ & NLINE & """
NEXT 2 TOKENS= """ & STR1A & """, """ & STR2A & """");

ifcr dynamic!storage thenc
record!class program (string name; integer array knt;
			record!pointer (program) link );
record!pointer (program) current!program;

define kountr= "program:knt [current!program]";

elsec
procedure kntloop;
BEGIN "KNTLOOP"
INTEGER ARRAY KOUNTR[1:MXKTR];
endc
own integer IKNT;
define NEXTCOUNTER="KOUNTR[(IKNT_IKNT+1) min mxktr]";
COMMENT PROCEDURES SCAN1, SCAN2, TERP1, AND TERPRI;


RECURSIVE PROCEDURE SCAN2;
	BEGIN 
	SPAC2_0;
	TYP2_ATOM(IGN,STR2A);
	WHILE TYP2='177 DO
		BEGIN TYP2_ATOM(IGN,STR2A);
		IF TYP2=2 THEN TYP2_ATOM(IGN,STR2A)
		ELSE IF TYP2=3 THEN TYP2_EMRK
		ELSE complain("ILLEGAL CHAR  <'" & CVOS(TYP2) & 
					"> AFTER '177");
		END;
	IF TYP2=EOFCODE THEN
		BEGIN TYP2_TOKENCODE; STR2_"END";
		STR2A_"END (supplied by scanner)";SPAC2_1;
		RETURN;
		END;
	IF TYP2=TOKENCODE THEN
		BEGIN SPAC2_1;
		STR2_UPPERCASE(STR2A);
		IF EQU(STR2,"COMMENT") THEN
			BEGIN 
			DO 
				STR2A_STR2A&INPUT(SRC,FINDSEMI)
			UNTIL SRCBRK;
			TYP2_CMNTCODE;
			END;
		END
	ELSE BEGIN IF TYP2=STRCONCODE THEN SPAC2_1; STR2_STR2A; END;
	IF TYP2='14 THEN
		BEGIN
		SOURCECOUNT_200; TS1_INPUT(SRC,FINDLF);
		TS2_NULL;
		WHILE (TS1[ inf  FOR 1] neq "-") and (LENGTH(TS1)>0) DO
			BEGIN TS2_TS1[ inf  FOR 1]& TS2;
			TS1_TS1[1 TO  inf -1];
			END;
		TI1_ INTSCAN(TS2,TI2);
 		TS1_INPUT(SRC,FINDLF); "READ THE SECOND HEADING LINE"
		IF (TI1=1) and  not FIRSTSCAN THEN
			BEGIN STR2A_ '15&'14;
			TYP2_CMNTCODE;
			END
		ELSE SCAN2;
		END;
	END "SCAN2";

PROCEDURE SCAN1;
	BEGIN
	SPAC1_SPAC2;
	STR1_STR2;
	STR1A_STR2A;
	TYP1_TYP2;
	SCAN2;
	END "SCAN1";

PROCEDURE TERP1;
	BEGIN INTEGER L2;
	STRING FILL;
	IF NLEN=0 THEN SPACO_0 ELSE IF SPACN THEN
		BEGIN TIA_LOP(NLINE); NLEN_NLEN-1; SPACN_0 END;
	IF LENGTH(OLINE)=0 THEN RETURN;
	L2_(OLEN+8) LAND '777777777770;
	OUT(OFILE,YES!BANG(BFILL&OLINE&TAB));
	IF (OTYPE neq 0) THEN
		BEGIN 
		FILL_ IF (FFLAG neq 0) and ((NLINES LAND 3)=0) THEN "   .   ." ELSE TAB;
		WHILE L2<CTRCOL DO
      			BEGIN OUT(OFILE,YES!BANG(FILL));
			L2_L2+8;
			END;
		IF CURCOUNT<0 THEN complain("DRYROT: negative count.");
		OUT(OFILE,CVS(CURCOUNT)&CRLF);
		OTYPE_0;
		END
	ELSE OUT(OFILE,CRLF);
	OLINE_NULL;
	NLINES_NLINES+1;
	END "TERP1";

PROCEDURE TERPRI;
	BEGIN
	TERP1;
	TI3_NT % 8;
	BFILL_TABS[1 FOR TI3]&BLANX[1 FOR NT-8*TI3];
	OLEN_NT;
	END "TERPRI";



COMMENT PROCEDURES INDENT,UNDENT,SPRINT, PRINT1, & COUNTSTR;

PROCEDURE INDENT(INTEGER NCOLS);
	BEGIN
	NT_ NT+NCOLS;
	IF NT geq LASCOL-1 THEN 
	    BEGIN SETFORMAT(0,0);
	    USERERR(0,0,"NESTING TOO DEEP FOR PRINTING. CHANGE INDENTION COUNTS
FOR BLOCKS AND CONTINUATIONS FROM /"&CVS(BLKIND)&"B/"&CVS(CONIND)&"C");
	    END;
	TERPRI;
	END;

PROCEDURE UNDENT(INTEGER NCOLS);
	BEGIN
	NT_ NT-NCOLS;
	TERPRI;
	END;

PROCEDURE SPRINT;
	BEGIN
	IF NLEN=0 THEN RETURN;
	OLINE_OLINE&NLINE;
	OLEN_OLEN+NLEN;
	OTYPE_ OTYPE LOR NTYPE;
	NLINE_NULL;
	SPACN_0;
	NLEN_0;
	END;

PROCEDURE PRINT1;
	BEGIN INTEGER L1;
	IF SPAC1  and  SPACO THEN 
		BEGIN STR1A_" "&STR1A; SPACT_1; 
		IF NLEN=0 THEN SPACN_1;
		END ELSE SPACT_0;
	L1_LENGTH(STR1A);
	IF OLEN+NLEN+L1<LASCOL THEN
		BEGIN NLINE_NLINE&STR1A;
		NLEN_NLEN+L1;
		END
	ELSE	BEGIN TERPRI; 
		IF SPACN  and  (NLEN=0) THEN
			BEGIN SPACN_SPACT_0; TIA_LOP(STR1A); L1_L1-1 END;
		IF OLEN+NLEN+L1<LASCOL THEN
			BEGIN NLEN_NLEN+L1;
			NLINE_NLINE&STR1A;
			END
		ELSE	BEGIN OLINE_NLINE;
			OTYPE_NTYPE;
			OLEN_OLEN+NLEN;
			TERPRI; IF SPACT THEN BEGIN TIA_LOP(STR1A); L1_L1-1 END;
			WHILE L1+NT+CONIND > LASCOL DO
				BEGIN OLINE_CONFIL& STR1A[1 FOR LASCOL-NT-CONIND];
				OTYPE_NTYPE;
				OLEN_ LASCOL;
				TERPRI;
				STR1A_STR1A[LASCOL-NT-CONIND+ 1 TO  inf ];
				L1_LENGTH(STR1A);
				END;
			NLINE_CONFIL&STR1A;
			NLEN_L1+CONIND;
			END;
		END;
	SPACO_SPAC1;
	END "PRINT1";
DEFINE PASSCOMMENT= "WHILE (TYP1=STRCONCODE) or (TYP1=CMNTCODE) DO
	BEGIN NTYPE_0; IF TYP1=STRCONCODE THEN PRINTS ELSE
	 PRINTC; SPRINT;SCAN1; END",
	CHECKSEMI= "IF TYP1="";"" THEN 
		BEGIN PRINT1;SPACO_1;SCAN1;SEMICOL_1;
		END ELSE SEMICOL_0;  SPRINT";
DEFINE PASSTOKEN=
		"BEGIN IF TYP1=STRCONCODE THEN PRINTS ELSE 
		  IF TYP1=CMNTCODE THEN PRINTC ELSE
		  BEGIN  IF TYP1=EMRK THEN COUNTSTR; PRINT1 END;
		SCAN1;
		END";

PROCEDURE COUNTSTR;
	BEGIN
	INTEGER I,J;
	GETFORMAT(I,J);
	SETFORMAT(0,0);
	STR1A_"<<"&CVS(NEXTCOUNTER)&">>"; SPAC1_0;
	SETFORMAT(I,J);
	END;


COMMENT PROCEDURES WIDTH,PRINTS, PRINTC, AND FINISH;

INTEGER PROCEDURE WIDTH(STRING ST1; INTEGER STCOL);
	BEGIN COMMENT RETURN THE FINAL COLUMN IF STRING
	  ST1 IS PRINTED STARTING IN COLUMN STCOL;
	INTEGER L1,BRK; STRING ST2;
	L1_STCOL;
	WHILE LENGTH(ST1)>0 DO
		BEGIN 
		ST2_SCAN(ST1,FINDTAB,BRK);
		L1_L1+LENGTH(ST2);
		IF BRK=TAB THEN L1_8+(L1 LAND '777777777770);
		END;
	RETURN(L1);
	END;

PROCEDURE PRINTS;
	BEGIN
	INTEGER L1,BRK,T1,L2;
	STRING ST1;
	IF SPAC1  and  SPACO THEN 
		BEGIN STR1A_" "&STR1A; SPACT_1; IF NLEN=0 THEN SPACN_1 END
		ELSE SPACT_0; 
	ST1_SCAN(STR1A,FINDLF,BRK);
	L1_WIDTH(ST1,NLEN+OLEN);
	IF L1 leq LASCOL THEN
		BEGIN NLINE_NLINE&ST1;
		NLEN_L1-OLEN;
		END
	ELSE	BEGIN
		TERPRI; IF SPACN  and  (NLEN=0) THEN
			BEGIN TIA_LOP(ST1); SPACT_SPACN_0 END;
		L1_WIDTH(ST1,NLEN+OLEN);
		IF L1 leq LASCOL THEN
			BEGIN
			NLINE_NLINE&ST1; NLEN_L1-OLEN;
			END
		ELSE
			BEGIN OLINE_NLINE; OTYPE_NTYPE;
			NLINE_NULL;
			OLEN_OLEN+NLEN; TERPRI;
			IF SPACT THEN  BEGIN TIA_LOP(ST1); SPACT_0 END;
			L1_WIDTH(ST1,OLEN+CONIND);
			IF L1 leq LASCOL THEN
				BEGIN NLINE_CONFIL&ST1; NLEN_ L1-OLEN;
				END
			ELSE	BEGIN L2_WIDTH(ST1,0);
				IF L2 leq LASCOL THEN
				  BEGIN T1_LASCOL-L2;
				  WHILE (L2_WIDTH(ST1,T1))>LASCOL DO
				    T1_T1-1;
				  OLEN_L2;
				  BFILL_BLANX[1 FOR T1];
				  OLINE_ST1; TERPRI;
				  END
				ELSE
				  BEGIN COMMENT JESUS THAT'S A LONG STRING;
				  WHILE(T1_ LENGTH(ST1))>0 DO
				    BEGIN
				    WHILE (L1_WIDTH(ST1[1 FOR T1],OLEN+CONIND))>LASCOL-2 DO
				      T1_T1-1;
				    NLINE_CONFIL&ST1[1 FOR T1]; NLEN_ L1-OLEN;
				    ST1_ST1[T1+1 TO  inf ];
				    IF LENGTH(ST1)>0 THEN
				      BEGIN NLINE_NLINE&"""&"; NLEN_NLEN+2; SPRINT;
				      TERPRI; ST1_CONFIL&""""&ST1;
				      END;
				    END;
				  END;
				END;
			END;
		END;

COMMENT BY HOOK OR CROOK WE GOT THE FIRST LINE OF THE STRING OUT.
  NOW DO THE REST;

	WHILE LENGTH(STR1A)>0 DO
		BEGIN SPRINT; TERP1; ST1_SCAN(STR1A,FINDLF,BRK);
		BFILL_NULL; OLEN_0;
		L1_WIDTH(ST1,0);
		IF L1 leq LASCOL THEN
		      BEGIN NLINE_ST1;
		      NLEN_L1; L1_0;
		      END
		ELSE
		      WHILE(T1_ LENGTH(ST1))>0 DO
			BEGIN
			WHILE (L1_WIDTH(ST1[1 FOR T1],0))>LASCOL-2 DO
			  T1_T1-1;
			NLINE_ST1[1 FOR T1]; NLEN_ L1;
			ST1_ST1[T1+1 TO  inf ];
			IF LENGTH(ST1)>0 THEN
			  BEGIN NLINE_NLINE&"""&"; NLEN_NLEN+2; SPRINT;
			  TERPRI; ST1_CONFIL&""""&ST1;
			  END;
			END;
		END;
	SPACO_SPAC1;
	END "PRINTS";

PROCEDURE PRINTC;
	BEGIN 
	STRING ST1;
	INTEGER BRK;
	IF (LENGTH(STR1A)=2) and EQU(STR1A,'15&'14) THEN 
		BEGIN TERPRI; OUT(OFILE,YES!BANG(STR1A)); RETURN;
		END;
	IF IGNCMT THEN RETURN;
	TERPRI;
	ST1_SCAN(STR1A,FINDLF,BRK);
	NTYPE_0;
	OLINE_ST1;
  	WHILE LENGTH(STR1A)>0 DO
		BEGIN ST1_SCAN(STR1A,FINDFF,BRK);
		IF BRK='14 THEN
		  BEGIN
		  SOURCECOUNT_200; TS1_SCAN(STR1A,FINDLF,BRK);
		  TS2_NULL;
		  WHILE (TS1[ inf  FOR 1] neq "-") and (LENGTH(TS1)>0) DO
			  BEGIN TS2_TS1[ inf  FOR 1]& TS2;
			  TS1_TS1[1 TO  inf -1];
			  END;
		  TI1_ INTSCAN(TS2,TI2);
		  TS1_SCAN(STR1A,FINDLF,BRK);
		  IF (TI1=1) THEN
			  BEGIN TERP1; OUT(OFILE,'15&'14);
			  OLEN_0;
			  END
		  END
		ELSE
		  BEGIN
		  TERP1; OLEN_0; BFILL_NULL;
		  OLINE_ST1;
		  END;
		END;
	TERPRI;
	END "PRINTC";

PROCEDURE FINISH;
	BEGIN
	NTYPE_1;
	WHILE (TYP1 neq ";") and ((TYP1 neq TOKENCODE) or  ( not EQU(STR1,"UNTIL") and 
	   not EQU(STR1,"END") and ( not EQU(STR1,"ELSE") or (TYP2=EMRK)))) DO
		PASSTOKEN;
	CHECKSEMI;
	END;


RECURSIVE PROCEDURE SCAN!STMT(INTEGER DOINDENT);

COMMENT THIS IS THE MAIN PROCEDURE.  IT WILL SCAN A SINGLE STATEMENT
	AND WRITE IT OUT TO THE LIST FILE.  IF THE STATEMENT ENDS
	WITH A SEMICOLON, THE VARIABLE SEMICOL WILL BE SET TO 1 ELSE
	0;

	BEGIN "SCAN!STMT"
	INTEGER S1,S2; LABEL KP; INTEGER NQ;
	WHILE (TYP1=STRCONCODE) or (TYP1=CMNTCODE) or 
	  ((TYP1=TOKENCODE) and (TYP2=":")) DO
		BEGIN "SCNLBL" COMMENT FIRST HANDLE LABELS AND COMMENTS;
		IF (TYP1=STRCONCODE) THEN
		      BEGIN NTYPE_0;
		      PRINTS; SPRINT;
		      END
		ELSE  IF TYP1=CMNTCODE THEN 
		      BEGIN PRINTC; SPRINT END
		   ELSE
		      BEGIN
IFCR using!records THENC
				record!pointer (class!) chase;
			if chase_ class!head
			 then do if equ(str1,class!:name[chase])
				  then done "SCNLBL"
				until null!record =
					(chase_class!:link [chase]);
ELSEC
			FOR S1_1 STEP 1 UNTIL NRPC DO
			 IF EQU(STR1,RPSTR[S1]) THEN DONE "SCNLBL";
ENDC
		      TERPRI;
   		      NTYPE_1; CURCOUNT_NEXTCOUNTER;
   		      PRINT1; SCAN1;
   		      PRINT1; SPRINT; TERPRI;
   		      END;
 	        SCAN1;
		END;

COMMENT FIRST DETERMINE WHETHER THIS IS A NULL STATEMENT (SOME NULL
	STATEMENTS ARE CAUGHT BELOW BY THE "PARSER";

	IF TYP1=";" THEN
		BEGIN PRINT1;SPACO_1;NTYPE_1;SCAN1;SPRINT;SEMICOL_1; RETURN;
		END;

COMMENT  DETERMINE THE STATEMENT TYPE BY A FINITE STATE "PARSER";

	NQ_1;
KP:	J_LOOKR;
	IF J leq 6 THEN
		BEGIN Q_NQ;
		WHILE Q>0 DO
			BEGIN PRINT1; SCAN1;
			IF J>12 THEN complain("ERROR IN STMT TYPING");
			Q_XITION[Q,J];
			J_LOOKR;
			END;
		J_ -Q;
		END;
	CASE J OF
		BEGIN "BIGSW"


COMMENT ROUTINES FOR SIMPLE EX AND NON-EX STMTS AND PROC. DECLS;
COMMENT  -- A GARDEN VARIETY EXECUTABLE STATEMENT;
	
[2]	FINISH;

else	complain("Dryrot:case index= " & cvs(j) & " in scan!stmt.");

COMMENT  -- A GARDEN VARIETY NON-EXECUTABLE STATEMENT;

[3]	BEGIN  "NONEX"
	NTYPE_0;
	WHILE TYP1 neq ";" DO
		PASSTOKEN;
	PRINT1;SPACO_1;SCAN1;SEMICOL_1;SPRINT;
	END;

COMMENT -- A FORWARD OR EXTERNAL PROCEDURE DECLARATION;

[4]	BEGIN "FPROC"
	TERPRI;
	NTYPE_0;
	PLVL_0;
	WHILE (PLVL>0) or (TYP1 neq ";") DO
		BEGIN PRINT1;
		IF TYP1="(" THEN PLVL_PLVL+1
		ELSE IF TYP2=")" THEN PLVL_PLVL-1;
		SCAN1;
		END;
	PRINT1; SPACO_1;
	SPRINT; SEMICOL_1;
	SCAN1;
	END;

COMMENT  -- AN ACTUAL REAL-LIFE PROCEDURE DECLARATION;

[5]	BEGIN  "PROC"
	TERPRI;
	NTYPE_0;
	PLVL_0;
	WHILE (PLVL>0) or (TYP1 neq ";") DO
		BEGIN PRINT1;
		IF TYP1="(" THEN PLVL_PLVL+1
		ELSE IF TYP2=")" THEN PLVL_PLVL-1;
		SCAN1;
		END;
	PRINT1; SPACO_1;
	SCAN1;
	SPRINT;
	INDENT(CONIND);
	S1_CURCOUNT;
	CURCOUNT_NEXTCOUNTER;
	SCAN!STMT(1);
	UNDENT(CONIND);
	CURCOUNT_S1;
	END;

COMMENT  -- ERROR;

[6]	complain("ERROR IN STMT TYPING");


COMMENT ROUTINES FOR BLOCK AND CASE STATEMENTS;

COMMENT  -- BEGIN, A BLOCK OR COMPOUND STATEMENT;

[7]	BEGIN "BLOCK"
IFCR using!records THENC
			record!pointer (let!) old!let!head;
			record!pointer (class!) old!class!head;
ELSEC
			INTEGER OLDNLETS, OLDNRPC;
ENDC
	TERPRI;
	NTYPE_1;
	PRINT1; SPRINT; SCAN1;
	PASSCOMMENT;
	IF DOINDENT THEN INDENT(BLKIND);
IFCR using!records THENC
	old!let!head_ let!head;
	old!class!head_ class!head;
ELSEC
	OLDNLETS_ NLETS;
	OLDNRPC_NRPC;
ENDC
	WHILE (TYP1 neq TOKENCODE) or  not EQU(STR1,"END") DO
		SCAN!STMT(1);
IFCR using!records THENC
	let!head_ old!let!head;
	class!head_ old!class!head;
ELSEC
	NLETS_ OLDNLETS;
	NRPC_OLDNRPC;
ENDC
	IF DOINDENT THEN UNDENT(BLKIND) ELSE TERPRI;
	PRINT1; SPRINT; SCAN1;
	PASSCOMMENT;
	CHECKSEMI;
	TERPRI;
	END;

COMMENT  -- CASE STATEMENT;

[8]	BEGIN  "CASE"
	NTYPE_1;
	S1_0;
	TERPRI;
	WHILE (TYP1 neq TOKENCODE) or  not EQU(STR1,"OF") or (TYP2=EMRK) DO
		PASSTOKEN;
	PRINT1; SPRINT; INDENT(CONIND);
	SCAN1; NTYPE_0;
	PASSCOMMENT;
	IF not EQU(STR1,"BEGIN") THEN complain("NO BEGIN AFTER CASE" );
	PRINT1;SPRINT; SCAN1; INDENT(CONIND);
	DO
		BEGIN  "CASE1"
		TERPRI; SEMICOL_0;
		CURCOUNT_NEXTCOUNTER;
		PASSCOMMENT;
		WHILE TYP1="[" DO
			BEGIN DO 
				BEGIN PRINT1; SCAN1;
				END
			UNTIL TYP1="]";
			PRINT1; SCAN1
			END;
		if equ(str1,"ELSE") then begin print1; scan1; end;
		SCAN!STMT(1);
		S1_S1+CURCOUNT;
		END
	UNTIL SEMICOL=0;
	PASSCOMMENT;
	IF not EQU(STR1,"END") THEN complain("NO END AFTER CASE");
	UNDENT(CONIND); PRINT1; NTYPE_0; 
	SCAN1;
	CHECKSEMI;
	UNDENT(CONIND); CURCOUNT_S1;
	END;

COMMENT DO,DONE,RETURN,FOR,FOREACH,WHILE,GOTO;

COMMENT  -- DO STATEMENT;

[9]	BEGIN "DOSTMT"
	TERPRI; PRINT1; NTYPE_1; SPRINT;
	INDENT(CONIND);
	CURCOUNT_NEXTCOUNTER;
	SCAN1;
	SCAN!STMT(1);
	PASSCOMMENT;
	UNDENT(CONIND);
	IF  not EQU(STR1,"UNTIL") THEN complain("NO UNTIL AFTER DO");
	PRINT1; SCAN1;
	FINISH;
	TERPRI;
	CURCOUNT_NEXTCOUNTER;
	END;

COMMENT  -- DONE, CONTINUE, RETURN STATEMENTS;

[10]	BEGIN "DONE"
	FINISH;
	TERPRI;
	CURCOUNT_0;
	END;

COMMENT  -- FOR, AND FOREACH STATEMENTS;

[11]	BEGIN "FORST"
	TERPRI;
	NTYPE_1;
	WHILE  not EQU(STR1,"DO") DO
		PASSTOKEN;
	PRINT1; SPRINT;
	INDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	SCAN1;
	SCAN!STMT(1);
	UNDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	END;

COMMENT  -- WHILE STATEMENT;

[12]	BEGIN  "WHILE"
	TERPRI;
	CURCOUNT_NEXTCOUNTER;
	NTYPE_1;
	WHILE  not EQU(STR1,"DO") DO
		PASSTOKEN;
	PRINT1; SPRINT;
	INDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	SCAN1;
	SCAN!STMT(1);
	UNDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	END;

COMMENT  -- GO TO STATEMENT;

[13]	BEGIN "GOTO"
	FINISH;
	TERPRI;
	CURCOUNT_0;
	END;


COMMENT IF STATEMENT AND START!CODE, ALSO NULL STATEMENT, AND LET;

COMMENT  -- IF STATEMENT;

[14]	BEGIN "IFSTMT"
	TERPRI;
	S1_CURCOUNT;
	NTYPE_1;
	WHILE (TYP1 neq TOKENCODE) or  not EQU(STR1,"THEN") or (TYP2=EMRK) DO
		PASSTOKEN;
	PRINT1; SPRINT; SCAN1;
	INDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	S2_S1-CURCOUNT;
	SCAN!STMT(1); S1_CURCOUNT;
	PASSCOMMENT;
	IF (SEMICOL=0)  and EQU(STR1,"ELSE") THEN
		BEGIN UNDENT(CONIND); CURCOUNT_S2;
		PRINT1; SPRINT; SCAN1;
		INDENT(CONIND); SCAN!STMT(1);
		S2_CURCOUNT;
		END;
	UNDENT(CONIND);
	CURCOUNT_S1+S2;
	END;

COMMENT  -- START!CODE AND QUICK!CODE;

[15]	BEGIN "CODE"
	TERPRI;
	PRINT1; NTYPE_1; SPRINT; SCAN1; PASSCOMMENT;
	IF DOINDENT THEN INDENT(BLKIND) ELSE TERPRI;
	NTYPE_0;
	WHILE  not EQU(STR1,"END") DO
		BEGIN PRINT1;
		IF TYP1=";" THEN
			BEGIN  SCAN1; PASSCOMMENT;
			SPRINT; TERPRI;
			END
		ELSE SCAN1;
		END;
	IF DOINDENT THEN UNDENT(BLKIND) ELSE TERPRI;
	PRINT1; SPRINT; SCAN1; PASSCOMMENT;
	CHECKSEMI;
	TERPRI;
	END;

COMMENT  -- NULL STATEMENT NOT ENDING IN SEMICOLON;
COMMENT  -- COPIES ARE NEEDED FOR -- END, ELSE, AND UNTIL;

[16][17][18]
	BEGIN  "NULL1"
	STRING TSA;
	TSA_STR1A; STR1A_"  "; SPAC1_0;
	PRINT1;STR1A_TSA; SPAC1_1;
	NTYPE_1; SPRINT;
	SEMICOL_0;
	END;

COMMENT  -- ERROR;

[19]	BEGIN 
	complain("ILLEGAL USE OF OF");
	END;

COMMENT -- LET STATEMENT;

[20]	BEGIN "LET"
	STRING TSA;
	INTEGER J1;
	NTYPE_0;
	WHILE TYP1 neq ";" DO
	    BEGIN PRINT1; SCAN1; TSA_ STR1; PRINT1; SCAN1;
	    IF TYP1 neq  "=" THEN
		complain("BAD LET STATEMENT");

	    PRINT1;
	    SCAN1; J1_ LOOKR;
	    IF J1 neq 0 THEN
IFCR using!records THENC
		begin	record!pointer (let!) nl;
		nl_ new!record(let!);
		let!:name [nl]_ tsa;
		let!:val  [nl]_ j1;
		let!:link [nl]_ let!head;
		let!head_ nl; nl_ null!record;
		end;
ELSEC
		BEGIN NLETS_ NLETS+1;
		IF NLETS>20 THEN USERERR(0,0,"TOO MANY LET STMTS");
		LETS[NLETS]_ TSA;
		LETVAL[NLETS]_ J1;
		END;
ENDC
	    PRINT1;
	    SCAN1;
	    END;
	PRINT1; SPACO_1; SCAN1; SEMICOL_1; SPRINT;
	END;



[21]	BEGIN "RECORDCLASS"
IFCR using!records THENC
		record!pointer (class!) ncl;
	ncl_ new!record(class!);
	class!:name [ncl]_ str2;
	class!:link [ncl]_ class!head;
	class!head_ ncl; ncl_ null!record;
ELSEC
	IF (NRPC_NRPC+1)>40 THEN USERERR(0,0,"TOO MANY RECORD CLASSES");
	RPSTR[NRPC]_STR2;
ENDC
	TERPRI; NTYPE_0; PLVL_0;
	WHILE (PLVL>0) OR (TYP1 NEQ ";") DO
	   BEGIN PRINT1;
	   IF TYP1="(" THEN PLVL_PLVL+1
	   ELSE IF TYP1=")" THEN PLVL_PLVL-1;
	   SCAN1 END;
	PRINT1; SPACO_1; SPRINT; SEMICOL_1; SCAN1; END;

[22]	BEGIN "RPTR"
	COMMENT must scan past parenthesized class list, then reenter parser
	    loop in order to allow for record!pointer procedures;
	DO BEGIN PRINT1; SCAN1 END UNTIL TYP1=")"; PRINT1; SCAN1;
	NQ_3; GOTO KP END "RPTR"

COMMENT END OF THE VARIOUS STATEMENT ROUTINES;

		END;
	END "SCAN!STMT";



ifcr dynamic!storage thenc

record!pointer (program) procedure getCounters( integer chan, howMany;
						string fname );
begin	integer array counter[ 0 : howMany max 0 ];
	record!pointer (program) rslt;
if howMany leq 0
 then begin
	usererr(0,1,"getCounters: " & cvs(howMany) & 
			" counters in " & cvxstr(fname) );
	howMany_ 0;
      end
 else arryin( chan, counter[0], howMany );
counter[howMany]_ 0;
rslt_ new!record (program);
program:name [rslt]_ fname;
memory[location(counter)] swap
	memory[location( program:knt [rslt] )];
Comment put array in record, prevent de-allocation;
return( rslt );
end;

procedure kntloop;
begin "KNTLOOP"		record!pointer (program) program!chain;
			external procedure $recgc;
elsec
integer ifil,nfil;
own STRING ARRAY NAMES[1:10];
own INTEGER ARRAY STRT[1:11];
endc
COMMENT THE REST OF THE MAIN PROGRAM;

integer nknt;
LABEL MLO; COMMENT PUT THERE TO LOCATE LOOP IN DDT;

	NKNT_IKNT_0;
ifcr using!records thenc
	let!head_ null!record;
	class!head_ null!record;
elsec
	NLETS_ NRPC_ 0;
endc
ifcr dynamic!storage thenc
	current!program_ program!chain_ null!record;
	$recgc;		Comment garbage collect;
	program!chain_ new!record (program);
	current!program_ program!chain;
		Comment (a fake head for the chain);
elsec
	IFIL_ NFIL_ 0;
endc
COMMENT NOW READ IN THE COUNTER FILE;

	WHILE TRUE DO
		BEGIN	own integer array INP[1:4];
			integer n;
		ARRYIN(SRC,INP[1],4);
		IF SRCEOF THEN DONE;
		N_INP[4];
		N_-(N ash -18);		comment was: N_-(N%262144);
ifcr dynamic!storage thenc
		program:link [current!program]_
			getCounters( src, n, cvxstr(inp[1]) );
		current!program_ program:link [current!program];
		end;
	current!program_ program!chain;
elsec
		NAMES[NFIL_NFIL+1]_CVXSTR(INP[1]);
		STRT[NFIL]_NKNT_NKNT+1;
		IF NKNT+N>MXKTR THEN USERERR(0,0,
		  "TOO MANY COUNTERS, USE THE /#K SWITCH (YOU HAVE AT LEAST "&CVS(NKNT+N)&" COUNTERS)");
		ARRYIN(SRC,KOUNTR[NKNT],N);
		NKNT_NKNT+N-1;
		END;
	STRT[NFIL+1]_NKNT+1;
endc
	RELEASE(SRC);


COMMENT NOW READ IN THE LIST FILES AND PRODUCE THE 
 PROFILES.  THE LIST FILE NAMES ARE FOUND IN THE COUNTER
 BLOCK HEADERS WRITTEN OUT TO THE DISK AFTER EXECUTION;

	OPEN(SRC_GETCHAN,"DSK",0,2,0,SOURCECOUNT,SRCBRK,SRCEOF);
MLO:
ifcr dynamic!storage thenc
	while current!program_ program:link [current!program] do
		begin "SRCLOOP"		integer fl;
		iknt_-1;
		mxktr_ arrinfo(program:knt [current!program],2);
		current!file!name_ program:name [current!program];
elsec
	FOR IFIL_1 STEP 1 UNTIL NFIL DO
		BEGIN "SRCLOOP"	integer fl;
		current!file!name_ names[ifil];
		IKNT_STRT[IFIL]-1;
endc
		FL_-1; LOOKUP(SRC,current!file!name&
              IFCR DECSW THENC ".CRF" ELSEC ".LST" ENDC ,FL);
		IF FL THEN USERERR(0,0,"CAN'T FIND FILE-"&
				current!file!name &
                   IFCR DECSW THENC ".CRF" ELSEC ".LST" ENDC);
		HEADNG_HEAD1& current!file!name;
		OUT(OFILE,'14&'15&YES!BANG(HEADNG)&'15&'12&'12);
		NLINES_0;
		FIRSTSCAN_1; SCAN1;
		FIRSTSCAN_0; SCAN1;
		PASSCOMMENT;
		IF EQU(STR1,"ENTRY") THEN 
			BEGIN CURCOUNT_0; NTYPE_0;
			WHILE TYP1 neq ";" DO 
				BEGIN PRINT1; SCAN1 END;
			PRINT1;SPACO_1; SCAN1;
			SPRINT;
			END
		ELSE CURCOUNT_1;
		TERPRI;
		SCAN!STMT(0);
		TERPRI;
		CLOSE(SRC);
ifcr dynamic!storage thenc
		i_ mxktr - 1;
elsec
		I_STRT[IFIL+1]-1;
endc
		IF IKNT neq I THEN
			USERERR(0,1,CVS(ABS(IKNT-I))&(IF IKNT<I THEN
 			  " TOO FEW" ELSE " TOO MANY")&" COUNTERS FOUND FOR-"&
			  current!file!name);
		END "SRCLOOP";
	RELEASE(SRC);
	RELEASE(OFILE);
END "KNTLOOP";
COMMENT MAIN PROGRAM, EXECUTION STARTS HERE;

SCANTABLE['177]_DELIM;
ATOMINIT(",+-|()[]/^_&<>=*%;:{~"&'14&'177,
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!$0123456789@.'",
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!$0123456789@.'",
	'11&'12&'40,
	'177,
	"""",
	0);
COMMENT THE FOLLOWING IS NECESSARY SINCE SAIL DOES NOT ALWAYS CLEAR
THE LOW ORDER BIT IN THE LIST FILE;

FOR I_1 STEP 1 UNTIL 18 DO BREAKSET(I,NULL,"P");
SETBREAK(FINDFF,'14&'12,'15,"IPS");
SETBREAK(FINDSEMI,";",NULL,"IPA"); 
SETBREAK(FINDLF,'12,'15,"IPS");
SETBREAK(FINDTAB,'11,NULL,"IPS");

ON!ETIME_0;

HEAD1_"     PROGRAM PROFILE 				";
NT_0;
SETFORMAT(8,0);
BLANX_"                                                                         "&
  "                                                     ";
TABS_"									"&
  "								";
WHILE TRUE DO
	BEGIN "SUPERLOOP"
	NX!TFIL_0;
	WANTBIN_TRUE;
	WANTLST_FALSE;
	SOURCECOUNT_100;

COMMENT  FIRST OPEN COUNTER FILE AND LISTING FILE;

	COMMAND!SCAN;

COMMENT THE FOLLOWING SWITCHES ARE IMPLEMENTED:
	
	/nB	INDENT n SPACES FOR BLOCKS (default 4)
	/nC	INDENT n SPACES FOR CONTINUATIONS (default 2)
	/F	FILL OUT EVERY 4th LINE WITH .   .   .
	/I	IGNORE COMMENTS OTHER THAN STRING CONSTANTS
	/nK	MAKE COUNTER ARRAY OF SIZE n (default 200)
	/nL	MAXIMUM LINE LENGTH OF n (default 120)
	/N	DON'T FILL OUT EVERY 4th LINE WITH .   .   .
	/S	STOP (EXIT PROGRAM) AFTER THIS PROFILE
	/T	TELETYPE MODE = /1C/2B/80L/F
;

	MXKTR_200;
	CONIND_2;BLKIND_4;
	IGNCMT_STPFLG_0;
	FFLAG_1;
	MAXCOL_ 120;
	I_1;
	WHILE LENGTH(SWTSTR)>0 DO
		BEGIN TEMP_LOP(SWTSTR);
		CASE TEMP-1 OF
			BEGIN 
			BLKIND_SWTVAL[I];
			CONIND_SWTVAL[I];
			FFLAG_1;
			IGNCMT_1;
			MXKTR_SWTVAL[I];
			MAXCOL_SWTVAL[I];
			FFLAG_0;
			STPFLG_1;
			BEGIN
			  CONIND_1; BLKIND_2; MAXCOL_80; FFLAG_1;
			END;
			USERERR(0,0,"ILLEGAL SWITCH")
			END;
		I_I+1;
 		END;

	CONFIL_BLANX[1 FOR CONIND];
	CTRCOL_ (MAXCOL LAND '777777777770) -8;
	LASCOL_ CTRCOL-9;

	kntloop;	comment allocate counters and go;
	IF STPFLG THEN DONE;
	END "SUPERLOOP";
OUTSTR("
THAT'S ALL FOLKS
");
END "PROFILE";

    IYÆ