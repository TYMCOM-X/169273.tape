
UNIVERSAL HDRFIL
?ALWAYS__0
?FTDEBUG__1
define	liblow <FILEXX(<(FTSYS)LIBSAA.REL>,17)>
define	libhi  <FILEXX(<(FTSYS)HLBSAA.REL>,17)>
define SLOFIL <SIXBIT /SAILOW/>		;loader stub for segment
define FILXXX <SIXBIT /SAISGA/>		;segment name
define SGDEVC <SIXBIT /DSK/>
define SGPPNN <[SIXBIT /FTSYS/
		0]>
?LOCSYM__1		; WANT LOCAL SEGMENT SYMBOLS
define procsr <ASCIZ /FT-Sail: />	;FOR PRINTOUT OF PROCESSOR
define bailod <FILEXX(<(FTSYS)BAIL.REL>,15)>	;RESIDENCE OF BAIL
define baipds <FILEXX(<(FTSYS)BAIPDA.REL>,17)>	;JFR pd's FOR RUNTIMES
IFNDEF .JBVER < IFNDEF JOBVER < ?.JBVER__137 >> ;must be a constant
IFNDEF .JBREN < IFNDEF JOBREN < ?.JBREN__124 >> ;must be a constant
DEFINE JD ' (A) <
	IFNDEF .JB'A < 
		IFDEF  JOB'A < DEFINE .JB'A <JOB'A>>
		IFNDEF JOB'A < EXTERNAL .JB'A >
		>
	IFNDEF JOB'A < DEFINE JOB'A <.JB'A> >
>
JD (SA)
JD (VER)
JD (REN)
JD (UUO)
JD (SYM)
JD (FF)
JD (REL)
JD (41)
JD (DDT)
JD (CNI)
JD (TPC)
JD (APR)
JD (HRL)
JD (HGH)
JD (HVR)
JD (OPC)
SUBTTL	SAIL/GOGOL MACROS AND SWITCHES
DEFINE STSW (V,VL) <IFNDEF V,<?V__VL>>	;sets switch if not defined
DEFINE STDEF (NAME,DEFINITION) <IFNDEF NAME,<DEFINE NAME <DEFINITION>>>
FOR @# SITE IN (CMU,ITS,JPL,NIH,PARC,SRIAI,SUMEX,UOR,DEC) <
	DEFINE site <IFN site#SW,>
	DEFINE NO#site <IFE site#SW,>
  >
define def2 # (name,reason) <
	DEFINE name <IFN reason,>
	DEFINE NO#name <IFE reason,> 
  >
def2(TYMSHR,TYMSW)		;TYMSHARE code (names are not regular)
def2(STANFO,STANSW)		;SU-AI code (names are not regular)
def2(IMSSS,IMSSSW)		;IMSSS code (names are not regular)
def2(BAIL,BAISW)		;DEBUGGER STUFF
def2(GLOB,GLOBSW)		;global compiler (GLOBC) can service
def2(GLOC,GLOBC)		; from GLOB (global model)
def2(HACK,HACKSW)		;TEMPORARILY VERSION FOR STANFORD
def2(KI10,KI10SW)		;CPU IS A KI10 (or KL10)
def2(KL10,KL10SW)		;CPU IS A KL10
def2(LOW,LOWER)			;lower bootstrap for 2 seg thing (only used in runtime) 
def2(LEP,LEAPSW)		;this compiler understands LEAP
def2(NRC,NRCSW)			;NEW-STYLE RECORD DESCRIPTORS
def2(REC,RCDSW)			;RECORDS ARE CONDITIONAL UNTIL DEBUGGED BETTER
def2(REN,RENSW)			;Re-entrant output (comp), runtimes (runtim)
def2(RENC,RENCSW)		;The compiler itself is reentrant
def2(RGC,RGCSW)			;RECORD GARBAGE COLLECTION (INSTEAD OF REF CNT)
def2(SFDS,SFDLVL)		;Operating system supports SFDs 
def2(TENX,TENXSW)		;FOR TENEX (or TOPS-20) SYSTEMS
def2(UP,UPPER)			;upper segment code (only used in runtime)
def2(URHASH,URHSW)		;NEW LEAP HASH ROUTINES AND SEARCHES
def2(URLEAP,URLPSW)		;TRUE FOR DESCENDING ITEM ALLOCATION
def2(URSTAT,URSTSW)		;TRUE IF YOU WANT LEAP SEARCH STATISTICS
def2(XCOM,XCOMSW)		;COMPILER SAVE/RESTART (EXTEND) FACILITY
IFDEF AUXCAL,<STSW (TYMSW,1)>	;AUXCAL ONLY DEFINED AT TYMSHARE
IFDEF SPCWAR,<STSW(STANSW,1)>	;SPCWAR ONLY DEFINED AT STANFORD AI
IFDEF GTJFN, <STSW(TENXSW,1)>	;GTJFN on TENEX
IFDEF JGTJFN,<STSW(TENXSW,1)>	;JGTJFN on TOPS-20
STSW(TENXSW,0)			;normally non-tenex (over-ride follows)
FOR @# SITE IN (CMU,ITS,JPL,NIH,PARC,SRIAI,SUMEX,UOR,TYM,STAN,IMSS) <
	IFNDEF site#SW, <?site#SW__0> >
STANFO <
STSW (SIXSW,1)
?KI10SW__1
?KL10SW__1
?SFDLVL__0		;STANFORD DOESN'T HAVE SFD'S
>;STANFO	
CMU < ;**** EXTRA SWITCHES FOR CMU ******
DEFINE GGAS <IFN GASSW,>	;cmu version of global segment
DEFINE NOGGAS <IFE GASSW,>	;inverse
DEFINE GGGON <^^ GLOBSW__GASSW>	;
DEFINE GGGOFF <^^ GLOBSW __0>	;USED TO SELECT SOME OF SU-AI GLOB STUFF
STSW(GASSW,0)			;NOT USUALLY CMU GLOBAL
STSW(GLOBSW,0)			;CMU WILL DIDDLE THIS SWITCH DIRECTLY
?SFDLVL__0		 ;CMU DOESN'T HAVE SFD'S
>;CMU
IMSSS <;DEFAULT SETTINGS AT IMSSS
?TENXSW__1			;TENEX AT IMSSS
?KI10SW__1			;AND A KI
?SIXSW__1			;USE SIXBIT PPN'S FOR LOADER AT IMSSS
>;IMSSS
PARC <
?TENXSW__1			;TENEX AT PARC
?KI10SW__1
?SIXSW__0
>;PARC
JPL <
?TENXSW__1
?SIXSW__0
>;JPL
SRIAI <
?TENXSW__1			
?SIXSW__0
>;SRIAI
SUMEX <
?IMSSSW__1			;MOST IMSSS FEATURES
?SIXSW__0			;EXCEPT DONT USE SIXBIT
?TENXSW__1			;BUT IS TENEX
?KI10SW__1			;IS KI
>;SUMEX
UOR <
?DECSW __ 1			;DEC TOPS-10 MONITOR
?KL10SW__1			;IS KL
?STANSW __ 0			; NOT AT STANFORD
?GLOCSW __ 0			; NO GLOBAL MODEL
?GLOBSW __ 0			; NO GLOBAL MODEL STUFF
?URHSW __ 1			; USE NEW HASH TECHNIQUE
?URLPSW __ 1			; ALLOCATE ITEMS TOP DOWN
>;UOR
TYMSHR<
?SFDLVL__0			;NO SFD'S AT TYMSHARE
?KI10SW__1			;ALL KI'S
STSW(KL10SW,0)			;NO KL10 code for production (confusing)
>;TYMSHR
TENX <
?RENCSW__1			;WANT A RE-ENTRANT COMPILER
?RENSW__1			;WANT A RE-ENTRANT RUNTIME
?DECSW__0			;NOT A DEC SYSTEM
?STANSW__0			;IN FACT, EXPLICITLY NOT STANFORD
?GLOBSW__0			;NOT USUALLY GLOBAL FOR TENEX
?GLOBC__0			;
STSW(LOADVR,=54)			;TENEX SITES SEEM TO HAVE V. 54
?SFDLVL__0			;NO TENEX SITE HAS SFD'S
>;TENX
IFN STANSW!TENXSW!CMUSW!TYMSW, <STSW(DECSW,0)>
STSW (RAIDSW,STANSW!UORSW!TYMSW) ;RAID used for DDT, help it out
STSW (HACKSW,STANSW)	;ONLY AT STANFORD
STSW (RENCSW,0)		;NOT USUALLY A REENTRANT COMPILER
STSW (DECSW,1)		; USUALLY DEC 10-50 BASED SYSTEM
STSW (HEDSYM,0)		;USUALLY NOT A USER-TABLE SYMBOL GENERATOR
STSW (KL10SW,.CPU.-2)	;.CPU. IS 4 FOR KL, 2 FOR KI, 1 FOR KA, 0 FOR 6
STSW (KI10SW,.CPU.-1)	;(funny character '26 = ^V = XOR)
STSW (XCOMSW,1)		;COMPILER SAVE/RESTART USUALLY SUPPORTED
STSW (SFDLVL,5)		;NORMAL SITE ALLOWS SFDs
STSW (RCDSW,1)		; NORMAL SITE ALLOWS RECORDS
STSW (RGCSW,RCDSW)	; NORMAL SITE USES RECORD GARBAGE COLLECTION
STSW (NRCSW,1)		; USUALLY A NEW-STYLE RECORD SYSTEM (now) ****
STSW (GLOBSW,0)		;USUALLY NOT A GLOBAL SEGMENT BEING MADE
STSW (SIXSW,0)		;usually PPNs are not SIXBIT
STSW (BAISW,1)		;USUALLY ON (BAIL)
STSW (URLPSW,1)		; from 9 on default to ROCHESTER LEAP 
STSW (URHSW,URLPSW)	;	ROCHESTER LEAP NEEDS ROCHESTER HASH
STSW (URSTSW,0)		;GENERALLY DON'T WANT THIS
IFG URLPSW-URHSW,<	;IF URLPSW = 1 & URHSW = 0
	PRINTX	URLPSW REQUIRES URHSW [FAIL ERROR ON NEXT LINE]
	#SWERR
>
KL10<	?KI10SW__1		;NORMALIZE
>;KL10
NOKI10<	?KL10SW__0
>;NOKI10
FOR SWITCH IN (CMUSW,ITSSW,JPLSW,PARCSW,SRIAISW,SUMEXSW,UORSW,STANSW,TYMSW,IMSSSW,TENXSW,DECSW)
 <IFN SWITCH <
	PRINTS * SWITCH: ON *
>>
IFG STANSW+TENXSW+CMUSW+TYMSW-1,<	;AT MOST ONE OF THESE CAN BE SET
	PRINTX	SWITCH INCOMPATIBILITY [TOO MANY SITES TURNED ON]
	#SWERR
>
STSW(TSTSEG,0)
NOTENX <
DEFINE GSYSIN <>
?SYSIND__0
DEFINE FILEXX (str,len) <
	radix =10
	,len		;string
	point 7,[asciz /str/],-1
	radix =8
	>
IFN TSTSEG,<
stdef(filxxx,<SIXBIT /SAISGT/>)
stdef(slofil,<SIXBIT /SAILWT/>)
stdef(sgdevc,<SIXBIT /DSK/>)
STANFO <
stdef(sgppnn,<SIXBIT /  SAIL/>)
>;STANFO
?LOCSYM__1
?NOPROT__1
>;IFN TSTSEG
stdef(FILXXX,<SIXBIT /SAISGA/>)
stdef(SLOFIL,<SIXBIT /SAILOW/>)		;PRODUCTION SAIL
stdef(SGDEVC,<SIXBIT /SYS/>)
stdef(SGPPNN,<0>)
STSW(LOCSYM,0)		;DON'T WANT LOCAL SEGMENT SYMBOLS
STSW(NOPROT,0)		;DON'T WANT SEGMENT PROTECT IF NOT GLOBAL
stdef(procsr,<ASCIZ /SAIL: />)		;FOR PRINTOUT OF PROCESSOR
stdef(rpgfil,<SIXBIT /QQSAIL/>)		;FOR COMPIL PURPOSES
stdef(defext,<'SAI'>)			;DEFAULT EXTENSION
stdef(BKTFIL,<FILEXX(<BKTBLS.BKT>,10)>)	;Standard break tables(new format/name)
stdef(BKTDEV,<FILEXX(<SYS>,3)>)
stdef(liblow,<FILEXX(<SYS:LIBSAA>,10)>)	;REQUIRED LIBRARY
stdef(libhi,< FILEXX(<SYS:HLBSAA>,10)>)	; (HISEG VERSION)
BAIL<
stdef(bailod,<FILEXX(<SYS:BAIL.REL>,12)>)	;RESIDENCE OF BAIL
stdef(baipds,<FILEXX(<SYS:BAIPDA.REL>,14)>)	;JFR pd's FOR RUNTIMES
>;BAIL
stdef(opdev,<SIXBIT /SYS/>)	;DEVICE FOR OPCODE FILE
stdef(opname,<SIXBIT /2OPS2/>)	;NAME (EXTEN ALWAYS OPS)
stdef(opppn,<0>)		;WHERE IT'S AT
GLOB <
DEFINE FILXXX <SIXBIT /GLBSGA/>
DEFINE SLOFIL <SIXBIT /GLBLOW/>
DEFINE SGDEVC <SIXBIT /SYS/>
DEFINE SGPPNN <0>
?NOPROT__1
?LOCSYM__1
>;GLOB
CMU <
GGAS <	;OH WELL
DEFINE SGDEVC <SIXBIT/DSK/>
DEFINE FILXXX <SIXBIT/CONSEG/>
DEFINE SGPPNN <XWD 1305,60410>	
>;GGAS
>;CMU
>;NOTENX
TENX <
?SYSIND__2
define gsysin <
	MOVE	SYSIND,$OSTYP	; 0 for TENEX, 2 for TOPS20
>;
DEFINE FILEXX (tnxstr,tnxlen,t20str,t20len) <
	radix =10
	,tnxlen
	point 7,[ASCIZ /tnxstr/],-1
	,t20len
	point 7,[ASCIZ /t20str/],-1
	radix =8
	>
IFN TSTSEG,<
stdef(FILXXX,<FILEXX(<<SAIL>T-SAISGT.SAV>,18,<SAI:T-SAISGT.EXE>,16)>)
stdef(SLOFIL,<SIXBIT /SAILWT/>)
stdef(LIBLOW,<FILEXX(<LIBSAT.REL>,10,<LIBSAT.REL>,10)>)
?LOCSYM__1
?NOPROT__1
>;IFN TSTSEG
BAIL<
stdef(BAILOD,<FILEXX(<<SAIL>BAIL.REL>,14,<SAI:BAIL.REL>,12)>)
stdef(BAIPDS,<FILEXX(<<SAIL>BAIPDA.REL>,16,<SAI:BAIPDA.REL>,14)>)
>;BAIL
stdef(FILXXX,<FILEXX(<<SAIL>T-0-SAISGA.SAV>,20,<SAI:T-0-SAISGA.EXE>,18)>)
stdef(SLOFIL,<SIXBIT /LOWTSA/>)
stdef(SLOLOD,<ASCIZ/SYS:LOWTSA,/>)		;FOR INTERFACE TO LOADER
stdef(LIBLOW,<FILEXX(<<SAIL>LIBSAA.REL>,16,<SAI:LIBSAA.REL>,14)>)
stdef(LIBHI,< FILEXX(<<SAIL>HLBSAA.REL>,16,<SAI:HLBSAA.REL>,14)>)
IMSSS<
stdef(SDTLOD,<ASCIZ /,SDDTRL[S,AIL]/>)
>;IMSSS
IFE TSTSEG,<
stsw(LOCSYM,0)
stsw(NOPROT,0)
>;IFE TSTSEG
STSW(SEGPAG,630)		;PAGE WHERE THE SEGMENT STARTS
STSW(STARTPAGE,610)		;PAGE WHERE CHANNEL BUFFERS BEGIN
STSW(JFNSIZE,20)		;NUMBER OF CHANNELS ALLOWED
stdef(RUNLOD,<FILEXX(<<SUBSYS>LOADER.SAV>,18,SYS:LINK.EXE,12)>)
stdef(LODTFN,<FILEXX(LOA.TMP,7,LNK.TMP,7)>)
stdef(BKTFIL,<FILEXX(<<SAIL>BKTBLS.BKT>,16,BKTBLS.BKT,10)>)
stdef(BKTDEV,<FILEXX(DSK,3,SAI,3)>)
stdef(UDTFIL,<FILEXX(<<SAIL>UDDT.SAV>,14,<SYS:UDDT.EXE>,12)>)
stdef(OPFILE,<FILEXX(<<SAIL>3OPS3.OPS>,15,<SAI:3OPS3.OPS>,13)>)
>;TENX
STANFO <  ; ACTUALLY, NOT KEPT UP LATELY
>;STANFO
II__1
FOR @' JJ IN (HEAD,SAIL,PARSE,PDEFS,PRODS,SUBRS,SMTB,SYM,GEN,<ARRAY>
,EXPRS,STATS,LEAP,TOTAL,COMSER,GOGOL,STRSER,IOSER,LEPRUN,MESPRO,WRDGET) <
?..'JJ__II
II__II1
>
IFDEF SETLST,<SETLST>
IFNDEF ..LIST,<
..LIST__0
FOR @' JJ IN (HEAD,SAIL,PARSE,SYM,GEN,ARRAY,EXPRS,STATS,LEAP,<TOTAL>
,COMSER,GOGOL,STRSER,IOSER,LEPRUN,MESPRO,WRDGET) <
?..LIST__..LIST!..'JJ
>
>;ifndef ..list
IFDEF SETLS2,<SETLS2>
DEFINE LSTON ' (JJ) <
	XLIST
IFN ..LIST & ..'JJ,<
	LIST>
>
	LSTON	(HEAD)
DEFINE DSCR <COMMENT  > ; FOR DIRECTORY MAKER
DEFINE GEN <IFE .NOGEN,<LALL>>
DEFINE NOGEN <XALL>
?.NOGEN__1	;DON'T EXPAND MACROS AT ALL AFTER FIRST NOGEN
	NOGEN
DEFINE IFNB (X) <IFDIF <><X>,>
DEFINE IFB (X) <IFIDN <><X>,>
NOTENX <
?DSPLEN__=280	;LAST CHANGED 2-8-77, FROM 260
>;NOTENX
TENX <
?DSPLEN__=350	;LAST CHANGED 12-03-79, FROM 330  (SDD)
>;TENX
GLOB <
?DSPLEN__DSPLEN+=50 ; SINCE THIS TAKES MORE
>;GLOB
DEFINE HERE(X) <
UP <
	FQQQQ __ .
	USE DSPCH	;SO THAT THE LABELS HAVE THE SAME ADDRESS
^^ X :	JRST	FQQQQ
IFGE .-DSPBAS-DSPLEN, <
PRINTS / Dispatch vector size exceeded, bump DSPLEN
/
>;
	USE
>;UP
NOUP <
^^ X :			;IF NOT MAKING AN UPPER SEGMENT, DOES NOT MATTER.
>;NOUP
>
DEFINE HEREFK (X,XFAKE) <
UP<
^^ XFAKE:		; A FAKE LABEL (FELLOW WILL HAVE REAL THING IN SPARES
>;UP
NOUP <
HERE(X)			;ONLY MATTERS IF MAKING A SEGMENT
>;NOUP
>
DEFINE SETCOR (SIZE,FIRST,LAST) <
	MOVE	C,SIZE
	PUSHJ	P,CORGET
	ERR	<CAN'T GET CORE FOR FIRST ALLOCATION>
	IFDIF <FIRST><>, <MOVEM	B,FIRST>
	IFDIF <LAST><>,<
		ADD	C,B
		MOVEM	C,LAST
>>
DEFINE DATA (MSG) <
	USE	VBLS
	IFGE	.-DBASE-DSIZE,<
	PRINTX	DATA AREA TOO SMALL [you will get a FAIL error on next line]
	#DATERR
>>
DEFINE TABLEDATA (MSG) <
	ZERODATA ()
>
DEFINE TABCONDATA (MSG) <
	DATA ( )
>
DEFINE ZERODATA (MSG) <
	USE	ZVBLS
	IFGE	.-ZBASE-ZSIZE,<
	PRINTX	ZEROED DATA AREA TOO SMALL [you will get a FAIL error on next line]
	#DATERR
>>
DEFINE BITDATA (MSG) <	USE>
DEFINE BITDDATA (MSG) <	USE>
DEFINE BIT2DATA (MSG) <	USE>
DEFINE BITD2DATA (MSG) < USE>
DEFINE ACDATA (MSG) <	USE>
DEFINE AC2DATA (MSG) <	USE>
DEFINE ENDDATA <
IFDEF ZBASE, <
	DATA ()		;CHECK
	ZERODATA ()		;CHECK
	USE
>>
DEFINE LEVPOINT(AD)< POINT DLFLDL,AD,35-LLFLDL>
DEFINE TRPCAL (P1,P2,P3,P4,ADR) <
BEGIN
	SKIPN	ADR
	 JRST 	 NOTRP
CMU <
	GGGON ;
>;CMU
GLOB <
	PUSH	P,USER
	MOVE	USER,GOGTAB	;IT MAY HAVE BEEN GLUSER
>;GLOB
	PUSH	P,TEMP
	PUSH	P,UUO1(USER)
	MOVEI	TEMP,.TRACS
	BLT	TEMP,.TRACS+11
	MOVE	TEMP,-1(P)
	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	PUSHJ	P,@ADR
	MOVSI	TEMP,.TRACS
	BLT	TEMP,11
	POP	P,UUO1(USER)
	POP	P,TEMP
GLOB <
	POP	P,USER		;GET IT BACK
>;GLOB
CMU <
	GGGOFF			;DELSELECT GLOBAL STUFF
>;CMU
NOTRP:
BEND
>;END TRPCAL DEF
DEFINE MOVEWI (I,J) <
		MOVEI TEMP,J
		MOVEM TEMP,I
>
DEFINE MOVEW (I,J) <
		MOVE	TEMP,J
		MOVEM	TEMP,I
>
DEFINE MOVE6 (I,J) <
		MOVE	TEMP,[SIXBIT /J/]
		MOVEM	TEMP,I
>
DEFINE MOVEI7 (I,J) <
		MOVEI	TEMP,[ASCIZ /J/]
		MOVEM	TEMP,I
>
DEFINE LOAD6 (I,J) <
		MOVE	I,[SIXBIT /J/]
>
DEFINE LOADI7 (I,J) <
		MOVEI	I,[ASCIZ /J/]
>
DEFINE PWORD (A) <
	POINT	36,A,35>
DEFINE PLEFT (A) <
	POINT	18,A,17>
DEFINE PRIGHT (A) <
	POINT	18,A,35>
DEFINE PCHAR (A) <
	POINT	7,A,35>
DEFINE IPWORD (A) <
	POINT	36,A>
DEFINE IPLEFT (A) <
	POINT	18,A>
DEFINE IPRIGHT (A) <
	POINT	18,A,17>
DEFINE IPCHAR(A) <
	POINT	7,A>
DEFINE SAVACS (L) <
 FOR II IN  L ,<
	PUSH	P,II
>>
DEFINE RESTACS (L) <
FOR II  IN  L, <
	POP	P,II
>>
NOTENX <
NOSTANFO <
DEFINE CALL6 ' (I,J) < CALLI	IFB(J) <U'I ;else> IFNB(I) <I,> U'J
>
>;NOSTANFO
STANFO <
DEFINE CALL6 ' (I,J) <
	IFB(J) < I;> J IFNB(I) <I,>
>
>;STANFO
NOSTANFO <
DEFINE CX ' (Y,Z) <
?U'Y__Z
>
	CX RESET,0	;0 RESET IO
	CX DDTIN,1	;1 EXT-GET DDT CHAR.
	CX SETDDT,2	;2 SETDDT LOC IN PROTECTED JOB DATA
	CX DDTOUT,3	;3 EXT:SEND DDT CHAR.
	CX DEVCHR,4	;4 DEVICE CHARACTISTICS
	CX DDTGT,5	;5 GET DDT MODE
	CX GETCHR,6	;6 DEVICE CHAR.(DIFF. NAME)
	CX DDTRL,7	;7 RELEASE DDT MODE
	CX WAIT,10	;10 WAIT TILL DEVICE INACTIVE
	CX CORE,11	;11 CORE UUO
	CX EXIT,12	;12 EXIT
	CX UTPCLR,13	;13 CLEAR DEC TAPE DIRECTORY 
	CX DATE,14	;14 GET DATE
	CX APRENB,16	;16 ENABLE APR FOR TRAPPING
	CX SWITCH,17	;20 RETURN DATA SWITCHES
	CX REASSIGN,21	;21 REASSIGN DEVICE TO ANOTHER JOB
	CX TIMER,22	;22 RETURN JIFFY CLOCK TIME
	CX MSTIME,23	;23 RETURN TIME OF DAY IN MS
	CX GETPPN,24	;24 RETURN PROJECT-PROGRAMMER NUMBER
	CX TRPSET,25	;25 SET PI TRAP LOC, AND USER IO
	CX TRPJEN,26	;26 DISMISS INTERRUPT TO EXEC MODE
	CX RUNTIM,27	;27 RETURN TOTAL JOB RUNNING TIME
	CX PJOB,30	;30 RETURN JOB NUMBER
	CX SLEEP,31	;31 SLEEP FOR N SECONDS, THEN RETURN TO USER
	CX SETPOV,32	;32 SET PUSH DOWN OVERFLOW TRAP
	CX PEEK,33	;33 PEEK INTO SYSTEM CORE.		;JS
	CX GETLIN,34	;34 GET NAME OF TTY
	CX RUN,35	;35 RUN COMMAND
	CX SETUWP,36	;36 SET USER WRITE PROTECT
	CX REMAP,37	;37 REDO CORE MAP
	CX GETSEG,40	;40 GET SEGMENT
	CX GETTAB,41	;41 GETTAB ILLEGAL AT STANFORD.
	CX TMPCOR,44	;44 TMPCOR manipulations.
>;NOSTANFO
>;NOTENX
DEFINE OP1 &(OPR,MS,ACC)  <
	IFIDN <ACC><>, <II__0>
	IFDIF <ACC><>, <II__ACC>
	OPR&. II,[ASCIZ /MS/]
>
FOR OP  IN  (ERR,IOERR) <
DEFINE OP (MSG,AC,ADDR) <
	IFIDN	<ADDR><>,<OP1 (OP,<MSG>,AC)>
	IFDIF <ADDR><>,<JRST	[OP1 (OP,<MSG>,AC)
			   JRST	ADDR ]>
>>
DEFINE CORERR(MSG) < JRST [	PUUO	3,[ASCIZ /MSG
/]
NOTENX <
				HALT	.	;DOT IN LITERALS REFERS TO THE
>;NOTENX
TENX <
				JSYS	HALTF
>;TENX
							]>
DEFINE ERRPRI (X) <
	PUSH	P,A
	MOVEI	A,[ASCIZ /X
/]
	PUSHJ	P,PRINT.
	POP	P,A
>
DEFINE PRINT (X) <
	PUUO 3,[ASCIZ /X/]
>
DEFINE TERPRI (X) <
	PUUO	3,[ASCIZ /X
/]>
DEFINE SPRINT(X) <	;SAFE PRINT, BEFORE UUO SET UP
	TTCALL 	3,[ASCIZ /X/]
>
DEFINE MAKCDB &  (CHN,NAM,MODD,I,O)  <
NAM&CDB:
NAM&MOD: MODD			;DATA MODE
NAM&DEV: 0			;DEVICE NAME IN SIXBIT
NAM&HED:
	IFN O,<XWD NAM&HDR,0>	;BLOCK HEADER POINTER
	IFE O,<XWD NAM&HDR,NAM&HDR>
NAM&HDR: 0			;I/O HEADER BLOCK
NAM&PNT: 0			;I/O BYTE POINTER
NAM&CNT: 0			;I/O CHAR COUNT
^NAM&FIL: 0			;I/O FILE NAME
^NAM&EXT: 0			;I/O EXTENSION
^NAM&PPN: 0			;I/O PPN
NAM&OP:	OPEN	CHN,NAM&CDB	;OPEN INSTRUCTION
NAM&NT:
notymshr <
	IFN I,<LOOKUP CHN,NAME>
	IFE I,<ENTER  CHN,NAME>
>;notymshr
tymshr <
	IFN I,<LOOKUP CHN,IODCNT>
	IFE I,<ENTER CHN,IODCNT>
>;tymshr
NAM&SPC:
	IFN O,<OUTBUF CHN,O>
IFE O,<
NOSTANFO <
	 IFIDN <NAM> <SRC>, <
		PUSHJ P,[MOVEI TEMP,.+1 ; PTR TO DESCRIPTOR, CALL UINBF ROUTINE
			 JRST	UINBF] >
	 IFDIF <NAM> <SRC>, <INBUF CHN,I>
>;NOSTANFO
STANFO <
		    UINBF CHN,.+1
>;STANFO
>;IFE O
NAM&BFS: IFN O,<O>
	IFE O,<I>	;# OF BUFFERS
	202		;MAKE BIGGER BUFFERS THAN NORMAL (INPUT ONLY)
SFDS<
NAM&PTH:	BLOCK 4+SFDLVL	;PLACE FOR PATH TO GO
> ;SFDS
>; end MAKCDB definition
DEFINE CHKCHN (AA,ROUTIN) & <
		TRZE	AA,777760	;ZERO BITS AND TEST VALID
		ERR <ROUTIN&: INVALID CHANNEL NUMBER>
>
DEFINE TSTERR (CHAN) <
		STATZ CHAN,740000 ;ANY ERRORS?
>
DEFINE TSTEOF (CHAN,EOFADD) <
		STATZ CHAN,20000  ;END OF FILE?
		JRST EOFADD	  ; YES
>
DEFINE SETNIT <
	MOVE	TEMP,[PUSHJ P,%UUOLNK]	;MAKE SURE WE CAN DO UUOS
	MOVEM	TEMP,41
	MOVE	P,ALLPDP	;AND PUSHJ'S
>
DEFINE SETPOV (AC,STR) <
 IFNB(STR) <MOVEI TEMP,[ASCIZ ?STR?]>	;GET VALUE
 IFB(STR) <MOVEI TEMP,0>
 II__(AC+17)&17			;BETWEEN 0 AND 17
 JJ__II-(2*(II/2))		;ODD OR EVEN
 IFE JJ,<HRLM TEMP,POVTAB+(II/2)>	;EVEN-- LEFT
 IFN JJ,<HRRM TEMP,POVTAB+(II/2)>	;ODD -- RIGHT
>;SETPOV
DEFINE OPTSYM(SYM)<
	MOVE	TEMP,[RADIX50 50,SYM]
	PUSHJ	P,OPTSY.
>
DEFINE BIT(NAME,BITT) <IFDIF <NAME><SPARE>,<?NAME__BITT>>
DEFINE DEFTBS <
	BIT	(RES,400000)	;RESERVED WORD
	BIT	(CNST,200000)	;CONSTANT ENTRY
	BIT	(SPARE,100000)	;****
	BIT	(INTRNL,40000)	;INTERNAL SYMBOL (SYMBOL EXPORTED)
	BIT	(EXTRNL,20000)	;EXTERNAL SYMBOL (STORAGE FOUND ELSEWHERE)
	BIT	(MPBIND,10000)	;MATCHING PROCEDURE OR BINDING ITEMVAR
	BIT	(VALUE,4000)	;FORMAL PARAMETER CALL BY VALUE
	BIT	(REFRNC,2000)	;FORMAL PARAMETER CALL BY REFERENCE
	BIT	(CONOK,1000)	;OK TO CALL INTRINSIC WITH CONST ARGS AT COMPTIME
	BIT	(SIMPLE,400)	;FOR DISPLAY SYSTEMS ONLY
	BIT	(MESSAGE,200)	;A MESSAGE PROCEDURE !!!!!(STANFORD ONLY).
	BIT	(OWN,100)	;OWN VARIABLE ?
	BIT	(ANYTYP,40)	;ANYTYPED VARIABLE (USED IN PROCEDURE CALLS)
	BIT	(SAFE,20)	;SAFE -- FOR ARRAYS AND SUCH.
	BIT	(DEFINE,10)	;DEFINED MACRO IDENTIFIER
	BIT	(RECURS,4)	;THIS ROUTINE IS REENTRANT
	BIT	(BILTIN,2)	;IF ON IN TBITS, DON'T SAVE AC'S ON CALL.
	BIT	(SBSCRP,1)	;SUBSCRIPED VARIABLE (ARRAY)
	BIT	(INPROG,400000)	;PROCEDURE BEING DEFINED, KEEP FIXUP CHAIN
	BIT	(GLOBL,200000)	;GLOBAL LEAP VARIABLE
	BIT	(FORTRAN,100000);FORTRAN PROCEDURE (EXTERNAL)
	BIT	(FORWRD,40000)	;FORWARD PROCEDURE OR LABEL
	BIT	(PROCED,20000)	;PROCEDURE
	BIT	(SHORT,10000)	;SHORT INTEGER OR SHORT REAL
	BIT	(ITMVAR,4000)	;LEAP ITEMVAR
	BIT	(PNTVAR,2000)	;RECORD POINTER VARIABLE
	BIT	(BOOLEAN,1000)	;BOOLEAN VARIABLE ?? (SAME AS INTEGER FOR NOW
	BIT	(ITEM,400)	;LEAP ITEM
	BIT	(STRING,200)	;A FHQ STRING
(LPARRAY,100)	;TYPE OF THIS ITEM IS ARRAY
	BIT	(SET,40)	;LEAP SET
	BIT	(LABEL,20)	;LABEL
	BIT	(LSTBIT,10)	; COMPLEX NUMBER ?? (NOT IMPLEMENTED)
	BIT	(DBLPRC,4)	; DOUBLE PRECISION NUMBER ?? (NOT IMPLEMENTED)
	BIT	(FLOTNG,2)	;REAL NUMBER
	BIT	(INTEGR,1)	;INTEGER NUMBER
	BIT	(KEEP,1)	;DO NOT FLUSH TYPE AHEAD
	BIT	(QUIET,2)	;DO NOT PRINT MESSAGES
	BIT	(NUMBS,4)	;DO PRINT THE "CALLED FROM .." STUFF
	BIT	(LOGGIN,10)	;SEND MESSAGES TO LOG FILE
	BIT	(CONT,20)	;CONTINUABLE ERROR
	BIT	(AUTO,40)	;AUTOMATIC CONTINUATION MODE
	BIT	(LOGOPN,100)	;LOG FILE IS CURRENTLY OPEN
	BIT	(ERRNOW,200)	;WE ARE CURRENTLY IN THE MIDDLE OF AN ERR. UUO
	BIT	(MINUS,400)	;WE JUST SAW A MINUS!
	BIT	(MADEPT,1000)	;WE HAVE ALREADY MADE A BYTE POINTER FOR FAKETTY
	BIT	(BUFOPN,2000)	;HE HAVE A BUFFER FOR DUMP MODE LOGGING
>
DEFTBS		;DEFINE THE TBITS
?FNYNAM __ RECURS 		;EXTERNAL+OWN+FNYNAM MEANS EXT REQ IS FOR
DEFINE FIX <.fatal  FIX opcode unchanged here!! (error coming)
	>;to catch bad use of FIX (ie ambiguous)
FLOAT_  2B8	OPDEF	FLOAT	[2B8]
FIXUUO_ 3B8	OPDEF	FIXUUO	[3B8]
IOERR._ 4B8	OPDEF	IOERR.	[4B8]
ERR._   5B8	OPDEF	ERR.	[5B8]
SIXPNT_ 6B8	OPDEF	SIXPNT	[6B8]
ARERR_  7B8	OPDEF	ARERR	[7B8]
RECUUO_10B8	OPDEF	RECUUO	[10B8]	;;%BI% --! RECORDS
DECPNT_11B8	OPDEF	DECPNT	[11B8]
OCTPNT_12B8	OPDEF	OCTPNT	[12B8]
ERRSPL_13B8	OPDEF	ERRSPL	[13B8]	;;%CJ% JFR 7-20-75
SNGL_  14B8	OPDEF	SNGL	[14B8]
DFIX_  16B8	OPDEF	DFIX	[16B8]	;SDD Long real to integer
DFLOAT_17B8	OPDEF	DFLOAT	[17B8]	;SDD integer to long real
ADJUBP_20B8	OPDEF	ADJUBP	[20B8]	;SDD adjust byte pointer
TENX <
PUUO_15B8	OPDEF	PUUO	[15B8]
>;TENX
NOTENX <
PUUO_<TTYUUO>	OPDEF	PUUO	[TTYUUO]
>;NOTENX
		OPDEF	TTCALL	[TTYUUO]
STANFO <
PDPFIX_<KAFIX>	OPDEF	PDPFIX	[KAFIX]
>;STANFO
DMOVE_120B8	OPDEF	DMOVE	[120B8]
DMOVEM_124B8	OPDEF	DMOVEM	[124B8]
DMOVN_121B8	OPDEF	DMOVN	[121B8]
DMOVNM_125B8	OPDEF	DMOVNM	[125B8]
FIXR_126B8	OPDEF	FIXR	[126B8]
FLTR_127B8	OPDEF	FLTR	[127B8]
KIFIX_122B8	OPDEF	KIFIX	[122B8]
ADJSP_105B8	OPDEF	ADJSP	[105B8]
DFAD_110B8	OPDEF	DFAD	[110B8]
DFSB_111B8	OPDEF	DFSB	[111B8]
DFMP_112B8	OPDEF	DFMP	[112B8]
DFDV_113B8	OPDEF	DFDV	[113B8]
DADD_114B8	OPDEF	DADD	[114B8]
DSUB_115B8	OPDEF	DSUB	[115B8]
DMUL_116B8	OPDEF	DMUL	[116B8]
DDIV_117B8	OPDEF	DDIV	[117B8]
JFOV_<JFCL 1,0>	OPDEF	JFOV	[JFCL 1,0]
		OPDEF	TRZ	[ANDCMI]
		OPDEF	TRC	[XORI]
		OPDEF	TRO	[IORI]
STANFO <
DPYOUT_703B8	OPDEF	DPYOUT	[703B8]
DPYCLR_701B8	OPDEF	DPYCLR	[701B8]
UINBF_704B8	OPDEF 	UINBF	[704B8]
?SEGSIZUUO 	_ 400022	;GET SIZE OF SECOND SEGMENT.
?CORE2UUO	_ 400015	;GET SOME MORE SECOND SEGMENT.
?GLBAR		__ 1000		;CURRENT LENGTH OF GLOBAL MODEL AREA.
>;STANFO
SUBTTL	SAIL/GOGOL USER TABLE DESCRIPTION
DEFINE XX (SYMBOL,SIZE,BACKUP) <
	?SYMBOL__LOCAT
IFN HEDSYM,<
	ENTRY	SYMBOL			;FOR HEAD.REL SYMBOL FILE
>;IFN HEDSYM
	LOCAT__LOCAT+1
	IFDIF<SIZE><>< LOCAT__LOCAT+SIZE-1>
	IFDIF<BACKUP><>< LOCAT__LOCAT-BACKUP>
>
LOCAT__0		;MAKES SYMBOLS ABSOLUTE
 XX CLER,,1
 XX UUO1	;TRADITIONAL LOC FOR GOGOL RETRN ADRS FOR ERROR MSGS.
 XX STRLNK
 XX SPLNK	;LINK END FOR SPACE ALLOCATION.
 XX SETLNK	;LINK END FOR SETS.
 XX SGROUT	;LINK UP STRING DSCRPTR GENERATOR ROUTINES HERE
 XX KNTLNK	;PROFILE COUNTER LINK END
 XX STWCRL	;HEAD of "Width Control Records" list
 XX STWCRA	;active "Width Control Record" 0 if none selected, 
 XX STLIST	;HEAD OF LIST OF STRING SPACES
 XX TOPBYTE	;NEXT FREE BYTE
 XX REMCHR	;-REMAINING FREE CHARS
 XX SGLIGN	;ON IF MUST BE ALIGNED TO FW BDRY (COMPILER ONLY).
 XX CHANS,20
 XX BKTPRV		;0 for UNPRIVILEGED, non-0 for PRIVILEGED. 
 XX BKTPTR,4,,		;POINTERS TO BLOCKS OF 18 BREAKTABLES EACH
     ?BRKTBL__0		;BREAK CHAR TABLE (entries are is.omit/is.break)
	?BKOBND__BRKTBL-1;Break for chars not in table (=omit/break)
	?BKDISP__BKOBND-1;BREAK CHAR DISPOSITION Word(0/0=S,1/0=A,0/1=R)
	?BKOMCV__BKDISP-1;"must copy" WORD= OMIT speedup/Conversion used
	?BKLCZR__BKOMCV-1; "lowerCase", "Z-mode"(use brktbl+0 on INPUT)
	?BKTOKN__BKLCZR-1; for "token" style scanning 
	?BKJFFO__BKTOKN-1;RESERVATION WORD= RESERVED/INITIALIZED
	?LNMSTB__BKJFFO-=19	;LINE NUMBER DISPOSITION,,character mask
     ?BKTOVH__-LNMSTB	;number of "overhead words" in table (fixed len)
XX  TTYCVT		;neg means tty input to u-case, pos means l-case
XX  FSTATS		; FOR GETSTS
 XX PDL		;IOWD SIZE,BASE  FOR SYSTEM PDL
 XX SPDL	;IOWD SIZE,BASE  FOR STRING PDL
STANFO <
XX  ZAPBEG,,1	;BEGINNING OF SECOND SEGMENT COPY OF STUFF.
>;STANFO
CMU <
XX  ZAPBEG,,1	;JUST LIKE SU-AI
>; CMU
STANFO <
 XX CURMES		;CURRENT MESSAGE.
>;STANFO
 XX MAXITM		;CURRENT TOP ITEM NUMBER.
 XX OLDITM		;LINKED LIST OF OLD ITEMS (DUMP HEAP).
 XX INFOTAB		;POINTER TO "GOOD POINTER" BLOCK OF CORE.
 XX DATAB		;POINTER TO DATUM AREA.
 XX HASTAB		;POINTER TO THE LEAP HASH TABLE.
 XX FP1			;FREE STORAGE -- 1 WORD.
 XX FP2			;FREE STORAGE -- 2 WORDS.
 XX HASMSK		;THE MASK FOR HASHING INTO OUR HASH SPACE.
URHASH <
XX RMASK1		;NEW MASK FOR MODIFIED LEAP ROUTINES
XX RMASK2
XX RMASK3
XX RMASK4		;END OF NEW MASKS (3/15/76 --
>;URHASH
URLEAP <
XX BRACKL		;POINTER TO LIST OF BRACKETED TRIPLE BLOCKS
>;URLEAP
 XX HASHP		;FOR PNAMES. XWD NEXT FREE ARRAY ENTRY,ARRAY BASE.
 XX MKBP		;MAKE BREAK-POINT
 XX ERBP		;ERASE BREAK-POINT
 XX PUBP		;PUT BREAK-POINT (NOT IMPLEMENTED)
 XX REBP		;REMOVE BREAK-POINT.(NOT IMPLEMENTED)
 XX ITMTOP		;MAXIMUM PERMISSIBLE ITEM NUMBER.
 XX LEABOT		; PTR TO SEARCH CONTROL BLOCK FOR DERIVED SETS ERASE. 
 XX FRLOC		; PTR TO CURRENT ACTIVE FOREACH CONTROL BLOCK POINTER
 XX SCBCHN		; PTR TO CHAIN OF ABANDONED SCB'S
 XX FREITM	;NUMBER OF FREE ITEMS REMAINING
 XX ARYDIR	;FOR TELLING FOUR ARRAY ROUTINES WHICH END IS UP.
 XX ARYLS	;A LINKED LIST (LUCKILY) OF STRING ARRAYS IN LEAP, AND SO FORTH.
XX BLKTAB,3,3	;BASE OF BLOCK CONTROL TABLE
   XX LOWC	;LOW LIMIT OF ALLOCATABLE "BLOCK" CORE
   XX TOP	;UPPER LIMIT OF SAME
   XX FRELST	;POINTER TO BLOCK FREE STORAGE LIST
 XX XPAND	;PERMISSION TO EXPAND IN CORREL IF 0
 XX ATTOP	;REQUEST TO ALLOCATE OFF TOP OF CORE IF NON-0
 XX NOSHRK	;IF ON, CORREL NOT GIVEN PERMISSION TO SHRINK CORE
STANFO <
 XX USCOR2	;IF ON, CORGET WILL USE CORE2 ROUTINES.
>;STANFO
 XX BUFACS,10,,	;FOR BUFFER ALLOCATOR
STANFO <
XX ZAPEND,,1	;END OF SECOND SEGMENT AREA.
>;STANFO
CMU <
XX USCOR2		;THE COPYCATS
XX ZAPEND,,1		;ditto ZAPBEG
>;CMU
 XX STBUCK,1,1	;USED IN STRING GC TO KEEP TRACK OF BLOCKS
   XX OFFSET		;Distance to move a string space, see STRNGC
 XX STINCR		;String space increment size, see STRNGC
 XX STREQD		;String space threshold size, see STRNGC
 XX SGCCNT		;NUMBER OF TIMES STRNGC HAS BEEN CALLED
 XX SGCTIME		;Time of last GC if non-zero, else not enabled
 XX SGCTOTAL		;Total GC time while enabled (set SGCTIME -1 to enable)
 XX SGCNUM		;Number of strings collected last GC
 XX SGCWASTE		;Number of wasted words after last GC
 XX SRELOC
 XX CODAC		;SAVE AC 1 OVER CALLS ON "CODE" RUNTIME ROUTINE
 XX WDTH		;GLOBAL WIDTH FOR STRING CONVERSION ROUTNES
 XX DIGS		; "" FOR # OF DECIMAL DIGITS
 XX CDBLOC	;IF CHNL IS A CH #, @CDBLOC(USER) GETS ITS CDB ADDR
 XX FNAME	;ENTER-LOOKUP TABLE
 XX EXT
 XX WD3
 XX PRPN
 XX LONGWD	;LONG FORM LOOKUPS AND ENTERS POKE THIS
 XX LONG2	; AND THIS -- FILEINFO ROUTINE GIVES TO USER
 XX PROJ		;USED BY FILNAM ROUTINE
TYMSHR<
XX FUSER
XX FUSER1	;TYMSHARE USER NAMES
>;TYMSHR
 XX RACS,13,,	;RE-ENTRANT ROUTINES SAVE HERE
 XX SGACS,14,,	;AVAILABLE ANY TIME IF YOU ARE NOT
 XX STACS,14,,	;YET ANOTHER AC SAVE AREA
 XX PGNNFL
?NPRIS__20	;NUMBER OF PRIORITIES
 XX PRILIS,NPRIS,, 	;PRIORITY LIST HEADERS
 XX GGDAD		;THE BASE FOR THE MAIN PROCESS (IF HAVE ONE)
 XX TIMER		;COUNTED DOWN FOR CLOCK INTERRUPTS
 XX SCHDRQ		;SET non-0 FOR A SCHEDULER REQUEST
 XX STKURT		;PLACE FOR STACKUNWINDER RETN ADRS
 XX INTQWP		;INTERRUPT NOTICE BUFFER WRITE PTR
 XX INTQRP		;READ PTR
 XX INTQWT		;TOP OF BUFFER 
 XX INTQWB		;BOTTOM OF BUFFER
 XX INTPRC		;INTERRUPT PROCESS BASE
 XX DISPAT		;DISPATCH TABLE FOR INTERRUPT LEVEL MODULE
 XX DFRINF		; AOBJN PTR TABLE FOR DEFERRED INTERRUPTS
NOTENX<
 XX IPDP		;INTERRUPT PDP
>;NOTENX
TENX<
 XX IPDP1
 XX IPDP2
 XX IPDP3
 XX ISPDP1
 XX ISPDP2
 XX ISPDP3
 XX TIMFRK		;TABLE OF FORK HANDLES FOR INTERRUPT SYSTEM, PROCESSES
>;TENX
 XX IJBCNI		;JOBCNI FROM A DEFERRED INTERRUPT
 XX IJBTPC		;JOBTPC FROM DEFERRED INTERRUPT
 XX IRUNNR		;RUNNER AT TIME OF DEFERRED INTERRUPT
NOTENX<
 XX ISPDP		;STRING PDP FOR INTERRUPT LEVEL
>;NOTENX
 XX $FSLIS		;LIST OF FREE STORAGE ALLOCATORS
 XX PRNINF		;$PRINT DEFAULTS
 XX BAILOC		;IF NONZERO, ADDRESS OF BAIL INTERCEPT ROUTINE
 XX JFRCEL		; USED TO BE XX <NOTHING>
 XX RSGCLK		;THE TWO WORD BLOCK REQUIRED BY SGINS
 XX RSGCL2		; AND A SECOND WORD
 XX STBLST		;HEAD OF CHAIN OF STRING DESCR ARRAYS FOR RECORDS
 XX RGCOFF		;SET THIS TO TURN OFF AUTO GC
 XX TGRADJ		;PUT PUSHJ ADR HERE TO ADJUST OWN TRIGGER LEVELS
 XX RGCRHO		;-1.0+1/"%FILL" LEVEL DESIRED FOR RECORD SPACES
 XX SPARUT,4,,		;SPARE USER TABLE ENTRIES
 XX PRTINF		;PRINT OUTPUT INFORMATION  XWD BITS,CHAN
 XX $$PROU		;PRINT OUTPUT TRAP FOR ALL STRINGS
 XX $$FINT		;USER FORMATTING FUNCTION FOR INTEGERS
 XX $$FREL		; "         "       "      "  REALS
 XX $$FITM		; "         "       "      "  ITEMS
 XX $$FSET		; "         "	    "	   "  SETS
 XX $$FLST		; "	    "	    "	   "  LISTS
 XX $$FSTR		; "	    "       "      "  STRINGS
 XX $$FREC		; "         "       "      "  RECORDS
 XX $$FLRL		;LONG REAL
SFDS<
 XX PATHBL,4+SFDLVL,,		;PATH BLOCK
> ;SFDS
 XX EXPCHR	;"@" OR "E" FOR REAL NUMBER EXPONENT CHARACTER
 XX SEGBOT	;ADDR WHICH SAIL FREE STORAGE MUST NOT EXCEED
 XX CORINS	; CORE uuo hook (non-zero means this instead of core)
 XX BKGETC	; if non-zero, execute on entry to GETCHAN
 XX BKOPEN	; if non-zero, execute on entry to OPEN
 XX BKRELS	; if non-zero, execute on entry to RELEASE
 XX NOXTMS	; if non-zero, suppress "end of SAIL execution" message
 XX ENDREN	; END OF USER DATA TABLE
SUBTTL	Global AC Definitions, Indices, Bits
AC2DATA (GLOBAL AC ASSIGNMENTS)
?P	_17
?SP	_16
?USER	_15
?TEMP	_14
?LPSA	_13
?RF	__12			;THE ALMIGHTY F REGISTER
?TAC1	__TEMP
?TAC2	__LPSA
BITDATA (BITS FOR %ALLOC SPACE REQUEST BLOCK ENTRIES)
?STDSPC __400000	;"INDIRECT" SPECIFICATION OF STANDARD AREA
?WNTADR __200000	;ADDRESS OF AREA TO BE STORED AS SPECIFIED
?WNTEND __100000	;ADDRESS OF NEXT AREA TO BE STORED AS SPECIFIED
?WNTPDP __ 40000	;PDP TO AREA TO BE STORED " "
?WNTPDL __ WNTPDP	;WNTPDP, WNTPDL -- WHAT'S THE DIFFERENCE?
?USRTB  __ 20000	;RESULT ADDRESSES ARE IN THE USER TABLE
?MINSZ  __ 10000	;THIS SIZE TO BE USED ONLY IF NO OTHERS GIVEN
BITDATA (INDICES OF STANDARDLY ALLOCATED AREAS (SEE %ALLOC))
?SYSPD	__ 1		;SYSTEM!PDL
?SYSSPD	__ 2		;STRING!PDL
?STRSP	__ 3		;STRING!SPACE
BITDATA (INDICES INTO THE FIXED PORTION OF EACH %ALLOC SPACE REQ. BLOCK)
?$ITNO	__1		;MAX ITEM NUMBER DECLARED THIS COMPILATION
?$NWITM __2		;XWD REQUIRED BUCKETS,REQUIRE  NEW!ITEMS 
?$GITNO	__3		;MAX (MIN?) GLOBAL ITEM NUMBER DECLARED
?$MSLNK	__4		;POINTER TO MESSAGE PROCEDURE LIST PUT HERE
?$PNMNO	__5		;REQUIRE n PNAMES PUTS n HERE
?$VRNO	__6		;VERSION NUMBER
?$SGNM	__7		;REQUIRED GLOBAL SEGMENT NAME (USUALLY EMPTY)
?$SGD	__10		;REQUIRED GLOBAL SEGMENT FILE DEVICE
?$SGF	__11		;" FILE NAME
?$SGPP	__12		;" PPN
?$TINIT __13		; POINTER TO INITIAL ITEM TYPES
?$PINIT __14		; POINTER TO INITIAL PRINTNAMES
?$CMVER __ 15		;com version
?$OBPDA __ 16		; pointer to outer block pda
?$SPREQ __ 20		; leaves a spare
ENDDATA
BITDATA (LINK NAMES)
?%STLNK __ 1
?%SPLNK __ 2
?%SETLK __ 3
?%SGROT __ 4
?%KTLNK __ 5
?%PDLNK __ 6
?%INLNK __ 7
?%RBLNK __ 10
BAIL<
?%BALNK __ 11
>;BAIL
?%RCLNK __ 12		;RECORD CLASS LINK
BITDATA (PROCEDURE DESCRIPTOR INDICES)
	DEFINE PDX(I),<
		?I __ PD.XXX
		PD.XXX__PD.XXX+1
>
PD.XXX	__ 0
	PDX	PD.	;0
	PDX	PD.ID1	;1
	PDX	PD.ID2	;2
	PDX	PD.PDB	;3
	PDX	PD.NPW	;4
	PDX	PD.DSW	;5
	PDX	PD.LLW	;6
	PDX	PD.DLW	;7
	PDX	PD.PDA	;10
	PDX	PD.PPD	;11
	PDX	PD.PCW	;12
	PDX	PD.BDI	;13
?PD.XXX__PD.XXX
BITDATA (TYPE CODES WITHIN RH OF INFOTAB ENTRY)
	NOTYPE __ 1	;NO TYPE AT ALL
        BRKITM __ 2	;BRACKETED TRIPLE
	STTYPE __ 3	;STRING ITEM
	FLTYPE __ 4	;REAL ITEM
	INTYPE __ 5	;INTEGER ITEM
	LSTYPE __ 7	;LIST ITEM (TYPE SHOULD ALWAYS BE 1 MORE THN SETYPE
	SETYPE __ 6	;SET ITEM
	PITTYP __ 10	;PROCEDURE ITEM
	PRCTYP __ 11	;PROCESS ITEM
	EVTTYP __ 12	;EVENT TYPE ITEM
	CTXTYP __ 13	;CONTEXT ITEM
	RFITYP __ 14	;REFERENCE ITEM
	RECTYP __ 15	;RECORD
	LBLTYP __ 16	;LABEL
	RCLTYP __ 17	;RECORD CLASS
	ITVTYP __ 20	;ITEMVAR	***** UNUSED 12-9-76 *****
	LFLTYP __ 21	;LONG REAL
	LINTYP __ 22	;LONG INTEGER
	MXSTYP __ LINTYP; LAST SIMPLE TYPE
	ARRTYP __ 24	;ARRAYS ARE THIS PLUS SIMPLE TYPE CODE
	INVTYP __ MXSTYP+ARRTYP+1; NON-VALID TYPE CODE
BITDATA (RECORD CLASS TYPE BITS)
	NODELC __ 1	;DO NOT DELETE RECORDS OF THIS CLASS (VIA GC)
	CMPLDC __ 2	;THIS RECORD CLASS IS COMPILED-IN
	HASRPS __ 4	;HAS RPTR / RPTR ARRAY
	HASSTR __ 10	;HAS STRING / STRING ARRAY SUBFIELDS
	HASDBL __ 20	;HAS DOUBLE (LONG REAL) FIELDS
BITDATA( PROC DESC STUFF)
?BLKCOD__17				;BLOCK BOUNDARY CODE
?EOPCOD__0				;END OF PROC LVI CODE
?AACOD__1					;ARITH ARRAY
?SACOD__2					;STRING ARRAY
?SETCOD__3				;SET
?LACOD__4					;LIST OR SET ARRAY
?FRCCOD__5				;FOREACH STATEMENT
?KLCOD__6				;KILL LIST
?CTXCOD __ 7				;CONTEXT
?CLNCOD __ 10				;CLEANUP PROC
?RPCOD __ 11				;RECORD PTR
?RPACOD __ 12				;RECORD PTR ARRAY
ENDDATA
BITDATA (USE OF THE RESERVED ITEMS)
	ITMANY __ 0	;ITEM FOR ANY
	MAINPI __ 1	;ITEM NUMBER OF THE MAIN PROCESS ITEM
	UNBND  __ 2	;UNBOUND (?ITEMVARS ETC)
	EVTYPI __ 3	;THE ITEM EVENT!TYPE
	NIC    __ UNBND	;ITEM GET BACK FROM EMPTY NOTICE QUEUE
	?MAXLOC __ =10	;MAXIMUM NUMBER OF LOCAL ITEMVARS IN FOREACH
	?QBIND __ 200	;A ? ITMVR (NOT A MP PARM)
	?FBIND __ 100	;A BIND ITMVR(HERE BECAUSE OF STATS)
BITDATA (THE NAMED BITS FOR REF ITEMS)
	?TMPB __ 400000 ; SIGN BIT MEANS A TEMP REF ITEM
	?REFB __ 200000	;USUALLY SET
	?QUESB __ 100000;FOR ? ITEMVARS
	?BINDB __ 40000	;FOR BIND ITEMVAR
	?PROCB __ 20000	;NOT NOW REALLY USED
	?ITEMB __ 10000	; AN ITEM (ITEMVAR)
	?ARY2B __ 4000	;FOR * ARRAY ITEMVAR ARRAY REFERENCES
	?MSK6BT __ 3740 ; BITS FOR SIX BIT TYPE
	?MSKUNT __ 3700	;BIT MASK FOR UNTYPED 
ENDDATA
 SYSPHS__2		;TWO SYSTEM PHASES
 USRPHS__=1000	;SDD: 08-MAY-81 many user phases.  This is now 
IFN HEDSYM, <		;MAKE AN HONEST ASSEMBLY OUT OF IT
	TITLE	HEAD
	END
>;IFN HEDSYM
?.VERSION__102400000023
SUBTTL	Command File Descriptions
	LSTON	(GOGOL)
SUBTTL	Conditional Assembly Switches, Macros
STSW(UPPER,0)		;NOT UPPER OR LOWER IF NEITHER SET
STSW(LOWER,0)
STSW(GLOBSW,0)		;ONLY GLOBAL IF SOMEBODY ELSE SAID SO
STSW(SEGS,0)
STSW(RENSW,0)		;RE-ENTRANT LIBRARY (HISEG) IF ON
STSW(LEAPSW,1)		;ASSUME LEAP
NOSTAN <
STSW(APRISW,1)		;THE APR INTERRUPT PACKAGE IS TO BE USED
>;NOSTAN
STANFO <
STSW(APRISW,0)		;USUALLY USE THE MOORER PACKAGE
>;STANFO
DEFINE COMPIL ' (NAM,ENT,EXT,DSCRP,INT,HINHB,DUMMY) <
IFIDN <DUMMY>,<> <
SUBTTL SAI'NAM -- DSCRP
IFE ALWAYS,<
	IFDIF <><ENT>,<ENTRY ENT>
	TITLE	SAI'NAM
REN <
	IFIDN <><HINHB>,<HISEG		;LOAD TO UPPER IF POSSIBLE>
>;REN
	IFDIF <><EXT>,<EXTERN EXT>
>;IFE ALWAYS
NOLOW <
	IFDIF <><INT>,<INTERN INT>
IFN ALWAYS,<
IFDIF <NAM><LOR>,<
IFDIF <><ENT>,<INTERNAL ENT>
>>
>;NOLOW
>;IFIDN <DUMMY>
>
DEFINE COMPXX ' (NAM,ENT,EXT,DSCRP,INT,HINHB) 
	<COMPIL(<NAM>,<ENT>,<EXT>,<DSCRP>,<INT>,<HINHB>)>
DEFINE ENDCOM (NAM) <
IFE ALWAYS,<
	END
>;IFE ALWAYS
>
IFNDEF ALWAYS,<?ALWAYS__1>
IFN ALWAYS,<DEFINE ENTINT (X) <INTERNAL X>>
IFE ALWAYS,<DEFINE ENTINT (X) <ENTRY X>>
SUBTTL	Titles, Versions
IFN ALWAYS,<
LOW <
	TITLE LOWER
>;LOW
NOUP <
NOLOW <
	TITLE RUNTIM -- SAIL RUNTIME ROUTINES
>;NOLOW
JOBVER__137
	LOC	JOBVER
	.VERSION&777777000000	;CURRENT VERSION NUMBER (LH ONLY)
	RELOC
>;NOUP
>;ALWAYS NEQ 0
SUBTTL	AC Definitions
?FF__0
?A_1						;TEMPS FOR ALLES
?B_2						; (SOMETIMES SAVED)
?C_3
?D_4
		?E_5		?X_5		;MORE TEMPS
		?Q1_6		?Y_6
		?Q2_7		?Z_7
		?Q3_10		?CHNL_10	;CHNL # FOR IOSER
		?T_11		?CDB_11		;CHANNEL DATA BLOCK PTR
		?T1_12				;TRY TO KEEP 12(RF) VALID.
?LPSA_13					;TEMP, PARAM AC
?TEMP_14					;TEMP ONLY
?USER_15					;PTR USER TABLE FOR RNTRNT ROUTS
?SP_16						;STRING STACK
?P_17						;SYSTEM STACK
SUBTTL	CDB, SIMIO Indices For IOSER, OTHER INDICES
	?IOERRPROC__ 0		;RETURN STATUS
	?IOIN     __ 1		;BUFFERED INPUT
	?IODIN    __ 2		;DUMP INPUT
     	?IOOUT    __ 3		;BUFMODE OUT.
	?IODOUT   __ 4		;DUMP OUTPUT
	?IOCLOSE  __ 5		;CLOSE FILE
	?IORELEASE__ 6		;RELEASE FILE
	?IOINBUF  __ 7		;INBUF
	?IOOUTBUF __10		;OUTBUF
	?IOSETI   __11		;USETI
	?IOSETO   __12		;USETO
	?SETIOSTS __13		;SET IO STATUS
	?IOOPEN __14		;OPEN CHANNEL
	?IOLOOKUP __15		;LOOKUP FILE
	?IOENTER  __16		;ENTER FILE
	?IORENAME __17		;RENAME FILE
TYMSHR <;CHANIO INDICES
	?CIOIN__14
	?CIOOUT__15
	?CIOCLS__1
	?CIORLS__0
	?CIOIBF__22
	?CIOOBF__23
	?CIOUSI__6
	?CIOUSO__7
	?CIOSTS__16
	?CIOOPN__13
	?CIOLUK__4
	?CIOENT__5
	?CIOREN__11
	?CIOGST__17
>;TYMSHR
	DMODE	__ 0		;DATA MODE	
	DNAME	__ 1		;DEVICE	
	BFHED	__ 2		;HEADER POINTERS	
	OBPNT	__ 3		;OUTPUT BUF. PTR	
	OBP	__ 4		;OUTPUT BYTE PTR	
	OCOWNT	__ 5		;OUTPUT BYTE CNT
	ONAME	__ 6		;OUTPUT FILE NAM
	OBUF	__ 7	 	;OUTPUT BUFFER LOC.
	IBPNT	__10		;SAME FOR INPUT
	IBP	__11	
	ICOWNT	__12
	INAME	__13	
	IBUF	__14	
	ICOUNT	__15		;INPUT DATA COUNT LIMIT ADDRESS
	BRCHAR	__16		;XWD TTYDEV FLAG, INPUT BREAK CHAR ADDR
	TTYDEV  __16		;LH -1 IF DEVICE IS A TTY -- USED BY OUT
	ENDFL	__17		;INPUT END OF FILE FLAG ADDR
	ERRTST	__20		;USER ERROR BITS SPECIFICATION WORD
	LINNUM  __21		;ADDR OF LINE NUMBER WORD (SETPL FUNCTION)
	PAGNUM  __22		;ADDR OF PAGE NUMBER WORD (SETPL FUNCTION)
	SOSNUM  __23		;ADDR OF SOS NUMBER WORD  (SETPL FUNCTION)
?IOTLEN	__SOSNUM+1	;LENGTH OF TABLE ENTRY
?LUPDL_30			;LENGTH OF UUO PDL
?MINPDS__=64			;SMALLEST ALLOWABLE SYSTEM PDL SIZE
?DEFPDS__=192			;DEFAULT PDL SIZE
?.ERSWC __ 20			;SIZE OF BUILT IN .ERSTR BUFFER
GLOB < 
?GBRK __ 6000			;MIN GLOBAL ITEM NUMBER
>;GLOB
?.HDRSIZ__6			;Header allocated in each string space
 ?.csize__-6	;Size of this space in characters
 ?.bysiz__-5	;byte size in bits for this space
 ?.bypwd__-4	;byte per word this space
 ?.STTOP__-3	;points 1 past last word this space
 ?.LIST__ -2	;Used to link descriptors (in-GC)
  ?.TOPBYT__.LIST	;byte pointer when this space abandoned (non-GC)
 ?.NEXT__ -1	;Next string space handle
?$WCRSZ__13	;size of Width control record
 ?$NEXT__0	;linkage for all WCRs (head is GOGTAB[STWCRL])
 ?$BYSIZ__1	;the byte size WCR controls
 ?$BYPWD__2	;bytes per word (for the nosy)
 ?$STLIST__3	;first SPC of this width on STLIST
 ?$STHAND__4	;active SPC this width
 ?$TOPBYTE__5	;place to start dumping new bytes (=GOGTAB[TOPBYTE])
 ?$REMCHR__6	;-bytes left in active space (=GOGTAB[REMCHR])
 ?$WASTE__7	;inaccessible byte count to 0
 ?$CSIZE__10	;total characters in all SPCs of this size
 ?$STINCR__11	;normal size for this width (ala GOGTAB)
 ?$STREQD__12	;threshold for leaving space (ala GOGTAB)
SUBTTL	Base (Low Segment) Data Descriptions -- Macros, Compil spec
NOUP <
DEFINE SGLK (ROUT,NAM,INT) <
 XX	(NAM,ROUT,INT)	;NAME OF STRING DSCRPTR GENERATING ROUTINE
 XX	(,0,)		;PLACE TO PUT A LINK
 LINK	%SGROT,.-1	;WHEREWITHAL TO GENERATE SAID LINK
>
>;NOUP
UP <
DEFINE SGLK (ROUT,NAM) <
 XX	(NAM,ROUT,)
 XX	(,0,)
>
>;UP
DEFINE XX  (A,B,C,D) <
	IFDIF <A><>,<? A :> B
	IFDIF <C><>,< C A >
>
UP <
III__140
	DEFINE XX (A,B,C,D) <
	IFDIF <A><>,<? A _ III >
	III __ III + 1
	IFDIF <D><>,<III_III+D-1>
>
>;UP
END
RhC¼