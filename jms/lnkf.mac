
	.TITLE	LNKF   - Main program routines for Tymshare host
	
	.SBTTL	LNKF   - Nexilis/JRG

	XLPAR			;DON'T LIST PARAMETER FILES

;DEFINE DISPATCH FOR LOAD DEVICE (IT IS 0 SINCE CAN'T LOAD A HOST!)

LKFLOD==!0

	CODE

	.SBTTL	LKFINI - Initialization

;SUBROUTINE TO INITIALIZE THE HOST INTERFACE ROUTINES
;	CALL	LKFINI

LKFINI::MOV	#DDLFCZ#,R1		;GET NUMBER OF WORDS TO CLEAR
	MOV	#DDLFFC#,R2		;GET FIRST WORD TO CLEAR
	ADD	R4,R2
2$:	CLR	(R2)+			;CLEAR THIS PART OF THE DDB
	SOB	R1,2$
.IF NE ..BUG
	MOV	#DBRING,DBRNGP		;RESET DEBUG RING POINTER
	MOV	#-1,DBRING-2		;SET UP THE FLAG WORDS
	MOV	#-1,DBRNGE
.ENDC
	CLR	@DDLFSR#(R4)		;DOES THIS INTERFACE EXIST?
	NXMJMP	NOLINK#			;NO-GO MARK IT THAT WAY!
	MOV	#$D1DWN,DDSTS1#(R4)	;YES-INDICATE LINK IS DOWN
	MOV	DDLFAV#(R4),DDLFAL#(R4)	;RESET POSITION IN RING
	MOVB	#.ISRST,DDLFIS#(R4)	;INITIALIZE INPUT STATE
	CALL	LKFENB#			;ENABLE THE INTERFACE
	 NOP				;CABLE HANGING LOOSE
	RETURN

;SUBROUTINE TO INITIALIZE EACH HOST INTERFACE SDB
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	LKFINS

LKFINS::MOV	#SDLFCZ#,R1		;GET NUMBER OF WORDS TO CLEAR
	MOV	#SDLFFC#,R2		;GET FIRST WORD TO CLEAR
	ADD	SD,R2
2$:	CLR	(R2)+			;CLEAR THIS PART OF THE SDB
	SOB	R1,2$
	DEC	SDLFBL#(SD)		;INITIALIZE THE BLOCK MODE LINK WORD
	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LFRSUM   - Subroutine to resume input from host

;SUBROUTINE CALLED WHEN ADDITIONAL INPUT CAN BE ACCEPTED FROM A HOST
;	C(SD) = ADDRESS OF SDB
;	CALL	LFRSUM

LFRSUM::TBBN	$H1BKO,SDLFS1#(SD),2$	;IF DOING BLOCK OUTPUT ON THIS SOCKET
	TBBN	$H1OPH,SDLFS1#(SD),RTN001;DO NOTHING IF HOLDING OUTPUT
	MOV	#$RQBOF,R0		;OTHERWISE TURN OFF BACKPRESSURE
	CJMP	SNDHST			;AND RETURN

;HERE IF THIS SOCKET IS DOING BLOCK MODE OUTPUT NOW

2$:	CJMP	STRBKO			;GO RESTART BLOCK MODE OUTPUT FROM HOST
	.PAGE
	.SBTTL	LFMAIN   - Main program loop routine

;SUBROUTINE CALLED ONCE EACH TIME THROUGH THE MAIN PROGRAM LOOP

	MAINXX	LFMAIN

LFMAIN:	MOV	#LKFDDB#,R4		;GET FIRST TYPE F LINK DDB
LFMAI1:	MOVB	DDLFRQ#(R4),R0		;GET REQUEST
	JMP	@LFMDSP(R0)		;DISPATCH ON IT

	PURE

LFMDSP:	.WORD	LFMAI2		;       = 00 - NO REQUEST
	.WORD	LFINPD		;$RQINP = 02 - INPUT REQUEST
	.WORD	LFOUTD		;$RQOUT = 04 - OUTPUT REQUEST
	.WORD	LFOUTD		;       = 06
	.WORD	LFBLKD		;$RQBLK = 10 - BLOCK MODE FUNCTION
	.WORD	LFBLKD		;       = 12
	.WORD	LFBLKD		;       = 14
	.WORD	LFBLKD		;       = 16

	CODE

;HERE IF NO REQUEST FOR THIS DDB

LFMAI2:	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE F LINK DDB
	BNE	LFMAI1			;CONTINUE IF ANOTHER
RTN001:	RETURN				;FINISHED

;HERE FOR BLOCK MODE FUNCTION

LFBLKD:
.IF NE ..BUG
	MOV	#-1,@DBRNGP
	ADD	#2,DBRNGP
	MOV	DDLFBS#(R4),@DBRNGP
	ADD	#2,DBRNGP
	CMP	#DBRNGE,DBRNGP
	BHI	2$
	MOV	#DBRING,DBRNGP
2$:
.ENDC
	BICB	#$RQBLK,DDLFRQ#(R4)	;CLEAR REQUEST
	MOV	DDLFBS#(R4),SD		;GET SDB ADDRESS
	BIC	#$H1BOA,SDLFS1#(SD)	;INDICATE BLOCK OUTPUT NOT ACTIVE NOW
	MOV	DDLFBK#(R4),R1		;GET FIRST PACKET
	CLR	DDLFBK#(R4)		;AND CLEAR THE POINTER
	PUSH	DDLFBJ#(R4)		;SAVE TOTAL CHARACTER COUNT
LFBLK2:	PUSH	(R1)			;SAVE ADDRESS OF NEXT PACKET
	INCB	SDPCNT#(SD)		;KEEP THE PACKET COUNT RIGHT
	MOV	DDLFBJ#(R4),R0		;GET CHARACTER COUNT
	CMP	#PKCMAX,R0		;MORE THAN ONE PACKET?
	BGE	2$			;NO
	MOV	#PKCMAX,R0		;YES-REDUCE AMOUNT FOR THIS PACKET
2$:	SUB	R0,DDLFBJ#(R4)		;REDUCE COUNT
	MOV	R0,PKCNT(R1)		;STORE COUNT IN PACKET (ALSO SETS
					;  C(PKTYPE) = 0)
	CALL	SNDPKT#			;SEND THE PACKET
	POP	R1			;GET ADDRESS OF NEXT PACKET
	BNE	LFBLK2			;CONTINUE IF ANOTHER
	POP	R0			;RESTORE TOTAL CHARACTER COUNT
	CLR	DDLFBS#(R4)		;CLEAR POINTER/FLAG WORD
	MOV	SDLFBL#(SD),DDLFBH#(R4)	;REMOVE FROM BLOCK OUTPUT LIST
	BNE	3$
	CLR	DDLFBT#(R4)
3$:	MOV	#-1,SDLFBL#(SD)
	TBBN	$H1BOK,SDLFS1#(SD),LFBLK7;IF HOST HAS KILLED THIS TRANSFER
	TST	SDLFBO#(SD)		;DID WE GET ALL THE HOST WANTS TO SEND?
	BLE	LFBLK7			;YES
	ASR	R0			;NO-CONVERT FROM CHARACTER COUNT TO
	ASR	R0			;  PDP-10 WORD COUNT
	ADD	R0,SDLFO0#(SD)		;BUMP PDP-10 ADDRESS
	ADC	SDLFO1#(SD)
	CMPB	SDPMAX#(SD),SDPCNT#(SD)	;CAN WE TAKE MORE NOW?
	BLE	LFBLK6			;NO
	MOV	DDLFBT#(R4),R2		;YES-PUT HIM BACK IN THE OUTPUT LIST
	BNE	LFBLK4
	MOV	SD,DDLFBH#(R4)
	BR	LFBLK5

LFBLK4:	MOV	SD,SDLFBL#(R2)
LFBLK5:	MOV	SD,DDLFBT#(R4)
	CLR	SDLFBL#(SD)
	BR	LFBLK8			;CONTINUE

;HERE IF HOST HAS MORE TO SEND BUT WE CAN'T TAKE IT NOW

LFBLK6:	BIS	#$S1STP,SDSTS1#(SD)	;INDICATE HAVE STOPPED INPUT FROM HOST
	BR	LFBLK8			;CONTINUE

;HERE IF BLOCK TRANSFER IS COMPLETE NOW

LFBLK7:	BIC	#$H1BKO!$H1BOK,SDLFS1#(SD);INDICATE NO LONGER DOING BLOCK OUTPUT
	MOV	#$RQBOC,R0		;REQUEST "BLOCK OUTPUT COMPLETE"
	CALL	SNDHST			;  MESSAGE
LFBLK8:	MOV	DDLFBH#(R4),SD		;NEED MORE BLOCK OUTPUT FROM HOST?
	BEQ	7$			;NO
	TBBN	$H1BKO,SDLFS1#(SD),5$	;GO ON IF STILL WANT BLOCK OUTPUT
	MOV	SDLFBL#(SD),DDLFBH#(R4)	;CHANGED OUR MIND-REMOVE FROM LIST
	BNE	3$
	CLR	DDLFBT#(R4)
3$:	MOV	#-1,SDLFBL#(SD)
	BR	LFBLK8			;TRY AGAIN

5$:	MOV	#$RQRBO,R0		;YES-REQUEST IT
	CALL	SNDHST
7$:	JMP	LFDON2			;FINISHED HERE
	.PAGE
	.SBTTL	LFINPD   - Input from host is done

;HERE IF INPUT IS DONE

LFINPD:
.IF NE ..BUG
	MOV	#-2,@DBRNGP
	ADD	#2,DBRNGP
	MOV	DDLFIX#(R4),@DBRNGP
	SWAB	@DBRNGP
	ADD	#2,DBRNGP
	CMP	#DBRNGE,DBRNGP
	BHI	1$
	MOV	#DBRING,DBRNGP
1$:
.ENDC
	BIC	#$RQINP,DDLFRQ#(R4)	;CLEAR THE INPUT REQUEST
	MOVB	DDLFIX#+1(R4),R0	;GET MESSAGE TYPE BYTE
	CLR	SD			;GET PORT NUMBER
	BISB	DDLFIX#(R4),SD
	BEQ	2$			;IF FOR PORT 0
	CMPB	DDSOC#(R4),SD		;VALID PORT NUMBER?
	BHIS	4$			;YES-GO ON
	CMPB	#.MSHSI,R0		;NO-IS THIS A RESTART MESSAGE?
	BEQ	2$			;YES-THATS OK
	CMPB	#6,R0			;OR A "FORMAT A" MESSAGE?
	BHI	2$			;YES-ALSO OK
	INC	DDERIS#(R4)		;NO-COUNT AS BAD SOCKET NUMBER
	BR	MSGBAD			;AND GO RESET THE HOST INTERFACE

;HERE FOR PORT 0 (ALSO FOR HOST PORTS MESSAGE)

2$:	MOV	DDWLD#(R4),SD		;GET ADDRESS OF "WILD" SDB
	BR	6$			;CONTINUE

;HERE FOR NORMAL VALID PORT

4$:	ASL	SD			;GET SDB FOR THE PORT
	ADD	DDSX#(R4),SD
	MOV	-(SD),SD		;GET ADDRESS OF SDB FOR SOCKET THAT
					;  CORRESPONDES TO THE PORT
6$:	TSTB	R0			;IS THIS A DATA MESSAGE?
	BMI	LFDATA			;YES-GO HANDLE IT
	ASL	R0			;NO-FOR WORD INDEXING
	JMP	@MSGDSP(R0)		;DISPATCH ON THE MESSAGE TYPE

;HERE FOR DATA MESSAGE

LFDATA:	MOV	DDLFIK#(R4),R1		;GET FIRST MESSAGE PACKET
	CLR	DDLFIK#(R4)
LFDAT2:	PUSH	(R1)			;SAVE ADDRESS OF NEXT PACKET
	MOV	DDLFCC#(R4),R0		;GET TOTAL CHARACTER COUNT
	BGT	2$			;GO ON IF PACKET NOT EMPTY
	FREPKT				;GIVE UP THE EMPTY PACKET
	BR	6$			;AND CONTINUE

;HERE WITH NON-EMPTY DATA PACKET

2$:	CMP	#PKCMAX,R0		;MORE THAN ONE PACKET?
	BGE	4$			;NO
	MOV	#PKCMAX,R0		;YES-JUST GET MAX
4$:	SUB	R0,DDLFCC#(R4)		;REDUCE COUNT
	MOV	R0,PKCNT(R1)		;STORE COUNT FOR THIS PACKET
					;  (ALSO SETS PKTYPE TO 0!)
	INCB	SDPCNT#(SD)		;BUMP THE PACKET COUNT
	CALL	SNDPKT#			;SEND THE PACKET
6$:	POP	R1			;GET NEXT PACKET
	BNE	LFDAT2			;CONTINUE IF HAVE ANOTHER ONE
	CMPB	SDPMAX#(SD),SDPCNT#(SD)	;NO-DO WE WANT ANY MORE?
	BGT	LFDO1N			;YES-GO ON
	BIS	#$S1STP,SDSTS1#(SD)	;NO-INDICATE STOPPED
	MOV	#$RQBON,R0		;AND SEND "BACKPRESSURE ON" MESSAGE
	CALL	SNDHST
LFDO1N:	JMP	LFDONE
	.PAGE
;HERE FOR ILLEGAL MESSAGE FROM FROM HOST

MSGBAD:	CALL	LKFDWN			;PUT HIM DOWN!
	MOV	#JIFX30#,R0		;PUT IN TIMER REQUEST FOR 30 SEC.
	MOV	#REENAB,R1
	MOV	R4,SD
	CALL	TIMREQ#
	BCS	10$			;FORGET ABOUT DISABLING IT IF CAN'T DELAY!
	CALL	LKFDII#			;DISABLE THE INTERFACE
	BIS	#$D1DIS,DDSTS1#(R4)	;INDICATE IT IS DISABLED
10$:	JMP	LFMAI2			;THATS ALL!

;HERE 1/2 MIN. AFTER WE DISABLED THE INTERFACE TO RE-ENABLE IT
;	C(SD) = ADDRESS OF DDB
;  NOTE:  THE DDB ADDRESS IS IN SD, NOT R4 !!!!!!

REENAB:	CLRB	DDLFOS#(SD)		;MAKE SURE OUTPUT STATE IS RIGHT
	BIC	#$D1DIS,DDSTS1#(SD)	;INDICATE NOT DISABLED NOW
	RETURN				;THATS ALL

;HERE FOR "SPECIFY HOST PORTS" MESSAGE (.MSHSI = 41) - THIS MESSAGE IS USED AS
;  A "RESET THE INTERFACE" MESSAGE!

MSGRST:	TBBE	$D1DWN,DDSTS1#(R4),MSGBAD;BAD MESSAGE IF HOST IS UP NOW
	TBBE	$D0KMC,(R4),2$		;ARE WE USING A KMC?
	CLR	R0			;YES-GET PORT OFFSET
	BISB	DDLFIX#+3(R4),R0
	MOV	R0,DDLFPO#(R4)		;SAVE IT IN THE DDB
2$:	CALL	LNKUP#			;ITS UP NOW!
	CALL	SNDPOK			;TRY TO POKE THE HOST NOW
	BR	LFDO2N			;FINISHED

;HERE FOR "BACKPRESSURE ON" MESSAGE (.MSNOP = 10)

MSGNOP:	TBBN	$H1BKI,SDLFS1#(SD),LFDO2N;IGNORE THIS IF BLOCK MODE INPUT
	BIS	#$S1HLD,SDSTS1#(SD)	;INDICATE NO MORE OUTPUT
	BR	LFDO2N			;THATS ALL

;HERE FOR "BACKPRESSURE OFF" MESSAGE (.MSOUP = 11)

MSGOUP:	TBBN	$H1BKI,SDLFS1#(SD),LFDO2N;IGNORE THIS IF BLOCK MODE INPUT
	BIC	#$S1HLD,SDSTS1#(SD)	;INDICATE OUTPUT IS OK NOW
	MOV	SDPKDH#(SD),R1		;ANY OUTPUT PENDING NOW?
	BEQ	LFDO2N			;NO
	CALL	RSPOKE#			;YES-START IT OUT
LFDO2N:	JMP	LFDONE			;THATS ALL

;HERE FOR "CHARACTER GOBBLER" MESSAGE (.MSGOB = 12)

MSGGOB:	MOV	#.PTEAT*400+.FNNUL,R2	;PACKET = EAT, FUNCTON = NULL
	BR	NEDFN1			;GO MAKE PACKET

;HERE FOR "CIRCUIT ZAPPER" MESSAGE (.MSZAP = 13)

MSGZAP:	TSTB	SDSOC#(SD)		;IS IT ON PORT 0?
	BEQ	LFDO2N			;YES-IGNORE IT
	CALL	MAKPKX			;GET A PACKET
	INCB	SDPCNT#(SD)
	MOVB	SDSTS1#(SD),R0		;GET SOCKET STATE
	CMPB	#.SSKT1,R0		;IS KILL PENDING NOW?
	BEQ	2$			;YES
	CMPB	#.SSKT2,R0		;MAYBE
	BEQ	2$			;YES
	CMPB	#.SSDTP,R0		;NO-IS DISCONNECT PENDING NOW?
	BNE	4$			;NO
2$:	MOV	#.PTDAK*400,PKCNT(R1)	;YES-MAKE DISCONNECT ACK PACKET
	BR	6$			;CONTINUE

;HERE IF DISCONNECT IS NOT PENDING

4$:	MOV	#.PTKIL*400+1,PKCNT(R1)	;STORE PACKET TYPE AND COUNT
	MOVB	#.ERREQ,PKDATA(R1)	;ERROR CODE = "REQUEST"
	MOV	#PKDATA+1,R0		;GET OFFSET FOR HOST NAME
	CALL	PUTHSN#			;PUT HOST NAME INTO THE PACKET
	ADD	R0,PKCNT(R1)		;FIX UP THE COUNT
6$:	CALL	SNDPKT#			;GO SEND THE PACKET
	CALL	FRESOC#			;FREE UP THE SOCKET
	TBBE	$D1ASB,DDSTS1#(R4),10$	;SKIP THIS IF WE DIDN'T DECLARE HOST OUT OF PORTS
	MOV	#.SFHHP,R0		;GET SUB-FUNCTION: HOST HAS PORTS
	CALL	MSGSPX			;Send message to gateway
	 BR	 10$			;Handle failure
	BIC	#$D1ASB,DDSTS1#(R4)	;Keep a record of doing this
10$:	JMP	LFDONE
	.PAGE

;HERE FOR "GREEN BALL" MESSAGE (.MSGRN = 16)

MSGGRN:	MOV	#.PTFUN*400+.FNGRN,R2	;FUNCTION = GREEN BALL
	BR	NEDFN1			;CONTINUE

;HERE FOR "RED BALL" MESSAGE (.MSRED = 17)

MSGRED:	MOV	#.PTFUN*400+.FNRED,R2	;FUNCTION = RED BALL
	BR	NEDFN1			;CONTINUE

;HERE FOR "YELLOW BALL" MESSAGE (.MSYEL = 20)

MSGYEL:	MOV	#.PTFUN*400+.FNREQ,R2	;FUNCTION = REQUEST
	BR	NEDFN1

;HERE FOR "ORANGE BALL" MESSAGE (.MSORG = 21)

MSGORG:	MOV	#.PTFUN*400+.FNRSP,R2	;FUNCTION = RESPONSE
NEDFN1:	MOV	#1,R3			;BYTE COUNT = 1
	JMP	NEDPKT

;HERE FOR "HANG CHARACTER" MESSAGE (.MSHNG = 22)

MSGHNG:	MOV	#.PTFUN*400+.FNHNG,R2	;FUNCTION =  HANG REQUEST
	BR	NEDS2D

;HERE FOR "ENTER TRANSPARENT MODE" MESSAGE (.MSETM = 23)

MSGETM:	MOV	#.TPTRN*400+1,R0	;PARAMETER = TRANSPARENCY, VALUE = 1
	BR	NEDFN1

;HERE FOR "LEAVE TRANSPARENT MODE" MESSAGE (.MSLTM = 24)

MSGLTM:	MOV	#.TPTRN*400+0,R0	;PARAMETER = TRANSPARENCY, VALUE = 0
NEDS2D:	JMP	NEDSDP
	.PAGE
;HERE FOR "SUPERVISOR REQUEST" MESSAGE (.MSSUP = 26)
;  THIS MESSAGE BEGINS A "CIRCUIT BUILDING" DIALOG.  THE PORT NUMBER FIELD
;  OF THIS MESSAGE CONTAINS A "DIALOG NUMBER" INSTEAD OF A PORT NUMBER.  WE
;  HAVE ONE DATA WORD IN EACH HOST SDB DEVOTED TO THIS DIALOG; THIS WORD IS
;  NEVER USED BY NORMAL MESSAGES, THUS WE CAN INDEX ON SD TO GET TO THIS
;  WORD, EVEN THOUGH WE CAN USE THE SDB FOR NOTHING ELSE AT THIS POINT.
;  THIS WORD (SDLFXP) POINTS TO A PACKET WHICH IS ALLOCATED BY THE ROUTINE
;  FOR THIS MESSAGE.

MSGSUP:	MOV	SDLFAX#(SD),R1		;IS THIS SUPERVISOR DIALOG ACTIVE?
	BEQ	4$			;NO-GO ON
	TBBN	$H1AUX,SDLFS1#(SD),MSGAXX;YES-IS THE CONNECT PACKET OUTSTANDING?
	MOV	(R1),R0			;IS A CONNECT PACKET WAITING?
	BEQ	10$			;NO
	CLR	(R1)			;YES-GIVE IT UP
	PUSH	R1
	MOV	R0,R1
	FREPKT
	POP	R1
	BR	10$			;CONTINUE

4$:	CALL	MAKPKX			;NO-GET A PACKET
10$:	MOV	R1,SDLFAX#(SD)		;SAVE PACKET ADDRESS
	CLR	PKCNT(R1)		;CLEAR THE COUNT BYTE + PACKET TYPE
	MOV	#$RQSR0,R0		;REQUEST SUPERVISOR RESPONSE MESSAGE
MSGSU2:	CALL	SNDHST
	BR	LFDO2N			;FINISHED FOR NOW

;HERE FOR "SUPERVISOR CHARACTER" MESSAGE (.MSAXC = 30)

MSGAXC:	MOVB	DDLFIX#+2(R4),R0	;GET CHARACTER
	MOV	SDLFAX#(SD),R1		;GET ADDRESS OF DATA PACKET FOR NAME
	BEQ	LFDO2N			;IGNORE THIS IF DIALOG NOT ACTIVE
	MOV	(R1),R2			;ARE WE PROCESSING THE DST NAME?
	BNE	MSGAX4			;YES (CONNECT PACKET LINKED TO DATA PACKET)
	CMP	#':,R0			;END OF LOGIN STRING?
	BEQ	MSGAX2			;YES
	CMP	#CR,R0			;ANOTHER WAY TO END IT
	BEQ	MSGAX3
	CMP	#';,R0			;ANOTHER WAY TO END IT
	BEQ	MSGAX3
	MOVB	PKCNT(R1),R3		;NO-CALCULATE WHERE TO PUT CHARACTER
	CMP	#20.,R3			;TOO MANY CHARACTERS?
	BLT	MSGAXX			;YES-ERROR!
	ADD	R1,R3
	MOVB	R0,PKDATA(R3)		;STORE CHARACTER
	INCB	PKCNT(R1)		;BUMP COUNT
	JMP	LFDONE			;FINISHED

;HERE IF ERROR IN SUPERVISOR STRING

MSGAXX:	PUSH	#$RQSR1			;GET MESSAGE REQUEST BIT
	JMP	MSGAX9			;CONTINUE

;HERE ON ":" - THIS MARKS THE END OF THE username string
;AND THE BEGINNING OF THE DST NAME

MSGAX2:	CALL	MAKCON			;MAKE CONNECT PACKET AND LINK IT IN
	JMP	LFDONE			;THATS ALL

;HERE ON LOGIN NAME WITH ONLY NAME AND NO EXPLICIT DESTINATION

MSGAX3:	PUSH	R0			;SAVE CHARACTER
	CALL	MAKCON			;MAKE CONNECT AND LINK IT IN PROPERLY
	BIC	#77,R1			;POINT TO BEGINING OF PACKET
	POP	R0
	MOV	R1,R2			;COPY CONNECT POINTER
	ADD	#PKDATA+6,R2		;POINT TO DESTINATION FIELD
	MOV	SDLFAX#(SD),R1		;POINT TO DATA PACKET FOR SAVING TERMINATOR
	MOV	#DFTHST#,R3		;POINT TO DEFAULT HOST
	MOVB	(R3)+,(R2)+		;IS THERE A DEFAULT HOST?
	BEQ	MSGAXX			;NO DEFAULT HOST - FAIL AUX CIRCUIT
10$:	MOVB	(R3)+,(R2)+		;COPY DEFAULT HOST NAME
	BNE	10$			;CONTINUE UNTIL END OF STRING ENCOUNTERED
	BR	MSGAX6			;PROCESS STRING TERMINATOR

;HERE WHEN PROCESSING THE DESTINATION NAME

MSGAX4:	CMP	#CR,R0			;END OF STRING?
	BEQ	MSGAX6			;YES
	CMP	#';,R0			;MAYBE
	BEQ	MSGAX6			;YES
1$:	MOVB	PKDATA(R2),R3		;GET CURRENT COUNT
	CMP	#7,R3			;PAST DST NAME?
	BGT	4$			;NO
	CMP	#21,R3			;YES-TOO MANY?
	BLE	MSGAXX			;YES-GO FAIL
	ADD	R2,R3			;NO-GET ADDRESS
	MOVB	R0,PKDATA+27(R3)	;STORE CHARACTER
	INCB	PKCNT(R2)		;BUMP PACKET SIZE
	INCB	PKDATA+2(R2)		;BUMP DST EXTENSION SIZE
	BR	14$			;CONTINUE

;HERE FOR DST NAME CHARACTER

4$:	CMP	#'@,R0			;START OF DST EXTENSION
	BNE	12$			;NO
	CMP	#2,R3			;CHECK FOR ONLY TWO CHARS
	BGT	MSGAXX			;NO - GO FAIL
	CMP	#5,R3			;CHECK FOR MAX DVnnn@
	BLT	MSGAXX			;NO - GO FAIL
	TSTB	PKDATA+4(R2)		;A PREVIOUS DEVICE?
	BNE	MSGAXX			;YES - GO FAIL
	MOV	#DEVMAX#,R0		;GET DEV. NAME TABLE
5$:	CMP	DEVNAM#-2(R0),PKDATA+6(R2) ;THIS ONE?
	BEQ	6$			;YES - NORMALIZE INDEX
	DEC	R0			;NO - KEEP ON LOOKING
	SOB	R0,5$			; ...AGAIN
	BR	MSGAXX			; NOT FOUND? - GO FAIL

; HERE WITH DEVICE NAME MATCH

6$:	ASR	R0			;GET NORMALIZED OFFSET
	DEC	R0			;MAKE RELATIVE 0
	MOVB	R0,PKDATA+4(R2)		;STORE DEVICE INDEX
	CLR	PKDATA+6(R2)		; FORGET THE ASCII
; LOOK FOR A SOCKET NUMBER AFTER THE DEVICE NAME
	CLR	R0			;DEFAULT IS WILD SOCKET
	SUB	#2,R3			;ADJUST COUNT
	TST	R3			;EOS?
	BLE	11$			;YES - FINISH
	PUSH	R1			;SAVE PACKET ADDRESS
	PUSH	R2			;SAVE PACKET DATA OFFSET
7$:	MOVB	PKDATA+10(R2),R1	;GET NEXT CHAR
	CLRB	PKDATA+10(R2)		;MAKE IT DISAPPEAR
	INC	R2			;LOOK AGAIN
	CMPB	#'0,R1			;DIGIT?
	BGT	10$			;NO - FINISH
	CMPB	#'9,R1			;TRY AGAIN
	BLT	10$			;NO CHANCE - GO FINISH
	ASHI	3,R0			;MAKE SOME ROOM
	BIC	#'0,R1			;MAKE BINARY
	ADD	R1,R0			;AND ADD IT IN
	SOB	R3,7$			;FINISHED?

;HERE WHEN NUMBER DECODED

10$:	POP	R2
	POP	R1
	TST	R3
	BGT	MSGAXX			;NON- NUMERIC/NON-NULL FOUND
	BIT	#177400,R0		;BIGGER THAN A BREADBOX?
	BNE	MSGAXX			;NOPE-GO FAIL
11$:	CLRB	PKDATA(R2)		;IGNORE DVnnn@
	MOVB	R0,PKDATA+5(R2)		;STORE SOCKET NO. IN PKT
	BR	LFDO4N			;GET MORE INPUT

;HERE WITHOUT DEVICE NAME TERMINATOR MATCH

12$:	CMP	#'/,R0			;START OF DST EXTENSION?
	BNE	13$			;NO
	MOVB	#10,PKDATA(R2)		;YES-FIX UP THE COUNT
	BR	LFDO4N			;CONTINUE

13$:	CMP	#6,R3
	BLE	MSGAXX
	ADD	R2,R3			;CALCULATE WHERE TO PUT CHARACTER
	MOVB	R0,PKDATA+6(R3)		;STORE CHARACTER
14$:	INCB	PKDATA(R2)		;BUMP COUNT
	BR	LFDO4N			;THATS ALL

;HERE ON FINAL CHARACTER OF THE SUPERVISOR DIALOG

MSGAX6:	MOVB	PKCNT(R1),R3		;GET COUNT FOR DATA PACKET
	ADD	R1,R3
	ADD	#PKDATA,R3
	MOVB	R0,(R3)+		;STORE FINAL CHARACTER
	INCB	PKCNT(R1)
	PUSH	SD			;SAVE THIS SDB
	CALL	GRBSDB#			;GET AN SDB
	BCS	MSGAXF			;IF NONE AVAILABLE NOW
	POP	R0			;GET PREVIOUS SDB AGAIN FOR A WHILE
	MOVB	SDSOC#(R0),SDLFQN#(SD)	;REMEMBER THE DIALOG NUMBER
	MOV	(R1),R0			;GET CONNECT PACKET
	CLR	(R1)			;CLEAR THE POINTER
	MOV	R0,R1
	MOVB	#164,PKDATA+35(R1)	;STORE FLAG BYTE
	MOVB	#P.TYMS+1,PKDATA+36(R1)	;STORE TERMINAL PROFILE
	MOV	#$H1AUX,SDLFS1#(SD)	;INDICATE CONNECT PACKET IS OUTSTANDING
	CALL	TYMCON#			;FINISH SETTING UP AND SEND THE CONNECT
					;  PACKET
	MOVB	DDSOC#(R4),R0		;get count of sockets on link
	MOV	DDSX#(R4),R2 		;Get pointer to first SDB pointer
30$:	MOV	(R2)+,R1		;Get SDB address
	TBBE	$S1INU,SDSTS1#(R1),40$	;Is the socket in use
	SOB	R0,30$			;Yes - try next one
;All the sockets are in use - inform gateway

	MOV	#.SFHOP,R0		;GET SUB-FUNCTION
	CALL	MSGSPX			;Send message to gateway
	 BR	 40$			;Handle failure
	BIS	#$D1ASB,DDSTS1#(R4)	;Keep a record of doing this
40$:	BR	LFDO4N			;THATS ALL

;HERE IF NO FREE SOCKETS ARE AVAILABLE

MSGAXF:	MOV	(SP),SD			;RESTORE SD
	MOV	#$RQSR4,(SP)		;GET MESSAGE REQUEST BIT
MSGAX9:	CLR	SDLFAX#(SD)		;CLEAR POINTER
	PUSH	(R1)			;SAVE ADDRESS OF 2ND PACKET
	FREPKT				;GIVE UP THE FIRST ONE
	POP	R1			;AND THE SECOND
	BEQ	2$
	FREPKT
2$:	POP	R0			;RESTORE REQUEST BIT
	CALL	SNDHST			;SEND MESSAGE TO HOST
LFDO4N:	JMP	LFDONE			;FINISHED

; MAKE CONNECT PACKET AND LINK IT TO DATA PACKET WITH USER NAME

MAKCON:	CALL	MAKPKX			;GET ANOTHER PACKET
	MOV	R1,@SDLFAX#(SD)		;LINK TO PREVIOUS PACKET
	MOV	#24,R0			;CLEAR OUT THE PACKET
2$:	CLR	(R1)+
	SOB	R0,2$
	MOV	#.PTCON*400+37,PKCNT-50(R1);STORE PACKET TYPE AND COUNT
	RETURN
	.PAGE
;HERE FOR "TEST PATTERN PROBE" MESSAGE (.MSTSP = 31)

MSGTSP:	MOV	DDLFIX#+2(R4),DDLFT1#(R4);COPY TEST PATTERN DATA
	MOV	DDLFIX#+4(R4),DDLFT2#(R4)
	MOV	#$RQTPR,R0		;REQUEST RESPONSE
	BR	LFDO4N			;THATS ALL

;HERE FOR "HOST SAD" MESSAGE (.MSSAD = 33)

MSGSAD:	MOV	DDLFGS#(R4),SD		;GET SUPERVISORY SDB
	BEQ	LFDO4N			;FORGET IT IF NONE
	CMPB	SDSTS1#(SD),#.SSCON	;IS IT CONNECTED?
	BNE	LFDO4N			;NO-FORGET IT
	MAKPKX			;YES-GET A PACKET
	MOV	#.PTFUN*400+6,PKCNT(R1)	;STORE PACKET TYPE AND COUNT
	MOV	#.SFSAD*400+.FNDCN,PKDATA(R1);STORE FIRST 2 DATA BYTES
	MOV	DDLFIX#+2(R4),PKDATA+2(R1);STORE SAD BITS
	MOV	DDLFIX#+4(R4),PKDATA+4(R1)
	BR	MSGSND			;GO SEND THE PACKET AND FINISH UP

;HERE FOR "HOST IS SHUT" MESSAGE (.MSSHT = 2)

MSGSHT:	BIC	#$D1ANS,DDSTS1#(R4)	;INDICATE NOT ANSWERED
	CLR	R0			;GET SUB-FUNCTION (.SFSHT = 0)
	BR	MSGSPR			;CONTINUE

;HERE FOR "HOST IS ANSWERED" MESSAGE (.MSANS = 1)

MSGANS:	BIS	#$D1ANS,DDSTS1#(R4)	;IN;DICATE ANSWERED
	MOV	#.SFANS,R0		;GET SUB-FUNCTION
MSGSPR:	CALL	MSGSPX			;SEND FUNCTION TO GATEWAY
	 NOP
	BR	LFDO4N

;HERE FOR "CLOCK REQUEST" MESSAGE (.MSCRQ = 42)

MSGCRQ:	MOV	#.SFTOD,R0		;GET SUB-FUNCTION (.SFTOD = 3)
	BR	MSGSPR			;CONTINUE


;HERE FOR "ECHO ON" MESSAGE (.MSECN = 34)

MSGECN:	MOV	#.TPECH*400+1,R0	;PARAMETER = ECHO, VALUE = 1
	BR	NEDSDP

;HERE FOR "ECHO OFF" MESSAGE (.MSECF = 35)

MSGECF:	MOV	#.TPECH*400+0,R0	;PARAMETER = ECHO, VALUE = 0
NEDSDP:	MOV	#.PTFUN*400+.FNSDP,R2	;PACKET = FUNCTION, FUNCTION = SET
					;  TERMINAL PARAMETERS
NEDCN3:	MOV	#3,R3			;BYTE COUNT = 3
NEDPKT:	CALL	MAKPKX			;GET A PACKET
	INCB	SDPCNT#(SD)
	MOVB	R3,PKCNT(R1)		;STORE BYTE COUNT
	MOVB	R2,PKDATA(R1)		;STORE FIRST DATA BYTE
	SWAB	R2
	MOVB	R2,PKTYPE(R1)		;STORE PACKET TYPE
	MOVB	R0,PKDATA+2(R1)		;STORE THIRD DATA BYTE
	SWAB	R0
	MOVB	R0,PKDATA+1(R1)		;STORE SECOND DATA BYTE
MSGSND:	CALL	SNDPKT#			;SEND THE PACKET
	BR	LFDO4N			;THATS ALL
	.PAGE
;HERE FOR "TERMINAL CHARACTERISTICS" MESSAGE (.MSTCS = 36)

MSGTCS:	CMPB	#17,DDLFIX#+2(R4)	;LEGAL PARAMETER?
	BLO	LFDO4N			;NO-IGNORE IT!
	CALL	MAKPKX			;YES-GET A PACKET
	INCB	SDPCNT#(SD)
	MOVB	DDLFIX#+3(R4),R2	;GET VALUE FOR CHARACTERISITIC
	MOVB	DDLFIX#+2(R4),R0	;GET CHARACTERISTIC
	ASL	R0
	ADD	R0,PC			;DISPATCH ON THE VALUE
	BR	TCSECC			; 0 - ECHO CONTROL
	BR	TCSECI			; 1 - ECHO ^I
	BR	TCSELC			; 2 - ECHO LF WITH CR
	BR	TCSECL			; 3 - ECHO CR WITH LF
	BR	TCSCRD			; 4 - CR DELAY
	BR	TCSIBR			; 5 - INPUT BAUD RATE
	BR	TCSOBR			; 6 - OUTPUT BAUD RATE
	BR	TCSPAR			; 7 - PARITY CONTROL
	BR	TCSHLF			;10 - HALF DUPLEX
	BR	TCSPRA			;11 - PARAMETER A
	BR	TCSPRB			;12 - PARAMETER B
	BR	TCSPRC			;13 - PARAMETER C
	BR	TCSXEN			;14 - X-ENABLE
	BR	TCSECH			;15 - ECHO ^H
	BR	TCSRXE			;16 - REVERSE X-ENABLE
;	BR	TCSKAT			;17 - KATAKANA

;HERE FOR TERMINAL CHARACTERISITIC 17 - KATAKANA

TCSKAT:	MOV	#.TPKAT,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 16 - REVERSE X-ENABLE

TCSRXE:	MOV	#.TPOHE,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 15 - ECHO ^H

TCSECH:	MOV	#.TPEBS,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 14 - X-ENABLE

TCSXEN:	MOV	#.TPIHE,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 13 - PARAMETER C

TCSPRC:	MOV	#.TPMCD,R3		;GET NETWORK PARAMETER
	CMP	#17,R2			;LEGAL VALUE?
	BHIS	2$			;YES
	MOV	#17,R2			;NO-USE HIGHEST LEGAL VALUE
2$:	MOVB	TYNFNF#(R2),R2		;APPLY "FUNCTION F"
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 12 - PARAMETER B

TCSPRB:	MOV	#.TPFCD,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 11 - PARAMETER A

TCSPRA:	MOV	#.TPVCD,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 10 - HALF-DUPLEX

TCSHLF:	MOV	#.TPLCP,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 7 - PARITY CONTROL

TCSPAR:	MOV	#.TPPAR,R3		;GET NETWORK PARAMETER
	TST	R2			;DOES HE WANT PARITY?
	BEQ	TCSSMP			;NO-SEND 0
	MOV	#4,R2			;YES
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 6 - OUTPUT BAUD RATE

TCSOBR:	MOV	#.TPORT,R3		;GET NETWORK PARAMETER
	BR	TCSRAT			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 5 - INPUT BAUD RATE

TCSIBR:	MOV	#.TPIRT,R3		;GET NETWORK PARAMETER
TCSRAT:	CMP	#17,R2			;VALID RATE?
	BGE	2$			;YES
	MOV	#2,R2			;NO-ASSUME 300 BAUD!
2$:	MOVB	TYNRTN#(R2),R2		;YES-GET NETWORK VALUE
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 4 - CARRIAGE RETURN DELAY SWITCH

TCSCRD:	MOV	#.TPBLT,R3		;GET NETWORK PARAMETER
TCSSMC:	COM	R2			;REVERSE THE VALUE
	BIC	#^C1,R2			;ONLY 1 BIT
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 3 - ECHO LF WITH CR

TCSELC:	MOV	#.TPCRI,R3		;GET NETWORK PARAMETER
	BR	TCSEXX			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 2 - ECHO CR WITH LF

TCSECL:	MOV	#.TPLFI,R3		;GET NETWORK PARAMETER
TCSEXX:	TST	R2			;CHECK HIS VALUE
	BEQ	TCSSMP			;IF HE WANTS TO CLEAR IT
	MOV	#4,R2			;IF HE WANTS TO SET IT
	BR	TCSSMP			;THATS ALL

;HERE FOR TERMINAL CHARACTERISITIC 1 - ECHO ^I

TCSECI:	MOV	#.TPEHT,R3		;GET NETWORK PARAMETER
	BR	TCSSMP			;CONTINUE

;HERE FOR TERMINAL CHARACTERISITIC 0 - ECHO CONTROL

TCSECC:	MOV	#.TPECH,R3		;GET NETWORK PARAMETER
TCSSMP:	MOVB	R2,PKDATA+2(R1)		;STORE VALUE IN PACKET
	MOVB	R3,PKDATA+1(R1)		;STORE PARAMETER IN PACKET
	MOVB	#.FNCDP,PKDATA(R1)	;STORE FUNCTION = CHANGE TERMINAL PARA.
FNCPKT:	MOV	#.PTFUN*400+3,PKCNT(R1)	;STORE PACKET TYPE AND COUNT
	CALL	SNDPKT			;SEND THE PACKET
LFDO9N:	JMP	LFDONE			;THATS ALL
	.PAGE
;HERE FOR "TERMINAL CHARACTERISTICS PROBE" MESSAGE (.MSTCP = 37)

MSGTCP:	MOVB	DDLFIX#+2(R4),R0	;GET PARAMETER VALUE
	CMP	#77,R0			;SPECIAL VALUE?
	BNE	MSGTC4			;NO-GO ON
	CALL	MAKPKX			;YES-GET A PACKET
	INCB	SDPCNT#(SD)
	MOV	#20,R0			;SET INDEX
	MOV	#PKDATA+1,R2		;GET POINTER
	ADD	R1,R2
2$:	MOVB	TCPTBL-1(R0),(R2)+	;GET PARAMETER
	CLRB	(R2)+			;CLEAR DUMMY ARGUMENT BYTE
	SOB	R0,2$			;LOOP IF MORE
	MOVB	#.FNADP,PKDATA(R1)	;STORE FUNCTION
	MOV	#.PTFUN*400+41,PKCNT(R1);STORE PACKET TYPE + COUNT
	CALL	SNDPKT#			;SEND THE PACKET
	BR	LFDONE			;FINISHED

MSGTC4:	CMP	#17,R0			;LEGAL VALUE?
	BLO	LFDO9N			;NO-IGNORE THE MESSAGE
	MOVB	TCPTBL(R0),R0		;GET NETWORK PARAMETER
	CALL	MAKPKX			;GET A PACKET
	INCB	SDPCNT#(SD)
	MOVB	R0,PKDATA+1(R1)		;STORE PARAMETER
	MOVB	#.FNADP,PKDATA(R1)	;FUNCTION = ACCESS TERMINAL PARA.
	BR	FNCPKT			;CONTINUE

;TABLE OF NETWORK PARAMETERS FOR TERMINAL CHARACTERISTICS PROBE MESSAGES

	PURE

TCPTBL:	.BYTE	.TPECH			; 0 - ECHO CONTROL
	.BYTE	.TPSHT			; 1 - ECHO ^I
	.BYTE	.TPLFI			; 2 - ECHO CR WITH LF
	.BYTE	.TPCRI			; 3 - ECHO LF WITH CR
	.BYTE	.TPBLT			; 4 - CR DELAY
	.BYTE	.TPIRT			; 5 - INPUT BAUD RATE
	.BYTE	.TPORT			; 6 - OUTPUT BAUD RATE
	.BYTE	.TPPAR			; 7 - PARITY CONTROL
	.BYTE	.TPLCP			;10 - HALF DUPLEX
	.BYTE	.TPVCD			;11 - PARAMETER A
	.BYTE	.TPFCD			;12 - PARAMETER B
	.BYTE	.TPMCD			;13 - PARAMETER C
	.BYTE	.TPIHE			;14 - X-ENABLE
	.BYTE	.TPEBS			;15 - ECHO ^H
	.BYTE	.TPOHE			;16 - REVERSE X-ENABLE
	.BYTE	.TPKAT			;17 - KATAKANA

	CODE
	.PAGE
;HERE FOR "INITIATE BLOCK MODE OUTPUT" MESSAGE (.MSBKO = 44)

MSGBKO:	BIS	#$H1BKO,SDLFS1#(SD)	;INDICATE BLOCK MODE OUTPUT ACTIVE
	MOV	DDLFIX#+2(R4),R0	;GET COUNT
	SWAB	R0			;PUT BYTES IN RIGHT ORDER!
	MOV	R0,SDLFBO#(SD)		;STORE COUNT
	MOVB	DDLFIX#+4(R4),SDLFO1#(SD);STORE ADDRESS
	MOVB	DDLFIX#+5(R4),SDLFO0#+1(SD)
	MOVB	DDLFIX#+6(R4),SDLFO0#(SD)
	CMPB	SDPMAX#(SD),SDPCNT#(SD)	;CAN WE ACCEPT HOST INPUT NOW?
	BGT	2$			;YES
	BIS	#$S1STP,SDSTS1#(SD)	;NO-INDICATE STOPPED
	BR	LFDONE			;THATS ALL

;HERE IF CAN ACCEPT SOME INPUT NOW

2$:	CALL	STRBKO			;START BLOCK OUTPUT
	BR	LFDONE			;FINISHED

;HERE FOR "INITIALE BLOCK MODE INPUT" MESSAGE (.MSBIN = 46)

MSGBIN:	CLR	SDLFXF#(SD)		;CLEAR AMOUNT TRANSFERED
	BIS	#$H1BKI,SDLFS1#(SD)	;INDICATE BLOCK INPUT IS ACTIVE
	MOV	DDLFIX#+2(R4),R0	;GET COUNT
	SWAB	R0			;PUT BYTES IN RIGHT ORDER!
	MOV	R0,SDLFBI#(SD)		;STORE COUNT
	BEQ	MSGBI2			;IF REQUEST IF FOR ZERO BYTES
	MOVB	DDLFIX#+4(R4),SDLFI1#(SD);STORE ADDRESS
	MOVB	DDLFIX#+5(R4),SDLFI0#+1(SD)
	MOVB	DDLFIX#+6(R4),SDLFI0#(SD)
	BIC	#$S1HLD,SDSTS1#(SD)	;INDICATE HOST WANTS DATA NOW
	MOV	#JIFX16#,R0		;START THE INPUT TIMER
	MOV	#HNGBMI,R1
	CALL	TIMREQ#
	MOV	SDPKDH#(SD),R1		;ANY PACKETS WAITING?
	BEQ	LFDONE			;NO
	CALL	RSPOKE#			;YES-START OUTPUT
	BR	LFDONE			;FINISHED FOR NOW

;HERE ON INPUT TIME-OUT

HNGBMI:	BIS	#$H1BKT,SDLFS1#(SD)	;INDICATE TIME-OUT
	BIS	#$S1HLD,SDSTS1#(SD)	;NO MORE OUTPUT NOW
	MOV	#$RQBID,R0		;REQUEST MESSAGE TO HOST
	CJMP	SNDHST			;QUEUE THE REQUEST AND RETURN

;HERE IF REQUEST IS FOR ZERO BYTES

MSGBI2:	BIS	#$S1HLD,SDSTS1#(SD)	;INDICATE NO OUTPUT TO HOST NOW
	MOV	#$RQBID,R0		;INDICATE BUFFER IS "COMPLETE"
	BR	MSGSNH

;HERE FOR "REQUEST BLOCK MODE INPUT TERMINATION" MESSAGE (.MSIRQ = 52)

MSGIRQ:	MOV	#$RQBIT,R0		;REQUEST MESSAGE TO TELL HOST
	BR	MSGSNH

;HERE FOR "REQUEST BLOCK MODE OUTPUT TERMINATION" MESSAGE (.MSORQ = 54)

MSGORQ:	TBBN	$H1BOA,SDLFS1#(SD),2$	;IS THIS SOCKET ACTIVE NOW?
	BIC	#$H1BKO!$H1BOK,SDLFS1#(SD);NO-INDICATE NOT BLOCK MODE NOW
	MOV	#$RQBOC,R0		;REQUEST MESSAGE TO HOST
	BR	MSGSNH

;HERE TO TERMINATE SOCKET WHICH IS NOW TRANSFERRING BLOCK MODE DATA

2$:	BIS	#$H1BOK,SDLFS1#(SD)	;INDICATE SHOULD KILL THIS TRANSFER
	BR	LFDONE			;THATS ALL

;HERE FOR "NEGOTIATE FOR BLOCK MODE PORTS" MESSAGE (.MSNEG = 56)

MSGNEG:	MOVB	DDLFIX#+2(R4),DDLFBP#(R4);GET NUMBER OF PORTS HE WANTS
	MOV	#$RQNEG,R0		;REQUEST MESSAGE
MSGSNH:	CALL	SNDHST
	BR	LFDONE			;FINISHED

;HERE FOR "ENTER ALTERNATE OUTPUT MODE" MESSAGE (.MSEAD = 61)

MSGEAD:	MOV	#.TPADM*400+1,R0	;PARAMETER = ALTERNATE DEVICE MODE,
	BR	NEDS8D			;  VALUE = 1

;HERE FOR "LEAVE ALTERNATE OUTPUT MODE" MESSAGE (.MSLAD = 62)

MSGLAD:	MOV	#.TPADM*400+0,R0	;PARAMETER = ALTERNATE DEVICE MODE,
NEDS8D:	JMP	NEDSDP			;  VALUE = 0
	.PAGE
LFDONE:	CLRB	DDLFIS#(R4)		;(.ISIDL=0) SET NEW INPUT STATE
LFDON2:	CALL	LKFACP#			;ACCEPT THE LAST INPUT DATA
10$:	BITB	#$RQOUT,DDLFRQ#(R4)	;IS THERE AN OUTPUT REQUEST NOW?
	BNE	LFOUTD			;YES-GO HANDLE IT
	JMP	LFMAI2			;NO
	.PAGE
	.SBTTL	LFOUTD	- Output done

;HERE WHEN OUTPUT IS FINISHED

LFOUTD:	BIC	#$RQOUT,DDLFRQ#(R4)	;CLEAR OUTPUT REQUEST
	CLRB	DDLFTD#(R4)		;CLEAR THE DATA TIMER
	MOV	DDLFOZ#(R4),SD		;GET DDB FOR THIS TRANSFER
	BEQ	LFOUT4			;IF NOTHING TO CLEAR UP!!
	TBBE	$H1BKH!$H1BKD,SDLFS1#(SD),LFOUT1;DOING BLOCK MODE STUFF?
	TBBN	$H1BKD,SDLFS1#(SD),LFOBK6;YES-DATA OR HEADER?
	BIS	#$H1BKD,SDLFS1#(SD)	;HEADER-INDICATE DATA NEXT
	MOV	DDLFOV#(R4),DDLFOP#(R4)	;GET POINTER WHERE IT SHOULD BE
	MOVB	SDLFVC#(SD),R2		;GET NUMBER OF BYTES HELD
	BEQ	LFOBK4			;IF NONE
	CLRB	SDLFVC#(SD)		;CLEAR COUNT
	MOV	SDLFVH#(SD),R0		;GET FIRST WORD TO OUTPUT
	SWAB	R0
	CMP	#2,R2			;ONLY NEED ONE WORD?
	BLT	2$			;NO
	CLRB	DDLFOC#(R4)		;YES-CLEAR COUNT
	CLR	DDLFOS#(R4)		;SET OUTPUT STATE
	JMP	LKFST9			;AND GO DO OUTPUT

;HERE IF HAVE MORE THAN ONE WORD TO OUTPUT FOR BLOCK MODE

2$:	MOV	DDLFBI#(R4),R2		;GET BYTE COUNT
	INC	R2			;ROUND UP
	ASR	R2
	MOVB	R2,DDLFOC#(R4)		;STORE WORD COUNT
	MOV	#.OSHLD,DDLFOS#(R4)	;SET OUTPUT STATE
	JMP	LKFST9			;GO DO OUTPUT

;HERE IF BLOCK MODE HOLD BUFFER IS EMPTY

LFOBK4:	CLR	R0			;GET FIRST WORD TO OUTPUT
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
	SWAB	R0
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
2$:	MOV	DDLFBI#(R4),R2		;GET BYTE COUNT
	DEC	R2			;CHANGE TO PDP-11 WORD COUNT - ROUND
	ASR	R2			;  UP (NOTE: THIS DOES NOT INCLUDE
					;  THE FIRST WORD OUTPUT)
	MOVB	R2,DDLFOC#(R4)		;STORE COUNT
	JMP	LKFST8			;GO SET STATE AND START OUTPUT

;HERE WHEN FINISHED SENDING BLOCK MODE DATA TO HOST

LFOBK6:	BIC	#$H1BKH!$H1BKD,SDLFS1#(SD);CLEAR FLAGS
	TST	SDLFBI#(SD)		;IS THIS BUFFER COMPLETE?
	BNE	LFOUT1			;NO
	BIS	#$S1HLD,SDSTS1#(SD)	;YES-HOLD OUTPUT TO HOST
	MOV	#$RQBID,R0		;SEND MESSAGE TO HOST
	CALL	SNDHST
LFOUT1:	MOV	DDLFOK#(R4),R1		;DO WE HAVE AN OUTPUT PACKET?
	BEQ	LFOUT2			;NO-GO ON
	CLR	DDLFOK#(R4)		;YES-CLEAR POINTER
	MOVB	PKCNT(R1),R0		;ANY THING LEFT IN THIS PACKET?
	BEQ	4$			;NO
	CALL	PKTAGN#			;YES-PUT THIS PACKET BACK!!
	BR	LFOUT2			;CONTINUE

4$:	CALL	GIVPKT#			;GIVE UP THE PACKET

;HERE TO SEE IF SHOULD PUT THE SOCKET WHICH JUST DID OUTPUT BACK INTO
;  THE SEND LIST

LFOUT2:	MOV	SDPKDH#(SD),R1		;MORE TO SEND NOW?
	BEQ	LFOUT3			;NO-GO ON
	CALL	CHKRSP#			;YES-CAN WE OUTPUT IT NOW?
	BMI	LFOUT3			;NO-CONTINUE
	CALL	LKPOK0#			;YES-PUT SDB BACK ON THE SEND LIST

;HERE WHEN COMPLETELY FINISHED CLEANING UP AFTER THE LAST OUTPUT - NOW FIND
;  THE NEXT THING TO OUTPUT

LFOUT3:	CLR	DDLFOZ#(R4)		;CLEAR SDB POINTER FOR SAFETY!
LFOUT4:	MOV	DDLKFH#(R4),SD		;GET SDB WITH INSERTED MESSAGE
	BNE	LFOUT7			;GO PROCESS IT
2$:	CALL	NXTPKT#			;GET NEXT PACKET TO SEND
	BCS	LFOUT9			;IF NONE THERE
	CALL	CHKRSP#			;CAN WE STILL OUTPUT THIS ONE?
	BMI	2$			;NO-FALSE ALARM!
	CALL	REMOVE#			;YES-REMOVE PACKET FROM THE DST LIST
4$:	CLR	(R1)			;MAKE SURE LINK WORD IS CLEAR
	CALL	DECPCN#			;DECREASE SENDER'S PACKET COUNT
	CALL	LKFSTR			;START OUTPUT
	BCS	LFOUT2			;TRY AGAIN IF DIDN'T START OUTPUT
LFOUT6:	JMP	LFMAI2			;THATS ALL FOR NOW

;HERE WITH SDB WITH INSERTED MESSAGE

LFOUT7:	MOV	SDLKFL#(SD),DDLKFH#(R4)	;REMOVE FROM LIST
	BNE	2$
	CLR	DDLKFT#(R4)		;CLEAR TAIL IF LIST IS EMPTY NOW
2$:	MOV	#-1,SDLKFL#(SD)		;INDICATE NOT IN LIST NOW
	CALL	SNDHS2			;START OUTPUT TO HOST
	BR	LFOUT6			;THATS ALL FOR NOW

;HERE IF NOTHING TO SEND TO HOST NOW

LFOUT9:	BIC	#$D1ACT,DDSTS1#(R4)	;CLEAR ACTIVE FLAG
	BR	LFOUT6			;THATS ALL

;HERE FROM DDB DISPATCH FROM NXTPKT IF NEED TO SEND "FLAG PACKET" - THIS IS
;  IMPOSSIBLE SINCE WE USE THE FLAG LIST FOR A DIFFERENT PURPOSE AND NEVER
;  CALL NXTPKT UNLESS IT IS EMPTY!!

LFOUTX::RSTOP	FNE			;[FLAG LIST NOT EMPTY]
	.PAGE
	.SBTTL	SNDHST	- Send message to host

;SUBROUTINE TO SEND MESSAGE TO HOST
;	C(R0) = REQUEST BIT FOR MESSAGE
;	CALL	SNDHST

SNDHST:	BIS	R0,SDLFRQ#(SD)		;SET THE REQUEST BIT
	TBBE	$D1ACT,DDSTS1#(R4),SNDHS2;IS OUTPUT ACTIVE NOW?
SNDHS1:	CMP	#-1,SDLKFL#(SD)		;ALREADY IN THE LIST?
	BNE	4$			;YES-NOTHING MORE NEEDED!
	MOV	DDLKFT#(R4),R0		;NO-MUST QUEUE THE REQUEST
	BNE	2$
	MOV	SD,DDLKFH#(R4)		;LIST EMPTY-PUT AT HEAD
	BR	3$

2$:	MOV	SD,SDLKFL#(R0)		;LINK TO END OF CURRENT LIST
3$:	MOV	SD,DDLKFT#(R4)		;UPDATE TAIL POINTER
	CLR	SDLKFL#(SD)		;CLEAR THE LINK WORD
4$:	RETURN				;THATS ALL FOR NOW

;HERE IF OUTPUT IS IDLE - START OUTPUT

SNDHS2:	MOV	SDLFRQ#(SD),R0		;GET REQUEST BITS
	BEQ	8$			;IGNORE FALSE ALARMS!
	CLR	R2			;FOR COUNT
2$:	ROL	R0			;FIND A BIT WHICH IS SET
	INC	R2
	BCC	2$
	ASL	R2			;FOR WORD INDEXING
	BIC	BITTBL-2(R2),SDLFRQ#(SD);CLEAR THE REQUEST BIT
	BEQ	6$			;GO ON IF NO OTHER REQUESTS SET
	CALL	SNDHS1			;MORE SET-PUT ON TAIL OF LIST
6$:	JMP	@SNDDSP-2(R2)		;DISPATCH
8$:	RETURN

	PURE

	.EVEN
SNDDSP:	.WORD	SNDBON		;$RQBON = 100000 - BACKPRESSURE ON
	.WORD	SNDBOF		;$RQBOF = 040000 - BACKPRESSURE OFF
	.WORD	SNDRBO		;$RQRBO = 020000 - REQUEST BLOCK MODE OUTPUT
	.WORD	SNDBOC		;$RQBOC = 010000 - BLOCK OUTPUT COMPLETE
	.WORD	SNDBID		;$RQBID = 004000 - BLOCK INPUT BUFFER COMPLETE
	.WORD	SNDBIT		;$RQBIT = 002000 - BLOCK INPUT FINISHED
	.WORD	SNDNEG		;$RQNEG = 001000 - NEG. FOR BLOCK CHANNELS
	.WORD	SNDSR0		;$RQSR0 = 000400 - SUPERVISOR RESPONSE, 0
	.WORD	SNDSR1		;$RQSR1 = 000200 - SUPERVISOR RESPONSE, 1
	.WORD	SNDSR4		;$RQSR4 = 000100 - SUPERVISOR RESPONSE, 4
	.WORD	SNDTPR		;$RQTPR = 000040 - TEST PATTERN RESPONSE

;TABLE FOR CLEARING THE REQUEST BITS

BITTBL:	.WORD	100000,040000,020000,010000,004000,002000,001000,000400
	.WORD	000200,000100,000040

	CODE
	.PAGE
;HERE TO SEND "TEST PATTERN RESPONSE" MESSAGE

SNDTPR:	MOV	DDLFT1#(R4),DDLFOX#(R4);PUT TEST PATTERN DATA IN BUFFER
	MOV	DDLFT2#(R4),DDLFOX#+2(R4)
	MOV	#.MSTSR*400,R0		;GET MESSAGE TYPE
	TBBN	$D0KMC,(R4),LKFWC2	;KMC HOST?
	BIS	#100*400,R0		;NO-INDICATE THIS IS A LONG MESSAGE
LKFWC2:	MOV	#2,R2			;WORD COUNT = 2
	JMP	LKFMSG

;HERE TO SEND "SUPERVISOR RESPONSE, 4" MESSAGE

SNDSR4:	MOV	#4,DDLFOX#(R4)		;STORE DATA
	BR	SNDSRX			;CONTINUE

;HERE TO SEND "SUPERVISOR RESPONSE, 1" MESSAGE

SNDSR1:	MOV	#1,DDLFOX#(R4)		;STORE DATA
	BR	SNDSRX			;CONTINUE

;HERE TO SEND "SUPERVISOR RESPONSE, 0" MESSAGE

SNDSR0:	CLR	DDLFOX#(R4)		;STORE DATA
SNDSRX:	MOV	#.MSSUR*400,R0		;GET MESSAGE TYPE
LKFWC1:	MOV	#1,R2			;WORD COUNT = 1
	JMP	LKFMSG

;HERE TO SEND "NEG. FOR BLOCK CHANNELS" MESSAGE

SNDNEG:	MOVB	DDLFBP#(R4),DDLFOX#(R4)	;REPORT CURRENT NUMBER OF CHANNELS
	MOV	#.MSNEG*400,R0		;GET MESSAGE TYPE
	BR	LKFWC1			;GO SEND 1 DATA WORD
	.PAGE
;HERE WHEN BLOCK INPUT IS COMPLETELY TERMINATED

SNDBIT:	MOV	#.MSIHR,R0		;GET MESSAGE TO SEND
	BIC	#$H1BKI,SDLFS1#(SD)	;INDICATE NOT BLOCK MODE NOW
	BIC	#$S1HLD,SDSTS1#(SD)	;OUTPUT NO LONGER HELD
	BR	ENDBLK			;CONTINUE

;HERE WHEN BLOCK INPUT BUFFER IS COMPLETE

SNDBID:	MOV	#.MSINT,R0		;ASSUME TIME-OUT
	TBBN	$H1BKT,SDLFS1#(SD),ENDBLK;RIGHT?
	MOV	#.MSINB,R0		;NO-BUFFER FULL
ENDBLK:	PUSH	R0			;STACK IT
	MOV	#HNGBMI,R1		;KILL TIMER REQUEST
	CALL	TIMKIL#
	BIC	#$H1BKT,SDLFS1#(SD)	;CLEAR BITS
	MOV	#DDLFQX#,R2		;POINT TO MESSAGE BUFFER
	ADD	R4,R2
	MOVB	SDLFVC#(SD),R0		;ANY BYTES BEING HELD?
	BEQ	6$			;NO-SKIP THE FIRST STUFF!
	CMP	SDLFBI#(SD),R0		;MORE THAN HE WANTS NOW?
	BGE	4$			;NO
	RSTOP	TMB			;[TOO MANY BYTES]

4$:	CLRB	SDLFVC#(SD)
	SUB	R0,SDLFBI#(SD)		;REDUCE COUNT
	ADD	R0,SDLFXF#(SD)		;AND INCREASE AMOUNT TRANSFERED
	MOV	#<377*400>+.MSBLK,(R2)+	;STORE FIRST WORD IN BUFFER
	MOVB	#-2,(R2)+		;STORE REST OF COUNT VALUE
	MOVB	SDLFI1#(SD),(R2)+	;STORE HIGH ORDER ADDRESS BYTE
	MOV	SDLFI0#(SD),(R2)	;STORE LOW ORDER ADDRESS
	SWAB	(R2)+
	MOV	SDLFVH#(SD),(R2)+	;STORE DATA BYTES
	MOV	SDLFVH#+2(SD),(R2)+
6$:	POPB	(R2)+			;PUT MESSAGE TYPE INTO BUFFER
	MOVB	SDSOC#(SD),(R2)+	;STORE SOCKET NUMBER
	MOV	SDLFXF#(SD),R0		;GET TOTAL BYTE COUNT
	CLR	SDLFXF#(SD)
	SWAB	R0
	MOV	R0,(R2)+		;STORE BYTE COUNT
	DEC	DDLFAL#(R4)		;REDUCE COUNT
	BGT	10$			;AT END?
	MOV	DDLFAV#(R4),DDLFAL#(R4)	;YES-RESET COUNT
10$:	SUB	#DDLFOX#-1,R2		;CALCULATE WORD COUNT
	SUB	R4,R2
	ASR	R2
	MOVB	R2,DDLFOC#(R4)		;STORE WORD COUNT FOR OUTPUT
	MOV	#DDLFOX#,R1		;POINT TO BUFFER
	ADD	R4,R1
	MOV	R1,DDLFOP#(R4)		;SET POINTER
	MOV	DDLFQX#(R4),R0		;GET FIRST WORD TO OUTPUT
	SWAB	R0
	CLR	DDLFOS#(R4)		;SET OUTPUT STATE
	JMP	LKFST9			;GO DO OUTPUT
	.PAGE
;HERE TO SEND "BLOCK OUTPUT COMPLETE" MESSAGE

SNDBOC:	MOV	#.MSBOC*400,R0		;GET MESSAGE TYPE
	BR	SNDTRX

;HERE TO SEND "REQUEST BLOCK MODE OUTPUT" MESSAGE

SNDRBO:	BIS	#$H1BOA,SDLFS1#(SD)	;INDICATE BLOCK OUTPUT ACTIVE
	MOVB	SDPMAX#(SD),R3		;GET MAXIMUM NUMBER OF PACKETS WE CAN
	MOVB	SDPCNT#(SD),R2		;  ACCEPT NOW
	SUB	R2,R3
	BGT	2$
	MOV	#1,R3			;IF GET TO HERE, ALWAYS TAKE 1!
2$:	MUL	#PKCMAX,R3		;CHANGE TO CHARACTERS
	MOV	SDLFBO#(SD),R0		;GET NUMBER OF CHARACTERS HOST WANTS
					;  TO OUTPUT IN THIS BLOCK
	CMP	R3,R0			;MORE THAN WE CAN TAKE?
	BGT	4$			;NO
	BIC	#3,R3			;YES-MAKE SURE WE TAKE AN EVEN NUMBER
					;  OF PDP-10 WORDS (4 CHARACTERS/WORD)
	MOV	R3,R0			;REDUCE THE AMOUNT
4$:	SUB	R0,SDLFBO#(SD)		;REDUCE AMOUNT TO DO
	MOV	R0,DDLFBJ#(R4)		;STORE COUNT FOR COMPLETION ROUTINE
	INC	R0			;CHANGE TO CHARACTER PAIR COUNT
	ASR	R0
	MOV	R0,DDLFBC#(R4)		;STORE FOR INTERRUPT LEVEL
	BGT	10$			;IS IT A LEGAL COUNT?
	RSTOP	BBC			;[BAD BLOCK MODE COUNT]

10$:	MOV	SD,DDLFBS#(R4)		;REMEMBER THE SDB TOO
	MOV	SDLFO0#(SD),DDLFOX#+2(R4);PUT ADDRESS IN MESSAGE
	SWAB	DDLFOX#+2(R4)
	MOVB	SDLFO1#(SD),DDLFOX#+1(R4)
	MOV	#.OSBMO,DDLFOS#(R4)	;Set output state
	JMP	LKFBKM			;CONTINUE

;HERE TO SEND "BACKPRESSURE OFF" MESSAGE

SNDBOF:	MOV	#.MSOUP*400,R0		;GET MESSAGE TYPE
SNDTRX:	JMP	LKFWC0			;CONTINUE

;HERE TO SEND "BACKPRESSURE ON" MESSAGE

SNDBON:	MOV	#.MSNOP*400,R0		;GET MESSAGE TYPE
	BR	SNDTRX			;CONTINUE
	.PAGE
	.SBTTL	LKFSTR	- Start output to host

;SUBROUTINE TO START OUTPUT TO HOST
;	C(R1) = ADDRESS OF PACKET TO SEND
;	C(SD) = ADDRESS OF SDB
;	C(R4) = ADDRESS OF ADB
;	CALL	LKFSTR

LKFSTR::TSTB	PKPNT(R1)		;NEW PACKET?
	BNE	2$			;NO
	INCB	PKPNT(R1)		;YES-FIX UP THE POINTER
2$:	MOV	R1,R3			;COPY ADDRESS
	ADD	#PKDATA,R3		;POINT TO FIRST DATA BYTE
	MOVB	PKCNT(R1),R2		;GET BYTE COUNT FROM PACKET
	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	ASL	R0			;DISPATCH ON THE TYPE
	JMP	@PKTDSP(R0)

;PACKET TYPE DISPATCH TABLE

	PURE

	.EVEN
PKTDSP:	.WORD	LKFDAT			;.PTDAT =  0 - DATA
	.WORD	LKFCON			;.PTCON =  1 - CONNECTION REQUEST
	.WORD	LKFACK			;.PTACK =  2 - CONNECT ACKNOWLEDGEMENT
	.WORD	LKFNAK			;.PTNAK =  3 - CONNECT NEGATIVE ACK.
	.WORD	LKFFUN			;.PTFUN =  4 - FUNCTION
	.WORD	LKFFUN			;.PTINT =  5 - INTERRUPT
	.WORD	LKFFUN			;.PTEAT =  6 - EAT
	.WORD	LKFDIS			;.PTDIS =  7 - DISCONNECT
	.WORD	LKFDIS			;.PTKIL = 10 - KILL CONNECTION
	.WORD	LKFDAK			;.PTDAK = 11 - DISCONNECT ACK

	CODE
	.PAGE
;HERE FOR DATA PACKET

LKFDAT:	MOV	R2,R0			;COPY BYTE COUNT
	TBBN	$H1BKI,SDLFS1#(SD),LKFBLK;BLOCK MODE?
	JMP	LKFDA4			;NO-GO ON

;HERE IF BLOCK MODE

LKFBLK:	TST	SDLFBI#(SD)		;IS THERE A REQUEST ACTIVE NOW?
	BGT	1$			;YES-GO ON
	RSTOP	BBC			;[BAD BLOCK MODE COUNT]

1$:	MOVB	SDLFVC#(SD),R2		;GET NUMBER OF BYTES WE ARE HOLDING
	BNE	2$			;IF SOME THERE
	CMP	#4,R0			;NONE HELD-HAVE MORE THAN 4 TO SEND?
	BLE	LKFBH3			;YES
2$:	MOV	R2,R3			;NO-COPY COUNT FOR LATER
	SUB	SDLFBI#(SD),R2		;CALCULATE NUMBER WANTED IN EXCESS OF
	NEG	R2			;  THE ONES WE ARE HOLDING
	CMP	R2,R0			;MORE THAN WE HAVE NOW?
	BGE	4$			;YES
	MOV	R2,R0			;NO-JUST GIVE AS MANY AS HE WANTS
4$:	SUB	#4,R3			;CALCULATE NUMBER OF SPACES LEFT IN
	NEG	R3			;  THE HOLD BUFFER
	CMP	R0,R3			;DO WE HAVE THAT MANY?
	BGE	6$			;YES
	MOV	R0,R3			;NO-JUST AS MANY AS WE HAVE
6$:	MOVB	PKPNT(R1),R2		;CALCULATE POSITION OF FIRST BYTE IN
	ADD	R1,R2			;  THE PACKET
	ADD	#PKDATA-1,R2
	MOVB	SDLFVC#(SD),R0		;CALCULATE POSTION OF FIRST EMPTY
	ADD	#SDLFVH,R0		;  SLOT IN THE HOLD BUFFER
	ADD	SD,R0
	ADD	R3,SDLFVC#(SD)		;ADJUST COUNTS
	SUB	R3,PKCNT(R1)
	ADD	R3,PKPNT(R1)		;AND PACKET POINTER
14$:	MOVB	(R2)+,(R0)+		;COPY BYTE TO HOLD BUFFER
	SOB	R3,14$			;CONTINUE IF MORE TO COPY
	MOVB	SDLFVC#(SD),R2		;GET NUMBER OF BYTES BEING HELD
	CMP	#4,R2			;IS THE HOLD BUFFER FULL NOW?
	BLE	LKFBH2			;YES
	CMP	SDLFBI#(SD),R2		;NO-IS THIS ALL HE WANTS THIS TIME?
	BLE	LKFBH2			;YES-GIVE IT TO HIM!
	CALL	GIVPKT#			;NO-GIVE UP THE PACKET
	SEC				;INDICATE OUTPUT NOT STARTED
	RETURN				;THATS ALL

;HERE IF HAVE BLOCK MODE TRANSFER FOR THE HOST NOW
;  WILL GET HERE IF HOLD BUFFER IS FULL (4 BYTES) OR IF IT IS NOT FULL BUT
;  WHAT IS THERE WILL EXACTLY FILL THE CURRENT BLOCK BUFFER OR IF IT IS EMPTY
;  AND WE HAVE 4 OR MORE BYTES TO TRANSFER

LKFBH2:	SUB	R2,SDLFBI#(SD)		;REDUCE AMOUNT NEEDED BY AMOUNT HELD
	MOVB	PKCNT(R1),R0		;GET SIZE OF PACKET
LKFBH3:	CMP	SDLFBI#(SD),R0		;NEED THIS MANY?
	BGT	2$			;YES
	MOV	SDLFBI#(SD),R0		;NO-REDUCE AMOUNT
	BR	4$			;CONTINUE

2$:	BIC	#3,R0			;NEED MORE THAN WE HAVE-ROUND DOWN TO
					;  WHOLE PDP-10 WORDS
4$:	SUB	R0,SDLFBI#(SD)		;REDUCE AMOUNT NEEDED
	MOV	R0,DDLFBI#(R4)		;REMEMBER AMOUNT TO XFER
	ADD	R2,R0			;CALCULATE TOTAL AMOUNT XFERED
	ADD	R0,SDLFXF#(SD)		;ADD INTO GRAND TOTAL
	MOV	SDLFI0#(SD),DDLFOX#+2(R4);PUT ADDRESS IN MESSAGE
	SWAB	DDLFOX#+2(R4)
	MOVB	SDLFI1#(SD),DDLFOX#+1(R4)
	INC	R0			;CALCULATE PDP-11 WORDS XFERED
	ASR	R0
	MOV	R0,R2			;CALCULATE PDP-10 WORDS XFERED
	INC	R2
	ASR	R2
	ADD	R2,SDLFI0#(SD)		;UPDATE ADDRESS
	ADC	SDLFI1#(SD)
	NEG	R0			;COUNT IS NEGATIVE TO INDICATE INPUT
					;  TO HOST
	BLT	10$			;IS IT A LEGAL COUNT?
	RSTOP	BBC			;[BAD BLOCK MODE COUNT]

10$:	MOVB	PKPNT(R1),R2		;CALCULATE ADDRESS OF FIRST BYTE IN
	ADD	R1,R2			;  PACKET TO XFER
	ADD	#PKDATA-1,R2
	MOV	R2,DDLFOV#(R4)		;REMEMBER IT FOR LATER
	MOV	DDLFBI#(R4),R2		;GET PACKET BYTE COUNT FOR XFER
	ADD	R2,PKPNT(R1)		;UPDATE POINT IN PACKET
	SUB	R2,PKCNT(R1)		;AND THE COUNT
	MOV	R1,DDLFOK#(R4)		;STORE PACKET ADDRESS FOR LATER
	BIS	#$H1BKH,SDLFS1#(SD)	;INDICATE PROCESSING BLOCK MODE HEADER
	CLR	DDLFOS#(R4)		;Set output state
LKFBKM:	TST	R0			;IS THE COUNT 0?
	BNE	4$			;NO-GO ON
	RSTOP	ZBC			;[ZERO BLOCK MODE COUNT]

4$:	MOVB	R0,DDLFOX#(R4)		;STORE LOW ORDER BYTE OF COUNT
	SWAB	R0			;GET HIGH ORDER BYTE IN RIGHT PLACE
	BIC	#^C377,R0
	BIS	#.MSBLK*400,R0		;PUT IN SPECIAL MESSAGE CODE
	MOVB	#2,DDLFOC#(R4)		;WORD COUNT = 2 (NOTE: WE REALLY
					;  WANT TO SEND A TOTAL OF 3 PDP-11
					;  WORDS HERE!)
;******* BEGIN DEBUG *********
.IF NE	..BUG
	MOV	R0,XXXX			;STORE FOR DEBUGGING
	SWAB	XXXX
	MOV	DDLFOX#(R4),XXXX+2
	MOV	DDLFOX#+2(R4),XXXX+4
	MOV	DDLFOX#+4(R4),XXXX+6
	MOV	DDLFOX#+6(R4),XXXX+10
.ENDC
	MOV	#DDLFOX#,R1		;POINT TO MESSAGE BUFFER
	ADD	R4,R1
	MOV	R1,DDLFOP#(R4)
	BR	LKFST9			;GO START OUTPUT
.IF NE	..BUG
	IMPURE
	.EVEN
XXXX:	.WORD	0
	.WORD	0
	.WORD	0
	.WORD	0
	.WORD	0
	.WORD	0
	CODE
.ENDC
;******** END DEBUG **********
	.PAGE
;HERE IF NOT BLOCK MODE

LKFDA4:	TBBN	$D0KMC,(R4),4$		;IF WE ARE TALKING TO A KMC
	MOV	DDLFAL#(R4),R3		;GET AMOUNT LEFT IN HOST RING
	ASL	R3			;CONVERT TO PDP-11 WORDS
	DEC	R3			;COMPENSATE FOR 16 BIT HEADER
	ASL	R3			;CONVERT TO CHARACTERS
	CMP	R3,R0			;DO WE HAVE TOO MANY NOW?
	BGE	2$			;NO
	MOV	R3,R0			;YES-JUST SEND AS MANY AS WILL FIT!
2$:; THE FOLLOWING IN A PETTY COMPLICATED COMPUTATION TO TRY TO KEEP
;FROM HAVING TO PAD OUT A MESSAGE IN THE HOST, THAT IS WE WANT THE ENTIRE
;MESSAGE TO CONSIST OF AN EVEN NUMBER OF PDP-11 WORDS
;THE GOOD BYTE COUNTS ARE 1 AND 2 (PLUS MULTIPLES OF 4) AND THE BAD COUNTS
;ARE 3 AND 4 (PLUS MULTIPLES OF 4). WE CORRECT THE PROBLEM BY FINDING
;3 AND 4(AND THEIR MULTIPLES) AND SUBTRACTING 2. THIS WILL LEAVE 2 BYTES FOR
;THE NEXT TIME, BUT THAT IS OK SINCE 2 IS AN OK COUNT.

	DEC	R0			;NOW 0 AND 1 ARE OK AND 2 AND 3 ARE BAD
	BIT	#2,R0			;CHECK FOR 2 OR 3
	BNE	3$			;FOUND 2 OR 3
	ADD	#2,R0			;FIX ABOVE AND BELOW DEC INSTRUCTIONS
3$:	DEC	R0			;THIS WILL FINISH SUBTRACTING 2 FROM THE BAD COUNTS	
	SUB	R0,R2			;CALCULATE AMOUNT LEFT IN PACKET
	MOVB	R2,PKCNT(R1)		;UPDATE COUNT
	MOV	R0,R2			;COPY COUNT AGAIN
	BR	10$			;CONTINUE

;HERE IF TALKING TO KMC

4$:	CLRB	PKCNT(R1)		;ALWAYS SEND THE ENTIRE PACKET
10$:	INC	R2			;CALCULATE NUMBER OF PDP11 WORDS NEEDED
	ASR	R2
	MOV	R1,DDLFOK#(R4)		;STORE PACKET ADDRESS
	MOVB	PKPNT(R1),R3		;GET OFFSET TO FIRST DATA BYTE
	ADD	R0,PKPNT(R1)		;UPDATE THE OFFSET (NOTE: PKPNT IS
					;  EVEN!!)
	ADD	R3,R1			;POINT TO FIRST DATA BYTE
	ADD	#PKDATA-1,R1
	BIS	#200,R0			;SET THE SIGN BIT
	SWAB	R0			;PUT IN RIGHT PLACE

;HERE TO START OUTPUT TO THE HOST
;	C(R0) = FIRST BYTE TO OUTPUT (STRING COUNT + 200 OR MESSAGE TYPE) * 400
;	C(R1) = ADDRESS OF FIRST WORD TO OUTPUT
;	C(R2) = NUMBER OF WORDS TO OUTPUT

LKFST4:	MOV	R1,DDLFOP#(R4)		;STORE OUTPUT POINTER
LKFST5:	TBBN	$D0KMC,(R4),2$		;GO ON IF KMC
	BIS	#1,R2			;NOT KMC-FIX UP THE COUNT
2$:	MOVB	R2,DDLFOC#(R4)		;STORE WORD COUNT

;*****THE FOLLOWING USED TO BE TBBE, INSTEAD OF TBBN*****JWR*10-09-80

	TBBN	$D0KMC,(R4),10$		;SKIP THIS IF USING KMC
	INC	R2			;CHANGE TO ACTUAL PDP-10 WORDS TO XFER
	ASR	R2
	SUB	R2,DDLFAL#(R4)		;REDUCE AMOUNT TO END OF HOST RING
	BGT	10$			;CONTINUE IF SOMETHING LEFT
	ADD	DDLFAV#(R4),DDLFAL#(R4)	;AT (OR BEYOND) END-RESET AMOUNT
10$:	BISB	SDSOC#(SD),R0		;GET SOCKET NUMBER
LKFST8:	CLR	DDLFOS#(R4)		;CLEAR THE OUTPUT STATE
	BIT	#1,DDLFOP#(R4)		;ARE WE WORD ALLIGNED?
	BEQ	LKFST9			;YES
	MOV	#.OSODD,DDLFOS#(R4)	;NO
LKFST9:	TBBN	$D1DIS,DDSTS1#(R4),10$	;FORGET IF DISABLED!!
	CALL	LKFSTO#			;START OUTPUT TO HOST
	MOV	SD,DDLFOZ#(R4)		;SAVE ADDRESS OF SDB
	BIS	#$D1ACT,DDSTS1#(R4)	;INDICATE OUTPUT IS ACTIVE
	MOVB	#3.,DDLFTD#(R4)		;START THE DATA TIMER
10$:	CLC				;INDICATE OUTPUT STARTED
	RETURN				;FINISHED
	.PAGE
;HERE FOR CONNECT PACKET

LKFCON:	CLR	SDLFS1#(SD)		;CLEAR STATUS BITS
	TSTB	PKDATA+27(R1)		;Is this a supervisory connection?
	BMI	LKFSPC			;Yes-go handle that
	MOV	#DDLFOX#,R2		;POINT TO THE OUTPUT BUFFER
	ADD	R4,R2
	TBBN	$D0KMC,(R4),1$		;GO ON IF KMC
	TST	(R2)+			;NOT KMC-FIX UP THE POINTER
1$:	MOVB	#204,(R2)+
	MOVB	SDSOC#(SD),(R2)+	;GET SOCKET NUMBER
	CALL	TYNGTT#			;GET THE TYMNET TERMINAL TYPE
	BITB	#2,PKDATA+35(R1)	;HALF DUPLEX TERMINAL?
	BEQ	2$			;NO
	BIS	#40,R0			;YES-TELL THE HOST
2$:	MOVB	R0,(R2)+		;STORE IN CONNECT MESSAGE
	PUSH	R1			;SAVE ADDRESS OF PACKET
	ADD	#PKDATA+16,R1		;POINT TO SRC NAME
	PUSH	R2			;SAVE POINTER
	CLR	R3			;CLEAR RESULT
	MOV	#6.,R2			;SET MAXIMUM COUNT
4$:	MOVB	(R1)+,R0		;GET CHARACTER
	BEQ	10$			;IF END OF NAME
	BIC	#^C177,R0		;ONLY 7 BITS
	CMP	#'0,R0			;IS IT A DIGIT?
	BHI	6$			;NO
	CMP	#'7,R0
	BLO	6$			;NO
	BIC	#^C7,R0			;YES-GET VALUE
	ASHI	3,R3			;MERGE IN TO OLD VALUE
	ADD	R0,R3
	SOB	R2,4$			;CONTINUE IF MORE TO CHECK
	BR	10$			;FINISHED WITH NAME

;HERE IF SRC NAME NOT IN RIGHT FORMAT

6$:	MOV	#3456,R3		;USE THIS FUNNY NUMBER
10$:	POP	R2			;RESTORE POINTER
	MOV	R3,R0			;GET 2 6 BIT BYTES
	BIC	#^C77,R0
	ASHI	-6,R3
	MOVB	R3,(R2)+		;STORE NODE NUMBER
	MOVB	R0,(R2)+
	MOV	(SP),R1			;RESTORE ADDRESS OF PACKET
	MOVB	PKDATA+15(R1),(R2)+	;STORE SOCKET NUMBER ON NODE
	MOV	#3,R0			;WORD COUNT = 3 IF KMC
	TBBN	$D0KMC,(R4),12$		;IS IT A KMC?
	MOV	#5,R0			;NO-WORD COUNT IS REALLY 5!
	TST	(R2)+			;FIX UP THE POINTER
12$:	BITB	#020,PKDATA+35(R1)	;SHOULD THE HOST CHECK HIS PASSWORD?
	BNE	20$			;NO
	MOVB	#201,(R2)+		;YES-ADD A DATA MESSAGE AFTER THE
	MOVB	SDSOC#(SD),(R2)+	;  AFTER THE CONNECT MESSAGE
	MOVB	#174,(R2)+		;WHICH CONTAINS A "VERTICAL BAR"
	ADD	#2,R0			;FIX UP THE WORD COUNT
20$:	MOV	R0,R2			;GET COUNT INTO RIGHT REGISTER
	MOV	#.MSLOG*400,R0		;GET INITIAL WORD
	CALL	LKFMSG			;SEND MESSAGE TO HOST
	POP	R1			;RESTORE PACKET ADDRESS
	CLR	R0			;ACCEPT THE CONNECTION
	MOV	#P.TYMS*400+144,R2	;GET TERMINAL PROFILE + FLAG BITS
	CALL	ACCEPT#
	MOVB	DDSOC#(R4),R0		;get count of sockets on link
	MOV	DDSX#(R4),R2 		;Get pointer to first SDB pointer
30$:	MOV	(R2)+,R1		;Get SDB address
	TBBE	$S1INU,SDSTS1#(R1),40$	;Is the socket in use
	SOB	R0,30$			;Yes - try next one
;All the sockets are in use - inform gateway

	MOV	#.SFHOP,R0		;GET SUB-FUNCTION
	CALL	MSGSPX			;Send message to gateway
	 BR	 40$			;Handle failure
	BIS	#$D1ASB,DDSTS1#(R4)	;Keep a record of doing this
40$:	CLC				;GIVE GOOD RETURN
	RETURN

;Here for supervisory connect

LKFSPC:	TBBN	$D1DWN,DDSTS1#(R4),10$	;Are we up?
	MOV	SD,DDLFGS#(R4)		;Yes-save address of this SDB
	MOVB	DDSOC#(R4),R2		;Get port count
	SWAB	R2
	CLRB	R2			;Assume host not answered
	TBBE	$D1ANS,DDSTS1#(R4),2$	;Right?
	BIS	#200,R2			;No-its answered now
2$:	CLR	R0
	CALL	ACCEPT#			;Accept the connection
	SEC
	RETURN

;Here if down

10$:	MOV	#.ERHSD,R0		;Reason = host down
	CALL	REFUSE#
	SEC
	RETURN


MSGSPX:	MOV	DDLFGS#(R4),SD		;GET SUPERVISORY SDB
	BEQ	10$			;FORGET IT IF NONE
	CMPB	SDSTS1#(SD),#.SSCON	;IS IT CONNECTED?
	BNE	10$			;NO-FORGET IT
	CALL	MAKPKX			;YES-GET A PACKET
	MOV	#.PTFUN*400+2,PKCNT(R1)	;STORE PACKET TYPE AND COUNT
	MOVB	#.FNDCN,PKDATA(R1)	;STORE FUNCTION
	MOVB	R0,PKDATA+1(R1)		;STORE SUB-FUNCTION
	CALL	SNDPKT			;SEND PACKET
	ADD	#2,(SP)			;DO SUCCESS RETURN
10$:	RETURN
	.PAGE
;HERE FOR CONNECT ACK PACKET - WE CAN ONLY GET THIS AFTER SENDING OUT A
;  CONNECT PACKET, WHICH MEANS THAT A SUPERVISOR DIALOG IS ACTIVE ON SOME
;  PORT WHOSE SOCKET NUMBER IS IN SDLFQN FOR THE SOCKET WE RECEIVED THE ACK
;  ON.  WE MUST FIRST SEND AN "INTERNAL NEW CONNECTION" MESSAGE ON THE PORT
;  THE ACK HAS BEEN RECEIVED ON, FOLLOWED BY A "SUPERVISOR RESPONSE" ON THE
;  PORT WHICH CORRESPONDS TO THE SUPERVISOR DIALOG.  THIS TERMINATES THE
;  SUPERVISOR DIALOG.

LKFACK:	PUSHB	PKDATA+1(R1)		;SAVE REASON
	CALL	GIVPKT#			;GIVE UP THE ACK PACKET
	MOVB	SDLFQN#(SD),R0		;GET DIALOG NUMBER
	ASL	R0			;FIND CORRESPONDING SDB
	ADD	DDSX#(R4),R0
	MOV	-(R0),R0
	MOV	SDLFAX#(R0),R1		;GET INITIAL DATA PACKET
	BEQ	4$			;IF NONE (VERY STRANGE!)
	CLR	SDLFAX#(R0)		;CLEAR POINTER
	TBBE	040,(SP),2$		;DOES HE WANT THE LOGIN STRING?
	INCB	SDPCNT#(SD)		;YES
	CALL	SNDPKT#			;SEND THE DATA PACKET
	BR	4$

2$:	FREPKT				;GIVE UP THE DATA PACKET
4$:	POP	R0			;GET FLAG BYTE
	TBBN	001,R0,RTNCS6		;FINISHED IF STILL WANT LOGIN MODE
CLRLGI:	BIC	#$H1AUX,SDLFS1#(SD)	;INDICATE NOT BUILDING AUX-CIRCUIT NOW
	MOV	#DDLFOX,R2		;GET POINTER TO OUTPUT BUFFER
	ADD	R4,R2
	MOVB	SDLFQN#(SD),R0		;GET DIALOG NUMBER
	MOV	R0,(R2)			;AND STORE IT IN THE MESSAGE
	ADD	DDLFPO#(R4),(R2)+	;ADD IN THE PORT OFFSET
	MOVB	#.MSSUR,(R2)+		;NEXT IS A SUPERVISOR MESSAGE
	MOVB	R0,(R2)+		;STORE DIALOG NUMBER AGAIN
	CLRB	(R2)			;DATA BYTE = 0
	MOV	#.MSAUX*400,R0		;GET MESSAGE TYPE
LKFWC3:	MOV	#3,R2			;WORD COUNT = 3
	JMP	LKFMSG
	.PAGE
;HERE FOR CONNECT NAK PACKET

LKFNAK:	PUSHB	PKDATA(R1)		;SAVE REASON
	CALL	JNKPKT#			;GIVE UP THE PACKET
	TBBE	$D1ASB,DDSTS1#(R4),10$	;SKIP THIS IF WE DIDN'T DECLARE HOST OUT OF PORTS
	MOV	#.SFHHP,R0		;GET SUB-FUNCTION: HOST HAS PORTS
	CALL	MSGSPX			;Send message to gateway
	 BR	 10$			;Handle failure
	BIC	#$D1ASB,DDSTS1#(R4)	;Keep a record of doing this
10$:
LKFNK2:	CALL	FRESOC#			;GIVE UP THE SOCKET
	MOV	(SP),R0			;GET REASON
	MOV	SD,(SP)			;SAVE ADDRESS OF SDB
	MOVB	SDLFQN#(SD),SD		;GET DIALOG NUMBER
	ASL	SD			;GET CORRESPONDING SDB
	ADD	DDSX#(R4),SD
	MOV	-(SD),SD
	MOV	#9.,R2			;GET MAXIMUM ERROR CODE
4$:	CMPB	ERRTBL-1(R2),R0		;THIS ONE?
	BEQ	10$			;YES
	SOB	R2,4$			;NO
	MOV	#4,R2			;NOT IN TABLE-USE 4!
10$:	MOVB	R2,DDLFOX#(R4)		;PUT ERROR CODE IN MESSAGE
	MOV	#.MSSUR*400,R0		;MESSAGE TYPE = SUPERVISOR RESPONSE
	MOV	#1,R2			;GET WORD COUNT
	CALL	LKFMSG			;START OUTPUT
	BIC	#$H1AUX,SDLFS1#(SD)	;INDICATE CONNECT PACKET NOT OUTSTANDING
	MOV	SDLFAX#(SD),R1		;GET INITIAL DATA PACKET
	BEQ	2$			;IF NONE (JUST TO BE SAFE!)
	CLR	SDLFAX#(SD)		;CLEAR POINTER
	FREPKT				;GIVE BACK THE PACKET
2$:	POP	SD			;RESTORE OUR SDB
RTNCC6:	CLC				;INDICATED OUTPUT STARTED
	RETURN				;RETURN

;ERROR TABLE

	PURE

ERRTBL:	.BYTE	.ERFER			; 1 = LOGIN STRING FORMAT ERROR
	.BYTE	.ERUNE			; 2 = USER NAME ERROR
	.BYTE	.ERMUD			; 3 = MUD ERROR
	.BYTE	.ERHNA			; 4 = HOST NOT AVAILABLE (AND MOST
					;	OTHER ERRORS TOO!!)
	.BYTE	.ERCRJ			; 5 = COMMAND REJECT
	.BYTE	.ERTIM			; 6 = NETWORK TIMEOUT
	.BYTE	.ERPRV			; 7 = ACCESS BARRED
	.BYTE	.EROOP			; 8 = OUT OF ORIGINATING PORTS
	.BYTE	.ERAQF			; 9 = AUX-CIRCUIT QUEUE FULL

	CODE
	.PAGE
;HERE FOR DISCONNECT OR KILL PACKET

LKFDIS:	PUSHB	PKDATA(R1)		;SAVE REASON
	CALL	JNKPKT#			;GIVE UP THE PACKET (WE WILL SEND
					;  A DISCONNECT ACK WHEN THE HOST
					;  SENDS US A ZAPPER IN RESPONSE
					;  TO OUR ZAPPER
	TBBE	$D1ASB,DDSTS1#(R4),10$	;SKIP THIS IF WE DIDN'T DECLARE HOST OUT OF PORTS
	MOV	#.SFHHP,R0		;GET SUB-FUNCTION: HOST HAS PORTS
	CALL	MSGSPX			;Send message to gateway
	 BR	 10$			;Handle failure
	BIC	#$D1ASB,DDSTS1#(R4)	;Keep a record of doing this
10$:	TBBN	$H1AUX,SDLFS1#(SD),LKFNK2;IF BUILDING AUX-CIRCUIT NOW
	TST	(SP)+			;FIX UP THE STACK
	CMP	DDLFGS#(R4),SD		;IS THIS THE SUPERVISORY SDB?
	BNE	4$			;No-go on
	CLR	DDLFGS#(R4)		;Yes-but not any more!
	BR	RTNCS6			;Thats all in this case

4$:	CALL	CLRPRT			;NO-RESET THE HOST PORT
	MOV	#.MSZAP*400,R0		;GET MESSAGE TYPE
LKFWC0:	CLR	R2			;WORD COUNT = 0
LKFMSG:	MOV	#DDLFOX,R1		;GET POINTER
	ADD	R4,R1
	JMP	LKFST4			;START OUTPUT TO HOST AND RETURN

;HERE FOR DISCONNECT ACK PACKET

LKFDAK:	CALL	GIVPKT#			;GIVE UP THE PACKET
	CALL	CLRPRT			;RESET THE HOST PORT
	CALL	FRESOC#			;FREE UP THE SOCKET
RTNCS6:	SEC				;INDICATE DID NOT START OUTPUT
	RETURN
	.PAGE
;HERE FOR FUNCTION, INTERRUPT, OR EAT PACKET

LKFFUN:	MOVB	PKDATA(R1),R0		;GET FUNCTION
	ASL	R0
	CMP	#FNCMAX,R0		;LEGAL FUNCTION?
	BLOS	FNCIGN			;NO-IGNORE IT
	JMP	@FNCDSP(R0)		;DISPATCH ON THE FUNCTION

;FUNCTION DISPATCH TABLE

FNCDSP:	.WORD	FNCIGN		;.FNMRK =  0 - NULL
	.WORD	FNCOPS		;.FNHRD =  1 - HARD INTERRUPT
	.WORD	FNCCHR		;.FNSFT =  2 - SOFT INTERRUPT
	.WORD	FNCIGN		;.FNOSA =  3 - OUTPUT SUPPRESS ACK
	.WORD	FNCOPS		;.FNOPS =  4 - OUTPUT SUPPRESS
	.WORD	FNCHLD		;.FNOPH =  5 - HOLD OUTPUT
	.WORD	FNCALW		;.FNOPA =  6 - ALLOW OUTPUT
	.WORD	FNCIGN		;.FNCDP =  7 - CHANGE DEVICE PARAMETERS
	.WORD	FNCIGN		;.FNSDP = 10 - SET DEVICE PARAMETERS
	.WORD	FNCIGN		;.FNADP = 11 - ACCESS DEVICE PARAMETERS
	.WORD	FNCRDP		;.FNRDP = 12 - REPLY WITH DEVICE PARAMETERS
	.WORD	FNCSPR		;.FNDCN = 13 - DEVICE CONTROL (SUPERVISORY
				;		 MESSAGES)
	.WORD	FNCIGN		;.FNDST = 14 - DEVICE STATUS
	.WORD	FNCIGN		;.FNADS = 15 - ACCESS DEVICE STATUS
	.WORD	FNCIGN		;.FNCON = 16 - CONTINUE OUTPUT (^Q)
	.WORD	FNCIGN		;.FNFHI = 17 - FORCE HARD INTERRUPT
	.WORD	FNCDEM		;.FNDEM = 20 - DEFERRED ECHO MODE CONTROL
	.WORD	FNCIGN		;.FNRQD = 21 - REQUEST DISCONNECT
	.WORD	FNCIGN		;.FNRQC = 22 - REQUEST BUFFER CLEAR
	.WORD	FNCREQ		;.FNREQ = 23 - REQUEST (YELLOW BALL)
	.WORD	FNCRSP		;.FNRSP = 24 - RESPONSE (ORANGE BALL)
	.WORD	FNCGRN		;.FNGRN = 25 - GREEN BALL
	.WORD	FNCRED		;.FNRED = 26 - RED BALL
	.WORD	FNCLST		;.FNLST = 27 - LOST DATA INDICATION (BLACK BALL)
	.WORD	FNCLSX		;.FNLSX = 30 - REFLECTED LOST DATA INDICATION
				;		 (GRAY BALL)
	.WORD	FNCBRK		;.FNBRK = 31 - BREAK RECEIVED OR REQUEST
	.WORD	FNCIGN		;.FNHNG = 32 - HANGUP REQUEST
	.WORD	FNCIGN		;.FNXHG = 33 - HARD HANGUP REQUEST
	.WORD	FNCIGN		;.FNRCC = 34 - RECONNECT CONTROL
	.WORD	FNCIGN		;.FNXGB = 35 - SPECIAL CHARACTER GOBBLER
	.WORD	FNCIGN		;.FNSRQ = 36 - STATUS REQUEST
	.WORD	FNCCLI		;.FNCLI = 37 - CLEAR LOGIN MODE
FNCMAX=!.-FNCDSP

;HERE FOR DEFERRED ECHO MODE CONTROL FUNCTION

FNCDEM:	TSTB	PKDATA+1(R1)		;TEST VALUE
	TBBN	$H1BKI,SDLFS1#(SD),FNCIGN;IGNORE IT IF DOING BLOCK INPUT
	TSTB	PKDATA+1(R1)		;TEST ARGUMENT
	BEQ	FNCDE2			;IF WANT TO LEAVE DEFFERED ECHO MODE
	PUSH	#.MSEDC*400		;MESSAGE = ENTER DEFFERED ECHO MODE
	BR	MRKCOM			;CONTINUE

;HERE IF WANT TO LEAVE DEFFERED ECHO MODE

FNCDE2:	PUSH	#.MSLDC*400		;MESSAGE = LEAVE DEFFERED ECHO MODE
	BR	MRKCOM			;CONTINUE

;HERE FOR FUNCTION TO BE IGNORED COMPLETELY

FNCIGN:	CALL	GIVPKT#			;GIVE UP THE PACKET
	BR	RTNCS6			;INDICATE DID NOT START OUTPUT

;HERE FOR "RED BALL" FUNCTION

FNCRED:	TBBN	$H1BKI,SDLFS1#(SD),FNCIGN;IGNORE IF DOING BLOCK INPUT
	PUSH	#.MSRED*400		;OTHERWISE GET HOST MESSAGE TYPE
	BR	MRKCOM			;CONTINUE

;HERE FOR "GREEN BALL" FUNCTION

FNCGRN:	TBBN	$H1BKI,SDLFS1#(SD),FNCIGN;IGNORE IT IF DOING BLOCK INPUT
	PUSH	#.MSGRN*400		;GET HOST MESSAGE TYPE
	BR	MRKCOM			;CONTINUE

;HERE FOR RESPONSE FUNCTION

FNCRSP:	TBBN	$H1BKI,SDLFS1#(SD),FNCIGN;IGNORE IT IF BLOCK INPUT
	PUSH	#.MSORG*400		;GET HOST MESSAGE TYPE
	BR	MRKCOM			;CONTINUE

;HERE FOR REQUEST FUNCTION

FNCREQ:	TBBE	$H1BKI,SDLFS1#(SD),4$	;DOING BLOCK INPUT?
	CALL	GIVPKT#			;YES-GIVE UP THE PACKET
	BIS	#$S1HLD,SDSTS1#(SD)	;HOLD OUTPUT TO HOST
	MOV	#.MSINE,R0		;SEND EOF MESSAGE TO HOST
	CJMP	ENDBLK			;AND RETURN (C WILL BE CLEAR)

;HERE FOR RESPONSE FUNCTION IF NOT BLOCK MODE INPUT

4$:	PUSH	#.MSYEL*400		;GET HOST MESSAGE TYPE
	BR	MRKCOM

;HERE FOR "BREAK" FUNCTION

FNCBRK:	PUSH	#.MSBRK*400		;GET HOST MESSAGE TYPE
MRKCOM:	CALL	GIVPKT#			;GIVE UP THE PACKET
	POP	R0			;GET MESSAGE TYPE
	BR	LKFWC0			;CONTINUE

;HERE FOR "BLACK BALL" FUNCTION

FNCLST:	PUSH	#.MSLOS*400+377		;GET MESSAGE TYPE AND ARGUMENT BYTE
	BR	FNCLOS			;CONTINUE

;HERE FOR "GRAY BALL" FUNCTION

FNCLSX:	PUSH	#.MSLOS*400+0		;GET MESSAGE TYPE AND ARGUMENT BYTE
FNCLOS:	CALL	GIVPKT#			;GIVE UP THE PACKET
	POP	R0			;RESTORE
	MOVB	R0,DDLFOX#(R4)		;STORE ARGMENT BYTE
	BIC	#377,R0			;REMOVE JUNK
	JMP	LKFWC1			;CONTINUE

;HERE FOR FUNCTION WHICH HAS SET OUTPUT SUPPRESS AND MUST HAVE AN "OUTPUT
;  SUPPRESS ACK" REPLY

FNCOPS:	MOVB	PKDATA+1(R1),DDLFOX(R4)	;GET CHARACTER
	MOV	(SD),R2			;GET LINKED SDB
	INCB	SDPCNT(R2)		;AND FIX UP THE PACKET COUNT
	CALL	ACKOPS#			;ACK THE OUTPUT SUPPRESS FUNCTION
	BR	FNCCH2			;CONTINUE

;HERE FOR FUNCTION WHICH CONTAINS A CHARACTER

FNCCHR:	MOVB	PKDATA+1(R1),DDLFOX(R4)	;PUT CHARACTER INTO THE MESSAGE
	CALL	GIVPKT#			;GIVE UP THE PACKET
FNCCH2:	MOV	#201*400,R0		;GET MESSAGE TYPE
	JMP	LKFWC1			;CONTINUE

;HERE FOR OUTPUT ALLOW FUNCTION

FNCALW:	BIC	#$H1OPH,SDLFS1#(SD)	;INDICATE OUTPUT OK NOW
	TBBN	$S1STP,SDSTS1#(SD),FNCIGN;IS OUTPUT OK NOW?
	PUSH	#.MSOUP*400		;YES-SAY "BACKPRESSURE OFF"
	BR	MRKCOM

;HERE FOR OUTPUT HOLD FUNCTION

FNCHLD:	BIS	#$H1OPH,SDLFS1#(SD)	;INDICATE SHOULD HOLD OUTPUT
	PUSH	#.MSNOP*400		;GET MESSAGE TYPE
	BR	MRKCOM			;CONTINUE

;HERE FOR SUPERVISORY MESSAGES

FNCSPR:	CMP	DDLFGS#(R4),SD		;IS THIS THE SUPERVISORY SDB?
	BNE	FNCIGN			;NO-IGNORE THIS PACKET
	TSTB	PKDATA+1(R1)		;IS IT A LEGAL SUB-FUNCTION?
	BNE	FNCIGN			;NO-IGNORE IT
	MOV	PKDATA+2(R1),R0		;YES-COPY TIME INTO BUFFER
	SWAB	R0
	MOV	R0,DDLFOX#(R4)
	MOV	PKDATA+4(R1),R0
	SWAB	R0
	MOV	R0,DDLFOX#+2(R4)
	CALL	GIVPKT#			;GIVE UP THE PACKET
	MOV	#.MSCRS*400,R0		;GET MESSAGE TYPE
	TBBN	$D0KMC,(R4),4$		;KMC HOST?
	BIS	#100*400,R0		;NO-INDICATE LONG MESSAGE
4$:	JMP	LKFWC2			;GO SEND IT TO THE HOST

;HERE FOR CLEAR LOGIN MODE FUNCTION

FNCCLI:	TBBE	$H1AUX,SDLFS1#(SD),FNCIGN;IGNORE IT IF NOT BUILDING AUX-CIRCUIT
	CALL	GIVPKT#			;GIVE UP THE PACKET
	JMP	CLRLGI			;GO HANDLE IT
	.PAGE
;HERE FOR REPLY WITH DEVICE PARAMETERS FUNCTION

FNCRDP:	PUSH	R4			;SAVE ADDRESS OF DDB
	ASR	PKCNT(R1)		;CALCULATE NUMBER OF PARAMETERS
	MOV	#DDLFQX#,R2		;GET POINTER TO OUTPUT BUFFER
	ADD	R4,R2
	MOV	R1,R4			;POINT TO DATA IN PACKET
	ADD	#PKDATA+1,R4
FNCRD2:	DECB	PKCNT(R1)		;ANY MORE IN THE PACKET?
	BLT	FNCRD8			;NO-FINISHED
	MOVB	(R4)+,R3		;YES-GET PARAMETER
	MOVB	(R4)+,R0		;AND GET VALUE
	CMP	#MAXTPR,R3		;DO WE KNOW ABOUT THIS ONE?
	BLO	FNCRD2			;NO-GO ON
	ASL	R3			;YES-ADJUST FOR WORD INDEXING
	JMP	@RDPDSP(R3)		;DISPATCH TO ROUTINE

;DISPATCH TABLE FOR NETWORK TERMINAL PARAMETERS

	PURE
	.EVEN

RDPDSP:	.WORD	FNCRD2		;	=  0 - ILLEGAL
	.WORD	FNCRD2		;.TPCIC =  1 - COMMAND INTERRUPT CHARACTER
	.WORD	FNCECH		;.TPECH =  2 - ECHO CONTROL
	.WORD	FNCRD2		;.TPBST =  3 - BREAK SET
	.WORD	FNCRD2		;.TPITD =  4 - IDLE TIMER DELAY
	.WORD	FNCRD2		;.TPTAP =  5 - "PAPER TAPE" MODE
	.WORD	FNCRD2		;.TPSNM =  6 - SUPPRESS NETWORK MESSAGES
	.WORD	FNCRD2		;.TPBRK =  7 - BREAK HANDLING
	.WORD	FNCRD2		;.TPPRF = 10 - TERINAL PROFIL
	.WORD	FNCORT		;.TPRAT = 11 - BAUD RATE
	.WORD	FNCRD2		;.TPWID = 12 - LINE WIDTH
	.WORD	FNCRD2		;.TPLEN = 13 - PAGE LENGTH
	.WORD	FNCOHE		;.TPOHE = 14 - OUTPUT HOLD ENABLE
	.WORD	FNCRD2		;.TPHIC = 15 - HARD INTERRUPT CHARACTER
	.WORD	FNCRD2		;.TPSIC = 16 - SOFT INTERRUPT CHARACTER
	.WORD	FNCRD2		;.TPOSC = 17 - OUTPUT SUPPRESS CHARACTER
	.WORD	FNCRD2		;.TPDEL = 20 - DELETE CHARACTER
	.WORD	FNCRD2		;.TPLDC = 21 - LINE DELETE CHARACTER
	.WORD	FNCRD2		;.TPLRC = 22 - LINE RETYPE CHARACTER
	.WORD	FNCRD2		;.TPSHT = 23 - SIMULATE HORIZONTAL TAB
	.WORD	FNCRD2		;.TPSVT = 24 - SIMULATE VERTICAL TAB
	.WORD	FNCRD2		;.TPSFF = 25 - SIMULATE FORM FEED
	.WORD	FNCMCD		;.TPMCD = 26 - MIN/MAX C.R. DELAY
	.WORD	FNCFCD		;.TPFCD = 27 - FIXED C.R. DELAY
	.WORD	FNCVCD		;.TPVCD = 30 - VARIABLE C.R. DELAY
	.WORD	FNCRD2		;.TPLFD = 31 - LINE FEED DELAY ****
	.WORD	FNCRD2		;.TPHTD = 32 - HORIZONTAL TAB DELAY
	.WORD	FNCRD2		;.TPVTD = 33 - VERTICAL TAB DELAY
	.WORD	FNCRD2		;.TPFFD = 34 - FIXED FORM FEED DELAY
	.WORD	FNCRD2		;.TPVFD = 35 - VARIABLE FORM FEED DELAY
	.WORD	FNCRD2		;.TPBSD = 36 - BACKSPACE DELAY
	.WORD	FNCLFI		;.TPLFI = 37 - LINE FEED INSERSION
	.WORD	FNCCRI		;.TPCRI = 40 - CARRIAGE RETURN INSERSION
	.WORD	FNCRD2		;.TPIMO = 41 - IMAGE MODE OUTPUT
	.WORD	FNCRD2		;.TPIMI = 42 - IMAGE MODE INPUT
	.WORD	FNCRD2		;.TPXLI = 43 - XLATE LOWER CASE INPUT
	.WORD	FNCRD2		;.TPXLO = 44 - XLATE LOWER CASE OUTPUT
	.WORD	FNCRD2		;.TPBDE = 45 - BACKSPACE DELETE ENABLE
	.WORD	FNCRD2		;.TPEDB = 46 - ECHO DELETE CHAR. AS BACKSPACE
	.WORD	FNCRD2		;.TPXBD = 47 - EXTENDED DELETE ECHO
	.WORD	FNCLCP		;.TPLCP = 50 - LOCAL COPY
	.WORD	FNCRD2		;.TPBC1 = 51 - 1ST ADDITIONAL BREAK CHARACTER
	.WORD	FNCRD2		;.TPBC2 = 52 - 2ND ADDITIONAL BREAK CHARACTER
	.WORD	FNCRD2		;.TPOPT = 53 - OUTPUT PENDING TIMER
	.WORD	FNCRD2		;.TPCCE = 54 - CONTROL CHARACTER ECHO
	.WORD	FNCRD2		;.TPESC = 55 - "ESC" CHARACTER ECHO CONTROL
	.WORD	FNCRD2		;.TPCHS = 56 - CONVERT HIGH SPEC. CHAR. TO "ESC"
	.WORD	FNCRD2		;.TPTYP = 57 - TERMINAL TYPE
	.WORD	FNCRD2		;.TPESQ = 60 - ESC SEQUENCE CONTROL
	.WORD	FNCRD2		;.TPFIL = 61 - ENABLE FILLING
	.WORD	FNCRD2		;.TPFCR = 62 - ALLOW FREE CR/LF
	.WORD	FNCRD2		;.TPHNG = 63 - HANG UP MODEM
	.WORD	FNCRD2		;.TPTRN = 64 - TRANSPARENCY MODE
	.WORD	FNCRD2		;.TPADM = 65 - ALTERNATE DEVICE MODE
	.WORD	FNCIRT		;.TPIRT = 66 - INPUT BAUD RATE
	.WORD	FNCORT		;.TPORT = 67 - OUTPUT BAUD RATE
	.WORD	FNCIHE		;.TPIHE = 70 - INPUT HOLD ENABLE
	.WORD	FNCKAT		;.TPKAT = 71 - KATAKANA
	.WORD	FNCPAR		;.TPPAR = 72 - PARITY CONTROL
	.WORD	FNCRD2		;.TPALF = 73 - AUTO LINE FEED
	.WORD	FNCRD2		;.TPVTS = 74 - VERTICAL TAB SPACING
	.WORD	FNCBLT		;.TPBLT = 75 - BELT PRINTER SWITCH
	.WORD	FNCEHT		;.TPEHT = 76 - ECHO HORIZONTAL TAB
	.WORD	FNCRD2		;.TPSRC = 77 - Status request character
	.WORD	FNCEBS		;.TPEBS =100 - Echo backspace
MAXTPR=!<.-RDPDSP>/2-1

;**** THE .TPLFD PARAMETER SHOULD BE SENT TO THE HOST AS "PARAMETER-D", BUT
;	THERE DOES NOT SEEM TO BE ANY WAY TO DO THIS!!!!

	CODE

;HERE FOR ECHO CONTROL PARAMETER (.TPECH)

FNCECH:	CLR	R3			;GET TYMSHARE PARAMETER
	BR	FNCCOM			;CONTINUE

;HERE FOR OUTPUT HOLD ENABLE PARAMETER (.TPOHE)

FNCOHE:	MOV	#16,R3			;GET TYMSHARE PARAMETER
	BR	FNCCOM			;CONTINUE

;HERE FOR ECHO HORIZONTAL TAB PARAMETER (.TPSHT)

FNCEHT:	MOV	#1,R3			;GET TYMSHARE PARAMETER
	BR	FNCCOM			;CONTINUE

;HERE FOR MIN/MAX C.R. DELAY PARAMETER (.TPMCD)

FNCMCD:	MOV	#13,R3			;GET TYMSHARE PARAMETER
	BR	FNCFNF			;CONTINUE

;HERE FOR FIXED C.R. DELAY PARAMETER (.TPFCD)

FNCFCD:	MOV	#12,R3			;GET TYMSHARE PARAMETER
	CMP	#17,R0			;TOO BIG?
	BHIS	FNCCOM			;NO-OK
	MOV	#17,R0			;YES-GET MAXIMUM VALUE
	BR	FNCCOM			;CONTINUE

;HERE FOR VARIABLE C.R. DELAY PARAMETER (.TPVCD)

FNCVCD:	MOV	#11,R3			;GET TYMSHARE PARAMETER
FNCFNF:	CALL	TYNFIV#			;APPLY INVERSE OF "FUNCTION-F"
	BR	FNCCOM			;CONTINUE

;HERE FOR LINE FEED INSERSION PARAMETER (.TPLFI)

FNCLFI:	MOV	#3,R3			;GET TYMSHARE PARAMETER
	BR	LFICRI			;CONTINUE

;HERE FOR CARRIAGE INSERSION PARAMETER (.TPCRI)

FNCCRI:	MOV	#2,R3			;GET TYMSHARE PARAMETER
LFICRI:	TBBN	4,R0,FNCONE		;IS IT SET?
	BR	FNCZER			;NO-RETURN 0

;HERE FOR PARITY CONTROL PARAMETER (.TPPAR)

FNCPAR:	MOV	#7,R3			;GET TYMSHARE PARAMETER
	TBBN	4,R0,FNCONE		;SET TO OUTPUT PARITY?
FNCZER:	CLR	R0			;NO
	BR	FNCCOM

FNCONE:	MOV	#1,R0			;YES
	BR	FNCCOM

;Here for echo backspace parameter (.TPEBS)

FNCEBS:	MOV	#15,R3			;GET TYMSHARE PARAMETER
	BR	FNCCOM			;CONTINUE

;HERE FOR BELT PRINTER CONTROL PARAMETER (.TPBLT)

FNCBLT:	MOV	#4,R3			;GET TYMSHARE PARAMETER
FNCCMX:	COM	R0			;REVERSE THE VALUE
	BIC	#^C1,R0			;JUST ONE BIT
	BR	FNCCOM			;CONTINUE

;HERE FOR LOCAL COPY PARAMETER (.TPLCP)

FNCLCP:	MOV	#10,R3			;GET TYMSHARE PARAMETER
	BR	FNCCOM			;CONTINUE

;HERE FOR INPUT BAUD RATE PARAMETER (.TPIRT)

FNCIRT:	MOV	#5,R3			;GET TYMSHARE PARAMETER
	BR	FNCRAT			;CONTINUE

;HERE FOR OUTPUT BAUD RATE PARAMETER (.TPORT)

FNCORT:	MOV	#6,R3			;GET TYMSHARE PARAMETER
FNCRAT:	CMP	#MAXRNT#,R0		;DOES TYMSHARE KNOW ABOUT THIS RATE?
	BHIS	2$			;YES
	MOV	#MAXRNT#,R0		;NO!
2$:	MOVB	TYNRNT#(R0),R0		;GET TYMSHARE RATE CODE
	BR	FNCCOM			;CONTINUE

;HERE FOR INPUT HOLD ENABLE PARAMETER (.TPIHE)

FNCIHE:	MOV	#14,R3			;GET TYMSHARE PARAMETER
	BR	FNCCOM			;CONTINUE

;HERE FOR KATAKANA PARAMETER (.TPKAT)

FNCKAT:	MOV	#17,R3			;GET TYMSHARE PARAMETER
FNCCOM:	MOVB	#.MSTCR,(R2)+		;STORE MESSAGE TYPE
	MOVB	SDSOC#(SD),(R2)+	;STORE SOCKET NUMBER
	MOVB	R3,(R2)+		;STORE PARAMETER
	MOVB	R0,(R2)+		;STORE VALUE
	BR	FNCRD2			;THATS IT FOR THIS ONE!

;HERE WHEN FINISHED WITH THE PACKET

FNCRD8:	POP	R4			;RESTORE DDB ADDRESS
	SUB	R4,R2			;CALCULATE NUMBER OF WORDS TO XFER
	ASR	R2
	SUB	#DDLFQQ#,R2		;DDLFQQ = DDLFQX/2+1
	PUSH	R2			;SAVE COUNT
	CALL	GIVPKT#			;GIVE UP THE PACKET
	POP	R2			;RESTORE COUNT
	BLE	4$			;IF NOTHING TO SEND TO HOST
	MOVB	DDLFQX#(R4),R0		;GET FIRST DATA BYTE
	SWAB	R0
	CJMP	LKFMSG			;SEND MESSAGE TO HOST AND RETURN

;HERE IF NOTHING TO SEND TO HOST HERE

4$:	SEC				;INDICATE NO OUTPUT
	RETURN
	.PAGE
	.SBTTL	Local subroutines

;SUBROUTINE TO GET PACKET - MAY ONLY BE CALLED WITH NOTHING ON THE STACK
;  WILL NOT RETURN IMMEDIATELY IF NO PACKETS ARE AVAILABLE
;	CALL	MAKPKX
;	C(R1) = ADDRESS OF PACKET

MAKPKX:	MAKPKT	.PLOPT#			;GET A PACKET
	BCC	RTN009			;FINISHED IF GOT ONE
	TST	DDLFXR(R4)		;NONE AVAILABLE-IS THIS THE FIRST TIME?
	BEQ	4$			;YES
	RSTOP	PWE			;[PACKET WAIT ERROR] - THIS SHOULD NOT BE
					;  POSSIBLE!!

4$:	POP	DDLFX1#(R4)		;SAVE RETURN ADDRESS
	MOV	R0,DDLFX2#(R4)		;SAVE REGISTERS
	MOV	R2,DDLFX3#(R4)
	MOV	R3,DDLFX4#(R4)
	MOV	#MAKPX6,DDLFXR#(R4)	;SAVE RECOVERY ADDRESS
	MOV	SD,DDLFXS#(R4)		;SAVE SDB ADDRESS
RTN009:	RETURN				;AND FORGET IT FOR NOW

;HERE WHEN FINALLY GET A PACKET AFTER COULD NOT GET ONE ABOVE

MAKPX6:	MOV	DDLFXS#(R4),SD		;RESTORE SDB ADDRESS
	MOV	DDLFX2#(R4),R0		;RESTORE REGISTERS
	MOV	DDLFX3#(R4),R2
	MOV	DDLFX4#(R4),R3
	JMP	@DDLFX1#(R4)		;RETURN FROM MAKPKX
	.PAGE
;SUBROUTINE TO START BLOCK MODE HOST OUTPUT
;	C(SD) = ADDRESS OF SDB
;	CALL	STRBKO

STRBKO:	CMP	#-1,SDLFBL#(SD)		;ALREADY IN THE LIST?
	BNE	6$			;YES-NOTHING NEEDED HERE!
	CLR	SDLFBL#(SD)		;NO-CLEAR LINK WORD
	MOV	DDLFBT#(R4),R2		;GET TAIL POINTER
	BNE	4$			;IF LIST NOT EMPTY
	MOV	SD,DDLFBH#(R4)		;EMPTY-PUT ON HEAD
	MOV	SD,DDLFBT#(R4)
	MOV	#$RQRBO,R0		;SEND MESSAGE TO HOST
	CJMP	SNDHST

4$:	MOV	SD,SDLFBL#(R2)		;NOT EMPTY-LINK AT END OF LIST
	MOV	SD,DDLFBT#(R4)		;UPDATE TAIL POINTER
6$:	RETURN

;SUBROUTINE TO RESET A HOST PORT
;	CALL	CLRPRT

CLRPRT:	CLR	SDLFS1#(SD)		;CLEAR THE HOST STATUS BITS
	CLRB	SDLFVC#(SD)		;CLEAR BLCK INPUT HOLD BUFFER
	CMP	#-1,SDLFBL#(SD)		;IS THIS PORT IN THE BLOCK OUTPUT LIST?
	BEQ	10$			;NO-FINISHED HERE
	MOV	DDLFBH#(R4),R2		;YES-GET FIRST IN LIST
	CMP	SD,R2			;THIS ONE?
	BNE	2$			;NO
	MOV	SDLFBL#(SD),DDLFBH#(R4)	;YES-REMOVE FROM LIST
	BNE	6$			;IS LIST EMPTY NOW?
;*****CHANGED FOLLOWING SYMBOL FROM "SD" TO "R4"**JOHN GOLTZ*JWR**10-30-80
	CLR	DDLFBT#(R4)		;YES-CLEAR TAIL POINTER
	BR	6$			;CONTINUE

;HERE IF NOT FIRST IN LIST

2$:	MOV	SDLFBL#(R2),R3		;GET NEXT SDB IN LIST
	CMP	SD,R3			;THISONE?
	BEQ	4$			;YES
	MOV	R3,R2			;ADVANCE POINTER
	BNE	2$			;CONTINUE IF MORE THERE
	RSTOP	BBL			;[BAD BLOCK MODE OUTPUT LIST]

;HERE WITH ENTRY BEFORE THIS SDB

4$:	MOV	SDLFBL#(SD),SDLFBL#(R2)	;REMOVE THIS SDB
	BNE	6$			;WAS IT AT THE END?
	MOV	R2,DDLFBT#(R4)		;YES-UPDATE TAIL POINTER
6$:	MOV	#-1,SDLFBL#(SD)		;INDICATE NOT IN LIST NOW
10$:	RETURN				;FINISHED
	.PAGE
;SUBROUTINE TO MARK THIS INTERFACE AS DOWN
;	CALL	LKFDWN

LKFDWN:	SETPSW	DDLFPL#(R4)		;NO INTERRUPTS NOW
	CALL	LKFCLR#			;CLEAR OUR BITS IND THE INTERFACE
	BIC	#$D1ACT!$D1ANS,DDSTS1#(R4);OUTPUT NOT ACTIVE NOW
	CLR	DDLFGS#(R4)		;No-supervisory SDB now
	CLRB	DDLFRQ#(R4)		;CLEAR MAIN PROGRAM REQUESTS
	CLR	DDLFOS#(R4)		;CLEAR THE OUTPUT STATE
	CLRB	DDLFOC#(R4)
	MOV	DDLFOK#(R4),R1		;DO WE HAVE AN OUTPUT PACKET
	BEQ	2$			;NO-GO ON
	CLR	DDLFOK#(R4)		;YES
	MOV	DDLFOZ#(R4),SD		;GET ASSOCIATED SDB
	CALL	GIVPKT#			;GIVE UP THE PACKET
2$:	MOVB	#.ISRST,DDLFIS#(R4)	;INPUT STATE = RESET
	MOV	DDLFIK#(R4),R1		;DO WE HAVE AN INPUT PACKET?
	BEQ	4$			;NO
	CLR	DDLFIK#(R4)		;YES
	FREPKT				;GIVE IT UP
4$:	CLR	DDLFTD#(R4)		;CLEAR THE DATA TIMERS (NOTE: THIS
					;  CLEARS BOTH DDLFTD AND DDLFTP SINCE
					;  DDLFTP = DDLFTD+1!)
	MOV	DDLFAV#(R4),DDLFAL#(R4)	;RESET AMOUNT LEFT BEFORE END OF RING
	CLRPSW				;INTERRUPTS OK NOW
	CALL	LNKDWN#			;MARK AS DOWN AT LINK LEVEL
	MOV	DDLKFH#(R4),SD		;GET FIRST SDB WITH INSERTED MESSAGE
	BEQ	12$			;IF NONE THERE
10$:	CLR	SDLFRQ#(SD)		;CLEAR REQUEST BITS
	MOV	SDLKFL#(SD),R0		;GET NEXT IN LIST
	MOV	#-1,SDLKFL#(SD)		;INDICATE THIS ONE NOT IN LIST
	MOV	R0,SD			;ADVANCE POINTER
	BNE	10$			;CONTINUE IF MORE
12$:	CLR	DDLKFH#(R4)		;FINISHED-CLEAR HEAD AND TAIL POINTERS
	CLR	DDLKFT#(R4)
RTN012:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LKFSEC	- Once-a-second routines

;SUBROUTINE CALLED ONCE-A-SECOND AT MAIN PROGRAM LEVEL
;	CALL	LKFSEC
;  NOTE:  THE MESSAGE TIMER IS NOT USED IN THIS VERSION OF LNKF - IT WILL
;    BE USED WITH THE KMC-11

	ONCSEC	LKFSEC

LKFSEC:	MOV	#LKFDDB#,R4		;GET FIRST TYPE F DDB
LKFSE0:	TBBN	$D1UNV!$D1DIS!$D1OFF,DDSTS1#(R4),LKFSE6;SHOULD WE USE THIS INTERFACE?
	MOV	DDLFXR#(R4),R0		;YES-ARE WE WAITING FOR A PACKET?
	BEQ	LKFSE2			;NO-GO ON
	MAKPKT	.PLSTP#			;YES-TRY TO GET ONE NOW
	BCS	LKFSE2			;GO ON IF NONE AVAILABLE NOW
	CLR	DDLFXR#(R4)		;GOT ONE
	PUSH	R4			;SAVE R4 BECAUSE RECOVERY ROUTINE WILL
					;PROBABLY RETURN TO LFMAIN WHICH LOOPS UNTIL R4 = 0
	CALL	(R0)			;CALL THE RECOVERY ROUTINE
	POP	R4			;RESTORE DDB BASE
LKFSE2:	TSTB	DDLFTD#(R4)		;IS THE DATA TIMER ACTIVE?
	BEQ	LKFSE4			;NO-GO ON
	DECB	DDLFTD#(R4)		;YES-HAS IT RUN OUT?
	BGT	LKFSE4			;NO
	TBBN	$NSNOT,NODSTS#,LKFSE6	;YES-SHOULD WE TIME IT OUT?
	CALL	LKFDWN			;YES-WE ARE DOWN!
	BR	LKFSE6

LKFSE4:	DECB	DDLFTP#(R4)		;TIME TO POKE HIM?
	BGT	LKFSE6			;NO-CONTINUE
	MOVB	#10.,DDLFTP#(R4)	;YES-RESET TIMER
	CALL	SNDPOK			;SEND POKE MESSAGE IF NOT ACTIVE
LKFSE6:	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE F LINK DDB
	BNE	LKFSE0			;CONTINUE IF ANOTHER ONE
RTN014:	RETURN				;OTHERWISE FINISHED
	.PAGE
;SUBROUTINE TO SEND POKE MESSAGE TO HOST (MESSAGE TYPE = 1)
;	CALL	SNDPOK

SNDPOK:	TBBN	$D1ACT!$D1DIS,DDSTS1#(R4),RTN014;DON'T NEED THIS IF ACTIVE NOW
						;  OR IF DISABLED
	MOV	#.MSANS*400,R0		;NOT ACTIVE-GET MESSAGE
	TBBE	$D1DWN,DDSTS1(R4),4$	;GO ON IF NOT DOWN
	CALL	LKFENB#			;TRY TO ENABLE THE INTERFACE
	 BR	 RTN014			;COULDN'T DO IT - WAIT ANOTHER 10 SECS
	TBBE	$D0KMC,(R4),RTN014	;DOWN-FORGET IT IF NOT USNG KMC
	MOV	#.MSACT*400,R0		;DOWN AND USING KMC-GET RIGHT MESSAGE
4$:	CLRB	DDLFOC#(R4)		;WORD COUNT
	CLR	SD			;NO SDB
	CLR	DDLFOS#(R4)		;OUTPUT STATE
	TBBN	$D0KMC,(R4),10$		;GO ON IF KMC
	INCB	DDLFOC#(R4)		;NOT KMC-FIX UP THE WORD COUNT
	MOV	SP,DDLFOP#(R4)		;MAKE SURE POINTER IS REASONABLE
	DEC	DDLFAL#(R4)		;REDUCE AMOUNT LEFT TO END OF RING
	BGT	10$			;IF MORE
	MOV	DDLFAV#(R4),DDLFAL#(R4)	;AT END-RESET COUNT
10$:	CJMP	LKFST9			;START OUTPUT AND RETURN
	.PAGE
	.SBTTL	Data

	PURE

;GENERATE MESSAGE LENGTH TABLE
;  EACH ENTRY IS ONE BYTE INDEXED BY MESSAGE NUMBER WHICH GIVES NUMBER OF
;  PDP11 WORDS WHICH FOLLOW AFTER THE MESSAGE NUMBER

	.MACRO	XX  N,LBL,TYP
	.BYTE	N/2
	.ENDM

MSGLEN::MTBL
MAXMSG==!.-MSGLEN-1
	.EVEN

;GENERATE DISPATCH TABLE FOR HOST-TO-NODE MESSAGES
;  EACH ENTRY IS ONE WORD INDEXED BY MESSAGE NUMBER TIMES 2 WHICH CONTAINS
;  ADDRESS OF ROUTINE TO PROCESS MESSAGE

	.MACRO	XX  N,LBL,TYP
	.WORD	LBL
	.ENDM

MSGDSP:	MTBL
	.EVEN
	.PAGE
	IMPURE

.IF NE ..BUG
;THE DEBUG RING!

DBRNGP::.WORD	0		;RING POINTER
	.WORD	-1		;EASY TO SEE "BEGINNING OR RING" FLAG
LKFRNG::
DBRING::.BLKW	1000.		;THE RING
DBRNGE::.WORD	-1		;EASY TO SEE "END OF RING" FLAG
.ENDC


	.EVEN

	.END
 @|ve