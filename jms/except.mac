	search	rtsym
	$module	nmask
	$excpt		;define it all
	entry	nmask.
	intern	mask.
	intern	unmsk.

nmask.:			;merely make MASK and UNMASK no-ops.
mask.:
unmsk.:
	aos	0(top)	;bump return address
	popj	top,	;and return
	prgend
	search	rtsym
	$module mask
	$excpt		;define it all
	entry	mask.
	entry	unmsk.
	$temp	psasave,1

mask.:
	movem	psa,psasave
	$getpsa	exception
	aos	r1,0(top)	;bump return address
	movei	r1,@-1(r1)	;get std cell addr
	hrrz	r1,0(r1)	;may be multiply indirected
	cail	r1,$stdmax
	jrst	.-2
	addi	r1,cells	;now actual cell address
	move	r0,0(r1)	;get contents of cell
	trnn	r0,400000	;if not maskable then
	jrst	return		;just ignore the call
	hlrz	r0,0(r1)	;get the masking count
	addi	r0,1		;up it by one
	tlne	r0,777777	;make sure it didn't overflow 18 bits
	jrst	maskerror	;report it if so
return:
	hrlm	r0,0(r1)	;update masking count
ret2:
	move	psa,psasave
	popj	top,
maskerror:
	pushj	top,twait.##
	outstr	[asciz /
?	Too many nested MASK calls/]
	jrst	error

unmsk.:
	movem	psa,psasave
	$getpsa	exception
	aos	r1,0(top)	;bump return address
	movei	r1,@-1(r1)	;get condition cell addr
	hrrz	r1,0(r1)	;may be multiply indirected
	cail	r1,$stdmax
	jrst	.-2
	addi	r1,cells	;addr of actual cell
	hlrz	r0,0(r1)	;get masking count
	sojg	r0,return	;ok if still masked
	jumpl	r0,unmskerror	;stop if extra unmask
	hrlm	r0,0(r1)	;keep count current
	movei	r0,200000
	tdnn	r0,0(r1)	;if not pending then
	jrst	ret2		;  return
	andcam	r0,0(r1)	;else clear pending bit
	move	r0,0(top)	;and signal it now
	ldb	r1,[point 16,0(r1),35];get last subcondition code
	$rtsignal

unmskerror:
	pushj	top,twait.
	outstr	[asciz /
?	Unmatched UNMASK/]
error:
	move	r0,0(top)
	pushj	top,wrtpc.##
	jrst	die.##
	$xend	mask
	prgend
	search	rtsym
	$module	masked
	$excpt		;define it all
	entry	tsmsk.
	$temp	psasave,1

tsmsk.:
	movem	psa,psasave
	$getpsa	exception
	aos	r1,0(top)
	ldb	r0,rt.reg##
	movei	r1,@-1(r1)	;get condition cell address
	hrrz	r1,0(r1)	;may be multiply indirected
	cail	r1,$stdmax
	jrst	.-2
	addi	r1,cells	;now actual cell address
	hlrz	r1,0(r1)	;get masking count
	jumpe	r1,.+2		;if zero, it's not masked
	movei	r1,$true	;else return true
	movem	r1,@r0		;in result reg
	move	psa,psasave
	popj	top,

	$xend	masked
	prgend
	search	rtsym
	$module	pending
	$excpt		;define it all
	$temp	target,1
	entry	pend.
	$temp	psasave,1

pend.:
	movem	psa,psasave
	$getpsa	exception
	aos	r1,0(top)	;bump return addr
	ldb	r0,rt.reg##
	movem	r0,target	;save register # for result
	movei	r1,@-1(r1)	;addr of std condition cell
	hrrz	r1,0(r1)	;may be multiply indirected
	cail	r1,$stdmax
	jrst	.-2
	addi	r1,cells
	ldb	r0,[point 1,0(r1),19] ;get pending bit
	movem	r0,@target	;return it
	movei	r0,200000
	andcam	r0,0(r1)	;clear pending bit
	move	psa,psasave
	popj	top,		;all done
	$xend	pending
	prgend
	search	rtsym
	$module	stmth - MATHSTATUS function
	entry	st.mth

st.mth:
	movei	r0,$exmth
	jrst	ex.sta##
	prgend
	search	rtsym
	$module	stusr - USERSTATUS function
	entry	st.usr

st.usr:
	movei	r0,$exusr
	jrst	ex.sta##
	prgend
	search	rtsym
	$module	stspc - SPECIALSTATUS function
	entry	st.spc

st.spc:
	movei	r0,$exspc
	jrst	ex.sta##
	prgend
	search	rtsym
	$module	stio - EXIOSTATUS function
	entry	st.io

st.io:
	movei	r0,$exio
	jrst	ex.sta##
	prgend
	search	rtsym
	$module	exsta - exception status
	$excpt
	entry	ex.sta
	extern	ex.set
	extern	ex.act

	$temp	rtemp,3		;first used in pushj

;
; EX.STA returns the subcondition code for the most "recently"
; activated handler, yielding a runtime error if there is none
; or if it is not in the same "class" requested by ST.MTH, ST.USR,
; ST.SPC or ST.IO.
;

ex.sta:
	push	top,r0		;save std cell addr
	pushj	top,ex.act	;get the active handler
	jrst	wrong		;error if none
	ldb	r2,[point 26,r1,25];get cond cell addr
	came	r2,0(top)	;must be that expected
	jrst	wrong
	andi	r1,777		;isolate the subcondition code
	dmove	r2,1+rtemp	;restore used regs
	pop	top,r0		;clear stack temp
	popj	top,
wrong:
	pop	top,r0		;clear stack temp
	pushj	top,twait.##
	outstr	[asciz /
?	Invalid STATUS call/]
	pushj	top,wrtpc.##
	jrst	die.##
	prgend
	search	rtsym
	$module	allconditions
	$excpt		;define it all
	entry	ex.all

;
; This module is loaded by an ALLCONDITIONS handler and in turn
; forces all the exception handlers to be activated.
;

	extern	ex.mth
	extern	ex.io
	extern	ex.usr
	extern	ex.atn
	extern	ex.sto
	extern	ex.stk
	extern	ex.spc

ex.all==0
	prgend
	search	rtsym
	$module	exsk - Stack overflow interception
	$excpt		;define it all
	entry	ex.stk
	intern	stk.ac
	extern	stk.tv

ex.stk==rx.stk##

stkinit:
	ife	$sys-$tym,<
	move	r1,[portal stk.tv]
	movem	r1,1+stkovf	;link to handler
	move	r1,[jsa	pda,0]	;trap instruction
	hrri	r1,stkovf	;addr for saved register
	settr2	r1,		;tell monitor about it>

	ife	$sys-$adp,<
	movei	r1,stk.tv
	movem	r1,$newpc+$icbstk+vector
	move	r1,[xwd 104000,sis.stk]
	pisys.	r1,>

	halt	.		;should not happen
	popj	top,

stk.ac:
	$pspda	;get pda and psa regs

	ife	$sys-$tym,<
	move	r0,stkovf	;get original PDA
	exch	r0,pda+regs	;save it + get addr of fault
	jsp	r1,.+1		;get PC flags
	hll	r0,r1>

	ife	$sys-$adp,<
	movei	r0,stk.cn	;addr to continue after dismissal
	exch	r0,$oldpc+$icbstk+vector
	hllzs	$xflags+$icbstk+vector
	debrk.
	halt	.
	halt	.
stk.cn:	>

	$errload (r1,$exstk,$none)
	$signal

	ife	$sys-$adp,<
sis.stk:
	exp	-11	;trap stack overflow
	xwd	$icbstk,0
	z	>

	$xend	exsk,stkinit
	prgend
	search	rtsym
	$module	exso - storage overflow handler
	$excpt		;define it all
	entry	ex.sto

ex.sto==rx.sto##


	$xend	exso
	prgend
	search	rtsym
	$module exnmth - overflow handler with underflow suppression
	$excpt		;define it all
	entry	nuflo.
	intern	ex.mth
	intern	mth.ac
	extern	mth.tv

ex.mth==rx.mth##

nuflo.:
mthinit:

	ife	$sys-$tym,<
	move	r1,[portal mth.tv]
	movem	r1,1+arovf
	move	r1,[jsa pda,0]
	hrri	r1,arovf
	settr1	r1,		;tell monitor to trap them>

	ife	$sys-$adp,<
	movei	r1,mth.tv
	movem	r1,$newpc+$icbmth+vector
	move	r1,[xwd 104000,sis.mth]
	pisys.	r1,>

	halt	.		;should not happen
	popj	top,

mth.ac:		;trapped on overflow or underflow
	$pspda

	ife	$sys-$tym,<
	move	r0,arovf	;get original PDA reg
	exch	r0,pda+regs
	subi	r0,1		;since the PC is 2 past the instruction>

	ife	$sys-$adp,<
	move	r0,$oldpc+$icbmth+vector>

	skipn	$inrt(pda)	;if in the runtime, ignore it
	skipe	$debin(pda)	;also ignore if in debugger
	jrst	ignore
	jrst	inusercode
ignore:

	ife	$sys-$tym,<
	tlz	r0,27637	;clear all but overflow bits
	movem	r0,.jbcst	;temp>

	dmove	r0,regs
	dmove	psa,psa+regs	;restore all regs

	ife	$sys-$tym,<
	jrstf	@.jbcst		;continue>

	ife	$sys-$adp,<
	debrk.
	halt	.
	halt	.>

inusercode:

	ife	$sys-$tym,<
	jsp	r1,.+1		;get the PC flags
	hll	r0,r1		;copy the PC flags
	hrri	r1,flagsok
	tlz	r1,440140	;want to clear all the error flags
	jrstf	@r1
flagsok:>

	tlnn	r0,100		;was it underflow?
	jrst	notunder	;no
	dmovem	r2,r2+regs	;get some working space
	move	r1,r0
	movem	r0,.jbcst##	;save continue address
	move	r0,-1(r1)	;get offending instruction
	ldb	r1,[point 4,r0,12];register for result
	lsh	r0,-^d27	;isolate the opcode
	movei	r2,regs		;must clear some in saved location
	add	r2,r1		;  and some in registers themselves
	jsp	r3,clear	;clear first reg
	cail	r0,110		;if < DFAD
	caile	r0,113		;or > DFDV
	jrst	fndone		;then it's not double precision
	addi	r2,1		;else clear next reg, too
	jsp	r3,clear
fndone:	$restore regs, r0, r3
	dmove	psa,psa+regs

	ife	$sys-$tym,<
	jrst	@.jbcst		;and continue user program>

	ife	$sys-$adp,<
	debrk.
	halt	.
	halt	.>

clear:
	caile	r1,r3		;if reg is <= r3,
	cail	r1,psa		;  is psa, or
	caile	r1,pda		;  is pda,
	jrst	clear2
	setzm	0(r2)		;then clear saved reg
	aoja	r1,0(r3)	;  and continue
clear2:	setzm	0(r1)		;else clear actual register
	aoja	r1,0(r3)	;  and continue

notunder:

	ife	$sys-$adp,<
	movei	r1,mth.cn
	movem	r1,$oldpc+$icbmth+vector
	debrk.
	halt	.
	halt	.
mth.cn:	>

	tlnn	r0,40		;check no divide flag
	jrst	notdzero
	$errload (r1,$exmth,$mthdz,$true)
	$signal
notdzero:
	tlnn	r0,40000	;check floating overflow flag
	jrst	mbarov		;off, must be arith overflow
	$errload (r1,$exmth,$mthfo,$true)
	$signal
mbarov:
	$errload (r1,$exmth,$mthao,$true)
	$signal

	ife	$sys-$adp,<
sis.mth:
	exp	-10	;trap arith exceptions
	xwd	$icbmth,0
	z	>

	$xend	exmth,mthinit
	prgend
	search	rtsym
	$module	exmth - underflow/overflow handler
	$excpt		;define it all
	entry	ex.mth
	intern	mth.ac
	extern	mth.tv

ex.mth==rx.mth##

mthinit:

	ife	$sys-$tym,<
	move	r1,[portal mth.tv]
	movem	r1,1+arovf
	move	r1,[jsa pda,0]
	hrri	r1,arovf
	settr1	r1,		;tell monitor to trap them>

	ife	$sys-$adp,<
	movei	r1,mth.tv
	movem	r1,$newpc+$icbmth+vector
	move	r1,[xwd 104000,sis.mth]
	pisys.	r1,>

	halt	.		;should not happen
	popj	top,

mth.ac:		;trapped on overflow or underflow
	$pspda

	ife	$sys-$tym,<
	move	r0,arovf	;get original PDA reg
	exch	r0,pda+regs
	subi	r0,1		;since the PC is 2 past the instruction>

	ife	$sys-$adp,<
	move	r0,$oldpc+$icbmth+vector>

	skipn	$inrt(pda)	;if in the runtime, ignore it
	skipe	$debin(pda)	;also ignore if in debugger
	jrst	ignore
	jrst	inusercode
ignore:

	ife	$sys-$tym,<
	tlz	r0,27637	;clear all but overflow bits
	movem	r0,.jbcst	;temp>

	dmove	r0,regs
	dmove	psa,psa+regs	;restore all regs

	ife	$sys-$tym,<
	jrstf	@.jbcst		;continue>

	ife	$sys-$adp,<
	debrk.
	halt	.
	halt	.>

inusercode:

	ife	$sys-$tym,<
	jsp	r1,.+1		;get the PC flags
	hll	r0,r1		;copy the PC flags
	hrri	r1,flagsok
	tlz	r1,440140	;want to clear all the error flags
	jrstf	@r1
flagsok:>

	ife	$sys-$adp,<
	movei	r1,mth.cn
	movem	r1,$oldpc+$icbmth+vector
	debrk.
	halt	.
	halt	.
mth.cn:	>

	tlnn	r0,100		;was it underflow?
	jrst	notunder	;no
	$errload (r1,$exmth,$mthfn,$true)
	$signal
notunder:
	tlnn	r0,40		;check no divide flag
	jrst	notdzero
	$errload (r1,$exmth,$mthdz,$true)
	$signal
notdzero:
	tlnn	r0,40000	;check floating overflow flag
	jrst	mbarov		;off, must be arith overflow
	$errload (r1,$exmth,$mthfo,$true)
	$signal
mbarov:
	$errload (r1,$exmth,$mthao,$true)
	$signal

	ife	$sys-$adp,<
sis.mth:
	exp	-10
	xwd	$icbmth,0
	z>

	$xend	exmth,mthinit
	prgend
	search	rtsym
	search	iosym
	$module	exio - io error interception
	$excpt		;define it all
	entry	ex.io
	entry	ioerr.
	$ps.op	(extern,M,$exio,interr)
	$ps.op	(extern,M,$exio,rewerr)
	$ps.op	(extern,M,$exio,eoferr)
	$ps.op	(extern,M,$exio,outerr)
	$ps.op	(extern,M,$exio,inpopn)
	$ps.op	(extern,M,$exio,ranerr)
	$ps.op	(extern,M,$exio,illcur)
	$ps.op	(extern,M,$exio,emperr)
	$ps.op	(extern,M,$exio,opnerr)

ex.io==rx.io##

ioerr.:
	tro	r1,$exio*2000	;insert cond cell addr
	$RTSIGNAL

	$xend	exio
	prgend
	search	rtsym
	$module	exusr - User exception trap
	$excpt		;define it all
	entry	ex.usr
	entry	userr.

ex.usr==rx.usr##

;
; USERR. reached with address of the exception in r1 and
; the exception block in r0 (since compiler generated
; code does a JSP R1,routine).  Merely reverse the regs before
; going to the exception manager.
;

userr.:	exch	r0,r1
	$rtsignal

	$xend	exusr
	prgend
	search	rtsym
	$module	exspc - special error interception
	$excpt		;define it all
	entry	ex.spc
	intern	spc.ac
	extern	spc.tv

ex.spc==rx.spc##

spcinit:

	ife	$sys-$tym,<
	hrlzi	r1,500000	;1b0+1b2
	intenb	r1,		;activate channel 2
	halt	.
	movei	r1,spc.tv	;addr for ill mem ref trap
	movem	r1,3+vector
	move	r1,[2,,2]	;cause = 2, channel 2
	intass	r1,		;ill mem ref>

	ife	$sys-$adp,<
	movei	r1,spc.tv
	movem	r1,$newpc+$icbim+vector
	move	r1,[xwd 104000,sis.im]
	pisys.	r1,>

	halt	.		;should not happen
	popj	top,

spc.ac:
	$pspda
	movei	r0,im.cn	;addr to continue after dismissal

	ife	$sys-$tym,<
	exch	r0,2+vector	;get PC of trap
	dismis>			;dismis the interrupt

	ife	$sys-$adp,<
	exch	r0,$oldpc+$icbim+vector
	debrk.
	halt	.
	halt	.>

im.cn:
	$errload (r1,$exspc,$spcmr)
	$signal

	ife	$sys-$adp,<
sis.im:
	exp	-6
	xwd	$icbim,0
	z>

	$xend	exspc,spcinit
	prgend
	search	rtsym
	$module	exatn - attention trap
	$excpt		;define it all
	entry	ex.atn
	intern	escap.
	intern	atn.ac
	extern	atn.tv

ex.atn==rx.atn##

atninit:
	movei	r1,atn.tv

	ife	$sys-$tym,<
	movem	r1,1+vector
	hrloi	r1,1		;break on channel 1, current port
	tinass	r1,
	halt	.
	hrlzi	r1,600000	;1b0+1b1
	intenb	r1,		;enable channel 1>

	ife	$sys-$adp,<
	movem	r1,$newpc+$icbatn+vector
	move	r1,[xwd 104000,sis.atn]
	pisys.	r1,>

	halt	.
	movei	r1,400000	;set "can be masked" flag
	movem	r1,$exatn+cells
	popj	top,

;
; There are three entries into this module:
;
; ESCAP. is reached whenever the runtime unmasks attentions
; 	 to check for postponed interrupts.
; ATN.AC actually fields interrupts from the monitor.
; IGNOR. fields interrupts from the monitor during critical
;	 sections of code (both in this module and in the
;	 exception manager), ignoring the interrupt with an
;	 immediate DISMIS.
;
; Both ESCAP. and ATN.AC must handle three distinct cases:
;
; (1) Debugger active.  Exit to the monitor and, if the user
;     continues, restore everything and continue execution.
; (2) An attention handler is currently active.  Restore state
;     and continue, ignoring the interrupt.
; (3) Neither of the above apply.  Signal the attention to the
;     exception manager.
;
; In addition, ATN.AC must check if the runtime has masked
; interrupts and, if so, record the occurance of the interrupt
; for detection in ESCAP. at an appropriate UNMASK.
;
; Given the different manner in which ESCAP. and ATN.AC are
; reached they are coded separately, sharing only a SEARCH
; routine which checks for an active attention handler.
;

ignor.:				;ignores all interrupts

	ife	$sys-$tym,<
	dismis
	halt	.>		;better not happen

	ife	$sys-$adp,<
	debrk.
	halt	.
	halt	.>

escap.:				;check for postponed interrupts
	skipg	@$exception(pda);actually .intmask(pda)
	popj	top,		;none pending
	skipn	$debin(pda)	;if the debugger was running
	jrst	escap1
	exit	1,		;  then go to the monitor prompt
	setzm	@$exception(pda);clear the pending flag
	popj	top,		;and continue
escap1:				;debugger not active
	setzm	@$exception(pda);clear pending interrupt
	movem	psa,$misc(pda)	;save runtime psa reg
;
; Begin critical section.
;
	$getpsa	exception
	dmovem	r2,r2+regs
	movei	r2,ignor.	;subsequent interrupts ignored

	ife	$sys-$tym,<
	movem	r2,1+vector>

	ife	$sys-$adp,<
	movem	r2,$newpc+$icbatn+vector>

;
; End critical section.
;
	dmovem	r4,r4+regs	;save work regs
	jsp	r5,search	;look for active attn handler
	jrst	esctrp		;none - signal it
	dmove	r4,r4+regs	;found one. ignore this one
	movei	r2,atn.tv	;restore correct handler
	ife	$sys-$tym,<
	movem	r2,1+vector>

	ife	$sys-$adp,<
	movem	r2,$newpc+$icbatn+vector>

;
; Begin critical section.
;
	dmove	r2,r2+regs
	move	psa,$misc(pda)	;restore caller's regs
;
; End critical section.
;
	popj	top,

esctrp:				;signal delayed attention
	dmovem	r0,r0+regs	;set up regs as expected
	dmove	r2,r2+regs	;by exception manager
	dmove	r4,r4+regs
	move	r0,$misc(pda)	;caller's psa
	movem	r0,psa+regs
	movem	pda,pda+regs
	pop	top,r0		;caller's return addr
	$errload (r1,$exatn,$none,$true)
	$signal

atn.ac:				;monitor signalled interrupt
	movem	pda,.jbcst##	;don't use $pspda macro since we
;
; Begin critical section.
;
	$getpda			;will go to the dot if in the debugger
	skipn	$maski(pda)	;if masked by runtime
	jrst	atn1
	aos	@$exception(pda);  then flag the interrupt seen
	move	pda,.jbcst	;restore state and

	ife	$sys-$tym,<
	dismis			;conintue
	halt	.>		;just in case

	ife	$sys-$adp,<
	debrk.
	halt	.
	halt	.>

atn1:
	skipn	$debin(pda)	;if debugger interrupted
	jrst	atn2
	move	pda,.jbcst	;then restore state and
	exit 	1,		;go to the monitor prompt

	ife	$sys-$tym,<
	dismis			;continue program
	halt	.>		;should not happen

	ife	$sys-$adp,<
	debrk.
	halt	.
	halt	.>

atn2:
	movem	psa,$misc(pda)	;save psa reg in temp
	$getpsa	exception
	dmovem	r2,r2+regs	;free up work regs
	movei	r2,atn3		;to continue on dismissal
	movei	r3,ignor.

	ife	$sys-$tym,<
	exch	r2,vector	;get interrupted address
	movem	r3,1+vector	;subsequent interrupts ignored>

	ife	$sys-$adp,<
	exch	r2,$oldpc+$icbatn+vector
	movem	r3,$newpc+$icbatn+vector>

;
; End critical section.
;

	ife	$sys-$tym,<
	dismis>

	ife	$sys-$adp,<
	debrk.
	halt	.
	halt	.>

atn3:
	movem	r2,iaddr	;save interrupted address
	move	r2,$misc(pda)	;original psa
	move	r3,.jbcst	;and pda
	dmovem	r2,psa+regs	;now saved
	dmovem	r4,r4+regs
	jsp	r5,search	;check for active attention handler
	jrst	atntrp		;none - signal it
	dmove	r2,r2+regs	;found one - ignore it
	dmove	r4,r4+regs
	move	pda,iaddr	;get interrupted address
	movem	pda,.jbcst	;save in temp
	movei	pda,atn.tv	;restore correct handler
	ife	$sys-$tym,<
	movem	pda,1+vector>

	ife	$sys-$adp,<
	movem	pda,$newpc+$icbatn+vector>

;
; Begin critical section.
;
	dmove	psa,psa+regs	;restore last two regs
	jrst	@.jbcst		;and continue
;
; End critical section.
;

atntrp:				;signal an attention interrupt
	dmovem	r0,r0+regs
	dmove	r2,r2+regs
	dmove	r4,r4+regs
	move	r0,iaddr
	$errload (r1,$exatn,$none,$true)
	$signal

;
; SEARCH called via JSP R5, returns:
;	+0 if no active attention handler found
;	+1 otherwise
;

	base==r2	;base of current stack frame
	hbt==r3		;addr of current hbt
	hsb==r4		;addr of current hsb

search:
	move	base,$base(pda)	;basis for current routine
newframe:
	hlrz	hbt,$chbt(base)	;addr of current hbt
	jumpe	hbt,nextsf	;if none, try previous stack frame
newhbt:
	move	hsb,$hsboffset(hbt)
	addi	hsb,0(base)	;addr of matching hsb
	hlrz	hsb,$hsbflag(hsb);addr of exception block
	jumpe	hsb,nxthbt	;try outer hbt if not active
	cain	hsb,$exatn	;if for attentions then
	jrst	1(r5)		;  do skip return to ignore
nxthbt:
	hrrz	hbt,$hbtlink(hheck outer hbt
	jumpn	hbt,newhbt
nextsf:
	move	base,1(base)	;back up one stack frame
	jumpn	base,newframe	;and check if not back to main
	jrst	0(r5)		;else report no active handler

	ife	$sys-$adp,<
sis.atn:
	exp	-3
	xwd	$icbatn,0
	z	>

	$xend	exatn,atninit
	prgend
	search	rtsym
	$module	escap
	entry	escap.

;
; Default escape check after runtime $UNMASKS.  Merely returns
; to the runtime.
;

escap.:	popj	top,
	prgend
	search	rtsym
	$module	signal
	$excpt		;define it all
	entry	signl.
	extern	m.user

signl.:
	aos	r1,0(top)	;bump return address
	$getpsa	exception
	movei	r1,@-1(r1)	;get condition cell addr
	lsh	r1,^d10		;form exception block
	move	r0,0(top)
	$rtsignal

	$xend	signal
	prgend
	search	rtsym
	$module	rsignal
	$excpt		;define it all
	entry	rsgnl.
	extern	m.user
	extern	ex.act
	$temp	rtemp,3		;first word used in pushj to ex.act

rsgnl.:
	pushj	top,ex.act	;get active hbt + its hsb
	halt	.		;should not happen
	hrrz	r2,$hbtlink(r2)	;back up one hbt
	hrlm	r2,$chbt(basis)
	psa==r2			;change base reg temporarily
	$getpsa	exception
	setom	cancontinue	;stay at dot if no handler found
	psa==pda-1
	dmove	r2,1+rtemp
	$rtsignal		;and do it

	$xend	rsignal
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthfn,Floating underflow)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthfo,Floating overflow)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthao,Arithmetic overflow)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthdz,Division by zero)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthas,Bad argument to ARCSIN)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthac,Bad argument to ARCCOS)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,interr,IO_INTR Internal error in I-O system)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,rewerr,IO_REWR Rewrite required)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,eoferr,IO_EOF Read beyond EOF)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,outerr,IO_OUTF Output failure)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,inpopn,IO_INPF Input failure)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,ranerr,IO_SEEK Non-random file)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,illcur,IO_ILLC Non-positive cursor value)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,emperr,IO_NEMP Can't EMPTY file)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,opnerr,IO_OPNF File var not assoc'd)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usras,Assertion failure)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrcx,Case index out of bounds)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrag,Aggregate assignment incompatibility)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrnl,NIL or uninitialized file variable)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrpt,NIL or uninitialized pointer)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrss,Substring index or length out of bounds)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrsr,Subscript out of bounds)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrsc,Scalar out of range)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrfl,Reference to a field not selected by current tag field value)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exsto,$none,Heap overflow)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exstk,$none,Stack overflow)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcmr,Illegal memory reference)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spciu,Illegal instruction)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcnn,Negative block size in NEW)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcbp,Bad pointer in DISPOSE)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcff,Attempt to free freed block)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcrh,Invalid heap pointer in RELEASE)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exatn,$none,Attention)
	prgend
	search	rtsym
	$module	m.user
	entry	m.user
m.user:	asciz	/User-signalled condition/
	prgend
	search	rtsym
	$module	exinit
	$excpt		;define it all
	entry	ex.set		;establish handler clause
	entry	ex.rst		;re-establish handler clause

;
; EXINIT allocates the exception handlers' PSA and initializes
; the system.


;
; EX.RST is called by the compiler generated code to update
; the current handler branch table address in the local stack frame.
;

ex.rst:
	aos	r1,0(top)	;bump return address
	movei	r1,@-1(r1)	;get addr of HBT
	hrlm	r1,$chbt(basis)	;update current hbt address
	popj	top,

ex.set:				;push a new HBT
	aos	r1,0(top)	;bump return address
	movei	r1,@-1(r1)	;get addr of HBT
	hrlm	r1,$chbt(basis)	;put addr in stack frame cell
	move	r1,$hsboffset(r1);get HSB offset in stack frame
	addi	r1,0(basis)
	setzm	$hsbflag(r1)	;flag inactive
	popj	top,

exini:	movei	r1,vector	;addr of trap vector

	ife	$sys-$tym,<
	hrli	r1,2		;enable it
	intadr	r1,>

	ife	$sys-$adp,<
	piini.	r1,>

	halt	.		;what?
	movei	r1,$mxch
	movem	r1,exloc	;max len of flex string
	popj	top,

	$end	exinit,exini
	prgend
	search	rtsym
	search	iosym
	$module	excpt - exception manager
	$excpt		;define it all

	$allconditions==-2
	$othrs==-1
	cstmt==0

	entry	excpt.
	entry	ex.tbl
	entry	rtexc.
	intern	exc.ac
	extern	exc.tv
	extern	atn.tv
	extern	atn.ac
	extern	twait.

;
; RTEXC. is just a prelude to EXCPT. and is reached when the
; runtime has detected and signalled an error and the PSA has
; not yet been set up for the exception manager.
;

rtexc.:
	movem	psa,$misc(pda)
	$getpsa	exception
	movem	r2,r2+regs
	move	r2,$misc(pda)
	movem	r2,psa+regs
	movem	pda,pda+regs
	move	r2,r2+regs

;
; EXCPT. is the exception manager which searches the active
; handler tables and fires up the appropriate handler, if any,
; for this condition.  It receives:
;
;  (r0) = exception address (e. g., addr of ill mem ref)
;  (r1) = exception block, with:
;	bits  0..25 = condition cell address
;	bit	 26 = "can continue" flag
;	bits 27..35 = subcondition code
;
; R0, r1, psa and pda regs have been saved and the psa and pda
; regs set up prior to this point.  All other registers are saved
; as necessary.
;
excpt.:
	setom	$excin(pda)	;flag manager running
	aos	cancontinue	;if .gt. 0 on reaching the dot, then
				;not reached through resignal and
				;may be able to continue
	dmovem	r0,resignal	;save for next time
	dmovem	r2,r2+regs	;free a couple of work registers
	ldb	r2,[point 26,r1,25];get the condition cell address
	cail	r2,$stdmax	;track down actual cell address
	hrrz	r2,0(r2)
	cail	r2,$stdmax	;if belongs to user then
	hrrz	r2,0(r2)	;always indirect again
	cail	r2,$stdmax	;and perhaps again if overlaid
	hrrz	r2,0(r2)
	cail	r2,$stdmax
	jrst	notmasked	;user exceptions are never masked
	addi	r2,cells	;addr of cell in PSA
	hlrz	r3,0(r2)	;get masked count
	jumpe	r3,stdnotmasked
	movei	r3,200000
	iorm	r3,0(r2)	;set pending bit
	dpb	r1,[point 16,0(r2),35];save subcondition code for unmask
	hrrzm	r0,.jbcst##	;temp
	dmove	r0,r0+regs
	movei	r2,atn.tv

	ife	$sys-$tym,<
	movem	r2,1+vector>	;reenable attention handler,
				;in case suppressed

	ife	$sys-$adp,<
	movem	r2,$newpc+$icbatn+vector>

	dmove	r2,r2+regs
	setzm	$excin(pda)	;flag manager done
	dmove	psa,psa+regs
	jrst	@.jbcst		;continue

stdnotmasked:
	subi	r2,cells	;keep original cell addr for std condition
notmasked:	;must search for a handler
	dmovem	r4,r4+regs
	dmovem	r6,r6+regs
	move	r3,$base(pda)	;get current stack frame pointer
	setzm	oth16		;flag no OTHERS handler yet encountered

;
; Main search loop:
;    r2 is condition cell addr
;    r3 is current stack frame addr
;    r4 is current handler branch table addr
;

	ccell==r2
	base==r3
	hbt==r4

getchb:
	hlrz	hbt,$chbt(base)	;get current handler block addr
	jumpe	hbt,nextsf	;if none, back one stack frame

;
; Have a handler branch table.  Search it for:
;   (1) - an others handler.  Mark it if first seen.
;   (2) - an actual handler.  Jump out and do it
;   (3) - an ALLCONDITIONS handler.  Same as (2).
;
; Use registers:
;   r5 as addr of current entry in handler branch table
;   r6 as condition cell addr from handler branch table
;   r7 as handler address for that cell, if necessary.
;

	c.hbt==r5
	c.hsb==r5
	c.cell==r6
	h.addr==r7

chbsrc:		;search current handler block
	move	c.hsb,$hsboffset(hbt)
	addi	c.hsb,0(base)	;now addr of HSB
	skipe	$hsbflag(c.hsb)	;if already activated
	jrst	nxthbt		;then skip it
	movei	c.hbt,$hbtentries(hbt);addr of first entry in block
tblchk:
	hlrz	c.cell,0(c.hbt)	;get cell addr
	cain	c.cell,$othrs	;if others, may be first seen
	jrst	is.others
	cain	c.cell,$allconditions
	jrst	hdrfound	;allconditions gets them all
	hrrz	c.cell,0(c.cell);always indirect once
	cail	c.cell,$stdmax	;if not standard then
	hrrz	c.cell,0(c.cell);  always indirect again
	cail	c.cell,$stdmax	;and perhaps again in case overlaid
	hrrz	c.cell,0(c.cell)
	camn	c.cell,ccell	;if same condition
	jrst	hdrfound	;  then done
	aoja	c.hbt,tblchk	;  else continue search of table
is.others:
	hrrz	h.addr,0(c.hbt)	;get the others handler addr
	jumpe	h.addr,nxthbt	;if zero, end of this handler block
	skipe	oth16		;if first "others" seen
	jrst	nxthbt
	dmovem	base,oth16	;then mark its place
	movem	c.hbt,othce
nxthbt:
	hrrz	hbt,$hbtlink(hbt);back to previous handler block
	jumpn	hbt,chbsrc	;if have one, search it
nextsf:
	move	base,1(base)	;back up one frame
	jumpe	base,gotodot	;end of stack, exit to monitor
	jrst	getchb		;search this frame

hdrfound:		;here if handler or allconditions handler found

	skipn	oth16		;if an "others" seen, then
	jrst	dohdr
	dmove	base,oth16	;restore state for the others handler
	move	c.hbt,othce

dohdr:
	hrlm	hbt,$chbt(base)	;new hbt

;
; Store the required info in the HSB for the handler clause.
;

	move	ccell,$hsboffset(hbt)
	addi	ccell,0(base)	;now addr of HSB
	movem	r1,$hsbxb(ccell);and save exception block
	ldb	r1,[point 26,r1,25];get condition cell address
	hrli	r0,0(r1)	;keep around for attention handler
	movem	r0,$hsbxaddr(ccell);flags the handler active
	hrrz	r0,0(c.hbt)	;handler address
	hlrz	r1,$hbtva(hbt)	;header invocation address
;
; Set up string describing location of exception
;

	ch==r2		;char to be added to strng
	strbp==r4	;byte pointer to expanded string
	curlen==r5	;current length of that string
	clink==r6	;JSP link register to ch output routine
	slink==r7	;JSP link register to other string output routines
	slen==r10	;string lengths
	sbp==r11	;string byte pointers
	trace==r12	;addr of trace block
	temp==top	;just a temp, here
	addr==r13	;for octal address output
	num==basis	;for decimal number output
	modx50==basis	;for modname radix-50 output
	stmtx==r13	;addr of cstmt
	pagex==r13	;addr of page block
	filex==r13	;addr of file block

;
; If reached through RESIGNAL then don't modify the description
; string.  It should still indicate the location of the exception,
; not the point of the resignal.
;

	skipg	cancontinue
	jrst	ck.ovl

;
; Initialize string byte pointer and length.
;

	move	curlen,exloc	;count length downward from max to zero
	movei	strbp,2+exloc
	hrli	strbp,440700	;bptr to target string

;
; get addr of trace block first, to check if in debug mode.
;

	hrrz	trace,3(basis)
	hrrz	temp,0(trace)	;addr of trace block or nil
	cain	temp,$nil
	jrst	not.debug	;notrace = not debug
	hlrz	temp,1(temp)	;addr of program block
	skipn	0(temp)		;if zero then
	jrst	not.debug	;  not debug

;
; Exception occurred in a debug module. Put out module
; name first.
;

	move	modx50,-1(temp)	;radix-50 module name
	jsp	slink,put.x50	;place in string
	movei	ch,"@"
	jsp	clink,put.ch

;
; Now track down page and file blocks and save in PSA locs.
;

	move	stmtx,$rtbase(pda)
	hrrz	stmtx,0(stmtx)	;now have CSTMT
	movem	stmtx,xstmt	;which must be saved for line number
ck.stmt:
	hrrz	temp,0(stmtx)	;get line number or bock_id
	jumpe	temp,hv.page	;found page block when zero
	hlrz	stmtx,0(stmtx)	;else check previous stmt block
	jrst	ck.stmt
hv.page:
	movem	pagex,xpage	;save addr of page block for subtitle
ck.page:
	hrrz	temp,0(pagex)	;get block_id for page
	jumpn	temp,hv.file	;have file block when non-zero
	hlrz	pagex,0(pagex)	;else back one page
	jrst	ck.page
hv.file:
	hrrz	temp,1(filex)	;get file number
	jumpe	temp,no.file	;suppress if zero
	move	slen,2(filex)	;get length of file name
	movei	sbp,3(filex)	;and addr of name
	jsp	slink,put.str	;place it
	movei	ch,"-"
	jsp	clink,put.ch
no.file:
	move	pagex,xpage	;retrieve addr of page block
	skipn	2(pagex)	;if null subtitle
	jrst	pg.num		;  then just print page number
	move	slen,2(pagex)	;else put the subtitle
	movei	sbp,3(pagex)
	jsp	slink,put.str
	jrst	do.lpnum
pg.num:
	hrrz	num,1(pagex)	;get page number
	jumpe	num,do.lnum	;print it only if non-zero
	jsp	slink,put.num
do.lpnum:
	movei	ch,"/"
	jsp	clink,put.ch
do.lnum:
	move	num,xstmt	;get back addr of stmt block
	move	num,0(num)	;actual block
	andi	num,37777	;isolate line number
	jsp	slink,put.num	;and place it in string
xdone:
	jumpge	curlen,.+2	;calculate actual length of string
	movei	curlen,0
	sub	curlen,exloc
	movmm	curlen,1+exloc

;
; Before invoking handler, have overlay manager bring
; it in, if necessary.  NOTE: this code assumes r1-r3 and pda are
; restored on return.
;

ck.ovl:
	move	basis,$base(pda)
	skipn	top,$bfpnt(pda)	;fake stack for PUSH
	move	top,$stack(pda)
	movni	r5,60+sz.ovl##	;space free at end of stack
	add	top,r5
	hrli	top,0(r5)
	exch	r1,base		;sf$vfy wants it in r1
	move	r2,r0		;preserve a reg
	push	top,[exp exc.tv]
	jrst	sf$vfy##
exc.ac:
	move	basis,r1	;handler's basis
	movem	basis,$base(pda);keep current
	dmove	r0,r2		;saved registers

;
; Finally, flag the manager done and goto the handler.
;

	setzm	$inrt(pda)	;just in case
	setzm	$excin(pda)
	movei	r2,atn.tv

	ife	$sys-$tym,<
	movem	r2,1+vector>	;reenable attention handler,
				;in case suppressed

	ife	$sys-$adp,<
	movem	r2,$newpc+$icbatn+vector>

	jrst	0(r1)


;
; Not a debug module.  Put location and/or name of routine/module.
;

not.debug:
	movei	slen,loc.len
	movei	sbp,loc.msg
	jsp	slink,put.str
	move	addr,resignal	;exception address
	jsp	slink,put.addr	;in string
	hrrz	temp,0(trace)	;addr of trace block
	caie	temp,$nil
	jrst	is.trace
	movei	slen,rout.len
	movei	sbp,rout.msg
	jsp	slink,put.str
	movei	addr,-1(trace)	;just print entry addr if notrace
	jsp	slink,put.addr
	jrst	xdone

;
; Non-debug module with trace block. Put module name and routine name.
;

is.trace:
	movei	slen,nr.len
	movei	sbp,nr.msg
	jsp	slink,put.str
	move	slen,2(temp)	;length of routine name
	movei	sbp,3(temp)	;and its addr
	jsp	slink,put.str
	movei	slen,mod.len
	movei	sbp,mod.msg
	jsp	slink,put.str
	hlrz	modx50,1(temp)	;addr of program block or zero
	move	modx50,-1(modx50)
	jsp	slink,put.x50
	jrst	xdone

is.user:
	movei	r2,m.user##
	jrst	do.msg
gotodot:
	movem	r0,$retadr(pda)	;address for traceback
	pushj	top,twait.
	dmove	r0,resignal	;restore excpt addr and code
	outstr	[asciz	/
?	/]
	ldb	r2,[point 26,r1,25];get cond cell addr
	cail	r2,$stdmax	;track down actual cell address
	hrrz	r2,0(r2)
	cail	r2,$stdmax
	hrrz	r2,0(r2)	;may be multiply indirected
	cail	r2,$stdmax
	hrrz	r2,0(r2)
	cail	r2,$stdmax
	jrst	is.user
	movei	r2,ex.tbl	;search address table if standard
msg.loop:
	hlrz	r3,0(r2)
	caie	r3,0(r1)
	aoja	r2,msg.loop
	hrrz	r2,0(r2)	;get address from table
do.msg:
	outstr	0(r2)
	outstr	[asciz	/ at user PC /]
	move	r2,[point 3,r0,17]
	movei	r3,6
	ildb	r4,r2
	addi	r4,"0"
	outchr	r4
	sojg	r3,.-3
ex.dot:
	movei	r2,atn.tv

	ife	$sys-$tym,<
	movem	r2,1+vector>	;reenable attention handler,
				;in case suppressed

	ife	$sys-$adp,<
	movem	r2,$newpc+$icbatn+vector>

	$restore regs, r0, r7
	setzm	$excin(pda)
	dmove	psa,psa+regs
	exit	1,
	$getpda
	$getpsa	exception
	dmove	r0,resignal
	skipe	cancontinue	;if came through resignal
	trnn	r1,1000		;or if flag not set
	jrst	cant		;then stay at dot
	movem	r0,.jbcst
	dmove	r0,regs
	dmove	psa,psa+regs
	jrst	@.jbcst		;else do it
cant:
	outstr	[asciz	/?	Can't continue./]
	jrst	ex.dot

;
; Utilities for location-string construction.
;

put.ch:
	sojl	curlen,0(clink)	;don't overwrite anything
	idpb	ch,strbp	;else put character in string
	jrst	0(clink)

put.str:
	hrli	sbp,440700	;make addr into bptr
str.loop:
	sojl	slen,0(slink)	;return when string done
	ildb	ch,sbp
	jsp	clink,put.ch
	jrst	str.loop

put.addr:			;put 6-digit octal number
	move	sbp,[point 3,addr,17]
	movei	slen,6
adr.loop:
	ildb	ch,sbp
	addi	ch,"0"
	jsp	clink,put.ch
	sojg	slen,adr.loop
	jrst	0(slink)

put.num:
	movei	addr,tmpaddr	;pseudo-stack
num.loop:
	idivi	num,^d10
	addi	1+num,"0"	;make ascii character
	movem	1+num,0(addr)	;save remainder in stack
	jumpe	num,num2.loop	;unpack when quotient zero
	soja	addr,num.loop
num2.loop:
	move	ch,0(addr)	;get num from stack
	jsp	clink,put.ch
	caie	addr,tmpaddr	;done when stack empty
	aoja	addr,num2.loop	;else continue unpacking
	jrst	0(slink)

put.x50:
	tlz	modx50,740000	;clear code field
	jumpe	modx50,0(slink)	;just in case it's null
	movei	addr,tmpaddr
x50.loop:
	idivi	modx50,50
	addi	1+modx50,"0"-1	;1-12 = 0-9
	caile	1+modx50,"9"
	addi	1+modx50,"A"-"9"-1	;13-44 = A-Z
	caile	1+modx50,"Z"
	subi	1+modx50,"Z"+1-"$"	;46-47 = $,%
	cain	1+modx50,"#"
	movei	1+modx50,"."		;45 = .
	cain	1+modx50,"&"
	movei	1+modx50,"_"
	movem	1+modx50,0(addr)	;in stack
	jumpe	modx50,num2.loop
	soja	addr,x50.loop

;
; Various messages and their lengths
;

loc.len==^d9
loc.msg: ascii	/Location /
rout.len==^d12
rout.msg: ascii	/ in routine at /
nr.len==^d4
nr.msg==rout.msg

mod.len==^d9
mod.msg: ascii	/, module /
;
; EX.TBL encodes the exception block for each of the standard
; conditions with the address of its associated error message.
;

ex.tbl:
	$errcell ($exmth,$mthfn,$true)
	$errcell ($exmth,$mthfo,$true)
	$errcell ($exmth,$mthao,$true)
	$errcell ($exmth,$mthdz,$true)
	$errcell ($exmth,$mthas,$true)
	$errcell ($exmth,$mthac,$true)
	$errcell ($exio,interr,$false)
	$errcell ($exio,rewerr,$false)
	$errcell ($exio,eoferr,$false)
	$errcell ($exio,outerr,$false)
	$errcell ($exio,inpopn,$false)
	$errcell ($exio,ranerr,$false)
	$errcell ($exio,illcur,$false)
	$errcell ($exio,emperr,$false)
	$errcell ($exio,opnerr,$false)
	$errcell ($exusr,$usras,$true)
	$errcell ($exusr,$usrcx,$true)
	$errcell ($exusr,$usrag,$false)
	$errcell ($exusr,$usrnl,$false)
	$errcell ($exusr,$usrpt,$false)
	$errcell ($exusr,$usrss,$false)
	$errcell ($exusr,$usrsr,$false)
	$errcell ($exusr,$usrsc,$false)
	$errcell ($exusr,$usrfl,$false)
	$errcell ($exsto,$none,$false)
	$errcell ($exstk,$none,$false)
	$errcell ($exspc,$spcmr,$false)
	$errcell ($exspc,$spciu,$false)
	$errcell ($exspc,$spcnn,$false)
	$errcell ($exspc,$spcbp,$false)
	$errcell ($exspc,$spcff,$false)
	$errcell ($exspc,$spcrh,$false)
	$errcell ($exatn,$none,$true)

	$xend	excpt
	prgend
	search	rtsym
	$module	atnacn - null attention handler
	entry	atn.ac
atn.ac==0
	prgend
	search	rtsym
	$module	pnret - Pntry/Prtrn
	entry	pntry.
	entry	prtrn.

pntry.:	dmovem	basis,1(top)
	hrrzm	r1,3(top)
	movei	basis,0(top)
	movem	basis,$base(pda)
	jrst	1(r1)

prtrn.:	dmove	basis,1(basis)
	movem	basis,$base(pda)
	popj	top,

	prgend
	search	rtsym
	$module	exmsg - Exception message printer
	$excpt
	entry	ex.msg
	extern	ex.act
	extern	ex.tbl
	extern	m.user
	extern	twait.
	$temp	rtemp,3		;first used in pushj

ex.msg:
	pushj	top,twait.
	pushj	top,ex.act	;get active hbt + hsb
	jrst	return		;noop if none active
	outstr	[asciz /
%	/]
	ldb	r2,[point 26,r1,25];get cond cell addr
	cail	r2,$stdmax	;track down actual cell address
	hrrz	r2,0(r2)
	cail	r2,$stdmax
	hrrz	r2,0(r2)	;may be multiply indirected
	cail	r2,$stdmax	;especially if overlaid
	hrrz	r2,0(r2)
	cail	r2,$stdmax	;if standard, know where to find info
	jrst	is.user
	movei	r2,ex.tbl	;table to standard messages
msg.loop:
	hlrz	r3,0(r2)
	caie	r3,0(r1)
	aoja	r2,msg.loop
	hrrz	r2,0(r2)	;address of asciz message
do.msg:
	outstr	0(r2)
	outstr	[asciz	/ at user PC /]
	move	r3,[point 3,r0,17]
	movei	r1,6
	ildb	r2,r3
	addi	r2,"0"
	outchr	r2
	sojg	r1,.-3
	outstr	[asciz /
/]
return:
	dmove	r2,1+rtemp
	popj	top,
is.user:
	movei	r2,m.user	;special case user exceptions
	jrst	do.msg
	prgend
	search	rtsym
	$module	exstr - Exception message string
	$excpt
	entry	ex.str
	extern	ex.act
	extern	ex.tbl
	extern	m.user

	pc==r0			;pc returned by ex.act
	char==r1		;temp for transfer of characters
	addr==r4		;address of string result
	destbp==r5		;target byte pointer
	sourcebp==r6		;source byte pointer
	length==r7		;length of string result
	xfer==r10		;JSP register
	count==r11

ex.str:
	move	addr,r2		;preserve address across ex.act call
	movei	destbp,1(addr)	;set up byte pointer to target string
	hrli	destbp,440700
	movei	length,0
	pushj	top,ex.act	;get active hbt + hsb
	jrst	done		;noop if none active
	ldb	r2,[point 26,r1,25];get cond cell addr
	cail	r2,$stdmax	;track down actual cell address
	hrrz	r2,0(r2)
	cail	r2,$stdmax
	hrrz	r2,0(r2)	;may be multiply indirected
	cail	r2,$stdmax	;especially if overlaid
	hrrz	r2,0(r2)
	cail	r2,$stdmax	;if standard, know where to find info
	jrst	is.user
	movei	r2,ex.tbl	;table to standard messages
msg.loop:
	hlrz	r3,0(r2)
	caie	r3,0(r1)
	aoja	r2,msg.loop
	hrrz	sourcebp,0(r2)	;address of asciz message
do.msg:
	jsp	xfer,movestring
	movei	sourcebp,userpc
	jsp	xfer,movestring
	move	sourcebp,[point 3,pc,17]
	movei	count,6
	ildb	char,sourcebp
	addi	char,"0"
	idpb	char,destbp
	sojl	count,done
	aoja	length,.-4
done:
	movem	length,0(addr)
	popj	top,
is.user:
	movei	sourcebp,m.user	;special case user exceptions
	jrst	do.msg
movestring:
	hrli	sourcebp,440700
moveloop:
	ildb	char,sourcebp	;get next character to be moved
	jumpe	char,0(xfer)	;done if at end of asciz string
	idpb	char,destbp	;else move to destination string
	aoja	length,moveloop	;and continue

userpc:	asciz	/ at user PC /
	prgend
	search	rtsym
	$module	exact - find active handler
	$excpt
	entry	ex.act
	$temp	rtemp,2

;
; EX.ACT searches for an active handler.  If none is found it simply returns.
; If one is found it does a skip return with:
;	(r0) = exception address
;	(r1) = exception block
;	(r2) = addr of its HBT
;

	base==r1
	hbt==r2
	hsb==r3

ex.act:
	dmovem	hbt,rtemp
	move	base,basis	;start search with current frame
act.loop:
	hlrz	hbt,$chbt(base)	;get addr of current hbt
	jumpe	hbt,nextsf	;back a frame when no hbt's left in this one
act.check:
	move	hsb,$hsboffset(hbt)
	addi	hsb,0(base)	;now addr of hsb
	skipn	$hsbflag(hsb)	;if inactive
	jrst	nexthbt		;then check outer hbt
	dmove	r0,$hsbxaddr(hsb)
	aos	0(top)		;do skip return with info
	popj	top,
nexthbt:
	hrrz	hbt,$hbtlink(hbt);get outer hbt
	jumpn	hbt,act.check	;check it if is one
nextsf:
	move	base,1(base)	;back one frame
	jumpn	base,act.loop	;look for a handler in it
	popj	top,		;end of stack, return
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthfn)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthfo)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthao)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthdz)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthas)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exmth,$mthac)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,interr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,rewerr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,eoferr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,outerr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,inpopn)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,ranerr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,illcur)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,emperr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exio,opnerr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usras)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrcx)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrag)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrnl)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrpt)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrss)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrsr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrsc)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exusr,$usrfl)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exsto,$none)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exstk,$none)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcmr)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spciu)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcnn)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcbp)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcff)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exspc,$spcrh)
	prgend
	search	rtsym
	search	iosym
	$errmodule ($exatn,$none)
	prgend
	search	rtsym
	$module	nuser
	entry	m.user
m.user==0
	prgend
	search	rtsym
	$module	rtreg
	entry	rt.reg

rt.reg:
	point	4, -1(r1), 12
	prgend
	search	rtsym
	$module	vxrx
	entry	vx.rx
vx.rx==0
	$low
	intern	rx.mth
rx.mth:!	exp	$exmth
	intern	rx.io
rx.io:!	exp	$exio
	intern	rx.usr
rx.usr:!	exp	$exusr
	intern	rx.sto
rx.sto:!	exp	$exsto
	intern	rx.stk
rx.stk:!	exp	$exstk
	intern	rx.spc
rx.spc:!	exp	$exspc
	intern	rx.atn
rx.atn:!	exp	$exatn
	$high
	prgend
	search	rtsym
	$module	rxmth
	entry	rx.mth
	$high
rx.mth:!	exp	$exmth
	prgend
	search	rtsym
	$module	rxio
	entry	rx.io
	$high
rx.io:!	exp	$exio
	prgend
	search	rtsym
	$module	rxusr
	entry	rx.usr
	$high
rx.usr:!	exp	$exusr
	prgend
	search	rtsym
	$module	rxsto
	entry	rx.sto
	$high
rx.sto:!	exp	$exsto
	prgend
	search	rtsym
	$module	rxstk
	entry	rx.stk
	$high
rx.stk:!	exp	$exstk
	prgend
	search	rtsym
	$module	rxspc
	entry	rx.spc
	$high
rx.spc:!	exp	$exspc
	prgend
	search	rtsym
	$module	rxatn
	entry	rx.atn
	$high
rx.atn:!	exp	$exatn
	end
l@*