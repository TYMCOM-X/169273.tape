TITLE	TRMTYP	Program to query a terminal for the type.
SUBTTL	written by David Weaver 1/15/82

	TOPS10==-1

	TWOSEG

IFN TOPS10 <
	SEARCH UUOSYM
IF1 <	PRINTX [Assembling TRMTYP for TOPS10]>
>
IFE TOPS10 <
	SEARCH MONSYM
IF1 <	PRINTX [Assembling TRMTYP for TOPS20]>
>
SUBTTL	Edit History

	TRMWHO==0		;WHO LAST EDITED (0 ORIGINAL AUTHOR)
	TRMMAJ==1		;MAJOR VERSION NUMBER
	TRMMIN==0		;MINOR VERSION NUMBER
	TRMEDT==11		;EDIT LEVEL

;Edit History:
;
;   1	Set the wait time for TOPS20 using the 1 min load average.
;   2	Set the wait time for TOPS10 differently for PTY's.
;   3	Add FL.VID to signify video terminal.
;   4	Fix up terminal types so VT180 and VT100 with printer port
;	are displayed properly.
;   5	Set VT100 with printer port and AVO as VT102 instead of VT100.
;   6	Revoke edit 5 until more cusps now about VT102's.
;   7	Save and restore the state of PAUSE ON END-OF-PAGE and don't
;	mess up the FULL/HALFDUPLEX setting on TOPS20.
;  10	Make sure NO RAISE is set.
;  11	Make PTY's read the controlling terminal's type and if batch,
;	just say batch.
;
IFE TOPS10 <
	RELOC	0

ENTVEC:	JRST	START
	JRST	START
	BYTE	(3)TRMWHO (9)TRMMAJ (6)TRMMIN (18)TRMEDT
ENTLEN==.-ENTVEC
>
IFN TOPS10 <
	LOC	134
	EXP	START
	LOC	137
	BYTE	(3)TRMWHO (9)TRMMAJ (6)TRMMIN (18)TRMEDT
	RELOC	0
>

SUBTTL	Definitions and impure storage

	T1=1
	T2=2
	T3=3
	T4=4
	A=5
	B=6
	C=7
	FL=15
	SP=16
	P=17

;FLAGS (LEFT HALF OF FL)
	FL.ANS==400000			;ANSI MODE TERMINAL
	FL.DEC==200000			;DEC MODE TERMINAL
	FL.VID==100000			;VIDEO TERMINAL (CHECK WIDTH IF ANSI)
	FL.NET==040000			;LINE IS NETWORK LINK
	FL.PTY==020000			;LINE IS ON A PTY
	FL.BAT==010000			;LINE IS CONTROLLED BY BATCH

STKLEN==20
STACK:	BLOCK	STKLEN

TRMSAV:	BLOCK	1		;SOME TERMINAL CHARACTERISTICS TO SAVE
;	FLAGS (RH)
	TR.PAG=400000		;PAUSE ON END-OF-PAGE

IFN TOPS10,<
	TTYCHN==1		;CHANNEL FOR TERMINAL

DEVBLK:	EXP	.IOPIM		;USE PACKED IMAGE MODE
	SIXBIT	/TTY/
	XWD	0,0

TRMFNC:	BLOCK	1		;BLOCK FOR TRMOP FUNCTIONS
TRMUDX:	BLOCK	1
TRMARG:	BLOCK	1

UNKTYP:	SIXBIT	/TTY/		;TOPS10 UNKNOWN TERMINAL TYPE
>
IFE TOPS10,<
DEVSTR:	ASCIZ	/TTY:/
	BLOCK	1

DEVJFN:	BLOCK	1		;JFN FOR TERMINAL

UNKTYP:	EXP	.TTDEF		;TOPS20 UNKNOWN TERMINAL TYPE

JOBBLK:	BLOCK	.JIBAT+1	;BLOCK TO GET JOB INFO
JOBLEN==.-JOBBLK

PTYLIN:	BLOCK	1		;LINE NUMBER OF FIRST PTY
CTYLIN:	BLOCK	1		;LINE NUMBER OF CTY
>
	BYTSIZ==^D7
	TTYSIZ==^D132
TTYBUF:	BLOCK	<TTYSIZ/BYTSIZ>+1

TERTYP:	BLOCK	1

IFE TOPS10,<
	LDAFCT==^D200		;FACTOR FOR MULTIPLYING LD AV BY FOR SLPTIM
	NETTIM==^D3000		;WAIT 3.0 SECONDS ON A NETWORK LINE
>
IFN TOPS10,<
	WAITIM==^D1100		;WAIT 1.1 SECONDS (GOES INTO SLPTIM)
	NETTIM==^D3000		;WAIT 3.0 SECONDS ON A NETWORK LINE
>
SLPTIM:	BLOCK	1		;TIME TO SLEEP

SUBTTL	Main program

	RELOC	400000

START:	RESET
	MOVE	P,[IOWD STKLEN,STACK]
	SETZ	FL,		;CLEAR ALL FLAGS
	PUSHJ	P,OPNDEV	;GO OPEN THE TERMINAL
	PUSHJ	P,CLRIBF	;CLEAR INPUT BUFFER
	PUSHJ	P,SETSLP	;SET THE SLEEP TIME
	MOVEI	T1,[ASCIZ/[Terminal type is /]
	PUSHJ	P,STRSND	;Output the MSG
	TLNN	FL,FL.BAT	;BATCH?
	 JRST	PTYCHK
	MOVEI	T1,[ASCIZ/BATCH/]
	PUSHJ	P,STRSND
	JRST	FINCRL
PTYCHK:	TLNN	FL,FL.PTY	;PTY?
	 JRST	DECDNT
	MOVEI	T1,[ASCIZ/PTY/]
	PUSHJ	P,STRSND
	PUSHJ	P,PTYTYP	;SET PTY SAME AS CONTROLLING TERMINAL
	JRST	FINCRL
DECDNT:	MOVEI	T1,[BYTE (7)33,"Z",0]
	PUSHJ	P,STRSND	;SEND IT
	PUSHJ	P,WAITO		;WAIT FOR OUTPUT TO COMPLETE
	PUSHJ	P,WAIT
	PUSHJ	P,STRGET	;GET THE RESPONSE
	PUSHJ	P,CHKTYP	;AND CHECK THE TYPE
	 JRST	ANSI		;IF WE FAILED, TRY ANSI
	TLNE	FL,FL.VID	;VIDEO TERMINAL?
	 TLNN	FL,FL.ANS	;WAS IT AN ANSI SEQUENCE
	  JRST	FINISH		; NO, GO FINISH UP
	JRST	ANSWID		;YES, FIGURE OUT TERMINAL WIDTH
ANSI:	MOVEI	T1,[BYTE (7)33,"[","0","c",0]
	PUSHJ	P,STRSND	;SEND IT
	PUSHJ	P,WAITO	;WAIT FOR OUTPUT TO COMPLETE
	PUSHJ	P,WAIT
	PUSHJ	P,STRGET	;GET THE RESPONSE
	PUSHJ	P,CHKTYP	;AND CHECK THE TYPE
	 PUSHJ	P,TRMUNK	;SAY "UNKNOWN"
	TLNN	FL,FL.ANS	;ANSI MODE?
	 JRST	FINISH		;NO, DONE
ANSWID:	MOVEI	T1,[BYTE (7)33,"7",33,"[","1",";","1","3","2","H",0]
	PUSHJ	P,STRSND	;SEND IT
	MOVEI	T1,[BYTE (7)33,"[","6","n",33,"8",0]
	PUSHJ	P,STRSND
	PUSHJ	P,WAITO		;WAIT FOR OUTPUT TO COMPLETE
	PUSHJ	P,WAIT
	PUSHJ	P,STRGET	;GET THE RESPONSE
	PUSHJ	P,CHKWID	;GET AND SET TERMINAL WIDTH
	 JFCL			;IGNORE FAILURE
FINISH:	MOVEI	T1,[BYTE (7)33,"\",0]
	PUSHJ	P,STRSND	;SEND IT
FINCRL:	MOVEI	T1,[BYTE (7)"]",15,12,0]
	PUSHJ	P,STRSND
	PUSHJ	P,CLRIBF	;CLEAR INPUT BUFFER
	PUSHJ	P,CLSDEV	;CLOSE TERMINAL
	PUSHJ	P,STOP
	JRST	.-1

SUBTTL	Common subroutines

STRGET: MOVE	A,[POINT 7,TTYBUF,-1]
CHRLUP:	PUSHJ	P,CHRGET	;GET A CHAR
	 JRST	CHRLP1		; NO INPUT
	IDPB	T2,A
	JRST	CHRLUP
CHRLP1:	SETZ	T2,		;TERMINATE WITH A <NUL>
	IDPB	T2,A
	POPJ	P,

CHKWID:	MOVE	A,[POINT 7,TTYBUF,-1]
	ILDB	T2,A		;GET A CHAR
	CAIE	T2,33		;ESC?
	 JRST	CPOPJ		;NO, RETURN
	ILDB	T2,A		;GET NEXT
	CAIE	T2,"["		;ANSI?
	 JRST	CPOPJ		;NO
	PUSHJ	P,ANSNUM	;GET THE ANSI NUMBER
	 JRST	CPOPJ		;INVALID
	PUSHJ	P,ANSNUM	;GET THE ANSI NUMBER
	 JRST	CPOPJ		;INVALID
	LDB	T2,A		;GET LAST CHAR
	CAIE	T2,"R"		;SHOULD BE CURSOR POSITION
	 JRST	CPOPJ		;ISN'T, DON'T SET WIDTH
	PUSHJ	P,SETWID	;GO SET THE WIDTH OF TERMINAL
	JRST	CPOPJ1

CHKTYP:	MOVE	A,[POINT 7,TTYBUF,-1]
	ILDB	T2,A		;GET A CHAR
	CAIE	T2,33		;ESC?
	 JRST	CPOPJ		;NO, RETURN
	ILDB	T2,A		;GET NEXT
	CAIE	T2,"["		;ANSI?
	 JRST	NOANSI		;NO
	ILDB	T2,A		;GET NEXT
	CAIE	T2,"?"		;BETTER BE THIS
	 JRST	CPOPJ		;NOPE, DON'T KNOW WHAT TO CALL THIS
	PUSHJ	P,ANSNUM	;GET THE ANSI NUMBER
	 JRST	CPOPJ		;INVALID
	MOVEI	T2,TBANSI	;GET TABLE TO SEARCH
	PUSHJ	P,SRCTBL	;TRY TO FIND INDEX
	 JRST	CPOPJ		;OUT OF RANGE
	MOVEM	T2,TERTYP	;SAVE TYPE INDEX
	MOVE	C,TYANSI(T2)	;GET TYPE NUMBER/NAME TO SET
	MOVE	B,TBANSI(T2)	;GET TERMINAL TYPE FROM TABLE
	SKIPE	T1,DSANSI(T2)	;GET DISPATCH ADDRESS
	 PUSHJ	P,(T1)		; GO DO IT
	HLRZ	T1,B		;GET STRING ADDRESS
	PUSHJ	P,STRSND	;AND OUTPUT
	PUSHJ	P,SETTYP	;SET TERMINAL TYPE
	TLO	FL,FL.ANS	;FLAG ANSI
CPOPJ1:	AOS	(P)		;GIVE SKIP RETURN
CPOPJ:	POPJ	P,		;AND RETURN

NOANSI:	CAIE	T2,"/"		;DEC MODE?
	 JRST	CPOPJ		;NO, UNKNOWN
	ILDB	T1,A		;GET NEXT CHARACTER
	ANDI	T1,177		;USE ONLY 7 BITS
	MOVEI	T2,TBDEC	;SEARCH DEC TERMINAL TYPES
	PUSHJ	P,SRCTBL
	 JRST	CPOPJ		;
	MOVE	C,TYDEC(T2)	;GET TYPE NUMBER/NAME TO SET
	MOVE	B,TBDEC(T2)	;
	SKIPE	T1,DSDEC(T2)	;GET DISPATCH ADDRESS
	 PUSHJ	P,(T1)		; GO DO IT
	HLRZ	T1,B		;GET TERMINAL STRING
	PUSHJ	P,STRSND	; AND OUTPUT IT
	PUSHJ	P,SETTYP	;SET TERMINAL TYPE
	TLO	FL,FL.DEC!FL.VID ;FLAG DEC VIDEO TERMINAL
	JRST	CPOPJ1		;GIVE GOOD RETURN

;ROUTINE TO SEARCH A TABLE FOR AN ENTRY
;
;	T1/ENTRY TO FIND
;	T2/TABLE ADDRESS (TABLE MUST END WITH 0)
;
;	PUSHJ	P,SRCTBL
;	 <HERE IF ENTRY NOT FOUND>
;	<HERE ON SUCCESS>
;
;	T2/TABLE INDEX
;
SRCTBL:	SETZ	T4,
SRCTB1:	SKIPN	T3,(T2)		;GET CURRENT ENTRY
	 JRST	CPOPJ		; END OF TABLE, NO SUCH ENTRY
	HRRZS	T3		;ONLY RIGHT HALF
	AOS	T2		;INCREMENT
	CAME	T3,T1		;DID WE MATCH?
	 AOJA	T4,SRCTB1	;NO, KEEP LOOKING
	MOVE	T2,T4		;COPY INDEX INTO T2
	JRST	CPOPJ1

SUBTTL	Terminal specific routines

TRMUNK:	MOVE	C,UNKTYP	;GET UNKNOWN NUMBER/NAME
	PUSHJ	P,SETTYP	;SET IT
	MOVEI	T1,[ASCIZ/Unknown/]
	PUSHJ	P,STRSND	;OUTPUT IT
	POPJ	P,

TLA34:	PUSHJ	P,ANSNUM	;GET NEXT PARAMETER
	 POPJ	P,		;NOT VALID
	MOVEI	T2,TBLA34	;GET TABLE TO SEARCH
	PUSHJ	P,SRCTBL	;TRY TO FIND INDEX
	 POPJ	P,		;OUT OF RANGE
	MOVE	C,TYLA34(T2)	;GET TYPE NUMBER/NAME TO SET
	MOVE	B,TBLA34(T2)	;GET TERMINAL TYPE FROM TABLE
	SKIPE	T1,DSLA34(T2)	;GET DISPATCH ADDRESS
	 PUSHJ	P,(T2)		; GO DO IT
	POPJ	P,		;NO, RETURN

TVT125:	PUSHJ	P,ANSNUM	;GET NEXT PARAMETER
	 POPJ	P,		;NOT VALID
	MOVEI	T2,TBT125	;GET TABLE TO SEARCH
	PUSHJ	P,SRCTBL	;TRY TO FIND INDEX
	 POPJ	P,		;OUT OF RANGE
	MOVE	C,TYT125(T2)	;GET TYPE NUMBER/NAME TO SET
	MOVE	B,TBT125(T2)	;GET TERMINAL TYPE FROM TABLE
	SKIPE	T1,DST125(T2)	;GET DISPATCH ADDRESS
	 PUSHJ	P,(T2)		; GO DO IT
	JRST	TVTVID		;RETURN

TVT132:	PUSHJ	P,ANSNUM	;GET NEXT PARAMETER
	 POPJ	P,		;NOT VALID
	MOVEI	T2,TBT132	;GET TABLE TO SEARCH
	PUSHJ	P,SRCTBL	;TRY TO FIND INDEX
	 POPJ	P,		;OUT OF RANGE
	MOVE	C,TYT132(T2)	;GET TYPE NUMBER/NAME TO SET
	MOVE	B,TBT132(T2)	;GET TERMINAL TYPE FROM TABLE
	SKIPE	T1,DST132(T2)	;GET DISPATCH ADDRESS
	 PUSHJ	P,(T2)		; GO DO IT
	JRST	TVTVID		;RETURN

TVT100:	PUSHJ	P,ANSNUM	;GET NEXT PARAMETER
	 POPJ	P,		;NOT VALID
	MOVEI	T2,TBT100	;GET TABLE TO SEARCH
	PUSHJ	P,SRCTBL	;TRY TO FIND INDEX
	 POPJ	P,		;OUT OF RANGE
	MOVE	C,TYT100(T2)	;GET TYPE NUMBER/NAME TO SET
	MOVE	B,TBT100(T2)	;GET TERMINAL TYPE FROM TABLE
	SKIPE	T1,DST100(T2)	;GET DISPATCH ADDRESS
	 PUSHJ	P,(T2)		; GO DO IT
TVTVID:	TLO	FL,FL.VID
	POPJ	P,		;RETURN

;RETURNS ANSI NUMBER IN T1
ANSNUM:	SETZ	T1,		;ZERO
ANSLUP:	ILDB	T2,A		;GET NEXT CHARACTER
	CAIN	T2,";"		;ANSI TERMINATOR?
	 JRST	CPOPJ1		; YES, SO GIVE A <SKIP>
	SKIPN	T2		;<NUL> IS INVALID
	 POPJ	P,		; THEN DONE
	CAIL	T2,"0"		;CHECK FOR INVALID NUMBER
	 CAILE	T2,"9"		;
	  JRST	CPOPJ1		;INVALID, SO TERMINATE
	IMULI	T1,^D10		;SET TO NEXT DIGIT
	SUBI	T2,"0"		;MAKE DECIMAL
	ADD	T1,T2		;AND ADD TO SUM
	JRST	ANSLUP		;AND DO THE REST

SUBTTL	TOPS20 dependent routines

IFE TOPS10,<
OPNDEV:	MOVE	T1,[GJ%SHT]	;USE SHORT FORM
	HRROI	T2,DEVSTR	;POINT TO DEVICE
	GTJFN%			;GET JFN
	 ERJMP	JSYERR		;GO OUTPUT ERROR
	MOVEM	T1,DEVJFN	;STORE JFN
	MOVE	T2,[<BYTE (6)BYTSIZ(4).GSIMG(8)0(18)0>!OF%RD!OF%WR]
	OPENF%
	 ERJMP	JSYERR
	MOVE	T1,[SIXBIT/PTYPAR/]
	SYSGT%			;GET LINE NUMBER OF FIRST PTY
	HRRZM	T1,PTYLIN	;SAVE FOR LATER
	HRROI	T1,[ASCIZ/CTY/]
	STDEV%			;GET DEVICE DESIGNATOR FOR CTY
	 ERJMP	JSYERR
	HRRZM	T2,CTYLIN	;SAVE FOR LATER
	SETO	T1,		;GET OUR JOB INFO
	MOVE	T2,[XWD -JOBLEN,JOBBLK]
	MOVEI	T3,.JIJNO	;START WITH JOB NUMBER
	GETJI%
	 ERJMP	JSYERR
	SKIPGE	JOBBLK+.JIBAT	;BATCH?
	 TLO	FL,FL.BAT	; YES, FLAG IT
	MOVE	T1,JOBBLK+.JITNO ;GET LINE NUMBER
	CAMLE	T1,CTYLIN	;GREATER THAN CTY?
	 TLO	FL,FL.NET	; YES, COULD BE NETWORK LINE
	CAML	T1,PTYLIN	;PTY?
	 TLO	FL,FL.PTY	; YES, FLAG IT
	TLNE	FL,FL.PTY	;PTY?
	 TLZ	FL,FL.NET	; YES, NO NETWORK
	POPJ	P,		;RETURN

SETSLP:	MOVE	T1,[SIXBIT/HQLAV/] ;GET 1 MINUTE LOAD AVERAGE
	SYSGT%
	 ERJMP	JSYERR
	MOVEI	T3,^D4		;ON THE OFF CHANCE THE FIXR OVERFLOWS
	FIXR	T3,T1		;MAKE IT AN INTEGER
	ADDI	T3,1		;ASSURE NON-ZERO
	IMULI	T3,LDAFCT	;MULTIPLY BY LOAD AVE FACTOR
	TLNN	FL,FL.NET	;NETWORK LINE?
	 JRST	SETSL1		;NO, SET WHAT WE CALCULATED
	CAIG	T3,NETTIM	;IF LOAD AVE MAKES GREATER USE THAT
	 MOVEI	T3,NETTIM	;OTHERWISE SET THE NETTIM
SETSL1:	MOVEM	T3,SLPTIM	;
	POPJ	P,

WAIT:	MOVE	T1,SLPTIM	;SLEEP A WHILE
	DISMS%
	 ERJMP	JSYERR
	POPJ	P,

WAITO:	MOVE	T1,DEVJFN	;GET THE JFN
	DOBE%
	POPJ	P,

STRSND:	HRRO	T2,T1
	MOVE	T1,DEVJFN	;GET THE JFN
	SETZ	T3,T4
	SOUT%
	 ERJMP	JSYERR
	POPJ	P,

CHRGET:	MOVE	T1,DEVJFN	;GET JFN
	SIBE%			;ANY INPUT?
	 SKIPA
	POPJ	P,
	BIN%
	 ERJMP	JSYERR
	AOS	(P)		;GIVE SKIP RETURN
	POPJ	P,

CLRIBF:	MOVE	T1,DEVJFN	;GET JFN
	CFIBF%			;CLEAR INPUT BUFFER
	POPJ	P,

PTYTYP:	POPJ	P,		;JUST RETURN (TYPE ALREADY SET BY TOPS20

SETTYP:	MOVE	T1,DEVJFN	;GET JFN
	MOVEI	T2,.MORXO
	MTOPR%			;DISABLE PAUSE AT END OF PAGE
	 ERJMP	JSYERR
	MOVE	T4,TRMSAV	;GET SAVED STATES WORD
	CAIE	T3,.MOONX	;WAS IT SET?
	 TRZA	T4,TR.PAG	; NO, CLEAR IT
	TRO	T4,TR.PAG	;YES, SET IT
	MOVEM	T4,TRMSAV	;SAVE FOR LATER
	RFMOD%			;GET CURRENT MODE WORD
	TRZ	T2,TT%LIC	;MAKE SURE RAISE IS CLEAR
	STPAR%			;SAVE IT
	 ERJMP	JSYERR
	MOVE	T2,C		;GET TYPE
	STTYP%			;SET IT
	MOVEI	T2,.MOXOF
	MOVEI	T3,TR.PAG	;WAS PAUSE AT END OF PAGE SET?
	TDNN	T3,TRMSAV	;
	 SKIPA	T3,[.MOOFF]	; NO, CLEAR IT
	MOVEI	T3,.MOONX	;YES, SET IT
	MTOPR%			;DISABLE PAUSE AT END OF PAGE
	 ERJMP	JSYERR
	POPJ	P,

SETWID:	MOVE	T3,T1		;COPY WIDTH
	MOVE	T1,DEVJFN	;GET JFN
	MOVEI	T2,.MOSLW	;SET WIDTH
	MTOPR%
	 ERJMP	JSYERR
	POPJ	P,

CLSDEV:	SETO	T1,
	CLOSF%
	 ERJMP	JSYERR
	POPJ	P,

STOP:	HALTF%			;STOP
	JRST	.-1

JSYERR:	HRROI	T1,CRLFQ	;OUTPUT <CRLF>?
	PSOUT%
	MOVEI	T1,.PRIOU	;USE PRIMARY OUTPUT DEVICE
	MOVE	T2,[.FHSLF,,-1]	;OUTPUT MESSAGES FOR THIS PROCESS
	SETZB	T3,T4
	ERSTR%			;OUTPUT THE ERROR STRING
	 JFCL
	  JFCL
	SETO	T1,		;CLOSE ALL JFNS
	CLOSF%
	 JFCL			;IGNORE ERROR
	HALTF
	JRST	.-1		;DON'T ALLOW CONTINUES

>;END IFE TOPS10

SUBTTL	TOPS10 dependent routines

IFN TOPS10,<

OPNDEV:	OPEN	TTYCHN,DEVBLK	;OPEN THE TERMINAL
	 JSP	SP,UUOERR
	MOVEI	T1,TTYCHN	;GET UDX
	IONDX.	T1,
	 JSP	SP,UUOERR
	MOVEM	T1,TRMUDX	;STORE FOR TRMOP.
	MOVNI	T1,1		;GET OUR CONTROLLING JOB NUMBER
	CTLJOB	T1,		;TO SEE IF WE ARE ON A PTY
	 JSP	SP,UUOERR
	SKIPL	T1		;PTY?
	 TLO	FL,FL.PTY	;YES
	MOVE	T1,[XWD -1,.GTOBI]
	GETTAB	T1,		;GET BATCH PARAMETERS
	 JSP	SP,UUOERR
	MOVE	T2,[OB.BSS]
	TDNE	T2,T1		;BATCH STREAM?
	 TLO	FL,FL.BAT	;YES, FLAG BATCH
	POPJ	P,

SETSLP:	MOVEI	T2,NETTIM	;SET NETWORK SLEEP TIME
	TLNN	FL,FL.NET	;NETWORK LINE?
	 MOVEI	T1,WAITIM	;NO, SET TTY SLEEP TIME
	MOVEM	T1,SLPTIM	;
	POPJ	P,

WAIT:	MOVE	T1,SLPTIM
	HIBER	T1,		;HIBER FOR SLPTIM
	 JSP	SP,UUOERR
	POPJ	P,

WAITO:	MOVEI	T1,.TOSOP	;WAIT FOR OUTPUT BUFFER TO CLEAR
	MOVEM	T1,TRMFNC
	MOVE	T1,[XWD 2,TRMFNC]
	TRMOP.	T1,
	 POPJ	P,
	JRST	WAITO

STRSND:	MOVEM	T1,TRMARG	;OUTPUT THE STRING
	MOVEI	T1,.TOOUS
	MOVEM	T1,TRMFNC
	MOVE	T1,[XWD 3,TRMFNC]
	TRMOP.	T1,
	 JSP	SP,UUOERR
	POPJ	P,

;GET CHAR IN T2
CHRGET:	MOVEI	T1,.TOSIP	;CHECK FOR INPUT
	MOVEM	T1,TRMFNC
	MOVE	T1,[XWD 2,TRMFNC]
	TRMOP.	T1,
	 POPJ	P,
	MOVEI	T1,.TOISC	;GET A CHAR
	MOVEM	T1,TRMFNC
	MOVE	T2,[XWD 2,TRMFNC]
	TRMOP.	T2,
	 JSP	SP,UUOERR
	AOS	(P)		;<SKIP> RETURN
	POPJ	P,

CLRIBF:	MOVEI	T1,.TOCIB	;CLEAR THE INPUT BUFFER
	MOVEM	T1,TRMFNC
	MOVE	T1,[XWD 2,TRMFNC]
	TRMOP.	T1,
	 JSP	SP,UUOERR
	POPJ	P,

PTYTYP:	MOVNI	T1,1		;GET OUR CONTROLLING JOB NUMBER
	CTLJOB	T1,		;TO SEE IF WE ARE ON A PTY
	 JSP	SP,UUOERR
	TRMNO.	T1,		;GET CONTROLLING JOB TERMINAL
	 JSP	SP,UUOERR
	PUSH	P,TRMUDX	;SAVE OLD UDX
	MOVEM	T1,TRMUDX	;STORE NEW ONE
	MOVEI	T1,.TOTRM	;GET CONTROLLING TERMINAL TYPE
	MOVEM	T1,TRMFNC	;
	MOVE	C,[XWD 2,TRMFNC]
	TRMOP.	C,
	 JSP	SP,UUOERR
	POP	P,TRMUDX	;GET BACK UDX

;HERE WITH TERMINAL TYPE IN C
SETTYP:	MOVEM	C,TRMARG	;SET THE TERMINAL TYPE
	MOVEI	T1,.TOTRM+.TOSET
	MOVEM	T1,TRMFNC
	MOVE	T1,[XWD 3,TRMFNC]
	TRMOP.	T1,
	 JSP	SP,UUOERR
	POPJ	P,

SETWID:	MOVEM	T1,TRMARG	;STORE WIDTH
	MOVEI	T1,.TOWID+.TOSET
	MOVEM	T1,TRMFNC
	MOVE	T1,[XWD 3,TRMFNC]
	TRMOP.	T1,
	 JSP	SP,UUOERR
	POPJ	P,

CLSDEV:	CLOSE	TTYCHN,		;CLOSE THE TERMINAL
	POPJ	P,

STOP:	EXIT	1,		;STOP THE JOB
	JRST	STOP

UUOERR:	OUTSTR	CRLFQ
	OUTSTR	[ASCIZ/UUO returned an ERROR, AC 16 contains the PC/]
	OUTSTR	CRLF
	SUBI	SP,2		;ADJUST TO UUO IN ERROR
	MOVE	15,(16)		;GET UUO
	HALT	.
>;END IFN TOPS10

SUBTTL	Terminal definitions

DEFINE TRMLST,<
	TRM	^D01,<VT100 >,.TT100,<VT100>,TVT100
	TRM	^D02,<LA120 >,.TT120,<LA120>,0
	TRM     ^D03,<TTY   >,.TTDEF,<LA34>,TLA34
	TRM	^D04,<VT100 >,.TT100,<VT132>,TVTVID
	TRM	^D05,<VK100 >,.TTK10,<GIGI(VK100)>,0
	TRM	^D06,<VT102 >,.TT102,<VT102>,TVTVID
	TRM	^D07,<VT100 >,.TT100,<VT131>,TVTVID
	TRM	^D08,<TTY   >,.TTDEF,<VT278>,0
	TRM	^D09,<TTY   >,.TTDEF,<LQP8F>,0
	TRM	^D10,<LA34  >,.TTDEF,<LA34VA>,TLA34
	TRM	^D11,<LA120 >,.TT120,<LA120(Katakana)>,0
	TRM	^D12,<VT100 >,.TT100,<VT125>,TVT125
	TRM	^D13,<TTY   >,.TTDEF,<LQP02>,0
	TRM	^D15,<TTY   >,.TTDEF,<LA12>,0
	TRM	^D16,<VT102 >,.TT102,<VT102J(Katakana)>,0
	TRM	^D17,<TTY   >,.TTDEF,<CT RO Printer>,0
	TRM	^D18,<TTY   >,.TTDEF,<VT80>,0
	TRM	^D19,<TTY   >,.TTDEF,<CLATTER>,0
	TRM	^D20,<TTY   >,.TTDEF,<LA80>,0
	TRM	^D21,<TTY   >,.TTDEF,<CT>,0
	TRM	^D22,<VT100 >,.TT100,<CT(VT100)>,0
	TRM	^D22,<TTY   >,.TTDEF,<CT(VT200)>,0
	TRM	0,0,0,0,-1
>
DEFINE TRMLS1,<
	TRM	^D00,<VT100 >,.TT100,<VT100>,0		;BASE VT100
	TRM	^D01,<VT100 >,.TT100,<VT180>,0	    	;VT180
	TRM	^D02,<VT100 >,.TT100,<VT100(AVO)>,0	;VT100 WITH AVO
	TRM	^D03,<VT100 >,.TT100,<VT180(AVO)>,0	;VT180 WITH AVO
	TRM	^D04,<VT100 >,.TT100,<VT125>,0		;VT125
	TRM	^D05,<VT100 >,.TT100,<VT185>,0
	TRM	^D06,<VT100 >,.TT100,<VT125(AVO)>,0
	TRM	^D07,<VT100 >,.TT100,<VT185(AVO)>,0
	TRM	^D08,<VT100 >,.TT100,<VT100(PRT)>,0	;PRINTER PORT
	TRM	^D09,<VT100 >,.TT100,<VT100(PRT)>,0
	TRM	^D10,<VT100 >,.TT100,<VT100(PRT+AVO)>,0
	TRM	^D11,<VT100 >,.TT100,<VT100(PRT+AVO)>,0
	TRM	^D12,<VT100 >,.TT100,<VT125(PRT)>,0
	TRM	^D13,<VT100 >,.TT100,<VT125(PRT)>,0
	TRM	^D14,<VT100 >,.TT100,<VT125(PRT+AVO)>,0
	TRM	^D15,<VT100 >,.TT100,<VT125(PRT+AVO)>,0
	TRM	0,0,0,0,-1
>
DEFINE TRMLS2,<
	TRM	^D11,<VT100 >,.TT100,<VT132(PRT+AVO+STP)>,0
	TRM	^D15,<VT100 >,.TT100,<VT132(GPO+PRT+AVO+STP)>,0
	TRM	0,0,0,0,-1
>
DEFINE TRMLS4,<
	TRM	^D04,<VT100 >,.TT100,<VT125>,0		;VT125
	TRM	^D05,<VT100 >,.TT100,<VT125(STP)>,0
	TRM	^D06,<VT100 >,.TT100,<VT125(AVO)>,0
	TRM	^D07,<VT100 >,.TT100,<VT125(AVO+STP)>,0
	TRM	0,0,0,0,-1
>
DEFINE TRMLS3,<
	TRM	^D00,<LA34  >,.TTDEF,<>,0
	TRM	^D01,<LA34  >,.TTDEF,<(Extended)>,0
	TRM	^D02,<LA34  >,.TTDEF,<(Katakana)>,0
	TRM	^D03,<LA34  >,.TTDEF,<(Katakana+Extended)>,0
	TRM	0,0,0,0,-1
>
DEFINE DECLST,<
	TRM	<A>,<VT50>,.TTV50,<VT50>,0
	TRM	<B>,<VT50>,.TTV50,<VT50>,0
	TRM	<C>,<VT52>,.TTV52,<VT55>,0
	TRM	<E>,<VT52>,.TTV52,<VT55(VT52)>,0
	TRM	<H>,<VT52>,.TTV52,<VT52H>,0
	TRM	<J>,<VT52>,.TTV52,<VT52H(COP)>,0
	TRM	<K>,<VT52>,.TTV52,<VT52>,0
	TRM	<L>,<VT52>,.TTV52,<VT52(COP)>,0
	TRM	<M>,<VT52>,.TTV52,<VT52(PRT)>,0
	TRM	<Z>,<VT52>,.TTV52,<VT100(VT52)>,0
	TRM	<`>,<VT52>,.TTV52,<VT61(VT52)>,0
	TRM	<a>,<VT52>,.TTV52,<VT61(VT52)(COP)>,0
	TRM	<b>,<VT52>,.TTV52,<VT61(VT52)(PRT)>,0
	TRM	<c>,<VT52>,.TTV52,<VT61(VT52)(PRT+COP)>,0
	TRM	<#>,<VT52>,.TTV52,<VT71t(VT52)>,0
	TRM	0,0,0,0,-1
>
DEFINE TRM (RESP,T10NAM,T20NUM,DESC,ROUTINE),<
IFE ROUTINE+1,<
	EXP	0			;END TABLE IF ROUTINE = -1
>
IFN ROUTINE+1,<
	XWD	[ASCIZ/DESC/],RESP
>
>
TBANSI:	TRMLST
TBT100:	TRMLS1
TBT125:	TRMLS4
TBT132:	TRMLS2
TBLA34:	TRMLS3

DEFINE TRM (RESP,T10NAM,T20NUM,DESC,ROUTINE),<
IFE ROUTINE+1,<
	EXP	0			;END TABLE IF ROUTINE = -1
>
IFN ROUTINE+1,<
	XWD	[ASCIZ/DESC/],"RESP"
>
>

TBDEC:	DECLST

DEFINE TRM (RESP,T10NAM,T20NUM,DESC,ROUTINE),<
	XWD	0,ROUTINE
>
DSANSI:	TRMLST
DST100:	TRMLS1
DST125:	TRMLS4
DST132:	TRMLS2
DSLA34:	TRMLS3
DSDEC:	DECLST

DEFINE TRM (RESP,T10NAM,T20NUM,DESC,ROUTINE),<
IFE T,<
	XWD	0,T20NUM
>
IFN TOPS10,<
	SIXBIT	/T10NAM/
>
>

TYANSI:	TRMLST
TYT100:	TRMLS1
TYT125:	TRMLS4
TYT132:	TRMLS2
TYLA34:	TRMLS3
TYDEC:	DECLST

SUBTTL	Miscellaneous literal storage

CRLFQ:	BYTE	(7)15,12,"?",0
CRLF:	BYTE	(7)15,12,0

LITRL:				;LITERALS START HERE

IFN TOPS10,<
	END	START
>
IFE TOPS10,<
	END	<ENTLEN,,ENTVEC>
>


     @lK