	TITLE	NAD   NODE ASSEMBLER AND DEBUGGER.
	SUBTTL	NAD FILE LAYOUT
	SALL			;SUPPRESS MACRO EXPANTIONS
; ******************************************************************
; **			PROPRIETARY INFORMATION			  **
; **								  **
; **  This  source code listing constitutes the proprietary pro-  **
; **  perty of MDC-TYMNET. The recipient, by receiving this pro-  **
; **  gram listing,  agrees that  neither this  listing  nor the  **
; **  information  disclosed herein nor any  part  thereof shall  **
; **  be reproduced or transferred to other documents or used or  **
; **  disclosed  to others  for manufacturing or  for any  other  **
; **  purpose except  as specifically  authorized in  writing by  **
; **  MDC-TYMNET.						  **
; ******************************************************************
; **			PROGRAM IDENTIFICATION			  **
; **								  **
; **  Version Number	: 1.08	  Release Date : 12/1/87	  **
; **								  **
; **  File Name		: nad01.r08				  **
; **								  **
; **  File Description	: Macro source file for NAD		  **
; **								  **
; **  File Abstract	: This is the only source file for NAD.   **
; **			: The command file NAD01.C08 will create  **
; **			: the file NAD.SAV.			  **
; **								  **
; ******************************************************************
VERSION==1			;NAD version
REVISION==8			;Revision level of version
	LOC	137
	BYTE	(3) 0 (9) VERSION (6) 0 (18) REVISION
	RELOC	0

;	COMMENTS ON CONDITIONAL JUMPS AND SKIPS REFER TO THE JUMP OR SKIP PATH

;	NAD FILE LAYOUT
;	MACRO DEFINITIONS
;	SYMBOLIC DEFINITIONS AND SOME CONSTANTS AND VARIABLES
;	IZY			INITIALIZE SYMBOL TABLE
;	IZ			INITIALIZE NAD
;	GF (GET FILE)		GETS AND ASSEMBLES FILE
;	GS (GET STATEMENT)	GETS AND ASSEMBLES STATEMENT
;	GE (GET EXPRESSION)	GETS AND ASSEMBLES EXPRESSIONS
;	GK  (TOKEN GETTER)	GETS CHR OR SUBSTRING AND TRANSLATES TO A VALUE
;	SYMBOL LOOKUP ROUTINES
;	FILE HANDLER AND SWAPPER
;	LISTER
;	SYMBOL DICTIONARY UTILITY
;	DIRECTIVE PROCESSORS
;	INSTRUCTION PROCESSORS
;	ERROR MESSAGE HANDLER
;	MISCELLANY
;	DEBUGGER COMMAND HANDLER
;	DEBUGGER COMMANDS
;	TABLES AND ERROR MESSAGES
	SUBTTL	MACRO DEFINITIONS
;		*********************************************

	OPDEF	QER	[31_33]
	OPDEF	CIT	[30_33]	;CALL INPUT TRAP PROCESSOR
	OPDEF	MEND	[32_33] ;MACRO END
	OPDEF	MARG	[33_33] ;MACRO ARG
	OPDEF	MAE	[34_33] ;MACRO ARG END
	OPDEF	TMES	[35_33]	;type message
	OPDEF	CPF	[PUSHJ	S,PF]	;CALL PROGRAM FAILURE
	OPDEF	RETURN	[POPJ	S,]
	OPDEF	PJS	[PUSHJ	S,]

	DEFINE	TYPE (TYPEA),<
	TMES	[ASCIZ	\TYPEA\]>

;	GET FREE LIST ENTRY TO W.
	DEFINE	GFL,<
	SKIPN	W,@FL
	PJS	GM
	EXCH	W,FL>

;	RETURN FREE LIST ENTRY FROM REGISTER "R"
	DEFINE	DFL(R),<
	EXCH	R,FL
	HRRZM	R,@FL>

;	CONVERT CHARACTER TO TYMNET CHARACTER BY ADDING PARITY BIT
	DEFINE	TYMNET(C),<200!C>

;	Check if aux circuit defined. If not go to NOAUX.
	DEFINE	AUXCHK,<
	SKIPGE	CN
	JRST	NOAUX>

;DEFINE REGISTERS
S=1			;PUSH DOWN STACK POINTER
I=2			;CURRENT INPUT CHARACTER POINTER
C=3			;CURRENT INPUT CHARACTER (USUALLY)
V=4
U=5
VS=6
OS=7
W=10
X=11
Y=12
L=13
M=14
F=15			;Primary Flag values
F2=16			;Secondary Flag values

	DEFINE	ALS (ALSX,ALSSTR),<ALSB==ALSX
	IRP	ALSSTR,<	ALSSTR==ALSB
		ALSB==ALSB+1>>

	DEFINE	DSP (DSPLST),<IRP DSPLST,<DSPX DSPLST>>
	DEFINE	DSPX (DSPXA),<DSP2 DSPXA>
	DEFINE	DSP2 (DSP2A,DSP2B),<ALS ALSB,DSP2A
	EXP	DSP2B>

	DEFINE	CA (BYTSIZ),	;BYTSIZ IS HALFWORD IF BYTSIZ ARG IS H.
<	PJS	CA'BYTSIZ'SUB>

	DEFINE	DBYTE (BREG),	;DEPOSIT A BYTE
<	MOVE	W,V		;;NEXT PHYSICAL ADDRESS
	SUB	W,VTAB+2	;;BIAS TO VIRTUAL ADDRESS
	CA			;;GET LOCAL BYTE ADDRESS
	DPB	BREG,W		;;DEPOSIT BYTE 2
	ADDI	V,1		;;INCREMENT ADDRESS
>

;	DEFINE IO CHANNELS FOR SYMBOLIC, LISTING, OBJECT, IMAGE BINARY,
;	AND CROSS TEMPORARY.
	ALS	10,<ICH,LCH,JCH,BCH,TCH>

;	DEFINE CHR TYPES
	ALS	0,<IT,OH,DIG,UAF,LAF,UGZ,LGZ,PE,OP,DE,VB,EM,CO,MA,AE>

;	DEFINE OPERATORS AND BUILD OPERATOR INDEXED PRECEDENCE TABLE.
	ALSB==0
PREC:	DSP	<<UAT,7>,<UBSLH,7>,<UPLU,7>,<UMIN,7>>
	NU==ALSB
	DSP	<<BPLU,4>,<BMIN,4>>
	NB==BPLU-UPLU
	DSP	<<STAR,5>,<SLASH,5>,<AMP,2>,<EXCL,1>,<PERC,1>,<UPAR,6>>
	NAO==ALSB		;NUMBER OF ARITHMETIC OPERATORS
	ALS	NAO,<BFO>;	;BBF (BUILD BACKWORD FORWARD).
	DSP	<<OLPAR,0>,<ORPAR,0>,<OT,0>>

;	DELIMITERS
	ALS	0,<BLA,TAB,COM,DOL,LPAREN,RPAREN,EQSIGN,LBRAK,RBRAK>;	;EXPRESSION DELIMITERS
	NED==ALSB
	ALS	ALSB,<COLON,SEMIC,CAR>;	;STATEMENT DELIMITERS
	NSD==ALSB-NED

	DEFINE	JV (AJV),<
	IRP	AJV,<
	JRST	AJV>>

;	BORROW AND RESTORE REGISTERS.
	DEFINE	BAR (BARA),<BARADR==.
	BARM==0
	BARN==0
	IRP	BARA,<BARM==1_BARA!BARM>
	REPEAT	20,<IFN	1_BARN&BARM,<PUSH	S,BARN>
	BARN==BARN+1>
	PJS	.-BARADR+.+2
	REPEAT	20,<BARN==BARN-1
	IFN	1_BARN&BARM,<POP	S,BARN>>
	RETURN>

;	CONDITIONAL DEPOSIT BYTE.
	DEFINE	CDPB (CDPBAC,CDPBD),<
	SKIPE	LSTMSK
	DPB	CDPBAC,CDPBD>

	DEFINE	PE (PEMSG,PERET),<QER	[XWD PEMSG,PERET]>

;	INCREMENT LINE COUNTER EXCEPT DURING MACRO EXPANSION
	DEFINE	INCLC,<
	SKIPN	MACSTK
	AOS	LC>
	SUBTTL	SYMBOLIC DEFINITIONS AND VARIABLES
;		*********************************************


	EXTERN	.JBFF,.JBREN

;Left half of Primary Flag values (register F)
ESCSW==1			;ESCAPE FLAG
VBSEEN==2			;VERTICAL BAR SEEN BY TOKEN GETTER
LSI==4				;1 if listing conditionals (IF, ELSE, EI)
EXPRIP==10			;EXPRESSION EVALLUATION IN PROGRESS
NOMACX==20			;SUPPRESS MACRO EXPANSIONS
NOLIST==40			;1 IF NOLIST
ENDFND==100			;1 IF "END" STATEMENT FOUND
ENDRPT==200			;STATEMENT IS END REPEAT (LISTER)
LSR==400			;0 IF LISTING REPEATED REPEAT LOOP
LSCEOL==1000			;STATEMENT TERMINATOR WAS ";" (LISTER)
LSX==2000			;0 IF LISTING MACRO EXPANSIONS
ABTASM==4000			;1 if assembly aborted
EOFF==10000			;EOF ENCOUNTERED
LSCNF==20000			;NOLIST OR UNTRUE IF (LISTER)
LSF==40000			;0 IF LISTING UNTRUE IF LINES
LSL==100000			;0 IF LISTING NOLISTED LINES AS IS
DCCF==200000			;DEBUG COMMAND CHARACTER ; : OR % SEEN
UTRUIF==400000			;1 IF IN UNTRUE IF

;Right half of Primary Flag values (register F)
ASONLY==1			;1 IF ONLY ASSEMBLING,NOT LISTING
SUPLST==2			;1 IF SUPPRESSING LISTING
LPASS1==4			;1 IF PASS ONE LISTINGS HAPPENING
LPASS2==10			;1 IF PASS TWO LISTING HAPPENING
NEWSEC==20			;1 IF NEXT PAGE SHOULD BE NEW SECTION
TTLFND==40			;1 IF TITLE NOT YET FOUND IN PASS ONE
CREF==100			;1 IF CREF HAPPENING THIS PASS
FSBTTL==200			;1 IF FIRST SUBTITLE NOT YET FOUND
PRPTOK==1000			;1 if last token scanned was in proprietary code
INCREF==2000			;1 IF OUTPUTING CREF INFO
PRPCOD==4000			;1 if in proprietary code
LSTTTL==10000			;1 IF LISTING TITLE
LSTDTL==20000			;1 IF LISTING DEFAULT TITLE
MASCAN==40000			;1 IF SCANNING FOR MACRO ARGUMENTS IN CALL
MBSCAN==100000			;1 IF SCANNING MACRO BODY IN DEFINITION
MKSHAD==200000			;1 if constructing shadow symbol table
LSLOCK==400000			;1 if input file is proprietary and not listed

;Right half of Secondary Flag values (register F2)
FRCLST==1			;1 if all assembles should list
MLTLST==2			;1 if multiple assemblies to single file
CRFLST==4			;1 if listing is a CREF listing
PS1LST==10			;1 if pass one listing desired
TYMPRP==20			;1 if user has TYMSHARE PROPRIETARY license
BINMOD==40			;1 if debugger in binary mode
CONDST==100			;1 if statement is conditional (IF, ELSE, EI)

;Monitor symbol definitions
JP.TYM==1B21			;TYMSHARE PROPRIETARY license
.GTFPN==-25			;GETTAB of file PPN
.GTPRV==6			;GETTAB of user privledge
.GTUNM==-22			;GETTAB of user name (1-6) SIXBIT
.GTUN1==-21			;GETTAB of user name (7-12) SIXBIT
.GTLIC==-20			;GETTAB of user license (process,,frame)
.GTCNF==11			;GETTAB of configuration table

;Symbol table bits in word zero
SYUNDF==400000			;symbol is undefined
SYSHNU==200000			;symbol was not defined (only shadow table)
SYPROP==100000			;symbol was defined in proprietary file
SYPRPM==040000			;symbol is macro from proprietary code or macro

HASHSZ==2007			;HASH TABLE SIZE
RPMAX==4			;MAX NUMBER OF ACTIVE REPEAT BLOCKS
CHRIT==00			;INPUT TRAP CHARACTER (MUST BE 0)


	NPDS==120		;PUSH DOWN STACK SIZE
	NIPD==20		;INTERRUPT STACK SIZE
IPDS:	BLOCK	NIPD		;STACK FOR AUX INTERRUPT
INTS:	0
PDS:	BLOCK	NPDS		;PUSHDOWN STACK AND SOME TEMPORARY STORAGE SPACE

ESKP:	IOWD	40,ESK1
	IOWD	40,ESK2
ESK:	BLOCK	2		;STACK POINTERS FOR STATEMENT ERROR STACK
ESK1:	BLOCK	20
ESK2:	BLOCK	20
	UCERN==10
UCERC:	Z
UCPCT:	BLOCK	UCERN		;TABLE OF PC S THAT HAVE BAD DISPLACEMENTS FOUND BY UC

	NNEST==2		;NUMBER OF LEVELS ALLOWED OF NESTED "'"S
	NVS==20			;NUMBER OF VALUES THAT CAN FIT INTO VALUE STACK
	NOS==NVS+4		;ALLOW A FEW MORE OPERATORS THAN VALUES
OPS:	0			;POINTER TO OP STACK
VALS:	0			;POINTER TO VAL STACK
VALSF:	0			;POINTER TO UNDEF FLAG STACK
VALSS:	BLOCK	NVS*NNEST
VALSFS:	BLOCK	NVS*NNEST	;FLAGS THAT SPECIFIY WHETHER VALS IS UNDEFINED
OPSS:	BLOCK	NOS*NNEST	;OPERATOR STACK
IBSLP:	Z	BSLPS		;initial value for backslash stack pointer
BSLP:	Z			;backslash stack pointer
BSLPS:	BLOCK	NOS*NNEST	;backslash stack. -1 if \ arg, 0 otherwise

LABEL:	Z
LABELP:	Z
LLABEL:	Z
LLC:	Z
TYP6C:	Z
DOTP:	Z
CURSEG:	0			;CURRENT SEGMENT INDEX
;SEGMENT TABLE - INITIAL PC VALUES
SEGSAV:	BLOCK	20		;FOR SAVING INITIAL SEGTAB
SEGTAB:	EXP 0,200000,400000,600000
	EXP 1000000,1200000,1400000,1600000
	EXP 2000000,2200000,2400000,2600000
	EXP 3000000,3200000,3400000,3600000
SEGTOP:	EXP 0,200000,400000,600000
	EXP 1000000,1200000,1400000,1600000
	EXP 2000000,2200000,2400000,2600000
	EXP 3000000,3200000,3400000,3600000
PC:	Z
PCP:	Z
PCP1:	Z
PCP2:	Z
PCV1:	CPF
PCV2:	Z
MOA:	SIXBIT	"OPCODE"	;MODULE NUMBER 0
	SIXBIT	"GLOBAL"
	SIXBIT	".MACRO"	;RESERVED FOR SYSTEM USE
	SIXBIT	"..FREE"
	SIXBIT	"MAIN  "
	BLOCK	44+MOA-.
MOORG:	BLOCK	44		;VALUE OF ORIGIN WHEN THIS MODULE STARTED EFFECT
MOUSE:	BLOCK	44		;USING REGISTOR ASSOCIATED WITH A MODULE
IBF0:	Z			;ADDRESS OF FIRST INPUT BUFFER
JSPEC:	16
	SIXBIT	/DSK/
	0
BSPEC:	16			;NAD IMAGE BINARY FILE SPEC
	SIXBIT	/DSK/
	0
BL:	12			;EXTENDED LOOKUP BLOCK
	BLOCK	11
LSPEC:	0
	SIXBIT	/DSK/
	LOH,,0
TSPEC:	17			;CROSS REQUEST FILE SPEC
	SIXBIT	/DSK/
	0
TL:	6			;CROSS REQUEST EXTENDED LOOKUP AND ENTER BLOCKS
	0
TE:	SIXBIT	/000CRE/
	SIXBIT	/TMP/
	0
TLSIZE:	0			;FILE SIZE
TR:	BLOCK	4		;CROSS REQUEST DELETE BLOCK
SWAPC:	Z
DMSCTR:	Z
LSPACE:	Z
LSTMSK:	Z			;-1=PASS 1, 0=PASS 2
DSW:	Z			;ZERO IF GS NOT CALLED BY DEBUGGER

.CHOPN==13			;init a device and channel
.CHLK==4			;select a file for input
.CHIBF==22			;create input buffer ring
.CHIN==14			;buffered input
.CHREL==0			;release a device

CMDNBF==1			;number of input buffers for each file
CMDSBF==3+CMDNBF*<3+200>	;input buffer size
CMDMAX==5			;number of command files
CMDLIM==CMDMAX-1		;highest command file number
CMDCHN==20			;first command file channel

CMDUSR:	BLOCK	2		;command file user name
CMDBLK:	Z			;open block
	SIXBIT	/DSK/
	Z
CMDNAM:	BLOCK	4		;lookup block
CMDBUF:	BLOCK	CMDSBF*CMDMAX	;command file input buffers
CMDBFA:	BLOCK	0		;addresses of input buffers
CMDX==0
	REPEAT	CMDMAX,<
	EXP	CMDBUF+CMDX*CMDSBF
CMDX==CMDX+1>
CURCMD:	EXP	-1		;index of current commmand file
	EXP	0		;CMDECO(-1) for inital value of echoing
CMDECO:	BLOCK	CMDMAX		;-1 if no echo, 0 if echo of command input
	PJS	CTINP		;input routine for command file -1, always terminal
CMDSRC:	BLOCK	CMDMAX		;command file source
GCHI:	PJS	CTINP		;GET CHAR INSTRUCTION
LEUSR:	BLOCK	2		;listing file user name
LE:	BLOCK	4
LOH:	BLOCK	3
ISPEC:	0
	SIXBIT	/DSK/
	XWD	0,IH
OBJNAM:	SIXBIT	/NAD/		;OBJECT FILE NAME
OBJNM1:	SIXBIT	/TMP/
JE:	BLOCK	4
;
;	The source file lookup block. An extended lookup block
;	is used to get the PPN of the file being looked up. This is returned is IL+1
;	replacing the address of the username (ILUSR). The PPN is used to determine
;	if the file to be assembled comes from the directory from which NAD
;	was started.
;
ILUSR:	BLOCK	2		;input file user name
IL:	Z	5		;INPUT FILE LOOKUP BLOCK
	BLOCK	5		;a five data word extended lookup block
IH:	BLOCK	3		;INPUT FILE BUFFER RING HEADER

IFPPN=IL+1			;PPN value in input file LOOKUP block
NADFPN:	BLOCK	1		;PPN of file where loaded from
MYLIC:	BLOCK	1		;process license,,frame license at start
NEEDLC:	BLOCK	1		;0 if file not in SOURCE or BETATEST

SRCTAB:	SIXBIT	/SOURCE/	; Name of allowable source directory
	Z			; (2 words)
	SIXBIT	/BETATE/	; Name of allowable source directory
	SIXBIT	/ST    /	; (2 words)
	SIXBIT	/QSATS /	; Name of official patch directory
	Z			; (2 words)
SRCLEN=<.-SRCTAB>/2		; Number of entries (divide by 2 words)

SYLOCK:	BLOCK	1		;0 if symbols not in proprietary code,
				;SYPROP otherwise

;	NAD IMAGE BINARY I/O MACROS
	DEFINE	IBINP(BUFF,R,BAD),
<	IFNB	<BAD>,<MOVE R,BAD
>	IFNB	<R>,<USETI BCH,1(R)
>	INPUT	BCH,[BYTE (18)-200,BUFF-1,0,0]>

	DEFINE	IBOUT(BUFF,R,BAD),
<	IFNB	<BAD>,<MOVE R,BAD
>	IFNB	<R>,<USETO BCH,1(R)
>	OUTPUT	BCH,[BYTE (18)-200,BUFF-1,0,0]>

	DEFINE	IIBSW(X,N),
<	MOVEI	W,X
	MOVEI	V,N
	PJS	ISYIB
	CPF>

	DEFINE	OIBSW(X,N),
<	MOVEI	W,X
	MOVEI	V,N
	PJS	OSYIB>

;	NAD IMAGE BINARY FILE ID RECORD BLOCK.
IBID:	0			;ID HEADER (4/1,12/BAD,20/**)
IBPSA:	0			;PROGRAM START ADDRESS
IBDATE:	0			;CREATION DATE (PDP FORMAT)
IBTIME:	0			;CREATION TIME IN MSEC
IBUNAM:	BLOCK	2		;USERNAME FOR FILE (6BIT)
IBFILE:	BLOCK	2		;FILENAME AND EXTENSION (6BIT)
IBAUTH:	BLOCK	2		;USERNAME OF AUTHOR (6BIT)
IBRIX:	BLOCK	2*100-12-2		;2 WORD RECORD INDEXES
	0
IBIDC:	0			;CHAIN TO NEXT ID RECORD BLOCK

;	NEW RECORD BLOCK
NRHDR:	BLOCK	2		;4/TYPE, 12/BAD, 20/**
NRDATA:	BLOCK	176		;36/**
NREND:	1100,,NRDATA+175

;	NIB MEMORY IMAGE BLOCK.
MIHDR=NRHDR			;4/2, 12/BAD, 20/PAD; 15/BCNT, 1/U, 20/VAD
MIDATA=NRDATA			;4(1/0,8/BYTE) OR 1/1,8/BYTE,1/0,8/BYTE,18/REPEAT CNT
MIEND=NREND
MIBMAX==77776			;MAXIMUM BYTES IN A MEMORY IMAGE RECORD.
				;LIMITED BY SIZE OF 'BCNT' FIELD IN HEADER (ONLY 15 BITS)
				;AND THE DESIRE TO HAVE AN EVEN NUMBER OF BYTES IN EACH RECORD.

;	NIB SYMBOL TABLE BLOCK
SYHDR=NRHDR			;4/3, 12/BAD, 20/COUNT; 36/MODULE
SYDATA=NRDATA			;36/**
SYEND=NREND

;	MAC set and memory bank record
MSHDR=NRHDR			;4/4, 12/**, 20/Subtype; 36/Data

;	NIB FLAGS AND POINTERS.
IBTYPP:	POINT	4,(M),3		;RECORD TYPE POINTER
IBBADP:	POINT	12,(M),15	;BLOCK ADDRESS POINTER
IBPADP:	POINT	20,(M),35	;PHYSICAL ADDRESS POINTER
IBSYCP=IBPADP			;SYMBOL TABLE ENTRY COUNT
IBMSTP=IBPADP			; MAC set entry subtype pointer
IBCNTP:	POINT	15,1(M),14	;BYTE COUNT POINTER
IBUVAP:	POINT	1,1(M),15	;UNDEFINED VIRTUAL ADDRESS FLAG POINTER
IBVADP:	POINT	20,1(M),35	;VIRTUAL ADDRESS POINTER
BRNGL:	0			;BEGIN OF GET MEMORY RANGE LIST
ERNGL:	0			;END OF GET MEMORY RANGE LIST
MIALL:	0			;<0 IF PUT/GET SELECTIVE,ELSE >=0
MIDAP:	0			;NEXT DATA BYTE POINTER (IN MI BLOCK)
SYDAP=MIDAP
IBRIXP:	0			;NEXT AVAILABLE INDEX SLOT FOR NIB PUTS
SCNT:	0			;SAVED IMAGE BINARY BYTE COUNT (WHEN>77777)
BFSW:	-1			;0=NEW FILE, 1=OLD, -1=NONE
BAD:	0			;NEXT BLOCK TO OUTPUT/INPUT
B1BAD:	0			;FIRST BLOCK OF SYMBOL TABLE RECORD
SYBUFF:	BLOCK	3		;BUFFER FOR SYMBOL TABLE ENTRIES
MSMSTY==1			; MAC set record subtype
MSTYP==4			; MAC set record type
SYTYP==3			;SYMBOL TABLE RECORD TYPE
MITYP==2			;MEMORY IMAGE RECORD TYPE
IDTYP==1			;ID RECORD TYPE
IBSOVR:	SIXBIT	/022779/	; State table version of invalid macro defs
IBSVER:	SIXBIT	/080883/	; State table version on nib file
IBMMUL:	BLOCK	1		; Multiplier for macro size in definition
NIBSW==200			;NUMBER OF NIB STATE TABLE WORDS

;	LISTER FLAGS, CONSTANTS AND VARIABLES.
ICHPLN==^D120			;INITIAL CHARACTERS/LINE
CPLMAX==^D145			;MAXIMUM CHARACTERS/LINE
CPLMIN==^D50			;MINIMUM CHARACTERS/LINE
ILNPPG==^D56			;INITIAL LINES/PAGE
LPPMAX==777777			;MAXIMUM LINES/PAGE
LPPMIN==^D4			;MINIMUM LINES/PAGE
CHPLN:	ICHPLN			;CHARACTERS/LINE
LNPPG:	ILNPPG			;LINES/PAGE
LSTLN:	Z			;-1 IF LINE NOT YET LISTED
				; 0 IF MORE OF LINE TO LIST
				; 1 IF LINE DONE LISTING
SAVCHR:	Z			;SAVE CHARACTER BETWEEN LINE LISTINGS
HEXSIZ==20			;CHAR POS FOR HEX IN LISTING (NOT PC)
ITXTSZ==ICHPLN-HEXSIZ		;INITIAL TEXT SIZE
TXTSIZ:	ITXTSZ			;TEXT SIZE
LNLEFT:	0			;LINES LEFT ON PAGE BEING LISTED
STDTTL:	ASCIZ	"  NAD-000000 00-XXX-00 00:00"
MONTH:	ASCII	"-jan-"
	ASCII	"-feb-"
	ASCII	"-mar-"
	ASCII	"-apr-"
	ASCII	"-may-"
	ASCII	"-jun-"
	ASCII	"-jul-"
	ASCII	"-aug-"
	ASCII	"-sep-"
	ASCII	"-oct-"
	ASCII	"-nov-"
	ASCII	"-dec-"
TTLMIN==^D46			;MINIMUM CHARACTERS IN TITLE
TTLSIZ==<CPLMAX-TTLMIN>/5+1	;SIZE OF TITLE BUFFERS
TTLBF:	BLOCK	TTLSIZ		;TITLE BUFFER
DTTLBF:	BLOCK	TTLSIZ		;DEFAULT TITLE BUFFER
STLMIN==^D25			;MINIMUM CHARACTERS IN SUBTITLE
STLSIZ==<CPLMAX-STLMIN>/5+1	;SIZE OF SUBTITLE BUFFERS
STLBF:	BLOCK	STLSIZ		;SUBTITLE BUFFER
DSTLBF:	BLOCK	STLSIZ		;DEFAULT SUBTITLE BUFFER
SECNUM:	Z			;CURRENT SECTION NUMBER
PAGNUM:	Z			;CURRENT PAGE NUMBER
TXTOUT:	Z			;NUMBER OF TEXT CHARACTERS OUTPUT SO FAR
NORPT:	0			;DON'T LIST REPEATED REPEAT IF NOLIST OR UNTRUE IF
SYSNO:	BLOCK	7		;Sysno buffer for %V command

SWRAN:	XWD	122002,101012
UCC:	Z
GESF:	Z
OPCODE:	Z
R1:	Z
DISP:	Z
FX2:	Z
SX2:	Z
RUSING:	Z
UDISP:	Z			;0 if disp defined, -1 if undefined
GSEC:	Z			;STATEMENT ERROR COUNT
ERRCNT:	Z			;Assembly error count
GMTVAL:	BLOCK	1		;Fixed GMT value for file assembly
TIMFIX:	BLOCK	3		;used for time fixing with DATUUO
UNSW:	Z			;SET TO -1 BY UN DIR. TO INHIBIT DEN FROM TYPING UNDEFINEDS
IFLINE:	0			;LINE NUMBER OF OUTER IF STATEMENT
IFLABL:	0			;LABEL NAME OF OUTER IF STATEMENT
IFLOCL:	0			;LOCAL LINE OF OUTER IF STATEMENT
TRUTH:	0			;USED BY LISTER TO REMEMBER IF BODY STATUS
IFC:	Z
IFT:	Z
ELSESW:	Z
RPF:	Z
RELINE:	0			;LINE NUMBER OF OUTER REPEAT STATEMENT
RELABL:	0			;LABEL NAME OF OUTER REPEAT STATEMENT
RELOCL:	0			;LOCAL LINE OF OUTER REPEAT STATEMENT
RPPTR:	Z
RPL:	BLOCK	RPMAX
RPI:	BLOCK	RPMAX
RPC:	BLOCK	RPMAX
RPLC:	BLOCK	RPMAX
RLINEI:	BLOCK	RPMAX
RPMAC:	BLOCK	RPMAX		;macro invocation at repeat start
	NSB==10			;SIDE BFRS FOR INPUT
	IINBUF==30		;MINIMUM NUMBER OF BFRS IN INPUT RING
	NLBF==10		;EXTRA BFRS FOR INPUT IF NOT LISTING.
PTB:	Z			;POINTER TO TRAILING BFR
PAB:	Z			;POINTER TO ACTIVE BFR
PLB:	Z			;POINTER TO LEADING BFR
LTT:	Z
LPG:	Z
GFS:	Z
LSVSIZ==3000			;SIZE OF LISTING SAVE BUFFER
LSVCNT:	Z			;NUMBER OF CHARACTER LEFT IN LSTBUF
LSTBUF:	BLOCK	LSVSIZ		;LISTER LINE SAVE BUFFER
LSVP:	Z			;LISTER LIVE BUFFER POINTER
LISTI:	Z			;SAVE CURRENT TEXT POINTER START
PCORG:	Z
PCL:	-1			;-1 IF NO MEMORY DATA TO LIST, PC TO LIST FROM, PC AND SIGN
;				BIT FOR PC THAT IS NOT IN LINE WITH THE VALUE OF .
LINEI:	Z			;BEGINING OF LINE POINTER
LC:	Z			;LINE COUNT
LEC:	Z			;LINE ERROR COUNT
PET1:	BLOCK	20
PET2:	BLOCK	20
GEUOK:	Z

GSSTK:	Z			;stack pointer on entering GS
UX:	Z			;previous pointer from FY
UL:	Z			;UL AND UM MUST BE IN CONSECUTIVE LOCATIONS
UM:	Z
MM:	-1			;MODULE MASK
MM1:	-1
DFODLO:	Z
MODULE:	4			;CURRENT MODULE NUMBER
AMM:	Z			;MODULE MASK AT ASSEMBLY START
AMODUL:	Z			;MODULE NUMBER AT ASSEMBLY START
TRADIX:	20
RADIX:	20
ARADIX:	20			;RADIX WHEN STARTING ASSEMBLER
BACKUP:	XWD	70000,
TP:	BLOCK	40		;TEST PACKAGE OR PATCH AREA

;	DEBUGGER STORAGE
CRS:	Z

;	Interrupt system definitions.
;	The definitions for the names xxxCHN must correspond with the
;	location of the interrupt routines in the transfer table TIV.

IA.DIS==1			;Disable interrupt system
IA.REE==2			;Enable interrupt system
IA.CLR==4			;Clear interrupt system

.IAESC==0			;Receipt of escape
.IACHR==1			;Receipt of a character
.IALOS==5			;Character lost on input
.IAZAP==7			;Receipt of a circuit zapper

ESCCHN==1			;Escape interrupt channel
ZAPCHN==2			;Zapper interrupt channel
LOSCHN==3			;Character lost interrupt channel
CHRCHN==4			;Character received interrupt channel

TIV:	EXP	0,ESC,0,AUXZAP,0,AUXLOS,0,AUXINT ;TRAP INTERUPT VECTOR (OLDPC,,TRAPADR)
CN:	0
ICX:	Z
OBR:	Z			;OUTPUT BAUD RATE
ESCBLK:	BLOCK	4
XIRX3R:	-1
MDPAIR:	BLOCK	2
AAPC:	Z
LVV:	BLOCK	2		;VALUE VECTOR FOR DEBUGGER COMMANDS.
;				 CONTAINS (VALUE OF LAST ARG, 0) FOR
;				 EXPRESSIONS OR 2-6 BYTE INSTRUCTION VALUE
;				 AND BYTE COUNT (SEE XVU)
XIVU:	BLOCK	2
XIU:	Z
XIW:	Z
TNX:	CPF
SWMIN:	Z
LOCAL:	1
DBLCHR:	Z			;LAST CHR PREPARED FOR OUTPUT BY DB.
DBC0:	Z
DBC1:	Z
BC:	Z			;BLANK COUNT
ARGC:	Z			;NUMBER OF ARGS SEEN FOR DEBUGGER COMMAND
ARGC1:	Z			;SAME AS ARGC FOR USE BY AA ONLY

IPC:	Z
TOM:	Z			;TYPE OUT MODE
COS:	Z			;CURRENT OUTPUT SIZE (HALFWORD OR FULLWORD)
DTOM:	Z			;NOTE TOM AND COS TREATED AS DOUBLE WORD IN CRET COMMAND
DCOS:	Z
WCLM:	Z			;WIDTH OF COLUMNS FOR OUTPUT
NCLM:	Z			;NUMBER OF COLUMNS FOR OUTPUT
DWCLM:	Z			;WIDTH OF COLUMNS FOR OUTPUT
DNCLM:	Z			;NUMBER OF COLUMNS FOR OUTPUT
CLMCNT:	Z			;CURRENT COLUMN COUNT
OPEN:	Z			;NON-ZERO IF MEMORY IS OPEN
CMACNT:	Z
P6:	.+1
	OUTCHR	V
	IDPB	V,DOS
DOSX:	Z
DOS:	POINT	7,.+1
	BLOCK	20		;DISASSEMBLY OUTPUT STRING
CS0:	ASCII	"     "
CS:	BLOCK	17		;COMMAND STRING
LCS:	BLOCK	1		;LAST COMMAND STRING POINTER
NCARGS==20			;NUMBER OF COMMAND ARGS ALLOWED
VTABP:	Z
VTAB:	BLOCK	2*NCARGS
CMLADR:	Z
CMLDTA:	Z
CMLU:	Z
CMLCHR:	Z			;CURRENT COMMAND CHARACTER
ICCHR:	Z			;CURRENT ENGINE COMMAND CHARACTER
ICCTRM:	Z			;-1 if command terminator sent, 0 if not
ICJMP:	Z	IC2		;ENGINE COMMAND ARGS AFTER COMMAND KLUDGE JUMP
CMPCNT:	Z			;COMPRESSION COUNTER
ASCHEX:	Z
FCSMIN:	100			;NUMBERS BELOW THIS ARE NOT TRANSLATED TO SYMBOLS
;		 UNLESS USER EXECUTES VALUE;@ COMMAND
FCSBND:	200			;MAX SYMBOL DIFFERENCE IN FCS
GECALL:	CPF
;	END OF DEBUGGER STORAGE

FL:	EXP	.+1,0,0,0
YENDSV:	Z
YEND:	Z
YEND1:	Z
YSUM:	EXP	0
YHASHT:	BLOCK	HASHSZ
EYH:

SHASHT:	BLOCK	HASHSZ		;Shadow symbol table
ESYH:
	PGSIZ==4000		;PDP 10 WORDS PER PAGE
	NPG==4			;NUMBER OF IN CORE PAGES
	NPGD==200		;THE PROGRAM LOGIC MUST BE CHANGED ALONG WITH
				;THESE PARAMETERS. THESE ARE COMMENT PARAMETERS.

CP:	REPEAT	PGSIZ/200,<XWD -200,0>
	Z
PGT:	BLOCK	NPGD		;PAGE MAPPING TABLE
;STORAGE FOR MACRO FACILITY
MACFRE:	XWD	MACFRE,MACFRE	; Macro body free list. Start list empty
	0			; Set this entry empty
MACVER:	Z			;macro invocation counter
MACCUR:	Z			;current macro invocation
MACCNT:	Z			;NUMBER OF CHARS LEFT IN PORTION OF DEF BLOCK
MACI:	Z			;SAVE INPUT POINTER FOR ERRORS DURING EXPANSIONS
MACN:	Z			;POSITION IN MACRO STACK FOR ERROR MESSAGES
MACSTK:	Z			;MACRO ARGUMENT CALL STACK
IPSTK:	Z			;INPUT TEXT POINTER STACK
ALWARG:	Z			;ALLOW DUMMY AFTER THIS CHAR IN MACRO DEF
MCHCNT:	Z			;NUMBER OF WORDS IN MACRO DEF BLOCK
MSYSAV:	BLOCK	2		;SAVE OF MACRO ARG DURING DEFINITION
MACTXT:	Z			;ADDRESS OF TEXT CHAIN DURING MACRO DEFINITION
NMARGS:	0			;ARG COUNT
NMACA==20			;MAX NUMBER OF ARGS ALLOWED
MACARG:	BLOCK	NMACA		;SPACE FOR BYTE POINTERS TO ARG STRINGS
MBMAX==777			;Maximum number of blocks in macro definition
MWMAX==3*MBMAX			;Maximum number of words in a macro definition
MBSIZ==5*3			;Number of characters in a macro block
MACBUF:	BLOCK	MWMAX		; Buffer for macro def and call while scanning
	SUBTTL	INITIALIZE NAD
;		*********************************************


IZ:				;INITIALIZE NAD
	RESET
	SETZB	F,F2		;INITIALIZE ALL FLAGS TO OFF
	MOVE	W,[-1,,.GTLIC]	;GET CURRENT LICENSE
	GETTAB	W,
	  SETZ	W,		; OOPS!  SAY NONE
	SKIPN	MYLIC		; ONLY DO ONCE
	  MOVEM	W,MYLIC		; SAVE FOR LATER...
	HRLZI	W,320000
	MOVEM	W,MM		;SET UP MODULE MASK
	MOVEI	W,4
	MOVEM	W,MODULE
	DMOVE	W,[ OPSS(OS)
		VALSS(VS)]	;INIT EXPR STACK PTRS
	DMOVEM	W,OPS
	MOVE	W,[ VALSFS(VS)]
	MOVEM	W,VALSF
	SETZM	BSLPS		;set first stack word to not \
	SETZM	LLABEL
	SETZM	LLC
	SETZM	DTTLBF		;SET NULL DEFAULT TITLE
	SETZM	DSTLBF		;SET NULL DEFAULT SUBTITLE
	SETZM	SECNUM		;START AT SECTION ONE
	MOVE	S,[IOWD NPDS,PDS]
	MOVE	W,OBJNAM	;MAKE OBJECT FILE NAME
	PJOB	X,		;OF FORM "NAD237.TMP"
	IDIVI	X,^D10		;extract digits
;;	PUSH	S,Y		;save final digit
;;	IDIVI	X,^D10		;extract digit
	LSH	X,6		;move high order digit to tens place
	LSHC	X,6		;move both over another char position
	IOR	W,X		;insert high order digit
	IOR	W,Y		;insert low order digit
;;	POP	S,Y		;restore final digit
;;	IOR	W,Y		;insert final digit
;;	TRO	W,'000'
	TRO	W,'009'
	MOVEM	W,OBJNAM
	MOVE	V,W		;DELETE ANY EXISTING FILES WITH SAME NAMES
	AOS	V
	MOVE	U,OBJNM1
	SETZ	W,
	OPEN	JCH,JSPEC
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
IZ0:	SOS	V		;GET NEXT NAME IN SEQUENCE
	DMOVEM	V,JE
	SETZM	JE+2
	SETZM	JE+3
	ENTER	JCH,JE
	JRST	.+2
	TLO	W,1		;SET FLAG FOR DONE
	SETZM	JE
	RENAME	JCH,JE
	JFCL
	TRNN	V,17		;ALL DONE?
	JRST	IZ2		;YES
	TLNN	W,1		;DONE?
	JRST	IZ0		;NO
IZ2:	DMOVE	W,ESKP		;INITIAL ERROR STACK POINTERS
	DMOVEM	W,ESK
	MOVE	W,[PJS UUO]
	MOVEM	W,41		;SET UUO PUSHJ
	MOVEI	W,CRESC1	;SET REENTER ADDRESS
	MOVEM	W,.JBREN
	MOVE	W,.JBFF
	MOVEM	W,IBF0
	HRRI	W,IINBUF*203+NSB*201+10*203+NPG+NPG*PGSIZ(W)	;IINBUF BFRS FOR INPUT,
;				NSB SIDE BFRS, 10 LISTING BFRS,NPG FOR SWAP MAP, NPG*PGSIZ FOR SWAP SPACE
	HRRZM	W,YEND
	HRRZM	W,YEND1
	SETZM	LOH		;SET LISTING FILE NOT OPEN
	SKIPN	DOTP
	PJS	IZY		;INITIALIZE OPCODES
	PJS	IZPG
	MOVE	U,VER		;NAD VERSION
	PJS	TYP6		;OUTPUT VERSION
;	MOVE NAD VERSION INTO TITLE
	MOVE	X,[POINT 6,VER]
	MOVE	Y,[POINT 7,STDTTL+1,6]
	ILDB	W,X
	ADDI	W,40		;CONVERT FROM SIXBIT TO ASCII
	IDPB	W,Y
	TLNE	X,770000
	JRST	.-4
	JRST	CRIZ

;	Generate the version as a sixbit string. Set radix to decimal
;	to get a decimal radix.
	DEFINE	SIXVER(V,R)<SIXBIT /'V'.'R'/>
	RADIX	10
VER:	SIXVER(\VERSION,\REVISION)
	RADIX	8

IZPG:				;INITIALIZE PAGING AREA
	SETZM	MEMBAS		;ZERO PAGING AREA
	MOVE	W,[XWD MEMBAS,MEMBAS+1]
	BLT	W,EMEM-1
	MOVNI	W,4
	MOVE	X,[ADDI W,MEMBAS]
	MOVEM	X,PGT+4(W)	;MARK THE IN CORE PAGES
	ADDI	X,PGSIZ
	AOJL	W,.-2
	MOVNI	W,NPGD-4
	MOVE	X,[PJS SWAP]
	MOVEM	X,PGT+NPGD(W)
	AOJL	W,.-1		;MARK SWAPPED OUT PAGES
	RETURN

	SUBTTL	LOOKCK - LOOKUP CHECK
;	******************************************************************
;	** LOOKCK - Lookup block checker				**
;	******************************************************************
;	**								**
;	**  Look at the LOOKUP/ENTER block used by the following LOOKUP **
;	**  instruction to determine whether to enable HR or RF license **
;	**  based on the file residing in directory SOURCE or BETATEST. **
;	**  Execute the LOOKUP, disable license (if enabled) and take   **
;	**  the proper return.						**
;	**								**
;	**  Actually there is a list of directories that are permitted  **
;	**  at location SRCTAB for a length of SRCLEN.  Initially there **
;	**  are two entries.						**
;	**  Add directory QSATS to list in NAD %1.7    30-Nov-87 /Carl  **
;	**								**
;	******************************************************************
;	** calling sequence:						**
;	**								**
;	**	PJS	LOOKCK		; call lookup checker		**
;	**	 LOOKUP	CNH,FILE	; instruction to execute	**
;	**	  <error return>	; return here if xct fails	**
;	**	<normal return>		; return here if xct skips	**
;	**								**
;	******************************************************************
;
LOOKCK:	SETOM	NEEDLC		; want license initially
	PUSH	S,W		; save a working register
	PUSH	S,X
	PUSH	S,Y
	HRRZ	W,-3(S)		; address of lookup instruction
	MOVE	W,(W)		; address of lookup block
	MOVE	X,0(W)		; read first word
	MOVE	Y,3(W)		; get ppn from short block
	TLNN	X,-1		; 0,,N means long lookup block
	  MOVE	Y,1(W)		; --get ppn from there--
	JUMPE	Y,LOOKNO	; zero ppn, no username, no license
	TLNE	Y,-1		; 0,,N means username at address N
	  JRST	LOOKNO		; ppn is non-zero, let it slide, [no license]
	MOVE	W,[-SRCLEN,,SRCTAB]
	DMOVE	X,(Y)		; get username X+Y
LOOKLP:	CAME	X,(W)		; check first half
	  JRST	LOOKNX		; no, go try next
	CAMN	Y,1(W)		; check second half
	  JRST	LOOKGO		; it matches both -- set license
LOOKNX:	AOJ	W,		; increment past entry
	AOBJN	W,LOOKLP	; and check next one

LOOKNO:	SETZM	NEEDLC		; tell them -- no license
LOOKGO:	POP	S,Y		; restore working register
	POP	S,X
	POP	S,W
	SKIPE	NEEDLC		; do we need license?
	  PJS	INCLIC		; yes, increment to full
	XCT	@(S)		; execute instruction at return address
	  CAIA			; skip addition if error
	 AOS	(S)		; increment for skip return
	AOS	(S)		; increment past LOOKUP instruction
	SKIPE	NEEDLC		; did we need license?
	  PJS	DECLIC		; yes, decrement license
	RETURN			; do the proper return


INCLIC:	PUSH	S,X		; save register
	MOVE	X,MYLIC		; get entire license
	SETLIC	X,		; set license
	POP	S,X		; restore register
	RETURN			; return to user

DECLIC:	PUSH	S,X		; save register
	HRR	X,MYLIC		; get frame license
	HRL	X,MYLIC		; set process to frame license
	SETLIC	X,		; set licnese
	POP	S,X		; restore register
	RETURN			; return to user

	SUBTTL	GET FILE
;		*********************************************


GF:	TRNN	F,LPASS1+LPASS2	;WILL THERE BE A LISTING?
	JRST	GF1		;NO
	MOVE	W,[DTTLBF,,TTLBF] ;MOVE DEFAULT TITLE TO TITLE BUFFER
	BLT	W,TTLBF+TTLSIZ-1
	PJS	TTLDAT		;PUT TIME AND DATE IN STANDARD TITLE
	MOVE	W,[DSTLBF,,STLBF] ;MOVE DEFAULT SUBTITLE TO SUBTITLE BUFFER
	BLT	W,STLBF+STLSIZ-1
	TRO	F,TTLFND+LSTTTL+FSBTTL
	TRNN	F,LSTDTL	;SHOULD DEFAULT TITLE BE LISTED?
	TRZ	F,LSTTTL	;NO. DON'T LIST TITLE
GF1:	SETZ	W,		;SYLOCK for non proprietary code
	TRNE	F,LSLOCK	;Is listing to be locked out?
	HRLZI	W,SYPROP	;Yes, turn on symbol lock.
	MOVEM	W,SYLOCK	;And save for symbol definitions.
	MOVE	W,PC
	MOVE	X,CURSEG	;RESET SEG BACK TO 0
	MOVEM	W,SEGTAB(X)
	CAMLE	W,SEGTOP(X)	;IS PC>MAX(PC)
	MOVEM	W,SEGTOP(X)	;YES. SET MAX(PC)=PC
	SETZ	X,
	MOVE	W,SEGTAB(X)
	MOVEM	W,PC
	MOVEM	W,PCORG
	MOVE	W,[SEGTAB,,SEGSAV] ;COPY SEGTAB FOR LISTER
	BLT	W,SEGSAV+17
	PJS	GETGMT		;Get a GMT value to use for assembly..
	MOVEM	V,GMTVAL	;..so that CURGMT has same value in both passes
	MOVE	W,RADIX		;SAVE RADIX AT START OF ASSEMLBY FOR LISTER
	MOVEM	W,ARADIX	;SO THAT LISTER STARTS WITH SAME RADIX
	MOVE	W,MM		;SAVE MODULE MASK AT ASSEMBLY START..
	MOVEM	W,AMM		;..SO THAT LISTER STARTS WITH SAME MASK.
	MOVE	W,MODULE	;SAVE MODULE NUMBER AT ASSEMBLY START..
	MOVEM	W,AMODUL	;..SO THAT LISTER STARTS WITH SAME MASK.
	SETOM	LSTMSK
	PJS	INTASM		;INITIALIZE ASSEMBLE
	PJS	SHBEG		;check if shadow is to be constructed
	TRNN	F,LPASS2	;LISTING IN PASS 2?
	TRNN	F,LPASS1	;OR NO LISTING IN PASS 1?
	JRST	GF2		;YES. JUST ASSEMBLE IN PASS 1
	MOVE	W,CHPLN		;USE FULL LINE FOR TEXT
	MOVEM	W,TXTSIZ
	PJS	OLF		;OPEN LISTING FILE
	PJS	LST		;ASSEMBLE W/ LISTING
	PJS	CLF		;CLOSE LISTING FILE
	JRST	GF3
GF2:	PJS	ASSEM		;GO DO FIRST PASS W/O LISTING
GF3:	PJS	CIF		;CLOSE SOURCE FILE
	TLNE	F,ABTASM	;was assembly aborted
	RETURN			;yes. exit
	SETZM	LSTMSK		;INDICATE PASS 2
	TRZN	F,MASCAN	;ARE MACRO ARGS STILL BEING SCANNED?
	JRST	GF4		;no
	TYPE	<$File ended while scanning arguments in macro call. No ) found>
GF4:	TRZN	F,MBSCAN	;is macro body still being scanned?
	JRST	GF5		;no
	TYPE	<$File ended while scanning macro definition. No [ or ] found.>
GF5:	PJS	IFCHK		;CHECK IF "IF" STILL ACTIVE
	PJS	RECHK		;CHECK IF "REPEAT" STILL ACTIVE
	MOVE	M,MODULE
	MOVE	M,LBIT(M)	;REFERENCE LOCAL UNDEFINEDS
	AOSE	UNSW
	PJS	TU		;TYPE UNDEFINEDS UNLESS UN DIRECTIVE RAN
	TYPE	<$End of assembly>
	TRNN	F,LPASS2	;LISTING IN PASS 2?
	JRST	GF30		;NO. GO FINISH ASSEMBLY
	TRO	F,FSBTTL	;IGNORE FIRST SUBTITLE
	TYPE	($Lister working)
	PJS	SHMID		;restore pass 1 symbol table from shadow table
	MOVE	W,PCORG
	MOVEM	W,PC
	MOVE	W,[SEGSAV,,SEGTAB] ;RESTORE INITIAL SEGTAB
	BLT	W,SEGTAB+17
	MOVE	W,AMODUL	;GET MODULE NUMBER AT ASSEMBLY START..
	MOVEM	W,MODULE	;..RESET FOR LISTER SCAN.
	MOVE	W,AMM		;GET MODULE MASK AT ASSEMBLY START..
	MOVEM	W,MM		;..RESET FOR LISTER SCAN.
	MOVE	W,ARADIX	;GET RADIX AT ASSEMBLY START
	MOVEM	W,RADIX		;AND RESET FOR SECOND FILE SCAN
	PJS	INTASM		;INITIALIZE ASSEMBLY
	SETZM	LSPACE		;LISTING BUFFERS NEEDED FOR LISTING
	PJS	OIF		;OPEN INPUT FILE AND START IO
	JUMPE	W,[CPF]		;ABORT IF CAN'T OPEN SECOND TIME
	PJS	OLF		;OPEN LISTING FILE
	MOVE	W,CHPLN		;GET TOTAL CHAR IN LISTING LINE
	SUBI	W,HEXSIZ+10	;REDUCE BY HEX AND PC SIZE
	MOVEM	W,TXTSIZ	;FOR TOTAL TEXT SIZE
	PJS	LST		;GO GET LISTING IN PASS 2
	PJS	CLF		;CLOSE LISTING FILE
	PJS	CIF		;CLOSE SOURCE FILE
	PJS	SHEND		;clear and check shadow table
GF30:	MOVE	W,PC		;GET CURRENT PC
	MOVE	X,CURSEG	;REFERENCE CURRENT SEGMENT
	CAMLE	W,SEGTOP(X)	;IS PC>MAX(PC)?
	MOVEM	W,SEGTOP(X)	;YES. SET MAX(PC)=PC
	RETURN

IFCHK:	MOVEI	M,IFLINE
	SKIPN	IFC		;IF STILL ACTIVE
	RETURN			;NO
	JRST	IRCHK
RECHK:	MOVEI	M,RELINE	;GET POINTER TO STATE INFORMATION
	SKIPE	RPF		;REPEAT FAULT FOUND
	JRST	IRCHK		;YES
	SKIPN	RPPTR		;STILL IN ACTIVE REPEAT
	RETURN			;NO
IRCHK:	TYPE	<$***>
	MOVE	V,(M)		;GET LINE NUMBER
	MOVEI	Y,12		;DECIMAL RADIX
	PJS	TN
	SKIPN	U,1(M)		;TYPE OUT LABEL IF THERE WAS ONE
	JRST	GF10
	PJS	BL3
	PJS	TYP6
	MOVE	V,(M)		;GET ABS LINE #
	SUB	V,2(M)		;TURN INTO LOCAL LINE #
	JUMPE	V,GF10
	OUTCHI	"+"
	MOVEI	Y,12
	PJS	TN		;TYPE OUT OFFSET FROM LABEL
GF10:	TYPE	<$Unmatched >
	CAIE	M,IFLINE
	JRST	GF13
	TYPE	<IF statement>
	RETURN
GF13:	TYPE	<REPEAT statement>
	RETURN

;	ASSEMBLE FILE WITHOUT LISTING.
ASSEM:	MOVEM	S,GFS		;EOF NEEDS TO KNOW WAY OUT
	TRO	F,ASONLY	;SET ONLY ASSEMBLING
	TRZ	F,CREF		;DON'T GET CREF LISTING
ASSEM1:	INCLC
ASSEM5:	SETZM	MACN		;CLEAR MACRO STACK COUNT
	MOVEM	I,LINEI		;SAVE START OF LINE FOR ERRORS
ASSEM2:	PJS	GS
	TLNE	F,ENDFND+ABTASM	;WAS LAST STATEMENT AN "END" or aborted
	JRST	ASSEM3		;YES
	LDB	C,I
	CAIE	C,15		;WAS THE EOS A <CR>?
	JRST	ASSEM4		;NO, IT WAS A ;
	PJS	GCHR		;YES, REMOVE THE <LF>
	SKIPE	LEC
	PJS	TLE
	JRST	ASSEM1
ASSEM3:	SKIPE	LEC		;ANY "END" OR EOF ERRORS?
	PJS	TLE		;YES
	RETURN
ASSEM4:	SKIPGE	MACN		;IS MACRO STACK OK
	SKIPE	LEC		;OR ARE THERE NO PENDING ERRORS
	JRST	ASSEM2		;YES. CONTINUE WITH ASSEMBLY
	JRST	ASSEM5		;NO. CLEAR OLD LINE SAVE

;	INITIALIZE FOR PASS 1 OR PASS 2
INTASM:	HRRI	W,GE1U
	HRRZM	W,GECALL	;ALLOW SOME UNDEFINED SYMBOLS
	SETZM	RPF
	SETZM	RPPTR
	SETZM	IFC
	SETZM	IFT
	SETZM	LC
	SETZM	LEC
	SETZM	LLABEL
	SETZM	UNSW
	SETZM	CURSEG		;START IN SEGMENT 0
	TLZ	F,VBSEEN+EXPRIP+LSCEOL+ENDRPT+NOLIST+UTRUIF+ENDFND+ABTASM
	TRZ	F,MASCAN+MBSCAN
	RETURN
	SUBTTL	GET STATEMENT
;		*********************************************


GS:	MOVEM	S,GFS		;EOF NEEDS TO KNOW WAY OUT
	MOVEM	S,GSSTK		;save stack pointer in case of abort
	MOVE	W,RADIX
	MOVEM	W,TRADIX
	SETZM	GESF
	MOVE	W,MM
	TLO	W,500000
	MOVEM	W,MM1
	SETZM	GSEC
	TLZ	F,NOMACX	;PREPARE TO SET NO MACRO EXPANSION FLAG
	TLNE	F,UTRUIF	;IN UNTRUE "IF"?
	TLO	F,NOMACX	;UNTRUE "IF". SUPPRESS MACRO EXPANSIONS
	PJS	GK
;			BLA  NUM SYM USYM OPR DLIM ILL
	JV	<.+1(U),GS2,GS2E,GSL,GSL,GS1E,GSD,GS1E>

GS1E:	PE	MSFCI,GSF	;OTHERWISE CHR IS ILLEGAL
GS2E:	PE	MSFCI,GSFX	;NUMBER IN LABEL POSITION

GSD:	HLR	W,C
	XCT	.+1(W)

	CPF		;BLANK	;REPORT ASSEMBLER INTERNAL ERROR
	CPF		;TAB	;REPORT ASSEMBLER INTERNAL ERROR
;		  ,     $   (   )    =    [    ]    :   ;  <CR>
;						      <LF> <FF>
	JV	<GS1E,GSF,GS1E,GS1E,GS1E,GS1E,GS1E,GSF,GSF,GSF>

GSL:				;LABEL
	HLR	X,C
	MOVE	X,RBIT(X)
	TRZ	X,1_BLA+1_TAB+1_SEMIC+1_CAR
	IORI	X,-DE(C)
	JUMPE	X,.+2
	PE	MSILT,GSFX	;LABEL DIDNT TERMINATE WITH A LEGAL DELIMITER
	MOVE	W,PC
	MOVEM	W,LABELP	;SAVE LABEL PC FOR GSF OR PEQ
	MOVE	X,LC
	MOVEM	X,LLC
	MOVEM	L,LLABEL
	TLNN	F,UTRUIF	;IF UNTRUE "IF"
	MOVEM	L,LABEL		; THEN DON'T DEFINE LABEL.

GS2:;	GET STATEMENT AFTER LABEL FIELD
	HRLZI	W,500000
	MOVEM	W,MM1		;LIMIT SEARCH TO OPCODES
	PJS	GK
	XCT	.+1(U)

	JRST	GS2		;BLANK, TAB
	PE	MSIOC,GSFX	;NUMBER
	JRST	GS2A		;SYMBOL
	PE	MSUOC,GSFX	;UNDEFINED SYMBOL
	PE	MSIOC,GSF	;OPERATOR
	JRST	GS2D		;DELIMETER
	PE	MSIOC,GSF	;ILLEGAL CHARACTER

GS2D:	HLR	W,C
	MOVE	W,RBIT(W)
	TRNE	W,1_SEMIC+1_CAR+1_COLON
	JRST	GSF
	PE	MSIOC,GSF

GS2A:	MOVE	W,MM
	MOVEM	W,MM1
	LDB	W,[POINT 6,(M),11]
	MOVE	W,PC9V(W)
	MOVEM	W,PCV2
	HLRZM	V,OPCODE
	MOVE	W,PC
	MOVEM	W,@DOTP
	TLNE	F,UTRUIF
	JRST	GS2C		;ASSEMBLING AN UNTRUE IF BLOCK
GS2B:	SKIPE	PCV2
	MOVEM	W,PCL
	PJS	(V)
	JRST	GSF

GS2C:	HRRZ	X,V
	CAIN	X,DIF
	JRST	GS2F
	CAIN	X,DELSE
	JRST	GS2F
	CAIN	X,DEI
	JRST	GS2F
	CAIN	X,DEN
	JRST	GS2F
	JRST	GST		;ASSEMBLY UNTRUE AND NOT AN IF, EI, OR END STATEMENT
GS2F:	TLZ	F,NOMACX	;FORCE MACRO EXPANSIONS EVEN IF UNTRUE IF
	JRST	GS2B

;	STATEMENT FLUSH. FINISH UP STATEMENT PROCESSING AND FLUSH TO EOS.
GSF:	ADD	I,BACKUP	;CAUSE RESCAN OF TERMINATOR. MAY BE CR
GSFX:	SKIPN	W,UCC
	JRST	.+3
	PJS	GERC
	SETZM	UCC
	SKIPN	L,LABEL
	JRST	GST		;IS THERE A LABEL NOT YET DEFINED
	SETZM	LABEL
	MOVE	VS,LABELP
	MOVE	U,MM
	MOVEM	U,MM1
	HRLZ	U,MODULE
	PJS	DY
;	JRST	GST		;SCAN TO END OF STATEMENT AND RETURN TO GS CALLER
GST:	ILDB	C,I
	MOVE	C,CT(C)		;Lookup character type
GSTS:	XCT	GSTX(C)		;Dispatch on character type
	XCT	GSTXD(C)	;Dispatch on character type

GSTX:	CIT	GST		;LOOK FOR MORE INPUT
	REPEAT	DE-1,<JRST GST>
	HLR	C,C		;DELIMITER
	JRST	GST		;VERTICAL BAR
	MEND	GST		;MACRO END
	JRST	GST		;' (CONCATENATION)
	MARG	GST		;MACRO ARGUMENT
	MAE	GST		;MACRO ARG END
GSTXD:	REPEAT	SEMIC,<	JRST	GST>
	RETURN			; <LF> ;
	RETURN			; <FF> <CR>

;	ADVANCE PC AND CHECK FOR REUSED MEMORY
PC2:	PJS	ALIGN2
	ADDI	W,2
	EXCH	W,PC
	CA	H
	LDB	0,W
	MOVEM	W,PCP
	AND	0,LSTMSK
	JUMPE	0,PCV2
	JRST	PCER

PC22:	PJS	ALIGN2
	ADDI	W,4
	EXCH	W,PC
	CA	H
	MOVEM	W,PCP
	LDB	Y,W
	MOVE	W,PC
	SUBI	W,2
	CA	H
	MOVEM	W,PCP1
	LDB	0,W
	IOR	0,Y
	AND	0,LSTMSK
	JUMPE	0,PCV2
PCER:	SKIPE	DSW
	JRST	PCV2
	PE	MSAIUM,ABORT

PC222:	PJS	ALIGN2
	ADDI	W,6
	EXCH	W,PC
	CA	H
	MOVEM	W,PCP
	LDB	VS,W
	MOVE	W,PC
	SUBI	W,4
	CA	H
	MOVEM	W,PCP1
	LDB	OS,W
	MOVE	W,PC
	SUBI	W,2
	CA	H
	MOVEM	W,PCP2
	LDB	0,W
	IOR	0,OS
	IOR	0,VS
	AND	0,LSTMSK
	JUMPE	0,PCV2
	JRST	PCER

PC0:	JRST	PCV2

PC02:	PJS	ALIGN2
	JRST	PCV2

PC04:	PJS	ALIGN4
	JRST	PCV2

ABORT:	MOVE	S,GSSTK		;restore stack pointer
	TLO	F,ABTASM	;report assembly abort
	RETURN

NADAB:	TYPE	<$Type "CONTINUE" to save new NIB or listing file>
	EXIT	1,

NADEX:	PJS	UBID		;UPDATE NIB ID BLOCK
	SETZM	IBRIXP		;set no nib block to update
	SETOM	BFSW		;set no NIB file
	RELEASE	BCH,		;DON'T ZAP NIB FILE
	RELEAS	JCH,		;AVOID ZAPPING TMP FILE
	TRZ	F2,MLTLST
	PJS	CLF		;DON'T ZAP LISTING FILE
	PJS	CFACLS		;Close all command files
	RESET
	HRROI	W,-1
	ZAPCIR	W,
	EXIT

	DEFINE	PC9M (PC9ARG),<PC9CT==1
	IRP	PC9ARG,<PC9ARG'V==PC9CT
	PC9CT==PC9CT+1
	JRST	PC9ARG>>
PC9V:	0
	PC9M	<RR,RR1,LPSR,RI,RI2,BF,BF1,RX,RX0,DBS,DHS,DWS,DBC,DHC,DWC,DAC,DSC,DXC,DEN,DORG,DBND,DSEG>
	PURGE	PC9M

PC9D:	JV	<XIRR,XIRR,XIRR,XIRI1,XIRI2,XIBF,XIBF,XIRX,XIRX>	;DISASSEMBLY TABLE
EPC9D:

ALIGN2:	TRNN	W,1
	RETURN
	AOS	PCL
	AOS	LABELP
	AOS	W,PC
	RETURN

ALIGN4:	TRNN	W,3
	RETURN
	ADDI	W,3
	TRZ	W,3
	MOVEM	W,PCL
	MOVEM	W,LABELP
	MOVEM	W,PC
	RETURN

	SUBTTL	GET EXPRESSION
;		**************************************************


;	GET EXPRESSION TO V. U =0 NORMALLY, 1 IF NUL EXP, 2 IF ONE
;		UNDEFINED SYMBOL FOUND AND GE1U CALLED. AND U =3 IF ILLEGAL EXP

GE1U:	SETOM	GEUOK		;REACH GE THRU HERE TO ALLOW ONE UNDEFINED IN EXPRESSION
	SETZM	UCC
	JRST	GEGO
GE:	SETZM	GEUOK
GEGO:	TLO	F,EXPRIP	;FLAG EXPR EVALUATION IN PROGRESS
	MOVE	W,IBSLP		;initialize backslash pointer
	MOVEM	W,BSLP
	SETZM	LTT
	SETZB	VS,OS		;INITIALIZE VALUE AND OPERATOR STACKS
GEA:	PJS	GK
	MOVE	W,U		;CURRENT TOKEN TYPE
	EXCH	W,LTT
	XCT	.+1(U)

	JV	<GE0(W),GE1(W),GE2(W),GE3(W),GE4(W),GED>
	PE	MSIC,GEF
GE0:	JV	<GEA,GED,GED,GED,GESE0,GESE0>
GE1:	JV	<GEPV,GESE0,GESE0,GESE0,GEPV,GEPV>
GE2:	JV	<GEPV0,GESE0,GESE0,GESE0,GEPV0,GEPV0>
GE3:	JV	<GEPVU0,GESE0,GESE0,GESE0,GEPVU0,GEPVU0>
GE4:	JV	<GEOPU,GEOPNU,GEOPNU,GEOPNU,GEOPU,GEOPU>

GESE:	PE	MSSE,GEF
GESE0:	PE	MSSE,GEF0

GEOPU:	HLRZ	V,C
	CAIN	V,UBSLH		;backslash operator?
	JRST	GEOP2		;yes. go set backslash stack
	CAIGE	V,NU
	JRST	GEOP1
	HRRZI	V,-NB(V)
	CAIGE	V,NU
	JRST	GEOP1
	PE	MSONU,GEF
GEOP2:	AOS	BSLP		;point to next stack entry
	SETOM	@BSLP		;signify in backslash operation
	JRST	GEOP1		;go stack operator

GEOPNU:				;OPERATOR NOT UNARY
	HLRZ	X,C
	CAIGE	X,NU
	PE	MSMUO,GEF
	MOVE	V,X
	PJS	GEES
GEOP1:	MOVEM	V,@OPS		;PUSH OPERATOR INTO OPERATOR STACK
	AOJA	OS,GEA

GEPVU0:	TRNN	F,CREF		;SHOULD CREF BE OUTPUT?
	JRST	GEPVU		;NO
	MOVEI	W,1		;OUTPUT SYMBOL REFERENCE
	PJS	OUTSYM

GEPVU:;	PUSH UNDEFINED VALUE
	SKIPE	@BSLP		;in backslash operation?
	JRST	GEPVU1		;yes. allow all undefined symbols
	AOSE	GEUOK		;SEE IF UNDEFINED ALLOWED IN THIS EXPRESSION
	PE	MSUS,GEPVU2	;replace undefined with zero
GEPVU1:	SETZM	@VALS		;UNDEFINED VALUE IS 0 IF NO SYMBOL TABLE CHAIN
	SETOM	@VALSF		;MARK THIS VALUE AS UNDEFINED
	AOJA	VS,GEA
GEPVU2:	SETZ	V,		;value zero
	JRST	GEPV		;go define

GEPV0:	TRNN	F,CREF		;CREF LISTING?
	JRST	GEPV		;NO
	MOVEI	W,1		;OUTPUT SYMBOL REFERENCE
	PJS	OUTSYM

GEPV:	MOVEM	V,@VALS		;PUSH VALUE ONTO STACK
	SETZM	@VALSF		;MARK VALUE AS DEFINED
	AOJA	VS,GEA

GED:
	HLR	X,C
	JV	<.+1(X),GEDT0,GEDT0,GEDT,GEDDOL,GEDLP,GEDRP,GEEQS,GEDT,GEDT,GEDT,GEDT,GEDT,GEDT>

GEDT0:	IBP	I		;POINT AT BLANK STRING TERMINATOR
GEDT:	MOVEI	V,OT		;SET OPERATOR TERMINATOR TO GRIND OUT THE STACK
	PJS	GEES		;EVALUATE STACK
	JUMPN	OS,[PE MSEI,GEF]	;STACK NOT COMPLETELY EVALUATED
	TLZ	F,EXPRIP	;TURN OFF FLAG, WE'RE DONE ONE WAY OR ANOTHER
	MOVEI	U,2		;U=2 IF LEGAL UNDEFINED EXPRESSION
	SKIPLE	GEUOK		;were there too many undefines?
	JRST	GEDT1		;go exit with value zero
	SKIPN	V,VS		;NUL EXPRESSION IF VALUE STACK EMPTY
	SOJA	U,[RETURN]	;NUL EXPESSION, SET V=0, U=1
	SOSE	VS		;IF VS NOT = 1, THEN STACK NOT PROPERLY EVALUATED.
	PE	MSESE,[RETURN]	;DID NOT END UP WITH EXACTLY ONE VALUE
	MOVE	V,@VALS		;PICK UP LAST STACK VALUE
	AND	U,@VALSF		;LAST VAL STACK FLAG IS -1 IF AN UNDEFINED, OTHERWISE 0
	ANDCM	V,@VALSF
	RETURN
GEDT1:	SETZ	V,		;return value zero
	RETURN

GEDLP:	MOVEI	V,4
	MOVEM	V,LTT		;TREAT RIGHT PAREN LIKE AN OPERATOR.
	MOVEI	V,OLPAR		;LEFT PAREN LEGAL IF LAST TOKEN WAS 0 OR 4.
	JV	<.+1(W),GEOP1,GESE,GESE,GESE,GEOP1,GESE>

GEDRP:	MOVEI	V,ORPAR		;RIGHT PAREN LEGAL IF LAST TOKEN WAS 1,2, OR 3.
	MOVEM	W,LTT		;KEEP OLD LTT. RPARENS ARE NOT PUSHED ONTO STACK.
	XCT	GEDRPX(W)
	JRST	GEA
GEDRPX:	JRST	GESE
	REPEAT	3,<PJS GEES>
	JV	<GESE,GESE>

GEDDOL:	EXCH	W,LTT
;				DONT UPDATE LAST TOKEN TYPE SINCE RADIX
;				SETTER IS NOT PART OF THE EXPRESSION
GEDOL1:	ILDB	V,I
	MOVE	C,CT(V)		;Lookup character type
	XCT	GEDX1(C)	;Dispatch on character type
	JUMPN	V,.+2
	MOVEI	V,20
	MOVEM	V,TRADIX
	JRST	GEA

GEDX1:	CIT	GEDOL1		;LOOK FOR MORE INPUT
	PE	MSRV,GEF
	SUBI	V,60
	SUBI	V,67
	SUBI	V,127
	REPEAT	6,<PE	MSRV,GEF>
	MEND	GEDOL1
	PE	MSRV,GEF
	MARG	GEDOL1
	MAE	GEDOL1

GEEQS:	SKIPE	U,LTT		;IS THIS THE FIRST CHR OF EXPRESSION
	PE	MSIL,GEF	;ILLEGAL LITERAL
	TLZ	F,EXPRIP
	AOJA	U,[RETURN]	;U=1 FOR NUL EXPRESSION

GEES:				;V IS THE STACK OPERATOR
	JUMPE	OS,[RETURN]	;NO OPERATORS ON THE STACK. NOTHING TO EVALUATE
	SOJL	OS,GEESE	;DECREMENT STACK POINTER
	MOVE	M,@OPS		;LOAD LAST OPERATOR
	CAIE	M,OLPAR		;WAS IT A LEFT PAREN
	JRST	GES1		;NO, DONT WORRY ABOUT PAREN RULES
	CAIE	V,ORPAR		;IS CURRENT OPERATOR A RIGHT PAREN
	ADDI	OS,1		;NO, DON'T REMOVE LEFT PAREN
	RETURN
GES1:	ADDI	OS,1		;RESTORE STACK POINTER
	MOVE	0,PREC(V)
	CAMLE	0,PREC(M)
	RETURN			;DONT EVALUATE STACK UNTIL LOWER PRECEDENCE
	SOJL	VS,GEESE	;DECREMENT STACKS TO SIMULATE POP
	SOJL	OS,GEESE
	MOVE	Y,@VALS		;RIGHT HAND VALUE TO Y
	MOVE	W,@VALSF	;-1 IF UNDEFINED VALUE IN Y
	CAIL	M,NU
	SOJL	VS,GEESE	;BINARY OPERATOR. REMOVE LEFT HAND VALUE
	MOVE	X,@VALS		;LEFT HAND VALUE
	SKIPE	@BSLP		;backslash operation?
	JRST	GEBSL1		;yes. don't evaluate expression
	JUMPN	W,GESUR		;RIGHT HAND VALUE UNDEFINED
	SKIPE	@VALSF
	JRST	GESUL		;LEFT HAND VALUE UNDEFINED

	XCT	GESX(M)		;EVALUATE DEFINED VALUES (UNARY OR BINARY)
GES2:	MOVEM	X,@VALS		;PUT COMBINED VALUE BACK INTO STACK
	SETZM	@VALSF
	AOJA	VS,GEES

GEBSL1:	CAIE	M,UBSLH		;is this the actual backslash operator?
	JRST	GEBSL2		;no. just preserve definedness.
	HRRZI	X,1(W)		;value is 1 if defined, 0 otherwise
	SOS	BSLP		;pop backslash stack
	JRST	GES2		;and go stack vaaclue
GEBSL2:	IORM	W,@VALSF	;if one arg undefined, expr is undefined
	AOJA	VS,GEES

GEESE:	POP	S,VS		;ERROR, ABORT
	PE	MSSE,GEF

GESUL:	IORI	M,40		;MARK LEFT AND RIGHT VALUES SWITCHED
	EXCH	X,Y
GESUR:	GFL			;X IS DEFINED, Y IS UNDEFINED, M IS OP.
	JUMPE	Y,.+3		;NO CHAIN YET
	HRRZM	W,2(Y)		;CHAIN TO PREVIOUS ENTRY
	JRST	.+2
	HRL	Y,W
	HRR	Y,W		;Y CONTAINS [XWD <BEGINNING CHAIN POINTER>,<END CHAIN POINTER>]
	HRRM	M,(Y)
	MOVEM	X,1(Y)
	SETZM	2(Y)
	MOVEM	Y,@VALS
	MOVEM	Y,UCC		;UNDEFINED CHAIN POINTER
	SETOM	@VALSF	;MARK THIS VALUE AS UNDEFINED
	AOJA	VS,GEES

GEF0:	ILDB	C,I
	MOVE	C,CT(C)		;Lookup character type
GEF:	HLR	W,C		;SOMETHING BAD HAPPENED - FLUSH REST OF EXPR
	XCT	.+1(C)		;Dispatch on character type
	CIT	GEF0		;LOOK FOR MORE INPUT
	JV	<GEF0,GEF0,GEF0,GEF0,GEF0,GEF0,GEF0,GEFT(W),GEF9,GEF0>
	MEND	GEF0
	JRST	GEF0
	MARG	GEF0
	MAE	GEF0
GEFT:	JV	<GEF9,GEF9,GEF9,GEF9,GEF0,GEF0,GEF0,GEF0,GEF9,GEF9,GEF9,GEF9>
GEF9:	TLZ	F,EXPRIP	;TURN OFF EXPR IN PROGRESS FLAG
	MOVEI	U,3		;GE ERROR RETURN
	SETZ	W,
	EXCH	W,UCC
	JUMPN	W,GERC		;RETURN UNDEFINED CHAIN STORAGE AND EXIT GE
	RETURN

GESX:	SETCM	X,Y
	CPF			;backslash should never get here
	MOVE	X,Y		;UNARY PLUS
	MOVN	X,Y		;UNARY MINUS
	ADD	X,Y		;PLUS
	SUB	X,Y
	PJS	GEMUL
	IDIV	X,Y
	AND	X,Y
	IOR	X,Y
	XOR	X,Y
	LSH	X,(Y)

GEMUL:	PUSH	S,Y
	MUL	X,Y
	SKIPE	X
	LSH	X,43
	IOR	X,Y
	POP	S,Y
	RETURN

GERC:	HLRZ	Y,W		;RETURN UNDEFINED VALUE CHAIN
	HRLZ	W,2(Y)
	DFL	Y		;RETURN CELL POINTED TO BY "Y"
	JUMPN	W,GERC
	RETURN

	SUBTTL	GET TOKEN
;		**************************************************


;	GET TOKEN TYPE TO U.0=BLANKS,1=NUM,2=SYMBOL,3 UND SYM,4=OP,5=DELIM,6=ILLEGAL
;	C = CT TABLE ENTRY FOR TYPES 0, 4, 5, 6
;	V = THE NUMBER VALUE FOR TYPE 1
;	L = THE SYMBOL FOR TYPE 2 OR 3
;	M = THE SYMTAB POINTER FOR TYPE 2, 0 FOR TYPE 3
;	MACROS ARE EXPANDED BEFORE PROCESSING.

GK:	ILDB	C,I
	MOVE	C,CT(C)		;Lookup character type
	XCT	GKX(C)		;Dispatch on character type
	RETURN
GKX:	CIT	GK		;LOOK FOR MORE INPUT
	MOVEI	U,6		;ILLEGAL CHARACTER
;		 DIG A-F a-f G-Z g-z  .
	JV	<GKN,GKY,GKY,GKY,GKY,GKY>
	MOVEI	U,4		;OPERATOR
	JV	<GKD,GKD>	;DELIMITER, VERTICAL BAR
	MEND	GK		;MACRO END
	MOVEI	U,6		;' (ILLEGAL)
	MARG	GK		;MACRO ARGUMENT
	MAE	GK		;MACRO ARG END

GKE:	;VERTICAL BAR - EVAL EXPRESSION, INSERT TEXT INTO SYMBOL
	TLOE	F,VBSEEN	;HAVE WE ALREADY SEEN ONE?
	JRST	GKY5		;YES - THIS IS TERMINATING QUOTE
	HRRZ	C,(S)		;GET CALLERS ADDRESS
	CAIE	C,GEA+1		;IS CALLER GE?
	SETZB	VS,OS		;INIT STACK POINTERS IF NOT CALLED FROM GE

	PUSH	S,L		;SAVE SOME THINGS
	PUSH	S,W
	PUSH	S,OPS
	PUSH	S,OS
	ADDM	OS,OPS		;UPDATE STACK POINTERS
	PUSH	S,VALS
	PUSH	S,VALSF
	PUSH	S,VS
	ADDM	VS,VALS
	ADDM	VS,VALSF
	PUSH	S,IBSLP
	PUSH	S,BSLP
	AOS	C,BSLP		;increment backslash pointer
	MOVEM	C,IBSLP		;and set as new value
	SETZM	@BSLP		;start stack as not in backslash
	PUSH	S,GEUOK
	PUSH	S,UCC
	PUSH	S,MM1		;INCASE SYMBOL IN OPCODE FIELD
	MOVE	V,MM		; THEN USE NONOPCODE SYMBOLS
	MOVEM	V,MM1
	PUSH	S,F		;save proprietary token indicator
	PJS	GE		;GET EXPRESSION VALUE
	TLZ	F,VBSEEN	;TURN OFF VERTICAL BAR FLAG
	POP	S,W		;restore proprietary token
	TRZ	F,PRPTOK	;clear value from bar evaluation
	TRNE	W,PRPTOK	;was old value set?
	TRO	F,PRPTOK	;yes, set as current value
	POP	S,MM1
	POP	S,UCC
	POP	S,GEUOK
	POP	S,BSLP
	POP	S,IBSLP
	POP	S,VS
	POP	S,VALSF
	POP	S,VALS
	POP	S,OS
	POP	S,OPS
	POP	S,W
	POP	S,L
	JUMPN	U,[ PE MSUE,[RETURN]] ;ARG MUST BE DEFINED
	PUSH	S,[0]		;CONVERT VALUE TO STRING
GKE1:	IDIV	V,TRADIX
	PUSH	S,HEX6(U)	;FORM SIXBIT STRING
	JUMPN	V,GKE1
GKE2:	POP	S,V		;GET NEXT DIGIT
	JUMPE	V,GKY2		;0 IS TERMINATOR
	IDPB	V,W		;ADD CHAR TO STRING
	TLNE	W,770000	;ROOM FOR MORE CHARS?
	JRST	GKE2		;GET NEXT CHR
GKE3:	POP	S,V		;L IS FULL. FLUSH EXTRA CHARS
	JUMPN	V,GKE3
	JRST	GKY2

GKD:;	DELIMITER OR BLANK OR TAB FIELD
	TLNN	C,-2		;CHECK FOR BLANK AND TAB (TYPES 0 AND 1)
	JRST	GKD1
	MOVEI	U,5
	RETURN
GKD1:	PJS	FBT		;FLUSH BLANKS AND TABS
	SETZ	U,
	MOVE	C,CT+40		;SET BLANK AS TERMINATOR
	RETURN

GKN:	SETZ	V,		;BUILD NUMBER INTO V
	MOVE	X,TRADIX	;Get the radix for this moment
GKN1:	HLRZ	W,C		;Get the normalized value of the character
	SUB	W,GKNN-2(C)	;Convert the character to a number
	CAML	W,X		;Compare with the radix
	PE	MSRV,.+1	;Treat digit >= the radix as an error
	MUL	V,X		;Multiply the accumulator by the radix
	SKIPE	V		;Check for zero result
	LSH	V,43		;Shift out all but LSB of result
	IOR	V,U		;LOGICAL MULTIPLY(replace sign bit by MSB)
	ADD	V,W		;Add current number to accumulator
GKN2:	ILDB	C,I		;Get next character
	MOVE	C,CT(C)		;Lookup character type
	XCT	.+1(C)		;Dispatch on character type
	CIT	GKN2		;GET MORE CHARACTERS
;		 CRAP DIG  A-F  a-f  G-Z  g-z   .    OPR DELIM  |
	JV	<GKN9,GKN1,GKN1,GKN1,GKN9,GKN9,GKN9,GKN9,GKN9,GKN9>
	MEND	GKN2		;MACRO END
	JRST	GKN9		;' (CONCATINATION)
	MARG	GKN2		;MACRO ARGUMENT
	MAE	GKN2		;MACRO ARG END
GKN9:	MOVEI	U,1
	ADD	I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
	RETURN
GKNN:	EXP	60,67,127

GKY:				;GET A SYMBOL FROM STREAM AND LOOKUP VALUE
	TRZ	F,PRPTOK	;save whether token was in proprietary code
	TRNE	F,PRPCOD	;  at start of token scan
	TRO	F,PRPTOK
	SETZ	L,		;BUILD SIXBIT INTO L
	MOVE	W,[POINT 6,L]	; POINT TO LEFT OF L
	HLR	V,C
	XCT	GKYX1(C)
GKY1:	IDPB	V,W		;PUT A SIXBIT BYTE IN W
GKY2:	ILDB	V,I		;READ FROM INPUT STREAM
	MOVE	C,CT(V)		;PICK UP CHR PROPERTIES
	XCT	GKYX1(C)	;CONVERT TO SIXBIT MAYBE
	TLNE	W,770000
	JRST	GKY1		;GET NXT CHR
	JRST	GKY2		;L IS FULL. FLUSH EXTRA CHRS.

GKYX1:	CIT	GKY2		;GET MORE CHARACTERS
	JRST	GKY5		;GARBAGE CHARACTERS
	SUBI	V,40		;DIGIT
	SUBI	V,40		;A-F
	ANDI	V,77		;a-f
	SUBI	V,40		;G-Z
	ANDI	V,77		;g-z
	MOVEI	V,'.'		; .
;		  OPR DELIM  |
	JV	<GKY5,GKY5,GKE>
	MEND	GKY2		;MACRO END
	JRST	GKY2		;' (CONCATINATION)
	MARG	GKY2		;MACRO ARGUMENT
	MAE	GKY2		;MACRO ARG END

GKY5:	ADD	I,BACKUP	;SYMBOL IN W
	PJS	FY
	MOVEI	U,2
	JUMPG	M,GKM0
	DMOVEM	L,UL
	MOVEM	X,UX
	AOJA	U,[RETURN]

GKM0:	TLNN	M,75		;IS IT A MACRO? (MODULE 2)
	TLNN	M,2
	RETURN			;NO, RETURN
	TLNE	F,NOMACX	;SHOULD MACRO EXPANSIONS BE SUPPRESSED
	RETURN			;YES. EXIT WITH SYMBOL NAME
	PJS	MACSET		;SET UP MACRO AND ARGS
	JRST	GK

;SET UP MACRO CALL, EAT ARGS, ETC.
MACSET:	TRNN	F,CREF		;CREF LISTING?
	JRST	MACST0		;NO
	MOVEI	W,5		;OUTPUT MACRO REFERENCE
	PJS	OUTSYM
MACST0:	LDB	Y,[POINT 9,2(M),35]	;GET NUMBER OF ARGUMENTS
	HRRI	Y,1(Y)		; COMPUTE NARGS+1
	MOVN	L,Y		; FORM POINTER TO STORE BYTE
	HRL	L,L		; POINTER FOR EACH ARG.
	HRRI	L,MACBUF	; POINTER = -(NARGS+1),,ARGADDR-1
	MOVEI	X,MWMAX		; Number of words in macro buffer
	SUB	X,Y		; Less words for argument pointers
	IMULI	X,5		; Compute number of characters for text
	MOVEM	X,MACCNT	; Save for insertion of characters
	ADDI	Y,MACBUF	; Construct byte pointer for first arg
	HRLI	Y,(POINT 7,0)
	SETZ	U,		;ZERO PAREN COUNTER
	SKIPN	MACN		;IS THIS A FIRST LEVEL EXPANSION
	MOVEM	I,MACI		;YES. SAVE "I" FOR ERROR MESSAGE TYPEOUT
	SKIPL	MACN		;IS EXPANSION FROM START OF LINE STILL ON
	AOS	MACN		;YES. KEEP TRACK OF EXPANSION
	PJS	GCHR		;GET NEXT CHR
	CAIE	C,"("		;MUST BE LPAR IF ANY ARGS
	JRST	[ADD I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
		JRST GKM3]
	TRO	F,MASCAN	;set scanning macro argument list
GKM9:	AOBJP	L,GKM2		;ANYMORE ARGS TO GET?
	MOVEM	Y,(L)		;YES. SAVE ADDRESS OF ARG START
	SUBI	Y,MACBUF	; Convert to relative to start of block
	EXCH	Y,(L)		; And save relative address instead
GKM:	ILDB	C,I		;PROCESS ARGS
	MOVE	V,CT(C)		;Lookup character type
	XCT	GKM1(V)		;STUFF OR SWITCH TO PROCESSING ROUTINE
	JRST	GKM

GKM1:	CIT	GKM		;GET MORE CHARACTERS
	REPEAT	DE-1,< PJS PUTMCH>	;NON-DELIMITER
	JRST	GKMD		;DELIMITER
	PJS	PUTMCH		;NON-DELIMITER
	MEND	GKM		;MACRO END
	JRST	GKMLIT		;' (LITERAL CHARACTER FLAG)
	MARG	GKM		;MACRO ARGUMENT
	MAE	GKM		;MACRO ARG END

GKMD:	CAIN	C,")"		;RIGHT PAREN MEANS END OF ARG PROCESSING
	SOJL	U,GKMDUN	;FINISH CALL IF OUTER PAREN
	CAIN	C,"("		;CHECK FOR NEW ARGUMENT LIST
	AOJ	U,		;COUNT ITS PAREN
	CAIN	C,","		;COMMA DELIMITS ARGS
	JUMPE	U,GKMD1		;END ARG IF NOT IN PARENS
	PJS	PUTMCH		;TREAT OTHER DELIMITERS AS NORMAL CHARS
	JRST	GKM

GKMD1:	MOVEI	C,2		;TERMINATE CURRENT ARG
	PJS	PUTMCH
	JRST	GKM9

GKMLIT:	PJS	GCHR		;TAKE ONE CHARACTER LITERALLY
	PJS	PUTMCH
	JRST	GKM

GKM2:	PJS	GCHR		;IGNORE REST OF ARGUMENT STRING
	CAIN	C,")"		;UNTIL FIRST RIGHT PAREN
	SOJL	U,GKM5		;EXIT IF OUTER PAREN
	CAIN	C,"("		;COUNT OPEN PARENS
	AOJ	U,
	CAIN	C,"`"		;IF LITERAL CHARACTER
	PJS	GCHR		;THEN ACCEPT ONE CHAR WITHOUT ")" CHECK
	JRST	GKM2

GKMDUN:	MOVEI	C,2		;TERMINATE CURRENT ARG
	PJS	PUTMCH
GKM3:	AOBJP	L,GKM5		;ANY ARGS NOT SET
	MOVEM	Y,(L)		;YES. SET THEM ALL TO NULL STRING.
	SUBI	Y,MACBUF	; Convert to relative to start of block
	EXCH	Y,(L)		; And save relative address instead
	JRST	GKMDUN
GKM5:	TRZ	F,MASCAN	;clear scanning for macro arguments
	SKIPGE	MACCNT		; Is macro argument text too big?
	SETZM	MACCNT		; Yes. Ignore excess (kludge!)
	PJS	FMACD		; Move argument strings to free storage
	MOVE	W,MACTXT	;GET START OF CALL BLOCK
	MOVE	Y,MCHCNT	;GET SIZE OF BLOCK
	HRLM	Y,(W)		;STORE SIZE IN BLOCK HEADER
	EXCH	W,MACSTK	;SET STACK TO POINT TO NEW BLOCK
	HRRM	W,@MACSTK	;SET NEW BLOCK TO POINT TO REST OF STACK
	PJS	SAVIP		;SAVE TEXT PTR FOR RETURN
	MOVE	W,IPSTK		;pointer to top stack entry
	AOS	Y,MACVER	;get next invocation number
	EXCH	Y,MACCUR	;set as current macro invocation
	TRZE	F,PRPCOD	;clear proprietary setting, and test to save
	TLO	Y,400000	;use sign bit to save old setting
	MOVEM	Y,2(W)		;save previous invocation number
	MOVE	Y,(M)		;get word zero of macro definition
	TLNE	Y,SYPRPM	;was macro defined in proprietary code?
	TRO	F,PRPCOD	;yes, still in proprietary code
	TRNE	F,SUPLST+ASONLY ;SHOULD LISTING BE SUPPRESSED?
	JRST	GKM4		;YES.
	IBP	I		;SAVE CURRENT STATEMENT INCLUDING MACRO
	PJS	LSVLNE		; CALL. SET BYTE POINTER TO AFTER ")"
	ADD	I,BACKUP	;RESTORE BYTE POINTER TO ")"
	SKIPN	LSTMSK		;IF LISTING IN PASS 1,SUPPRESS EXPANSION
	TLNE	F,LSX+NOLIST	;SHOULD MACRO EXPANSION BE SUPPRESSED?
	TRO	F,SUPLST	;YES.
	TRNN	F,SUPLST	;SHOULD MACRO EXPANSION BE SUPPRESSED?
	SOSGE	LSVCNT		;ANY ROOM IN BUFFER?
	JRST	GKM4		;NO
	MOVEI	C,"["		;BRACKET MACRO BODY IN LISTING
	IDPB	C,LSVP
GKM4:	HLRZ	I,2(M)		; Get pointer to macro text
	HRLI	I,(POINT 7,0)	; and construct byte pointer
	MOVEM	I,LISTI		;AND SAVE IN CASE THIS NEEDS TO BE SAVED
	RETURN

;	END OF TOKEN GETTER
	SUBTTL	SYMBOL TABLE PROCESSORS
;		**************************************************


;	Symbol Table. There are HASHSZ lists that chain symbol table entries.
;	The head of the appropriate list is found by a simple hash of the
;	sixbit key. There are 3 words per entry.
;	Word 0 left
;	  Bit 0 (SYUNDF)	: 1 if symbol is undefined
;	  Bit 1	(SYSHNU)	: 1 if symbol was not defined (only in shadow table)
;	  Bit 2	(SYPROP)	: 1 if symbol came from proprietary file
;	  Bit 3	(SYPRPM)	: 1 if macro came from proprietary file
;	  Bits 4-5	: unused
;	  Bits 6-11	: opcode type, only for opcodes, module 0
;	  Bits 12-17	: module #. 0 for opcodes, 1 for global, 2 for macros,
;			:	3 unused, 4-37 for user (4 is MAIN)
;	Word 0 right	List chain address or 0 if end of chain
;	Word 1		36 bits of sixbit ASCII
;	Word 2		Value word

;	Undefined symbols that are entered in the table have bit 0 word 0 on
;	and the value word is borrowed until the value is known to point
;	to a chain that is waiting for the value. The chain may go through
;	node memory and symbol table space. If the chain goes through
;	symbol table space the chain is a compute chain that stores opcodes
;	and values that must be combined with the symbol value to create
;	an expression value. Word 2 contains zeros in the left half when
;	it points to a compute chain. When word 2 points to user memory it
;	contains a 20 bit byte pointer and the sign bit is on. Chains through
;	memory may be spliced to a compute chain that comes back to memory
;	and later goes into another compute chain. When UC unravels compute
;	chains it accumulates an expression value and then deposits into node
;	memory according to the node byte address at the
;	end of the compute chain and then resets the accumulated value to the
;	symbol value before proceeding further through the chaining.
;	A compute chain entry looks like this:
;	Word 0. All zeros except for a right adjusted five bit operation code
;		preceded by a bit that if on means do non communative operation
;		with the arguments in reverse order.
;	Word 1. The right hand value for the 36 bit operation. The value that
;		is delivered to this entry in the chain is the left hand value.
;	Word 2. A symbol table address to continue compute chain or a byte
;		address and the sign bit on if the end of the compute chain.
;	Values are chained though memory when the chain is unraveled by DY
;	and UC. The chains are created by SPLICE which splices a new value
;	destination into an undefined chain.
;	The chaining through memory uses PDP 10 halfwords to chain through
;	node memory halfwords. Before a halfword has its defined value in
;	it, it may contain a 15 bit relative to PC backword chain element
;	or a 15 bit symbol table index. These chaining addresses are left
;	adjusted into an 18 bit PDP 10 halfword that will ultimately contain
;	a 16 bit value. There is a bit on to the right of the 15 bits if the 15
;	bits is node memory backward chaining. The 2 other bits tell the chain
;	unraveler the mode in which the value should be stored (immediate value,
;	RX1 or RX2 value, etc.). Undefined chains end with a 0 pointer.

;DELETE SYMBOL (SIXBIT IN L)
DELSYM:	PJS	FY		;see if symbol defined
	JUMPE	M,DELSY1	;not there
	TRNE	F,MKSHAD	;if making shadow table, forget its a macro
	SETZ	W,		;dont tell RY its a macro
	PJS	RY		;remove from symbol table
	TRNE	F,MKSHAD	;shadow table for pass 2 needed?
	PJS	SHOLD		;yes. enter old value before delete
DELSY1:	RETURN

;	Remove symbol from symbol table.
;	Called with M set to entry to remove, X set to previous entry and
;	W set to module bit mask. Destroys W and V.
;	Note the input to RY is the output of FY for a symbol in the table.
;

RY:	TLNN	W,100000	;IS SYMBOL TO BE DELETED FROM MODULE 2 (A MACRO)
	JRST	RY1		;NO
	HLRZ	W,2(M)		;GET ADDRESS OF TEXT
	LDB	V,MBSPNT	;GET NUMBER OF WORDS TO RETURN
	PJS	REMAC		;AND RETURN TO FREE LIST
RY1:	JUMPL	M,RY5		;CHECK FOR UNDEFINED SYMBOL
RY2:	HRRZ	V,(M)		;GOT IT, PICK UP CHAIN POINTER
	HRRM	V,(X)		;SPLICE THIS ENTRY OUT OF THE LIST
	HRRZ	W,M		;clear flag bits in M
	DFL	W		;RETURN ENTRY CUT OUT TO FREE LIST
	RETURN
RY5:	SKIPN	2(M)		;ANY UNRESOLVED REFERENCES
	JRST	RY2		;NO, ALLRIGHT TO DELETE SYMBOL
	SETZ	VS,		;SET UP A ZERO SYMBOL
	PUSH	S,X		;SAVE REG X
	PJS	UC		;UNCHAIN THIS SYMBOL
	PE	MSKILL,RY6
RY6:	POP	S,X 		;RESTORE X
	JRST	RY2

;	Find symbol in L and whose module is in module mask MM1.
;	Return M=0 if not in table, otherwise set M to address of entry.
;	Always return X as address of previous entry.
;	If found return W as module mask bit and V as value.
;	Also set left of M to left of first word of entry.

FY:	MOVM	W,L
	IDIVI	W,HASHSZ		;Divide by size of list head array
	HRRI	M,YHASHT(X)	;Use remainder to make address of list head
FY1:	HRRZ	X,M		;save previous pointer
	HRRZ	M,(M)		;Get next symbol entry
	JUMPE	M,FY2		;Return if no symbol found
	CAME	L,1(M)		;Is this a match on the symbol?
	JRST	FY1		;No, continue search
	LDB	W,[POINT 6,0(M),17]	;Yes, load up module number
	MOVE	W,LBIT(W)
	TDNN	W,MM1		;Is this the one we are looking for?
	JRST	FY1		;No, continue searching
	HLL	M,(M)		;Yes, load up the flag bits
	MOVE	V,2(M)		;Load up the value
FY2:	RETURN


;	FCS	FIND CLOSE SYMBOL TO V.
;		 PUT DIF IN U. SYM TAB PTR TO W.
;		 CALLER PUTS MODULE FILTER IN M.
FCS:	BAR	<X,Y,L,VS>	;SAVE REGISTERS OVER CALL
	MOVE	U,FCSBND	;MAXIMUM DIFFERENCE FOR SYMBOL TO BE CONSIDERED CLOSE
	SETO	W,		;INITIALIZE TO UNDEFINED
	MOVE	VS,FCSMIN	
	CAMN	M,LBIT		;IS IT AN OPERATOR?
	MOVEI	VS,400		;YES. ALLOW OPERATORS ONLY >=400
	CAMGE	V,VS
	RETURN
	MOVNI	Y,HASHSZ	;FORM POINTER TO HASH TABLE
	JRST	FC4		;START SEARCH
FC1:	MOVE	VS,2(X)		;Get symbol value
	CAMN	M,LBIT		;Test for opcode mode
	HLRZ	VS,2(X)		;Opcode value is a halfword
	SUB	VS,V		;Subtract search value from symbol value
	MOVN	VS,VS		;Form search value minus symbol value
	JUMPL	VS,FC2		;Continue search if search value less than symbol value
	CAML	VS,U		;Compare difference with limit
	JRST	FC2		;Continue search if difference too big
	MOVEI	L,2(X)		;Get address of value
	CAMN	L,DOTP
	JRST	FC2
	LDB	L,[POINT 6,(X),17] ;Extract the module #
	TDNN	M,LBIT(L)	;Compare with requested #
	JRST	FC2		;Continue search if wrong module
	MOVE	L,(X)		;Get word 0 of entry
	TLNE	L,SYPROP	;Is symbol in proprietary code?
	JRST	FC2		;Yes, don't print in debug mode.
;	GOOD SYMBOL FOUND
	MOVE	U,VS		;Save difference
	MOVE	W,X		;Save pointer
	JUMPE	U,[RETURN]	;Zero difference is the end of the search
FC2:	HRRZ	X,(X)		;Get next symbol table entry
FC3:	JUMPG	X,FC1		;Continue if not end of chain
	AOJGE	Y,[RETURN]	;Increment pointer to next hash table entry
FC4:	HRRZ	X,EYH(Y)	;Get Symbol table entry from hash table
	JRST	FC3

;	DEFINE A MACRO OR OPCODE. CALLED WITH NAME IN "L" AND VALUE IN
;	"VS".

DOM:	TRNN	F,CREF		;CREF LISTING?
	JRST	DOM0		;NO
	MOVEI	W,6		;OUTPUT MACRO DEFINITION
	PJS	OUTSYM
DOM0:	TRNE	F,PRPCOD	;is definition in proprietary code?
	TLO	U,SYPRPM	;yes, mark macro as proprietary.
	HRLZI	W,500000	;ONLY REDEFINE AN OPCODE OF MACRO
	MOVEM	W,MM1
	PJS	FY		;IS SYMBOL ALREADY DEFINED
	JUMPE	M,DOM2		;NO. GO MAKE NEW ENTRY
	JUMPL	W,DOM1		;JUMP IF OPCODE
	HLRZ	W,2(M)		;IF MACRO, GET TEXT ADDRESS
	LDB	V,MBSPNT	;GET NUMBER OF WORDS TO RETURN
	PJS	REMAC		;AND RETURN TO FREE LIST
DOM1:	TRNN	F,MKSHAD	;shadow needed?
	JRST	DOM3		;no
	PJS	SHOLD		;shadow old value.
	MOVE	W,M		;get old module number
	XOR	W,U		;compare with new
	TLNE	W,77		;are they different (has it changed) ?
	PJS	SHNEW		;yes. shadow new symbol
DOM3:	HLLM	U,(M)		;SET NEW MODULE NUMBER
	MOVEM	VS,2(M)		;STORE NEW VALUE WORD
	RETURN
DOM2:	MOVE	V,VS		;PASS VALUE WORD IN "V"
	PJS	MY		;MAKE NEW ENTRY
	RETURN
MBSPNT:	POINT	9,2(M),26	;POINTS TO MACRO BLOCK SIZE

; Remove block addressed by W from list. Uses registers X and Y.
; Leaves W unchanged
;
REMBLK: HRR	X,(W)		; Get block after block W
	HLR	Y,(W)		; Get block before block W
	HRRM	X,(Y)		; Have block before W point to block after
	HRLM	Y,(X)		; Have block after W point to block before
	RETURN
;
; Return Macro block addressed by W to list. List is sorted by size.
;
REMAC:	HRRZ	W,W		; Clear left half of W
	CAIE	V,1		; Is it a single cell?
	JRST	REMAC1		; No, it is larger. Save on Macro free list
	DFL	W		; Yes, return to single cell free list.
	RETURN
REMAC1:	PUSH	S,X		; Save registers X and Y
	PUSH	S,Y
	MOVEM	V,1(W)		; Get size of entry to return
	MOVEI	Y,MACFRE	; Get address of list header
REMAC2: HRR	Y,(Y)		; Get address of next list entry
	CAMGE	V,1(Y)		; If block is bigger, it goes before
	JRST	REMAC2		; Block smaller, try next
	HRRM	Y,(W)		; Have block point to after block
	HLR	X,(Y)		; Get before block
	HRLM	X,(W)		; Have block point to before block
	HRLM	W,(Y)		; Have after block point to returned block
	HRRM	W,(X)		; Have before block point to returned block
	POP	S,Y		; Restore registers Y and X
	POP	S,X
	RETURN

;	Make symbol entry.
;	Called with L set to name, V set to value, U set to left half flags
;	and X set to address of previous entry where new is to go.
;	Return M set to address of new entry, X and W destroyed.

MY:	GFL
	MOVE	M,W		;put address of new entry in M
	HRRZ	W,(X)		;put address of next entry in W
	HLL	W,U		;construct first word of new entry in W
	MOVEM	W,(M)		;store first word of new entry
	MOVEM	L,1(M)		;store name in second word
	MOVEM	V,2(M)		;store value in third word
	HRRM	M,(X)		;have previous point to new entry
	TRNE	F,MKSHAD	;shadow table in use?
	PJS	SHNEW		;yes. shadow new symbol
	RETURN


;	DY	define a symbol
;	Put symbol definition into the symbol table.  Handle forward references
;	to the symbol by calling UC to unchain the mess.
;	ARGUMENTS:	L HAS SIXBIT SYMBOL.
;			VS HAS NEW VALUE.
DY:	TRNN	F,CREF		;CREF LISTING?
	JRST	DY0		;NO
	MOVEI	W,1		;OUTPUT SYMBOL DEFINITION
	PJS	OUTSYM
	MOVEI	W,2		;mark as local
	PJS	LOCN
DY0:	PJS	FY		;Does the symbol already exist?
	JUMPE	M,DY1		;No, go make new one
	TRNE	F,MKSHAD	;Yes, shadow in use?
	PJS	SHOLD		;Yes, shadow old value
	IOR	M,SYLOCK	;Insert symbol lock in left half of M
	HLLM	M,(M)		;and store bak in entry
	JUMPL	M,UC		;SYMBOL HAS UNDEFINED FLAG ON
	MOVEM	VS,2(M)
	RETURN
DY1:	MOVE	V,VS
	IOR	U,SYLOCK	;Set symbol lock for new symbol
	PJS	MY		;Make an entry for the symbol
	RETURN			;ENTER SYMBOL INTO TABLE

;	UC	Handle undefined symbol forward reference chain
UC:	TLZ	M,SYUNDF	;Turn off undefined bit
	HLLM	M,(M)		;and store back in entry
	MOVE	W,VS
	MOVE	V,VS		;V IS TEMPORARY VALUE. VS IS SYMBOL VALUE.
	EXCH	W,2(M)
UC1:	JUMPE	W,UC9
	JUMPG	W,UCY
	HRRZ	Y,W		;Save pointer to memory reference cell
	MOVE	W,1(Y)		;Get location in engine memory for fixup
	MOVE	OS,W		;..and save the location
	CA	K
	MOVE	X,(Y)		;Get type of reference
	JV	<.+1(X),UCH,UCW,UCRX,UCRX3>
UCW:	CAML	V,[-1_40]
	CAML	V,[1_40]
	PJS	UCER1
	ROT	V,-20
	DPB	V,W		;STORE LEFT BYTE
	MOVE	W,OS
	ADDI	W,2
	CA	H
	ROT	V,20
	DPB	V,W
	JRST	UCH1
UCH:				;STORE A HALFWORD INTO USER MEMORY
	CAML	V,[-1_20]
	CAIL	V,1_20
	PJS	UCER1
	DPB	V,W		;DEPOSIT HALFWORD
UCH1:	MOVE	V,VS
	MOVE	W,Y		;Restore pointer to reference cell
	JRST	UCY2		;Continue with rest of chain

UCRX0:	PUSH	S,0
	MOVE	0,OS
	SUBI	0,2
	TLZ	0,400000
	PJS	QPC
	POP	S,0
	SETZ	V,
UCRX:				;PUT DISPLACEMENT FIELD INTO RX1 OR RX2 INSTRUCTION
	TDNN	V,[-1_16]
	JRST	UCRX1
	SUB	V,OS		;RELATIVE TO P DISP
	ADD	V,[1_43-2]	;CORRECT FOR UNINCREMENTED PC AND SIGN BIT OF OS
	CAML	V,[-40000]	;IS IT TOO FAR BEHIND PC
	CAIL	V,40000		;IS IT TOO FAR BEYOND PC
	JRST	UCRX0
	IORI	V,100000	;TELL CPU TO USE RX2 ADDRESSING
UCRX1:	DPB	V,W
	JRST	UCH1

UCRX30:	PUSH	S,0
	MOVE	0,OS
	SUBI	0,4
	TLZ	0,400000
	PJS	QPC
	POP	S,0
	SETZ	V,
UCRX3:				;PUT 3 BYTE ADRS INTO RX3 INSTRUCTION
	TLNE	V,777700
	JRST	UCRX30
	DPB	V,W		;MIDDLE AND RIGHT BYTE
	MOVE	W,OS
	SUBI	W,1
	CA
	ROT	V,-20
	DPB	V,W		;LEFT BYTE
	JRST	UCH1

UCER1:	PUSH	S,0
	MOVE	0,OS
	TLZ	0,400000
	PJS	QPC
	SETZ	V,
	POP	S,0
	RETURN


UCY:	MOVE	X,1(W)
	MOVE	Y,(W)
	ANDI	Y,77
	TRZN	Y,40
	EXCH	X,V
	XCT	UCX(Y)
UCY2:	HRRZ	Y,W
	MOVE	W,2(W)
	DFL	Y		;RETURN CELL "Y" TO FREE LIST
	JRST	UC1

UCBF:	MOVE	Y,2(W)		;Point to cell with Engine address
	MOVE	0,1(Y)		;Get Engine address
	TLZ	0,400000	;P COUNTER
	SUB	X,0		;RELATIVE TO P DIFFERENCE
	TRNN	V,400
	MOVN	X,X		;BACKWARD OR FORWARD SHORT JUMP
	ROT	X,-1		;HALFWORD COUNTER
	TDZN	X,[-20]
	JRST	UCBF1		;MUST BE FOUR BITS
	PJS	QPC		;QUE PC IN TABLE FOR ERROR OUTPUT IN TLE9A
	SETZB	V,X
UCBF1:	IOR	V,X		;BUILD INSTRUCTION
	JRST	UCY2

UCX:	SETCM	V,X
	CPF			;CAN NEVER BE IN UNDEFINED EXPRESSION
	MOVE	V,X		;UNARY PLUS
	MOVN	V,X		;UNARY MINUS
	ADD	V,X		;PLUS
	SUB	V,X
	PJS	UCMUL
	IDIV	V,X
	AND	V,X
	IOR	V,X
	XOR	V,X
	LSH	V,(X)
	JRST	UCBF

UCMUL:	PUSH	S,U
	MUL	V,X
	SKIPE	V
	LSH	V,43
	IOR	V,U
	POP	S,U
	RETURN

UC9:	SKIPN	UCERC
	RETURN
	PE	MSSD,[RETURN]

;	PUT ANOTHER ELEMENT ON THE CHAIN THAT WILL BE
;	FILLED LATER WHEN THE SYMBOL IS DEFINED. Y=SPECIAL COMPUTE CHAIN,
;	DESTINATION FOR VALUE PTR IN VS. U RIGHT IS MEMORY INSTRUCTION TYPE (0-3).

SPLICE:	SKIPGE	M,UM		;M=0. NO SYMBOL TABLE ENTRY FOR THIS UNDEFINED SYMBOL.
	JRST	SC1		;SPLICE INTO CHAIN
	SKIPE	M
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	PUSH	S,U
	HRL	U,MODULE	;DEFINE SYMBOL
	TLO	U,SYUNDF
	MOVE	X,UX		;get previous address from FY for MY
	MOVE	L,UL
	SETZ	V,
	PJS	MY
	POP	S,U
SC1:	SKIPL	LSTMSK		;only splice in pass 1
	JRST	SCP2
	GFL			;Allocate a reference cell
	MOVE	X,W		;Save pointer to reference cell
	TLO	W,400000	;Mark as pointer to reference cell
	JUMPN	Y,SC2		;THERE IS A COMPUTE CHAIN FOR THIS EXPRESSION
	EXCH	W,2(M)		;Have symbol table point to reference cell
	MOVEM	W,2(X)		;Have reference cell point to previous chain
	JRST	SC3
SC2:	HLRZ	L,Y
	EXCH	L,2(M)
	MOVEM	L,2(X)		;Have reference cell point to previous chain
	MOVEM	W,2(Y)		;Have new chain point to reference cell
SC3:	MOVEM	U,(X)		;Save flag bits in reference cell
	MOVEM	VS,1(X)		;Save engine memory reference
	RETURN
SCP2:	MOVEM	Y,UCC		;save chain to be deleted at end of statement
	RETURN

;
; Get memory for free list of three word cells. Return with at least one
; new cell on free list.
;
GM:	HLRZ	W,MACFRE	; Get address of smallest block on free list
	SKIPN	1(W)		; Is it really a block?
	JRST	GM1		; No. Need to get new memory
	PUSH	S,X		; Save registers for block remove
	PUSH	S,Y
	PJS	REMBLK		; Remove block from free list
	POP	S,Y
	MOVE	X,1(W)		; Get number of cells in block
	JRST	GM2		; Go link to free list
GM1:	HRRZ	W,YEND		; Get current end of memory
	ADDI	W,3000		; Allocate in multiples of 1000 cells
	TLNN	W,777777	; Is request past end of memory
	CORE	W,
	PJS	GME		; Out of memory
	HRRZ	W,YEND		; Get address of start of block
	ADDI	W,3000		; New address of end of memory
	EXCH	W,YEND		; Set new memory end and get address of block
	PUSH	S,X		; Save register for count
	MOVEI	X,1000		; Number of cells allocated
GM2:	HRRZM	W,@FL		; Put cells at end of free list
GM3:	HRRZI	W,3(W)		; Address of next cell, three words long
	HRRZM	W,-3(W)		; Have previous cell point to cell
	SOJG	X,GM3		; Any more cells to link?
	POP	S,X		; Restore X
	SETZM	W,-3(W)		; Make last cell end of list
	HRRZ	W,@FL		; Address of second cell on free list
XPS:	RETURN
GME:	PE	MSOOM,ABORT

;	Shadow Symbol Table Routines
;
;	Put an old definition in shadow symbol table.
;	This is a symbol table entry that is in the symbol table and whose
;	value is changing or who is being deleted.
;	Called with M set to address of symbol table entry and
;	L set to symbol name. Destroys registers W, X and V.
;
SHOLD:	PJS	SHADOW		;is it already in shadow symbol table
	RETURN			;yes. only save on first change
	MOVE	V,2(M)		;get old value
	MOVEM	V,2(W)		;and save
	RETURN

;	Put a new definition in shadow symbol table.
;	This is a symbol that is being added to the symbol table.
;	The symbol is marked in the shadow table is not being in the
;	symbol table by setting bit 1 of the first word of the entry.
;	Called with L set to symbol name and U set to module number.
;	Destroys registers W, X and V.
;
SHNEW:	PUSH	S,M		;save to set flags
	HLL	M,U		;insert flags
	TLO	M,SYSHNU	;add not in table bit
	PJS	SHADOW		;is it already in the shadow symbol table?
	JFCL			;yes. nothing to do
	POP	S,M
	RETURN

;	Search shadow symbol table.
;	Called with symbol name in L and module number in U.
;	Skips if symbol not found and returns in W the address of
;	the new table entry. Table entry has name set from L and value
;	set from VS and flag bits set from the left half of M.
;	Destroys registers W, X and V.
;
SHADOW:	MOVM	W,L		;hash symbol
	IDIVI	W,HASHSZ
	HRRI	V,SHASHT(X)	;get address of shadow table word
SHAD1:	HRRZ	X,V		;save previous pointer
	HRRZ	V,(V)		;get address of next entry
	JUMPE	V,SHAD2		;symbol not in table
	CAME	L,1(V)		;is this the symbol?
	JRST	SHAD1		;no. try next
	HLL	W,(V)		;get module number of entry
	XOR	W,M		;compare to old symbol
	TLNE	W,77
	JRST	SHAD1		;no, try next
	RETURN			;symbol found. exit
SHAD2:	GFL
	HRRM	W,(X)		;put new entry in shadow table
	HLLZM	M,(W)		;set flag bits
	MOVEM	L,1(W)		;set name
	AOS	(S)		;skip return to signify not found
	RETURN

;	Begin shadow symbol table.
;	Set switch to create shadow table only if there will be a second pass.
;
SHBEG:	TRNN	F,LPASS2	;will there be a second pass?
	RETURN			;no. no shadow table
	TRO	F,MKSHAD	;set make shadow bit
	MOVE	W,[XWD SHASHT,SHASHT+1]
	SETZM	SHASHT		;zero shadow table
	BLT	W,ESYH-1
	RETURN

;	Prepass 2 shadow table processing.
;	Restore symbol table to its state at beginning of pass 1.
;
SHMID:	TRZ	F,MKSHAD	;clear make shadow table flag
	MOVNI	Y,HASHSZ	;negative table size to Y
SHMID1:	HRRZ	OS,ESYH(Y)	;get shadow table word
SHMID2:	JUMPE	OS,SHMID5	;no entries for this word.
	HLL	OS,(OS)		;get flag bits
	MOVE	L,1(OS)		;get symbol name
	LDB	U,[POINT 6,OS,17]	;get module number
	MOVE	W,LBIT(U)	;get module mask bit
	MOVEM	W,MM1		;and set for FY
	PJS	FY		;find symbol in symbol table
	JUMPN	M,SHMID3	;jump if symbol in symbol table
	TLNE	OS,SYSHNU	;was it in table when put in shadow
	JRST	SHMID4		;no leave shadow and symbol tables alone
	HLLZ	U,OS		;get flag bits for MY
	TLZ	OS,777700	;clear all but module number in flag bits
	TLO	OS,SYSHNU	;set new symbol bit
	HLLM	OS,(OS)		;and set shadow table
	MOVE	V,2(OS)		;get old value
	TLNE	U,SYUNDF	;is value undefined chain?
	SETZ	V,		;yes. restore as empty chain
	PJS	MY		;and put back in symbol table
	JRST	SHMID4
SHMID3:	HLLM	OS,(M)		;restore flag bits
	HLLM	M,(OS)		;save new flag bits
	EXCH	V,2(OS)		;save new value and get old one
	TLNE	OS,SYUNDF	;is it undefined?
	SETZ	V,		;yes. store a null chain
	MOVEM	V,2(M)		;restore old value
	SETZ	W,
	TLNE	OS,SYSHNU	;should symbol be removed from table?
	PJS	RY		;yes. do it
SHMID4:	HRRZ	OS,(OS)		;get next entry
	JRST	SHMID2
SHMID5:	AOJL	Y,SHMID1
	RETURN

;	Finish shadow table.
;	Restore any undefined chains from end of pass 1 and insure
;	that there are no problems.
;
SHEND:	MOVNI	Y,HASHSZ	;negative table size
SHEND1:	HRRZ	OS,ESYH(Y)	;get first entry
SHEND2:	JUMPE	OS,SHEND8	;no more entries, get next word
	HLL	OS,(OS)
	MOVE	L,1(OS)		;get symbol name
	LDB	U,[POINT 6,OS,17]	;get module number
	MOVE	W,LBIT(U)	;module mask bit
	MOVEM	W,MM1		;store for FY
	PJS	FY		;find symbol in symbol table
	JUMPN	M,SHEND3	;jump if in symbol table
	TLNN	OS,SYSHNU	;is it in shadow table
	PJS	SHBUG		;yes. error
	JRST	SHEND7		;no. ok
SHEND3:	TLNE	OS,SYSHNU	;is it in shadow?
	PJS	SHBUG		;no. error
	MOVE	U,OS		;get flag bits for compare
	XOR	U,M		;compare flags
	TLNE	U,777777	;are they the same?
	PJS	SHBUG		;no. error
	JUMPL	M,SHEND5	;jump if value not defined in symbol table.
	TLNE	W,100000	;is it a macro?
	JRST	SHEND6		;yes. dont compare values directly
	CAME	V,2(OS)	;are values the same?
SHEND4:	PJS	SHBUG		;no. error
	JRST	SHEND7		;yes. ok
SHEND5:	JUMPN	V,SHEND4	;undefined value better be zero
	MOVE	V,2(OS)		;restore undefined chain
	MOVEM	V,2(M)
	JRST	SHEND7
SHEND6:	HLRZ	W,2(OS)			;delete macro body
	LDB	V,[POINT 9,2(OS),26]
	PJS	REMAC
SHEND7:	HRRZ	W,OS
	HRRZ	OS,(OS)		;get next entry
	DFL	W
	JRST	SHEND2
SHEND8:	AOJL	Y,SHEND1
	RETURN

SHBUG:	TYPE	<$Shadow table error for: >
	MOVE	U,1(OS)
	PJS	TYP6		;print name
	JUMPE	M,SHBUG1
	TYPE	<$Symbol table: >
	HLRZ	U,(M)		;flag bits
	PJS	TOCT
	OUTCHI	" "
	MOVE	U,2(M)		;value
	PJS	TOCT
SHBUG1:	TYPE	<$Shadow table: >
	HLRZ	U,(OS)		;flag bits
	PJS	TOCT
	OUTCHI	" "
	MOVE	U,2(OS)		;value
	PJS	TOCT
	RETURN
	SUBTTL	FILE HANDLER AND PAGE SWAPPER
;		**************************************************


;	Get a file name.
;
;	This routine has two entry points
;		GFN if the file name comes from the command stream and
;			is terminated with a carriage return and
;		GFNX if the input source and the terminator is specified by the caller.
;
;	Scanning for a file name will terminate unsuccessfully on three
;	conditions, one, scanning the terminator in the middle of a username
;	or before a name is given, two, scanning a question mark anywhere,
;	three, scanning a second period in the name or a nonletter
;	or digit in the name. A successful file name must be of the
;	following form (where [...] means that ... is optional)
;
;		[(username)]name[.[extension]]
;
;	where username is any string not containing the terminator, a question
;	mark or a right parenthesis and name and extension are strings of at
;	least one character consisting of only letters or digits.
;
;	Input-
;		GFN - None
;		GFNX - C: terminator
;		      VS: instruction which when eXeCuTed returns the next
;				character in W
;
;	Output-
;		L: name of one to six charcaters
;		M: extension of zero to three characters
;		X: first word of user name or 0
;		Y: second word of user name
;		U: -1 if . scanned before extension, otherwise 0
;
;	Registers used- OS, W, VS, C
;
;
GFN:	MOVE	VS,[XCT GCHI]	;setup to scan command stream
	MOVEI	C,15		; and terminate on carriage return
GFNX:	SETZB	L,M		;zero name and extension
	SETZB	X,Y		;zero user name
	SETZ	U,		;and period flag
	XCT	VS		;get first character of file name
	CAIE	W,"("		;does it start with a user name?
	JRST	GFN3		;no
	MOVE	OS,[POINT 6,X]	;store name in X and Y
GFN1:	XCT	VS		;get next character of user name
	CAIN	W,")"		;is it the end?
	JRST	GFN2		;yes
	CAME	W,C		;is it the terminator or
	CAIN	W,"?"		; a question mark?
	RETURN			;yes, fail
	CAMN	OS,[POINT 6,X+1,35]	;have twelve characters been scanned?
	JRST	GFN1		;yes, ignore this one
	CAIL	W,"a"		;lower case?
	CAILE	W,"z"
	SKIPA
	SUBI	W,40		;yes, convert to uppper
	SUBI	W,40		;convert to sixbit
	IDPB	W,OS		;and save in username
	JRST	GFN1		;go scan next character
GFN2:	XCT	VS		;get first name character after user name
GFN3:	MOVE	OS,[POINT 6,L]	;put name in L
GFN4:	CAMN	W,C		;is it the terminator?
	JRST	GFN7		;yes. go end scan
	CAIN	W,"."		;is it the start of the extension?
	JRST	GFN6		;yes. go start it
	CAIL	W,"0"		;is it a digit
	CAILE	W,"9"
	SKIPA
	JRST	GFN5		;yes. go add to file name
	CAIL	W,"A"		;is it an upper case letter?
	CAILE	W,"Z"
	SKIPA
	JRST	GFN5		;yes. go store it in file name
	CAIL	W,"a"		;is it a lower case letter?
	CAILE	W,"z"
	RETURN			;no. invalid character in name or extension
	SUBI	W,40		;convert to upper case
GFN5:	SUBI	W,40		;convert to sixbit
	TLNE	OS,770000	;anymore room for character?
	IDPB	W,OS		;yes
	XCT	VS		;get next character
	JRST	GFN4		;and go scan it
GFN6:	JUMPL	U,[RETURN]	;fail if period already scanned
	SETO	U,		;flag period scanned
	MOVE	OS,[POINT 6,M,17]	;set up to store extension
	XCT	VS		;get first character of extension
	JRST	GFN4
GFN7:	MOVSS	M		;put extension in left half
	JUMPE	L,[RETURN]	;fail if no name given
	AOS	(S)		;skip return on success
	RETURN

OIF:				;OPEN INPUT FILE
	TLZ	F,EOFF
	SETOM	DMSCTR
	MOVE	Y,IBF0
	ADDI	Y,NSB*201
	MOVEM	Y,.JBFF		;START OF RING
	OPEN	ICH,ISPEC
	  JRST	OIFE
	SETZM	IL+4		;clear lookup block
	SETZB	W,IL+5
	SKIPE	ILUSR
	  HRRZI	W,ILUSR
	MOVEM	W,IL+1		;store address of user name or zero if no user name
	PJS	LOOKCK		;check username for license (xct of .+1)
	 LOOKUP	ICH,IL
	  JRST	OIFE
	MOVE	W,LSPACE
	INBUF	ICH,IINBUF(W)
	INPUT	ICH,
	GETSTS	ICH,X
	TRNE	X,20000
	JRST	ITEOF
	TRNE	X,740000
	JRST	ITIOER
	MOVE	Y,IBF0
	HRLI	Y,CHRIT_13
	MOVEI	X,NSB		;INITIALIZE SIDE RING
	ADDI	Y,201
	MOVEM	Y,-1(Y)
	SOJG	X,.-2
	HRR	X,IBF0
	HRRM	X,-1(Y)		;WRAP AROUND POINTER
	HRRZM	X,PTB		;POINTER TO TRAILING BFR (WHICH HAPPENS TO BE EMPTY)
	ADDI	X,201
	HRRZM	X,PAB		;ACTIVE BFR.REG. IT WILL POINT TO END OF PAB
	ADDI	X,201
	HRRZM	X,PLB		;LEADING BFR JUST BEYOND END OF PAB
	HRRI	I,-1(X)
	HRLI	I,(POINT 7,0)	;RECEIVE TRP CHR ON 1ST ILDB C,I
	SKIPA	W,S		;SET W NON ZERO FOR NO ERROR SIGNAL
OIFE:	SETZ	W,
	RETURN

CIF:	CLOSE	ICH,
	RELEASE	ICH,
	SETZM	IH
	RETURN

OJF:				;OPEN OBJECT FILE
	OPEN	JCH,JSPEC
	JRST	OJFE
	DMOVE	V,OBJNAM
OJF1:	DMOVEM	V,JE
	SETZM	JE+2
	SETZM	JE+3		;SETUP ENTER
	ENTER	JCH,JE
	SKIPA
	RETURN
	TRNN	V,17
	JRST	OJFE
	SOS	V
	JRST	OJF1		;FILE NAME IN USE. TRY ANOTHER NAME.
OJFE:	TYPE	<$Can't open object file>
	JRST	NADAB

OLF:	SKIPE	LOH		;DON'T OPEN IF ALREADY OPEN.
	RETURN
	OPEN	LCH,LSPEC	;OPEN LISTING FILE CHANNEL
	JRST	OLFE
	SKIPE	LE		;HAS FILE NAME BEEN SET?
	JRST	OLF1		;yes
	MOVE	V,IL+2		;NO. USE INPUT FILE NAME.
	MOVE	U,[SIXBIT /CRF/]
	TRNN	F2,CRFLST
	MOVE	U,[SIXBIT /LST/]
	DMOVEM	V,LE
OLF1:	SETZB	W,LE+2
	SKIPE	LEUSR		;was a user name given?
	HRRZI	W,LEUSR		;yes. refer to it.
	MOVEM	W,LE+3
	ENTER	LCH,LE
	JRST	OLFE
	OUTBUF	LCH,NLBF
	OUTPUT	LCH,
	TRZ	F,INCREF	;CLEAR IN CREF CODE FLAG
	RETURN
OLFE:	TYPE	<$Can't open listing file>
	JRST	NADAB

CLF:	TRNN	F2,MLTLST	;CLOSE LIST FILE UNLESS MULTI FILE LIST
	SKIPN	LOH		;OR FILE NOT OPEN.
	RETURN
	OUTPUT	LCH,
	CLOSE	LCH,
	RELEAS	LCH,
	SETZM	LOH
	TRNE	F2,CRFLST	;IS THIS A CREF LISTING?
	PJS	CROSS		;YES. INFORM CROSS OF IT.
	RETURN

CROSS:
;	CONSTRUCT TMP FILE NAME INCASE NEED TO PUT CROSS REQUEST ON DISK.
;	FILE NAME IS 'NNNCRE.TMP' WHERE NNN IS JOB NUMBER.
	MOVEI	W,TE		;ADDRESS FILENAME WORD IN FILE SPEC
	HRLI	W,(POINT 6,0)	;CONSTRUCT BYTE POINTER TO IT
	PJOB	X,		;GET JOB NUMBER
	IDIVI	X,^D100		;CONVERT TO SIXBIT
	ADDI	X,'0'
	IDPB	X,W		;AND PUT IN FILE NAME
	MOVE	X,Y
	IDIVI	X,^D10
	ADDI	X,'0'
	IDPB	X,W
	ADDI	Y,'0'
	IDPB	Y,W
;	FIRST CHECK IF THERE ALREADY IS A TMPCOR FILE OF CROSS
;	REQUESTS. TMPCOR FILE NAME IS 'CRE'. THIS IS DONE BY READING
;	THE FILE WITH A ZERO LENGTH BUFFER. IF IT IS THERE, THE SIZE OF
;	THE FILE WILL ALSO BE RETURNED.
	HRLZI	X,'CRE'		;MAKE TMPCOR COMMAND FROM 
	HRRZI	Y,Y		; REGISTER PAIR (X,Y)
	HRRI	W,X		;ADDRESS TMPCOR COMMAND
	HRLI	W,1		; AND DO A READ.
	TMPCOR	W,
	JRST	CROSS6		;NO TMPCOR FILE. TRY DISK.
	PJS	CRSBUF		;ALLOCATE CROSS BUFFER.
	HRRI	W,X		;ADDRESS TMPCOR COMMAND
	HRLI	W,2		;DO A READ AND DELETE.
	TMPCOR	W,
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
;	AT THIS POINT, OLD REQUEST FILE IS IN MEMORY STARTING AT "YEND",
;	THE BUFFER ALLOCATED HAS ROOM FOR TWO MORE WORDS FOR NEW REQUEST,
;	THE OLD FILE HAS BEEN DELETED, "Y" CONTAINS AN IOWD
;	WORD FOR OLD FILE(NOT INCLUDING TWO WORDS FOR NEW REQUEST)
;	AND "L" CONTAINS ADDRESS OF END OF FULL BUFFER (INCLUDING THE TWO
;	NEW WORDS) PLUS ONE. FIRST ADD NEW REQUEST AND THEN
;	TRY TO WRITE A NEW TMPCOR FILE. IF THIS FAILS, WRITE BUFFER
;	TO DISK.
CROSS1:	SUB	Y,[2,,0]	;HAVE "Y" REFERENCE FULL BUFFER.
	HRRI	W,-2(C)		;ADDRESS TWO WORDS FOR NEW REQUEST.
	SETZM	(W)		;SET NEW WORDS TO ALL NULLS.
	SETZM	1(W)
	HRLI	W,(POINT 7,0)	;CONSTRUCT BYTE POINTER TO NEW WORDS.
	MOVEI	C,"_"		;MAKE REQUEST "_FILENAME"
	IDPB	C,W
	MOVEI	L,LE		;ADDRESS CREF FILE NAME
	HRLI	L,(POINT 6,0)	;CONSTRUCT BYTE POINTER TO FILE NAME
CROSS2:	ILDB	C,L		;GET NEXT CHARACTER OF FILE NAME
	JUMPE	C,CROSS3	;STOP AT BLANK
	ADDI	C,40		;CONVERT FROM SIXBIT TO ASCII
	IDPB	C,W		;PUT IN NEW REQUEST
	TLNE	L,770000	;END OF FILE NAME?
	JRST	CROSS2		;NO
CROSS3:	MOVEI	C,15		;END REQUEST WITH CARRIAGE RETURN
	IDPB	C,W
	MOVEI	C,12		; AND A LINEFEED.
	IDPB	C,W
	HRRI	W,X		;ADDRESS TMPCOR COMMAND
	HRLI	W,3		;DO A WRITE.
	TMPCOR	W,
	JRST	CROSS5		;NO ROOM. GO TRY DISK FILE.
CROSS4:	MOVE	W,YEND		;GET OLD END OF MEMORY
	TLNN	W,777777	; Is request past end of memory
	CORE	W,		;AND RESET.
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	RETURN
CROSS5:	OPEN	TCH,TSPEC	;ASSIGN CHANNEL IN DUMP MODE
	JRST	CROSSE
	SETZB	W,TE+2		;CLEAR ENTER BLOCK
	SETZM	TE+3
	HRRM	W,TE+1
	ENTER	TCH,TE		;CREATE NEW FILE.
	JRST	CROSSE
	SETZ	L,		;SET END OF DUMP COMMAND LIST
	OUTPUT	TCH,Y		;WRITE REQUESTS
	RELEASE	TCH,		;CLOSE FILE
	JRST	CROSS4		;GO RELEASE BUFFER AND EXIT
;	NO TMPCOR FILE. CHECK IF DISK FILE EXISTS. IF SO, READ IT IN 
;	AND DELETE IT. IF NOT, JUST ALLOCATE BUFFER SPACE FOR NEW REQUEST.
CROSS6:	OPEN	TCH,TSPEC
	JRST	CROSSE
	SETZB	W,TL+1		;CLEAR ENTER BLOCK
	SETZM	TL+4
	SETZM	TL+5
	HRRM	W,TL+3
	LOOKUP	TCH,TL		;OPEN FOR INPUT
	JRST	CROSS7		;NO TMPCOR OR DISK FILE.
	MOVE	W,TLSIZE	;GET FILE SIZE IN WORDS.
	PJS	CRSBUF		;ALLOCATE REQUEST BUFFER
	SETZ	L,		;SET END OF DUMP COMMAND LIST
	INPUT	TCH,Y		;READ OLD REQUEST FILE
	SETZM	TR		;CLEAR RENAME BLOCK
	SETZM	TR+1
	SETZM	TR+2
	SETZM	TR+3
	RENAME	TCH,TR		;DELETE OLD FILE
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	RELEAS	TCH,
	JRST	CROSS1		;GO CREATE NEW REQUEST FILE
CROSS7:	SETZ	W,		;NO OLD REQUEST
	PJS	CRSBUF		;ALLOCATE BUFFER
	JRST	CROSS1		;AND GO WRITE NEW REQUEST.
CROSSE:	TYPE	<$Can't open CREF temp file>
	JRST	NADAB

;	USE SIZE RETURNED TO ALLOCATE A BUFFER FOR FILE. GET AN
;	EXTRA TWO WORDS FOR NEW CROSS REQUEST. "Y" WILL CONTAIN AN IOWD
;	WORD FOR BUFFER. THIS WILL BE USED BOTH TO READ TMPCOR FILE AND
;	DISK FILE.
CRSBUF:	MOVN	Y,W		;NEGATE FILE SIZE FOR IOWD WORD.
	HRL	Y,Y		;AND PUT IN LEFT HALF.
	HRR	Y,YEND		;ADDRESS END OF MEMORY FOR BUFFER.
	SUBI	Y,1		;USE ADDRESS MINUS 1 FOR IOWD.
	ADD	W,YEND		;ALLOCATE BUFFER FOR FILE
	ADDI	W,2		;PLUS TWO WORDS FOR NEW REQUEST.
	MOVE	C,W		;SAVE END OF BUFFER TO ADD NEW REQUEST.
	TLNN	W,777777	; Is request past end of memory?
	CORE	W,
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	RETURN

;	SET UP NEW ID BLOCK FOR NIB FILE.
IIDB:	MOVEI	W,IBID
	SETZB	V,U		;ZERO OUT BLOCK
IID1:	DMOVEM	V,(W)
	ADDI	W,2
	CAIG	W,IBIDC		;END OF BLOCK?
	JRST	IID1		;NO, KEEP ZEROING
	MOVEI	M,IBID
	MOVE	V,BAD		;GET BLOCK ADDRESS
	DPB	V,IBBADP	;PUT IN HEADER
	AOS	BAD
	MOVEI	V,IDTYP
	DPB	V,IBTYPP	;PUT TYPE IN HEADER
	SETO	V,
	MOVEM	V,IBPSA		;SET UNDEFINED PROGRAM START ADDRESS
	DATE	V,
	MOVEM	V,IBDATE	;SET UP DATE
	MSTIME	V,
	MOVEM	V,IBTIME	;SET UP TIME
	DMOVE	V,BL+2
	DMOVEM	V,IBFILE	;SET UP FILENAME
	MOVE	V,[-1,,.GTUNM]	;GET LOGGED IN USERNAME
	GETTAB	V,
	CAM			;IGNORE ERRORS
	MOVE	U,[-1,,.GTUN1]	;SECOND HALF
	GETTAB	U,
	CAM			;IGNORE ERRORS
	DMOVEM	V,IBAUTH	;SET UP AUTHOR
	MOVEI	W,IBRIX
	MOVEM	W,IBRIXP	;POINT TO START OF INDEX
	RETURN

;	UPDATE IMAGE BINARY ID RECORD.
UBID:	MOVE	V,IBRIXP
	SKIPN	BFSW		;CAN FILE BE UPDATED?
	CAIG	V,IBRIX		;ANYTHING TO OUTPUT?
	RETURN			;NO
	MOVEI	M,IBID
	LDB	V,IBBADP	;GET BLOCK ADDRESS
	USETO	BCH,1(V)	;POSITION FILE
	OUTPUT	BCH,[BYTE (18)-200,IBID-1,0,0]	;OUTPUT ID BLOCK
	RETURN

SWAP:	BAR	<L,V,U,Y>	;PAGE REFERENCE MACRO CALLED SWAPPER. FETCH PAGE FROM DISC.
	AOS	SWAPC
	SKIPN	JE
	PJS	OJF		;OPEN OBJECT FILE IF UNOPENED
	MOVE	L,SWRAN
	ROT	L,3
	MOVEM	L,SWRAN
	ANDI	L,3
	MOVNI	U,NPGD
	MOVE	Y,LPG
	MOVE	V,[PJS SWAP]
SW1:	CAMN	V,PGT+NPGD(U)
	AOJL	U,SW1
	CAIE	Y,NPGD(U)	;DONT SWAP OUT LAST PAGE REFERENCED
	SOJL	L,.+2		;USE THIS PAGE
	AOJA	U,SW1

	HRR	L,PGT+NPGD(U)	;MEMORY ADRS OF BEGINNING OF PAGE
	MOVNI	Y,PGSIZ/200	;NUMBER OF PHYSICAL WRITES NECESSARY
	SUBI	L,1		;CP ADR MUST BE ONE LESS THAN MEMORY BLOCK
SW2:	HRRM	L,CP+PGSIZ/200(Y)	;MAKE A WORD IN CHANNEL PROGRAM
	ADDI	L,200
	AOJL	Y,SW2

	MOVEI	Y,NPGD(U)	;NAD FILE PAGE NUMBER
	IMULI	Y,PGSIZ/200	;DEC DISC BLOCK INDEX
	USETO	JCH,1(Y)
	OUTPUT	JCH,CP		;SWAP OUT A PAGE
	MOVE	Y,X
	IMULI	Y,PGSIZ/200
	USETI	JCH,1(Y)
	INPUT	JCH,CP		;SWAP IN THE PAGE
	GETSTS	JCH,Y
	TRZN	Y,640000
	JRST	SW3		;LOOK FOR ERRORS
	TYPE	<$Bit 18,19,20, or 21 read by GETSTS UUO. Can't swap>
	JRST	NADAB		;EXIT WHILE USER FINDS DEC DOCUMENT
SW3:	TRZN	Y,20000
	JRST	SW4
	SETSTS	JCH,(Y)		;EOF INDICATOR
	HRR	Y,CP		;CLEAR OUT PAGE
	MOVE	L,Y
	ADDI	L,PGSIZ
	AOJ	Y,
	SETZM	(Y)
	HRL	Y,Y
	AOJ	Y,
	BLT	Y,(L)
SW4:	EXCH	V,PGT+NPGD(U)	;MARK OLD PAGE AS ON THE DISC
	MOVEM	V,PGT(X)	;MARK NEW PAGE AS IN
	XCT	PGT(X)		;EXECUTE THIS AS IF SWAP HAD NEVER BEEN CALLED.SEE CA MACRO.
	RETURN


;;;	ITP - INPUT TRAP PROCESSOR.
;
;	CALLED AS THE CIT UUO WHEN THE INPUT TRAP CHARACTER (NULL) IS 
;	SEEN IN THE INPUT SIDE BUFFER.  IF THIS IS THE END OF THE SIDE BUFFER,
;	GET NEXT SIDE BUFFER, ELSE, SKIP NULLS UNTIL NEXT VALID CHARACTER.

ITP:	HRR	C,40
	HRRM	C,(S)		;INPUT TRAP RETURNS TO RETURN ARG OF CALLER
IT0:	HRRZI	C,-200(I)
	CAMN	C,PTB
	JRST	IT8		;ADVANCE TO PAB, MOVING OUT OF TRAILING BFR.
	CAMN	C,PAB		;END OF ACTIVE BUFFER?
	JRST	IT1		;YES
	ILDB	C,I		;NO, GET NEXT BYTE
	CAIN	C,CHRIT		;IS THIS NULL CHARACTER?
	JRST	IT0		;YES, SKIP IT
	ADD	I,BACKUP	;BACKUP OVER GOOD CHARACTER
	RETURN
;				ADVANCE ACTIVE BFR AND ITS TRAILING BFR
IT1:	TRNN	F,SUPLST+ASONLY	;IS THE LISTER RUNNING
	PJS	LSVLNE		;YES, SAVE BEGINNING OF LINE
	HRR	C,PAB
	HRRZM	C,PTB
	HRR	C,200(C)
	HRRZM	C,PAB

IT2:	MOVE	I,@IH		;GET PTR TO BFR AFTER NXT BFR
	SKIPL	(I)		;SKIP IF INPUT ICH, WONT CAUSE A DISMISS
	JRST	IT4		;BFR BEYOND NXT IS EMPTY. WE MIGHT DISMISS SOON TO GET DATA
IT3:	PJS	ITBLT		;MOVE A BFR TO SIDE BFR RING
	INPUT	ICH,		;RELEASE BFR AND POSSIBLY TRIGGER PHYSICAL IO
	MOVE	C,PLB
	HRRZ	C,200(C)
	HRRZM	C,PLB		;ADVANCE LEAD BFR
	CAME	C,PTB		;DONT READ INTO WHAT WILL BE TRAILING BFR.(SEE IT8)
	JRST	IT2		;FILL LEADING BFRS UNTIL IT2 NOTICES POSSIBLE DMS

IT4:	MOVE	C,PAB
	CAME	C,PLB
	JRST	IT9		;GOOD, WE HAVE DATA READY FOR A NEW ACTIVE BFR
	AOS	DMSCTR		;TOO BAD, WE'LL SUFFER A DISMISS TO GET SOME DATA
	SKIPG	@IH
	JRST	IT3
	INPUT	ICH,
	WAIT	ICH,
	GETSTS	ICH,C
	TRNE	C,20000
	JRST	ITEOF
	TRNE	C,750000
	JRST	ITIOER
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	JRST	IT9

IT8:	TRNN	F,SUPLST+ASONLY	;IS LISTER RUNNING
	PJS	LSVLNE		;YES. SAVE BEGINNING OF LINE

IT9:	MOVE	I,PAB
	HRLI	I,(POINT 7,0)	;BYTE POINTER
	MOVEM	I,LISTI		;SAVE POINTER TO REST OF LINE
	RETURN

ITEOF:	TLO	F,EOFF		;SET END OF FILE FLAG
	PJS	DEN
	MOVE	S,GFS		;RETURN TO CALLER FOR THIS PASS
	RETURN

ITIOER:	TYPE	<$Disk I/O error>
	JRST	NADAB

ITBLT:				;COPY A BFR FROM INPUT RING TO SIDE RING
	MOVE	C,IH		;BFR PTR
	HRLI	C,2(C)		;FIRST DATA WORD TO PICK UP
	HRR	C,PLB		;FIRST WORD OF DESTINATION BFR
	HRRZI	I,177(C)	;LAST WORD DEPOSITED IN DESTINATION BFR
	BLT	C,(I)
	RETURN


FBT:	PJS	GCHR		;FLUSH BLANKS AND TABS
	CAIE	C," "
	CAIN	C,11
	JRST	FBT		;FBT IF BLANK OR TAB
	ADD	I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
	RETURN

TYPEOL:	OUTCHI	15
	OUTCHI	12
	RETURN			;TYPE CARRIAGE RET. LINE FEED

GCHR:	ILDB	C,I
	CAILE	C,3		;IS IT A TRAP CHARACTER
	RETURN			;NO. RETURN CHARACTER
	JRST	.+1(C)		;YES. GO TO TRAP PROCESSOR
	CIT	GCHR		;END OF INPUT FILE BUFFER
	MARG	GCHR		;MACRO ARGUMENT
	MAE	GCHR		;MACRO ARGUMENT END
	MEND	GCHR		;MACRO END

BL3:	REPEAT	3,<OUTCHI " ">
	RETURN

TYPEM:	HRLI	W,(POINT 7,0)	;Type message addressed in "W".
TYPEM1:	ILDB	X,W
	JUMPE	X,[RETURN]
	CAIN	X,"$"		;CR-LF SEQUENCE?
	JRST	TYPEM2		;YES. GO TYPE THEM
	OUTCHR	X
	JRST	TYPEM1
TYPEM2:	PJS	TYPEOL
	JRST	TYPEM1

TYP6:	BAR	V		;TYPE OUT SIXBIT LABEL IN U AND LEAVE CHR COUNT IN V
	SETZM	TYP6C
TYP6A:	SETZ	V,
	LSHC	V,6
	ADDI	V,40		;MOVE A CHAR TO V
	XCT	@P6		; "OUTCHR V"  OR  "IDPB V,DOS"
	AOS	TYP6C
	JUMPN	U,TYP6A
	RETURN

TN0:	PUSH	S,U		;PUSH A REMAINDER
TN:				;TYPE V IN RADIX Y
	TLZ	V,400000
	IDIV	V,Y
	JUMPG	V,TN0		;LOOP IF STILL CREATING QUOTIENTS
	PUSH	S,U		;PUSH A REMAINDER
	MOVE	U,[IDPB	U,DOS]
	SKIPE	TNX
	MOVE	U,[OUTCHR	U]
	MOVEM	U,TNX		;SET OUTPUT DESTINATION TO TTY OR DOS
	SETZM	TYP6C		;CLEAR COUNT OF CHARS TYPED
TN1:	POP	S,U
	TRNE	U,777740	;Is this the return address?
	JRST	(U)		;Yes, exit procedure
	TRZE	Y,-1
	CAIG	U,11
	JRST	.+3
	PUSH	S,U
	SETZ	U,		;LEAD ZERO
	MOVE	U,HEX(U)
	XCT	TNX		;OUTPUT A CHR
	AOS	TYP6C		;INCREMENT COUNT OF CHARS TYPED
	JRST	TN1

;	Type a full word octal number in U. Uses registers W and V.

TOCT:	MOVEI	W,^D12		;twelve octal bytes in 36 bit word
TOCT1:	SETZ	V,		;clear to accept next byte
	LSHC	V,3		;get next byte from U
	ADDI	V,"0"		;convert to ASCII
	OUTCHR	V		;and type
	SOJG	W,TOCT1		;check if anymore to type
	RETURN

;
;	Get command input from file or terminal.
;
CFINP:	PUSH	S,X		;save registers needed
	PUSH	S,Y
	MOVE	X,CURCMD	;get index of current command file
	MOVE	Y,CMDBFA(X)	;get address of buffer header
CFINP1:	SOSGE	2(Y)		;buffer empty?
	JRST	CFINP3		;yes. refill buffer.
	ILDB	W,1(Y)		;get next character
	JUMPE	W,CFINP1	;ignore nulls
	SKIPL	CMDECO(X)	;should it be echoed?
	OUTCHR	W		;yes
	CAIN	W,15		;carriage return?
	JRST	CFINP6		;yes. go ignore linefeed
	CAIN	W,"V"-100	;control V?
	JRST	CFINP8		;yes. go switch to terminal input
	CAIN	W,"D"-100	;control D?
	JRST	CFINP4		;yes. end of file
CFINP2:	POP	S,Y		;restore registers
	POP	S,X
	RETURN
CFINP3:	MOVEI	W,CMDCHN(X)	;get channel for input
	HRLI	W,.CHIN
	CHANIO	W,		;read next buffer
	JRST	CFINP1		;get next character from buffer
CFINP4:	PJS	CFCLS		;close command file on eof or error
CFINP5:	POP	S,Y		;restore registers
	POP	S,X
	JRST	@GCHI		;go to new input source
CFINP6:	SOSGE	2(Y)		;get linefeen
	JRST	CFINP7		;need another buffer
	IBP	1(Y)		;ignore linefeed
	SKIPL	CMDECO(X)	;echo linefeed?
	OUTCHI	12		;yes
	MOVEI	W,15		;insure CR returned even if got next buffer
	JRST	CFINP2		;and exit
CFINP7:	MOVEI	W,CMDCHN(X)	;get channel
	HRLI	W,.CHIN
	CHANIO	W,		;get next buffer
	JRST	CFINP6		;get linefeed
	JRST	CFINP4		;eof
CFINP8:	MOVE	W,[PJS CTINP]	;switch to terminal input
	MOVEM	W,CMDSRC(X)
	MOVEM	W,GCHI
	JRST	CFINP5

CTINP:	TLNN	F,DCCF		;character wanted immediately?
	JRST	CTINP1		;no
	INCHRW	W		;yes. break on all characters
	TLZA	F,DCCF		;only for one character
CTINP1:	INCHWL	W		;break on punctuation
	CAIN	W,15		;carriage return?
	INCHRW	1(S)		;discard linefeed
	SKIPL	CURCMD		;command file active?
	CAIE	W,"D"-100	;and a control d?
	RETURN
	PUSH	S,X		;yes. restore command file input
	MOVE	X,CURCMD	;current command file
	MOVE	W,[PJS CFINP]	;input now from file
	MOVEM	W,CMDSRC(X)
	MOVEM	W,GCHI
	POP	S,X
	JRST	CFINP		;go get next character from file
;
;	Close either current command file or all command files.
;
CFCLS:	MOVE	W,CURCMD	;just close current command file
	SOSA	W		;set to new current command file
CFACLS:	SETO	W,		;close all command files
	PUSH	S,W		;save to test end of loop
	SKIPGE	W,CURCMD	;are any command files open?
	JRST	CFCLS2		;no. do nothing
CFCLS1:	MOVEI	W,CMDCHN(W)	;get channel
	HRLI	W,.CHREL
	CHANIO	W,		;release channel
	SOS	W,CURCMD	;reduce current command number
	CAMLE	W,(S)		;check if over
	JRST	CFCLS1		;more to do
CFCLS2:	MOVE	W,CMDSRC(W)	;get source of new current file
	MOVEM	W,GCHI		;set as character get instruction
	POP	S,W		;adjust stack
	RETURN
	SUBTTL	LISTER
;		**************************************************



;	ASSEMBLE WITH A LISTING.
LST:	MOVEM	S,GFS		;SAVE FOR EOF EXIT.
	SETZM	TRUTH		;INIT IF VALUE TO TRUE
	SETZM	SAVCHR
	SETZM	TXTOUT		;SET NO TEXT OUTPUT YET.
	SETZM	LNLEFT		;START LISTING ON NEW PAGE
	TRNE	F,LSTTTL	;IS TITLE TO BE LISTED?
	TRO	F,NEWSEC	;YES. START FILE AT NEW SECTION
	TRZ	F,ASONLY+CREF 	;NOT JUST ASSEMBLING OR CREF.
	TRNN	F2,CRFLST	;UNLESS LISTING SWITCH SET
	JRST	LS2		;NO CREF
	TRO	F,CREF		;CREF LISTING HAPPENING
	MOVNI	W,10		;DECREASE TEXT SIZE BY SIZE
	ADDM	W,TXTSIZ	; OF CREF LINE NUMBERS
	PJS	BEGCRF		;BEGIN CREF OUTPUT
	MOVEI	W,20		;MARK NEXT AS TITLE
	PJS	LOCN
	PJS	LOTTL		;OUTPUT CREF LISTING TITLE
	MOVEI	X,104		;END TITLE STRING
	PJS	ENDCRF
LS2:	INCLC
LS2A:	SETZM	MACN		;CLEAR MACRO STACK COUNTER
	MOVEM	I,LINEI		;SAVE START OF LINE FOR ERRORS
LS1:	MOVEM	I,LISTI
	TRZ	F2,CONDST	; Reset statement is conditional
	SETOM	PCL		;INIT PC LISTING OFF
	TRNE	F,SUPLST	;IS LISTING BEING SUPPRESSED?
	JRST	LS1A		;YES. DON'T CLEAR LISTING FLAGS.
	MOVEI	W,5*LSVSIZ	;NUMBER OF CHARACTERS IN LSTBUF
	MOVEM	W,LSVCNT
	MOVE	W,BLSVP		;INITIALIZE LISTER SAVE BUFFER POINTER
	MOVEM	W,LSVP
LS1A:	TRNE	F,CREF		;CREF LISTING?
	PJS	BEGCRF		;YES. BEGING CREF CONTROL OUTPUT
	PJS	GS
	TLZE	F,ENDRPT	;WAS STATEMENT NOT LAST END REPEAT?
	JRST	LS5A		;YES. DO NOT LIST
	TRNE	F,SUPLST	;IS LISTING BEING SUPPRESSED?
	JRST	LS5A		;YES.
	SETZM	NORPT		;ALLOW LIST OF NOT FIRST REPEAT LOOP
	SKIPE	LSTMSK		;PASS 1 LISTING?
	JRST	LS8R		;YES.DON'T CHECK LIST SWITCHES
	TLNN	F,NOLIST
	JRST	LS8F		;NOLIST IS NOT ACTIVE
	TLNE	F,LSL		;ARE NOLIST LINES TO BE LISTED
	JRST	LS5A		;NO. DON'T LIST THIS LINE
	SETOM	PCL		;IN ANY CASE, DON'T LIST MEMORY WORD
	SETOM	NORPT		; OR OTHER THAN FIRST TIME OF REPEAT
LS8F:	MOVE	W,IFC
	SUB	W,IFT
	SKIPE	TRUTH
	JUMPN	W,[TLNE  F,LSF	;ARE UNTRUE IF LINES TO BE LISTED
		   JRST  LS5A	;NO. DON'T LIST THIS LINE
		   SETOM PCL	;DON'T LIST MEMORY WORD
		   SETOM NORPT	;OR NONFIRST REPEAT LOOPS
		   JRST  LS8R]
  	MOVEM	W,TRUTH
LS8R:	TRNE	F2,CONDST	; Is current statement a conditional
	TLNN	F,LSI		; ... and should conditionals be listed?
	SKIPA			; Either not a conditional or should be listed
	JRST	LS5A		; Do not list this conditional statement
	SKIPG	W,RPPTR		;IS REPEAT BLOCK BEING LISTED
	JRST	LS8		;NO
	SKIPE	RPL-1(W)	;IS IT THE FIRST TIME THRU?
	JRST	LS8		;YES. GO LIST
	SKIPE	LSTMSK		;PASS 1 LISTING?
	JRST	LS5A		;YES. LIST REPEAT ONLY ONCE
	TLNN	F,LSR		;SHOULD IT BE SKIPPED?
	SKIPE	NORPT
	JRST	LS5A		;YES. DON'T LIST IT
LS8:	SETOM	LSTLN		;NONE OF LINE LISTED YET
	PJS	LSTART		;SIGNAL START OF LINE LIST
	SKIPE	LSTMSK		;PASS 1 LISTING?
	JRST	LS5F		;YES. DON'T LIST PC.
	SETO	V,
	EXCH	V,PCL
	TLNE	V,377700
	JRST	LS5F
	SKIPE	TXTOUT		;IN MIDDLE OF TEXT LINE
	PJS	LOEOL		;YES. FINISH LINE.

;	OUTPUT PC, MAYBE SOME MEMORY DATA, AND COPY INPUT LINE
	MOVE	OS,[POINT 4,V,11]	;HEX BYTE POINTER FOR PC
LS3:	ILDB	W,OS		;GET A BYTE FROM PC
	HRR	W,HEX(W)
	PJS	LOC		;OUTPUT HEX DIGIT
	TLNE	OS,770000
	JRST	LS3
	JUMPL	V,LS5

LS4B:	MOVEI	W,11		;TAB TO START OF HEX
	PJS	LOC
	SETZ	VS,		;SET NO CHARACTERS LISTER FOR HEX
LS4:	MOVE	W,V
	CAMN	W,PC
	JRST	LS5E
	CAILE	VS,HEXSIZ-3	;ABOUT TO OVERFLOW MARGIN?
	JRST	[PJS FILLHX
		 PJS LSCOPY	;YES. LIST TEXT
		 PJS LSTART	;START A NEW LINE
		 JRST LS4B]
	CA
	LDB	W,W
	PJS	LOBYTE
	AOJA	V,LS4

LS5F:	SKIPE	TXTOUT		;ANY TEXT OUTPUT ALREADY?
	JRST	LS5B		;YES. DON'T FILL IN HEX
LS5:	MOVEI	W,11		;TAB OVER PC POSITIONS
	SKIPN	LSTMSK		;IF PASS 1 LISTING, NO PC TO SKIP
	PJS	LOCN
	SETZ	VS,		;SET COUNT OF HEX LISTED (I.E. NONE)
LS5E:	PJS	FILLHX		;FILL FOR HEX
LS5B:	PJS	LSCOPY
	SKIPG	LSTLN		;ANYMORE OF LINE TO LIST?
	JRST	[PJS LSTART	;SIGNAL START OF NEW LINE
		 JRST LS5]
LS5A:	TLNE	F,ENDFND	;END OF FILE?
	JRST	LS5C		;YES. EXIT
	TLNE	F,ABTASM	;was assembly aborted?
	JRST	LS5G		;yes. go type message
	LDB	C,I		;GET END OF STATEMENT CHARACTER
	CAIE	C,15		;IF STATEMENT ENDED WITH CARRIAGE RETURN
	JRST	LS5D		;NO
	PJS	GCHR		;YES. REMOVE LINEFEED
	SKIPL	LSTMSK		;IN PASS 2?
	SETZM	LEC		;YES. IGNORE ERRORS.
	SKIPE	LEC		;ARE THERE ANY ERRORS?
	PJS	TLE
	JRST	LS2
LS5C:	SKIPL	LSTMSK		;PASS 2?
	SETZM	LEC		;YES. IGNORE LINE ERRORS
LS5G:	SKIPE	LEC		;ANY LINE ERRORS?
	PJS	TLE		;YES. TYPE THEM OUT
	RETURN
LS5D:	SKIPGE	MACN		;IS MACRO STACK OK
	SKIPE	LEC		;OR ARE THERE NO PENDING ERRORS?
	JRST	LS1		;YES. CONTINUE
	JRST	LS2A		;NO. CLEAR OLD LINE SAVE

LSTART:	TRNE	F,NEWSEC	;NEW SECTION?
	SETZM	LNLEFT		;YES. FORCE NEW PAGE
	SKIPLE	LNLEFT		;ROOM FOR LINE ON THIS PAGE?
	JRST	LSRT50		;YES
	SKIPGE	LSTLN		;FIRST LINE OF TEXT?
	TRNN	F,CREF		;AND OUTPUTTING CREF?
	JRST	LSRT0		;NO
	MOVEI	X,104		;END CREF INFO FOR TITLE
	PJS	ENDCRF
LSRT0:	MOVEI	W,14		;OUTPUT TOP OF FORM
	PJS	LOCN
	MOVE	W,LNPPG		;GET LINES PER PAGE
	TRNN	F,LSTTTL	;IS LISTING BEING TITLED AND PAGED?
	HRLOI	W,377777	;NO. SET INFINITY PAGE SIZE.
	MOVEM	W,LNLEFT	;SET AS LINES LEFT
	TRZN	F,NEWSEC	;DOES THIS PAGE START A NEW SECTION?
	JRST	LSRT1		;NO
	AOS	SECNUM		;GO TO NEXT SECTION NUMBER
	SETZM	PAGNUM		;AND START AT PAGE ONE
LSRT1:	TRNN	F,LSTTTL	;SHOULD TITLE BE LISTED?
	JRST	LSRT5		;NO. DON'T PRINT HEADING
	AOS	PAGNUM		;GO TO NEXT PAGE NUMBER
	MOVEI	X,[ASCIZ "Page  "]	;OUTPUT TITLE
	PJS	LOSTR		;OUTPUT "PAGE "
	MOVE	OS,SECNUM
	PJS	LONUM		;OUTPUT SECTION NUMBER
	MOVEI	W,"-"
	PJS	LOCN		;OUTPUT "-"
	MOVE	OS,PAGNUM
	PJS	LONUM		;OUTPUT PAGE NUMBER
	MOVEI	W,11
	PJS	LOCN		;TAB TO TITLE TEXT
	PJS	LOTTL		;LIST TITLE
	PJS	LOEOL		;END TITLE LINE
	SETZ	VS,		;COUNT SIZE OF FILE NAME
	SKIPN	L,ILUSR		;WAS A USER NAME SPECIFIED?
	JRST	LSRT4		;NO. GO PRINT FILE NAME.
	MOVEI	W,"("
	PJS	LOCN
	PJS	SYMSIZ		;SIZE OF FIRST WORD OF USER NAME.
	ADD	VS,W		;KEEP TRAK OF SIZE OF FILE NAME
	MOVEI	X,L
	PJS	LOSTR6		;PRINT FIRST WORD OF USER NAME
	SKIPN	L,ILUSR+1	;CHECK SECOND WORD OF USER NAME
	JRST	LSRT3
	PJS	SYMSIZ		;SIZE OF SECOND WORD
	ADD	VS,W
	MOVEI	X,L
	PJS	LOSTR6		;PRINT SECOND WORD
LSRT3:	MOVEI	W,")"
	PJS	LOCN
	ADDI	VS,2
LSRT4:	MOVE	L,IL+2		;GET FILE NAME
	PJS	SYMSIZ		;GET SIZE OF NAME
	ADD	VS,W
	MOVEI	X,L		;ADDRESS NAME
	PJS	LOSTR6		;OUTPUT FILE NAME
	HLLZ	L,IL+3		;GET EXTENSION
	JUMPE	L,LSRT2		;CHECK IF THERE IS ONE.
	MOVEI	W,"."
	PJS	LOCN		;OUTPUT "."
	PJS	SYMSIZ		;GET SIZE OF EXTENSION
	ADDI	VS,1(W)		;SIZE OF EXTENSION AND DOT
	MOVEI	X,L
	PJS	LOSTR6		;OUTPUT EXTENSION
LSRT2:	MOVEI	W,11
	CAIGE	VS,10		;CHECK IF 8 OR MORE CHARS IN FILE NAME
	PJS	LOCN		;IF NOT, TAB TO 8 CHARS
	CAIGE	VS,20		;CHECK IF 16 OR MORE CHARS IN FILE NAME
	PJS	LOCN		;IF NOT, TAB TO 16 CHARS
	CAIGE	VS,30		;CHECK IF 24 OR MORE CHARS IN FILE NAME
	PJS	LOCN		;IF NOT, TAB TO 24 CHARS
	MOVEI	W," "
	PJS	LOCN		;SKIP 1 MORE
	MOVEI	X,STLBF
	PJS	LOSTR		;OUTPUT SUBTITLE
	PJS	LOEOL		;END SUBTITLE LINE
	PJS	LOEOL		;BLANK LINE AFTER TITLE
LSRT5:	SKIPGE	LSTLN		;FIRST LINE OF TEXT?
	TRNN	F,CREF		;OUTPUTTING CREF?
	JRST	LSRT50		;NO
	PJS	BEGCRF
LSRT50:	TRNN	F,CREF		;AND CREF LISTING?
	RETURN			;NO
	TLNE	F,LSCNF		;WILL THIS BE A NEW LINE?
	JRST	LSRT51		;NO
	MOVEI	X,103		;OUTPUT AND INCREMENT CREF LINE NUMBER
	SKIPGE	LSTLN		;FIRST LINE OF TEXT?
	PJS	ENDCRF
	MOVEI	W,11		;TAB TO START OF LINE
	PJS	LOCN
	RETURN
LSRT51:	MOVEI	X,104		;JUST END CREF
	PJS	ENDCRF
	RETURN

LOTTL:	SKIPN	TTLBF		;IS THERE A TITLE?
	JRST	LOTTL1		;NO. DON'T PRINT IT
	MOVEI	X,TTLBF	
	PJS	LOSTR		;OUTPUT TITLE TEXT
	MOVEI	W," "
	PJS	LOC
	PJS	LOC
LOTTL1:	MOVEI	X,STDTTL
	PJS	LOSTR		;OUTPUT STANDARD TITLE
	RETURN

LONUM0:	PUSH	S,W		;OUTPUT DECIMAL NUMBER TO LISTING
LONUM:	IDIVI	OS,^D10
	JUMPG	OS,LONUM0	;CHECK IF MORE DIGITS
LONUM1:	ADDI	W,"0"		;CONVERT TO ASCII
	PJS	LOCN
	POP	S,W		;GET NEXT DIGIT OR RETURN
	TRNN	W,777740	;Is this the return address?
	JRST	LONUM1		;NO. MUST BE DIGIT
	JRST	(W)		;YES. RETURN ADDRESS

LOSTR:	HRLI	X,(POINT 7,0)	;OUTPUT ASCII STRING TO LISTING
LOSTR1:	ILDB	W,X
	JUMPE	W,[RETURN]	;STRING ENDS WITH NULL
	PJS	LOCN
	JRST	LOSTR1

LOSTR6:	HRLI	X,(POINT 6,0)	;OUTPUT SIXBIT WORD TO LISTING
LSTR61:	ILDB	W,X
	JUMPE	W,[RETURN]	;TERMINATE ON BLANK
	ADDI	W,40		;CONVERT TO ASCII
	PJS	LOCN
	TLNE	X,770000	;END OF SIXBIT WORD
	JRST	LSTR61		;NO
	RETURN			;TERMINATE ON SIX CHARACTERS

LOBYTE:				;OUTPUT BYTE TO LISTING FILE IN HEX FORMAT.
	LSHC	W,-4		;LEFT BYTE TO RIGHT OF W
	CAIL	W,12
	ADDI	W,7
	ADDI	W,60		;CONVERT TO HEX
	PJS	LOC
	SETZ	W,
	LSHC	W,4
	CAIL	W,12
	ADDI	W,7
	ADDI	W,60
	PJS	LOC
	TRNN	V,1
	RETURN
	MOVEI	W," "
	PJS	LOC		;BLANK AFTER HALFWORD
	RETURN

LOEOL:	MOVEI	W,15		;OUTPUT <CR>
	PJS	LOCN
	MOVEI	W,12		;OUTPUT <LF>
	PJS	LOCN
	SOS	LNLEFT		;DECREMENT LINES LEFT ON PAGE
	SETZM	TXTOUT		;SET NO TEXT OUTPUT YET
	RETURN

LOC:	PJS	LOCN		;OUTPUT CHARACTER
	AOJA	VS,[RETURN]	;AND COUNT IT

LOC0:	OUT	LCH,
	JRST	LOCN
	PE	MSLFF,ABORT
;
;	The following check is a double check to insure that
;	proprietary code cannot be listed. LOCN should never be called
;	if LSLOCK is set.
;
LOCN:	TRNE	F,LSLOCK
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	SOSGE	LOH+2
	JRST	LOC0
	IDPB	W,LOH+1
	RETURN

FILLHX:	SKIPN	LSTMSK		;IF PASS 1 LISTING, NO HEX TO FILL
	CAIL	VS,HEXSIZ	;HEX POSITIONS FULL?
	RETURN
	MOVEI	W,11		;TAB THRU HEX POSITIONS
	PJS	LOC
	ADDI	VS,7
	JRST	FILLHX

LSCOPY:	SKIPLE	LSTLN		;ANYMORE OF LINE TO LIST?
	JRST	LSC1A		;NO. JUST LIST NEW LINE.
	MOVE	VS,TXTOUT	;GET COUNT OF TEXT OUTPUT SO FAR
	SKIPE	SAVCHR		;CONTINUATION LINE?
	JRST	[MOVEI W,"*"	;YES. START LINE WITH "**"
		 PJS LOC
		 PJS LOC
		 JRST LSC0]
	SKIPL	LSTLN		;FIRST LINE?
	JRST	LSC0		;NO. DON'T SETUP POINTERS AGAIN
	SETZM	LSTLN		;SET PART OF LINE LISTED
	MOVE	C,BLSVP		;SET TO POINT AT BEGINNING OF LINE
	EXCH	I,LISTI
LSC0:	PJS	LSCHR		;GET FIRST CHARACTER OF LIST LINE
	CAIN	W," "		;IF IT IS A BLANK
	TLNN	F,LSCEOL	;AND LAST STATEMENT ENDED WITH A SEMICOLON
	JRST	LSC1		;NOT THE CASE
	TLNN	F,LSCNF		;AND THIS IS NOT A NOLIST OR UNTRUE IF
	MOVEI	W,"I"-100	;THEN REPLACE LEADING BLANK WITH TAB
LSC1:	JUMPE	W,LSC3		;END OF STATEMENT. GO OUTPUT TERMINATOR
	CAIN	W,15		;CARRIAGE RETURN?
	JRST	[PJS LSCHR	;YES. IGNORE LINEFEED
		 JRST LSC1A]
	CAIN	W,11		;TAB?
	JRST	[ANDCMI VS,7	;YES. MOVE TO NEXT TAB STOP
		 ADDI VS,7
		 JRST LSC1B]
LSC1B:	CAMGE	VS,TXTSIZ	;ROOM FOR THIS CHARACTER?
	JRST	LSC2		;YES
	MOVEM	W,SAVCHR	;NO. SAVE FOR REST OF LISTING
LSC1A:	PJS	LOEOL		;GO TO NEW LINE
	TLZ	F,LSCEOL+LSCNF	;INDICATE NEW LINE
	RETURN
LSC2:	PJS	LOC		;OUTPUT CHARACTER TO LISTING FILE
	PJS	LSCHR		;GET NEXT STATEMENT CHARACTER
	JRST	LSC1

LSC3:	AOS	LSTLN		;NO MORE OF LINE TO LIST
	LDB	W,I		;GET STATEMENT TERMINATOR
	CAIE	W,";"		;WAS TERMINATOR SEMICOLON?
	JRST	LSC4		;NO, WAS A <CR>
	TLNN	F,NOLIST
	SKIPE	TRUTH
	JRST	LSC5		;UNTRUE IF BODY
	TLOA	F,LSCEOL
LSC4:	TLZ	F,LSCEOL
	TLZ	F,LSCNF
	CAIN	W,14		;WAS LINE TERMINATED WITH <FF>?
	JRST	[SETZM LNLEFT	;FORCE TOP OF FORM AT "LSTART"
		 RETURN]
	PJS	LOEOL		;OUPUT <CR><LF>
	RETURN

LSC5:	PJS	LOC		;NOLIST OR UNTRUE IF BODY, LIST AS IS
	TLO	F,LSCEOL!LSCNF	;SET NOLIST/UNTRUE IF AND ; TERMINATOR
	MOVEM	VS,TXTOUT	;SAVE TEXT OUTPUT SO FAR
	RETURN

;GET CHARACTERS OF STATEMENT TO BE LISTED. STATEMENT WILL NORMALLY
;BE POINTER TO BY "LISTI" AND TERMINATE AT "I". IF THE INPUT SOURCE
;EVER CHANGED DUE TO END OF INPUT BUFFER OR A MACRO CALL, THEN
;THE BEGINNING OF THE STATEMENT WILL BE POINTED TO BY "BLSVP" AND
;WILL TERMINATE AT "LSVP".
LSCHR:	SKIPE	W,SAVCHR	;CHARACTER FROM PREVIOUS LINE?
	JRST	[SETZM SAVCHR	;YES. USE IT
		 RETURN]
	CAMN	C,LSVP		;ANYMORE TEXT IN SAVED BUFFER?
	JRST	LSCHR1		;NO. GET REST OF TEXT FROM MAIN SOURCE
	ILDB	W,C		;GET NEXT CHARACTER FROM SAVED BUFFER
	RETURN
LSCHR1:	ILDB	W,I		;GET NEXT MAIN BUFFER CHARACTER
	CAMN	I,LISTI		;IS THIS THE STATEMENT TERMINATOR
	TDZA	W,W		;YES. RETURN NULL INSTEAD
	JUMPE	W,LSCHR1	;IGNORE NULLS IN MAIN BUFFER
	RETURN

;MOVE ALL THE TEXT (EXCLUDING NULLS) BETWEEN "LISTI" AND "I" TO
;LIST SAVE BUFFER
LSVLNE:	SKIPGE	LSVCNT		;WAS BUFFER ALREADY FILLED?
	JRST	LSVL3		;YES. DON'T TYPE ERROR MESSAGE AGAIN.
LSVL1:	ILDB	C,LISTI		;GET NEXT CHARACTER TO SAVE
	CAMN	I,LISTI		;ANYMORE TEXT IN BUFFER
	RETURN			;NO. RETURN
	JUMPE	C,LSVL1		;IGNORE NULLS
	SOSGE	LSVCNT		;ANY ROOM IN BUFFER?
	JRST	LSVL2		;NO
	IDPB	C,LSVP		;PUT INTO LISTER SAVE BUFFER
	JRST	LSVL1
LSVL2:	PUSH	S,0		;SAVE TO TYPE ERROR
	TYPE	<$STATEMENT TRUNCATED IN LISTING.>
	POP	S,0
LSVL3:	MOVEM	I,LISTI		;RESET FOR NEXT MOVE
	RETURN
BLSVP:	POINT	7,LSTBUF	;POINTER TO BEGINNING OF BUFFER

; PUT DATE AND TIME IN STANDARD TITLE.
TTLDAT:	DATE	W,		;GET DATE FROM SYSTEM
	IDIVI	W,^D31		;W=(MONTH-1)+12*(YEAR-1964),X=DAY-1
	ADDI	X,1		;X=DAY
	MOVE	V,[POINT 7,STDTTL+2,20]
	IDIVI	X,^D10
	ADDI	X,"0"
	CAIN	X,"0"
	MOVEI	X," "
	IDPB	X,V
	ADDI	Y,"0"
	IDPB	Y,V
	IDIVI	W,^D12		;W=YEAR-1964,X=MONTH-1
	MOVE	X,MONTH(X)
	MOVEM	X,STDTTL+3
	MOVE	V,[POINT 7,STDTTL+4]
	ADDI	W,^D64		;W=YEAR-1900
	IDIVI	W,^D10
	ADDI	W,"0"
	IDPB	W,V
	ADDI	X,"0"
	IDPB	X,V
	MSTIME	X,		;GET TIME IN MILLISEC FROM SYSTEM
	IDIVI	X,^D1000*^D60	;CONVERT TO MINUTES
	IDIVI	X,^D60		;X=HOURS,Y=MINUTES
	IBP	V		;SKIP TO TIME FIELD
	MOVE	W,X
	IDIVI	W,^D10
	ADDI	W,"0"
	CAIN	W,"0"
	MOVEI	W," "
	IDPB	W,V
	ADDI	X,"0"
	IDPB	X,V
	IBP	V		;SKIP OVER ":"
	MOVE	X,Y		;GET MINUTES
	IDIVI	X,^D10
	ADDI	X,"0"
	IDPB	X,V
	ADDI	Y,"0"
	IDPB	Y,V
	RETURN

;	OUTPUT BEGIN CREF LISTING CODE IF NOT ALREADY OUT?
BEGCRF:	TROE	F,INCREF	;IS CODE ALREADY OUT?
	RETURN
	MOVEI	W,177		;OUTPUT BEGIN CREF CODE
	PJS	LOCN
	MOVEI	W,102
	PJS	LOCN
	RETURN

;	OUTPUT END CREF LISTING CODE. END CODE IN "X".
ENDCRF:	TRZN	F,INCREF
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVEI	W,177
	PJS	LOCN
	MOVE	W,X
	PJS	LOCN
	RETURN

;	COMPUTE NUMBER OF CHARACTERS IN SIXBIT SYMBOL IN "L".
;	RETURN IN "W".
SYMSIZ:	MOVEI	W,6		;ASSUME SIX CHARS IN LENGTH
	TDNN	L,SIXMSK-1(W)
	SOJG	W,.-1
	RETURN

SIXMSK:	EXP	770000000000,7700000000,77000000,770000,7700,77

;	OUTPUT SIXBIT SYMBOL IN "L" TO CREF FILE PRECEDED BY CODE IN "W".
OUTSYM:	PJS	LOCN
	PJS	SYMSIZ		;GET SYMBOL SIZE
	PJS	LOCN		;AND OUTPUT IT
	MOVEI	X,L		;ADDRESS SYMBOL
	PJS	LOSTR6		;AND OUTPUT IT
	RETURN
	SUBTTL	DIRECTIVE PROCESSORS
;		**************************************************

;DEFINE MACRO
DMAC:	SKIPN	L,LABEL		;NAME MUST BE IN LABEL FIELD
	PE	MSMLF,XPSBI	;ELSE ERROR
	HRLOI	X,237777	;SEE IF MACRO NAME IS USE OTHER
	MOVEM	X,MM1		; THAN AS A MACRO OR OPCODE
	PJS	FY
	SKIPE	M		;IS IT ALREADY IN USE
	PE	MMNIU,XPSBI	;YES. ERROR
	HRLOI	X,-<NMACA+1>	;INITIALIZE AGRUMENT COUNT
	MOVEM	X,NMARGS
	TLO	F,NOMACX	;DON'T ALLOW ARGS TO BE MACRO NAMES
	PJS	FBT		;FLUSH BLANKS AND TABS
	PJS	GCHR		;GET NEXT CHAR
	CAIE	C,"("		;ARGS MUST BE SURROUNDED BY PARENS
	JRST	DMAC6		;NO ARGS
DMAC1:	PJS	GK
	MOVE	X,NMARGS
	XCT	DMAC7(U)	;FOR NOW, MUST BE SYMBOL
DMAC7:	PE	MSSE,XPSBI
	PE	MSSE,XPSBI
	JRST	DMAC0
	JRST	DMAC0
	PE	MSSE,[RETURN]
	PE	MSSE,[RETURN]
	PE	MSSE,[RETURN]
DMAC0:	AOBJP	X,[ PE MTMMA,[RETURN]]
	MOVEM	L,MACARG(X)
	MOVEM	X,NMARGS
	PJS	GK
	CAMN	C,CT+","	;MORE ARGS IF COMMA
	JRST	DMAC1
	CAME	C,CT+")"	;DONE IF RIGHT PAREN
	PE	MSSE,XPSBI1	;ELSE ERROR
	TRO	F,MBSCAN	;set scanning macro body
DMAC2:	PJS	GCHR		;GET NEXT CHAR
DMAC6:	CAIE	C,15		;SKIPPING OVER CARRIGE RETURN
	JRST	DMAC61		;NO
	INCLC		;YES. INCREMENT LINE COUNTER
DMAC61:	CAIE	C,"["		;SEARCH FOR MACRO BODY START
	JRST	DMAC2
	AOS	X,NMARGS	;ADD ONE TO ARGUMENT COUNT
	HRRZM	X,NMARGS	;AND REMOVE BOUND CHECK
	MOVEI	Y,MBMAX*MBSIZ	; Number of characters in macro buffer
	MOVEM	Y,MACCNT	; Save for character insertion
	MOVEI	Y,MACBUF	; Byte pointer to start of macro buffer
	HRLI	Y,(POINT 7,0)
	SETZ	U,		;INIT BRACKET COUNT FOR DEFS WITHIN DEFS
	SETOM	ALWARG		;ALLOW DUMMY ARGUMENT
DMAC3:	ILDB	C,I
DMAC5:	MOVE	V,CT(C)		;GET CHAR TYPE
	XCT	DMAC4(V)	;Dispatch on character type

;	DISPATCH TABLE.
DMAC4:	CIT	DMAC3		;GET MORE CHARACTERS
;		 CRAP   DIGIT   A-F    a-f    G-Z    g-z
	JV	<DMACST,DMACDG,DMACSY,DMACSY,DMACSY,DMACSY>
;		   .      OPER  DELIM   |
	JV	<DMACSY,DMACST,DMACEM,DMACST>
	MEND	DMAC3		;MACRO END
	JRST	DMACCA		;' (CONCATENATION OPERATOR)
	MARG	DMAC3		;MACRO ARGUMENT
	MAE	DMAC3		;MACRO ARG END

DMACEM:	CAIN	C,"]"		;MAYBE END OF MACRO BODY
	SOJL	U,DMACDN	;GO FINISH IF OUTER BRACKET
	CAIN	C,"["		;IS THIS START OF ANOTHER MACRO
	AOJ	U,		;YES. INCREMENT BRACKET COUNT
	CAIE	C,15		;SKIPPING OVER CARRIAGE RETURN
	JRST	DMACST		;NO
	INCLC		;YES. INCREMENT LINE COUNTER
DMACST:	SETOM	ALWARG		;ALLOW DUMMY ARG AFTER BREAK CHAR
DMAST1:	PJS	PUTMCH		;STUFF CHAR INTO STRING STORAGE
	JRST	DMAC3

DMACDG:	SETZM	ALWARG		;DO NOT ALLOW ARG AFTER DIGIT
	JRST	DMAST1

;CONCATENATION OPERATOR
DMACCA:	ILDB	C,I		;GET NEXT CHAR
	CAIN	C,"]"		;END MACRO CHAR IS SPECIAL CASE - TAKE LITERALLY
	JRST	DMACST
	CAIN	C,"`"
	JRST	DMACST
	SETOM	ALWARG		;ALLOW ARG AFTER CONCATENATION
	JRST	DMAC5		;GET ARG STRING (MAYBE)

DMACSY:	SKIPN	ALWARG		;WAS PREVIOUS CHAR A BREAK?
	JRST	DMAST1		;NO. DON'T SCAN FOR DUMMY ARG
	MOVE	M,[POINT 7,MSYSAV]	;INIT BYTE POINTER TO SAVE ARG
	SETZ	L,		;BUILD SIXBIT SYMBOL NAME IN L
	MOVE	W,[POINT 6,L]
DMASY7:	IDPB	C,M		;STUFF CHAR INTO SAVE AREA
	XCT	DMASY1(V)	;CONVERT TO SIXBIT OR FINISH UP
	TLNN	W,770000	;SIX CHARS COLLECTED ALREADY?
	JRST	DMASY4		;YES. DO NAT SAVE ANYMORE
	IDPB	C,W		;NO. PUT INTO NAME
DMASY5:	ILDB	C,I		;GET NEXT CHARACTER
	MOVE	V,CT(C)		;GET CHARACTER TYPE
	JRST	DMASY7

;	ANOTHER DISPATCH TABLE
DMASY1:	CIT	DMASY6		;GET MORE CHARACTERS
	JRST	DMASY3		;GARBAGE CHARACTERS
	SUBI	C,40		;DIGIT
	SUBI	C,40		;A-F
	ANDI	C,77		;a-f
	SUBI	C,40		;G-Z
	ANDI	C,77		;g-z
	MOVEI	C,'.'		; .
;		  OPR    DELIM   |
	JV	<DMASY3,DMASY3,DMASY3>
	MEND	DMASY6		;MACRO END
	JRST	DMASY3		;' CONCATENATION OPERATOR
	MARG	DMASY6		;MACRO ARGUMENT
	MAE	DMASY6		;MACRO ARG END

DMASY6:	ADD	M,BACKUP	;BACKUP OVER TRAP CHARACTER
	JRST	DMASY5

DMASY4:	SETZM	ALWARG		;IF ARG ENDED WITH ALPHA, DO NOT ALLOW ARG
DMASY3:	ADD	I,BACKUP	;BACK UP TEXT PTR
	MOVE	X,NMARGS	;GET ARG COUNT
DMASY2:	SOJL	X,DMASY8	;SEE IF SYMBOL IS ARG
	CAME	L,MACARG(X)
	JRST	DMASY2
	MOVEI	C,1		;INSERT MACRO ARG CHAR
	PJS	PUTMCH
	AOS	C,X		;ADJUST ARG INDEX TO RANGE 1-NMARGS
	PJS	PUTMCH		;AND PUT IN MACRO BODY
	JRST	DMAC3
DMASY8:	SETZ	C,		;PUT NULL AT END OF SAVED TEXT
	DPB	C,M
	MOVE	M,[POINT 7,MSYSAV]	;POINT TO BEGINNING
DMASY9:	ILDB	C,M		;GET NEXT SAVED CHARACTER
	JUMPE	C,DMAC3		;EXIT IF END
	PJS	PUTMCH		;PUT INTO MACRO TEXT
	JRST	DMASY9

DMACDN:	TRZ	F,MBSCAN	;clear scanning for macro body
	MOVEI	C,"C"-100
	PJS	PUTMCH		;STUFF MACRO END CHAR
	SKIPGE	MACCNT		;is macro text too big?
	JRST	DMACD1		;yes. don't define.
	PJS	FMACD		; Move definition to free space
	MOVE	VS,MCHCNT	; Get number of blocks in definition
	LSH	VS,9		; BLOCK ADDRESS IN BITS 0-17, BLOCK SIZE
	ADD	VS,NMARGS	; IN BITS 18-26 AND NUMBER OF ARGUMENTS
	HRL	VS,MACTXT	; IN BITS 27-35.
	HRLZI	U,2		;SPECIFY MACRO MODULE
	SETZ	L,		;GET MACRO NAME TO L
	EXCH	L,LABEL
	PJS	DOM		;MAKE SYMTAB ENTRY
	RETURN
DMACD1:	TYPE	<Macro body for macro >
	MOVE	U,LABEL
	PJS	TYP6		;type name of macro
	TYPE	< too big>
	SETZM	LABEL		;insure label is not defined
	RETURN

;	Put character in macro definition buffer. Insure that it will fit

PUTMCH:	SOSL	MACCNT		; Anymore room in buffer
	IDPB	C,Y		; Yes. Put in buffer
	RETURN

;
; Request a block of size specified by MCHCNT. Return address in MACTXT.
; Get block from list, choosing largest block or if none large enough,
; get new memory.
;
GMACD:	MOVE	X,MCHCNT	; Number of cells needed
	CAIE	X,1		; Is only a single cell needed?
	JRST	GMACD1		; No.
	GFL			; Get a single cell from free list
	HRRZM	W,MACTXT	; Save address of single cell
	RETURN
GMACD1:	MOVEI	W,MACFRE	; Get list header
GMACD2:	HRR	W,(W)		; Get next list entry
	CAMGE	X,1(W)		; Is largest block too big?
	JRST	GMACD2		; Yes, go try next
	CAMG	X,1(W)		; Is block the same size as needed?
	JRST	GMACD3		; Yes, go use it
	HLR	W,(W)		; Get previous block
	CAMG	X,1(W)		; Is it big enough?
	JRST	GMACD3		; Yes. Use it
	HRRZ	W,YEND		; Get block from new memory
	MOVEM	W,MACTXT	; Save beginning of block
	ADD	W,MACCNT	; Add size of block needed in words
	TLNN	W,777777	; Is request past end of memory
	CORE	W,		; Extend memory for new block
	PJS	GME		; Out of memory
	MOVE	W,MACTXT	; Get beginning of block
	ADD	W,MACCNT	; Add size of block needed in words
	MOVEM	W,YEND		; Save new end of memory
	RETURN
GMACD3: PJS	REMBLK		; Remove block from free list
	HRRZM	W,MACTXT	; Save address of start of block
	MOVE	V,1(W)		; Get size in cells of block to use
	SUB	V,MCHCNT	; Compute number of cells not used
	JUMPE	V,[RETURN]	; Perfect fit. Nothing more to do
	MOVE	Y,MCHCNT	; Get number of blocks used
	IMULI	Y,3		; Convert to number of words
	ADD	W,Y		; Compute address of left over block
	PJS	REMAC		; Return to free list
	RETURN

;	Move MACBUF to free storage.

FMACD:	MOVE	V,MACCNT	; Get number of characters remaining
	IDIVI	V,MBSIZ		; Convert to blocks
	MOVEI	W,MBMAX		; Get total number of blocks allocated
	SUB	W,V		; Compute number of blocks used
	MOVEM	W,MCHCNT	; Save number of blocks used
	IMULI	W,3		; Compute number of words used
	MOVEM	W,MACCNT	; Save count of words in new block
	PJS	GMACD		; Get portion of free storage
	HRLI	X,MACBUF	; Source address for block move
	HRR	X,MACTXT	; Destination address for block move
	HRRZI	Y,-1(X)		; Get destination address minus one
	ADD	Y,MACCNT	; Address of last word in destination
	BLT	X,(Y)		; Move MACBUF to free storage
	RETURN

XPSBI1:	CAIG	U,3		;DID LAST TOKEN CAUSE I TO BE BACKED UP
XPSBI:	IBP	I		;YES. RESTORE IT FOR "GSF" BACKUP
	RETURN

;DELETE SYMBOLS
DKIL:	PUSH	S,F		;SAVE FLAG WORD DURING SCAN
	TLO	F,NOMACX	;SUPPRESS MACRO EXPANSIONS
DKIL0:	PJS	GK		;GET NEXT SYMBOL NAME
	JV	<.+1(U),DKIL0,DKILE,DKIL1,DKIL1,DKILE,DKILE,DKILE>
DKILE:	PE	MSSE,DKIL2
DKIL1:	TRNE	F,CREF		;CREF LISTING?
	PJS	[MOVEI W,1	;YES. RECORD SYMBOL REFERENCE
		 PJS   OUTSYM
		 RETURN]
	PJS	DELSYM
	PJS	GCHR
	CAIN	C,","		;CONTINUE IF COMMA
	JRST	DKIL0
	POP	S,F		;RESTORE FLAG WORD
	RETURN
DKIL2:	POP	S,F		;RESTORE FLAG WORD
	JRST	XPSBI1

;	Global directive.
;
DGL:	PJS	GK		;GET LEADING BLANKS OR AN ASCI SYMBOL
	JV	<.+1(U),DGL,DGLE,DGL2,DGL2,DGLE,DGLE,DGLE>
DGLE:	PE	MSSE,XPSBI1	;SYNTAX ERROR
DGL2:	TRNN	F,CREF		;cross output needed?
	JRST	DGL5		;no
	MOVEI	W,1		;symbol definition
	PJS	OUTSYM
	MOVEI	W,17		;global symbol
	PJS	LOCN
DGL5:	HRLZI	U,200000	;module mask for only globals
	EXCH	U,MM1		;set as mask for symbol search
	PJS	FY		;is the symbol already global?
	EXCH	U,MM1		;restore current module mask
	JUMPN	M,DGL3		;if already global, nothing to do
	PJS	FY		;symbol already defined?
	JUMPN	M,DGL4		;yes, just change its module
	SETZ	V,		;set value zero (empty undefined chain)
	HRLZI	U,SYUNDF+1	;set undefined in module 1 (global module)
	PJS	MY
DGL3:	PJS	GCHR
	CAIN	C,","
	JRST	DGL		;CONTINUE IF COMMA
	RETURN
DGL4:	TRNN	F,MKSHAD	;making shadow table?
	JRST	DGL1		;no
	PJS	SHOLD		;save old definition
	HLL	U,M		;get old flags
	TLZ	U,77		;change to module 1 for globals
	TLO	U,1
	PJS	SHNEW
DGL1:	TLZ	M,77		;CHANGE TO MODULE 1 (GLOBAL)
	TLO	M,1
	HLLM	M,(M)
	JRST	DGL3

DLIST:	TLZ	F,NOLIST	;TURN ON LISTING
	PJS	FBT		;FLUSH BLANKS AND TABS TO OPERANDS
	CAIE	C,";"		;CHECK FOR NO OPTIONS
	CAIN	C,15
	JRST	XPSBI
	CAIN	C,":"
	JRST	XPSBI
	SETO	V,		;SET NO OPTIONS FOUND SWITCH
LIS1:	MOVE	W,[ANDCM F,Y]	;ASSUME SWITCH BEING SET
	PJS	GCHR		;GET NEXT OPTION CHARACTER
	CAIN	C,"-"		;IS SWITCH BEING RESET?
	PJS	[MOVE W,[IOR F,Y]	;YES.
		 PJS  GCHR	;GET NEXT OPTION CHARACTER
		 SETZ V,	;RESET NO OPTIONS FOUND SWITCH
		 RETURN]
	MOVNI	X,NLSTOP	;NUMBER OF LIST OPTIONS
LIS2:	HRRZ	Y,LSTOP+NLSTOP(X) ;GET OPTION CHARACTER
	CAME	C,Y		;IS THERE A MATCH
	AOJL	X,LIS2		;NO. TRY NEXT OPTION.
	JUMPE	X,[JUMPL V,LIS3	;OK IF NO OPTION FOUND
		   PE MSILO,[RETURN]]
	SETZ	V,		;RESET NO OPTIONS FOUND SWITCH
	HLLZ	Y,LSTOP+NLSTOP(X) ;GET BIT TO SET
	SKIPN	DSW		;ONLY SET IF DIRECT STATEMENT
	SKIPL	LSTMSK		;OR INDIRECT IN PASS 2
	XCT	W		;SET OR RESET IT
	PJS	GCHR
	CAIN	C,","		;END OF OPTION LIST?
	JRST	LIS1		;NO. GET ANOTHER OPTION
LIS3:	SKIPN	MACSTK		;IS A MACRO CALL?
	RETURN			;NO
	TRZ	F,SUPLST	;YES. SET SUPPRESS MACRO EXPANSION
	TLNE	F,LSX		;IF -X SWITCH IS NOW SET.
	TRO	F,SUPLST
	RETURN

LSTOP:	XWD	LSL,"L"		; List nolist lines
	XWD	LSF,"F"		; List untrue if lines
	XWD	LSR,"R"		; List all of repeat loops
	XWD	LSX,"X"		; List macro expansions
	XWD	LSI,"I"		; List conditional stements
NLSTOP==.-LSTOP

DNLIST:	SKIPN	DSW		;SET SWITCHES IF DIRECT STATEMENT.
	SKIPL	LSTMSK		;DON'T SET LIST FLAGS IF NOT LISTING
	TLO	F,NOLIST
	JRST	XPSBI

;"TITLE" DIRECTIVE
DTTL:	MOVE	X,CHPLN		;GET PAGE LENGTH
	SUBI	X,TTLMIN	;COMPUTE TITLE BOUND
	SKIPN	DSW		;DIRECT STATEMENT
	JRST	DTTL1		;NO
	TRO	F,LSTDTL	;SET DEFAULT TITLE TO BE LISTED.
	MOVEI	W,DTTLBF	;PUT TEXT IN DEFAULT TITLE BUFFER
	JRST	DTTL2
DTTL1:	SKIPE	LSTMSK		;IS THIS PASS 2
	TRNN	F,LPASS2	;OR IS THERE NO PASS TWO LISTING?
	JRST	XPSBI		;YES. IGNORE TITLE
	TRZN	F,TTLFND	;HAS A TITLE ALREADY BEEN FOUND?
	PE	MSOTPF,XPSBI	;YES. ERROR
	TRO	F,LSTTTL	;SET TITLE TO BE LISTED.
	MOVEI	W,TTLBF		;PUT TEXT IN TITLE BUFFER
DTTL2:	PJS	GETTXT
	SETZM	SECNUM		;START A SECTION ONE
	JRST	XPSBI

;"SUBTTL" DIRECTIVE
DSTL:	MOVE	X,CHPLN		;GET LINE SIZE
	SUBI	X,STLMIN	;COMPUTE SUBTITLE BOUND
	TRNE	F2,CRFLST
	SUBI	X,10
	SKIPN	DSW		;DIRECT STATEMENT
	JRST	DSTL1		;NO
	MOVEI	W,DSTLBF	;PUT SUBTITLE IN DEFAULT BUFFER
	PJS	GETTXT
	JRST	XPSBI
DSTL1:	MOVEI	W,STLBF		;PUT TEXT IN SUBTITLE BUFFER
	SKIPN	LSTMSK		;PASS 1?
	JRST	DSTL2		;NO. PASS 2
	TRNN	F,LPASS1+LPASS2	;WILL THERE BE A LISTING?
	JRST	XPSBI		;NO. IGNORE SUBTITLE
	TRNN	F,LPASS2	;WILL LISTING BE IN PASS 2?
	TROA	F,NEWSEC	;NO. IN PASS 1. START NEW SECTION
	TRZE	F,FSBTTL	;PASS 2 LISTING. IS THIS FIRST SUBTITLE?
	PJS	GETTXT
	TRNN	F,LSTTTL	;IS TITLE TO BE LISTED?
	TRZ	F,NEWSEC	;NO TITLE. NO NEW SECTION.
	JRST	XPSBI
DSTL2:	TRNE	F,LSTTTL	;IS TITLE TO BE LISTED?
	TRZE	F,FSBTTL	;FIRST SUBTITLE IN PASS 2?
	JRST	XPSBI		;YES.IGNORE
	TRO	F,NEWSEC	;START NEW SECTION ON NEXT PAGE
	PJS	GETTXT
	JRST	XPSBI

GETTXT:	SETZM	(W)		;INSURE FIRST WORD OF NULL TITLE =0
	HRLI	W,(POINT 7,0)	;CONSTRUCT BYTE POINTER
	PJS	GCHR		;IGNORE LEADING BLANK OR TAB
	CAIE	C,";"		;CHECK IF END OF LINE
	CAIN	C,15
	JRST	GTXT2
GTXT1:	PJS	GCHR
	CAIE	C,";"		;CHECK FOR END OF TITLE
	CAIN	C,15
	JRST	GTXT2		;END OF TITLE
	SOJLE	X,[PE MSTTL,GTXT2] ;CHECK FOR TITLE TOO LONG
	IDPB	C,W
	JRST	GTXT1
GTXT2:	SETZ	C,		;END TITLE WITH NULL
	IDPB	C,W
	ADD	I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
	RETURN

;	"NOTTL" DIRECTIVE
DNOTTL:	SKIPN	DSW		;DIRECT STATEMENT?
	JRST	DNTTL1		;NO
	TRZ	F,LSTDTL	;SET NOT TO LIST DEFAULT TITLE.
	JRST	XPSBI
DNTTL1:	SKIPE	LSTMSK		;PASS 2?
	TRNN	F,LPASS2	;OR LISTING HAPPENING IN PASS 1?
	JRST	XPSBI		;YES. IGNORE DIRECTIVE.
	TRZ	F,LSTTTL	;SET TO NOT LIST TITLE.
	JRST	XPSBI

;"SEG" DIRECTIVE
DSEG:	PJS	GE		;PICK UP ARG
	SOJG	U,[RETURN]	;check for undefined or illegal expr
	CAIL	V,0		;CHECK RANGE
	CAILE	V,17
	PE	MSSNOR,[RETURN]
	MOVE	W,CURSEG	;SAVE CURRENT PC
	MOVE	X,PC
	MOVEM	X,SEGTAB(W)
	CAMLE	X,SEGTOP(W)	;IS PC>MAX(PC)
	MOVEM	X,SEGTOP(W)	;YES. SET MAX(PC)=PC
	MOVEM	V,CURSEG	;UPDATE CURRENT SEGMENT
	MOVE	V,SEGTAB(V)	;GET NEW PC
	JRST	DORG1		;UPDATE PC, PROCESS LABEL

DEN:;	END DIRECTIVE
	HRLZI	W,400000
	IORM	W,PCL
	TLO	F,ENDFND	;SET END FOUND FLAG.
	TLNE	F,EOFF		;END OF FILE?
	RETURN
	JRST	XPSBI

DREM:	;REMARK DIRECTIVE. COPY REST OF STATEMENT TO CONTROLLING TTY.
	SKIPL	LSTMSK
	JRST	XPSBI		;PASS 1 ONLY
	PJS	GCHR		;REMOVE LEADING BLANK
	CAIE	C,";"		;CHECK FOR END OF STATEMENT
	CAIN	C,15
	RETURN
DREM1:	PJS	GCHR
	CAIE	C,";"
	CAIN	C,15
	RETURN			;COPY TO STATEMENT DELIMITER
	TRNN	F,PRPTOK	;if remark started in non proprietary code
	TRNN	F,PRPCOD	;and now in proprietary code
	SKIPA
	JRST	DREM1		;then don't print proprietary remark
	CAIN	C,"%"
	JRST	DREM2
	OUTCHR	C
	JRST	DREM1
DREM2:	PJS	TYPEOL
	JRST	DREM1		;OUTPUT % AS CAR.RET. L.F.

DNUM:	;CONVERT NUMBER TO CURRENT RADIX AND TYPE IT ON CONTROLLING TTY
	PJS	GE
	SOJG	U,[RETURN]	;check for undefined or illegal expr
	MOVE	Y,TRADIX
	SKIPGE	LSTMSK
	PJS	TN
	RETURN

DLNO:	;Return the current line number as the value of the directive
	MOVE	V,LC		;Get current line number
	JRST	DEQ1		;Use as value to be EQuated to label

DNADV:	;Return the NAD version as an octal number
	MOVEI	V,VERSION	;Get version
	IMULI	V,^D<16*16>	;Move left two hex digits
	ADDI	V,REVISION	;Add on revision
	JRST	DEQ1		;Use as value to be EQuated to label

DERRCT:	;Return the number of assembly errors encountered so far
	MOVE	V,ERRCNT	;Get error count
	JRST	DEQ1		;Use as value to be EQuated to label

DUNCT:	;Return the number of undefined's currently in symbol table
	SETZ	V,		;Start with no undefined symbols
	MOVNI	VS,HASHSZ	;get size of table
DUNCT1:	HRRZ	OS,EYH(VS)	;Get next table entry;
DUNCT2:	JUMPE	OS,DUNCT3	;End of chain, go to next.
	SKIPGE	W,(OS)		;undefined
	AOJ	V,		;Yes
	HRRZ	OS,W		;Get next pointer in chain.
	JRST	DUNCT2
DUNCT3:	AOJL	VS,DUNCT1
	JRST	DEQ1

DCGMT:	;Return the current time in network time, seconds since 1/1/74
	MOVE	V,GMTVAL	;Get GMT saved at assembly start
	SKIPE	DSW		;Is it direct?
	PJS	GETGMT		;Yes, compute GMT
	JRST	DEQ1		;Go equate to label

GETGMT:	DATE	V,		;get current date in time zone
	MOVEM	V,TIMFIX	;save for conversion
	TIMER	V,		;get time since midnight in jiffies
	MOVEM	V,TIMFIX+1	;and also save
	MOVE	V,[XWD 0,400020]
	MOVEM	V,TIMFIX+2
	MOVEI	V,TIMFIX
	DATUUO	V,		;convert to GMT and days since 1/1/64
	JFCL
	MOVE	V,TIMFIX	;get days since 1/1/64
	SUBI	V,^D<3653>	;convert to days since 1/1/74 for ISIS
	IMULI	V,^D<24*60*60>	;convert to seconds since 1/1/74
	EXCH	V,TIMFIX+1	;get jiffies since midnight
	IDIVI	V,^D<60>	;convert to seconds since midnight
	ADD	V,TIMFIX+1	;add seconds to midnight from 1/1/74
	RETURN
	
DQUIT:	;Abort assembly. Clear command files and input buffer. If operand
	;is true, return to executive level. Otherwise return to NAD debug level.
	PJS	GE		;Get operand
	SOJG	U,[RETURN]	;Error if U = 2 or 3
	PJS	CFACLS		;Close all command files.
	CLRBFI
	JUMPG	V,NADEX		;If operand true (>0), exit NAD
	JRST	ABORT		;Otherwise just abort the assembly.

DRE:;	REPEAT DIRECTIVE
	SKIPE	RPPTR		;IS THIS OUTER REPEAT BLOCK?
	JRST	DRE1		;NO, DON'T SAVE PLACE
	MOVE	W,LC		;STORE STATE INFORMATION
	MOVEM	W,RELINE	;FOR ERROR HANDLING
	DMOVE	W,LLABEL
	DMOVEM	W,RELABL
DRE1:	PJS	GE
	MOVE	W,RPPTR
	CAIL	W,RPMAX
	PE	MSTMNR,DREE
	XCT	.+1(U)
	JRST	DRE0
	JRST	DRE0
	JRST	DREE
	PE	MSEI,DREE
DREE:	SETOM	RPF		;MARK REPEAT FAULT. NULIFY FUTURE REPEAT FUNCTIONS.
	RETURN

DRE0:	MOVEM	V,RPC(W)	;STORE INITIAL REPEAT COUNTER
	TLZ	V,777700	;CONVERT VALUE TO ADDRESS CONSTANT
	TLO	V,400000	;SET TO ONLY LIST "PC"
	MOVEM	V,PCL
	SETOM	RPL(W)		;FLAG FOR LISTING
	SKIPN	RPPTR
	JRST	DRE2		;IF OUTER BLOCK
	SKIPN	RPL-1(W)	;TEST BLOCK OUTSIDE THIS ONE
	SETZM	RPL(W)		;IF NOT 1ST TIME THROUGH
DRE2:	MOVE	X,LINEI
	MOVEM	X,RLINEI(W)
	LDB	C,I		;GET STATEMENT TERMINATION CHARACTER
	MOVE	C,CT(C)		;GET CHARACTER TABLE ENTRY
	PJS	GSTS
	MOVEM	I,RPI(W)	;MARK THE BEGINNING OF REPEAT RANGE
	MOVE	X,LC
	MOVEM	X,RPLC(W)
	MOVE	X,MACCUR	;save current macro invocation number
	MOVEM	X,RPMAC(W)
	AOS	RPPTR
	RETURN

DER:	PJS	GE		;END REPEAT DIRECTIVE
	SKIPG	W,RPPTR
	PE	MSMES,DREE
	SKIPE	MACSTK		;is repeat in a macro?
	JRST	DER1		;yes. repeat loop all in memory. don't restrict loop size.
	HRRZ	X,I		;MAKE SURE REPEAT RANGE NOT LONGER THAN ONE SIDE BFR
	HRRZ	Y,RPI-1(W)
	SUB	X,Y
	SKIPGE	X
	ADDI	X,NSB*201
	CAIL	X,201
	PE	MSRRGT,DREE
DER1:	MOVE	X,MACCUR	;get current macro invocation number
	CAME	X,RPMAC-1(W)	;has it changed?
	PE	MSMEIR,DREE	;yes. error
	MOVE	X,V
	TLZ	X,777700	;CONVERT VALUE TO ADDRESS CONSTANT
	TLO	X,400000	;SET TO ONLY LIST "PC"
	MOVEM	X,PCL
	SKIPE	RPF
	RETURN
	SETZM	RPL-1(W)	;CLEAR LISTING FLAG
	XCT	DERX(U)
	SOSA	RPPTR		;END OF REPEATING
	SKIPA	X,LEC		;REPEAT SOME MORE
	RETURN
	JUMPE	X,.+4
	PUSH	S,W
	PJS	TLE
	POP	S,W
	MOVE	X,RLINEI-1(W)
	MOVEM	X,LINEI
	MOVE	I,RPLC-1(W)
	MOVEM	I,LC
	MOVE	I,RPI-1(W)
	MOVEM	I,LISTI		;ADJUST LISTER SAVE POINTER
	TLO	F,ENDRPT	;SET END REPEAT FOR LISTER
	SETZM	LLABEL
	RETURN

DERX:	SKIPG	V
	SOSG	RPC-1(W)
	JRST	DREE
	PE	MSEI,DREE

DIF:	SKIPE	IFC		;ONLY DO FOR OUTER IF
	JRST	DIF1
	MOVE	W,LC		;SAVE STATE INFORMATION
	MOVEM	W,IFLINE	;IN CASE OF ERRORS
	DMOVE	W,LLABEL
	DMOVEM	W,IFLABL
DIF1:	PJS	GE		;GET ARG VALUE
	AOS	W,IFC
	CAIL	W,45
	PE	MSTMI,DEI1	;CHECK DEPTH
	MOVE	X,LBIT-1(W)
	ANDCAM	X,ELSESW	;CLEAR ELSE FLAG
	JUMPN	U,DIFER		;ARG WAS UNDEFINED - REPORT ERROR
	JUMPLE	V,DIF2		;FALSE ARG. DONT INCR IFT.
	TLNE	F,UTRUIF
	JRST	DIF4		;DONT ASSEMBLE. DEEP INTO UNTRUE LEVELS.
	AOS	IFT		;SET IFT=IFC
	ORM	X,ELSESW	;MARK THIS LEVEL AS UNAVAILABLE TO TRUE ELSE
DIF2:	TLZ	V,777700	;CONVERT VALUE TO ADDRESS CONSTANT
	TLO	V,400000	;SET TO ONLY LIST "PC"
	MOVEM	V,PCL
DIF3:	TLZ	F,UTRUIF
	MOVE	V,IFC		;GET STATE OF IF. TRUE OR UNTRUE.
	CAME	V,IFT
	TLO	F,UTRUIF
DIF4:	TRO	F2,CONDST	; Indicate that this is conditional statement
	RETURN
DIFER:	PE	MSEI,DIF2

DELSE:	PJS	GE
	SOJG	U,DIFER		;GET ASSEMBLE TRUE/FALSE ARG
	SKIPL	U
	MOVEI	V,1		;SET NULL ARG TO TRUE
	SKIPG	W,IFC
	PE	MSNEP,DIF4
	SUB	W,IFT
	JUMPLE	W,DELSE1	;THIS IF LEVEL HAS JUST RUN AS TRUE
	JUMPLE	V,DIF2		;FALSE ELSE. DO NOTHING. HE MIGHT GIVE ANOTHER ELSE.
	SOJG	W,DIF2		;IFC-IFT GREATER THAN 1. CANT ASSEMBLE.
	MOVE	W,IFT
	MOVE	X,LBIT(W)
	TDNN	X,ELSESW
	AOS	IFT		;TURN ON A ELSE RANGE
	ORM	X,ELSESW	;BUT NOT AGAIN UNTIL THIS LEVEL HAS BEEN REGAINED IN
	JRST	DIF2
DELSE1:	SETZ	V,		;RETURN VALUE OF FALSE FOR LISTING
	SOS	IFT
	JRST	DIF2

DEI:	SKIPG	W,IFC
	PE	MSNEP,XPSBI
	CAMG	W,IFT
	SOS	IFT
DEI1:	SOS	IFC
	IBP	I
	JRST	DIF3

DBND:				;BOUND STATEMENT
;FORCE PC TO (PC+(ARG-1))&-ARG WHERE ARG IS A POWER OF 2
	PJS	GE		;GET ARG VALUE
	SOJG	U,[RETURN]	;check for undefined or illegal expr
	JFFO	V,DBND2		;GET NUMBER OF FIRST BIT
	RETURN			;DONE IF ZERO
DBND2:	SETO	W,		;FORM ONES IN RESISTER
	MOVN	U,U		;NEGATE ZERO BIT COUNT
	LSH	W,-1(U)		;FORM 000001...11
	AND	V,W		;FORM 000000...XX
	JUMPE	V,DBND5		;CHECK FOR PURE POWER OF 2 IN ORIG ARG
	LSH	W,1		;NOT SO, GO TO NEXT POWER OF 2
	PUSH	S,DSW		;SAVE DIRECT SWITCH
	SETOM	DSW		;SET SWITCH NOT TO COUNT AS ERROR
	PE	MBND,.+1	;PUT OUT WARNING
	POP	S,DSW		;RESTORE DIRECT SWITCH
DBND5:	MOVE	V,W		;COPY MASK
;	MOVN	U,V
;	MOVEI	V,-1(V)
;	MOVE	W,V		;CHECK THAT ARG IS A POWER OF 2
;	AND	W,U
;	SKIPE	W
;	PE	MAMBP2,[RETURN]
	ADD	W,PC		;ROUND UP
;	AND	V,U
	ANDCA	V,W		;MASK OFF BITS WITH COMP. OF BIT MASK
	JRST	DORG1

DORG:				;ORIGIN STATEMENT
	PJS	GE
	SOJG	U,[RETURN]	;ERROR IF U = 2 OR 3
DORG1:	CAML	V,[1_24]	;IS PC A LEGAL ADDRESS?
	PE	MSSPCO,[RETURN]
	MOVEM	V,PC
	MOVE	W,CURSEG	;REFERENCE CURRENT SEGMENT
	CAMLE	V,SEGTOP(W)	;IS PC>MAX(PC)?
	MOVEM	V,SEGTOP(W)	;YES. SET MAX(PC)=PC
	MOVEM	V,PCL
	SKIPN	LABEL
	RETURN
	JRST	DEQ1

DEQ:				;DEFINE LABEL FIELD ACCORDING TO OPERAND EXPRESSION
	PJS	GE
	SOJG	U,[RETURN]	;ERROR IF U = 2 OR 3
DEQ1:	MOVE	W,V
	TLZ	W,377700
	TLO	W,400000
	MOVEM	W,PCL
	MOVE	VS,V
	HRLZ	U,MODULE
	SETZ	L,
	EXCH	L,LABEL
	JUMPE	L,[PE MSMLF,[RETURN]]	;ERROR EXIT IF NO LABEL FIELD
	PJS	DY
	RETURN

DBS:	HRLZI	W,400000
	IORM	W,PCL		;DEFINE BYTE STORAGE
	PJS	GE
	SOJG	U,[RETURN]
DBS1:	JUMPL	V,[PE MSNRS,[RETURN]] ;CHECK FOR NEGATIVE
	ADD	V,PC		;GET NEW PC
	CAML	V,[1_24]	;IS NEW PC TOO LARGE
	PE	MSSPCO,[RETURN]	;YES
	MOVEM	V,PC		;STORE NEW PC
	RETURN

DHS:				;DEFINE HALFWORD STORAGE
	HRLZI	W,400000
	IORM	W,PCL
	PJS	GE
	SOJG	U,[RETURN]
	LSH	V,1
	JRST	DBS1

DWS:				;DEFINE WORD STORAGE
	HRLZI	W,400000
	IORM	W,PCL
	PJS	GE
	SOJG	U,[RETURN]
	LSH	V,2
	JRST	DBS1

DBC:	MOVEM	W,@DOTP		;SAVE PC FOR MEMORY STORE
	PJS	GE		;BYTE CONSTANT DIRECTIVE
	AOS	PC
	SOJG	U,[RETURN]	;check for undefined or illegal expr
	CAML	V,[-400]
	CAIL	V,400
	PE	MSOOR,.+1
	MOVE	W,@DOTP
	CA
	CDPB	V,W
	JRST	DC9

DHC:; PROCESS HALFWORD CONSTANT
	MOVEM	W,@DOTP		;SAVE PC FOR MEMORY STORE
	MOVEI	W,2
	ADDM	W,PC
	PJS	@GECALL
	XCT	.+1(U)		;DISPATCH ACCORDING TO GE RESULTS
	JV	<DHC0,DHC0,DHC2>
	PE	MSIE,[RETURN]

DHC0:	CAML	V,[-200000]
	CAIL	V,200000
	PE	MSOOR,DC9
	MOVE	W,@DOTP
	CA	H
	CDPB	V,W
	JRST	DC9

DHC2:	SETZ	U,		;HALFWORD IS CHAIN DATA TYPE 0
	SETZ	Y,
	EXCH	Y,UCC		;UNDEFINED CHAIN IF ANY
	MOVE	VS,PC
	SUB	VS,[1_43+2]
	PJS	SPLICE
	JRST	DC9

DWC:	MOVEM	W,@DOTP		;SAVE PC TO STORE DATA
	MOVEI	W,4
	ADDM	W,PC
	PJS	@GECALL	;WORD CONSTANT DIRECTIVE
	XCT	.+1(U)
	JRST	DWC0
	JRST	DWC0
	SOJA	U,DWCU
	PE	MSIE,[RETURN]
DWCU:				;U=1 WHICH IS WORD CONSTANT DATA TYPE FOR CHAINING LOGIC
	SETZ	Y,
	EXCH	Y,UCC
	MOVE	VS,PC
	SUB	VS,[1_43+4]
	PJS	SPLICE
	JRST	DC9

DWC0:	CAML	V,[-1_40]
	CAML	V,[1_40]
	PE	MSOOR,DC9
	MOVE	W,@DOTP
	CA	H
	ROT	V,-20
	CDPB	V,W		;LEFT HALF
	TLZ	W,220000	;MAKE BYTE PTR GO TO RIGHT HALF
	ROT	V,20
	CDPB	V,W
DC9:	HLRZ	W,C		;SEE IF MORE CONSTANTS IN THIS STATEMENT
	CAIE	W,COM
	RETURN
	MOVE	W,PC
	JRST	PCV2

DXC:				;DEFINE BYTE STRING FROM PAIRS OF HEX CHRS
	PJS	FBT
DXC1:	PJS	GCHR
	MOVE	W,CT(C)		;Lookup character type
	SETZ	V,
	XCT	DXCX(W)		;Dispatch on character type
	LSH	V,4
	PJS	GCHR
	MOVE	W,CT(C)		;Lookup character type
	XCT	DXCX(W)		;Dispatch on character type
	PJS	DPBV
	JRST	DXC1
DXCX:	CIT	DXC1		;LOOK FOR MORE INPUT
	PE	MSIH,[RETURN]
	IORI	V,-60(C)
	IORI	V,-67(C)
	IORI	V,-127(C)
	REPEAT	4,<PE	MSIH,[RETURN]>
	RETURN

DSC:				;DEFINE STRING CONSTANT. LIKE AC WITH LEADING BYTE FOR STRING LENGTH.
	SETOM	PCV1
	AOS	PC
	SKIPA
DAC:	SETZM	PCV1
	PJS	FBT		;DEFINE ASC STRING
	PJS	GCHR
	MOVE	Y,C		;STRING DELIMITER
	CAIE	Y,15
	CAIN	Y,";"
	RETURN			;IS IT A STATEMENT DELIMITER?
DAC1:	PJS	GCHR
	CAMN	C,Y
	JRST	DAC2
	CAIE	C,15
	CAIN	C,";"
	PE	MSANPT,[RETURN]
	CAIN	C,CHRIT
	CIT	DAC1		;LOOK FOR MORE INPUT
	CAIN	C,42
	JRST	DACX		;GET HEX IF CHR IS "
	MOVEI	V,200(C)	;PREPARE BYTE WITH PARITY ALWAYS ON
	PJS	DPBV
	JRST	DAC1
DAC2:	SKIPN	PCV1
	RETURN
	MOVE	W,@DOTP
	MOVE	V,PC
	SUBI	V,1(W)
	CA
	CDPB	V,W
	RETURN

DACX:	ILDB	C,I		;GET FIRST CHR OF HEX PAIR
	MOVE	W,CT(C)		;Lookup character type
	SETZ	V,
	XCT	DACXX(W)	;Dispatch on character type
	LSH	V,4
	PJS	GCHR
	MOVE	W,CT(C)		;Lookup character type
	XCT	DACXX(W)	;Dispatch on character type
	PJS	DPBV
	JRST	DAC1

DACXX:	CIT	DACX		;LOOK FOR MORE INPUT
	PE	MSIH,[RETURN]
	IORI	V,-60(C)
	IORI	V,-67(C)
	IORI	V,-127(C)
	REPEAT	5,<PE	MSIH,[RETURN]>

DMO:;		DEFINE MODULE
	PJS	GE		;GET ORIGIN
	SOJG	U,[RETURN]	;check for undefined or illegal expr
	CAMN	C,[COM,,DE]
	SKIPL	U		;CHECK FOR NULL EXPR
	PE	MSIORG,[RETURN]
	MOVEM	V,MOORG		;SAVE ORIGIN TIL STATEMENT BEYOND ERROR TRAPS
	PJS	GK
	XCT	MNX(U)
	MOVNI	W,44
	SETZ	Y,		;FIND SLOT IN MODULE TABLE
DMO1A:	SKIPN	X,MOA+44(W)
	MOVE	Y,W		;REMEMBER UNUSED SLOT
	CAMN	L,X
	JRST	DMO2
	AOJL	W,DMO1A
	SKIPN	W,Y
	PE	MS36MI,XPSBI
DMO2:	MOVEI	W,44(W)		;MODULE INDEX
	MOVEM	L,MOA(W)	;SAVE ASC
	MOVE	X,MOORG
DMO3:	MOVEM	W,MODULE
	HLLZ	V,MM
	TLZ	V,37777
	IOR	V,LBIT(W)
	MOVEM	V,MM
	MOVEM	X,MOORG(W)
	MOVEM	X,PC
	MOVE	W,CURSEG	;REFERENCE CURRENT SEGMENT
	CAMLE	X,SEGTOP(W)	;IS PC>MAX(PC)?
	MOVEM	X,SEGTOP(W)	;YES. SET MAX(PC)=PC.
	JRST	XPSBI

DEM:				;OUTPUT MODULE BOUNDS
	SKIPN	LSTMSK
	JRST	DEM1
	PJS	TYPEOL
	MOVE	W,MODULE
	MOVE	U,MOA(W)
	PJS	TYP6		;MODULE NAME
	OUTCHI	" "
	MOVE	V,MOORG(W)
	MOVEI	Y,20
	PJS	TN		;INITIAL PC
	OUTCHI	" "
	MOVE	V,PC
	MOVEI	Y,20
	PJS	TN		;ENDING PC
	MOVE	M,MODULE
	MOVE	M,LBIT(M)
	PJS	TU		;TYPE UNDEFINEDS

DEM1:	MOVEI	W,4
	MOVE	X,PC
	JRST	DMO3

DFO:	ANDCA	W,MM		;DEFINE MODULE AS FOREIGN.
DLO:	IOR	W,MM		;DEFINE MODULE AS LOCAL.
	HRRZM	V,DFODLO	;SAVE PTR TO DFO OR DLO INSTRUCTION
DL1:	PJS	GK		;GET ASC STRING
	JV	<.+1(U),DL1,MNX(U),DL2,DL2,MNX(U),MNX(U),MNX(U)>
DL2:	MOVNI	W,44		;SCAN FOR ASC
	CAME	L,MOA+44(W)
	AOJL	W,.-1
	JUMPE	W,MNX
	MOVE	W,LBIT+44(W)
	XCT	@DFODLO
	MOVEM	W,MM
	JRST	XPSBI

DUS:	PJS	FBT
	PJS	GK		;GET MODULE NAME
	XCT	MNX(U)
	MOVNI	X,44
	CAME	L,MOA+44(X)
	AOJL	X,.-1
	JUMPN	X,.+2
	PE	MSUE,XPSBI
	MOVEM	X,FX2
	PJS	GR
	MOVE	X,FX2
	MOVEM	V,MOUSE+44(X)
	MOVE	W,LBIT+44(X)
	IORM	W,MM
	RETURN

MNX:	PE	MSMNI,XPSBI	;BLANK OR TAB
	PE	MSMNI,XPSBI	;NUMBER
	JFCL			;SYMBOL
	JFCL			;UNDEFINED SYMBOL
	REPEAT	3,<PE	MSMNI,[RETURN]>	;OPERATOR,DELIMITER,ILLEGAL

DUN:				;TYPE OUT ALL UNDEFINED SYMBOLS. INHIBIT DEN FROM TYPING ANY.
	SETOB	M,UNSW
	SKIPGE	LSTMSK
	PJS	TU
	JRST	XPSBI

DRA:	PJS	GE		;GET RADIX
	SOJG	U,[RETURN]	;check for undefined or illegal expr
	JUMPE	U,DRAE		;CHECK FOR NULL EXPR
	CAILE	V,20
DRAE:	PE	MSRV,[RETURN]
	JUMPL	V,DRAE
	SKIPN	V
	MOVEI	V,20
	MOVEM	V,RADIX
	RETURN
	SUBTTL	INSTRUCTION PROCESSORS
;		**************************************************


LPSR:	PJS	GR
	JUMPE	W,RR0		;2 OPERANDS - TREAT AS NORMAL RR FORMAT INSTRUCTION
	MOVEI	U,1(V)		;WEIRD FORMAT IF 1 OPERAND
	ANDI	U,17
	LSH	U,4
	IORM	U,OPCODE
	JRST	RR2

RR:;		REGISTOR TO REGISTOR INSTRUCTION
SF:	SFV==RRV
	PJS	GR		;BUILD RR INSTRUCTION
RR0:	LSH	V,4
	IORM	V,OPCODE
	JUMPN	W,RR2		;NO MORE ARGUMENTS
RR1:	PJS	GR
	SKIPN	W		;CHECK FOR EXTRANEOUS OPERANDS
	PE	MTMO,.+1
RR2:	IOR	V,OPCODE
	CDPB	V,PCP
	RETURN

BF:	PJS	GR		;BACKWARD FORWARD. CREATE SPECIAL SF INSTRUCTION.
	JUMPN	W,[PE MSMOF,[RETURN]]
	DPB	V,[POINT 4,OPCODE,31]
BF1:	PJS	@GECALL
	SOJLE	U,BF4		;DEFINED VALUE
	SOJE	U,.+2
	PE	MSIE,[RETURN]
;		UNDEFINED SHORT FORMAT OPERAND
	GFL
	MOVEI	X,BFO
	MOVEM	X,(W)		;SET COMPUTE CHAIN OPERATOR
	HRRZ	V,OPCODE
	MOVEM	V,1(W)		;SAVE INSTRUCTION WITHOUT PC DIFF
	SETZM	2(W)
	MOVE	VS,PC
	SUB	VS,[1_43+2]
	SETZ	Y,
	EXCH	Y,UCC
	JUMPE	Y,BF2
	HRRM	W,2(Y)
	JRST	BF3		;CONNECT COMPUTE CHAIN AND OPCODE CONSTANT
BF2:	HRL	Y,W		;MAKE SIMPLE COMPUTE CHAIN INCLUDING OPCODE VALUE
BF3:	HRR	Y,W		;END OF COMPUTE CHAIN
	PJS	SPLICE
	RETURN
BF4:	SUB	V,@DOTP
	MOVE	W,OPCODE
	TRNN	W,400
	MOVN	V,V
	ROT	V,-1
	TDNN	V,[-20]
	JRST	RR2
	PE	MSOOR,[RETURN]

RX0:	SKIPA	V,LBIT		;RX BUT R1 FIELD IS ALWAYS 0
RX:	LDB	V,[POINT 4,OPCODE,31]	;SEE IF R1 IS PART OF OPCODE
	PJS	G3
	HRLZI	V,-1
	JUMPN	W,.+2
	PJS	GR
	MOVEM	V,SX2
	SKIPE	GSEC
	RETURN

;	SET U=0 IF RX1,2/ U=1 IF RX3/U=2 IF RX1,2 UNDEFINED/ U=3 IF RX3 UNDEFINED
	SETZ	U,
	SKIPL	SX2
	AOJA	U,RXF0
	MOVE	V,DISP
	TDNN	V,[-1_16]
	JRST	RXF0
;	ATTEMPT RELATIVE TO P.
;	DISPLACEMENT=[DISP-(INCREMENTED PC)]&77777+100000
	SUB	V,PC		;PC WAS INCREMENTED IN PC22
	CAML	V,[-40000]	;IS IT TOO FAR BEHIND CURRENT PC
	CAIL	V,40000		;IS IT TOO FAR BEYOND CURRENT PC
	PE	MSOOR,[RETURN]	;ADRS OUT OF RANGE
	IORI	V,100000	;TELL CPU TO EXECUTE RX2 ADDRESSING
RXF0:	SKIPE	UDISP		;is expression undefined?
	ADDI	U,2
	JV	<.+1(U),RX1,RX3,RX1U,RX3>

RX1:	CDPB	V,PCP1
	RETURN

RX3:	LDB	V,[POINT 8,DISP,19]
	ROT	V,-10
	HRR	V,SX2
	IORI	V,100(V)
	ROT	V,10
	CDPB	V,PCP1
	MOVEI	W,2
	ADDB	W,PC
	SUBI	W,2
	MOVE	V,DISP
	CA	H
	CDPB	V,W
	CAIE	U,3
	RETURN
	SETZ	Y,		;UNDEFINED RX3 DISPLACEMENT
	EXCH	Y,UCC
	MOVE	VS,PC
	SUB	VS,[1_43+2]
	PJS	SPLICE
	RETURN

RX1U:	SETZ	Y,
	EXCH	Y,UCC
	MOVE	VS,PC
	SUB	VS,[1_43+2]
	PJS	SPLICE
	RETURN

G3:				;GET 3 OPERANDS:	R1,DISP, AND FX2
	SETZM	DISP
	SETZM	FX2
	SETZM	UDISP
	HRRM	V,R1
	JUMPN	V,G3A		;R1 ALREADY KNOWN
	PJS	GR		;NO
	MOVEM	V,R1
	JUMPN	W,G3B		;NO MORE ARGS
G3A:	SETZM	RUSING
	PJS	@GECALL
	MOVEM	V,DISP
	CAIN	U,2		;is value undefined?
	SETOM	UDISP		;yes. record
	HLRZ	W,C
	SUBI	W,COM		;INDEX FIELD DELIMITED BY COMMA OR LEFT BRACKET
	JUMPE	W,G3C
	SUBI	W,LBRAK-COM
	JUMPN	W,G3B
G3C:	PJS	GR		;GET FIRST X2
	SOJN	U,.+3
	LDB	V,[POINT 6,(M),17]
	HRRZ	V,MOUSE(V)
	MOVEM	V,FX2
G3B:	MOVE	Y,R1
	ROT	Y,4
	IOR	Y,FX2
	IOR	Y,OPCODE
	CDPB	Y,PCP		;STORE FIRST HALFWORD OF INSTRUCTION
	RETURN

RI:	SETZ	V,
	PJS	G3
	SKIPE	GSEC
	RETURN
	SKIPN	W
	PE	MTMO,.+1
	SKIPE	UDISP		;is it undefined?
	JRST	RI1U
	MOVE	V,DISP
	CDPB	V,PCP1
	RETURN
RI1U:	SETZ	U,
	SETZ	Y,
	EXCH	Y,UCC
	MOVE	VS,PC
	SUB	VS,[1_43+2]
	PJS	SPLICE
	RETURN

RI2:	SETZ	V,
	PJS	G3
	SKIPE	GSEC
	RETURN
	SKIPN	W		;CHECK FOR EXTRANEOUS OPERANDS
	PE	MTMO,.+1
	SKIPE	UDISP		;is it undefined?
	JRST	RI2U
	MOVE	W,DISP
	CDPB	W,PCP2
	LSH	W,-20
	CDPB	W,PCP1
	RETURN
RI2U:	SETZ	Y,
	EXCH	Y,UCC
	MOVE	VS,PC
	ADD	VS,[1_43-4]
	MOVEI	U,1
	PJS	SPLICE
	RETURN

GR:	PJS	GE		;GET REGISTER FIELD
	TDZE	V,[-20]
	PE	MSRNB,.+1	;MORE THAN FOUR BIT
	HRRZ	W,C
	CAIE	W,DE
	JRST	GRIRF
	HLR	W,C
	HRRZI	W,-COM(W)	;W = 0 IF REGISTOR FOLLOWED BY A COMMA
	XCT	.+1+COM(W)
	RETURN
	RETURN
	RETURN
	JV	<GRIRF,GRIRF,GRIRF,GRIRF>
	RETURN
	RETURN
	RETURN
	RETURN
	RETURN
GRIRF:	POP	S,1(S)		;SKIP BACK A LEVEL
	RETURN			;AND RETURN
	SUBTTL	ERROR HANDLERS
;		**************************************************


TYPEI:	HRRZ	0,40		;get address of message
	HRLI	0,(POINT 7,0)	;construct byte pointer
	MOVEM	0,2(S)		;save it
TYPE1:	ILDB	0,2(S)		;get next character of ASCIZ message
	JUMPE	0,[RETURN]	;end on null
	CAIN	0,"$"		;carriage return?
	JRST	TYPE2		;yes
	OUTCHR	0
	JRST	TYPE1
TYPE2:	PJS	TYPEOL
	JRST	TYPE1

QER1:	MOVEM	W,(S)		;THIS UUO DOES NOT RETURN TO CALLER PLUS 1
	MOVE	W,IFC		;IGNORE ERRORS INSIDE UNTRUE IFS
	CAME	W,IFT
	JRST	PE1
	MOVE	W,LEC
	CAIL	W,20
	JRST	PE1		;LIMIT ERROR STACK TO 20
	PUSH	S,X
	HLL	X,@40
	HLRZM	X,PET1(W)	;SAVE MSG ADRS
	MOVE	X,MACI
	SKIPN	MACN		;IS A MACRO EXPANSION HAPPENING?
	MOVE	X,I		;NO. USE "I". OTHERWISE USE "MACI"
	MOVEM	X,PET2(W)	;CHARACTER POSITION WHERE ERROR WAS FOUND
	AOS	LEC
	AOS	GSEC
	SKIPN	DSW		;is error in source file
	AOS	ERRCNT		;yes, then count it for ERRCNT directive
	POP	S,X
PE1:	POP	S,W		;DECREMENT STACK BEFORE NON POPJ RETURN
	HRRZ	W,@40		;PICK UP RETURN ADDRESS
	EXCH	W,1(S)		;RESTORE W
	JRST	@1(S)


PF:	TYPE	<$Assembler bug or program failure at location >
	HRRZ	V,(S)
	MOVEI	Y,10
	PJS	TN
	JRST	NADAB

TLE:				;TYPE LINE ERRORS
	PUSH	S,I		;SAVE TEXT BYTE POINTER
	PUSH	S,F		;SAVE FLAGS WORD
	TRO	F,SUPLST	;DON'T DO ANY LISTING ACTION
	SKIPE	DSW		;direct assembly
	JRST	TLE7		;yes. just type message
	PJS	TYPEOL
	TYPE	<***>
	MOVE	V,LC
	MOVEI	Y,12
	PJS	TN		;TYPE LINE NUMBER
	TRNE	F,LSLOCK	;if not listing
	JRST	TLE7		;then don't list line even in error message
	SKIPN	U,LLABEL
	JRST	TLE0
	PJS	BL3
	PJS	TYP6		;TYPE OUT LAST LABEL
	MOVE	V,LC
	SUB	V,LLC		;LOCAL LINE COUNT FROM LAST LABEL
	JUMPE	V,TLE0
	OUTCHI	"+"
	MOVEI	Y,12
	PJS	TN
TLE0:	PJS	TYPEOL
;	SKIPL	MACN		;NO LINE IF LEFT MACRO EXPANSION
;	TLNE	F,EOFF		;DON'T COPY LINE IF IT DOESN'T EXIST
	SKIPGE	MACN		;NO LINE IF LEFT MACRO EXPANSION
	JRST	TLE7
	MOVE	Y,MACI		;END AT "MACI" IF IN EXPANSION
	SKIPN	MACN		;IN EXPANSION
	MOVE	Y,I
	MOVE	I,LINEI		;SETUP TO COPY HIS LINE
TLE1:	PJS	GCHR
	OUTCHR	C
	MOVE	0,C
	CAMN	I,Y
	JRST	TLE2
	TLNN	F,EOFF		;AT AN EOF, STOP AT NULL
	JRST	TLE1A		;DON'T DO THE FOLLOWING IF NOT AT EOF
	ILDB	C,I		;PEEK AT NEXT CHAR
	JUMPE	C,TLE2		;STOP AT NULL, SINCE LINK HAS BEEN DESTROYED
	ADD	I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
TLE1A:	PJS	GCHR		;READ NEXT CHAR, SKIPPING OVER MACRO STUFF
	ADD	I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
	CAME	I,Y		;CHECK FOR END OF ERROR LINE
	JRST	TLE1
TLE2:	CAIE	0,12
	PJS	TYPEOL

	MOVE	I,LINEI
	SETZ	W,
	MOVNI	X,2
TLE3:	CAMN	I,PET2(W)
	JRST	TLE3A
	PJS	GCHR
	ADD	I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
	CAME	I,PET2(W)
	JRST	TLE3B
TLE3A:	MOVEI	X,101(W)
	OUTCHR	X
	CAMN	I,PET2+1(W)
	AOJA	W,.-1
	AOJA	W,TLE3C
TLE3B:	CAIE	C,11
	JRST	TLE3B1
	OUTCHR	C
	AOJA	X,TLE3C		;CHECK FOR TAB
TLE3B1:	AOSE	X
	OUTCHI	" "
TLE3C:	CAMGE	W,LEC
	JRST	[PJS	GCHR
		 JRST	TLE3]
	SETZ	W,
TLE4:	HRRZI	X,101(W)
TLE4A:	PJS	TYPEOL
	OUTCHR	X
	PJS	BL3
	OUTSTR	@PET1(W)
	SOSG	LEC
	JRST	TLE9
	MOVE	V,PET2(W)
	CAME	V,PET2+1(W)
	AOJA	W,TLE4
	AOJA	W,TLE4A
TLE9:	POP	S,F		;RESTORE FLAG WORD
	POP	S,I		;RESTORE TEXT POINTER
	SKIPG	VS,UCERC	;ANY ADDRESS CHAIN FAILURES?
	RETURN
	SETZB	OS,UCERC	;YES, TYPE OUT THE PC S WHERE THE ERROR WAS RECORDED
TLE9A:	PJS	TYPEOL
	OUTCHI	11
	OUTCHI	11		;CR, LF, TAB, TAB
	TYPE	<Operand out of range at PC = >
	MOVE	V,UCPCT(OS)
	MOVEI	Y,20
	PJS	TN
	ADDI	OS,1
	SOJG	VS,TLE9A
	RETURN

TLE7:	SETZ	W,
TLE7A:	PJS	TYPEOL
	OUTSTR	@PET1(W)
	SOSLE	LEC
	AOJA	W,TLE7A
	JRST	TLE9

QPC:	BAR	<W>		;PUT THE PROGRAM COUNTER IN REG. 0 ON THE ERROR QUE
	MOVE	W,UCERC
	CAIGE	W,UCERN
	AOS	W,UCERC
	MOVEM	0,UCPCT-1(W)
	RETURN

;	TYPE UNDEFINED SYMBOLS FOR MODULE MASK M
;	  EXIT WITH Y < 0 IF ANY UNDEFINEDS.
;	  ENTER AT TUN TO CHECK UNDEFINEDS BUT DO NOT TYPE OUT
TU:	SETO	Y,
	SKIPA
TUN:	HRROI	Y,0		;LARGE MINUS NUMBER
	MOVNI	VS,HASHSZ
TU1:	SKIPE	OS,EYH(VS)
	JRST	TU3		;BEGINNING OF SYMBOL CHAIN
TU2:	AOJL	VS,TU1
	SETCA	Y,
	RETURN
TU3:	SKIPGE	W,(OS)
	JRST	TU5		;UNDEFINED FLAG IS ON
TU4:	HRRZ	OS,W
	JUMPE	OS,TU2
	JRST	TU3
TU5:	LDB	X,[POINT 6,W,17]
	TDNN	M,LBIT(X)
	JRST	TU4		;DONT TYPE OUT THIS UNDEFINED SYMBOL
	JUMPGE	Y,TU5A
	AOSGE	Y
	RETURN			;FLAG UNDEFINEDS ONLY
	TYPE	<$***Undefined symbols$>
TU5A:	MOVE	U,1(OS)		;PICK UP SIXBIT
	TRNN	Y,100
	JRST	.+3
	PJS	TYPEOL
	SETZ	Y,
	PJS	TYP6
	ADD	Y,TYP6C
	OUTCHI	" "
	AOJ	Y,
	JRST	TU4
	SUBTTL	MISCELLANY
;		**************************************************


DPBV:	AOS	W,PC		;DEPOSIT BYTE AND ADVANCE PC
	SUBI	W,1
	CA
	CDPB	V,W
	RETURN

UUO:	MOVEM	W,1(S)
	LDB	W,[POINT 5,40,8]
	MOVE	W,UUOTAB-30(W)
	EXCH	W,1(S)
	XCT	1(S)
UUOTAB:	JV	<ITP,QER1,MACEND,MARG1,MAEND,TYPEI>

MACEND:	HRR	C,40		;RETURNS TO ARG
	HRRM	C,(S)
	TRNN	F,SUPLST+ASONLY	;IS THE LISTER RUNNING
	PJS	LSVLNE		;SAVE STATEMENT TEXT
	PUSH	S,W		;SAVE "W" AND "V" FOR CALL TO R"REMAC"
	PUSH	S,V
	SKIPN	W,MACSTK	;IS THIS REALLY A MACRO END
	CPF			;NO. ABORT
	HRRZ	V,(W)		;POP TOP BLOCK OFF STACK
	MOVEM	V,MACSTK
	HLRZ	V,(W)		;GET SIZE OF BLOCK
	PJS	REMAC		;RETURN MEMORY TO FREE STORAGE
	MOVE	V,IPSTK		;pointer to current stack entry
	MOVE	V,2(V)		;get previous macro invocation number
	TRZ	F,PRPCOD	;clear setting of proprietary from macro	
	TLZE	V,400000	;was caller proprietary?
	TRO	F,PRPCOD	;yes, restore proprietary code indicator
	MOVEM	V,MACCUR	;and make it current
	POP	S,V
	POP	S,W
	PJS	RESIP		;RESTORE PREVIOUS TEXT POINTER
	SKIPN	MACN		;DOES THIS END MACRO WHICH STARTED LINE
	MOVEM	I,MACI		;YES. SAVE END OF MACRO
	SOS	MACN		;REDUCE MACRO STACK COUNT
	TRNN	F,SUPLST+ASONLY
	SOSGE	LSVCNT		;ANY ROOM IN BUFFER?
	JRST	MACEN1		;NO
	MOVEI	C,"]"		;BRACKET END OF MACRO EXPANSION
	IDPB	C,LSVP		;YES.
MACEN1:	MOVEM	I,LISTI		;AND SAVE FOR LISTING
	SKIPN	MACSTK
	TRZ	F,SUPLST
	TRZ	F2,CONDST	; Forget that this is a conditional statement
	RETURN

MARG1:	HRR	C,40		;RESTURNS TO ARG OF CALLER
	HRRM	C,(S)
	TRNN	F,SUPLST+ASONLY	;IS LISTER RUNNING
	PJS	LSVLNE		;YES. SAVE STATEMENT TEXT FOR LISTER
	ILDB	C,I		;GET ARG INDEX
	PJS	SAVIP		;SAVE PTR TO MACRO BODY
	SKIPN	I,MACSTK	;ABORT IF NO MACRO
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	ADD	C,I		;COMPUTE ADDRESS OF ARG BYTE POINTER
	ADD	I,(C)		;GET ARG BYTE POINTER
	MOVEM	I,LISTI		;SAVE TEXT POINTER FOR LISTER
	RETURN

MAEND:	HRR	C,40		;MACRO ARG END
	HRRM	C,(S)		;RETURNS TO ARG
	SKIPN	MACSTK		;MACRO IN PROGRESS?
	CPF			;NO. ABORT
	TRNN	F,SUPLST+ASONLY	;IS LISTER RUNNING
	PJS	LSVLNE		;YES. SAVE BEGINNING OF STATEMENT
	PJS	RESIP		;RESTORE POINTER
	MOVEM	I,LISTI		;YES. SAVE TEXT POINTER
	RETURN


CASUB:	LSHC	W,-2		;W(RIGHT) = WORD ADDRESS
	LDB	X,[POINT 2,X,1]	;X = BYTE COUNT
	HLL	W,CATAB(X)	;W(LEFT) = BYTE ADDRESS
	LDB	X,[POINT 7,W,24]	;X = PAGE
	TRZ	W,-4000		;W = BYTE ADDRESS WITHIN PAGE
	XCT	PGT(X)
	MOVEM	X,LPG
	RETURN
CAHSUB:	LSHC	W,-2
	LDB	X,[POINT 2,X,1]
	HLL	W,CATABH(X)
	LDB	X,[POINT 7,W,24]
	TRZ	W,-4000
	XCT	PGT(X)
	MOVEM	X,LPG
	RETURN
CAKSUB:	LSHC	W,-2
	LDB	X,[POINT 2,X,1]
	HLL	W,CATABK(X)
	LDB	X,[POINT 7,W,24]
	TRZ	W,-4000
	XCT	PGT(X)
	MOVEM	X,LPG
	RETURN

;	SAVE AND RESTORE INPUT TEXT POINTERS. USED BY MACRO CALLS TO SAVE
;	BYTE POINTER TO PREVIOUS INPUT SOURCE. THE STACK CONSISTS OF
;	BLOCKS FROM THE FREE LIST. THE FIRST WORD OF EACH BLOCK CONTAINS
;	THE ADDRESS OF THE PREVIOUS STACK ENTRY OR ZERO IF THE
;	BOTTOM ENTRY. THE SECOND WORD CONTAINS THE SAVED BYTE POINTER.
;	THE CELL "IPSTK" CONTAINS THE ADDRESS OF THE TOP OF THE STACK OR
;	ZERO IF THE STACK IS EMPTY. IF A RESTORE IS ATTEMPTED FROM
;	AN EMPTY STACK, THE ASSEMLER ABORTS BY CALLING THE PROGRAM FAILURE
;	ROUTINE

SAVIP:	PUSH	S,W		;NEED ONE REGISTER
	GFL			;GET A WORD FROM FREE LIST
	MOVEM	I,1(W)		;STORE PREVIOUS INPUT POINTER
	EXCH	W,IPSTK		;HAVE STACK POINT TO NEW ENTRY
	HRRZM	W,@IPSTK	;HAVE NEW ENTRY POINT TO REST TO STACK
	POP	S,W
	RETURN

RESIP:	PUSH	S,W		;NEED ONE REGISTER
	SKIPN	W,IPSTK		;IS STACK EMPTY
	CPF			;YES. SHOULD NOT HAPPEN. ABORT
	MOVE	I,(W)		;GET POINTER TO REST OF STACK
	MOVEM	I,IPSTK		;HAVE STACK POINT TO REST
	MOVE	I,1(W)		;GET PREVIOUS INPUT TEXT POINTER
	DFL	W		;RETURN TOP OF STACK TO FREE LIST
	POP	S,W
	RETURN
	SUBTTL	DEBUGGER COMMAND INTERPRETER
;		**************************************************


CRIZ:	MOVEM	S,CRS		;FIRST ENTRY SPOT TO DDT
CRESC1:
	PJS	DECLIC		;Reduce license to frame license
	MOVE	W,[-1,,.GTPRV]	;Get current frames privledges
	GETTAB	W,
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	TRZ	F2,TYMPRP	;Assume frame does not have Tymshare license
	TDNE	W,[JP.TYM]	;and check if it does
	TRO	F2,TYMPRP	;and if so, remember that it does
	MOVE	W,[-1,,.GTFPN]	;Get files PPN that NAD came from
	GETTAB	W,
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVEM	W,NADFPN	;Save it for proprietary check
	PJS	INTSET		;REENTRY POINT
	MOVEI	W,1000		;BREAK-ON-PUNCTUATION BIT
	SETMOD	W,		;SET FILE STATUS BITS
	SKIPN	JE		;WAS OBJECT FILE OPEN?
	JRST	CRESC2		;NO
	OPEN	JCH,JSPEC	;YES
	JRST	OJFE
	SETZM	JE+2
	SETZM	JE+3
	LOOKUP	JCH,JE
	JRST	OJFE
	SETZM	JE+2		;CLEAR LOOKUP BLOCK
	SETZM	JE+3
	ENTER	JCH,JE		;REOPEN THE FILE
	JRST	OJFE
CRESC2:	HRROI	W,16
	SETO	X,
	AUXCAL	W,X
	MOVEM	X,OBR		;OUTPUT BAUD RATE
	SETOM	CN		;RESET AUX CIRCUIT NUMBER

;	POPULAR ENTRY POINTS TO COMMAND RECOGNITION
CR:	PJS	TYPEOL		;ENTER HERE TO TYPE <CR>,<LF> AND CLOSE MEMORY
CR1:	SETZM	OPEN		;HERE TO CLOSE MEMORY ONLY
CR2:	SETZM	CMACNT		;HERE TO DO NEITHER OF ABOVE
	SETOM	ICCHR
	SETOM	ICCTRM		;set ic command to output terminator
	SETOM	DSW		;DIRECT STATEMENTS ASSEMBLED
	MOVEI	W,IC2		;ENGINE command arg kludge
	MOVEM	W,ICJMP
	TRZ	F,CREF		;INSURE DIRECT STATEMENTS DON'T CREF
	MOVE	I,[POINT 7,CS]
	SETZM	BC		;INITIALIZE COMMAND STRING POINTER

;	BUILD COMMAND STRING. SCAN FOR COMMAND CHARACTER.
CR3:	MOVE	S,CRS		;INITIALIZE PUSHDOWN STACK POINTER
	SETZM	GSEC		;CLEAR EROROR COUNT
	MOVE	W,PC
	MOVEM	W,@DOTP
	CAMN	I,[POINT  7,LCS,35]	;IS BUFFER FULL?
	SKIPA	W,[ASCII  "    ?"]	;YES, FLUSH WITH ?
	XCT	GCHI
	TLO	F,ESCSW		;MARK CHR RECEIVED SINCE LAST ESCAPE
	CAIL	W,"a"		;MAP LOWER CASE TO UPPER
	CAILE	W,"z"
	SKIPA
	SUBI	W,40
	MOVEI	U,CT0
	PJS	CMLOOK		;CHECK FOR COMMAND CHR
	JUMPN	V,CR4
	IDPB	W,I		;ORDINARY CHR. APPEND TO COMMAND STRING
	JRST	CR3

CR4:	SKIPE	V,CMLADR
	JRST	(V)
	JRST	DQUES

ESC:	CLRBFI
	CLRBFO
	MOVE	X,OBR		;RESET OUTPUT BAUD RATE
	HRROI	W,16
	AUXCAL	W,X
	TRZ	F,LSLOCK+PRPCOD+PRPTOK ;clear proprietary flags
	SETZM	SYLOCK
	TLZN	F,ESCSW
	JRST	NADEX		;EXIT IF TWO ESCAPES WITH NOTHING IN BETWEEN
	MOVEI	0,DQUES3	;SEND THE PROGRAM BACK TO COMMAND HANDLER
	SKIPL	CN		;aux circuit active?
	MOVEI	0,ICESC		;go clear it up
	HRRM	0,TIV
	DISMIS

ICESC:	HRLZ	W,CN
	HRRI	W,7		;CLEAR OUTPUT BUFFER TO AUX. CIRCUIT
	AUXCAL	W,
	HLLZ	W,W
	LSH	W,11		;shift port number to bits 0-8
	IOR	W,[141,,5]	;WAIT 5 SECONDS FOR ORANGE BALL
	HIBER W,
	JFCL
	HRLZ	W,CN
	HRRI	W,6
	AUXCAL	W,		;CLEAR INPUT BUFFER
	TRNN	F2,BINMOD	;and in binary mode?
	JRST	DQUES3		;no
	HRLZ	W,CN
	HRRI	W,4
	AUXCAL	W,201		;sent flush character
	PJS	ICBCLR		;AND CLEAR BINARY MODE
	JRST	DQUES3		;return to command processor

INTSET:	HRLZI	W,IA.CLR
	INTADR	W,		;RESET INTERRUPTS
	JFCL
	MOVE	W,[IA.REE,,TIV]
	INTADR	W,		;SET INTERRUPT VECTOR ADDRESS
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVE	W,[IOWD NIPD,IPDS]
	MOVEM	W,INTS
	HRLOI	W,(<.IAESC>B8+<ESCCHN>B17) ;cmd port escape channel
	TINASS	W,
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVSI	W,(1B0+1B<ESCCHN>)
	INTENB	W,		;Enable escape interrupt
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	RETURN

AUXZAP:	TYPE	<$Aux circuit lost>
	HRRI	W,AXZAP2
	HRRM	W,TIV+<2*<ZAPCHN-1>>
	DISMIS
AXZAP2:	HRLI	W,(<.IALOS>B8)
	HRR	W,CN
	TINASS	W,		;unassign character lost interrupt
	JFCL
	HRLI	W,(<.IAZAP>B8)
	HRR	W,CN
	TINASS	W,		;unassign circuit zap interrupt
	JFCL
	TRZE	F2,BINMOD	;is it in binary mode?
	JRST	AXZAP3		;yes. Character receive not set
	HRLI	W,(<.IACHR>B8)
	HRR	W,CN
	TINASS	W,		;unassign character received interrupt
	JFCL
AXZAP3:	SETOM	CN		;set no aux circuit
	MOVE	X,OBR		;reset output baud rate
	HRROI	W,16
	AUXCAL	W,X
	JRST	DQUES3

;	Input character lost from aux circuit. Type message and return

AUXLOS:	PUSH	S,0		;Save register used by TYPE macro
	TYPE	<$Data lost from aux circuit$>
	POP	S,0
	DISMIS

AUXINT:	EXCH	S,INTS
	PJS	RIP
	EXCH	S,INTS
	DISMIS

RIP:	BAR	<W,X>		;RELAY FROM ENGINE TO PDP COMMAND CIRCUIT OUT
	HRL	X,CN
RIP1:	HRRI	X,10
	AUXCAL	X,
	JRST	RIP2
	HRRI	X,1
	AUXCAL	X,W
	JRST	RIP2		;CHR TO RELAY IS IN W
	PJS	ICOUT		;print it
	JRST	RIP1
RIP2:	HRRI	X,11		;DO LEVDEF ON AUX CIRCUIT
	AUXCAL	X,		;IN CASE YELLOW BALL WAITING
	RETURN

DQUES1:	TYPE	<   ? >
	JRST	DQUES3
DQUES:	TYPE	<   ?>
DQUES3:	MOVE	X,CURCMD	;get current command file index
	MOVE	W,[PJS CTINP]	;force input from terminal
	MOVEM	W,CMDSRC(X)
	MOVEM	W,GCHI
	JRST	CR

CMLOOK:				;LEAVE V>0 IF COMMAND CHR. V=0 IF ORDINARY CHR.
	SETZM	CMLADR		;CLEAR FOR NOW. CMLADR MAY GET A DISPATCH ADR
	CAIN	W," "
	AOS	BC		;BLANK COUNT
	MOVE	C,CT(W)		;Lookup character type
	MOVE	C,RBIT(C)

CML1:	LDB	V,[POINT 7,(U),17]	;PICK UP A CMND CHR FROM TABLE
	JUMPE	V,[RETURN]	;W CHR NOT IN CMND TABLE
	CAME	W,V
	AOJA	U,[AOJA	U,CML1]
	MOVEM	W,CMLCHR

	MOVE	X,CMACNT	;COMPUTE ARG COUNT FROM COMMA COUNT
	CAME	I,[POINT 7,CS]
	AOS	X
	SKIPE	BC
	MOVEI	X,1
	MOVEM	X,ARGC
	MOVEM	X,ARGC1
	HRRI	V,73
	IDPB	V,I		;APPEND A SEMICOLON TO CMND STRING
	HRRZM	U,CMLU
	MOVE	U,(U)		;PICK UP CMND CONTROL BITS
	CAILE	X,3		;IF GREATER THAN 3 ARGS
	MOVEI	X,3		; USE 3 FOR 3 OR GREATER NUMBER OF ARGS
	TDNN	U,LBIT(X)
	JRST	CMLE		;IF NOT VALID NUMBER OF ARGS FOR THIS COMMAND
	SKIPE	ARGC1
	TLNN	U,20000
	JRST	CML3		;IF NO ARGS OR V SWITCH NOT SET
	PJS	AA		;ASSEMBLE ARGUMENTS
	SKIPE	GSEC
	JRST	CMLE		;IF ERROR IN ARGUMENTS

CML3:	MOVE	U,CMLU
	MOVE	V,ARGC
	CAILE	V,3		;> 3 ARGS
	MOVEI	V,3		;YES. USE 3 OR > ADDRESS
	XCT	CMLX(V)
	HRRZM	V,CMLADR	;GET COMMAND ADDRESS
	MOVE	VS,(U)
	LSH	VS,7
	ASH	VS,-40
	MOVEM	VS,CMLDTA
	PJS	IZDOS
	RETURN

CMLX:	HRR	V,(U)		;COMMAND ADDRESS FOR 0 ARGS
	HLR	V,1(U)		;   "       "     "  1 ARG
	HRR	V,1(U)		;   "       "     "  2 ARGS
	HRR	V,1(U)		;   "       "     "  3 ARGS OR MORE
CMLE:	HRR	V,S		;ERROR IN ARGUMENTS
	RETURN

;	A VALUE VECTOR IS A DOUBLE WORD. IF WORD 1 IS 0, WORD 0 IS A BINARY
;	VALUE WORD. OTHERWISE THE FIRST 2, 4, OR 6 BYTES ARE AN INSTRUCTION,
;	WITH THE RIGHTMOST HALF OF WORD 1 BEING 1, 2, OR 3.

XVU:	DMOVEM	V,LVV		;TRANSLATE VALUE VECTOR V,U TO STRING DOS
	MOVE	W,TOM
	MOVE	W,XVJ(W)
	JUMPE	U,(W)
	HLR	W,W
	JRST	(W)
XVJ:	XVER,,XM
	XVER,,XN
	XVER,,XASC
	XVER,,XS
	XI,,XVER
XVER:	AOS	GSEC
	RETURN

XVUB:	PJS	DOS3B
	PJS	XVU
	PJS	DOS3B
	RETURN

XN:	JUMPGE	V,XM		;SIGNED NUMBER TO STRING DOS
	MOVN	V,V
	SETOM	SWMIN
XM:				;MAGNITUDE V TO DOS
	TLZ	V,740000
XM1:	LDB	W,DOS
	MOVE	W,CT(W)		;Lookup character type
	MOVE	W,RBIT(W)
	ANDI	W,1_DIG!1_UAF!1_LAF!1_UGZ!1_LGZ!1_PE	;W=0 IF PLU SGN UNNECESSARY
	SKIPE	W
	MOVEI	W,53
	AOSG	SWMIN
	MOVEI	W,55
	SKIPE	W
	IDPB	W,DOS		;OUTPUT "+" OR "-" OR NOTHING
	MOVE	Y,TRADIX
	SETZM	TNX
	PJS	TN		;OUTPUT NUMERIC STRING
	RETURN

XASC:	SETZ	U,
	SKIPE	COS
	LSHC	V,-20
	LSHC	V,-20
	LSHC	V,10
	IDPB	V,DOS
	JUMPN	U,.-2
	RETURN

XS:	MOVE	M,MM
	PJS	FCS
	JUMPL	W,XA1
	PUSH	S,U
	MOVE	U,1(W)
	PJS	DOS6		;OUTPUT SIXBIT SYMBOL
	POP	S,V
	JUMPE	V,[RETURN]
XA1:	PJS	XN
	RETURN

XI:				;TRANSLATE INSTRUCTION V,U TO STRING DOS
	HRRI	U,1
	DMOVEM	V,XIVU		;NOTE USE OF NON ZERO U A FEW LINES BELOW
	MOVE	W,DOS
	MOVEM	W,DOSX
	HRLZI	M,400000
	LDB	V,[POINT 16,XIVU,19]
	TRZ	V,17
	TRNE	V,360
	PJS	FCS
	MOVEM	U,XIU		;USING NON ZERO U SET ABOVE
	JUMPE	U,XI1
	TRZ	V,377
	PJS	FCS
	JUMPE	U,XI1
	MOVE	U,[SIXBIT	"OPFLOP"]
	PJS	DOS6
	RETURN

XI1:	HRRZM	W,XIW		;SYM TAB PTR
	MOVE	U,1(W)
	PJS	DOS6
	PJS	DOS1B
	LDB	V,[POINT 4,XIVU,15]	; R1 FIELD
	SKIPE	XIU
	PJS	XM1
	LDB	W,[POINT 6,@XIW,11]	;INTRUCTION TYPE
	CAIG	W,EPC9D-PC9D
	JUMPG	W,PC9D-1(W)
	CPF			;REPORT ASSEMBLER INTERNAL ERROR

XIBF:	PJS	XICMA
	LDB	V,[POINT 4,XIVU,19]
	LSH	V,1		;R2. HALFWORD COUNT.
	HRLZI	W,100
	TDNN	W,XIVU
	MOVN	V,V		;IS IT FORWARD OR BACKWARD?
	ADD	V,PC		;COMPUTE EFFECTIVE ADDRESS OF JUMP
	JRST	XS		;OUTPUT AND RETURN TO CALLER

XIRX:	AOS	XIVU+1		;INTRUCTION IS AT LEAST 2 HALFWORDS LONG
	LDB	W,[POINT 2,XIVU,21]	;ADRS TYPE BITS
	JV	<.+1(W),XIRX1,XIRX3,XIRX2,XIRX2>

XIRI1:	AOS	XIVU+1
XIRX1:	MOVE	V,XIVU
	ANDI	V,177777
	JRST	XID

XIRX2:	MOVE	V,XIVU
	LSH	V,25
	ASH	V,-25		;DISPLACEMENT
	ADD	V,PC
	ADDI	V,4		;EFFECTIVE ADRS
	JRST	XID

XIRX3:	AOS	XIVU+1
	DMOVE	V,XIVU
	LSHC	V,20
	TLZ	V,777700
	LDB	W,[POINT 4,XIVU,27]
	MOVEM	W,XIRX3R
	JRST	XID

XIRI2:	DMOVE	V,XIVU
	ADDI	U,2
	MOVEM	U,XIVU+1
	LSHC	V,20
	TLZ	V,740000
	JRST	XID

XID:				;OUTPUT DISPLACEMENT V TO DOS
	PJS	XICMA
	PJS	XS
XIRR:	PJS	XICMA
	LDB	V,[POINT 4,XIVU,19]
	PJS	XM1		;R2 FIELD
	SKIPGE	V,XIRX3R
	RETURN
	SETOM	XIRX3R
	PJS	XICMA
	JRST	XS		;SAME AS PJS XS	;PS

MD:	BAR	<Y>		;MEMORY TO DOUBLE WORD
	MOVE	0,[POINT 8,V,3]
	SETZB	V,U
MD1:	MOVE	W,Y
	CA
	LDB	W,W
	IDPB	W,0
	CAME	0,[POINT 8,U,23]
	AOJA	Y,MD1
	RETURN

DM:	BAR	<Y>		;DOUBLE WORD TO MEMORY. Y IS PC.
	MOVE	0,[POINT 8,V,3]
DM1:	MOVE	W,Y
	CA
	ILDB	X,0
	DPB	X,W
	CAME	0,[POINT 8,U,23]
	AOJA	Y,DM1
	RETURN

MV:				;MEMORY TO VALUE VECTOR. Y=PC.
	PJS	MD		;GET A DOUBLE WORD
MV0:	MOVE	W,TOM
	JV	<.+1(W),MVM,MVN,MVM,MVM,MVI>
MVN:	LSH	V,4
	SKIPN	COS
	ASH	V,-20
	ASH	V,-4		;PRESERVE SIGN INFO
	JRST	MVM1
MVM:	LSH	V,4
	SKIPN	COS
	LSH	V,-20
	LSH	V,-4
MVM1:	SETZ	U,
	RETURN
MVI:	DMOVEM	V,MDPAIR
	PJS	XI
	DMOVE	V,XIVU
	MOVE	W,DOSX
	MOVEM	W,DOS
	RETURN

VM:	JUMPN	U,VMI		;IT IS AN INSTRUCTION VALUE VECTOR
	MOVE	0,[POINT 16,V,3]
	SKIPN	COS
	IBP	0
VM1:	MOVE	W,Y
	ADDI	Y,2
	PJS	CAHSUB
	ILDB	X,0
	DPB	X,W
	TLNE	0,770000
	JRST	VM1
	RETURN
VMI:	HRRZ	L,U
	LSHC	V,-20
VMI1:	MOVE	W,Y
	ADDI	Y,2
	PJS	CAHSUB
	DPB	V,W
	LSHC	V,20
	SOJG	L,VMI1
	RETURN

FCCPC:	MOVEM	V,PC
FCC:				;FULL CELL CONTENTS TO DOS
	MOVE	Y,V
	PJS	MV
	DMOVEM	V,LVV
	PJS	XVUB
	RETURN

FC:	PUSH	S,V		;FULL CELL AND ITS LABEL TO DOS. V=PC.
	PJS	IZDOS
	PJS	XS		;LABEL TO DOS
	MOVEI	W,134
	IDPB	W,DOS		;OUTPUT A BACKSLASH
	POP	S,V
	PJS	FCCPC
	PJS	DOSOUT
	RETURN

AA:				;ASSEMBLE ARGUMENTS
	HRRI	W,VTAB
	HRRZM	W,VTABP
	SETZM	GSEC
	SKIPE	BC
	JRST	AAI
;	ASSEMBLE ARGUMENT EXPRESSIONS
	MOVE	W,ARGC1		;GET NUMBER OF ARGS TYPED
	CAILE	W,NCARGS	;ARE THERE TOO MANY
	JRST	AAE		;YES. ERROR
	MOVE	I,[POINT 7,CS]
AA1:	MOVE	W,MM
	MOVEM	W,MM1
	PJS	AAGS
	SOJG	U,AAE		;ERROR IF NOT DEFINED OR NOT NULL
	MOVEI	W,2
	ADDB	W,VTABP
	SETZ	U,
	DMOVEM	V,-2(W)
	DMOVEM	V,LVV
	SOSLE	ARGC1
	JRST	AA1
	JRST	AAEND
AAE:	AOS	GSEC
	HRRI	V,77
	IDPB	V,DOS
	IDPB	V,DOS		;2 QUESTION MARKS
	JRST	AAEND

AAGS:	MOVEM	S,GSSTK		;save stack pointer for abort
	PJS	GE		;assemble expersion
	SKIPE	LEC		;any error messages?
	PJS	TLE		;yes. type them
	RETURN

AAL:	SKIPA	I,[POINT 7,CS]
AAI:	MOVE	I,[POINT 7,CS0]	;ASSEMBLE INSTRUCTION
	HRRI	W,VTAB
	HRRZM	W,VTABP
	MOVEI	W,1
	MOVEM	W,ARGC
	MOVE	Y,PC
	MOVEM	Y,AAPC
	PJS	MD
	DMOVEM	V,MDPAIR
	HRRI	W,GE
	HRRZM	W,GECALL
	TRO	F,ASONLY
	SETOM	LSTMSK
	PJS	GS
	SKIPE	LEC		;type any error messages
	PJS	TLE
	HRRI	W,4
	SKIPN	GSEC
	HRRZM	W,TOM
	MOVE	Y,AAPC
	MOVEM	Y,PC
	PJS	MD
	EXCH	V,MDPAIR
	EXCH	U,MDPAIR+1
	PJS	DM
	DMOVE	V,MDPAIR
	PJS	MV0
	MOVE	W,DOSX
	MOVEM	W,DOS
	DMOVEM	V,@VTABP
	DMOVEM	V,LVV
AAEND:	TLZE	F,ABTASM	;was assembly aborted?
	JRST	DQUES3		;yes. stop command file
	RETURN


DOS3B:	SKIPA	W,[40_16+40_7+40]	;3 BLANKS
DOS1B:	HRRZI	W,40
	IDPB	W,DOS
	LSH	W,-7
	JUMPN	W,.-2
	RETURN

IZDOS:	MOVE	W,[POINT 7,DOS+1]
	MOVEM	W,DOS
	RETURN
DOSOUT:	SETZ	W,
	IDPB	W,DOS
	OUTSTR	DOS+1
	RETURN

DOS6:	AOS	P6
	PJS	TYP6
	SOS	P6
	RETURN

XICMA:	LDB	0,DOS		;OUTPUT COMMA TO DISASSEMBLY STRING IF ADVISEABLE
	MOVEI	W,","
	CAIE	0," "
	IDPB	W,DOS
	RETURN

PBY:	BAR	<W>		;PUT BYTE V INTO MEMORY LOC W
	SKIPN	LOCAL
	JRST	PBY7
	CA
	DPB	V,W
	RETURN

PBY7:	CPF			;REPORT ASSEMBLER INTERNAL ERROR

KCOMMA:	AOS	CMACNT
	MOVEI	W,","
	DPB	W,I
	JRST	CR3
	SUBTTL	DEBUGGER COMMANDS
;		**************************************************


AF:	TRZ	F,LPASS1+LPASS2
	TRNE	F2,PS1LST	;Is a pass 1 listing desired?
	TRO	F,LPASS1	;Yes, request pass one listing.
	TRNN	F2,FRCLST	;Should a pass two listing be forced
	SKIPE	VS		;or is it being requested
	TRO	F,LPASS2	;yes, request pass two listing.
	TRNE	F,LPASS2	;If a pass two listing is requested,
	TRZ	F,LPASS1	;don't request a pass one listing
	PJS	BL3
	PJS	GFN		;Get input file name
	JRST	DQUES		;not a well formed file name
	DMOVEM	L,IL+2		;save file name and extension
	DMOVEM	X,ILUSR		;save user name
	SETZ	W,		;assume listing buffer needed for listing
	TRNN	F,LPASS2	;unless listing in pass 2
	TRNN	F,LPASS1	;or no pass 1 listing
	MOVEI	W,NLBF		;then free listing buffers for input
	SKIPE	LOH		;unless list file already open
	SETZ	W,		;then buffers not free for input
	MOVEM	W,LSPACE	;list buffers free for input
	PJS	OIF		;open input file
	JUMPE	W,DQUES		;open error. abort
	TRZ	F,LSLOCK+PRPCOD
;[1.6a]	MOVE	W,IFPPN		;Get input files PPN
;[1.6a]	CAMN	W,NADFPN	;Is input file not from NAD's home directory
	TRNE	F2,TYMPRP	;or does frame have Tymshare license?
	  JRST	AF1		;Yes. Allow listings
	TRO	F,LSLOCK+PRPCOD	;No. Forbid listing of proprietary code
	TRZ	F,LPASS1+LPASS2
AF1:	SETZM	DSW		;assemble indirect statements
	PJS	GF
	TRZ	F,LSLOCK+PRPCOD+PRPTOK
	SETZM	SYLOCK
	TLZE	F,ABTASM	;assembly aborted?
	JRST	DQUES3		;yes. stop command file
	JRST	CR

IBF:			;IMAGE BINARY FILE COMMANDS ;F AND %F
	PJS	UBID		;UPDATE PREVIOUS (POSSIBLE) FILE
	MOVEM	VS,BFSW		;FLAG NEW OR APPEND
	PJS	BL3		;OUTPUT 3 BLANKS
	PJS	GFN		;GET NEW FILENAME
	JRST	IBER		;not a well formed file name.
	DMOVEM	L,BL+2		;FILENAME and extension
	DMOVEM	X,IBUNAM	;user name
	SETZB	W,BL+4
	SKIPE	IBUNAM		;SKIP IF NO USERNAME GIVEN
	HRRZI	W,IBUNAM	;USERNAME IS IN IBUNAM
	MOVEM	W,BL+1		;POINT TO USERNAME
	SETZM	BL+11		;INSURE INITIAL STORAGE VALUE = 0
	OPEN	BCH,BSPEC	;CLOSE OLD FILE, OPEN NEW
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	LOOKUP	BCH,BL		;CHECK FOR EXISTING FILE
	JRST	IBF1		;CHECK ERRORS
	MOVE	W,BL+1		;get PPN
	SKIPN	IBUNAM		;was user name given?
	MOVEM	W,IBUNAM+1	;no. save PPN
	SKIPN	ARGC		;ANY ARGUMENTS?
	JRST	IBF6		;NO
	SKIPN	LVV		;ARG VALUE=0?
	JRST	IBF6		;YES
	SKIPE	BFSW		;SKIP IF 1;F
	JRST	IBF3		;1%F, OK TO ENTER FILE
	JRST	IBF2		;1;F, OK TO SUPERSEDE
IBF6:	SKIPE	BFSW		;SKIP IF ;F
	JRST	IBF5		;0%F, INPUT EXISTING ID BLOCK
	TYPE	<Supersede existing file? (Y or N): >
	TLO	F,DCCF		;GET CHARACTER IMEDIATELY
	XCT	GCHI		;GET RESPONSE
	CAIE	W,"Y"
	CAIN	W,"y"
	JRST	IBF2		;IF YES
	JRST	IBEX		;IF NO

IBF1:				;CHECK LOOKUP ERROR
	HRR	V,BL+3		;ERROR CODE
	JUMPN	V,IBER		;ABORT IF TYPE NOT "FILE NOT FOUND"
	SKIPN	BFSW		;SKIP IF %F
	JRST	IBF3		;NO FILE, OK FOR ;F
	TYPE	<Creating new file.>
	SETZM	BFSW		;FLAG NEW FILE
	JRST	IBF3

IBF2:				;SUPERSEDING EXISTING FILE
	CLOSE	BCH,		;RETURN OLD FILE
	SETZM	BL+5		;CLEAR WORD SIZE
	SETZM	BL+11		;CLEAR BLOCK SIZE
IBF3:				;ENTER NEW OR UPDATE FILE
	SETZ	V,
	HRRM	V,BL+3		;CLEAR ERROR CODE
	SETZM	BL+4		;CLEAR DATE AND TIME FIELD
	ENTER	BCH,BL
	JRST	IBER		;ENTER ERROR
	MOVE	W,BL+1		;get PPN
	SKIPN	IBUNAM		;was user name given?
	MOVEM	W,IBUNAM+1	;no. save PPN
	MOVE	V,BFSW
	SETZM	BFSW		;FLAG OUTPUT IS OK
	CAIE	V,0		;IS THIS NEW OR EXISTING FILE?
	JRST	IBF5		;INPUT EXISTING ID BLOCK
	SETZM	BAD
	PJS	IIDB		;INITIALIZE NEW ID BLOCK
IBF4:	SETZ	V,
	HRRM	V,BL+3		;CLEAR DATE FIELD
	SETZM	BL+4		;CLEAR TIME FIELD
	SETO	M,
	PJS	TUN		;TEST UNDEFINEDS
	JUMPGE	Y,CR		;EXIT IF NONE
	TYPE	<*** Undefined symbols, memory image not guaranteed$>
	JRST	CR		;NOW EXIT

IBF5:				;INPUT ID BLOCK, MARK INDEX AS FULL
	IBINP	IBID
	MOVEI	V,IBIDC-1
	MOVEM	V,IBRIXP	;MARK AS FULL
	SETOM	BAD		;FLAG UNKNOWN BLOCK ADDRESS
	JRST	IBF4		;CHECK FOR UNDEFINED SYMBOLS

IBER:	SETOM	BFSW		;ERROR IN COMMAND, RESET FLAG
	JRST	DQUES

IBEX:	SETOM	BFSW		;FORGET IT!
	JRST	DQUES3


;	PAD,VAD,CNT;G - GET NIB FILE INTO LOCAL IMAGE
GIB0:	SETZM	MIALL		;0 ARG. GET ENTIRE FILE
	JRST	GI1
GIB1:	MOVE	V,VTAB		;1 ARG
	MOVEM	V,VTAB+2	;SET COUNT IN ARG 2
	SETZM	VTAB		;PAD = 0
GIB2:	MOVE	V,ARGC
	CAILE	V,2		;2 ARGS OR LESS?
	JRST	GIB3		;3 ARGS
	MOVE	V,VTAB+2	;2 ARGS
	MOVEM	V,VTAB+4	;MOVE COUNT
	MOVE	V,VTAB
	MOVEM	V,VTAB+2	;COPY PAD TO VAD
GIB3:	SETOM	MIALL		;SET FLAG TO GET SELECTIVE
	MOVE	V,VTAB		;GET PAD
	ADDM	V,VTAB+4	;CHANGE BCNT TO LAD+1
	SUBM	V,VTAB+2	;CHANGE VAD TO A BIAS
GI1:	SKIPGE	BFSW		;IS THERE A CURRENT FILE?
	JRST	PSIBE2		;NO
	SETZM	BRNGL		;SET RANGE LIST NULL
	SETZ	M,		;SET INDEX SCAN TO INITIALIZE
GI4:	PJS	IXSCAN		;GET NEXT INDEX ENTRY
	JRST	GIT		;NO MORE. GO TEST FOR MISSING PEICES
	LDB	V,IBTYPP	;GET RECORD TYPE
	CAIE	V,MITYP		;IS THIS A MEMORY IMAGE INDEX?
	JRST	GI4		;NO
	SKIPL	MIALL		;GETTING ENTIRE FILE?
	JRST	GI2		;YES. GET THIS RECORD
	LDB	V,IBPADP	;GET PAD FOR THIS RECORD
	CAML	V,VTAB+4	;IS PAD < LAD+1?
	JRST	GI4		;NO
	LDB	U,IBCNTP	;GET BYTE COUNT
	ADD	U,V		;PAD+BCNT
	CAMG	U,VTAB		;IS (PAD+BCNT)>REQUESTED PAD?
	JRST	GI4		;NO

	CAMGE	V,VTAB		;GET FAD=MAX(PAD,REQUESTED PAD)
	MOVE	V,VTAB
	CAMLE	U,VTAB+4	;GET LAD+1=MIN(PAD+BCNT,REQUESTED LAD+1)
	MOVE	U,VTAB+4
GI6:	GFL			;GET ENTRY FOR RANGE LIST
	DMOVEM	V,1(W)		;SAVE FAD AND LAD+1
	MOVEI	X,BRNGL		;SCAN LIST TO INSERT NEW ENTRY
GI21:	MOVE	Y,X		;SAVE ADDRESS OF PREVIOUS ENTRY
	MOVE	X,(Y)		;ADDRESS NEXT ENTRY
	JUMPE	X,GI22		;CHECK IF END OF LIST
	CAMLE	V,1(X)		;IS NEW FAD<=FAD OF THIS ENTRY?
	JRST	GI21		;NO. GO GET NEXT ENTRY
GI22:	HRRZM	X,(W)		;HAVE NEW POINT TO ENTRY FOUND
	HRRZM	W,(Y)		;HAVE PREVIOUS POINT TO NEW
	JUMPN	X,.+2		;IS NEW ENTRY NEW LIST END?
	HRRZM	W,ERNGL		;YES. SAVE ADDRESS OF LIST END
	LDB	W,IBBADP	;GET BLOCK ADDRESS OF RECORD
	USETI	BCH,1(W)	;POSITION TO BLOCK
	MOVEI	L,MIDATA
	LDB	VS,IBPADP	;INIT CURRENT ADDRESS (CAD)
GI7:	IBINP	MIHDR		;GET NEXT DATA BLOCK
GI8:	SKIPGE	(L)		;IS THIS A COMPRESSION WORD?
	JRST	GI10		;YES, UNCOMPRESS IT
	ADDI	VS,4		;CAD=CAD+4
	CAMLE	VS,V		;IS CAD > FAD
	JRST	GI14		;YES, COPY TO LOCAL MEMORY
GI9:	ADDI	L,1		;NO, GET NEXT WORD
	CAIGE	L,MIEND		;END OF BLOCK?
	JRST	GI8		;NO, GET NEXT WORD
	MOVEI	L,MIHDR		;YES, POSITION WORD POINTER TO START
	JRST	GI7		;GET NEXT BLOCK
GI2:	LDB	V,IBVADP	;GET VAD
	LDB	U,IBUVAP	;GET VAD DEFINED BIT.
	TRNE	U,1		;IS VAD DEFINED?
	LDB	V,IBPADP	;NO. USE PAD.
	MOVEM	V,VTAB+2	;SAVE FOR STORE
	LDB	V,IBPADP	;GET PAD
	SUBM	V,VTAB+2	;CHANGE VAD TO BIAS
	LDB	U,IBCNTP	;GET BCNT
	ADD	U,V		;CONVERT TO LAD+1
	JRST	GI6

GI10:	HRRZ	Y,(L)		;GET REPEAT COUNT
	LSH	Y,1		;RC*2
	ADDI	Y,2		;BYTE COUNT = RC*2+2
	ADD	VS,Y		;CAD=CAD+BYTE COUNT
	CAMG	VS,V		;IS CAD>FAD?
	JRST	GI9		;NO, GET NEXT WORD
	MOVE	Y,VS
	SUB	Y,V		;BCNT=CAD-FAD
	LDB	C,[POINT 8,(L),8]	;GET BYTE 1
	LDB	OS,[POINT 8,(L),17]	;GET BYTE 2
	TRNN	Y,1		;IS COUNT EVEN?
	JRST	GI11		;YES
	ADDI	Y,1		;MAKE IT EVEN
	DBYTE	OS		;DEPOSIT THE BYTE
	CAML	V,U		;FAD<LAD+1?
	JRST	GI20		;NO, DONE
GI11:	MOVE	X,V		;FAD
	ADD	X,Y		;FAD+BCNT
	CAMGE	X,U		;FAD+BCNT<LAD+1?
	JRST	GI12		;YES
	MOVE	Y,U
	SUB	Y,V		;BCNT=LAD+1-FAD
GI12:	DBYTE	C		;DEPOSIT BYTE 1
	DBYTE	OS		;DEPOSIT BYTE 2
	SUBI	Y,2		;BCNT=BCNT-2
	CAILE	Y,1		;MORE THAN 1 BYTE LEFT?
	JRST	GI12		;YES
	JUMPE	Y,GI13		;IF NO MORE LEFT
	DBYTE	C		;DEPOSIT LAST BYTE
GI13:	CAML	V,U		;FAD<LAD+1?
	JRST	GI20		;NO, DONE
	JRST	GI9		;GET NEXT WORD

GI14:	MOVE	Y,VS
	SUB	Y,V		;BCNT=CAD-FAD
	CAIN	Y,4		;HOW MANY BYTES?
	JRST	GI15		;IF 4
	CAIN	Y,3
	JRST	GI16		;IF 3
	CAIN	Y,2
	JRST	GI17		;IF 2
	JRST	GI18		;IF 1

GI15:	LDB	C,[POINT 8,(L),8]
	DBYTE	C		;DEPOSIT BYTE 1
	CAML	V,U		;VAD<LAD+1?
	JRST	GI20		;NO, DONE
GI16:	LDB	C,[POINT 8,(L),17]
	DBYTE	C		;BYTE 2
	CAML	V,U
	JRST	GI20
GI17:	LDB	C,[POINT 8,(L),26]
	DBYTE	C		;BYTE 3
	CAML	V,U
	JRST	GI20
GI18:	LDB	C,[POINT 8,(L),35]
	DBYTE	C		;BYTE 4
	CAML	V,U
	JRST	GI20
	JRST	GI9		;GET NEXT WORD

GI20:	SUB	U,VTAB+2	;CONVERT LAD+1 TO VIRTUAL
	LDB	V,IBPADP	;GET FILE FAD
	SUB	V,VTAB+2	;CONVERT TO VIRTUAL
	LSH	V,-20		;COMPUTE SEGMENT NUMBER
	CAMLE	U,SEGTOP(V)	;HAS SEGMENT GOT LARGER?
	MOVEM	U,SEGTOP(V)	;YES. SET NEW MAX.
	JRST	GI4		;GO GET NEXT RECORD

GIT:				;TEST FOR MISSING PIECES
	SKIPL	MIALL		;WAS ENTIRE FILE READ?
	JRST	GIT31		;YES. NO NEED TO CHECK MEMORY
	SKIPN	Y,BRNGL		;WERE ANY RANGES READ?
	JRST	GIT2		;NOPE
	MOVE	V,1(Y)		;GET LOWEST ADDRESS READ
	CAME	V,VTAB		;IS IT = PAD?
	JRST	GIT3		;NO. DATA NOT READ
	MOVE	V,2(Y)		;SET HIGHEST LAD+1 READ
GIT1:	CAMN	V,VTAB+4	;IS HIGHEST READ+1=REQUESTED LAD+1
	JRST	GIT4		;YES. ALL DATA READ
	MOVE	Y,(Y)		;GET NEXT ENTRY
	JUMPE	Y,GIT3		;IF NO MORE ENTRIES, DATA MISSING
	CAMGE	V,1(Y)		;IS NEXT PAD TOO HIGH?
	JRST	GIT3		;YES. DATA MISSING
	CAMG	V,2(Y)		;IS NEW LAD+1>OLD LAD+1
	MOVE	V,2(Y)		;YES. SET NEW TO HIGHEST LAD+1 READ
	JRST	GIT1		;GO EXAMINE NEXT RANGE
GIT2:	TYPE	< *** File missing all of requested data>
	JRST	CR
GIT3:	TYPE	< *** File missing some of requested data>
GIT31:	TYPE	<$Data ranges read:>
	MOVE	W,BRNGL		;SCAN RANGE LIST
GIT32:	PJS	TYPEOL		;START A NEW LINE
	MOVEI	X,70		;SET CHARS/LINE COUNT
GIT33:	JUMPE	W,GIT34		;CHECK IF ANYMORE RANGES REMAINING
	MOVE	V,1(W)		;GET START OF RANGE
	MOVEI	Y,20		;SET RADIX TO HEX
	PJS	TN		;TYPE IT OUT
	SUB	X,TYP6C		;DECREMENT CHARS/LINE
	OUTCHI	"-"		;TYPE RANGE SEPARATOR
	SUBI	X,1
	MOVE	V,2(W)		;GET END OF RANGE
	SUBI	V,1		;CHANGE LAD+1 TO LAD
	MOVEI	Y,20		;SET RADIX TO HEX
	PJS	TN		;AND TYPE IT OUT
	SUB	X,TYP6C
	MOVE	W,(W)		;ADDRESS NEXT RANGE
	SOJLE	X,GIT32		;CHECK IF END OF LINE
	OUTCHI	" "		;SEPARATE RANGES
	JRST	GIT33		;GO TYPE OUT NEXT RANGE
GIT34:	CAIE	X,70		;HAS A RANGE BEEN TYPED ON THIS LINE?
	PJS	TYPEOL		;YES. TYPE <CR><LF>
GIT4:	MOVE	Y,BRNGL		;GET BEGIN OF RANGE LIST
	JUMPE	Y,CR		;Exit if no range list
	EXCH	Y,FL		;RETURN TO FREE LIST
	MOVEM	Y,@ERNGL	;HAVE RANGE LIST POINT TO FREE LIST
	JRST	CR

;	SCAN NIB INDEX BLOCKS. SKIP IF INDEX ENTRY, NOSKIP AT END.
IXSCAN:	JUMPN	M,IXSC5		;CHECK IF FIRST TIME CALLED
	MOVEI	M,IBID
	LDB	V,IBBADP	;GET ID BLOCK ADDRESS
	CAIN	V,0		;FIRST BLOCK?
	JRST	IXSC2		;YES
	PJS	UBID		;NO, OUTPUT ID RECORD
	SETZ	V,		;GET FIRST BLOCK
IXSC1:	IBINP	IBID,V		;GET NEXT ID RECORD BLOCK
	MOVEI	V,IBIDC-1
	MOVEM	V,IBRIXP	;MARK AS FULL
IXSC2:	MOVEI	M,IBRIX		;POINT TO FIRST RECORD INDEX
IXSC3:	SKIPE	(M)		;END OF THIS ID RECORD?
	JRST	IXSC4		;NO
	SKIPN	V,IBIDC		;END OF ID CHAIN?
	RETURN			;YES, EXIT
	JRST	IXSC1		;GET NEXT ID RECORD
IXSC4:	AOS	(S)		;SET SKIP RETURN
	RETURN
IXSC5:	ADDI	M,2		;GET NEXT ENTRY
	JRST	IXSC3		;TRY NEXT RECORD INDEX

;	MACSET%Z - Put MAC set number to NIB file
MSIB0:	SETOM	VTAB		; If no argument given, use MAC set -1
MSIB1:	SKIPE	BFSW		; NIB file opened?
	JRST	PSIBE2		; No, error, go inform user
	SETZM	MSHDR		; Clear first word of header entry
	MOVEI	M,MSHDR		; Address new ID block entry
	MOVEI	V,MSTYP		; Get MAC set entry type
	DPB	V,IBTYPP	; Store in type field in new ID block entry
	MOVEI	V,MSMSTY	; Get MAC set subtype
	DPB	V,IBMSTP	; Store in subtype field in new ID block entry
	MOVE	V,VTAB		; Get MAC set number specified by user
	MOVEM	V,MSHDR+1	; Store in second word of new ID block entry
	PJS	IRHDR		; Store new entry in current ID block
	JRST	CR		; That's it. Return to user for more commands

;	PAD,VAD,CNT;P - PUT LOCAL IMAGE TO NIB FILE.
PIB0:	SETOM	MIALL		;SET TO WRITE ALL SEGMENTS
PIB4:	AOS	V,MIALL		;GO TO NEXT SEGMENT
	CAIL	V,20		;ARE THERE ANYMORE SEGMENTS?
	JRST	CR		;NO. EXIT
	MOVE	W,V		;GET SEGMENT NUMBER
	LSH	W,20		;CONVERT TO FAD
	CAML	W,SEGTOP(V)	;IS SEGMENT EMPTY?
	JRST	PIB4		;YES. TRY NEXT SEGMENT
	MOVEM	W,VTAB		;SET PAD FOR SEGMENT
	MOVEM	W,VTAB+2	;SET VAD FOR SEGMENT
	MOVE	V,SEGTOP(V)	;GET LAD+1
	SUB	V,W		;COMPUTE BCNT
	MOVEM	V,VTAB+4
	JRST	PIB3		;GO WRITE IT OUT
PIB5:	SKIPL	MIALL		;PUTTING ALL SEGMENTS
	JRST	PIB4		;YES. GO GET NEXT ONE
	JRST	CR		;NO. EXIT
PIB1:	MOVE	V,VTAB		;1 ARGUMENT
	MOVEM	V,VTAB+2	;SET COUNT IN ARG 2
	SETZM	VTAB		;SET PHYSICAL ADDRESS = 0
PIB2:	SETOM	MIALL		;SET TO PUT SELECTIVE MEMORY
	MOVE	V,ARGC
	CAILE	V,2		;2 ARGS OR LESS?
	JRST	PIB3		;3 ARGS
	MOVE	V,VTAB+2	;2 ARGUMENTS
	MOVEM	V,VTAB+4	;MOVE BCNT
	MOVE	V,VTAB
	MOVEM	V,VTAB+2	;COPY PAD TO VAD
PIB3:	SKIPE	BFSW		;IS THERE A FILE DEFINED?
	JRST	PSIBE2		;NOPE
PI0:	MOVE	V,VTAB+4
	CAIG	V,MIBMAX	;IS COUNT MORE THAN MAXIMUM ALLOWED?
	JRST	PI1		;NO
	SUBI	V,MIBMAX
	MOVEM	V,SCNT		;SAVE REMAINING COUNT
	MOVEI	V,MIBMAX
	MOVEM	V,VTAB+4	;RESET COUNT
	SKIPA
PI1:	SETZM	SCNT		;SET REMAINDER TO 0
	SETZM	MIHDR
	SETZM	MIHDR+1
	MOVEI	V,MITYP
	MOVEI	M,MIHDR
	DPB	V,IBTYPP	;SET MEMORY IMAGE RECORD TYPE
	MOVE	V,VTAB
	DPB	V,IBPADP	;SET PHYSICAL ADDRESSS
	MOVE	V,VTAB+2
	DPB	V,IBVADP	;SET VIRTUAL ADDRESS
	MOVE	V,VTAB+4
	DPB	V,IBCNTP	;SET BYTE COUNT
	PJS	IRHDR		;INITIALIZE RECORD HEADERS
	MOVE	V,[POINT 9,MIDATA]
	MOVEM	V,MIDAP		;POINT TO START OF DATA AREA
	MOVE	V,VTAB+4	;GET COUNT
	ADDM	V,VTAB		;UPDATE PAD FOR NEXT TIME
	MOVE	Y,VTAB+2	;GET VIRTUAL ADDRESS
	ADDM	Y,VTAB+4	;CHANGE COUNT TO LAST ADDRESS + 1 (LAD+1)
PI5:	CAMGE	Y,VTAB+4	;PASSED LAD?
	JRST	PI6		;NO
	IBOUT	MIHDR,V,BAD	;PUT NEXT DATA BLOCK
	AOS	BAD		;UPDATE BLOCK ADDRESS
	SKIPN	SCNT		;IS SAVED COUNT = 0?
	JRST	PIB5		;GO CHECK IF MORE SEGMENTS TO WRITE
	MOVE	V,VTAB+4	;NO, PREPARE FOR MOVE
	MOVEM	V,VTAB+2	;POINT VAD PAST CURRENT AREA
	MOVE	V,SCNT
	MOVEM	V,VTAB+4	;UPDATE COUNT
	JRST	PI0		;STARTUP AGAIN

PI6:	MOVE	L,MIDAP
	CAME	L,MIEND		;PAST END OF BLOCK?
	JRST	PI7		;NO
	IBOUT	MIHDR,V,BAD	;PUT LAST DATA BLOCK
	AOS	BAD		;COUNT THE BLOCK
	MOVE	L,[POINT 9,MIHDR]
	MOVEM	L,MIDAP		;POINT TO START OF BLOCK
PI7:	MOVE	W,Y		;NEXT ADDRESS
	CA			;GET BYTE POINTER
	LDB	V,W		;GET BYTE 1
	MOVE	W,Y
	ADDI	W,1
	CA
	LDB	U,W		;BYTE 2
	SETZ	M,		;INIT REPEAT COUNT
PI8:	ADDI	Y,2		;INCREMENT VAD
	CAML	Y,VTAB+4	;LAD REACHED?
	JRST	PI9		;YES
	MOVE	W,Y
	CA
	LDB	VS,W		;BYTE 3
	MOVE	W,Y
	ADDI	W,1
	CA
	LDB	OS,W		;BYTE 4
	CAME	VS,V		;BYTE 3 = BYTE 1?
	JRST	PI9		;NO
	CAMN	OS,U		;BYTE 4 = BYTE 2?
	AOJA	M,PI8		;(3,4) = (1,2), UPDATE REPEAT COUNT

PI9:	CAIE	M,0		;THIS IS NOT A REPEAT, WHERE THERE ANY?
	JRST	PI10		;YES, OUTPUT COMPRESSION WORD
	IDPB	V,MIDAP		;DEPOSIT BYTE 1
	IDPB	U,MIDAP		;		2
	IDPB	VS,MIDAP	;		3
	IDPB	OS,MIDAP	;		4
	ADDI	Y,2		;INCREMENT VAD
	JRST	PI5		;GO FOR MORE

PI10:	CAMG	Y,VTAB+4	;HAVE WE OVERRUN LAD?
	JRST	PI11		;NO
	SUBI	M,1		;FIX REPEAT COUNT
	SUBI	Y,2		;LOOK AT THESE BYTES AGAIN LATER
PI11:	IORI	V,400		;COMPRESSION FLAG
	IDPB	V,MIDAP		;DEPOSIT BYTE	1
	IDPB	U,MIDAP		;		2
	MOVE	L,M
	CAILE	M,777777	;IS IT > 18 BITS?
	MOVEI	M,777777	;YES
	ROT	M,-11		;LEFT HALF OF REPEAT COUNT
	IDPB	M,MIDAP		;DEPOSIT LEFT HALF
	ROT	M,11
	IDPB	M,MIDAP		;DEPOSIT RIGHT HALF OF REPEAT COUNT
	SUBI	L,777777
	JUMPLE	L,PI5		;IF DONE WITH REPEAT
	MOVE	M,L		;NEW REPEAT COUNT
	MOVE	L,MIDAP
	CAME	L,MIEND		;PAST END OF BLOCK?
	JRST	PI11		;NO, OUTPUT MORE REPEATS
	IBOUT	MIHDR,L,BAD	;PUT NEXT DATA BLOCK
	AOS	BAD		;COUNT THE BLOCK
	MOVE	L,[POINT 9,MIHDR]
	MOVEM	L,MIDAP		;POINT TO START OF BLOCK
	JRST	PI11		;OUTPUT MORE REPEATS

;	PAD;T - OUTPUT IMAGE BINARY TRANSFER ADDRESS.
TIB:	SKIPGE	BFSW		;IS THERE A CURRENT FILE?
	JRST	PSIBE2		;NO
	MOVEI	M,IBID
	LDB	V,IBBADP	;GET ID BLOCK ADDRESS
	CAIN	V,0		;FIRST BLOCK?
	JRST	TI1		;YES
	PJS	UBID		;NO, OUTPUT ID RECORD
	USETI	BCH,1		;POSITION FILE TO FIRST BLOCK
	IBINP	IBID
	MOVEI	V,IBIDC-1
	MOVEM	V,IBRIXP	;MARK AS FULL
TI1:	MOVE	V,VTAB
	MOVEM	V,IBPSA
	JRST	CR

;	MODULE%P - OUTPUT SYMBOL TABLE TO IMAGE BINARY FILE
PSIB1:	MOVE	I,[POINT 7,CS]	;SCAN FOR MODULE NAME
	PJS	SYMSIX		;CONVERT TO SIXBIT AND PUT IN "L"
	JUMPE	L,PSIBE1	;CHECK IF NAME FOUND
	MOVNI	W,44		;SCAN MODULE TABLE FOR NAME
	CAME	L,MOA+44(W)	;IS IT IN TABLE
	AOJL	W,.-1		;NO. TRY ANOTHER
	JUMPE	W,PSIBE1	;CHECK IF NOT IN TABLE
	MOVE	W,LBIT+44(W)	;GET MODULE BIT
	JRST	PSI0
PSIB0:	MOVEI	L,NIBSW		;NUMBER OF STATE TABLE WORDS
	HRLOI	W,377777	;PUT ALL SYMBOLS BUT OPCODES
PSI0:	MOVEM	W,MM1		;SAVE MODULE MASK
	SKIPE	BFSW		;IS THERE A FILE?
	JRST	PSIBE2		;NO. EXIT
	SETZM	SCNT		;ZERO COUNT OF SYMBOLS WRITTEN
	SETZM	SYHDR		;CLEAR HEADER OF NEW RECORD
	MOVEM	L,SYHDR+1	;PUT MODULE NAME IN HEADER
	MOVEI	V,SYTYP		;GET SYMBOL TABLE RECORD TYPE
	MOVEI	M,SYHDR		;ADDRESS NEW RECORD HEADER
	DPB	V,IBTYPP	;INSERT TYPE IN HEADER
	PJS	IRHDR		;INITIALIZE INDEX AND RECORD HEADER
	MOVE	W,BAD		;SAVE BLOCK ADDRESS OF FIRST BLOCK OF NEW RECORD
	MOVEM	W,B1BAD		; TO STORE SYMBOL COUNT AFTER RECORD WRITTEN
	MOVEI	L,SYDATA	;START STORING DATA AFTER HEADER
	MOVE	W,SYHDR+1	;GET MODULE NAME FROM HEADER
	TLNE	W,777777	;IS IT NUMBER OF STATE TABLE WORDS
	JRST	PSI13		;NO
	OIBSW	IBSVER,1	;OUTPUT STATE TABLE WORDS. VERSION
	OIBSW	CURSEG,1	;CURRENT SEGMENT
	OIBSW	SEGTAB,20	;SEGMENT TABLE
	OIBSW	MODULE,1	;CURRENT MODULE
	OIBSW	MM,1		;CURRENT MODULE MASK
	OIBSW	MOA,44		;MODULE NAME TABLE
	OIBSW	MOORG,44	;MODULE ORIGIN TABLE
	OIBSW	MOUSE,44	;MODULE FX2 TABLE
PSI13:	MOVE	VS,[YHASHT-EYH,,0] ;SCAN SYMBOL TABLE FROM YHAST TO EYH
PSI1:	MOVE	W,YHASHT(VS)	;GET NEXT SYMBOL TABLE CHAIN
	JUMPE	W,PSI4		;IF EMPTY(=0), GO GET NEXT ONE
PSI2:	MOVE	M,(W)		;GET FIRST WORD OF SYMBOL TABLE ENTRY
	LDB	X,[POINT 6,M,17] ;GET MODULE NUMBER
	MOVE	X,LBIT(X)	;CONVERT TO MODULE BIT
	TDNN	X,MM1		;IS IT IN MODULE(S) TO BE WRITTEN?
	JRST	PSI3		;YES. DON'T PUT OUT TO FILE
	MOVEI	V,3		;SET SIZE OF ENTRY TO WRITE
	PJS	OSYIB		;OUTPUT SYMBOL TABLE ENTRY TO FILE
	TLNN	X,100000	;IS IT A MACRO(MODULE=2)?
	JRST	PSI3		;NO
	LDB	V,[POINT 9,2(W),26] ;YES. GET SIZE OF MACRO TEXT
	IMULI	V,3		;Convert from blocks to words
	HLRZ	W,2(W)		;GET ADDRESS OF MACRO TEXT
	PJS	OSYIB		;OUTPUT TEXT TO FILE
PSI3:	HRRZ	W,M		;GET ADDRESS OF NEXT SYMBOL TABLE ENTRY
	JUMPN	W,PSI2		;GO PROCESS IF NONZERO
PSI4:	AOBJN	VS,PSI1	;GO TO NEXT WORD IN SYMBOL TABLE
	MOVE	X,BAD		;NO MORE ENTRIES. GET BLOCK ADDRESS OF LAST BLOCK
	CAMN	X,B1BAD		;IS LAST EQUAL TO FIRST?
	JRST	PSI11		;YES. GO SET SYMBOL TABLE COUNT
	CAIN	L,SYHDR		;IS LAST BLOCK EMPTY?
	JRST	PSI10		;YES. DON'T WRITE IT OUT.
	IBOUT	SYHDR,X		;OUTPUT LAST BLOCK
	AOS	BAD		;UPDATE LAST BLOCK ADDRESS
PSI10:	IBINP	SYHDR,X,B1BAD	;GET FIRST BLOCK OF RECORD
PSI11:	MOVE	V,SCNT		;GET NUMBER OF DATA WORDS WRITTEN
	MOVEI	M,SYHDR		;ADDRESS DATA BLOCK
	DPB	V,IBSYCP	;STORE COUNT IN HEADER
	IBOUT	SYHDR,X,B1BAD	;WRITE OUT FIRST BLOCK
	CAML	X,BAD		;IS THIS FIRST TIME BLOCK WRITTEN
	AOS	BAD		;YES. UPDATE LAST BLOCK ADDRESS
	DMOVE	V,SYHDR		;GET HEADER JUST WRITTEN
	MOVE	W,IBRIXP	;ADDRESS INDEX IN ID RECORD
	DMOVEM	V,-2(W)		;RESTORE HEADER FOR RECORD
	JRST	CR

OSYIB:	ADDM	V,SCNT		;UPDATE COUNT OF DATA WORDS WRITTEN
	MOVE	OS,W		;SAVE ADDRESS OF WORDS MOVED
OSYIB1:	MOVEI	C,SYEND		;COMPUTE NUMBER OF WORDS LEFT IN BLOCK
	SUB	C,L
	CAML	C,V		;IS THERE ROOM IN BLOCK FOR NEW DATA?
	MOVE	C,V		;YES
	SUB	V,C		;REDUCE NO OF WORDS TO WRITE
	HRL	U,OS		;PUT FROM ADDRESS IN BLT POINTER
	HRR	U,L		;PUT IN TO ADDRESS
	ADD	OS,C		;UPDATE FROM ADDRESS BY WORDS WRITTEN
	ADDB	L,C		;UPDATE TO ADDRESS ALSO
	BLT	U,-1(C)		;MOVE WORDS TO RECORD
	CAIGE	L,SYEND		;IS THIS BLOCK FULL
	JRST	OSYIB4		;NO
	IBOUT	SYHDR,L,BAD	;YES.WRITE IT OUT
	AOS	BAD		;UPDATE LAST BLOCK WRITTEN ADDRESS
	MOVEI	L,SYHDR		;SET TO ADDRESS
OSYIB4:	JUMPG	V,OSYIB1	;ANYMORE WORDS TO WRITE
	RETURN			;NO. EXIT

PSIBE1:	TYPE	<   Nonexistent module name>
	JRST	DQUES3
PSIBE2:	TYPE	<   Image binary file not open>
	JRST	DQUES3

IRHDR:	MOVE	W,IBRIXP
	CAIGE	W,IBIDC-1	;INDEX FULL?
	JRST	IRH3		;NO
	PJS	UBID		;OUTPUT THIS ONE
IRH1:	MOVE	V,IBIDC		;GET CHAIN TO NEXT ID BLOCK
	CAIN	V,0		;END OF CHAIN?
	JRST	IRH2		;YES
	IBINP	IBID,V		;GET NEW BLOCK OF ID RECORD
	JRST	IRH1

IRH2:	MOVE	V,BL+11		;GET FILE BLOCK COUNT
	CAMGE	V,BAD		;HAVE WE INCREASED IT?
	MOVE	V,BAD		;YES
	MOVEM	V,BAD		;UPDATE BAD FOR NEW ID BLOCK
	MOVEM	V,IBIDC		;UPDATE CHAIN
	PJS	UBID		;REPLACE THIS ID RECORD
	PJS	IIDB		;INITIALIZE NEW ID BLOCK
IRH3:	MOVEI	M,NRHDR
	MOVE	V,BAD
	DPB	V,IBBADP	;UPATE BLOCK ADDRESS
	DMOVE	V,NRHDR
	MOVE	W,IBRIXP
	DMOVEM	V,(W)		;COPY HEADER TO INDEX
	ADDI	W,2
	MOVEM	W,IBRIXP		;POINT TO NEXT ENTRY
	RETURN

;	MODULE%G - INPUT SYMBOL TABLE FROM IMAGE BINARY FILE
GSIB1:	MOVE	I,[POINT 7,CS]	;SCAN FOR MODULE NAME
	PJS	SYMSIX		;CONVERT TO SIXBIT AND PUT IN "L"
	JUMPE	L,PSIBE1	;CHECK IF NAME FOUND
	SKIPA
GSIB0:	MOVEI	L,NIBSW		;GET ALL MODULES AND STATE INFO
	SKIPGE	BFSW		;IS THERE A FILE?
	JRST	PSIBE2		;NO.
	SETZ	X,		;SET RECORD NOT FOUND SWITCH
	SETZ	M,		;SET FIRST TIME THRU "IXSCAN"
GSI0:	PJS	IXSCAN		;GET NEXT INDEX ENTRY
	JRST	GSI20		;DONE SCANNING INDEX
	LDB	V,IBTYPP	;GET RECORD TYPE
	CAIE	V,SYTYP		;IS IT A SYMBOL TABLE RECORD
	JRST	GSI0		;NO, TRY ANOTHER.
	CAMN	L,1(M)		;IS IT THE CORRECT MODULE?
	LDB	X,IBBADP	;YES.SAVE BLOCK NUMBER
	JRST	GSI0		;GO FIND LAST MATCH
GSI20:	JUMPE	X,GSIBE1	;RECORD NOT ON FILE
	MOVEM	X,BAD		;SAVE BLOCK NUMBER
	IBINP	SYHDR,X		;READ FIRST BLOCK OF RECORD
	AOS	BAD		;SET TO NEXT BLOCK OF RECORD
	MOVEI	M,SYHDR		;ADDRESS RECORD HEADER
	LDB	V,IBSYCP	;GET NUMBER OF WORDS OF SYMBOLS
	MOVNM	V,SCNT		;SET COUNTER FOR READS
	MOVEI	V,SYDATA	;ADDRESS FIRST WORD OF DATA
	MOVEM	V,SYDAP		;SET FROM POINTER FOR "ISYIB"
	TLNE	L,777777	;IS THERE STATE INFO?
	JRST	GSI1		;NO.
	IIBSW	VS,1		;READ STATE INFO VERSION
	CAME	VS,IBSVER	;IS IT CORRECT?
	JRST	GSI2A		;NO
	MOVEI	VS,3		; Number of words/unit in macro size field
GSI21:	MOVEM	VS,IBMMUL	; Save for reading macro definitions
	IIBSW	CURSEG,1	;CURRENT SEGMENT
	IIBSW	SEGTAB,20	;SEGMENT TABLE
	IIBSW	MODULE,1	;CURRENT MODULE
	IIBSW	MM,1		;CURRENT MODULE MASK
	IIBSW	MOA,44		;MODULE NAME TABLE
	IIBSW	MOORG,44	;MODULE ORIGIN TABLE
	IIBSW	MOUSE,44	;MODULE FX2 TABLE
GSI1:	MOVEI	W,SYBUFF	;FOR NEXT SYM TABLE ENTRY
	MOVEI	V,3		;GET THREE WORDS
	PJS	ISYIB		;GO READ IN ENTRY
	JRST	CR		;NO MORE ENTRIES. GO FINISH
	MOVE	X,(W)		;GET FIRST WORD OF ENTRY
	LDB	X,[POINT 6,(W),17] ;GET MODULE NUMBER
	MOVE	X,LBIT(X)	;GET MODULE MASK
	MOVEM	X,MM1		;SAVE FOR SYMBOL DEFINING
	HLL	U,(W)		;GET MODULE NUMBER FOR DEFINING SYMBOL
	TLZ	U,777700-SYPRPM-SYPROP	;save module mask and proprietary
	TRNE	F2,TYMPRP	; Does user have Tymshare license?
	TLZ	U,SYPRPM+SYPROP	; Yes, clear proprietary bits
	MOVE	L,1(W)		;GET SYMBOL NAME
	MOVE	VS,2(W)		;GET SYMBOL VALUE
	SKIPGE	(W)		;IS SYMBOL UNDEFINED?
	SETZ	VS,		;YES. FORCE VALUE ZERO.
	TLNE	X,100000	;IS SYMBOL A MACRO
	JRST	GSI2		;YES. GO GET TEXT AND DEFINE
	PJS	DY		;DEFINE A NONMACRO DEFINED SYMBOL
	JRST	GSI1		;GO GET NEXT SYMBOL FROM FILE

GSI2:	LDB	Y,[POINT 9,VS,26] ;GET NUMBER OF BLOCKS OF TEXT
	IMUL	Y,IBMMUL	; Convert to number of words written
	HRL	VS,YEND		;SET TEXT ADDRESS IN VALUE WORD
	ADDB	Y,YEND		;ADJUST END OF MEMORY
	TLNN	Y,777777	; Is request past end of memory?
	CORE	Y,		;GET MEMORY FOR MACRO TEXT
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	HLRZ	W,VS		;GET ADDRESS OF MACRO TEXT
	LDB	V,[POINT 9,VS,26] ;GET NUMBER OF WORDS AGAIN.
	IMUL	V,IBMMUL	; Convert to number of words written
	PJS	ISYIB		;READ IN MACRO TEXT
	CPF			;REPORT ASSEMBLER INTERNAL ERROR			;IT BETTER BE THERE!
	PJS	DOM		;GO DEFINE MACRO
	JRST	GSI1		;GO GET NEXT ENTRY

GSI2A:	CAME	VS,IBSOVR	; Is it old version which wrote 1/3 of macro
	JRST	GSIBE2		; No, error
	MOVEI	VS,1		; Yes, set up macro size multiplier
	JRST	GSI21

ISYIB:	ADDM	V,SCNT		;DECREMENT FILE WORD COUNT
	SKIPG	SCNT		;ENOUGH WORDS IN FILE FOR REQUEST
	JRST	ISYIB0		;YES
	CAME	V,SCNT		;WAS "SCNT" ZERO WHEN CALLED
	CPF			;NO. IT SHOULD HAVE BEEN
	RETURN			;YES. EXIT WITH NONSKIP FOR EOF
ISYIB0:	AOS	(S)		;SET SKIP RETURN
	PUSH	S,W		;SAVE BUFFER ADDRESS
	MOVE	X,SYDAP		;GET ADDRESS OF NEXT DATA WORD IN BUFFER
ISYIB1:	CAIGE	X,SYEND		;ANYMORE WORDS IN BUFFER?
	JRST	ISYIB2		;YES
	IBINP	SYHDR,X,BAD	;GET NEXT BLOCK FROM FILE
	AOS	BAD		;INCREMENT BLOCK NUMBER
	MOVEI	X,SYHDR		;ADDRESS TOP OF BUFFER
ISYIB2:	MOVEI	C,SYEND		;ADDRESS END OF BUFFER
	SUB	C,X		;COMPUTE WORDS REMAINING IN BUFFER
	CAML	C,V		;ENOUGH FOR THIS REQUEST?
	MOVE	C,V		;YES. MOVE WHOLE REQUEST
	SUB	V,C		;DECR BY NUMBER TO BE MOVED
	HRL	M,X		;ADDRESS FROM BUFFER
	HRR	M,W		;ADDRESS TO BUFFER
	ADD	X,C		;INCREMENT FROM ADDRESS
	ADDB	W,C		;INCR TO ADDRESS AND ADDRESS END OF TO BUFFER
	BLT	M,-1(C)		;MOVE DATA
	JUMPG	V,ISYIB1	;CHECK IF MORE DATA NEEDED
	MOVEM	X,SYDAP		;SAVE FROM BUFFER POINTER
	POP	S,W		;RESTORE ADDRESS OF TO BUFFER
	RETURN

GSIBE1:	TYPE	<   Module not in file>
	JRST	DQUES3
GSIBE2:	TYPE	<   Incorrect state info version>
	JRST	DQUES3

;DELETE ONE SYMBOL
KILSYM:	MOVE	I,[POINT 7,CS]
	PJS	SYMSIX
	MOVE	W,MM
	MOVEM	W,MM1
	PJS	DELSYM
	JRST	CR

;	CONVERT ASCII SYMBOL POINTER TO BY "I" TO SIXBIT.
;	RETURN SYMBOL IN "L".
SYMSIX:	SETZ	L,		;CLEAR SYMBOL
	MOVE	W,[POINT 6,L]
SSIX1:	ILDB	C,I		;GET NEXT CHARCATER OF SYMBOL
	MOVE	V,CT(C)		;GET CHARACTER TYPE
	XCT	SIXTAB(V)	;CONVERT TO SIXBIT
	IDPB	C,W		;ADD TO SIXBIT SYMBOL
	TLNE	W,770000	;ANYMORE ROOM?
	JRST	SSIX1		;YES. GET NEXT CHARACTER
	RETURN

SIXTAB:	REPEAT	2,<RETURN>
	SUBI	C,40
	SUBI	C,40
	ANDI	C,77
	SUBI	C,40
	ANDI	C,77
	MOVEI	C,'.'
	REPEAT	7,<RETURN>

;	SET LINE AND PAGE SIZE FOR LISTER.
SETLS0:	MOVEI	W,ICHPLN	;RESTORE INITIAL LINE SIZE
	MOVEM	W,CHPLN
	MOVEI	W,ILNPPG	;RESTORE INITIAL PAGE SIZE
	MOVEM	W,LNPPG
	JRST	CR
SETLS2:	MOVEI	W,^D10		;SET RADIX TO TEN
	MOVEM	W,TRADIX
	SKIPE	BC		;WAS A STATEMENT USED AS ARG
	JRST	DQUES		;YES. ERROR
	PJS	AA		;ASSEMBLE ARGS WITH RADIX OF 10
	SKIPE	GSEC		;ANY ERRORS?
	JRST	DQUES		;YES
	MOVE	W,VTAB		;GET FIRST ARG
	MOVE	X,ARGC		;GET WHETHER 1 OR 2 ARGS
	CAIE	X,2
	JRST	SETLS1		;1 ARG
	CAIL	W,CPLMIN	;CHECK LINE LENGTH FOR OUT OF BOUNDS
	CAILE	W,CPLMAX
	JRST	SETLS4
	MOVEM	W,CHPLN
	MOVE	W,VTAB+2	;GET NEW PAGE SIZE
SETLS1:	CAIL	W,LPPMIN	;CHECK PAGE LENGTH FOR OUT OF BOUNDS
	CAILE	W,LPPMAX
	JRST	SETLS5
	MOVEM	W,LNPPG
	JRST	CR
SETLS4:	TYPE	<   Line length out of bounds>
	JRST	DQUES3
SETLS5:	TYPE	<   Page length out of bounds>
	JRST	DQUES3

;	START CREF OR MULTILISTING.
BCREF0:	SETZB	L,VTAB		;TYPE=0,FILENAME=NULL
	SETZB	U,X		;no username or extension
	JRST	BCREF
BCREF1:	SETZM	VTAB		;TYPE=0
	MOVE	I,[POINT 7,CS]	;SCAN FOR FILE NAME
	JRST	BCREF3
BCREF2:	SOS	ARGC1		;GET FIRST ARG AS TYPE
	PJS	AA
	SKIPE	GSEC		;ANY ERRORS?
	JRST	DQUES		;YES
BCREF3:	ILDB	W,I		;see if there is a file name
	CAIE	W,";"		;check for terminator
	JRST	BCREF4		;not found
	SETZ	L,		;set no file name
	SETZB	U,X		;set no username or extension
	JRST	BCREF
BCREF4:	ADD	I,BACKUP	;fix byte pointer to rescan first character
	MOVE	VS,[ILDB W,I]	;get file name from CS via I
	MOVEI	C,";"		;terminate on a semicolon
	PJS	GFNX		;get file name
	JRST	DQUES		;not a well formed file name
BCREF:	MOVE	W,VTAB		;GET ARG
	CAIL	W,0		;MUST BE GREATER THAN OR EQUAL TO 0
	CAIL	W,6		;AND LESS THAN SIX
	JRST	DQUES
	TRNE	F2,MLTLST	;HAS IT BEEN STARTED ALREADY?
	JRST	DQUES		;YES.ERROR
	TRNN	W,1		;ARG=0,2 OR 4 FOR CREF
	TRO	F2,CRFLST
	TRNN	W,6		;ARG=0 OR 1 FOR PASS 1 LISTING
	TRO	F2,PS1LST
	TRNE	W,4		;ARG=4 OR 5 TO FORCE LISTINGS
	TRO	F2,FRCLST
	TRO	F2,MLTLST	;SET MULTILISTING.
	SETZM	LOH		;SET LISTING FILE NOT OPEN
	DMOVEM	L,LE		;SAVE FILE NAME and extension
	DMOVEM	X,LEUSR		;save user name
	JUMPL	U,CR		;extension specified. don't set one
	MOVE	M,[SIXBIT /CRF/]
	TRNN	F2,CRFLST
	MOVE	M,[SIXBIT /LST/]
	MOVEM	M,LE+1		;set default extension
	JRST	CR

;	END CREF LISTING
ECREF:	TRZ	F2,MLTLST+FRCLST+PS1LST
	PJS	CLF		;CLOSE LISTING FILE.
	TRZ	F2,CRFLST
	SETZM	LE		;CLEAR LIST FILE NAME
	JRST	CR

;
;	Open command file for input.
;	This is the ;X command. It takes one argument before the semicolon.
;	It must either be zero or one. If no argument is given, zero is assumed.
;	Zero means the command file input should be echoed.
;	One means don't echo.
;
SETCMD:	MOVE	W,CURCMD	;index of current command file
	CAIL	W,CMDLIM	;are all used up?
	JRST	SCER1		;yes. error
	SKIPE	W,ARGC		;are there no arguments?
	MOVE	W,LVV		;no. get argument
	JUMPL	W,SCER2		;cannot be less than zero
	CAILE	W,1		;nor greater than one
	JRST	SCER2
	PJS	BL3
	PJS	GFN		;get file name
	JRST	DQUES		;not a well formed file name
	DMOVEM	L,CMDNAM	;save name and extension
	DMOVEM	X,CMDUSR	;save user name
	SETZB	W,CMDNAM+2
	SKIPE	CMDUSR		;was a user name set
	HRRZI	W,CMDUSR	;yes
	MOVEM	W,CMDNAM+3	;refer to it in lookup block
	MOVE	X,CURCMD	;get current command file index
	MOVE	Y,CMDBFA+1(X)	;get address of next buffer
	MOVEM	Y,CMDBLK+2	;store for init
	ADDI	Y,3		;address data buffer
	MOVEM	Y,.JBFF		;store for buffer allocation
	MOVEI	W,CMDCHN+1(X)	;get next channel to use
	HRLI	W,.CHOPN	;set to do init on channel
	CHANIO	W,CMDBLK
	JRST	DQUES		;cannot init
	HRLI	W,.CHIBF	;set up to allocate buffers
	CHANIO	W,CMDNBF
	HRLI	W,.CHLK		;set up for lookup
	PJS	LOOKCK		;check username for license (xct of .+1)
	 CHANIO	W,CMDNAM
	  JRST	DQUES		;cannot find file
	MOVN	W,LVV		;get argument and convert to internal
	SKIPG	ARGC		;was an argument specified?
	MOVE	W,CMDECO(X)	;no. Use previous files echo flag
	MOVEM	W,CMDECO+1(X)	;store as -1 or 0
	MOVE	W,[PJS CFINP]	;set up as file input first
	MOVEM	W,CMDSRC+1(X)
	MOVEM	W,GCHI		;set character source instruction
	AOS	CURCMD		;make new command file the current one
	JRST	CR

SCER1:	TYPE	< Maximum number of command files open>
	JRST	DQUES3
SCER2:	TYPE	< Argument must be 0 or 1>
	JRST	DQUES3

;
;	Close one or more command files. If the argument is zero or not given
;	close all the command files. Otherwise close the number specified.
;
RSTCMD:	SKIPE	X,ARGC		;argument specified?
	MOVE	X,LVV		;yes. get it
	JUMPL	X,DQUES		;must be positive
	JUMPE	X,RCMD1		;if zero, go close all files
	PJS	CFCLS		;close most recently open file
	SOJG	X,.-1		;close another if needed
	JRST	CR
RCMD1:	PJS	CFACLS		;close all command files
	JRST	CR
;
;	Print version, date, time and system information
;
PRTVER:	PJS	TTLDAT		;get date and time into title
	OUTSTR	STDTTL		;and print it
	OUTSTR	[ASCIZ "  Sysno "]
	MOVEI	X,6		;get first 7 words of configuration info
PVER1:	HRLZ	Y,X		;index of word to get
	HRRI	Y,.GTCNF	;configuration table
	GETTAB	Y,		;get word into Y
	JRST	DQUES
	MOVEM	Y,SYSNO(X)	;save it
	SOJGE	X,PVER1		;get another
	OUTSTR	SYSNO
	OUTCHI	" "
	OUTSTR	SYSNO+5		;print system date
	JRST	CR

SETFCS:	MOVE	V,LVV
	MOVEM	V,FCSMIN
	JRST	CR

SETRLY:				;SET RELAY SWITCH FOR ENGINE CIRCUITS. SEE TEST IN RIP SUBROUTINE.
	MOVE	V,LVV
	MOVEM	V,ASCHEX
	JRST	CR		;0 FOR NORMAL SETTING

SCPC:				; ; : OR % COMMAND
	ADD	I,BACKUP	;DECREMENT BYTE POINTER BY ONE CHARACTER
	TLO	F,DCCF		;FLAG ; : OR % SEEN
	XCT	GCHI		;GET INPUT CHAR
	CAIL	W,"a"
	CAILE	W,"z"
	SKIPA
	SUBI	W,40
	MOVEI	U,CT1
	SKIPE	VS
	PJS	[
	MOVEI	U,CT2
	CAIE	VS,1
	MOVEI	U,CT3
	RETURN
	]
	PJS	CMLOOK	;DO A DISPATCH FROM ALTERNATE COMMAND TABLE
	JUMPE	V,DQUES1	;USER ERROR
	JRST	CR4

PCPO:				;PERCENT C OR PERCENT O COMMANDS.
	AUXCHK
	HRL	W,CN
	HRRI	W,4
	AUXCAL	W,10(VS)	;SEND CONTROL C OR O
	HRRI	W,6
	AUXCAL	W,		;CLEAR AUXILIARY INPUT
	HRROI	W,7
	AUXCAL	W,		;STOP COMMAND CIRCUIT OUTPUT FLOOD
	JRST	CR

PBS:				;PERCENT BACKSLASH COMMAND
	AUXCHK
	HRL	W,CN
	HRRI	W,4
	AUXCAL	W,"\"
	JRST	CR

;	COMMAND FILE COMMENTS. CAN ALSO COME FROM TERMINAL.
;	IGNORES ALL CHARACTERS TO CARRIAGE RETURN AND THEN TREATS
;	COMMAND AS THOUGH ONLY A CARRIAGE RETURN WAS TYPED.

CCOMNT:	XCT	GCHI		;GET NEXT COMMAND CHARACTER
	CAIE	W,15		;IS IT A CARRIAGE RETURN
	JRST	CCOMNT		;NO. IGNORE
	MOVE	W,ARGC		;GET NUMBER OF ARG
	JUMPE	W,CRET0		;GO TO PROPER CARRIAGE RETURN COMMAND
	CAIGE	W,2
	JRST	CRET1
	JRST	CRETP

CRET0:	DMOVE	W,DTOM
	DMOVEM	W,TOM
	DMOVE	W,DWCLM
	DMOVEM	W,WCLM
	MOVE	W,RADIX
	MOVEM	W,TRADIX
	JRST	CR1
CRET1:	SKIPE	GSEC
	JRST	DQUES

	PJS	@ICJMP
	SKIPN	OPEN
	JRST	CRET0
	DMOVE	V,VTAB
	MOVE	Y,PC
	PJS	VM
	JRST	CRET0
CRETP:	PJS	@ICJMP
	JRST	CR1

COLONC:	PJS	AAL		;DEFINE LABEL
	SKIPE	GSEC
	JRST	DQUES1
	PJS	BL3
	JRST	CR2

QUOTE1:	MOVE	V,VTAB
	MOVEM	V,PC
QUOTE:	MOVEI	M,17*5		;QUOTE COMMAND. USED TO ENTER ASC INTO MEMORY.
	XCT	GCHI
	MOVE	Y,W		;USER SPECIFIED STRING DELIMITER
	XCT	GCHI
	IDPB	W,DOS
	CAME	W,Y
	SOJG	M,.-3		;BUILD STRING
	JUMPLE	M,DQUES		;STRING TOO LONG
	XCT	GCHI
	CAIE	W,15
	JRST	DQUES		;CR MUST FOLLOW DELIMITER

	MOVE	W,PC
	MOVE	I,[POINT 7,DOS+1]	;COPY STRING TO MEMORY
	ILDB	V,I
	CAMN	V,Y
	JRST	.+3
	PJS	PBY
	AOJA	W,.-4
	MOVEM	W,PC
	JRST	CR1

LF1:	PJS	@ICJMP
	DMOVE	V,VTAB
	MOVE	Y,PC
	PJS	VM
LF0:	MOVE	V,CMLDTA
	SKIPE	COS
	ASH	V,1
	JUMPL	V,LFA		;^ OR L.F ?
	OUTCHI	15
	MOVE	Y,PC
	PJS	MV
	HRRZ	V,U
	LSH	V,1
	JUMPG	V,LFB		;U 1,2,3 TO V 2,4,6 FOR INSTRUCTIONS
	MOVEI	V,2
	SKIPE	COS
	MOVEI	V,4		;BYTE COUNT FOR CONSTANT
	JRST	LFB

LFP:	PJS	@ICJMP
	JRST	DQUES

LFA:	PJS	TYPEOL
LFB:	ADD	V,PC
	PJS	FC
	SETOM	OPEN
	JRST	CR2

SL0:	MOVEI	W,FCC		;SLASH COMMAND. NO ARGS.
	SETZ	X,
	JRST	SL5		;DONT OPEN CELL UNLESS ALREADY OPENED
SL1:	SETO	X,		;OPEN AND TYPE OUT
	MOVEI	W,FCCPC
SL5:	DMOVE	V,LVV
	JUMPN	U,DQUES1
	SKIPL	VS
	MOVEM	VS,TOM
	IORM	X,OPEN		;MAYBE OPEN A CELL
	PJS	(W)
	PJS	DOSOUT		;FULL CELL CONTENTS TO TTY
	JRST	CR2

SL2:	SKIPL	VS
	MOVEM	VS,TOM		;TYPE OUT A RANGE OF CELLS
	MOVE	V,VTAB+2	;GET 2ND EXPRESSION
	CAMLE	V,VTAB		;IS IT AN ADDRESS OR A LENGTH?
	JRST	SL2A		;IF AN ADDRESS
	ADD	V,VTAB		;A LENGTH, CHANGE TO AN ADDRESS
	SOS	V
	MOVEM	V,VTAB+2	;SAVE ENDING ADDRESS
SL2A:	MOVE	W,NCLM		;GET CURRENT NUMBER OF COLUMNS
	MOVEM	W,CLMCNT	;INIT COLUMN COUNT
	PJS	TYPEOL		;OUTPUT CRLF
SL2B:	MOVE	V,VTAB		;NEXT ADDRESS TO LIST
	CAMLE	V,VTAB+2
	JRST	CR		;DONE WITH TYPEOUT
	PUSH	S,V
	PJS	IZDOS
	SKIPE	NCLM
	JRST	SL2C		;IF COLUMIZED OUTPUT
	PJS	XS		;OUTPUT LABEL
	MOVEI	W,134
	IDPB	W,DOS		;OUTPUT BACKSLASH
SL2C:	POP	S,V
	MOVEM	V,PC
	MOVE	Y,V
	PJS	MV		;GET VECTOR VALUE
	DMOVEM	V,LVV
	SKIPN	NCLM
	PJS	DOS3B		;OUTPUT 3 BLANKS IF NOT COLUMIZED
	PJS	XVU		;TRANSLATE VALUE VECTOR TO STRING DOS
	SKIPN	NCLM
	JRST	SL2F		;IF NOT COLUMIZED OUTPUT
	HRRZ	W,DOS		;CURRENT PTR (DOS+n)
	SUBI	W,DOS		;n
	IMULI	W,5		;5*n
	HLRZ	X,DOS		;GET p
	LSH	X,-14
	IDIVI	X,7		;p/7
	SUB	W,X		;5*n-p/7=LENGTH IN CHARACTERS
	MOVE	X,WCLM		;WIDTH OF COLUMN
	SUB	X,W		;NUMBER OF PADDING BLANKS
	JUMPGE	X,SL2E		;IF DATA LESSTHAN WIDTH
	SETZ	W,
	IDPB	W,DOS		;MARK END OF STRING
	PJS	IZDOS		;GO TO TOP AGAIN
SL2D:	ILDB	W,DOS
	AOS	X
	JUMPLE	X,SL2D		;IF IGNORING CHARACTERS
	SKIPN	W
	JRST	SL2H		;END OF STRING
	OUTCHR	W
	JRST	SL2D
SL2E:	SKIPG	X
	JRST	SL2G		;NO MORE BLANKS
	OUTCHI	40
	SOS	X
	JRST	SL2E

SL2F:	PJS	DOS3B		;OUTPUT 3 BLANKS
SL2G:	PJS	DOSOUT		;OUTPUT THE STRING
SL2H:	HRRZ	V,LVV+1
	JUMPN	V,.+4
	MOVEI	V,1
	SKIPE	COS
	MOVEI	V,2
	LSH	V,1
	ADDM	V,VTAB
	SKIPN	NCLM
	JRST	SL2A		;IF NOT COLUMIZING
	SOS	W,CLMCNT	;# OF COLUMNS LEFT
	JUMPLE	W,SL2A		;IF NO MORE LEFT
	OUTCHI	40
	JRST	SL2B

EQ01:	SKIPL	VS
	MOVEM	VS,TOM
	DMOVE	V,LVV
	CAIN	VS,3		;IS THIS THE "_" COMMAND?
	JRST	EQ02		;YES
	PJS	XVUB
	PJS	DOSOUT
	JRST	CR2
EQ02:	PUSH	S,FCSBND	;SAVE MAX SYMBOL DIFFERENCE
	HRLOI	VS,377777	;GET LARGEST ADDRESS DIFFERENCE
	MOVEM	VS,FCSBND	;ALLOW ALL SYMBOLS TO BE USED
	PJS	XVUB		;CALCULATE ADDRESS VALUE
	POP	S,FCSBND	;RESTORE "FCSBND"
	PJS	DOSOUT		;PRINT SYMBOL AND OFFSET
	JRST	CR2

LIBOOT:	SKIPA	OS,S		;NEGATE OS FOR BOOT LOAD
LI:	SETZ	OS,		;LOAD ENGINE
	PJS	TYPEOL
	MOVEI	W,4
	SLEEP	W,
	HRROI	Y,16
	AUXCAL	Y,VS		;SET OUTPUT BAUD RATE
	MOVE	U,ARGC
	ANDI	U,1
	ADD	U,U		;U=0 IF 2 ARGS,U=2 IF 3 ARGS.
	MOVE	V,VTAB
	MOVEM	V,IPC
	MOVE	V,VTAB(U)
	MOVE	U,VTAB+2(U)
	PJS	DB
	TYPE	<$Loaded$>
	HRLI	W,41
	HRRI	W,20000
	HIBER	W,		;RUNOUT TTY OUTPUT
	SETO	W,		;ERR RETURN FROM HIBER
	HRROI	Y,16
	MOVE	VS,OBR
	AUXCAL	Y,VS
	JUMPG	W,CR1
	CPF			;REPORT ASSEMBLER INTERNAL ERROR

DB:			;DUMP BLOCK
;			V=PC
;			IPC=ENGINE PC
;			U=BYTE COUNT
;			OS NEG. IF BOOT DUMP
;			C IS CHECKSUM REGISTER
	SETOM	DBLCHR
	SETZ	C,		;INITIALIZE LAST CHR SENT AND CHECKSUM
	JUMPL	OS,DB1
	IONEOU	[200]		;OUTPUT A RESET
	LDB	W,[POINT 8,IPC,19]
	PJS	DBCHR2
	LDB	W,[POINT 8,IPC,27]
	PJS	DBCHR2
	LDB	W,[POINT 8,IPC,35]
	PJS	DBCHR2
	LDB	W,[POINT 8,U,19]
	PJS	DBCHR2
	LDB	W,[POINT 8,U,27]
	PJS	DBCHR2
	LDB	W,[POINT 8,U,35]
	PJS	DBCHR2

DB1:	SOJL	U,DB2
	MOVE	W,V
	CA
	LDB	W,W
	PJS	DBCHR
	AOJA	V,DB1
DB2:	MOVN	W,C
	ANDI	W,177
	PJS	DBCHR3	;SEND CHECKSUM
	HRRI	W,202
	JRST	DBCHR3		;RESET ENGINE LOADER,POP BACK FROM DB

DBCHR:	JUMPL	OS,DBCHR3
	JUMPE	U,DBF
	CAME	W,DBLCHR
	JRST	DBF
	MOVE	X,DBC0
	IOR	X,DBC1
	CAIGE	X,367
	JRST	DBCHR1

DBF:				;FLUSH ZEROS OR ONES PATTERN IF ANY ACCUMULATING.
	SOSGE	X,DBC0
	JRST	DBF1
	JUMPG	X,.+3
	IONEOU	[0]
	JRST	DBF9
	IONEOU	[203]
	ADDI	X,211
	IONEOU	X
	ADDI	C,203(X)
DBF1:	SOSGE	X,DBC1
	JRST	DBF9
	JUMPG	X,.+3
	IONEOU	[-1]
	SOJA	C,DBF9
	IONEOU	[204]
	ADDI	X,211
	IONEOU	X
	ADDI	C,204(X)
DBF9:	SETZM	DBC0
	SETZM	DBC1

DBCHR1:	MOVEM	W,DBLCHR
	JUMPE	U,DBCHR2
	JUMPN	W,.+3
	AOS	DBC0
	RETURN
	CAIE	W,377
	JRST	.+3
	AOS	DBC1
	RETURN

DBCHR2:	CAIG	W,204
	CAIG	W,177
	JRST	DBCHR3
	IONEOU	[201]
	ADDI	C,201
	XORI	W,200
DBCHR3:	IONEOU	W
	ADD	C,W
	RETURN

;	HERE FOR CTL(N) = ENGINE "M" COMMAND.
ICM:	SOS	CMLCHR

;	PROCESS ENGINE COMMAND CHARACTER.
IC:	AUXCHK
	HRRZ	V,CMLCHR
	HRRZ	W,CMLCHR
	IORI	V,300
	CAIL	W,40		;IS CHARACTER PRINTABLE?
	JRST	IC6		;YES, DON'T ECHO IT THEN
	OUTCHR	V		;ECHO PRINTABLE CHR
	OUTCHI	" "
IC6:	MOVEM	V,ICCHR
	ADD	I,BACKUP	;BACKUP TO BEGINNING OF CMND STRING
	MOVE	U,CMLU
	MOVS	U,1(U)
	MOVSM	U,ICX		;SAVE CMD WORD
	JRST	(U)
IC2:	SKIPGE	ICCHR
	RETURN
	POP	S,W		;THROW AWAY RETURN
;	SEND COMMAND CHACACTER TO ENGINE.
IC3:	HRL	W,CN
	HRRI	W,3
	AUXCAL	W,ICCHR
	HRRI	W,4		;send immediate character
	SKIPE	ICCTRM		;should terminator be sent
	AUXCAL	W," "
	SETZ	I,
	HRR	W,ICX
	JRST	(W)

;	SEND THE ARGUMENTS TO THE ENGINE.
IC4:	SOSGE	ARGC
	JRST	CR1
	PJS	ICSA
	MOVEI	V,","
	PJS	SDI		;ARG FOLLOWED BY COMMA
	JRST	IC4


;	RELAY UNKNOWN : CMD TO AUX CIRCUIT
ICRLY:	AUXCHK
ICRLY0:	XCT	GCHI		;GET NEXT CHAR
	MOVE	V,W
	CAIN	V," "
	JRST	ICRL2		;IF END OF COMMAND
	CAIN	V,","
	JRST	ICRL2		;IF END OF COMMAND
	CAIN	V,15
	JRST	ICRL1		;IF CR, NO PARAMETERS FOR COMMAND
	PJS	SDI		;SEND NEXT COMMAND CHARACTER
	JRST	ICRLY0		;GET ANOTHER

ICRL1:	PJS	SDI		;sent terminator
	JRST	CR1		;and exit. nothing more to do

ICRL2:	MOVEM	V,CMLCHR	;SAVE COMMAND TERMINATOR
	SETZM	ICCTRM		;don't send terminator
	JRST	IC6		;SET UP COMMAND


;	:W OR :WR - SEE WHICH IT IS.
ICW:	AUXCHK
	XCT	GCHI		;NEXT CHARACTER
	CAIL	W,"a"		;CONVERT lower to UPPER
	CAILE	W,"z"
	SKIPA
	SUBI	W,40
	CAIN	W,"R"		;IS THIS :WR COMMAND?
	JRST	ICWR		;IF :WR
	DPB	W,I		;INSERT 1ST ARG CHAR IN COMMAND LINE
	IBP	I		;INCREMENT FOR BACKUP.
	MOVEI	V,[ EXP 0,CR3_22+ICW9]
	MOVEM	V,CMLU		;SET UP FOR NEXT COMMAND ADDRESSES
	JRST	IC		;SUCCESS. GO GET ARGS.
;	RETURN HERE TO PROCESS ARGS.
ICW9:	MOVE	V,ARGC
	CAIE	V,2		;2 ARGUMENTS?
	JRST	DQUES		;MUST BE 2 FOR NOW
	MOVEI	W,4		;send count of four bytes
	EXCH	W,VTAB+2	;send as second argument
	MOVEM	W,VTAB+4	;and make second arg the third arg
	AOS	ARGC		;one arg added
	JRST	IC4

;	:W,ADR,VAL OR PHYADR,VIRADR,CNT:W - WRITE DATA.
;	ALSO OLD CONTROL W GOES HERE.
ICW1:				;CONTROL W. SEND MEMORY DATA.
	AUXCHK
	SKIPE	ARGC		;SKIP IF PHYAD,VIRAD,CNT:W FORM
	JRST	ICW2		;GET ARGUMENTS
	MOVEI	W,ICW2
	MOVEM	W,ICJMP
	JRST	IC
;	SET UP ARGUMENTS.
ICW2:	SKIPG	ARGC
	JRST	DQUES		;MUST BE AT LEAST 1 ARG
	PJS	ICBBEG		;BEGIN BINARY MODE
	MOVE	V,ARGC		;get argument count
	CAIE	V,1
	JRST	ICW6
	MOVEI	W,4
	MOVEM	W,VTAB+4	;IF ONLY ONE, ASSUME ONE WORD COUNT
ICW6:	CAIE	V,2
	JRST	ICW7
	MOVE	W,VTAB+2	;MAKE SECOND ARG BE THIRD ARG
	MOVEM	W,VTAB+4
ICW7:	CAIL	V,3
	JRST	ICW8
	MOVE	V,VTAB		;IF TWO ARGS OR LESS
	MOVEM	V,VTAB+2	;MAKE SOURCE AND DESTINATION ADDRS SAME

;	SEND THE ADDRESS AND BYTE COUNT VALUES.
ICW8:	MOVEI	V,TYMNET("W")
	PJS	SDI		;SEND W CHARACTER
	PUSH	S,VTAB+2	;save arguments in case of retry
	PUSH	S,VTAB+4
	SETZ	V,		;SEND A ZERO BEFORE ARGS
	PJS	SDI		;SEND A ZERO BEFORE ARGS
	MOVE	X,VTAB		;SEND ADDRESS TO WRITE DATA
	PJS	ICBARG
	MOVE	X,VTAB+4	;SEND COUNT OF BYTES TO WRITE
	PJS	ICBARG
;
;	Send data from PDP memory to ISIS DDT
;
ICW3:	MOVE	W,VTAB+2
	CA
	LDB	V,W
	JUMPE	V,ICW550	;CHECK FOR COMPRESSABLE 0
	CAIN	V,377		;CHECK FOR 0xFF
	JRST	ICW570
	PJS	SDI		;SEND DATA
	AOS	VTAB+2
	SOSLE	VTAB+4
	JRST	ICW3

;	SEE IF DATA WAS RECEIVED OK.
ICW35:	POP	S,VTAB+4		;restore arguments in case of retry
	POP	S,VTAB+2
	TYPE	< Data sent >
	HRLZ	W,CN
	LSH	W,11		;port number to bits 0-8 for HIBER
	IOR	W,[112,,^D2]	;wait 2 minutes for prompt to be typed
	HIBER	W,		;wait for output to be received
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	HRLZ	W,CN
	HRRI	W,10
	AUXCAL	W,		;anything in input buffer?
	JRST	ICW5		;no. DDT still waiting for more data. Data lost
	PJS	ICBEND		;LEAVE BINARY MODE
	JRST	DQUES3		;FAILED TO EXIT
	JRST	CR1
ICW5:	TYPE	<***no response - retrying$>
	HRLZ	W,CN
	HRRI	W,4
	AUXCAL	W,201		;send a flush character
	PJS	RAC		;ignore prompt
	PJS	RAC
	JRST	ICW8

;HANDLE ZERO COMPRESSION HERE
ICW550:	SETZM	CMPCNT		;INITIALIZE COUNTER
ICW552:	AOS	W,VTAB+2	;INCREMENT POINTER (AND SETUP W)
	SOSG	VTAB+4		;DECREMENT COUNTER
	JRST	ICW554		;HANDLE END OF TRANSFER
	CA
	LDB	V,W		;GET NEXT CHAR
	JUMPN	V,ICW554	;HANDLE END OF STRING
	AOS	CMPCNT		;ADD ONE TO COMPRESSION COUNT
	JRST	ICW552		;CONTINUE
ICW554:	MOVE	W,CMPCNT
	CAIL	W,3		;COUNT <= 3
	JUMPA	ICW558		;HANDLE STRING OF MORE THAN 3 ZEROS
;	A STRING OF 3 ZERO WOULD BE SENT AS 84 40 43 SO JUST SEND 3 ZEROS
ICW556:	SETZ	V,		;SET UP FOR ONE ZERO
	PJS	SDU		;SEND THE ZERO
	SOSL	CMPCNT		;COUNT CHARACTER
	JUMPA	ICW556		;HANDLE ANOTHER ONE
	SKIPG	VTAB+4		;TEST COUNTER
	JRST	ICW35		;HANDLE END OF TRANSFER
	JRST	ICW3		;HANDLE NEXT CHAR
ICW558:	MOVEI	V,204		;FORM ZERO COMPRESSION CHAR
	PJS	SDU		;SEND UNCHANGED
	MOVE	V,CMPCNT	;GET COMPRESSION COUNT
	SUBI	V,370		;SEE HOW MANY THERE WERE
	JUMPGE	V,ICW560	;HANDLE BIG BLOCK
	ADDI	V,371		;CALCULATE NUMBER OF ZEROS
	PJS	SDI		;SEND ESCAPED
	SKIPG	VTAB+4		;TEST COUNTER
	JRST	ICW35		;HANDLE END OF TRANSFER
	JRST	ICW3
ICW560:	MOVEM	V,CMPCNT	;STORE BACK FOR NEXT PASS
	MOVEI	V,370		;SET BLOCK COUNT
	PJS	SDU
	JRST	ICW554		;TRY ANOTHER BLOCK



;HANDLE 0xFF COMPRESSION HERE
ICW570:	SETZM	CMPCNT		;INITIALIZE COUNTER
ICW572:	AOS	W,VTAB+2	;INCREMENT POINTER (AND SETUP W)
	SOSG	VTAB+4		;DECREMENT COUNTER
	JRST	ICW574		;HANDLE END OF TRANSFER
	CA
	LDB	V,W		;GET NEXT CHAR
	CAIE	V,377
	JUMPA	ICW574		;HANDLE END OF STRING
	AOS	CMPCNT		;ADD ONE TO COMPRESSION COUNT
	JRST	ICW572		;CONTINUE
ICW574:	MOVE	W,CMPCNT
	CAIL	W,2		;COUNT <= 2
	JUMPA	ICW578		;HANDLE STRING OF MORE THAN 2
ICW576:	SETO	V,		;SET UP FOR ONE 0xFF
	PJS	SDU		;SEND THE 0xFF
	SOSL	CMPCNT		;COUNT CHARACTER
	JUMPA	ICW576		;HANDLE ANOTHER ONE
	SKIPG	VTAB+4		;TEST COUNTER
	JRST	ICW35		;HANDLE END OF TRANSFER
	JRST	ICW3		;HANDLE NEXT CHAR
ICW578:	MOVEI	V,205		;FORM 0xFF COMPRESSION CHAR
	PJS	SDU		;SEND UNCHANGED
	MOVE	V,CMPCNT	;GET COMPRESSION COUNT
	SUBI	V,370		;SEE HOW MANY THERE WERE
	JUMPGE	V,ICW580	;HANDLE BIG BLOCK
	ADDI	V,371		;CALCULATE NUMBER OF ZEROS
	PJS	SDI		;SEND ESCAPED
	SKIPG	VTAB+4		;TEST COUNTER
	JRST	ICW35		;HANDLE END OF TRANSFER
	JRST	ICW3
ICW580:	MOVEM	V,CMPCNT	;STORE BACK FOR NEXT PASS
	MOVEI	V,370		;SET BLOCK COUNT
	PJS	SDU
	JRST	ICW574		;TRY ANOTHER BLOCK



;	START BINARY MODE.
ICBBEG:	TRO	F2,BINMOD	;flag in binary mode
	HRLI	W,(<.IACHR>B8)
	HRR	W,CN
	TINASS	W,		;unassign character receive interrupt
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVEI	V,TYMNET("C")
	PJS	SDI
	MOVEI	V,TYMNET("B")
	PJS	SDI		;CONVERT CMD
ICBEG1:	PJS	RAC
	CAIN	W,200		;is it first character of prompt?
	JRST	ICBEG2		;yes
	PJS	ICOUT		;no. print it
	JRST	ICBEG1		;and get another
ICBEG2:	PJS	RAC
	RETURN

;	END BINARY MODE. SKIP RETURN ON SUCCESS. NONSKIP ON FAILURE.
ICBEND:	PJS	RAC		;GET COMMAND RESPONSE
	CAIE	W,200		;CHECK FOR PROMPT X'8002
	JRST	ICBE2		;NOT A PROMPT. GET FLUSH REQUEST
	PJS	RAC		;GET SECOND PART OF PROMPT
	CAIE	W,2		;IS IT REST OF PROMPT?
	JRST	ICBE5		;NO
	TYPE	<and received$>
	AOS	(S)		;set skip return
	JRST	ICBE20		;YES. SUCCESSFUL COMMAND. GO FINISH

;	RELAY OUTPUT UNTIL FLUSH REQUEST.
ICBE1:	PJS	RAC		;GET NEXT CHARACTER
	CAIN	W,200		;IS IT AN ESCAPE CHARACTER?
	JRST	ICBE4		;YES. GO GET SECOND HALF.
ICBE2:	CAIN	W,201		;IS IT A FLUSH REQUEST.
	JRST	ICBE10		;YES. RELAY FINISHED. GO FINISH COMMAND.
ICBE3:	ROT	W,-4		;OUTPUT CHARACTER IN HEX.
	OUTCHR	HEX(W)
	LSH	W,-40
	OUTCHR	HEX(W)
	JRST	ICBE1		;GET NEXT CHARACTER
ICBE4:	PJS	RAC		;GET SECOND HALF OF ESCAPE PAIR
ICBE5:	CAIL	W,2		;IS IT A DATA CHARACTER?
	JRST	ICBE6		;NO. GO TRANSLATE TO MESSAGE.
	IORI	W,200		;CONVERT TO DATA CHARACTER
	JRST	ICBE3		;AND GO OUTPUT
ICBE6:	CAIL	W,RIPXN		;Is it a known code?
	JRST	ICBE7		;no
	MOVE	W,RIPX-2(W)	;TYPE MESSAGE
	PJS	TYPEM
	JRST	ICBE1		;GET NEXT CHARACTER
ICBE7:	PUSH	S,W		;save message code
	MOVEI	W,[ASCIZ "$ISIS error code: "]
	PJS	TYPEM
	POP	S,V		;restore error code
	MOVEI	Y,16		;type in hex
	PJS	TN
	PJS	TYPEOL
	JRST	ICBE1
ICBE10:	HRL	W,CN		;HONOR FLUSH REQUEST
	HRRI	W,4
	AUXCAL	W,201
	PJS	RAC		;IGNORE PROMPT
	PJS	RAC

ICBE20:	PJS	ICBCLR		;clear binary mode
	RETURN

;	Clear binary mode to aux circuit if there is a circuit and
;	in binary mode.

ICBCLR:	HRLZ	W,CN		;send "CA" command
	HRRI	W,4
	AUXCAL	W,TYMNET("C")
	AUXCAL	W,TYMNET("A")
ICBCL1:	PJS	RAC		;get final prompt
	ANDI	W,177		;remove parity bit
	CAIE	W,15		;wait for carriage return, linefeed, *
	JRST	ICBCL1
	OUTCHR	W		;and type it
	PJS	RAC
	OUTCHR	W
	PJS	RAC
	OUTCHR	W
	HRLI	W,(<.IACHR>B8+<CHRCHN>B17)
	HRR	W,CN
	TINASS	W,		;reassign character received interrupt
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVSI	W,(1B0+1B<CHRCHN>)
	INTENB	W,		;restore character receive interrupt
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVSI	W,(1B0+1B<CHRCHN>)
	INTACT	W,
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	TRZ	F2,BINMOD	;FLAG ASCII MODE
	RETURN

;	BINARY READ FROM AUX CURCUIT. RETURN CHAR IN REGISTER "W".
;	IF DATA NOT READ, ABORT COMMAND BY ENTERING "ICBEND" AND
;	THEN GOING TO "DQUES".
;BRAC:	PJS	RAC		;READ NEXT AUX CHAR
;	CAIE	W,200		;IS IT AN ESCAPE CHAR?
;	JRST	BRAC1		;NO.
;	PJS	RAC		;GET ESCAPED CHARACTER
;	CAIL	W,2		;IS IT A DATA CHARACTER?
;	JRST	BRAC2		;NO. GO ABORT
;	IORI	W,200		;CONVERT TO DATA VALUE.
;	RETURN
;BRAC1:	CAIE	W,201		;IS IT A FLUSH REQUEST?
;	RETURN
;	PJS	ICBE10		;YES. GO TERMINATE BINARY MODE.
;	JRST	DQUES		;AND ABORT
;BRAC2:	PJS	ICBE5		;GO TERMINATE BINARY MODE.
;	JRST	DQUES

;	SEND ENGINE BINARY ARG. A ZERO BYTE MUST BE SENT BEFORE
;	ARGS. SENDS THE LOWER FOUR BYTES OF REGISTER "X".
ICBARG:	MOVE	U,[POINT 8,X,3]	;SEND 4 BYTES OF ENGINE ADRS
ICBA1:	ILDB	V,U
	PJS	SDI
	TLNE	U,770000
	JRST	ICBA1
	RETURN

RAC:	HRLZ	W,CN
	AUXCAL	W,W
	JRST	.+2
	RETURN			;READ AUX. CIRCUIT
	TYPE	<$*** Cannot input 8-bit character.>
	JRST	CDQUES

ICSA:				;SEND ARGUMENT TO ENGINE
	HRL	W,CN
	HRRI	W,3
	MOVE	U,[POINT 4,VTAB(I),3]
ICSA1:	ILDB	X,U
	AUXCAL	W,HEX(X)
	TLNE	U,770000	;ALL?
	JRST	ICSA1
	ADDI	I,2
	RETURN

ICN:	;"NEXT" COMMAND
	MOVEI	V,TYMNET("N")	;GET "N"
	MOVEM	V,CMLCHR	;MAKE IT THE COMMAND CHAR
	JRST	IC		;GO TO COMMAND SENDER AND ECHOER

;	:R OR :RR - SEE WHICH.
ICR:	AUXCHK
	XCT	GCHI		;NEXT CHARACTER
	CAIL	W,"a"		;MAP lower to UPPER CASE
	CAILE	W,"z"
	SKIPA
	SUBI	W,40
	CAIN	W,"R"		;IS THIS :RR COMMAND?
	JRST	ICRR		;IF :RR

;	:R COMMAND.
	DPB	W,I		;DEPOSIT ARGUMENT FIRST CHARACTER
	IBP	I		;INCREMENT FOR BACKUP
;	MOVEI	V,[EXP 0,CR3_22+ICR2]
;	MOVEM	V,CMLU		;SET COMMAND TRANSFER ADDRESSES.

;	CONTROL-R COMMAND
;ICR1:	PJS	ICBBEG		;ENTER BINARY MODE
	JRST	IC		;PROCESS COMMAND, GET ARGUMENTS

;	RETURN HERE WITH VALID ARGUMENTS.
;ICR2:	MOVE	V,ARGC		;GET NUMBER OF ARGUMENTS
;	CAIE	V,2		;MUST BE ONLY TWO ARGS.
;	JRST	DQUES
;	SKIPGE	VTAB+2		;CHECK COUNT OF BYTES TO READ
;	JRST	DQUES		;MUST BE POSITIVE
;	SETZ	V,		;START ARGS WITH A ZERO
;	PJS	SDI
;	MOVE	X,VTAB		;SEND ADDRESS TO READ FROM
;	PJS	ICBARG
;	MOVE	X,VTAB+2	;SEND NUMBER OF BYTES TO READ
;	PJS	ICBARG
;	SETZ	Y,		;INITIALIZE EMPTY LINE COUNT
;	MOVE	X,VTAB		;GET FIRST ADDRESS TO READ
;ICR4:	JUMPG	Y,ICR6		;ROOM FOR MORE ON LINE?
;	MOVE	V,[POINT 4,X,15]	;NO. START NEW LINE
;ICR5:	ILDB	W,V		;OUTPUT ADDRESS 
;	OUTCHR	HEX(W)
;	TLNE	V,770000
;	JRST	ICR5
;	MOVEI	Y,10		;ALLOW 8 HALFWORDS/LINE
;	TRNE	X,1		;IF ODD ADDRESS
;	OUTSTR	[ASCIZ /    /]	; SKIP FIRST BYTE.
;ICR6:	TRNN	X,1		;IF NEXT BYTE ON EVEN ADDRESS
;	OUTSTR	[ASCIZ /  /]	;THEN SEPARATE IT FROM LAST ONE
;	PJS	BRAC		;GET NEXT BYTE
;	ROT	W,-4		;GET FIRST HEX BYTE
;	OUTCHR	HEX(W)		;AND PRINT
;	LSH	W,-40		;GET SECOND BYTE
;	OUTCHR	HEX(W)		;AND PRINT IT TOO.
;	TRNN	X,1		;END OF HALFWORD?
;	JRST	ICR7		;NO
;	SOJG	Y,ICR7		;YES. END OF LINE?
;	PJS	TYPEOL		;YES. TYPE CR-LF
;ICR7:	AOJ	X,		;INCREMENT ADDRESS.
;	SOSLE	VTAB+2	;ANYMORE BYTES TO READ?
;	JRST	ICR4		;YES.
;	SKIPE	Y		;ANYTHING ON LINE?
;	PJS	TYPEOL		;YES. TYPE CR-LF
;	SETZ	Y,		;NO TERMINATION MESSAGE.
;	PJS	ICBEND		;END BINARY MORE.
;	JRST	DQUES3		;FAILED
;	JRST	CR1		;SUCCEEDED

;	:RR COMMAND.
ICRR:	MOVEI	V,TYMNET("R")
	MOVEM	V,CMLCHR	;DEPOSIT R CHARACTER
	PJS	SDI		;OUTPUT FIRST R TO ENGINE
	JRST	IC		;OPUTPUT 2ND R AND ARGS

ICE:				;READ REGISTORS COMMAND
	AUXCHK
	MOVEI	V,TYMNET("R")
	MOVEM	V,CMLCHR
	OUTCHR	V
	OUTCHR	V
	OUTCHI	" "
	PJS	SDI		;SEND FIRST R TO ENGINE
	JRST	IC		;GO SEND SECOND R AND ARGUMENTS

ICF:				;WRITE A REG.
	AUXCHK
	MOVEI	V,TYMNET("W")
	OUTCHR	V
	PJS	SDI		;SEND W TO ENGINE
	MOVEI	V,TYMNET("R")
	MOVEM	V,CMLCHR
	OUTCHR	V		;TYPE "WR "
	OUTCHI	" "
	JRST	IC		;GO SEND R AND ARGUMENTS

;	:WR - WRITE A REGISTER.
ICWR:	MOVEI	V,TYMNET("W")
	PJS	SDI		;SEND W CHARACTER
	MOVEI	V,TYMNET("R")
	MOVEM	V,CMLCHR	;SET UP R CHARACTER
	MOVEI	V,[ EXP 0,CR3_22+ICWR1]
	MOVEM	V,CMLU		;GO TO ICWR1 AFTER <CR> SEEN
	JRST	IC		;PROCESS R AND ARGS

;	RETURN HERE TO PROCESS :WR ARGUMENTS.
ICWR1:				;WRITE ONE REGISTOR COMMAND.
	AOS	W,ARGC
	CAIE	W,3
	JRST	DQUES		;ARG COUNT MUST GO FROM 2 TO 3
	MOVEI	W,1
	EXCH	W,VTAB+2
	MOVEM	W,VTAB+4
	JRST	IC4

;	:Z command. Logout from ISIS DDT.Expects a Z as confirmation.
;	Don't type command terminator.

ICZ:	SETZM	ICCTRM		;type type terminator
	JRST	IC

SDI0:	HRL	W,CN
	HRRI	W,3		;SEND DATA CHR TO ENGINE
	AUXCAL	W,[200]
	XORI	V,100
SDI:	CAIE	V,200		; X'80
	CAIN	V,201		; X'81
	JRST	SDI0
	CAIE	V,204		; X'84
	CAIN	V,205		; X'85
	JRST	SDI0
	CAIE	V,203		; X'83
	CAIN	V,217		; X'8F
	JRST	SDI0
	CAIE	V,003		; X'03
	CAIN	V,017		; X'0F
	JRST	SDI0
;	JRST	SDU		;SEND UNMODIFIED


;SEND CHARACTER UNMODIFIED
SDU:	HRL	W,CN
	HRRI	W,3		;SEND DATA CHR TO ENGINE
	AUXCAL	W,V
	RETURN

ICOUT:	SKIPE	ASCHEX		;print as two hex characters?
	JRST	ICOUT1		;yes
	OUTCHR	W		;no. just print it
	RETURN
ICOUT1:	ROT	W,-4
	OUTCHR	HEX(W)		;print first four bits as hex character
	LSH	W,-40
	OUTCHR	HEX(W)		;print second four bits
	RETURN

RIPX:	Z	IM02
	Z	IM03
	Z	IM04
	Z	IM05
	Z	IM06
	Z	IM07
	Z	IM08
	Z	IM09
	Z	IM0A
	Z	IM0B
	Z	IM0C
	Z	IM0D
	Z	IM0E
	Z	IM0F
	Z	IM10
	Z	IM11
	Z	IM12
	Z	IM13
	Z	IM14
	Z	IM15
	Z	IM16
	Z	IM17
	Z	IM18
	Z	IM19
	Z	IM1A
	Z	IM1B
	Z	IM1C
	Z	IM1E
	Z	IM1F
	Z	IM20
	Z	IM21
RIPXN==.-RIPX+2
;	ENGINE MESSAGES

IMFLUS:	ASCIZ	"type '%\'$"
IM02:	ASCIZ	"$*"
IM03:	ASCIZ	"illegal command$"
IM04:	ASCIZ	"illegal inst. at "
IM05:	ASCIZ	">>breakpoint "
IM06:	ASCIZ	"address out of range$"
IM07:	ASCIZ	"breakpoint number out of range$"
IM08:	ASCIZ	"no breakpoint to proceed from$"
IM09:	ASCIZ	"memory out of bounds$"
IM0A:	ASCIZ	"ill. reg. number$"
IM0B:	ASCIZ	"disk error -"
IM0C:	ASCIZ	"invalid number$"
IM0D:	ASCIZ	"incorrect bounds$"
IM0E:	ASCIZ	"bad search length$"
IM0F:	ASCIZ	"bad search boundary$"
IM10:	ASCIZ	"ill svc executed$"
IM11:	ASCIZ	"ill mem ref by out svc$"
IM12:	ASCIZ	"parity error$"
IM13:	ASCIZ	"ill mem ref by user program$"
IM14:	ASCIZ	" Zap? "
IM15:	ASCIZ	"jump out of bounds$"
IM16:	ASCIZ	"slot already connected$"
IM17:	ASCIZ	"illegal instruction in controlled code$"
IM18:	ASCIZ	"breakpoint already exists there$"
IM19:	ASCIZ	"DISPATCHER crash$"
IM1A:	ASCIZ	"$Bad 'M' arguments"
IM1B:	ASCIZ	"$We already have use of SPY...aborting"
IM1C:	ASCIZ	"$...aborting"
IM1D:	ASCIZ	"insufficient licence$"
IM1E:	ASCIZ	"FROZEN!$"
IM1F:	ASCIZ	"$MAC not set up correctly"
IM20:	ASCIZ	"$ABORTING--available space exceeded"
IM21:	ASCIZ	"disc area save protected$"


RELAY:				;SEND HEX TO ENGINE
	AUXCHK
RELAY0:	PJS	RELAY1
	MOVE	U,W
	LSH	U,4
	PJS	RELAY1
	IORI	W,400(U)
	MOVE	V,W
	PJS	SDI
	JRST	RELAY0

RELAY1:	XCT	GCHI
	SUBI	W,60
	JUMPL	W,CR
	CAIG	W,11
	RETURN
	SUBI	W,7
	CAIG	W,17
	CAIG	W,11
	JRST	CR
	RETURN

RELAYA:				;RELAY ASC FROM TERMINAL TO 732 UNTIL USER ESCAPES
	AUXCHK
RELAYB:	TLO	F,DCCF		;GET CHARACTERS WITHOUT LINE EDITTING
	XCT	GCHI
	MOVEI	V,400(W)
	PJS	SDI
	JRST	RELAYB

NOAUX:	TYPE	<$No aux circuit>
	JRST	DQUES3

;	Build an aux circuit.
;	The command takes two arguments. The first is the number of times
;	to do the CREAUX before failing. The second is the number of seconds
;	to wait after the CREAUX fails before executing it again.
;	Both arguments must be greater than or equal to zero.
;	If the first argument is zero, the command never stops trying
;	until the CREAUX succeedds.
;	If no arguments are, the values used are one try. In this
;	case the delay time (second argument) is meaningless.
;	If only one argument is given, thirty seconds is used
;	for the second argument. If an argument is null, its value is zero.
;
;	Abreviated command		Expanded command
;	__________________		________________
;		a,;C			      a,0;C
;		,b;C			      0,b;C
;		 ,;C			      0,0;C
;		 a;C			     a,30;C
;		  ;C			      1,-;C
;	
EC:	MOVEI	W,1		;If no args, set first arg to 1
	MOVEM	W,VTAB
ECA:	MOVEI	W,^D30		;If no second arg, set it to 30
	MOVEM	W,VTAB+2
ECAB:	SKIPGE	VTAB		;Don't allow negative first arg
	JRST	DQUES
	SKIPGE	W,VTAB+2	;Don't allow negative second arg either
	JRST	DQUES
	JUMPE	W,EC0		;If no delay, leave it as zero for check
	CAILE	W,777777	;does time fit in right half
	MOVEI	W,777777	;No. Well make it
	HRLI	W,1		;Specify delay time is in seconds for HIBER
	MOVEM	W,VTAB+2	;Put it back as second arg
EC0:	PJS	BL3		;ESTABLISH CIRCUIT
	MOVE	I,[POINT 7,CS]	;READ STRING INTO CS
EC1:	XCT	GCHI
	CAIN	W,15
	JRST	EC2
	CAIN	W,"?"
	JRST	DQUES
	CAIL	W,"a"
	CAILE	W,"z"
	SKIPA
	SUBI	W,40
	IDPB	W,I
	JRST	EC1
EC2:	TRZ	F2,BINMOD	;set initially to ascii mode
	SETZ	W,
	IDPB	W,I
	SKIPGE	X,CN		;is there another aux circuit?
	JRST	EC6		;No
	SETOM	CN		;Forget about it
	MOVE	W,X		;Get old port number
	HRLI	W,(<.IAZAP>B8)	; and deassign zapper interrupt
	TINASS	W,
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVE	W,X		;Deassign character lost interrupt
	HRLI	W,(<.IALOS>B8)
	TINASS	W,
	CPF
	MOVE	W,X		;Also deassign char recv interrupt
	HRLI	W,(<.IACHR>B8)	;(Assign cause and port to channel 0)
	TINASS	W,
	CPF
	ZAPCIR	X,		;Zap old aux circuit
EC6:	TYPE	<Working>
	HRRZI	W,CS
	CREAUX	W,
	JRST	EC3
	MOVEM	W,CN
	HRLI	W,(<.IAZAP>B8+<ZAPCHN>B17)
	TINASS	W,		;AUX CIRCUIT ZAPPER INT CHANNEL
	JRST	EC5
	HRLI	W,(<.IALOS>B8+<LOSCHN>B17)	;Aux circuit char lost int
	HRR	W,CN
	TINASS	W,
	JRST	EC5
	HRLI	W,(<.IACHR>B8+<CHRCHN>B17)
	HRR	W,CN
	TINASS	W,		;AUX CHAR RECEIVED INT CHANNEL
	JRST	EC5
	TYPE	<$Circuit ready>
	MOVSI	W,(1B0+1B<ZAPCHN>+1B<LOSCHN>+1B<CHRCHN>)
	INTENB	W,		;ENABLE AUX INTERRUPTS
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	MOVSI	W,(1B0+1B<CHRCHN>)
	INTACT	W,		;FIRE UP CHAR RCVD INTERRUPT
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	JRST	CR

EC3:	TLNN	W,777777	;Supervisor error?
	JRST	EC4		;Yes
	HLRZ	W,W		;System error. Get error code.
	ADDI	W,7
EC4:	CAIL	W,17		;Is it a known error?
	SETZ	W,		;No.
	TYPE	<*** >
	MOVE	W,CAXERR(W)	;Get error message address.
	PJS	TYPEM		;Type error message
	PJS	TYPEOL
	SOSN	VTAB		;Try again?
	JRST	DQUES3		;No. Exit
	SKIPG	W,VTAB+2	;Is there a delay before calling CREAUX again?
	JRST	EC6		;No. Go do it
	HIBER	W,		;Sleep awile
	CPF			;REPORT ASSEMBLER INTERNAL ERROR
	JRST	EC6		;Now go try again

CAXERR:	[ASCIZ	"Unknown error"]				; ?,,?
	[ASCIZ	"Bad name format"]				; 0,,1
	[ASCIZ	"Name not in MUD"]				; 0,,2
	[ASCIZ	"Bad MUD"]					; 0,,3
	[ASCIZ	"System not available"]				; 0,,4
	[ASCIZ	"Down line load or deal out request failure"]	; 0,,5
	[ASCIZ	"Time out"]					; 0,,6
	[ASCIZ	"Access not permitted"]				; 0,,7
	[ASCIZ	"Too many curcuits"]				; 1,,?
	[ASCIZ	"Bad user name"]				; 2,,?
	[ASCIZ	"Out of channels"]				; 3,,?
	[ASCIZ	"No response to request"]			; 4,,?
	[ASCIZ	"No response to string"]			; 5,,?
	[ASCIZ	"No curcuit established"]			; 6,,?
	[ASCIZ	"Error response to request"]			; 7,,?

EC5:	TYPE	<*** Cannot assign interrupts to curcuit.>
CDQUES:	SETOB	W,CN		;HERE IF AUX CIRC SETUP BOMBS
	ZAPCIR	W,		;ZAP ALL AUX CIRCUITS
	TYPE	< Curcuit zapped.$>
	JRST	DQUES3

STDTOM:	MOVEM	VS,DTOM
STTOM:	MOVEM	VS,TOM
STTOM1:	PJS	BL3
	JRST	CR2

STDCOS:	MOVEM	VS,DCOS
STCOS:	MOVEM	VS,COS
	JRST	STTOM1
STDC1:	MOVEM	VS,DCOS
	MOVE	V,VTAB
	MOVEI	W,4
	SKIPE	COS
	MOVEI	W,10
	MOVEM	V,DNCLM
	MOVEM	W,DWCLM
	JRST	STC1A
STC1:	MOVE	V,VTAB
	MOVEI	W,4
	SKIPE	COS
	MOVEI	W,10
STC1A:	MOVEM	VS,COS
	MOVEM	V,NCLM
	MOVEM	W,WCLM
	JRST	STTOM1
STDC2:	MOVEM	VS,DCOS
	MOVE	W,VTAB
	MOVE	V,VTAB+2
	MOVEM	V,DNCLM
	MOVEM	W,DWCLM
	JRST	STC2A
STC2:	MOVE	W,VTAB
	MOVE	V,VTAB+2
STC2A:	MOVEM	VS,COS
	MOVEM	V,NCLM
	MOVEM	W,WCLM
	JRST	STTOM1
	SUBTTL	COMMAND TABLES AND ERROR MESSAGES
;		**************************************************


CATAB:	POINT	8,0,9
	POINT	8,0,17
	POINT	8,0,27
	POINT	8,0,35
CATABH:	POINT	16,0,17
	0
	POINT	16,0,35
	0
CATABK:	POINT	18,0,17
	0
	POINT	18,0,35
	0

HEX:	EXP	60,61,62,63,64,65,66,67,70,71,101,102,103,104,105,106
HEX6:	EXP	20,21,22,23,24,25,26,27,30,31,41,42,43,44,45,46

XBITN==44
LBIT:	REPEAT	44,<XBITN==XBITN-1
	EXP	1_XBITN>
RBIT:	REPEAT	44,<EXP 1_XBITN
	XBITN==XBITN+1>

;	CT - CHARACTER TYPE TABLE.


	DEFINE	NCW (NCWN,NCWA),<REPEAT	NCWN,<XWD	.-CT,NCWA>>
	DEFINE	CW (CWA),<IRP	CWA,<CX CWA>>
	DEFINE	CX (CXA),<CW2	CXA>
	DEFINE	CW2 (CW2R,CW2L),<XWD	CW2L,CW2R>

CT:
	NCW	1,IT				;NULL (INPUT TRAP CHARACTER)
	CW	<<MA>,<AE>,<EM>>		;MACRO ARG, MACRO ARG END, MACRO END
	NCW	5,OH				; ^D - ^H
	CW	<<DE,TAB>,<DE,SEMIC>>		; ^I, ^J
	NCW	1,OH				; ^K
	CW	<<DE,CAR>>			; ^L <FF>
	CW	<<DE,CAR>>			; ^M <CR>
	NCW	22,OH				; ^N - ^Z, ESC, FS, GS, RS, US
	CW	<<DE,BLA>,<OP,EXCL>>		;BLANK, !
	NCW	2,OH				; " #
	CW	<<DE,DOL>,<OP,PERC>,<OP,AMP>>	; $ % &
	NCW	1,OH				; '
	CW	<<DE,LPAREN>,<DE,RPAREN>>	; ( )
	CW	<<OP,STAR>,<OP,BPLU>,<DE,COM>> 	; * + ,
	CW	<<OP,BMIN>,<PE>,<OP,SLASH>> 	; - . /
	NCW	12,DIG				; 0 - 9
	CW	<<DE,COLON>,<DE,SEMIC>>		; : ;
	NCW	1,OH				; <
	CW	<<DE,EQSIGN>>			; =
	NCW	2,OH				; > ?
	CW	<<OP,UAT>>			; @
	NCW	6,UAF				; A-F
	NCW	24,UGZ				; G-Z
	CW	<<DE,LBRAK>>			; [
	CW	<<OP,UBSLH>>			; \
	CW	<<DE,RBRAK>,<OP,UPAR>>		; ] ^
	NCW	1,OH				; _
	CW	<<CO>>				; `
	NCW	6,LAF				; a-f
	NCW	24,LGZ				; g-z
	NCW	1,OH				; {
	CW	<<VB,VB>>			; |
	NCW	3,OH				; } ~ DEL

	PURGE	NCW,CW,CX,CW2


;	CT0 - CT2  DEBUGGER COMMAND TABLES.
;
;	CM0 = 1 IF 0 ARGS ALLOWED
;	CM1 = 1 IF 1 ARG  ALLOWED
;	CM2 = 1 IF 2 ARGS ALLOWED
;	CM3 = 1 IF >2 ARGS ALLOWED
;	CMCHR = 7 BIT ASCII VALUE OF COMMAND CHARACTER
;	CMVSW = 1 IF TO ASSEMBLE ARGUMENTS INTO NUMERIC VALUE
;	CMDATA = VALUE TO PASS TO PROCESSOR IN REGISTER VS

	DEFINE	CM (CM0,CM1,CM2,CM3,CMCHR,CMVSW,CMDATA,CMADR0,CMADR1,CMADR2),<
	XWD	CM0_21+CM1_20+CM2_17+CM3_16+CMVSW_15+CMDATA_7&17_7+CMCHR,CMADR0
	XWD	CMADR1,CMADR2>

;	CT0 - COMMAND TABLE, FIRST CHARACTER PROCESSING.

CT0:
	CM	1,1,1,1,77,0,0,DQUES1,DQUES1,DQUES1	;	?
	CM	1,1,1,1,15,1,0,CRET0,CRET1,CRETP	;	CAR.RET.
	CM	1,1,1,1,12,1,0,LF0,LF1,LFP		;	L.F.
	CM	1,1,1,1,54,0,0,KCOMMA,KCOMMA,KCOMMA	;	,
	CM	1,1,1,0,134,1,-1,SL0,SL1,SL2		;	\
	CM	1,1,1,0,133,1,0,SL0,SL1,SL2		;	[
	CM	1,1,1,0,135,1,4,SL0,SL1,SL2		;	]
	CM	1,1,0,0,75,1,-1,EQ01,EQ01,DQUES1	;	=
	CM	1,1,0,0,43,1,0,EQ01,EQ01,DQUES1		;	#
	CM	1,1,0,0,137,1,3,EQ01,EQ01,DQUES1	;	_
	CM	1,1,0,0,42,1,0,QUOTE,QUOTE1,DQUES1	;	"
	CM	1,1,1,1,72,0,2,SCPC,COLONC,SCPC		;	:
	CM	1,1,1,1,73,0,0,SCPC,SCPC,SCPC		;	;
	CM	1,1,1,1,45,0,1,SCPC,SCPC,SCPC		;	%
	CM	1,0,0,0,01,0,0,IC,IC3,CR1		;	CONTROL A (INIT MAC)
	CM	1,0,0,0,02,0,0,IC,CR3,IC4		;	CONTROL B (SET BP)
	CM	1,0,0,0,05,0,0,ICE,CR3,IC4		;	CONTROL E (RR CMND)
	CM	1,0,0,0,06,0,0,ICF,CR3,ICWR1		;	CONTROL F (WRITE 1 REG)
	CM	1,0,0,0,07,0,0,IC,CR3,IC4		;	CONTROL G
	CM	1,0,0,0,10,0,0,IC,IC3,CR1		;	CONTROL H
	CM	1,0,0,0,11,0,0,IC,IC3,CR1		;	CONTROL I
	CM	1,0,0,0,13,0,0,IC,CR3,IC4		;	CONTROL K
	CM	1,0,0,0,14,0,0,IC,CR3,IC4		;	CONTROL L
	CM	1,0,0,0,16,0,0,ICM,CR3,IC4		;	CONTROL N (USED FOR M CMND)
	CM	1,0,0,0,20,0,0,IC,IC3,CR1		;	CONTROL P
	CM	1,0,0,0,21,0,0,ICN,IC3,CR1		;	CONTROL Q (NEXT)
	CM	1,0,0,0,22,0,0,IC,CR3,IC4		;	CONTROL R
	CM	1,0,0,0,23,0,0,IC,CR3,IC4		;	CONTROL S
	CM	1,0,0,0,24,0,0,IC,IC3,CR1		;	CONTROL T
	CM	1,0,0,0,25,0,0,IC,CR3,IC4		;	CONTROL U
	CM	1,0,0,0,27,0,0,ICW1,CR3,ICW2		;	CONTROL W
	CM	1,0,0,0,30,0,0,IC,CR3,IC4		;	CONTROL X
	CM	1,0,0,0,32,0,0,ICZ,IC3,CR1		;	CONTROL Z
	Z



;	CT1 - COMMAND TABLE, SECOND CHARACTER, AFTER A ;.

CT1:	CM	1,1,0,0,101,1,0,AF,SETFCS,DQUES1	;	;A
	CM	1,1,1,0,103,1,0,EC,ECA,ECAB		;	;C
	CM	1,1,1,1,113,0,0,DQUES,KILSYM,DQUES	;	;K
	CM	1,0,0,0,105,0,0,IC,IC3,CR1		;	;E
	CM	1,1,0,0,106,1,0,IBF,IBF,DQUES		;	;F
	CM	1,1,1,1,107,1,0,GIB0,GIB1,GIB2		;	;G
	CM	1,1,0,0,130,1,0,SETCMD,SETCMD,DQUES1	;	;X
	CM	1,0,0,0,115,0,0,STTOM,DQUES1,DQUES1	;	;M
	CM	1,0,0,0,116,0,1,STTOM,DQUES1,DQUES1	;	;N
	CM	1,1,1,1,120,1,0,PIB0,PIB1,PIB2		;	;P
	CM	1,0,0,0,42,0,2,STTOM,DQUES1,DQUES1	;	;"
	CM	1,0,0,0,123,0,3,STTOM,DQUES1,DQUES1	;	;S
	CM	1,0,0,0,111,0,4,STTOM,DQUES1,DQUES1	;	;I
	CM	1,1,0,0,122,1,0,RELAY,SETRLY,DQUES	;	;R
	CM	0,1,0,0,124,1,0,DQUES,TIB,DQUES		;	;T
	CM	1,1,0,0,136,1,-2,LF0,LF1,DQUES1		;	;^
	CM	1,0,0,0,134,0,-1,SL1,DQUES1,DQUES1	;	;\
	CM	1,0,0,0,133,0,0,SL1,DQUES1,DQUES1	;	;[
	CM	1,0,0,0,135,0,4,SL1,DQUES1,DQUES1	;	;]
	CM	0,0,1,1,67,1,2,DQUES,DQUES,LI		;	;7
	CM	0,0,1,1,70,1,5,DQUES,DQUES,LI		;	;8
	CM	1,1,1,0,62,1,0,STCOS,STC1,STC2		;	;2
	CM	1,1,1,0,64,1,-1,STCOS,STC1,STC2		;	;4
	CM	1,1,0,0,100,1,0,AF,SETFCS,DQUES1	;	;@ (OLD FORM OF ;A)
	CM	1,1,1,0,45,0,0,SETLS0,SETLS2,SETLS2	;	;%
	CM	1,1,1,0,50,0,0,BCREF0,BCREF1,BCREF2	;	;(
	CM	1,0,0,0,51,1,0,ECREF,DQUES1,DQUES1	;	;)
	CM	1,1,1,1,73,1,0,CCOMNT,CCOMNT,CCOMNT	;	;;
	Z


;	CT2 - COMMAND TABLE, SECOND CHARACTER, AFTER A %.

CT2:	CM	1,0,0,0,101,0,1,AF,DQUES1,DQUES1	;	%A
	CM	1,1,0,0,106,1,1,IBF,IBF,DQUES		;	%F
	CM	1,0,0,0,115,0,0,STDTOM,DQUES1,DQUES1	;	%M
	CM	1,0,0,0,116,0,1,STDTOM,DQUES1,DQUES1	;	%N
	CM	1,0,0,0,122,0,0,RELAYA,DQUES1,DQUES1	;	%R
	CM	1,0,0,0,42,0,2,STDTOM,DQUES1,DQUES1	;	%"
	CM	1,0,0,0,123,0,3,STDTOM,DQUES1,DQUES1	;	%S
	CM	1,0,0,0,111,0,4,STDTOM,DQUES1,DQUES1	;	%I
	CM	0,0,1,1,67,1,2,DQUES,DQUES,LIBOOT	;	%7
	CM	0,0,1,1,70,1,5,DQUES,DQUES,LIBOOT	;	%8
	CM	1,1,1,0,62,1,0,STDCOS,STDC1,STDC2	;	%2
	CM	1,1,1,0,64,1,-1,STDCOS,STDC1,STDC2	;	%4
	CM	1,0,0,0,100,0,1,AF,DQUES1,DQUES1	;	%@ (OLD FORM OF %A)
	CM	1,1,1,1,121,0,0,NADEX,NADEX,NADEX	;	%Q
	CM	1,1,1,1,134,0,0,PBS,PBS,PBS		;	%\
	CM	1,1,1,1,103,0,-5,PCPO,PCPO,PCPO		;	%C
	CM	1,1,1,1,117,0,7,PCPO,PCPO,PCPO		;	%O
	CM	1,1,0,0,107,0,0,GSIB0,GSIB1,DQUES	;	%G
	CM	1,1,0,0,120,0,0,PSIB0,PSIB1,DQUES	;	%P
	CM	1,1,0,0,130,1,0,RSTCMD,RSTCMD,DQUES1	;	%X
	CM	1,0,0,0,126,0,0,PRTVER,DQUES1,DQUES1	;	%V
	CM	1,1,0,0,132,1,0,MSIB0,MSIB1,DQUES	;	%Z
	Z


;	CT3 - COMMAND TABLE, SECOND CHARACTER, AFTER A :.

CT3:	CM	1,0,0,0,101,0,0,IC,IC3,CR1		;	:A
	CM	1,0,0,0,102,0,0,IC,CR3,IC4		;	:B
	CM	1,0,0,0,105,0,0,IC,IC3,CR1		;	:E
	CM	1,0,0,0,107,0,0,IC,CR3,IC4		;	:G
	CM	1,0,0,0,110,0,0,IC,IC3,CR1		;	:H
	CM	1,0,0,0,111,0,0,IC,IC3,CR1		;	:I
	CM	1,0,0,0,113,0,0,IC,CR3,IC4		;	:K
	CM	1,0,0,0,114,0,0,IC,CR3,IC4		;	:L
	CM	1,0,0,0,115,0,0,IC,CR3,IC4		;	:M
	CM	1,0,0,0,116,0,0,IC,IC3,CR1		;	:N
	CM	1,0,0,0,120,0,0,IC,IC3,CR1		;	:P
	CM	1,0,0,0,122,0,0,ICR,CR3,IC4		;	:R OR :RR
	CM	1,0,0,0,123,0,0,IC,CR3,IC4		;	:S
	CM	1,0,0,0,124,0,0,IC,IC3,CR1		;	:T
	CM	1,0,0,0,125,0,0,IC,CR3,IC4		;	:U
	CM	1,0,0,0,126,0,0,IC,CR3,IC4		;	:V
	CM	1,1,1,1,127,1,0,ICW,ICW1,ICW1		;	:W OR :WR
	CM	1,0,0,0,130,0,0,IC,CR3,IC4		;	:X
	CM	1,0,0,0,131,0,0,IC,CR3,IC4		;	:Y
	CM	1,0,0,0,132,0,0,ICZ,IC3,CR1		;	:Z
	CM	1,0,0,0,072,0,0,ICRLY,CR3,IC4		;	::
	CM	1,1,1,1,134,0,0,PBS,PBS,PBS		;	:\
	Z

	PURGE	CM



;	ERROR MESSAGE TEXTS.
MTMO:	ASCIZ	"Too many operands for opcode"
MMNIU:	ASCIZ	"Macro name in use"
MTMMA:	ASCIZ	"Too many arguments in macro definition"
MSSNOR:	ASCIZ	"Segment number out of range"
MSIORG:	ASCIZ	"Invalid origin field or origin not followed by a comma"
MSSD:	ASCIZ	"Some displ. fld expressions using this label def. are out of range"
MSLFF:	ASCIZ	"Listing file failure"
MS36MI:	ASCIZ	"36 modules in use. Limit exceeded"
MSMNI:	ASCIZ	"Module name invalid"
MSANPT:	ASCIZ	"ASC not properly terminated"
MSIH:	ASCIZ	"Improper hex"
MSOOR:	ASCIZ	"Operand out of range"
MSMOF:	ASCIZ	"Missing operand field"
MSAIUM:	ASCIZ	"Assembling into used memory"
MSNEP:	ASCIZ	"Not enough preceeding IF statements"
MSTMI:	ASCIZ	"Too many IFs. Nesting max = 36"
MSMES:	ASCIZ	"More 'ER' statements than valid 'RE' statements"
MSRRGT:	ASCIZ	"Repeat range greater than 640 characters"
MSMEIR:	ASCIZ	"Macro ends in repeat range."
MSTMNR:	ASCIZ	"Too many nested repeats. Max=4"
MSRNB:	ASCIZ	"Register field not between 0 and F"
MSIL:	ASCIZ	"Illegal literal"
MSMLF:	ASCIZ	"Missing label field"
MSUE:	ASCIZ	"Undefined expression"
MAMBP2:	ASCIZ	"Arg must be a power of 2"
MSIE:	ASCIZ	"Illegal expression"
MSIOC:	ASCIZ	"Invalid opcode"
MSUOC:	ASCIZ	"Undefined opcode"
MSILT:	ASCIZ	"Illegal label terminator"
MSUS:	ASCIZ	"Undefined not allowed"
MSEI:	ASCIZ	"Expression incomplete or syntax error"
MSMUO:	ASCIZ	"Misplaced unary operator"
MSESE:	ASCIZ	"Syntax error in expression"
MSSE:	ASCIZ	"Syntax error"
MSRV:	ASCIZ	"Radix violation"
MSONU:	ASCIZ	"Operator not unary"
MSOOM:	ASCIZ	"NAD is out of memory"
MSIC:	ASCIZ	"Illegal character"
MSFCI:	ASCIZ	"First character of statement illegal"
MSNRS:	ASCIZ	"Negative value in storage statement illegal"
MSSPCO:	ASCIZ	"Statement sets pc out of bounds"
MSILO:	ASCIZ	"Illegal list option"
MSOTPF:	ASCIZ	"Only one TITLE per file allowed"
MSTTL:	ASCIZ	"TITLE too long. Truncated"
MSKILL:	ASCIZ	"KILL of undefined symbol with unresolved references" 
MBND:	ASCIZ	"BND argument is not a power of 2, rounded up"
	SUBTTL	LITERALS
	XLIST	;don't list all the literals
LITS:	LIT
	LIST
	SUBTTL	INITIALIZE SYMBOL TABLE
;		*********************************************


MEMBAS:			;THIS AREA (NPG BY PGSIZ) FOR NODE MEMORY IS BORROWED
			;BEFORE SYMBOL TABLE INITIALIZATION FOR THE OPCODES.


IZY:	MOVNI	Y,EIZOP-IZOP	;INITIALIZE SYMBOL TABLE
IZY1:	HRLZ	U,EIZOP(Y)
	MOVE	L,1+EIZOP(Y)
	MOVE	V,2+EIZOP(Y)
	PJS	FY		;prepare for MY
	JUMPN	M,PF		;and check if already defined
	PJS	MY
	ADDI	Y,3
	JUMPL	Y,IZY1
	MOVE	L,IZDOT+1
	PJS	FY
	HRRZI	M,2(M)
	MOVEM	M,DOTP
	RETURN

	ALS	0,<X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,XA,XB,XC,XD,XE,XF>;	;HEX SYMBOLS

	DEFINE	XV(XVA,XVB),<XVV==0
	IRPC	XVA,<XVV==XVV*20+X'XVA>
	XWD	XVV,XVB>

	DEFINE	OPSET (OPSETA),<IRP OPSETA,<OPSET1 OPSETA>>
	DEFINE	OPSET1(OPSETB),<OPSET2 OPSETB>
	DEFINE	OPSET2 (OPASC,OPCOD,OPV2,OPV1),< EXP OPV2'V_6
	SIXBIT	/OPASC/
	XV	OPCOD,OPV1>

	DEFINE	DIRSET(DIRSX),<IRP DIRSX,<DSET1 DIRSX>>
	DEFINE	DSET1(DS1X),<DSET2 DS1X>
	DEFINE	DSET2(DSTXT,DSADR,DSCNT<0>),< 0
	SIXBIT	/DSTXT/
	DSCNT,,DSADR>

IZOP:	DIRSET	<<MACRO,DMAC>,<REMARK,DREM>,<NUMBER,DNUM>,<RA,DRA>>
	DIRSET	<<LINENO,DLNO>,<QUIT,DQUIT>,<NADVER,DNADV>,<ERRCNT,DERRCT>>
	DIRSET	<<UNCNT,DUNCT>,<CURGMT,DCGMT>>
	DIRSET	<<TITLE,DTTL>,<SUBTTL,DSTL>,<NOTTL,DNOTTL>,<KILL,DKIL>>
	DIRSET	<<GL,DGL>,<LIST,DLIST>,<NOLIST,DNLIST>,<EQ,DEQ>>
	OPSET	<<ORG,0,DORG,PC0>,<SEG,0,DSEG,PC0>,<BND,0,DBND,PC0>>
	OPSET	<<BS,0,DBS,PC0>,<HS,0,DHS,PC02>,<WS,0,DWS,PC04>>
	OPSET	<<AC,0,DAC,PC0>,<SC,0,DSC,PC0>,<XC,0,DXC,PC0>,<END,0,DEN,PC0>>
	OPSET	<<BC,0,DBC,PC0>,<HC,0,DHC,PC02>,<WC,0,DWC,PC04>>
	DIRSET	<<MO,DMO>,<EM,DEM>,<LO,DLO>>
	DIRSET	<<FO,DFO>,<US,DUS>>
	DIRSET	<<UN,DUN>,<RE,DRE>,<IF,DIF>>
	DIRSET	<<ER,DER>,<ELSE,DELSE>,<EI,DEI>>

	OPSET	<<L,5800,RX,PC22>,<LR,0800,RR,PC2>,<LI,F800,RI2,PC222>>
	OPSET	<<LIS,2400,SF,PC2>,<LCS,2500,SF,PC2>>
	OPSET	<<LH,4800,RX,PC22>,<LHI,C800,RI,PC22>>
	OPSET	<<LA,E600,RX,PC22>,<LHL,7300,RX,PC22>>
	OPSET	<<LM,D100,RX,PC22>,<LB,D300,RX,PC22>,<LBR,9300,RR,PC2>>
	OPSET	<<EXHR,3400,RR,PC2>,<EXBR,9400,RR,PC2>>
	OPSET	<<ST,5000,RX,PC22>,<STH,4000,RX,PC22>,<STM,D000,RX,PC22>>
	OPSET	<<STB,D200,RX,PC22>,<STBR,9200,RR,PC2>>
	OPSET	<<CL,5500,RX,PC22>,<CLR,0500,RR,PC2>,<CLI,F500,RI2,PC222>>
	OPSET	<<CLH,4500,RX,PC22>,<CLHI,C500,RI,PC22>,<CLB,D400,RX,PC22>>
	OPSET	<<N,5400,RX,PC22>,<NR,0400,RR,PC2>,<NI,F400,RI2,PC222>>
	OPSET	<<NH,4400,RX,PC22>,<NHI,C400,RI,PC22>>
	OPSET	<<O,5600,RX,PC22>,<OR,0600,RR,PC2>,<OI,F600,RI2,PC222>>
	OPSET	<<OH,4600,RX,PC22>,<OHI,C600,RI,PC22>>
	OPSET	<<X,5700,RX,PC22>,<XR,0700,RR,PC2>,<XI,F700,RI2,PC222>>
	OPSET	<<XH,4700,RX,PC22>,<XHI,C700,RI,PC22>>
	OPSET	<<TI,F300,RI2,PC222>,<THI,C300,RI,PC22>>
	OPSET	<<SLL,ED00,RI,PC22>,<SLLS,1100,SF,PC2>>
	OPSET	<<SRL,EC00,RI,PC22>,<SRLS,1000,SF,PC2>>
	OPSET	<<SLHL,CD00,RI,PC22>,<SLHLS,9100,SF,PC2>>
	OPSET	<<SRHL,CC00,RI,PC22>,<SRHLS,9000,SF,PC2>>
	OPSET	<<RLL,EB00,RI,PC22>,<RRL,EA00,RI,PC22>>
	OPSET	<<TBT,7400,RX,PC22>,<SBT,7500,RX,PC22>>
	OPSET	<<CBT,7700,RX,PC22>,<RBT,7600,RX,PC22>,<TS,E000,RX0,PC22>>
	OPSET	<<A,5A00,RX,PC22>,<AI,FA00,RI2,PC222>,<AIS,2600,SF,PC2>>
	OPSET	<<AR,0A00,RR,PC2>,<AH,4A00,RX,PC22>,<AHI,CA00,RI,PC22>>
	OPSET	<<AM,5100,RX,PC22>,<AHM,6100,RX,PC22>>
	OPSET	<<S,5B00,RX,PC22>,<SR,0B00,RR,PC2>,<SI,FB00,RI2,PC222>>
	OPSET	<<SIS,2700,SF,PC2>,<SH,4B00,RX,PC22>,<SHI,CB00,RI,PC22>>
	OPSET	<<C,5900,RX,PC22>,<CR,0900,RR,PC2>,<CI,F900,RI2,PC222>>
	OPSET	<<CH,4900,RX,PC22>,<CHI,C900,RI,PC22>>
	OPSET	<<M,5C00,RX,PC22>,<MR,1C00,RR,PC2>>
	OPSET	<<MH,4C00,RX,PC22>,<MHR,0C00,RR,PC2>>
	OPSET	<<D,5D00,RX,PC22>,<DR,1D00,RR,PC2>>
	OPSET	<<DH,4D00,RX,PC22>,<DHR,0D00,RR,PC2>>
	OPSET	<<SRA,EE00,RI,PC22>,<SRHA,CE00,RI,PC22>,<CHVR,1200,RR,PC2>>
	OPSET2	LHR,1200,RR,PC2
	OPSET	<<LPSW,C200,RX0,PC22>,<LPSWR,1800,LPSR,PC2>,<EPSR,9500,RR,PC2>>
	OPSET	<<SSR,9D00,RR,PC2>,<SVC,E100,RX,PC22>>
	OPSET	<<OC,DE00,RX,PC22>,<OCR,9E00,RR,PC2>>
	OPSET2	RDR,9B00,RR,PC2
	OPSET	<<WD,DA00,RX,PC22>,<WDR,9A00,RR,PC2>>
	OPSET2	WB,D600,RX,PC22
	OPSET	<<UPSW,D500,RX0,PC22>,<CIO,9900,RR,PC2>>

;		JUMP SUNDRIES
	OPSET	<<JT,4200,RX,PC22>,<JTR,0200,RR,PC2>,<JTBS,2000,BF,PC2>>
	OPSET	<<JTFS,2100,BF,PC2>,<JFFO,3100,BF,PC2>,<JFFOH,3300,BF,PC2>>
	OPSET	<<JF,4300,RX,PC22>,<JFR,0300,RR,PC2>,<JFBS,2200,BF,PC2>>
	OPSET2	JFFS,2300,BF,PC2
	OPSET	<<JL,4210,RX,PC22>,<JLR,0210,RR1,PC2>,<JLBS,2010,BF1,PC2>>
	OPSET2	JLFS,2110,BF1,PC2
	OPSET	<<JLE,4320,RX,PC22>,<JLER,0320,RR1,PC2>,<JLEBS,2220,BF1,PC2>>
	OPSET2	JLEFS,2320,BF1,PC2
	OPSET	<<JE,4330,RX,PC22>,<JER,0330,RR1,PC2>,<JEBS,2230,BF1,PC2>>
	OPSET2	JEFS,2330,BF1,PC2
	OPSET	<<JN,4230,RX,PC22>,<JNR,0230,RR1,PC2>,<JNBS,2030,BF1,PC2>>
	OPSET2	JNFS,2130,BF1,PC2
	OPSET	<<JGE,4310,RX,PC22>,<JGER,0310,RR1,PC2>,<JGEBS,2210,BF1,PC2>>
	OPSET2	JGEFS,2310,BF1,PC2
	OPSET	<<JG,4220,RX,PC22>,<JGR,0220,RR1,PC2>,<JGBS,2020,BF1,PC2>>
	OPSET2	JGFS,2120,BF1,PC2
	OPSET	<<JO,4240,RX,PC22>,<JOR,0240,RR1,PC2>,<JOBS,2040,BF1,PC2>>
	OPSET2	JOFS,2140,BF1,PC2
	OPSET	<<JNO,4340,RX,PC22>,<JNOR,0340,RR1,PC2>,<JNOBS,2240,BF1,PC2>>
	OPSET2	JNOFS,2340,BF1,PC2
	OPSET	<<JC,4280,RX,PC22>,<JCR,0280,RR1,PC2>,<JCBS,2080,BF1,PC2>>
	OPSET2	JCFS,2180,BF1,PC2
	OPSET	<<JNC,4380,RX,PC22>,<JNCR,0380,RR1,PC2>,<JNCBS,2280,BF1,PC2>>
	OPSET2	JNCFS,2380,BF1,PC2
	OPSET	<<J,4300,RX0,PC22>,<JR,0300,RR1,PC2>,<JBS,2200,BF1,PC2>>
	OPSET2	JFS,2300,BF1,PC2
	OPSET	<<JAL,4100,RX,PC22>,<JALR,0100,RR,PC2>>
	OPSET	<<NOP,4200,RX,PC22>,<NOPR,0200,RR,PC2>>
	OPSET	<<COPY,3F00,RR,PC2>,<ARAND,3E00,RR,PC2>>
	OPSET	<<SBOD,1300,RR,PC2>,<XMIT,1400,RR,PC2>>
	OPSET	<<SPM,1500,RR,PC2>,<GCHAR,1600,RR,PC2>>
	OPSET	<<SCAN,3500,RR,PC2>,<ALIGN,3600,RR,PC2>>
	OPSET	<<CKSUM,3700,RR,PC2>>
IZDOT:	1
	16_36
	0			;P COUNTER
EIZOP:	PURGE	XV,OPSET,OPSET1,OPSET2

	LIT

	BLOCK	NPG*PGSIZ+MEMBAS-.

EMEM:

	END	IZ
    F@<