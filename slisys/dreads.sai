BEGIN "READST"
DEFINE MAXIVAL=24*12-1;
REAL ARRAY NULLTM,LOST,JOBS,SIZE,ASIZE,MSIZE,SIZ0,SIZ8,SIZ16,
   SIZ24,SIZ32,SIZ40,SIZ48,SIZ56,FILE,SWAP,TRU,
   MONPG,BASE[0:MAXIVAL];
INTEGER ARRAY GRFINM[1:4]; INTEGER GRFMUL,J;
REQUIRE "<><>" DELIMITERS;
REQUIRE "(SAILIB)TYMGET.DEF" SOURCE!FILE;
REQUIRE "(SAILIB)TYMCAL.DEF" SOURCE!FILE;
DEFINE LIC!SYS = <'40000>;
DEFINE CALLI!SETLIC = <-'10>;
DEFINE RH(A)=<(A LAND '777777)>;
DEFINE LH(A)=<(A LSH -18)>;
BOOLEAN RECORDS;
DEFINE DEFINEIT(NAME,PFX,ARGS)=
<DEFINE NAME=<FORLC X!ZOT_(ARGS) DOC <X!X X!ZOT> ENDC>;
REDEFINE X!X(A,B,C,D,E,F)=<REDEFINE X!XNUM=X!XNUM+1;
	DEFINE PFX>&"!"&<A=X!XNUM;>;
REDEFINE X!XNUM=0;
NAME;
DEFINE PFX>&<!!NUM=X!XNUM;
>;

DEFINEIT (CMDMAC,CMD,<(INT,INTERVAL),(START,START),(BASE,BASE),
	(GRF,GRAPH),(ADD,ADD),(MULT,MULTIPLE),(DAYS,DAYS),
	(COL,COLOR),(OVL,OVERLAY),
	(TERM,TERMINAL),(STOP,STOP),
	(DATE,DATE),(SUM,SUMMARY),
	(HELP,HELP),(QUIT,QUIT)>);

REDEFINE X!X(A,B,C,D,E,F)=<"B" IFC CMD!>&<A NEQ CMD!!NUM THENC , ENDC>;
PRELOAD!WITH CMDMAC;
STRING ARRAY CMDNMS[1:CMD!!NUM];
INTEGER INTERVAL,BEGINT,ENDINT,I,OSC,DESDATE,SCALE;
STRING CMDSTR,DATSTR,SSTR;
BOOLEAN BOOL;
EXTERNAL STRING ACCUM;
EXTERNAL INTEGER SCNVAL;
DEFINE CRLF=<'15&'12>;
EXTERNAL INTEGER PROCEDURE SCANU(REFERENCE STRING STR);
EXTERNAL STRING PROCEDURE STDATE(INTEGER I,J);
EXTERNAL INTEGER PROCEDURE STRSRC(STRING ARRAY T;STRING S; REFERENCE
	BOOLEAN B);
EXTERNAL INTEGER PROCEDURE RDDATE(REFERENCE INTEGER I,J; VALUE
	INTEGER Q; REFERENCE STRING S);
EXTERNAL  INTEGER PROCEDURE RDTIME(REFERENCE INTEGER I,J; VALUE
	INTEGER Q; REFERENCE STRING S);
REQUIRE "(SAILIB)SAILIB" LIBRARY;
INTEGER PRNTWIDTH,TRMWIDTH,TRMHEIGHT,TRMTYP,PRNTEND;
INTEGER GNUM1,PRNTBEG,MODE,GRPCHL;
REAL BASETOT;
REAL ARRAY TOTAL,ARRMAX,TOTALDV[1:5];
INTEGER BASGRF,INTSEC,ENDDAT,INTPERDAY,BASEDATE,FINALDATE;
INTEGER NUMDYS,PIPD,MULWID,MULFST,MULEND;
EXTERNAL SIMPLE INTEGER PROCEDURE CNVDATE(INTEGER DATE,FROM,TO);
BOOLEAN ARRAY DAYBOOL[0:6];
DEFINE DECFMT=0,DAYFMT='400000;
BOOLEAN MULGRPH;
PRELOAD!WITH "WEDNSDAY","THURSDAY","FRIDAY","SATURDAY",
	"SUNDAY","MONDAY","TUESDAY";
STRING ARRAY DAYNMS[1:7];
DEFINEIT (GRFMAC,GRF,<
   (NUL,NULL,NULLTM[FROM],<NULL TIME>,<%>,FALSE),
   (LOS,LOST,LOST[FROM],<LOST TIME>,<%>,FALSE),
   (JOB,JOBS,JOBS[FROM],<NUMBER OF JOBS>,JOBS,FALSE),
   (TSZ,TSIZE,SIZE[FROM],<TOTAL SIZE>,K,FALSE),
   (ASZ,ASIZE,ASIZE[FROM],<AVERAGE SIZE>,K,FALSE),
   (MSZ,MSIZE,MSIZE[FROM],<MEDIAN SIZE>,K,FALSE),
   (SZ0,SIZE0,SIZ0[FROM],<JOBS UNDER 8K>,JOBS,FALSE),
   (SZ1,SIZE8,SIZ8[FROM],<JOBS 8K TO 15K>,JOBS,FALSE),
   (SZ2,SIZE16,SIZ16[FROM],<JOBS 16K TO 23K>,JOBS,FALSE),
   (SZ3,SIZE24,SIZ24[FROM],<JOBS 24K TO 31K>,JOBS,FALSE),
   (SZ4,SIZE32,SIZ32[FROM],<JOBS 32K TO 39K>,JOBS,FALSE),
   (SZ5,SIZE40,SIZ40[FROM],<JOBS 40K TO 47K>,JOBS,FALSE),
   (SZ6,SIZE48,SIZ48[FROM],<JOBS 48K TO 55K>,JOBS,FALSE),
   (SZ7,SIZE56,SIZ56[FROM],<JOBS OVER 55K>,JOBS,FALSE),
   (UNU,UNUSED,(NULLTM[FROM]-LOST[FROM]),<UNUSED TIME>,<%>,FALSE),
   (FIL,FILE,FILE[FROM],<FILE PAGE RATE>,<PAGES/SECOND>,TRUE),
   (SWP,SWAP,SWAP[FROM],<SWAP PAGE RATE>,<PAGES/SECOND>,TRUE),
   (MON,MONITOR,MONPG[FROM],<MONITOR PAGE RATE>,<PAGES/SECOND>,TRUE),
   (PGS,PAGES,(FILE[FROM]+SWAP[FROM]+MONPG[FROM]),
	<DISK PAGE RATE>,<PAGES/SECOND>,TRUE),
   (USD,USED,(BASE[FROM]*100-NULLTM[FROM]),<USER TIME>,<%>,FALSE),
   (BSY,BUSY,(BASE[FROM]*100-NULLTM[FROM]+LOST[FROM]),
	<BUSY TIME>,<%>,FALSE),
   (TRR,RTRU,(100*TRU[FROM]+(TBASE_TBASE+BASE[FROM]*99-NULLTM[FROM])*0),
	<TRU'S/USER TIME>,<TRU'S/SECOND>,TRUE),
   (TRU,TRU,TRU[FROM],<TRU RATE>,<TRU'S/SECOND>,TRUE)>);


RECORD!CLASS GRFCLS (REAL ARRAY ARY);
RECORD!POINTER (GRFCLS) ARRAY  GRFPTR[1:4];
EXTERNAL PROCEDURE GENARY(INTEGER ARRAY ARGS; INTEGER LOC);
DEFINEIT (SCLMAC,SCL,<
	(SC001,0.01,0.01,1),(SC002,0.02,0.01,2),
	(SC005,0.05,0.01,5),
	(SC01,0.1,0.1,1),(SC02,0.2,0.1,2),
	(SC05,0.5,0.1,5),(SC1,1.0,1,1),
	(SC2,2.0,1,2),(SC5,5.0,1,5),
	(SC10,10.0,10,1),(SC20,20.0,10,2),
	(SC50,50.0,10,5),(SC100,100.0,100,1),
	(SC200,200.0,100,2),(SC500,500.0,100,5),
	(SC1000,1000.0,1000,1),(SC2000,2000.0,1000,2),
	(SC5000,5000.0,1000,5),(SC10000,10000.0,10000,1),
	(SC20000,20000.0,10000,2),(SC50000,50000.0,10000,5)>);

REDEFINE X!X(A,B,C,D,E,F)=<B IFC SCL!>&<A NEQ SCL!!NUM THENC , ENDC>;

PRELOAD!WITH SCLMAC;
REAL ARRAY SCLEL[1:SCL!!NUM];

REDEFINE X!X(A,B,C,D,E,F)=<"B" IFC SCL!>&<A NEQ SCL!!NUM THENC , ENDC>;

PRELOAD!WITH SCLMAC;
STRING ARRAY SCLNMS[1:SCL!!NUM];

DEFINE TERMDISP(Z,Q)=<
REDEFINE X!X(A,B,C,D,E,F)=<A>&<Z(Q) IFC TRM!>&<A NEQ TRM!!NUM THENC ;
	ELSEC END ENDC>;
CASE TRMTYP-1 OF BEGIN TRMMAC>;

REDEFINE X!X(A,B,C,D,E,F)=<"C" IFC SCL!>&<A NEQ SCL!!NUM THENC
	, ENDC>;

PRELOAD!WITH SCLMAC;
STRING ARRAY SCLNMS2[1:SCL!!NUM];

REDEFINE X!X(A,B,C,D,E,F)=<D IFC SCL!>&<A NEQ SCL!!NUM
	THENC , ENDC>;

PRELOAD!WITH SCLMAC;
INTEGER ARRAY SCLIDX[1:SCL!!NUM];
PROCEDURE SCLARY(REAL ARRAY ARY;INTEGER SCALE);
BEGIN INTEGER I;
FOR I_1 STEP 1 UNTIL TRMWIDTH DO
 ARY[I]_ARY[I]/SCLEL[SCALE]
END "SCLARY";

INTEGER PROCEDURE SELSCALE(REAL SIZE);
BEGIN INTEGER I;
FOR I_1 STEP 1 UNTIL SCL!!NUM DO
   IF SIZE/SCLEL[I]<TRMHEIGHT THEN RETURN(I);
RETURN(SCL!!NUM) END "SELSCALE";

STRING PROCEDURE MULCHR(INTEGER NUMBER,CHR);
BEGIN INTEGER I; STRING ST;
ST_"";
FOR I_1 STEP 1 UNTIL NUMBER DO ST_ST&CHR;
RETURN (ST) END "MULCHR";

PRELOAD!WITH " ","/","*","'","""","\","X","@";
INTEGER ARRAY COLORTTY[0:7];
PRELOAD!WITH 6,3,2,5,7,1,4;
INTEGER ARRAY COLORD[1:7];

PRELOAD!WITH "CYAN","YELLOW","GREEN","PURPLE","WHITE","RED"
	,"BLUE";
STRING ARRAY COLORNAMES[1:7];

PRELOAD!WITH 6,3,2,5,7,1,4;
INTEGER ARRAY COLORN[1:7];
BOOLEAN ARRAY SCALED[1:4];INTEGER ARRAY SCLMUL[1:4];

REDEFINE X!X(A,B,C,D,E,F)=<"B" IFC GRF!>&<A NEQ GRF!!NUM
	THENC , ENDC>;

PRELOAD!WITH GRFMAC;
STRING ARRAY GRFNAMS[1:GRF!!NUM];

INTEGER PROCEDURE REDGRPH;
BEGIN INTEGER I;
IF SCANU(CMDSTR) NEQ 1 OR (I_STRSRC(GRFNAMS,ACCUM,BOOL))=0 THEN
	RETURN(0);
RETURN (I) END "REDGRPH";

REDEFINE X!X(A,B,C,D,E,F)=<"D" IFC GRF!>&<A NEQ GRF!!NUM
	THENC , ENDC>;
PRELOAD!WITH GRFMAC;
STRING ARRAY GRFPNM[1:GRF!!NUM];

REDEFINE X!X(A,B,C,D,E,F)=<"E" IFC GRF!>&<A NEQ GRF!!NUM
	THENC , ENDC>;
PRELOAD!WITH GRFMAC;
STRING ARRAY GRFUNTS[1:GRF!!NUM];

REDEFINE X!X(A,B,C,D,E,F)=<F IFC GRF!>&<A NEQ GRF!!NUM
	THENC , ENDC>;
PRELOAD!WITH GRFMAC;
BOOLEAN ARRAY GRFBOOL[1:GRF!!NUM];
PROCEDURE ADJTRM;
BEGIN
PRNTBEG_BEGINT;
PRNTEND_ENDINT MIN (PRNTBEG+TRMWIDTH*INTERVAL-1);
PRNTWIDTH_(PRNTEND-PRNTBEG) DIV INTERVAL+1
END "ADJTRM";

DEFINEIT (TRMMAC,TRM,<(TTY,TTY,72,54),(LPT,LPT,132,54)
	,(ISC,CHRISC,72,36),(ISCG,ISC,144,144)
	,(ZEN,ZENTEC,72,12),(ZEN2,ZENTEC2,72,36)
	,(ADM3,ADM3A,72,14),(LA12,TTY,217,54)>);

REDEFINE X!X(A,B,C,D,E,F)=<"B" IFC TRM!>&<A NEQ TRM!!NUM THENC , ENDC>;
PRELOAD!WITH TRMMAC;
STRING ARRAY TRMNMS[1:TRM!!NUM];

REDEFINE X!X(A,B,C,D,E,F)=<C IFC TRM!>&<A NEQ TRM!!NUM THENC , ENDC>;
PRELOAD!WITH TRMMAC;
INTEGER ARRAY TRMWDA[1:TRM!!NUM];

REDEFINE X!X(A,B,C,D,E,F)=<D IFC TRM!>&<A NEQ TRM!!NUM THENC , ENDC>;
PRELOAD!WITH TRMMAC;
INTEGER ARRAY TRMWTA[1:TRM!!NUM];

PROCEDURE OPNGRPH;
BEGIN INTEGER EOF;
IF GRPCHL GEQ 0 THEN RETURN;
MODE_CALL(CVSIX("GRAPH"),"DEVCHR");
MODE_IF MODE LAND ('10 LSH 18) NEQ 0 THEN '10 ELSE 0;
EOF_-1;
OPEN(GRPCHL_GETCHAN,"GRAPH",MODE,0,2,EOF,EOF,EOF);
IF EOF NEQ 0 THEN BEGIN RELEASE(GRPCHL); GRPCHL_-1; RETURN END;
ENTER(GRPCHL,"READST.DAT",EOF);
RETURN END "OPNGRPH";

PROCEDURE OUTGWD(INTEGER I);
IF GRPCHL<0 THEN IONEOU(I) ELSE WORDOUT(GRPCHL,I);

PROCEDURE OUTGRPH(STRING ST);
IF GRPCHL<0 THEN OUTSTR(ST) ELSE IF MODE=0 THEN OUT(GRPCHL,ST)
ELSE WHILE LENGTH(ST) NEQ 0 DO WORDOUT(GRPCHL,LOP(ST));

DEFINE MXPRNT=0;
REDEFINE X!X(A,B,C,D,E,F)=<REDEFINE MXPRNT=MXPRNT MAX C;>;
TRMMAC;
REAL ARRAY OUTBASE[1:MXPRNT];

PROCEDURE MAKGRF;
BEGIN INTEGER I;
PRELOAD!WITH 1,1,MXPRNT;
OWN INTEGER ARRAY SIZE[1:3];
FOR I_1 STEP 1 UNTIL 4 DO
 GENARY(SIZE,LOCATION(GRFCLS:ARY[GRFPTR[I]_NEW!RECORD(GRFCLS)]));
END "MAKGRF";
REQUIRE MAKGRF INITIALIZATION;
PROCEDURE GENARRAY(REAL ARRAY OUTARRAY; INTEGER GRAPHNUMBER;
	REFERENCE REAL TOTAL,BASETOTAL,ARRAYMAX,TOTALDV);
BEGIN
INTEGER FROM,TO,FROMINT,FROMEL,FPRNTBEG,FINTERVAL,FPRNTEND;
INTEGER IVL2,IVB,IVE,TOORG,FBASE,I;
INTEGER DATE;
REAL TBASE,GRPH;

REDEFINE X!X(A,B,C,D,E,F)=<C IFC GRF!>&<A NEQ GRF!!NUM
	THENC , ENDC>;

IF MULGRPH THEN BEGIN
  FINALDATE_CNVDATE(ENDDAT,DECFMT,DAYFMT);
  BASEDATE_CNVDATE(DESDATE,DECFMT,DAYFMT);
  NUMDYS_0;
  FOR I_BASEDATE STEP 1 UNTIL FINALDATE DO
    IF DAYBOOL[I MOD 7] THEN NUMDYS_NUMDYS+1;
  PIPD_TRMWIDTH%NUMDYS MIN INTPERDAY;
  IVL2_(MAXIVAL+1)%INTPERDAY;
  IVB_BEGINT%IVL2; IVE_ENDINT%IVL2;
  FINTERVAL_(IVE-IVB+PIPD)%PIPD;
  IVE_IVE MAX (IVB+(INTPERDAY MIN PIPD*FINTERVAL)-1);
  IF IVE GEQ INTPERDAY THEN BEGIN IVB_IVB-(IVE-INTPERDAY+1);
    IVE_INTPERDAY-1 END;
  MULWID_IVL2*FINTERVAL; MULFST_IVL2*IVB; MULEND_IVL2*(IVE+1)-1;
  PIPD_(IVE-IVB+FINTERVAL)%FINTERVAL
END ELSE BEGIN
  FINALDATE_BASEDATE_0;
  FPRNTBEG_PRNTBEG; FINTERVAL_INTERVAL;
  FPRNTEND_PRNTEND END;
TOORG_TO_0;
TOTAL_BASETOTAL_ARRAYMAX_TOTALDV_0;
FOR DATE_BASEDATE STEP 1 UNTIL FINALDATE DO
  IF NOT MULGRPH OR DAYBOOL[DATE MOD 7] THEN BEGIN
    IF MULGRPH THEN BEGIN FPRNTBEG_(FBASE_INTPERDAY*(
	DATE-BASEDATE))+IVB;
      FPRNTEND_FBASE+IVE END;
  FOR FROMINT_FPRNTBEG STEP FINTERVAL UNTIL FPRNTEND DO BEGIN
   FROMEL_(FROMINT+FINTERVAL-1)MIN FPRNTEND;
   TBASE_GRPH_0;
   FOR FROM_FROMINT STEP 1 UNTIL FROMEL DO BEGIN
	GRPH_GRPH+(CASE GRAPHNUMBER-1 OF (GRFMAC));
	TBASE_TBASE+BASE[FROM] END;
   BASETOTAL_BASETOTAL+(OUTBASE[TO_TO+1]_TBASE);
   TOTAL_TOTAL+GRPH;
   TOTALDV_TOTALDV+(OUTARRAY[TO]_(GRPH_GRPH/TBASE));
   ARRAYMAX_ARRAYMAX MAX GRPH END;
  IF MULGRPH THEN TOORG_TO_TOORG+PIPD END
END "GENARRAY";
PROCEDURE TTYBASE(INTEGER OSP,SCALE);
BEGIN
INTEGER TSTART,TEND,TINT,TSPC,SLINE,ELINE,LINE,TOSP,SF1,SF2,I,J;
IF MULGRPH THEN BEGIN
  TSTART_MULFST; TEND_MULEND; TINT_MULWID*SCALE*3 MAX 12;
  TSPC_(12%(MULWID*SCALE) MAX 3)-1; SLINE_IF PIPD<8 THEN 4 ELSE 0;
  ELINE_4 END
ELSE BEGIN
  TSTART_PRNTBEG; TEND_PRNTEND; TINT_INTERVAL*SCALE*3 MAX 12;
  TSPC_(12%(INTERVAL*SCALE) MAX 3)-1; SLINE_0; ELINE_3 END;
FOR LINE_SLINE STEP 1 UNTIL ELINE DO
 IF LINE=4 THEN BEGIN
  TOSP_OSP+(TSPC_IF PIPD<8 THEN PIPD-2 ELSE PIPD-6)%2;
  GETFORMAT(SF1,SF2); SETFORMAT(2,0);
  FOR I_BASEDATE STEP 1 UNTIL FINALDATE DO
   IF DAYBOOL[I MOD 7] THEN BEGIN
    OUTGRPH(MULCHR(TOSP," "));
    IF PIPD>8 THEN OUTGRPH(DAYNMS[I MOD 7+1][1 FOR 3]&" ");
    OUTGRPH(CVS(CNVDATE(I,DAYFMT,DECFMT) MOD 31+1));
    TOSP_TSPC END; SETFORMAT(SF1,SF2) END
  ELSE BEGIN
    TOSP_OSP;
    FOR J_BASEDATE STEP 1 UNTIL FINALDATE DO
	IF NOT MULGRPH OR DAYBOOL[J MOD 7] THEN BEGIN
     FOR I_TSTART STEP TINT UNTIL TEND DO BEGIN
      OUTGRPH(MULCHR(TOSP," ")); TOSP_TSPC;
      OUTGRPH("0"+(CASE LINE OF (I%120, I%12 MOD 10,
	I%2 MOD 6,I*5 MOD 10))) END;
     TOSP_PIPD-((TSPC+1)*((TEND-TSTART)%TINT)+1) END;
    IF MULGRPH OR LINE NEQ 3 THEN OUTGRPH(CRLF) END
END "TTYBASE";
PROCEDURE TTYSTS(STRING SCALE);
OUTGRPH(SSTR&DATSTR&" "&GRFPNM[GNUM1]&(IF LENGTH(SCALE)=0 THEN
	"" ELSE " SCALE = "&
	SCALE)&CRLF&(IF NOT GRFBOOL[GNUM1] THEN
	"TOT="&CVF(TOTALDV[1]) ELSE "ITOT="&CVF(TOTAL[1]))&
	",MAX="&CVF(ARRMAX[1])&",MEAN="&CVF(TOTAL[1]/BASETOT)&
	" "&GRFUNTS[GNUM1]
	&CRLF&CRLF);

PROCEDURE TTYGRAPH(REAL ARRAY GRF);
BEGIN INTEGER I,J,SAVSP,PRNTW2;

PRNTW2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
OUTGRPH('14); TTYSTS(SCLNMS[SCALE]);
FOR I_TRMHEIGHT STEP -1 UNTIL 1 DO BEGIN
   IF I MOD 10=0 THEN OUTGRPH(MULCHR(PRNTW2,".")&'15);
   SAVSP_0;
   FOR J_1 STEP 1 UNTIL PRNTW2 DO
	IF I<GRF[J]+0.5 THEN BEGIN OUTGRPH(MULCHR(SAVSP," ")&"X");
	   SAVSP_0 END ELSE SAVSP_SAVSP+1;
   OUTGRPH(CRLF) END;
SAVSP_0;
FOR I_1 STEP 1 UNTIL PRNTW2 DO
   IF OUTBASE[I] NEQ 0 THEN SAVSP_SAVSP+1 ELSE BEGIN
	OUTGRPH(MULCHR(SAVSP," ")&"-"); SAVSP_0 END;
OUTGRPH(CRLF); TTYBASE(0,1); OUTGRPH(CRLF);
END "TTYGRAPH";
DEFINE LPTGRAPH=<TTYGRAPH>,ADM3GRAPH=<TTYGRAPH>,LA12GRAPH=<TTYGRAPH>;

PROCEDURE ZENPOS(INTEGER X,Y);
BEGIN
OUTGWD('33); OUTGWD("C"); OUTGWD("0"+(TRMHEIGHT+4-Y) DIV 16);
OUTGWD("0"+(TRMHEIGHT+4-Y) MOD 16); OUTGWD("0"+X DIV 16);
OUTGWD("0"+X MOD 16)
END "ZENPOS";

PROCEDURE ZENDCHR(INTEGER CH);
BEGIN
OUTGWD('33); OUTGWD("F"); OUTGWD("0"+CH) END "ZENDCHR";

INTEGER ZENX,ZENY,ZENMODE;
PROCEDURE ZENOUT(INTEGER X,Y,MODE);
BEGIN INTEGER I;
IF MODE=ZENMODE THEN RETURN;
IF Y=ZENY AND 0<X-ZENX<6 THEN
   FOR I_ZENX+1 STEP 1 UNTIL X DO OUTGWD(" ")
   ELSE ZENPOS(X,Y);
ZENDCHR(MODE); ZENMODE_MODE; ZENX_X+1; ZENY_Y
END "ZENOUT";

PROCEDURE ZENGRAPH(REAL ARRAY GRF);
BEGIN INTEGER I,J,PRTWD2;
PRTWD2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
OUTGWD('33); OUTGWD("P"); OUTGWD('33); OUTGWD("K");
TTYSTS(SCLNMS2[SCALE]);
ZENX_0; ZENY_TRMHEIGHT; ZENMODE_0;
FOR I_TRMHEIGHT STEP -1 UNTIL 1 DO BEGIN
   FOR J_1 STEP 1 UNTIL PRTWD2 DO
	ZENOUT(J+5,I,IF I<GRF[J]+0.5 THEN 4 ELSE 0);
   ZENOUT(PRTWD2+6,I,0);
   END;
ZENMODE_100; COMMENT FORCE CHANGE; ZENOUT(5,0,0);
FOR I_1 STEP 1 UNTIL PRTWD2 DO
   OUTGWD(IF OUTBASE[I]=0 THEN "-" ELSE " ");
OUTGRPH(CRLF); TTYBASE(6,1);
SETFORMAT(4,3);
FOR I_5 STEP 5 UNTIL TRMHEIGHT DO BEGIN
   ZENPOS(0,I);OUTGRPH(CVS(I*SCLIDX[SCALE])) END;
END "ZENGRAPH";
DEFINE ZEN2GRAPH=<ZENGRAPH>;
BOOLEAN PROCEDURE LOADSTATUS(INTEGER DATE;INTEGER ARRAY BASE2);
BEGIN
INTEGER I,STSCHL,JFYSEC,JFYINT,IVAL,INCTIME,EOF,ETIME;
INTEGER ARRAY STSARY[0:15];
REAL FJFSEC,ISEC,ISECT,TSEC;
BOOLEAN SEEN;

COMMENT NXTINC IS CALLED TO UPDATE THE INTERVAL AND TIME
   IN INTERVAL FOR THE REMAINDER OF THIS RECORD. IT
   RETURNS TRUE AT THE END OF THE INTERVAL AND FALSE OTHERWISE.
   IT UPDATES IVAL (INTERVAL NUMBER) AND ISEC (SECONDS
   OF THIS RECORD IN THIS INTERVAL);

BOOLEAN PROCEDURE NXTINC;
BEGIN
IF INCTIME LEQ 0 OR IVAL=MAXIVAL THEN RETURN (TRUE);
IVAL_IVAL+1;
ISECT_(ISEC_(INCTIME MIN JFYINT)/FJFSEC)/TSEC;
INCTIME_INCTIME-JFYINT; RETURN(FALSE)
END "NXTINC";

COMMENT FSTINC IS CALLED TO INITIALLY EESTABLISH IVAL
   AND ISEC (ALSO TSEC TOTAL SEC IN RECORD) IT RETURNS FALSE
   IF THIS INTERVAL SHOULD NOT BE EXAMINED;

BOOLEAN PROCEDURE FSTINC;
BEGIN INTEGER IREM,STIME;
TSEC_INCTIME/FJFSEC;
IVAL_(STIME_ETIME*JFYSEC-INCTIME) DIV JFYINT;
IREM_(IVAL+1)*JFYINT-STIME;
ISECT_(ISEC_(IREM MIN INCTIME)/FJFSEC)/TSEC;
INCTIME_INCTIME-IREM;
WHILE IVAL<0 DO IF NXTINC THEN RETURN(FALSE);
SEEN_TRUE;IVAL_IVAL+BASGRF;
RETURN(TRUE) END "FSTINC";

COMMENT SETJFYSEC TAKES THE NUMBER OF TICS/SECOND AND SETS
   JFYSEC,FJFSEC, AND JFYINT;

PROCEDURE SETJFYSEC(INTEGER VALUE);
BEGIN FJFSEC_JFYSEC_VALUE; JFYINT_JFYSEC*INTSEC END "SETJFYSEC";
DEFINE INCPRC(A,B)=<A[IVAL]_A[IVAL]+((STSARY[B]*100)*ISECT)
	/FJFSEC>;
DEFINE INCISC(A,B)=<A[IVAL]_A[IVAL]+STSARY[B]*ISEC>;
DEFINE INCCNT(A,B)=<A[IVAL]_A[IVAL]+STSARY[B]*ISECT>;
STRING NAMSTR;

OPEN(STSCHL_GETCHAN,"DSK",'14,2,0,EOF,EOF,EOF);
GETFORMAT(I,EOF); SETFORMAT(-2,0);
NAMSTR_CVS((DATE DIV 31 MOD 12)+1)&CVS(DATE MOD 31+1)&
   CVS((DATE DIV (31*12)+64) MOD 100);
SETFORMAT(I,EOF);
LOOKUP (STSCHL,"(SYS)"&NAMSTR&".DAT",EOF);
IF EOF NEQ 0 THEN BEGIN CLOSE (STSCHL); RETURN (FALSE) END;
SEEN_FALSE; SETJFYSEC(60);
WHILE TRUE DO BEGIN ARRYIN(STSCHL,STSARY[0],16);
   IF EOF NEQ 0 THEN DONE;
   IF LH(STSARY[0]) NEQ DATE THEN CONTINUE;
   ETIME_RH(STSARY[0]);
   IF (INCTIME_STSARY[1]) GEQ 0 AND FSTINC THEN DO BEGIN
	BASE[IVAL]_BASE[IVAL]+ISEC;
	INCPRC(NULLTM,2);
	INCPRC(LOST,3);
	INCISC(JOBS,4);
	INCISC(SIZE,5);
	INCISC(ASIZE,6);
	INCISC(MSIZE,7);
	INCISC(SIZ0,8);
	INCISC(SIZ8,9);
	INCISC(SIZ16,10);
	INCISC(SIZ24,11);
	INCISC(SIZ32,12);
	INCISC(SIZ40,13);
	INCISC(SIZ48,14);
	INCISC(SIZ56,15)
	END UNTIL NXTINC
   ELSE CASE RH(STSARY[1]) MIN 9 OF BEGIN
	[0][1][3][4][5][6][9];
	[2][10] SETJFYSEC(STSARY[2]);
	[7] IF (INCTIME_STSARY[2])>0 AND FSTINC THEN DO BEGIN
	   BASE2[IVAL]_BASE2[IVAL]+ISEC;
	   INCCNT(FILE,3)/4.0;
	   INCCNT(SWAP,4)/4.0;
	   INCCNT(TRU,5)/10000.0;
	   INCCNT(MONPG,6)
	   END UNTIL NXTINC END
   END;
RELEASE (STSCHL);
RETURN(SEEN) END "LOADSTATUS";
DEFINE LPTADD=<TTYADD>,ADM3ADD=<TTYADD>,LA12ADD=<TTYADD>;
DEFINE ZENADD=<TTYADD>;DEFINE ZEN2ADD=<TTYADD>;
PROCEDURE MULSTS(INTEGER GRFMUL;BOOLEAN B;STRING ARRAY SCLNMS);
BEGIN INTEGER I;
OUTGWD('14); OUTGRPH(SSTR&DATSTR&CRLF); SETFORMAT(0,3);
FOR I_1 STEP 1 UNTIL GRFMUL DO BEGIN
  IF B THEN BEGIN OUTGWD("F"+'100); OUTGWD(COLORD[I]) END;
  OUTGRPH((IF B THEN NULL ELSE COLORTTY[COLORD[I]])&" "&
	GRFPNM[GRFINM[I]]&" SCALE="&SCLNMS[SCLMUL[I]]&
	(IF NOT GRFBOOL[GRFINM[I]] THEN
	",TOT="&CVF(TOTALDV[I]) ELSE ",ITOT="&CVF(TOTAL[I]))&
	",MAX="&CVF(ARRMAX[I])&",MEAN="&CVF(TOTAL[I]/BASETOT)&
	" "&GRFUNTS[GRFINM[I]]&CRLF) END;
IF GRFMUL NEQ 4 THEN OUTGRPH(CRLF)
END "MULSTS";

PROCEDURE TTYADD(INTEGER GRFMUL);
BEGIN
INTEGER I,J,SAVSP,PRNTW2;

PRNTW2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
MULSTS(GRFMUL,FALSE,SCLNMS);
FOR I_TRMHEIGHT STEP -1 UNTIL 1 DO BEGIN
  SAVSP_0;
  FOR J_1 STEP 1 UNTIL PRNTW2 DO
    IF I GEQ GRFCLS:ARY[GRFPTR[1]][J]+0.5 THEN SAVSP_SAVSP+1 ELSE BEGIN
      OUTGRPH(MULCHR(SAVSP," ")&(IF I>GRFCLS:ARY[GRFPTR[2]][J]+0.5 THEN
	COLORTTY[COLORD[1]] ELSE IF I>GRFCLS:ARY[GRFPTR[3]][J]+0.5 THEN
	COLORTTY[COLORD[2]] ELSE IF I>GRFCLS:ARY[GRFPTR[4]][J]+0.5 THEN
	COLORTTY[COLORD[3]] ELSE COLORTTY[COLORD[4]]));
      SAVSP_0 END;
  IF I MOD 10=0 THEN OUTGRPH('15&MULCHR(PRNTW2,"."));
  OUTGRPH(CRLF) END;
SAVSP_0;
FOR I_1 STEP 1 UNTIL PRNTW2 DO
   IF OUTBASE[I] NEQ 0 THEN SAVSP_SAVSP+1 ELSE BEGIN
	OUTGRPH(MULCHR(SAVSP," ")&"-"); SAVSP_0 END;
OUTGRPH(CRLF); TTYBASE(0,1); OUTGRPH(CRLF);
END "TTYADD";

PROCEDURE SCLMULTI;
BEGIN INTEGER I,J;

ARRCLR(SCALED,FALSE);
FOR I_1 STEP 1 UNTIL GRFMUL DO
 IF NOT SCALED[I] THEN BEGIN
  SCLARY(GRFCLS:ARY[GRFPTR[I]],SCLMUL[I]_SELSCALE(ARRMAX[I]));
  SCALED[I]_TRUE END;
END "SCLMULTI";
DEFINE ISCCURS=<"C"+'100>,ISCCCI=<"F"+'100>,ISCCTL=<"["+'100>,
	ISCHORZ=<"X">,ISCVERT=<"J">;

PROCEDURE ISCPOS(INTEGER X,Y);
BEGIN
OUTGWD(ISCCURS); OUTGWD(X+5); OUTGWD(42-Y)
END "ISCPOS";

PROCEDURE ISCCOL(INTEGER FORG,BACKG);
BEGIN
OUTGWD(ISCCCI); OUTGWD(BACKG LSH 3+FORG)
ENCCOL";

PROCEDURE ISCMODE(INTEGER MODE);
BEGIN
OUTGWD(ISCCTL); OUTGWD(MODE)
END "ISCMODE";

DEFINE ISCPLOT='202,ISCBAR=246,ISCPLTESC=255;
DEFINE ISCCPLT=254;

PROCEDURE ISCAXIS(INTEGER PRNTW,XSCALE,YSCALE,GRFMUL(1));
BEGIN INTEGER Y,CH,SF1,SF2,I;

ISCCOL(7,0); ISCPOS(0,TRMHEIGHT%YSCALE);
ISCMODE(ISCVERT); OUTGWD(ISCPLOT); OUTGWD(ISCCPLT);
FOR Y_TRMHEIGHT%YSCALE STEP -1 UNTIL 1 DO
  OUTGWD('17+(IF Y MOD 5=0 THEN '140 ELSE 0));
OUTGWD(ISCPLTESC); ISCMODE(ISCHORZ);
I_12%(XSCALE*(IF MULGRPH THEN MULWID ELSE INTERVAL)) MAX 3;
PRNTW_(PRNTW+XSCALE-1)%XSCALE; SF1_IF XSCALE=1 THEN '21 ELSE '20;
OUTGWD(ISCPLOT); OUTGWD(ISCCPLT); OUTGWD('107);
FOR Y_1 STEP 1 UNTIL PRNTW DO BEGIN
  CH_IF (Y-1) MOD I=0 THEN '116 ELSE '104;
  IF OUTBASE[XSCALE*Y]=0 THEN CH_CH+SF1;
  IF XSCALE=2 AND OUTBASE[XSCALE*Y-1]=0 THEN CH_CH+1;
  OUTGWD(CH) END;
OUTGWD(ISCPLTESC);
GETFORMAT(SF1,SF2);SETFORMAT(4,3);
COMMENT FOR Y_5*YSCALE STEP (5*YSCALE) UNTIL TRMHEIGHT DO BEGIN
  ISCPOS(-5,Y%YSCALE);
COMMENT   FOR I_1 STEP 1 UNTIL GRFMUL DO BEGIN
    ISCCOL(COLORD[I],0);
COMMENT     OUTGRPH(CVS(Y*SCLIDX[SCLMUL[I]])&CRLF) END END;
ISCCOL(7,0); ISCPOS(-5,-1); TTYBASE(6,XSCALE);
ISCPOS(-5,-4);
END "ISCAXIS";
PROCEDURE ISCGRAPH(REAL ARRAY GRF);
BEGIN INTEGER PRNTW2,I,J,H;

PRNTW2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
ISCCOL(7,0); ISCMODE(ISCHORZ);
OUTGWD('14); TTYSTS(SCLNMS2[SCALE]); ISCMODE(ISCVERT);
ISCCOL(0,COLORD[1]);
FOR I_1 STEP 1 UNTIL PRNTW2 DO
 IF(H_GRF[I]+0.5)>0 THEN BEGIN
   ISCPOS(I,H); FOR J_1 STEP 1 UNTIL H DO OUTGWD(" ") END;
ISCAXIS(PRNTW2,1,1);
END "ISCGRAPH";


PROCEDURE ISCADD(INTEGER GRFMUL);
BEGIN INTEGER X,Y,H1,H2,H3,H4,PRNTW2;
PRNTW2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
ISCCOL(7,0); ISCMODE(ISCHORZ);
MULSTS(GRFMUL,TRUE,SCLNMS2);
ISCMODE(ISCVERT);
FOR X_1 STEP 1 UNTIL PRNTW2 DO
  IF (H1_GRFCLS:ARY[GRFPTR[1]][X]+0.5)>0 THEN BEGIN
    H2_GRFCLS:ARY[GRFPTR[2]][X]+0.5;
    H3_GRFCLS:ARY[GRFPTR[3]][X]+0.5;
    H4_GRFCLS:ARY[GRFPTR[4]][X]+0.5;
    ISCPOS(X,H1); ISCCOL(0,COLORD[1]);
    FOR Y_H1 STEP -1 UNTIL H2+1 DO OUTGWD(" ");
    IF H2=0 THEN CONTINUE;
    ISCCOL(0,COLORD[2]);
    FOR Y_H2 STEP -1 UNTIL H3+1 DO OUTGWD(" ");
    IF H3=0 THEN CONTINUE;
    ISCCOL(0,COLORD[3]);
    FOR Y_H3 STEP -1 UNTIL H4+1 DO OUTGWD(" ");
    IF H4=0 THEN CONTINUE;
    ISCCOL(0,COLORD[4]);
    FOR Y_H4 STEP -1 UNTIL 1 DO OUTGWD(" ")
   END;
ISCAXIS(PRNTW2,1,1);
END "ISCADD";
PROCEDURE ISCOVL(INTEGER GRFMUL);
BEGIN INTEGER X,Y,I,J,PRNTW2;
INTEGER ARRAY H[1:5],C[1:4];

PRNTW2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
H[5]_0;
ISCCOL(7,0); ISCMODE(ISCHORZ);
MULSTS(GRFMUL,TRUE,SCLNMS2);
ISCMODE(ISCVERT);
FOR X_1 STEP 1 UNTIL PRNTW2 DO BEGIN
 FOR I_1 STEP 1 UNTIL GRFMUL DO
  H[I]_GRFCLS:ARY[GRFPTR[I]][X]+0.5;
 FOR I_GRFMUL+1 STEP 1 UNTIL 4 DO H[I]_0;
 IF (H[1] MAX H[2] MAX H[3] MAX H[4])=0 THEN CONTINUE;
 FOR I_1 STEP 1 UNTIL GRFMUL DO C[I]_COLORD[I];
 FOR I_1 STEP 1 UNTIL GRFMUL DO
  FOR J_I+1 STEP 1 UNTIL GRFMUL DO
   IF H[I]<H[J] THEN BEGIN
    Y_H[I]; H[I]_H[J]; H[J]_Y; Y_C[I]; C[I]_C[J]; C[J]_Y END;
 C[4]_C[4] XOR (C[3]_C[3] XOR (C[2]_C[2] XOR C[1]));
 ISCPOS(X,H[1]);
 FOR I_1 STEP 1 UNTIL GRFMUL DO BEGIN
  ISCCOL(0,C[I]);
  FOR Y_H[I] STEP -1 UNTIL H[I+1]+1 DO OUTGWD(" ");
  IF H[I+1]=0 THEN DONE END END;
ISCAXIS(PRNTW2,1,1,GRFMUL);
END "ISCOVL";
PROCEDURE ISCGGRAPH(REAL ARRAY GRF);
BEGIN INTEGER PRNTW2,X,Y,H;

PRNTW2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
ISCCOL(7,0); ISCMODE(ISCHORZ); OUTGWD('14);
TTYSTS(SCLNMS2[SCALE]); ISCCOL(COLORD[1],0);
OUTGWD(ISCPLOT); OUTGWD(ISCBAR); OUTGWD(24);
FOR X_1 STEP 1 UNTIL PRNTW2 DO
 IF (H_GRF[X]+0.5)>0 THEN BEGIN
  OUTGWD(X+11); OUTGWD(H+24) END;
OUTGWD(ISCPLTESC);
ISCAXIS(PRNTW2,2,4);
END "ISCGGRAPH";

PROCEDURE ISCGADD(INTEGER GRFMUL);;
PROCEDURE ISCGOVL(INTEGER GRFMUL);;
PROCEDURE CLRIT(INTEGER ARRAY BASE2);
BEGIN
ARRCLR(NULLTM);ARRCLR(LOST);ARRCLR(JOBS);ARRCLR(SIZE);
ARRCLR(MSIZE);ARRCLR(SIZ0);ARRCLR(SIZ8);ARRCLR(SIZ16);
ARRCLR(SIZ24);ARRCLR(SIZ32);ARRCLR(SIZ40);ARRCLR(SIZ48);
ARRCLR(SIZ56);ARRCLR(FILE);ARRCLR(SWAP);ARRCLR(TRU);
ARRCLR(ASIZE);ARRCLR(MONPG);ARRCLR(BASE);ARRCLR(BASE2)
END "CLRIT";

PROCEDURE FINARY(INTEGER ARRAY BASE2);
BEGIN INTEGER I; REAL ISEC;
FOR I_0 STEP 1 UNTIL MAXIVAL DO
   IF BASE[I] NEQ BASE2[I] NEQ 0 THEN BEGIN
	ISEC_BASE[I]/BASE2[I];
	FILE[I]_FILE[I]*ISEC;
	SWAP[I]_SWAP[I]*ISEC;
	TRU[I]_TRU[I]*ISEC;
	MONPG[I]_MONPG[I]*ISEC END
END "FINARY";

PROCEDURE TTYOVL(INTEGER GRFMUL);
BEGIN
INTEGER I,J,SAVSP,PRNTW2,CH,K;

PRNTW2_IF MULGRPH THEN PIPD*NUMDYS ELSE PRNTWIDTH;
MULSTS(GRFMUL,FALSE,SCLNMS);
FOR I_TRMHEIGHT STEP -1 UNTIL 1 DO BEGIN
  SAVSP_0;
  FOR J_1 STEP 1 UNTIL PRNTW2 DO BEGIN
   CH_0;
   FOR K_1 STEP 1 UNTIL GRFMUL DO
    IF I LEQ GRFCLS:ARY[GRFPTR[K]][J]+0.5
     THEN CH_CH XOR COLORD[K];
   IF CH=0 THEN SAVSP_SAVSP+1 ELSE BEGIN
    OUTGRPH(MULCHR(SAVSP," ")&COLORTTY[CH]); SAVSP_0 END END;
  IF I MOD 10=0 THEN OUTGRPH('15&MULCHR(PRNTW2,"."));
  OUTGRPH(CRLF) END;
SAVSP_0;
FOR I_1 STEP 1 UNTIL PRNTW2 DO
   IF OUTBASE[I] NEQ 0 THEN SAVSP_SAVSP+1 ELSE BEGIN
	OUTGRPH(MULCHR(SAVSP," ")&"-"); SAVSP_0 END;
OUTGRPH(CRLF); TTYBASE(0,1); OUTGRPH(CRLF);
END "TTYOVL";

DEFINE LPTOVL=<TTYOVL>,ZENOVL=<TTYOVL>,ZEN2OVL=<TTYOVL>;
DEFINE ADM3OVL=<TTYOVL>,LA12OVL=<TTYOVL>;
BOOLEAN PROCEDURE READSTATUS (INTEGER DATE);
BEGIN BOOLEAN B; INTEGER I;
INTEGER ARRAY BASE2[0:MAXIVAL];
CLRIT(BASE2);
INTSEC_300; BASGRF_0;
B_LOADSTATUS(DATE,BASE2);
FINARY(BASE2);
MULGRPH_FALSE;
RETURN(B) END "READSTATUS";

BOOLEAN PROCEDURE GETMUL(INTEGER FROM,TODAT);
BEGIN INTEGER I; BOOLEAN B;
INTEGER ARRAY BASE2[0:MAXIVAL];
CLRIT(BASE2);
FROM_CNVDATE(FROM,DECFMT,DAYFMT); TODAT_CNVDATE(TODAT,DECFMT,DAYFMT);
B_FALSE; IF 36<(NUMDYS_TODAT-FROM+1) LEQ 0 THEN RETURN(FALSE);
INTPERDAY_(MAXIVAL+1)%NUMDYS;
FOR I_288,144,96,72,48,24,12,8 DO
  IF INTPERDAY GEQ I THEN BEGIN INTPERDAY_I; DONE END;
INTSEC_(24*60*60)%INTPERDAY;
BASGRF_0;
FOR I_FROM STEP 1 UNTIL TODAT DO BEGIN
    B_B LOR LOADSTATUS(CNVDATE(I,DAYFMT,DECFMT),BASE2);
    BASGRF_BASGRF+INTPERDAY END;
FINARY(BASE2);
MULGRPH_TRUE;
RETURN(B) END "GETMUL";
RECORDS_FALSE; INTERVAL_4; BEGINT_0; ENDINT_MAXIVAL; GRPCHL_-1;
TRMWIDTH_TRMWDA[TRMTYP_TRM!TTY];
TRMHEIGHT_TRMWTA[TRM!TTY];
ADJTRM; OPNGRPH; ARRCLR(DAYBOOL,TRUE);
TTYUP(TRUE);
IF LIC!SYS LAND (I _ GETTAB(-1,JBTLIC)) = 0  THEN
	CALLI(RH(I) LSH 18 + RH(I),CALLI!SETLIC);
SSTR _ (SSTR _ CVSTR(CALLI('11,'41)) [1 FOR 4]) & "  ";

WHILE TRUE DO BEGIN "MAINLOOP"
OUTSTR(CRLF&"*");
IF GRPCHL GEQ 0 AND MODE NEQ 0 THEN CLOSE(GRPCHL);
CASE SCANU(CMDSTR_INCHWL) OF BEGIN
[2][3] OUTSTR ("ILLEGAL COMMAND");
[1] CASE STRSRC(CMDNMS,ACCUM,BOOL) OF BEGIN "CMDS"
   [0] OUTSTR ("ILLEGAL COMMAND");
   [CMD!INT] IF SCANU(CMDSTR)=2 AND 0<SCNVAL<100 THEN
	BEGIN INTERVAL_SCNVAL; ADJTRM END
	   ELSE OUTSTR ("ILLEGAL INTERVAL");
   [CMD!STOP] IF RDTIME(I,OSC,SCANU(CMDSTR),CMDSTR) THEN
	BEGIN ENDINT_((I-1) DIV 5) MAX BEGINT;
	  ADJTRM END
	   ELSE OUTSTR("BAD TIME");
   [CMD!START][CMD!BASE] IF RDTIME(I,OSC,SCANU(CMDSTR),
	CMDSTR) THEN BEGIN BEGINT_(I DIV 5) MIN ENDINT;
		ADJTRM END ELSE
	OUTSTR ("BAD TIME");
   [CMD!DATE] BEGIN BOOL_TRUE; RECORDS_FALSE;
	IF (OSC_SCANU(CMDSTR))=0 THEN DESDATE_CALL(0,"DATE") ELSE
	   BOOL_RDDATE(DESDATE,OSC,OSC,CMDSTR);
	IF NOT BOOL THEN OUTSTR("BAD DATE") ELSE BEGIN
	   RECORDS_READSTATUS(DESDATE);
	   DATSTR_STDATE(DESDATE,'200+3);
	   IF NOT RECORDS THEN OUTSTR("NO DATA FOR DATE") END
	END;
   [CMD!SUM] IF NOT RECORDS THEN OUTSTR("NO DATE SELECTED") ELSE
	IF (GNUM1_REDGRPH)=0 THEN OUTSTR("ILLEGAL GRAPH")
	ELSE BEGIN
	SETFORMAT(0,3);
	DO BEGIN
	   GENARRAY(GRFCLS:ARY[GRFPTR[1]],GNUM1,TOTAL[1],BASETOT,ARRMAX[1],TOTALDV[1]);
	   TTYSTS("");
	   END UNTIL (GNUM1_REDGRPH)=0 END;
   [CMD!GRF] IF NOT RECORDS THEN OUTSTR("NO DATE SELECTED") ELSE
	IF (GNUM1_REDGRPH)=0 THEN OUTSTR ("ILLEGAL GRAPH")
	ELSE BEGIN
	SETFORMAT(0,3);
	DO BEGIN
	   GENARRAY(GRFCLS:ARY[GRFPTR[1]],GNUM1,TOTAL[1],BASETOT,ARRMAX[1],TOTALDV[1]);
	   SCLARY(GRFCLS:ARY[GRFPTR[1]],
		SCLMUL[1]_SCALE_SELSCALE(ARRMAX[1]));
	   TERMDISP(GRAPH,GRFCLS:ARY[GRFPTR[1]]) END
	UNTIL (GNUM1_REDGRPH)=0 END;
   [CMD!ADD] IF NOT RECORDS THEN OUTSTR("NO DATE SELECTED") ELSE
	IF (GRFINM[1]_REDGRPH)>0 THEN BEGIN
	FOR I_2 STEP 1 UNTIL 4 DO
	   IF (GRFINM[I]_J_REDGRPH) LEQ 0 THEN DONE;
	IF J GEQ 0 THEN BEGIN
	GRFMUL_I-1;
	FOR I_1 STEP 1 UNTIL GRFMUL DO
	   GENARRAY(GRFCLS:ARY[GRFPTR[I]],GRFINM[I],TOTAL[I],BASETOT,ARRMAX[I],TOTALDV[I]);
	FOR I_GRFMUL STEP 1 UNTIL 3 DO CASE I OF BEGIN
	   ARRCLR(GRFCLS:ARY[GRFPTR[1]]);ARRCLR(GRFCLS:ARY[GRFPTR[2]]);ARRCLR(GRFCLS:ARY[GRFPTR[3]]);
	   ARRCLR(GRFCLS:ARY[GRFPTR[4]]) END;
	ARRMAX[5]_0;
	FOR I_1 STEP 1 UNTIL TRMWIDTH DO
	   ARRMAX[5]_ARRMAX[5] MAX (GRFCLS:ARY[GRFPTR[1]][I]_GRFCLS:ARY[GRFPTR[1]][I]+(GRFCLS:ARY[GRFPTR[2]][I]_
		GRFCLS:ARY[GRFPTR[2]][I]+(GRFCLS:ARY[GRFPTR[3]][I]_GRFCLS:ARY[GRFPTR[3]][I]+GRFCLS:ARY[GRFPTR[4]][I])));
	SCALE_SELSCALE(ARRMAX[5]);
	FOR I_1 STEP 1 UNTIL GRFMUL DO
	  SCLARY(GRFCLS:ARY[GRFPTR[I]],SCLMUL[I]_SCALE);
	TERMDISP(ADD,GRFMUL)
	END END;
   [CMD!MULT]
     BEGIN RECORDS_FALSE;
     BOOL_RDDATE(DESDATE,OSC,SCANU(CMDSTR),CMDSTR) AND
	RDDATE(ENDDAT,OSC,OSC,CMDSTR);
     IF NOT BOOL THEN OUTSTR("BAD DATES") ELSE BEGIN
	RECORDS_GETMUL(DESDATE,ENDDAT);
	DATSTR_STDATE(DESDATE,'200+3)&" TO "&STDATE(ENDDAT,'200+3);
	IF NOT RECORDS THEN OUTSTR("NO DATA FOR INTERVAL") END
     END;
   [CMD!DAYS] BEGIN ARRCLR(DAYBOOL,BOOL_FALSE);
     WHILE SCANU(CMDSTR)=1 AND
      (I_STRSRC(DAYNMS,ACCUM,BOOL)) NEQ 0 DO
	BOOL_DAYBOOL[I-1]_TRUE;
     IF NOT BOOL THEN ARRCLR(DAYBOOL,TRUE);
     IF LENGTH(CMDSTR) NEQ 0 THEN OUTSTR ("BAD DAY NAME") END;
   [CMD!COL] BEGIN ARRTRAN(COLORD,COLORN); OSC_1;
	FOR I_1 STEP 1 UNTIL 7 DO
	 IF SCANU(CMDSTR)=1 AND (OSC_STRSRC(COLORNAMES,ACCUM,
		BOOL)) NEQ 0 THEN COLORD[I]_COLORN[OSC] ELSE
	  DONE;
	IF LENGTH(CMDSTR) NEQ 0 OR OSC LEQ 0 THEN
	  OUTSTR ("BAD COLOR NAME") END;
   [CMD!OVL] IF NOT RECORDS THEN OUTSTR("NO DATE SELECTED") ELSE
	IF (GRFINM[1]_REDGRPH)>0 THEN BEGIN
	FOR I_2 STEP 1 UNTIL 4 DO
	   IF (GRFINM[I]_J_REDGRPH) LEQ 0 THEN DONE;
	IF J GEQ 0 THEN BEGIN
	GRFMUL_I-1;
	FOR I_1 STEP 1 UNTIL GRFMUL DO
	   GENARRAY(GRFCLS:ARY[GRFPTR[I]],GRFINM[I],TOTAL[I],BASETOT,ARRMAX[I],TOTALDV[I]);
	FOR I_GRFMUL STEP 1 UNTIL 3 DO CASE I OF BEGIN
	   ARRCLR(GRFCLS:ARY[GRFPTR[1]]);ARRCLR(GRFCLS:ARY[GRFPTR[2]]);ARRCLR(GRFCLS:ARY[GRFPTR[3]]);
	   ARRCLR(GRFCLS:ARY[GRFPTR[4]]) END;
	SCLMULTI; TERMDISP(OVL,GRFMUL) END END;
   [CMD!TERM] IF SCANU(CMDSTR) NEQ 1 OR (I_STRSRC(TRMNMS,ACCUM
	,BOOL))=0 THEN OUTSTR("BAD TERMINAL TYPE")
	ELSE BEGIN
	   TRMWIDTH_TRMWDA[TRMTYP_I];
	   TRMHEIGHT_TRMWTA[I]; ADJTRM END;
   [CMD!QUIT] BEGIN "QUIT"
	IF GRPCHL GEQ 0 THEN RELEASE(GRPCHL);CALL(0,"EXIT");END "QUIT";
   [CMD!HELP] CASE SCANU(CMDSTR) OF BEGIN "HELPCMDS"
    [0] [2] [3]  OUTSTR("
HELP		If followed by command name, gives help for the command.
DATE		Select date for graph
MULTIPLE	Print graph for specified range of dates
DAYS		Print graph for specified days of the week
INTERVAL	Set interval for graph
START		Set start time for graph
BASE		Same as start
STOP		Set ending time for graph
GRAPH		Print specified graphs
ADD		Print added graphs
OVERLAY		Print overlaid graphs
SUMMARY		Just print summary information
COLOR		Select color for graphs
QUIT		Exit back to monitor
");
    [1] CASE STRSRC(CMDNMS,ACCUM,BOOL) OF BEGIN "HELP"
	[CMD!HELP] OUTSTR("
HELP followed by a command name prints out detailed information
about the named command.
");
	[CMD!DAYS] OUTSTR("
DAYS takes a list of days of the week as an argument.
If a range of dates has been specified with MULTIPLE,
DAYS will cause subsequent graphing commands to print
only that data which was collected on the days of the
week specified.
");
	[CMD!QUIT] OUTSTR("
QUIT closes the graph output file if any and returns back
to monitor level.
");
	[CMD!COL] OUTSTR("
COLOR selects the colors to be used on ISC terminals.
");
    	[CMD!GRF]
		 REDEFINE X!X(A,B,C,D,E,F) = <"B" IFC GRF!>&<A NEQ GRF!!NUM THENC & "," & ELSEC & CRLF ENDC>;
           OUTSTR("
GRAPH accepts a list of performance items and prints their graphs.
Items are:
" & GRFMAC & "
Graphs may be written onto a device other than the terminal.
To do this, assign the device the logical name 'GRAPH'. The
output will appear in the file 'READST.DAT'.");
	[CMD!DATE] OUTSTR("
DATE selects a single date to print graphs for. Dates are of
the form MM-DD-YY, DD-Month-YY, or Month DD,YY.
If the argument is blank, today's date will be used.
");
	[CMD!MULT] OUTSTR("
MULTIPLE accepts a start date followed by and end date which
are taken as a range for which to print subsequent graphs.
");
	[CMD!INT] OUTSTR("
INTERVAL n sets the time interval for the graph to n*5 minutes.
");
	[CMD!TERM] BEGIN "TERMINAL!HELP"
	DEFINE X!X(A,B,C,D,E,F) = <"B" IFC TRM!>&<A NEQ TRM!!NUM
	   THENC & "," & ELSEC & CRLF ENDC>;
	OUTSTR("TERMINAL selects terminal type. Current terminal types are:" & CRLF & TRMMAC) END "TERMINAL!HELP";
	[CMD!START] OUTSTR("
START selects the start time for subsequent graphs.
The argument is of the form HHMM or HH:MM.
");
	[CMD!BASE] OUTSTR("
BASE selects the start time for subsequent graphs.
The argument is of the form HHMM or HH:MM.
");
	[CMD!STOP] OUTSTR("
STOP selects the stop time for subsequent graphs.
The argument is of the form HHMM or HH:MM.
");
	[CMD!ADD] OUTSTR("
ADD takes up to four graph names (see HELP GRAPH) as
arguments. It concatenates the four graphs specified vertically,
with the last graph specified starting at the origin,
forming a single graph. An example of how this is used is
'ADD LOST UNUSED USED'. The top of the graph will be even,
since these quantities add up to 100%.
");
	[CMD!OVL] OUTSTR("
OVERLAY overlays up to four graph items. This is useful
for comparing the magnitudes of related values.
");
	[CMD!SUM] OUTSTR("
SUMMARY prints the summary lines which normally appear
at the top of graphs.
");
         [0] OUTSTR("
There is no help for " & ACCUM & CRLF)
       END "HELP"
    END "HELPCMDS"
   END "CMDS"
END
END "MAINLOOP"
END "READST"
    mUIkG