Entry;
begin "DED - Command module"
  require "DED.DEF" source!file;
!! title PEAK Command Module ;

! *************************************************************************
*                                                                         *
*      Herein contained are all of the command key bindings, and the      *
*      main command loop where the commands are dispatched.  Certain      *
*       simple commands, such as the Meta prefix handlers, argument       *
*             collectors, and error handlers also live here.              *
*                                                                         *
**************************************************************************;


!                      From the SAIL runtime system
;

  external integer
    !skip!;                             ! Indicates an error occurred in
                                        ! some quadrant of the Runtimes.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         From the Utility Module
;

  external simple integer procedure
    DecrBP (integer BP);                ! Return a decremented byte
                                        ! pointer. 
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
!
!                         From the Buffer Module
;

  ifcr TymcomX thenc
    external simple procedure
      B!Kill;                           ! Kill the current Buffer
                                        ;
    external simple procedure
      B!CheckPoint;                     ! Force a Checkpoint to take
                                        ! place. 
                                        ;
    external simple procedure
      B!Make (string Filename, Alias);

    external simple boolean procedure
      B!CKFile (integer W1, W2);
  endc

  ifcr Tops20 thenc
    external simple procedure
      B!DelCurrentBuffer;               ! Delete the current Buffer.
                                        ;
    external simple procedure
      B!CheckPoint (boolean Close);     ! Force a Checkpoint to take
                                        ! place. 
                                        ;

    external simple boolean procedure
      B!CreateChkPntFile
          (string TName, TAlias(null); 
          integer TPage(0), TLine(0),
          TChar(0));                    ! Create a new checkpoint file
                                        ! and fill it with the named
                                        ! Text file.
                                        ;
    external simple boolean procedure
      B!FileInsert (string FName);      ! Insert a Text file after the
                                        ! Point in the Buffer.
                                        ;
    external simple procedure
      B!RestoreFromEDT;                 ! Restore everything from the EDT
                                        ! area to accessible data
                                        ! structures. 
                                        ;
    external simple procedure
      B!CKFile (string Name);
  endc

  external simple boolean procedure
    B!AnyM;

  external simple integer procedure
    B!ModCnt;

  external simple boolean procedure
    B!Fini (boolean WriteFiles);

  external simple boolean procedure
    B!FreeP;

  external simple procedure
    B!BufStat;

  external simple procedure
    B!Restore;

  external simple procedure
    B!Step (integer Direction);

  external simple procedure
    B!Insert (integer Char);

  external simple integer procedure
    B!GetC;

  external simple procedure
    B!Delete (integer Number);

  external simple procedure
    B!Move (integer Distance);

  external simple integer procedure
    B!GetP;

  external simple procedure
    B!SetP (integer Position);

  external simple integer procedure
    B!AllocateMark;

  external simple procedure
    B!DeAllocateMark (integer M);

  external simple integer procedure
    B!GetM (integer MarkNum);

  external simple procedure
    B!SetM (integer MarkNum, Position);

  external simple integer procedure
    B!Cnt;


  external boolean
    B!BegP,
    B!EndP,
    B!ModP;

  external integer
    B!Lock,
    B!CkPtSer,
    B!Prot;

  external string
    B!Mode,
    B!File;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                        From the Redisplay Module
;

  external integer
    T!Width;                            ! How wide is the terminal?
                                        ;
  external procedure
    R!Init;

  ifcr Tops20 thenc
    external simple procedure
      T!FlshIBuf;                       ! Flush the last input character
                                        ! from the terminal input buffer.
                                        ;
  endc

  external integer procedure
    T!GetC;                             ! Get an image character.
                                        ;

  external simple procedure
    T!GetTermType (boolean X);          ! Establish the terminal type for
                                        ! the Redisplay.
                                        ;
  external procedure
    T!OutC (integer C);                 ! Print an image character.
                                        ;

  external procedure
    T!Bell;

  external boolean procedure
    T!ChrP;                             ! True iff character available.
                                        ;

  external procedure
    T!Fini;                             ! Reset the terminal.
                                        ;

  external procedure
    T!RSet;                             ! Re-init the terminal.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         From the Window Module
;

  external integer
    W!Buf0,                             ! Identity of Buffer for window 0.
                                        ;
    W!Buf1;                             ! Identity of Buffer for window 1.
                                        ;

  external procedure
    W!Disp (boolean PuntFlag);

  external integer procedure
    W!Size;

  external integer procedure
    W!GetS;

  external procedure
    W!SetS (integer Position);

  external procedure
    W!Frame;

  external procedure
    W!Msg (string S);                   ! Put S in the message line.
                                        ;

  external procedure
    W!Msg2 (string S);

  external procedure
    W!NewS;

  external procedure
    W!FixS;


  external boolean
    W!MsgF;                             ! Show cursor on msg line.
                                        ;

  external procedure
    W!BClr;

  external procedure
    W!BMsg (integer Line; string Text);

  external procedure
    W!BAdd (string Text);

  external procedure
    W!BSet (boolean OnFlag);

  external integer
    W!BoxP;

  external integer
    W!White;                            ! On to "highlite" whitespace.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                          From the File Module
;

  external boolean
    F!RPGFlag;


  ifcr TymcomX thenc
    external boolean procedure
      F!Decompose
        (string InStr;
        reference string UserName, File, Ext, PPN, Alias, Switches); 

    external boolean procedure
      F!Read (string FName);

    external boolean procedure
      F!Load (string FName; integer P, L, C);

    external boolean procedure
      F!Lookup (string FName);

    external integer procedure
      F!GetC;

    external procedure
      F!Release;
  endc

  ifcr Tops20 thenc
    external boolean procedure
      F!Decompose
        (string InStr;
        reference string Device, UserName, File, Ext, Gen, Alias,
        Switches); 
  endc

  external string procedure
    F!Parse (string FName);

  external integer procedure
    F!Scan (string FName);

  external boolean procedure
    F!Writ (string FName);

  external procedure
    F!Exit;


! ------------------------------------------------------------------------;
!! title Internal Storage ;
! ----------  Internal data structures and state information  ----------- ;


  internal integer
    C!Debug,                            ! This guy is on if we're
                                        ! debugging.
                                        ;

    C!CheckPointInterval;               ! Number of seconds of inactivity
                                        ! before a checkpoint is done.
                                        ;

  own safe internal integer array
    C!Dispatch [0:'577];

    ! The dispatch table has an entry for each of the 200(8) ASCII
    ! characters, plus entries for "Meta" characters, which are formed by
    ! adding 200(8) or 400(8), depending on the prefix character, to the
    ! command character. 
    ;


  integer
    C!MetaPrefix,                       ! The current Meta prefix.
                                        ;
    C!XMetaPrefix;                      ! The Current XMeta prefix.
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                     For keeping track of commands.
;

  internal integer
    C!Cmd,                              ! The current command.
                                        ;
    C!Addr;                             ! The address of the routine
                                        ! dispatched to by the current
                                        ! command.
                                        ;

    ! Note: These two items are declared internal so that they'll appear
    ! in the link map.
    ;

  own integer
    C!LastCmd,                          ! The previous comand.
                                        ;
    C!LastAddr;                         ! The address of the routine
                                        ! dispatched to by the previous
                                        ! command.
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                 Storage relating to command processing
;

  own integer
    C!DispatchCount;                    ! Count of commands dispatched.
                                        ;

  internal boolean
    C!Quit;                             ! Set this to end command loop.
                                        ;

  own integer
    CF!Chan;                            ! The Channel through which a
                                        ! command file is input.  (Note
                                        ! that with one channel, we are
                                        ! not capable of recursion.)
                                        ;
  own boolean
    C!JournalFile;                      ! True iff we are showing command
                                        ! file comands.
                                        ;
  own boolean
    C!CmdFileP;                         ! True iff comands from file.
                                        ;
  own string
    C!String;                           ! String being read by command.
                                        ;

  internal integer
    C!ArgV;                             ! The value of the argument.
                                        ;
  own integer
    C!ArgMultiplier;                    ! The value of a defaulted
                                        ! argument.
                                        ;
  own boolean
    C!JournalCommand;                   ! True iff we are showing all
                                        ! commands.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                            The Macro System
;

! Several different flavors of macros are used here.  A macro may be
! defined 'by example' by keeping track of things being typed, or defined
! explicitely by special functions.  Once a macro is defined, it may be
! executed by the 'invoke last macro defined' command, or bound to a key.
;


  define
    MAXMACROLENGTH = 200;               ! Maximum size in characters.
                                        ;
  define
    MAXMACRODEPTH = 12;			! Maximum calling depth.
					;
  define
    C!MacroPointer = 1;                 ! Left-half Flag for Macro Addr.
					;
  record!class
    Macro ( integer Id;			! Macro Identifier ;
            integer Key;		! Previous Key Binding ;
	    string  Body;		! Macro Body  ;
            string  Name;		! Macro Name  ;
            record!pointer (Macro) Last;! Obvious link pointers ;
            record!pointer (Macro) Next );

  own record!pointer (Macro)
    C!MacroStack,			! Head of macro stack. ;
    C!MacroNames;			! Head of "named" macros.
					;
  own integer
    C!MacroDepth;			! Current macro call depth.
					;
  own boolean
    C!DefiningMacro;                    ! True iff we want to 'remember'
                                        ! keystrokes.
                                        ;
  own boolean
    C!JournalMacro;                     ! True iff we are showing macro
                                        ! commands.
                                        ;
  own string
    C!LastMacro,                        ! The last keyboard macro defined.
                                        ;
    C!Macro;                            ! The current macro string.
                                        ;
  own boolean
    C!MAbort;                           ! Signal for the macro system to
                                        ! abort the current macro.  This
                                        ! gets set by various commands.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                             The Kill Buffer
;

! The Kill Buffer saves killed or copied text temporarily.
;

  define
    KILLBUFSIZE = 1000;                 ! The Kill Buffer size in words.
                                        ;
  define
    KILLBUFMAX = KILLBUFSIZE * CharactersPerWord;
                                        ! The Kill Buffer size in
                                        ! characters.
                                        ;

  own integer array
    C!KillBuf [0:KILLBUFSIZE - 1];      ! The Kill Buffer itself.
                                        ;
  own integer
    C!KillBP,                           ! A byte pointer into the Kill
                                        ! Buffer.
                                        ;
    C!KillCnt;                          ! A count of the number of
                                        ! characters in the Kill Buffer.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                            The Binding Stack
;

! The Binding Stack is used for the temporary storage of key bindings.
;

   define
     BINDINGSTACKSIZE = 50;             ! The maximum number of bindings
                                        ! we may save simultaneously.
                                        ;

  own integer
    C!BindingStackPnt;                  ! ??? A pointer into the Binding
                                        ! Stack.
                                        ;
  own safe integer array
    C!BindingStack [1:BINDINGSTACKSIZE];
                                        ! The Binding Stack itself.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                     Searching and Replacing strings
;

  own string
    C!Search,                           ! The current Single-Search
                                        ! string.
                                        ;
    C!SearchM,                          ! The current Multiple-Search
                                        ! string. 
                                        ;
    C!QOldStr,                          ! The current Query-Replace
                                        ! Search String.
                                        ;
    C!QNewStr;                          ! The current Query-Replace
                                        ! Replacement String.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                              Aux Circuits
;

  internal integer
    C!CreEscChr,                        ! CreAux command escape character,
                                        ! two of which will allow you to
                                        ! return to editing the buffer.
                                        ;
    C!AuxPort;                          ! The identity of the port on which
                                        ! the aux circuit exists. (Must be
                                        ! initially -1.)
                                        ;
  internal string
    C!AuxStr;                           ! The login string used by CreAux.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                           Miscellaneous Stuff
;

  own integer
    G!AppendKillP,                      ! True to force next kill to append
                                        ! to kill buffer.
                                        ;
    C!RightMargin,                      ! Location of the Right Margin.
                                        ;
    C!LeftMargin,                  ! Location of the Left Margin.
                                        ;
    C!StickyColumn;                     ! The column we're "stuck" to.
                                        ;
  internal integer
    C!TABWidth;                         ! The width of a tab.
                                        ;
  own integer
    C!IndentUnitWidth;                  ! The width of an indent unit.
                                        ;
  internal boolean
    C!SPMRegion;                        ! Swap Point and Mark on
                                        ! Region-oriented commands
                                        ! (including Insert File)
                                        ;
  internal boolean
    G!TextMode;                         ! True iff we are in text mode.
                                        ;
  own boolean
    C!UseTABS,                          ! Use tabs (as opposed to spaces)
                                        ! for indentation.
                                        ;
    C!VFMode;                           ! Vue Fill Mode, which if true
                                        ! indicates that Fill Paragraph
                                        ! and Justify Paragraph use the
                                        ! argument as a right-margin
                                        ! override value, and leave the
                                        ! point at the end of the current
                                        ! paragraph (normally, the
                                        ! argument is a repeat count, and
                                        ! the point is located after the
                                        ! current paragraph).
                                        ;

  ifcr Tops20 thenc
    internal integer
      G!ShowGens;                       ! Show File generation counts.
                                        ;
  endc

  internal integer
    G!Test,                             ! ??? Used for testing
                                        ;
    G!ESCF,                             ! Print ESC as "$".
                                        ;
    G!OverWriteP,                       ! Overwrite on character insert.
                                        ;
    G!WrapP,                            ! Perform line wrap on display.
                                        ;
    G!CaseMatch,                        ! Exact case match on searches.
                                        ;
    G!FFBreak;                          ! Break display page on FF.
                                        ;
  internal boolean
    G!RNulls,                           ! True if nulls are to be removed
                                        ! automatically when the Text
                                        ! file is read.  Only cleared by
                                        ! a command line switch.
                                        ;
    G!CRCtl;                            ! A lonely CR is displayed as
                                        ! "^m".  (The alternative is "&"
                                        ! in column 80);
                                        ;
  internal integer
    G!MagicMode;                        ! ??? For internal hackery.
                                        ;
  internal string
    C!UserName;                         ! Name we're logged in to.
                                        ;

  own boolean
    InsertLiterally;                    ! True iff the character being
                                        ! inserted is to be inserted
                                        ! literally (ie, not interpreted
                                        ! by the insert routine).
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

! The following macros help write readable commands ;

define
  PuntCommand =
  {
    begin
      C!ArgV _ 0;
      return;
    end
  };


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                                  C!Tab
;

! The array C!Tab is useful in a variety of ways.  First, it defines most
!  all of the uses for each character, such as whether it is considered
!  alphabetic, whitespace, legal in an identifier, etc.  Also, the table
!  contains the upshifted value of characters for purposes of searching.
;

preload!with
  '0,                                   '1,
  '2,                                   '3,
  '4,                                   '5,
  '6,                                   IsAbort + '7,

  '10,                                  IsWhite + TAB,
  IsEOL + '12,                          '13,
  IsEOL + FF,                           IsEOL + CR,
  '16,                                  '17,

  '20,                                  '21,
  '22,                                  '23,
  '24,                                  '25,
  '26,                                  '27,

  '30,                                  '31,
  '32,                                  '33,
  '34,                                  '35,
  '36,                                  '37,

  IsWhite + IsYes + " ",                IsDelim + "!",
  IsDelim + '42,                        IsDelim + "#",
  IsDelim + "$",                        IsDelim + "%",
  IsDelim + "&",                        IsDelim + "'",

  IsDelim + "(",                        IsDelim + ")",
  IsDelim + "*",                        IsDelim + "+",
  IsDelim + ",",                        IsDelim + "-",
  IsDelim+IsNum+IsYes+IsAbort+".",      IsDelim + "/",

  IsNum + IsToken + "0",                IsNum + IsToken + "1",
  IsNum + IsToken + "2",                IsNum + IsToken + "3",
  IsNum + IsToken + "4",                IsNum + IsToken + "5",
  IsNum + IsToken + "6",                IsNum + IsToken + "7",

  IsNum + IsToken +  "8",               IsNum + IsToken + "9",
  IsDelim + ":",                        IsDelim + ";",
  IsDelim + "<",                        IsDelim + "=",
  IsDelim + ">",                        IsDelim + "?",

  IsDelim + "@",                        IsAlpha + IsToken + "A",
  IsAlpha + IsToken + "B",              IsAlpha + IsToken + "C",
  IsAlpha + IsToken + "D",              IsAlpha + IsToken + "E",
  IsAlpha + IsToken + "F",              IsAlpha + IsToken + "G",

  IsAlpha + IsToken + "H",              IsAlpha + IsToken + "I",
  IsAlpha + IsToken + "J",              IsAlpha + IsToken + "K",
  IsAlpha + IsToken + "L",              IsAlpha + IsToken + "M",
  IsAlpha + IsToken + IsNo + "N",       IsAlpha + IsToken + "O",

  IsAlpha + IsToken + "P",              IsAlpha + IsToken + "Q",
  IsAlpha + IsToken + "R",              IsAlpha + IsToken + "S",
  IsAlpha + IsToken + "T",              IsAlpha + IsToken + "U",
  IsAlpha + IsToken + "V",              IsAlpha + IsToken + "W",

  IsAlpha + IsToken + "X",              IsAlpha + IsToken + IsYes + "Y",
  IsAlpha + IsToken + "Z",              IsDelim + "[",
  IsDelim + "\",                        IsDelim + "]",
  IsDelim + "^",                        IsDelim + "_",

  IsDelim + "`",                        IsAlpha + IsToken + "A",
  IsAlpha + IsToken + "B",              IsAlpha + IsToken + "C",
  IsAlpha + IsToken + "D",              IsAlpha + IsToken + "E",
  IsAlpha + IsToken + "F",              IsAlpha + IsToken + "G",

  IsAlpha + IsToken + "H",              IsAlpha + IsToken + "I",
  IsAlpha + IsToken + "J",              IsAlpha + IsToken + "K",
  IsAlpha + IsToken + "L",              IsAlpha + IsToken + "M",
  IsAlpha + IsToken + IsNo + "N",       IsAlpha + IsToken + "O",

  IsAlpha + IsToken + "P",              IsAlpha + IsToken + "Q",
  IsAlpha + IsToken + "R",              IsAlpha + IsToken + "S",
  IsAlpha + IsToken + "T",              IsAlpha + IsToken + "U",
  IsAlpha + IsToken + "V",              IsAlpha + IsToken + "W",

  IsAlpha + IsToken + "X",              IsAlpha + IsToken + IsYes + "Y",
  IsAlpha + IsToken + "Z",              IsDelim + "{",
  IsDelim + "|",                        IsDelim + "}",
  IsDelim + "~",                        DEL;

internal safe integer array
  C!Tab [0:'177];


! ----------------------------------------------------------------------- ;
!! title Rtn C!PointerToInteger ;
! This routine is used to convert a record-pointer to an integer. ;
!  It is necessary to "fool" SAIL using start-code so that there
!  is absolutely no type-checking done during the conversion.
;

simple integer procedure C!PointerToInteger( record!pointer (Macro) Ptr );
  begin!code

    Hrrz  1,Ptr;		! Copy the pointer for our return ;

  end;

!! title Rtn C!IntegerToPointer ;
! This routine is used to convert an integer to a record-pointer. ;
!  It is necessary to "fool" SAIL using start-code so that there
!  is absolutely no type-checking done during the conversion.
;

simple record!pointer (Macro) procedure C!IntegerToPointer( Integer I );
  begin!code

    Hrrz  1,I;			! Copy the integer for our return ;

  end;

!! title Rtn Dispatch ;
! This is the dispatch routine.  It expects that 'Cmd' is a valid command
!  character.  For an explanation of the format of the dispatch table,
!  see the comments in C!Init.  Dispatch is defined here because numerous
!  routines below call it. ;

forward recursive procedure C!MacroDispatch( Integer MacroPointer );

simple procedure Dispatch( integer Cmd );
  begin "dispatch"

    C!Cmd := Cmd;
    C!Addr := C!Dispatch[ C!Cmd ];

    if ( lh( C!Addr ) = C!MacroPointer ) then

      C!MacroDispatch( C!Addr )

    else

    begin!code
      aos C!DispatchCount;      ! kick the counter ;
      pushj p,@C!Addr;          ! and go ;
    end;

    ! Remember the command, unless it wants to be invisible (eg, C!Arg) ;

    if ( C!Cmd >= 0 ) then
      begin
        C!LastCmd := C!Cmd;
        C!LastAddr := C!Addr;
      end;

  end "dispatch";
!! title Rtn C!WaitAndPossiblyCheckpoint ;
! Routine called from T!GetC when a redisplay has been done and there
! still isn't a character from the keyboard.  If a checkpoint interval
! has been given wait that long, then checkpoint the buffer is nothing
! has been done at the keyboard. ;

simple procedure C!WaitAndPossiblyCheckpoint;
begin "timer"
  ifcr TymcomX thenc
    own integer Flag;

    if (not C!CheckPointInterval) then
      return;

    start!code
      setzm     Flag;           ! assume character hit ;
      hrli      1, '11;         ! wait for char, wait in seconds ;
      hrr       1, C!CheckPointInterval;
      calli     1, '72;         ! hiber 1, ;
       jfcl;
      hrroi     1, '10;         ! .axsic - skip if character ;
      auxcal    1,;
        setom   Flag;           ! no character hit ;
    end;

    if (Flag) then
    begin
      W!Msg2("[CheckPoint]");
      B!CheckPoint;
      W!Disp(false);
    end;
  endc

  ifcr Tops20 thenc
    return;
  endc
end "timer" ;
!! title Rtn C!ChrP ;
! Routine to tell if a command character is available
;

internal simple boolean procedure C!ChrP;
  begin
    if ( C!CmdFileP ) then return( true );
    if ( length( C!Macro )) then return( true );
    return( T!ChrP );
  end;
!! title Rtn C!GetC ;
! Routine to get the next command character.  Returns one from
! wherever it is that we're getting characters.
;

internal simple integer procedure C!GetC;
  begin "get command character"
    own integer C;

    if ( length( C!Macro )) then ! return next char of macro string ;
      begin
        C := lop( C!Macro );
      end
    else if ( C!CmdFileP ) then
      begin
        ifcr TymcomX thenc
          C _ F!GetC;
        endc

        ifcr Tops20 thenc
          if (not (C _ charin(CF!Chan))) then
            C _ - 1;
        endc
      end
    else
      begin
        ! These tests should be seperate, since they are sensitive to
          time elapsing ;

        if ( not C!ChrP ) then W!Disp( true );
        if ( not C!ChrP ) then C!WaitAndPossiblyCheckpoint;
        C := T!GetC;
      end;

    ! here with next command character ;

    if ( C!DefiningMacro ) then
      begin
        C!LastMacro := C!LastMacro & C;
        if ( length( C!LastMacro ) = MAXMACROLENGTH ) then
          begin
            C!DefiningMacro := false;
            W!Msg( "Maximum Macro length exceeded -- aborting definition" );
            T!Bell;
          end;
      end;

    return( C );

  end "get command character";
!! title Rtn C!GetCMD ;
! Routine to get the next full command ;

forward string procedure CvCmdChr( integer C );

simple integer procedure C!GetCMD;
  begin "get command"
    own integer Temp;

    Temp := C!GetC;

    if ( Temp = C!MetaPrefix ) then
      begin
	W!Msg( "Meta" );
	Temp := C!GetC lor Meta;
      end
    else if ( Temp = C!XMetaPrefix ) then
      begin
	W!Msg( "XMeta" );
	Temp := C!GetC lor Meta2;
      end;

    if ( Temp land ( Meta lor Meta2 ) ) then
      begin
	W!Msg( CvCmdChr(Temp) );
        if ( C!CmdFileP and C!JournalFile and length( C!Macro ) = 0 ) then
	  W!Disp( True );
      end;

    return( Temp );

  end "get command";
!! title Rtn C!Err;
! Some Meta-Commands which aren't really considered to be user commands. ;

! "This command is no good" command.  This also has the effect of
!  closing a macro definition. ;

internal simple procedure C!Err;
  begin "abort"

    T!Bell;
    W!Msg( NULL );
    C!ArgV := 0;

    if ( C!DefiningMacro ) then
      begin
        C!DefiningMacro := false;
        C!LastMacro := C!LastMacro[1 for inf-1];
        if ( C!Cmd > '177 ) then
          C!LastMacro := C!LastMacro[1 for inf-1];
        W!Msg( "Keyboard macro defined" );
      end;

  end "abort";
!! title Rtn C!Ignore ;
! The basic no-op ;

simple procedure C!Ignore;
  begin
    C!ArgV := 0;
  end;


!! title Rtn C!Exit ;
! Command to abort the command loop. ;

internal simple procedure C!Exit;
  begin
    C!ArgV := 0;
    C!Quit := true;
  end;


!! title Rtn C!NotExit ;
! Command to not abort the command loop ;

simple procedure C!NotExit;
  begin
    C!ArgV := 0;
    W!Msg( "Use ^X^C" );
  end;
!! title Rtn C!Arg ;
! Pick up a numeric agrument and set C!ArgV.
! 
! This command is 'invisible' in that it uses some magic to
! cause Dispatch() to forget that we were just dispatched to.
! This prevents C!LastCmd from pointing to us, and enables
! ^K to work correctly.
;

simple procedure C!Arg;
  begin "arg"
    own integer C, N, P;

    if ( C!ArgV = 0 ) then
      C!ArgV := 1;

    W!Msg( "Arg: " & cvs(C!ArgV * C!ArgMultiplier) );
    P := N := 0;

    forever do
      begin "get arg"
        C := C!GetC;
        if ( C < "0" or C > "9" ) then done "get arg";
        P := true;
        N := N * 10 + ( C - "0" );
        W!Msg( "Arg: " & cvs( C!ArgV * N ) );
      end "get arg";

    C!Macro := C & C!Macro;

    if (C!DefiningMacro) then
      C!LastMacro := C!LastMacro[1 for inf-1];

    if ( P ) then C!ArgV := C!ArgV * N
    else C!ArgV := C!ArgV * C!ArgMultiplier;

    W!Msg( NULL );

    C!Cmd := -1;                ! cause Dispatch() to forget us ;

  end "arg";
!! title Rtn C!XOFFSynch ;
! "Synch" to the terminal by waiting for an XON (^Q).  This is useful
!  for those terminals which do XON/XOFF handshaking, and may keep on
!  XOFFing if you keep sending character at them.  (E.g. H19). ;

simple procedure C!XOFFSynch;
  begin "handshake"

    C!ArgV := 0;
    while ( T!GetC neq '21 ) do
    begin
    end;

  end "handshake";
!! title Rtn C!PushBinding ;
! Routine to "push" a key binding onto the binding stack ;

simple procedure C!PushBinding;
  begin "push binding"
    own integer Key;

    C!ArgV := 0;
    if ( C!BindingStackPnt = BINDINGSTACKSIZE ) then
      W!Msg( "Binding Stack is full" )
    else
      begin
        W!Msg( "Key: " );
        Key := C!GetCmd;
        C!BindingStackPnt := C!BindingStackPnt + 1;
        C!BindingStack[ C!BindingStackPnt ] := C!Dispatch[ Key ];
        W!Msg( NULL );
      end;

  end "push binding";
!! title Rtn C!Pop!Binding ;
! Routine to "pop" a binding off the stack and bind it to a key ;

simple procedure C!PopBinding;
  begin "pop binding"
    own integer Key;

    C!ArgV := 0;
    if ( C!BindingStackPnt = 0 ) then
      W!Msg( "Binding Stack is empty" )
    else
      begin
        W!Msg( "Key: " );
        Key := C!GetCmd;
        C!Dispatch[ Key ] := C!BindingStack[ C!BindingStackPnt ];
        C!BindingStackPnt := C!BindingStackPnt - 1;
        W!Msg( NULL );
      end;

  end "pop binding";
!! title The Commands themselves ;
! Other commands get included here ;

  ! first some forwards ... ;

  forward integer procedure SymCmdAddr( string C );
  forward integer procedure SymVarAddr( string S );
  forward string  procedure SymCmdName( integer V );
  forward string  procedure SymVarName( integer V );

  ! now the requires ;

  require "COMSUB.REQ" source!file;     ! handy subroutines ;
  require "COMM1.REQ" source!file;      ! simple commands ;
  require "COMM2.REQ" source!file;      ! tricky commands ;
  require "COMM3.REQ" source!file;      ! macro & rebinding commands ;
  require "COMM4.REQ" source!file;      ! file i/o commands ;
  require "COMM5.REQ" source!file;      ! mode stuff ;
  require "COMM6.REQ" source!file;      ! window manipulation commands ;
  require "COMM7.REQ" source!file;      ! help system ;

  ifcr TymcomX thenc
    require "COMM8.REQ" source!file;	! CREAUX stuff - AUXWIN ;
  endc
! title Rtn C!Init ;
! C!Init - Set up the key bindings, and symbolic stuff.
;

internal procedure C!Init;
  begin "initialization"

ifcr TymcomX thenc
    C!UserName := cv6str( call( xwd(-1, -'22), "gettab" )) &
                  cv6str( call( xwd(-1, -'21), "gettab" ));
endc

ifcr Tops20 thenc
    integer J, L, C, T;
    J := gjinf( L,C,T );
    C!UserName := dirst( L );
    clear(G!ShowGens);
endc

    C!MetaPrefix := ESC;        ! standard meta prefix ;
    C!XMetaPrefix := CAN;       ! standard xmeta prefix ;

    C!Debug := 0;               ! ... unless asked for ;

    C!DispatchCount := 0;       ! no commands dispatched, yet. ;

    C!CheckPointInterval := 60; ! 60 second delay before checkpoint ;

    G!AppendKillP := false;     ! We are not appending to the kill buffer.
                                ;
    C!Quit := false;            ! we're not dead, yet ;
    C!SPMRegion _ false;        ! Do not swap point and mark on
                                ! reqion-oriented commands
                                ;
    G!TextMode _ false;         ! We come up in Normal Mode.
                                ;
    C!CmdFileP := false;        ! commands are not coming from file ;
    C!DefiningMacro := false;   ! not defining macro ;
    C!Macro := NULL;            ! no macro, yet ;
    C!LastMacro := NULL;        ! no keyboard macro ;
    C!Search := NULL;           ! no search string, yet ;
    C!SearchM := NULL;          ! no m-search string, either ;
    C!QOldStr := null;          ! no q-replace search string ;
    C!QNewStr := null;          ! no q-replace replace string ;
    C!BindingStackPnt := 0;     ! nothing on the bind stack ;
    C!KillCnt := 0;             !  and has nothing in it ;
    C!ArgMultiplier := 4;       ! default multiplier ;
    C!LeftMargin := 1;          ! where the margins are ;
    C!RightMargin := 72;        !  (for those commands who care) ;
    C!VFMode _ 0;               ! Vue-compatibility paragraph fill mode ;
    C!TABWidth := 8;            ! default <tab> width ;
    C!IndentUnitWidth := 2;     ! default indentation unit ;
    C!UseTABS := 1;             ! try to use <TAB>s when indenting ;
    C!JournalMacro := 0;        ! journal macro commands off ;
    C!JournalFile := 0;         ! journal command file commands off ;
    C!JournalCommand := 0;      ! journal all commands off ;
    G!Test := 0;                ! test feature off ;
    G!OverWriteP := 0;          ! don't overwrite ;
    G!ESCF := 1;                ! print <ESC> as "$" ;
    G!WrapP := 1;               ! wrap long lines ;
    G!FFBreak := 1;             ! break page on <FF> ;
    G!CRCtl := true;            ! lonely CR displays as "^m" ;
    G!CaseMatch := 0;           ! default to folding case on search ;
    G!MagicMode := 0;

    C!MacroDepth_ -1;		! macro recursion depth ;

    C!MacroStack_ new!record( Macro );
    Macro:Next[ C!MacroStack ]_ new!record( Macro );
    Macro:Last[ Macro:Next[ C!MacroStack ] ]_ C!MacroStack;

    C!MacroNames_ new!record( Macro );
    Macro:Next[ C!MacroNames ]_ new!record( Macro );
    Macro:Last[ Macro:Next[ C!MacroNames ] ]_ C!MacroNames;

    clear(InsertLiterally);             ! Interpret characters as they are
                                        ! inserted.
                                        ;
    C!CreEscChr _ '30;                  ! The default CreAux escape
                                        ! character is ^X.
                                        ;
    C!AuxStr    _ null;                 ! The default login string is
                                        ! empty.
                                        ;
    C!AuxPort   _ -1;                   ! The default auxiliary port is
                                        ! undefined.
                                        ;

!! title Bind ASCII Commands ;
    ! Initialize the dispatch table ;

    define Loc(Routine) = {location( Routine )};

    C!Dispatch[  '0 ] := Loc( C!Ignore );       ! ^@ ;
    C!Dispatch[  '1 ] := Loc( C!MoveBOL );      ! ^A ;
    C!Dispatch[  '2 ] := Loc( C!MoveB );        ! ^B ;
    C!Dispatch[  '3 ] := Loc( C!NotExit );      ! ^C ;
    C!Dispatch[  '4 ] := Loc( C!DelF );         ! ^D ;
    C!Dispatch[  '5 ] := Loc( C!MoveEOL );      ! ^E ;
    C!Dispatch[  '6 ] := Loc( C!MoveF );        ! ^F ;
    C!Dispatch[  '7 ] := Loc( C!Err );          ! ^G ;
    C!Dispatch[ '10 ] := Loc( C!DelB );         ! ^H ;
    C!Dispatch[ '11 ] := Loc( C!Insert );       ! ^I ;
    C!Dispatch[ '12 ] := Loc( C!IndentDown );   ! ^J ;
    C!Dispatch[ '13 ] := Loc( C!DelEOL );       ! ^K ;
    C!Dispatch[ '14 ] := Loc( C!Refresh );      ! ^L ;
    C!Dispatch[ '15 ] := Loc( C!Insert );       ! ^M ;
    C!Dispatch[ '16 ] := Loc( C!MoveDown );     ! ^N ;
    C!Dispatch[ '17 ] := Loc( C!Open );         ! ^O ;
    C!Dispatch[ '20 ] := Loc( C!MoveUp );       ! ^P ;
    C!Dispatch[ '21 ] := Loc( C!Quote );        ! ^Q ;
    C!Dispatch[ '22 ] := Loc( C!RRSearch );     ! ^R ;
    C!Dispatch[ '23 ] := Loc( C!RFSearch );     ! ^S ;
    C!Dispatch[ '24 ] := Loc( C!Twiddle );      ! ^T ;
    C!Dispatch[ '25 ] := Loc( C!Arg );          ! ^U ;
    C!Dispatch[ '26 ] := Loc( C!NextScreen );   ! ^V ;
    C!Dispatch[ '27 ] := Loc( C!Wipe );         ! ^W ;
    C!Dispatch[ '30 ] := Loc( C!Err );          ! ^X - *reserved* ;
    C!Dispatch[ '31 ] := Loc( C!Yank );         ! ^Y ;
    C!Dispatch[ '32 ] := Loc( C!ScrollUp );     ! ^Z ;
    C!Dispatch[ '33 ] := Loc( C!Err );          ! ESC - *reserved* ;
    C!Dispatch[ '34 ] := Loc( C!Err );          ! ^\ - not bound ;
    C!Dispatch[ '35 ] := Loc( C!Err );          ! ^] - not bound ;
    C!Dispatch[ '36 ] := Loc( C!Toggle );       ! ^^ ;
    C!Dispatch[ '37 ] := Loc( C!Err );          ! ^_ - not bound ;

    ! All normally printable characters self-insert ;

    fill( C!Dispatch, '40, '176, Loc(C!Insert) );

    C!Dispatch[ DEL ] := Loc( C!DelB );         ! DEL ;

!! title Bind Meta Commands ;
    ! Meta commands.  Most of these are still undefined. ;

    fill( C!Dispatch, '200, '377, Loc(C!Err) );

    C!Dispatch[ Meta + '02 ] := Loc( C!MovTokenB );     ! Meta-^B ;
    C!Dispatch[ Meta + '04 ] := Loc( C!DelTokenF );     ! Meta-^D ;
    C!Dispatch[ Meta + '06 ] := Loc( C!MovTokenF );     ! Meta-^F ;
    C!Dispatch[ Meta + '10 ] := Loc( C!DelTokenB );     ! Meta-^H ;
    C!Dispatch[ Meta + '12 ] := Loc( C!RightJustify );  ! Meta-^J ;
    C!Dispatch[ Meta + '27 ] := Loc( C!Copy );          ! Meta-^W ;
    C!Dispatch[ Meta + '32 ] := Loc( C!ScrollDown );    ! Meta-^Z ;

    C!Dispatch[ Meta + " " ] := Loc( C!SetMark );       ! Meta-<space> ;
    C!Dispatch[ Meta + "!" ] := Loc( C!LineTOS );       ! Meta-! ;
    C!Dispatch[ Meta + "(" ] := Loc( C!MatchDelim );    ! Meta-( ;
    C!Dispatch[ Meta + ")" ] := Loc( C!MatchDelim );    ! Meta-) ;
    C!Dispatch[ Meta + "," ] := Loc( C!MovTOS );        ! Meta-, ;
    C!Dispatch[ Meta + "." ] := Loc( C!MovBOS );        ! Meta-. ;
    C!Dispatch[ Meta + ":" ] := Loc( C!MovSpecB );      ! Meta-: ;
    C!Dispatch[ Meta + ";" ] := Loc( C!MovSpecF );      ! Meta-;
    C!Dispatch[ Meta + "<" ] := Loc( C!MovBOB );        ! Meta-< ;
    C!Dispatch[ Meta + "=" ] := Loc( C!ShowSearch );    ! Meta-= ;
    C!Dispatch[ Meta + ">" ] := Loc( C!MovEOB );        ! Meta-> ;
    C!Dispatch[ Meta + "?" ] := Loc( C!Help );          ! Meta-? ;
    C!Dispatch[ Meta + "B" ] :=
    C!Dispatch[ Meta + "b" ] := Loc( C!MovTokenB );     ! Meta-b ;
    C!Dispatch[ Meta + "C" ] :=
    C!Dispatch[ Meta + "c" ] := Loc( C!ChangeString );  ! Meta-c ;
    C!Dispatch[ Meta + "D" ] :=
    C!Dispatch[ Meta + "d" ] := Loc( C!DeltokenF );     ! Meta-d ;
    C!Dispatch[ Meta + "F" ] :=
    C!Dispatch[ Meta + "f" ] := Loc( C!MovTokenF );     ! Meta-f ;
    C!Dispatch[ Meta + "G" ] :=
    C!Dispatch[ Meta + "g" ] := Loc( C!GotoMark );      ! Meta-g ;
    C!Dispatch[ Meta + "H" ] :=
    C!Dispatch[ Meta + "h" ] := Loc( C!DelTokenB );     ! Meta-h ;
    C!Dispatch[ Meta + "I" ] :=
    C!Dispatch[ Meta + "i" ] := Loc( C!AddIndent );     ! Meta-i ;
    C!Dispatch[ Meta + "J" ] :=
    C!Dispatch[ Meta + "j" ] := Loc( C!Err );           ! Meta-j ;
    C!Dispatch[ Meta + "K" ] :=
    C!Dispatch[ Meta + "k" ] := Loc( C!DelToEol );      ! Meta-K ;
    C!Dispatch[ Meta + "M" ] :=
    C!Dispatch[ Meta + "m" ] := Loc( C!MSearch );       ! Meta-M ;
    C!Dispatch[ Meta + "O" ] :=
    C!Dispatch[ Meta + "o" ] := Loc( C!OverWrite );     ! Meta-O ;
    C!Dispatch[ Meta + "P" ] :=
    C!Dispatch[ Meta + "p" ] := Loc( C!FillPara );      ! Meta-Q ;
    C!Dispatch[ Meta + "Q" ] :=
    C!Dispatch[ Meta + "q" ] := Loc( C!QueryChange );   ! Meta-Q ;
    C!Dispatch[ Meta + "R" ] :=
    C!Dispatch[ Meta + "r" ] := Loc( C!RSearch );       ! Meta-R ;
    C!Dispatch[ Meta + "S" ] :=
    C!Dispatch[ Meta + "s" ] := Loc( C!FSearch );       ! Meta-S ;
    C!Dispatch[ Meta + "U" ] :=
    C!Dispatch[ Meta + "u" ] := Loc( C!UnIndent );      ! Meta-U ;
    C!Dispatch[ Meta + "V" ] :=
    C!Dispatch[ Meta + "v" ] := Loc( C!PriorScreen );   ! Meta-V ;
    C!Dispatch[ Meta + "W" ] :=
    C!Dispatch[ Meta + "w" ] := Loc( C!ToggleWrap );    ! Meta-W ;
    C!Dispatch[ Meta + "X" ] :=
    C!Dispatch[ Meta + "x" ] := Loc( C!SymDispatch );   ! Meta-X ;
    C!Dispatch[ Meta + "Z" ] :=
    C!Dispatch[ Meta + "z" ] := Loc( C!ScrollDown );    ! Meta-Z ;

    C!Dispatch[ Meta + "^" ] := Loc( C!TokenToggle );   ! Meta-^ ;
    C!Dispatch[ Meta + "{" ] := Loc( C!MovBOP );        ! Meta-{ ;
    C!Dispatch[ Meta + "}" ] := Loc( C!MovEOP );        ! Meta-} ;
    C!Dispatch[ Meta + "~" ] := Loc( C!UnModify );      ! Meta-~ ;
!! title Bind Xmeta Commands ;

  ! XMeta commands ;

    fill( C!Dispatch, '400, '577, Loc(C!Err) );

    C!Dispatch[ Meta2 + '03 ] := Loc( C!SafeExit );     ! XMeta-^C ;
    C!Dispatch[ Meta2 + '05 ] := Loc( C!RunRPG );       ! XMeta-^E ;
    C!Dispatch[ Meta2 + '06 ] := Loc( C!Finish );       ! XMeta-^F ;
    C!Dispatch[ Meta2 + '11 ] := Loc( C!InsertFile );   ! XMeta-^I ;
    C!Dispatch[ Meta2 + '13 ] := Loc( C!KillBuffer );   ! XMeta-^K ;
    C!Dispatch[ Meta2 + '14 ] := Loc( C!CmdFile );      ! XMeta-^L ;
    C!Dispatch[ Meta2 + '16 ] := Loc( C!NewBuffer );    ! XMeta-^N ;
    C!Dispatch[ Meta2 + '17 ] := Loc( C!WSwitch );      ! XMeta-^O ;
    C!Dispatch[ Meta2 + '22 ] := Loc( C!ReadFile );     ! XMeta-^R ;
    C!Dispatch[ Meta2 + '23 ] := Loc( C!CheckPoint );   ! XMeta-^S ;
    C!Dispatch[ Meta2 + '24 ] := Loc( C!DateTimeMsg );  ! XMeta-^T ;
    C!Dispatch[ Meta2 + '25 ] := Loc( C!UnCheckPoint ); ! XMeta-^U ;
    C!Dispatch[ Meta2 + '27 ] := Loc( C!WriteFile );    ! XMeta-^W ;

    C!Dispatch[ Meta2 + '42 ] := Loc( C!MsgText );      ! XMeta-" ;
    C!Dispatch[ Meta2 + "!" ] := Loc( C!RecoverCheckPointFile ); ! XMeta-! ;
    C!Dispatch[ Meta2 + "_" ] := Loc( C!AssignVar );    ! XMeta-_ ;
    C!Dispatch[ Meta2 + "<" ] := Loc( C!LastBuffer );   ! XMeta-< ;
    C!Dispatch[ Meta2 + "=" ] := Loc( C!QueryVar );     ! XMeta-= ;
    C!Dispatch[ Meta2 + ">" ] := Loc( C!NextBuffer );   ! XMeta-> ;
    C!Dispatch[ Meta2 + "?" ] := Loc( C!QueryKey );     ! XMeta-? ;
    C!Dispatch[ Meta2 + "-" ] := Loc( C!Lock );         ! XMeta-- ;
    C!Dispatch[ Meta2 + "+" ] := Loc( C!UnLock );       ! XMeta-+ ;
    C!Dispatch[ Meta2 + "|" ] := Loc( C!Comment );      ! XMeta-| ;

    C!Dispatch[ Meta2 + "1" ] := Loc( C!W1 );           ! XMeta-1 ;
    C!Dispatch[ Meta2 + "2" ] := Loc( C!W2 );           ! XMeta-2 ;

    C!Dispatch[ Meta2 + "B" ] :=
    C!Dispatch[ Meta2 + "b" ] := Loc( C!ReBind );       ! XMeta-b ;
    C!Dispatch[ Meta2 + "D" ] :=
    C!Dispatch[ Meta2 + "d" ] := Loc( C!ReadMacro );    ! XMeta-d ;
    C!Dispatch[ Meta2 + "E" ] :=
    C!Dispatch[ Meta2 + "e" ] := Loc( C!MacroByExample ); !    -e ;
    C!Dispatch[ Meta2 + "G" ] :=
    C!Dispatch[ Meta2 + "g" ] := Loc( C!WGrow );        ! XMeta-g ;
    C!Dispatch[ Meta2 + "I" ] :=
    C!Dispatch[ Meta2 + "i" ] := Loc( C!EnvironStr );   ! XMeta-i ;
    C!Dispatch[ Meta2 + "M" ] :=
    C!Dispatch[ Meta2 + "m" ] := Loc( C!BindMacro );    ! XMeta-m ;
    C!Dispatch[ Meta2 + "N" ] :=
    C!Dispatch[ Meta2 + "n" ] := Loc( C!NormalMode );   ! XMeta-n ;
    C!Dispatch[ Meta2 + "S" ] :=
    C!Dispatch[ Meta2 + "s" ] := Loc( C!SwapPM );       ! XMeta-s ;
    C!Dispatch[ Meta2 + "T" ] :=
    C!Dispatch[ Meta2 + "t" ] := Loc( C!TextMode );     ! XMeta-t ;
    C!Dispatch[ Meta2 + "W" ] :=
    C!Dispatch[ Meta2 + "w" ] := Loc( C!DelWhiteF );    ! XMeta-w ;
    C!Dispatch[ Meta2 + "V" ] :=
    C!Dispatch[ Meta2 + "v" ] := Loc( C!DelWhiteB );    ! XMeta-v ;
    C!Dispatch[ Meta2 + "X" ] :=
    C!Dispatch[ Meta2 + "x" ] := Loc( C!ExecLastMacro ); ! XMeta-x ;

    C!Dispatch[ Meta2 + "[" ] := Loc( C!PushBinding );  ! XMeta-[ ;
    C!Dispatch[ Meta2 + "]" ] := Loc( C!PopBinding );   ! XMeta-] ;

  end "initialization";
!! title Expand Command Tables ;
! Build the symbolic command access tables
;
  require " [Expanding Command Tables]
" message;

  define $CC = 0, $CN = {preload!with }, $CA = {};

  define $Cmd( N, A ) = {
    redefine $CC = $CC + 1;
    redefine $CN = cvms( $CN ) & {N, };
    redefine $CA = cvms( $CA ) & {SymCmdA[}& cvms($CC) &{] := location(A); };
  };

    ! setting the argument ;

    $Cmd( "Argument",                   C!Arg );

    ! moving around ;

    $Cmd( "Up",                         C!MoveUp );
    $Cmd( "Down",                       C!MoveDown );
    $Cmd( "Forward",                    C!MoveF );
    $Cmd( "Backward",                   C!MoveB );
    $Cmd( "Forward Token",              C!MovTokenF );
    $Cmd( "Backward Token",             C!MovTokenB );
    $Cmd( "Beginning of Line",          C!MoveBOL );
    $Cmd( "End of Line",                C!MoveEOL );
    $Cmd( "Forward Window",             C!NextScreen );
    $Cmd( "Backward Window",            C!PriorScreen );
    $Cmd( "Top of Window",              C!MovTOS );
    $Cmd( "Bottom of Window",           C!MovBOS );
    $Cmd( "Top of Page",                C!MovBOP );
    $Cmd( "Bottom of Page",             C!MovEOP );
    $Cmd( "Top of Buffer",              C!MovBOB );
    $Cmd( "Bottom of Buffer",           C!MovEOB );
    $Cmd( "Line to Top of Window",      C!LineTOS );
    $Cmd( "Scroll Window Up",           C!ScrollUp );
    $Cmd( "Scroll Window Down",         C!ScrollDown );

    ! deleting stuff ;

    $Cmd( "Delete",                     C!DelF );
    $Cmd( "Delete Backward",            C!DelB );
    $Cmd( "Delete Token Forward",       C!DelTokenF );
    $Cmd( "Delete Token Backward",      C!DelTokenB );
    $Cmd( "Kill Line",                  C!DelEOL );
    $Cmd( "Set Append Kill",            C!SetAppendKill );
    $Cmd( "Kill Partial Line",          C!DelToEOL );
    $Cmd( "Delete Whitespace Forward",  C!DelWhiteF );
    $Cmd( "Delete Whitespace Backward", C!DelWhiteB );

    ! inserting stuff ;

    $Cmd( "Insert",                     C!Insert );
    $Cmd( "Insert CRLF",                C!InsertCRLF );
    $Cmd( "Insert TAB",                 C!InsertTAB );
    $Cmd( "Quote",                      C!Quote );
    $Cmd( "Column Insert",              C!InsStrtoCol );
    $Cmd( "Insert Octal",               C!InsertOctal );

    ! manipulation of lines ;

    $Cmd( "Open Line",                  C!Open );
    $Cmd( "Open Line With Indent",      C!IndentDown );
    $Cmd( "Indent Column Down",         C!ColumnDown );
    $Cmd( "Indent Line Down",           C!IndentDown );
    $Cmd( "Indent Line Up",             C!IndentUp );
    $Cmd( "Center Line",                C!Center );
    $Cmd( "Right Justify Line",         C!RightJustify );
    $Cmd( "Indent Line",                C!AddIndent );
    $Cmd( "Unindent Line",              C!UnIndent );

    ! other manipulations ;

    $Cmd( "Toggle Case",                C!Toggle );
    $Cmd( "Token UC",                   C!TokenUC );
    $Cmd( "Token LC",                   C!TokenLC );
    $Cmd( "Toggle Token",               C!TokenToggle );
    $Cmd( "Capitalize Token",           C!CapitalizeToken );
    $Cmd( "Transpose",                  C!Twiddle );
    $Cmd( "Up Paragraph",               C!BckHalfPara );
    $Cmd( "Down Paragraph",             C!FwdHalfPara );
    $Cmd( "Fill Line",                  C!FillLine );
    $Cmd( "Fill Paragraph",             C!FillPara );
    $Cmd( "Fill to End of Paragraph",   C!FillToEOP );
    $Cmd( "Set Left Margin",            C!SetLM );
    $Cmd( "Set Right Margin",           C!SetRM );
    $Cmd( "Force Left Margin",          C!ForceLeftMargin );
    $Cmd( "Goto Column",                C!GotoColumn );
    $Cmd( "Show Column",                C!ShowColumn );
    $Cmd( "Show Octal",                 C!ShowOctal );

    ! searching ;

    $Cmd( "Search",                     C!FSearch );
    $Cmd( "Copy to Search",             C!CopyToSearch );
    $Cmd( "Search Again",               C!RFSearch );
    $Cmd( "Show Search String",         C!ShowSearch );
    $Cmd( "Reverse Search",             C!RSearch );
    $Cmd( "Reverse Search Again",       C!RRSearch );
    $Cmd( "Change",                     C!ChangeString );
    $Cmd( "Query Change",               C!QueryChange );
    $Cmd( "Repeat Query Change",        C!RepeatQChange );
    $Cmd( "Multiple Search",            C!MSearch );
    $Cmd( "Match Parens",               C!MatchDelim );
    $Cmd( "Special Search",             C!MovSpecF );
    $Cmd( "Reverse Special Search",     C!MovSpecB );

    ! marks and region commands ;

    $Cmd( "Set Mark",                   C!SetMark );
    $Cmd( "Clear Mark",                 C!ClearMark );
    $Cmd( "Swap Mark",                  C!SwapPM );
    $Cmd( "Goto Mark",                  C!GotoMark );
    $Cmd( "Copy Region",                C!Copy );
    $Cmd( "Wipe Region",                C!Wipe );
    $Cmd( "Insert Kill Buffer",         C!Yank );
    $Cmd( "Indent Region",              C!IndentRegion );
    $Cmd( "Unindent Region",            C!UnindentRegion );

    ! Window Manipulations ;

    $Cmd( "Split Window",               C!W2 );
    $Cmd( "Unsplit Window",             C!W1 );
    $Cmd( "Switch Windows",             C!WSwitch );
    $Cmd( "Grow Window",                C!WGrow );
    $Cmd( "Window Bar",                 C!WBar );
    $Cmd( "Refresh Window",             C!Refresh );

    ! Buffer manipulations ;

    $Cmd( "New Buffer",                 C!NewBuffer );
    $Cmd( "Delete Buffer",              C!KillBuffer );
    $Cmd( "Next Buffer",                C!NextBuffer );
    $Cmd( "Last Buffer",                C!LastBuffer );
    $Cmd( "Lock Buffer",                C!Lock );
    $Cmd( "Unlock Buffer",              C!UnLock );
    $Cmd( "UnModify Buffer",            C!UnModify );

    ! Reading/Writing Files ;

    $Cmd( "Read File",                  C!ReadFile );
    $Cmd( "Insert File",                C!InsertFile );
    $Cmd( "Write File",                 C!WriteFile );
    $Cmd( "Command File",               C!CmdFile );
    $Cmd( "Finish",                     C!Finish );
    $Cmd( "Finish to RPG",              C!RunRPG );
    $Cmd( "Checkpoint",                 C!Checkpoint );
    $Cmd( "Recover Checkpoint",         C!UnCheckPoint );
    $Cmd( "Recover CheckPoint File",    C!RecoverCheckPointFile );
    $Cmd( "Safe Exit",                  C!SafeExit );
    $Cmd( "Exit",                       C!Exit );

    ! mode stuff ;

    $Cmd( "Text Mode",                  C!TextMode );
    $Cmd( "Normal Mode",                C!NormalMode );
    $Cmd( "Toggle Wrap Flag",           C!ToggleWrap );
    $Cmd( "Toggle Overwrite Flag",      C!OverWrite );

    ! variable, macro and key binding stuff ;

    $Cmd( "Bind Variable",              C!AssignVar );
    $Cmd( "Query Variable",             C!QueryVar );
    $Cmd( "Bind Function",              C!ReBind );
    $Cmd( "Query Function",             C!QueryKey );
    $Cmd( "Execute Function",           C!SymDispatch );
    $Cmd( "UnBind Key",                 C!UnBindKey );
    $Cmd( "Define Macro",               C!ReadMacro );
    $Cmd( "Define Macro by Example",    C!MacroByExample );
    $Cmd( "Bind Macro",                 C!BindMacro );
    $Cmd( "Name Macro",                 C!NameMacro );
    $Cmd( "UnName Macro",               C!UnNameMacro );
    $Cmd( "Push Binding",               C!PushBinding );
    $Cmd( "Pop Binding",                C!PopBinding );
    $Cmd( "Execute Macro",              C!ExecLastMacro );

    ! manipulating the character table ;

    $Cmd( "Is Number",                  C!SetNum );
    $Cmd( "Not Number",                 C!ClearNum );
    $Cmd( "Is Token",                   C!SetToken );
    $Cmd( "Not Token",                  C!ClearToken );
    $Cmd( "Is Delim",                   C!SetDelim );
    $Cmd( "Not Delim",                  C!ClearDelim );
    $Cmd( "Is Special",                 C!SetSpecial );
    $Cmd( "Not Special",                C!ClearSpecial );

    ! misc. ;

    $Cmd( "Delete NULLs",               C!DelNULLs );
    $Cmd( "XOFF Synch",                 C!XOFFSynch );
    $Cmd( "Nothing",                    C!Ignore );
    $Cmd( "Frame Push",                 C!PushFrame );
    $Cmd( "Beep",                       T!Bell );
    $Cmd( "Help",                       C!Help );
    $Cmd( "Abort Command",              C!Err );
    $Cmd( "Start Comment",              C!Comment );
    $Cmd( "Start Message",              C!MsgText );
    $Cmd( "Date Time Message",          C!DateTimeMsg );
    $Cmd( "Insert Information String",  C!EnvironStr );
    $Cmd( "Increment Char",             C!IncrChar );
    $Cmd( "Decrement Char",             C!DecrChar );
    $Cmd( "Set Terminal Type",          C!SetTermType );

    ifcr TymcomX thenc
      $Cmd( "CreAux",			C!CreAux );
      $Cmd( "Set CreAux Esc Char",      C!SetCreEsc );
    endc

  ! finish up the macro ;

  redefine $CN = cvms( $CN ) &
    {NULL; safe string array SymCmd[ 1 : $CC + 1 ]; };

  ! expand the name table ;

  $CN

  ! allocate the address table ;

  safe integer array SymCmdA[ 1 : $CC ];
!! title Rtn InitSymCmdAddr ;

procedure InitSymCmdAddr;
  begin
    $CA
  end;

require InitSymCmdAddr initialization;
!! title Expand Variable Tables ;
! Now do the symbolic variable access stuff
;

  require " [Expanding Variable Tables]
" message;

  define $VC = 0, $VN = {preload!with }, $VA = {};

  define $Var( N, A ) = {
    redefine $VC = $VC + 1;
    redefine $VN = cvms( $VN ) & {N, };
    redefine $VA = cvms( $VA ) & {SymVarA[}& cvms($VC) &{] := location(A); };
  };

    $Var( ".Debug",             C!Debug );
    $Var( ".Cmd",               C!Cmd );
    $Var( ".LastCmd",           C!LastCmd );
    $Var( ".Arg",               C!ArgV );
    $Var( ".ScreenWidth",       T!Width );
    $Var( ".ExitToRPG",         F!RPGFlag );
    $Var( ".MetaPrefix",        C!MetaPrefix );
    $Var( ".XMetaPrefix",       C!XMetaPrefix );
    $Var( ".Box",               W!BoxP );
    $Var( ".StickyColumn",      C!StickyColumn );

    $Var( "Multiplier",         C!ArgMultiplier );
    $Var( "WrapLongLines",      G!WrapP );
    $Var( "BreakPageOnFF",      G!FFBreak );
    $Var( "EscapeAs$",          G!ESCF );
    $Var( "OverWriteOnInsert",  G!OverWriteP );
    $Var( "UseTabs",            C!UseTabs );
    $Var( "TabWidth",           C!TABWidth );
    $Var( "IndentWidth",        C!IndentUnitWidth );
    $Var( "LeftMargin",         C!LeftMargin );
    $Var( "RightMargin",        C!RightMargin );
    $Var( "ExactCaseMatch",     G!CaseMatch );
    $Var( "CRAsCtl",            G!CRCtl );
    $Var( "JournalMacro",       C!JournalMacro );
    $Var( "JournalFile",        C!JournalFile );
    $Var( "JournalCommand",     C!JournalCommand );
    $Var( "SwapPMRegion",       C!SPMRegion);
    $Var( "VariableFill",       C!VFMode);

    $Var( "CheckpointInterval", C!CheckPointInterval );

  redefine $VN = cvms( $VN ) &
    { NULL; safe string array SymVar[ 1 : $VC + 1 ]; };

  $VN

  safe integer array SymVarA[ 1 : $VC ];
!! title Rtn InitVarLocs ;

procedure InitVarLocs;
  begin
    $VA
  end;

require InitVarLocs initialization;
!! title Rtn SymCmdAddr ;
! Routine to return the address of a function given its name.
! Two types of address are returned:
!        0 ,, Addr of Routine in Command Tables  (or)
!     Flag ,, Record Pointer to Keyboard Macro
;

integer procedure SymCmdAddr( string Cmd );
  begin "addr"
    integer I, Index;
    record!pointer (Macro) Idx, Ptr;

    Index := 0;

    ! Start with zero index "*unknown*" := 0        ;
    ! If we find a partial match -- then            ;
    !   If an exact match,                          ;
    !     then return the address                   ;
    !     else If non-zero-index [previous match]   ;
    !            then return "*ambigious*" := -1    ;
    !            else set index for match           ;
    ! If Index is non-zero, then return the address ;
    !   else return 0                               ;

    Ptr_ C!MacroNames;
    while ( Ptr_ Macro:Next[ Ptr ] ) do
      if ( kequ( Cmd, Macro:Name[ Ptr ][1 for length( Cmd )] )) then

        if ( kequ( Cmd, Macro:Name[ Ptr ] )) then
          return( Macro:Id[ Ptr ] )
        else if ( Idx ) then
	       if ( kequ( Macro:Name[ Ptr ], Macro:Name[ Idx ] )) then
	       else return( -1 )
	     else
	       Idx_ Ptr;

    if ( Idx ) then
      Index_ Macro:Id[ Idx ];

    for I := 1 upto $CC do
      if ( kequ( Cmd, SymCmd[ I ][1 for length( Cmd )] )) then

        if ( kequ( Cmd, SymCmd[ I ] )) then
          return( SymCmdA[ I ] )
        else if ( Index ) then
	       if ( lh( Index ) = C!MacroPointer ) then
	         if ( kequ(SymCmd[I], Macro:Name[ Idx ] )) then
		 else return( -1 )
               else return( -1 )
             else
               Index := I;

    return( if Index then
	      if ( lh( Index ) = C!MacroPointer ) then
	        Index
	      else
	        SymCmdA[ Index ]
	    else 0 );

  end "addr";
!! title Rtn SymVarAddr ;
! Given a variable name, return it's address.
;

integer procedure SymVarAddr( string Sym );
  begin "val"
    integer I, Index;

    Index := 0;

    ! Start with zero index "*unknown*" := 0        ;
    ! If we find a partial match -- then            ;
    !   If an exact match,                          ;
    !     then return the address                   ;
    !     else If non-zero-index [previous match]   ;
    !            then return "*ambigious*" := -1    ;
    !            else set index for match           ;
    ! If Index is non-zero, then return the address ;
    !   else return 0                               ;

    for I := 1 upto $VC do
      if ( kequ( Sym, SymVar[ I ][1 for length( Sym )] )) then

        if ( kequ( Sym, SymVar[ I ] )) then
          return( SymVarA[ I ] )
        else if ( Index ) then
               return( -1 )
             else
               Index := I;

    return( if Index then SymVarA[ Index ] else 0 );

  end "val";
!! title Rtn SymCmdName ;
! Given an address, figure out what routine it is.
! Two types of address are deciphered:
!        0 ,, Addr of Routine in Command Tables  (or)
!     Flag ,, Record Pointer to Keyboard Macro
;

string procedure SymCmdName( integer Addr );
  begin "name"
    integer I;
    record!pointer (Macro) Ptr;

    if ( lh( Addr ) = C!MacroPointer ) then
      begin "macro name pointer"

	Ptr_ C!MacroNames;
	while ( Ptr_ Macro:Next[ Ptr ] ) do
	  if ( Macro:Id[ Ptr ] = Addr ) then
	    return( Macro:Name[ Ptr ] & " (Macro)" );

	Ptr_ C!MacroStack;
	while ( Ptr_ Macro:Next[ Ptr ] ) do
	  if ( Macro:Id[ Ptr ] = Addr ) then
	    return( if length( Macro:Name[ Ptr ] ) then
		      Macro:Name[ Ptr ] & " (Macro)"
		    else """Un-named"" (Macro)" );

      end "macro name pointer"

      else
	for I := 1 upto $CC do
	  if ( SymCmdA[ I ] = Addr ) then return( SymCmd[ I ] );

    return( NULL );

  end "name";
!! title Rtn SymVarName ;
! Given an address, figure out what variable it is.
;

string procedure SymVarName( integer Addr);
  begin "name"
    integer I;

    for I := 1 upto $VC do
      if ( SymVarA[ I ] = Addr ) then return( SymVar[ I ] );

    return( NULL );

  end "name";
!! title Rtn C!Loop ;
! C!Loop - the main command dispatch lives here.  "Meta" and "XMeta"
! commands are formed by routine C!GetCMD. ;

internal recursive procedure C!Loop;
begin "command loop"
  integer
    Cmd;

  W!NewS;

  forever do
  begin "loop"
    Cmd _ C!GetCMD;

    if (Cmd < 0) then
      done "loop";

    Dispatch(Cmd);

    if (C!Quit) then
      done "loop";
  end "loop";
end "command loop";
!! title Rtn C!File ;
! C!File - take commands from a file ;
;

simple boolean procedure C!File (string F);
begin "cmd file"
  ifcr TymcomX thenc
    if ( not F!Lookup( F )) then return( false );

    C!CmdFileP := true;		! now taking commands from file ;
    C!Loop;			! take the commands ;
    C!CmdFileP := false;	! done with file ;
    F!Release;			! release the file ;
    C!Quit := false;		! keep us in the command loop ;

    return( true );		! return success ;
  endc

  ifcr Tops20 thenc
    CF!Chan _ openfile(F, "ROE");

      ! Try opening the command file.
      ;

    if (!skip!) then
      return(false);

      ! Could not open the command file.
      ;

    set(C!CmdFileP);

      ! Now taking commands from file.
      ;

    C!Loop;

      ! Take the commands.
      ;

    clear(C!CmdFileP);

      ! Done with file.
      ;

    cfile(CF!Chan);

      ! Release the file.
      ;

    clear(C!Quit);

      ! Keep us in the command loop.
      ;

    return(true);

      ! Return success.
      ;
  endc
end "cmd file";
!! title Rtn C!Ini ;
! C!Ini - read initialization file.
;

internal procedure C!INI;
  begin
    string IniFileName;

    ifcr TymcomX thenc
      IniFileName _ "(" & C!UserName & ")" & DED!Alias & ".INI";
    endc

    ifcr Tops20 thenc
      ifcr false thenc
        IniFileName _ "PS:<" & C!UserName & ">" & DED!Alias & ".INI";
      elsec
        IniFileName _ "PS:[" & C!UserName & "]" & "FtPeak.Ini";
      endc
    endc

    if (not C!File(IniFileName)) then
      W!Msg("No " & IniFileName)
    else
      W!Msg(null);
  end;
end "DED - Command module";


! **************************  End Comand.Sai  *************************** ;
N|bh