SUBTTL	TBA SORT ROUTINES
TITLE	SORTSB   TBA SORT SUBROUTINES
	TWOSEG
	RELOC	400000

	SALL


	PP==17
	TA==13	;REDEFINED FROM 16
	TB==12	;REDEF. FROM 15
	TC==11	;REDEF. FROM 14
	TD==10	;REDEF. FROM 13
	TE==7	;REDEF. FROM 12

; FILE TABLE DEFINITIONS:
;       SXNAM (IN PAGD)         SIXBIT FILE NAME
;       SXEXT (IN PAGD)         SIXBIT EXTENSION IN LEFT HALF, RH=0
;       SXUN  (IN PAGD)         SIXBIT USERNAME 1ST HALF
;       SXUN2 (IN PAGD)         SIXBIT USERNAME 2ND HALF
;       SXSIZ (IN PAGD)         SIZE OF SIXBIT BLOCK
        FILPTR==SXSIZ           ;CURRENT CURSOR TO FILE
        FSTAT==FILPTR+1         ;STATUS OF FILE 1=READ -1=WRITE 0=CLOSED
        FTSIZE==SXSIZ+2         ;SIZE OF WHOLE TABLE

	$JOB==30	;PJOB UUO


	ENTRY PSORT.	;INITIALIZE
	ENTRY MERGE.	;MERGE THE SCRATCH FILES
	ENTRY RETRN.	;RETURN A RECORD
	ENTRY RELES.	;PROCESS A RELEASED RECORD
	ENTRY ENDS.	;CLEAN UP AFTER SORT

	INTERN	RETLEN

	EXTERNAL DSCR	;DSA DESCRIPTORS
	FILE1=DSCR+3
	TABLOC=DSCR+4
;KILL JOB

	DEFINE	STOPIT(MESSAG)<
	MOVEI	0,[ASCIZ/MESSAG/]
	JRST	KILL.##		;IN TBASRT
	>
	SUBTTL	INITIALIZE

PSORT.:	MOVEI	TA,2
	EXCH	TA,(PP)
	ADDM	TA,(PP)		;POPJ NOW RETURNS AFTER ARGUMENTS
	MOVE	TB,1(TA)
	MOVE	TA,(TA)
	HLRZM	TA,KEYSIZ	;SIZE OF CONVERTED KEY, IN WORDS
	HLRZM	TB,KEYLOC	;LOCATION OF CONVERTED KEYS
	HRRZM	TB,KEYCV.	;LOCATION OF KEY CREATION CODE
	MOVE	TB,RECSIZ##	;MAX RECORD SIZE (FROM TBASRT)
	MOVEI	TC,5		;ASSUME ASCII - 5 CHARS PER WORD.
	ADDI	TB,-1(TC)	;TO FORCE UPWARD ROUNDING
	IDIVI	TB,(TC)		;NO. WORDS TO HOLD LARGEST RECORD
	ADD	TB,KEYSIZ	;NO. WORDS FOR KEYS
	HRRZI	TB,1(TB)	;FLAG WORD
	HRRZM	TB,NWDREC	;RECORD SIZE IN WORDS

	MOVEI	TE,^D128
	IDIV	TE,NWDREC
	CAIGE	TE,3
	MOVEI	TE,3
	HRRZM	TE,N		;TABLE SIZE IS N
GETC.2:	MOVEI	TD,3	;NO. OF FILES
	HRRZM	TD,NFILES
	IMULI	TD,FTSIZE	;NUMBER OF WORDS PER FILE
	CALL	ALLSP##,<$,TD,FILE1,0>
	CALLI	TD,$JOB		;GET JOB NUMBER

	MOVEI	TE,3
GETC2A:	IDIVI	TD,^D10
	ADDI	TC,"0"-40
	LSHC	TC,-6
	SOJG	TE,GETC2A
	HLRZM	TB,JOBNUM

	MOVE	TA,FILE1
	SETZM	CURFIL
GETC.3:	MOVE	TB,[SIXBIT /JOBS00/]
	HRL	TB,JOBNUM
	MOVEM	TB,SXNAM(TA)
	MOVE	TB,[SIXBIT /TMP/]
	MOVEM	TB,SXEXT(TA)
	SETZM	SXUN(TA)	;USE CURRENT DIRECTORY
	SETZM	SXUN2(TA)
	SETZM	FSTAT(TA)	;CLOSED
	AOS	TB,CURFIL
	HRRZM	TA,FILLST-1(TB)	;SET UP FILLST ENTRY
	ADDM	TB,SXNAM(TA)	;FILE NUMBER
	ADDI	TA,FTSIZE
	CAMGE	TB,NFILES
	JRST	GETC.3		;DO NEXT TABLE
	SETOM	SBFRDY		;FILE TABLES SET UP.
	HRRZ	TB,N
	MOVE	TE,NWDREC
	ADDI	TE,2
	IMUL	TE,TB
	CALL	ALLSP,<$,TE,TABLOC,0>
	MOVE	TC,TABLOC
	MOVE	TA,TC
	ADD	TA,N
	MOVEM	TA,TEMLOC
	ADD	TA,N
	MOVEM	TA,SRTARE
	HRRZI	TB,1
SET.1:	CAMLE	TB,N
	JRST	SET.2
	HRRZM	TA,(TC)
	HRRZI	TC,1(TC)
	ADD	TA,NWDREC
	AOJA	TB,SET.1

SET.2:	HRRZ	TA,SRTARE
	HRLS	TA
	HRRI	TA,1(TA)
	SETZM	-1(TA)
	MOVE	TB,NWDREC
	IMUL	TB,N
	ADDI	TB,-2(TA)
	BLT	TA,(TB)
	SETZM	CURFIL
SET2.1:	AOS	TA,CURFIL	;OPEN ALL BUT LAST FILE FOR OUTPUT
	CAML	TA,NFILES
	JRST	SET.3
	HRRZI	TB,1
	HRRZM	TB,NSTRAD-1(TA)
	HRRZS	TB,FILLST-1(TA)
	PUSHJ	PP,OPENOT	;OPEN FOR OUTPUT
	JRST	SET2.1
SET.3:	SETZM	NSTRAD-1(TA)
	SETZM	CURFIL
	SETZM	IGNFIL
	SETZM	RECREL
	SETZM	RECRET
	HRRZI	TA,1
	HRRZM	TA,LV
	SETZM	NT
	POPJ	PP,
	SUBTTL	MERGE PHASE

MERGE.:	HRRZ	TA,LV
	CAIN	TA,1
	JRST	M2		;NO INVISIBLE RECORDS
	HRRZM	TA,TCOUNT
	HRRZ	TA,LV
	JRST	M1.5
M1:	PUSHJ	PP,PUTOUT	;PUT OUT ALL VISIBLE RECORDS
	AOS	TA,LV
M1.5:	CAMG	TA,NT
	JRST	M1
	SOS	TA,TCOUNT
	HRRZM	TA,NT
	PUSHJ	PP,SETNXT	;SET UP NEW STRING
	HRRZI	TA,1		;MAKE REMAINING RECORDS VISIBLE
	HRRZM	TA,LV
M2:	PUSHJ	PP,PUTOUT	;PUT OUT CURRENTLY VISIBLE RECORDS
	AOS	TA,LV
	CAMG	TA,NT
	JRST	M2
	MOVE	TA,IGNFIL
	MOVEM	TA,TCOUNT
	PUSHJ	PP,SETNXT
	MOVE	TA,IGNFIL
	CAMN	TA,TCOUNT
	JRST	M3
	HRRZ	TA,NFILES	;DISTRIBUTION PERFECT --- BACK DOWN ONE LEVEL
	SETZM	NSTRAD-1(TA)
	SOJG	TA,.-1
M3:	SETZB	TA,CURFIL
M4:	HRRZ	TB,FILLST(TA)
	PUSH	PP,TB
	PUSHJ	PP,WRTEOF	;WRITE EOF AND CLOSE
	POP	PP,TB
	PUSHJ	PP,CLOSIT	;ALL OUTPUT FILES
	AOS	TA,CURFIL
	HRRZ	TB,NFILES
	CAIGE	TA,-1(TB)
	JRST	M4
	SETZB	TA,CURFIL
	SETZB	TB,CURFIL
	HRRZ	TA,NFILES
	HRRZI	TA,-1(TA)
	HRRZM	TA,OUTFIL
	SETZM	NSTRAD(TA)
P0:	HRRZ	TB,FILLST(TB)
	PUSHJ	PP,OPENIN	;OPEN FILE FOR INPUT
	AOS	TB,CURFIL
	HRRZ	TC,NFILES
	CAIGE	TB,-1(TC)
	JRST	P0
P.1:	PUSHJ	PP,RDALL
P1.05:	SETZB	TA,CURFIL
P1.1:	CAMN	TA,OUTFIL
	JRST	P1.2		;NOT AN INPUT FILE
	HLRZ	TB,FILLST(TA)	;STRING COUNT
	SKIPLE	TC,NSTRAD(TA)
	ADD	TB,TC
	JUMPG	TB,P1.3		;MORE MERGE PASSES REQUIRED
P1.2:	HRRZI	TA,1(TA)
	CAMGE	TA,NFILES
	JRST	P1.1
SETRET:	SETOM	RTRN		;'RETURN OKAY' FLAG
	SETZM	RECRET
	POPJ	PP,
RDALL:	SETZB	TA,CURFIL
P1.30:	CAMN	TA,OUTFIL
	JRST	P1.31
	HRRZ	TB,FILLST(TA)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRRZ	TC,(TD)
	MOVE	TD,EOS
	MOVEM	TD,(TC)
	PUSHJ	PP,IFREAD	;READ UNLESS DUMMY STRING
	HRRZ	TA,CURFIL
	HLRZ	TB,FILLST(TA)	;NO. STRINGS ON FILE
	JUMPE	TB,.+2
	HRRZI	TB,-1(TB)	;DECREMENT IF POSITIVE
	SOSGE	NSTRAD(TA)
	HRLM	TB,FILLST(TA)	;PUT IN DECREMENTED COUNT
P1.31:	AOS	TA,CURFIL
	CAMGE	TA,NFILES
	JRST	P1.30
	POPJ	PP,
P1.3:	HRRZ	TA,OUTFIL
	HRRZS	TB,FILLST(TA)	;CLEAR STRING COUNT
	SETZM	NSTRAD(TA)
	PUSHJ	PP,OPENOT	;OPEN FOR OUTPUT
P.2:	SETZB	TA,CURFIL
P2.1:	CAMN	TA,OUTFIL
	JRST	P2.2
	HRRZ	TE,TABLOC
	ADDI	TE,(TA)
	HRRZ	TB,(TE)
	MOVE	TE,(TB)
	CAMN	TE,EOF.
	JRST	P.4
P2.2:	AOS	TA,CURFIL
	CAMGE	TA,NFILES
	JRST	P2.1
P.3:	PUSHJ	PP,GETSML	;FIND SMALLEST RECORD
	HRRZ	TB,I
	HRRZ	TA,TABLOC
	ADDI	TA,(TB)
	HRRZ	TC,(TA)
	MOVE	TA,(TC)
	CAMN	TA,EOS
	JRST	P3.1		;ALL AT EOS
	CAMN	TA,EOF.
	JRST	RLYEOF
	ADD	TA,KEYSIZ
	HRRZI	TA,1(TA)
	HRRZ	TB,OUTFIL		;OUTPUT FILE
	HRRZ	TB,FILLST(TB)
	PUSH	PP,TC	;SAVE RECORD LOC
	PUSHJ	PP,WRITIT	;WRITE IT
	HRRZ	TA,I
	HRRZ	TB,FILLST(TA)
	POP	PP,TC		;GET RECORD LOC BACK
	PUSHJ	PP,DOREAD	;READ A RECORD
	JRST	P.3

P3.1:	HRRZ	TA,OUTFIL
	HRRZ	TB,FILLST(TA)
	HLRZ	TE,FILLST(TA)
	HRRZI	TE,1(TE)
	HRLM	TE,FILLST(TA)	;BUMP STRING COUNT
	PUSHJ	PP,WRTEOS	;WRITE 'END-OF-STRING'
	PUSHJ	PP,RDALL
	JRST	P.2

P.4:	HRRZ	TA,OUTFIL	;EOF ON CURFIL AFTER ALL REACHED EOS
	HRRZ	TB,FILLST(TA)	;OUTPUT FILE TABLE ADDRESS
	PUSH	PP,TB
	PUSHJ	PP,WRTEOF	;WRITE 'END-OF-FILE'
	MOVE	TB,(PP)
	PUSHJ	PP,CLOSIT	;CLOSE FILE
	POP	PP,TB
	PUSHJ	PP,OPENIN	;OPEN FILE FOR INPUT
	HRRZ	TA,CURFIL
	HRRZ	TB,FILLST(TA)
	PUSHJ	PP,PURGIT
	HRRZ	TA,CURFIL
	EXCH	TA,OUTFIL	;CURFIL WILL BECOME OUTPUT FILE
	HRRZM	TA,CURFIL	;AND OUTPUT FILE WILL BECOME INPUT FILE
	HRRZ	TB,FILLST(TA)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRRZ	TC,(TD)
	MOVE	TD,EOS
	MOVEM	TD,(TC)
	PUSHJ	PP,IFREAD	;READ FILE UNLESS DUMMY STRING
	HRRZ	TA,CURFIL
	HLRZ	TB,FILLST(TA)
	JUMPE	TB,.+2
	HRRZI	TB,-1(TB)
	SOSGE	NSTRAD(TA)
	HRLM	TB,FILLST(TA)
	JRST	P1.05
GETSML:	SETZB	TA,I
	CAMN	TA,OUTFIL
	HRRZI	TA,1(TA)
	HRRZM	TA,I
	HRRZM	TA,J
GET.01:	AOS	TB,J
	CAMN	TB,OUTFIL
	JRST	GET.01
	CAML	TB,NFILES
	JRST	GETS.3
	HRRZ	TA,I
	HRRZ	TE,TABLOC
	ADDI	TE,(TA)
	HRRZ	TC,(TE)
	MOVE	TE,(TC)		;FLAG WORD FOR RECORD I
	CAME	TE,EOS
	JRST	GETS.1		;NOT EOS
GET.05:	HRRZI	TA,(TB)
	HRRZM	TA,I		;I_J
	JRST	GET.01
GETS.1:	HRRZ	TE,TABLOC
	ADDI	TE,(TB)
	HRRZ	TD,(TE)
	MOVE	TE,(TD)		;FLAG WORD FOR RECORD J
	CAMN	TE,EOS
	JRST	GET.01		;EOS
	HRRZ	TE,KEYSIZ
GET1.5:	HRRZI	TC,1(TC)	;RECORD I
	HRRZI	TD,1(TD)	;RECORD J
	MOVE	TA,(TC)
	CAMN	TA,(TD)
	JRST	GETS.2		;EQUAL SO FAR
	CAMLE	TA,(TD)
	HRRZM	TB,I		;RECORD J < RECORD I
	JRST	GET.01
GETS.2:	SOJG	TE,GET1.5	;MORE KEY WORDS
	JRST	GET.01
GETS.3:	POPJ	PP,
SUBTTL RETURN RECORDS

RETRN.:	SKIPL	RTRN
	JRST	NORET		;RETURN NOT ACTIVE
	PUSHJ	PP,GETSML
	HRRZ	TA,I
	HRRZ	TE,TABLOC
	ADDI	TE,(TA)
	HRRZ	TB,(TE)
	MOVE	TE,(TB)		;RECORD I FLAG WORD
	CAMN	TE,EOS
	JRST	RETDUN		;FINISHED
	MOVEM	TE,RETLEN	;[7]# OF WORDS IN RETURNED RECORD
	CAMN	TE,EOF.
	JRST	RETDUN
	HRRZ	TC,RECLOC	;SD-FILE RECORD AREA
	HRRZI	TD,(TC)
	ADDI	TD,-1(TE)
	ADD	TB,KEYSIZ
	HRLI	TC,1(TB)	;START OF RECORD ITSELF
	BLT	TC,(TD)		;MOVE RECORD TO SD-FILE
	HRRZ	TC,TB		;MOVE RECORD LOC TO TC
	SUB	TC,KEYSIZ		;BACK TO START
	HRRZ	TB,FILLST(TA)
	PUSHJ	PP,DOREAD	;READ RECORD
	AOS	TA,RECRET
	CAMLE	TA,RECREL
	JRST	BAD1
	POPJ	PP,
RETDUN:	SETZM	RTRN
	MOVE	TA,RECREL
	CAME	TA,RECRET
	JRST	BADCNT
	AOS	(PP)
	POPJ	PP,
	SUBTTL	PROCESS RECORDS RELEASED

RELES.:	SKIPN	TA		;MAKE SURE AT LEAST ONE
	MOVEI	TA,1		;WORD IS WRITTEN
	MOVEM	TA,RELSIZ	;SIZE OF RECORD RELEASED, IN WORDS
	SKIPN	TA,KEYCV.
	JRST	NOSORT		;NO ACTIVE SORT
	PUSHJ	PP,(TA)		;CONVERT KEYS
	HRRZ	TA,NT		;NO. RECORDS IN TABLE
	CAMGE	TA,N
	JRST	NOTFUL		;TABLE NOT FULL
	PUSHJ	PP,BINSER	;FIND PLACE IN TABLE FOR RELEASED RECORD
	HRRZ	TA,LV
	CAMG	TA,N
	JRST	P.6		;SOME RECORDS ARE VISIBLE
	PUSHJ	PP,SETNXT	;SET UP TO START NEW STRING
	HRRZI	TA,1
	HRRZM	TA,LV		;MAKE ALL VISIBLE
P.6:	PUSHJ	PP,PUTOUT	;OUTPUT TABLE(LV) RECORD
	HRRZ	TB,LV
	ADD	TB,TABLOC
	HRRZ	TA,-1(TB)	;CORE LOCATION OF RECORD PUT OUT
	HRRZ	TB,RELSIZ	;SIZE OF RECORD RELEASED
	HRRZM	TB,(TA)		;FLAG WORD FOR NEW RECORD
	HRRZI	TB,1(TA)	;FIRST LOCATION FOR KEYS
	HRL	TB,KEYLOC
	HRRZ	TC,KEYSIZ
	ADDI	TC,(TA)
	BLT	TB,(TC)		;MOVE KEYS TO SAVE AREA
	HRRZI	TD,1(TC)	;FIRST LOCATION FOR RECORD
	HRL	TD,RECLOC	;RECLOC POINTS TO SD-FILE RECORD AREA
	ADD	TC,RELSIZ
	BLT	TD,(TC)		;MOVE RECORD
	HRRZ	TA,I		;I IS INDEX OF TABLE ENTRY NEW RECORD
	CAMN	TA,LV		;SHOULD FOLLOW--0 IF IT PRECEDES ALL
	JRST	RELXIT		;SIMPLE REPLACEMENT
	CAML	TA,LV
	JRST	Q1		;NEW RECORD WILL BE VISIBLE
	HRRZ	TB,LV
	CAIG	TB,1(TA)
	JRST	P.7		;NEW RECORD REPLACED OLD ONE INVISIBLY
	HRRZ	TD,TABLOC
	ADDI	TD,-1(TB)
	HRRZ	TE,(TD)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRLZI	TC,(TD)		;TABLE(I+1)
	ADD	TA,TEMLOC
	HRRI	TC,(TA)		;TEMP(I+1)
	MOVS	TD,TC		;TEMP(I+1),TABLE(I+1)
	ADD	TB,TEMLOC
	BLT	TC,-2(TB)	;TABLE(I+1) THRU TABLE(LV-1) MOVED TO TEMPS
	HRRI	TD,1(TD)	;TEMP(I+1),TABLE(I+2)
	HRRZ	TB,LV
	ADD	TB,TABLOC
	BLT	TD,-1(TB)
	HRRZ	TA,I
	ADD	TA,TABLOC
	HRRZM	TE,(TA)
P.7:	AOS	LV
RELXIT:	AOS	RECREL
	POPJ	PP,
Q1:	HRRZ	TA,LV
	ADD	TA,TABLOC
	HRRZ	TE,-1(TA)

	HRLZI	TB,(TA)		;TABLE(LV)
	HRRI	TB,-1(TA)	;TABLE(LV-1)
	HRRZ	TC,I
	ADD	TC,TABLOC
	BLT	TB,-2(TC)	;TABLE(I-2)
	HRRZM	TE,-1(TC)	;TABLE(I-1)
	JRST	RELXIT
NOTFUL:	SKIPLE	TA,NT
	PUSHJ	PP,BINSER
	SKIPE	TA,NT
	CAMG	TA,I
	JRST	NOTF.1
	HRRZ	TA,I
	HRRZ	TB,TABLOC
	ADDI	TB,(TA)		;TABLE(I+1)
	HRRZ	TC,TEMLOC
	HRLZS	TB
	HRRI	TB,(TC)
	ADDI	TB,(TA)		;XWD TABLE(I+1),TEMP(I+1)
	MOVS	TD,TB
	HRRZ	TE,NT
	ADDI	TC,-1(TE)	;TEMP(NT)
	BLT	TB,(TC)
	HRRI	TD,1(TD)	;XWD TEMP(I),TABLE(I+1)
	HRRZ	TC,TABLOC
	ADDI	TC,(TE)		;TABLE(NT+1)
	MOVE	TB,(TC)
	BLT	TD,(TC)
	HRRZ	TA,I
	ADD	TA,TABLOC
	MOVEM	TB,(TA)		;TABLE(I+1)
	JRST	NOTF.2
NOTF.1:	ADD	TA,TABLOC
NOTF.2:	HRRZ	TA,(TA)		;RECORD AREA FOR NEW RECORD
	HRRZ	TC,RELSIZ
	HRRZM	TC,(TA)		;FLAG WORD
	HRRZI	TB,1(TA)
	HRL	TB,KEYLOC
	HRRZ	TC,KEYSIZ
	ADDI	TC,(TA)
	BLT	TB,(TC)		;KEYS
	HRRZI	TD,1(TC)
	HRL	TD,RECLOC
	ADD	TC,RELSIZ
	BLT	TD,(TC)
	AOS	NT
	JRST	RELXIT
	SUBTTL	CLEAN UP AFTER COBOL SORT
;		(ALSO ON ERROR EXIT)

ENDS.:	SKIPN	SBFRDY	;DON'T BOTHER IF TABLES NOT SET UP.
	JRST	END.3
	SETZB	TA,CURFIL
END.1:	HRRZ	TB,FILLST(TA)
	SKIPN	FSTAT(TB)
	JRST	END.2
	PUSHJ	PP,PURGIT
END.2:	AOS	TA,CURFIL
	CAMGE	TA,NFILES
	JRST	END.1

END.3:	SETZM	KEYCV.
	SETZM	TB,RTRN
	POPJ	PP,
	SUBTTL	OUTPUTS RECORD LV ON CURRENT STRING

PUTOUT:	HRRZ	TB,LV
	ADD	TA,TABLOC
	HRRZ	TC,-1(TA)
	HRRZ	TA,(TC)
	ADD	TA,KEYSIZ
	HRRZI	TA,1(TA)
	HRRZ	TD,CURFIL
	HRRZ	TB,FILLST(TD)
	PUSHJ	PP,WRITIT
	POPJ	PP,
	SUBTTL	SET UP NEXT FILE TO RECEIVE OUTPUT STRING

SETNXT:	HRRZ	TA,CURFIL
	HLRZ	TB,FILLST(TA)
	HRRZI	TB,1(TB)		;INCREMENT STRING COUNT ON
	HRLM	TB,FILLST(TA)		;CURRENT FILE BY 1
	HRRZ	TB,FILLST(TA)		;FILE TABLE ADDRESS FOR CURRENT FILE
	PUSHJ	PP,WRTEOS	;WRITE 'END-OF-STRING'
	HRRZ	TC,CURFIL
	SOS	NSTRAD(TC)	;DECREMENT NO. STRINGS TO ADD
SNX0.1:	AOS	TC,CURFIL
	HRRZ	TD,NFILES
	IDIVI	TC,-1(TD)
	HRRZM	TB,CURFIL	;ADVANCE CURFIL TO NEXT
	CAMN	TB,IGNFIL	;USABLE OUTPUT FILE
	JRST	SNX0.1
	SKIPLE	NSTRAD(TB)
	POPJ	PP,		;ADD STRING TO HIM
SNX0.2:	AOS	TC,IGNFIL
	HRRZ	TD,NFILES
	IDIVI	TC,-1(TD)
	HRRZM	TB,IGNFIL	;ADVANCE IGNFIL
	SETZM	NSTRAD(TB)
	HLRZ	TA,FILLST(TB)	;NO. STRINGS ON IGNFIL
	SETZ	TB,
SNX0.3:	CAME	TB,IGNFIL
	HRRZM	TA,NSTRAD(TB)	;IS NO. TO ADD TO EACH OF OTHERS
	HRRZI	TB,1(TB)
	CAMGE	TB,NFILES
	JRST	SNX0.3
	HRRZ	TB,IGNFIL
	HRRZI	TB,1(TB)
	IDIVI	TB,-1(TD)
	HRRZM	TA,CURFIL	;CURFIL_IGNFIL+1
	POPJ	PP,
SUBTTL BINARY SEARCH OF KEYS FOR RECORDS IN CORE

BINSER:	HRRZ	TA,NT
	HRRZI	TB,(TA)
	ANDI	TA,-1(TB)
	JUMPN	TA,.-2		;FIND LARGEST POWER OF 2 <= NT
	HRRZI	TA,(TB)
	HRRZM	TA,J
	SETZ	TD,		;COMPARISON INDICATOR
	HRRZM	TA,I
B1:	ADD	TA,TABLOC
	HRRZ	TA,-1(TA)	;LOCATION OF RECORD I
	HRRZI	TA,1(TA)	;LOCATION OF KEYS FOR RECORD I
	HRRZ	TB,KEYLOC	;LOCATION OF KEYS FOR NEW RECORD
	HRRZ	TC,KEYSIZ	;NO. OF WORDS OF KEYS
B1.1:	SOJL	TC,B3		;COMPARISON COMPLETE
	MOVE	TE,(TA)		;KEY WORD FOR RECORD I
	CAMN	TE,(TB)
	JRST	B1.2		;EQUAL SO FAR
	CAMG	TE,(TB)
	TDZA	TD,TD		;RECORD I < NEW RECORD
	SETO	TD,		;RECORD I > NEW RECORD
	HRRZ	TA,J
	CAIG	TA,1
	JRST	B1.3		;COMPARISONS COMPLETE
	LSH	TA,-1
	HRRZM	TA,J		;J_J/2
	CAIGE	TD,0
	MOVNS	TA		;RECORD I > NEW RECORD
	ADDB	TA,I
	JUMPL	TD,B1		;CHECK NEXT RECORD
	CAMG	TA,NT		;OVER TOP OF TABLE?
	JRST	B1		;NO
	SUB	TA,J		;YES, SO SET I TO LAST I WHICH WAS
	HRRZI	TA,1(TA)	;WITHIN BOUNDS, + 1
	HRRZM	TA,I
B2:	CAMLE	TA,NT
	JRST	B2.4		;OVER TOP OF TABLE
	ADD	TA,TABLOC
	HRRZ	TA,-1(TA)	;LOCATION OF RECORD I
	HRRZI	TA,1(TA)	;LOCATION OF RECORD I KEYS
	HRRZ	TB,KEYLOC	;NEW RECORD KEY LOCATION
	HRRZ	TC,KEYSIZ
B2.1:	SOJL	TC,B3		;COMPARISON COMPLETE
	MOVE	TE,(TA)
	CAMN	TE,(TB)
	JRST	B2.2		;EQUAL SO FAR
	CAML	TE,(TB)
	JRST	B2.4		;RECORD I > NEW RECORD
	AOS	TA,I
	JRST	B2		;TRY NEXT
B2.2:	HRRZI	TA,1(TA)
	AOJA	TB,B2.1		;NEXT WORDS OF KEYS

B1.2:	HRRZI	TA,1(TA)
	AOJA	TB,B1.1

B1.3:	JUMPGE	TD,B3
B2.4:	SOS	I		;RECORD I > NEW, I-1 < NEW
B3:	POPJ	PP,
	SUBTTL FILE I/O ROUTINES

OPENIN:	SKIPE	FSTAT(TB)
	JRST	FLOPEN
	OPEN	@TB,,READ,,<RZ,SQ>
	SKIPE	1
	JRST	TFLERR
	READ	2
	MOVEM	2,FILPTR(TB)
	AOS	FSTAT(TB)
	POPJ	PP,

OPENOT:	SKIPE	FSTAT(TB)
	JRST	FLOPEN
	OPEN	@TB,,SUPER,,<RZ,TP,SQ>
	SKIPE	1
	JRST	TFLERR
	READ	2
	MOVEM	2,FILPTR(TB)
	SETOM	FSTAT(TB)
	POPJ	PP,

CLOSIT:	SKIPN	FSTAT(TB)
	JRST	FLCLSD
	MOVE	TA,FILPTR(TB)
	SKIPL	FSTAT(TB)
	JRST	CLST1
	WRITE	TA
	JRST	CLST2
CLST1:	FREE	TA
CLST2:	CALL	CLOSEF##,<$,TA>
	SETZM	FSTAT(TB)
	POPJ	PP,

PURGIT:	PUSHJ	PP,CLOSIT
	OPEN @TB,,DELETE,,<CLOSE>
	POPJ	PP,

WRTEOF:	MOVE	TA,FILPTR(TB)
	MOVEI	TC,1
	OUT	TC,TA
	MOVE	TC,EOF.
	OUT	TC,TA
	MOVEM	TA,FILPTR(TB)
	POPJ	PP,

WRTEOS:	MOVE	TA,FILPTR(TB)
	MOVEI	TC,1
	OUT	TC,TA
	MOVE	TC,EOS
	OUT	TC,TA
	MOVEM	TA,FILPTR(TB)
	POPJ	PP,

DOREAD:	MOVE	TE,FILPTR(TB)
	IN	TD,TE
	JRST	ATEND
	CALL	TFR##,<$,TD,$,TE,$,TC,0>
	MOVEM	1,FILPTR(TB)
	POPJ	PP,

;READ UNLESS DUMMY NULL STRING

IFREAD:	SKIPLE	NSTRAD(TA)
	JRST	IFRED
	PUSHJ	PP,DOREAD
IFRED:	POPJ	PP,

WRITIT:	MOVE	TE,FILPTR(TB)
	OUT	TA,TE
	CALL	TFR##,<$,TA,$,TE,$,TC,1>
	MOVEM	1,FILPTR(TB)
	POPJ	PP,
	SUBTTL ERROR ROUTINES

ATEND:	STOPIT	<At end on SORT temp file>
FLOPEN:	STOPIT	<Attempt to open already open temporary file>
FLCLSD:	STOPIT	<Attempt to close unopened temporary file>
NORET:	STOPIT	<Return encountered, SORT not active>
BADCNT:	CAML	TA,RECRET
	JRST	BAD2
BAD1:	STOPIT	<Returned more records than released>
BAD2:	STOPIT	<Some released records lost somewhere>
RLYEOF:	STOPIT	<EOF precedes EOS on merge file>
NOSORT:	STOPIT	<Release executed with no sort active>
TFLERR:	STOPIT	<Can't open temporary file>
	SUBTTL A COUPLE CONSTANTS

EOS:	XWD	-3,-3		;END-OF-STRING FLAG
EOF.:	XWD	0,0		;END-OF-FILE FLAG
	SUBTTL	IMPURE AREA

	RELOC	;PUT IN LOSEG

EXTERN	KEYCV.,RECLOC,SBFRDY

TCOUNT:	BLOCK	1
FILLST:	BLOCK	^D16
I:	BLOCK	1
J:	BLOCK	1
N:	BLOCK	1
NT:	BLOCK	1
KEYSIZ:	BLOCK	1
KEYLOC:	BLOCK	1
LV:	BLOCK	1
NFILES:	BLOCK	1
MXRCSZ:	BLOCK	1
NWDREC:	BLOCK	1
CURFIL:	BLOCK	1
IGNFIL:	BLOCK	1
RECREL:	BLOCK	1
RECRET:	BLOCK	1
RTRN:	BLOCK	1
RELSIZ:	BLOCK	1
OUTFIL:	BLOCK	1
NSTRAD:	BLOCK	^D16
TEMLOC:	BLOCK	1
JOBNUM:	BLOCK	1
SRTARE:	BLOCK	1
RETLEN:	BLOCK	1

	RELOC	;PUT LITERALS, ETC. IN HISEG

	END
  