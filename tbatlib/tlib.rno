.upper case
.spacing 1
.paper size 54,73
.left margin 8
.right margin 75
.tab stops 5 10 15 20 25 30 35 40 45 50 55 60 65 70
.paragraph 0
.flag capitalize
.flag index
.flag underline
.number 1
.C;TYMBASIC USER FUNCTION LIBRARY
.S3;.C;15 March 1978
.S2;.C;TYMSHARE, INC.
.C;Technical Division
.PAGE
.first title
.nojustify
.FLAG INDEX
.NONUMBER
.x Table of Contents
.c;TABLE OF CONTENTS
.s4;.lm+8;.tab stop 60
.nf;Introduction	2
.i4;Use of User Library Functions	2
.i4;Tymshare Support of Library Functions	3
.s2;Terminal I/O	4
.i4;Block I/O	5
.s2;Interfacing with PERFORM	7
.s2;Running Another Program	9
.s2;Job, User, and System Information	12
.s4;Dates	20
.s2;File I/O	23
.i4;Scanning a File Directory	25
.s2;Array Operations	40
.s2;Half-Word Manipulation	41
.s2;Extended Escape Control	44
.s2;FORTRAN string conversion	48
.s2;Fast Sorter	52
.s2;INDEX	53
.page
.lm-8
.NUMBER 2
.tab stops 5 10 15 20 25 30 35 40 45 50 55 60 65 70
.title      TYMBASIC User Function Library
.i-4;^&Introduction\&
.s2.f
The functions described here (also referred to as 
"procedures") are available for use in any TYMBASIC program, and are
intended to provide interfaces to some of the Tymcom-X operating
system features and to supplement the built-in TYMBASIC features
and library functions.
.p;.i-4;^&Use of User Library Functions\&
.X User Library Functions >Use of
.x Use of ^User ^Library ^Functions
.x Accessing ^User ^Library ^Functions
.p;The functions are accessed in the same manner as a user-defined
.x <DEF Statement
.x user-defined procedures
procedure in TYMBASIC.
First, the TYMBASIC module that contains the call to the function must
contain a statement of the form:
.p
.x <DEF statement
.nf;     DEF EXTERNAL FUNCTION.NAME(ARGS)
.f
.x language type
.x value of a function
.p;In some cases, a keyword identifying the language type (i.e.,  "SIMPL") must be inserted to provide the
.x language type
.x function type
correct interface to the given function; appearance of this keyword
does not otherwise affect the use or the behavior of the function.
.x type
If the function returns a value, then a keyword identifying the type
(i.e., INTEGER) must also be present.
.x <AKA clause
.x function identifiers
.x function names
.p;In some other cases, an "AKA" clause must appear because the
.x <AKA clause
actual name of the function contains characters which are illegal as
identifiers in TYMBASIC. Many of the functions contain such characters
.x user-defined procedures
to prevent conflicts with the names of user-defined
procedures.
.p;The DEF statement may appear even if the function is not actually called
in the TYMBASIC module.
This allows the user to maintain a list of DEF's
.x <CALL statement
that make up a standard part of his TYMBASIC module.
The function will only be loaded into core from the function library
if referenced by a call (that is, by the CALL statement or by
reference to the function from within an expression).
.p;The exact form of the required DEF will be given with each
function.
.tp 13
.p;^&Tymshare Support of Library Functions\&
.x Library Functions >Support of
.x support of ^Library ^Functions by ^Tymshare
.x maintainance of ^library ^functions
.p;User library functions fall into two categories:
those supported by Tymshare and those not supported.
If functions in the latter category are used, the following TYMBASIC command must
be issued prior to loading (see the TYMBASIC Reference Manual):
.x <TLIB
.x <library command
.x <tbatlib
.x <LIBRARY command
.x <TLIB
.p.i+4;_>LIBRARY (TBATLIB)TLIB
.P;The category of support will be given with each function.
.PAGE;.NF;.SUBTITLE        Terminal I/O                                              26 May 1977
.x Terminal <i/o
.s;SET.EC                                   SUPPORTED
------                            Beginning with Ver 2.5
.s;Form of DEF:
.s;    DEF EXTERNAL SET.EC(LOGICAL L)
.s;Arguments:
.s;.lm+4;L is TRUE to set ECHO on and FALSE to set it off.
.s;.i-4;Results:
.s;.f;Sets the TYMBASIC ECHOing on or off for the current
command source and all subsequent command sources (in the
case of command file stacking).
.s;SET.EC has exactly the same effect as the ECHO and NO ECHO TYMBASIC
commands, which are not available within a TYMBASIC program.
.s;.i-4;Use:
.s;SET.EC is useful in writing applications where command files will
be opened and ECHOing may be desired.
.lm-4;.page;.nf
.x Terminal <i/o
.s;STUFIB                               NOT SUPPORTED
.x <STUFIB
------
.s;Form of DEF:
.s;    DEF EXTERNAL SIMPL STUFIB(STRING S)
.s;Arguments:
.s;.lm+4;.f;S is a string containing the characters to be inserted into
the job's input buffer.
It must contain any carriage returns desired; TYMBASIC will not provide
a terminating carriage return.
.s;.i-4;Results:
.s;Inserts the characters contained in S into the current job's terminal
input buffer.
There is no guarantee that all characters will be inserted -- this depends
on the size assigned to the input buffer by the operating system,
and on the number of characters already in the buffer.
The characters inserted may be mixed arbitrarily with characters arriving
from the user's terminal if the user's typing coincides with this call.
.s;.i-4;Use:
.s;STUFIB is useful as a means of inter-program communication when
short command strings can be used.
.lm-4;.page
.x Terminal <i/o
.s;^&Block Output to the Terminal\&
.s;Overview
.s;.f;Using block output instead of the normal method can
reduce the terminal output component of the cost by
35-40_%, when driving a 30 CPS terminal.
Since there is a charge for the time the
program spends in block output mode, slower terminals will cost
more and faster ones cost less.
It is not cost-effective to use block output for small
bursts of output; each output operation is charged for a
minimum of 80 characters.
A conservative way to proceed is to bracket any portion of the
program that runs terminal-bound with calls to BEGIN.BLOCK.OUT
and END.BLOCK.OUT.
.nf;.S;BEGIN.BLOCK.OUT                            SUPPORTED
---------------                   Beginning with Ver 2.4
.s;Form of DEF
.s;    DEF LOGICAL EXTERNAL SIMPL BEGIN.BLOCK.OUT AKA ".BBO"
.s;Arguments:
.s;.i4;None.
.s;Results:
.f;.s;.lm+4;Returns TRUE if the terminal was put into block output
mode.
If TRUE, characters currently buffered for output and all
further terminal-directed output will be transmitted by
blocks, until END.BLOCK.OUT is called.
Characters will be transmitted when the block (400 characters long)
is full, rather than when a carriage return is output.
Of course, requests for input, execution of a WAIT -1 statement,
and end of program cause the buffered characters to be transmitted
just as for normal terminal output.
.lm-4;.page;.nf;
.x terminal <i/o
END.BLOCK.OUT                        SUPPORTED
-------------                      Beginning with Ver 2.4
.s;Form of DEF:
.s;    DEF EXTERNAL SIMPL END.BLOCK.OUT AKA ".EBO"
.s;Arguments:
.s;.i4;None.
.s;Results:
.s;.lm+4;.f;If the output buffer is not empty, ship it.
Terminate block output.
.lm-4;.PAGE;.nf;
.subtitle         Interfacing with PERFORM                                 13 May 1977
.x Interfacing with <perform
.s;^&ST.PER\&                            NOT SUPPORTED
.s2;Form of DEF:
.x <PERFORM
.s;.i4;DEF LOGICAL EXTERNAL ST.PER
.p;Arguments:
.s;.i4;None.
.p;Results:
.p;.f;.lm+4;If a PERFORM command file is active, ST.PER opens it as
the TYMBASIC commmand file, positions to the next character
to be input, and returns TRUE.
.x command files
Otherwise, ST.PER returns FALSE.
.p;.i-4;Use:
.p;
It is safe to always call ST.PER at the beginning of the program,
since it takes no action if it finds no active PERFORM
command file.
ST.PER should be used in conjunction with EXITPE, discussed
below.
.p;Note that when a TYMBASIC command file is open, normal
terminal input is taken from the command file.
.x terminal input
.lm-4;.page;.nofill
.subtitle         Interfacing with Perform                                 13 May 1977
.x Interfacing with <perform
.s;^&EXITPE\&                            NOT SUPPORTED
.x <PERFORM
.s;Form of DEF:
.s;.i4;DEF EXTERNAL EXITPE
.p;Arguments:
.p;.i4;None.
.p;Results:
.x command files
.p;.f;.lm+4;If a TYMBASIC command file is
open, EXITPE writes its current cursor position out to the PERFORM
cursor file and runs PERFORM; otherwise, it
deletes the PERFORM command file, if any, and returns to
XEXEC.
.p;.i-4;Use:
.p;EXITPE should be called only if ST.PER was called earlier in the
program.
.p;EXITPE deletes the PERFORM command file if no TYMBASIC
command file is open because it assumes that all the characters
have been read out of the command file and that TYMBASIC
automatically closed the file.
.p;If the user wishes to merely exit to PERFORM without
having made use of the PERFORM command file, he can use the
RUNUUO function on "(SYS)PERFORM"
.x <RUNUUO
with a starting offset of 1.
.p;EXITPE never returns.
.p;
Also, command files may not be nested beyond the PERFORM command
file at the time of the call.
.lm-4;.page;.nf;
.subtitle         Running Another Program                                  13 May 1977
.x running another program
.s;RUNUUO                              SUPPORTED
.x <RUNUUO
------                            Beginning with ver 2.3
.s;Form of DEF:                            
.S;.I4;DEF EXTERNAL SIMPL RUNUUO (STRING S, INTEGER I)
.S;Arguments:
.f;.s;.lm+4;S is the file nomen (see the TYMBASIC Reference Manual) of the
.x file >nomen
program to run.

.s;I is the offset from the startpoint in words at which the 
program is to be started.
.x startpoint
.x startpoint offset
.s;.i-4;Results:
.s;
RUNUUO runs the specified program at the given startpoint
(limited to 1 if the user may not read the high segment about to be
run, else limited to 77B).
If the file nomen specified by S is illegal, a FILE error condition
results on file unit number -9.
If the run fails for any other reason, RUNUUO returns; however,
all IO channels and various other attributes of the program will 
have been deactivated by the Monitor.
Therefore, the program should severly limit its actions
following an error return from RUNUUO.
.x error condition
.x file >unit number -9
.x <file error condition
.x <IO channels
.s;.i-4;Use:
.s;The startpoint offset is normally zero or one, the latter usually
indicating that the RUN has been executed from another program
(as apposed to the user at the terminal), and that its initial
input or state vector may be found in a special command file
(start-up information is also sometimes passed in the registers;
see ST.REG, below).
.x <ST.REG
.x registers
Many TYMCOM-X utilities (PIP, CROSS, all the compilers)
use this convention, and all programs created with the SAVE
BINARY command in TYMBASIC may be run with an offset
of zero or one. 
.x <SAVE
.x <save <binary command
However, not all programs can be run with an offset of one.
.x command files
.x <PIP
.x <CROSS
.x compilers
.p;A TYMBASIC program can examine the offset it was run with
by looking at the special variable START.POINT.
.x <start.point
.p;The standard convention on TYMCOM-X for one program
to  communicate some data to another is through a .TMP
file, named in the following manner: the first three characters
of the file name are the job number of the current job (see index),
right-justified, in decimal with zero fill.
The last three characters make up a unique keyword that
identifies the second program.
This is very often the first three characters of the program name.
.x <.tmp file
.x file >name
.x job number
For example, if the user's job number is 48, and the program
.x running another program
to be run is SAMPLE, the file name would be "048SAM.TMP".
SAMPLE will normally take its commands out of this file if run
with an offset of one.
However, the file may contain any sort of data meant for
.x command files
.x startpoint offset
.x <Start.point
SAMPLE's consumption.
.s;
Example:
.s;.nf;.lm+4;the program FIRSTP:
_.
_.
_.
160 OPEN STR(JOBNO,"DDD")+"SAM.TMP-A", OUTPUT,3
170 PRINT ON 3: "NYC.DAT,1967"
180 PRINT ON 3: "CHI.DAT,1968"
190 CLOSE 3
200 CALL RUNUUO("SAMPLE", 1)
210 STOP "Cannot run SAMPLE"
.S;the program SAMPLE:
_.
_.
_.
100 IF START.POINT=1 THEN !open as command file
110    OPEN STR(JOBNO,"DDD")+"SAM.TMP",INPUT, -1
120 ENDIF
130 INPUT COMMAND.LINE$ !Input the command
.LM-4
.lm-4.nf.page
.subtitle         Running Another Program                                  15 March 1978
.x running another program
.x <ST.REG
.x registers
^&ST.REG\&                              SUPPORTED
                                Beginning with Ver 4.5
.s
Form of DEF:
.s.i4;DEF INTEGER EXTERNAL SIMPL ST.REG(INTEGER I)
.s;Arguments:
.f.s.lm+4
I is the register number, from 0 to 17B.
.lm-4
.s
Results:
.s.lm+4
ST.REG returns the contents of register I as they were when the program
was run.
Like the TBA system-defined variable START.POINT, these values only have
meaning when a program created by the SAVE BINARY command is run,
.x <SAVE <BINARY
.x <START.POINT
and are zero otherwise.
If I is not between 0 and 17B, the resulting value is undefined.
.s.i-4;Use:
.s
Certain program pass information to programs they run through
registers as well as through temporary files.
.lm-4;.NF;.page
.subtitle         Job, User, and System Information                        30 August 1977
.x Job, User, and System Information
.x <GETPJC
.s;GETPJC                                  NOT SUPPORTED
------                               Beginning with Ver 3.11
.s;Form of DEF:
.s;.i4;DEF STRING EXTERNAL GETPJC
.s;Arguments:
.s;.i4;None.
.s;Results:
.s;.f;.lm+4;Returns a string containing the users project code.
.lm-4
.page;.nf
.subttl	Job, User, and System Information
.s;GET.GFD.PPN					NOT SUPPORTED
-----------
.s;Form of DEF:
.s.i+4;DEF STRING EXTERNAL GET.GFD.PPN
.s;Arguments:
.s.lm+4;None
.i-4.s;Results:
.f;.s;Returns PPN of GFDed user in the form [account,user number] or null string if error.
.lm-4
.page;.nf
.subttl	Job, User, and System Information
.s;GET.LOG.PPN                                 NOT SUPPORTED
-----------
.s;Form of DEF:
.s.i+4;DEF STRING EXTERNAL GET.LOG.PPN
.s;Arguments:
.s.lm+4;None
.i-4.s;Results:
.f;.s;Returns PPN of logged in user in the form [account,user number] or null string if error.
.lm-4
.page;.nf
.subttl	Job, User, and System Information
.s;GET.PROG.NAM                                 NOT SUPPORTED
------------
.s;Form of DEF:
.s.i+4;DEF STRING EXTERNAL GET.PROG.NAM
.s;Arguments:
.s.lm+4;None
.i-4.s;Results:
.f;.s;Returns program name or null string if error.
.lm-4
.page;.nf
.subttl	Job, User, and System Information
.s;GET.RUN.PPN                                 NOT SUPPORTED
-----------
.s;Form of DEF:
.s.i+4;DEF STRING EXTERNAL GET.RUN.PPN
.s;Arguments:
.s.lm+4;None
.i-4.s;Results:
.f;.s;Returns PPN of run-from user in the form [account,user number] (or null string if error).
 The run-from directory is the directory in which the
 running program is stored.
.lm-4;.page;.nf;
.subtitle         Job, User, and System Information                      1 August 1980
.x job, user, and system information
.x <ILOG.PPN
.s;ILOG.PPN                                 NOT SUPPORTED
--------
.s;Form of DEF:
.s.i+4;DEF INTEGER EXTERNAL ILOG.PPN
.s;Arguments:
.s.lm+4;None
.i-4.s;Results:
.f;.s;PPN of logged in user as an integer.
.lm-4
.page;.nf;.s;IGFD.PPN                                 NOT SUPPORTED
.x job, user, and system information
.x <IGFD.PPN
--------
.s;Form of DEF:
.s.i+4;DEF INTEGER EXTERNAL IGFD.PPN
.s;Arguments:
.s.lm+4;None
.i-4.s;Results:
.f;.s;PPN of GFDed user as an integer.
.lm-4
.page;.nf;.s;IRUN.PPN                                 NOT SUPPORTED
.x job, user, and system information
.x <IRUN.PPN
--------
.s;Form of DEF:
.s.i+4;DEF INTEGER EXTERNAL IRUN.PPN
.s;Arguments:
.s.lm+4;None
.i-4.s;Results:
.f;.s;PPN of run from user as an integer.
The run from directory is the directory in which the running program is stored.
.lm-4
.page.nf
.subtitle         Job, User, and System Information                        30 August 1977
.x job, user, and system information
.x <IFTP
.s;IFTP                                     NOT SUPPORTED
----                             Beginning with Ver 3.3
.s;Form of DEF:
.s;.i4;DEF LOGICAL EXTERNAL SIMPL IFTP
.S;Arguments:
.s;.i4;None.
.s;Results:
.f;.s;.lm+4;IFTP returns TRUE if the user is Tymshare PROPRIETARY (IN-HOUSE),
else FALSE.
.nf;.lm-4;.page;
.subtitle         Job, User, and System Information                        30 August 1977
.x job, user, and system information
.x job number
.x <JOBNO
.s;JOBNO                                     SUPPORTED
-----                              Beginning with Ver 2.3
.s;Form of DEF:                            
.s;.i4;DEF INTEGER EXTERNAL JOBNO AKA  ".JOBNO"
.s;Arguments:
.s;.I4;None.
.s;Results:
.s;.i4;.f;Returns the integer-valued job number.
.s;Use:
.lm+4;.s;The job number is most often used to create file names that
are unique for temporary files.
.LM-4;.PAGE;.NF;
.subtitle         Job, User, and System Information                        30 August 1977
.x job, user, and system information
.x <SYSNO
.s;SYSNO                                   NOT SUPPORTED
-----                                Beginning with Ver 3.3
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL SIMPLE SYSNO
.s;Arguments:
.s;.i4;None.
.s;Results:
.s;.f;.lm+4;Returns the Tymshare system number of the computer being run.
.s;.I-4;Use:
.s;SYSNO is useful for programs that run on more 
than 1 system.
.lm-4;.page;.nf;
.subtitle         Dates                                                    13 May 1977
.x dates
.NF;.s;FILE.DATE                               SUPPORTED
---------                          Beginning with Ver 2.3
.s;Form of DEF: 
.s;.i4;DEF INTEGER EXTERNAL SIMPL FILE.DATE(STRING F)
.S;Arguments:
.x file >date comparisons
.s;.i4;F contains a file nomen.
.x file >nomen
.x creation dateile including seconds
.x dates
.x file >creation date
.s;Results:
.s;.lm+4;.f;Returns -1 if the file nomen is illegal or if the
specified file cannot be opened for input.
Otherwise returns the creation date of the file as an integer
in the following format:
days since Jan 1 1964 ,, seconds since midnight in Greenwich
time.
.s;.i-4;Use:
.s;FILE.DATE is useful for file date comparisons in which the
converted string representing the date in the user's time zone is
not needed (see DT.CNV) or in which a comparison needs to
be made that includes the time down to the second.
.x time zones
.x <Dt.cnv
.lm-4;.PAGE;.NF;
.x dates
.x <DAY.NO
.s;DAY.NO                                 NOT SUPPORTED
------                            Beginning with Ver. 3.3
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL DAY.NO(STRING YY.MM.DD)
.S;Arguments:
.s;.lm+4;.f;YY.MM.DD is a string of the form "YY/MM/DD" where
.list;.le;All characters other than the slashes must be numeric.
.le;The day number must be present but may have any positive value.
.le;The month number must be present but may have any value.
If MM is greater than 12, it is adjusted to be in the range 1-12
and the appropriate number of years is added to YY before YY
is validated.
.le;The year number must be present and must be either in the range 1964-2063 or in the
range 0-99.
Years 0 through 63 are interpreted as 2000 through 2063, and years
64-99 are interpreted as 1964-1999.
.els
.s.i-4;Results:
.s;DAY.NO returns an integer which is the number of days
since December 31, 1963 indicated by the input date string. 
If any error occurs, DAY.NO returns zero.
.s;.i-4;Use:
.s;DAY.NO converts dates from a string form to a numeric form.
.lm-4
.s;WARNING: DAY.NO arms and dis-arms the TRANSFORM ON-condition.
.x <TRANSFORM
.X On-condition
.page;.nf;
.subtitle         Dates                                                    13 May 1977
.x dates
.s;DT.CNV                                   SUPPORTED
------                            Beginning with Ver 2.3
.s;Form of DEF:                            
.s;.i4;DEF STRING EXTERNAL DT.CNV(INTEGER D)
.S;Arguments:
.s;.lm+4;.f;D is an integer representing a date in the following
format (returned by FILE.DATE):
days since Jan 1, 1964 ,, seconds since midnight in
.x dates
.x time zones
.x <FILE.DATE
Greenwich time.
.s;.i-4;Results:
.s;DT.CNV returns a 15 character string of the form 
.br;YY/MM/DD##HH:MM
.s;.i-4;Use:
.s;DT.CNV converts file dates into a form that is printable
and that can still be used to compare dates.
.lm-4;.PAGE;.NF;
.subtitle         File I/O                                                 13 May 1977
.x file <i/o
.x file <i/o
.x parsing file nomens
.x <file.parse
.s;FILE.PARSE                             SUPPORTED
----------                         Beginning with Ver 4.2
.s2;
.s;Form of DEF:                            
.s;.i4; DEF INTEGER EXTERNAL FILE.PARSE (STRING F,  _&
.i16;STRING A(*)) AKA "FL.PRS"
.S;
Arguments:
.p;.lm+4;.f;F is a string containing the file nomen (see TYMBASIC
.x file >nomen
Reference Manual).
.P;A is a string array in which will be returned the
components of the file nomen.
.p;
.i-4;Results:
.p;.f;FILE.PARSE returns zero if there are no syntactic
errors in the file nomen; otherwise, it returns the
error number.
The string array A is filled as follows:
.s;.nf;.lm+4;A(1) - username in parentheses or ppn in brackets
.i7;or null string
.x file >extension
.X username
.x file >name
.x extension
A(2) - file name, up to six characters, or "TERMIN" if the
.i7;file nomen specifies the terminal
A(3) - extension, up to three characters, including the
.i7;period if one appeared (else null string)
A(4) - confirmation, if any (else null string), including
.x confirmation
.x confirmation keyword
.i7;the hyphen, as four characters, "-NEW", "-ANY", or
.i7;"-EXI"
.s1;
.lm-4;
For example the file nomen "(Tba.user)Program.tba-e" would result in:
.lm+4;
.s
A(1) = "(TBA.USER)"
A(2) = "PROGRA"
A(3) = ".TBA"
A(4) = "-EXI"
.s
.lm-4
Note the upper case results.
.s2;
.i-4;Use:
.p;.f;The use of FILE.PARSE guarantees an error-free
.x file >nomen parse
file nomen parse that is identical to the one
used throughout TYMBASIC.
.lm-4;.page;.nf;
.SUBTITLE          File I/O                                                13 May 1977
.x file <i/o
.s;GET.UN                                   SUPPORTED
------                             Beginning with Ver 2.3
.s;Form of DEF:                           
.s;.i4;DEF INTEGER EXTERNAL GET.UN
.S;Arguments:
.s;.I4;None.
.s;Results:
.p;.lm+4;.f;Returns the first free TYMBASIC file unit number, or
zero if none are free.
.x file >unit number
.s;.i-4;Use:
.p;GET.UN is important in writing procedures
that must open a file but do not know which file unit
numbers are in use.
Example:
.p;.I4;135 OPEN F$+".DAT", BINARY INPUT, I WHERE I=GET.UN
.lm-4;.page;.NF;
.SUBTITLE         File I/O - Scanning a File Directory                          13 May 1977
.x file <i/o>scanning file directory
^&Overview of UFD SCAN package\&
.s;.F;
 This set of procedures is designed to scan a specified UFD (User File Directory) and return all
 occurences of a specified file name and extension, and optionally
 the file's size, creation date, license, and status. The file name
 and extension may include "wild carding" using "_#" for the character
 wild card, and "*" for the name or extension wild card.
 The UFD is not scanned in any particular order.
.x wild carding
.x <ufd <scan package, overview
.x <ufd
.x file >name

.x file >extension
.x file >size
.x dates
.x file >creation date
.nf.s
.x file >license
.x file >status
.x file >directory
.x username
 The procedures are:
.s1;.NF;
.x <FD.OPEN
.X <FD.WILD
.X <FD.EXACT
.X <FD.STEP
.X <FD.QUERY
.X <FD.NAME
.X <FD.EXT
.X <FD.SIZE
   FD.OPEN  - Open the UFD specified by the username.
.x username
   FD.WILD  - Specify file name and extension with 
              wild carding.
   FD.EXACT - Specify file name and extension without 
              wild carding.
   FD.STEP  - Advance to next file name.
   FD.QUERY - Did the last call to FD.STEP find another 
              file name?
   FD.NAME  - Return current file name.
   FD.EXT   - Return current file extension.
   FD.SIZE  - Return current file size.
   FD.LIC   - Return current file license.
   FD.DATE  - Return current file date and time.
   FD.STAT  - Return current file status.
   FD.SET   - Set buffer size and enable optional file values.
   FD.CLOSE - Close current UFD.
.X <FD.LIC
.X <FD.DATE
.X <FD.STAT
.X <FD.SET
.X <FD.CLOSE
.F;.S;All of these procedures are callable as EXTERNAL TBA procedures.
.s;.tp 30
.x file <i/o>scanning file directory
 The following artificial example may provide some insights:
.s.nf
   100 print "Directory: ":
   110 input in form "R": dir$
   120 if fd.open(dir$) then
   130   print "File name: ":
   140   input in form "R": fnam$
   150   if fnam$ _# "" then
   160     print "File extension: ":
   170     input in form "R": fext$
   180     call fd.wild(fnam$,fext$)
   190     if fd.step then
   200       tnam$ = fd.name
   210       text$ = fd.ext
   220       tsize = fd.size
   230       tlic = fd.lic
   240       tdate = fd.date
   250       tstat = fd.stat
                 .
                 .
.x file <i/o>scanning file directory
                 .
                 .
   390       go to 190
   400     endif
   410     go to 130
   420   endif
   430   call fd.close
   440 endif
   450 go to 100
.page;
.x file <i/o>scanning file directory
.NF;.s;FD.OPEN                                 SUPPORTED  
-------                            Beginning with Ver 2.3
.s;Form of DEF:                           
.s.i+4;DEF LOGICAL EXTERNAL FD.OPEN(STRING UFD.NAME)
.s;Arguments:
.s.lm+4;UFD.NAME is the name of the directory (username) to scan.
If it is null then the current directory is specified
(the directory GFD'ed to).
.x username
.x <gfd
.x file >directory
.x error condition
.i-4.s;Results:
.f;.s;FD.OPEN returns true if the directory was successfully opened
and false if the username is too long.
Any other error will cause a FILE error condition to occur on unit -9
(which can be trapped with an ON statement).
FD.OPEN prepares a UFD  for scanning, and enables
the routines FD.STEP, FD.QUERY, FD.NAME, FD.EXT, FD.SIZE, FD.LIC, FD.DATE
and FD.STAT (they return null values (false, zero, or 
null) until FD.OPEN has been successfully called).
.x <ON condition statement
.x file >unit number -9
.lm-4
.page;.NF;
.x file <i/o>scanning file directory
.S;FD.CLOSE                                  SUPPORTED 
--------                           Beginning with Ver 2.3
.s;Form of DEF:                           
.s.i+4;DEF EXTERNAL FD.CLOSE
.s;Arguments:
.s.i+4;None.
.s;Results:
.f;.s.lm+4;If a file directory has been successfully opened by FD.OPEN then
it is closed and all internal buffers are released. The routines
FD.STEP, FD.QUERY, FD.NAME, FD.EXT, FD.SIZE, FD.LIC, FD.DATE and FD.STAT
are disabled (will return null values) until FD.OPEN is again
successfully called.
.lm-4
.page;.NF;
.x file <i/o>scanning file directory
.S;FD.STEP                               SUPPORTED
-------                           Beginning with Ver 2.3
.s;Form of DEF:
.s.i+4;DEF LOGICAL EXTERNAL FD.STEP
.s;Arguments:
.s.i+4;None.
.s;Results:
.f;.s.lm+4;FD.STEP advances the file name scan to the
next specified file name and extension, if any.
Note that a call to FD.WILD or FD.EXACT does NOT locate the first match;
a call to FD.STEP must be made to do that.
FD.STEP will return true if another file name is found that matches the
name given to FD.WILD or FD.EXACT, otherwise it will return false.
.x <fd.wild
.x <fd.exact
.lm-4
.page;.NF;
.x file <i/o>scanning file directory
.S;FD.EXACT                                SUPPORTED
--------                         Beginning with Ver 2.3
.s;Form of DEF:
.s.i+4;DEF EXTERNAL FD.EXACT(STRING (FILENAME, EXTENSION))
.x file >name
.x file >extension
.s;Arguments:
.s.lm+4;FILENAME is the file name. It will be truncated to six
characters. EXTENSION is the extension. It will be truncated
to three characters.
.s.i-4;Results:
.f;.s;FD.EXACT specifies a file name and extension to be searched for
within the UFD. Special characters within the file name or extension
are taken literally so that non-standard file names can be found.
FD.EXACT does not find the file; FD.STEP must be used for that purpose.
.x <fd.step
.lm-4
.PAGE;.NF;
.x file <i/o>scanning file directory
.s;FD.WILD                                SUPPORTED
-------                          Beginning with Ver 2.3
.s;Form of DEF:
.s.i+4;DEF EXTERNAL FD.WILD(STRING (FILENAME,EXTENSION))
.S;Arguments:
.F;.s;.lm+4;FILENAME is the file name. It will be truncated to six characters.
EXTENSION is the extension. It will be truncated to three characters.
.s.i-4;Results:
.f;.s;FD.WILD specifies a file name and extension to be searched for within
the UFD. The wild card characters "_#" and "*" will match any character
and any file name or extension, respectively.
FD.WILD does not find the first match on the specified name; FD.STEP
.x wild carding
.x file >name
.x file >extension
.x <fd.step
must be used for that purpose.
.lm-4
.nf;.page
.x file <i/o>scanning file directory
.S;FD.QUERY                            SUPPORTED
--------                        Beginning with Ver 2.3
.s;Form of DEF:
.s.i+4;DEF LOGICAL EXTERNAL FD.QUERY
.s;Arguments:
.s.i+4;None.
.s;Results:
.f;.s.lm+4;FD.QUERY returns the value returned by the last call to FD.STEP
(or false if no call to FD.STEP has been made since the last
successful call to FD.OPEN).
Thus, FD.QUERY will return true if there is a match and false if not.
.x <fd.step
.s.i-4;Use:
.s;FD.QUERY is useful when the programmer wants
to know if file information is available without advancing to the next match.
.lm-4
.page;.NF;
.x file <i/o>scanning file directory
.S;FD.SET                               SUPPORTED 
------                          Beginning with Ver 2.3
.s;Form of DEF:
.s.i+4;DEF EXTERNAL FD.SET(INTEGER (BUFFER.LENGTH,CONTROL.CODE))
.s;Arguments:
.s;.f;.lm+4;BUFFER.LENGTH specifies the length to be used for the
UFD SCAN internal buffer.
If BUFFER.LENGTH is negative, then no change is specified. If it is zero
or one, then a length of 100 is specified.
.x <ufd <scan internal buffer
.p;When FD.STEP is initially called after a call to FD.OPEN, it asks
the monitor to fill its internal buffer with data describing the file
names which match the specified file name and extension.
The monitor only puts as many entries into the buffer as will
fit. When FD.STEP exhausts the data in that buffer, it requests another.
Each entry in the buffer takes two words plus one word for each of the
following if requested: size, date, license and status
(all four are requested unless the user specifies otherwise in this call).
.p;CONTROL.CODE specifies which data items are requested as follows:
.nf.lm+4
bit 32 - fetch file size (enable FD.SIZE) if 1
bit 33 - fetch license (enable FD.LIC) if 1
bit 34 - fetch date (enable FD.DATE) if 1
bit 35 - fetch status (enable FD.STAT) if 1
.x file >creation date
.x file >size
.x file >status
.x file >license
.fill.lm-4.s;If CONTROL.CODE is negative then no change is specified.
.s.i-4;Results:
.s;FD.SET sets the buffer length parameter and enables or 
disables the capture of certain data items for the next call to FD.WILD or FD.EXACT.
.s.i-4;Use:
.s;FD.SET is used in applications where core space or the overhead of making monitor calls
is critical.
If the buffer length is large, less monitor calls are made;
if less data items are requested, a smaller buffer will suffice.
.x core space
.x monitor calls
.lm-4
.PAGE;.NF;
.x file <i/o>scanning file directory
.s;FD.NAME                             SUPPORTED
-------                         Beginning with Ver 2.3
.s;Form of DEF:
.s;.i4;DEF STRING EXTERNAL FD.NAME
.S;Arguments:
.s;.i4;None.
.s;Results:
.lm+4;.p;If FD.QUERY would currently return TRUE then this function
returns the current file name. Otherwise, it returns a null string.
.x file >name
.lm-4;.PAGE;.NF;
.x file <i/o>scanning file directory
.s;FD.EXT                              SUPPORTED
------                          Beginning with Ver 2.3
.s;Form of DEF:
.s;.i4;DEF STRING EXTERNAL FD.EXT
.S;Arguments:
.s;.i4;None
.s;Results:
.x file >extension
.lm+4;.f;.s;If FD.QUERY would currently return TRUE then this function
returns the current file extension. Otherwise it returns a
null string.
.lm-4;.PAGE;.NF;
.x file <i/o>scanning file directory
.s;FD.SIZE                            SUPPORTED
-------                        Beginning with Ver 2.3
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL FD.SIZE
.S;Arguments:
.s;.i4;None
.s;Results:
.F;.lm+4;.s;If FD.QUERY would currently return TRUE 
then this routine returns the current file size
in blocks (unless FD.SIZE is disabled - see FD.SET). 
Otherwise, it returns  a minus one.
.lm-4;.PAGE;.NF;
.x file <i/o>scanning file directory
.s;FD.LIC                             SUPPORTED
------                          Beginning with Ver 2.3
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL FD.LIC
.s;Arguments:
.s;.i4;None.
.s;Results:
.s;
.lm+4;.f;If FD.QUERY would currently return TRUE 
then this routine returns the current file license 
(unless FD.LIC is disabled - see FD.SET).
Otherwise, it returns a minus one.
.x file >license
.lm-4;.PAGE;.NF;
.x file <i/o>scanning file directory
.s;FD.DATE                            SUPPORTED
-------                         Beginning with Ver 2.3
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL FD.DATE
.s;Arguments:
.s;.i4;None.
.s;Results:
.s;
.lm+4;.f;If FD.QUERY would currently return TRUE 
then this routine returns the current file date
and time in the following format:
days since Jan 1, 1964,,seconds since midnight in Greenwich time
(unless FD.DATE is disabled - see FD.SET).
Otherwise, it returns a minus one.
.lm-4;.PAGE;.NF;
.x file <i/o>scanning file directory
.s;FD.STAT                            SUPPORTED
-------                        Beginning with Ver 2.3
.s;Form of DEF:
.s;.I4;DEF INTEGER EXTERNAL FD.STAT
.s;Arguments:
.s;.i4;None.
.s;Results:
.s;
.nf
.fill
.lm+4;If FD.QUERY would currently return TRUE then this routine returns the
file status as below (unless FD.STAT is disabled - see FD.SET).
Otherwise, it returns a minus one.
.nf;.s;
          bits 26-35 = file protection
          bits 23-26 = bits 8-11 from extended lookup word 14
          bits 19-22 = bits 4-7 from extended lookup word 14
          bits 17-18 = bits 2-3 from extended lookup word 14
          bits 15-16 = bits 0-1 from extended lookup word 14
.x file >protection
.x file >temporary bit
.x file >dumped bit
.x file >lookup
.s;.i-4;Use:
.f;.s;Bit 4 from extended lookup word 14 is the "file dumped" bit
and indicates that the file has been written to backup tape.
.s;Bit 8 is the "file temporary" bit and indicates that the file
will be automatically deleted upon GFD or LOGOUT.
.s;The protection is a 9-bit field consisting of three three-bit
codes.
The first applies to the user himself, the second to all
users in the same account, the third to any user.
.s;The codes are:
.s;.nf;    0    ALL
    1    CP
    2    UFD
    3    AP
    4    RD
    5    RUN
    6    LK
    7    NO
.s;.f;See File Protection in the Tymshare XEXEC manual for a 
description of each of these codes.
.lm-4;.page;.nf;
.subtitle         Array Operations                                         13 May 1977
.x array operations
.s;ARRAY.BOUNDS                              SUPPORTED
------------                        Beginning with Ver 2.4
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL ARRAY.BOUNDS(*) _&
.I8;(type A(*,*,...)) AKA "BND.AR"
.x arrays >bounds
.x bounds of an array
.x dimension of an array
.lm+4;.S;.f;For the word "type" the user should substitute the
type of the array he wishes to pass to ARRAY.BOUNDS.
.x procedures
He should also specify the number of dimensions of the
array by including the proper number of asterisks as shown
above.
.p;To pass arrays of differing types or
dimensionalities to ARRAY.BOUNDS the module should contain
one DEF for each needed type/dimensionality combination
with a unique procedure name but containing identical
AKA clauses.
For example:
.s;.nf;DEF INTEGER EXTERNAL INT.BOUNDS.1(*)(INTEGER A(*)) AKA "BND.AR"
DEF INTEGER EXTERNAL REAL.BOUNDS.2(*)(REAL A(*,*)) AKA "BND.AR"
.S;.i-4;Arguments:
.s;A is any array.
.s;.i-4;Results:
.f;.s;ARRAY.BOUNDS returns a one-dimensional integer array that
contains one element for every dimension of the argument array.
Each element contains the bounds pair for that dimension:
the lower bound in the left half of the integer, the upper
bound in the right half.
.x bounds pairs of an array
.s;.i-4;Use:
.s;ARRAY.BOUNDS is useful in procedures that expect an array
argument but do not know the bounds.
.p;To extract the bounds pairs:
.s;.nf;.lm+4;INTEGER BOUNDS(1:N) !N is the dimensionality
BOUNDS = INT.BOUNDS.1(SOME.INT.ARRAY)
LOWER.BOUND.1 = RSH(BOUNDS(1), 18)
UPPER.BOUND.1 = BOUNDS(1) BAN 777777B
.lm-4;.page;.NF;
.subtitle         Half-word Manipulation                                    2 June 1977
.x half-word manipulation
.S;.NF;^&RH\&                         NOT SUPPORTED
.s;Form of DEF:
.s;    DEF INTEGER EXTERNAL SIMPL RH(INTEGER I) AKA ".RH"
.S;Arguments:
.s;.i4;I is any integer.
.s;Results:
.lm+4;.s;.f;RH returns the right half-word of I as an integer.
This is bits 18-35 in DEC terminology.
The left half of the result is always zero.
.lm-4;.page;.NF;
.x half-word manipulation
.nf;.s;^&LH\&                           NOT SUPPORTED
.s;Form of DEF:
.s;    DEF INTEGER EXTERNAL SIMPL LH(INTEGER I) AKA ".LH"
.S;Arguments:
.s;.i4;I is any integer.
.s;Results:
.lm+4;.s;.f;LH returns the left half-word of I as an integer.
This is bits 0-17 in DEC terminology. 
The left half of the result is always zero.
.lm-4;.page;.nf;
.x half-word manipulation
^&XWD\&                                NOT SUPPORTED
.S;Form of DEF:
.s;    DEF INTEGER EXTERNAL SIMPL XWD(INTEGER (I,J)) AKA ".XWD"
.s;Arguments:
.s;.i4;I and J are integers.
.s;Results:
.lm+4;.s;.f;XWD returns an integer whose left half-word is the right
half-word of I and whose right half-word is the right half-word
of J.
The left half-words of I and J are ignored.
.lm-4
.nj
.flag cap
.subttl	Extended Escape Control
.page
.x Extended Escape Control
.center
^&Extended Escape Control\&
.p
The following three routines have been added to the User Function Library for the
purpose of extending the user's escape control, specifically
to give the user the ability to temporarily disable escapes.
.page
.subttl	Extended Escape Control
.nf
.p
^&<disable\&################################<supported
.x <DISABLE
#################################Beginning with Ver 4.5
.fill
.p
Form of <def:
.lm +5
.p
<def <external <disable <aka "<.disable"
.lm -5
.p
Arguments:
.lm +5
.p
None.
.lm -5
.p
Results:
.lm +5
.p
<disable disables escapes and increments an internal cell whose
initial value is zero. The internal cell is used for communication
between <disable, <enable, and <cenable.
.x <ENABLE;.x <CENABLE
.p
Whenever escapes have been disabled by <disable, any escapes that
occur will be ignored. They will, however, be remembered and
will take effect as soon as <enable or <cenable
re-enables escapes.
.lm -5
.page
.subttl	Extended Escape Control
.nf
.p
^&<enable\&##################################<supported
.x <ENABLE
#################################Beginning with Ver 4.5
.fill
.p
Form of <def:
.lm +5
.p
<def <external <enable <aka "<.enable"
.lm -5
.p
Arguments:
.lm +5
.p
None.
.lm -5
.p
Results:
.lm +5
.p
<enable decrements an internal cell which is incremented by <disable.
.x <DISABLE
If the value of the decremented cell is less than or equal to zero
then <enable zeroes the cell and re-enables escapes. Any escapes
which were not honored because of a previous call to <disable will
occur at this time.
.lm -5
.page
.subttl	Extended Escape Control
.nf
.p
^&<cenable\&#################################<supported
.x <CENABLE
#################################Beginning with Ver 4.5
.fill
.p
Form of <def:
.lm +5
.p
<def <external <cenable <aka "<.cenable"
.lm -5
.p
Arguments:
.lm +5
.p
None.
.lm -5
.p
Results:
.lm +5
.p
<cenable zeroes the internal cell used by <disable and <enable and
.x <DISABLE;.x <ENABLE
then re-enables escapes. Any escapes which were not honored because
of a previous call to <disable will occur at this time.
.lm -5
.page
.SUBTITLE         FORTRAN string conversion
.x <FORTRAN string conversion
.s;.nf;^&F.CHR\&			NOT SUPPORTED
.x <F.CHR
.s;Form of DEF:
.s;	DEF STRING EXTERNAL F.CHR(INTEGER I)
.s;Arguments:
.s;.i4;I is an integer containing a FORTRAN string.
.s;Results:
.s;.i4;F.CHR returns a TBA string of 5 or fewer characters.
.s;Use:
.fill
.s;.lm+4;F.CHR is useful in converting a FORTRAN string of 5 or fewer
characters to a TBA string.
.lm-4
.page
.x <FORTRAN string conversion
.s;^&F.ASC\&			NOT SUPPORTED
.x <F.ASC
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL F.ASC(STRING S)
.s;Arguments
.s;.i4;S contains a TBA string.
.s;Results:
.s;.lm+4;F.ASC returns an integer containing a FORTRAN string coresponding
to the first five characters of S. If S contains less than five
characters, it is padded on the right with spaces.
.lm-4
.s;Use:
.s;.lm+4;F.ASC is useful in converting a TBA string of 5 or fewer
characters to a FORTRAN string.
.lm-4
.page
.x <FORTRAN string conversion
.s;^&F.CHRA\&			NOT SUPPORTED
.x <F.CHRA
.s;Form of DEF:
.s;.i4;DEF STRING EXTERNAL F.CHRA(INTEGER K(*))
.s;Arguments:
.s;.lm+4;K is an integer array of one dimension which
contains a FORTRAN string.
.lm-4
.s;Results:
.s;.i4;F.CHRA returns the coresponding TBA string.
.s;Use:
.s;.lm+4;F.CHRA is useful in converting FORTRAN strings that may be
longer than 5 characters to a TBA string.
.lm-4
.page
.x <FORTRAN string conversion
.s;^&F.ASCA\&			NOT SUPPORTED
.x <F.ASCA
.s;Form of DEF:
.s;.i4;DEF INTEGER EXTERNAL F.ASCA(*)(STRING S)
.s;Arguments:
.s;.i4;S is a TBA string of any length.
.s;Results:
.s;.lm+4;F.ASCA returns a integer array of one dimension
that contains the coresponding FORTRAN string.
.lm-4
.s;Use:
.s;.lm+4;F.ASCA is useful in converting a TBA string of any length
to a FORTRAN string.
.lm-4
.page
.subtitle         Fast Sorter
.x Fast Sorter
.x <sort
^&SORT\&#############################NOT SUPPORTED
.skip
Form of def:
.skip
.indent
Def Integer External Sort(*)(integer n.recs)
.skip
Arguments:
.indent+5
n.recs is the number of records to be sorted
.skip
Results:
.skip
.lm+5
return an integer array containing a sorted list of record numbers.
.lm-5
.skip
User-Supplied Procedure:
.skip
.lm+5
Sort refers to a user-supplied procedure with the following def:
.indent 3
.x <CMPARE
DEF INTEGER EXTERNAL CMPARE(INTEGER(P1,P2))
.break
when CMPARE is called, P1 and P2 will be in the range 1 through N.RECS.
The procedure CMPARE must compare record P1 with
record P2, using whatever compare algorithm is suitable for this
sort, and return an intger -1,0, or 1 depending on whether
record P1 is less than, equal to, or greater than record P2.
.lm-5
.skip
Use:
.skip
.lm+5
This routine uses a very fast sort algorithm, and,since the compare
is written by the user for his particular records, it can handle
records of any complexity whatever without having to resort to an
obscure command language.
.lm-5
.skip
Example:
.skip
.nf
10 ! sample driver for the in-core quickersort.
20 !
30 ! We sort employees by month of review date and by name.
40 !
50 def integer external sort(*) ( integer n.recs)
100 data Frank, Nov
110 data John, Oct
120 data Carl, Jan
130 data Mike, Jun
140 data Lee, Jan
150 data Allen, Dec
160 data Karen, Dec
170 data Polle, Jun
180 data Dick, Dec
190 data Don, Feb
200 !
210 integer i, num.records
220 num.records = 9
230 integer sorted( num.records)
240 string field1(num.records), field2(num.records)
250 read field2(i), field1(i) for i=1 to num.records
260 sorted = sort( num.records)
270 print field1(sorted(i)), field2(sorted(i)) for i=1 to _&
.i+5;num.records
280 stop
290 !
300 !
310 def integer entry scomp( integer ( p1, p2)) aka "CMPARE"
320   integer result
330   ! = = = = !
340   result = comp( field1(p1), field1(p2))
350   if result#0 then exit result else exit comp(field2(p1) _&
.i+7;,field2(p2))
360 endf scomp
.f
.page
.subtitle         Index                                                     26 May 1977
.DO index
  7@p)