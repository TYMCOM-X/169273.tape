


                                TABLE OF CONTENTS




          SECTION 1. INTRODUCTION                                   1
                  1.1.  The Language                                1
                  1.2.  The Manual                                  2


          SECTION 2.  SYSTEM CONCEPTS                               3
                  2.1.  Modules and Programs                        3
                             Modules                                3
                             Workspace Module                       3
                             Libraries                              3
                             Programs                               4
                  2.2.  Language Elements                           5
                  2.3.  Commands and Statements                     6
                             Format                                 6
                             Line Continuation                      6
                             Remarks                                6
                             Commands                               7
                             Statements                             7
                                  Indirect                          7
                                  Direct                            8
                                  Statement Modifiers               8
                             Statement Type Tables                  9
                             Command Type Tables                    12


          SECTION 3. DATA                                           14
                  3.1.  Type                                        14
                             Numeric Data                           14
                             String Data                            14
                             Logical Data                           14
                  3.2.  Type Conversion                             15
                  3.3.  Class: Scalars and Arrays                   15
                  3.4.  Constants                                   16


          SECTION 4.  NAMES                                         18
                  4.1.  Identifiers                                 18
                  4.2.  Types for Identifiers                       19
                  4.3.  File Nomens                                 20


          SECTION 5.  VARIABLES                                     23
                  5.1.  Class and Type                              23
                  5.2.  Initial Value                               23

      


                  User-Defined Variables

                  5.3.  Declarations for Variables                  24
                             Array Declaration                      24
                             Duplicate Declarations                 24
                             Syntax                                 24
                             Implicit Declarations                  25
                  5.4.  Array Elements                              25
                  5.5.  Subarrays                                   25
                             Syntax                                 26
                             Semantics                              26
                             The NAME statement                     27

                  System-Defined Variables

                  5.6.  System-Defined Variables                    28
                             System-Defined Scalar Variables        28
                             System-Defined Array Variables         28


          SECTION 6.  EXPRESSIONS                                   30
                  6.1.  General                                     30
                  6.2.  Operator Precedence                         30
                  6.3.  Conversion of Types in Expressions          31
                  6.4.  Arithmetic Operators                        32
                  6.5.  Matrix Operators                            33
                  6.6.  Bitwise Operators                           34
                  6.7.  Relational Operators                        35
                  6.8.  Boolean Operators                           36
                  6.9.  String Operators                            37
                  6.10. Array Expressions                           38


          SECTION 7.  PROCEDURES                                    39
                  7.1.  Class and Type                              39

                  User-Defined Procedures

                  7.2.  EXTERNAL and ENTRY (Global) Procedures      39
                             Other-language EXTERNAL Procedures     41
                             The AKA clause in the DEF statement    41
                  7.3.  Declarations for Procedures and Parameters  42
                             Syntax                                 42
                             Semantics                              43
                             Parameters for EXTERNAL Procedures     44
                  7.4.  Passing Arguments to Procedures             44
                             Number of Arguments                    45
                             Passing Arguments by Name and Value    45
                             Type Conversion of Arguments           45
                             Array Parameters                       46
                  7.5.  Context, Scope, Local Variables and Procedures 46
                             Nested Procedures                      47
      


                             Preservation of Values Across Calls    47
                  7.6.  Procedure Value: Exiting from a Procedure   47
                  7.7.  I/O Within a Procedure                      47

                  System-Defined Procedures

                  7.8.  Table of System-Defined Procedures          48
                            Trigonometric Functions                 48
                            Exponential Functions                   49
                            Complex Functions                       49
                            Numeric Functions                       50
                            MAX and MIN Functions                   51
                            SUM and PROD Functions                  51
                            Matrix and Array Functions              52
                            Shifting Functions                      53
                            String Functions                        54
                            Utility Functions                       56


          SECTION 8.  EXECUTION                                     57
                  8.1.  Overview                                    57
                  8.2.  Command/Statement Phase                     59
                  8.3.  Compilation Phase                           60
                  8.4.  Load/Initialize Phase                       63
                  8.5.  Run Phase                                   64
                  8.6.  Command Files                               66


          SECTION 9.  STATEMENTS                                    68
                  9.1.  Statement Descriptions, Alphabetically      69
                  9.2.  Statement Modifiers                         100


          SECTION 10.  COMMANDS, ALPHABETICALLY                     103


          SECTION 11.  FILE MANAGEMENT                              122
                  11.1.  Introduction                               122
                  11.2.  File Attributes                            122
                             Mode                                   122
                             Protection                             123
                             Type                                   123
                             Access Method and Record Length        125
                             Random Access Files                    125
                             Sequential Files                       126
                  11.3.  Location and Position                      126
                             Location                               126
                             Position                               126
                             Carriage Returns and End of Record     127
                  11.4.  The Terminal As a File                     127
                             General                                127
                             Program Activation Characters          128
      


                  11.5.  Random-Access Operations                   128
                             Erasing Part of a File                 128
                             Changing Location                      129
                             Record Boundaries                      130
                             Example                                135


          SECTION 12.  FORMATTING                                   137
                  12.1.  Introduction                               137
                             Terminal Output                        138
                             Output of Nul Characters               138
                             Array Input and Output                 138
                             Input and Output of Carriage Returns   138
                             Definitions                            139
                  12.2.  Free-Form Formatting                       140
                             Input                                  140
                             Output                                 140
                             Joining Input and Output               142
                             Conversion Characteristics             143
                  12.3.  IMAGE Formatting                           145
                             Long and Short Format Fields           145
                             Numeric Fields                         146
                             String Fields                          147
                             Free-Form Image                        147
                             Literal Text                           148
                             End of Image                           149
                  12.4.  FORM formatting                            150
                             Formatting Characters                  151
                             String Characters                      156
                             Numeric Characters                     157
                             Floating Characters                    161
                             Utility Characters                     164
                             Replication                            165
                             FORM Input                             167
                             FORM Output                            168
                             Treatment of Eor's                     169


          APPENDIX A    Reserved Words                              170
          APPENDIX B    RUN-Phase Error Messages                    171
          APPENDIX C    Intraline Editing                           175
          APPENDIX D    XASC and IXASC Character Codes              187
          APPENDIX E    EXTERNAL Procedures                         189
          APPENDIX F    Internal Array Handling                     198
          APPENDIX G    Automatically Generated Files               202


          INDEX
      TYMBASIC REFERENCE MANUAL        INTRODUCTION                  Page 1
      1 January 1978                                                 Sec. 1.1


                            SECTION 1.  INTRODUCTION



      This manual is intended as a specification of and reference for the
      TYMBASIC language implemented on the Tymcom X systems.


      1.1 THE LANGUAGE      ___ ___ ________


      TYMBASIC comprises a set of statements, commands, and functions,
      incorporating most of the Basic language extensions found in
      SUPERBASIC-IX, as well as many features unique to this
      implementation.

      Features common to both languages include:

              * direct and indirect statements
              * string manipulation statements and functions
              * logical, integer, double precision, and
                 complex arithmetic
              * extensive formatting capability
              * built-in editing
              * random access files
              * binary files
              * command files

      Features unique to TYMBASIC include:

              * compilation, rather than interpretation
              * identifiers up to 15 characters
              * user-defined procedures
              * extended program control structures
              * subarray naming and manipulation
              * relocatable object programs
              * calls to non-TYMBASIC subroutines
              * non-ASCII collating capability
      TYMBASIC REFERENCE MANUAL        INTRODUCTION                  Page 2
      1 January 1978                                                 Sec. 1.2


      1.2 THE MANUAL      ___ ___ ______


      Specifications of all statements and commands are presented in
      Sections 9 and 10, respectively, with each section arranged
      alphabetically.  Other sections discuss more general topics, often
      exemplifying effective usage of the statements and commands.  The
      index may aid the user in bringing together the specification of a
      particular language element with a discussion of its areas of
      application.

      Conventions used in the presentation are:

            * Words shown in upper-case are keywords;  words in lower-case
              are generic terms describing a field to be filled by the
              user.  For example:

                   DATA text

              The keyword DATA is to be entered, followed by any text.

            * Braces indicate alternatives;  brackets indicate options.
              For example:

                    GOTO
                   GO TO line number

              Either GOTO or GO TO may be used.

                   EXIT [expression]

              An expression following the EXIT is optional.

                   NO TRACE [ variable list ] [ line range list]

              The command NO TRACE may be followed by a variable list
              and/or a line range list or by nothing at all.

            * Three dots (...) indicate that one or more repetitions of the
              preceding element are allowed.  For example:

                   NEXT iteration variable [,iteration variable ...]

              NEXT may be followed by more than one iteration variable,
              with each separated by a comma from the one preceding.

      Generic terms (such as iteration variable) are defined in text
      immediately following the usage.
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS               Page 3
      1 January 1978                                                 Sec. 2.1


                           SECTION 2.  SYSTEM CONCEPTS


      2.1 MODULES AND PROGRAMS      ___ _______ ___ ________

      MODULES      _______

      A module is a collection (often a file) of procedures and a main
      program.  There are two kinds of modules:  source modules, which
      contain the symbolic text of the module in the language the module
      was written (e.g., TYMBASIC, FORTRAN, MACRO) and relocatable modules,
      which are derived from source modules by compilation (or assembly in
      the case of MACRO).  Relocatable modules may be loaded together to
      form an executable program.

      A source module may be changed or edited and then compiled to create
      a new relocatable module corresponding to the new source module.

      The difference between the two kinds of modules is normally reflected
      by the file extension of the module.  For example, PROG.TBA would be
      a source module and PROG.REL would be its corresponding relocatable
      module (or PROG.RDL if the module contains debugging information).
      The file name (e.g., PROG) is considered to be the name of the
      module, whether it be source or relocatable.

      WORKSPACE MODULE      _________ ______

      A source module may be a collection of TYMBASIC statements contained
      in the user's TYMBASIC workspace.  The workspace module may be edited
      using TBA editing commands and it may be saved as a file (using the
      SAVE command).  If saved, the workspace is associated with the file
      and the two are known by the same name (called the workspace name).
      Any operation that names the workspace associates the workspace with
      a file (for example, loading statements into the workspace with the
      GET command).

      LIBRARIES      _________

      A library is a file that contains a collection of relocatable
      modules.  It may also contain an index to the procedures contained
      within those modules.

      If a library has been specified by the use of the LIBRARY command, it
      is searched during the creation of a program.  Only those modules                                                     ____
      that contain procedures needed by the rest of the program are taken
      from the library and made part of the program.
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS               Page 4
      1 January 1978                                                 Sec. 2.1


      PROGRAMS      ________

      Each TYMBASIC program is composed of several relocatable modules, as
      follows (see also Execution, Sec. 8):

           1.  If the module list is empty, the workspace module.

           2.  If the module list is not empty, every module in the module
               list.  The workspace may be added to the module list.

           3.  Modules extracted from the libraries specified in the user's
               library list, as needed by the rf the program.

           4.  Modules from the TYMBASIC library and other system libraries
               that form the environment of the program or that are needed
               by the rest of the program (the SIN routine, for example, if
               called).


      One of the modules in the first or second group is called the
      startpoint module;  it contains the starting point for the program,
      similar to a Fortran MAIN program.  The default startpoint module is
      the workspace (or a direct statement if one was entered).  The
      STARTPOINT command is used to specify a different startpoint module.
      In the general case the startpoint module will make procedure calls
      to procedures located within the other modules.

      Note that since modules are independently compiled, the line numbers
      and variable names of one module are not known outside that module;
      only global procedures are known to other modules (see Sec. 7.2).
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS               Page 5
      1 January 1978                                                 Sec. 2.2


      2.2.  LANGUAGE ELEMENTS      ____  ________ ________


      The TYMBASIC language consists of the following language elements:


           Language Element                        See
           ----------------                        ---

           Line Numbers                            Sec. 2.3
           Identifiers                             Sec. 4.1
           File Nomens                             Sec. 4.3
           Constants                               Sec. 3.4
           Remarks (comments)                      Sec. 2.3
           Operators                               Sec. 6
           Line Continuation Charactes             Sec. 2.3
           Terminal End-of-File Characters         Sec. 8.6
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS               Page 6
      1 January 1978                                                 Sec. 2.3


      2.3 COMMANDS AND STATEMENTS      ___ ________ ___ __________

      TYMBASIC is called by the XEXEC command TBA.  Thereafter, TYMBASIC
      commands and statements can be entered.

      FORMAT      ______

      Commands and statements may contain up to 256 characters, counting
      line numbers and spaces (but not including the carriage return or
      line feed at the end).  Control characters are not allowed within
      commands or statements.  At least one space must be entered between
      adjacent alphanumeric language elements to avoid ambiguity, but
      non-alphanumeric elements do not require space character separators:

              10 A=B+C

      is equivalent to

              10 A = B + C

      Command and statement input is terminated by typing a carriage
      return.

      LINE CONTINUATION      ____ ____________

      Input that exceeds the user's terminal line length may be continued
      by typing an ampersand and a carriage return.  Any number of lines
      may be entered up to the 256 character limit (the line continuation
      itself counts as one character).  Lines may be split between any two
      language elements.  For example:

              >10 let a(val(substr(f$,n,m-n),p$+"%")) = &
                       b(n,sum(c(i) for i=1 to m) div &
                       x mod (yZ)
              >20 !Whew


      REMARKS      _______

      An exclamation point that does not appear within a quoted string or
      in a DATA statement delineates the beginning of a comment or remark
      in a command or statement.  The comment continues to the end of the
      command or statement.  In a statement, the comment will print with
      the source module listing but will have no effect on module
      execution.  The REM statement (REMark) has a similar effect, but can
      only be used at the beginning of the line.
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS               Page 7
      1 January 1978                                                 Sec. 2.3


      Examples:

              > !This is a comment
              >20 REM so is this
              >30 A = B !The rest is comment
              >40 B = C REM But this is an error.
              ERROR   ...NEAR 'B = C? REM'

      COMMANDS      ________

      Commands are executed immediately.  They are not made part of the
      workspace module and do not require a compilable module in the
      workspace in order to execute, as do statements.  Commands may not
      contain expressions.  For example:

              -tba
              Ver. 4.0
              >get trial.tba
              >library (tbatlib)tlib
              >run

      The GET, LIBRARY and RUN commands above are executed immediately, and
      they are not stored in any file.

      STATEMENTS      __________

      Statements are the basic components of the TYMBASIC language.  There
      are two kinds of statements:  indirect statements and direct
      statements.  Every statement is checked for syntactic correctness
      immediately after it is entered into TYMBASIC.

      Indirect Statements      ________ __________

      Statements may be grouped together to form a module.  These
      statements are called indirect statements because execution of them
      does not occur until the module is loaded into a program and run.  In
      this case, each statement is preceeded by a line number.  The line
      numbers determine the order of the statements within the module, and
      must be unsigned integers not exceeding 99999.  A TYMBASIC source
      module may contain up to 16,000 indirect statements.  For example:

              -tba
              Ver. 4.0
              >get trial.run
              >15 let a=21

      The LET statement is inserted into the workspace module TRIAL.RUN
      according to the statement number (for instance, between statements
      10 and 20, possibly replacing a previously existing line 15).  The
      statement will become part of the version of TRIAL.RUN stored on a
      file only if the workspace is written back out to the file by a SAVE
      command.  All TYMBASIC statements may be used indirectly.
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS               Page 8
      1 January 1978                                                 Sec. 2.3


      Direct Statements      ______ __________

      If a statement is entered without a line number it is immediately
      compiled as a module in itself, loaded with the rest of the program,
      and executed.  The direct statement does not become part of the
      workspace module.  It is, however, compiled and executed in the
      context of the workspace module (see Sec. 7.5).  Therefore, it may
      operate on variables and call procedures defined in the workspace
      module and it may also call procedures defined as EXTERNAL by the
      workspace module.  For example:

              -tba
              Ver. 4.0
              >get trial.run
              >let a=21
              >start

      The workspace variable A is set to 21 by the LET statement before the
      START command causes execution of the program to begin (see also
      Section 8, Execution).  The LET statement is not part of the module
      TRIAL.RUN.

      Not all statements may be entered directly (see Statement Types,
      below).


      Statement Modifiers      _________ _________

      Most statements may include statement modifiers, which appear to the
      right of the statement body.  The modifiers can cause iterative or
      conditional execution of the statement and can also assign certain
      values to variables prior to execution of the statement body.  See
      Sec. 9.2.  Examples:


              10 PRINT A(I) FOR I = 1 TO 10
              20 OPEN F$, INPUT, J WHERE J = GET.UN
              30 CALL FUNC(I) WHILE I<X-Y
              40 PRINT FUNC(I) FOR I = J TO 100 WHERE J = FUNC2(X)
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS               Page 9
      1 January 1978                                                 Sec. 2.3


      STATEMENT TYPES      _________ _____

      The following table groups TYMBASIC statements by function.  Those
      statements that may not be entered directly are indicated by the
      appearance of an "X" in the right-hand column.  Each statement is
      described fully in Section 9.1, where they are listed in alphabetical
      order.

      Note that some statements appear in more than one group.  For
      instance, COPY appears in the Utility group because it can copy one
      file to another;  it also appears in the IO group because it can copy
      a file to/from the terminal.
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS              Page 10
      1 January 1978                                                Sec. 2.3


                                 I/O  STATEMENTS

          Statement               Effect                      Indirect Only

            CIB         clears terminal input buffer
            CLOSE       closes files
            COB         clears terminal output buffer
            COPY        copies files (including terminal)
            DATA        supplies data values                       X
            EIGHTI      reads eight-level terminal input
            EIGHTO      sends eight-level terminal output
            ERASE       erases parts of files
            INPUT       inputs from terminal or file
            LOCATE      sets location on file
            LOL         sets line length
            OPEN        opens file
            PRINT       prints at terminal or file
            READ        reads from DATA statements
            REMOVE      deletes file
            RESTORE     resets pointer to top of DATA block
            WRITE       same as PRINT



                           PROGRAM CONTROL  STATEMENTS

          Statement             Effect                        Indirect Only

            ELSE      begins alternate statement group              X
            END       stops execution (same as STOP)                X
            ENDIF     ends extended IF statement                    X
            FOR       begins loop                                   X
            GOTO      transfers control to statement
            IF        begins conditional statement
            LOG       stops session
            NEXT      ends FOR loop                                 X
            NO        cancels ON condition
            ON        transfers control on condition or value
            ORIF      starts alternate statement group              X
            PAUSE     interrupts execution                          X
            QUIT      transfers to XEXEC
            RESUME    resumes execution after ON condition
            STOP      stops execution (same as END)                 X
            WAIT      suspends execution for a period of time       X
                      or until the output buffer is empty



      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS              Page 11
      1 January 1978                                                Sec. 2.3


                             SUBPROGRAM  STATEMENTS

          Statement             Effect                      Indirect Only

            CALL        calls procedures
            DEF         defines procedures                          X
            ENDF        ends procedure definition                   X
            EXIT        returns from procedures
            GOSUB       transfers to subroutines
            RETURN      returns from subroutines



                        VARIABLE MANIPULATION  STATEMENTS

          Statement            Effect                       Indirect Only

            LET         optional assignment statement prefix
            MAT         optional matrix (array) prefix



                        VARIABLE  DECLARATION  STATEMENTS

          Statement            Effect                        Indirect Only

           COMPLEX    declares complex variables                    X
           DIM        declares variables                            X
           DOUBLE     declares double precision real variables      X
           INTEGER    declares integer variables                    X
           LOGICAL    declares logical variables                    X
           NAME       declares subarrays                            X
           REAL       declares real (single precision) variables    X
           STRING                                                   X
           or TEXT    declares string variables                     X



                               UTILITY  STATEMENTS

          Statement            Effect                         Indirect Only

           BASE          changes array default lower bound
           BOUNDARY      sets minimum values for free
                         form output
           COPY          copies files
           ERASE         erases parts of open files
           MAT           optional matrix (array) prefix
           NO            cancels ON condition
           REM           remarks (comments)
           REMOVE        deletes file
           RENAME        changes file name
           SIGNIFICANCE  sets # digits for free-form output
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS              Page 12
      1 January 1978                                                Sec. 2.3


      COMMAND TYPES      _______ _____

      The following table groups TYMBASIC commands by function.  Each
      command is described fully in Section 10, where they are listed
      alphabetically.



                                CONTROL  COMMANDS

          Command            Effect

           BREAK         sets lines for execution interrupt
           DO            executes a command file
           GO            resumes interrupted execution
           LOG           stops session
           INITIALIZE    compiles, loads and initializes program
           QUIT          transfers to XEXEC
           RUN           compiles, loads, initializes, initiates execution
           START         initiates execution, without initializing
           STEP          executes specified number of statements



                               DEBUGGING  COMMANDS

          Command            Effect

           BREAK         sets lines for execution interrupt
           CDE           prints code generated
           DEBUG         sets diagnostic features on
           DUMP REFS     saves cross reference information
           PMC           prints intermediate code from parser
           SYMD          prints compiler variable definition
           TRACE         traces execution of lines or variables



                                EDITING  COMMANDS

          Command           Effect

           DELETE        deletes lines
           EDIT          prints line, allows editing
           MODIFY        allows editing but does not print line first
           RENUMBER      renumbers lines in workspace
      TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS              Page 13
      1 January 1978                                                Sec. 2.3


                                UTILITY  COMMANDS

          Command           Effect

           DLIST         lists workspace, with name, date and time
           ECHO          echoes input characters to TOUT destination
           ENTER         gets statements from command source, supplies #s
           GET           loads statements into workspace
           LIBRARY       adds files to library list
           LIST          list lines from workspace, or lists status
           MERGE         merges statements from file into workspace
           MODULE        adds files to module list
           RENUMBER      renumbers lines in workspace
           SAVE          stores workspace on file
           SAVE BINARY   stores program as executable file
           TABS          sets tab stops
           TOUT          specifies terminal output (TOUT) destination

      TYMBASIC REFERENCE MANUAL          DATA                       Page 14
      1 January 1978                                                Sec. 3.1


                                SECTION 3.  DATA


      3.1.  TYPE      ____  ____

      There are three groups of data types within TYMBASIC:  numeric,
      string, and logical.


      NUMERIC DATA      _______ ____

      Numeric data includes integers (type INTEGER), single-precision real
      numbers (type REAL), double-precision real numbers (type DOUBLE), and
      complex numbers (type COMPLEX).

      INTEGERS are represented as 1 word (36-bit) exact-precision
      quantities, with the range:

              -34,359,738,367 through +34,359,738,367 

      REALS (single-precision) are 1-word floating-point quantities with
      precision through 7 decimal digits.  Range:

              -10**38 through -10**-38, 0, +10**-38 through +10**38

      DOUBLES (double precision) are 2-word floating-point quantities with
      precision through 18 decimal digits.  The range is the same as for
      reals.

      COMPLEX numbers are represented as a pair of reals, the first
      representing the real part, the second the imaginary part.


      STRING DATA      ______ ____

      A string (type STRING) is a sequence of from 0 to 4095 characters.
      Each character has a 7-bit value (a range of 0 to 127) and can be
      interpreted as a character in the ASCII character set.


      LOGICAL DATA      _______ ____

      A logical data item (type LOGICAL) may have only the values TRUE (+1)
      or FALSE (0).  It is represented as a 1-word integer.
      TYMBASIC REFERENCE MANUAL          DATA                       Page 15
      1 January 1978                                                Sec. 3.2


      3.2.  TYPE CONVERSION      ____  ____ __________

      During the evaluation of expressions, the passing of arguments to
      procedures, and the assignment of values to variables, TYMBASIC will
      automatically convert a value to match the expected or required type,
      if possible.  Automatic type conversion follows these rules:

           1.  String can not be automatically converted to numeric or
               logical and vice-versa.

           2.  Real (single or double precision) to integer conversion is
               by rounding as in the Algol standard (.5 rounds in the
               positive direction).

           3.  A non-zero integer value converts to a TRUE (+1) logical
               value, and zero to FALSE.

           4.  A TRUE logical value converts to an integer +1, FALSE to 0.

           5.  Single to double precision conversion is by adding a second
               word of zero.

           6.  Complex is converted to real by dropping the imaginary part,
               and real is converted to complex by providing a zero
               imaginary part.



      3.3.  CLASS:  SCALARS and ARRAYS      ____  ______  _______ ___ ______

      Data is divided into two classes:  scalar and array.


      SCALARS      _______

      A scalar is a single value.


      ARRAYS      ______

      An array is an ordered set of scalars called the array elements.  It
      is construed as a rectangle having a fixed number of dimensions or
      subscripts (between 1 and 10, inclusive).  Each dimension has an
      integral length defined by an upper and lower bound.  The size of the
      array is the product of the lengths of the dimensions, and the
      elements of the array are ordered according to the value of each
      subscript.

      Vectors and matrices are simply arrays that have 1 and 2 dimensions,
      respectively.

      The number of dimensions that a data item has determines its
      "dimensionality." Scalars are considered to have dimensionality zero.
      TYMBASIC REFERENCE MANUAL          DATA                       Page 16
      1 January 1978                                                Sec. 3.4


      3.4.  CONSTANTS      ____  _________

      A constant is a data item whose value cannot change during program
      execution.  That is, its value may be read but not written and the                                            ____         _______
      value read will never change.

      There are no constants of class array nor of type complex.  The form
      of constants is given by type below.


      INTEGER CONSTANTS      _______ _________

      Integer constants can appear in two forms:  decimal and octal.

      A decimal integer constant consists of one or more decimal digits
      such as

              1
              5280

      An octal integer constant consists of one or more octal digits (0
      through 7) followed by the letter B.  For example:

              2B
              104B


      REAL CONSTANTS      ____ _________

      A real constant consists of one or more digits and a decimal point,
      such as

              3.14
              21.
              .0001

      A real constant may also be written as a sequence of digits (possibly
      including a decimal point) with a trailing exponent (E-format).  The
      exponent consists of the letter E followed by a one or two digit
      integer, which may be signed.  The integer is the power of 10 to
      which the number will be raised.  Imbedded spaces are not allowed.
      For example:

              .314E01
                 or     (=3.14)
              .314E1

              896.715974E06       (=896715974)


      TYMBASIC REFERENCE MANUAL          DATA                       Page 17
      1 January 1978                                                Sec. 3.4


      DOUBLE CONSTANTS      ______ _________

      Double constants are identical in appearance to real constants with
      exponents, except that the letter D is used instead of E.  Example:

              896.715974D12

      There are two special constants, PI and DPI, of type REAL and DOUBLE,
      respectively, that represent the single and double precision values
      of pi.


      STRING CONSTANTS      ______ _________

      A string constant consists of a sequence of printable characters
      (possibly none) enclosed in single or double quotation marks.  For
      example:

              'This constant has 28 characters'
              "because spaces are characters"
              ""
              '"" is a null string'


      LOGICAL CONSTANTS      _______ _________

      Logical constants are limited to two:  TRUE and FALSE, which have
      integer values of one and zero, respectively.  For example:

              10 IF A<400 THEN EXIT TRUE

      TYMBASIC REFERENCE MANUAL          NAMES                      Page 18
      1 January 1978                                                Sec. 4.1


                                SECTION 4. NAMES


      4.1 IDENTIFIERS      ___ ___________

      Identifiers are those language elements which name variables,
      procedures, parameters, and TYMBASIC keywords.

      A TYMBASIC identifier may be up to 15 characters.  The first
      character must be alphabetic, the rest alphabetic, numeric, or
      periods.  The last character may be a $.  Some legal identifiers:

              A1
              test.result.100
              NAME.OF.JOB$

      Lower and upper case characters are equivalent in identifiers.
      STRING.A$, string.a$, and String.A$, for example, are equivalent, and
      all refer to the same variable.

      There are two groups of identifiers:  user-defined identifiers and
      TYMBASIC keywords.

      User-defined identifiers may not duplicate TYMBASIC keywords, which
      are listed in Appendix A.

      There may be up to 4095 user-defined identifiers in a TYMBASIC source
      module.
      TYMBASIC REFERENCE MANUAL          NAMES                      Page 19
      1 January 1978                                                 Sec. 4.2


      4.2.  TYPES FOR IDENTIFIERS      ____  _____ ___ ___________

      Every user-defined identifier, and many TYMBASIC keywords, have a
      type (integer, real, double, complex, string or logical).  The type
      for a TYMBASIC keyword is predetermined, but the user may assign any
      type to a user-defined identifier, either explicitly or by default.

      Explicit:  identifier type may be explicitly given in a declaration:

              >10 DOUBLE A, B, C(1:15)
              >20 COMPLEX COMPN
              >30 STRING SIGNOFF

      Implicit:  in the absence of any explicit declaration, the type is
      STRING if the identifier ends with a $, the type is REAL otherwise.
      For example:

              >10 SIGNOFF$ = "Goodbye"
              >20 A, B, C = 10.25

      An explicit declaration overrides the implicit convention:

              >10 REAL F10$
              >20 INTEGER SIGNOFF$

      F10$ and SIGNOFF$ are real and integer, respectively.
      TYMBASIC REFERENCE MANUAL          NAMES                      Page 20
      1 January 1978                                                Sec. 4.3


      4.3.  FILE NOMENS      ____  ____ ______

      A TYMBASIC file "nomen", i.e., the total expression by which a file
      is named, is the construct that specifies user directory, file name
      with extension, and confirmation keyword.  The general syntax for
      file nomen is:

      [user directory] file name [.[extension]][confirmation keyword]

      Note that the term "file name" applies only to a specific component
      of a file nomen.

      Examples:

              TEMP
              TST.SBA
              (JONES)MLIB.REL-NEW
              (Jones)mlib.rel-n
              (SMITH)FXX.-E
              FXX.TST-A
              [13426,734032]FILE.xyz-exist


      In all parts of a file nomen lower case is equivalent to upper case.


      User Directory      ____ _________

      The user directory must be given when referring to a file belonging
      to another user.  It consists of either a user name enclosed in
      parentheses or a PPN enclosed in square brackets.

      User names can be one to twelve characters;  if greater, an error
      condition is generated.  TYMBASIC allows dots in user names, e.g.
      (jones.A)FXX.TST (the dot is part of the twelve allowable
      characters).

      A PPN is a pair of octal digit strings separated by a comma.  Each
      octal digit string may be from one to six digits.


      File name      ____ ____

      A file name must be at least one character long and must contain no
      spaces.  If a file name greater than six characters is entered, it is
      truncated to six characters.

      File names consisting of three-character or longer truncations of the
      word TERMINAL (TER, TERM, etc.) are abbreviations for TERMINAL.  File
      names whose first six characters are TERMIN but whose succeeding
      characters differ (e.g., TERMINXY), or that appear with a user
      directory or extension are illegal.
      TYMBASIC REFERENCE MANUAL          NAMES                      Page 21
      1 January 1978                                                Sec. 4.3


      Extension      _________

      If a period (dot) follows the file name then the characters following
      the period constitute the extension.  If the period is followed by a
      non-alphanumeric then the extension is explicitly null.  If the
      extension entered is greater than three characters, it is truncated
      to three.


      Default Extension      _______ _________

      If no extension appears in a file nomen then a default extension is
      inserted if one exists for the operation in question.  If the file
      with the inserted extension is being opened for input and cannot be
      found, then a null extension is inserted.  For example:

              >GET FLS

      TYMBASIC will look for FLS.TBA first;  if it is not found TYMBASIC
      will then look for FLS. .


      Confirmation Keyword      ____________ _______

      A confirmation keyword, if used, consists of a dash followed by any
      left subset of the words EXISTING (to allow an existing file to be
      overwritten);  NEW (to indicate awareness that a new file is being
      created);  or ANY (to indicate indifference as to whether the file
      exists or not).  If an incorrect declaration is made, an error
      condition is generated and the request is not processed.  Note the
      following:

              >SAVE FLS.K-EXISTING
              File does not exist FLS.K
              >SAVE FLS.M-NEW
              File already exists FLS.M

      If a confirmation keyword is not used, then TYMBASIC supplies prompts
      to remind the user of the current status of the file.  If the file
      already exists, TYMBASIC prints a prompt message;  for example:

              >SAVE FLS.P
              FLS.P: Existing file--OK?

      If the user types YES (or a left subset of it) and a carriage return,
      then the request is executed.

      TYMBASIC REFERENCE MANUAL          NAMES                      Page 22
      1 January 1978                                                Sec. 4.3


      If the file does not already exist, then TYMBASIC so informs the
      requestor:

              >10 OPEN "FLS.B", OUTPUT, 1
              >RUN
              FLS.B: New File--OK?

      Again, if the user then types YES (or Y or YE) and a carriage return,
      the request is executed.  If the user answers NO (or N) the request
      is not executed and an error condition is generated.  This file
      confirmation procedure is used whenever a file is being opened for
      output in TYMBASIC.


      Quotation Marks with File Nomens      _________ _____ ____ ____ ______

      File nomens used as operands of the commands GET, SAVE, DUMP REFS,
      INITIALIZE, RUN, MERGE and DO are interpreted literally and,
      therefore, need not be enclosed in quotes.  However, quotation marks
      must surround file nomens that begin with a numeric.

      TYMBASIC REFERENCE MANUAL          VARIABLES                  Page 23
      1 January 1978                                                Sec. 5.1


                              SECTION 5. VARIABLES


      Variables, named by identifiers, are the receptacles for data.
      Variables may be read or written during program execution.
      Certain variables are system-defined (defined by TYMBASIC);  others
      may be defined by the user.

              Kinds of Variables:           Class:

                Simple Variable               scalar
                Array Variable                array
                Array Element                 scalar
                Subarray                      array


      5.1.  CLASS & TYPE      ____  _____ _ ____

      Variables can be of either class, scalar or array, and both scalar
      variables and array variables may be of any type (integer, real,
      double, complex, string, or logical).

      The type and dimensionality of a variable may not change during
      program execution.  For example:  a scalar variable may not change
      into an array variable;  an integer variable may not change into a
      logical variable;  and the number of dimensions of an array variable
      may not change.


      5.2 INITIAL VALUE      ___ _______ _____

      The initial value assigned to a user-defined variable depends on the
      variable type:

              numeric = zero (integer, real, double, complex)

              logical = zero or FALSE

              string = null (as if defined to be "")

      All simple variables are given initial values during Initialization
      (see Execution, Sec. 8.4), and all variables except subarrays are
      re-initialized when a declaration for the variable is executed.

      Initial values for system-defined variables are documented with their
      definitions.
      TYMBASIC REFERENCE MANUAL          VARIABLES                  Page 24
      1 January 1978                                                Sec. 5.3


                             USER-DEFINED VARIABLES


      5.3.  DECLARATIONS FOR VARIABLES      ____  ____________ ___ _________

      The declaration statements (INTEGER, REAL, DOUBLE, COMPLEX, STRING,
      LOGICAL and DIM) determine the type and dimensionality of simple and
      array variables.

      The type of variables declared in the DIM statement (or not declared
      at all) is determined according to the name of the variable:  the
      type is string if the name ends with a $, otherwise the type is real.

      The declaration statements are partly executable, partly
      non-executable.  When a declaration statement is executed, the
      declared variables are initialized (i.e., their values are set to the
      initial values depending on type, as described in Sec. 5.2) and any
      data they contained previously is lost.  A declaration is
      non-executable in that it determines the type and dimensionality of a
      variable and these attributes can never change during program
      execution.


      ARRAY DECLARATIONS      _____ ____________

      When an array declaration is executed, the array is re-dimensioned
      and its new size is determined according to the given dimension
      bounds.  Note that when an array declaration is executed all data
      previously contained within the array is replaced by initial values.

      Execution of an array declaration must precede any reference to the
      array or to elements within the array.  It is not mandatory, however,
      that a declaration for a scalar variable be executed prior to
      references to that scalar variable.


      DUPLICATE DECLARATIONS      _________ ____________

      A module may contain more than one declaration for a given variable.
      Duplicate declarations must agree in type, class and number of
      dimensions, but the dimension bounds of an array may change.


      SYNTAX:  THE VARIABLE/DIMENSION LIST      _______  ___ __________________ ____

      Each declaration statement consists of the statement identifier
      (REAL, DIM, etc.) followed by a variable/dimension list which lists
      simple and array variable identifiers separated by commas.

      Each array variable identifier is followed by a parenthesized list of
      dimension bounds, one for each dimension, separated by commas.  The
      TYMBASIC REFERENCE MANUAL          VARIABLES                  Page 25
      1 January 1978                                                Sec. 5.3


      dimension bounds consist either of one numeric expression,
      representing the upper bound, or two numeric expressions separated by
      a colon, representing the lower and upper bounds.  If only the upper
      bound is specified, the current value of BASE (at the time of the
      execution of the declaration statement) is used as the lower bound.
      Either bound may be positive, zero, or negative.

              Examples:

              >10 STRING COMPANY.NAMES(-5:5, 20), I, ZEBRA
              >20 REAL NUM$(M+N:2*(M+N)), J, K(-20:-5, X)


      IMPLICIT DECLARATIONS      ________ ____________

      If a simple variable referenced in a module does not appear in any
      declaration statement within the module, it is assigned a type
      according to its name (see Sec. 4.2) and the scope of the variable
      will be the entire module (see Sec. 7.5).


      5.4.  ARRAY ELEMENTS      ____  _____ ________

      Any element of an array variable may be accessed (read or written) by
      following the variable name with a parenthesized list of subscripts,
      one for each dimension.

              Example:

              10 LET A(5,N*M)=DRIP.FACTOR(M)+Y**2


      5.5.  SUBARRAYS      ____  _________

      Any rectangular-shaped subsection of an array variable (or another
      subarray) can be defined as a subarray.  Once so defined, the
      subarray may be accessed (read or written) in exactly the same manner
      as an array variable.  When values are changed in the subarray, the
      values of the parent array are also changed because the subarray is
      actually a part of the parent array.

      A subarray, when defined, can be given a name with the NAME statement
      in which case the same subarray may be referenced more than once, or
      it can be anonymous and exist only for the duration of the operation
      in which it was defined.

      Besides being more efficient, naming a subarray also allows elements
      of the subarray to be accessed (exactly as an array element) and
      allows another subarray to be defined with the first subarray as the
      parent.
      TYMBASIC REFERENCE MANUAL          VARIABLES                  Page 26
      1 January 1978                                                Sec. 5.5


      SYNTAX, SUBARRAY DEFINITION      _______ ________ __________

      A subarray is defined by following the parent array name by a
      parenthesized list of subarray bounds, one for each dimension of the
      parent array.

      A subarray bound may be 1) a single numeric expression, 2) two
      numeric expressions separated by a colon, or 3) an asterisk.

      Examples:

              PAR.ARRAY(8,*)
              YR.TOTALS(3:6, 3:6, 3:6)
              B(*,*)


      SEMANTICS      _________

      If a single numeric value is given for a subscript, then the subarray
      will refer to only that portion of the parent array that has that
      subscript value.

      An asterisk specifies the entire range of a subscript, and a bounds
      pair specifies a certain subset of the subscript range.  Specifying
      equal expressions in a bounds pair is legal, as in B(4:4).

      For example, if the parent array YR.TOTALS were declared as

              10 REAL YR.TOTALS(10, 15, 20)

      then

              YR.TOTALS(8, *, *)

      refers to a two-dimensional (15 by 20) subarray, consisting of the
      8th plane of the parent array YR.TOTALS.  Whereas this subarray
      slices one complete plane from a three dimensional array, other
      segments can be taken, for example:

      Given
              10 REAL A(8,8,8)
      then
              A(3:6, 3:6, 3:6)

      is the cube-shaped 4 by 4 by 4 arrray at the center of A.

      Thus, the subarray may have the same number of dimensions as the
      parent, or fewer, depending on how many single values are given for
      subscripts.  Any number of subarrays may be taken from the same
      parent array.
      TYMBASIC REFERENCE MANUAL          VARIABLES                  Page 27
      1 January 1978                                                Sec. 5.5


      An error condition will be generated at the time of array or subarray
      element access if the element being accessed does not fall within the
      bounds of the array or subarray.  This can occur, for example, if the
      parent array is redimensioned without compatible adjustment to its
      subarrays.


      THE NAME STATEMENT      ___ ____ _________

      A subarray may be named by the NAME statement, and thereafter the
      subarray name refers to that subarray.  Naming a subarray is the only
      way that provides for accessing individual elements of the subarray.
      For example:

              10 REAL YR.TOTALS(10, 15, 20)
              20 NAME TOTALS.75=YR.TOTALS(8, 10:15, 15:20)
              30 NAME TOTALS.76=YR.TOTALS(9, 10:15, 15:20)

      TOTALS.75 is a two-dimensional subarray consisting of a rectangular
      section of the 8th plane of the parent array YR.TOTALS.  The elements
      of TOTALS.75 refer to the elements of YR.TOTAL as follows:

              TOTALS.75(10,15)      YR.TOTALS(8,10,15)
              TOTALS.75(10,16)      YR.TOTALS(8,10,16)
              .
              .
              .
              TOTALS.75(15,20)      YR.TOTALS(8,15,20)

      The subscript bounds of the subarray refer directly to those given in
      the NAME statement, so that the element TOTALS.75(12,14) is
      equivalent to the element YR.TOTALS(8,12,14).

      As with non-subarray declarations, the NAME statement may occur more
      than once for a given subarray name, as long as the dimensionality of
      the subarray is not changed.  Thus the same subarray name may
      describe different parts of different parent arrays at any given time
      in the execution of the program.

      See also the NAME statement, Sec. 9.1.
      TYMBASIC REFERENCE MANUAL          VARIABLES                  Page 28
      1 January 1978                                                Sec. 5.6


      5.6.  SYSTEM-DEFINED VARIABLES      ____  ______________ _________


      SYSTEM-DEFINED SCALAR VARIABLES      ______________ ______ _________

      The system-defined variable named EPS affects the relational operator
      =# and the INV function.  TYMBASIC initializes EPS to the REAL value
      1E-10;  its value may be set to an expression as with any variable,
      but it may not be re-declared.  It is global to every module
      throughout the entire program.

      START.POINT is a system-defined integer variable, global to the
      entire program, set by TYMBASIC when a SAVE BINARY program is run.
      Its value will be zero if the program is run normally;  it will be
      set to one if the program is run with a starting increment of one.
      See the DEC System10 Assembly Language Handbook, Monitor Calls.  Like
      EPS, START.POINT may be stored into but not re-declared.


      SYSTEM-DEFINED ARRAY VARIABLES      ______________ _____ _________

      The system-defined array variables ASCTABLE and CHARTABLE enable the
      user to change the system-standard (ASCII) collating sequence for
      every module throughout the program.  Normally, characters are stored
      internally in ASCII code, and string comparisons, as well as input
      and output, are based on ASCII.  The user may handle non-ASCII codes
      using the ASC and CHAR functions, described in Section 7.8, which are
      based on the current values in ASCTABLE and CHARTABLE.

      TYMBASIC declares ASCTABLE and CHARTABLE as follows:

              INTEGER ASCTABLE (0:127)
              STRING CHARTABLE (0:127):1

      The user may use ASCTABLE and CHARTABLE like any array variable.
      ASCTABLE contains the information required to convert ASCII character
      codes to corresponding character codes in the desired collating
      sequence.  It is used in string comparisons.  CHARTABLE contains the
      characters (1-character strings) corresponding to the character codes
      0-127.  The CHAR function uses CHARTABLE to convert codes from the
      current collating sequence back to their character representations.

      For example, assume that for the purposes of ASC, CHAR, and character
      comparisons, the character "A" is to have the value 6 instead of its
      usual ASCII value of 65.  This is accomplished as follows:

              10 ASCTABLE(65)=6
              20 CHARTABLE(6)="A"

      From then on, ASC("A") returns a value of 6 and CHAR(6) returns "A".
      Note that CHAR(ASC("A"))is still "A".
      TYMBASIC REFERENCE MANUAL          VARIABLES                  Page 29
      1 January 1978                                                Sec. 5.6


      TYMCOM-IX codes can be loaded into ASCTABLE and CHARTABLE using the
      array valued system functions IXASC and IXCHAR as follows:

              ASCTABLE=IXASC
              CHARTABLE=IXCHAR

      TYMCOM-X ASCII can be restored by:

              ASCTABLE=XASC
              CHARTABLE=XCHAR

      TYMCOM-X ASCII is the initial condition.  See Appendix D for a table
      of IXASC, IXCHAR, XASC and XCHAR values.

      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 30
      1 January 1978                                                Sec. 6.1


      SECTION 6.  EXPRESSIONS      _______ __  ___________


      6.1.  GENERAL      ____  _______

      Expressions specify operations to be performed upon scalar and array
      values (array operations are discussed more fully in Sec. 6.10).
      Expressions are evaluated during execution to either numeric, string,
      or logical values, depending on the expression components.

      Barring error conditions, all parts of an expression are evaluated
      during execution.  In particular, both operands of a boolean operator
      are always evaluated, regardless of whether the result can be
      determined from one operand alone.


      6.2.  OPERATOR PRECEDENCE      ____  ________ __________

      Parentheses may be used to indicate precedence of operation.
      Parentheses may be nested to any level, and redundant parentheses
      have no effect.  Within parentheses (or without them), operators
      follow the hierarchy of precedence listed below.  Operators of equal
      precedence are listed on the same line.


      Highest precedence: ** (or ^ or ^)
                          - (unary minus)
                          MOD BAN BOR BEX
                          * / DIV
                          + -
                          = > >= < <= # =# << >>
                          NOT
                          AND
                          OR  XOR
                          IMP
      Lowest precedence:  EQV
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 31
      1 January 1978                                                Sec. 6.3


      6.3.  CONVERSION OF TYPES IN EXPRESSIONS      ____  __________ __ _____ __ ___________


      CONVERSION      __________

      The type of an operand will be converted, if necessary, as follows:


           1.  To match the closest type accepted by the operator

               and then

           2.  If two operands are of different types, the operand of lower
               type is converted up to the type of the other (except for **
               and PWR, which are discussed below).  See the order of types
               table, below.

      Logical values may be used freely in numeric expressions and vice
      versa, with conversion taking place as necessary.

      Example:

              10 INTEGER I
              20 REAL R
              30 DOUBLE D
              40 D = 2.71828
              50 I = 17
              60 R = D/I

      In line 60, the value of I is first converted to type real, because
      the / operator does not accept an integer operand (as shown in the
      table on the next page).  Then, it is converted to type double to
      match the type of the other operand, D.  The result of the division
      will be of type double, as shown in the table (note also that this
      value will be converted to real in order to store it into R).

      ORDER      _____

      Type conversions in expressions are made according to the following
      order of types:


            Highest type: complex
                          double
                          real
                          integer
            Lowest type:  logical


      NOTE:  Complex is converted down to real (not double).
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 32
      1 January 1978                                                Sec. 6.4


      6.4.  ARITHMETIC OPERATORS      ____  __________ _________

      The following arithmetic operators accept numeric scalars or arrays.
      Operations on arrays are element-by-element (see Sec. 6.10).


      operator     operand    result           comments
      -------------------------------------------------------------------------
        +        | integer | integer |       addition
                 |  real   |  real   |
                 | double  | double  |   see also Sec. 6.9 for +
                 | complex | complex |   as string concatenator
      -------------------------------------------------------------------------
        -        | integer | integer |       subtraction  or  unary minus
                 |  real   |  real   |
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------------
        *        | integer | integer |       multiplication
                 |  real   |  real   |
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------------
        /        |  real   |  real   |       division
                 | double  | double  |  Note:  result is always floating point
                 | complex | complex |
      -------------------------------------------------------------------------
        DIV      | integer | integer |       "integer result" division
                 |  real   |  real   |  a DIV b is equivalent to FIX(a/b)
                 | double  | double  |
      -------------------------------------------------------------------------
        MOD      | integer | integer |       modulo
                 |  real   |  real   |
                 | double  | double  |   complex operands are converted to real
      -------------------------------------------------------------------------
       ** or ^   | integer | real    |       exponentiation
        or ^     |  real   |  real   |  (see effect of MAT prefix Sec. 9.1)
      (see below)| double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------------

      For exponentiation, the operands may be of different types.  The type
      of the result is the higher of the types of the operands, with one
      exception:  an integer raised to an integer power will yield a real
      result because a negative power may give a fractional result.

      Complex exponentiation is defined as:

              EXP(P+LOG(ABS(B))+CMPLX(0,1)*PHASE(B)

      where B is the base and P is the power.
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 33
      1 January 1978                                                Sec. 6.5


      6.5.  MATRIX OPERATORS      ____  ______ _________


      The MUL and PWR operators are used with two-dimensional arrays.
      There are special rules for handling one-dimensional arrays.  See
      also MAT prefix, Sec. 9.1.


      operator     operand    result           comments
      -------------------------------------------------------------------------
        MUL      | integer | integer |       matrix multiplication
                 |  real   |  real   |
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------------
        PWR      | integer | integer |       matrix exponentiation
                 |  real   |  real   |  A PWR 3 is equivalent to A MUL A MUL A
                 | double  | double  |  power must be an integer scalar
                 | complex | complex |
      -------------------------------------------------------------------------

      MUL operates on two-dimensional arrays.  However one-dimensional
      arrays in a MUL expression are internally treated as a row or column
      vector of the same length.  A row vector is a two-dimensional array
      with a length of one in the first dimension, a column vector is a
      two-dimensional array with a length of one in the second dimension.
      A one-dimensional array to the left of a MUL is treated as a row
      vector, to the right as a column vector.

      MUL requires the lengths of the inner dimensions be equal (else a run
      time error).  The size of the result is determined by the outer
      dimensions.

      MUL of two one-dimensional arrays gives a scalar result, not an
      array.  However MUL of explicitly defined (two-dimensional) row and
      column vectors yields a two-dimensional array result containing one
      element.
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 34
      1 January 1978                                                Sec. 6.6


      6.6.  BIT-WISE OPERATORS      ____  ________ _________


      The following operators accept integer scalars only.


      operator     operand    result           comments
      -------------------------------------------------------------------------
        BAN      | integer | integer |       bit by bit and
      -------------------------------------------------------------------------
        BOR      | integer | integer |       bit by bit or
      -------------------------------------------------------------------------
        BEX      | integer | integer |       bit by bit exclusive or
      -------------------------------------------------------------------------
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 35
      1 January 1978                                                Sec. 6.7


      6.7.  RELATIONAL OPERATORS      ____  __________ _________


      The following relational operators are used to compare numeric
      scalars.  They give a logical result.  Except where noted complex
      operands are not allowed.  Note that the logical result may be used
      freely in a numeric or logical expression.


      operator            result
      -------------------------------------------------------------------------
           =          |   equal to     May be used with complex operands.
                      | Not to be confused with the = assignment. "LET A= B=C"
                      | assigns the logical value of B=C to A.
      -------------------------------------------------------------------------
           <          |   less than
      -------------------------------------------------------------------------
        <= or =<      |   less than or equal to
      -------------------------------------------------------------------------
           >          |   greater than
      -------------------------------------------------------------------------
        >= or =>      |   greater than or equal to
      -------------------------------------------------------------------------
        # or <> or >< |   not equal to    May be used with complex operands.
      -------------------------------------------------------------------------
           <<         |   very much less than
                      |  A<<B is true if internally A+B=B
      -------------------------------------------------------------------------
           >>         |   very much greater than
                      |  A>>B is true if internally A+B=A
      -------------------------------------------------------------------------
        =# or #=      |   approximately equal to
                      |   May be used with complex operands.
                      | This operator is defined in terms of the system-defined
                      | variable EPS. A=#B is true if ABS(A/B-1) < EPS
      -------------------------------------------------------------------------
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 36
      1 January 1978                                                Sec. 6.8


      6.8.  BOOLEAN OPERATORS      ____  _______ _________


      The following boolean operators accept only logical scalar operands.
      The type of the result of the boolean operators is logical.  Both
      operands of a boolean operator are always evaluated, regardless of
      whether the result can be determined from one operand alone.


      operator   T op T  T op F  F op T  F op F      comments
      -------------------------------------------------------------------------
        AND    |   T       F       F       F    |    logical and
      -------------------------------------------------------------------------
        OR     |   T       T       T       F    |    logical inclusive or
      -------------------------------------------------------------------------
        XOR    |   F       T       T       F    |    logical exclusive or
      -------------------------------------------------------------------------
        IMP    |   T       F       T       T    |    logical implication
      -------------------------------------------------------------------------
        EQV    |   T       F       F       T    |    logical equivalence
      -------------------------------------------------------------------------
        NOT    |    NOT T = F      NOT F = T    |    logical negation
      -------------------------------------------------------------------------
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 37
      1 January 1978                                                Sec. 6.9


      6.9.  STRING OPERATORS      ____  ______ _________

      Strings cannot be manipulated like numbers, but they may be
      concatenated, using the + operator, and compared, using a subset of
      the relational operators:


      Operator           Meaning                  Use
      -------------------------------------------------------------
        +             |  concatenation of two  |  Operands may
                      |  strings               |  be arrays.
      -------------------------------------------------------------
        <             |  less than             |
      ------------------------------------------  Operands may not
        <= or =>      |  less than or equal    |  be arrays.
      ------------------------------------------
        =             |  equal                 |  All relational
      ------------------------------------------  comparisons use
        >= or =>      |  greater than or equal |  the collating
      ------------------------------------------  sequence defined
        >             |  greater than          |  in ASCTABLE
      ------------------------------------------
        # or >< or <> |  not equal             |
      -------------------------------------------------------------
      TYMBASIC REFERENCE MANUAL          EXPRESSIONS                Page 38
      1 January 1978                                                Sec. 6.10


      6.10.  ARRAY EXPRESSIONS      _____  _____ ___________

      Array operations are element-by-element, except for the operators MUL
      and PWR, which denote matrix multiplication and exponentation, or
      when the line is prefaced by MAT.  That is, binary operators operate
      on corresponding elements of the two array operands, and unary
      operators operate singly on the elements of the array operand.

      Arithmetic operations in which one operand is a scalar expression and
      the other is an array (or subarray) expression are valid for any
      operation that is valid when both operands are scalar expressions,
      except that an array cannot be stored into a scalar.  For example:


              >10 INTEGER A(1:10,5:75), J
              >20 A = 5*J
              >30 PRINT A*2 +J

      In line 20, the scalar expression 5*J is stored into every element of
      the array A.  In line 30, every element of the array A is multiplied
      by 2, and then the value of J is added to every element of A.

      Element-by element operations in which both operands are array
      expressions are valid when the array expressions are conformable:
      they have the same number of dimensions and the lengths of
      corresponding dimensions are equal.

      The value of an arithmetic operation on array expresions is an array
      expression that is conformable with the operands, and whose subscript
      lower bounds are equal to the current value for BASE.  The type of
      such resulting array expressions follows the same rules as for scalar
      operations.

      Element-by-element operations are limited to the arithmetic
      operators, and are not defined on type logical.

      ARRAY INTERSECTION      _____ ____________

      Different subsections of the same array may be defined as subarrays
      (see Sec. 5.5).  The intersection of two such subarrays is also a
      subarray, and can be referenced by the use of the @ operator.  For
      example:


              >10 INTEGER A(20,20,20), X(20,10,10)
              >20 NAME B = A(*,6:15,*)
              >30 NAME C = A(*,*,6:15)
              >40 X = B @ C

      B@C in this case is equivalent to A(*,6:15,6:15).  An error condition
      is generated if the result of the intersection is void or if the two
      operands do not share a common parent array.  The dimensionality of
      the result is no greater than the lesser of the number of dimensions
      of the two operands.
      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 39
      1 January 1978                                                Sec. 7.1


                              SECTION 7. PROCEDURES


      See the GOSUB statement for a description of GOSUB subroutines.

      Procedures, named by identifiers, may be defined by the user or
      supplied by TYMBASIC.  The TYMBASIC system-defined procedures are
      listed in Sec. 7.8.  System-defined procedures (also known as
      functions) all return a value.  User-defined procedures, defined by
      the DEF statement, return a value also, but it may be a null value,
      equivalent to the initial value given to simple variables (see
      Sec. 5.2).  Procedures may be called as functions by using the
      procedure name in an expression, or by an explicit CALL statement (in
      which case any value returned by the procedure is ignored).

      Procedures are not recursive.  That is, they may not directly or
      indirectly call themselves.


      7.1.  CLASS & TYPE      ____  _____ _ ____

      The value of a procedure can be of either class, scalar or array, and
      both scalar- and array-valued procedures may be of any type (integer,
      real, double, complex, string, or logical).

      The type and class of a user-defined procedure is specified in the
      procedure declaration, which is a DEF statement.  The type and class
      of system-defined procedures is predefined.


                             USER-DEFINED PROCEDURES


      7.2.  EXTERNAL AND ENTRY (GLOBAL) PROCEDURES      ____  ________ ___ _____ ________ __________

      A procedure contained in one module may be called from another
      module.  Such a procedure is called a global procedure.  In this
      case, the calling module must contain a DEF statement for that
      procedure with the EXTERNAL attribute.  The DEF EXTERNAL informs
      TYMBASIC of the name, type, class and dimensionality of the external
      procedure and lists the parameters it expects.  DEF EXTERNAL
      statements are non-executable.

      The called module contains the procedure body.  If written in
      TYMBASIC, the module must contain a DEF statement for that procedure
      with the ENTRY attribute, so that its name will be known outside of
      its own module (i.e., global).  A global procedure may also be called
      from within the same module that contains the procedure.  Example:
      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 40
      1 January 1978                                                Sec. 7.2


      -TYPE INVHYP.TBA

      10 ! ** INVERSE HYPERBOLIC FUNCTIONS **
      20 ! INVERSE HYP. SINE
      30 DEF ENTRY INV.SINH(X)=LOG(X+SQR(X^2+1))
      40 ! INVERSE HYP. COSINE
      50 DEF ENTRY INV.COSH(X)
      60   IF X>1 THEN EXIT LOG(X+SQR(X^2-1))
      70   STOP  "ERROR--INV.COSH ARGUMENT MUST BE >=1"
      80 ENDF INV.COSH
      120 ! INVERSE HYP. TANGENT
      130 DEF ENTRY INV.TANH(X)
      140   IF X^2<1 THEN EXIT LOG((1+X)/(1-X))/2
      150   STOP  "ERROR--INV.TANH ARGUMENT MUST BE BETWEEN -1 AND 1"
      160 ENDF INV.TANH

      -TBA
      Ver. 4.0
      >GET EXAMPL
      >LIST

      10 DEF EXTERNAL INV.SINH(X)
      20 DEF EXTERNAL INV.COSH(X)
      30 DEF EXTERNAL INV.TANH(X)
      40 PRINT "THIS PROGRAM USES THE MODULE INVHYP.TBA."
      50 PRINT INV.SINH(13)
      60 PRINT INV.COSH(9)
      70 PRINT INV.TANH( TANH(5.6) )
      80 ! TANH IS A SYSTEM-DEFINED FUNCTION
      90 END

      >MODULES INVHYP, EXAMPL
      >LIST MODULES
      INVHYP      NO DEBUG
      EXAMPL.TBA     NO DEBUG     ** WORKSPACE **

      >RUN
      THIS PROGRAM USES THE MODULE INVHYP.TBA.
       3.259573
       2.887271
       5.599944

      END in line 90
      >
      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 41
      1 January 1978                                                Sec. 7.2


      A module may legally contain DEF EXTERNAL statements for procedures
      which are in fact never called.  A Loader request for the procedure
      is made only if the procedure is called.  Therefore, external
      procedures that are declared but never called will not cause a module
      to be loaded from a library.


      OTHER-LANGUAGE EXTERNAL PROCEDURES      ______________ ________ __________

      A procedure written in a language other than TYMBASIC may be called
      from a TYMBASIC module.  There is no facility, however, for calling
      TYMBASIC procedures from other-language modules.

      Calls are supported to procedures written in:

              TYMBASIC
              F10, SUPERFORTRAN, FORTRAN4
              COBOL
              SIMPL
              BLISS

      The assembly language form of the calling sequences for each language
      are given in Appendix E.

      Procedures written in FORTRAN or COBOL may not do any I/O.  A
      complete discussion of restrictions for other-language procedures is
      also given in Appendix E.


      THE AKA CLAUSE IN THE DEF STATEMENT      ___ ___ ______ __ ___ ___ _________

      The loader can only recognise global procedure names up to six
      characters.  The AKA clause allows the user to define an alternate
      name for a global procedure by which the loader will identify the
      procedure.  Within the module containing the DEF the procedure will
      be known by its original name.  Note that the AKA names, if any,
      given in the DEF EXTERNAL and in the DEF ENTRY must match for the
      loader to properly link the procedure call to the procedure.

      If no AKA name is given, then the loader will identify the procedure
      by the first six characters of the original procedure name.

      The characters that make up the AKA name must belong to the SIXBIT
      set (this is the printable ASCII character set less lowercase alphas,
      and less `, {, |, }, ~).  Lowercase alphas given in the AKA name are
      converted to uppercase.  Example:

              10 DEF EXTERNAL MY.PROCEDURE AKA "HER.PR"
      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 42
      1 January 1978                                                Sec. 7.3


      7.3.  DECLARATIONS FOR PROCEDURES AND PARAMETERS      ____  ____________ ___ __________ ___ __________

      The type, class, and other attributes of a procedure, and the type
      and class of all of its parameters are given in the DEF statement.
      There may be as many as 511 user-defined procedures in a module.


      Syntax:      _______


                               EXTERNAL procedure                               ________ _________

      (A global procedure whose body is contained in another module)

      DEF [type] EXTERNAL [language] id [(dims)][(params)][AKA "name"]

      Examples:

          10 DEF EXTERNAL FUNC1(INTEGER I)
          20 DEF INTEGER EXTERNAL FUNC2(*,*)(INTEGER I)
          30 DEF COMPLEX EXTERNAL SFO FUNC3(REAL I, DOUBLE D) AKA "$POLAR"


                      Single-line procedure (global/local)                      ___________ _________ ______________

      (The procedure value is given as an expression on the same line as
      the DEF, and the procedure is global/local)

      DEF [type] [ENTRY] id [(dims)][(params)][AKA "name"] = expression

      Examples:

          10 DEF FUNC1 = 43
          20 DEF INTEGER ENTRY FUNC2(INTEGER I) AKA "ITSIT" = 7*I
          30 DEF DOUBLE FUNC3(*)(DOUBLE D(*)) = D/DPI


                       Multi-line procedure (global/local)                       __________ _________ ______________

      (The procedure body consists of a group of statements;  the procedure
      value is given in an EXIT statement;  the procedure is global/local)

      DEF [type] [ENTRY] id [(dims)][(params)][AKA "name"]
      .
      . statements
      .
      ENDF id

      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 43
      1 January 1978                                                Sec. 7.3


      Example:

          10 DEF INTEGER FUNC1(INTEGER I)
          20   CALL NEXT.LINE(I)
          30   EXIT VAL(F$)
          40 ENDF FUNC1

      In all of the above forms, the AKA clause may appear only if EXTERNAL
      or ENTRY is specified.


      Semantics      _________

      "type" may be any of the type keywords:  INTEGER, REAL, DOUBLE,
      COMPLEX, STRING or LOGICAL, and specifies the type of the value of
      the procedure.

      As for variables, if an explicit type declaration is omitted, the
      procedure name determines the type (see Sec. 4.2).

      "language" specifies the calling conventions for EXTERNAL procedures
      and may be one of:  TBA, SFO, F40, SIMPL or BLISS.  If not specified
      the calling convention is TBA.

      "id" is an identifier that is the procedure name.

      "(dims)" is a parenthesized series of asterisks, separated by commas,
      and specifies the number of dimensions for an array-valued procedure.
      For example,

              DEF FUNC3(*,*,*)(I,J)

      declares an array-valued procedure of three dimensions (and two
      parameters).  This field is omitted for scalar-valued procedures.

      "(params)" is a list of parameters with optional type keywords,
      separated by commas.  A type keyword may be followed by a
      parenthesized list of parameters, in which case that type applies to
      all those parameters.  For example,

              DEF FUNC (REAL I, STRING F)

      declares a procedure with two parameters, one of type REAL, one of
      type STRING.

              DEF FUNC(INTEGER(I,J,K), COMPLEX F)

      declares a procedure with four parameters, the first three of type
      INTEGER, the fourth of type COMPLEX.

      If an explicit type declaration is omitted, the parameter name
      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 44
      1 January 1978                                                Sec. 7.3


      determines the type (see Sec. 4.2).

      Array parameters may be specified by following the parameter name
      with a parenthesized series of asterisks separated by commas, one for
      each dimension of the parameter array.  For example:

              DEF FUNC (DOUBLE (A(*,*),B))

      declares a procedure with two parameters, both of type double, the
      first of which is a two-dimensional array.

      As many as 31 parameters may be specified in the DEF.

      The AKA clause is discussed in Section 7.2.


      Parameters for EXTERNAL procedures      __________ ___ ________ __________

      For EXTERNAL procedures, the DEF is non-executable and simply defines
      the attributes of the procedure.  Therefore, parameters mentioned in
      the DEF are dummy parameters that specify the type and dimensions of
      the arguments to be passed to the procedure, and no space is
      allocated for them.

      FOR Loops and Extended IF statements in Procedure Definitions      ___ _____ ___ ________ __ __________ __ _________ ___________

      These two constructs must begin and end in the same context.  That
      is, a FOR loop or extended IF statement may not cross a procedure
      definition.  A procedure may, however, be wholly contained within one
      of these constructs.  For example:

                Legal:                        Not legal:

          10 IF A=5 THEN                  10 IF A=5 THEN
          20   DEF F6(I)                  20   DEF F6(I)
          30     CALL NEW.VALUE(I)        30     CALL NEW.VALUE(I)
          40     EXIT F7(I)*4             40   Q = F6(A)
          50   ENDF F6                    50 ENDIF
          60   Q = F6(A)                  60     EXIT F7(I)*4
          70 ENDIF                        70   ENDF F6


      7.4.  PASSING ARGUMENTS TO PROCEDURES      ____  _______ _________ __ __________

      A procedure may be called by a CALL statement or by reference within
      an expression.  Arguments to the procedure can be expressions, and
      are listed within parentheses after the procedure name and separated
      by commas.  The arguments given in the call, if any, are transferred
      to corresponding parameters as defined in the DEF for the procedure
      being called.  Control then transfers to the procedure body.
      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 45
      1 January 1978                                                Sec. 7.4


      NUMBER OF ARGUMENTS      ______ __ _________

      The number of arguments given must be the same as the number of
      parameters specified in the DEF, with one exception:  more arguments
      than specified may be passed to EXTERNAL procedures declared SFO or
      F40.


      PASSING ARGUMENTS BY NAME AND VALUE      _______ _________ __ ____ ___ _____

      There are two ways in which arguments are passed to procedures in
      TYMBASIC:  by name and by value.

      In passing an argument by value, the value of the argument is stored
      into the parameter.  If the value of the parameter changes during
      execution of the procedure, the original argument is not affected.

      In passing an argument by name, the address or name of the argument
      is given to the procedure, so that when the procedure stores into the
      parameter it is actually storing into the argument.  If the argument
      is a constant, storing into it may generate a fatal error.

      If the procedure being called is TBA, then all arguments are passed
      by value except for array arguments.  This is done because passing an
      array argument by value would involve copying all the array elements,
      and would increase execution time and storage allocation.

      Array expressions may be passed to a TYMBASIC procedure, and the
      array may be read and written during execution of the procedure, but
      when the procedure exits the array is discarded.

      String expressions passed to a TYMBASIC procedure are also discarded
      when the procedure exits.

      If the procedure being called is SFO or F40, then all arguments are
      passed by name.

      If the procedure being called is SIMPL or BLISS, then numeric (and
      logical) scalar arguments are passed by value and array arguments and
      string scalar arguments are passed by name.

      See Appendix E for a complete description of other-language calling
      conventions.


      TYPE CONVERSION OF ARGUMENTS      ____ __________ __ _________

      An argument must agree in class (scalar/array), and in number of
      dimensions, with its corresponding parameter.

      If a scalar argument is of a different type than that specified by
      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 46
      1 January 1978                                                Sec. 7.4


      its corresponding parameter, it is converted to the type of the
      parameter, if possible.  Array arguments will not be converted (an
      error will be generated in the case of type mismatches).

      If a converted argument is passed by name then it is considered to be
      an expression.  Therefore, storing into a parameter whose
      corresponding argument was a converted variable will not change the
      value of the variable.

      ARRAY PARAMETERS      _____ __________

      For array parameters, only the dimensionality is specified in the
      DEF.  The bounds for each dimension are determined from the argument
      array at the time of procedure call.  Thus, re-declaring the array
      parameter within the procedure body is not part of the calling
      protocol:  it in fact will re-declare and clear the array as an array
      declaration will anywhere in a module.


      7.5.  CONTEXT, SCOPE, LOCAL VARIABLES & PROCEDURES      ____  ________ ______ _____ _________ _ __________

      Parameters, variables and procedures declared within a procedure are
      local.  That is, references to their names within the procedure will
      apply to the locally-defined names regardless of whether these names
      have been defined in the main program or in an outer procedure.
      Example:

              10 INTEGER I,J,K
              20 DEF F(I)
              30   LOGICAL J
              40   K=I*J
              50 ENDF F

      In line 40, K refers to the integer K defined on line 10.  I refers
      to the (implicitly typed) real I defined as a parameter on line 20.
      J refers to the logical J defined by declaration on line 30.

      The scope of a parameter, procedure, or variable consists of the
      contexts in which it is known.  Thus, the real parameter I defined on
      line 20 and the logical J defined on line 30 have the same scope:
      lines 20 through 50, whereas the scope of K, defined on line 10, is
      lines 10 through 50.  Reference to a variable named "J" may refer to
      two different variables, depending on the context in which the
      reference occurs.

      Thus, to say that a parameter, procedure, or variable is local to a
      procedure is to say that its scope is limited to within the
      procedure.


      TYMBASIC REFERENCE MANUAL              PROCEDURES             Page 47
      1 January 1978                                                Sec. 7.5


      NESTED PROCEDURES      ______ __________

      A procedure may be contained within the body of another procedure,
      and if so is said to be nested within an outer procedure.  The inner
      procedure name is local to the outer procedure;  that is, its scope
      is limited to within the outer procedure.  Procedures may be nested
      up to ten levels.


      PRESERVATION OF VALUES ACROSS CALLS      ____________ __ ______ ______ _____

      The values held by local variables are static across calls to a
      procedure.  In other words, a local variable will have the same value
      at the beginning of the execution of a procedure as it had at the end
      of the previous execution of the procedure.  Values are of course
      given to parameters at the time of the procedure call.  However,
      should a branch into a procedure or a call to a nested procedure take
      place after the outer procedure has exited, only numeric and logical
      scalar parameters will have retained their values (if the procedure
      has never been called then they will have initial values).  Array
      parameters may not be referenced at all when a procedure body is
      branched into;  string scalar parameters may be read or written only
      after the procedure has been called at least once.


      7.6 PROCEDURE VALUE:  EXITING FROM A PROCEDURE      ___ _________ ______  _______ ____ _ _________

      The procedure value is determined at the time of exit.  Exit from a
      procedure occurs when an EXIT statement is executed or when the ENDF
      is reached (for single-line procedures exit occurs after evaluation
      of the procedure expression).

      A procedure may contain any number of EXIT statements.

      If the EXIT statement supplies a value, then that value (converted to
      the declared type of the procedure if necessary) will be the value of
      the procedure.  If a value is omitted or if exit is by reaching the
      ENDF, a null (initial) value is provided according to the type of the
      procedure (see Sec. 4.2).


      7.7 I/O WITHIN A PROCEDURE      ___ ___ ______ _ _________

      Input or output may be done from within a procedure even though an
      input or output operation is in progress.  For example,

              10 PRINT ON 1 AT N:  X+Y, FUNC(Z), FUNC(A)

      and, in FUNC:

              420 PRINT ON 1:  E, F, G
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 48
      1 January 1978                                                Sec. 7.8


      7.8.  TABLES OF SYSTEM-DEFINED PROCEDURES      ____  ______ __ ______________ __________

      This section presents all of the system-defined procedures, organized
      into tables according to their function.

      All TYMBASIC system-defined procedures are functions;  that is, they
      all return a value.

      All arguments are scalars except where noted.

      The data types of input arguments for each function are given with
      the description;  if a different data type is supplied, conversion to
      one of the accepted types is automatically performed (see Sec. 3.2).
      Thus, even though complex is not listed as an accepted type for the
      ROUN function, if a complex argument is given to ROUN the argument
      will be converted to real (according to the standard conversion
      rules).


                             TRIGONOMETRIC FUNCTIONS                             _____________ _________

      Trigonometric functions use radians.

      Function     Argument   Result           Description
      -------------------------------------------------------------------
      SIN(X)     |  real   |  real   |      sine of X
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------
      COS(X)     |  real   |  real   |      cosine of X
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------
      TAN(X)     |  real   |  real   |      tangent of X
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------
      ASIN(X)    |  real   |  real   |      arcsine of X
      -------------------------------------------------------------------
      ACOS(X)    |  real   |  real   |      arccosine of X
      -------------------------------------------------------------------
      ATAN(X) or | double  | double  |      arctangent of X
      ATN(X)     |         |         |
      -------------------------------------------------------------------
      ATAN(X,Y)  | double  | double  |      arctangent of X/Y
      or ATN(X,Y)|         |         |
      -------------------------------------------------------------------
      SINH(X)    |  real   |  real   |      hyperbolic sine of X
      -------------------------------------------------------------------
      COSH(X)    |  real   |  real   |      hyperbolic cosine of X
      -------------------------------------------------------------------
      TANH(X)    |  real   |  real   |      hyperbolic tangent of X
      -------------------------------------------------------------------
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 49
      1 January 1978                                                Sec. 7.8


                              EXPONENTIAL FUNCTIONS                              ___________ _________


      Function     Argument   Result           Description
      -------------------------------------------------------------------
      SQRT(X) or | double  | double  |       square root of X
      SQR(X)     | complex | complex |
      -------------------------------------------------------------------
      LOG(X)     |  real   |  real   |       natural log of X
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------
      LGT(X) or  |  real   |  real   |       log of X base 10
      LOG10(X)   | double  | double  |
      -------------------------------------------------------------------
      EXP(X)     |  real   |  real   |       e to the X power
                 | double  | double  |
                 | complex | complex |
      -------------------------------------------------------------------

      The exponential operator, ^ or ^ or **, is discussed in Section 6.4.



                                COMPLEX FUNCTIONS                                _______ _________


      Function     Argument   Result           Description
      -------------------------------------------------------------------
      CMPLX(X,Y) |  real   | complex |    complex value X+iY
      -------------------------------------------------------------------
      REAL(C)    | complex |  real   |    real part of C
      -------------------------------------------------------------------
      IMAG(C)    | complex |  real   |    imaginary part of C
      -------------------------------------------------------------------
      ABS(C)     | complex |  real   |    magnitude of C
      -------------------------------------------------------------------
      PHASE(C)   | complex |  real   |    phase, in radians, of C
      -------------------------------------------------------------------
      POLAR(X,Y) | double  | complex |    complex value with 
                 |         |         |    magnitude X and phase
                 |         |         |    Y, in radians
      -------------------------------------------------------------------
      CONJ(C)    | complex | complex |    conjugate of C
      -------------------------------------------------------------------

      Note that the following are equivalent:

              C
              CMPLX(REAL(C),IMAG(C))
              POLAR(ABS(C),PHASE(C))
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 50
      1 January 1978                                                Sec. 7.8


                                NUMERIC FUNCTIONS                                _______ _________

      In this table, "any type" means any non-string type.

      Function     Argument   Result           Description
      -------------------------------------------------------------------
      ABS(X)     | integer | integer |    absolute value
                 |  real   |  real   |
                 | double  | double  |   ABS of complex returns
                 | complex |  real   |   magnitude as real
      -------------------------------------------------------------------
      DBL(X)     | any type| double  |    double precision value of X
                 |         |         | DBL of complex uses real part only
      -------------------------------------------------------------------
      REAL(X)    | any type|  real   |    converts X to real
                 |         |         | REAL of complex returns real part
      -------------------------------------------------------------------
      INT(X)     | any type| integer |    greatest integer less 
                 |         |         |    than or equal to X
                 |         |         | INT of complex uses real part only
      -------------------------------------------------------------------
      IP(X)      | integer | integer |    Integer part of X:
                 |  real   |  real   |    greatest integer less
                 | double  | double  |    than or equal to X
      -------------------------------------------------------------------
      FP(X)      | integer | integer |    Fractional part of X:
                 |  real   |  real   |    X - IP(X)
                 | double  | double  |
      -------------------------------------------------------------------
      FIX(X)     | integer | integer |    X truncated
                 |  real   |  real   |
                 | double  | double  |
      -------------------------------------------------------------------
      ROUN(X)    | integer | integer |    X rounded to nearest integer
                 |  real   |  real   |
                 | double  | double  | If exactly between two
                 |         |         | integers it will round in
                 |         |         | the positive direction
      -------------------------------------------------------------------
      SGN(X)     | any type| integer |  -1 if X<0 , 0 if X=0 , +1 if X>0
                 |         |         | SGN of complex uses real part only
      -------------------------------------------------------------------
      COMP(X,Y) *| integer | integer |  -1 if X<Y , 0 if X=Y , +1 if X>Y
                 |  real   | integer |
                 | double  | integer |
      -------------------------------------------------------------------
      PDIF(X,Y) *| integer | integer |   Positive difference:
                 |  real   |  real   |  X-Y if X-Y>0, else 0
                 | double  | double  |
      -------------------------------------------------------------------
       * If arguments are of different types, the argument with lower type
       is converted to the type of the other argument.
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 51
      1 January 1978                                                Sec. 7.8


                              MAX AND MIN FUNCTIONS                              ___ ___ ___ _________



      These functions return the value of the largest or smallest argument.
      MAX and MIN may be used two ways.  Either with an argument list:


              MAX(X1,X2,X3,...Xn) or MIN(X1,X2,X3,...Xn)

      Or with a FOR loop, some examples:

              MAX( ARRAY(X) FOR X=I TO J )
              MIN( SQR(X) FOR X= ARRAY(I) TO ARRAY (J) )

      The type of the result is the same as the argument with the highest
      type.  Complex arguments are illegal, but string arguments are
      allowed.


                             SUM AND PROD FUNCTIONS                             ___ ___ ____ _________

      These functions return the summation or product of their arguments.
      The arguments are specified with a FOR loop.  For example:

              SUM( ARRAY(I) FOR I = 1 TO 100 )
              PROD( SQR(X)*Y FOR X= I TO J )

      The type of the result is the same as the argument with the highest
      type.  Array arguments are allowed for SUM and PROD.  String
      arguments are allowed with SUM (in which case concatenation is
      performed) but not with PROD.
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 52
      1 January 1978                                                Sec. 7.8


                           MATRIX AND ARRAY FUNCTIONS                           ______ ___ _____ _________

      Function        Value

      INV(A)          Inverse of matrix A; A must be a non-
                      singular square matrix of type real or
                      double precision.

      TRN(A)          Transpose of matrix A

      DET             Single precision value of determinant of
                      last matrix inverted

      ZER             Array of zeros; type real.  TYMBASIC
                      creates an array with the proper
                      dimensionality and size to satisfy
                      the assignment statement in which it appears.

      ZER(n) or       Array of zeroes; type real. TYMBASIC creates a
      ZER(n,m)        temporary array of specified dimensionality and size
                      which may be used as an operand in an expression.

      CON             Array of ones; type real. TYMBASIC
                      creates an array to satisfy the
                      assignment statement, as above.

      CON(n) or       Array of ones; type real. TYMBASIC creates a
      CON(n,m)        temporary array of specified dimensionality and size
                      which may be used as an operand in an expression.

      IDN             Square identity matrix; type real.
                      TYMBASIC creates an array to satisfy
                      the assignment statement, as above.

      IDN(n)          Square identity matrix; type real. TYMBASIC creates
                      a temporary two dimensional array of specified size
                      which may be used as an operand in an expression


      Arguments and results concern arrays, specifically one- or
      two-dimensional arrays.  A matrix is singular if a pivotal element
      less than EPS in absolute value is encountered in INV.
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 53
      1 January 1978                                                Sec. 7.8


                               SHIFTING FUNCTIONS                               ________ _________


      Arguments to the shifting functions must be type integer and do not
      convert automatically.  Values are type integer.


      Function        Value

      LSH(X,N)        X shifted left N bits, with zero fill.
                      If N is negative, X is shifted to the right
                      ABS(N) bits.

      RSH(X,N)        X shifted right N bits; zero fill. If
                      N is negative, X is shifted to the left
                      ABS(N) bits.

      ARSH(X,N)       X shifted right N bits; sign fill.  If
                      N is negative, the sign bit is unchanged
                      and the other bits are shifted to the
                      left ABS(N) bits.

      RCY(X,N)        X cycled N bits to the right if N is
                      positive, or X cycled ABS(N) bits to
                      the left if N is negative
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 54
      1 January 1978                                                Sec. 7.8


                                STRING FUNCTIONS                                ______ _________

      With these functions, S, S1, and S2 denote scalar string expressions,
      N, N1 and N2 denote scalar integer expressions, and R may be a
      numeric or string scalar expression.

      Function        Type         Value

      LENGTH(S)       integer      number of characters in S

      SPACE(N)        string       N spaces

      VAL(S)          real         The number specified by S in free form

      VAL(S1,S2)      real         The number obtained by converting
                                   S1 using the FORM format of S2
                                   (See Sec. 12.4)

      STR(R)          string       R is converted to a string according
                                   to the same rules as free-form output,
                                   observing the type of R (any type ok)

      STR(R,S)        string       R converted to string using the
                                   FORM format S (any type ok)
                                   (See Sec. 12.4)

      LEFT(S,N)       string       The first N characters of S, counting
                                   from the left

      RIGHT(S,N)      string       The last N characters of S, counting
                                   from the right

      SUBSTR(S,N1,N2) string       N2 characters of S, starting with
                                   character number N1

      SUBSTR(S,N)     string       The substring of S starting with
                                   character number N and ending with the
                                   last character of S

      INDEX(S1,S2,N)  integer      The character position of S2 within S1,
          or                       or zero if S2 is not found, searching
      INDEX(S1,S2)                 S1 from its Nth character or its first
                                   character if N is not given

      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 55
      1 January 1978                                                Sec. 7.8


      CHAR(N1 [,N2])  string       A string of length 0-5. N2 default is
                                   5. N2 will be forced to be
                                   in the range 0<N2<=5. CHAR converts the
                                   right most N2 bytes (7 bits each) of N1
                                   to a character string as determined by
                                   current CHARTABLE values. Leading bytes
                                   of zero are ignored (not converted to
                                   null characters). Imbedded and trailing
                                   zeros are converted to CHARTABLE(0).
                                   Bytes are taken from bit 1 to bit 35,
                                   not from bit 0 to bit 34.

      ASC(S[,N])      integer      The collating sequence codes of the
                                   first N characters of S. N default is
                                   5. The codes are right justified as
                                   an integer value. See the examples
                                   after the table.

      COMP(S1,S2)     integer      -1 if S1<S2, 0 if S1=S2, 1 if S1>S2

      LPAD(S,N)       string       S adjusted to a length of N characters
                                   by adding leading spaces if N>LENGTH(S)

      RPAD(S,N)       string       S adjusted to a length of N characters
                                   by adding trailing spaces if NLENGTH(S)

      CPAD(S,N)       string       S adjusted to a length of N characters
                                   by centering S if N>LENGTH(S).
                                   If S cannot be evenly centered,
                                   it is left-centered.

      RPT(S,N)        string       S repeated N times

      RJUST(S)        string       S with trailing spaces deleted

      LJUST(S)        string       S with leading spaces deleted

      COUNT(S1,S2)    integer      The number of times S2 occurs in S1

      Assuming the normal collating sequence, here are some examples of the
      ASC function:

              ASC('A') = 101B
              ASC('A',5) = 101B
              ASC('AB') = 20302B
              ASC('AB',2) = 20302B

      See also Section 5.6, System-defined Variables.
      TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES    Page 56
      1 January 1978                                                Sec. 7.8


                                UTILITY FUNCTIONS                                _______ _________

      Function        Type         Value

      RND(X)          real         A pseudo-random number in the range
        or                         [0,1). The derivation of the random
      RND                          number sequence depends on whether X is
                                   positive or negative when the sequence
                                   is initiated. If X is positive, its
                                   specific value determines the first
                                   number generated; if X is negative,
                                   the internal clock determines
                                   the first number generated. RND(0) or
                                   RND is used to generate succeeding
                                   random numbers from the sequence started
                                   with a positive or negative X. RND
                                   will not generate a random sequence if
                                   iteratively called with a non-zero
                                   argument.
      POS             integer      The position of the next character to be
                                   printed; the terminal print position
      POS(N)          integer      Position on file N.  See Section 11.3.
      TAB(N)          string       A string of spaces sufficient to tab to
                                   print position N at the terminal.
      TAB(N1,N2)      string       A string of spaces sufficient to tab to
                                   print position N1 on file N2.
      DATE            string       A string of 15 characters indicating the
                                   date and time of day as follows:
                                   YY/MM/DD  HH:MM
      TIME            integer      An integer incremented every sixtieth of
                                   a second; during a session, it always
                                   increases and is never reset to zero.
      TCP             logical      FALSE if no command file is open or TRUE
                                   if a command file is open.
      TERM            logical      TRUE if terminal input awaits processing
                                   and FALSE if not.
      LOC(N)          integer      The current location on file N.
                                   See Section 11.3.
      SIZE(N)         integer      The size of the open file N.
                                   See Section 11.3.
      YEAR            string       The current year as four characters.
      ERRCD           integer      The number of the most recent error
                                   detected by TYMBASIC or 0 (zero)
                                   if no errors have been detected.
                                   See the ON-condition statement.
      ERRFL           integer      The file unit number associated with the
                                   most recent end-of-file or file error
                                   or 0 if no file errors have been
                                   detected.
      ERRLN           integer      The number of the statement where the
                                   most recent error occurred or 0 if none.
      ERRMSG(N)       string       The message associated with error number
                                   N as returned by ERRCD above, which need
                                   not have occurred. See Appendix B.
      TRU             real         The total number of TRUs used
                                   since logging in.
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 57
      1 January 1978                                                Sec. 8.1


                             SECTION 8     EXECUTION


      8.1 OVERVIEW      ___ ________


      Entering, compiling, loading and executing a TBA program involves
      four phases of the TBA system, and four corresponding phases of
      system/user interaction:

          1.  The Command/Statement phase, in which TBA commands and
              statements are entered and individually (and immediately)
              analyzed for syntactic regularity, and a list of modules may
              be specified.

          2.  The Compile phase, in which a relocatable version of each TBA
              module is generated and analyzed for global coherence.

          3.  The Load/Initialize phase, in which the loader creates a core
              image (program) from the relocatable modules, and variables
              are initialized.

          4.  The Run phase, in which execution is transfered to the user's
              program.

      Each phase need not be explicitly called.  In the sequence

              -TBA
              Ver. 4.0
              >10 A = 1
              >20 Print A
              >30 END
              >RUN
              1
              END IN 30
              >

      The RUN command issued in phase 1 initiates the three succeeding
      phases.  Effects of the commands associated with execution and code
      listing are shown below.
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 58
      1 January 1978                                                Sec. 8.1


         Command      Effect:                  Remarks
      
                      Compile  L/I   Run
      
         PMC                                   lists intermediate code
                                               generated by parser
      
         CDE              X                    compiles the workspace
                                               module, lists a MACRO-like
                                               version of the code
      
         SAVE BINARY      X     X              compiles and loads program,
                                               does not execute, no
                                               continue point defined
                                               (GO and STEP will not work)
      
         INITIALIZE       X     X              compiles,  loads and
                                               initializes program,
                                               does not execute, but does
                                               define a continue point
                                               (GO and STEP will work).
      
         RUN              X     X      X       compiles, loads, initializes
                                               and transfers execution
                                               to program.
      
         DIRECT STATEMENT X     X      X       compiles, loads, initializes
                                               if the program requires it,
                                               and transfers execution to
                                               the direct statement.
      
         GO                            X       restarts execution at the
                                               continue point
      
         STEP                          X       restarts execution at the
                                               continue point
      
         START                         X       restarts execution at the
                                               start of the program without
                                               losing valid data
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 59
      1 January 1978                                                Sec. 8.2


      8.2 THE COMMAND/STATEMENT PHASE      ___ ___ _________________ _____

      The user enters the Command/Statement phase by entering the Xexec
      command:

              -TBA

      The TYMBASIC system is called, prints the TYMBASIC version number,
      and issues a > prompt, which indicates a readiness to accept commands
      or statements.  The user's TYMBASIC workspace module is created, into
      which the user's indirect statements are entered.  The workspace
      remains unnamed until either a

              GET file nomen

      or a

              SAVE file nomen

      command is executed, whereupon file nomen (less confirmation) names
      the workspace.  The workspace may also be named as a side effect of
      the Compilation phase.  Execution of a

              DEL ALL

      command unnames the workspace as well as deleting its contents.

      Each command or statement entered during this phase is analyzed for
      syntactic regularity by the parser, and diagnostics are issued as
      necessary.  Parser output is the intermediate code that is displayed
      with the PMC command.  No check is made in this phase for the
      correctness of program logic (the relation of a statement to any
      other statement).

      When entering commands and statements at the ">" level, the old line
      image is the last line typed in response to the ">".

      In the Command/Statement phase, the user may create a module list and
      a library list.


      THE MODULE LIST      ___ ______ ____

      The names of the modules to be loaded into the program are kept in a
      module list.  If the module list is empty, then only the workspace
      module will be loaded.  The module list contains the names of
      TYMBASIC source and relocatable modules and the names of
      other-language relocatable modules.  During the Compilation Phase,
      the TYMBASIC source modules are compiled to produce relocatable
      modules (any module whose extension is not .REL or .RDL is assumed to
      be a TYMBASIC source module).  The user's workspace may or may not be
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 60
      1 January 1978                                                Sec. 8.2


      included in the module list.  Modules in the module list are always
      loaded, whether they are actually referenced or not.  Current
      contents of the module list can be listed with the LIST MODULE[S]
      command, and modules may be added to or deleted from the module list
      by the [NO] MODULE command, and indirectly by the Compilation phase.


      THE LIBRARY LIST      ___ _______ ____

      The user may create a list of libraries to be searched by the loader
      for procedures that are referenced by modules already loaded.
      Libraries are added or deleted from the library list with the LIBRARY
      or NO LIBRARY command;  libraries can be listed with the LIST
      LIBRARIES command.  Each user library contains one or more
      relocatable modules, grouped for convenience.  Modules in a library
      will be loaded only if required to satisfy references to procedures
      contained within them.  The user's libraries are searched in the
      order of the library list.  Each library is searched only once,
      sequentially, for modules that contain procedures that have been
      referenced from modules already loaded.

      Thus, the order in which the libraries appear on the library list is
      important.  If a procedure in library A calls a procedure in library
      B, library B must follow library A in the library list.



      8.3 THE COMPILATION PHASE      ___ ___ ___________ _____

      The Compilation phase is entered by a direct statement or any of
      these TYMBASIC commands:

              INITIALIZE
              CDE
              RUN
              SAVE BINARY

      All of the above, except CDE (which compiles the workspace and then
      returns to the Command/Statement phase) create a program, and for
      this reason invoke a process called Global Recompilation that
      prepares for the Load/Initialize phase.

      There are two modes in which Global Recompilation operates:

           1.  The module list is empty and the program will consist of the
               workspace module.

           2.  The module list is not empty and the program will consist of
               the modules on the module list.

      The first mode is similar to the operation of most other BASIC
      systems, and will be discussed first.
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 61
      1 January 1978                                                Sec. 8.3


      EMPTY MODULE LIST      _____ ______ ____

      If the workspace is empty, the error message "No program" is printed
      and the command or direct statement is aborted.

      Otherwise, the workspace module is compiled to create a relocatable
      module.  The extension for the relocatable module is .REL if the
      workspace is in the NO DEBUG state, else it is .RDL.  If the
      workspace has no name, then a temporary relocatable module is
      created.

      Any compilation errors abort the process and return the user to the
      Command/Statement phase.

      NON-EMPTY MODULE LIST      _________ ______ ____

      If the workspace is empty and no startpoint module has been specified
      (meaning that the workspace is the startpoint), the error message "No
      program" is printed and the command or direct statement is aborted.

      Adding the Workspace to the Module List      ______ ___ _________ __ ___ ______ ____

      If the workspace is not empty and does not appear exactly on the
      module list (comparing user name, file name, and extension), then the
      user is given the opportunity to add the workspace to the module list
      (and name it in the process, if necessary).

      The workspace will be included in the program ONLY IF it appears on
      the module list.

      If the workspace is in fact not on the module list, TYMBASIC will
      ask:

              Add workspace to module list?

      If the response is N[O], Global Recompilation continues, and the
      workspace will not be loaded in the Load/Initialize phase and
      therefore will not be part of the program.  If the response is Y[ES],
      then the workspace name is added to the module list.  If unnamed,
      TYMBASIC prompts:

              Name:

      and the user gives the workspace name (note that a SAVE is not
      automatically executed to the file with this name).  The user may
      also answer "AS file nomen" to the "Add workspace" question, which
      implicitly answers affirmatively and names the workspace at the same
      time.

      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 62
      1 January 1978                                                Sec. 8.3


      Checking for a Valid Startpoint      ________ ___ _ _____ __________

      After it has been determined whether or not the workspace will appear
      on the module list, a check is made that the startpoint module is on
      the module list.  If it is not, TYMBASIC prints

              STARTPOINT not element of program

      and aborts the command.  If a direct statement was given, the check
      is still made despite the fact that execution begins with the direct
      statement.

      Compilation of Modules      ___________ __ _______

      In the next phase of Global Recompilation, every TYMBASIC source
      module on the module list is compiled, if necessary, to create a
      corresponding relocatable module (in this context, compilation also
      includes line-by-line parsing).  Any module whose extension is not
      .REL or .RDL is assumed to be a TYMBASIC source module.  If a
      relocatable module is newer than its corresponding source module, the
      source module will not be compiled.  If it is older or none exists,
      the source module will be compiled.  For each module compiled,
      TYMBASIC prints

              TBA:

      followed by the file name.  If an unnamed workspace is compiled, the
      name will appear as "WRK.SP".

      If the source module is in another directory (user name) then that
      directory is searched for the corresponding relocatable module newer
      than the source module;  if not found, the current directory is
      searched.  If none can be found, then one is created in the current
      directory by compilation of the source module.

      The extension for a relocatable module is .REL if compiled in the
      NO DEBUG state (default) and .RDL if compiled in the DEBUG state.

      If a direct statement was entered, it is compiled in the same debug
      state as the workspace, producing a temporary relocatable module.

      The workspace module will be compiled if any other modules were
      compiled in the current invocation of Global Recompilation (not
      counting the direct statement module).

      Global errors involving two or more statements in a module may be
      detected during compilation of that module;  a fatal error will end
      compilation of that module but compilation of other modules will
      proceed.  However, when Global Recompilation is complete, control
      will pass back to the Command/Statement phase rather than to the
      Load/Initialize phase.
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 63
      1 January 1978                                                Sec. 8.4


      8.4 THE LOAD/INITIALIZE PHASE      ___ ___ _______________ _____


      The Load/Initialize phase includes loading of the relocatable modules
      in the user's module list (or the workspace module if none), plus the
      loading of any other modules needed, from the user's libraries and
      the TYMBASIC Run Phase System Library, in that order.

      Note:  System file handling facilities should not be used to rename
      relocatable files, or combine modules;  the loader expects to find
      exactly one module name embedded in each relocatable file loaded as a
      module, and it expects the module and file names to match.

      INITIALIZATION      ______________

      During initialization, the following occurs:

          Variables defined within TBA modules are given initial values
          (see Sec. 5.2), and system-defined variables (see Sec. 5.6) are
          initialized to their default values.

          NEXT statements are set to fall through when branched to.

          Array variables are set to generate an error condition if
          referenced prior to execution of the array declaration.

          Files are closed except for command and TOUT files.

          Error traps are unset and ERRCD, ERRFL, and ERRLN are set to
          zero.

          GOSUB's are deactivated (all return locations are cleared).

          BASE value is set to 1.

          BOUNDARY is set to 0.

          SIGNIFICANCE value is set to 14.

          The Random number seed is initialized.

          DET value is set to 0.

      After completion of the Initialization phase, the program is said to
      contain valid data (in variables), until some modification is made to
      the program (see below).  While the program contains valid data, the
      data may be accessed by a direct statement and the START command is
      also allowed.
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 64
      1 January 1978                                                Sec. 8.5


      8.5 THE RUN PHASE      ___ ___ ___ _____

      The RUN phase transfers execution to the startpoint module.

      END OF EXECUTION      ___ __ _________

      Execution continues until 

           1.  the end of the program or execution of a STOP or END
               statement

           2.  execution of a QUIT or LOG statement

           3.  end of the direct statement if one was entered

           4.  execution of a PAUSE statement

           5.  a breakpoint is encountered

           6.  an error condition occurs which the program does not trap

           7.  one or more escapes is typed

           8.  The STEP count is exhausted


      In the first case, control returns to the Command/Statement phase.
      User files are closed, but data values are retained in variables, and
      can be accessed by a direct statement (i.e., the program contains
      valid data).

      In the second case, control leaves the TYMBASIC system, returning
      either to XEXEC or ending the session entirely.

      When execution of a direct statement terminates, control returns to
      the Command/Statement phase, but no files or closed nor any data
      lost.

      Interruptions And Continuability      _____________ ___ ______________

      For the remaining cases, the program is interrupted and control
      returns to the Command/Statement phase.  An interrupted program is
      continuable;  that is, it may be continued by the use of the GO or
      STEP commands.  Each of the interruption conditions defines a
      continue point, which is the line to which the GO or STEP commands
      will transfer execution.

      If the program has been initialized but not run (with the INITIALIZE
      command), the continue point is the same as the startpoint:  the
      first line in the startpoint module.
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 65
      1 January 1978                                                Sec. 8.5


      If an interruption results from a PAUSE statement, the continue point
      is the point immediately after the PAUSE.

      If an interruption results from a breakpoint being encountered, the
      continue point is the beginning of the statement at which the
      breakpoint was set.

      If an interruption results from a single escape, the current
      statement completes execution and the continue point is the next
      statement in the program.

      If an interruption results from two or more escapes, execution of the
      current statement is interrupted, and the continue point is the
      beginning of that statement.

      Program Modification      _______ ____________

      While in the Command/Statement phase, valid data contained in
      variables is retained and the program remains continuable until some
      part of the program is modified.  A program modification may be any
      of the following:

            *modifying any module, including the workspace
            *changing the DEBUG state for any module
            *adding or deleting a module or library

      TYMBASIC always asks the user for confirmation before allowing him to
      make a program modification that will lose valid data.

      If the program contains valid data and the last statement executed
      lies within the workspace module, then a direct statement will be
      compiled in the same context as that statement.  That is, those
      variables known at that line in the workspace module are the ones
      accessible to the direct statement (see Sec. 7.5).
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 66
      1 January 1978                                                Sec. 8.5


      8.6 COMMAND FILES      ___ _______ _____

      Command files permit TYMBASIC to take its commands and terminal input
      from a file rather than from the terminal.  A command file may be
      called by either the DO command, or the OPEN statement with * or -1
      as the file unit number.

      If another command file is called while a command file is open, input
      is taken from the new file until its end and then TYMBASIC resumes
      taking input from the first file where it left off.  Command files
      may be stacked in this way up to ten levels.


      ECHOING OF COMMAND INPUT      _______ __ _______ _____

      During execution of a command file, the command input is not normally
      printed (echoed).  Of course, if command input is from the terminal
      (which may be opened as a command file from another command file),
      the command input and the prompts and messages associated with it are
      printed at the terminal.

      However, if echoing is being done (see the ECHO command), command
      input and the prompts and messages associated with it will be
      printed, either at the terminal or on the TOUT file if one is open
      (see the TOUT command).  For example:

              >DO COM1        !Commands in COM1 are not printed
              >ECHO
              >DO COM2
              >MODULES A,B    !These are commands from COM2.  The commands
              >LIBRARY C      !and prompts are printed because ECHO is on.
              >

      The state of echoing applies to the current command file and to
      command files it calls.  Suppose, for example, that echoing is on
      during the execution of one command file and another command file is
      called.  Then echoing continues for the second command file, unless
      it turns echoing off.  If it does, then echoing remains off until the
      end of the second command file.  At this point, execution returns to
      the first command file and the state of echoing is automatically
      reset on, as it was when the first command file transfered execution
      to the second.

      The end of file for the terminal opened as a command file is
      signified by typing an ampersand (&) alone on a line.

      Command files (and TOUT files) remain open across the different
      phases of the TYMBASIC system, so that a command file opened in the
      Command/Statement phase will remain open in the Run phase.  Normal
      input done by statements in the Run phase with the INPUT statement
      will input from the current command source, be it either the terminal
      TYMBASIC REFERENCE MANUAL               EXECUTION             Page 67
      1 January 1978                                                Sec. 8.6


      or a command file.


      ERRORS DURING COMMAND FILE EXECUTION      ______ ______ _______ ____ _________

      If an error occurs during execution of a command file, all command
      files are closed until the terminal is again the command source.
      TYMBASIC will print the error message, then the last line read from
      the command file, then

              At line n in name

      for each command file closed, where n is the number of the last line
      input from the command file and name is the name of the command file.

      Certain conditions are considered warnings, rather than errors, and
      in this case execution of the command file proceeds.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 68
      1 January 1978                                                Sec. 9.1


                             SECTION 9.  STATEMENTS



      This section provides the syntax, semantics, and examples of the
      TYMBASIC statements, arranged in alphabetical order.  A concluding
      section discusses the six statement modifiers.

      Symbols used in the syntax:

                      n              The letter n indicates an integer-
                                     valued expression.  Several fields
                                     are indicated by numbers:
                                     n1, n2, etc.

                      s              string expression

                      r              real expression

                     id              identifier (see Sec. 4.1.)

                     ln              line number

                    list             List following a metasymbol indicates
                                     one or more entries may be made
                                     separated by commas.

                   variable/         List of variables and dimension
                   dimension         specifications for declaration
                    list             statements (see Sec. 5.3.)

                   input list        List of variables (arrays,
                                     simple variables, array elements,
                                     subarrays or subarray names)

                   text              any string of characters up to
                                     a carriage return
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 69
      1 January 1978                                                Sec. 9.1


      9.1  STATEMENT DESCRIPTIONS      ___  _________ ____________


      BASE      ____

      Syntax:

              BASE n

      Semantics:

      The BASE statement changes the default lower bound for array
      dimensioning to n for the current module only.  n may be positive,
      negative, or zero.  The default lower bound is initially 1.  For
      example:

              10 BASE 5
              20 REAL A(20,M)

      is equivalent to:

              10 REAL A(5:20, 5:M)


      BOUNDARY      ________

      Syntax:

              BOUNDARY r

      Semantics:

      The BOUNDARY statement causes values of magnitude less than the real
      value r to be written as zero for every module in the program;  it
      applies only to free-form output.  (Note that r must be >= 0).  For
      example:

              10 BOUNDARY 1E-3
              20 X=-2/10000
              30 PRINT "X=":X

              >RUN
              X= 0


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 70
      1 January 1978                                                Sec. 9.1


      CALL      ____

      Syntax:

              CALL id [(expression list)]

      Semantics:

      The CALL statement transfers control to the procedure named by the
      identifier;  any specified arguments are passed to the procedure.
      When the procedure exits, control returns to the point immediately
      following the call.  For example, suppose a program contains the
      following procedure:

              500 DEF PRINTSTARS(N)
              510 PRINT "****" FOR i=1 TO  N
              520 EXIT
              530 ENDF PRINTSTARS

      Then the line

              200 CALL PRINTSTARS(10)

      causes a column of four asterisks ten lines long to be printed.  See
      also Section 7.4.


      CIB      ___

      Syntax:

              CIB

      Semantics:

      The CIB statement clears the terminal input buffer (both the
      monitor's and TYMBASIC's).


      CLOSE      _____

      Syntax:

              CLOSE n1[,n2...]

      Semantics:

      The CLOSE statement closes each file having the file unit number
      specified by each expression if a file is open on that file unit
      number.  CLOSE 0 restores normal terminal input after an
      OPEN...BINARY...0 statement has opened the terminal for eight-level
      input.  CLOSE * (or CLOSE -1) closes the command file (if any).  For
      example:

              100 CLOSE 3,17,M+2
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 71
      1 January 1978                                                Sec. 9.1


      COB      ___

      Syntax:

              COB

      Semantics:

      The COB statement clears the terminal output buffer by discarding any
      characters in the TYMBASIC output buffer and causing any characters
      en route to the terminal to be discarded.


      COMPLEX      _______

      Syntax:

              COMPLEX variable/dimension list

      Semantics:

      The COMPLEX statement declares complex variables and dimensions
      complex array variables (see also Sec. 5.3).  For example:

              10 COMPLEX IVAL$, STRESS$, XTABLE(8,4)


      COPY      ____

      Syntax:

              COPY s1 TO s2

      Semantics:

      The COPY statement copies the contents of the file with file nomen
      specified by s1 onto the file with file nomen specified by s2.  If s2
      specifies the terminal, then s1 is printed at the TOUT destination
      (usually the terminal).  If s1 specifies the terminal, then data
      entered from the command source (usually the terminal) is copied onto
      s2.  An & alone on a line will terminate data entry from the command
      source.  Examples:

              100 COPY FINAL1$ TO FINAL2$
              100 COPY "FILEX" TO A$+B$
              100 COPY "SUMFIL" TO "TERM"

      COPY to or from the terminal is symbolic (character-by-character).
      However, one file may be copied to another without any restrictions
      on its contents.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 72
      1 January 1978                                                Sec. 9.1


      DATA      ____

      Syntax:

              DATA text

      Semantics:

      The DATA statement supplies symbolic data, which is read as free-form
      input in READ statements.  The data is sorted in order of increasing
      line numbers into a single data block, with data from each statement
      separated by a comma.  Data blocks for each module in the program are
      kept separately.  For example:

              100 DATA "XYZ", 12.3 3D-9
              110 DATA 10E-3, "LITERAL"
              120 DATA 42

      is equivalent to:

              100 DATA "XYZ", 12.3, 3D-9, 10E-3, "LITERAL", 42

      Data is stored symbolically and the appropriate value is created at
      the time a READ statement occurs.  Comments are not allowed in DATA
      statements.  DATA statements are not executable.


      DEF[INE]      ________

      Syntax:

      The DEF statement syntax is given in Section 7.3.

      Semantics:

      The DEF statement defines user-written procedures.  There may be as
      many as 511 user-defined procedures.  See Section 7 for a full
      description of user-defined procedures.

      If a DEF statement is reached by falling through or by a GOTO
      statement, the procedure is branched around:  the next executable
      statement after the ENDF (or after a single-line DEF) is executed.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 73
      1 January 1978                                                Sec. 9.1


      DIM      ___

      Syntax:

              DIM variable/dimension list

      Semantics:

      The DIM statement dimensions array variables whose types are
      determined implicitly by variable name (see also Sec. 5.3).  For
      example:

              50 DIM RATIOS(4,1000,P*Q),DAT$(0:4,-2:M,7)

      Any string dimensioned in a DIM statement has a maximum string length
      of 4095 characters, since no length field is permitted in the DIM
      statement.


      DOUBLE      ______

      Syntax:

              DOUBLE variable/dimension list

      Semantics:

      The DOUBLE statement declares double precision variables and
      dimensions double precision arrays (see also Sec. 5.3).  For example:

              10 DOUBLE EXACTA(100,M:N),NUM$,BER(3,4)


      EIGHTI      ______

      Syntax:

              EIGHTI input list

      Semantics:

      The EIGHTI statement accepts eight-level terminal input characters
      and assigns them to the named scalars, which must be declared
      integer.  TYMBASIC does not prompt for input.  Before an EIGHTI
      statement will be allowed to execute, the following statement must
      have been executed:

              OPEN "TERMINAL" FOR BINARY INPUT AS FILE 0

      No normal terminal input is allowed until CLOSE 0.  Normal terminal
      output occurs during EIGHTI mode.  The TERM function continues to
      operate during EIGHTI mode, but input characters are not echoed.

      Echoing is turned on by a CLOSE statement with a file number of zero.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 74
      1 January 1978                                                Sec. 9.1


      EIGHTO      ______

      Syntax:

              EIGHTO integer expression list

      Semantics:

      The EIGHTO statement prints an eight-level character at the terminal
      for each integer value given in the list.


      END      ___

      Syntax:

              END [expression]

      Semantics:

      The END statement terminates program execution, closes all files
      (except for command and TOUT files), and prints any specified
      expression or END IN line number.  For example:

              100 END "JOB DONE"


      ENDF      ____

      Syntax:
              ENDF  id

      Semantics:

      ENDF signifies the end of the user-defined procedure named by the
      identifier.  If an ENDF is executed, an EXIT with null value occurs.
      See the DEF and EXIT statements.


      ENDIF      _____

      Syntax:

              ENDIF

      Semantics:

      The ENDIF statement ends an extended IF statement (see IF).
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 75
      1 January 1978                                                Sec. 9.1


      ERASE      _____

      Syntax:

              ERASE n FROM n1 TO n2

      Semantics:

      The ERASE statement erases locations n1 through n2 in the file with
      unit number n,which must be a RANDOM file open for OUTPUT or IO, but
      not for input.  The erasure is done by filling with nulls (zeroes)
      for binary files or spaces for symbolic files, except when erasing to
      or beyond the end of the file in which case nulls are always used.
      For example:

              400 ERASE 3 FROM 100 TO 125

      See Section 11.5.


      EXIT      ____

      Syntax:

              EXIT [expression]

      Semantics:

      The EXIT statement transfers control to the point immediately
      following a procedure call.  If EXIT is followed by an expression,
      the value of the expression is returned as the value of the procedure
      (as with a function).  If the expression is omitted, a zero, for
      numeric or logical valued procedures, or a null string, for string
      valued procedures, is returned.  A CALL statement ignores the
      returned value.  The EXIT causes space allocated for string and array
      parameters to be released (see Sec. 7.5.).  Example:

              EXIT (A-B)*2
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 76
      1 January 1978                                                Sec. 9.1


      FOR      ___

      Syntax:

      FOR iteration variable = iteration part [,iteration part ...]
      
      .
      .
      .
      NEXT iteration variable

      The iteration variable must be a simple scalar variable of type
      integer, real, or double.  Its scope is not limited to within the FOR
      loop;  that is, it may be referenced outside of the FOR loop.

      Iteration part, syntax:

      
      
                 BY         UNTIL logical expression
                      n2    WHILE logical expression
                 STEP       TO   n3
           n1
      
                              BY
                     TO  n3  STEP  n2

      n1, n2 and n3 are numeric expressions;  default for n2 is +1.

      Semantics:

      The FOR Statement executes one or more statements repeatedly over a
      range of values for the iteration variable:  it is initially set to
      n1, and its limit value is determined by the UNTIL, WHILE, or TO
      clause.  When there is more than one iteration part, any following
      iteration part is invoked only after the preceeding iteration part is
      exhausted.

      When an iteration part is invoked, n1, n2 and n3 are evaluated.  n1
      is then stored into the iteration variable.  At this point, a FOR
      Test is made, and if its value is TRUE the FOR loop begins execution.

      If the TO n3 clause is used, as in:

              FOR i= n1 BY n2 TO n3

      the value of the FOR Test is:

              SGN(n2)*i > SGN(n2)*n3,
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 77
      1 January 1978                                                Sec. 9.1


      where i is the iteration value defined below.

      If the WHILE or UNTIL clause is used, as in:

              ...n1 BY n2 UNTIL logical expression

      then the value of the FOR Test is either the value of logical
      expression for WHILE, or NOT logical expression for UNTIL.

      When the NEXT statement is executed, an iteration value is computed
      that is the sum of the current value of the iteration variable and n2
      (as computed when the iteration part was invoked).  If either a WHILE
      or UNTIL clause was used in the current iteration part the iteration
      value is stored immediately into the iteration variable.  Otherwise,
      the iteration value is stored only if the value of the FOR Test,
      which is now made, is TRUE.

      In any case, if the value of the FOR Test was TRUE the FOR loop body
      is executed.  If FALSE, the current iteration part is exhausted.

      Therefore, the following hold for FOR statements:


           1.  If a FOR statement is executed, it will always store an
               initial value into the iteration variable.

           2.  Changes to the iteration variable within the loop body do
               affect the loop decision logic.

           3.  The loop test is made before execution of the loop body;  it
               is possible to execute the FOR statement but not the loop
               body.

           4.  After execution of a FOR loop, the iteration variable
               contains the first value for which the logical expression
               was not satisfied if WHILE or UNTIL, or the last value for
               which the loop was executed if TO.

           5.  n1, n2 and n3 are evaluated only once for each iteration
               part.  The default value for n2 is +1.


      FOR-NEXT loops may be nested to any depth.

      A GOTO may branch into a FOR loop even though the FOR statement
      itself has not been executed.  When the NEXT statement is reached,
      the iteration variable does not change and control passes on as if
      the entire loop had been exhausted.


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 78
      1 January 1978                                                Sec. 9.1


      GO SUB
      GOSUB      _____

      Syntax:

               GO SUB
               GOSUB    ln

      Semantics:

      The GOSUB statement transfers control to the subroutine at the
      specified line number.  Subroutine calls may be nested to any depth.
      TYMBASIC allows recursion for GOSUBs, but variables are not
      automatically saved or restored at each recursion level.  A GOSUB may
      cross the boundaries of a user-defined procedure.  GOSUB and GO SUB
      are equivalent.  The end of the subroutine is indicated by a RETURN
      statement, execution of which transfers control to the point
      immediately after the GOSUB.


      GO TO
      GOTO      ____

      Syntax:

              GOTO
              GO TO   ln

      Semantics:

      The GOTO statement transfers control to the specified line number.
      GOTO and GO TO are equivalent.


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 79
      1 January 1978                                                Sec. 9.1


      IF      __

      Syntax:

      IF logical expression THEN ln1        [ELSE ln2       ]
                                 statement1       statement2

      Semantics:

      The IF statement transfers control or executes a specified statement
      depending upon the value of the logical expression.  If the
      expression is TRUE then either statement1 is executed or control
      passes to the first line number.  If the expression is FALSE then
      either statement2 is executed or control passes to the second line
      number;  if the ELSE clause is omitted then the next statement in the
      program sequence is executed.  All parts of a logical expression are
      evaluated, even when its final value could be determined during
      evaluation.

      Statement1 and statement2 must either be modifiable (see Sec. 9.2) or
      be further IF...THEN and IF...THEN...ELSE statements, which may be
      nested to any depth.  For example:

              10 IF X=3 THEN IF F>20 THEN 200 ELSE 300 ELSE PRINT "HELP"

      An ELSE is matched with the nearest unmatched IF.

      There is a difference in action between an IF...THEN I/O statement
      and an I/O statement followed by an IF modifier.  For example:

              IF X=0 THEN PRINT ON Z AT N:Y

      does not reposition file Z to N when X does not equal 0, whereas

              PRINT ON Z AT N:Y IF X=0

      does.  The statement modifier applies only to the I/O list.


      IF (Extended)      __ __________

      Syntax:

              IF logical expression THEN
                  .
                  . statements
                  .
              [ORIF logical expression THEN]
                  .
                  . statements
                  .
              [ELSE]
                  .
                  . statements
                  .
              ENDIF
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 80
      1 January 1978                                                Sec. 9.1


      Semantics:

      The extended IF executes a group of statements selected according to
      the evaluation of one or more logical expressions.  Statements
      following an ORIF clause are executed if its logical expression is
      TRUE and if all preceding logical expressions are FALSE.  There may
      be any number of ORIF clauses.  Statements following the ELSE clause,
      if present, are executed if all preceding expressions are FALSE.

      At most, only one set of statements (subpart) of an extended IF is
      executed.  The conditions are evaluated only until one is satisfied.

      Extended IF's may be nested.  There may not be any ORIF's following
      an ELSE clause, except those in a nested IF.

      A branch to an ORIF or ELSE line branches to just past the ENDIF
      line.  A branch to within a set of statements controlled by an
      extended IF, ORIF, or ELSE completes execution of the entered
      subpart, then branches to just past the ENDIF line.


      IIF (abbreviation for INPUT IN FORM)      ___


      IIM (abbreviation for INPUT IN IMAGE)      ___


      INPUT      _____

      Syntax:

              INPUT input list

      Semantics:

      The INPUT statement accepts free-form input from the command source,
      assigning the entered values to the variables specified in the list.
      The command source is normally the terminal, but may be a command
      file (see the DO command and the OPEN statement).  Arrays and scalars
      may appear in the input list in any combination.  The old line image
      for terminal editing is the last line typed in response to an INPUT
      statement.  See Section 12.3 for a discussion of free-form input.

      An example is:

              INPUT A$, RATES (3,8), XARRAY$
              ? "RANDOM" 25.3
              ? "FIRST"Gc "SECOND", "THIRD"Gc "FOU,RTH"


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 81
      1 January 1978                                                Sec. 9.1


      INPUT FROM      _____ ____

      Syntax:

              INPUT FROM n [AT n1]:  input list

      Semantics:

      The INPUT FROM statement assigns values from file with unit number n
      (which must be open) to the listed variables.  The AT clause applies
      only to random files:  n1 is an integer expression whose value
      specifies the location from which the first value is read (see
      Sec. 11.3).  For example:

              50 INPUT FROM 3 AT 10:  X,Y,FOO$(1:5)


      INPUT IN FORM
      INPUT IN IMAGE      _____ __ _____

      Syntax:
                                          FORM
              INPUT  [FROM n [AT n1]] IN  IMAGE  s : input list

      Semantics:

      The IN FORM and IN IMAGE clauses specify formatting.  The string
      expression is the format used for the input conversion.  See Section
      12 for a discussion of formatted input.


      INTEGER      _______

      Syntax:

              INTEGER variable/dimensions list

      Semantics:

      The INTEGER statement declares integer variables and dimensions
      integer array variables (see also Sec. 5.3).  For example:

              50 INTEGER EMPNO,B$(50)
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 82
      1 January 1978                                                Sec. 9.1


      LET      ___

      Syntax:

              [LET] assignment list

      The assignment list is a list of one or more assignments of the
      following forms:

              input list = expression
              variable == variable

      Semantics:

      The first form of an assignment (input list = expression) stores the
      value of the expression into the listed variables.  For example,

              10 I = 5
              20 I, J, K = 5

      The second form of an assignment (variable == variable) exchanges the
      values of the two variables.

      The two forms of assignments may be strung together into a list.  For
      example,

              10 A,B = C*2, D == E(4), F,D = FUNC(G)

      Scalar and array assignments may appear in any combination in the
      assignment list.

      The assignments in the assignment list are executed from left to
      right.  However, within a compound assignment (e.g., I,J = 5) the
      assignments are executed from right to left.  Within any assignment,
      all subscripts for variables on the left of the equal sign are
      evaluated prior to evaluation of the expression.  For example,

              10 I = 5
              20 B(I), I = 10

      Line 20 stores 10 into I and into B(5).

      The type of the value to be stored is converted to the type of the
      receiving variable, if possible (see Type Conversion, Sec. 3.2).

      For array assignment the number of elements must be the same.  For
      string assignment, a value longer than the declared maximum length of
      the receiving string variable will be truncated to that length.

      The word LET is optional and is provided for compatibility with other
      BASICs.

      Note that A=B=C does NOT store C into A and B, but rather evaluates
      the logical expression B=C and stores either true or false into A.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 83
      1 January 1978                                                Sec. 9.1


      LOCATE      ______

      Syntax:
                             *
              LOCATE n1  ON  n2

      Semantics:

      The LOCATE statement makes n1 the current location on random file n2.
      For a variable length record file the location is a data unit number:
      a character number in symbolic files, a word number in binary files.
      For a fixed length record file the location is a record number.  The
      LOCATE statement sets the position function POS to 1 for that file.
      The specified location may be greater than the current size of the
      file (see Sec. 11.3).


      LOG      ___

      Syntax:

              LOG [expresssion]

      Semantics:

      The LOG statement halts program execution, closes all files, and ends
      the user's entire session at the terminal.  Logout information is
      printed as well as any expression given after the word LOG.  For
      example:

              100 LOG "FINIS"


      LOGICAL      _______

      Syntax:

              LOGICAL variable/dimension list

      Semantics:

      The LOGICAL statement declares logical variables and dimensions
      logical array variables (see also Sec. 5.3).  For example:

              10 LOGICAL BOOLE, SWITCH(4)


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 84
      1 January 1978                                                Sec. 9.1


      LOL      ___

      Syntax:

              LOL n

      Semantics:

      The LOL statement sets the line length to n characters for free-form
      output for all modules in the program (see Sec. 12.3).  The initial
      LOL is taken from the user's terminal characteristics.  For example:

              100 LOL 125

      The LOL statement modifies the user's terminal characteristics.  LOL
      affects output to a file as well as to the terminal.  The LOL
      specification remains in effect until another LOL is executed.  If a
      number greater than 256 is specified, LOL is set to 256;  if a number
      less than or equal to zero is specified, LOL is not changed.


      MAT      ___

      Syntax:

              MAT statement

      Semantics:

      The MAT statement indicates matrix multiplication or exponentiation
      rather than element-by-element.  MAT prefixed to a line will
      effectively change all * operators to MUL and all ** or ^ operators
      to PWR.  For example:

              MAT A = B*(C**D)

      compiles as

              A = B MUL (C PWR D)

      MAT may precede any statement;  it cannot be used within an
      expression.

      Legal:

              MAT INPUT B
              MAT READ A
              MAT PRINT A * B
              IF X = Y THEN MAT A = (B * C) + (D^ E)

      In the last example the MAT does not apply to the logical expression
      X = Y.

      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 85
      1 January 1978                                                Sec. 9.1


      Illegal:

              IF MAT A = B * B  THEN...

      MAT has no effect on expressions that already indicate matrix
      operations:

              A = B MUL C

      and

              MAT A = B MUL C

      are equivalent.


      NAME      ____

      Syntax:

              NAME id1 = id2 (subarray bounds list)

      Subarray bounds syntax:

              n1 :  n2
               *

      Semantics:

      The NAME statement creates a subarray:  a rectangular-shaped
      subsection of an existing array (see Sec. 5.5 for a full discussion
      of subarrays).  The existing (or parent) array must have already been
      declared, and the subarray bounds must not be greater in number or
      extent than that of the parent.  The number of NAME statements that
      precede the first declaration of the parent array is limited to 5.


      NEXT      ____

      Syntax:

              NEXT iteration variable [,iteration variable...]

      Semantics:

      The NEXT statement marks the end of the FOR loop statements.  If more
      than one iteration variable appears, the statement is equivalent to

              NEXT iteration variable1
              NEXT iteration variable2
              .
              .
              . (See the FOR statement)
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 86
      1 January 1978                                                Sec. 9.1


      NO      __

      Syntax:

                  DATAEND
                  ENDFILE n
                  ERROR
              NO  ESCAPE
                  FILE n
                  MATH
                  TRANSFORM

      Semantics:

      The NO statement cancels the specified ON condition trap.  See the ON
      condition statement.


      ON DIV BY ZER      __ ___ __ ___

      Syntax:

              ON DIV BY ZER [NO] ERROR

      Semantics:

      Division by zero is normally an error condition in TYMBASIC.
      However, if the user executes ON DIV BY ZER NO ERROR, division by
      zero will give a zero result (unless reset by ON DIV BY ZER ERROR),
      throughout every module in the program.


      ON-GOTO      _______

      Syntax:

              ON n  GOTO  ln1,...lnK

      Semantics:

      The ON-GOTO statement transfers control to the line having the nth
      line number given in the line number list.  An error condition occurs
      if n is less than 1 or greater than K.  For example:

              10 NUMA=2, NUMB=3
              20 ON NUMA*NUMB GO TO 110,120,130,140,150,160,170

      Statement 20 transfers control to line 160.


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 87
      1 January 1978                                                Sec. 9.1


      ON-GOSUB      ________


      Syntax:

              ON n GOSUB ln1,...lnK

      Semantics:

      The ON-GOSUB statement transfers control to the subroutine starting
      at the nth line number given in the line number list.  An error
      condition occurs if n is less than 1 or greater than K.  See the
      GOSUB statement.  For example:

              100 ON ABS(B3) GOSUB 500,530,595,700


      ON-CONDITION      ____________

      Syntax:

                  ENDFILE n
                  FILE n
                  DATAEND
              ON  ESCAPE         GOTO  ln
                  MATH
                  TRANSFORM
                  ERROR

      Semantics:

      The ON condition statements enable the user's program to
      automatically regain control when an error condition is generated
      during program execution.  When an error occurs, TYMBASIC causes
      control to be transferred to the statement specified in the ON
      condition statement.  Thereafter, the program may analyze the error
      condition, using the system-defined functions ERRCD, ERRLN, and
      ERRFL, and may choose to resume execution at the beginning of the
      statement that caused the error.

      Execution of an ON condition statement specifies a line number to
      which control will be transferred when the specified condition
      occurs, as follows:
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 88
      1 January 1978                                                Sec. 9.1


         CONDITION          Meaning

         DATAEND         End of DATA values is encountered
         ENDFILE n       End of input file n is encountered
         ERROR           An error occurs other than those specifically
                         selected
         ESCAPE          Escape is typed
         FILE n          File error occurs on file n
         MATH            Mathematical error is encountered
         TRANSFORM       Numeric conversion or formatting error occurs

      The ON condition thus armed remains active until either another ON or
      a NO for that condition is executed.  Note that execution of an ON
      statement itself will NOT cause a transfer to another line to occur,
      but only establishes to which statement control will be transferred
      if an error condition DOES occur in the future.

      When a trap (transfer) is taken for an armed condition, the error
      message associated with the condition will not be printed, but the
      system-defined functions ERRCD, ERRLIN, and ERRFL are set, and the
      associated message may be found by reference to ERRMSG(ERRCD).

      For example:

              500 ON FILE 3 GO TO 900

      specifies that control is to transfer to line number 900 if a file
      error occurs on file unit number 3, such as opening file 3 for input
      when the file does not exist.  The interrupted statement is
      remembered in the Resume Stack so that execution can later be resumed
      at the interrupted statement.  For example, suppose that a FILE error
      on unit number 3 occurs in line 5050 and control is transferred to
      line 900.  It is possible that before the program is able to execute
      a RESUME statement, a TRANSFORM error occurs in line 930, and control
      is transferred to line 600 (because of a previously executed ON
      TRANSFORM GOTO 600 statement).  If a RESUME is then executed, control
      will return to line 930.  If another RESUME is executed, control will
      finally return to line 5050.

      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 89
      1 January 1978                                                Sec. 9.1


      The n following ENDFILE and FILE may be any integer from -9 to 20,
      with these meanings:

               1-20      TBA file unit numbers
               0         no file
              -1         Command file
              -2         TOUT file
              -3         DATA/READ
              -4         COPY FROM file
              -5         COPY TO file
              -6         RENAME FROM file
              -7         RENAME TO file
              -8         REMOVE file
              -9         miscellaneous user file

      FILE(-4), for example, will trap file errors on the COPY source file.
      Note that of the negative values only -3 is meaningful for ENDFILE,
      and means exactly the same as DATAEND.

      If an end-of-file condition occurs in a file for which the ENDFILE
      condition has not been set but the FILE condition has, then the FILE
      condition branch is taken.  If any other condition occurs for which
      that ON-condition has not been set but ERROR has, then the ERROR
      condition branch is taken.

      When an escape occurs and ON ESCAPE has been executed, then escapes
      are disabled until the second statement after another ON ESCAPE or a
      RESUME is executed.

      Onced armed by an ON condition statement, a particular error
      condition will cause control to be transferred regardless of where
      the error occurred.  Specifically, an error in one module may cause
      control to pass into another module.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 90
      1 January 1978                                                Sec. 9.1


      OPEN      ____

      Syntax:
                                                INPUT
                    ,   SYMBOLIC  SEQUENTIAL    OUTPUT  ,        n2
          OPEN s1  FOR   BINARY   RANDOM[(n1)]    IO    AS FILE  *
          
              [WITH PROTECTION s2] [,ERR [GOTO] ln]

      Semantics:

      The OPEN statement opens the file with file nomen specified by the
      string expression s1 for subsequent input or output.  If the terminal
      is specified (see Sec. 4.3), then input or output through file unit
      number n2 is equivalent to normal terminal I/O.  As many as 20 files,
      not including the terminal, may be open simultaneously.  See also the
      Files discussion, Section 11.

      If specified, n1 represents a fixed record length, in words for
      binary files, in characters for symbolic files;  it is an integer
      expression.  If n1 is omitted, the random file is of variable length
      records.

      n2 is the file unit number.  An * in that field will cause the file
      to be opened as a command file.  The file unit number should be an
      integer from 1 through 20, or one of the following special cases:

               0     valid only in
                     OPEN "TERM", BINARY INPUT, 0
                      (enables eight-level input)

              -1     Command file (same as *)
              -2     TOUT file (note: closes current TOUT file if any)

      s2, the second string expression, specifies three protection codes on
      the file:  the first applies to the user himself, the second to users
      in his account, and the last to all other users.  The codes are shown
      below.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 91
      1 January 1978                                                Sec. 9.1


              Protection               Permits
                 Code
      
      
                 ALL         Renaming or deleting this file
                 CP          Changing protection of this file
                 UPD         Changing contents of this file
                 AP          Appending to this file
                 RD          Reading this file
                 RUN         Running the program on this file
                 LK          Looking at directory information about
                             this file
                 NO          No knowledge of this file
                 *           Forces the XEXEC default protection code

      If protection is not specified or if the protection string is null
      (length = 0), then the protection for a new file will be the XEXEC
      default, for a previously existing file it will remain as the
      previous protection.

      If the user specifies *, the file will get the XEXEC default
      protection.

      The WITH PROTECTION clause is ignored for INPUT files.

      For example:

              10 OPEN...WITH PROTECTION "ALL RUN NO"

      The line number in the ERR clause specifies the line to which control
      will be transferred on file errors on file n2.  It is exactly
      equivalent to executing

              ON FILE n GOTO ln

      and thus sets an ON condition trap not limited in scope to the OPEN
      statement.

      The short form of the OPEN statement is:

                          IO
                          INPUT
                          OUTPUT
                          RANDIO[(n1)]
                 n2       RANDIN[(n1)]      SYMBOLIC
          OPEN ( *  ,s1,  RANDOUT[(n1)]   ,  BINARY

          [, PROTECTION=s2][, ERR=ln])

      The table below summarizes the default assumptions with OPEN.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 92
      1 January 1978                                                Sec. 9.1


      Default             Assumed when:

          SYMBOLIC               BINARY not specified

          SEQUENTIAL             RANDOM, RANDIO, RANDIN, or
                                 RANDOUT not specified.

          Variable length        (n1) not specified
          records on
          random file

          System default (new    PROTECTION is not specified
          file) or previous
          protection retained

          Terminal input         The string expression for
          or output              file evaluates to "TERMINAL".

      A file may be opened on more than 1 file unit number -- for example,
      if reading from one and writing on another.  The terminal may be
      opened on more than 1 file unit number;  however, both input and
      output are always valid through these unit numbers.


      PAUSE      _____

      Syntax:

              PAUSE [expression]

      The PAUSE statement interrupts execution, such that the GO or STEP
      commands can resume it, and prints the specified expression or PAUSE
      IN line number.  For example:

              100 PAUSE "TYPE GO TO CONTINUE"

      The continue point will be the point immediately after the PAUSE (see
      Sec. 8.5).


      PIF (abbreviation for PRINT IN FORM)      ___


      PIM (abbreviation for PRINT IN IMAGE)      ___


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 93
      1 January 1978                                                Sec. 9.1


      PRINT      _____

      Syntax:

                              : *             : *            * : *
                              ;               ;                ;
      PRINT [ON n1] [AT n2]:  ,  expression1  ,  expression2   ,

      In the form, an asterisk (*) after a square bracket means the
      component may appear zero or more times;  an asterisk after a brace
      means the component may appear one or more times.

      Semantics:

      The PRINT statement prints the specified value(s) in free-form at the
      terminal or a file, spacing according to the given punctuation (see
      Sec. 12.3).  Array and scalar values may be printed in any
      combination.

      An example:

              PRINT "H":"I";"TYM",DATE
              HI TYM         77/07/19  18:53

      Note that TYMBASIC requires some form of separator in
      multiple-expression print lists.  Thus, the following will generate
      the error message "Invalid print or write statement":

              PRINT "XYZ="A

      Trailing spaces are suppressed on terminal output;  trailing spaces
      are not suppressed with file output.

      The ON clause in a PRINT statement writes the specified expression
      values on file n1, which must be open.  The AT clause applies only to
      random files and specifies the location at which to begin writing
      values.  Examples:

              >100 PRINT ON 3 AT 20:  SQRT(X); "HELLO"
              >150 PRINT ON J:X,Y,Z+A


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 94
      1 January 1978                                                Sec. 9.1


      PRINT IN FORM
      PRINT IN IMAGE      _____ __ _____

      Syntax:

                                         FORM
              PRINT [[ON n1 [AT n2]][IN  IMAGE  s]:]expression list

      Semantics:

      The IN FORM and IN IMAGE clauses specify formatting.  s is a string
      expression whose value is the format used in the conversion of the
      output.  Use and examples of formatted output are supplied in Section
      12.


      QUIT      ____

      Syntax:

              QUIT [expression]

      Semantics:

      The QUIT statement halts program execution and transfers control to
      XEXEC after printing the specified expression or QUIT IN line number.
      For example:

              100 QUIT "EXIT FROM TYMBASIC"


      READ      ____

      Syntax:

              READ input list

      Semantics:

      The READ statement reads values from the ordered collection of DATA
      statements (the data block of the current module) into the specified
      variables.  If the end of the data block is encountered, a DATAEND
      error condition is generated.  The READ statement uses standard
      free-form input to read values from the data block.  For example:

              10 READ A
              20 READ B,C,D
              30 DATA 10,20,30,40

      assigns 10 to A, 20 to B, 30 to C, and 40 to D.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 95
      1 January 1978                                                Sec. 9.1


      REAL      ____

      Syntax:

              REAL  variable/dimension list

      Semantics:

      The REAL statement declares real variables and dimensions real array
      variables (see also Sec. 5.3).  For example:

              >20 REAL EST(100), XRATE


      REM      ___

      Syntax:

               !
              REM text

      Semantics:

      The REM statement inserts comments in the program (which have no
      effect on program execution) that can be used for documenting a
      program.  The ! delimits all text remaining on the line as a comment.
      For example:

              >10 !LINE 10 IS NOT EXECUTED
              >20 REM NEITHER IS LINE 20
              >30 PRINT S !S IS SALES VOLUME FOR 1973

      If REM is entered as a direct statement (with no leading line
      number), no action is taken.


      REMOVE      ______

      Syntax:

              REMOVE s

      Semantics:

      The REMOVE statement deletes the file with the file nomen specified
      by s.  For example:

              >100 REMOVE "FILEX"

      It is not an error if the file is not found.
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 96
      1 January 1978                                                Sec. 9.1


      RENAME      ______

      Syntax:

              RENAME s1 AS s2

      Semantics:

      The RENAME statement changes the name of the file with file nomen
      specified by s1 to the new name s2.  For example:

              >100 RENAME "FILEX" AS "FILEY"

      The confirmation procedure is operative on the second file.  For
      example, if FILEY already exists, then it will be deleted and
      replaced by FILEX only if an appropriate confirmation keyword was
      given or the user answers affirmatively to the question "Existing
      file, Ok?".

      Note that renaming a file can be used to move the file from one
      directory to another without actually copying its contents.


      RESTORE      _______

      Syntax:

              RESTORE

      Semantics:

      The RESTORE statement causes the next READ statement to assign values
      beginning with the first value in the data block of the current
      module.  For example:

              >10 READ A,B
              >20 RESTORE
              >30 READ C,D,E,F
              >40 DATA 10,20,30,40

      assigns 10 to A, 20 to B, 10 to C, 20 to D, 30 to E, and 40 to F.

      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 97
      1 January 1978                                                Sec. 9.1


      RESUME      ______

      Syntax:

              RESUME [ln]

      Semantics:

      The RESUME statement resumes execution at the beginning of the
      statement that last caused a specified user-trapped error condition
      (or at the statement specified by the line number), if the condition
      hasn't already been cleared by a RESUME.  (Every error condition that
      is trapped by the user creates an entry on the RESUME stack;
      execution of a RESUME statement takes the top entry off the stack,
      branching then to its associated statement.) See also the ON
      condition statement.


      RETURN      ______

      Syntax:

              RETURN

      Semantics:

      The RETURN statement transfers control to the point immediately after
      the most recently executed GOSUB statement.  For example, if the
      GOSUB subroutine was called by

              10 GOSUB 100 UNTIL I=45

      then the RETURN statement

              160 RETURN

      would transfer control back to the UNTIL test, which may or may not
      cause the GOSUB to be executed once again.


      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 98
      1 January 1978                                                Sec. 9.1


      SIGNIFICANCE      ____________

      Syntax:

              SIGNIFICANCE n

      Semantics:

      SIGNIFICANCE causes all free-form floating point output (types real
      and double) to write up to n significant digits, throughout every
      module in the program.  The value of n may range from 1 through 18.
      For example, the statements

              >10 SIGNIFICANCE 6
              >20 PRINT PI
              >30 SIGNIFICANCE 3
              >40 PRINT PI

      print:

              3.14159
              3.14

      Regardless of SIGNIFICANCE, no more than seven digits of a (single
      precision) real number will be written.


      STOP      ____

      Syntax:

              STOP [expression]

      Semantics:

      The STOP statement terminates program execution, closes all files
      (except for command and TOUT files), and prints the specified
      expression or STOP IN line number.  For example:

              >100 STOP "JOB DONE"
      TYMBASIC REFERENCE MANUAL              STATEMENTS             Page 99
      1 January 1978                                                Sec. 9.1


      STRING
      TEXT      ____

      Syntax:

              STRING
               TEXT     variable/dimension list

      Semantics:

      The STRING statement declares string variables, dimensions string
      array variables, and specifies desired maximum string lengths (see
      also Sec. 5.3).  The word TEXT is equivalent to STRING and is
      provided for compatibility with other BASICs.  For example:

              10 STRING NAME(300):20,ADDR:35

      If string length is omitted, the maximum length defaults to 4095
      characters.  As strings are of variable length, and use only the
      storage they require, setting a maximum length is for protection
      only.  When a string value is stored into a string variable, its
      length is truncated to the maximum length of the variable if
      necessary.


      WAIT      ____

      Syntax:

              WAIT n

      Semantics:

      The WAIT statement causes TYMBASIC to pause for n seconds before
      resuming program execution.  If n is negative, TYMBASIC waits until
      the terminal output buffer is empty.  For example:

              >100 WAIT 10


      WRITE      _____

      The WRITE statement is equivalent to the PRINT statement, and is
      provided for compatibility with other BASICs.
      TYMBASIC REFERENCE MANUAL              STATEMENTS            Page 100
      1 January 1978                                               Sec. 9.2


      9.2 STATEMENT MODIFIERS      ___ _________ _________

      Most TYMBASIC statements can be modified by one of six clauses,
      described below.  The modifiers follow the statement body, delineated
      by at least one space.  Modifiers may be followed by modifiers, in
      which case they are executed from right to left.

      The statements DATA, DEF, ELSE, ENDF, ENDIF, NEXT, and ORIF may not
      be modified.  The IF statement itself may not be modified but a THEN
      or ELSE clause not consisting of another IF may be.


      FOR Modifier      ___ ________

      Syntax:
                                             TO n3
      FOR iteration variable = n1 [ [BY n2]  UNTIL  logical expression ]
                                             WHILE


      Semantics:

      A statement followed by a FOR modifier is executed until the FOR loop
      is satisfied.  (There is an implied NEXT at the end of the
      statement.) See the FOR statement description.  For example:

              PRINT SUBTOT(I) FOR I = 2 BY 2 TO 16

      The first eight even-numbered elements of SUBTOT are printed.  This
      statement is equivalent to:

              FOR I = 2 BY 2 TO 16
                PRINT SUBTOT(I)
              NEXT I


      IF Modifier      __ ________

      Syntax:

              IF logical expression

      Semantics:

      A statement followed by an IF modifier is executed if the logical
      expression is TRUE, otherwise execution passes to the next statement.
      For example:

              PAUSE IF TROUBLE

      If the variable TROUBLE is TRUE the PAUSE statement will be executed.
      TYMBASIC REFERENCE MANUAL              STATEMENTS            Page 101
      1 January 1978                                               Sec. 9.2


      UNLESS Modifier      ______ ________

      Syntax:

              UNLESS logical expression

      Semantics:

      A statement followed by an UNLESS modifier is executed if the logical
      expression is FALSE, otherwise execution passes to the next
      statement.  For example:

              CALL ASUB UNLESS X=0

      The subroutine ASUB will be called whenever this statement is
      executed and X is not equal to zero.


      UNTIL Modifier      _____ ________

      Syntax:

              UNTIL logical expression

      Semantics:

      The UNTIL modifier causes the statement to be executed repeatedly as
      long as the logical expression is FALSE.  When it is TRUE execution
      passes to the next statement.  For example:

              LET I = I+1 UNTIL X(I)=0

      Note that the UNTIL test is made prior to execution of the statement
      body.


      WHERE Modifier      _____ ________

      Syntax:

              WHERE assignment list

      Semantics:

      The WHERE modifier causes the statement to be executed after the
      assignments in the modifier have been executed.  The assignment list
      may contain simple or compound assignments or exchanges in any
      combination (see the LET statement).  For example:

              GOSUB 2000 WHERE A=15

              CALL FUNC(I,J,K) WHERE I,J=1, K=2, L==M
      TYMBASIC REFERENCE MANUAL              STATEMENTS            Page 102
      1 January 1978                                               Sec. 9.2


      WHILE Modifier      _____ ________

      Syntax:

              WHILE logical expression

      Semantics:

      The WHILE modifier causes the statement to be executed repeatedly as
      long as the logical expression is TRUE.  When the expression is FALSE
      execution passes to the next statement.  For example:

              TOKEN = GET.TOKEN(LINE) WHILE TOKEN # '"'


      Modifier Range      ________ _____

      Parts of some statements are outside the range of a statement
      modifier:  when an input or output statement is modified, the
      calculation of any file unit number, format, or location and the
      setting of the location in the statement is not within the modifier's
      range.  The modifier does control the printing of any data.  For
      example:

              >10 I=9
              >20 PRINT ON I:SQRT(I), I WHERE I=5

      is equivalent to:

              >10 PRINT ON 9:  SQRT(5),5

      Conversely, the input or output list of the statement includes the
      modifiers.  Thus a Control B from the terminal on input will restart
      the entire input list including the modifiers.

      Note that even if the modifier causes nothing to be printed, the file
      unit number and format are calculated and the file location is
      changed if these fields appear.  For example:

              >10 PRINT ON N AT F1(N) IN FORM F2$(N):  F3(I) IF I>=0

      If I is less than zero, F3 will not be called and no data is printed
      on file N.  However, the two functions F1 and F2$ will be called and
      the location on file N will be set to the value returned by F1.
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 103
      1 January 1978                                               Sec. 10.0


                              SECTION 10. COMMANDS



      This section provides the syntax, semantics, and an example of each
      TYMBASIC command.  The commands are listed in alphabetical order.

      Many commands operate on or over a range of lines in the workspace,
      specified by the initial and terminating lines, separated by a colon
      or a dash.  This is shown in the syntax by:
                                             :
              line range        Syntax: ln1[ - ln2]

      A warning message is printed for any line range containing no lines.

      A line range list is one or more line ranges, with comma separators.
      For example:

              100:150, 210:340, 500

      The word ALL may be given anywhere a line range list is valid to
      specify all the lines in the workspace.


      BREAK
      NO BREAK      __ _____


      Syntax:

              BREAK line range list
              NO BREAK [line range list]

      Semantics:

      Break specifies line number ranges within the current workspace for
      breakpoints.  Successive BREAK commands are cumulative.  During
      execution, control returns to the Command/Statement phase when any of
      the breakpoints are encountered;  the action is analogous to a PAUSE
      (see also Sec. 8.5).  For example:

              >BREAK 10,100-200
              >RUN

              BREAK AT 10
              >TRACE CNTR
              >GO

      The NO BREAK command removes all or specified breakpoints.
      Breakpoints are also erased when a RENUMBER, or GET command is
      entered.
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 104
      1 January 1978                                               Sec. 10.0


      CDE      ___

      Syntax:

              CDE [line range]

      Semantics:

      CDE prints a MACRO-like display of the code generated for the
      specified line or line range in the workspace, or if no lines are
      specified, for all lines.  For example:

              >CDE 10-100

      As CDE forces a compilation of the entire workspace, a relocatable
      file will be generated, and any compilation diagnostics will be
      output.


      DEBUG
      NO DEBUG      __ _____

      Syntax:

              [NO] DEBUG

      Semantics:

      The DEBUG command causes the workspace module (and all modules added
      to the module list while the workspace state is DEBUG) to be compiled
      in the DEBUG state.

      When the workspace is in the DEBUG state, the BREAK and TRACE
      commands are operative on lines and variables defined in the
      workspace.  In addition, for array element accesses in any module
      compiled in the DEBUG state, TYMBASIC checks each subscript against
      its bounds.  For modules compiled in the NO DEBUG state, TYMBASIC
      only checks for array element addressing outside the area allocated
      to the array.

      For every module compiled in the DEBUG state, TYMBASIC checks every
      store into a variable and every execution of a statement (so that
      BREAK and TRACE can work).  For these reasons, execution of a module
      in the DEBUG state is many times slower than execution of the same
      module in the NO DEBUG state.

      The default state in TYMBASIC is NO DEBUG.

      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 105
      1 January 1978                                               Sec. 10.0


      DELETE      ______

      Syntax:

              DELETE  line range list

      Semantics:

      Deletes the specified lines from the workspace.  If all lines are
      deleted in the workspace, the workspace is automatically unnamed.  An
      example is:

              >DELETE 10, 20-50, 80

      The user may delete a single line by typing its line number followed
      by a carriage return.

      DO      __

      Syntax:

              DO file nomen

      Semantics:

      DO opens the specified command file and begins accepting its TYMBASIC
      statements and commands.  The default extension for file nomen is
      .CMD.  See Command Files, Section 8.6.


      DLIST      _____

      Syntax:

              DLIST [line range list]

      Semantics:

      DLIST prints the workspace name and the current date and time before
      listing the specified lines or all lines in the workspace.  For
      example:

              >DLIST 10, 100-200, 300


      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 106
      1 January 1978                                               Sec. 10.0


      DUMP REFS      ____ ____

      Syntax:

              DUMP REFS [file nomen]

      Semantics:

      DUMP REFS stores on the specified file information needed to create a
      cross-reference listing for the workspace module.  The file is in the
      format expected by the XEXEC CROSS command and the file name is
      appended to the CRE tempcore file.  For example:

              >DUMP REFS CREFIL

      Default extension:  .CRF


      ECHO and NO ECHO      ____ ___ __ ____

      Syntax:

              [NO] ECHO

      Semantics:

      ECHO and NO ECHO determine whether command input characters, prompts,
      and messages associated with command input are to be echoed to the
      current TOUT destination.  See Section 8.6.

      The default is NO ECHO.  If the terminal is the command source, input
      is echoed, and prompts and messages are printed there.  If a command
      file is open, prompts and input lines are not printed unless ECHO has
      been specified.


      EDIT      ____

      Syntax:

              EDIT line range list
              ln E

      Semantics:

      EDIT prints the specified lines one at a time and waits for the user
      to edit each, allowing any of the Tymshare control characters (see
      Appendix C).  For example:
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 107
      1 January 1978                                               Sec. 10.0


              >EDIT 10
              10 THERE IS A MUSTAKE

      Note that

              >100E

      can be entered for

              >EDIT 100

      The line number may modified, in which case a new line is entered
      into the workspace, but the original line is not deleted.


      ENTER      _____

      Syntax:

              ENTER  [ln]  [BY i]

      Semantics:

      ENTER automatically supplies line numbers as the user enters
      statements into the workspace.  The numbers start with the specified
      line number (default is 100), and are incremented by i.  If the BY
      clause is omitted, the increment is the last specified increment, or
      10 if no previous ENTER increment was given.  For example:

              >ENTER 50 BY 5

      ENTER automatically terminates if an attempt is made to interleave or
      overwrite lines.  The user terminates data entry by typing an & alone
      on a line.  During statement entry, the old line image is the last
      statement entered.

      Statements may also be entered into the workspace by typing the line
      number followed by the statement.  In this case, the statement may
      replace another statement.  For example,

              >200 A(I) = FUNC(J)
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 108
      1 January 1978                                               Sec. 10.0


      GET      ___

      Syntax:

              GET file nomen

      Semantics:

      GET moves TYMBASIC statements stored on the specified file into the
      user's workspace, checks each statement for valid syntax, and names
      the workspace with the file nomen (less the confirmation keyword).
      For example:

              >GET PROG2

      TBA is the default extension for the file nomen.  If the file cannot
      be found or accessed, the command is aborted.

      If the current workspace is not empty and has been modified since the
      last GET or SAVE operation, TYMBASIC gives the user an opportunity to
      save the workspace module by asking:

              Save workspace?

      The user may answer Y[ES], N[O], or AS file nomen.  If the answer is
      Y[ES] and the workspace is unnamed, TYMBASIC prompts for a file
      nomen;  if the answer is AS file nomen the file nomen becomes the
      file name whether the workspace had been previously named or not.  In
      either case the effects are as if a SAVE command had been issued.  If
      the answer is N[O] the recent modifications are lost.  After
      processing these options, the actual GET begins, as described below
      the NOTE.

              NOTE:  TYMBASIC will warn the user if a N[O] would result in
              a program modification.  When 1) a program has been loaded
              and it still contains valid data (see Sec. 8.4) and 2) the
              current workspace is on the module list, then a GET command
              without saving the workspace would result in a program
              modification, since the workspace previously loaded into the
              program would no longer exist.  In this case TYMBASIC issues
              a warning with the prompt:

                  Answering NO will destroy valid data
                  Save workspace?

              If the module list is not empty then GET is always a program
              modification.

      If the file nomen specified in the GET command is found on the module
      list, then the workspace debug state is set from the debug state of
      that module on the module list.  TYMBASIC informs the user if the
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 109
      1 January 1978                                               Sec. 10.0


      workspace debug state changes in this manner.

      The file must be a symbolic file containing only indirect statements:
      that is, each line must begin with a line number and contain a
      statement that is syntactically valid as an indirect statement.  Any
      other lines will be diagnosed and rejected.  The line numbers need
      not be in ascending order and may interleave with or overwrite
      earlier lines.

      If an input line is preceeded by a form feed (control L) then that
      line will get a Top of Form mark (see the TOF command).  If an input
      line contains a line feed (control J) then it is interpreted as a
      line continuation.  Any other control characters found within the
      line are removed and a warning message is printed.  EDIT10-type line
      numbers are stripped from input lines.


      GO      __

      Syntax:

              GO

      Semantics:

      GO starts program execution at the continue point.  (The continue
      point is defined in Section 8.5).  Variables retain their current
      values.  GO is valid only after the program has been initialized and
      a continue point has been defined.


      INITIALIZE      __________

      Syntax:

              INIT[IALIZE] [file nomen]

      Semantics:

      INIT initializes the Run phase environment but does not begin
      executing the program;  if necessary, a GET and/or compilation
      occurs.  See Section 8.4 for a description of initialization.



      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 110
      1 January 1978                                               Sec. 10.0


      LIBRARY
      NO LIBRARY      __ _______

      Syntax:

              [NO] LIBRARY
                   LIBRARIES      file nomen list

      Semantics:

      The LIBRARY command adds the specified files to the user's library
      list in the order specified;  the NO LIBRARY command deletes
      specified files from the library list maintaining relative order.  A
      .REL extension is inserted if no extension is supplied.  LIBRARY and
      NO LIBRARY are both program modifications.

      A given file nomen may appear more than once on the library list, and
      when removed, all instances of that file nomen are removed at once.
      A warning is printed for any file nomen that is illegal (or not found
      on the library list in NO LIBRARY);  however, processing of the file
      nomen list continues to its end.


      LIST      ____

      Syntax:

              LIST [line range list]

      Semantics:

      LIST lists the specified lines or all lines (the default) in the
      workspace.  Output is to the current TOUT destination, usually the
      terminal.  For example:

              >LIST 10-50, 300


      LIST BREAK      ____ _____

      Syntax:

              LIST BREAK

      Semantics:

      The LIST BREAK command lists the current breakpoints.


      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 111
      1 January 1978                                               Sec. 10.0


      LIST LIBRARY      ____ _______

      Syntax:

              LIST  LIBRARY
                    LIBRARIES

      Semantics:

      The LIST LIBRARY command lists the libraries in the library list if
      any.  The files are listed in the order in which they will be
      searched.


      LIST MODULE      ____ ______

      Syntax:

              LIST MODULE[S]

      Semantics:

      The modules in the user's modules list are printed in the order in
      which they will be loaded.  Included in the module listing is an
      indication of the debug state of each module and notations for the
      workspace and startpoint modules.  If the module list is empty
      TYMBASIC prints the warning

              Module list empty


      LIST TRACE      ____ _____

      Syntax:

              LIST TRACE

      Semantics:

      The LIST TRACE command indicates which lines will be traced and which
      variables, when stored into, will print the line number and value of
      the variable.


      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 112
      1 January 1978                                               Sec. 10.0


      LOG      ___

      Syntax:

              LOG

      Semantics:

      LOG closes all files and ends the user's entire session at the
      terminal.  Logout information is printed.


      MAP      ___

      Syntax:

              MAP

      Semantics:

      MAP prints information about the user's program size and its storage
      allocation.  The program must have been initialized.  The output
      format is:

      
            LOAD               LOSEG    HISEG
        MODULE NAME           ADDRESS  ADDRESS
      
         SYSTEM               address  address
      
           name               address  address
            .
            .
            .
      
         SYSTEM               address  address
      
       END PROGRAM:           address  address
      
      

      The module name SYSTEM indicates parts of the TYMBASIC system.
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 113
      1 January 1978                                               Sec. 10.0


      MERGE      _____

      Syntax:

              MERGE file nomen

      Semantics:

      This command merges TYMBASIC statements stored on the specified file
      into the workspace.  As with the GET command, the file must be
      symbolic and contain only indirect statements;  lines need not be in
      order and may interleave with or overwrite existing lines.  For
      example:

              >MERGE PROG2

      .TBA is the default extension.  MERGE does not change the workspace
      name.


      MODIFY      ______

      Syntax:

              MOD[IFY] [line range list]
              ln M

      Semantics:

      MODIFY is identical to the EDIT command above, except that it does
      not print the line before editing.  Similarly,

              >3M                 is an alternative to
              >MOD 3


      MODULE
      NO MODULE      __ ______

      Syntax:

              [NO] MODULE[S] file nomen list

      Semantics:

      The MODULE command adds the specified files to the module list in the
      given order;  the NO MODULE command removes the specified files from
      the list.  When a module is added to the module list, its debug state
      is determined from the current debug state of the workspace.  The
      default extension for the file nomens is .TBA .
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 114
      1 January 1978                                               Sec. 10.0


      Every module must have a unique file name, regardless of user name
      and extension, since each load module name must be unique (and also
      to avoid conflicts when creating relocatable modules).  The MODULE
      command checks for name duplication and informs the user of conflict
      resolutions.  For example:

              >MODULE JKL, (SAM)XYZ, abc.abc

      adds three modules to the module list, and if followed by

              >MODULE (JOE)XYZ, abc.def
              Replacing (SAM)XYZ, ABC.ABC

      two are replaced because their file names are identical.  This
      replacement may alter the order of the module list and therefore
      constitutes a program modification.

      A warning message is printed for any file nomen that is illegal;
      however, processing of the file nomen list continues to its end.

      For the NO MODULE command, modules having the same file name as the
      specified file nomens (regardless of user name and extension) are
      removed from the module list if found.  A message is printed for each
      file nomen that indicates what module was removed from the list, or
      that no entry can be found with the given name.

      Adding or deleting a module is always a program modification.


      PMC      ___

      Syntax:

              PMC line range list

      Semantics:

      PMC prints the intermediate code generated by the parser for the
      specified lines or all lines.  This command is for the use of
      TYMBASIC system analysis.


      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 115
      1 January 1978                                               Sec. 10.0


      QUIT      ____

      Syntax:

              QUIT

      Semantics:

      QUIT closes all files and tranfers control to XEXEC.


      RENUMBER      ________

      Syntax:

                                        TO
                          [[FROM] ln2[  -  ln3]] ADD[-]i
                                        :
                                                TO         BY
              REN[UMBER]  [[AS] ln1][FROM ln2[  -  ln3]][  INC  i]
                                                :
                                        TO
                          [ln1][,[ln2[  -   ln3]][,[i]]]
                                        :

      Semantics:

      This command renumbers lines in the user's workspace.
      The renumbering is as follows:  ln2 is the old number of the line in
      the program where renumbering is to begin, ln1 is the first new line
      number, and i is the increment to be used in assigning the new line
      numbers.  The alternate form (RENUMBER ln ADD i) renumbers from old
      line number 1n to the end of the program by adding i to every line
      number.  (In the ADD clause i may be negative).  Renumbering proceeds
      through ln3.  Examples:

              >LIST

                3 INPUT A
                7 GO TO 200 IF A=0
               42 PRINT 1/A
               43 GO TO 3
              200 STOP

              >RENUMBER 10,3,20

              >LIST

              10 INPUT A
              30 GO TO 90 IF A=0
              50 PRINT 1/A
              70 GO TO 10
              90 STOP
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 116
      1 January 1978                                               Sec. 10.0


      Note that the references to line numbers within statements in the
      workspace are also renumbered to correspond properly to the new line
      numbers.

      Renumber will never delete or interleave lines, but it can be used to
      move lines.

      Default values are:

              ln1   100
              ln2     0
              ln3    99999
               i     10


      RUN      ___

      Syntax:

              RUN  [file nomen]

      Semantics:

      RUN loads, initializes and executes the program.  If a file is
      specified, RUN first GETs the file.  See Execution, Section 8.  For
      example:

              >RUN FILEX


      SAVE      ____

      Syntax:

              SAVE  [file nomen]  [line range list]

      Semantics:

      SAVE stores the specified lines or the entire workspace module on a
      symbolic file with the given file nomen.  The default extension is
      .TBA .  An error message is printed if the workspace is empty.

      If no file nomen is specified, then the user name, if any, is deleted
      from the workspace name, and the workspace name is then used.

      If, however, a file nomen is given and no line range list is given
      (thus specifying the entire workspace module) then the file nomen
      (less the confirmation keyword, if any) becomes the workspace name.
      An example is:

              >SAVE FOOBAR 19, 30-48, 160
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 117
      1 January 1978                                               Sec. 10.0


      SAVE BINARY      ____ ______

      Syntax:

              SAVE BINARY [file nomen]

      Semantics:

      SAVE BINARY stores the user's program as an executable file.  If no
      file nomen is specified, then the workspace name is used, less the
      user name if any (it is an error if the workspace is unnamed in this
      case).  If a file nomen is given and specifies an extension other
      than .SHR, the error message "Illegal extension" is printed and the
      command is aborted.  Otherwise, an executable file with extension
      .SHR is created.  Confirmation applies to the .SHR file, not the .LOW
      file (which will also be created if the user has other-language
      modules that contain program or data in the low segment).

      If the workspace or any module in the module list is in the DEBUG
      state, the user is asked:

              Execution of program in DEBUG mode more expensive, proceed?

      A N[O] response will abort the command.

      After successful completion of a SAVE BINARY command, no continue
      point is established, and the program contains no valid data.

      An example is

              >SAVE BINARY CTAB

      which creates the executable file CTAB.SHR.


      START      _____

      Syntax:

              START

      Semantics:

      START causes the program to re-execute from its beginning, retaining
      current variable values.  Files are not affected.  This command is
      valid only when the program contains valid data and does not cause
      the Load/Initialize phase to be invoked (see Section 8).  It is
      equivalent to the direct statement GO TO n, where n is the first line
      number in the program.
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 118
      1 January 1978                                               Sec. 10.0


      STARTPOINT      __________

      Syntax:

              STARTPOINT file nomen
              NO STARTPOINT

      Semantics:

      The STARTPOINT command specifies the startpoint module, which during
      the Load/Initialize phase must either be found on the module list or
      be the workspace name (see Sec. 8.4).  The NO STARTPOINT command
      causes the workspace to resume its role as the startpoint module.


      STEP      ____

      Syntax:

              STEP [i]

      Semantics:

      STEP starts execution at the continue point and interrupts back to
      the Command/Statement phase after i statements (from modules compiled
      in the DEBUG state) complete execution.  The integer constant i may
      be in the range 1 through 250000;  if omitted, 1 is assumed.  For
      example:

              >STEP 3

      Whenever control returns to Command/Statement phase, any active STEP
      count is discarded.  STEP is allowed only when the workspace is in
      the DEBUG state, and a continue point is defined.


      SYMD      ____

      Syntax:

              SYMD id [ ln ]

      Semantics:

      SYMD prints the definition of the identifier (scalar or array
      variable, subarray, procedure, or parameter).  A line number is given
      to set the procedure context if the specified identifier is local.
      SYMD does not perform on implicitly declared variables (see
      Sec. 5.3).
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 119
      1 January 1978                                               Sec. 10.0


      For example:

              >SYMD I 900
              KIND TYPE  NPAR LOC
              ARRY INT     2  44

      KIND will be scalar, array, or procedure;  TYPE is the type of the
      identifier;  NPAR is the number of parameters or number of
      dimensions;  and LOC is the low segment location of the identifier.


      TABS      ____

      Syntax:

              TABS integer list

      Semantics:

      TABS sets tab stops at the specified positions;  that is it sets the
      Control I positions.  As many as 16 tabs can be set.  For example:

              >TABS 20,30,50

      The default tab stops are 9, 17, 33, 41, 49, 57, 65, 73, 81, 89, 97,
      105, 113, 121, and 129.

      Control I at or beyond the last tab yields a single space.


      TOF      ___

      Syntax:

              TOF [line range list]

      Semantics:

      TOF gives each line specified (or all lines) a Top of FORM mark.
      When a marked line is written on a file with the SAVE command, it is
      preceeded by the sequence form feed/carriage return/line feed.  When
      listed, it is preceeded by a form feed.
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 120
      1 January 1978                                               Sec. 10.0


      TOUT      ____

      Syntax:

              TOUT file nomen

      Semantics:

      TOUT specifies a file on which output normally sent to the terminal
      is to be written.  If a TOUT file is currently open then it is first
      closed.  For example:

              >TOUT FOO

      The command

              >TOUT TERMINAL

      resumes the printing of terminal output.  The place where normal
      terminal output is sent is called the TOUT Destination, be it either
      the terminal or a file.


      TRACE
      NO TRACE      __ _____

      Syntax:

              [NO] TRACE [variable list] [line range list]

      Semantics:

      TRACE provides a printed trace of program execution on the specified
      lines of the workspace module.  For those lines, it prints a trace
      message whenever a simple scalar variable is stored into whose name
      appears in the variable list.  If no variables are specified, a trace
      message appears whenever a specified line is executed.  For example:
      TYMBASIC REFERENCE MANUAL              COMMANDS              Page 121
      1 January 1978                                               Sec. 10.0


              >TRACE 100-200
              >RUN
              *100
              *110
              *115
              *115
              *120
              *130
              >TRACE X,Y 100-200
              >RUN
              *110
              *110 X= 5
              *120
              *120 Y= 20, 3             Note that Y is a complex
              >                         variable.

      The command

              >TRACE

      or

              >TRACE ALL

      traces all lines.

      NO TRACE cancels the trace for the specified variables or statements;
      if none are specified all are cancelled.


      VERSION      _______

      Syntax:

              VERSION

      Semantics:

      The VERSION command prints the current TYMBASIC version number.  This
      is the number that should appear on any correspondence with Tymshare
      concerning TYMBASIC.  The version number is also printed whenever
      TYMBASIC is entered.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 122
      1 January 1978                                               Sec. 11.1


                         Section 11     FILE MANAGEMENT


      11.1 INTRODUCTION      ____ ____________

      File management refers to operations on files executed by TBA
      run-phase program statements as opposed to TBA commands.

      Files are opened by OPEN statements;  they remain open until closed
      by CLOSE statements or until an END or STOP is encountered.  Files
      are deleted by REMOVE statements.  The syntax and semantics of the
      OPEN, CLOSE, and REMOVE statements are to be found in Section 9.1.

      The file unit number in an I/O statement is rounded to an integer,
      which must fall in the range 1 through 20 or a error condition will
      be generated.  All references to file numbers except in OPEN and
      ON-condition statements require that the file be already open.



      11.2 FILE ATTRIBUTES      ____ ____ __________

      Tymbasic programs operate on files in the XEXEC environment.  Both
      file mode (Input/Supersede/Update) and protection reflect intrinsic
      attributes of the XEXEC file system observed and retained by TBA.
      The OPEN statement maps the XEXEC file nomen to a TBA file unit
      number, and assigns those attributes not intrinsic to XEXEC files:
      type (symbolic/binary), access method (sequential/random), and record
      length.



      MODE      ____

      If a file is opened for INPUT it is said to be in Input mode.  The
      file must already exist.  Other users may access the file while it is
      open.  The PRINT statement may not be used on a file open in Input
      mode.

      Output can take place in two modes, called Update and Supersede.
      Opening a file for IO invokes Update mode and opening a file for
      OUTPUT invokes Supersede mode.

      In the Update mode, the system retrieves the contents of the original
      (old) file, if any, and changes are made directly to the contents of
      that file, i.e., its contents may be over-written or added to.  Until
      the CLOSE statement is executed the file may continue to be modified
      or read, but the file can not be accessed by any other user.

      In the Supersede mode the old file is not accessed.  Instead, a new,
      empty file is created.  Until the CLOSE statement is executed the new
      file may continue to be written and other users may access the
      original file.  When the CLOSE statement has been executed the old
      file is deleted and the new file takes its place.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 123
      1 January 1978                                               Sec. 11.2


      PROTECTION      __________

      Files have three protection codes, specifying protection levels for
      the user himself, other users in his account, and for all other
      users.  Protection can be specified in the OPEN statement, or
      defaulted to ALL RD NO, which allows the user to change, rename, or
      delete the file, other users in the same account to read the file,
      and denies all other users any knowledge of the file.  See the OPEN
      statement description in Section 9.



      TYPE      ____

      A file is considered as a sequence of data units, stored in symbolic
      or binary form.  The basic data unit in symbolic files is a
      character;  in binary files it is a word.  TYMBASIC does not allow
      mixing of symbolic and binary data in the same file.

      Symbolic files consist of 7-bit ASCII characters, stored on a file at
      five characters per storage word.  When a numeric or logical value is
      read from or written to a symbolic file, conversion takes place
      between internal machine representation and character representation.
      Symbolic file input and output may use formatted or unformatted
      (free-form) conversion.

      A binary file is stored in internal machine form.  Since numeric
      conversion does not take place with binary files, formatted I/O is
      not allowed;  free-form PRINT or INPUT statements are the only kind
      allowed with binary files.  Values are input from a binary file
      according to the data type of the input list element.  TYMBASIC
      cannot check that values input from the binary file are of the proper
      type, and errors of this sort will produce unpredictable results.

      Strings are written in characters whether they are stored on symbolic
      or binary files.  Strings on binary files always occupy a whole
      number of words.  Binary strings are formatted as follows:  the first
      half word is the string's character count, the second half word is
      the string's word count;  the contents of the string occupy
      successive words at five characters per word, and the last word is
      padded with NUL characters (zeros).  If the string ends on a word
      boundary an entire word of NUL's is stored.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 124
      1 January 1978                                               Sec. 11.2


      The storage allocated for various types of data in binary files is
      shown in the following table.


                               Binary Data Storage

                   Type                  Storage
      
                Real                  1 word   36 bits
      
                Double Precision      2 words  72 bits
      
                Complex               2 words  72 bits
       
                Integer               1 word   36 bits
       
                Logical               1 word   36 bits
       
                String                Stored at 5
                                      characters per word
                                      plus a 1 word
                                      descriptor
       

      The SIZE(n) function returns the size in characters, words, or
      records of open file n as follows:



            Variable-length     Symbolic      Number of characters
             record
                                Binary        Total number of words

            Fixed-length        Symbolic      Number of
             record             and Binary    complete records


      SIZE takes into account any output done to the file beyond its
      original limits.  See section 11.5 for examples of SIZE usage.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 125
      1 January 1978                                               Sec. 11.2


      ACCESS METHOD AND RECORD LENGTH      ______ ______ ___ ______ ______

      The organization, type, and basic data units allowed with sequential
      and random-access files are summarized below:


                     ACCESS METHODS AND FILE CHARACTERISTICS

        File           File           File            Data
        Access         Composition    Type            Unit
        Method


                       Variable-      symbolic        Character
        Sequential     length
                       records        binary          Word

                       Variable-      symbolic        Character
                       length
                       records        binary          Word
        Random
                       Fixed-length   symbolic        r Characters
                       records
                                      binary          r words


      Notes:

           1.  Word length:  36 bits

           2.  Character code:  7-bit USASCII

           3.  r = record length specified in OPEN statement



      RANDOM-ACCESS FILES      _____________ _____

      Random files allow explicit file-positioning operations, so that data
      may be accessed in any order.  Random files are of two kinds:
      fixed-length-record and variable-length-record.

      Fixed-length-record files are divided into records of equal numbers
      of data units, as specified in the OPEN statement.  The carriage
      return/line feed sequence has no special significance in
      fixed-length-record symbolic files.  The record length in binary
      files has no significance except for positioning operations.

      Variable-length-record files have no such static divisions.  In
      symbolic files the carriage return/line feed sequence ends each line
      and thus marks a record boundary (a record is equivalent to a line
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 126
      1 January 1978                                               Sec. 11.2


      for variable-length-record symbolic files).  In binary files data is
      stored continuously and so a record boundary can be construed as
      beginning at any word.  Positioning on variable-length-record files
      is by data unit number, not record number.

      Fixed-length formats only must be used for input or output to
      fixed-length-record symbolic files.  Free- or fixed-form formatting
      is allowed with variable-length-record files.


      SEQUENTIAL FILES      __________ _____

      A sequential file is a variable-length-record file in which explicit
      file-positioning is not allowed;  that is, reading and writing must
      take place in the same sequence in which data is stored on that file.
      Once the file is opened, the first data item in the file must be read
      or written, then the second, etc.  The terminal, which functions as a
      sequential file, is discussed in subsection 11.4.



      11.3 LOCATION AND POSITION      ____ ________ ___ ________


      LOCATION      ________

      Each data unit in a variable-length-record file, and each record in a
      fixed-length-record file, is assigned a positive integer called its
      location.  There is only one location pointer for a file.  Locations
      begin at 1, and the location is set to 1 when a file is opened.

      The function LOC(n) returns the value of the location pointer in file
      n.  For fixed-length-record files the value of LOC(n) is a record
      number.  For variable-length-record files, the value of LOC(n) is a
      data unit number.  When reading or writing a fixed-length-record
      file, the location returned by LOC(n) does not change until the
      entire record is read or written.  Thus, if a LOC(n) function is
      executed while the position pointer is at the middle of a record, the
      value returned is the same as it was when the position pointer was at
      the start of the record.  See section 11.5 for examples of the usage
      of LOC(n).



      POSITION      ________

      For fixed-length-record files, the position is defined as the data
      unit (character or word) offset within the current record at which
      the next input or output will be performed.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 127
      1 January 1978                                               Sec. 11.3


      For variable-length-record files, the position is again defined with
      respect to the beginning of the current record (or line).  However,
      there are special rules that determine where the current record
      begins:

           1.  If the AT clause or LOCATE statement is used, then a record
               is defined as beginning at the specified location.

           2.  In a symbolic variable-length-record file, if a carriage
               return is read or written then a record is defined as
               beginning immediately following the carriage return.

      In both cases, the position is set to 1.

      Positions begin at 1, and the position is set to 1 when a file is
      opened.

      The function POS(n) returns the data unit position within the current
      record or line at which the next input or output on file n will be
      performed.



      CARRIAGE RETURNS AND END OF RECORD      ________ _______ ___ ___ __ ______

      The end of a record in fixed-length-record files behaves similarly to
      the carriage return/line feed sequence in variable-length-record
      files.  They are referred to together as EOR.  The FORM character "/"
      or "R", the end of an IMAGE, and the end of a free-form print or
      input list produce or seek an EOR and when used cause the position to
      be set to 1.



      11.4 THE TERMINAL AS A FILE      ____ ___ ________ __ _ ____


      General      _______

      The terminal functions as a sequential file.  The same rules for the
      use of OPEN, CLOSE, INPUT and PRINT for files apply to the use of the
      terminal as a numbered file.  For example:

      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 128
      1 January 1978                                               Sec. 11.4


              >10 open "TERM",input,1
              >20 input from 1 in image "#":a,b,c
              >30 PIM "#":a,b,c
              >40 close 1
              >50 end

      When "TERMINAL" is specified in an OPEN statement, the terminal is
      treated as an open file and is counted as one of the 15 files that
      may be open concurrently.  Input and output on the terminal file
      perform identically to normal terminal input and output.



      Program Activation Characters      _______ __________ __________

      In the Command/Statement phase, each statement or command entered is
      terminated with a program-activation character in the form of a
      carriage return.  The carriage return causes TYMBASIC to parse the
      input and return error and diagnostic messages if faults are
      discovered.

      In the Run phase, a TYMBASIC program awaiting input from the terminal
      is activated by either a carriage return, a Control-G, or a
      Control-B.  The first two characters allow run-phase processing to
      continue.  Control-B causes the current INPUT list to be restarted
      and the program to again wait for input.



      11.5 RANDOM-ACCESS OPERATIONS      ____ _____________ __________



      ERASING PART OF A FILE      _______ ____ __ _ ____

      The ERASE statement can be used to erase any selected segment in a
      random file open for OUTPUT or IO (but not for INPUT).

      If the end of a file is erased, nulls (zeroes) are written in the
      specified locations.  The file thus becomes smaller as reflected by
      the SIZE function;  however, the file size as stored on the disk will
      not be affected.

      If the erased portion is in the middle of the file, then spaces (for
      symbolic) or nulls (for binary) are written in the specified
      locations, and the file size is not affected.  The location for that
      file after the erasure is one greater than the last erased location.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 129
      1 January 1978                                               Sec. 11.5


      In the following example the file "FILIN.MM" has characters 3 through
      25 erased by the program

              >10 STRING INPUT.LINE
              >20 COPY "FILIN.MM" TO "TERMINAL"
              >30 OPEN "FILIN.MM-A", RANDOM IO, 5   ! must be open for                                                                        _
                                                      OUTPUT or IO
              >40 ERASE 5 FROM 3 TO 25
              >50 CLOSE 5
              >60 COPY "FILIN.MM" TO "TERMINAL"
              >70 END

              >RUN
              ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIMM
              AB                       ZABCDEFGHIMM
              END IN LINE   70



      CHANGING LOCATION      ________ ________

      The AT clause used with the INPUT and PRINT statements and the LOCATE
      statement move the location pointer to the specified location, and
      set the position to 1.  Normal input and output may also cause the
      location to increase sequentially.



      In Fixed-length-record Files      __ ___________________ _____

      With fixed-length-record files, the AT clause or LOCATE statement
      moves the location pointer to the beginning of the specified record.
      Thus, if the file "FILIN.Z" contains

              ABCDEFGHIJKLMNOPQRSTUVWXYZAB

      the program

              >10 STRING A,B,C
              >20 OPEN "FILIN.Z", RANDOM(5) INPUT,1
              >30 INPUT FROM 1 AT 2 IN FORM "5X/":A,B,C
              >40 PRINT A;B;C

      will print the characters

              FGHIJ    KLMNO    PQRST

      The first record (consisting of the characters ABCDE) is skipped
      because the AT 2 clause moves the location to the start of record 2
      (i.e.  F).  After each record is processed, the location is set to
      the start of the next record.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 130
      1 January 1978                                               Sec. 11.5


      In Variable-length-record Files      __ ______________________ _____

      The principal difference in how location is manipulated with
      variable-length-record versus fixed-length-record files is that, with
      variable-length-record files, the location refers to the position of
      individual data units rather than records.  Thus, with the file
      "FILIN.Z" containing the data

              ABCDEFGHIJKLMNOPQRSTUVWXYZABC

      the program

              >5 STRING A,B,C
              >10 OPEN "FILIN.Z", RANDOM INPUT, 1
              >20 INPUT FROM 1 AT 5 IN FORM "5X":A,B,C
              >30 PRINT A;B;C

      will print three groups of characters, starting with the fifth:

              EFGHI    JKLMN    OPQRS

      The location pointer goes to the fifth character and processing
      starts at that point.



      RECORD BOUNDARIES IN FIXED-LENGTH-RECORD SYMBOLIC FILES      ______ __________ __ ___________________ ________ _____

      Record boundaries in symbolic files must be crossed explicitly.
      Failure to do so may cause a file error condition with associated
      error message:  "Attempt to overflow fixed length record on random
      file".  Thus, for example, with the file "FILIN.Z", which contains
      the data

            ABCDEFGHIJKLMNOPARSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ

      an error condition is generated as soon as the following program
      tries to execute line 50:

              >10 STRING A,B
              >20 OPEN "FILIN.Z", RANDOM (10)INPUT,1
              >30 INPUT FROM 1 IN FORM "10X/":A
              >40 PRINT A
              >50 INPUT FROM 1 IN FORM "12X/":B
              >60 PRINT B
              >RUN
              ABCDEFGHIJ

              Attempt to overflow fixed length record on random file
                  in line   50
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 131
      1 January 1978                                               Sec. 11.5


      The format "12X/" illegally attempted to read through the
      10-character record boundary declared in line 20.

      Note that although TYMBASIC will not cross a record boundary to
      either read or write data, when an output format specifies a length
      longer than the space left in the record, characters will be written
      up to the end of the current record even though this constitutes an
      error condition.  Thus, although the following program yields an
      error:

              >15 ON ERROR GOTO 100
              >20 OPEN "DATA3-A", RANDOM (10) IO, 3
              >30 PRINT ON 3 IN FORM "15D/":"1234567890123456"
              >40 STOP
              >100 PRINT ERRMSG(ERRCD):" in line":ERRLN
              >150 CLOSE 3
              >160 END

              >RUN
              Attempt to overflow fixed length record on random file in
              line 30
              END IN     160

      ten characters are nevertheless written on the file "DATA3":

              -TYPE DATA3
              1234567890



      Use of / to Cross Record Boundaries      ___ __ _ __ _____ ______ __________

      When a FORM is used for file input or output, TYMBASIC will not cross
      record boundaries to process successive records without the presence
      of the character / (or the character R, discussed below) in the FORM.
      In the following examples the file "FORM.IMM" contains

              RECORD ONERECORD TWO

      Note that although the following program only attempts to input the
      same number of characters as the record length, an error is
      generated:

              >10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
              >20 STRING A,B
              >30 INPUT FROM 1 IN FORM "10%":A
              >35 INPUT FROM 1 IN FORM "10%":B
              >40 PRINT A;B
              >50 CLOSE 1
              >60 END
              >RUN
              Attempt to overflow fixed length record on random file
                  in line 35
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 132
      1 January 1978                                               Sec. 11.5


      However, when the / is added to the format in line 30 the program
      runs to completion:

              >10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
              >20 STRING A,B
              >30 INPUT FROM 1 IN FORM "10%/":A
              >35 INPUT FROM 1 IN FORM "10%/":B
              >40 PRINT A;B
              >50 CLOSE 1
              >60 END

              >RUN
              RECORD ONE  RECORD TWO
              END IN     60

      On output to a fixed-length-record file using /, if the record has
      not been completely filled when a / is encountered, it is padded with
      spaces.



      Use of IMAGE to Cross Record Boundaries      ___ __ _____ __ _____ ______ __________

      When used for fixed-length-record file input or output, an IMAGE
      causes the current record to be processed and then moves the location
      and position pointers to the start of the next record.

              >10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
              >20 STRING A,B
              >30 INPUT FROM 1 IN IMAGE "%%%%%%%%%%":A,B
              >40 PRINT A;B
              >50 CLOSE 1
              >60 END

              >RUN
              RECORD ONE  RECORD TWO
              END IN     60

      Note in the following example that only the first four characters of
      each record are printed and that after each input takes place the
      location and position pointers automatically move to the start of the
      next ten-character record.

      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 133
      1 January 1978                                               Sec. 11.5


              >10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
              >20 STRING A,B
              >30 INPUT FROM 1 IN IMAGE "%%%%":A,B
              >40 PRINT A;B
              >50 CLOSE 1
              >60 END
              >RUN
              EXECUTION
              RECO  RECO
              END IN     60

      On output to a fixed-length-record file using an IMAGE, if the number
      of characters specified by the IMAGE is less than the record length,
      the data specified by the IMAGE is printed and the remainder of the
      record is padded with spaces.



      Use of R Format      ___ __ _ ______

      With fixed-length-record files the "R" format reads or writes up to
      the end of the current record.  If the current position is at some
      point before the end of the record then "R" specifies that the
      remainder of the record be read or written.  Also, "R" performs the
      same location function as "/";  that is, it moves the location
      pointer to the start of the next record and sets the position to 1.
      In the following example the file "FORM.IMM" contains the data

              RECORD ONERECORD TWO

      which is processed by the program

              >10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
              >20 STRING A,B,C,D
              >30 INPUT FROM 1 IN FORM "6% R":A,B,C,D
              >40 PRINT A:B;C:D
              >50 CLOSE 1
              >60 END

              >RUN
              RECORD ONE  RECORD TWO
              END IN     60

      The "R" format is used to read the remaining four characters of each
      ten-character record into variables B and D.

      If line 30 were modified to read:

              30 INPUT FROM 1 IN FORM "10% R":A,B,C,D
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 134
      1 January 1978                                               Sec. 11.5


      the "R" would perform the same location function as a / in that
      position, but the variables B and D would then receive null strings.
      A would receive "RECORD ONE", and C would receive "RECORD TWO".

      In variable-length-record files, the "R" format reads or writes up
      through the next carriage return (or end of file on input) and causes
      the position to be set to 1.
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 135
      1 January 1978                                               Sec. 11.5


      EXAMPLE      _______

      The file "FILIN.Z" which contains the 53 characters

      ABCDEFGHIJKLMNOPQRSTUVWXYZ*ABCDEFGHIJKLMNOPQRSTUVWXYZ

      is read by the following program:

      >10 STRING A,C
      >20 OPEN "FILIN.Z-A", RANDOM (15) INPUT, 1
      >30 PRINT "INPUT FILE SIZE = ":SIZE(1):" RECORDS"
      >40 OPEN "FILIN.Y-A", RANDOM (10) OUTPUT, 2
      >50 LOCATE 2 ON 1 !SET POINTER TO RECORD 2 IN FILE 1
      >70 PRINT "FILE 1 POINTER SET INITIALLY AT INPUT RECORD ":LOC(1)
      >80 PRINT "FILE 2 POINTER SET INITIALLY AT OUTPUT RECORD ":LOC(2)
      >90 PRINT "VALUE OF POS(1) IS : ":POS(1)
      >100 INPUT FROM 1 IN FORM "10X":A
      >110 PRINT "AFTER READING ":A:" POS(1) IS":POS(1)
      >120 PRINT ON 2 IN FORM "10X/":A   ! first output record
      >130 PRINT "LOCATION ON FILE 1 STILL AT RECORD":LOC(1)
      >140 INPUT FROM 1 IN FORM "R":A !READ REMAINDER OF RECORD
      >150 PRINT "CHARACTERS SKIPPED IN RECORD 2 ARE: ":A
      >160 PRINT "RECORD POINTER NOW MOVED TO START OF RECORD ":LOC(1)
      >170 INPUT FROM 1 IN FORM "10X/":A
      >180 PRINT "NOW, AFTER READING ":A:" POS(1) IS ":POS(1)
      >190 PRINT ON 2 IN FORM "10X/":A   ! second output record
      >200 PRINT "LOCATION IN FILE 1 IS AT RECORD":LOC(1)
      >210 PRINT "LOCATION IN FILE 2 IS AT RECORD":LOC(2)
      >220 PRINT "SIZE OF FILE 2 (OUTPUT FILE)=":SIZE(2):" RECORDS"
      >230 CLOSE 1,2
      >240 OPEN "FILIN.Y-A", RANDOM INPUT, 3
      >250 INPUT FROM 3 IN FORM "R":C
      >260 PRINT "SIZE OF FILE 3 =":SIZE(3):" CHARACTERS"
      >270 PIF "/'AND HERE ARE THE CONTENTS OF FILE 3: 'R":C
      >280 CLOSE 3
      >290 END

      >RUN
      INPUT FILE SIZE =  3 RECORDS
      FILE 1 POINTER SET INITIALLY AT INPUT RECORD  2
      FILE 2 POINTER SET INITIALLY AT OUTPUT RECORD  1
      VALUE OF POS(1) IS :  1
      AFTER READING PQRSTUVWXY POS(1) IS 11
      LOCATION ON FILE 1 STILL AT RECORD 2
      CHARACTERS SKIPPED IN RECORD 2 ARE: Z*ABC
      RECORD POINTER NOW MOVED TO START OF RECORD  3
      NOW, AFTER READING DEFGHIJKLM POS(1)  IS  1
      LOCATION IN FILE 1 IS AT RECORD 4
      LOCATION IN FILE 2 IS AT RECORD 3
      SIZE OF FILE 2 (OUTPUT FILE)= 2 RECORDS
      SIZE OF FILE 3 = 20 CHARACTERS
      AND HERE ARE THE CONTENTS OF FILE 3: PQRSTUVWXYDEFGHIJKLM
      END IN     290
      TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT        Page 136
      1 January 1978                                               Sec. 11.5


      In this program the file "FILIN.Z" is opened for input with a
      15-character record length.  A second file, which is opened for
      output with a 10-character record length (see line 40), has portions
      of the input data file written on it.  This file is then reopened for
      input (line 240) and its contents printed.  Note:


           1.  The size of file 1 is given as 3 records (line 30) because
               the fourth record (i.e., the last 8 characters) is
               incomplete.

           2.  Because there is no / in the format in line 100 the position
               pointer in record 2 stops at the 11th character in the
               record, i.e.  the next one to be processed after the 10
               required by the format.  Hence, at this point POS(1)=11.

           3.  The format "R" in line 140 reads the remaining characters
               not yet processed in the record and moves the location and
               position pointers to the start of record 3.  Hence, LOC(1)
               in line 160 returns a value of 3.

      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 137
      1 January 1978                                               Sec. 12.1


                          SECTION 12         FORMATTING


      12.1 INTRODUCTION      ____ ____________

      This section describes the formatting capabilities of TYMBASIC
      applied to terminal and file I/O, the use of the DATA and READ
      statements and the STR and VAL functions.  The three types of
      formatting are free-form, IMAGE, and FORM.

      Free-form, discussed in Section 12.2, is the simplest, using the
      INPUT statement or the PRINT statement plus delimiters.  A variety of
      numeric formats are accepted on input.  The semicolon and comma, used
      as delimiters in a print list of a PRINT statement, create zones
      across the print line in which each output expression is printed.  A
      colon joins output fields.  An example:

           >10 header$= "The score is"
           >20 score = 15
           >30 print header$;score
           >run
           The score is    15


      IMAGE and FORM formatting are specified by including a format string
      in a PRINT or INPUT statement.  For example:

           >10 PRINT IN FORM "4X/": F$
           >20 INPUT IN IMAGE I$: A

      IMAGE formatting, discussed in Section 12.3, uses two characters (#
      and %) to indicate the layout of an input or output line.  It can
      specify integer, decimal, E-format, and string formats, and a
      format-string rescan allows automatic repetition of the same format.
      A single # indicates free-form data conversion.  Literal text can be
      included in the format string;  any characters other than % or #
      fields are taken to be literal text.  An example:

           >10 month$="March"
           >20 day=2
           >30 print in image "The date is: # %%":month$,day
           >run
           The date is: March  2

      The single # specifies free-form output of the value for month$, the
      two % characters specify a two-digit field for the day.

      FORM formatting, discussed in Section 12.4, incorporates most of the
      features of free-form and IMAGE formatting, and also offers a variety
      of characters to control the exact structure and placement of fields,
      and capabilities such as floating $;  automatic indication of
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 138
      1 January 1978                                               Sec. 12.1


      negative balances with parentheses or minus signs;  leading *
      characters for dollar fields;  binary, hex, and octal conversion;
      upper and lower case conversions;  and changing zeros to spaces.
      Literal text in a FORM format string is indicated by quotation marks
      within the format string, for example:

           >10 A = 46
           >20 print in form "'The answer is:' 5z":A
           >run
           The answer is:   46

      For both IMAGE and FORM output, numeric values greater than the
      maximum significance (7 significant digits in single precision, 18 in
      double) are treated as follows:  the number is rounded to the maximum
      significance and the excess digits are replaced by zeros.  For
      example:

           >10 A=123456789.1234
           >20 PRINT IN IMAGE "%%%%%%%%%%.%%%%": A
           >run
            123456800.0000


      TERMINAL OUTPUT      ________ ______

      Trailing spaces are always supressed in output to the terminal.
      Also, if a carriage return is printed when the carriage position is 1
      (POS function not including trailing spaces), only a line feed is
      printed.

      OUTPUT OF NUL CHARACTERS      ______ __ ___ __________

      Nul characters (zeroes) may not be printed in TYMBASIC, except in
      eight-level terminal output.

      ARRAY INPUT AND OUTPUT      _____ _____ ___ ______

      If an entire array is printed or input its elements are accessed by
      varying the last subscript most rapidly.

      INPUT AND OUTPUT OF CARRIAGE RETURNS      _____ ___ ______ __ ________ _______

      If a carriage return character is printed as part of a string,
      TYMBASIC automatically follows it by a line feed character.
      Conversely, if a carriage return/ line feed pair is input, the line
      feed is discarded and only the carriage return becomes part of the
      string.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 139
      1 January 1978                                               Sec. 12.1


      DEFINITIONS      ___________

      The following definitions are applicable to the discussion of
      TYMBASIC formatting capabilities.

              a.  CONVERSION                  __________

      Conversion, in general, is the process of creating in a given mode of
      representation a string of characters or bits which correspond to a
      string of characters or bits in another mode of representation.  With
      respect to TYMBASIC I/O formatting, there are three types of
      conversion:  (1) from internal numeric representation to string (i.e.
      numeric output);  (2) string to internal numeric representation (i.e.
      numeric input);  and (3) string representation to string
      representation (i.e.  string input and output), which is strictly
      speaking a type of editing rather than conversion.  An example would
      be the formatting of the string "1^^4" into the string "1004".

              b.  FORMAT STRING                  ______ ______

      A format string is a group of special-purpose characters in a PRINT
      or INPUT statement that controls or modifies conversion, spacing,
      upper/lower case, storage, sequence, etc. of input or output data.

              c.  FORMAT FIELD                  ______ _____

      A format field is a group of characters in a format string that stand
      alone (delimited by separation characters), for the purpose of the
      transmission of a specific data item.

              d.  FIELD SEPARATOR                  _____ _________

      A field separator is a special-purpose character (e.g. a space) that
      delimits a field in a format string.

              e.  LITERAL TEXT                  _______ ____

      Literal text is a sequence of characters within a format string that
      are to be printed exactly as they occur or else, on input, cause
      skipping of the same number of characters.

              f.  EOR                  ___

      EOR (for "End Of Record") is the abbreviation used in this manual to
      denote an end of record or a CR/LF in a file or the terminal viewed
      as a file.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 140
      1 January 1978                                               Sec. 12.2


      12.2. FREE-FORM FORMATTING      _____ _________ __________


      Free-form formatting is the easiest to use, but has the least
      specific format control.


      INPUT      _____

      In free-form input, items read in response to the input list of an
      INPUT statement must be separated by a comma, space, carriage return,
      or (terminal input only) Control-G.

      Null input is ignored.  For example:

           >10 input a,b,c
           >20 print a,b,c
           >run
           ? 10,,20 (cr)
           ? (cr)
           ? 30 (cr)
            10             20             30

      Neither the extra comma nor the second carriage return has any
      effect.  Leading spaces are also ignored.  String text input that
      contains commas or leading spaces must be enclosed in quotes.


      OUTPUT      ______

      In free-form output, the characters  ,   ;   :  used as separators of
      expressions in a PRINT statement determine spacing in the output
      print line.  A single-expression print list requires no punctuation:

           10 PRINT A

      will print the value of A followed by a carriage return.

      Comma and Semicolon      _____ ___ _________

      A comma in a print list divides the line into zones of 15 spaces.  A
      value is printed left-justified in a zone (the first space for
      numeric output is reserved for a sign).  After a comma is
      encountered, the next value is printed at the start of the next zone.
      For example:

           >PRINT 1,2,3
            1              2              3
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 141
      1 January 1978                                               Sec. 12.2


      If there is not at least one space between the end of text in the
      last zone and the beginning of text in the next, a zone is skipped
      and printing starts in the beginning of the next zone:

           >10 A=99,B=88
           >20 PRINT "TEST VALUE (NEWTONS)",A,B
           >RUN
           TEST VALUE (NEWTONS)          99              88

      The 21 string characters use all of zone one and 6 spaces of zone
      two, so the value of A begins the third zone and B the fourth.

      If there is not room enough on the current line (determined by line
      length - see the LOL statement), then a carriage return is printed
      and the value is printed in the first zone of the new line.  (The
      carriage return is not printed if the current line is empty.)

      The semicolon has the same effect as a comma except that the print
      zones are 3 spaces wide:

           >PRINT -1;2;3
           -1  2  3

      The comma or semicolon may be used simply for spacing.  For example:

           >print -1;;3
           -1     3 

      Colon      _____

      A colon separator causes two values to be concatenated.  For example:

           >10 PRINT K: FOR K = -2 TO +2
           >20 PRINT "ALL":"TOGE":"THER":"NOW"
           >RUN
           -2-1 0 1 2ALLTOGETHERNOW


      Note that a space is automatically generated for a positive number in
      the place of a minus sign for a negative number.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 142
      1 January 1978                                               Sec. 12.2


      Combinations      ____________

      When used in combination in a PRINT statement, the separators each
      give the output their characteristic spacing, with comma and
      semicolon creating both 15 and 3 character zones simultaneously.  For
      example:

           >10 A=5,B=-6,C=7,D=8,E=-9
           >20 PRINT A:B:C;D,E
           >run
            5-6 7    8    -9

      The colons join the values of A, B, and C;  the semicolon causes the
      value of D to be left justified in the next 3-space print zone;  and
      the comma causes the value of E to be left justified in the next
      15-space print zone.


      End of Print List      ___ __ _____ ____

      A carriage return/line feed is automatically generated if punctuation
      does not end a PRINT statement.  Thus one or more PRINT statements
      alone (without print list or punctuation) may be used to print blank
      lines.

      Array Output      _____ ______

      If an entire array is printed in free-form, the spacing between its
      elements is determined by the delimiter immediately following the
      array in the print list.  If the array is not followed by any
      punctuation, its elements are separated by comma (15-character zone)
      spacing.


      JOINING INPUT AND OUTPUT      _______ _____ ___ ______

      Punctuation can be used to allow input text to appear on the same
      line as output text.  Also, if the input text is terminated by typing
      a Control-G (abbreviated [Gc]), rather than a carriage return, more
      output text may be provided on the same line.  For example:

           >10 print "B=";
           >20 input b
           >30 print " (DIVISOR)"
           >run
           B=? 99 [Gc] (DIVISOR)
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 143
      1 January 1978                                               Sec. 12.2


      CONVERSION CHARACTERISTICS      __________ _______________



                           FREE-FORM INPUT CONVERSION                           _________ _____ __________

      Format                        Accepts numbers in all formats:
                                    integer, decimal, E-format and D-
                                    format.  Also accepts string input
                                    to variables declared as string.
                                    Numeric input can have no imbedded
                                    spaces.

      Sign                          Treats unsigned input numbers as
                                    positive.

      Decimal point                 Accepts and ignores any number of
      and zero                      leading integer zeros and trailing
      suppression                   decimal zeros.  Accepts decimal point
                                    not followed by numerals.

      Logical input                 Accepts input values for variables
                                    declared as logical.  Zero and nonzero
                                    values are converted to 0's and 1's
                                    respectively.

      Complex input                 Accepts two input values as
                                    complex input to variables
                                    declared as complex.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 144
      1 January 1978                                               Sec. 12.2


                           FREE-FORM OUTPUT CONVERSION                           _________ ______ __________

      Numeric Output

        *Integer                    Integer form retained through 11
                                    digits. E-format used over 11 digits.
                                    Numeric range: +34x10**9 through
                                    -34x10**9.

        *Real and Double            Printed with decimal point and
                                    fractional part (except for exact
                                    integer values) up to 7 significant
                                    digits for single precision and 14
                                    14 significant digits for double
                                    precision (or as specified by
                                    SIGNIFICANCE statement).  E-format used
                                    for larger quantities and quantities
                                    smaller than .1.  Numeric range
                                    from -10**38 through +10**38.

      Rounding

        *Integer                    None

        *Real (single precision)    Rounds after 7 significant digits
                                    (or less, as specified by SIGNIFICANCE
                                    statement).

        *Real (double precision)    Rounds after 14 significant digits
                                    (or up to 18 as specified by
                                    SIGNIFICANCE statement).

      Decimal point and             Trailing zeros after decimal point
      zero suppression              are not printed.  Decimal point
                                    is printed only if fractional
                                    digits are generated.

      Treatment of                  Space printed before positive numbers.
      sign                          Minus sign printed before negative
                                    numbers.

      Logical Output                Prints 0 and 1 integer values.

      Complex Output                Printed as pairs of real values:
                                    one for the real part and one
                                    for the imaginary part. Comma
                                    separates real and imaginary parts.
                                    Follows same rules as real numbers
                                    with respect to format, precision
                                    and rounding.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 145
      1 January 1978                                               Sec. 12.3


      12.3. IMAGE FORMATTING      _____ _____ __________


      The IMAGE format string in a PRINT or INPUT statement prints or
      accepts exactly one line or record.  It uses  % and  # characters to
      define the image of a number or string.  The number of % or #
      characters given in a format field determines the number of
      characters formatted;  an exception is a single # used for free-form
      conversion.  Literal text may appear in the format (all text other
      than % or # fields is taken as literal text).  For example:

           >10 NAME$='JONES'
           >20 RANK=23
           >30 PRINT IN IMAGE "FIRST  %%%%% %%':NAME$,RANK
           >RUN
           FIRST  JONES 23

      The IMAGE field specifies printing of the literal text FIRST, two
      spaces, the string value of NAME$ formatted for 5 characters, a
      single space, and finally the numeric value of RANK, formatted as two
      digits.

      In determining the number of characters for numeric output, an extra
      character must be provided for the minus sign of negative values.  An
      attempt to output a sign without having reserved a space generates an
      error condition.

      LONG AND SHORT FORMAT FIELDS      ____ ___ _____ ______ ______


          OUTPUT       |           numeric                   string
                       | integer part    decimal part                  
          ------------------------------------------------------------
          Format field>|
          output value | leading spaces  trailing zeros   trailing spaces
                       |
          Format field<|
          output value | error condition    rounding         truncation


          INPUT        |           numeric                   string
                       | integer part    decimal part
          ------------------------------------------------------------
          Format field>|
          input string |       generates  an  error  condition
                       |
          Format field<|
          input string |          truncation                 truncation
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 146
      1 January 1978                                               Sec. 12.3


      NUMERIC FIELDS      _______ ______

      The % character is used to format integer and decimal fields;  the #
      character is used for E-format fields.  (A single # may also be used
      - see FREE-FORM IMAGE, below.) Spaces input by a % or # field are
      interpreted as zeroes.

      Integer      _______

      A series of one or more % characters can format an integer field.
      One % is needed for a sign.  Examples:

           FORMAT FIELD    PRINTS      AS

            %%%%%%%         200       ^^^^200
                           -200       ^^^-200
                            5.67      ^^^^^^6

            %%%             200       200
                           -200      error condition
                            5.67      ^^6


      Decimal      _______

      To output a decimal value, include a decimal point at the appropriate
      location in the format field:

           FORMAT FIELD    PRINTS      AS

            %%%%%.%%        200       ^^200.00
                           -200       ^-200.00
                            5.67      ^^^^5.67

            %%%%.%%%%       200       ^200.0000
                           -200       -200.0000
                            5.67      ^^^5.6700

            %%%%.%          5.67      ^^^5.7


      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 147
      1 January 1978                                               Sec. 12.3


      E-Format      ________

      A minimum of 7 # characters, or 6 with a decimal point, are needed
      for E-format input or output.  Assuming such a format (either
      "#######" or "#.#####") the assignment of characters is:

           #       the sign position
           . or #  the decimal point
           #       the minimum single digit mantissa
           #       the character E
           #       sign of the exponent
           ##      two places for the exponent

      All positions are required;  if there is not at least one # before
      the decimal point an error condition will result.  A # character must
      be supplied for each digit in the mantissa.  Examples:

           FORMAT FIELD    PRINTS     AS

            #######         200    ^.2E+03
                           -200    ^.2E+03
                            5.67   ^.6E+01

            #########       200    ^.200E+03
                           -200    -.200E+03
                            5.67   ^.567E+03

            ##.#####        200    ^2.0E+02
                           -200    -2.0E+02
                            5.67   ^5.7E+00



      STRING FIELDS      ______ ______

      Either # or % may be used to format string fields.  Examples:

           >10 a$="URE360"
           >20 PIM "%%%%%%":a$
           >30 PIM "####":a$
           >run
           URE360
           URE3


      FREE-FORM IMAGE      _________ _____

      A single # can be used for free-form conversion of values, exactly as
      described in "Free-form Conversion Characteristics", Sec. 12.2.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 148
      1 January 1978                                               Sec. 12.3


      Note that free-form conversion cannot be used for writing to a random
      file with fixed-length records.  The # itself does NOT read or write
      a carriage return.  End of image, however, will (see END OF IMAGE,
      below).


      LITERAL TEXT      _______ ____

      All characters in an IMAGE format string, including spaces, are
      considered literal text except those characters that comprise the
      format fields (%, #, and a decimal point immediately preceeding or
      following a % or #).

      On output, every character of literal text is printed exactly as it
      appears in the format string.

      On input from a terminal, literal text in a format string is printed
      at the terminal as follows:

                  a.  If the literal text precedes the format field the
                  text is printed and the system then looks for input.
                  b.  If the text follows a format field, the system looks
                  for input.  After the input is received the text is
                  printed.

      On input from a file, literal text in a format string causes a
      corresponding number of input characters to be skipped.  Thus, if the
      IMAGE format string "ZZ%%%" is used to read the input A=666, the data
      accepted is 666.  If the format string "A=%%%" is then used for
      output the characters A= would be printed before each value.  For
      example, the data

              A=123
              A=456
              A=789

      is read from the file URE.360 and printed by the program:

              >10 OPEN "URE.360-A", INPUT, 1
              >15 ON ENDFILE 1 GOTO 40
              >20 INPUT FROM 1 IN IMAGE "XX%%%":NN
              >25 PIM "A=%%%":NN
              >30 GOTO 20
              >40 CLOSE 1
              >50 END

              >RUN
              A=123
              A=456
              A=789

              END in line 50
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 149
      1 January 1978                                               Sec. 12.3


      END OF IMAGE      ___ __ _____

      When the end of an input IMAGE format string is reached, TYMBASIC
      seeks or prints an EOR and ignores further input characters until the
      EOR is read.  For example, with the following file only the first
      three characters of each record are read.

              123456
              234567
              345678
              456789

              >10 OPEN "END.IMG-A", INPUT, 1
              >20 ON ENDFILE (1) GOTO 60
              >30 INPUT FROM 1 IN IMAGE "%%%":KK
              >40 PRINT KK
              >50 GOTO 30
              >60 CLOSE 1
              >70 END

              >RUN
              123
              234
              345
              456

              END in line 70

      When the end of an output IMAGE format string is reached an EOR is
      generated.  The remainder of a fixed-length record is filled with
      spaces.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 150
      1 January 1978                                               Sec. 12.4


      12.4 FORM FORMATTING      ____ ____ __________

      FORM formats have similarities to IMAGE formats (both use % and #
      characters), but whereas the IMAGE format builds a character by
      character image of a line, the FORM format specifies one or more
      fields, using both formatting and utility characters.  

      In the FORM format, characters and fields can be replicated, using
      numbers, parentheses, and brackets.  Since the format is not an
      image, a space does not produce or accept a space on output or input,
      but is used to delimit fields;  the utility character B indicates a
      literal space.  Literal text must be enclosed in quotes.

      An example of some of these differences:  the IMAGE format

           PRINT IN IMAGE "%%%%%%   %% %% %% THE END":  a,b,c,d

      could be specified with a FORM format as

           PRINT IN FORM "6% 3B 3(2%B) 'THE END'":  a,b,c,d

      The treatment of format fields that are either longer or shorter than
      the corresponding input or output values is the same as for IMAGE, as
      described under "LONG AND SHORT FORMAT FIELDS" in Sec. 12.3.

      This subsection describes the formatting characters, the utility
      characters, FORM input and output, and concludes with the treatment
      of EOR's by FORM formats.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 151
      1 January 1978                                               Sec. 12.4


      FORMATTING CHARACTERS      __________ __________

      The % and # characters follow the same rules as for IMAGE formatting.
      The following additional formatting characters cannot be used in the
      same field with either % or #, although their use in different fields
      of the same FORM format is allowed.

      The FORMATTING CHARACTERS table below is arranged alphabetically with
      + and - appearing near the sign-formatting character S and .
      appearing near V, the decimal point positioning character.  The $ and
      * formatting characters appear at the end of the table.  By function,
      the characters fall into three groups:

        String    Either      Numeric
        ------    ------      --------
           A         D        E   H   K
           C         Y        O   P   Q
           J                  S   +   -
           R                  .   V   W
           U                  Z   $   *
           X


                              FORMATTING CHARACTERS

      Char-     Description              Example
      acter             
      -----------------------------------------------------------------

      A    For printing or             6A        Prints "ABCD" as
           input of strings                      ABCD^^
           only. Prints or
           accepts a letter or
           a space only.
       
      C    Prints or accepts any       6C        Prints "ABC" as
           string character. On                  ^ABC^^
           output, centers the
           string (if string
           cannot be evenly
           centered it is left-
           centered). On input, C
           is equivalent to X.
           Cannot appear in same
           field with any other
           format character.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 152
      1 January 1978                                               Sec. 12.4


      D    For either string
           or numeric fields:
            *Prints or accepts         6D        Prints 1004 as 001004.
             digits in numeric                   Reads 1004 from 001004.
             fields. Leading or
             embedded zeros
             are printed.
            *Prints or accepts         6D        Prints "1004" as 100400
             string characters                   Reads 100400 from 1^^4^^
             0-9 and space.
             Spaces are replaced
             by zeros.
       
      E    Specifies that the          3D.DESDD  Prints 1004 as
           expression is printed                 100.4E+01. Reads 1004
           or interpreted as                     from 100.4E+01
           E-format notation. The
           E is printed. There
           can be only be one
           E per field.
       
      H    Converts a number           6H        Prints 1004 as 003EC.
           to hexadecimal.                       Reads 1004 from 0003EC
           Supplies leading zeroes.
           Cannot be concatenated
           with any other format
           character. Number to
           be converted must be
           declared integer.
       
      J    Prints or accepts any       6J        Prints "ABC" as
           string character. On                  ^^^ABC
           output, right-justifies
           the string. On input it
           is equivalent to X. J
           cannot appear in the same
           field with any other
           format character.
       
      K    Same as E except that       3D.DKSDD  Prints 1004 as
           E is not printed on                   100.4+01
           output.
       
      O    Converts a number           8O        Prints 1004 as 00001754
           to octal. Supplies                    Reads 1004 from
           leading zeros. Cannot                  00001754
           be concatenated with
           any other format
           character. Number to be
           converted must be
           declared integer.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 153
      1 January 1978                                               Sec. 12.4


       
      P    For printing negative       P6QP      Prints -1004 as (1004)
           values enclosed in                    Prints +1004 as ^1004^
           parentheses. Sufficient
           P's must appear to allow    3P.4P     Prints -12.4 as (12.400)
           values to be so treated.              Prints 12.4 as ^12.400^
           More than one P in
           integer part or exponent
           prints or accepts a
           number with a left
           parenthesis floated to
           left of number.
           Prints spaces in            D.DEPDDP  Prints .000123 as
           place of parentheses                  1.2E(04))
           if value is positive.                 Prints 1234 as 1.2E^03^
           P's can also be placed
           around the exponent of
           a number.
       
      Q    Output only, for            6Q        Prints 1004 as 1004
           printing a number left
           adjusted. Prints one
           digit per character.
           Unneeded character
           positions are suppressed.
       
      R    For free-form input or      R         Prints "ABC123" as
           output of complete                    ABC123 followed
           strings. Supplies EOR                 by a carriage return.
           on output. Reads EOR                  Reads ABC123 from
           on input but does not                 ABC123CR/LF
           make it part of string.
           In fixed-length record
           random files, R prints
           all or remainder of a
           record and moves
           current-location pointer
           to start of next record
       
      S    More than one S prints      6S        Prints 1004 as ^+1004
           or accepts a number
           with sign floated           S5D       Prints 1004 as +01004
           to left of number.
           One S anywhere in a         5DS       Prints 1004 as 01004+
           numeric format prints
           the sign in that position.
       
      +    For printing sign of        6+        Prints +1004 as ^+1004
           a positive number.
           Two or more + signs
           float to left of number.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 154
      1 January 1978                                               Sec. 12.4


       
           Sign of negative number
           printed as space. Accepts   6+        Prints -1004 as ^^1004
           any sign on input. Single   6D+       Prints +1004 as 001004+
           + prints + or space in
           position specified.
       
      -    For printing sign of        6-        Prints -1004 as -1004
           a negative number. Two
           or more - signs float
           to left of number.
           Accepts any sign on input.
       
           Sign of a positive number
           printed as space. Single    6-        Prints +1004 as 1004
           - prints - or space in
           position specified.
       
      U    Prints or accepts any       6U        Prints "string" as STRING
           string character and
           converts lower case to
           upper case.
       
      .    For decimal point loc-      4D.2D     Prints 1004 as 1004.00
           ation in numeric fields
           only. Prints or accepts
           decimal point.
       
      V    Indicates position of       4DV2D     Prints 1004 as 100400
           decimal point in
           format string. Decimal      4DV2D     Reads 10040 as 1004
           point is suppressed on
           output. Adds indicated
           decimal point scaling
           on input. This character
           can only be used in
           conjunction with other
           formatting characters.
       
      W    For conversion to           12W       Prints 1004 as
           binary. Supplies                      100111110
           leading zeros. Cannot
           be concatenated with
           any other formatting
           character. Number to
           be converted must be
           declared integer.
       
      X    For strings only.           6X        Prints "ABC5" as ABC5^^
           Prints or accepts any
           string character.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 155
      1 January 1978                                               Sec. 12.4


           Reads a carriage return
           from carriage return/
           line feed. Prints a
           carriage return as
           carriage return/
           line feed.
       
      Y    Prints or accepts           6Y        Prints 1004 as ^^1^^4.
           the digits 0-9 and space
           only, for either string
           or numeric fields.                    Prints string "1004" as
           On input, Y converts                  1^^4^^.
           spaces to zeros. On                   Reads "001004" from ^^1^^4
           output, Y converts
           zeros to spaces.
       
      Z    Prints or accepts a         6Z        Prints 001004 as 1004
           decimal digit and                     Reads 1004 from 001004
           replaces leading zeros
           with spaces.
       
      $    Prints or accepts           4$.$$     Prints 10.95 as ^$10.95
           digits 0-9, spaces and
           $ in numeric fields
           only. Prints or
           accepts a $ floated
           to the position
           before the first
           digit. Two or more
           consecutive $'s are
           necessary for floating
           to take place.
       
      *    Fills up spaces
           between $ and first
           digit of a number
           with *'s to act as a        $6*.DD    Prints 10.95 as $****10.95
           check protect feature.                Reads 10.95 from
           For use with digits                   $****10.95
           0-9, spaces and $
           in numeric fields only.
           Number is right justi-
           field. Two or more
           consecutive *'s are
           necessary for floating
           to take place.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 156
      1 January 1978                                               Sec. 12.4


      STRING CHARACTERS      ______ __________


      D and Y in String Fields      _ ___ _ __ ______ ______

      D and Y act similarly in string fields as they do in numeric fields,
      but cannot be combined with comma or period as they can in numeric
      fields.  Both only operate on the characters 0 through 9 and spaces.
      On output, D will print the string character 0 in place of a space,
      and Y will print a space in place of the string character 0.  On
      input, D and Y are equivalent;  spaces are converted to zeroes.
      NOTE:  Concatenation of U, X and A with any numeric field characters
      other than D and Y is not permitted.

      If D or Y is concatenated with any numeric field characters, the
      field is numeric.  Similarly, D or Y concatenated with A, U or X
      results in a string field.  If D, Y, or both are the only characters
      in a field, the field type will be taken from the variable type.
      This means that such a field can print or accept a numeric or a
      string value.

      Note the following example:

      The file FRM.STR

              5^^9
              1^^000

      is read by the following program

              >10 STRING NN,OO
              >20 OPEN "FRM.STR-A",INPUT,1
              >30 INPUT FROM 1 IN FORM "4D/4Y/":NN,OO
              >40 PRINT NN;OO
              >50 CLOSE 1
              >60 END
              >RUN
              5009^^1000
              END in line 60
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 157
      1 January 1978                                               Sec. 12.4


      NUMERIC CHARACTERS      _______ __________


      D and Y in Numeric Fields      _ ___ _ __ _______ ______

      On numeric output the characters D and Y can be used to print digits.
      D will print leading, embedded, and trailing zeroes, while Y will
      replace each leading, embedded, or trailing zero with a space.
      Examples:

              Field:        Prints:           As:

              4D              2307            2307

              4Y              2307            23^7

              3D.3D             15            015.000

              YDD.DDY           15            ^15.00^

              D.DESDD          600            6.OE+02

              Y.YESYD          600            6.^E+^2


      D and Y are equivalent when used in input fields.  Both will accept
      only digits or spaces;  spaces are converted to zeroes.  Any attempt
      to accept characters other than digits and spaces will cause an error
      condition.  For example, either 3D or 3Y will read the value 307 from
      either 307 or 3 7.  Notice that D and Y will accept neither a decimal
      point nor the sign of a number.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 158
      1 January 1978                                               Sec. 12.4


      Concatenation within Subfields      _____________ ______ _________

      These rules concern the concatenation of certain characters within
      the same subfield of a format string.  A subfield is defined as
      either that part of a field which formats a number without its
      exponent or that part of a field which formats the exponent.  The
      characters affected by these rules are:  Q, Z and the floating
      characters (i.e.  two or more):  $,*,P,S,+, and -.  These are known
      as conditional field characters.

                                     RULE 1                                     ____ _

      Two different conditional characters cannot appear in the same
      subfield.  Thus, "$$ZZ", "***$$$$" are not permitted.  The field
      "QQQESSS" is permitted because the Q's are in one subfield and the
      S's another.

      NOTE:  One exception to this rule is that Q's and Z'S can be used in
      the decimal part of a field.  Example:

              >10 PIF "+++++.QQQ":47.5,47.00
              >RUN
                +47.5  +47.

                                     RULE 2                                     ____ _

      The conditional field characters can be used before but not after D
      or Y in a subfield.  Thus, "$$$DDDD", "+++++YD", "SSS.DD" are
      permitted, but "DDDD$$$", "YD+++++" and "DD.SSS" are not permitted.

                                     RULE 3                                     ____ _

      If conditional field characters other than Q or Z are used to print
      the decimal part of a number, the result will be the same as if D's
      had been used instead.  For example, the following pairs of fields
      are equivalent:

                  Field:               Is Same As:

                  $$$$.$$                $$$$.DD

                  SSSVSSS                SSSVDDD

                  $---.--                 $---.DD

                  ZZ.ZESQQ               ZZ.ZESQQ

                  PPP.PPP                PPP.DDP
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 159
      1 January 1978                                               Sec. 12.4


                                     RULE 4                                     ____ _

      When the comma is used with conditional field characters, a comma
      will print only if a digit of the number being printed appears to the
      left of the comma.  Otherwise, the comma prints the same character as
      generated by the conditional character field in which the comma
      appears.  When the comma is used with D a comma prints
      unconditionally.  For example,

              Field:                Prints:                 As:

              ***,***.DD           1203.6               **1,203.60

                                   32.61                *****32.61

              $$,$$$               2341.7               $2,342

                                   -28                  ^^^$28

              SQ,3Q,3Q.3D          24369.6              +24,369.600

                                   -315.01              -315.010

              Z,ZZZ                1200                 1,200

                                   39                   ^^^39

              -DD,DDD.DD           -1337.4              -01,337.40

                                   16.25                ^00,016.25

              Y,YYY                3297                 3,297

                                   8                    ^^^^8
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 160
      1 January 1978                                               Sec. 12.4


      Hex, Octal, and Binary Conversion:  H, O, and W      ____ ______ ___ ______ ___________  __ __ ___ _

      The H, O and W characters specify the conversion between integer
      numeric values and hexadecimal, octal or binary strings,
      respectively.  The H, O and W conversion characters cannot be
      concatenated with other formatting characters.  They can, however, be
      used with the utility characters.  For example:

              >10 INTEGER A
              >20 A=4798
              >30 PIF "6H 3B 8O 3B 12W":A,A,A
              >RUN
              0012BE   00011276   001010111110


                                     CAUTION

                     If the format string has less
                     characters than the converted output
                     value, the number actually printed is a
                     truncated, right justified version of
                     the correct number having the exact
                     number of characters specified in the
                     format string.  With "3H" the string
                     printed for the value 4798 is 2BE.  No
                     error condition occurs.



      Also, H, O, and W, when used in input formats, allow the conversion
      of hex, octal or binary input strings into numeric values.  As with
      output formats, the input values must be read into variables
      previously declared as integer.  For example:

              >10 INTEGER X,Y,Z
              >20 IIF "3H 4O 5W":X,Y,Z
              >30 PRINT X,Y,Z
              >RUN
              ABC
              1234
              11111
               2748           668            31
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 161
      1 January 1978                                               Sec. 12.4


      FLOATING CHARACTERS      ________ __________


      Floating and Static $      ________ ___ ______ _

      The use of the $ as a floating character (by including two or more
      $'s in the same field) prints or accepts a $ immediately preceding a
      number.  Example:

              >10 PIF "$$$.$$ bbb $$$.$$ bbb $$$$":2.045,.7,300
              >RUN
              ^$2.05^^^^^$.70^^^$300

      On output, the $ always floats to the position before the first
      non-space output character.  If the $ field is made too short and
      does not allow for the floating $, an error condition results.  Thus,
      23.06 cannot be printed with the format "$$.$$".  If the $ field is
      longer than the output value requires, the $ is preceeded by spaces.

      On input, a $ will accept a space or $ before a number.

      Static use of the $ occurs when a single $ is simply to be printed in
      the position specified, as in the following example:

              >10 PIF "$6*.DD":24.95
              >RUN
              $****24.95

      A static * may not appear within a subfield.

      Floating and Static *      ________ ___ ______ _

      The floating * field prints or accepts leading *'s in place of spaces
      as protection of dollar amounts on checks.  For example:

              >10 PIF "4* BBB **.** BBB 3*.**":23,8.625,3.2
              >RUN
              **23^^^*8.63^^^**3.20

      Behavior of * is analagous to $ except that all leading spaces are                                                  ___
      replaced by * instead of only the space immediately preceeding the
      number.

      The static use of * occurs when a single * is specified.  In this
      case the * is simply printed in the position specified, as in the
      following example:

              >10 PIF "*3$.DD":44.95
              >RUN
              *$44.95
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 162
      1 January 1978                                               Sec. 12.4


      Floating and Static P      ________ ___ ______ _

      The floating P field prints or accepts a left parenthesis floated to
      the left of a negative number, preceeded by spaces if an excess of
      P's is given.  P will print or accept a space for positive numbers.
      The exponent subfield may also be parenthesized.  A static P must
      always appear for the right parenthesis.  TYMBASIC will interpret the
      rightmost P in a subfield as a static P if necessary.  Examples:

           Field:      Interpreted As:    Prints:     As:

           6P          5PP                -123        ^(123)
                                           123        ^^123^

           4P.3P       4P.2DP             -12.3       ^(12.30)
                                           12.3       ^^12.30^

      Static use of P causes a right or left parenthesis (depending on
      whether it precedes or follows the number) to be printed or accepted
      for negative numbers.  For positive numbers, static P prints or
      accepts a space.  Parentheses must always be balanced.  For example:

           Field:          Prints:         As:

           P3Z.3QP         -49.2           (^49.2)
                            49.2           ^^49.2^

           Z.DDEPDDP       .492            4.92E(01)

      In order to balance parentheses, it is often necessary to combine
      floating and static P in the same field.  Examples:

           Field:          Prints:         As:

           6P.2DP          -49.2           ^^^(49.20)

           2P.3DES2QP      -49.2           (4.920E+1)

           4P.2P2QP        -117.36         (117.36)
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 163
      1 January 1978                                               Sec. 12.4


      Floating and Static Sign Characters      ________ ___ ______ ____ __________

      The format characters S, + and - will float to the left of the number
      printed if two or more are specified, as shown in the following
      table:

        More    Floats:                         Example
        than                                     Field:  Prints:  As:
        one:
         

        S               Sign                       3S       6      +6

        +               + if positive number.      3+       6      +6

                        Space if negative                  -6      ^6

        -               - If negative number.      3-      -6      -6

                        Space if positive                   6      ^6

      The single (i.e.  static) occurrence of any of these characters
      causes it to be printed in the position specified, instead of
      floating.  For example:

          Static  Prints                        Example
                                              Field:  Prints:    As:

          S       Sign                        ZZS      -6      ^6-

          +       + if positive number.       +DDD    -102     ^102
                  Space if negative           DDD+     102     102+

          -       - if negative number.       -YYY    -102     -1 2
                  Space if positive           -DD-    -77      -77-

      Note that more than one static occurrence of S, +, or - in a single
      subfield is permitted.  For example,

              >10 PIF "*$QQQQS*":-15
              >RUN
              *$15-*

              >10 PIF "SDD.D-+/":-72.8,12.3
              >RUN
              -72.8-^
              +12.3^+

      The sign of an exponent subfield can be printed only in front of the
      exponent.  After the exponent, a static occurrence of S, +, or - will
      print the sign of the mantissa.  For example,

              >10 PIF "SDDESDD-+/":1234,-5678
              >RUN
              +12E+02^+
              -57E+02-^
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 164
      1 January 1978                                               Sec. 12.4


      UTILITY CHARACTERS      _______ __________

      The utility characters do not transmit or convert data values, but
      are used to transmit special characters or to affect the format
      itself.  Those that do not separate or create fields may be used
      anywhere within a subfield.


                               UTILITY CHARACTERS

           Character                    Function
           ----------------------------------------------------------------

           Space                        Acts as field separator.

           B                            Prints a space on output.
                                        Skips a character on input.

           "text" or                    Prints the enclosed literal text
           'text'                       on output; on input, skips as
                                        many characters as are enclosed.
                                        Quote marks follow same rules as
                                        for string expressions.

           ,                            Prints a comma on output;
                                        skips a character on input.
                                        For use in numeric fields only.

           /                            Prints an EOR on output; seeks
                                        an EOR on input; acts as field
                                        separator.

           \                            Prints a line feed on output;
                                        skips a character on input.

           n( )                         Causes the enclosed field to be
                                        replicated n times,
                                        creating n fields.

           n[ ]                         Causes enclosed characters to be
                                        replicated n times.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 165
      1 January 1978                                               Sec. 12.4


      REPLICATION      ___________

      Format characters and fields can be repeated by the use of numeric
      multipliers.  (Replication is available only with FORM formats.)
      Three types of replication are allowed:

           1.  Direct use of multipliers with single format characters, as
               shown in the following examples:


                       The Format:            May Be Expressed As:

                       %%%                    3%

                       %%%%.%%                4%.2%

                       #######                7#

                       ##.#####                2#.5#

                       %%BBBB%%.%             2%4B2%.%

                       **********.**          10*.2*



           2.  Replication of groups of format characters by use of a
               multiplier with square brackets enclosing the affected
               characters.  Examples:


                       The Format:              May Be Expressed as:

                       HBHBHBHBHBHB              6[HB]

                       $Z,ZZZ,ZZZ                $Z2[,3Z]

                       DHDH 3WB3WB               2[DH] 2[3WB]

                       XAXA                      2[XA]


               Up to four levels of nesting within brackets are allowed.
               The format

                    10 K$ = "2[2[YD]B]"

               is equivalent to the format:

                    10 K$ = "YDYDBYDYDB"
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 166
      1 January 1978                                               Sec. 12.4


               A minus sign in a format field is interpreted as the static
               minus sign formatting character and does not apply to the
               replication count.  Thus the string "-2[DB] 3D/" is
               interpreted as "-DBDB 3D/".

               A replication count of zero is legal.

               The characters E, K, V and the period (.) cannot be
               replicated.

           3.  Replication of fields, by use of a multiplier with
               parentheses enclosing the affected fields.  Examples:


                       The Format:             May Be Expressed As:

                       DD   DD   DD               3(DD)

                       3Z B 3Z B 3Z B             3(3Z B)

                       3%.3% 4B 3%.3% 4B          2(3%.3% 4B)

               Parentheses may be nested up to four levels.

               Fields to be replicated must be set off by field separators,
               such as spaces.  For example "DBD2(BY)" is illegal, and
               should be expressed as "DBD 2(BY)".

      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 167
      1 January 1978                                               Sec. 12.4


      FORM INPUT      ____ _____


      Literal Text in Input Format String      _______ ____ __ _____ ______ ______

      Literal text encountered in a FORM input format causes a
      corresponding number of input characters to be skipped.  The literal
      text itself is not printed.  Thus, if the input format "'A='3D" is
      used to read the input A=666, the value accepted is 666.  If this
      same form is used for output, the characters A= would be printed.
      This allows the same format to be used for both input and output.
      Note the following example of terminal input and output:

              >10 IIF "'A='#'B='#":A,B
              >20 PIF "'A='#'B='#":A,B
              >RUN
              XX9876,^^^1234      [any two characters or spaces
              A= 9876B= 1234          could be entered before value]


      EOR in an Input Format      ___ __ __ _____ ______

      When a / symbol is used to designate an EOR in an input FORM,
      TYMBASIC will seek an EOR when the / is encountered.  All input
      characters up to the next EOR are ignored.



      End of FORM and FORM Rescan      ___ __ ____ ___ ____ ______

      The end of a format string does not cause TYMBASIC to seek an EOR.
      If an input format contains fewer fields than the number of variables
      listed in the INPUT statement, the format will be re-scanned from the
      beginning until all variables have been given values.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 168
      1 January 1978                                               Sec. 12.4


      FORM OUTPUT      ____ ______


      Literal Text in Output Format String      _______ ____ __ ______ ______ ______

      Any literal text in a FORM output format is printed up to the next
      output field in the FORM, or to the end of the FORM format.


      EOR in an Output Format      ___ __ __ ______ ______

      A slash (/) is used in a format to generate an EOR.  Consecutive
      slashes may be used to generate blank lines or records.


      End of FORM and FORM Rescan      ___ __ ____ ___ ____ ______

      The end of an output format string does not cause TYMBASIC to
      generate an EOR.  If a FORM format contains fewer fields than the
      number of expressions in the PRINT statement, the format will be
      re-scanned from the beginning until all expressions have been
      printed.
      TYMBASIC REFERENCE MANUAL             FORMATTING             Page 169
      1 January 1978                                               Sec. 12.4


      TREATMENT OF EOR'S      _________ __ _____

      Carriage return and line feed in a file are stored as two characters
      but are treated by formatting characters as a single EOR character.
      Thus, the format "7X" in the following program causes the reading in
      of six characters plus a CR/LF treated as a single carriage return
      character.  After the execution of line 40, the value of LOC(1) in
      line 50 is 9 (i.e.  the character G), indicating that the EOR stored
      after the character D is treated in the file as two characters.  The
      file FILIN.x containing the characters

              ABCD(CR)(LF)
              EFGHIJ(CR)(LF)

      is read by the program F.DAT as follows:

              >GET F.DAT-A
              >LIST
              10 STRING A
              20 OPEN "FILIN.x-A", RANDOM INPUT , 1
              30 PRINT LOC(1)
              40 INPUT FROM 1 IN FORM "7X":A
              50 PRINT LOC(1)
              60 PRINT "A=":A
              70 CLOSE 1
              80 END

              >RUN
               1
               9
              A=ABCD
              EF

              END in line 80
      TYMBASIC REFERENCE MANUAL        TYMBASIC KEYWORDS           Page 170
      1 January 1978                                               App. A


                         APPENDIX A.   TYMBASIC KEYWORDS

      The following keywords are reserved in TYMBASIC, and cannot be used
      as user-defined identifiers.

      ABS          DET          IIM          OPEN         SIMPL
      ACOS         DIM          IMAG         OR           SIN
      ADD          DIV          IMAGE        ORIF         SINH
      AKA          DLIST        IMP          OUTPUT       SIZE
      ALL          DO           IN           PAUSE        SPACE
      AND          DOUBLE       INC          PDIF         SQR
      ARSH         DPI          INDEX        PHASE        SQRT
      AS           DUMP         INIT         PI           START
      ASC          ECHO         INITIALIZE   PIF          STARTPOINT
      ASCTABLE     EDIT         INPUT        PIM          STEP
      ASIN         EIGHTI       INT          PMC          STOP
      AT           EIGHTO       INTEGER      POLAR        STR
      ATAN         ELSE         INV          POS          STRING
      ATN          ENCODE       IO           PRINT        SUB
      BAN          END          IP           PROD         SUBSTR
      BASE         ENDF         IXASC        PROTECTION   SUM
      BEX          ENDFILE      IXCHAR       PWR          SYMBOLIC
      BINARY       ENDIF        LEFT         QUIT         SYMD
      BLISS        ENTER        LENGTH       RANDIN       TAB
      BOR          ENTRY        LET          RANDIO       TABS
      BOUNDARY     EPS          LGT          RANDOM       TAN
      BREAK        EQV          LIBRARIES    RANDOUT      TANH
      BY           ERASE        LIBRARY      RCY          TBA
      CALL         ERR          LIST         READ         TCP
      CDE          ERRCD        LJUST        REAL         TERM
      CFO          ERRFL        LOC          REFS         TEXT
      CHAR         ERRLN        LOCATE       REL          THEN
      CHARTABLE    ERRMSG       LOG          REM          TIME
      CIB          ERROR        LOG10        REMARK       TO
      CLOSE        ESCAPE       LOGICAL      REMOVE       TOF
      CMPLX        EXIT         LOL          REN          TOUT
                   EXP          LOS          RENAME       TRACE
      COMP         EXTERNAL     LPAD         RENUMBER     TRANSFORM
      COMPLEX      F40          LSH          RESTORE      TRN
      CON          FALSE        MAP          RESUME       TRU
      CONJ         FILE         MAT          RETURN       TRUE
      COPY         FIX          MATH         RIGHT        UNLESS
      COS          FOR          MAX          RJUST        UNTIL
      COSH         FORM         MERGE        RND          VAL
      COUNT        FP           MIN          ROUN         VERSION
      DATA         FROM         MOD          ROUND        WAIT
      DATAEND      GET          MODIFY       RPAD         WHERE
      DATE         GO           MODULE       RPT          WHILE
      DBL          GOSUB        MODULES      RSH          WITH
      DEBUG        GOTO         MUL          RUN          WRITE
      DECODE       IDN          NAME         SAVE         XASC
      DEF          IF           NEXT         SEQUENTIAL   XCHAR
      DEFINE       IIF          NO           SFO          XOR
      DEL                       NOT          SGN          YEAR
      DELETE                    ON           SIGNIFICANCE ZER
      TYMBASIC REFERENCE MANUAL        RUN-PHASE ERROR MESSAGES    Page 171
      1 January 1978                                               App. B


                     APPENDIX  B.  RUN-PHASE ERROR MESSAGES
      
      ERRCD        ERRMSG(ERRCD)
      -----        -------------
      
        1  Expression out of bounds in ON expression GO TO or GO SUB statement
        2  Negative number used in BOUNDARY statement
        3  Negative number used in SIGNIFICANCE statement
        4  String too long
        5  Argument to CHAR must be greater than or equal to 0 and less than 128
        6  Array subscript out of bounds
        7  Vector sizes do not conform in vector product
        8  Matrix not in proper form in vector-matrix product
        9  Vector and matrix not size conformal in vector-matrix product
       10  Matrix not in proper form for matrix-vector product
       11  Vector and matrix not size conformal in matrix-vector product
       12  Matrices not conformal in matrix product
       13  Attempt to multiply or transpose matrices of more than 2 dimensions
       14  Arrays do not have the same number of dimensions
       15  Arrays do not have same number of elements in corresponding dimensions
       16  Type of base array less than type of power array
       17  Matrix is not square
       18  Operation is not defined on given types
       19  Subarray subscript out of bounds
       20  Power less than zero in matrix exponentiation
       21  Reference to undeclared array
       22  Type conversion for string arrays not defined
       23  Attempt to invert a singular matrix
       24  Subarrays do not share a common ancestor in @ operation
       25  Subarrays share no common elements in @ operation
       26  Attempt to take LOG of negative argument
       27  Attempt to take SQRT of negative argument
       28  Operand types incompatible
       29  Overflow in SINH function
       30  Overflow in COSH function
       31  Underflow in two argument ATAN function
       32  Magnitude of argument to ASIN function greater than 1
       33  Attempt to take LOG of zero
       34  Attempt to take LOG10 of a complex argument
       35  Error in EXP for complex argument
       36  Overflow in ** operation
       37  Underflow in ** operation
       38  Overflow in (complex)**(integer) operation
       39  Underflow in (complex)**(integer) operation
       40  Radius less than or equal to zero in POLAR function
       41  Overflow in complex multiplication
       42  Underflow in complex multiplication
       43  Underflow in complex division
       44  Relational operation not defined on given numeric types
       45  Overflow in TAN routine
       46  Integer overflow
      TYMBASIC REFERENCE MANUAL        RUN-PHASE ERROR MESSAGES    Page 172
      1 January 1978                                               App. B


       47  Integer divide check
       48  Illegal error trap
       49  Floating overflow
       50  Floating divide check
       51  Floating underflow
       52  Run time initialization error
       53  Maximum number of input streams exceeded
       54  Open not confirmed on file
       55  Cannot find file
       56  File already exists
       57  No free I/O channel for file
       58  User name too long
       59  Illegal file name
       60  Cannot find file
       61  User name does not exist
       62  Protection failure on file
       63  File is being modified
       64  Cannot rename file. (File already exists)
       65  Compiler error during operation on file directory
       66  Data error during operation on file directory
       67  Monitor error during operation on file directory
       68  Monitor error during operation on file directory
       69  Monitor error during operation on file directory
       70  Monitor error during operation on file directory
       71  Monitor error during operation on file directory
       72  Disk storage quota exceeded. Cannot open file
       73  Cannot write in directory
       74  Monitor error during operation on file directory
       75  Monitor error during operation on file directory
       76  Monitor error during operation on file directory
       77  Monitor error during operation on file directory
       78  Monitor error during operation on file directory
       79  Monitor error during operation on file directory
       80  Monitor error during operation on file directory
       81  Monitor error during operation on file directory
       82  Cannot create file in directory
       83  Monitor error during operation on file directory
       84  File number must be an integer between 1 and 20 inclusive
       85  Same file number may not be used for two files
       86  Illegal protection code
       87  Three (3) protection codes required
       88  GO SUB stack overflow
       89  GO SUB stack underflow
       90  Record length must be greater than zero
       91  Invalid option combination:
       92  TERMINAL may not be specified twice
       93  TERMINAL may not be specified
       94  File must be random
       95  File must be open for output or input-output
       96  Record number must be an integer greater than 0
       97  Last record number must not be less than the first
      TYMBASIC REFERENCE MANUAL        RUN-PHASE ERROR MESSAGES    Page 173
      1 January 1978                                               App. B


       98  File must be open
       99  Error number must be an integer between 1 and n inclusive
      100  File number must be an integer between -9 and 20 inclusive
      101  File number must be 0 for TERMINAL BINARY input output
      102  Illegal character in form field
      103  Too many nested parentheses
      104  Unmatched ')'
      105  Unmatched '('
      106  Number precedes ')' ']' or space
      107  Unmatched string delimiter
      108  Use of numeric format with string variable is illegal
      109  Invalid R form
      110  Number precedes decimal point
      111  Attempt to overflow fixed length record on random file
      112  Invalid input or format in VAL function
      113  Vacuous format
      114  Ambiguous dot
      115  Two decimal points in numeric field
      116  Unmatched ']'
      117  Unmatched '['
      118  Too many nested brackets
      119  Number precedes exponent indicator
      120  Illegal character in integer conversion field
      121  Illegal character in special string field
      122  Invalid integer part in special form
      123  Invalid fractional part in special form
      124  Invalid exponential part in special form
      125  Invalid special form field
      126  Invalid use of P in special form
      127  Output field descriptor is too small
      128  Number too large for type conversion indicated in format
      129  Number too small for type conversion indicated in format
      130  Illegal character for numeric conversion
      131  Illegal character in alpha formatted field
      132  Illegal character in numeric formatted field
      133  Illegal character in alpha or numeric formatted field
      134  Use of R form with numeric variable is illegal
      135  Illegal character in special radix field
      136  Expecting formatted input
      137  Normal terminal input not allowed during Eight-level input
      138  Use of string format with a numeric variable is illegal
      139  Field is valid for output only
      140  Special radix must be used with an integer or logical variable
      141  Complex argument to STR function is illegal
      142  End of file found
      143  READ statement out of DATA
      144  File must be open
      145  File must be open for OUTPUT or IO
      146  File must be open for INPUT
      147  Format specified with binary file
      148  'AT' construct not valid with sequential file
      TYMBASIC REFERENCE MANUAL        RUN-PHASE ERROR MESSAGES    Page 174
      1 January 1978                                               App. B


      149  File number must be an integer between 1 and 20 inclusive
      150  Free-form I/O to fixed record length random file is illegal
      151  Compiler bug: Trace UUO trapped but no trace routine loaded
      152  RESUME statement before trap condition exists
      153   is unimplemented
      154  Dynamic Storage Area Clobbered by Re-Load
      155  Interrupted
      156  Cannot create .SHR file
      157  Cannot create program load map
      158  Upper bound must be greater than or equal to lower bound
      159  Data area may not be expanded beyond 131,072 words
      160  Request for more core refused by Monitor
      161  Attempt to redimension a subarray
      162  File number 0 may be used only for eight-level input
      163  Error encountered during SORT
      164  Illegal sequence of string-field characters

      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 175
      1 January 1978                                               App. C


                          APPENDIX C. INTRALINE EDITING



      Line editing in the Tymbasic systems follows the standards set forth
      in "Tymshare Intraline Editing" (TIE) of 26 November 1975.  The
      following is taken from that paper.


      Intraline editing is the process of manipulating symbolic text, one
      line at a time.  The line may be simply a modification of another
      line (called the "old line") or it may be a new line in its own
      right.  QED-like intraline editing, the basis for TIE, refers to a
      method of intraline editing using control characters.

      The behavior of intraline editing in the Tymshare Editor on the
      XDS-940 is the foundation for the behavior called for in TIE.  Thus,
      a person having experience with the 940 Editor or its cousin on the
      PDP-10 will immediately understand the TIE functions.

      TIE is based in part on the 940 Editor concept of boundaries for
      backwards deletions.  That is, one can not 'backspace' past the
      beginning of an ongoing Text Insertion.  One must complete the
      insertion before deleting characters which occur before the
      insertion.  (This is not so on the PDP-10 Editor.)

      A point of departure from the 940 Editor foundation is that Tymshare
      Intraline Editing follows the PDP-10 Editor convention of displaying
      between backslashes those characters which are backspaced over.
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 176
      1 January 1978                                               App. C


                          SUMMARY OF CONTROL CHARACTER OPERATIONS


      Control A

         Backspaces in the new line and in the old line as appropriate.  It
         is an "un-do" operation.  Rings Bel if there are no characters
         left to delete in the new line or the current insertion.

      Control B

         In the Run phase, restarts the current Input statement, in the
         Command/Statement phase rings Bel.

      Control C

         Copies and prints the next character from the old line to the new
         line.  If there are no more characters to copy, rings Bel.

      Control D

         Copies and prints the rest of the characters from the old line, if
         any, to the new line, prints a Carriage Return and Line Feed, and
         terminates the line.

      Control E

         Starts a Text Insertion or completes one in progress, printing "<"
         or ">".

      Control F

         Copies (without printing) the rest of the characters from the old
         line, if any, to the new line, prints a Carriage Return and Line
         Feed, and terminates the line.

      Control G

         In the Run phase, acts as an activation character on input, like a
         carriage return.  In the Command/Statement phase rings Bel.

      Control H

         Same as Control A.

      Control I

         Enters enough spaces into the new line to reach the next tabstop
         or one space if no tabstops are defined beyond the current
         position.

      Control J    (Line Feed)

         Same as carriage return, except that on the next input the old
         line image will be the remainder of the current old line image.
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 177
      1 January 1978                                               App. C


      Control K

         Deletes and prints the next character in the old line, if any;
         otherwise, rings Bel.

      Control L

         Copies but does not print the rest of the characters from the old
         line, if any, to the new line and then prints a plus sign.  Rings
         Bel if there are no more characters to copy.

      Control M    (Carriage Return)

         Prints a Carriage Return and Line Feed and terminates the line.

      Control N

         Copies and prints the rest of the characters from the old line to
         the new line, if any;  otherwise, rings Bel.  It does not
         terminate the line;  thus, editing may continue at the end of the
         line.

      Control O

         Copies and prints characters from the old line to the new line up
         to but not including the next character typed.  Searches for the
         character from two characters beyond the current old line pointer.
         Rings Bel if not found.

      Control P

         Deletes and prints "%" for each character in the old line up to
         but not including the next character typed.  Searches for the
         character from two characters beyond the current old line pointer.
         Rings Bel if not found.

      Control Q

         If typed at the beginning of the line is a request to back up a
         line in an insert or append.  Otherwise, deletes characters
         backwards up to the beginning of the new line or the beginning of
         an ongoing insertion and prints "^".  If no insertion was in
         progress, also prints a Carriage Return.  Backspaces in the old
         line as appropriate.  Rings Bel if there are no characters to
         delete.

      Control R

         Prints the remainder of the old line and then the prompt and the
         contents of the new line on the next line, lining up the beginning
         of the remainder of the old line with the end of the new line.
         Never prints a line of just spaces.
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 178
      1 January 1978                                               App. C


      Control S

         Deletes the next character in the old line if any and prints "%".
         Otherwise, rings Bel.

      Control T

         Not implemented.

      Control U

         Copies characters from the old line if any, or enters spaces, into
         the new line until the next tabstop is reached.

      Control V

         In the Run phase, enters a control character (including Carriage
         Return or Line Feed) into the new line.  If an alphabetic
         character is typed, enters its opposite case.  In the
         Command/Statement phase rings Bel.

      Control W

         Backspaces past spaces, then past all characters up to a space or
         to the beginning of the line or ongoing insertion.  Rings Bel if
         there are no more characters left to backspace over.  Backspaces
         in the old line as appropriate.

      Control X

         Deletes and prints "%" for each character in the old line up to
         and including the next character typed.  Searches for the
         character from one character beyond the current old line position.
         Rings Bel if not found.

      Control Y

         Replaces the old line image with the contents of the new line,
         prints a prompt and continues the edit at the beginning of the new
         line.

      Control Z

         Copies and prints characters from the old line to the new line up
         to and including the next character typed.  Searches for the
         character from one character beyond the current old line position.
         Rings Bel if not found.
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 179
      1 January 1978                                               App. C


                                  COORDINATED BACKSPACING



      Coordinated Backspacing means that the cursor in the old line is kept
      synchronized to the movements of the new line cursor.  That is, after
      backspacing to a certain point in the new line the cursor in the old
      line will be at the same position as it was when the new line cursor
      was last at its current position.  Coordinated backspacing applies to
      Control-A, Control-H, Control-W, and Control-Q.

      Each character in the new line may or may not be associated with a
      character in the old line.  If a new line character was part of an
      insertion or if it was entered at a time when there were no more
      characters in the old line, it is not paired with an old line
      character.  Otherwise, it is.  Likewise, a character in the old line
      may be associated with a new line character.  If an old line
      character was deleted by Control-S, -K, -P or -X, then it has no
      association with a new line character.  Otherwise, any character
      behind the old line cursor is paired with a new line character.

      In backspacing over a character in the new line, the old line cursor
      is backed up until it backspaces over the corresponding character in
      the old line, if there is such an association.  Otherwise, the old
      line cursor is not changed.  Thus, coordinated backspacing "erases"
      the previous copies, replacements, or insertions.


      Example:


      >30E
      30 print a(old) for old = 1 to 5
      Oo30 print a(nwA\w\ewD for old = 1 to 5
      >LIST 30
      30 print a(new) for old = 1 to 5
      >
      

      The Control A removed the "w" from the new line and also backspaced
      past the "l" in the old line so that the Control D functions
      properly.
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 180
      1 January 1978                                               App. C


      To illustrate further, a more complicated example:


      >30E
      30 a = old.line
      Oo30 a = E<third.N>old.lineW\enil.dlo.drihtE\<second.D>old.line
      >LIST 30
      30 a = second.old.line
      >

      In this example, the user inserts "third." in front of "old.line",
      copies to the end of the old line and then decides to change "third."
      to "second.".  He backspaces past the identifier "third.old.line" and
      then inserts "second." and copies again to the end of the old line.
      Note that backspacing over "third." did not cause any backspacing in
      the old line;  after backspacing over "third." the user was left in
      the same position he was in before typing "third." originally.  Thus,
      when he copied to the end of the old line after inserting "second.",
      the first characters to be copied were "old".
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 181
      1 January 1978                                               App. C


                      DIFFERENCES FROM THE BEHAVIOR OF THE 940 EDITOR


      Carriage Return is not, as in the 940 Editor, the last character of
      each line.  A line is defined by its length, not an internal
      delimiter.  Thus, the operation of a control character never ends a
      line by copying through the end of the old line.  The following
      control characters had this 'copy line end' property on the 940
      Editor:

           C, U, and Z.

      They do not have this property in Tymshare Intraline Editing.

      The ability to mention the end of the line by reference to Carriage
      Return is not supported, as there is no Carriage Return to reference
      (example:  Control-O Control-M;  copy up to end of line).

      Other differences:

           1.  Control-T is not implemented;  Control-R is to be used
               instead.

           2.  Any behavior which was deemed to be a bug was fixed for the
               Tymshare Intraline Editor.

           3.  Control-J no longer enters a Line Feed into a line.  It is
               now a "line-split" character.

           4.  Control-U copies either characters from the old line image,
               or spaces, to the new line, up to the next tabstop.  In
               other words, the behavior of Control-U converges with that
               of Control-I.  The 940 Editor behavior of copying line end
               is, of course, not TIE behavior.  Also, on the 940,
               Control-U is a No-op if there are no characters to copy.
               TIE Control-U is never a No-op (nor a BEL) in the normal
               case (no Line Overflow).  If there are no more (expicitly
               defined) tabstops, the next tabstop is defined as the next
               column, as in the 940 Editor.

           5.  Control-R never completes a Text Insertion.  Instead, a ''
               is printed at the correct spot in the new line to mark the
               beginning of the insertion.

           6.  Control-R never prints a line of only spaces (this
               frequently occurs during processing of long lines).

           7.  Control-N now has the function Control-H had on the 940.
               Control-H is a backspace character and is identical to
               Control-A.

           8.  Control-Y no longer copied the remainder of the old line.

      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 182
      1 January 1978                                               App. C


                                       BEL AND NO-OP


      BEL (Control-G) is sent to the Physical Terminal when an operation is
      requested that can not be fulfilled (operation is here defined as any
      logical function except the simple typing in of a text character).
      Request for an operation that would cause Line Overflow produces a
      BEL response.  Any operation which produced BEL is a No-op;  i.e.,
      the state of editing is precisely the same as if no operation had
      been requested.  Conversely, any operation which is a No-op always
      produces a BEL response.  The following requests produce a BEL
      response according to the accompanying conditions:

           Any operation which, if performed, would cause Line Overflow.

           Or any of the following:

                Control-A:  backwards deletion boundary is met.
                Control-B:  if unimplemented.
                Control-C:  no characters to copy.
                Control-D:  never.
                Control-E:  never.
                Control-F:  never.
                Control-G:  always.
                Control-H:  backwards deletion boundary is met.
                Control-I:  never.
                Control-J:  never.
                Control-K:  no characters to delete.
                Control-L:  no characters to copy.
                Control-M:  never.
                Control-N:  no characters to copy.
                Control-O:  specified character not found in rest of old
                            line image.
                Control-P:  specified character not found in rest of old
                            line image.
                Control-Q:  backwards deletion boundary is met.
                Control-R:  never.
                Control-S:  no characters to delete.
                Control-T:  always.
                Control-U:  never.
                Control-V:  if unimplemented.
                Control-W:  backwards deletion boundary is met.
                Control-X:  specified character not found in rest of old
                            line image.
                Control-Y:  never.
                Control-Z:  specified character not found in rest of old
                            line image.
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 183
      1 January 1978                                               App. C


                                      TEXT INSERTIONS


      Text Insertions, started and completed by typing Control-E, are
      characterized by the property that the characters inserted are not
      considered to have counterparts in the old line (the 940 Editor is
      the basis for this definition).

      This property has the following corollaries:

      1.  Inserting characters into the new line does not advance the old
          line cursor.

      2.  Backspacing within an insertion, even with Control-A or
          Control-Q, does not decrement the old line cursor.

      3.  Any operation which forces the forward movement of the old line
          cursor (such as Control-C or Control-X) first completes the
          insertion.

      4.  Any operation which terminates a line completes the insertion.
          The ending '>' is always output, except after Carriage Return,
          Line Feed, and Line Overflow.


      Text Insertions are completed by the following operations:


      1.  Any operation terminating a line, including Line Overflow.
      2.  Control-C if successful (i.e., there is no BEL response).
      3.  Control-D always.
      4.  Control-E always.
      5.  Control-F always.
      6.  Control-J always ( '>' not printed).
      7.  Control-K if successful.
      8.  Control-L if successful.
      9.  Control-M always ( '>' not printed).
      10. Control-N if successful.
      11. Control-O if successful.
      12. Control-P if successful
      13. Control-S if successful.
      14. Control-U always.
      15. Control-X if successful.
      16. Control-Y always.
      17. Control-Z if successful.


      A deletion within a text insertion always has a backwards boundary at
      the point of the beginning of the insertion.  Attempts to backspace
      beyond the beginning of an insertion (using Control-A, -H, -W, or -Q)
      always invoke a BEL response.
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 184
      1 January 1978                                               App. C


                                    BACKWARDS DELETIONS

      Backwards Deletion characters:  Control-A, Control-H, Control-W,
      Control-Q.

      Backwards Deletions, whose printed output is delimited by a pair of
      backslashes, are characterized by backspacing either the cursor in
      the new line image, or both cursors in new and old images.
      Control-A, Control-H, Control-Q, and Control-W may backspace in the
      old image as well as the new unless a Text Insertion is in progress.

      The completion of a Backwards Deletion is signalled by the printing
      of a closing backslash.

      Backwards Deletions follow these conventions:


      1.  Backwards Deletions within a Text Insertion are always bounded by
          the beginning of that Insertion or the beginning of the new line
          image, whichever comes first as the deletion proceeds.

      2.  Old line cursor is not changed by the operation of any Backwards
          Deletion control characters (or any other operator) during Text
          Insertions.

      3.  Backwards Deletions are always completed by any successful
          non-deletion operation.

      4.  The only addition to 3 is that Backwards Deletions are completed
          when, in the process of deletion, a backwards boundary is met
          (the beginning of the line or the start of a Text Insertion).



                                       LINE OVERFLOW

      Line Overflow is the condition created when type-in of a text
      character attempts to place more than 256 characters in the new line
      image buffer.

      Line Overflow behavior is as defined in the Tymshare Editor Manual
      except for the following convention:

      If overflow would be caused by the operation of a control character,
      then that operation is then re-interpreted as a No-op, and invokes a
      BEL response.




      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 185
      1 January 1978                                               App. C


                                         PROMPTING




      The Tymshare Intraline Editor prompts to the Physical Terminal under
      the following circumstances:



              1.  At the beginning of new line entry.


              2.  During the operation of Control-R and Control-Y.




                                      LINE TERMINATION




      Line Termination is caused by any of the following control
      characters:  Control-D, Control-F, Control-J(Line Feed), Control-H
      (carraiage return).  Line overflow caused by type-in of a text
      character also causes line termination.

      Line Termination does NOT occur, as it may on the 940 Editor, after
      the following control characters:

           Control-C
           Control-U
           Control-Z




                             Influence on Intraline Editing of
                       Presence of Control Characters in Line Images



      If control characters and the character DEL are allowed in TIE line
      images then the following type-out rules apply within TIE:


          All control characters print as     "&" followed by their
                                            alphabetic interpretation

          DEL     prints as               DEL
      TYMBASIC REFERENCE MANUAL        INTRALINE EDITING           Page 186
      1 January 1978                                               App. C


      Control-R will assume that DEL has no effect on the print position at
      the device.

      The computation of print position employed by Control-I and Control-U
      to determine the next tabstop follows this set of target type-out
      rules:



          Carriage Return would print as Carriage Return  Line Feed


          Control-H                   as a backspace
          Control-I                   as spaces to the next tabstop

          All other control characters and DEL would have no effect on
          print position

      TYMBASIC REFERENCE MANUAL        CHARACTER CODES                  Page 187
      1 January 1978                                                    App. D


                                     APPENDIX D.


                   TABLES OF XASC, XCHAR, IXASC, AND IXCHAR VALUES                   ______ __ _____ ______ ______ ___ ______ ______


         XASC XCHAR                      XASC XCHAR     XASC  XCHAR


           0  Nul                         43  +          86   V
           1  Control A                   44  ,          87   W
           2  Control B                   45  - (minus)  88   X
           3  Control C                   46  .          89   Y
           4  Control D                   47  /          90   Z
           5  Control E                   48  0          91   [
           6  Control F                   49  1          92   \
           7  Control G(Bell)             50  2          93   ]
           8  Control H(Backspace)        51  3          94   ^ or
           9  Control I(Tab)              52  4          95   _ or  (underline)
          10  Control J(Line feed)        53  5          96   ` (accent grave)
          11  Control K(Vert tab)         54  6          97   a
          12  Control L(Form feed)        55  7          98   b
          13  Control M(Carriage return)  56  8          99   c
          14  Control N                   57  9         100   d
          15  Control O                   58  :         101   e
          16  Control P                   59  ;         102   f
          17  Control Q                   60  <         103   g
          18  Control R                   61  =         104   h
          19  Control S                   62  >         105   i
          20  Control T                   63  ?         106   j
          21  Control U                   64  @         107   k
          22  Control V                   65  A         108   l
          23  Control W                   66  B         109   m
          24  Control X                   67  C         110   n
          25  Control Y                   68  D         111   o
          26  Control Z                   69  E         112   p
          27  Control [(escape)           70  F         113   q
          28  Control \                   71  G         114   r
          29  Control ]                   72  H         115   s
          30  Control ^                   73  I         116   t
          31  Control _                   74  J         117   u
          32  space                       75  K         118   v
          33  !                           76  L         119   w
          34  "                           77  M         120   x
          35  #                           78  N         121   y
          36  $                           79  O         122   z
          37  %                           80  P         123   {
          38  &                           81  Q         124   |
          39  ' (single quote)            82  R         125   }
          40  (                           83  S         126   ~
          41  )                           84  T         127   Del (rubout)
          42  *                           85  U
      TYMBASIC REFERENCE MANUAL        CHARACTER CODES                  Page 188
      1 January 1978                                                    App. D


                              TYMCOM-IX CHARACTER CODES                              _________ _________ _____


        IXASC IXCHAR          IXASC IXCHAR           IXASC  IXCHAR

           0  SPACE             43  K                  86   v
           1  !                 44  L                  87   w
           2  "                 45  M                  88   x
           3  #                 46  N                  89   y
           4  $                 47  O                  90   z
           5  %                 48  P                 
           6  &                 49  Q                  92   |
           7  ' (single quote)  50  R                 
           8  (                 51  S                  94   ~
           9  )                 52  T                  95   rubout (end of file
          10  *                 53  U                       file character)
          11  +                 54  V                  96   Nul  (control @)
          12  ,                 55  W                  97   Control A
          13  - (minus)         56  X                  98   Control B
          14  .                 57  Y                  99   Control C
          15  /                 58  Z                 100   Control D
          16  0                 59  [                 101   Control E
          17  1                 60  \                 102   Control F
          18  2                 61  ]                 103   Control G
          19  3                 62  ^ or              104   Control H
          20  4                 63  _ or  (underline) 105   Control I
          21  5                 64  ` (accent grave)  106   Control J
          22  6                 65  a                 107   Control K
          23  7                 66  b                 108   Control L
          24  8                 67  c                 109   Control M
          25  9                 68  d                 110   Control N
          26  :                 69  e                 111   Control O
          27  ;                 70  f                 112   Control P
          28  <                 71  g                 113   Control O
          29  =                 72  h                 114   Control R
          30  >                 73  i                 115   Control S
          31  ?                 74  j                 116   Control T
          32  @                 75  k                 117   Control U
          33  A                 76  l                 118   Control V
          34  B                 77  m                 119   Control W
          35  C                 78  n                 120   Control X
          36  D                 79  o                 121   Control Y
          37  E                 80  p                 122   Control Z
          38  F                 81  q                 123   Control [ (escape)
          39  G                 82  r                 124   Control \
          40  H                 83  s                 125   Control ]
          41  I                 84  t                 126   Control ^
          42  J                 85  u                 127   Control _(abort)
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 189
      1 January 1978                                                    App. E


                           APPENDIX E. EXTERNAL PROCEDURES

      TYMBASIC programs can call external functions/procedures written in
      SFORTRAN, FORTRAN-10, F40 (CFORTRAN), SIMPL, BLISS, COBOL, or MACRO.  The
      other-language functions used should be compiled using normal XEXEC
      commands, then the .REL file(s) should be named in a MODULE or LIBRARY
      statement.  The TYMBASIC program should contain appropriate DEF EXTERNALs.

      Each of these languages has some restrictions on the kinds of data used
      for arguments and return values.  In general,

         Numeric scalars may always be used.  The various Fortrans have
         corresponding data types, and numeric scalar arguments and return
         values are straightforward.  SIMPL and BLISS have no data types as such
         and deal only with machine words;  see the descriptions of these
         languages.

         Numeric arrays (whole arrays or array expressions) may be passed to any
         of the languages;  subarrays may not be used with the Fortrans.  The
         Fortrans are passed the address of the body of the array;  the other
         languages get the address of the descriptor.

         String scalars may be passed as arguments to all the languages.  For
         the Fortrans the address of the string body is passed.  The others get
         the address of the string descriptor.

         String arrays may not be passed to the Fortrans.  The other languages
         can handle them if they interpret the descriptors themselves (the
         address of the descriptor is passed).


      A String Descriptor is a two-word entity.  The first word contains the
      address of the string body (which always begins on a word boundary).  The
      second word consists of two halfwords:  the left half is the current
      length in characters and the right half is the declared maximum length of
      the variable (same as the left half for expressions and constants).  The
      string body is in ASCIZ format.  Array descriptors are discussed in
      Appendix F.
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 190
      1 January 1978                                                    App. E


                         SFORTRAN, FORTRAN-10, F40 (CFORTRAN)                         _________ ___________ ___ __________

      The three Fortrans are similar in the kinds of data that may be passed
      back and forth;  these comments apply to all three unless otherwise noted.

      Arguments to Fortran procedures are passed by reference.  If the Fortran
      procedure stores into an argument it will change the TYMBASIC caller's
      variable.  Two restrictions that apply here are that string variables and
      string or numeric constants may not be altered by a Fortran procedure.
      Example:

               SUBROUTINE FORSUB(A,B,C)
               A=3
               CALL XYZSUB(B)
               END

      The actual argument (in TYMBASIC) for C could be a real variable,
      expression, or constant.  A and B could not be constants.  A is obviously
      modified by the subroutine;  B is not explicitly changed but is passed to
      another subroutine which could possibly store into it, so it is assumed to
      be modified.

      Numeric or logical scalars all work with no special handling if declared
      to be the same type in both the TYMBASIC DEF and the Fortran subroutine.
      The one slight incompatibility is using double precision with F40.
      TYMBASIC and F40 use different hardware representations for double
      precision numbers:  TYMBASIC uses "hardware format", F40 uses "software
      format", which has about two decimal digits less precision.  TYMBASIC will
      automatically convert between the two formats on both call and return, but
      values returned from F40 will be inaccurate in the last few digits.

      Numeric arrays may be passed as arguments to any of the Fortrans, except
      that double precision arrays may not be passed to F40 (the conversion
      described for double precision scalars is not performed for arrays).

      The Fortran subroutine being called may declare the array with constant
      bounds if the size is known, or the dimensions may be passed as separate
      arguments (this is the same technique used by an all-Fortran program).
      IMPORTANT:  If an array has more than one dimension, the array declaration
      and references in the Fortran routine must list the subscripts in the
      opposite order from that used in the TYMBASIC program.  This is because
      the two languages store the array elements in memory differently:
      TYMBASIC varies the last subscript most rapidly;  Fortran varies the first
      subscript most rapidly.

      Care must be taken with the BASE statement in TYMBASIC - Fortran has a
      default base of one for each dimension just like TYMBASIC, but if that is
      changed with the BASE statement, each Fortran routine must have the lower
      bound declared explicitly to match.
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 191
      1 January 1978                                                    App. E


      String scalars (not arrays) may be passed to any of the Fortrans by
      declaring the appropriate argument in the DEF EXTERNAL as a STRING
      variable.  The string is passed to Fortran in the same way that Fortran
      passes a Hollerith constant, and may be received as a numeric scalar or
      array.  This is true for SFORTRAN as well - the string isn't a STRING
      variable as used in SFO, just a Hollerith constant.

      Restrictions on the use of Fortran routines:
        The Fortran code may not do any I/O.
        SFORTRAN code may not use any STRING variables.

      Example:

         (TYMBASIC)
         10 DEF INTEGER EXTERNAL F40 BONZ(INTEGER(ARY(*,*),M,N,I,J))
         20 BASE 0
         30 INTEGER HOOHOO(3,7)
         40 HOOHOO(I,J) = I*10+J FOR I = 0 TO 3 FOR J = 0 TO 7
         50 PRINT BONZ(HOOHOO,3,7,2,4)
         60 END

         (F40)
                 INTEGER FUNCTION BONZ(ARY,M,N,I,J)
         C returns the value of ARY(I,J) where ARY is dimensioned 0:M,0:N
         C in TYMBASIC terms.  Note the reversal of all subscripts here.
                 INTEGER M,N,I,J,ARY(0/N,0/M)
                 BONZ = ARY(J,I)
                 RETURN
                 END



                                        COBOL                                        _____

      COBOL and Superfortran have the same calling conventions.  To define a
      COBOL procedure, use a DEF EXTERNAL SFO in TYMBASIC.  Passing of arguments
      follow the SFO restrictions listed above.  TYMBASIC and COBOL data types
      do not always correspond.  For example, COBOL has no complex or double
      precision type while TYMBASIC has no two word integer type.
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 192
      1 January 1978                                                    App. E


                                 TBA CALLING SEQUENCE                                 ___ _______ ________

      Each TBA procedure has a parameter vector, a block in the low segment
      which holds the data local to the procedure.  The first word of the
      parameter vector holds the procedure's return address.  The second word is
      used to hold the call time value of register 16 (octal) which must be
      preserved across procedure calls.  Successive groups of words hold the
      parameters in the order they appear in the DEF.  The number of words
      allocated for each parameter depends upon the type of that parameter.
      Numeric scalars are allocated one or two words (two for double or
      complex).  When the procedure is called, the value of the scalar argument
      is stored into its allocated portion of the parameter vector.

      Two words are allocated for a string parameter to hold a string
      descriptor.  At call time, a block of memory is allocated into which the
      contents of the argument body is copied.  The string descriptor is then
      set so that it points to this new body.

      For an array parameter, two items are allocated in the parameter vector.
      First, one word is used to point to the array descriptor being used for
      the parameter.  Following the array pointer word, space is reserved for a
      descriptor of the appropriate dimensionality.  When an array parameter is
      passed by name, the pointer word is set to the address of the descriptor
      of the argument array.  When an array is passed by value, a copy of the
      array body is made and the descriptor in the parameter vector is set to
      describe that copy.  The pointer word is set to point to the parameter
      vector descriptor.  References to an array parameter within a procedure
      are carried out indirectly through the pointer word.

      After storing the arguments into the parameter vector, the procedure is
      called with a JSP 1, .  For string and array valued procedures, the JSP is
      followed by a word containing the address of the descriptor for the
      resulting string or array.  For procedures defined with a DEF ENTRY, the
      procedure code is preceeded by a word containing the address of the third
      word of the parameter vector (the location of the first parameter).

      The procedure starts with two MOVEMs which save the contents of register 1
      (the return address) and register 16 (octal) in the parameter vector.  The
      procedure ends with a MOVE that restores register 16 and a JRST to the
      return address.
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 193
      1 January 1978                                                    App. E


                            SFO AND CFO CALLING SEQUENCES                            ___ ___ ___ _______ _________

      The SFO calling sequence is used for SFORTRAN, FORTRAN-10, and COBOL.
      Parameters are placed in an argument list with one word per parameter.
      The left half is a type code, the right half is the address of the
      argument.  The argument list is preceded by a word containing, in its left
      half, the negative of the number of entries in the list.  The address of
      the first argument in the list is placed in register 16 and then the
      routine is called with a PUSHJ 17,.

            in hiseg                          in loseg
                                            -number of entries,,0
         MOVEI 16,ARGLST            ARGLST:  type,,address
         PUSHJ 17,routine name               type,,address
                                                  .
                                                  .
      The type codes for SFO are:
         logical  40b
         integer  100b
         real     200b
         double   400b
         complex  600b
         string   740b


      The argument list of the CFO and F40 calling sequence immediatley follows
      the call.  This requires the call and argument list to be in the loseg.
      The argument list has one word per argument consisting of the ARG no-op
      (same as a JUMP), a type code in the ac field and the address of the
      argument in the address field.  The routine is called with a JSA 16,.

            in hiseg                           in loseg
         HILOC:  JRST LOLOC           LOLOC:  JSA 16,routine name
                                              ARG type,,address
                                              ARG type,,address
                                              JRST HILOC+1

      The type codes for CFO/F40 are:
         0 - integer
         2 - real
         3 - logical
         5 - hollerith (string)
         6 - double precision
         7 - complex argument
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 194
      1 January 1978                                                    App. E


                                        SIMPL                                        _____

      SIMPL routines must be compiled with the (,P) switch to use the PUSHJ
      calling sequence rather than the JSP calling sequence:  -COM FOO(,P) where
      FOO.SIM contains SIMPL routines to be called by TYMBASIC.

      Numeric and logical scalar arguments may be passed to SIMPL with these
      precautions:

         SIMPL has no data types as such, and normally performs integer
         arithmetic on variables.  TYMBASIC will convert data to the type
         specified in the DEF EXTERNAL.  Logicals are passed as 0 for false, 1
         for true.

         Double and complex arguments take two words each in machine
         representation.  Since each SIMPL argument is one word, the procedure
         must use two adjacent dummy arguments to receive one double or complex
         argument.  Double or complex values may be returned from SIMPL by using
         the RETURN [A;B] construction.

      String scalars may be passed to SIMPL.  The address of the string
      descriptor is passed.  The SIMPL routine may modify the descriptor.  The
      string body may not be moved or expanded beyond its current size.

      Numeric or string arrays may be passed to SIMPL.  The address of the array
      descriptor is passed.  The code will need to work through the descriptor
      to access the array elements.


      The SIMPL calling sequence is the most straightforward of any of the
      languages.  The arguments are passed in consecutive registers beginning
      with register one.  Numeric scalars take one register for logical/integer/
      real, two registers for double/complex.  The register[s] contain the value
      of the argument, not a pointer.  Strings and arrays take one register
      each, which contains the address of the string/array descriptor or the
      string body.  Only registers 1 thru 10 (decimal) may be used to pass
      arguments.

      A result may be returned in register 1 (and register 2 for double or
      complex functions).

      SIMPL returns with a POPJ 17,

      A MACRO routine may be called declaring it with DEF EXTERNAL SIMPL in
      TYMBASIC and using the SIMPL calling sequence.  All registers may be
      destroyed by the MACRO routine except 17 (the stack pointer).
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 195
      1 January 1978                                                    App. E


                                        BLISS                                        _____

      BLISS routines must contain the declaration SREG= 17 in the MODULE
      statement (that's the MODULE statement in BLISS, not the MODULE command in
      TYMBASIC).  The other special registers (B, F, and V) may be allocated as
      desired.

      BLISS has no data types.  TYMBASIC will convert arguments to the types
      specified in the parameter list of the DEF.  The result will be
      interpreted according to the type of the DEF.

      As with SIMPL, two adjacent BLISS arguments are needed to recieve one
      TYMBASIC double or complex argument.  String scalars may be passed to
      BLISS.  The address of the descriptor is passed.  The descriptor may be
      modified but the body may not be expanded or moved.

      Numeric or string arrays may be passed to BLISS.  The address of the
      descriptor is passed.  The BLISS routine will need to interpret the
      descriptor to access the array.

      The BLISS calling sequence passes the arguments on the stack.  For numeric
      scalars the actual value is stacked.  For strings and arrays the address
      of the descriptor is passed.  The routine is called with a PUSHJ 17,.
      TYMBASIC will unstack the arguments after the call.
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 196
      1 January 1978                                                    App. E


                       INTERFACING OTHER LANGUAGES TO TYMBASIC                       ___________ _____ _________ __ ________

      There are five areas in which an external procedure might conflict with
      the TYMBASIC system.  Care must be taken to either avoid these conflicts
      or program around them.

      1.  UUO's:  Unimplemented User Operations
        These are special system instructions (opcodes 1 through 37B) that trap
        to the user program rather than to the monitor when executed.  TYMBASIC
        uses a subset of these - 1 through 16B and 31B through 37B - for value
        traces in DEBUG mode and errors, respectively.

           The error UUO's are:

            ESCAPE     31B
            ERROR      32B
            MATH       33B
            TRANSFORM  34B
            DATAEND    35B
            ENDFILE    36B
            FILE       37B

        The ENDFILE and FILE UUO's expect a file unit number in register 1.  All
        UUO's must have a vaild error number in the address field.  They do not
        return.

        If an external procedure uses its own UUO's it must override the
        TYMBASIC UUO instruction in location 41B in the Job Data Area, and it
        must restore the instruction before returning to TYMBASIC.


      2.  Memory

        TYMBASIC maintains control of memory allocation during execution of a
        user program.  If an external procedure needs to allocate memory, the
        procedure must:

           1.  Call the routine ALLSP with the following arguments:

             register 0 - number of words to allocate
             register 1 - address of pointer for allocated block
                           also called the "descriptor"
             register 2 - zero

           The descriptor must be provided, and it will contain on return from
           ALLSP the address of the "body" - the block of core just allocated.
           Immediatly preceeding the body (in the right half-word) will be a
           back pointer to the descriptor;  so if the descriptor must be moved,
           the back pointer must be updated.
      TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES              Page 197
      1 January 1978                                                    App. E


           2.  Call the routine RELSP to release a block of core, with register
           1 containing the address of the body.  RELSP will zero the descriptor
           by means of the back pointer.


      3.  Math and Escape Trapping

        TYMBASIC uses the Tymshare Software Interrupt System to trap escapes and
        math errors such as overflow, etc.  If an external procedure needs to
        trap escapes or math errors it must use this same system and must
        restore the previous state of the system before returning to TYMBASIC.


      4.  Allocation of I/O Channels

        External procedures must only attempt to allocate a free channel, and
        should not assume that certain channels are free.


      5.  Global Names

        Most TYMBASIC global names contain a period in the name (such as
        ".dsin").  However, conflicts may arise with global names belonging to
        the user.  If this should happen another name should be used.
      TYMBASIC REFERENCE MANUAL        INTERNAL ARRAY HANDLING          Page 198
      1 January 1978                                                    App. F


                         APPENDIX F. INTERNAL ARRAY HANDLING

      A TBA array has a body and a descriptor.  The body is a block of memory
      which contains the elements of the array.  The elements are stored in a
      sequential manner with the rightmost subscript varying most rapidly.  The
      elements of a subarray exist in the body of their parent array, that is,
      the body of a subarray is a subset of the body of its parent.  The
      descriptor contains information needed to access the array.

      Array (non-subarray) descriptors:

              Word 0 - pointer to array body.  In the case of a string
                       array, each element is a two word descriptor.

              Word 1 - left half :  size of body in words
                       right half:  computed array base

              Word 2 - left half :  type of array:  0 - logical
                                                    1 - integer
                                                    2 - real
                                                    3 - double
                                                    4 - complex
                                                    5 - string
                       right half:  number of dimensions

              Then starting at word 3 is a list of lower and upper bounds for
              each dimension.  There is one word per dimension starting with the
              rightmost dimension.
                       left half :  lower bound for this dimension
                       right half:  upper bound for this dimension

              Following is a list of access coefficients.  Each takes a half
              word and the list starts with the coefficient for the rightmost
              dimension.

              The access code follows next.  The size of the access code depends
              on the dimensionality of the array.  For subarrays and arrays with
              three or more dimensions, the access code is a two word call to an
              access routine at another location.
      TYMBASIC REFERENCE MANUAL        INTERNAL ARRAY HANDLING          Page 199
      1 January 1978                                                    App. F


                                 SUBARRAY DESCRIPTORS                                 ________ ___________

      Subarray descriptors are structured somewhat differently.  A subarray may
      have a lesser dimensionality than its parent because some of its
      dimensions may be fixed.  These fixed dimensions are called hidden
      dimensions.  A dimension in the parent that is not fixed in the subarray
      is called an apparent dimension.

      The subarray descriptor includes a dimension map.  This map contains one
      bit per dimension of the parent indicating whether that dimension is
      hidden (bit=0) or apparent (bit=1).  The rightmost bit of the dimension
      map refers to the rightmost dimension, second from the right refers to the
      second dimension from the right, etc.

      Subarray descriptors:

              Word 0 - left half :  4 bits containing the count of the
                                    hidden dimensions followed by 14 bits
                                    containing the dimension map.
                       right half:  address of parent array's access code

              Word 1 - left half :  number of elements in this subarray
                       right half:  address of parent array descriptor

              Word 2 - left half :  type of array
                       right half:  number of apparent dimensions

              Starting at word 3 are the upper and lower bounds and the access
              coefficients for the apparent dimensions, as for non-subarrays.

              The access code, which is always two words long for subarrays,
              follows next.

              Then follows a list of the subscripts for the hidden dimensions,
              starting at the rightmost hidden dimension, one halfword per
              hidden dimension.
      TYMBASIC REFERENCE MANUAL        INTERNAL ARRAY HANDLING          Page 200
      1 January 1978                                                    App. F


                                     ARRAY ACCESS                                     _____ ______

      Array access in TYMBASIC is done with a computed array base and a set of
      access coefficients, one per dimension.  The computed array base
      represents the location of the element whose subscripts are all zero,
      which may be a fictitious element.  The access coefficients are used to
      compute an offset from this element.  The location of an array element is
      the sum of the computed array base and the summation of the products of
      the subscripts and their corresponding access coefficients.  That is:

                   n
           L = B +   Si*Ci  where  n= number of dimensions
                  i=1              S1 thru Sn are the subscripts
                                   C1 thru Cn are the access coefficients
                                   B= the computed array base
                                   L= location(address) of the element

      Access coefficients are derived from the element size and the lower and
      upper bounds for the dimensions in the following manner:

           Cn= element size.    1 for logical,integer and real.
                                2 for double,complex, and string.
           Cn-1= Cn * (Un-Ln +1)
                 .
                 .
           Ci= Ci+1 * (Ui+1 - Li+1 + 1)
                 .
                 .
           C1= C2*(U2 - L2 +1)

      where Li is the lower bound and Ui the upper bound for subscript i.  For
      subarrays, Cn is always 1 regardless of element size.  Note that C0 is the
      array body size in words.

      The computed array base is computed as follows:

                   n
          B = W -    Li*Ci    where W is the address of the
                  i=1                 array's first element

      The computed array base may be equal, less or greater than W.


      For example, consider the array created by:

          10 BASE 2
          20 STRING ARRAY(4,5)

         The access coefficients are C2=2 (each element is a two word string
         descriptor) and C1= C2*(5-2+1)=8 .
      TYMBASIC REFERENCE MANUAL        INTERNAL ARRAY HANDLING          Page 201
      1 January 1978                                                    App. F


         The array size in words is C1*(4-2+1)=24 words.

         The computed array base, B = (W- C1*2 +C2*2) = W-20 where W is the
         address of the arrays first element.

         The location of ARRAY(3,4) is B+ C1*3 + C2*4 = W+10 .

      The user may use the array base and access coefficients manually, or
      indirectly through the access code.


                                     ACCESS CODE                                     ______ ____

      The access code in the array or subarray descriptor may be used for fast
      array accessing (this is presently limited to arrays of 2 or fewer
      dimensions).  The subscripts are placed in the registers starting with the
      leftmost subscript in register 1.  Then with register 17 set up as a stack
      pointer, the acces code is called with a PUSHJ 17.  Upon return, register
      2 contains the address of the array element.

      Example:

         (TYMBASIC)
         10 DEF EXTERNAL SIMPL GETELM(INTEGER(I,J),A(*,*))
         20 !  USING THE SIMPL CALLING SEQUENCE FOR A MACRO SUBROUTINE
         30 DIM ARY(3,3)
         40 PRINT GETELM(2,3,ARY)

         (MACRO)
         ENTRY   GETELM
                               ;REGISTERS 1 AND 2 CONTAIN THE SUBSCRIPTS
                               ;REGISTER 3 CONTAINS THE DESCRIPTOR ADDRESS
         GETELM: PUSHJ 17,6(3) ;ACCESS CODE AT WORD 6 FOR ARRAY OF 2 DIMs
                 MOVE  1,(2)   ;ADDRESS OF ELEMENT RETURNED IN REGISTER 2
                 POPJ  17,     ;RETURN TO TBA WITH VALUE OF ELEMENT
                               ;IN REGISTER 1
      TYMBASIC REFERENCE MANUAL        AUTOMATICALLY GENERATED FILES    Page 202
      1 January 1978                                                    App. G


                      APPENDIX G. AUTOMATICALLY GENERATED FILES


         There are two classes of files generated by TYMBASIC without user
         confirmation.


         1.  Implicitly requested files

             Files with extension .REL or .RDL are relocatable files created by
             the Compilation phase.

             Files with the extension .LOW can be created by the SAVE BINARY
             command.

         2.  Temporary files

             These are files created by TYMBASIC to temporarily store
             information, and are automatically deleted when the user GFD's or
             LOG's off.

             The characters "nnn" represent the three-digit job number of the
             user.

             VMFnnn.TMP              core-image file
             nnnDST.REL or .RDL      relocatable direct statement file
             nnnWRK.REL or .RDL      relocatable workspace file
             nnnWRK.TBA              holds workspace symbolics during
                                     Global Recompilation
             SBAnnn.SHR              Run phase high segment file

      TYMBASIC REFERENCE MANUAL                INDEX                    Page 203
      1 January 1978  


                                        INDEX                                        _____

         ! . . . . . . . . . . . . . . . . . 6, 95

         $ formatting character  . . . . . . 155, 161

         *
            in OPEN statement  . . . . . . . 90
            in subarray definition . . . . . 26
            multiplication . . . . . . . . . 30, 32
            protection code  . . . . . . . . 91
         * formatting character  . . . . . . 155, 161
         **  . . . . . . . . . . . . . . . . 30-32

         + . . . . . . . . . . . . . . . . . 30, 32
            string concatenator  . . . . . . 37
         + formatting character  . . . . . . 153

         -
            binary minus . . . . . . . . . . 30
            minus  . . . . . . . . . . . . . 32
            unary minus  . . . . . . . . . . 30
         - formatting character  . . . . . . 154

         /
            division . . . . . . . . . . . . 30, 32
            format . . . . . . . . . . . . . 127, 131, 168
         / formatting character  . . . . . . 164, 167

         940 editor  . . . . . . . . . . . . 181, 183, 185

         = . . . . . . . . . . . . . . . . . 30, 35, 37, 82
         ==  . . . . . . . . . . . . . . . . 82
         =>  . . . . . . . . . . . . . . . . 37
         =<  . . . . . . . . . . . . . . . . 37
         =>  . . . . . . . . . . . . . . . . 35
         =<  . . . . . . . . . . . . . . . . 35
         =#  . . . . . . . . . . . . . . . . 28

         ?
            input prompt . . . . . . . . . . 80

         @ . . . . . . . . . . . . . . . . . 38

         A formatting character  . . . . . . 151
         ABS . . . . . . . . . . . . . . . . 49-50
         Absolute value  . . . . . . . . . . 50
         Access methods in files . . . . . . 125
         ACOS  . . . . . . . . . . . . . . . 48
         Activation characters . . . . . . . 128
         Addition  . . . . . . . . . . . . . 32
         AKA . . . . . . . . . . . . . . . . 41-44
         ALL
            line range list  . . . . . . . . 103
            protection code  . . . . . . . . 91
         Ampersands  . . . . . . . . . . . . 6, 66
         AND . . . . . . . . . . . . . . . . 30, 36
         AP
            protection code  . . . . . . . . 91
         Arccosine . . . . . . . . . . . . . 48
         Arcsine . . . . . . . . . . . . . . 48
         Arctangent  . . . . . . . . . . . . 48
         Arguments (see Procedures)  . . . . 44
         Arithmetic shift  . . . . . . . . . 53
         Arrays  . . . . . . . . . . . . . . 38
            @  . . . . . . . . . . . . . . . 38
            arguments (see Procedures) . . . 45
            array body . . . . . . . . . . . 192, 198
            array descriptor . . . . . . . . 189, 192, 194, 198
            assignment . . . . . . . . . . . 82
            bounds . . . . . . . . . . . . . 11, 15, 25, 46, 69
            declaration  . . . . . . . . . . 24, 46
            definition . . . . . . . . . . . 15
            dimensions . . . . . . . . . . . 15, 24-25
            elements . . . . . . . . . . . . 15, 25
            expressions  . . . . . . . . . . 38
            input  . . . . . . . . . . . . . 85, 138
            internal access
              access code  . . . . . . . . . 198-199, 201
              access coefficients  . . . . . 198, 200
              array base . . . . . . . . . . 198, 200
              lower bounds . . . . . . . . . 198-199
              upper bounds . . . . . . . . . 198-199
            intersection . . . . . . . . . . 38
            lower bound of . . . . . . . . . 69
            manipulation . . . . . . . . . . 38, 85
            manipulation statements  . . . . 11
            operators  . . . . . . . . . . . 33
            output . . . . . . . . . . . . . 85, 138, 142
            parameters (see Parameters)  . . 46
            parent of subarray . . . . . . . 25
            size . . . . . . . . . . . . . . 24
            slices (see Subarrays) . . . . . 25
            subarrays (see Subarrays)  . . . 25
            subscripts . . . . . . . . . . . 15, 25, 190, 199
              bounds checking of . . . . . . 104
            system-defined functions . . . . 52
            variables (see Variables)  . . . 23
         ARSH  . . . . . . . . . . . . . . . 53
         ASC . . . . . . . . . . . . . . . . 28, 55
         ASCII . . . . . . . . . . . . . . . 123
         ASCII collating sequence  . . . . . 28
         ASCIZ . . . . . . . . . . . . . . . 189
         ASCTABLE  . . . . . . . . . . . . . 28, 37
         ASIN  . . . . . . . . . . . . . . . 48
         Assembly  . . . . . . . . . . . . . 3
         Assignment  . . . . . . . . . . . . 82
            strings  . . . . . . . . . . . . 82
         Assignment list . . . . . . . . . . 82
         Asterisks
            in OPEN statement  . . . . . . . 90
            in subarray definition . . . . . 26
            protection code  . . . . . . . . 91
         AT clause . . . . . . . . . . . . . 127, 129
         ATAN  . . . . . . . . . . . . . . . 48
         ATN . . . . . . . . . . . . . . . . 48

         B formatting character  . . . . . . 163
         Backslashes . . . . . . . . . . . . 184
         Backspacing
            in line editing  . . . . . . . . 179
         Backwards boundary  . . . . . . . . 184
         Backwards deletion  . . . . . . . . 183-184
            completion . . . . . . . . . . . 184
         BAN . . . . . . . . . . . . . . . . 30
         BASE  . . . . . . . . . . . . . . . 25, 63, 69, 190
         Bel . . . . . . . . . . . . . . . . 182-184
         BEX . . . . . . . . . . . . . . . . 30
         Binary files  . . . . . . . . . . . 122-123, 128
         Binary format . . . . . . . . . . . 154, 160
         Binary I/O
            data storage . . . . . . . . . . 124
            strings  . . . . . . . . . . . . 123
         BLISS . . . . . . . . . . . . . . . 41, 43, 45, 189, 195
         BOR . . . . . . . . . . . . . . . . 30
         BOUNDARY  . . . . . . . . . . . . . 63, 69
         Bounds
            arrays . . . . . . . . . . . . . 25
            subarrays  . . . . . . . . . . . 26
         Braces
            in presentation  . . . . . . . . 2
         Brackets
            in presentation  . . . . . . . . 2
         BREAK . . . . . . . . . . . . . . . 103-104
         Breakpoints . . . . . . . . . . . . 65, 103

         C formatting character  . . . . . . 151
         CALL  . . . . . . . . . . . . . . . 39, 44, 70
         Carraige returns
            at end of IMAGE  . . . . . . . . 149
            in free-form input . . . . . . . 140
         Carriage returns  . . . . . . . . . 6, 127-128, 134, 138, 177, 181,
                                             183, 185-186
            in FORM formats  . . . . . . . . 167, 169
            in free-form output  . . . . . . 141-142
            in IMAGE formats . . . . . . . . 148
            terminal output  . . . . . . . . 138
            use of / . . . . . . . . . . . . 168
            use of \ . . . . . . . . . . . . 168
         Case independence . . . . . . . . . 18, 20
         CDE . . . . . . . . . . . . . . . . 58, 60, 104
         Centering . . . . . . . . . . . . . 55, 151
         CFO . . . . . . . . . . . . . . . . 193
         CFORTRAN  . . . . . . . . . . . . . 189-190, 193
         CHAR  . . . . . . . . . . . . . . . 28, 55
         Characteristics of files  . . . . . 122
         CHARTABLE . . . . . . . . . . . . . 28, 55
         CIB . . . . . . . . . . . . . . . . 70
         Circular shift  . . . . . . . . . . 53
         Class . . . . . . . . . . . . . . . 23
            definition . . . . . . . . . . . 15
         CLOSE . . . . . . . . . . . . . . . 70, 122
         CLOSE 0 . . . . . . . . . . . . . . 73
         Closing files . . . . . . . . . . . 70, 95, 98, 124
         CMPLX . . . . . . . . . . . . . . . 49
         COB . . . . . . . . . . . . . . . . 71
         COBOL . . . . . . . . . . . . . . . 41, 189, 191, 193
         Collating sequence  . . . . . . . . 28, 55
         Colon . . . . . . . . . . . . . . . 137, 140
         Comma . . . . . . . . . . . . . . . 137, 140
            in conditional field . . . . . . 159
         Command files . . . . . . . . . . . 56, 66-67, 80
            execution of . . . . . . . . . . 105
         Command source  . . . . . . . . . . 80
         Command/Statement phase . . . . . . 57, 59, 128
         Commands  . . . . . . . . . . . . . 6
            control  . . . . . . . . . . . . 12
            debug  . . . . . . . . . . . . . 12
            edit . . . . . . . . . . . . . . 12
            length . . . . . . . . . . . . . 6
            program control  . . . . . . . . 12
            types  . . . . . . . . . . . . . 12
            utility  . . . . . . . . . . . . 13
         Comments  . . . . . . . . . . . . . 6, 95
            in DATA statement  . . . . . . . 72
         COMP  . . . . . . . . . . . . . . . 50, 55
         Comparisons
            numeric  . . . . . . . . . . . . 50
            string . . . . . . . . . . . . . 28, 55
         Compilation . . . . . . . . . . . . 3, 57, 60, 62
         Compilation phase . . . . . . . . . 57, 60, 202
         COMPLEX . . . . . . . . . . . . . . 24, 71
         Complex
            definition . . . . . . . . . . . 14
            functions  . . . . . . . . . . . 49
            input  . . . . . . . . . . . . . 143
            magnitude  . . . . . . . . . . . 49
            output . . . . . . . . . . . . . 144
            value  . . . . . . . . . . . . . 49
         CON . . . . . . . . . . . . . . . . 52
         Concatenation . . . . . . . . . . . 51
         Concepts  . . . . . . . . . . . . . 3
         Condition trap  . . . . . . . . . . 89
         Conditional field characters  . . . 158
         Confirmation keyword  . . . . . . . 21
            in file nomen  . . . . . . . . . 21
         CONJ  . . . . . . . . . . . . . . . 49
         Conjugate . . . . . . . . . . . . . 49
         Constants
            logical  . . . . . . . . . . . . 17
            numeric  . . . . . . . . . . . . 16
            string . . . . . . . . . . . . . 17
         Context . . . . . . . . . . . . . . 8, 46, 65
         Continuability  . . . . . . . . . . 64
         Continuation of long lines  . . . . 6
         Continue point  . . . . . . . . . . 58, 64
         Control A . . . . . . . . . . . . . 176, 179, 182-184
         Control B . . . . . . . . . . . . . 102, 128, 176, 181-182
         Control C . . . . . . . . . . . . . 176, 182-183
         Control characters  . . . . . . . . 6, 175-176, 185
            in input lines . . . . . . . . . 109
         Control commands  . . . . . . . . . 12
         Control D . . . . . . . . . . . . . 176, 181-183, 185
         Control E . . . . . . . . . . . . . 176, 182-183
         Control F . . . . . . . . . . . . . 176, 182-183, 185
         Control G . . . . . . . . . . . . . 128, 140, 142, 176, 181-182
         Control H . . . . . . . . . . . . . 176, 179, 181-184
         Control I . . . . . . . . . . . . . 119, 176, 182, 186
         Control J . . . . . . . . . . . . . 109, 176, 181-183, 185
         Control K . . . . . . . . . . . . . 177, 179, 182-183
         Control L . . . . . . . . . . . . . 109, 177, 182-183
         Control M . . . . . . . . . . . . . 177, 182-183
         Control N . . . . . . . . . . . . . 177, 181-184
         Control O . . . . . . . . . . . . . 177, 182-183
         Control P . . . . . . . . . . . . . 177, 179, 182-183
         Control Q . . . . . . . . . . . . . 177, 179, 182-185
         Control R . . . . . . . . . . . . . 177, 181-182, 184, 186
         Control S . . . . . . . . . . . . . 178-179, 182-183
         Control T . . . . . . . . . . . . . 178, 181-182
         Control transfer  . . . . . . . . . 75, 87, 97
         Control U . . . . . . . . . . . . . 178, 182-183, 186
         Control V . . . . . . . . . . . . . 178, 181-182
         Control W . . . . . . . . . . . . . 178-179, 182-184
         Control X . . . . . . . . . . . . . 178-179, 182-183
         Control Y . . . . . . . . . . . . . 178, 181-184
         Control Z . . . . . . . . . . . . . 178, 182-183
         Conversion  . . . . . . . . . . . . 15, 48, 123
            in assignments . . . . . . . . . 82
            in expressions . . . . . . . . . 31
            in function calls  . . . . . . . 50
            in I/O . . . . . . . . . . . . . 137, 139
            in procedure calls . . . . . . . 45
            lower to upper case  . . . . . . 154
            numeric to string  . . . . . . . 54-55
            string to numeric  . . . . . . . 54-55
         Coordinated backspacing . . . . . . 179
         COPY  . . . . . . . . . . . . . . . 71
         Copying files . . . . . . . . . . . 71
         Core image  . . . . . . . . . . . . 57
         COS . . . . . . . . . . . . . . . . 48
         COSH  . . . . . . . . . . . . . . . 48
         Cosine  . . . . . . . . . . . . . . 48
         COUNT . . . . . . . . . . . . . . . 55
         CP
            protection code  . . . . . . . . 91
         CPAD  . . . . . . . . . . . . . . . 55
         Cross reference . . . . . . . . . . 106
         Cycle shift . . . . . . . . . . . . 53

         D
            in constants . . . . . . . . . . 17
         D formatting character  . . . . . . 152, 156
         D-format  . . . . . . . . . . . . . 143
         DATA  . . . . . . . . . . . . . . . 6, 72, 137
         Data
            declaration statements . . . . . 11
            in variables . . . . . . . . . . 23-24, 63-64
            representation . . . . . . . . . 123
            types (see Types)  . . . . . . . 14
         Data input  . . . . . . . . . . . . 94
         Data unit . . . . . . . . . . . . . 83, 123, 125
         DATAEND . . . . . . . . . . . . . . 87, 94, 196
         DATE  . . . . . . . . . . . . . . . 56
         Date
            on listings  . . . . . . . . . . 105
         DBL . . . . . . . . . . . . . . . . 50
         DEBUG . . . . . . . . . . . . . . . 104, 196
         Debug commands  . . . . . . . . . . 12
         Debugging . . . . . . . . . . . . . 3, 118, 120
         Declaration
            array  . . . . . . . . . . . . . 24
            context  . . . . . . . . . . . . 46
            dimensionality . . . . . . . . . 24
            duplicate  . . . . . . . . . . . 24
            global procedures  . . . . . . . 42
            implicit . . . . . . . . . . . . 25, 118
            parameters . . . . . . . . . . . 42, 44
              arrays . . . . . . . . . . . . 46
            procedures . . . . . . . . . . . 42-44
            subarrays
              NAME statement . . . . . . . . 27
              syntax . . . . . . . . . . . . 26
            type . . . . . . . . . . . . . . 24
            variables  . . . . . . . . . . . 11, 23-24
              syntax . . . . . . . . . . . . 24
         DEF . . . . . . . . . . . . . . . . 39, 42, 44, 46, 72, 189, 191-192
            see Procedures . . . . . . . . . 39
         Default data type . . . . . . . . . 19, 24
         Default extension . . . . . . . . . 105-106, 108, 113
            definition . . . . . . . . . . . 21
         DEFINE  . . . . . . . . . . . . . . 72
         Definitions . . . . . . . . . . . . 3
            libraries  . . . . . . . . . . . 3
            modules  . . . . . . . . . . . . 3
            programs . . . . . . . . . . . . 3
            workspace  . . . . . . . . . . . 3
         Del . . . . . . . . . . . . . . . . 185-186
         DELETE  . . . . . . . . . . . . . . 105
         DET . . . . . . . . . . . . . . . . 52, 63
         Determinant . . . . . . . . . . . . 52
         Differences, from 940 editor  . . . 181
         DIM . . . . . . . . . . . . . . . . 24, 73
         Dimensionality  . . . . . . . . . . 23-24
            definition . . . . . . . . . . . 15
         Direct statements (see Statements, direct)  8
         Disk files (see Files)  . . . . . . 122
         DIV . . . . . . . . . . . . . . . . 30, 32
         Division  . . . . . . . . . . . . . 32
            integer result . . . . . . . . . 32
         DLIST . . . . . . . . . . . . . . . 105
         DO  . . . . . . . . . . . . . . . . 80, 105
         Documenting
            programs . . . . . . . . . . . . 6
         Dots
            in presentation  . . . . . . . . 2
         DOUBLE  . . . . . . . . . . . . . . 24, 73
         Double
            range of . . . . . . . . . . . . 14
         Double precision  . . . . . . . . . 73
         Double precision value  . . . . . . 50
         DPI . . . . . . . . . . . . . . . . 17
         DUMP  . . . . . . . . . . . . . . . 106
         DUMP refs . . . . . . . . . . . . . 106

         E
            exponential  . . . . . . . . . . 49
            in constants . . . . . . . . . . 16
         E formatting character  . . . . . . 152
         E-format  . . . . . . . . . . . . . 16, 137, 143-144, 146, 152
         ECHO  . . . . . . . . . . . . . . . 66, 106
         Echoing . . . . . . . . . . . . . . 66
         EDIT  . . . . . . . . . . . . . . . 106
         Edit commands . . . . . . . . . . . 12
         Editing . . . . . . . . . . . . . . 3, 107, 113
            a line . . . . . . . . . . . . . 175
         Editor
            differences from IX system . . . 181
            prompting  . . . . . . . . . . . 185
         Eight-level . . . . . . . . . . . . 70, 73, 138, 149
         EIGHTI  . . . . . . . . . . . . . . 73
         EIGHTO  . . . . . . . . . . . . . . 74
         Elements
            arrays . . . . . . . . . . . . . 25
            subarrays  . . . . . . . . . . . 25
         ELSE  . . . . . . . . . . . . . . . 80
         ELSE clause
            in IF statement  . . . . . . . . 79
         END . . . . . . . . . . . . . . . . 64, 74
         End of file . . . . . . . . . . . . 122, 134
         ENDF  . . . . . . . . . . . . . . . 42, 74
         ENDFILE . . . . . . . . . . . . . . 87, 196
         ENDIF . . . . . . . . . . . . . . . 74, 80
         ENTER . . . . . . . . . . . . . . . 107
         ENTRY . . . . . . . . . . . . . . . 39, 43
         EOR . . . . . . . . . . . . . . . . 139
            at end of IMAGE  . . . . . . . . 149
            in FORM formats  . . . . . . . . 167, 169
         EPS . . . . . . . . . . . . . . . . 28, 35, 52
         EQV . . . . . . . . . . . . . . . . 30, 36
         ERASE . . . . . . . . . . . . . . . 75, 128
         Erasing . . . . . . . . . . . . . . 128
         ERR . . . . . . . . . . . . . . . . 91
         ERRCD . . . . . . . . . . . . . . . 56, 63
         ERRFL . . . . . . . . . . . . . . . 56, 63
         ERRLN . . . . . . . . . . . . . . . 56, 63
         ERRMSG  . . . . . . . . . . . . . . 56
         ERROR . . . . . . . . . . . . . . . 87, 196
         Errors
            file number  . . . . . . . . . . 56
            in command files . . . . . . . . 67
            line . . . . . . . . . . . . . . 56
            line number  . . . . . . . . . . 56
            message string . . . . . . . . . 56
            number . . . . . . . . . . . . . 56
            on files . . . . . . . . . . . . 122, 124, 130-131
            trapping . . . . . . . . . . . . 197
         ESCAPE  . . . . . . . . . . . . . . 87, 196
         Escapes . . . . . . . . . . . . . . 65
            trapping . . . . . . . . . . . . 197
         Exchange  . . . . . . . . . . . . . 82
         Exclusive or  . . . . . . . . . . . 36
         Executable file . . . . . . . . . . 117
         Execution . . . . . . . . . . . . . 3, 57, 94, 97-99
            interruption of  . . . . . . . . 64, 92, 103, 118
            pause  . . . . . . . . . . . . . 99
            program  . . . . . . . . . . . . 83
            resuming . . . . . . . . . . . . 97
            termination of . . . . . . . . . 74, 98
            tracing of . . . . . . . . . . . 120
         EXIT  . . . . . . . . . . . . . . . 75
            number of  . . . . . . . . . . . 47
         EXP . . . . . . . . . . . . . . . . 49
         Exponential functions . . . . . . . 49
         Exponentiation  . . . . . . . . . . 32
            matrix . . . . . . . . . . . . . 33
         Exponents
            in constants . . . . . . . . . . 16
         Extended IF . . . . . . . . . . . . 79-80
         Extension . . . . . . . . . . . . . 3, 21, 62
            in file nomen  . . . . . . . . . 21
         EXTERNAL  . . . . . . . . . . . . . 39, 43, 45, 189
         External procedures (see Procedures)  39

         F10 . . . . . . . . . . . . . . . . 41
         F40 . . . . . . . . . . . . . . . . 41, 43, 45, 189-191, 193
         False . . . . . . . . . . . . . . . 17
         Field . . . . . . . . . . . . . . . 139
         Field separator . . . . . . . . . . 139
         FILE  . . . . . . . . . . . . . . . 87, 196
         File extension (see Extension)  . . 3
         File names  . . . . . . . . . . . . 20, 96
         File nomen  . . . . . . . . . . . . 20, 90, 96
         Files . . . . . . . . . . . . . . . 93, 98, 122-136
            access methods . . . . . . . . . 125
            automatically generated  . . . . 202
            binary . . . . . . . . . . . . . 122-125, 128
            carriage returns . . . . . . . . 127-128, 134
            characteristics  . . . . . . . . 122
            closing  . . . . . . . . . . . . 94, 124
            copying  . . . . . . . . . . . . 71
            data representation  . . . . . . 123
            data unit  . . . . . . . . . . . 123
            eof  . . . . . . . . . . . . . . 122
            erasing  . . . . . . . . . . . . 128-129
            errors . . . . . . . . . . . . . 56
            file unit numbers  . . . . . . . 122, 196
            fixed-length-record  . . . . . . 125, 127, 129-130
            input  . . . . . . . . . . . . . 93
            location . . . . . . . . . . . . 56, 129-130, 135
            management . . . . . . . . . . . 122
            modes  . . . . . . . . . . . . . 124
            opening  . . . . . . . . . . . . 90, 124
            organization . . . . . . . . . . 124-125
            output . . . . . . . . . . . . . 122
            position . . . . . . . . . . . . 56, 126, 135
            random . . . . . . . . . . . . . 122
            random-access  . . . . . . . . . 125, 127, 129-136
            record boundaries  . . . . . . . 131-134
            sequential . . . . . . . . . . . 122, 125, 127
            size . . . . . . . . . . . . . . 135
            symbolic . . . . . . . . . . . . 122-123, 125
            temporary  . . . . . . . . . . . 202
            terminal . . . . . . . . . . . . 122, 127
            types  . . . . . . . . . . . . . 123
            variable-length-record . . . . . 125, 130, 134
         FIX . . . . . . . . . . . . . . . . 50
         Fixed-length-record . . . . . . . . 125-126, 129-130
            overflow . . . . . . . . . . . . 130-131
            use of IMAGE . . . . . . . . . . 132
            use of R format  . . . . . . . . 133-134
         Floating $  . . . . . . . . . . . . 161
         Floating *  . . . . . . . . . . . . 161
         Floating characters . . . . . . . . 158
         FOR . . . . . . . . . . . . . . . . 76
            in MAX, MIN, SUM, PROD . . . . . 51
            loop termination . . . . . . . . 85
            loops  . . . . . . . . . . . . . 76, 85
            modifier . . . . . . . . . . . . 100
            statement  . . . . . . . . . . . 76
              execution of . . . . . . . . . 76
         FORM  . . . . . . . . . . . . . . . 131, 137, 150
            use of / . . . . . . . . . . . . 127, 131
            use of R . . . . . . . . . . . . 127, 133
         Form feed
            in input lines . . . . . . . . . 109
         Format field  . . . . . . . . . . . 139
         Format fields . . . . . . . . . . . 150
         Format string . . . . . . . . . . . 137, 139
            rescan . . . . . . . . . . . . . 137
         Formatted I/O . . . . . . . . . . . 123
         Formatting  . . . . . . . . . . . . 137
         FORTRAN-10  . . . . . . . . . . . . 189-190, 193
         FORTRAN4  . . . . . . . . . . . . . 41
         FP  . . . . . . . . . . . . . . . . 50
         Fractional part . . . . . . . . . . 50
         Free-form . . . . . . . . . . . . . 137, 140
            in FORM formats  . . . . . . . . 137
            in IMAGE formats . . . . . . . . 137, 147
            input  . . . . . . . . . . . . . 72
            numeric output . . . . . . . . . 98
            output . . . . . . . . . . . . . 69, 84
            READ statement . . . . . . . . . 94
            terminal input . . . . . . . . . 80
         Functions . . . . . . . . . . . . . 189
         Functions (see Procedures)  . . . . 48

         GET . . . . . . . . . . . . . . . . 3, 60, 108
         Global procedures (see Procedures)  39
         Global Recompilation  . . . . . . . 60
         GO  . . . . . . . . . . . . . . . . 58, 64, 109
         GO files  . . . . . . . . . . . . . 117
         GOSUB . . . . . . . . . . . . . . . 39, 63, 78
            returns from . . . . . . . . . . 97
         GOTO  . . . . . . . . . . . . . . . 78
            on . . . . . . . . . . . . . . . 86

         H formatting character  . . . . . . 152
         Hexadecimal format  . . . . . . . . 160
         Hexadecimal notation  . . . . . . . 152
         Hyperbolic cosine . . . . . . . . . 48
         Hyperbolic sine . . . . . . . . . . 48
         Hyperbolic tangent  . . . . . . . . 48

         I/O
            in other language procedures . . 191
            in other-language procedures . . 41
         I/O channels  . . . . . . . . . . . 197
         I/O statements  . . . . . . . . . . 10
         Identifiers . . . . . . . . . . . . 18, 23
            number of  . . . . . . . . . . . 18
         Identity matrix . . . . . . . . . . 52
         IDN . . . . . . . . . . . . . . . . 52
         IF  . . . . . . . . . . . . . . . . 79
            extended . . . . . . . . . . . . 79-80
         IF modifier . . . . . . . . . . . . 79, 100
         IIF . . . . . . . . . . . . . . . . 80
         IIM . . . . . . . . . . . . . . . . 80
         IMAG  . . . . . . . . . . . . . . . 49
         IMAGE . . . . . . . . . . . . . . . 132, 137, 145
         Imaginary part  . . . . . . . . . . 49
         IMP . . . . . . . . . . . . . . . . 30, 36
         Inclusive or  . . . . . . . . . . . 36
         INDEX . . . . . . . . . . . . . . . 54
         Indirect statements (see Statements, indirect)  7
         INIT  . . . . . . . . . . . . . . . 109
         Initial values  . . . . . . . . . . 23, 63
         Initialization  . . . . . . . . . . 23, 63
         INITIALIZE  . . . . . . . . . . . . 58, 60, 64, 109
         INPUT . . . . . . . . . . . . . . . 67, 80-81, 122, 124
         Input
            array  . . . . . . . . . . . . . 85, 138
            data . . . . . . . . . . . . . . 94
            file . . . . . . . . . . . . . . 90
            terminal . . . . . . . . . . . . 92
         Input lists . . . . . . . . . . . . 68, 82, 128
         Input mode  . . . . . . . . . . . . 124
         INT . . . . . . . . . . . . . . . . 50
         INTEGER . . . . . . . . . . . . . . 24, 81
         Integer
            range of . . . . . . . . . . . . 14
         Integer part  . . . . . . . . . . . 50
         Intermediate code . . . . . . . . . 58, 114
         Internal compiler table . . . . . . 118
         Interrupting execution  . . . . . . 64, 92, 94, 103, 118
         Interrupts  . . . . . . . . . . . . 197
         Intraline editing . . . . . . . . . 175
         INV . . . . . . . . . . . . . . . . 28, 52
         Inverse . . . . . . . . . . . . . . 52
         Inverse of matrix . . . . . . . . . 52
         IO  . . . . . . . . . . . . . . . . 122
         IP  . . . . . . . . . . . . . . . . 50
         Iteration variable  . . . . . . . . 76
         IXASC . . . . . . . . . . . . . . . 29
         IXCHAR  . . . . . . . . . . . . . . 29

         J formatting character  . . . . . . 152
         Justification . . . . . . . . . . . 55, 152
            string . . . . . . . . . . . . . 55

         K formatting character  . . . . . . 152
         Keywords  . . . . . . . . . . . . . 18

         Largest . . . . . . . . . . . . . . 51
         LEFT  . . . . . . . . . . . . . . . 54
         Left shift  . . . . . . . . . . . . 53
         LENGTH  . . . . . . . . . . . . . . 54
         Length
            of string  . . . . . . . . . . . 54
         Length(s) . . . . . . . . . . . . . 55
         LET . . . . . . . . . . . . . . . . 82
         LGT . . . . . . . . . . . . . . . . 49
         Libraries . . . . . . . . . . . . . 3, 41
            TYMBASIC system  . . . . . . . . 63
            user's . . . . . . . . . . . . . 63
         LIBRARY . . . . . . . . . . . . . . 60, 110, 189
         Library list  . . . . . . . . . . . 4, 60
         Limits
            line length  . . . . . . . . . . 6
            statements . . . . . . . . . . . 7
         Line continuation . . . . . . . . . 6
         Line editing  . . . . . . . . . . . 175
         Line feeds  . . . . . . . . . . . . 6, 176, 183, 185-186
            in input lines . . . . . . . . . 109
            in terminal output . . . . . . . 138
            use of / . . . . . . . . . . . . 168
            use of \ . . . . . . . . . . . . 168
         Line length . . . . . . . . . . . . 6, 84
            terminal . . . . . . . . . . . . 6
         Line numbers  . . . . . . . . . . . 6-7, 107
            edit10 . . . . . . . . . . . . . 109
            range  . . . . . . . . . . . . . 7
         Line overflow . . . . . . . . . . . 182-184
         Line range  . . . . . . . . . . . . 103
         Line range list . . . . . . . . . . 103
         Line splitting  . . . . . . . . . . 181, 185
         Line termination  . . . . . . . . . 183, 185
         Line-oriented I/O . . . . . . . . . 145
         Lines
            deletion of  . . . . . . . . . . 105
            editing of . . . . . . . . . . . 107, 113
            renumbering  . . . . . . . . . . 115
         LIST  . . . . . . . . . . . . . . . 110
         LIST LIBRARIES  . . . . . . . . . . 60
         LIST LIBRARY  . . . . . . . . . . . 111
         LIST MODULE . . . . . . . . . . . . 111
         LIST MODULE[S]  . . . . . . . . . . 60
         LIST TRACE  . . . . . . . . . . . . 111
         Listings  . . . . . . . . . . . . . 105, 113
         Lists . . . . . . . . . . . . . . . 68
         Literal text  . . . . . . . . . . . 139
            in FORM formats  . . . . . . . . 138, 150, 164, 167-168
            in IMAGE formats . . . . . . . . 137, 145
            in image formats . . . . . . . . 148
         LJUST . . . . . . . . . . . . . . . 55
         LK
            protection code  . . . . . . . . 91
         Load/Initialize phase . . . . . . . 63
         Loading . . . . . . . . . . . . . . 3
         LOC . . . . . . . . . . . . . . . . 56
            example  . . . . . . . . . . . . 135
         Local procedures  . . . . . . . . . 46
         Local variables . . . . . . . . . . 46
         LOCATE  . . . . . . . . . . . . . . 83, 127
         Location  . . . . . . . . . . . . . 56, 126, 128, 130
            example  . . . . . . . . . . . . 135
            fixed-length-record  . . . . . . 129-130
            of records . . . . . . . . . . . 129
            setting  . . . . . . . . . . . . 129
         LOG . . . . . . . . . . . . . . . . 49, 83, 112
         LOG10 . . . . . . . . . . . . . . . 49
         Logarithm
            base 10  . . . . . . . . . . . . 49
            natural  . . . . . . . . . . . . 49
         Logging out . . . . . . . . . . . . 83
         LOGICAL . . . . . . . . . . . . . . 24, 83
         Logical
            definition . . . . . . . . . . . 14
            input  . . . . . . . . . . . . . 143
            output . . . . . . . . . . . . . 144
         Logical shift . . . . . . . . . . . 53
         Logical values  . . . . . . . . . . 83
         LOL . . . . . . . . . . . . . . . . 84, 141
         Lower bound . . . . . . . . . . . . 25
         Lower case  . . . . . . . . . . . . 18, 20
         LPAD  . . . . . . . . . . . . . . . 55
         LSH . . . . . . . . . . . . . . . . 53

         MACRO . . . . . . . . . . . . . . . 189, 194, 201
         Magnitude
            complex  . . . . . . . . . . . . 49-50
         Main program  . . . . . . . . . . . 3
         MAP . . . . . . . . . . . . . . . . 112
         MAT . . . . . . . . . . . . . . . . 84
         MATH  . . . . . . . . . . . . . . . 87, 196
         Math error trapping . . . . . . . . 197
         Matrices  . . . . . . . . . . . . . 15
            functions  . . . . . . . . . . . 52
            identity . . . . . . . . . . . . 52
            inversion  . . . . . . . . . . . 52
            singular . . . . . . . . . . . . 52
         Matrix operations . . . . . . . . . 33, 84
         MAX . . . . . . . . . . . . . . . . 51
         Maximum . . . . . . . . . . . . . . 51
         Memory allocation, internal . . . . 196
            ALLSP  . . . . . . . . . . . . . 196
            back pointer . . . . . . . . . . 196
            RELSP  . . . . . . . . . . . . . 197
         MERGE . . . . . . . . . . . . . . . 113
         Messages
            error  . . . . . . . . . . . . . 56
         MIN . . . . . . . . . . . . . . . . 51
         Minimum . . . . . . . . . . . . . . 51
         MOD . . . . . . . . . . . . . . . . 30
         Modifier range  . . . . . . . . . . 102
         MODIFY  . . . . . . . . . . . . . . 113
         MODULE  . . . . . . . . . . . . . . 60, 113, 189
         Module list . . . . . . . . . . . . 4, 59-61, 111, 118
         Modules
            definition . . . . . . . . . . . 3
            direct statement . . . . . . . . 62
            in a program . . . . . . . . . . 4
            in other directories . . . . . . 62
            name . . . . . . . . . . . . . . 3, 114
            other-language . . . . . . . . . 41, 117
            procedure calls across . . . . . 39
            relocatable  . . . . . . . . . . 3, 57, 62
            source . . . . . . . . . . . . . 3, 62
            startpoint . . . . . . . . . . . 4, 111, 116
            workspace (see Workspace)  . . . 59
         MUL . . . . . . . . . . . . . . . . 33
         Multiplication  . . . . . . . . . . 32
            matrix . . . . . . . . . . . . . 33

         NAME  . . . . . . . . . . . . . . . 25, 27, 85
         Name scope  . . . . . . . . . . . . 46
         Names . . . . . . . . . . . . . . . 18, 20
            of files . . . . . . . . . . . . 20
            of workspace (see workspace name)  3
            TYMBASIC global  . . . . . . . . 197
         Negative balances . . . . . . . . . 153
         Nesting
            I/O  . . . . . . . . . . . . . . 47
            procedures . . . . . . . . . . . 47
         NEXT  . . . . . . . . . . . . . . . 63, 76, 85
         NO  . . . . . . . . . . . . . . . . 86
            protection code  . . . . . . . . 91
         NO DEBUG  . . . . . . . . . . . . . 104, 113
         NO LIBRARY  . . . . . . . . . . . . 60
         NO MODULE . . . . . . . . . . . . . 60
         NO TRACE  . . . . . . . . . . . . . 120
         No-op . . . . . . . . . . . . . . . 182, 184
         NOT . . . . . . . . . . . . . . . . 30, 36
         NUL . . . . . . . . . . . . . . . . 123
         NUL characters  . . . . . . . . . . 138
         Numbers . . . . . . . . . . . . . . 14
         Numeric fields
            use of d . . . . . . . . . . . . 157
            use of y . . . . . . . . . . . . 157

         O formatting character  . . . . . . 152
         Octal format  . . . . . . . . . . . 160
         Octal notation  . . . . . . . . . . 152
         Old line  . . . . . . . . . . . . . 59, 106-107, 175
         ON condition processing . . . . . . 87, 89
         ON DIV BY ZER . . . . . . . . . . . 86
         ON ENDFILE  . . . . . . . . . . . . 89
         ON ERROR  . . . . . . . . . . . . . 89
         ON FILE . . . . . . . . . . . . . . 89
         ON-GOSUB  . . . . . . . . . . . . . 87
         ON-GOTO . . . . . . . . . . . . . . 86
         OPEN  . . . . . . . . . . . . . . . 80
            binary . . . . . . . . . . . . . 90
            input  . . . . . . . . . . . . . 90
            io . . . . . . . . . . . . . . . 90
            output . . . . . . . . . . . . . 90
            random . . . . . . . . . . . . . 90
            sequential . . . . . . . . . . . 90
            symbolic . . . . . . . . . . . . 90
         Opening files . . . . . . . . . . . 90
         OR  . . . . . . . . . . . . . . . . 30, 36
         ORIF  . . . . . . . . . . . . . . . 80
         Other-language procedures . . . . . 189
         Other-language procedures (see Procedures)  41
         OUTPUT  . . . . . . . . . . . . . . 122
         Output
            array  . . . . . . . . . . . . . 85, 138, 142
            file . . . . . . . . . . . . . . 90
            free-form  . . . . . . . . . . . 69, 84
            free-form numeric  . . . . . . . 98
            significance . . . . . . . . . . 98
            terminal . . . . . . . . . . . . 92-93, 138
         Output buffer
            terminal . . . . . . . . . . . . 71

         P formatting character  . . . . . . 153
         Padding
            string . . . . . . . . . . . . . 55
         Parameter vector  . . . . . . . . . 192
         Parameters  . . . . . . . . . . . . 44-46
            arrays . . . . . . . . . . . . . 44, 46-47
            declaration  . . . . . . . . . . 42-43
            for EXTERNAL procedures  . . . . 44
            number of  . . . . . . . . . . . 44
            string scalars . . . . . . . . . 47
            to fortran procedures  . . . . . 45
         Parser  . . . . . . . . . . . . . . 58, 114
         PAUSE . . . . . . . . . . . . . . . 65, 92
         PDIF  . . . . . . . . . . . . . . . 50
         PHASE . . . . . . . . . . . . . . . 49
         Phases  . . . . . . . . . . . . . . 57
         PI  . . . . . . . . . . . . . . . . 17
         PIF . . . . . . . . . . . . . . . . 92
         PIM . . . . . . . . . . . . . . . . 92
         PMC . . . . . . . . . . . . . . . . 58, 114
         POLAR . . . . . . . . . . . . . . . 49
         POS . . . . . . . . . . . . . . . . 56, 83, 127, 138
            example  . . . . . . . . . . . . 135
         Position  . . . . . . . . . . . . . 56, 126, 134
            example  . . . . . . . . . . . . 135
         Positive difference . . . . . . . . 50
         Power . . . . . . . . . . . . . . . 32-33
         PPN . . . . . . . . . . . . . . . . 20
         Precision
            for numeric types  . . . . . . . 14
         PRINT . . . . . . . . . . . . . . . 93
            terminal output  . . . . . . . . 93
         Print zones . . . . . . . . . . . . 137, 140
         Procedures  . . . . . . . . . . . . 39, 189
            alternate name . . . . . . . . . 41
            arguments  . . . . . . . . . . . 44
              array expressions  . . . . . . 45
              arrays . . . . . . . . . . . . 45-46
              call by name . . . . . . . . . 45-46
              call by value  . . . . . . . . 45
              constants  . . . . . . . . . . 45
              fortran  . . . . . . . . . . . 45
              number of  . . . . . . . . . . 44
              string expressions . . . . . . 45
              to fortran procedures  . . . . 45
              type conversion  . . . . . . . 45
            array-valued . . . . . . . . . . 43
            branches into  . . . . . . . . . 47
            call by reference  . . . . . . . 44
            calls to . . . . . . . . . . . . 70
            calls to nested procedures . . . 47
            COBOL  . . . . . . . . . . . . . 41
            context  . . . . . . . . . . . . 46
            declaration  . . . . . . . . . . 39, 42
              AKA clause . . . . . . . . . . 41
              semantics  . . . . . . . . . . 43
              syntax . . . . . . . . . . . . 42
            end of . . . . . . . . . . . . . 74
            entry  . . . . . . . . . . . . . 39
            exiting  . . . . . . . . . . . . 47
            external . . . . . . . . . . . . 39, 189, 196
            global . . . . . . . . . . . . . 39
              names  . . . . . . . . . . . . 41
              other-language . . . . . . . . 41
            I/O  . . . . . . . . . . . . . . 47
            local  . . . . . . . . . . . . . 46
            name . . . . . . . . . . . . . . 43
            nested . . . . . . . . . . . . . 46
            nesting  . . . . . . . . . . . . 47
            number of  . . . . . . . . . . . 42
            other-language . . . . . . . . . 41, 43
              I/O within . . . . . . . . . . 41
            passing arguments  . . . . . . . 44
            returning  . . . . . . . . . . . 47
            single-line  . . . . . . . . . . 47
              declaration  . . . . . . . . . 42
            system-defined . . . . . . . . . 48
            user-defined . . . . . . . . . . 72
            value  . . . . . . . . . . . . . 47
         PROD  . . . . . . . . . . . . . . . 51
         Program activation characters . . . 128
         Program control commands  . . . . . 12
         Program control statements  . . . . 10
         Program modification  . . . . . . . 65
         Programs  . . . . . . . . . . . . . 4, 57
            binary . . . . . . . . . . . . . 117
            end of . . . . . . . . . . . . . 64
            execution  . . . . . . . . . . . 83, 109, 118, 120
            GO files . . . . . . . . . . . . 117
              running  . . . . . . . . . . . 28
            saving . . . . . . . . . . . . . 117
            sharable . . . . . . . . . . . . 117
            workspace (see Workspace)  . . . 108
         Prompting . . . . . . . . . . . . . 184
         PROTECTION  . . . . . . . . . . . . 92
         Punctuation
            in free-form output  . . . . . . 140
         PWR . . . . . . . . . . . . . . . . 31, 33

         Q formatting character  . . . . . . 153
         QUIT  . . . . . . . . . . . . . . . 94, 115
         Quotation marks
            in FORM formats  . . . . . . . . 138, 150
            with file nomens . . . . . . . . 22
            with free-form string input  . . 140
            with ! . . . . . . . . . . . . . 6

         R format  . . . . . . . . . . . . . 127, 133-134
         R formatting character  . . . . . . 153
         Random files (see Random-access files)  122
         Random number function  . . . . . . 56, 63
         Random-access files . . . . . . . . 125, 127-128, 130-136
            carriage returns . . . . . . . . 127
            example  . . . . . . . . . . . . 135
            fixed-length-record  . . . . . . 130
            location . . . . . . . . . . . . 129, 135
            position . . . . . . . . . . . . 83, 126, 135
            record boundaries  . . . . . . . 130-134
            record length  . . . . . . . . . 130
            size . . . . . . . . . . . . . . 135
         Random-access operations  . . . . . 128
         RCY . . . . . . . . . . . . . . . . 53
         RD
            protection code  . . . . . . . . 91
         RDL file  . . . . . . . . . . . . . 3, 59, 61-62, 202
         READ  . . . . . . . . . . . . . . . 94, 137
         Read statement
            data for . . . . . . . . . . . . 72
         REAL  . . . . . . . . . . . . . . . 24, 49-50, 95
         Real
            range of . . . . . . . . . . . . 14
         Real part . . . . . . . . . . . . . 49
         Record boundaries . . . . . . . . . 130-131
            crossing . . . . . . . . . . . . 131
         Record I/O  . . . . . . . . . . . . 145
         Record length . . . . . . . . . . . 130
         Recursive . . . . . . . . . . . . . 39
         References  . . . . . . . . . . . . 106
         REL file  . . . . . . . . . . . . . 3, 59, 61-62, 110, 189, 202
         Relocatable files . . . . . . . . . 57, 202
         REM . . . . . . . . . . . . . . . . 6, 95
         REMARK  . . . . . . . . . . . . . . 6
         Remarks . . . . . . . . . . . . . . 6
         REMOVE  . . . . . . . . . . . . . . 95
         RENAME  . . . . . . . . . . . . . . 96
         RENUMBER  . . . . . . . . . . . . . 115
         Repeat  . . . . . . . . . . . . . . 55
         Repetition
            in FORM formats  . . . . . . . . 165
         Replication
            in FORM formats  . . . . . . . . 165
         Rescan
            in FORM formats  . . . . . . . . 167
         Reserved functions (see Procedures, system-defined)  48
         Reserved words  . . . . . . . . . . 18
         RESTORE . . . . . . . . . . . . . . 96
         RESUME  . . . . . . . . . . . . . . 97
         Resuming execution  . . . . . . . . 97
         RETURN  . . . . . . . . . . . . . . 97
         RIGHT . . . . . . . . . . . . . . . 54
         Right shift . . . . . . . . . . . . 53
         RJUST . . . . . . . . . . . . . . . 55
         RND . . . . . . . . . . . . . . . . 56
         Rnd . . . . . . . . . . . . . . . . 63
         ROUN  . . . . . . . . . . . . . . . 50
         Rounding  . . . . . . . . . . . . . 15, 50, 138
         RPAD  . . . . . . . . . . . . . . . 55
         RPT . . . . . . . . . . . . . . . . 55
         RSH . . . . . . . . . . . . . . . . 53
         RUN . . . . . . . . . . . . . . . . 58, 60, 116
         Run . . . . . . . . . . . . . . . . 60
         RUN
            protection code  . . . . . . . . 91
         Run phase . . . . . . . . . . . . . 57, 128

         S formatting character  . . . . . . 153
         SAVE  . . . . . . . . . . . . . . . 3, 7, 60, 116-117
         SAVE BINARY . . . . . . . . . . . . 28, 58, 60, 202
         Saving the workspace (see Workspace, saving)  3
         Scalars . . . . . . . . . . . . . . 28
            definition . . . . . . . . . . . 15
         Scope . . . . . . . . . . . . . . . 46
            of implicitly declared variable  25
         Semicolon . . . . . . . . . . . . . 137, 140
         SEQUENTIAL  . . . . . . . . . . . . 90, 92
         Sequential files  . . . . . . . . . 125
         SFO . . . . . . . . . . . . . . . . 43, 45, 191, 193
         SFORTRAN  . . . . . . . . . . . . . 189-191, 193
         SGN . . . . . . . . . . . . . . . . 50
         Shift
            arithmetic . . . . . . . . . . . 53
            circular . . . . . . . . . . . . 53
            left . . . . . . . . . . . . . . 53
            logical  . . . . . . . . . . . . 53
            right  . . . . . . . . . . . . . 53
         Shifting functions  . . . . . . . . 53
         SHR file  . . . . . . . . . . . . . 117
         Sign  . . . . . . . . . . . . . . . 50
         Sign formatting characters  . . . . 163
         SIGNIFICANCE  . . . . . . . . . . . 63, 98
         Significance
            in numeric output  . . . . . . . 138, 144
         Significant digits  . . . . . . . . 138
         SIMPL . . . . . . . . . . . . . . . 41, 43, 45, 189, 194, 201
         SIN . . . . . . . . . . . . . . . . 48
         Sine  . . . . . . . . . . . . . . . 48
         Single escape . . . . . . . . . . . 65
         SINH  . . . . . . . . . . . . . . . 48
         SIXBIT  . . . . . . . . . . . . . . 41
         SIZE  . . . . . . . . . . . . . . . 56, 124, 128
         Size
            array  . . . . . . . . . . . . . 24
         SIZE
            example  . . . . . . . . . . . . 135
         Smallest  . . . . . . . . . . . . . 51
         Source modification . . . . . . . . 65
         SPACE . . . . . . . . . . . . . . . 54
         Space
            as field separator . . . . . . . 163
         Spaces
            in free-form input . . . . . . . 140
            in terminal output . . . . . . . 138
            leading  . . . . . . . . . . . . 140
         SQR . . . . . . . . . . . . . . . . 49
         SQRT  . . . . . . . . . . . . . . . 49
         Square root . . . . . . . . . . . . 49
         START . . . . . . . . . . . . . . . 58, 63, 117
         START.POINT . . . . . . . . . . . . 28
         Starting point  . . . . . . . . . . 4
         STARTPOINT  . . . . . . . . . . . . 4, 118
         Startpoint module (see Modules, startpoint)  4
         Statement modifiers . . . . . . . . 8, 79, 100
         Statements  . . . . . . . . . . . . 6
            array manipulation . . . . . . . 11
            by group . . . . . . . . . . . . 9
            direct . . . . . . . . . . . . . 8-9, 62-65
            format . . . . . . . . . . . . . 6
            I/O  . . . . . . . . . . . . . . 10
            indirect . . . . . . . . . . . . 7, 9
            length . . . . . . . . . . . . . 6
            limits . . . . . . . . . . . . . 7
            order  . . . . . . . . . . . . . 7
            program control  . . . . . . . . 10
            subprogram . . . . . . . . . . . 11
            types  . . . . . . . . . . . . . 9
            utility  . . . . . . . . . . . . 11
            variable declaration . . . . . . 11
         Static $  . . . . . . . . . . . . . 161
         Static *  . . . . . . . . . . . . . 161
         STEP  . . . . . . . . . . . . . . . 58, 64, 118
         STOP  . . . . . . . . . . . . . . . 64, 98
         Storing . . . . . . . . . . . . . . 116-117
         STR . . . . . . . . . . . . . . . . 54, 137
         STRING  . . . . . . . . . . . . . . 24, 99, 189, 194
         String padding  . . . . . . . . . . 55
         Strings . . . . . . . . . . . . . . 14, 123
            assignment . . . . . . . . . . . 82
            comparisons  . . . . . . . . . . 37
            concatenation  . . . . . . . . . 51
            definition . . . . . . . . . . . 14
            expressions  . . . . . . . . . . 37
            functions  . . . . . . . . . . . 54
            input  . . . . . . . . . . . . . 153
            maximum length . . . . . . . . . 73, 82
            searching  . . . . . . . . . . . 54-55
            string body  . . . . . . . . . . 189
            string descriptor  . . . . . . . 189, 192, 194
            system-defined functions . . . . 54
            values . . . . . . . . . . . . . 99
         Subarrays . . . . . . . . . . . . . 25, 199
            @  . . . . . . . . . . . . . . . 38
            apparent dimensions  . . . . . . 199
            as parent arrays . . . . . . . . 25
            bounds . . . . . . . . . . . . . 26-27
            descriptor . . . . . . . . . . . 199
            dimension map  . . . . . . . . . 199
            dimensions . . . . . . . . . . . 26-27
            elements . . . . . . . . . . . . 25, 27
            hidden dimensions  . . . . . . . 199
            named  . . . . . . . . . . . . . 25, 27
            parent array . . . . . . . . . . 199
            subscripts . . . . . . . . . . . 26
            syntax . . . . . . . . . . . . . 26
         Subfield  . . . . . . . . . . . . . 156
         Subprogram statements . . . . . . . 11
         Subroutines . . . . . . . . . . . . 39, 87
            arguments  . . . . . . . . . . . 70
            calls to . . . . . . . . . . . . 70
         Subscripts (see Arrays,subscripts)  15
         SUBSTR  . . . . . . . . . . . . . . 54
         Substring . . . . . . . . . . . . . 54
         Subtraction . . . . . . . . . . . . 32
         SUM . . . . . . . . . . . . . . . . 51
         SUPERFORTRAN  . . . . . . . . . . . 41
         Supersede mode  . . . . . . . . . . 122
         SYMBOLIC  . . . . . . . . . . . . . 92
         Symbolic files  . . . . . . . . . . 122
         Symbolic I/O  . . . . . . . . . . . 123
         SYMD  . . . . . . . . . . . . . . . 118
         System-defined procedures (see Procedures, system-defined)  48
         System-defined variables (see Variables)  23
         System/user interaction . . . . . . 57

         TAB . . . . . . . . . . . . . . . . 56
         Tab stops . . . . . . . . . . . . . 119
         TABS  . . . . . . . . . . . . . . . 119
         TAN . . . . . . . . . . . . . . . . 48
         Tangent . . . . . . . . . . . . . . 48
         TANH  . . . . . . . . . . . . . . . 48
         TBA . . . . . . . . . . . . . . . . 6, 43, 45
         TCP . . . . . . . . . . . . . . . . 56
         TERM  . . . . . . . . . . . . . . . 56
         TERM 
            in COPY statement  . . . . . . . 71
            in OPEN statement  . . . . . . . 90
            system-defined function  . . . . 73
         Terminal
            as a file  . . . . . . . . . . . 122, 127
            clearing output buffer . . . . . 71
            line length  . . . . . . . . . . 6
            output buffer  . . . . . . . . . 71
            print position . . . . . . . . . 56
         Terminal characteristics  . . . . . 84
         Terminal input  . . . . . . . . . . 56, 73, 92
            eight-level  . . . . . . . . . . 73
            free-form  . . . . . . . . . . . 80
         Terminal output . . . . . . . . . . 74, 92-93, 120, 138
            eight-level  . . . . . . . . . . 74
            PRINT  . . . . . . . . . . . . . 93
            suppression of trailing spaces . 93, 138
         Terminal output buffer  . . . . . . 71
         Termination
            execution  . . . . . . . . . . . 64, 74, 98
            FOR loops  . . . . . . . . . . . 85
            line . . . . . . . . . . . . . . 183, 185
         Testing for end of file . . . . . . 122
         Text  . . . . . . . . . . . . . . . 68, 95
         Text insertion  . . . . . . . . . . 183-184
         THEN clause
            in IF statement  . . . . . . . . 79
         TIE . . . . . . . . . . . . . . . . 175
         TIME  . . . . . . . . . . . . . . . 56
         Time of day . . . . . . . . . . . . 56
         TOF . . . . . . . . . . . . . . . . 109, 119
         TOUT  . . . . . . . . . . . . . . . 120
         TOUT destination  . . . . . . . . . 120
         TOUT files  . . . . . . . . . . . . 63, 66, 90
         TRACE . . . . . . . . . . . . . . . 104, 120
         Trace
            program execution  . . . . . . . 120
         Trailing spaces . . . . . . . . . . 93, 138
         TRANSFORM . . . . . . . . . . . . . 87, 196
         Transpose of matrix . . . . . . . . 52
         Trapping error conditions . . . . . 89
         Trigonometric functions . . . . . . 48
         TRN . . . . . . . . . . . . . . . . 52
         TRU . . . . . . . . . . . . . . . . 56
         True  . . . . . . . . . . . . . . . 17
         Truncation  . . . . . . . . . . . . 50
            in I/O . . . . . . . . . . . . . 145
            string . . . . . . . . . . . . . 54, 82
         TYMBASIC  . . . . . . . . . . . . . 41
         TYMBASIC calling sequence . . . . . 192
         TYMBASIC keywords . . . . . . . . . 18
         Tymbasic system library . . . . . . 63
         Tymshare editor . . . . . . . . . . 175, 184
         Type, file  . . . . . . . . . . . . 123
         Types
            conversion
              in expressions . . . . . . . . 31
            data . . . . . . . . . . . . . . 14
            declaration  . . . . . . . . . . 24
            default  . . . . . . . . . . . . 24
            default for identifiers  . . . . 19
            initial value  . . . . . . . . . 23
            order of . . . . . . . . . . . . 31
            variables  . . . . . . . . . . . 23

         U formatting character  . . . . . . 154
         Unit number (see Files, file unit number)  122
         UNLESS modifier . . . . . . . . . . 101
         UNTIL modifier  . . . . . . . . . . 101
         UPD
            protection code  . . . . . . . . 91
         Update mode . . . . . . . . . . . . 122
         Upper bound . . . . . . . . . . . . 25
         User directory  . . . . . . . . . . 20
         User files (see Files)  . . . . . . 122
         User name . . . . . . . . . . . . . 20
         User-defined procedures (see Procedures)  72
         Utility commands  . . . . . . . . . 13
         Utility functions . . . . . . . . . 56
         Utility statements  . . . . . . . . 11
         UUO'S . . . . . . . . . . . . . . . 196

         V formatting character  . . . . . . 154
         VAL . . . . . . . . . . . . . . . . 54, 137
         Valid data  . . . . . . . . . . . . 63-64
         Variable-length-record  . . . . . . 125-127, 130, 134
            use of R format  . . . . . . . . 134
         Variable/dimension list . . . . . . 24
         Variable/dimension lists  . . . . . 68
         Variables . . . . . . . . . . . . . 23
            array element  . . . . . . . . . 23
            array manipulation statements  . 11
            arrays . . . . . . . . . . . . . 23
            class  . . . . . . . . . . . . . 23
            declaration (see Declaration)  . 23
            declaration statements . . . . . 11
            default type . . . . . . . . . . 24
            dimensionality . . . . . . . . . 23-24
            initial value  . . . . . . . . . 23
            initialization . . . . . . . . . 57
            local  . . . . . . . . . . . . . 46-47
            manipulation statements  . . . . 11
            names  . . . . . . . . . . . . . 20
            simple . . . . . . . . . . . . . 23
            subarray . . . . . . . . . . . . 23
            system-defined . . . . . . . . . 23
              ASCTABLE . . . . . . . . . . . 28
              CHARTABLE  . . . . . . . . . . 28
              EPS  . . . . . . . . . . . . . 28
              START.POINT  . . . . . . . . . 28
            type . . . . . . . . . . . . . . 23
            user-defined . . . . . . . . . . 23
         Vectors . . . . . . . . . . . . . . 15
         VERSION . . . . . . . . . . . . . . 121

         W formatting character  . . . . . . 154
         WAIT  . . . . . . . . . . . . . . . 99
         Warnings  . . . . . . . . . . . . . 67
         WHERE modifier  . . . . . . . . . . 101
         WHILE modifier  . . . . . . . . . . 102
         WITH PROTECTION . . . . . . . . . . 90
         Workspace . . . . . . . . . . . . . 4, 7, 59-61
            definition . . . . . . . . . . . 3
            deletion of lines  . . . . . . . 105
            module . . . . . . . . . . . . . 58-59, 65, 111
            moving program into  . . . . . . 108
            name . . . . . . . . . . . . . . 3, 59, 61, 113, 116, 118
            saving . . . . . . . . . . . . . 7, 116
         WRITE . . . . . . . . . . . . . . . 99

         X formatting character  . . . . . . 154
         XASC  . . . . . . . . . . . . . . . 29
         XCHAR . . . . . . . . . . . . . . . 29
         XEXEC . . . . . . . . . . . . . . . 6, 64, 94
         XOR . . . . . . . . . . . . . . . . 30, 36

         Y formatting character  . . . . . . 155-156
         YEAR  . . . . . . . . . . . . . . . 56

         Z formatting character  . . . . . . 155
         ZER . . . . . . . . . . . . . . . . 52
         Zones
            in print lines (see Print zones)  137

         #=  . . . . . . . . . . . . . . . . 35
         <=  . . . . . . . . . . . . . . . . 35
         <=  . . . . . . . . . . . . . . . . 37
         \ . . . . . . . . . . . . . . . . . 168
         \ formatting character  . . . . . . 164
         . formatting character  . . . . . . 154
         & . . . . . . . . . . . . . . . . . 71
         & . . . . . . . . . . . . . . . . . 66
         >=  . . . . . . . . . . . . . . . . 37
         # . . . . . . . . . . . . . . . . . 37
         < . . . . . . . . . . . . . . . . . 37
         > . . . . . . . . . . . . . . . . . 37
         >=  . . . . . . . . . . . . . . . . 35
         <<  . . . . . . . . . . . . . . . . 35
         >>  . . . . . . . . . . . . . . . . 35
         # . . . . . . . . . . . . . . . . . 35
         > . . . . . . . . . . . . . . . . . 35
         < . . . . . . . . . . . . . . . . . 35
         ^ . . . . . . . . . . . . . . . . . 32
         # . . . . . . . . . . . . . . . . . 30
         < . . . . . . . . . . . . . . . . . 30
         > . . . . . . . . . . . . . . . . . 30
         ^ . . . . . . . . . . . . . . . . . 30
         & . . . . . . . . . . . . . . . . . 6

 W 
