SUBTTL	TBA SORT   OUTER MODULE
TITLE	TBASRT	TBA SORT

	TWOSEG
	RELOC	400000


;SORT ROUTINES USED:

	EXTERNAL PSORT.,MERGE.,RELES.,RETRN.,ENDS.

	INTERN RECSIZ,RECLOC,KEYCV.,SBFRDY
	EXTERNAL RETLEN

;MISCELLANEOUS ROUTINES USED

	EXTERNAL GD7.,KEY.
;ENTRY TO SORT FROM TBA

        TBADCL  SORT,<<INFIL,2>,<OUTFIL,2>,<KEYS,2>>
	MOVE	TA,[XWD DSCR,DSCR+1]	;CLEAR DESCRIPTORS
	SETZM	DSCR
	BLT	TA,DSCR+4
	SETZM	OFPTR
	SETZM	IFPTR

	MOVE	1,[POINT 7,0]	;SET UP POINTER TO COMMAND STRING
	ADD	1,KEYS
	MOVEM	1,KEYSPT
	JSP	TA,RESET

	SETZ	SW	;CLEAR ALL FLAGS

	PUSHJ	PP,GETKAR	;GET A COMMAND CHARACTER
	CAIN	CH,0		;IF NULL STRING,
	JRST	TBARTN		;  EXIT

	MOVE	TA,[XWD LOLOW,LOLOW+1]; CLEAR SOME IMPURE AREA
	SETZM	LOLOW
	BLT	TA,HILOW
	MOVEI	TA,1
	MOVEM	TA,KEYSZ
	MOVEI	KP,KEYDEF	;MOVE KEY POINTER TO START OF TABLE

	PUSHJ	PP,COMSTR	;  COMMAND STRING
	CAIE	CH,0		;ILLEGAL IF TERMINATED WITH
	JRST	BADIDL		;[6] OTHER THAN <CR>
;MAKE SURE WE HAVE A RECORD SIZE

	SKIPE	RECSIZ		;ANY SIZE?
	JRST	START4		;YES--OK

	MOVEI	TA,^D80		;DEFAULT RECORD SIZE
	MOVEM	TA,RECSIZ	;  80 CHARACTERS

;CHECK KEYS

START4:	PUSHJ	PP,SCNKEY

	TRNE	SW,COMERA	;ANY ERRORS?
	ERROR	SRTERR

;SET UP RECORD AREAS

	MOVE	TA,RECSIZ
	MOVEI	TC,5
	IDIVI	TA,(TC)
	SKIPE	TA+1
	ADDI	TA,1
	MOVEM	TA,RECWDS

	AOJ	TA,		;ONE EXTRA WORD (SEE OPROC1)
	CALL	ALLSP##,<$,TA,DSCR,0>
	ADD	2,[POINT 7,0]
	MOVEM 2,RECLOC

;SET ASIDE AREA FOR KEYS

	MOVE	TA,KEYWRK
	HRLM	TA,CALLST+1
	CALL	ALLSP##,<$,TA,DSCR+1,0>
	MOVEM	2,KEYWRK
	MOVSM	2,CALLST+2

;BUILD KEYS

	CALL	ALLSP##,<$,KEYSZ,DSCR+2,0>
	MOVEM	2,CKEYLC
	HRRM	2,CALLST+2
	PUSHJ	PP,KEYBLD
SUBTTL THE SORT PROCESS

	PUSH	PP,SW		;SAVE SWITCHES
	PUSHJ	PP,CALLST	;CALL PSORT.

INPROC:	MOVE	TA,OUTFIL	;SAVE FILE NAME LOCATION
	MOVEM	TA,FNASCI	;IN CASE OF ERROR
	LNDRY	@OUTFIL,DEFEXT
	SKIPLE	1
	JRST	FLERRL
	MOVEM	2,FNSXBT
	SETZM	TERMFL
	JUMPE	1,.+3
	AOS	TERMFL		;SET TERMINAL OUTPUT FLAG
	JRST	IP1

	OPEN	@FNSXBT,,SUPERSEDE,,<RZ,CN,SQ>
	SKIPE	1
	JRST	FLERRO
	MOVEM	2,OFPTR
	READCR	OFPTR,7

IP1:	MOVE	TA,INFIL
	MOVEM	TA,FNASCI
	LNDRY	@INFIL,DEFEXT,<NO.TER>
        SKIPE   1
        JRST    FLERRL
	MOVEM	2,FNSXBT
	OPEN	@FNSXBT,STD,READ,,<RZ,SQ>
        SKIPE   1
        JRST    FLERRO
	MOVEM	2,IFPTR
	READCR	IFPTR,7

	SETZM	ICOUNT		;CLEAR INPUT RECORD COUNTER

IPROC1:	SETZM	RELEN.		;[322]CLEAR RECORD SIZE
	CALL	INPLIN##,<IFPTR,$,RECLOC,$,RECSIZ>
	JUMPN	1,IPROC4
	ADDI	0,4
	IDIVI	0,5
	MOVEM	0,RELEN.
	AOS	ICOUNT		;NOT AT END: BUMP COUNT

	MOVE	DP,RELEN.		;[7]ACTUAL LEN OF REC IN WRDS
	CAMLE	DP,RECWDS	;[7] CHECK IT
	MOVE	DP,RECWDS	;[7]
	PUSHJ	PP,RELES.	;  RECORD
	JRST	IPROC1		;LOOP
IPROC4:	FREECR	IFPTR
	CALL	CLOSEF##,<$,IFPTR>
	SETZM	IFPTR

	PUSHJ	PP,MERGE.	;MERGE SCRATCH FILES

OTPROC:	SETZM	OCOUNT		;CLEAR OUTPUT RECORD COUNTER

OPROC1:	PUSHJ	PP,RETRN.	;RETURN A RECORD
	AOSA	OCOUNT		;NOT AT END: BUMP COUNTER
	JRST	OPROC4		;AT END

	SKIPE	TERMFL		;OUTPUT TO TERMINAL?
	JRST	TEROUT		;YES--GO DO IT.
	MOVE	TB,RETLEN	;[7]GET NUMBER OF WORDS RETURND
	IMULI	TB,5		;[7]CONVERT TO CHARS
	CAMLE	TB,RECSIZ	;[7]IF > RECSIZE (SINCE DOING TO WORD)
	MOVE	TB,RECSIZ	;[7]JUST DO TO RECORD SIZE
	CALL	OUTLIN##,<OFPTR,$,RECLOC>
	JRST	OPROC1		;LOOP

TEROUT:	HRRZ	TA,RECLOC
	HRRZ	TB,TA
	ADD	TB,RETLEN
	SETZM	(TB)		;MAKE SURE STRING IS ASCIZ
	CALL	TDO##,<$,TA,2>
	CALL	TDO,<DEFEXT,1>		;EMPTY STRING WITH CRLF
	JRST	OPROC1
OPROC4:	SKIPE	TERMFL
	JRST	OP1
	WRITCR	OFPTR
	CALL	CLOSEF##,<$,OFPTR>
	SETZM	OFPTR

OP1:	MOVE	TA,ICOUNT	;BE SURE
	CAME	TA,OCOUNT	;  COUNTS AGREE
	JRST	BADCNT		;OOPS!!

OPROC5:	POP	PP,SW		;GET SWITCH REGISTER BACK
	JRST	TBARTN		;  EXIT TO TBA
SUBTTL SCAN COMMAND FOR ONE DESCRIPTOR

COMSTR:	CAIN	CH,"/"		;SWITCH COMING UP?
	JRST	COMS12
	CAIN	CH,0		;  LEGAL TERMINATOR?
	POPJ	PP,		;YES

COMS9:	MOVEI	0,[ASCIZ/Improper SORT command string/]

	JRST	KILL.
;"/" SEEN -- PROCESS SWITCH

COMS12:	PUSHJ	PP,GETKAR	;GET SWITCH LETTER
	CAIN	CH,"K"
	JRST	KSWICH
	CAIN	CH,"R"
	JRST	RSWICH

	PUSH	PP,CH
	SETZ	0,		;SO KILL. WILL RETURN
	PUSHJ	PP,KILL.
	MOVEI	0,[ASCIZ/'/]
	CALL	CXER3##
	POP	PP,CH
	CALL	ERRCH,<$,CH>
	MOVEI	0,[ASCIZ/' is not a valid switch/]
	CALL	CXER1##
	ERROR	SRTERR
;"R" SWITCH
;GET RECORD SIZE

RSWICH:	PUSHJ	PP,GETDEC	;GET DECIMAL NUMBER
	JUMPE	TA,RSWCH2
	CAILE	TA,^D4095
	JRST	RSWCH3		;TOO LARGE
	SKIPE	RECSIZ		;RECORD SIZE PREVIOUSLY SPECIFIED?
	JRST	RSWCH1		;YES--ERROR MAYBE
	MOVEM	TA,RECSIZ	;NO--STASH THIS ONE
	JRST	ENDSW

RSWCH1:	CAMN	TA,RECSIZ	;IS THIS SIZE SAME AS BEFORE?
	JRST	ENDSW		;YES--OK
	MOVEI	0,[ASCIZ"Only one /R allowed"]
	JRST	KILL.

RSWCH2:	MOVEI	0,[ASCIZ/Record size must be greater than zero/]
	JRST	KILL.

RSWCH3:	MOVEI	0,[ASCIZ/Record size must be less than 4095/]
	JRST	KILL.
;"K" SWITCH
;SET UP A KEY ENTRY

KSWICH:	CAIN	KP,ENDKEY	;ANY ROOM FOR KEY?
	JRST	KSWCH9		;NO

	PUSHJ	PP,GETKAR	;GET S, U OR X
	MOVEI	TA,0
	CAIN	CH,"S"
	MOVEI	TA,SIGNED
	CAIN	CH,"U"
	MOVEI	TA,UNSIGN
	JUMPE	TA,KSWCH1

	MOVSM	TA,KTYPE(KP)	;STASH TYPE

	CAIN	TA,ALPHA	;WAS IT ALPHA?
	JRST	KSWCH2		;YES--THEREFORE NOT NUMERIC

	PUSHJ	PP,GETKAR	;GET N OR X
	MOVEI	TA,0
KSWCH1:	CAIN	CH,"N"
	MOVEI	TA,DISPLY
	CAIN	CH,"X"
	MOVEI	TA,ALPHA
	JUMPN	TA,KSWC1B

	MOVEI	TA,ALPHA
	SKIPE	KTYPE(KP)
	MOVEI	TA,DISPLY
	IORI	SW,REGET

KSWC1B:	HRRM	TA,KTYPE(KP)	;STASH NUMERIC TYPE

KSWCH2:	PUSHJ	PP,GETKAR	;GET D OR A
	CAIN	CH,"A"
	JRST	KSWCH4
	MOVSI	TA,1B18
	CAIE	CH,"D"
	JRST	KSWCH3
	IORM	TA,KTYPE(KP)
	JRST	KSWCH4

KSWCH3:	CAIG	CH,"9"		;IS IT A DIGIT?
	CAIGE	CH,"0"
	JRST	KSWCHE		;NO--ERROR
	IORI	SW,REGET	;YES--SET 'REGET COMMAND CHARACTER'
;"K" SWITCH (CONT'D)

KSWCH4:	PUSHJ	PP,GETDEC	;GET LOW BYTE POSITION
	MOVEM	TA,LOWBYT(KP)

	CAIE	CH,"."		;IS SEPERATOR "."?
	JRST	KSWCHE		;NO--ERROR

KSWCH5:	PUSHJ	PP,GETDEC	;GET KEY SIZE
	MOVEM	TA,KEYSIZ(KP)
	ADDI	KP,KEYENT
	SOS	NUMKEY
	JRST	KSWCH7

KSWCH7:	CAIN	CH,","
	JRST	KSWICH
	JRST	ENDSW

KSWCH9:	MOVEI	0,[ASCIZ/Too many keys/]
	JRST	KILL.

KSWCHE:	MOVEI	0,[ASCIZ"Improper /K"]
	JRST	KILL.


;TERMINATE SWITCH LOGIC

ENDSW:	MOVEI	TA,0		;CLEAR TA
	JRST	COMSTR
;GET A DECIMAL NUMBER FROM COMMAND STRING

GETDEC:	MOVEI	TA,0		;CLEAR RESULT

GTDEC1:	PUSHJ	PP,GETKAR	;SKIP
	CAIN	CH," "		;  PAST
	JRST	GTDEC1		;  SPACES

GTDEC2:	CAIG	CH,"9"		;DIGIT?
	CAIGE	CH,"0"
	POPJ	PP,		;NO--RETURN

	IMULI	TA,^D10		;YES--ADD
	ADDI	TA,-"0"(CH)	;  TO RESULT
	PUSHJ	PP,GETKAR	;GET NEXT CHARACTER
	JRST	GTDEC2		;LOOP

;GET CHARACTER FROM COMMAND STRING

GETKAR:	TRZE	SW,REGET
	JRST	GTKR10

	ILDB	CH,KEYSPT
	CAIGE	CH,"a"		;IF lower case, CONVERT TO UPPER CASE
	JRST	.+3
	CAIG	CH,"z"
	SUBI	CH,40
	MOVEM	CH,COMKAR
	POPJ	PP,

GTKR10:	MOVE	CH,COMKAR
	POPJ	PP,
SUBTTL BUILD 'KEY SETUP' ROUTINE

KEYBLD:	MOVEI	KP,KEYDEF	;INITIALIZE
	HRL	KP,NUMKEY	;  KP
	MOVE	TA,KEYWRK	;  AND
	MOVEM	TA,KEYLOC	;  KEYLOC

KEYB1:	HRRZ	TA,KTYPE(KP)	;GET KEY TYPE
	CAILE	TA,NTYPES	;IF FUNNY,
	MOVEI	TA,0		;  RESET
	PUSHJ	PP,@KEYB2(TA)	;GO TO ONE OF THE ROUTINES

	ADDI	KP,KEYENT-1	;BUMP TO
	AOBJN	KP,KEYB1	;  NEXT ENTRY AND LOOP

	MOVSI	TA,(POPJ 17,)	;NO MORE--
	JRST	PUTKYW		;PUT OUT EXIT AND RETURN

KEYB2:	EXP	KEYB30		;UNDEFINED
	EXP	KEYB30		;COMP (ILLEGAL)
	EXP	KEYB15		;NUMERIC DISPLAY
	EXP	KEYB30		;FLOATING-POINT (ILLEGAL)
	EXP	KEYB3		;ALPHANUMERIC
;ALPHANUMERIC KEY

KEYB3:	MOVE	TA,[PUSHJ 17,KEY.]
	PUSHJ	PP,PUTKYW

	MOVEI	TE,5

	MOVE	TA,LOWBYT(KP)
	SUBI	TA,1
	IDIVI	TA,0(TE)
	ADD	TA,RECLOC

	HRLI	TA,(POINT 7,0)
	LDB	TD,[POINT 6,TA,11]
	IMULI	TA+1,(TD)
	MOVEI	TD,^D36
	SUBI	TD,(TA+1)
	DPB	TD,[POINT 6,TA,5]
	PUSHJ	PP,PUTKYW

	HRLZ	TA,KEYSIZ(KP)
	HRR	TA,KEYLOC
	SKIPL	KTYPE(KP)	;DESCENDING?
	TLZA	TA,1B18		;NO--CLEAR BIT
	TLO	TA,1B18		;YES--SET BIT
	PUSHJ	PP,PUTKYW

	MOVE	TA,KEYSIZ(KP)
	ADDI	TA,4
	IDIVI	TA,5
	ADDM	TA,KEYLOC
	POPJ	PP,
;A COUPLE OF ROUTINES LEFT OVER FOR NUMERIC DISP.

KEYB6:	PUSHJ	PP,PUTKYW

	MOVSI	TA,(SETCA)
	SKIPGE	KTYPE(KP)
	PUSHJ	PP,PUTKYW

	MOVSI	TA,(MOVEM)
	HRR	TA,KEYLOC
	AOS	KEYLOC
	JRST	PUTKYW

KEYB10:	PUSHJ	PP,KEYB6

	MOVSI	TA,(SETCA 1,)
	SKIPGE	KTYPE(KP)
	PUSHJ	PP,PUTKYW

	MOVSI	TA,(MOVEM 1,)
	HRR	TA,KEYLOC
	AOS	KEYLOC
	JRST	PUTKYW
;NUMERIC DISPLAY

KEYB15:	MOVE	TA,[HRRZI DP,3]
	ADD	TA,CKEYLC
	PUSHJ	PP,PUTKYW
	MOVE	TA,[PUSHJ PP,GD7.]
	PUSHJ	PP,PUTKYW

	MOVSI	TA,(SKIPA)
	PUSHJ	PP,PUTKYW

	MOVE	TA,LOWBYT(KP)
	SUBI	TA,1

	MOVEI	TD,5
	IDIVI	TA,(TD)
	ADD	TA,RECLOC
	CAIE	TD,6
	MOVEI	TD,7
	IMULI	TD,(TA+1)
	MOVNS	TD
	ADDI	TD,^D36
	DPB	TD,[POINT 6,TA,5]

	MOVE	TB,KEYSIZ(KP)
	DPB	TB,[POINT 11,TA,17]

	LDB	TB,[POINT 17,KTYPE(KP),17]
	CAIN	TB,UNSIGN
	TLZA	TA,1B<^D18+6>
	TLO	TA,1B<^D18+6>

	MOVE	TB,KEYSIZ(KP)
	CAILE	TB,^D10
	JRST	KEYB10
	JRST	KEYB6

;BAD CODE

KEYB30:	MOVEI	0,[ASCIZ/Bad key type/]
	JRST	KILL.
SUBTTL SCAN THROUGH KEY PARAMETERS LOOKING FOR ERRORS

SCNKEY:	MOVEI	KP,KEYDEF	;START AT TOP
	HRL	KP,NUMKEY	;BUILD IOWD
	TLNN	KP,-1		;ANY KEYS?
	JRST	NOKEYS		;NO--ERROR

SCNK1:	SKIPE	TA,LOWBYT(KP)	;ANY LOW BYTE?
	CAMLE	TA,RECSIZ	;YES--INSIDE RECORD?
	JRST	OUTRNG		;YES--ERROR

	SKIPN	TC,KEYSIZ(KP)	;ANY SIZE?
	JRST	ZEROSZ		;NO--ERROR

SCNK4:	ADDI	TC,-1(TA)	;IS KEY
	CAMLE	TC,RECSIZ	;  FULLY WITHIN RECORD?
	JRST	OUTRNG		;NO--ERROR

	HRRZ	TA,KTYPE(KP)	;ADD TO
	CAIG	TA,NTYPES	;  SIZE OF
	PUSHJ	PP,@SCNK10(TA)	;  KEY AREA

SCNK9:	ADDI	KP,KEYENT-1	;BUMP UP TO
	AOBJN	KP,SCNK1	;  NEXT KEY
	POPJ	PP,		;NO MORE--QUIT
;INCREMENT SIZE OF AREA TO HOLD KEYS

SCNK10:	EXP	SCNK14		;UNDEFINED
	EXP	SCNK14		;COMP
	EXP	SCNK11		;NUMERIC DISPLAY
	EXP	SCNK14		;FLOATING-POINT
	EXP	SCNK13		;ALPHANUMERIC

SCNK11:	MOVEI	TA,^D8
	ADDM	TA,KEYSZ
	MOVE	TA,KEYSIZ(KP)	;IS ITEM ONE WORD
	CAILE	TA,^D10		;  OR TWO?
	AOS	KEYWRK		;TWO
	AOS	KEYWRK		;ONE
	POPJ	PP,

SCNK13:	MOVEI	TA,3
	ADDM	TA,KEYSZ
	MOVE	TA,KEYSIZ(KP)	;ENOUGH WORDS
	ADDI	TA,4		;  FOR
	IDIVI	TA,5		;  FIVE BYTES
	ADDM	TA,KEYWRK	;  PER WORD
SCNK14:	POPJ	PP,
SUBTTL MISCELLANEOUS ROUTINES

;EXIT
TBARTN:	PUSHJ	PP,CLNUP2	;(NO NEED TO CLOSE IN & OUT FILES)
	MOVE	0,OCOUNT	;RETURN NUMBER OF RECORDS SORTED.
	TBARET

;RESET PROGRAM

RESET:	HRRZM	TA,RETLOC	;SAVE RETURN ADDRESS

	SETZM	KEYCV.

	SETZM	COMKAR

	MOVE	TA,[XWD SETWRT,CALLST]
	BLT	TA,CALLST+3

	JRST	@RETLOC		;RETURN

SETWRT:	PUSHJ	PP,PSORT.
	Z
	Z
	POPJ	PP,
;STASH A SINGLE 'KEY BUILDER' WORD

PUTKYW:	SKIPG	KEYSZ
	JRST	PTKERR
	MOVEM	TA,@CKEYLC
	AOS	TA,CKEYLC
	SOS	KEYSZ
	POPJ	PP,

;KEY CONVERSION TABLE OVERFLOW

PTKERR:	MOVEI	0,[ASCIZ/Key table overflow/]
	JRST	KILL.
;ERROR HANDLER - CLEANUP, PRINT MESSAGE IF OK

KILL.::	PUSH	PP,0
	PUSHJ	PP,CLENUP
	ERROR	QR,SRTERR
	POP	PP,0
	SKIPN	0
	POPJ	PP,
	PUSHJ	PP,CXER3##
	ERROR	SRTERR

;FILE ERROR

FLERRO:	PUSH	PP,1		;SAVE ERROR NUMBER
	CALL	.GARYS##,<$,FNSXBT,0>
	MOVEM	1,FNASCI
	JRST	FLERRL+1

FLERRL:	PUSH	PP,1		;FILE ERROR DURING LNDRY
	PUSHJ	PP,CLENUP
	MOVE	0,FNASCI
	POP	PP,1
	MOVE	2,[EXP MSCFIL]	;UNIT NUMBER
	PUSHJ	PP,PUBFER##

;CLEAN UP BEFORE EXITING

CLENUP:	SKIPN	OFPTR		;CLOSE INPUT AND OUTPUT FILES IF OPEN
	JRST CLNUP1
	WRITCR	OFPTR
	CALL	CLOSEF,<$,OFPTR>
CLNUP1:	SKIPN	IFPTR
	JRST	CLNUP2
	FREECR	IFPTR
	CALL	CLOSEF,<$,IFPTR>

CLNUP2:	PUSHJ	PP,ENDS.	;GO CLEAN UP SORTSB STUFF

	MOVEI	DP,4		;RETURN MEMORY
CLNUP3:	MOVE	1,DSCR(DP)
	JUMPE	1,CLNUP4
	CALL	RELSP##
CLNUP4:	SOJGE	DP,CLNUP3
	POPJ	PP,
SUBTTL ERROR ROUTINES

BADIDL:	MOVEI	0,[ASCIZ/Illegal character on end of command string/]
	JRST	KILL.		;[6]

;TYPE OUT 'TA' AS DECIMAL NUMBER

TYPDEC:	JUMPGE	TA,TYPDC1
	MOVEI	0,[ASCIZ/-/]
	CALL	CXER1##
	MOVMS	TA
	TLZ	TA,(1B0)

TYPDC1:	IDIVI	TA,^D10
	HRLM	TB,(PP)
	SKIPE	TA
	PUSHJ	PP,TYPDC1
	HLRZ	TA,(PP)
	ADDI	TA,"0"
	CALL	ERRCH,<$,TA>
	POPJ	PP,

;NO KEYS

NOKEYS:	MOVEI	0,[ASCIZ/No keys specified/]
	JRST	KILL.

;KEY OUT OF RANGE

OUTRNG:	SETZ	0,
	PUSH	PP,KP		;SO TYPKEY CAN GET IT
	PUSHJ	PP,KILL.
	POP	PP,KP
	PUSHJ	PP,TYPKEY
	MOVEI	0,[ASCIZ/ is outside record/]
	CALL	CXER1##
	JRST	SCNK9

;ZERO KEY LENGTH

ZEROSZ:	SETZ	0,
	PUSH	PP,KP
	PUSHJ	PP,KILL.
	POP	PP,KP
	PUSHJ	PP,TYPKEY
	MOVEI	0,[ASCIZ/ has zero length/]
	CALL	CXER1##
	JRST	SCNK9

;TYPE OUT "Key M.N"

TYPKEY:	IORI	SW,COMERA	;SET ERROR FLAG
	MOVEI	0,[ASCIZ/Key /]
	CALL	CXER3
	MOVE	TA,LOWBYT(KP)
	PUSHJ	PP,TYPK1
	MOVEI	0,[ASCIZ/./]
	CALL	CXER1##
	MOVE	TA,KEYSIZ(KP)

TYPK1:	IDIVI	TA,^D10
	HRLM	TA+1,(PP)
	SKIPE	TA
	PUSHJ	PP,TYPK1
	HLRZ	CH,(PP)
	ADDI	CH,"0"
	CALL	ERRCH,<$,CH>
	POPJ	PP,
;OCOUNT NOT = ICOUNT AFTER SORT COMPLETE

BADCNT:	SETZ	0,
	PUSHJ	PP,KILL.
	MOVEI	0,[ASCIZ/Read /]
	CALL	CXER1##
	MOVE	TA,ICOUNT
	PUSHJ	PP,TYPDEC
	MOVEI	0,[ASCIZ/ records, but wrote /]
	CALL	CXER1##
	MOVE	TA,OCOUNT
	PUSHJ	PP,TYPDEC
	ERROR	SRTERR

;OUTPUT ONE CHARACTER AS AN ERROR MESSAGE STRING

ERRCH:	LSH	0,^D29		;CONVERT CHAR INTO STRING
	MOVEM	0,CHOUT
	CALL	CXER1##,<CHOUT>
	POPJ	PP,
SUBTTL CONSTANTS

	SRTERR==^D163	;SORT ERROR MESSAGE NUMBER

;SWITCH FLAGS

REGET==1B18	;REGET PREVIOUS COMMAND CHARACTER
COMERA==1B21	;ERROR IN COMMAND STRING

;ACCUMULATORS

SW=6		;SWITCHES ***REDEFINED FROM 0***
TA=1		;TEMP
TB=2		;TEMP
TC=3		;TEMP
TD=4		;TEMP
TE=5		;TEMP
CH=10		;COMMAND CHARACTER
KP=11		;POINTER TO KEY DEFINITIONS
DP=13		;ONLY USED IN INPROC
PP=17		;PUSH-DOWN POINTER

DEFEXT:	Z		;DEFAULT FILE NAME EXTENSION: NULL STRING
SUBTTL WORK LOCATIONS

	TOPHI==.	;REMEMBER HI-SEG BREAK

	RELOC

RETLOC:	BLOCK 1		;RETURN LOC FOR RESET

LOLOW==.		;FIRST LOCATION ZEROED UPON STARTING

;FILE DEFINITIONS





;AREA TO STORE KEY DEFINITIONS

KEYENT==3		;SIZE OF EACH ENTRY

KEYDEF:	BLOCK ^D20*KEYENT

ENDKEY==.		;FIRST LOCATION NOT IN TABLE

NUMKEY:	BLOCK 1		;NUMBER OF KEYS (NEGATIVE)

LOWBYT==0	;RELATIVE LOCATION OF LOW BYTE NUMBER
KEYSIZ==1	;    "       "        KEY SIZE
KTYPE==2	;    "       "        KEY TYPE CODES

SIGNED==1	;KEY IS SIGNED
UNSIGN==2	;KEY IS UNSIGNED

DISPLY==2	;KEY IS DISPLAY
ALPHA==4	;KEY IS ALPHANUMERIC

NTYPES==4	;NUMBER OF KEY TYPES
;MISCELLANEOUS

ICOUNT:	BLOCK 1		;COUNT OF NUMBER OF RECORDS READ
OCOUNT:	BLOCK 1		;COUNT OF NUMBER OF RECORDS WRITTEN
RECSIZ:	BLOCK 1		;RECORD SIZE IN BYTES
RECWDS:	BLOCK 1		;RECORD SIZE IN WORDS
KEYWRK:	BLOCK 1		;AT FIRST, SIZE OF KEY AREA, THEN START OF KEY AREA
KEYLOC:	BLOCK 1		;LOCATION FOR NEXT KEY (SEE BLDKEY)

HILOW==.-1		;LAST LOCATION ZEROED UPON RESTART

RECLOC:	BLOCK 1		;ADDRESS OF RECORD AREA
CALLST:	BLOCK 4		;CALL TO PSORT. (SEE RESET)

COMKAR:	BLOCK	1	;LAST COMMAND CHARACTER SEEN

KEYSPT:	BLOCK 1		;POINTER TO INPUT STRING
DSCR::	BLOCK 5		;DESCRIPTORS FOR DSA
FNASCI:	BLOCK 1		;ASCII FILE NAME LOCATION
FNSXBT:	BLOCK 1		;SIXBIT FILE NAME LOCATION
IFPTR:	BLOCK 1		;INPUT FILE POINTER
OFPTR:	BLOCK 1		;OUTPUT FILE POINTER
RELEN.:	BLOCK 1		;RECORD SIZE IN WORDS.
KEYSZ:	BLOCK 1		;LEN OF KEY CONV. TABLE
CKEYLC:	BLOCK 1		;LOC OF KEY CONV. TABLE
CHOUT:	BLOCK 1		;CHARACTER FOR OUTPUT
KEYCV.:	BLOCK 1		;FLAG FOR SORTSB
TERMFL:	BLOCK 1		;FLAG: 0 IF FILE OUTPUT, 1 IF TERM
SBFRDY:	BLOCK 1		;FLAG FOR SORTSB

	RELOC	TOPHI	;RELOC SO LITERALS GO IN HI-SEGMENT

	END

    