!! title COMM2 - Commands of moderate complexity ;
! *************************************************************************
*									  *
*				   COMM2				  *
*		      Commands of moderate complexity			  *
*									  *
***************************************************************************


	   This file is required as a source!file in COMAND.SAI.


**************************************************************************;
!! title Rtn C!DelTokenF ;
! "Token" delete stuff.  This is sort of cute.  We delete grayspace
!  until non-grayspace is seen.  We take the first non-gray character
!  and save the descriptive bits from C!Tab which tell what kind of things
!  this character may be.  This character is deleted.  The descriptive
!  bits of the next character are ANDed with the bits.  If non-zero, then
!  the character is of the same token class, and may be deleted.
!  This idea attributed to Tim Brengle. ;

procedure C!DelTokenF;
  begin "delete token forward"
    integer TokenBits;

    if ( B!Lock ) then PuntCommand;

    if ( not C!ArgV ) then C!ArgV := 1;

    while ( C!ArgV ) do
      begin "do a token"
	forever do
	  begin "grayspace"
	    if ( B!EndP ) then PuntCommand;
	    if ( C!IsGrayP ) then
	      B!Delete( FORWARDS )
	    else
	      done "grayspace";
	  end "grayspace";
	TokenBits := C!Tab[ B!GetC ] land ChrMask;
	B!Delete( FORWARDS );
	forever do
	  begin "this token"
	    if ( B!EndP ) then PuntCommand;
	    TokenBits := TokenBits land C!Tab[ B!GetC ];
	    if ( LH( TokenBits ) = 0 ) then done "this token";
	    B!Delete( FORWARDS );
	  end "this token";
	C!ArgV := C!ArgV - 1;
      end "do a token";

  end "delete token forward";
!! title Rtn C!DelTokenB ;
! Delete a token backwards. ;

procedure C!DelTokenB;
begin "C!DelTokenB"
  integer
    TokenBits;

  if (B!Lock) then
    PuntCommand;

  if (not C!ArgV) then
    C!ArgV _ 1;

  while (C!ArgV) do
  begin "do a token"
    while (true) do
    begin "grayspace"
      if (B!BegP) then
	PuntCommand;

      B!Move(BACKWARDS);

      if (C!IsGrayP) then
	B!Delete(FORWARDS)
      else
	done "grayspace";
    end "grayspace";

    TokenBits _ C!Tab[B!GetC] land ChrMask;
    B!Delete(FORWARDS);

    while (true) do
    begin "this token"
      if(B!BegP) then
	PuntCommand;

      B!Move(BACKWARDS);
      TokenBits _ TokenBits land C!Tab[B!GetC];

      if (LH(TokenBits) = 0) then
	done "this token";

      B!Delete(FORWARDS);
    end "this token";

    B!Move(FORWARDS);
    decr(C!ArgV);
  end "do a token";

  if (W!GetS = B!GetP) then
  begin
    MoveBackwards;
    W!Disp(true);
    MoveForwards;
  end;

    ! Reframe if the point is at the beginning of the window ;
end "C!DelTokenB";
!! title Rtn C!MovTokenF ;
!  Routine to move forward over a token . ;

procedure C!MovTokenF;
begin "move token forward"
  integer TokenBits;

  if ( not C!ArgV ) then
    C!ArgV := 1;

  while ( C!ArgV ) do
  begin "do a token"
    SkipGraySpace;

    if (B!EndP) then
      PuntCommand;

    TokenBits := C!Tab[ B!GetC ] land ChrMask;

    forever do
    begin "this token"
      if ( B!EndP ) then
	PuntCommand;

      B!Move( FORWARDS );
      TokenBits := TokenBits land C!Tab[ B!GetC ];

      if ( LH( TokenBits ) = 0 ) then
	done "this token";
    end "this token";

    C!ArgV := C!ArgV - 1;
  end "do a token";
end "move token forward";
!! title Rtn C!MovTokenB ;
! Move backwards over a token . ;

procedure C!MovTokenB;
begin "move token backwards"
  integer TokenBits;

  if ( not C!ArgV ) then
    C!ArgV := 1;

  while ( C!ArgV ) do
  begin "do a token"
    forever do
    begin "grayspace"
      if ( B!BegP ) then
	PuntCommand;

      B!Move( BACKWARDS );

      if ( not C!IsGrayP ) then
	done "grayspace";
    end "grayspace";

    TokenBits := C!Tab[ B!GetC ] land ChrMask;

    forever do
    begin "this token"
      if( B!BegP ) then
	PuntCommand;

      B!Move( BACKWARDS );
      TokenBits := TokenBits land C!Tab[ B!GetC ];

      if ( LH( TokenBits ) = 0 ) then
	done "this token";
    end "this token";

    B!Move( FORWARDS );
    C!ArgV := C!ArgV - 1;
  end "do a token";
end "move token backwards";
!! title Rtn C!TokenUC ;
! Force a token to upper case ;

procedure C!TokenUC;
begin "force token UC"
  integer TokenBits, C;

  if ( B!Lock ) then
    PuntCommand;

  if ( not C!ArgV ) then
    C!ArgV := 1;

  while ( C!ArgV ) do
  begin "do a token"
    SkipGraySpace;

    if (B!EndP) then
      PuntCommand;

    TokenBits := C!Tab[ B!GetC ] land ChrMask;

    forever do
    begin "this token"
      if ( B!EndP ) then
	PuntCommand;

      C := B!GetC;
      TokenBits := TokenBits land C!Tab[ C ];

      if ( LH( TokenBits ) = 0 ) then
	done "this token";

      if (( C >= "a" ) and ( C <= "z" )) then
      begin
	B!Delete( FORWARDS );
	B!Insert( C - '40 );
      end
      else
	B!Move( FORWARDS );
    end "this token";
    C!ArgV := C!ArgV - 1;
  end "do a token";

end "force token UC";
!! title Rtn C!TokenLC ;
! Force a token to lower case ;

procedure C!TokenLC;
begin "force token LC"
  integer TokenBits, C;

  if ( B!Lock ) then
    PuntCommand;

  if ( not C!ArgV ) then
    C!ArgV := 1;

  while ( C!ArgV ) do
  begin "do a token"
    SkipGraySpace;

    if (B!EndP) then
      PuntCommand;

    TokenBits := C!Tab[ B!GetC ] land ChrMask;

    forever do
    begin "this token"
      if ( B!EndP ) then
	PuntCommand;

      C := B!GetC;
      TokenBits := TokenBits land C!Tab[ C ];

      if ( LH( TokenBits ) = 0 ) then
	done "this token";

      if (( C >= "A" ) and ( C <= "Z" )) then
      begin
	B!Delete( FORWARDS );
	B!Insert( C + '40 );
      end
      else
	B!Move( FORWARDS );
    end "this token";

    C!ArgV := C!ArgV - 1;
  end "do a token";
end "force token LC";
!! title Rtn C!TokenToggle ;
! Toggle the case of a token ;

procedure C!TokenToggle;
begin "toggle case"
  integer TokenBits, C;

  if ( B!Lock ) then
    PuntCommand;

  if ( not C!ArgV ) then
    C!ArgV := 1;

  while ( C!ArgV ) do
  begin "do a token"
    SkipGraySpace;

    if (B!EndP) then
      PuntCommand;

    TokenBits := C!Tab[ B!GetC ] land ChrMask;

    forever do
    begin "this token"
      if ( B!EndP ) then
	PuntCommand;

      C := B!GetC;
      TokenBits := TokenBits land C!Tab[ C ];

      if ( LH( TokenBits ) = 0 ) then
	done "this token";

      if (( C >= "A" ) and ( C <= "Z" )) then
      begin
	B!Delete( FORWARDS );
	B!Insert( C + '40 );
      end
      else if (( C >= "a" ) and ( C <= "z" )) then
      begin
	B!Delete( FORWARDS );
	B!Insert( C - '40 );
      end
      else
	B!Move( FORWARDS );
    end "this token";

    C!ArgV := C!ArgV - 1;
  end "do a token";
end "toggle case";
!! title Rtn C!CapitalizeToken ;
! Force the next token into standard capitalization.
;

simple procedure C!CapitalizeToken;
begin "C!CapitalizeToken"
  integer
    C,
    TokenBits;

  if (not C!ArgV) then
    C!ArgV _ 1;

  while (C!ArgV) do
  begin
    SkipGraySpace;

    if (B!EndP) then
      PuntCommand;

    C _ B!GetC;
    TokenBits _ C!Tab[C] land ChrMask;

    if (IsLower(C)) then
    begin
      B!Delete(FORWARDS);
      B!Insert(UpShift(C));
    end
    else
      B!Move(FORWARDS);

    while (true) do
    begin
      if (B!EndP) then
        PuntCommand;

      C _ B!GetC;
      TokenBits _ TokenBits land C!Tab[C];

      if (lh(TokenBits) = 0) then
        done;

      if (IsUpper(C)) then
      begin
        B!Delete(FORWARDS);
        B!Insert(DownShift(C));
      end
      else
        B!Move(FORWARDS);
    end;

    decr(C!ArgV);
  end;
end "C!CapitalizeToken";
!! title Rtn C!MovSpecF ;
! Move to the next 'special' character.
;

simple procedure C!MovSpecF;
begin 
  if (not C!ArgV) then
    C!ArgV _ 1;

  while (C!ArgV) do
  begin
    if (not MoveTo(C!IsSpecial, FORWARDS)) then
      done;

    B!Move(FORWARDS);
    decr(C!ArgV);
  end;

  C!ArgV _ 0;
end ;
!! title Rtn C!MovSpecB ;
! Move to the previous 'special' character.
;

simple procedure C!MovSpecB;
begin 
  if (not C!ArgV) then
    C!ArgV _ 1;

  while (C!ArgV) do
  begin
    if (not MoveTo(C!IsSpecial, BACKWARDS)) then
      done;

    decr(C!ArgV);
  end;

  C!ArgV _ 0;
end;
!! title Macro KillChr ;
! Kill the next logical character, placing it in the Kill Buffer if
! possible.  This macro assumes that the following variables exist in the
! scope in which it is invoked:
!
!	Cont.Flg	Continuation Flag,
!			  if = 0 we may insert into KB
!	C!KillBP	Pointer into the KB
!	C!KillCnt	The number of characters in the KB.
!
! If parameter Parm1 = "EOL", we want to delete a CRLF.
! Otherwise, we will insert its value into the KB. ;


define
  KillChr (Parm1) =
  {
    assignc Parm1 = scanc(cvps(Parm1), null, null, "IK");

    ifcr (equ(cvps(Parm1), "EOL")) thenc
      B!Delete(FORWARDS);
      B!Delete(FORWARDS);

     if (not Cont.Flg) then
      begin
	idpb(CR, C!KillBP);
	idpb(LF, C!KillBP);
	incr(C!KillCnt, 2);
      end;
    elsec
      B!Delete(FORWARDS);

      if (not Cont.Flg) then
      begin
	idpb(Parm1, C!KillBP);
	incr(C!KillCnt);
      end
    endc
  };
!! title Macro AbortKill ;
! Abort a text-killing operation, by removing the text killed by this
! invocation of the command from the Kill Buffer and replacing it in the
! Text Buffer.  Both the parameters
!
!	BP		A byte-pointer to the removable section of the KB
!	Count		The number of characters to remove
!
! need to be variables, for they are manipulated as reference objects ;


define
  AbortKill (BP, Count) =
  {
    while (Count) do
    begin
      B!Insert(ildb(BP));
      decr(Count);
    end
  };
!! title Macro SaveKill ;
! Save a text-killing operation, leaving as many lines as will fit
! completely in the Kill Buffer intact, and returning the leading portion
! of the line that will not to the Text Buffer.  This macro assumes that
! the following variables exist in the scope in which it is invoked:
!
!	C!KillBP	Pointer into the KB
!	C!KillCnt	The number of characters in the KB.
;

define
  SaveKill =
  {
    begin
      integer
	Char;

      while (C!KillCnt and
	  (Char _ ldb(C!KillBP)) neq LF and Char neq FF) do
      begin
	B!Insert(Char);
	B!Move(BACKWARDS);
	C!KillBP _ DecrBP(C!KillBP);
	decr(C!KillCnt);
      end;
    end
  };
!! title Rtn KBFullPrompt ;
! Ask the user what to do when the kill buffer fills up, and force him to
! answer sensibly ;

simple integer procedure KBFullPrompt;
begin "KBFullPrompt"
  integer
    Char;
  string
    Prompt;
  define
    UpShift (X) = {(X land (lnot '40))},
    ToUpper (X) = {(if ("a" <= X <= "z") then UpShift(X) else X)};


  Char   _ 0;
  Prompt _ "Kill Buffer Full - Enter (A)bort, (P)roceed or (S)ave: ";

  while (not Char) do
  begin
    if (not C!ReadString(Prompt, CR, ESC)) then
      Char _ 0
    else
      Char _ ToUpper(C!String);

    if (Char) then
    begin
      W!Msg(
	Prompt & 
	  (if (Char = "A") then "Abort"
	  else if (Char = "S") then "Save"
	  else if (Char = "P") then "Proceed"
	  else Char)
      );

      W!Disp(true);

      if (Char = "A" or Char = "P" or Char = "S") then
	done
      else
	Char _ 0;
    end;

    T!Bell;
  end;

  return(Char);
end "KBFullPrompt";
!! title Rtn SearchStrFullPrompt ;
! Ask the user what to do when the search string fills up in the process
of a copy to it ;

simple integer procedure SearchStrFullPrompt;
begin "SearchStrFullPrompt"
  integer
    Char;
  string
    Prompt;
  define
    UpShift (X) = {(X land (lnot '40))},
    ToUpper (X) = {(if ("a" <= X <= "z") then UpShift(X) else X)};


  Char   _ 0;
  Prompt _ "Search String Full - Enter (A)bort or (P)roceed: ";

  while (not Char) do
  begin
    if (not C!ReadString(Prompt, CR, ESC)) then
      Char _ 0
    else
      Char _ ToUpper(C!String);

    if (Char) then
    begin
      W!Msg(
	Prompt & 
	  (if (Char = "A") then "Abort"
	  else if (Char = "P") then "Proceed"
	  else Char)
      );

      W!Disp(true);

      if (Char = "A" or Char = "P") then
	done
      else
	Char _ 0;
    end;

    T!Bell;
  end;

  return(Char);
end "SearchStrFullPrompt";
!! title Rtn C!CopyToSearch ;
! Copy text into the search string.
;

simple procedure C!CopyToSearch;
begin "C!CopyToSearch"
  integer
    Mark,
    HowMany,
    Temp;

  Mark   _ C!ArgV;
  C!ArgV _ 0;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if ((Mark < 0) or (Mark > 9)) then
  begin
    W!Msg("Bad Mark Number - " & cvs(Mark));
    T!Bell;
    return;
  end;
 
  if (B!GetM(Mark) < 0) then
  begin
    W!Msg("Mark " & cvs(Mark) & " not set");
    T!Bell;
    return;
  end;

  if (B!GetM(Mark) = B!GetP) then
  begin
    W!Msg("The Point and Mark " & cvs(Mark) & " are in the same place");
    T!Bell;
    return;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  HowMany _ abs(B!GetP - B!GetM(Mark));

  if (HowMany > MAXSEARCHSTRING) then
  begin
    if (SearchStrFullPrompt neq "P") then
      return
    else
      HowMany _ MAXSEARCHSTRING;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  C!Search _ NULL;

  if (B!GetP > B!GetM(Mark)) then
  begin
    Temp _ B!GetP;
    B!SetP(B!GetM(Mark));
    B!SetM(Mark, Temp);
  end;

  while (HowMany > 0) do
  begin
    C!Search _ C!Search & B!GetC;
    B!Move(FORWARDS);
    decr(HowMany);
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  W!Msg("Search String Set");
end "C!CopyToSearch";
!! title Rtn C!DelToEOL ;
! Delete to the end of the Line, copying text into the kill buffer, if
!  there's room.  If there is no room in kill buffer, prompt the user for
!  verification. ;  

forward simple procedure C!DelEOL;
forward simple procedure C!Wipe;

simple procedure C!DelToEOL;
begin
  own integer
    Cont.Flg,
    SaveBP,
    SaveCnt,
    SavePt,
    Temp1;
  define
    Eol = {Eol};

  if (B!Lock or B!EndP) then
    PuntCommand;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if (not G!AppendKillP and
      C!LastAddr neq location(C!DelToEOL) and
      C!LastAddr neq location(C!Wipe) and
      C!LastAddr neq location(C!DelEOL)) then
  begin
    C!KillBP  _ point(7, C!KillBuf[0], -1);
    C!KillCnt _ 0;
  end;

  clear(G!AppendKillP);
  C!ArgV _ C!ArgV max 1;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  Cont.Flg _ 0;
  SaveBP   _ C!KillBP;
  SaveCnt  _ C!KillCnt;
  SavePt   _ B!GetP;

  if (not B!EndP) then
    while (C!ArgV) do
    begin "argv times"
      if (not B!EndP) then
      begin "delete"
	Temp1 _ B!GetC;

	if (Temp1 = FF) then
	  done "argv times";

	if (AtEOL) then
	begin "EOL"
	  if (not Cont.Flg and C!KillCnt >= KILLBUFMAX - 1) then
	    if ((Cont.Flg _ KBFullPrompt) = "S") then
	    begin
	      Cont.Flg _ 0;
	      done "argv times";
	    end
	    else if (Cont.Flg = "A") then
	      done "argv times";

	  KillChr(Eol);
	end "EOL"
	else
	begin "char"
	  while (not B!EndP and not AtEOL) do
	  begin
	    Temp1 _ B!GetC;

	    if ((not Cont.Flg and C!KillCnt >= KILLBUFMAX) and
		((Cont.Flg _ KBFullPrompt) = "A" or Cont.Flg = "S")) then 
	      done "argv times";

	    KillChr(Temp1);
	  end;
	end "char";
      end "delete"
      else
	done "argv times";

      decr(C!ArgV);
    end "argv times";

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if (Cont.Flg = "A") then
  begin
    integer
      BP,
      Count;

    BP    _ SaveBP;
    Count _ C!KillCnt - SaveCnt;

    AbortKill(BP, Count);

    C!KillBP  _ SaveBP;
    C!KillCnt _ SaveCnt;

    W!Msg("Kill Aborted");
  end
  else if (Cont.Flg = "S") then
  begin
    SaveKill;
    W!Msg("Kill Saved");
  end;

  B!SetP(SavePt);

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  W!FixS;
  C!ArgV _ 0;
end;
!! title Rtn C!DelEOL ;
! Delete to and including the end of the Line, copying text into the kill
!  buffer, if there's room.  If there is no room in kill buffer, prompt
!  the user for verification. ; 

simple procedure C!DelEOL;
begin
  own integer
    Cont.Flg,
    SaveBP,
    SaveCnt,
    SavePt,
    Temp1;
  define
    Eol = {Eol};

  if (B!Lock or B!EndP) then
    PuntCommand;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if (not G!AppendKillP and
      C!LastAddr neq location(C!DelToEOL) and
      C!LastAddr neq location(C!Wipe) and
      C!LastAddr neq location(C!DelEOL)) then
  begin
    C!KillBP  _ point(7, C!KillBuf[0], -1);
    C!KillCnt _ 0;
  end;

  clear(G!AppendKillP);
  C!ArgV _ C!ArgV max 1;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  Cont.Flg _ 0;
  SaveBP   _ C!KillBP;
  SaveCnt  _ SaveCnt;
  SavePt   _ B!GetP;

  if (not B!EndP) then
    while (C!ArgV) do
    begin "argv times"
      while (not B!EndP) do
      begin "delete"
	Temp1 _ B!GetC;

	if (AtEOL and Temp1 neq FF) then
	begin "EOL"
	  if (not Cont.Flg and C!KillCnt >= KILLBUFMAX - 1 and
	      ((Cont.Flg _ KBFullPrompt) = "A" or Cont.Flg = "S")) then
	    done "argv times";

	  KillChr(Eol);
	  done "delete";
	end "EOL"
	else
	begin
	  if (not Cont.Flg and C!KillCnt >= KILLBUFMAX and
	      ((Cont.Flg _ KBFullPrompt) = "A" or Cont.Flg = "S")) then
	    done "argv times";

	  KillChr(Temp1);

          if (Temp1 = FF) then
            done "delete";
	end;
      end "delete";

      decr(C!ArgV);
    end "argv times";

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if (Cont.Flg = "A") then
  begin
    integer
      BP,
      Count;

    BP    _BP;
    Count _ C!KillCnt - SaveCnt;

    AbortKill(BP, Count);

    C!KillBP  _ SaveBP;
    C!KillCnt _ SaveCnt;

    W!Msg("Kill Aborted");
  end
  else if (Cont.Flg = "S") then
  begin
    SaveKill;
    W!Msg("Kill Saved");
  end;

  B!SetP(SavePt);

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  W!FixS;
  C!ArgV _ 0;
end;
!! title Rtn C!Copy ;
! "Copy" text from the point to the mark.  Abort if the copy will overflow
!  the kill buffer. ;

simple procedure C!Copy;
begin
  integer
    Mark,
    HowMany,
    Temp,
    SavePt;

  Mark   _ C!ArgV;
  C!ArgV _ 0;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if ((Mark < 0) or (Mark > 9)) then
  begin
    W!Msg("Bad Mark Number - " & cvs(Mark));
    T!Bell;
    return;
  end;

  if (B!GetM(Mark) < 0) then
  begin
    W!Msg("Mark " & cvs(Mark) & " not set");
    T!Bell;
    return;
  end;

  if (B!GetM(Mark) = B!GetP) then
  begin
    W!Msg("The Point and Mark " & cvs(Mark) & " are in the same place");
    T!Bell;
    return;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  HowMany _ abs(B!GetP - B!GetM(Mark));

  if (HowMany > KILLBUFMAX) then
  begin
    W!Msg("Kill Buffer would overflow by " & cvs(HowMany - KILLBUFMAX) &
	" characters.  Copy Aborted.");
    return;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  C!KillBP  _ point(7, C!KillBuf[0], -1);
  C!KillCnt _ 0;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  SavePt _ B!GetP;			! save the point ;

  if (B!GetM(Mark) < B!GetP) then	! set it to mark if needed ;
    B!SetP(B!GetM(Mark));

  while (HowMany > 0) do
  begin
    idpb(B!GetC, C!KillBP);
    incr(C!KillCnt);
    B!Move(FORWARDS);
    decr(HowMany);
  end;

  B!SetP(SavePt);

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  W!Msg("Copy Complete");
end;
!! title Rtn C!Wipe ;
! "Wipe" text from between the point and the mark.  The text will be
!   removed from the lower end of the region forward.  In the case that
!   the kill buffer will overflow, the user has three options:
!
!	(A)bort the command, leaving everything intact,
!	(P)roceed and lose whatever data cannot be accomodated in the
!	  kill buffer,
!	(S)ave whatever data will fit and stop there.
;

simple procedure C!Wipe;
begin "C!Wipe"
  integer
    Char,
    Mark,
    HowMany,
    SavePt,
    Temp;


  if (B!Lock) then
    PuntCommand;

  Mark   _ C!ArgV;
  C!ArgV _ 0;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if ((Mark < 0) or (Mark > 9)) then
  begin
    W!Msg("Bad Mark Number - " & cvs(Mark));
    T!Bell;
    return;
  end;

  if (B!GetM(Mark) < 0) then
  begin
    W!Msg("Mark " & cvs(Mark) & " not set");
    T!Bell;
    return;
  end;

  if (B!GetM(Mark) = B!GetP) then
  begin
    W!Msg("The Point and Mark " & cvs(Mark) & " are in the same place");
    T!Bell;
    return;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if (C!LastAddr neq location(C!DelEOL) and
      C!LastAddr neq location(C!DelToEOL) and
      C!LastAddr neq location(C!Wipe)) then
  begin
    C!KillBP  _ point(7, C!KillBuf[ 0 ], -1);
    C!Killcnt _ 0;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  HowMany _ abs(B!GetP - B!GetM(Mark));

  if (HowMany > KILLBUFMAX - C!KillCnt) then
  begin
    Char _ KBFullPrompt;

    if (Char = "S") then
      HowMany _ KILLBUFMAX - C!KillCnt
    else if (Char = "A") then
    begin
      W!Msg("Wipe Aborted");
      return;
    end;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  SavePt _ B!GetP;

  if (SavePt > B!GetM(Mark)) then
  begin
    B!SetP(B!GetM(Mark));
    B!SetM(Mark, SavePt);
  end;

  while (HowMany > 0) do
  begin
    if (C!KillCnt < KILLBUFMAX) then
    begin
      idpb(B!GetC, C!KillBP);
      incr(C!KillCnt);
    end;

    B!Delete(FORWARDS);
    decr(HowMany);
  end;

  if (SavePt neq B!GetP) then
  begin
    Temp _ B!GetM(Mark);
    B!SetM(Mark, B!GetP);
    B!SetP(Temp);
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  W!Msg("Wipe Complete");
end "C!Wipe";
!! title Rtn C!Yank ;
! "Yank" text out of the kill buffer and insert it at the mark.  Leave
!  the point at the end of the inserted text.  The kill buffer is not
!  affected. ;

procedure C!Yank;
begin "C!Yank"
  integer
    BP,
    Count,
    SavePt;

  SavePt _ B!GetP;

  if (not C!ArgV) then
    C!ArgV _ 1;

  while (C!ArgV) do
  begin 
    Count _ C!KillCnt;
    BP    _ point(7, C!KillBuf[0], -1);

    while (Count) do
    begin
      B!Insert(ildb(BP));
      decr(Count);
    end;

    decr(C!ArgV);
  end;

  if (not C!SPMRegion) then
    B!SetP(SavePt);

  W!Msg("Yank Complete");
end "C!Yank";
!! title Rtn DoIndent ;
! Do the common legwork for region indent commands.
;

simple procedure DoIndent (integer Add);
begin "DoIndent"
  integer
    SPt1,
    SPt2,
    SPt3,
    Point,
    Mark,
    SavPt;

  SPt1 _ B!AllocateMark;
  SPt2 _ B!AllocateMark;
  SPt3 _ B!AllocateMark;

  B!SetM(SPt3, B!GetP);

  if (B!GetP < (Mark _ B!GetM(0))) then
  begin
    MoveToBOL;
    SavPt _ 1;
    B!SetM(SPt1, B!GetP);

    B!SetP(Mark);
    MoveToEOL;
    MoveForwards;
    B!SetM(SPt2, B!GetP);
  end
  else
  begin
    MoveToEOL;
    MoveForwards;
    SavPt _ 2;
    B!SetM(SPt2, B!GetP);

    B!SetP(Mark);
    MoveToBOL;
    B!SetM(SPt1, B!GetP);
  end;

  B!SetP(B!GetM(SPt1));

  while (true) do
  begin
    if (not AtEOL) then
      ForceIndent(GetIndent + Add);

    MoveToEOL;
    MoveForwards;

    if (B!EndP or B!GetP >= B!GetM(SPt2)) then
      done;
  end;

  B!SetP
  (
    B!GetM
    (
      if (not C!SPMRegion) then
        SPt3
      else if (SavPt = 1) then
        SPt2
      else
        SPt1
    )
  );

  B!DeAllocateMark(SPt1);
  B!DeAllocateMark(SPt2);
  B!DeAllocateMark(SPt3);
end "DoIndent";
!! title Rtn C!AddIndent ;
! Command to indent the current line an additional indentation unit. ;

procedure C!AddIndent;
  begin
    integer Add;
    if ( not C!ArgV ) then C!ArgV := 1;
    Add := C!ArgV * C!IndentUnitWidth;
    ForceIndent( GetIndent + Add );
    C!ArgV := 0;
  end;
!! title Rtn C!IndentRegion ;
! Indent a region of text delimited by the point and User Mark 0.
;

procedure C!IndentRegion;
begin "C!IndentRegion"
  if (B!GetM(0) < 0) then
  begin
    W!Msg("Mark 0 isn't set");
    T!Bell;
    PuntCommand;
  end;

  if (not C!ArgV) then
    C!ArgV _ 1;

  DoIndent(C!ArgV * C!IndentUnitWidth);
  C!ArgV _ 0;
end "C!IndentRegion";
!! title Rtn C!UnIndent ;
! Command to "unindent" a line by the specified amount. ;

procedure C!UnIndent;
  begin
    integer Remove;
    if ( not C!ArgV ) then C!ArgV := 1;
    Remove := C!ArgV * C!IndentUnitWidth;
    ForceIndent( GetIndent - Remove );
    C!ArgV := 0;
  end;
!! title Rtn C!UnIndentRegion ;
! Unindent a region of text delimited by the point and User Mark 0.
;

procedure C!UnIndentRegion;
begin
  if (B!GetM(0) < 0) then
  begin
    W!Msg("Mark 0 isn't set");
    T!Bell;
    PuntCommand;
  end;

  if (not C!ArgV) then
    C!ArgV _ 1;

  DoIndent(-(C!ArgV * C!IndentUnitWidth));
  C!ArgV _ 0;
end;
!! title Rtn C!Center ;
! "center" a line of text within the current margins. ;

simple procedure C!Center;
begin
  own integer
    SavePt,
    Width;

  C!ArgV _ 0;
  MoveToBOL;
  SavePt _ B!GetP;

  while (C!IsWhiteP) do
    B!Delete(FORWARDS);

  MoveToEOL;


  ! Delete trailing whitespace ;

  begin
    B!Move(BACKWARDS);

    while (B!GetP > SavePt and C!IsWhiteP) do
    begin
      B!Delete(FORWARDS);
      B!Move(BACKWARDS);
    end;

    B!Move(FORWARDS);
  end;


  Width _ B!GetP - SavePt;

  if (Width = 0) then
    return;

  ForceIndent(C!LeftMargin - 1 +
      (((C!RightMargin - C!LeftMargin + 1) - Width) % 2));
  MoveToEOL;
end;
!! title Rtn C!RightJustify ;
! Right justify a chunk of text against the current margin ;

simple procedure C!RightJustify;
begin
  own integer
    SavePt,
    SpacesNeeded;
  
  SavePt _ B!GetP;
  MoveToEOL;

  ! Delete trailing whitespace ;

  begin
    B!Move(BACKWARDS);

    while (B!GetP > SavePt and C!IsWhiteP) do
    begin
      B!Delete(FORWARDS);
      B!Move(BACKWARDS);
    end;

    B!Move(FORWARDS);
  end;

  SpacesNeeded _ C!RightMargin - GetColumn + 1;
  B!SetP(SavePt);

  while (SpacesNeeded > 0) do
  begin
    B!Insert(" ");
    decr(SpacesNeeded);
  end;

  C!ArgV _ 0;
end;
!! title Rtn C!ShowSearch ;
! Display the single- and multiple-search strings ;

procedure C!ShowSearch;
begin
  string
    TmpStr;


  TmpStr _ null;

  if (C!Search) then
    appnd(TmpStr, "Search: """ & C!Search & """");

  if (C!SearchM) then
    appnd(TmpStr, "   M-Search: """ & C!SearchM & """");

  if (not length(TmpStr)) then
    appnd(TmpStr, "No Search Strings");

  W!Msg(TmpStr);
  C!ArgV _ 0;
end;
!! title Rtn C!FSearch ;
! Search forward through the buffer for a text string ;

simple procedure C!FSearch;
  begin "search"
    own integer SavePoint;

    if ( not C!ReadString( "Search: ", ESC, ESC )) then
      begin
	W!Msg( "Search Aborted" );
	C!ArgV := 0;
	return;
      end;
    if ( length( C!String ) = 0 ) then
      begin
	if ( length( C!Search ) = 0 ) then
	  begin
	    W!Msg( "No Search String" );
	    C!ArgV := 0;
	    return;
	  end
	else
	  W!Msg( "Search: " & C!Search & "$" );
      end
    else
      C!Search := C!String;

    W!MsgF := true;
    if ( not C!ChrP ) then W!Disp( true );
    W!MsgF := false;

    if ( not C!ArgV ) then C!ArgV := 1;
    while ( C!ArgV > 0 ) do
      begin
	SavePoint := B!GetP;
	ForwardSearch( C!Search );
	if ( SavePoint = B!GetP ) then
	  C!ArgV := -1
	else
	  C!ArgV := C!ArgV - 1;
      end;

    if ( C!ArgV < 0 ) then
      begin
	W!Msg( "Search: " & C!Search & "  [failed]" );
	C!MAbort := true;
      end
    else
      W!Msg( "Search: " & C!Search );

    C!ArgV := 0;

  end "search";
!! title Rtn C!RFSearch ;
! Repeat a forward search ;

internal simple procedure C!RFSearch;
  begin "repeat search"
    own integer SavePoint;

    if ( length( C!Search ) = 0 ) then
      begin
	W!Msg( "No Search String" );
	C!ArgV := 0;
	return;
      end;

    W!Msg( "Search: " & C!Search & "$" );

    W!MsgF := true;
    if ( not C!ChrP ) then W!Disp( false );
    W!MsgF := false;

    if ( not C!ArgV ) then C!ArgV := 1;
    while ( C!ArgV > 0 ) do
      begin
	SavePoint := B!GetP;
	ForwardSearch( C!Search );
	if ( SavePoint = B!GetP ) then
	  C!ArgV := -1
	else
	  C!ArgV := C!ArgV - 1;
      end;

    if ( C!ArgV < 0 ) then
      begin
	W!Msg( "Search: " & C!Search & "  [failed]" );
	C!MAbort := true;
      end
    else
      W!Msg( "Search: " & C!Search );

    C!ArgV := 0;

  end "repeat search";
!! title Rtn C!RSearch ;
! Search backwards through the buffer for a text string ;

simple procedure C!RSearch;
  begin "reverse search"
    own integer SavePoint;

    if ( not C!ReadString( "Reverse Search: ", ESC, ESC )) then
      begin
	W!Msg( "Reverse Search Aborted" );
	C!ArgV := 0;
	return;
      end;
    if ( length( C!String ) = 0 ) then
      begin
	if ( length( C!Search ) = 0 ) then
	  begin
	    W!Msg( "No Search String" );
	    C!ArgV := 0;
	    return;
	  end
	else
	  W!Msg( "Reverse Search: " & C!Search & "$" );
      end
    else
      C!Search := C!String;

    W!MsgF := true;
    if ( not C!ChrP ) then W!Disp( true );
    W!MsgF := false;

    if ( not C!ArgV ) then C!ArgV := 1;
    while ( C!ArgV > 0 ) do
      begin
	SavePoint := B!GetP;
	BackwardSearch( C!Search );
	if ( SavePoint = B!GetP ) then
	  C!ArgV := -1
	else
	  C!ArgV := C!ArgV - 1;
      end;

    if ( C!ArgV < 0 ) then
      begin
	W!Msg( "Reverse Search: " & C!Search & "  [failed]" );
	C!MAbort := true;
      end
    else
      W!Msg( "Reverse Search: " & C!Search );

    C!ArgV := 0;

  end "reverse search";
!! title Rtn C!RRSearch ;
! Repeat a backward search ;

simple procedure C!RRSearch;
  begin "repeat reverse search"
    own integer SavePoint;

    if ( length( C!Search ) = 0 ) then
      begin
	W!Msg( "No Search String" );
	C!ArgV := 0;
	return;
      end;

    W!Msg( "Reverse Search: " & C!Search & "$" );

    W!MsgF := true;
    if ( not C!ChrP ) then W!Disp( true );
    W!MsgF := false;

    if ( not C!ArgV ) then C!ArgV := 1;
    while ( C!ArgV > 0 ) do
      begin
	SavePoint := B!GetP;
	BackwardSearch( C!Search );
	if ( SavePoint = B!GetP ) then
	  C!ArgV := -1
	else
	  C!ArgV := C!ArgV - 1;
      end;

    if ( C!ArgV < 0 ) then
      begin
	W!Msg( "Reverse Search: " & C!Search & "  [failed]" );
	C!MAbort := true;
      end
    else
      W!Msg( "Reverse Search: " & C!Search );

    C!ArgV := 0;

  end "repeat reverse search";
!! title Rtn C!MSearch ;
! The shell for a multiple search
;

procedure C!MSearch;
begin "C!MSearch"
  own integer
    SavePoint;

  if (not C!ReadESCString("M-Search: ")) then
  begin
    W!Msg("M-Search Aborted");
    C!ArgV _ 0;
    return;
  end;

  if (length(C!String) = 0) then
  begin
    if (length(C!SearchM) = 0) then
    begin
      W!Msg("No M-Search String");
      C!ArgV _ 0;
      return;
    end
    else
      W!Msg("M-Search: " & C!SearchM & "$");
  end
  else
    C!SearchM _ C!String;

  W!MsgF _ true;
  if (not C!ChrP) then W!Disp(true);
  W!MsgF _ false;

  if (not C!ArgV) then C!ArgV _ 1;
  while (C!ArgV > 0) do
  begin
    SavePoint _ B!GetP;
    MultipleSearch(C!SearchM);
    if (SavePoint = B!GetP) then
      C!ArgV _ -1
    else
      C!ArgV _ C!ArgV - 1;
  end;

  if (C!ArgV < 0) then
  begin
    W!Msg("M-Search: " & C!SearchM & "  [failed]");
    C!MAbort _ true;
  end
  else
    W!Msg("M-Search: " & C!SearchM);

  C!ArgV _ 0;
end "C!MSearch";
!! title Rtn C!ChangeString ;
! Change one string to another. ;

procedure C!ChangeString;
  begin "change"
    integer I, SavePoint, ChangeCount;
    string OldString, NewString;

    if ( not C!ReadString( "Change: ", ESC, ESC )) then
      begin
	W!Msg( "Change Aborted" );  C!ArgV := 0;  return;
      end;
    if ( length( C!String ) = 0 ) then
      begin
	W!Msg( "Change Aborted" );  C!ArgV := 0;  return;
      end;

    OldString := C!String;

    if ( not ( C!ReadString( "Change: " & OldString & " to: ",ESC,ESC ))) then
      begin
	W!Msg( "Change Aborted" );  C!ArgV := 0;  return;
      end;
    NewString := C!String;

    W!MsgF := true;
    if ( not C!ChrP ) then W!Disp( true );
    W!MsgF := false;

    ChangeCount := 0;

    if ( not C!ArgV ) then C!ArgV := '377777777777;

    while ( C!ArgV > 0 ) do
      begin "each arg"
	SavePoint := B!GetP;
	ForwardSearch( OldString );
	if ( SavePoint = B!GetP ) then
	  C!ArgV := 0
	else
	  begin
	    for I := 1 upto length( OldString ) do
	      B!Delete( BACKWARDS );
	    for I := 1 upto length( NewString ) do
	      B!Insert( NewString[ i for 1 ] );
	    ChangeCount := ChangeCount + 1;
	    C!ArgV := C!ArgV - 1;
	  end;
      end "each arg";

    W!Msg( "Change: " & OldString & " to: " & NewString &
           "  [" & cvs( ChangeCount ) & "]" );

    C!ArgV := 0;

  end "change";
!! title Rtn C!QueryChange ;
! "Query Change" - user-friendliness in action ;

simple procedure C!QueryChange;
begin "C!QueryChange"
  string
    Prompt;
  own integer
    I,
    SavePoint,
    Response,
    N;


  if (not C!ReadString("Q-Change: ", ESC, ESC)) then
  begin
    W!Msg("Q-Change Aborted");
    C!ArgV _ 0;
    return;
  end;

  if (length(C!String) = 0) then
  begin
    W!Msg("Q-Change Aborted");
    C!ArgV _ 0;
    return;
  end;

  C!QOldStr _ C!String;

  if (not C!ReadString("Q-Change: " & C!QOldStr & " to: ", ESC, ESC)) then
  begin
    W!Msg("Q-Change Aborted");
    C!ArgV _ 0;
    return;
  end;

  C!QNewStr _ C!String;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  W!MsgF    _ true;

  if (not C!ChrP) then
    W!Disp(true);

  W!MsgF _ false;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  N _ 0;

  if (not C!ArgV) then
    C!ArgV _ MaxInteger;

  while (C!ArgV > 0) do
  begin
    SavePoint _ B!GetP;
    ForwardSearch(C!QOldStr);

    if (SavePoint = B!GetP) then
      C!ArgV _ -1
    else
    begin "query"
      Prompt _ "Q-Change: " & C!QOldStr & " to: " & C!QNewStr;
      W!Msg(Prompt & " ?");
      Response _ C!GetC;

      if (C!Tab[Response] land IsYes) then
      begin "change"
	W!Msg(Prompt & " [Yes]");
	incr(N);

	for I _ 1 upto length(C!QOldStr) do
	  B!Delete(BACKWARDS);

	for I _ 1 upto length(C!QNewStr) do
	  B!Insert(C!QNewStr[i for 1]);

	W!Disp(false);
      end "change"
      else
      begin
	W!Msg(Prompt & " [No]");
	W!Disp(false);
      end;

      if (C!Tab[Response] land IsAbort) then
	C!ArgV _ 0
      else
	decr(C!ArgV);
    end "query";
  end;

  W!Msg(Prompt & " [" & cvs(N) & "]");
  C!ArgV _ 0;
end "C!QueryChange";
!! title Rtn C!RepeatQChange ;
! Repeat "Query Change" ;

simple procedure C!RepeatQChange;
begin "C!RepeatQChange"
  string
    Prompt;
  own integer
    I,
    SavePoint,
    Response,
    N;


  if (not length(C!QOldStr)) then
  begin
    W!Msg("No Previous Q-Change Command");
    T!Bell;
    C!ArgV _ 0;
    return;
  end;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  W!MsgF _ true;

  W!Msg("Q-Change: " & C!QOldStr & " to: " & C!QNewStr);

  if (not C!ChrP) then
    W!Disp(true);

  W!MsgF _ false;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  N _ 0;

  if (not C!ArgV) then
    C!ArgV _ MaxInteger;

  while (C!ArgV > 0) do
  begin
    SavePoint _ B!GetP;
    ForwardSearch(C!QOldStr);

    if (SavePoint = B!GetP) then
      C!ArgV _ -1
    else
    begin "query"
      Prompt _ "Q-Change: " & C!QOldStr & " to: " & C!QNewStr;
      W!Msg(Prompt & " ?");
      Response _ C!GetC;

      if (C!Tab[Response] land IsYes) then
      begin "change"
	W!Msg(Prompt & " [Yes]");
	incr(N);

	for I _ 1 upto length(C!QOldStr) do
	  B!Delete(BACKWARDS);

	for I _ 1 upto length(C!QNewStr) do
	  B!Insert(C!QNewStr[i for 1]);

	W!Disp(false);
      end "change"
      else
      begin
	W!Msg(Prompt & " [No]");
	W!Disp(false);
      end;

      if (C!Tab[Response] land IsAbort) then
	C!ArgV _ 0
      else
	decr(C!ArgV);
    end "query";
  end;

  W!Msg(Prompt & " [" & cvs(N) & "]");
  C!ArgV _ 0;
end "C!RepeatQChange";
!! title Rtn C!MatchDelim ;
! command to find matching delimiters ;

simple procedure C!MatchDelim;
  begin
    own integer SavePoint;
    own integer Delim, MatchDelim, Dir, DelimCount, C;

    if (( C!Cmd land '177 ) = "(" ) then
      begin
	Delim := ")";  MatchDelim := "(";
	Dir := BACKWARDS;
      end
    else if (( C!Cmd land '177 ) = ")" ) then
      begin
	Delim := "(";  MatchDelim := ")";
	Dir := FORWARDS;
      end
    else
      begin
	W!Msg( "Not set up to match that!" );
	return;
      end;

    if ( C!ArgV = 0 ) then DelimCount := 1 else DelimCount := C!ArgV;
    C!ArgV := 0;

    SavePoint := B!GetP;
    B!Move( Dir );

    while ( true ) do
      begin
	if ( Dir = FORWARDS ) and B!EndP then done;
	C := B!GetC;
	if ( C = MatchDelim ) then
	  DelimCount := DelimCount - 1
	else if ( C = Delim ) then
	  DelimCount := DelimCount + 1;
	if ( DelimCount = 0 ) then done;
	if ( Dir = BACKWARDS ) and B!BegP then done;
	B!Move( Dir );
      end;

    if ( DelimCount neq 0 ) then
      begin
	B!SetP( SavePoint );
	W!Msg( "Match Failed" );
	C!MAbort := true;
      end;
  end;
!! title Rtn FindBOP ;
! Find and return the location of the beginning of the current paragraph.
! Selects the beginning of the first line following the most recent blank
! line.
;

simple integer procedure FindBOP;
begin "FindBOP"
  integer
    BOP,
    OrigPt;

  OrigPt _ B!GetP;
  BOP    _ -1;

  if (LineEmpty) then
  begin
    while (not B!EndP and C!IsGrayP) do
      MoveForwards;

    if (not B!EndP) then
      MoveToBOL;

    BOP _ B!GetP;
  end
  else
  begin
    boolean
      CrlfSeen;
    integer
      SavePt;

    clear(CrlfSeen);
    SavePt _ -1;

    MoveBackwards;

    while (not B!BegP) do
    begin
      if (B!GetC = FF) then
      begin
        BOP _ B!GetP + 1;
        done;
      end
      else
      begin
        if (AtEOL) then
        begin
          if (CrlfSeen) then
          begin
            BOP _ SavePt;
            done;
          end
          else
          begin
            set(CrlfSeen);
            SavePt _ B!GetP + 2;
          end;
        end
        else
        begin
          if (not C!IsWhiteP) then
          begin
            clear(CrlfSeen);
            SavePt _ -1;
          end;
        end;
      end;

      MoveBackwards;
    end;

    BOP _ BOP max 0;
  end;

  B!SetP(OrigPt);
  return(BOP);
end "FindBOP";
!! title Rtn FindEOP ;
! Find and return the location of the end of the current paragraph.
! Selects end of the last line in the next block of nonempty lines.
;

simple integer procedure FindEOP;
begin "FindEOP"
  integer
    EOP,
    OrigPt;

  OrigPt _ B!GetP;

  if (LineEmpty) then
  begin
    while (not B!EndP and C!IsGrayP) do
      MoveForwards;
  end;

  if (B!EndP) then
    EOP _ B!GetP
  else
  begin
    boolean
      CrlfSeen;
    integer
      SavePt;

    clear(CrlfSeen);
    SavePt _ -1;

    while (not B!EndP) do
    begin
      if (B!GetC = FF) then
      begin
        EOP _ 
            (
              if (CrlfSeen) then
                SavePt
              else
                B!GetP
            );

        done;
      end
      else
      begin
        if (AtEOL) then
        begin
          if (CrLfSeen) then
          begin
            EOP _ SavePt;
            done;
          end
          else
          begin
            set(CrlfSeen);
            SavePt _ B!GetP;
          end;
        end
        else
        begin
          if (not C!IsWhiteP) then
          begin
            clear(CrlfSeen);
            SavePt _ -1;
          end;
        end;
      end;

      MoveForwards;
    end;

    if (B!EndP) then
      EOP _ B!GetP;
  end;

  B!SetP(OrigPt);
  return(EOP);
end "FindEOP";
!! title Rtn C!FwdHalfPara ;
! Move forward a half a paragraph.
;

simple procedure C!FwdHalfPara;
begin "C!FwdHalfPara"
  C!ArgV _ C!ArgV max 1;

  while (C!ArgV) do
  begin
    if (not LineEmpty) then
      MoveForwards;

    B!SetP(
        if (LineEmpty) then
          FindBOP
        else
          FindEOP
    );

    decr(C!ArgV);
  end;
end "C!FwdHalfPara";
!! title Rtn C!BckHalfPara ;
! Move backwards a half a paragraph.
;

simple procedure C!BckHalfPara;
begin "C!BckHalfPara"
  C!ArgV _ C!ArgV max 1;

  while (C!ArgV) do
  begin
    if (not LineEmpty) then
      MoveBackwards;

    if (LineEmpty) then
    begin
      MoveBackwards;

      while (not B!BegP and C!IsGrayP) do
        MoveBackwards;

      MoveToEOL;
    end
    else
      B!SetP(FindBOP);

    decr(C!ArgV);
  end;
end "C!BckHalfPara";
!! title Rtn DoParaFill ;
! Perform the Fill operation on some number of paragraphs, starting at
! the selected point.
;

simple procedure DoParaFill (boolean StartAtBeginning);
begin "DoParaFill"
  integer
    BegPt,                              ! Point corresponding to the
                                        ! beginning of the paragraph.
                                        ;
    Col,                                ! The column number of the
                                        ! current character.
                                        ;
    CrownOfst,                          ! The relative offset of the
                                        ! crown from the rest of the
                                        ! paragraph.
                                        ;
    EndMk,                              ! The mark corresponding to the
                                        ! end of the paragraph.
                                        ;
    LM,                                 ! The value of the left margin
                                        ! for this session.
                                        ;
    RepCnt,                             ! The number of times to perform
                                        ! paragraph fill.
                                        ;
    RM;                                 ! The value of the right margin
                                        ! for this session.
                                        ;

  LM _ C!LeftMargin max 1;

  if (C!VFMode) then
  begin
    RepCnt _ 1;
    RM     _
        if (C!ArgV) then
          C!ArgV
        else
          C!RightMargin;
  end
  else
  begin
    RepCnt _ C!ArgV max 1;
    RM     _ C!RightMargin;
  end;

  if (LM > RM) then
  begin
    T!Bell;
    W!Msg("The Left Margin (" & cvs(LM) &
        ") must be less than or equal to the Right Margin (" &
        cvs(RM) & ")");
    PuntCommand;
  end;

  EndMk  _ B!AllocateMark;

  while (RepCnt) do
  begin
    BegPt _
        (
          if (StartAtBeginning) then
            FindBOP
          else
            B!GetP
        );

    B!SetM(EndMk, FindEOP);
    B!SetP(BegPt);

    if (StartAtBeginning) then
    begin
      CrownOfst _ GetIndent;
      DownLine;
      decr(CrownOfst, GetIndent);
      B!SetP(BegPt);
      CompressGS(FORWARDS, EndMk);

      Col _ (LM + CrownOfst) max 1;
      ForceIndent(Col - 1);
    end
    else
      Col _ GetColumn;

    DoFill(Col, EndMk, LM, RM);
    CompressWS(BACKWARDS);

    if (not C!VFMode) then
      MoveForwards;

    set(StartAtBeginning);
    decr(RepCnt);
  end;

  B!DeAllocateMark(EndMk);
  C!ArgV _ 0;
end "DoParaFill";
!! title Rtn C!FillPara ;
! Fill the current paragraph from beginning to end.
;

simple procedure C!FillPara;
begin "C!FillPara"
  define
    StartAtBeginning = {true};

  DoParaFill(StartAtBeginning);
end "C!FillPara";
!! title Rtn C!FillToEOP ;
! Fill the current paragraph from the point to the end and fill
! subsequent paragraphs as usual.
;

simple procedure C!FillToEOP;
begin "C!FillToEOP"
  define
    DontStartAtBeginning = {false};

  DoParaFill(DontStartAtBeginning);
end "C!FillToEOP";
!! title Rtn C!SetLM ;
! Set the value of the Left Margin.
;

simple procedure C!SetLM;
begin "C!SetLM"
  C!LeftMargin _
      (
        if (C!ArgV > 0) then
          C!ArgV
        else
          GetColumn
      );

  W!Msg("Left Margin: " & cvs(C!LeftMargin));
  C!ArgV _ 0;
end "C!SetLM";
!! title Rtn C!SetRM ;
! Set the value of the Right Margin.
;

simple procedure C!SetRM;
begin "C!SetRM"
  C!RightMargin _
      (
        if (C!ArgV > 0) then
          C!ArgV
        else
          GetColumn
      );

  W!Msg("Right Margin: " & cvs(C!RightMargin));
  C!ArgV _ 0;
end "C!SetRM";
!! title Rtn C!SetTermType ;
! Set the Terminal type to be something other than what the monitor says.
! (Note the clever call of the "Refresh Window" command in our endgame.)
;

simple procedure C!SetTermType;
begin "C!SetTermType"
  define
    DontAskTheMonitor = {false};

  set(W!MsgF);
  W!Msg(null);
  W!Disp(false);
  T!GetTermType(DontAskTheMonitor);
  clear(W!MsgF);
  C!Refresh;
end "C!SetTermType";
!! title Rtn C!GotoColumn ;
! Try to wind up in the specified column of the current line.
;

simple procedure C!GotoColumn;
begin "C!GotoColumn"
  TryColumn
  (
    if (C!ArgV) then
      C!ArgV
    else
      C!LeftMargin
  );

  C!ArgV _ 0;
end "C!GotoColumn";


! ************************** End of COMM2.REQ ****************************;
    BSQ-!