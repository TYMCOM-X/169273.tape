


        TYM-Pascal Debugger User's Guide
        Preliminary Version








                           PROPRIETARY DOCUMENT INFORMATION
                           ----------- -------- -----------


        The  material  contained  in  this   document   is   proprietary   and
        confidential  to  Tymshare,  Incorporated,  and  is  not  to  be used,
        reproduced or disclosed except in accordance with program  license  or
        with   written   permission  from  the  legal  division  of  Tymshare,
        Incorporated, 20705 Valley Green Drive, Cupertino, California 95014.


                                Copyright (C) 1979 by 
                                            Tymshare, Inc.     




































        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page i
        Preliminary Version




                                  TABLE OF CONTENTS


        1.0 INTRODUCTION                                                     1

        1.1 Compiling a module in DEBUG mode                                 1
        1.2 Entering the Debugger                                            1

        2.0 DEBUGGER COMMAND SYNTAX                                          2

        2.1 The Command Line                                                 2
        2.2 Syntax of user-entered constants                                 2
        2.3 Referencing program text                                         2
        2.4 Referencing program data                                         4

        3.0 DEBUGGER COMMAND DESCRIPTIONS                                    6

        3.1 Inquiry commands                                                 6
        3.2 Display/modification associated commands                         9
        3.3 Execution control commands                                      14

        4.0 DEBUGGER COMMAND SUMMARY                                        17

        5.0 SAMPLE DEBUGGER SESSION                                         19

        6.0 MISCELLANEOUS                                                   22

        6.1 The Debugger symbol table file.                                 22
        6.2 Identifier length                                               22
        6.3 Debugging overlaid programs                                     23

        APPENDIX A - Listing of program from sample Debugger session        24

        APPENDIX B - Debugger syntax                                        27



















        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 1
        Preliminary Version


        1.0 INTRODUCTION


        1.1 Compiling a Module in DEBUG Mode

        The Pascal Debugger is loaded automatically by LINK-10 when  at  least
        one  of  the  Pascal  modules  being loaded has been compiled in DEBUG
        mode.

        A module may be compiled in DEBUG mode by specifying the DEBUG  option
        either on the compiler command line or as a block option following the
        PROGRAM, MODULE or DATAMODULE statement.  See  the  TYM-Pascal  User's
        Guide  for more information on specifying compiler options.  An entire
        module  must  be  compiled  in  DEBUG  mode.  There  is  currently  no
        provision  for  compiling  selected  routines within a module in DEBUG
        mode.


        1.2 Entering the Debugger

        When a program containing module(s) in DEBUG mode is run, the Debugger
        will  be  automatically entered before the first statement of the main
        program is executed.  The Debugger  may  also  be  reentered  after  a
        runtime  error,  trap,  break  or  other  abort by typing 'DDT' to the
        monitor prompt.  After a break the user also has  the  alternative  of
        typing  'CONTINUE'  to  resume  program execution without entering the
        Debugger.  However if  the  break  occurred  while  the  Debugger  was
        executing  then  both  'CONTINUE'  and  'DDT' will cause resumption of
        Debugger execution at the point where the break was typed.  While  the
        Debugger may be reentered after a runtime error or trap, resumption of
        user program execution is not allowed.
























        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 2
        Preliminary Version


        2.0 DEBUGGER COMMAND SYNTAX

        2.1 The Command Line

        The Debugger prompts for input with '>>'.  Two classes of  inputs  may
        be  keyed  in:  debugger  commands  and  requests to display or modify
        program data.  In order to avoid confusion between  Debugger  commands
        and  program  identifiers,  Debugger commands are preceded by a period
        ('.').  Each  Debugger  command  begins  with  a  keyword,  which  may
        generally  be  abbreviated,  and is followed by one or more parameters
        separated by spaces.  Display  or  modification  requests  are  simply
        normal  Pascal  data  references  or assignment statements.  Any input
        prefaced with a period will be interpreted as a Debugger command;  all
        other inputs are interpreted as display or modification requests.  Any
        number of commands or display or modification requests may be typed on
        one  command  line,  separated  by  semicolons  (';').  They  will  be
        executed sequentially from left to right, and, if one is in error, the
        following  one(s)  will  be  ignored.  When an error in a command line
        does occur, the command line is printed along with  an  uparrow  ('^')
        indicating  the  approximate position of the error.  The length of the
        longest command line which may be entered is 150  characters.  Command
        lines  are not retained when execution of the user program is resumed.
        Thus commands which cause resumption of the user program  (the  .STEP,
        .SSTEP  and .PROCEED commands) should not be followed by more Debugger
        commands on the same command line, since they will not be executed.


        2.2 Syntax of User-Entered Constants

        Integers may be entered in octal by appending an (upper or lower case)
        'B'  to  the  integer.  String  constants may be delimited by either a
        single (') or double (") quote mark.  However  the  closing  delimiter
        must  be  the same as the opening delimiter.  The delimiting character
        may be included in the string by entering it twice.  Having two string
        delimiter  characters available is especially convenient in breakpoint
        strings.  For example:

             .BREAKPOINT 1 'ERROR_MSG:="ILLEGAL VALUE";.P'

        Real numbers are entered using the standard  TYM-Pascal  syntax.  Note
        that  at  least  one  digit (possibly the digit zero) must precede the
        decimal point.  Set constants may be entered using the standard Pascal
        syntax.


        2.3 Referencing Program Text

        Several  commands  require  parameters  which reference source program
        text, e.g., the command  for  setting  a  breakpoint.  Source  program
        lines are referenced hierarchically, as follows:





        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 3
        Preliminary Version


        Module (MODULE, PROGRAM or DATAMODULE identifier)
          File (Name or number of primary source file or $INCLUDE file)
            Page (Page name or number based on $PAGE directives)
              Line (Line number within page within file)

        The   syntax  of  a  fully  qualified  reference,  referred  to  as  a
        <source reference>, is:

             <module>@<file>-<page>/<line number>

        The characters '@', '-'  and  '/'  serve  to  identify  the  preceding
        components  of  the  source  reference.  For  example,  a file name or
        number must always be followed by '-'.  If the file name or number  is
        omitted   (defaults   are   discussed   in   the   individual  command
        descriptions), then the character '-' is omitted also.

        The <module> is simply  the  identifier  which  follows  the  PROGRAM,
        MODULE  or  DATAMODULE  statement.  A  file  may be either the primary
        source file or a file included via a $INCLUDE  or  $SYSTEM  directive.
        The  file  number  is assigned by the compiler and appears in compiler
        generated listings.  A file identifier is the file name and may be  up
        to  six characters long.  Pages are defined by $PAGE directives in the
        source  program.  Page  numbers  appear  both  in  compiler  generated
        listings  and  in  listings  generated  by the utility program FORMAT.
        Page names are all contiguous  alphanumeric  and  underbar  characters
        following  the  '$PAGE'.  For  example, '$PAGE foo_bar_info--returns a
        descriptor for a foo_bar' would have page name 'foo_bar_info'.  If  no
        subtitle  follows  the  '$PAGE'  then  the page number must be used to
        reference the page.  The  file  and/or  page  is  omitted  in  <source
        reference>  printouts  by  the Debugger if the file and/or page is the
        first one, i.e., number zero.  On input, any components of  a  <source
        reference>  except the line number may be omitted.  The .DISPLAY FILES
        and .DISPLAY PAGES commands are useful for determining file  and  page
        numbers and names for modules compiled in DEBUG mode.

        Referencing statements by line number within page, rather than by line
        number within file, generally allows old listings to be  used  longer.
        An  edit  only  affects  the  line  numbers within the particular page
        rather than within the entire file.  The compiler, the FORMAT  program
        and the QED LIST command all produce listings with line numbers within
        pages.

        Lines containing the beginning of a Pascal statement, an UNTIL  clause
        or  an END keyword may be referenced.  The beginning of statements are
        indicated by the keywords identifying them, e.g., IF, CASE,  etc.,  or
        by  the  first  identifier  in a procedure call or assignment.  A line
        containing only a BEGIN, ELSE or label may not be referenced.

        Note that if the beginning of two or more statements, or  the  end  of
        two  or  more compound statements appear on a line, only the first one
        may be referenced.  The others are effectively part of the  first  one
        as  far  as  the  Debugger  is  concerned.  Thus, typing more than one
        statement on a line may not  make  for  effective  debugging  (not  to


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 4
        Preliminary Version


        mention readable code).


        2.4 Referencing Program Data

        Whenever  the  debugger is entered, all identifiers which are in scope
        at the point where program execution was suspended are  available  for
        display  or modification.  Thus all identifiers of the current routine
        and those declared in any routines which lexically enclose the current
        routine  are  available.  If  the routine was recursively called, then
        the local variables from the most recent invocation of the routine are
        available.  The  location  of  the  last  statement  executed  may  be
        displayed via the .DISPLAY LOCATION  command.  A  PUBLIC  variable  or
        constant  may  be displayed or modified whenever the module containing
        the current statement includes a PUBLIC or  EXTERNAL  declaration  for
        it.

        The  set of identifiers available for display or modification on entry
        to the debugger is  called  the  initial  scope.  This  scope  may  be
        changed  by  the user via the .OPEN command.  The current scope is the
        set of identifiers currently available for  display  or  modification,
        i.e.,  either  the  scope last opened via the .OPEN command, or, if no
        .OPEN command has been given since the Debugger was last entered, then
        the  initial  scope.  The  current  scope  may  be  displayed with the
        .DISPLAY SCOPE command.

        The .OPEN command enables the user to change the  current  scope.  The
        .OPEN  command  permits  the new scope to be specified in one of three
        ways:

        1. The scope of any active routine may be  opened  by  specifying  the
           number  of  its stack frame.  Stack frame numbers can be determined
           via the .DISPLAY STACK command.  Frames are numbered from 1,  where
           1 refers to the main program's frame.

        2. The  scope  of any routine of any module compiled in DEBUG mode may
           also be opened.  The routine need not be currently  active,  though
           local  variables  of  inactive routines may not be examined.  Using
           this method the .OPEN command takes a '<scope  reference>'  as  its
           parameter.  A  scope  reference  has the following syntax:  (square
           brackets indicate  an  optional  construct;  an  asterisk  marks  a
           construct which may be repeated zero or more times)
             <scope reference> ::=
               [<module>@] <routine name>: [<routine name>:]* [(<invocation>)]
           or
             <scope reference> ::= <module>@
           Each  routine  named  must be declared within the routine or module
           which precedes it.  The module name and '@' may be omitted only  if
           the first named routine is PUBLIC.  '<Invocation>' is an (optional)
           integer constant which specifies which invocation of a  recursively
           called  routine should be opened.  Invocation numbers are described
           in more detail in the description of the .OPEN command.



        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 5
        Preliminary Version


        3. The current scope may be reset to the initial scope by  giving  the
           .OPEN command without any parameters.

        The  current  scope  also defines the current module, i.e., the module
        containing the current  scope.  If  a  module  name  is  omitted  from
        commands referencing files, pages or lines, then the current module is
        used as the default (NOT the module containing the initial scope).
















































        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 6
        Preliminary Version


        3.0 DEBUGGER COMMAND DESCRIPTIONS


        In the following descriptions, most examples refer to a sample program
        contained  in  Appendix  A.  The  examples are collected together in a
        sample Debugger session listed in section 4.  Minimum abbreviations of
        keywords  are  underlined.  Optional constructs are enclosed in square
        brackets.  If an asterisk follows the closing bracket,  the  construct
        may be repeated zero or more times.


        3.1 Inquiry commands

        .DISPLAY <option>

             Displays  the  information  specified  by  the  option.  Possible
             options include:

             MODULES

                Lists all Pascal modules in the program.  Modules not compiled
                in DEBUG mode are indicated.

             FILES [<module>@]

                Lists  all  file(s)  and  their  number(s) in a module, or the
                current module, if none is specified.  This command may not be
                used   with   modules   which  contain  no  executable  Pascal
                statements, e.g., datamodules.

             PAGES [<module>@][<file>]

                Lists all pages in a  file  (within  a  module).  The  current
                module  and/or  file  zero  are  assumed  if  parameter(s) are
                omitted.  This command may  not  be  used  with  files  within
                modules  which  contain no executable Pascal statements, e.g.,
                datamodules.

             For example, in the sample program:

                  >> .DISPLAY MODULES
                  TEST F
                  >> .DISPLAY FILES
                  0 FORMAT
                  >> .DISPLAY PAGES
                  2 mainline
                  1 f format
                  0

             LOCATION

                Prints the location of the current statement  and  the  reason
                the  Debugger was entered (only the location is printed if the


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 7
        Preliminary Version


                entry is due to a .STEP or .SSTEP command).  The name  of  the
                routine  containing the current statement is also printed.  In
                all location printouts, if the number of the page or  file  is
                zero, it is omitted.

             BREAKPOINTS

                Prints  the  location(s)  and  number(s)  of  all  breakpoints
                currently set.

             For example, at the first statement of routine CNVT in the sample
             program:

                  >> .DISPLAY LOCATION
                  Breakpoint #0 at TEST F@17 in CNVT
                  >> .DISPLAY BREAKPOINTS
                  0 TEST F@17
                  1 TEST F@1/26

             SCOPE

                Prints   the  module  and  routine(s)  whose  identifiers  are
                currently in scope.  The module is  printed  first,  and  then
           routine(s)   from   outermost   to   innermost.  Several  core
                addresses are also printed.  HISEG is the first  word  of  the
                module's  high  segment  (code)  section,  while LOWSEG is the
                beginning of its static storage section.  BASIS is the address
                of  a  routine's  stack  frame.  It  shows  which  frame  of a
                recursively called routine  is  currently  in  scope,  as  the
                example following the next option demonstrates.

             STACK [<stack frame count>]

                Displays  the  current  state  of  the  stack.  If no count is
                specified, information on the entire stack is  printed.  If  a
                count  is  specified, that number of frames, starting with the
                innermost (the frame of the  current  routine),  are  printed.
                BASIS  is  the stack frame address, and LVL, the lexical level
                of the routine  (0=Main,  1=first-level  routine  (potentially
                PUBLIC),  etc.).  LOC  is the location of the first executable
                statement of  the  routine  and  CALL,  the  location  of  the
                statement  within the calling routine where the call was made.
                A Debugger-style location is printed if possible; otherwise, a
                high segment address is printed.

             For  example,  after the second (recursive) call to routine CNVT,
             the following output  from  .DISPLAY  SCOPE/STACK  results.  Note
             that  the  BASIS in SCOPE is the second (innermost) BASIS of CNVT
             in the .DISPLAY STACK output.

             Breakpoint #0 at TEST F@17 in CNVT
             >> .DISPLAY SCOPE
             TEST F        (HISEG=400010,LOWSEG=140)


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 8
        Preliminary Version


             I FORMAT      (BASIS=6364)
             CNVT          (BASIS=6433)
             >> .DISPLAY STACK
             5 CNVT         BASIS=6433 LVL=2 LOC=TEST F@17 CALL=TEST F@18
             4 CNVT         BASIS=6407 LVL=2 LOC=TEST F@17 CALL=TEST F@25
             3 I FORMAT    BASIS=6364 LVL=1 LOC=TEST F@25 CALL=TEST F@1/25
             2 F FORMAT    BASIS=6315 LVL=1 LOC=TEST F@1/20 CALL=TEST F@2/26
             1 TEST FORMA  BASIS=6305 LVL=0 LOC=400736

        .HELP or .COMMANDS

             Lists all Debugger commands.

        .KIND <source reference>

             Lists the  'kind'  of  the  referenced  statement.  The  possible
             statement  kinds  are:  assignment  statement, procedure call, IF
             statement, FOR statement, LOOP statement, WHILE  statement,  CASE
             statement,  WITH statement, GOTO statement, I/O statement, RETURN
             statement, STOP statement,  EXIT  clause,  UNTIL  clause,  REPEAT
             statement  and  END keyword.  The only mandatory component of the
             <source reference> is  the  line  number.  Defaults  for  omitted
             components  are the same as those described under the .BREAKPOINT
             command (which is described in section 3.3).

        .VERSION

             Prints the Debugger's version number.



























        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 9
        Preliminary Version


        3.2  Display/Modification and Associated Commands


        .OPEN [ <scope reference>    ]
              [ <stack frame number> ]

             Allows identifiers in other than the initial scope (as defined by
             the  current point in program execution) to be accessed.  It also
             defines the current module, which  is  used  as  the  default  in
             commands taking a module name, e.g., BREAKPOINT.  A new scope can
             be specified by (1) completely elaborating it from the  outermost
             level (module@routine:routine: . . . ), or (2) specifying a stack
             frame  to  be  opened.  The  latter  method  is  often  the  most
             convenient  way  to  open  a particular recursive invocation of a
             routine, although the first form may also be used.

             For instance, after the second (recursive) call to  CNVT  in  the
             sample program, the situation is this:

             Breakpoint #0 at TEST F@17 in CNVT
             >> .DISPLAY SCOPE
             TEST F        (HISEG=400010,LOWSEG=140)
             I FORMAT      (BASIS=6364)
             CNVT          (BASIS=6433)
             >> .DISPLAY STACK
             5 CNVT         BASIS=6433 LVL=2 LOC=TEST F@17 CALL=TEST F@18
             4 CNVT         BASIS=6407 LVL=2 LOC=TEST F@17 CALL=TEST F@25
             3 I FORMAT    BASIS=6364 LVL=1 LOC=TEST F@25 CALL=TEST F@1/25
             2 F FORMAT    BASIS=6315 LVL=1 LOC=TEST F@1/20 CALL=TEST F@2/26
             1 TEST FORMA  BASIS=6305 LVL=0 LOC=400736

             At  this  point,  identifiers defined in the second invocation of
             CNVT, I FORMAT, and the main program are in  scope.  However,  as
             both I FORMAT and CNVT have a parameter NUM, and we are currently
             in CNVT, requesting NUM would access the  identifier  defined  in
             CNVT, whose current value is 10.

             To  examine  NUM in I FORMAT, we must open the scope of I FORMAT,
             without including CNVT.  This can be done by typing:

                  >> .OPEN TEST FORMAT@I FORMAT:
                  >> NUM
                  100
                  >> .DISPLAY SCOPE
                  TEST F            (HISEG=400010,LOWSEG=140)
                  I FORMAT          (BASIS=6364)

             Alternately, I FORMAT's stack frame could  have  been  specified,
             e.g.,

                  >> .OPEN 3
                  >> .DISPLAY SCOPE
                  TEST F            (HISEG=400010,LOWSEG=140)


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 10
        Preliminary Version


                  I FORMAT          (BASIS=6364)
                  >> NUM
                  100

             The number 3 was obtained from the previous .DISPLAY STACK.  Note
             that since frames are numbered from the main down, the number  of
             an  invocation  of  a  routine  does  not  change as long as that
             invocation is active, thus obviating the need to  .DISPLAY  STACK
             each time you want to open the same invocation.

             To  examine  the  value of NUM the first time CNVT was called, an
             invocation number can be specified on the first  form  of  .OPEN,
             e.g.,

                  >> .OPEN TEST FORMAT@I FORMAT:CNVT:(2)
                  >> NUM
                  100

             Invocation  1  corresponds  to  the  most  recent invocation of a
             routine, and is the default if no number is specified.  2 is  the
             next most recent, 3 the one below it, etc.

             In  this form of .OPEN, if the specified or default invocation of
             the  rightmost  routine  cannot  be  found,  the   least   recent
             invocation  is used.  If no invocation of the rightmost is found,
             the stack is examined for an invocation  of  the  next  rightmost
             routine  with  the proper invocation number.  If no invocation of
             this routine is found, the process is repeated with the remaining
             routines specified, from right to left.

             Instead  of specifying an invocation number, the first invocation
             of CNVT could have been opened via its stack number, e.g.,

                  >> .OPEN 4

             Finally, at any time, the default scope can be re-established  by
             merely typing .OPEN, e.g.,

                  >> .OPEN

        .WITH [<record reference>[,<record reference>]*]

             The  .WITH  command,  like  the Pascal WITH statement, allows the
             identifiers of fields within record variable(s) to be  referenced
             without  qualification.  For  example,  if  F FORMAT  is  in  the
             current scope:

                  >> .OPEN TEST FORMAT@F FORMAT:
                  >> .WITH FMT DESC
                  >> FIELD WIDTH
                  6
                  >> FRAC WIDTH
                  2


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 11
        Preliminary Version


             Each .WITH command overrides the previous .WITH  command,  unlike
             the  Pascal WITH statement.  However, the reference(s) in the new
             .WITH are resolved in the scope  of  the  previous  .WITH,  i.e.,
             fields  of  record type within a previously .WITHed record may be
             directly referenced in a subsequent .WITH.  The advantage of this
             is  that you can sequence through a chain of records via a series
             of .WITHs, e.g.,

                  TYPE P:^RECORD
                           ...
                           NEXTP:P;
                           ...
                          END;
                  VAR HEADP:P;

                  >> .WITH HEADP^
                     access first record
                  >> .WITH NEXTP^   (in HEADP^record)
                     access second
                  >> .WITH NEXTP^   (in second)
                     etc.

             To simultaneously open the scope of several records, type all the
             names on the same .WITH command.  All the record references given
             will be resolved in the scope existing prior to the command; this
             is also unlike the Pascal WITH statement.

             If  .WITHs  are in effect when program execution is resumed, they
             will be preserved when the Debugger is reentered if  the  routine
             containing  the current statement has not changed.  Thus, you can
             establish .WITHs once, and step through a  routine.  However,  if
             the routine is different on Debugger entry, any active .WITHs are
             automatically deactivated.

             If a .WITH command is given without any  parameters,  all  active
             .WITH's  are  cleared.  An .OPEN command also clears any existing
             .WITHs.

        <reference>

             Displays the value of the specified program variable or constant.
             Array  subscripting  (  off_array[x,y] ), pointer dereferencing (
             oof_ptr^ ), and  field  selection  (  oof_rec.field1  )  are  all
             permissible.  Array  subscripts  may  be  any  <reference> of the
             appropriate type.  Integers and arrays of integers may be printed
             in octal by appending ':o' or ':O' to the reference.

             The  reference may be to an object of any type, including records
             and arrays.  The only restriction is that the object may not be a
             record  which  includes an undiscriminated union (i.e., a variant
             part for which a tag type but no tag field identifier is  given).
             If  an  array  is  specified  the  entire array is printed.  If a
             record is specified the  entire  record  is  printed  with  field


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 12
        Preliminary Version


             values  labeled with the corresponding field identifier.  Part of
             an array ( a 'slice' of the array) may also be printed using  the
             special syntax:

                some_array[m..n]

             This  '..'  notation will cause elements 'm' through 'n' of array
             some_array to be displayed.  The  type  of  the  elements  to  be
             printed   is   arbitrary   except   for   the   restriction  that
             undiscriminated unions are  not  allowed.  Multiple  indices  may
             also be present.  However, only one slice may be specified and it
             must be  the  last  'index'  given.  Examples  are  given  below.
             Substrings      may     also     be     printed     using     the
             'some_string[start:length]' syntax.

             Examples:
                  A2D is a two dimensional array:
                  >> A2D
                     1   2   3   4   5
                     5   4   3   2   1
                   507 508 509 510 511
                  >> A2D[2..3]
                     5   4   3   2   1
                   507 508 509 510 511
                  >> A2D[3,2..4]
                   508 509 510

                  SOME_STRING is a (fixed or varying length) string:
                  >> SOME_STRING
                  'ILLEGAL VALUE ENTERED'
                  >> SOME_STRING[3:11]
                  'LEGAL VALUE'

             <reference> := <elementary value>

                  The value of any elementary  (set,  string,  integer,  char,
                  boolean,  real,  pointer, file and enumerated types) program
                  variable may be changed.  Constants and value parameters may
                  not  be changed.  The <elementary value> may be any constant
                  or reference of type compatible  with  the  left  hand  side
                  object.  Thus  any  non-aggregate  (i.e.,  not  an  array or
                  record) assignment  statement  may  be  typed.  In  addition
                  pointers  may  be  assigned user-keyed-in integer constants.
                  In this context, the  integer  constant  is  assumed  to  be
                  octal, even if not terminated with a 'b'.  Pointer variables
                  may also  be  assigned  the  value  of  another  pointer  of
                  compatible type.  Substrings of strings may also be assigned
                  to by using the [start:length] syntax on the left hand  side
                  of the assignment.

                  Examples:
                       >> CURRENT_NODE := 14307  (* Ptr assign, RHS octal *)
                       >> COLORS := [RED..GREEN,CHARTREUSE]  (* Set assign *)


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 13
        Preliminary Version


                       >> MESSAGE := 'BAD INPUT LINE'  (* String assignment *)
                       >> MESSAGE[5:10] := 'VIBES'  (* Substring assignment *)
                       >> MESSAGE
                       'BAD VIBES     '

             .WHERE <reference>

                  Prints  the core address of any addressable reference (which
                  may be of any type).  Local variables of  inactive  routines
                  and user entered constants are not addressable.













































        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 14
        Preliminary Version


        3.3  Execution Control Commands

        .STOP

             Terminates  program  execution,  closes all files, and returns to
             the monitor.  Program execution may not be resumed subsequently.

        .ABORT

             Exit to the monitor without closing files.  Program execution may
             be resumed if the Debugger is reentered.

        .BREAKPOINT <source reference> [<string>]

             Sets a breakpoint at the specified line and prints the breakpoint
             number assigned.  Up to ten breakpoints are allowed.  The default
             module,  if  none  is specified in the <source reference>, is the
             current module, i.e.,  the  one  containing  the  currently  open
             scope.  If  a  file,  but no page, is specified, page zero in the
             file is assumed.  If a page, but no file, is specified, the  page
             is  assumed  to  be  in  file  zero.  If  only  a  line number is
             specified:

                  1.  If at the first statement in the main program, or if the
                  current  (default)  module  does  not  contain  the  current
                  statement (which can be determined with .DISPLAY  LOCATION),
                  then  page  zero  in  file  zero  in  the  current module is
                  assumed.

                  2.  If the current module contains  the  current  statement,
                  then  the  line number is assumed to refer to a statement in
                  the page containing the current statement.

             If a breakpoint cannot be set on the specified line, the Debugger
             will  ask  you  if  you want it on the closest line with a larger
             number on which a breakpoint can be set.  'YES', 'Y', or <cr> may
             be  typed  to  set  the  breakpoint;  'NO' or 'N' will cancel the
             command.  For example, on the first Debugger entry in the  sample
             program:

                  >> .BREAKPOINT 1
                  Line 17 instead?
                  Break #0 set.
                  >> .BREAKPOINT F FORMAT/26
                  Break #1 set.

             If  a  string  is  specified,  its contents will be automatically
             executed as a line of command input every time the breakpoint  is
             encountered.  Any and all commands or requests may be included in
             the string.  In the example above, if the user had always  wanted
             to  print  the  value  of  NUM and execute the next statement, he
             would have typed:



        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 15
        Preliminary Version


                  >> .BREAKPOINT 1 'NUM;.SSTEP'

        .CLEAR [<breakpoint number>]

             Clears the specified breakpoint.  To determine the  number  of  a
             breakpoint,  .DISPLAY  BREAKPOINTS  can be used.  If no number is
             typed, the Debugger assumes all are to be cleared,  and  requests
             confirmation before clearing them.  For example,

                  >> .DISPLAY BREAKPOINTS
                  0 TEST F@1/39
                  1 TEST F@1/26
                  >> .CLEAR
                  Clear all?

        .IF <boolean expr> THEN <statement> [ ELSE <statement> ]

             The  .IF  command  provides  conditional  execution  of  Debugger
             commands.  The <boolean expr>  is  an  arbitrary  Pascal  boolean
             expression,  i.e.,  it  is an arbitrary boolean valued expression
             composed  from   <reference>s,   the   relational   operators   (
             =,<>,<=,<,>=,>  ), the IN operator, parentheses and the operators
             AND, OR and NOT.  In addition, the relational operators have been
             extended  to  permit  pointers,  file  variables  and  subroutine
             variables to be compared to  (user  entered)  integer  constants.
             When  an  integer  is  compared  to  a  pointer, file variable or
             subroutine variable, the radix of the constant is assumed  to  be
             octal.  Otherwise  the  Debugger  enforces  the same restrictions
             which Pascal places on  the  use  of  relational  operators.  For
             example,  pointers  may  only be compared using the operators '='
             and '<>'.  The <statement> is an arbitrary  Debugger  command  or
             display  or  modification request.  Multiple commands or requests
             may be included in the THEN or  ELSE  clause  by  bracketing  the
             statements with BEGIN and END (see the example below).

             The   primary  value  of  the  .IF  command  is  that  it  allows
             conditional breakpoints.  There  are  several  common  situations
             where  this  ability  is  useful.  For  example, it can provide a
             'hook' when you wish to stop at a source line in the middle of  a
             loop.  If  a  linked list is being traversed and you wish to halt
             when 'OOF_PTR' is pointing to a  specific  list  node,  then  the
             following command could be used.
                  .BREAKPOINT 14 '.IF OOF_PTR <> 43782 THEN .P'
             Another  common situation is when a variable is being assigned an
             unexpected value at some unknown time.  If the  location  of  the
             assignment is known, then the following command could be useful:
                  .BREAKPOINT 1 '.IF (FOO >= 0) AND (FOO <= 255) THEN .P
                       ELSE BEGIN "FOO OUT OF RANGE:  "; FOO END'
             In  certain  circumstances  the  .IF  command may also be used to
             'patch' an incorrect program.  In the example  Debugger  session,
             routine  CNVT is patched so that it works correctly in subsequent
             testing.  This is done with the following command:
                  .BREAKPOINT 20 '.IF NUM = 10 THEN CNVT := "10"; .P'


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 16
        Preliminary Version


        .PROCEED [<breakpoint count>]

             Resumes  program  execution  until   the   next   breakpoint   is
             encountered  (if  no  count is given).  If a count is typed, that
             number of breakpoints must be encountered before the Debugger  is
             reentered.  Note  that  if  n  is  the  number typed, on the n-th
             breakpoint the Debugger will  be  entered.  Thus,  .PROCEED 1  is
             equivalent to .PROCEED.

        .SSTEP [<statement count>]

             Return  to  the Debugger after the specified number of statements
             have been executed.  If no number  is  given,  execute  the  next
             statement.  The  Debugger will also be entered if a breakpoint is
             encountered before the step count  is  exhausted.  .SSTEP  counts
             statements  executed  in  routines  called from the routine where
             execution was resumed, i.e., it steps into called routines.

        .STEP [<statement count>]

             Same as .SSTEP except routine calls are counted as one  statement
             (unless a breakpoint is encountered in a called routine, in which
             case stepping ceases).  For example, in  the  sample  program,  a
             .STEP  issued  at TEST F@1/26 in F FORMAT returns to the Debugger
             at TEST F@1/28:

                  Breakpoint #1 at TEST F@1/26 IN F FORMAT
                  >> .STEP
                  at TEST F@1/28 IN F FORMAT

             A  .SSTEP  at  TEST F@18  in  CNVT  stops  at  TEST F@17   (first
             executable statement in recursive call to CNVT):

                  >> .SSTEP
                  at TEST_F@18 in CNVT
                  >> .SSTEP
                  at TEST_F@17 in CNVT


















        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 17
        Preliminary Version


        4.0  Debugger Command Summary

        The  following is a summary of the Debugger commands and of the syntax
        of some of the parameters.  In  the  following  descriptions,  minimal
        abbreviations  are underlined, and optional parameters are enclosed in
        brackets ([]).  If the parameter in brackets is asterisked, it may  be
        repeated zero or more times.  The complete debugger syntax is given in
        Appendix A.

        .ABORT

        .BREAKPOINT <source reference> [<string>]

        .CLEAR [<breakpoint number>]

        .COMMANDS

        .DISPLAY BREAKPOINTS
                 FILES [<module>@]
                 LOCATION
                 MODULES
                 SCOPE
                 STACK [<number of frames>]
                 PAGES [<module>@][<file>]

        .HELP

        .IF <boolean expr> THEN <statement> [ELSE <statement>]

        .KIND <source reference>

        .OPEN [ <scope reference>    ]
              [ <stack frame number> ]

        .PROCEED [<breakpoint count>]

        .SSTEP [<statement count>]

        .STEP [<statement count>]

        .STOP

        .VERSION

        .WITH [<record reference> [,<record reference>]*]

        .WHERE <reference>

        <statement> ::= <simple statement> | <compound statement>

        <simple statement> ::= <debugger command>            |
                               <display/modification request>



        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 18
        Preliminary Version


        <compound statement> ::= BEGIN <statement> [;<statement>]* END

        <source reference>::=
           [<module>@] [<file>-] [<page>/] <line number>

        <scope reference>::=
           [<module>@] <routine name>: [<routine name>:]* [(<invocation>)]
         | <module>@
         | [ <stack frame number> ]














































        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 19
        Preliminary Version


        5.0  Sample Debugger Session

        This annotated Debugger session shows a user  finding  a  bug  in  the
        attached  sample  program.  The program exercises a simplistic routine
        to print a real number in a FORTRAN-style F format.  The bug  is  that
        100  in an F6.2 format is output as ":0.00".  As he knows that the bug
        must be in the conversion of the integer  part,  the  user  begins  by
        setting two breakpoints, one at the beginning of routine CNVT, and the
        other in  F FORMAT  immediately  after  the  call  to  I FORMAT  which
        converts the integer part.  Text keyed in by the user is underlined.

        >> .DISPLAY MODULES        (start by displaying status
        TEST_F                     information for later use)
        >> .DISPLAY FILES
        0 FORMAT
        >> .DISPLAY PAGES
        2 mainline
        1 f_format
        0
        >> .BREAKPOINT 1           (default page at beginning of 
        Line 17 instead?           program execution is zero, i.e., the
        Break #0 set.              one containing I_FORMAT)
        >> .BREAKPOINT F_FORMAT/26 (after call to I_FORMAT)
        Break #1 set.
        >> .DISPLAY BREAKPOINTS    (make sure breakpoints were 
        0 TEST F@17                set correctly)
        1 TEST F@1/26
        >> .PROCEED                (off to the races)
        total fw: 6
        frac fw: 2
        *100
        Breakpoint #0 at TEST F@17 in CNVT
        >> .DISPLAY SCOPE
        TEST F   (HISEG=400010,LOWSEG=140)
        I FORMAT (BASIS=6364)
        CNVT     (BASIS=6407)
        >> .DISPLAY LOCATION       (where we want to be)
        Breakpoint #0 at TEST F@17 in CNVT
        >> .SSTEP                  (step the IF test)
        at TEST F@18 in CNVT
        >> .SSTEP                  (step into CNVT for the second time)
        at TEST_F@17 in CNVT
        >> .DISPLAY STACK          (make sure two calls to CNVT on stack)
        5 CNVT         BASIS=6433 LVL=2 LOC=TEST F@17 CALL=TEST F@18
        4 CNVT         BASIS=6407 LVL=2 LOC=TEST F@17 CALL=TEST F@25
        3 I FORMAT     BASIS=6364 LVL=1 LOC=TEST F@25 CALL=TEST F@1/25
        2 F FORMAT     BASIS=6315 LVL=1 LOC=TEST F@1/20 CALL=TEST F@2/26
        1 TEST FORMA   BASIS=6305 LVL=0 LOC=400736
        >> NUM                     (parameter value to 2nd call of CNVT)
        10
        >> .SSTEP                  (step IF test again)
        at TEST_F@19 in CNVT       (oops--CNVT not called again!!)
        >>.OPEN TEST_FORMAT@I_FORMAT:  (check everything in sight to find


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 20
        Preliminary Version


                                       error)
        >> NUM                     (parameter to I_FORMAT)
        100
        >> .DISPLAY SCOPE          (make sure OPEN worked)
        TEST F     (HISEG=400010,LOWSEG=140)
        I FORMAT   (BASIS=6364)
        >> .OPEN 3                 (open by stack frame to be sure)
        >> .DISPLAY SCOPE          (notice scope is the same as above)
        TEST F     (HISEG=400010,LOWSEG=140)
        I FORMAT   (BASIS=6364)
        >> NUM                     (as is the parameter)
        100
        >> .OPEN TEST_FORMAT@F_FORMAT: (check format passed to F_FORMAT)
        >> .WITH FMT_DESC          (open the scope of the record)
        >> FIELD_WIDTH             (in FMT_DESC)
        6
        >> FRAC_WIDTH              (in FMT_DESC)
        2
        >> RNUM                    (parameter to F_FORMAT)
        1.000000000E+02
        >> .OPEN TEST_FORMAT@I_FORMAT:CNVT(2)
        >> NUM                     (check parameter to CNVT on 1st call)
        100
        >> .OPEN                   (everything's OK--return to 
        >> .SSTEP                  default scope)
        at TEST F@20 in CNVT
        >> CNVT                    (here's the bug--">"in IF should
        ':'                        be ">=")
        >> CNVT:='10'              (fix up answer to what it should be)
        >> .CLEAR 0                (clear breakpoint in CNVT)
        >> .BREAKPOINT 26          (after 1st call to CNVT in I_FORMAT)
        Break #0 set.
        >> .PROCEED
        Breakpoint #0 at TEST F@26 in I FORMAT
        >> I_FORMAT                (check answer returned by I_FORMAT)
        '100'
        >> .CLEAR 0                (it's OK--clear this breakpoint)
        >> .PROCEED                (return from I_FORMAT)
        Breakpoint #1 at TEST F@1/26 in F FORMAT
        >> .STEP                   (step over call to I_FORMAT
        at TEST F@1/28 IN F FORMAT  for fraction)
        >> .DISPLAY SCOPE
        TEST  F    (HISEG=400010,LOW=140)
        F FORMAT   (BASIS=6315)
        >> INTPART                 (check values of variables 
        '100'                      in F_FORMAT)
        >> FRACPART
        '00'
        >> .STEP                   (looks good--step ACTUAL_FW 
        at TEST F@1/30 in F FORMAT computation)
        >> ACTUAL_FW
        6
        >> .BREAKPOINT 39          (set breakpoint at end of F_FORMAT.


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 21
        Preliminary Version


        Break #0 set.              Notice that default page is one
        >> .PROCEED                containing current statement.)
        Breakpoint #0 at TEST F@1/39 in F FORMAT
        >> F_FORMAT                (check the answer--its OK)
        '100.00'
        >> .DISPLAY BREAKPOINTS
        0 TEST F@1/39
        1 TEST F@1/26
        >>.CLEAR                   (clear all breakpoints)
        Clear all?
        >> .BREAKPOINT 20 '.IF NUM = 10 THEN CNVT := "10"; .P'
                                   (patch so error won't show
        Break #0 set.               up in subsequent testing)
        >> .PROCEED                (continue to print the answer)
        100.00                     (ta-dum--the right answer)
        *
        total fw: 6                (try again with patch in)
        frac_fw: 2
        *100
        100.00



































        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 22
        Preliminary Version


        6.0  MISCELLANEOUS


        6.1 The Debugger Symbol Table File

        When a module is compiled in DEBUG mode, special blocks of information
        used by the Debugger are inserted in the generated code,  and  a  file
        containing  the  runtime  symbol table is produced.  This file has the
        same name as the relocatable binary file but  with  extension  '.DEB',
        and  is  always written in the same directory as the relocatable file.
        The name of the symbol table file, including the  directory  where  it
        was  written,  is  recorded  in a special 'program' block in the code,
        i.e., in the '.REL' file.  When the  Debugger  must  open  the  symbol
        table  file  for  a  module  it first attempts to open the symbol file
        recorded in the .REL file.  If this  fails,  it  attempts  to  open  a
        symbol  file  of  the appropriate name in the current directory search
        list.  If this also  fails,  an  error  message  is  printed  and  the
        Debugger stopped.  Thus, either:

          1. a .DEB file should be left in the directory where it was created,
             or,
          2. it should be moved to a directory in the  search  list  of  every
             user  who  will  (may)  run a version of a program built with the
             corresponding DEBUG mode .REL file.  One usually effective way of
             accomplishing  this  is  to  move  .REL  and  .DEB  files  around
             together.

        In either case .DEB files must be read  accessible  to  users  running
        programs built with corresponding DEBUG mode .REL files.

        The  date  and  time  of the compilation are recorded in both the .DEB
        file and the .REL file.  When a .DEB file is opened the date and  time
        in  it  are  compared  to  the date and time in the corresponding .REL
        file.  If the date and time do not match then the Debugger treats  the
        relevant  Pascal module as if it was not compiled in DEBUG mode.  Thus
        displaying or assigning  to  variables  would  be  forbidden.  Such  a
        day/time  mismatch  can  occur if, for example, a module is recompiled
        but the corresponding program is run  before  it  is  relinked.  If  a
        mismatch  does  occur  then  an  error  message to that effect will be
        printed along with the name of the source file.  The file named should
        then be recompiled and the program should be relinked.


        6.2 Identifier Length

        TYM-Pascal  allows  identifiers  of  arbitrary  length.  The  Debugger
        however retains only the first 40 characters of identifiers entered by
        the  user.  If the user enters an identifier longer than 40 characters
        it is truncated to 40 characters.  When it is looked up in the  symbol
        table of the .DEB file, the symbol table entries are also truncated to
        40 characters before being compared with the user entered identifier.




        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 23
        Preliminary Version


        6.3 Debugging Overlaid Programs

        There are certain restrictions on the use  of  the  Debugger  with  an
        overlaid  program.  The  restrictions  all relate to the use of module
        names where the named module resides in an overlay.  The Debugger uses
        the  LINK-10  symbol  table to locate modules whose names are given as
        parameters to  Debugger  commands.  However,  the  link  symbol  table
        available  in  an overlaid program is the one resulting from the build
        of the resident portion of the program.  Thus the  names  of  overlaid
        modules  are inaccessible to the Debugger.  In any command which takes
        a module name as a parameter only the names of modules in the resident
        portion   of   the   program  may  be  specified.  This  includes  the
        .BREAKPOINT,  .DISPLAY  FILES,  .DISPLAY  PAGES  and  .OPEN   command.
        However  these  commands  may  be used with modules in overlays in the
        following way.  Note that if the  module  name  is  omitted  in  these
        commands,   the  current  module,  i.e.,  the  module  containing  the
        currently open scope, is used by default.  Thus to set a breakpoint in
        an  overlaid  module  or to display the files in an overlay module the
        user need only first open the module  using  the  .OPEN  command.  The
        name  of  the  overlaid module may not be used to open the module, but
        two other methods are  available.  First,  if  a  routine  within  the
        module is active then that routine may be opened by specifying a stack
        frame number (from the .DISPLAY  STACK  command).  Alternatively,  the
        user  may  open  a (possibly inactive) routine of the module using the
        syntax:
             .OPEN <routine name>: [ <routine name>: ]* [ (<invocation>) ]
        Using this method, the first named routine must be PUBLIC.

        In summary, when using the  Debugger  with  an  overlaid  program  the
        following  should  be  kept in mind.  The name of module in an overlay
        should never be  included  as  a  parameter  to  a  Debugger  command.
        Instead  the  relevant module should first be .OPENed using one of the
        two methods described above.  Commands may then be given  without  the
        module  name.  The  Debugger  will  use  the  currently open module by
        default.




















        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 27
        Preliminary Version


        APPENDIX B - DEBUGGER SYNTAX

        The Debugger's syntax is listed in full below.  The  conventions  used
        were   described  earlier,  with  the  following  exception.  Where  a
        metacharacter conflicts with a terminal symbol, the terminal symbol is
        bracketed with single quotes, e.g., '['.


        <command line> ::= <statement> [ ; <statement> ]* <end of line>

        <statement> ::= <compound statement> |
            <simple statement>

        <compound statement> ::= begin <statement> [ ; <statement> ]* end

        <simple statement> ::= <debugger command> |
            <display/modification request>

        <debugger command> ::= <abort command> |
            <breakpoint command> |
            <clear command> |
            <commands command> |
            <display command> |
            <help command> |
            <if command> |
            <kind command> |
            <open command> |
            <proceed command> |
            <sstep command> |
            <step command> |
            <stop command> |
            <version command> |
            <with command> |
            <where command>

        <display/modification request> ::= <display request> |
            <modification request>

        <display request> ::= <cons or ref>

        <modification request> ::= <reference> := <cons or ref>

        <abort command> ::= .ABORT

        <breakpoint command> ::= 
            .BREAKPOINT <source reference> [ string-constant ]

        <clear command> ::= .CLEAR [ <breakpoint number> ]

        <display command> ::= .DISPLAY <display option>

        <display option> ::= BREAKPOINTS |
            FILES [ <module> @ ]  |


        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 28
        Preliminary Version


            LOCATION  |
            MODULES  |
            PAGES [ <module> @ ] [ <file> ]
            SCOPE  |
            STACK  [ <number of frames> ]  |

        <help command> ::= .HELP

        <if command> ::= 
            .IF <boolean expression> THEN <statement>
                 [ ELSE <statement> ]

        <kind command> ::= .KIND <source reference>

        <open command> ::= .OPEN [ <scope reference> ] |
            .OPEN [ <stack frame number> ]

        <proceed command> ::= .PROCEED [ <breakpoint count> ]

        <sstep command> ::= .SSTEP [ <statement count> ]

        <step command> ::= .STEP [ <statement count> ]

        <stop command> ::= .STOP

        <version command> ::= .VERSION

        <with command> ::= 
            .WITH [ <record reference> [ , <record reference> ]* ]

        <where command> ::= .WHERE <reference>

        <source reference> ::=  
            [ <module>@ ] [ <file>- ] [ <page>/ ] <line number>

        <module> ::= identifier

        <file> ::= identifier | integer-constant

        <page> ::= identifier  |  integer-constant

        <line number> ::= integer-constant

        <breakpoint number> ::= integer-constant

        <number of frames> ::= integer-constant

        <boolean expression> ::= <term> [ <relop> <term> ]

        <relop> ::= IN | = | <> | <= | < | >= | >

        <term> ::= <factor> [ OR <factor> ]*



        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 29
        Preliminary Version


        <factor> ::= <unary expr> [ AND <unary expr> ]*

        <unary expr> ::= [ NOT ] <primitive expr>

        <primitive expr> ::= <cons or ref>  |  ( <boolean expression> )

        <scope reference> ::= <module>@  |
            [<module>@] <routine name>: [<routine name>:]* [(<invocation>)]

        <routine name> ::= identifier

        <invocation number> ::= integer-constant

        <stack frame number> ::= integer-constant

        <breakpoint count> ::= integer-constant

        <statement count> ::= integer-constant

        <record reference> ::= <reference>

        <reference> ::= <substring ref>  |
            <slice ref>  |
            <other ref>

        <substring ref> ::=
            <other ref> '[' <cons or ref> : <cons or ref> ']'

        <cons or ref> ::= <constant> | <reference>

        <slice ref> ::= <other ref> '[' [ <cons or ref>, ]* <range> ']'

        <range> ::= <cons or ref>..<cons or ref>

        <other ref> ::= <field ref>  |
            <indexed ref>  |
            <pointer ref>  |
            identifier

        <field ref> ::= <other ref>.identifier

        <indexed ref> ::= 
            <other ref> '[' <cons or ref> [ ,<cons or ref> ]* ']'

        <pointer ref> ::= <other ref>^

        <constant> ::= integer-constant  |
            real-constant  |
            string-constant  |
            <set constant>

        <set constant> ::= '[' [ <set element> [ ,<set element> ]* ] ']'



        3 July 1979






        TYM-Pascal Debugger User's Guide                              Page 30
        Preliminary Version


        <set element> ::= <cons or ref>  |  <range>






















































        3 July 1979




  v?*