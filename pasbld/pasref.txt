


                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual         Page i








                          PROPRIETARY DOCUMENT INFORMATION
                          ----------- -------- -----------


             The material contained in this document is proprietary  and
             confidential  to  TYMSHARE,  Incorporated, and is not to be
             used, reproduced, or disclosed except  in  accordance  with
             program  license  or with written permission from the legal
             division of  TYMSHARE,  Incorporated,  20705  Valley  Green
             Drive, Cupertino, California 95014.



                                      May 1981





































                                           
                                           
                                           
               Tymshare Pascal Language Reference Manual       Page ii


                                      Contents
























































                                           
                                           
                                           
               Tymshare Pascal Language Reference Manual       Page iv


                                      Contents
























































                                           
                                           
                                           
               Tymshare Pascal Language Reference Manual       Page iv


                                      Contents
























































                                           
                                           
                                           
               Tymshare Pascal Language Reference Manual       Page v


                                      Contents
























































                                           
                                           
                                           
               Tymshare Pascal Language Reference Manual       Page vi


                                      Contents
























































                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual       Page vii


                                      Contents
























































                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual       Page viii


                                      Contents
























































                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 1


             1 INTRODUCTION               INTRODUCTION



             This   document   defines  the  Tymshare  Pascal  language.
             Tymshare Pascal is an  extended  version  of  the  language
             described  in the Pascal User Manual and Report (K. Jensen,
             N. Wirth, Springer-Verlag, New York: 1974).

             Tymshare Pascal removes many arbitrary restrictions imposed
             by  the  standard  Pascal language.  A full type definition
             may  be  used  in  places  where  previously  only  a  type
             identifier  was  allowed.  An  expression  with  a constant
             value may be  used  where  before  a  simple  constant  was
             required.  A function may return a value of any type except
             a procedure, rather  than  only  a  scalar  or  a  pointer.
             Troublesome  limitations of Pascal which have been noted in
             other versions have also been  removed.  Actual  arrays  of
             varying  length  may  be  bound  to  a  formal parameter of
             "flexible"  array  type.  Additional   standard   functions
             returning  the  actual  bounds  of  array  parameters  make
             construction of routines manipulating array  parameters  of
             variable length straightforward.

             Other extensions provide completely new capabilities.  Some
             of  these  simplify  the  programming  of  certain   common
             manipulations previously difficult to accomplish in Pascal.
             An example is the addition of a string type,  which  allows
             character  arrays  whose  lengths  vary  at  run time to be
             defined  and  then  manipulated  via  such  operations   as
             substring   extraction  and  concatenation.  The  remaining
             extensions  are  provided  to  produce   production-quality
             software.  One  example  of  this is the ability to detect,
             isolate, and, in some instances, to  recover  from  certain
             exceptional conditions without execution termination.

             Other  documents  included  in the Tymshare Pascal Language
             series are:

                   o   Tymshare Pascal Debugger User's  Guide--describes
                       how to use the Tymshare Pascal debugger.

                   o   Tymshare  Pascal Compiler User's Guide--describes
                       how to use the Tymshare Pascal compiler.








             Introduction
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 2


             2 SUMMARY OF THE LANGUAGE               SUMMARY OF THE LANGUAGE



             [The figure entitled "Hierarchy of Pascal Types" on page 30
             provides  a  graphic  overview of the material presented in
             Sections 2.1 and 2.2.]

             A Pascal program consists  of  a  main  program  and  other
             separately  compiled  modules  containing  only subroutines
             and/or data.

             The  main  program  is  organized  as  a  "block"  with   a
             declaration   section   and   a   statement   section.  The
             declaration  section  defines  the  data,  procedures,  and
             functions  to  be  used.  The  statement  section gives the
             actions  to  be  performed.  The  procedure  and   function
             declarations  are themselves blocks and may contain further
             "local"  declarations.  This   "nesting"   of   blocks   is
             characteristic   of   so-called   "block   structure"   and
             determines the accessibility of the  program's  symbols  to
             its executable statements.

             Subroutine  and  data  modules  contain  only a declaration
             section, which may be viewed as an adjunct to that  of  the
             main  program.  However, declarations are not automatically
             shared between modules.  For sharing to occur, a name  must
             be  defined  in  one  module with a PUBLIC declaration, and
             referenced in other modules with an  EXTERNAL  declaration.
             External  declarations  may  also refer to names defined in
             modules written in other languages.





             2.1 The Declaration Section                 The Declaration Section


             The declaration section may define up to  seven  categories
             of names:











             Language Summary
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 3



                   o   LABELs

                   o   CONSTs

                   o   VARs

                   o   PROCEDURE identifiers

                   o   FUNCTION identifiers

                   o   TYPEs

                   o   EXCEPTIONs

             LABELs  identify  statements, and may be used as targets of
             GOTOs.  CONST identifiers denote constant data values.  VAR
             identifiers  denote  variables, whose values may be changed
             by  statements  in  the  program.  PROCEDURE  and  FUNCTION
             identifiers   are   used   in   calling  subroutines.  TYPE
             identifiers    denote    types,    which    describe    the
             characteristics   of  data  values.  EXCEPTION  identifiers
             denote classes of exceptional events which can occur during
             the  execution  of  a  program.  All names must be declared
             before they are used,  except  for  certain  uses  of  type
             identifiers.





             2.1.2 Name Declarations                   Name Declarations

             A  LABEL  declaration  introduces  numeric labels which are
             later defined by their appearance in the statement  section
             of the block.

             A  CONST  declaration  defines an identifier of a specified
             (or implied) type which has a fixed value, and thus  cannot
             be  assigned  to.  An  EXTERNAL  CONST declaration does not
             specify  the  value,  since  the  value  is  given  in  the
             corresponding PUBLIC declaration in another module.

             A  VAR  declaration  defines an identifier as a variable of
             some type.  A variable's lifetime is normally the  same  as
             the  block  in which it is declared.  Variables declared in
             the outermost  block  of  a  compilation,  or  declared  as
             STATIC, exist throughout program execution.  Initial values
             may be specified for such variables.

             A  PROCEDURE  declaration  binds   an   identifier   to   a

             Language Summary
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 4


             parameterized   block   describing   some  operation.  Each
             parameter is denoted within the procedure by an identifier,
             called  the  formal  parameter, which is defined as part of
             the procedure declaration.  An invocation of the  procedure
             must  specify an actual quantity to be bound to each formal
             parameter.  There  are  two  kinds  of  parameters:   VALUE
             parameters  and  VAR parameters.  An actual value parameter
             is an expression which is evaluated once and bound  to  the
             formal  parameter.  Within  the  procedure, assignment to a
             value parameter is not allowed.  An actual var parameter is
             a  reference to a variable, and the formal parameter stands
             for this variable.

             An EXTERNAL PROCEDURE  declaration  only  gives  the  kinds
             (value, var) and types of the parameters.  Formal parameter
             identifiers are optional.

             FUNCTIONs are declared like  procedures,  except  that  the
             type   of  the  result  returned  by  a  function  is  also
             specified.  Within a function, the value to be returned  is
             treated  like a variable with the same name as the function
             itself.  Thus, when a function calls  itself,  a  parameter
             list  must  be specified, even if it is empty, to show that
             it isn't just referring to its return value.


             An EXCEPTION declaration defines an identifier as the  name
             of  a  user-defined condition.  Condition names may be used
             with  the   signaling   and   exception-handling   features
             discussed in Section 13 to deal with exceptional conditions
             which  occur  during  the  execution  of  a  program.  Like
             variables,  condition  names  may  be PUBLIC or EXTERNAL if
             they are declared in the outermost block of a compilation.


             2.1.3 TYPEs                   TYPEs

             The Pascal language  is  strongly  typed.  Every  constant,
             variable,  parameter,  and  function  has a data type which
             regulates its use.  The data type essentially  defines  the
             values  which  may be assumed by a variable of the type and
             the operations which may be performed on  these  values.  A
             data type may be described directly in a declaration, or it
             may be referenced through an identifier defined in  a  TYPE
             declaration.

             The  simple  types encompass the basic computational values
             of the language:  SCALAR types and REALs.  Scalars are used
             as  cardinal  and ordinal values, and include the so-called
             enumerated types and the standard types  BOOLEAN,  INTEGER,
             and  CHARACTER,  An enumerated type defines an ordered list

             Language Summary
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 5


             of identifiers, each denoting a unique value.  Booleans are
             the  logical  values  TRUE  and  FALSE;  integer values are
             written as decimal, binary, octal, or  hexadecimal  integer
             numbers;   and   character   values  are  given  as  single
             characters   enclosed   in   single   quotes.   Reals   are
             floating-point  values  written  as  numbers  in fractional
             (fixed-point) or exponential (floating-point) notation.

             A type may also be defined as a subrange of a  simple  type
             by  giving  the smallest and largest value of the range.  A
             real subrange may be further  qualified  with  a  PRECISION
             factor  specifying  the required precision of values; i.e.,
             the number of significant decimal digits  in  the  mantissa
             (fraction).

             POINTER-type  values  refer  to  variables  of  a specified
             target type.  A pointer may be assigned to or compared with
             another  pointer  without accessing their target variables.
             The  target  variable  of  a   pointer   is   accessed   by
             "dereferencing"  the  pointer  variable  (see Section 9.5).
             There is a single pointer constant, denoted by  NIL,  which
             does  not  point to any variable.  Other pointer values are
             generated in one of three  ways:  (1)  by  creating  a  new
             variable  with the standard procedures NEW or ALLOCATE, (2)
             by taking the address of an ordinary variable, and  (3)  by
             converting an integer to an address.

             PROCEDURE  and FUNCTION types define the kinds and types of
             the formal parameters in a subroutine, and, in the case  of
             a  function, the result type.  Procedure and function types
             are used to declare variables or  formal  parameters  whose
             values are actual subroutines.

             FILE  types  define  variables which may be associated with
             physical files and  input/output  devices.  File  variables
             are manipulated by input/output statements and functions.

             Values  of  a  SET  type are sets of values from the scalar
             base type of the SET type.

             In  addition  to  the   "elementary   types",   there   are
             "structured  types"  containing  components  which  may  be
             separately referenced.  These components may, in  turn,  be
             of  either  elementary or structured type.  There are three
             kinds of structured types:  arrays, character strings,  and
             records.

             An  ARRAY  is  a homogeneous structure whose components are
             selected by a computable index of  some  scalar  type.  The
             types  of  the  index  and  the components are given in the
             array  type  definition.  Multidimensional  arrays  may  be

             Language Summary
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Refe Manual          Page 6


             declared,  and each dimension may be indexed by a different
             scalar  type.  These  are  equivalent   to   arrays   whose
             components  are  other  arrays.  Flexible  array  types are
             those for which the bound(s) of  the  index  type  are  not
             specified.  They  may  be  used  as  the  types  of  formal
             parameters and as components of dynamically allocated data.
             Array-type  values  are  written  as parenthesized lists of
             values of the component type.

             Character STRINGs are varying-length arrays of  characters,
             indexed  by  a  subrange of integers from one to some fixed
             maximum length.  A string value also has a  current  length
             associated with it (0 <= length <= maximum length).  At any
             time, only the first "length" characters of the string  are
             defined.  String-type  values  are  denoted  by  characters
             enclosed by single quotes.  In assignment, comparison,  and
             special  string operations, values of type CHAR and certain
             fixed-length  arrays  of  CHAR  are  interchangeable   with
             strings.

             A  RECORD  type  is a heterogeneous structure of components
             called "fields".  A "field name" is not a computable value,
             but rather an identifier, which denotes the component to be
             accessed.  The  field  identifiers  and  their   associated
             component types are declared in the record definition.

             A  record  may  be  declared  as having several alternative
             substructures,  called  "variants",  which  differ  in  the
             number  and types of the contained fields.  This means that
             variables of the  same  record  type  may,  in  fact,  have
             different   structures,   and   that  the  structure  of  a
             particular record variable may change during the course  of
             execution.    Normally,    the   different   variants   are
             discriminated  by  the  value  of  an  explicitly  declared
             component  called  the  "tag  field".  When  no  tag  field
             exists, the record is an undiscriminated union.

             An optional PACKED attribute may be  specified  in  simple,
             array, and record type declarations.  Packing a simple type
             influences the number of bits  allocated  for  its  values.
             Packing  an  array  or  record  type allows the compiler to
             reduce the space required for values of the type,  even  at
             the cost of increased access times.









             Language Summary
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 7


             2.2 The Statement Section                 The Statement Section


             The  statement  section  of  a  main program, procedure, or
             function consists of  one  or  more  sequentially  executed
             statements.

             The most fundamental statement is the assignment statement.
             This causes the value of an expression to be assigned to  a
             variable or a component of a variable.  Expressions consist
             of variables, constants, sets, and  operator  and  function
             invocations.  The  set  of  operators  may be subdivided as
             follows:

               (1) Arithmetic     operators--addition,      subtraction,
                   negation,   multiplication,  integer  division,  real
                   division, exponentiation, and remainder.

               (2) A string operator--concatenation.

               (3) Logical   operators--negation,    conjunction,    and
                   disjunction,  which  operate  on booleans.  Also, the
                   short-circuited logical  operators  ANDIF  and  ORIF,
                   which  evaluates  their left operands first and their
                   right  operands  only  if  its  value  is  needed  to
                   determine the result.

               (4) Set    operators--union,    intersection,   and   set
                   difference.

               (5) Relational operators--equality, inequality, ordering,
                   set   membership,  and  set  inclusion.  These  yield
                   boolean results.

             The CALL statement invokes a procedure.

             Grouping of several statements to be executed  sequentially
             is   specified   by  the  compound  statement;  conditional
             execution, by the IF statement and the CASE statement;  and
             repetitive  execution,  by the LOOP, FOR, REPEAT, and WHILE
             statements.

             The IF  statement  executes  a  statement  depending  on  a
             boolean  predicate;  the  CASE statement selects from among
             many alternatives  according  to  the  value  of  a  scalar
             expression.

             The LOOP statement iterates indefinitely; the FOR statement
             is used when a bound on the number of executions  is  known
             beforehand;  otherwise, the REPEAT and WHILE statements may
             be used.  All repetitive constructs  may  contain  EXIT  IF

             Language Summary
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 8


             statements   specifying  loop  termination  predicates  and
             optional actions.

             The WITH statement opens the  scope  containing  the  field
             identifiers  of specified record variable(s).  Thus, within
             the  component  statement  of  the  WITH,  fields  of   the
             specified  record(s) may be referenced by their identifiers
             alone.

             There are three kinds of statements which alter the regular
             flow   of   control:   the   STOP  statement,  which  halts
             execution; the RETURN statement, which causes a return from
             a  procedure  or  function,  and  the GOTO statement, which
             jumps  to  a  designated   statement,   possibly   aborting
             subroutine invocations or loops.

             Handler  clauses  on compound statements specify statements
             to be executed when exceptions occur  during  execution  of
             the compound statement.

































             Language Summary
                                           
                                           
                                           

                                           
                                           
                                           
              Tymshare Pascal Language Reference Manual          Page 9


             3 NOTATION AND TERMINOLOGY               NOTATION AND TERMINOLOGY




             In   this  document,  a  modified  version  of  traditional
             Backus-Naur form is used to  describe  the  syntax  of  the
             language.   The  symbol  '::='  separates  the  name  of  a
             syntactic construct (on the left) from its  definition  (on
             the  right).  Alternative  definitions  of  a construct are
             separated by vertical bars ('|').  Constructs  enclosed  in
             square  brackets  are optional.  If the terminating bracket
             is immediately followed by an ellipsis,  i.e.,  '...',  the
             enclosed   constructs   may   be   repeated.   A   list  of
             alternatives is enclosed in braces  if  one  of  them  must
             appear.  Capitalized  words  represent reserved words which
             may not be  used  as  program  identifiers.  Other  special
             symbols,  primarily  graphic  characters,  are  enclosed in
             single quotes, e.g., ';'.

                  special-symbol ::=
                        '+' | '-' | '*' | '/' | '**' | '=' | '<' | '>'
                        | '<>' | '<=' | '>=' | ':=' | '(' | ')' | '['
                        | ']' | '.' | '|' | ',' | ';' | ':' | '^' |'..'
                        | reserved-word

                  reserved-word ::=
                      ALLCONDITIONS | AND | ANDIF | ARRAY 
                      | BEGIN 
                      | CASE | CONST 
                      | DATAMODULE | DIV | DO | DOWNTO 
                      | FILE | FOR | FORWARD | FUNCTION 
                      | ELSE | END | ENVMODULE | EXCEPTION | EXIT
                      | EXTERNAL
                      | GETSTRING | GOTO 
                      | IF | IN 
                      | LABEL | LOOP 
                      | MOD | MODULE 
                      | NIL | NILF | NOT 
                      | OF | OPTIONS | OR | ORIF | OTHERS 
                      | PACKED | PREC | PROCEDURE | PROGRAM | PUBLIC
                      | PUTSTRING
                      | READ | READLN | READRN | RECORD | REPEAT 
                      | RETURN
                      | SET | STATIC | STOP | STRING
                      | THEN | TO | TYPE
                      | UNTIL
                      | VAR
                      | WHILE | WITH | WRITE | WRITELN | WRITERN



             Notation and Terminology
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 10


             Commentary is also used in  the  BNF  of  the  language  to
             describe syntactical restrictions or properties which would
             otherwise  not   be   apparent.   Symbols   of   the   form
             something-reference,        something-expression,       and
             constant-something  are  understood  to  be  equivalent  to
             reference,  expression,  and  constant,  respectively.  The
             qualifier describes semantic attributes of the symbol.













































             Notation and Terminology
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 11


             4 LEXICAL SYNTAX               LEXICAL SYNTAX




             Identifiers must  begin  with  a  letter  and  may  contain
             letters,   digits,  and  underbars  (sometimes  printed  as
             backarrows).  All   characters   in   an   identifier   are
             significant.    Uppercase   and   lowercase   letters   are
             equivalent in all contexts except as elements of  character
             or  string  constants.  For  example, "BEGIN", "begin", and
             "Begin" are all acceptable spellings of the  reserved  word
             BEGIN.

                  letter ::=
                  A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
                  a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z

                  binary-digit ::= 0|1

                  octal-digit ::= 0|1|2|3|4|5|6|7

                  digit ::= 0|1|2|3|4|5|6|7|8|9

                  hex-digit ::= 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 
                                |A |B |C |D |E |F 
                                |a |b |c |d |e |f

                  identifier ::= letter [ letter | digit | '_' ] ...

             Numbers may be either real or integer.  Integer numbers may
             be either  binary,  octal,  decimal,  or  hexadecimal.  The
             radix  is indicated by preceding the number by a pound sign
             ('#') and one of the following letters:  'B' (binary),  'D'
             (decimal),  'O'  (octal), and 'H' (hexadecimal).  The pound
             sign and letter may  be  omitted;  decimal  radix  will  be
             assumed.  Hexadecimal  numbers  are the letters 'A' through
             'F' as well as the decimal  digits.  A  hexadecimal  number
             must begin with a decimal digit; leading zeroes may be used
             to satisfy this requirement.

             Integer numbers are always considered  to  be  nonnegative,
             and  thus  must  be  preceded by a minus ('-') to produce a
             negative value.  This implies that, on a  two's  complement
             computer,  the  most  negative  number cannot be explicitly
             used as a numeric constant in a program, since the  numeric
             portion  of  a  negative integer constant is evaluated as a
             positive integer and then negated.  To obtain  this  value,
             the constant "minimum(integer)" may be used.

                  unsigned-integer ::= octal-integer | decimal-integer

             Lexical Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 12


                  decimal-integer ::= [ '#' 'D' ] digit  ...

                  binary-integer ::= '#' 'B' binary-digit ...

                  octal-integer ::= '#' 'O' octal-digit ...

                  hex-integer ::= '#' 'H' hex-digit ...

             A  real  number  is a decimal integer followed by a decimal
             point, a fractional part, and/or an exponent.  An  exponent
             specifies a power of ten.

                  unsigned-real ::=
                     digits [ '.' [ digits ] ]
                        [ { E | e } [ '+' | '-' ] digits ]

                  digits ::= digit ... 

             String  constants  are  enclosed  in single quotes (').  An
             apostrophe  in  a  string  constant  is  indicated  by  two
             adjacent  apostrophes  (single  quotes).  Strings  may  not
             extend across  line  boundaries.  Character  constants  are
             strings containing a single character.  Any printable ASCII
             character (space through '~') may be  used  in  string  and
             character constants.  Nonprinting ASCII character constants
             may be created using the "CHR" function, which returns  the
             ASCII   character  with  a  specified  integer  value.  For
             example, "chr(#O15)" represents the  carriage  return  (CR)
             character.  Strings which are longer than one line or which
             contain  nonprinting   characters   may   be   created   by
             concatenating shorter strings, for example:

                  const pw_mask := 'XXX' || chr(#O15) || '###'

             This would cause the second string to overstrike the first,
             as might be done when printing a password mask.

             Identifiers,  numbers,  string  and  character   constants,
             special symbols, and reserved words are called "tokens".

             Text  between  the  symbols  '(*'  and  '*)'  is treated as
             commentary, and has no effect on the meaning of a  program.
             Comments  may be nested, i.e., one comment may be contained
             within another.  Blanks, ends of lines,  and  comments  are
             considered  as  separators.  Any  number  of separators may
             occur  between  adjacent  tokens,  but  no  separators  are
             allowed within a token.  Adjacent identifiers, numbers, and
             reserved words must be separated by at least one separator.




             Lexical Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 13


             5 PROGRAM STRUCTURE               PROGRAM STRUCTURE



             A Pascal program consists  of  one  or  more  independently
             compiled modules whose internal organization is a recursive
             block structure.  Both the division into  modules  and  the
             intramodule structure serve to control access to names.



             5.1 Kinds of Compilations                 Kinds of Compilations


             Four  different  types  of  modules  or  "compilations" are
             distinguished:  main  programs,  subroutine  modules,  data
             modules, and environment modules:

                  compilation ::=
                     main-program | subroutine-module | data-module 
                     | environment-module

             Each  type  of compilation is organized as a "block" with a
             "heading" and a "body".  The heading designates the type of
             the  module,  options which apply during the compilation of
             the module, and the name of the  module.  The  module  name
             has no significance within the compilation, and need not be
             distinct from other names used within it.  The contents  of
             the body depend on the type of the module.


             5.1.1 Main Programs                   Main Programs

             The body of a main program contains an optional declaration
             part and a required statement part.  The  declaration  part
             may  include  any  kind of declaration.  The statement part
             defines the action to be performed by the program.

                  main-program ::=
                     program-heading body '.'

                  program-heading ::=
                     PROGRAM identifier [ options-clause ] ';'

                  body ::=
                     [ declaration-part ';' ] statement-part

                  options-clause ::= OPTIONS option [ ',' option ] ...

                  option ::= identifier [ '(' option-parameter 
                     [',' option-parameter ]...')' ]

             Program Structure
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 14


                  option-parameter ::= identifier | number | string


             5.1.2 Subroutine Modules                   Subroutine Modules

             A subroutine  module  contains  only  a  declaration  part.
             Anything  except  a label may be declared, but at least one
             public procedure or function must be defined.

                  subroutine-module ::=
                     module-heading declaration-part '.'

                  module-heading ::=
                     MODULE identifier [ options-clause ] ';'

                  declaration-part ::=
                     declaration [ ';' declaration ] ...



             5.1.3 Data Modules                   Data Modules

             A data  module  contains  only  a  declaration  part  which
             defines  a  group  of  data  items.  Only types, constants,
             public variables, and public conditions may be declared  in
             a data module.

                  data-module ::=
                     data-module-heading declaration-part END '.'

                  data-module-heading ::=
                     DATAMODULE identifier [ options-clause ] ';'

                  declaration-part ::=
                     declaration [ ';' declaration ] ...


             5.1.4 Environment Modules                   Environment Modules

             Every  Pascal  compilation  takes  place within a "standard
             environment".  This environment, provided by the  compiler,
             contains  the  declarations  of  all  the  symbols,  types,
             procedures,  etc.,  that  are  predefined  in  the   Pascal
             language.

             The standard environment for a compilation may be augmented
             with an "environment extension".  An environment  extension
             is  an  additional  set  of  symbols, whose definitions are
             added to the definitions of the  symbols  in  the  standard
             environment.   The   standard  environment,  plus  all  the
             definitions from the  environment  extension,  make  up  an

             Program Structure
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 15


             "extended  environment".  Since  an extended environment is
             an extension of the standard environment, no symbol  in  it
             may  have  the  same  name  as  any  symbol in the standard
             environment.

             An  extended  environment  is  created  by   compiling   an
             environment module.

                  environment-module ::=
                     environment-module-heading declaration-part END '.'

                  environment-module-heading ::=
                     ENVMODULE identifier [ options-clause ] ';'

                  declaration-part ::= 
                     declaration [ ';' declaration ] ...

             It   may   contain   only   constant,  type,  and  external
             declarations.  Furthermore, it may not contain declarations
             of any symbols whose names are the same as those of symbols
             already defined in the standard environment.

             When the compiler compiles an environment module,  it  does
             not  create a relocatable binary file.  Instead, it creates
             an  "environment  file",  which  may  be  used   in   other
             compilations.  The  environment file name is taken from the
             first file name before the equal sign  when  the  user  has
             specified  a  relocatable binary file name or from a source
             file name which the user  has  specified  at  the  compiler
             prompt.  However,  its  default  extension is ".ENV" rather
             than ".REL".

             The user can compile an environment module in  an  extended
             environment  rather than the standard environment.  In this
             case, the environment file  created  from  the  compilation
             will   contain   all  the  definitions  from  the  standard
             environment, from the specified extended  environment,  and
             from  the  compiled environment module.  Thus, the user can
             create  an  extended  environment  which  contains  another
             extended  environment  as  a  subset,  just  as an extended
             environment contains the standard environment as a subset.

             Warning:  An extended environment is always created  for  a
             particular  target machine.  Therefore, when the user loads
             an extended environment, all subsequent  compilations  will
             not only take place with that environment, but for the same
             target machine that the environment was created for.  Thus,
             an  ENVIRON  command  will  override  any  previous  TARGET
             keyword, and a TARGET command will negate the effect of any
             previous ENVIRON keyword.


             Program Structure
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 16


             Using   the   extended   environment  mechanism,  a  single
             environment file could contain  declarations  for  all  the
             types  and external references in a system.  Supposing that
             the environment  file  contained  the  declaration  for  an
             "external  procedure  P",  no  conflict  would occur if the
             module  containing  the  public  declaration  for  P   were
             compiled  with  that  environment  file, since the external
             declaration would occur in the standard environment  scope,
             and the public declaration would occur in the module scope,
             and would therefore override the external declaration.



             5.2 Block Structure                 Block Structure


             A  main  program  or  subroutine  module  block  may   have
             additional  blocks  nested  within  it in the form of local
             subroutine declarations.  These have  a  heading,  optional
             declarations   of   any   kind   (including  further  local
             subroutine declarations), and a required statement part.

             The block corresponding to an entire compilation is  called
             the  "outermost"  or  "level  1"  block.  Subroutine blocks
             defined within this outermost block are at "level  2",  and
             so forth.  A block which is defined within another block is
             said to be "local" to it; a block is "inferior" to  another
             block if it is nested at any level within that block.
























             Program Structure
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 17


             6 DECLARATION AND USE OF NAMES               DECLARATION AND USE OF NAMES



             A  name  may  refer  to  an  item belonging to one of eight
             categories:   labels,    constants,    types,    variables,
             subroutines  (procedures  or functions), conditions, fields
             of  records,  and  formal   parameters.   All   names   are
             identifiers,  except  for  label  names  which are unsigned
             integers.



             6.1 Declarations                 Declarations


             A declaration is used to associate an  item  with  a  name.
             All names except parameters and field names are declared by
             specific statements in the declaration part of a block.

                  declaration-part ::=
                     declaration [ ';' declaration ] ...

                  declaration ::=
                     label-declaration | data-declaration 
                     | subroutine-declaration | exception-declaration

                  data-declaration ::=
                     const-declaration | type-declaration 
                     | var-declaration

             Formal parameters are declared in the parameter list  of  a
             subroutine  declaration.  Field  names  are declared in the
             field list of a record type declaration.

             A declaration is considered to be at the same level as  the
             block  in  which it appears.  For example, a declaration in
             the  outermost  block  is  at  level  1.  The  name  of   a
             subroutine   is   declared   in  the  block  enclosing  the
             subroutine; the names of parameters are declared within the
             subroutine  block  and are therefore at a level one greater
             than that of the subroutine's name.



             6.2 Scope of Names                 Scope of Names


             Within a compilation, a name may refer  to  more  than  one
             item.  Block  structure  is  used  to  delimit the scope of
             declarations in order to distinguish different  uses  of  a

             Declaration and Use of Names
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 18


             name.  A  name  is  known  (i.e.,  its declaration applies)
             within the block in which it is  declared  and  within  any
             inferior block in which there is not a local declaration of
             the same name.  There may not be multiple  declarations  of
             the same name in a single block.

             The  use  of  function  names is an exception to this rule.
             Within the body of a function, the function name may  refer
             either  to  the  function  itself or to the function return
             value.  The name refers to the function when it is used  in
             a  context where a function is expected:  (1) in a function
             reference,  denoted  syntactically  by  a  parameter   list
             following   the  function  identifier;  (2)  as  an  actual
             parameter being passed to a formal function  parameter,  or
             (3)  as  the right-hand side of an assignment to a function
             variable.  In all other  cases,  the  name  refers  to  the
             function return value.

             Within its scope, a name may not be referenced before it is
             declared, except in certain cases where a name is used as a
             type identifier.  A type name used in the declaration of an
             external constant, an external  variable,  or  an  external
             subroutine  (as  a  parameter  or result type) need only be
             declared before the item is used in  the  program.  If  the
             item  is  never used, the type need not be declared at all.
             A type name used as the target of a pointer type need  only
             be  declared  before any pointer having that target type is
             dereferenced (i.e., before a variable pointed to by such  a
             pointer  is  referenced) or is passed in a call to NEW (see
             Section 12).  Pointers bound to undeclared type  names  may
             be  used  freely,  so  long as they are not dereferenced or
             passed to NEW.

             If a name is  declared  in  both  an  inner  block  and  an
             enclosing  block,  and is used before it is declared in the
             inner block, then the declaration from the enclosing  block
             will apply.

             Names  are  not automatically known in all the compilations
             composing a program.  For sharing to occur, a name must  be
             declared  as  PUBLIC  in  one  module  and  as  EXTERNAL in
             another.  A public or  external  designation  may  only  be
             applied  to  a constant, variable, condition, or subroutine
             declaration at level 1.  The public declaration defines the
             actual  item; the external declaration is only a reference.
             Thus, the body of a subroutine, the value of a constant, or
             an  initial  value  for  a  variable is only given with the
             public  declaration.  The  external  declaration  must   be
             identical to the public declaration in all other respects.



             Declaration and Use of Names
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 19


             The  language  defines  a number of "predefined" constants,
             types, procedures, and functions.  The names of these items
             are  predeclared  in a scope which effectively encloses the
             entire compilation.  Thus, redeclaration of  a  predeclared
             name,   anywhere   within   a  compilation,  overrides  the
             predefined declaration.



             6.3 Label Declarations                 Label Declarations


             A label declaration introduces a numeric label which is  to
             be used as the target of a GOTO statement.

                  label-declaration ::=
                     LABEL label [ ',' label ] ...

                  label ::= unsigned-integer

             A  label thus declared must be defined by its appearance on
             a statement in the same block in which it is declared.



             6.4 Constant Declarations                 Constant Declarations


             Constants are items whose values  are  defined  at  compile
             time  and  cannot be modified by the executing program.  An
             identifier is declared as denoting a constant  value  in  a
             const declaration, which specifies a type and/or value.

                  const-declaration ::=
                     [ PUBLIC | EXTERNAL ] CONST
                     constant-definition [ ';' constant-definition ] ...

                  constant-definition ::=
                     identifier ':' type 
                     | identifier [ ':' type ] { '=' | ':=' } constant

             A  "local  constant"  is  defined  when  neither PUBLIC nor
             EXTERNAL is specified.  A value must  be  specified  for  a
             local  constant.  If  a  type  is  given, the value must be
             compatible with the type; otherwise, the apparent  type  of
             the  value is used.  A type is required when the value is a
             structured expression.  A local constant may be used  as  a
             synonym for its value.




             Declaration and Use of Names
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 20


             If  PUBLIC  is  specified,  the  name is made accessible to
             other compilations.  Both a type and a value must be  given
             in a public declaration.

             An  external  constant  declaration  permits  one module to
             reference a public constant defined in  another.  Only  the
             type  is specified.  Since the value of the constant is not
             known during compilation, the name cannot be used  where  a
             constant value is required.



             6.5 Variable Declarations                 Variable Declarations


             A  variable  declaration  consists of a list of identifiers
             denoting the new variables, followed by their type  and  an
             optional initial value.

                  var-declaration ::=
                     [ PUBLIC | EXTERNAL | STATIC ] VAR
                          var-definition [ ';' var-definition ] ...

                  var-definition ::=
                     identifier-list ':' type [ ':=' constant ]

                  identifier-list ::= identifier [ ',' identifier ] ...

             A  variable  declaration may specify that the variables are
             STATIC.  A "nonstatic" variable  is  created  whenever  the
             block  in which it is declared is entered, and is destroyed
             when the  block  terminates.  A  nonstatic  variable  in  a
             recursive  routine  may  have  several distinct versions in
             existence   simultaneously.    Static    variables    exist
             throughout  the  program execution, and can thus be used to
             preserve  information  between  calls  to   a   subroutine.
             Variables  declared in the outermost block of a compilation
             are always static; variables  local  to  a  subroutine  are
             normally nonstatic.

             Only  static  and  public  variables  may  be given initial
             values.  An initial value must be a constant which could be
             assigned   to  the  variable.  The  variable  receives  its
             initial value when the program is loaded.








             Declaration and Use of Names
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 21


             6.6 Other Declarations                 Other Declarations


             Subroutine declarations are described in Section 7.1.  Type
             declarations   are  described  in  Section  8.1.  Condition
             declarations are described in Section 13.1.














































             Declaration and Use of Names
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 22


             7 PROCEDURES AND FUNCTIONS               PROCEDURES AND FUNCTIONS



             Procedures  and  functions  (referred  to  collectively  as
             subroutines)  are parameterized blocks representing actions
             and computations.  Such subroutines may be referenced by an
             actual  subroutine  name  which  is  permanently bound to a
             particular block, or by a subroutine variable or  parameter
             which indirectly references some actual subroutine.



             7.1 Declaration of Actual Subroutines                 Declaration of Actual Subroutines


             A  subroutine  declaration  declares  an  actual subroutine
             identifier  and  gives  it  a  type  specifying  its  usage
             (procedure  or function), the kinds of parameters which are
             required by the subroutine, and, in the case of a function,
             the type of the value it returns.  There are three forms:

                  subroutine-declaration ::=
                     actual-subroutine-declaration 
                     | forward-subroutine-declaration 
                     | external-subroutine-declaration

             An   actual   subroutine  declaration  specifies  both  the
             parameter  list  and  the  body  of  the  subroutine.   The
             parameter  list  in  the declaration gives each parameter a
             name,  called  the  formal  parameter,  by  which   it   is
             referenced  in  the  body  of  the subroutine.  The options
             clause specifies options which apply during compilation  of
             the  subroutine  and  its inferior blocks.  The declaration
             part of the body defines the  local  data  and  subroutines
             used  within  the  subroutine; the statement part gives the
             operations to be performed by the subroutine.















             Procedures and Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 23


                  actual-subroutine-declaration ::=
                     [ PUBLIC ] subroutine-heading ';' body

                  subroutine-heading ::=
                     procedure-heading | function-heading

                  procedure-heading ::=
                     PROCEDURE identifier
                        [ parameter-list ] [ options-clause ]

                  function-heading ::=
                     FUNCTION identifier [ parameter-list ]
                        ':' type [ options-clause ]

             In general, a subroutine must be declared before it can  be
             called.  If  two  subroutines  call each other, then one of
             them  must  be  predeclared  with  a   forward   subroutine
             declaration  which  gives  its type and options clause, but
             not its body.

                  forward-subroutine-declaration ::=
                     [ PUBLIC ] subroutine-heading ';' FORWARD

             The subroutine body must be given in an  actual  subroutine
             declaration   later  in  the  same  block.  The  subroutine
             heading in the actual declaration  is  ignored;  it  should
             either  duplicate the heading in the forward declaration or
             consist only of the subroutine name.  For example:

                  procedure a (x, y: real); forward;

                  procedure b;
                    begin          
                    . . .          (* b calls a *)
                    end;

                  procedure a;    (*the parameter list is omitted here*)
                    begin          
                    . . .          (* a calls b *)
                    end;

             When  PUBLIC  is  specified  in  the   declaration   of   a
             subroutine,  the  name of the subroutine is made accessible
             to  other  compilations.  In   order   to   reference   the
             subroutine,  another  compilation  must include an external
             subroutine declaration.  This defines only the name of  the
             subroutine  and  the  types of the parameters.  The body is
             omitted, and the names of  the  formal  parameters  may  be
             omitted as well.



             Procedures and Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 24


                  external-subroutine-declaration ::=
                     EXTERNAL subroutine-heading



             7.2 Parameters                 Parameters


             There   are   two   kinds   of  parameters:  VALUE  (input)
             parameters and VAR parameters.  A value parameter  may  not
             be modified by the subroutine, while a var parameter may be
             modified.

             The parameters of a subroutine are declared in a  parameter
             list.  Two  forms  are  recognized:  a long parameter list,
             which  contains  both  the  names  and  the  types  of  the
             parameters, and a short parameter list, which contains only
             the parameter types.  The long form must be used in  actual
             and  forward  subroutine declarations, since the parameters
             must be referenced by name in the subroutine  body.  Either
             form  is  permitted  in  the  declaration  of  an  external
             subroutine or a subroutine type.

               parameter-list ::=
                  long-parameter-list | short-parameter-list

               long-parameter-list ::=
                  '(' [ parameter-definition
                                [ ';' parameter-definition ] ... ] ')'

               parameter-definition ::=
                  [ VAR ] identifier-list ':' type

               short-parameter-list ::=
                  '(' [ parameter-description
                                [ ';' parameter-description ] ... ] ')'

               parameter-description ::= [ VAR ] type

          A parameter definition or parameter description which does not
          contain  the  VAR  tag denotes a value parameter.  A parameter
          definition  which  contains  more  than  one   identifier   is
          equivalent   to   independent  declarations  of  each  of  the
          individual identifiers with the same mode (var or  value)  and
          type.  There are no restrictions on the types of parameters.







             Procedures and Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 25


          7.3 Subroutine Invocation              Subroutine Invocation


          A  procedure  is  invoked  by  a CALL statement designating an
          actual procedure name, a procedure parameter, or  a  procedure
          variable.

          A  function  is invoked by a function reference designating an
          actual function name, a  function  parameter,  or  a  function
          variable.  A  function  with no parameters may be invoked with
          an empty  actual  parameter  list  or  no  parameter  list.  A
          parameter  list  must  be  used  when  a function calls itself
          recursively, since  within  the  body  of  the  function,  the
          function  name without a parameter list refers to the function
          return value.

          An invocation of a subroutine must specify an actual parameter
          to  be  bound  to  each  formal  parameter.  An  actual  value
          parameter is an expression which is evaluated once,  converted
          to  the  required  type  if necessary, and bound to the formal
          parameter.  This process is termed "value binding." 

          An actual var parameter is a variable  reference.  Within  the
          body  of  the  subroutine,  the formal parameter refers to the
          actual  variable.  The  types  of  the   formal   and   actual
          parameters  must  be strictly compatible (see Section 8).  The
          parameter binding is established when a subroutine is invoked;
          thus,  modification  within a subroutine of a pointer or index
          variable which was used in selecting a var parameter does  not
          affect  the  binding.  A substring reference may not be passed
          as a var parameter.  A component of a packed array  or  record
          may  not  be  passed as a var parameter unless it is itself an
          array, record, or string.

          It is an error if  a  subroutine  references  and  modifies  a
          variable  passed  to  it  as  a  var  or  value parameter by a
          nonlocal reference to the actual variable, or  by  referencing
          another  var  parameter  bound  to  the  actual variable.  The
          results of such modifications are undefined.

          Invocation of a subroutine suspends execution of  the  calling
          block,  creates  a  new  generation of the nonstatic variables
          local to the called subroutine, and begins  execution  of  the
          statement  part of the called subroutine.  Normally, execution
          of the  caller  resumes  when  the  subroutine  returns.  This
          occurs  when either a RETURN statement (see Section 11.1.4) or
          the last statement in the subroutine  is  executed.  Execution
          of  the  caller may also be resumed by execution of a nonlocal
          GOTO to a label defined in the caller.

          While execution of a subroutine is ongoing or  suspended,  the

             Procedures and Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 26


          subroutine is said to be "active".  Because subroutines may be
          recursively invoked, there may in  fact  be  several  distinct
          activations  of  a  particular  subroutine  at any given time.
          Each activation is associated  with  a  different  version  of
          local  variables,  and  the copies of a single variable in the
          different versions may have different  values.  Further,  each
          activation may have been called from a different location.

          If  an  expression containing a function call is assigned to a
          variable, and the execution of the function is terminated by a
          nonlocal GOTO, then the value of the variable is undefined.



          7.4 Subroutine Values              Subroutine Values


          Parameters  and  variables  may  be  declared  with  a  formal
          subroutine type.  Such an  item  may  receive,  via  parameter
          (value)  binding or assignment, a "subroutine value", and then
          may be used to invoke that subroutine.

          A subroutine  value  denotes  an  actual  subroutine  and  its
          "environment".  Environment has the following meaning.  When a
          subroutine is invoked, it may access the variables declared in
          enclosing  blocks;  moreover,  since blocks may be recursively
          invoked, only the most recent "version" of those variables  is
          accessible.  Therefore,  when  a  subroutine value is created,
          the version of variables that would currently be accessible to
          the  actual  subroutine  is  saved as its environment.  Later,
          when the subroutine value  is  invoked  through  a  subroutine
          variable  or  parameter,  it can only access variables in that
          version.

          A subroutine value remains valid only so long as  the  version
          of  variables given by the display continues to exist.  In the
          case of a subroutine declared  in  the  outermost  block,  the
          value  remains valid for the rest of the program.  In the case
          of a subroutine declared in an inner block, it  remains  valid
          until  the  activation  of its containing block is terminated.
          This means, in essence, that a subroutine  value  may  not  be
          used outside of the block containing the actual subroutine.

          A  standard  procedure  or  function name may not be used as a
          subroutine value.







             Procedures and Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 27


             8 TYPES               TYPES



             All constants, variables, parameters,  and  functions  have
             data types which regulate their use.  The data type defines
             the values which may be assumed by a variable of the  type.
             It  also  defines  the operations which may be performed on
             these values.

             The operations in the language require their operands to be
             compatible  with  one  another or with some specified type.
             Two   kinds   of   compatibility   are   defined:    "value
             compatibility" and "strict compatibility".

             Value compatibility with a particular type is a requirement
             for assignment, use as a value  parameter,  or  use  as  an
             operand.  It  means  that a value is either of the required
             type,  or  convertible  to  that  type  by  some   implicit
             conversion.  Specific  value  compatibility rules are given
             in Sections 8.2 through 8.8.

             Strict  compatibility  with  a   particular   type   is   a
             requirement   for  use  as  an  actual  var  parameter.  In
             addition to being value compatible, two strictly compatible
             items   have   the   same   internal   representation.   By
             definition, two strictly compatible items can replace  each
             other on the left-hand side of an assignment statement (but
             see Section 8.2 about packing).  That  is,  any  assignment
             valid for one item is valid for the other.

             To   help  define  strict  compatibility,  the  concept  of
             identical types is used.  All objects declared in the  same
             identifier  list  in  a  declaration, or declared using the
             same type identifier, have identical  types.  Further,  two
             distinct  type identifiers are identical if one is declared
             to be identical  to  the  other  (e.g.,  "type  a  =  b;").
             Finally,  distinct  type  definitions  may define identical
             types, depending on the kinds of  the  types  in  question;
             identity for each kind of type is described in Sections 8.2
             through 8.7.  Identical types are strictly compatible.





             8.1 The Definition of Types                 The Definition of Types



             A data type in a declaration may  either  be  specified  by

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 28


             fully  describing  it (using the general "type" syntax), or
             by a type identifier which is defined elsewhere in  a  type
             declaration.

                  type-declaration ::=
                     TYPE type-definition [ ';' type-definition ] ...

                  type-definition ::= type-identifier '=' type

                  type ::=
                     type-identifier | simple-type | pointer-type
                     | set-type | subroutine-type | file-type
                     | structured-type

                  type-identifier ::= identifier

             The  properties  of  the  various kinds of types order them
             into a hierarchy which  is  not  quite  the  same  as  that
             indicated by the syntax of the language.

































             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 29


                              HIERARCHY OF PASCAL TYPES
                              _________ __ ______ _____






                  E   L   E   M   E   N   T   A   R   Y












             SIMPLE   POINTER   FILES   SUBROUTINE   SET     STRUCTURED


                         "PTR"


               SUBRANGE    BINARY    TYPED    PROCEDURE    FUNCTION




             "REAL"      SCALAR  "TEXT" 





             "INTEGER"  "CHAR"   ENUMERATED     ARRAYS  STRINGS  RECORDS





             "IO_OPTIONS" "IO_STATUS" GENERIC FLEXIBLE FIXED  VARYING

                                                                 GENERIC


                           "BOOLEAN"    USER-ENUMERATED TYPES


             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 30





             8.2 Simple Types                 Simple Types


             The  simple types are the basic computational values of the
             language.  Their values are strictly  ordered.  The  simple
             types are divided into scalars, reals, and subranges of the
             two.

                  simple-type ::=
                     [ packing-clause ] unpacked-simple-type

                  packing-clause ::=
                     PACKED [ '[' constant-width ']' ]

                  unpacked-simple-type ::=
                     enumerated-type | subrange-type

             The standard type identifiers INTEGER, BOOLEAN,  CHAR,  and
             REAL also denote simple types.

             A  subrange  type  consists of a contiguous range of values
             from an enumerated or simple standard type called the "base
             type"  of the subrange.  All subrange types having the same
             base type are compatible with each  other  and  with  their
             base   type.   If  no  packing  or  precision  clauses  are
             specified, they are all stored in a standard representation
             and   are  therefore  also  strictly  compatible.  Unpacked
             simple  types  are  identical  if  their  base  types   are
             identical  and  their  upper and lower bounds are the same.
             An enumerated or standard simple type is identical  to  the
             subrange  type  containing all of its values (e.g., CHAR is
             identical to "MINIMUM(CHAR) ..  MAXIMUM(CHAR)").

             Packing specifies a possible modification in the number  of
             bits  used  to represent a value of the packed type.  If no
             width  is  explicitly  given  in  the  packing  clause,  an
             appropriate width is selected by the compiler.  A specified
             width must be at least as large as the  largest  number  of
             bits required to store any value of the type.  The compiler
             has the option of using a larger width  to  achieve  better
             performance,  and  will  always  select  the same width for
             types  with  the  same  specified  width,  so  that  strict
             compatibility of types is not affected.

             Packed  types  are strictly compatible only if their widths
             are the same and their base types are identical.  A  packed
             and an unpacked type are never strictly compatible.  If two
             unpacked simple or  subrange  types  are  identical,  their

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 31


             packed  counterparts are also identical if the same packing
             clause is used.

             There are two predefined functions which may be applied  to
             a  simple  type  identifier  or  a  variable reference of a
             simple type.

                MINIMUM     returns the minimum value of the type
                MAXIMUM     returns the maximum value of the type


             8.2.1 Scalar Types                   Scalar Types

             The values of a scalar type can be mapped onto an  interval
             of  the  integers.  Scalar  types may be used as indexes of
             arrays and as the domains of set types.

             In  addition  to  minimum  and  maximum,  there  are  three
             predefined  functions  which may be applied to an item of a
             scalar type:

                SUCC        returns the successor of its  argument.  The
                            successor  of  the maximum value of the type
                            is undefined.
                PRED        returns the  predecessor  of  its  argument.
                            The  predecessor of the minimum value of the
                            type is undefined.
                ORD         returns the  ordinal  value  of  (i.e.,  the
                            integer corresponding to) its argument.


             8.2.1.1 INTEGER                     INTEGER

             A  value  of  the  standard  type  INTEGER  is denoted by a
             unsigned integer.  (Negative integers may be denoted  by  a
             constant  expression  of  the form "'-' unsigned-integer".)
             The  standard  name  INTEGER  refers  to  the  subrange  of
             integral  values  from -2**31 to (2**31)-1.  A compiler may
             provide extralingual options allowing  the  definition  and
             use of integral values outside the standard range.


             8.2.1.2 CHARACTER                     CHARACTER

             A character value may be selected from the set of seven-bit
             ASCII characters.  A printable character value  is  denoted
             by  a  single  character  enclosed  in single quotes (e.g.,
             'a').  The ordinal value of  a  character  is  its  numeric
             representation  in ASCII.  The standard name CHAR refers to
             the entire character set.


             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 32


             8.2.1.3 Enumerated Types                     Enumerated Types

             An enumerated type  is  an  ordered  set  of  values,  each
             denoted by an identifier.

                  enumerated-type ::=
                     '(' identifier [ ',' identifier ] ... ')'

             Each  identifier is declared as a constant within the block
             in which the type is defined.  The ordinal  value  assigned
             to  the  first  identifier  is 0; the second, 1; and so on.
             Distinct enumerated types are not compatible.


             8.2.1.4 BOOLEAN                     BOOLEAN

             The name BOOLEAN  is  predefined  as  the  enumerated  type
             "(FALSE,  TRUE)".  Logical  operators  may  be  applied  to
             values of this primitive type, and the comparison operators
             yield boolean results.


             8.2.2 REAL                   REAL

             Reals  are  floating-point  values  with  an exponent and a
             fraction  of  some   specified   precision.   The   default
             representation  is  determined  by  the  precision  of  the
             fraction; thus, reals with different precisions  are  value
             compatible but not strictly compatible.  Real constants are
             denoted by unsigned numbers in  fractional  or  exponential
             notation.  The precision of a real constant is equal to the
             number of digits  appearing  in  its  external  value  (not
             including  digits in the exponent).  The standard name REAL
             denotes an  implementation-defined,  "standard"  range  and
             precision for floating-point numbers.


             8.2.3 Subrange Types                   Subrange Types

             A  type  may  be defined as a subrange of some other simple
             type, called its "base type", by specifying the  upper  and
             lower  limits  of the range.  A real subrange may include a
             precision specification.

                  subrange-type ::=
                     constant-lower-limit '..' constant upper-limit
                           [ PREC constant-precision ]

             The base type is implied by the  types  of  the  limits.  A
             subrange  of  an  enumerated type is defined when values of
             that type are used as limits.  A real subrange  is  defined

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 33


             using integer or real limits; the presence of either a real
             limit or a precision specification implies a real subrange.
             An integer subrange is defined when both limits are integer
             values and there is no precision specification.

             The precision factor specifies the  required  precision  of
             the fraction of a real value as a number of decimal digits.
             For example, "1..10e12 PREC 5" indicates that the  fraction
             must  be  accurate  to  one  part  in  10**5.  The compiler
             chooses a storage representation which allows at least  the
             required  precision.  A precision factor must be a positive
             integer constant.  If the precision factor is omitted,  the
             precision of the standard type REAL is used.

             The MINIMUM and MAXIMUM predefined functions may be used to
             refer to the limits of a subrange type.



             8.3 POINTER Types                 POINTER Types


             Values of a pointer type refer indirectly to variables of a
             specified target type.

                  pointer-type ::= '^' type

             A  pointer  value  may be assigned to another pointer.  Its
             actual target variable may be accessed by dereferencing the
             pointer (see Section 9.5).

             The  declaration  of  a  type identifier used as the target
             type of a pointer need not precede the declaration  of  the
             pointer  type.  The  target  type  identifier may, in fact,
             remain undeclared so long as no  variable  of  the  pointer
             type is dereferenced or used in a call to NEW.

             A  single  pointer constant is denoted by the standard name
             NIL, and doesn't point to any variable.  It is therefore an
             error  to attempt to access the actual target variable of a
             pointer whose value is NIL.  It may be assigned to pointers
             having  any  target type.  Other pointer values are created
             when storage for a variable is dynamically  allocated  with
             the  NEW  or  ALLOCATE  standard  procedures.  (The pointer
             coercion  and  ADDRESS  functions   also   return   pointer
             values--see Sections 15.2.2 and 15.7, respectively.)

             The target types of pointer types must be identical for the
             pointer types to be either  value  compatible  or  strictly
             compatible.  However,  the  standard type identifier PTR is
             defined as a pointer type which is strictly compatible with

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 34


             any  other  pointer  type.  The  target  type of PTR is not
             defined, and values of this type may not be dereferenced or
             used in calls to NEW.  POINTER types allow utility routines
             operating on pointers of multiple types to be written.

             The use of pointers, particularly those whose target  types
             have  flexible  or  variant  properties,  is  discussed  in
             further detail in Section 12.



             8.4 SET Types                 SET Types


             Values of a SET type are sets of values  from  some  scalar
             domain type.

                  set-type ::= [ PACKED ] SET OF domain-type

                  domain-type ::= type-identifier | unpacked-simple-type

             The  domain type may be any scalar or scalar subrange type,
             except for an integer subrange with a negative lower bound.

             The operators which may be applied to sets are as follows:

                   +           union
                   *           intersection
                   -           difference
                   <=, >=      subset, superset
                   IN          membership

             A set value may be  created  with  a  set  expression  (see
             Section  10.1.2).  The  expression "[]", denoting the empty
             set, is compatible with any set type.

             Sets whose domain types have the same base type (e.g.,  all
             sets  over  integer  ranges) are value compatible.  Two set
             types are identical if and only if their domain  types  are
             identical and their packing attributes are the same.  Aside
             from this,  there  is  no  difference  between  packed  and
             unpacked set types.



             8.5 Subroutine Types                 Subroutine Types


             A  PROCEDURE  type  describes  a  class  of  procedures  by
             specifying the types and kinds  (value  or  var)  of  their
             parameters.  A FUNCTION type describes a class of functions

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 35


             by specifying the types and kinds of their  parameters  and
             their return type.

                  subroutine-type ::=
                     PROCEDURE [ parameter-list ] 
                     | FUNCTION [ parameter-list ] ':' type

             The  values  of  a  procedure  or  function type are actual
             procedures or functions.  Actual subroutine names take  the
             place  of  subroutine  constants (CONST declarations with a
             subroutine type are not allowed).  A variable or  parameter
             with  a  subroutine  type  may  be  called like an ordinary
             subroutine, and has an actual subroutine as its value.

             Two procedure types are identical  if  their  corresponding
             formal  parameters  are of identical type and kind.  In the
             case of function types, their return  types  must  also  be
             identical.

             Within  a  function,  the function name normally designates
             the return  value.  However,  when  it  is  assigned  to  a
             function  variable  or  passed  as a function parameter, it
             designates the function itself.  No ambiguity is  possible,
             since  the  return  value  of  a  function  may not be of a
             subroutine type.



             8.6 FILE Types                 FILE Types


             FILE types define templates and mechanisms for transferring
             data into and out of programs.  Variables of file types are
             dynamically associated with physical files and devices, and
             data  transfers  are  achieved  by  standard procedures and
             functions operating on these variables.

                  file-type ::= [ PACKED ] FILE OF { type | '*' }

             A file type includes a "component type" which specifies the
             data   the   file   contains.  Each  file  variable  has  a
             "component variable", or "buffer variable", which is of the
             file's  component  type.  The  component variable of a file
             variable f is referenced as f^.

             The standard type TEXT is defined as PACKED FILE  OF  CHAR.
             Variables  of  type TEXT are associated with physical files
             composed of lines of  characters.  Special  conversion  and
             formatting operations may be performed on such files.

             Files  without an explicit component type, i.e., FILE OF *,

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 36


             allow variable-length data transfers directly to  and  from
             program  variables.  Such files are referred to as "binary"
             files.  No component is defined for a binary file variable.

             Sequential access is provided through all  file  variables,
             and  random  access and intermixed input/output through all
             variables except those of type TEXT.  File types and  their
             associated  standard procedures and functions are described
             further in Section 14.

             File types are  identical  if  their  component  types  are
             identical,  or  if  both  are  binary,  and  their  packing
             attributes are the same.  Variables of identical file types
             may  be  assigned,  compared,  and  passed as parameters as
             described in Section 14.

             A single file constant, denoted by the standard name  NILF,
             may  be  assigned to all file variables.  It indicates that
             the variable is not associated  with  a  physical  file  or
             device.



             8.7 Structured Types                 Structured Types


             Structured  types  contain  some number of components which
             may be separately referenced and which may, in  turn,  have
             either  elementary  or  structured  types.  There are three
             classes of structured  types:  arrays,  character  strings,
             and records.

                  structured-type ::=
                     array-type | string-type | record-type

             Arrays  and  records  may  be  PACKED,  indicating that the
             compiler may select a more compact representation  for  the
             components,  even  at  the expense of efficiency of access.
             However, if a component has a packed simple  type  with  an
             explicit  bit  size,  the  compiler is not free to pack the
             item further.  Packing has two effects on the meaning of  a
             program.  First, a packed structured type is not compatible
             with an unpacked  structured  type.  Second,  nonstructured
             components  of  a packed structured type may not be used as
             actual var parameters.







             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 37


             8.7.1 ARRAY Types                   ARRAY Types

             An array is a homogeneous structure  whose  components  are
             referenced  with  a  computable  index of some scalar type.
             The types of the index and the components are given in  the
             array type definition.

               array-type ::=
                  [ PACKED ] ARRAY
                     '[' index-type [ ',' index-type ] ... ']' OF type

               index-type ::=
                  type-identifier | unpacked-simple-type
                  | constant-lower-bound '..' '*' | '*'

             An  array  of arrays is called a multidimensional array.  A
             multidimensional array may be defined as "ARRAY  [idxtype1]
             OF  ARRAY  [idxtype2]  OF  ...";  this may be contracted to
             "ARRAY [idxtype1, idxtype2] OF ...".  The first index of  a
             multidimensional   array   is  referred  to  as  the  first
             dimension, the second index as the second  dimension,  etc.
             The  index  of  a  one-dimensional  array is its first (and
             only) dimension.

             There are three distinct classes of arrays,  differentiated
             by  the  form  of  their  index type:  fixed-length arrays,
             flexible arrays, and generic arrays.  These  are  described
             in the following sections.

             Three predefined functions may be applied to any array type
             identifier or array reference:

                LOWERBOUND  returns the  minimum  index  value  of  some
                            dimension of an array
                UPPERBOUND  returns  the  maximum  index  value  of some
                            dimension of an array
                DIMENSION   returns the number of index values  in  some
                            dimension of an array

             A  structured expression listing the individual elements of
             an  array  in  row-major  order  may  be  used   in   array
             initialization, assignments to arrays, and parameter lists.
             Provided that the number of elements is correct, such array
             expressions  implicitly  acquire  the index type and bounds
             appropriate  to  context.  The  expressions  take  on   the
             required  index  types  provided that they have the correct
             number of elements.

             Two array types are identical if their component types  and
             all  of  their  index types are identical.  Two array types
             are  strictly  compatible  if  their  component  types  are

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 38


             identical and their index types agree in a manner dependent
             on the classes of the arrays.


             8.7.1.1 Fixed-Length Arrays                     Fixed-Length Arrays

             A fixed-length array is defined when the index type  is  an
             unpacked  simple  type.  Fixed-length  arrays  are strictly
             compatible if their index types have the same base type and
             the  same minimum and maximum values; i.e., the arrays have
             the same lower and upper bounds.


             8.7.1.2 Flexible Arrays                     Flexible Arrays

             The size of a flexible array is not  determined  until  run
             time.  A  flexible array is defined when a range with a '*'
             upper bound is given as the index type.  As a  variable  of
             such a type cannot be statically allocated, the type may be
             used only (1) as the target type of a pointer, (2)  as  the
             type  of  a  trailing field of a record (or record variant)
             type which is itself the  target  type  of  a  pointer,  or
             (3) as  the  type  of a formal parameter.  In the first two
             cases, the upper bound  of  the  array  is  specified  upon
             allocation  (Section  12.4).  In the third case, the formal
             parameter assumes  the  upper  bound  of  an  actual  array
             parameter  bound  to  it.  A  flexible  array  is  strictly
             compatible with a flexible-  or fixed-length array  if  the
             base  types  of  their  index types are identical and their
             lower bounds are the same.  For  a  flexible  array  to  be
             bound to a fixed-array formal parameter, their upper bounds
             must be the same at run time as well.


             8.7.1.3 Generic Arrays                     Generic Arrays

             An array type with an unspecified index type is defined  by
             giving  '*'  in  place  of the index type.  Such a type can
             only be used as  the  type  of  a  formal  parameter.  This
             indicates  that  the  actual parameter may be an array with
             any index type and the  same  component  type.  Within  the
             subroutine,  the  formal  array  parameter  is  indexed  by
             integer values; its bounds are the ordinal  values  of  the
             bounds  of  the actual array parameter.  A generic array is
             strictly compatible with any other array.

             If an  array  expression  is  passed  to  a  generic  array
             parameter,  1 is used for the lower bound and the length of
             the list for the upper bound.



             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 39


             Note that the component type of  an  array  may  not  be  a
             flexible  or generic array type.  Therefore, only the first
             dimension of a multidimensional array may be variable.


             8.7.1.4 Assignment of Arrays                     Assignment of Arrays

             Assignment of one array to another is legal only if the two
             arrays  have  the  same lower and upper bounds at run time,
             even though they may be otherwise compatible.


             8.7.2 STRING Types                   STRING Types

             Character strings are packed arrays of characters used  for
             representing printable text.  They may be used like arrays.
             There are two kinds of strings:  fixed-length  strings  and
             varying-length strings.

             A  fixed-length  string  is  declared  as  a  PACKED  ARRAY
             [indextype] OF CHAR, where  the  indextype  is  an  integer
             subrange  with  a lower bound of 1.  The upper limit may be
             "*" to define a fixed-length string whose  length  will  be
             determined at run time, as with ordinary arrays.

             A varying-length string is declared as:

                  string-type ::=
                     STRING [ '[' {constant-maximum-length | '*' } ']' ]

             The  maximum length must be a nonnegative integer constant;
             if it is  omitted,  an  implementation-dependent  value  is
             used.  A  "*"  indicates  that  the  maximum length will be
             determined at run time, and may be used either  for  formal
             parameters corresponding to actual parameters whose maximum
             lengths  will  differ,  or  as  (components   of)   dynamic
             variables, similar to flexible arrays.

             All  strings  have  a  current length and a maximum length.
             For a fixed-length string, the current and maximum  lengths
             are  the  same.  For  a  varying-length string, the current
             length may vary from zero  to  the  maximum  length  during
             execution.  At any given time, only those characters in the
             string with indexes between 1 and the  current  length  are
             defined.   When   a   string   value   is   assigned  to  a
             varying-length string variable, the current length  of  the
             variable is updated (see Section 8.8).

             There are seven predefined functions which may be used with
             strings:


             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 40


                LOWERBOUND  is 1, by definition
                UPPERBOUND  returns the maximum length of a string
                LENGTH      returns the current length of a string
                SUBSTR      references a substring
                INDEX       locates a string within another string
                SEARCH      locates the first occurrence in a string  of
                            any of a set of characters
                VERIFY      locates  the first occurrence in a string of
                            a character which  is  not  a  member  of  a
                            specified set

             One  operator  is defined for strings:  concatenation (||).
             Strings may be indexed like arrays  to  access  a  specific
             character.  Substrings  may be extracted and assigned using
             the SUBSTR function or a substring reference.

             String values are written as strings of characters enclosed
             in single quotes.  The null string is denoted by ''.

             Fixed-length  strings  and varying-length strings are value
             compatible.  Padding and truncation to achieve the required
             length  are  performed  automatically.  Two  varying-string
             types or two fixed-string  types  are  identical  if  their
             maximum  lengths  are the same, and are strictly compatible
             if either is flexible.  For a flexible string to  be  bound
             to  a  nonflexible  var formal parameter, their upperbounds
             must be the same at run time.  A fixed and a varying string
             are not strictly compatible.


             8.7.3 RECORD Types                   RECORD Types

             A  RECORD  type  is  a heterogeneous structure containing a
             fixed number of components called  fields.  Each  field  is
             designated  by  an identifier called a field name which may
             be used in a field reference or under the control of a WITH
             statement  to refer to the particular component.  The field
             names need not be distinct from names declared  outside  of
             the record type definition.

                  record-type ::=
                     [ PACKED ] RECORD [ field-list ] [ ';' ] END

                  field-list ::=
                     fixed-part [ ';' variant-part ] 
                     | variant-part

                  fixed-part ::=
                     field-definition [ ';' field-definition ] ...



             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 41


                  field-definition ::=
                     identifier-list ':' type

             Use  of  more  than one identifier in a field definition is
             equivalent to separate definitions of each identifier.

             A record may be  declared  as  having  several  alternative
             substructures,  called  "variants",  which  differ  in  the
             number and types of  the  contained  fields.  Variants  are
             listed  in  a  CASE  construction,  labeled  by values of a
             scalar  type.  Normally,   the   different   variants   are
             discriminated  by  the  value  of  the  tag field, which is
             defined in the case heading.  At any given time,  only  the
             fields  in the variant selected by the current value of the
             tag field are defined.  When the tag field is omitted,  the
             record  is  said to be "undiscriminated", and the fields in
             any variant may be referenced.

                  variant-part ::=
                     CASE [ identifier ':' ] type OF
                        variant [ ';' variant ] ...

                  variant ::=
                     case-label-list ':' '(' [ field-list ] [ ';' ] ')'

                  case-label-list ::= range-list | OTHERS

             The case label values must be unique and  contained  within
             the  range  of  the  scalar  tag  field  type  given in the
             heading.  If no  variant  is  specified  for  a  particular
             value, the value is associated with the OTHERS variant.  If
             there is no OTHERS variant, the omitted  values  have  null
             variants.

             As  noted in Section 8.7.1.2, the last field of a record or
             variant within a record may be a flexible  array.  However,
             all  variables  having  such  record types must be dynamic,
             i.e., explicitly allocated at run time.  Hence, such record
             types may appear only as the target type of pointers and as
             the types of formal parameters in a  program.  Further,  no
             field  of  a  record  may  have  a record type containing a
             flexible array.

             When the required type is clear from the context, a  record
             value  may be created with a record expression (see Section
             10.2.1).

             Separately defined record types are incompatible,  even  if
             the  textual  definitions  of  the  records  are identical.
             Every occurrence of  the  keyword  RECORD  creates  a  type
             distinct  from  all  other record types.  Thus record types

             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 42


             are compatible  only  if  they  are  identical.  Compatible
             records may be assigned, but may not be compared.  Further,
             while compatible records whose last  field  is  a  flexible
             array  may  be  assigned,  records  with variants ending in
             flexible arrays may not be assigned.



             8.8 Implicit Type Conversions                 Implicit Type Conversions


             Implicit type conversions are performed in  contexts  where
             the  required  type  is  well  determined:  in  assignment,
             initialization of constants and static variables, and value
             binding  in parameter lists.  The following conversions are
             defined:

                scalar to scalar of a different range
                   The base types of the scalars must be the  same.  The
                   operation is in error if the value being converted is
                   outside the range of the target type.

                integer to real
                   The integer is floated and rounded to  the  precision
                   of the real type.

                real to real of a different precision
                   The  source  value is rounded to the precision of the
                   target.

                fixed or varying string to varying string
                   Let LS be the (current) length of the source  string;
                   let  MLT  be the maximum length of the target string.
                   If LS > MLT, then the target is set to the first  MLT
                   characters  of  the  source  string  and  its current
                   length becomes MLT; otherwise, only LS characters are
                   copied  to  the target and its current length becomes
                   LS.

                fixed or varying string to fixed string
                   Let LS be the (current) length of the source  string,
                   and  LT  the fixed length of the target.  If LS < LT,
                   the source string  is  padded  with  (LT-LS)  blanks;
                   otherwise,   the   trailing  (LS-LT)  characters  are
                   truncated.

                char to string
                   The conversion is performed as if the character value
                   were a fixed string of length 1 (one).



             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 43


                set to set of different domain
                   The base types of the domains of the sets must be the
                   same.  The source set is intersected with the  domain
                   of  the  target  set, effectively truncating elements
                   outside of the range.



             8.9 Explicit Type Conversions                 Explicit Type Conversions


             There are  several  additional  conversions  which  can  be
             performed  but  must be explicitly programmed using special
             conversions:  integer  to  enumerated  scalar,  scalar   to
             integer, real to integer (truncated or rounded), pointer to
             pointer, integer to pointer, and pointer  to  integer  (see
             Section 15.2.2).



































             Types
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 44


             9 REFERENCES               REFERENCES



             A   reference  designates  some  named  item  (a  variable,
             constant, or parameter), a component of an item, a variable
             referenced  by  a  pointer,  or  the  value  returned  by a
             function.  A reference may be  used  in  an  expression  to
             access  the  designated  (component) value.  It may also be
             used on the left-hand side of an assignment or as an actual
             var  parameter,  to  designate the item to be modified.  In
             this case, the reference must be a variable reference, that
             is, a reference to an item that can be modified.  Note that
             a variable reference is  not  strictly  synonymous  with  a
             variable:  it  may, for example, be a field within a record
             variable.

                  reference ::=
                     entire-reference | field-reference 
                     | indexed-reference | substring-reference 
                     | pointer-reference | function-reference 
                     | component-reference



             9.1 Entire References                 Entire References


             An entire reference denotes the value of a named item,  and
             is of the type declared for the name.

                  entire-reference ::= identifier

             The  reference  is  variable  only  if  the  identifier  is
             declared  as  a  variable  or  a  var  parameter.  If   the
             identifier is a field name accessed under control of a WITH
             statement, the reference  is  variable  if  the  containing
             record value is variable.



             9.2 Field References                 Field References


             A  field  reference  selects a component of a record-valued
             reference.  The reference is variable if the base record is
             variable.

                  field-reference ::= reference '.' identifier

             The  identifier  must  name  a  field defined in the record

             References
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 45


             type.  Further, if the field is in a variant part which  is
             discriminated by a tag field, then the current value of the
             tag field must select the variant containing the field.



             9.3 Indexed References                 Indexed References


             An indexed reference selects an element of an  array-valued
             reference,  or  a character from a string-valued reference.
             The type is the component type of the array.  The reference
             is variable if the base array or string is variable.

                  indexed-reference ::=
                     reference '[' expression [ ',' expression ] ... ']'

             Use  of more than one index expression is equivalent to the
             use of separate subscripting.  That is, "a[idx1, idx2]"  is
             the  same  as "a[idx1] [idx2]".  Each index expression must
             be compatible with the declared index type, and within  the
             actual bounds of the array.



             9.4 Substring References                 Substring References


             A  substring  reference  designates  some  substring  of  a
             string-valued reference.

                  substring-reference ::=
                     reference '[' expression ':' expression ']'

             The first  expression  gives  the  position  of  the  first
             character of the substring; the second expression gives its
             length.  They must be integer  expressions  satisfying  the
             following  constraint.  Let  SIDX  be  the  starting index;
             SLEN, the length of the substring; and RLEN the  length  of
             the  base string.  Then, 1 <= SIDX <= SIDX + SLEN <= RLEN +
             1.  This constraint permits zero-length substrings.

             A substring reference is variable if  the  base  string  is
             variable.  However, it may only be used as the target of an
             assignment, not as an actual var parameter.

             Assigning to a  substring  reference  does  not  alter  the
             length  of  the  base string, even if the value assigned is
             longer  or  shorter  than  the  computed  length   of   the
             substring.  The assigned value is converted to the required
             length  (Section  8.7.2).  A  substring  reference  in  any

             References
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 46


             context  can  also  be specified with the standard function
             SUBSTR.



             9.5 Pointer References                 Pointer References


             A pointer reference designates the target variable of  some
             pointer-valued  reference.  The  type  of the result is the
             target type of the pointer.  Accessing the target  variable
             of   a   pointer   in   this   manner  is  referred  to  as
             "dereferencing" the pointer.

                  pointer-reference ::= reference '^'

             A pointer reference is always  variable.  However,  if  the
             pointer has been generated by taking the address of a value
             parameter, assigning to the reference is an error, and  the
             effect is undefined.



             9.6 Function References                 Function References


             A   function   reference  designates  an  invocation  of  a
             function.  The value of a  user-defined  function  has  the
             declared  result type.  Standard functions are described in
             Section 15.

                  function-reference ::=
                     reference [ actual-parameter-list ]

                  actual-parameter-list ::=
                     '(' [ expression [ ',' expression ] ... ] ')'

             A function of no  parameters  may  be  invoked  without  an
             explicit  parameter list.  However, in order to invoke such
             a function by its actual name from within its body, a  null
             parameter  list,  "()",  must  be given, since the function
             name alone indicates the return value.

             If the return value of a  function  is  an  array,  string,
             record, or pointer, then the function reference can be used
             as the base reference in an  array,  substring,  field,  or
             pointer reference.

             In   general,  a  function  reference  is  not  a  variable
             reference.  However,  the  standard  function   SUBSTR   is
             treated  as  a  substring reference, and may be used on the

             References
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 47


             left-hand side of an assignment to modify a substring of  a
             string variable.



             9.7 Component References                 Component References


             A  component reference accesses the "component" or "buffer"
             variable associated with all but binary files (FILE OF  *),
             which have no associated component variable.

                  component-reference ::= reference '^'

             A  component  reference  is  always  variable,  and  may be
             assigned.




































             References
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 48


             10 EXPRESSIONS                EXPRESSIONS



             The  data  elements  of  a  program  are  constant   values
             (described in Section 4) and the values of variables, which
             are accessible via references (Section 9).  To  create  new
             values,  these  data  elements  may  be  combined  to  form
             expressions.  An expression defines a  new  value  of  some
             simple or structured type in terms of existing values.

                  expression ::=
                     simple-expression | composite-expression



             10.1 Simple Expressions                  Simple Expressions


             A  simple  expression  generally  defines  a  value of some
             unstructured type.  (A reference to a structured  constant,
             variable,  or parameter is a simple expression, but defines
             a structured value.)  All simple expressions are ultimately
             composed   of   primitive   expressions  (Section  10.1.1),
             combined by operators:

                  simple-expression ::=
                     term [ relational-operator term ]

                  term ::=
                     factor [ adding-operator factor ] ...

                  factor ::=
                     power-expression
                        [ multiplying-operator power-expression ] ...

                  power-expression ::=
                     unary-expression [ '**' unary-expression ]

                  unary-expression ::=
                     [ '+' | '-' | NOT ] primitive-expression

                  relational-operator ::=
                     IN | '=' | '' | '' | '' | '=' | '='

                  adding-operator ::=
                     '+' | '-' | OR | ORIF | '||'

                  multiplying-operator ::=
                    '*' | '/' | DIV | MOD | AND | ANDIF


             Expressions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 49


             The precedence of the operators is:

                  (highest) unary operators ('+', '-', NOT)
                            exponentiation ('**')
                            multiplying operators
                            adding operators
                  (lowest)  relational operators

             Note that the logical operators have higher precedence than
             the  relational  operators.  This  means, for example, that
             "a<b OR c>d" will be parsed as "a < (b OR c) < d", which is
             erroneous.


             10.1.1 Primitive Expressions                    Primitive Expressions

             A  primitive  expression  may  be  a  literal  constant,  a
             reference to a previously defined value, a set  expression,
             or an expression enclosed in parentheses:

                  primitive-expression ::=
                     unsigned-integer | unsigned-real | string 
                     | reference | '(' simple-expression ')' 
                     | set-expression

             An  unsigned  integer,  unsigned  real, or string denotes a
             constant value, according to the information in Section  4.
             A  reference  denotes  the  current value of the referenced
             variable,  parameter,  or  constant.   The   value   of   a
             parenthesized   expression  is  simply  the  value  of  the
             expression.  Set expressions  are  described  in  the  next
             section.


             10.1.2 Set Expressions                    Set Expressions

                  set-expression ::= '[' [ range-list ] ']'

                  range-list ::= range [ ',' range ] ...

                  range ::= scalar-expression [ '..' scalar-expression ]

             A set-expression specifies a value of a set type by listing
             the elements of the set, either individually or  as  ranges
             of values.  A range of the form "val1..val2" specifies that
             the elements val1, succ(val1), ...,  val2  are  all  to  be
             included  in  the  set;  if  val2  <  val1, no elements are
             included.  All  of  the  scalar  expressions   in   a   set
             expression  must be expressions with simple, nonreal types,
             and they must all be compatible with one another.  The base
             type  of  the  set  expression  is  the  type of the scalar

             Expressions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 50


             expressions in its range list.  (The  empty  set  constant,
             "[]" is defined to be compatible with any set type.) 


             10.1.3 Arithmetic Operators                    Arithmetic Operators



             10.1.3.1 Unary Operators                      Unary Operators

                  +    represents  the  identity  operation.  It  may be
                       applied to any integer or real number.

                  -    negates its operand.  It may be  applied  to  any
                       integer or real number.




             10.1.3.2 Arithmetic Operators                      Arithmetic Operators

             The  arithmetic  operators  all  take two operands.  Except
             where noted, each operand may be either  an  integer  or  a
             real  number.  If both operands are integers, the result of
             the operation is an integer.  If both operands  are  reals,
             the  result  of  the  operation  is real, with precision at
             least as great as that of the more precise operand.  If one
             operand  is  real  and  one is an integer, then the integer
             argument is converted to standard type REAL or  to  a  real
             number  with  at  least the precision of the real argument,
             whichever is more precise.

                  +    returns the sum of its operands

                  -    returns the difference of its operands

                  *    returns the product of its operands

                  DIV  requires integer operands, and returns an integer
                       representing  their  quotient, with the remainder
                       discarded (that is,  the  quotient  is  truncated
                       toward zero)

                  /    converts  its  operands  to real numbers, if they
                       are not already real numbers, and  returns  their
                       real quotient

                  MOD  requires   integer   operands,  and  returns  the
                       integer value of "op1 MOD op2", which is  defined
                       as "op1 - (op1 DIV op2)*op2"


             Expressions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 51


                  **   is the exponentiation operator.  Note that a ** b
                       ** c is erroneous, and must be written as  (a  **
                       b)  **  c or a ** (b ** c), to indicate the order
                       of evaluation.  The restrictions on the values of
                       the  operands,  and  the result of the operation,
                       are  defined  according  to  the  types  of   the
                       operands  (but  note that in all cases, 0 ** 0 is
                       undefined):

                       integer ** integer  [ op2 > 0 ]
                            yields an integer result

                       real ** integer
                            yields a real result

                       real ** real  [ op1 > 0 ]
                            yields a real result

                       integer ** real  [ op1 > 0 ]
                            converts the integer argument to  real,  and
                            returns a real result




             10.1.3.3 Relational Operators                      Relational Operators

             The relational operators are "<", ">", "<=", ">=", "=", and
             "<>", representing "less than", "greater than", "less  than
             or  equal  to", "greater than or equal to", "equal to", and
             "not equal to", respectively.  They may be used to  compare
             any  two  compatible  scalar  values  (integer,  character,
             boolean, real, enumerated, and subranges thereof), as  well
             as  strings  (see Section 10.1.6).  They perform an integer
             comparison if  both  operands  are  integers,  and  a  real
             comparison   (with   conversion  if  necessary)  if  either
             argument  is  real.  The  relational  operators  return   a
             boolean value of "TRUE" or "FALSE".

             The  relational operators "=" and "<>" (but not the others,
             since no ordering is defined) may also be used  to  compare
             compatible  values of pointer or file types.  No comparison
             between operands of record or array types is allowed.


             10.1.4 Boolean Operators                    Boolean Operators

             The boolean operators are NOT, AND, OR,  ANDIF,  and  ORIF.
             These  operators  all  take  boolean  operands and return a
             boolean result.  NOT, AND,  and  OR  perform  the  standard
             logical  operations.  ANDIF  and ORIF are equivalent to AND

             Expressions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 52


             and OR, except with respect to the order of  evaluation  of
             their  operands.  AND and OR may evaluate their operands in
             either order, and may evaluate both operands or  only  one.
             ANDIF and ORIF always evaluate their left operand first; if
             the first operand of ANDIF is FALSE or the first operand of
             ORIF  is TRUE, then they return a result without evaluating
             the second operand.

             All the relational operators can also be used with  boolean
             operands,  since "boolean" is defined as a scalar type with
             "FALSE" < "TRUE".  This means that the relational operators
             provide the following standard logical operations:

                       Relation | Operation
                       ---------|--------------
                        p <= q  |  p implies q
                        p >= q  |  q implies p
                        p = q   |  equivalence
                        p <> q  |  exclusive or


             10.1.5 Set Operators                    Set Operators

             The following set operations are defined if "x" and "y" are
             two sets with the same base type, and "a" is a value of the
             base type of "x" and "y".

                  x + y  returns the union of the two sets

                  x * y  returns the intersection of the two sets

                  x - y  returns  the  difference  of the two sets; that
                          is, all the elements that are in x and are not
                          in y

                  x <= y returns  TRUE  if  x is a subset of y Note that
                          this is the "subset-or-equality" relation, not
                          the "proper subset" relation.

                  x >= y returns TRUE if y is a subset of x

                  x = y  returns  TRUE  if  the two sets contain exactly
                          the same elements

                  x <> y returns TRUE if the two  sets  do  not  contain
                          exactly the same elements

                  a IN x returns TRUE if the element a is in the set x




             Expressions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 53


             10.1.6 String Operators                    String Operators

             The  operator "||" takes two string operands, and returns a
             single  string  which  is  the  concatenation  of  the  two
             operands.

             All  of the relational operators are applicable to strings.
             In comparing two strings, "s1" and "s2", they  are  scanned
             from  left to right.  If all the character positions of the
             two strings are the same, then the two strings  are  equal.
             If  a  difference is found in the "i"th character position,
             then (s1 < s2) if (s1[i] < s2[i]), and (s1 > s2) if  (s1[i]
             > s2[i]).  When comparing two strings of differing lengths,
             the shorter string is padded on the right  with  blanks  to
             match  the  length  of  the  longer string.  Characters are
             treated as strings of length 1.



             10.2 Composite Expressions                  Composite Expressions


             A composite expression defines a value of  some  structured
             type.   All  composite  expressions  have  the  form  of  a
             parenthesized list of expressions:

                  composite-expression ::=
                     '(' [ expression [ ',' expression ] ... ] ')'

             Since it is  not  possible  to  determine  the  type  of  a
             composite   expression  just  by  examining  it,  composite
             expressions are permitted only in contexts in  which  their
             type  can  be determined unambiguously.  These are:  (1) as
             the value of a constant or the initial value of a  variable
             of  a  structured  type;  (2)  on the right-hand side of an
             assignment statement, whose destination is of a  structured
             type;  or  (3)  as  an  actual  parameter in a procedure or
             function call, where the formal parameter has a  structured
             type.













             Expressions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 54


             10.2.1 Record Expressions                    Record Expressions

             In  a composite expression representing a record value, the
             expressions in the parenthesized  list  correspond  to  the
             fields  of  the  record,  in the order of their definition.
             They must be value compatible with the corresponding  field
             types.  A  composite  expression  defining  a  value  of an
             undiscriminated union record type must contain a value  for
             the  variant  tag  field  (to allow selection of the proper
             variant), even though this is not stored  as  part  of  the
             record value.


             10.2.2 Array Expressions                    Array Expressions

             In  a composite expression representing an array value, the
             expressions in the parenthesized  list  correspond  to  the
             elements  of  the array, ordered by index value.  They must
             be value compatible with the element type of the array.  If
             a  composite  expression  is  used  to define a flexible or
             generic array value, the number of  elements  in  the  list
             determines the number of elements in the array.






























             Expressions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 55


             11 STATEMENTS                STATEMENTS



             The  statement  part  of  a  main  program,  procedure,  or
             function consists of  one  or  more  sequentially  executed
             statements, which denote the actions to be performed by the
             program.

                  statement-part ::= BEGIN statement-list END

                  statement-list ::= statement [ ';' statement ] ...

             Statements may be prefixed with a label to be referenced in
             a GOTO statement (see Section 11.1.3).

                  statement ::=
                     [ label ':' ] unlabeled-statement

                  unlabeled-statement ::=
                     simple-statement | structured-statement 
                     | exit-statement



             11.1 Simple Statements                  Simple Statements


             A  simple  statement denotes a single imperative operation.
             The null statement consists of no symbols  and  denotes  no
             action.

                  simple-statement ::=
                     assignment-statement | call-statement 
                     | goto statement | return statement
                     | stop-statement | null-statement

                  null-statement ::= (* nothing *)


             11.1.1 Assignment Statements                    Assignment Statements

             An  assignment  statement  causes  a  new computed value to
             replace the previous value of a variable or a component  of
             a variable.

                  assignment-statement ::=
                     variable-reference ':=' expression

             The  variable  reference  and  the  expression  must  be of
             compatible  types.  Implicit  conversions   are   performed

             Statements
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 56


             between  certain  nonidentical  types.  When  a  value of a
             simple type is assigned, it must lie within  the  range  of
             values specified by the variable's type.


             11.1.2 CALL Statements                    CALL Statements

             The CALL statement denotes the invocation of a procedure.

                  call-statement ::=
                     procedure-reference [ actual-parameter-list ]

                  actual-parameter-list ::=
                     '(' [ expression [ ',' expression ] ... ] ')'

             A  procedure invocation must specify an actual parameter to
             be bound to each corresponding formal  parameter  given  in
             the type of the procedure reference.  Information governing
             invocation of a subroutine is given in  further  detail  in
             Section 7.3.


             11.1.3 GOTO Statements                    GOTO Statements

             Execution  of a GOTO statement alters the normal sequential
             flow of control by branching to  the  statement  associated
             with the label.

                  goto-statement ::= GOTO label

             The  label  must have been declared in the declaration part
             of a block, and defined by its occurrence as a label  on  a
             statement in the statement part of the block.

             A  GOTO  to  a  label  defined within a containing block is
             permitted, and is termed a "nonlocal GOTO".  Execution of a
             nonlocal GOTO terminates all active subroutines called from
             the most recent activation of the block where the label  is
             defined.

             A  "local  GOTO" may not branch into a structured statement
             from outside that statement.  Thus, local GOTOs may only be
             used  to exit structured statements or to branch within the
             body of a structured statement.








             Statements
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 57


             11.1.4 RETURN Statements                    RETURN Statements

                  return-statement ::= RETURN

             A RETURN statement may only appear in the statement part of
             a  subroutine,  and  causes  an  immediate  return from the
             subroutine.  When used in a function,  a  value  must  have
             been  previously  assigned to the return value for it to be
             defined.


             11.1.5 STOP Statements                    STOP Statements

                  stop-statement ::= STOP

             A stop statement halts the execution of a program.



             11.2 Structured Statements                  Structured Statements


             Structured statements are groups of statements which are to
             be   executed   either   in   sequential   order  (compound
             statement), within the scope of a record (WITH  statement),
             conditionally  (conditional  statements),  or  repetitively
             (repetitive statements).

                  structured-statement ::=
                     compound-statement | with-statement
                     | conditional-statement | repetitive-statement


             11.2.1 Compound Statements                    Compound Statements

             A compound statement serves to group together one  or  more
             statements  for execution as a single unit.  The statements
             are executed in sequential order.

                  compound-statement ::=
                     BEGIN statement-list END


             11.2.2 WITH Statements                    WITH Statements

             A WITH statement opens a record value, so that  within  the
             body of the WITH statement, the fields of the record may be
             accessed without qualification.




             Statements
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 58


               with-statement ::=
                  WITH record-reference [ ',' record-reference ] ... DO
                     unlabeled-statement

             Use of multiple references is an  abbreviation  for  nested
             WITH   statements.   That   is,  "WITH r1,  ... rn  DO"  is
             equivalent to "WITH r1 DO ...  WITH rn DO".

             Each record reference is evaluated once upon entry  to  the
             WITH  statement.  Within the unlabeled statement, modifying
             a subscript or pointer used in the reference does not alter
             the  identity  of  the  record  item whose fields are to be
             accessed.  An assignment made to any of the record items is
             permitted  and  has  the effect of assigning to each of the
             fields.  The record reference itself can also be assigned a
             new  value,  which  in  general  changes  the  value of its
             fields.


             11.2.3 Conditional Statements                    Conditional Statements

             A  conditional  statement  selects  one  of  its  component
             statements for execution.

                  conditional-statement ::=
                     if-statement | case-statement


             11.2.3.1 IF Statements                      IF Statements

             An  IF  statement selects one of two alternative actions on
             the basis of a  boolean  predicate.  If  the  predicate  is
             TRUE,  then  the statement tagged with THEN is executed; if
             FALSE,  the  ELSE  statement  is  executed,   if   present.
             Omitting  the  ELSE  part  implies  that no action is to be
             performed when the predicate is FALSE.

                  if-statement ::=
                     IF expression THEN unlabeled-statement
                         [ ELSE unlabeled-statement ]

             An ELSE part is associated with the closest preceding  THEN
             part.


             11.2.3.2 CASE Statements                      CASE Statements

             A  CASE  statement  selects  one  of  a  set of alternative
             statements on the basis of a scalar-valued expression.

                  case-statement ::=

             Statements
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 59


                     CASE selector expression OF
                        case-member [ ';' case-member ] ... [';'] END

                  case-member ::=
                     case-label-list ':' unlabeled-statement

                  case-label-list ::= range-list | OTHERS

                  range-list ::= range [ ',' range ] ...

                  range ::= scalar-expression [ '..' scalar-expression ]

             Each alternative is labeled with a list of constant  values
             and/or  ranges  of constant values compatible with the type
             of the selector expression.  The case label lists  must  be
             disjoint.  The  statement  whose  label  list  includes the
             computed value of  the  selector  is  executed.  The  label
             OTHERS  may be used to designate a statement to be executed
             if none of the other labels applies.  If there is no OTHERS
             case  and  no  label  applies, no action is performed other
             than the computation of the selector expression.


             11.2.4 Repetitive Statements                    Repetitive Statements

             Repetitive statements specify repeated execution of one  or
             more statements.  The LOOP statement iterates indefinitely;
             the FOR statement is used when a bound  on  the  number  of
             iterations  is  known  beforehand;  the  REPEAT  and  WHILE
             statements are used when iteration is to be  controlled  by
             complex   predicates.  All  repetitive  statements  may  be
             terminated  by  an  EXIT   statement   which   contains   a
             termination   predicate   and   optional   action.  A  GOTO
             statement may also be used to exit a repetitive statement.

                  repetitive-statement ::=
                     while-statement | repeat-statement
                     | for-statement | loop-statement


             11.2.4.1 WHILE Statements                      WHILE Statements

                  while-statement ::=
                     WHILE expression DO unlabeled-statement

             The expression must yield a boolean  value.  The  unlabeled
             statement  is  executed  repeatedly while this predicate is
             TRUE.  The predicate is evaluated and  tested  before  each
             iteration;   therefore,  if  it  is  initially  false,  the
             controlled statement is never executed.


             Statements
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 60


             11.2.4.2 REPEAT Statements                      REPEAT Statements

                  repeat-statement ::=
                     REPEAT statement-list UNTIL expression

             The expression must yield a boolean value.  The  statements
             in the body are executed repeatedly until the expression is
             TRUE.  The predicate is evaluated  and  tested  after  each
             iteration;  therefore,  the body of the REPEAT statement is
             executed at least once.


             11.2.4.3 FOR Statements                      FOR Statements

             A FOR statement repetitively executes  a  statement,  while
             assigning  successive  values  from a computed range to its
             "control variable".  Iteration terminates when the range is
             exhausted.

                  for-statement ::=
                     FOR identifier ':=' for-range DO
                        unlabeled-statement

                  for-range ::=
                     initial-expression TO final-expression
                     | initial-expression DOWNTO final-expression

             The  control variable and the initial and final expressions
             must be of compatible scalar types.  The  control  variable
             is  denoted  as  an identifier only, and thus can reference
             only an entire variable, not a component of a variable.  It
             is  further  required that the identifier designate a local
             variable.  That is, it cannot be declared in  an  enclosing
             scope,  and  it  cannot  be a parameter.  Assignment to the
             control variable within the body  of  a  FOR  statement  is
             prohibited.

             The  initial and final expressions are each evaluated once,
             upon entry to the FOR statement.  The control  variable  is
             assigned  the  initial  value  for the first iteration, and
             then on each subsequent iteration, successive  values  from
             the  range.  The  values  increase  if  TO is specified and
             decrease if DOWNTO is  specified.  The  last  iteration  is
             performed  when  the  control  value  is equal to the final
             expression.  If the initial value is greater than the final
             value  (TO) or less than the final value (DOWNTO), the body
             is never executed.

             Upon normal termination of the FOR statement, the value  of
             the  control variable is undefined; if the FOR statement is
             exited with an EXIT or GOTO statement, the control variable

             Statements
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 61


             contains  the  value  assigned  at  the  start  of the last
             iteration.


             11.2.4.4 LOOP Statements                      LOOP Statements

                  loop-statement ::= LOOP statement-list END

             The LOOP  statement  specifies  that  its  body  is  to  be
             repetitively  executed.  There  is no termination condition
             associated with the LOOP statement itself.  The only way to
             escape  from  a loop is with an EXIT, GOTO, RETURN, or STOP
             statement.


             11.2.4.5 EXIT Statements                      EXIT Statements

                  exit-statement ::=
                     EXIT IF expression [ DO unlabeled-statement ]

             Any repetitive statement  may  contain  one  or  more  EXIT
             statements.  If  the boolean-valued expression yields TRUE,
             the optional termination action is  executed,  if  present,
             and execution continues following the repetitive statement.
             Otherwise, execution continues with the statement following
             the EXIT statement.

             An  EXIT  statement  must be executed on each repetition of
             the repetitive statement.  That is, it may not be under the
             control  of  a  conditional statement within the repetitive
             statement.

             The optional termination action is part of the body of  the
             repetitive  statement.  Thus, any WITH statements enclosing
             the EXIT statement apply to the termination action as well.

















             Statements
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 62


             12 POINTERS AND DYNAMIC ALLOCATION                POINTERS AND DYNAMIC ALLOCATION



             Variables in Pascal generally have a lifetime equal to that
             of  the block in which they are declared.  A variable local
             to a recursive procedure may have several versions.  Static
             variables  are  created  once,  and  exist  throughout  the
             execution of the program.  Dynamic variables, however,  are
             created  under  direct  program control, and have lifetimes
             independent of any block's  activation.  They  are  created
             and  destroyed  in a storage area called the "heap" through
             the use of standard procedures.  Dynamic variables have  no
             names, and are instead referenced through pointers.

             Pointer  types  are  bound by their declaration to a single
             target type.  When a dynamic variable is created, its  type
             is the target type of the pointer which references it.  For
             example, when creating dynamic variables of  type  integer,
             pointer  variables of type "^integer" are used to reference
             them.  Pointer  expressions  yield  references  to  dynamic
             variables  when  they  are "dereferenced", denoted by a "^"
             immediately following the pointer expression.  For example,
             if  p  is  a pointer variable (or a pointer expression), p^
             references the associated dynamic variable  of  the  target
             type of p.

             As  mentioned  in Section 8.3, pointer types are compatible
             (and identical) only if their target types  are  identical.
             Several  means  exist  for  deliberate  violation  of  this
             compatibility rule (Section 12.5).  The predefined  pointer
             constant  NIL  is  compatible with all pointer types, and a
             pointer with this value  does  not  refer  to  any  dynamic
             variable.  A  pointer  variable  which  does not point to a
             dynamic variable, but may be examined,  should  be  set  to
             NIL.   A  pointer  expression  equal  to  NIL  may  not  be
             dereferenced.

             Recursive data structures may be easily defined  in  Pascal
             through the use of a structured type containing pointers to
             itself.  Records are typically used here, with a  field  or
             fields containing data, and pointer fields linking the node
             to its neighbors in  the  network.  Special  cases  of  the
             network are the tree and the list.

                  type
                    net_pointer = ^ net_node;
                    net_node = record
                      data1, data2, ... , datan: data_type;
                      link1, link2, ... , linkm: net_pointer
                      end;

             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 63



                    b_tree_element = record
                      key: b_tree_key;
                      next_leaf:  ^b_tree_node
                      end;

                    b_tree_node =
                      array [1 .. ((b_tree_order + 1) div 2)]
                        of b_tree_element;


             The  use  of  "net_node" in the definition of "net_pointer"
             occurs before  its  definition,  since  the  definition  of
             "net_node"  requires  the definition of "net_pointer".  The
             definition of field "next_leaf" in the second example  uses
             a  similar  reference  to type "b_tree_node".  Such forward
             references are  permitted  in  Pascal  for  pointer  types.
             Further,  if  no  pointer  of  a given pointer type is ever
             dereferenced or used in a call to NEW, then the target type
             of  the  pointer  type need not be defined at all.  Thus, a
             routine may pass and assign pointers without  knowledge  of
             the pointer's target type (see Section 8.3).



             12.1 Allocation and Deallocation of Pointers                  Allocation and Deallocation of Pointers


             The  lifetime  of  a  dynamic  variable is completely under
             program control.  Standard procedures are  used  to  create
             and   destroy   dynamic   variables,   whose  existence  is
             independent of scope.


             12.1.1 Allocation                    Allocation

             The predefined procedures NEW (p)  and  ALLOCATE (p,n)  are
             used  to create, or allocate, a dynamic variable of pointer
             p's target type.  Here, p must be a pointer reference; p is
             assigned  a  pointer  to the new dynamic variable (i.e., p^
             references the new  variable).  After  a  NEW  or  ALLOCATE
             operation,  p  points to a distinct dynamic variable of its
             target type, independent of any  previous  NEW  operations.
             The variable p^ is not initialized by NEW or ALLOCATE, with
             the exception that tag fields whose values  are  explicitly
             specified  in  the call to NEW are set to those values (see
             Section 12.4).

             NEW and ALLOCATE both take a pointer variable or expression
             (which  must  be  assignable) as their first parameter.  In
             NEW, a list of values selecting variants and/or a  flexible

             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 64


             array upper bound to be defined in the dynamic variable may
             optionally  follow.   An   integer-valued   expression   is
             specified  to  ALLOCATE as its second parameter, giving the
             number of storage units to  be  allocated  to  the  dynamic
             variable.  The  number  of  storage  units  to  allocate is
             usually determined via the SIZE  or  EXTENT  functions,  as
             described in Sections 12.3 and 12.4.


             12.1.2 Deallocation                    Deallocation

             The predefined procedure DISPOSE(px) is used to destroy, or
             deallocate, a dynamic  variable.  Here,  px  is  a  pointer
             expression.  The  dynamic  variable  px^ is deallocated and
             invalidated.  Any  subsequent   references   to   px^   are
             undefined.

             It   is  essential  that  allocation  and  deallocation  be
             properly  used  when   manipulating   dynamic   structures.
             DISPOSE  may  be  used to explicitly deallocate unnecessary
             dynamic variables.  This allows storage to  be  reallocated
             to   new   dynamic  variables.  Further,  if  all  pointers
             referencing a dynamic variable are  destroyed  because  the
             blocks containing them are no longer active, or the dynamic
             variables containing them have been deallocated,  then  the
             storage  allocated by the dynamic variable is "lost" to the
             program, i.e., will never be reallocated.  Thus, failure to
             DISPOSE  dynamic  variables  will  cause the heap to become
             full of unused, and likely inaccessible, dynamic variables.
             On   the  other  hand,  a  dynamic  variable  must  not  be
             referenced once  it  has  been  DISPOSEd,  nor  may  it  be
             DISPOSEd  again.  All  pointers  to  it must be reassigned;
             failure  to  do  so   creates   a   "dangling   reference".
             Dereferencing a dangling pointer is an error.

             In  the  example  below,  type "bin" is a binary tree, with
             fields "left" and "right" as  self-referent  pointers.  The
             subroutine KILL_BRANCH prunes a branch from such a tree.














             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 65


                  procedure kill_branch (var p:  ^bin);
                    begin
                    if p <> nil then begin
                      kill_branch (p^.left);
                      kill_branch (p^.right);
                      dispose (p);
                      p := nil
                      end
                    end;

             Notice that the nodes of the binary tree are deallocated in
             a postorder walk (that is,  the  children  of  a  node  are
             deallocated  before  the node).  The only dangling pointers
             in this routine exist between the DISPOSE operation and the
             assignment  of  p.  At all other points in the routine, the
             original subtree is a valid tree.



             12.2 Operations on Pointers                  Operations on Pointers


             Pointers may  be  assigned,  dereferenced,  and  passed  as
             parameters.  The comparison operators "=" and "<>" may also
             be used with pointers.

             The WITH statement (see Section 11.2.2), when used  with  a
             pointer  type  whose  target  type  is a record, provides a
             convenient way of walking linked  data  structures  without
             using extra temporary variables.  Since a WITH reference is
             evaluated once, at the  start  of  the  statement,  a  WITH
             reference  such  as  p^  frees  the  pointer  p  for use in
             operations  within  the  WITH  statement.  When  the   WITH
             statement  is  used within an iterative construct, p may be
             assigned to  the  next  operand  at  any  time  during  the
             iteration  without  affecting  the  WITH reference.  At the
             start of the next iteration, the  WITH  reference  will  be
             evaluated again, using the new value of p.

             The  logical  operators ANDIF and ORIF (see Section 10.1.4)
             are  useful  in  manipulating  recursive  structures.   For
             example,  in  structures  where a NIL pointer indicates the
             end of a subchain, a search for  a  desired  value  may  be
             performed easily by the following:

                  p := first;
                  while (p <> nil) andif (p^.value <> desired) do
                    p := p^.next;
                  (* if p = nil then failure else success;  *)



             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 66


             12.3 Pointers to Records with Variants                  Pointers to Records with Variants


             Many  applications  require  more  flexibility  in creating
             structures than can be obtained using identical nodes.  For
             example,  if  nodes  in a list structure can contain one of
             several disjoint sets of data, it is wasteful  to  allocate
             sufficient  space  for  each  node  to  hold  all data sets
             simultaneously.  Variant-record types permit records  of  a
             single type to have different structures.


                  type
                    votes = record
                      a, b: integer;
                      case c: boolean of
                        true:  ();     (* the null variant *)
                        false: (
                          d, e: integer;
                          f: char;
                          case integer of
                            0..4: (g: integer);
                            5,7,9:(h, i: integer);
                            6,8:  (j, k: char);
                            10:   (m: real);
                            others: () )  (* null *)
                    end (* of record definition *);

             Every  record of type votes contains fields a, b, and c.  A
             value for the tag field c may be  specified  to  NEW  as  a
             constant  following  the  pointer variable reference, which
             both initializes c and selects  the  substructure  for  the
             rest  of  the record.  Selecting TRUE creates no additional
             fields, and limits the size of the record to that  required
             for  a,  b,  and  c.  Every  record  for  which  c is FALSE
             contains fields d, e, and f.  A second nested variant  part
             follows,  for which a tag field value may also be specified
             to NEW to select the variant to  be  defined;  if  none  is
             specified,  the "5,7,9" variant will be chosen as it is the
             largest.  Notice that the CASE for the second variant has a
             type  but  not  a  field  name.  This is an undiscriminated
             union of fields in a record definition.  No  tag  field  is
             allocated  in  the record, and the integer used in the call
             to NEW is lost.  This prohibits run-time  checking  of  the
             tag field in record references; in fact, an undiscriminated
             union is similar to a FORTRAN EQUIVALENCE in which a single
             area  of  memory  may  be referenced by multiple names with
             different data types.  Notice in  the  example  above  that
             field  g  may reference its storage within the record as an
             integer, while field m may reference the same area  of  the
             record   as   a   real.  No  run-time  check  can  restrict

             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 67


             references to the variant given to NEW upon creation of the
             record;  the  user  must ensure that any references made to
             fields within an undiscriminated union actually exist.  For
             example,  the  call  NEW(p, false, 3) would create a p^ for
             which field "i" would not exist; a subsequent reference  to
             "p^.i" is invalid at run time, but would not be detected as
             an error.

             The  Pascal  i/o   system   (see   Section   14)   requires
             fixed-length entities in its typed files.  For example, the
             data type "FILE OF votes" (using the earlier example) would
             contain constant size records whose size corresponds to the
             "false, 5" variant list.  However, variable-length  dynamic
             variables  may  be  written  to  a  file  using  the EXTENT
             function in conjunction with  Pascal  binary  i/o.  If  the
             program  writes  the  size  of  each  variable  to the file
             immediately before  the  variable  itself,  the  file  will
             contain   enough   information  to  reread  the  variables.
             EXTENT(p), where p is a pointer, returns  the  size  of  p^
             only if p^ is a dynamic variable (i.e., is allocated on the
             heap), and is not a subrecord of another record.  Thus,

                  write (f, extent(p), p^: extent(p))

             will first write out the size of the variable p^, and  then
             the actual variable p^.  Notice that the size specification
             for  the  write  of  p^  is  necessary,  since  its  actual
             allocated size is not known at compile time.

             To  write  the  length of a variable which is not a dynamic
             variable to a file, the SIZE function should be used.  SIZE
             and  EXTENT  are  both  described in more detail in Section
             15.7.

             To read variables from such files, ALLOCATE  may  be  used.
             The  use  of  NEW  would  be awkward since the program must
             somehow determine the tag fields of the record being  read,
             and  then use a CASE statement to select an appropriate NEW
             call (since NEW must be  passed  constants  to  select  tag
             fields).  No  initialization  is performed by ALLOCATE, but
             in this case, none is needed since the entire variable will
             be  read  into  p^.  To  reconstruct p^ from a binary file,
             given an integer i, the following could be entered:

                  read (f, i);
                  allocate (p, i);
                  read (f, p^: i);


             If the dynamic variables written to a file are  deallocated
             after  being written, or if the file was written by another

             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 68


             program, then any pointer values read  from  the  file  are
             invalid.  Before  a  variable  is  written  to  a file, any
             pointer components can  be  "fixed  up"  to  refer  to  the
             correct  variable  by  coercing pointer values.  One method
             for doing so is to order the nodes in a network,  and  then
             to  write  each  node in order.  This strategy requires one
             extra  integer  component  per  node,   and   entails   two
             traversals  of  the  network.  The  first traversal assigns
             increasing integer values to each extra component  in  each
             node;  the  second traversal coerces each pointer component
             in the node to the integer value of the node  to  which  it
             refers,  and  then  writes  the  record.  Notice  that this
             method works with any network, and that  special  cases  of
             networks   may   reduce  this  overhead  considerably.  For
             example, a list need only have  its  data  written  out  in
             order; linkage information is unnecessary.

             The  following  warnings  are  given  concerning the use of
             variant records:

               (1) The program should not change tag fields in a  record
                   whose  values were specified on the call to NEW which
                   created the record, unless the new tag field  selects
                   the same variant.
               (2) Assignments  of  record  values to records created on
                   the heap with  variants  may  be  unsafe,  since  the
                   maximum  record size is copied.  If the record on the
                   heap is smaller than this maximum, locations  outside
                   the   record  may  be  modified,  with  indeterminate
                   results.



             12.4 Pointers to Flexible Arrays                  Pointers to Flexible Arrays


             Variant-record types (see Section  12.3)  can  be  used  to
             allocate  variable-length  records.  Similarly, pointers to
             flexible arrays can be  used  to  allocate  variable-length
             arrays.  The  declaration  of  an  array  type  whose index
             specification  gives  an  upper   bound   of   "*"   is   a
             flexible-array declaration.  Flexible arrays, records whose
             last field is a flexible array,  and  variants  whose  last
             field  is  a  flexible array can be created by calls to NEW
             with user-specified upper bounds  for  the  flexible  item.
             Since    the    flexible    item   is   always   last,   an
             integer-compatible expression appears as the last parameter
             to  NEW,  indicating the upper bound for the flexible item.
             Specification of an upper bound  for  a  flexible  item  is
             required.   Thus,  if  a  record  containing  one  or  more
             variants ending in flexible items  is  allocated,  all  tag

             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 69


             field  values  must  be specified if a variant containing a
             flexible item is selected.  Upper-bound specifications  may
             be  run-time  variable  expressions, while tag field values
             must be constant.

             The upper bound of a flexible item may  be  accessed  after
             its  creation  by  UPPERBOUND.  The  actual size of such an
             item may be acccessed using a  special  form  of  the  SIZE
             function  (see Section 15.7) which takes the upper bound of
             such an array as a parameter.

             Although EXTENT is recommended for generating the size of a
             variant  record  when writing to a binary file, SIZE may be
             used for a flexible array.  The item  preceding  the  array
             should be the array's actual upper bound.  For example:

                  write (f, upperbound (p^),
                      p^: size (p^, upperbound (p^));

             will  write  the flexible array's upper bound, and then its
             elements.  Rereading proceeds as follows:

                  read (f,i);
                  new (p,i);
                  read (f,p^: size (p^,i));

             For  nonvariant  records  containing  a  trailing  flexible
             field,  the  item  preceding  the  record may either be the
             length (via EXTENT or SIZE) of the  record,  or  the  upper
             bound  of the flexible field.  For reconstruction, ALLOCATE
             or NEW would be used, respectively.

             When using the former approach, SIZE  is  recommended  over
             EXTENT,  since  in  general,  EXTENT(p)>=SIZE(p^).  This is
             because  EXTENT  is  an  implementation-dependent  function
             which  returns  the  actual  size  of  the dynamic variable
             allocated by the heap manager.  In some cases, the  manager
             may  allocate  a  larger  area of storage than is required;
             EXTENT  returns  the  actual  size  of  the   variable   as
             allocated.  In other words, a dynamic variable is always as
             large as it needs to be, but it  may  be  larger;  repeated
             writes  and  rereads  may  increase the actual sizes of the
             dynamic variables involved.  Since EXTENT must be used  for
             variant  records,  this  problem  with  repeated  rereading
             cannot be avoided.







             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 70


                  type
                    flex = array [1..*] of integer;
                    flexptr = ^flex;
                    flexrec = record
                      a: integer;
                      case b: boolean of
                        true:  (c: integer);
                        false: (d: flex)
                      end;

                  var
                    f: flexptr;
                    g: ^flexrec;

             Given the above declarations, the following NEW calls could
             be made:

                  new (f, 100);       (* allocates 100-element array * )
                  new (g, true);      (* fields a, b, and c only *)
                  new (g, false, 30); (* fields a,b,d with up. bd.=30 *)

             Note  that both of the following are invalid because of the
             previously  noted  restrictions   on   allocating   records
             containing flexible items:

                  new (g);            (* must have upper bound *)
                  new (g, false);     (* still must have upper bound *)

             The  following  warnings  are  given  concerning the use of
             flexible-array items:

               (1) The upper bound of a flexible array cannot be changed
                   once it is created.
               (2) Assignment   of  records  with  final  flexible-array
                   fields is allowed only if the actual upper bounds  of
                   the  arrays are the same.  Assignment of records with
                   variants containing flexible arrays is prohibited.



             12.5 Pointer Coercions                  Pointer Coercions


             Pointer types are compatible (and identical) only if  their
             target   types   are  identical.  Given  the  existence  of
             variant-record and flexible-array types, this compatibility
             rule  need  not be violated for most applications.  In some
             cases,  however,  bending  this   compatibility   rule   is
             necessary   or  desirable  for  reasons  of  efficiency  or
             simplicity.  Also, in certain cases, it  becomes  necessary
             to form pointers to variables which were not created on the

             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 71


             heap, or to perform "pointer arithmetic".  The creation  of
             a  pointer  value by any means other than NEW, ALLOCATE, or
             the predefined constant NIL is called a  pointer  coercion.
             Pascal  provides explicit conversion functions which permit
             the user to coerce pointers in a straightforward manner.

             The most general pointer coercion function is

                  pointer_type_name(p)    or    pointer_type_name(n)

             where p is an expression of any pointer type, and n  is  an
             integer-compatible  expression.  These constructions form a
             pointer of the pointer type identified by pointer_type_name
             whose value equals the value of p or n.  For example,

                  type
                    credit = ^integer;
                    debit = ^credit;

                  var
                    a: credit;
                    b: debit;

             creates  the  functions  "credit"  and  "debit",  which are
             available for pointer coercions such as:

                  a := credit(b);      (* convert a debit to a credit *)
                  b := debit (1923);   (* integer constant *)

             The   predefined    function    ORD    (x)    returns    an
             integer-compatible value corresponding to the integer value
             of a pointer if x is of a pointer type, or  the  zero-based
             ordinal  of  a  scalar if x is of a scalar type.  Using ORD
             permits construction  of  pointer  arithmetic  expressions,
             such as:

                  a := credit (ord (b) + 13);      (* dangerous!! *)
                  a := credit (ord (b) + size (b)) (* better form *)

             Using integer constants in pointer expressions is a primary
             cause of machine dependence.  The SIZE function can usually
             replace   such   integer   constants,   preserving  machine
             independence.

             The  predefined  type  PTR  is  a  pointer  type  which  is
             compatible  with  all  other  pointer  types.  This type is
             especially useful as a parameter type  for  routines  which
             perform  some  function  independent  of  the  type  of the
             pointer.  Note that this also defines the  function  PTR(p)
             or PTR(n), as for all other pointer types.


             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 72


             The  predefined function ADDRESS(x) returns a value of type
             PTR which is a pointer to  the  reference  x.  The  ADDRESS
             function  can  be used to form pointers to items not on the
             heap, and to aid in pointer arithmetic operations.  Careful
             use of ADDRESS will not compromise machine independence.

             The following restrictions exist for arguments to ADDRESS:

               (1) The argument must be a valid reference.
               (2) The argument cannot be an elementary packed component
                   (that is, a component of a  packed  array  or  packed
                   record  which  is  not  itself  a  record,  array, or
                   string).
               (3) The argument cannot be a substring.

             It is possible to form  pointers  to  subrecords  within  a
             record by using the ADDRESS function.

             Notice  that modification of a "credit" heap variable above
             (for example) via a "debit" pointer, or modification  of  a
             nonheap variable whose address is accessible via a pointer,
             may cause errors in a given  implementation.  Specifically,
             standard optimization techniques involving the detection of
             common subexpressions and the analysis of data flow  assume
             that pointers of a given type can only reference a group of
             variables (the base type) whose elements  are  inaccessible
             except  through pointers of that type.  Modifying base type
             variables through other pointers, or using the pointers  to
             modify  variables  other  than  those of the base type, may
             invalidate compiler optimization assumptions, and cause the
             generation    of    incorrect    code.   For   a   specific
             implementation, such operations  are  documented  as  being
             potentially dangerous.



















             Pointers and Dynamic Allocation
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 73


             13 EXCEPTIONAL CONDITION HANDLING                EXCEPTIONAL CONDITION HANDLING



             An  "exceptional  event" ("exception") can occur during the
             execution of a program, and normally causes the program  to
             terminate  immediately.  An  exception may be caused by the
             user pressing the break key, i.e., an attention  interrupt,
             or  it  may  be caused by some action of the program, e.g.,
             division by zero.  The Pascal "exception manager"  is  able
             to  intercept  the occurrence of an exception, "signal" the
             appropriate  "condition",   and   prevent   the   immediate
             termination  of the program.  The language defines a set of
             standard conditions, which are  automatically  provided  in
             the initial environment.  The predefined condition signaled
             by the exception manager allows the  program  to  recognize
             and   handle  the  event.  Other  user-defined  conditions,
             without any intrinsic meaning,  may  also  be  declared.  A
             program  can also signal a condition explicitly, by calling
             the  standard  procedure  SIGNAL.  When  a   condition   is
             signaled,  execution  stops  at  the  current location, and
             resumes at a "handler" defined elsewhere in the program.



             13.1 Conditions and Condition Handlers                  Conditions and Condition Handlers


             A condition is denoted in a program by a condition name and
             is  subject  to  the  same  scope  rules  as type names and
             variable identifiers.  Names  for  user-defined  conditions
             are declared in exception declarations:

                  exception-declaration ::=
                     [ PUBLIC | EXTERNAL ] EXCEPTION
                        identifier [ ',' identifier ] ...

             Condition  names  at the outermost level of a module may be
             declared as PUBLIC or EXTERNAL.  It  doesn't  matter  which
             module  a  public condition name is declared in, so long as
             it is declared PUBLIC in exactly one module,  and  EXTERNAL
             in every other module that uses it.

             Any   compound   statement  may  have  a  "handler  clause"
             associated with it.  A handler clause follows the statement
             list  of  the  compound  statement,  and  precedes  the END
             keyword.  A handler clause applies only  to  the  statement
             list  preceding  it.  Handler  clauses  are very similar to
             CASE statements, except that the alternative statements  in
             a  handler  clause are labeled with condition names instead
             of constants.

             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 74


               compound-statement ::=
                  BEGIN statement-list [ handler-clause ] END

               handler-clause ::=
                  EXCEPTION handler [ ';' handler ] ... [';']

               handler ::=
                  condition-list ':' unlabeled-statement

               condition-list ::=
                  condition-identifier[ ',' condition-identifier ] ...  
                  | OTHERS | ALLCONDITIONS


             When a condition is signaled, a handler clause  may  become
             "active";  i.e.,  it  may  react  to the exceptional event.
             Activation  of  handlers  is  discussed  in  the  following
             sections.



             13.2 Signaling a Condition                  Signaling a Condition


             A  condition  may be signaled in one of two ways.  When the
             Pascal exception manager  detects  an  exception,  it  will
             signal   an   appropriate  standard  condition.  Also,  the
             standard procedure SIGNAL may be called with a user-defined
             condition  name  as  an  argument  to  signal the indicated
             condition.  The format of a call to SIGNAL is:

                  SIGNAL (user-condition);

             User-defined conditions can be very useful for dealing with
             the  kinds  of  problems  that nonlocal GOTO statements are
             usually used for.  With user-defined conditions,  the  main
             program could declare, "EXCEPTION commanderror".  Errors in
             the processing of a command line  could  then  be  signaled
             with  "SIGNAL(commanderror)",  which would transfer control
             to a handler in the main program.  A call to SIGNAL without
             an  argument  is  allowed  when some handler is active.  In
             this case it resignals the condition whose signaling caused
             the  handler  to be activated.  This is particularly useful
             in an OTHERS handler (see Section 13.3.1), which may  first
             perform  some  general  action  and  then  call  SIGNAL  to
             resignal the condition for a specific handler.






             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 75


             13.3 Handling a Signaled Condition                  Handling a Signaled Condition


             When  an  exceptional  condition   is   signaled,   program
             execution   is   stopped  immediately,  and  the  following
             signaling algorithm is executed:

             (1)  The "current statement" is defined to be the statement
                  which  was  being  executed  when  the  condition  was
                  signaled.

                  If the current statement is contained  in  a  compound
                  statement  which  has  a  handler  clause,  then  that
                  handler clause is termed "active".  Similarly, if  the
                  current  statement  is in a procedure or function, and
                  the statement  which  called  it  is  contained  in  a
                  compound  statement  which  has a handler clause, that
                  handler  clause  is  termed  active.  In  general,   a
                  handler  clause  is active if any calling statement in
                  the current call stack is contained  in  its  compound
                  statement.

                  If some active handler clause contains a handler which
                  is  labeled  with  the  signaled  condition  or   with
                  ALLCONDITIONS,  then  perform the signaling algorithm,
                  starting  with  step  (2).  Otherwise,  terminate  the
                  program  immediately  without applying the rest of the
                  signaling algorithm.

             (2)  Let the "current compound statement" be the  innermost
                  compound   statement   which   contains   the  current
                  statement.  If the current compound  statement  has  a
                  handler  clause  containing a handler which is labeled
                  with the signaled condition, OTHERS, or ALLCONDITIONS,
                  then go to step (4).  Otherwise, go to step (3).

             (3)  If  the  current  compound  statement is the body of a
                  procedure or function, then  terminate  this  routine,
                  redefining  the  current statement to be the statement
                  that  this  routine  was   called   from.   Otherwise,
                  redefine  the  current  statement  to  be  the current
                  compound statement.  Now repeat step (2).










             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 76


             (4)  Execute the handler statement which  is  labeled  with
                  the  signaled condition, OTHERS, or ALLCONDITIONS.  If
                  there is a choice, choose the handler statement  which
                  is  labeled  with  the  signaled condition.  A handler
                  clause is not  allowed  to  contain  both  OTHERS  and
                  ALLCONDITIONS  handlers.  Following  completion of the
                  handler statement, continue the program as though  the
                  current  compound  statement  had  completed execution
                  normally.




             13.3.1 OTHERS Handlers                    OTHERS Handlers

             If a handler clause has no handler labeled with the name of
             a  signaled condition, but does have a handler labeled with
             OTHERS, then the  OTHERS  handler  will  be  activated.  An
             OTHERS  handler  allows  a  routine  to  perform  necessary
             clean-up activities when it is terminated by the  signaling
             of  a  condition  for  which  it  doesn't  have an explicit
             handler.  Therefore, an OTHERS handler should  end  with  a
             SIGNAL  call,  to  pass  the  signaled  condition  on to an
             explicit handler.  (This is not a language requirement, but
             an  OTHERS  handler  which  did  not end by resignaling its
             activating condition would not be useful.)   The  following
             example illustrates the intended use of OTHERS handlers:

                  program example;
                  exception A, B, C;

                  procedure x;
                  begin
                     (* may signal A, B, or C *)
                  end;

                  procedure p;
                  var f: text;
                  begin
                     ...
                     rewrite (f, ...);
                     begin
                        (* miscellaneous file processing; calls x;
                           also calls p recursively *)
                     exception
                        others:  begin close (f); signal () end
                     end;
                  end (* p *);

             If  procedure  x  were to return to the main program with a
             nonlocal GOTO on encountering  an  error,  then  the  files

             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 77


             opened  by the multiple, recursive invocations of procedure
             p could never be closed.  Procedure x returns to  the  main
             program  by  signaling,  however,  and  each  invocation of
             procedure p has its own handler, to close the file that  it
             has  opened  before  resignaling the condition.  A possible
             sequence of actions might be:

                  Main program calls p(1)
                     p(1) opens f1
                     p(1) calls p(2)
                        p(2) opens f2
                        p(2) calls p(3)
                           p(3) opens f3
                           p(3) calls x
                              x signals A
                           p(3)s handler closes f3
                           p(3)s handler resignals A
                        p(2)s handler closes f2
                        p(2)s handler resignals A
                     p(1)s handler closes f1
                     p(1)s handler resignals A
                  Main program's handler for A takes control




             13.3.2 ALLCONDITIONS Handlers                    ALLCONDITIONS Handlers

             An OTHERS handler performs some  specific  clean-up  action
             and  then  resignals its activating condition.  It does not
             handle any condition itself; it simply allows  the  routine
             that  declared  it  to  clean  up  behind itself when it is
             terminated  by  the  signaling  of  some  condition,  which
             presumably will be handled by an explicit handler elsewhere
             in the program.  Consequently, step (1)  of  the  signaling
             algorithm  will invoke the full signaling algorithm only if
             there is an active handler clause with an explicit  handler
             for  the  signaled  condition:  if  the only active handler
             which could handle the condition is an OTHERS handler, then
             the program will simply terminate.

             An  ALLCONDITIONS  handler  acts as an explicit handler for
             any condition which does not have a labeled handler in  the
             same clause.  It really does handle any condition which may
             happen to be signaled, and it is not expected  to  resignal
             the  condition.  Thus, an ALLCONDITIONS handler may be used
             in a program or subroutine to recover from any exception or
             signaled condition.  However, note that the recovery may be
             imperfect, since all the conditions that  the  handler  may
             have  to  recover from may not be known.  In general, it is
             much safer if the user explicitly enumerates the conditions

             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 78


             he or she is prepared to handle.



             13.4 Maskable Exceptions                  Maskable Exceptions


             Most  exceptions  make  normal  continuation of the program
             impossible and must be responded to  immediately.  However,
             some  conditions  may be signaled long after the occurrence
             of their  exceptions,  allowing  the  program  to  continue
             normally  in  the  interval.  Such  exceptions  are  called
             "maskable".

             The standard procedure MASK (condition) tells the exception
             manager  not  to  signal  "condition"  when  its  exception
             occurs,  but  simply  to  make  an  internal  note  of  the
             exception.   The  argument  to  MASK  must  be  a  maskable
             condition.  Following a call to MASK, the condition is said
             to   be  "masked".  A  masked  condition  whose  associated
             exception has actually occurred is said  to  be  "pending".
             Reoccurrence  of  a  pending  exception has no effect:  the
             only possible states for a masked exception are pending and
             not pending.

             A  program  can  test whether a masked condition is pending
             with the standard function call  PENDING (condition).  This
             will  return TRUE if the condition is pending, and FALSE if
             it is not.  It will always return FALSE if the condition is
             not   masked.  It  also  resets  the  condition's  internal
             "pending" flag, so that a subsequent call to  PENDING  will
             return FALSE unless the exception reoccurs in between.

             The  standard  procedure  call UNMASK (condition) unmasks a
             masked condition.  When  a  masked,  pending  condition  is
             unmasked, it will be signaled immediately.  MASK and UNMASK
             calls can be "stacked"; that is,  if  condition  A  is  not
             masked,  after the sequence MASK(A), MASK(A), UNMASK(A), it
             will be masked, but after an additional UNMASK(A), it  will
             be  unmasked.  A  call  to UNMASK with a condition which is
             not masked will result in an error.

             The standard function call MASKED (condition) may  be  used
             to determine whether a condition is masked.  It will return
             TRUE if the condition is masked  and  FALSE  if  it  isn't.
             Like  MASK  and  UNMASK, MASKED may be called only with the
             names of maskable conditions.





             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 79


             13.5 Standard Conditions                  Standard Conditions


             The language provides a collection of standard  conditions,
             which  need  not  be  explicitly  declared by programs that
             refer to them.  These standard conditions are  signaled  by
             the Pascal exception manager when it detects an exception.

             Many  standard  exceptions  have  standard status functions
             associated with them.  Such a status function may  only  be
             invoked  when  a handler for the corresponding condition is
             active.


             13.5.1 Arithmetic Exceptions                    Arithmetic Exceptions

             Any arithmetic exception  which  can  be  detected  by  the
             implementation will cause the standard condition MATH_ERROR
             to be signaled.  The MATH_ERROR condition may  be  signaled
             either for a hardware arithmetic error, such as division by
             zero, or for an error in a standard math function,  such  a
             negative argument to SQRT.

             A handler for this condition may call the standard function
             MATHSTATUS to determine what arithmetic exception occurred.
             MATHSTATUS  will  return  a  value  of  the enumerated type
             MATH_STATUS.  The  values  of  this  type  depend  on   the
             implementation, but their names all begin with "MATH_".


             13.5.2 Input/Output Exceptions                    Input/Output Exceptions

             When  a fatal error occurs during the performance of an i/o
             operation, the run-time system  will  signal  the  standard
             condition  IO_ERROR.  A  handler for this condition may use
             the  standard  function   EXIOSTATUS   to   determine   the
             particular  i/o  error  which  occurred.  EXIOSTATUS,  like
             IOSTATUS (see  Section  14.6),  returns  a  value  of  type
             IO_STATUS.   However,   IOSTATUS   always  returns  a  code
             describing the last  i/o  operation  that  occurred,  while
             EXIOSTATUS  returns  a  code  describing the exception that
             caused the IO_ERROR handler to be activated.

             Note that when the RETRY option is  set  for  a  file,  the
             IO_ERROR  condition  will  not  be  signaled  until the i/o
             operation  following  the  operation  on  which  the  error
             actually  occurs.  This  allows  the  program to detect the
             error (with IOSTATUS) and correct it before  the  exception
             has a chance to occur.



             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 80


             13.5.3 Program Exceptions                    Program Exceptions

             Program exceptions are all those errors whose detection can
             be controlled with some type of run-time checking.  When  a
             program  exception occurs, the PROGRAM_ERROR condition will
             be signaled.  A PROGRAM_ERROR  handler  can  determine  the
             particular user exception which has occurred by calling the
             standard function PROGRAMSTATUS, which returns a  value  of
             the  enumerated  type PROGRAM_STATUS.  The elements of this
             type include,  but  are  not  necessarily  limited  to  the
             following:

             PROGRAM_OK         never returned as an error code
             PROGRAM_ASSERTION  FALSE argument in assertion call
             PROGRAM_CASE       case selector not in case label list
             PROGRAM_COMPATIBIL lengths don't match in array assignment
             PROGRAM_FILE       NIL or undefined file in i/o call
             PROGRAM_POINTER    NIL or undefined pointer dereferenced
             PROGRAM_SUBSTRING  index or length out of bounds
             PROGRAM_SUBSCRIPT  array subscript out of bounds
             PROGRAM_VALUE      scalar value out of range


             13.5.4 Attention and Overflow Exceptions                    Attention and Overflow Exceptions

             Most  systems  provide some sort of feature to allow a user
             to interrupt an executing program.  In  any  implementation
             in  which  a  program  can  trap  such  interrupts,  a user
             interrupt  will  cause  the  ATTENTION  condition   to   be
             signaled.

             When  a  call  to  NEW  causes  storage  to  overflow,  the
             allocator will signal the STORAGE_OVERFLOW condition.  If a
             program runs out of space in the stack that Pascal uses for
             storing  local  variables  and  linkage   information   for
             procedures and functions, it will signal the STACK_OVERFLOW
             condition.  (Note that if  a  handler  for  this  condition
             attempts  to do any procedure or function calls, the result
             will probably be another stack overflow.)













             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 81


             13.5.5 Miscellaneous Exceptions                    Miscellaneous Exceptions

             Most systems can detect a variety of miscellaneous  errors.
             The  occurrence  of  such  an error will cause the standard
             condition SPECIAL_ERROR to be signaled.  A handler for this
             condition  may  call the standard function SPECIALSTATUS to
             determine  just  which  special  exception  occurred;  this
             function  will  return  a  value  of  the  enumerated type,
             SPECIAL_STATUS.  The  possible  values  of  this  type  are
             completely dependent on the implementation, but their names
             all begin with "SPECIAL_".



             13.6 Warning Messages                  Warning Messages


             For some programs, it is useful to  have  a  handler  which
             intercepts  a  large class of conditions, ignores them, and
             simply restarts the program at  a  convenient  point.  This
             handler  might  print  a  warning  message  describing  the
             condition that has been  ignored.  The  standard  procedure
             EXCEPTION_MESSAGE,  which  is  called  with  no  arguments,
             types, on the user's terminal, the appropriate message  for
             the  condition  that was last signaled.  Where appropriate,
             it will modify the message to indicate that it is a warning
             message rather than an error message.

























             Exceptional Condition Handling
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 82


             14 INPUT AND OUTPUT                INPUT AND OUTPUT



             Transfer  of data between a Pascal program and a peripheral
             device is accomplished through  a  file  variable.  A  file
             variable  in  the program may be associated with a physical
             file or device at run time.  The name of the file  variable
             may be referred to as its "file identifier".  Each physical
             file is  identified  by  the  contents  of  some  character
             string; this string is called its "file name".

             Pascal input/output is device independent in the sense that
             the  standard  i/o  operations  are   not   restricted   to
             particular  devices.  Any  specific  information  about the
             location, device, physical structure, etc., of  a  physical
             file  is encoded in its file name, which is a string passed
             to a standard procedure associating a physical file with  a
             file  variable.  This  means that the format of a file name
             may vary from one Pascal implementation to another.  Pascal
             also   provides   for  communication  with  an  interactive
             terminal controlling a program.



             14.1 File Types, Variables, and Modes                  File Types, Variables, and Modes


             A file variable, like all variables in Pascal, has a  type,
             in this case, a file type, declared as follows:

                 file-type ::= [PACKED] FILE OF {type | '*'}

             A file type is bound to the type specified in the file-type
             declaration.  The type to which a file  type  is  bound  is
             referred  to  as  its "component type".  The component type
             determines:  (1) the  format  of  individual   data   items
             (commonly  called "records" in other programming languages)
             composing the file, and (2) an attribute referred to as the
             "mode"  of  the file.  A file type with an asterisk instead
             of a component type is not bound to any  type.  Data  items
             (records) of any type and length may be written to and read
             from such a file.

             There are three file modes:  "text", "typed", and "binary".
             Text  files are of the type PACKED FILE OF CHAR.  TEXT is a
             predefined  identifier  for  this  type.  Files  without  a
             component  type  (FILE  OF *) are binary files.  Text files
             are   accessed   sequentially,   and   certain   conversion
             operations  on  them  are  provided,  allowing variables of
             types besides CHAR to be input or output.  Files  of  other

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 83


             modes  may be accessed sequentially and/or randomly, and no
             conversions are provided.  Pascal text files will  probably
             be  compatible  with  text files on systems with a standard
             text file format; however, this is  not  guaranteed.  While
             access  to  files  of  other  modes is always the same, the
             physical  formats  of   such   files   are   implementation
             dependent.

             File  types  are  not  compatible unless they have the same
             mode.  Furthermore, for two typed files to  be  compatible,
             they  must  have  identical component types.  For two files
             having the same mode, both must be packed or both  must  be
             unpacked to be compatible.  (Packed files may be maintained
             in a more compact format  with  potentially  longer  access
             times than unpacked files.)

             Several  operations  between  compatible file variables are
             defined.  The first is assignment of  one  compatible  file
             variable  to  another.  The  result  of  assigning two file
             variables is that either may subsequently be used to access
             the  physical  file  associated with the file variable from
             which assignment was made.  If the file variable  to  which
             assignment  is made was associated with some other physical
             file,  the  association  may  be  "lost",  since  the  file
             variable is now associated with a different file.  However,
             the file with which it was previously  associated  has  not
             been closed.

             Another  operation  between  compatible  file  variables is
             making comparisons for equality (=)  and  inequality  (<>).
             Normally,  two  file  variables  separately associated with
             files will not be equal, even if they are  associated  with
             the same physical file.  Two file variables can only become
             equal by assignment, with the exception of those associated
             with  the  terminal, for which special provisions are made.
             Parameters of file type  may  be  declared  and  passed  to
             routines.  However,  since  the  state  of their associated
             physical files will  be  altered  if  such  parameters  are
             referenced at all, they must be declared as var parameters.

             A   third   operation  between  compatible  file  variables
             involves the assignment  of  a  predefined  constant  NILF,
             compatible with all file types.  A file variable with value
             NILF is not associated with any physical  file  or  device.
             NILF  may  be  used with files in a manner analogous to NIL
             with pointers.

             There are  no  restrictions  on  the  declaration  of  file
             variables.  They  may  be declared as components of arrays,
             records, etc., and as local variables of a routine.  In the
             latter  case,  if  the  file  variable  is  not STATIC, its

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 84


             association with a physical file is not preserved,  nor  is
             the  file  automatically  closed when the enclosing routine
             returns.  The association is thus "lost",  if  the  routine
             does  not  explicitly  close  the  file,  just  as  storage
             associated with local pointers which  is  not  disposed  is
             lost.  Component  types  of  file variables may not contain
             flexible  or  generic  arrays.  While  they   may   contain
             subroutine,  pointer,  and even file types, it is important
             to remember that values of variables  of  these  types  are
             "program dependent".  Thus, when such variables are read in
             one program from files written by  another  program,  their
             values should be considered to be undefined.

             Every  file  variable  having  an  explicit component type,
             i.e., all except binary, has a  "buffer  variable".  For  a
             file  variable  F  of  type  FILE  OF  T,  F^ is its buffer
             variable, which is of type T.  The  buffer  variable  of  a
             text  file  is  of type CHAR.  All i/o is performed through
             the buffer variable, i.e., when an item is  read  (via  the
             GET  routine)  from  the  file,  it is read into the buffer
             variable, and when an item is written (PUT),  the  contents
             of the buffer variable are written.

             When  i/o  is  performed with GET and PUT, the program must
             explicitly copy data into or out of  the  buffer  variable.
             Therefore,  additional  standard  i/o routines are provided
             (READ and WRITE) which automatically  move  data  from  the
             buffer to program variables after input, or into the buffer
             before  output.  Since  a  binary  file  does  not  have  a
             component  type, it does not have a buffer.  Thus, only the
             READ and WRITE routines may be used with binary files.



             14.2 Association with Physical Files, Devices                  Association with Physical Files, Devices


             Before communication with a physical  file  or  device  can
             take  place,  it  must  be  associated  with  a Pascal file
             variable.  As noted earlier, the mode of the physical  file
             and  the  logical  structure  of  data  to  be read from or
             written to it are defined by the type of the file variable.
             In addition to the file name, which identifies the physical
             file or device, certain other information is  specified  at
             the time of association.







             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 85


             14.2.1 Association                    Association

             The direction of subsequent data transfer is defined by the
             standard routine called to associate a file variable with a
             physical file or device, as follows:

               OPEN    --input, valid only with text files
               RESET   --input
               REWRITE --output
               UPDATE  --both   input  and  output;  invalid  with  text
                         files

             A set of options selected  from  the  following  predefined
             scalar type IO_OPTIONS may also be specified:

               SEEKOK   --allow random access (calls to SEEK allowed)
               IMAGE    --transfer characters without conversion
               PRESERVE --do not delete previous contents of file
               ASCII    --do not skip/ignore nonprinting characters
               CONTROL  --interpret first character of output lines as 
                          carriage control
               RETRY    --on fatal i/o errors, return control to program
                          for recovery attempt

             Each of these options is discussed in greater detail later.
             SEEKOK is valid only with typed and  binary  files,  IMAGE,
             CONTROL,  and  ASCII  only  with  text files, and RETRY and
             PRESERVE with all files.

             The format for a call on any of these standard routines is

                 operation '('file-variable [','file-name] 
                         [','option-set] ')'

             for example:

                 RESET    (F,[ASCII,PRESERVE]);
                 REWRITE  (F,'string',[PRESERVE]);
                 UPDATE   (F,S1||S2).

             If no file name appears, as in the call to RESET above, the
             file      variable      is      associated      with     an
             implementation-dependent  physical  file.  This   "default"
             physical  file  is  a  function  of the file identifier, so
             identical file identifiers in different  programs  will  be
             associated  with  the  same  default file.  A file variable
             which cannot be referenced  by  a  single  identifier  (for
             example,  a  component  of  an  array) cannot be associated
             without an explicit file name.  In addition, the predefined
             file  variables  TTY  and TTYOUTPUT, both of type TEXT, are
             automatically  associated  with  the  interactive  terminal

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 86


             controlling  a  program if no file name is specified.  They
             are public, i.e., references to them in all  modules  refer
             to  the  same variables.  Further, the identifier TTYOUTPUT
             is implicitly substituted for TTY when TTY appears  in  the
             parameter  list  of  any  standard  output  routine,  e.g.,
             REWRITE.  If the following associations are made:

                 OPEN(TTY) or RESET(TTY);
                 REWRITE(TTY); (*TTYOUTPUT implicitly substituted for 
                                TTY*)

             the  only  instances  where  TTYOUTPUT  must  be  specified
             explicitly  as  the  "output  side"  of  the  terminal  are
             (1)  when passed as an actual file parameter, and (2)  when
             accessing the file buffer variable.

             These   conventions   provide  the  appearance  of  two-way
             communication  with  the  controlling  terminal  through  a
             single  file  identifier,  without actually associating the
             identifier with UPDATE, an operation which is  not  allowed
             on text files.

             INPUT  and  OUTPUT  are  two  other predefined, public file
             variables of type TEXT.  If a file variable is omitted in a
             call  to certain standard input routines, INPUT is assumed.
             Similarly, if no file variable appears  in  calls  to  some
             standard   output   routines,   OUTPUT  is  assumed.  These
             assumptions are made for the convenience  of  users.  Aside
             from   their   predeclaration   and  use  as  default  file
             identifiers in  certain  routines,  INPUT  and  OUTPUT  are
             normal text files.

             As  noted earlier, options may be specified when a physical
             file is  associated.  If  no  options  are  specified,  the
             following defaults are assumed by the various routines:

                 OPEN,  RESET    preserves  the  contents  of an already
                     existing file.  Only printable characters  will  be
                     read from text files, with others being ignored.

                 REWRITE    deletes  the  contents  of  the  file, if it
                     already  exists.  Otherwise,  an  empty   file   is
                     created.  Any  and all characters may be written to
                     character files.

                 UPDATE    preserves the contents of an  existing  file.
                     Otherwise, an empty file is created.  Additionally,
                     random access is allowed.

             In  the  cases  where  contents  of  a  file  are  normally
             preserved,  deletion of contents cannot be specified via an

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 87


             option, but may be accomplished by a subsequent call  to  a
             standard routine, EMPTY.

                 EMPTY(file-variable)      deletes  the  contents of the
                     associated  physical  file  which  must  have  been
                     associated   with   REWRITE   or   UPDATE.  Default
                     deletion of contents by REWRITE may  be  overridden
                     by specifying PRESERVE.

             Suppression  of  nonprinting  characters  on  input  may be
             overridden by specifying  the  ASCII  option.  Finally,  if
             random  input  or  output are to be performed on a file not
             associated with UPDATE, SEEKOK must be specified.

             The implications of specifying the IMAGE and RETRY  options
             will be discussed later.

             Finally,  the file name associated with a file variable may
             be obtained by calling the standard function FILENAME.

                 FILENAME(file-variable)    returns  the  name  of   the
                     associated  physical  file or device as a string of
                     the predefined varying string type FILE_NAME, whose
                     maximum  length  is  implementation dependent.  The
                     result returned by FILENAME when called with a file
                     variable  which  is  not associated with a physical
                     file or device is undefined.


             14.2.2 Dissociation and Multiple Associations                    Dissociation and Multiple Associations

             All  physical  files  and  devices  associated  with   file
             variables   when   a   program   terminates   normally  are
             automatically dissociated.  Files may also  be  dissociated
             during  program execution by calling either of two standard
             routines:

                 CLOSE[ (file-variable) ]    is normal dissociation.  If
                     the   file  variable  is  omitted,  all  files  are
                     dissociated as if the program had terminated.

                 SCRATCH(file-variable)    dissociates   the   specified
                     file  variable  and  deletes the physical file.  If
                     deletion fails  or  is  otherwise  impossible,  the
                     effect is the same as CLOSE.

             Situations  requiring  explicit dissociation during program
             execution include:  (1) deletion of a  temporary  "working"
             file  when  it is no longer needed, (2) before performing a
             sequence of operations on one physical file which have been
             performed on another, (3) to make a physical file which has

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 88


             been modified available to other programs while the program
             making the modifications continues to execute.

             As   suggested  in  (2)  above,  a  file  variable  may  be
             dissociated from one physical file and then associated with
             another,  i.e.,  file  variables may be multiply associated
             during the execution  of  a  program.  Normally,  CLOSE  or
             SCRATCH  must  be  called  before  the second call to OPEN,
             REWRITE, etc., or the first association will be "lost".  In
             other words, the external environment of the program, e.g.,
             the operating system, will still view the physical file  as
             associated  with  the program, yet the program will have no
             way of further  referencing  the  file.  If,  however,  one
             associated file variable is assigned to another, either can
             safely be associated with another physical file without  an
             intervening  CLOSE  or  SCRATCH.  In  fact,  if  a CLOSE or
             SCRATCH  is  performed  on  one,  the  same  operation   is
             implicitly  performed  on  the  other.  Finally,  CLOSE and
             SCRATCH should never be called with a  file  which  is  not
             associated.

             Association and dissociation of file variables and physical
             files  is  analogous  to  allocation  and  deallocation  of
             pointers.  For  instance,  omitting/performing CLOSE before
             RESET on a file variable previously associated  is  similar
             to  omitting/performing  DISPOSE  before  NEW  on a pointer
             previously allocated.

             A certain amount of additional "clean-up" is provided  with
             files, in that all associated files, whether "lost" or not,
             are dissociated by a CLOSE call without  arguments  and  by
             normal program termination.

             At certain points while writing a file, it may be desirable
             or necessary to insure that all write operations which have
             been performed by the program are reflected in the physical
             file, which may not be the case if i/o is buffered  in  the
             implementation.  The  standard  procedure  BREAK  should be
             called at these points:

                 BREAK [ (file-variable) ]    insures that  the  results
                     of  all  previous write operations are reflected in
                     the physical file  associated  with  the  specified
                     file  variable.  The  file  variable must have been
                     associated with REWRITE  or  UPDATE.  If  the  file
                     variable is omitted, TTYOUTPUT is assumed.  The use
                     of BREAK with interactive i/o is discussed  further
                     in Section 14.3.4.2.




             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 89


             14.3 Text File Input and Output                  Text File Input and Output


             Sequential character input and output is the most basic and
             most  commonly  used  mode  of  i/o.  In  Pascal,  this  is
             accomplished  through file variables of the predefined type
             TEXT.


             14.3.1 Text File Structure                    Text File Structure

             A Pascal  text  file  is  best  viewed  as  a  sequence  of
             characters  punctuated  with  marks  signifying  the end of
             lines, pages, and the file.  Characters are read one  at  a
             time  into the file variable's buffer variable.  Whenever a
             mark is read, instead of reading some special character,  a
             standard boolean function is set to return TRUE and a blank
             is placed in the file's buffer  variable.  When  characters
             which  are  not  marks  are  read,  all  of  these standard
             functions return FALSE.  Similarly, characters are  written
             one-by-one to a file from the buffer variable, and routines
             are called to write  marks,  rather  than  writing  special
             characters.   This   approach   frees   programs  from  the
             implementation-dependent formats for lines, pages, and  the
             file itself.


             14.3.2 Basic Character Input and Output                    Basic Character Input and Output

             The basic character i/o routines are:

                 GET    --input next character into buffer
                 PUT    --output the character currently in buffer
                 EOLN   --TRUE if end of line just encountered on input
                 EOPAGE --TRUE if end of page just encountered on input
                 EOF    --TRUE if end of file just encountered on input
                 WRITELN--terminate the current line
                 PAGE   --terminate the current page

             The  file  on which to perform the operation is a parameter
             to all of  these  routines.  If  omitted,  file  OUTPUT  is
             assumed  for  output  operations  and  file INPUT for input
             operations.  Files  are   automatically   terminated   when
             dissociated;  hence,  there  is no routine to output a file
             terminator.  Note that WRITELN,  while  it  is  a  standard
             routine   name,  is  also  a  reserved  word,  for  reasons
             discussed later.

             Page marks always  occur  at  the  end  of  lines  and  are
             signaled  at  the  same  time  as  end  of  lines, i.e., if
             EOPAGE(F)=TRUE, then EOLN(F)=TRUE.  To insure that this  is

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 90


             always  the  case,  PAGE(F)  always  performs  an  implicit
             WRITELN(F) if an explicit WRITELN(F)  has  not  immediately
             preceded it.  EOF, however, becomes TRUE when an attempt to
             GET the first character of a line after the  last  line  of
             the file is made; i.e., at the end of the last line EOLN is
             TRUE, then, after the next  GET,  EOLN  is  FALSE  and  EOF
             becomes  TRUE.  The  following program fragment copies file
             INPUT to OUTPUT and demonstrates the use of the  basic  i/o
             functions.


                 RESET(INPUT);    (*RESET performs an implicit GET*)
                 REWRITE(OUTPUT);
                 WHILE NOT EOF DO BEGIN
                      WHILE NOT EOLN DO BEGIN
                           OUTPUT^:=INPUT^;
                           PUT;   (*OUTPUT is assumed file variable*)
                           GET    (*INPUT is assumed file variable*)
                      END;
                      WRITELN;    (*INPUT^=' ' at this point*)
                      IF EOPAGE THEN PAGE;
                      GET         (*first character of next line*)
                 END;
                 CLOSE            (*all files*)

             WRITELN  on  output  devices  such  as line printers or the
             terminal causes a carriage return and advances to the  next
             physical  line.  PAGE  similarly advances to the top of the
             next physical page, although its effect on  an  interactive
             terminal   is  implementation  dependent,  and  it  may  be
             ignored.  EOPAGE may never  become  TRUE  on  the  terminal
             (TTY) depending on the implementation.  EOF may become TRUE
             on the terminal, if the implementation provides a means  of
             reading  an end of file from the terminal, but it is not an
             error to continue to read from it.  Thus, it  is  advisable
             to   ignore   EOF  from  the  terminal  to  insure  program
             portability.  On all other files, an attempt to read  after
             EOF becomes TRUE is an error.




             14.3.2.1 Character Set and the ASCII Option                      Character Set and the ASCII Option


             Any of an implementation-dependent set of characters may be
             used to terminate an input line.  Normally, the terminating
             character  is not passed to the program, the file buffer is
             set to  blank,  and  EOLN  becomes  TRUE.  Also,  as  noted
             previously,   nonprinting  characters  are  ignored,  i.e.,
             skipped on input.  Finally, horizontal tabs are  translated

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 91


             into blanks according to an implementation-dependent set of
             tab stops.

             If  the  ASCII  option  is  specified  in  RESET  or  OPEN,
             characters terminating a line are placed in the file buffer
             (with EOLN still TRUE), and nonprinting characters are  not
             skipped.  Horizontal  tabs,  if passed directly to programs
             by the operating system, are placed in the file buffer, and
             not  translated  into  blanks.  As  the  handling  of  such
             special characters varies from system to  system,  programs
             invoking   the  ASCII  option  are  likely  to  be  machine
             dependent.  Constants of  type  CHAR  can  be  defined  for
             special characters via the CHR predefined function, e.g.,

                 CONST tab = chr(#O11)




             14.3.2.2 Carriage Control, CONTROL Option                      Carriage Control, CONTROL Option


             PAGE  and  WRITELN  provide  a  certain  amount of carriage
             control  on  output  devices.  Additional  control  may  be
             exercised  on those devices permitting it by specifying the
             CONTROL option in a REWRITE statement.  If  this  is  done,
             WRITELN  terminates  lines but does not affect the position
             of the  carriage.  The  initial  character  of  all  output
             lines, i.e., the first character written to the file or the
             first character after a WRITELN, determines the positioning
             of the carriage, as follows:

             ' ' :  advance to beginning of next line (single space)
             '0' : advance to beginning of line after next (doublespace)
             '1' : advance to beginning of next page (top of form)
             '+' : return carriage but do not advance (overprint)
             any other :advance to beginning of next line (singlespace)

             The  initial  character  is printed unless it is in the set
             [' ', '0', '1',  '+'].  As  noted  before,  the  effect  of
             WRITELN  is  merely  to  terminate  lines under the CONTROL
             option.  PAGE is equivalent to a WRITELN followed by a  PUT
             of  '1',  and  thus  should  generally not be used with the
             CONTROL option,  since  the  character  output  immediately
             after  a  PAGE will not be interpreted as carriage control,
             and will be printed.

             The character devices for which the CONTROL option  may  be
             specified are implementation dependent, as is the effect of
             reading a file written with the CONTROL option.  It is thus
             advisable  to specify the CONTROL option only when directly

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 92


             writing to an output device or when writing to a file which
             will  be  copied  to  such a device later.  The recommended
             interpretation on reading a file written with  the  CONTROL
             option is as follows:

             ' ' :  equivalent to terminating previous line with WRITELN
             '0' :  previous line terminated with WRITELN; WRITELN
             '1' :  previous line terminated with PAGE
             '+' :  ignored, although some character may be passed if
                    ASCII in effect

             To facilitate tabular input and output, a standard function
             CURSOR  is  defined.   CURSOR(file-variable)   returns   an
             integer-compatible   result   indicating   the   number  of
             characters which have been read  from  or  written  to  the
             current  line.  Thus,  immediately after a WRITELN or PAGE,
             CURSOR returns zero.  After the first character  is  output
             (with PUT), CURSOR returns 1, after the second, 2, etc.  On
             input, CURSOR returns the number of characters from a  line
             which  have preceded the character currently in the buffer.
             Thus, when the first character after the  end  of  line  is
             input  (with  GET), CURSOR returns 0, and when EOLN is TRUE
             on an input file, CURSOR returns the number  of  characters
             previously read from the line, i.e., the length of the line
             not counting the end-of-line character.

             Note that special characters read (if ASCII is  in  effect)
             or  written  are counted as single characters by CURSOR, no
             matter how they are echoed or printed.  CURSOR is simply  a
             character  count,  and does not always reflect the physical
             position of the carriage on i/o devices.


             14.3.3 Character Input and Output Conversions                    Character Input and Output Conversions

             A constant or variable of certain types may be converted to
             a  sequence  of  characters forming an external (printable)
             representation of its value.  Conversely, the  value  of  a
             variable  of  certain  types  may  be  set  by converting a
             sequence of characters forming an  external  representation
             of  a  constant  of  the  same  or compatible type.  In the
             former case, the sequence  of  characters  may  be  written
             directly  to  a  character  file  or  may  be  placed  in a
             string-compatible  variable.  In  the  latter   case,   the
             sequence  may be read from a character file or taken from a
             string-compatible   expression.   These   conversions   are
             specified   by  standard  routines  whose  names  are  also
             reserved words, as follows:




             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 93


             WRITE and WRITELN  convert value(s) and output to character
                                file
             READ and READLN    input from character file and convert
                                value(s)
             PUTSTRING          convert value(s) into string-compatible
                                variable
             GETSTRING          convert value(s) from string-compatible
                                expression

             PUTSTRING and GETSTRING perform  conversions  to  and  from
             string-compatible   items,   instead  of  output  or  input
             streams.  A  WRITELN  is  the  same  as  a  WRITE  with  an
             identical parameter list, except that WRITELN writes a line
             mark after all conversions  have  been  made  and  written.
             Similarly,  READLN  is  the same as READ, except that after
             all conversions  have  been  made,  the  remainder  of  the
             current  input  line  (if  any) is discarded, and the first
             character of the next line is input into the  file  buffer.
             The syntax of a call to these routines is as follows:

                 i/o-conversion ::= input-conversion | output-conversion

                 input-conversion ::= {READ | READLN}
                    [ '(' [ input-list | file-reference
                       [ ',' input-list ] ] ')' ]

                 output-conversion ::= {WRITE | WRITELN}
                    [ '(' [ output-list | file-reference
                       [',' output-list ] ] ')' ]

                 string-conversion ::= putstring | getstring

                 putstring ::= PUTSTRING
                     '(' string-variable-reference ',' output-list ')'

                 getstring ::= GETSTRING
                     '(' string-expression ',' input-list ')'

                 output-list ::= output-item [',' output-item] ...

                 output-item ::= expression [output-format]

                 input-list ::= input-item [','input-item] ...

                 input-item ::= variable-reference [input-format]


             Calls  to these routines look much like calls to any other,
             except  that  formatting  directives  may  be  appended  to
             parameters  in the list.  For this reason, the names of the
             routines are reserved.  Explicit formatting is discussed in

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 94


             Section 14.3.4.  The first parameter of the i/o routines is
             the file on which i/o is to be performed, while  the  first
             parameter  of  the string-conversion routines is the string
             being operated upon.  If the file variable  is  omitted  in
             the   i/o   routines,  INPUT  or  OUTPUT  is  assumed.  The
             remaining parameters (i/o items) of  all  routines  specify
             either  variables  into  which  converted  values are to be
             stored (READ, READLN, GETSTRING) or expressions  which  are
             to  be converted (WRITE, WRITELN, PUTSTRING).  Zero or more
             i/o items may be specified to WRITELN and READLN while  one
             or  more  must  be  specified  to  READ,  WRITE, and string
             conversions.

             The i/o conversion routines use the basic routines GET  and
             PUT  to  perform  i/o.  The first character examined on any
             input conversion is the one currently in the  file  buffer,
             e.g.,   for   INPUT,  the  current  value  of  INPUT^.  The
             character in the buffer after an input  conversion  is  the
             one  which  terminated  the converted sequence, and will be
             the first character examined by  the  next  conversion,  if
             there  is  no  intervening  GET.  On  an output conversion,
             characters are stored in the  buffer  and  PUT  one-by-one.
             Thus,   the   character  in  the  buffer  after  an  output
             conversion will be the final  character  in  the  converted
             sequence.  Also,

                 READ(F,V1,...,Vn)

             and

                 WRITE(F,V1,...Vn)

             are equivalent to

                 READ (F,V1); ...  ;READ(F,Vn)

             and

                 WRITE(F,V1); ...  ;WRITE(F,Vn)

             respectively.  Thus,  it  is  sufficient  to  describe  the
             conversions  performed  on  individual  items   to   define
             completely the operation of the conversion routines.

             In  GETSTRING,  characters  are  taken in sequence from the
             string until values have been read for all  items,  or  the
             end  of  the  string  is  reached.  In the latter case, the
             value(s) of item(s) not processed are  unchanged,  and  the
             routine returns.  In READ (and READLN), characters are read
             from the file until all items are  processed,  crossing  as
             many line and page boundaries as necessary.  It is an error

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 95


             if the end of file is encountered  before  all  items  have
             been  processed.  The difference between READ and READLN is
             that  in  READLN,  after  all  items  are  processed,   the
             following operation is effectively performed:


                 WHILE NOT EOLN(F) DO GET(F);
                 GET(F)

             In  PUTSTRING, items are processed until the maximum length
             of the string is reached or all items have been  processed.
             In the latter case, if the string is varying, its length is
             set  to  the  total  number  of  characters  generated   in
             processing  the  items, while if it is fixed, its remaining
             characters are blanked.  This treatment is consistent  with
             string  assignment  in Pascal.  In PUTSTRING, either all of
             the characters generated by an individual  item  conversion
             are  stored  in  the  string,  or  none are.  In WRITE (and
             WRITELN) all items are always processed.




             14.3.3.1 Default Input Conversions                      Default Input Conversions


             The manner in which variables or expressions in  items  are
             converted   is  determined  by  their  types.  The  default
             conversions, applied in READ, READLN, and GETSTRING,  i.e.,
             those  applied  when  no  formatting  is  specified, are as
             follows:

             Character-compatible variables,  i.e.,  variables  of  type
             CHAR  and  subranges  thereof,  cause the next character in
             sequence to be  stored  in  the  variable.  Thus,  READ  or
             READLN  of a character-compatible variable V from text file
             F is defined as:

                 V:=F^;GET(F)

             Note that a character will be transferred from  the  buffer
             to  the  variable  even  when EOLN=TRUE.  String-compatible
             variables cause characters to be taken  in  sequence  until
             either the maximum length of the variable or the end of the
             current input  line  (READ,  READLN)  or  the  end  of  the
             argument  string  (GETSTRING) is reached.  This sequence of
             characters, of length less than or  equal  to  the  maximum
             length  of  the variable, is then assigned to the variable.
             Thus, if the variable  is  a  varying  string,  its  length
             becomes  the  length  of  the  input  sequence  and, if the
             variable is a fixed string, the  sequence  is  padded  with

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 96


             blanks  before  assignment  if  its length is less than the
             length of the variable.  Note that the  character  returned
             at  the  end  of  the  line  is  not  stored  in the string
             variable, and that reading a string when EOLN=TRUE  returns
             a null string.

             An integer constant conforming to the syntactical rules for
             such constants may be converted into an  integer-compatible
             or  real-compatible variable, and a valid real constant may
             be converted into a  real-compatible  variable.  In  either
             case, blanks are first skipped, crossing line boundaries if
             necessary, until a nonblank character  is  encountered.  If
             the  characters  which  follow  do  not  constitute a valid
             numeric constant, the corresponding variable is set to zero
             and   the   conversion  terminates  on  the  first  invalid
             character encountered.  An error  also  occurs  unless  the
             first  nonblank  character  is  a  comma, in which case the
             corresponding variable is set to zero, and  the  conversion
             terminates  without error.  A valid numeric constant may be
             terminated by any character.  The character terminating the
             conversion  will  be  the  first  one  examined by the next
             conversion, unless it is a comma.  To facilitate separation
             of numeric values with commas, when a numeric conversion is
             terminated by a comma, the character  after  the  comma  is
             read  into  the file buffer; i.e., the comma is not treated
             like other terminating characters and is considered  to  be
             part of the constant instead.  Thus,

                 READ (F,A,B,C)

             where  A, B, and C are all real-compatible variables may be
             satisfied by the input line

                 -4,,2.36

             which sets A=-4.0, B=0.0,  and  C=2.36.  F^=','  after  the
             conversion  of A (the second comma).  The second conversion
             sets B to 0.00 and F^='2' (the character after the  comma).
             Finally,  C is set to 2.36 and the conversion is terminated
             by the end of a line.  Normally, F^  would  now  contain  a
             blank,  unless the ASCII option had been specified.  In any
             case, the character in the file buffer  when  EOLN=TRUE  is
             never  examined  by  a  numeric conversion, since an end of
             line either  terminates  a  conversion  in  process  or  is
             skipped  before  conversion begins.  In fact, the character
             in the file buffer when EOLN=TRUE will only be  transferred
             by a READ or READLN into a character variable.





             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 97


             14.3.3.2 Default Output Conversions                      Default Output Conversions


             When  WRITE,  WRITELN,  or  PUTSTRING  are  called  with  a
             variable or expression without formatting,  the  characters
             written  or stored in the target string by PUTSTRING depend
             on the type of value.  The contents of character-compatible
             and    string-compatible   values   are   written   without
             modification,  while  numeric  values  are   converted   as
             follows:

             An  integer-compatible  value  is  converted to a string of
             decimal digits, preceded by a minus sign if  the  value  is
             negative  and  a  space otherwise.  Only significant digits
             are printed; i.e., no leading zeroes are printed except for
             zero itself which is written as '0'.  Thus, for an integral
             value e, the number of  characters  printed  is  p+1  where
             10**(p-1) <= abs(e) < 10**p.

             A   real-compatible   value   is   converted  either  to  a
             fixed-point  representation,  e.g.,   '237.8'   or   to   a
             floating-point representation, e.g., '2.378E+02', depending
             on the magnitude and precision of the value.  The  fraction
             of  floating-point  representations  is  between  1 and 10,
             excluding 10, while  fixed-point  representations  have  at
             least  one digit before the decimal point.  In either case,
             the minimum number  of  digits  printed  is  equal  to  the
             precision  of the value, which is either the specified (via
             PREC)  or  default  (precision  of  standard   type   real)
             precision  if  the  value  is a variable, or is the maximum
             precision of any  of  the  operands  if  the  value  is  an
             expression.  A  fixed-point representation is printed if it
             requires   fewer    characters    than    the    equivalent
             floating-point  representation.  Otherwise,  floating point
             is used.  Whether fixed or floating point  is  chosen,  the
             representation  is preceded by a minus sign if the value is
             negative and a space otherwise.  Thus, if  NEXP  characters
             are  required  to print an exponent and PR is the precision
             of a value E, a fixed representation is used  if  10**-NEXP
             <= E < 10**(PR+NEXP) and floating point otherwise.












             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 98


             14.3.4 Formatted Input/Output                    Formatted Input/Output


             Input  and  output  conversions  may  be  controlled by the
             program through formats.  Formats  specify  the  number  of
             characters  to  be read or written (the field width) in all
             cases, and for numeric values,  the  representation  to  be
             read or written.


             14.3.4.1 Formatted Input                      Formatted Input

             An input format consists of an integer expression, referred
             to as the "field  width",  appended  to  the  variable  and
             separated  from  it  by  a  colon.  Formats  appended to an
             integer-compatible variable may also include a ':O' (either
             uppercase  or  lowercase) after the field width, specifying
             that input constant is to be interpreted as an octal rather
             than  decimal  value.  Similarly, ':H' (either case) may be
             appended to specify hexadecimal input interpretation.

                  input-format ::=
                     ':' expression [ ':O' | ':o' | ':H' | ':h' ]

             The field width specifies the number of  characters  to  be
             taken  from  the  argument string in GETSTRING or read from
             the file in READ and READLN.  Characters  are  taken  until
             the  field  width is exhausted, the end of the input string
             is reached (GETSTRING), or an end  of  line  (or  page)  is
             encountered  (READ,  READLN).  These  characters  are  then
             processed according to the type of the item.

             Formats  may  not   be   used   with   character-compatible
             variables.  The  sequence  of characters is merely assigned
             to  string-compatible  variables.   The   only   difference
             between  a formatted and unformatted string input operation
             is the additional limit on characters taken from the  input
             source   imposed  by  the  field  width.  That  is,  enough
             characters are taken, if available, to  satisfy  the  field
             width;   these   characters   are   then  assigned  to  the
             string-compatible variable.

             A formatted numeric input  operation  is  identical  to  an
             unformatted   operation   with   the   exception  that  the
             conversion  terminates  at  the  end  of  the  sequence  of
             characters  defined  above.  If no nonblank character or an
             invalid numeric constant is encountered,  the  variable  is
             set to zero.  In the latter instance, an error also occurs.

             ':O'  or ':o' may be appended to a field width following an
             integer-compatible variable if an octal input conversion is

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 99


             desired.  Similarly,  ':H'  or  ':h'  may  be appended to a
             field width if a hexadecimal input conversion  is  desired.
             Only characters from the set ['0'..'7'] optionally preceded
             by a minus sign are allowed in the input constant for octal
             conversion, while hexadecimal conversion allows any decimal
             digit, plus the characters ['A'..'F'], in either  uppercase
             or  lowercase,  optionally  preceded by a minus sign.  Note
             that an explicit radix character  ('B'  or  'b'  signifying
             octal, for example) following the constant is not required;
             if it is not valid for the type of input, it will  in  fact
             be  treated  as  a  nonnumeric  character  terminating  the
             conversion.


             14.3.4.2 Formatted Output                      Formatted Output

             Output formats control conversion  of  internal  values  to
             text.

                 output-format ::= string-format | integer-format 
                                   | real-format | boolean-format

                 string-format ::= ':' expression [ ':L' | ':l' ]

                 integer-format ::=
                    ':' expression [ ':O' | ':o' | ':H' | ':h' ]

                 real-format ::=
                    ':' expression [ ':' expression [ ':E' | ':e' ] ]

                 boolean-format ::= ':' expression


             The  initial  expression in an output format, which must be
             integer, is referred  to  as  the  field  width.  For  real
             formats, the initial expression is sometimes referred to as
             the "total field width", to distinguish it from the  second
             integer  expression  which  may  appear, referred to as the
             "fractional field width" or the "precision factor".

             In general, the total field  width  specifies  the  minimum
             number of characters which will result from the conversion.
             Numeric conversion overflow may cause this field  width  to
             be  exceeded  (see  the  discussion  of  the  conversion of
             integer   expressions   later).   Also,    all    PUTSTRING
             conversions  are  checked  against  the number of available
             character positions available in the target  string  before
             any  characters  are  stored.  Regardless  of  any explicit
             output formats, no characters will be stored in the  target
             string  if  the  PUTSTRING  would  overflow  the  remaining
             character positions.

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 100


             A string or character expression with a format  is  written
             with  leading spaces if the length of the string expression
             is less than or equal to the specified  field  width,  such
             that  the  total  number  of  characters written equals the
             specified field width.  Character expressions  are  treated
             as  strings  of  length  one.  If  the length of the string
             expression is greater than the field width, the  string  is
             truncated  on  the right such that the number of characters
             written  equals  the  field  width.  If  ':L'  or  ':l'  is
             specified,  string expressions will be output with trailing
             spaces, instead of leading spaces, to  fill  the  specified
             field  width.  The  effect  is  to  left-justify the string
             within the field.

             An integer expression is converted to a string  of  decimal
             digits  in  the same manner as in the unformatted case, but
             the string is then written with sufficient  leading  spaces
             (right-justified)  to  fill  the specified field width.  If
             the length of  the  converted  integer  exceeds  the  field
             width,  the  conversion overflows, and the converted string
             is simply written, producing more characters than specified
             by  the  field  width.  When  writing  a nonnegative number
             which overflows  the  field  width,  no  leading  space  is
             printed.  Thus,  by  specifying  a  field  width which will
             always overflow (zero,  for  example),  the  leading  blank
             which precedes nonnegative integers with default formatting
             may be suppressed.

             If ':O' or ':o' is appended to the field width, the integer
             is  converted  to  a  string of octal, rather than decimal,
             digits.  Similarly, ':H' or ':h' will convert  the  integer
             to  a  hexadecimal representation.  The lowest-order digits
             in the hexadecimal or  octal  representation  are  written,
             completely  filling  the  specified field width.  A loss of
             significance can occur, since the field width for octal  or
             hexadecimal  integer  output  is  never  exceeded; only the
             lowest-order digits  are  written.  When  the  field  width
             provides  more  room  than  required for full significance,
             leading  zeroes  are  supplied  for   nonnegative   integer
             expressions,  while  negative expressions are padded on the
             left with either the character '7' (for octal) or 'F'  (for
             hexadecimal).

             There are three methods of specifying format parameters for
             real expressions to be written.  The first is to specify an
             explicit  total field width, such as 'X:12'.  This produces
             a floating-point representation in which the real number is
             represented  as  the  product of a fraction between 1.0 and
             10.0 and an integral power of 10 exponent.  The  number  of
             characters  necessary  to  represent  any  possible  signed
             exponent value is implementation dependent (for example,  a

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 101


             range   of  exponent  values  of  -38..+38  requires  three
             characters).  This number (called NEXP) is subtracted  from
             the  specified  total  field width along with a space for a
             sign character and a space for the  character  'E'  or  'e'
             (implementation  dependent)  preceding  the  exponent; i.e.
             NEXP+1 is subtracted from the specified total field  width.
             The  resultant  field  width  is  filled with the character
             representation  of  the  fraction  between  1.0  and  10.0,
             including  a  decimal  point.  Thus,  the  output  field is
             filled completely.  The specified total field width must be
             at  least  NEXP+5,  allowing two digits of precision in the
             fraction (for example, '-2.3E-10').  If a field width  less
             than NEXP+5 is specified, a field width of NEXP+5 is used.

             Specification  of  an  explicit  total  field  width and an
             explicit fractional field width, such as 'X:12:3', produces
             a  fixed-point  representation.  The fractional field width
             specifies the number of digits which  will  appear  to  the
             right  of  the  decimal  point,  and  the total field width
             specifies the total number of  characters  to  be  written.
             The total field width must be at least two greater than the
             fractional field width in order to allow  for  the  decimal
             point  and  at  least  one digit to the left of the decimal
             point.  If the total field width is smaller than this, then
             the  field width will be exceeded.  If the magnitude of the
             real  expression  is  too  large  to  be   represented   in
             fixed-point format without overflowing the field width, the
             field    width    will    be    exceeded    up    to     an
             implementation-defined   number   of  characters  (possibly
             zero).   Beyond    this,    an    implementation-dependent,
             floating-point  representation  with  the  specified  total
             field   width   will   be   used.    This    floating-point
             representation  will  be  right  justified within the field
             width.  Note  that  a   leading   blank   for   nonnegative
             expressions  is not required as it is in the floating-point
             format.

             The character pair  ':E'  or  ':e'  after  two  field-width
             expressions,   such   as   'X:12:3:E',   specifies  that  a
             floating-point representation is  to  be  used.  The  first
             integer  expression  specifies the total field width, while
             the second expression specifies the precision  factor.  The
             value of the precision factor gives the number of digits to
             be represented in  the  fraction.  Thus,  the  total  field
             width must allow enough room for this precision factor, the
             exponent (NEXP),  a  decimal  point,  and  an  'E'  or  'e'
             (implementation  dependent)  preceding  the exponent, i.e.,
             the total field width >= precision factor + NEXP  +  2.  In
             addition,  if the real expression is negative, then another
             space must be allotted for the sign.  If  the  total  field
             width   is   smaller   than  this,  it  will  be  exceeded.

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 102


             Otherwise, the expression will appear  right  justified  in
             the  field.  As  with integers, the specification 'X:0:5:E'
             will produce output of the form 'n.nnnnE+nn', with the zero
             value  for the total field width removing the leading space
             for positive expressions.

             Boolean output formatting  follows  the  rules  for  string
             output  formatting, with the fixed-length strings 'TRUE' or
             'FALSE' used as appropriate.  The field width will never be
             exceeded.  Note that ':L' or ':l' for left justification of
             strings cannot be specified for boolean output items.


             14.3.5 Interactive Text File Input and Output                    Interactive Text File Input and Output

             Devices such as an interactive  terminal  communicate  data
             through  text  file  input/output.  Special  considerations
             must be made to  avoid  problems  with  synchronization  of
             input/output operations and machine-dependent programs.


             14.3.5.1 Interactive Device Association                      Interactive Device Association

             Although  interactive  input/output is normally done with a
             single physical device, separate file variables  for  input
             and  output  must  be  associated with it.  For interactive
             terminal  sessions,  the  predefined  variables   TTY   and
             TTYOUTPUT are furnished for input and output, respectively.
             For output association, the standard procedure  REWRITE  is
             used.  For  input  there are two standard procedures, RESET
             and OPEN.  RESET does an  implicit  GET  immediately  after
             association.  GET  associates  a  variable with the device.
             The result of the implicit GET in the RESET call is that  a
             line  of  textual input from the device being associated is
             expected at the time of the procedure call.  In  the  usual
             case  that  this  is  not  desirable, the OPEN procedure is
             used.

             As mentioned in Section 14.1, file variables are  analogous
             to   pointer   variables.  Thus,  each  file  variable  has
             associated with it an implementation-dependent value  which
             can  be  used  in  logical comparisons and assignments.  In
             other words, it is possible to determine whether  one  file
             variable has been previously assigned the value of another.
             Note that an assignment of file variables is the  only  way
             to  cause  two  file  variables  to  have  the  same value.
             Association of separate file variables to the same file  or
             device  will not guarantee the equality of those variables.
             The following program fragment demonstrates the  use  of  a
             file  variable's  "value"  to  produce  machine-independent
             code:

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 103



             OPEN(TTY); REWRITE(TTY);     (*associate the terminal*)
             LOOP
               WRITE(TTY, 'Enter the data file name: '); (*prompt user*)
               BREAK(TTY);                (*BREAK is discussed in 
                                          Section 14.3.4.2*)

               READLN(TTY, F_NAME);
               OPEN(F, F_NAME);           (*OPEN the specified file*)

               PROCESS_DATA(F);           (*call user procedure*)

               CLOSE(F)
             END;

             This program is deficient in two respects:  (1) it  is  not
             possible   for  the  user  to  specify  a  file  name  that
             represents input from the interactive terminal, and (2)  if
             (1)  were  not  the  case,  then  the  call  to CLOSE could
             potentially dissociate TTY, causing an error to  occur.  To
             avoid  these difficulties, the program should define a name
             for the interactive terminal (for example, "TERMINAL"), and
             whenever  this string is seen in a file-name specification,
             the file should be associated through  an  assignment.  The
             following program fragment incorporates these changes:

             OPEN(TTY); REWRITE(TTY);
             LOOP
               WRITE(TTY, 'Enter the data file name: '); (*prompt*)
               BREAK(TTY);

               READLN(TTY, F_NAME);
               IF UPPERCASE(F_NAME) = 'TERMINAL' THEN F := TTY
               ELSE OPEN(F, F_NAME);

               PROCESS_DATA(F);

               IF F <> TTY THEN CLOSE(F)  (*don't close TTY!*)
             END;



             14.3.5.2 Buffered I/O with a Terminal                      Buffered I/O with a Terminal

             Interactive  devices  such  as  a terminal typically handle
             input and output in a line-oriented  manner.  However,  the
             buffer variable of a text file variable represents a single
             character.  Thus, there is usually an internal  buffer  for
             an   interactive   device  which  contains  a  sequence  of
             characters comprising a  line.  The  GET,  PUT,  READ,  and
             WRITE  procedures simply move characters between the buffer

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 104


             variable and the internal buffer; i.e., actual  input  from
             or  output to the terminal may not always occur on a GET or
             a PUT.  The buffer variable of a text file can  be  thought
             of  as  a  "window"  into  the  internal  buffer.  The  GET
             procedure moves the window over the next character  in  the
             buffer,  reading  a  new line into the internal buffer only
             when all characters have been exhausted.  The PUT procedure
             advances  the  window  by  one  character position and then
             deposits a character in  the  new  position,  flushing  the
             internal  buffer  to  the terminal when the buffer is full.
             The  READLN  and  WRITELN  procedures  actually  cause  the
             movement  of  data  between  the  internal  buffer  and the
             terminal.  The READLN procedure behaves like READ, but then
             discards  the  rest  of the internal buffer and reads a new
             line from the terminal.  WRITELN behaves much  like  WRITE,
             but  then  writes  the  internal  buffer  to  the terminal,
             appending an end-of-line mark.

             The following program fragment illustrates the use  of  the
             buffer variable to read lines of text.

                 VAR LINE : STRING [80];
                 BEGIN
                     LINE := '';
                     WHILE NOT EOF(F) DO BEGIN
                         READLN(F);   (*read a line into the buffer*)
                         WHILE NOT EOLN(F) DO BEGIN
                             LINE := LINE || F^;
                             GET(F)
                         END;
                         PROCESS_LINE(LINE)
                     END
                 END;

             The  set  of  characters which cause EOLN to have the value
             TRUE are implementation dependent.  On end of line, a  file
             variable's buffer variable will contain a space rather than
             an  end-of-line  character  unless  the  ASCII  option   is
             specified  at  file  association.  If  the  ASCII option is
             specified, then the character marking the end of line  will
             be in the buffer variable.

             In  many  interactive  terminal  applications, the user may
             desire to "converse" with the  program,  i.e.,  synchronize
             the writing of prompts and queries with the reading of user
             responses.  The following example illustrates a solution to
             the  problems  which  may  arise  from  internally buffered
             interactive text file i/o:

             BEGIN
                 WRITE(TTYOUTPUT, 'ENTER YOUR NAME: ');

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 105


                 BREAK(TTY);         (*flush the TTYOUTPUT internal 
                                       buffer*)
                 READLN(TTY);        (*discard the current contents of 
                                       the TTY internal buffer and
                                       read a new one*)
                 READ(TTY, NAME)     (*read the name*)
             END;

             The string, 'ENTER YOUR NAME:  ', is placed at the  end  of
             the  TTYOUTPUT  buffer  (but not necessarily printed on the
             terminal), and then the string NAME is read  from  the  TTY
             buffer.  If  the  TTY  buffer  is empty, then a new line is
             read from the terminal to  the  TTY  buffer  prior  to  the
             assignment of a string value to NAME.

             The   standard   procedure  BREAK,  valid  only  for  files
             associated for output,  is  used  to  force  the  immediate
             writing  of  the TTYOUTPUT buffer to the terminal.  The use
             of READLN without a variable list  assures  that  the  NAME
             variable  is  read  from  a new terminal input line.  In an
             implementation that communicates with  the  terminal  on  a
             character-by-character  basis (as opposed to line-by-line),
             the BREAK procedure has no effect.  Thus,  programs  should
             be  written with the assumption that line-by-line input and
             output are done.  Note that a program  which  assumes  that
             input is done character-by-character is not portable.

             The  standard  procedure  CLEAR  is  used to reset a file's
             internal buffer without causing  any  input  or  output  to
             occur.  In  the case of a file variable associated with the
             terminal, CLEAR may also discard any input or output  which
             has  not  yet  reached  the  terminal  or  the program, for
             example, any characters which have  been  "typed-ahead"  on
             input.  This action is dependent on the capabilities of the
             particular operating system being used.  The usual  use  of
             this  procedure is to clear out any typed-ahead input (with
             CLEAR(TTY)) or unfinished  output  (with  CLEAR(TTYOUTPUT))
             after  an  error  has  occurred  and  before  an  error  or
             interrupt handler prints a message.


             14.3.5.3 More Interactive I/O Considerations                      More Interactive I/O Considerations

             If the implementation provides a means of inputting an  end
             of  file  from  the  terminal,  then  the EOF function will
             become TRUE on input of such a  character.  However,  since
             not  all  implementations provide a way of signaling end of
             file from the terminal, portable programs  should  not  use
             the  EOF function with the terminal.  Similarly, the EOPAGE
             function  should  not  be  used  for  interactive  terminal
             applications.

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 106


             The  PAGE procedure has the effect of writing a skip to top
             of page to the  terminal,  which  causes  the  terminal  to
             behave  in a manner dependent on the characteristics of the
             particular terminal.  In  general,  the  use  of  the  PAGE
             procedure  as a formatting aid for output to an interactive
             device is not  recommended.  Instead,  line  counts,  etc.,
             should be used.

             The  CURSOR  function  with a file variable associated with
             the terminal does not count multiple characters  which  may
             be  echoed  for certain characters.  For example, if TTY is
             associated with the ASCII option, and a  tab  character  is
             read through this file variable, CURSOR(TTY) will increment
             by one, although the character may echo as several blanks.


             14.3.6 IMAGE Input and Output                    IMAGE Input and Output

             Text files associated with the IMAGE  option  suppress  the
             conversion  of  characters  on  input  or  output.  This is
             useful in applications involving communication with devices
             that  may  require data to be in an eight-bit rather than a
             seven-bit (ASCII) format.

             The RESET and  REWRITE  standard  procedures  are  used  to
             associate  a  text  file in IMAGE mode.  The OPEN procedure
             may not be used with this option.  If both  the  IMAGE  and
             ASCII  options  are  specified, the ASCII option is ignored
             and the text file is associated in IMAGE mode.

             There are two standard procedures for  IMAGE  input/output,
             READ8 and WRITE8.  The format of a call to these procedures
             is:

                 operation'('[file-variable','] variable-reference')'

             where     variable-reference     must     reference      an
             integer-compatible  variable  and  file-variable  must be a
             text  file.  If  this  is  omitted,  TTY  or  TTYOUTPUT  is
             assumed.  The  buffer  variable  of  a file opened in IMAGE
             mode is undefined--the file may only  be  read  or  written
             with the READ8 or WRITE8 procedures.  It is an error to use
             any standard procedure other than READ8 or WRITE8  to  read
             or  write  an  IMAGE  mode  file.  The EOF function has its
             usual definition, but the EOLN and  EOPAGE  functions  will
             always return FALSE.






             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 107


             14.4 Typed Input and Output                  Typed Input and Output


             While  it  is  possible to read and write character strings
             representing integers, reals, and more  complex  structures
             such  as  sets, records, and arrays, it is simpler and more
             efficient to read and write the actual bit patterns to  and
             from memory.  Typed files provide a facility for such input
             and output.

             All file types are bound to a  component  type.  This  type
             effectively   defines   the   template   for   interpreting
             fixed-length bit patterns in physical files as Pascal  data
             entities.   As   with  text  files,  typed  files  have  an
             associated buffer component, f^, which contains the current
             file  element.  For  typed  files,  f^  is  of  the  file's
             component type.




             14.4.1 The Pascal Typed-File Model                    The Pascal Typed-File Model

             A file composed of fixed-length elements may be thought  of
             as   an   array   with  an  unspecified  upper  bound.  The
             operations on typed files transfer individual  elements  of
             the array to and from the buffer.  They also affect certain
             attributes and state information associated with  the  file
             variable.  A procedural definition of typed-file operations
             is presented below.


             A typed file, defined by:

                  VAR f: FILE OF type

             has the following hidden entities associated with it:

                  f.mode: ( readonly, writeonly, readwrite );
                  f.extent: 0 .. *;
                  f.cursor: 1 .. *;
                  f.data: ARRAY [1 .. f.extent] OF type
                  f.buffer: type

             "Mode" is a "state variable" which retains the  permissible
             operations  on  the  file  variable  from association time.
             "Extent" is the number  of  elements  in  the  file,  while
             "cursor"  selects one element as the current one.  The data
             array contains the  components  of  the  file,  indexed  by
             cursor,  and  representing  the  physical  file itself, and
             "buffer" is the buffer component described above.  The user

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 108


             accesses these data as follows:

                  EXTENT(f)         returns f.extent
                  CURSOR(f)         returns f.cursor
                  EOF(f)            returns (f.cursor > f.extent)
                  f^                references f.buffer


             Note  that  CURSOR for a text file is different from CURSOR
             for a typed  file.  Here,  CURSOR  represents  the  current
             index  in  the  virtual  array, f.data.  Note also that EOF
             only reflects the position of the cursor  relative  to  the
             end of the file.


             14.4.2 Association of Typed Files                    Association of Typed Files

             The  association  operations  for  typed-file variables are
             defined as follows:


             RESET (f)    (* initialize for input only *)

                  f.mode := readonly;
                  f.extent := "the number of elements in the file";
                  f.cursor := 1;
                  IF f.cursor <= f.extent THEN
                    f.buffer := f.data [f.cursor]


             REWRITE (f)  (* initialize for output only *)

                  f.mode := writeonly;
                  IF "preserve in open options" 
                    THEN f.extent :="the number of elements in the file"
                    ELSE f.extent := 0;
                  f.cursor := f.extent + 1;
                  f.buffer := "undefined"


             UPDATE (f)   (* initialize for input/output *)

                  f.mode := readwrite;
                  f.extent := "the number of elements in the file";
                  f.cursor := 1;
                  IF f.cursor <= f.extent THEN
                    f.buffer := f.data [f.cursor]


             The OPEN operation is not provided  for  typed  files.  The
             quoted  strings shown above represent operations whose form

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 109


             is dependent  on  the  implementation  but  whose  meanings
             should  be  clear;  for example, "the number of elements in
             the file" is the file size if the file is  not  empty,  and
             zero  if  the  file  is either empty or does not exist.  If
             f.extent is zero, the error code returned upon  association
             will distinguish the latter two cases (see Section 14.6).


             14.4.3 Data-Transfer Operations                    Data-Transfer Operations

             The data-transfer operations for typed files are defined as
             follows:


             GET (f)      (* input *)

             IF f.mode = writeonly THEN error;
             IF f.cursor > f.extent THEN error;
             f.cursor := f.cursor + 1;
             IF f.cursor <= f.extent THEN
               f.buffer := f.data [f.cursor]


             PUT (f)      (* output *)

             IF f.mode = readonly THEN error;
             IF f.cursor > f.extent THEN f.extent := f.cursor;
             f.data [f.cursor] := f.buffer;
             f.cursor := f.cursor + 1


             The word "error" above, insures that if  the  statement  is
             TRUE,  the  operation  will  terminate  immediately, and an
             error code will be set (see Section 14.6).

             The  primitive  operations   above   are   sufficient   for
             sequential  input and output.  Several points are worthy of
             note.  On input operations, CURSOR  is  incremented  before
             the  actual transfer operation, while on output operations,
             it is  incremented  after  the  transfer.  In  both  cases,
             CURSOR  represents the current index into the virtual array
             f.data.  Notice that RESET and UPDATE effectively perform a
             GET  operation as they fill the buffer with the first datum
             in the file.  Also, a GET which  increments  f.cursor  past
             f.extent  does  not  fill the buffer, and EOF becomes TRUE.
             This also holds for a RESET of a file which exists  but  is
             empty.   Finally,   note  that  PUT  extends  the  file  if
             necessary.




             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 110


             14.4.4 Random File Operations                    Random File Operations

             Random access is provided through the SEEK operator for all
             files associated with the SEEKOK option.  SEEKOK is assumed
             for files associated with UPDATE.  SEEK is defined below:


             SEEK (f, n)

             f.cursor := n;
             IF (f.mode <> writeonly) AND (f.cursor <= f.extent) THEN
               f.buffer := f.data [f.cursor]


             SEEK is used to reposition CURSOR to another place  in  the
             file.  Notice that if input is permitted, SEEK will perform
             an input operation if the new CURSOR value  is  within  the
             file,  thus insuring f^ is always defined.  The user should
             make every effort to  avoid  redundant  GET  operations  by
             remembering  that  SEEK keeps f^ updated.  For example, the
             sequence "SEEK(n); GET; f^..." contains an unnecessary GET,
             since   a  SEEK(n+1)  would  have  loaded  f^  as  desired.
             Similarly, to update the n-th element of  an  update  file,
             the  sequence  "SEEK(n);  f^ := newvalue; PUT" suffices; no
             GET is needed.  Notice, however, that after the  PUT,  even
             though  f.cursor  is  now  n+1,  f^ contains the (new) n-th
             element.  At this point, to update the (n+1)th  element,  a
             "SEEK(n+1)"  is  required to load f^; a GET would increment
             f.cursor before loading f^,  loading  the  (n+2)th  element
             instead of the (n+1)th.

             For  convenience,  the following shorthand translations are
             provided ( "=>" means "is equivalent to"):

             READ (f, x)  =>              x := f^; GET (f)
             WRITE (f, x)  =>             f^ := x; PUT (f)

             READ (f, x1, ... , xn)  =>   READ(f, x1);...;READ(f, xn)
             WRITE (f, x1, ... , xn)  =>  WRITE(f, x1);...;WRITE(f, xn)

             READRN(f, m, x1, ..., xn)  => SEEK(f,m);READ(f,x1,...,xn)
             WRITERN(f, m, x1, ..., xn)  => SEEK(f,m);WRITE(f,x1,...,xn)


             The READ and WRITE functions are most useful for sequential
             operations over the entire file, or over several contiguous
             elements.  Notice that a READ (or READRN) operation  always
             GETs the next element after the one just read.




             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 111


             14.5 Binary Files                  Binary Files


             It is often desirable or necessary to read and write blocks
             of data of arbitrary size.  A file type which is not  bound
             to   any   component  type  ("FILE  OF  *")  provides  this
             capability.  Such binary files may be defined in  terms  of
             the  model  presented  in  Section 14.4.  The difference is
             that there are no restrictions on  the  types  of  elements
             written or read (typed files require compatibility with the
             component).


             14.5.1 Extension of the Typed Formalism                    Extension of the Typed Formalism

             Any variable x can be viewed as an array of "storage units"
             with  upperbound  SIZE(x),  where  a  storage  unit  is the
             smallest addressable unit of storage for a  given  machine.
             Assuming for the moment that storage unit is a type (which,
             of course, it is not), and that x.[i] references a unit  of
             storage  whose  address is "ADDRESS(x)+i-1" within variable
             x, we may define the various binary file operators  (  "=>"
             may be interpreted as "is conceptually") :


             FILE OF *  =>           FILE OF storage unit

             READ (f, x:m)  =>       FOR i := 1 TO m DO READ (f, x.[i])
             WRITE (f, x:m) =>       FOR i := 1 TO m DO WRITE(f, x.[i])

             READ (f, x)  =>         READ (f, x: SIZE (x))
             WRITE (f, x)  =>        WRITE (f, x: SIZE (x))


             The same shorthand forms of READRN and WRITERN are provided
             for binary files as for typed files (see  Section  14.4.4).
             SEEK  sets the file cursor for the next operation, and READ
             and WRITE affect input and output transfers.  The cursor is
             maintained  in  storage  units;  thus,  calls  to  SEEK may
             utilize  SIZE,  EXTENT,  or  both   to   preserve   machine
             independence  (see  Sections  12.3  and  12.4).  No  buffer
             variable (f^) is defined for binary files;  thus,  the  GET
             and PUT operations may not be used.

             However,  binary  files may be viewed as having a "internal
             buffer" which is not directly accessible.  While GET,  PUT,
             and  the  file buffer f^, which are used to define the READ
             and WRITE operations for typed files, cannot be  used  with
             binary  files, the model given for typed-file operations is
             still valid for binary files if  the  user  visualizes  the
             operations  in  terms  of  the  storage  unit  type  and an

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 112


             internal buffer.  For example, after a RESET  on  a  binary
             file,  CURSOR is 1 (and is subsequently adjusted in storage
             unit increments), and  the  internal  buffer  contains  the
             first  storage  unit.  If  a  READ is then performed, for a
             variable which is one  storage  unit  in  size,  the  first
             storage  unit  in  the  file  will  be transferred into the
             variable from the internal buffer,  and  the  next  storage
             unit  in  the  file  will be read into the internal buffer.
             Through a similar line of reasoning, the  operation  READRN
             (f,  3, x) will get x starting at the third storage unit in
             the file.  Note that no internal  buffer  actually  exists,
             and  thus  the  READ  operation  does  not really load file
             elements into it.



             14.6 Errors in Input and Output                  Errors in Input and Output


             Errors in the Pascal i/o  system  fall  into  two  distinct
             classes.     Certain    errors    indicate    "catastrophic
             environmental conditions" which are certain to  affect  the
             program's   subsequent   performance   (for   example,   an
             unrecoverable  disk  error).  After  such  errors,  further
             operations  are  prohibited  on  the  file  where the error
             occurred.  Other  errors  signal  "irregular  results  from
             standard   functions"  which  will  not  affect  subsequent
             operations.


             14.6.1 The Predefined Type IO_STATUS                    The Predefined Type IO_STATUS

             The Pascal i/o system communicates error information to the
             user   program   through  values  of  the  predefined  type
             IO_STATUS:

                type
                  io_status = 
                  (io_ok, io_novf, io_povf, io_dgit, io_govf, io_intr,
                 io_rewr, io_eof, io_outf, io_inpf, io_seek, io_illc,
                   io_nemp, io_opnf);

             The meaning of each value is explained in Section 14.6.3.









             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 113


             An error code is associated with every file variable, which
             is  set  on  every  i/o operation.  The predefined function
             IOSTATUS(f) returns the current value of the error code for
             the file variable f, and resets it to IO_OK.  IOSTATUS with
             no parameter returns the most recent error code set by  the
             i/o   system,   which  is  set  for  every  text-formatting
             operation (i.e., GETSTRING and PUTSTRING) as well as  every
             i/o operation).

             It  is  important  to  note  that every item in an i/o list
             represents an  individual  operation,  and  that  an  error
             occurring on the processing of one item may be reset by the
             next item.

                 scratch(f);
                 if iostatus (f) = io_nemp then (*f not there any more*)
                   writeln (tty, 'Couldn''t delete scratch file.');
                 getstring (str, i);
                 local := iostatus;          (*call without parameter*)
                 if local = io_govf then
                   writeln (tty, 'Couldn''t find any integer there.')
                 else if local = io_novf then
                   writeln (tty, 'Integer too big.');
                 reset (f, fname, options);
                 if eof (f) then
                   if iostatus (f) = io_opnf then
                     writeln (tty, 'File not found.')
                   else writeln (tty, 'File is empty.');


             14.6.2 Fatal and Nonfatal I/O Errors                    Fatal and Nonfatal I/O Errors

             The error codes listed in Section 14.6.1 may be  subdivided
             into  two  classes:  nonfatal  and  fatal.  Nonfatal errors
             signal some "interesting" condition which may be ignored by
             the  i/o  system.  Fatal  errors, with one exception, cause
             immediate, abnormal program  termination  unless  the  file
             variable  in question was associated with the RETRY option.
             This option defers program termination until the next  file
             operation,  to  permit  examination  of IOSTATUS(f).  If no
             call to IOSTATUS(f) is made,  the  next  call  to  any  i/o
             system   routine   using  f  will  cause  abnormal  program
             termination with the same error  condition  as  would  have
             occurred  previously, if f had not been associated with the
             RETRY option.  Since IOSTATUS(f) clears the file variable's
             error  code,  it  is  the  user's  responsibility  to avoid
             subsequent operations which may be damaging.





             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 114


             14.6.3 Meanings of I/O Error Codes                    Meanings of I/O Error Codes

             The conditions signaled by  each  of  the  values  of  type
             IO_STATUS  are  listed  below.  The  following are nonfatal
             conditions:

             IO_OK   - the  initial  and   default   value.   No   error
                       condition.

             IO_NOVF - arithmetic  overflow  on  conversion.  An attempt
                       was made to  convert  an  external  value  to  an
                       integer   which  exceeds  the  allowed  range  of
                       values.    Subrange    limits     are     checked
                       independently.  The  value of the integer item is
                       not modified.

             IO_POVF - PUTSTRING overflow.  Conversion of a data item to
                       its  external  representation would have exceeded
                       the  maximum  length  of  the   string-compatible
                       target.   The   external  representation  is  not
                       stored in the object string of the PUTSTRING.

             IO_DGIT - invalid  numeric  input.  For  integer  reads,  a
                       digit  was  encountered  which  is not within the
                       base of the read  (e.g., a  '9'  seen  during  an
                       octal  read),  terminating the read.  For integer
                       or real reads, the first nonblank character  seen
                       was  not  acceptable  for the conversion, and the
                       corresponding variable is set to zero.

             IO_GOVF - GETSTRING overflow.  The end of the object string
                       was  encountered before acceptable characters for
                       the desired conversion (e.g., a blank string  for
                       an  integer  conversion).  The target reference's
                       value is not modified.

             The following are fatal conditions:

             IO_INTR - internal    error    in    i/o     system.     An
                       implementation-dependent error has been detected.

             IO_REWR - rewrite  required.  An  attempt was made to write
                       to  a  file  which  was  open  for  input   only.
                       Subsequent input operations will work.

             IO_EOF  - attempt  to  read  beyond  the end of file (EOF).
                       Input operations cannot be performed once an  end
                       of file has been encountered.  This error code is
                       also returned from an attempt to read from a file
                       which   was  open  for  output  only.  Subsequent
                       output operations will  work.  If  the  file  was

             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 115


                       associated  with the SEEKOK option, the error may
                       be recovered by SEEKing within the file limits.

             IO_OUTF - output failure.  An environmental error  occurred
                       on   an   output   operation.  Subsequent  output
                       operations may be damaging.

             IO_INPF - input failure.  An environmental  error  occurred
                       on   an   input   operation.   Subsequent   input
                       operations may be damaging.

             IO_SEEK - attempt to SEEK nonrandom file.  A SEEK operation
                       was  performed  on a file not associated with the
                       SEEKOK   option.   This   error    requires    no
                       correction.

             IO_ILLC - illegal cursor value.  A nonpositive cursor value
                       was  passed  to  SEEK.  This  error  requires  no
                       correction.

             IO_NEMP - can't  empty  file.  The  EMPTY  operation on the
                       file variable failed, or  a  SCRATCH  failed  and
                       performed  a  CLOSE  instead.  The  file variable
                       should be CLOSEd by  the  program  if  EMPTY  was
                       attempted.

             IO_OPNF - association failure.  The file variable could not
                       be associated as  requested.  The  file  variable
                       need  not be CLOSEd after such an error.  This is
                       the  only  fatal  error  which  will  not   cause
                       immediate  termination; it is always deferred, as
                       if RETRY had been  specified.  In  addition,  EOF
                       can  be used after an association operation as an
                       error  check.  For  input-only  and  input-output
                       files, EOF will be TRUE if an error occurred; for
                       output-only files, EOF will be FALSE if an  error
                       occurred.  Performing  a RESET with an empty file
                       will also set EOF TRUE, but the IOSTATUS(F) error
                       return may be used to distinguish between the two
                       conditions.




             14.6.4 Extended Status                    Extended Status

             The    predefined    function    EXTSTATUS    returns    an
             integer-compatible value which further describes i/o errors
             in an implementation-dependent fashion.  The default  value
             of EXTSTATUS is zero.  For example,


             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 116


                  open (f, filename, options);
                  if iostatus (f) = io_opnf then begin
                    local := extstatus;
                    writeln (tty,'File failed, code [', local:12:o, ']')
                    end;

             will  print  the message 'File failed, code [000000000001]'
             if EXTSTATUS returns the  value  1.  Note  that  the  local
             variable  was  needed to save the value of EXTSTATUS, since
             the writing of the constant string 'File  failed,  code  ['
             would have reset EXTSTATUS to zero.









































             Input and Output
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 117


             15 STANDARD FUNCTIONS                STANDARD FUNCTIONS






             15.1 Arithmetic Functions                  Arithmetic Functions




             15.1.1 Ordinary Mathematical Functions                    Ordinary Mathematical Functions

             Each  of  the  following  functions  takes  a  single  real
             argument (except for ARCTAN--see note 3) and returns a real
             result.  The  precision  of the result is at least as great
             as the precision of the argument.  An integer  argument  is
             converted   to   type  REAL.  These  functions  have  their
             conventional mathematical meanings.

                  SQRT          LN (1)         LOG (2)        EXP
                  SIN           ARCSIN         SINH           COS
                  ARCCOS        COSH           TAN
                  ARCTAN (3)    TANH           COTAN

             Notes:

                (1)  LN returns the base e logarithm of its argument.
                (2)  LOG returns the base 10 logarithm of its argument.
                (3)  ARCTAN may take two arguments.  ARCTAN(x,y) =
                     ARCTAN(x/y), except that it is defined even if
                     y is zero.


              15.1.2 Generic Mathematical Functions                     Generic Mathematical Functions

                  ABS(x) = |x|
                  SQR(x) = x*x

             When called  with  an  integer  argument,  these  functions
             return   an   integer  result.  When  called  with  a  real
             argument, they return a  real  result  with  at  least  the
             precision of the argument.

                  MIN(x1,x2,...,xn)
                  MAX(x1,x2,...,xn)

             MIN  returns the smallest of its arguments, and MAX returns
             the largest of its arguments.  If all of the arguments  are
             integers,  then  the  result  is an integer.  If any of the

             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 118


             arguments are real, then all of the arguments are converted
             to real, and the result is real.


             15.1.3 Miscellaneous                    Miscellaneous

                  ODD(x) is a predicate which takes an integer argument,
                       and returns TRUE if  its  argument  is  odd,  and
                       FALSE if it is even.

                  RANDOM(x)  returns  a  pseudorandom real number with a
                       uniform  distribution  from  the  interval  0  <=
                       RANDOM(x)  <  1,  using  x  as  the  seed for the
                       random-number generator.

                  RANDOM() is the same as RANDOM(x),  but  it  uses  the
                       value returned by the last call to RANDOM for its
                       seed.  On the first call to  RANDOM,  a  standard
                       seed is used.



             15.2 Type Conversion Functions                  Type Conversion Functions




             15.2.1 Arithmetic Conversions                    Arithmetic Conversions

                  TRUNC(x) takes a real argument, and returns an integer
                       representing the integer part  of  its  argument.
                       TRUNC always truncates toward zero.

                  ROUND(x)  takes  a  real  argument,  and  returns  the
                       integer which is closest to its argument.

                       ROUND(x)   = TRUNC(x+0.5), if x > 0.
                                  = TRUNC(x-0.5), if x < 0.

                  ROUND(x,n) When called in this form, ROUND  returns  a
                       real  result  representing  its  first  argument,
                       rounded to the decimal  place  indicated  by  its
                       second argument.

                            ROUND(x,n) = ROUND(x/(10**n)) * (10**n)

                       For    example,    ROUND(3.1415,-2)    =    3.14;
                       ROUND(1495.27,2) = 1500.




             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 119


             15.2.2 Scalar and Pointer Conversions                    Scalar and Pointer Conversions

                  ORD(s) takes an  argument  of  any  scalar  type,  and
                       returns  an  integer  representing the ordinal of
                       the argument in the set of values making  up  its
                       type.  The  elements of an enumerated scalar type
                       have ordinals 0, 1,  ...  n-1,  corresponding  to
                       their  positions  in  the list defining the type.
                       If s is an integer, then ord(s) = s.

                  ORD(ptr) where ptr is a pointer will return an integer
                       representing  the address in memory of the object
                       pointed to by ptr.

                  CHR(n) takes an integer argument, and returns the n-th
                       character  in  the ASCII character set.  That is,
                       CHR(n)   is   the    character    with    numeric
                       representation n in ASCII.

             Let T be the name of any scalar type, and let P be the name
             of any pointer  type.  Then  the  following  functions  are
             defined:

                  T(n)  takes  an integer argument, and returns the n-th
                       element of the type T.  CHR is equivalent to  the
                       type name CHAR used as a function.

                  P(ptr) takes any pointer as an argument, and returns a
                       pointer of  type  P  which  points  to  the  same
                       location  in  memory  as  its  argument  pointer.
                       Unwise use of this feature may easily  compromise
                       program  portability, in much the same way as use
                       of undiscriminated unions in record types.

                  P(n) may also be used as a function  with  an  integer
                       argument.   It  returns  a  pointer  of  type  P,
                       pointing to the absolute memory location n.



             15.3 Operations on Simple Types                  Operations on Simple Types


                  SUCC(v) takes an argument  of  any  scalar  type,  and
                       returns  the  next element of that type.  If v is
                       the largest value of its type, this is an  error.
                       ORD(SUCC(v)) = ORD(v) + 1.

                  PRED(v)  takes  an  argument  of  any scalar type, and
                       returns the previous element of that type.  If  v
                       is  the  smallest element of its type, this is an

             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 120


                       error.  ORD(PRED(v)) = ORD(v) - 1.

                  MINIMUM(v) takes an argument of any simple  type,  and
                       returns  the  smallest  value  of that type.  The
                       argument to MINIMUM may be either a reference  of
                       a  simple  type,  or  the name of the simple type
                       itself.

                  MAXIMUM(v) takes an argument of any simple  type,  and
                       returns  the  largest  value  of  that type.  The
                       argument to MAXIMUM may be either a reference  of
                       a  simple  type,  or  the name of the simple type
                       itself.

                  MIN and MAX may be called, not only  with  integer  or
                       real  arguments,  but also with arguments of some
                       scalar type.  All the arguments must  be  of  the
                       same type, and MIN or MAX returns the smallest or
                       the largest of the arguments, respectively.



             15.4 String Functions                  String Functions


             In the following descriptions, s, s1, and s2 represent  any
             string-compatible  expressions  (i.e.,  a  fixed or varying
             string, or a character); ind, len, and default are  integer
             values; and chars is a set of characters.

                  LENGTH(s)  takes  a  string,  and  returns  an integer
                       representing  its  length.  The   length   of   a
                       character  is  always  1;  the  length of a fixed
                       string is the declared length of the string;  and
                       the  length  of  a  varying string is the current
                       length, which is between zero  and  the  declared
                       maximum length of the string.

                  UPPERCASE(s)  takes a string, and returns an identical
                       string in which all the  lowercase  letters  have
                       been  replaced  by  the  corresponding  uppercase
                       letters.

                  LOWERCASE(s) takes a string, and returns an  identical
                       string  in  which  all the uppercase letters have
                       been  replaced  by  the  corresponding  lowercase
                       letters.

                  SUBSTR(s,ind[,len])  takes  a string, an index, and an
                       optional  length.  If  the  length  is   omitted,
                       SUBSTR  returns  the  substring  of  the original

             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 121


                       string from the ind-th character to  the  end  of
                       the  string.  If  the  length  is specified, then
                       SUBSTR returns len characters  from  the  string,
                       starting   with   the   ind-th   character.   The
                       arguments to SUBSTR must satisfy the relations:

                       1 < ind < LENGTH(s) + 1, if len is omitted.
                       1 < ind < ind + len < LENGTH(s) + 1,
                          if len is specified.

                       Unlike any other function, SUBSTR may also appear
                       on the left-hand side of an assignment statement.
                       In this case, s must be a variable reference (see
                       Section  9.1),  and  the effect is to replace the
                       specified characters of the referenced string  by
                       the string expression from the right-hand side of
                       the assignment.

                  INDEX(s1,s2[,default]) returns the index in s1 of  the
                       first character of the leftmost occurrence of s2.
                       If s2 does not occur in s1,  then  INDEX  returns
                       zero  if  the default argument is omitted, or the
                       default argument if it is  specified.  If  S2  is
                       the  null  string,  then  the  value  one will be
                       returned.

                  SEARCH(s,chars[,default]) returns  the  index  of  the
                       leftmost  character  in  s  which is in the chars
                       set.  If  there  is  no  such  character  in  the
                       string,  then  SEARCH returns zero if the default
                       argument is omitted, or the default  argument  if
                       it is specified.

                  VERIFY(s,chars[,default])  returns  the  index  of the
                       leftmost character in s which is not in the chars
                       set.  If  there  is  no  such  character  in  the
                       string, then VERIFY returns zero if  the  default
                       argument  is  omitted, or the default argument if
                       it is specified.



             15.5 File Predicates                  File Predicates


                  EOF(file) takes a file as  an  argument,  and  returns
                       TRUE if the current position in the file is at or
                       beyond its end, and FALSE otherwise.  EOF  should
                       always  be true for an output file not associated
                       with the SEEKOK option.  If EOF is  true  for  an
                       input file not associated with the SEEKOK option,

             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 122


                       then any further attempt to read  from  the  file
                       will cause an error.

                  EOLN(file)  takes  a  text  file  as  an argument, and
                       returns TRUE if the file is positioned at the end
                       of a line, and FALSE otherwise.  When a text file
                       is positioned at the end  of  a  line,  the  file
                       buffer (file^) contains a blank if not associated
                       with the ASCII option.  The file can be  advanced
                       to the start of the next line by doing a GET or a
                       READLN.

                  EOPAGE(file) takes a text file  as  an  argument,  and
                       returns TRUE if the file is positioned at the end
                       of a page, and FALSE  otherwise.  EOPAGE  implies
                       EOLN,  so the file may be advanced by doing a GET
                       or READLN.

                  CURSOR(file) takes a file  as  argument.  For  a  text
                       file,   CURSOR   returns   an  integer-compatible
                       position within the  current  line.  For  nontext
                       files,  CURSOR  returns  the one-based index into
                       the file corresponding to the current position in
                       the  file.  For  typed  files,  f^  contains  the
                       CURSORth element in the file.

                  IOSTATUS(file)  may  take  a  file  as  argument,  and
                       returns  a value of type IO_STATUS indicating any
                       errors that may have occurred on  the  last  file
                       operation.  If  no  argument is given, the result
                       of the last operation  (including  PUTSTRING  and
                       GETSTRING) is returned.

                  EXTSTATUS() returns an integer-compatible value giving
                       an implementation-dependent  extended  status  of
                       the last file operation.

                  EXTENT(file)  returns the number of actual elements in
                       a typed file or  the  number  of  actual  storage
                       units  in  a binary file.  EXTENT may not be used
                       with text files.

                  FILENAME(file) returns the name of the  physical  file
                       or  device  associated with a file as a string of
                       the predefined  varying  string  type  FILE_NAME,
                       whose maximum length is implementation dependent.






             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 123


             15.6 Environment Inquiries                  Environment Inquiries


                  DATE()  returns a nine-character string containing the
                       current  date  in  the  format  DD-MMM-YY  (e.g.,
                       '17-Apr-78').

                  TIME()  returns  an integer representing the number of
                       milliseconds which have elapsed since midnight.

                  RUNTIME() returns an integer representing milliseconds
                       of elapsed CPU time.  The value of RUNTIME at the
                       start of program execution is not specified,  but
                       the  difference  between  RUNTIME at the start of
                       program execution and  RUNTIME  at  an  arbitrary
                       time  during  execution will always be the number
                       of CPU milliseconds used by this program.



             15.7 Attribute Inquiries                  Attribute Inquiries


                  LOWERBOUND(a[,dim]) returns  the  lower  bound  of  an
                       array (in a specified dimension), of a string, or
                       of a set.  If a is an array reference or the name
                       of  an  array  type,  then LOWERBOUND returns the
                       lower  bound  of  the  array  in  the   dimension
                       specified  by  dim,  which  must  be  a  positive
                       integer  constant.  If  the   dim   argument   is
                       omitted,   it   defaults   to   1  (the  leftmost
                       dimension).  When applied to a fixed or  flexible
                       array,  LOWERBOUND  returns a constant, which may
                       be of any simple type.  When applied to a generic
                       array  parameter,  LOWERBOUND returns the ordinal
                       value of the lower  bound  of  the  corresponding
                       actual  array  parameter.  LOWERBOUND  returns  1
                       when applied to a string reference or type  name,
                       and  the  lower  bound  of  the  set  domain when
                       applied to a set reference or type name.

                  UPPERBOUND(a[,dim]) is the same as LOWERBOUND,  except
                       that  it  returns  the  upper  bound of an array,
                       string, or set instead of its lower  bound.  When
                       applied  to an array, the result of UPPERBOUND is
                       a constant unless the argument is a generic array
                       parameter  or  a  flexible array reference.  When
                       applied to a string reference, UPPERBOUND returns
                       the  maximum  length  of  the  string type.  When
                       applied to a set, it returns the upper  bound  of
                       the domain of the set type.

             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 124


                  DIMENSION(a[,dim])   is   related  to  LOWERBOUND  and
                       UPPERBOUND.  It returns an integer indicating the
                       number  of  elements  in  an  array,  the maximum
                       number  of  characters  (maximum  length)  of   a
                       string,  or  the number of elements in the domain
                       of a set type.  In all  cases,  DIMENSION(a,n)  =
                       ORD(UPPERBOUND(a,n)) - ORD(LOWERBOUND(a,n)) + 1.

                  ADDRESS(v)  returns  a  value of type PTR representing
                       the memory address of the variable v.  V may be a
                       variable reference (see Section 9) which is not a
                       substring reference or a nonstructured  component
                       of  a  packed  structured variable; or v may be a
                       value parameter.

                  EXTENT(ptr) returns an integer representing the number
                       of   storage   units   (generally,   the  minimum
                       addressable  amount  of  storage  on  a  machine)
                       occupied  by  the  dynamic  variable ptr^, if the
                       dynamic  variable  was  allocated  by  a  NEW  or
                       ALLOCATE.

                  SIZE(x)  returns an integer representing the number of
                       storage units required for  the  storage  of  its
                       argument.  X  may  be either a variable reference
                       or a type name.  The type  of  x  may  not  be  a
                       packed  scalar type, and x may not be a reference
                       to a nonstructured field of a  packed  structured
                       type.  When applied to a flexible array, SIZE can
                       take a second argument specifying the upper bound
                       for  the  array.  When applied to a generic array
                       parameter, SIZE takes  two  additional  arguments
                       specifying    the   lower   and   upper   bounds,
                       respectively.  When  applied  to  a  record  with
                       variants,  SIZE  can  take constant tag values to
                       select variants to be used.  When  applied  to  a
                       record  with  a trailing flexible component, SIZE
                       can take a final argument  specifying  the  upper
                       bound for the array.



             15.8 Predefined Constants                  Predefined Constants



                  COMPDATE()  returns a nine-character string containing
                       the compilation date of the module in the  format
                       DD-MMM-YY (e.g., '17-Apr-79').

                  COMPTIME() returns a eight-character string containing

             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 125


                       the time of day of the compilation in the  format
                       HH:MM:SS (e.g., "14:22:03").



             15.9 Functions in Constant Expressions                  Functions in Constant Expressions


             All  of  the  standard  functions  may  be used in constant
             expressions, except for the following:

                  RANDOM        EOLN           EOF            DATE
                  TIME          RUNTIME        ADDRESS        CURSOR
                  EOPAGE        IOSTATUS       EXTSTATUS      EXTENT
                  FILENAME

             If a function is used in a  constant  expression,  all  the
             arguments  of  the  function  must be constant expressions,
             unless the function is one of the following,  which  return
             information  about  the type of their arguments rather than
             about their values:

                  MINIMUM       MAXIMUM        LOWERBOUND     UPPERBOUND
                  DIMENSION     SIZE




























             Standard Functions
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 126


                        APPENDIX A - SYNTAX OF THE LANGUAGE  




             ::=         means "is defined as"

             [  ]        encloses an optional item

             ...         indicates one or more occurrences of  preceding
                         item

             |           means "choose one of"; indicates alternatives

             lowercase   indicates a category name

             UPPERCASE   indicates a reserved word

             -           unites a compound variable name

             ' '         indicates  the  literal character or characters
                         enclosed by the single quotes.

             {  }        indicates that the contents of the  braces  are
                         to be treated as a single item

             In   the   BNF   which   follows,   symbols   of  the  form
             something-reference,        something-expression        and
             constant-something    (except    constant-definition)   are
             understood to be equivalent to reference,  expression,  and
             constant,  respectively.  The  qualifier in the symbol name
             is used as semantic commentary.


             compilation ::=
                main-program | subroutine-module | data-module
                | environment-module

             main-program ::= program-heading body '.'

             program-heading ::=
                PROGRAM identifier [ options-clause ] ';'

             body ::=
                [ declaration-part ';' ] statement-part

             subroutine-module ::=
                module-heading declaration-part '.'




             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 127


             module-heading ::=
                MODULE identifier [ options-clause ] ';'

             data-module ::=
                data-module-heading declaration-part END '.'

             data-module-heading ::=
                DATAMODULE identifier [ options-clause ] ';'

             environment-module ::=
                environment-module-heading declaration-part END '.'

             environment-module-heading ::=
                 ENVMODULE identifier [ options-clause ] ';'

             declaration-part ::=
                declaration [ ';' declaration ] ...

             declaration ::=
                label-declaration | const-declaration
                | type-declaration | var-declaration 
                | subroutine-declaration | exception-declaration

             label-declaration ::=   LABEL label [ ',' label ] ...

             const-declaration ::=
                [ PUBLIC | EXTERNAL ] CONST
                   constant-definition [ ';' constant-definition ] ...

             constant-definition ::=
                identifier ':' type |
                identifier [ ':' type ] { '=' | ':=' } constant

             var-declaration ::=
                [ PUBLIC | EXTERNAL | STATIC ] VAR
                   var-definition [ ';' var-definition ] ...

             var-definition ::=
                identifier-list ':' type [ ':=' constant ]

             identifier-list ::= identifier [ ',' identifier ] ...

             type-declaration ::=
                TYPE type-definition [ ';' type-definition ] ...

             type-definition ::= type-identifier '=' type

             type-identifier ::= identifier exception-declaration




             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 128


             subroutine-declaration ::=
                actual-subroutine-declaration 
                | forward-subroutine-declaration 
                | external-subroutine-declaration

             actual-subroutine-declaration ::=
                [ PUBLIC ] subroutine-heading ';' body

             forward-subroutine-declaration ::=
                [ PUBLIC ] subroutine-heading ';' FORWARD

             external-subroutine-declaration ::=
                EXTERNAL subroutine-heading

             subroutine-heading ::=
                procedure-heading | function-heading

             procedure-heading ::=
                PROCEDURE identifier [ parameter-list ]
                   [ options-clause ]

             function-heading ::=
                FUNCTION identifier [ parameter-list ]
                   ':' type [ options-clause ]

             parameter-list ::=
                short-parameter-list | long-parameter-list

             long-parameter-list ::=
                '(' [ parameter-definition
                        [ ';' parameter-definition ] ... ] ')' 

             parameter-definition ::=
                [ VAR ] identifier-list ':' type

             short-parameter-list ::=
                '(' [ parameter-description
                        [ ';' parameter-description ] ... ] ')'

             parameter-description ::= [ VAR ] type

                   (A  short  parameter  list  may  only  appear  in  an
                   external subroutine declaration or a subroutine type)

             options-clause ::=
                OPTIONS option [ ',' option ] ...

             option ::= identifier [ '(' option-parameter 
                [',' option-parameter] ... ')']

             option-parameter ::= identifier | number | string

             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 129


             type ::=
                type-identifier | simple-type | pointer-type 
                | set-type | subroutine-type | file-type 
                | structured-type

             simple-type ::=
                [ packing-clause ] unpacked-simple-type

             packing-clause ::=
                PACKED [ '[' constant-width ']' ]

             unpacked-simple-type ::=
                enumerated-type | subrange-type

             subrange-type ::=
                constant-lower-limit '..' constant-upper-limit
                         [ PREC constant-precision ]

             enumerated-type ::=
                '(' identifier [ ',' identifier ] ... ')'

             pointer-type ::= '^' type

             set-type ::= [PACKED] SET OF domain-type

             domain-type ::= type-identifier | unpacked-simple-type

             subroutine-type ::=
                PROCEDURE [ parameter-list ]
                FUNCTION [ parameter-list ] ':' type

             file-type ::=
                [ PACKED ] FILE OF { type | '*' }

             structured-type ::=
                array-type | string-type | record-type

             array-type ::=
                [ PACKED ] ARRAY
                 '[' index-type [ ',' index-type ] ... ']' OF type

             index-type ::=
                type-identifier | unpacked-simple-type 
                constant-lower-bound '..' '*' | '*'

             string-type ::=
                STRING [ '[' {constant-maximum-length |  '*' } ']' ]

             record-type ::=
                [ PACKED ] RECORD [ field-list ] [ ';' ] END


             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 130


             field-list ::=
                fixed-part [ ';' variant-part ] variant-part

             fixed-part ::=
                field-definition [ ';' field-definition ] ...

             field-definition ::=   identifier-list ':' type

             variant-part ::=
                CASE [ identifier ':' ] type OF
                   variant [ ';' variant ] ...

             variant ::=
                case-label-list ':' '(' [ field-list ] [ ';' ] ')'

             case-label-list ::= range-list | OTHERS

             statement-part ::= 
                BEGIN statement-list handler-clause handler END

             statement-list ::= statement [ ';' statement ] ...

             statement ::=   [ label ':' ] unlabeled-statement

             unlabeled-statement ::=
                simple-statement | structured-statement
                | exit-statement

             simple-statement ::=
                assignment-statement | call-statement
                | goto-statement | return-statement
                | stop-statement | null-statement

             assignment-statement ::=
                variable-reference ':=' expression

             call-statement ::=
                procedure-reference [ actual-parameter-list ]

             (Standard i/o conversion routines READ, READLN, WRITE
             WRITELN, PUTSTRING, and GETSTRING have nonstandard
             parameter lists and reserved identifiers.)

             goto-statement ::= GOTO label

             return-statement ::= RETURN

             stop-statement ::= STOP




             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 131


             null-statement ::= (* nothing *)

             structured-statement ::=
                compound-statement | with-statement
                conditional-statement | repetitive-statement

             compound-statement ::=
                BEGIN statement-list [ handler ] END

             with-statement ::=
                WITH record-reference [ ',' record-reference ] ... DO
                   unlabeled-statement

             conditional-statement ::=
                if-statement | case-statement

             if-statement ::=
                IF expression THEN unlabeled-statement
                   [ ELSE unlabeled-statement ]

             case-statement ::=
                CASE selector expression OF
                   case-member [ ';' case-member ] ... [';'] END

             case-member ::=
                case-label-list ':' unlabeled-statement

             repetitive-statement ::=
                while-statement | repeat-statement
                | for-statement | loop-statement

             while-statement ::=
                WHILE expression DO unlabeled-statement

             repeat-statement ::=
                REPEAT statement-list UNTIL expression

             for-statement ::=
                FOR identifier ':=' for-range DO
                   unlabeled-statement

             for-range ::=
                initial-expression TO final-expression 
                | initial-expression DOWNTO final-expression

             loop-statement ::=
                LOOP statement-list END





             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 132


             exit-statement ::=
                EXIT IF expression [ DO unlabeled-statement ]

                   (An  EXIT  statement  is  used  as  an  escape from a
                   repetitive construct.  It can only appear in the body
                   of  such  a  statement  or  in a WITH statement which
                   itself appears in a repetitive statement.)

             reference ::=
                entire-reference | field-reference 
                | indexed-reference | substring-reference
                | pointer-reference | function-reference 
                | component-reference

             entire-reference ::= identifier

             field-reference ::=
                reference '.' identifier

             indexed-reference ::=
                reference '[' expression [ ',' expression ] ... ']'

             substring-reference ::=
                reference '[' expression ':' expression ']'

             pointer-reference ::= reference '^'

             function-reference ::=
                reference [ actual-parameter-list ]

             actual-parameter-list ::=
                '(' [ expression [ ',' expression ] ... ] ')'

             component-reference ::= reference '^'

             constant ::= expression

                   (Any expression may be used as  a  constant  provided
                   that   it  yields  a  constant  value.  Most  of  the
                   standard functions may be used.)

             expression ::=
                simple-expression | composite-expression

             simple-expression ::=
                term [ relational-operator term ]

             relational-operator ::=
                IN | '=' | '' | '' | '' | '=' | '='



             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 133


             term ::=
                factor [ adding-operator-factor ] ...

             adding-operator ::=
                '+' | '-' | OR | ORIF | '||'

             factor ::=
                power-expression
                   [ multiplying-operator power-expression ] ...

             multiplying-operator ::=
                '*' | '/' | DIV | MOD | AND | ANDIF

             power-expression ::=
                unary-expression [ '**' unary-expression ]

             unary-expression ::=
                [ '+' | '-' | NOT ] primitive-expression

             primitive-expression ::=
                unsigned-integer | unsigned-real
                | string | reference | '(' simple-expression ')' 
                | set-expression

             composite-expression ::=
                '(' [ expression  [',' expression ] ... ] ')'

                   (A structured  expression  can  only  be  used  in  a
                   context  where  a  value  of  a  structured  type  is
                   expected.)

             set-expression ::= '[' [ range-list ] ']'

             range-list ::= range [ ',' range ] ...

             range ::= scalar-expression [ '..' scalar-expression ]
















             Appendix A - Syntax
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 134


                                       INDEX  






             ABS, 118
             ADDRESS, 34, 73, 125-26
             ALLCONDITIONS handler, 75-76, 78-79
             ALLOCATE, 34, 64-65, 68
             Apostrophe, indicating in string constant, 12
             ARCCOS, 118
             ARCSIN, 118
             ARCTAN, 118
             Arithmetic conversion functions, 119
             Arithmetic exceptions, 80
             Arithmetic operators, 51-52
             Array types, 5-6, 38-40
               Assignment of, 40
               Bounds of, 38
               Expressions, 55
               Fixed-length, 39
               Flexible, 6, 39, 42, 55, 69-71, 85
               Generic, 39-40, 55, 85
               Index type in, 38
               Multidimensional, 5-6, 38
             ASCII,character constants,nonprinting, 12, 32, 86, 92, 107
               option, 86, 88, 92-93, 97, 105, 107
             Assignment, 40
             Association of physical files, devices, 85-88, 103-04, 
                 109-10
             Attention and overflow exceptions, 81
             ATTENTION condition, 81
             Attribute inquiries, 124-25


             Base type, of subrange, 31
             Binary files, 37, 48, 83, 85, 112-13
             Block structure, 2, 16, 17-18 
               Levels, 16, 17, 18
               Local, definition of, 16
               Scope, 17-19
             BNF, 9-10
             BOOLEAN, 4, 33
             Boolean, Operators, 52-53
             BREAK, 89, 106
             Buffer variable, 36, 85, 104-05
             Buffered i/o with a terminal, 104-06



             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 135


             CALL statement, 7, 25, 57
             Carriage control, and CONTROL option, 92-93
             CASE statement, 7, 59-60, 67
             CHARacter, Type, 4, 6, 31, 32, 36, 40
             Character i/o conversions, 93-98
             CHR, 92, 120
             CLEAR, standard procedure, 106
             CLOSE, 88-89
             Comments, 12
             Compatibility, 28, 30-32, 33-35, 37, 42-43, 46, 50-51,
                 55, 63, 84, 93-99, 112
             Compatible file variables, operations between, 84
             COMPDATE, 125
             Component references, 48
             Component type, 36-37, 83, 108
               Files without explicit, 36-37, 40
             Component variable, 36
             Composite expressions, 54
             Compound statements, 58
             COMPTIME, 125-26
             Concatenation operator, 41
             Condition names, 74
             Constant expressions, functions in, 126
             Constants, 2-3, 12, 17
               Declaration of, 17, 19-20
               Local, definition of, 19
               Predefined, 125-26
             CONTROL, 86, 92
             Conversion functions, 119-20
               Arithmetic, 119
               Pointer, 120
               Scalar, 120
             COS, 118
             COSH, 118
             COTAN, 118
             CURSOR, 93, 107, 109, 111, 123, 126


             Dangling reference, 65, 66
             Data-transfer, in typed files, 109-10
             DATE, 124, 126
             Declarations, 2-6, 17-21
               Actual, 22-23
               Constant, 17, 19
               EXTERNAL, 2, 16, 18, 19-20, 23-24, 74
               FORWARD, 22-23
               Label, 19
               POINTER, 34-35
               PUBLIC, 2, 16,  18, 23, 74
               STRING, 40-41
               Subroutine, 22-24

             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 136


               Type, 28-29
               Variable, 3
             Default input conversions, 96-97
             Default output conversions, 98
             Dereferencing the pointer, 34-35, 47, 63, 64, 65
             DIMENSION, 38, 125, 126
             DISPOSE, 65, 89
             Dissociation of file variables, 88-89
             Dynamic allocation, 63-73


             Elementary types, 4-5
             EMPTY, 88
             Empty set, 35
             Entire reference, 45
             Enumerated types, 4, 33
             Environment, definition of, 26
               inquiries, 124
               modules, 13, 14-16
             EOF, 90, 91, 106, 107, 109, 115, 122, 126
             EOLN, 90, 91, 107, 122, 126
             EOPAGE, 90, 91, 106, 107, 122, 126
             Exception manager, 74
             EXCEPTION_MESSAGE, 82
             Exceptional conditions, 74-82
             EXIOSTATUS, 80
             EXIT statement, 60, 61, 62-63
             EXIT IF statement, 7-8
             EXP, 118
             Explicit type conversions, 44
             Expressions, 49-55
               Primitive, 50
               Set, 50-51
             EXTENT, 65, 68, 70, 112, 125, 126
             EXTSTATUS, 116, 123, 126


             Fatal i/o errors, 114, 115-16
             Field names, 6,  17, 41-43
             Field reference, 41-43
             Field width, 99, 100, 101-03
             Fields, in RECORD types, 6
             File name, definition of, 6, 83
             FILENAME, 88, 123, 126
             File predicates, 122-23
             FILE types, 5, 36-37
             Fixed-length strings, 40-41
             FOR statement, 7, 61-62
             Formatted input, 99-100
             Formatted output, 99, 100-03
             Forward references, 64

             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 137


             Fractional field width, 100, 102
             FUNCTION, 2-4, 5, 18, 22-27
             FUNCTION, References, 47-48
             FUNCTION, Types, 35-36
             Functions, standard, 118-26


             GET, 90, 91, 95, 103, 104, 110, 112
             GETSTRING, 94, 95, 96, 114
             GOTO statement, 8, 26, 56, 57, 60, 61, 62


             Handler clause, 74-77
               Active, 75, 76
             Handlers, 8, 74-78
             Handling exceptional conditions, 74-82
             Heap, 63, 65, 69, 70, 73
             Hexadecimal, Input interpretation, 99-100
               Output interpretation, 101-03


             Identical types, 28, 31, 34, 35, 36, 37, 38-39, 41, 
                 42-43, 63
             IF statement, 7, 59
             IMAGE, 86
               i/o, 107
             Implicit type conversions, 43-44, 56-57
             INDEX, 41, 122
             Indexed reference, 46
             Initialization, of constants, 43
               of static variables, 43
             INPUT, 87
             Input/Output, 37, 68, 83-117
               Errors in, 113-16
               Exceptions, 80
             Integers, 4, 11
               Decimal, 11
               Octal, 11
               Type, 31
               Unsigned, 11
             Interactive text file i/o, 103-07
             IO_ERROR, 80
             IO_STATUS, 80, 114-16, 123, 126


             LABELs, 2-3, 17, 19
             LENGTH, 41, 121
             LN, 118
             Local GOTO, 57
             LOG, 118
             LOOP statement, 7, 60, 62

             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 138


             LOWERBOUND, 38, 41, 124, 126
             LOWERCASE, 121


             MASK, 79
             Maskable exceptions, 79
               Not pending, 79
               Pending, 79
             MATHSTATUS, 80
             MATH_ERROR, 80
             MAXIMUM, 32, 34, 118, 121, 126
             MINIMUM, 32, 34, 118, 121, 126
             Mode, of a file, 83
             Multiple associations of file variables, 88


             Names, declaration and use of, 17-20
             NEW, 34, 64-65, 67-68, 69, 70, 81
             NEXP, 102
             NIL, 34, 63, 66
             NILF, 37, 84
             Nonfatal i/o errors, 114-15
             Nonlocal GOTO, 57
             Null string, 41


             Octal, Input interpretation, 99-100
             Octal, Output interpretation, 101
             ODD, 119
             OPEN, 86, 87, 103, 107, 109
             Operations on simple types, 120-21
             Operators, 7, 49-50, 51-54, 66
             ORD, 72, 120
             OTHERS handler, 75, 76, 77-78
               label, 42, 60
             OUTPUT, 87


             PACKED attribute, 6, 36
             Packing, 31
             PAGE, 90, 91, 92, 107
             Parameters,
               formal, 3-4, 17, 23, 25
               formal, Value, 3, 24, 25, 26
               formal, Var, 4, 24, 25
             Parameter list, Long, 24
               Short, 24
             Pascal, Program structure, 2-8, 13-16
                 Block, 13
                 Body, 13
                 Data module, 14

             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 139


                 Environment module, 14-16
                 Heading, 13
                 Main, 13-14
                 Subroutine, 14
             Pascal, Syntax, 127-34
             PENDING, 79
             Pointer coercion functions, 34, 71-73 
             Pointer conversion functions, 120
             Pointer types, 5, 34-35, 63-73
               Compatibility of, 34-35
               NIL, 34
               References, 47
             Pointer values, generating, 5
             PRECision factor, 5, 33-34, 100
             PRED, 32, 120-21
             PRESERVE, 86
             Primitive expressions, 49, 50
             PROCEDURE, 2-4, 5, 17, 22-25
               EXTERNAL, 4
               Invoking, 26
               Types, 35-36
             PROGRAMSTATUS, 81
             Program exceptions, 81
             PROGRAM_ERROR, condition, 81
             PROGRAM_STATUS, enumerated type, 81
             PTR, 34-35, 72
               Target type, 34
             PUT, 90, 95, 104, 110, 112
             PUTSTRING, 94, 95, 96, 114


             RANDOM, 119, 126
             Random access, 37
               in typed files, 111-12
             READ, 94, 95, 96, 111, 112, 113
             READ8, 107
             READLN, 94, 95, 96, 105
             READRN, 111, 112
             Reals, 4, 5, 33
               Type, 33
               Unsigned, 12
             RECORD type, 6, 37, 41-43
               Expressions, 55
             Recursive data structures, 63, 66
             References, 45-48
             Relational operators, 52
             REPEAT statement, 7, 60, 61
             Reserved words, 9
             RESET, 86, 87, 103, 109
             RETRY option, 80, 86
             RETURN statement, 8, 26, 62

             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 140


             REWRITE, 86, 87, 89, 103, 107
             ROUND, 119
             RUNTIME, 124, 126


             Scalars, 4
             Scalar conversion functions, 120
             Scope, 17-19
               Effect of predefined names on, 19
               Use of function name, 18
             SCRATCH, 88-89
             SEARCH, 41, 122
             SEEK operation, in typed files, 111-12
             SEEKOK, 86, 88, 111
             Separators, 12
             Sequential access, 37
             Set operators, 53
             SET types, 5, 35
               Compatibility of, 35
               Empty set, 35, 51
               Expressions, 50-51
               Operators, 35, 53
               Packed/unpacked, 35
             SIGNAL, 74, 75
             Signaling algorithm, 76-77
             Signaling a condition, 75
             Simple types, operations on, 120-21
             SIN, 118
             SINH, 118
             SIZE, 65, 68, 112, 125, 126
             Special symbols, 9
             SPECIAL_ERROR, 82
             SPECIALSTATUS, 82
             SQR, 118
             SQRT, 118
             STACK_OVERFLOW condition, 81
             Standard conditions, 80-82
             Standard functions, 118-26
               Arithmetic, 118-19
               Attribute inquiries, 124-25
               Environment inquiries, 124
               File predicates, 122-23
               in constant expressions, 126
               Predefined constants, 125-26
               Simple types, operations on, 120-21
               String, 121-22
               Type conversion, 119-20
             Standard types, 4-6
             Statements, 7-8, 56-62
               Assignment, 56-57
               CALL, 57

             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 141


               CASE, 59-60
               Compound, 58
               Conditional, 59
               EXIT, 60, 61, 62
               FOR, 60
               GOTO, 57, 60, 61, 62
               IF, 59
               LOOP, 60, 62
               REPEAT, 60
               Repetitive, 60-61
               RETURN, 58, 62
               Simple, 56
               STOP, 58, 62
               Structured, 58
               WHILE, 60
               WITH, 58
             Static variables, initialization of, 43
             STOP statement, 8, 62
             Storage, 6
             Storage unit, definition of, 112
             STORAGE_OVERFLOW condition, 81
             Strict compatibility, 28, 31, 33-34, 37-38
             String operators, 54
             STRING types, 6, 40-41
             Strings, standard functions for, 121-22
             Structured statements, 5-8, 37-43, 57
             Structured types, 5-8, 37-43
             Subrange, 5, 31, 33-34
               Base type in, 31, 33-34
             Subroutines, 2, 3, 5, 16, 22-27
               Active, definition of, 26
               Actual names in, 36
               Declaring, 21-24
               Invoking, 25-26
               Parameters, 24
               Types, 35-36
               Values for, 25
             SUBSTR, 41, 46-47, 121-22
             Substrings, 41
             Substrings, References, 46-47
             SUCC, 32, 120
             Syntax, lexical, of the language, 11-12, 127-34


             Tag fields, 6, 42, 67, 68, 69
             TAN, 118
             TANH, 118
             Target variables, 5, 63-64
             TEXT, 36, 87, 90
             Text files, 83, 90-107
               Basic character i/o, 90

             Index
                                           
                                           
                                           

                                           
                                           
                                           
             Tymshare Pascal Language Reference Manual          Page 142


               Structure, 90
             TIME, 124, 126
             Tokens, definition of, 12
             Total field width, 100, 101, 102
             TRUNC, 119
             TTY, 86, 87, 103, 104
             TTYOUTPUT, 86, 87, 103, 104
             Type conversions, 43-44
             Typed file, 83-84
               i/o, 108-11
             TYPEs, data, 4-6, 17, 28-44
               Declaration of, 28-29
               Hierarchy of, 30
               Identical, definition of, 28, 31
               Simple, 4, 31-33


             Unary operators, 51
             Undiscriminated record, 42, 55
             Undiscriminated unions, 6, 55, 68
             UNMASK, 79
             UPDATE, 86, 87, 89, 110
             UPPERBOUND, 38, 41, 70, 124, 126
             UPPERCASE, 121


             Value binding, 26
             Value compatibility, 28, 34-35
             Variables, 2-3, 17, 63
               Declarations, 17
               Dynamic, 63
               File, in i/o, 83-117
               Initial values for, 20
               Nonstatic, 20
               Referencing and modifying, 25
               STATIC, 20, 63
               Undefined values of, 25
             Variants, in RECORDs, 6, 42-43, 67-68
             Varying-length strings, 40-41
             VERIFY, 41, 122


             WHILE statement, 7, 60
             WITH statement, 58-59, 62, 66
             WRITE, 94, 95, 104, 111, 112
             WRITE8, 107
             WRITELN, 90, 91, 92, 93, 94, 95, 105
             WRITERN, 112




             Index
                                           
                                           
                                           

                                             
                                             
                                             
               Tymshare Pascal Language Reference Manual          Page 143


            SECTION     HEADING                                   PAGE



            1        INTRODUCTION                                 1

            2        SUMMARY OF THE LANGUAGE                      2

            2.1         The Declaration Section                   2

            2.1.2          Name Declarations                      3

            2.1.3          TYPEs                                  4

            2.2         The Statement Section                     7

            3        NOTATION AND TERMINOLOGY                     9

            4        LEXICAL SYNTAX                               11

            5        PROGRAM STRUCTURE                            13

            5.1         Kinds of Compilations                     13

            5.1.1          Main Programs                          13

            5.1.2          Subroutine Modules                     14

            5.1.3          Data Modules                           14

            5.1.4          Environment Modules                    14

            5.2         Block Structure                           16

            6        DECLARATION AND USE OF NAMES                 17

            6.1         Declarations                              17

            6.2         Scope of Names                            17

            6.3         Label Declarations                        19

            6.4         Constant Declarations                     19

            6.5         Variable Declarations                     20

            6.6         Other Declarations                        21

            7        PROCEDURES AND FUNCTIONS                     22

            7.1         Declaration of Actual Subroutines         22

            Contents
                                             
                                             
                                             

                                             
                                             
                                             
               Tymshare Pascal Language Reference Manual          Page 144


            7.2         Parameters                                24

            7.3         Subroutine Invocation                     25

            7.4         Subroutine Values                         26

            8        TYPES  27

            8.1         The Definition of Types                   27

            8.2         Simple Types                              30

            8.2.1          Scalar Types                           31

            8.2.1.1           INTEGER                             31

            8.2.1.2           CHARACTER                           31

            8.2.1.3           Enumerated Types                    32

            8.2.1.4           BOOLEAN                             32

            8.2.2          REAL                                   32

            8.2.3          Subrange Types                         32

            8.3         POINTER Types                             33

            8.4         SET Types                                 34

            8.5         Subroutine Types                          34

            8.6         FILE Types                                35

            8.7         Structured Types                          36

            8.7.1          ARRAY Types                            37

            8.7.1.1           Fixed-Length Arrays                 38

            8.7.1.2           Flexible Arrays                     38

            8.7.1.3           Generic Arrays                      38

            8.7.1.4           Assignment of Arrays                39

            8.7.2          STRING Types                           39

            8.7.3          RECORD Types                           40

            8.8         Implicit Type Conversions                 42

            Contents
                                             
                                             
                                             

                                             
                                             
                                             
               Tymshare Pascal Language Reference Manual          Page 145


            8.9         Explicit Type Conversions                 43

            9        REFERENCES                                   44

            9.1         Entire References                         44

            9.2         Field References                          44

            9.3         Indexed References                        45

            9.4         Substring References                      45

            9.5         Pointer References                        46

            9.6         Function References                       46

            9.7         Component References                      47

            10       EXPRESSIONS                                  48

            10.1        Simple Expressions                        48

            10.1.1         Primitive Expressions                  49

            10.1.2         Set Expressions                        49

            10.1.3         Arithmetic Operators                   50

            10.1.3.1          Unary Operators                     50

            10.1.3.2          Arithmetic Operators                50

            10.1.3.3          Relational Operators                51

            10.1.4         Boolean Operators                      51

            10.1.5         Set Operators                          52

            10.1.6         String Operators                       53

            10.2        Composite Expressions                     53

            10.2.1         Record Expressions                     54

            10.2.2         Array Expressions                      54

            11       STATEMENTS                                   55

            11.1        Simple Statements                         55

            11.1.1         Assignment Statements                  55

            Contents
                                             
                                             
                                             

                                             
                                             
                                             
               Tymshare Pascal Language Reference Manual          Page 146


            11.1.2         CALL Statements                        56

            11.1.3         GOTO Statements                        56

            11.1.4         RETURN Statements                      57

            11.1.5         STOP Statements                        57

            11.2        Structured Statements                     57

            11.2.1         Compound Statements                    57

            11.2.2         WITH Statements                        57

            11.2.3         Conditional Statements                 58

            11.2.3.1          IF Statements                       58

            11.2.3.2          CASE Statements                     58

            11.2.4         Repetitive Statements                  59

            11.2.4.1          WHILE Statements                    59

            11.2.4.2          REPEAT Statements                   60

            11.2.4.3          FOR Statements                      60

            11.2.4.4          LOOP Statements                     61

            11.2.4.5          EXIT Statements                     61

            12       POINTERS AND DYNAMIC ALLOCATION              62

            12.1        Allocation and Deallocation of Pointers   63

            12.1.1         Allocation                             63

            12.1.2         Deallocation                           64

            12.2        Operations on Pointers                    65

            12.3        Pointers to Records with Variants         66

            12.4        Pointers to Flexible Arrays               68

            12.5        Pointer Coercions                         70

            13       EXCEPTIONAL CONDITION HANDLING               73

            13.1        Conditions and Condition Handlers         73

            Contents
                                             
                                             
                                             

                                             
                                             
                                             
               Tymshare Pascal Language Reference Manual          Page 147


            13.2        Signaling a Condition                     74

            13.3        Handling a Signaled Condition             75

            13.3.1         OTHERS Handlers                        76

            13.3.2         ALLCONDITIONS Handlers                 77

            13.4        Maskable Exceptions                       78

            13.5        Standard Conditions                       79

            13.5.1         Arithmetic Exceptions                  79

            13.5.2         Input/Output Exceptions                79

            13.5.3         Program Exceptions                     80

            13.5.4         Attention and Overflow Exceptions      80

            13.5.5         Miscellaneous Exceptions               81

            13.6        Warning Messages                          81

            14       INPUT AND OUTPUT                             82

            14.1        File Types, Variables, and Modes          82

            14.2        Association with Physical Files, Devices  84

            14.2.1         Association                            85

            14.2.2         Dissociation and Multiple Associations 87

            14.3        Text File Input and Output                89

            14.3.1         Text File Structure                    89

            14.3.2         Basic Character Input and Output       89

            14.3.2.1          Character Set and the ASCII Option  90

            14.3.2.2          Carriage Control,  CONTROL Option   91

            14.3.3         Character Input and Output Conversions 92

            14.3.3.1          Default Input Conversions           95

            14.3.3.2          Default Output Conversions          97

            14.3.4         Formatted Input/Output                 98

            Contents
                                             
                                             
                                             

                                             
                                             
                                             
               Tymshare Pascal Language Reference Manual          Page 148


            14.3.4.1          Formatted Input                     98

            14.3.4.2          Formatted Output                    99

            14.3.5         Interactive Text File Input and Output 102

            14.3.5.1          Interactive Device Association      102

            14.3.5.2          Buffered I/O with a Terminal        103

            14.3.5.3          More Interactive I/O Considerations  105

            14.3.6         IMAGE Input and Output                 106

            14.4        Typed Input and Output                    107

            14.4.1         The Pascal Typed-File Model            107

            14.4.2         Association of Typed Files             108

            14.4.3         Data-Transfer Operations               109

            14.4.4         Random File Operations                 110

            14.5        Binary Files                              111

            14.5.1         Extension of the Typed Formalism       111

            14.6        Errors in Input and Output                112

            14.6.1         The Predefined Type IO_STATUS          112

            14.6.2         Fatal and Nonfatal I/O Errors          113

            14.6.3         Meanings of I/O Error Codes            114

            14.6.4         Extended Status                        115

            15       STANDARD FUNCTIONS                           117

            15.1        Arithmetic Functions                      117

            15.1.1         Ordinary Mathematical Functions        117

            15.1.2         Generic Mathematical Functions         117

            15.1.3         Miscellaneous                          118

            15.2        Type Conversion Functions                 118

            15.2.1         Arithmetic Conversions                 118

            Contents
                                             
                                             
                                             

                                             
                                             
                                             
               Tymshare Pascal Language Reference Manual          Page 149


            15.2.2         Scalar and Pointer Conversions         119

            15.3        Operations on Simple Types                119

            15.4        String Functions                          120

            15.5        File Predicates                           121

            15.6        Environment Inquiries                     123

            15.7        Attribute Inquiries                       123

            15.8        Predefined Constants                      124

            15.9        Functions in Constant Expressions         125

            APPENDIX A - SYNTAX OF THE LANGUAGE                   126

            INDEX    134

































            Contents
  T6wG