	SUBTTL	Gimpel--Ma355/JDS/DRH/MP/RCM/VB		15-Jun-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	UUOSYM		;TOPS10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	STRVER==5		;MAJOR VERSION NUMBER
	STRMIN==0		;MINOR VERSION NUMBER
	STREDT==233		;EDIT LEVEL
	STRWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	STR,SNOSTR,<Strings>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%UUOS		;VERSION NUMBER OF UUOSYM
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	STRTTL			; Title
	STRPTX			; PASS2 assembly message
	SUBTTL	Table of Contents

;		Table of Contents for Strings
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. ASCII. . . . . . . . . . . . . . . . . . . . . . . . .    4
;   4. CAT - THE CONCATENATION OPERATOR . . . . . . . . . . .    5
;   5. DIFFER & IDENT . . . . . . . . . . . . . . . . . . . .    6
;   6. DUPL(S,N). . . . . . . . . . . . . . . . . . . . . . .    7
;   7. THE LEXICAL COMPARISON PREDICATES. . . . . . . . . . .    8
;   8. LPAD & RPAD. . . . . . . . . . . . . . . . . . . . . .    9
;   9. REPLACE(S1,S2,S3). . . . . . . . . . . . . . . . . . .   11
;  10. REVERSE(S) . . . . . . . . . . . . . . . . . . . . . .   13
;  11. SIZE(S). . . . . . . . . . . . . . . . . . . . . . . .   14
;  12. SUBSTR(S,K,L). . . . . . . . . . . . . . . . . . . . .   15
;  13. TRIM(S). . . . . . . . . . . . . . . . . . . . . . . .   16
;  14. ASBLOK . . . . . . . . . . . . . . . . . . . . . . . .   17
;  15. CONCAT - CONCATENATE STRINGS . . . . . . . . . . . . .   18
;  16. DUPLI - INTERNAL FORM OF DUPL. . . . . . . . . . . . .   19
;  17. EQINIT - INITIALIZATION FOR EQUAL AND LEQUAL . . . . .   20
;  18. EQUAL - TESTS FOR EQUALITY BETWEEN STRINGS . . . . . .   21
;  19. IDINIT & IDENT . . . . . . . . . . . . . . . . . . . .   22
;  20. LEQUAL - LEXICAL TEST FOR STRINGS. . . . . . . . . . .   23
;  21. STCON - STRING CONSTANT (TO GROWING AREA). . . . . . .   24
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
226	REPLACE with unequal second and third arguments should fail
	not give an error message.
233	FIX EDIT 226, SO REPLACE WILL WORK.
\
	SUBTTL	ASCII

;	ASCII(N) WILL RETURN A SINGLE CHARACTER SPECIFIED BY THE
;	INTEGER N.	N IS INTERPRETED AS AN OCTAL NUMBER.
;	THUS, ASCII(11) IS THE TAB CHARACTER.

ASCI.0::ASCII:
	JSP	TLINK,CVTINT##	; MAKE SURE ARG IS INTEGER
	ERROR.	1,107		; BAD ARG.
	POP	STACK,S1	; INTEGER IS PLACED IN S1
	POP	STACK,Z		; THIS IS GARBAGE.
	CLEAR	P2,		; SHIFT COUNT IN P2
	CLEARB	S2,S3		; CLEAR S2 IN CASE OF 0
				; ACCUMULATED VALUE IS HELD IN S3

ASC.1:	JUMPE	S1,ASC.2	; DONE IF S1 FALLS TO 0
	IDIVI	S1,^D10		; INTERPRET THE NUMBER AS DECIMAL
				; REMAINDER GOES TO S2
	CAILE	S2,7		; ARE WE AN OCTAL LOOKING NUMBER
	ERROR	13,54		; NOPE -- BAD ARG TO ASCII
	LSHC	S2,-3		; SHIFT REM. INTO S3
	ADDI	P2,3		; RECORD AMOUNT OF SHIFT IN P2
	JRST	ASC.1		; LOOP

ASC.2:
	LSHC	S2,(P2)		; CORRECT VALUE IN S2
	CAIL	S2,^D128	; MUST BE LESS THAN 128
	ERROR	13,58		; ERRONEOUS ARG TO ASCII
	HRL	S2,S2		; PUT OFFSET INTO LEFT HALF
	HRRI	S2,1		; LENGTH OF STRING IS 1
	PUSH	STACK,$ALPHA##	; SBLOK IS &ALPHABET
	PUSH	STACK,S2	; COMPLETE STRING DESC.
	JRST	1(PLINK)	; SUCCESSFUL RETURN
	SUBTTL	CAT - THE CONCATENATION OPERATOR

;	STRING CONCATENATION IS HANDLED HERE
;	PATTERN CONCATENATION (AS WELL AS ANY OTHER
;	KIND) IS HANDLED ELSEWHERE.
;	NONSTRING ARGUMENTS ARE PASSED OFF TO CATP.

CAT::	MOVSI	P2,SDT		; LOAD P2 WITH NULL STRING TOP
	CAMN	P2,-1(STACK)	; SKIP IF 2ND ARG IS NONNULL
	JRST	CAT1		; TAKE BRANCH FOR NULL 2ND ARG
	CAMN	P2,-3(STACK)	; CHECK 1ST ARG FOR NULL
	JRST	CAT2		; BRANCH IF FIRST IS NULL

		;	HERE IF NEITHER ARG IS NULL

	JSP	TLINK,CVTSTR##	; TRY TO CONVERT 2ND ARG
	JRST	CATP##		; NO GO - LET PATTERNS HANDLE THIS
	POP	STACK,FLAP+1	; SAVE THE STRNG IN THE FLAP## ...
	POP	STACK,FLAP##	; REGION

	JSP	TLINK,CVTSTR	; CONVERT THE 1ST ARG. TO STRING
	JRST	CAT3		; NO GO - TAKE BRANCH

	POP	STACK,FLAP##+3	; REMOVE THE DESCRIPTOR ...
	POP	STACK,FLAP##+2	; FROM THE STACK
	PUSH	STACK,FLAP##	; NOW PUSH ...
	PUSH	STACK,FLAP##+1	; THESE DESCRIPTORS ...
	PUSH	STACK,FLAP##+2	; BACK ONTO ...
	PUSH	STACK,FLAP##+3	; THE STACK

	MOVEI	Z,2		; SET UP ARGUMENT TO CONCAT
	JSP	TLINK,CONCAT	; CALL CONCATENATE
	ERROR	11,13		; EXCEEDED &MAXLNGTH
	JRST	1(PLINK)	; NORMAL RETURN

		;	IF 2ND ARG IS NULL CONTROL ARRIVES HERE
CAT1:	SUB	STACK,[XWD 2,2]	; REMOVE 2ND ARGUMENT
	JRST	1(PLINK)	; RETURN SUCCESS
	
		; 	IF FIRST ARG IS NULL CONTROL ARRIVES HERE
CAT2:	POP	STACK,-2(STACK)	; REMOVE 1ST ...
	POP	STACK,-2(STACK)	; ARGUMENT
	JRST	1(PLINK)	; RETURN SUCCESS

		; 	IF 1ST ARG IS STRANGE, COME HERE
CAT3:	PUSH	STACK,FLAP##	; PUSH 2ND ARG ...
	PUSH	STACK,FLAP##+1	; ONTO STACK
	JRST	CATP		; LET PATTERN BUILDER HANDLE THIS
	SUBTTL	DIFFER & IDENT

;	THE BUILT-IN FUNCTIONS DIFFER(X,Y) AND IDENT(X,Y)

DFFR::	JSP	TLINK,IDINIT	; USE TYPE
	JSP	TLINK,IDENT	; T ROUTINES
	JRST	RETNUL##	; SUCCEED
	JRST	0(PLINK)	; FAIL


IDENT0::JSP	TLINK,IDINIT	; T
	JSP	TLINK,IDENT	; ROUTINES
	JRST	0(PLINK)	; FAIL
	JRST	RETNUL##	; SUCCEED
	SUBTTL	DUPL(S,N)

DUPL::	JSP	TLINK,CVTINT	; CONVERT 2ND ARG TO INTEGER
	ERROR.	1,63		; BAD 2ND ARG
	POP	STACK,S2	; SAVE VALUE OF N
	POP	STACK,Z		; THIS IS GARBAGE

	JUMPL	S2,FRET1##	; NEGATIVE N WILL CAUSE FAILURE

	JSP	TLINK,CVTSTR	; CONVERT FIRST ARGUMENT
	ERROR.	1,64		; BAD 1ST ARGUMENT
	MOVE	Z,S2		; LOAD REG 0 WITH N
	JSP	TLINK,DUPLI	; CALL UTILITY FOR DUPLICATING
	ERROR	11,10		; EXCEEDED &MAXLNGTH
	JRST	1(PLINK)	; NORMAL RETURN
	SUBTTL	THE LEXICAL COMPARISON PREDICATES

;		LEQ	 LGE	 LGT	 LLE	 LLT	 LNE

LEQ::	MOVSI	P2,2000		; INSERT JUMP CODE FOR JUMPE
	JRST	LEX		; JOIN COMMON PROCESSING

LGE::	MOVSI	P2,5000		;INSERT CODE FOR JUMPGE
	JRST	LEX		; JOIN COMMON CODE

LGT::	MOVSI	P2,7000		; INSERT CODE FOR JUMPG
	JRST	LEX		; JOIN COMMON CODE

LLE::	MOVSI	P2,3000		; INSERT CODE FOR JUMPLE
	JRST	LEX		; JOIN COMMON CODE

LLT::	MOVSI	P2,1000		; INSERT CODE FOR JUMPL
	JRST	LEX		; JOIN COMMON CODE

LNE::	MOVSI	P2,6000		; INSERT CODE FOR JUMPN
;	JRST	LEX		; JOIN COMMON CODE


;	MERGE HERE FROM ALL 6 LEXICAL ENTRY POINTS.
LEX:	JSP	TLINK,CVTSTR	; MAKE SURE 2ND ARG IS STRING
	ERROR.	1,36		; BAD 2ND ARG.
	POP	STACK,FLAP##+1	; SAVE THIS DESCRIPTOR ...
	POP	STACK,FLAP##	; IN THE FLAP## REGION 
	JSP	TLINK,CVTSTR	; MAKE SURE FIRST ARGUMENT IS STRING
	ERROR.	1,35		; BAD FIRST ARGUMENT

;	IN THE SUBSEQUENT COMPUTATION S1 WILL BE SET POSITIVE,
;	ZERO, OR NEGATIVE DEPENDING ON WHETHER THE FIRST
;	ARGUMENT IS RESPECTIVELY GREATER THAN, EQUAL TO , OR LESS 
;	THAN THE 2ND ARGUMENT.

;	MERGE HERE FROM IDENT AND DIFFER (STRING CASE)
LEXC:	SETZ	S1,		; INITIALIZE S1 TO 0
	JSP	TLINK,EQINIT	; GO INITIALIZE LEQUAL TEST
	JRST	LEXC1		; MUST HAVE BEEN NULL STRING
	PUSH	STACK,FLAP##	; PUSH THE 2ND ARGUMENT
	PUSH	STACK,FLAP##+1	; ONTO THE STACK
	JSP	TLINK,LEQUAL	; GO CALL LEXICAL COMPARISON
	MOVEI	S1,1		; 2ND LESS THAN FIRST
	SKIPA			; 2ND = FIRST
LX.2ND:	SETO	S1,		; 2ND GREATER THAN FIRST

;	MERGE HERE FROM LEXC1 (FIRST ARG HAD BEEN NULL)
LX.CMP:	IOR	P2,[JUMP S1,RETNUL]	; INSERT REST OF INSTR.
	XCT	P2		; RETURN NULL IF S1 SATISFIES
				; SPECIFIED CONDITION.
	JRST	0(PLINK)	; OTHERWISE FAIL

LEXC1:	SUB	STACK,[2,,2]	; POP NULL STRING 
	MOVE	S2,FLAP##	; LOAD FIRST WORD OF 2ND ARG
	CAME	S2,NULLST##	; IS THIS ALSO THE NULL STRING
	JRST	LX.2ND		; NO - 2ND ARG IS GREATER
	JRST	LX.CMP		; YES - 2ND ARG IS ALSO NULL
				; S1 IS ALREADY 0 - GO MAKE COMP.
	SUBTTL	LPAD & RPAD

LPAD::	JSP	SLINK,PADCOM	; OFF TO COMMON ROUTINE

;	MERGE HERE FROM RPAD
LPAD1:	MOVEI	Z,2		; INDICATE 2 ARGS FOR
	JSP	TLINK,CONCAT	; CONCATENATE
	ERROR	11,11		; EXCEEDED &MAXLNGTH
	JRST	1(PLINK)	; NORMAL RETURN

RPAD::	JSP	SLINK,PADCOM	; PROCESS ARGS
	MOVE	Z,0(STACK)	; EXCHANGE
	EXCH	Z,-2(STACK)	; THE
	MOVEM	Z,0(STACK)	; TOP
	MOVE	Z,-1(STACK)	; TWO
	EXCH	Z,-3(STACK)	; DESCRIP-
	MOVEM	Z,-1(STACK)	; TORS
	JRST	LPAD1
;	HERE TO PROCESS ARGS FOR LPAD AND RPAD
;	AN S-TYPE ROUTINE WHICH LEAVES TWO STRINGS
;	ON THE STACK.	THE FIRST IS THE FIRST STRING
;	ARGUMENT.	THE SECOND IS THE 3RD ARGUMENT
;	DUPLICATED THE CORRECT NUMBER OF TIMES.

PADCOM:
	CAIE	Z,2		; SKIP ON NORMAL 2-ARG CASE
	JRST	PAD3		; MUST BE 3 ARGS
	PUSH	STACK,$ALPHA	; PUSH BLANK ...
	PUSH	STACK,[XWD " ",1]	; ONTO STACK
	JRST	PAD1		; JOIN PROCESSING

PAD3:	CAIE	Z,3		; SKIP IF 3 ARGS
	ERROR	13,57		; HE GOOFED
	JSP	TLINK,CVTSTR	; MAKE IT A STRING
	ERROR.	1,75		; BAD 3RD ARGUMENT
	HRRZ	S2,0(STACK)	; LOAD LENGTH TO S2
	CAIE	S2,1		; IF 1 SKIP
	ERROR	13,56		; OTHERWISE HE ERRED

;	MERGE HERE FROM THE 2 ARG CASE
PAD1:	POP	STACK,FLAP+1	; SAVE THE 3RD ARG
	POP	STACK,FLAP	; IN THE FLAP AREA

	JSP	TLINK,CVTINT	; CONVERT 2ND ARG
	ERROR.	1,76		; BAD 2ND ARG
	POP	STACK,S2	; SAVE VALUE IN S2
	POP	STACK,Z		; GET RID OF DATATYPE

	JSP	TLINK,CVTSTR	; CONVERT 1ST ARG
	ERROR.	1,77		; BAD 1ST ARG
	HRRZ	S3,0(STACK)	; LENGTH TO S3
	SUB	S2,S3		; NUMBER OF CHARS. NEEDED TO S2
	JUMPLE	S2,1(PLINK)	; IF WE HAVE ENOUGH, RETURN

	MOVE	Z,S2		; LOAD ARG FOR CALL TO DUPL
	PUSH	STACK,FLAP	; PUSH PAD ...
	PUSH	STACK,FLAP+1	; CHAR. BACK ONTO STACK
	JSP	TLINK,DUPLI	; DUPLICATE PAD CHAR
	ERROR	11,11		; STRING TOO LONG
	JRST	0(SLINK)	; RETURN TO SENDER
	SUBTTL	REPLACE(S1,S2,S3)

;	EFFICIENCY IS OBTAINED BY NOT BUILDING A TABLE
;	IF S2 AND S3 ARE THE SAME AS 'LAST TIME'

RPLC::	MOVE	T1,STACK	; SAVE THE STACK
	MOVEI	S1,3		; THERE ARE 4 WORDS TO BE COMPARED
RPL4:	POP	STACK,S2	; RETRIEVE STACK VALUE
	CAME	S2,RP.A2##(S1)	; COMPARE THIS WITH FORMER VALUE
	JRST	RPL3		; IF UNEQUAL, BRANCH
	SOJGE	S1,RPL4		; DEDUCT FROM S1 AND GO BACK

;	MERGE HERE AFTER TABLE CONSTRUCTION
RPL1:	JSP	TLINK,CVTSTR	; CONVERT 1ST ARG TO STRING
	ERROR.	1,88		; BAD FIRST ARG
	HRRZ	P2,0(STACK)	; EXTRACT LENGTH OF THIS STRING
	JUMPLE	P2,1(PLINK)	; IF THIS IS 0, RETURN IT.

	MOVE	Z,P2		; LOAD ARGUMENT AND ...
	JSP	QLINK,ASBLOK	; ALLOCATE AN SBOK
	ERROR	11,13		; &MAXLNGTH ERROR
	MOVE	T3,-1(STACK)	; SAVE IN T3 THE FIRST DESCR. WORD
	JSP	QLINK,CVTPTR##	; CONVERT NEW STRING TO POINTER
	0			; DON'T BASE IT
	ERROR	15		; THIS CAN'T HAPPEN
	MOVEM	Z,T1		; SAVE POINTER OF NEW STRING IN T1

	JSP	QLINK,CVTPTR	; NOW CONVERT OLD STRING
	0			; NO BASING
	JRST	RETNL1##	; MUST HAVE BEEN NULL STRING
	MOVEM	Z,T2		; SAVE POINTER IN T2

	PUSH	STACK,T3	; PUSH VALUE TO BE RETURNED
	PUSH	STACK,P2	; THROW IN LENGTH
	MOVE	S1,RP.TBL##	; LET S1 POINT TO TABLE

;	START OF LOOP FOR REPLACEMENT
RPL2:	ILDB	S2,T2		; GRAB FIRST BYTE OF SUBJECT STRING
	ADD	S2,S1		; ADD IN THE TABLE ADDRESS
	MOVE	S2,CTBITS(S2)	; PICK UP REPLACEMENT BYTE
	IDPB	S2,T1		; INSERT INTO NEW STRING
	SOJG	P2,RPL2		; DECREMENT AND REPEAT (AND TEST)
	JRST	1(PLINK)	; SUCCESSFUL RETURN
;	HERE IF THE 2ND AND 3RD ARGUMENTS ARE DIFFERENT FROM BEFORE
RPL3:	MOVE	STACK,T1	; RESTORE STACK
	JSP	TLINK,CVTSTR	; CONVERT 3RD ARG.
	ERROR.	1,86		; BAD 3RD ARG
	POP	STACK,RP.A2##+3	; SAVE ARG FOR ...
	POP	STACK,RP.A2##+2	; NEXT TIME

	JSP	TLINK,CVTSTR	; CONVERT 2ND ARG
	ERROR.	1,87		; BAD ARG
	POP	STACK,RP.A2##+1	; SAVE ARG FOR ...
	POP	STACK,RP.A2##	; NEXT TIME

;	EITHER A TABLE HAS BEEN CREATED BEFORE IN WHICH CASE
;	WE'LL USE IT OR IT HAS NOT BEEN CREATED IN WHICH CASE
;	WE MUST ALLOCATE ONE.
RPL7:	SKIPN	S1,RP.TBL##	; LOAD S1 WITH TABLE ADDRESS
	JRST	RPL5		; GO CREATE TABLE
	ADDI	S1,CTBITS+^D127	; POINT TO LAST WORD IN TABLE
	MOVEI	S2,177		; INDEXING VARIBLE (ALSO IN-
				; SERTION CHARACTER)

	MOVEM	S2,0(S1)	; PLUG CHARACTER INTO TABLE
	SOS	S1		; POINT TO NEXT WORD IN TABLE
	SOJGE	S2,.-2		; DECREMENT CHRACTER AND LOOP

	PUSH	STACK,RP.A2	; PUSH 2ND ARG. BACK ...
	PUSH	STACK,RP.A2+1	; ONTO STACK
	JSP	QLINK,CVTPTR	; CONVERT TO POINTER
	0
	JRST	RPL6		; MUST BE NULL STRING
	MOVEM	Z,T2		; SAVE POINTER IN T2

	PUSH	STACK,RP.A2+2	; PUSH 3RD ARG ...
	PUSH	STACK,RP.A2+3	; ONTO STACK
	JSP	QLINK,CVTPTR	; CONVERT TO POINTER
	0
	 JRST	FRET1##		;[226] Fail - Unequal arguments
	MOVEM	Z,T3		; SAVE IN T3

	MOVE	S1,RP.TBL	; LET S1 POINT TO THE TABLE
	HRRZ	T4,RP.A2+1	; GET LENGTH OF 2ND ARG.
	HRRZ	Q1,RP.A2+3	; GET LENGTH OF 3RD ARG.
	CAME	T4,Q1		; ARE THEY EQUAL, SKIP IF SO
	 JRST	FRET1##		;[226] Fail - Unequal arguments

;	LOOP FOR INSERTING CHARACTERS INTO THE TABLE
RP.INS:	ILDB	Q2,T2		; GET BYTE FROM 2ND ARG.
	ADDI	Q2,0(S1)	; ADD IN ADDRESS OF TABLE
	ILDB	Q3,T3		; RETRIEVE CORRESPONDING BYTE OF 3RD
	MOVEM	Q3,CTBITS(Q2)	; INSERT BYTE
	SOJG	T4,RP.INS	; GO BACK AND LOOP
	JRST	RPL1		; TABLE IS FINISHED - RESUME PROCESSING

;	HERE IF A TABLE HAS TO BE CREATED
;	WE'LL USE A CHARACTER TABLE ALTHOUGH IN AN UNUSUAL WAY
RPL5:	MOVE	Z,[XWD CTBLOK,^D128+CTBITS]
	JSP	QLINK,BLOK##	; ALLOCATE THE BLOK
	ERROR	15		; NO ERROR IS POSSIBLE HERE
	POP	STACK,RP.TBL+1	; RETRIEVE DESCRIPTOR
	POP	STACK,RP.TBL	; FROM STACK
	JRST	RPL7

;	HERE IF 2ND ARG IS NULL
RPL6:	SUB	STACK,[XWD 2,2]	; POP 2ND ARG FROM THE STACK
	MOVE	T1,NULLST	; LOAD NULL STRING
	CAME	T1,RP.A2+2	; IS 3RD ARG. ALSO NULL
	 JRST	FRET1##		;[266] Fail - Unequal arguments
	JRST	RPL1		; YES - THIS REPLACE IS A NOOP
	SUBTTL	REVERSE(S)

RVRS::	JSP	TLINK,CVTSTR	; ENSURE STRING ARGUMENT
	ERROR.	1,89		; BAD ARGUMENT

	MOVE	Z,0(STACK)	; SAVE STRING ...
	MOVEM	Z,FLAP+1	; DESCRIPTOR ...
	MOVE	Z,-1(STACK)	; IN FLAP ...
	MOVEM	Z,FLAP		; REGION

	JSP	QLINK,CVTPTR	; CONVERT DESCRIPTOR TO POINTER
	P2			; BASED ON P2
	JRST	RETNL1##		; REMOVE 1 DESCRIPTOR AND RETURN NULL
	MOVEM	Z,S1		; SAVE THE POINTER

	HRRZ	S2,FLAP+1	; S2 WILL HOLD THE STRING LENGTH
	MOVE	Z,S2		; SET UP ARGUMENT FOR CALL TO ASBLOK
	JSP	QLINK,ASBLOK	; ALLOCATE AN SBLOK
	ERROR	11,13		; EXCEEDED &MAXLNGTH
	MOVEM	S2,0(STACK)	; INSERT LENGTH INTO STRING DESCR.

	MOVE	T1,S2		; COPY LENGTH
	IDIVI	T1,5		; WORD COUNT IN T1, BYTE COUNT IN T2
	MOVE	P2,FLAP		; LOAD BASE REG. FOR STRING ARG
	MOVE	Q1,-1(STACK)	; LOAD BASE REGISTER FOR NEW STRING
	ADD	Q1,T1		; ADD IN WORD COUNT
	JUMPE	T2,RV.2		; IF BYTE COUNT IS 0 JUMP INTO LOOP

;	TOP OF LOOP
RV.1:	ILDB	T3,S1		; LOAD T3 WITH NEXT BYTE
	LSHC	T3,-7		; SHIFT BYTE INTO T4
	SOJG	T2,RV.1		; IF STILL MORE IN T2, GO BACK

;	A WORD (OR A PARTIAL WORD IF THIS IS THE FIRST TIME THRU)
;	OF CHARACTERS HAS JUST BEEN LOADED INTO T4 IN REVERSE.
;	SINCE THESE CHARACTERS WERE OBTAINED FROM THE FRONT OF
;	THE ARGUMENT STRING, THEY MUST NOW BE DEPOSITED INTO THE
;	BACK END OF THE NEWLY CONSTRUCTED STRING
	MOVEM	T4,SCHARS(Q1)	; STORE CHARACTERS INTO LAST WORD
RV.2:	MOVEI	T2,5		; REINITIALIZE T2 IN CASE WE GO AGAIN
	SOJL	T1,1(PLINK)	; LOOP ON WORD COUNT
	SOJA	Q1,RV.1		; ADJUST NEW STRING POINTER AND LOOP
	SUBTTL	SIZE(S)

SIZE::	JSP	TLINK,CVTSTR	; CONVERT ARG TO STRING
	ERROR.	1,37		; BAD ARGUMENT TO SIZE
	MOVSI	Z,IDT		; LOAD Z WITH INTEGER DATA TYPE
	MOVEM	Z,-1(STACK)	; PLUG 1ST DESCRIPTOR WORD
	HRLM	Z,0(STACK)	; ZERO OUT OFFSET FIELD
	JRST	1(PLINK)	; SUCCESSFUL RETURN
	SUBTTL	SUBSTR(S,K,L)

;	LET A AND B BE THE OFFSET AND LENGTH WITHIN THE 
;	DESCRIPTOR FOR S.	LET A' AND B' BE THE NEW OFFSET
;	AND LENGTHS RESPECTIVELY.	THEN
;
;	A' = A + K - 1
;	B' = L
;
; PROVIDED:	K-1 GREATER THAN OR EQUAL TO 0
;		L	 GREATER THAN OR EQUAL TO 0
;		L	 LESS THAN OR EQUAL TO B - (K-1)
;
;	SUBSTR FAILS IF ANY OF THESE CONDITIONS IS NOT SATISFIED
;	
;	ALSO	SUBSTR(S,K) HAS AN IMPLIED L OF 
;		L = B - (K-1)


SBSTR::	CAIN	Z,2	; TEST FOR NUMBER OF ARGS BEING EQUAL TO 2
	JRST	SB.2	; TAKE THIS BRANCH IF SO
	CAIE	Z,3	; SKIP IF 3 ARGS
	ERROR	13,50	; BAD 2ND ARG TO SUBSTR

	JSP	TLINK,CVTINT	; CONVERT 3RD ARGUMENT TO INTEGER
	ERROR.	1,97		; BAD 3RD ARG
	
	POP	STACK,S3	; L IS SAVED IN S3
	POP	STACK,Z		; GET RID OF THIS JUNK
	JUMPL	S3,FRET2##	; FAIL IF S3 IS NEGATIVE
	JUMPE	S3,RETNL2##	; IF S3 IS 0 RETURN NULL STRING

;	MERGE HERE FROM 2-ARGUMENT CASE WITH S3 = 0
SB.3:	JSP	TLINK,CVTINT	; CONVERT 2ND ARG TO INTEGER
	ERROR.	1,96		; BAD 2ND ARG
	POP	STACK,S2	; 2ND ARG (K) TO S2
	POP	STACK,Z		; REMOVE HEADER
	SOJL	S2,FRET1##	; KEEP K-1 IN S2. ALSO FAIL IF NEG.

	JSP	TLINK,CVTSTR	; CONVERT FIRST ARG TO STRING
	ERROR.	1,95		; BAD FIRST ARG.
	HLRZ	T1,0(STACK)	; OFFSET (A) TO T1
	HRRZ	T2,0(STACK)	; LENGTH (B) TO T2
	SUB	T2,S2		; B-(K-1) IS NOW IN T2
	JUMPL	T2,FRET1##	; IF NEGATIVE WE FAIL

	SKIPN	S3		; IF S3 IS ZERO ...
	MOVE	S3,T2		; SET IT TO B-(K-1)

	JUMPE	S3,RETNL1##	; RETURN NULL IF LENGTH IS 0
	CAMLE	S3,T2		; SKIP IF L	LE	B-(K-1)
	JRST	FRET1##		; FAIL IF OTHERWISE
	ADD	T1,S2		; A + K - 1 TO T1 (THIS IS A')
	HRL	S3,T1		; MAKE (A',B') WORD IN S3
	MOVEM	S3,0(STACK)	; INSERT THIS INTO STACK
	JRST	1(PLINK)	; AND RETURN

;	2-ARGUMENT SUBSTR
SB.2:	SETZ	S3,		; SET 3RD ARG. TO 0
	JRST	SB.3		; JOIN MAIN PROCESSING
	SUBTTL	TRIM(S)

TRIM::	JSP	TLINK,CVTSTR	; ENSURE STRING
	JRST	1(PLINK)	; OK - JUST RETURN

	JSP	TLINK,TRIMT	; USE T VERSION OF TRIM
	JRST	1(PLINK)	; AND RETURN
	SUBTTL	ASBLOK

;	CALLING SEQUENCE:
;
;	LOAD Z WITH # OF CHARS
;	JSP	QLINK,ASBLOK
;	WILL ALLOCATE AN SBLOK.	
;	THE VALUE WILL BE RETURNED ON THE STACK AND
;	WILL BE A DOUBLE-0 STRING DESCRIPTOR.
ASBLOK::
	CAMLE	Z,$MAXL##		; COMPARE REQUEST WITH KEYWORD
				; (&MAXLNGTH)
	JRST	0(QLINK)	; TAKE ERROR EXIT IF TOO BIG
	MOVEM	Z,Q2		; PUT # IN Q2 SO DIVISION IS POSS.
	ADDI	Q2,SCHARS*5+4	; ADD EVEN MORE BYTES
	IDIVI	Q2,NBYTES	; DIVIDE BY NUMBER OF BYTES PER WORD
				; REQUIRED IN Q2
	HRLI	Q2,SBLOK	; PREPARE REST OF HEADER

;	MERGE HERE AFTER GARBAGE COLLECT
ASB2:	MOVEM	Q2,BTCODE&BLENG(SURF)
				; INSERT HEADER WORD
	CLEARM	GCFLD(SURF)	; CLEAR GCFLD
	MOVE	Q3,SURF		; SAVE IN Q3 CURRENT SURFACE
	ADDI	SURF,0(Q2)	; INCREMENT SURF BY REQ. AMOUNT.
	CAMLE	SURF,CEIL##	; SKIP IF NO  COLL. IS NEEDED
	JRST	ASB1		; GO HANDLE THE GC CASE
	HRLI	Q3,SDT		; PREPARE DESCRIPTOR WORD
	PUSH	STACK,Q3	; RETURN THIS VALUE
	PUSH	STACK,[0]	; RETURN DOUBLE-0 STRING
	HLL	Q3,[POINT 7,0-0]; RETURN POINTER ...
	ADDI	Q3,SCHARS	; IN Q3
	JRST	1(QLINK)	; NORMAL RETURN

;	HERE IF INSUFFICIENT ROOM
ASB1:	SUBI	SURF,0(Q2)	; BRING SURFACE BACK TO PREVIOUS LEVEL
	MOVE	Q3,Z		; SAVE # OF CHARS.
	PUSHR	Q		; SAVE Q REGISTERS
	MOVEI	Z,0(Q2)		; LOAD NUMBER OF WORDS NEEDED
	JSP	QLINK,GCOLF##	; MAKE ROOM
	POPR	Q		; RESTORE Q REGISTERS

	JRST	ASB2		; BACK TO JOIN MAIN PROC.
	CAIL	Z,16614		; JUST FOR UPDATE.SNO
	SUBTTL	CONCAT - CONCATENATE STRINGS

;	 CALLING SEQUENCE:
;
;	PUSH STRING DESCRIPTORS ONTO STACK (IN REVERSE ORDER)
;	LOAD Z WITH # OF ARGS
;	JSP	TLINK,CONCAT
;	ERROR RETURN
;	NORMAL RETURN - RETURNED VALUE AT STACK TOP

CONCAT::
	MOVE	T2,Z		; COPY # OF STRINGS INTO T2
	MOVE	T3,STACK	; T3 WILL INDEX THROUGH THE STACK
	CLEAR	T4,		; ZERO OUT T4

;	THIS IS THE TOP OF A LOOP TO COMPUTE THE LENGTH OF THE 
;	RESULTING STRING
CC1:	ADD	T4,0(T3)	; ADD OFFSET - LENGTH OF ARG. STRING
	SUBI	T3,2		; DECREMENT T3
	SOJG	Z,CC1		; DO THIS FOR EACH ARGUMENT

;	FALL THRU WHEN T4 HAS THE TOTAL ACCUMULTED LENGTHS
;	IN ITS RIGHT HALF
	HRRZ	Z,T4		; INSERT TOTAL LENGTH INTO Z
	JSP	QLINK,ASBLOK	; ALLOCATE THE SBLOK
	JRST	0(TLINK)	; PASS ERROR BACK
	MOVE	T3,-1(STACK)	; SAVE STRING DESCRIPTOR ...
	MOVEM	T3,FLAT##	; IN FLAT AREA
	HRRZM	T4,FLAT##+1	; INSERT LENGTH INTO 2ND DESCR WORD

	MOVEM	Q3,T4		; SAVE POINTER IN T4
	SUB	STACK,[2,,2]	; POP STACK

;	TOP OF LOOP THAT CONCATENATES STRINGS
CC2:	HRRZ	T3,0(STACK)	; SAVE ITS LENGTH
	JSP	QLINK,CVTPTR	; GET POINTER FOR IT
	0			; NO BASING NEEDED
	JRST	CC4		; MUST HAVE BEEN A NULL STRING

CC3:	ILDB	Q1,Z		; GET CHARACTER OF STRING TO BE ...
				; CONCATENATED IN.
	IDPB	Q1,T4		; INSERT THIS CHARACTER INTO MAIN STRING
	SOJG	T3,CC3		; DO IT FOR AS MANY CHARACTERS AS ARE
				; IN THE SUBSTRING.
	SOJG	T2,CC2		; LOOP ON NUMBER OF STRINGS

;	CONCATENATION IS COMPLETED.
CC5:	PUSH	STACK,FLAT##	; RETURN ...
	PUSH	STACK,FLAT##+1	; SAVED ...
	JRST	1(TLINK)	; STRING

;	IF ONE OF THE STRINGS WAS A NULL COME HERE
CC4:	SUB	STACK,[XWD 2,2]	; GET RID OF DESCRIPTOR
	SOJG	T2,CC2		; DEDUCT FROM # OF STRINGS COUNT
	JRST	CC5		; NON LEFT? RETURN
	SUBTTL	DUPLI - INTERNAL FORM OF DUPL

;	 CALLING SEQUENCE:
;
;	PUSH STRING DESCRIPTOR ONTO STACK (MUST BE STRING)
;	LOAD Z WITH NUMBER OF DUPLICATONS
;	JSP	TLINK,DUPLI
;	ERROR - STRING TOO LONG
;	NORMAL - STRING ARG IS REPLACED BY RETURNED VALUE
;
;	 REGISTER ALLOCATION FOR DUPLI(S,N)
;
;	T2 : SIZE(S)
;	T3 : N
;	T4 : POINTER FOR DUPL (THE RETURNED STRING)
;	Q1 : COUNTER FOR INNER LOOP
;	Q2 : INNER LOOP POINTER TO S

DUPLI::	MOVEM	Z,T3		; SAVE N IN T3
	HRRZ	T2,0(STACK)	; SIZE(S) TO T2
	IMUL	Z,T2		; OVERALL LENGTH TO Z
	JUMPG	Z,DUPLI1	; JUMP IF THIS LENGTH EXCEEDS 0
	SUB	STACK,[XWD 2,2]	; POP STACK
	PUSH	STACK,NULLST	; RETURNING ...
	PUSH	STACK,NULLST+1	; NULL STRING
	JRST	1(TLINK)	; NORMAL EXIT

DUPLI1:	MOVEM	Z,T4		; SAVE THIS QUANTITY
	JSP	QLINK,ASBLOK	; ALLOCATE AN SBLOK
	JRST	0(TLINK)	; EXCEEDED &MAXLNGTH
	MOVEM	T4,FLAT##+1	; STORE ULTIMATE LENGTH
	MOVE	Z,-1(STACK)	; TRANSFER DESCR. TOP
	MOVEM	Z,FLAT##	; TO FLAT AREA

	JSP	QLINK,CVTPTR	; CONVERT SBLOK TO POINTER
	0			; NO BASING NEEDED
	ERROR	15,0		; THIS CAN'T HAPPEN
	MOVEM	Z,T4		; SAVE DUPL POINTER IN T4
	JSP	QLINK,CVTPTR	; CONVERT S TO POINTER
	0
	JRST	1(TLINK)	; IF THE STRING IS NULL WE OUGHT
				; TO RETURN THE NULL STRING

;	OUTER LOOP (INITIALIZE VALUES)
DUPLI2:	MOVE	Q1,T2		; COUNTER FOR INNER LOOP IS SIZE(S)
	MOVE	Q2,Z		; POINTER FOR S IS SAVED IN Z

;	INNER LOOP
DUPLI3:	ILDB	Q3,Q2		; PICK UP CHAR. FROM S
	IDPB	Q3,T4		; PUT BYTE INTO DUPL
	SOJG	Q1,DUPLI3	; BRANCH IF Q1 IS STILL POSITIVE
;	INNER LOOP COMPLETED

	SOJG	T3,DUPLI2	; OUTER LOOP BASED ON N

	PUSH	STACK,FLAT##	; LOAD NEW STRING ...
	PUSH	STACK,FLAT##+1	; ONTO STACK ...
	JRST	1(TLINK)	; AND RETURN SUCCESSFULLY
	SUBTTL	EQINIT - INITIALIZATION FOR EQUAL AND LEQUAL

;	 CALLING SEQUENCE:
;
;	PUSH STRING DESCRIPTOR ONTO STACK
;	JSP	TLINK,EQINIT
;	ERROR -		REFLECTS ERROR BY CVTPTR, STACK UNPOPPED
;	NORMAL -		STACK POPPED, THE SAVET AREA IS SET UP AS BELOW
;
;		FLAT&FLAT+1 = ORIGINAL STRING DESCRIPTOR
;		IGNOT = POINTER
;		IGNOT+1 = LENGTH

EQINIT::
	MOVE	Z,-1(STACK)	; SAVE STRING DESCRIPTOR
	MOVEM	Z,FLAT		; IN ...
	MOVE	Z,0(STACK)	; FLAT ...
	MOVEM	Z,FLAT+1	; AREA
	HRRZM	Z,IGNOT##+1	; SAVE LENGTH IN IGNOT AREA
	JSP	QLINK,CVTPTR	; CONVERT STRING TO POINTER
	T2		; BASE ON T2
	JRST	0(TLINK)	; TAKE ERROR EXIT
	MOVEM	Z,IGNOT##	; SAVE POINTER IN IGNOT
	JRST	1(TLINK)	; TAKE NORMAL EXIT
	SUBTTL	EQUAL - TESTS FOR EQUALITY BETWEEN STRINGS

;	 CALLING SEQUENCE:
;
;	PUSH STRING DESCRIPTOR ONTO STACK
;	JSP	TLINK,EQUAL
;	NO	; THE GIVEN STRING IS NOT EQUAL
;	YES	; THE GIVEN STRING IS EQUAL TO THE ONE PREVIOUSLY
;		; PASSED TO EQINIT.

EQUAL::
	HRRZ	T4,0(STACK)	; LENGTH OF STRING TO T2
	CAME	T4,IGNOT+1	; COMPARE WITH OLD LENGTH
	JRST	EQUAL1		; TAKE JUMP IF UNEQUAL

	JSP	QLINK,CVTPTR	; GET POINTER FOR STRING
	0			; NO BASE
	JRST	EQUAL1		; IF NULL, TAKE THIS BRANCH

	MOVE	T2,FLAT		; LOAD BASE FOR OLD STRING
	MOVE	Q1,IGNOT	; LOAD POINTER OF OLD STRING

EQUAL2:	ILDB	Q2,Q1		; LOAD NEXT CHARACTER FROM OLD
	ILDB	Q3,Z		; LOAD NEXT CHARACTER FROM NEW
	CAME	Q2,Q3		; SKIP IF THESE ARE EQUAL
	JRST	0(TLINK)	; TAKE UNEQUAL EXIT
	SOJG	T4,EQUAL2	; GO BACK FOR MORE
	JRST	1(TLINK)	; TAKE SUCCESS EXIT

EQUAL1:	SUB	STACK,[XWD 2,2]	; POP STACK
	JRST	0(TLINK)	; TAKE NOT EQUAL EXIT
	SUBTTL	IDINIT & IDENT

;   CALLING SEQUENCE:
;	PUSH DESCRIPTOR ONTO STACK
;	JSP	TLINK,IDINIT
;	RETURN - FLAT AREA INITIALIZED
;
;	PUSH DESCRIPTOR ONTO STACK
;	JSP	TLINK,IDENT
;	NOT IDENTICAL WITH OTHER DESCRIPTOR
;	IDENTICAL WITH OTHER DESCRIPTOR
;
;	STACK IS POPPED ONE DESCRIPTOR IN ALL 3 CASES

IDINIT::HLRZ	T2,-1(STACK)	; DATATYPE # TO ...
	ANDI	T2,DTNUM	; T2

	CAILE	T2,MAXDTN	; WITHIN RANGE?
	JRST	ID.D2		; NO EXTERNAL.

	JRST	ID.VEC(T2)	; JUMP INTO TABLE

	 ; JUMP TABLE FOR IDINIT

ID.VEC: JRST	ID.D2		; COMPARE BOTH WORDS
	JRST	ID.D2		; INTEGER
	JRST	ID.D2		; REAL
	JRST	ID.STR		; STRING
	JRST	ID.D1		; PATTERN
	JRST	ID.D1		; ARRAY
	JRST	ID.D2		; EXPRESSION
	JRST	ID.D2		; CODE
	JRST	ID.D1		; TABLE
	JRST	ID.D2		; NAME
	JRST	ID.D1		; DEFINED DATATYPE

	 ; COMPARE FIRST WORDS

ID.D1:	JSP	T3,ID.RET	; SET T3 AND RETURN

	 ; HERE ON SUBSEQUENT CALLS

	MOVE	T2,FLAT		; ARE ...
	CAME	T2,-1(STACK)	; FIRST WORDS THE SAME?
	JRST	ID.NO		; NO
	JRST	ID.YES		; YES

	 ; COMPARE TWO WORDS

ID.D2:	JSP	T3,ID.RET

	MOVE	T2,FLAT		; LOAD FIRST WORD
	MOVE	T3,FLAT+1	; AND 2ND WORD
	CAMN	T2,-1(STACK)	; EITHER FIRST ...
	CAME	T3,0(STACK)	; OR 2ND DIFFERENT ...
	JRST	ID.NO		; THEN TAKE THIS BRANCH
	JRST	ID.YES		; OTHERWISE THIS ONE

ID.RET:	MOVEM	T3,IGNOT+2	; SAVE TEST ADDRESS
	POP	STACK,FLAT+1	; SAVE DESCRIPTOR ...
	POP	STACK,FLAT	; FOR SUBSEQUENT TESTS
	JRST	0(TLINK)	; AND RETURN

	 ; NOW WE CAN DEFINE IDENT

IDENT::	JRST	@IGNOT##+2	; JUMP TO PROCESSOR

	 ; RETURN COMES TO EITHER ID.YES OR ID.NO
	 ; EXCEPT FOR STRINGS WHICH IS HANDLED BY EQUAL

ID.NO:	SUB	STACK,[2,,2]	; POP STACK
	JRST	0(TLINK)	; FAIL EXIT

ID.YES:	SUB	STACK,[2,,2]	; POP STACK
	JRST	1(TLINK)	; SUCCESS EXIT

	 ; STRINGS ARE HANDLED HERE

ID.STR:	MOVE	T2,-1(STACK)	; NULL
	CAMN	T2,NULLST	; STRING?
	JRST	ID.D1		; YES

	MOVEI	T3,ID.ST1	; SET 
	MOVEM	T3,IGNOT+2	; COMPARE ADDRESS
	SOJA	TLINK,EQINIT	; THINK ABOUT IT

ID.ST1:	JRST	EQUAL		; LET EQUAL HANDLE THIS
	SUBTTL	LEQUAL - LEXICAL TEST FOR STRINGS

;	 CALLING SEQUENCE:
;
;	PUSH STRING DESCRIPTOR ONTO STACK
;	JSP	TLINK,LEQUAL
;	LESS THAN
;	EQUAL TO
;	GREATER THAN
;
;	THE COMPARISON IS MADE WITH RESPECT TO THE STRING
;	PREVIOUSLY PASSED TO EQINIT

LEQUAL::
	HRRZ	T4,0(STACK)	; LOAD LENGTH OF NEW STRING
	MOVE	T3,T4		; SAVE THIS LENGTH IN T3
	CAMLE	T4,IGNOT+1	; SKIP IF NEW LENGTH LT OLD
	MOVE	T4,IGNOT+1	; MIN. LENGTH TO T4

	JSP	QLINK,CVTPTR	; CONVERT ARG TO POINTER
	0			; NO BASE REGISTER REQUIRED
	JRST	LEQ3		; PROBABLY NULL STRING

	MOVE	T2,FLAT		; BASE OLD STRING POINTER
	MOVE	Q1,IGNOT	; LOAD POINTER OF OLD STRING

;	TOP OF COMPARISON LOOP
LEQ1:	ILDB	Q2,Q1		; LOAD CHRACTER FROM OLD STRING
	ILDB	Q3,Z		; LOAD CHARACTER FROM NEW STRING
	CAME	Q2,Q3		; SKIP IF THESE 2 CHAR. ARE EQUAL
	JRST	LEQ2		; TAKE NON EQUAL CASE.
	SOJG	T4,LEQ1		; LOOP ON T4 (MIN STRING LENGTH)
	SUB	T3,IGNOT+1	; (LENGTH NEW) - (LENGTH OLD) TO T3
	JUMPE	T3,1(TLINK)	; SAME? - TAKE EQUAL EXIT
	JUMPG	T3,2(TLINK)	; GREATER? - TAKE GR TH EXIT
	JRST	0(TLINK)	; ONLY ONE EXIT LEFT - TAKE IT

LEQ2:	SUB	Q3,Q2	; GET DIFFERENCE BETWEEN NEW AND OLD TO Q3
	JUMPG	Q3,2(TLINK)	; TAKE 'GREATER THAN' EXIT
	JRST	0(TLINK)	; OTHERWISE TAKE 'LESS THAN' EXIT

LEQ3:	SUB	STACK,[XWD 2,2]	; BUMP STACK
	JRST	0(TLINK)	; TAKE 'LESS THAN' EXIT
	SUBTTL	STCON - STRING CONSTANT (TO GROWING AREA)

;	CALLING SEQUENCE:
;
;	PUSH STRING DESCRIPTOR ONTO STACK
;	JSP	TLINK,STCON	; INSERT STRING CONSTANT
;	RETURN WITH NEW DESCRIPTOR REPLACING OLD


STCON::	HRRZ	Q2,-1(STACK)	; MAKE SURE ...
	CAMG	Q2,CEIL		; STRING BLOK
	CAMGE	Q2,FLOOR##	; IS IN ...
	JRST	0(TLINK)	; THE FLOATING AREA

	HRRZ	T2,0(STACK)	; GET LENGTH
	CAMLE	T2,STCREM##	; ENOUGH ROOM
	JRST	STCON2		; NO

	JSP	QLINK,CVTPTR	; GET ...
	0			; POINT-
	ERROR	15		; ER

	PUSH	STACK,STCHD##	; LOAD
	MOVE	Q2,STCTOT##	; NEW
	SUB	Q2,STCREM##	; DESCRIP-
	HRL	Q2,Q2		; OR
	HRR	Q2,T2		; ONTO 
	PUSH	STACK,Q2	; STACK

	 ; TOP OF LOOP

STCON1:	ILDB	Q2,Z		; COPY ...
	IDPB	Q2,STCPTR##	; CHARACTER
	SOS	STCREM		; DECREMENT COUNT
	SOJG	T2,STCON1	; LOOP ON LENGTH OF STRING

	JRST	0(TLINK)	; AND RETURN

	 ; HERE IF A NEW SBLOK NEED BE ALLOCATED

STCON2:	ADDI	T2,^D200	; 40 WORDS
	IDIVI	T2,5		; WORD COUNT
	MOVE	Z,T2		; NEEDED LENGTH
	JSP	QLINK,GCOLG##	; ENSURE ROOM
	MOVE	Z,T2		; RESTORE Z
	MOVE	Q2,GSURF##	; SAVE SBLOK ADDR
	ADDM	Z,GSURF		; UPDATE GSURF

	HRLI	Z,SBLOK		; COMPLETE ...
	MOVEM	Z,BTCODE&BLENG(Q2) ; HEADER
	CLEARM	GCFLD(Q2)	; CLEAR FOR HYGIENE

	SUBI	T2,2		; DETERMINE ...
	IMULI	T2,5		; NUMBER OF 
	MOVEM	T2,STCREM	; CHARACH-
	MOVEM	T2,STCTOT	; TERS

	HRLI	Q2,SDT		; MAKE DESCRIP-
	MOVEM	Q2,STCHD	; TOR TOP

	MOVEI	Q2,0(Q2)	; MAKE POINTER
	ADD	Q2,[POINT 7,2]	; TO FIRST ...
	MOVEM	Q2,STCPTR	; BYTE

	JRST	STCON		; RESUME PROCESSING
;	TRIMT - A TYPE T ROUTINE TO TRIM TRAILING BLANKS
; CALLING SEQUENCE
;	PUSH STRING DESCRIPTOR
;	JSP	TLINK,TRIMT
;	RETURN (ARGUMENT REPLACED BY RETURNED VALUE)

TRIMT::	HRRZ	T2,-1(STACK)	; LOAD SBLOK POINTER
	JUMPE	T2,0(TLINK)	; NULL STRING EXIT

	HLRZ	Q1,0(STACK)	; OFFSET
	HRRZ	Q3,0(STACK)	; LENGTH
	ADDI	Q1,0(Q3)	; SUM
	IDIVI	Q1,5		; Q1 - WORDS, Q2 - BYTES
	ADDI	T2,SCHARS(Q1)	; POINT TO WORD
	MOVE	T4,0(T2)	; MOVE WORD TO T4
	MOVE	Q1,Q2		; COPY # OF BYTES OFFSET
	IMULI	Q1,7		; SHIFT THIS MANY BYTES
	LSHC	T3,0(Q1)	; INTO T3

	 ; SEARCH BACKWARDS FOR NONBLANK BY SHIFTING

TRIMT1:	SOJL	Q2,TRIMT2	; IF Q2 IS 0 REFRESH WORD
	CLEAR	T4,		; ZERO OUT TEST WORD
	LSHC	T3,-7		; SHIFT INTO T4 HIGH
	CAME	T4,[ASCII / /]	; BLANK?
	JRST	TRIMT3		; NO - DONE
	SOJG	Q3,TRIMT1	; DECREMENT LENGTH

	 ; STRING WAS ALL BLANK

TRIMT4:	SUB	STACK,[2,,2]	; POP DESCRIPTOR
	PUSH	STACK,NULLST	; RETURN ...
	PUSH	STACK,NULLST+1	; NULL ...
	JRST	0(TLINK)	; STRING

	 ; HERE TO PICK UP PREVIOUS WORD

TRIMT2:	MOVE	T3,-1(T2)	; LOAD PREVIOUS WORD
	LSH	T3,-1		; GET RID OF BIT 35
	MOVEI	Q2,5		; PRIME Q2
	CAME	T3,["     "]	; ALL BLANK?
	SOJA	T2,TRIMT1	; NO - LOOK AT EACH CHAR.

	SUBI	Q3,5		; 5 FEWER BYTES
	JUMPLE	Q3,TRIMT4	; IF NONE LEFT- RETURN NULL

	SOJA	T2,TRIMT2	; LOOP FOR MORE

	 ; WRAP-UP

TRIMT3:	HRRM	Q3,0(STACK)	; PLUG LENGTH
	JRST	0(TLINK)	; RETURN
	END
nM!\E