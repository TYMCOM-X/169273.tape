	SUBTTL	Gimpel--Ma355/JDS/DRH/MP/RCM/VB		15-Jun-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	UUOSYM		;TOPS10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	NUMVER==5		;MAJOR VERSION NUMBER
	NUMMIN==0		;MINOR VERSION NUMBER
	NUMEDT==151		;EDIT LEVEL
	NUMWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	NUM,SNONUM,<Numeric Routines>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%UUOS		;VERSION NUMBER OF UUOSYM
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	NUMTTL			; Title
	NUMPTX			; PASS2 assembly message
	SUBTTL	Table of Contents

;		Table of Contents for Numeric Routines
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. INTRODUCTION . . . . . . . . . . . . . . . . . . . . .    4
;   4. NUMCOM . . . . . . . . . . . . . . . . . . . . . . . .    5
;   5. NUMOP. . . . . . . . . . . . . . . . . . . . . . . . .    9
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
151	INTEGER(3.0) doesn't fail, make it.
\
	SUBTTL	INTRODUCTION
;THIS MODULES CONTAINS ALL ARITHMETIC ROUTINES FOR SITBOL.  IT
;IS BROKEN UP INTO TWO PARTS:
;	1)NUMCOM -- NUMERIC COMPARISON ROUTINES
;		 -- EQ,NE,GE,LE,GT,LT
;		-- REMDR, INTEGER, RANDOM

;	2)NUMOP  -- NUMERIC AND ARITHMETIC OPERATIONS
;		 -- PLUS,MINUS,EXP,MUL,DIV,SUM,DIFF

;THE TWO BUILT-IN FUNCTIONS 'REMDR' AND 'INTEGER' ARE IN
;NUMCOM.
SUBTTL	NUMCOM	--NUMERIC COMPARISON ROUTINES

GE::	MOVSI	S1,(CAMGE P2,)	;SETUP CORRECT COMPARE.
	JRST	DOCOM		;AND GO DO COMPARE

LE::	MOVSI	S1,(CAMLE P2,)	;COMPARE LESS THAN
	JRST	DOCOM		;AND GO TO COMPARE ROUTINE

GT::	MOVSI	S1,(CAMG P2,)	;COMPARE GT
	JRST	DOCOM

LT::	MOVSI	S1,(CAML P2,)	;LESS THAN
	JRST	DOCOM


EQ::	MOVSI	S1,(CAME P2,)	;CHECK FOR EQUALITY
	JRST	DOCOM		;AND TO COMPARE

NE::	MOVSI	S1,(CAMN P2,)	;CHECK FOR INEQUALITY
	JRST	DOCOM
;DOCOM IS THE ROUTINE THAT DOES THE ACTUALLY CONDITION CHECKING
;ON THE COMPARISON PREDICATES.  IT CALLS 'GTSAM2', JUST TO GET 
;LIKE DATA-TYPES WITHOUT REGARD FOR WHAT THEY ARE.

DOCOM:	JSP	QLINK,GTSAM2	;GET LIKE DATA TYPES
	ERROR	15		; CAN'T HAPPEN
	JFCL			;IGNORE INTEGER RETURN
	XCT	S1		;DO THE COMPARISON
	JRST	0(PLINK)	;CONDITION NOT SATISFIED
	JRST	RETNUL##	;CONDITION SATISFIED--
				; RETURN A NULL

;GTSAM2--ROUTINE TO CONVERT TWO ARGS ON THE STACK TO THE
;SAME NUMERIC FORM.  AN ATTEMPT IS MADE TO CONVERT TO NUMERIC
;OHTERWISE THEY WILL BE CONVERTED TO REAL.

;CALLING SEQUENCE:	JSP QLINK,GTSAM2
;			  ERROR RETURN
;			  INTEGER RETURN
;			  REAL RETURN

;ON RETURN:	P2 CONTAINS FIRST ARGUMENT
;		Z  CONTAINS SECOND ARGUMENT
;		S2 CONTAINS A DESCRIPTOR HEADER FOR THE RESULT.
;	     ***STACK IS POP'ED***

GTSAM2:	CLEAR	Z,		;A LOOP FLAG
	MOVE	S2,-1(STACK)	;GET TYPE OF SECOND ARG
GTSAM3:	AND	S2,-3(STACK)	;AND IT WITH FIRST TYPE
	MOVEM	QLINK,IGNOP##	;SAVE THIS
	TLNN	S2,NUMDC	;BOTH NUMERIC?
	JRST	GTSM2A		;NO--MAKE THEM BOTH REAL
	TLNE	S2,IDT-NUMDC	;BOTH INTEGERS?
	JRST	GOTINT		;YES
	TLNE	S2,RDT-NUMDC	;BOTH REAL?
	JRST	GOTRL		;YES GO HANDLE IT
	SKIPE	Z		;FIRST TIME THRU
	JRST	GTSAM4		;NO, GO TO REAL
GTSM2A:	JSP	TLINK,CVTNUM##	;CONVERT SECOND ARG TO NUMERIC
	ERROR.	1,28		; BAD 2ND ARG
	POP	STACK,S3	;POP OFF SECOND ARG
	POP	STACK,S2	;GET THE DESCRIPTOR
	JSP	TLINK,CVTNUM	;CONVERT FIRST ARG TO NUMERIC
	ERROR.	1,27		; BAD 1ST ARG
	PUSH	STACK,S2	;PUT SECOND ARG BACK ON
	PUSH	STACK,S3	;STACK, AND
	SETO	Z,		;SET SECOND TIME AROUND
	MOVE	QLINK,IGNOP##	;RESTORE QLINK
	JRST	GTSAM3		;AND TRY AGAIN

GTSAM4:	JSP	TLINK,CVTRL##	;TRY TO GO TO REAL
	  JRST	0(QLINK)	;NO CONVERSION
	POP	STACK,S3	;POP OFF SEC ARG
	POP	STACK,S2
	JSP	TLINK,CVTRL	;AND CONVERT FIRST ARG
	  JRST	0(QLINK)	;CAN'T CONVERT
	MOVE	Z,S3		;SECOND ARG IN Z
	MOVE	QLINK,IGNOP##	;RESTORE QLINK
	AOJ	QLINK,		;DOUBLE SKIP MEANS AOS ONCE AND THEN
	AOJA	QLINK,GOTFST	;AOS QLINK AND FINISH THE JOB

GOTRL:	AOJ	QLINK,		;SKIP RETURN
GOTINT:	AOJ	QLINK,		;FOR INTEGER RETUNR
	POP	STACK,Z		;SECOND ARG IN Z
	POP	STACK,S2	;DESCRIPTOR IN S2
GOTFST:	POP	STACK,P2	;FIRST ARG IN P2
	POP	STACK,(STACK)	;CLEAR THE STACK
	JRST	0(QLINK)	;AND TAKE INTEGER RETURN
;HERE ARE THE 'REMDR' AND 'INTEGER' BUILT INS
; AND ALSO 'RANDOM'

REMDR::	JSP	TLINK,CVTINT##	;CONVERT SEC ARG TO INT
	ERROR.	1,84		;CAN'T DO
	POP	STACK,P2	;GET SEC ARG IN P2
	POP	STACK,(STACK)	;AND FORGET THIS
	JSP	TLINK,CVTINT	;CONVERT FIRST ARG TO INT
	ERROR.	1,85
	POP	STACK,S2	;GET FIRST ARG IN S2
	SKIPN	P2		;CANT DIV BY ZERO
	ERROR	10,15
	IDIV	S2,P2		;DO THE DIVIDE
	MOVSI	S2,IDT		;INTEGER
	MOVEM	S2,(STACK)	;PUT ON STACK
	PUSH	STACK,S2+1	;STACK THE REMAINDER
	JRST	1(PLINK)	;AND RETURN

INTGR::	JSP	TLINK,CVTNUM##	;[151] Make sure its integral
	  JRST	FRET1		;[151] Its not -- Fail
	HLRZ	Q1,-1(STACK)	;[151] Get the datatype
	CAIE	Q1,IDT		;[151] Must be integer
	JRST	FRET1##		;ITS NOT -- FAIL
	JRST	RETNL1##	;RETURN THE NULL


RAND::	JSP	TLINK,CVTINT	; ENSURE AN
	ERROR.	1,82		; INTEGER

	 ; GENERATOR OBTAINED FROM JACM 14:1,110

	AOSG	S2,$RAND##	; PICK UP OLD...
	MOVEI	S2,1		; + 1
	IMUL	S2,[273673163155]	; APPLY MULTIPLIER
	MOVEM	S2,$RAND	; SAVE RESULT

	LSH	S2,1		; REMOVE SIGN
	MOVEI	S1,200		; NO POWER OF 2
	LSHC	S1,-9		; SHIFT EXPONENT IN
	FSC	S2,0		; AND NORMALIZE

	SKIPE	0(STACK)	; REQUESTED REAL?
	JRST	RANDI		; NO, INTEGER

	MOVSI	Q1,RDT		; INDICATE ...
	MOVEM	Q1,-1(STACK)	; DATATYPE
	MOVEM	S2,0(STACK)	; SET VALUE
	JRST	1(PLINK)	; AND RETURN

RANDI:	 ; HERE TO PRODUCE AN INTEGER

	SKIPL	0(STACK)	; TEST FOR NEG ARG
	JSP	TLINK,CVTRL	; MAKE A REAL
	ERROR	13,47		; FAIL RET CAN'T HAPPEN

	FMPL	S2,0(STACK)	; DO THE MULTIPLY
	MOVEM	S2,0(STACK)	; STORE RESULT ON STACK
	JSP	TLINK,CVTINT	; MAKE AN INTEGER
	ERROR	13,47		; THIS WON'T HAPPEN

	AOS	0(STACK)	; NEED 1 MORE
	JRST	1(PLINK)	; AND RETURN
SUBTTL	NUMOP	ARITHMETIC OPERATIONS


;FIRST THE BINARY OPERATIONS

;SUM,DIFF,MUL,DIV,EXP


;ADDITION
SUM::	JSP	QLINK,GTSAM2	;GET LIKE DATA TYPES
	ERROR	15		; CAN'T HAPPEN
	JRST	SUMINT		;AND TWO INTEGER

SUMRL:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,2)]
	FADR	P2,Z		;DO THE ADD
	JRST	BINRET		;COMMON BIN OP RETURN

SUMINT:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,7)]
	ADD	P2,Z		;AND THEM
	JRST	BINRET		;AND RETURN


;SUBTRACTION
DIFF::	JSP	QLINK,GTSAM2	;GET A MATCHED SET
	ERROR	15		; CAN'T HAPPEN
	JRST	DIFINT		;INTEGERS

DIFRL:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,2)]
	FSBR	P2,Z		;SUBTACT THEM
	JRST	BINRET		;AND RETURN

DIFINT:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,8)]
	SUB	P2,Z		;SUBTRACT THEM
	JRST	BINRET
;MULTIPLICATION
MUL::	JSP	QLINK,GTSAM2	;GET LIKE DATA TYPES
	ERROR	15		; CAN'T HAPPEN
	JRST	MULINT		;INTEGERS

MULRL:	JFCL	17,.+1	;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,2)]
	FMPR	P2,Z		;DO THE MULTIPLY
	JRST	BINRET		;AND RETURN

MULINT:	JFCL	17,.+1		;CLEAR FLAGS
	MOVE	T1,[ERROR (10,9)]
	IMUL	P2,Z		;DO THE MULTIPLY
	JRST	BINRET


;DIVISION
DIV::	JSP	QLINK,GTSAM2	;GET LIKE DATATYPES
	ERROR	15		; CAN'T HAPPEN
	JRST	DIVINT

DIVRL:	SKIPN	Z		;IS  DIVISOR ZERO?
	ERROR	10,3		;YES
	JFCL	17,.+1
	MOVE	T1,[ERROR (10,2)]
	FDVR	P2,Z		;DO THE DIVIDE
	JRST	BINRET

DIVINT:	SKIPN	Z		;IS DIVISOR ZERO?
	ERROR	10,6		;YES
	JFCL	17,.+1
	MOVE	T1,[ERROR (10,6)]	;THIS SHOULDN'T HAPPEN
	IDIV	P2,Z		;DIVIDE
	JRST	BINRET
;NOW THE EXPONENTIATION ROUTINE
;COMMENTS REFER TO  A ** B
;USING THIS ALGORITHM, THE NUMBER OF MULTIPLICATIONS
;IS LESS THAN 2LOG(2) B


EXP::	JSP	TLINK,CVTINT	;CONVERT B TO INTEGER
	ERROR.	1,30		; BAD ARG
	POP	STACK,NUMSTR##	;GET B
	POP	STACK,(STACK)	;IGNORE THIS

EXP1:	JSP	TLINK,CVTNUM	;CONVERT A TO NUMERIC
	ERROR.	1,29		;HE LOSES
	POP	STACK,S1	;A GOES IN S1
	POP	STACK,S3	;ITS DESCRIPTOR IN S3
	MOVEI	S2,1		;SETUP FOR MULTIPLY
	TLNE	S3,RDT-NUMDC	;REAL?
	MOVSI	S2,201400	;YES MAKE IT 1.0

EXP2:	MOVE	Q1,NUMSTR	;GET B BACK
	JFFO	Q1,EXP2A	;GET HIGH ORDER BIT OF B
	JRST	EXPZR		;A ** 0 = 1
EXP2A:	TLNE	S3,RDT-NUMDC	;IS A REAL?
	CAME	S1,[201400,,0]	;YES COMPARE AGAINST 1.0
	CAIN	S1,1		;IF INTEGER COMPARE AGAINST 1
	JRST	EXPZR		;1 ** X = 1
	MOVEI	P2,1		;SETUP A MARKER
	MOVNS	Q2		;NEG NUMBER OF LEADING ZEROES
	ADDI	Q2,^D35		;PLUS 35
	LSH	P2,(Q2)		;SETUP A MARKER
	MOVEI	Q2,1		;AND A CURSOR

EXP3:	JFCL	17,.+1		;CLEAR ALL FLAGS
EXP30:	CAMN	P2,Q2		;DONE YET?
	JRST	EXPDON		;YES FINISH UP
	TLNE	S3,RDT-NUMDC	;A REAL?
	JRST	EXP4		;YES! USE FMPR'S
	TDNE	Q1,Q2		;IS CURRENT BIT 1?
	IMUL	S2,S1		;YES! SAVE THIS ONE
	IMUL	S1,S1		;AND SQUARE THIS
	JRST	EXP3A		;SETUP FOR NEXT LOOP

EXP4:	TDNE	Q1,Q2		;IS CURRENT BIT A 1?
	FMPR	S2,S1		;YES SAVE THIS MUL
	FMPR	S1,S1		;AND SQUARE THIS

EXP3A:	LSH	Q2,1		;SETUP CURSOR FOR NEXT BIT
	JOV	[ERROR (10,5)]	;OVERFLOW?
	JRST	EXP30		;GO BACK FOR MORE
;MORE EXPONENTIATION

EXPDON:	JFCL	17,.+1		;CLEAR ALL FLAGS
	TLNE	S3,RDT-NUMDC	;IS A REAL?
	JRST	EXPDN1		;YES
	IMUL	S2,S1		;FINAL PRODUCT
	JRST	EXPRET		;STACK AND RETURN

EXPDN1:	FMPR	S2,S1		;FINAL REAL PRODUCT

EXPRET:	JOV	[ERROR (10,5)]	;OVERFLOW?
	PUSH	STACK,S3	;PUSH THE DESCRIPTOR
	PUSH	STACK,S2	;AND THE ANSWER
	JRST	1(PLINK)	;AND RETURN

EXPZR:	MOVEI	S2,1		;ANSWER IS 1
	TLNE	S3,RDT-NUMDC	;IF A IS REAL,
	MOVSI	S2,201400	;ITS 1.0
	JRST	EXPRET+1	;AND RETURN
;HERE ARE THE TWO UNARY ROUTINES PLUS AND MINUS

PLUS::	JSP	TLINK,CVTNUM	;CONVERT ARG TO NUMERIC
	ERROR.	1,33		;CONVERSION FAILED
	JRST	1(PLINK)	;RETURN


MINUS::	JSP	TLINK,CVTNUM	;CONVERT TO NUMERIC
	ERROR.	1,34		;CAN'T CONVERT
	MOVE	P2,0(STACK)	;GET THE VALUE
	CAMN	P2,[400000,,0]	;IF LARGEST NEGATIVE NUMBER,
	ERROR	10,14		;THEN WE CAN'T CONVERT
	MOVNM	P2,0(STACK)	;TAKE THE NEGATIVE
	JRST	1(PLINK)	;AND RETURN
;COMMON RETURN FOR ALL BINARY OPERATIONS

BINRET:	JOV	.+2		;SKIP IF OVERFLOW SET
	SKIPA			;SKIP ERROR JUMP
	JRST	T1		;JUMP TO ERROR ALREADY SETUP IN T1

	PUSH	STACK,S2	;PUT THE DESCRIPTOR ON THE STACK
	PUSH	STACK,P2	;PUT RESULT ON STACK
	JRST	1(PLINK)	;AND RETURN NORMALLY


NUMEND:	END
   