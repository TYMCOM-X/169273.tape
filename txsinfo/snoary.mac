	SUBTTL	Gimpel--Ma355/JDS/DRH/MP/RCM/VB		15-Jun-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	UUOSYM		;TOPS10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	ARYVER==5		;MAJOR VERSION NUMBER
	ARYMIN==0		;MINOR VERSION NUMBER
	ARYEDT==263		;EDIT LEVEL
	ARYWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	ARY,SNOARY,<Arrays>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%UUOS		;VERSION NUMBER OF UUOSYM
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	ARYTTL			; Title
	ARYPTX			; PASS2 assembly message
	SUBTTL	Table of Contents

;		Table of Contents for Arrays
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. ARRAY(P,V) . . . . . . . . . . . . . . . . . . . . . .    4
;   4. ARY - SECONDARY ROUTINE TO ALLOCATE THE ARRAY. . . . .    5
;   5. ITEM - THE ARRAY REFERENCE . . . . . . . . . . . . . .    6
;   6. PROTOTYPE. . . . . . . . . . . . . . . . . . . . . . .    7
;   7. COPY . . . . . . . . . . . . . . . . . . . . . . . . .    8
;   8. SORTING ROUTINES . . . . . . . . . . . . . . . . . . .    9
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
147	Clean up how Y.???? and X.???? are used (use TX?? instead or
	TD?? OR MOVX instead of MOVE)
262	Fix a HALT when sorting an array with defined data types, a key
	and the array was not full, so it contained null strings.
263	Use XWD22 instead of [2,,2]
\
	SUBTTL	ARRAY(P,V)

ARRAY::	POP	STACK,FLAP##+1	; SAVE ...
	POP	STACK,FLAP##	; 2ND ARGUMENT

	JSP	SLINK,ARY	; ALLOCATE THE ARRAY

	MOVE	P2,-1(STACK)	; ADDRESS OF ARRAY
	HRRZ	S1,NSUBS(P2)	; BUMP
	LSH	S1,1		; OVER DIM ...
	ADD	P2,S1		; INFO

	MOVE	T1,FLAP##	; RELOAD ...
	MOVE	T2,FLAP##+1	; 2ND ARG.
	MOVEM	T1,SUBFAC(P2)	; AND PLUNK INTO ...
	MOVEM	T2,SUBFAC+1(P2) ; FIRST ARRAY ELEMENT

	HRRZI	Q1,SUBFAC+2(P2)	; POINT TO 2ND ELEMENT
	HRRZ	Q2,-1(STACK)	; ADDRESS OF ABLOK
	ADD	Q2,BLENG(Q2)	; ADDRESS JUST BEYOND ABLOK
	CAILE	Q1,-1(Q2)	; IS THERE A 2ND ELEMENT?
	JRST	1(PLINK)	; NO

	HRLI	Q1,SUBFAC(P2)	; 'FROM' ADDRESS
	BLT	Q1,0(Q2)	; SPRAY DESCRIPTOR
	JRST	1(PLINK)	; AND RETURN
	SUBTTL	ARY - SECONDARY ROUTINE TO ALLOCATE THE ARRAY

	 ; ARY - A TYPE S UTILITY TO ALLOCATE AN ARRAY
	 ; CALLING SEQUENCE:
	 ;	PUSH PROTOTYPE ONTO STACK
	 ; 	JSP	SLINK,ARY
	 ;	RETURN	; ARRAY DESCRIPTOR REPLACES PROTOTYPE

ARY::	POP	STACK,FLAS##+1	; SAVE ...
	POP	STACK,FLAS##	; PROTOTYPE	

	PUSHR	PS		; FREE UP SOME REGISTERS

	PUSH	STACK,FLAS##	; RESTORE ...
	PUSH	STACK,FLAS##+1	; PROTOTYPE

	NS==P1			; NUMBER OF SUBSCRIPTS
	SZ==P2			; SIZE OF ARRAY
	LB==S1			; LOWER BOUND

	 ; INITIALIZE PARAMETERS

	CLEAR	NS,		; NO SUBSCRIPTS SO FAR
	MOVEI	SZ,2		; INITIAL SIZE
	MOVEI	LB,1		; TENTATIVE LOWER BOUND
	CLEARM	CURSOR##	; TEST FOR DONENESS

	 ; TEST TUPE OF PROTOTYPE

	MOVE	Z,-1(STACK)	; IS IT ...
	TLNE	Z,NUMDC	; NUIMERIC?
	JRST	ARY2		; YES - SKIP THE HJORSE PLAY

	 ; INITIALIZE FOR SCANNING THE STRING

	JSP	TLINK,CVTSTR##	; ENSURE A STRING
	ERROR.	1,54		; NO?
	JSP	TLINK,STINIT##	; PREPARE T;O STREAM
	ERROR	13,22		; NULL STRING

	 ; SCAN FOR LOWER BOUND

ARY1:	MOVEI	LB,1		; DEFAULT LOWER BOUND

	MOVE	S2,SYSCT##	; STREAM ...
	MOVX	S3,Y.CM!Y.COL	; FOR ...
	JSP	TLINK,STRM##	; COMMA OR COLON
	JRST	ARY2		; RUNNOUT!

	SOS	CURSOR##	; INCREMENT PAST
	IBP	STPTR##		; BREAK CHAR.

	CAIE	Q2,":"		; WAS IT COLON
	JRST	ARY2		; NO - WAS UPPER BOUND

	JSP	TLINK,CVTINT##	; GET INTEGER
	ERROR	13,24		; HE'S GIVING US JUNK
	MOVE	LB,0(STACK)	; LOAD THE LOWER BOUND
	SUB	STACK,XWD22##	;[263] POP THE STACK

	 ; PROCESS THE UPER BOUND

	MOVX	S3,Y.CM		; SCAN FOR ...
	JSP	TLINK,STRM	; COMMA
	JRST	ARY2		; RUNNOUT

	SOS	CURSOR		; GET PAST ...
	IBP	STPTR		; THE COMMA

	 ; HERE FROM NO COLON CASE & RUNNOUTS

ARY2:	JSP	TLINK,CVTINT	; GET THE INTEGER
	ERROR	13,24		; BAD VALUE

	 ; COMPUTE DIMENSIONALITY

	AOS	T1,0(STACK)	; LOAD THE UPPER BOUND + 1
	SUB	T1,LB		; DETERMINE EXTENT
	CAIG	T1,777777	; GREATER THAN 2**18
	CAIG	T1,0		; OR LESS THAN 1
	ERROR	13,27		; GIVE A MESSAGE

	IMUL	SZ,T1		; ACCUMULATE TOTAL SIZE
	AOJ	NS,		; ADD 1 FOR SUBSCRIPT

	HRL	T1,LB		; PACK IN THE LOWER BOUND
	MOVEM	T1,0(STACK)	; AND PUT IT ON THE STACK

	SKIPE	CURSOR		; TEST FOR COMPLETION
	JRST	ARY1		; NOT DONE YET
	 ; PASS II TO ARY
	 ; THE DIMENSION INFORMATION HAS BEEN GATHWRED

	 ; COMPUTE SIZE OF ARRAY AND ENSURE STORAE

	MOVE	Z,NS		; TWICE THE ...
	LSH	Z,1		; NUMBER OF SUBSCRIPTS
	ADDI	Z,SUBFAC(SZ)	; PLUS THE REST

	SKIPE	GRFLAG		; DOES HE WANT GR?
	JSP	QLINK,GCOLG##	; YES, BUT ALSO GIVE HIM
	JSP	QLINK,GCOLF##	; ENSURE THIS MUCH STORAGE
	MOVEM	Z,T4		; SAVE SIZE

	SKIPE	GRFLAG		; INTO GROWING STORE?
	EXCH	SURF,GSURF##	; YES

	 ; FILL IN THE TOP OF THE ARRAY

	HRLI	Z,ABLOK		; PREPARE
	MOVEM	Z,BTCODE&BLENG(SURF)	; FIRST WORD
	CLEARM	GCFLD(SURF)	; ZERO GC WORD

	AOS	T3,ARYID##	; TRANSFER NEXT ID #
	HRL	T3,NS		; AND NUMBER OF SUBSCRIPTS
	MOVSM	T3,AHASH&NSUBS(SURF) ; INTO ABLOK

	HRLI	Z,FLAS		; MOVE ...
	HRRI	Z,APROTO(SURF)	; PROTO;TYPE
	BLT	Z,APROTO+1(SURF)	; IN ABLOK

	ADD	SURF,NS		; BUMP SURF BY TWICE THE ...
	ADD	SURF,NS		; SUBSCRIPT COUNT (-1)
	MOVEI	S3,2		; MULTIPLIER HELD HERE

	 ; TOP OF LOOP FOR INSERTING BUNDS

ARY4:	SUBI	SURF,2		; READY FOR NEXT SUBSCRIPT
	MOVE	Q1,0(STACK)	; GET LB - DIM
	MOVEM	Q1,SUBLBD&SUBDIM(SURF) ; WORD
	SUB	STACK,XWD22##	;[263] AND POP STACK

	MOVEM	S3,SUBFAC(SURF)	; INSERT THE FACTOR
	IMULI	S3,0(Q1)	; COMPUTE THE NEXT FACTOR
	SOJG	NS,ARY4		; LOOP ON SUBSCRIPT COUNT

	 ; FALL THRU TO RETURN

	POPR	PS		; RESTORE REGISTERS

	MOVE	T3,SURF		; CREATE
	HRLI	T3,ADT		; AN ...
	PUSH	STACK,T3	; ARRAY
	PUSH	STACK,[0]	; DESCRIPTOR

	HRRZ	T3,BLENG(T3) 	; GET LENGTH OF ABLOK
	ADD	SURF,T3		; INCREMENT PAST BLOK

	SKIPE	GRFLAG##	; WENT INTO GROWING?
	EXCH	SURF,GSURF	; YES, RESTORE
	JRST	0(SLINK)	; AND RETURN
	SUBTTL	ITEM - THE ARRAY REFERENCE


	 ; TEST FOR ARRAY

ITEM::	MOVE	S2,Z		; # OF ...
	SUBI	S2,1		; SUBSCRIPTS-1 ...
	LSH	S2,1		; DOUBLED TO S2

	HRRZ	P2,STACK	; POINT TO TOP STACK ITEM
	SUB	P2,S2		; POINT TOFIRST ARG

	HLRZ	S1,-1(P2)	; GET DT
	CAIE	S1,ADT		; ARRAY?
	JRST	TITEM##		; NO

	 ; CHECK FOR CORRECT # OF SUBSCRIPTS

	MOVE	P2,-1(P2)	; POINT TO ARRAY
	HRRZ	S3,NSUBS(P2)	; LOAD SUBSCRIPT COUNT
	CAIE	Z,1(S3)		; 1 LESS THAN ARG COUNT
	ERROR	3,3		; NO - BAD NUMBER

	MOVEI	S1,SUBFAC(S2)	; JCOMPUTING OFFSET IN S1

	ADD	P2,S2		; POINT JUST ABOVE DIM INFO

	 ; LOP FOR FIGURING ADDRESS

ITEM1:	JSP	TLINK,CVTINT##	; ENSURE AN INTEGER
	ERROR	3,4		; MUST BE INTEGER

	SUBI	P2,2		; POINT TO NEXT DIM. INFO
	MOVE	T1,SUBLBD&SUBDIM(P2) ; LOAD LBD & DIM
	HLRE	T2,T1		; (POSS. NEG.) LBD TO T2
	MOVE	T3,0(STACK)	; RETRIEVE SUBSCRIPT
	SUB	STACK,XWD22##	;[263] POP SUBSCRIPT
	SUB	T3,T2		; I - LBD

	CAIL	T3,0		; CANNOT BE LESS THAN 0
	CAIL	T3,0(T1)	; NOR AS LARGE AS DIM.
	JRST	ITEMF		; GO FAIL

	IMUL	T3,SUBFAC(P2)	; ASSERT MULTIPLIER
	ADD	S1,T3		; ADD THIS TO TOTAL

	SOJG	S3,ITEM1	; LOOP ON # OF SUBSCRIPTS

	 ; FINAL WRAP-UP

	MOVEI	P2,VAR		; INSERT VAR
	HRLM	P2,-1(STACK)	; AS DESCR TYPE

	MOVEM	S1,0(STACK)	; INSERT COMPUTED OFFSET

	JRST	1(PLINK)	; AND RETURN

	 ; HERE ON FAILURE

ITEMF:	LSH	S3,1		; POP ...
	HRL	S3,S3		; STACK ...
	SUB	STACK,S3	; BY # OF REMAINING ...
	JRST	0(PLINK)	; SUBSCRIPTS (PLUS ONE).

	SUBTTL	PROTOTYPE

PROTO::	HLRZ	S1,-1(STACK)	; GET DATATYPE
	MOVE	P2,-1(STACK)	; LOAD ADDR OF OBJECT
	CAIE	S1,ADT		;  ARRAY?
	JRST	PROTO1		; NO

	SUB	STACK,XWD22##	;[263] POP ARGUMENT
	PUSH	STACK,APROTO(P2)	; PUSH ...
	PUSH	STACK,APROTO+1(P2)	; PROTOTYUPE
	JRST	1(PLINK)		; AND RETURN

PROTO1:	CAIE	S1,TDT		; TABLE?
	ERROR.	1,83		; NO - ERROR

	SUB	STACK,XWD22##	;[263] POP ITEM
	MOVSI	S2,IDT		; RETURN THE ...
	PUSH	STACK,S2	; NUMBER OF ...
	HRRZ	T1,TNBUCK(P2)	; PUSH NUMBER
	PUSH	STACK,T1	; OF BUCKETS.
	JRST	1(PLINK)	; AS PROTOTYPE
	SUBTTL	COPY

COPY0::	MOVEI	TLINK,1(PLINK)

	 ; TYPE T ROUTINE TO DO THE COPYING
	 ;	(NO ERROR EXIT)

COPY::	HLRZ	T3,-1(STACK)	; GET DATA TYPE
	CAIN	T3,ADT		; ARRAY?
	JRST	COPYA		; YES

	CAIE	T3,DDT		; DEFINED DATA
	JRST	0(TLINK)	; NO - RETURN ELEMENT

	AOS	T4,DFDID##	; NEXT ID NUMBER
	MOVEI	T2,DHASH	; POINT TO ID FIELD
	JRST	COPYC		; JOIN COMMON PROCESSING

COPYA:	AOS	T4,ARYID	; GET ID NUMBER FOR ARRAY
	MOVEI	T2,AHASH	; POINT TO HASH FIELD

COPYC:	HRRZ	T3,-1(STACK)	; LOAD ADDR OF OBJECT
	HRRZ	Z,BLENG(T3)	; LOAD LENGTH OF BLOK
	JSP	QLINK,GCOLF##	; ENSURE THIS MUCH SPACE

	HRRZ	T3,-1(STACK)	; LOAD ADDR OF OBJECT AGAIN
	HRLZ	Z,T3		; 'FROM' ADDRESS
	HRR	Z,SURF		; 'TO' ADDRESS
	HRRZ	T3,BLENG(T3)	; GET THE LENGTH
	ADD	T3,SURF		; POINT BEYOND BLOK
	BLT	Z,-1(T3)	; DO THE MOVE

	HRRM	SURF,-1(STACK)	; STORE NEW BASE ADDRESS
	CLEARM	GCFLD(SURF)	; CLEAR THIS IN CASE
	ADD	SURF,T2		; POINT TO ID FIELD
	HRLM	T4,0(SURF)	; INSERT ID #

	HRRZ	SURF,T3		; UPDATE SURF
	JRST	0(TLINK)	; AND RETURN

	SUBTTL	SORTING ROUTINES

	 ;	SORT
	 ; PRIMARY ROUTINE TO SORT AN ARRAY OR TABLE

SORT::	CLEARM	IGNOP##		; FLAG ENTRY
	JRST	SORTC		; JOIN COMMON PROCESSING

	 ; RSORT

	 ; PRIMARY ROUTINE TO DO A REVERSE SORT

RSORT::	SETOM	IGNOP##

SORTC:	HLRZ	T1,-3(STACK)	; IS FIRT ARG ...
	CAIE	T1,TDT		; A TABLE?
	JRST	SORTA		; NO

	JSP	TLINK,CVTINT	; GET THE INTEGER
	ERROR.	1,93		; CAN'T BE OTHERWISE

	SKIPN	P2,0(STACK)	; LOAD INTEGER
	MOVEI	P2,1		; DEFAULT IS 1

	SUB	STACK,XWD22##	;[263] POP STACK
	JSP	SLINK,CVTARY##	; CONVERT TO ARRAY
	JRST	FRET1##		; FAIL IF NULL TABLE

	PUSH	STACK,[IDT,,0]	; REPLACE ORIGINAL ...
	PUSH	STACK,P2	; ARGUMENT
	JRST	SORTC		; AND GO BACK TO START

SORTA:	MOVEI	Q3,-3(STACK)	; POINT TO BADNESS
	CAIE	T1,ADT		; AN ARRAY?
	ERROR%	1,92		; NO - BAD TYPE

	MOVE	T2,-3(STACK)	; DETERMINE
	HRRZ	P2,NSUBS(T2)	; NUMBER OF DIMENSIONS
	SUBI	P2,2		; MAKE NUMBER TESTABLE
	ASH	P2,1		; DOUBLE IT
	SKIPLE	P2		; IS NUMBER GT 2?
	ERROR	13,42		; YES, ERROR

	SETZB	S1,S3		;[262] Set the offset to zero tentatively
				;[262]  and signal no field function

	JSP	TLINK,CVTINT	; 2ND ARG INTEGER
	 JRST	SORTA1		; NO, TRY FIELD REF

	SUB	STACK,XWD22##	;[263] POP STACK
	JUMPL	P2,SORTB	; JUMP IF DIMENSION IS 1

	MOVE	S1,2(STACK)	; LOAD 2ND ARG
	MOVE	T2,-1(STACK)	; LOAD ARRAY ADDR
	HLRZ	Q1,SUBLBD+2(T2)	; LOAD LOWER BOUND
	SUB	S1,Q1		; SUBTRACT FROM ARGUMENT
	HRRZ	Q2,SUBDIM+2(T2)	; LOAD RANGE SIZE
	CAMGE	S1,Q2		; SKIP IF TOO BIG
	SKIPGE	S1		; FALL THRU IF TOO SMALL
	ERROR	13,43		; AND GIVE THIS ERROR

	ASH	S1,1		; DOUBLE IT TO GIVE OFFSET
	JRST	SORTB		; JOIN OTHER PROCESSING

	 ; HERE IF 2ND ARG WAS NOT INTEGER

SORTA1:	SKIPL	P2		; IF THE # OF DIMS. IS 2, WE ...
	ERROR.	1,99		; CAN'T USE A FIELD NAME
	JSP	TLINK,CVTNAM##	; GET THE NAME
	ERROR.	1,100		; BAD DATATYPE
	SKIPE	0(STACK)	; NATURAL VARIABLE?
	ERROR	13,44		; NO - GIVE ERROR

	HRRZ	S3,-1(STACK)	; GET VB ADDR
	SUB	STACK,XWD22##	;[263] AND POP STACK
	HRRZ	Q1,VFUNC(S3)	; CHECK TO MAKE ...
	HLRZ	Q2,BTCODE(Q1)	; SURE THAT THE NAME
	CAIE	Q2,FFBLOK	; IS THE NAME OF
	ERROR	13,44		; A FIELD FUNCTION

	 ; RESUME COMMON PROCESSING

SORTB:	MOVE	Z,-1(STACK)	; SAVE ORIGINAL
	MOVEM	Z,FLAP		; ARRAY
	JSP	TLINK,COPY	; AND COPY IT

	MOVE	T2,FLAP		; DETERMINE ...
	MOVE	S2,SUBFAC(T2)	; ADDRESSING WIDTH OF ...
	MOVEM	S2,IGNOP+1	; ARRAY AND SAVE IT.

	HRRZ	Z,SUBDIM(T2)	; DETERMINE # OF DESCRIPTORS
	JSP	TLINK,IMSORT	; INITIALIZE THE SORT

	HRRZ	T3,FLAS		; TABLE POINTER
	HRRZ	T2,FLAP		; ARRAY POINTER
	SKIPL	P2		; INCREMENT IF TWO ...
	ADDI	T2,2		; DIMENSIONS.
	MOVE	T1,IGNOS##	; # OF ITEMS

	 ; LOOP TO FILL TABLE WITH OFFSET,POINTER PAIRS

SORTAL:	MOVEI	Q2,SUBDIM+1(T2)	; POINT TO DESCRIPTOR
	JUMPE	S3,SORTA3	; JUMP IF NO FIELD NAME
	JSP	QLINK,LOCVAL##	; ADJUST IF NECESSARY

	HLRZ	Q3,0(Q2)	; GET DATATYPE
	CAIE	Q3,DDT		; DEFINED TYPE?
	JRST	SORTA3		; NO - USE THIS

	HRRZ	Q1,0(Q2)	; LOAD DBLOK ADDR
	HRRZ	Q3,ADFBLK(Q1)	; LOAD DFBLOK ADDR
	MOVEI	T4,VFUNC-FFLINK(S3)	; POINT NEAR VALUE

	 ; LOOP TO FIND THE CORRECT OFFSET

SORTA2:	HRRZ	T4,FFLINK(T4)	; GET NEXT FFLBOK ADDR
	JUMPE	T4,SORTA3	; NONE LEFT
	HRRZ	Z,FFDFBL(T4)	; LOAD DFBLOK ADDR
	CAME	Z,Q3		; IS THIS THE ONE?
	JRST	SORTA2		; NO, TRY NEXT ONE

	HLL	Q2,FFOFFS(T4)	; PICK UP OFFSET
	HRR	Q2,Q1		; COMPLETE THE ADDRESS
	SKIPA			; SKIP INTO THE PROCESSSING

	 ; MERGE HERE FROM NORMAL CASE

SORTA3:	HRL	Q2,S1		; INSERT OFFSET
	MOVEM	Q2,TBUCK(T3)	; PLUG TABLE
	ADD	T2,IGNOP+1	; BUMP ARRAY
	ADDI	T3,1		; BUMP TABLE POINTER
	SOJG	T1,SORTAL	; LOOP ON BUCKET COUNT

	 ; END OF LOOP TO FILL TABLE

	MOVE	Z,IGNOP		; LOAD DIRECTION FLAG
	JSP	SLINK,MSORT	; DO THE SORT

	HRRZ	S3,FLAS		; LOAD TABLE ADDRESS
	HRRZ	S2,-1(STACK)	; RELOAD NEW ARRAY
	ADDI	S2,SUBDIM+2(P2)	; POINT TO FIRST DESCR
	MOVE	S1,IGNOS##	; RELOAD COUNT
	CLEAR	T3,		; CLEAR DESCR 2ND WORD

	 ; LOOP TO TRANSFER DESCR FROM OLD TO NEW ARRAY

SORTA5:	HRRZ	T1,TBUCK(S3)	; GET ADDR OF DESCR
	HLRZ	T2,0(T1)	; GET TYPE OF DESCR
	CAIE	T2,DBLOK	; IS IT REALLY A DBLOK
	JRST	SORTA6		; MUST BE A DESCRIPTOR

	HRR	T2,T1		; MANUFACTURE A DESCR
	HRLI	T2,DDT		; FOR A DEFINED TYPE
	MOVEI	T1,T2		; AND POINT TO IT

SORTA6:	MOVE	T4,IGNOP+1	; LOAD WIDTH
	ASH	T4,-1		; IN DESCRIPTORS
SORTB6:	MOVE	Q2,T1		; POINT ...
	JSP	QLINK,LOCVAL	; TO REAL DESCRIPTOR
	PUSH	S2,0(Q2)	; PUSH DESCRIPTOR ...
	PUSH	S2,1(Q2)	; INTO THE ARRAY
	ADDI	T1,2		; POINT TO NEXT DESCR
	SOJG	T4,SORTB6	; COUNT DOWN ON T4

	ADDI	S3,1		; INCR THE TABLE
	SOJG	S1,SORTA5	; COUNT DOWN

	 ; NOTHING TO DO BUT RETURN

	JSP	QLINK,NSRT1	; NULL OUT THE TABLE
	JRST	1(PLINK)	; AND RETURN
	 ; TSORT - A ROUTINE TO SORT A TABLE

	 ; CALLING SEQUENCE:
	 ;	PUSH TABLE DESCR
	 ;	LOAD Z WITH FLAG,,OFFSET
	 ;	JSP	P2,TSORT
	 ;	RETURN WITH IGNOS## EQUAL TO # OF NON-NULL ITEMS 
	 ;	AND WITH FLAS EQUAL TO A TABLE OF
	 ;	ELEMENTS IN SORTED ORDER.

TSORT::	SKIPA	S1,[TSEQ##]	; LOAD SEQ ROUTINE

	 ; ENTRY POINT TO SORT A VARIABLE TABLE

VTSORT::MOVEI	S1,VTSEQ##	; POINT TO SEQ ROUTINE

	MOVEM	 Z,IGNOS+1	; SAVE FLAG,,OFFSET

	CLEAR	S3,		; COUNT ...
	JSP	TLINK,0(S1)	; # OF ITEMS ...
	AOJ	S3,		; IN THE TABLE

	MOVE	Z,S3		; LOAD THE COUNT
	JSP	TLINK,IMSORT	; INITIALIZE THE SORT

	HRL	S3,IGNOS+1	; OFFSET
	MOVE	S2,FLAS##	; ADDR OF NEW TBLOK
	JSP	TLINK,0(S1)	; SEQUENCE THRU TABLE AGAIN
	JSP	QLINK,[HRR	S3,T4	; LOAD TEBLOK ADDR
		MOVEM	S3,TBUCK(S2)	; STORE IT
		AOJA	S2,0(QLINK)]	; INCR S2 AND RETURN

	HLRE	Z,IGNOS+1	; LOAD FLAG
	JSP	SLINK,MSORT	; DO THE SORT

	JRST	0(P2)		; AND RETURN
	 ; IMSORT - INITIALIZE MSORT
	 ; CALLING SEQUENCE:
	 ;	LOAD Z WITH # OF ITEMS TO BE SORTED
	 ;	JSP	TLINK,IMSORT
	 ;	RETURN	 ; FLAS AND IGNOS ARE SETUP

IMSORT:	MOVEM	Z,IGNOS		; SAVE #
	MOVEM	TLINK,FLAS+1	; SAVE RETURN
	CLEARM	FLAS		; PROTECT GC

	JSP	TLINK,TBL##	; ALLOCATE A TABLE

	MOVE	Z,IGNOS		; ALLOCATE ...
	JSP	TLINK,TBL	; ANOTHER ONE

	MOVE	TLINK,FLAS+1	; RESTORE LINK

	POP	STACK,FLAS+3	; POP
	POP	STACK,FLAS+2	; THE
	POP	STACK,FLAS+1	; RES
	POP	STACK,FLAS	; ULTS

	JRST	0(TLINK)


	 ; NSRT(I) - NULL OUT SORTING TABLE

NSRT1::	SKIPA	Q2,[FLAS]	; LOAD ADDR OF DESCR
NSRT2::	MOVEI	Q2,FLAS+2	; DITTO
	MOVE	Q3,0(Q2)	; LOAD ADDR OF TBLOK
	MOVEI	Z,JKBLOK	; INDICATE ...
	HRLM	Z,0(Q3)		; THAT IT'S JUNK
	CLEARM	0(Q2)		; THEN DESTROY THE DESCRIPTOR
	JRST	0(QLINK)	; AND RETURN
	 ; MSORT - A MERGE SORTING ROUTINE

	 ; CALLING SEQUENCE:
	 ;	SET FLAS WITH TABLE OF DESIGNATORS
	 ; (A DESIGNATOR CONSISTS OF AN ADDRESS (RIGHT SIDE)	
	 ; AND AN OFFSET (LEFT SIDE). THEIR SUM POINTS TO A
	 ; DESCRIPTOR.
	 ;	SET FLAS+2 WITH EQUI-SIZE TABLE
	 ;	LOAD Z WITH FLAG (0 MEANS ASCENDING)
	 ;	JSP	SLINK,MSORT
	 ;	RETURN WITH FLAS CONTAINING ORDERED DESIGNATORS.

	GT12==FLAS##+1	; ADDRESS IF LOW STREAM GT UPPER STREAM
	GT21==FLAS##+3	; ADDRESS IF UPPER STREAM GT LOW STREAM

MSORT: MOVEI	Q1,TAKE.1	; DECISION ...
	MOVEI	Q2,TAKE.2	; ADDRESSES
	SKIPE	Z		; REVERSE ...
	EXCH	Q1,Q2		; IF FLAGGED
	MOVEM	Q1,GT21		; SAVE ...
	MOVEM	Q2,GT12		; ADDRESSES

	PUSHR	PS		; WE NEED THESE

	MOVEI	P1,1		; GROUP SIZE

	 ; OUTER LOOP - HERE AFTER GROUP SIZE HAS BEEN DOUBLED

MSORT1:	CAML	P1,IGNOS	; EQUAL TO SIZE OF LIST?
	JRST	MSORT9		; YES - ALL DONE
	MOVNM	P1,IGNOS+2	; SAVE NEGATIVE OF GROUP SIZE

	HRRZ	P2,FLAS		; COMPUTE UPPER LIMIT
	ADD	P2,IGNOS	; OF SOURCE TABLE
	MOVEM	P2,IGNOS+1	; FOR MIDDLE LOOP

	HRRZ	S3,FLAS+2	; SET UP S3 FOR...
	ADDI	S3,TBUCK-1	; PUSHING ONTO DESTINATION TABLE.
	HRRZ	P2,FLAS		; RELOAD SOURCE TABLE

	 ; MIDDLE LOOP - MERGE UPPER AND LOWER LISTS EACH OF
	 ; LENGTH P1 (MAYBE).	S1 AND S2 REPRESENT THE 2 LISTS
	 ; AND ARE FORMATTED (-COUNT,,ADDR).

MSORT2:	CAML	P2,IGNOS+1	; ANY LEFT?
	JRST	MSORT8		; NO

	HRR	S1,P2		; PREPARE LOWER ...
	HRL	S1,IGNOS+2	; LIST DESIGNATOR
	ADDI	P2,0(P1)	; BUMP SOURCE
	CAML	P2,IGNOS+1	; IS THERE ANY UPPER LIST?
	JRST	MSORT7		; NO

	MOVE	S2,P2		; PREPARE UPPER ...
	HRL	S2,IGNOS+2	; LIST DESIGNATOR
	ADDI	P2,0(P1)	; BUMP SOURCE
	CAMG	P2,IGNOS+1	; IS IT BEYOND
	JRST	COMP1		; NO - TO INNER LOOP

	HRRZ	T1,S2		; COMPUTE NEGATIVE ...
	SUB	T1,IGNOS+1	; OF AMOUNT REMAINING ...
	HRL	S2,T1		; INTO UPPER DESIGNATOR

	 ; INNER LOOP - HERE TO COMPARE TWO DESCRIPTORS
	 ; ONE DESIGNATED BY S1, THE OTHER BY S2

COMP1:	HLRZ	Q2,TBUCK(S1)	; SET T4 ...
	ADD Q2,TBUCK(S1)	; TO POINT TO ...
	JSP	QLINK,LOCVAL	; FIRST ...
	MOVE	T4,Q2		; DESCRIPTOR

	HLRZ	Q2,TBUCK(S2)	; SET Q2 ...
	ADD	Q2,TBUCK(S2)	; TO POINT TO ...
	JSP	QLINK,LOCVAL	; SECOND DESCRIPTOR

	HLRZ	T1,0(T4)	; LOAD FIRST DATATYPE
	CAIN	T1,SDT		 ; IS IT STRING?
	JRST	COMPS		; YES - LOOK AT NEXT

COMP2:	MOVE	T1,0(T4)	; LOAD FIRST WORD OF FIRST
	SUB	T1,0(Q2)	; SUBTRACT SECOND
	JUMPN	T1,COMP3	; JUMP IF DIFFERENT

	MOVE	T1,1(T4)	; COMPARE ...
	SUB	T1,	; SECOND WORDS
COMP3:	JUMPG	T1,@GT12	; FIRST GT 2ND
	JUMPL	T1,@GT21	; 2ND GT 1ST
	JRST	TAKE.1		; EQUAL - DONE'T INVERT

	 ; FIRST IS STRING, 2ND IS IN DOUBT

COMPS:	HLRZ	T2,0(Q2)	; IS THE SECOND ...
	CAIE	T2,SDT		; A STRING?
	JRST	COMP2		; NO - COMPARE DESCRIPTORS
	HRRZ	T2,0(Q2)	; ALSO JUMP IF
	JUMPE	T2,COMP2	; ITS A NULL STRING

	PUSH	STACK,0(T4)	; PUSH FIRST
	PUSH	STACK,1(T4)	; DESCRIPTOR
	PUSH	STACK,0(Q2)	; PUSH 2ND ...
	PUSH	STACK,1(Q2)	; DESCRIPTOR

	JSP	TLINK,EQINIT##	; INITIALIZE
	ERROR	15		; CAN'T FAIL

	JSP	TLINK,LEQUAL##	; COMPARE FIRST WITH 2ND
	JRST	@GT21		; FIRST WINS
	JRST	TAKE.1		; EQUALITY
	JRST	@GT12		; SECOND WINS

	 ; MERGING S1 & S2 INTO S3

TAKE.1:	PUSH	S3,TBUCK(S1)	; SELECT S1
	AOBJN	S1,COMP1	; BACK TO COMPARE ...
	JRST	FL.S2		; UNLESS RUNNOUT

TAKE.2:	PUSH	S3,TBUCK(S2)	; SELECT S2
	AOBJN	S2,COMP1	; LOOP BACK UNLESS RUNNOUT

	 ; FALL THRU TO FLUSH OUT S1

FL.S1:	MOVE	S2,S1		; COPY INDEX ITEM
FL.S2:	PUSH	S3,TBUCK(S2)	; TRANSFER TOKEN
	AOBJN	S2,FL.S2	; KEEP MOVING UNTIL S2 RUNS OUT
	JRST	MSORT2		; BACK TO MIDDLE LOOP
 
	 ; HERE IF ONLY LOWER LIST EXISTS

MSORT7:	HRRZ	T1,S1		; COMPUTE ...
	SUB	T1,IGNOS+1	; NEG. OF AMOUNT LEFT
	HRL	S1,T1		; INTO S1-LEFT
	JRST	FL.S1		; AND FLUSH OUT S1

	 ; HERE ON COMPLETION OF A MERGE

MSORT8:	MOVE	Z,FLAS		; EXCHANGE ...
	EXCH	Z,FLAS+2	; SOURCE ARRAY ...
	MOVEM	Z,FLAS		; WITH DESTINATION

	IMULI	P1,2		; SIZE OF SEGMENT IS DOUBLED
	JRST	MSORT1		; LOOP BACK

	 ; HERE ON COMPLETION OF THE SORT

MSORT9:	POPR	PS		; RESTORE REGS
	JSP	QLINK,NSRT2	; NULL OUT 2ND TABLE
	JRST	0(SLINK)	; AND RETURN
	END
  =;Dd%