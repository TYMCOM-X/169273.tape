(HELGEM)NEXTIM.SAI                                            Page 1
Program Listing                 Generated by CRFSYM %3

1	
2	entry
3		NexTim
4	;
5	
6	begin "Next Run Time"
7	
8	require "(SAILIB)SAIL.DEF"   source!file;
9	require "(CARL)JQUEUE.DEF"   source!file;
10	require "(HELGEM)SUBMIT.DEF" source!file;
11	require "(HELGEM)DAYTIM.REQ" source!file;
12	
13	redefine PutMult(x)   = { DPB( x, PMult(   memory[ ArrAddr + GI!Pos ] ) ) };
14	redefine PutType(x)   = { DPB( x, PType(   memory[ ArrAddr + GI!Pos ] ) ) };
15	redefine PutMoMult(x) = { DPB( x, PMoMult( memory[ ArrAddr + GI!Pos ] ) ) };
16	redefine PutBody(x)   = { DPB( x, PBody(   memory[ ArrAddr + GI!Pos ] ) ) };
17	redefine PutConn(x)   = { DPB( x, PConn(   memory[ ArrAddr + GI!Pos ] ) ) };
18	
19	redefine GetMult     = { LDB( PMult(   memory[ ArrAddr + GI!Pos ] ) ) };
20	redefine GetType     = { LDB( PType(   memory[ ArrAddr + GI!Pos ] ) ) };
21	redefine GetMoMult   = { LDB( PMoMult( memory[ ArrAddr + GI!Pos ] ) ) };
22	redefine GetBody     = { LDB( PBody(   memory[ ArrAddr + GI!Pos ] ) ) };
23	redefine GetConn     = { LDB( PConn(   memory[ ArrAddr + GI!Pos ] ) ) };
24	
25	redefine SREF(x) = { DPB( x, PDate( memory[ ArrAddr + GI!Pos + 1 ] ) ) };
26	redefine GREF      = { LDB( PDate( memory[ ArrAddr + GI!Pos + 1 ] ) ) };
27	
28	redefine STIM(x) = { DPB( x, PTime( memory[ ArrAddr + GI!Pos + 1 ] ) ) };
29	redefine GTIM      = { LDB( PTime( memory[ ArrAddr + GI!Pos + 1 ] ) ) };
30	
31	
32	
(HELGEM)NEXTIM.SAI                                            Page 2
Program Listing                 Generated by CRFSYM %3

33	
34	integer
35		DateGen
36	,	NewDatTim
37	,	Earliest
38	,	DatesInArr
39	,	TotDats
40	,	LimitDate
41	,	ExcCount
42	,	i
43	,	NewConn
44	,	FailedDates
45	,	GI!Pos
46	,	ExcBase
47	,	UsersZone
48	,	GMTBase
49	;
50	
51	boolean
52		 Exceptions	! becomes true if "exception" connector found ;
53	;
54	
55	preload!with
56	"JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE",
57	"JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER";
58	own safe string array Mos[ 0:NumMnths - 1 ];
59	
60	preload!with
61	"SATURDAY","SUNDAY","MONDAY",
62	"TUESDAY","WEDNESDAY","THURSDAY","FRIDAY";
63	own safe string array WkDay[ 0:NumWkDay - 1 ];
64	
65	own integer array DateArr[1:E!MaxItem,1:2];
66	own integer array ExcpArr[1:E!MaxItem,1:2];
67	
68	
69	
(HELGEM)NEXTIM.SAI                                            Page 3
Program Listing                 Generated by CRFSYM %3

70	
71	simple integer procedure GetDaOfWeek( integer dis );
72	! ----------------------------------------------------------------------;
73	!									;
74	!	GetDaOfWeek							;
75	!		Given a displacement in days from 1-Jan-64, determine	;
76	!		the day of the week as 0-6 where 0 = Saturday.		;
77	!									;
78	! ----------------------------------------------------------------------;
79	return( (dis + 4) mod 7 );
80	
81	
82	
83	simple integer procedure YearNumb( integer disp );
84	! returns the year (0-99) of the displacement;
85	! better way is ((CONST<days 0-1/1/1964> + disp) - leap-years) div 365 ;
86	BEGIN
87		String date;
88	  date_ CvSDat( disp );
89	  return( cvd( date[inf - 1 to inf] ) );
90	END;
91	
92	
93	
94	simple integer procedure MonthNumb( integer disp );
95	! returns the month (0-11) of the displacement;
96	BEGIN
97		integer i;
98		String date;
99	  date_ CvSDat( disp );
100	  for i_ 0 upto 11 do			! check array for match;
101	    if KEQU( date[ 4 for 3 ],Mos[ i ][ 1 for 3 ] ) then
102	      return( i );
103	END;
104	
105	
106	
107	simple integer procedure DaOfMonth( integer disp );
108	! returns the day-of-the-month (1-31) of the displacement;
109	BEGIN
110		String date;
111	  date_ CvSDat( disp );
112	  return( cvd( date[1 for 2] ) );
113	END;
114	
115	
(HELGEM)NEXTIM.SAI                                            Page 4
Program Listing                 Generated by CRFSYM %3

116	
117	simple integer procedure typeW( integer ArrAddr; integer baseDT );
118	BEGIN
119	    integer
120		NextDate
121	,	ref
122	,	BaseDayNum
123	,	RefDayNum
124	,	diff
125	,	dd
126	,	RefYear
127	,	RefMOY
128	,	RefDOM
129	,	FDOM
130	,	FDOMday
131	,	NextMonth
132	,	BODY
133	,	MULT
134	,	MOMULT
135	;
136	
137	  ref_ GREF;
138	  BODY_ GetBody;
139	  MULT_ GetMult;
140	  MOMULT_ GetMoMult;
141	  if !lh( BaseDt ) < ref then ! first date must be after Ref Date ;
142	    baseDT_ !xwd( ref,!rh( BaseDT ) );
143	
144	  ! ______________________________________________________________________;
145	  ! Unit such as "EVERY FRIDAY";
146	  ! ______________________________________________________________________;
147	  if MULT = 1 and MOMULT = 0 then 
148	    BEGIN
149	    BaseDayNum_ GetDaOfWeek( !lh( BaseDT ) );	! Get day of the base ;
150	    if BaseDayNum = BODY then	! Is it the day we're looking for ;
151	      Diff_ 0				! No Difference ;
152	    else				! They are not the same ;
153	      if BaseDayNum < BODY then		! Figure the difference ;
154	        Diff_ abs( BaseDayNum - BODY )
155	      else
156	        Diff_ 7 - ( BaseDayNum - BODY );
157	
158	    NextDate_ !lh( BaseDT ) + diff; 	! Figure next instance of BODY ;
159	    if NextDate = !lh( BaseDT )  then		! Cannot return it if same ;
160	      BEGIN
161	      if not GTIM > !rh( BaseDT ) then		! Req'd time is > base time;
162	        return( NextDate + 7 )		!   so next date is next week ;
163	      else				! Req'd time is earlier than base ;
164		return( nextdate );		!   so next this is date/time ;
165	      END
166	    else
167	      BEGIN
168	      return( NextDate );			! > base so return it ;
169	      END
170	    END
171	  else
172	
173	  ! ______________________________________________________________________;
(HELGEM)NEXTIM.SAI                                            Page 4.1
Program Listing                 Generated by CRFSYM %3

174	  ! Unit such as "EVERY 4TH FRIDAY";
175	  ! ______________________________________________________________________;
176	  if MULT > 1 and MOMULT = 0 then 
177	    BEGIN
178	    RefDayNum_ GetDaOfWeek( Ref );	! Get day-of-the-week of reference ;
179	    if RefDayNum = BODY then		
180	      Diff_ 0				! Difference between ref & TGT days ;
181	    else
182	      if RefDayNum < BODY then	! If ref day comes before TGT day ;
183	        Diff_ abs( RefDayNum - BODY ) ! Days to back up from TGT to ref ;
184	      else
185	        Diff_ 7 - ( RefDayNum - BODY ); ! Days forward from ref to TGT ;
186	
187	    ref_ ref + diff;	! Move from ref day to first instance of TGT day ;
188	
189	    while ref < !lh( BaseDT ) do 		! Until we pass the base ;
190	      ref_ ref + ( 7 * MULT );	!    keep adding 7*Multiplier ;
191	
192	    if ref = !lh( BaseDT ) then			! Happens to equal the base ;	
193	      if not GTIM > !rh( BaseDT ) then	! i.e., next run is not later today ;
194	        return( ref + ( 7 * MULT ) ) ! Then move to next ;
195	      else
196		return( ref )	
197	    else
198	      return( ref );	! date is on future day so don't worry about time ;
199	    END
200	  else
201	
202	  ! ______________________________________________________________________;
203	  ! Unit such as "2nd WED OF EVER MONTH";
204	  ! ______________________________________________________________________;
205	  if MULT > 0 and MOMULT > 0 then 
206	    BEGIN
207	    RefDOM_ DaOfMonth( ref ); ! get day of month of ref;
208	    RefMoy_ MonthNumb( Ref ); ! get month of the ref date;
209	    RefYear_ YearNumb( Ref ); ! get Year of the ref date;
210	    FDOM_ ref - RefDOM - 1; ! get disp of first day of ref month;
211	    FDOMDay_ GetDaOfWeek( FDOM ); ! get day of week of FDOM;
212	    if FDOMday = BODY then
213	      Diff_ 0 			! No difference ;
214	    else
215	      if FDOMday < BODY then	
216	        Diff_ abs( FDOMday - BODY )	! Figure the difference ;
217	      else
218	        Diff_ 7 - ( FDOMday - BODY );	! same ;
219	    if MULT = 9 then
220	      BEGIN 			! find last whatever of ref month;
221	      dd_ FDOM + diff + 28;
222	      if MonthNumb( dd ) = RefMoy then
223		dd_ dd - 7;
224	      END
225	    else
226	      dd_ FDOM + diff + ( ( MULT - 1 ) * 7 ); ! push to req'd day ;
227	
228	    if dd > !lh( BaseDT ) then
229	      BEGIN
230	      return( dd );
231	      END;
(HELGEM)NEXTIM.SAI                                            Page 4.2
Program Listing                 Generated by CRFSYM %3

232	    NextMonth_ RefMOY; 			! start with ref month;
233	    while true do 
234	      BEGIN
235	      NextMonth_ NextMonth + MOMULT; ! Advance the number of months ;
236	      if NextMonth > 12 then		   ! If we overrun December ;
237	        BEGIN
238		NextMonth_ NextMonth - 12;
239		RefYear_ RefYear + 1;
240	        END;
241	      FDOM_ CvDate( NextMonth + 1,1,RefYear ); ! get 1st day of next mo;
242	      FDOMday_ GetDaOfWeek( FDOM );      ! what day-of-the-week;
243	      if FDOMday = BODY then		! See above ;
244	        Diff_ 0
245	      else
246	        if FDOMday < BODY then
247	       	  Diff_ abs( FDOMday - BODY )
248	        else
249	          Diff_ 7 - ( FDOMday - BODY );
250	      if MULT = 9 then
251	        BEGIN 				! find last whatever of ref month;
252		dd_ FDOM + diff + 28;
253		if MonthNumb( dd ) = NextMonth or DaOfMonth( dd ) < 10 then
254		  dd_ dd - 7;
255	        END
256	      else
257	        dd_ FDOM + diff + ( ( MULT - 1 ) * 7 );
258	
259	      if dd > !lh( BaseDT ) or dd = !lh( BaseDT ) then
260	        BEGIN
261		if GTIM > !rh( BaseDT ) then	! Same day but later time ;
262	          return( dd );
263		if dd > !lh( BaseDT ) then	! Same day but later time ;
264	          return( dd );
265	        END
266	      END
267	    END
268	  ! ______________________________________________________________________;
269	
270	END;
271	
272	
(HELGEM)NEXTIM.SAI                                            Page 5
Program Listing                 Generated by CRFSYM %3

273	
274	simple integer procedure typeN( integer ArrAddr; integer baseDT );
275	BEGIN
276		integer baseDOM,baseMOY,baseYear,NextMonth,FDOM,NextDOM,
277			RefMOY,RefDOM,RefYear,dd,BODY,ref,MOMULT;
278	  ref_ GREF;
279	  BODY_ GetBody;
280	  MOMULT_ GetMoMult;
281	  if MOMULT = 0 then		! such as "EVERY nTH DAY";
282	    BEGIN
283	    dd_ ref;				! start with ref date ;
284	    while true do
285	      BEGIN
286	      if dd > !lh( BaseDT ) then
287	        return( dd );
288	      if dd = !lh( BaseDT ) then
289	        if GTIM > !rh( BaseDT ) then
290	          return( dd );
291	      dd_ dd + BODY;
292	      END
293	    END
294	  else
295	    BEGIN
296	    if !lh( BaseDt ) < ref then ! first date must be after Ref Date ;
297	      baseDT_ !xwd( ref,!rh( BaseDT ) );
298	    if MOMULT = 1 then ! as "25TH DAY OF EVERY MONTH";
299	      BEGIN
300	      baseDOM_ DaOfMonth( !lh( baseDT ) ); ! get day of month of base;
301	      baseMoy_ MonthNumb( !lh( BaseDT ) ); ! get month of the base date;
302	      baseYear_ YearNumb( !lh( BaseDT ) ); ! get Year of the base date;
303	      if BODY > BaseDOM then 	! may be in this month;
304	        BEGIN
305		NextDom_ CvDate( baseMOY + 1,BODY,baseYear );	
306	        END
307	      else
308	        BEGIN
309	        if BODY = BaseDOM then
310		  if GTIM > !rh( BaseDT ) then
311		    return( CvDate( baseMOY + 1,BODY,baseYear ) );
312		NextMonth_ baseMOY + 2;	! else next month;
313		if NextMonth > 12 then	! Overran December ;
314		  BEGIN
315		  NextMonth_ NextMonth - 12;
316		  baseYear_ baseYear + 1;	! Happy New Year! ;
317		  END;
318		NextDOM_ CvDate( NextMonth,BODY,baseYear );
319	        END;
320	      return( NextDOM );
321	      END;	 ! if MOMULT = 1;
322	
323	    if MOMULT > 1 then	! as "25TH DAY OF EVERY 3RD MONTH";
324	      BEGIN
325	      RefDOM_ DaOfMonth( ref ); ! get day of month of ref;
326	      RefMoy_ MonthNumb( ref ); ! get month of the ref date;
327	      RefYear_ YearNumb( ref ); ! get Year of the ref date;
328	      nextDOM_ CvDATE( RefMoy + 1,BODY,RefYear );
329	      if nextDOM > !lh( BaseDT ) then ! if the base happens to be target day;
330		return( nextDOM ); ! good enough;
(HELGEM)NEXTIM.SAI                                            Page 5.1
Program Listing                 Generated by CRFSYM %3

331	      if nextDOM = !lh( BaseDT ) then
332		if GTIM > !rh( BaseDT ) then
333		  return( NextDOM );
334	
335	      NextMonth_ RefMOY - ( MOMULT - 1 );
336	      while true do 
337	        BEGIN
338	        NextMonth_ NextMonth + MOMULT;
339	        if NextMonth > 12 then
340	          BEGIN
341	          NextMonth_ NextMonth - 12;
342	          RefYear_ RefYear + 1;
343	          END;
344	        nextDOM_ CvDate( NextMonth + 1,BODY,RefYear );
345	        if BODY = 32 then
346	          BEGIN 
347	          while MonthNumb( NextDOM ) = NextMonth do
348	            NextDOM_ NextDOM - 1;
349	          END;
350	        if nextDOM > !lh( BaseDT ) then
351	          return( NextDOM );
352	        if nextDOM = !lh( BaseDT ) then
353		  if GTIM > !rh( BaseDT ) then
354		    return( NextDOM );
355	        END
356	      END	
357	    END
358	END;
359	
360	
(HELGEM)NEXTIM.SAI                                            Page 6
Program Listing                 Generated by CRFSYM %3

361	simple integer procedure TypeT( integer ArrAddr; integer base );
362	begin
363		integer REFTIM,MinDay,H,M,Brk,BaseTime,DaysAhead,ref,BODY;
364		string Frac;
365	  BODY_ GetBody;
366	  ref_ GREF;
367	  MinDay_ 1440;
368	  DaysAhead_ 0;
369	  Frac_ CvSTim( GTIM );
370	  H_ intscan( Frac,Brk );
371	  M_ intscan( Frac,Brk );
372	  REFTIM_ M + ( 60 * H );
373	
374	  if ref > !lh( base ) then
375	    base_ !xwd( ref,0 );  			! After midnight of ref date ;
376	  Frac_ CvSTim( !rh( Base ) );
377	  H_ intscan( Frac,Brk );
378	  M_ intscan( Frac,Brk );
379	  BaseTime_ M + ( 60 * H );
380	
381	  while REFTIM GEQ BaseTime do
382	    REFTIM_ REFTIM - BODY;
383	
384	  while REFTIM LEQ BaseTime do
385	    BEGIN
386	    REFTIM_ REFTIM + BODY; 	
387	    if REFTIM GEQ MinDay then ! New time is in next day ;
388	      BEGIN
389	      REFTIM_ REFTIM - MinDay;
390	      DaysAhead_ 1 ;
391	      done;
392	      END
393	    END;
394	
395	  M_ REFTIM MOD MinDay;
396	  H_ REFTIM DIV 60;
397	  M_ M - ( H * 60 );
398	  return( !xwd(!lh( base) + DaysAhead,
399	          TFract( cvs(H)&":"&cvs(M)&":00" ) )
400	        );
401	  
402	END;
403	
404	
405	
(HELGEM)NEXTIM.SAI                                            Page 7
Program Listing                 Generated by CRFSYM %3

406	
407	simple integer procedure typeS( integer ArrAddr; integer base );
408	BEGIN
409	  integer ref;
410	  ref_ GREF;
411	
412	  if ref = !lh( base ) then
413	    if GTIM > !rh( base ) then
414	      return( ref );
415	
416	  if ref > !lh( base ) then
417	    return( ref )
418	  else
419	    return( 0 );
420	END;
421	
422	
423	
424	simple integer procedure FindModif( integer ArrAddr; integer ConnSought );
425	! search Array for connector ConnSought;
426	! If connector is found then return the date, as "AFTER 3/3/86.";
427	! else return 0;
428	BEGIN
429		integer Dat;
430	  GI!Pos_ E!Descriptor;		! BEGIN at the BEGINning;
431	  While true do
432	    BEGIN
433	    if GetConn =  ConnSought then	! does it match what is asked for;
434	      BEGIN
435	      GI!Pos_ GI!Pos + D!Length; ! date is in next GI!Poss;
436	      Dat_ !xwd( GREF,GTIM );
437	      return( Dat );		! return the date;
438	      END;
439	    if GetConn = EndCon then		! at END so go no furthur;
440	      BEGIN
441	      return( 0 );
442	      END;
443	    GI!Pos_ GI!Pos + D!Length;	! proceed to next word;
444	    END
445	END;
446	
447	
(HELGEM)NEXTIM.SAI                                            Page 8
Program Listing                 Generated by CRFSYM %3

448	
449	internal simple integer procedure NexTim( integer ArrAddr, BasDatTim );
450	! ----------------------------------------------------------------------;
451	!									;
452	!	NexTim		Routine to return the next available runtime	;
453	!			date based on the date supplied.		;
454	!									;
455	! ----------------------------------------------------------------------;
456	BEGIN "figure"
457	
458	  if not( LDB( PConn( memory[ ArrAddr+E!Descriptor+D!Type ] ) ) )
459	   then return( 0 );			! if connector = 0, return ;
460	
461	  UsersZone_ LDB( point( 6, memory[ ArrAddr+E!Privs ], 7 ) );
462	  GMTBase_ CvtDTM( BasDatTim, UsersZone, '20 );
463	
464	  ExcCount_ 1; 				! exception array index;
465	  Exceptions_ false;	 		! true if "EXCEPT" connector is found ;
466	  FailedDates_ 0; 	 		! Count dates not used due to except's;
467	  LimitDate_ FindModif( ArrAddr, BefCon ); ! See if there's a before date.;
468	  if LimitDate = 0 then 		! There was no before connector. ;
469	    BEGIN
470	    LimitDate_ FindModif( ArrAddr, UntCon ) ; 	! check for an until. ;
471	    LimitDate_ LimitDate + 1;     		! If "UNTIL" found then add 1 ;
472	    if LimitDate = 1 then           		! i.e., not found ;
473	      LimitDate_ 0;				! So no limit date.;
474	    END;
475	  GI!Pos_ E!Descriptor; ! go to beginning of the date code ;
476	  while true do
477	    BEGIN "find a date"
478	    arrclr( DateArr );
479	    arrclr( ExcpArr );
480	    TotDats_ 0;
481	    ExcBase_ 99999;
482	    
483	    ! ----------------------------------------------------------------------;
484	    ! Figure next run date for each date unit within the expression.
485	    ! Load into DateArr until an "EXCEPT" connector is found. From that
486	    ! point on, load run dates into ExcpArr.
487	    ! ----------------------------------------------------------------------;
488	    while true do
489	      BEGIN "load date arrays"
490	      TotDats_ TotDats + 1; 
491	      NewConn_ GetConn;
492	      DateGen_ NewDatTim_ 0;
493	      case GetType of 
494	        BEGIN
495	        [ TypW ] DateGen_   typeW( ArrAddr, GMTBase );
496	        [ TypN ] DateGen_   typeN( ArrAddr, GMTBase );
497	        [ TypS ] DateGen_   typeS( ArrAddr, GMTBase );
498	        [ T NewDatTim_ typeT( ArrAddr, GMTBase )
499	        END; 
500	
501	      if DateGen = 262143 then		! '777777  ;
502	        return( -1 );			! Startup. ;
503	
504	      if DateGen > 0 then
505	        NewDatTim_ !xwd( DateGen,GTIM ); 		! load run time ;
(HELGEM)NEXTIM.SAI                                            Page 8.1
Program Listing                 Generated by CRFSYM %3

506	
507	      if !lh( NewDatTim ) < ExcBase then 		! save earliest date ;
508	        ExcBase_ !lh( NewDatTim );
509	      if Exceptions then			! if Exception has been found ;
510	        BEGIN
511		ExcpArr[ExcCount,1]_ NewDatTim; 	! All following are exceptions;
512		ExcCount_ ExcCount + 1;			! Increment exception count ;
513	        END
514	      else
515	        BEGIN					! no exception found yet ;
516	        DateArr[TotDats,1]_ NewDatTim;		! latest date into array ;
517		DateArr[TotDats + 1,2]_ NewConn;	! keep connector with the date;
518	        if NewConn = ExcCon then                ! is connector an ExcCon? ;
519	 	  Exceptions_ true;		        ! All further dates are exceptions;
520	        if Exceptions then	                ! if Exception has been found ;
521	          GMTBase_ !xwd( ExcBase - 1, !rh( GMTBase ) );
522	        END;
523	      if GetConn = EndCon then
524		done
525	      else					! else get next part, continue;
526	        GI!Pos_ GI!Pos + D!Length; 
527	      END "load date arrays";
528	    ! ----------------------------------------------------------------------;
529	
530	
531	    ! ----------------------------------------------------------------------;
532	    ! Get the earliest run date from DateArr, move it to "Earliest".
533	    ! ----------------------------------------------------------------------;
534	    Earliest_ DateArr[1,1];
535	    DatesInArr_ TotDats - ExcCount + 1 ;
536	    if DatesInArr > 1 then
537	      for i_ 2 upto DatesInArr do 
538	        BEGIN
539	        if DateArr[i,1] < Earliest and DateArr[i,2] neq 69 and 
540		    DateArr[i,1] > 0 then
541	          Earliest_ DateArr[i,1]; 	   ! get lowest next date from array ;
542	        END;
543	    ! ----------------------------------------------------------------------;
544	
545	    if LimitDate > 0 and Earliest > LimitDate - 1 then
546	      BEGIN  
547	      return( 0 );		      ! there is no date before a before date;
548	      END;
549	
550	
551	    ! ----------------------------------------------------------------------;
552	    ! If there is an Earliest, then see if it is overruled by any exceptions.
553	    ! If not excepted then return the date 
554	    !    else go back to beginning of "find a date" to find a later "Earliest".
555	    ! ----------------------------------------------------------------------;
556	    if Earliest > 0 then
557	      BEGIN						! there is a new date ;
558	      if ExcCount > 1 then 		! if there are exceptions;
559	        BEGIN
560		for i_ 1 upto ExcCount - 1 do
561		  BEGIN				! check found date against exceptions ;
562		  if Earliest = ExcpArr[ i,1 ] then		! date = an exception ;
563		    BEGIN
(HELGEM)NEXTIM.SAI                                            Page 8.2
Program Listing                 Generated by CRFSYM %3

564		    GMTBase_ Earliest; ! next date found must be > current date ;
565		    ExcCount_ 1;			! re-init exception aray index;
566		    Exceptions_ false;
567		    GI!Pos_ E!Descriptor; 		! back to beginning ;
568		    FailedDates_ FailedDates + 1;
569		    if FailedDates > 365 then 		! no more than 365 attempts ;
570		      BEGIN 
571		    ! print( crlf,"NO DATES BEFORE ", CvSDat( !lh( Earliest ) ) );
572		      return( 0 ); 			! All dates excepted;
573		      END;
574		    continue "find a date"; 		! try again ;
575		    END
576		  END;
577	        return( CvtDTM( Earliest, '20, UsersZone ) );
578	        END					! no exception to date ;
579	      else
580	        return( CvtDTM( Earliest, '20, UsersZone ) );
581	      END					! there were no exceptions. ;
582	    else
583	      return( 0 ); 				! no further dates were found ;
584	    ! ----------------------------------------------------------------------;
585	
586	    if NewConn = EndCon then
587	      done;
588	    END "find a date";
589	END "figure";
590	
591	! print( crlf,"BAS:",!lh( GMTBase )," ",CvSTim( !rh( GMTBase ) )," " );
592	! print( crlf,"DateGen=",DateGen );
593	! print( crlf,"NEW:",!lh( NewDatTim )," ",CvSTim( !rh( NewDatTim ) )," " );
594	!     for i_ 1 upto TotDats - ExcCount + 1 do
595	!       print(crlf,"DateArr[",i,",1]=",
596	!       !lh( DateArr[i,1] ),"-",
597	!       CvSTim( !rh( DateArr[i,1] ) ) );
598	! 
599	!     for i_ 1 upto TotDats - ExcCount + 1 do
600	!       print(crlf,"ExcpArr[",i,",1]=",
601	!       !lh( ExcpArr[i,1] ),"-",
602	!       CvSTim( !rh( ExcpArr[i,1] ) ) );  
603	! 
604	! print( crlf,"GREF=",GREF );
605	
606	END "Next Run Time";
(HELGEM)NEXTIM.SAI        User defined Symbol Table           Page 9
Cross Reference                 Generated by CRFSYM %3

!LH                        141   158   159   189   192   228   259   259   263
                           286   288   296   300   301   302   329   331   350
                           352   374   398   412   416   507   508
!RH                        142   161   193   261   289   297   310   332   353
                           376   413   521
!XWD                       142   297   375   398   436   505   521
ARRADDR                    117   274   361   407   424   449   458   461   467
                           470   495   496   497   498
ARRCLR                     478   479
BASDATTIM                  449   462
BASE                       361   374   375   376   398   407   412   413   416
BASEDAYNUM                 122   150   153   154   156
BASEDOM                    276   300   303   309
BASEDT                     117   141   142   142   158   159   161   189   192
                           193   228   259   259   261   263   274   286   288
                           289   296   297   297   300   301   302   310   329
                           331   332   350   352   353
BASEMOY                    276   301   305   311   312
BASETIME                   363   379   381   384
BASEYEAR                   276   302   305   311   316   316   318
BEFCON                     467
BODY                       132   138   150   153   154   156   179   182   183
                           185   212   215   216   218   243   246   247   249
                           277   279   291   303   305   309   311   318   328
                           344   345   363   365   382   386
BRK                        363   370   371   377   378
CONNSOUGHT                 424   433
CVD                         89   112
CVDATE                     241   305   311   318   328   344
CVS                        399   399
CVSDAT                      88    99   111
CVSTIM                     369   376
CVTDTM                     462   577   580
D!LENGTH                   435   443   526
D!TYPE                     458
DAOFMONTH                  107   253   300   325
DAT                        429   436   437
DATE                        87    88    89    98    99   101   110   111   112
DATEARR                     65   478   516   517   534   539   539   540   541
DATEGEN                     35   492   495   496   497   501   504   505
DATESINARR                  38   535   536   537
DAYSAHEAD                  363   368   390   398
DD                         125   221   222   223   223   226   228   230   252
                           253   253   254   254   257   259   259   262   263
                           264   277   283   286   287   288   290   291   291
DIFF                       124   151   154   156   158   180   183   185   187
                           213   216   218   221   226   244   247   249   252
                           257
DIS                         71    79
DISP                        83    88    94    99   107   111
E!DESCRIPTOR               430   458   475   567
E!MAXITEM                   65    66
E!PRIVS                    461
EARLIEST                    37   534   539   541   556   562   564   577   580
ENDCON                     439   523
EXCBASE                     46   481   507   508   521
EXCCON                     518
(HELGEM)NEXTIM.SAI        User defined Symbol Table           Page 10
Cross Reference                 Generated by CRFSYM %3

EXCCOUNT                    41   464   511   512   512   535   558   560   565
EXCEPTIONS                  52   465   509   519   520   566
EXCPARR                     66   479   511   562
FAILEDDATES                 44   466   568   568   569
FDOM                       129   210   211   221   226   241   242   252   257
                           276
FDOMDAY                    130   211   212   215   216   218   242   243   246
                           247   249
FINDMODIF                  424   467   470
FRAC                       364   369   370   371   376   377   378
GETBODY                    138   279   365
GETCONN                    433   439   491   523
GETDAOFWEEK                 71   211   242
GETMOMULT                  140   280
GETMULT                    139
GETTYPE                    493
GI!POS                      45   430   435   435   443   443   475   526   526
                           567
GMTBASE                     48   462   495   496   497   498   521   521   564
GREF                       137   278   366   410   436
GTIM                       161   193   261   289   310   332   353   369   413
                           436   505
H                          363   370   372   377   379   396   397   399
I                           42    97   100   101   102   537   539   539   540
                           541   560   562
INTSCAN                    370   371   377   378
KEQU                       101
LIMITDATE                   40   467   468   470   471   471   472   473
M                          363   371   372   378   379   395   397   397   399
MINDAY                     363   367   387   389   395
MOMULT                     134   140   235   277   280   281   298   323   335
                           338
MONTHNUMB                   94   208   222   253   301   326   347
MOS                         58   101
MULT                       133   139   190   194   219   226   250   257
NEWCONN                     43   491   517   518
NEWDATTIM                   36   492   498   505   507   508   511   516
NEXTDATE                   120   158   159   162   164   168
NEXTDOM                    276   305   318   320   328   329   330   331   333
                           344   347   348   348   350   351   352   354
NEXTIM                       3   449
NEXTMONTH                  131   232   235   235   236   238   238   241   253
                           276   312   313   315   315   318   335   338   338
                           339   341   341   344   347
NUMMNTHS                    58
NUMWKDAY                    63
PCONN                      458
POINT                      461
REF                        121   137   141   142   187   187   189   190   190
                           192   194   196   198   208   209   210   277   278
                           283   296   297   325   326   327   363   366   374
                           375   409   410   412   414   416   417
REFDAYNUM                  123   179   182   183   185
REFDOM                     128   210   277   325
REFMOY                     127   208   222   232   277   326   328   335
REFTIM                     363   372   381   382   382   384   386   386   387
                           389   389   395   396
(HELGEM)NEXTIM.SAI        User defined Symbol Table           Page 11
Cross Reference                 Generated by CRFSYM %3

REFYEAR                    126   209   239   239   241   277   327   328   342
                           342   344
TFRACT                     399
TOTDATS                     39   480   490   490   516   517   535
TYPEN                      274   496
TYPES                      407   497
TYPET                      361   498
TYPEW                      117   495
TYPN                       496
TYPS                       497
TYPT                       498
TYPW                       495
UNTCON                     470
UPTO                       100   537   560
USERSZONE                   47   461   462   577   580
WKDAY                       63
YEARNUMB                    83   209   302   327
(HELGEM)NEXTIM.SAI        MACRO Symbol Table                  Page 12
Cross Reference                 Generated by CRFSYM %3

ARRADDR                     13    14    15    16    17    19    20    21    22
                            23    25    26    28    29
GETBODY                     22
GETCONN                     23
GETMOMULT                   21
GETMULT                     19
GETTYPE                     20
GI!POS                      13    14    15    16    17    19    20    21    22
                            23    25    26    28    29
GREF                        26
GTIM                        29
PBODY                       16    22
PCONN                       17    23
PDATE                       25    26
PMOMULT                     15    21
PMULT                       13    19
PTIME                       28    29
PTYPE                       14    20
PUTBODY                     16
PUTCONN                     17
PUTMOMULT                   15
PUTMULT                     13
PUTTYPE                     14
SREF                        25
STIM                        28
X                           13    13    14    14    15    15    16    16    17
                            17    25    25    28    28
(HELGEM)NEXTIM.SAI        SAIL Reserved Words                 Page 13
Cross Reference                 Generated by CRFSYM %3

!                           52    72    74    75    76    77    84    85    95
                           100   108   141   144   146   149   150   151   152
                           153   158   159   161   162   163   164   168   173
                           175   178   180   182   183   185   187   189   190
                           192   193   194   198   202   204   207   208   209
                           210   211   213   216   218   220   226   232   235
                           236   241   242   243   251   261   263   268   281
                           283   296   298   300   301   302   303   312   313
                           316   321   323   325   326   327   329   330   375
                           387   425   426   427   430   433   435   437   439
                           443   450   452   453   454   459   464   465   466
                           467   468   470   471   472   473   475   483   501
                           502   505   507   509   511   512   515   516   517
                           518   519   520   525   528   532   541   543   547
                           551   557   558   561   562   564   565   567   569
                           571   572   574   578   581   583   584   591   592
                           593   594   598   603
ABS                        154   183   216   247
AND                        539   539
ARRAY                       58    63    65    66
BEGIN                        6    86    96   109   118   160   167   220   229
                           234   237   251   260   275   282   285   295   299
                           304   308   314   324   337   340   346   362   385
                           388   408   428   432   434   440   456   469   477
                           489   494   510   515   538   557   559   561   563
                           570
BOOLEAN                     51
CASE                       493
CONTINUE                   574
DIV                        396
DO                         100   189   233   284   336   347   381   384   431
                           476   488   537   560
DONE                       391   524
DPB                         13    14    15    16    17    25    28
ELSE                       152   155   163   166   171   181   184   195   197
                           200   214   217   225   245   248   256   294   307
                           418   514   525   579   582
END                         90   103   113   165   169   170   199   224   231
                           240   255   265   266   267   292   293   306   317
                           319   321   343   349   355   356   357   358   392
                           393   402   420   438   442   444   445   474   499
                           513   522   527   542   548   573   575   576   578
                           581   588   589   606
ENTRY                        2
FALSE                      465   566
FOR                        100   101   101   112   537   560
GEQ                        381   387
IF                         101   141   150   153   159   161   179   182   192
                           193   212   215   219   222   228   236   243   246
                           250   253   259   261   263   281   286   288   289
                           296   298   303   309   310   313   323   329   331
                           332   339   345   350   352   353   374   387   412
                           413   416   433   439   458   468   472   501   504
                           507   509   518   520   523   536   539   556   558
                           562   569
INF                         89    89
INTEGER                     34    65    66    71    71    83    83    94    94
(HELGEM)NEXTIM.SAI        SAIL Reserved Words                 Page 14
Cross Reference                 Generated by CRFSYM %3

                            97   107   107   117   117   117   119   274   274
                           274   276   361   361   361   363   407   407   407
                           409   424   424   424   429   449   449
INTERNAL                   449
LDB                         19    20    21    22    23    26    29   458   461
LEQ                        384
MEMORY                      13    14    15    16    17    19    20    21    22
                            23    25    26    28    29   458   461
MOD                         79   395
NEQ                        539
NOT                        161   193   458
OF                         493
OR                         253   259
OWN                         58    63    65    66
PRELOAD!WITH                55    60
PROCEDURE                   71    83    94   107   117   274   361   407   424
                           449
REDEFINE         8     9    10    11
STRING                      58    63    87    98   110   364
THEN                       101   141   150   153   159   161   179   182   192
                           193   212   215   219   222   228   236   243   246
                           250   253   259   261   263   281   286   288   289
                           296   298   303   309   310   313   323   329   331
         #B7uÜ>@"