	SUBTTL	Gimpel--Ma355/JDS/DRH/MP/RCM/VB		15-Jun-76

; COPYRIGHTS 1972,1973,1976,1977 STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	UUOSYM		;TOPS10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	GCVER==5		;MAJOR VERSION NUMBER
	GCMIN==0		;MINOR VERSION NUMBER
	GCEDT==305		;EDIT LEVEL
	GCWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	GC,SNOGC,<Garbage Collector>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%UUOS		;VERSION NUMBER OF UUOSYM
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	GCTTL				; Title
	GCPTX				; PASS2 assembly message
	SUBTTL	Table of Contents

;		Table of Contents for Garbage Collector
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. MISC DEFINITIONS . . . . . . . . . . . . . . . . . . .    4
;   4. ENTRY POINTS . . . . . . . . . . . . . . . . . . . . .    5
;   5. GENERAL DISPATCHING. . . . . . . . . . . . . . . . . .    7
;   6. STACK MARKING. . . . . . . . . . . . . . . . . . . . .    9
;   7. GRID MARKING . . . . . . . . . . . . . . . . . . . . .   10
;   8. SPECIAL BLOK MARKING PROCEDURES. . . . . . . . . . . .   12
;   9. PHASE II - ADDRESS MODIFICATION. . . . . . . . . . . .   20
;  10. - PHASE III (DATA MOVEMENT). . . . . . . . . . . . . .   22
;  11. FINAL WRAP-UP. . . . . . . . . . . . . . . . . . . . .   24
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
270	Clean some misc. things in SNOGC.
305	CORE UUO in SNOGC should use ADDI, not IORI to round to next 1K.
\
	SUBTTL	MISC DEFINITIONS

	NFLOOR==IGNOQ##		; NEW FLOOR
	BLIST==IGNOQ##+1	; BLOK LIST
	SUBTTL	ENTRY POINTS

CLLCT::	JSP	TLINK,CVTINT##	; 2ND ARGUMENT
	ERROR.	1,57		; BAD ARGUMENT

	SKIPE	P2,0(STACK)	; WAS THE ARGUMENT 0?
	MOVEM	P2,TOOMCH##	; NO, USE IT AS MAX. SLACK
	SUB	STACK,[2,,2]	; POP STACK
	 ; 
	JSP	TLINK,CVTINT	; 1ST ARGUMENT
	ERROR.	1,57		; BAD ARGUMENT

	SKIPE	P2,0(STACK)	; WAS ARG 0?
	MOVEM	P2,BROOM##	; NO, USE AS BREATHING ROOM
	JSP	SLINK,CGCOL	; ORDER UP ONE COMPLETE GC

	CLEAR	Q3,		; DETERMINE ...
	CORE	Q3,		; MAX CORE
	ASH	Q3,^D10		; IN WORDS

	MOVE	Q2,.JBHRL	; LOAD SIZE -1 OF ...
	SUBI	Q2,JOBHGH##	;[270] THIS IS THE HIGH SEGMENT
	ADD	Q2,.JBREL	; INCREASE BY SIZE-1 OF LOW
	SUBI	Q3,2(Q2)	; FIND AMOUNT LEFT
	ADD	Z,Q3		; ADD TO RETURNED VALUE

	MOVEM	Z,0(STACK)	; RETURN SUM
	JRST	1(PLINK)	; NORMAL RETURN

	 ; TYPE S ROUTINE TO PERFORM A COMPLETE
	 ; GARBAGE COLLECTION (DESTROY FLAP## ADDRESSES)

CGCOL::	 ;
	 ; CLEAR OUT FLOATING ADDRESSES IN SAVE AREAS

	CLEARM	FLAP##		; CLEAR ...
	CLEARM	FLAP+2		; PRIMARY AREA
	MOVE	Z,[SAVEP##,,SAVES##]; THEN ...
	BLT	Z,FLAQ##+3	; COPY AREA TO S,T & Q

	CLEARM	SEDIM##		; CLEAR THE SEDIMENT
	CLEARM	SUBJ##		; DELETE THE SUBJECT

	JSP	QLINK,GCOL	; GARBAGE COLLECT
	JRST	0(SLINK)	; AND RETURN
	 ; TYPE Q ENTRY POINTS TO THE GARBAGE COLLECTOR

	 ; GCOL, UNCONDITIONALLY COLLECT STORAGE

GCOL::	SETOM	IGNOQ##+2		; FLAG ENTRY POINT
	CLEARM	IGNOQ+3		; NO EXCESS NEEDED
	JRST	GCOLF1		; JOIN GCOLF PROLOGUE

	 ; GCOLG, GARBAGE COLLECT TO ENSURE SUPPLY OF GROWING STORAGE

GCOLG::	MOVE	Q3,FLOOR##	; FIND AMOUNT LEFT
	SUB	Q3,GSURF##	; IN GRID
	CAMG	Z,Q3		; ENOUGH LEFT?
	JRST	0(QLINK)	; YES

	CLEARM	SEDIM		; SEDIMENT GETS MOVED
	CLEARM	IGNOQ##+2		; FLAG ENTRY
	MOVEM	Z,IGNOQ+3	; SAVE ORIGINAL REQUEST
	ADD	Z,GSURF##		; ADD PRESENT SURFACE
	ADDI	Z,XGRID		; GIVE A LITTLE EXTRA
	MOVEM	Z,NFLOOR	; ESTABLISH AS NEW FLOOR
	JRST	GCOLF2		; JOIN GCOLF PROLOGUE

	 ; GCOLF, GARBAGE COLLECT TO ENSURE FLOATING STORAGE

GCOLF::	MOVE	Q3,CEIL##		; FIND AMOUNT
	SUB	Q3,SURF		; LEFT
	CAMG	Z,Q3		; ENOUGH?
	JRST	0(QLINK)	; YES

	CLEARM	IGNOQ+2		; FLAG ENTRY
	MOVEM	Z,IGNOQ+3	; SAVE ORIGNAL VALUE

	 ; HERE FORM GCOL

GCOLF1:	MOVE	Z,FLOOR		; OLD FLOOR IS ...
	MOVEM	Z,NFLOOR	; GOOD ENOUGH

	 ; HERE FROM GCOLF

GCOLF2:	PUSHR	PSTQ		; SAVE ALL REGISTERS
	AOS	NGCS##		; INDICATE FACT OF GCOL

	MOVE	Q1,FLOOR	; IF NO SEDIMENT
	SKIPN	SEDIM		; THEN USE FLOOR
	MOVEM	Q1,SEDIM	; AS THE SEDIMENTARY LEVEL

	MOVE	Z,FLOOR		; INSERT A ...
	SUB	Z,GSURF		; DUMMY BLOK HEADER ...
	JUMPE	Z,GCI		; INTO THE GROWING ...
	HRLI	Z,JKBLOK	; REGION IN ORDER ...
	MOVE	Q3,GSURF	; TO BRIDGE THE GAP BETWEEN ...
	MOVEM	Z,BTCODE&BLENG(Q3) ; GROWING AND FLOATING STORE

	JRST	GCI		; JOIN PHASE I
	SUBTTL	GENERAL DISPATCHING

	 ; RECOVERY NUMBERS

	RC.STK==1		; STACKS
	RC.GB==2		; GRID BLOKS
	RC.VB==3		; VARIABLE BLOKS
	RC.HST==0		; HISTORY STACK

GCDISP:	RECOHS,,GCLERR		; HISTORY STACK RECOVERY
	RECOSK,,GCLERR		; INTEGER (STACK RECOVERY)
	RECOGB,,GCLERR		; REAL (GRID BLOK RECOVERY)
	RECOVB,,0		; STRING (VARIABLE BLOCK RECOVERY)
	RECOP,,MARKP		; PATTERN
	RECOA,,MARKA		; ARRAY
	RECOC,,MARKC		; EXPRESSION
	RECOC,,MARKC		; CODE
	RECOT,,MARKT		; TABLE
	GCLERR,,GCLERR		; NO BLOK ASS. WITH NDT
	RECOD,,MARKD		; DEFINED DATATYPE
	GCLERR,,0		; CHARACTER TABLE
	RECOUT,,MARKUT		; UTILITY
	GCLERR,,0		; I/O BLOK
	IFN <.-GCDISP>-<TEBLOK&77>,<PRINTX GCDISP TABLE IS OFF>
	RECOTE,,MARKTE		; TABLE ELEMENT
	GCLERR,,0		; JUNK BLOK
	GCLERR,,0		; DEFINED FUNCTION
	GCLERR,,0		; DATATYPE FBLOK
	RECOFF,,MARKFF		; FIELD FBLOK
	GCLERR,,0		; EXTERNAL FBLOK
	RECOT,,MARKTF		; TRACED FBLOK
	RECOUT,,MARKUT		; TRACE BLOK
	RECOUT,,MARKUT		; INPUT-ASSOCIATED BLOK
	RECOUT,,MARKUT		; OUTPUT-ASSOCIATED BLOK
	GCLERR,,0		; BUFFER BLOK
	GCLERR,,0		; OLD BUFFER BLOK
	IFN <.-GCDISP>-<STBLOK&77>,<PRINTX GCDISP TABLE IS OFF>
	GCLERR,,0		; STREAM BLOK

GCLERR:	ERROR	15
	; PROFLC - PROCESS A FLOATING ADDRESS CONDITIONALLY 
	; (ON THE APPEARANCE OF THE FLDC BIT)
	; T3 CONTAINS ADDRESS OF POTENTIALLY FLOATING ADDRESS

PROFLC:	TDNN	S1,0(T3)	; FLOATING?
	JRST	0(QLINK)	; NO

	 ; PROFLU - UNCONDITIONAL FLOATING ADDRESS

PROFLU:	HRRZ	Q2,0(T3)	; LOAD ADDRESS
	CAML	Q2,FLOOR	; BELOW THE FLOOR ?
	CAML	Q2,SURF		; OR ABOVE THE SURFACE?
	JRST	0(QLINK)	; YES, RETURN

	CAML	Q2,SEDIM	; POINTING TO SEDIMENT?
	JRST	PROFL1		; NO
	SKIPN	GCFLD(Q2)	; YES, IF NOT PREV. MARKED
	SETOM	GCFLD(Q2)	; MARK IT ...
	JRST	0(QLINK)	; AND RETURN

PROFL1:	HRRZ	Q3,GCFLD(Q2)	; LOAD TOP OF LIST

	HRRM	T3,GCFLD(Q2)	; INSERT OUR POINTER
	HRRM	Q3,0(T3)	; INSERT HIS IN OURS
	JUMPN	Q3,0(QLINK)	; IF PREVIOUSLY MARKED, RETURN

	 ; FALL THRU IF BLOK HAS NOT PREVIOUSLY BEEN MARKED

	HLRZ	Q3,BTCODE(Q2)	; LOAD BLOK TYPE
	ANDI	Q3,DTNUM	; MAKE AN INDEX
	HRRZ	Q3,GCDISP(Q3)	; LOAD ADDRESS OF PROCESSOR
	JUMPE	Q3,0(QLINK)	; RETURN IF NONE REQUIRED

	HRLM	T4,GCFLD(Q2)	; INSERT BACK POINTER
	MOVE	T4,Q2		; POINT TO NEW BLOK
	JRST	0(Q3)		; BEGIN NEW BLOK

	 ; GENERALIZED RECOVERY PROCEDURE
	 ; FIRST WALK DOWN CHAIN UNTIL A 0 IS FOUND

RECO:	HRRZ	T3,GCFLD(T4)	; LOAD HEAD OF CHAIN

RECO1:	HRRZ	Z,0(T3)		; TEST FOR ...
	JUMPE	Z,RECO2		; ZERO, JUMP IF
	MOVE	T3,Z		; ADVANCE IF NOT ZERO
	JRST	RECO1		; AND LOOP

RECO2:	HLRZ	T4,GCFLD(T4)	; LOAD PREVIOUS BLOK ADDR
	HLRZ	Q3,BTCODE(T4)	; GET BLOK TYPE
	ANDI	Q3,DTNUM	; MASK TO GET BLOK NUMBER
	HLRZ	Q2,GCDISP(Q3)	; PICK UP RECOVERY ADDR
	JRST	0(Q2)		; JUMP INDIRECT
	SUBTTL	STACK MARKING

	 ; STACK CONTROL WORDS

SCW:	XWD	STBASE##,STACK	; SYSTEM STACK
	XWD	NSBASE##,NSTACK##	; NAME STACK
LSCW:	XWD	.+1,.+2		; TENDED FID AREA
	EXP	TENDED##-1,AID##-1

	 ; HERE TO BEGIN MARKING EVERYTHING

GCI:	HRLI	S1,FLDC		; S1 IS NEVER CHANGED

	 ; FIRST LOOK AT THE STACKS

	MOVEI	P1,SCW-1	; POINT ABOVE STACK CONTROL WORDS
	MOVEI	T4,P1	 	; P1 IS A FAKE HEAD

	 ; LOOP HERE TO PROCESS NEXT STACK

GCI.1:	MOVEI	P1,1(P1)	; POINT TO NEXT CONTROL WORD
	CAILE	P1,LSCW		; BEYOND LAST CONTROL WORD?
	JRST	GCI.HS		; GO PROCESS HISTORY STACK

	HRLI	P1,RC.STK	; INSERT RECOVERY CODE

	 ; LOAD P2 WITH UPPER LIMIT
	 ; T3 WITH FIRST ELEMENT ADDRESS

	HRRZ	Q1,0(P1)	; LOAD POINTER TO STACK WORD
	HRRZ	P2,0(Q1)	; LOAD LAST ADDRESS OF STACK

	HLRZ	Q1,0(P1)	; LOAD POINTER TO STACK BASE
	HRRZ	T3,0(Q1)	; LOAD ADDRESS OF BASE
	ADDI	T3,1		; POINT DIRECTLY AT FIRST ENTRY

	 ; LOOP TO PROCESS NEXT STACK ITEM

GCI.2:	CAML	T3,P2		; ARE WE BELOW THE STACK TOP?
	JRST	GCI.1		; NO - GET NEXT STACK

	MOVE	T2,0(T3)	; LOAD FIRST DESCRIPTOR
	TLNN	T2,SJUNKF	; JUNK?
	JRST	GCI.3		; NO

	ADDI	T3,0(T2)	; BUMP OVER JUNK
	JRST	GCI.2		; AND LOOP

GCI.3:	JSP	QLINK,PROFLC	; PROCESS ITEM

	 ; STACK RECOVERY POINT

RECOSK:	MOVEI	T3,2(T3)	; SKIP TO NEXT
	JRST	GCI.2		; AND LOOP

	 ; MARKING THE HISTORY STACK

	 ; LOOK FOR A WORD OF THE FORM D.EX3,,----
	 ; THE NEXT WORD SHOULD BE PROCESSED UNCONDITIONALLY
	 ; IF ANYTHING INTERESTING IT WILL BE A PATTERN

GCI.HS:	HRRZ	T3,HSBASE##	; LOAD ADDRESS ...
	ADDI	T3,1		; OF BASE OF HISTORY STACK
	HRRZ	P2,HSR		; LOAD CURREN TOP OF HSTACK
	HRLZI	P1,RC.HST	; P1 HOLDS THE RECOVERY TYPE
	MOVEI	T4,P1		; POINT TO PSUEDO BLOK HEAD

GCI.H1:	CAML	T3,P2		; ARE WE DONE?
	JRST	GCI.GR		; YES

	HLRZ	T1,0(T3)	; LOAD TYPE
	CAIE	T1,D.EX3##	; LOOKING FOR ONE OF THESE
	AOJA	T3,GCI.H1	; LOOP BACK

	AOJ	T3,		; INCREMENT
	HLRZ	T1,0(T3)	; FIRST CHECK TYPE
	CAIE	T1,PDT		; BETTER BE PATTERN
	ERROR	15		; COMPLAIN
	JSP	QLINK,PROFLC	; PROCESS IT

	 ; HISTORY STACK RECOVERY POINT

RECOHS:	AOJA	T3,GCI.H1	; BACK FOR MORE
	SUBTTL	GRID MARKING

GCI.GR:	MOVE	P2,SEDIM	; UPPER LIMIT
	MOVE	T3,GRID##	; STARTING POINT

GCI.G1:	CAML	T3,P2		; WITHIN BOUNDS?
	JRST	GCII		; NO - OFF TO PHASE II

	MOVE	T2,BTCODE&BLENG(T3) ; LOAD CODE-LENGTH
	TLNN	T2,BLOKF	; A BLOK?
	JRST	GCI.V		; NO - PROCESS VARIABLE

	 ; A BLOK HAS BEEN FOUND IN TH GRID AREA

	HLRZ	T1,BTCODE(T3)	; FROM THE BLOK TYPE
	ANDI	T1,DTNUM	; FIND ITS INDEX
	HRRZ	Q1,GCDISP(T1)	; GET PROCESSING ADDRESS
	JUMPN	Q1,GCI.G2	; UNLESS 0, JUMP

	 ; NO PROCESSING NEEDED

	ADDI	T3,0(T2)	; SKIP PAST BLOK
	JRST	GCI.G1		; AND LOOP

	 ; HERE IF BLOK HAS FLOATNG ADDRESSES

GCI.G2:	HRLI	P1,RC.GB	; INSERT RECOVERY CODE
	HRR	P1,T3		; SAVE STATE HERE
	HRL	Z,T4		; POINTER TO RECOVERY CODE
	HRRI	Z,[0]		; AND POINTER TO PSUEDO-LIST
	MOVEM	Z,GCFLD(T3)	; INTO GCFLD FOR RECOVERY

	MOVE	T4,T3		; POINT TO BLOK AND ...
	JRST	0(Q1)		; JUMP TO PROCESS IT.

	 ; RECOVERY OPERATION FOR GRID BLOKS

RECOGB:	HRRZ	T3,BLENG(P1)	; LOAD LENGTH OF BLOK
	ADDI	T3,0(P1)	; ADD ADDRESS OF BLOK
	JRST	GCI.G1		; AND LOOP
	 ; VARIABLE BLOCK PROCESSING

GCI.V:	HRLI	P1,RC.VB	; TYPE OF PROCESSING
	HRR	P1,T3		; POINT TO VB-TOP
	JSP	QLINK,PROFLC	; PROCESS VALUE OF VARIABLE

GCI.V1:	MOVEI	T3,VLABEL(P1)	; PROCESS LABEL ...
	JSP	QLINK,PROFLU	; FIELD

GCI.V2:	MOVEI	T3,VFUNC(P1)	; PROCESS FUNCTION ...
	JSP	QLINK,PROFLU	; FIELD

GCI.V3:	MOVEI	T3,VNAME(P1)	; PROCESS NAME ...
	JSP	QLINK,PROFLC	; FIELD

GCI.V4: MOVEI	T3,VARSIZ(P1)	; POINT TO BEYOND VB
	JRST	GCI.G1		; AND JOIN MAIN GRID LOOP

	 ; HERE FOR RECOVERY DURING VARIABLE BLOCK PROCESSING

RECOVB:	CAIN	T3,VALUE(P1)	; PROCESSING VALUE?
	JRST	GCI.V1		; YES

	CAIN	T3,VLABEL(P1)	; LABEL?
	JRST	GCI.V2		; YES

	CAIN	T3,VFUNC(P1)	; FUNCTION FIELD
	JRST	GCI.V3		; YES

	JRST	GCI.V4		; MUST BE END
	SUBTTL	SPECIAL BLOK MARKING PROCEDURES

	 ; MARKING FOR PATTERN

MARKP:	MOVEI	T3,PSTART(T4)	; POINT TO FIRST DESCRIPTOR
	JSP	QLINK,PROFLC	; PROCESS DESCRIPTO

	 ; HERE FOR RECOVERY AND INITIALIZATON

RECOP:	HRRZ	T2,BLENG(T4)	; LOAD LENGTH OF PATTERN
	ADDI	T2,0(T4)	; FND ADDRESS OF BOTTOM
	CAIN	T3,PSTART(T4)	; IF AT BEGINNING
	MOVEI	T3,LPHDR+PARG-PNDSZ(T4)	; INITIALIZE

MARKP1:	ADDI	T3,PNDSZ	; POINT TO NEXT NODE
	CAML	T3,T2		; WITHIN BOUNDS?
	JRST	RECO		; NO - RECOVER
	JSP	QLINK,PROFLC	; PROCESS FLOATING ADDR
	JRST	MARKP1		; AND REPEAT
	 ; ARRAY BLOK (ABLOK) PROCESSING

MARKA:	MOVEI	T3,APROTO(T4)	; PROCESS ...
	JSP	QLINK,PROFLC	; PROTOTYPE

MARKA1:	HRRZ	T3,NSUBS(T4)	; LOAD # OF SUBSCRIPTS
	LSH	T3,1		; DOUBLE IT
	ADDI	T3,SUBFAC(T4)	; POINT TO FIRST ELEMENT
	JRST	MRKUT1		; TREAT LIKE A UTILITY

	 ; HERE FOR ARRAY RECOVERY

RECOA:	CAIE	T3,APROTO(T4)	; WERE WE PROCESSING PROTOTYPE?
	JRST	RECOUT		; NO - TREAT LIKE UTILITY
	JRST	MARKA1		; YES - FIND FIRST ELEMENT
	 ; CODE BLOK MARKING

MARKC:	MOVEI	T3,LCLINK(T4)	; PROCESS LAST 
	JSP	QLINK,PROFLU	; CODE BLOK

MARKC1:	MOVEI	T3,NCLINK(T4)	; PROCESS NEXT ...
	JSP	QLINK,PROFLU	; CODE BLOK

	JRST	RECO		; ALL DONE, JUST RECOVER
	 

	 ; HERE FOR RECOVERY DURING CBLOK PROCESSING

RECOC:	CAIN	T3,LCLINK(T4)	; WERE WE HERE LAST?
	JRST	MARKC1		; YES - JOIN CODE PROCESSING
	JRST	RECO		; NO - JUST RECOVER
	 ; MARKING TABLES (AND TFBLOKS)


MARKT:	MOVEI	T3,TBUCK(T4)	; POINT TO FIRST BUCKET
MARKT1:	HRRZ	T2,BLENG(T4)	; PLACE LIMIT ...
	ADDI	T2,0(T4)	; IN T2
MARKT2:	CAML	T3,T2		; ARE WE STILL BELOW LIMIT
	JRST	RECO		; NO - RECOVER

	JSP	QLINK,PROFLU	; PROCESS ELEMENT
	ADDI	T3,1		; INCREMENT POINTER
	JRST	MARKT2		; AND LOOP

	 ; RECOVERY POINT FOR TABLES

RECOT:	ADDI	T3,1		; INCREMENT POINTER
	JRST	MARKT1		; AND GO RESTORE LIMIT

	 ; TFBLOK PROCESSING

MARKTF:	MOVEI	T3,TFOLD(T4)	; POINT TO FIRST FIELD
	JRST	MARKT1		; JOIN TABLE PROCESSING
	 ; UTILITY BLOK (UTBLOK) PROCESSING

MARKUT:	MOVEI	T3,LHDR(T4)	; POINT TO FIRST DESCRIPTOR
MRKUT1:	HRRZ	T2,BLENG(T4)	; LENGTH OF BLOK
	ADDI	T2,0(T4)	; POINTER BEYOND BLOK
MRKUT2:	CAML	T3,T2		; BEYOND BLOK?
	JRST	RECO		; YES

	JSP	QLINK,PROFLC	; PROCESS DESCRIPTOR
	ADDI	T3,2		; NEXT DESCRIPTOR
	JRST	MRKUT2		; AND LOOP

	 ; RECOVERY FOR UTBLOK

RECOUT:	ADDI	T3,2		; INCREMENT TO NEXT
	JRST	MRKUT1		; AND JOIN PROCESSING
	 ; DEFINED DATATYPE PROCESSING

MARKD:	MOVEI	T3,ADFBLK(T4)	; PROCESS ...
	JSP	QLINK,PROFLU	; ASSOCIATED FBLOK

MARKD1:	MOVEI	T3,DFLDS(T4)	; POINT TO ITS FIELDS
	JRST	MRKUT1		; AND TREAT AS UTILITY BLOK
	
	 ; RECOVERY FOR A DBLOK

RECOD:	CAIE	T3,ADFBLK(T4)	; WAS THIS WHAT WE WERE PROCESSING
	JRST	RECOUT		; NO - RECOVER LIKE UTILITY
	JRST	MARKD1		; YES - INITIALIZE
	 ; TABLE ELEMENT (TEBLOK) PROCESSING

MARKTE:	MOVEI	T3,TEREF(T4)	; PROCESS THE
	JSP	QLINK,PROFLC	; REFERENCE ELEMENT

MRKTE1:	MOVEI	T3,TEVAL(T4)	; PROCESS THE ...
	JSP	QLINK,PROFLC	; VALUE

MRKTE2:	MOVEI	T3,TELINK(T4)	; PROCESS THE ...
	JSP	QLINK,PROFLU	; LINK (THE NEXT TEBLOK)

	JRST	RECO		; AND RECOVER

	 ; RECOVERY FOR TEBLOK'S

RECOTE:	CAIN	T3,TELINK(T4)	; WERE WE HERE?
	JRST	RECO		; YES - ALL DONE

	CAIE	T3,TEVAL(T4)	; HOW ABOUT HERE?
	JRST	MRKTE1		; NO - GO PROCESS IT
	JRST	MRKTE2		; YES - ON TO THE LINK
	 ; FIELD FUNCTION (FFBOK) PROCESSING

	 ; (NOTE: THIS HAPPENS TO BE THE SAME AS TFBLOK)

MARKFF:	MOVEI	T3,FFDFBL(T4)	; PROCESS ...
	JSP	QLINK,PROFLU	; THE ASSOCIATED FBLOK

MRKFF1:	MOVEI	T3,FFLINK(T4)	; THEN GET THE LINK
	JSP	QLINK,PROFLU	; 

	JRST	RECO

	 ; RECOVERY FOR FFBLOK

RECOFF:	CAIE	T3,FFDFBL(T4)	; WERE WE HERE?
	JRST	RECO		; NO - MUST BE DONE
	JRST	MRKFF1		; YES - DO THE LINK
	SUBTTL	PHASE II - ADDRESS MODIFICATION

	 ; IN THIS PHASE, ALL LOCATIONS CHAINED OFF 
	 ; THE GCFLD OF A BLOK ARE ADJUSTED TO POINT TO
	 ; THE NEW LOCATION OF THE BLOK

GCII:	MOVE	T1,NFLOOR	; T1 WILL POINT TO THE NEW
	SUB	T1,FLOOR	; ADJUST BY AMOUNT OF ...
	ADD	T1,SEDIM	; SEDIMENT
	MOVE	T2,SEDIM	; T2 WILL POINT TO THE OLD
	MOVEI	S3,BLIST	; POINT TO LIST OF BLOKS

	 ; MAIN LOOP OF PHASE II

GCII1:	CAML	T2,SURF		; STILL BELOW SURFACE?
	JRST	GCII8		; NO - DONE OF PHASE II

	HRRZ	S2,BLENG(T2)	; LOAD SIZE OF BLOK
	SKIPN	GCFLD(T2)	; SH9ULD WE SAVE THIS BLOK?
	JRST	GCII7		; NO

	HRRZM	T2,0(S3)	; ADD BLOK TO LIST
	MOVEI	S3,GCFLD(T2)	; POINT TO NEXT RECEPTACLE

	HLRZ	Z,BTCODE(T2)	; LOAD BLOK TYPE
	CAIE	Z,SBLOK		; TEST FOR STRING
	JRST	GCII4		; NO

	 ; FOR STRINGS FIND MAXIMUM PENETRATION INTO SBLOK

	MOVEI	T3,7		; BUT DO THIS
	TDNE	T3,NGCS		; ONLY EVERY 8
	JRST	GCII4		; GC'S

	HRRZ	Q1,GCFLD(T2)	; HEAD OF CHAIN
	CLEAR	Q2,		; VALUE SET HERE

GCII2:	HLRZ	Q3,1(Q1)	; LOAD OFFSET
	ADD	Q3,1(Q1)	; ADD LENGTH
	CAIGE	Q2,0(Q3)	; NEW HIGH?
	MOVEI	Q2,0(Q3)	; YES

	HRRZ	Q1,0(Q1)	; LOAD ADDRESS OF NEXT DESCRIPTOR
	JUMPN	Q1,GCII2	; AND LOOP IN NON-ZERO

	ADDI	Q2,<NBYTES*LHDR>+<NBYTES-1> ; DETERMINE ...
	IDIVI	Q2,NBYTES	; SBLOK SIZE
	HRRM	Q2,BLENG(T2)	; INSERT NEW SIZE

	 ; NOW CHAIN DOWN THRU LIST OF FLOATING ADDRESSES

GCII4:	HRRZ	T4,GCFLD(T2)	; FIRST ON THE LIST

GCII5:	HRRZ	Q1,0(T4)	; SAVE EXITIN ADDRESS
	HRRM	T1,0(T4)	; PLUG NEW LOCATION
	MOVE	T4,Q1		; TRANSFER ADDRESS
	JUMPN	T4,GCII5	; LOOP WHILE NON-ZERO

	HRRZ	Q1,BLENG(T2)	; GET DURRENT BLOK LENGT
	ADD	T1,Q1		; INCREMNT PAST BLOK

	 ; HERE IF BLOK WAS NOT MARKED

GCII7:	ADD	T2,S2		; INCREMENT PAST OLD BLOK
	JRST	GCII1		; AND LOOP

	 ; FINISH UP WITH PASS II

GCII8:	CLEARM	0(S3)		; INDICATE END OF CHAIN
	MOVE	SURF,T1		; SAVE SURFACE

	 ; CHECK SEDIMENT AND RECORD IN S1 THE 
	 ; MAXIMUM SEDIMENTATION LEVEL FOR NEXT TIME
	 ; (OR LEAVE IT AS 0 IF IT WAS ALL REFERENCED)

	CLEAR	S1,		; INITIALIZE S1
	MOVE	T1,FLOOR	; BEGIN AT THE FLOOR

GCII9:	CAML	T1,SEDIM	; STILL IN SEDIMENT?
	JRST	GCIII		; NO - PHASE III

	JUMPN	S1,GCII9A	; IF TOP OF SED. HAS NOT BEEN FOUND
	SKIPN	GCFLD(T1)	; AND IF BLOK HAS NOT BEEN TOUCHED
	MOVE	S1,T1		; ESTABLISH AS SED. LEVEL

GCII9A:	CLEARM	GCFLD(T1)	; CLEAR FIELD
	HRRZ	T2,BLENG(T1)	; GET BLOK LENGTH
	ADD	T1,T2		; BUMP PAST BLOK
	JRST	GCII9		; AND LOOP FOR MORE
	SUBTTL  PHASE III (DATA MOVEMENT)

GCIII:	MOVE	T2,BLIST	; LIST OF BLOKS
	MOVE	T1,SEDIM	; DESTINATION

	 ; LOOP FOR UPWARD MOVEMENT

GCIII1:	JUMPE	T2,GCIII2	; JUMP IF DONE
	HRRZ	Q3,BLENG(T2)	; GET LENGTH
	HRRZ	T3,GCFLD(T2)	; LOAD NEXT BLOK
	CLEARM	GCFLD(T2)	; CLEAR FOR NEXT GC
	CAIN	T1,0(T2)	; REFLEXIVE MOVE?
	JRST	GCIII9		; YES

	SKIPN	S1		; WAS SED. ALREADY MARKED?
	MOVE	S1,T1		; NO MARK IT

	HRR	Z,T1		; 'TO' ADDRESS
	HRL	Z,T2		; 'FROM' ADDRESS
	ADD	T1,Q3		; POINT BEYOND BLOK
	BLT	Z,-1(T1)	; DO THE MOVE
	MOVE	T2,T3		; GET NEXT ADDRESS
	JRST	GCIII1		; AND LOOP
	
	 ; HERE IF NO BLT IS NEEDED

GCIII9:	ADD	T1,Q3		; NEXT DESTINA
	MOVE	T2,T3		; NEXT BLOK
	JRST	GCIII1		; LOOP FOR MORE
	 ; HERE AFTER ALL BLOKS HAVE BEEN COALESCED
	 ; INTO A CONTIGOUS REGION BEGINNING WITH FLOOR

	 ; ALLOCATE MORE CORE IF NEEDED

GCIII2:	MOVEM	S1,SEDIM	; INSERT NEW SED. LEVEL

	MOVE	Q2,SURF		; DO WE ...
	ADD	Q2,BROOM	; NEED ...
	ADD	Q2,IGNOQ+3	; (ORIGINAL REQUEST)
	CAMG	Q2,CEIL		; MORE CORE?
	JRST	GCIII3		; NO

	ADDI	Q2,1000		;[305] Round up
	SUBI	Q2,MARGIN	; BUT LEAVE SAFETY MARGIN
	MOVEM	Q2,CEIL		; THIS WILL BE THE NEW CEILING
	ADDI	Q2,MARGIN	; ADD SAFETY MARGIN
	CAML	Q2,HIWATR##	; IS THIS THE MOST SO FAR?
	MOVEM	Q2,HIWATR	; YES - MARK
	CORE	Q2,		; REQUEST THIS MUCH
	JRST	[	HRROI P1,-^D6001	; INDICATE
		 JRST	ABSERR## ]	; ERROR 6.1


GCIII3:	MOVE	T2,NFLOOR	; LET T2 =
	SUB	T2,FLOOR	; NFLOOR - FLOOR
	JUMPE	T2,GCEND	; IF SAME, JUMP TO WRAP-UP

	MOVE	T3,NFLOOR	; RESET ...
	MOVEM	T3,FLOOR	; FLOOR
	CLEARM	SEDIM		; SED. LEVEL IS OBSOLETE

	MOVE	S1,SURF		; FIND AMOUNT ...
	SUB	S1,NFLOOR	; TO BE MOVED
	IDIV	S1,T2		; DIVIDE BY DISTANCE MOVED
	 ; S1 CONTANS # OF WHOLE CHUNKS TO BE MOVED
	 ; T2 CONTAINS SIZE OF CHUNKS
	 ; S2 CONTAINS REMAINDER

	MOVE	T4,SURF		; DETERMINE DESTINATION ...
	SUB	T4,S2		; OR REMAINDER
	MOVE	Z,S2		; LOAD AMOUNT TO BE MOVED
	JUMPE	S2,GCIII4	; AVOID I NUMBER IS 0
	JSP	QLINK,MOVEUP	; DO THE MOVE

GCIII4:	SOJL	S1,GCEND	; INDEX ON S1
	SUB	T4,T2		; BUMP DESTINATION
	MOVE	Z,T2	 ; LOAD THE AMOUNT
	JSP	QLINK,MOVEUP	; DO THE MOVE
	JRST	GCIII4		; LOOP FOR MORE


;	MOVEUP - MOVES A BLOCK OF CORE UPWARD TO A NON-
;	OVERLAPPING REGION. CALLING SEQUENCE:
;	LOAD Z WITH AMOUNT TO BE MOVED
;	LOAD T4 WITH DESTINATION
;	LOAD T2 WITH AMOUNT BLOK IS TO BE DISPLACED
;	JSP	QLINK,MOVEUP
;	RETURN - T2 & T4 ARE PRESERVED

MOVEUP:	MOVE	Q3,T4		; 'TO' ADDRESS

	MOVE	Q2,T4		; COMPUTE ...
	SUB	Q2,T2		; 'FROM' ADDRESS
	HRL	Q3,Q2		; AND PLACE INTO Q3-LEFT

	MOVE	Q2,T4		; COMPUTE ULTIMATE
	ADD	Q2,Z		; DESTINATION
	BLT	Q3,-1(Q2)	; AND DO A BLT
	JRST	0(QLINK)	; AND RETURN
	SUBTTL	FINAL WRAP-UP

GCEND:	MOVE	T2,TOOMCH	; LET T2 =
	ADD	T2,SURF		; TOOMCH+SURF
	ADD	T2,IGNOQ+3	; ORIGNAL REQUEST
	IORI	T2,1777		; ROUND UP
	SUBI	T2,MARGIN	; BUT ALLOW FOR MARGIN
	CAML	T2,CEIL		; TOO MUCH SLACK?
	JRST	GCEND1		; NO

	MOVEM	T2,CEIL		; YES - SET LOWER CEILING
	ADDI	T2,MARGIN	; ADD SAFETY MARGIN
	CORE	T2,		; REQUEST LESS CORE
	ERROR	15		; STRANGE ERROR

GCEND1:	POPR	PSTQ		; RESTOR REGISTERS
	MOVE	Z,IGNOQ+3	; RELOAD Z
	SKIPN	IGNOQ+2		; GCOL ENTRY?
	JRST	0(QLINK)	; NO - JUST RETURN

	MOVE	Z,CEIL		; FIND AMOUNT
	SUB	Z,SURF		; OF ROOM LEFT
	JRST	0(QLINK)	; AND RETURN

;	BLOK - UTILITY FUNCTION (LAZY MAN'S CORE
;	ALLOCATION METHOD.	THE BLOK IS ZEROE'D.
;	CALLING SEQUENCE:
;	LOAD Z WITH	BTCODE,,BLENG
;	JSP	QLINK,BLOK
;	ERROR	(CURRENTLY NOT USED)
;	RETURN - BLOK IS ALLOCATED, DESCRIPTOR IS RETURNED ON STACK

BLOK::	HRRZ	Q2,Z		; GET LENGTH
	ADD	Q2,SURF		; FINAL POSITION OF SURF
	CAMLE	Q2,CEIL		; ARE WE BEYOND LIMITS
	JRST	BLOK1		; YES

	MOVEM	Z,BTCODE&BLENG(SURF) ; FIRST WORD
	HRRI	Q3,GCFLD+1(SURF)	; 'TO' ADDRESS
	HRLI	Q3,GCFLD(SURF)	; & 'FROM' ADDRESS FOR ...
	CLEARM	GCFLD(SURF)	; ZEROING OUT ...
	BLT	Q3,-1(Q2)	; THE BLOK

	HRR	Z,SURF		; FORM FIRST ...
	TLZ	Z,BLOKF		; WORD ...
	TLO	Z,FLDC		; OF RETURN DESCRIPTOR
	PUSH	STACK,Z		; AND ...
	PUSH	STACK,[0]	; RETURN IT.

	MOVE	SURF,Q2		; UPDATE SURFACE
	JRST	1(QLINK)	; AND RETURN

	 ; HERE IF A COLLECT IS NEEDED

BLOK1:	MOVEM	Z,BLOKSV##	; SAVE ARG
	MOVEM	Q1,BLOKSV+1	; SAVE LINK
	HRRZ	Z,Z		; NEED JUST THE AMOUNT
	JSP	QLINK,GCOLF	; ENSURE THIS MUCH
	MOVE	Z,BLOKSV	; RESTOR ...
	MOVE	Q1,BLOKSV+1	; THINGS
	JRST	BLOK		; AND START ANEW

	END
  @³