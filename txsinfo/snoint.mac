	SUBTTL	MA355/JDS/DRH/MP/RCM/VB		15-JUN-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	INTVER==5		;MAJOR VERSION NUMBER
	INTMIN==0		;MINOR VERSION NUMBER
	INTEDT==257		;EDIT LEVEL
	INTWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	INT,SNOINT,<The Interpreter>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	INTTTL			; Title
	INTPTX			; PASS2 assembly message
	SUBTTL	Table of Contents

;		Table of Contents for The Interpreter
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. PROGRAM INITIALIZATION . . . . . . . . . . . . . . . .    4
;   4. NORMAL STATEMENT PROCESSING. . . . . . . . . . . . . .    5
;   5. FAILURE PROCESSING . . . . . . . . . . . . . . . . . .    8
;   6. GOTO'S . . . . . . . . . . . . . . . . . . . . . . . .   10
;   7. TERMINATIONS (ERRST, ETERM, EOP, END, STAT). . . . . .   13
;   8. SP. FUNCS. (EVAL LINE NEG$ QUEST$ CVTVAL ASGNVL LOCVAL)  14
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
131	ADD SUPPORT FOR SNODDT & PAV.
153	Fix tracing of &STFCOUNT, it did not work.
164	Unevaluated expressions are now compiled out of line.
205	Add a title to every page of the output listing.
211	GET RID OF EXTRA PAGE ON LISTING FILE.
234	Fix  a problem with EVAL when it fails with &ERRTYPE set to > 1.
236	ReVISE THE FORMAT OF THE LISTING OUTPUT.
252	FIX EVAL (AGAIN) SO IT WORKS WHEN IT FAILS
257	Allow comment to follow semi-colon.
\

	SUBTTL	PROGRAM INITIALIZATION

;	CONTROL ARRIVES HERE FROM SYSTEM INTERFACE.
;	THE DATA AREA HAS BEEN INITIALIZED.

ISTART::
	DMOVE	T2,LISTF##	; THIS IS THE LISTING FILE.
	JSP	S3,PRINTF##	; Give title
	ERROR	15,		; Can't fail here.

	JSP	QLINK,MSTIME##	; GET TIME
	MOVEM	Z,TIME.S##	; LOG STARTING TIME
	JSP	PLINK,CODE##	; CALL COMPILER (NO ARGS.)
	ERROR	15		; HE CAN'T FAIL HERE

	JSP	QLINK,MSTIME	; OBTAIN COMPILATION OUT ...
	MOVEM	Z,TIME.C##	; TIME AND SAVE IT

	PUSHR	PST		; SAVE PST'S
	DMOVE	T2,LISTF	; GET LISTING FILE
	JUMPN	T3,ISTAF	; SKIP THIS IF NO LISTING FILE

	JSP	SLINK,LINE	; PRINT OUT END OF COMP. MESS
	XWD	LISTF##,1	; ..
	XWD	SDT,S.EOC##
	POPR	PST		; GET BACK P'S
ISTAF:	POP	STACK,T2	; STARTING POINT OFFSET TO T2...
	POP	STACK,T1	; AND LOCATION TO T1
	MOVEM	STACK,GROUND##	; THIS IS GROUND LEVEL FOR ALL 
				; STATEMENTS AT THIS LEVEL.
	CLEARM	PREX##		; CLEAR PRE-EXECUTION FLAG

	TRNN	T1,-1		; IS STARTING POINT A SYSTEM LABEL ?
	JRST	0(T2)		; YES, JUMP RIGHT TO IT
	dmovem	T1,ILOC##	; NO, STORE CBLOK LOCATION AND...
				; OFFSET IN ILOC BLOCK

	SKIPN	AUTOHS##	; AUTOMATIC HISTOGRAM?
	JRST	IBEGIN		; BEGIN STATEMENT PROCESSING 

	PUSH	STACK,[IDT,,0]	; GIVE ARGUMENT OF
	PUSH	STACK,[1]	; 1
	JSP	SLINK,KWHIST##+2 ; CALL HISTOGRAM MAKER
	ERROR	15		; ERROR RETURN
;	JRST	IBEGIN		; BEGIN PROCESSING

	SUBTTL	NORMAL STATEMENT PROCESSING

;	STATEMENT INITIALIZATION -
;
;	CONTROL ARRIVES HERE WHEN ANYONE WANTS TO BEGIN
;	EXECUTING A NEW STATEMENT.	ILOC CONTAINS THE LABEL
;	OF THE NEW STATEMENT.	ILABEL CONTAINS THE LABEL OF THE
;	STATEMENT THAT HAD BEEN EXECUTING.

IBEGIN::
IFN FTDDT,<
	MOVE	P1,ILOC		;GET CBLOCK ADDRESS
	ADD	P1,ILOC+1	;POINT TO STATEMENT
	HRRZ	P2,CHEAD(P1)	;GET CODE INTERPRETER FUNCTION ADDRESS
	JRST	(P2)		;GO
>;END OF IFN FTDDT
BGST::
	MOVE	STACK,GROUND##	; LOAD STACK FROM GROUND
	MOVE	Z,$STNO##	; PICK UP OLD STATEMENT NUMBER ...
	MOVEM	Z,$LASTN##	; FROM &STNO AND PLUG &LASTNO
	dmove	P1,ILOC##	; PICK UP NEW ...
				; LABEL FROM ILOC
	dmovem	P1,ILABEL##	; STORE INTO ...
				; ILABEL

	ADD	P1,P2		; ADDRESS OF NEW STATEMENT TO P1
	HLRZ	Z,CSTNO(P1)	; EXTRACT THE NEW STATEMENT NUMBER
	MOVEM	Z,$STNO##	; INSERT IT INTO &STNO KEYWORD

	AOS	S1,$STCNT##	; INCREMENT &STCOUNT.
	CAMLE	S1,$STLIM##	; SKIP IF &STCOUNT NOT ABOVE &STLIMIT
	ERROR	11,6		; EXCEEDED &STLIMIT
	SKIPE	$STCNT##+1	; IS &STCOUNT BEING TRACED?
	JSP	SLINK,STCTRC##	; CALL TRACE IF SO
	ADDI	P2,CRULE	; ADD OFFSET TO OBTAIN FIRST ...
				; ELEMENT WITHIN STATEMENT.
	
	MOVEM	P2,ILOC##+1	; UPDATE ILOC##



;	***** BASIC INTERPRETER LOOP *****
;
;	COME HERE TO PROCESS AN ELEMENT IN COMPILED CODE.

I.LOOP::SKIPA	P1,ILOC##+1	; LOAD P1 FROM ILOC##+1 AND SKIP
				; OVER INCREMENTING INSTRUCTION.
I.BUMP::AOS	P1,ILOC+1	; ADD ONE TO ILOC AND LOAD
				 ; RESULT INTO P1
	ADD	P1,ILOC		; ADD IN ADDRESS OF CBLOK
	MOVE	P2,0(P1)	; OBTAIN ELEMENT FROM CBLOK

	TLZE	P2,CDFF		; SKIP IF NOT A FUNCTION
	JRST	I.FN		; PROCESS FUNCTON AT I.FN

	PUSH	STACK,P2	; PUSH ARG ONTO STACK
	PUSH	STACK,[0]	; AS WELL AS ZERO WORD

IFE FTDDT,<
	JRST	I.BUMP		; GO BACK AND DO IT AGAIN.
>
IFN FTDDT,<
	JRST	@I.JRST##	; Continue loop if DDT event has not
				; occurred otherwise process the event
>;END OF IFN FTDDT

;	BRANCH TO I.FN IF A FUNCTION WAS ENCOUNTERED
;	IN THE COMPILED CODE. THIS COULD BE AN INTERPRETER
;	FUNCTION OR A USER FUNCTION. P2 CONTAINS THE ELEMENT

I.FN::	MOVEM	STACK,STSAVE##	; SAVE STACK IN CASE OF ERROR RECOVERY

	 ; HERE FROM APPLY

	TLZE	P2,CDIFF	; SKIP IF NOT AN INTERPRETER FUNCTION
	JRST	0(P2)		; BRANCH DIRECTLY TO INTERPRETER FUNCTION
	TLZ	P2,CDFLGS	; CLEAR ALL REMAINING FLAGS
	HLRZM	P2,IGNOP##	; SAVE NUMBER OF ACTUAL ARGUMENTS
	HRRZM	P2,IGNOP##+2	; SAVE FOR &ERRPARM
	HRR	P2,0(P2)	; GET ADDRESS OF FBLOK
	MOVE	P1,FFLAGS&FNARGS(P2)	; RETRIEVE FLAGS
	TLNN	P1,FEAFL	; SKIP TO EVALUATE ARGS
	JRST	I.SA		; JUMP TO SUPPLY ARGUMENTS

;	ENTER HERE TO EVALUATE ARGUMENTS.

I.EA:	MOVEI	S2,1(STACK)	; ADDRESS OF LAST DESCR +2 TO S2
	SUB	S2,IGNOP##	; POINT TO FIRST ...
	SUB	S2,IGNOP##	; ACTUAL ARGUMENT

;	TOP OF LOOP - EVALUATE DESCRIPTOR CURRENTLY
;	AT THE STACK POSITION DENOTED BY S2

I.EA1:	MOVE	S3,0(S2)	; DESCRIPTOR'S FIRST WORD TO S3
I.EA2:	TLNN	S3,NONDC	; SKIP IF NON DATA
	JRST	I.EA3		; IF DATA, BRANCH TO END OF LOOP

	TLNE	S3,TVDC		; SKIP IF NOT A TRAPPED VARIABLE
	JRST	I.ETV		; BRANCH TO EVALUATE TRAPPED VARIABLE

	ADD	S3,1(S2)	; ADD OFFSET TO VARIABLE

	MOVE	T1,1(S3)	; LOAD 2ND DESCRIPTOR WORD
	MOVEM	T1,1(S2)	; STORE INTO STACK
	MOVE	S3,0(S3)	; LOAD FIRST DESCRIPTOR WORD
	MOVEM	S3,0(S2)	; STORE INTO STACK

	JRST	I.EA2		; GO BACK AND EXAMINE DESCRIPTOR

;	HERE IF THE DESCRIPTOR IS A VALUE (NONDC = 0)
;	NOTHING TO DO BUT LOOP.
I.EA3:	ADDI	S2,2		; BUMP STACK CURSOR BY 2
I.EA4:	CAIG	S2,0(STACK)	; ARE WE PAST STACK TOP, SKIP IF SO
	JRST	I.EA1		; BACK FOR MORE PROCESSING
	JRST	I.SA



;	***** TRAPPED VARIABLE EVALUATION *****
;
;	HERE TO EVALUATE A TVAR; S2 POINTS TO DESCRIPTOR
;	BEARING THE TRAPPED VARIABLE.

I.ETV:	PUSH	STACK,0(S2)	; PUSH TRAPPED VARIABLE
	PUSH	STACK,1(S2)	; INTO TOP OF STACK
	MOVEM	S2,IGNOP##+1	; SAVE STACK POSITION

	HRLI	P2,FLDC		; SAFE STORE ...
	MOVEM	P2,FLAP##+2	; FLOATING ADDRESS

	MOVE	SLINK,1(S2)	; LOAD ENTRY POINT
	JSP	SLINK,0(SLINK)	; EVALUATE THE VARIABLE
	JRST	IFAIL		; JUMP ON FAILURE

	MOVE	P2,FLAP##+2	; RESTORE ADDRESS
	MOVE	S2,IGNOP##+1	; RESTORE S2
	POP	STACK,1(S2)	; POP INTO ...
	POP	STACK,0(S2)	; THE STACK
	JRST	I.EA1		; JUMP BACK TO EVALUATE ARGS LOOP

;	***** SUPPLYING MISSING ARGUMENTS AND MAKING THE CALL*****

;	CONTROL GOES TO I.SA AFTER EVALUATION OF ARGUMENTS.
;	FIRST COMPARE THE NUMBER OF PARAMETERS (P1-RIGHT) WITH
;	THE NUMBER OF ARGUMENTS ON STACK (IN IGNOP).	IF THESE
;	ARE THE SAME WE NEEDN'T CHECK FSAFL FLAG.

I.SA:	MOVE	Z,IGNOP##		; LOAD # OF ARGUMENTS
	CAIE	Z,0(P1)		; SKIP IF # OF ARGS = # OF PARAMS
	JRST	I.SA1		; BRANCH TO SUPPLY ARGUMENTS

;	HERE WHEN READY TO MAKE CALL
I.CALL:	JSP	PLINK,FCODE(P2)	; MAKE CALL
	JRST	IFAIL		; BRANCH OFF TO HANDLE FAILURE
	JRST	I.BUMP		; GO BACK AND REPEAT

; HERE IF THERE IS A DISCREPANCY BETWEEN THE # OF ARGS 
; AND THE NUMBER OF PARAMS.
I.SA1:	TLNE	P1,FAAFL	; SKIP IF ANY-ARGS FLAG IS OFF
	JRST	I.CALL		; ANY NUMBER CAN PLAY
	CAIL	Z,0(P1)		; SKIP IF # OF ARGS LT # OF PARAMS
	ERROR	13,0		; TOO MANY ARGUMENTS
	TLNN	P1,FSAFL	; SKIP IF SUPPLY-ARGS FLAG IS ON
	JRST	I.CALL		; OK, JUST MAKE CALL
	MOVE	S1,Z		; LOAD S1 WITH NUMBER ...
	SUBI	S1,0(P1)	; OF ARGUMENTS TO BE SUPPLIED

I.SALP:	PUSH	STACK,NULLST##	; PUSH NULL STRING ...
	PUSH	STACK,NULLST+1	; ONTO STACK
	AOJL	S1,I.SALP	; KEEP LOOPING UNTIL COUNT HAS BEEN...
	JRST	I.CALL		; REDUCED, THEN MAKE CALL


	SUBTTL	FAILURE PROCESSING

;	POINTS OF ENTRY:
;		IFAIL - ENTRY FROM ERROR HANDLER IN
;			AN ATTEMPT TO RECOVER FROM ERROR
;		I.FLA - FAILURE FROM TRAPPED VARIABLE

IFAIL::	MOVE	STACK,STSAVE##	; REESTABLISH STACK
			 ; THIS WAS SAVED PREVIOUSLY AT I.FN

	
I.FLA:	MOVE	S1,ILOC##		; S1 WILL POINT TO ...
	ADD	S1,ILOC##+1	; CURRENT FUNCTION
	HLRZ	S2,0(S1)	; PUT NUMBER OF ACTUAL ...
	ANDI	S2,CDARGS	; ARGS IN S2 RIGHT

;	REMOVE S2 DESCRIPTORS FROM THE STACK
I.FL1:	ASH	S2,1		; DOUBLE S2
	HRL	S2,S2		; MAKE BOTH HALVES SAME
	SUB	STACK,S2	; DECREMENT STACK
	CLEAR	S2,		; ZERO OUT S2

; LOOP TO FIND THE NEGATE FUNCTION.
;	IF A NEGATE FUNCTION IS FOUND WHOSE SCOPE INCLUDES
;	THE ITEM OR FUNCTION WHICH FAILED, THEN WE SHOULD
;	RETURN THE NULL STRING FOR THAT NEGATE.
;	S2 IS AN INTEGER USED TO DETERMINE WHETHER A FUNCTION
;	CONTAINS THE FAILED ITEM IN ITS SCOPE. 
;	IF S2 IS NEGATIVE THE FUNCTION DOES NOT 
;	CONTAIN THE FAILED ITEM.
;
I.FL2:	AOJ	S1,		; BUMP S1
	MOVS	S3,0(S1)	; LOAD S3 WITH ELEMENT (SWAPPED)
	TRNE	S3,CDIFF	; SKIP IF NOT INTERPRETER FUNC.
	JRST	I.FLIN		; GO HANDLE INT. FUNC.
	
;	GET NUMBER OF ARGS IN S3 OR 0 IF NOT A FUNC.
	TRNN	S3,CDFF		; SKIP IF A FUNCTION
	CLEAR	S3,		; NOT A FUNCTION
	ANDI	S3,CDARGS	; OBTAIN # OF ARGS

	ADDI	S2,0(S3)	; ADD THIS #  TO S2
	SOJL	S2,I.FL2	; AND SOJ BACK IF RESULT NEGATIVE
	JUMPG	S2,I.FL1	; IF GT 0 WE HAVE DESCRIPTORS TO 
				; REMOVE, ALSO CAN'T BE NEGATE FUNC.
	HRRZ	Q2,0(S1)	; POINT TO VFUNC FIELD
	JSP	QLINK,LFBLOK##	; GET POINTER TO FBLOK
	CAIE	Q2,NEG$##	; DO WE HAVE NEGATE FUNCTION?
	JRST	I.FL2		; NO , JUST LOOP BACK
	SUB	S1,ILOC##		; YES, UPDATE ...
	MOVEM	S1,ILOC##+1	; ILOC+1
	PUSH	STACK,NULLST	; PUSH NULL STRING ONTO ...
	PUSH	STACK,NULLST+1	; STACK. THIS IS NEG'S RET. VAL.
	JRST	I.BUMP		; GO BACK FOR MORE.



;	***** HALT OF NEGATE SEARCH *****
;
;	IF AN INTERPRETER FUNCTION WAS ENCOUNTERED WE STOP 
;	THE SCAN FOR NEGATE. IF THE SCAN POINT IS ALREADY
;	BEYOND THE FAIL GOTO FOR THIS STATEMENT, WE CAN'T TAKE THE 
;	FAIL GO TO FOR THIS WOULD IMPLY A LOOP.	IN THIS CASE WE 
;	GO ON TO THE NEXT STATEMENT.
;	IF WE ARE IN AN EBLOK, ENCOUNTERING AN INT. FUNCTION 
;	MEANS THAT WE ARE AT THE END OF THE EBLOK AND THAT 
;	EVAL MUST REPORT FAILURE.

I.FLIN:	HLRZ	Z,S3		; LOAD INTERPRETER FUNCTION ADDRESS

	CAIN	Z,EOE		; END OF EXPRESSION?
	JRST	EOEF		; YES - FAIL RETURN OF EVAL

	AOS	$STFCT##	; HERE MEANS STATEMENT FAILED
	SKIPE	$STFCT##+1	;[153] Test for &STFCOUNT being traced
	JSP	SLINK,STFTRC##	; YES - GO TRACE IT

I.FAIL::MOVE	P1,ILABEL##	; PICK UP CURRENT CBLOK POINTER
	ADD	P1,ILABEL##+1	; P1 POINTS TO CURRENT STATEMENT HDR.
	HRRZ	P2,CFGOTO(P1)	; OBTAIN FAIL GO TO OFFSET.
	CAMG	P2,ILOC##+1	; BEYOND LOC? THEN SKIP
	JRST	I.NEXT		; ELSE GO ON TO NEXT STATEMENT
	MOVEM	P2,ILOC##+1	; STORE FAIL OFFSET AS CURRENT
	MOVE	STACK,GROUND	; RE-ESTABLISH STACK BASE.
	JRST	I.LOOP		; GO BACK AND PROCESS FAIL GO TO

;	HERE TO GO TO NEXT STATEMENT.

I.NEXT:	MOVE	P1,ILABEL	; ESTABLISH POINTER ...
	ADD	P1,ILABEL+1	; TO THIS STATEMENT
	HRRZ	S1,CNEXT(P1)	; OFFSET FOR NEXT STATEMENT
	MOVEM	S1,ILOC+1	; THIS ESTABLISHES LOC. COUNTER
	CAMLE	S1,ILABEL+1	; NEW OFFSET IS NORMALLY GR. THAN OLD

	JRST	IBEGIN		; SO WE TAKE THIS BRANCH NORMALLY

;	NEW CBLOK
	MOVE	P1,ILABEL	; LOAD ADDR OF CURR. CBLOK
	HRR	P1,NCLINK(P1)	; LOAD ADDR OF NEXT CBLOK
	MOVEM	P1,ILOC		; INSTALL AS NEW LOCATION
	JRST	IBEGIN		; PROCESS NEW STATEMENT.


	SUBTTL	GOTO'S	(GOTO, DGOTO, IGOTO, LRGOTO)

;	GOTO - INTERPRETER FUNCTION - INSERTED INTO THE CBLOK
;	BY A NORMAL (PARENTHETICAL) GO TO.

GOTO::
	HLRZ	S1,-1(STACK)	; EXTRACT DATATYPE FROM VAL. ON STACK
	CAIE	S1,VAR		; NORMAL CASE IS VAR
	JRST	GOTONU		; NOT VAR - MUST BE NUMERIC
	SKIPE	0(STACK)	; IS VARIABLE NATURAL?
	ERROR	8,5		; UNNATURAL
	MOVEI	Q3,NDT		; TRANSFORM VAR TO NAME
	HRLM	Q3,-1(STACK)	; FOR &ERRPARM PURPOSES

	MOVE	S2,-1(STACK)	; LOAD POINTER TO VAR BLOCK
	MOVE	S3,VFLAGS(S2)	; PICK UP THE FLGS FIELD
	TLNE	S3,LTFLAG	; IS LABEL TRACED
	JRST	GOTO2		; YES - GO TRACE LABEL

;	MERGE HERE IF HE STOPS TRACING DURING THE TRACE
GOTO3:
	TLNN	S3,OPFLAG	; OPERATOR TEST
	SKIPN	S1,VLABEL(S2)	; LOAD S1 WITH LABEL AND TEST
	ERROR.	8,2		; UNDEFINED LABEL
	
GOTO3A:	HLRZ	S3,S1		; PICK UP LEFT HALF OF LABEL
	TRNN	S1,-1		; TEST FOR SYSTEM LABEL
	JRST	0(S3)		; YES - BRANCH OUT

	HRLI	S1,CDT		; FORM DESCRIPTOR TOP
	MOVEM	S1,ILOC		; STORE IT
	MOVEM	S3,ILOC+1	; STORE DESCRIPTOR BOTTOM

	JRST	IBEGIN		; BEGIN NEW STATEMENT

GOTO2:	JSP	SLINK,LTRC##	; TRACE THE LABEL
	MOVE	S2,-1(STACK)	; REESTABLISH POINTER TO VAR BL
	MOVE	S3,VFLAGS(S2)	; PICK UP TRACE FLAG AGAIN
	TLNN	S3,LTFLAG	; CHECK FOR TRACING AGAIN
	JRST	GOTO3		; JOIN NORMAL PROCESSING IF ITS OFF

	MOVE	S2,VLABEL(S2)	; POINT TO TRBLOK
	HRR	S1,TRVAL(S2)	; GET CBLOK ADDR
	HRL	S1,TRVAL+1(S2)	; GET OFFSET
	JUMPN	S1,GOTO3A	; JOIN REG. PROC.
	ERROR.	8,2		; UNDEFINED LABEL


;	***** NUMERIC GOTO *****
GOTONU:
	JSP	TLINK,CVTVAL	; MAKE IT A VALUE
	ERROR	15		; CAN'T FAIL
	JSP	TLINK,CVTINT##	; INSURE INTEGER
	ERROR.	8,2		; NO? - REALLY BAD

	MOVE	P2,0(STACK)	; GET INTEGER
	dmove	S1,ILABEL	; KEEP CBLOK ADDR IN S1
				; KEEP OFFSET IN S2

GOTON1:	MOVE	S3,S1		; KEEP SUM ...
	ADDI	S3,0(S2)	; IN S3

	JUMPL	P2,GOTOB	; GO BACKWARDS IF P2 IS NEGATIVE
	SOJL	P2,GOTONE	; END SEARCH IF P2 IS 0

	HRRZ	T1,CNEXT(S3)	; LOAD NEXT OFFSET
	CAMLE	T1,S2		; SHOULD COMPARE HIGH
	JRST	GOTOLP		; BRANCH IF SO

	HRR	S1,NCLINK(S1)	; ESTABLISH NEW CBLOK
	TRNN	S1,-1		; CHECK ADDRESS FOR 0
	ERROR	8,7		; 0 - END OF LINE
	JRST	GOTOLP		; GO LOOP IF OK

;	HERE FOR A NEGATIVE (BACKWARD) GO TO.
GOTOB:	ADDI	P2,1		; KEEP BUMPING P2
	HLRZ	T1,CLAST(S3)	; PICK UP LAST OFFSET
	CAMGE	T1,S2		; SHOULD BE LESS THAN BEFORE
	JRST	GOTOLP		; IT IS - LOOP

	HRR	S1,LCLINK(S1)	; GET LAST CBLOK
	TRNN	S1,-1		; TEST FOR 0 ADDRESS
	ERROR	8,7		; 0 - END OF THE LINE

;	END OF NUMERIC GOTO LOOP
GOTOLP:
	MOVE	S2,T1		; TRANSFER OFFSET TO S2
	JRST	GOTON1		; SEEK ANOTHER INCREMENT

;	END OF NUMERIC GO TO
GOTONE:
	dmoveM	S1,ILOC		; NEW LOCATION IS GIVEN ...
				; BY S1 & S2
	JRST	IBEGIN		; START NEW STATEMENT


;	***** THE DIRECT GO TO *****
;	I.E. GOTO 'S WITH ANGULAR BRACKETS
DGOTO::
	JSP	TLINK,CVTVAL	; MAKE IT A VALUE
	ERROR	8,6		; BAD ARGUMENT
	HLRZ	P2,-1(STACK)	; GET DATATYPE
	CAIE	P2,CDT		; MUST BE TYPE CODE.
	JRST	GOTONU		; TRY NUMERIC GOTO
	POP	STACK,ILOC+1	; INSERT AS
	POP	STACK,ILOC	; NEW LABEL
	JRST	IBEGIN		; AND GO THERE

;	IMMEDIATE GOTO - THIS IS AN INTERPRETER FUNCTION USED
;	FOR HOPPING AROUND CODE.
IGOTO::
	MOVE	P2,ILOC+1	; PICK UP CURRENT CODE OFFSET
	ADD	P2,ILOC		; ADD IN BASE OF CBLOK
	MOVE	P1,1(P2)	; PICK UP NEXT ITEM IN CBLOK
	HRRZM	P1,ILOC+1	; THIS IS NEW VALUE FOR ILOC
	JRST	I.LOOP		; BEGIN AGAIN.

;	LONG RANGE GO TO - THIS IS AN INTERPRETER FUNCTION FOR 
;	SKIPPING TO THE NEXT CBLOK
LRGOTO::
	MOVE	P2,ILABEL	; POINT TO CBLOK HEAD
	HRR	P2,NCLINK(P2)	; INSERT IN P2 THE NEXT ADDR.
	MOVEM	P2,ILOC		; ESTABLISH THIS AS ILOC
	MOVEI	P2,CCODE	; LOAD OFFSET TO CODE IN NEW CBLOK
	MOVEM	P2,ILOC+1	; PLACE INTO OFFSET

	JRST	IBEGIN		; BEGIN WITH ILOC AS NEW


	SUBTTL	TERMINATIONS (ERRST, ETERM, EOP, END, STAT)

;	HERE IF AN ERRONEOUS STATEMENT IS EXECUTED.
ERRST::	ERROR	4,2		; NOTHING SUBTLE HERE

;	HERE WHEN END OF PROGRAM IS REACHED
EOP::

;	HERE WHEN END OF PROGRAM IS BRANCHED TO
END::
	SKIPLE	AUTOHS		; WAS END FROM AUTO-HISTOGRAM?
	JRST	CLOSIO		; YES

	JSP	QLINK,MSTIME##	; GET CURRENT TIME
	MOVEM	Z,TIME.E##	; INDICATE AS ENDING TIME

	JSP	SLINK,LINE	; PRINT NORM-TERM MESSAGE
	6
	XWD	SDT,[12,,1]
	XWD	SDT,S.NORM##
	XWD	IDT,$FNCLV##	; INDICATE FUNCTION LEVEL
	XWD	SDT,S.SMNT##
	XWD	IDT,$STNO##	; INDICATE LAST ST. EXEC.
	XWD	SDT,[135,,1]

	JRST	STAT		; GO GIVE STATISTICS

;	HERE FROM ERR FOR FATAL TERM.
ETERM::
	JSP	SLINK,LINE	; PRINT ERROR-TERM MESSAGE
	4
	XWD	SDT,[12,,1]
	XWD	SDT,S.LAST##
	XWD	IDT,$STNO##	; LAST STMT NO.
	XWD	SDT,[135,,1]	; END BRACKET

	JRST	STAT		; GO GIVE STATISTICS

;	HERE TO PUT OUT STATISTICS SUMMARY
STAT:
	MOVE	S1,$DUMP##	; &DUMP ON?
	JUMPLE	S1,STAT2	; NO

	JSP	SLINK,LINE	; WARN
	XWD	XERRF##,3		; USER
	XWD	SDT,[14,,1]	; THAT
	XWD	SDT,S.DMP##	; A DUMP
	XWD	SDT,[12,,1]	; IS COMMING

	PUSH	STACK,[IDT,,0]	; PUSH ARGUMENT
	PUSH	STACK,$DUMP##	; FOR DUMP
	CLEARM	$DUMP##		; ROUTINE
	JSP	PLINK,DUMP$##+FCODE ; CALL DUMP
	ERROR	15		; CAN'T FAIL
	SUB	STACK,XWD22##	; POP OFF RETURN VALUE

STAT2:	 ;

	SKIPN	LISTF##		; SKIP STAT IF NO 
	JRST	CLOSIO		; LIST FILE

	MOVEI	Z,1		; ARGUMENT FOR PRINTE
	MOVEM	Z,NLMPGN##	; ..
	SETZM	NLPGNO##	; ..
	JSP	S3,PRINTE##	; PRINT TITLE.
	 ERROR	12,2		;  SHOULDN'T HAPPEN.

	JSP	SLINK,LINE	; STATISTICS HEADER
	1
	XWD	SDT,S.STAT##

	MOVE	P2,TIME.C	; GET TIME OUT OF COMPILER
	SUB	P2,TIME.S	; SUBTRACT STARTING TIME
	JSP	SLINK,LINE	; PRINT COMPILATION TIME
	2
	XWD	IDT+10,P2
	XWD	SDT,S.CMTM##

	MOVE	P2,TIME.E	; GET ENDING TIME
	SUB	P2,TIME.C	; SUBTRACT TIME OUT OF COMP.
	JSP	SLINK,LINE	; PRINT EXECUTION TIME
	2
	XWD	IDT+10,P2
	XWD	SDT,S.EXTM##

	IMULI	P2,^D1000	; MULTIPLY TO GET MICROSEC.
	SKIPN	$STCNT##		; TEST THE STATEMENT COUNT FOR 0
	JRST	STAT1		; 0 - AVOID DIVISION BY
	IDIV	P2,$STCNT##	; FIND AVERAGE
	JSP	SLINK,LINE	; PRINT AVE. TIME
	2
	XWD	IDT+10,P2
	XWD	SDT,S.AVE##

	JSP	SLINK,LINE	; INDICATE ...
	4
	XWD	IDT+10,$STCNT	; NUMBER OF ...
	XWD	SDT,S.STE STATEMENTS EXECUTED
	XWD	IDT+10,$STFCT	; NUMBER OF ...
	XWD	SDT,S.FLD##	; STATEMENTS FAILED

STAT1:	JSP	SLINK,LINE	; NO OF GC'S
	2
	XWD	IDT+10,NGCS##
	XWD	SDT,S.GC##

	JSP	SLINK,LINE	; NO OF READS
	2
	XWD	IDT+10,NINS##
	XWD	SDT,S.NINS##

	JSP	SLINK,LINE	; NO. OF WRITES
	2
	XWD	IDT+10,NOUTS##
	XWD	SDT,S.NOUT##
	
	 ; STORAGE STATISTICS

	JSP	PLINK,KSTAT	; PUT OUT HIGH SEG
	XWD	.JBHRL,S.HGH##	 ; GIVE ARGS

	MOVE	P2,CEIL##		; GET CURRENT
	ADDI	P2,MARGIN	; HIGH
	SKIPN	HIWATR		; WAS THIS FILLED?
	MOVEM	P2,HIWATR##	; NO FILL IT

	MOVEM	P2,IGNOP##	; SAVE CEIL

	JSP	PLINK,KSTAT	; HIGH WATER MARK
	XWD	HIWATR,S.MLOW## ;

	JSP	PLINK,KSTAT	; LOW SEGMENT
	XWD	IGNOP##,S.LOW##	; MESSAGE
	MOVE	P2,IGNOP##	; LOAD CEIL
	SUB	P2,FLOOR##	; SUBTRACT OFF FLOOR

	JSP	SLINK,LINE	; FLOATING STORAGE
	XWD	0,2
	XWD	IDT+16,P2
	XWD	SDT,S.FLID##

	MOVE	P2,FLOOR	; COMPUTE SIZE OF
	SUB	P2,GRID##	; GRID

	JSP	SLINK,LINE	; GROWING STORAGE
	XWD	0,2
	XWD	IDT+16,P2
	XWD	SDT,S.GRID##

	MOVE	P2,GRID		; COMPUTE
	HRRZ	S1,NSBASE##	; TOTAL LENGTH OF 
	SUBI	P2,1(S1)	; STACKS

	JSP	SLINK,LINE	; TOTAL STACKS
	XWD	0,2
	XWD	IDT+16,P2
	XWD	SDT,S.STKS##

	JSP	PLINK,STKST	; NAME STACK
	XWD	NSBASE,HSBASE##
	XWD	0,S.NST##

	JSP	PLINK,STKST	; HISTORY (ALTERNATES) STACK
	XWD	HSBASE,STBASE##
	XWD	0,S.HST##

	MOVE	P2,GRID		; NEED GRID
	SUBI	P2,1		; MINUS 1
	MOVEM	P2,IGNOP##	; IN A LOCATION

	JSP	PLINK,STKST	; SYSTEM STACK
	XWD	STBASE,IGNOP##
	XWD	0,S.SST##

	JSP	SLINK,LINE	; VARIABLE TABLE
	XWD	0,2
	XWD	IDT+16,LVTBL##
	XWD	SDT,S.VTBL##


	 ; HERE TO PREPARE AUTOMATIC HISTOGRAM

	SKIPL	AUTOHS##	; TEST FLAG FIRST
	JRST	CLOSIO		; JUST RETURN

	PUSH	STACK,SYSTR##	; SNOBOL4 PROGRAM
	PUSH	STACK,S.HIST##	; TO MAKE A HISTOGRAM
	JSP	PLINK,CODE	; COMPILE IT
	ERROR	15

	POP	STACK,ILOC+1	; AND GO
	POP	STACK,ILOC	; EXECUTE

	MOVEI	Q1,1		; NOW
	MOVEM	Q1,AUTOHS	; SET FLAG TO AVOID THIS PLACE.

	JRST	IBEGIN		; OFF TO EXECUTE NEW CODE
	JRST	CLOSIO##	; RETURN TO GOD

	 ; STKST - SUBROUTINE USED BY THE ABOVE STACK 
	 ; STATISTICS PRINTOUT.
	 ; CALLING SEQUENCE:
	 ;	JSP	PLINK,STKST
	 ; 	XWD	BASE,TOP
	 ;	XWD	0,S.ID

STKST:	HRRZ	P2,0(PLINK)	; POINT TO 
	HRRZ	P2,0(P2)	; TOP OF STACK

	HLRZ	S1,0(PLINK)	; POINT TO
	HRRZ	S1,0(S1)	; BOTTOM

	MOVE	S2,P2		; SAVE TOP
	SUB	P2,S1		; COMPUTE LENGTH

STKST2:	SKIPE	0(S2)		; FOUND A NON-ZERO?
	JRST	STKST1		; YES

	SOS	S2		; DEDUCT 1
	CAMLE	S2,S1		; END REACHED YET?
	JRST	STKST2		; NO - JUST LOOP

STKST1:	SUBI	S2,0(S1)	; FIND NET
	MOVEM	S2,IGNOP##	; SAVE

	PUSH	STACK,SYSTR	; PUSH
	MOVE	S3,1(PLINK)	; ID 
	PUSH	STACK,0(S3)	; FOR STACK

	JSP	SLINK,LINE	; WRITE LINE
	XWD	0,4		; # ARGS
	XWD	IDT+23,P2	; LENGTH
	XWD	STACK,1		; ID STRING
	XWD	SDT,S.USED##	; AMOUNT ACUALLY USED
	XWD	IDT,IGNOP##	; AND THE VALUE

	JRST	2(PLINK)	; RETURN

	 ; KSTAT - WRITES OUT STORAGE STATISTIC IN TERMS OF K
	 ; CALLING SEQUENCE:
	 ;	JSP PLINK,KSTAT
	 ;	EXP LOC1,S.ID
	 ; PUTS OUT MESSAGE AT S.ID OF CONTENTS OF LOC1

KSTAT:	HLRZ	S1,0(PLINK)	; LOAD ADDRESS OF LOC1
	MOVE	P2,0(S1)	; PICK UP VALUE
	ANDI	P2,377777	; MASK OUT LEFT AND HIGHBIT
	LSH	P2,-^D10	; DIVIDE BY K
	ADDI	P2,1		; USE CEILING
	PUSH	STACK,SYSTR	; START PUSHING THE STRING
	MOVE	S1,0(PLINK)	; GET ADDR OF S.ID
	PUSH	STACK,0(S1)	; PUSH 2ND HALF

	JSP	SLINK,LINE	; PRODUCE THE WRITE-OUT
	XWD	0,2
	XWD	IDT+7,P2
	XWD	STACK,1

	JRST	1(PLINK)	; AND RETURN


	SUBTTL	SP. FUNCS. (EVAL LINE NEG$ QUEST$ CVTVAL ASGNVL LOCVAL)

;	THE PRIMARY FUNCTION EVAL
;	MAKE SURE VALUE IS AN EXPRESSION
;	ALSO PUSH THE CURRENT 'STATE'.
EVAL::	MOVE	Z,-1(STACK)	; GET FIRST DESCR. WORD
	CAME	Z,NULLST	; IS IT THE NULL STRING?
	TLNE	Z,NUMDC		; OR IS IT A NUMBER?
	JRST	1(PLINK)	; RETURN IF EITHER

	HLRZ	Z,-1(STACK)	; GET DATATYPE
	CAIN	Z,EDT		; IF ALREADY EXPRESSION ...
	JRST	EVAL1		; AVOID CONVERT
	JSP	TLINK,CVTSTR	; TO STRING
	ERROR.	1,66		; BAD ARGUMENT

EVAL1:	MOVEI	P2,-1(STACK)	; POINT TO ARG
	$PUSH	<P1,P2>		;[242] Save the P registers
	PUSHSA	MI		; SAVE INTERP. AND PATT. MTCH. STATE
	PUSH	STACK,0(P2)	; PUSH ...
	PUSH	STACK,1(P2)	; ARGUMENT
	JSP	PLINK,CVTEXP##	; CONVERT
	JRST	EVAL2		; BAD SYNTAX - GO FAIL
	POP	STACK,ILOC+1	; RETRIEVE ...
	POP	STACK,ILOC	; EXPRESSION
	JRST	I.LOOP		; GO 'EXECUTE' EXPRESSION



;	SUCCESS RETURN TO EOE - FAIL RETURN TO EVAL2
EVAL2:	SUB	STACK,XWD22	;POP STACK
EOEF:	MOVEI	S1,1			; SIGNAL A FAIL
	JRST	EOEG	;COMMON MERGE
EOE::	POP	STACK,FLAP##+1	; POP ...
	POP	STACK,FLAP##	; RETURNED VALUE.
	SETZ	S1,		; 0 IN S1 MEANS SUCCESS
EOEG:	POPSA	MI		; RESTORE ...
	$POP	<P2,P1>		;[242] Restore the P registers
	SUB	STACK,XWD22##	; POP ORIGINAL ARG
	JUMPN	S1,0(PLINK)	; FAIL EXIT
	PUSH	STACK,FLAP	; GOTTEN VALUE IS ...
	PUSH	STACK,FLAP+1	; PUSHED BACK ON STACK
	JRST	1(PLINK)	; TAKE SUCCESS EXIT


;	***** THE UTILITIES - LINE & LINE. *****
;
;	CALLING SEQUENCE:
;	JSP	SLINK,LINE
;	XWD	FILE,N	; IO-DESCRIPTOR,# OF ARGS
;	XWD	TYPE1,LOC1
;	XWD	TYPE2,LOC2
;	...
;	XWD	TYPEN,LOCN
;
;	TYPE= SDT, IDT+K OR STACK
;	LOC=	(FOR SDT) LOCATION OF 2ND WORD OF STRING
;		DESCRIPTOR. FIRST WORD IS $ALPHA OR SYSTR
;	 =	(FOR IDT+K) LOCATION OF INTEGER.
;		INTEGER IS PRINTED IN IK FORMAT.
;	 =	(FOR STACK) 1,2,3 ... INDICATING 1ST, 2ND,
;		3RD ... DESCRIPTOR ON STACK (STACK POPPED).
;
;	JSP	SLINK,LINE.	DOES THE SAME THING EXCEPT A 
;	WRITE IS AVOIDED AND THE STRING IS RETURNED.
;
;	ROLES PLAYED BY VARIOUS S-TYPE LOCATIONS.
;
;	S1 - MEANDERS OVER THE ARGUMENT LIST
;	S2 - KEEPS TRACK OF THE # OF ARGS TO LINE
;	S3 - GENERAL UTILITY
;	IGNOS - ARG. COUNT FOR CONCAT
;	IGNOS+1 - HOLDS INITIAL VALUE OF STACK
;	IGNOS+2 - FLAG (0 OR -1) INDICATING ENTRY
;	IGNOS+3 - MAX. STACK REFERENCE

LINE::
	CLEARM	IGNOS##+2		; ENTRY POINT FLAG
	SKIPA
LINE.::
	SETOM	IGNOS##+2	; ENTRY POINT FLAG
	CLEARM	IGNOS##		; INITIALIZE ARG COUNT (CONCAT)
	CLEARM	IGNOS##+3		; MAX. STACK REF.
	MOVEM	STACK,IGNOS##+1   ; SAVE STACK
	HRRZ	S2,0(SLINK)	; ARG COUNT FOR LINE
	ADDI	S1,1(S2)	; S1 WILL POINT TO ARGS.



;	TOP OF LOOP - HERE TO GET NEXT ARG
LINE1:	SOJ	S1,		; COUNTING DOWN
	HLRZ	Z,0(S1)		; PICK UP TYPE
	CAIE	Z,SDT		; SKIP IF STRING
	JRST	LINE2		; TRY SOMETHING ELSE

;	FALL THROUGH FOR STRINGS
	MOVE	S3,0(S1)	; PICK UP LOC
	HRRZ	T1,0(S3)	; GET LENGTH
	MOVEI	T2,$ALPHA##	; USE $ALPHA
	CAIE	T1,1		; IF LENGTH = 1
	MOVEI	T2,SYSTR	; ELSE USE SYSTR
	PUSH	STACK,0(T2)	; PUSH FIRST WORD
	PUSH	STACK,0(S3)	; PUSH 2ND WORD

	AOS	IGNOS		; INCREASE CONCAT ARG COUNT
	SOJG	S2,LINE1	; LOOP ON S2
	JRST	LINE3		; END OF PROCESSING

;	HERE IF NOT SDT
LINE2:	TRNN	Z,NUMDC		; SKIP IF IDT
	JRST	LINE2A		; NOT IDT - BRANCH

	SUBI	Z,IDT		; DETERMINE FORMAT LENGTH

	MOVSI	S3,IDT		; FOR 1ST DESCRIPTOR WORD
	PUSH	STACK,S3	; AND PUSH ONTO STACK
	MOVE	S3,0(S1)	; PICK UP LOC
	PUSH	STACK,0(S3)	; PUSH ACTUAL INTEGER

	MOVE	S3,Z		; SAVE FORMAT LENGTH

	JSP	TLINK,CVTSTR##	; CONVERT INTEGER TO STRING
	ERROR	15		; CAN'T FAIL

	AOS	IGNOS		; INCR. ARG COUNT FOR CONCAT
	HRRZ	Z,0(STACK)	; EXTRACT LENGTH OF STRING
	SUBM	S3,Z		; DEDUCT LENGTH FROM FORMAT
				; (RESULT TO Z)
	JUMPLE	Z,LINE4		; AVOID PREFIX IF NOT NEEDED

	PUSH	STACK,$ALPHA	; PUSH BLANK
	PUSH	STACK,[" ",,1]	; ONTO STACK
	JSP	TLINK,DUPLI##	; OBTAIN PAD CHAR.
	ERROR	15		; BAD FORMAT

	AOS	IGNOS		; INCREMENT CONCAT ARG CNT

;	MERGE HERE IF BLANKS NOT NEEDED
LINE4:
	SOJG	S2,LINE1	; LOOP ON S2
	JRST	LINE3		; FINAL WRAP-UP

;	DRIFT HERE FROM NO SDT, NO IDT CASE
LINE2A:
	CAIE	Z,STACK		; IS IT STACK
	ERROR	15		; CAN'T BE OTHERWISE


	HRRZ	S3,0(S1)	; GET INDEX OF STACK ELEMENT
	CAMLE	S3,IGNOS+3	; GREATER THAN ANY PREV.?
	MOVEM	S3,IGNOS+3	; YES - NEW HIGH
	HRRZ	T1,IGNOS+1	; RETRIEVE STACK POINTER
	SUBI	T1,0(S3)	; ADJUST TO POINT TO ...
	SUBI	T1,0(S3)	; DESCRIPTOR - 1

	PUSH	STACK,1(T1)	; PUSH FIRST WORD
	PUSH	STACK,2(T1)	; AND SECOND WORD
	JSP	TLINK,CVTSTR	; ENSURE ...
	ERROR	15		; STRING

	AOS	IGNOS		; INCREASE ARG COUNT (CONCAT)
	SOJG	S2,LINE1	; LOOP ON S2

;	HERE IF NO ARGS ARE LEFT
LINE3:	MOVE	Z,IGNOS		; ARG COUNT FOR CONCAT
	CAIG	Z,1		; MORE THAN 1 ARG
	JRST	LINE6		; NO - DON'T CONCAT
	JSP	TLINK,CONCAT##	; CONCATENATE ALL
	ERROR	15

;	JUMP HERE FROM NO CONCAT
LINE6:
	SKIPE	IGNOS+2		; SKIP IF ENTRY WAS LINE
	JRST	LINE5		; AVOID WRITE

; DETERMINE AND LOAD FILE
	HLRZ	S2,-1(S1)	; PICK UP FILE DESCR
	SKIPN	S2		; DEFAULT IS ...
	MOVEI	S2,LISTF	; LISTF
	DMOVE	T2,0(S2)	; MOVE FILE
				; DESCR INTO REGS.

	JSP	TLINK,WRITE##	; WRITE THE RECORD
	ERROR	12,5	

;	MERGE HERE FROM NO WRITE CASE
LINE7:
; POP STACK BY MAX STACK ARG
	HRR	S3,IGNOS+3	; MAX STACK ARG
	LSH	S3,1		; DOUBLED
	HRL	S3,S3		; BOTH HALVES
	SUB	STACK,S3	; POP STACK

; RETURN TO SENDER
	HRRZ	S2,-1(S1)	; LOAD # OF ARGS
	ADDI	S1,0(S2)	; FIND RETURN LOC
	SKIPN	IGNOS+2		; SKIP IF ENTRY WAS LINE.
	JRST	0(S1)		; RETURN FROM LINE
	PUSH	STACK,FLAS##	; PUSH STRING
	PUSH	STACK,FLAS##+1	; BACK ONTO STACK
	JRST	0(S1)		; RETURN FROM LINE.

; HERE IF NO WRITE 
LINE5:	POP	STACK,FLAS##+1	; SIMULATE WRITE
	POP	STACK,FLAS	; BY POPPING STACK
	 JRST	LINE7		; JOIN NORMAL PROCESSING



;	***** THE PRIMARY FUNCTION NEGATE (\) *****


	 ; THE ARGUMENT IS NOT EVALUATED BECAUSE FAILURE
	 ; DURING EVALUATION BY THE INTERPRETER WOULD NOT
	 ; WORK FOR INPUT-ASSOCIATED VARIABLES

NEG::	JSP	TLINK,CVTVAL	; MAKE A VALUE OUT OF IT
	JRST	RETNL1##	; TURN FAILURE INTO SUCCESS
	JRST	FRET1##		; TURN SUCCESS INTO FAILURE


;	***** THE PRIMARY FUNCTION - INTEROGATION (?) *****

;	FUNC	QUEST$,1,E
;	JRST	RETNL1##	; JUST RETURN NULL


;	***** THE UTILITY ASGNVL *****
; CALLING SEQUENCE:
;	JSP	TLINK,ASGNVL
;	FAIL		; STACK CLEARED
;	SUCCESS	; VARIABLE REMAINS, VALUE IS POPPED

ASGNVL::
	HLRZ	Z,-3(STACK)	; PICK UP DATATYPE OF 1ST ARG
	CAIE	Z,VAR		; IF VARIABLE, SKIP
	JRST	ASGN1		; ASSIGN TO THE TRAPPED VARIABLE

	MOVE	T2,-3(STACK)	; GET POINTER ...
	ADD	T2,-2(STACK)	; TO CURRENT DESCRIPTOR VALUE

	HLRZ	Z,0(T2)		; LOAD DATATYPE
	CAIN	Z,TVAR		; CHECK FOR TRAPPED VARIABLE
	JRST	ASGN2		; JUMP IF ITS A TRAP

	POP	STACK,1(T2)	; POP VALUE ...
	POP	STACK,0(T2)	; INTO VARIABLE
	JRST	1(TLINK)	; AND RETURN

;	HERE IF VARIABLE POINTS TO TRAPPED VARIABLE
ASGN2:	MOVE	Z,0(T2)		; PICK UP TRAPPED VARIABLE
	MOVEM	Z,-3(STACK)	; PLACE INTO STACK
	MOVE	Z,1(T2)		; PICK UP 2ND WORD OF TV
	MOVEM	Z,-2(STACK)	; PLACE IT IN STACK
	JRST	ASGN3		; FLOW AROUND OBSTACLE

;	HERE IF NOT A VARIABLE
ASGN1:	CAIE	Z,TVAR		; BETTER BE A TRAPPED V.
	ERROR	14,9		; NO - ILLEGAL ACT

;	MERGE HERE FROM ABOVE
ASGN3:
	MOVE	T3,STACK	; SAVE CURRENT STACK POSITION
	PUSHSA	S		; ELEVATE PRIVILEGE
	PUSHR	ST		; TO THAT OF TYPE S
	PUSH	STACK,-3(T3)	; BRING ...
	PUSH	STACK,-2(T3)	; UP VALUES ...
	PUSH	STACK,-1(T3)	; FROM ...
	PUSH	STACK,0(T3)	; DOWN BELOW

	MOVE	SLINK,-2(STACK)	; POINT TO TV LOC
	JSP	SLINK,2(SLINK)	; SPRING OFF TO DO ASSIGN.
	TDZA	Q1,Q1		; ON FAIL SET Q1 TO 0
	MOVEI	Q1,1		; ON SUCCESS SET Q1 TO 1

	POP	STACK,FLAT##+1	; POP THE TRAPPED VARIABLE
	POP	STACK,FLAT##
	POPR	ST		; RESTORE ...
	POPSA	S		; THE STACK
	
	CAME	T3,STACK	; A LITTLE CHECK
	ERROR	15		; ON STACK CORRECTEDNESS

	SUB	STACK,XWD44##	; REMOVE BOTH VALUES 
	JUMPE	Q1,0(TLINK)	; FAIL IF Q1 = 0
	PUSH	STACK,FLAT	; RESTORE TRAPPED VARIABLE
	PUSH	STACK,FLAT+1
	JRST	1(TLINK)	; TAKE SUCCESS EXIT


;	***** THE UTILITY CVTVAL *****

;	CONVERTS AN ARBITRARY DESCRIPTOR TO A VALUE
; CALLING SEQUENCE:
;	PUSH A DESCRIPTOR ONTO STACK
;	JSP	TLINK,CVTVAL
;	FAIL	; THE ORIGINAL DESCRIPTOR IS LEFT ON STACK
;	SUCCESS	; A VALUE DESCRIPTOR REPLACES THE DESCR. 

CVTVAL::
	HLRZ	Z,-1(STACK)	; GET DATATYPE TO Z
	TRNN	Z,NONDC		; SKIP IF NOT ALREADY A VALUE
	JRST	1(TLINK)	; IMMEDIATE SUCCESSFUL RETURN

	TRNN	Z,INDC		; SKIP IF A VARIABLE OR CONSTANT
	JRST	CVTVL1		; BRANCH IF OTHER

	MOVE	T2,-1(STACK)	; GET ADDRESS OF
	ADD	T2,0(STACK)	; NEW DESCRIPTOR

	SUB	STACK,XWD22##	; POP OLD VALUE
	PUSH	STACK,0(T2)	; PUSH THIS ...
	PUSH	STACK,1(T2)	; DESCRIPTOR AND
	JRST	CVTVAL		; DO IT AGAIN

;	HERE FOR TRAPPED VARIABLES
CVTVL1:	CAIE	Z,TVAR		; CHECK IF TRAPPED
	ERROR	15		; REAL TROUBLE
	MOVEI	T2,-1(STACK)	; POINT TO TRAPPED VARIABLE
	PUSHSA	S		; ELEVATE PRIV TO 
	PUSHR	ST		; THAT OF TYPE S
	PUSH	STACK,0(T2)	; PUSH ...
	PUSH	STACK,1(T2)	; TV
	MOVE	SLINK,0(STACK)	; POINT TO LOC
	JSP	SLINK,0(SLINK)	; MAKE CALL TO GET VALUE
	TDZA	Q2,Q2		; SET Q2 TO 0 FOR FAIL
	MOVEI	Q2,1		; OTHERWISE TO 1
	POP	STACK,FLAQ##+1	; RETRIEVE ...
	POP	STACK,FLAQ##	; VALUE
	POPR	ST		; RETORE CONDI-
	POPSA	S		; TIONS
	SUB	STACK,XWD22##	; REMOVE OLD VALUE
	PUSH	STACK,FLAQ	; PUT
	PUSH	STACK,FLAQ+1	; RETURNED VALUE BACK ON STACK
	JUMPE	Q2,0(TLINK)	; AND TAKE APPROPRIATE ...
	JRST	CVTVAL		; TRY AGAIN


;	***** THE UTILITY, LOCVAL *****

; CALLING SEQUENCE:
;	LOAD	Q2 WITH ADDRESS OF DESCRIPTOR
;	JSP	QLINK,LOCVAL
;	RETURN		; Q2 IS ADJUSTED TO POINT TO VALUE

LOCVAL::
	HLRZ	Z,0(Q2)		; PICK UP DATATYPE
	TRNN	Z,NONDC		; SKIP IF NOT DATA
	JRST	0(QLINK)	; RET IMM. IF ALREADY DATA

	TRNN	Z,INDC		; TEST FOR INDIRECT DATA
	JRST	LOCVL1		; NO - MUST BE TVAR

	MOVE	Q3,0(Q2)	; PICK UP FIRST DESCR. WORD
	ADD	Q3,1(Q2)		; ADD IN OFFSET
	HRR	Q2,Q3		; MAKE Q2 POINT THERE
	JRST	LOCVAL		; ONCE AROUND AGAIN.

;	HERE IF TRAPPED VARIABLE
LOCVL1:	CAIE	Z,TVAR		; MIGHT AS WELL CHECK
	ERROR	15		; OUR ERROR

	MOVE	Q2,0(Q2)	; POINT TO UTBLOK
	MOVEI	Q2,LHDR(Q2)	; VALUE IS HERE
	JRST	LOCVAL		; CHECK AGAIN


	END
  >dR4m