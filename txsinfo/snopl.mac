	SUBTTL	Gimpel--Ma355/JDS/DRH/MP/RCM/VB		15-Jun-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	UUOSYM		;TOPS10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION

	PLVER==5		;MAJOR VERSION NUMBER
	PLMIN==0		;MINOR VERSION NUMBER
	PLEDT==207		;EDIT LEVEL
	PLWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	PL,SNOPL,<Local Pattern Routines>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%UUOS		;VERSION NUMBER OF UUOSYM
	SHOW.	%%SNOP	;VERSION NUMBER OF SNOPRM



	PLTTL			; Title
	PLPTX			; PASS2 message
	SUBTTL	Table of Contents

;		Table of Contents for Local Pattern Routines
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. CVTPAT - CONVERT TO PATTERN UTILITY. . . . . . . . . .    4
;   4. PEVAL - EVALUATION ROUTINE FOR PRIMS . . . . . . . . .    6
;   5. PEVALI - PEVAL TO INTEGER. . . . . . . . . . . . . . .    7
;   6. PEVALS - PEVAL TO STRING . . . . . . . . . . . . . . .    8
;   7. PATALL - USED BY BUILT-INS TO ALLOCATE NODE. . . . . .    9
;   8. UPDATE - USED BY BUILT-INS TO UPDATE SURF. . . . . . .   10
;   9. PTRLPL - USED BY LEN AND TAB TO UPDATE STPTR . . . . .   11
;  10. POSTAB - USED BY BUILT-INS POS,RPOS,TAB,RTAB . . . . .   12
;  11. PATPRO - USED BY MOST BUILT-INS AND CVTPAT . . . . . .   13
;  12. BRKPRO - USED BY BREAKX. . . . . . . . . . . . . . . .   14
;  13. EVLPRO - USED BY CVTPAT FOR EXPRESSIONS. . . . . . . .   15
;  14. KEYWORD
;       14.1.   $FAIL . . . . . . . . . . . . . . . . . . . .   16
;       14.2.   $FENCE. . . . . . . . . . . . . . . . . . . .   17
;       14.3.   $REM. . . . . . . . . . . . . . . . . . . . .   18
;  15. ANY - BUILT IN USED BY PATTERN BUILDER . . . . . . . .   19
;  16. PR.ANY - PRIMITIVE USED BY ANY(S) & NOTANY(S). . . . .   20
;  17. PR$ANY - PRIMITIVE USED BY ANY(E). . . . . . . . . . .   21
;  18. NTNY - BUILT-IN USED BY PATTERN BUILDER. . . . . . . .   22
;  19. PR$NTN - PRIMITIVE USED BY NOTANY(E) . . . . . . . . .   23
;  20. BREAK - BUILT-IN USED BY PATTERN BUILDER . . . . . . .   24
;  21. PR.BRK - PRIMITIVE USED BY BREAK(S). . . . . . . . . .   25
;  22. PR$BRK - PRIMITIVE USED BY BREAK(E). . . . . . . . . .   26
;  23. BREAKX - BUILT-IN CALLED BY PATTERN BUILDER. . . . . .   27
;  24. SPAN - BUILT-IN USED BY PATTERN BUILDER. . . . . . . .   28
;  25. PR.SPN - PRIMITIVE USED BY SPAN(S) . . . . . . . . . .   29
;  26. PR$SPN - PRIMITIVE USED BY SPAN(E) . . . . . . . . . .   30
;  27. LEN - BUILT-IN USED BY PATTERN BUILDER . . . . . . . .   31
;  28. PR.LEN - PRIMITIVE USED BY LEN(N). . . . . . . . . . .   32
;  29. PR$LEN - PRIMITIVE USED BY LEN(E). . . . . . . . . . .   33
;  30. POS - BUILT-IN USED BY PATTERN BUILDER . . . . . . . .   34
;  31. PR.POS - PRIMITIVE USED BY POS(N). . . . . . . . . . .   35
;  32. PR$POS - PRIMITIVE USED BY POS(E). . . . . . . . . . .   36
;  33. RPOS - BUILT-IN USED BY PATTERN BUILDER. . . . . . . .   37
;  34. PR.RPS - PRIMITIVE USED BY RPOS(N) . . . . . . . . . .   38
;  35. PR$RPS - PRIMITIVE USED BY RPOS(E) . . . . . . . . . .   39
;  36. RTAB - BUILT-IN USED BY PATTERN BUILDER. . . . . . . .   40
;  37. PR.RTB - PRIMITIVE USED BY RTAB(N) . . . . . . . . . .   41
;  38. PR$RTB - PRIMITIVE USED BY RTAB(E) . . . . . . . . . .   42
;  39. TAB - BUILT-IN USED BY PATTERN BUILDER . . . . . . . .   43
;  40. PR.TAB - PRIMITIVE USED BY TAB(N). . . . . . . . . . .   44
;  41. PR$TAB - PRIMITIVE USED BY TAB(E). . . . . . . . . . .   45
;  42. PR.FL - PRIMITIVE USED FOR FAIL. . . . . . . . . . . .   46
;  43. PR.GBL - PRIMITIVE USED BY BAL . . . . . . . . . . . .   47
;  44. PR.LN1 - PRIMITIVE FOR LEN(1). . . . . . . . . . . . .   48
;  45. PR.LFL - PRIMITIVE TO LENGTH FAIL. . . . . . . . . . .   49
;  46. PR.STR - PRIMITIVE FOR 'STRING' SCAN . . . . . . . . .   50
;  47. PR.CN1 AND PR.IN1 - IMMEDIATE AND CONDITIONAL NAMING ONE   51
;  48. PRCNB1 AND PRINB1 - IMMEDIATE AND CONDITIONAL NAMING WITH BACK-UP ONE  52
;  49. PR.CN2 - CONDITIONAL NAMING TWO. . . . . . . . . . . .   53
;  50. PRCNB2 - CONDITIONAL NAMING WITH BACK UP TWO . . . . .   54
;  51. PR.IN2 - IMMEDIATE NAMING TWO. . . . . . . . . . . . .   55
;  52. PRINB2 - IMMEDIATE NAMING WITH BACKUP TWO. . . . . . .   56
;  53. NAMELIST PROCESSOR - PNAMEL. . . . . . . . . . . . . .   57
;  54. CURS$ - BUILT-IN TO BUILD NODE . . . . . . . . . . . .   58
;  55. PR.CUR - PRIMITIVE FOR @VARIABLE . . . . . . . . . . .   59
;  56. PR$CUR - PRIMITIVE FOR @EXPRESSION . . . . . . . . . .   60
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
164	Change VA for unevaluated expressions being no longer inline.
207	Clean up some of the code.
\

	SUBTTL	CVTPAT - CONVERT TO PATTERN UTILITY

;	CALLING SEQUENCE:
;	PUSH STRING DESCRIPTOR
;	JSP	TLINK,CVTPAT
;	ERROR	;	ARG LEFT ON STACK - WILL NOT
	;	CONVERT
;	NORMAL	;	CONVERTED VALUE IS ON STACK

CVTPAT::	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIN	Z,PDT		;  PATTERN?
	JRST	1(TLINK)	;  NORMAL - PATTERN ALREADY.
	CAIN	Z,EDT		;  EXPRESSION?
	JRST	CEXPAT		;  YES, CONVERT HERE
	MOVEM	TLINK,CVPTSV##	;  SAVE TLINK
	JSP	TLINK,CVTSTR##	;  STRING?
	JRST	@CVPTSV		;  ERROR, RETURN
	SKIPN	0(STACK)	;  NULL STRING?
	JRST	NULLND		;  YES
	PUSH	STACK,-1(STACK)	;  SAVE SDT ON STACK
	PUSH	STACK,-1(STACK)	;   . . .
	JSP	QLINK,CVTPTR##	;  POINTER?
	T2	;		REG
	JRST	0(TLINK)	;  NO
	PUSH	STACK,[XWD IDT,0]	; PUSH DESC FOR G.C.
	PUSH	STACK,Z		;  POINTER IN REG 0, SAVE IT
	PUSH	STACK,-3(STACK)	;SET UP FOR CVTCS
	PUSH	STACK,-3(STACK)	;  ETC.
	MOVEI	Z,1		;  LENGTH OF STRING = 1 FOR FIRST
	;CHARACTER, ONLY THE FIRST CHARACTER NEED BE CONVERTED
	;	TO BE PLACED IN PSTART
	HRRM	Z,0(STACK)	;  PLACE 1 IN LENGTH OF DESC.
	JSP	TLINK,CVTCS##	;  CHARACTER SET?
	ERROR	15		;  ERROR, WEIRD!
	MOVE	TLINK,CVPTSV	;  RESTORE TLINK
	MOVE	Z,SURF		;  ALLOCATE SPACE FROM 
	HRLI	Z,PATPRO	;  SURF FOR . . .
	BLT	Z,LPHDR+2*PNDSZ-1(SURF)	;  PATTERN PROTOTYPE
	MOVEI	Z,LPHDR+2*PNDSZ	;  SIZE OF PROTOTYPE . . .
	HRRM	Z,BLENG(SURF)	;  PLACE IN RIGHT HALF OF PBLOK
	MOVEI	T3,LPHDR(SURF)	;  T3 -> BEGINNING OF NODE
	POP	STACK,PSTART+1(SURF)	;  POP CHARACTER SET . . .
	POP	STACK,PSTART(SURF)	;  DESCRIPTOR INTO PSTART
	POP	STACK,PNDSZ+PARG+1(T3)	;  POP POINTER INTO NODE
	POP	STACK,(STACK)	;[207]	POP STRING DESCRIPTOR . .. .
	POP	STACK,Z		;  SECOND WORD INTO PARG
	MOVEM	Z,PARG+1(T3)	;  TO BE PLACED IN PARG
	HRRM	Z,PMIN(SURF)	; AND PMIN
	POP	STACK,PARG(T3)	;  POP FIRST WORD TOO
	MOVEI	Z,PR.STR	;  PRIMITIVE FOR STRING . .    
	MOVEM	Z,PPROG(T3)	;  TO BE PLACED IN PPROG


	MOVEI	T2,2*PNDSZ+LPHDR	;  VALUE USED TO INCREMENT
	;	SURF
SRFUPD:	MOVE	Z,SURF		;  LOAD ADDRESS OF PBLOK TO 
	;	UPDATE SURF
	HRLI	Z,PDT		;  INSERT PATTERN DATATYPE IN PBLOK
	PUSH	STACK,Z		;  PUSH DESCRIPTOR FOR PDT
	PUSH	STACK,[0]	;  ON TO STACK
	ADD	SURF,T2		;  UPDATE SURFACE - VALUE IN T2
	CAML	SURF,CEIL##	;  IF SURF<CEIL, SKIP
	JSP	QLINK,GCOL##	;  GARBAGE COLLECT IF NOT
	JRST	1(TLINK)	;  NORMAL RETURN
NULLND:	MOVE	TLINK,CVPTSV	;  RESTORE TLINK
	MOVE	Z,SURF		;  ALLOCATE SPACE FOR PROTOTYPE
	HRLI	Z,PATPRO	;  FROM SURF
	BLT	Z,LPHDR+PNDSZ-1(SURF)	;ETC.
	MOVEI	Z,LPHDR+PNDSZ	;  SIZE OF PROTOTYPE PLACE IN
	HRRM	Z,BLENG(SURF)	;  RIGHT HALF OF PBLOK
	MOVEI	T3,LPHDR(SURF)	;  T3->BEGINNING OF NODE
	POP	STACK,Z		;  RETRIEVE SDT DESCRIPTOR
	MOVEM	Z,PARG+1(T3)	;  PLACE IN PARG - 2ND WORD
	HRRM	Z,PMIN(SURF)	;  AND ALSO IN PMIN
	POP	STACK,PARG(T3)	;  POP FIRST WORD INTO PARG
	MOVEI	Z,SC.S		;  GO TO SUCCESS IF NULL STRING
	MOVEM	Z,PPROG(T3)	;  PLACE IN PPROG
	MOVEI	T2,PNDSZ+LPHDR	;  VALUE TO INCREMENT SURF
	JRST	SRFUPD		;  GO AND UPDATE SURF

;	MERGE HERE IF EXPRESSION
CEXPAT:	MOVE	Z,SURF		;  ALLOCATE SPECIFIC . . .
	HRLI	Z,EVLPRO	;  PATTERN PROTOTYPE FOR
	BLT	Z,LPHDR+PNDSZ-1(SURF)	;  FOR AN EXPRESSION


	POP	STACK,LPHDR+PARG+1(SURF)	;POP DESCR INTO
	POP	STACK,LPHDR+PARG(SURF)		;	PATTERN NODE
	MOVEI	T2,PNDSZ+LPHDR		; PLACE VALUE TO BE ADDED TO
	;	SURF IN T2
	JRST	SRFUPD		;  UPDATE SURF

	
	SUBTTL	PEVAL - EVALUATION ROUTINE FOR PRIMS

;	CALL:
;		MOVEI	T2,LOC(DESCR OF EBLOK)
;		JSP	TLINK,PEVAL##
;	RETURN:
;		TO CALL+1 IF EVAL FAILED.	BAD ARG ON STACK
;		TO CALL+2 IF EVAL SUCCEEDED.	EVALUATED ARG ON STACK

PEVAL::	HLRZ	Q3,0(T2)	; PICK UP DATATYPE
	CAIE	Q3,EDT		; EXPRESSION?
	JRST	PEVALX		; NO

	HRRZ	Q3,0(T2)	; ADDRESS OF CBLOK
	ADD	Q3,1(T2)	; LOCATION OF EXPRESSION
	MOVE	Q1,1(Q3)	; LOAD NEXT WORD
	CAME	Q1,[CDIF,,EOE##] ; END OF EXP?
	JRST	PEVAL1		; NO

	PUSH	STACK,0(Q3)	; PUSH SINGLE ELEMENT
	PUSH	STACK,[0]	; ONTO THE STACK
	JRST	1(TLINK)	; AND RETURN

PEVAL1:	PUSHSA	MIPS		;HAVE A LONG ONE
	PUSHR	PST		;	EVERYTHING
	MOVEM	HSR,HSTACK##	;	AND RESET HIST STACK POINTER

	PUSH	STACK,0(T2)	;PUT ARG ONTO STACK
	PUSH	STACK,1(T2)	;	DESCR IS 2 WORDS

PEVAL0:	MOVEI	Z,1		;EVALUATE 
	JSP	PLINK,EVAL##	;	OUR ONE ARG
	JRST	PEVALF		;FAILED.

	POP	STACK,FLAT##+1	; SAVE ...
	POP	STACK,FLAT	; RETURNED VALUE
	JRST	PEVALD		; AND JUMP


PEVALF:	SKIPA	Q1,[0]		;FAIL RETURN FROM EVAL. RECORD FAIL IN Q1

PEVALD:	MOVEI	Q1,1	;SUCCESS. RECORD THAT IN Q1

	MOVE	HSR,HSTACK	;RESTORE EVERYBODY'S
	POPR	PST		;	STATUS INDIC'S
	POPSA	MIPS		; AND REGS
	JUMPE	Q1,0(TLINK)	; FAIL? GIVE FAIL EXIT

	MOVEI	T2,FLAT		; POINT TO RET. VALUE
	HLRZ	Q2,FLAT		; LOAD DATA TYPE
	CAIN	Q2,EDT		; ITS NOT EXPRESSION?
	JRST	PEVAL		; IT IS, BACK FOR MORE

PEVALX:	PUSH	STACK,0(T2)	;PUT RSLT OR ORIG ARG
	PUSH	STACK,1(T2)	;	ONTO STACK AS THE ANSWER

	JRST	1(TLINK)		;	-NORMAL RETURN


;
;
;	SUBROUTINE TO SQUEEZE OUT SINGLE-ELEMENT
;	UNEVALUATED EXPRESSIONS
;	CALL:
;	MOVEI	T2,LOC(DESCR OF EXP)
;	JSP	T3,SQZE
	 ;MAY ALTER T2 & Q3
;	RETURN:
;	TO CALL + 1 IF FOUND NON-EXPR SOMEWHERE
;	TO CALL + 2 IF FOUND A LONG EXPRESSION
;		T2 = LOC(RESULT OF SEARCH), ALWAYS
;
SQZE:	HLRZ	Z,0(T2)		;CHECK FOR EXPR
	CAIE	Z,EDT		;	IF NOT,
	JRST	0(T3)		;	EXIT QUICK

	HRRZ	Q3,0(T2)	;CHECK FOR SIMPLE EXPR
	HRRZ	Z,BLENG(Q3)	;	IS IT A SHORT ONE?
	CAIE	Z,LHDR+2	;	I.E., ONE DESCR LONG?
	JRST	1(T3)		;NO- EXIT TO DO THE LONG EVAL

	MOVEI	T2,LHDR(Q3)	;YES- USE IT INSTEAD.
	JRST	SQZE		;	AND TRY TO REPEAT IT.


	SUBTTL	PEVALI - PEVAL TO INTEGER
;	TYPE S ROUTINE - PEVAL TO INTEGER CALLED BY POS, RPS, TAB,
;	LEN, RTAB - RETURNS WITH A NONNEGATIVE INTEGER ON STACK
;	CALLING SEQUENCE:
;		HAVE P2 SET TO ADDR OF PATT NODE
;	JSP	SLINK,PEVALI
;	NORMAL RETURN

PEVALI:	MOVEI	T2,PARG(P2)	;SET UP FOR PEVAL- ARG ADDR
	JSP	TLINK,PEVAL	;  CALL PEVAL
	JRST	SC.MF##		;  ERROR, MATCH FAIL

	JSP	TLINK,CVTVAL##	; CONVERT VARIABLES
	JRST	[SUB STACK,[2,,2]
		 JRST SC.MF]	; POP STACK AND FAIL

	JSP	TLINK,CVTINT##	;  CONVERT DESCRIPTOR TO INTEGER
	ERROR.	1,2		;RQD INT ARG AND IT'S NOT.
	SKIPGE	0(STACK)	;  NONNEGATIVE?
	ERROR	13,1		;  NO, ERROR
	JRST	0(SLINK)	; RETURN


	SUBTTL	PEVALS - PEVAL TO STRING

;	TYPE S ROUTINE - PEVAL TO STRING
;	CALLED BY PR$ANY, PR$NTNY, PR$SPN, PR$BRK
;	RETURNS WITH A NONNULL STRING ON STACK
;	CALLING SEQUENCE:

;	HAVE P2 SET TO PATT NODE
;	JSP	SLINK,PEVALS
;	NORMAL RETURN


PEVALS:	MOVEI	T2,PARG(P2)	;	SET UP FOR PEVAL
	JSP	TLINK,PEVAL	;  CALL PEVAL
	JRST	SC.MF		;  ERROR

	JSP	TLINK,CVTVAL	; MAKE VALUE
	JRST	[SUB STACK,[2,,2]
		 JRST SC.MF]	; POP STACK AND FAIL

	JSP	TLINK,CVTSTR	;  CONVERT DESCRIPTOR FROM PEVAL TO STR
	ERROR.	1,6		;RQD STRING AND IT'S NOT.
	MOVE	Z,-1(STACK)	;  YES, SEE IF NULL
	CAMN	Z,NULLST##	;  . . .
	ERROR	13,6		;  YES, ERROR
	JRST	0(SLINK)	;  NO, RETURN


	SUBTTL	PATALL - USED BY BUILT-INS TO ALLOCATE NODE

;	THIS ROUTINE ALLOCATES A PATTERN NODE WITHOUT UPDATING SURF
;	AND IS CALLED BY THE VARIOUS PATTERN BUILT-IN FUNCTIONS
;	AND ANY OTHER PATTERN LOCAL TYPE ROUTINES WHERE APPLICABLE
;	CALLING SEQUENCE:
;	JSP TLINK,PATALL

PATALL:	MOVE	Z,SURF		;  MOVE SURF POINTER TO REG 0
	HRLI	Z,PATPRO	;  INSERT PATTERN PROTOTYPE 
	;	ADDRESS IN REG 0
	BLT	Z,LPHDR+PNDSZ-1(SURF)	;  MOVE ENTIRE PROTOTYPE
	;	INTO FLOATING STORAGE
	MOVEI	T2,LPHDR(SURF)	;  T2 -> NODE
	POP	STACK,PARG+1(T2)	;  POP ARGUMENT INTO . . .
	POP	STACK,PARG(T2)	;  PARG FIELD OF NODE
	JRST	0(TLINK)	;  RETURN


	SUBTTL	UPDATE - USED BY BUILT-INS TO UPDATE SURF

;	THIS ROUTINE DOES THE FIRST UPDATE ON SURF CALLED AFTER
;	THE NODE IS FILLED IN.
;	THE ROUTINE IS CALLED BY THE VARIOUS PATTERN BUILT-IN
;	FUNCTIONS ETC.
;	CALLING SEQUENCE:
;	JRST UPDATE

UPDATE:	MOVE	Z,SURF		;  LOAD ADDRESS OF PBLOK
	HRLI	Z,PDT		;  INSERT PATTERN DATATYPE
	PUSH	STACK,Z		;  PUSH DESCRIPTOR FOR . . .
	PUSH	STACK,[0]	;  PDT ONTO STACK
	ADDI	SURF,PNDSZ+LPHDR	;  UPDATE SURFACE OF FLOATING STORGE
	CAML	SURF,CEIL##	;  IF SURF IS BELOW CEIL, SKIP
	JSP	QLINK,GCOL	;  OTHERWISE GARBAGE COLLECT
	JRST	1(PLINK)	;  RETURN TO PATTERN BUILDER


	SUBTTL	PTRLPL - USED BY LEN AND TAB TO UPDATE STPTR

;	THE FOLLOWING ROUTINE IS USED BY LEN AND TAB TO UPDATE STPTR. 
;	USED BY PRIMITIVES LEN AND TAB, NOT BUILT-INS
;	IF MORE THAN ONE WORD OR BYTE IS REQUIRED TO UPDATE
;	STPTR.
;	CALLING SEQUENCE:
;	JRST PTRLPL	OR	JRST PTRLP

PTRLPL:	HRRZ	Z,S2		;  S2  CONTAINS THE NUMBER OF WORDS
	ADDM	Z,STPTR##	;  UPDATE STPTR
;	MERGE HERE IF THERE ARE LESS THAN FIVE BYTES TO ADD TO STPTR

PTRLP:	SOJL	S3,SC.S##	;S3-BYTE CNT- LE 0? THEN QUIT
	IBP	STPTR		;	IF NOT YET, INC ONCE
	JRST	PTRLP		;	AND SEE IF THAT FINISHES IT

	SUBTTL	POSTAB - USED BY BUILT-INS POS,RPOS,TAB,RTAB

;	THE FOLLOWING ROUTINE IS COMMON CODE FOR RTAB,TAB,RPOS, AND POS
;	-	THE BUILT-INS.	
;	CALLING SEQUENCE:	
;	MOVEI	P2,PR$---	;	P2 HAS THE PRIMITIVE IF
	;	AN EXPRESSION OCCURS FOR ANY
	;	OF THE FOUR BUILT-INS E.G.
	;	PR$PO
;	MOVEI	S3,PR.---	;	S3 HAS THE PRIMITIVE IF
	;	IT IS POSSIBLE TO CONVERT TO
	;	INTEGER
;	JSP	SLINK,POSTAB	;	GO HERE
;	RETURN HERE IF EXPRESSION
;	RETURN HERE IF INTEGER IN ORDER TO INITIALIZE PSTART
; 

POSTAB:	JSP	TLINK,CVTINT	;  INTEGER?
	JRST	PSTB.X		;  NO, TRY EXPRESSION.
	SKIPGE	0(STACK)	;  NEGATIVE ARGUMENT?
	ERROR	13,14	; ERROR - NEGATIVE ARGUMENT
	JSP	TLINK,PATALL	;  ALLOCATE PATTERN PROTOTYPE
	MOVEM	S3,PPROG(T2)	;  STORE PRIMITIVE NAME
	JRST	1(SLINK)	;  GO INITIALIZE PSTART IF NECESSARY
;	MERGE HERE TO TRY FOR EXPRESSION
PSTB.X:	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIE	Z,EDT		;  EXPRESSION?
	ERROR.	1,41		;  ERROR., NEITHER INTEGER OR EXPR
	JSP	TLINK,PATALL	;  ALLOCATE PATTERN PROTOTYPE
	MOVEM	P2,PPROG(T2)	;  STORE EXPRESSION PRIMITIVE
	;	ENTRY POINT
	JRST	0(SLINK)	;  RETURN IF EXPRESSION

	SUBTTL	PATPRO - USED BY MOST BUILT-INS AND CVTPAT

;	THE FOLLOWING PROTOTYPE IS USED BY MOST BUILT-INS AND CVTPAT
;
PATPRO:	XWD	PBLOK,PNDSZ+LPHDR	;  PATTERN BLOCK AND SIZE
	REPEAT	LPHDR,<0>	;  FILL WITH ZEROS
	XWD	400000,400000	;  NO ALTERNATE, NO SUBSEQUENT
	REPEAT	2*PNDSZ-2,<0>	;  REST OF FIRST NODE FILLED
	;	WITH ZEROS AS WELL AS 2ND 
	;	NODE

	SUBTTL	BRKPRO - USED BY BREAKX

;	THE FOLLOWING PROTOTYPE IS USED BY THE BUILT-IN BREAKX
;
BRKPRO:	XWD	PBLOK,PNDSZ*4+LPHDR	;  THIS PROTO HAS 4 NODES
	REPEAT	LPHDR-1,<0>	;  FILL WITH ZEROS IN SMALL 
	;	PORTION OF FIRST NODE
	XWD	0,SC.S
	XWD	400000,LPHDR+PNDSZ
	REPEAT	PNDSZ-2,<0>	

	XWD	0,PR.BRK	;  PPROG FIELD - ALWAYS SUCCESS
	XWD	400000,LPHDR+PNDSZ*2	;  NO ALTERNATE, 3RD
	;	NODE IS SUBSEQUENT
	REPEAT	PNDSZ-2,<0>	;  ZEROS
	XWD	0,SC.S		;  PPROG LOCATION
	XWD	LPHDR+3*PNDSZ,400000 ;	NO SUBSQ, ALT IS 4TH NODE
	REPEAT	PNDSZ-2,<0>	;  ZEROS
	XWD	0,PR.LN1	;  PPROG
	XWD	400000,LPHDR+PNDSZ	;  NO ALT, SUBS IS 2ND NODE
	XWD	IDT,0		;  PARG FIELD
	1	;		MINIMUM LENGTH IS 1

	SUBTTL	EVLPRO - USED BY CVTPAT FOR EXPRESSIONS

;	THE FOLLOWING PROTOTYPE IS USED BY CVTPAT IF AN EXPRESSION
;	OCCURS.
; 
EVLPRO:	XWD	PBLOK,PNDSZ+LPHDR	;  1 NODE
	REPEAT	LPHDR-2,<0>	;  ZEROS
	EXP	1		; MINIMUM LENGTH
	XWD	0,PR.EX1##	;  PPROG
	XWD	400000,400000		;	NO ALT, NO SUBS
	REPEAT	PNDSZ-2,<0>	;  ZEROS

	SUBTTL	KEYWORD -- $FAIL

;	THIS IS THE PATTERN PROTOTYPE FOR THE KEYWORD $FAIL
; 
$FAIL::	XWD	PBLOK,PNDSZ+LPHDR	;  PATTERN BLOCK AND SIZE
	REPEAT	LPHDR-1,<0>	;  ZEROS
	XWD	0,PR.FL		;  PPROG
	XWD	400000,400000	;  NO ALT, NO SUBSQUENT
	REPEAT	PNDSZ-2,<0>	;  ZEROS

	SUBTTL	KEYWORD -- $FENCE

;	THIS IS THE PATTERN PROTOTYPE FOR THE KEYWORD $FENCE
; 
$FENCE::	XWD	PBLOK,2*PNDSZ+LPHDR	;  PATTERN BLOCK AND SIZE
	REPEAT	LPHDR-1,<0>	;  ZEROS
	XWD	0,SC.S		;  MATCHES NULL STRING
	;	IF SUCCEEDS , IF NOT, ABORTS
	XWD	LPHDR+PNDSZ,400000	;  ALT IS ABORT - 2ND NODE, 
	;	NO SUBSEQUENT
	REPEAT	PNDSZ-2,<0>	;  ZEROS
	XWD	0,PR.ABT##	;  ALTERNATE NODE, ABORT
	XWD	400000,400000	;  NO ALT, NO SUBS
	REPEAT	PNDSZ-2,<0>	;  ZEROS

	SUBTTL	KEYWORD -- $REM

;	THIS IS THE PATTERN PROTOTYPE FOR THE KEYWORD $REM
;
$REM::	XWD	PBLOK,PNDSZ+LPHDR	;  PATTERN BLOCK AND SIZE
	REPEAT	LPHDR-1,<0>	;  ZEROS
	XWD	0,PR.RTB	;  SAME AS . . .
	XWD	400000,400000	;  RTAB(0) - THEREFORE . . .
	XWD	IDT,0		;  INTEGER VALUE = 0
	0	;		. . .

	SUBTTL	ANY - BUILT IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR ANY AS WELL AS NOTANY
;	CALLING SEQUENCE:	
;	PUSH DESCRIPTOR
;	JSP PLINK,ANY
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)
;
	
ANY::	JSP	TLINK,CVTSTR	;  STRING?
	JRST	ANY.EX		;  ERROR, TRY EXPRESSION
	MOVE	Z,-1(STACK)	;  TEST FOR . . .
	CAMN	Z,NULLST	;  NULL STRING.
	ERROR	13,21		;  NULL STRING, ERROR.
	JSP	TLINK,CVTCS	;  OK, CONVERT TO CHARACTER SET
	ERROR	15		;  ERROR, WEIRD!
;	MERGE HERE FROM NOTANY BUILT-IN
	
NTNY1:	JSP	TLINK,PATALL	;  COMMON CODE TO ALLOCATE NODE
	MOVE	Z,PARG(T2)	;  INITIALIZE PSTART . . .
	MOVEM	Z,PSTART(SURF)	;  WITH CHARACTER SET IN . . .
	MOVE	Z,PARG+1(T2)	;  PARG . . .
	MOVEM	Z,PSTART+1(SURF)	;  . . . 
	MOVEI	S3,PR.ANY	;  PPROG - PRIMITIVE FOR MATCHER
ANY1:	MOVEM	S3,PPROG(T2)	;  STORE IN PPROG
	MOVEI	Z,1		;  MINIMUM LENGTH . . .VEM	Z,PMIN(SURF)	;  STORE IN PMIN
	JRST	UPDATE		;  UPDATE SURF POINTER
;	GO HERE TO TRY FOR AN EXPRESSION 
ANY.EX:	HLRZ	Z,-1(STACK)	;  EXPRESSION?
	CAIE	Z,EDT		;  . . .
	ERROR.	1,48		;  NEITHER EXPR OR STRING
	MOVEI	S3,PR$ANY	;  PRIMITIVE ENTRY POINT FOR AN
	;	EXPRESSION
	MOVEI	TLINK,ANY1	;  RETURN FROM PATALL = TLINK
	JRST	PATALL		;  ALLOCATE NODE AND THEN REJOIN
	;	MAIN PROCESSING OF ANY

	SUBTTL	PR.ANY - PRIMITIVE USED BY ANY(S) & NOTANY(S)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR.ANY IS ENCOUNTERED IN A NODE
;	CALLING SEQUENCE:
;	JRST PR.ANY
;	RETURN EITHER GOES TO SUCCESS, LENGTH-FAIL, OR MATCH FAIL
;
PR.ANY::SKIPG	CURSOR##	;  CHECK CURSOR VALUE FOR LENGTH
	;	FAILURE.	IF CURSOR <= 0
	;	FAILS.	SINCE ANY REQUIRES
	;	LENGTH OF 1
	JRST	SC.LF##		;  ENTRY POINT FOR LENGTH FAIL
	MOVE	S2,PARG(P2)	;  P2 -> CURRENT NODE
	;	RETRIEVE FIRST WORD OF
	;	DESCRIPTOR,	SET UP S2 AND
	MOVE	S3,PARG+1(P2)	;  S3  FOR CHECK
ANY.PR:	JSP	TLINK,CHECK##	;  STREAM FOR ANY(S)
	JRST	SC.MF		;  MATCH FAILURE
	IBP	STPTR		;  UPDATE STPTR
	SOS	CURSOR		;  UPDATE CURSOR
	JRST	SC.S		;  RETURN TO SUCCESS

	SUBTTL	PR$ANY - PRIMITIVE USED BY ANY(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$ANY IS ENCOUNTERED IN A NODE - SIGNIFIES
;	THAT AN EXPRESSION MUST BE EVALUATED FOR ANY( )
;	CALLING SEQUENCE:
;	JRST PR$ANY
;	RETURN EITHER GOES TO LENGTH FAILURE, MATCH FAIL, OR SUCCESS
;
PR$ANY::	SKIPG	CURSOR		;  IF CURSOR <= 0 . . .
	JRST	SC.LF		;  LENGTH FAIL
	JSP	SLINK,PEVALS	;  PEVAL TO STRING
	JSP	TLINK,CVTCS	;  CONVERT EVALUATED EXPRESSION
	;	TO CHARACTER SET IF POSSIBLE
	ERROR	15		;  UNABLE TO CONVERT
;	MERGE HERE FROM PR$NTNY
ANYNT:	POP	STACK,S3	;  SET UP S2 . . .
	POP	STACK,S2	;  AND S3 TO MERGE WITH PR.ANY
	JRST	ANY.PR		;  MERGE WITH PR.ANY TO DO SCAN

	SUBTTL	NTNY - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR NOTANY BY CALLING THE BUILT-IN
;	ANY - UTILIZES CONVERT TO CHARACTER SET COMPLEMENT
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,NTNY
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)
;
	
NTNY::	JSP	TLINK,CVTSTR	;  STRING?
	JRST	NTNY.X		;  TRY EXPRESSION
	MOVE	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAMN	Z,NULLST	;  NULL STRING?
	ERROR	13,20		;  ERROR FOR NULL STRING IN NOTANY
	JSP	TLINK,CVTCSC##	;  CONVERT TO CHARACTER SET
	;	COMPLEMENT TO MERGE WITH ANY()
	ERROR	15		;  WEIRD ERROR!
	JRST	NTNY1		;  ENTER INTO ANY() BUILT-IN
;	MERGE HERE TO TEST FOR AN EXPRESSION
	
NTNY.X:	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIE	Z,EDT		;  EXPRESSION?
	ERROR.	1,47		;  NEITHER EXPR OR STRING
	MOVEI	S3,PR$NTN	;  SET UP S3 WITH PPROG TO JOIN
	;	WITH ANY BUILT-IN
	JSP	TLINK,PATALL	;  ALLOCATE NODE ETC
	JRST	ANY1		;  JOIN BUILT-IN ANY()

	SUBTTL	PR$NTN - PRIMITIVE USED BY NOTANY(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$NTN IS ENCOUNTERED IN THE PPROG FIELD OF A NODE
;	- SIGNIVIES THAT AN EXPRESSION MUST BE EVALUATED
;	FOR NOTANY( )
;	CALLING SEQUENCE:
;	JRST PR$NTN
;	RETURN EITHER GOES TO LENGTH FAILURE, MATCH FAIL, OR SUCCESS
;
PR$NTN::	SKIPG	CURSOR		;  IF CURSOR <= 0 . . .
	JRST	SC.LF		;  LENGTH FAIL
	JSP	SLINK,PEVALS	;  PEVAL TO STRING TO EVALUATE
	JSP	TLINK,CVTCSC	;  CONVERT EVALUATED EXPR TO CS
	ERROR	15		;  ERROR, WEIRD!
	JRST	ANYNT		;  MERGE WITH PR$ANY

	SUBTTL	BREAK - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR BREAK 
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,BREAK
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)
;
BREAK::	JSP	TLINK,CVTSTR	;  STRING?
	JRST	BRK.EX		;  TRY EXPRESSION
	MOVE	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAMN	Z,NULLST	;  NULL STRING?
	ERROR	13,19		;  YES, ERROR
	JSP	TLINK,CVTCS	;  NO, CONVERT TO CS
	ERROR	15		;  WEIRD!
	MOVEI	S3,PR.BRK	;  PRIMITIVE FOR PPROG IN S3
;	MERGE HERE AFTER TEST FOR EXPRESSION
BRK1:	JSP	TLINK,PATALL	;  COMMON CODE
	MOVEM	S3,PPROG(T2)	;  STORE PRIMITIVE
	JRST	UPDATE		;  UPDATE SURF 
;	MERGE HERE TO TEST FOR EXPRESSION
BRK.EX:	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIE	Z,EDT		;  EXPRESSION?
	ERROR.	1,46		;  NEITHER EXPR NOR STRING
	MOVEI	S3,PR$BRK	;  PRIMITIVE FOR PPROG
	JRST	BRK1		;  JOIN NORMAL PROCESSING

	SUBTTL	PR.BRK - PRIMITIVE USED BY BREAK(S)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR.BRK IS ENCOUNTERED IN A NODE
;	USED BY BREAK() AND BREAKX()
;	CALLING SEQUENCE:
;	JRST PR.BRK
;	RETURN GOES TO MATCH FAILURE, LENGTH FAILURE OR SUCCESS
; 
PR.BRK::	MOVE	S2,PARG(P2)	;  SET UP T2 AND . . .
	MOVE	S3,PARG+1(P2)	;  T3 FOR STR. - PT -> CURRENT 
	;	NODE
BRK.PR:	PUSH	STACK,CURSOR	;  SAVE CURSOR VALUE(OLD)
	PUSH	STACK,STPTR	;  SAVE STPTR VALUE(OLD)
	AOS	CURSOR		;  ADD ONE TO CURSOR
	JSP	TLINK,STR.##	;  STREAM FOR CHARACTER IN STRING
	JRST	RES.BK		;  ERROR, RESTORE CURSOR ETC.
	SUB	STACK,[XWD 2,2]	;	TAKE OLD VALUE OF CURSOR AND
	;	STPTR OFF STACK
	SOSLE	CURSOR		;  UPDATE CURSOR TO GET BACK IN 
	;	SYNCH
	JRST	SC.S		;  IF CURSOR > 0, GO TO SUCCESS
	HRRZ	Z,SUBJ##+1	;  IF SUBJECT AND . . .
	CAME	Z,MAXLEN##	;  MAXLEN ARE EQUAL THEN . . .
	JRST	SC.S		;  RESTORE AND LF , ELSE SUCCESS
	ADD	STACK,[2,,2]	; RESTORE STACK
RES.BK:	POP	STACK,STPTR	;  RESTORE STPTR
	POP	STACK,CURSOR	;  RESTORE CURSOR
	JRST	SC.LF		;  LENGTH FAIL

	SUBTTL	PR$BRK - PRIMITIVE USED BY BREAK(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$BRK IS ENCOUNTERED IN THE PPROG FIELD OF A NODE
;	USED BY BREAK(E) AND BREAKX(E) - JOINS PR.BRK
;	CALLING SEQUENCE:
;	JRST PR$BRK
;	RETURN GOES TO SUCCESS, MATCH FAIL, OR LENGTH FAIL
;	AFTER EXPRESSION IS EVALUATED AND MATCH ATTEMPTED
; 
PR$BRK::	JSP	SLINK,PEVALS	;  CALL PEVAL TO STRING
	JSP	TLINK,CVTCS	;  CONVERT EVALUATED EXPRESSION
	;	TO CHARACTER SET
	ERROR	15		;  STRANGE ERROR
	POP	STACK,S3	;  SET UP S2 AND S3 . . .
	POP	STACK,S2	;  FOR STR. IN PR.BRK
	JRST	BRK.PR		;  JOIN PR.BRK

	SUBTTL	BREAKX - BUILT-IN CALLED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF - DOES NOT NEED TO
;	BUILD PROTOTYPE - ALREADY IN CORE - SPECIAL TO BREAKX
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,BRKX
;	ERROR RETURN
;	NORMAL RETURN AFTER AN UPDATE PERFORMED OF SURF
;
BRKX::	JSP	TLINK,CVTSTR	;  STRING?
	JRST	BRKX.X		;  NO, TRY EXPRESSION.
	MOVE	Z,-1(STACK)	;  RETRIEVE OFFSET AND LENGTH
	CAMN	Z,NULLST	;  NULL STRING?
	ERROR	13,18		;  YES, ERROR
	JSP	TLINK,CVTCS	;  CONVERT TO CS
	ERROR	15		;  WEIRD ERROR!
	MOVEI	S3,PR.BRK	;  PPROG PRIMITIVE IF STRING
BRX1:	MOVE	Z,SURF		;  ALLOCATE BREAKX . . .
	HRLI	Z,BRKPRO	;  PROTOTYPE
	BLT	Z,LPHDR+4*PNDSZ-1(SURF)
	MOVEI	T2,LPHDR+PNDSZ(SURF)	;  T2 -> 2ND NODE OF PROTO
	POP	STACK,PARG+1(T2)	;  2ND HAS DESCRIPTOR
	POP	STACK,PARG(T2) ; . . .
	MOVEM	S3,PPROG(T2)	;  PPROG PRIMITIVE - STORE
	MOVE	Z,SURF		;  PUSH . . .
	HRLI	Z,PDT		;  . . .
	PUSH	STACK,Z		;  PDT ONTO . . .
	PUSH	STACK,[0]	;  STACK
	ADDI	SURF,4*PNDSZ+LPHDR	;  UPDATE SURF POINTER
	CAML	SURF,CEIL	;  SURF < CEIL?
	JSP	QLINK,GCOL	;  NO, GARBAGE COLLECT
	JRST	1(PLINK)	;  RETURN TO PATTERN BUILDER
;	MERGE HERE TO TEST FOR EXPRESSION
BRKX.X:	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIE	Z,EDT		;  EXPRESSION?
	ERROR.	1,45		;  NEITHER STRING NOR EXPR
	MOVEI	S3,PR$BRK	;  S3 HAS PRIMITIVE FOR PPROG
	JRST	BRX1		;  JOIN MAIN PROCESSING

	SUBTTL	SPAN - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR SPAN()
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,SPAN
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)

SPAN::	JSP	TLINK,CVTSTR	;  STRING?
	JRST	SPAN.X		;  NO, TRY EXPRESSION
	MOVE	Z,-1(STACK)	;  NULL STRING?
	CAMN	Z,NULLST	;  . . .
	ERROR	13,17		;  YES, ERROR.
	JSP	TLINK,CVTCS	;  NO, CONVERT TO CS
	ERROR	15		;  WON'T CONVERT, WHY?!
	JSP	TLINK,PATALL	;  COMMON CODE TO ALLOCATE NODE
	MOVE	Z,PARG(T2)	;  INITIALIZE . . .
	MOVEM	Z,PSTART(SURF)	;  PSTART . . .
	MOVE	Z,PARG+1(T2)	;  . . .
	MOVEM	Z,PSTART+1(SURF)	;  . . .
	MOVEI	S3,PR.SPN	;  PRIMITIVE FOR PPROG
	
;	MERGE HERE AFTER TEST FOR EXPRESSION
	
SPAN1:	MOVEM	S3,PPROG(T2)	;  STORE PRIMITIVE ENTRY POINT
	MOVEI	Z,1		;  MINIMUM LENGTH FOR MATCH
	MOVEM	Z,PMIN(SURF)	;  STORE IN PMIN
	JRST	UPDATE		;  UPDATE SURF AND RETURN

;	GO HERE TO TEST FOR EXPRESSION

SPAN.X:	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIE	Z,EDT		;  EXPRESSION?
	ERROR.	1,44		;  NO, ERROR.- NEITHER STRING 
	;	NOR EXPRESSION
	MOVEI	S3,PR$SPN	;  PRIMITIVE FOR EXPR
	MOVEI	TLINK,SPAN1	;  RETURN POINT IN MAIN PROCESS
	JRST	PATALL		;  ALLOCATE PATTERN

	SUBTTL	PR.SPN - PRIMITIVE USED BY SPAN(S)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN PR.SPN
;	IS ENCOUNTERED IN A NODE OF THE PATTERN BLOCK
;	CALLING SEQUENCE:
;	JRST	PR.SPN
;	RETURN EITHER GOES TO SUCCESS, LENGTH-FAIL, OR MATCH-FAIL

PR.SPN::SKIPG	CURSOR		;  TEST CURSOR FOR LENGTH FAIL
	JRST	SC.LF		;  IF <= 0,  LENGTH-FAIL
	DMOVE	S2,PARG(P2)	;  SET UP REGISTERS S2 . . .
;	MOVE	S3,PARG+1(P2)	;  S3 FOR STREAMING WHERE P2 ->
	;	CURRENT NODE
	
;	MERGE HERE FROM PR$SPN

SPN.PR:	JSP	TLINK,CHECK	;  CHECK FIRST CHARACTER FIRST
	JRST	SC.MF		;  SINCE FIRST CHARACTER DOES
	;	NOT MATCH, MATCH FAIL.
	JSP	TLINK,STR.C##	;  STREAM FOR CHARACTER SET
	;	COMPLEMENT SO KNOW WHEN TO
	;	STOP THE SCAN
	JFCL			;[163] Runnout - but match worked
	SKIPN	CURSOR		;[163] Don't do it.
	IBP	STPTR##		;[163] Increment the byte pointer
	JRST	SC.S		;  MATCH ALSO SUCCEEDED

	SUBTTL	PR$SPN - PRIMITIVE USED BY SPAN(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN PR$SPN
;	IS ENCOUNTERED IN A NODE OF THE PATTERN BLOCK
;	THIS ROUTINE IS ONLY USED FOR EVALUATING EXPRESSION
;	FOR SPAN.
;	CALLING SEQUENCE:
;	JRST	PR$SPN
;	RETURN EITHER GOES TO SUCCESS, LENGTH-FAIL, OR MATCH-FAIL
PR$SPN::SKIPG	CURSOR		;  CHECK FOR LENGTH-FAILURE
	JRST	SC.LF		;  FAIL, IF <= 0.
	JSP	SLINK,PEVALS	;  CALL PEVAL TO STRING TO 
	;	ATTEMPT TO EVALUATE EXPR
	JSP	TLINK,CVTCS	;  ON RETURN, CONVERT TO CS
	ERROR	15		;  WON'T CONVERT, WHY?!
	POP	STACK,S3	;  SET UP S2, AND S3 FOR . . .
	POP	STACK,S2	;  STREAMING
	JRST	SPN.PR		;  JOIN PR.SPN TO STREAM

	SUBTTL	LEN - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR LEN.
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,LEN
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)

LEN::	JSP	TLINK,CVTINT	;  INTEGER?
	JRST	LEN.EX		;  NO, TRY EXPRESSION
	SKIPGE	0(STACK)	;  NEGATIVE INTEGER?
	ERROR	13,12		;  YES, ERROR
	JSP	TLINK,PATALL	;  ALLOCATE PROTOTYPE
	MOVEI	Z,PR.LEN	;  PATTERN PRIMITIVE
	MOVEM	Z,PPROG(T2)	;  STORE IN PPROG
	MOVE	Q1,PARG+1(T2)	;  LOAD INTEGER INTO Q1 TO . . .
	MOVEM	Q1,PMIN(SURF)	;  IN PMIN.
	HRRM	Q1,PARG(T2)	;  RETAIN ACTUAL INTEGER VALUE
	;	IN RIGHT HALF OF PARG
	IDIVI	Q1,5		;  DETERMINE NO. OF WORDS AND
	;	BYTES
	HRLM	Q1,PARG+1(T2)	;  WORDS IN Q1 . . .
	HRRM	Q2,PARG+1(T2)	;  BYTES IN Q2, STORE IN PARG+1
	JRST	UPDATE		;  UPDATE SURF
;	MERGE HERE TO TEST FOR EXPRESSION
LEN.EX:	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIE	Z,EDT		;  EXPRESSION?
	ERROR.	1,39		;  NEITHER INTEGER NOR EXPRESSION
	JSP	TLINK,PATALL	;  ALLOCATE NODE
	MOVEI	S3,PR$LEN	;  PRIMITIVE FOR EXPRESSION
	MOVEM	S3,PPROG(T2)	;  PLACE IN PPROG
	JRST	UPDATE		;  UPDATE SURF

	SUBTTL	PR.LEN - PRIMITIVE USED BY LEN(N)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR.LEN IS ENCOUNTERED IN A NODE OF THE PATTERN BLOCK.
;	CALLING SEQUENCE:
;	JRST PR.LEN
;	RETURN EITHER GOES TO SUCCESS, LENGTH-FAIL OR MATCH FAIL

PR.LEN::	HRRZ	S1,PARG(P2)	;  RETRIEVE VALUE OF INTEGER
	HLRZ	S2,PARG+1(P2)	;  NUMBER OF WORDS
	HRRZ	S3,PARG+1(P2)	;  NUMBER OF BYTES TO BE 
	;	USED IN PTRLPL
;	MERGE HERE FROM PR$LEN	
LEN.PR:	CAMLE	S1,CURSOR	;  IF CURSOR < INTEGER VALUE . . 
	JRST	SC.LF		;  LENGTH FAIL
	JUMPE	S1,SC.S		;  IF INT = O, MATCH NULL STR
		MOVN	Z,S1			;[207] OTHERWISW UPDATE ..
		ADDM	Z,CURSOR		;[207] CURSOR BY LEN OF INT VALUE
	JRST	PTRLPL		;  UPDATE STPTR AND RETURN FROM
	;	PTRLPL TO SC.S

	SUBTTL	PR$LEN - PRIMITIVE USED BY LEN(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$LEN IS ENCOUNTERED IN A NODE - SIGNIFIES
;	THAT AN EXPRESSION MUST BE EVALUATED FOR LEN()
;	CALLING SEQUENCE:
;	JRST PR$LEN
;	RETURN EITHER GOES TO LENGTH-FAIL, MATCH FAIL OR SUCCESS

PR$LEN::	JSP	SLINK,PEVALI	;  EVALUATE EXPR, DESCR. ON
	POP	STACK,S2	;  TOP OF STACK . .
	POP	STACK,(STACK)	;[207]	POP STACK
	MOVEM	S2,S1		;  S1 = VALUE OF INTEGER
	IDIVI	S2,5		;  S2 = WORDS, S3  BYTES
	JRST	LEN.PR		;  MERGE WITH PR.LEN FOR UPDATE

	SUBTTL	POS - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR POS() - ALSO CALLS COMMON ROUTINE
;	USED BY RPOS, TAB, AND RTAB.
;	CALLING SEQUENCE:
;	JSP PLINK,POS
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)

POS::	MOVEI	P2,PR$POS	;  P2 = PRIMITIVE FOR EXPR
	MOVEI	S3,PR.POS	;  S3 = PRIMITIVE FOR INTEGER
	JSP	SLINK,POSTAB	;  COMMON ROUTINE
	JRST	UPDATE		;  RETURN FROM POSTAB IF EXPR
	;	CONTROL GOES TO UPDATE
	MOVE	Z,PARG(T2)	;  RETURN IF INTEGER
	MOVEM	Z,PSTART(SURF)	;  UPDATE . . .
	MOVE	Z,PARG+1(T2)	;  . . .
	MOVEM	Z,PSTART+1(SURF)	;  PSTART
	JRST	UPDATE		;  UPDATE SURF

	SUBTTL	PR.POS - PRIMITIVE USED BY POS(N)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR.POS IS ENCOUNTERED IN A NODE
;	CALLING SEQUENCE:
;	JRST PR.POS
;	RETURN EITHER GOES TO SUCCESS, LENGTH-FAIL, OR MATCH FAIL

PR.POS::	MOVE	S2,PARG+1(P2)	;  RETRIEVE VALUE OF ARGUMENT
;	MERGE HERE FROM PR$POS
RPSM:	SUB	S2,MAXLEN	;  SUBTRACT FROM VALUE . . .
	ADD	S2,CURSOR	;  MAXLEN - CURSOR
	JUMPE	S2,SC.S		;[207] IF =, CURSOR POSITION OK
	JUMPG	S2,SC.MF	;[207] CURSOR BEYOND POINT
	JRST	SC.LF		;[207] IMPOSSIBLE NOT ENOUGH CHAR.

	SUBTTL	PR$POS - PRIMITIVE USED BY POS(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$POS IS ENCOUNTERED IN A NODE - SIGNIFIES
;	THAT AN EXPRESSION MUST BE EVALUATED FOR POS()
;	CALLING SEQUENCE:
;	JRST PR$POS
;	RETURN GOES TO LF,MF,OR SUCCESS

PR$POS::	JSP	SLINK,PEVALI	;  EVALUATE
	POP	STACK,S2	;  SET UP S2 TO MERGE WITH PR.POS
	POP	STACK,(STACK)	;[207]	POP STACK
	JRST	RPSM		;  MERGE WITH PR.POS

	SUBTTL	RPOS - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR RPOS 
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,RPOS
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)

RPOS::	MOVEI	P2,PR$RPS	;  P2=PRIMITIVE FOR EXPR.
	MOVEI	S3,PR.RPS	;  S3 = PRIMITIVE FOR INT.
	JSP	SLINK,POSTAB	;  COMMON CODE
	JRST	UPDATE		;  RETURN IF EXPR, UPDATE
	MOVE	Z,PARG(T2)	;  RETURN IF INTEGER . . .
	MOVEM	Z,PSTART(SURF)	;  SET UP PSTART . . .
	MOVE	Z,PARG+1(T2)	;  WITH A NEGATIVE . . .
	SETCAM	Z,PSTART+1(SURF)	;  VALUE
	JRST	UPDATE		;  UPDATE AND RETURN

	SUBTTL	PR.RPS - PRIMITIVE USED BY RPOS(N)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR.RPS IS ENCOUNTERED IN A NODE
;	CALLING SEQUENCE:
;	JRST PR.RPS
;	RETURN EITHER GOES TO MF, LF, OR SUCCESS

PR.RPS::	MOVE	S3,PARG+1(P2)	;  RETRIEVE VALUE OF ARG
;	MERGE HERE FROM PR$RPS
RPS.PR:	HRRZ	S2,SUBJ+1	;  LENGTH OF SUBJECT STRING
	SUB	S2,S3		;  SET UP TO ENTER POS
	JRST	RPSM		;  MERGE WITH PR.POS
	;	SINCE POS(L-N)=RPOS(N)

	SUBTTL	PR$RPS - PRIMITIVE USED BY RPOS(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$RPS IS ENCOUNTERED IN A NODE - SIGNIFIES
;	THAT AN EXPRESSION MUST BE EVALUATED FOR RPOS()
;	CALLING SEQUENCE:
;	JRST PR$RPS
;	RETURN GOES TO LF, MF, OR SUCCESS

PR$RPS::	JSP	SLINK,PEVALI	;  EVALUATE
	POP	STACK,S3	;  S3=INTEGER VALUE
	POP	STACK,(STACK)	;[207]	POP STACK
	JRST	RPS.PR		;  MERGE WITH PR.RPS

	SUBTTL	RTAB - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR RTAB()
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,RTAB
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)


RTAB::	MOVEI	P2,PR$RTB	;  SET UP P2 WITH PRIM FOR EXPR
	MOVEI	S3,PR.RTB	;  PRIMITIVE FOR INTEGER
	JSP	SLINK,POSTAB	;  COMMON CODE
	JRST	UPDATE		;  RETURN IF EXPR
	JRST	UPDATE		;  RETURN IF INTEGER, UPDATE

	SUBTTL	PR.RTB - PRIMITIVE USED BY RTAB(N)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR.RTB IS ENCOUNTERED IN A NODE.
;	CALLING SEQUENCE:
;	JRST PR.RTB
;	RETURN GOES TO MF, LF, OR SUCCESS

PR.RTB::	MOVE	S2,PARG+1(P2)	;  RETRIEVE ARGUMENT FOR RTAB
	
;	MERGE HERE FROM PR$RTB
RTB.PR:	HRRZ	S3,SUBJ+1	;  RETRIEVE LENGTH OF SUBJ
	SUB	S3,S2		;  S3 = L-N SINCE TAB(L-N)= 
	;	RTAB(N)
	JRST	TAB.PR		;  MERGE WITH PR.TAB

	SUBTTL	PR$RTB - PRIMITIVE USED BY RTAB(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$RTB IS ENCOUNTERED IN A NODE - SIGNIFIES
;	THAT AN EXPRESSION MUST BE EVALUATED FOR RTAB()
;	CALLING SEQUENCE:
;	JRST PR$RTB
;	RETURN GOES TO MF, LF, OR SUCCESS

PR$RTB::	JSP	SLINK,PEVALI	;  EVALUATE
	POP	STACK,S2	;  ARGUMENT FOR RTAB IN S2
	POP	STACK,(STACK)	;[207]	POP STACK
	JRST	RTB.PR		;  MERGE WITH PR.RTB

	SUBTTL	TAB - BUILT-IN USED BY PATTERN BUILDER

;	THIS ROUTINE ALLOCATES SPACE FROM SURF AND FORMS
;	PROTOTYPE FOR TAB()
;	CALLING SEQUENCE:
;	PUSH DESCRIPTOR
;	JSP PLINK,TAB
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)

TAB::	MOVEI	P2,PR$TAB	;  PRIMITIVE EXPR. ENTRY
	MOVEI	S3,PR.TAB	;  PRIMITIVE FOR INTEGER
	JSP	SLINK,POSTAB	;  COMMON CODE
	JRST	UPDATE		;  RETURN FOR EXPR
	JRST	UPDATE		;  RETURN FOR INTEGER UPDATE

	SUBTTL	PR.TAB - PRIMITIVE USED BY TAB(N)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR.TAB IS ENCOUNTERED IN A NODE.
;	CALLING SEQUENCE:
;	JRST PR.TAB
;	RETURN GOES TO MF, LF, OR SUCCESS

PR.TAB::	MOVE	S3,PARG+1(P2)	;  RETRIEVE VALUE OF ARGUMENT
	
;	MERGE HERE FROM PR$TAB
TAB.PR:	MOVE	S2,MAXLEN	;  S2 = MAXLEN
	SUB	S2,S3		;  S2 = MAXLEN - VALUE
	JUMPL	S2,SC.LF	;  IF ARG > MAXLEN, LEN-FAIL
	CAMLE	S2,CURSOR	;  IF S2 > CURSOR, THEN . . .
	JRST	SC.MF		;  MATCH FAIL
	MOVE	S3,CURSOR	;  RETRIEVE OLD CURSOR VALUE
	SUB	S3,S2		;  S3 = CURSOR-(MAXLEN-ARG) =
	;	NUMBER OF BYTES TO INC. STPTR
	MOVEM	S2,CURSOR	;  UPDATE NEW CURSOR
	SKIPN	FUTILE##		;  TEST FUTILITY FLAG TO SEE
	;	IF	PUSH HSTACK WITH ALT
	JRST	PTRLP		;  NO, UPDATE STPTR
	HRLI	S2,D.LF##	;  YES, USE NEG. 
	PUSH	HSR,S2		;  PUSH [D.LF CURSOR]
	PUSH	HSR,STPTR	;  PUSH [STPTR]
	JRST	PTRLP		;  UPDATE STPTR

	SUBTTL	PR$TAB - PRIMITIVE USED BY TAB(E)

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHEN
;	PR$TAB IS ENCOUNTERED INA NODE - SIGNIFIES
;	THAT AN EXPRESSION MUST BE EVALUATED FOR TAB()
;	CALLING SEQUENCE:
;	JRST PR$TAB
;	RETURN GOES TO MF, LF, OR SUCCESS

PR$TAB::JSP	SLINK,PEVALI	;  EVALUATE INTEGER
	POP	STACK,S3	;  ARGUMENT IN S3
	POP	STACK,(STACK)	;[207]	POP STACK
	JRST	TAB.PR		;  MERGE WITH PR.TAB

	SUBTTL	PR.FL - PRIMITIVE USED FOR FAIL

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER
;	WHEN PR.FL IS IN NODE - BUILT IN BY BUILDER
;	CALLING SEQUENCE:
;	JRST PR.FL
;	RETURN GOES TO MF OR LF

PR.FL::	SKIPL	,CURSOR		;  CURSOR LESS THAN 0?
	JRST	SC.MF		;  NO, MATCH FAIL
	JRST	SC.LF		;  YES, LENGTH FAIL

	SUBTTL	PR.GBL - PRIMITIVE USED BY BAL

;	THIS ROUTINE IS CALLED ONLY WHEN BAL IS REFERENCED.
;	IT IS CALLED BY THE PATTERN MATCHER.
;	CALLING SEQUENCE: 
;	JRST PR.GBL
;	RETURN GOES TO LF, MF, OR SUCCESS

PR.GBL::	SKIPG	CURSOR		;  CHECK CURSOR VALUE
	JRST	SC.LF		;  CURSOR <= 0, LF
	MOVE	S2,SYSCT##	;  S2 -> SYSTEM CHAR. TABLE
	MOVE	S3,[Y.LP!Y.RP]	;  MASK FOR "()"
	JSP	TLINK,CHECK	;  CHECK FIRST CHARACTER
	JRST	GBAL1		;  ERROR, ONLY ONE LETTER
	CAIE	Q2,"("		;  SEE IF LEFT-PAREN
	JRST	SC.MF		;  NO, THEREFORE UNBALANCED
	PUSH	STACK,CURSOR	;  SAVE CURSOR . . .
	PUSH	STACK,STPTR	;  AND STPTR
	SOS	CURSOR		;  BUMP OVER . . .
	IBP	STPTR		;  THE LEFT-PAREN
	MOVEI	S1,1		;  S1 HOLDS PAREN COUNT
	
GBAL2:	JSP	TLINK,STR.	;  LOOK FOR ANOTHER "()"
	JRST	GBAL3		;  NONE
	SOS	CURSOR		;  UPDATE CURSOR AND . . .
	IBP	STPTR		;  STPTR TO STREAM FOR NEXT PAR
	CAIN	Q2,"("		;  IS IT "("?
	AOJA	S1,GBAL2	;  YES, ADD 1 TO S1.
	SOJG	S1,GBAL2	;  NO, IT IS ")" , SUB 1.
	SUB	STACK,[XWD 2,2]	;	POP STACK OF SAVED VALUES
	CLEARM	FUTILE		;  CLEAR THE FUTILE FLAG
	JRST	SC.S		;  SUCCESSFUL RETURN SINCE
	;	S1 = 0
;	ENTER HERE IF UNBALANCED
GBAL3:	POP	STACK,STPTR	;  RESTORE . . .
	POP	STACK,CURSOR	;  THINGS
	JRST	SC.MF		;  MATCH FAIL
;	ENTER HERE FOR SINGLE CHARACTER	
GBAL1:	SOS	CURSOR		;  JUMP OVER CHARACTER
	IBP	STPTR		;  . . .
	JRST	SC.S		;  SUCCESSFUL RETURN

	SUBTTL	PR.LN1 - PRIMITIVE FOR LEN(1)

;	THIS ROUTINE IS USED BY VARIOUS OTHER PRIMITIVES
;	AND IS CALLED BY PATTERN MATCHER
;	CALLING SEQUENCE:
;	JRST PR.LN1
;	RETURN GOES TO LF OR SUCCESS

PR.LN1::	SKIPG	CURSOR		;  IS CURSOR > 0?
	JRST	SC.LF		;  NO, LENGTH FAIL.
	SOS	CURSOR		;  YES, UPDATE CURSOR BY 1
	IBP	STPTR		;  UPDATE STPTR BY 1 BYTE
	JRST	SC.S		;  SUCCESS

	SUBTTL	PR.LFL - PRIMITIVE TO LENGTH FAIL

;	THIS ROUTINE IS CALLED BY PATTERN MATCHER FOR
;	ANY TIME LENGTH FAIL IS DESIRED
;	CALLING SEQUENCE:
;	JRST PR.LFL
;	RETURN GOES TO LENGTH FAIL

PR.LFL::	MOVEI	S2,1		;  TURN . . .
	IORM	S2,FUTILE	;  FUTILITY FLAG ON
	JRST	SC.LF		;  LENGTH FAIL

	SUBTTL	PR.STR - PRIMITIVE FOR 'STRING' SCAN

;	THIS ROUTINE IS CALLED BY THE PATTERN MATCHER WHENEVER
;	PR.STR IS ENCOUNTERED IN THE NODE
;	CALLING SEQUENCE:
;	JRST PR.STR
;	RETURN GOES TO LF, MF, OR SUCCESS

PR.STR::	HRRZ	T3,PARG+1(P2)	;  RETRIEVE LEN OF STRING FOR
	;	LOOPING AND TESTING
	CAMLE	T3,CURSOR	;  IF SIZE(STRING)>CURSOR . . .
	JRST	SC.LF		;  LENGTH FAIL
	MOVE	T2,PARG(P2)	;  T2 USED IN CVTPTR TO FORM
	;	POINTER TO STRING
	MOVE	Q3,SUBJ		;  Q3 USED IN SUBJ STRING
	MOVE	S1,CURSOR	;  SAVE OLD CURSOR VALUE
	MOVE	S2,STPTR	;  SAVE OLD STPTR VALUE
	MOVE	Z,PNDSZ+PARG+1(P2)	;  RETRIEVE POINTER TO STRING
	;	FROM NODE
	LDB	T1,STPTR	;  GET CHARACTER OF SUBJ, STRING
STRLP:	ILDB	S3,Z		;  GET CHARACTER OF STRING
	CAME	S3,T1		;  COMPARE =?
	JRST	RESPTR		;  NO, RESTORE OLD CURS AND PTR
	SOS	CURSOR		;  YES, UPDATE CURSOR . . .
	ILDB	T1,STPTR	;  AND STPTR AND GET CHARACTER
	SOJN	T3,STRLP	;  JUMP IF T3 NOT = 0.
	JRST	SC.S		;  =0, LOOP COMPLETE, RETURN.
;	ENTER HERE TO RESTORE THINGS
RESPTR:	MOVEM	S2,STPTR	;  STPTR RESTORED
	MOVEM	S1,CURSOR	;  CURSOR RESTORED
	JRST	SC.MF		;  MATCH FAIL

	SUBTTL	PR.CN1 AND PR.IN1 - IMMEDIATE AND CONDITIONAL NAMING ONE

;	THESE ROUTINES ARE ONE AND THE SAME - THEY PLACE
;	THE CURSOR VALUE ON THE STACK AND PLACE ALT 
;	ON HISTORY STACK
;	THEY ARE CALLED DURING NAMING BY PATTERN MATCHER.
;	CALLING SEQUENCE:
;	JRST PR.IN1	OR JRST PR.CN1
;	RETURN GOES TO SUCCESS

PR.XN1:: MOVE	Z,MAXLEN		;PLACE MAXLEN-CURSOR
	SUB	Z,CURSOR		;	(SUBSTR LEFT OFFSET)
	PUSH	STACK,[XWD IDT,0]	;	AS AN INTEGER
	PUSH	STACK,Z			;	ON THE SYSTEM STACK

	PUSH	HSR,[XWD D.XB1##,0]	;AND PUT THE FAILURE CLEANUP
	PUSH	HSR,Z			;	NODE ON H.S.
					;(DON'T NEED CURSOR OR STPTR)
	JRST	SC.S			;AND RETURN SUCCESS

	SUBTTL	PRCNB1 AND PRINB1 - IMMEDIATE AND CONDITIONAL NAMING WITH BACK-UP ONE

;	THESE ROUTINES ARE ONE IN THE SAME - THEY BOTH JUST
;	POP THE STACK AND RETURN LNTH FAILFULLY
;	CALLING SEQUENCE:
;	JRST PR.CNB1 OR JRST PR.INB1
;	RETURN GOES TO LNTH FAIL

PR.XB1:: SUB 	STACK,[XWD 2,2]		;POP SYSTEM STACK
	JRST	SC.LF			;AND GO GET THE REAL ALT

	SUBTTL	PR.CN2 - CONDITIONAL NAMING TWO

;	THIS ROUTINE PUSHES THE NAMESTACK WITH A VARIABLE AND THE
;	OLD AND NEW CURSOR VALUES - CALLED BY PATTERN MATCHER
;	CALLING SEQUENCE:
;	JRST PR.CN2
;	RETURN GOES TO SUCCESS

PR.CN2::MOVE	S3,NSTACK##	;  S3 -> NAMESTACK
	PUSH	S3,PARG(P2)	;  PUT VAR ON NSTACK . . .
	PUSH	S3,PARG+1(P2)	;  . . .
	PUSH	S3,[XWD IDT,0]		;DESCR HEAD FOR SUBSTR INDIC
	MOVE	Z,0(STACK)		;;NOW BRACKET THE MTCHED SUBSTR
	HLRZ	T1,SUBJ+1		;GET SUBJ'S BASIC OFFSET
	MOVE	T2,MAXLEN		;CALC OFFSET OF CUR POSIT
	SUB	T2,CURSOR		;	FROM STR HEAD
	SUB	T2,Z		;CUR OFFSET LESS BEGIN OFFSET=LNTH
	ADD	Z,T1		;MAKE UP REAL OFFSET IN SBLOK
	HRL	T2,Z		;COMPOSE OFFSET//LNTH
	PUSH	S3,T2			;AND STORE ON NAME STACK
	MOVEM	S3,NSTACK		;UPDATE NAME STK PERM PTR
	SUB	STACK,[XWD 2,2]	;POP THE CURSOR FM SYSSTK

	PUSH	HSR,[XWD D.CB2##,0]	;PUT THE FAIL FIXUP RTN
	PUSH	HSR,Z			;	INDIC ONTO H.S.
		;FIXUP NEEDS ONLY TO BE CALLED--
		; CURSOR & STPTR FIELDS WILL NOT BE USED
	JRST	SC.S		;  RETURN SUCCESSFULLY

	SUBTTL	PRCNB2 - CONDITIONAL NAMING WITH BACK UP TWO

;	THIS ROUTINE PUSHES TWO FULL WORDS OF ZEROS ON
;	THE STACK AND BUMPS THE NSTACK DOWN 4 WORDS
;	CALLING SEQUENCE:
;	JRST PRCNB2
;	RETURN GOES TO LNTH FAIL

PR.CB2::MOVE	S3,NSTACK	;  S3 -> NSTACK
	HLRZ	Z,0(S3)			;RETRIEVE STR DESC BOTTOM
	HLRZ	Q3,SUBJ+1		;GET SUBJ'S BASIC OFFSET
	SUB	Z,Q3			;	AND TAKE IT OUT,LEAVING
					;	THE LOCAL OFFSET
	PUSH	STACK,[XWD IDT,0]	;AND PUT IT BACK ONTO SYSSTK
	PUSH	STACK,Z			;	INCASE WE COME THRU PR.CN2 AGAIN
	SUB	S3,[XWD 4,4]	;	POP NSTACK
	MOVEM	S3,NSTACK	;  NSTACK VALUE CHANGED
	JRST	SC.LF		;GO GET REAL ALT

	SUBTTL	PR.IN2 - IMMEDIATE NAMING TWO

;	THIS ROUTINE ASSIGNS A VALUE IMMEDIATELY
;	CALLING SEQUENCE:
;	JRST PR.IN2
;	RETURN GOES TO SUCCESS

PR.IN2::
	POP	STACK,S2	;  POP MAXLEN-CURSOR INTO S2
	POP	STACK,(STACK)	;[207]POP OFF THE DESCR HDR
	MOVEI	T2,PARG(P2)		;EVALUATE ARG IF NECESSARY
	JSP	TLINK,PEVAL		;	AND PUT RSLT ON STK
	JRST	[ADD STACK,[2,,2]
		 JRST SC.MF]	; PUSH STACK AND FAIL
	
;	GO HERE TO TEST FOR VAR OR TVAR
IN23:	SETCM	Z,-1(STACK)	;  RETRIEVE DATATYPE
	TLNE	Z,NONDC+FLDC	;  TEST NONDC BIT
	ERROR	14,8		;  NOT A VAR OR TVAR
	HLRZ	T2,SUBJ+1	;  GET OFFSET FROM SUBJ STRING
	MOVEM	S2,T1		;  SAVE MAXLEN-CURSOR
	ADD	S2,T2		;  ADD MAXLEN-CURS TO ORIG OFFSET
	MOVE	S3,MAXLEN		; CURRENT STR OFFSET
	SUB	S3,CURSOR		; (MAX-CURS)	LESS
	SUB	S3,T1			; LEFT-SIDE OFFS GIVES LENGTH
	HRLM	S2,S3		;  OFFSET AND LENGTH OF STRING
	PUSH	STACK,SUBJ	;  FIRST DESC. WORD
	PUSH	STACK,S3	;  SECOND DESC. WORD FOR ASGNVL
	JSP	QLINK,FIXNUL	; MAKE 0-LENGTH STRINGS NULL

	HRLI	T1,D.IB2##	;SET UP FAILURE FIXER ON HIST STK
	PUSH	HSR,T1		;IF FAILURE COMES BACK THRU HERE,
	PUSH	HSR,Z	;STPTR UNUSED;	WE HAVE TO RESTORE THE CURSOR
		;TO THE SYSTEM STACK IN CASE FAILURE BACKS UP
		;A LITTLE BUT NOT AS FAR AS PR.XB1.
		;NOTICE THIS IS NOT THE CURSOR THAT WE'RE PUTTING
		;INTO THE CURSOR'S SLOT, BUT RATHER MAXLEN-CURSOR
		;I.E., THE LEFT OFFSET OF THE MATCHED SUBSTRING.
		;THAT'S PRECISELY THE QUANTITY THAT HAS TO GET
		;PUT BACK ON THE SYSTEM STACK IN CASE OF FAILURE.
		;NEVER MIND THE STPTR SLOT ON H.S.; IT'S NOT USED HERE.
		;SEE ALSO PR.IB2

	JSP	TLINK,ASGNVL##	;  GO ASSIGN VALUE 
IFE FTPAV,<
	ERROR	14,8		;COULDN'T ASSIGN IT.
>
IFN FTPAV,<
	JRST	SC.MF		;ASSIGNMENT FAILED -- MATCH FAILS
>
	SUB	STACK,[XWD 2,2]	;	POP STACK BEFORE RETURN
	JRST	SC.S		;  RETURN SUCCESSFULLY TO PM
	

	SUBTTL	PRINB2 - IMMEDIATE NAMING WITH BACKUP TWO

;		ROUTINE FETCHES MATCHED SUBSTRING OFFSET FROM H.S.
;		WHERE IT WAS SAVED BY PR.IN2 AND WAS TAKEN OFF H.S.
;		AND PUT INTO "CURSOR" BY SCAN.	THIS OFFSET IS THEN
;		PUSHED BACK ONTO SYSTEM STACK WHERE PR.IN2
;		EXPECTS TO FIND IT(JUST IN CASE BACKUP FINDS A 
;		SUCCESS AND RUNS FORWARD INTO PR.IN2 AGAIN)

;	CALLING SEQUENCE:
;	JRST PR.IB2
;	RETURN GOES TO LNTH FAIL

PR.IB2:: PUSH	STACK,[XWD IDT,0]	;PUSH THE LEFT-OFFSET
	PUSH	STACK,CURSOR		;BACK ONTO THE SYS STK
	JRST	SC.LF			;NOW GO GET THE REAL ALT

	SUBTTL	NAMELIST PROCESSOR - PNAMEL

;	THIS IS A SECONDARY ROUTINE CALLED BY THE PATTERN MATCHER
;	AND IS USED FOR PROCESSING THE NAME STACK
;	UPON ENTRY, S2 -> BASE OF NAME STACK AND S3 -> END OF NAME
;	STACK.	NAME STACK IS PROCESSED ON A FIFO BASIS.
;	CALLING SEQUENCE:
;	JSP	SLINK,PNAMEL
;	NORMAL RETURN

PNAMEL::	CAIL	S2,0(S3)	;S2 .LT. S3?
	JRST	0(SLINK)		;	NO - DONE - EXIT
	MOVEI	T2,1(S2)		;MAKE SURE ENTRY
	JSP	TLINK,PEVAL		;	IS EVALUATED
	JRST	PNAME1		;	FAILED- SKIP ASSGT
	SETCM	Z,-1(STACK)		;CHECK RSLT IS VAR OR TVAR
	TLNE	Z,NONDC+FLDC		;	SKIP IF SO
	ERROR	14,8			;	NOT.	CAN'T ASSIGN
	PUSH	STACK,SUBJ		;VALUE TO ASSIGN- STRING
	PUSH	STACK,4(S2)		;	AND THE SUBSTR BRACKETER
	JSP	QLINK,FIXNUL	; MAKE 0-LENGTH STRINGS NULL
	JSP	TLINK,ASGNVL		; ASSIGN IT
IFE FTPAV,<
	ERROR	14,8			;	COULDN'T
>
IFN FTPAV,<
	SKIPA			;ASSIGNMENT FAILED -- SO WHAT
>;END OF IFN FTPAV
	SUB	STACK,[XWD 2,2]		;POP VALUE OFF STACK

PNAME1:	ADDI	S2,4			;GO TO NEXT N.S. ENTRY
	JRST	PNAMEL			;	THEN LEAVE IF ALL DONE
	
	 ; TERTIARY ROUTINE TO CONVERT 0-LENGTH STRINGS TO NULL

FIXNUL:	HRRZ	Q2,0(STACK)	; GET LENGTH
	JUMPN	Q2,0(QLINK)	; INSTANT RETURN IF NOT NULL

	SUB	STACK,[2,,2]	; POP STACK
	PUSH	STACK,NULLST	; PUSH ON ...
	PUSH	STACK,NULLST+1	; NULL STRING
	JRST	0(QLINK)	; AND RETURN

	SUBTTL	CURS$ - BUILT-IN TO BUILD NODE

;	THIS ROUTINE BUILDS THE NODE AND ALLOCATES STORAGE OFF
;	SURF FOR THE PATTERN BUILDER.	CALLED WHEN @ SEEN.
;	CALLING SEQUENCE:
;	JSP	PLINK,CURS
;	ERROR RETURN
;	NORMAL RETURN FROM UPDATE(COMMON CODE)

CURS::	SETCM	Z,-1(STACK)	;  RETRIEVE 1ST WORD
	TLNE	Z,NONDC+FLDC	;  TEST FOR VAR OR TVAR
	JRST	CURS.X		;  MAY BE AN EXPRESSION

	JSP	TLINK,PATALL	;  ALLOCATE NODE
	MOVEI	Z,PR.CUR	;  PRIMITIVE FOR VAR OR TVAR
	MOVEM	Z,PPROG(T2)	;  PLACE IN PPROG
	JRST	UPDATE		;  NORMAL RETURN AFTER UPDATE
	
;	ENTER HERE IF EXPRESSION
CURS.X:	JSP	TLINK,CVTVAL	;  INSURE A VALUE
	ERROR	15		;  THIS CAN'T HAPPEN
	HLRZ	Z,-1(STACK)	;  RETRIEVE DATATYPE
	CAIE	Z,EDT		;  MUST BE AN EXPRESSION
	ERROR	14,7		;  WRONG KIND OF VALUE, HE LOSES

	JSP	TLINK,PATALL	;  ALLOCATE NODE
	MOVEI	S3,PR$CUR	;  PRIMITIVE FOR EXPR.
	MOVEM	S3,PPROG(T2)	;  PLACE IN PPROG OF NODE
	JRST	UPDATE		;  NORMAL RETURN

	SUBTTL	PR.CUR - PRIMITIVE FOR @VARIABLE

;	THIS ROUTINE ASSIGNS THE VALUE OF THE CURSOR TO A VARIABLE.
;	IT IS CALLED BY THE PATTERN MATCHER AS WELL AS
;	BY PR$CUR.
;	CALLING SEQUENCE:
;	JRST PR.CUR
;	RETURN GOES TO SUCCESS UNLESS A WEIRD ERROR OCCURS

PR.CUR::	PUSH	STACK,PARG(P2)	; PUSH NAME ONTO ...
	PUSH	STACK,PARG+1(P2)	; STACK
PR.CUS:	PUSH	STACK,[IDT,,0]	; PUSH DESCRIPTOR TOP

	MOVE	Z,MAXLEN	;  OBTAIN MAXLEN
	SUB	Z,CURSOR	;  SUBTRACT CURSOR
	PUSH	STACK,Z		;  PUSH VALUE TO BE ASSIGNED . . . 
	JSP	TLINK,ASGNVL	;  CALL ASGNVL
IFE FTPAV,<
	ERROR	15
>
IFN FTPAV,<
	JRST	SC.MF		;ASSIGNMENT FAILED -- MATCH FAILS
>
	SUB	STACK,[XWD 2,2]	;	POP STACK
	JRST	SC.S		;  NORMAL RETURN

	SUBTTL	PR$CUR - PRIMITIVE FOR @EXPRESSION

;	THIS ROUTINE DETERMINES IF AN EXPRESSION
;	WHICH IS EVALUATED HERE IS A VAR OR A TVAR
;	THEN PR.CUR IS CALLED TO ASSIGN VALUE.
;	CALLING SEQUENCE:
;	JRST PR$CUR
;	RETURN FINALLY GOES TO SC.S

PR$CUR::	MOVEI	T2,PARG(P2)		;LOC OF EXPR DESCR
	JSP	TLINK,PEVAL		;EVALUATE IT.
	JRST	SC.MF			;	FAILED.	PASS IT BACK
	SETCM	Z,-1(STACK)		;CHK RESULT IS VAR OR TRAPVAR
	TLNE	Z,NONDC+FLDC		;	SKP IF OK
	ERROR	14,7			;	NOT OK.	HOLLER
	JRST	PR.CUS			;GO JOIN COMMON CODE
	END
 tf