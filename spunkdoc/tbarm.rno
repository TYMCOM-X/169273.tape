.;THE SLASH OPTIONS FOR THIS FILE ARE /RIG:6  /UND:SEP
.Flag capitalize
.Flag underline
.flag index
.page size 55
.nonumber
.f .LM 0 .rm 69 .break .nj .p0
.c;TABLE OF CONTENTS
.tab stops 62
.s4;.lm+4;.nf;SECTION 1. INTRODUCTION	1
        1.1.  The Language	1
        1.2.  The Manual	2
.s2;SECTION 2.  SYSTEM CONCEPTS	3
        2.1.  Modules and Programs	3
                   Modules	3
                   Workspace Module	3
                   Libraries	3
                   Programs	4
        2.2.  Language Elements	5
        2.3.  Commands and Statements	6
                   Format	6
                   Line Continuation	6
                   Remarks	6
                   Commands	7
                   Statements	7
                        Indirect	7
                        Direct	8
                        Statement Modifiers	8
                   Statement Type Tables	9
                   Command Type Tables	12
.s2;SECTION 3. DATA	14
        3.1.  Type	14
                   Numeric Data	14
                   String Data	14
                   Logical Data	14
        3.2.  Type Conversion	15
        3.3.  Class: Scalars and Arrays	15
        3.4.  Constants	16
.s2;SECTION 4.  NAMES	18
        4.1.  Identifiers	18
        4.2.  Types for Identifiers	19
        4.3.  File Nomens	20
.s2;SECTION 5.  VARIABLES	23
        5.1.  Class and Type	23
        5.2.  Initial Value	23
.s1.tp12
        User-Defined Variables
.s1
        5.3.  Declarations for Variables	24
                   Array Declaration	24
                   Duplicate Declarations	24
                   Syntax	24
                   Implicit Declarations	25
        5.4.  Array Elements	25
        5.5.  Subarrays	25
                   Syntax	26
                   Semantics	26
                   The NAME statement	27
.s1
        System-Defined Variables
.s1
        5.6.  System-Defined Variables	28
                   System-Defined Scalar Variables	28
                   System-Defined Array Variables	28
.s2;SECTION 6.  EXPRESSIONS	30
        6.1.  General	30
        6.2.  Operator Precedence	30
        6.3.  Conversion of Types in Expressions	31
        6.4.  Arithmetic Operators	32
        6.5.  Matrix Operators	33
        6.6.  Bitwise Operators	34
        6.7.  Relational Operators	35
        6.8.  Boolean Operators	36
        6.9.  String Operators	37
        6.10.#Array Expressions	38
.s2;SECTION 7.  PROCEDURES	39
        7.1.  Class and Type	39
.s1
        User-Defined Procedures
.s1
        7.2.  EXTERNAL and ENTRY (Global) Procedures	39
                   Other-language EXTERNAL Procedures	41
                   The AKA clause in the DEF statement	41
        7.3.  Declarations for Procedures and Parameters	42
                   Syntax	42
                   Semantics	43
                   Parameters for EXTERNAL Procedures	44
        7.4.  Passing Arguments to Procedures	44
                   Number of Arguments	45
                   Passing Arguments by Name and Value	45
                   Type Conversion of Arguments	45
                   Array Parameters	46
        7.5.  Context, Scope, Local Variables and Procedures	46
                   Nested Procedures	47
                   Preservation of Values Across Calls	47
        7.6.  Procedure Value: Exiting from a Procedure	47
        7.7.  I/O Within a Procedure	47
.s1
        System-Defined Procedures
.s1
        7.8.  Table of System-Defined Procedures	48
                  Trigonometric Functions	48
                  Exponential Functions	49
                  Complex Functions	49
                  Numeric Functions	50
                  MAX and MIN Functions	51
                  SUM and PROD Functions	51
                  Matrix and Array Functions	52
                  Shifting Functions	53
                  String Functions	54
                  Utility Functions	56
.s2;SECTION 8.  EXECUTION	57
        8.1.  Overview	57
        8.2.  Command/Statement Phase	59
        8.3.  Compilation Phase	60
        8.4.  Load/Initialize Phase	63
        8.5.  Run Phase	64
        8.6.  Command Files	66
.s2;SECTION 9.  STATEMENTS	68
        9.1.  Statement Descriptions, Alphabetically	69
        9.2.  Statement Modifiers	100
.s2;SECTION 10.  COMMANDS, ALPHABETICALLY	103
.s2;SECTION 11.  FILE MANAGEMENT	122
        11.1.  Introduction	122
        11.2.  File Attributes	122
                   Mode	122
                   Protection	123
                   Type	123
                   Access Method and Record Length	125
                   Random Access Files	125
                   Sequential Files	126
        11.3.  Location and Position	126
                   Location 	126
                   Position	126
                   Carriage Returns and End of Record	127
        11.4.  The Terminal As a File	127
                   General	127
                   Program Activation Characters	128
        11.5.  Random-Access Operations	128
                   Erasing Part of a File	128
                   Changing Location	129
                   Record Boundaries	130
                   Example	135
.s2;SECTION 12.  FORMATTING	137
        12.1.  Introduction	137
                   Terminal Output	138
                   Output of Nul Characters	138
                   Array Input and Output	138
                   Input and Output of Carriage Returns	138
                   Definitions	139
        12.2.  Free-Form Formatting	140
                   Input	140
                   Output	140
                   Joining Input and Output	142
                   Conversion Characteristics	143
        12.3.  IMAGE Formatting	145
                   Long and Short Format Fields	145
                   Numeric Fields	146
                   String Fields	147
                   Free-Form Image	147
                   Literal Text	148
                   End of Image	149
        12.4.  FORM formatting	150
                   Formatting Characters	151
                   String Characters	156
                   Numeric Characters	157
                   Floating Characters	161
                   Utility Characters	164
                   Replication	165
                   FORM Input	167
                   FORM Output	168
                   Treatment of Eor's	169
.s2;APPENDIX A    Reserved Words	170
APPENDIX B    RUN-Phase Error Messages	171
APPENDIX C    Intraline Editing	175
APPENDIX D    XASC and IXASC Character Codes	187
APPENDIX E    EXTERNAL Procedures	189
APPENDIX F    Internal Array Handling	198
APPENDIX G    Automatically Generated Files	202
.s2;INDEX
.fill.lm-4
.page
.number page 1
.title TYMBASIC REFERENCE MANUAL        INTRODUCTION
.FT
.subtitle 1 January 1978                                                 Sec. 1.1
.c;SECTION 1.##INTRODUCTION
.skip 3
.f;This manual is intended as a specification of and
reference for the TYMBASIC language
implemented on  the Tymcom X systems.
.skip 2
^&1.1  THE LANGUAGE\&
.nj
.f;.s2;TYMBASIC comprises a set of statements, commands,
and functions, incorporating most of the Basic language extensions
found in SUPERBASIC-IX, as well as many features unique to this
implementation.
.skip 1
Features common to both languages include:
.skip 1
.LM+8;
.nofill
* direct and indirect statements
* string manipulation statements and functions
* logical, integer, double precision, and
   complex arithmetic
* extensive formatting capability
* built-in editing
* random access files
* binary files
* command files
.skip 1
.indent-8
Features unique to TYMBASIC include:
.skip 1
* compilation, rather than interpretation
* identifiers up to 15 characters
* user-defined procedures
* extended program control structures
* subarray naming and manipulation
* relocatable object programs
* calls to non-TYMBASIC subroutines
* non-ASCII collating capability
.lm-8;.fill
.subtitle 1 January 1978                                                 Sec. 1.2
.page
^&1.2  THE MANUAL\&
.nj;
.skip 2
Specifications of all statements and commands are presented in Sections
9 and 10, respectively, with each section arranged alphabetically.
Other sections discuss more general topics, often exemplifying effective
usage of the statements and commands.
The index may aid the user in bringing together the
specification of a particular language element with a discussion of its areas
of application.
.skip 1
.tp 20
Conventions used in the presentation are:
.x braces> in presentation
.x brackets> in presentation
.x dots> in presentation
.skip 1
.lm+8;
.i-2;*#Words shown in upper-case are keywords; words in lower-case are
generic terms describing a field to be filled by the user.  For example:
.skip 1
.indent 5
DATA text
.skip 1
The keyword DATA is to be entered, followed by any text.
.skip 1
.i-2;*#Braces indicate alternatives; brackets indicate options.  For example:
.skip 1
.indent 5
 #GOTO
.indent 5
 GO TO   line number
.skip 1
Either GOTO or GO TO may be used.
.skip 1
.indent 5
EXIT  [expression]
.skip 1
An expression following the EXIT is optional.
.skip 1
.indent 5
NO TRACE  [ variable list ] [ line range list]
.skip 1
.f;The command NO TRACE may be followed by a variable list and/or
a line range list or by nothing at all.
.skip 1
.i-2;*#Three dots (...) indicate that one or more repetitions of the preceding element
are allowed.  For example:
.skip 1
.indent 5
NEXT iteration variable  [,iteration variable ...]
.skip 1
NEXT may be followed by more than one iteration variable, with
each separated by a comma from the one preceding.
.skip 1
.lm-8;Generic terms (such as iteration variable) are defined in text immediately
following the usage.

.FLAG CAPITALIZE
.FLAG UNDERLINE
.FLAG INDEX
.F .LM 0 .RM 69 .BREAK .PAGE .NJ .P0
.title TYMBASIC REFERENCE MANUAL        SYSTEM CONCEPTS
.subtitle 1 January 1978                                                 Sec. 2.1
.FT
.C;SECTION 2.  SYSTEM CONCEPTS
.s2;^&2.1 MODULES AND PROGRAMS\&
.x definitions
.x concepts
.x definitions> modules
.x definitions> workspace
.x definitions> libraries
.x definitions> programs
.x modules> source
.x modules> relocatable
.x modules> definition
.x main program
.p;^&MODULES\&
.p;A module is a collection (often a file) of procedures and a main program.
There are two kinds of modules: source modules, which contain the symbolic text of the
module in the language the module was written (e.g., TYMBASIC, FORTRAN, MACRO)
and relocatable modules, which are derived from source modules by
compilation (or assembly in the case of MACRO).
.x compilation
.x assembly
Relocatable modules may be loaded together to form an executable program.
.x loading
.x execution
.p;A source module may be changed or edited and then compiled to create a new
.x editing
relocatable module corresponding to the new source module.
.p;The difference between the two kinds of modules is normally reflected
by the file extension of the module.
.x extension
.x file extension (see ^Extension)
For example, PROG.TBA would be a source module and PROG.REL would be its
.x <REL file
.x <RDL file
corresponding relocatable module (or PROG.RDL if the module contains
debugging information).
.x debugging
The file name (e.g., PROG) is considered to be the name of the module,
whether it be source or relocatable.
.x modules> name
.p;^&WORKSPACE MODULE\&
.x workspace> definition
.p;A source module may be a collection of TYMBASIC statements
contained in the user's TYMBASIC workspace.
The workspace module may be edited using TBA editing commands
and it may be saved as a file (using the SAVE command).
.x saving the workspace (see ^Workspace, saving)
.x <SAVE
If saved, the workspace is associated with the file and
the two are known by the same name (called the workspace name).
.x workspace> name
.x workspace> name
Any operation that names the workspace associates the workspace with a file
(for example, loading statements into the workspace with the GET command).
.x names> of workspace (see workspace name)
.x <GET
.p;^&LIBRARIES\&
.x libraries
.p;A library is a file that contains a collection of relocatable modules.
It may also contain an index to the procedures contained within those
modules.
.p;If a library has been specified by the use of the LIBRARY command,
it is searched during the creation of a program.
^&Only\& those modules that contain procedures needed by the rest of the program
are taken from the library and made part of the program.
.tp 15
.p;^&PROGRAMS\&
.x programs
.x modules> in a program
.p;Each TYMBASIC program is composed of several relocatable modules, as follows
(see also Execution, Sec.#8):
.list
.le;If the module list is empty, the workspace module.
.le;If the module list is not empty, every module in the module list.
The workspace may be added to the module list.
.x module list
.x workspace
.le;Modules extracted from the libraries specified in the user's library
list, as needed by the rest of the program.
.x library list
.le;Modules from the TYMBASIC library and other system libraries
that form the environment of the program or that are needed by the
rest of the program (the SIN routine, for example, if called).
.els
.p;One of the modules in the first or second group is called the startpoint
.x starting point
module; it contains the starting point for the program, similar to a Fortran MAIN program.
.x startpoint module (see ^Modules, startpoint)
.x modules> startpoint
The default startpoint module is the workspace (or a direct statement if one
was entered).
.x workspace
The STARTPOINT command is used to  specify a different startpoint module.
.x <STARTPOINT
In the general case the startpoint module will make procedure calls to procedures
located within the other modules.
.p;Note that since modules are independently compiled, the line numbers
and variable names of one module are not known outside that module;
only global procedures are known to other modules (see Sec.#7.2).
.subtitle 1 January 1978                                                 Sec. 2.2
.page;^&2.2. LANGUAGE ELEMENTS\&
.s2;The TYMBASIC language consists of the following language elements:
.s2.nf
.lm+5
Language Element                        See
----------------                        ---
.s
Line Numbers                            Sec.#2.3
Identifiers                             Sec.#4.1
File Nomens                             Sec.#4.3
Constants                               Sec.#3.4
Remarks (comments)                      Sec.#2.3
Operators                               Sec.#6
Line Continuation Charactes             Sec.#2.3
Terminal End-of-File Characters         Sec.#8.6
.lm-5.f
.subtitle 1 January 1978                                                 Sec. 2.3
.page
.p;^&2.3 COMMANDS AND STATEMENTS\&
.x commands
.x statements
.p;TYMBASIC is called by the XEXEC command TBA.
.x <TBA
.x <XEXEC
Thereafter, TYMBASIC commands and statements can be entered.
.tp 7
.s;^&FORMAT\&
.x line length
.x statements> length
.x carriage returns
.x line feeds
.x control characters
.x limits> line length
.x commands> length
.f;.s;Commands and statements may contain up to 256 characters,
counting line numbers and spaces (but not including the carriage return
.x line numbers
or line feed at the end).
Control characters are not allowed within commands or statements.
At least one space must be
entered between adjacent alphanumeric language elements to avoid
ambiguity, but non-alphanumeric elements do not require space
character separators:
.x statements> format
.tab stops 8
.s.nf;
	10 A=B+C
.s;is equivalent to
.s
	10 A = B + C
.s;.f;Command and statement input is terminated by typing a carriage return.
.p;^&LINE CONTINUATION\&
.x _&
.x ampersands
.x line continuation
.x continuation of long lines
.p;Input that exceeds the user's terminal line length may be
continued by typing an ampersand and a carriage return.
.x line length> terminal
.x terminal> line length
Any number of lines may be entered up to the 256 character limit
(the line continuation itself counts as one character).
Lines may be split between any two language elements.
For example:
.s.nf
.lm+8
_>10 let a(val(substr(f$,n,m-n),p$+"%")) = _&
         b(n,sum(c(i) for i=1 to m) div _&
         x mod (y^z)
_>20 !Whew
.fill
.lm-8
.tp 10;.s2;^&REMARKS\&
.x <DATA
.x !
.x comments
.x documenting> programs
.x remarks
.s;An exclamation point that does not appear within a quoted string or
.x quotation marks> with _!
in a DATA statement delineates the beginning of a comment or remark
in a command or statement.
The comment continues to the end of the command or statement.
In a statement, the comment will print with the source module listing
but will have no effect on module execution.
The REM statement (REMark) has a similar effect, but can only be
.x <REMARK
used at the beginning of the line.
.x <REM
.tp 7;Examples:
.s;.nf;
	_> !This is a comment
	_>20 REM so is this
	_>30 A = B !The rest is comment
	_>40 B = C REM But this is an error.
.i8;ERROR   ...NEAR 'B = C? REM'
.f
.p;^&COMMANDS\&
.page size +1
.s;Commands are executed immediately.
They are not made part of the workspace module and do not require a compilable module in the
.x workspace
workspace in order to execute, as do statements.
Commands may not contain expressions.
For example:
.s;
.nf
	_-tba
        Ver. 4.0
	_>get trial.tba
	_>library (tbatlib)tlib
	_>run
.S;.f
The GET, LIBRARY and RUN commands above are executed
immediately, and they are not stored in any file.
.p;^&STATEMENTS\&
.p;Statements are the basic components of the TYMBASIC language.
There are two kinds of statements: indirect statements and direct statements.
Every statement is checked for syntactic correctness immediately after
it is entered into TYMBASIC.
.p;^&Indirect Statements\&
.p;Statements may be grouped together to form a module.
These statements are called indirect statements because execution
of them does not occur until the module is loaded into
a program and run.
In this case, each statement is preceeded by a line number.
Tne numbers determine the order of the statements within the module,
and must be unsigned integers not exceeding 99999.
.x statements> indirect
.x indirect statements (see ^Statements, indirect)
.x line numbers
.x workspace
.x statements> order
.x line numbers
.x line numbers> range
A TYMBASIC source module may contain up to 16,000 indirect statements.
.x limits> statements
.x statements> limits
For example:
.s;.nf
	_-tba
        Ver. 4.0
	_>get trial.run
	_>15 let a=21
.f
.p;The LET statement is inserted into the workspace module TRIAL.RUN according
to the statement number (for instance, between statements 10 and 20,
possibly replacing a previously existing line 15).
The statement will become part of the
version of TRIAL.RUN stored on a file  only if the workspace is written back
out to the file by a SAVE command.
.x <SAVE
.x workspace> saving
All TYMBASIC statements may be used indirectly.
.tp 5
.p;^&Direct Statements\&
.page size -1
.p;If a statement is
entered without a line number it is immediately compiled as a
module in itself, loaded with the rest of the program, and executed.
The direct statement does not become part of the workspace
module.
It is, however, compiled and executed in the context of the
workspace module (see Sec.#7.5).
Therefore, it may operate on variables and call procedures
defined in the workspace module and it may also call procedures defined as
EXTERNAL by the workspace module.
.x context
.x Direct statements (see ^Statements, direct)
.x statements> direct
For example:
.s;.nf
	_-tba
        Ver. 4.0
	_>get trial.run
	_>let a=21
	_>start
.s;.f;The workspace variable A is set to 21 by the LET statement
before the START command causes execution of the program to begin
(see also Section 8, Execution).
The LET statement is not part of the module TRIAL.RUN.
.p;Not all statements may be entered directly (see Statement Types, below).
.s2;^&Statement Modifiers\&
.x statement modifiers
.s;Most statements may include statement modifiers, which appear to the right
of the statement body.
The modifiers can cause iterative or conditional execution of the statement
and can also assign certain values
to  variables prior to execution of the statement body.
See Sec.#9.2.
Examples:
.s2.lm+8.lit
10 PRINT A(I) FOR I = 1 TO 10
20 OPEN F$, INPUT, J WHERE J = GET.UN
30 CALL FUNC(I) WHILE I<X-Y
40 PRINT FUNC(I) FOR I = J TO 100 WHERE J = FUNC2(X)
.end lit
.lm-8
.page
^&STATEMENT TYPES\&
.x statements> types
.s;The following table groups TYMBASIC statements
by function.
Those statements that may not be entered directly are indicated by the
appearance of an "X" in the right-hand column.
.x statements> direct
.x statements> indirect
Each statement is described fully in Section 9.1, where they
are listed in alphabetical order.
.s;Note that some statements appear in more than one
group.
For instance, COPY appears in the Utility group because it can copy one
file to another; it also appears in the IO group because it can
copy a file to/from the terminal.
.x statements> by group
.subtitle 1 January 1978                                                Sec. 2.3
.page
.page size +4
.tab stops 6,18,61
.c;I/O  STATEMENTS
.x <I/O statements
.x Statements> <I/O
.nf;.s;    Statement               Effect                      Indirect Only
.s
	CIB	clears terminal input buffer
	CLOSE	closes files
	COB	clears terminal output buffer
	COPY	copies files (including terminal)
	DATA	supplies data values	X
	EIGHTI	reads eight-level terminal input
	EIGHTO	sends eight-level terminal output
	ERASE	erases parts of files
	INPUT	inputs from terminal or file
	LOCATE	sets location on file
	LOL	sets line length
	OPEN	opens file
	PRINT	prints at terminal or file
	READ	reads from DATA statements
	REMOVE	deletes file
	RESTORE	resets pointer to top of DATA block
	WRITE	same as PRINT
.s3
.c;PROGRAM CONTROL  STATEMENTS
.x statements> program control
.x program control statements
.tab stops 6,16,62
.s;    Statement             Effect                        Indirect Only
.s
	ELSE	begins alternate statement group	X
	END	stops execution (same as STOP)	X
	ENDIF	ends extended IF statement	X
	FOR	begins loop	X
	GOTO	transfers control to statement
	IF	begins conditional statement
	LOG	stops session
	NEXT	ends FOR loop	X
	NO	cancels ON condition
	ON	transfers control on condition or value
	ORIF	starts alternate statement group	X
	PAUSE	interrupts execution	X
	QUIT	transfers to XEXEC
	RESUME	resumes execution after ON condition
	STOP	stops execution (same as END)	X
	WAIT	suspends execution for a period of time	X
		or until the output buffer is empty
.s3
.TP 15;
.c;SUBPROGRAM  STATEMENTS
.x subprogram statements
.x statements> subprogram
.tab stops 6,18,62
.s;    Statement             Effect                      Indirect Only
.s;	CALL	calls procedures
	DEF	defines procedures	X
	ENDF	ends procedure definition	X
	EXIT	returns from procedures
	GOSUB	transfers to subroutines
	RETURN	returns from subroutines
.s3;
.c;VARIABLE MANIPULATION  STATEMENTS
.x variables> manipulation statements
.x Variables> array manipulation statements
.x arrays> manipulation statements
.x statements> array manipulation
.s;    Statement            Effect                       Indirect Only
.s;	LET	optional assignment statement prefix
	MAT	optional matrix (array) prefix
.s3
.c;VARIABLE  DECLARATION  STATEMENTS
.x data> declaration statements
.x statements> variable declaration
.x variables> declaration statements
.x declaration> variables
.tab stops 5,16,62
.s;    Statement            Effect                        Indirect Only
.s;	COMPLEX	declares complex variables	X
	DIM	declares variables	X
	DOUBLE	declares double precision real variables	X
	INTEGER	declares integer variables	X
	LOGICAL	declares logical variables	X
	NAME	declares subarrays	X
	REAL	declares real (single precision) variables	X
	STRING		X
	or TEXT	declares string variables	X
.s3;.c;UTILITY  STATEMENTS
.x utility statements
.x statements> utility
.tab stops 5,19,62
.s;    Statement            Effect                         Indirect Only
.s;	BASE	changes array default lower bound
.x arrays> bounds
	BOUNDARY	sets minimum values for free
		form output
	COPY	copies files
	ERASE	erases parts of open files
	MAT	optional matrix (array) prefix
	NO	cancels ON condition
	REM	remarks (comments)
	REMOVE	deletes file
	RENAME	changes file name
	SIGNIFICANCE	sets _# digits for free-form output
.page size -4
.f.s2;^&COMMAND TYPES\&
.x commands> types
.s;The following table groups TYMBASIC commands by
function.  Each command is described fully in
Section 10, where they are listed alphabetically.
.nf;.s3;.c;CONTROL  COMMANDS
.x control commands
.x commands> control
.x program control commands
.x commands> program control
.tp12
.s;    Command            Effect
.s;	BREAK	sets lines for execution interrupt
	DO	executes a command file
	GO	resumes interrupted execution
	LOG	stops session
	INITIALIZE	compiles, loads and initializes program
	QUIT	transfers to XEXEC
	RUN	compiles, loads, initializes, initiates execution
	START	initiates execution, without initializing
	STEP	executes specified number of statements
.s3;.c;DEBUGGING  COMMANDS
.x debug commands
.x commands> debug
.tp10
.s;    Command            Effect
.s;	BREAK	sets lines for execution interrupt
	CDE	prints code generated
	DEBUG	sets diagnostic features on
	DUMP REFS	saves cross reference information
	PMC	prints intermediate code from parser
	SYMD	prints compiler variable definition
	TRACE	traces execution of lines or variables
.tp15
.tp10;.s3;.c;EDITING  COMMANDS
.x edit commands
.x commands> edit
.tp10
.s;    Command           Effect
.s;	DELETE	deletes lines
	EDIT	prints line, allows editing
	MODIFY	allows editing but does not print line first
	RENUMBER	renumbers lines in workspace
.tp16
.s3;.c;UTILITY  COMMANDS
.x utility commands
.x commands> utility
.s;    Command           Effect
.s;	DLIST	lists workspace, with name, date and time
	ECHO	echoes input characters to TOUT destination
	ENTER	gets statements from command source, supplies _#s
	GET	loads statements into workspace
	LIBRARY	adds files to library list
	LIST	list lines from workspace, or lists status
	MERGE	merges statements from file into workspace
	MODULE	adds files to module list
	RENUMBER	renumbers lines in workspace
	SAVE	stores workspace on file
	SAVE BINARY	stores program as executable file
	TABS	sets tab stops
	TOUT	specifies terminal output (TOUT) destination
.f
.;THE SLASH OPTIONS FOR THIS FILE ARE /RIG:6

.Flag capitalize
.Flag underline
.flag index
.page size 55
.f .LM 0 .rm 69 .nj .p0
.first title
.title TYMBASIC REFERENCE MANUAL          DATA             
.subtitle 1 January 1978                                                Sec. 3.1
.page.c;SECTION 3.  DATA
.x data> types (See ^Types)
.x types> data
.x numbers
.x strings
.s2;^&3.1. TYPE\&
.s;There are three groups of data types within TYMBASIC:
numeric, string, and logical.
.s2;^&NUMERIC DATA\&
.s;Numeric data includes integers (type INTEGER), single-precision
real numbers (type REAL), double-precision real numbers (type
DOUBLE), and complex numbers (type COMPLEX).
.s;INTEGERS are represented as 1 word (36-bit) exact-precision quantities, with the
range:
.x integer> range of
.s.i8;-34,359,738,367 through +34,359,738,367 
.s;REALS (single-precision) are 1-word floating-point
quantities with precision through 7 decimal digits.
Range:
.x real> range of
.s.i8;-10**38 through -10**-38, 0, +10**-38 through +10**38
.s;DOUBLES (double precision) are 2-word floating-point
quantities with precision through 18 decimal digits.
The range is the same as for reals.
.x double> range of
.s;COMPLEX numbers are represented as a pair of reals, the
first representing the real part, the second the imaginary part.
.x complex> definition
.x precision> for numeric types
.x strings> definition
.s2;^&STRING DATA\&
.s;A string (type STRING) is a sequence of from 0 to 4095 characters.
Each character has a 7-bit value (a range of 0 to 127) and can
be interpreted as a character in the ASCII character set.
.x logical> definition
.s2;^&LOGICAL DATA\&
.s;A logical data item (type LOGICAL) may have only the
values TRUE (+1) or FALSE (0).
It is represented as a 1-word integer.
.page
.subtitle 1 January 1978                                                Sec. 3.2
.s2;^&3.2.  TYPE CONVERSION\&
.x conversion
.p;During the evaluation of expressions, the passing of arguments
to procedures, and the assignment of values to variables, TYMBASIC will
automatically convert a value to match the expected
or required type, if possible.
Automatic type conversion follows these rules:
.list.le;String can not be automatically converted to numeric or logical
and vice-versa.
.le;Real (single or double precision) to integer conversion is by
rounding as in the Algol standard (.5 rounds in the positive direction).
.x rounding
.le;A non-zero integer value converts to a TRUE (+1) logical value,
and zero to FALSE.
.le;A TRUE logical value converts to an integer +1, FALSE to 0.
.le;Single to double precision conversion is by adding a second
word of zero.
.le;Complex is converted to real by dropping the imaginary part,
and real is converted to complex by providing a zero imaginary part.
.end list
.x class> definition
.x scalars> definition
.x arrays> definition
.subtitle 1 January 1978                                                 Sec. 3.3
.page size +2
.s2;^&3.3. CLASS: SCALARS and ARRAYS\&
.s;Data is divided into two classes: scalar and
array.
.s2;^&SCALARS\&
.s;A scalar is a single value.
.x arrays> elements
.x arrays> dimensions
.x arrays> subscripts
.x subscripts (See ^Arrays,subscripts)
.x arrays> bounds
.s2;^&ARRAYS\&
.s;An array is an ordered set of scalars called the array
elements.
It is construed as a rectangle having a fixed number of
dimensions or subscripts (between 1 and 10, inclusive).
Each dimension has an integral length defined by an
upper and lower bound.
The size of the array is the product of the lengths of the
dimensions, and the elements of the array are ordered
according to the value of each subscript.
.s;Vectors and matrices are simply arrays that have 1 and 2 dimensions,
respectively.
.x vectors
.x matrices
.s;The number of dimensions that a data item has determines its
"dimensionality."
Scalars are considered to have dimensionality zero.
.x dimensionality> definition
.subtitle 1 January 1978                                                Sec. 3.4
.s2;^&3.4. CONSTANTS\&
.page size -2
.x constants> numeric
.s;A constant is a data item whose value cannot change
during program execution.
That is, its value may be ^&read\& but not ^&written\&
and the value read will never change.
.s;There are no constants of class array nor of type complex.
The form of constants is given by type below.
.s2;^&INTEGER CONSTANTS\&
.s;Integer constants can appear in two forms: decimal and octal.
.s;A decimal integer constant consists of one or more decimal digits
such as
.s.i8;1
.i8;5280
.s;An octal integer constant consists of one or more octal digits
(0 through 7) followed by the letter B.
For example:
.s.i8;2B
.i8;104B
.s2;^&REAL CONSTANTS\&
.s;A real constant consists of one or more digits and a decimal
point, such as
.s.i8;3.14
.i8;21.
.i8;_.0001
.x ^E> in constants
.x ^exponents> in constants
.s;A real constant may also be written as a sequence of digits 
(possibly including a decimal point) with a trailing exponent (E-format).
.x E-format
The exponent consists of the letter E followed by a one or two
digit integer, which may be signed.
The integer is the power of 10 to which the number will be
raised.
Imbedded spaces are not allowed.
For example:
.nf;
.s.i8;_.314E01
.i11;or     (=3.14)
.i8;_.314E1
.s.i8;896.715974E06       (=896715974)
.f;
.s2.tp5;^&DOUBLE CONSTANTS\&
.s;Double constants are identical in appearance to real
constants with exponents, except that the letter D is used
instead of E.
Example:
.x ^D> in constants
.x <pi
.x <dpi
.s.i8;896.715974D12
.f;
.s;There are two special constants, PI and DPI, of type
REAL and DOUBLE, respectively, that represent the single and
double precision values of pi.
.s2;^&STRING CONSTANTS\&
.x constants> string
.s;A string constant consists of a sequence of printable characters
(possibly none) enclosed in single or double quotation marks.
For example:
.lm+8.s.nf;'This constant has 28 characters'
"because spaces are characters"
""
'"" is a null string'
.lm-8;
.f
.s2;^&LOGICAL CONSTANTS\&
.x constants> logical
.s;Logical constants are limited to two:
TRUE and FALSE, which have integer values of one and zero,
respectively.
For example:
.x True
.x False
.s.i8;10 IF A_<400 THEN EXIT TRUE
.Flag capitalize
.Flag underline
.flag index
.page size 55
.f .LM 0 .rm 69 .nj .p0
.first title
.title TYMBASIC REFERENCE MANUAL          NAMES
.subtitle 1 January 1978                                                Sec. 4.1
.page.c;SECTION 4. NAMES
.X names
.s2;^&4.1 IDENTIFIERS\&
.x identifiers
.s;Identifiers are those language elements which name variables,
procedures, parameters, and TYMBASIC keywords.
.X keywords
.x reserved words
.x <TYMBASIC keywords
.s;A TYMBASIC identifier may be up to 15 characters.
The first character must be alphabetic, the rest
alphabetic, numeric, or periods.
The last character may be a $.
Some legal identifiers:
.s;.i8;A1
.i8;test.result.100
.i8;NAME.OF.JOB$
.x case independence
.x lower case
.s;Lower and upper case characters are equivalent in
identifiers.
STRING.A$, string.a$, and String.A$, for example, are
equivalent, and all refer to the same variable.
.s;There are two groups of identifiers: user-defined identifiers
and TYMBASIC keywords.
.s;User-defined identifiers may not duplicate TYMBASIC keywords,
which are listed in Appendix A.
.s;There may be up to 4095 user-defined identifiers in a
TYMBASIC source module.
.x identifiers> number of
.subtitle 1 January 1978                                                 Sec. 4.2
.page;^&4.2. TYPES FOR IDENTIFIERS\&
.x types> default for identifiers
.x default data type
.s;Every user-defined identifier, and many TYMBASIC 
keywords, have a type (integer, real, double, complex, string
or logical).
The type for a TYMBASIC keyword is 
predetermined, but the user may assign any type to 
a user-defined identifier, either explicitly or by default.
.p;Explicit: identifier type may be explicitly given in
a declaration:
.s.lm+8.nf
_>10 DOUBLE A, B, C(1:15)
_>20 COMPLEX COMPN
_>30 STRING SIGNOFF
.f.lm-8
.p;Implicit: in the absence of any explicit declaration, the type is
STRING if the identifier ends with a $,
the type is REAL otherwise.
For example:
.s.lm+8.nf
_>10 SIGNOFF$ = "Goodbye"
_>20 A, B, C = 10.25
.f.lm-8
.p;An explicit declaration overrides the implicit convention:
.nf.lm+8.s
_>10 REAL F10$
_>20 INTEGER SIGNOFF$
.f.lm-8
.p;F10$ and SIGNOFF$ are real and integer, respectively.
.subtitle 1 January 1978                                                Sec. 4.3
.page;^&4.3. FILE NOMENS\&
.x names
.x variables> names
.page size +1
.s;A TYMBASIC file "nomen", i.e., the total expression by which a
file is named, is the construct that specifies user directory,
file name with extension, and confirmation keyword.
The general syntax for file nomen is:
.x file nomen
.x names> of files
.s;[user directory] file name [.[extension]][confirmation keyword]
.s;Note that the term "file name" applies only to a specific
component of a file nomen.

.p;Examples:
.skip 1
.nofill
.nojustify
.lm+8;TEMP
TST.SBA
(JONES)MLIB.REL-NEW
(Jones)mlib.rel-n
(SMITH)FXX.-E
FXX.TST-A
[13426,734032]FILE.xyz-exist
.lm-8;.skip 1
.p;In all parts of a file nomen lower case is equivalent to upper case.
.x case independence
.x lower case
.s2;^&User Directory\&
.x user directory
.x user name
.f;.s;The user directory must be given when referring to a file
belonging to another user.
It consists of either a user name enclosed in parentheses or a PPN enclosed
in square brackets.
.p;User names can be one to twelve characters; if greater,
an error condition is generated.
TYMBASIC allows dots in user names, e.g. (jones.A)FXX.TST
(the dot is part of the twelve allowable characters).
.p;A PPN is a pair of octal digit strings separated by a comma.
Each octal digit string may be from one to six digits.
.x <PPN
.s2;^&File name\&
.x file names
.s;A file name must be at least one character long and must contain
no spaces.  If a file name
greater than six characters is entered, it is truncated to six
characters.
.s;File names consisting of three-character or longer truncations
of the word TERMINAL (TER, TERM, etc.)
are abbreviations for TERMINAL.
File names whose first six characters are TERMIN but whose
succeeding characters differ (e.g., TERMINXY), or that appear with
a user directory or extension are illegal.
.tp10;.s2;^&Extension\&
.page size -1
.x extension
.x extension> in file nomen
.s;If a period (dot) follows the file name then the
characters following the period constitute
the extension.
If the period is followed by a non-alphanumeric then the extension is explicitly null.
If the extension entered is greater than three
characters, it is truncated to three.
.s2;^&Default Extension\&
.x default extension> definition
.p;If no extension appears in a file nomen then a default extension is
inserted if one exists for the operation in question.
If the file with the inserted extension is being opened for input and cannot be found,
then a null extension is inserted.
For example:
.p.lm+8.nf;_>GET FLS
.f.lm-8
.p;TYMBASIC will look for FLS.TBA first; if it is not found TYMBASIC
will then look for FLS_.#_.
.s2;^&Confirmation Keyword\&
.x confirmation keyword
.x confirmation keyword> in file nomen
.s;.f;A confirmation keyword, if used, consists of a dash followed
by any left subset of the words EXISTING (to allow an existing file
.x confirmation keyword
to be overwritten); NEW (to indicate awareness that a new file is
being created); or ANY (to indicate indifference as to whether the
file exists or not).  If an incorrect declaration is made, an error
condition is generated and the request is not processed.  Note the
following:
.s;.lm+8;.nf;_>SAVE FLS.K-EXISTING
File does not exist FLS.K
_>SAVE FLS.M-NEW
File already exists FLS.M
.lm-8;.p;.f;If a confirmation keyword is not used, then TYMBASIC supplies
prompts to remind the user of the current status of the file.
If the file already exists, TYMBASIC prints a prompt message;
for example:
.I8;.s;.nf;_>SAVE FLS.P
.I8;FLS.P: Existing file--OK?
.f;.s;If the user types YES (or a left subset of it) and a carriage
return, then the request is executed.
.p.tp7;If the file does not already exist, then TYMBASIC so informs the requestor:
.s.lm+8.nf
_>10 OPEN "FLS.B", OUTPUT, 1
_>RUN
FLS.B: New File--OK?
.f.lm-8
.s;Again, if the user then types YES (or Y or YE) and a
carriage return, the request is executed.
If the user answers NO (or N) the request is not executed
and an error condition is generated.
This file confirmation procedure is used whenever a file is
being opened for output in TYMBASIC.
.skip 2
.x quotation marks> with file nomens
^&Quotation Marks with File Nomens\&
.
.s;File nomens used as operands of the commands GET, SAVE, DUMP REFS, INITIALIZE,
RUN, MERGE and DO are interpreted literally and, therefore,
need not be enclosed in quotes.
However, quotation marks must surround file nomens that begin
with a numeric.
.;THE SLASH OPTIONS FOR THIS FILE ARE /RIG:6

.Flag capitalize
.Flag underline
.flag index
.page size 55
.f .LM 0 .rm 69 .nj .p0
.first title
.title TYMBASIC REFERENCE MANUAL          VARIABLES
.subtitle 1 January 1978                                                Sec. 5.1
.page.c;SECTION 5. VARIABLES
.x variables
.x data> in variables
.s2;Variables, named by identifiers, are the
receptacles for data.
.x identifiers
Variables may be read or written during program execution.
.br;Certain variables are system-defined (defined by TYMBASIC);
others may be defined by the user.
.x variables> system-defined
.x variables> user-defined
.x system-defined variables (see ^Variables)
.nf
.s.lm+8;Kinds of Variables:           Class:
.x variables> simple
.x variables> arrays
.x variables> array element
.x variables> subarray
.x arrays> variables (see ^Variables)
.s.lm+2;Simple Variable               scalar
Array Variable                array
Array Element                 scalar
Subarray                      array
.lm-10
.f;
.s2;^&5.1. CLASS _& TYPE\&
.x class
.x types> variables
.x variables> type
.x variables> class
.s;Variables can be of either class, scalar or array, and both
scalar variables and array variables may be of any type
.x dimensionality
.x variables> dimensionality
(integer, real, double, complex, string, or logical).
.s;The type and dimensionality of a variable may not
change during program execution.
For example: a scalar variable may not change into an array
variable; an integer variable may not change into a logical
variable; and the number of dimensions of an array variable
may not change.
.subtitle 1 January 1978                                           Sec. 5.2
.s2;^&5.2 INITIAL VALUE\&
.s;The initial value assigned to a user-defined variable depends
on the variable type:
.x variables> initial value
.x initial values
.x types> initial value
.s.i8;numeric = zero  (integer, real, double, complex)
.s.i8;logical = zero or FALSE
.s.i8;string  = null (as if defined to be "")
.x initialization
.x variables> declaration (see ^Declaration)
.s;All simple variables are given initial values during Initialization
(see Execution, Sec.#8.4), and all variables except subarrays are re-initialized
when a declaration for the variable is executed.
.x declaration> variables
.s;Initial values for system-defined variables are documented
with their definitions.
.x variables> system-defined
.subtitle 1 January 1978                                                Sec. 5.3
.page;
.c;USER-DEFINED VARIABLES
.s2;^&5.3. DECLARATIONS FOR VARIABLES\&
.s;The declaration statements (INTEGER, REAL, DOUBLE, COMPLEX,
STRING, LOGICAL and DIM) determine the type and dimensionality
of simple and array variables.
.x <integer
.x <real
.x <double
.x <complex
.x <string
.x <logical
.x <dim
.x declaration> variables
.x types> declaration
.x dimensionality
.x declaration> dimensionality
.x declaration> type
.x default data type
.x types> default
.x variables> default type
.x variables> dimensionality
.s;The type of variables declared in the DIM statement
(or not declared at all)
is determined according to the name of the variable: the type
is string if the name ends with a $, otherwise the type is real.
.x <DIM
.s;The declaration statements are partly executable, partly
non-executable.
When a declaration statement is executed, the
declared variables are initialized (i.e., their values are
set to the initial values depending on type, as described
in Sec.#5.2) and any data they contained previously is lost.
A declaration is non-executable in that it determines the
type and dimensionality of a variable and these
attributes can never change during program execution.
.x data> in variables
.s2;^&ARRAY DECLARATIONS\&
.s;When an array declaration is executed, the
array is re-dimensioned and its new size is determined
according to the given dimension bounds.
Note that when an array declaration is executed 
all data previously contained within the array is
replaced by initial values.
.x declaration> array
.x arrays> declaration
.x arrays> size
.x arrays> dimensions
.x size> array
.s;Execution of an array declaration must precede any reference
to the array or to elements within the array.
It is not mandatory, however, that a declaration for a scalar
variable be executed prior to references to that scalar variable.
.s2;^&DUPLICATE DECLARATIONS\&
.x declaration> duplicate
.s;A module may contain more than one declaration for a given variable.
Duplicate declarations must agree in type, class and number of
dimensions, but the dimension bounds of an array may change.
.tp5;.s2;^&SYNTAX: THE VARIABLE/DIMENSION LIST\&
.x variable/dimension list
.x declaration> variables> syntax
.s;Each declaration statement consists of the statement identifier
(REAL, DIM, etc.) followed by a variable/dimension list which lists
simple and array variable identifiers separated by commas.
.s;Each array variable identifier is followed by a 
parenthesized list of dimension bounds, one for each dimension,
separated by commas.
The dimension bounds consist either of one numeric expression,
representing the upper bound, or two numeric expressions separated
by a colon, representing the lower and upper bounds.
If only the upper bound is specified, the current
value of BASE (at the time of the execution of the
declaration statement) is used as the lower bound.
Either bound may be positive, zero, or negative.
.x arrays> dimensions
.x arrays> bounds
.x <BASE
.x lower bound
.x upper bound
.x bounds> arrays
.tp 4.s.i8;Examples:
.s.i8;_>10 STRING COMPANY.NAMES(-5:5, 20), I, ZEBRA
.i8;_>20 REAL NUM$(M+N:2*(M+N)), J, K(-20:-5, X)
.s2;^&IMPLICIT DECLARATIONS\&
.x declaration> implicit
.s;If a simple variable referenced in a module does not appear in any
declaration statement within the module, it is assigned a
type according to its name (see Sec.#4.2)
and the scope of the variable will be the entire module
.x scope> of implicitly declared variable
(see Sec.#7.5).
.subtitle 1 January 1978                                                Sec. 5.4
.s2;^&5.4. ARRAY ELEMENTS\&
.s;Any element of an array variable may be accessed (read or written)
by following the variable name with a parenthesized list
of subscripts, one for each dimension.
.x arrays> elements
.x elements> arrays
.x arrays> subscripts
.x arrays> subscripts
.s.i8;Example:
.s.i8;10 LET A(5,N*M)=DRIP.FACTOR(M)+Y**2
.subtitle 1 January 1978                                                Sec. 5.5
.s2;^&5.5. SUBARRAYS\&
.x subarrays
.x arrays> subarrays (see ^Subarrays)
.x arrays> slices (see ^Subarrays)
.x arrays> parent of subarray
.s;Any rectangular-shaped subsection of an array variable (or another
subarray) can be defined as a subarray.
Once so defined, the subarray may be accessed (read or written) in
exactly the same manner as an array variable.
When values are changed in the subarray, the values of the
parent array are also changed because the subarray is
actually a part of the parent array.
.s;A subarray, when defined, can be given a name with the NAME
statement in which case the same subarray may be referenced more
than once, or it can be anonymous and exist only for the duration
of the operation in which it was defined.
.x <name
.x subarrays> named
.s;Besides being more efficient, naming a subarray also allows
elements of the subarray to be accessed (exactly as an array element)
.x subarrays> elements
.x elements> subarrays
.x subarrays> as parent arrays
and allows another subarray to be defined with the first subarray
as the parent.
.s2;^&SYNTAX, SUBARRAY DEFINITION\&
.s;A subarray is defined by following the parent array name
.x subarrays> syntax
.x declaration> subarrays> syntax
.x bounds> subarrays
.x subarrays> dimensions
.x subarrays> bounds
by a parenthesized list of subarray bounds, one for each dimension
of the parent array.
.s;A subarray bound may be 1) a single numeric expression, 2) two
numeric expressions separated by a colon, or 3) an asterisk.
.s;Examples:
.x *> in subarray definition
.x asterisks> in subarray definition
.s.i8;PAR.ARRAY(8,*)
.i8;YR.TOTALS(3:6, 3:6, 3:6)
.i8;B(*,*)
.s2;^&SEMANTICS\&
.s;If a single numeric value is given for a subscript, then the
subarray will refer to only that portion of the parent array that
.x subarrays> subscripts
has that subscript value.
.s;An asterisk specifies the entire range of a subscript, and a
bounds pair specifies a certain subset of the subscript range.
Specifying equal expressions in a bounds pair is legal, as in B(4:4).
.s;For example, if the parent array YR.TOTALS were declared as
.s.i8;10 REAL YR.TOTALS(10, 15, 20)
.s;then
.s.i8;YR.TOTALS(8, *, *)
.s;refers to a two-dimensional (15 by 20) subarray,
consisting of the 8th plane of the parent array YR.TOTALS.
Whereas this subarray slices one complete plane from a
three dimensional array, other segments can be taken, for example:
.s;Given
.i8;10 REAL A(8,8,8)
.br;then
.i8;A(3:6, 3:6, 3:6)
.s;is the cube-shaped 4 by 4 by 4 arrray at the center of A.
.s;Thus, the subarray may have the same number of dimensions as the
parent, or fewer, depending on how many single values are
given for subscripts.
Any number of subarrays may be taken from the same parent array.
.s;An error condition will be generated at the time of array or 
subarray element access if the element being accessed does not fall within the
bounds of the array or subarray.
.x subarrays> bounds
This can occur, for example, if the parent array is redimensioned
without compatible adjustment to its subarrays.
.s2;^&THE NAME STATEMENT\&
.x <NAME
.s;A subarray may be named by the NAME statement, and thereafter
the subarray name refers to that subarray.
.x subarrays> named
.x subarrays> elements
.x declaration> subarrays> <NAME statement
Naming a subarray is the only way that provides for accessing
individual elements of the subarray.
For example:
.s.i8;10 REAL YR.TOTALS(10, 15, 20)
.I8;20 NAME TOTALS.75=YR.TOTALS(8, 10:15, 15:20)
.I8;30 NAME TOTALS.76=YR.TOTALS(9, 10:15, 15:20)
.s;TOTALS.75 is a two-dimensional subarray consisting of a
rectangular section of the 8th plane of the parent array
YR.TOTALS.
The elements of TOTALS.75 refer to the elements of YR.TOTAL
as follows:
.nf;
.s.i8;TOTALS.75(10,15)      YR.TOTALS(8,10,15)
.I8;TOTALS.75(10,16)      YR.TOTALS(8,10,16)
.I8;_.
.I8;_.
.I8;_.
.I8;TOTALS.75(15,20)      YR.TOTALS(8,15,20)
.f;
.s;The subscript bounds of the subarray refer directly to those
given in the NAME statement, so that the element TOTALS.75(12,14)
is equivalent to the element YR.TOTALS(8,12,14).
.s;As with non-subarray declarations, the NAME statement may
occur more than once for a given subarray name, as long as the
dimensionality of the subarray is not changed.
.x subarrays> dimensions
Thus the same subarray name may describe different parts of 
different parent arrays at any given time in the execution of the
program.
.s;See also the NAME statement, Sec.#9.1.
.subtitle 1 January 1978                                                Sec. 5.6
.page
.s2;^&5.6. SYSTEM-DEFINED VARIABLES\&
.x <START.POINT
.x <EPS
.x variables> system-defined> <EPS
.x variables> system-defined> <START.POINT
.x <inv
.x =_#
.s2;^&SYSTEM-DEFINED SCALAR VARIABLES\&
.s.f;The system-defined variable named EPS affects the relational
operator _=_# and the INV function.
TYMBASIC initializes EPS to the REAL value 1E-10; its value may be
set to an expression as with any variable, but it may not be
re-declared.
It is global to every module throughout the entire program.
.x <EPS
.p;START.POINT is a system-defined integer variable, global to the entire program, set by TYMBASIC when a SAVE
BINARY program is run.
.x <SAVE <BINARY
.x programs> <GO files> running
Its value will be zero if the program is run normally; it will be
set to one if the program is run with a starting increment of
one.
See the DEC System10 Assembly Language Handbook, Monitor Calls.
Like EPS, START.POINT may be stored into but not re-declared.
.x scalars
.s2;^&SYSTEM-DEFINED ARRAY VARIABLES\&
.tp 15
.s;The system-defined array variables ASCTABLE and CHARTABLE enable
.x variables> system-defined> <ASCTABLE
.x variables> system-defined> <CHARTABLE
.x collating sequence
.x comparisons> string
.x <ASCII collating Sequence
.x <ASC
.x <CHAR
.x <ASCTABLE
.x <CHARTABLE
the user to change the system-standard (ASCII) collating sequence
for every module throughout the program.
Normally, characters are stored internally in ASCII code, and
string comparisons, as well as input and output, are based on ASCII.
The user may handle non-ASCII codes using the ASC and CHAR
functions, described in Section 7.8, which are based on
the current values in ASCTABLE and CHARTABLE.
.s;TYMBASIC declares ASCTABLE and CHARTABLE as follows:
.P.i8;INTEGER ASCTABLE (0:127)
.i8;STRING CHARTABLE (0:127):1
.s;The user may use ASCTABLE and CHARTABLE like any array variable.
ASCTABLE contains the information required to convert ASCII
character codes to corresponding character codes in the desired collating
sequence.
It is used in string comparisons.
CHARTABLE contains the characters (1-character strings)
corresponding to the character codes 0-127.
The CHAR function uses CHARTABLE to convert codes from
the current collating sequence back to their character
representations.
.s;For example, assume that for the purposes of ASC, CHAR, and
character comparisons, the character "A" is to have the value
6 instead of its usual ASCII value of 65.
This is accomplished as follows:
.s.i8;10 ASCTABLE(65)=6
.I8;20 CHARTABLE(6)="A"
.s;From then on, ASC("A") returns a value of 6 and CHAR(6) returns
"A".
Note that CHAR(ASC("A"))is still "A".
.s;TYMCOM-IX codes can be loaded into ASCTABLE and CHARTABLE
using the array valued system functions IXASC and IXCHAR as
.x <IXASC
.x <IXCHAR
.x <XASC
.x <XCHAR
follows:
.s.i8;ASCTABLE=IXASC
.i8;CHARTABLE=IXCHAR
.s;TYMCOM-X ASCII can be restored by:
.s;.i8;ASCTABLE=XASC
.i8;CHARTABLE=XCHAR
.s;TYMCOM-X ASCII is the initial condition.
See Appendix D for a table of IXASC, IXCHAR, XASC and XCHAR values.
.first title
.title TYMBASIC REFERENCE MANUAL          EXPRESSIONS
.;THE SLASH OPTIONS FOR THIS FILE ARE /RIG:6  /UND:SEP

.Flag capitalize
.Flag underline
.flag index
.page size 55
.f .LM 0 .rm 69 .nj .p0
.subtitle 1 January 1978                                                Sec. 6.1
.page;^&SECTION 6.  EXPRESSIONS\&
.s2;^&6.1. GENERAL\&
.s;Expressions specify operations to be performed upon scalar and array
values (array operations are discussed more fully in Sec.#6.10).
Expressions are evaluated during execution to either numeric, string, or logical
values, depending on the expression components.
.p;Barring error conditions, all parts of an expression are evaluated
during execution.
In particular, both operands of a boolean operator are always evaluated,
regardless of whether the result can be determined from one operand alone.
.s2;^&6.2. OPERATOR PRECEDENCE\&
.s;Parentheses may be used to indicate precedence of operation.
Parentheses may be nested to any level, and redundant parentheses
have no effect.
Within parentheses (or without them), operators follow the hierarchy of precedence
listed below.
Operators of equal precedence are listed on the same line.
.s2.lm+20.nf
.i-20;Highest precedence: ** (or _^ or _^)
.x **
.x _^
- (unary minus)
.x -> unary minus
MOD BAN BOR BEX
.x <MOD
.x <BAN
.x <BOR
.x <BEX
* / DIV
.x *> multiplication
.x /> division
.x <DIV
+ -
.x +
.x -> binary minus
= _> _>= _< _<= _# =_# _<_< _>_>
.x =
.x _>
.x _<
.x _#
NOT
.x <NOT
AND
.x <AND
OR  XOR
.x <OR
.x <XOR
IMP
.x <IMP
.i-20;Lowest precedence:  EQV
.x <EQV
.f.lm-20
.subtitle 1 January 1978                                                Sec. 6.3
.page;^&6.3. CONVERSION OF TYPES IN EXPRESSIONS\&
.x conversion> in expressions
.s2;^&CONVERSION\&
.s;The type of an operand will be converted, if necessary,
as follows:
.s.list
.le;To match the closest type accepted by the operator
.s;and then
.le;If two operands are of different types, the operand of lower type
is converted up to the type of the other (except for ** and
PWR, which are discussed below).
See the order of types table, below.
.els
.x <PWR
.x **
.x types> conversion> in expressions
.x types> order of
Logical values may be used freely in numeric expressions
and vice versa, with conversion taking place as necessary.
.p;Example:
.s.nf.lm+8
10 INTEGER I
20 REAL R
30 DOUBLE D
40 D = 2.71828
50 I = 17
60 R = D/I
.f.lm-8
.p;In line 60, the value of I is first converted to type real, because the / operator
does not accept an integer operand
(as shown in the table on the next page).
Then, it is converted to type double to match the type of the other operand, D.
The result of the division will be of type double,
as shown in the table (note also that this value will be converted to
real in order to store it into R).
.s;^&ORDER\&
.s;Type conversions in expressions are made according to the following
order of types:
.s2.lm+20.nf
.i-14;Highest type: complex
double
real
integer
.i-14;Lowest type:  logical
.f.lm-20
.s2;NOTE: Complex is converted down to real (not double).
.subtitle 1 January 1978                                                Sec. 6.4
.page;^&6.4. ARITHMETIC OPERATORS\&
.s;The following arithmetic operators accept numeric scalars or arrays.
Operations on arrays are element-by-element (see Sec.#6.10).
.s2.rm+6.lit
operator     operand    result           comments
-------------------------------------------------------------------------
  +        | integer | integer |       addition
           |  real   |  real   |
           | double  | double  |   see also Sec. 6.9 for +
           | complex | complex |   as string concatenator
-------------------------------------------------------------------------
  -        | integer | integer |       subtraction  or  unary minus
           |  real   |  real   |
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------------
  *        | integer | integer |       multiplication
           |  real   |  real   |
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------------
  /        |  real   |  real   |       division
           | double  | double  |  Note:  result is always floating point
           | complex | complex |
-------------------------------------------------------------------------
  DIV      | integer | integer |       "integer result" division
           |  real   |  real   |  a DIV b is equivalent to FIX(a/b)
           | double  | double  |
-------------------------------------------------------------------------
  MOD      | integer | integer |       modulo
           |  real   |  real   |
           | double  | double  |   complex operands are converted to real
-------------------------------------------------------------------------
 ** or ^   | integer | real    |       exponentiation
  or ^     |  real   |  real   |  (see effect of MAT prefix Sec. 9.1)
(see below)| double  | double  |
           | complex | complex |
-------------------------------------------------------------------------
.end lit
.rm-6
.ps 55,69
.x +
.x -> minus
.x *> multiplication
.x /> division
.x <DIV
.x **
.x _^
.x addition
.x subtraction
.x multiplication
.x division
.x division> integer result
.x exponentiation
.x power
.s;For exponentiation, the operands may be of different types. The type of the
result is the higher of the types of the operands, with one exception:  an
integer raised to an integer power will yield a real result because a negative power
may give a fractional result.
.s;Complex exponentiation is defined as:
.s.i8;EXP(P+LOG(ABS(B))+CMPLX(0,1)*PHASE(B)
.s;where B is the base and P is the power.
.subtitle 1 January 1978                                                Sec. 6.5
.page;^&6.5. MATRIX OPERATORS\&
.s2;The MUL and PWR operators are used with two-dimensional arrays. There are
special rules for handling one-dimensional arrays.
See also MAT prefix, Sec.#9.1.
.s2.rm+6.lit
operator     operand    result           comments
-------------------------------------------------------------------------
  MUL      | integer | integer |       matrix multiplication
           |  real   |  real   |
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------------
  PWR      | integer | integer |       matrix exponentiation
           |  real   |  real   |  A PWR 3 is equivalent to A MUL A MUL A
           | double  | double  |  power must be an integer scalar
           | complex | complex |
-------------------------------------------------------------------------
.end lit
.rm-6
.ps 55,69
.x <MUL
.x <PWR
.x matrix operations
.x arrays> operators
.x multiplication> matrix
.x exponentiation> matrix
.x power
.p;MUL operates on two-dimensional arrays. However one-dimensional
arrays in a MUL expression are internally treated as a row or column
vector of the same length. A row vector is a two-dimensional array with a
length of one in the first dimension, a column vector is a two-dimensional
array with a length of one in the second dimension. A one-dimensional array
to the left of a MUL is treated as a row vector, to the right as a column
vector.
.p;MUL requires the lengths of the inner dimensions be equal (else a run
time error). The size of the result is determined by the outer dimensions.
.p;MUL of two one-dimensional arrays gives a scalar result, not an array.
However MUL of explicitly defined (two-dimensional) row and column vectors
yields a two-dimensional array result containing one element.
.subtitle 1 January 1978                                                Sec. 6.6
.page;^&6.6. BIT-WISE OPERATORS\&
.s2;The following operators accept integer scalars only.
.s2.rm+6.lit
operator     operand    result           comments
-------------------------------------------------------------------------
  BAN      | integer | integer |       bit by bit and
-------------------------------------------------------------------------
  BOR      | integer | integer |       bit by bit or
-------------------------------------------------------------------------
  BEX      | integer | integer |       bit by bit exclusive or
-------------------------------------------------------------------------
.end lit
.rm-6
.ps 55,69
.subtitle 1 January 1978                                                Sec. 6.7
.page;^&6.7. RELATIONAL OPERATORS\&
.s2;The following relational operators are used to compare numeric scalars. They
give a logical result. Except where noted complex operands are not allowed.
Note that the logical result may be used freely in a numeric or logical
expression.
.s2.rm+6.lit
operator            result
-------------------------------------------------------------------------
     =          |   equal to     May be used with complex operands.
                | Not to be confused with the = assignment. "LET A= B=C"
                | assigns the logical value of B=C to A.
-------------------------------------------------------------------------
     <          |   less than
-------------------------------------------------------------------------
  <= or =<      |   less than or equal to
-------------------------------------------------------------------------
     >          |   greater than
-------------------------------------------------------------------------
  >= or =>      |   greater than or equal to
-------------------------------------------------------------------------
  # or <> or >< |   not equal to    May be used with complex operands.
-------------------------------------------------------------------------
     <<         |   very much less than
                |  A<<B is true if internally A+B=B
-------------------------------------------------------------------------
     >>         |   very much greater than
                |  A>>B is true if internally A+B=A
-------------------------------------------------------------------------
  =# or #=      |   approximately equal to
                |   May be used with complex operands.
                | This operator is defined in terms of the system-defined
                | variable EPS. A=#B is true if ABS(A/B-1) < EPS
-------------------------------------------------------------------------
.end lit
.rm-6
.ps 55,69
.x =
.x _<
.x _>
.x _#
.x _>_>
.x _<_<
.x _#=
.x <EPS
.x =_<
.x =_>
.x _>=
.x _<=
.subtitle 1 January 1978                                                Sec. 6.8
.page;^&6.8. BOOLEAN OPERATORS\&
.s2;The following boolean operators accept only logical scalar operands.
The type of the result of the boolean operators is logical.
Both operands of a boolean operator are always evaluated, regardless of
whether the result can be determined from one operand alone.
.s2.rm+6.lit
operator   T op T  T op F  F op T  F op F      comments
-------------------------------------------------------------------------
  AND    |   T       F       F       F    |    logical and
-------------------------------------------------------------------------
  OR     |   T       T       T       F    |    logical inclusive or
-------------------------------------------------------------------------
  XOR    |   F       T       T       F    |    logical exclusive or
-------------------------------------------------------------------------
  IMP    |   T       F       T       T    |    logical implication
-------------------------------------------------------------------------
  EQV    |   T       F       F       T    |    logical equivalence
-------------------------------------------------------------------------
  NOT    |    NOT T = F      NOT F = T    |    logical negation
-------------------------------------------------------------------------
.end lit
.rm-6
.ps 55,69
.x <AND
.x <OR
.x <XOR
.x <IMP
.x <EQV
.x <NOT
.x inclusive or
.x exclusive or
.subtitle 1 January 1978                                                Sec. 6.9
.page;^&6.9. STRING OPERATORS\&
.x strings> expressions
.f;.s;Strings cannot be manipulated like numbers, but they may be
concatenated, using the + operator, and compared, using
a subset of
the relational operators:
.s2.lit
Operator           Meaning                  Use
-------------------------------------------------------------
  +             |  concatenation of two  |  Operands may
                |  strings               |  be arrays.
-------------------------------------------------------------
  <             |  less than             |
------------------------------------------  Operands may not
  <= or =>      |  less than or equal    |  be arrays.
------------------------------------------
  =             |  equal                 |  All relational
------------------------------------------  comparisons use
  >= or =>      |  greater than or equal |  the collating
------------------------------------------  sequence defined
  >             |  greater than          |  in ASCTABLE
------------------------------------------
  # or >< or <> |  not equal             |
-------------------------------------------------------------
.end lit
.x <ASCTABLE
.x strings> comparisons
.x +> string concatenator
.x _>
.x _<
.x _#
.x =
.x _>=
.x _<=
.x =_<
.x =_>
.subtitle 1 January 1978                                                Sec. 6.10
.page;^&6.10. ARRAY EXPRESSIONS\&
.page size +3
.x arrays
.x arrays> manipulation
.x arrays> expressions
.f;.s;Array operations are element-by-element, except for the
operators MUL and PWR, which denote matrix multiplication
and exponentation, or when the line is prefaced by MAT.
That is, binary operators operate on corresponding elements of the two
array operands, and unary operators operate singly on the elements of the
array operand.
.p;Arithmetic operations in which one operand is a scalar expression
and the other is an array (or subarray) expression
are valid for any operation that is valid when both operands
are scalar expressions, except that an array cannot be stored into a scalar.
For example:
.s2.lm+8.lit
>10 INTEGER A(1:10,5:75), J
>20 A = 5*J
>30 PRINT A*2 +J
.end lit
.lm-8
.p;In line 20, the scalar expression 5*J is stored into every element
of the array A.
In line 30, every element of the array A is multiplied by 2, and
then the value of J is added to every element of A.
.p;Element-by element operations in which both operands are array expressions are valid
when the array expressions are conformable: they have the same number
of dimensions and the lengths of corresponding dimensions are equal.
.s;The value of an arithmetic operation on array expresions is an array expression
that is conformable with the operands, and whose subscript
lower bounds are equal to the current value for BASE.
The type of such resulting array expressions follows the same rules as
for scalar operations.
.p;Element-by-element operations are limited to the arithmetic
operators, and are not defined on type logical.
.p;^&ARRAY INTERSECTION\&
.p;Different subsections of the same array may be defined as subarrays
(see Sec.#5.5).
The intersection of two such subarrays is also a subarray, and
can be referenced by the use of the @ operator.
.x @
.x arrays> intersection
.x arrays> @
.x subarrays> @
For example:
.s2.lm+8.lit
>10 INTEGER A(20,20,20), X(20,10,10)
>20 NAME B = A(*,6:15,*)
>30 NAME C = A(*,*,6:15)
>40 X = B @ C
.end lit
.lm-8
.s;B@C in this case is equivalent to A(*,6:15,6:15).
An error condition is generated if the result of the intersection is
void or if the two operands do not share a common parent array.
The dimensionality of the result is no greater than the lesser of the number of
dimensions of the two operands.
.page size -3
.;THE SLASH OPTIONS FOR THIS FILE ARE /RIG:6

.Flag capitalize
.Flag underline
.flag index
.page size 55
.f .LM 0 .rm 69 .nj .p0
.first title
.title TYMBASIC REFERENCE MANUAL              PROCEDURES
.subtitle 1 January 1978                                                Sec. 7.1
.page.c;SECTION 7. PROCEDURES
.x procedures
.s2;See the GOSUB statement for a description of GOSUB subroutines.
.x <GOSUB
.x subroutines
.s;Procedures, named by identifiers, may be defined by the user
or supplied by TYMBASIC.
The TYMBASIC system-defined procedures are listed in Sec.#7.8.
System-defined procedures (also known as functions) all return a value.
User-defined procedures, defined by the DEF statement, return
a value also, but it may be a null value, equivalent to the initial value given
to simple variables (see Sec.#5.2).
.x <DEF
Procedures may be called as functions by using the procedure name
in an expression, or by an explicit CALL statement (in which case
any value returned by the procedure is ignored).
.x <CALL
.s;Procedures are not recursive.
.x recursive
That is, they may not directly or indirectly call themselves.
.subtitle 1 January 1978                                                Sec. 7.1
.s2;^&7.1. CLASS _& TYPE\&
.s;The value of a procedure can be of either class, scalar or array,
and both scalar- and array-valued procedures may be of any type
(integer, real, double, complex, string, or logical).
.s;The type and class of a user-defined procedure is specified in
the procedure declaration, which is a DEF statement.
.x <DEF
The type and class of system-defined procedures is predefined.
.x procedures> declaration
.x <DEF> see ^procedures
.s2;.c;USER-DEFINED PROCEDURES
.subtitle 1 January 1978                                                Sec. 7.2
.s2;^&7.2. EXTERNAL AND ENTRY (GLOBAL) PROCEDURES\&
.x global procedures (See ^procedures)
.x external procedures (See ^procedures)
.x procedures> global
.x procedures> external
.x procedures> entry
.x modules> procedure calls across
.s;A procedure contained in one module may be called from another module.
Such a procedure is called a global procedure.
In this case, the calling module must contain a DEF statement for that
procedure with the EXTERNAL attribute.
.x <EXTERNAL
The DEF EXTERNAL informs TYMBASIC of the name, type, class and
dimensionality of the external procedure and lists the parameters
it expects.
DEF EXTERNAL statements are non-executable.
.s;The called module contains the procedure body.
If written in TYMBASIC, the module must contain a DEF statement for 
that procedure with the ENTRY attribute, so that its name will
be known outside of its own module (i.e., global).
.x <ENTRY
A global procedure may also be called from within the same
module that contains the procedure.
Example:
.nf;
.page;-TYPE INVHYP.TBA
.s;10 ! ** INVERSE HYPERBOLIC FUNCTIONS **
20 ! INVERSE HYP. SINE
30 DEF ENTRY INV.SINH(X)=LOG(X+SQR(X_^2+1))
40 ! INVERSE HYP. COSINE
50 DEF ENTRY INV.COSH(X)
60   IF X_>1 THEN EXIT LOG(X+SQR(X_^2-1))
70   STOP  "ERROR--INV.COSH ARGUMENT MUST BE _>=1"
80 ENDF INV.COSH
120 ! INVERSE HYP. TANGENT
130 DEF ENTRY INV.TANH(X)
140   IF X_^2_<1 THEN EXIT LOG((1+X)/(1-X))/2
150   STOP  "ERROR--INV.TANH ARGUMENT MUST BE BETWEEN -1 AND 1"
160 ENDF INV.TANH
.s;_-TBA
Ver.#4.0
_>GET EXAMPL
_>LIST
.s;10 DEF EXTERNAL INV.SINH(X)
20 DEF EXTERNAL INV.COSH(X)
30 DEF EXTERNAL INV.TANH(X)
40 PRINT "THIS PROGRAM USES THE MODULE INVHYP.TBA."
50 PRINT INV.SINH(13)
60 PRINT INV.COSH(9)
70 PRINT INV.TANH( TANH(5.6) )
80 ! TANH IS A SYSTEM-DEFINED FUNCTION
90 END
.s;_>MODULES INVHYP, EXAMPL
_>LIST MODULES
INVHYP      NO DEBUG
EXAMPL.TBA     NO DEBUG     ** WORKSPACE **
.s;_>RUN
THIS PROGRAM USES THE MODULE INVHYP.TBA.
 3.259573
 2.887271
 5.599944
.s;END in line 90
_>
.f
.page;A module may legally contain DEF EXTERNAL statements for 
procedures which are in fact never called.
A Loader request for the procedure is made only if the procedure is
called.
Therefore, external procedures that are declared but never called
will not cause a module to be loaded from a library.
.x libraries
.s2;^&OTHER-LANGUAGE EXTERNAL PROCEDURES\&
.x other-language procedures (See ^Procedures)
.x procedures> other-language
.x procedures> global> other-language
.s;A procedure written in a language other than TYMBASIC may be called
from a TYMBASIC module.
There is no facility, however, for calling TYMBASIC procedures
from other-language modules.
.x modules> other-language
.s;Calls are supported to procedures written in:
.s;.lm+8;.nf;TYMBASIC
F10, SUPERFORTRAN, FORTRAN4
COBOL
SIMPL
BLISS
.lm-8;
.f;
.x <F40
.x <TYMBASIC
.x <F10
.x <SUPERFORTRAN
.x <FORTRAN4
.x <COBOL
.x <SIMPL
.x <BLISS
.s;The assembly language form of the calling sequences for each language are given
in Appendix E.
.s;Procedures written in FORTRAN or COBOL may not do any I/O.
A complete discussion of restrictions for other-language procedures
is also given in Appendix E.
.x <I/O> in other-language procedures
.x procedures> other-language> <I/O within
.x procedures> <COBOL
.s2;^&THE AKA CLAUSE IN THE DEF STATEMENT\&
.x <AKA
.x procedures> declaration> <AKA clause
.x procedures> global> names
.s;The loader can only recognise global procedure names up to six
characters.
The AKA clause allows the user to define an alternate name 
for a global procedure
by which the loader will identify the procedure.
.x procedures> alternate name
Within the module containing the DEF the 
procedure will be known by its original name.
Note that the AKA names, if any, given in the
DEF EXTERNAL and in the DEF ENTRY must match for the loader to 
properly link the procedure call to the procedure.
.s;If no AKA name is given, then the loader will identify the
procedure by the first six characters of the original procedure name.
.s;The characters that make up the AKA name must belong to the SIXBIT
set (this is the printable ASCII character set less lowercase
alphas, and less _`, _{, _|, _}, _~).
.x <SIXBIT
Lowercase alphas given in the AKA name are converted to uppercase.
Example:
.s.nf.lm+8
10 DEF EXTERNAL MY.PROCEDURE AKA "HER.PR"
.f.lm-8
.page
.subtitle 1 January 1978                                                Sec. 7.3
.s2;^&7.3. DECLARATIONS FOR PROCEDURES AND PARAMETERS\&
.x procedures> declaration
.x parameters> declaration
.x declaration> procedures
.s;The type, class, and other attributes of a procedure, and
the type and class of all of its parameters are given in the 
DEF statement.
.x <DEF
.x declaration> parameters
There may be as many as 511 user-defined procedures in a module.
.x procedures> number of
.s2;^&Syntax:\&
.x procedures> declaration> syntax
.x <DEF
.x <AKA
.x declaration> procedures
.x declaration> global procedures
.s2.c;^&EXTERNAL procedure\&
.s;(A global procedure whose body is contained in another module)
.s;DEF [type] EXTERNAL [language] id [(dims)][(params)][AKA "name"]
.s;Examples:
.s.nf.lm+4
10 DEF EXTERNAL FUNC1(INTEGER I)
20 DEF INTEGER EXTERNAL FUNC2(*,*)(INTEGER I)
30 DEF COMPLEX EXTERNAL SFO FUNC3(REAL I, DOUBLE D) AKA "$POLAR"
.f.lm-4
.s2.c;^&Single-line procedure (global/local)\&
.x procedures> single-line> declaration
.s;(The procedure value is given as an expression on the same
line as the DEF, and the procedure is global/local)
.s;DEF [type] [ENTRY] id [(dims)][(params)][AKA "name"] = expression
.s;Examples:
.s.nf.lm+4
10 DEF FUNC1 = 43
20 DEF INTEGER ENTRY FUNC2(INTEGER I) AKA "ITSIT" = 7*I
30 DEF DOUBLE FUNC3(*)(DOUBLE D(*)) = D/DPI
.f.lm-4
.s2.c;^&Multi-line procedure (global/local)\&
.s;(The procedure body consists of a group of statements; the
procedure value is given in an EXIT statement; the procedure
is global/local)
.s;.nf;DEF [type] [ENTRY] id [(dims)][(params)][AKA "name"]
_.
_. statements
_.
ENDF id
.x <ENDF
.s.tp9;Example:
.s.nf.lm+4
10 DEF INTEGER FUNC1(INTEGER I)
20   CALL NEXT.LINE(I)
30   EXIT VAL(F$)
40 ENDF FUNC1
.f.lm-4
.s;In all of the above forms, the AKA clause may appear only if
EXTERNAL or ENTRY is specified.
.x <AKA
.x <EXTERNAL
.x <ENTRY
.s2;^&Semantics\&
.x procedures> declaration> semantics
.s;.f;"type" may be any of the type keywords: INTEGER, REAL, 
DOUBLE, COMPLEX, STRING or LOGICAL, and specifies the type of
the value of the procedure.
.s;As for variables, if an explicit type declaration is omitted,
the procedure name determines the type (see Sec.#4.2).
.s;"language" specifies the calling conventions for EXTERNAL
procedures and may be one of: TBA, SFO, F40, SIMPL or BLISS.
.x <TBA
.x <SFO
.x <F40
.x <SIMPL
.x <BLISS
If not specified the calling convention is TBA.
.x <EXTERNAL
.x procedures> other-language
.s;"id" is an identifier that is the procedure name.
.x procedures> name
.s;"(dims)" is a parenthesized series of asterisks, separated by
commas, and specifies the number of dimensions for an
array-valued procedure.
For example,
.x procedures> array-valued
.x declaration> procedures
.s;.i8;DEF FUNC3(*,*,*)(I,J)
.s;declares an array-valued procedure of three dimensions (and
two parameters).
This field is omitted for scalar-valued procedures.
.s;"(params)" is a list of parameters with optional type
keywords, separated by commas.
A type keyword may be followed by a parenthesized list of
parameters, in which case that type applies to all those
parameters.
For example,
.x parameters> declaration
.s;.i8;DEF FUNC (REAL I, STRING F)
.s;declares a procedure with two parameters, one of type
REAL, one of type STRING.
.s;.i8;DEF FUNC(INTEGER(I,J,K), COMPLEX F)
.s; declares a procedure with four parameters, the first
three of type INTEGER, the fourth of type COMPLEX.
.s;If an explicit type declaration is omitted, the
parameter name determines the type (see Sec.#4.2).
.s;Array parameters may be specified by following the parameter
name with a parenthesized series of asterisks separated by
commas, one for each dimension of the parameter array.
For example:
.x parameters> arrays
.s;.i8;DEF FUNC (DOUBLE (A(*,*),B))
.s;declares a procedure with two parameters, both of type
double, the first of which is a two-dimensional array.
.s;As many as 31 parameters may be specified in the DEF.
.x <DEF
.x parameters> number of
.s;The AKA clause is discussed in Section 7.2.
.x <AKA
.s2;^&Parameters for EXTERNAL procedures\&
.x parameters> for <EXTERNAL procedures
.s;For EXTERNAL procedures, the DEF is non-executable and
simply defines the attributes of the procedure.
.x <DEF
Therefore, parameters mentioned in the DEF are dummy parameters
that specify the type and dimensions of the arguments to be passed to
the procedure, and no space is allocated for them.
.s;^&FOR Loops and Extended IF statements in Procedure Definitions\&
.s;These two constructs must begin and end in the same context.
That is, a FOR loop or extended IF statement may not cross a procedure
definition.
A procedure may, however, be wholly contained within one of these constructs.
For example:
.s.nf.lm+4
      Legal:                        Not legal:
.s
10 IF A=5 THEN                  10 IF A=5 THEN
20   DEF F6(I)                  20   DEF F6(I)
30     CALL NEW.VALUE(I)        30     CALL NEW.VALUE(I)
40     EXIT F7(I)*4             40   Q = F6(A)
50   ENDF F6                    50 ENDIF
60   Q = F6(A)                  60     EXIT F7(I)*4
70 ENDIF                        70   ENDF F6
.f.lm-4
.tp 6
.subtitle 1 January 1978                                                Sec. 7.4
.s2;^&7.4. PASSING ARGUMENTS TO PROCEDURES\&
.x arguments (see ^Procedures)
.x procedures> passing arguments
.x procedures> arguments
.x procedures> call by reference
.s;A procedure may be called by a CALL statement or by reference
within an expression.
.x <CALL
Arguments to the procedure can be expressions, and are listed within parentheses after
the procedure name and separated by commas.
The arguments given in the call, 
if any, are transferred to corresponding parameters as defined
in the DEF for the procedure being called.
.x <DEF
Control then transfers to the procedure body.
.x parameters
.x declaration> procedures
.x procedures> arguments> number of
.x declaration> parameters
.s2;^&NUMBER OF ARGUMENTS\&
.s;The number of arguments given must be the same as the number
of parameters specified in the DEF, with one exception:
more arguments than specified may be passed to EXTERNAL procedures
declared SFO or F40.
.x parameters
.x <EXTERNAL
.x <SFO
.x F40
.x procedures> arguments> Fortran
.x parameters> to Fortran procedures
.s2;^&PASSING ARGUMENTS BY NAME AND VALUE\&
.s;There are two ways in which arguments are passed to procedures
in TYMBASIC: by name and by value.
.x procedures> arguments> call by name
.x procedures> arguments> call by value
.s;In passing an argument by value, the value of the argument is 
stored into the parameter.
If the value of the parameter changes during execution of the
procedure, the original argument is not affected.
.s;In passing an argument by name, the address or name of 
the argument is given to the procedure, so that when the procedure stores into
the parameter it is actually storing into the argument.
If the argument is a constant, storing into it may generate
a fatal error.
.x procedures> arguments> constants
.s;If the procedure being called is TBA, then all arguments are
passed by value except for array arguments.
.x <TBA
This is done because passing an array argument by value would
involve copying all the array elements, and would increase
execution time and storage allocation.
.x procedures> arguments> arrays
.s;Array expressions may be passed to a TYMBASIC procedure,
and the array may be read and written during execution of the
procedure, but when the procedure exits the array is discarded.
.x procedures> arguments> array expressions
.s;String expressions passed to a TYMBASIC procedure are also
discarded when the procedure exits.
.x procedures> arguments> string expressions
.s;If the procedure being called is SFO or F40, then all arguments
are passed by name.
.x <SFO
.x F40
.x procedures> arguments> to Fortran procedures
.s;If the procedure being called is SIMPL or BLISS, then numeric
(and logical) scalar arguments are passed by value and array 
arguments and string scalar arguments are passed by name.
.x <SIMPL
.x <BLISS
.s;See Appendix E for a complete description of other-language 
calling conventions.
.tp 5
.s2;^&TYPE CONVERSION OF ARGUMENTS\&
.x procedures> arguments> type conversion
.x conversion> in procedure calls
.s;An argument must agree in class (scalar/array), and in number
of dimensions, with its corresponding parameter.
.x procedures> arguments> arrays
.x arrays> arguments (See ^Procedures)
.s;If a scalar argument is of a different type than that
specified by its corresponding parameter, it is converted to
the type of the parameter, if possible.
Array arguments will not be converted (an error will be
generated in the case of type mismatches).
.s;If a converted argument is passed by name then it is
considered to be an expression.
Therefore, storing into a parameter whose corresponding
argument was a converted variable will not change the value of
the variable.
.x procedures> arguments> call by name
.s;^&ARRAY PARAMETERS\&
.x arrays> parameters (See ^Parameters)
.x parameters> arrays
.x arrays> bounds
.s;For array parameters, only the dimensionality is specified in
the DEF.
.x <DEF
.x procedures> arguments> arrays
The bounds for each dimension are determined from the argument
array at the time of procedure call.
Thus, re-declaring the array parameter within the procedure body
is not part of the calling protocol:
it in fact will re-declare and clear the array as an array declaration
will anywhere in a module.
.x declaration> parameters> arrays
.x arrays> declaration
.subtitle 1 January 1978                                                Sec. 7.5
.s2;^&7.5. CONTEXT, SCOPE, LOCAL VARIABLES _& PROCEDURES\&
.x context
.x scope
.x name scope
.x local variables
.x local procedures
.s;Parameters, variables and procedures declared within a
procedure are local.
That is, references to their names within the procedure will
apply to the locally-defined names regardless of whether
these names have been defined in the main program or in an
outer procedure.
.x parameters
.x declaration> context
.x procedures> context
.x procedures> nested
.x variables> local
.x procedures> local
.tp8;Example:
.s.nf.lm+8;10 INTEGER I,J,K
20 DEF F(I)
30   LOGICAL J
40   K=I*J
50 ENDF F
.lm-8;.f
.s;In line 40, K refers to the integer K defined on line 10.
I refers to the (implicitly typed) real I defined as a 
parameter on line 20.
J refers to the logical J defined by declaration on line 30.
.s.tp3;The scope of a parameter, procedure, or variable consists of the 
contexts in which it is known.
Thus, the real parameter I defined on line 20 and the logical
J defined on line 30 have the same scope: lines 20 through 50, 
whereas the scope of K, defined on line 10, is lines
10 through 50.
Reference to a variable named "J" may refer to two different
variables, depending on the context in which the reference occurs.
.s;Thus, to say that a parameter, procedure, or variable is local
to a procedure is to say that its scope is limited to 
within the procedure.
.s2.tp4;^&NESTED PROCEDURES\&
.x procedures> nesting
.x nesting> procedures
.s;A procedure may be contained within the body of another procedure,
and if so is said to be nested within an outer procedure.
The inner procedure name is local to the outer procedure; that
is, its scope is limited to within the outer procedure.
Procedures may be nested up to ten levels.
.s2;^&PRESERVATION OF VALUES ACROSS CALLS\&
.x variables> local
.s;The values held by local variables are static across calls to
a procedure.
In other words, a local variable will have the same value
at the beginning of the execution of a procedure as it had at
the end of the previous execution of the procedure.
Values are of course given to parameters at the time of the
procedure call.
However, should a branch into a procedure or a call to a nested procedure take place after the outer procedure has
exited, only numeric and logical scalar parameters will have retained their values
(if the procedure has never been called then they will have initial
values).
.x procedures> branches into
.x procedures> calls to nested procedures
Array parameters may not be referenced at all when a
procedure body is branched into; string scalar parameters
may be read or written only after the procedure has been
called at least once.
.x parameters> arrays
.x parameters> string scalars
.subtitle 1 January 1978                                                Sec. 7.6
.s2.tp6;^&7.6 PROCEDURE VALUE: EXITING FROM A PROCEDURE\&
.x procedures> value
.x procedures> exiting
.s;The procedure value is determined at the time of exit.
Exit from a procedure occurs when an EXIT statement
is executed or when the ENDF is reached (for single-line procedures
exit occurs after evaluation of the procedure expression).
.x procedures> returning
.x procedures> single-line
.s;A procedure may contain any number of EXIT statements.
.x <EXIT> number of
.s;If the EXIT statement supplies a value, then that value
(converted to the declared type of the procedure if necessary)
will be the value of the procedure.
If a value is omitted or if exit is by reaching the ENDF, a null
(initial) value is provided according to the type of the procedure
(see Sec.#4.2).
.subtitle 1 January 1978                                                Sec. 7.7
.s2.tp10;^&7.7 I/O WITHIN A PROCEDURE\&
.x procedures> <I/O
.s;Input or output may be done from within a procedure even
though an input or output operation is in progress.
For example,
.s.i+8;10 PRINT ON 1 AT N: X+Y, FUNC(Z), FUNC(A)
.s;and, in FUNC:
.s.i+8;420 PRINT ON 1: E, F, G
.x nesting> <I/O
.;THE SLASH OPTIONS FOR THIS FILE ARE /RIG:6
.Flag capitalize
.Flag underline
.flag index
.page size 55
.f .LM 0 .rm 69 .nj .p0
.first title
.title TYMBASIC REFERENCE MANUAL        SYSTEM-DEFINED PROCEDURES
.subtitle 1 January 1978                                                Sec. 7.8
.page size +2
.page;^&7.8. TABLES OF SYSTEM-DEFINED PROCEDURES\&
.x system-defined procedures (See ^Procedures, system-defined)
.x functions (See ^procedures)
.x reserved functions (See ^Procedures, system-defined)
.x procedures> system-defined
.p;This section presents all of the system-defined procedures, organized
into tables according to their function.
.p;All TYMBASIC system-defined procedures are functions; that is, they all
return a value.
.p;All arguments are scalars except where noted.
.p;The data types of input arguments for each function are given with
the description; if a different data type is supplied, conversion
.x conversion
to one of the accepted types is automatically performed (see Sec.#3.2).
Thus, even though complex is not listed as an accepted type for
the ROUN function, if a complex argument is given to ROUN the argument
will be converted to real (according to the standard conversion rules).
.s2.c;^&TRIGONOMETRIC FUNCTIONS\&
.x trigonometric functions
.s;Trigonometric functions use radians.
.s.nf
Function     Argument   Result           Description
-------------------------------------------------------------------
SIN(X)     |  real   |  real   |      sine of X
.x <SIN
.x sine
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------
COS(X)     |  real   |  real   |      cosine of X
.x <COS
.x cosine
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------
TAN(X)     |  real   |  real   |      tangent of X
.x <TAN
.x tangent
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------
ASIN(X)    |  real   |  real   |      arcsine of X
.x <ASIN
.x arcsine
-------------------------------------------------------------------
ACOS(X)    |  real   |  real   |      arccosine of X
.x <ACOS
.x arccosine
-------------------------------------------------------------------
ATAN(X) or | double  | double  |      arctangent of X
.x <ATAN
.x <ATN
ATN(X)     |         |         |
-------------------------------------------------------------------
ATAN(X,Y)  | double  | double  |      arctangent of X/Y
or ATN(X,Y)|         |         |
.x <ATAN
.x <ATN
.x arctangent
-------------------------------------------------------------------
SINH(X)    |  real   |  real   |      hyperbolic sine of X
.x <SINH
.x hyperbolic sine
-------------------------------------------------------------------
COSH(X)    |  real   |  real   |      hyperbolic cosine of X
.x <COSH
.x hyperbolic cosine
-------------------------------------------------------------------
TANH(X)    |  real   |  real   |      hyperbolic tangent of X
.x <TANH
.x hyperbolic tangent
-------------------------------------------------------------------
.f
.page size -2
.page.c;^&EXPONENTIAL FUNCTIONS\&
.x exponential functions
.s2
.nf
Function     Argument   Result           Description
-------------------------------------------------------------------
SQRT(X) or | double  | double  |       square root of X
.x <SQRT
.x <SQR
.x square root
SQR(X)     | complex | complex |
-------------------------------------------------------------------
LOG(X)     |  real   |  real   |       natural log of X
.x <LOG
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------
LGT(X) or  |  real   |  real   |       log of X base 10
.x <LGT
.x <LOG10
LOG10(X)   | double  | double  |
-------------------------------------------------------------------
.x <EXP
.x ^E> exponential
EXP(X)     |  real   |  real   |       e to the X power
           | double  | double  |
           | complex | complex |
-------------------------------------------------------------------
.x logarithm> natural
.x logarithm> base 10
.f.s
The exponential operator, _^ or _^ or **, is discussed in Section 6.4.
.s3.c;^&COMPLEX FUNCTIONS\&
.x complex> functions
.s2.nf
Function     Argument   Result           Description
-------------------------------------------------------------------
CMPLX(X,Y) |  real   | complex |    complex value X+iY
.x <CMPLX
.x complex> value
-------------------------------------------------------------------
REAL(C)    | complex |  real   |    real part of C
.x <REAL
.x real part
-------------------------------------------------------------------
IMAG(C)    | complex |  real   |    imaginary part of C
.x <IMAG
.x imaginary part
-------------------------------------------------------------------
ABS(C)     | complex |  real   |    magnitude of C
.x <ABS
.x complex> magnitude
-------------------------------------------------------------------
PHASE(C)   | complex |  real   |    phase, in radians, of C
.x <PHASE
-------------------------------------------------------------------
POLAR(X,Y) | double  | complex |    complex value with 
.x <POLAR
           |         |         |    magnitude X and phase
           |         |         |    Y, in radians
-------------------------------------------------------------------
CONJ(C)    | complex | complex |    conjugate of C
.x <CONJ
.x conjugate
.x magnitude> complex
-------------------------------------------------------------------
.f
.s;Note that the following are equivalent:
.nf.s.lm+8
C
CMPLX(REAL(C),IMAG(C))
POLAR(ABS(C),PHASE(C))
.f.lm-8
.page size +2
.page.c;^&NUMERIC FUNCTIONS\&
.s;In this table, "any type" means any non-string type.
.s
.nf
Function     Argument   Result           Description
-------------------------------------------------------------------
ABS(X)     | integer | integer |    absolute value
.x <ABS
.x absolute value
.x magnitude> complex
           |  real   |  real   |
           | double  | double  |   ABS of complex returns
           | complex |  real   |   magnitude as real
-------------------------------------------------------------------
DBL(X)     | any type| double  |    double precision value of X
.x <DBL
.x double precision value
           |         |         | DBL of complex uses real part only
-------------------------------------------------------------------
REAL(X)    | any type|  real   |    converts X to real
.x <REAL
           |         |         | REAL of complex returns real part
-------------------------------------------------------------------
INT(X)     | any type| integer |    greatest integer less 
.x <int
           |         |         |    than or equal to X
           |         |         | INT of complex uses real part only
-------------------------------------------------------------------
IP(X)      | integer | integer |    Integer part of X:
.x <IP
.x integer part
           |  real   |  real   |    greatest integer less
           | double  | double  |    than or equal to X
-------------------------------------------------------------------
FP(X)      | integer | integer |    Fractional part of X:
.x <fp
.x fractional part
           |  real   |  real   |    X - IP(X)
           | double  | double  |
-------------------------------------------------------------------
FIX(X)     | integer | integer |    X truncated
.x <fix
.x truncation
           |  real   |  real   |
           | double  | double  |
-------------------------------------------------------------------
ROUN(X)    | integer | integer |    X rounded to nearest integer
.x <roun
.x rounding
           |  real   |  real   |
           | double  | double  | If exactly between two
           |         |         | integers it will round in
           |         |         | the positive direction
-------------------------------------------------------------------
SGN(X)     | any type| integer |  -1 if X_<0 , 0 if X=0 , +1 if X_>0
.x <sgn
.x sign
           |         |         | SGN of complex uses real part only
-------------------------------------------------------------------
COMP(X,Y) *| integer | integer |  -1 if X_<Y , 0 if X=Y , +1 if X_>Y
.x <comp
.x comparisons> numeric
           |  real   | integer |
           | double  | integer |
-------------------------------------------------------------------
PDIF(X,Y) *| integer | integer |   Positive difference:
.x <pdif
.x positive difference
           |  real   |  real   |  X-Y if X-Y_>0, else 0
           | double  | double  |
-------------------------------------------------------------------
 * If arguments are of different types, the argument with lower type
 is converted to the type of the other argument.
.x conversion> in function calls
.f
.page size -2
.page.c;^&MAX AND MIN FUNCTIONS\&
.x maximum
.x minimum
.x largest
.x smallest
.s3
These functions return the value of the largest or smallest 
argument. MAX and MIN may be used two ways. Either with an
argument list:
.x <MAX
.x <MIN
.s2
.i+8;MAX(X1,X2,X3,...Xn)    or    MIN(X1,X2,X3,...Xn)
.s
Or with a FOR loop, some examples:
.x <FOR> in <MAX, <MIN, <SUM, <PROD
.s
.i+8;MAX( ARRAY(X) FOR X=I TO J )
.i+8;MIN( SQR(X) FOR X= ARRAY(I) TO ARRAY (J) )
.s
The type of the result is the same as the argument with the 
highest type.
Complex arguments are illegal, but string arguments are allowed.
.s
.s
.c;^&SUM AND PROD FUNCTIONS\&
.x <SUM
.x <PROD
.s
These functions return the summation or product of their 
arguments.
The arguments are specified with a FOR loop.
.x strings> concatenation
For example:
.s
.i+8;SUM( ARRAY(I) FOR I = 1 TO 100 )
.i+8;PROD( SQR(X)*Y FOR X= I TO J )
.s
The type of the result is the same as the argument
with the highest type.
Array arguments are allowed for SUM and PROD.
String arguments are allowed with SUM (in which case concatenation is
performed) but not with PROD.
.x concatenation
.tab stops 16,29
.page
.c;^&MATRIX AND ARRAY FUNCTIONS\&
.x arrays> system-defined functions
.x matrices> functions
.S;.NF;Function	Value
.s;INV(A)	Inverse of matrix A; A must be a non-
.x <INV
.x inverse of matrix
.x matrices> inversion
.x matrices> singular
.x <INV
.x INVERSE
	singular square matrix of type real or
	double precision.
.s
TRN(A)	Transpose of matrix A
.x <TRN
.x determinant
.x transpose of matrix
.s
DET	Single precision value of determinant of
.x <DET
.x <DET
.x DETERMINANT
	last matrix inverted
.s
ZER	Array of zeros; type real.  TYMBASIC
.x <ZER
	creates an array with the proper
	dimensionality and size to satisfy
	the assignment statement in which it appears.
.s
ZER(n)#or	Array of zeroes; type real. TYMBASIC creates a
ZER(n,m)	temporary array of specified dimensionality and size
	which may be used as an operand in an expression.
.s
CON	Array of ones; type real. TYMBASIC
.x <CON
	creates an array to satisfy the
	assignment statement, as above.
.s
CON(n)#or	Array of ones; type real. TYMBASIC creates a
CON(n,m)	temporary array of specified dimensionality and size
	which may be used as an operand in an expression.
.s
IDN	Square identity matrix; type real.
.x matrices> identity
.x <IDN
.x IDENTITY MATRIX
	TYMBASIC creates an array to satisfy
	the assignment statement, as above.
.s
IDN(n)	Square identity matrix; type real. TYMBASIC creates
	a temporary two dimensional array of specified size
	which may be used as an operand in an expression
.s2;.f;Arguments and results concern arrays, specifically one-
or two-dimensional arrays.
A matrix is singular if a pivotal element less than EPS in
absolute value is encountered in INV.
.x <EPS
.page
.s3.c;^&SHIFTING FUNCTIONS\&
.x shifting functions
.s2;Arguments to the shifting functions must be type integer and do not
convert automatically.
Values are type integer.
.s2.nf
Function	Value
.s;LSH(X,N)	X shifted left N bits, with zero fill.
.x <LSH
.x LOGICAL SHIFT
.x LEFT SHIFT
.x SHIFT> LEFT
.x SHIFT> LOGICAL
	If N is negative, X is shifted to the right
	ABS(N) bits.
.s
RSH(X,N)	X shifted right N bits; zero fill. If
.x <RSH
.x RIGHT SHIFT
.x SHIFT> RIGHT
.x SHIFT> LOGICAL
	N is negative, X is shifted to the left
	ABS(N) bits.
.s
ARSH(X,N)	X shifted right N bits; sign fill.  If
.x <ARSH
.x ARITHMETIC SHIFT
.x SHIFT> ARITHMETIC
	N is negative, the sign bit is unchanged
	and the other bits are shifted to the
	left ABS(N) bits.
.s
RCY(X,N)	X cycled N bits to the right if N is
.x <RCY
.x circular shift
.x cycle shift
.x SHIFT> CIRCULAR
	positive, or X cycled ABS(N) bits to
	the left if N is negative
.f
.page
.s3.c;^&STRING FUNCTIONS\&
.x strings> functions
.x strings> system-defined functions
.s;With these functions, S, S1, and S2 denote scalar string expressions,
N, N1 and N2 denote scalar integer expressions, and R may be a numeric or string scalar expression.
.s.nf
Function        Type         Value
.s
LENGTH(S)       integer      number of characters in S
.x <LENGTH
.x length> of string
.s
SPACE(N)        string       N spaces
.x <SPACE
.x conversion> string to numeric
.s
VAL(S)          real         The number specified by S in free form
.x <VAL
.x conversion> string to numeric
.x conversion> numeric to string
.s
VAL(S1,S2)      real         The number obtained by converting
	             S1 using the FORM format of S2
	             (See Sec.#12.4)
.s
STR(R)          string       R is converted to a string according
                             to the same rules as free-form output,
                             observing the type of R (any type ok)
.x <STR
.s
STR(R,S)        string       R converted to string using the
                             FORM format S (any type ok)
                             (See Sec.#12.4)
.s
LEFT(S,N)       string       The first N characters of S, counting
.x <LEFT
.x truncation> string
	             from the left
.s
RIGHT(S,N)	string       The last N characters of S, counting
.x <RIGHT
	             from the right
.s
SUBSTR(S,N1,N2)	string       N2 characters of S, starting with
.x <SUBSTR
.x substring
		character number N1
.s
SUBSTR(S,N)	string       The substring of S starting with
		character number N and ending with the
		last character of S
.s
INDEX(S1,S2,N)	integer      The character position of S2 within S1,
.x <INDEX
    or		or zero if S2 is not found, searching
INDEX(S1,S2)                 S1 from its Nth character or its first
.x strings> searching
                             character if N is not given
.s.tp12
CHAR(N1 [,N2])	string	A string of length 0-5. N2 default is
.x <CHAR
                	5.#N2 will be forced to be
                	in the range 0_<N2_<=5.#CHAR converts the
                	right most N2 bytes (7 bits each) of N1
.x conversion> numeric to string
.x collating sequence
.x <CHARTABLE
                	to a character string as determined by
                	current CHARTABLE values.#Leading bytes
                	of zero are ignored (not converted to
                	null characters).#Imbedded and trailing
                	zeros are converted to CHARTABLE(0).
                	Bytes are taken from bit 1 to bit 35,
                	not from bit 0 to bit 34.
.s
ASC(S[,N]) 	integer      The collating sequence codes of the
.x <ASC
.x conversion> string to numeric
		first N characters of S.#N default is
		5.#The codes are right justified as
		an integer value. See the examples
		after the table.
.s
COMP(S1,S2)	integer      -1 if S1_<S2, 0 if S1=S2, 1 if S1_>S2
.x <COMP
.x comparisons> string
.s
LPAD(S,N)	string       S adjusted to a length of N characters
.x <LPAD
.x string padding
		by adding leading spaces if N_>LENGTH(S)
.tp10
.s
RPAD(S,N)	string       S adjusted to a length of N characters
.x <RPAD
		by adding trailing spaces if N>LENGTH(S)
.x padding> string
.s
CPAD(S,N)	string	S adjusted to a length of N characters
		by centering S if N_>LENGTH(S).
		If S cannot be evenly centered,
		it is left-centered.
.x <CPAD
.x centering
.s
RPT(S,N)	string       S repeated N times
.x <RPT
.x repeat
.s
RJUST(S)	string       S with trailing spaces deleted
.x <RJUST
.x justification
.s
LJUST(S)	string       S with leading spaces deleted
.x <LJUST
.s
COUNT(S1,S2)	integer	The number of times S2 occurs in S1
.x <COUNT
.x justification> string
.x strings> searching
.f
.s.tp9;Assuming the normal collating sequence, here are some examples
of the ASC function:
.x <ASC
.x collating sequence
.s.nf;.LM+8;ASC('A') = 101B
ASC('A',5) = 101B
ASC('AB') = 20302B
ASC('AB',2) = 20302B
.lm-8.f
.p;See also Section 5.6, System-defined Variables.
.page
.page size +5
.s3.c;^&UTILITY FUNCTIONS\&
.x utility functions
.s.nf
Function        Type         Value
.s
RND(X)	real	A pseudo-random number in the range
.x <RND
.x random number function
  or		[0,1).#The derivation of the random
RND		number sequence depends on whether X is
		positive or negative when the sequence
		is initiated.#If X is positive, its
		specific value determines the first
		number generated; if X is negative,
		the internal clock determines
		the first number generated.#RND(0) or
		RND is used to generate succeeding
		random numbers from the sequence started
		with a positive or negative X. RND
		will not generate a random sequence if
		iteratively called with a non-zero
		argument.
POS	integer	The position of the next character to be
.x <POS
.x position
.x terminal> print position
		printed;#the terminal print position
POS(N)	integer	Position on file N.  See Section 11.3.
TAB(N)	string	A string of spaces sufficient to tab to
.x <TAB
		print position N at the terminal.
TAB(N1,N2)	string	A string of spaces sufficient to tab to
		print position N1 on file N2.
.x files> position
DATE	string	A string of 15 characters indicating the
.x <DATE
		date and time of day as follows:
		YY/MM/DD##HH:MM
TIME	integer	An integer incremented every sixtieth of
.x <TIME
.x time of day
		a second; during a session, it always
		increases and is never reset to zero.
TCP	logical	FALSE if no command file is open or TRUE
.x <TCP
.x command files
		if a command file is open.
TERM	logical	TRUE if terminal input awaits processing
.x <TERM
.x terminal input
		and FALSE if not.
LOC(N)	integer	The current location on file N.
		See Section 11.3.
.x <LOC
.x location
.x files> location
SIZE(N)	integer	The size of the open file N.
		See Section 11.3.
.x <SIZE
YEAR	string	The current year as four characters.
.x <YEAR
ERRCD	integer	The number of the most recent error
.x <ERRCD
.x errors> number
		detected by TYMBASIC or 0 (zero)
		if no errors have been detected.
		See the ON-condition statement.
ERRFL	integer	The file unit number associated with the
.x <ERRFL
.x errors> file number
.x files> errors
.x errors> line number
		most recent end-of-file or file error
		or 0 if no file errors have been
		detected.
ERRLN	integer	The number of the statement where the
.x <ERRLN
.x errors> LINE
		most recent error occurred or 0 if none.
ERRMSG(N)	string	The message associated with error number
.x <ERRMSG
.x messages> error
.x errors> MESSAGE string
		N as returned by ERRCD above, which need
		not have occurred. See Appendix B.
TRU	real	The total number of TRUs used
		since logging in.
.x <TRU
.f
.page size -5
.FLAG CAPITALIZE
.FLAG INDEX
.FLAG UNDERLINE
.page size 55
.LM 0 .RM 69 .BREAK .NJ .P 0
.title TYMBASIC REFERENCE MANUAL               EXECUTION
.subtitle 1 January 1978                                                Sec. 8.1
.FT
.page;.C;SECTION 8     EXECUTION
.s2;^&8.1 OVERVIEW\&
.s2;Entering, compiling, loading and executing a TBA program
involves four phases of the TBA system, and four corresponding
phases of system/user interaction:
.s;.lm+8;.i-4;1. The Command/Statement phase, in which TBA
commands and statements are entered and individually (and immediately) analyzed for
syntactic regularity, and a list of modules may be specified.
.x compilation
.x execution
.x phases
.x system/user interaction
.x command/^Statement phase
.s.i-4;2. The Compile phase, in which a relocatable version of each TBA
module is generated and analyzed for global coherence.
.x Compilation phase
.x relocatable files
.x modules> relocatable
.s;.i-4;3. The Load/Initialize phase, in which the loader creates a
core image (program) from the relocatable modules, and variables are
.x programs
.x modules> relocatable
.x variables> initialization
initialized.
.x Run phase
.x core image
.s;.i-4;4.  The Run phase, in which execution is transfered to the
user's program.
.s.lm-8;Each phase need not be explicitly called.
In the sequence
.s;.lm+8;.nf;-TBA
Ver.#4.0
_>10 A = 1
_>20 Print A
_>30 END
_>RUN
1
END IN 30
_>
.s;.f;.lm-8;The RUN command issued in phase 1
initiates the three succeeding phases.
Effects of the commands associated with execution and code
listing are shown below.
.tp 25;.s;.lit
   Command      Effect:                  Remarks

                Compile  L/I   Run

   PMC                                   lists intermediate code
                                         generated by parser

   CDE              X                    compiles the workspace
                                         module, lists a MACRO-like
                                         version of the code

   SAVE BINARY      X     X              compiles and loads program,
                                         does not execute, no
                                         continue point defined
                                         (GO and STEP will not work)

   INITIALIZE       X     X              compiles,  loads and
                                         initializes program,
                                         does not execute, but does
                                         define a continue point
                                         (GO and STEP will work).

   RUN              X     X      X       compiles, loads, initializes
                                         and transfers execution
                                         to program.

   DIRECT STATEMENT X     X      X       compiles, loads, initializes
                                         if the program requires it,
                                         and transfers execution to
                                         the direct statement.

   GO                            X       restarts execution at the
                                         continue point

   STEP                          X       restarts execution at the
                                         continue point

   START                         X       restarts execution at the
                                         start of the program without
                                         losing valid data
.end literal
.x <PMC
.x <CDE
.x <SAVE <BINARY
.x <INITIALIZE
.x <RUN
.x intermediate code
.x parser
.x workspace> module
.x continue point
.x <GO
.x <STEP
.x <START
.subtitle 1 January 1978                                                Sec. 8.2
.page;^&8.2 THE COMMAND/STATEMENT PHASE\&
.s;The user enters the Command/Statement phase by entering
the Xexec command:
.s;.i8;_-TBA
.s;The TYMBASIC system is called, prints the TYMBASIC version number, and issues a _> prompt, which
indicates a readiness to accept commands or statements.
The user's TYMBASIC workspace module is created, into which the
.x modules> workspace (see ^Workspace)
.x workspace
user's indirect statements are entered.
The workspace remains unnamed until either a
.s;.i8;GET file nomen
.s;or a
.s;.i8;SAVE file nomen
.x workspace> name
.x workspace
.x Command/^Statement phase
.s;command is executed, whereupon file nomen (less confirmation) names the
workspace.
The workspace may also be named as a side effect of the Compilation phase.
.x workspace> name
Execution of a
.s;.i8;DEL ALL
.s;command unnames the workspace as well as deleting its
contents.
.s;Each command or statement entered during this phase
is analyzed for syntactic regularity by the parser,
and diagnostics are issued as necessary.
Parser output is the intermediate code that is
displayed with the PMC command.
No check is made in this phase for the correctness of program logic (the relation
of a statement to any other statement).
.p;When entering commands and statements at the "_>" level,
the old line image is the last line typed in response to the "_>".
.x old line
.p;In the Command/Statement phase, the user may create a module list and a library list.
.s2;^&THE MODULE LIST\&
.s;The names of the modules to be loaded into the program
are kept in a module list.
If the module list is empty, then only the workspace module will be loaded.
.x workspace> module
.x module list
The module list contains the names of TYMBASIC source and relocatable modules
and the names of other-language relocatable modules.
During the Compilation Phase, the TYMBASIC source modules are compiled to
produce relocatable modules (any module whose extension is not .REL or .RDL
is assumed to be a TYMBASIC source module).
.x <REL file
.x <RDL file
.x module list
The user's workspace may or may not be included in the
module list.
Modules in the module list are always loaded, whether they are
actually referenced or not.
Current contents of the module list can be listed with the
LIST MODULE[S] command, and modules may be added to or deleted from the
module list by the [NO] MODULE command, and indirectly by the Compilation phase.
.x <NO <MODULE
.x <MODULE
.x <GET
.x <RUN
.x <SAVE
.x <list <module[s]
.S2;^&THE LIBRARY LIST\&
.p;The user may create a list of libraries to be searched by the
loader for procedures that are referenced by modules already loaded.
Libraries are added or deleted from the library list with the LIBRARY
or NO LIBRARY command; libraries can be listed with the
LIST LIBRARIES command.
.x <NO <LIBRARY
.x <LIBRARY
.X <LIST <LIBRARIES
Each user library contains one or more relocatable modules,
grouped for convenience.
Modules in a library will be loaded only if required to satisfy
references to procedures contained within them.
The user's libraries are searched in the order of the library list.
.x library list
Each library is searched only once, sequentially, for modules
that contain procedures that have been referenced from modules already loaded.
.p;Thus, the order in which the libraries appear on the library list
is important.
If a procedure in library A calls a procedure in library B, library B must
follow library A in the library list.
.subtitle 1 January 1978                                                Sec. 8.3
.s3.tp15;^&8.3 THE COMPILATION PHASE\&
.page size +1
.p;The Compilation phase is entered by a direct statement or any of these TYMBASIC commands:
.x compilation phase
.s;.i8;INITIALIZE
.i8;CDE
.i8;RUN
.i8;SAVE BINARY
.x <INITIALIZE
.x<cde
.x run
.x <save <binary
.p;All of the above, except CDE (which compiles the workspace and then
returns to the Command/Statement phase) create a program, and for this
reason invoke a process called Global Recompilation that prepares for the
Load/Initialize phase.
.x <CDE
.x Global ^Recompilation
.x compilation
.p;There are two modes in which Global Recompilation operates:
.list
.le;The module list is empty and the program will consist of the workspace
module.
.le;The module list is not empty and the program will consist of the
modules on the module list.
.els
The first mode is similar to the operation of most other BASIC
systems, and will be discussed first.
.x module list
.x workspace
.s.tp6;^&EMPTY MODULE LIST\&
.page size -1
.p;If the workspace is empty, the error message "No#program" is printed
and the command or direct statement is aborted.
.p;Otherwise, the workspace module is compiled to create a relocatable
module.
The extension for the relocatable module is .REL if the workspace is in
the NO DEBUG state, else it is .RDL.
.x <REL file
.x <RDL file
If the workspace has no name, then a temporary relocatable module is created.
.p;Any compilation errors abort the process and return the user to the
Command/Statement phase.
.s.tp10;^&NON-EMPTY MODULE LIST\&
.p;If the workspace is empty and no startpoint module has been specified (meaning that the workspace is the startpoint),
the error message "No program" is printed and the command or direct statement is aborted.
.s;^&Adding the Workspace to the Module List\&
.x module list
.x workspace
.p;If the workspace is not empty and does not appear exactly on the module list
(comparing user name, file name, and extension), then the user is given
the opportunity to add the workspace to the module list
(and name it in the process, if necessary).
.p;The workspace will be included in the program ONLY IF it appears on the
module list.
.p;If the workspace is in fact not on the module list, TYMBASIC will ask:
.s.i8;Add workspace to module list?
.p;If the response is N[O], Global Recompilation continues, and the workspace
will not be loaded in the Load/Initialize phase and therefore
will not be part of the program.
If the response is Y[ES], then the workspace name is added to the module
list.
If unnamed, TYMBASIC prompts:
.s.i8;Name:
.p;and the user gives the workspace name (note that a SAVE is not
.x workspace> name
automatically executed to the file with this name).
The user may also answer "AS#file#nomen" to the "Add#workspace" question,
which implicitly answers affirmatively and names the workspace at the
same time.
.s.tp10;^&Checking for a Valid Startpoint\&
.p;After it has been determined whether or not the workspace will appear
on the module list, a check is made that the startpoint module
is on the module list.
If it is not, TYMBASIC prints
.s.i8;STARTPOINT not element of program
.p;and aborts the command.
If a direct statement was given, the check is still made despite the
fact that execution begins with the direct statement.
.s;^&Compilation of Modules\&
.p;In the next phase of Global Recompilation, every TYMBASIC
source module on the module list is compiled, if necessary,
to create a corresponding relocatable module (in this context,
compilation also includes line-by-line parsing).
Any module whose extension is not .REL or .RDL is assumed to be a
TYMBASIC source module.
.x modules> source
.x modules> relocatable
.x <REL file
.x <RDL file
.x extension
If a relocatable module is newer than its corresponding source module,
the source module will not be compiled.
If it is older or none exists, the source module will be compiled.
For each module compiled, TYMBASIC prints
.s.i8;TBA:
.p;followed by the file name.
If an unnamed workspace is compiled, the name will appear as "WRK.SP".
.p;If the source module is in another directory (user name) then that 
directory is searched for the corresponding relocatable module
newer than the source module; if not found, the current directory
is searched.
If none can be found, then one is created in the current directory
by compilation of the source module.
.p;The extension for a relocatable module is .REL if compiled in the NO#DEBUG
state (default) and .RDL if compiled in the DEBUG state.
.x <REL file
.x <RDL file
.x modules> source
.x modules> relocatable
.x modules> in other directories
.x compilation
.p;If a direct statement was entered, it is compiled in the same debug
state as the workspace, producing a temporary relocatable module.
.x statements> direct
.x modules> direct statement
.p;The workspace module will be compiled if any other
modules were compiled in the current invocation of Global Recompilation
(not counting the direct statement module).
.p;Global errors involving two or more statements in a module
may be detected during compilation of that module; a fatal error will
end compilation of that module but compilation of other modules
will proceed.
However, when Global Recompilation is complete, control will pass
back to the Command/Statement phase rather than to the Load/Initialize phase.
.subtitle 1 January 1978                                                Sec. 8.4
.page;^&8.4 THE LOAD/INITIALIZE PHASE\&
.x Load/^Initialize phase
.s2;The Load/Initialize phase includes loading of the relocatable
modules in the user's module list (or the workspace module if none),
plus the loading of any other modules needed, from the user's libraries
and the TYMBASIC Run Phase System Library, in that order.
.x TYMBASIC system library
.x libraries> user's
.x libraries> <TYMBASIC system
.s;Note: System file handling facilities should not be used to rename
relocatable files, or combine modules; the loader expects
to find exactly one module name embedded in each relocatable
file loaded as a module, and it expects the module and
file names to match.
.s;^&INITIALIZATION\&
.x initialization
.p;During initialization, the following occurs:
.lm+4
.p;Variables defined within TBA modules are given initial values
(see Sec.#5.2), and system-defined variables (see Sec.#5.6) are initialized to their default
values.
.x initial values
.p;NEXT statements are set to fall through when branched to.
.x <NEXT
.p;Array variables are set to generate an error condition if referenced
prior to execution of the array declaration.
.p;Files are closed except for command and TOUT files.
.x <TOUT files
.p;Error traps are unset and ERRCD, ERRFL, and ERRLN are set to zero.
.x <ERRFL
.x <ERRCD
.x <ERRLN
.p;GOSUB's are deactivated (all return locations are cleared).
.x <GOSUB
.p;BASE value is set to 1.
.X <BASE
.p;BOUNDARY is set to 0.
.x <BOUNDARY
.p;SIGNIFICANCE value is set to 14.
.x <SIGNIFICANCE
.p;The Random number seed is initialized.
.x RND
.x random number function
.p;DET value is set to 0.
.x <DET
.lm-4
.p;After completion of the Initialization phase, the program is said
to contain valid data (in variables), until some modification is made to
.x data> in variables
the program (see below).
While the program contains valid data, the data may be accessed
by a direct statement and the START command is also allowed.
.x <START
.x statements> direct
.x valid data
.x data> in variables
.subtitle 1 January 1978                                                Sec. 8.5
.page;^&8.5 THE RUN PHASE\&
.p;The RUN phase transfers execution to the startpoint module.
.p;^&END OF EXECUTION\&
.p;Execution continues until 
.list.le;the end of the program or execution of
a STOP or END statement
.le;execution of a QUIT or LOG statement
.le;end of the direct statement if one was entered
.le;execution of a PAUSE statement
.le;a breakpoint is encountered
.le;an error condition occurs which the program does not trap
.le;one or more escapes is typed
.le;The STEP count is exhausted
.els
.p;In the first case, control returns to the Command/Statement phase.
User files are closed, but data values are retained in variables,
and can be accessed by a direct statement (i.e., the program contains valid data).
.x statements> direct
.x valid data
.x data> in variables
.x programs> end of
.x <STOP
.x <END
.x termination> execution
.p;In the second case, control leaves the TYMBASIC system, returning
either to XEXEC or ending the session entirely.
.x <XEXEC
.p;When execution of a direct statement terminates, control returns to the
Command/Statement phase, but no files or closed nor any data lost.
.p;^&Interruptions And Continuability\&
.p;For the remaining cases, the program is interrupted and control
returns to the Command/Statement phase.
An interrupted program is continuable; that is, it may be continued
by the use of the GO or STEP commands.
.x <GO
.x <STEP
.x continue point
.x continuability
.x execution> interruption of
Each of the interruption conditions defines a continue point,
which is the line to which the GO or STEP commands will transfer execution.
.p;If the program has been initialized but not run (with the INITIALIZE command),
.x <INITIALIZE
the continue point is the same as the startpoint:  the first line in
the startpoint module.
.x interrupting execution
.p;If an interruption results from a PAUSE statement,
the continue point is the point immediately after the PAUSE.
.x <PAUSE
.p;If an interruption results from a breakpoint being encountered,
.x breakpoints
the continue point is the beginning of the statement at which
the breakpoint was set.
.p;If an interruption results from a single escape,
.x single escape
.x escapes
the current statement completes execution and the continue
point is the next statement in the program.
.p;If an interruption results from two or more escapes,
execution of the current statement is interrupted, and
the continue point is the beginning of that statement.
.s;^&Program Modification\&
.p;While in the Command/Statement phase, valid data contained in variables is retained and the program
remains continuable until some part of the program is modified.
A program modification may be any of the following:
.x program modification
.x program modification
.x source modification
.s.lm+6.nf
*modifying any module, including the workspace
*changing the DEBUG state for any module
*adding or deleting a module or library
.lm-6.f
.p;TYMBASIC always asks the user for confirmation before allowing him to
make a program modification that will lose valid data.
.p;If the program contains valid data and the last statement executed lies within the
workspace module, then a direct statement will be compiled in the same context
as that statement.
That is, those variables known at that line in the workspace module
are the ones accessible to the direct statement (see Sec.#7.5).
.x statements> direct
.x context
.x workspace> module
.page;^&8.6 COMMAND FILES\&
.x Command files
.subtitle 1 January 1978                                                Sec. 8.6
.p;.f;Command files permit TYMBASIC to take its commands and terminal
input from a file rather than from the terminal.
A command file may be called by either the DO command, or the
OPEN statement with * or -1 as the file unit number.
.p;If another command file is called while a command file is
open, input is taken from the new file until its end and then TYMBASIC
resumes taking input from the first file where it left off.
Command files may be stacked in this way up to ten levels.
.s2.tp5;^&ECHOING OF COMMAND INPUT\&
.p;During execution of a command file, the command input
is not normally printed (echoed).
Of course, if command input is from the terminal (which may be opened as a
command file from another command file), the command input and the prompts and
messages associated with it are printed at the terminal.
.p;However, if echoing is being done (see the ECHO command),
command input and the prompts and messages associated with it will be printed,
either at the terminal or on the TOUT file if one is open (see the TOUT command).
For example:
.s.lm+8.lit
>DO COM1        !Commands in COM1 are not printed
>ECHO
>DO COM2
>MODULES A,B    !These are commands from COM2.  The commands
>LIBRARY C      !and prompts are printed because ECHO is on.
>
.end lit.lm-8
.p;The state of echoing applies to the current command file and to command
files it calls.
Suppose, for example, that echoing is on during the execution of one command file
and another command file is called.
Then echoing continues for the second command file, unless it turns
echoing off.
If it does, then echoing remains off until the end of the second command file.
At this point, execution returns to the first command file and the state
of echoing is automatically reset on, as it was when the first
command file transfered execution to the second.
.x echoing
.x <ECHO
.x <TOUT files
.p;The end of file for the terminal opened as a command file is signified
by typing an ampersand (_&) alone on a line.
.x ampersands
.x _&
.p;Command files (and TOUT files) remain open across the different
phases of the TYMBASIC system, so that a command file opened in the
Command/Statement phase will remain open in the Run phase.
Normal input done by statements in the Run phase with the
INPUT statement will input from the current command source, be it either
the terminal or a command file.
.x <INPUT
.s2.tp10;^&ERRORS DURING COMMAND FILE EXECUTION\&
.x errors> in command files
.x command files
.p;If an error occurs during execution of a command file, all command files
are closed until the terminal is again the command source.
TYMBASIC will print the error message, then the last line read from the
command file, then
.s.i8;At line n in name
.s;for each command file closed, where n is the number of the last line
input from the command file and name is the name of the
command file.
.p;Certain conditions are considered warnings, rather than errors, and
in this case execution of the command file proceeds.
.x warnings
.flag capitalize
.FLAG UNDERLINE
.F .FLAG INDEX
.LM 0 .RM 69 .BREAK .PAGE .nj .p 0 .TAB STOPS 4,20
.title TYMBASIC REFERENCE MANUAL              STATEMENTS
.subtitle 1 January 1978                                                Sec. 9.1
.FT
.s;.c;SECTION 9.  STATEMENTS
.f;.S3;This section provides the syntax, semantics, and examples
of the TYMBASIC statements, arranged in alphabetical order.
A concluding section discusses the six statement modifiers.
.p;Symbols used in the syntax:
.S;.LM+8;.NF;        n              The letter n indicates an integer-
                       valued expression.  Several fields
                       are indicated by numbers:
                       n1, n2, etc.
.s
        s              string expression
.s
        r              real expression
.s
       id              identifier (see Sec. 4.1.)
.s
       ln              line number
.s
      list             List following a metasymbol indicates
.x lists
                       one or more entries may be made
                       separated by commas.
.s
     variable/         List of variables and dimension
     dimension         specifications for declaration
      list             statements (see Sec. 5.3.)
.x variable/dimension lists
.s
     input list        List of variables (arrays,
                       simple variables, array elements,
                       subarrays or subarray names)
.x input lists
.s
     text              any string of characters up to
                       a carriage return
.x text
.lm-8
.page;^&9.1  STATEMENT DESCRIPTIONS\&
.s2;^&BASE\&
.x <BASE
.s
Syntax:
.S
.i8;BASE n
.s
Semantics:
.s
.f;The ><BASE statement changes the default lower bound for
.x arrays> bounds
array dimensioning to n for the current module only.
n may be positive, negative, or zero.
The default lower bound is initially 1.
.x arrays> lower bound of
For example:
.S;.i8;10 BASE 5
.i8;20 REAL A(20,M)
.S;.nf;is equivalent to:
.S;.i8;10 REAL A(5:20, 5:M)
.s2
><&B&O&U&N&D&A&R&Y
.s
Syntax:
.S
.i8;BOUNDARY r
.s
Semantics:
.s;.f;
The BOUNDARY statement causes values of magnitude
less than the real value r to be written as zero for every module in the program;
it applies only to free-form output.
.x output> free-form
.x free-form> output
.x output> free-form
(Note that r must be _>= 0).
For example:
.s.lm+8.nf;10 BOUNDARY 1E-3
20 X=-2/10000
30 PRINT "X=":X
.s;_>RUN
X= 0
.f.lm-8
.s2.tp10;^&CALL\&
.x <CALL
.s;Syntax:
.s.i8;><CALL id [(expression list)]
.s;Semantics:
.x subroutines> calls to
.x subroutines> arguments
.p;The CALL statement transfers control to the procedure named by the identifier;
any specified arguments are passed to the procedure.
When the procedure exits, control returns to the point immediately following
the call.
For example, suppose a program contains the following
procedure:
.s;.nf;.i8;500 DEF PRINTSTARS(N)
.i8;510 PRINT "****" FOR i=1 TO  N
.i8;520 EXIT
.i8;530 ENDF PRINTSTARS
.f
.tp 6
.s;Then the line
.s;.i8;200 CALL PRINTSTARS(10)
.s;causes a column of four asterisks ten lines long to be printed.
See also Section 7.4.
.x procedures> calls to
.tp12;.s2;<^&CIB\&
.x <CIB
.s;Syntax:
.s.i8;CIB
.s;Semantics:
.s;The CIB statement clears the terminal input buffer (both the monitor's and
TYMBASIC's).
.tp12;.s2
<^&CLOSE\&
.page size +4
.x <CLOSE
.s1
Syntax:
.S
.i8;CLOSE n1[,n2...]
.s
Semantics:
.s
.f;The CLOSE statement closes each file having the file unit number
specified by each expression if a file is open on that file unit number.
CLOSE 0 restores normal terminal input after an OPEN...BINARY...0 statement
has opened the terminal for eight-level input.
.x eight-level
CLOSE * (or CLOSE -1) closes the command file (if any).
.x closing files
For example:
.s;.i8;100 CLOSE 3,17,M+2
.s2.tp10;^&COB\&
.page size -4
.x <COB
.s;Syntax:
.s;.i8;COB
.s;Semantics:
.p;The COB statement clears the terminal output buffer by discarding
any characters in the TYMBASIC output buffer and causing any characters
en route to the terminal to be discarded.
.x terminal output buffer
.x output buffer> terminal
.x terminal> output buffer
.x terminal> clearing output buffer
.s2.tp10;<>^&COMPLEX\&
.s
Syntax:
.S
.i8;COMPLEX variable/dimension list
.s
Semantics:
.s
The COMPLEX statement declares complex variables and
dimensions complex array variables (see also Sec.#5.3).
For example:
.S;.i8;10 COMPLEX IVAL$, STRESS$, XTABLE(8,4)
.f
.s2.TP 10;<^&COPY\&
.x <COPY
.s;Syntax:
.s
.i8;COPY s1 TO s2
.s
Semantics:
.s;The COPY statement copies the contents of the file with file nomen
specified by s1 onto the file with file nomen specified by s2.
.x copying files
If s2 specifies the terminal, then s1 is printed at the TOUT destination (usually the terminal).
If s1 specifies the terminal, then data entered from the command source
(usually the terminal) is copied onto s2.
An _&  alone on a line will terminate
.x _&
data entry from the command source.
Examples:
.s.nf.lm+8;100 COPY FINAL1$ TO FINAL2$
100 COPY "FILEX" TO A$+B$
100 COPY "SUMFIL" TO "TERM"
.f.lm-8
.x files> copying
.x <TERM > in <COPY statement
.p;COPY to or from the terminal is symbolic (character-by-character).
However, one file may be copied to another without any restrictions on its
contents.
.s2.tp10;<>^&DATA\&
.s;Syntax:
.s;.i8;DATA text
.s;Semantics:
.s;The DATA statement supplies symbolic data, which is read as free-form
input in READ statements.
.x free-form> input
The data is sorted in order of increasing line numbers
into a single data block, with data from each statement separated by a comma.
Data blocks for each module in the program are kept separately.
For example:
.nf.s;.lm+8;100 DATA "XYZ", 12.3 3D-9
110 DATA 10E-3, "LITERAL"
120 DATA 42
.s;.i-8;is equivalent to:
.s;100 DATA "XYZ", 12.3, 3D-9, 10E-3, "LITERAL", 42
.s.lm-8.f;Data is stored symbolically and the appropriate
value is created at the time a READ statement occurs.
Comments are not allowed in DATA statements.
.x Comments> in <DATA statement
.x read statement> data for
DATA statements are not executable.
.s2;<^&DEF[INE]\&
.x <define
.s;Syntax:
.s;The DEF statement syntax is given in Section 7.3.
.s;Semantics:
.p;.f;The <>DEF statement defines user-written procedures.
.x procedures> user-defined
.x user-defined procedures (see ^Procedures)
There may be as many as 511 user-defined procedures.
See Section 7 for a full description of user-defined procedures.
.p;If a DEF statement is reached by falling through or by a GOTO statement,
the procedure is branched around: the next executable statement
after the ENDF (or after a single-line DEF) is executed.
.tp17;.s2;<>^&DIM\&
.s;Syntax:
.s;.i8;DIM variable/dimension list
.s;Semantics:
.p;The DIM statement dimensions array variables whose types
are determined implicitly by variable name (see also Sec.#5.3).
For example:
.s;.nf;.i8;50 DIM RATIOS(4,1000,P*Q),DAT$(0:4,-2:M,7)
.s;.F;Any string dimensioned in a DIM statement has a maximum
.x strings> maximum length
string length of 4095 characters, since no length field
is permitted in the DIM statement.
.s2;<>^&DOUBLE\&
.s;Syntax:
.s;.i8;DOUBLE variable/dimension list
.s;Semantics:
.p;The DOUBLE statement declares double precision variables and
.x double precision
dimensions double precision arrays (see also Sec.#5.3).
For example:
.s;.i8;10 DOUBLE EXACTA(100,M:N),NUM$,BER(3,4)
.x double precision
.S2;<>^&EIGHTI\&
.page size +3
.s;Syntax:
.s;.i8;EIGHTI input list
.s;Semantics:
.f;.p;The EIGHTI statement accepts eight-level
.x eight-level
.x terminal input> eight-level
.x terminal input
terminal input characters and assigns them to the named scalars,
which must be declared integer.  TYMBASIC does not
prompt for input.  Before an EIGHTI statement will be allowed
to execute, the following statement must have been executed:
.s;.i8;OPEN "TERMINAL" FOR BINARY INPUT AS FILE 0
.s;No normal terminal input is allowed until CLOSE 0.
.x <Close 0
Normal terminal output occurs during EIGHTI mode.
.x <TERM > system-defined function
The TERM function continues to operate during EIGHTI mode,
but input characters are not echoed.
.s;Echoing is turned on by a CLOSE statement
with a file number of zero.
.tp 10;.s2;<>^&EIGHTO\&
.page size -3
.s;Syntax:
.s;.i8;EIGHTO integer expression list
.s;Semantics:
.p;The EIGHTO statement prints an eight-level character at
.x terminal output> eight-level
the terminal for each integer value given in the list.
.x terminal output
.s2;<>^&END\&
.s;Syntax:
.s;.i8;END [expression]
.s;Semantics:
.p;The END statement terminates program execution, closes all
files (except for command and TOUT files), and prints any specified expression or END IN line number.
For example:
.s;.i8;100 END "JOB DONE"
.x execution> termination of
.x termination> execution
.f;.s2;<>^&ENDF\&
.s;Syntax:
.nf;.lm+8;
ENDF  id
.f;.lm-8;.s;Semantics:
.p;ENDF signifies the end of the user-defined procedure named by the identifier.
If an ENDF is executed, an EXIT with null value occurs.
See the DEF and EXIT statements.
.x procedures> end of
.tp10.s2;^&ENDIF\&
.x <ENDIF
.s;Syntax:
.s.i8;ENDIF
.s;Semantics:
.s;The ENDIF statement ends an extended IF statement (see IF).
.tp10;.s2;<>^&ERASE\&
.s;Syntax:
.s;.i8;ERASE n FROM n1 TO n2
.s;Semantics:
.p;The ERASE statement erases locations n1 through n2 in the file with
unit number n,which must be a RANDOM file open for OUTPUT or IO, but not
for input. The erasure is done by filling with nulls (zeroes) for
binary files or spaces for symbolic files, except when erasing to or
beyond the end of the file in which case nulls are always used.
For example:
.s;.i8;400 ERASE 3 FROM 100 TO 125
.p;See Section 11.5.
.s2;<>^&EXIT\&
.s;Syntax:
.s;.i8;EXIT [expression]
.s;Semantics:
.p
The EXIT statement transfers control to the point immediately following a
.x control transfer
procedure call.
If EXIT is followed by an expression, the value of the
expression is returned as the value of the procedure
(as with a function).
If the expression is omitted, a zero, for numeric or
logical valued procedures, or a null string, for string valued procedures,
is returned.
A CALL statement ignores the returned value.
The EXIT causes space allocated for string and array parameters to be
released (see Sec.#7.5.).
Example:
.s.i8;EXIT (A-B)*2
.tp 20;.s2;<>^&FOR\&
.s;Syntax:
.x <FOR> loops
.x <FOR> statement
.x <FOR> statement> execution of
.x <next
.s;.lit
FOR iteration variable = iteration part [,iteration part ...]

.
.
.
NEXT iteration variable
.end lit
.x iteration variable
.p;The iteration variable must be a simple scalar variable of type
integer, real, or double.
Its scope is not limited to within the FOR loop; that is, it may be referenced
outside of the FOR loop.
.p;Iteration part, syntax:
.s;
.lit;

           BY         UNTIL logical expression
                n2    WHILE logical expression
           STEP       TO   n3
     n1

                        BY
               TO  n3  STEP  n2
.end lit
.f
.p;n1, n2 and n3 are numeric expressions; default for n2 is +1.
.s;Semantics:
.p;The FOR Statement executes one or more statements
repeatedly over a range of values for the iteration variable:
it is initially set to n1, and its limit value is determined by the
UNTIL, WHILE, or TO clause.
When there is more than one iteration part, any following iteration
part is invoked only after the preceeding iteration part is
exhausted.
.p;When an iteration part is invoked, n1, n2 and n3
are evaluated.
n1 is then stored into the iteration variable.
At this point, a FOR Test is made, and if its value is TRUE
the FOR loop begins execution.
.p;If the TO n3 clause is used, as in:
.p;.i8;FOR i= n1 BY n2 TO n3
.p;the value of the FOR Test is:
.p;.i8;SGN(n2)*i _> SGN(n2)*n3,
.p;where i is the iteration value defined below.
.p;If the WHILE or UNTIL clause is used, as in:
.p;.i8;_._._.n1 BY n2 UNTIL logical expression
.p;then the value of the FOR Test is either the value of
logical expression for WHILE, or NOT logical expression
for UNTIL.
.p;When the NEXT statement is executed, an iteration value
is computed that is the sum of the current value of the
iteration variable and n2 (as computed when the iteration part
was invoked). If either a WHILE or UNTIL clause was used in
the current iteration part the iteration value is stored
immediately into the iteration variable.
Otherwise, the iteration value is stored only if the value
of the FOR Test, which is now made, is TRUE.
.p;In any case, if the value of the FOR Test was TRUE the
FOR loop body is executed. If FALSE, the current
iteration part is exhausted.
.p;Therefore, the following hold for FOR statements:
.p;.list;.le;If a FOR statement is executed, it will always
store an initial value into the iteration variable.
.le;Changes to the iteration variable within the loop
body do affect the loop decision logic.
.le;The loop test is made before execution of the loop body;
it is possible to execute the FOR statement but not the loop
body.
.le;After execution of a FOR loop, the iteration variable
contains the first value for which the logical expression was
not satisfied if WHILE or UNTIL, or the last value for
which the loop was executed if TO.
.le;n1, n2 and n3 are evaluated only once for each iteration
part. The default value for n2 is +1.
.end list
.p;FOR-NEXT loops may be nested to any depth.
.p;A GOTO may branch into a FOR loop even though the FOR
statement itself has not been executed.
When the NEXT statement is reached, the iteration variable
does not change and control passes on as if the entire
loop had been exhausted.
.nf
.nf.s2.tp10;GO SUB
<>^&GOSUB\&
.s;Syntax:
.s;.i8; GO SUB
.i8; GOSUB    ln
.s;Semantics:
.f;.p;The GOSUB statement transfers control to the subroutine at
the specified line number.
Subroutine calls may be nested to any depth.
TYMBASIC allows recursion for GOSUBs, but variables are not
automatically saved or restored at each recursion level.
A GOSUB may cross the boundaries of a user-defined procedure.
GOSUB and GO SUB are equivalent.
The end of the subroutine is indicated by a RETURN statement, execution
of which transfers control to the point immediately after the GOSUB.
.TP 10;.s2;GO TO
.br;<>^&GOTO\&
.s;Syntax:
.s;.i8; GOTO
.i8; GO TO###ln
.s;Semantics:
.f;.p;The GOTO statement transfers control to the specified line number.
GOTO and GO TO are equivalent.
.s2.tp25;<>^&IF\&
.page size +5
.S;Syntax:
.nf.s;IF logical expression THEN ln1        [ELSE ln2       ]
.nf;                           statement1       statement2
.s;Semantics:
.s;.f;The IF statement transfers control or executes a specified
statement depending upon the value of the logical expression.
If the expression is TRUE then either statement1 is executed
or control passes to the first line number.
If the expression is FALSE then either statement2 is executed or
control passes to the second line number; if the ELSE clause is
omitted then the next statement in the program sequence is
executed.
All parts of a logical expression are evaluated, even when
its final value could be determined during evaluation.
.s;Statement1 and statement2 must either be modifiable (see Sec.#9.2) or be further
IF...THEN and IF...THEN...ELSE statements, which may be nested to any
depth.
For example:
.s;.nf;.i8;10 IF X=3 THEN IF F_>20 THEN 200 ELSE 300 ELSE PRINT "HELP"
.s;.F;An ELSE is matched with the nearest unmatched IF.
.x <ELSE clause> in <IF statement
.s;There is a difference in action between an IF...THEN
I/O statement and an I/O statement followed by an IF modifier.
.x statement modifiers
.x <IF modifier
.x <then clause> in <if statement
For example:
.s;.nf;.i8;IF X=0 THEN PRINT ON Z AT N:Y
.s;.f;does not reposition file Z to N when X does
not equal 0, whereas
.s;.nf;.i8;PRINT ON Z AT N:Y IF X=0
.s;.f;does.
The statement modifier applies only to the I/O list.
.s2;<>^&IF (Extended)\&
.x <if> extended
.x extended <if
.S;Syntax:
.s
.lit
        IF logical expression THEN
            .
            . statements
            .
        [ORIF logical expression THEN]
            .
            . statements
            .
        [ELSE]
            .
            . statements
            .
        ENDIF
.end lit
.x <ORIF
.x <ELSE
.x <ENDIF
.S;
.s;Semantics:
.s;The extended IF executes a group of statements selected
according to the evaluation of one or more logical expressions.
Statements following an ORIF clause are executed if its logical
expression is TRUE and if all preceding logical expressions are FALSE.
There may be any number of ORIF clauses.
Statements following the ELSE clause, if present, are executed if
all preceding expressions are FALSE.
.s;
.f;At most, only one set of statements (subpart) of
an extended IF is executed.
The conditions are evaluated only until one is satisfied.
.f;.s;Extended IF's may be nested.
There may not be any ORIF's following an ELSE clause, except
those in a nested IF.
.s;A branch to an ORIF or ELSE line branches to just past the ENDIF line.
.x <ORIF
.x <ELSE
.x extended <IF
.x <IF> extended
A branch to within a set of statements controlled by an extended
IF, ORIF, or ELSE completes execution of the entered subpart,
then branches to just past the ENDIF line.
.s2;^&IIF\& (abbreviation for INPUT IN FORM)
.x <IIF
.s2;^&IIM\&    (abbreviation for INPUT IN IMAGE)
.x <IIM
.TP 10;.s2;<>^&INPUT\&
.S;Syntax:
.s;.i8;INPUT input list
.s;Semantics:
.p;The INPUT statement accepts free-form input from the command source,
assigning the entered values to the variables specified in the list.
.x free-form> terminal input
.x Terminal input> free-form
.x ?> input prompt
.x command source
.x command files
The command source is normally the terminal, but may be a
command file (see the DO command and the OPEN statement).
Arrays and scalars may appear in the input list in any combination.
The old line image for terminal editing is the last line typed in response
to an INPUT statement.
.x <DO
.x <OPEN
See Section 12.3 for a discussion of free-form input.
.s;.nf;An example is:
.S;.lm+8;<>INPUT A$, RATES (3,8), XARRAY$
? "RANDOM" 25.3
? "FIRST"Gc "SECOND", "THIRD"Gc "FOU,RTH"
.f.lm-8
.s2.tp12;<>^&INPUT FROM\&
.page size -5
.s;Syntax:
.s;.i8;INPUT FROM n [AT n1]:  input list
.s;Semantics:
.p;The INPUT FROM statement assigns values
from file with unit number n (which must be open) to the listed variables.
The AT clause applies only to  random files:
n1 is an integer expression whose value specifies the
location from which the first value is read (see Sec.#11.3).
For example:
.S;.i8;50 INPUT FROM 3 AT 10:  X,Y,FOO$(1:5)
.s2;.nf;INPUT IN FORM
.tp10;^&INPUT IN IMAGE\&
.s;Syntax:
.i8;                            FORM
.I8;INPUT  [FROM n [AT n1]] IN  IMAGE  s : input list
.s;Semantics:
.s;.f;The IN FORM and IN IMAGE clauses specify formatting.
The string expression is the format used for the input conversion.
See Section 12 for a discussion of formatted input.
.s2;<>^&INTEGER\&
.f
.s;Syntax:
.s;.i8;INTEGER variable/dimensions list
.s;Semantics:
.p;The INTEGER statement declares integer variables and
dimensions integer array variables (see also Sec.#5.3).
For example:
.S;.i8;50 INTEGER EMPNO,B$(50)
.page size +6
.page;^&LET\&
.x <LET
.s;Syntax:
.s.i8;[LET] assignment list
.x assignment list
.x assignment
.p;The assignment list is a list of one or more assignments of the following
forms:
.s.i8;input list = expression
.x =
.x input lists
.i8;variable == variable
.x ==
.x exchange
.s;Semantics:
.p;The first form of an assignment (input list = expression) stores
the value of the expression into the listed variables. For example,
.s.lm+8.nf
10 I = 5
20 I, J, K = 5
.f.lm-8
.p;The second form of an assignment (variable == variable) exchanges
the values of the two variables.
.p;The two forms of assignments may be strung together into a list.
For example,
.s.i8;10 A,B = C*2, D == E(4), F,D = FUNC(G)
.p;Scalar and array assignments may appear in any combination in the
assignment list.
.p;The assignments in the assignment list are executed from left to right.
However, within a compound assignment (e.g., I,J = 5) the assignments
are executed from right to left.
Within any assignment, all subscripts for variables on the left of
the equal sign are evaluated prior to evaluation of the expression.
For example,
.s.i8;10 I = 5
.i8;20 B(I), I = 10
.p;Line 20 stores 10 into I and into B(5).
.p;The type of the value to be stored is converted to the type of the
receiving variable, if possible (see Type Conversion, Sec.#3.2).
.x conversion> in assignments
.x arrays> assignment
.p;For array assignment the number of elements must be the same.
For string assignment, a value longer than the declared maximum length
of the receiving string variable will be truncated to that length.
.x strings> assignment
.x strings> maximum length
.x truncation> string
.x assignment> strings
.p;The word LET is optional and is provided for compatibility with other BASICs.
.p;Note that A=B=C does NOT store C into A and B, but rather
evaluates the logical expression B=C and stores either
true or false into A.
.page size -6
.s2.tp10;<>^&LOCATE\&
.s;Syntax:
.nf
.i8;               *
.i8;LOCATE n1  ON  n2
.f.s;Semantics:
.p;The LOCATE statement makes n1 the current location on random file n2.
.x random-access files> position
For a variable length record file the location is a data unit number:
a character number in symbolic files, a word number in binary files.
For a fixed length record file the location is a record number.
The LOCATE statement sets the position function POS to 1 for that file.
.x <POS
.x data unit
The specified location may be greater than the current size of the file (see Sec.#11.3).
.s2;<>^&LOG\&
.s;Syntax:
.s;.i8;LOG [expresssion]
.s;Semantics:
.p;The LOG statement halts program execution, closes all files, and ends the
.x execution> program
.x programs> execution
user's entire session at the terminal.
Logout information is printed as well as any expression given
after the word LOG.
For example:
.s;.i8;100 LOG "FINIS"
.x logging out
.tp10;.s2;<>^&LOGICAL\&
.s;Syntax:
.s.i8;LOGICAL  variable/dimension list
.s;Semantics:
.p;The LOGICAL statement declares logical variables
.x logical values
and dimensions logical array variables (see also Sec.#5.3).
For example:
.s.i8;10 LOGICAL BOOLE, SWITCH(4)
.s2.tp10;<>^&LOL\&
.s;Syntax:
.s;.i8;LOL n
.S;Semantics:
.p;The LOL statement sets the line length to n characters
for free-form output for all modules in the program (see Sec.#12.3).
.x output> free-form
.x free-form> output
The initial LOL is taken from the user's terminal characteristics.
.x line length
For example:
.s.i8;100 LOL 125
.s;The LOL statement modifies the user's terminal characteristics.
LOL affects output to a file as well as to the terminal.
The LOL specification remains in effect until another
LOL is executed.
If a number greater than 256 is specified, LOL is set to 256;
if a number less than or equal to zero is specified, LOL is not changed.
.x terminal characteristics
.s2;<>^&MAT\&
.page size +3
.x Matrix operations
.s;Syntax:
.s;.i8;MAT statement
.s;Semantics:
.p;The MAT statement indicates matrix multiplication
or exponentiation rather than element-by-element.
MAT prefixed to a line will effectively change all * operators
to MUL and all ** or _^ operators to PWR.
For example:
.s;.i8;MAT A = B*(C**D)
.s;compiles as
.s;.i8;A = B MUL (C PWR D)
.s;MAT may precede any statement; it cannot be used within an expression.
.lm+8;.p;.i-8;Legal:
.s;MAT INPUT B
.nf;MAT READ A
MAT PRINT A * B
IF X = Y THEN MAT A = (B * C) + (D_^ E)
.f.s.lm-8;In the last example the MAT does not apply to the logical expression
X = Y.
.nf.lm+8.s.tp3.i-8;Illegal:
.x arrays> output
.x input> array
.x arrays> input
.x output> array
.x arrays> manipulation
.s;IF MAT A = B * B  THEN...
.lm-8;.s;.f;MAT has no effect on expressions that already
indicate matrix operations:
.s;.i8;A = B MUL C
.s;and
.s;.i8;MAT A = B MUL C
.s;are equivalent.
.TP 10;.s2;.f;<>^&NAME\&
.s;Syntax:
.s;.i8;NAME id1 =  id2 (subarray bounds list)
.s;Subarray bounds syntax:
.s.i8;n1 : n2
.i8;#*
.P;Semantics:
.p;The NAME statement creates a subarray: a rectangular-shaped
subsection of an existing array (see Sec.#5.5 for a full discussion of subarrays).
The existing (or parent) array must have already been declared, and the
subarray bounds must not be greater in number or extent
than that of the parent.
The number of NAME statements that precede the first declaration of the parent
array is limited to 5.
.s2;.f;<>^&NEXT\&
.s;Syntax:
.s;.i8;NEXT iteration variable [,iteration variable...]
.x <FOR> loops
.s;Semantics:
.p;The NEXT statement marks the end of the FOR loop
statements.
If more than one iteration variable appears, the statement is
equivalent to
.p;.i8;NEXT iteration variable1
.i8;NEXT iteration variable2
.i8;_.
.i8;_.
.i8;_.
(See the FOR statement)
.x <FOR> loop termination
.x termination> <FOR loops
.f
.s2.tp10;<>^&NO\&
.s;Syntax:
.tp10;.s;.lm+8;.lit
    DATAEND
    ENDFILE n
    ERROR
NO  ESCAPE
    FILE n
    MATH
    TRANSFORM
.end literal;.lm-8;
.S.tp10;Semantics:
.p;The NO statement cancels the specified ON condition trap.
See the ON condition statement.
.tp10.s2;^&ON DIV BY ZER\&
.x <ON <DIV <BY <ZER
.s;Syntax:
.s.i8;ON DIV BY ZER [NO] ERROR
.s;Semantics:
.s;Division by zero is normally an error condition in TYMBASIC.
However, if the user executes ON#DIV#BY#ZER#NO#ERROR, division by zero
will give a zero result (unless reset by ON#DIV#BY#ZER#ERROR), throughout
every module in the program.
.tp10;.s2;<>^&ON-GOTO\&
.s;Syntax:
.s;.nf;
.i8;ON n  GOTO  ln1,...lnK
.s;Semantics:
.x <GOTO> ON
.f;.p;The ON-GOTO statement transfers control to
the line having the nth line number given in the line
number list.
An error condition occurs if n is less than 1 or greater
than K.
For example:
.s.i8;10 NUMA=2, NUMB=3
.i8;20 ON NUMA*NUMB GO TO 110,120,130,140,150,160,170
.s;Statement 20 transfers control to line 160.
.s2.tp10;<>^&ON-GOSUB\&
.page size -3
.S2;Syntax:
.p;.i8; ON n GOSUB  ln1,...lnK
.s;Semantics:
.p;The ON-GOSUB statement transfers control to the subroutine
.x control transfer
.x subroutines
starting at the nth line number given in the line number list.
An error condition occurs if n is less than 1 or greater than K.
See the GOSUB statement.
For example:
.s;.nf;.i8;100 ON ABS(B3) GOSUB 500,530,595,700
.TP 10;.s2;^&ON-CONDITION\&
.x <ON condition processing
.S;Syntax:
.s;.lm+8;.lit
    ENDFILE n
    FILE n
    DATAEND
ON  ESCAPE         GOTO  ln
    MATH
    TRANSFORM
    ERROR
.end lit;.lm-8;
.x <ENDFILE
.x <FILE
.x <DATAEND
.x <ESCAPE
.x <MATH
.x <TRANSFORM
.x <ERROR
.f
.s;Semantics:
.p;The ON condition statements enable the user's program
to automatically regain control when an error condition is generated
during program execution.
When an error occurs, TYMBASIC causes control to be transferred to the
statement specified in the ON condition statement.
Thereafter, the program may analyze the error condition, using the
system-defined functions ERRCD, ERRLN, and ERRFL, and may
choose to resume execution at the beginning of the statement
that caused the error.
.p;Execution of an ON condition  statement specifies a line number to which
control will be transferred
when the specified condition occurs, as
follows:
.TP 11;.s
.lm+3;.NF;CONDITION          Meaning
.s
.lit
DATAEND         End of DATA values is encountered
ENDFILE n       End of input file n is encountered
ERROR           An error occurs other than those specifically
                selected
ESCAPE          Escape is typed
FILE n          File error occurs on file n
MATH            Mathematical error is encountered
TRANSFORM       Numeric conversion or formatting error occurs
.end lit;
.lm-3;.s;.F;The ON condition thus armed remains active until either another ON or
a NO for that condition is executed.
Note that execution of an ON statement itself will NOT cause a transfer to
another line to occur, but only establishes to which statement control will be
transferred if an error condition DOES occur in the future.
.S;When a trap (transfer) is taken for an armed condition, the error
message associated with the condition will
not be printed, but the system-defined functions ERRCD, ERRLIN, and ERRFL
are set, and the associated message may be found by reference to  ERRMSG(ERRCD).
.s;For example:
.s;.i8;500 ON FILE 3  GO TO 900
.s;.f;specifies that control is to transfer to line number
900 if a file error occurs on file unit number 3, such as opening
file 3 for input when the file does not exist.
The interrupted statement is remembered in the Resume Stack so that
execution can later be resumed at the interrupted statement.
For example, suppose that a FILE error on unit number 3 occurs in line 5050 and
control is transferred to line 900.
It is possible that before the program is able to execute a RESUME statement,
a TRANSFORM error occurs in line 930, and control is transferred to line 600
(because of a previously executed ON TRANSFORM GOTO 600 statement).
If a RESUME is then executed, control will return to line 930.
If another RESUME is executed, control will finally return to line 5050.
.p.tp14;The n following ENDFILE and FILE may be any integer from
-9 to 20, with these meanings:
.lm+8;.nf;.p; 1-20      TBA file unit numbers
 0         no file
-1         Command file
-2         TOUT file
-3         DATA/READ
-4         COPY FROM file
-5         COPY TO file
-6         RENAME FROM file
-7         RENAME TO file
-8         REMOVE file
-9         miscellaneous user file
.lm-8;.p;.f;FILE(-4), for example, will trap file errors on the COPY source
.x <ON condition processing
file.
Note that of the negative values only -3 is meaningful for ENDFILE,
and means exactly the same as DATAEND.
.p;If an end-of-file condition occurs in a file for which the
ENDFILE condition has not been set but the FILE condition has,
then the FILE condition branch is taken.
If any other condition occurs for which that ON-condition has
not been set but ERROR has, then the ERROR condition branch
is taken.
.x <ON <ERROR
.x <ON <FILE
.x <ON <ERROR
.p;When an escape occurs and ON ESCAPE has been executed,
then escapes are disabled until the second statement after another ON ESCAPE or a
RESUME is executed.
.x <on <endfile
.x condition trap
.x trapping error conditions
.p;Onced armed by an ON condition statement, a particular error condition
will cause control to be transferred regardless of where the
error occurred.
Specifically, an error in one module may cause control to pass into another
module.
.TP 20;.s2;^&OPEN\&
.x <SEQUENTIAL
.x <open> binary
.x <open> input
.x <open> io
.x <Open> output
.x <Open> Random
.x <Open> SEQUENTIAL
.x <Open> Symbolic
.s;Syntax:
.lm+4;.lit
                                      INPUT
          ,   SYMBOLIC  SEQUENTIAL    OUTPUT  ,        n2
OPEN s1  FOR   BINARY   RANDOM[(n1)]    IO    AS FILE  *

    [WITH PROTECTION s2] [,ERR [GOTO] ln]
.end lit;.lm-4
.x files> opening
.x <WITH <PROTECTION
.s;Semantics:
.p;The OPEN statement opens the file with file nomen specified by the string
 expression s1 for subsequent input or output.
.x file nomen
.x input> file
.x output> file
If the terminal is specified (see Sec.#4.3), then input or output through
file unit number n2 is equivalent to normal terminal I/O.
.x <TERM > in <OPEN statement
.x files> opening
.x files> opening
.x opening files
As many as 20 files, not including the terminal, may be open
simultaneously.  See also the Files discussion, Section 11.
.s;If specified, n1 represents a fixed record length,
in words for binary files, in characters for symbolic files;
it is an integer expression.
If n1 is omitted, the random file is of variable length records.
.p;n2 is the file unit number.
An * in that field will cause the file to be opened as a
.x asterisks> in <OPEN statement
.x *> in <OPEN statement
command file.
The file unit number should be an integer from 1 through 20, or
one of the following special cases:
.lm+8;.nf;.p; 0     valid only in
       OPEN "TERM", BINARY INPUT, 0
        (enables eight-level input)
.s;
-1     Command file (same as *)
-2     TOUT file (note: closes current TOUT file if any)
.x <TOUT files
.lm-8;
.s;.f;s2, the second string expression, specifies three protection codes on the file:
the first applies to the user himself, the second to users in
his account, and the last to all other users.
The codes are shown below.
.TP 15;.s;.nf;.lit
        Protection               Permits
           Code


           ALL         Renaming or deleting this file
           CP          Changing protection of this file
           UPD         Changing contents of this file
           AP          Appending to this file
           RD          Reading this file
           RUN         Running the program on this file
           LK          Looking at directory information about
                       this file
           NO          No knowledge of this file
           *           Forces the XEXEC default protection code
.end literal
.x <ALL> protection code
.x <CP> protection code
.x <UPD> protection code
.x <AP> protection code
.x <RD> protection code
.x <RUN> protection code
.x <LK> protection code
.x <NO> protection code
.x *> protection code
.x asterisks> protection code
.f;.s;If protection is not specified  or if the protection
string is null (length = 0), then the protection for a new file will
be the XEXEC default, for a previously existing file it will remain
as the previous protection.
.s;If the user specifies *, the file will get the XEXEC default protection.
.s;The WITH PROTECTION clause is ignored for INPUT
files.
.p;For example:
.s;.i8;10 OPEN...WITH PROTECTION "ALL RUN NO"
.s;The line number in the ERR clause specifies the line to which
control will be transferred on file errors on file n2.
.x <ERR
It is exactly equivalent to executing
.s;.i8;ON FILE n  GOTO ln
.s;and thus sets an ON condition trap not limited in scope
to the OPEN statement.
.tp 10;
.s;The short form of the OPEN statement is:
.s;.lit
                    IO
                    INPUT
                    OUTPUT
                    RANDIO[(n1)]
           n2       RANDIN[(n1)]      SYMBOLIC
    OPEN ( *  ,s1,  RANDOUT[(n1)]   ,  BINARY
.end literal
.s;.i4;[, PROTECTION=s2][, ERR=ln])
.s;The table below summarizes the default assumptions with
OPEN.
.s2;.nf;Default             Assumed when:
.s;.nf
.lm+4;
SYMBOLIC               BINARY not specified
.s
.x <symbolic
.x <sequential
SEQUENTIAL             RANDOM, RANDIO, RANDIN, or
                       RANDOUT not specified.
.s;
Variable length        (n1) not specified
records on
random file
.x <protection
.x input> terminal
.x output> terminal
.x terminal input
.x terminal output
.s
System default (new    PROTECTION is not specified
file) or previous
protection retained
.s
Terminal input         The string expression for
or output              file evaluates to "TERMINAL".
.lm-4.f
.p;A file may be opened on more than 1 file unit number -- for example,
if reading from one and writing on another.
The terminal may be opened on more than 1 file unit number; however,
both input and output are always valid through these unit numbers.
.tp10;.s2;<>^&PAUSE\&
.s;Syntax:
.s;.i8;PAUSE [expression]
.x interrupting execution
.p;The PAUSE statement interrupts execution, such that the
.x execution> interruption of
GO or STEP commands can resume it, and prints the specified
expression or PAUSE IN line number.
For example:
.s.i8;100 PAUSE "TYPE GO TO CONTINUE"
.p;The continue point will be the point immediately after the PAUSE
(see Sec.#8.5).
.s2;<>^&PIF\&   (abbreviation for PRINT IN FORM)
.s2;<>^&PIM\&   (abbreviation for PRINT IN IMAGE)
.s2.tp10;<^&PRINT\&
.x <PRINT
.s;Syntax:
.s;
.lit
                        : *             : *            * : *
                        ;               ;                ;
PRINT [ON n1] [AT n2]:  ,  expression1  ,  expression2   ,
.end lit
.p;In the form, an asterisk (*) after a square bracket means the
component may appear zero or more times; an asterisk after a
brace means the component may appear one or more times.
.s;Semantics:
.f;.p;The PRINT statement prints the specified value(s) in free-form at the
.x terminal output
.x output> terminal
terminal or a file, spacing according to the given punctuation
(see Sec.#12.3).
Array and scalar values may be printed in any combination.
.x terminal output> <PRINT
.x <PRINT> terminal output
.s;An example:
.s;.NF;.I8;<>PRINT "H":"I";"TYM",DATE
.i8;HI TYM         77/07/19  18:53
.f;.s;Note that TYMBASIC requires some form of separator in
multiple-expression print lists.
Thus, the following will generate the error message "Invalid print
or write statement":
.S;.I8;PRINT "XYZ="A
.s;.F;
Trailing spaces are suppressed
.x trailing spaces
.x terminal output> suppression of trailing spaces
on terminal output; trailing spaces are not suppressed with
file output.
.f;.s;The ON clause in a PRINT statement writes the specified expression
values on file n1, which must be open.
.x files
.x files> input
The AT clause applies only to random files and specifies the location
at which to begin writing values.
Examples:
.s;.nf;.i8;_>100 PRINT ON 3 AT 20:  SQRT(X); "HELLO"
.I8;_>150 PRINT ON J:X,Y,Z+A
.s2.tp10;PRINT IN FORM
.nf;^&PRINT IN IMAGE\&
.s;Syntax:
.p.i8;                           FORM
.i8;PRINT [[ON n1 [AT n2]][IN  IMAGE  s]:]expression list
.s;Semantics:
.s;.f;The IN FORM and IN IMAGE clauses specify formatting.
s is a string expression whose value is the format used in the conversion of
the output.
Use and examples of formatted output are supplied in
Section 12.
.s2.tp10;^&QUIT\&
.x <QUIT
.x interrupting execution
.s;Syntax:
.s;.i8;QUIT [expression]
.s;Semantics:
.p;The QUIT statement halts program execution and transfers
.x execution
.x <XEXEC
control to <>XEXEC after printing the specified expression or
QUIT IN line number.
For example:
.s;.nf;.i8;100 QUIT "EXIT FROM TYMBASIC"
.x files> closing
.tp 10;.s2;<>^&READ\&
.s;Syntax:
.s;.i8;READ input list
.s;Semantics:
.p;.f;The READ statement reads values from the ordered collection of
.x data input
.x input> data
DATA statements (the data block of the current module) into the specified variables.
If the end of the data block is encountered, a DATAEND error
.x <DATAEND
condition is generated.
The READ statement uses standard free-form input to read values from the
data block.
.x free-form> <READ statement
For example:
.s;.nf;.lm+8;10 READ A
20 READ B,C,D
30 DATA 10,20,30,40
.s;.LM-8;.F;assigns 10 to A, 20 to B, 30 to C, and 40 to D.
.s2;<>^&REAL\&
.S;Syntax:
.s;.lm+8;.lit
REAL  variable/dimension list
.end lit;.lm-8
.s;Semantics:
.p;The REAL statement declares real variables and dimensions real
array variables (see also Sec.#5.3).
For example:
.s;.i8;_>20 REAL EST(100), XRATE
.tp10;.s2;<>^&REM\&
.s;Syntax:
.s;.lit
         !
        REM text
.end lit
.x text
.s;Semantics:
.p;.f;The REM statement inserts comments in the program (which have
.x comments
.x !
no effect on program execution) that can be used for documenting
a program.
The _! delimits all text remaining on the line as a comment.
For example:
.s;.nf;.lm+8;_>10 !LINE 10 IS NOT EXECUTED
_>20 REM NEITHER IS LINE 20
_>30 PRINT S !S IS SALES VOLUME FOR 1973
.LM-8.F
.p;If REM is entered as a direct statement (with no leading line number),
no action is taken.
.tp10;.S2;<>^&REMOVE\&
.S;Syntax:
.s;.i8;REMOVE s
.s;Semantics:
.p;The REMOVE statement deletes the file with the file nomen specified by s.
For example:
.x closing files
.s;.i8;_>100 REMOVE "FILEX"
.S;.f;It is not an error if the file is not found.
.s2;<>^&RENAME\&
.s;Syntax:
.s;.i8;RENAME s1 AS s2
.s;Semantics:
.p;The RENAME statement changes the name of the file with file nomen specified
by s1 to the new
name s2.
.x file names
For example:
.s;.i8;_>100 RENAME "FILEX" AS "FILEY"
.s;.f;The confirmation procedure is operative on the second file.
For example, if FILEY already exists, then it will be deleted and replaced
by FILEX only if an appropriate confirmation keyword was given or the
user answers affirmatively to the question "Existing file, Ok?".
.x file nomen
.p;Note that renaming a file can be used to move the file from one
directory to another without actually copying its contents.
.s2;<>^&RESTORE\&
.s;Syntax:
.s;.i8;RESTORE
.s;Semantics:
.p;The RESTORE statement causes the next READ statement to assign
values beginning with the first value in the data block of the current module.
For example:
.s;.nf;.lm+8;_>10 READ A,B
_>20 RESTORE
_>30 READ C,D,E,F
_>40 DATA 10,20,30,40
.lm-8
.s;.f;assigns 10 to A, 20 to B, 10 to C, 20 to D, 30 to E, and 40 to F.
.s.tp10;<>^&RESUME\&
.s;Syntax:
.s;.i8;RESUME [ln]
.x resuming execution
.x execution> resuming
.x execution
.s;Semantics:
.p;The RESUME statement resumes execution at the beginning of the
statement that last caused a specified user-trapped error condition
(or at the statement specified by the line number), if the condition
hasn't already been cleared by a RESUME.
(Every error condition that is trapped by the user creates an
entry on the RESUME stack; execution of a RESUME statement
takes the top entry off the stack, branching then to its
associated statement.)
See also the ON condition statement.
.tp10;.s2;<>^&RETURN\&
.s;Syntax:
.s;.i8;<>RETURN
.s;Semantics:
.p;.f;The RETURN statement transfers control to the point immediately
after the most recently executed GOSUB statement.
For example, if the GOSUB subroutine was called by
.s.i8;10 GOSUB 100 UNTIL I=45
.s;then the RETURN statement
.s.i8;160 RETURN
.s;would transfer control back to the UNTIL test, which may or may not
cause the GOSUB to be executed once again.
.x control transfer
.x <Gosub> returns from
.s2.tp20;<>^&SIGNIFICANCE\&
.s;Syntax:
.s;.i8;SIGNIFICANCE n
.s;Semantics:
.p;SIGNIFICANCE causes all free-form floating point output (types real and double)
.x output> significance
.x free-form> numeric output
.x output> free-form numeric
to write up to n significant digits, throughout every module in the program.
The value of n may range from 1 through 18.
For example, the statements
.tp 10;.s;.nf;.lm+8;_>10 SIGNIFICANCE 6
_>20 PRINT PI
_>30 SIGNIFICANCE 3
_>40 PRINT PI
.s;.lm-8;print:
.s;.i8;3.14159
.i8;3.14
.s;.f;Regardless of SIGNIFICANCE, no more than seven digits of a
(single precision) real number will be written.
.s2.tp10;<>^&STOP\&
.s;Syntax:
.s;.i8;STOP [expression]
.s;Semantics:
.p;The STOP statement terminates program execution, closes all
files (except for command and TOUT files), and prints the specified expression or STOP IN line
number.
.x closing files
For example:
.x termination> execution
.x execution> termination of
.x execution
.x files
.s;.i8;_>100 STOP "JOB DONE"
.tp20;.f;.s2;<>STRING
.br;^&TEXT\&
.s;Syntax:
.s;.i8; STRING
.nf;.i8; TEXT     variable/dimension list
.s;Semantics:
.p;.f;The STRING statement declares string
variables, dimensions string array variables, and specifies
desired maximum string lengths (see also Sec.#5.3).
The word TEXT is equivalent to STRING and is provided for compatibility
with other BASICs.
For example:
.x strings> values
.s;.nf;.i8;10 STRING NAME(300):20,ADDR:35
.s;.f;If string length is omitted, the maximum length defaults to 4095 characters.
As strings are of variable length, and use only the storage they
require, setting a maximum length is for protection only.
When a string value is stored into a string variable,
its length is truncated to the maximum length of the variable if necessary.
.s2;<>^&WAIT\&
.s;Syntax:
.s;.i8;WAIT n
.s;Semantics:
.p;The WAIT statement causes TYMBASIC to pause for n
seconds before resuming program execution.
If n is negative, TYMBASIC waits until the terminal output
buffer is empty.
For example:
.x execution
.x execution> pause
.s;.i8;_>100 WAIT 10
.tp10;.s2;<>^&WRITE\&
.p;The WRITE statement is equivalent to the PRINT statement, and is provided
for compatibility with other BASICs.
.subtitle 1 January 1978                                               Sec. 9.2
.page;^&9.2  STATEMENT MODIFIERS\&
.x statement modifiers
.p;Most TYMBASIC statements can be modified by one
of six clauses, described below.
The modifiers follow the statement body, delineated by at least
one space.
Modifiers may be followed by modifiers, in which case they
are executed from right to left.
.p;The statements DATA, DEF, ELSE, ENDF, ENDIF, NEXT, and ORIF may not be
modified.
The IF statement itself may not be modified but a THEN
or ELSE clause not consisting of another IF may be.
.s2;^&FOR Modifier\&
.x <FOR> modifier
.p;Syntax:
.lit
                                       TO n3
FOR iteration variable = n1 [ [BY n2]  UNTIL  logical expression ]
                                       WHILE
.end lit
.s2;Semantics:
.p;.f;A statement followed by a FOR modifier is executed
until the FOR loop is satisfied.
(There is an implied NEXT at the end of the statement.)
See the FOR statement description.
For example:
.p;.i8;PRINT SUBTOT(I) FOR I = 2 BY 2 TO 16
.p;The first eight even-numbered elements of SUBTOT are printed.
This statement is equivalent to:
.lm+8.nf.s
FOR I = 2 BY 2 TO 16
  PRINT SUBTOT(I)
NEXT I
.f.lm-8
.tp10;.s2;^&IF Modifier\&
.page size +2
.x <if modifier
.s;Syntax:
.p;.i8;IF logical expression
.p;Semantics:
.p;A statement followed by an IF modifier is executed if the logical
expression is TRUE, otherwise execution passes to the next statement.
For example:
.p;.i8;PAUSE IF TROUBLE
.p;If the variable TROUBLE is TRUE the PAUSE statement will be
executed.
.tp 10
.s2;^&UNLESS Modifier\&
.page size -2
.x <unless modifier
.s;Syntax:
.p;.i8;UNLESS logical expression
.p;Semantics:
.p;A statement followed by an UNLESS modifier is executed if the
logical expression is FALSE, otherwise execution passes to
the next statement.
For example:
.p;.i8;CALL ASUB UNLESS X=0
.p;The subroutine ASUB will be called whenever this statement
is executed and X is not equal to zero.
.s2;^&UNTIL Modifier\&
.x <until modifier
.s;Syntax:
.p;.i8;UNTIL logical expression
.p;Semantics:
.p;The UNTIL modifier causes the statement to be executed
repeatedly as long as the logical expression is FALSE.
When it is TRUE execution passes to the next statement.
For example:
.p;.i8;LET I = I+1 UNTIL X(I)<=0
.p;Note that the UNTIL test is made prior to execution of the statement body.
.tp 10;.s2;^&WHERE Modifier\&
.page size +4
.x <where modifier
.s;Syntax:
.p;.i8;WHERE assignment list
.p;Semantics:
.p;The WHERE modifier causes the statement to be executed after
the assignments in the modifier have been executed.
The assignment list may contain simple or compound assignments or
exchanges in any combination (see the LET statement).
For example:
.p;.i8;GOSUB 2000 WHERE A=15
.s.i8;CALL FUNC(I,J,K) WHERE I,J=1, K=2, L==M
.tp 10;.s2;^&WHILE Modifier\&
.page size -4
.x <while modifier
.x <while modifier
.p;Syntax:
.p;.i8;WHILE logical expression
.p;Semantics:
.p;The WHILE modifier causes the statement to be executed
repeatedly as long as the logical expression is TRUE.
When the expression is FALSE execution passes to the
next statement.
For example:
.s.i8;TOKEN = GET.TOKEN(LINE) WHILE TOKEN _# '"'
.tp 10;.s2;^&Modifier Range\&
.x modifier range
.x modifier range
.s;Parts of some statements are outside the range of a
statement modifier: when an input or output
statement is modified, the calculation of any file unit number,
format, or location and the setting of the location  in the statement is not within the
modifier's range.
The modifier does control the printing of any data.
For example:
.s;.i8;_>10 I=9
.i8;_>20 PRINT ON I:SQRT(I), I WHERE I=5
.p;is equivalent to:
.p;.i8;_>10 PRINT ON 9: SQRT(5),5
.p;Conversely, the input or output list of the statement includes the
modifiers.
Thus a Control B from the terminal on input will restart
.x Control ^B
the entire input list including the modifiers.
.p;Note that even if the modifier causes nothing to be printed, the file
unit number and format are calculated and the file location is changed
if these fields appear.
For example:
.s.i8;_>10 PRINT ON N AT F1(N) IN FORM F2$(N): F3(I) IF I_>=0
.p;If I is less than zero, F3 will not be called and no data is printed on file N.
However, the two functions F1 and F2$ will be called and the location on file
N will be set to the value returned by F1.

.Flag capitalize
.Flag underline
.flag index
.f .LM 0 .rm 69 .break .page .nj .p0
.title TYMBASIC REFERENCE MANUAL              COMMANDS
.subtitle 1 January 1978                                               Sec. 10.0
.ft

.S2;.C;SECTION 10. COMMANDS
.S3;This section provides the syntax, semantics, and an
example of each TYMBASIC command.
The commands are listed in alphabetical order.
.p;Many commands operate on or over a range of lines in the workspace,
specified by the initial and terminating lines, separated by
a colon or a dash.
This is shown in the syntax by:
.nf;                                       :
.i8;line range     ###Syntax: ln1[ - ln2]
.f
.p;A warning message is printed for any line range containing no lines.
.p;A line range list is one or more line ranges, with
comma separators.
For example:
.s;.i8;100:150, 210:340, 500
.s;The word ALL may be given anywhere a line range list is valid to 
specify all the lines in the workspace.
.x <ALL> line range list
.x line range
.x line range list
.s2;><BREAK
.br;^&NO BREAK\&
.s2;Syntax:
.s.i8;BREAK line range list
.i8;NO BREAK [line range list]
.s;Semantics:
.p;Break specifies line number ranges within the current workspace for breakpoints.
.x breakpoints
Successive BREAK commands are cumulative.
During execution, control returns to the Command/Statement phase when
any of the breakpoints are encountered; the action is
analogous to a PAUSE (see also Sec.#8.5).
.x interrupting execution
.x execution> interruption of
For example:
.NF;.p;.lm+8;_>BREAK 10,100-200
_>RUN
.S
BREAK AT 10
_>TRACE CNTR
_>GO
.f;.lm-8;.s;The NO BREAK command removes all or specified
breakpoints.
Breakpoints are also erased when a RENUMBER, or GET command is entered.
.tp10;.s2;<>^&CDE\&
.S;Syntax:
.s;.i8;CDE [line range]
.s;.f;Semantics:
.p;CDE prints a MACRO-like display of the code generated for the specified line or
line range in the workspace, or if no lines are specified, for all lines.
For example:
.s;.nf;.i8;_>CDE 10-100
.f;.S;As CDE forces a compilation of the entire workspace,
a relocatable file will be
generated, and any compilation diagnostics will be output.
.f;.s2;><DEBUG
.br;^&NO DEBUG\&
.s;Syntax:
.s;.i8;[NO] DEBUG
.x <NO <DEBUG
.x <DEBUG
.S;Semantics:
.p;The DEBUG command causes the workspace module (and all modules added to the
module list while the workspace state is DEBUG) to be compiled in the
DEBUG state.
.p;When the workspace is in the DEBUG state, the BREAK and TRACE commands are
.x <BREAK
.x <TRACE
operative on lines and variables defined in the workspace.
In addition, for array element accesses in any module compiled in the DEBUG
state, TYMBASIC checks each subscript against its bounds.
For modules compiled in the NO DEBUG state,
TYMBASIC only checks for array element addressing outside
the area allocated to the array.
.p;For every module compiled in the DEBUG state,
TYMBASIC checks every store into a variable and every execution of a
statement (so that BREAK and TRACE can work).
For these reasons, execution of a module in the DEBUG state is many times
slower than execution of the same module in the NO DEBUG state.
.x arrays> subscripts> bounds checking of
.p;The default state in TYMBASIC is NO DEBUG.
.s.tp10;^&DELETE\&
.x <DELETE
.s;Syntax:
.s.i8;DELETE##line range list
.s;Semantics:
.s;Deletes the specified lines from the workspace.
If all lines are deleted in the workspace, the workspace is automatically
unnamed.
An example is:
.p;.i8;_>DELETE 10, 20-50, 80
.s;The user may delete a single line by typing its line number
followed by a carriage return.
.x lines> deletion of
.x workspace> deletion of lines
.tp10;.s;.f;<>^&DO\&
.s;Syntax:
.s;.i8;DO file nomen
.s;Semantics:
.p;DO opens the specified command file and begins accepting
its TYMBASIC statements and commands.
The default extension for file nomen is .CMD.
.x default extension
See Command Files, Section 8.6.
.x command files> execution of
.s2;<>^&DLIST\&
.s;Syntax:
.s;.i8;DLIST  [line range list]
.s;Semantics:
.p;DLIST prints the workspace name and the current date and time before listing the
specified lines or all lines in the workspace.
.x listings
.x date> on listings
For example:
.s;.i8;_>DLIST 10, 100-200, 300
.s2.tp10;<>^&DUMP REFS\&
.x <DUMP REFS
.x cross reference;.x references
.s;Syntax:
.s;.i8;DUMP REFS [file nomen]
.s;Semantics:
.p;DUMP REFS stores on the specified file information needed to
create a cross-reference listing for the workspace module.
The file is in the format
expected by the XEXEC CROSS command and the file name is appended to the
CRE tempcore file.
For example:
.p;.i8;_>DUMP REFS CREFIL
.p;Default extension:  .CRF
.x default extension
.tp 10;.s2;<>^&ECHO and NO ECHO\&
.s;Syntax:
.s;.i8;[NO] ECHO
.s;Semantics:
.p;ECHO and NO ECHO determine whether command input characters,
prompts, and messages associated with command input
are to be echoed to the current TOUT destination.
See Section 8.6.
.p;The default is NO ECHO.
If the terminal is the command source, input is echoed, and
prompts and messages are printed there.
If a command file is open, prompts and input lines are not
printed unless ECHO has been specified.
.s2;<>^&EDIT\&
.s;Syntax:
.s;.i8;EDIT line range list
.i8;ln E
.s;Semantics:
.p;EDIT prints the specified lines one at a time and waits for
the user to edit each,
.x old line
allowing any of the Tymshare control characters (see Appendix C).
For example:
.p;.nf;.lm+8;_>EDIT 10
10 THERE IS A MUSTAKE
.p;.i-8;Note that
.p;_>100E
.p;.i-8;can be entered for
.p;_>EDIT 100
.x editing
.x lines> editing of
.lm-8
.p;The line number may modified, in which case a new line is entered
into the workspace, but the original line is not deleted.
.tp10.s2;<>^&ENTER\&
.s;Syntax:
.s;.i8;ENTER  [ln]  [BY i]
.s;Semantics:
.p;.f;ENTER automatically supplies line numbers as the user enters
statements into the workspace.  The numbers start with the specified line
number (default is 100), and are incremented by i.
.x line numbers
If the BY clause is omitted, the increment is the last specified
increment, or 10 if no previous ENTER increment was given.
For example:
.p;.i8;_>ENTER 50 BY 5
.p;ENTER automatically terminates if an attempt is made to
interleave or overwrite lines.  The user terminates data
entry by typing an _& alone on a line.
During statement entry, the old line image is the last statement entered.
.x old line
.p;Statements may also be entered into the workspace by typing the line
number followed by the statement.
In this case, the statement may replace another statement.
For example,
.s.i8;_>200 A(I) = FUNC(J)
.page;<>^&GET\&
.s;Syntax:
.s;.i8;GET  file nomen
.s;Semantics:
.p;GET moves TYMBASIC statements stored on the specified file into
the user's workspace, checks each statement for valid syntax,
and names the workspace with the file nomen (less the confirmation keyword).
For example:
.p;.i8;_>GET PROG2
.p;TBA is the default extension for the file nomen.
.x default extension
.x programs> workspace (see ^Workspace)
.x workspace> moving program into
If the file cannot be found or accessed, the command is aborted.
.p;If the current workspace is not empty and has been modified since
the last GET or SAVE operation, TYMBASIC gives the user an opportunity
to save the workspace module by asking:
.s.i8;Save workspace?
.s;The user may answer Y[ES], N[O], or AS file nomen.
If the answer is Y[ES] and the workspace is unnamed, TYMBASIC
prompts for a file nomen; if the answer is AS file nomen the file nomen
becomes the file name whether the workspace had been previously named or not.
In either case the effects are as if a SAVE command had been issued.
If the answer is N[O] the recent modifications
are lost.
After processing these options, the actual GET begins, as described
below the NOTE.
.lm+8.s;NOTE: TYMBASIC will warn the user if a N[O] would result
in a program modification. When 1) a program has been loaded and it still
contains valid data (see Sec.#8.4) and 2) the current workspace
is on the module list, then a GET command without saving
the workspace would result in a program modification, since the
workspace previously loaded into the program would no longer exist.
In this case TYMBASIC issues a warning with the prompt:
.s.lm+4.nf
Answering NO will destroy valid data
Save workspace?
.lm-4.f
.p;If the module list is not empty then GET is
always a program modification.
.lm-8
.p;If the file nomen specified in the GET command is found on the module list, then
the workspace debug state is set from the debug state of that module
on the module list.
TYMBASIC informs the user if the workspace debug state changes
in this manner.
.p;The file must be a symbolic file containing only indirect statements:
that is, each line must begin with a line number and contain a
statement that is syntactically valid as an indirect statement.
Any other lines will be diagnosed and rejected.
The line numbers need not be in ascending order and may interleave
with or overwrite earlier lines.
.p;If an input line is preceeded by a form feed (control L) then that line
will get a Top of Form mark (see the TOF command).
If an input line contains a line feed (control J) then it is
interpreted as a line continuation.
.x Control ^L
.x Control ^J
.x <TOF
.x line feeds> in input lines
.x form feed> in input lines
Any other control characters found within the line
are removed and a warning message is printed.
EDIT10-type line numbers are stripped from input lines.
.x control characters> in input lines
.x line numbers> EDIT10
.tp10;.S2;<>^&GO\&
.S;Syntax:
.s;.i8;GO
.s;Semantics:
.p;GO starts program execution at the continue point.
(The continue point is defined in Section 8.5).
.x programs> execution
Variables retain their current values.
GO is valid only after the program has been initialized and
a continue point has been defined.
.s2;<^&INITIALIZE\&
.x <INITIALIZE
.x <INIT
.s;Syntax:
.s;.i8;INIT[IALIZE]  [file nomen]
.s;Semantics:
.p;INIT initializes the Run phase environment but does not begin executing the
program; if necessary, a GET and/or compilation occurs.
See Section 8.4 for a description of initialization.
.S3;.tp10;<>LIBRARY
.br;^&NO LIBRARY\&
.s;Syntax:
.s;.i8;[NO]   LIBRARY
.i13; LIBRARIES #####file nomen list
.s;Semantics:
.s;The LIBRARY command adds the specified files to the
user's library list in the order specified; the NO LIBRARY command deletes specified files
from the library list maintaining relative order.
A .REL extension is inserted if no extension is supplied.
LIBRARY and NO LIBRARY are both program modifications.
.p;A given file nomen may appear more than once on the library list,
and when removed, all instances of that file  nomen are removed at once.
A warning is printed for any file nomen that is illegal (or not
found on the library list in NO LIBRARY); however, processing
of the file nomen list continues to its end.
.x <REL file
.s2.tp10;^&LIST\&
.x <LIST
.s;Syntax:
.s;.i8;LIST [line range list]
.s;Semantics:
.p;LIST lists the specified lines or all lines (the default) in the workspace.
Output is to the  current TOUT destination, usually the terminal.
For example:
.s;.i8;_>LIST 10-50, 300
.s2.tp8;^&LIST BREAK\&
.s;Syntax:
.s.i8;LIST BREAK
.s;Semantics:
.p;The LIST BREAK command lists the current breakpoints.
.s2.tp8;^&LIST LIBRARY\&
.x <LIST <LIBRARY
.s;Syntax:
.s.i8;LIST##LIBRARY
.i8;######LIBRARIES
.x <LIST <LIBRARY
.s;Semantics:
.p;The LIST LIBRARY command lists the libraries in the library list if any.
The files are listed in the order in which they will be searched.
.s2.tp8;^&LIST MODULE\&
.s;Syntax:
.s.i8;LIST MODULE[S]
.s;Semantics:
.p;The modules in the user's modules list are printed in the order in which
they will be loaded.
Included in the module listing is an indication of the debug state
of each module and notations for the workspace and startpoint modules.
If the module list is empty TYMBASIC prints the warning
.s.i8;Module list empty
.x <LIST <MODULE
.x module list
.x modules> startpoint
.x workspace> module
.s2.tp8;^&LIST TRACE\&
.s;Syntax:
.s.i8;LIST TRACE
.s;Semantics:
.p;The LIST TRACE command indicates which lines will be traced and
which variables, when stored into, will print the line number and value
of the variable.
.x <LIST <TRACE
.s2.tp8;^&LOG\&
.x <LOG
.s;Syntax:
.s.i8;LOG
.s;Semantics:
.p;LOG closes all files and ends the user's entire session at the terminal.
Logout information is printed.
.s2;<>^&MAP\&
.s;Syntax:
.s;.i8;MAP
.s;Semantics:
.s;MAP prints information about the user's program size and
its storage allocation.
The program must have been initialized.
The output format is:
.s;.lit;
      LOAD               LOSEG    HISEG
  MODULE NAME           ADDRESS  ADDRESS

   SYSTEM               address  address

     name               address  address
      .
      .
      .

   SYSTEM               address  address

 END PROGRAM:           address  address


.end lit
.p;.f;The module name SYSTEM indicates parts of the TYMBASIC system.
.tp 10;.s2;><^&MERGE\&
.s;Syntax:
.s;.i8;MERGE file nomen
.s;Semantics:
.x listings
.p;This command merges TYMBASIC statements stored on the
specified file into the workspace.
As with the GET command, the file must be symbolic and contain
only indirect statements; lines need not be in order and may
interleave with or overwrite existing lines.
For example:
.p;.i8;_>MERGE PROG2
.p; .TBA is the default extension.
.x default extension
MERGE does not change the workspace name.
.x workspace> name
.s2;><^&MODIFY\&
.s;Syntax:
.s;.i8;MOD[IFY] [line range list]
.i8;ln M
.s;Semantics:
.p;MODIFY is identical to the EDIT command above, except that it
does not print the line before editing.
.x editing
.x lines> editing of
Similarly,
.p;.i8;_>3M#################is an alternative to
.i8;_>MOD 3
.tp10;.s2;><MODULE
.br;^&NO MODULE\&
.x <NO <DEBUG
.s;Syntax:
.s;.i8;[NO] MODULE[S] file nomen list
.s;Semantics:
.s;The MODULE command adds the specified files to the
module list in the given order; the NO MODULE command removes the specified
files from the list.
When a module is added to the module list, its debug state is determined
from the current debug state of the workspace.
The default extension for the file nomens is .TBA#.
.p;Every module must have a unique file name, regardless of user name
and extension, since each load module name must be unique (and also
to avoid conflicts when creating relocatable modules).
.x modules> name
The MODULE command checks for name duplication and informs the user
of conflict resolutions.
For example:
.s;.i8;_>MODULE JKL, (SAM)XYZ, abc.abc
.p;adds three modules to the module list, and if followed by
.p;.i8;_>MODULE (JOE)XYZ, abc.def
.i8;Replacing (SAM)XYZ, ABC.ABC
.p;two are replaced because their file names are identical.
This replacement may alter the order of the module list and therefore
constitutes a program modification.
.p;A warning message is printed for any file nomen that is illegal;
however, processing of the file nomen list continues to its end.
.p;For the NO MODULE command, modules having the same file name as the
specified file nomens (regardless of user name and extension) are removed
from the module list if found.
A message is printed for each file nomen that indicates what
module was removed from the list, or that no entry can be found with
the given name.
.p;Adding or deleting a module is always a program modification.
.s2;<>^&PMC\&
.s;Syntax:
.s;.i8;PMC  line range list
.s;Semantics:
.p;PMC prints the intermediate code generated by the parser for
the specified lines or all lines.
.x parser
.x intermediate code
This command is for the use of TYMBASIC system analysis.
.s2.tp10;^&QUIT\&
.x <QUIT
.s;Syntax:
.s.i8;QUIT
.s;Semantics:
.p;QUIT closes all files and tranfers control to XEXEC.
.s2.tp13;<>^&RENUMBER\&
.s;Syntax:
.nf;.s;
                                  TO
                    [[FROM] ln2[  -  ln3]] ADD[-]i
                                  :
                                          TO         BY
        REN[UMBER]  [[AS] ln1][FROM ln2[  -  ln3]][  INC  i]
                                          :
                                  TO
                    [ln1][,[ln2[  -   ln3]][,[i]]]
                                  :
.x lines> renumbering
.s;Semantics:
.f;.p;This command renumbers lines in the
user's workspace.
.f;The renumbering is as follows:  ln2 is the old number of the
line in the program where renumbering is to begin, ln1 is the first
new line number, and i is the increment to be used in assigning
the new line numbers.
The alternate form (RENUMBER ln ADD i) renumbers from old line
number 1n to the end of the program by adding i to every line
number.
(In the ADD clause i may be negative).
Renumbering proceeds through ln3.
Examples:
.page size +2
.s.nf.lm+8.tp6;_>LIST
.s
  3 INPUT A
  7 GO TO 200 IF A=0
 42 PRINT 1/A
 43 GO TO 3
200 STOP
.S;_>RENUMBER 10,3,20
.S;_>LIST
.S;10 INPUT A
30 GO TO 90 IF A=0
50 PRINT 1/A
70 GO TO 10
90 STOP
.page size -2
.p;.f;.LM-8;Note that the references to line numbers within
statements in the workspace are also renumbered to correspond properly
to the new line numbers.
.s;Renumber will never delete or interleave lines, but it
can be used to move lines.
.tp10;.s;Default values are:
.s;.lm+8;.nf;ln1   100
ln2     0
ln3    99999
 i     10
.lm-8;
.s2.tp10;<>^&RUN\&
.s;Syntax:
.s;.i8;RUN  [file nomen]
.s;Semantics:
.f;.p;RUN loads, initializes and executes the program.
.x modules> startpoint
If a file is specified, RUN first GETs the file.
See Execution, Section 8.
For example:
.s;.i8;_>RUN FILEX
.s2.tp10;><^&SAVE\&
.page size +2
.x workspace> saving
.s;Syntax:
.s;.nf;.i8;SAVE  [file nomen]  [line range list]
.s;Semantics:
.f;.p;SAVE stores the specified lines or the entire workspace module
on a symbolic file with the given file nomen.
The default extension is .TBA#.
An error message is printed if the workspace is empty.
.s;If no file nomen is specified, then the user name, if any, is deleted from
the workspace name, and the workspace name is then used.
.x workspace> name
.x storing
.s;If, however, a file nomen is given and no line range list is given
(thus specifying the entire workspace module) then the file nomen
(less the confirmation keyword, if any) becomes the workspace name.
An example is:
.s;.i8;_>SAVE FOOBAR 19, 30-48, 160
.page size -2
.s2.tp10;<>^&SAVE BINARY\&
.s;Syntax:
.s;.i8;SAVE BINARY  [file nomen]
.s;Semantics:
.s;SAVE BINARY stores the user's program as
an executable file.
If no file nomen is specified, then the workspace name is used, less the
user name if any (it is an error if the workspace is unnamed in this
case).
If a file nomen is given and specifies an extension other than .SHR,
the error message "Illegal extension" is printed and the command is aborted.
.x <SHR file
Otherwise, an executable file with extension .SHR is created.
Confirmation applies to the .SHR file, not the .LOW file
(which will also be created if the user has other-language
.x modules> other-language
modules that contain program or data in the low segment).
.p;If the workspace or any module in the module list is in the 
DEBUG state, the user is asked:
.s.i8;Execution of program in DEBUG mode more expensive, proceed?
.s;A N[O] response will abort the command.
.p;After successful completion of a SAVE BINARY command, no continue point
is established, and the program contains no valid data.
.x programs> saving
.x programs> sharable
.x programs> binary
.x programs> <GO files
.x storing
.x executable file
.x <GO files
.p;An example is
.p;.i8;_>SAVE BINARY CTAB
.p;which creates the executable file CTAB.SHR.
.s2;<>^&START\&
.s;Syntax:
.s;.i8;START
.s;Semantics:
.p;START causes the program to re-execute from its beginning,
retaining current variable values.
Files are not affected.  This command is valid only when the
program contains valid data and does not cause the Load/Initialize phase
to be invoked (see Section 8).
It is equivalent to the direct statement GO TO n, where n is the first
line number in the program.
.tp10.s2;^&STARTPOINT\&
.x <STARTPOINT
.s;Syntax:
.s.i8;STARTPOINT file nomen
.i8;NO STARTPOINT
.s;Semantics:
.s;The STARTPOINT command specifies the startpoint module,
which during the Load/Initialize phase must either be found on the module list
or be the workspace name (see Sec.#8.4).
.x module list
.x workspace> name
The NO STARTPOINT command causes the workspace to resume its role as the
startpoint module.
.s2;<>^&STEP\&
.s;Syntax:
.s;.i8;STEP  [i]
.s;Semantics:
.p;STEP starts execution at the continue point and interrupts back
to the Command/Statement phase after i statements (from modules compiled in the DEBUG state) complete execution.
The integer constant i may be in the range 1 through 250000; if omitted, 1 is
assumed.
.x interrupting execution
.x execution> interruption of
.x programs> execution
.x debugging
For example:
.s;.i8;_>STEP 3
.s;Whenever control returns to Command/Statement phase, any active STEP count
is discarded.
STEP is allowed only when the workspace is in the DEBUG state, and a continue point is defined.
.tp10;.s2;<>^&SYMD\&
.s;Syntax:
.s;.i8;SYMD id [ ln ]
.s;Semantics:
.p;SYMD prints the definition of the identifier
(scalar or array variable, subarray, procedure, or parameter).
A line number is given to set the procedure context if the specified
identifier is local.
SYMD does not perform on implicitly declared variables (see Sec.#5.3).
.x declaration> implicit
.x debugging
.x internal compiler table
.tp10;For example:
.nf.lm+8.s
_>SYMD I 900
KIND TYPE  NPAR LOC
ARRY INT     2  44
.f.lm-8
.s;KIND will be scalar, array, or procedure;
TYPE is the type of the identifier;
NPAR is the number of parameters or number of dimensions;
and LOC is the low segment location of the identifier.
.tp10;.S2;<>^&TABS\&
.S;Syntax:
.s;.i8;TABS  integer list
.s;Semantics:
.p;TABS sets tab stops at the specified positions; that is it sets
the Control I positions.  As many as 16 tabs can be set.
.x Control ^I
For example:
.p;.i8;_>TABS 20,30,50
.p;The default tab stops are 9, 17, 33,
41, 49, 57, 65, 73, 81, 89, 97, 105, 113, 121, and 129.
.x tab stops
.s;Control I at or beyond the last tab yields a single space.
.s2.tp10;<>^&TOF\&
.s;Syntax:
.s;.i8;TOF [line range list]
.s;Semantics:
.p;TOF gives each line specified (or all lines) a Top of FORM
mark.
When a marked line is written on a file with the SAVE command,
it is preceeded by the sequence form feed/carriage return/line feed.
When listed, it is preceeded by a form feed.
.tp10;.s2;<>^&TOUT\&
.s;Syntax:
.s;.i8;TOUT file nomen
.s;Semantics:
.p;TOUT specifies a file on which output normally
sent to the terminal is to be written.
.x terminal output
If a TOUT file is currently open then it is first closed.
For example:
.p;.i8;_>TOUT FOO
.s;The command
.s;.i8;_>TOUT TERMINAL
.s;resumes the printing of terminal output.
The place where normal terminal output is sent
is called the TOUT Destination, be it either
the terminal or a file.
.x <TOUT destination
.s2;><TRACE
.br;^&NO TRACE\&
.x <no <trace
.s;Syntax:
.s;.i8;[NO] TRACE  [variable list] [line range list]
.s;Semantics:
.p;.f;TRACE provides a printed trace of program execution on the
specified lines of the workspace module.
.x Trace> program execution
.x programs> execution
.x execution> tracing of
.x debugging
For those lines, it prints a trace message whenever a simple scalar variable is stored into
whose name appears in the variable list.
If no variables are specified, a trace message appears
whenever a specified line is executed.
For example:
.tp16
.s;.lm+8;.nf;_>TRACE 100-200
_>RUN
*100
*110
*115
*115
*120
*130
_>TRACE X,Y 100-200
_>RUN
*110
*110 X= 5
*120
*120 Y= 20, 3             Note that Y is a complex
_>                         variable.
.p;.i-8;The command
.p;_>TRACE
.p;.i-8;or
.p;_>TRACE ALL
.p;.lm-8;traces all lines.
.f.p;NO TRACE cancels the trace for the specified variables
or statements; if none are specified all are cancelled.
.tp10.s2;^&VERSION\&
.x <VERSION
.s;Syntax:
.s.i8;VERSION
.s;Semantics:
.s;The VERSION command prints the current TYMBASIC version number.
This is the number that should appear on any correspondence
with Tymshare concerning TYMBASIC.
The version number is also printed whenever TYMBASIC is entered.
.page
.nj
.page size 55
.flag cap;.flag index
.title TYMBASIC REFERENCE MANUAL             FILE MANAGEMENT
.FT
.subtitle 1 January 1978                                               Sec. 11.1
.flags all
.left margin 0
.right margin 69
.c;Section 11     FILE MANAGEMENT
.skip 2
.x Files> Management
.x disk files (see ^Files)
.x user files (see ^Files)
.x files
.x files> characteristics
.x Files
^&11.1  INTRODUCTION\&
.page size +3
.p;.f;File management refers to operations on files executed by TBA run-phase program
statements as opposed to TBA commands.
.x characteristics of files
.x files> characteristics
.P;Files are opened by OPEN statements; they remain open
until closed by CLOSE statements or until an END or STOP is
encountered.
Files are deleted by REMOVE statements.
The syntax and semantics of the OPEN, CLOSE, and REMOVE
statements are to be found in Section 9.1.
.x symbolic files
.x Binary files
.x files
.x files> symbolic
.x files> Binary
.x files> terminal
.x terminal> as a file
.x files> sequential
.x files> random
.x random files (see ^Random-access files)
.p;The file unit number in an I/O statement is rounded to an
.subtitle 1 January 1978                                               Sec. 11.2
integer, which must fall in the range 1 through 20 or a
error condition will be generated.
All references to file numbers except in OPEN
and ON-condition statements require
that the file be already open.
.s3;^&11.2  FILE ATTRIBUTES\&
.p;Tymbasic programs operate on files in the XEXEC environment.
Both file mode (Input/Supersede/Update) and
protection reflect intrinsic attributes of the XEXEC file
system observed and retained by TBA.
The OPEN statement maps the XEXEC file nomen to a TBA
file unit number, and assigns those attributes not intrinsic to
XEXEC files: type (symbolic/binary), access method
(sequential/random), and record length.
.x files
.x files> file unit numbers
.x unit number (see ^Files, file unit number)
.s3;^&MODE\&
.F;.s;If a file is opened for INPUT it is said to
be in Input mode.
The file must already exist.
Other users may access the file while it is open.
The PRINT statement may not be used on a
file open in Input mode.
.x Files> output
.x update mode
.x supersede mode
.x <io
.x <output
.s;Output can take place in two modes, called
Update and Supersede.
Opening a file for IO invokes Update mode and opening a file for OUTPUT
invokes Supersede mode.
.s;In the Update mode, the system retrieves the contents
of the original (old) file, if any, and changes are made directly to
the contents of that file, i.e.,
its contents may be over-written or added to.  Until the
><CLOSE statement is executed the file may continue to be modified or
read, but the file can not be accessed by any other user.
.s;In the Supersede mode the old file is not accessed.
Instead, a new, empty file is created.
Until the ><CLOSE statement is executed the new file
may continue to be written and other users may access the
original file.
When the ><CLOSE statement has
been executed the old file is deleted and the new file takes its place.
.x Testing for End of File
.x errors> on files
.x files
.x files> eof
.x end of file
.x <input
.s3;^&PROTECTION\&
.page size -3
.p;Files have three protection codes, specifying
protection levels for the user himself, other users in his
account, and for all other users.
Protection can be specified in the OPEN statement,
or defaulted to ALL RD NO, which allows the user to change,
rename, or delete the file, other users in the same
account to read the file, and denies all other users any
knowledge of the file.
See the OPEN statement description in Section 9.
.s3;^&TYPE\&
.x files> data representation
.x data> representation
.x files
.x type, file
.x files> types
.x files> symbolic
.x files> Binary
.x symbolic <I/O
.x data unit
.x files> data unit
.s;A file is considered as a sequence of data units,
stored in symbolic or binary form.
The basic data unit in symbolic files is a character; in binary files it is
a word.
TYMBASIC does not allow mixing of  symbolic and binary data in the same file.
.s;Symbolic files consist of 7-bit ><ASCII characters,
stored on a file at five characters per storage word.
When a numeric or logical value is read from or written to a symbolic file,
>conversion takes place between internal machine representation and
character representation.
Symbolic file input and
.x conversion
output may use formatted or unformatted (free-form) conversion.
.x files
.x files> Binary
.x Binary files
.s;A binary file is stored in internal machine form.
Since numeric >conversion does not take
.x formatted <I/O
place with binary files, formatted I/O is not allowed;
.x Binary <I/O> \s\t\r\i\n\g\s
.x strings
free-form PRINT or INPUT statements are the only kind
allowed with binary files.
Values are input from a binary file according to the data type of the input
list element.
TYMBASIC cannot check that values input from the binary file
are of the proper type, and errors of this sort will produce
unpredictable results.
.s;Strings are written in characters whether they are stored on
symbolic or binary files.  Strings on binary files always occupy
a whole number of words.  Binary strings are formatted as
follows: the first half word is the string's character count, the
second half word is the string's word count; the contents of the
string occupy successive words at five characters per word, and the
last word is padded with ><NUL characters (zeros).  If the string
ends on a word boundary an entire word of NUL's is stored.
.tp 25;.p;The storage allocated for various types of data in binary files
is shown in the following table.
.skip 2
.tab stops 12,38
.x Binary <i/o> \d\a\t\a storage
.x files
.x files> Binary
.c;Binary Data Storage
.s;.nf;
.lit
             Type                  Storage

          Real                  1 word   36 bits

          Double Precision      2 words  72 bits

          Complex               2 words  72 bits
 
          Integer               1 word   36 bits
 
          Logical               1 word   36 bits
 
          String                Stored at 5
                                characters per word
                                plus a 1 word
                                descriptor
 
.end literal
.F
.x files> organization
.x errors> on files
.x closing files
.x files
.x files> closing
.x files> opening
.x Files> modes
.x <input
.x input mode
.p;The SIZE(n) function returns the size in characters, words, or
.x <SIZE
records of open file n as follows:
.nf.s2
.lm+5
.s
 Variable-length     Symbolic      Number of characters
  record
                     Binary        Total number of words
.s
 Fixed-length        Symbolic      Number of
  record             and Binary    complete records
.s
.f;.s
.lm-5
.f;SIZE takes into account any output done to the file beyond its
original limits.
See section 11.5 for examples of SIZE usage.
.tp20;.s3;^&ACCESS METHOD AND RECORD LENGTH\&
.P;.F;The organization, type, and basic data units allowed
with sequential and random-access files are summarized below:
.tp 10;.S2;.c;ACCESS METHODS AND FILE CHARACTERISTICS
.x data unit
.x files
.x files> sequential
.tp 30
.x files> organization
.x access methods in files
.x files> access methods
.x random-access files
.x sequential files
.x files
.x files> random-access
.x files> sequential
.x files> binary
.x files> symbolic
.x files> variable-length-record
.x files> fixed-length-record
.x variable-length-record
.x fixed-length-record
.nofill
.nojustify
.skip 1
.tab stops 6,21,37,53
.x data unit
  File           File           File            Data
  Access         Composition    Type            Unit
  Method
.s2
                 Variable-      symbolic        Character
  Sequential     length
                 records        binary          Word
.s1
                 Variable-      symbolic        Character
                 length
                 records        binary          Word
  Random
                 Fixed-length   symbolic        r Characters
                 records
                                binary          r words
.f
.s2
Notes:
.list.le;Word length: 36 bits
.le;Character code: 7-bit USASCII
.le;r = record length specified in OPEN statement
.els
.s2;^&RANDOM-ACCESS FILES\&
.p;Random files allow explicit file-positioning operations, so
that data may be accessed in any order.
Random files are of two kinds: fixed-length-record and
variable-length-record.
.p;Fixed-length-record files are divided into records of equal
numbers of data units, as specified in the OPEN statement.
The carriage return/line feed sequence has no special
significance in fixed-length-record symbolic files.
The record length in binary files has no significance except for positioning
operations.
.p;Variable-length-record files have no such static divisions.
In symbolic files the carriage return/line
feed sequence ends each line and thus marks a record boundary
(a record is equivalent to a line for variable-length-record
symbolic files).
In binary files data is stored continuously and so a record
boundary can be construed as beginning at any word.
Positioning on variable-length-record files is by data unit number,
not record number.
.p;Fixed-length formats only must be used for input or output
to fixed-length-record symbolic files.
Free- or fixed-form formatting is allowed with variable-length-record
files.
.fill
.S2;^&SEQUENTIAL FILES\&
.p;.f;A sequential file is a variable-length-record file in which
explicit file-positioning is not allowed; that is, reading and
writing must take place in the same sequence in which data is stored
on that file.
Once the file is opened, the first data item in the file must be
read or written, then the second, etc.
The terminal, which functions as a sequential file, is discussed
in subsection 11.4.
.s3;^&11.3 LOCATION AND POSITION\&
.subtitle 1 January 1978                                               Sec. 11.3
.s2;.TP 10;^&LOCATION\&
.p;Each data unit in a >variable-length-record
file, and each record in a >fixed-length-record
file, is assigned a positive integer called its location.
.x location
There is only one location pointer for a file.
Locations begin at 1, and the location is set to 1 when a
file is opened.
.x Position
.x files
.x files> position
.x random-access files> position
.p;The  function LOC(n) returns the value of
the location pointer in file n.
For fixed-length-record files the value of LOC(n)
is a record number.
For variable-length-record files,
the value of LOC(n) is a data unit number.
When reading or writing a fixed-length-record
file, the location returned by LOC(n) does not change
until the entire record is read or written.
Thus, if a LOC(n) function is executed while the position pointer is at the
middle of a record, the value returned is the same as it was when the position
pointer was at the start of the record.
See section 11.5 for examples of the usage
of LOC(n).
.tp10;.s3;^&POSITION\&
.p;For >fixed-length-record files, the position is defined
as the data unit (character
or word) offset within the current record at which the next input
or output will be performed.
.p;For >variable-length-record files, the position is again defined with
respect to the beginning of the current record (or line).
However, there are special rules that determine where the current
record begins:
.list
.x <AT clause
.x <LOCATE
.le;If the AT clause or LOCATE statement is used, then a record is defined
as beginning at the specified location.
.x carriage returns
.x files> carriage returns
.le;In a symbolic variable-length-record file, if a carriage return is read or written
then a record is defined as beginning immediately following the
carriage return.
.els
In both cases, the position is set to 1.
.x <form> \u\s\e of ^R
.x <form> \u\s\e of /
.x R format
.x /> format
.x random-access files
.x random-access files> carriage returns
.x files> carriage returns
.x files> fixed-length-record
.x files
.x files> random-access
.x carriage returns
.p;Positions begin at 1, and the position is set to 1 when a file is opened.
.p;The function POS(n) returns the data unit position within
.x <POS
the current record or line at which the next input or output
on file n will be performed.
.s3;^&CARRIAGE RETURNS AND END OF RECORD\&
.s;The end of a record in fixed-length-record files behaves similarly
to the carriage return/line feed sequence in variable-length-record files.
They are referred to together as EOR.
The FORM character "/" or "R", the end of an IMAGE, and the end of a free-form print or input list produce or
seek an EOR and when used cause the position to be set to 1.
.x files
.x files> terminal
.x files> sequential
.x Terminal> as a File
.TP10;.S3;^&11.4  THE TERMINAL AS A FILE\&
.subtitle 1 January 1978                                               Sec. 11.4
.s2;^&General\&
.s;The terminal functions as a sequential file.
The same rules for the use of OPEN, CLOSE, INPUT and PRINT for files apply to
the use of the terminal as a numbered file.
For example:
.skip 1
.nofill
.TP10;.LM+8;_>10 open "TERM",input,1
_>20 input from 1 in image "_#":a,b,c
_>30 PIM "_#":a,b,c
_>40 close 1
_>50 end
.LM-8
.skip 1
.fill
When "TERMINAL" is specified in an OPEN statement, the terminal is treated
as an open file and is counted as one of the 15 files that may be
open concurrently.
Input and output on the terminal file perform identically to normal terminal input
and output.
.s3;^&Program Activation Characters\&
.x activation characters
.x program activation characters
.x Command/^Statement phase
.s;In the Command/Statement phase, each statement or command entered is
terminated with a program-activation character in the form of a
.x files> carriage returns
.x carriage returns
carriage return.  The carriage return causes
TYMBASIC to parse the input and return error and diagnostic
messages if faults are discovered.
.x Run phase
.x files> carriage returns
.x carriage returns
.x Control ^B
.x Control ^G
.x input lists
.s;In the Run phase, a TYMBASIC program awaiting input from the terminal
is activated by either a carriage return, a Control-G, or a Control-B.
The first two characters allow run-phase processing to continue.
Control-B causes the current INPUT list to be restarted and
the program to again wait for input.
.x Random-Access Operations
.subtitle 1 January 1978                                               Sec. 11.5
.tp10;.s3;^&11.5  RANDOM-ACCESS OPERATIONS\&
.x random-access files
.s3;^&ERASING PART OF A FILE\&
.x erasing
.x <ERASE
.x files
.x files> erasing
.p.f;The ERASE statement can be used to erase any selected segment
in a random file open for OUTPUT or IO
(but not for INPUT).
.p;If the end of a file is erased, nulls (zeroes) are written in the
specified locations. The file thus becomes smaller as reflected by the
SIZE function; however, the file size as stored on the disk will not
be affected.
.p;If the erased portion is in the middle of the file, then spaces (for
symbolic) or nulls (for binary) are written in the specified locations,
and the file size is not affected. The location for that file after the
erasure is one greater than the last erased location.
.x <SIZE
.x files> binary
.x binary files
.x location
.tp 27
.P;In the following example the file "FILIN.MM"
has characters 3 through 25 erased by the program
.x files
.x files> erasing
.s.nf;.LM+8;_>10 STRING INPUT.LINE
_>20 COPY "FILIN.MM" TO "TERMINAL"
_>30 OPEN "FILIN.MM-A", RANDOM IO, 5   ! must be open for &
                                        OUTPUT or IO
_>40 ERASE 5 FROM 3 TO 25
_>50 CLOSE 5
_>60 COPY "FILIN.MM" TO "TERMINAL"
_>70 END
.S;
_>RUN
ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIMM
AB                       ZABCDEFGHIMM
END IN LINE   70
.LM-8;.f
.x location> of records
.x files
.x files> random-access
.x files> location
.x random-access files> location
.s3;^&CHANGING LOCATION\&
.x Location> setting
.p;The AT clause used with the INPUT and PRINT statements
and the LOCATE statement
move the location pointer to  the specified location,
and set the position to 1.
Normal input and output may also cause the location to increase sequentially.
.s3;^&In Fixed-length-record Files\&
.x files> location
.x files> fixed-length-record
.x fixed-length-record
.x location> fixed-length-record
.p;With >fixed-length-record files, the AT clause or LOCATE statement
moves the location pointer to the beginning of the specified record.
Thus, if the file "FILIN.Z" contains
.x <AT Clause
.s;.I8;ABCDEFGHIJKLMNOPQRSTUVWXYZAB
.p;the program
.LM+8;.s1;.nf;_>10 STRING A,B,C
_>20 OPEN "FILIN.Z", RANDOM(5) INPUT,1
_>30 INPUT FROM 1 AT 2 IN FORM "5X/":A,B,C
_>40 PRINT A;B;C
.p;.I-8;will print the characters
.s;FGHIJ    KLMNO    PQRST
.LM-8;.f;.p;The first record (consisting of the characters ABCDE)
is skipped because the AT 2 clause moves the location
to the start of record 2 (i.e. F).
After each record is processed, the location is set
to the start of the next record.
.s3;^&In Variable-length-record Files\&
.x Record Length
.x Random-Access Files> record length
.x Variable-length-record
.x files
.x files> random-access
.x location> fixed-length-record
.x files> location
.x files> variable-length-record
.x random-access files
.p;The principal difference in how >location is manipulated with
>variable-length-record versus >fixed-length-record files is
that, with variable-length-record files, the location refers to
the position of individual data units rather than records.
Thus, with the file "FILIN.Z" containing the data
.s;.I8;ABCDEFGHIJKLMNOPQRSTUVWXYZABC

.p;the program
.nf
.LM+8;.s;_>5 STRING A,B,C
_>10 OPEN "FILIN.Z", RANDOM INPUT, 1
_>20 INPUT FROM 1 AT 5 IN FORM "5X":A,B,C
_>30 PRINT A;B;C
.LM-8;.P;.F;will print three groups of characters, starting with
the fifth:
.I8;.nf.s;EFGHI    JKLMN    OPQRS
.f;.p;The location pointer goes to the fifth character
and processing starts at that point.
.S3;^&RECORD BOUNDARIES IN FIXED-LENGTH-RECORD SYMBOLIC FILES\&
.x record boundaries
.x random-access files
.x random-access files> record boundaries
.x files> random-access
.x files> fixed-length-record
.x random-access files> fixed-length-record
.x fixed-length-record> overflow
.x files
.p;Record boundaries in symbolic files must be crossed explicitly.
Failure to do so may cause
.x errors> on files
a file error condition with associated
error message: "Attempt to overflow fixed length
record on random file".
Thus, for example, with the file "FILIN.Z", which contains the
data
.S;.I6;ABCDEFGHIJKLMNOPARSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ
.x errors> on files
.s;an error condition is generated as soon as the
following program tries to execute line 50:
.tp10;.LM+8;.p;.nf;_>10 STRING A,B
_>20 OPEN "FILIN.Z", RANDOM (10)INPUT,1
_>30 INPUT FROM 1 IN FORM "10X/":A
_>40 PRINT A
_>50 INPUT FROM 1 IN FORM "12X/":B
_>60 PRINT B
_>RUN
ABCDEFGHIJ
.S;Attempt to overflow fixed length record on random file
    in line   50
.LM-8;.s;.F;The format "12X/" illegally attempted to read
through the 10-character record boundary declared in line 20.
.p;Note that although TYMBASIC will not cross a record boundary to
either read or write data, when an output format specifies a length
longer than the space left in the record, characters will be
.x errors> on files
written up to the end of the current record even
though this constitutes an error condition.
Thus, although the following program yields an error:
.LM+8;.s1;.nf;_>15 ON ERROR GOTO 100
_>20 OPEN "DATA3-A", RANDOM (10) IO, 3
_>30 PRINT ON 3 IN FORM "15D/":"1234567890123456"
_>40 STOP
_>100 PRINT ERRMSG(ERRCD):" in line":ERRLN
_>150 CLOSE 3
_>160 END
.S;
_>RUN
Attempt to overflow fixed length record on random file in line 30
END IN     160
.I-8;.f;.s1;ten characters are nevertheless written on the file "DATA3":
.s;.nf;-TYPE DATA3
1234567890
.LM-8;.f;.tp 10;.s3;^&Use of / to Cross Record Boundaries\&
.x <form
.x record boundaries
.x record boundaries> crossing
.x /> format
.x <form> \u\s\e of /
.x files
.x files> random-access
.x files> record boundaries
.x random-access files> record boundaries
.x random-access files
.x fixed-length-record> overflow
.p;When a FORM is used for file input or output,
TYMBASIC will not cross record boundaries to process
successive records without the presence of the character / (or
the character R, discussed
below) in the FORM.
In the following examples the file "FORM.IMM" contains
.I8;.s;RECORD ONERECORD TWO
.page size +3
.s;Note that although the following program only attempts
.x errors> on files
to input the same number of characters as the record length, an
error is generated:
.LM+8;.s1;.nf;_>10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
_>20 STRING A,B
_>30 INPUT FROM 1 IN FORM "10%":A
_>35 INPUT FROM 1 IN FORM "10%":B
_>40 PRINT A;B
_>50 CLOSE 1
_>60 END
_>RUN
Attempt to overflow fixed length record on random file
    in line 35
.page size -3
.LM-8;.f;.p;However, when the / is added to the format in line 30
the program runs to completion:
.LM+8;.nf;.s1;_>10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
_>20 STRING A,B
_>30 INPUT FROM 1 IN FORM "10%/":A
_>35 INPUT FROM 1 IN FORM "10%/":B
_>40 PRINT A;B
_>50 CLOSE 1
_>60 END
.S;
_>RUN
RECORD ONE  RECORD TWO
END IN     60
.LM-8;.p;.f;On output to a fixed-length-record file using /, if the record
has not been completely filled when a / is encountered, it is
padded with spaces.
.s3;.f;^&Use of IMAGE to Cross Record Boundaries\&
.x <IMAGE
.x files
.x files> record boundaries
.x files> random-access
.x random-access files
.x random-access files> record boundaries
.x fixed-length-record> use of <image
.p;When used for fixed-length-record file input or output, an
IMAGE causes the current record to be processed and then
moves the location and position pointers to the start of the next record.
.tp18;.LM+8;.s;.nf;_>10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
_>20 STRING A,B
_>30 INPUT FROM 1 IN IMAGE "%%%%%%%%%%":A,B
_>40 PRINT A;B
_>50 CLOSE 1
_>60 END
.S;
_>RUN
RECORD ONE  RECORD TWO
END IN     60
.LM-8;.P;.F;Note in the following example that only the first four characters
of each record are printed and that after each input takes place
the location and position pointers automatically move to the start of the next
ten-character record.
.lm+8.s.nf.tp10;_>10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
_>20 STRING A,B
_>30 INPUT FROM 1 IN IMAGE "%%%%":A,B
_>40 PRINT A;B
_>50 CLOSE 1
_>60 END
_>RUN
EXECUTION
RECO  RECO
END IN     60
.LM-8;.p;.f;On output to a fixed-length-record file using an
IMAGE, if the number of characters specified by
the IMAGE is less than the record length, the data specified by the IMAGE is
printed and the remainder of the record is padded with spaces.
.s3;.f;^&Use of R Format\&
.x r format
.x files
.x files> random-access
.x random-access files
.x random-access files> record boundaries
.x files> record boundaries
.x fixed-length-record> use of ^r format
.p;With fixed-length-record files
the "R" format reads or writes up to the end of
the current record.
.x <form> \u\s\e of ^R
.x ^R format
If the current position is at some point before the end of the
record then "R" specifies that the remainder of the record be
read or written.
Also, "R" performs the same location function as "/"; that
is, it moves the location pointer to the start of the next
record and sets the position to 1.
In the following example the file "FORM.IMM" contains the data
.tp 16
.I8;.s;RECORD ONERECORD TWO
.s;which is processed by the program
.LM+8;.s;.nf;_>10 OPEN "FORM.IMM-A",RANDOM (10) IO, 1
_>20 STRING A,B,C,D
_>30 INPUT FROM 1 IN FORM "6% R":A,B,C,D
_>40 PRINT A:B;C:D
_>50 CLOSE 1
_>60 END
.S;_>RUN
RECORD ONE  RECORD TWO
END IN     60
.LM-8;.p.f;The "R" format is used to read the remaining four characters of each
ten-character record into variables B and D.
.p;If line 30 were modified to read:
.I8;.s;30 INPUT FROM 1 IN FORM "10% R":A,B,C,D
.p;the "R" would perform the same location function as a / in that
position, but the variables B and D would
then receive null strings. A would receive "RECORD ONE", and
C would receive "RECORD TWO".
.x carriage returns
.x files
.x files> carriage returns
.x end of file
.x r format
.x files> random-access
.x files> record boundaries
.x random-access files
.x random-access files> record boundaries
.x fixed-length-record> use of ^r format
.x files> variable-length-record
.x variable-length-record> use of ^r format
.p;In >variable-length-record files, the "R" format reads or writes up through
the next carriage return (or end of file on input) and causes the >position
to be set to 1.
.page
.page size +4
^&EXAMPLE\&
.p;The file "FILIN.Z" which contains the 53 characters
.s;ABCDEFGHIJKLMNOPQRSTUVWXYZ*ABCDEFGHIJKLMNOPQRSTUVWXYZ
.s;is read by the following program:
.s;.nf;.TP20
_>10 STRING A,C
_>20 OPEN "FILIN.Z-A", RANDOM (15) INPUT, 1
_>30 PRINT "INPUT FILE SIZE = ":SIZE(1):" RECORDS"
_>40 OPEN "FILIN.Y-A", RANDOM (10) OUTPUT, 2
_>50 LOCATE 2 ON 1 !SET POINTER TO RECORD 2 IN FILE 1
_>70 PRINT "FILE 1 POINTER SET INITIALLY AT INPUT RECORD ":LOC(1)
_>80 PRINT "FILE 2 POINTER SET INITIALLY AT OUTPUT RECORD ":LOC(2)
_>90 PRINT "VALUE OF POS(1) IS : ":POS(1)
_>100 INPUT FROM 1 IN FORM "10X":A
_>110 PRINT "AFTER READING ":A:" POS(1) IS":POS(1)
_>120 PRINT ON 2 IN FORM "10X/":A   ! first output record
_>130 PRINT "LOCATION ON FILE 1 STILL AT RECORD":LOC(1)
_>140 INPUT FROM 1 IN FORM "R":A !READ REMAINDER OF RECORD
_>150 PRINT "CHARACTERS SKIPPED IN RECORD 2 ARE: ":A
_>160 PRINT "RECORD POINTER NOW MOVED TO START OF RECORD ":LOC(1)
_>170 INPUT FROM 1 IN FORM "10X/":A
_>180 PRINT "NOW, AFTER READING ":A:" POS(1) IS ":POS(1)
_>190 PRINT ON 2 IN FORM "10X/":A   ! second output record
_>200 PRINT "LOCATION IN FILE 1 IS AT RECORD":LOC(1)
_>210 PRINT "LOCATION IN FILE 2 IS AT RECORD":LOC(2)
_>220 PRINT "SIZE OF FILE 2 (OUTPUT FILE)=":SIZE(2):" RECORDS"
_>230 CLOSE 1,2
_>240 OPEN "FILIN.Y-A", RANDOM INPUT, 3
_>250 INPUT FROM 3 IN FORM "R":C
_>260 PRINT "SIZE OF FILE 3 =":SIZE(3):" CHARACTERS"
_>270 PIF "/'AND HERE ARE THE CONTENTS OF FILE 3: 'R":C
_>280 CLOSE 3
_>290 END
.S;
.x files
.x files> random-access
.x random-access files
.x random-access files> example
.x <loc> \e\x\a\m\p\l\e
.x <size> \e\x\a\m\p\l\e
.x <pos> \e\x\a\m\p\l\e
.x location> example
.x files> size
.x files> location
.x files> position
.x random-access files> position
.x random-access files> location
.x random-access files> size
.x position> example
_>RUN
INPUT FILE SIZE =  3 RECORDS
FILE 1 POINTER SET INITIALLY AT INPUT RECORD  2
FILE 2 POINTER SET INITIALLY AT OUTPUT RECORD  1
VALUE OF POS(1) IS :  1
AFTER READING PQRSTUVWXY POS(1) IS 11
LOCATION ON FILE 1 STILL AT RECORD 2
CHARACTERS SKIPPED IN RECORD 2 ARE: Z*ABC
RECORD POINTER NOW MOVED TO START OF RECORD  3
NOW, AFTER READING DEFGHIJKLM POS(1)  IS  1
LOCATION IN FILE 1 IS AT RECORD 4
LOCATION IN FILE 2 IS AT RECORD 3
SIZE OF FILE 2 (OUTPUT FILE)= 2 RECORDS
SIZE OF FILE 3 = 20 CHARACTERS
AND HERE ARE THE CONTENTS OF FILE 3: PQRSTUVWXYDEFGHIJKLM
END IN     290
.page size -4
.P;.F;In this program the file "FILIN.Z" is opened
for input with a 15-character record length.
A second file, which is opened for output with a 10-character record length
(see line 40), has portions of the input data file written on it.
This file is then reopened for input (line 240) and its contents
printed.
Note:
.x files
.x random-access files
.x files> random-access
.p;.list;.le;The size of file 1 is given as 3
records (line 30) because the fourth record (i.e., the last 8
characters) is incomplete.
.le;Because there is no / in the format in line 100
the position pointer in record 2 stops at the 11th character in the record, i.e.
the next one to be processed after the 10 required by the format.
Hence, at this point POS(1)=11.
.le;The format "R" in line 140 reads the remaining characters not yet
processed in the record and moves the location and position pointers to the start of
record 3.
Hence, LOC(1) in line 160 returns a value of 3.
.end list
.page size 55
.page;
.FLAG CAPITALIZE !<!
.FLAG UNDERLINE !&!
.FLAG INDEX !_>!
.F .LM 0 .RM 69 .NJ .P0
.title TYMBASIC REFERENCE MANUAL             FORMATTING
.subtitle 1 January 1978                                               Sec. 12.1
.FT
.C;SECTION 12         FORMATTING
.s2;^&12.1 INTRODUCTION\&
.x formatting;.x conversion> in <I/O
.x <DATA;.x <STR;.x <VAL;.x <READ
.f;.p;This section describes the formatting capabilities of
TYMBASIC applied to terminal and file I/O, the use of the DATA and READ statements
and the STR and VAL functions.
The three types of formatting are free-form, IMAGE, and FORM.
.s;Free-form, discussed in Section 12.2, is the simplest, using the
INPUT statement or the PRINT statement plus delimiters.
A variety of numeric formats are accepted on input.
The semicolon and
comma, used as delimiters in a print list of a PRINT statement, create zones across the print line
in which each output expression is printed.  A colon joins output fields.
An example:
.x free-form;.x zones> in print lines (see ^Print zones)
.x semicolon;.x print zones;.x comma;.x colon
.s;.nf;.lm+5
_>10 header$= "The score is"
_>20 score = 15
_>30 print header$;score
_>run
The score is    15
.s2
.f;.lm-5
IMAGE and FORM formatting are specified by including a format string
in a PRINT or INPUT statement.  For example:
.x <IMAGE;.x <FORM;.x format string
.s;.lm+5;.nf
_>10 PRINT IN FORM "4X/": F$
_>20 INPUT IN IMAGE I$: A
.S;.F;.LM-5
IMAGE formatting, discussed in Section 12.3,  uses two characters (_# and %) to indicate the layout of
an input or output line.
It can specify integer, decimal, E-format, and string formats, and a format-string
rescan allows automatic repetition of the same format.  A single _#
indicates free-form data conversion.   Literal text can be included in
the format string; any characters other than % or _# fields are taken to be literal text.   An example:
.x format string> rescan
.x E-format;.x free-form> in <IMAGE formats
.x literal text> in <IMAGE formats
.s;.nf;.lm+5
_>10 month$="March"
_>20 day=2
_>30 print in image "The date is: _# %%":month$,day
_>run
The date is: March  2
.s;.f;.lm-5
The single _#  specifies free-form output
of the value for month$, the two % characters specify a two-digit
field for the day.
.s;FORM formatting, discussed in Section 12.4,  incorporates most of the features
of free-form and IMAGE formatting, and also  offers a variety of characters
.x free-form> in <FORM formats
to control the exact structure and placement of fields, and capabilities
such as floating $;
automatic indication of negative balances with parentheses or minus signs;
leading * characters for dollar fields;
 binary, hex, and octal
conversion; upper and lower case conversions; and  changing zeros to spaces.
Literal text in a FORM format string is indicated by quotation marks within the format string, for example:
.x literal text> in <FORM formats;.x quotation marks> in <FORM formats
.s;.lm+5;.nf
_>10 A = 46
_>20 print in form "'The answer is:' 5z":A
_>run
The answer is:   46
.s.lm-5.f
For both IMAGE and FORM output, numeric values greater than the
maximum significance (7 significant digits in single precision, 
18 in double) are treated as follows: the number is rounded to 
.x significant digits;.x rounding
the maximum significance and the excess digits are replaced by zeros.
For example:
.x significance> in numeric output
.s;.nf;.lm+5
_>10 A=123456789.1234
_>20 PRINT IN IMAGE "%%%%%%%%%%.%%%%": A
_>run
 123456800.0000
.f;.lm-5
.s2;^&TERMINAL OUTPUT\&
.x terminal output
.x output> terminal
.x terminal output;.x spaces> in terminal output;.x trailing spaces
.s;Trailing spaces are always supressed in output to the terminal.
.x terminal output> suppression of trailing spaces
Also, if a carriage return is printed when the carriage position is 1
.x carriage returns> terminal output
.x <POS
(POS function not including trailing spaces), only a line feed is printed.
.x line feeds> in terminal output
.s;^&OUTPUT OF NUL CHARACTERS\&
.x <NUL characters
.x eight-level
.p;Nul characters (zeroes) may not be printed in TYMBASIC, except in eight-level terminal output.
.s;^&ARRAY INPUT AND OUTPUT\&
.x arrays> output;.x arrays> input;.x output> array;.x input> array
.p;If an entire array is printed or input its elements are accessed
by varying the last subscript most rapidly.
.s;^&INPUT AND OUTPUT OF CARRIAGE RETURNS\&
.x carriage returns
.p;If a carriage return character is printed as part of a string,
TYMBASIC automatically follows it by a line feed character.
Conversely, if a carriage return/ line feed pair is input, the line
feed is discarded and only the carriage return becomes part of the string.
.page;^&DEFINITIONS\&
.nj;.p;The following definitions are applicable to the discussion of
TYMBASIC formatting capabilities.
.P;.i8;a.  ^&CONVERSION\&
.x conversion> in <I/O
.p;Conversion, in general, is the process of creating
in a given mode of representation a string of characters or bits
which correspond to a string of characters or bits in
another mode of representation.
With respect to TYMBASIC I/O formatting, there are three types
of conversion:  (1) from internal numeric representation to string
(i.e. numeric output); (2) string to internal numeric representation
(i.e. numeric input); and (3) string representation to string
representation (i.e. string input and output),
which is strictly speaking a type of editing rather than conversion.
An example would be the formatting of the string "1_^_^4" into the
string "1004".
.p.i8;b.  ^&FORMAT STRING\&
.x format string
.p;A format string is a group of special-purpose characters in a PRINT
or INPUT statement that controls or modifies conversion, spacing,
upper/lower case, storage, sequence, etc.#of input or output data.
.p.i8;c.  ^&FORMAT FIELD\&
.x format field;.x field
.p;A format field is a group of characters in a format string that stand
alone (delimited by separation characters), for the purpose of the transmission
of a specific data item.
.p.i8;d.  ^&FIELD SEPARATOR\&
.x field separator
.p;A field separator is a special-purpose character (e.g.#a space)
that delimits a field in a format string.
.p.i8;e.  ^&LITERAL TEXT\&
.x literal text
.p;Literal text is a sequence of characters within a format string that are
to be printed exactly as they occur or else, on input, cause skipping
of the same number of characters.
.p.i8;f.  ^&EOR\&
.x <EOR
.p;EOR (for "End Of Record") is the abbreviation used in this manual to
denote an end of record or a CR/LF in a file or the terminal
viewed as a file.
.subtitle 1 January 1978                                               Sec. 12.2
.page;^&12.2.#FREE-FORM FORMATTING\&
.x free-form
.s2
.f
Free-form formatting is the easiest to use, but has the least specific
format control.
.s2
^&INPUT\&
.s;In free-form input, items read in response to the
input list of an INPUT statement must
be separated by a comma, space, carriage return, or (terminal input only)
Control-G.
.x Control ^G;.x comma;.x spaces> in free-form input;.x carraige returns> in free-form input
.x spaces> leading
.s;Null input is ignored.  For example:
.s;.nf;.lm+5
_>10 input a,b,c
_>20 print a,b,c
_>run
? 10,,20 (cr)
? (cr)
? 30 (cr)
 10             20             30
.s;.f;.lm-5
Neither the extra comma nor the second carriage
return has any effect.  Leading spaces are also
ignored.
String text input that contains commas or leading spaces must be
enclosed in quotes.
.x quotation marks> with free-form string input
.s2;^&OUTPUT\&
.s;In free-form output, the characters #,# #;# #:# used as separators of expressions in a PRINT statement determine
spacing in the output print line.
A single-expression print list requires no punctuation:
.x comma;.x semicolon;.x colon;.x punctuation> in free-form output
.s;.indent 5;10#PRINT A
.s;will print the value of A followed by a carriage return.
.s;^&Comma and Semicolon\&
.x print zones
.s; A comma in a print list divides the line into zones of
15 spaces.
A value is printed left-justified in a zone (the first
space for numeric output is reserved for a sign).
After a comma is encountered, the next value is printed at the start of
the next zone.  For example:
.s;.indent 5
_>PRINT 1,2,3
.indent 5
#1##############2##############3
.page
.s;If there is not at least one space between the end
of text in the last zone and the beginning of text in the next, a zone
is skipped and printing starts in the beginning of the
next zone:
.nf.tp8
.s;.lm+5
_>10 A=99,B=88
_>20 PRINT "TEST VALUE (NEWTONS)",A,B
_>RUN
TEST VALUE (NEWTONS)##########99##############88
.s;.lm-5
.f
The 21 string characters use all of zone one and 6
spaces of zone two, so the value of A begins the third
zone and B the fourth.
.s;If there is not room enough on the current line (determined by
line length - see the LOL statement), then a carriage return is
.x <LOL
printed and the value is printed in the first zone of the new line.  (The
carriage return is not printed if the current line is empty.)
.x carriage returns> in free-form output
.s;The semicolon has the same effect as a comma
except that the print zones are 3 spaces wide:
.nf
.s;.lm+5
_>PRINT -1;2;3
-1  2  3
.f
.lm-5
.s;The comma or semicolon may be used simply for spacing.  For example:
.s;.nf;.lm+5
_>print -1;;3
-1     3 
.f;.lm-5
.s
^&Colon\&
.s;A colon separator causes two values to be concatenated.
For example:
.nf
.s;.lm+5
_>10 PRINT K: FOR K = -2 TO +2
_>20 PRINT "ALL":"TOGE":"THER":"NOW"
_>RUN
-2-1 0 1 2ALLTOGETHERNOW
.s2
.f
.lm-5
Note that a space is automatically generated for a positive number
in the place of a minus sign for a negative number.
.page
^&Combinations\&
.s;When used in combination in a PRINT statement, the separators
each give the output their characteristic spacing, with comma and semicolon
creating both 15 and 3 character zones simultaneously.  For example:
.nf
.s.lm+5.tp10
_>10 A=5,B=-6,C=7,D=8,E=-9
_>20 PRINT A:B:C;D,E
_>run
 5-6 7    8    -9
.f
.S;.LM-5
The colons join the values of A, B, and C; the semicolon causes
the value of D to be left justified in the next 3-space
print zone; and the comma causes the value of E to be
left justified in the next 15-space print zone.
.s2
^&End of Print List\&
.s;A carriage return/line feed is automatically generated if punctuation does not end a
PRINT statement.  Thus one or more PRINT statements
alone (without print list or punctuation) may be used to print
blank lines.
.s
.x carriage returns> in free-form output
.x output> array;.x arrays> output
^&Array Output\&
.s
If an entire array is printed in free-form, the spacing between its
elements is determined by the delimiter immediately following the array
in the print list.
If the array is not followed by any punctuation, its elements are
separated by comma (15-character zone) spacing.
.s2
^&JOINING INPUT AND OUTPUT\&
.s
Punctuation can be used to allow input text to appear on the
same line as output text.  Also, if the input text is terminated
by typing a Control-G (abbreviated [Gc]), rather
than a carriage return, more output text may be provided
on the same line.  For example:
.x control ^G
.s;.nf;.lm+5
_>10 print "B=";
_>20 input b
_>30 print " (DIVISOR)"
_>run
B=? 99 [Gc] (DIVISOR)
.lm-5;.f
.page
^&CONVERSION CHARACTERISTICS\&
.s3;.c;^&FREE-FORM INPUT CONVERSION\&
.x E-format
.x D-format
.tab stops 30
.nf;.s;Format	Accepts numbers in all formats:
	integer, decimal, E-format and D-
	format.  Also accepts string input
	to variables declared as string.
	Numeric input can have no imbedded
	spaces.
.s;Sign	Treats unsigned input numbers as
	positive.
.s;Decimal point	Accepts and ignores any number of
and zero	leading integer zeros and trailing
suppression	decimal zeros.  Accepts decimal point
	not followed by numerals.
.s;Logical input	Accepts input values for variables
	declared as logical.  Zero and nonzero
.x logical> input
	values are converted to 0's and 1's
	respectively.
.s;Complex input	Accepts two input values as
.x complex> input
	complex input to variables
	declared as complex.
.page.c;^&FREE-FORM OUTPUT CONVERSION\&
.s;Numeric Output
.nf;.tab stops 2,30
.s;	*Integer	Integer form retained through 11
.x E-format
		digits. E-format used over 11 digits.
		Numeric range: +34x10**9 through
		-34x10**9.
.s;	*Real and Double	Printed with decimal point and
		fractional part (except for exact
		integer values) up to 7 significant
		digits for single precision and 14
		14 significant digits for double
		precision (or as specified by
		SIGNIFICANCE statement).  E-format used
.x significance> in numeric output
		for larger quantities and quantities
		smaller than .1.  Numeric range
		from -10**38 through +10**38.
.s;Rounding
.s;	*Integer	None
.s;	*Real (single precision)	Rounds after 7 significant digits
		(or less, as specified by SIGNIFICANCE
		statement).
.s;	*Real (double precision)	Rounds after 14 significant digits
		(or up to 18 as specified by
		SIGNIFICANCE statement).
.s;Decimal point and	Trailing zeros after decimal point
zero suppression	are not printed.  Decimal point
		is printed only if fractional
		digits are generated.
.s;Treatment of	Space printed before positive numbers.
sign	Minus sign printed before negative
		numbers.
.s;Logical Output	Prints 0 and 1 integer values.
.x logical> output
.s;Complex Output	Printed as pairs of real values:
.x complex> output
		one for the real part and one
		for the imaginary part. Comma
		separates real and imaginary parts.
		Follows same rules as real numbers
		with respect to format, precision
		and rounding.
.f
.subtitle 1 January 1978                                               Sec. 12.3
.page;^&12.3.#IMAGE FORMATTING\&
.s2
.x record <I/O
.x line-oriented <I/O;.x <IMAGE
The IMAGE format string in a PRINT or INPUT statement prints or accepts 
exactly one line or record.
It uses #% and #_# characters
to define the image of a number or string.  The number of
% or _# characters given in a format field determines the number of
characters formatted; an exception is a single _# used for free-form conversion.
Literal text may appear in the format (all text other than % or _# fields
is taken as literal text).  For example:
.x literal text> in <IMAGE formats
.s;.nf;.lm+5
_>10 NAME$='JONES'
_>20 RANK=23
_>30 PRINT IN IMAGE "FIRST  %%%%% %%':NAME$,RANK
_>RUN
FIRST  JONES 23
.f;.lm-5
.p;The IMAGE field specifies printing of the literal text FIRST,
two spaces, the string value of NAME$ formatted for 5 characters,
a single space, and finally the numeric value of RANK, formatted
as two digits.
.s;In determining the number of characters for numeric output, an extra
character must be provided for the minus sign of negative values.
An attempt to output a sign without 
having reserved a space generates an error condition.
.s;^&LONG AND SHORT FORMAT FIELDS\&
.s2
.nf.lm+4
OUTPUT       |           numeric                   string
             | integer part    decimal part                  
------------------------------------------------------------
Format field_>|
output value | leading spaces  trailing zeros   trailing spaces
             |
Format field_<|
output value | error condition    rounding         truncation
.x truncation> in <I/O
.s2
INPUT        |           numeric                   string
             | integer part    decimal part
------------------------------------------------------------
Format field_>|
input string |       generates  an  error  condition
             |
Format field_<|
input string |          truncation                 truncation
.lm-4.f
.page;^&NUMERIC FIELDS\&
.s;The % character is used to format integer and decimal fields; the _# character is used
for E-format fields.
(A single _# may also be used - see FREE-FORM IMAGE, below.)
.x E-format
Spaces input by a % or _# field are interpreted as zeroes.
.s;^&Integer\&
.s
A series of one or more % characters can format an integer field.
One % is needed for a sign.  Examples:
.s;.nf;.lm+5
FORMAT FIELD    PRINTS      AS
.s
 %%%%%%%         200       _^_^_^_^200
                -200       _^_^_^-200
                 5.67      _^_^_^_^_^_^6
.s
 %%%             200       200
                -200      error condition
                 5.67      _^_^6
.s;.f;.lm-5
.s;^&Decimal\&
.s
To output a decimal value, include a decimal point at the appropriate
location in the format field:
.s;.nf;.lm+5
FORMAT FIELD    PRINTS      AS
.s
 %%%%%.%%        200       _^_^200.00
                -200       _^-200.00
                 5.67      _^_^_^_^5.67
.s
 %%%%.%%%%       200       _^200.0000
                -200       -200.0000
                 5.67      _^_^_^5.6700
.s
 %%%%.%          5.67      _^_^_^5.7
.s;.f;.lm-5
.s.tp30;^&E-Format\&
.s;A minimum of 7 _# characters, or 6 with a decimal point, are needed
for E-format input or output.  Assuming such
a format (either "_#_#_#_#_#_#_#" or "_#._#_#_#_#_#")
the assignment of characters is:
.s;.nf;.lm+5
_#       the sign position
.indent-1
 . or _#  the decimal point
_#       the minimum single digit mantissa
_#       the character E
_#       sign of the exponent
_#_#      two places for the exponent
.s;.f;.lm-5
All positions are required; if there is not at least one _# before the
decimal point an error condition will result.
A _# character must be supplied for each digit in the mantissa.
Examples:
.s;.nf;.lm+5
FORMAT FIELD    PRINTS     AS
.s
 _#_#_#_#_#_#_#         200    _^.2E+03
                -200    _^.2E+03
                 5.67   _^.6E+01
.s
 _#_#_#_#_#_#_#_#_#       200    _^.200E+03
                -200    -.200E+03
                 5.67   _^.567E+03
.s
 _#_#._#_#_#_#_#        200    _^2.0E+02
                -200    -2.0E+02
                 5.67   _^5.7E+00
.s;.f;.lm-5
.s2
^&STRING FIELDS\&
.s
Either _# or % may be used to format string fields.
Examples:
.s;.nf;.lm+5
_>10 a$="URE360"
_>20 PIM "%%%%%%":a$
_>30 PIM "_#_#_#_#":a$
_>run
URE360
URE3
.s2
.lm-5;.f
^&FREE-FORM IMAGE\&
.s
A single _# can be used for free-form conversion of values, exactly
as described in "Free-form Conversion Characteristics", Sec.#12.2.
.x free-form> in <IMAGE formats
.p;Note that free-form conversion cannot be used for writing to a random file
with fixed-length records.
The _# itself does NOT read or write a carriage return.
End of image, however, will (see END OF IMAGE, below).
.x carriage returns> in <IMAGE formats;.x literal text> in IMAGE formats
.S2;^&LITERAL TEXT\&
.p;All characters in an IMAGE format string, including spaces,
are considered literal text except those characters that comprise the
format fields (%, _#, and a decimal point immediately preceeding or
following a % or _#).
.p;On output, every character of literal text is printed exactly
as it appears in the format string.
.p;On input from a terminal, literal text in a format string
is printed at the terminal as follows:
.lm+12;
.s.tp6
.br;a.  If the literal text precedes the format field the text
is printed and the system then looks for input.
.br;b.  If the text follows a format field, the system looks for input.
After the input is received the text is
printed.
.lm-12;.p;On input from a file, literal text in a format string causes
a corresponding number of input characters to be skipped.
Thus, if the IMAGE format string "ZZ%%%" is used to read the input
A=666, the data accepted is 666.
If the format string "A=%%%" is then used for output the characters
A= would be printed before each value. For example, the data
.p;.i8;A=123
.i8;A=456
.i8;A=789
.p;is read from the file URE.360 and printed by the program:
.page size +1
.p;.nf;.LM+8;_>10 OPEN "URE.360-A", INPUT, 1
_>15 ON ENDFILE 1 GOTO 40
_>20 INPUT FROM 1 IN IMAGE "XX%%%":NN
_>25 PIM "A=%%%":NN
_>30 GOTO 20
_>40 CLOSE 1
_>50 END
.S;
_>RUN
A=123
A=456
A=789
.S;END in line 50
.f.lm-8
.page size-1
.page;^&END OF IMAGE\&
.f;.p;When the end of an input IMAGE format string is reached,
TYMBASIC seeks or prints  an EOR and ignores further input
characters until the EOR is read.
.x <EOR> at end of <IMAGE
.x carraige returns> at end of <IMAGE
For example, with the following file only the first three
characters of each record are read.
.p;.nf;.LM+8;123456
234567
345678
456789
.p;_>10 OPEN "END.IMG-A", INPUT, 1
_>20 ON ENDFILE (1) GOTO 60
_>30 INPUT FROM 1 IN IMAGE "%%%":KK
_>40 PRINT KK
_>50 GOTO 30
_>60 CLOSE 1
_>70 END
.S;_>RUN
123
234
345
456
.S;END in line 70
.LM-8;
.f;.p;When the end of an output IMAGE format string is reached an EOR is
generated.
The remainder of a fixed-length record is filled with spaces.
.x eight-level
.subtitle 1 January 1978                                               Sec. 12.4
.page;^&12.4 FORM FORMATTING\&
.s
.x <FORM
FORM formats have similarities to IMAGE formats (both use % and _#
characters), but whereas the IMAGE format builds a character by character
image of a line, the FORM format specifies one or more fields, using
both formatting and utility characters.  
.x format fields
.s;In the FORM format,
characters and fields can be replicated,
using numbers, parentheses, and brackets.
Since the format is not an image, a space does not produce 
or accept a space on output or input, but is used to delimit fields;
the utility character B indicates a literal space.
Literal text must be enclosed in quotes.
.x quotation marks> in <FORM formats;.x literal text> in <FORM formats
.s
An example of some of these differences:
  the IMAGE format
.s;.lm+5
PRINT IN IMAGE "%%%%%%###%% %% %% THE END": a,b,c,d
.lm-5;.s
could be specified with a FORM
format as
.s;.lm+5
PRINT IN FORM "6% 3B 3(2%B) 'THE END'": a,b,c,d
.s;.lm-5
The treatment of format fields that are either longer or shorter
than the corresponding input or output values is the same as for IMAGE,
as described under "LONG AND SHORT FORMAT FIELDS" in Sec.#12.3.
.s;This subsection describes the formatting characters, the utility 
characters, FORM input and output, and concludes
with the treatment of EOR's by FORM formats.
.page
^&FORMATTING CHARACTERS\&
.s
The % and _# characters follow the same rules as for IMAGE formatting.
The following additional formatting characters cannot be used
in the same field with either % or _#, although their
use in different fields of the same FORM format is allowed.
.s;The FORMATTING CHARACTERS table below is arranged alphabetically
with + and - appearing near the sign-formatting character S
and _. appearing near V, the decimal point positioning character.
The $ and * formatting characters appear at the end of the table.
By function, the characters fall into three groups:
.s;.lm+2;.nf
String    Either      Numeric
------    ------      --------
   A         D        E   H   K
   C         Y        O   P   Q
   J                  S   +   -
   R                  .   V   W
   U                  Z   $   *
   X
.S;.F;.LM-2
.s;.c;FORMATTING CHARACTERS
.S
.nf
Char-     Description              Example
acter             
-----------------------------------------------------------------
.s.tab stops 4,33,43
.x A formatting character
A	 For printing or	6A	Prints "ABCD" as
	 input of strings 		ABCD_^_^
	 only. Prints or
	 accepts a letter or
 	 a space only.
#
.x C formatting character
.x centering
C	 Prints or accepts any	6C	Prints "ABC" as
	 string character. On		_^ABC_^_^
	 output, centers the
	 string (if string
	 cannot be evenly
	 centered it is left-
	 centered). On input, C
	 is equivalent to X.
	 Cannot appear in same
	 field with any other
	 format character.
.page
.x D formatting character
D	 For either string
	 or numeric fields:
	  *Prints or accepts 	6D	Prints 1004 as 001004.
	   digits in numeric 		Reads 1004 from 001004.
	   fields. Leading or
	   embedded zeros
 	   are printed.
	  *Prints or accepts	6D	Prints "1004" as 100400
	   string characters		Reads 100400 from 1_^_^4_^_^
	   0-9 and space.
	   Spaces are replaced
	   by zeros.
#
.x E formatting character
E	 Specifies that the 	3D.DESDD	Prints 1004 as
	 expression is printed 		100.4E+01. Reads 1004
	 or interpreted as 		from 100.4E+01
	 E-format notation. The
.x E-format
	 E is printed. There
	 can be only be one
	 E per field.
#
.x H formatting character
H	 Converts a number 	6H	Prints 1004 as 003EC.
	 to hexadecimal.		Reads 1004 from 0003EC
.x hexadecimal notation
	 Supplies leading zeroes.
	 Cannot be concatenated
	 with any other format
	 character. Number to
	 be converted must be
	 declared integer.
#
.x J formatting character
.x justification
J	 Prints or accepts any	6J	Prints "ABC" as
	 string character. On		_^_^_^ABC
	 output, right-justifies
	 the string. On input it
	 is equivalent to X. J
	 cannot appear in the same
	 field with any other
	 format character.
#
.x K formatting character
K	 Same as E except that 	3D.DKSDD	Prints 1004 as
	 E is not printed on	          100.4+01
	 output.
#
.x O formatting character
O	 Converts a number	8O	Prints 1004 as 00001754
	 to octal. Supplies 		Reads 1004 from
.x octal notation
	 leading zeros. Cannot 			00001754
	 be concatenated with
	 any other format
	 character. Number to be
	 converted must be
	 declared integer.

#
.x P formatting character
.x negative balances
P	 For printing negative	P6QP	Prints -1004 as (1004)
	 values enclosed in		Prints +1004 as _^1004_^
	 parentheses. Sufficient
	 P's must appear to allow	3P.4P	Prints -12.4 as (12.400)
	 values to be so treated.		Prints 12.4 as _^12.400_^
	 More than one P in
	 integer part or exponent
	 prints or accepts a
	 number with a left
	 parenthesis floated to
	 left of number.
	 Prints spaces in	D.DEPDDP	Prints .000123 as
	 place of parentheses		1.2E(04))
	 if value is positive.		Prints 1234 as 1.2E_^03_^
	 P's can also be placed
	 around the exponent of
	 a number.

#
.x Q formatting character
Q	 Output only, for 	6Q 	Prints 1004 as 1004
	 printing a number left
	 adjusted. Prints one
	 digit per character.
	 Unneeded character
	 positions are suppressed.
#
.x R formatting character
.x strings> input
R	 For free-form input or	R	Prints "ABC123" as
	 output of complete 		ABC123 followed
	 strings. Supplies EOR 		by a carriage return.
	 on output. Reads EOR  		Reads ABC123 from
	 on input but does not 		ABC123CR/LF
	 make it part of string.
	 In fixed-length record
	 random files, R prints
	 all or remainder of a
	 record and moves
	 current-location pointer
	 to start of next record
#
.x S formatting character
S	 More than one S prints 	6S 	Prints 1004 as _^+1004
	 or accepts a number
	 with sign floated 	S5D	Prints 1004 as +01004
	 to left of number.
	 One S anywhere in a 	5DS 	Prints 1004 as 01004+
	 numeric format prints
	 the sign in that position.
#
.x + Formatting character
+	 For printing sign of	6+	Prints +1004 as _^+1004
	 a positive number.
	 Two or more + signs
	 float to left of number.
#
	 Sign of negative number
	 printed as space. Accepts	6+ 	Prints -1004 as _^_^1004
	 any sign on input. Single 	6D+	Prints +1004 as 001004+
  	 + prints + or space in
	 position specified.
#
.x - formatting character
-	 For printing sign of	6-	Prints -1004 as -1004
	 a negative number. Two
	 or more - signs float
	 to left of number.
	 Accepts any sign on input.
#
	 Sign of a positive number
	 printed as space. Single	6-	Prints +1004 as 1004
	 - prints - or space in
	 position specified.

#
.x U formatting character
.x conversion> lower to upper case
U	 Prints or accepts any	6U	Prints "string" as STRING
	 string character and
	 converts lower case to
	 upper case.

#
.x _. formatting character
_.	 For decimal point loc- 	4D.2D 	Prints 1004 as 1004.00
	 ation in numeric fields
	 only.#Prints or accepts
	 decimal point.

#
.x V formatting character
V	 Indicates position of	4DV2D	Prints 1004 as 100400
	 decimal point in
	 format string. Decimal	4DV2D	Reads 10040 as 1004
	 point is suppressed on
	 output. Adds indicated
	 decimal point scaling
	 on input. This character
	 can only be used in
	 conjunction with other
	 formatting characters.

#
.x W formatting character
.x binary format
W	 For conversion to	12W	Prints 1004 as
	 binary. Supplies		100111110
	 leading zeros. Cannot
	 be concatenated with
	 any other formatting
	 character. Number to
	 be converted must be
	 declared integer.

#
.x X formatting character
X	 For strings only.	6X	Prints "ABC5" as ABC5_^_^
	 Prints or accepts any
	 string character.
	 Reads a carriage return
	 from carriage return/
	 line feed. Prints a
	 carriage return as
	 carriage return/
	 line feed.

#
.x Y formatting character
Y	 Prints or accepts	6Y	Prints 1004 as _^_^1_^_^4.
	 the digits 0-9 and space
	 only, for either string
	 or numeric fields.		Prints string "1004" as
	 On input, Y converts		1_^_^4_^_^.
	 spaces to zeros. On		Reads "001004" from _^_^1_^_^4
	 output, Y converts
	 zeros to spaces.

#
.x Z formatting character
Z	 Prints or accepts a 	6Z	Prints 001004 as 1004
	 decimal digit and		Reads 1004 from 001004
	 replaces leading zeros
	 with spaces.

#
.x $ formatting character
$	 Prints or accepts	4$.$$	Prints 10.95 as _^$10.95
	 digits 0-9, spaces and
	 $ in numeric fields
	 only. Prints or
	 accepts a $ floated
	 to the position
	 before the first
	 digit. Two or more
	 consecutive $'s are
	 necessary for floating
	 to take place.

#
.x * formatting character
*	 Fills up spaces
	 between $ and first
	 digit of a number
	 with *'s to act as a	$6*.DD	Prints 10.95 as $****10.95
	 check protect feature.		Reads 10.95 from
	 For use with digits 		$****10.95
	 0-9, spaces and $
	 in numeric fields only.
	 Number is right justi-
	 field. Two or more
	 consecutive *'s are
	 necessary for floating
	 to take place.
.f
.page;^&STRING CHARACTERS\&
.s2;^&D and Y in String Fields\&
.x D formatting character
.x Y formatting character
.p;D and Y act similarly in string fields as they do in numeric fields,
.x D formatting character
.x Y formatting character
but cannot be combined with comma or period as they can in numeric fields.
Both only operate on the characters 0 through 9 and spaces.
On output, D will print the string character 0
in place of a space, and Y will print a space in place of
the string character 0.
On input, D and Y are equivalent; spaces are converted to zeroes.
NOTE: Concatenation of U, X and A with any numeric field characters
.x subfield
other than D and Y is not permitted.
.p;If D or Y is concatenated with any numeric field characters, the
field is numeric.
Similarly, D or Y concatenated with A, U or X results in a string
field.
If D, Y, or both are the only characters in a field, the field type
will be taken from the variable type.
This means that such a field can print or accept a numeric or a string value.
.p;Note the following example:
.s;The file FRM.STR
.p;.nf;.lm+8;5_^_^9
1_^_^000
.lm-8
.s;is read by the following program
.s;.lm+8;_>10 STRING NN,OO
_>20 OPEN "FRM.STR-A",INPUT,1
_>30 INPUT FROM 1 IN FORM "4D/4Y/":NN,OO
_>40 PRINT NN;OO
_>50 CLOSE 1
_>60 END
_>RUN
5009_^_^1000
END in line 60
.f.lm-8
.page;^&NUMERIC CHARACTERS\&
.s2;^&D and Y in Numeric Fields\&
.x numeric fields> use of d
.x numeric fields> use of y
.p;.f;On numeric output the characters D and Y can be used to print
digits.
        D will print leading, embedded, and trailing zeroes, while
Y will replace each leading, embedded, or trailing zero with a space.
Examples:
.tp10;.p;.lm+8;.nf;Field:        Prints:           As:
.s;4D              2307            2307
.s;4Y              2307            23_^7
.s;3D.3D             15            015.000
.s;YDD.DDY           15            _^15.00_^
.s;D.DESDD          600            6.OE+02
.s;Y.YESYD          600            6._^E+_^2
.lm-8;.f;.p;
.p;D and Y are equivalent when used in input fields.
Both will accept only digits or spaces; spaces are converted
to zeroes.
Any attempt to accept characters other than digits and spaces
will cause an error condition.
For example, either 3D or 3Y will read the value 307 from either
307 or 3 7.
Notice that D and Y will accept neither a decimal point nor
the sign of a number.
.page;^&Concatenation within Subfields\&
.p;.f;These rules concern the concatenation of certain characters within
the same subfield of a format string.
A subfield is defined as either that part of a field which formats
a number without its exponent or that part of a field which formats
the exponent.
The characters affected by these rules are: Q, Z and the
floating characters (i.e. two or more): $,*,P,S,+, and -.
These are known as conditional field characters.
.x floating characters
.x conditional field characters
.p;.c;^&RULE 1\&
.p;.f;Two different conditional characters cannot appear in the same
subfield.
Thus, "$$ZZ", "***$$$$" are not permitted.  The field "QQQESSS" is
permitted because the Q's are in one subfield and the S's another.
.p;NOTE: One exception to this rule is that Q's and Z'S can be used in the decimal
part of a field.
Example:
.s.nf.lm+8
_>10 PIF "+++++.QQQ":47.5,47.00
_>RUN
  +47.5  +47.
.f.lm-8
.p;.tp10;.c;^&RULE 2\&
.p;The conditional field characters can be used before but not after D
or Y in a subfield.
Thus, "$$$DDDD", "+++++YD", "SSS.DD" are permitted, but
"DDDD$$$", "YD+++++" and "DD.SSS" are not permitted.
.p;.c;^&RULE 3\&
.p;.f;If conditional field characters other than Q or Z are used to print the decimal part
of a number, the result will be the same as if D's had been
used instead.
For example, the following pairs of fields are equivalent:
.lm+12;.nf;.p;Field:               Is Same As:
.s;
$$$$.$$                $$$$.DD
.s;
SSSVSSS                SSSVDDD
.s;
$---.--                 $---.DD
.s;
ZZ.ZESQQ               ZZ.ZESQQ
.s
PPP.PPP                PPP.DDP
.page
.lm-12;.f;.p;.c;^&RULE 4\&
.p;When the comma is used with conditional field characters, a comma will
print only if a digit of the number being printed appears to the
left of the comma.
Otherwise, the comma prints the same character as generated by the
conditional character field in which the comma appears.
When the comma is used with D a comma prints unconditionally.
.x comma> in conditional field
For example,
.tp10;
.lm+8;.nf;.p;Field:                Prints:                 As:
.s;
***,***.DD           1203.6               **1,203.60
.s;                     32.61                *****32.61
.s;
$$,$$$               2341.7               $2,342
.s;                     -28                  _^_^_^$28
.s;
SQ,3Q,3Q.3D          24369.6              +24,369.600
.s;                     -315.01              -315.010
.s;
Z,ZZZ                1200                 1,200
.s;                     39                   _^_^_^39
.s;-DD,DDD.DD           -1337.4              -01,337.40
.s;                     16.25                _^00,016.25
.s;
Y,YYY                3297                 3,297
.s;                     8                    _^_^_^_^8
.f.lm-8
.tp10.page;^&Hex, Octal, and Binary Conversion: H, O, and W\&
.p;The H, O and W characters specify the conversion between integer numeric
values and
hexadecimal, octal or
binary strings, respectively.
The H, O and W conversion characters cannot be concatenated with
other formatting characters.
They can, however, be used with the utility characters.
.x hexadecimal format
.x binary format;.x octal format
For example:
.nf;.p;.lm+8;_>10 INTEGER A
_>20 A=4798
_>30 PIF "6H 3B 8O 3B 12W":A,A,A
_>RUN
0012BE   00011276   001010111110
.lm-8
.tp20;.NOTE CAUTION
.nj;If the format string has less characters than the
converted output value, the number actually printed is
a truncated, right justified version of the correct number
having the exact number of characters specified
in the format string.
With "3H" the string printed for the value 4798 is 2BE.
No error condition occurs.
.END NOTE
.f;.p;Also, H, O, and W, when used in input
formats, allow the conversion of hex, octal or binary input strings
into numeric values.
As with output formats, the input values must be read into variables
previously declared as integer.
For example:
.nf;.p;.lm+8;_>10 INTEGER X,Y,Z
_>20 IIF "3H 4O 5W":X,Y,Z
_>30 PRINT X,Y,Z
_>RUN
ABC
1234
11111
 2748           668            31
.f.lm-8
.page;^&FLOATING CHARACTERS\&
.tp10;.s2;^&Floating and Static $\&
.x $ formatting character
.x floating $
.x Static $
.p;The use of the $ as a floating character (by including two or more $'s in the same field) prints or accepts
a $ immediately preceding a number.
Example:
.p;.nf;.lm+8;_>10 PIF "$$$.$$ bbb $$$.$$ bbb $$$$":2.045,.7,300
_>RUN
_^$2.05_^_^_^_^_^$.70_^_^_^$300
.lm-8;
.f;.p;On output, the $ always floats to the position before the
first non-space output character.
If the $ field is made too short and does not allow for the
floating $, an error condition results.
Thus, 23.06 cannot be printed with the format "$$.$$".
If the $ field is longer than the output value requires,
the $ is preceeded by spaces.
.p;On input, a $ will accept a space or $ before a number.
.p;Static use of the $ occurs when a single $
is simply to be printed in the position specified, as in the following
example:
.nf;.p;.lm+8;_>10 PIF "$6*.DD":24.95
_>RUN
$****24.95
.lm-8.f
.p;A static * may not appear within a subfield.
.s;^&Floating and Static *\&
.x * formatting character
.x floating *
.x static *
.p;The floating * field prints or accepts leading *'s in place of
spaces as protection of dollar amounts on checks.
For example:
.p;.nf;.lm+8;_>10 PIF "4* BBB **.** BBB 3*.**":23,8.625,3.2
_>RUN
**23_^_^_^*8.63_^_^_^**3.20
.f.lm-8
.p;Behavior of * is analagous to $ except that ^&all\& leading
spaces are replaced by * instead of only the space immediately preceeding the number.
.p;The static use of * occurs when a single * is specified.
In this case the * is simply printed in the position specified,
as in the following example:
.nf;.p;.lm+8;_>10 PIF "*3$.DD":44.95
_>RUN
*$44.95
.lm-8.f
.tp10.s2;^&Floating and Static P\&
.s;The floating P field prints or accepts a left parenthesis floated
to the left of a negative number, preceeded by spaces if an excess
of P's is given.
P will print or accept a space for positive numbers.
The exponent subfield may also be parenthesized.
A static P must always appear for the right parenthesis.
TYMBASIC will interpret the rightmost P in a subfield as a static P if
necessary.
Examples:
.s.nf.lm+5
Field:      Interpreted As:    Prints:     As:
.s
6P          5PP                -123        _^(123)
                                123        _^_^123_^
.s
4P.3P       4P.2DP             -12.3       _^(12.30)
                                12.3       _^_^12.30_^
.f.lm-5
.p;Static use of P causes a right or left parenthesis (depending on
whether it precedes or follows the number) to be printed or accepted
for negative numbers.
For positive numbers, static P prints or accepts a space.
Parentheses must always be balanced.
For example:
.s.nf.lm+5
Field:          Prints:         As:
.s
P3Z.3QP         -49.2           (_^49.2)
                 49.2           _^_^49.2_^
.S
Z.DDEPDDP       .492            4.92E(01)
.f.lm-5
.p;In order to balance parentheses, it is often necessary to combine
floating and static P in the same field.
Examples:
.s.nf.lm+5
Field:          Prints:         As:
.s
6P.2DP          -49.2           _^_^_^(49.20)
.s
2P.3DES2QP      -49.2           (4.920E+1)
.s
4P.2P2QP        -117.36         (117.36)
.f.lm-5
.tp20;.s2;^&Floating and Static Sign Characters\&
.x Sign formatting characters
.page size +5
.p;The format characters S, + and - will float to the left of
the number printed if two or more are specified, as shown in the
following table:
.tp10;.lm+2;.nf;.s;More    Floats:                         Example
than                                     Field:  Prints:  As:
one:
#
.s
S               Sign                       3S       6      +6
.s;
+               + if positive number.      3+       6      +6
.s;                Space if negative                  -6      _^6
.x space> as field separator
.x B formatting character

.s;-               - If negative number.      3-      -6      -6
.s;                Space if positive                   6      _^6
.lm-2;.f;.s;The single (i.e. static) occurrence of any of these characters
causes it to be printed in the position specified, instead of
floating.
For example:
.lm+4;.nf;.s;Static  Prints                        Example
                                    Field:  Prints:    As:
.s;
S       Sign                        ZZS      -6      _^6-
.s;
+       + if positive number.       +DDD    -102     _^102
        Space if negative           DDD+     102     102+
.s;
-       - if negative number.       -YYY    -102     -1 2
        Space if positive           -DD-    -77      -77-
.lm-4;.f;.p;Note that more than one static occurrence of S, +, or - in a
single subfield is permitted.  For example,
.p;.nf;.lm+8;_>10 PIF "*$QQQQS*":-15
_>RUN
*$15-*
.s;_>10 PIF "SDD.D-+/":-72.8,12.3
_>RUN
-72.8-_^
+12.3_^+
.lm-8
.p;.f;The sign of an exponent subfield can be
printed only in front of the exponent.
After the exponent, a static occurrence of S, +, or - will print
the sign of the mantissa.
For example,
.s.nf.lm+8;_>10 PIF "SDDESDD-+/":1234,-5678
_>RUN
+12E+02_^+
-57E+02-_^
.f.lm-8
.page;^&UTILITY CHARACTERS\&
.page size -5
.p;The utility characters do not transmit or convert data values,
but are used to transmit special characters or to affect the format itself.
Those that do not separate or create fields may be used anywhere
within a subfield.
.s2.c;UTILITY CHARACTERS
.s.nf.lm+5
Character                    Function
----------------------------------------------------------------
.s;Space                        Acts as field separator.
.s;B                            Prints a space on output.
                             Skips a character on input.
.s;"text" or                    Prints the enclosed literal text
.x literal text> in <FORM formats
'text'                       on output; on input, skips as
                             many characters as are enclosed.
                             Quote marks follow same rules as
                             for string expressions.
.s;,                            Prints a comma on output;
                             skips a character on input.
                             For use in numeric fields only.
.s;/                            Prints an EOR on output; seeks
.x / formatting character
.x _\ formatting character
                             an EOR on input; acts as field
                             separator.
.s;_\                            Prints a line feed on output;
                             skips a character on input.
.s;n(#)                         Causes the enclosed field to be
                             replicated n times,
                             creating n fields.
.s;n[#]                         Causes enclosed characters to be
                             replicated n times.
.lm-5.f
.page;^&REPLICATION\&
.x replication> in <FORM formats
.x repetition> in <FORM formats
.p;.f;Format characters and fields can be repeated by the use of
numeric multipliers.
(Replication is available only with FORM formats.)
Three types of replication are allowed:
.list;.le;Direct use of multipliers with single format characters,
as shown in the following examples:
.s2;.lm+8;.nf;The Format:            May Be Expressed As:
.s;%%%                    3%
.s;%%%%.%%                4%.2%
.s;_#_#_#_#_#_#_#                7_#
.s;_#_#._#_#_#_#_#                2_#.5_#
.s;%%BBBB%%.%             2%4B2%.%
.s;**********.**          10*.2*
.lm-8;.s2;
.f;.le;Replication of groups of format characters by use of a
multiplier with square brackets enclosing the affected
characters.
Examples:
.s2.lm+8;.nf;The Format:              May Be Expressed as:
.s;HBHBHBHBHBHB              6[HB]
.s;$Z,ZZZ,ZZZ                $Z2[,3Z]
.s;DHDH 3WB3WB               2[DH] 2[3WB]
.s;XAXA                      2[XA]
.f.lm-8
.s2;Up to four levels of nesting within brackets are allowed.
The format
.s.i5;10 K$ = "2[2[YD]B]"
.s;is equivalent to the format:
.s.i5;10 K$ = "YDYDBYDYDB"
.s;A minus sign in a format field is interpreted as the static
minus sign formatting character and does not apply to the replication
count.
Thus the string "-2[DB]#3D/" is interpreted as "-DBDB#3D/".
.p;A replication count of zero is legal.
.p;The characters E, K, V and the period (.) cannot be replicated.
.le;Replication of fields, by use of a multiplier
with parentheses enclosing the affected fields.
Examples:
.s2;.lm+8;.nf;The Format:             May Be Expressed As:
.s;DD   DD   DD               3(DD)
.s;3Z B 3Z B 3Z B             3(3Z B)
.s;3%.3% 4B 3%.3% 4B          2(3%.3% 4B)
.f.lm-8
.p;Parentheses may be nested up to four levels.
.p;Fields to be replicated must be set off by field separators,
such as spaces.
For example "DBD2(BY)" is illegal, and should be expressed as "DBD#2(BY)".
.end list

.page;^&FORM INPUT\&
.s2.tp10;^&Literal Text in Input Format String\&
.x literal text> in <FORM formats
.f;.p;Literal text encountered in a FORM input format causes a corresponding number
of input characters to be skipped.
The literal text itself is not printed.
Thus, if the input format "'A='3D" is used to read the input
A=666, the value accepted is 666.
If this same form is used for output, the characters A= would
be printed.
This allows the same format to be used for both input and output.
Note the following example of terminal input and output:
.S;.nf;.LM+8;_>10 IIF "'A='_#'B='_#":A,B
_>20 PIF "'A='_#'B='_#":A,B
_>RUN
XX9876,_^_^_^1234      [any two characters or spaces
A= 9876B= 1234 #########could be entered before value]

.lm-8.f
.s2;^&EOR in an Input Format\&
.x carriage returns> in <FORM formats
.x <EOR> in <FORM formats
.x / formatting character
.p;When a / symbol is used to designate an EOR in an input
FORM, TYMBASIC will seek an EOR when the / is encountered.
All input characters up to the next EOR are ignored.
.s3;^&End of FORM and FORM Rescan\&
.x rescan> in <FORM formats
.f;.p;The end of a
format string does not cause TYMBASIC to seek an EOR.
If an input format contains fewer fields than the number of variables
listed in the INPUT statement, the format will be
re-scanned from the beginning until all variables have been given
values.
.page;^&FORM OUTPUT\&
.s2.tp10;^&Literal Text in Output Format String\&
.x literal text> in <FORM formats
.s;Any literal text in a FORM output format is printed
up to the next output field in the FORM, or to the end of the
FORM format.
.s2.tp7;^&EOR in an Output Format\&
.x Carriage returns> Use of /
.x Carriage returns> Use of _\
.x line feeds> use of _\
.x line feeds> use of /
.x /> format
.x _\
.p;
A slash (/) is used in a format to generate an EOR.
Consecutive slashes may be used to generate blank lines or records.
.s2;^&End of FORM and FORM Rescan\&
.p;.f;The end of an output format string does not cause
TYMBASIC to generate an EOR.
If a FORM format contains fewer fields than
the number of expressions in the PRINT statement, the format will be re-scanned from the
beginning until all expressions have been printed.
.page;^&TREATMENT OF EOR'S\&
.x <EOR> in <FORM formats
.x carriage returns> in <FORM formats
.p;Carriage return and line feed in a file are stored
as two characters but are treated by formatting characters
as a single EOR character.
Thus, the format "7X" in the following program causes the reading
in of six characters plus a CR/LF treated as a single carriage return character.
After the execution of line 40, the value of LOC(1) in line 50
is 9 (i.e. the character G), indicating that the EOR
stored after the character D is treated in the file as two characters.
The file FILIN.x containing the characters
.p;.i8;ABCD(CR)(LF)
.i8;EFGHIJ(CR)(LF)
.p;is read by the program F.DAT as follows:
.tp20;.nf;.p;.LM+8;_>GET F.DAT-A
_>LIST
10 STRING A
20 OPEN "FILIN.x-A", RANDOM INPUT , 1
30 PRINT LOC(1)
40 INPUT FROM 1 IN FORM "7X":A
50 PRINT LOC(1)
60 PRINT "A=":A
70 CLOSE 1
80 END
.P;
_>RUN
 1
 9
A=ABCD
EF
.P;
END in line 80
.f.lm-8
.page
.title TYMBASIC REFERENCE MANUAL        TYMBASIC KEYWORDS
.ft
.page size +5
.subtitle 1 January 1978                                               App. A
.C;APPENDIX A.   TYMBASIC KEYWORDS
.P;.F;The following keywords are reserved in TYMBASIC, and
cannot be used as user-defined identifiers.
.s;.lit
ABS          DET          IIM          OPEN         SIMPL
ACOS         DIM          IMAG         OR           SIN
ADD          DIV          IMAGE        ORIF         SINH
AKA          DLIST        IMP          OUTPUT       SIZE
ALL          DO           IN           PAUSE        SPACE
AND          DOUBLE       INC          PDIF         SQR
ARSH         DPI          INDEX        PHASE        SQRT
AS           DUMP         INIT         PI           START
ASC          ECHO         INITIALIZE   PIF          STARTPOINT
ASCTABLE     EDIT         INPUT        PIM          STEP
ASIN         EIGHTI       INT          PMC          STOP
AT           EIGHTO       INTEGER      POLAR        STR
ATAN         ELSE         INV          POS          STRING
ATN          ENCODE       IO           PRINT        SUB
BAN          END          IP           PROD         SUBSTR
BASE         ENDF         IXASC        PROTECTION   SUM
BEX          ENDFILE      IXCHAR       PWR          SYMBOLIC
BINARY       ENDIF        LEFT         QUIT         SYMD
BLISS        ENTER        LENGTH       RANDIN       TAB
BOR          ENTRY        LET          RANDIO       TABS
BOUNDARY     EPS          LGT          RANDOM       TAN
BREAK        EQV          LIBRARIES    RANDOUT      TANH
BY           ERASE        LIBRARY      RCY          TBA
CALL         ERR          LIST         READ         TCP
CDE          ERRCD        LJUST        REAL         TERM
CFO          ERRFL        LOC          REFS         TEXT
CHAR         ERRLN        LOCATE       REL          THEN
CHARTABLE    ERRMSG       LOG          REM          TIME
CIB          ERROR        LOG10        REMARK       TO
CLOSE        ESCAPE       LOGICAL      REMOVE       TOF
CMPLX        EXIT         LOL          REN          TOUT
             EXP          LOS          RENAME       TRACE
COMP         EXTERNAL     LPAD         RENUMBER     TRANSFORM
COMPLEX      F40          LSH          RESTORE      TRN
CON          FALSE        MAP          RESUME       TRU
CONJ         FILE         MAT          RETURN       TRUE
COPY         FIX          MATH         RIGHT        UNLESS
COS          FOR          MAX          RJUST        UNTIL
COSH         FORM         MERGE        RND          VAL
COUNT        FP           MIN          ROUN         VERSION
DATA         FROM         MOD          ROUND        WAIT
DATAEND      GET          MODIFY       RPAD         WHERE
DATE         GO           MODULE       RPT          WHILE
DBL          GOSUB        MODULES      RSH          WITH
DEBUG        GOTO         MUL          RUN          WRITE
DECODE       IDN          NAME         SAVE         XASC
DEF          IF           NEXT         SEQUENTIAL   XCHAR
DEFINE       IIF          NO           SFO          XOR
DEL                       NOT          SGN          YEAR
DELETE                    ON           SIGNIFICANCE ZER
.end literal
.page size -5
.page
.title TYMBASIC REFERENCE MANUAL        RUN-PHASE ERROR MESSAGES
.ft
.page size 55
.subtitle 1 January 1978                                               App. B
.S3;.C;APPENDIX  B.  RUN-PHASE ERROR MESSAGES
.LIT

ERRCD        ERRMSG(ERRCD)
-----        -------------

  1  Expression out of bounds in ON expression GO TO or GO SUB statement
  2  Negative number used in BOUNDARY statement
  3  Negative number used in SIGNIFICANCE statement
  4  String too long
  5  Argument to CHAR must be greater than or equal to 0 and less than 128
  6  Array subscript out of bounds
  7  Vector sizes do not conform in vector product
  8  Matrix not in proper form in vector-matrix product
  9  Vector and matrix not size conformal in vector-matrix product
 10  Matrix not in proper form for matrix-vector product
 11  Vector and matrix not size conformal in matrix-vector product
 12  Matrices not conformal in matrix product
 13  Attempt to multiply or transpose matrices of more than 2 dimensions
 14  Arrays do not have the same number of dimensions
 15  Arrays do not have same number of elements in corresponding dimensions
 16  Type of base array less than type of power array
 17  Matrix is not square
 18  Operation is not defined on given types
 19  Subarray subscript out of bounds
 20  Power less than zero in matrix exponentiation
 21  Reference to undeclared array
 22  Type conversion for string arrays not defined
 23  Attempt to invert a singular matrix
 24  Subarrays do not share a common ancestor in @ operation
 25  Subarrays share no common elements in @ operation
 26  Attempt to take LOG of negative argument
 27  Attempt to take SQRT of negative argument
 28  Operand types incompatible
 29  Overflow in SINH function
 30  Overflow in COSH function
 31  Underflow in two argument ATAN function
 32  Magnitude of argument to ASIN function greater than 1
 33  Attempt to take LOG of zero
 34  Attempt to take LOG10 of a complex argument
 35  Error in EXP for complex argument
 36  Overflow in ** operation
 37  Underflow in ** operation
 38  Overflow in (complex)**(integer) operation
 39  Underflow in (complex)**(integer) operation
 40  Radius less than or equal to zero in POLAR function
 41  Overflow in complex multiplication
 42  Underflow in complex multiplication
 43  Underflow in complex division
 44  Relational operation not defined on given numeric types
 45  Overflow in TAN routine
 46  Integer overflow
 47  Integer divide check
 48  Illegal error trap
 49  Floating overflow
 50  Floating divide check
 51  Floating underflow
 52  Run time initialization error
 53  Maximum number of input streams exceeded
 54  Open not confirmed on file
 55  Cannot find file
 56  File already exists
 57  No free I/O channel for file
 58  User name too long
 59  Illegal file name
 60  Cannot find file
 61  User name does not exist
 62  Protection failure on file
 63  File is being modified
 64  Cannot rename file. (File already exists)
 65  Compiler error during operation on file directory
 66  Data error during operation on file directory
 67  Monitor error during operation on file directory
 68  Monitor error during operation on file directory
 69  Monitor error during operation on file directory
 70  Monitor error during operation on file directory
 71  Monitor error during operation on file directory
 72  Disk storage quota exceeded. Cannot open file
 73  Cannot write in directory
 74  Monitor error during operation on file directory
 75  Monitor error during operation on file directory
 76  Monitor error during operation on file directory
 77  Monitor error during operation on file directory
 78  Monitor error during operation on file directory
 79  Monitor error during operation on file directory
 80  Monitor error during operation on file directory
 81  Monitor error during operation on file directory
 82  Cannot create file in directory
 83  Monitor error during operation on file directory
 84  File number must be an integer between 1 and 20 inclusive
 85  Same file number may not be used for two files
 86  Illegal protection code
 87  Three (3) protection codes required
 88  GO SUB stack overflow
 89  GO SUB stack underflow
 90  Record length must be greater than zero
 91  Invalid option combination:
 92  TERMINAL may not be specified twice
 93  TERMINAL may not be specified
 94  File must be random
 95  File must be open for output or input-output
 96  Record number must be an integer greater than 0
 97  Last record number must not be less than the first
 98  File must be open
 99  Error number must be an integer between 1 and n inclusive
100  File number must be an integer between -9 and 20 inclusive
101  File number must be 0 for TERMINAL BINARY input output
102  Illegal character in form field
103  Too many nested parentheses
104  Unmatched ')'
105  Unmatched '('
106  Number precedes ')' ']' or space
107  Unmatched string delimiter
108  Use of numeric format with string variable is illegal
109  Invalid R form
110  Number precedes decimal point
111  Attempt to overflow fixed length record on random file
112  Invalid input or format in VAL function
113  Vacuous format
114  Ambiguous dot
115  Two decimal points in numeric field
116  Unmatched ']'
117  Unmatched '['
118  Too many nested brackets
119  Number precedes exponent indicator
120  Illegal character in integer conversion field
121  Illegal character in special string field
122  Invalid integer part in special form
123  Invalid fractional part in special form
124  Invalid exponential part in special form
125  Invalid special form field
126  Invalid use of P in special form
127  Output field descriptor is too small
128  Number too large for type conversion indicated in format
129  Number too small for type conversion indicated in format
130  Illegal character for numeric conversion
131  Illegal character in alpha formatted field
132  Illegal character in numeric formatted field
133  Illegal character in alpha or numeric formatted field
134  Use of R form with numeric variable is illegal
135  Illegal character in special radix field
136  Expecting formatted input
137  Normal terminal input not allowed during Eight-level input
138  Use of string format with a numeric variable is illegal
139  Field is valid for output only
140  Special radix must be used with an integer or logical variable
141  Complex argument to STR function is illegal
142  End of file found
143  READ statement out of DATA
144  File must be open
145  File must be open for OUTPUT or IO
146  File must be open for INPUT
147  Format specified with binary file
148  'AT' construct not valid with sequential file
149  File number must be an integer between 1 and 20 inclusive
150  Free-form I/O to fixed record length random file is illegal
151  Compiler bug: Trace UUO trapped but no trace routine loaded
152  RESUME statement before trap condition exists
153   is unimplemented
154  Dynamic Storage Area Clobbered by Re-Load
155  Interrupted
156  Cannot create .SHR file
157  Cannot create program load map
158  Upper bound must be greater than or equal to lower bound
159  Data area may not be expanded beyond 131,072 words
160  Request for more core refused by Monitor
161  Attempt to redimension a subarray
162  File number 0 may be used only for eight-level input
163  Error encountered during SORT
164  Illegal sequence of string-field characters
.END LIT
.nj
.p 0
.page
.title TYMBASIC REFERENCE MANUAL        INTRALINE EDITING
.FT
.subtitle 1 January 1978                                               App. C
.C;APPENDIX C. INTRALINE EDITING
.skip 3
.f;Line editing in the Tymbasic systems follows the standards set forth
.x LINE EDITING
in "Tymshare Intraline Editing" (TIE) of 26 November 1975.  The following
is taken from that paper.
.x editing> a line
.skip 2
Intraline editing is the process of manipulating symbolic text, one line
.x intraline editing
at a time.
The line may be simply a modification of another line (called
the "old line") or it may be a new line in its own right.
.x old line
QED-like intraline editing, the basis for TIE,  refers to a method of intraline editing using
control characters.
.x control characters
.p
.x Tymshare Editor
The behavior of intraline editing in the Tymshare Editor on the XDS-940
is the foundation for the behavior called for in TIE.
.x <tie
Thus, a person having experience with the 940 Editor or its cousin on the PDP-10
will immediately understand the TIE functions.
.p
TIE is based in part on the 940 Editor concept
of boundaries for backwards deletions.
That is, one can not 'backspace' past the beginning of an ongoing Text
Insertion.
One must complete the insertion before deleting characters which occur before
the insertion.
(This is not so on the PDP-10 Editor.)
.p
A point of departure from the 940 Editor foundation is that Tymshare
Intraline Editing follows the PDP-10 Editor convention of
displaying between backslashes those characters which are
backspaced over.
.page.c80;SUMMARY OF CONTROL CHARACTER OPERATIONS
.page size +4
.skip 2
.lm+3
.indent -3
.x Control ^A
.x control characters
Control A
.p
Backspaces in the new line and in the old line as appropriate.
It is an "un-do" operation.
Rings Bel if there are no characters left to delete in the new line or the current insertion.
.p
.x Control ^B
.indent -3
Control B
.p
In the Run phase, restarts the current Input statement, in the
Command/Statement phase rings Bel.
.p
.x Control ^C
.tp10;
.indent -3
Control C
.p
Copies and prints the next character from the old line
to the new line.
If there are no more characters to copy, rings Bel.
.p
.x Control ^D
.indent -3
Control D
.p
Copies and prints the rest of the characters from the old line, if any,
to the new line, prints a Carriage Return and Line Feed, and terminates
the line.
.p.i-3;Control E
.p;Starts a Text Insertion or completes one in progress,
printing "_<" or "_>".
.x Control ^E
.p
.x Control ^F
.indent -3
Control F
.p
Copies (without printing) the rest of the characters from the old line,
if any, to the new line, prints a Carriage Return and Line Feed, and
terminates the line.
.p
.x Control ^G
.indent -3
Control G
.p
In the Run phase, acts as an activation character on input,
like a carriage return.
In the Command/Statement phase rings Bel.
.p
.x Control ^H
.indent -3
Control H
.p
Same as Control A.
.p
.x Control ^I
.indent -3
Control I
.p
Enters enough spaces into the new line to reach the next tabstop or one
space if no tabstops are defined beyond the current position.
.p
.x Control ^J
.x Line Feeds
.indent -3
.tp4
Control J####(Line Feed)
.s
Same as carriage return, except that on the next input the old line image
will be the remainder of the current old line image.
.p
.x Control ^K
.indent -3
Control K
.p
Deletes and prints the next character in the old line, if any; otherwise,
rings Bel.
.p
.x Control ^L
.indent -3
Control L
.p
Copies but does not print the  rest of the characters from the old line,
if any, to the new line and then prints a plus sign.
Rings Bel if there are no more characters to copy.
.p
.x Control ^M
.x Carriage returns
.indent -3
Control M####(Carriage Return)
.p
Prints a Carriage Return and Line Feed and terminates the line.
.p
.x Control ^N
.tp10;
.indent -3
Control N
.p
Copies and prints the rest of the characters from the old line to the new
line, if any; otherwise, rings Bel.
It does not terminate the line; thus, editing may continue at the end
of the line.
.p
.x Control ^O
.indent -3
Control O
.p
Copies and prints characters from the old line to the new line up to but not
including the  next character typed.
Searches for the character from two characters beyond the current old line pointer.
Rings Bel if not found.
.p
.x Control ^P
.indent -3
Control P
.p
Deletes and prints "%" for each character in the old line up to but not
including the next character typed.
Searches for the character from two characters beyond the current old line pointer.
Rings Bel if not found.
.p
.x Control ^Q
.indent -3
Control Q
.p
If typed at the beginning of the line is a request to back up a line in an
insert or append.
Otherwise, deletes characters backwards up to the beginning of the new line
or the beginning of an ongoing insertion and prints "_^".
If no insertion was in progress, also prints a Carriage Return.
Backspaces in the old line as appropriate.
Rings Bel if there are no characters to delete.
.p
.x Control ^R
.indent -3
.tp 6
Control R
.p
Prints the remainder of the old line and then the prompt and the contents of the new line
on the next line, lining up the beginning of the remainder of the old line
with the end of the new line.
Never prints a line of just spaces.
.p
.x Control ^S
.indent -3
Control S
.p
Deletes the next character in the old line if any and prints
"%".
Otherwise, rings Bel.
.p
.x Control ^T
.indent -3
Control T
.p
Not implemented.
.p
.x Control ^U
.indent -3
Control U
.p
Copies characters from the old line if any, or enters spaces, into
the new line until the next tabstop is reached.
.p
.x Control ^V
.tp10
.indent -3
Control V
.p
In the Run phase, enters a control character (including Carriage Return or
Line Feed) into the new line.
If an alphabetic character is typed, enters its opposite case.
In the Command/Statement phase rings Bel.
.p
.x Control ^W
.indent -3
Control W
.p
Backspaces past spaces, then past all characters up to a space or to the
beginning of the line or ongoing insertion.
Rings Bel if there are no more characters left to backspace over.
Backspaces in the old line as appropriate.
.p
.x Control ^X
.indent -3
Control X
.p
Deletes and prints "%" for each character in the old line
up to and including the next character typed.
Searches for the character from one character beyond the current old line position.
Rings Bel if not found.
.p
.x Control ^Y
.indent -3
Control Y
.p
Replaces the old line image with the contents of the new line, prints a prompt and continues
the edit at the beginning of the new line.
.p
.x Control ^Z
.indent -3
Control Z
.p
Copies and prints characters from the old line to the new line up to and
including the next character typed.
Searches for the character from one character beyond the current old line position.
Rings Bel if not found.
.lm-3
.page
.page size -4
.center 80
COORDINATED BACKSPACING
.skip 3
.f;Coordinated Backspacing means that the cursor in the old line
.x backspacing> in line editing
is kept synchronized to the movements of the new line cursor.
That is, after backspacing to a certain point in the new line the cursor
in the old line will be at the same position as it was when the new line
cursor was last at its current position.
.x Control ^H
.x Control ^A
.x Control ^W
.x Control ^Q
.x Coordinated Backspacing
Coordinated backspacing applies to Control-A, Control-H, Control-W, and Control-Q.
.p
Each character in the new line may or may not be associated with a character
in the old line.
If a new line character was part of an insertion or if it
was entered at a time when there were no more characters in
the old line, it is not paired with an old line character.
Otherwise, it is.
Likewise, a character in the old line may be associated with a new line
character.
.x Control ^S
.x Control ^K
.x Control ^P
.x Control ^X
If an old line character was deleted by Control-S, -K, -P
or -X, then it has no association with a new line character.
Otherwise, any character behind the old line
cursor is paired with a new line character.
.p
In backspacing over a character in the new line, the old line cursor
is backed up until it backspaces over the corresponding character
in the old line, if there is such an association.
Otherwise, the old line cursor is not changed.
Thus, coordinated backspacing "erases" the previous copies, replacements,
or insertions.
.s2;Example:
.s2
.lit
>30E
30 print a(old) for old = 1 to 5
Oo30 print a(nwA\w\ewD for old = 1 to 5
>LIST 30
30 print a(new) for old = 1 to 5
>

.end lit
.s;The Control A removed the "w" from the new line and also backspaced past
the "l" in the old line so that the Control D functions properly.
.page
.s;To illustrate further, a more complicated example:
.s2
.lit
>30E
30 a = old.line
Oo30 a = E<third.N>old.lineW\enil.dlo.drihtE\<second.D>old.line
>LIST 30
30 a = second.old.line
>
.end lit
.s;In this example, the user inserts "third." in front of "old.line",
copies to the end of the old line and then decides to change "third." to "second.".
He backspaces past the identifier "third.old.line" and then inserts
"second." and copies again to the end of the old line.
Note that  backspacing over "third." did not cause any backspacing in the
old line; after backspacing over "third." the user was left in the same
position he was in before typing "third." originally.
Thus, when he copied to the end of the old line after inserting
"second.", the first characters to be copied were "old".
.page
.x Carriage returns
.x Line Splitting
.x Control ^V
.x Control ^J
.skip 3
.center 80
DIFFERENCES FROM THE BEHAVIOR OF THE 940 EDITOR
.s
.page size +4
.p;Carriage Return is not, as in the 940 Editor, the last character of
.x editor> differences from <IX system
each line.
A line is defined by its length, not an internal delimiter.
Thus, the operation of a control character never ends a line by
copying through the end of the old line.
The following control characters had this 'copy line end' property on
the 940 Editor:
.break
.indent 5
.skip 1
C, U, and Z.
.skip 1
They do not have this property in Tymshare Intraline Editing.
.p
The ability to mention the end of the line by reference to Carriage Return
is not supported, as there is no Carriage Return to reference (example:
Control-O Control-M; copy up to end of line).
.x Differences, from 940 Editor
.x 940 Editor
.x Control ^G
.x Control ^B
.x Control ^Y
.x Control ^R
.x Control ^T
.x Control ^V
.x Control ^J
.x Control ^D
.x Line Splitting
.s;Other differences:
.list
.le;Control-T is not implemented; Control-R is to be used
instead.
.le;Any behavior which was deemed to be a bug was fixed for the
Tymshare Intraline Editor.
.le;Control-J no longer enters a Line Feed into a line.
It is now a "line-split" character.
.le;Control-U copies either characters from the old line  image,
or spaces, to the new line, up to the next tabstop.
In other words, the behavior of Control-U converges with that of Control-I.
The 940 Editor behavior of copying line end is, of course, not TIE behavior.
Also, on the 940, Control-U is a No-op if there are no characters
to copy.
TIE Control-U is never a No-op (nor a BEL) in the normal case (no
Line Overflow).
If there are no more (expicitly defined) tabstops, the next tabstop is defined
as the next column, as in the 940 Editor.
.le;Control-R never completes a Text Insertion.
Instead, a '<' is printed at the correct spot in the new line
to mark the beginning of the insertion.
.le;Control-R never prints a line of only spaces (this frequently occurs
during processing of long lines).
.le;Control-N now has the function Control-H had on the 940.
Control-H is a backspace character and is identical to Control-A.
.x Control ^N
.x Control ^H
.le;Control-Y no longer copied the remainder of the old line.
.x Control ^Y
.end list
.page
.page size -4
.x BEL
.x No-op
.x Line Overflow
.center 80
BEL AND NO-OP
.skip 2
BEL (Control-G) is sent to the Physical Terminal when an operation is requested that
can not be fulfilled (operation is here defined as any logical
function except the simple typing in of a text character).
Request for
an operation that would cause Line Overflow produces a BEL response.
Any operation which produced BEL is a No-op; i.e., the state of editing
is precisely the same as if no operation had been requested.
Conversely, any operation which is a No-op always produces a
BEL response.
The following requests produce a BEL response
according to the accompanying conditions:
.break
.skip 1
.left margin +10
.indent -5
Any operation which, if performed, would cause Line Overflow.
.skip 1
.left margin +12
.indent -17
Or any of the following:
.break
.x Control ^A
.x Control ^B
.x Control ^C
.x Control ^D
.x Control ^E
.x Control ^F
.x Control ^G
.x Control ^H
.x Control ^I
.x Control ^J
.x Control ^C
.x Control ^U
.x Control ^Z
.x Control ^K
.x Control ^L
.x Control ^M
.x Control ^N
.x Control ^O
.x Control ^P
.x Control ^Q
.x Control ^R
.x Control ^S
.x Control ^T
.x Control ^U
.x Control ^V
.x Control ^W
.x Control ^X
.x Control ^Y
.x Control ^Z
.skip 1
.indent -12
Control-A:##backwards deletion boundary is met.
.indent -12
Control-B:##if unimplemented.
.indent -12
Control-C:##no characters to copy.
.indent -12
Control-D:##never.
.indent -12
Control-E:##never.
.indent -12
Control-F:##never.
.indent -12
Control-G:##always.
.indent -12
Control-H:##backwards deletion boundary is met.
.indent -12
Control-I:##never.
.indent -12
Control-J:##never.
.indent -12
Control-K:##no characters to delete.
.indent -12
Control-L:##no characters to copy.
.indent -12
Control-M:##never.
.indent -12
Control-N:##no characters to copy.
.indent -12
Control-O:##specified character not found in rest of old line image.
.indent -12
Control-P:##specified character not found in rest of old line image.
.indent -12
Control-Q:##backwards deletion boundary is met.
.indent -12
Control-R:##never.
.indent -12
Control-S:##no characters to delete.
.indent -12
Control-T:##always.
.indent -12
Control-U:##never.
.indent -12
Control-V:##if unimplemented.
.indent -12
Control-W:##backwards deletion boundary is met.
.indent -12
Control-X:##specified character not found in rest of old line image.
.indent -12
Control-Y:##never.
.indent -12
Control-Z:##specified character not found in rest of old line image.
.lm-12
.lm-10
.page
.x Text Insertion
.x Control ^E
.x Control ^A
.x Control ^Q
.x Control ^C
.x Control ^D
.x Control ^E
.x Control ^F
.x Control ^H
.x Control ^J
.x Control ^K
.x Control ^L
.x Control ^M
.x Control ^N
.x Control ^O
.x Control ^P
.x Control ^S
.x Control ^U
.x Control ^X
.x Control ^Y
.x Control ^Z
.x Line Termination
.x termination> line
.x Carriage returns
.x Line Feeds
.x Line Overflow
.x Backwards Deletion
.x BEL
.center 80
TEXT INSERTIONS
.skip 2
Text Insertions, started and completed by typing Control-E,
are characterized by the property that the characters inserted are not
.x 940 Editor
considered to have counterparts in the old line (the 940 Editor is the basis for this definition).
.p
This property has the following corollaries:
.lm+4
.p
.indent -4
1.##Inserting characters into the new line does not
advance the old line cursor.
.p
.indent -4
2.##Backspacing within an insertion, even with Control-A or Control-Q, does
not decrement the old line cursor.
.p
.indent -4
3.##Any operation which forces the forward movement of the old line cursor
(such as Control-C or Control-X)
first completes the insertion.
.p
.indent -4
4.##Any operation which terminates a line completes the insertion.
The ending '_>' is always output, except after Carriage Return, Line Feed,
and Line Overflow.
.skip 1
.p
.i-4;Text Insertions are completed by the following operations:
.skip 1
.p
.indent -4
1.##Any operation terminating a line, including Line Overflow.
.indent -4
2.##Control-C  if successful (i.e., there is no BEL response).
.indent -4
3.##Control-D  always.
.indent -4
4.##Control-E  always.
.indent -4
5.##Control-F  always.
.indent -4
.indent -4
6.##Control-J  always ( '_>' not printed).
.indent -4
7.##Control-K  if successful.
.indent -4
8.##Control-L  if successful.
.indent -4
9.##Control-M  always ( '_>' not printed).
.indent -4
10.#Control-N if successful.
.indent -4
11.#Control-O  if successful.
.indent -4
12.#Control-P  if successful
.indent -4
13.#Control-S  if successful.
.indent -4
14.#Control-U  always.
.indent -4
15.#Control-X  if successful.
.indent -4
16.#Control-Y  always.
.indent -4
17.#Control-Z  if successful.
.skip 1
.lm-4
.p
A deletion within a text insertion always has a backwards boundary at
the point of the beginning of the insertion.
Attempts to backspace beyond the beginning of an insertion
.x Control ^A
.x Control ^N
.x Control ^W
.x Control ^Q
(using Control-A, -H, -W, or -Q) always
invoke a BEL response.
.page
.x Backwards Deletion
.x Backslashes
.x Control ^H
.x Control ^Q
.x Control ^A
.x Control ^W
.x Text Insertion
.x Backwards Boundary
.x Backwards Deletion> Completion
.center 80
BACKWARDS DELETIONS
.s
Backwards Deletion characters: Control-A, Control-H, Control-W, Control-Q.
.p
Backwards Deletions, whose printed output is delimited by a pair of backslashes,
are characterized by backspacing either the cursor in the new line
image, or both cursors in new and old images.
Control-A, Control-H, Control-Q, and Control-W may backspace in the old
image as well as the new unless
a Text Insertion is in progress.
.p
The completion of a Backwards Deletion is signalled by the printing of a
closing backslash.
.p
Backwards Deletions follow these conventions:
.lm+4
.skip 2
.indent -4
1.##Backwards Deletions within a Text Insertion are always bounded by the beginning of that
Insertion or the beginning of the new line image, whichever comes first as the deletion proceeds.
.skip 1
.indent -4
2.##Old line cursor is not changed by the operation of any Backwards Deletion
control characters (or any other operator) during Text Insertions.
.skip 1
.indent -4
3.##Backwards Deletions are always completed by any successful
non-deletion operation.
.skip 1
.indent -4
4.##The only addition to 3 is that Backwards Deletions are completed when,
in the process of deletion, a backwards boundary is met (the beginning of the line or the start of a Text Insertion).
.lm-4
.x Line Overflow
.x BEL
.x No-op
.x Tymshare Editor
.s3
.center 80
LINE OVERFLOW
.s
Line Overflow is the condition created when type-in of
a text character attempts to place more than 256 characters in the new line image buffer.
.p
Line Overflow behavior is as defined in the Tymshare Editor Manual
except for the following convention:
.break
.p
If overflow would be caused by the operation of a control character, then
that operation is then re-interpreted as a No-op, and invokes
a BEL response.
.s4
.x Prompting
.x Control ^R
.x Control ^Y
.x Control ^Q
.x Control ^A
.x Control ^N
.x Control ^W
.tp10
.center 80
PROMPTING
.skip 3
.x editor> prompting
.p
The  Tymshare Intraline Editor prompts to the Physical Terminal under the following
circumstances:
.skip 3
.lm+8;
1.##At the beginning of new line entry.
.skip 2
2.##During the operation of Control-R and Control-Y.
.lm-8
.s4
.center 80
LINE TERMINATION
.skip 3
.p
.x Line Termination
.x termination> line
.x Carriage returns
.x Line Feeds
.x Control ^D
.x Control ^F
.x Control ^Q
.x Control ^J
.x Line Splitting
.x 940 Editor
Line Termination is caused by any of the following control characters:
Control-D, Control-F, Control-J(Line Feed), Control-H
(carraiage return).
Line overflow caused by type-in of a text character also causes
line termination.
.FILL
.p
Line Termination does NOT occur, as it may on the 940 Editor,
after the following control characters:
.p
.indent 5
Control-C
.indent 5
Control-U
.indent 5
Control-Z
.s4
.center 80
Influence on Intraline Editing of
.center 80
Presence of Control Characters in Line Images
.skip 3
.x Control Characters
.x DEL
If control characters and the character DEL are allowed in TIE line
images then the following type-out rules apply within TIE:
.lm+4
.nofill
.s2
All control characters print as     "_&" followed by their
                                  alphabetic interpretation
.skip 1
DEL     prints as               DEL
.skip 2
.lm-4
.fill
.p
.x Control ^R
Control-R will assume that DEL has no effect on the print
position at the device.
.p
.x Control ^I
.x Control ^U
The computation of print position employed by Control-I and Control-U
to determine the next tabstop follows this set of target type-out
rules:
.lm+4
.nofill
.x Carriage returns
.x Line Feeds
.x Control ^I
.x DEL
.skip 2
.p
Carriage Return would print as Carriage Return  Line Feed
.skip 1
.s;
Control-H                   as a backspace
Control-I                   as spaces to the next tabstop
.skip 1
.f
All other control
characters and DEL would have no effect on print position
.lm-4
.fill
.FLAG UNDERLINE
.FLAG INDEX
.LM 0 .RM 74 .NJ .P0
.title TYMBASIC REFERENCE MANUAL        CHARACTER CODES
.subtitle 1 January 1978                                                    App. D
.page
.TAB STOPS 4,8,36,40,50,56
.c;APPENDIX D.
.page size +1
.NF;.S2;.C;^&TABLES OF XASC, XCHAR, IXASC, AND IXCHAR VALUES\&
.S2;   XASC XCHAR                      XASC XCHAR     XASC  XCHAR
.S2;	 0	Nul 	43	+	 86	V
	 1	Control A	44	,	 87	W
	 2	Control B	45	_- (minus)	 88	X
	 3	Control C	46	_.	 89	Y
	 4	Control D	47	_/	 90	Z
	 5	Control E	48	0	 91	[
	 6	Control F	49	1	 92	_\
 	 7	Control G(Bell)	50	2	 93	]
	 8	Control H(Backspace)	51	3	 94	_^ or
	 9	Control I(Tab)	52	4	 95	__ or  (underline)
	10	Control J(Line feed)	53	5	 96	_` (accent grave)
	11	Control K(Vert tab)	54	6	 97	a
	12	Control L(Form feed)	55	7	 98	b
	13	Control M(Carriage return)	56	8	 99	c
	14	Control N	57	9	100	d
	15	Control O	58	:	101	e
	16	Control P	59	;	102	f
	17	Control Q	60	_<	103	g
	18	Control R	61	=	104	h
	19	Control S	62	_>	105	i
	20	Control T	63	?	106	j
	21	Control U	64	@	107	k
	22	Control V	65	A	108	l
	23	Control W	66	B	109	m
	24	Control X	67	C	110	n
	25	Control Y	68	D	111	o
	26	Control Z	69	E	112	p
	27	Control [(escape)	70	F	113	q
	28	Control _\	71	G	114	r
	29	Control ]	72	H	115	s
	30	Control _^	73	I	116	t
	31	Control __	74	J	117	u
	32	space	75	K	118	v
	33	!	76	L	119	w
	34	"	77	M	120	x
	35	_#	78	N	121	y
	36	_$	79	O	122	z
	37	_%	80	P	123	{
	38	_&	81	Q	124	|
	39	_' (single quote)	82	R	125	}
	40	_(	83	S	126	_~
	41	_)	84	T	127	Del (rubout)
	42	*	85	U
.PAGE
.TAB STOPS 4,8,26,30,48,54
.c;^&TYMCOM-IX CHARACTER CODES\&
.page size -1
.S2;  IXASC IXCHAR          IXASC IXCHAR           IXASC  IXCHAR
.s;
	 0	SPACE	43	K	 86	v
	 1	!	44	L	 87	w
	 2	"	45	M	 88	x
	 3	_#	46	N	 89	y
	 4	$	47	O	 90	z
	 5	%	48	P	
	 6	_&	49	Q	 92	|
	 7	' (single quote)	50	R	
	 8	(	51	S	 94	~
	 9	)	52	T	 95	rubout (end of file
	10	*	53	U	 	file character)
	11	+	54	V	 96	Nul  (control _@)
	12	,	55	W	 97	Control A
	13	- (minus)	56	X	 98	Control B
	14	_.	57	Y	 99	Control C
	15	/	58	Z	100	Control D
	16	0	59	[	101	Control E
	17	1	60	_\	102	Control F
	18	2	61	]	103	Control G
	19	3	62	_^ or	104	Control H
	20	4	63	__ or  (underline)	105	Control I
	21	5	64	_` (accent grave)	106	Control J
	22	6	65	a	107	Control K
	23	7	66	b	108	Control L
	24	8	67	c	109	Control M
	25	9	68	d	110	Control N
	26	:	69	e	111	Control O
	27	;	70	f	112	Control P
	28	_<	71	g	113	Control O
	29	=	72	h	114	Control R
	30	_>	73	i	115	Control S
	31	?	74	j	116 	Control T
	32	_@	75	k	117	Control U
	33	A	76	l	118	Control V
	34	B	77	m	119	Control W
	35	C	78	n	120	Control X
	36	D	79	o	121	Control Y
	37	E	80	p	122	Control Z
	38	F	81	q	123	Control _[ (escape)
	39	G	82	r	124	Control _\
	40	H	83	s	125	Control ]
	41	I	84	t	126	Control _^
	42	J	85	u	127	Control __(abort)
.fill
.title TYMBASIC REFERENCE MANUAL        EXTERNAL PROCEDURES
.subtitle 1 January 1978                                                    App. E
.page
.c;APPENDIX E. EXTERNAL PROCEDURES
.x Procedures> external
.x Other-language procedures
.p;TYMBASIC programs can call external functions/procedures written in SFORTRAN,
FORTRAN-10, F40 (CFORTRAN), SIMPL, BLISS, COBOL, or MACRO.  The
other-language functions used should be compiled using normal XEXEC
commands, then the .REL file(s) should be named in a MODULE or LIBRARY
.x <MODULE;.x <LIBRARY;.x <REL file
statement.  The TYMBASIC program should contain appropriate DEF EXTERNALs.
.x functions;.x procedures;.x <SFORTRAN;.x <FORTRAN-10;.x <F40;.x <SIMPL
.x <CFORTRAN;.x <BLISS;.x <COBOL;.x <MACRO;.x <DEF;.x <EXTERNAL
.p;Each of these languages has some restrictions on the kinds of data
used for arguments and return values.  In general,
.s;.lm+3;Numeric scalars may always be used.  The various Fortrans have
   corresponding data types, and numeric scalar arguments and return
   values are straightforward.  SIMPL and BLISS have no data types as
   such and deal only with machine words; see the descriptions of
   these languages.
.s;Numeric arrays (whole arrays or array expressions) may be passed to
   any of the languages; subarrays may not be used with the Fortrans.
   The Fortrans are passed the address of the body of the array;
   the other languages get the address of the descriptor.
.s;String scalars may be passed as arguments to all the languages.
   For the Fortrans the address of the string body is passed.
   The others get the address of the string descriptor.
.x <STRING
.s;String arrays may not be passed to the Fortrans.
   The other languages can handle them if they interpret the
   descriptors themselves (the address of the descriptor is passed).
.lm-3;.s1
.p;A String Descriptor is a two-word entity.  The first word contains the
.x Strings> string descriptor;.x Strings> string body
address of the string body (which always begins on a word boundary).
The second word consists of two halfwords:  the left half is the current
length in characters and the right half is the declared maximum length
of the variable (same as the left half for expressions and constants).
The string body is in ASCIZ format.
.x <ASCIZ
Array descriptors are discussed in Appendix F.
.x Arrays> array descriptor
.page;.c;^&SFORTRAN, FORTRAN-10, F40 (CFORTRAN)\&
.x <SFORTRAN;.x <FORTRAN-10;.x <F40;.x <CFORTRAN
.p;The three Fortrans are similar in the kinds of data that may be passed
back and forth; these comments apply to all three unless otherwise noted.
.p;Arguments to Fortran procedures are passed by reference.  If the Fortran
procedure stores into an argument it will change the TYMBASIC caller's
variable.  Two restrictions that apply here are that string variables
and string or numeric constants may not be altered by a Fortran
procedure.  Example:
.s;.lm+9;SUBROUTINE FORSUB(A,B,C)
.br;A=3
.br;CALL XYZSUB(B)
.br;END
.lm-9;.s
The actual argument (in TYMBASIC) for C could be a real variable, expression,
or constant.  A and B could not be constants.  A is obviously modified by
the subroutine; B is not explicitly changed but is passed to another
subroutine which could possibly store into it, so it is assumed to be
modified.
.p;Numeric or logical scalars all work with no special handling if declared to
be the same type in both the TYMBASIC DEF and the Fortran subroutine.
The one slight incompatibility is using double precision with
F40.  TYMBASIC and F40 use different hardware representations for
double precision numbers:  TYMBASIC uses "hardware format", F40 uses
"software format", which has about two decimal digits less precision.
TYMBASIC will automatically convert between the two formats on both call and
return, but values returned from F40 will be
inaccurate in the last few digits.
.p;Numeric arrays may be passed as arguments to any of the Fortrans, except
that double precision arrays may not be passed to F40 (the conversion
described for double precision scalars is not performed for arrays).
.p;The Fortran subroutine being called may declare the array with
constant bounds if the size is known, or the dimensions may be
passed as separate arguments (this is the same technique used by
an all-Fortran program).  IMPORTANT: If an array has more than one dimension,
the array declaration and references in the Fortran routine must list
the subscripts in the opposite order from that used in the TYMBASIC program.
.x Arrays> subscripts
.x Arrays> subscripts
This is because the two languages store the array elements in memory
differently:  TYMBASIC varies the last subscript most rapidly; Fortran
varies the first subscript most rapidly.
.p;Care must be taken with the BASE statement in TYMBASIC - Fortran has a default
.x <BASE
base of one for each dimension just like TYMBASIC, but if that is changed with
the BASE statement, each Fortran routine must have the lower bound
declared explicitly to match.
.p;String scalars (not arrays) may be passed to any of the Fortrans
by declaring the appropriate argument in the DEF EXTERNAL as a
.x <DEF
.x <SFORTRAN
STRING variable.  The string is passed to Fortran in the same way that
Fortran passes a Hollerith constant, and may be received as a
numeric scalar or array.  This is true for SFORTRAN as well - the string
isn't a STRING variable as used in SFO, just a Hollerith constant.
.p;Restrictions on the use of Fortran routines:
.br;##The Fortran code may not do any I/O.
.x <I/O> in other language procedures
.br;##SFORTRAN code may not use any STRING variables.
.s;Example:
.s;.lm+3;(TYMBASIC)
.br;10 DEF INTEGER EXTERNAL F40 BONZ(INTEGER(ARY(*,*),M,N,I,J))
.br;20 BASE 0
.br;30 INTEGER HOOHOO(3,7)
.br;40 HOOHOO(I,J) = I*10+J FOR I = 0 TO 3 FOR J = 0 TO 7
.br;50 PRINT BONZ(HOOHOO,3,7,2,4)
.br;60 END
.s;(F40)
.x <F40
.br;.lm+8;INTEGER FUNCTION BONZ(ARY,M,N,I,J)
.br;.i-8;C returns the value of ARY(I,J) where ARY is dimensioned 0:M,0:N
.br;.i-8;C in TYMBASIC terms.  Note the reversal of all subscripts here.
.br;INTEGER M,N,I,J,ARY(0/N,0/M)
.br;BONZ = ARY(J,I)
.br;RETURN
.br;END
.lm-8
.lm-3
.s3;.c;^&COBOL\&
.p;COBOL and Superfortran have the same calling conventions.
To define a COBOL procedure, use a DEF EXTERNAL SFO in TYMBASIC.
.x <COBOL;.x <DEF;.x <SFO
Passing of arguments follow the SFO restrictions listed above.
TYMBASIC and COBOL data types do not always correspond. For example,
COBOL has no complex or double precision type while TYMBASIC has no two
word integer type.
.page;.c;^&TBA CALLING SEQUENCE\&
.x <TYMBASIC calling sequence
.p;Each TBA procedure has a parameter vector, a block in the low segment which
.x parameter vector
holds the data local to the procedure.
The first word of the parameter vector holds the procedure's return address.
The second word is used to hold the call time value of register 16 (octal)
which must be preserved across procedure calls.
Successive groups of words hold the parameters in the order they appear in the
DEF. The number of words allocated for each parameter depends upon the type
.x <DEF
of that parameter.
Numeric scalars are allocated one or two words (two for double or complex).
When the procedure is called, the value of the scalar argument is stored
into its allocated portion of the parameter vector.
.p;Two words are allocated for a string parameter to hold a string descriptor.
.x Strings> string descriptor
At call time, a block of memory is allocated into which
the contents of the argument body is copied.
.x Arrays> array body
The string descriptor is then set so that it points to this new body.
.p;For an array parameter, two items are allocated in the parameter vector.
First, one word is used to point to the array descriptor being used for the
.x Arrays> array descriptor
parameter. Following the array pointer word, space is reserved for a 
descriptor of the appropriate dimensionality.
When an array parameter is passed by name, the pointer word is set to the 
address of the descriptor of the argument array.
When an array is passed by value, a copy of the array body is made and the
descriptor in the parameter vector is set to describe that copy.
The pointer word is set to point to the parameter
vector descriptor.
References to an array parameter within a
procedure are carried out indirectly through the pointer word.
.p;After storing the arguments into the parameter vector, the procedure is
called with a JSP 1, .
For string and array valued procedures, the JSP is followed by a word
containing the address of the descriptor for the resulting string
or array.
For procedures defined with a DEF ENTRY, the procedure code is preceeded by a
word containing the address of the third word of the parameter vector (the
location of the first parameter).
.p;The procedure starts with two MOVEMs which save the contents of register
1 (the return address) and register 16 (octal) in the parameter vector.
The procedure ends with a MOVE that restores register 16 and a JRST to
the return address.
.page;.c;^&SFO AND CFO CALLING SEQUENCES\&
.p;The SFO calling sequence is used for SFORTRAN, FORTRAN-10, and
.x <SFO;.x <SFORTRAN;.x <FORTRAN-10
COBOL. Parameters are placed in an argument list with one word
.x <COBOL
per parameter. The left half is a type code, the right half is
the address of the argument.
The argument list is preceded by a word containing, in its left
half, the negative of the number of entries in the list.
The address of the first argument in the list is placed in register 16 and
then the routine is called with a PUSHJ 17,.
.s1;.i+6;in hiseg##########################in loseg
.i+38;-number of entries,,0
.i+3;MOVEI 16,ARGLST############ARGLST: type,,address
.i+3;PUSHJ 17,routine name###############type,,address
.i+43;#.
.i+43;#.
.br;The type codes for SFO are:
.i+3;logical##40b
.i+3;integer##100b
.i+3;real#####200b
.i+3;double###400b
.i+3;complex##600b
.i+3;string###740b
.s2;The argument list of the CFO and F40 calling sequence immediatley
.x <CFO;.x <F40;.x <CFORTRAN
follows the call. This requires the call and argument list to be in the
loseg. The argument list has one word per argument consisting of
the ARG no-op (same as a JUMP), a type code in the ac field and the
address of the argument in the address field.
The routine is called with a JSA 16,.
.s;.i+6;in hiseg###########################in loseg
.i+3;HILOC: JRST LOLOC###########LOLOC: JSA 16,routine name
.i+40;ARG type,,address
.i+40;ARG type,,address
.i+48;.
.i+48;.
.i+40;JRST HILOC+1
.s;The type codes for CFO/F40 are:
.i+3;0 - integer
.i+3;2 - real
.i+3;3 - logical
.i+3;5 - hollerith (string)
.i+3;6 - double precision
.i+3;7 - complex argument
.page;.c;^&SIMPL\&
.x <SIMPL
.p;SIMPL routines must be compiled with the (,P) switch to use the
PUSHJ calling sequence rather than the JSP calling sequence:
-COM FOO(,P) where FOO.SIM contains SIMPL routines to be called by TYMBASIC.
.p;Numeric and logical scalar arguments may be passed to SIMPL
with these precautions:
.p;.lm+3;SIMPL has no data types as such, and normally performs
integer arithmetic on variables.
 TYMBASIC will convert data to the type specified in
the DEF EXTERNAL.  Logicals are passed as 0 for false, 1 for true.
.p;Double and complex arguments take two words each in machine
representation.  Since each SIMPL argument is one word, the
procedure must use two adjacent dummy arguments to receive one double
or complex argument.  Double or complex values may be returned from
SIMPL by using the RETURN [A;B] construction.
.lm-3
.p;String scalars may be passed to SIMPL.
.x <STRING
The address of the string descriptor is passed.
The SIMPL routine may
modify the descriptor. The string body may not be moved or expanded
beyond its current size.
.p;Numeric or string arrays may be passed to SIMPL.
The address of the array descriptor is passed.
.x Arrays> array descriptor
The code will need to work through the descriptor to access the array
elements.
.s2;The SIMPL calling sequence is the most straightforward of any
of the languages.
The arguments are passed in consecutive registers beginning with
register one.  Numeric scalars take one register for logical/integer/
real, two registers for double/complex.  The register[s] contain the
value of the argument, not a pointer.  Strings and arrays take one
register each, which contains the address of the string/array
.x Strings> string descriptor;.x Arrays> array descriptor
descriptor or the string body.
Only registers 1 thru 10 (decimal) may be used to pass arguments.
.p;A result may be returned in register 1 (and register 2 for double
or complex functions).
.s;SIMPL returns with a POPJ 17,
.p;A MACRO routine may be called declaring it with DEF EXTERNAL
.x <MACRO
SIMPL in TYMBASIC and using the SIMPL calling sequence.
All registers may be destroyed by the MACRO routine except 17 (the stack
pointer).
.page;.c;^&BLISS\&
.x <BLISS
.p;BLISS routines must contain the declaration SREG= 17 in the MODULE
statement (that's the MODULE statement in BLISS, not the
MODULE command in TYMBASIC). The other special registers (B, F, and
V) may be allocated as desired.
.p;BLISS has no data types. TYMBASIC will convert arguments to
the types specified in the parameter list of the DEF. The result
will be interpreted according to the type of the DEF.
.p;As with SIMPL, two adjacent BLISS arguments are needed to
recieve one TYMBASIC double or complex argument. String scalars may
be passed to BLISS. The address of the descriptor is passed. The descriptor
may be modified but the body may not be expanded or moved.
.p;Numeric or string arrays may be passed to BLISS. The address of
the descriptor is passed. The BLISS routine will need to interpret
the descriptor to access the array.
.p;The BLISS calling sequence passes the arguments on the stack.
For numeric scalars the actual value is stacked. For strings and arrays
the address of the descriptor is passed.
The routine is called with a PUSHJ 17,. TYMBASIC will unstack
the arguments after the call.
.page;.c;^&INTERFACING OTHER LANGUAGES TO TYMBASIC\&
.p;There are five areas in which an external procedure might conflict
.x Procedures> external
with the TYMBASIC system.
Care must be taken to either avoid these conflicts or
program around them.
.s;1. UUO's: Unimplemented User Operations
.x <UUO's
.lm+2;These are special system instructions (opcodes 1 through 37B)
that trap to the user program rather than to the monitor when
executed.
TYMBASIC uses a subset of these - 1 through 16B and 31B through 37B - for
value traces in DEBUG mode and errors, respectively.
.x <DEBUG
.s;.i+3;The error UUO's are:
.s;.lm+4;ESCAPE#####31B
.x <ESCAPE
.br;ERROR######32B
.x <ERROR
.br;MATH#######33B
.x <MATH
.br;TRANSFORM##34B
.x <TRANSFORM
.br;DATAEND####35B
.x <DATAEND
.br;ENDFILE####36B
.x <ENDFILE
.br;FILE#######37B
.x <FILE
.lm-4
.p;The ENDFILE and FILE UUO's expect a file unit number in register 1. 
.x Files> file unit numbers
All UUO's must have a vaild error number in the address field.
They do not return.
.p;If an external procedure uses its own UUO's it must override the
TYMBASIC UUO instruction in location 41B in the Job Data
Area, and it must restore the instruction before returning to TYMBASIC.
.s2;.i-2;2. Memory
.p;TYMBASIC maintains control of memory allocation during execution of
.x Memory allocation, internal
a user program.
If an external procedure needs to allocate memory, the
procedure must:
.s;.lm+3;1. Call the routine ALLSP with the following arguments:
.x Memory allocation, internal> <ALLSP
.lm+2;.s;register 0 - number of words to allocate
.br;register 1 - address of pointer for allocated block
.i+14;also called the "descriptor"
.br;register 2 - zero
.lm-2
.s;The descriptor must be provided, and it will contain on return from ALLSP
the address of the "body" - the block of core just allocated.
Immediatly preceeding the body (in the right half-word) will be a back
pointer to the descriptor; so if the descriptor must be moved, the back
.x Memory allocation, internal> back pointer
pointer must be updated.
.p;2. Call the routine RELSP to release a block of core, with
.x memory allocation, internal> <RELSP
register 1 containing the address of the body.
RELSP will zero the descriptor by means of the back pointer.
.lm-3
.s2;.i-2;3. Math and Escape Trapping
.x Math error trapping;.x Escapes> trapping
.x Errors> trapping
.p;TYMBASIC uses the Tymshare Software Interrupt System to
.x Interrupts
trap escapes and math errors such as overflow, etc.
If an external procedure needs to trap escapes or math errors
it must use this same system and must restore the previous state of the
system before returning to TYMBASIC.
.s2;.i-2;4. Allocation of I/O Channels
.x <I/O channels
.p;External procedures must only attempt to allocate a free channel, and
should not assume that certain channels are free.
.s2;.i-2;5. Global Names
.p;Most TYMBASIC global names contain a period in the name (such as
.x Names> <TYMBASIC global
".dsin").
However, conflicts may arise with global names belonging to the user.
If this should happen another name should be used.
.lm-2
.title TYMBASIC REFERENCE MANUAL        INTERNAL ARRAY HANDLING
.subtitle 1 January 1978                                                    App. F
.page;.c;APPENDIX F. INTERNAL ARRAY HANDLING
.p;A TBA array has a body and a descriptor. The body is a block of memory
which contains the elements of the array. The elements are stored in a
sequential manner with the rightmost subscript varying most rapidly.
The elements of a subarray exist in the body of their parent array, that is,
the body of a subarray is a subset of the body of its parent.
The descriptor contains information needed to access the array.
.x Arrays> array descriptor;.x Arrays> array body
.p;Array (non-subarray) descriptors:
.s1;.lm+8;Word 0 - pointer to array body. In the case of a string
.i+9;array, each element is a two word descriptor.
.s1;Word 1 - left half :  size of body in words
.i+9;right half:  computed array base
.x Arrays> internal access> array base
.s1;Word 2 - left half :  type of array:  0 - logical
.i+38;1 - integer
.i+38;2 - real
.i+38;3 - double
.i+38;4 - complex
.i+38;5 - string
.i+9;right half: number of dimensions
.s1;Then starting at word 3 is a list of lower and upper bounds
.x Arrays> internal access> lower bounds;.x Arrays> internal access> upper bounds
for each dimension.
There is one word per dimension starting with the rightmost dimension.
.i+9;left half :  lower bound for this dimension
.i+9;right half: upper bound for this dimension
.s1;Following is a list of access coefficients. Each takes a half word and the
.x Arrays> internal access> access coefficients
list starts with the coefficient for the rightmost dimension.
.s1;The access code follows next. The size of the access code depends on
.x Arrays> internal access> access code
the dimensionality of the array. For subarrays and arrays with three
or more dimensions, the access code is a two word call to
an access routine at another location.
.page;.c;^&SUBARRAY DESCRIPTORS\&
.x Subarrays> descriptor
.s1;.lm-8;Subarray descriptors are structured somewhat differently.
.x subarrays
A subarray may have a lesser dimensionality than its parent
.x Subarrays> parent array
because some of its dimensions may be fixed. These fixed dimensions
are called hidden dimensions. A dimension in the parent that is not fixed
.x Subarrays> hidden dimensions;.x Subarrays> apparent dimensions
in the subarray is called an apparent dimension.
.p;The subarray descriptor includes a dimension map.
.x Subarrays> dimension map
This map contains one bit per dimension of the parent indicating whether
that dimension is hidden (bit=0) or apparent (bit=1). The rightmost bit
of the dimension map refers to the rightmost dimension, second
from the right refers to the second dimension from the right, etc.
.p;Subarray descriptors:
.s1;.lm+8;Word 0 - left half :  4 bits containing the count of the
.i+22;hidden dimensions followed by 14 bits
.i+22;containing the dimension map.
.i+9;right half: address of parent array's access code
.x Arrays> internal access> access code
.s1;Word 1 - left half :  number of elements in this subarray
.i+9;right half:  address of parent array descriptor
.s1;Word 2 - left half :  type of array
.i+9;right half:  number of apparent dimensions
.s1;Starting at word 3 are the upper and lower bounds and the access
.x Arrays> internal access> upper bounds;.x Arrays> internal access> lower bounds
coefficients for the apparent dimensions, as for non-subarrays.
.s1;The access code, which is always two words long for subarrays,
follows next.
.s1;Then follows a list of the subscripts for the hidden
.x Arrays> subscripts
dimensions, starting at the rightmost hidden dimension, one halfword per
hidden dimension.
.lm-8
.page;.c;^&ARRAY ACCESS\&
.p;Array access in TYMBASIC is done with a computed array base and a set
of access coefficients, one per dimension.
.x Arrays> internal access> access coefficients;.x Arrays> internal access> array base
The computed array base represents the location of the element whose
subscripts are all zero, which may be a fictitious element.
The access coefficients are used to compute an offset from this element.
The location of an
array element is the sum of the computed array base and the summation
of the products of the subscripts and their corresponding access 
coefficients. That is:
.s;.nf
             n
     L = B +   Si*Ci  where  n= number of dimensions
            i=1              S1 thru Sn are the subscripts
                             C1 thru Cn are the access coefficients
                             B= the computed array base
                             L= location(address) of the element

.f
.p;Access coefficients are derived from the element size and the
lower and upper bounds for the dimensions in the following manner:
.s;.nf
     Cn= element size.    1 for logical,integer and real.
                          2 for double,complex, and string.
     Cn-1= Cn * (Un-Ln +1)
           .
           .
     Ci= Ci+1 * (Ui+1 - Li+1 + 1)
           .
           .
     C1= C2*(U2 - L2 +1)
.f
.s;where Li is the lower bound and Ui the upper bound for subscript i.
   For subarrays, Cn is always 1  regardless of element size.
   Note that C0 is the array body size in words.
.p;The computed array base is computed as follows:
.s;.nf
             n
    B = W -    Li*Ci    where W is the address of the
            i=1                 array's first element
.s;.f;The computed array base may be equal, less or greater than W.
.s;.p;For example, consider the array created by:
.s;.i+4;10 BASE 2
.br;.i+4;20 STRING ARRAY(4,5)
.lm+3;.s;The access coefficients are C2=2 (each element is a two word string
descriptor) and C1= C2*(5-2+1)=8 .
.s;The array size in words is C1*(4-2+1)=24 words.
.s;The computed array base, B = (W- C1*2 +C2*2) = W-20 where W is the
address of the arrays first element.
.s;The location of ARRAY(3,4) is B+ C1*3 + C2*4 = W+10 .
.lm-3
.s1;The user may use the array base and access coefficients manually, or
indirectly through the access code.
.s2;.c;^&ACCESS CODE\&
.s1;The access code in the array or subarray descriptor may be used for
.x Arrays> internal access> access code
fast array accessing (this is presently limited to arrays of 2 or fewer
dimensions). The subscripts are placed in the registers starting with the
leftmost subscript in register 1. Then with register 17 set up as a stack
pointer, the acces code is called with a PUSHJ 17. Upon return, register 2
contains the address of the array element.
.p;Example:
.s;.lm+3;(TYMBASIC)
.br;10 DEF EXTERNAL SIMPL GETELM(INTEGER(I,J),A(*,*))
.br;20 ! USING THE SIMPL CALLING SEQUENCE FOR A MACRO SUBROUTINE
.x <MACRO;.x <SIMPL
.br;30 DIM ARY(3,3)
.br;40 PRINT GETELM(2,3,ARY)
.s;(MACRO)
.br;ENTRY###GETELM
.i+22;;REGISTERS 1 AND 2 CONTAIN THE SUBSCRIPTS
.i+22;;REGISTER 3 CONTAINS THE DESCRIPTOR ADDRESS
.br;GETELM:#PUSHJ 17,6(3) ;ACCESS CODE AT WORD 6 FOR ARRAY OF 2 DIMs
.i+8;MOVE##1,(2)###;ADDRESS OF ELEMENT RETURNED IN REGISTER 2
.i+8;POPJ##17,#####;RETURN TO TBA WITH  VALUE OF ELEMENT
.i+22;;IN REGISTER 1
.subtitle 1 January 1978                                                    App. G
.title TYMBASIC REFERENCE MANUAL        AUTOMATICALLY GENERATED FILES
.page.c;APPENDIX G. AUTOMATICALLY GENERATED FILES
.x files> automatically generated
.x files> temporary
.s2;There are two classes of files generated by TYMBASIC without user
confirmation.
.s.list
.le;Implicitly requested files
.s;Files with extension .REL or .RDL are relocatable files created
by the Compilation phase.
.x <RDL file;.x <REL file;.x Compilation phase;.x relocatable files
.s;Files with the extension .LOW can be created by the SAVE BINARY
command.
.x <SAVE <BINARY
.le;Temporary files
.s;These are files created by TYMBASIC to temporarily store information,
and are automatically deleted when the user GFD's or LOG's off.
.s;The characters "nnn" represent the three-digit job number of the user.
.s.nf
VMFnnn.TMP              core-image file
nnnDST.REL or .RDL      relocatable direct statement file
nnnWRK.REL or .RDL      relocatable workspace file
nnnWRK.TBA              holds workspace symbolics during
                        Global Recompilation
SBAnnn.SHR              Run phase high segment file
.els
.page
.title TYMBASIC REFERENCE MANUAL                INDEX
.subtitle 1 January 1978  
.C;^&INDEX\&
.do INDEX
    B@k