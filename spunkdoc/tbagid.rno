.flag index .FLAG CAPITALIZE
.upper case
.spacing 1
.paper size 54,71
.left margin 10
.right margin 71
.paragraph 0
.number 0
.title #####TYMBASIC GID -- Overall System Considerations
.figure 1
.blank
.subtitle #####TBA Status Control
.skip 4
.center 80
TYMBASIC GID
.skip 3
.center 80
-----
.skip 3
.center 80
General Internal Design
.skip 2
.center 80
of the
.skip 2
.center 80
TYMBASIC Language
.skip 2
.center 80
for Tymcom-X
.skip 3
.center 80
-----
.skip 5
.center 80
2/9/78
.skip 5
.center 80
Version 12
.page 
.index <TBA ^Status ^Control
.index Status ^Control
.index <P.MOD
.index <PSW
.index <CLRFLG
.skip 1
.center 80
TBA Status Control
.skip 1
The "modules" of Tymbasic are boxes 4, 5, 6, 7, 8 and 10 of the
level 1 TYMBAS flowchart.
These modules communicate via the user program data structure
(><LRT et al.) and the following status words:
.skip 1
.indent 5
.X <MDUFG
MDUFG:
.skip 1
.left margin 20

The count of modules on the module list.
(MDUFG not 0) _<=_> (a non-empty module list exists).
Certain commands and situations are handled differently when
>modules are being used than in the old Super Basic mode
.index current workspace
where only the current workspace exists.
.skip 1
.indent -5
.X <PGCNFG
PGCNFG:
.skip 1
.index program continuability
The program continuability flag.  (PGCNFG not 0) _<=_> (program has
.index continue point
been in execution; a continue point exists; no >program modifacation has
been made since; ><CXLNUM is the continue line).
.skip 1
.indent -5
.X <DSMDFG
DSMDFG:
.skip 1
The data-structure modification flag. (DSMDFG not 0) _<=_>
(program has been in execution and no >data-structure-mod has been
.x Interrupts
irrevocably committed since; ><CXLNUM is the interrupt line).
Data Recoverability is, however, not implemented in TYMBASIC.
.skip 1
.test page 7
.skip 1
.indent -5
.X <P.MOD
P.MOD:
.skip 1
><P.MOD = -1 =_>
.skip 1
.left margin 25
either the program has never been executed or else the program has been
modified since its last execution. This is the initial condition.
.skip 1
.indent -5
><P.MOD = 0 =_>
.skip 1
A run phase program exists and no program modifications
have occurred since its inception.
.skip 1
.indent -5
Note:
.break
.X <PGCNFG
(><P.MOD = -1) =_> (PGCNFG = 0)
.left margin 20
.tp 6
.indent -5
.X <MSTATE
MSTATE:
.skip 1
A ><PARSE subroutine called when a >source-mod is requested by the
user.
If P.MOD is 0 then ><MSTATE prints the message:
.skip 1
.i+5;Destroy Data?
.skip 1
and awaits Y[ES]##or N[O]##.
.X <P.MOD
If the answer is YES, ><MSTATE sets (P.MOD,PGCNFG) to (-1,0) and
returns the value 1.
If the answer is NO, ><MSTATE returns 0 and ><PARSE fails to carry
.x Source-mod
out the requested source-mod.
.indent -5
.skip 1
.X <CXLNUM
CXLNUM:
.skip 1
Current run-side linenum; the line interrupted or next to be executed
.index Direct ^Statements
when program is continued; specifies context of direct statements.
.skip 1
.left margin 25
.indent -10
.X <CLRFLG
CLRFLG:
.skip 1
.indent -5
A status word mapped by:
.skip 1
.x <RCFG
.x <CCFG
.x <DCFG
REC##CLRFLG,_<_<RCFG,1_>,_<CCFG,1_>,_<DCFG,1_>_>
.skip 1
field#########=1#means
.break
-----#########--------
.skip 1
@CLRFLG/RCFG##><XRUN data structures allocated
.break
###"###/CCFG##><COMPIL data structures allocated
.break
###"###/DCFG##><DECLAR data structures allocated
.skip 1
.left margin 20
.test page 8
.X xCFG
.index data structures
When /xCFG = 0, then the process x data structures are totally
.X <TRLS
.X <TBL
unallocated (all tbl's have been TRLS'd, etc.).
When />x^C^F^G = 1, then the data structures for process x represent
the successful, error-free, complete output of process x for
the current program (if ><P.MOD not -1) or for a previous state of
the program (if ><P.MOD = -1).
.test page 7
.skip 1
.left margin 20
.indent -5
.index <CXLNUM
.index <SEGNO
.X <PSW
PSW:
.skip 1
A status word used when a >transition is to be made from ><PARSE to
other modules.
.X <PARSE
.X <PSW
PSW, set by PARSE, designates which command is calling for the
transition and which actions need to be performed by the other modules.
.test page 5
.skip 1
.indent -5
.X <SEGNO
SEGNO:
.skip 1
As each module exits, it sets SEGNO to the case value (see
TYMBAS flowchart) of the module to be executed next
.skip 1
.x <DECLSW
.skip 1
.i-5;DECLSW:
.skip 1
This switch is used to tell the code generator to do some initialization.
It is set to zero in SYSUP. During COMPIL it is looked at. If it is zero
then some initialization stuff is done and it is set to one at once.
Once set to one it never once changes (a small wonder).
.skip 1
.left margin 10
.X <SYSUP
Overall flow of status control:# at SYSUP, these initializations
are made:
.skip 1
.indent 5
-1 -_> ><P.MOD
.skip 1
.indent 5
.X <CLRFLG
.X <DSMDFG
0 -_> CLRFLG,DSMDFG
.skip 1
.indent 5
.X <PGCNFG
.X <MDUFG
0 -_> PGCNFG,MDUFG,DECLSW
.skip 1
When ><PARSE exits to other modules, the value of ><P.MOD (together with
.X <PSW
the active user command) determines the setting of PSW.
PSW, in turn, governs which modules are to be called.
The action of those modules is governed by the values of ><PSW
.X <CLRFLG
and CLRFLG.
Before exiting, each module ensures its data structures are as
.X <CLRFLG
advertised by CLRFLG.
Exit is to ><PARSE if errors were found and to the designated
successor module otherwise (as shown below in the Transition Table).
.page
The primary system tasks which vary according to ><PSW and ><CLRFLG
are shown in the following table.
.skip 1
.index Task ^Table
.center 80
Task Table
.skip 1
task_######done by#####description
.break
-----#####-------#####-----------
.break
.skip 1
.left margin 32
.indent -22
.X <DCFG
##1#######><DECLAR######0 -_> /DCFG; release structures; process
declarations; if errors then release structures else 1 -_> /><DCFG
.skip 1
.indent -22
.X <DCFG
##2#######><DECLAR######if /DCFG = 0 then do Task 1, else
.X <SDT
(start with existing SDT; process declarations and update SDT; if
.X <DCFG
errors then release structures and put 0 -_> /DCFG).
.skip 1
.indent -22
##3#######><DECLAR######display definition of symbol ><CDEID in context
><CDELN1. (The SYMD command).
.skip 1
.indent -22
##4#######><COMPIL######0 -_> /CCFG; release structures; compile
program; if errors then release structures else 1 -_> /CCFG
.skip 1
.indent -22
.index Direct ^Statements
.X <CCFG
##5#######><COMPIL######compile direct statement; leave /CCFG alone;
if errors then return to ><PARSE
.skip 1
.indent -22
##6#######><COMPIL######display compiled code for lines in range
.x <CDELN1
.x <CDELN2
CDELN1:CDELN2
.skip 1
.indent -22
##7#######><IZVAR#######Initialize the Run Phase (system and user defined
variables, etc)
.skip 1
.indent -22
##8#######><IZVAR#######Recover user data from VMF file into loseg.
.index Direct ^Statements
of direct statement code
.skip 1
.indent -22
##9#######><XRUN########Transfer execution to user program or direct statement.
.fill
.left margin 10
.test page 24
.X <PSW
The following table shows each of the possible values of PSW,
designates which of the above tasks are to be performed and shows the
normal set of modules to be invoked.
.skip 2
.test page 24
.left margin 11
.center 80
Transition Table
.index Transition ^Table
.skip 1
.nofill
><P.MOD  #########                    ---------Modules--------
=-1?  Condition    ><PSW Tasks        ><DECLAR ><COMPIL ><IZVAR ><XRUN
----- ------------ --- ------------ ------ ------ ----- ----
.skip 1
.INDEX Direct ^Statements
  Y   direct stmnt  1  1,4,5,7,9      X      X      X    X
  N   direct stmnt  2  5,8,9                 X      X    X
  Y   ><RUN           3  1,4,7,9        X      X      X    X
  N   ><RUN           4  8,9                          X    X
  N!  ><START         6  9                                 X
  N!  ><GO            7  9                                 X
  Y   ><INIT          8  1,4,7,9        X      X      X    X
  N   ><INIT          9  7,9                          X    X
.left margin 10
either ><CLEAR        10  none         ><SYSIZL
either ><QUIT         11  none         ><EXIT
.left margin 11
  Y   ><CDE          12  1,4,6          X      X
  N   ><CDE          13  1,4,6          X      X
  Y   ><SYMD         14  1,3            X
  N   ><SYMD         15  3              X
  N!  ><STEP         16  9                                 X
.index <SAVE <BIN
  Y   ><SAVE <BIN     17  1,4,7          X      X      X
  N   ><SAVE <BIN     18  not implemented
.left margin 10
either ><LOG          19
.fill
.subtitle #####Module Transitions (USWAP)
.page
.index Module ^Transitions (^U^S^W^A^P)
.index <USWAP
.skip 1
.center 80
Module Transitions (USWAP)
.skip 1
.left margin 10
.X <SYSIZL
.X <PARSE
.X <DECLAR
.X <COMPIL
.X <IZVAR
Transition among SYSIZL, PARSE, DECLAR, COMPIL, and IZVAR is via
><RUNSEG and preserves a continuous loseg.
.X <XRUN
When control passes via ><TRRZL to ><RUNIZL and XRUN, a new loseg and hiseg
are to be created by the loader.
.X <SLO
Prior to this the editside loseg is saved on the VMF file.
.skip 1
.INDEX program layout
A running TBA program is laid out as follows:
.break
(brackets denote optional items.)
.left margin 27
.indent -4
.skip 1
.nofill
0:# monitor area data
.index <TBA system data
TBA system data and direct statement temps
module1 data }
.indent -1
[module2 data]}
.indent -1
[ . . .      ]}  Includes workspace module
.indent -1
[modulen data]}
.indent -1
.index Direct ^Statements
.index literals
.index temps
.index library-list data
.indent -1
[library-list data]
.index <TBA library data
TBA library data
.index dynamic storage
dynamic storage
.skip 1
.indent -12
.index <TBA system code
O'400000':##TBA system code
module1 code
module2 code
 . . .
modulen code
.index workspace module code
workspace module code
direct statement code
.index library-list code
library-list code
.index <TBA library code
TBA library code
.index Direct ^Statements
.index Direct ^Statement code
.skip 1
.left margin 10
.fill
The module data area contains numeric scalars, string descriptors and
array descriptors; it is allocated to a static area by ><DECLAR
.X <COMPIL
(and COMPIL).
.skip 1
The ><DSA holds the actual bodies of strings and arrays.
As these structures are dynamic, ><DSA may grow or shrink in
size during execution; it is thus always at the highest
locations of the loseg.
.skip 1
When a TBA program begins execution, the hiseg is saved on
.skip 1
.indent 5
nnnSBA.SHR
.skip 1
where nnn is the current job number.
.skip 1
When the program is interrupted, the current loseg is written
.X <LVR
out on the VMF file.
.x <VMF file
Control then passes to ><PARSE via runseg (SYS)TBA.SHR.
.skip 1
If the program is restarted with the ><GO or ><STEP command,
.X <LVR
user data) can simply be reloaded and execution resumed.
.index Direct ^Statements
If the program is restarted by a direct statement, then a reload of
the .><REL files will be required.
If no program modification is in effect, user data is reloades to its old
location and control is transferred to the direct statment.
.subtitle #####Program Load Map (PGMP)
.page
.index Program ^Load ^Map (^P^G^M^P)
.index <PGMP
.skip 1
.center 80
Program Load Map (PGMP)
.skip 1
The Program Load Map is created by ><RUNIZL as part of the Program
Load Process from information supplied by the system loader.
.skip 1
The format of the >loadmap is given by:
.skip 1
.indent 5
.X <PGMP
.X <NPGMP
REC_# PGMP,_<_<NPGMP,36_>,
.indent 10
.X <LPGMP
.X <HPGMP
_<LPGMP,18_>,_<HPGMP,18_>_>
.skip 1
.indent 5
/><NPGMP -- sixbit program name
.skip 1
.indent 5
/><LPGMP -- loadpoint of loseg
.skip 1
.indent 5
/><HPGMP -- loadpoint of hiseg
.skip 1
.X <RUNIZL
The program load map is generated as the initial process of RUNIZL.
This process proceeds as follows:
.skip 1
.left margin 15
.indent -5
.index symbol table
1.###The symbol table generated by the loader (found at the end of
the loseg) is reformatted into the above record format.
.X <MAPORG
The table origin is placed in MAPORG.
.skip 1
.indent -5
2.###The pager initialization routine is called.
.skip 1
.indent -5
3.###A copy of ><PGMP is placed in the VMF for use by
the ><MAP command.
.skip 1
.indent -5
4.###The ><STARTPOINT and WORKSPACE module names are obtained from the
virtual memory file.
.skip 1
.indent -5
5.###><PGMP is scanned to find the >startpoint module.
This module will be one of the following:
.skip 1
.left margin 20
.indent -5
a.###The module specified by the ><STARTPOINT command.
.skip 1
.indent -5
b.###The workspace module.
.skip 1
.indent -5
.index Direct ^Statements
c.###The direct statement code module.
.skip 1
.left margin 15
The highseg >startpoint address is stored in ><STRTPT.
.left margin 10
.subtitle #####><XRUN Load String
.page
.index <XRUN ^Load ^String
.skip 1
.center 80
><XRUN Load String
.skip 1
From the module list and library list, TBA creates a
load string to drive the TBA loader (the system loader pre-loaded with
necessary system modules) which contains names of
the .><REL files in the following order:
.skip 1
.left margin 20
.indent -5
.break
module
.break
module
.break
 . . .
.break
module (workspace module)
.break
direct statement module nnnDST.REL
library (user libraries)
.break
library
.break
 . . .
.break
.indent -5
TBALIB.REL
.skip 1
.left margin 10
The modules are in the order of the module list; the libraries are in
the order of the library list.
.skip 1
The .><REL files have conventional program
names (same as the file name) so that the Program Load Map can be
used to find:
.left margin 20
.skip 1
.indent -5
a.###the bounds of the module area, as a whole
.skip 1
.indent -5
b.###The bounds of the workspace module
.skip 1
.indent -5
c.###the >startpoint of the TBA program
.skip 1
.left margin 10
See Program Load Map above.
.subtitle #####Program Load Process
.page
.index Program ^Load ^Process
.X <TRRZL
.skip 1
.center 80
Program Load Process (TRRZL)
.skip 1
.left margin 10
The process of passing from the SYSIZL,..., ><COMPIL states to ><RUNIZL
and ><XRUN is accomplished by ><TRRZL (Transfer to run initialization).
><TRRZL consists basically of three subprocesses:
.skip 1
.left margin 15
.indent -5
1.###Build ><XRUN load string.
.skip 1
.indent -5
2.###Invoke the TBA loader via a ><RUN UUO.
.skip 1
.indent -5
3.###Begin run phase execution in the ><RUNIZL state.
.index Direct ^Statements
.subtitle #####Direct Statement References
.page
.index Direct ^Statements
.skip 1
.center 80
Direct Statements
.index Direct ^Statements
.skip 1
.left margin 10
.index Direct ^Statements
Each direct statement is a separate module.
References from within the direct statement to its own data or code
and to library routines
is accomplished by relocation.
References from the direct statement to the workspace are
accomplished by indexing.
.x <UVARR
.x <WLOCR
Register 14 octal (UVARR) is used for indexing into the workspace module's
loseg.
Register 15 octal (WLOCR) is used for indexing into the workspace module's
hiseg.
These two registers are set by IZVAR and are not used by any run phase code.
.x <IZVAR
.subtitle #####Condition Trap Table (CNDTT)
.page
.index Condition ^Trap ^Table (^C^N^D^T^T)
.index <CNDTT
.skip 1
.center 80
Condition Trap Table (CNDTT)
.skip 1
.INDEX Condition traps
.X <CNDTT
A table, CNDTT, is maintained for each condition and holds the
information:
.skip 1
.left margin 20
.indent -5
a.###whether condition armed
.skip 1
.indent -5
if armed:
.skip 1
.indent -5
b.###address to trap to
.subtitle #####Data Structure Management (TBL, DSA, Module Transitions, USWAP)
.page
.index Data ^Structure ^Management (<TBL, <DSA, ^Module ^Transitions, <USWAP)
.index <TBL
.index <DSA
.index Module ^Transitions
.index <USWAP
.skip 1
.X <DSA
.X <TBL
.center 80
Data Structure Management (TBL, DSA, Module Transitions, USWAP)
.left margin 10
.skip 1
Two data structure environments are maintained under TBA.
.X <SYSIZL
.X <PARSE
.X <DECLAR
.X <COMPIL
The first, the editside, encompasses SYSIZL, PARSE, DECLAR, COMPIL
.X <IZVAR
and IZVAR; the second, called runside, prevails during program
.X <XRUN
execution (i.e., the TBA module, XRUN).
.skip 1
The editside loseg is maintained continuously among its modules.
.X <FTBL
The data structures involved are system variables, arrays, FTBL's,
.X <FTBL
.X <TBL
.X <VTBL
TBL's and VTBL's.
.X <LALOC
.X <LFREE
The only dynamic blocks allocated (see LALOC, LFREE) are for the IO
buffers involved in the ><DO and ><TOUT commands.
.skip 1
The ><TBL package is described in detail under separate cover, but
briefly, the structures ><TBL and ><VTBL are managed in a dynamic
portion of the loseg called the paging area.
The VMF is used as a swapping
store for the paging areas.
When control is passed to the runside, the entire editside loseg
is dumped on the VMF.
.skip 1
.X <TBL
.X <FTBL
.X <VTBL
The runside uses no TBL's, VTBL's or FTBL's.
All data structures are either static areas set up at load time
or else are in the ><DSA area.
The ><DSA area is a collection of dynamically allocated blocks of
storage pointed to by static data structures.
Included in the ><DSA are array and string bodies, IO buffers,
 and IO control blocks.
.subtitle #####System Debug Switch (DEBMOD)
.page
.index System ^Debug ^Switch (^D^E^B^M^O^D)
.X <DEBMOD
.skip 1
.center 80
System Debug Switch (DEBMOD)
.skip 1
The conditional assembly switch DEBMOD governs the assembly of TBA
debugging facilities.
The settings are:
.skip 1
.nf
.lm+4
0 => No Debug
1 => DDT at run-time
2 => DDT at parse-compile-time
3 => DDT at both parse-compile-time and runtime
.lm-4
.fill
.skip 1
With DEBMOD nonzero, DDT is entered at the beginning of code generation,
on entering the runside, and on return to the parseside.
Local symbols are put out to the .REL file with D nonzero including
a statement label for the first word of code generated for each TBA source
line.
The form of this label is nL where n is the decimal line number of the source
line.
Line 200 would thus have the label '200L'.
.skip 1
DEBMOD nonzero also causes checks for internal errors throughout TBA.
.subtitle #####System Stack
.page
.index System ^Stack
.left margin 10
.skip 1
.center 80
System Stack
.skip 1
.index <RXP
.index <stack pointer
.index <r15
.x <RXP
Register 17 octal (RXP,P) is used as a pushdown stack pointer for
all TBA internal system linkage.
Positions on the stack are allocated for parameter values, local
variables and the return address.
.page
.index User-^Supplied ^Routines
.skip 1
.center 80 
User-Supplied Routines
.skip 1
Routines to be loaded with TBA programs must follow certain rules
of neighborliness.
These rules are discussed in Appendix E of the TBA Reference Manual.
.subtitle #####Object File Naming Conventions
.page
.Index Object ^File ^Naming ^Conventions
.skip 1
.center 80
Object File Naming Conventions
.skip 1
.left margin 20
.nofill
                  DEBUG      NO DEBUG
              -------------------------
Named         | name.RDL  | name.REL  |
Anonymous     | nnnWRK.RDL| nnnWRK.REL|
Direct Stmt.  | nnnDST.RDL| nnnDST.REL|
Source File   |      nnnWRK.TBA       |
              -------------------------
.fill
.left margin 10
.skip 2
In PARDAT:
.skip 1
.indent 5
CERCNT
.skip 1
.left margin 30
.indent -15
WRKCMP_#0##iff##the current module is the workspace module
.skip 1
.indent -15
MODNM:#BLOCK 5 name of the source file
.skip 1
.indent -15
1st word=0#iff#the current module is an anonymous workspace
.SKIP 2
.LEFT MARGIN 10
-RUN TBA
.break
_>DEBUG
.BREAK
_>MODULE A
.BREAK
_>NO DEBUG
.BREAK
_>MODULE B
.BREAK
_>10 A=0
.break
_>PRINT A
.SKIP 1
generates:# A.RDL
.BREAK
############B.REL
.BREAK
########nnnWRK.REL  (empty workspace module)
.BREAK
########nnnDST.REL
.BREAK
.subtitle #####User-Defined Modules and Libraries
.page
.index User-^Defined ^Modules and ^Libraries
.skip 1
.center 80
User-Defined Modules and Libraries
.skip 1
The module list is maintained by use of these data structures:
.left margin 15
.skip 1
><MDUFG -- number of modules
.skip 1
.index <MDUR
.index <MDUN0
.index <MDUN1
.index <MDUN2
.index <MDUN3
.index <MDUN4
.index <MDUPPN
.index <MDUMD
.index <MDUT
REC##MDUR,_<_<MDUN0,36_>,_<MDUN1,36_>,_<MDUN2,36_>,
.break
#####_<MDUN3,36_>,_<MDUN4,36_>,_<MDUPPN,36_>,_<MDUMD,36_>_>
.skip 1
.X <MDUT
.X <MDUR
><TBL##MDUT,20,MDUR
.left margin 20
.skip 1
/MDUMD# -- (not 0) _<=_> (module mode in DEBUG)
.left margin 30
.indent -10
.skip 1
/MDUN0 -- /MDUN4 -- module name in ASCIZ format (possibly with directory name and extension, including parenthesis and "." but will all spaces removed.)
.skip 1
.indent -11
/MDUPPN -- Project-programmer number of directory, if applicable, zero
otherwise
.skip 2
.left margin 10
The library list is maintained by these similar data structures:
.left margin 15
.skip 1
.index <LIBR
.index <LIBN1
.index <LIBN2
.index <LIBN3
.index <LIBN4
.index <LIBPPN
.index <LIBT
REC LIBR,_<_<LIBN0,36_>,_<LIBN1,36_>,_<LIBN2,36_>,
.break
#####_<LIBN3,36_>,_<LIBN4,36_>,_<LIBPPN,36_>_>
.skip 2
.X <LIBT
><TBL LIBT,20,LIBR
/LIBN0 - /LIBN4 -- library name, same format as module name
above
.skip 
/LIBPPN -- same as /MDUPPN
.subtitle #####Line Reference Table (LRT)
.page
.index Line ^Reference ^Table <(LRT)
.center 80
Line Reference Table (LRT)
.skip 1
.indent -10
.index <LRTE
.index <LRT
.index <LCOD
.index <LNUMB
.index <LTXT
.index <LNXT
.index <LPMC
.index <LSUBN
.index <LCFG
.index <LDFG
.index <LEFG
REC##LRTE,_<_<LCOD,18_>,_<LNUMB,18_>,_<LTXT,36_>,_<LPMC,36_>,_<LNXT,12_>,
.i+8
_<LSUBN,9_>,_<LCFG,1_>,_<LDFG,1_>,_<LEFG,1_>,_<LFOR,6_>,
.i+8;_<LTOFFG,1_>_>
.skip 1
.indent -5
><TBL##LRT,,LRTE
.skip 1
.left margin 30
.indent -10
/LCOD# -- address of compiled code
.skip 1
.indent -10
/LNUMB -- line number; 100003 =_> deleted entry
.skip 1
.indent -10
/LTXT# -- virtual address of source text
.skip 1
.indent -10
/LNXT# -- recno of successor ><LRT entry
.skip 1
.indent -10
.x <PMC
/LPMC# -- virtual address of PMC's
.skip 1
.indent -10
/LSUBN -- procedure number containing this line (0 = main prog)
.skip 1
.indent -10
.X <COMPIL
/LCFG#####= 0 _<=_> (process line in COMPIL)
.skip 1
.indent -10
.X <DECLAR
/LDFG#####= 1 _<=_ (process line in DECLAR)
.skip 1
.indent -10
/LEFG#####= 1 _<=_> (/LCOD established)
.skip 1
.i-10
/LFOR##-- number of FOR loops in this line. DECLAR
allocates R%VRLC space for return addresses based on this field.
.x <DECLAR
.x <FOR loops
.skip 1
.i-10
/LTOFFG###= 1 _<=_> TOF (top of form) mark on this line
.skip 2
.left margin 10
><LRT is a chained dictionary to the user program. 
The first three entries of ><LRT are always:
.skip 1
.indent 5
.index Direct ^Statements
.X <DSTH
1 = DSTH_# -- direct statement
.skip 1
.indent 5
.X <LSTH
2 = LSTH_# -- dummy last line
.skip 1
.indent 5
.X <FSTH
3 = FSTH_# -- dummy first line
.skip 1
><LRT Index Table -- ><LRXT
.skip 2
The ><LRXT allows rapid lookup of ><LRT entries, given a line
number value:
.skip 1
.indent 4
.index <LRX
.index <LRXL
.index <LRXK
.index <LRXN
.index <LRXSZ
.index <LRXT
.index <LRXRG
REC#--#LRX,_<_<LRXL,18_>,_<LRXK,18_>_>
.skip 1
.indent 4
LRXN -- highest entry num in ><LRXT
.skip 1
.indent 4
LRXSZ_# -- (=100) declared size of ><LRXT arrays
.skip 1
.left margin 20
.indent -6
LRXT[0:LRXSZ_#]><LRXL -- periodically selected line number values,
including endpoints of ><LRT
.skip 1
.left margin 10
.indent 4
LRXT[0:LRXSZ_#]LRXK -- corresponding recid's within ><LRT
.skip 1
.indent 4
LRXRG -- (highest linenum) minus (lowest linenum)
.skip 1
.indent 4
formula for initial guess is:
.skip 1
.indent 4
I = ((LNUMb-LRXL[0])*LRXN)DIV LRXRG
.skip 1
><LRXT is setup by ><DECLAR initialization and used subsequently
.X <COMPIL
by both ><DECLAR and COMPIL.
.skip 1
.test page 14
These entries simplify the process of chaining in user lines.
These entries are initialized:
.skip 1
.left margin 15
.nofill
Entry    /LNUMB     /LNXT
.break
-----    -----      -----
.skip 1
.X <DSTH
DSTH#    100000     DSTH#
.skip 1
.X <LSTH
LSTH#    100001     ##0
.skip 1
><FSTH#    100002     LSTH#
.skip 1
.fill
.left margin 10
Deleted ><LRT entries have /><LNUMB = 100003.
.skip 1
Note:
.break
.index <LRT
.index <TXT
.index <PMC
New entries are always added to the ends of LRT, TXT and PMC.
.index <RENUMBER
Garbage collection only occurs as a byproduct of ><GET or RENUMBER.
.index Garbage ^Collection
Omitted ><LRT entries are threaded past (besides being given a
special /LNUMB value).
.subtitle #####Text Area (TXT)
.page
.index Text ^Area <(TXT)
.center 80
Text Area (TXT)
.skip 1
.indent 5
.index <TXT
.index source lines
.X <VTBL
VTBL TXT,7,*
.skip 1
The records of TXT are the source lines of the user program stored
in standard Tymcom X 7-bit ASCII.
.index <LRT
.X <LRT
The lines are retrieved via the LRT.
.subtitle #####PMC (PMC)
.page
.index <PMC <(PMC)
.skip 2
.center 80
PMC
.skip 1
   The PMC (also known as preliminary code, pass 1 code and TYMBASIC
intermediate code) is the stuff that the parser generates from the TBA
program and sends to the code generator.
.skip 1
  PMC lives in 9 bit bytes. The first byte in a string of PMC bytes gives an
OPTYPE. A particular OPTYPE may require other bytes containing information
.x <OPTYPE
like line numbers and variable ids. Usualy the size in bytes of the PMC
string for a given OPTYPE is fixed. An exception is SCON which gives a string
constant. Its format is the SCON optype followed by a byte containing the
number of characters in the string, followed by the characters one per byte.
You must be careful when processing PMCs not to lose your place or havoc will
result.
.skip 1
  When OPTYPES were first discovered they were in the ranges 0-124 and 235-255.
They were probably borrowed from a basic written for a 32 bit machine which
would very likly have had 8 bit bytes. The original intent was to fill in the
center hole with any new PMCs. It is considerably safer to add new optypes after
255 instead. The center hole has been compressed out of many of the PMC tables
and the cutoff point for the lower range has been hardwired into the code with
such mild atrocities as 'CAIG 1,124's and the like.
.skip 1
  PMC is generated during LNANAL ( the mammouth Parse 1.5.4 which is the
analysis of one line of the TBA source) in packets. For details on packets read
"7.6.1 Pass 1 and Pass 2 Code Generation". In MOVBIN (Parse 1.5.7) the packets
are ordered. In THREAD(Parse 1.5.12) the LRT is given a pointer to the completed
PMC for the line.
.skip 1
  The PMC is retrieved via the LRT in DECLAR, COMPIL and in PMCX(Parse 1.5.6.21)
.x <DECLAR
.x <COMPIL
for processing. The processing is done through a number of tables which are
referenced with the PMC OPTYPE. The tables are:
.skip 2
.left margin 41
.i-31
.x <PSTMLT
.x <POPLT
PSTMLT and POPLT in DECLAR######an XCT table. It contains an instruction for
                                 each OPTYPE that either ignores the PMC string
                                 or processes declarations as appropriate.
.skip 1
.i-31
.x <COPTX
.x <COPTY
COPTX and COPTY in COMPIL#######which gives a location in the code generator
                                 where the PMC string can be processed.
.skip 1
.i-31
.x <RZTBLO
.x <RZTBHI
RZTBLO an RZTBHI in CSUBS#######which gives the length of the PMC string for
                                 each OPTYPE for use in bypassing the PMC
                                 string during an error.
.skip 1
.i-31
.x <PMCNMS
PMCNMS in PARSE8################which gives the ASCII name of the OPTYPE for
                                 use in the 'PMC' command
.skip 1
.i-31
.x <PMCTBL
PMCTBL in PARSE8################which gives a printing pattern for the PMC
                                 string for use in the 'PMC' command.
.left margin 10
.skip 1
 All except the last, PMCTBL, are generated with macros in PMC.MAC.
The macros are LOPMCS and HIPMCS.
They contain comments and serve as documentation for the preliminary code.
LOPMCS gives the dope on the
.x <HIPMCS
.x <LOPMCS
OPTYPEs in the range 0-124, HIPMCS the range 235 and up. A sub macro entitled
"PMC" gives information for each OPTYPE. In particular: the OPTYPE number,
the ASCII name, an instruction for the XCT table in DECLAR, an address for the
.x <DECLAR
.x <COMPIL
.x <OPTYPE
.x <PMC
table in COMPIL, and the total size in bytes of the PMC string of that OPTYPE.
The various tables are generated by redefinition of the "PMC" macro followed by
expansions of the LOPMCS and HIPMCS macros.
.skip 1
  To add a new OPTYPE you need only make a new entry to the end of HIPMCS and
to the end of PMCTBL in PARSE8.
.skip 1
  For a somewhat outdated but still valuable account of the implemetation of a
new statement in TBA including PMC changes, read (SPUNKDEV)JEFF1.MEM .
.skip 4
.center 80
PMC Area (PMC)
.INDEX <PMC
.skip 1
.indent 5
.X <VTBL
VTBL PMC,9,*
.skip 1
.INDEX Parser output
Each record of pmc holds the PMC's (parser output -- preliminary
code) for the corresponding source line.
.X <LRT
Retrieval is via LRT.
.subtitle #####Name Table (HVX,NAMDIC)
.page
.index Name ^Table <(HVX,NAMDIC)
.skip 1
.center 80
Name Table (NAMT, NAMTB, NAMS)
.index <NAMTB
.index <NAMT
.index <NAMS
.index <HVX
.index <NAMDIC
.index Reserved ^Words
.index User ^Defined ^Symbols
.skip 1
The Name Table stores TBA reserved words and user-defined symbols.
As each new name is entered, the next sequential integer (starting
from 1) is permanently associated with that name. The next integer to
.index <NAMIDX
be assigned is kept in NAMIDX.
.skip 1
The names are paged manually rather than by a ><TBL to allow fast access.
The pager allocates pages of free core as needed for
additional names. The vector NAMDIC contains core
locations of each allocated block of names. Each name is stored in Sixbit.
Three words of core are allocated per name: Two and one-half for the spelling and the last halfword for a link to the next name in
that last chain; the link is the name table number (NAMIDX) of that name,
so locating that next name requires a reference to NAMDIC. HVX is a
statistically allocated vector of primary hash links to name table entries.
.subtitle #####Variable Allocation Address (R%VRLC)
.page
.index Variable ^Allocation ^Address <(R%VRLC)
.index <R%VRLC
.skip 1
.center 80
Variable Allocation Address (R%VRLC)
.skip 1
.X <R%VRLC
.X <DECLAR
The variable R%VRLC, initialized to STRTUV during DECLAR, is the
relocatable loseg address next available to be used for a storage
location.
.index Direct ^Statements
.index source-mod
During DECLAR, loseg space is allocated for explicitly declared
variables.
Numeric scalars get space for their values, strings and arrays get space for
their descriptors.
When a procedure is encountered, a parameter vector (PVEC) is
started. Declaration for parameters, local variables, and entire
PVECs for local procedures are contained within the PVEC.
.x <PVEC
At the completion of the DECLAR pass we allocate one word to hold the
return address for every FOR loop (we counted them).
.skip 1
During COMPIL, space is allocated for implicitly declared variables and temp
cells.
Blocks of loseg space are used to save away registers and temp cells before
calling procedures.
.x <COMPIL
.x <FOR
.x temp#cells
.subtitle #####Location Counter (RXLOC)
.page
.index Location ^Counter
.index <RXLOC
.skip 1
.center 80
Location Counter (RXLOC)
.skip 1
The variable RXLOC holds the relocatable address of the
next instruction to be generated; RXLOC is initialized to zero by
.index Direct ^Statements
><COMPIL in Task 4 (see Task Table); direct statements continue
to increase RXLOC.
.subtitle #####Break Structures (BRKT, BRKTR, BRKN, BRKLX)
.page
.index Break ^Structures <(BRKT, <BRKTR, <BRKN, <BRKLX)
.index <BRKT
.index <BRKTR
.index <BRKN
.index <BRKLX
.skip 1
.center 80
Break Structures (BRKT, BRKTR, BRKN, BRKLX)
.skip 1
BRKT contains all active BREAK information.
.INDEX <RHED
.X <XRUN
.X <RHED
BRKT is maintained by ><PARSE and referenced by XRUN, particularly RHED.
The format is
.skip 1
.indent 5
.INDEX <BKL1
.INDEX <BKL2
REC##BRKTR,_<_<BKL1,18_>,_<BKL2,18_>_>
.skip 1
.indent 5
ARRAY##BRKT[BRKTR:# BRKLX*BRKTR]
.skip 1
The variable BRKN is the current number of entries,(plus one), limit BRKLX,
in BRKT.
.skip 1
Entries are coded:
.left margin 15
/BKL1 -- Low linenum of a range
.skip 1
.left margin 24
.indent -9
/BKL2 -- high linenum of a range (same as /BKL1 if the "range" is a single
line number.)
.skip 1
.left margin 10
Entries are kept sorted from lowest to highest line _# at all times, with
no overlap or duplication.
.skip 1
BRKT is initialized by setting BRKT[0] to 100001,,100001 and
setting BRKN=1.
.subtitle #####Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)
.page
.index Trace ^Structure <(TRCT, <TRCTR, <TRCN, <TRVT, <TRVTR, <TRCLX, <TRVLX)
.index <TRCT
.index <TRCTR
.index <TRCN
.index <TRVT
.index <TRVTR
.index <TRCLX
.index <TRVLX
.skip 1
.center 80
Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)
.skip 1
Structure
.skip 1
.left margin 15
.INDEX <TRVN
.INDEX <NOVTN
.INDEX <NOVTRR
.INDEX <NOVL1
.INDEX <NOVL2
varb###TRCN,TRVN,NOVTN
.skip 1
REC##NOVTRR,_<_<NOVL1,18_>,_<NOVL2,18_>_>
.skip 1
.INDEX <TCL1
.INDEX <TCL2
.INDEX <TCVL
REC##TRCTR,_<_<TCL1,18_>,_<TCL2,18_>,_<TCVL,36_>_>
.skip 1
.nojustify
REC##TRVTR,_<_<TRVLC,18_>,_<TRVID,15_>,_<TRVTP,3_>,
.INDEX <TRVLC
.INDEX <TRVID
.INDEX <TRVTP
.INDEX <TRVSP1
.INDEX <TRVSP2
.INDEX <TRVSP3
#####_<TRVSP1,36_>,_<TRVSP2,36_>,_<TRVSP3,36_>_>
.justify
.skip 1
><TRCLX = 15
.skip 1
><TRVLX = 25
.skip 1
ARRAY##TRCT[TRCTR:TRCLX*TRCTR]
.skip 1
ARRAY##TRVT[TRVTR:TRVLX*TRVTR]
.skip 1
.INDEX <NOVTR
ARRAY##NOVTR[NOVTRR: TRCLX*NOVTRR]
.skip 1
.indent -5
Contents
.skip 1
.left margin 25
.indent -10
><NOVTN##-- number of active entries in NOVTR, limit ><TRCLX
.skip 1
.indent -10
><TRCTN# -- number of active entries in TRCT, limit TRCLX
.skip 1
.indent -10
><TRVN###-- number of active entries in TRVT, limit TRVLX
.skip 1
.indent -10
><TRVLX# -- limit on entries in TRVT
.skip 1
.indent -10
><TRCLX##-- limit on entries in TRCT, NOVTR
.skip 1
.indent -10
/TCL1# -- low number of range specified
.skip 1
.indent -10
/TCL2# -- high number of range
.skip 1
.indent -10
/TCVL# -- entry number of associated entry in TRVT (first entry is number 0)
.skip 1
.indent -10
/TRSP1##- 1st 5 charaters of name
.indent -10
.skip 1
.INDEX <TRSP1
.INDEX <TRSP2
.INDEX <TRSP3
/TRSP2##- 2nd five numbers of a name
.indent -10
.skip 1
/TRSP3##- 3rd five characters of name; NULL padded, left justified(ASCIZ
format)
.skip 1
.indent -10
/TRVLC -- relative R%VRLC location of the variable
.skip 1
.indent -10
/TRVID -- identno (><SDT index) of the variable (VARID)
.skip 1
.indent -10
/TRVTP -- type of the variable
.left margin 15
.skip 1
.indent -5
Use
.skip 1
><PARSE maintains all parts of the trace structure except for
TRVT/(TRVLC, TRVTP).
><IZVAR maintains TRVT/(TRVLC, TRVTP)
.skip 1
TRCT is initialized to TRCT: 100000,,100000
.break
#########################+1:#####999
.break
######################with TRCTN=1
.skip 1
TRVT is initialized by setting TRVN=0
.skip 1
NOVTR is initialized to NOVTR: 100001,,100001 with NOVTN=1
.skip 1
NOVTR and TRCT are kept sorted, with no overlap or duplication; TRCT is sorted first on /TCVL, then on line range.
.subtitle #####Register Usage
.page
.index Register ^Usage
.skip 1
.center 80
Register Usage
.skip 1
.left margin 23
.indent -8
.X <RXJ
R1(RXJ_#)#--#><JSP register:##procedure calls, ><GOSUB calls, ><RHED calls,
.x <FOR ^Loops
FOR loop body calls
.indent -8
.skip 1
.INDEX <PUSHJ
.X <RXP
R17(RXP_#)#--#push jump register for system (flowchart and library) calls
and array element accessing. Often refered to in the code as 'P'.
.skip 1
.indent -8
.X <RXO
R16(RXO_#)#--#statement origin register (see Statement Orientation)
.skip 1
.i-8
R15(WLOCR) -- workspace module hiseg register. Used as an index register in direct
statements
.x <WLOCR
.x direct#statements
.skip 1
.i-8
R14(UVARR) -- workspace module loseg register. Used as an index register in direct
statements
.x <UVARR
.left margin 10
.skip 1
Note:
.i+2
Registers R14 thru R17 are reserved for dedicated use by TBA.
.subtitle #####Processing of Monitor-Controlled Interrupts
.page
.index Processing of ^Monitor-^Controlled ^Interrupts
.skip 1
.center 80
Processing of Monitor-Controlled Interrupts
.skip 1
.INDEX interrupts
.INDEX Escapes
A stack of locations is maintained to which control is to be
passed when an escape is typed by the user:
.skip 1
.left margin 15
.INDEX <EXSXR
.INDEX <EXLOC
.INDEX <EXRXP
.INDEX <EXSX
.INDEX <EXN
REC##EXSXR,_<_<EXLOC,18_>,
.indent 5
_<EXRXP,18_>_>
.skip 1
Array##EXSX[0:10*EXSXR]
.skip 1
.left margin 30
.indent -7
EXN -- current depth of stack
.skip 1
.indent -10
/EXLOC -- address to resume control
.skip 1
.indent -10
.X <RXP
/><EXRXP -- value to place in r[RXP_#] before passing control
.left margin 10
.skip 1
@EXSX[I*EXSXR] points to the record holding the interrupt
information for the level I.
.skip 1
A set of routines govern whether the interrupt is to
actually be serviced:
.skip 1
.left margin 23
.indent -12
.INDEX <EXOFF
.INDEX <EXPEEK
.INDEX <EXON
EXOFF( ) -- when called, causes escapes to be ignored
.skip 1
.indent -13
EXPEEK( ) -- when called, returns non-zero if an escape has been
ignored since the most recent call to EXOFF( )
.skip 1
.indent -11
EXON( ) -- when called, rearms escapes and, if an escape has been
typed since the most recent call to EXOFF( ), transfers control
according to the top of EXSX[ ].
.subtitle #####DEBUG/NO DEBUG
.page
.index <DEBUG/NO <DEBUG
.skip 1
.center 80
DEBUG/NO DEBUG
.left margin 10
.skip 1
The system variable ><DEBGSW is set to 1 when DEBUG and 0 when NO DEBUG.
The initial value is 1.
.skip 1
><DEBGSW is noticed by several TBA processes:
.skip 1
.left margin 15
process########(= 0) =_>
.break
-------########--------
.skip 1
BREAK,TRACE,###prohibit yourself
.break
><STEP
.skip 1
><COMPIL#########generate calls to ><RPHED insted of ><RHED
.skip 1
><RDXMX##########shorter >subscripting code
.i+16;(not yet implemented)
.left margin 10
.subtitle #####Numeric Scalars
.page
.index Numeric ^Scalars
.left margin 10
.skip 1
.center 80
Numeric Scalars
.skip 1
.nofill
Numeric Scalars are stored as
.left margin 30
.indent -15
.skip 1
Type###########Format
.indent -15
----###########------ 
.indent -15
.skip 1
logical########one word integer:
0 = FALSE
1 = TRUE
.skip 1
.indent -15
integer########one word integer
.skip 1
.indent -15
real###########one word floating point
.skip 1
.indent -15
double#########KI-10 format double precision floating
.skip 1
.indent -15
.fill
complex########two consecutive single precision floating
values#--#(real part,imaginary part)
.subtitle #####Type Codes
.page
.left margin 10
.index Type ^Codes
.skip 1
.center 80
Type Codes
.skip 1
The TBA data-type code conventions are:
.skip 1
.left margin 15
type########name######value
.break
----########----######-----
.skip 1
.index logical scalars
.index integer scalars
.index real scalars
.index double precision scalars
.index complex scalars
logical#####><LOG_#########0
.skip 1
integer#####><INT_#########1
.skip 1
real########><REAL_########2
.skip 1
.X <DBL
double######DBL_#########3
.skip 1
.X <CMPLX
.X <CPLX
complex#####CPLX_# or####4
.break
.X <CMPLX
.X <CPLX
############CMPLX_#
.skip 1
.X <STR
string######STR_#########5
.subtitle #####String Scalars
.page
.index String Scalars
.left margin 10
.skip 1
.center 80
String Scalars
.skip 1
.index String ^Descriptors
.index string body
A string scalar comprises a descriptor and a body.
.skip 1
The descriptor occupies two words:
.left margin 15
.skip 1
0:# body address
.skip 1
1:# curr length | max length
.left margin 10
.skip 1
The body begins on a word boundary and each character
occupies seven bits:
.skip 1
.left margin 21
.indent -6
0:# BYTE(7)C1,C2,C3,C4,C5
.skip 1
.indent -6
1:# BYTE(7)C6, etc
.skip 1
.left margin 10
The fields of the descriptor are accessed via:
.skip 1
.indent 5
.INDEX <SDR
.INDEX <SDADR
.INDEX <SDCL
.INDEX <SDML
REC##SDR,_<_<SDADR,36_>,_<SDCL,18_>,_<SDML,18_>_>
.skip 1
.left margin 30
.indent -10
/SDADR -- address of string body; if zero,
denotes an unallocated string, any reference to which should
be diagnosed
.skip 1
.indent -10
/SDCL# -- number of characters currently stored in the body.
.skip 1
.indent -10
/SDML# -- declared length of the string -- the body has been
allocated enough space to hold this many characters
.skip 1
.left margin 10
The string body is always allocated an integral number of fullwords
and is initialized to all zero bits.
Bit 35 of each body word always remains zero.
Whenever a value is stored into a string, unused character
positions in the last-stored body word are set to zero bits.
Hence, some string operations can be performed on a fullword basis.
.subtitle #####Messages
.page
.index Messages
.skip 1
.center 80
Messages
.skip 1
Constant messages (prompts, diagnostics, etc.) are not stored
as string bodies with string descriptors.
Instead they are stored in ASCIZ form -- termination is by 
a NUL.
.subtitle #####Terminal-Related Functions
.page
.index Terminal-^Related ^Functions
.skip 1
.center 80
Terminal-Related Functions
.skip 1
See Tymcom-X Terminal Interface Standards.
The primary data structure involved is the command input stack (CX):
.skip 1
.indent 5
.nojustify
.INDEX <CX
.INDEX <CXR
.INDEX <CXFN
.INDEX <CXLN
.INDEX <CXEP
.INDEX <CXNM
.INDEX <CXNMS
REC####CXR,_<_<CXFN,18_>,_<CXLN,18_>,_<CXEP,12_>,_<CXNM,24_>_>
.indent 5
.skip 1
><FTBL###CX,11,CXR
.skip 1
.indent 5
.X <VTBL
VTBL###CXNMS,60
.skip 1
.left margin 31
.indent -9
/CXFN -- file number; 0 = terminal
.skip 1
.indent -9
/CXLN -- ordinal line number of command most
recently read (at this level)
.skip 1
.indent -9
.INDEX <ECHO
/CXEP -- echo state; 1 = ECHO; 0 = NO ECHO
.skip 1
.indent -9
/CXNM -- record identifier (within CXNMS)
of file nomen
.skip 2
.left margin 10
.justify
When TBA initially starts up, the first entry in CX
is created with
.skip 1
.indent 5
0 -_> CX[0]/(CXFN,CXLN,CXEP)
.skip 1
and with /CXNM referring to the initial entry of CXNMS,
which is 'TERMINAL'.
.skip 1
The (ECHO,NO ECHO) commands simply set CX[0]/CXEP to (1,0).
.skip 1
The variable ><TPOS always holds the current value of ><POS
(carriage position of the physical terminal).
The following utility routines perform terminal-oriented
operations for the TBA system.
.left margin 15
.skip 1
.indent -5
.INDEX <CXCI
.INDEX <TOUT ^Destination
.index Command ^Echo ^Destination
.index Command ^Input
1.###CXCI(#) -- Command Input
.skip 1
Fetch and return a character from the current command source.
No editing is to be performed.
If echo is on, post the character to the ><TOUT destination;
exception: when command input is from terminal, never echo to terminal.
If the character is the first of a new line then increment CX[0]/CXLN.
If the end of file has just been reached (logically speaking),
.INDEX <CXKX
call CXKX(#), and return a NUL (ASCII 0) -- in this case,
the next call to CXCI will access the lower level command source.
.skip 1
.tp 7
Usage Note:
.skip 1
.INDEX <CXCI
><GETLIN will read its characters via CXCI(#).
><PARSE will only call ><GETLIN when the command source is the
terminal; command file input is done via
CXCI(#), directly.
Runtime file input from the * file number will use CXCI(#) directly.
.skip 1
.left margin 15
.indent -5
.index Command ^Files
2.###CXDO(F) -- Open New Command File
.skip 1
F points to a string descriptor which refers
to a string which holds, hopefully, a file-nomen.
The file is to be opened as the command source and a new
level added to CX with all fields appropriately initialized.
CXDO(#) normally returns the value 1.
If for any reason the operation cannot be completed, a value
0 is returned after ><CXER is called with an appropriate
diagnostic message.
.skip 1
.indent -5
.INDEX <CXER
.index Error ^Conditions in ^Command ^File
3.###CXER(E) -- Error Conditions Encountered
.skip 1
An error has been encountered.
E is the address of an appropriate ASCIZ diagnostic message.
Actions a thru c, section VIII of 'Terminal Interface Standards
for Tymcom X' are to be performed.
The Error Message Destination is the ><TOUT destination
and the TERMINAL.
Note:# unstacking does not occur if terminal is command source.
.skip 1
.indent -5
.INDEX <CXKX
.INDEX <CX
.INDEX Echo state
.index Command ^Files, closing
4.###CXKX(#) -- Close Command File
.skip 1
If CX currently contains only one entry (the TERMINAL),
do nothing.
Otherwise, terminate processing from the current command source,
pop CX[0] and revert to the next lower command source.
Note that a prior echo state is thereby reinstated.
.skip 1
.indent -5
.test page 16
.INDEX <CXMO
.INDEX <MOCR
.INDEX <MONOCR
.INDEX <MOSTR
.index Message ^Output
5.###CXMO(MSG,MODE) -- Message Output
.skip 1
A message is to be output.  The value of MODE determines the
coding scheme:
.skip 1
.nojustify
.indent 5
MODE#########################MSG is
.indent 5
 ----#########################------ 
.skip 1
.left margin 35
.indent -20
MOCR_# = 1###########address of ASCIZ message to
which an EOL should be logically appended
.skip 1
.indent -20
MONOCR_# = 2#########address of ASCIZ message;
append no EOL
.skip 1
.indent -20
.X <MOSTR
MOSTR_# = 3##########address of string descriptor;
append no EOL
.skip 1
.left margin 15
.justify
If command source is terminal then post message to terminal.
If echo is on then:
.skip 1
.left margin 20
If ><TOUT File exists, post to it.
.skip 1
Else if terminal not command source, post to terminal.
.left margin 15
.skip 1
Usage Note:
.skip 1
CXMO(#) should be used by TBA for all prompts and messages, as
defined in the Terminal Interface Standards.
.skip 1
.indent -5
.INDEX <CXTI
.INDEX Terminal ^Input
6.###CXTI(#) -- Terminal Input
.skip 1
Fetch and return character from the physical terminal.
Do not echo it anywhere.
Perform no editing.
.skip 1
Usage Note:
.skip 1
CXTI(#) is used for the INPUT statement either where no file is
specified or where the file number refers to the TERMINAL
opened as a numbered file.  CXTI(#) is also used for the
EIGHTI statement.
.skip 1
.left margin 14
.indent -5
.test page 13
.index <CXTDO
.index Terminal-^Directed ^Output
7.###CXTDO(C) -- Terminal-Directed Output
.skip 1
C is a character (ASCII code) to be
posted to the ><TOUT destination.
.skip 1
Usage Note:
.skip 1
CXTDO is intended to perform all Terminal - Directed Output,
as defined in the Interface Standards.
.X <PMC
.X <LIST
This would include output from such commands as LIST, PMC and
><CDE and from the ><PRINT statement where no file number is specified.
If TERMINAL is the ><TOUT destination, then C is posted via CXTO(#).
.skip 1
.indent -5
.test page 8
.index <CXTO
.index Terminal ^Output
8.###CXTO(C) -- TERMINAL Output
.skip 1
Post the character C to the physical terminal.
.skip 1
Implementation Note:
.skip 1
CXTO(#) and CXTI(#) are responsible for maintaining the
variable TPOS.
.skip 1
Usage Note:
.skip 1
CXTO(#) is used for the EIGHTO statement and for the ><PRINT
statement where a file number has been specified which
refers to the TERMINAL.
.subtitle #####System-Level File IO
.page
.index System-^Level ^File <IO
.index File <IO
.index <IO
.index paging
.skip 1
.center 80
File IO
.skip 1
.left margin 10
Input/output operations on files are performed by a paging algorithm.
For the purposes of this algorithm, files are divided up into
pages. All pages are of the same length and the number of words in a page is always a power of two.
.indent 5
To initiate IO operations on a file, the file must first be created
.index <CREATE
.index <OPENF
.index <CONOPN
or opened by calling one of the routines CREATE, OPENF or CONOPN. 
.index File ^Control ^Blocks
Each of these routines sets up a file control block describing the file
.index Virtual ^Addresses
and returns the "virtual address" of the beginning of the file.  A virtual
address is the address of a word or byte within a file combined with 
a field that identifies the file.  A virtual address therefore
uniquely identifies a specific word or byte of a particular file among
all of the words or bytes in all of the files that are currently active.  
.index Virtual ^Word ^Addresses
Virtual addresses are of two types:  virtual word addresses and 
.index Virtual ^Byte ^Addresses
virtual byte addresses.  A virtual word address contains a high-order
field that identifies a particular file and a low-order field that
contains the address of a word in the file relative to the beginning of
the file (word 0).  A virtual byte address also contains a high-order
field that identifies a particular file, together with a low-order field
that contains the address of a byte in the file relative to the beginning
of the file (byte 0).
.indent 5
Given the virtual address of the beginning of the file, the virtual
address of any word or byte in the file can be constructed by simple 
addition.  In order to access a word of the file, the macro ><READ is used
to translate the virtual word address of the desired word into a core 
address.  Similarly, to access a byte of the file the macro ><READCR is used
to translate the virtual byte address of the desired byte into a core
address.  The way in which this translation is performed will now
be described.
.indent 5
.index Paging ^Algorithm
The paging algorithm first searches a hash table containing one entry
for every page that is currently in core. If the page containing
the required word or byte is present,
 the search will locate it and supply the core address of its first
word. Given this address, the address of the desired word or byte within
the page is then constructed and returned.
.indent 5
If the page is not present in core memory, the paging algorithm must then find a place to store the page in core memory.  To do this, it scans a map
 of the region of memory where
pages are stored, looking for a free space. The map is known as
.index Core ^Table
the core table and the region of memory is referred to as the 
.index Paging ^Area
paging area. In most cases, no free spaces will be available
and the paging algorithm must remove one of the pages currently
in memory to make way for the new page.
.indent 5
In selecting a page to be removed, the algorithm takes three factors
 into account. 
Firstly, a page which is currently being accessed must not be
removed from memory. Secondly, a page which has not been modified
during the time that it has been in memory should be selected ahead of a page which has been modified, because a modified page must be written
back to its file, while an unmodified page may be discarded,
since an up-to-date copy already exists in the file.
Thirdly, the least recently referenced page should be selected, on the
assumption that it is the page which is least likely to be referenced in
the near future.
.indent 5
If a suitable page is found, it is removed from memory. If not, a
space is created by obtaining more core 
memory from the monitor. The desired page is then read into
the vacant space. In the case where a request is made to access
a word or byte that lies beyond the end of the file, a page of zero words
is created and appended to the file.
.indent 5
When the page has been located or brought into memory, a marker is set
in the core table to indicate that the page is in use and must not
be removed by a subsequent scan. The marker is in the form of a count of the number of READ and READCR  operations that have been performed
for the page and not yet cancelled. The count is incremented by each new
><READ or ><READCR operation that references the page.
.indent 5
A ><READ is cancelled by calling either the ><WRITE macro
or the ><FREE macro.  Similarly, a ><READCR is cancelled by calling either the
><WRITCR or ><FREECR macro.  A call to one of these macros signals that the
page is no longer being used and causes the count in the core table 
entry for the page to be decremented. When the count becomes negative,
all outstanding ><READ and ><READCR  requests for the page have been cancelled
and it may be considered for removal from core memory during
subsequent scans of the core table.
.indent 5
At the moment when the count becomes negative, the current value of
a pseudo clock register is stored in the core table entry for
the page so as to record the time of last access to the page.
.indent 5
The WRITE and WRITCR macros are used to inform the paging algorithm that the page
has been modified and must ultimately be written back to the file,
whereas the FREE and FREECR macros are used to indicate that the page has not
been modified and need not be written back to the file
(unless it has been modified by other accesses).
.skip 1
.indent 5
.indent 5
.index Word ^Cursor
The ><READ macro returns a "word cursor".  This is a word containing the
core address of the requested word in its right half and a count of the
number of words between that word and the following page boundary in its
.index Byte ^Cursor
left half.  The ><READCR macro returns a "byte cursor".  This is a standard
PDP10 byte pointer.  The page may be accessed directly, using the
word cursor or byte cursor.  Note that this requires that the user 
.index Page ^Boundaries
should be aware of the existence and location of page boundaries in the
file.  The size of pages used by the pager is specified by the global
.X <PSIZE
assembly-time variable PSIZE.  Its value can be changed by altering the
.X <PEX
value of another global assembly-time variable, PEX.
.skip 1
.X <PSIZE
.indent 5
PSIZE=2**PEX
.skip 1
.indent 5
A set of macros and subroutines is provided that eliminate the need for
users of the pager to be concerned with page boundaries in most cases.
These macros and subroutines transfer a single word, a single byte, a block
of words, or a string of bytes to or from the file.  Each transfer advances
the cursor to the next word or byte in the file, turning pages as required.
When these operations are used, only the first page of the file has to be
read explicitly and only the last page has to be released explicitly.
Following is a summary of the tables maintained by the paging
algorithm.
.left margin 20
.skip 1
.index Channel ^Table
.index File ^Control ^Blocks
(1) Channel table - a table containing the address of the file control block for each active channel.
.skip 1
data in each entry:
.indent 5
-address of file control block
.skip 1
.index File ^Control ^Blocks
(2) File control blocks - structures containing details of each
active file.
.skip 1
format:
.indent 5
COUNT - count of arguments for monitor calls
.indent 5
PTR - relative address of directory name
.indent 5
NAM - file name in 6-bit bytes
.indent 5
EXT - file extension in 6-bit bytes
.indent 5
CON - confirmation information used by CONOPN
.indent 5
LEN - length of file in words
.indent 5
DIR - directory name in 6-bit bytes
.indent 5
CHAN - channel number
.indent 5
NLEN - length of file name in bytes
.indent 5
><STR - file name string in 7-bit bytes
.skip 1
.index Core ^Table
(3) Core table - a table containing information about each page
frame in the paging area
.skip 1
data in each entry:
.indent 5
- use count or age
.indent 5
- page modified indication
.indent 5
- hash table index of page
.skip 1
.index Hash ^Table, ^Paging ^Algorithm
(4) Hash table - a table containing information about each page
currently in core memory
.skip 1
data in each entry:
.indent 5
- virtual page number
.indent 5
- core table index of page
.left margin 10
.skip 2
.index Open and ^Close ^Operations
OPEN AND CLOSE OPERATIONS
.skip 1
1. ><CREATE creates a new file (or a new version of 
an existing file) and opens it for reading and writing,
bypassing the confirmation procedure. It returns a result indicator
and the virtual address of word zero of the file. CREATE is a
subroutine.
.skip 1
Parameters
.skip 1
R0 - address of a file name string
.break
A file name string is a string of left-justified 7-bit bytes
in the following format:
.skip 1
.lm -6
S[(S_<directory_>S)]S_<file name_>[.[_<extension_>]]S[-S_<confirmation_>S]N
.lm +6
.skip 1
Where [,] denotes optional items
.indent 5
S denotes a string of zero or more spaces
.indent 5
N denotes the null character (000)
.skip 1
.index Default ^Extension
R1 - default extension string to be used if the file name string
contains no explicit extension. The string should be left justified.
If no extension is required, this parameter should be zero.
.skip 1
Results
.skip 1
R1 - result indicator
.indent 5
1 if file successfully created
.indent 5
0 if error detected (an error message will have been printed)
.indent 5
-1 if the file name is "TERMINAL"
.break
R2 - virtual address of word zero of the file
.break
R3 - address of a copy of the file name string in edited form
.skip 2
2. ><OPENF opens a file for reading and writing, bypassing the
confirmation procedure. It returns a result indicator and the virtual address of word zero of the file. OPENF is a subroutine.
.skip 1
.test page 5
Parameters
.indent 5
R0 - address of a file name string.
.indent 5
R1 - 0 if file is to be opened for reading only.
.indent 5
#####1 if file is to be opened for both reading and writing.
.skip 1
Results
.indent 5
R1 - result indicator as for CREATE.
.indent 5
R2 - virtual address of word zero of the file.
.indent 5
R3 - address of a copy of the file name string in edited form.
.skip 2
3. ><CONOPN creates a new file if no file exists or opens an existing
file using the full confirmation procedure specified by Tymshare. 
It returns a result indicator and the virtual address of word 
zero of the file.
.skip 1
Parameters
.indent 5
R0 - address of a file name string
.indent 5
R1 - 0 open file for reading only.
.indent 4
#####-1 validate file name only
.indent 4
######1 open file for both reading and writing.
.indent 5
.index Default ^Extension
R2 - default extension string to be used if the file name string contains no explicit extension. The string should be left 
justified.
.skip 1
Results
.indent 5
R1 - result indicator as for CREATE.
.indent 5
R2 - virtual address of word zero of the file.
.indent 5
R3 - address of a copy of the file name string in edited form.
.skip 1
.X <CREATE
4. ><CLOSEF closes a file that has previously been opened by a CREATE,
.X <CONOPN
><OPENF or CONOPN. It removes all pages of the file from core (even if they are locked) and writes them back to the file if necessary.
 CLOSEF is a subroutine.
.skip 1
Parameter
.indent 5
R0 - virtual address of any word or byte of the file.
.skip 2
5. DELETE deletes a file that has previously been opened
by CREATE, OPENF or CONOPN. It removes all pages of the file from core (even if they are locked).
Delete is a subroutine.
.skip 1
Parameter
.indent 5
R0 - virtual address of any word or byte of the file
.skip 1
Result
.indent 5
R1 - result indicator
.indent 5
#####1 if successful
.indent 5
#####0 if deletion not permitted
.skip 2
.page
.index Word-^Oriented <IO
.index <IO, ^Word-^Oriented
WORD-ORIENTED IO
.skip 1
1. ><READ converts a virtual word address into a word cursor. It takes the
virtual word address stored in the location specified by the effective
address and replaces it by the corresponding word cursor. READ is a macro.
.skip 1
Parameter
.indent 10
1-address of word containing the virtual address
.skip 1
.indent 5
The page containing the address will remain in core until a 
><WRITE or ><FREE operation is performed.
.skip 2
2. ><WRITE releases a page that is no longer required so that
it may be written back
to its file.  It takes the word cursor in the location 
specified by the effective address and releases the page containing
that address.  It also overwrites the word cursor with the 
corresponding virtual word address.
 WRITE is a macro.
.skip 1
Parameter
.indent 10
1-address of word containing the cursor
.skip 1
3. ><FREE releases a page that is no longer required so that it
may be removed from core memory. Its operation is similar to that of 
WRITE, except that the page is simply removed from core memory
and is not written back to its file. FREE is a macro.
.skip 1
Parameter
.indent 10
1-address of word containing the cursor
.skip 1
.indent 5
A READ  operation should always be paired with either a WRITE or a 
FREE. If the number  of READs performed on a page does not match
the number of WRITEs and FREEs, the page will either remain in core
indefinitely or will be released prematurely.
.skip 2
4.  ><IN reads a word from a file.  It takes the word cursor in a
designated register and loads the word at that file address into a
specified register.  It then advances the cursor so that it points to
the next word of the file.  IN is a macro.
.skip 1
Parameters
.indent 10
1-number of register that is to receive the word
.indent 10
2-number of register containing the cursor (should not be register zero)
.skip 1
Parameters one and two should not specify the same register.
.skip 2
5.  ><OUT writes a word into a file.  It takes the word cursor
in a designated register and stores the contents of a specified register
into that file address.  It then advances the cursor so that it points to
the next word of the file.  OUT is a macro.
.skip 1
Parameters
.indent 10
1-number of register containing the word
.indent 10
2-number of register containing the cursor (should not be register zero)
.skip 1
Parameters one and two should not specify the same register.
.skip 2
6.  ><TFR transfers a group of consecutive words from an area of memory to
a file or from a file to an area of memory.  TFR also advances the word
cursor to point to the next word of the file beyond the area transferred.
TFR is a subroutine.
.skip 1
Parameters
.indent 10
R0 - number of words to be transferred
.indent 10
R1 - word cursor
.indent 10
R2 - memory address
.indent 10
R3 - direction of transfer
.break
###############0 read into memory
.break
###############1 write into file
.skip 1
Results
.indent 10
R1 - updated cursor
.indent 10
R2 - updated memory address
.skip 2
7.  ><STEP moves a word cursor backward or forward a specified number
of words from its current position.  If the cursor crosses a page boundary
it will either WRITE or FREE the current page as required.  ><STEP is a
subroutine.
.skip 1
Parameters
.indent 10
R0 - positive or negative number of words
.indent 10
R1 - word cursor
.indent 10
R2 - 0 if current page to be freed
.indent 15
1 if current page to be written
.skip 1
Result
.indent 10
R1 - updated word cursor
.skip 3
.page
.index Byte-^Oriented <IO
.index <IO, ^Byte-^Oriented
BYTE-ORIENTED IO
.skip 2
1.  ><READCR converts a virtual byte address into a byte cursor.  It takes
the virtual byte address stored in the location specified by the effective
address and replaces it by the corresponding byte cursor.  READCR is a 
macro.
.skip 1
Parameters
.indent 10
1-address of word containing virtual byte address
.indent 10
2-size of byte in bits
.skip 2
2.  ><WRITCR releases a page that is no longer required so that it may be 
written back to its file.  It takes the byte cursor in the location specified
by the effective address and releases the page containing that address.
It also overwrites the byte cursor with the corresponding virtual byte
address.  WRITCR is a macro.
.skip 1
Parameter
.indent 10
1-address of byte cursor
.skip 2
3.  ><FREECR releases a page that is no longer required so that it may be 
removed from core memory.  Its operation is similar to that of WRITCR, except
that the page is simply removed from core memory and is not written
back to its file.  FREECR is a macro.
.skip 1
Parameter
.indent 10
1-address of byte cursor
.skip 2
4.  ><INCR reads a byte from a file.  It takes the byte cursor in the 
location specified by the effective address and advances it so that it points
to the next byte in the file.  It then loads that byte into a specified 
register.  INCR is a macro.
.skip 1
Parameters
.indent 10
1-number of register that will receive the byte
.indent 10
2-address of byte cursor
.skip 1
Note that the mnemonic ILDBV may be used interchangeably with INCR.
.skip 2
5.  ><OUTCR writes a byte into a file.  It takes the byte cursor in the
location specified by the effective address and advances it so that 
it points to the next byte in the file.  It then stores the byte from a
specified register into that byte position.  OUTCR is a macro.
.skip 1
Parameters
.indent 10
1-number of register containing the byte
.indent 10
2-address of byte cursor
.skip 1
Note that the mnemonic IDPBV may be used interchangeably with OUTCR.
.skip 2
6.  ><TFRSTR transfers a group of consecutive bytes from an area of memory
to a file or from a file to an area of memory.  It advances the byte 
cursor to point to the next byte of the file, transfers the specified
number of bytes starting at that position, and leaves the byte cursor
pointing to the last byte transferred.  ><TFRSTR is a subroutine.
.skip 1
Parameters
.indent 10
R0 - number of bytes to be transferred
.indent 10
R1 - byte cursor
.indent 10
R2 - word address of memory area
.indent 10
R3 - direction of transfer
.indent 15
0 file to memory
.indent 15
1 memory to file
.skip 1
Result
#####R1 - updated byte cursor
.skip 2
7.  ><STEPCR moves a byte cursor backward or forward a specified number of bytes
from its current position.  If the cursor crosses a page boundary, ><STEPCR
will either WRITE or FREE the current page as required.  ><STEPCR
is a subroutine.
.skip 1
Parameters
.indent 10
R0 - positive or negative number of bytes
.indent 10
R1 - byte cursor
.indent 10
R2 - 0 if current page to be freed
.indent 15
1 if current page to be written
.skip 1
Result
.indent 10
R1 - updated byte cursor
.skip 3
MISCELLANEOUS ROUTINES
.skip 2
1.  MARK sets a marker associated with a page that will cause the page
to be written back to its file when the page is released.  MARK is mainly
useful when a file is being accessed simultaneously for both reading
and writing.
.indent 5
The sequential output operations OUT, OUTCR, TFR, and ><TFRSTR all
turn the pages of a file as they advance through it.  As the cursor moves
to the next page, the previous page is released by a WRITE operation.
Similarly on input, IN, INCR, TFR, and ><TFRSTR release pages by a FREE
operation.  When input and output operations are interleaved, output may
occur within a page, but the page boundary may be crossed during an input
operation, so that the modified page will not be written back to its file.
To avoid this problem, when input and output operations are 
occurring on the same file, every output should be followed by a MARK 
operation.  MARK is a macro.
.skip 1
Parameters
.indent 10
1-number of register containing a word or byte cursor 
.indent 10
(should not be register zero)
.skip 1
MARK does not alter the contents of the register.
.skip 2
2.  ><LOCK causes a page to be locked in core so that normal page turning 
operations of sequential IO will not remove it from core memory.
.indent 5
For example, suppose that a file is being scanned sequentially using
IN operations.  Suppose also that at some point in the scan, a pointer
to a section of the file needs to be retained, even though the scan
through the file should continue.  To prevent the desired page from
being released when the scan passes on to the following page, a LOCK 
operation is performed on the first page.
.indent 5
Every LOCK operation should be paired with a WRITE, FREE, WRITCR, or FREECR
operation to unlock the page when it is no longer required.  LOCK is
a macro.
.skip 1
Parameter
.indent 10
1-number of register containing a word or byte cursor 
.indent 10
(should not be register zero)
.skip 1
LOCK does not alter the contents of the register.
.skip 2
3.  ><FCB obtains information about a currently open file.  Specifically, it
returns the address of the file control block for the file.  As previously
described, this block contains the file name, length, project-programmer
number, etc.  FCB is a macro.
.skip 1
Parameter
.indent 10
1-number of register containing the virtual
.indent 10
address of any word or byte in the file
.indent 10
(should not be register zero)
.skip 1
Result
.indent 10
1-address of file control block in same register
.indent 10
as above
.skip 2
4. ><TRANSFER is a basic IO subroutine that writes information to a file
or reads information from it. The core address and file
addresses of the information and the length of the transfer are all specified explicitly by the caller.
.skip 1
Parameters
.indent 5
R0 - core address of first word
.indent 5
R1 - virtual address of first word
.break
#####(must be a multiple of 128)
.indent 5
R2 - number of words to be transferred
.indent 5
R3 - direction of transfer
.indent 10
0 -read
.indent 10
1 - write
.subtitle #####Program-File Formats
.page
.index Program-^File ^Formats
.skip 1
.center 80
Program-File Formats
.skip 1
The ><SAVE command creates a very straightforward file.
Each line is terminated by a CR LF.
There are no tabs or special line-number or page-mark codes.
A line may be split between blocks;
the file is an uninterrupted stream of data characters.
The last block is filled out, if not full, with NULs.
.skip 1
.subtitle #####Get-File Formats
.page
.index ^G^E^T-^File ^Formats
.X <GET
.skip 1
.center 80
GET-File Formats
.skip 1
The ><GET command accepts a broader class of files than that created
.X <SAVE
by SAVE.
Only printable characters and blanks are allowed within a line
(no control characters or carriage returns or line feeds may be
interior to the line).
.skip 1
.index Ampersand
.index Line ^Continuation
.index Linefeed
When a non-empty input line is terminated by an ampersand, the
following line is to be logically appended.
The sequence ampersand,carriage return,linefeed is
replaced in the TBA input buffer by the single character
linefeed.
Linefeed characters are totally ignored by the parser.
.X <SAVE
When text is output by TBA (under LIST, SAVE, etc.)
the interior linefeeds are retranslated into ampersand,carriage
return,linefeed.
Under editing, the linefeed prints as 
ampersand, return,linefeed, but is treated as a single character --
thus it will be copied by a _&C and deleted by _&N.
.skip 1
.index Page ^Marks
.index Form ^Feeds
.index Sticky ^Line ^Numbers
Page marks, form feeds and sticky line numbers are ignored at
the beginning of a line (see EDIT10 manual, pp.#20, 21).
NULLs are ignored at the end of a line.
.index Bit 35
Any other occurrences of a bit 35_#0 is diagnosed "non-symbolic
file" and input is terminated.
Any other occurrence of an illegal character is diagnosed
and the line is discarded.
An overlong line is diagnosed and discarded.
.skip 1
.subtitle #####DUMP REFS and Tempcor Files
.page
.index <DUMP <REFS and ^Tempcor ^Files
.skip 1
.center 80
DUMP REFS and Tempcor Files
.skip 1
.index <TMPCOR files
Tempcor files are a special kind of file used for communication
between programs.
In particular, the ><CROSS program obtains information about which .CRF
files exist by examining a particular tempcor file, named 'CRE'.
This tempcor file may either exist in core, under the name 'CRE',
or it may exist on disk under the name 'nnnCRE.TMP',
where nnn represents the job number of the current job.
.skip 1
The DUMP REFS command performs two functions.
First it creates an appropriate .CRF file.
Secondly, it appends the name of the created file to the end
of the CRE tempcor file.
The following algorithm is followed:
.test page 28
.skip 6
.center 80
read current
.center 80
CRE from core
.skip 2
.center 80
no####################yes
.center 80
found?
.skip 3
.center 80
#####read from###############rewrite updated
.center 80
#####disk####################CRE on disk
.skip 1
###no##############yes
.break
#########found?
.skip 1
write on#######update
.break
disk###########on disk
.skip 6
.title #####TYMBASIC GID -- ><DECLAR
.subtitle #####Declaration Processing (DECLAR)
.page
.index Declaration ^Processing <(DECLAR)
.X <DECLAR
.skip 1
.center 80
Declaration Processing (DECLAR)
.skip 1
.X <DECLAR
The module DECLAR, as the first pass in compiling the user's
.index <PMC
program, reads the pmc's for declarations, DATA statements, DEFs,
.INDEX <DATA ^Statement
ENDFs and NAME statements.
.x <NAME
From that information and a partialy filled LRT and in some cases an
existing SDT, DECLAR does the following tasks:
.skip 1
.lm+5
Creates an SDT (Symbol Definition Table), a PRODT (PROcedure
Definition Table), and a PARDT (PARameter Definition Table).
.skip 1
Creates an LRXT, an LRT rapid lookup table
.x <LRXT
.skip 1
Creates a DTAV table for inline data
.skip 1
Allocates R%VRLC space for variables (except implictly declared variables
which have space allocated in COMPIL.)
.x <COMPIL
.skip 1
Checks for DEF/ENDF mismatches.
.skip 1
Counts FOR loops and allocates R%VRLC space for cells to contain
return address.
.x <FOR
.skip 1
Checks validity of NAME statements.
.skip 1
Sets the values of LRT/LSUBN; clears LRT/LEFG
.lm-4
.index <LRT
.index <LSUBN
.X <DTAV
.X <SDT
.X <PRODT
.X <PARDT
.INDEX <LEFG
.INDEX <LCOD
.skip 1
Subsequent modules are responsible for these partially
declarative tasks:
.skip 1
.indent 5
(1)##Establishing LRT/LCOD
.skip 1
.indent 5
(2)##Setting LRT/LEFG
.skip 1
.skip 1
If an error is encountered during the processing of a line, a
.INDEX <CXER
diagnostic is printed (via CXER) and processing continues with
the succeeding declarative line.
If errors have been found when ><DECLAR finishes, control is passed to
.X <PARSE
PARSE, otherwise we go on to COMPIL.
The DECLAR pass also handles the SYMD command.
.x <SYMD
.x <COMPIL
.skip 1
See Task Table and Transition Table.
.subtitle #####Symbol Definitions (SDT, PRODT, PARDT)
.page
.index Symbol ^Definitions <(SDT, <PRODT, <PARDT)
.index <SDT
.index <PRODT
.index <PARDT
.skip 1
.center 80
Symbol Definitions (SDT, PRODT, PARDT)
.skip 1
The ><SDT contains entries describing each symbol found in the module.
Each symbol with a unique spelling is assigned an ><SDT position known as
.x <ID
its ID.
><SDT normally holds the definitions of all global-level variables
of the TBA source program, but during processing (by ><DECLAR or
.index Procedure ^Compilation
.index Parameter ^Definitions
.X <COMPIL
COMPIL) of a procedure body, the parameter and local variable definitions temporarily
supplant global variables of the same spelling.
.X <SDT
The structure of SDT, the Symbol Definition Table, is given by:
.skip 1
.left margin 20
.indent -5
.nojustify
.INDEX <SDTR
.INDEX <SLOC
.INDEX <SUSED
.INDEX <STYP
.INDEX <SKND
.INDEX <SN
REC##SDTR,_<_<SLOC,18_>,_<STYP,3_>,_<SUSED,1_>,_<SKND,2_>,
#####_<SN,9_>,_<SPROCN,12_>_>
.justify
.skip 1
.indent -5
.INDEX <SDT
TBL##SDT,,SDTR
.skip 1
.left margin 25
.indent -5
.X <SLOC
/SLOC# -- ><R%VRLC value (location) of symbol
.skip 1
.indent -5
.X <STR
.X <STYP
.X <LOG
/STYP# -- data type (><LOG_# - STR_#)
.skip 1
.indent -5
.X <SUSED
/SUSED# = 1 _<=_> declaration for this variable has been processed
.skip 1
.indent -5
.x <SKND
/SKND# --
.break
.index <SSCAL
.index <SARY
.index <SPRO
.index <SPARY
SSCAL_# =_> scalar variable
.break
SARY_## =_> array variable
.break
SPRO_## =_> procedure
.break
SPARY_# =_> array parameter
.skip 1
.indent -5
/SN### -- 
.break
/SKND = (SARY_# or SPARY_#) =_> number of #####dimensions (limit 10)
.break
/SKND = SPRO_# =_> procedure number (limit 511)
.break
(PRODT record number) else unused
.skip 1
.indent -5
.x <SPROCN
/SPROCN -- ID of procedure to which this variable is local
.skip 1
.left margin 10
.X <MINLV
R%VRLC values are assigned beginning with MINLV_#, and increasing by
the number of words statically allocated to each symbol 
(see Numeric Scalars, String Scalars, and Arrays.)
.skip 1
.INDEX Symbol ^Types
.index Types, ^Symbol
Types are assigned either by an explicit declaration or by a ><DIM
statement to the appropriate implicit type
.index <NAMT
(the latter requiring examination of NAMT).
The first declaration encountered for a variable will set /SUSED to 1.
A subsequent declaration must agree in type and dimensionality.
.skip 1
.test page 14
For procedures (/SKND=SPRO_#), the procedure number (/SN) locates
.index Procedure ^Compilation
.index <SN
.X <PRODT
the entry for that symbol in PRODT.
><PRODT is structured as follows:
.skip 1
.nojustify
.index <PRODTR
.index <LDRNAM
.index <PPARS
.index <PPFIN
.index <PFXP
.index <PNAM
.index <PMODD
.index <PNP
.index <PFDIM
.i+5;REC##PRODTR,_<_<LDRNAM,36_>,_<PPARS,18_>,_<PPFIN,18_>,_<PFXP,18_>,
.indent 10
_<PNAM,18_>,_<PFROC,12_>,_<PMODD,9_>,_<PNP,5_>,_<PUSD,1_>,_<PFDIM,4_>_>
.skip 1
.indent 5
><TBL##PRODT,,PRODTR
.left margin 30
.skip 1
.indent -10
/LDRNAM -- radix 50 spelling of the procedure name
.skip 1
.indent -10
/PPARS -- record number in PARDT of initial local or parameter name
.skip 1
.indent -10
/PPFIN -- record number in PARDT of last local or parameter name
.SKIP 1
.INDENT -10
/PFXP# -- fixup address for procedure calls
.skip 1
.indent -10
.INDEX Procedure ^Name
/PNAM# -- ><ID of the procedure name
.skip 1
.i-10
.index <PFROC
/PFROC -- ID of the procedure to which this prcodeure is local
.skip 1
.indent -10
/PMODD -- mode 0 through 7 as follows:
.skip 1
.nf
0 = normal
1 = TBA ENTRY
2 = EXTERNAL
3 = TBA EXTERNAL (same as 2)
4 = SFO EXTERNAL
5 = CFO EXTERNAL
6 = SIMPL EXTERNAL
7 = BLISS EXTERNAL
.fill
.skip 1
.indent -10
/PNP## -- number of parameters (limit 31)
.skip 1
.indent -10
/PUSD# -- =0 ==_> COMPIL has not yet learned the address of the procedure
.skip 1
.indent -10
/PFDIM -- number of dimensions (for array-valued procedure, else 0)
.skip 1
.justify
.left margin 10
.test page 19
A chain of PARDT entries is associated with each PRODT entry.
These are records beginning with the record number /PPARS and linked through /PARLNK up through record number /PPFIN.
The structure of PARDT is:
.skip 1
.nojustify
.indent 5
.index <PARDTR
.index <PALOC
.index <PATYP
.index <PAKND
.index <PARDT
.index <PASN
.index <PANAM
.index <PAUSD
.index <PROCNO
.index <PARLNK
.index Local ^Variable ^Compilation
.index Name ^Scoping
.index Parameter ^Compilation
REC##PARDTR,_<_<PALOC,18_>,_<PATYP,3_>,_<PAUSD,1_>,_<PAKND,2_>,
.indent 10
_<PASN,9_>,_<PROCNO,12_>,_<PANAM,12_>,_<PARLNK,12_>_>
.skip 1
.indent 5
><TBL##PARDT,,PARDTR
.left margin 30
.skip 1
.indent -10
.x <R%VRLC
.x <PVEC
/PALOC -- same as SLOC in SDT
procedure
.skip 1
.indent -10
/PATYP -- same as STYP in SDT
.skip 1
.indent -10
/PAUSD -- same as SUSED in SDT
.skip 1
.indent -10
/PAKND -- same as SKND in SDT
.skip 1
.indent -10
/PASN# -- same as SN in SDT
.skip 1
.indent -10
/PROCNO -- same as SPROCN in SDT
.skip 1
.indent -10
/PANAM -- ><ID of symbol
.skip 1
.indent -10
/PARLNK -- pointer (link) to next PARDT entry in chain
.skip 1
.justify
.left margin 10
Normally PARDT holds the specification information for each
of the parameters or locals of the corresponding procedure.
.X <COMPIL
During compilation of the procedure (by either ><DECLAR or COMPIL)
body, the param/local fields are swapped with the ><SDT fields of the
corresponding global variable.
The correspondence is:
.skip 1
.indent 5
SDT/(SLOC,STYP,SUSED,SKND,SN,SPROCN)
.indent 17
_<-_>
.indent 5
PARDT/(PALOC,PATYP,PAUSD,PAKND,PASN,PROCNO)
Thus during the compilation or declaration of a procedure, the
SDT holds definitions of all the symbols that may be referenced.
.subtitle #####DATA Statement Values (DTAV)
.page
.index <DATA ^Statement ^Values <(DTAV)
.index <DATV
.skip 1
.center 80
DATA Statement Values (DTAV)
.skip 1
DATA values are stored by ><DECLAR into DTAV:
.skip 1
.indent 5
.X <VTBL
VTBL##DTAV,,7
.skip 1
.index <DATA ^Statement
Each record consists of the characters from a single DATA statement.
.title #####Tymbasic GID -- COMPIL
.subtitle #####Code Generation (COMPIL, Optimization, Direct Statements)
.page
.index Direct ^Statements
.x Direct ^Statements
.index Code ^Generation <(COMPIL, ^Optimization, ^Direct ^Statements)
.index <COMPIL
.index Optimization
.skip 1
.center 80
Code Generation (COMPIL, Optimization, Direct Statements)
.index Direct ^Statements
.skip 1
.X <PMC
><COMPIL generates code for the user program by reading all pmcs in line
.X <SDT
.x <LRXT
.X <PARDT
.X <PRODT
number order and making reference to SDT, PARDT, PRODT, and LRXT.
.X <REL
The output of ><COMPIL is the file prog.REL, where prog is the current
><SAVE name.
The only symbols included in prog.><REL are those required to accomplish
linkages to externally supplied routines.
The level of >optimization of the code generated by ><COMPIL is determined
by three principles:
.skip 1
.left margin 20
.indent -5
1.###><COMPIL works primarily from the Operand Data Structure which
provides only local information
.skip 1
.indent -5
2.###operations described in the Runtime Utilities section are performed
by those routines and hence not by open code
.skip 1
.indent -5
3.###generation of special code to take advantage of constant
operands is only done where, in the judgment of the TBA development
team, a significant overall system performance improvement
can be made.
Examples are:
.skip 1
.left margin 30
.indent -5
.index immediate instructions
.index constants
a.###immediate instructions are generated for constants
where possible
.skip 1
.indent -5
b.###>constants within expressions of a higher type are converted
at compile time
.skip 1
.indent -5
c.###relational operators involving the constant zero compile
JUMP instructions
.skip 1
.left margin 10
.index Direct ^Statements
(See Direct Statements.)
.subtitle #####Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV)
.page
.index Operand ^Data ^Structure <(OPDSTK, <OPDL, <OPDN, <O1P, <O2P, <RGSV )
.index <OPDSTK
.index <OPDL
.index <OPDN
.index <O1P
.index <O2P
.index <RGSV
.skip 2
.skip 1
.center 80
Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV)
.skip 1
The ><PARSE output, ><pmc codes, are in a right-handed polish string which
designates operands and then subsequently presents the operator
which is to operate on them.
The status of the operands, during the compilation of a single
statement, is maintained on the operand stack, OPDSTK.
For both convenience and efficiency, an array of pointers, OPDL,
is maintained to the active entries of the stack.
.skip 1
.indent 5
OPDL[1] thru OPDL[OPDN]
.skip 1
are the addresses of the OPDN active entries. For ease in handling
degenerate cases, OPDL[0] = 0.
An operand is removed from the top of the stack by
.skip 1
.indent 5
-1 + -_> OPDN
.skip 1
and from position K by
.skip 1
.indent 5
-1 + -_> OPDN
.skip 1
.indent 5
OPDL[J+1] -_> OPDL[J] for J = K to OPDN
.skip 1
Thus operands are manipulated in toto by simple pointer operations.
.skip 1
In addition the pointers O1P and O2P are always maintained such that
O1P = OPDL[OPDN-1] and O2P = OPDL[OPDN].
Hence for a binary operator the operands are O1P and O2P.
The action of each operator, besides generating correct code, must
leave all elements of the Operand Data Structure in a correct,
consistent state.
.skip 1
.test page 18
The structure of an operand entry is:
.skip 1
.indent 5
.index <OPDR
.index <OL
.index <OV
.index <OC
.index <OM
.index <OT
.index <ONG
.index <OPDSTK
REC##OPDR,_<_<OL,36_>,_<OV,36_>,_<OC,18_>,_<OM,18_>
.indent 10
_<OT,18_>,_<ONG,18_>_>
.skip 1
.indent 10
OPDSTK[0:159]##Array with room for 40 operand stack entries
.skip 1
.left margin 21
/OC# -- class
.skip 1
/OM# -- Mode
.skip 1
.X <LOG_#
.X <STR
/OT# -- Type (LOG_#:STR_#)
.skip 1
/OL# -- Location
.skip 1
/OV# -- Value
.skip 1
/ONG -- Pending Negation or number of dimensions for arrays
.skip 1
.left margin 10
.test page 14
Operands are categorized on a hierarchical basis with the primary
discriminator being Class:
.skip 1
.left margin 15
/OC#######means
.break
---#######-----
.skip 1
.index <ONSC
.index <OSSC
.index <OMX
.index <OTST
.index <OSC
.index <OSST
.X <STR
ONSC_######Numeric Scalar; /OT not STR_#
.skip 1
.X <STR
OSSC_######String Scalar; /OT = STR_#
.skip 1
OMX_#######Matrix
.skip 1
OTST_######Test
.skip 1
OSC_#######Slice Colon
.skip 1
0SST_######Slice Star
.skip 1
.indent -5
.test page 19
.index <ONSC
For /OC = ONSC_#,
.skip 1
/OM#######means
.break
---#######-----
.skip 1
.left margin 25
.indent -10
.index <OKON
.index <OREG
.index <OLVAR
.index <OUVAR
.index <OSUB
.index <ONG
.x Constants
OKON_######constant is in (/OV,/OL)
.break
.X <CMPLX
.X <CPLX
.X <DBL
###########(/OL = low part of DBL_#; no CPLX_#)
.skip 1
.indent -10
.X <CMPLX
.X <CPLX
.X <DBL
/OREG_######value is in register /OL and, if CPLX_# or DBL_#, in
1 + /OL; [Note:# only registers 0 thru 5 can be involved in any operand]
.skip 1
.indent -10
.X <CMPLX
.X <CPLX
.X <DBL
.X <OTMP
OLVAR_#####(= OTMP_#) value in ><R%VRLC location /OL (and 1+/OL if DBL_# or CPLX_#);
Temp cell descriptor pointer in /OV.
.skip 1
.indent -10
OUVAR_#####User variable; Value in R%VRLC location /OL; absolute
.index Direct ^Statements
addressing needed if compiling a continuable direct statement; 
.index <QV
/QV=variable ID
.skip 1
.indent -10
/OSUB_# (=4) address of value in r[/OL] or if /OL _> 15 decimal, address
of vaule in temp at R%VRLC location /OL.
Temp cell descriptor pointer in /OV.
.x Temp cell descriptor pointer
.skip 1
.indent -10
.index Value ^Negation
/ONG not 0 _<=_> negation of the value has been deferred; /ONG not used
for OKON_# or OSUB_#
.skip 1
.indent -15
.test page 13
.index <OSSC
For /OC = OSSC_#
.skip 1
.indent -10
/OM#######means
.indent -10
---#######-----
.skip 1
.indent -10
.index Literals
.index <LIT
OKON_######literal, /OL= record_# in LIT
.skip 1
.indent -10
.index Temporary ^Cells
OTMP_######temporary cell; ><R%VRLC location
of descriptor in /OL; Temp cell descriptor pointer in /OV.
.skip 1
.indent -10
OUVAR_#####descriptor at R%VRLC location /OL; user variable; 
.index <QV
/QV=variable ID
.skip 1
.indent -10
.index Array ^Elements
/OSUB_#####address of array element in r[/OL], or
><R%VRLC location /OL.
.skip 2
.indent -15
.test page 18
.index <OMX
For /OC = OMX_#,
.skip 1
.indent -10
.index <ONG
.index <OREG
.index <OUVAR
.index <OSUB
.index <OTMP
.index Array ^Dimensions
/ONG -- number of dimensions
.skip 1
.indent -10
/OM#######means
.indent -10
---#######-----
.skip 1
.indent -10
OREG_######operand is a mat value in ><RAC
.skip 1
.indent -10
OUVAR_#####User variable; operand is simply the name of an array; ><R%VRLC location of 
description in /OL; /OV not 0 means operand is array parameter.
.index Array ^Parameters
.skip 1
.indent -10
.index Array ^Elements
OSUB_######User variable; operand is to become an array element; ><R%VRLC location of
descriptor in /OL; prior /ONG opnds on OPDSTK are the subscript expressions; /OV not 0 means operand is array parameter.
.skip 1
.indent -10
OTMP_######opnd is a mat value in a temp cell; R%VRLC location if
descriptor in /OL; Temp cell descriptor pointer in /OV.
.skip 1
.indent -15
.test page 6
.index <OTST
For /OC = OTST_#,
.skip 1
.left margin 15
.index Relational ^Operation, ^Deferred
the opnd is a deferred relational operation; /OM is the operator
(OLT_#,(=1) OLE_#,(=3) OEQ_#,(=2) ONE_#,(=6) OGE_#,(=5) 
OGT_#,(=7); the prior two operands on OPDSTK are the comparands.
.skip 2
.left margin 10
.test page 17
So as to avoid repetitive searching of OPDSTK to determine which
.index <RGSV
registers are committed to which operands, a status vector, RGSV,
is maintained which, for each register, displays the involvement of
that register in the recently generated code.
.skip 1
.left margin 25
.indent -10
RGSV[r]###means
.indent -10
-------###-----
.skip 1
.indent -10
0##########register unused
.skip 1
.indent -10
.index Register ^Usage
.index <ORSVD
.index Temporary ^Cells
.X <COMPIL
ORSVD_#####register reserved by COMPIL; not saveable in a temp cell
or useable for an operand
.skip 1
.indent -10
n#########register in use by operand OPDL[n]; 0 _< n _< = OPDN
.skip 1
.subtitle #####Literals (LIT,SLIT)
.page
.skip 1
.center 80
Literals (LIT,SLIT,LHSH)
.index <LHSH
.x <SLIT
.index Literals
.index <LIT
.skip 2
.left margin 20
><TBL LIT,40,LITR
.skip 1
/LV -- numeric scalar constant
.left margin 27
.indent -7
.skip 1
/LL -- low-order word of numeric scalar, if type is double, or for strings,
the virtual address of the body
.left margin 20
.skip 1
/LADR -- fixup address
.skip 1
.X <VTBL
VTBL SLIT,,7
.skip 1
TBL LHSH,1,LBSZE
.skip 1
.left margin 10
.indent 5
There are three tables used for handeling literals.
The LIT table holds the type and fixup adr of the literals.
It also holds the actual literal for numeric literals, or a pointer into the
SLIT table for string literals.
.skip 1
The SLIT table holds the actual string literals.
A hash table, LHSH, holds hash codes for every LIT table entry and is used for
literal pooling.
Each record in LHSH is a block of LBSZE hashes.
This was done to avoid a lot of pager activity when pooling literals.
.skip 1
Numeric scalar constants are carried on the operand stack until they
are referenced.
At that point the LIT table is searched, with the aid of the LHSH table, for
a matching literal.
If no match is found a new LIT record is created for the literal.
When a string constant is encountered we search the LIT records for a match.
If no match is found a LIT record is created and the string is stored in the
SLIT table.
The fixup address is not filled in until the string is first referenced.
.index String ^Constants
The operand stack entry for the string carries the LIT record number
in the /OL field.
.subtitle #####Temp-cell Description Table (TQDT)
.page
.skip 2
.center 80
Temp-cell Description table (TQDT)
.index Temporary ^Cells
.index Temp-cell ^Description ^Table <(TQDT)
.index <TQ^DT, Definition
.skip 2
.left margin 10
.indent 5
Temp-cells which have been allocated by ><COMPIL in the course of 
generating code for expressions are kept track of in TQDT:
.skip 2
.indent 10
.index <TQSZE
TBL##TQDT,1,TQSZE
.skip 1
.i+5;Every Temp cell has a temp cell descriptor which holds three pieces of
information: its location, its size, and whether or not it is busy.
The size of a temp cell is either one or two words for 
single length or double length numeric scalars and string descriptors, or
more than two words for temporary array descriptors.
The size is stored in the right 17 bits of the left half of the temp cell
descriptor. The left most bit of the size field is set to indicate a temp
cell for a string descriptor which may not be used for a numeric scalar.
.i+5;The location of a temp cell is determined by R%VRLC at the time
of allocation.
The location is stored in the descriptor's right half.
The leftmost bit of the descriptor is the busy flag. It is set to one to
indicate a busy temp cell.
.skip 1
.i+5;In the old days each descriptor was a record in the TQDT table.
This caused a lot of pager activity so now each record is a block of TQSZE
descriptors. TQDBLK is a block of core large enough to hold TQSZE descriptors.
A descriptor pointer, which contains a block number (or TQDT record number)
in the left half and a number between 1 and TQSZE in the right, is used to
identify a descriptor.
.index <R%VRLC
.index <TQDBLK
.index temp#cell#descriptor
TQSZE is large enough that TQDT will almost alway have but one record.
.skip 1
.i+5;When a procedure call is encountered, the contents of all busy temp cells
must be saved away in virgin R%VRLC territory.
This is because the procedure may use the same temp cells (Even a non-TBA
procedure or a TBA procedure in another module may call yet another
procedure in this module.)
.i+5;Temp cells must be freed after use and no temp cell may remain busy
beyond the compilation of one line of the TBA source.
.index Function ^Calls
.subtitle #####Control Stack (CSTK, CSTKP)
.page
.index Control ^Stack <(CSTK, <CSTKP)
.index <CSTK
.index <CSTKP
.skip 1
.center 80
Control Stack (CSTK, CSTKP)
.skip 1
.left margin 10
.index Conditionals, ^Compilation of
Compilation of conditional control structures is governed by the
.index <CSTK
.index <CSTKR
.index <CFXL
.index <CBGL
.index <CMODF
stack, CSTK.
.skip 1
.left margin 15
CSTKP -- always = @CSTK[0]
.skip 1
REC##CSTKR,_<_<CFXL,18_>,_<CBGL,18_>,_<CMODF,18_>,_<CLNM,18_>
.index <CLNM
.skip 1
><FTBL##CSTK,15,CSTKR
.skip 1
.left margin 20
/CFXL# -- head of fixup chain
.skip 1
/CBGL# -- location of condition evaluation
.skip 1
.left margin 30
.indent -10
/CMODF -- governing conditional:
.left margin 30
.index <IF
.index <WHILE
.index <UNLESS
.index <ELSE
.index <ORIF
CIF_#, CUNLS_#, CWHIL_#, CUNTL_#, CELSE_#, CORIF_# (equal to the corresponding OPTYPE values)
.i-10
.skip 1
/CLNM##-- LRT record number for use in errors
.index <LRT
.skip 1
.left margin 10
Whenever a primary conditional (IF, WHILE, UNTIL, UNLESS) is encountered,
an entry is created on CSTK.
The stack supports the bookkeeping for forward references and back
branches (WHILE, UNTIL).
When a secondary conditional (ORIF, ELSE) is encountered, the proper
code is emitted and /CMODF is set to the secondary conditional.
When the ENDIF pmc is reached, proper code is emitted and
CSTK[0] is popped.
.i+4;When compilatio is completed, an error will be given for every entry
remaining on the CSTK.
/CLNM is used to give the line number of the primary conditional.
.title #####TYMBASIC GID -- Runside Layout
.subtitle #####Arrays
.page
.index Arrays
.skip 1
.center 80
Arrays
.skip 1
An array comprises a descriptor and a body.
.index Array ^Descriptors
.index Array ^Bodies
The size of the descriptor depends on the number of dimensions
of the array, while the body size depends on the type and the
current dimension bounds.
Appendix F of the TYMBASIC REFERENCE MANUAL dicusses internal array handling.
.skip 1
For an array of N dimensions, the descriptor has the form:
.skip 1
.nofill
.index <ATAG
.index <ALOC
.index <ABSZ
.index <ABASE
.index <ATYP
.index <ANDIM
.index ^A^L^Bn
.index ^A^U^Bn
.index ^A^C^O^E^Fn
.index <CADR
.index <ADSR
##########-----------------------------
ADSR######[###/ATAG#####][###/ALOC####]
##########[###/ABSZ#####][###/ABASE###]
##########[###/ATYP#####][###/ANDIM###]
+3########[###/ALB0#####][###/AUB0####]
########################:################-Bounds, higher
########################:#################dimensions
+/ANDIM+3#[###/ACOEFO###][###/ACOEF1##]
########################:################-ACOEF's, higher
########################:#################dimensions
+CADR#####[########access code########]
##########[###########################]
##########-----------------------------
.fill
.skip 1
.left margin 20
.nofill
CADR = Code address = /ANDIM+(/ANDIM+1)div 2 + ADSR +3
.fill
.skip 2
.indent -10
The data portion of the descriptor is mapped by:
.skip 1
REC#####ADR,_<_<ATAG,18_>,_<ALOC,18_>,_<ABSZ,18_>,
.break
#####_<ABASE,18_>,_<ATYP,18_>,_<ANDIM,18_>,_<ALB0,18_>,
.break
#####_<AUB0,18_>,_<ALB1,18_>,_<AUB1,18_>,...,
.break
#####_<ACOEF0,18_>,_<ACOEF1,18_>..._>
.skip 1
/ATAG -- Slice tag field. Ignored for "parent" 
.break
#########array, contains bitmap for slices.
.skip 1
/ALOC -- Address of the array body 
.skip 1
/ABSZ -- Array body size
.skip 1
/ABASE -- Computed array base
.skip 1
/ATYP -- Data type of array
.skip 1
/ANDIM -- Number of dimensions
.skip 1
/ALBi -- Lower bound, dimension i
.skip 1
/AUBi -- Upper bound, dimension i
.skip 1
/ACOEFi -- Access coefficient, dimension i
.skip 1
Array Descriptor sizes are determined as
follows:
.skip 1
Number of dimensions######Size in words
.break
--------------------######-------------
.break
#########1######################13
.break
#########2######################19
.break
########n_>2###############5+n+(n+1)div2
.skip 2
.left margin 10
.indent 5
The address of an array element is obtained by executing the
access code section of the array
descriptior. For one and two dimensional arrays the array
subscript values are passed in R1 and R1,R2 respectively. For
the two dimensional case, R1 contains the rightmost
subscript. Subscript values for arrays of higher dimensionality
are passed in the psuedo registers, with PR[0] containing the rightmost
subscript. For all cases the access code call is:
.skip 1
#####><PUSHJ####RXP,CADR####(see above for CADR calculation)
.skip 1
The address of the referenced element is returned in R2.
.skip 1
.indent 5
Subscript bounds testing may take one of two forms
.INDEX <DEBUG
.index Subscript ^Checking
determined by the (DEBUG/NO DEBUG) mode switch. If in
DEBUG mode, each subscript is checked against the bounds for each
dimension. In NO DEBUG mode the calculated element address is tested
to determine if it is within the array body boundaries. Note
that one and two dimensional arrays are always treated as if in
DEBUG mode. If any boundary is exceeded, control is transferred to
the error processing routine.
.skip 1
The body of an array is a contiguous block of storage with the
elements of the array stored consecutively in the order
of right-most subscript varying most rapidly.
For a numeric array, each element is simply the one or two
words required to store a scalar of that type.
.skip 1
.index String ^Array
.index String ^Descriptors
For a string array, each element is a two word string descriptor
of the form:
.skip 1
.indent 5
0:# String body pointer.
.skip 1
.indent 5
1:# Current length,, Maximum length
.skip 1
Note that when the string array is declared, the word (0 | max length)
must be stored as the second word of each element, while zero is
stored in the pointer word.
String bodies must be explicitly allocated as an independent
process by the string processing routines.
.page
.nj;.lm+10;.tab stop10;.p-10;
.p;/AMAP	Slice dimension map.  Note:  bits within this field
are number ^&right to left\& with the rightmost bit as bit zero.
.s;A dimension j (0<=j<=n-1 where n is the number of dimension of the parent array) which is to be fixed (hidden)
in the slice is denoted by a zero (0) in bit position j.  If A is
the set of all hidden dimension numbers for all i not in A and 0<= i
<= n-1:  /ATAG bit i = 1.  All other bits zero.
.p;/AHCNT	The number of hidden dimensions
.s;.p;/ALOC	The address of the access code portion of the
parent descriptor.
.s;.p;/ABSZ	The number of logical element in the slice.  Note
that a single element may occupy either one or two words depending
on type.
.s;.p;/ABASE	Not used for slices (actually, points to parent descriptor
.s;.p;/ATYP	The type of the slice (same as parent)
.s;.p;/ANDIM	The apparent dimensionality of the slice.  That is,
the number of dimensions of the parent, minus the number of hidden
dimensions.
.s;.p;/ALBi	Lower bound for apparent dimension i
.s;.p;/AUBi	Upper bound for apparent dimensions i
.s;.p;/ACOEFi	Remapping coefficient - used by AREMAP routine
.s;.p;/AHDIMi	Subscript for hidden dimensions.  These are ordered
by increasing actual (ie. as in parent) dimension.  For example
/AHDIM0 contains the subscript corresponding to dimension indicated
by the first zero encountered in /ATAG examining from right to left.
.lm-10;.s2;ADSR+CADR is the address branched to when accessing the slice.
Note that to the array user, the slice appears identical to a non-sliced
array as long as the access code is used for element access.
.page;
.lit;



CADR =  /ANDIM+  (/ANDIM +1) DIV2 +3

SIZE =  CADR +2+  (/AHCNT+1) DIV 2
     =  5+n+  (n+1) DIV 2+
              (/ATTENT+1) DIV 2

Maximum descriptor size =  20 words
.end lit;
.lit;


           4bits 14 bits
                                       ADSR = descriptor address
          |-------------------------|
ADSR      |/AHCNT|/AMAP |/ALOC      | 
          |      |      |           |
          |-------------------------|
     +1   |   /ABSZ     |/ABASE     |
          |-------------------------|
     +2   |   /ATYP     |/ANDIM     |
          |-------------------------|
     +3   |   /ALBO     |/AUB0      |
          |-------------------------|
          .             .           .
          .             .           .  /ALBi's, /AUBis  i > 0
          .             .           .
          |-------------------------|
+/ANDIM+3 |  /ACOEF0    |/ACOEF1    |
          |-------------------------|
          .             .           .
          .             .           .  /ACOEFi's  i > 1 
          .             .           .
          |-------------------------|
          |   MOVEI  RO, CADR       |
          |-------------------------|
          |   JSP    R3, SLACC      |
          |-------------------------|
+CADR+2   |  /AHDIM0    |/AHDIM1    |
          |-------------------------|
          .             .           .
          .             .           .  /AHDIM's  i > 1
          .             .           .
          |-------------------------|

CADR =  /ANDIM+  (/ANDIM +1) DIV 2 +3

SIZE =  CADR +2+ (/AHCNT+1)  DIV 2
     =  5+n+  (n+1) DIV 2+
              (/ATTENT+1) DIV 2

Maximum descriptor size =   20 words
.end lit;
.subtitle #####Statement Orientation (RHED, BTFG, RXFG)
.page
.index Statement ^Orientation <(RHED, <BTFG, <RXFG)
.index <RHED
.index <BTFG
.index <RXFG
.skip 1
.center 80
Statement Orientation (RHED, BTFG, RXFG)
.skip 1
The code generated for each TBA statement includes an orientation
sequence whose purpose is to support such features as BREAK,
.index <DEBUG
.index <BREAK
.index <TRACE
.index <RESUME
TRACE, RESUME, continuation after errors, and printout of
offending statements with diagnostics.
The orientation sequence, which is
.skip 1
.indent 5
MOVEI##RXL,linenum
.skip 1
.indent 5
><JSP####R16,rhed
.skip 1
normally occurs as the first two codes for each line.
The exception is ><DEF statements (see User Defined Procedures), where
some linkage code precedes.
When DEBUG, rhed is the routine RHED; when NO DEBUG, rhed is .#+#1
.X <RXO
and thus simply records the statement location in register 16 (RXO).
.skip 1
When exit from a TBA statement may be temporary, as in
.skip 1
.nofill
.left margin 15
><GOSUB
><CALL
.index Procedure ^References
.index Conditional ^Processing
.index Diagnostic ^Routines
procedure reference
transfer to condition processor
diagnostic routine
.skip 1
.left margin 10
.fill
.X <RXL
.X <RXO
then the values of R1 (RXJ), R16 (RXO) and, in some cases, the location
counter, are saved, so as to support the specified level of
continuability.
The variable BTFG (set by ><XRUN initialization) is non-zero if and
only if at least one of ><BRKN or ><TRCN is non-zero.
The variable RXFG (initialized to BTFG by ><XRUN initialization and
set to 1 if escape is typed) is non-zero if and only if ><RHED should
consider not returning immediately upon being called.
Thus, even in DEBUG mode, interpretative overhead is minimized whenever
no BREAK or TRACE statements are active.
.subtitle #####Module Orientation (MQHED)
.page
.index Module ^Orientation <(MQHED)
.index <MQHED
.skip 1
.center 80
Module Orientation (MQHED)
.skip 1
The variable MQHED holds the address of the hiseg of the module
currently in control.
This variable is saved and/or set by the execution of the following
situations:
.skip 1
.left margin 15
.index Procedure prologues, <ENTRY
.index Trap ^Handling
.index <XRUN startup
ENTRY procedure prologues
.skip 1
trap handling
.skip 1
><XRUN startup
.skip 1
><EXIT statement
.skip 1
.left margin 10
Whenever MQHED is set or unset to the workspace module,
then BTEG and RXFG are appropriately set.
.subtitle #####><GOSUB Processing (RGOSUB, RGRET, GSBSTK)
.page
.index <GOSUB ^Processing <(RGOSUB, <RGRET, <GSBSTK)
.index <RGOSUB
.index <RGRET
.index <GSBSTK
.skip 1
.center 80
><GOSUB Processing (RGOSUB, RGRET, GSBSTK)
.skip 1
A stack, GSBSTK, is maintained on the runside.
GSBSTK holds the return address and the values (at ><GOSUB time) of
.X <RXJ
.X <RXO
the register RXL_# and R16 (RXO).
The statement
.skip 1
.indent 5
><GOSUB line
.skip 1
compiles into
.skip 1
.indent 5
MOVEI##r2,address of line location
.skip 1
.indent 5
><JSP####R1,RGOSUB
.skip 1
The statement
.skip 1
.indent 5
><RETURN
.skip 1
compiles into
.skip 1
.indent 5
JRST##><RGRET
.skip 1
RGRET restores the stacked items and returns to past the ><RGOSUB call.
If the stack is empty, RGRET prints a diagnostic and causes the
line holding the ><RETURN to be printed.
.subtitle #####String and Matrix Code
.page
.index String and ^Matrix ^Code
.skip 1
.left margin 10
.center 80
String and Matrix Code
.skip 1
.index Array ^Code
One bit is used to describe each string or array that is passed to a runside routine.
.skip 1
.indent 5
0:##User variable, if array.  User variable,
.indent 5
.index Literals
.index Temporary ^Results
array element, or literal, if string scalar.
.skip 1
.indent 5
1:##Temporary result (either array or string)
.skip 1
The flags are found in bits 33 and 35 of r5,
for strings whose addresses are passed in r1 and in r2,
respectively; and in bits 33 and 35 of r0, for arrays
whose addresses are passed in r2 and r3, respectively.
.subtitle #####FOR Loops
.page
.index <FOR ^Loops
.skip 1
.center 80
FOR LOOPS
.skip 1
A FOR loop is compiled into the following code pattern:
.left margin 25
.skip 1
.nofill
iterpart 1
iterpart 2
 ...
iterpart n
JRST past
.skip 1
.indent -10
body:#####MOVEM##R1,><FRET
bodycode
JRST##@><FRET
.indent -10
past:
.skip 1
.indent -15
A multi-line FOR loop ends as follows:
.skip 1
JSP####1,@fret
.indent -10
past:#####MOVEI##1,[JRST 0,0(1)]
MOVEM##1,fret
.skip 1
.indent -15
An iterpart with an upper bound compiles into:
.skip 1
eval initial value
eval step
eval upper bound
convert each to type of itervarb
load initial to AC
AC -_> itervarb
.skip 1
.indent -10
loop:#####compare AC to bound
if done, JRST out
AC -_> itervarb
><JSP##R1,body
itervarb + step -_> AC
JRST loop
.indent -10
out:
.skip 1
.indent -15
A ><WHILE or ><UNTIL iterpart compiles to:
.skip 1
eval initial value and step
convert each to type of itervarb
initial -_> itervarb
.skip 1
.indent -10
loop:#####test condition
if done, JRST out
><JSP##R1,body
step + -_> itervarb
JRST loop
.indent -10
out:
.subtitle #####FOR Loop Generation (FORSTK, FORP, FORTYP, FORBX)
.page
.index <FOR ^Loop ^Generation <(FORSTK, <FORP, <FORTYP, <FORBX)
.index <FORSTK
.index <FORP
.index <FORTYP
.index <FORBX
.skip 1
.center 80
FOR Loop Generation (FORSTK, FORP, FORTYP, FORBX)
.skip 1
.fill
.left margin 10
Compilation of FOR loops is accomplished using these data
structures:
.skip 1
.left margin 25
.indent -10
FORP## -- always equal to TLOC(FORSTK,0)
.skip 1
.indent -10
FORSTK -- stack to facilitate nested FOR loops; only the top record
is accessed
.skip 1
.left margin 20
FTBL#FORSTC,15,FORSC
.skip 1
.index <FORSR
.index <FVAR
.index <FFXP
.index <FRET
.index <FTYP
.index <FLVAR
.index <FFLG
REC##FORSR,_<_<FVAR,18_>,_<FFXP,18_>,_<FRET,18_>,
.indent 5
_<FTYP,18_>,_<FLVAR,18_>,_<FFLG,18_>,_<FLNM,18_>_>
.skip 1
.left margin 35
.indent -10
/FVAR# -- varid of itervarb
.skip 1
.indent -10
/FFXP# -- during processing of loop body:# address of JRST around body
During processing of iterparts:# address of head of fix-up chain for
references to the first word of the body.  In the case of SUM, PROD,
MAX and MIN, the body is compiled first, so the address of the
first word of body code goes here.
.skip 1
.indent -10
/FRET# -- R%VRLC address where loop return address is stored.
.skip 1
.indent -10
/FTYP# -- type of itervarb
.skip 1
.indent -10
/FLVAR -- R%VRLC location of itervarb
.skip 1
.indent -10
/FFLG# -- =1 for SUM, PROD, MAX and MIN
=0 otherwise
.skip 1
.i-10
/FLNM##-- LRT record number for use in errors
.index <LRT
.left margin 10
FDLV, FDTP, and FDND:# R%VRLC address, type, and number of dimensions
of dummy SUM, PROD, MAX or MIN variable, respectively.
.skip 1
As part of runside initialization of indirect statements, RUNIZL
stores the address of word 2 of the code into each /FRET
location (except for SUM, PROD, MAX and MIN).
This word contains the instruction JRST 0,0(1).
.skip 1
When compilation is complete, an error will be given for every entry
remaining on the FORSTK.
/FLNM is used to give the line number of the FOR for this error message.
.subtitle #####User-Defined Procedures
.page
.index User-^Defined ^Procedures
.skip 1
.center 80
User-Defined Procedures
.index Procedures, ^User-^Defined
.skip 1
.left margin 10
Each procedure has an entry point (PEPT) and a parameter
.index <PEPT
.index <PVEC
vector (PVEC).
PEPT is the location (in the hiseg) of the procedure body,
while ><PVEC is the location (in the loseg) of a block which
holds the data local to the procedure.
.index <LRT
.index <LCOD
PEPT is kept in LRT/LCOD for the line of the ><DEF of the
.X <SDT
.INDEX <SLOC
procedure, while ><PVEC is in the SDT/SLOC field of the name of the
procedure.
.skip 1
.index Return ^Address
The first word of ><PVEC holds the return address
for the procedure.
.index Parameters, ^User-^Defined ^Procedure
Successive groups of words hold the parameters in the order they appear in 
the DEF statement.
The number of words allocated to each parameter depends upon
the kind of parameter.
Numeric scalars are simply allocated the one or two words required
to hold a scalar value of that type.
When the procedure is called, the value of the scalar argument
.X <PVEC
is stored into the allocated portion of the PVEC.
.skip 1
.index String ^Parameters
For a string parameter, two words are allocated for a string
.index String ^Descriptors
descriptor.
At call time, a block of storage is allocated into which the
contents of the argument body is moved.
The descriptor is then set so that it points to this new body by doing:
.skip 1
.left margin 24
.indent -7
.index <SDADR
.index <SDCL
.index <SDML
/SDADR = address of allocated block
.skip 1
.indent -7
/SDCL# = /SDML = length of argument, in characters
.skip 1
.left margin 10
.index Array ^Parameter, ^User-^Defined ^Procedures
.X <PVEC
For an array parameter, two items are allocated in PVEC.
.index Array ^Descriptors
First, a single word is used to point to the descriptor
currently being used for the parameter.
Following the array pointer word, storage is reserved for a
descriptor of the appropriate dimensionality.
the pointer word is mapped by:
.skip 1
.indent 5
.index <APR
.index <APLIF
.index <APLOC
REC##APR,_<_<APLIF,18_>,_<APLOC,18_>_>
.skip 1
.indent 10
.index Array ^Parameters, ^Call by ^Value
/APLIF -- ><NAM_# or ><VAL_#
.skip 1
.indent 10
/APLOC -- descriptor address
.skip 1
When an array argument is passed by name, then /APLIF
is set to NAM_# and /APLOC is set to the address of the
descriptor of the argument array.
When an array is passed by value, then a block is allocated
.X <PVEC
to hold a copy of the body, the descriptor in PVEC is set to
.X <VAL_#
describe that copy, /APLIF is set to VAL_#, and /APLOC is
set to point to the ><PVEC descriptor.
References to an array parameter within the body of the procedure
are always carried out indirectly through /APLOC.
.skip 1
.test page 8
One word is reserved in ><PVEC to hold the call time value
.X <RXL
.X <RXO
of register R16 (RXO); ><EXIT is thus able to restore the
environment of the calling statement.
When an ><EXIT is performed, local parameter bodies are de-allocated:
string parameter bodies are released and /SDADR is set to zero.
.X <VAL_#
.X <NAM_#
For array parameters with /APLIF = NAM_#, /APLIF is set to VAL_#,
and /APLOC is pointed to the ><PVEC descriptor.
.index <ADLN
.index <ADHN
.X <VAL_#
When /APLIF = VAL_#, then the body is released and /ADLN and /ADHN
are set to zero.
.skip 1
It is possible that control may leave a procedure by a ><GO#TO
.index Procedure ^Prologues
rather than an ><EXIT and that the procedure would be subsequently
called.
For this reason, special care must be taken at the time a procedure
is called.
.index String ^Parameters
.index Array ^Parameters
In particular, if any of the string or array parameters hold local
values, these must be released prior to setting ><PVEC to the
new arguments.
.skip 1
When a string or matrix expression is passed as an argument, note that
the body need not be physically copied to a new block.
.X <VAL_#
Such an expression is always an ><RAC entry with ><RACLIF = VAL_#,
.X <PVEC
and can be passed simply by storing ><RACLOC into the PVEC.
.skip 1
For those procedures which have string or array parameters, a location
.index <EXIT point
><PXPT (><EXIT point) is defined.
PXPT heads a sequence of code which releases storage allocated
.index Local ^Parameters
to local parameters.
This code is generated as part of the first ><EXIT compiled for a
.x <EXIT
given procedure, and is used by subsequent EXITs.
.skip 1
.index Procedures, ^String ^Valued
.index String ^Valued ^Procedures
When the string being returned is a user
variable (global or local), the body must be copied.
.skip 1
The above policies governing procedure linkages are implemented
partly in pure generated code and partly by means of runtime
routines called from the code.
.index <RACAMX
.index <RACASA
.index <RACASS
.index <RXPSS
.index <RXPMX
The routines used are RACAMX, RACASA, RACASS, RXPSS and RXPMX.
After the arguments have been passed, the procedure is called by
.skip 1
.indent 5
.INDEX <RXJ
><JSP###RXJ_#,PEPT
.skip 1
For string and array procedures, the JSP is followed by an address of where
we want the return value put.
Hence, the first word of the procedure is
.skip 1
.indent 5
.X <PVEC
><PEPT###MOVEM  RXJ_#,PVEC
.subtitle #####User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)
.page
.index <IO ^Management, ^User
.index User <IO ^Management <(IOCB, <FCB, <FNT, <XINT, <IOCW, ^Channel ^Numbers)
.index <IOCB
.index <FCB
.index <FNT
.index <XINT
.index <IOCW
.index Channel ^Numbers
.skip 1
.center 80
User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)
.skip 1
TBA features a sophisticated IO system:# more than one IO statement can
.index <IO ^Statements, ^Multiply ^Active
be simultaneously active; errors and end of file can be independently
trapped for each file; IO may be performed by user-supplied routines
independently of the TBA IO system; >license can be set and
manipulated within TBA; random access is supported on a
character, word or record basis.
.skip 1
The user may designate (in an ><OPEN or ><ON condition statement)
any (unique per file) integer from 0 to 20 as a file number.
.skip 1
.index <FNT
.index <FCB
.index File ^Control ^Blocks
.index <INPUT
.index <PRINT
The array FNT[0:20], initially all 0, is set to the address of a
dynamically allocated file control block (FCB) when a file number
is first referenced in an OPEN or ON condition statement.
If an INPUT or ><PRINT statement references an FNT entry which is zero,
the condition is diagnosed.
.skip 1
An FCB contains the following kinds of information:
.skip 1
.left margin 20
.indent -5
#1.##whether file is open or closed
.skip 1
.indent -5
#2.##file nomen
.skip 1
.indent -5
#3.##count of elements left in current buffer
.skip 1
.indent -5
#4.##file size
.skip 1
.indent -5
#5.##mode in which file was opened
.skip 1
.indent -5
#6.##current cursor position
.skip 1
.indent -5
#7.##location and number of allocated buffers
.skip 1
.indent -5
#8.##channel number assigned to file
.skip 1
.indent -5
#9.##error number of most recent error condition occurring on
this file
.skip 1
.indent -5
10.##a byte pointer within current buffer to element just processed
.skip 1
.left margin 10
Whenever a file is closed the FCB will be released and the FNT entry
reset to 0.
.skip 1
During the life of the IO statement, the IOCB contains all status
information required for the operation of the element processing
routines (cf. above).
In essence, the element processing routines are designed to be serially
re-entrant with non-temporary local variables indexed off of the
IOCB address.
Some of the information in the IOCB is:
.skip 1
.left margin 20
.indent -5
1#the file number (providing a link to the FCB)
.skip 1
.indent -5
2#the displacement off ><DSAORG of a dynamically allocated block
holding the FORM or IMAGE (if any)
.skip 1
.indent -5
3#the current scan point within the FORM or IMAGE
.skip 1
.left margin 10
Note the possibility that in between successive calls to element
processing routines for a given IO statement, the file involved could
be closed or otherwise seriously affected.
.skip 1
Therefore whenever an element processing routine is called, it first
validates the consistency of the operation being requested with the
current status of the associated FNT and FCB structures.
For efficiency, the significant data (symbolic vs binary, input vs
output, formatted vs free format, etc.) are packed into a
single word in the IOCB and the FCB.
Thus a single logical mask and test can be used to validate the
file/operation consistency.
.skip 1
.test page 5
When a file is opened, the monitor is asked to supply a free
channel number to be used and placed in the FCB.
Thus TBA will avoid using a channel already being used by a
user-supplied routine.
Similarly a user-supplied routine should not
expect pre-assembled channel assignments.
.title #####TYMBASIC GID -- Runside Routines
.no subtitle
.page
.skip 1
.center 80
RUNSIDE ROUTINES
.skip 1
.tp 8
.left margin 15
.indent -10
.index <RSLEN
.INDEX String ^Length
RSLEN##--#LENGTH(string S)
.skip 1
.indent -5
in
.break
r2##--#S
.break
r5##--#string code
.skip 1
.indent -5
out
.break
r1##--#integer LENGTH(S)
.skip 2
.tp 8
.indent -10
.INDEX <RSBLK
.index Blank ^String
RSBLK##--#blank string
.skip 1
.indent -5
input
.break
r1##--#requested length may be zero
.break
r4##--#address of result
.skip 1
.indent -5
do
.break
return a string of (r1) blanks
.skip 2
.tp 11
.indent -10
.index <RSVL1
.index String ^Value
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
RSVL1##--#string value
.skip 1
.indent -5
input
.break
r2##--#string
.break
r5##--#string code
.skip 1
.indent -5
output
.break
r1##--#Real
.skip 1
.indent -5
do
.break
convert the string to a numeric value in free format
.skip 2
.tp 10
.indent -10
.index <RSST1
.index Numeric to ^String ^Conversion
.index Conversion, ^Numeric to ^String
RSST1##--#STR(X)
.skip 1
.indent -5
in
.break
AC#--#X
.break
r5#--#type
.break
r4##--#address of result
.skip 1
.indent -5
output
.break
STR(X)
.skip 2
.indent -10
.index Left ^Substring
.tp 12
.index Substring
.index <RSLFT
RSLFT##--#left substring
.skip 1
.indent -5
input
.break
r1##-#number of characters
.break
r2##--#string
.break
r5##--#string code
.break
r4##--#address of result
.skip 1
.indent -5
do
.break
return the left (r1)characters of the string
.skip 2
.indent -10
.index Right ^Substring
.tp 10
.index Substring
.index <RSRGT
RSRGT##--#right substring
.skip 1
.indent -5
input
.break
r1##--#number of characters
.break
r2##--#string
.break
r4##--#address of result
.break
r5##--#string code
.skip 1
.indent -5
do
.break
return the right (r1)characters of the string
.skip 2
.indent -10
.tp 10
.index Substring
.index <RSBN2
RSBN2##--#SUBSTR(S,N)
.skip 1
.indent -5
input
.break
r1##--#N (integer)
.break
r2##--#S (string)
.break
r4##--#address of result
.break 
r5##--#string code
.skip 1
.indent -5
output
.break
substring
.skip 2
.indent -10
.tp 9
.index <INDEX
RNDX2 -- INDEX (S1,S2)
.skip 1
.indent -5
input
.break
r1 -- s1
.break
r2 -- s2
.break
r5 -- string code
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.indent -10
.index String ^Concatenation
.tp 10
.index Concatenation, ^String
.index <RSCAT
.index <RAC
RSCAT##--#(s1+s2)#--#string concat
.skip 1
.indent -5
input (one argument may be in RAC)
.break
r1##--#s1
.break
r2##--#s2
.break
r4##--#address of result
.break
r5##--#string code
.skip 1
.indent -5
output
.break
s1 +s2
.skip 2
.indent -10
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
.tp 8
.index <ASC
.index <RSAS1
RSAS1##--#ASC(S)
.skip 1
.indent -5
input
.break
r2#--#s
.break
r5##--#string code
.skip 1
.indent -5
output
.break
r1##--#ASC(S,5) integer
.skip 2
.indent -10
.tp 8
.index <CHAR
.index <RCHAR
.index Numeric to ^String ^Conversion
.index Conversion, ^Numeric to ^String
RCHAR##--#CHAR(N)
.skip 1
.indent -5
input
.break
r1##--#integer
.break
r4##--#address of result
.skip 1
.i-5;output
.break
CHAR(N)
.skip 1
.tp 10
.i-10
.x <.CPAD
.x <CPAD
_.CPAD##-- CPAD(S,N)
.skip 1
input
.i+5;r1 -- integer N
.i+5;r2 -- string S
.i+5;r5 -- string code
.i+5;r4 -- address of result
.skip 1
output
.i+6;CPAD(S,N)
.skip 2
.indent -10
.tp 10
.index <LPAD
.index <RSLPD
RSLPD##--#LPAD(S,N)
.skip 1
.indent -5
input
.break
r1#--#integer N
.break
r2##--#string S
.break
r5##--#string code
.break
r4##--#address of result
.skip 1
.indent -5
output
.break
LPAD(S,N)
.skip 2
.indent -10
.tp 10
.index <RPAD
.index <RSRPD
 RSRPD# -- RPAD(s,N)
.skip 1
.indent -5
input
.break
r1 -- int N
.break
r2 -- str S
.break
r5 -- string code
.break
r4##--#address of result
.skip 1
.indent -5
 output
.break
RPAD(S,N)
.skip 2
.indent -10
.index <RPT
.index <RSRPT
RSRPT##--#RPT(S,N)
.skip 1
.indent -5
input
.break
r1 -- integer N
.break
r2 -- string S
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
RPT(S,N)
.skip 2
.indent -10
.tp 9
.INDEX <RJUST
.INDEX <RSRJT
RSRJT##--#RJUST(S)
.skip 1
.indent -5
input
.break
r2 -- str S
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
RJUST(S)
.skip 2
.indent -10
.tp 9
.INDEX <LJUST
.INDEX <RSLJT
RSLJT##--#LJUST(S)
.skip 1
.indent -5
in
.break
r2 -- str S
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
out
.break
LJUST(S)
.skip 2
.indent -10
.INDEX <COUNT
.INDEX <RSCNT
RSCNT##--#COUNT(s1,s2)
.skip 1
.indent -5
in
.break
r1 -- s1 (string)
.break
r2 -- s2 (string)
.break
r5 -- string code
.skip 1
.indent -5
do
.break
calculate COUNT (s1,s2)
.skip 2
.tp 13
.indent -10
.INDEX <RSVL2
.INDEX <VAL
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
RSVL2
.skip 1
.indent -5
input
.break
r1 -- s1
.break
r2 -- s2
.break
r5 -- string code
.skip 1
.indent -5
output
.break
r1 -- real
.skip 1
.indent -5
do
.break
VAL(s1,s2)
.skip 2
.indent -10
.tp 10
.index <STR
.index <RSST2
.index Numeric to ^String ^Conversion
.index Conversion, ^Numeric to ^String
RSST2##--#STR(X,S)
.skip 1
.indent -5
in
.break
r0,r1 -- X
.break
r2 -- S
.break
r3 -- type
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
out
.break
STR(X,S)
.skip 2
.indent -10
.tp 13
.index <SUBSTR
.index <RSBNL
.index Substring
RSBNL##--#substr(s,N1,N2)
.skip 1
.indent -5
input
.break
r1 -- N1 (integer)
.break
r2 -- S(string)
.break
r3 -- N2 (integer)
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
substr (s,N1,N2)
.skip 1
.indent -5
do
.break
perform ><SUBSTR operation
.skip 2
.indent -10
.index <INDEX
.tp 11
.index <RNDX3
RNDX3##--#INDEX(s1,s2,N)
.skip 1
.i-10
input
.break
r1 -- s1
.break
r2 -- s2
.break
r3 -- N
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.indent -10
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
.tp 9
.index <ASC
.index <RSASC
RSASC##--#ASC(S,N)
.skip 1
.indent -5
in
.break
r1 -- N
.break
r2 -- S
.break
r5 -- string code
.skip 1
.indent -5
out
.break
r1 -- ASC(S,N), integer
.skip 2
.indent -10
.tp 8
.INDEX <TAB
.INDEX <RTAB1
 RTAB1 -- TAB(1 arg)
.skip 1
.indent -5
input
.break
r1 -- integer
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string of spaces
.skip 2
.indent -10
.tp 7
.INDEX <LOC
.INDEX <RLOC
 RLOC -- LOC
.skip 1
.indent -5
input
.break
r1 -- integer
.skip 1
.indent -5
output
.breAk
r1 -- integer
.skip 2
.indent -10
.tp 7
.INDEX <SIZE
.INDEX <RSIZ
 RSIZ -- SIZE
.skip 1
.indent -5
input
.break
r1 -- integer
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.tp 8
.indent -10
.INDEX <ERRMSG
.INDEX <RRMSG
 RRMSG -- ERRMSG
.skip 1
.indent -5
input
.break
r1 -- integer
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string
.skip 2
.indent -10
.tp 8
.INDEX <TAB
.INDEX <RTAB2
 RTAB2 -- TAB(2 args)
.skip 1
.indent -5
input
.break
r1,r3 -- integers
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string
.skip 2
.indent -10
.tp 7
.INDEX <POS
.INDEX <RPOS
RPOS##--#POS(1arg)
.skip 1
.indent -5
input
.break
r1 -- integer
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.indent -10
.tp 9
.INDEX <RND
.x <.RNDA
.index Random ^Number ^Generation
_.RNDA##--#RND(X)
.skip 1
.indent -5
input
.break
.indent 5
_>0 =_> initial value
.break
r1:##=0 =_> RND()
.break
.indent 5
_<0 =_> use clock to obtain initial value
.skip 1
.indent -5
output
.break
r1 -- RND(X)
.skip 2
.indent -10
.tp 13
.index <COMP
.index <RSCMP
RSCMP##--#COMP(s1,s2)
.skip 1
.indent -5
input
.break
r1 -- s1
.break
r2 -- s2
.break
r5 -- string code
.skip 1
.indent -5
output
.break
r1 -- COMP(s1,s2) = (-1,0,1)
.skip 1
.indent -5
do
.break
return logical value in r1, corresponding to sign of source 1 - source 2
.skip 2
.indent -10
.tp 10
.INDEX <MAX
.INDEX <RSMAX
RSMAX##--#max(s1,s2)
.skip 1
.indent -5
input
.break
r1 -- s1 (string)
.break
r2 -- s2 (string)
.break
r4 -- address of result
.break
r5 -- string code
.skip 1
.indent -5
output
.break
max(s1,s2)
.skip 2
.indent -10
.tp 10
.INDEX <MIN
.INDEX <RSMIN
RSMIN##--#min(s1,s2)
.skip 1
.indent -5
input
.break
r1 -- s1 (string)
.break
r2 -- s2 (string)
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
min(s1,s2)
.skip 2
.tp 9
.i-10
.x <RSTRLE
RSTRLE##--#String comparison  less than or equal
.skip
input
.i+5;r1 -- string 1
.i+5;r2 -- string 2
.i+5;r5 -- string code
.skip 1
output
.i+5;r1 -- result, logical valued
.skip 2
.tp 9
.i-10
.x <RSTRGE
RSTRGE##--#String comparison  greater than or equal
.skip
input
.i+5;r1 -- string 1
.i+5;r2 -- string 2
.i+5;r5 -- string code
.skip 1
output
.skip 2
.tp 9
.i+5;r1 -- result, logical valued
.skip 2
.tp 9
.i-10
.x <RSTRG
RSTRG###--#String comparison  greater than
.skip
input
.i+5;r1 -- string 1
.i+5;r2 -- string 2
.i+5;r5 -- string code
.skip 1
output
.i+5;r1 -- result, logical valued
.skip 2
.tp 9
.i-10
.x <RSTRL
RSTRL###--#String comparison  less than
.skip
input
.i+5;r1 -- string 1
.i+5;r2 -- string 2
.i+5;r5 -- string code
.skip 1
output
.i+5;r1 -- result, logical valued
.skip 2
.tp 9
.i-10
.x <RSTRE
RSTRE###--#String comparison  equal to
.skip
input
.i+5;r1 -- string 1
.i+5;r2 -- string 2
.i+5;r5 -- string code
.skip 1
output
.i+5;r1 -- result, logical valued
.skip 2
.tp 9
.i-10
.x <RSTRNE
RSTRNE##--#String comparison  not equal to
.skip
input
.i+5;r1 -- string 1
.i+5;r2 -- string 2
.i+5;r5 -- string code
.skip 1
output
.i+5;r1 -- result, logical valued
.skip 2
.tp 8
.indent -10
.INDEX <.CDIV
.index Complex ^Division
.index Division, ^Complex
_.CDIV##--#complex division
.skip 1
.indent -5
input
.break
r1,r2 -- operand 1
.break
r3,r4 -- operand 2
.skip 1
.indent -5
output
.break
r1,r2 -- quotient
.skip 2
.indent -10
.index Complex ^Multiplication
.tp 8
.index Multiplication, ^Complex
.index <.CMUL
_.CMUL##--#complex multiplication
.skip 1
.indent -5
input
.break
r1,r2 -- operand 1
.break
r3,r4 -- operand 2
.skip 1
.indent -5
output
.break
r1,r2 -- product
.skip 2
.indent -10
.INDEX <RPHZ
.tp 8
.INDEX <PHASE
.x <.POLR
_.POLR# -- POLAR(radius,theta)
.skip 1
.indent -5
input
.break
r1,r2 -- radius(double)
.break
r3,r4 -- theta(double)
.skip 1
.indent -5
output
.break
r1,r2 -- POLAR(radius,theta)(complex)
.skip 2
.tp 14
.indent -10
.INDEX <RSROP
.index _>_>
.index _<_<
.index =_#
.index Relational ^Routine for ^Special ^Operators
RSROP##--#special relational operator
.skip 1
.indent -5
input
.break
r5 -- LH:##type of operands
.break
######RH:##operator:##_<_< is 17, _>_> is 16, =_# is 18
.break
AC -- value1
.break
AC2 -- value2
.skip 1
.indent -5
output
.break
r1 -- logical result
.skip 1
.indent -5
do
.break
evaluate (value1) operator (value2) and leave 0 or 1 in r1
.skip 2
.indent -10
.tp 7
.index <DATE
.index <RXDAT
RXDAT##--#(DATE)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output type
.break
string
.skip 2
.indent -10
.tp 7
.INDEX <TIME
.INDEX <RXTIM
RXTIM##--#(TIME)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output type
.break
string
.skip 2
.indent -10
.tp 7
.INDEX <TERM
.INDEX <RXTRM
.index Terminal ^Input
RXTRM##--#(TERM)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
logical
.skip 2
.indent -10
.tp 7
.index <IXASC
.index <RIASC
RIASC##--#(IXASC)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
integer array, 1 dim
.skip 2
.indent -10
.tp 7
.index <IXCHAR
.index <RICHR
RICHR##--#(IXCHAR)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string array, 1 dim
.skip 2
.indent -10
.tp 7
.index <XASC
.index <RXASC
RXASC##--#(XASC)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
integer array, 1 dim
.skip 2
.indent -10
.tp 7
.index <XCHAR
.index <RXCHR
RXCHR##--#(XCHAR)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string array, 1 dim
.skip 2
.indent -10
.tp 7
.index <TCP
.index <RTCP
RTCP##--#(TCP)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
logical
.skip 2
.indent -10
.tp 7
.index <DET
.index <RDET
RDET##-- (DET)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
double
.skip 2
.indent -10
.tp 7
.index <YEAR
.index <RXYR
RXYR##--#(YEAR)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output type
.break
string
.skip 2
.tp 7
.indent -10
.index <ERRCD
.index <RRCD
RRCD##--#(ERRCD)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.tp 7
.indent -10
.index <ERRLN
.index <RRLN
RRLN##--#(ERRLN)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.tp 7
.indent -10
.index <ERRFL
.index <RRFL
RRFL##-- (ERRFL)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.indent -10
.tp 7
.index <TRU
.index <RTRU
RTRU##--#(TRU)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
real
.skip 2
.indent -10
.tp 7
.index <POS
.index <RPOST
RPOST##--#(POS with no arguments)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.indent -10
.tp 13
.index <INV
.index <RMINV
.index Array ^Inversion
.index Matrix ^Inversion
.index Inversion, ^Matrix
RMINV##--#invert matrix
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r3 -- array
.break
r4 -- address of result
.skip 1
.indent -5
do
.break
invert a real or double 2-dim matrix
.skip 1
.indent -5
error
.break
matrix not square
.break
matrix singular
.skip 2
.indent -10
.tp 9
.x <TRN
.x <RMTRN
RMTRN##--#transpose
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r3 -- array
.break
r4 -- address of result
.skip 1
.indent -5
do
.break
transpose 2-dim non-string matrix, same type
.skip 2
.tp 7
.indent -10
.X <RMPWR
.X Array ^Exponentiation
RMPWR##--#matrix exponentiation
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r1 -- integer
.break
r2 -- array
.break
r3 -- address of result
.skip 2
.tp 9
.indent -10
.X <RSACT
RSACT##--#string scalar + string array
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2 -- string
.break
r3 -- array
.break
r4 -- address of result
.break
r5 -- string code or string code +4 if scalar precedes array
.skip 2
.indent -10
.X Scalar ^Multiplication of ^Array
.tp 16
.x Array, ^Scalar ^Multiplication
.x <RMSOP
RMSOP##--#Array-Scalar operations
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r1(,r2) -- scalar
.break
r3 -- address of input array descriptor
.break
r4 -- address of result array descriptor
.break
r5 -- operation number
.break
######22 + ##23 - ##24 DIV ##26 / ##27 * ##28 MOD
.i+6;add 9 to operation number if scalar is on left
.i+6;and not commutative
.break
r6 -- type of array (we will convert array to this type if necessary)
.skip 1
.i-5;do
.break
result array = input array op scalar
.skip 2
.indent -10
.tp 10
.X Array ^Operations, ^Element by ^Element
.x <REEOPS
REEOPS##--#element-by-element array operation
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r1 -- OPID=22, 23, 24, 26, 27, or 28
.break
If OPID = 24, the compiler checks to make sure both arrays have integer
type.
.break
r2 -- first array
.break
r3 -- second array
.break
r4 -- address of result
.skip 2
.tp 7
.indent -10
.X <RAINT
.X Array ^Intersections
.x @ (^Array ^Intersections)
><RAINT##--#array intersection
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2,r3 -- the arrays
.break
the compiler does no checking.
.break
r4 -- address of result
.skip 2
.indent -10
.tp 6
.x Array ^Multiplication
.x <RAMUL
RAMUL##--#matrix multiplication
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2,r3 -- arrays
.break
r4 -- address of result
.skip 2
.indent -10
.tp 8
.x Array ^Exponentiation, ^Element by ^Element
.x <REPWR
REPWR##--#element-by-element exponentiation
.skip 1
.indent -5
input
.break
r0 -- array code
.break 
r1(,r2) -- scalar
.break
r3 -- array
.break
r4 -- address of result
.break
r5 -- type of scalar, or type + 10 if scalar on left
.skip 2
.tp 6
.indent -10
.X <RNEGA
.x Array ^Negation
.x Negation, ^Array
RNEGA##--#negate a matrix
.skip 1
.indent -5
input
.break
r3 -- matrix to be negated
.break
r0 -- array code
.break
r4 -- address of result
.skip 2
.indent -10
.tp 7
.x Move ^Array
.X <RACMMX
RACMMX##--#move matrix
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2 -- source
.break
r3 -- dest (must be NAM_)
.break
Physically move body
.skip 2
.tp 10
.indent -10
.X <RACXMX
.X Exchange ^Array
.x Array ^Exchange
RACXMX##--#exchange matrices
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2,r3 -- the arrays
.break
exchange values of source 1, source 2
.skip 2
.indent -5
note:
.break
bodies need not be moved; RACLIF = NAM_# !
.skip 2
.indent -10
.x String ^Exchange
.tp 9
.x Exchange ^String
.X <RACXS
RACXS##--#exchange scalar string or string array element
.skip 1
.indent -5
input
.break
r1 -- source 1 (must be NAM_#)
.break
r2 -- source 2 (must be NAM_#)
.break
r5 -- string code
.skip 1
.indent -5
do
.break
exchange values of source 1, source 2
.skip 2
.indent -10
.tp 4
.X <IDN
.X <RAIDN
RAIDN##--#IDN without arguments
.skip 1
.indent -5
input
.break
r3 -- address of destination (must be user variable)
.skip 2
.tp 6
.indent -10
.X <RACMS
.x Move ^String
.x String ^Move
RACMS##--#move scalar string or string array element
.skip 1
.indent -5
input
.break
r1 -- source
.break
r2 -- dest (must be NAM_#)
.break
r5 -- string code
.skip 2
.indent -10
.tp 10
.x Exponentiation
.X <RPWR
RPWR##--#evaluate X**Y
.skip 1
.indent -5
input
.break
r5:##LH -- type of X
.break
#####RH -- type of Y ##(RH_<=LH)
.break
r1 -- X
.break
r3 -- Y
.skip 1
.indent -5
output
.break
AC -- X**Y
.skip 2
.tp 8
.i-10
.x <.RIPWR
_.RIPWR##--#real to an integer power
.skip 1
input
.i+5;r1 -- base (real)
.i+5;r3 -- power (integer)
.skip 1
output
.i+5;r1 -- base**power (real)
.skip 2
.tp 8
.i-10
.x <.RRPWR
_.RRPWR##==#real to a real power
.skip 1
input
.i+5;r1 -- base (real)
.i+5;r3 -- power (real)
.skip 1
output
.i+5;r1 -- base**power (real)
.skip 2
.tp 8
.i-10
.x <.DIPWR
_.DIPWR##--#double to an integer power
.skip 1
input
.i+5;r1,r2 -- base (double)
.i+5;r3 -- power (integer)
.skip 1
output
.i+5;r1,r2 -- base**power (double)
.skip 2
.tp 8
.i-10
.x <.DDPWR
_.DDPWR##--#double to a double power
.skip 1
input
.i+5;r1,r2 -- base (double)
.i+5;r3,r4 -- power (double)
.skip 1
output

.i+5;r1,r2 -- base**power (double)
.skip 2
.skip 2
.tp 8
.i-10
.x <.CIPWR
_.CIPWR##--#complex to an integer power
.skip 1
input
.i+5;r1,r2 -- base (complex)
.i+5;r3####-- power (integer)
.skip 1
output
.i+5;r1,r2 -- base**power (complex)
.skip 2
.tp 8
.i-10
.x <.CCPWR
_.CCPWR##--#complex to a complex power
.skip 1
input
.i+5;r1,r2 -- base (complex)
.i+5;r3,r4 -- power (complex)
.skip 1
.i+5;r1,r2 -- base**power (complex)
.skip 2
.tp 10
.indent -10
.X <RXAMX
.x Procedure ^Prologues, ^Array ^Parameter
.x Parameter, ^Array to ^Procedure
.x Array ^Parameter, to ^Procedure
RXAMX##--#matrix procedure argument
.skip 1
.indent -5
input
.break
r0 -- array code for argument
.break
r2 -- address of pointer to parameter descriptor
.break
r3 -- argument
.skip 1
.indent -5
do
.break
de-allocate any old param value; pt param to arg;
.break 
fail to move body
.skip 2
.indent -10
.x String ^Parameter, to ^Procedure
.x Parameter, ^String to ^Procedure
.tp 9
.x Procedure ^Prologues
.X <RXAS
RXAS # -- scalar string or string array element procedure
and argument
.skip 1
.indent -5
input
.break
r1 -- param
.break
r2 -- arg
.break
r5 -- string code
.skip 1
.indent -5
do
.break
de-allocate any old param value; set param to refer to argument
.skip 2
.tp 10
.indent -10
.X <RXPMX
.x Procedure ^Prologues
.x Array ^Parameter ^Deallocation
.x Deallocation of ^Array ^Parameter
RXPMX# -- de-allocate matrix param
.skip 1
.indent -5
input
.break
r2 -- addr of pointer to param
.skip 1
.indent -5
do
.break
de-allocate body (if any);
.break
set /APLOC to local vector;
.break
set /ADLN = /ADHN = 0
.break
Note: This routine may not change r0 or r1.
.skip 2
.indent -10
.test page 8
.x Procedure ^Prologues
.x String ^Parameter ^Deallocation
.tp 10
.x Deallocation of ^String ^Parameter
.X <RXPSS
RXPSS# -- de-allocate string param
.skip 1
.indent -5
input
.break
r2 -- addr of param
.skip 1
.indent -5
do
.break
de-allocate body (if any);
.break
set /SDADR = 0
.skip 1
.indent -5
Note: This routine may not change r0 or r1.
.skip 2
.indent -10
.tp 10
.x Return ^String
.X <RXRS
RXRS -- return string
.skip 1
.indent -5
input
.break
r2 -- addr of string
.break
r3 -- ><PVEC addr of descriptor
.break
r5 -- string code
.skip 1
.indent -5
do
.break
return string. If string is a user variable (global or local), copy body
.X <PVEC
Put descriptor in PVEC.
.skip 2
.tp 5
.indent -10
.X <RSIG
.x Significance, ^Output
.x Set ^Output ^Significance
RSIG#--#set output significance
.skip 1
.indent -5
input
.break
r1 -- number of significant digits (integer)
.break
error: r1_<1 or r1_>17.
.skip 1
.indent -10
.x Set ^Boundary
.tp 8
.x Boundary, ^Set
.X <RBND
RBND## -- set boundary
.skip 1
.indent -5
input
.break
r1 -- boundary value (real)
.skip 1
.indent -5
do
.break
set boundary
.break
error: r1_<0
.skip 2
.tp 1
.indent -10
.X <RCIB
.x Clear ^Terminal ^Input ^Buffer
.x <CIB
.x Terminal ^Input ^Buffer
RCIB -- Clear terminal input buffer
.skip 2
.tp 5
.indent -10
.X <RCLOS
.x File ^Closing
.x Close ^File
RCLOS -- close a file
.skip 1
.indent -5
r1 -- file number
.skip 1
.indent -5
error -- file not open
.skip 2
.indent -10
.X <RCOB
.X <COB
.X Clear ^Output ^Buffer
.x Terminal ^Output ^Buffer
RCOB -- Clear terminal output buffer
.skip 2
.indent -10
.tp 7
.skip 2
.X <RCOPY
.X <COPY
.x File ^Copy
RCOPY -- Copy file S1 onto S2.
.skip 1
.indent -5
r1 -- s1
.skip 1
.indent -5
r2 -- s2
.skip 1
.indent -5
r5 -- string code
.skip 2
.indent -10
.tp 7
.X <ERASE
.X <RERAS
RERAS -- erase specified records on specified file
.skip 1
.indent -5
r3 -- final record number
.skip 1
.indent -5
r1 -- beginning record number
.skip 1
.indent -5
r4 -- file number
.skip 2
.tp 7
.indent -10
.X <RFOLD
.X <LOL
.x Terminal ^Carriage ^Width
.x Width , ^Terminal
RFOLD# -- set terminal width
.skip 1
.indent -5
input
.break
r1 -- terminal width
.skip 1
.indent -5
do
.break
set terminal width to the number in r1
.skip 2
.indent -10
.X <RINPF
.x File ^Setup for ^Formatted ^Input
.tp 12
.x Formatted ^Input
RIOF# -- Set up the file and format for INPUT or PRINT.
FORM used.
.skip 1
.indent -5
r1 -- record (if any)
.skip 1
.indent -5
r3 -- file number (if any)
.skip 1
.indent -5
r2 -- FORM string
.skip 1
.indent -5
r5 -- string code
.skip 1
.indent -5
FW1 -- ><INPFF or ><PRTFF+16
.skip 2
.tp 6
.indent -10
.X <RINPT
.x Input of ^Variable
RINPT# -- INPUT a variable
.skip 1
.indent -5
input
.break
r1# -- R%VRLC address of the variable
.break
HW1 -- variable class (ONSC_#, OSSC_#, etc.)
.break
HW2 -- variable type
.skip 2
.indent -10
.test page 8
.X <RKLFMT
.x Format, ^Discard
RKLFMT -- Discard current IO format
.skip 2
.tp 9
.indent -10
.X <RLOCAT
.x <LOCATE ^Record
RLOCAT -- locate specified record on the specified file
.skip 1
.indent -5
r3 -- file number (-1 = command file)
.skip 1
.indent -5
r1 -- record number
.skip 1
.indent -5
error
.break
1. file not open
.break
2. file not random
.skip 2
.tp 9
.indent -10
.X <ROPEN
.X <OPEN
.x File ^Open
ROPEN -- execute OPEN statement
.skip 1
.indent -5
r4 -- line number for error trap (if any)
.indent -5
r3 -- file number (if any)
.indent -5
r0 -- record length (if any)
.indent -5
r2 -- file
.indent -5
r5 -- string code
.indent -5
FW1 -- Access mode
.indent -5
r1 -- protection code (if any)
.skip 2
.indent -10
.X <RPRTF
.x File ^Setup for ^Formatted ^Print
.tp 5
.X <PRINT
RIOI# -- Set up the file and format for PRINT or INPUT.
FORM not used.
.skip 1
.indent -5
input -- same as for RIOF, except that r2 contains IMAGE string,
if any, and r5 contains string code, if any.
.skip 2
.tp 7
.indent -10
.X <RPRTS
.x Print ^Spacing
RPRTS# -- print spacing (ignored if formatted)
.skip 1
.indent -5
input
.break
r3 -- spacing code 0-3 (see pmc Formats, OPTYPE = 41)
.skip 1
.indent -5
do
.break
print spacing for unformatted symbolic output
.skip 2
.indent -10
.tp 15
.X <RPRTV
.x Print ^Value
RPRTV# -- print value
.skip 1
.indent -5
input
.break
HW1 -- class and type
.break
HW2 -- spacing code
.skip 1
.indent -5
value is passed in:
.break
AC -- if numeric scalar
.break
r2 -- if string with string code in r5
.break
r3 -- matrix
.skip 1
.indent -5
do
.break
print value as specified to file, terminal,  or ENCODE array.
ignore spacing if file is binary or if destination is ENCODE array
.skip 2
.tp 6
.indent -10
.x <RREAD
.x Read a ^Variable
RREAD -- READ a variable
.skip 1
.indent -5
input
.break
r1# -- R%VRLC address of the variable
.break
HW1 -- variable class (ONSC_#, OSSC_#, etc.)
.break
HW2 -- variable type
.skip 2
.tp 4
.indent -10
.X <RRMOV
.X <REMOVE
RRMOV -- Remove specified file
.skip 1
.indent -5
r2 -- S1
.indent -5
r5 -- string code
.skip 2
.tp 7
.indent -10
.X <RRNAM
.X <RENAME
RRNAM -- rename file S1 as S2.
.skip 1
.indent -5
r1 -- s1
.skip 1
.indent -5
r2 -- s2
.skip 1
.indent -5
r5 -- string code
.skip 2
.tp 7
.indent -10
.X <RRSTR
.x <DATA ^Block ^Index, ^Reset
><RRSTR -- restore data block
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
do
.break
reset the data block index to zero
.skip 2
.indent -10
.X <R8IN
.X <EIGHTI
R8IN -- EIGHTI
.skip 1
.indent -5
r1 -- R%VRLC location of variable
.skip 2
.indent -10
.X <R8OUT
.X <EIGHTO
R8OUT -- EIGHTO
.skip 1
.indent -5
r1 -- integer value
.SKIP 2
.INDENT -10
.index Direct ^Statements
.indent -10
.X <RDXMX
.X <DIM
.X Array ^Declaration
.x Declaration of ^Array
RDXMX -- declare or redeclare array (matrix)
.skip 1
.indent -5
input
.break
r1 -- addr of descriptor
.break
r2 -- declared length (if string)
.indent -5
.skip 1
Dimensions bounds must already be in the descriptor. See ARRAYS.
.skip 1
.indent -5
do
.break
allocate storage for the array; set body to zero; fill in descriptor;
set header words (of string elements)
.skip 2
.indent -10
.X <RDXSS
.x String ^Declaration
.x Declaration of ^String
RDXSS# -- declare scalar string
.skip 1
.indent -5
input
.break
r1 -- addr of descriptor
.break
r3 -- declared length
.skip 1
.indent -5
do
.break
allocate body; set it to zero; set descriptor to zero current length
.break
Note: string may already have been declared, possibly with different
declared length.
.skip 2
.INDENT -10
.X <RGOSUB
.X <GOSUB
RGOSUB -- ><GOSUB call
.skip 1
.indent -5
input
.break
r2 -- line location.
.skip 2
.indent -10
.X <RGRET
.X <RETURN
.X <GOSUB <RETURN
RGRET##-- Return from ><GOSUB call
.skip 2
.indent -10
.X <RHED
.X <DEBUG
.X <BREAK
.X <TRACE
><RHED -- Used to support BREAK and TRACE
.skip 2
.indent -10
.test page 17
.X <RINTP
.x Interrupts
RINTP# -- interrupt program
.skip 1
.indent -5
input
.break
##H -- 0 = ><STOP
.break
#######2 = ><END
.break
#######4 = ><PAUSE
.break
#######6 = ><QUIT
.break
#######8 = ><LOGOUT
.skip 1
(Add 1 to above values if expression has already been printed.)
.skip 1
.indent -5
do
.break
perform indicated interrupt (see TBA spec, pp 39, 73-74); printout for
><LOG like that for others plus logout info
.skip 2
.indent -10
.X <RNOCN
.X <NO ^Condition ^Statement
RNOCN -- set condition OFF
.skip 1
.indent -5
input
.break
r3 -- if FILE or ENDFILE,filenumber
.break
r5 -- kind of condition
.indent 5
EOF_#==0
.indent 5
ESC_#==1
.indent 5
MTH_#==2
.indent 5
TRN_#==3
.indent 5
FIL_#==4
.indent 5
DAT_#==5
.indent 5
ERR_#==6
.skip 2
.i-10
.x <.SSIN
_.SSIN##-- Single Precision Sine
.skip 1
input
.i+5;r1 -- operand
.skip 1
output
.i+5;r1 -- SIN(operand)
.skip 2
.i-10
.x <.DSIN
_.DSIN##-- Double Precision Sine
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- SIN(opernad)
.skip 2
.i-10
.x <.SCOS
_.SCOS##-- Single Precision Cosine
.skip 1
input
.i+5;r1 -- operand
.skip 1
output
.i+5;r1 -- COS(operand)
.x <SIN
.x <COS
.skip 2
.i-10
.x <.CCOS
_.CCOS##-- Complex Cosine
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- COS(operand)
.x <COS
.skip 2
.i-10
.x <.CSIN
_.CSIN##-- Complex Sine
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- SIN(operand)
.x <SIN
.skip 2
.i-10
.x <.STAN
_.STAN##-- Single Precision Tangent
.skip 1
input
.i+5;r1 -- operand
.skip 1
output
.i+5;r1 -- TAN(operand)
.x <TAN
.skip 2
.i-10
.x <.DTAN
_.DTAN##-- Double Precision Tangent
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- TAN(operand)
.x <TAN
.skip 2
.i-10
.x <.CTAN
_.CTAN##-- Complex Tangent
.skip 1
input
.i+5;r1,r1 -- opernad
.skip 1
output
.i+5;r1,r2 -- TAN(operand)
.x <TAN
.skip 2
.i-10
.x <.CABS
_.CABS##-- Complex Absolute Value
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1 -- /A+Bi/ = SQRT(A^2 + B^2)
.x <ABS
.skip 2
.i-10
.x <.SQRT
_.SQRT##-- Square Root
.skip 1
input
.i+5;r1,(r2) -- operand
.i+5;r3######-- type of operand
.skip 1
output
.i+5;r1,(r2) -- SQRT(operand)
.x <SQRT
.skip 2
.i-10
.x <.CSQRT
_.CSQRT##-- Complex Square Root
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- SQRT(operand)
.x <SQRT
.skip 2
.indent -10
.X <.ASIN
.X <ASIN
_.ASIN##--#Arcsine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- ASIN(operand)
.skip 2
.indent -10
.x <.ACOS
.X <ACOS
_.ACOS##--#Arccosine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- ACOS(operand)
.skip 2
.indent -10
.X <.ATAN
.X <ATAN
_.ATAN##--#Arctangent (single argument)
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- ATAN(operand)
.skip 2
.indent -10
.X <.SINH
.X <SINH
_.SINH##--#Hyperbolic Sine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- SINH(operand)
.skip 2
.indent -10
.X <.COSH
.X <COSH
_.COSH##--#Hyperbolic Cosine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- COSH(operand)
.skip 2
.indent -10
.X <.TANH
.X <TANH
_.TANH##--#Hyperbolic Tangent
.skip 1
.indent -5
input
.break
r1,r2 -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- TANH(operand)
.skip 2
.indent -10
.X <RONCN
.X <ON ^Condition
RONCN##--#set condition ON
.skip 1
.indent -5
input
.break
r1 -- branch address
.break
r3 -- if FILE or ENDFILE, filenumber
.break
r5 -- kind of condition
.indent 5
ESC_#==0
.indent 5
ERR_#==1
.indent 5
MTH_#==2
.indent 5
TRN_#==3
.indent 5
DAT_#==4
.indent 5
EOF_#==5
.indent 5
FIL_#==6
.skip 2
.indent -10
.X <.ATAN2
.X <ATAN
_.ATAN2##--#Arctangent (double argument)
.skip 1
.indent -5
input
.break
r1,(r2) -- operand 1
.break
r3,(r4) -- operand 2
.break
r5 -- operand type (both operands have same type)
.skip 1
.indent -5
output
.break
r1,r2 -- ATAN(operand 1)/(operand 2)
.skip 2
.i-10
.x <.SEXP
_.SEXP##-- Single Precision Exponentiation
.skip 1
input
.i+5;r1 -- opernad
.skip 1
output
.i+5;r1 -- EXP(operand)
.x <EXP
.skip 2
.i-10
.x <.DEXP
_.DEXP##-- Double Precision Exponentiation
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- EXP(operand)
.x <EXP
.skip 2
.i-10
.x <.CEXP
_.CEXP##-- Complex Exponentiation
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- EXP(operand)
.x <EXP
.skip 2
.i-10
.x <.SLOG
_.SLOG##-- Single Precision Natural Log (Base e)
.skip 1
input
.i+5;r1 -- operand
.skip 1
output
.i+5;r1 -- LOG(operand)
.x <LOG
.skip 2
.i-10
.x <.DLOG
_.DLOG##-- Double Precision Natural Log (Base e)
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- LOG(operand)
.x <LOG
.skip 2
.i-10
.x <.CLOG
_.CLOG##-- Complex Natural Log (Base e)
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- LOG(operand)
.x <LOG
.skip 2
.i-10
.x <.SLGT
_.SLGT##-- Single Precision Common Log (Base 10)
.skip 1
input
.i+5;r1 -- operand
.skip 1
output
.i+5;r1 -- LOG10(operand)
.x <LGT
.x <LOG10
.skip 2
.i-10
.x <.DLGT
_.DLGT##-- Double Precision Common Log (Base 10)
.skip 1
input
.i+5;r1,r2 -- operand
.skip 1
output
.i+5;r1,r2 -- LOG10(operand)
.x <LGT
.x <LOG10
.skip 2
.i-10
.x <.CLGT
_.CLGT##-- Complex Common Log (Base 10)
.skip 1
input
.i+5;r1,r2 -- opernad
.skip 1
output
.i+5;r1,r2 -- LOG10(operand)
.x <LGT
.x <LOG10
.skip 2
.indent -10
.X <RRSUM
.X <RESUME
RRSUM##--#executes RESUME statement
.skip 2
.i-10
.x <.SFIX
_.SFIX##--#single precision FIX
.x <FIX
.skip 1
input
.i+5;r1 -- arg (real)
.skip 1
output
.i+5;r1 -- FIX(arg) (real)
.skip 2
.i-10
.x <.DFIX
_.DFIX##--#double FIX
.skip 1
input
.i+5;r1,r2 -- arg (double)
.skip 1
output
.i+5;r1,r2 -- FIX(arg) (double)
.skip 2
.i-10
.x <.SROUN
_.SROUN##--#single ROUND
.skip 1
input
.i+5;r1 -- arg (real)
.skip 1
output
.i+5;r1 -- ROUND(arg)
.x <ROUND
.skip 2
.i-10
.x <.SIP
_.SIP##--#single precision IP (integer part)
.x <IP
.skip 1
input
.i+5;r1 -- arg (real)
.skip 1
output
.i+5;r1 -- IP(arg) (real)
.skip 2
.i-10
.x <.SFP
_.SFP##--#single precision FP (floating part)
.skip 1
input
.i+5;r1 -- arg (real)
.skip 1
output
.i+5;r1 -- FP(arg)  (real)
.skip 2
.i-10
.x <.DROUN
_.DROUN##--#double ROUND
.skip 1
input
.i+5;r1,r2 -- arg (double)
.skip 1
output
.i+5;r1,r2 -- ROUND(arg) (double)
.x <ROUND
.skip 2
.i-10
.x <.DIP
_.DIP##--#double IP
.skip 1
input
.i+5;r1,r2 -- arg (double)
.skip 1
output
.i+5;r1,r2 -- IP(arg) (double)
.x <IP
.skip 2
.i-10
.x <.DFP
.x <DFP
_.DFP##--#double FP
.skip 1
input
.i+5;r1,r2 -- arg (double)
.skip 1
output
.i+5;r1,r2 -- FP(arg) (double)
.skip 2
.i-10
.x <.SINT
.x <INT
_.SINT##--#single precision INT
.skip 1
input
.i+5;r1 -- arg (real)
.skip 1
output
.i+5;r1 -- INT(arg) (integer)
.skip 2
.i-10
.x <.DINT
.x <INT
_.DINT##--#double INT
.skip 1
input
.i+5;r1,r2 -- arg (double)
.skip 1
output
.i+5;r1 -- INT(arg) (integer)
.skip 2
.indent -10
.X <RWAIT
.X <WAIT
RWAIT##--#wait
.skip 1
.indent -5
input
.break
r1 -- WAIN
.skip 1
.indent -5
do
.break
wait WAIN seconds
.skip 2
.indent -10
.X <RGSLC
.X Array ^Slicing
RGSLC##--#Create array slice
.skip 1
.indent -5
input
.break
r3#--#descriptor address of N-dimensional parent array
.break
PR[0:N-1]#--#dimension specifications for dimensions
.break
0 through N-1 of the parent array (N greater than 2)
.skip 1
.break
r1#--#dimension specification for dimension 0 (N=1 or 2)
.skip 1
r2#--#dimension specification for dimension 1 (N=2)
.skip 1
FW1#--#dimension map
.skip 1
.indent -5
output
.break
array slice
.skip 1
.indent 10
Note:  if only one subscript is specified for a given dimension,
the dimension specification will simply be that subscript.  
If two subscripts are specified, the lower (upper) bound will be in 
the left (right) halfword of the dimension specification.  
The bit in the 2**J place of the dimension map will be 0 if only 
one subscript is specified for dimension J, and 1 if 2 subscripts 
are specified.
.left margin 5
.subtitle #####Bibliography
.page
.skip 1
.center 80
BIBLIOGRAPHY
.skip 2
EXTERNAL SPECIFICATION
.skip 1
*##Tymbasic language external reference specification
(updated January 1975 and May 1975)
.skip 1
*##Tymshare Super Basic reference manual
.skip 1
*##Differences between Super Basic and Tymbasic
.skip 4
INTERNAL DESIGN
.skip 1
*##Tymbasic general internal design
.skip 1
*##Tymbasic task descriptions (maintained in the file (TBA4:17)PEBBLE)
.skip 1
*##Tymbasic project schedule (maintained in the file (TBA4:17)CHART)
.skip 1
*##Programming standards and procedures--Tymbasic project
.skip 1
*##A few words about paging
.skip 1
*##Memo on test programs
.skip 4
INTERFACES
.skip 1
*##Tymcom X monitor version PO.2 information
.skip 1
*##Quick reference for Tymcom X monitor calls
.skip 1
*##Reference manual for KI10 software interrupt system on the Tymcom X
.skip 1
*##Terminal interface standards for Tymbasic
.skip 1
*##Specification for intraline editing for Tymbasic
.skip 1
*##Specification for file name syntax and semantics for Tymbasic
.skip 1
*##Files (symbolic file format)
.skip 1
*##The care and feeding of CREF
.skip 4
MANUALS
.skip 1
*##DEC system 10 assembly language handbook
.skip 1
*##DEC system 10 system reference manual
.skip 1
*##Tymshare Editor -- instant series
.skip 1
*##Tymshare Editor -- reference series
.skip 1
*##Addendum to editor -- January 1972
.skip 1
*##Tymshare Executive -- reference series
.skip 1
*##Tymshare XEXEC manual 
.skip 1
*##FET -- a file editing tool
.skip 1
*##Tymcom X user program index
.skip 1
*##Tymex
.skip 1
*##Tymcom X file creation and modification
.skip 1
*##Runoff
.skip 1
*##The beginner's guide
.title #####TYMBASIC GID
.subtitle #####INDEX
.page
.left margin 10
.print index
 ^7b&