








                                  TYMBASIC GID



                                     -----



                            General Internal Design


                                     of the


                               TYMBASIC Language


                                  for Tymcom-X



                                     -----





                                     2/9/78





                                   Version 12
     TYMBASIC GID -- Overall System Considerations               Page 1
     TBA Status Control


                               TBA Status Control

          The "modules" of Tymbasic are boxes 4, 5, 6, 7, 8 and  10  of
          the  level 1 TYMBAS flowchart.  These modules communicate via
          the  user  program  data  structure  (LRT  et  al.)  and  the
          following status words:

               MDUFG:

                    The count of modules on the  module  list.   (MDUFG
                    not  0)  <=>  (a  non-empty  module  list  exists).
                    Certain  commands  and   situations   are   handled
                    differently when modules are being used than in the
                    old  Super  Basic  mode  where  only  the   current
                    workspace exists.

               PGCNFG:

                    The program continuability flag.   (PGCNFG  not  0)
                    <=>  (program  has  been  in execution;  a continue
                    point exists;  no  program  modifacation  has  been
                    made since;  CXLNUM is the continue line).

               DSMDFG:

                    The data-structure modification flag.  (DSMDFG  not
                    0)  <=>  (program  has  been  in  execution  and no
                    data-structure-mod has been  irrevocably  committed
                    since;    CXLNUM  is  the  interrupt  line).   Data
                    Recoverability  is,  however,  not  implemented  in
                    TYMBASIC.


               P.MOD:

                    P.MOD = -1 =>

                         either the program has never been executed  or
                         else  the  program has been modified since its
                         last   execution.    This   is   the   initial
                         condition.

                    P.MOD = 0 =>

                         A run phase  program  exists  and  no  program
                         modifications    have   occurred   since   its
                         inception.

                    Note:
                         (P.MOD = -1) => (PGCNFG = 0)
     TYMBASIC GID -- Overall System Considerations               Page 2
     TBA Status Control


               MSTATE:

                    A PARSE subroutine  called  when  a  source-mod  is
                    requested  by  the user.  If P.MOD is 0 then MSTATE
                    prints the message:

                         Destroy Data?

                    and awaits Y[ES]  or N[O]  .  If the answer is YES,
                    MSTATE  sets  (P.MOD,PGCNFG)  to (-1,0) and returns
                    the value 1.  If the answer is NO, MSTATE returns 0
                    and   PARSE   fails  to  carry  out  the  requested
                    source-mod.

               CXLNUM:

                    Current run-side linenum;  the line interrupted  or
                    next  to  be  executed  when  program is continued;
                    specifies context of direct statements.

               CLRFLG:

                    A status word mapped by:

                         REC  CLRFLG,<<RCFG,1>,<CCFG,1>,<DCFG,1>>

                         field         =1 means
                         -----         --------

                         @CLRFLG/RCFG  XRUN data structures allocated
                            "   /CCFG  COMPIL data structures allocated
                            "   /DCFG  DECLAR data structures allocated

                    When /xCFG = 0, then the process x data  structures
                    are   totally  unallocated  (all  tbl's  have  been
                    TRLS'd, etc.).  When  /xCFG  =  1,  then  the  data
                    structures  for process x represent the successful,
                    error-free, complete output of process  x  for  the
                    current program (if P.MOD not -1) or for a previous
                    state of the program (if P.MOD = -1).

               PSW:

                    A status word used when a transition is to be  made
                    from  PARSE  to  other modules.  PSW, set by PARSE,
                    designates  which  command  is  calling   for   the
                    transition  and  which actions need to be performed
                    by the other modules.
     TYMBASIC GID -- Overall System Considerations               Page 3
     TBA Status Control


               SEGNO:

                    As each module exits, it sets  SEGNO  to  the  case
                    value  (see  TYMBAS  flowchart) of the module to be
                    executed next


               DECLSW:

                    This switch is used to tell the code  generator  to
                    do  some  initialization.   It  is  set  to zero in
                    SYSUP.  During COMPIL it is looked at.   If  it  is
                    zero  then some initialization stuff is done and it
                    is set to one at once.  Once set to  one  it  never
                    once changes (a small wonder).

          Overall  flow   of   status   control:    at   SYSUP,   these
          initializations are made:

               -1 -> P.MOD

               0 -> CLRFLG,DSMDFG

               0 -> PGCNFG,MDUFG,DECLSW

          When PARSE  exits  to  other  modules,  the  value  of  P.MOD
          (together  with  the  active  user  command)  determines  the
          setting of PSW.  PSW, in turn, governs which modules  are  to
          be  called.   The  action of those modules is governed by the
          values of  PSW  and  CLRFLG.   Before  exiting,  each  module
          ensures  its  data  structures  are  as advertised by CLRFLG.
          Exit is to PARSE if errors were found and to  the  designated
          successor  module otherwise (as shown below in the Transition
          Table).
     TYMBASIC GID -- Overall System Considerations               Page 4
     TBA Status Control


          The primary system tasks which  vary  according  to  PSW  and
          CLRFLG are shown in the following table.

                                   Task Table

          task#     done by     description
          -----     -------     -----------

            1       DECLAR      0  ->   /DCFG;    release   structures;
                                process  declarations;   if errors then
                                release structures else 1 -> /DCFG

            2       DECLAR      if /DCFG =  0  then  do  Task  1,  else
                                (start   with  existing  SDT;   process
                                declarations and update SDT;  if errors
                                then  release  structures  and put 0 ->
                                /DCFG).

            3       DECLAR      display definition of symbol  CDEID  in
                                context CDELN1.  (The SYMD command).

            4       COMPIL      0  ->   /CCFG;    release   structures;
                                compile   program;    if   errors  then
                                release structures else 1 -> /CCFG

            5       COMPIL      compile direct statement;  leave  /CCFG
                                alone;  if errors then return to PARSE

            6       COMPIL      display  compiled  code  for  lines  in
                                range CDELN1:CDELN2

            7       IZVAR       Initialize the Run  Phase  (system  and
                                user defined variables, etc)

            8       IZVAR       Recover user data from  VMF  file  into
                                loseg.  of direct statement code

            9       XRUN        Transfer execution to user  program  or
                                direct statement.
     TYMBASIC GID -- Overall System Considerations               Page 5
     TBA Status Control


          The following table shows each of the possible values of PSW,
          designates  which  of the above tasks are to be performed and
          shows the normal set of modules to be invoked.


                                Transition Table

           P.MOD                               ---------Modules--------
           =-1?  Condition    PSW Tasks        DECLAR COMPIL IZVAR XRUN
           ----- ------------ --- ------------ ------ ------ ----- ----

             Y   direct stmnt  1  1,4,5,7,9      X      X      X    X
             N   direct stmnt  2  5,8,9                 X      X    X
             Y   RUN           3  1,4,7,9        X      X      X    X
             N   RUN           4  8,9                          X    X
             N!  START         6  9                                 X
             N!  GO            7  9                                 X
             Y   INIT          8  1,4,7,9        X      X      X    X
             N   INIT          9  7,9                          X    X
          either CLEAR        10  none         SYSIZL
          either QUIT         11  none         EXIT
             Y   CDE          12  1,4,6          X      X
             N   CDE          13  1,4,6          X      X
             Y   SYMD         14  1,3            X
             N   SYMD         15  3              X
             N!  STEP         16  9                                 X
             Y   SAVE BIN     17  1,4,7          X      X      X
             N   SAVE BIN     18  not implemented
          either LOG          19
     TYMBASIC GID -- Overall System Considerations               Page 6
     Module Transitions (USWAP)


                           Module Transitions (USWAP)

          Transition among SYSIZL, PARSE, DECLAR, COMPIL, and IZVAR  is
          via  RUNSEG  and  preserves a continuous loseg.  When control
          passes via TRRZL to RUNIZL and XRUN, a new  loseg  and  hiseg
          are  to be created by the loader.  Prior to this the editside
          loseg is saved on the VMF file.

          A running TBA program is laid out as follows:
          (brackets denote optional items.)

                       0:  monitor area data
                           TBA system data and direct statement temps
                           module1 data }
                          [module2 data]}
                          [ . . .      ]}  Includes workspace module
                          [modulen data]}
                          [library-list data]
                           TBA library data
                           dynamic storage

               O'400000':  TBA system code
                           module1 code
                           module2 code
                            . . .
                           modulen code
                           workspace module code
                           direct statement code
                           library-list code
                           TBA library code

          The  module  data  area  contains  numeric  scalars,   string
          descriptors  and  array  descriptors;   it  is allocated to a
          static area by DECLAR (and COMPIL).

          The DSA holds the actual bodies of strings  and  arrays.   As
          these  structures are dynamic, DSA may grow or shrink in size
          during execution;  it is thus always at the highest locations
          of the loseg.

          When a TBA program begins execution, the hiseg is saved on

               nnnSBA.SHR

          where nnn is the current job number.

          When the program is interrupted, the current loseg is written
          out on the VMF file.  Control then passes to PARSE via runseg
          (SYS)TBA.SHR.
     TYMBASIC GID -- Overall System Considerations               Page 7
     Module Transitions (USWAP)


          If the program is restarted with the GO or STEP command, user
          data)  can  simply be reloaded and execution resumed.  If the
          program is restarted by a direct statement, then a reload  of
          the  .REL files will be required.  If no program modification
          is in effect, user data is reloades to its old  location  and
          control is transferred to the direct statment.
     TYMBASIC GID -- Overall System Considerations               Page 8
     Program Load Map (PGMP)


                            Program Load Map (PGMP)

          The Program Load Map is created by  RUNIZL  as  part  of  the
          Program  Load Process from information supplied by the system
          loader.

          The format of the loadmap is given by:

               REC# PGMP,<<NPGMP,36>,
                    <LPGMP,18>,<HPGMP,18>>

               /NPGMP -- sixbit program name

               /LPGMP -- loadpoint of loseg

               /HPGMP -- loadpoint of hiseg

          The program load map is generated as the initial  process  of
          RUNIZL.  This process proceeds as follows:

          1.   The symbol table generated by the loader (found  at  the
               end  of  the loseg) is reformatted into the above record
               format.  The table origin is placed in MAPORG.

          2.   The pager initialization routine is called.

          3.   A copy of PGMP is placed in the VMF for use by  the  MAP
               command.

          4.   The STARTPOINT and WORKSPACE module names  are  obtained
               from the virtual memory file.

          5.   PGMP is scanned to find  the  startpoint  module.   This
               module will be one of the following:

               a.   The module specified by the STARTPOINT command.

               b.   The workspace module.

               c.   The direct statement code module.

               The highseg startpoint address is stored in STRTPT.
     TYMBASIC GID -- Overall System Considerations               Page 9
     XRUN Load String


                                XRUN Load String

          From the module list and library list,  TBA  creates  a  load
          string  to drive the TBA loader (the system loader pre-loaded
          with necessary system modules) which contains  names  of  the
          .REL files in the following order:

               module
                    module
                    .  .  .
                    module (workspace module)
                    direct statement module  nnnDST.REL  library  (user
                    libraries)
                    library
                    .  .  .
               TBALIB.REL

          The modules are  in  the  order  of  the  module  list;   the
          libraries are in the order of the library list.

          The .REL files have conventional program names (same  as  the
          file name) so that the Program Load Map can be used to find:

               a.   the bounds of the module area, as a whole

               b.   The bounds of the workspace module

               c.   the startpoint of the TBA program

          See Program Load Map above.
     TYMBASIC GID -- Overall System Considerations              Page 10
     Program Load Process


                          Program Load Process (TRRZL)

          The process of passing from the SYSIZL,..., COMPIL states  to
          RUNIZL  and  XRUN  is  accomplished by TRRZL (Transfer to run
          initialization).    TRRZL   consists   basically   of   three
          subprocesses:

          1.   Build XRUN load string.

          2.   Invoke the TBA loader via a RUN UUO.

          3.   Begin run phase execution in the RUNIZL state.
     TYMBASIC GID -- Overall System Considerations              Page 11
     Direct Statement References


                               Direct Statements

          Each direct statement is a separate module.  References  from
          within  the  direct  statement to its own data or code and to
          library routines is accomplished by  relocation.   References
          from  the  direct statement to the workspace are accomplished
          by indexing.  Register 14 octal (UVARR) is used for  indexing
          into the workspace module's loseg.  Register 15 octal (WLOCR)
          is used for  indexing  into  the  workspace  module's  hiseg.
          These  two registers are set by IZVAR and are not used by any
          run phase code.
     TYMBASIC GID -- Overall System Considerations              Page 12
     Condition Trap Table (CNDTT)


                          Condition Trap Table (CNDTT)

          A table, CNDTT, is maintained for each  condition  and  holds
          the information:

               a.   whether condition armed

               if armed:

               b.   address to trap to
     TYMBASIC GID -- Overall System Considerations              Page 13
     Data Structure Management (TBL, DSA, Module Transitions, USWAP)


        Data Structure Management (TBL, DSA, Module Transitions, USWAP)

          Two data structure environments  are  maintained  under  TBA.
          The  first,  the editside, encompasses SYSIZL, PARSE, DECLAR,
          COMPIL and  IZVAR;   the  second,  called  runside,  prevails
          during program execution (i.e., the TBA module, XRUN).

          The editside  loseg  is  maintained  continuously  among  its
          modules.   The data structures involved are system variables,
          arrays, FTBL's, TBL's and VTBL's.  The  only  dynamic  blocks
          allocated  (see LALOC, LFREE) are for the IO buffers involved
          in the DO and TOUT commands.

          The TBL package is described in detail under separate  cover,
          but  briefly,  the  structures  TBL and VTBL are managed in a
          dynamic portion e loseg called the paging area.  The VMF
          is  used  as  a  swapping  store  for the paging areas.  When
          control is passed to the runside, the entire  editside  loseg
          is dumped on the VMF.

          The runside uses  no  TBL's,  VTBL's  or  FTBL's.   All  data
          structures  are  either  static  areas set up at load time or
          else are in the DSA area.  The DSA area is  a  collection  of
          dynamically  allocated blocks of storage pointed to by static
          data structures.  Included in the DSA are  array  and  string
          bodies, IO buffers, and IO control blocks.
     TYMBASIC GID -- Overall System Considerations              Page 14
     System Debug Switch (DEBMOD)


                          System Debug Switch (DEBMOD)

          The conditional assembly switch DEBMOD governs  the  assembly
          of TBA debugging facilities.  The settings are:

              0 = No Debug
              1 = DDT at run-time
              2 = DDT at parse-compile-time
              3 = DDT at both parse-compile-time and runtime

          With DEBMOD nonzero, DDT is entered at the beginning of  code
          generation,  on  entering  the  runside, and on return to the
          parseside.  Local symbols are put out to the .REL  file  with
          DEBMOD nonzero including a statement label for the first word
          of code generated for each TBA source line.  The form of this
          label  is nL where n is the decimal line number of the source
          line.  Line 200 would thus have the label '200L'.

          DEBMOD  nonzero  also  causes  checks  for  internal   errors
          throughout TBA.
     TYMBASIC GID -- Overall System Considerations              Page 15
     System Stack


                                  System Stack

          Register 17 octal (RXP,P) is used as a pushdown stack pointer
          for  all TBA internal system linkage.  Positions on the stack
          are allocated for parameter values, local variables  and  the
          return address.
     TYMBASIC GID -- Overall System Considerations              Page 16
     System Stack


                             User-Supplied Routines

          Routines to be loaded with TBA programs must  follow  certain
          rules  of  neighborliness.   These  rules  are  discussed  in
          Appendix E of the TBA Reference Manual.
     TYMBASIC GID -- Overall System Considerations              Page 17
     Object File Naming Conventions


                         Object File Naming Conventions

                                      DEBUG      NO DEBUG
                                  -------------------------
                    Named         | name.RDL  | name.REL  |
                    Anonymous     | nnnWRK.RDL| nnnWRK.REL|
                    Direct Stmt.  | nnnDST.RDL| nnnDST.REL|
                    Source File   |      nnnWRK.TBA       |
                                  -------------------------


          In PARDAT:

               CERCNT

               WRKCMP#0  iff  the  current  module  is  the   workspace
                              module

               MODNM: BLOCK 5 name of the source file

               1st  word=0 iff the  current  module  is  an   anonymous
                              workspace


          -RUN TBA
          >DEBUG
          >MODULE A
          >NO DEBUG
          >MODULE B
          >10 A=0
          >PRINT A

          generates:  A.RDL
                      B.REL
                  nnnWRK.REL (empty workspace module)
                  nnnDST.REL
     TYMBASIC GID -- Overall System Considerations              Page 18
     User-Defined Modules and Libraries


                       User-Defined Modules and Libraries

          The  module  list  is  maintained  by  use  of   these   data
          structures:

               MDUFG -- number of modules

               REC  MDUR,<<MDUN0,36>,<MDUN1,36>,<MDUN2,36>,
                    <MDUN3,36>,<MDUN4,36>,<MDUPPN,36>,<MDUMD,36>>

               TBL  MDUT,20,MDUR

                    /MDUMD  -- (not 0) <=> (module mode in DEBUG)

                    /MDUN0 -- /MDUN4 -- module  name  in  ASCIZ  format
                              (possibly   with   directory   name   and
                              extension, including parenthesis and  "."
                              but will all spaces removed.)

                   /MDUPPN -- Project-programmer number  of  directory,
                              if applicable, zero otherwise


          The  library  list  is  maintained  by  these  similar   data
          structures:

               REC LIBR,<<LIBN0,36>,<LIBN1,36>,<LIBN2,36>,
                    <LIBN3,36>,<LIBN4,36>,<LIBPPN,36>>


               TBL LIBT,20,LIBR /LIBN0 - /LIBN4 -- library  name,  same
               format as module name above

               /LIBPPN -- same as /MDUPPN
     TYMBASIC GID -- Overall System Considerations              Page 19
     Line Reference Table (LRT)


                           Line Reference Table (LRT)

     REC  LRTE,<<LCOD,18>,<LNUMB,18>,<LTXT,36>,<LPMC,36>,<LNXT,12>,
                       <LSUBN,9>,<LCFG,1>,<LDFG,1>,<LEFG,1>,<LFOR,6>,
                       <LTOFFG,1>>

          TBL  LRT,,LRTE

                    /LCOD  -- address of compiled code

                    /LNUMB -- line number;  100003 => deleted entry

                    /LTXT  -- virtual address of source text

                    /LNXT  -- recno of successor LRT entry

                    /LPMC  -- virtual address of PMC's

                    /LSUBN -- procedure number containing this line  (0
                              = main prog)

                    /LCFG     = 0 <=> (process line in COMPIL)

                    /LDFG     = 1 <= (process line in DECLAR)

                    /LEFG     = 1 <=> (/LCOD established)

                    /LFOR  -- number of FOR loops in this line.  DECLAR
                              allocates   R%VRLC   space   for   return
                              addresses based on this field.

                    /LTOFFG   = 1 <=> TOF (top of form)  mark  on  this
                              line


          LRT is a chained dictionary to the user program.   The  first
          three entries of LRT are always:

               1 = DSTH# -- direct statement

               2 = LSTH# -- dummy last line

               3 = FSTH# -- dummy first line

          LRT Index Table -- LRXT


          The LRXT allows rapid lookup of LRT  entries,  given  a  line
          number value:
     TYMBASIC GID -- Overall System Considerations              Page 20
     Line Reference Table (LRT)


              REC -- LRX,<<LRXL,18>,<LRXK,18>>

              LRXN -- highest entry num in LRXT

              LRXSZ# -- (=100) declared size of LRXT arrays

              LRXT[0:LRXSZ#]LRXL -- periodically selected  line  number
                    values, including endpoints of LRT

              LRXT[0:LRXSZ#]LRXK -- corresponding recid's within LRT

              LRXRG -- (highest linenum) minus (lowest linenum)

              formula for initial guess is:

              I = ((LNUMb-LRXL[0])*LRXN)DIV LRXRG

          LRXT is setup by DECLAR initialization and used  subsequently
          by both DECLAR and COMPIL.

          These entries simplify the process of chaining in user lines.
          These entries are initialized:

               Entry    /LNUMB     /LNXT
               -----    -----      -----

               DSTH     100000     DSTH 

               LSTH     100001       0

               FSTH     100002     LSTH 

          Deleted LRT entries have /LNUMB = 100003.

          Note:
          New entries are always added to the ends of LRT, TXT and PMC.
          Garbage  collection  only  occurs  as  a  byproduct of GET or
          RENUMBER.  Omitted LRT entries  are  threaded  past  (besides
          being given a special /LNUMB value).
     TYMBASIC GID -- Overall System Considerations              Page 21
     Text Area (TXT)


                                Text Area (TXT)

               VTBL TXT,7,*

          The records of TXT are the source lines of the  user  program
          stored  in  standard  Tymcom  X  7-bit  ASCII.  The lines are
          retrieved via the LRT.
     TYMBASIC GID -- Overall System Considerations              Page 22
     PMC (PMC)


                                      PMC

          The PMC (also known as preliminary  code,  pass  1  code  and
          TYMBASIC  intermediate  code)  is  the  stuff that the parser
          generates  from  the  TBA  program  and  sends  to  the  code
          generator.

          PMC lives in 9 bit bytes.  The first byte in a string of  PMC
          bytes gives an OPTYPE.  A particular OPTYPE may require other
          bytes containing information like line numbers  and  variable
          ids.   Usualy the size in bytes of the PMC string for a given
          OPTYPE is fixed.  An exception is SCON which gives  a  string
          constant.   Its  format is the SCON optype followed by a byte
          containing the number of characters in the  string,  followed
          by  the  characters  one  per byte.  You must be careful when
          processing PMCs not to lose your place or havoc will result.

          When OPTYPES were first discovered they were  in  the  ranges
          0-124  and 235-255.  They were probably borrowed from a basic
          written for a 32 bit machine which would very likly have  had
          8  bit  bytes.  The original intent was to fill in the center
          hole with any new PMCs.  It is considerably safer to add  new
          optypes   after  255  instead.   The  center  hole  has  been
          compressed out of many of the PMC tables and the cutoff point
          for  the  lower  range  has been hardwired into the code with
          such mild atrocities as 'CAIG 1,124's and the like.

          PMC is generated during LNANAL (  the  mammouth  Parse  1.5.4
          which  is  the  analysis  of  one  line of the TBA source) in
          packets.  For details on packets read "7.6.1 Pass 1 and  Pass
          2  Code Generation".  In MOVBIN (Parse 1.5.7) the packets are
          ordered.  In THREAD(Parse 1.5.12) the LRT is given a  pointer
          to the completed PMC for the line.

          The PMC is retrieved via the LRT in  DECLAR,  COMPIL  and  in
          PMCX(Parse  1.5.6.21) for processing.  The processing is done
          through a number of tables which are referenced with the  PMC
          OPTYPE.  The tables are:


          PSTMLT and POPLT in DECLAR      an XCT table.  It contains an
                                         instruction  for  each  OPTYPE
                                         that either  ignores  the  PMC
                                         string       or      processes
                                         declarations as appropriate.

          COPTX and COPTY in COMPIL       which gives a location in the
                                         code  generator  where the PMC
                                         string can be processed.
     TYMBASIC GID -- Overall System Considerations              Page 23
     PMC (PMC)


          RZTBLO an RZTBHI in CSUBS       which gives the length of the
                                         PMC string for each OPTYPE for
                                         use  in  bypassing   the   PMC
                                         string during an error.

          PMCNMS in PARSE8                which gives the ASCII name of
                                         the  OPTYPE  for  use  in  the
                                         'PMC' command

          PMCTBL  in  PARSE8                which  gives   a   printing
                                         pattern for the PMC string for
                                         use in the 'PMC' command.

          All except the last, PMCTBL, are  generated  with  macros  in
          PMC.MAC.   The  macros  are  LOPMCS and HIPMCS.  They contain
          comments and serve as documentation for the preliminary code.
          LOPMCS  gives  the  dope  on  the OPTYPEs in the range 0-124,
          HIPMCS the range 235 and up.   A  sub  macro  entitled  "PMC"
          gives  information  for  each  OPTYPE.   In  particular:  the
          OPTYPE number, the ASCII name, an  instruction  for  the  XCT
          table  in DECLAR, an address for the table in COMPIL, and the
          total size in bytes of the PMC string of  that  OPTYPE.   The
          various  tables  are  generated  by redefinition of the "PMC"
          macro followed by expansions of the LOPMCS and HIPMCS macros.

          To add a new OPTYPE you need only make a new entry to the end
          of HIPMCS and to the end of PMCTBL in PARSE8.

          For a somewhat outdated but still  valuable  account  of  the
          implemetation  of  a  new  statement  in  TBA  including  PMC
          changes, read (SPUNKDEV)JEFF1.MEM .




                                 PMC Area (PMC)

               VTBL PMC,9,*

          Each  record  of  pmc  holds  the  PMC's  (parser  output  --
          preliminary   code)   for   the  corresponding  source  line.
          Retrieval is via LRT.
     TYMBASIC GID -- Overall System Considerations              Page 24
     Name Table (HVX,NAMDIC)


                         Name Table (NAMT, NAMTB, NAMS)

          The Name Table stores TBA  reserved  words  and  user-defined
          symbols.   As  each  new name is entered, the next sequential
          integer (starting from 1) is permanently associated with that
          name.  The next integer to be assigned is kept in NAMIDX.

          The names are paged manually rather than by a  TBL  to  allow
          fast  access.   The  pager  allocates  pages  of free core as
          needed for additional names.  The vector NAMDIC contains core
          locations  of  each  allocated  block of names.  Each name is
          stored in Sixbit.  Three words  of  core  are  allocated  per
          name:   Two  and  one-half  for  the  spelling  and  the last
          halfword for a link to the next name in that last chain;  the
          link  is  the  name  table  number  (NAMIDX) of that name, so
          locating that next name requires a reference to NAMDIC.   HVX
          is  a statistically allocated vector of primary hash links to
          name table entries.
     TYMBASIC GID -- Overall System Considerations              Page 25
     Variable Allocation Address (R%VRLC)


                      Variable Allocation Address (R%VRLC)

          The variable R%VRLC, initialized to STRTUV during DECLAR,  is
          the relocatable loseg address next available to be used for a
          storage location.  During DECLAR, loseg  space  is  allocated
          for explicitly declared variables.  Numeric scalars get space
          for their values, strings and  arrays  get  space  for  their
          descriptors.   When  a  procedure is encountered, a parameter
          vector (PVEC) is started.  Declaration for parameters,  local
          variables,   and   entire  PVECs  for  local  procedures  are
          contained within the PVEC.  At the completion of  the  DECLAR
          pass  we  allocate  one  word  to hold the return address for
          every FOR loop (we counted them).

          During COMPIL, space is  allocated  for  implicitly  declared
          variables  and temp cells.  Blocks of loseg space are used to
          save away registers and temp cells before calling procedures.
     TYMBASIC GID -- Overall System Considerations              Page 26
     Location Counter (RXLOC)


                            Location Counter (RXLOC)

          The variable RXLOC holds the relocatable address of the  next
          instruction to be generated;  RXLOC is initialized to zero by
          COMPIL  in  Task  4  (see  Task  Table);   direct  statements
          continue to increase RXLOC.
     TYMBASIC GID -- Overall System Considerations              Page 27
     Break Structures (BRKT, BRKTR, BRKN, BRKLX)


                  Break Structures (BRKT, BRKTR, BRKN, BRKLX)

          BRKT  contains  all  active  BREAK  information.    BRKT   is
          maintained  by  PARSE  and  referenced  by XRUN, particularly
          RHED.  The format is

               REC  BRKTR,<<BKL1,18>,<BKL2,18>>

               ARRAY  BRKT[BRKTR:  BRKLX*BRKTR]

          The variable BRKN is  the  current  number  of  entries,(plus
          one), limit BRKLX, in BRKT.

          Entries are coded:
               /BKL1 -- Low linenum of a range

               /BKL2 -- high linenum of a range (same as /BKL1  if  the
                        "range" is a single line number.)

          Entries are kept sorted from lowest to highest line # at  all
          times, with no overlap or duplication.

          BRKT is initialized by setting BRKT[0] to 100001,,100001  and
          setting BRKN=1.
     TYMBASIC GID -- Overall System Considerations              Page 28
     Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)


         Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)

          Structure

               varb   TRCN,TRVN,NOVTN

               REC  NOVTRR,<<NOVL1,18>,<NOVL2,18>>

               REC  TRCTR,<<TCL1,18>,<TCL2,18>,<TCVL,36>>

               REC  TRVTR,<<TRVLC,18>,<TRVID,15>,<TRVTP,3>,
                    <TRVSP1,36>,<TRVSP2,36>,<TRVSP3,36>>

               TRCLX = 15

               TRVLX = 25

               ARRAY  TRCT[TRCTR:TRCLX*TRCTR]

               ARRAY  TRVT[TRVTR:TRVLX*TRVTR]

               ARRAY  NOVTR[NOVTRR:  TRCLX*NOVTRR]

          Contents

               NOVTN  -- number of active entries in NOVTR, limit TRCLX

               TRCTN  -- number of active entries in TRCT, limit TRCLX

               TRVN   -- number of active entries in TRVT, limit TRVLX

               TRVLX  -- limit on entries in TRVT

               TRCLX  -- limit on entries in TRCT, NOVTR

               /TCL1  -- low number of range specified

               /TCL2  -- high number of range

               /TCVL  -- entry  number  of  associated  entry  in  TRVT
                         (first entry is number 0)

               /TRSP1  - 1st 5 charaters of name

               /TRSP2  - 2nd five numbers of a name

               /TRSP3  - 3rd five characters  of  name;   NULL  padded,
                         left justified(ASCIZ format)

               /TRVLC -- relative R%VRLC location of the variable
     TYMBASIC GID -- Overall System Considerations              Page 29
     Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)


               /TRVID -- identno (SDT index) of the variable (VARID)

               /TRVTP -- type of the variable

          Use

               PARSE maintains all parts of the trace structure  except
               for  TRVT/(TRVLC,  TRVTP).  IZVAR maintains TRVT/(TRVLC,
               TRVTP)

               TRCT is initialized to TRCT:  100000,,100000
                                        +1:     999
                                     with TRCTN=1

               TRVT is initialized by setting TRVN=0

               NOVTR is  initialized  to  NOVTR:   100001,,100001  with
               NOVTN=1

               NOVTR and TRCT are  kept  sorted,  with  no  overlap  or
               duplication;   TRCT  is  sorted  first on /TCVL, then on
               line range.
     TYMBASIC GID -- Overall System Considerations              Page 30
     Register Usage


                                 Register Usage

               R1(RXJ#) -- JSP register:  procedure calls, GOSUB calls,
                       RHED calls, FOR loop body calls

               R17(RXP#) -- push jump register  for  system  (flowchart
                       and  library) calls and array element accessing.
                       Often refered to in the code as 'P'.

               R16(RXO#) -- statement origin  register  (see  Statement
                       Orientation)

               R15(WLOCR) -- workspace module hiseg register.  Used  as
                       an index register in direct statements

               R14(UVARR) -- workspace module loseg register.  Used  as
                       an index register in direct statements

          Note:
            Registers R14 thru R17 are reserved for  dedicated  use  by
          TBA.
     TYMBASIC GID -- Overall System Considerations              Page 31
     Processing of Monitor-Controlled Interrupts


                  Processing of Monitor-Controlled Interrupts

          A stack of locations is maintained to which control is to  be
          passed when an escape is typed by the user:

               REC  EXSXR,<<EXLOC,18>,
                    <EXRXP,18>>

               Array  EXSX[0:10*EXSXR]

                       EXN -- current depth of stack

                    /EXLOC -- address to resume control

                    /EXRXP -- value to place in r[RXP#] before  passing
                              control

          @EXSX[I*EXSXR] points to the  record  holding  the  interrupt
          information for the level I.

          A set of routines govern whether the interrupt is to actually
          be serviced:

           EXOFF( ) -- when called, causes escapes to be ignored

          EXPEEK( ) -- when called, returns non-zero if an  escape  has
                       been  ignored  since  the  most  recent  call to
                       EXOFF( )

            EXON( ) -- when called, rearms escapes and,  if  an  escape
                       has  been  typed  since  the most recent call to
                       EXOFF( ), transfers control according to the top
                       of EXSX[ ].
     TYMBASIC GID -- Overall System Considerations              Page 32
     DEBUG/NO DEBUG


                                 DEBUG/NO DEBUG

          The system variable DEBGSW is set to 1 when DEBUG and 0  when
          NO DEBUG.  The initial value is 1.

          DEBGSW is noticed by several TBA processes:

               process        (= 0) =>
               -------        --------

               BREAK,TRACE,   prohibit yourself
               STEP

               COMPIL         generate calls to RPHED insted of RHED

               RDXMX          shorter subscripting code
                               (not yet implemented)
     TYMBASIC GID -- Overall System Considerations              Page 33
     Numeric Scalars


                                Numeric Scalars

          Numeric Scalars are stored as

               Type           Format
               ----           ------ 

               logical        one word integer:
                              0 = FALSE
                              1 = TRUE

               integer        one word integer

               real           one word floating point

               double         KI-10 format double precision floating

               complex        two consecutive single precision floating
                              values -- (real part,imaginary part)
     TYMBASIC GID -- Overall System Considerations              Page 34
     Type Codes


                                   Type Codes

          The TBA data-type code conventions are:

               type        name      value
               ----        ----      -----

               logical     LOG#        0

               integer     INT#        1

               real        REAL#       2

               double      DBL#        3

               complex     CPLX# or    4
                           CMPLX#

               string      STR#        5
     TYMBASIC GID -- Overall System Considerations              Page 35
     String Scalars


                                 String Scalars

          A string scalar comprises a descriptor and a body.

          The descriptor occupies two words:

               0:  body address

               1:  curr length | max length

          The body  begins  on  a  word  boundary  and  each  character
          occupies seven bits:

               0:  BYTE(7)C1,C2,C3,C4,C5

               1:  BYTE(7)C6, etc

          The fields of the descriptor are accessed via:

               REC  SDR,<<SDADR,36>,<SDCL,18>,<SDML,18>>

                    /SDADR -- address of string body;  if zero, denotes
                              an  unallocated  string, any reference to
                              which should be diagnosed

                    /SDCL  -- number of characters currently stored  in
                              the body.

                    /SDML  -- declared length of the string -- the body
                              has  been  allocated enough space to hold
                              this many characters

          The string body is always allocated  an  integral  number  of
          fullwords  and  is  initialized  to all zero bits.  Bit 35 of
          each body word always remains  zero.   Whenever  a  value  is
          stored  into  a  string,  unused  character  positions in the
          last-stored body word are set  to  zero  bits.   Hence,  some
          string operations can be performed on a fullword basis.
     TYMBASIC GID -- Overall System Considerations              Page 36
     Messages


                                    Messages

          Constant messages (prompts, diagnostics, etc.) are not stored
          as  string  bodies with string descriptors.  Instead they are
          stored in ASCIZ form -- termination is by a NUL.
     TYMBASIC GID -- Overall System Considerations              Page 37
     Terminal-Related Functions


                           Terminal-Related Functions

          See Tymcom-X Terminal Interface Standards.  The primary  data
          structure involved is the command input stack (CX):

               REC    CXR,<<CXFN,18>,<CXLN,18>,<CXEP,12>,<CXNM,24>>

               FTBL   CX,11,CXR

               VTBL   CXNMS,60

                      /CXFN -- file number;  0 = terminal

                      /CXLN -- ordinal line number of command most
                               recently read (at this level)

                      /CXEP -- echo state;  1 = ECHO;  0 = NO ECHO

                      /CXNM -- record identifier (within CXNMS) of file
                               nomen


          When TBA initially starts  up,  the  first  entry  in  CX  is
          created with

               0 -> CX[0]/(CXFN,CXLN,CXEP)

          and with /CXNM referring to the initial entry of CXNMS, which
          is 'TERMINAL'.

          The (ECHO,NO ECHO) commands simply set CX[0]/CXEP to (1,0).

          The variable TPOS always  holds  the  current  value  of  POS
          (carriage  position of the physical terminal).  The following
          utility routines perform terminal-oriented operations for the
          TBA system.

          1.   CXCI( ) -- Command Input

               Fetch and return a character from  the  current  command
               source.   No editing is to be performed.  If echo is on,
               post the character to the TOUT destination;   exception:
               when  command  input  is  from  terminal,  never echo to
               terminal.  If the character is the first of a  new  line
               then  increment CX[0]/CXLN.  If the end of file has just
               been reached (logically  speaking),  call  CXKX( ),  and
               return a NUL (ASCII 0) -- in this case, the next call to
               CXCI will access the lower level command source.

     TYMBASIC GID -- Overall System Considerations              Page 38
     Terminal-Related Functions


               Usage Note:

               GETLIN will read its characters via CXCI( ).  PARSE will
               only   call  GETLIN  when  the  command  source  is  the
               terminal;  command  file  input  is  done  via  CXCI( ),
               directly.   Runtime  file  input  from the * file number
               will use CXCI( ) directly.

          2.   CXDO(F) -- Open New Command File

               F points to a string descriptor which refers to a string
               which holds, hopefully, a file-nomen.  The file is to be
               opened as the command source and a new level added to CX
               with  all  fields  appropriately  initialized.   CXDO( )
               normally returns the value 1.  If  for  any  reason  the
               operation  cannot  be  completed,  a value 0 is returned
               after CXER is  called  with  an  appropriate  diagnostic
               message.

          3.   CXER(E) -- Error Conditions Encountered

               An error has been encountered.  E is the address  of  an
               appropriate ASCIZ diagnostic message.  Actions a thru c,
               section VIII of 'Terminal Interface Standards for Tymcom
               X'  are  to be performed.  The Error Message Destination
               is  the  TOUT  destination  and  the  TERMINAL.   Note: 
               unstacking does not occur if terminal is command source.

          4.   CXKX( ) -- Close Command File

               If CX currently contains only one entry (the  TERMINAL),
               do  nothing.   Otherwise,  terminate processing from the
               current command source, pop CX[0] and revert to the next
               lower  command  source.  Note that a prior echo state is
               thereby reinstated.

     TYMBASIC GID -- Overall System Considerations              Page 39
     Terminal-Related Functions


          5.   CXMO(MSG,MODE) -- Message Output

               A message is to be output.  The value of MODE determines
               the coding scheme:

                    MODE                         MSG is
                    ----                         ------ 

               MOCR# = 1           address of ASCIZ message to which an
                                   EOL should be logically appended

               MONOCR# = 2         address of ASCIZ message;  append no
                                   EOL

               MOSTR# = 3          address of string descriptor;
                                   append no EOL

               If command source  is  terminal  then  post  message  to
               terminal.  If echo is on then:

                    If TOUT File exists, post to it.

                    Else  if  terminal  not  command  source,  post  to
                    terminal.

               Usage Note:

               CXMO( ) should be  used  by  TBA  for  all  prompts  and
               messages,   as   defined   in   the  Terminal  Interface
               Standards.

          6.   CXTI( ) -- Terminal Input

               Fetch and return character from the  physical  terminal.
               Do not echo it anywhere.  Perform no editing.

               Usage Note:

               CXTI( ) is used for the INPUT statement either where  no
               file is specified or where the file number refers to the
               TERMINAL opened as a numbered  file.   CXTI( )  is  also
               used for the EIGHTI statement.

     TYMBASIC GID -- Overall System Considerations              Page 40
     Terminal-Related Functions


         7.   CXTDO(C) -- Terminal-Directed Output

              C is a character (ASCII code) to be posted  to  the  TOUT
              destination.

              Usage Note:

              CXTDO is intended to  perform  all  Terminal  -  Directed
              Output,  as  defined  in  the  Interface Standards.  This
              would include output from such commands as LIST, PMC  and
              CDE  and from the PRINT statement where no file number is
              specified.  If TERMINAL is the TOUT destination,  then  C
              is posted via CXTO( ).

         8.   CXTO(C) -- TERMINAL Output

              Post the character C to the physical terminal.

              Implementation Note:

              CXTO( ) and CXTI( ) are responsible for  maintaining  the
              variable TPOS.

              Usage Note:

              CXTO( ) is used for the  EIGHTO  statement  and  for  the
              PRINT  statement  where  a file number has been specified
              which refers to the TERMINAL.
     TYMBASIC GID -- Overall System Considerations              Page 41
     System-Level File IO


                                    File IO

          Input/output operations on files are performed  by  a  paging
          algorithm.   For  the  purposes  of this algorithm, files are
          divided up into pages.  All pages are of the same length  and
          the number of words in a page is always a power of two.
               To initiate IO operations on a file, the file must first
          be  created  or opened by calling one of the routines CREATE,
          OPENF or CONOPN.  Each of  these  routines  sets  up  a  file
          control  block  describing  the file and returns the "virtual
          address" of the beginning of the file.  A virtual address  is
          the  address  of a word or byte within a file combined with a
          field that identifies the file.  A virtual address  therefore
          uniquely  identifies  a specific word or byte of a particular
          file among all of the words or bytes in all of the files that
          are  currently  active.   Virtual addresses are of two types:
          virtual word addresses and virtual byte addresses.  A virtual
          word  address  contains  a high-order field that identifies a
          particular file and  a  low-order  field  that  contains  the
          address  of  a  word in the file relative to the beginning of
          the file (word 0).  A virtual byte address  also  contains  a
          high-order  field that identifies a particular file, together
          with a low-order field that contains the address of a byte in
          the file relative to the beginning of the file (byte 0).
               Given the virtual address of the beginning of the  file,
          the  virtual  address  of any word or byte in the file can be
          constructed by simple addition.  In order to access a word of
          the  file,  the  macro  READ is used to translate the virtual
          word address  of  the  desired  word  into  a  core  address.
          Similarly,  to  access a byte of the file the macro READCR is
          used to translate the virtual byte  address  of  the  desired
          byte  into a core address.  The way in which this translation
          is performed will now be described.
               The  paging  algorithm  first  searches  a  hash   table
          containing  one  entry  for  every  page that is currently in
          core.  If the page containing the required word  or  byte  is
          present,  the  search  will  locate  it  and  supply the core
          address of its first word.  Given this address,  the  address
          of  the  desired  word  or  byte  within  the  page  is  then
          constructed and returned.
               If the page is not present in core  memory,  the  paging
          algorithm  must  then  find a place to store the page in core
          memory.  To do this, it scans a map of the region  of  memory
          where pages are stored, looking for a free space.  The map is
          known as the core table and the region of memory is  referred
          to as the paging area.  In most cases, no free spaces will be
          available and the paging algorithm must  remove  one  of  the
          pages currently in memory to make way for the new page.
               In selecting a page to be removed, the  algorithm  takes
          three  factors  into  account.   Firstly,  a  page  which  is
     TYMBASIC GID -- Overall System Considerations              Page 42
     System-Level File IO


          currently being accessed must not  be  removed  from  memory.
          Secondly,  a page which has not been modified during the time
          that it has been in memory should be selected ahead of a page
          which  has  been  modified,  because  a modified page must be
          written back to its file, while an  unmodified  page  may  be
          discarded,  since  an  up-to-date  copy already exists in the
          file.  Thirdly, the least recently referenced page should  be
          selected,  on  the  assumption  that  it is the page which is
          least likely to be referenced in the near future.
               If a suitable page is found, it is removed from  memory.
          If not, a space is created by obtaining more core memory from
          the monitor.  The desired page is then read into  the  vacant
          space.   In the case where a request is made to access a word
          or byte that lies beyond the end of the file, a page of  zero
          words is created and appended to the file.
               When the page has been located or brought into memory, a
          marker  is set in the core table to indicate that the page is
          in use and must not be removed by  a  subsequent  scan.   The
          marker  is  in  the form of a count of the number of READ and
          READCR operations that have been performed for the  page  and
          not yet cancelled.  The count is incremented by each new READ
          or READCR operation that references the page.
               A READ is cancelled by calling either the WRITE macro or
          the  FREE macro.  Similarly, a READCR is cancelled by calling
          either the WRITCR or FREECR macro.  A call to  one  of  these
          macros  signals  that  the  page  is no longer being used and
          causes the count in the core table entry for the page  to  be
          decremented.    When   the   count   becomes   negative,  all
          outstanding READ and READCR requests for the page  have  been
          cancelled  and  it  may  be  considered for removal from core
          memory during subsequent scans of the core table.
               At the moment  when  the  count  becomes  negative,  the
          current  value  of  a  pseudo clock register is stored in the
          core table entry for the page so as to  record  the  time  of
          last access to the page.
               The WRITE and WRITCR  macros  are  used  to  inform  the
          paging  algorithm  that  the  page has been modified and must
          ultimately be written back to the file, whereas the FREE  and
          FREECR macros are used to indicate that the page has not been
          modified and need not be written back to the file (unless  it
          has been modified by other accesses).

               The READ macro returns a "word cursor".  This is a  word
          containing  the  core  address  of  the requested word in its
          right half and a count of the number of  words  between  that
          word  and  the following page boundary in its left half.  The
          READCR macro returns a "byte cursor".   This  is  a  standard
          PDP10 byte pointer.  The page may be accessed directly, using
          the word cursor or byte cursor.  Note that this requires that
          the  user  should  be  aware of the existence and location of
     TYMBASIC GID -- Overall System Considerations              Page 43
     System-Level File IO


          page boundaries in the file.  The size of pages used  by  the
          pager  is  specified  by  the  global  assembly-time variable
          PSIZE.  Its value can be changed by  altering  the  value  of
          another global assembly-time variable, PEX.

               PSIZE=2**PEX

               A  set  of  macros  and  subroutines  is  provided  that
          eliminate  the  need  for  users of the pager to be concerned
          with  page  boundaries  in  most  cases.   These  macros  and
          subroutines transfer a single word, a single byte, a block of
          words, or a string of  bytes  to  or  from  the  file.   Each
          transfer  advances the cursor to the next word or byte in the
          file, turning pages as required.  When these  operations  are
          used,  only  the  first  page  of  the  file  has  to be read
          explicitly  and  only  the  last  page  has  to  be  released
          explicitly.   Following is a summary of the tables maintained
          by the paging algorithm.

                    (1) Channel table - a table containing the  address
                    of the file control block for each active channel.

                    data in each entry:
                         -address of file control block

                    (2) File control  blocks  -  structures  containing
                    details of each active file.

                    format:
                         COUNT - count of arguments for monitor calls
                         PTR - relative address of directory name
                         NAM - file name in 6-bit bytes
                         EXT - file extension in 6-bit bytes
                         CON - confirmation information used by CONOPN
                         LEN - length of file in words
                         DIR - directory name in 6-bit bytes
                         CHAN - channel number
                         NLEN - length of file name in bytes
                         STR - file name string in 7-bit bytes

                    (3) Core table -  a  table  containing  information
                    about each page frame in the paging area

                    data in each entry:
                         - use count or age
                         - page modified indication
                         - hash table index of page

                    (4) Hash table -  a  table  containing  information
                    about each page currently in core memory
     TYMBASIC GID -- Overall System Considerations              Page 44
     System-Level File IO


                    data in each entry:
                         - virtual page number
                         - core table index of page


          OPEN AND CLOSE OPERATIONS

          1.  CREATE creates a  new  file  (or  a  new  version  of  an
          existing   file)  and  opens  it  for  reading  and  writing,
          bypassing the confirmation procedure.  It  returns  a  result
          indicator  and  the virtual address of word zero of the file.
          CREATE is a subroutine.

          Parameters

          R0 - address of a file name string
          A file name string is a string of left-justified 7-bit  bytes
          in the following format:

    S[(S<directory>S)]S<file name>[.[<extension>]]S[-S<confirmation>S]N

          Where [,] denotes optional items
               S denotes a string of zero or more spaces
               N denotes the null character (000)

          R1 - default extension string to be used  if  the  file  name
          string  contains no explicit extension.  The string should be
          left justified.  If no extension is required, this  parameter
          should be zero.

          Results

          R1 - result indicator
               1 if file successfully created
               0 if error detected (an error  message  will  have  been
          printed)
               -1 if the file name is "TERMINAL"
          R2 - virtual address of word zero of the file
          R3 - address of a copy of the file name string in edited form


          2.  OPENF opens a file for reading and writing, bypassing the
          confirmation  procedure.   It  returns a result indicator and
          the virtual address of word zero of the  file.   OPENF  is  a
          subroutine.

     TYMBASIC GID -- Overall System Considerations              Page 45
     System-Level File IO


          Parameters
               R0 - address of a file name string.
               R1 - 0 if file is to be opened for reading only.
                    1 if file is to be  opened  for  both  reading  and
          writing.

          Results
               R1 - result indicator as for CREATE.
               R2 - virtual address of word zero of the file.
               R3 - address of a copy of the file name string in edited
          form.


          3.  CONOPN creates a new file if no file exists or  opens  an
          existing file using the full confirmation procedure specified
          by Tymshare.  It returns a result indicator and  the  virtual
          address of word zero of the file.

          Parameters
               R0 - address of a file name string
               R1 - 0 open file for reading only.
                   -1 validate file name only
                    1 open file for both reading and writing.
               R2 - default extension string to be  used  if  the  file
          name  string  contains  no  explicit  extension.   The string
          should be left justified.

          Results
               R1 - result indicator as for CREATE.
               R2 - virtual address of word zero of the file.
               R3 - address of a copy of the file name string in edited
          form.

          4.  CLOSEF closes a file that has previously been opened by a
          CREATE,  OPENF  or  CONOPN.  It removes all pages of the file
          from core (even if they are locked) and writes them  back  to
          the file if necessary.  CLOSEF is a subroutine.

          Parameter
               R0 - virtual address of any word or byte of the file.


          5.  DELETE deletes a file that has previously been opened  by
          CREATE,  OPENF  or  CONOPN.  It removes all pages of the file
          from core (even if they are locked).  Delete is a subroutine.

          Parameter
               R0 - virtual address of any word or byte of the file

          Result
     TYMBASIC GID -- Overall System Considerations              Page 46
     System-Level File IO


               R1 - result indicator
                    1 if successful
                    0 if deletion not permitted


     TYMBASIC GID -- Overall System Considerations              Page 47
     System-Level File IO


          WORD-ORIENTED IO

          1.  READ converts a virtual word address into a word  cursor.
          It  takes  the  virtual  word  address stored in the location
          specified by the effective address and  replaces  it  by  the
          corresponding word cursor.  READ is a macro.

          Parameter
                    1-address of word containing the virtual address

               The page containing the  address  will  remain  in  core
          until a WRITE or FREE operation is performed.


          2.  WRITE releases a page that is no longer required so  that
          it may be written back to its file.  It takes the word cursor
          in the  location  specified  by  the  effective  address  and
          releases   the   page   containing  that  address.   It  also
          overwrites the word cursor  with  the  corresponding  virtual
          word address.  WRITE is a macro.

          Parameter
                    1-address of word containing the cursor

          3.  FREE releases a page that is no longer required  so  that
          it may be removed from core memory.  Its operation is similar
          to that of WRITE, except that the page is simply removed from
          core  memory  and is not written back to its file.  FREE is a
          macro.

          Parameter
                    1-address of word containing the cursor

               A READ operation should always be paired with  either  a
          WRITE  or a FREE.  If the number of READs performed on a page
          does not match the number of WRITEs and FREEs, the page  will
          either  remain  in  core  indefinitely  or  will  be released
          prematurely.


          4.  IN reads a word from a file.  It takes the word cursor in
          a designated register and loads the word at that file address
          into a specified register.  It then advances  the  cursor  so
          that it points to the next word of the file.  IN is a macro.

          Parameters
                    1-number of register that is to receive the word
                    2-number of register containing the cursor  (should
          not be register zero)
     TYMBASIC GID -- Overall System Considerations              Page 48
     System-Level File IO


          Parameters one and two should not specify the same register.


          5.  OUT writes a word into a file.  It takes the word  cursor
          in  a  designated  register  and  stores  the  contents  of a
          specified register into that file address.  It then  advances
          the  cursor  so  that it points to the next word of the file.
          OUT is a macro.

          Parameters
                    1-number of register containing the word
                    2-number of register containing the cursor  (should
          not be register zero)

          Parameters one and two should not specify the same register.


          6.  TFR transfers a group of consecutive words from  an  area
          of memory to a file or from a file to an area of memory.  TFR
          also advances the word cursor to point to the  next  word  of
          the file beyond the area transferred.  TFR is a subroutine.

          Parameters
                    R0 - number of words to be transferred
                    R1 - word cursor
                    R2 - memory address
                    R3 - direction of transfer
                         0 read into memory
                         1 write into file

          Results
                    R1 - updated cursor
                    R2 - updated memory address


          7.  STEP moves a word cursor backward or forward a  specified
          number  of  words  from  its current position.  If the cursor
          crosses a page boundary it will  either  WRITE  or  FREE  the
          current page as required.  STEP is a subroutine.

          Parameters
                    R0 - positive or negative number of words
                    R1 - word cursor
                    R2 - 0 if current page to be freed
                         1 if current page to be written

          Result
                    R1 - updated word cursor
     TYMBASIC GID -- Overall System Considerations              Page 49
     System-Level File IO


          BYTE-ORIENTED IO


          1.  READCR converts  a  virtual  byte  address  into  a  byte
          cursor.   It  takes  the  virtual  byte address stored in the
          location specified by the effective address and  replaces  it
          by the corresponding byte cursor.  READCR is a macro.

          Parameters
                    1-address of word containing virtual byte address
                    2-size of byte in bits


          2.  WRITCR releases a page that is no longer required so that
          it may be written back to its file.  It takes the byte cursor
          in the  location  specified  by  the  effective  address  and
          releases   the   page   containing  that  address.   It  also
          overwrites the byte cursor  with  the  corresponding  virtual
          byte address.  WRITCR is a macro.

          Parameter
                    1-address of byte cursor


          3.  FREECR releases a page that is no longer required so that
          it may be removed from core memory.  Its operation is similar
          to that of WRITCR, except that the  page  is  simply  removed
          from core memory and is not written back to its file.  FREECR
          is a macro.

          Parameter
                    1-address of byte cursor


          4.  INCR reads a byte from a file.  It takes the byte  cursor
          in  the  location  specified  by  the  effective  address and
          advances it so that it points to the next byte in  the  file.
          It then loads that byte into a specified register.  INCR is a
          macro.

          Parameters
                    1-number of register that will receive the byte
                    2-address of byte cursor

          Note that the mnemonic ILDBV may be used interchangeably with
          INCR.


          5.  OUTCR writes a byte into  a  file.   It  takes  the  byte
          cursor in the location specified by the effective address and
     TYMBASIC GID -- Overall System Considerations              Page 50
     System-Level File IO


          advances it so that it points to the next byte in  the  file.
          It  then  stores the byte from a specified register into that
          byte position.  OUTCR is a macro.

          Parameters
                    1-number of register containing the byte
                    2-address of byte cursor

          Note that the mnemonic IDPBV may be used interchangeably with
          OUTCR.


          6.  TFRSTR transfers a group of  consecutive  bytes  from  an
          area of memory to a file or from a file to an area of memory.
          It advances the byte cursor to point to the next byte of  the
          file,  transfers  the  specified  number of bytes starting at
          that position, and leaves the byte  cursor  pointing  to  the
          last byte transferred.  TFRSTR is a subroutine.

          Parameters
                    R0 - number of bytes to be transferred
                    R1 - byte cursor
                    R2 - word address of memory area
                    R3 - direction of transfer
                         0 file to memory
                         1 memory to file

          Result      R1 - updated byte cursor


          7.   STEPCR  moves  a  byte  cursor  backward  or  forward  a
          specified  number of bytes from its current position.  If the
          cursor crosses a page boundary, STEPCR will either  WRITE  or
          FREE the current page as required.  STEPCR is a subroutine.

          Parameters
                    R0 - positive or negative number of bytes
                    R1 - byte cursor
                    R2 - 0 if current page to be freed
                         1 if current page to be written

          Result
                    R1 - updated byte cursor



          MISCELLANEOUS ROUTINES


          1.  MARK sets a marker associated with a page that will cause
     TYMBASIC GID -- Overall System Considerations              Page 51
     System-Level File IO


          the  page  to  be  written  back to its file when the page is
          released.  MARK  is  mainly  useful  when  a  file  is  being
          accessed simultaneously for both reading and writing.
               The sequential output operations OUT,  OUTCR,  TFR,  and
          TFRSTR  all  turn the pages of a file as they advance through
          it.  As the cursor moves to the next page, the previous  page
          is  released  by  a WRITE operation.  Similarly on input, IN,
          INCR, TFR, and TFRSTR release  pages  by  a  FREE  operation.
          When  input and output operations are interleaved, output may
          occur within a page, but the page  boundary  may  be  crossed
          during an input operation, so that the modified page will not
          be written back to its file.  To  avoid  this  problem,  when
          input  and  output operations are occurring on the same file,
          every output should be followed by a MARK operation.  MARK is
          a macro.

          Parameters
                    1-number of register  containing  a  word  or  byte
          cursor 
                    (should not be register zero)

          MARK does not alter the contents of the register.


          2.  LOCK causes a page to be locked in core  so  that  normal
          page  turning  operations of sequential IO will not remove it
          from core memory.
               For example,  suppose  that  a  file  is  being  scanned
          sequentially  using IN operations.  Suppose also that at some
          point in the scan, a pointer to a section of the  file  needs
          to  be retained, even though the scan through the file should
          continue.  To prevent the desired page  from  being  released
          when  the  scan  passes  on  to  the  following  page, a LOCK
          operation is performed on the first page.
               Every LOCK operation should  be  paired  with  a  WRITE,
          FREE,  WRITCR, or FREECR operation to unlock the page when it
          is no longer required.  LOCK is a macro.

          Parameter
                    1-number of register  containing  a  word  or  byte
          cursor 
                    (should not be register zero)

          LOCK does not alter the contents of the register.


          3.  FCB obtains information  about  a  currently  open  file.
          Specifically,  it  returns  the  address  of the file control
          block for the file.   As  previously  described,  this  block
          contains  the  file  name, length, project-programmer number,
     TYMBASIC GID -- Overall System Considerations              Page 52
     System-Level File IO


          etc.  FCB is a macro.

          Parameter
                    1-number of register containing the virtual
                    address of any word or byte in the file
                    (should not be register zero)

          Result
                    1-address of file control block in same register
                    as above


          4.  TRANSFER is a basic IO subroutine that writes information
          to a file or reads information from it.  The core address and
          file addresses of the  information  and  the  length  of  the
          transfer are all specified explicitly by the caller.

          Parameters
               R0 - core address of first word
               R1 - virtual address of first word
               (must be a multiple of 128)
               R2 - number of words to be transferred
               R3 - direction of transfer
                    0 -read
                    1 - write
     TYMBASIC GID -- Overall System Considerations              Page 53
     Program-File Formats


                              Program-File Formats

          The SAVE command creates a very straightforward  file.   Each
          line  is terminated by a CR LF.  There are no tabs or special
          line-number or page-mark codes.  A line may be split  between
          blocks;    the  file  is  an  uninterrupted  stream  of  data
          characters.  The last block is filled out, if not full,  with
          NULs.

     TYMBASIC GID -- Overall System Considerations              Page 54
     Get-File Formats


                                GET-File Formats

          The GET command accepts a broader class of  files  than  that
          created  by  SAVE.   Only printable characters and blanks are
          allowed within a line  (no  control  characters  or  carriage
          returns or line feeds may be interior to the line).

          When a non-empty input line is terminated  by  an  ampersand,
          the following line is to be logically appended.  The sequence
          ampersand,carriage return,linefeed is  replaced  in  the  TBA
          input  buffer  by  the  single  character linefeed.  Linefeed
          characters are totally ignored by the parser.  When  text  is
          output by TBA (under LIST, SAVE, etc.) the interior linefeeds
          are  retranslated  into  ampersand,carriage  return,linefeed.
          Under    editing,   the   linefeed   prints   as   ampersand,
          return,linefeed, but is treated as a single character -- thus
          it will be copied by a &C and deleted by &N.

          Page marks, form feeds and sticky line numbers are ignored at
          the  beginning  of  a  line  (see EDIT10 manual, pp. 20, 21).
          NULLs  are  ignored  at  the  end  of  a  line.   Any   other
          occurrences  of  a  bit 35#0 is diagnosed "non-symbolic file"
          and input is terminated.  Any other occurrence of an  illegal
          character  is  diagnosed  and  the  line  is  discarded.   An
          overlong line is diagnosed and discarded.

     TYMBASIC GID -- Overall System Considerations              Page 55
     DUMP REFS and Tempcor Files


                          DUMP REFS and Tempcor Files

          Tempcor  files  are  a  special  kind  of   file   used   for
          communication  between  programs.   In  particular, the CROSS
          program obtains information about which .CRF files  exist  by
          examining  a  particular  tempcor  file,  named  'CRE'.  This
          tempcor file may either exist in core, under the name  'CRE',
          or  it  may  exist on disk under the name 'nnnCRE.TMP', where
          nnn represents the job number of the current job.

          The DUMP REFS  command  performs  two  functions.   First  it
          creates  an  appropriate .CRF file.  Secondly, it appends the
          name of the created file to the end of the CRE tempcor  file.
          The following algorithm is followed:






                                  read current
                                 CRE from core


                           no                    yes
                                     found?



                       read from               rewrite updated
                         disk                    CRE on disk

             no              yes
                   found?

          write on       update
          disk           on disk






     TYMBASIC GID -- DECLAR                                     Page 56
     Declaration Processing (DECLAR)


                        Declaration Processing (DECLAR)

          The module DECLAR, as the first pass in compiling the  user's
          program,  reads  the pmc's for declarations, DATA statements,
          DEFs, ENDFs and NAME statements.  From that information and a
          partialy filled LRT and in some cases an existing SDT, DECLAR
          does the following tasks:

               Creates  an  SDT  (Symbol  Definition  Table),  a  PRODT
               (PROcedure  Definition  Table),  and  a PARDT (PARameter
               Definition Table).

               Creates an LRXT, an LRT rapid lookup table

               Creates a DTAV table for inline data

               Allocates R%VRLC space for variables  (except  implictly
               declared   variables   which  have  space  allocated  in
               COMPIL.)

               Checks for DEF/ENDF mismatches.

               Counts FOR loops and allocates R%VRLC space for cells to
               contain return address.

               Checks validity of NAME statements.

               Sets the values of LRT/LSUBN;  clears LRT/LEFG

           Subsequent  modules  are  responsible  for  these  partially
           declarative tasks:

                (1)  Establishing LRT/LCOD

                (2)  Setting LRT/LEFG


           If an error is encountered during the processing of a  line,
           a  diagnostic is printed (via CXER) and processing continues
           with the succeeding declarative line.  If errors  have  been
           found  when  DECLAR  finishes,  control  is passed to PARSE,
           otherwise we go on to COMPIL.  The DECLAR pass also  handles
           the SYMD command.

           See Task Table and Transition Table.
     TYMBASIC GID -- DECLAR                                     Page 57
     Symbol Definitions (SDT, PRODT, PARDT)


                     Symbol Definitions (SDT, PRODT, PARDT)

           The SDT contains entries describing each symbol found in the
           module.   Each  symbol with a unique spelling is assigned an
           SDT position known  as  its  ID.   SDT  normally  holds  the
           definitions  of all global-level variables of the TBA source
           program, but during processing (by DECLAR or  COMPIL)  of  a
           procedure body, the parameter and local variable definitions
           temporarily supplant global variables of the same  spelling.
           The  structure of SDT, the Symbol Definition Table, is given
           by:

               REC  SDTR,<<SLOC,18>,<STYP,3>,<SUSED,1>,<SKND,2>,
                         <SN,9>,<SPROCN,12>>

               TBL  SDT,,SDTR

                    /SLOC  -- R%VRLC value (location) of symbol

                    /STYP  -- data type (LOG# - STR#)

                    /SUSED  = 1 <=> declaration for this  variable  has
                         been processed

                    /SKND  --
                         SSCAL# => scalar variable
                         SARY#  => array variable
                         SPRO#  => procedure
                         SPARY# => array parameter

                    /SN    -- 
                         /SKND  =  (SARY#  or  SPARY#)  =>  number   of
                              dimensions (limit 10)
                         /SKND = SPRO# => procedure number (limit 511)
                         (PRODT record number) else unused

                    /SPROCN -- ID of procedure to which  this  variable
                         is local

          R%VRLC  values  are  assigned  beginning  with  MINLV#,   and
          increasing  by  the  number  of words statically allocated to
          each  symbol  (see  Numeric  Scalars,  String  Scalars,   and
          Arrays.)

          Types are assigned either by an explicit declaration or by  a
          DIM  statement  to  the appropriate implicit type (the latter
          requiring  examination  of  NAMT).   The  first   declaration
          encountered   for  a  variable  will  set  /SUSED  to  1.   A
          subsequent declaration must agree in type and dimensionality.
     TYMBASIC GID -- DECLAR                                     Page 58
     Symbol Definitions (SDT, PRODT, PARDT)


          For procedures  (/SKND=SPRO#),  the  procedure  number  (/SN)
          locates  the  entry  for  that  symbol  in  PRODT.   PRODT is
          structured as follows:

               REC  PRODTR,<<LDRNAM,36>,<PPARS,18>,<PPFIN,18>,<PFXP,18>,
                    <PNAM,18>,<PFROC,12>,<PMODD,9>,<PNP,5>,<PUSD,1>,<PFD
          IM,4>>

               TBL  PRODT,,PRODTR

                    /LDRNAM -- radix 50 spelling of the procedure name

                    /PPARS -- record number in PARDT of initial local
                              or parameter name

                    /PPFIN -- record number in PARDT of last local or
                              parameter name

                    /PFXP  -- fixup address for procedure calls

                    /PNAM  -- ID of the procedure name

                    /PFROC -- ID of the procedure to which this
                              prcodeure is local

                    /PMODD -- mode 0 through 7 as follows:

                              0 = normal
                              1 = TBA ENTRY
                              2 = EXTERNAL
                              3 = TBA EXTERNAL (same as 2)
                              4 = SFO EXTERNAL
                              5 = CFO EXTERNAL
                              6 = SIMPL EXTERNAL
                              7 = BLISS EXTERNAL

                    /PNP   -- number of parameters (limit 31)

                    /PUSD  -- =0 ==> COMPIL has not yet learned the
                              address of the procedure

                    /PFDIM -- number of dimensions (for array-valued
                              procedure, else 0)

     TYMBASIC GID -- DECLAR                                     Page 59
     Symbol Definitions (SDT, PRODT, PARDT)


          A chain of PARDT entries is associated with each PRODT entry.
          These are records beginning with the record number /PPARS and
          linked through /PARLNK up through record number /PPFIN.   The
          structure of PARDT is:

               REC  PARDTR,<<PALOC,18>,<PATYP,3>,<PAUSD,1>,<PAKND,2>,
                    <PASN,9>,<PROCNO,12>,<PANAM,12>,<PARLNK,12>>

               TBL  PARDT,,PARDTR

                    /PALOC -- same as SLOC in SDT procedure

                    /PATYP -- same as STYP in SDT

                    /PAUSD -- same as SUSED in SDT

                    /PAKND -- same as SKND in SDT

                    /PASN  -- same as SN in SDT

                    /PROCNO -- same as SPROCN in SDT

                    /PANAM -- ID of symbol

                    /PARLNK -- pointer (link) to next PARDT entry in
                              chain

          Normally PARDT holds the specification information  for  each
          of  the  parameters or locals of the corresponding procedure.
          During compilation of the  procedure  (by  either  DECLAR  or
          COMPIL) body, the param/local fields are swapped with the SDT
          fields   of   the   corresponding   global   variable.    The
          correspondence is:

               SDT/(SLOC,STYP,SUSED,SKND,SN,SPROCN)
                           <->
               PARDT/(PALOC,PATYP,PAUSD,PAKND,PASN,PROCNO) Thus  during
          the  compilation or declaration of a procedure, the SDT holds
          definitions of all the symbols that may be referenced.
     TYMBASIC GID -- DECLAR                                     Page 60
     DATA Statement Values (DTAV)


                          DATA Statement Values (DTAV)

          DATA values are stored by DECLAR into DTAV:

               VTBL  DTAV,,7

          Each record consists of the characters  from  a  single  DATA
          statement.
     Tymbasic GID -- COMPIL                                     Page 61
     Code Generation (COMPIL, Optimization, Direct Statements)


           Code Generation (COMPIL, Optimization, Direct Statements)

          COMPIL generates code for the user  program  by  reading  all
          pmcs in line number order and making reference to SDT, PARDT,
          PRODT, and LRXT.  The output of COMPIL is the file  prog.REL,
          where  prog  is  the  current  SAVE  name.   The only symbols
          included  in  prog.REL  are  those  required  to   accomplish
          linkages  to  externally  supplied  routines.   The  level of
          optimization of the code generated by COMPIL is determined by
          three principles:

               1.   COMPIL  works  primarily  from  the  Operand   Data
                    Structure which provides only local information

               2.   operations  described  in  the  Runtime   Utilities
                    section  are  performed by those routines and hence
                    not by open code

               3.   generation of special code  to  take  advantage  of
                    constant  operands  is  only  done  where,  in  the
                    judgment of the TBA development team, a significant
                    overall system performance improvement can be made.
                    Examples are:

                         a.   immediate instructions are generated  for
                              constants where possible

                         b.   constants within expressions of a  higher
                              type are converted at compile time

                         c.   relational   operators   involving    the
                              constant zero compile JUMP instructions

          (See Direct Statements.)
     Tymbasic GID -- COMPIL                                     Page 62
     Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV)


          Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV)

          The PARSE output, PMC codes, are  in  a  right-handed  polish
          string   which  designates  operands  and  then  subsequently
          presents the operator which  is  to  operate  on  them.   The
          status  of  the  operands, during the compilation of a single
          statement, is maintained on the operand stack,  OPDSTK.   For
          both  convenience and efficiency, an array of pointers, OPDL,
          is maintained to the active entries of the stack.

               OPDL[1] thru OPDL[OPDN]

          are the addresses of the OPDN active entries.   For  ease  in
          handling  degenerate  cases,  OPDL[0]  =  0.   An  operand is
          removed from the top of the stack by

               -1 + -> OPDN

          and from position K by

               -1 + -> OPDN

               OPDL[J+1] -> OPDL[J] for J = K to OPDN

          Thus operands are  manipulated  in  toto  by  simple  pointer
          operations.

          In addition the pointers O1P and O2P  are  always  maintained
          such that O1P = OPDL[OPDN-1] and O2P = OPDL[OPDN].  Hence for
          a binary operator the operands are O1P and O2P.   The  action
          of each operator, besides generating correct code, must leave
          all elements of the Operand  Data  Structure  in  a  correct,
          consistent state.

     Tymbasic GID -- COMPIL                                     Page 63
     Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV)


          The structure of an operand entry is:

               REC  OPDR,<<OL,36>,<OV,36>,<OC,18>,<OM,18>
                    <OT,18>,<ONG,18>>

                    OPDSTK[0:159]  Array with room for 40 operand stack
          entries

                     /OC  -- class

                     /OM  -- Mode

                     /OT  -- Type (LOG#:STR#)

                     /OL  -- Location

                     /OV  -- Value

                     /ONG -- Pending Negation or number  of  dimensions
                     for arrays

          Operands are categorized on a  hierarchical  basis  with  the
          primary discriminator being Class:

               /OC       means
               ---       -----

               ONSC#     Numeric Scalar;  /OT not STR#

               OSSC#     String Scalar;  /OT = STR#

               OMX#      Matrix

               OTST#     Test

               OSC#      Slice Colon

               0SST#     Slice Star

     Tymbasic GID -- COMPIL                                     Page 64
     Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV)


          For /OC = ONSC#,

               /OM       means
               ---       -----

               OKON#     constant is in (/OV,/OL)
                                    (/OL = low part of DBL#;  no CPLX#)

               /OREG#     value is in register /OL  and,  if  CPLX#  or
                         DBL#,  in  1  + /OL;  [Note:  only registers 0
                         thru 5 can be involved in any operand]

               OLVAR#    (= OTMP#) value in R%VRLC  location  /OL  (and
                         1+/OL if DBL# or CPLX#);  Temp cell descriptor
                         pointer in /OV.

               OUVAR#    User variable;  Value in R%VRLC location  /OL;
                         absolute  addressing  needed  if  compiling  a
                         continuable direct statement;  /QV=variable ID

               /OSUB# (=4) address of value in r[/OL] or if  /OL  >  15
                         decimal,  address  of  vaule in temp at R%VRLC
                         location /OL.  Temp cell descriptor pointer in
                         /OV.

               /ONG not 0 <=> negation of the value has been  deferred;
                         /ONG not used for OKON# or OSUB#

          For /OC = OSSC#

               /OM       means
               ---       -----

               OKON#     literal, /OL= record# in LIT

               OTMP#     temporary cell;  R%VRLC location of descriptor
                         in /OL;  Temp cell descriptor pointer in /OV.

               OUVAR#    descriptor  at  R%VRLC  location  /OL;    user
                         variable;  /QV=variable ID

               /OSUB#    address of array element in r[/OL], or  R%VRLC
                         location /OL.


     Tymbasic GID -- COMPIL                                     Page 65
     Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV)


          For /OC = OMX#,

               /ONG -- number of dimensions

               /OM       means
               ---       -----

               OREG#     operand is a mat value in RAC

               OUVAR#    User variable;  operand is simply the name  of
                         an  array;   R%VRLC location of description in
                         /OL;   /OV  not  0  means  operand  is   array
                         parameter.

               OSUB#     User variable;  operand is to become an  array
                         element;   R%VRLC  location  of  descriptor in
                         /OL;  prior  /ONG  opnds  on  OPDSTK  are  the
                         subscript   expressions;    /OV  not  0  means
                         operand is array parameter.

               OTMP#     opnd is a mat value in a  temp  cell;   R%VRLC
                         location  if  descriptor  in  /OL;   Temp cell
                         descriptor pointer in /OV.

          For /OC = OTST#,

               the opnd is a deferred relational operation;  /OM is the
               operator   (OLT#,(=1)   OLE#,(=3)   OEQ#,(=2)  ONE#,(=6)
               OGE#,(=5) OGT#,(=7);  the prior two operands  on  OPDSTK
               are the comparands.


          So as to avoid repetitive searching of  OPDSTK  to  determine
          which  registers  are  committed  to which operands, a status
          vector,  RGSV,  is  maintained  which,  for  each   register,
          displays  the  involvement  of  that register in the recently
          generated code.

               RGSV[r]   means
               -------   -----

               0          register unused

               ORSVD#    register reserved by COMPIL;  not saveable  in
                         a temp cell or useable for an operand

               n         register in use by operand OPDL[n];  0 < n < =
                         OPDN

     Tymbasic GID -- COMPIL                                     Page 66
     Literals (LIT,SLIT)


                            Literals (LIT,SLIT,LHSH)


                    TBL LIT,40,LITR

                    /LV -- numeric scalar constant

                    /LL -- low-order word of numeric scalar, if type is
                           double,  or for strings, the virtual address
                           of the body

                    /LADR -- fixup address

                    VTBL SLIT,,7

                    TBL LHSH,1,LBSZE

               There are three tables used for handeling literals.  The
          LIT  table  holds the type and fixup adr of the literals.  It
          also holds the actual literal  for  numeric  literals,  or  a
          pointer into the SLIT table for string literals.

          The SLIT table holds the  actual  string  literals.   A  hash
          table,  LHSH,  holds hash codes for every LIT table entry and
          is used for literal pooling.  Each record in LHSH is a  block
          of  LBSZE  hashes.   This  was  done  to avoid a lot of pager
          activity when pooling literals.

          Numeric scalar constants are carried  on  the  operand  stack
          until  they  are  referenced.  At that point the LIT table is
          searched, with the aid of the  LHSH  table,  for  a  matching
          literal.   If  no  match is found a new LIT record is created
          for the literal.  When a string constant  is  encountered  we
          search  the  LIT records for a match.  If no match is found a
          LIT record is created and the string is stored  in  the  SLIT
          table.   The  fixup address is not filled in until the string
          is first referenced.  The operand stack entry for the  string
          carries the LIT record number in the /OL field.
     Tymbasic GID -- COMPIL                                     Page 67
     Temp-cell Description Table (TQDT)


                       Temp-cell Description table (TQDT)


               Temp-cells which have been allocated by  COMPIL  in  the
          course  of  generating code for expressions are kept track of
          in TQDT:


                    TBL  TQDT,1,TQSZE

               Every Temp cell has a temp cell descriptor  which  holds
          three  pieces  of  information:   its location, its size, and
          whether or not it is busy.  The size of a temp cell is either
          one  or  two words for single length or double length numeric
          scalars and string descriptors, or more than  two  words  for
          temporary array descriptors.  The size is stored in the right
          17 bits of the left half of the temp  cell  descriptor.   The
          left  most  bit  of  the size field is set to indicate a temp
          cell for a string descriptor which may  not  be  used  for  a
          numeric scalar.
               The location of a temp cell is determined by  R%VRLC  at
          the  time  of  allocation.   The  location  is  stored in the
          descriptor's right half.  The leftmost bit of the  descriptor
          is  the  busy flag.  It is set to one to indicate a busy temp
          cell.

               In the old days each descriptor was a record in the TQDT
          table.   This  caused  a  lot  of  pager activity so now each
          record is a block of TQSZE descriptors.  TQDBLK is a block of
          core  large  enough  to hold TQSZE descriptors.  A descriptor
          pointer, which  contains  a  block  number  (or  TQDT  record
          number)  in the left half and a number between 1 and TQSZE in
          the right, is used to identify a descriptor.  TQSZE is  large
          enough that TQDT will almost alway have but one record.

               When a procedure call is encountered,  the  contents  of
          all  busy  temp  cells  must  be  saved away in virgin R%VRLC
          territory.  This is because the procedure may  use  the  same
          temp  cells  (Even  a non-TBA procedure or a TBA procedure in
          another  module  may  call  yet  another  procedure  in  this
          module.)
               Temp cells must be freed after use and no temp cell  may
          remain  busy  beyond  the  compilation of one line of the TBA
          source.
     Tymbasic GID -- COMPIL                                     Page 68
     Control Stack (CSTK, CSTKP)


                          Control Stack (CSTK, CSTKP)

          Compilation of conditional control structures is governed  by
          the stack, CSTK.

               CSTKP -- always = @CSTK[0]

               REC  CSTKR,<<CFXL,18>,<CBGL,18>,<CMODF,18>,<CLNM,18>

               FTBL  CSTK,15,CSTKR

                    /CFXL  -- head of fixup chain

                    /CBGL  -- location of condition evaluation

                    /CMODF -- governing conditional:
                              CIF#,  CUNLS#,  CWHIL#,  CUNTL#,  CELSE#,
                              CORIF# (equal to the corresponding OPTYPE
                              values)

                    /CLNM  -- LRT record number for use in errors

          Whenever a primary conditional (IF, WHILE, UNTIL, UNLESS)  is
          encountered, an entry is created on CSTK.  The stack supports
          the bookkeeping for  forward  references  and  back  branches
          (WHILE, UNTIL).  When a secondary conditional (ORIF, ELSE) is
          encountered, the proper code is emitted and /CMODF is set  to
          the  secondary  conditional.   When the ENDIF pmc is reached,
          proper code is emitted and CSTK[0] is popped.
              When compilatio is completed, an error will be given  for
          every entry remaining on the CSTK.  /CLNM is used to give the
          line number of the primary conditional.
     TYMBASIC GID -- Runside Layout                             Page 69
     Arrays


                                     Arrays

          An array comprises a descriptor and a body.  The size of  the
          descriptor  depends on the number of dimensions of the array,
          while the body size depends  on  the  type  and  the  current
          dimension  bounds.   Appendix  F  of  the  TYMBASIC REFERENCE
          MANUAL dicusses internal array handling.

          For an array of N dimensions, the descriptor has the form:

                    -----------------------------
          ADSR      [   /ATAG     ][   /ALOC    ]
                    [   /ABSZ     ][   /ABASE   ]
                    [   /ATYP     ][   /ANDIM   ]
          +3        [   /ALB0     ][   /AUB0    ]
                                  :                -Bounds, higher
                                  :                 dimensions
          +/ANDIM+3 [   /ACOEFO   ][   /ACOEF1  ]
                                  :                -ACOEF's, higher
                                  :                 dimensions
          +CADR     [        access code        ]
                    [                           ]
                    -----------------------------

                    CADR = Code address = /ANDIM+(/ANDIM+1)div 2 + ADSR
                    +3


          The data portion of the descriptor is mapped by:

                    REC     ADR,<<ATAG,18>,<ALOC,18>,<ABSZ,18>,
                         <ABASE,18>,<ATYP,18>,<ANDIM,18>,<ALB0,18>,
                         <AUB0,18>,<ALB1,18>,<AUB1,18>,...,
                         <ACOEF0,18>,<ACOEF1,18>...>

                    /ATAG -- Slice tag field.  Ignored for "parent" 
                             array, contains bitmap for slices.

                    /ALOC -- Address of the array body 

                    /ABSZ -- Array body size

                    /ABASE -- Computed array base

                    /ATYP -- Data type of array

                    /ANDIM -- Number of dimensions

                    /ALBi -- Lower bound, dimension i
     TYMBASIC GID -- Runside Layout                             Page 70
     Arrays


                    /AUBi -- Upper bound, dimension i

                    /ACOEFi -- Access coefficient, dimension i

                    Array Descriptor sizes are determined as follows:

                    Number of dimensions      Size in words
                    --------------------      -------------
                             1                      13
                             2                      19
                            n>2               5+n+(n+1)div2


               The address of an array element is obtained by executing
          the  access  code  section of the array descriptior.  For one
          and two dimensional arrays the  array  subscript  values  are
          passed in R1 and R1,R2 respectively.  For the two dimensional
          case, R1 contains the rightmost subscript.  Subscript  values
          for  arrays of higher dimensionality are passed in the psuedo
          registers, with PR[0]  containing  the  rightmost  subscript.
          For all cases the access code call is:

               PUSHJ    RXP,CADR    (see above for CADR calculation)

          The address of the referenced element is returned in R2.

               Subscript bounds testing  may  take  one  of  two  forms
          determined  by the (DEBUG/NO DEBUG) mode switch.  If in DEBUG
          mode, each subscript is checked against the bounds  for  each
          dimension.   In  NO DEBUG mode the calculated element address
          is tested to  determine  if  it  is  within  the  array  body
          boundaries.   Note  that  one  and two dimensional arrays are
          always treated as if in  DEBUG  mode.   If  any  boundary  is
          exceeded,  control  is  transferred  to  the error processing
          routine.

          The body of an array is a contiguous block  of  storage  with
          the  elements  of the array stored consecutively in the order
          of right-most subscript varying most rapidly.  For a  numeric
          array,  each  element is simply the one or two words required
          to store a scalar of that type.

          For a string  array,  each  element  is  a  two  word  string
          descriptor of the form:

               0:  String body pointer.

               1:  Current length,, Maximum length

          Note that when the string array is declared, the  word  (0  |
     TYMBASIC GID -- Runside Layout                             Page 71
     Arrays


          max  length)  must  be  stored  as  the  second  word of each
          element, while zero is stored in the  pointer  word.   String
          bodies must be explicitly allocated as an independent process
          by the string processing routines.
     TYMBASIC GID -- Runside Layout                             Page 72
     Arrays


                                  Array Slices

          Array slicing logic is currently undefined.
     TYMBASIC GID -- Runside Layout                             Page 73
     Statement Orientation (RHED, BTFG, RXFG)


                    Statement Orientation (RHED, BTFG, RXFG)

          The  code  generated  for  each  TBA  statement  includes  an
          orientation   sequence  whose  purpose  is  to  support  such
          features as BREAK, TRACE, RESUME, continuation after  errors,
          and  printout  of offending statements with diagnostics.  The
          orientation sequence, which is

               MOVEI  RXL,linenum

               JSP    R16,rhed

          normally occurs as the first two codes for  each  line.   The
          exception  is  DEF  statements (see User Defined Procedures),
          where some linkage code precedes.  When DEBUG,  rhed  is  the
          routine  RHED;   when NO DEBUG, rhed is . + 1 and thus simply
          records the statement location in register 16 (RXO).

          When exit from a TBA statement may be temporary, as in

               GOSUB
               CALL
               procedure reference
               transfer to condition processor
               diagnostic routine

          then the values of R1 (RXJ), R16 (RXO) and,  in  some  cases,
          the  location  counter,  are  saved,  so  as  to  support the
          specified level of continuability.  The variable BTFG (set by
          XRUN  initialization) is non-zero if and only if at least one
          of BRKN or TRCN is non-zero.  The variable RXFG  (initialized
          to  BTFG  by  XRUN  initialization  and set to 1 if escape is
          typed) is non-zero if and only if RHED  should  consider  not
          returning immediately upon being called.  Thus, even in DEBUG
          mode, interpretative overhead is minimized whenever no  BREAK
          or TRACE statements are active.
     TYMBASIC GID -- Runside Layout                             Page 74
     Module Orientation (MQHED)


                           Module Orientation (MQHED)

          The variable MQHED holds the address  of  the  hiseg  of  the
          module  currently  in control.  This variable is saved and/or
          set by the execution of the following situations:

               ENTRY procedure prologues

               trap handling

               XRUN startup

               EXIT statement

          Whenever MQHED is set or unset to the workspace module,  then
          BTEG and RXFG are appropriately set.
     TYMBASIC GID -- Runside Layout                             Page 75
     GOSUB Processing (RGOSUB, RGRET, GSBSTK)


                    GOSUB Processing (RGOSUB, RGRET, GSBSTK)

          A stack, GSBSTK, is maintained on the runside.  GSBSTK  holds
          the  return  address  and  the  values (at GOSUB time) of the
          register RXL# and R16 (RXO).  The statement

               GOSUB line

          compiles into

               MOVEI  r2,address of line location

               JSP    R1,RGOSUB

          The statement

               RETURN

          compiles into

               JRST  RGRET

          RGRET restores the stacked items  and  returns  to  past  the
          RGOSUB   call.   If  the  stack  is  empty,  RGRET  prints  a
          diagnostic and causes the  line  holding  the  RETURN  to  be
          printed.
     TYMBASIC GID -- Runside Layout                             Page 76
     String and Matrix Code


                             String and Matrix Code

          One bit is used to describe each  string  or  array  that  is
          passed to a runside routine.

               0:  User variable, if array.  User variable,
               array element, or literal, if string scalar.

               1:  Temporary result (either array or string)

          The flags are found in bits 33 and  35  of  r5,  for  strings
          whose  addresses  are  passed  in r1 and in r2, respectively;
          and in bits 33 and 35 of r0, for arrays whose  addresses  are
          passed in r2 and r3, respectively.
     TYMBASIC GID -- Runside Layout                             Page 77
     FOR Loops


                                   FOR LOOPS

          A FOR loop is compiled into the following code pattern:

                         iterpart 1
                         iterpart 2
                          ...
                         iterpart n
                         JRST past

               body:     MOVEM  R1,FRET
                         bodycode
                         JRST  @FRET
               past:

          A multi-line FOR loop ends as follows:

                         JSP    1,@fret
               past:     MOVEI  1,[JRST 0,0(1)]
                         MOVEM  1,fret

          An iterpart with an upper bound compiles into:

                         eval initial value
                         eval step
                         eval upper bound
                         convert each to type of itervarb
                         load initial to AC
                         AC -> itervarb

               loop:     compare AC to bound
                         if done, JRST out
                         AC -> itervarb
                         JSP  R1,body
                         itervarb + step -> AC
                         JRST loop
               out:

          A WHILE or UNTIL iterpart compiles to:

                         eval initial value and step
                         convert each to type of itervarb
                         initial -> itervarb

               loop:     test condition
                         if done, JRST out
                         JSP  R1,body
                         step + -> itervarb
                         JRST loop
               out:
     TYMBASIC GID -- Runside Layout                             Page 78
     FOR Loop Generation (FORSTK, FORP, FORTYP, FORBX)


               FOR Loop Generation (FORSTK, FORP, FORTYP, FORBX)

          Compilation of FOR loops is  accomplished  using  these  data
          structures:

               FORP   -- always equal to TLOC(FORSTK,0)

               FORSTK -- stack to facilitate nested  FOR  loops;   only
                         the top record is accessed

                    FTBL FORSTC,15,FORSC

                    REC  FORSR,<<FVAR,18>,<FFXP,18>,<FRET,18>,
                         <FTYP,18>,<FLVAR,18>,<FFLG,18>,<FLNM,18>>

                         /FVAR  -- varid of itervarb

                         /FFXP  -- during  processing  of  loop  body: 
                                   address  of  JRST around body During
                                   processing of iterparts:  address of
                                   head  of fix-up chain for references
                                   to the first word of the  body.   In
                                   the  case of SUM, PROD, MAX and MIN,
                                   the body is compiled first,  so  the
                                   address  of  the  first word of body
                                   code goes here.

                         /FRET  -- R%VRLC  address  where  loop  return
                                   address is stored.

                         /FTYP  -- type of itervarb

                         /FLVAR -- R%VRLC location of itervarb

                         /FFLG  -- =1 for SUM, PROD,  MAX  and  MIN  =0
                                   otherwise

                         /FLNM  -- LRT record number for use in errors
          FDLV, FDTP, and FDND:  R%VRLC address, type,  and  number  of
          dimensions   of   dummy  SUM,  PROD,  MAX  or  MIN  variable,
          respectively.

          As part of runside  initialization  of  indirect  statements,
          RUNIZL  stores  the  address  of word 2 of the code into each
          /FRET location (except for SUM, PROD,  MAX  and  MIN).   This
          word contains the instruction JRST 0,0(1).

          When compilation is complete, an  error  will  be  given  for
          every  entry  remaining on the FORSTK.  /FLNM is used to give
          the line number of the FOR for this error message.
     TYMBASIC GID -- Runside Layout                             Page 79
     User-Defined Procedures


                            User-Defined Procedures

          Each procedure has an entry  point  (PEPT)  and  a  parameter
          vector  (PVEC).   PEPT  is the location (in the hiseg) of the
          procedure body, while PVEC is the location (in the loseg)  of
          a block which holds the data local to the procedure.  PEPT is
          kept in LRT/LCOD for the line of the DEF  of  the  procedure,
          while  PVEC  is  in  the  SDT/SLOC  field  of the name of the
          procedure.

          The first word of PVEC  holds  the  return  address  for  the
          procedure.  Successive groups of words hold the parameters in
          the order they appear in the DEF statement.   The  number  of
          words  allocated  to  each parameter depends upon the kind of
          parameter.  Numeric scalars are simply allocated the  one  or
          two words required to hold a scalar value of that type.  When
          the procedure is called, the value of the scalar argument  is
          stored into the allocated portion of the PVEC.

          For a string parameter, two words are allocated for a  string
          descriptor.   At  call  time, a block of storage is allocated
          into which the contents of the argument body is  moved.   The
          descriptor  is then set so that it points to this new body by
          doing:

                 /SDADR = address of allocated block

                 /SDCL  = /SDML = length of argument, in characters

          For an array parameter, two  items  are  allocated  in  PVEC.
          First,  a  single  word  is  used  to point to the descriptor
          currently being used for the parameter.  Following the  array
          pointer  word,  storage  is  reserved for a descriptor of the
          appropriate dimensionality.  the pointer word is mapped by:

               REC  APR,<<APLIF,18>,<APLOC,18>>

                    /APLIF -- NAM# or VAL#

                    /APLOC -- descriptor address

          When an array argument is passed by name, then /APLIF is  set
          to NAM# and /APLOC is set to the address of the descriptor of
          the argument array.  When an array is passed by value, then a
          block is allocated to hold a copy of the body, the descriptor
          in PVEC is set to describe that copy, /APLIF is set to  VAL#,
          and   /APLOC   is  set  to  point  to  the  PVEC  descriptor.
          References to an array  parameter  within  the  body  of  the
          procedure are always carried out indirectly through /APLOC.
     TYMBASIC GID -- Runside Layout                             Page 80
     User-Defined Procedures


          One word is reserved in PVEC to hold the call time  value  of
          register  R16  (RXO);   EXIT  is  thus  able  to  restore the
          environment of  the  calling  statement.   When  an  EXIT  is
          performed,  local  parameter bodies are de-allocated:  string
          parameter bodies are released and /SDADR is set to zero.  For
          array  parameters  with /APLIF = NAM#, /APLIF is set to VAL#,
          and /APLOC is pointed to the PVEC descriptor.  When /APLIF  =
          VAL#,  then  the body is released and /ADLN and /ADHN are set
          to zero.

          It is possible that control may leave a procedure by a  GO TO
          rather   than  an  EXIT  and  that  the  procedure  would  be
          subsequently called.  For this reason, special care  must  be
          taken  at  the time a procedure is called.  In particular, if
          any of the string or  array  parameters  hold  local  values,
          these  must  be  released  prior  to  setting PVEC to the new
          arguments.

          When a string or matrix expression is passed as an  argument,
          note  that  the  body  need not be physically copied to a new
          block.  Such an expression is always an RAC entry with RACLIF
          =  VAL#,  and can be passed simply by storing RACLOC into the
          PVEC.

          For those procedures which have string or array parameters, a
          location PXPT (EXIT point) is defined.  PXPT heads a sequence
          of code which releases storage allocated to local parameters.
          This code is generated as part of the first EXIT compiled for
          a given procedure, and is used by subsequent EXITs.

          When the string being returned is a user variable (global  or
          local), the body must be copied.

          The  above  policies   governing   procedure   linkages   are
          implemented partly in pure generated code and partly by means
          of runtime routines called from the code.  The routines  used
          are  RACAMX,  RACASA,  RACASS,  RXPSS  and  RXPMX.  After the
          arguments have been passed, the procedure is called by

               JSP   RXJ#,PEPT

          For string and array procedures, the JSP is  followed  by  an
          address  of  where  we want the return value put.  Hence, the
          first word of the procedure is

               PEPT   MOVEM RXJ#,PVEC
     TYMBASIC GID -- Runside Layout                             Page 81
     User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)


       User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)

          TBA features a sophisticated IO system:   more  than  one  IO
          statement  can  be  simultaneously active;  errors and end of
          file can be independently trapped for each file;  IO  may  be
          performed  by user-supplied routines independently of the TBA
          IO system;  license can be set and  manipulated  within  TBA;
          random  access  is  supported  on a character, word or record
          basis.

          The user may designate (in an OPEN or ON condition statement)
          any (unique per file) integer from 0 to 20 as a file number.

          The array FNT[0:20], initially all 0, is set to  the  address
          of  a  dynamically  allocated file control block (FCB) when a
          file number is first referenced in an OPEN  or  ON  condition
          statement.   If an INPUT or PRINT statement references an FNT
          entry which is zero, the condition is diagnosed.

          An FCB contains the following kinds of information:

                1.  whether file is open or closed

                2.  file nomen

                3.  count of elements left in current buffer

                4.  file size

                5.  mode in which file was opened

                6.  current cursor position

                7.  location and number of allocated buffers

                8.  channel number assigned to file

                9.  error  number  of  most  recent   error   condition
                    occurring on this file

               10.  a byte pointer within  current  buffer  to  element
                    just processed

          Whenever a file is closed the FCB will be  released  and  the
          FNT entry reset to 0.

          During the life of the IO statement, the  IOCB  contains  all
          status  information required for the operation of the element
          processing routines (cf.  above).  In  essence,  the  element
          processing  routines  are  designed to be serially re-entrant
     TYMBASIC GID -- Runside Layout                             Page 82
     User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)


          with non-temporary local variables indexed off  of  the  IOCB
          address.  Some of the information in the IOCB is:

               1 the file number (providing a link to the FCB)

               2 the displacement off DSAORG of a dynamically allocated
                    block holding the FORM or IMAGE (if any)

               3 the current scan point within the FORM or IMAGE

          Note the possibility that  in  between  successive  calls  to
          element  processing  routines  for  a given IO statement, the
          file  involved  could  be  closed  or   otherwise   seriously
          affected.

          Therefore whenever an element processing routine  is  called,
          it  first  validates  the  consistency of the operation being
          requested with the current status of the associated  FNT  and
          FCB   structures.    For  efficiency,  the  significant  data
          (symbolic vs binary,  input  vs  output,  formatted  vs  free
          format,  etc.)  are packed into a single word in the IOCB and
          the FCB.  Thus a single logical mask and test can be used  to
          validate the file/operation consistency.

          When a file is opened, the monitor is asked to supply a  free
          channel  number  to  be used and placed in the FCB.  Thus TBA
          will  avoid  using  a  channel  already  being  used   by   a
          user-supplied  routine.   Similarly  a  user-supplied routine
          should not expect pre-assembled channel assignments.
     TYMBASIC GID -- Runside Routines                           Page 83


                                RUNSIDE ROUTINES

     RSLEN  -- LENGTH(string S)

          in
               r2  -- S
               r5  -- string code

          out
               r1  -- integer LENGTH(S)


     RSBLK  -- blank string

          input
               r1  -- requested length may be zero
               r4  -- address of result

          do
               return a string of (r1) blanks


     RSVL1  -- string value

          input
               r2  -- string
               r5  -- string code

          output
               r1  -- Real

          do
               convert the string to a numeric value in free format


     RSST1  -- STR(X)

          in
               AC -- X
               r5 -- type
               r4  -- address of result

          output
               STR(X)


     TYMBASIC GID -- Runside Routines                           Page 84


     RSLFT  -- left substring

          input
               r1  - number of characters
               r2  -- string
               r5  -- string code
               r4  -- address of result

          do
               return the left (r1)characters of the string


     RSRGT  -- right substring

          input
               r1  -- number of characters
               r2  -- string
               r4  -- address of result
               r5  -- string code

          do
               return the right (r1)characters of the string


     RSBN2  -- SUBSTR(S,N)

          input
               r1  -- N (integer)
               r2  -- S (string)
               r4  -- address of result
               r5  -- string code

          output
               substring


     RNDX2 -- INDEX (S1,S2)

          input
               r1 -- s1
               r2 -- s2
               r5 -- string code

          output
               r1 -- integer


     TYMBASIC GID -- Runside Routines                           Page 85


     RSCAT  -- (s1+s2) -- string concat

          input (one argument may be in RAC)
               r1  -- s1
               r2  -- s2
               r4  -- address of result
               r5  -- string code

          output
               s1 +s2


     RSAS1  -- ASC(S)

          input
               r2 -- s
               r5  -- string code

          output
               r1  -- ASC(S,5) integer


     RCHAR  -- CHAR(N)

          input
               r1  -- integer
               r4  -- address of result

          output
               CHAR(N)

     .CPAD  -- CPAD(S,N)

               input
                    r1 -- integer N
                    r2 -- string S
                    r5 -- string code
                    r4 -- address of result

               output
                     CPAD(S,N)


     TYMBASIC GID -- Runside Routines                           Page 86


     RSLPD  -- LPAD(S,N)

          input
               r1 -- integer N
               r2  -- string S
               r5  -- string code
               r4  -- address of result

          output
               LPAD(S,N)


     RSRPD  -- RPAD(s,N)

          input
               r1 -- int N
               r2 -- str S
               r5 -- string code
               r4  -- address of result

          output
               RPAD(S,N)


     RSRPT  -- RPT(S,N)

          input
               r1 -- integer N
               r2 -- string S
               r5 -- string code
               r4 -- address of result

          output
               RPT(S,N)


     RSRJT  -- RJUST(S)

          input
               r2 -- str S
               r5 -- string code
               r4 -- address of result

          output
               RJUST(S)


     TYMBASIC GID -- Runside Routines                           Page 87


     RSLJT  -- LJUST(S)

          in
               r2 -- str S
               r5 -- string code
               r4 -- address of result

          out
               LJUST(S)


     RSCNT  -- COUNT(s1,s2)

          in
               r1 -- s1 (string)
               r2 -- s2 (string)
               r5 -- string code

          do
               calculate COUNT (s1,s2)


     RSVL2

          input
               r1 -- s1
               r2 -- s2
               r5 -- string code

          output
               r1 -- real

          do
               VAL(s1,s2)


     RSST2  -- STR(X,S)

          in
               r0,r1 -- X
               r2 -- S
               r3 -- type
               r5 -- string code
               r4 -- address of result

          out
               STR(X,S)


     TYMBASIC GID -- Runside Routines                           Page 88


     RSBNL  -- substr(s,N1,N2)

          input
               r1 -- N1 (integer)
               r2 -- S(string)
               r3 -- N2 (integer)
               r5 -- string code
               r4 -- address of result

          output
               substr (s,N1,N2)

          do
               perform SUBSTR operation


     RNDX3  -- INDEX(s1,s2,N)

     input
               r1 -- s1
               r2 -- s2
               r3 -- N
               r5 -- string code
               r4 -- address of result

          output
               r1 -- integer


     RSASC  -- ASC(S,N)

          in
               r1 -- N
               r2 -- S
               r5 -- string code

          out
               r1 -- ASC(S,N), integer


     RTAB1 -- TAB(1 arg)

          input
               r1 -- integer
               r4 -- address of result

          output
               string of spaces


     TYMBASIC GID -- Runside Routines                           Page 89


     RLOC -- LOC

          input
               r1 -- integer

          output
               r1 -- integer


     RSIZ -- SIZE

          input
               r1 -- integer

          output
               r1 -- integer


     RRMSG -- ERRMSG

          input
               r1 -- integer
               r4 -- address of result

          output
               string


     RTAB2 -- TAB(2 args)

          input
               r1,r3 -- integers
               r4 -- address of result

          output
               string


     RPOS  -- POS(1arg)

          input
               r1 -- integer

          output
               r1 -- integer


     TYMBASIC GID -- Runside Routines                           Page 90


     .RNDA  -- RND(X)

          input
                    >0 => initial value
               r1:  =0 => RND()
                    <0 => use clock to obtain initial value

          output
               r1 -- RND(X)


     RSCMP  -- COMP(s1,s2)

          input
               r1 -- s1
               r2 -- s2
               r5 -- string code

          output
               r1 -- COMP(s1,s2) = (-1,0,1)

          do
               return logical value in r1,  corresponding  to  sign  of
               source 1 - source 2


     RSMAX  -- max(s1,s2)

          input
               r1 -- s1 (string)
               r2 -- s2 (string)
               r4 -- address of result
               r5 -- string code

          output
               max(s1,s2)


     RSMIN  -- min(s1,s2)

          input
               r1 -- s1 (string)
               r2 -- s2 (string)
               r5 -- string code
               r4 -- address of result

          output
               min(s1,s2)


     TYMBASIC GID -- Runside Routines                           Page 91


     RSTRLE  -- String comparison less than or equal

               input
                    r1 -- string 1
                    r2 -- string 2
                    r5 -- string code

               output
                    r1 -- result, logical valued


     RSTRGE  -- String comparison greater than or equal

               input
                    r1 -- string 1
                    r2 -- string 2
                    r5 -- string code

               output


                    r1 -- result, logical valued


     RSTRG   -- String comparison greater than

               input
                    r1 -- string 1
                    r2 -- string 2
                    r5 -- string code

               output
                    r1 -- result, logical valued


     RSTRL   -- String comparison less than

               input
                    r1 -- string 1
                    r2 -- string 2
                    r5 -- string code

               output
                    r1 -- result, logical valued


     TYMBASIC GID -- Runside Routines                           Page 92


     RSTRE   -- String comparison equal to

               input
                    r1 -- string 1
                    r2 -- string 2
                    r5 -- string code

               output
                    r1 -- result, logical valued


     RSTRNE  -- String comparison not equal to

               input
                    r1 -- string 1
                    r2 -- string 2
                    r5 -- string code

               output
                    r1 -- result, logical valued


     .CDIV  -- complex division

          input
               r1,r2 -- operand 1
               r3,r4 -- operand 2

          output
               r1,r2 -- quotient


     .CMUL  -- complex multiplication

          input
               r1,r2 -- operand 1
               r3,r4 -- operand 2

          output
               r1,r2 -- product


     .POLR  -- POLAR(radius,theta)

          input
               r1,r2 -- radius(double)
               r3,r4 -- theta(double)

          output
               r1,r2 -- POLAR(radius,theta)(complex)
     TYMBASIC GID -- Runside Routines                           Page 93


     RSROP  -- special relational operator

          input
               r5 -- LH:  type of operands
                     RH:  operator:  << is 17, >> is 16, =# is 18
               AC -- value1
               AC2 -- value2

          output
               r1 -- logical result

          do
               evaluate (value1) operator (value2) and leave 0 or 1  in
               r1


     RXDAT  -- (DATE)

          input
               r4 -- address of result

          output type
               string


     RXTIM  -- (TIME)

          input
               r4 -- address of result

          output type
               string


     RXTRM  -- (TERM)

          input
               none

          output type
               logical


     RIASC  -- (IXASC)

          input
               r4 -- address of result

          output
               integer array, 1 dim
     TYMBASIC GID -- Runside Routines                           Page 94


     RICHR  -- (IXCHAR)

          input
               r4 -- address of result

          output
               string array, 1 dim


     RXASC  -- (XASC)

          input
               r4 -- address of result

          output
               integer array, 1 dim


     RXCHR  -- (XCHAR)

          input
               r4 -- address of result

          output
               string array, 1 dim


     RTCP  -- (TCP)

          input
               none

          output type
               logical


     RDET  -- (DET)

          input
               none

          output type
               double


     TYMBASIC GID -- Runside Routines                           Page 95


     RXYR  -- (YEAR)

          input
               r4 -- address of result

          output type
               string


     RRCD  -- (ERRCD)

          input
               none

          output type
               integer


     RRLN  -- (ERRLN)

          input
               none

          output type
               integer


     RRFL  -- (ERRFL)

          input
               none

          output type
               integer


     RTRU  -- (TRU)

          input
               none

          output type
               real


     TYMBASIC GID -- Runside Routines                           Page 96


     RPOST  -- (POS with no arguments)

          input
               none

          output type
               integer


     RMINV  -- invert matrix

          input
               r0 -- array code
               r3 -- array
               r4 -- address of result

          do
               invert a real or double 2-dim matrix

          error
               matrix not square
               matrix singular


     RMTRN  -- transpose

          input
               r0 -- array code
               r3 -- array
               r4 -- address of result

          do
               transpose 2-dim non-string matrix, same type


     RMPWR  -- matrix exponentiation

          input
               r0 -- array code
               r1 -- integer
               r2 -- array
               r3 -- address of result


     TYMBASIC GID -- Runside Routines                           Page 97


     RSACT  -- string scalar + string array

          input
               r0 -- array code
               r2 -- string
               r3 -- array
               r4 -- address of result
               r5 -- string code or string code +4 if  scalar  precedes
               array


     RMSOP  -- Array-Scalar operations

          input
               r0 -- array code
               r1(,r2) -- scalar
               r3 -- address of input array descriptor
               r4 -- address of result array descriptor
               r5 -- operation number
                     22 +   23 -   24 DIV   26 /   27 *   28 MOD
                     add 9 to operation number if scalar is on left
                     and not commutative
               r6 -- type of array (we will convert array to this  type
               if necessary)

          do
               result array = input array op scalar


     REEOPS  -- element-by-element array operation

          input
               r0 -- array code
               r1 -- OPID=22, 23, 24, 26, 27, or 28
               If OPID = 24, the compiler  checks  to  make  sure  both
               arrays have integer type.
               r2 -- first array
               r3 -- second array
               r4 -- address of result


     RAINT  -- array intersection

          input
               r0 -- array code
               r2,r3 -- the arrays
               the compiler does no checking.
               r4 -- address of result


     TYMBASIC GID -- Runside Routines                           Page 98


     RAMUL  -- matrix multiplication

          input
               r0 -- array code
               r2,r3 -- arrays
               r4 -- address of result


     REPWR  -- element-by-element exponentiation

          input
               r0 -- array code
               r1(,r2) -- scalar
               r3 -- array
               r4 -- address of result
               r5 -- type of scalar, or type + 10 if scalar on left


     RNEGA  -- negate a matrix

          input
               r3 -- matrix to be negated
               r0 -- array code
               r4 -- address of result


     RACMMX  -- move matrix

          input
               r0 -- array code
               r2 -- source
               r3 -- dest (must be NAM)
               Physically move body


     RACXMX  -- exchange matrices

          input
               r0 -- array code
               r2,r3 -- the arrays
               exchange values of source 1, source 2


          note:
               bodies need not be moved;  RACLIF = NAM# !


     TYMBASIC GID -- Runside Routines                           Page 99


     RACXS  -- exchange scalar string or string array element

          input
               r1 -- source 1 (must be NAM#)
               r2 -- source 2 (must be NAM#)
               r5 -- string code

          do
               exchange values of source 1, source 2


     RAIDN  -- IDN without arguments

          input
               r3 -- address of destination (must be user variable)


     RACMS  -- move scalar string or string array element

          input
               r1 -- source
               r2 -- dest (must be NAM#)
               r5 -- string code


     RPWR  -- evaluate X**Y

          input
               r5:  LH -- type of X
                    RH -- type of Y   (RH<=LH)
               r1 -- X
               r3 -- Y

          output
               AC -- X**Y


     .RIPWR  -- real to an integer power

               input
                    r1 -- base (real)
                    r3 -- power (integer)

               output
                    r1 -- base**power (real)


     TYMBASIC GID -- Runside Routines                          Page 100


     .RRPWR  == real to a real power

               input
                    r1 -- base (real)
                    r3 -- power (real)

               output
                    r1 -- base**power (real)


     .DIPWR  -- double to an integer power

               input
                    r1,r2 -- base (double)
                    r3 -- power (integer)

               output
                    r1,r2 -- base**power (double)


     .DDPWR  -- double to a double power

               input
                    r1,r2 -- base (double)
                    r3,r4 -- power (double)

               output
                    r1,r2 -- base**power (double)




     .CIPWR  -- complex to an integer power

               input
                    r1,r2 -- base (complex)
                    r3    -- power (integer)

               output
                    r1,r2 -- base**power (complex)


     .CCPWR  -- complex to a complex power

               input
                    r1,r2 -- base (complex)
                    r3,r4 -- power (complex)

                    r1,r2 -- base**power (complex)
     TYMBASIC GID -- Runside Routines                          Page 101


     RXAMX  -- matrix procedure argument

          input
               r0 -- array code for argument
               r2 -- address of pointer to parameter descriptor
               r3 -- argument

          do
               de-allocate any old param value;  pt param to arg;
               fail to move body


     RXAS   -- scalar string or  string  array  element  procedure  and
               argument

          input
               r1 -- param
               r2 -- arg
               r5 -- string code

          do
               de-allocate any old param value;  set param to refer  to
               argument


     RXPMX  -- de-allocate matrix param

          input
               r2 -- addr of pointer to param

          do
               de-allocate body (if any);
               set /APLOC to local vector;
               set /ADLN = /ADHN = 0
               Note:  This routine may not change r0 or r1.


     RXPSS  -- de-allocate string param

          input
               r2 -- addr of param

          do
               de-allocate body (if any);
               set /SDADR = 0

          Note:  This routine may not change r0 or r1.


     TYMBASIC GID -- Runside Routines                          Page 102


     RXRS -- return string

          input
               r2 -- addr of string
               r3 -- PVEC addr of descriptor
               r5 -- string code

          do
               return string.  If string is a user variable (global  or
               local), copy body Put descriptor in PVEC.


     RSIG -- set output significance

          input
               r1 -- number of significant digits (integer)
               error:  r1<1 or r1>17.

     RBND   -- set boundary

          input
               r1 -- boundary value (real)

          do
               set boundary
               error:  r1<0


     RCIB -- Clear terminal input buffer


     RCLOS -- close a file

          r1 -- file number

          error -- file not open


     RCOB -- Clear terminal output buffer




     RCOPY -- Copy file S1 onto S2.

          r1 -- s1

          r2 -- s2

          r5 -- string code
     TYMBASIC GID -- Runside Routines                          Page 103


     RERAS -- erase specified records on specified file

          r3 -- final record number

          r1 -- beginning record number

          r4 -- file number


     RFOLD  -- set terminal width

          input
               r1 -- terminal width

          do
               set terminal width to the number in r1


     RIOF  -- Set up the file and format  for  INPUT  or  PRINT.   FORM
               used.

          r1 -- record (if any)

          r3 -- file number (if any)

          r2 -- FORM string

          r5 -- string code

          FW1 -- INPFF or PRTFF+16


     RINPT  -- INPUT a variable

          input
               r1  -- R%VRLC address of the variable
               HW1 -- variable class (ONSC#, OSSC#, etc.)
               HW2 -- variable type


     RKLFMT -- Discard current IO format


     TYMBASIC GID -- Runside Routines                          Page 104


     RLOCAT -- locate specified record on the specified file

          r3 -- file number (-1 = command file)

          r1 -- record number

          error
               1.  file not open
               2.  file not random


     ROPEN -- execute OPEN statement

          r4 -- line number for error trap (if any)
          r3 -- file number (if any)
          r0 -- record length (if any)
          r2 -- file
          r5 -- string code
          FW1 -- Access mode
          r1 -- protection code (if any)


     RIOI  -- Set up the file and format for PRINT or INPUT.  FORM  not
               used.

          input -- same as for RIOF,  except  that  r2  contains  IMAGE
               string, if any, and r5 contains string code, if any.


     RPRTS  -- print spacing (ignored if formatted)

          input
               r3 -- spacing code 0-3 (see pmc Formats, OPTYPE = 41)

          do
               print spacing for unformatted symbolic output


     TYMBASIC GID -- Runside Routines                          Page 105


     RPRTV  -- print value

          input
               HW1 -- class and type
               HW2 -- spacing code

          value is passed in:
               AC -- if numeric scalar
               r2 -- if string with string code in r5
               r3 -- matrix

          do
               print value as specified to file,  terminal,  or  ENCODE
               array.    ignore   spacing  if  file  is  binary  or  if
               destination is ENCODE array


     RREAD -- READ a variable

          input
               r1  -- R%VRLC address of the variable
               HW1 -- variable class (ONSC#, OSSC#, etc.)
               HW2 -- variable type


     RRMOV -- Remove specified file

          r2 -- S1
          r5 -- string code


     RRNAM -- rename file S1 as S2.

          r1 -- s1

          r2 -- s2

          r5 -- string code


     RRSTR -- restore data block

          input
               none

          do
               reset the data block index to zero


     R8IN -- EIGHTI
     TYMBASIC GID -- Runside Routines                          Page 106


          r1 -- R%VRLC location of variable


     R8OUT -- EIGHTO

          r1 -- integer value


     RDXMX -- declare or redeclare array (matrix)

          input
               r1 -- addr of descriptor
               r2 -- declared length (if string)

          Dimensions bounds must already be  in  the  descriptor.   See
               ARRAYS.

          do
               allocate storage for the array;  set body to zero;  fill
               in descriptor;  set header words (of string elements)


     RDXSS  -- declare scalar string

          input
               r1 -- addr of descriptor
               r3 -- declared length

          do
               allocate body;  set it to zero;  set descriptor to  zero
               current length
               Note:  string may already have been  declared,  possibly
               with different declared length.


     RGOSUB -- GOSUB call

          input
               r2 -- line location.


     RGRET  -- Return from GOSUB call


     RHED -- Used to support BREAK and TRACE


     TYMBASIC GID -- Runside Routines                          Page 107


     RINTP  -- interrupt program

          input
                 H -- 0 = STOP
                      2 = END
                      4 = PAUSE
                      6 = QUIT
                      8 = LOGOUT

               (Add 1 to above values if expression  has  already  been
               printed.)

          do
               perform  indicated  interrupt  (see  TBA  spec,  pp  39,
               73-74);   printout  for  LOG  like  that for others plus
               logout info


     RNOCN -- set condition OFF

          input
               r3 -- if FILE or ENDFILE,filenumber
               r5 -- kind of condition
                    EOF#==0
                    ESC#==1
                    MTH#==2
                    TRN#==3
                    FIL#==4
                    DAT#==5
                    ERR#==6


     .SSIN  -- Single Precision Sine

               input
                    r1 -- operand

               output
                    r1 -- SIN(operand)


     .DSIN  -- Double Precision Sine

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- SIN(opernad)


     .SCOS  -- Single Precision Cosine
     TYMBASIC GID -- Runside Routines                          Page 108


               input
                    r1 -- operand

               output
                    r1 -- COS(operand)


     .CCOS  -- Complex Cosine

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- COS(operand)


     .CSIN  -- Complex Sine

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- SIN(operand)


     .STAN  -- Single Precision Tangent

               input
                    r1 -- operand

               output
                    r1 -- TAN(operand)


     .DTAN  -- Double Precision Tangent

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- TAN(operand)


     .CTAN  -- Complex Tangent

               input
                    r1,r1 -- opernad

               output
                    r1,r2 -- TAN(operand)
     TYMBASIC GID -- Runside Routines                          Page 109


     .CABS  -- Complex Absolute Value

               input
                    r1,r2 -- operand

               output
                    r1 -- /A+Bi/ = SQRT(A2 + B2)


     .SQRT  -- Square Root

               input
                    r1,(r2) -- operand
                    r3      -- type of operand

               output
                    r1,(r2) -- SQRT(operand)


     .CSQRT  -- Complex Square Root

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- SQRT(operand)


     .ASIN  -- Arcsine

          input
               r1,(r2) -- operand
               r3 -- operand type

          output
               r1,r2 -- ASIN(operand)


     .ACOS  -- Arccosine

          input
               r1,(r2) -- operand
               r3 -- operand type

          output
               r1,r2 -- ACOS(operand)


     .ATAN  -- Arctangent (single argument)

          input
     TYMBASIC GID -- Runside Routines                          Page 110


               r1,(r2) -- operand
               r3 -- operand type

          output
               r1,r2 -- ATAN(operand)


     .SINH  -- Hyperbolic Sine

          input
               r1,(r2) -- operand
               r3 -- operand type

          output
               r1,r2 -- SINH(operand)


     .COSH  -- Hyperbolic Cosine

          input
               r1,(r2) -- operand
               r3 -- operand type

          output
               r1,r2 -- COSH(operand)


     .TANH  -- Hyperbolic Tangent

          input
               r1,r2 -- operand
               r3 -- operand type

          output
               r1,r2 -- TANH(operand)


     RONCN  -- set condition ON

          input
               r1 -- branch address
               r3 -- if FILE or ENDFILE, filenumber
               r5 -- kind of condition
                    ESC#==0
                    ERR#==1
                    MTH#==2
                    TRN#==3
                    DAT#==4
                    EOF#==5
                    FIL#==6
     TYMBASIC GID -- Runside Routines                          Page 111


     .ATAN2  -- Arctangent (double argument)

          input
               r1,(r2) -- operand 1
               r3,(r4) -- operand 2
               r5 -- operand type (both operands have same type)

          output
               r1,r2 -- ATAN(operand 1)/(operand 2)


     .SEXP  -- Single Precision Exponentiation

               input
                    r1 -- opernad

               output
                    r1 -- EXP(operand)


     .DEXP  -- Double Precision Exponentiation

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- EXP(operand)


     .CEXP  -- Complex Exponentiation

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- EXP(operand)


     .SLOG  -- Single Precision Natural Log (Base e)

               input
                    r1 -- operand

               output
                    r1 -- LOG(operand)


     .DLOG  -- Double Precision Natural Log (Base e)

               input
                    r1,r2 -- operand
     TYMBASIC GID -- Runside Routines                          Page 112


               output
                    r1,r2 -- LOG(operand)


     .CLOG  -- Complex Natural Log (Base e)

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- LOG(operand)


     .SLGT  -- Single Precision Common Log (Base 10)

               input
                    r1 -- operand

               output
                    r1 -- LOG10(operand)


     .DLGT  -- Double Precision Common Log (Base 10)

               input
                    r1,r2 -- operand

               output
                    r1,r2 -- LOG10(operand)


     .CLGT  -- Complex Common Log (Base 10)

               input
                    r1,r2 -- opernad

               output
                    r1,r2 -- LOG10(operand)


     RRSUM  -- executes RESUME statement


     .SFIX  -- single precision FIX

               input
                    r1 -- arg (real)

               output
                    r1 -- FIX(arg) (real)
     TYMBASIC GID -- Runside Routines                          Page 113


     .DFIX  -- double FIX

               input
                    r1,r2 -- arg (double)

               output
                    r1,r2 -- FIX(arg) (double)


     .SROUN  -- single ROUND

               input
                    r1 -- arg (real)

               output
                    r1 -- ROUND(arg)


     .SIP  -- single precision IP (integer part)

               input
                    r1 -- arg (real)

               output
                    r1 -- IP(arg) (real)


     .SFP  -- single precision FP (floating part)

               input
                    r1 -- arg (real)

               output
                    r1 -- FP(arg) (real)


     .DROUN  -- double ROUND

               input
                    r1,r2 -- arg (double)

               output
                    r1,r2 -- ROUND(arg) (double)


     .DIP  -- double IP

               input
                    r1,r2 -- arg (double)

               output
     TYMBASIC GID -- Runside Routines                          Page 114


                    r1,r2 -- IP(arg) (double)


     .DFP  -- double FP

               input
                    r1,r2 -- arg (double)

               output
                    r1,r2 -- FP(arg) (double)


     .SINT  -- single precision INT

               input
                    r1 -- arg (real)

               output
                    r1 -- INT(arg) (integer)


     .DINT  -- double INT

               input
                    r1,r2 -- arg (double)

               output
                    r1 -- INT(arg) (integer)


     RWAIT  -- wait

          input
               r1 -- WAIN

          do
               wait WAIN seconds


     RGSLC  -- Create array slice

          input
               r3 -- descriptor address of N-dimensional parent array
               PR[0:N-1] -- dimension specifications for dimensions
               0 through N-1 of the parent array (N greater than 2)

               r1 -- dimension specification for dimension 0 (N=1 or 2)

               r2 -- dimension specification for dimension 1 (N=2)

               FW1 -- dimension map
     TYMBASIC GID -- Runside Routines                          Page 115


          output
               array slice

                         Note:  if only one subscript is specified  for
               a  given  dimension,  the  dimension  specification will
               simply  be  that  subscript.   If  two  subscripts   are
               specified,  the  lower (upper) bound will be in the left
               (right) halfword of the  dimension  specification.   The
               bit  in the 2**J place of the dimension map will be 0 if
               only one subscript is specified for dimension J,  and  1
               if 2 subscripts are specified.
     TYMBASIC GID -- Runside Routines                          Page 116
     Bibliography


                                  BIBLIOGRAPHY


     EXTERNAL SPECIFICATION

     *  Tymbasic language  external  reference  specification  (updated
     January 1975 and May 1975)

     *  Tymshare Super Basic reference manual

     *  Differences between Super Basic and Tymbasic




     INTERNAL DESIGN

     *  Tymbasic general internal design

     *  Tymbasic   task   descriptions   (maintained   in   the    file
     (TBA4:17)PEBBLE)

     *  Tymbasic   project   schedule   (maintained   in    the    file
     (TBA4:17)CHART)

     *  Programming standards and procedures--Tymbasic project

     *  A few words about paging

     *  Memo on test programs




     INTERFACES

     *  Tymcom X monitor version PO.2 information

     *  Quick reference for Tymcom X monitor calls

     *  Reference manual for KI10  software  interrupt  system  on  the
     Tymcom X

     *  Terminal interface standards for Tymbasic

     *  Specification for intraline editing for Tymbasic

     *  Specification for file name syntax and semantics for Tymbasic

     *  Files (symbolic file format)
     TYMBASIC GID -- Runside Routines                          Page 117
     Bibliography


     *  The care and feeding of CREF




     MANUALS

     *  DEC system 10 assembly language handbook

     *  DEC system 10 system reference manual

     *  Tymshare Editor -- instant series

     *  Tymshare Editor -- reference series

     *  Addendum to editor -- January 1972

     *  Tymshare Executive -- reference series

     *  Tymshare XEXEC manual 

     *  FET -- a file editing tool

     *  Tymcom X user program index

     *  Tymex

     *  Tymcom X file creation and modification

     *  Runoff

     *  The beginner's guide
     TYMBASIC GID                                              Page 118
     INDEX


          .ACOS  . . . . . . . . . . . . 109
          .ASIN  . . . . . . . . . . . . 109
          .ATAN  . . . . . . . . . . . . 109
          .ATAN2 . . . . . . . . . . . . 111
          .CABS  . . . . . . . . . . . . 109
          .CCOS  . . . . . . . . . . . . 108
          .CCPWR . . . . . . . . . . . . 100
          .CDIV  . . . . . . . . . . . . 92
          .CEXP  . . . . . . . . . . . . 111
          .CIPWR . . . . . . . . . . . . 100
          .CLGT  . . . . . . . . . . . . 112
          .CLOG  . . . . . . . . . . . . 112
          .CMUL  . . . . . . . . . . . . 92
          .COSH  . . . . . . . . . . . . 110
          .CPAD  . . . . . . . . . . . . 85
          .CSIN  . . . . . . . . . . . . 108
          .CSQRT . . . . . . . . . . . . 109
          .CTAN  . . . . . . . . . . . . 108
          .DDPWR . . . . . . . . . . . . 100
          .DEXP  . . . . . . . . . . . . 111
          .DFIX  . . . . . . . . . . . . 113
          .DFP . . . . . . . . . . . . . 114
          .DINT  . . . . . . . . . . . . 114
          .DIP . . . . . . . . . . . . . 113
          .DIPWR . . . . . . . . . . . . 100
          .DLGT  . . . . . . . . . . . . 112
          .DLOG  . . . . . . . . . . . . 111
          .DROUN . . . . . . . . . . . . 113
          .DSIN  . . . . . . . . . . . . 107
          .DTAN  . . . . . . . . . . . . 108
          .POLR  . . . . . . . . . . . . 92
          .RIPWR . . . . . . . . . . . . 99
          .RNDA  . . . . . . . . . . . . 90
          .RRPWR . . . . . . . . . . . . 100
          .SCOS  . . . . . . . . . . . . 107
          .SEXP  . . . . . . . . . . . . 111
          .SFIX  . . . . . . . . . . . . 112
          .SFP . . . . . . . . . . . . . 113
          .SINH  . . . . . . . . . . . . 110
          .SINT  . . . . . . . . . . . . 114
          .SIP . . . . . . . . . . . . . 113
          .SLGT  . . . . . . . . . . . . 112
          .SLOG  . . . . . . . . . . . . 111
          .SQRT  . . . . . . . . . . . . 109
          .SROUN . . . . . . . . . . . . 113
          .SSIN  . . . . . . . . . . . . 107
          .STAN  . . . . . . . . . . . . 108
          .TANH  . . . . . . . . . . . . 110

          =# . . . . . . . . . . . . . . 93
          @ (Array Intersections)  . . . 97

          ABASE  . . . . . . . . . . . . 69
          ABS  . . . . . . . . . . . . . 109
          ABSZ . . . . . . . . . . . . . 69
          ACOEFn . . . . . . . . . . . . 69
          ACOS . . . . . . . . . . . . . 109
          ADHN . . . . . . . . . . . . . 80
          ADLN . . . . . . . . . . . . . 80
          ADSR . . . . . . . . . . . . . 69
          ALBn . . . . . . . . . . . . . 69
          ALOC . . . . . . . . . . . . . 69
          Ampersand  . . . . . . . . . . 54
          ANDIM  . . . . . . . . . . . . 69
          APLIF  . . . . . . . . . . . . 79
          APLOC  . . . . . . . . . . . . 79
          APR  . . . . . . . . . . . . . 79
          Array Bodies . . . . . . . . . 69
          Array Code . . . . . . . . . . 76
          Array Declaration  . . . . . . 106
          Array Descriptors  . . . . . . 69, 79
          Array Dimensions . . . . . . . 65
          Array Elements . . . . . . . . 64-65
          Array Exchange . . . . . . . . 98
          Array Exponentiation . . . . . 96
          Array Exponentiation, Element by Element  98
          Array Intersections  . . . . . 97
          Array Inversion  . . . . . . . 96
          Array Multiplication . . . . . 98
          Array Negation . . . . . . . . 98
          Array Operations, Element by Element  97
          Array Parameter Deallocation . 101
          Array Parameter, to Procedure  101
          Array Parameter, User-Defined Procedures  79
          Array Parameters . . . . . . . 65, 80
          Array Parameters, Call by Value  79
          Array Slicing  . . . . . . . . 72, 114
          Array, Scalar Multiplication . 97
          Arrays . . . . . . . . . . . . 69
          ASC  . . . . . . . . . . . . . 85, 88
          ASIN . . . . . . . . . . . . . 109
          ATAG . . . . . . . . . . . . . 69
          ATAN . . . . . . . . . . . . . 109, 111
          ATYP . . . . . . . . . . . . . 69
          AUBn . . . . . . . . . . . . . 69

          Bit 35 . . . . . . . . . . . . 54
          BKL1 . . . . . . . . . . . . . 27
          BKL2 . . . . . . . . . . . . . 27
          Blank String . . . . . . . . . 83
          Boundary, Set  . . . . . . . . 102
          BREAK  . . . . . . . . . . . . 73, 106
          Break Structures (BRKT, BRKTR, BRKN, BRKLX)  27
          BRKLX  . . . . . . . . . . . . 27
          BRKN . . . . . . . . . . . . . 27, 73
          BRKT . . . . . . . . . . . . . 27
          BRKTR  . . . . . . . . . . . . 27
          BTFG . . . . . . . . . . . . . 73
          Byte Cursor  . . . . . . . . . 42
          Byte-Oriented IO . . . . . . . 49

          CADR . . . . . . . . . . . . . 69
          CALL . . . . . . . . . . . . . 73
          CBGL . . . . . . . . . . . . . 68
          CCFG . . . . . . . . . . . . . 2, 4
          CDE  . . . . . . . . . . . . . 5, 40
          CDEID  . . . . . . . . . . . . 4
          CDELN1 . . . . . . . . . . . . 4
          CDELN1.  . . . . . . . . . . . 4
          CDELN2 . . . . . . . . . . . . 4
          CFXL . . . . . . . . . . . . . 68
          Channel Numbers  . . . . . . . 81
          Channel Table  . . . . . . . . 43
          CHAR . . . . . . . . . . . . . 85
          CIB  . . . . . . . . . . . . . 102
          CLEAR  . . . . . . . . . . . . 5
          Clear Output Buffer  . . . . . 102
          Clear Terminal Input Buffer  . 102
          CLNM . . . . . . . . . . . . . 68
          Close File . . . . . . . . . . 102
          CLOSEF . . . . . . . . . . . . 45
          CLRFLG . . . . . . . . . . . . 1-4
          CMODF  . . . . . . . . . . . . 68
          CMPLX  . . . . . . . . . . . . 34, 64
          CNDTT  . . . . . . . . . . . . 12
          COB  . . . . . . . . . . . . . 102
          Code Generation (COMPIL, Optimization, Direct Statements)  61
          Command Echo Destination . . . 37
          Command Files  . . . . . . . . 38
          Command Files, closing . . . . 38
          Command Input  . . . . . . . . 37
          COMP . . . . . . . . . . . . . 90
          COMPIL . . . . . . . . . . . . 2, 4-6, 10, 13, 19-20, 22-23,
                                         25-26, 32, 56-57, 59, 61, 65,
                                         67
          Complex Division . . . . . . . 92
          Complex Multiplication . . . . 92
          Complex scalars  . . . . . . . 34
          Concatenation, String  . . . . 85
          Condition Trap Table (CNDTT) . 12
          Condition traps  . . . . . . . 12
          Conditional Processing . . . . 73
          Conditionals, Compilation of . 68
          CONOPN . . . . . . . . . . . . 41, 45
          Constants  . . . . . . . . . . 61, 64
          Continue point . . . . . . . . 1
          Control Stack (CSTK, CSTKP)  . 68
          Conversion, Numeric to String  83, 85, 87
          Conversion, String to Numeric  83, 85, 87-88
          COPTX  . . . . . . . . . . . . 22
          COPTY  . . . . . . . . . . . . 22
          COPY . . . . . . . . . . . . . 102
          Core Table . . . . . . . . . . 41, 43
          COS  . . . . . . . . . . . . . 108
          COSH . . . . . . . . . . . . . 110
          COUNT  . . . . . . . . . . . . 87
          CPAD . . . . . . . . . . . . . 85
          CPLX . . . . . . . . . . . . . 34, 64
          CREATE . . . . . . . . . . . . 41, 44-45
          CROSS  . . . . . . . . . . . . 55
          CSTK . . . . . . . . . . . . . 68
          CSTKP  . . . . . . . . . . . . 68
          CSTKR  . . . . . . . . . . . . 68
          Current workspace  . . . . . . 1
          CX . . . . . . . . . . . . . . 37-38
          CXCI . . . . . . . . . . . . . 37-38
          CXEP . . . . . . . . . . . . . 37
          CXER . . . . . . . . . . . . . 38, 56
          CXFN . . . . . . . . . . . . . 37
          CXKX . . . . . . . . . . . . . 37-38
          CXLN . . . . . . . . . . . . . 37
          CXLNUM . . . . . . . . . . . . 1-2
          CXMO . . . . . . . . . . . . . 39
          CXNM . . . . . . . . . . . . . 37
          CXNMS  . . . . . . . . . . . . 37
          CXR  . . . . . . . . . . . . . 37
          CXTDO  . . . . . . . . . . . . 40
          CXTI . . . . . . . . . . . . . 39
          CXTO . . . . . . . . . . . . . 40

          DATA Block Index, Reset  . . . 105
          DATA Statement . . . . . . . . 56, 60
          DATA Statement Values (DTAV) . 60
          Data Structure Management (TBL, DSA, Module Transitions, USWAP)  13
          Data structures  . . . . . . . 2
          Data-structure-mod . . . . . . 1
          DATE . . . . . . . . . . . . . 93
          DATV . . . . . . . . . . . . . 60
          DBL  . . . . . . . . . . . . . 34, 64
          DCFG . . . . . . . . . . . . . 2, 4
          Deallocation of Array Parameter  101
          Deallocation of String Parameter  101
          DEBGSW . . . . . . . . . . . . 32
          DEBMOD . . . . . . . . . . . . 14
          DEBUG  . . . . . . . . . . . . 70, 73, 106
          DEBUG/NO DEBUG . . . . . . . . 32
          DECLAR . . . . . . . . . . . . 2, 4-6, 13, 19-20, 22-23, 25,
                                         55-57, 59-60
          Declaration of Array . . . . . 106
          Declaration of String  . . . . 106
          Declaration Processing (DECLAR)  56
          DECLSW . . . . . . . . . . . . 3
          DEF  . . . . . . . . . . . . . 73, 79
          Default Extension  . . . . . . 44-45
          DET  . . . . . . . . . . . . . 94
          DFP  . . . . . . . . . . . . . 114
          Diagnostic Routines  . . . . . 73
          DIM  . . . . . . . . . . . . . 57, 106
          Direct statements  . . . . . . 30
          Direct Statement code  . . . . 6
          Direct Statements  . . . . . . 2, 4-8, 10-11, 19, 25-26, 61,
                                         64, 106
          Division, Complex  . . . . . . 92
          DO . . . . . . . . . . . . . . 13
          Double precision scalars . . . 34
          DSA  . . . . . . . . . . . . . 6, 13
          DSAORG . . . . . . . . . . . . 82
          DSMDFG . . . . . . . . . . . . 1, 3
          DSTH . . . . . . . . . . . . . 19-20
          DTAV . . . . . . . . . . . . . 56
          DUMP REFS and Tempcor Files  . 55
          Dynamic storage  . . . . . . . 6

          ECHO . . . . . . . . . . . . . 37
          Echo state . . . . . . . . . . 38
          EIGHTI . . . . . . . . . . . . 105
          EIGHTO . . . . . . . . . . . . 106
          ELSE . . . . . . . . . . . . . 68
          END  . . . . . . . . . . . . . 107
          ERASE  . . . . . . . . . . . . 103
          ERRCD  . . . . . . . . . . . . 95
          ERRFL  . . . . . . . . . . . . 95
          ERRLN  . . . . . . . . . . . . 95
          ERRMSG . . . . . . . . . . . . 89
          Error Conditions in Command File  38
          Escapes  . . . . . . . . . . . 31
          Exchange Array . . . . . . . . 98
          Exchange String  . . . . . . . 99
          EXIT . . . . . . . . . . . . . 5, 74, 80
          EXIT point . . . . . . . . . . 80
          EXLOC  . . . . . . . . . . . . 31
          EXN  . . . . . . . . . . . . . 31
          EXOFF  . . . . . . . . . . . . 31
          EXON . . . . . . . . . . . . . 31
          EXP  . . . . . . . . . . . . . 111
          EXPEEK . . . . . . . . . . . . 31
          Exponentiation . . . . . . . . 99
          EXRXP  . . . . . . . . . . . . 31
          EXSX . . . . . . . . . . . . . 31
          EXSXR  . . . . . . . . . . . . 31

          FCB  . . . . . . . . . . . . . 51, 81
          FFLG . . . . . . . . . . . . . 78
          FFXP . . . . . . . . . . . . . 78
          File Closing . . . . . . . . . 102
          File Control Blocks  . . . . . 41, 43, 81
          File Copy  . . . . . . . . . . 102
          File IO  . . . . . . . . . . . 41
          File Open  . . . . . . . . . . 104
          File Setup for Formatted Input  103
          File Setup for Formatted Print  104
          FIX  . . . . . . . . . . . . . 112
          FLVAR  . . . . . . . . . . . . 78
          FNT  . . . . . . . . . . . . . 81
          FOR  . . . . . . . . . . . . . 25, 56
          FOR Loop Generation (FORSTK, FORP, FORTYP, FORBX)  78
          FOR Loops  . . . . . . . . . . 30, 77
          FOR loops  . . . . . . . . . . 19
          FORBX  . . . . . . . . . . . . 78
          Form Feeds . . . . . . . . . . 54
          Format, Discard  . . . . . . . 103
          Formatted Input  . . . . . . . 103
          FORP . . . . . . . . . . . . . 78
          FORSR  . . . . . . . . . . . . 78
          FORSTK . . . . . . . . . . . . 78
          FORTYP . . . . . . . . . . . . 78
          FREE . . . . . . . . . . . . . 42, 47
          FREECR . . . . . . . . . . . . 42, 49
          FRET . . . . . . . . . . . . . 77-78
          FSTH . . . . . . . . . . . . . 19-20
          FTBL . . . . . . . . . . . . . 13, 37, 68
          FTYP . . . . . . . . . . . . . 78
          Function Calls . . . . . . . . 67
          FVAR . . . . . . . . . . . . . 78

          Garbage Collection . . . . . . 20
          GET  . . . . . . . . . . . . . 20, 54
          GET-File Formats . . . . . . . 54
          GETLIN . . . . . . . . . . . . 38
          GO . . . . . . . . . . . . . . 5, 7, 80
          GOSUB  . . . . . . . . . . . . 30, 73-75, 106
          GOSUB Processing (RGOSUB, RGRET, GSBSTK)  75
          GOSUB RETURN . . . . . . . . . 106
          GSBSTK . . . . . . . . . . . . 75

          Hash Table, Paging Algorithm . 43
          HIPMCS . . . . . . . . . . . . 23
          HPGMP  . . . . . . . . . . . . 8
          HVX  . . . . . . . . . . . . . 24

          ID . . . . . . . . . . . . . . 57-59
          IDN  . . . . . . . . . . . . . 99
          IF . . . . . . . . . . . . . . 68
          Immediate instructions . . . . 61
          IN . . . . . . . . . . . . . . 47
          INCR . . . . . . . . . . . . . 49
          INDEX  . . . . . . . . . . . . 84, 88
          INIT . . . . . . . . . . . . . 5
          INPFF  . . . . . . . . . . . . 103
          INPUT  . . . . . . . . . . . . 81
          Input of Variable  . . . . . . 103
          INT  . . . . . . . . . . . . . 114
          INT# . . . . . . . . . . . . . 34
          Integer scalars  . . . . . . . 34
          Interrupts . . . . . . . . . . 1, 31, 107
          INV  . . . . . . . . . . . . . 96
          Inversion, Matrix  . . . . . . 96
          IO . . . . . . . . . . . . . . 41
          IO Management, User  . . . . . 81
          IO Statements, Multiply Active  81
          IO, Byte-Oriented  . . . . . . 49
          IO, Word-Oriented  . . . . . . 47
          IOCB . . . . . . . . . . . . . 81
          IOCW . . . . . . . . . . . . . 81
          IP . . . . . . . . . . . . . . 113-114
          IXASC  . . . . . . . . . . . . 93
          IXCHAR . . . . . . . . . . . . 94
          IZVAR  . . . . . . . . . . . . 4-6, 11, 13, 29

          JSP  . . . . . . . . . . . . . 30, 73, 75, 77, 80

          LALOC  . . . . . . . . . . . . 13
          LCFG . . . . . . . . . . . . . 19
          LCOD . . . . . . . . . . . . . 19, 56, 79
          LDFG . . . . . . . . . . . . . 19
          LDRNAM . . . . . . . . . . . . 58
          LEFG . . . . . . . . . . . . . 19, 56
          Left Substring . . . . . . . . 83
          LFREE  . . . . . . . . . . . . 13
          LGT  . . . . . . . . . . . . . 112
          LHSH . . . . . . . . . . . . . 66
          LIBN1  . . . . . . . . . . . . 18
          LIBN2  . . . . . . . . . . . . 18
          LIBN3  . . . . . . . . . . . . 18
          LIBN4  . . . . . . . . . . . . 18
          LIBPPN . . . . . . . . . . . . 18
          LIBR . . . . . . . . . . . . . 18
          Library-list code  . . . . . . 6
          Library-list data  . . . . . . 6
          LIBT . . . . . . . . . . . . . 18
          License  . . . . . . . . . . . 81
          Line Continuation  . . . . . . 54
          Line Reference Table (LRT) . . 19
          Linefeed . . . . . . . . . . . 54
          LIST . . . . . . . . . . . . . 40
          LIT  . . . . . . . . . . . . . 64, 66
          Literals . . . . . . . . . . . 6, 64, 66, 76
          LJUST  . . . . . . . . . . . . 87
          LNUMB  . . . . . . . . . . . . 19-20
          LNXT . . . . . . . . . . . . . 19
          Loadmap  . . . . . . . . . . . 8
          LOC  . . . . . . . . . . . . . 89
          Local Parameters . . . . . . . 80
          Local Variable Compilation . . 59
          LOCATE Record  . . . . . . . . 104
          Location Counter . . . . . . . 26
          LOCK . . . . . . . . . . . . . 51
          LOG  . . . . . . . . . . . . . 5, 57, 107, 111-112
          LOG# . . . . . . . . . . . . . 34, 57
          LOG10  . . . . . . . . . . . . 112
          Logical scalars  . . . . . . . 34
          LOGOUT . . . . . . . . . . . . 107
          LOG# . . . . . . . . . . . . . 63
          LOL  . . . . . . . . . . . . . 103
          LOPMCS . . . . . . . . . . . . 23
          LPAD . . . . . . . . . . . . . 86
          LPGMP  . . . . . . . . . . . . 8
          LPMC . . . . . . . . . . . . . 19
          LRT  . . . . . . . . . . . . . 1, 19-21, 23, 56, 68, 78-79
          LRTE . . . . . . . . . . . . . 19
          LRX  . . . . . . . . . . . . . 20
          LRXK . . . . . . . . . . . . . 20
          LRXL . . . . . . . . . . . . . 20
          LRXN . . . . . . . . . . . . . 20
          LRXRG  . . . . . . . . . . . . 20
          LRXSZ  . . . . . . . . . . . . 20
          LRXT . . . . . . . . . . . . . 19-20, 56, 61
          LSTH . . . . . . . . . . . . . 19-20
          LSUBN  . . . . . . . . . . . . 19, 56
          LTXT . . . . . . . . . . . . . 19
          LVR  . . . . . . . . . . . . . 6-7

          MAP  . . . . . . . . . . . . . 8
          MAPORG . . . . . . . . . . . . 8
          Matrix Inversion . . . . . . . 96
          MAX  . . . . . . . . . . . . . 90
          MDUFG  . . . . . . . . . . . . 1, 3, 18
          MDUMD  . . . . . . . . . . . . 18
          MDUN0  . . . . . . . . . . . . 18
          MDUN1  . . . . . . . . . . . . 18
          MDUN2  . . . . . . . . . . . . 18
          MDUN3  . . . . . . . . . . . . 18
          MDUN4  . . . . . . . . . . . . 18
          MDUPPN . . . . . . . . . . . . 18
          MDUR . . . . . . . . . . . . . 18
          MDUT . . . . . . . . . . . . . 18
          Message Output . . . . . . . . 39
          Messages . . . . . . . . . . . 36
          MIN  . . . . . . . . . . . . . 90
          MINLV  . . . . . . . . . . . . 57
          MOCR . . . . . . . . . . . . . 39
          Module Orientation (MQHED) . . 74
          Module Transitions . . . . . . 13
          Module Transitions (USWAP) . . 6
          Modules  . . . . . . . . . . . 1
          MONOCR . . . . . . . . . . . . 39
          MOSTR  . . . . . . . . . . . . 39
          Move Array . . . . . . . . . . 98
          Move String  . . . . . . . . . 99
          MQHED  . . . . . . . . . . . . 74
          MSTATE . . . . . . . . . . . . 2
          Multiplication, Complex  . . . 92

          NAM# . . . . . . . . . . . . . 79
          NAMDIC . . . . . . . . . . . . 24
          NAME . . . . . . . . . . . . . 56
          Name Scoping . . . . . . . . . 59
          Name Table (HVX,NAMDIC)  . . . 24
          NAMIDX . . . . . . . . . . . . 24
          NAMS . . . . . . . . . . . . . 24
          NAMT . . . . . . . . . . . . . 24, 57
          NAMTB  . . . . . . . . . . . . 24
          NAM# . . . . . . . . . . . . . 80
          Negation, Array  . . . . . . . 98
          NO Condition Statement . . . . 107
          NOVL1  . . . . . . . . . . . . 28
          NOVL2  . . . . . . . . . . . . 28
          NOVTN  . . . . . . . . . . . . 28
          NOVTR  . . . . . . . . . . . . 28
          NOVTRR . . . . . . . . . . . . 28
          NPGMP  . . . . . . . . . . . . 8
          Numeric Scalars  . . . . . . . 33
          Numeric to String Conversion . 83, 85, 87

          O1P  . . . . . . . . . . . . . 62
          O2P  . . . . . . . . . . . . . 62
          Object File Naming Conventions  17
          OC . . . . . . . . . . . . . . 63
          OKON . . . . . . . . . . . . . 64
          OL . . . . . . . . . . . . . . 63
          OLVAR  . . . . . . . . . . . . 64
          OM . . . . . . . . . . . . . . 63
          OMX  . . . . . . . . . . . . . 63, 65
          ON . . . . . . . . . . . . . . 81
          ON Condition . . . . . . . . . 110
          ONG  . . . . . . . . . . . . . 63-65
          ONSC . . . . . . . . . . . . . 63-64
          OPDL . . . . . . . . . . . . . 62
          OPDN . . . . . . . . . . . . . 62
          OPDR . . . . . . . . . . . . . 63
          OPDSTK . . . . . . . . . . . . 62-63
          OPEN . . . . . . . . . . . . . 81, 104
          Open and Close Operations  . . 44
          OPENF  . . . . . . . . . . . . 41, 44-45
          Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV )  62
          Optimization . . . . . . . . . 61
          OPTYPE . . . . . . . . . . . . 22-23
          OREG . . . . . . . . . . . . . 64-65
          ORIF . . . . . . . . . . . . . 68
          ORSVD  . . . . . . . . . . . . 65
          OSC  . . . . . . . . . . . . . 63
          OSSC . . . . . . . . . . . . . 63-64
          OSST . . . . . . . . . . . . . 63
          OSUB . . . . . . . . . . . . . 64-65
          OT . . . . . . . . . . . . . . 63
          OTMP . . . . . . . . . . . . . 64-65
          OTST . . . . . . . . . . . . . 63, 65
          OUT  . . . . . . . . . . . . . 48
          OUTCR  . . . . . . . . . . . . 49
          OUVAR  . . . . . . . . . . . . 64-65
          OV . . . . . . . . . . . . . . 63

          P.MOD  . . . . . . . . . . . . 1-3, 5
          Page Boundaries  . . . . . . . 42
          Page Marks . . . . . . . . . . 54
          Paging . . . . . . . . . . . . 41
          Paging Algorithm . . . . . . . 41
          Paging Area  . . . . . . . . . 41
          PAKND  . . . . . . . . . . . . 59
          PALOC  . . . . . . . . . . . . 59
          PANAM  . . . . . . . . . . . . 59
          Parameter Compilation  . . . . 59
          Parameter Definitions  . . . . 57
          Parameter, Array to Procedure  101
          Parameter, String to Procedure  101
          Parameters, User-Defined Procedure  79
          PARDT  . . . . . . . . . . . . 56-57, 59, 61
          PARDTR . . . . . . . . . . . . 59
          PARLNK . . . . . . . . . . . . 59
          PARSE  . . . . . . . . . . . . 2-4, 6, 13, 27, 29, 38, 56,
                                         62
          Parser output  . . . . . . . . 23
          PASN . . . . . . . . . . . . . 59
          PATYP  . . . . . . . . . . . . 59
          PAUSD  . . . . . . . . . . . . 59
          PAUSE  . . . . . . . . . . . . 107
          PEPT . . . . . . . . . . . . . 79-80
          PEX  . . . . . . . . . . . . . 43
          PFDIM  . . . . . . . . . . . . 58
          PFROC  . . . . . . . . . . . . 58
          PFXP . . . . . . . . . . . . . 58
          PGCNFG . . . . . . . . . . . . 1, 3
          PGMP . . . . . . . . . . . . . 8
          PHASE  . . . . . . . . . . . . 92
          PMC  . . . . . . . . . . . . . 19-20, 23, 40, 56, 61-62
          PMC (PMC)  . . . . . . . . . . 22
          PMCNMS . . . . . . . . . . . . 23
          PMCTBL . . . . . . . . . . . . 23
          PMODD  . . . . . . . . . . . . 58
          PNAM . . . . . . . . . . . . . 58
          PNP  . . . . . . . . . . . . . 58
          POPLT  . . . . . . . . . . . . 22
          POS  . . . . . . . . . . . . . 37, 89, 96
          PPARS  . . . . . . . . . . . . 58
          PPFIN  . . . . . . . . . . . . 58
          PRINT  . . . . . . . . . . . . 40, 81, 104
          Print Spacing  . . . . . . . . 104
          Print Value  . . . . . . . . . 105
          Procedure Compilation  . . . . 57-58
          Procedure Name . . . . . . . . 58
          Procedure Prologues  . . . . . 80, 101
          Procedure Prologues, Array Parameter  101
          Procedure prologues, ENTRY . . 74
          Procedure References . . . . . 73
          Procedures, String Valued  . . 80
          Procedures, User-Defined . . . 79
          Processing of Monitor-Controlled Interrupts  31
          PROCNO . . . . . . . . . . . . 59
          PRODT  . . . . . . . . . . . . 56-58, 61
          PRODTR . . . . . . . . . . . . 58
          Program  . . . . . . . . . . . 1
          Program continuability . . . . 1
          Program layout . . . . . . . . 6
          Program Load Map (PGMP)  . . . 8
          Program Load Process . . . . . 10
          Program-File Formats . . . . . 53
          PRTFF+16 . . . . . . . . . . . 103
          PSIZE  . . . . . . . . . . . . 43
          PSTMLT . . . . . . . . . . . . 22
          PSW  . . . . . . . . . . . . . 1-5
          PUSHJ  . . . . . . . . . . . . 30, 70
          PVEC . . . . . . . . . . . . . 25, 59, 79-80, 102
          PXPT . . . . . . . . . . . . . 80

          QUIT . . . . . . . . . . . . . 5, 107
          QV . . . . . . . . . . . . . . 64

          R%VRLC . . . . . . . . . . . . 25, 57, 59, 64-65, 67
          R15  . . . . . . . . . . . . . 15
          R8IN . . . . . . . . . . . . . 105
          R8OUT  . . . . . . . . . . . . 106
          RAC  . . . . . . . . . . . . . 65, 80, 85
          RACAMX . . . . . . . . . . . . 80
          RACASA . . . . . . . . . . . . 80
          RACASS . . . . . . . . . . . . 80
          RACLIF . . . . . . . . . . . . 80
          RACLOC . . . . . . . . . . . . 80
          RACMMX . . . . . . . . . . . . 98
          RACMS  . . . . . . . . . . . . 99
          RACXMX . . . . . . . . . . . . 98
          RACXS  . . . . . . . . . . . . 99
          RAIDN  . . . . . . . . . . . . 99
          RAINT  . . . . . . . . . . . . 97
          RAMUL  . . . . . . . . . . . . 98
          Random Number Generation . . . 90
          RBND . . . . . . . . . . . . . 102
          RCFG . . . . . . . . . . . . . 2
          RCHAR  . . . . . . . . . . . . 85
          RCIB . . . . . . . . . . . . . 102
          RCLOS  . . . . . . . . . . . . 102
          RCOB . . . . . . . . . . . . . 102
          RCOPY  . . . . . . . . . . . . 102
          RDET . . . . . . . . . . . . . 94
          RDXMX  . . . . . . . . . . . . 32, 106
          RDXSS  . . . . . . . . . . . . 106
          READ . . . . . . . . . . . . . 41-42, 47
          Read a Variable  . . . . . . . 105
          READCR . . . . . . . . . . . . 41-42, 49
          Real scalars . . . . . . . . . 34
          REAL#  . . . . . . . . . . . . 34
          REEOPS . . . . . . . . . . . . 97
          Register Usage . . . . . . . . 30, 65
          REL  . . . . . . . . . . . . . 7, 9, 61
          Relational Operation, Deferred  65
          Relational Routine for Special Operators  93
          REMOVE . . . . . . . . . . . . 105
          RENAME . . . . . . . . . . . . 105
          RENUMBER . . . . . . . . . . . 20
          REPWR  . . . . . . . . . . . . 98
          RERAS  . . . . . . . . . . . . 103
          Reserved Words . . . . . . . . 24
          RESUME . . . . . . . . . . . . 73, 112
          RETURN . . . . . . . . . . . . 75, 106
          Return Address . . . . . . . . 79
          Return String  . . . . . . . . 102
          RFOLD  . . . . . . . . . . . . 103
          RGOSUB . . . . . . . . . . . . 75, 106
          RGRET  . . . . . . . . . . . . 75, 106
          RGSLC  . . . . . . . . . . . . 114
          RGSV . . . . . . . . . . . . . 62, 65
          RHED . . . . . . . . . . . . . 27, 30, 32, 73, 106
          RIASC  . . . . . . . . . . . . 93
          RICHR  . . . . . . . . . . . . 94
          Right Substring  . . . . . . . 84
          RINPF  . . . . . . . . . . . . 103
          RINPT  . . . . . . . . . . . . 103
          RINTP  . . . . . . . . . . . . 107
          RJUST  . . . . . . . . . . . . 86
          RKLFMT . . . . . . . . . . . . 103
          RLOC . . . . . . . . . . . . . 89
          RLOCAT . . . . . . . . . . . . 104
          RMINV  . . . . . . . . . . . . 96
          RMPWR  . . . . . . . . . . . . 96
          RMSOP  . . . . . . . . . . . . 97
          RMTRN  . . . . . . . . . . . . 96
          RND  . . . . . . . . . . . . . 90
          RNDX3  . . . . . . . . . . . . 88
          RNEGA  . . . . . . . . . . . . 98
          RNOCN  . . . . . . . . . . . . 107
          RONCN  . . . . . . . . . . . . 110
          ROPEN  . . . . . . . . . . . . 104
          ROUND  . . . . . . . . . . . . 113
          RPAD . . . . . . . . . . . . . 86
          RPHED  . . . . . . . . . . . . 32
          RPHZ . . . . . . . . . . . . . 92
          RPOS . . . . . . . . . . . . . 89
          RPOST  . . . . . . . . . . . . 96
          RPRTF  . . . . . . . . . . . . 104
          RPRTS  . . . . . . . . . . . . 104
          RPRTV  . . . . . . . . . . . . 105
          RPT  . . . . . . . . . . . . . 86
          RPWR . . . . . . . . . . . . . 99
          RRCD . . . . . . . . . . . . . 95
          RREAD  . . . . . . . . . . . . 105
          RRFL . . . . . . . . . . . . . 95
          RRLN . . . . . . . . . . . . . 95
          RRMOV  . . . . . . . . . . . . 105
          RRMSG  . . . . . . . . . . . . 89
          RRNAM  . . . . . . . . . . . . 105
          RRSTR  . . . . . . . . . . . . 105
          RRSUM  . . . . . . . . . . . . 112
          RSACT  . . . . . . . . . . . . 97
          RSAS1  . . . . . . . . . . . . 85
          RSASC  . . . . . . . . . . . . 88
          RSBLK  . . . . . . . . . . . . 83
          RSBN2  . . . . . . . . . . . . 84
          RSBNL  . . . . . . . . . . . . 88
          RSCAT  . . . . . . . . . . . . 85
          RSCMP  . . . . . . . . . . . . 90
          RSCNT  . . . . . . . . . . . . 87
          RSIG . . . . . . . . . . . . . 102
          RSIZ . . . . . . . . . . . . . 89
          RSLEN  . . . . . . . . . . . . 83
          RSLFT  . . . . . . . . . . . . 84
          RSLJT  . . . . . . . . . . . . 87
          RSLPD  . . . . . . . . . . . . 86
          RSMAX  . . . . . . . . . . . . 90
          RSMIN  . . . . . . . . . . . . 90
          RSRGT  . . . . . . . . . . . . 84
          RSRJT  . . . . . . . . . . . . 86
          RSROP  . . . . . . . . . . . . 93
          RSRPD  . . . . . . . . . . . . 86
          RSRPT  . . . . . . . . . . . . 86
          RSST1  . . . . . . . . . . . . 83
          RSST2  . . . . . . . . . . . . 87
          RSTRE  . . . . . . . . . . . . 92
          RSTRG  . . . . . . . . . . . . 91
          RSTRGE . . . . . . . . . . . . 91
          RSTRL  . . . . . . . . . . . . 91
          RSTRLE . . . . . . . . . . . . 91
          RSTRNE . . . . . . . . . . . . 92
          RSVL1  . . . . . . . . . . . . 83
          RSVL2  . . . . . . . . . . . . 87
          RTAB1  . . . . . . . . . . . . 88
          RTAB2  . . . . . . . . . . . . 89
          RTCP . . . . . . . . . . . . . 94
          RTRU . . . . . . . . . . . . . 95
          RUN  . . . . . . . . . . . . . 5, 10
          RUNIZL . . . . . . . . . . . . 6, 8, 10
          RUNSEG . . . . . . . . . . . . 6
          RWAIT  . . . . . . . . . . . . 114
          RXAMX  . . . . . . . . . . . . 101
          RXAS . . . . . . . . . . . . . 101
          RXASC  . . . . . . . . . . . . 94
          RXCHR  . . . . . . . . . . . . 94
          RXDAT  . . . . . . . . . . . . 93
          RXFG . . . . . . . . . . . . . 73
          RXJ  . . . . . . . . . . . . . 30, 75, 80
          RXL  . . . . . . . . . . . . . 73, 80
          RXLOC  . . . . . . . . . . . . 26
          RXO  . . . . . . . . . . . . . 30, 73, 75, 80
          RXP  . . . . . . . . . . . . . 15, 30-31
          RXPMX  . . . . . . . . . . . . 80, 101
          RXPSS  . . . . . . . . . . . . 80, 101
          RXRS . . . . . . . . . . . . . 102
          RXTIM  . . . . . . . . . . . . 93
          RXTRM  . . . . . . . . . . . . 93
          RXYR . . . . . . . . . . . . . 95
          RZTBHI . . . . . . . . . . . . 23
          RZTBLO . . . . . . . . . . . . 23

          SARY . . . . . . . . . . . . . 57
          SAVE . . . . . . . . . . . . . 5, 53-54, 61
          SAVE BIN . . . . . . . . . . . 5
          Scalar Multiplication of Array  97
          SDADR  . . . . . . . . . . . . 35, 79
          SDCL . . . . . . . . . . . . . 35, 79
          SDML . . . . . . . . . . . . . 35, 79
          SDR  . . . . . . . . . . . . . 35
          SDT  . . . . . . . . . . . . . 4, 29, 56-57, 59, 61, 79
          SDTR . . . . . . . . . . . . . 57
          SEGNO  . . . . . . . . . . . . 2-3
          Set Boundary . . . . . . . . . 102
          Set Output Significance  . . . 102
          Significance, Output . . . . . 102
          SIN  . . . . . . . . . . . . . 108
          SINH . . . . . . . . . . . . . 110
          SIZE . . . . . . . . . . . . . 89
          SKND . . . . . . . . . . . . . 57
          SLIT . . . . . . . . . . . . . 66
          SLO  . . . . . . . . . . . . . 6
          SLOC . . . . . . . . . . . . . 57, 79
          SN . . . . . . . . . . . . . . 57-58
          Source lines . . . . . . . . . 21
          Source-mod . . . . . . . . . . 2, 25
          SPARY  . . . . . . . . . . . . 57
          SPRO . . . . . . . . . . . . . 57
          SPROCN . . . . . . . . . . . . 57
          SQRT . . . . . . . . . . . . . 109
          SSCAL  . . . . . . . . . . . . 57
          STACK pointer  . . . . . . . . 15
          START  . . . . . . . . . . . . 5
          STARTPOINT . . . . . . . . . . 8
          Startpoint . . . . . . . . . . 8-9
          Statement Orientation (RHED, BTFG, RXFG)  73
          Status Control . . . . . . . . 1
          STEP . . . . . . . . . . . . . 5, 7, 32, 48
          STEPCR . . . . . . . . . . . . 50
          Sticky Line Numbers  . . . . . 54
          STOP . . . . . . . . . . . . . 107
          STR  . . . . . . . . . . . . . 34, 43, 57, 63, 87
          String and Matrix Code . . . . 76
          String Array . . . . . . . . . 70
          String body  . . . . . . . . . 35
          String Concatenation . . . . . 84
          String Constants . . . . . . . 66
          String Declaration . . . . . . 106
          String Descriptors . . . . . . 35, 70, 79
          String Exchange  . . . . . . . 98
          String Length  . . . . . . . . 83
          String Move  . . . . . . . . . 99
          String Parameter Deallocation  101
          String Parameter, to Procedure  101
          String Parameters  . . . . . . 79-80
          String scalars . . . . . . . . 35
          String to Numeric Conversion . 83, 85, 87-88
          String Value . . . . . . . . . 83
          String Valued Procedures . . . 80
          STRTPT.  . . . . . . . . . . . 8
          STYP . . . . . . . . . . . . . 57
          Subscript Checking . . . . . . 70
          Subscripting . . . . . . . . . 32
          SUBSTR . . . . . . . . . . . . 88
          Substring  . . . . . . . . . . 84, 88
          SUSED  . . . . . . . . . . . . 57
          Symbol Definitions (SDT, PRODT, PARDT)  57
          Symbol table . . . . . . . . . 8
          Symbol Types . . . . . . . . . 57
          SYMD . . . . . . . . . . . . . 5, 56
          SYSIZL . . . . . . . . . . . . 5-6, 13
          System Debug Switch (DEBMOD) . 14
          System Stack . . . . . . . . . 15
          System-Level File IO . . . . . 41
          SYSUP  . . . . . . . . . . . . 3

          TAB  . . . . . . . . . . . . . 88-89
          TAN  . . . . . . . . . . . . . 108
          TANH . . . . . . . . . . . . . 110
          Task Table . . . . . . . . . . 4
          TBA library code . . . . . . . 6
          TBA library data . . . . . . . 6
          TBA Status Control . . . . . . 1
          TBA system code  . . . . . . . 6
          TBA system data  . . . . . . . 6
          TBL  . . . . . . . . . . . . . 2, 13, 18-19, 24, 58-59, 66
          TCL1 . . . . . . . . . . . . . 28
          TCL2 . . . . . . . . . . . . . 28
          TCP  . . . . . . . . . . . . . 94
          TCVL . . . . . . . . . . . . . 28
          Temp cell descriptor . . . . . 67
          Temp cells . . . . . . . . . . 25
          Temp cell descriptor pointer . 64
          Temp-cell Description Table (TQDT)  67
          Temporary Cells  . . . . . . . 64-65, 67
          Temporary Results  . . . . . . 76
          Temps  . . . . . . . . . . . . 6
          TERM . . . . . . . . . . . . . 93
          Terminal Carriage Width  . . . 103
          Terminal Input . . . . . . . . 39, 93
          Terminal Input Buffer  . . . . 102
          Terminal Output  . . . . . . . 40
          Terminal Output Buffer . . . . 102
          Terminal-Directed Output . . . 40
          Terminal-Related Functions . . 37
          Text Area (TXT)  . . . . . . . 21
          TFR  . . . . . . . . . . . . . 48
          TFRSTR . . . . . . . . . . . . 50-51
          TIME . . . . . . . . . . . . . 93
          TMPCOR files . . . . . . . . . 55
          TOUT . . . . . . . . . . . . . 13, 37-40
          TOUT Destination . . . . . . . 37
          TPOS . . . . . . . . . . . . . 37
          TQDBLK . . . . . . . . . . . . 67
          TQDT, definition . . . . . . . 67
          TQSZE  . . . . . . . . . . . . 67
          TRACE  . . . . . . . . . . . . 73, 106
          Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)  28
          TRANSFER . . . . . . . . . . . 52
          Transition . . . . . . . . . . 2
          Transition Table . . . . . . . 5
          Trap Handling  . . . . . . . . 74
          TRCLX  . . . . . . . . . . . . 28
          TRCN . . . . . . . . . . . . . 28, 73
          TRCT . . . . . . . . . . . . . 28
          TRCTN  . . . . . . . . . . . . 28
          TRCTR  . . . . . . . . . . . . 28
          TRLS . . . . . . . . . . . . . 2
          TRN  . . . . . . . . . . . . . 96
          TRRZL  . . . . . . . . . . . . 6, 10
          TRSP1  . . . . . . . . . . . . 28
          TRSP2  . . . . . . . . . . . . 28
          TRSP3  . . . . . . . . . . . . 28
          TRU  . . . . . . . . . . . . . 95
          TRVID  . . . . . . . . . . . . 28
          TRVLC  . . . . . . . . . . . . 28
          TRVLX  . . . . . . . . . . . . 28
          TRVN . . . . . . . . . . . . . 28
          TRVSP1 . . . . . . . . . . . . 28
          TRVSP2 . . . . . . . . . . . . 28
          TRVSP3 . . . . . . . . . . . . 28
          TRVT . . . . . . . . . . . . . 28
          TRVTP  . . . . . . . . . . . . 28
          TRVTR  . . . . . . . . . . . . 28
          TXT  . . . . . . . . . . . . . 20-21
          Type Codes . . . . . . . . . . 34
          Types, Symbol  . . . . . . . . 57

          UNLESS . . . . . . . . . . . . 68
          UNTIL  . . . . . . . . . . . . 77
          User Defined Symbols . . . . . 24
          User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)  81
          User-Defined Modules and Libraries  18
          User-Defined Procedures  . . . 79
          User-Supplied Routines . . . . 16
          USWAP  . . . . . . . . . . . . 6, 13
          UVARR  . . . . . . . . . . . . 11, 30

          VAL  . . . . . . . . . . . . . 87
          VAL# . . . . . . . . . . . . . 79
          Value Negation . . . . . . . . 64
          VAL# . . . . . . . . . . . . . 80
          VAL# . . . . . . . . . . . . . 80
          VAL# . . . . . . . . . . . . . 80
          VAL# . . . . . . . . . . . . . 79
          Variable Allocation Address (R%VRLC)  25
          Virtual Addresses  . . . . . . 41
          Virtual Byte Addresses . . . . 41
          Virtual Word Addresses . . . . 41
          VMF file . . . . . . . . . . . 6
          VTBL . . . . . . . . . . . . . 13, 21, 23, 37, 60, 66

          WAIT . . . . . . . . . . . . . 114
          WHILE  . . . . . . . . . . . . 68, 77
          Width , Terminal . . . . . . . 103
          WLOCR  . . . . . . . . . . . . 11, 30
          Word Cursor  . . . . . . . . . 42
          Word-Oriented IO . . . . . . . 47
          Workspace module code  . . . . 6
          WRITCR . . . . . . . . . . . . 42, 49
          WRITE  . . . . . . . . . . . . 42, 47

          XASC . . . . . . . . . . . . . 94
          XCFG . . . . . . . . . . . . . 2
          Xcfg . . . . . . . . . . . . . 2
          XCHAR  . . . . . . . . . . . . 94
          XINT . . . . . . . . . . . . . 81
          XRUN . . . . . . . . . . . . . 2, 4-6, 8-10, 13, 27, 73-74
          XRUN Load String . . . . . . . 9
          XRUN startup . . . . . . . . . 74

          YEAR . . . . . . . . . . . . . 95

          << . . . . . . . . . . . . . . 93
          >> . . . . . . . . . . . . . . 93
  @E