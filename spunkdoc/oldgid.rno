.flag index .FLAG CAPITALIZE
.upper case
.spacing 1
.paper size 54,71
.left margin 10
.right margin 71
.paragraph 0
.number 0
.title TYMBASIC GID -- Overall System Considerations
.figure 1
.blank
.subtitle TBA Status Control
.skip 4
.center 80
TYMBASIC GID
.skip 3
.center 80
-----
.skip 3
.center 80
General Internal Design
.skip 2
.center 80
of the
.skip 2
.center 80
TYMBASIC Language
.skip 2
.center 80
for Tymcom-X
.skip 3
.center 80
-----
.skip 5
.center 80
3/10/76
.skip 5
.center 80
Version 11
.page 
.index <TBA ^Status ^Control
.index Status ^Control
.index <STATE
.index <PSW
.index <CLRFLG
.skip 1
.center 80
TBA Status Control
.skip 1
The "modules" of Tymbasic are boxes 4, 5, 6, 7, 8 and 10 of the
level 1 TYMBAS flowchart.
These modules communicate via the user program data structure
(><LRT et al.) and the following status words:
.skip 1
.indent 5
.X <MDUFG
MDUFG:
.skip 1
.left margin 20

The module flag.
(MDUFG not 0) _<=_> (a non-empty module list exists).
Certain commands and situations are handled differently when
>modules are being used than in the old Super Basic mode
.index current workspace
where only the current workspace exists.
.skip 1
.indent -5
.X <PGCNFG
PGCNFG:
.skip 1
.index program continuability
The program continuability flag.  (PGCNFG not 0) _<=_> (program has
.index continue point
been in execution; a continue point exists; no >source-mod has
been made since; ><CXLNUM is the continue line).
.skip 1
.indent -5
.X <DSMDFG
DSMDFG:
.skip 1
The data-structure modification flag. (DSMDFG not 0) _<=_>
(program has been in execution and no >data-structure-mod has been
.x Interrupts
irrevocably committed since; ><CXLUM is the interrupt line).
.skip 1
.indent -5
><PXLNFG:
.skip 1
The >print-interrupt-line flag. (PXLNFG not 0) _<=_> (><PARSE should print
the line whose linenum is CXLNUM).
.test page 7
.skip 1
.indent -5
.X <STATE
STATE:
.skip 1
><STATE = -1 =_>
.skip 1
.left margin 25
either the program has never been executed or else a >source-mod has
.index current workspace
occurred in the current workspace since the most recent compilation.
.skip 1
.indent -5
><STATE = 0 =_>
.skip 1
the complement of the above situation.
.skip 1
.indent -5
Note:
.break
.X <PGCNFG
(><STATE = -1) =_> (PGCNFG = 0)
.left margin 20
.tp 6
.indent -5
.X <MSTATE
MSTATE:
.skip 1
A ><PARSE subroutine called when a >source-mod is requested by the
user.
If ><PGCNFG = 0, ><MSTATE sets ><STATE = -1 and returns the value 1.
If ><PGCNFG is not 0, then ><MSTATE prints the message
.skip 1
.index program continuability
.indent 5
DESTROY PROGRAM CONTINUABILITY?
.skip 1
and awaits Y[ES]##or N[O]##.
.X <STATE
If the answer is YES, ><MSTATE sets (STATE,PGCNFG) to (-1.0) and
returns the value 1.
If the answer is NO, ><MSTATE returns 0 and ><PARSE fails to carry
.x Source-mod
out the requested source-mod.
.indent -5
.skip 1
.X <CXLNUM
CXLNUM:
.skip 1
Current run-side linenum; the line interrupted or next to be executed
.index Direct ^Statements
when program is continued; specifies context of direct statements,
even if the corresponding statement has been deleted.
.skip 1
.left margin 25
.indent -10
.X <CLRFLG
CLRFLG:
.skip 1
.indent -5
A status word mapped by:
.skip 1
.x <RCFG
.x <CCFG
.x <DCFG
REC##CLRFLG,_<_<RCFG,1_>,_<CCFG,1_>,_<DCFG,1_>_>
.skip 1
field#########=1#means
.break
-----#########--------
.skip 1
@CLRFLG/RCFG##><XRUN data structures allocated
.break
###"###/CCFG##><COMPIL data structures allocated
.break
###"###/DCFG##><DECLAR data structures allocated
.skip 1
.left margin 20
.test page 8
.X xCFG
.index data structures
When /xCFG = 0, then the process x data structures are totally
.X <TRLS
.X <TBL
unallocated (all tbl's have been TRLS'd, etc.).
When />x^C^F^G = 1, then the data structures for process x represent
the successful, error-free, complete output of process x for
the current program (if ><STATE not -1) or for a previous state of
the program (if ><STATE = -1).
.test page 7
.skip 1
.left margin 20
.indent -5
.index <CXLNUM
.index <SEGNO
.X <PSW
PSW:
.skip 1
A status word used when a >transition is to be made from ><PARSE to
other modules.
.X <PARSE
.X <PSW
PSW, set by PARSE, designates which command is calling for the
transition and which actions need to be performed by the other modules.
.test page 5
.skip 1
.indent -5
.X <SEGNO
SEGNO:
.skip 1
As each module exits, it sets SEGNO to the case value (see
TYMBAS flowchart) of the module to be executed next
.skip 1
.left margin 10
.X <SYSUP
Overall flow of status control:# at SYSUP, these initializations
are made:
.skip 1
.indent 5
-1 -_> ><STATE
.skip 1
.indent 5
.X <CLRFLG
.X <PXLNFG
.X <DSMDFG
0 -_> CLRFLG,PXLNFG,DSMDFG
.skip 1
.indent 5
.X <PGCNFG
.X <MDUFG
0 -_> PGCNFG,MDUFG
.skip 1
If ><RUN or ><INIT is ever successfully executed (that is, no compiler
diagnostics occur), then ><IZVAR will set ><DSMDFG to 1, and ><XRUN will
set ><PGCNFG to 1 (unless termination was due to the ><STOP command).
When ><PARSE exits to other modules, the value of ><STATE (together with
.X <PSW
the active user command) determines the setting of PSW.
PSW, in turn, governs which modules are to be called.
The action of those modules is governed by the values of ><PSW
.X <CLRFLG
and CLRFLG.
Before exiting, each module ensures its data structures are as
.X <CLRFLG
advertised by CLRFLG.
Exit is to ><PARSE if errors were found and to the designated
successor module otherwise (as shown below in the Transition Table).
.page
The primary system tasks which vary according to ><PSW and ><CLRFLG
are shown in the following table.
.skip 1
.index Task ^Table
.center 80
Task Table
.skip 1
task_######done by#####description
.break
-----#####-------#####-----------
.break
.skip 1
.left margin 32
.indent -22
.X <DCFG
##1#######><DECLAR######0 -_> /DCFG; release structures; process
declarations; if errors then release structures else 1 -_> /><DCFG
.skip 1
.indent -22
.X <DCFG
##2#######><DECLAR######if /DCFG = 0 then do Task 1, else
.X <SDT
(start with existing SDT; process declarations and update SDT; if
.X <DCFG
errors then release structures and put 0 -_> /DCFG)
.skip 1
.indent -22
##3#######><DECLAR######display definition of symbol ><CDEID in context
><CDELN1
.skip 1
.indent -22
##4#######><COMPIL######0 -_> /CCFG; release structures; compile
program; if errors then release structures else 1 -_> /CCFG
.skip 1
.indent -22
.index Direct ^Statements
.X <CCFG
##5#######><COMPIL######compile direct statement; leave /CCFG alone;
.X <SDT
observe ><PGCNFG and properly warn user before adding symbols to SDT;
if errors then return to ><PARSE
.skip 1
.indent -22
##6#######><COMPIL######display compiled code for lines in range
.x <CDELN1
.x <CDELN2
CDELN1:CDELN2
.skip 1
.indent -22
##7#######><IZVAR#######put out loseg initialization information
.skip 1
.indent -22
##8#######><IZVAR#######generate .><REL information to initialize loseg
.index Direct ^Statements
of direct statement code
.skip 1
.indent -22
##9#######><XRUN########load ><DSA from prog.><DSA file
.skip 1
.indent -22
#10#######><XRUN########fix up loseg references for relocated ><DSA
from bitmap
.skip 1
.indent -22
#11#######><XRUN########use null ><DSA
.skip 1
.fill
.left margin 10
.test page 24
.X <PSW
The following table shows each of the possible values of PSW,
designates which of the above tasks are to be performed and shows the
normal set of modules to be invoked.
.skip 2
.test page 24
.left margin 11
.center 80
Transition Table
.index Transition ^Table
.skip 1
.nofill
><STATE  #########                    ---------Modules--------
=-1?  Condition    ><PSW Tasks        ><DECLAR ><COMPIL ><IZVAR ><XRUN
----- ------------ --- ------------ ------ ------ ----- ----
.skip 1
.INDEX Direct ^Statements
  Y   direct stmnt  1  2,4,5,8,9,10   X      X      X    X
  N   direct stmnt  2  5,8,9,10              X      X    X
  Y   ><RUN           3  1,4,7,11       X      X      X    X
  N   ><RUN           4  7,11                         X    X
  Y   ><START         5  2,4,8,9,10     X      X      X    X
  N   ><START         6  9                                 X
  N!  ><GO            7  9                                 X
  Y   ><INIT          8  1,4,7,11       X      X      X    X
  N   ><INIT          9  7,11                         X    X
.left margin 10
either ><CLEAR        10  none         ><SYSIZL
either ><QUIT         11  none         ><EXIT
.left margin 11
  Y   ><CDE          12  2,4,6          X      X
  N   ><CDE          13  6                     X
  Y   ><SYMD         14  2,3            X
  N   ><SYMD         15  3              X
  N!  ><STEP         16  9                                 X
.index <SAVE <BIN
  Y   ><SAVE <BIN     17  2,4,8,9,10     X      X      X    X
  N   ><SAVE <BIN     18  9                                 X
.fill
.left margin 10
.subtitle Data Structure Preservation (.SDT)
.page
.index Data ^Structure ^Preservation (.^S^D^T)
.index <SDT
.skip 1
.center 80
Data Structure Preservation (.SDT)
.skip 1
The User-Data-Structure of a TBA program involves the internal tables:
.skip 1
.indent 5
.INDEX <SDT
.INDEX <PRODT
.INDEX <CLRFLG
SDT,PRODT,CLRFLG
.indent 5
.x <MDUT
.x <LIBT
MDUT,LIBT
.indent 5
.X <LVR
prog.LVR, prog.><DSA
.skip 1
.left margin 15
.indent -5
a.###When ><GET of a module is performed and ><DSMDFG is non-zero, ><STATE
.X <DCFG
.X <CCFG
.X <CLRFLG
is set to zero, 1 -_>< @CLRFLG/(DCFG,CCFG) and a current
module.><SDT file is sought.
If such a file is found, ><SDT et al are loaded from that file.
If not found, the module is immediately compiled so as to create a
benchmark ><SDT et al, which are immediately written on the module.><SDT
file.
.skip 1
.indent -5
b.###When ><SAVE of a module is performed and ><DSMDFG is nonzero and
><STATE = -1, then a trial compilation is performed to detect a
.x Data-structure-mod
data-structure-mod.
.X <REL
.X <SDT
If no such mod has occurred, the updated module.SDT, module.REL, and
module.TBA are saved and ><STATE is set to zero.
If such a mod is detected, the user is given a chance to abort the save.
If he aborts the save, ><SDT et al are reloaded from the module.><SDT file.
If he asks for the save to be completed, then ><SDT et al are set to nil
and ><DSMDFG is set to zero.
.skip 1
.indent -5
.index Direct ^Statements
c.###When a direct statement is entered and ><DSMDFG is nonzero and
.X <SAVE
.X Data-structure-mod
><STATE = -1 then, as with SAVE, a test is made for a data-structure-mod.
If none is found, the updated module.><REL and module.><SDT are written out,
.index Direct ^Statements
><STATE is set to zero and the direct statement is compiled
and executed.
.subtitle Module Transitions (USWAP)
.page
.index Module ^Transitions (^U^S^W^A^P)
.index <USWAP
.skip 1
.center 80
Module Transitions (USWAP)
.skip 1
.left margin 10
.X <SYSIZL
.X <PARSE
.X <DECLAR
.X <COMPIL
.X <IZVAR
Transition among SYSIZL, PARSE, DECLAR, COMPIL, and IZVAR is via
><RUNSEG and preserves a continuous loseg.
The necessary hiseg configurations are used from
.x <SYSIZL
.x <PARSE
(SYS)SYSIZL.SHR, (SYS)PARSE.SHR, etc.
.X <XRUN
When control passes via ><TRRZL to ><RUNIZL and XRUN, a new loseg and hiseg
are to be created by the loader.
.X <SLO
Prior to this the editside loseg is saved on prog.SLO.
.skip 1
.INDEX program layout
A running TBA program is laid out as follows:
.break
(brackets denote optional items.)
.left margin 27
.indent -4
.skip 1
.nofill
0:# monitor area data
.index <TBA system data
TBA system data
module1 data }
.indent -1
[module2 data]}
.indent -1
[ . . .      ]}  Includes workspace module
.indent -1
[modulen data]}
.indent -1
.index Direct ^Statements
.index literals
.index temps
[direct statement literals and temps]
.index library-list data
.indent -1
[library-list data]
.index <TBA library data
TBA library data
.index dynamic storage
dynamic storage
.skip 1
.indent -12
.index <TBA system code
O'400000':##TBA system code
module1 code
module2 code
 . . .
modulen code
.index workspace module code
workspace module code
.index library-list code
library-list code
.index <TBA library code
TBA library code
.index Direct ^Statements
.index Direct ^Statement code
direct statement code
.skip 1
.left margin 10
.fill
The module data area contains numeric scalars, string descriptors and
array descriptors; it is allocated to a static area by ><DECLAR
.X <COMPIL
(and COMPIL).
.skip 1
The ><DSA holds the actual bodies of strings and arrays.
As these structures are dynamic, ><DSA may grow or shrink in
size during execution; it is thus always at the highest
locations of the loseg.
.skip 1
When a TBA program begins execution, the hiseg is saved on
.skip 1
.indent 5
prog.HI
.skip 1
where prog is the current program ><SAVE name.
.skip 1
When the program is interrupted, the current loseg is written
.X <LVR
out on prog.LVR.
Control then passes to ><PARSE via runseg (SYS)PARSE.SHR.
.skip 1
If the program is restarted with the ><GO or ><STEP command,
.X <LVR
prog.(LVR,HI) can simply be reloaded and execution resumed.
.index Direct ^Statements
If the program is restarted by a direct statement, then a reload of
the .><REL files will be required.
The relocated segments of the loseg will be restored to their old
contents from the prog.><LVR file (see ><XRUN Load Procedure).
.subtitle Program Load Map (PGMP)
.page
.index Program ^Load ^Map (^P^G^M^P)
.index <PGMP
.skip 1
.center 80
Program Load Map (PGMP)
.skip 1
The Program Load Map is created by ><RUNIZL as part of the Program
Load Process from information supplied by the system loader.
.skip 1
The format of the >loadmap is given by:
.skip 1
.indent 5
.X <PGMP
.X <NPGMP
REC_# PGMP,_<_<NPGMP,36_>,
.indent 10
.X <LPGMP
.X <HPGMP
_<LPGMP,18_>,_<HPGMP,18_>_>
.skip 1
.indent 5
/><NPGMP -- sixbit program name
.skip 1
.indent 5
/><LPGMP -- loadpoint of loseg
.skip 1
.indent 5
/><HPGMP -- loadpoint of hiseg
.skip 1
.X <RUNIZL
The program load map is generated as the initial process of RUNIZL.
This process proceeds as follows:
.skip 1
.left margin 15
.indent -5
.index symbol table
1.###The symbol table generated by the loader (found at the end of
the loseg) is reformatted into the above record format.
.X <MAPORG
The table origin is placed in MAPORG.
.skip 1
.indent -5
2.###The pager initialization routine is called.
.skip 1
.indent -5
3.###A copy of ><PGMP is placed in the virtual memory file for use by
the ><MAP command.
.skip 1
.indent -5
4.###The ><STARTPOINT and WORKSPACE module names are obtained from the
virtual memory file.
.skip 1
.indent -5
5.###><PGMP is scanned to find the >startpoint module.
This module will be one of the following:
.skip 1
.left margin 20
.indent -5
a.###The module specified by the ><STARTPOINT command.
.skip 1
.indent -5
b.###The workspace module.
.skip 1
.indent -5
.index Direct ^Statements
c.###The direct statement code module.
.skip 1
.left margin 15
The highseg >startpoint address is stored in ><STRTPT.
.left margin 10
.subtitle ><XRUN Load String
.page
.index <XRUN ^Load ^String
.skip 1
.center 80
><XRUN Load String
.skip 1
From the module list and library list, TBA creates a
load string to drive the system loader which contians names of
the .><REL files in the following order:
.skip 1
.left margin 20
.indent -5
(SYS)TBARUN.><REL
.break
module
.break
module
.break
 . . .
.break
module (workspace module)
.break
library (user libraries)
.break
library
.break
 . . .
.break
.indent -5
(SYS)TBAL1.LIB (TBA libraries)
.break
 . . .
.break
.index Direct ^Statements
Dnnnn.TMP (direct statement) -- nnnn = current job number
.skip 1
.left margin 10
The modules are in the order of the module list; the libraries are in
the order of the library list.
.skip 1
The .><REL files have conventional program
names (same as the file name) so that the Program Load Map can be
used to find:
.left margin 20
.skip 1
.indent -5
a.###the bounds of the module area, as a whole
.skip 1
.indent -5
b.###The bounds of the workspace module
.skip 1
.indent -5
c.###the >startpoint of the TBA program
.skip 1
.left margin 10
See Program Load Map above.
.subtitle Program Load Process
.page
.index Program ^Load ^Process
.X <TRRZL
.skip 1
.center 80
Program Load Process (TRRZL)
.skip 1
.left margin 10
The process of passing from the SYSIZL,..., ><COMPIL states to ><RUNIZL
and ><XRUN is accomplished by ><TRRZL (Transfer to run initialization).
><TRRZL consists basically of three subprocesses:
.skip 1
.left margin 15
.indent -5
1.###Build ><XRUN load string verifying any user specified filenames
by checking to see if the given files exist.
.skip 1
.indent -5
2.###Invoke the system loader via a ><RUN UUO.
.skip 1
.indent -5
3.###Begin program execution in the ><RUNIZL state.
.index Direct ^Statements
.subtitle Direct Statement Compilation
.page
.index Direct ^Statements
.index Direct ^Statement ^Compilation
.skip 1
.center 80
Direct Statement Compilation
.index Direct ^Statements
.skip 1
.left margin 10
.index Direct ^Statements
Each direct statement is a separate module.
References from within the direct statement to its own data or code
will be accomplished, as usual, by relocation.
References from the direct statement to the workspace will be
accomplished by indexing.
.subtitle Condition Trap Table (CNDTT)
.page
.index Condition ^Trap ^Table (^C^N^D^T^T)
.index <CNDTT
.skip 1
.center 80
Condition Trap Table (CNDTT)
.skip 1
.INDEX Condition traps
.X <CNDTT
A table, CNDTT, is maintained for each condition and holds the
information:
.skip 1
.left margin 20
.indent -5
a.###whether condition armed
.skip 1
.indent -5
if armed:
.skip 1
.indent -5
b.###address of module holding trap
.skip 1
.indent -5
c.###linenumber of trap
.skip 1
.indent -5
d.###displacement within module of trap
.skip 1
.left margi
As modules are recompiled, ><COMPIL marks entries as disarmed if the
line is deleted and updates the displacement field otherwise.
The Program Load Process updates the address of module
holding the trap.
.subtitle Data Structure Management (TBL, DSA, Module Transitions, USWAP)
.page
.index Data ^Structure ^Management (<TBL, <DSA, ^Module ^Transitions, <USWAP)
.index <TBL
.index <DSA
.index Module ^Transitions
.index <USWAP
.skip 1
.X <DSA
.X <TBL
.center 80
Data Structure Management (TBL, DSA, Module Transitions, USWAP)
.skip 1
Two data structure environments are maintained under TBA.
.X <SYSIZL
.X <PARSE
.X <DECLAR
.X <COMPIL
The first, the editside, encompasses SYSIZL, PARSE, DECLAR, COMPIL
.X <IZVAR
and IZVAR; the second, called runside, prevails during program
.X <XRUN
execution (i.e., the TBA module, XRUN).
.skip 1
The editside loseg is maintained continuously among its modules.
.X <FTBL
The data structures involved are system variables, arrays, FTBL's,
.X <FTBL
.X <TBL
.X <VTBL
TBL's and VTBL's.
.X <LALOC
.X <LFREE
The only dynamic blocks allocated (see LALOC, LFREE) are for the IO
buffers involved in the ><DO and ><TOUT commands.
.skip 1
The ><TBL package is described in detail under separate cover, but
briefly, the structures ><TBL and ><VTBL are managed in a static
portion of the loseg called the paging area.
A scratch file (named uniquely for each job) is used as a swapping
store for the paging areas.
The page size, number of pages and page replacement algorithm may
be tuned, if necessary, during milestone 8.
When control is passed to the runside, the entire editside loseg
is dumped on a scratch file, and the swapping file is closed.
.skip 1
.X <TBL
.X <FTBL
.X <VTBL
The runside uses no TBL's, VTBL's or FTBL's and no paging area.
All data structures are either static areas set up at load time
or else are in the ><DSA area.
The ><DSA area is a collection of dynamically allocated blocks of
storage pointed to by static data structures.
Included in the ><DSA are array and string bodies, IO buffers, file
control blocks, and IO control blocks.
.subtitle System Debug Switches (DBGn)
.page
.index System ^Debug ^Switches (^D^B^Gn)
.index ^D^B^Gn
.X <DBG
.skip 1
.center 80
System Debug Switches (DBGn)
.skip 1
.X <DBG
The set of symbols DBGn, for digits n, are designated as system
debug switches.
Each switch governs the assembly of specified debugging facilities.
Facility n is controlled as follows:
.skip 1
.indent 5
IFN##DBGn,_<facility n_>
.skip 1
For a switch to be turned on, then, it is only necessary to have
a ><DBSET.MAC file containing
.skip 1
.indent 5
.X <DBG
DBGn = 1
.skip 1
which is assembled with MA.MAC, as in
.skip 1
.indent 5
.X <PARSE
.X <MA
COM##><DBSET + MA + PARSE, etc.
.skip 1
A switch is set off by inclusion of
.skip 1
.indent 5
.X <DBG
DBGn = 0
.skip 1
The switch specifications are:
.skip 1
.left margin 25
.indent -15
switch name####on means
.break
.indent -15
-----------####--------
.skip 1
.indent -15
.X <DBG1
.X <DCL
.X <BDCL
.X <RETURN
.X <BRETURN
DBG1###########DCL, BDCL, RETURN, BRETURN process
.INDEX System ^Stack
.x Chartnames
chartnames, etc -- see System Stack; ><DMP is defined and callable
.INDEX Program ^Status ^Display
with ;G -- see Program Status Display
.skip 1
.indent -15
><DBG2###########><IZVAR adds symbols to module.><REL file
.skip 1
.indent -15
.X <SYSUP
><DBG3###########escape is armed in SYSUP; see Processing of Monitor
Controlled Interrupts
.subtitle System Stack
.page
.index System ^Stack
.left margin 10
.skip 1
.center 80
System Stack
.skip 1
.index <RXP
.index <stack pointer
.index <r15
.x <RXP
r[RXP_#],r15, is used as a stack pointer for all TBA-internal system
linkage.
Positions on the stack are allocated for parameter values, local
variables and the return address.
.INDEX chartnames
If ><DBG1 is defined, then names of charts and variables are also stacked.
The structure of the stack is defined by
.skip 1
.left margin 15
.indent -5
rxp syntax
.break
.indent -5
----------
.skip 1
>rxpstk = mark >cvec-string
.skip 1
##mark = nil | -1
.skip 1
##>cvec = >ret >cname >par-string >parcnt
.skip 1
.x Chartnames
#>cname = nil | chartname
.skip 1
>parcnt = nil | paramcount
.skip 1
###>par = >pname pval
.skip 1
#>pname = nil | paramname
.skip 1
##pval = paramvalue
.skip 1
###>ret = return address
.x Return ^Address
.skip 1
.left margin 10
rxp semantics
.break
-------------
.skip 1
The ><RXP stack is a sequence of single-word values, the last of which
is pointed to by register RXP_#.
If ><DBG1 is not defined, then "mark", "cname", "parcnt", and
"pname" are not stored on the stack and no position
is allocated for them (hence, "nil").
.x Chartnames
"chartname" and "paramname" are stored in Sixbit, right justified,
with leading blanks.
"paramcount" is the number (possibly zero) of "par" entries in
its particular "cvec".
.subtitle User Symbol Table
.page
.index User ^Symbol ^Table
.skip 1
.center 80
User Symbol Table
.skip 1
In normal production, the user should have no real need to load his
.X <DDT
compiled program into DDT.
.skip 1
During TBA development, however, and perhaps during the use of TBA
to develop applications systems, the availability of user symbols may
be convenient.
Therefore, when the System Debug Switch ><DBG2 is on, ><IZVAR will put out
user symbols on the module.><REL file.
.skip 1
Appropriate >blocknames will be put out to isolate symbols.
The block name will be either the procedure name or, if the main
program, the module name.
The anonymous module will be named .MAIN.
.skip 1
The left six chars of long names will be used.
Resolution of duplicates is not yet specified.
.subtitle User-Supplied Routines
.page
.index User-^Supplied ^Routines
.skip 1
.center 80 
User-Supplied Routines
.skip 1
Routines to be loaded with TBA programs must follow certain rules
of neighborliness.
The rules currently known are:
.skip 1
.left margin 20
.indent -5
1.###register usage must follow the conventions described in the section
Register Usage
.skip 1
.indent -5
2.###channel numbers must be supplied by the monitor when needed
.skip 1
.indent -5
3.###code loaded into the hiseg must be read-only
.subtitle Program Status Display (DMP)
.page
.index ^Program ^Status ^Display <(DMP)
.index <DMP
.skip 1
.center 80
Program Status Display (DMP)
.skip 1
.left margin 10
.X <DBG1
Under control of an assembly switch, DBG1, the macro ><DCL 
.index chartnames
will stack chart names, parameter names and control counts.
The ><DDT command
.skip 1
.indent 5
.x <DMP
JSR DMP;X
.skip 1
will print out the contents of the stack in a readable form, for
example:
.skip 1
.left margin 15
><TLOC
.skip 1
##T = 000000014030
.skip 1
##R = 777777777777
.skip 1
><CSTV
.break
><COMPIL
.break
TYMBAS
.skip 1
.left margin 10
For each level, the following is printed:
.skip 1
.left margin 15
.index chartnames
chart name; names of parameters and
local variables together with octal values
.skip 1
.left margin 10
.index system ^stack
><DMP leaves all registers unaffected so that a picture of the stack
can be displayed and TBA then continued.
.subtitle Object File Naming Conventions
.page
.Index Object ^File ^Naming ^Conventions
.skip 1
.center 80
Object File Naming Conventions
.skip 1
.left margin 20
.nofill
                  DEBUG      NO DEBUG
              -------------------------
Named         | name.RDL  | name.REL  |
Anonymous     | K00XX.TMP | J00XX.TMP |
Direct Stmt.  | D00XX.TMP | D00XX.TMP |
Source File   |       W00XX.TMP       |
              -------------------------
.fill
.left margin 10
.skip 2
In PARDAT:
.skip 1
.indent 5
CERCNT
.skip 1
.left margin 30
.indent -15
WRKCMP_#0##iff##the current module is the workspace module
.skip 1
.indent -15
MODNM:#BLOCK 5 name of the source file
.skip 1
.indent -15
1st word=0#iff#the current module is an anonymous workspace
.SKIP 2
.LEFT MARGIN 10
-RUN TBA
.BREAK
_>MODULE A
.BREAK
_>NO DEBUG
.BREAK
_>MODULE B
.BREAK
_>10 A=0
.break
_>PRINT A
.SKIP 1
generates:# A.RDL
.BREAK
############B.REL
.BREAK
########J00XX.TMP
.BREAK
########D00XX.TMP
.BREAK
########W00XX.TMP
.BREAK
.subtitle User-Defined Modules and Libraries
.page
.index User-^Defined ^Modules and ^Libraries
.skip 1
.center 80
User-Defined Modules and Libraries
.skip 1
The module list is maintained by use of these data structures:
.left margin 15
.skip 1
><MDUFG -- number of modules
.skip 1
.index <MDUR
.index <MDUN0
.index <MDUN1
.index <MDUN2
.index <MDUN3
.index <MDUN4
.index <MDUPPN
.index <MDUMD
.index <MDUT
REC##MDUR,_<_<MDUN0,36_>,_<MDUN1,36_>,_<MDUN2,36_>,
.break
#####_<MDUN3,36_>,_<MDUN4,36_>,_<MDUPPN,36_>,_<MDUMD,36_>_>
.skip 1
.X <MDUT
.X <MDUR
><TBL##MDUT,20,MDUR
.left margin 20
.skip 1
/MDUMD# -- (not 0) _<=_> (module mode in DEBUG)
.left margin 30
.indent -10
.skip 1
/MDUN0 -- /MDUN4 -- module name in ASCIZ format (possibly with directory name and extension, including parenthesis and "." but will all spaces removed.)
.skip 1
.indent -11
/MDUPPN -- Project-programmer number of directory, if applicable, zero
otherwise
.skip 2
.left margin 10
The library list is maintained by these similar data structures:
.left margin 15
.skip 1
.index <LIBR
.index <LIBN1
.index <LIBN2
.index <LIBN3
.index <LIBN4
.index <LIBPPN
.index <LIBT
REC LIBR,_<_<LIBN0,36_>,_<LIBN1,36_>,_<LIBN2,36_>,
.break
#####_<LIBN3,36_>,_<LIBN4,36_>,_<LIBPPN,36_>_>
.skip 2
.X <LIBT
><TBL LIBT,20,LIBR
/LIBN0 - /LIBN4 -- library name, same format as module name
above
.skip 
/LIBPPN -- same as /MDUPPN
.subtitle Line Reference Table (LRT)
.page
.index Line ^Reference ^Table <(LRT)
.center 80
Line Reference Table (LRT)
.skip 1
.indent -10
.index <LRTE
.index <LRT
.index <LCOD
.index <LNUMB
.index <LTXT
.index <LNXT
.index <LPMC
.index <LSUBN
.index <LCFG
.index <LDFG
.index <LEFG
REC##LRTE,_<_<LCOD,18_>,_<LNUMB,18_>,_<LTXT,22_>,_<LNXT,14_>,
.break
_<LMPC,22_>,_<LSUBN,9_>,_<LCFG,1_>,_<LDFG,1_>,_<LEFG,1_>_>
.skip 1
.indent -5
><TBL##LRT,,LRTE
.skip 1
.left margin 30
.indent -10
/LCOD# -- address of compiled code
.skip 1
.indent -10
/LNUMB -- line number; 100003 =_> deleted entry
.skip 1
.indent -10
/LTXT# -- virtual address of source text
.skip 1
.indent -10
/LNXT# -- recno of successor ><LRT entry
.skip 1
.indent -10
.x <PMC
/LPMC# -- virtual address of PMC's
.skip 1
.indent -10
/LSUBN -- procedure number containing this line (0 = main prog)
.skip 1
.indent -10
.X <COMPIL
/LCFG#####= 0 _<=_> (process line in COMPIL)
.skip 1
.indent -10
.X <DECLAR
/LDFG#####= 1 _<=_ (process line in DECLAR)
.skip 1
.indent -10
/LEFG#####= 1 _<=_> (/LCOD established)
.skip 2
.left margin 10
><LRT is a chained dictionary to the user program. 
The first three entries of ><LRT are always:
.skip 1
.indent 5
.index Direct ^Statements
.X <DSTH
1 = DSTH_# -- direct statement
.skip 1
.indent 5
.X <LSTH
2 = LSTH_# -- dummy last line
.skip 1
.indent 5
.X <FSTH
3 = FSTH_# -- dummy first line
.skip 1
><LRT Index Table -- ><LRXT
.skip 2
The ><LRXT allows rapid lookup of ><LRT entries, given a line
number value:
.skip 1
.indent 4
.index <LRX
.index <LRXL
.index <LRXK
.index <LRXN
.index <LRXSZ
.index <LRXT
.index <LRXRG
REC#--#LRX,_<_<LRXL,18_>,_<LRXK,18_>_>
.skip 1
.indent 4
LRXN -- highest entry num in ><LRXT
.skip 1
.indent 4
LRXSZ_# -- (=100) declared size of ><LRXT arrays
.skip 1
.left margin 20
.indent -6
LRXT[0:LRXSZ_#]><LRXL -- periodically selected line number values,
including endpoints of ><LRT
.skip 1
.left margin 10
.indent 4
LRXT[0:LRXSZ_#]LRXK -- corresponding recid's within ><LRT
.skip 1
.indent 4
LRXRG -- (highest linenum) minus (lowest linenum)
.skip 1
.indent 4
formula for initial guess is:
.skip 1
.indent 4
I = ((LNUM-LRXL[0])*LRXN)DIV LRXRG
.skip 1
><LRXT is setup by ><DECLAR initialization and used subsequently
.X <COMPIL
by both ><DECLAR and COMPIL.
.skip 1
.test page 14
These entries simplify the process of chaining in user lines.
These entries are initialized:
.skip 1
.left margin 15
.nofill
Entry    /LNUM      /LNXT
.break
-----    -----      -----
.skip 1
.X <DSTH
DSTH#    100000     DSTH#
.skip 1
.X <LSTH
LSTH#    100001     ##0
.skip 1
><FSTH#    100002     LSTH#
.skip 1
.fill
.left margin 10
Deleted ><LRT entries have /><LNUMB = 100003.
.skip 1
Note:
.break
.index <LRT
.index <TXT
.index <PMC
New entries are always added to the ends of LRT, TXT and PMC.
.index <RENUMBER
Garbage collection only occurs as a byproduct of ><GET or RENUMBER.
.index Garbage ^Collection
Omitted ><LRT entries are threaded past (besides being given a
special /LNUMB value).
.subtitle Text Area (TXT)
.page
.index Text ^Area <(TXT)
.center 80
Text Area (TXT)
.skip 1
.indent 5
.index <TXT
.index source lines
.X <VTBL
VTBL TXT,7,*
.skip 1
The records of TXT are the source lines of the user program stored
in standard Tymcom X 7-bit ASCII.
.index <LRT
.X <LRT
The lines are retrieved via the LRT.
.subtitle PMC Area (PMC)
.page
.index <PMC ^Area <(PMC)
.skip 1
.center 80
PMC Area (PMC)
.INDEX <PMC
.skip 1
.indent 5
.X <VTBL
VTBL PMC,9,*
.skip 1
.INDEX Parser output
Each record of pmc holds the PMC's (parser output -- preliminary
code) for the corresponding source line.
.X <LRT
Retrieval is via LRT.
.subtitle Name Table (HVX,NAMDIC)
.page
.index Name ^Table <(HVX,NAMDIC)
.skip 1
.center 80
Name Table (NAMT, NAMTB, NAMS)
.index <NAMTB
.index <NAMT
.index <NAMS
.index <HVX
.index <NAMDIC
.index Reserved ^Words
.index User ^Defined ^Symbols
.skip 1
The Name Table stores TBA reserved words and user-defined symbols.
As each new name is entered, the next sequential integer (starting
from 1) is permanently associated with that name. The next integer to
.index <NAMIDX
be assigned is kept in NAMIDX.
.skip 1
The names are kept in core rather than in a ><TBL to allow fast access.
.X <PSIZE
The pager allocates free core in blocks of size PSIZE_# as needed for
additional names. The vector NAMDIC contains core
locations of each allocated block of names. Each name is stored in a
sixbit code which permits 0-9, "." and upper and lower-case letters.
Three words of core are allocated per name: Two and one-half for the spelling and the last halfword for a link to the next name in
that last chain; the link is the name table number (NAMIDX) of that name,
so locating that next name requires a reference to NAMDIC. HVX is a
statistically allocated vector of primary hash links to name table entries.
.subtitle Variable Allocation Address (RXLVAR)
.page
.index Variable ^Allocation ^Address <(RXLVAR)
.index <RXLVAR
.skip 1
.center 80
Variable Allocation Address (RXLVAR)
.skip 1
.X <RXLVAR
.X <DECLAR
The variable RXLVAR, initialized to zero during DECLAR, is the
relocatable loseg address next available to be used for a storage
location.
.index Direct ^Statements
.index source-mod
Source-mod's and direct statements continue to increase RXLVAR.
Only Task 1 (see Task Table) within ><DECLAR will reset RXLVAR to zero.
.subtitle Location Counter (RXLOC)
.page
.index Location ^Counter
.index <RXLOC
.skip 1
.center 80
Location Counter (RXLOC)
.skip 1
The variable RXLOC holds the relocatable address of the
next instruction to be generated; RXLOC is initialized to zero by
.index Direct ^Statements
><COMPIL in Task 4 (see Task Table); direct statements continue
to increase RXLOC.
.subtitle Break Structures (BRKT, BRKTR, BRKN, BRKLX)
.page
.index Break ^Structures <(BRKT, <BRKTR, <BRKN, <BRKLX)
.index <BRKT
.index <BRKTR
.index <BRKN
.index <BRKLX
.skip 1
.center 80
Break Structures (BRKT, BRKTR, BRKN, BRKLX)
.skip 1
BRKT contains all active BREAK information.
.INDEX <RHED
.X <XRUN
.X <RHED
BRKT is maintained by ><PARSE and referenced by XRUN, particularly RHED.
The format is
.skip 1
.indent 5
.INDEX <BKL1
.INDEX <BKL2
REC##BRKTR,_<_<BKL1,18_>,_<BKL2,18_>_>
.skip 1
.indent 5
ARRAY##BRKT[BRKTR:# BRKLX*BRKTR]
.skip 1
The variable BRKN is the current number of entries,(plus one), limit BRKLX,
in BRKT.
.skip 1
Entries are coded:
.left margin 15
/BKL1 -- Low linenum of a range
.skip 1
.left margin 24
.indent -9
/BKL2 -- high linenum of a range (same as /BKL1 if the "range" is a single
line number.)
.skip 1
.left margin 10
Entries are kept sorted from lowest to highest line _# at all times, with
no overlap or duplication.
.skip 1
BRKT is initialized by setting BRKT[0] to 100001,,100001 and
setting BRKN=1.
.subtitle Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)
.page
.index Trace ^Structure <(TRCT, <TRCTR, <TRCN, <TRVT, <TRVTR, <TRCLX, <TRVLX)
.index <TRCT
.index <TRCTR
.index <TRCN
.index <TRVT
.index <TRVTR
.index <TRCLX
.index <TRVLX
.skip 1
.center 80
Trace Structure (TRCT, TRCTR, TRCN, TRVT, TRVTR, TRCLX, TRVLX)
.skip 1
Structure
.skip 1
.left margin 15
.INDEX <TRVN
.INDEX <NOVTN
.INDEX <NOVTRR
.INDEX <NOVL1
.INDEX <NOVL2
varb###TRCN,TRVN,NOVTN
.skip 1
REC##NOVTRR,_<_<NOVL1,18_>,_<NOVL2,18_>_>
.skip 1
.INDEX <TCL1
.INDEX <TCL2
.INDEX <TCVL
REC##TRCTR,_<_<TCL1,18_>,_<TCL2,18_>,_<TCVL,36_>_>
.skip 1
.nojustify
REC##TRVTR,_<_<TRVLC,18_>,_<TRVID,15_>,_<TRVTP,3_>,
.INDEX <TRVLC
.INDEX <TRVID
.INDEX <TRVTP
.INDEX <TRVSP1
.INDEX <TRVSP2
.INDEX <TRVSP3
#####_<TRVSP1,36_>,_<TRVSP2,36_>,_<TRVSP3,36_>_>
.justify
.skip 1
><TRCLX = 15
.skip 1
><TRVLX = 25
.skip 1
ARRAY##TRCT[TRCTR:TRCLX*TRCTR]
.skip 1
ARRAY##TRVT[TRVTR:TRVLX*TRVTR]
.skip 1
.INDEX <NOVTR
ARRAY##NOVTR[NOVTRR: TRCLX*NOVTRR]
.skip 1
.indent -5
Contents
.skip 1
.left margin 25
.indent -10
><NOVTN##-- number of active entries in NOVTR, limit ><TRCLX
.skip 1
.indent -10
><TRCTN# -- number of active entries in TRCT, limit TRCLX
.skip 1
.indent -10
><TRVN###-- number of active entries in TRVT, limit TRVLX
.skip 1
.indent -10
><TRVLX# -- limit on entries in TRVT
.skip 1
.indent -10
><TRCLX##-- limit on entries in TRCT, NOVTR
.skip 1
.indent -10
/TCL1# -- low number of range specified
.skip 1
.indent -10
/TCL2# -- high number of range
.skip 1
.indent -10
/TCVL# -- entry number of associated entry in TRVT (first entry is number 0)
.skip 1
.indent -10
/TRSP1##- 1st 5 charaters of name
.indent -10
.skip 1
.INDEX <TRSP1
.INDEX <TRSP2
.INDEX <TRSP3
/TRSP2##- 2nd five numbers of a name
.indent -10
.skip 1
/TRSP3##- 3rd five characters of name; NULL padded, left justified(ASCIZ
format)
.skip 1
.indent -10
/TRVLC -- relative RXLVAR location of the variable
.skip 1
.indent -10
/TRVID -- identno (><SDT index) of the variable (VARID)
.skip 1
.indent -10
/TRVTP -- type of the variable
.left margin 15
.skip 1
.indent -5
Use
.skip 1
><PARSE maintains all parts of the trace structure except for
TRVT/(TRVLC, TRVTP).
><IZVAR maintains TRVT/(TRVLC, TRVTP)
.skip 1
TRCT is initialized to TRCT: 100000,,100000
.break
#########################+1:#####999
.break
######################with TRCTN=1
.skip 1
TRVT is initialized by setting TRVN=0
.skip 1
NOVTR is initialized to NOVTR: 100001,,100001 with NOVTN=1
.skip 1
NOVTR and TRCT are kept sorted, with no overlap or duplication; TRCT is sorted first on /TCVL, then on line range.
.subtitle Register Usage
.page
.index Register ^Usage
.skip 1
.center 80
Register Usage
.skip 1
.left margin 23
.indent -8
.X <RXJ
RXJ_##--#><JSP register:##procedure calls, ><GOSUB calls, ><RHED calls,
.x <FOR ^Loops
FOR loop body calls
.indent -8
.skip 1
.INDEX <PUSHJ
.X <RXP
RXP_##--#push jump register for system (flowchart and library) calls
and array element accessing
.skip 1
.indent -8
.X <RXO
RXQ_##--#statement origin register (see Statement Orientation)
.skip 1
.left margin 10
Assignments
.left margin 15
.skip 1
#1:# ><RXJ_#
.BREAK
.X <RXO
14:# RXQ_#
.break
.X <RXP
15:# RXP_#
.skip 1
.left margin 10
Note:
Registers 12, 13, 14, and 15 are reserved for dedicated use by TBA.
.skip 1
Generated code currently refers only to registers 0 through#5.
.subtitle Processing of Monitor-Controlled Interrupts
.page
.index Processing of ^Monitor-^Controlled ^Interrupts
.skip 1
.center 80
Processing of Monitor-Controlled Interrupts
.skip 1
.INDEX interrupts
.INDEX Escapes
A stack of locations is maintained to which control is to be
passed when an escape is typed by the user:
.skip 1
.left margin 15
.INDEX <EXSXR
.INDEX <EXLOC
.INDEX <EXRXP
.INDEX <EXSX
.INDEX <EXN
REC##EXSXR,_<_<EXLOC,18_>,
.indent 5
_<EXRXP,18_>_>
.skip 1
Array##EXSX[0:10*EXSXR]
.skip 1
.left margin 30
.indent -7
EXN -- current depth of stack
.skip 1
.indent -10
/EXLOC -- address to resume control
.skip 1
.indent -10
.X <RXP
/><EXRXP -- value to place in r[RXP_#] before passing control
.left margin 10
.skip 1
@EXSX[I*EXSXR] points to the record holding the interrupt
information for the level I.
.skip 1
A set of routines govern whether the interrupt is to
actually be serviced:
.skip 1
.left margin 23
.indent -12
.INDEX <EXOFF
.INDEX <EXPEEK
.INDEX <EXON
EXOFF( ) -- when called, causes escapes to be ignored
.skip 1
.indent -13
EXPEEK( ) -- when called, returns non-zero if an escape has been
ignored since the most recent call to EXOFF( )
.skip 1
.indent -11
EXON( ) -- when called, rearms escapes and, if an escape has been
typed since the most recent call to EXOFF( ), transfers control
according to the top of EXSX[ ].
.subtitle DEBUG/NO DEBUG
.page
.index <DEBUG/NO <DEBUG
.skip 1
.center 80
DEBUG/NO DEBUG
.left margin 10
.skip 1
The system variable ><DEBGSW is set to 1 when DEBUG and 0 when NO DEBUG.
The initial value is 1.
.skip 1
><DEBGSW is noticed by several TBA processes:
.skip 1
.left margin 15
process########(= 0) =_>
.break
-------########--------
.skip 1
BREAK,TRACE,###prohibit yourself
.break
><STEP
.skip 1
><COMPIL#########don't generate calls to ><RHED
.skip 1
><RDIM###########shorter >subscripting code
.left margin 10
.subtitle Numeric Scalars
.page
.index Numeric ^Scalars
.left margin 10
.skip 1
.center 80
Numeric Scalars
.skip 1
.nofill
Numeric Scalars are stored as
.left margin 30
.indent -15
.skip 1
Type###########Format
.indent -15
----###########------ 
.indent -15
.skip 1
logical########one word integer:
0 = FALSE
1 = TRUE
.skip 1
.indent -15
integer########one word integer
.skip 1
.indent -15
real###########one word floating point
.skip 1
.indent -15
double#########KI-10 format double precision floating
.skip 1
.indent -15
.fill
complex########two consecutive single precision floating
values#--#(real part,imaginary part)
.subtitle Type Codes
.page
.left margin 10
.index Type ^Codes
.skip 1
.center 80
Type Codes
.skip 1
The TBA data-type code conventions are:
.skip 1
.left margin 15
type########name######value
.break
----########----######-----
.skip 1
.index logical scalars
.index integer scalars
.index real scalars
.index double precision scalars
.index complex scalars
logical#####><LOG_#########0
.skip 1
integer#####><INT_#########1
.skip 1
real########><REAL_########2
.skip 1
.X <DBL
double######DBL_#########3
.skip 1
.X <CMPLX
.X <CPLX
complex#####CPLX_# or####4
.break
.X <CMPLX
.X <CPLX
############CMPLX_#
.skip 1
.X <STR
string######STR_#########5
.subtitle String Scalars
.page
.index String Scalars
.left margin 10
.skip 1
.center 80
String Scalars
.skip 1
.index String ^Descriptors
.index string body
A string scalar comprises a descriptor and a body.
.skip 1
The descriptor occupies two words:
.left margin 15
.skip 1
0:# body address
.skip 1
1:# curr length | max length
.left margin 10
.skip 1
The body begins on a word boundary and each character
occupies seven bits:
.skip 1
.left margin 21
.indent -6
0:# BYTE(7)C1,C2,C3,C4,C5,C6,C7
.skip 1
.indent -6
1:# BYTE(7)C8, etc
.skip 1
.left margin 10
The fields of the descriptor are accessed via:
.skip 1
.indent 5
.INDEX <SDR
.INDEX <SDADR
.INDEX <SDCL
.INDEX <SDML
REC##SDR,_<_<SDADR,36_>,_<SDCL,18_>,_<SDML,18_>_>
.skip 1
.left margin 30
.indent -10
/SDADR -- address of string body; if zero,
denotes an unallocated string, any reference to which should
be diagnosed
.skip 1
.indent -10
/SDCL# -- number of characters currently stored in the body.
.skip 1
.indent -10
/SDML# -- declared length of the string -- the body has been
allocated enough space to hold this many characters
.skip 1
.left margin 10
The string body is always allocated an integral number of fullwords
and is initialized to all zero bits.
Bit 35 of each body word always remains zero.
Whenever a value is stored into a string, unused character
positions in the last-stored body word are set to zero bits.
Hence, some string operations can be performed on a fullword basis.
.subtitle Messages
.page
.index Messages
.skip 1
.center 80
Messages
.skip 1
Constant messages (prompts, diagnostics, etc.) are not stored
as string bodies with string descriptors.
Instead they are stored in ASCIZ form -- termination is by 
a NUL.
.subtitle Terminal-Related Functions
.page
.index Terminal-^Related ^Functions
.skip 1
.center 80
Terminal-Related Functions
.skip 1
See Tymcom-X Terminal Interface Standards.
The primary data structure involved is the command input stack (CX):
.skip 1
.indent 5
.nojustify
.INDEX <CX
.INDEX <CXR
.INDEX <CXFN
.INDEX <CXLN
.INDEX <CXEP
.INDEX <CXNM
.INDEX <CXNMS
REC####CXR,_<_<CXFN,18_>,_<CXLN,18_>,_<CXEP,12_>,_<CXNM,24_>_>
.indent 5
.skip 1
><FTBL###CX,11,CXR
.skip 1
.indent 5
.X <VTBL
VTBL###CXNMS,60
.skip 1
.left margin 31
.indent -9
/CXFN -- file number; 0 = terminal
.skip 1
.indent -9
/CXLN -- ordinal line number of command most
recently read (at this level)
.skip 1
.indent -9
.INDEX <ECHO
/CXEP -- echo state; 1 = ECHO; 0 = NO ECHO
.skip 1
.indent -9
/CXNM -- record identifier (within CXNMS)
of file nomen
.skip 2
.left margin 10
.justify
When TBA initially starts up, the first entry in CX
is created with
.skip 1
.indent 5
0 -_> CX[0]/(CXFN,CXLN,CXEP)
.skip 1
and with /CXNM referring to the initial entry of CXNMS,
which is 'TERMINAL'.
.skip 1
The (ECHO,NO ECHO) commands simply set CX[0]/CXEP to (1,0).
.skip 1
The variable ><TPOS always holds the current value of ><POS
(carriage position of the physical terminal).
The following utility routines perform terminal-oriented
operations for the TBA system.
.left margin 15
.skip 1
.indent -5
.INDEX <CXCI
.INDEX <TOUT ^Destination
.index Command ^Echo ^Destination
.index Command ^Input
1.###CXCI(#) -- Command Input
.skip 1
Fetch and return a character from the current command source.
No editing is to be performed.
If echo is on, post the character to the ><TOUT destination;
exception: when command input is from terminal, never echo to terminal.
If the character is the first of a new line then increment CX[0]/CXLN.
If the end of file has just been reached (logically speaking),
.INDEX <CXKX
call CXKX(#), and return a NUL (ASCII 0) -- in this case,
the next call to CXCI will access the lower level command source.
.skip 1
.tp 7
Usage Note:
.skip 1
.INDEX <CXCI
><GETLIN will read its characters via CXCI(#).
><PARSE will only call ><GETLIN when the command source is the
terminal; command file input is done via
CXCI(#), directly.
Runtime file input from the * file number will use CXCI(#) directly.
.skip 1
.left margin 15
.indent -5
.index Command ^Files
2.###CXDO(F) -- Open New Command File
.skip 1
F points to a string descriptor which refers
to a string which holds, hopefully, a file-nomen.
The file is to be opened as the command source and a new
level added to CX with all fields appropriately initialized.
CXDO(#) normally returns the value 1.
If for any reason the operation cannot be completed, a value
0 is returned after ><CXER is called with an appropriate
diagnostic message.
.skip 1
.indent -5
.INDEX <CXER
.index Error ^Conditions in ^Command ^File
3.###CXER(E) -- Error Conditions Encountered
.skip 1
An error has been encountered.
E is the address of an appropriate ASCIZ diagnostic message.
Actions a thru c, section VIII of 'Terminal Interface Standards
for Tymcom X' are to be performed.
The Error Message Destination is the ><TOUT destination
and the TERMINAL.
Note:# unstacking does not occur if terminal is command source.
.skip 1
.indent -5
.INDEX <CXKX
.INDEX <CX
.INDEX Echo state
.index Command ^Files, closing
4.###CXKX(#) -- Close Command File
.skip 1
If CX currently contains only one entry (the TERMINAL),
do nothing.
Otherwise, terminate processing from the current command source,
pop CX[0] and revert to the next lower command source.
Note that a prior echo state is thereby reinstated.
.skip 1
.indent -5
.test page 16
.INDEX <CXMO
.INDEX <MOCR
.INDEX <MONOCR
.INDEX <MOSTR
.index Message ^Output
5.###CXMO(MSG,MODE) -- Message Output
.skip 1
A message is to be output.  The value of MODE determines the
coding scheme:
.skip 1
.nojustify
.indent 5
MODE#########################MSG is
.indent 5
 ----#########################------ 
.skip 1
.left margin 35
.indent -20
MOCR_# = 1###########address of ASCIZ message to
which an EOL should be logically appended
.skip 1
.indent -20
MONOCR_# = 2#########address of ASCIZ message;
append no EOL
.skip 1
.indent -20
.X <MOSTR
MOSTR_# = 3##########address of string descriptor;
append no EOL
.skip 1
.left margin 15
.justify
If command source is terminal then post message to terminal.
If echo is on then:
.skip 1
.left margin 20
If ><TOUT File exists, post to it.
.skip 1
Else if terminal not command source, post to terminal.
.left margin 15
.skip 1
Usage Note:
.skip 1
CXMO(#) should be used by TBA for all prompts and messages, as
defined in the Terminal Interface Standards.
.skip 1
.indent -5
.INDEX <CXTI
.INDEX Terminal ^Input
6.###CXTI(#) -- Terminal Input
.skip 1
Fetch and return character from the physical terminal.
Do not echo it anywhere.
Perform no editing.
.skip 1
Usage Note:
.skip 1
CXTI(#) is used for the INPUT statement either where no file is
specified or where the file number refers to the TERMINAL
opened as a numbered file.  CXTI(#) is also used for the
EIGHTI statement.
.skip 1
.left margin 14
.indent -5
.test page 13
.index <CXTDO
.index Terminal-^Directed ^Output
7.###CXTDO(C) -- Terminal-Directed Output
.skip 1
C is a character (ASCII code) to be
posted to the ><TOUT destination.
.skip 1
Usage Note:
.skip 1
CXTDO is intended to perform all Terminal - Directed Output,
as defined in the Interface Standards.
.X <PMC
.X <LIST
This would include output from such commands as LIST, PMC and
><CDE and from the ><PRINT statement where no file number is specified.
If TERMINAL is the ><TOUT destination, then C is posted via CXTO(#).
.skip 1
.indent -5
.test page 8
.index <CXTO
.index Terminal ^Output
8.###CXTO(C) -- TERMINAL Output
.skip 1
Post the character C to the physical terminal.
.skip 1
Implementation Note:
.skip 1
CXTO(#) and CXTI(#) are responsible for maintaining the
variable TPOS.
.skip 1
Usage Note:
.skip 1
CXTO(#) is used for the EIGHTO statement and for the ><PRINT
statement where a file number has been specified which
refers to the TERMINAL.
.subtitle System-Level File IO
.page
.index System-^Level ^File <IO
.index File <IO
.index <IO
.index paging
.skip 1
.center 80
File IO
.skip 1
.left margin 10
Input/output operations on files are performed by a paging algorithm.
For the purposes of this algorithm, files are divided up into
pages. All pages are of the same length and the number of words in a page is always a power of two.
.indent 5
To initiate IO operations on a file, the file must first be created
.index <CREATE
.index <OPENF
.index <CONOPN
or opened by calling one of the routines CREATE, OPENF or CONOPN. 
.index File ^Control ^Blocks
Each of these routines sets up a file control block describing the file
.index Virtual ^Addresses
and returns the "virtual address" of the beginning of the file.  A virtual
address is the address of a word or byte within a file combined with 
a field that identifies the file.  A virtual address therefore
uniquely identifies a specific word or byte of a particular file among
all of the words or bytes in all of the files that are currently active.  
.index Virtual ^Word ^Addresses
Virtual addresses are of two types:  virtual word addresses and 
.index Virtual ^Byte ^Addresses
virtual byte addresses.  A virtual word address contains a high-order
field that identifies a particular file and a low-order field that
contains the address of a word in the file relative to the beginning of
the file (word 0).  A virtual byte address also contains a high-order
field that identifies a particular file, together with a low-order field
that contains the address of a byte in the file relative to the beginning
of the file (byte 0).
.indent 5
Given the virtual address of the beginning of the file, the virtual
address of any word or byte in the file can be constructed by simple 
addition.  In order to access a word of the file, the macro ><READ is used
to translate the virtual word address of the desired word into a core 
address.  Similarly, to access a byte of the file the macro ><READCR is used
to translate the virtual byte address of the desired byte into a core
address.  The way in which this translation is performed will now
be described.
.indent 5
.index Paging ^Algorithm
The paging algorithm first searches a hash table containing one entry
for every page that is currently in core. If the page containing
the required word or byte is present,
 the search will locate it and supply the core address of its first
word. Given this address, the address of the desired word or byte within
the page is then constructed and returned.
.indent 5
If the page is not present in core memory, the paging algorithm must then find a place to store the page in core memory.  To do this, it scans a map
 of the region of memory where
pages are stored, looking for a free space. The map is known as
.index Core ^Table
the core table and the region of memory is referred to as the 
.index Paging ^Area
paging area. In most cases, no free spaces will be available
and the paging algorithm must remove one of the pages currently
in memory to make way for the new page.
.indent 5
In selecting a page to be removed, the algorithm takes three factors
 into account. 
Firstly, a page which is currently being accessed must not be
removed from memory. Secondly, a page which has not been modified
during the time that it has been in memory should be selected ahead of a page which has been modified, because a modified page must be written
back to its file, while an unmodified page may be discarded,
since an up-to-date copy already exists in the file.
Thirdly, the least recently referenced page should be selected, on the
assumption that it is the page which is least likely to be referenced in
the near future.
.indent 5
If a suitable page is found, it is removed from memory. If not, a
space is created by obtaining more core 
memory from the monitor. The desired page is then read into
the vacant space. In the case where a request is made to access
a word or byte that lies beyond the end of the file, a page of zero words
is created and appended to the file.
.indent 5
When the page has been located or brought into memory, a marker is set
in the core table to indicate that the page is in use and must not
be removed by a subsequent scan. The marker is in the form of a count of the number of READ and READCR  operations that have been performed
for the page and not yet cancelled. The count is incremented by each new
><READ or ><READCR operation that references the page.
.indent 5
A ><READ is cancelled by calling either the ><WRITE macro
or the ><FREE macro.  Similarly, a ><READCR is cancelled by calling either the
><WRITCR or ><FREECR macro.  A call to one of these macros signals that the
page is no longer being used and causes the count in the core table 
entry for the page to be decremented. When the count becomes negative,
all outstanding ><READ and ><READCR  requests for the page have been cancelled
and it may be considered for removal from core memory during
subsequent scans of the core table.
.indent 5
At the moment when the count becomes negative, the current value of
a pseudo clock register is stored in the core table entry for
the page so as to record the time of last access to the page.
.indent 5
The WRITE and WRITCR macros are used to inform the paging algorithm that the page
has been modified and must ultimately be written back to the file,
whereas the FREE and FREECR macros are used to indicate that the page has not
been modified and need not be written back to the file
(unless it has been modified by other accesses).
.skip 1
.indent 5
.indent 5
.index Word ^Cursor
The ><READ macro returns a "word cursor".  This is a word containing the
core address of the requested word in its right half and a count of the
number of words between that word and the following page boundary in its
.index Byte ^Cursor
left half.  The ><READCR macro returns a "byte cursor".  This is a standard
PDP10 byte pointer.  The page may be accessed directly, using the
word cursor or byte cursor.  Note that this requires that the user 
.index Page ^Boundaries
should be aware of the existence and location of page boundaries in the
file.  The size of pages used by the pager is specified by the global
.X <PSIZE
assembly-time variable PSIZE.  Its value can be changed by altering the
.X <PEX
value of another global assembly-time variable, PEX.
.skip 1
.X <PSIZE
.indent 5
PSIZE=2**PEX
.skip 1
.indent 5
A set of macros and subroutines is provided that eliminate the need for
users of the pager to be concerned with page boundaries in most cases.
These macros and subroutines transfer a single word, a single byte, a block
of words, or a string of bytes to or from the file.  Each transfer advances
the cursor to the next word or byte in the file, turning pages as required.
When these operations are used, only the first page of the file has to be
read explicitly and only the last page has to be released explicitly.
Following is a summary of the tables maintained by the paging
algorithm.
.left margin 20
.skip 1
.index Channel ^Table
.index File ^Control ^Blocks
(1) Channel table - a table containing the address of the file control block for each active channel.
.skip 1
data in each entry:
.indent 5
-address of file control block
.skip 1
.index File ^Control ^Blocks
(2) File control blocks - structures containing details of each
active file.
.skip 1
format:
.indent 5
COUNT - count of arguments for monitor calls
.indent 5
PTR - relative address of directory name
.indent 5
NAM - file name in 6-bit bytes
.indent 5
EXT - file extension in 6-bit bytes
.indent 5
CON - confirmation information used by CONOPN
.indent 5
LEN - length of file in words
.indent 5
DIR - directory name in 6-bit bytes
.indent 5
CHAN - channel number
.indent 5
NLEN - length of file name in bytes
.indent 5
><STR - file name string in 7-bit bytes
.skip 1
.index Core ^Table
(3) Core table - a table containing information about each page
frame in the paging area
.skip 1
data in each entry:
.indent 5
- use count or age
.indent 5
- page modified indication
.indent 5
- hash table index of page
.skip 1
.index Hash ^Table, ^Paging ^Algorithm
(4) Hash table - a table containing information about each page
currently in core memory
.skip 1
data in each entry:
.indent 5
- virtual page number
.indent 5
- core table index of page
.left margin 10
.skip 2
.index Open and ^Close ^Operations
OPEN AND CLOSE OPERATIONS
.skip 1
1. ><CREATE creates a new file (or a new version of 
an existing file) and opens it for reading and writing,
bypassing the confirmation procedure. It returns a result indicator
and the virtual address of word zero of the file. CREATE is a
subroutine.
.skip 1
Parameters
.skip 1
R0 - address of a file name string
.break
A file name string is a string of left-justified 7-bit bytes
in the following format:
.skip 1
.lm -6
S[(S_<directory_>S)]S_<file name_>[.[_<extension_>]]S[-S_<confirmation_>S]N
.lm +6
.skip 1
Where [,] denotes optional items
.indent 5
S denotes a string of zero or more spaces
.indent 5
N denotes the null character (000)
.skip 1
.index Default ^Extension
R1 - default extension string to be used if the file name string
contains no explicit extension. The string should be left justified.
If no extension is required, this parameter should be zero.
.skip 1
Results
.skip 1
R1 - result indicator
.indent 5
1 if file successfully created
.indent 5
0 if error detected (an error message will have been printed)
.indent 5
-1 if the file name is "TERMINAL"
.break
R2 - virtual address of word zero of the file
.break
R3 - address of a copy of the file name string in edited form
.skip 2
2. ><OPENF opens a file for reading and writing, bypassing the
confirmation procedure. It returns a result indicator and the virtual address of word zero of the file. OPENF is a subroutine.
.skip 1
.test page 5
Parameters
.indent 5
R0 - address of a file name string.
.indent 5
R1 - 0 if file is to be opened for reading only.
.indent 5
#####1 if file is to be opened for both reading and writing.
.skip 1
Results
.indent 5
R1 - result indicator as for CREATE.
.indent 5
R2 - virtual address of word zero of the file.
.indent 5
R3 - address of a copy of the file name string in edited form.
.skip 2
3. ><CONOPN creates a new file if no file exists or opens an existing
file using the full confirmation procedure specified by Tymshare. 
It returns a result indicator and the virtual address of word 
zero of the file.
.skip 1
Parameters
.indent 5
R0 - address of a file name string
.indent 5
R1 - 0 open file for reading only.
.indent 4
#####-1 validate file name only
.indent 4
######1 open file for both reading and writing.
.indent 5
.index Default ^Extension
R2 - default extension string to be used if the file name string contains no explicit extension. The string should be left 
justified.
.skip 1
Results
.indent 5
R1 - result indicator as for CREATE.
.indent 5
R2 - virtual address of word zero of the file.
.indent 5
R3 - address of a copy of the file name string in edited form.
.skip 1
.X <CREATE
4. ><CLOSEF closes a file that has previously been opened by a CREATE,
.X <CONOPN
><OPENF or CONOPN. It removes all pages of the file from core (even if they are locked) and writes them back to the file if necessary.
 CLOSEF is a subroutine.
.skip 1
Parameter
.indent 5
R0 - virtual address of any word or byte of the file.
.skip 2
5. DELETE deletes a file that has previously been opened
by CREATE, OPENF or CONOPN. It removes all pages of the file from core (even if they are locked).
Delete is a subroutine.
.skip 1
Parameter
.indent 5
R0 - virtual address of any word or byte of the file
.skip 1
Result
.indent 5
R1 - result indicator
.indent 5
#####1 if successful
.indent 5
#####0 if deletion not permitted
.skip 2
.page
.index Word-^Oriented <IO
.index <IO, ^Word-^Oriented
WORD-ORIENTED IO
.skip 1
1. ><READ converts a virtual word address into a word cursor. It takes the
virtual word address stored in the location specified by the effective
address and replaces it by the corresponding word cursor. READ is a macro.
.skip 1
Parameter
.indent 10
1-address of word containing the virtual address
.skip 1
.indent 5
The page containing the address will remain in core until a 
><WRITE or ><FREE operation is performed.
.skip 2
2. ><WRITE releases a page that is no longer required so that
it may be written back
to its file.  It takes the word cursor in the location 
specified by the effective address and releases the page containing
that address.  It also overwrites the word cursor with the 
corresponding virtual word address.
 WRITE is a macro.
.skip 1
Parameter
.indent 10
1-address of word containing the cursor
.skip 1
3. ><FREE releases a page that is no longer required so that it
may be removed from core memory. Its operation is similar to that of 
WRITE, except that the page is simply removed from core memory
and is not written back to its file. FREE is a macro.
.skip 1
Parameter
.indent 10
1-address of word containing the cursor
.skip 1
.indent 5
A READ  operation should always be paired with either a WRITE or a 
FREE. If the number  of READs performed on a page does not match
the number of WRITEs and FREEs, the page will either remain in core
indefinitely or will be released prematurely.
.skip 2
4.  ><IN reads a word from a file.  It takes the word cursor in a
designated register and loads the word at that file address into a
specified register.  It then advances the cursor so that it points to
the next word of the file.  IN is a macro.
.skip 1
Parameters
.indent 10
1-number of register that is to receive the word
.indent 10
2-number of register containing the cursor (should not be register zero)
.skip 1
Parameters one and two should not specify the same register.
.skip 2
5.  ><OUT writes a word into a file.  It takes the word cursor
in a designated register and stores the contents of a specified register
into that file address.  It then advances the cursor so that it points to
the next word of the file.  OUT is a macro.
.skip 1
Parameters
.indent 10
1-number of register containing the word
.indent 10
2-number of register containing the cursor (should not be register zero)
.skip 1
Parameters one and two should not specify the same register.
.skip 2
6.  ><TFR transfers a group of consecutive words from an area of memory to
a file or from a file to an area of memory.  TFR also advances the word
cursor to point to the next word of the file beyond the area transferred.
TFR is a subroutine.
.skip 1
Parameters
.indent 10
R0 - number of words to be transferred
.indent 10
R1 - word cursor
.indent 10
R2 - memory address
.indent 10
R3 - direction of transfer
.break
###############0 read into memory
.break
###############1 write into file
.skip 1
Results
.indent 10
R1 - updated cursor
.indent 10
R2 - updated memory address
.skip 2
7.  ><STEP moves a word cursor backward or forward a specified number
of words from its current position.  If the cursor crosses a page boundary
it will either WRITE or FREE the current page as required.  ><STEP is a
subroutine.
.skip 1
Parameters
.indent 10
R0 - positive or negative number of words
.indent 10
R1 - word cursor
.indent 10
R2 - 0 if current page to be freed
.indent 15
1 if current page to be written
.skip 1
Result
.indent 10
R1 - updated word cursor
.skip 3
.page
.index Byte-^Oriented <IO
.index <IO, ^Byte-^Oriented
BYTE-ORIENTED IO
.skip 2
1.  ><READCR converts a virtual byte address into a byte cursor.  It takes
the virtual byte address stored in the location specified by the effective
address and replaces it by the corresponding byte cursor.  READCR is a 
macro.
.skip 1
Parameters
.indent 10
1-address of word containing virtual byte address
.indent 10
2-size of byte in bits
.skip 2
2.  ><WRITCR releases a page that is no longer required so that it may be 
written back to its file.  It takes the byte cursor in the location specified
by the effective address and releases the page containing that address.
It also overwrites the byte cursor with the corresponding virtual byte
address.  WRITCR is a macro.
.skip 1
Parameter
.indent 10
1-address of byte cursor
.skip 2
3.  ><FREECR releases a page that is no longer required so that it may be 
removed from core memory.  Its operation is similar to that of WRITCR, except
that the page is simply removed from core memory and is not written
back to its file.  FREECR is a macro.
.skip 1
Parameter
.indent 10
1-address of byte cursor
.skip 2
4.  ><INCR reads a byte from a file.  It takes the byte cursor in the 
location specified by the effective address and advances it so that it points
to the next byte in the file.  It then loads that byte into a specified 
register.  INCR is a macro.
.skip 1
Parameters
.indent 10
1-number of register that will receive the byte
.indent 10
2-address of byte cursor
.skip 1
Note that the mnemonic ILDBV may be used interchangeably with INCR.
.skip 2
5.  ><OUTCR writes a byte into a file.  It takes the byte cursor in the
location specified by the effective address and advances it so that 
it points to the next byte in the file.  It then stores the byte from a
specified register into that byte position.  OUTCR is a macro.
.skip 1
Parameters
.indent 10
1-number of register containing the byte
.indent 10
2-address of byte cursor
.skip 1
Note that the mnemonic IDPBV may be used interchangeably with OUTCR.
.skip 2
6.  ><TFRSTR transfers a group of consecutive bytes from an area of memory
to a file or from a file to an area of memory.  It advances the byte 
cursor to point to the next byte of the file, transfers the specified
number of bytes starting at that position, and leaves the byte cursor
pointing to the last byte transferred.  ><TFRSTR is a subroutine.
.skip 1
Parameters
.indent 10
R0 - number of bytes to be transferred
.indent 10
R1 - byte cursor
.indent 10
R2 - word address of memory area
.indent 10
R3 - direction of transfer
.indent 15
0 file to memory
.indent 15
1 memory to file
.skip 1
Result
#####R1 - updated byte cursor
.skip 2
7.  ><STEPCR moves a byte cursor backward or forward a specified number of bytes
from its current position.  If the cursor crosses a page boundary, ><STEPCR
will either WRITE or FREE the current page as required.  ><STEPCR
is a subroutine.
.skip 1
Parameters
.indent 10
R0 - positive or negative number of bytes
.indent 10
R1 - byte cursor
.indent 10
R2 - 0 if current page to be freed
.indent 15
1 if current page to be written
.skip 1
Result
.indent 10
R1 - updated byte cursor
.skip 3
MISCELLANEOUS ROUTINES
.skip 2
1.  MARK sets a marker associated with a page that will cause the page
to be written back to its file when the page is released.  MARK is mainly
useful when a file is being accessed simultaneously for both reading
and writing.
.indent 5
The sequential output operations OUT, OUTCR, TFR, and ><TFRSTR all
turn the pages of a file as they advance through it.  As the cursor moves
to the next page, the previous page is released by a WRITE operation.
Similarly on input, IN, INCR, TFR, and ><TFRSTR release pages by a FREE
operation.  When input and output operations are interleaved, output may
occur within a page, but the page boundary may be crossed during an input
operation, so that the modified page will not be written back to its file.
To avoid this problem, when input and output operations are 
occurring on the same file, every output should be followed by a MARK 
operation.  MARK is a macro.
.skip 1
Parameters
.indent 10
1-number of register containing a word or byte cursor 
.indent 10
(should not be register zero)
.skip 1
MARK does not alter the contents of the register.
.skip 2
2.  ><LOCK causes a page to be locked in core so that normal page turning 
operations of sequential IO will not remove it from core memory.
.indent 5
For example, suppose that a file is being scanned sequentially using
IN operations.  Suppose also that at some point in the scan, a pointer
to a section of the file needs to be retained, even though the scan
through the file should continue.  To prevent the desired page from
being released when the scan passes on to the following page, a LOCK 
operation is performed on the first page.
.indent 5
Every LOCK operation should be paired with a WRITE, FREE, WRITCR, or FREECR
operation to unlock the page when it is no longer required.  LOCK is
a macro.
.skip 1
Parameter
.indent 10
1-number of register containing a word or byte cursor 
.indent 10
(should not be register zero)
.skip 1
LOCK does not alter the contents of the register.
.skip 2
3.  ><FCB obtains information about a currently open file.  Specifically, it
returns the address of the file control block for the file.  As previously
described, this block contains the file name, length, project-programmer
number, etc.  FCB is a macro.
.skip 1
Parameter
.indent 10
1-number of register containing the virtual
.indent 10
address of any word or byte in the file
.indent 10
(should not be register zero)
.skip 1
Result
.indent 10
1-address of file control block in same register
.indent 10
as above
.skip 2
4. ><TRANSFER is a basic IO subroutine that writes information to a file
or reads information from it. The core address and file
addresses of the information and the length of the transfer are all specified explicitly by the caller.
.skip 1
Parameters
.indent 5
R0 - core address of first word
.indent 5
R1 - virtual address of first word
.break
#####(must be a multiple of 128)
.indent 5
R2 - number of words to be transferred
.indent 5
R3 - direction of transfer
.indent 10
0 -read
.indent 10
1 - write
.subtitle Program-File Formats
.page
.index Program-^File ^Formats
.skip 1
.center 80
Program-File Formats
.skip 1
The ><SAVE command creates a very straightforward file.
Each line is terminated by a CR LF.
There are no tabs or special line-number or page-mark codes.
A line may be split between blocks;
the file is an uninterrupted stream of data characters.
The last block is filled out, if not full, with NULs.
.skip 1
.subtitle Get-File Formats
.page
.index ^G^E^T-^File ^Formats
.X <GET
.skip 1
.center 80
GET-File Formats
.skip 1
The ><GET command accepts a broader class of files than that created
.X <SAVE
by SAVE.
Only printable characters and blanks are allowed within a line
(no control characters or carriage returns or line feeds may be
interior to the line).
.skip 1
.index Ampersand
.index Line ^Continuation
.index Linefeed
When a non-empty input line is terminated by an ampersand, the
following line is to be logically appended.
The sequence ampersand,carriage return,linefeed is
replaced in the TBA input buffer by the single character
linefeed.
Linefeed characters are totally ignored by the parser.
.X <SAVE
When text is output by TBA (under LIST, SAVE, etc.)
the interior linefeeds are retranslated into ampersand,carriage
return,linefeed.
Under editing, the linefeed prints as 
ampersand, return,linefeed, but is treated as a single character --
thus it will be copied by a _&C and deleted by _&N.
.skip 1
.index Page ^Marks
.index Form ^Feeds
.index Sticky ^Line ^Numbers
Page marks, form feeds and sticky line numbers are ignored at
the beginning of a line (see EDIT10 manual, pp.#20, 21).
NULLs are ignored at the end of a line.
.index Bit 35
Any other occurrences of a bit 35_#0 is diagnosed "non-symbolic
file" and input is terminated.
Any other occurrence of an illegal character is diagnosed
and the line is discarded.
An overlong line is diagnosed and discarded.
.skip 1
.subtitle DUMP REFS and Tempcor Files
.page
.index <DUMP <REFS and ^Tempcor ^Files
.skip 1
.center 80
DUMP REFS and Tempcor Files
.skip 1
.index <TMPCOR files
Tempcor files are a special kind of file used for communication
between programs.
In particular, the ><CROSS program obtains information about which .CRF
files exist by examining a particular tempcor file, named 'CRE'.
This tempcor file may either exist in core, under the name 'CRE',
or it may exist on disk under the name 'nnnCRE.TMP',
where nnn represents the job number of the current job.
.skip 1
The DUMP REFS command performs two functions.
First it creates an appropriate .CRF file.
Secondly, if appends the name of the created file to the end
of the CRE tempcor file.
The following algorithm should be followed when this appending is done:
.test page 28
.skip 6
.center 80
read current
.center 80
CRE from core
.skip 2
.center 80
no####################yes
.center 80
found?
.skip 3
.center 80
#####read from###############rewrite updated
.center 80
#####disk####################CRE on disk
.skip 1
###no##############yes
.break
#########found?
.skip 1
write on#######update
.break
disk###########on disk
.skip 6
.title TYMBASIC GID -- ><DECLAR
.subtitle Declaration Processing (DECLAR)
.page
.index Declaration ^Processing <(DECLAR)
.X <DECLAR
.skip 1
.center 80
Declaration Processing (DECLAR)
.skip 1
.X <DECLAR
The module DECLAR, as the first pass in compiling the user's
.index <PMC
program, reads the pmc's for declarative statements and
.INDEX <DATA ^Statement
DATA statements.
From that information, ><DECLAR compiles the data structures
.index <LRT
.index <LSUBN
.X <DTAV
.X <SDT
.X <PRODT
.X <PARDT
DTAV, SDT, PRODT and PARDT; sets the values of LRT/LSUBN; clears
.INDEX <LEFG
.INDEX <LCOD
LRT/LEFG; and verifies matching of DEF/ENDFs.
.skip 1
Subsequent modules are responsible for these partially
declarative tasks:
.skip 1
.indent 5
(1)##Establishing LRT/LCOD
.skip 1
.indent 5
(2)##Setting LRT/LEFG
.skip 1
.skip 1
If an error is encountered during the processing of a line, a
.INDEX <CXER
diagnostic is printed (via CXER) and processing continues with
the succeeding declarative line.
If errors have been found when ><DECLAR finishes, control is passed to
.X <PARSE
PARSE.
.skip 1
See Task Table and Transition Table.
.subtitle Symbol Definitions (SDT, PRODT, PARDT)
.page
.index Symbol ^Definitions <(SDT, <PRODT, <PARDT)
.index <SDT
.index <PRODT
.index <PARDT
.skip 1
.center 80
Symbol Definitions (SDT, PRODT, PARDT)
.skip 1
The ><SDT contains entries describing each symbol found in the module.
Each symbol with a unique spelling is assigned an ><SDT position known as
.x <ID
its ID.
><SDT normally holds the definitions of all global-level variables
of the TBA source program, but during processing (by ><DECLAR or
.index Procedure ^Compilation
.index Parameter ^Definitions
.X <COMPIL
COMPIL) of a procedure body, the parameter and local variable definitions temporarily
supplant global variables of the same spelling.
.X <SDT
The structure of SDT, the Symbol Definition Table, is given by:
.skip 1
.left margin 20
.indent -5
.nojustify
.INDEX <SDTR
.INDEX <SLOC
.INDEX <SUSED
.INDEX <STYP
.INDEX <SKND
.INDEX <SN
REC##SDTR,_<_<SLOC,18_>,_<STYP,3_>,_<SUSED,1_>,_<SKND,2_>,
#####_<SN,9_>,_<SPROCN,12_>_>
.justify
.skip 1
.indent -5
.INDEX <SDT
TBL##SDT,,SDTR
.skip 1
.left margin 25
.indent -5
.X <SLOC
/SLOC# -- ><RXLVAR value (location) of symbol
.skip 1
.indent -5
.X <STR
.X <STYP
.X <LOG
/STYP# -- data type (><LOG_# - STR_#)
.skip 1
.indent -5
.X <SUSED
/SUSED# = 1 _<=_> declaration for this variable has been processed
.skip 1
.indent -5
.x <SKND
/SKND# --
.break
.index <SSCAL
.index <SARY
.index <SPRO
.index <SPARY
SSCAL_# =_> scalar variable
.break
SARY_## =_> array variable
.break
SPRO_## =_> procedure
.break
SPARY_# =_> array parameter
.skip 1
.indent -5
/SN### -- 
.break
/SKND = (SARY_# or SPARY_#) =_> number of #####dimensions (limit 10)
.break
/SKND = SPRO_# =_> procedure number (limit 511)
.break
(PRODT record number) else unused
.skip 1
.indent -5
.x <SPROCN
/SPROCN -- ID of procedure to which this variable is local
.skip 1
.left margin 10
.X <MINLV
RXLVAR values are assigned beginning with MINLV_#, and increasing by
the number of words statically allocated to each symbol 
(see Numeric Scalars, String Scalars, and Arrays.)
.skip 1
.INDEX Symbol ^Types
.index Types, ^Symbol
Types are assigned either by an explicit declaration or by a ><DIM
statement to the appropriate implicit type
.index <NAMT
(the latter requiring examination of NAMT).
The first declaration encountered for a variable will set /SUSED to 1.
A subsequent declaration must agree in type and dimensionality.
.skip 1
.test page 14
For procedures (/SKND=SPRO_#), the procedure number (/SN) locates
.index Procedure ^Compilation
.index <SN
.X <PRODT
the entry for that symbol in PRODT.
><PRODT is structured as follows:
.skip 1
.nojustify
.index <PRODTR
.index <LDRNAM
.index <PPARS
.index <PPFIN
.index <PFXP
.index <PNAM
.index <PMODD
.index <PNP
.index <PFDIM
.i+5;REC##PRODTR,_<_<LDRNAM,36_>,_<PPARS,18_>,_<PPFIN,18_>,_<PFXP,18_>,
.indent 10
_<PNAM,18_>,_<PMODD,9_>,_<PNP,5_>,_<PUSD,1_>,_<PFDIM,4_>_>
.skip 1
.indent 5
><TBL##PRODT,,PRODTR
.left margin 30
.skip 1
.indent -10
/LDRNAM -- radix 50 spelling of the procedure name
.skip 1
.indent -10
/PPARS -- record number in PARDT of initial local or parameter name
.skip 1
.indent -10
/PPFIN -- record number in PARDT of last local or parameter name
.SKIP 1
.INDENT -10
/PFXP# -- fixup address for procedure calls
.skip 1
.indent -10
.INDEX Procedure ^Name
/PNAM# -- ><ID of the procedure name
.skip 1
.indent -10
/PMODD -- mode 0 through 7 as follows:
.skip 1
.nf
0 = normal
1 = TBA ENTRY
2 = EXTERNAL
3 = TBA EXTERNAL (same as 2)
4 = SFO EXTERNAL
5 = CFO EXTERNAL
6 = SIMPL EXTERNAL
7 = BLISS EXTERNAL
.fill
.skip 1
.indent -10
/PNP## -- number of parameters (limit 31)
.skip 1
.indent -10
/PUSD# -- =0 ==_> COMPIL has not yet learned the address of the procedure
.skip 1
.indent -10
/PFDIM -- number of dimensions (for array-valued procedure, else 0)
.skip 1
.justify
.left margin 10
.test page 19
A chain of PARDT entries is associated with each PRODT entry.
These are records beginning with the record number /PPARS and linked through /PARLNK up through record number /PPFIN.
The structure of PARDT is:
.skip 1
.nojustify
.indent 5
.index <PARDTR
.index <PALOC
.index <PATYP
.index <PAKND
.index <PARDT
.index <PASN
.index <PANAM
.index <PAUSD
.index <PROCNO
.index <PARLNK
.index Local ^Variable ^Compilation
.index Name ^Scoping
.index Parameter ^Compilation
REC##PARDTR,_<_<PALOC,18_>,_<PATYP,3_>,_<PAUSD,1_>,_<PAKND,2_>,
.indent 10
_<PASN,9_>,_<PROCNO,12_>,_<PANAM,12_>,_<PARLNK,12_>_>
.skip 1
.indent 5
><TBL##PARDT,,PARDTR
.left margin 30
.skip 1
.indent -10
.x <RXLVAR
.x <PVEC
/PALOC -- same as SLOC in SDT
procedure
.skip 1
.indent -10
/PATYP -- same as STYP in SDT
.skip 1
.indent -10
/PAUSD -- same as SUSED in SDT
.skip 1
.indent -10
/PAKND -- same as SKND in SDT
.skip 1
.indent -10
/PASN# -- same as SN in SDT
.skip 1
.indent -10
/PROCNO -- same as SPROCN in SDT
.skip 1
.indent -10
/PANAM -- ><ID of symbol
.skip 1
.indent -10
/PARLNK -- pointer (link) to next PARDT entry in chain
.skip 1
.justify
.left margin 10
Normally PARDT holds the specification information for each
of the parameters or locals of the corresponding procedure.
.X <COMPIL
During compilation of the procedure (by either ><DECLAR or COMPIL)
body, the param/local fields are swapped with the ><SDT fields of the
corresponding global variable.
The correspondence is:
.skip 1
.indent 5
SDT/(SLOC,STYP,SUSED,SKND,SN,SPROCN)
.indent 17
_<-_>
.indent 5
PARDT/(PALOC,PATYP,PAUSD,PAKND,PASN,PROCNO)
.subtitle DATA Statement Values (DTAV)
.page
.index <DATA ^Statement ^Values <(DTAV)
.index <DATV
.skip 1
.center 80
DATA Statement Values (DTAV)
.skip 1
DATA values are stored by ><DECLAR into DTAV:
.skip 1
.indent 5
.X <VTBL
VTBL##DTAV,,7
.skip 1
.index <DATA ^Statement
Each record consists of the characters from a single DATA statement.
.title Tymbasic GID -- COMPIL
.subtitle Code Generation (COMPIL, Optimization, Direct Statements)
.page
.index Direct ^Statements
.x Direct ^Statements
.index Code ^Generation <(COMPIL, ^Optimization, ^Direct ^Statements)
.index <COMPIL
.index Optimization
.skip 1
.center 80
Code Generation (COMPIL, Optimization, Direct Statements)
.index Direct ^Statements
.skip 1
.X <PMC
><COMPIL generates code for the user program by reading all pmcs in line
.X <SDT
.X <PARDT
.X <PRODT
number order and making reference to (SDT, PARDT, PRODT).
.X <REL
The output of ><COMPIL is the file prog.REL, where prog is the current
><SAVE name.
The only symbols included in prog.><REL are those required to accomplish
linkages to externally supplied routines.
The level of >optimization of the code generated by ><COMPIL is determined
by three principles:
.skip 1
.left margin 20
.indent -5
1.###><COMPIL works primarily from the Operand Data Structure which
provides only local information
.skip 1
.indent -5
2.###operations described in the Runtime Utilities section are performed
by those routines and hence not by open code
.skip 1
.indent -5
3.###generation of special code to take advantage of constant
operands is only done where, in the judgment of the TBA development
team, a significant overall system performance improvement
can be made.
Examples are:
.skip 1
.left margin 30
.indent -5
.index immediate instructions
.index constants
a.###immediate instructions will be generated for constants
where possible
.skip 1
.indent -5
b.###>constants within expressions of a higher type will be converted
at compile time
.skip 1
.indent -5
c.###relational operators involving the constant zero will compile
JUMP instructions
.skip 1
.indent -5
d.###effort on marginal optimizations will be delayed until milestone 8
.skip 1
.left margin 10
.index Direct ^Statements
(See Direct Statements.)
.subtitle Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV, ORAC)
.page
.index Operand ^Data ^Structure <(OPDSTK, <OPDL, <OPDN, <O1P, <O2P, <RGSV, <ORAC)
.index <OPDSTK
.index <OPDL
.index <OPDN
.index <O1P
.index <O2P
.index <RGSV
.index <ORAC
.skip 2
.skip 1
.center 80
Operand Data Structure (OPDSTK, OPDL, OPDN, O1P, O2P, RGSV, ORAC)
.skip 1
The ><PARSE output, ><pmc codes, are in a right-handed polish string which
designates operands and then subsequently presents the operator
which is to operate on them.
The status of the operands, during the compilation of a single
statement, is maintained on the operand stack, OPDSTK.
For both convenience and efficiency, an array of pointers, OPDL,
is maintained to the active entries of the stack.
.skip 1
.indent 5
OPDL[1] thru OPDL[OPDN]
.skip 1
are the addresses of the OPDN active entries. For ease in handling
degenerate cases, OPDL[0] = 0.
An operand is removed from the top of the stack by
.skip 1
.indent 5
-1 + -_> OPDN
.skip 1
and from position K by
.skip 1
.indent 5
-1 + -_> OPDN
.skip 1
.indent 5
OPDL[J+1] -_> OPDL[J] for J = K to OPDN
.skip 1
Thus operands are manipulated in toto by simple pointer operations.
.skip 1
In addition the pointers O1P and O2P are always maintained such that
O1P = OPDL[OPDN-1] and O2P = OPDL[OPDN].
Hence for a binary operator the operands are O1P and O2P.
The action of each operator, besides generating correct code, must
leave all elements of the Operand Data Structure in a correct,
consistent state.
.skip 1
.test page 18
The structure of an operand entry is:
.skip 1
.indent 5
.index <OPDR
.index <OL
.index <OV
.index <OC
.index <OM
.index <OT
.index <ONG
.index <OPDSTK
REC##OPDR,_<_<OL,36_>,_<OV,36_>,_<OC,18_>,_<OM,18_>
.indent 10
_<OT,18_>,_<ONG,18_>_>
.skip 1
.indent 10
OPDSTK[0:159]##Array with room for 40 operand stack entries
.skip 1
.left margin 21
/OC# -- class
.skip 1
/OM# -- Mode
.skip 1
.X <LOG_#
.X <STR
/OT# -- Type (LOG_#:STR_#)
.skip 1
/OL# -- Location
.skip 1
/OV# -- Value
.skip 1
/ONG -- Pending Negation or number of dimensions for arrays
.skip 1
.left margin 10
.test page 14
Operands are categorized on a hierarchical basis with the primary
discriminator being Class:
.skip 1
.left margin 15
/OC#######means
.break
---#######-----
.skip 1
.index <ONSC
.index <OSSC
.index <OMX
.index <OTST
.index <OSC
.index <OSST
.X <STR
ONSC_######Numeric Scalar; /OT not STR_#
.skip 1
.X <STR
OSSC_######String Scalar; /OT = STR_#
.skip 1
OMX_#######Matrix
.skip 1
OTST_######Test
.skip 1
OSC_#######Slice Colon
.skip 1
0SST_######Slice Star
.skip 1
.indent -5
.test page 19
.index <ONSC
For /OC = ONSC_#,
.skip 1
/OM#######means
.break
---#######-----
.skip 1
.left margin 25
.indent -10
.index <OKON
.index <OREG
.index <OLVAR
.index <OUVAR
.index <OSUB
.index <ONG
.x Constants
OKON_######constant is in (/OV,/OL)
.break
.X <CMPLX
.X <CPLX
.X <DBL
###########(/OL = low part of DBL_#; no CPLX_#)
.skip 1
.indent -10
.X <CMPLX
.X <CPLX
.X <DBL
/OREG_######value is in register /OL and, if CPLX_# or DBL_#, in
1 + /OL; [Note:# only registers 0 thru 5 can be involved in any operand]
.skip 1
.indent -10
.X <CMPLX
.X <CPLX
.X <DBL
.X <OTMP
OLVAR_#####(= OTMP_#) value in ><RXLVAR location /OL (and 1+/OL if DBL_# or CPLX_#); ><TQDT rec_#, if any, in /OV
.skip 1
.indent -10
OUVAR_#####User variable; Value in RXLVAR location /OL; absolute
.index Direct ^Statements
addressing needed if compiling a continuable direct statement; 
.index <QV
/QV=variable ID
.skip 1
.indent -10
/OSUB_# (=4) address of value in r[/OL]
.skip 1
.indent -10
.index Value ^Negation
/ONG not 0 _<=_> negation of the value has been deferred; /ONG not used
for OKON_# or OSUB_#
.skip 1
.indent -15
.test page 13
.index <OSSC
For /OC = OSSC_#
.skip 1
.indent -10
/OM#######means
.indent -10
---#######-----
.skip 1
.indent -10
.index Literals
.index <LIT
OKON_######literal, /OL= record_# in LIT
.skip 1
.indent -10
.index Temporary ^Cells
OTMP_######temporary cell; ><RXLVAR location
of descriptor in /OL; ><TQDT record number, if any, in /OV
.skip 1
.indent -10
OUVAR_#####descriptor at RXLVAR location /OL; user variable; 
.index <QV
/QV=variable ID
.skip 1
.indent -10
.index Array ^Elements
/OSUB_#####address of array element in r[/OL], or
><RXLVAR location /OL.
.skip 2
.indent -15
.test page 18
.index <OMX
For /OC = OMX_#,
.skip 1
.indent -10
.index <ONG
.index <OREG
.index <OUVAR
.index <OSUB
.index <OTMP
.index Array ^Dimensions
/ONG -- number of dimensions
.skip 1
.indent -10
/OM#######means
.indent -10
---#######-----
.skip 1
.indent -10
OREG_######operand is a mat value in ><RAC
.skip 1
.indent -10
OUVAR_#####User variable; operand is simply the name of an array; ><RXLVAR location of 
description in /OL; /OV not 0 means operand is array parameter.
.index Array ^Parameters
.skip 1
.indent -10
.index Array ^Elements
OSUB_######User variable; operand is to become an array element; ><RXLVAR location of
descriptor in /OL; prior /ONG opnds on OPDSTK are the subscript expressions; /OV not 0 means operand is array parameter.
.skip 1
.indent -10
OTMP_######opnd is a mat value in a temp cell; RXLVAR location if
descriptor in /OL; ><TQDT rec_#, if any, in /OV
.skip 1
.indent -15
.test page 6
.index <OTST
For /OC = OTST_#,
.skip 1
.left margin 15
.index Relational ^Operation, ^Deferred
the opnd is a deferred relational operation; /OM is the operator
(OLT_#,(=1) OLE_#,(=3) OEQ_#,(=2) ONE_#,(=6) OGE_#,(=5) 
OGT_#,(=7); the prior two operands on OPDSTK are the comparands.
.skip 2
.left margin 10
.test page 17
So as to avoid repetitive searching of OPDSTK to determine which
.index <RGSV
registers are committed to which operands, a status vector, RGSV,
is maintained which, for each register, displays the involvement of
that register in the recently generated code.
For register r (0 thru 5),
.skip 1
.left margin 25
.indent -10
RGSV[r]###means
.indent -10
-------###-----
.skip 1
.indent -10
0##########register unused
.skip 1
.indent -10
.index Register ^Usage
.index <ORSVD
.index Temporary ^Cells
.X <COMPIL
ORSVD_#####register reserved by COMPIL; not saveable in a temp cell
or useable for an operand
.skip 1
.indent -10
n#########register in use by operand OPDL[n]; 0 _< n _< = OPDN
.skip 1
.indent -15
.test page 8
.X <RAC
The variable ><ORAC gives the current status of RAC,
.skip 1
.indent -10
ORAC######means
.indent -10
----######-----
.skip 1
.indent -10
   O_######RAC unused
.skip 1
.indent -10
n#########RAC in use by OPDL[n];0 _< n _< = OPDN
.subtitle Literals (LIT,SLIT)
.page
.skip 2
.center 80
Literals (LIT,SLIT)
.index Literals
.index <LIT
.index <SLIT
.index <LITR
.index <LV
.index <LL
.index <LADR
.index <LTYP
.skip 3
.left margin 20
REC LITR,_<_<LV,36_>,_<LL,36_>,_<LADR,18_>,_<LTYP,18_>_>
.skip 1
><TBL LIT,40,LITR
.skip 1
/LV -- numeric scalar constant
.left margin 27
.indent -7
.skip 1
/LL -- low-order word of numeric scalar, if type is double
.left margin 20
.skip 1
/LADR -- fixup address
.skip 1
.X <VTBL
VTBL SLIT,,7
.skip 2
.left margin 10
.indent 5
Numeric scalar constants are carried on the operand stack until they
are referenced. At that point, a new LIT record is created for
.index String ^Constants
the literal. When a string constant is encountered, the string is stored in the SLIT table. A new LIT record is immediately created, but
the /LADR field is not filled in until the string is referenced. The
operand stack entry for the string carries the LIT record number
in the /OL field.
.subtitle Temp-cell Description Table (TQDT)
.page
.skip 2
.center 80
Temp-cell Description table (TQDT)
.index Temporary ^Cells
.index Temp-cell ^Description ^Table <(TQDT)
.index <TQ^DT, Definition
.skip 2
.left margin 10
.indent 5
Temp-cells which have been allocated by ><COMPIL in the course of 
generating code for expressions are kept track of in TQDT:
.skip 2
.indent 10
.index <TQDTR
.index <TQLV
.index <TQC
.index <TQSZ
.index <TQBSY
REC##TQDTR,_<_<TQLV,18_>,_<TQC,3_>,
.skip 1
.indent 15
_<_<TQSZ,3_>,_<TQBSY,1_>_>
.skip 1
.indent 10
><TBL##TQDT,50,TQDTR
.skip 1
.indent 10
One record in TQDT describes a single temp cell:
.skip 1
.indent 15
/TQLV#--#><RXLVAR value assigned to cell
.skip 1
.indent 15
/TQSZ#--#number of words allocated to cell
.skip 1
.indent 15
/TQBSY#--#(not 0)_<=_>(cell now in use)
.skip 2
.index Function ^Calls
TQDT holds the reusable temp-cells. When a function call
is encountered, anything in the TQDT or in a register
is saved in virgin RXLVAR territory. The new cells created
may not be reused, so they are not entered in the TQDT.
.skip 1
.indent 5
After each statement has been compiled, or after
the currently used temp-cells have been saved, the busy flags are
turned off.
.subtitle Control Stack (CSTK, CSTKP)
.page
.index Control ^Stack <(CSTK, <CSTKP)
.index <CSTK
.index <CSTKP
.skip 1
.center 80
Control Stack (CSTK, CSTKP)
.skip 1
.left margin 10
.index Conditionals, ^Compilation of
Compilation of conditional control structures is governed by the
.index <CSTK
.index <CSTKR
.index <CFXL
.index <CBGL
.index <CMODF
stack, CSTK.
.skip 1
.left margin 15
CSTKP -- always = @CSTK[0]
.skip 1
REC##CSTKR,_<_<CFXL,18_>,_<CBGL,18_>,_<CMODF,18_>_>
.skip 1
><FTBL##CSTK,15,CSTKR
.skip 1
.left margin 20
/CFXL# -- head of fixup chain
.skip 1
/CBGL# -- location of condition evaluation
.skip 1
.left margin 30
.indent -10
/CMODF -- governing conditional:
.left margin 30
.index <IF
.index <WHILE
.index <UNLESS
.index <ELSE
.index <ORIF
CIF_#, CUNLS_#, CWHIL_#, CUNTL_#, CELSE_#, CORIF_# (equal to the corresponding OPTYPE values)
.skip 1
.left margin 10
Whenever a primary conditional (IF, WHILE, UNTIL, UNLESS) is encountered,
an entry is created on CSTK.
The stack supports the bookkeeping for forward references and back
branches (WHILE, UNTIL).
When a secondary conditional (ORIF, ELSE) is encountered, the proper
code is emitted and /CMODF is set to the secondary conditional.
When the ENDIF pmc is reached, proper code is emitted and
CSTK[0] is popped.
.title TYMBASIC GID -- Runside Layout
.subtitle Arrays
.page
.index Arrays
.skip 1
.center 80
Arrays
.skip 1
An array comprises a descriptor and a body.
.index Array ^Descriptors
.index Array ^Bodies
The size of the descriptor depends on the number of dimensions
of the array, while the body size depends on the type and the
current dimension bounds.
.skip 1
For an array of N dimensions, the descriptor has the form:
.skip 1
.nofill
.index <ATAG
.index <ALOC
.index <ABSZ
.index <ABASE
.index <ATYP
.index <ANDIM
.index ^A^L^Bn
.index ^A^U^Bn
.index ^A^C^O^E^Fn
.index <CADR
.index <ADSR
##########-----------------------------
ADSR######[###/ATAG#####][###/ALOC####]
##########[###/ABSZ#####][###/ABASE###]
##########[###/ATYP#####][###/ANDIM###]
+3########[###/ALB0#####][###/AUB0####]
########################:################-Bounds, higher
########################:#################dimensions
+/ANDIM+3#[###/ACOEFO###][###/ACOEF1##]
########################:################-ACOEF's, higher
########################:#################dimensions
+CADR#####[########access code########]
##########[###########################]
##########-----------------------------
.fill
.skip 1
.left margin 20
.nofill
CADR = Code address = /ANDIM+(/ANDIM+1)div 2 + ADSR +3
.fill
.skip 2
.indent -10
The data portion of the descriptor is mapped by:
.skip 1
REC#####ADR,_<_<ATAG,18_>,_<ALOC,18_>,_<ABSZ,18_>,
.break
#####_<ABASE,18_>,_<ATYP,18_>,_<ANDIM,18_>,_<ALB0,18_>,
.break
#####_<AUB0,18_>,_<ALB1,18_>,_<AUB1,18_>,...,
.break
#####_<ACOEF0,18_>,_<ACOEF1,18_>..._>
.skip 1
/ATAG -- Slice tag field. Ignored for "parent" 
.break
#########array, contains bitmap for slices.
.skip 1
/ALOC -- Address of the array body 
.skip 1
/ABSZ -- Array body size
.skip 1
/ABASE -- Computed array base
.skip 1
/ATYP -- Data type of array
.skip 1
/ANDIM -- Number of dimensions
.skip 1
/ALBi -- Lower bound, dimension i
.skip 1
/AUBi -- Upper bound, dimension i
.skip 1
/ACOEFi -- Access coefficient, dimension i
.skip 1
Array Descriptor sizes are determined as
follows:
.skip 1
Number of dimensions######Size in words
.break
--------------------######-------------
.break
#########1######################13
.break
#########2######################19
.break
########n_>2###############5+n+(n+1)div2
.skip 2
.left margin 10
.indent 5
The address of an array element is obtained by executing the
access code section of the array
descriptior. For one and two dimensional arrays the array
subscript values are passed in R1 and R1,R2 respectively. For
the two dimensional case, R1 contains the rightmost
subscript. Subscript values for arrays of higher dimensionality
are passed in the psuedo registers, with PR[0] containing the rightmost
subscript. For all cases the access code call is:
.skip 1
#####><PUSHJ####RXP,CADR####(see above for CADR calculation)
.skip 1
The address of the referenced element is returned in R2.
.skip 1
.indent 5
Subscript bounds testing may take one of two forms
.INDEX <DEBUG
.index Subscript ^Checking
determined by the (DEBUG/NO DEBUG) mode switch. If in
DEBUG mode, each subscript is checked against the bounds for each
dimension. In NO DEBUG mode the calculated element address is tested
to determine if it is within the array body boundaries. Note
that one and two dimensional arrays are always treated as if in
DEBUG mode. If any boundary is exceeded, control is transferred to
the error processing routine.
.skip 1
The body of an array is a contiguous block of storage with the
elements of the array stored consecutively in the order
of right-most subscript varying most rapidly.
For a numeric array, each element is simply the one or two
words required to store a scalar of that type.
.skip 1
.index String ^Array
.index String ^Descriptors
For a string array, each element is a two word string descriptor
of the form:
.skip 1
.indent 5
0:# String body pointer.
.skip 1
.indent 5
1:# Current length,, Maximum length
.skip 1
Note that when the string array is declared, the word (0 | max length)
must be stored as the second word of each element, while zero is
stored in the pointer word.
String bodies must be explicitly allocated as an independent
process by the string processing routines.
.page
.index Array ^Slicing
.skip 1
.center 80
Array Slices
.skip 1
Array slicing logic is currently undefined.
.subtitle Statement Orientation (RHED, BTFG, RXFG)
.page
.index Statement ^Orientation <(RHED, <BTFG, <RXFG)
.index <RHED
.index <BTFG
.index <RXFG
.skip 1
.center 80
Statement Orientation (RHED, BTFG, RXFG)
.skip 1
The code generated for each TBA statement includes an orientation
sequence whose purpose is to support such features as BREAK,
.index <DEBUG
.index <BREAK
.index <TRACE
.index <RESUME
.index <RXO
TRACE, RESUME, continuation after errors, and printout of
offending statements with diagnostics.
The orientation sequence, which is
.skip 1
.indent 5
MOVEI##RXL,linenum
.skip 1
.indent 5
><JSP####RXO,rhed
.skip 1
normally occurs as the first two codes for each line.
The exception is ><DEF statements (see User Defined Procedures), where
some linkage code precedes.
When DEBUG, rhed is the routine RHED; when NO DEBUG, rhed is .#+#1
.X <RXO
and thus simply records the statement location in register RXO_#.
.skip 1
When exit from a TBA statement may be temporary, as in
.skip 1
.nofill
.left margin 15
><GOSUB
><CALL
.index Procedure ^References
.index Conditional ^Processing
.index Diagnostic ^Routines
procedure reference
transfer to condition processor
diagnostic routine
.skip 1
.left margin 10
.fill
.X <RXL
.X <RXO
then the values of r[RXL_#], r[RXO_#] and, in some cases, the location
counter, are saved, so as to support the specified level of
continuability.
The variable BTFG (set by ><XRUN initialization) is non-zero if and
only if at least one of ><BRKN or ><TRCN is non-zero.
The variable RXFG (initialized to BTFG by ><XRUN initialization and
set to 1 if escape is typed) is non-zero if and only if ><RHED should
consider not returning immediately upon being called.
Thus, even in DEBUG mode, interpretative overhead is minimized whenever
no BREAK or TRACE statements are active.
.subtitle Module Orientation (MQHED)
.page
.index Module ^Orientation <(MQHED)
.index <MQHED
.skip 1
.center 80
Module Orientation (MQHED)
.skip 1
The variable MQHED holds the address of the hiseg of the module
currently in control.
This variable is saved and/or set by the execution of the following
situations:
.skip 1
.left margin 15
.index Procedure prologues, <ENTRY
.index Trap ^Handling
.index <XRUN startup
ENTRY procedure prologues
.skip 1
trap handling
.skip 1
><XRUN startup
.skip 1
><EXIT statement
.skip 1
.left margin 10
Whenever MQHED is set or unset to the workspace module,
then BTEG and RXFG are appropriately set.
.subtitle ><GOSUB Processing (RGOSUB, RGRET, GSBSTK)
.page
.index <GOSUB ^Processing <(RGOSUB, <RGRET, <GSBSTK)
.index <RGOSUB
.index <RGRET
.index <GSBSTK
.skip 1
.center 80
><GOSUB Processing (RGOSUB, RGRET, GSBSTK)
.skip 1
A stack, GSBSTK, is maintained on the runside.
GSBSTK holds the return address and the values (at ><GOSUB time) of
.X <RXL
.X <RXO
the register RXL_# and RXO_#.
The statement
.skip 1
.indent 5
><GOSUB line
.skip 1
compiles into
.skip 1
.indent 5
MOVEI##r2,address of line location
.skip 1
.indent 5
.index <RXJ
><JSP####RXJ,RGOSUB
.skip 1
The statement
.skip 1
.indent 5
><RETURN
.skip 1
compiles into
.skip 1
.indent 5
JRST##><RGRET
.skip 1
RGRET restores the stacked items and returns to past the ><RGOSUB call.
If the stack is empty, RGRET prints a diagnostic and causes the
line holding the ><RETURN to be printed.
.subtitle String and Matrix Code
.page
.index String and ^Matrix ^Code
.skip 1
.left margin 10
.center 80
String and Matrix Code
.skip 1
.index Array ^Code
One bit is used to describe each string or array.
.skip 1
.indent 5
0:##User variable, if array.  User variable,
.indent 5
.index Literals
.index Temporary ^Results
array element, or literal, if string scalar.
.skip 1
.indent 5
1:##Temporary result (either array or string)
.skip 1
The flags are found in bits 33 and 35 of r5,
for strings whose addresses are passed in r1 and in r2,
respectively; and in bits 33 and 35 of r0, for arrays
whose addresses are passed in r2 and r3, respectively.
.subtitle FOR Loops
.page
.index <FOR ^Loops
.skip 1
.center 80
FOR LOOPS
.skip 1
A FOR loop is compiled into the following code pattern:
.left margin 25
.skip 1
.nofill
iterpart 1
iterpart 2
 ...
iterpart n
JRST past
.skip 1
.indent -10
body:#####MOVEM##RXJ,><FRET
bodycode
JRST##@><FRET
.indent -10
past:
.skip 1
.indent -15
A multi-line FOR loop ends as follows:
.skip 1
JSP####1,@fret
.indent -10
past:#####MOVEI##1,[JRST 0,0(1)]
MOVEM##1,fret
.skip 1
.indent -15
An iterpart with an upper bound compiles into:
.skip 1
eval initial value
eval step
eval upper bound
convert each to type of itervarb
load initial to AC
AC -_> itervarb
.skip 1
.indent -10
loop:#####compare AC to bound
if done, JRST out
AC -_> itervarb
><JSP##RXJ,body
itervarb + step -_> AC
JRST loop
.indent -10
out:
.skip 1
.indent -15
A ><WHILE or ><UNTIL iterpart compiles to:
.skip 1
eval initial value and step
convert each to type of itervarb
initial -_> itervarb
.skip 1
.indent -10
loop:#####test condition
if done, JRST out
.index <RXJ
><JSP##RXJ,body
step + -_> itervarb
JRST loop
.indent -10
out:
.subtitle FOR Loop Generation (FORSTK, FORP, FORTYP, FORBX)
.page
.index <FOR ^Loop ^Generation <(FORSTK, <FORP, <FORTYP, <FORBX)
.index <FORSTK
.index <FORP
.index <FORTYP
.index <FORBX
.skip 1
.center 80
FOR Loop Generation (FORSTK, FORP, FORTYP, FORBX)
.skip 1
.fill
.left margin 10
Compilation of FOR loops is accomplished using these data
structures:
.skip 1
.left margin 25
.indent -10
FORP## -- always equal to TLOC(FORSTK,0)
.skip 1
.indent -10
FORSTK -- stack to facilitate nested FOR loops; only the top record
is accessed
.skip 1
.left margin 20
FTBL#FORSTC,15,FORSC
.skip 1
.index <FORSR
.index <FVAR
.index <FFXP
.index <FRET
.index <FTYP
.index <FLVAR
.index <FFLG
REC##FORSR,_<_<FVAR,18_>,_<FFXP,18_>,_<FRET,18_>,
.indent 5
_<FTYP,18_>,_<FLVAR,18_>,_<FFLG,18_>_>
.skip 1
.left margin 35
.indent -10
/FVAR# -- varid of itervarb
.skip 1
.indent -10
/FFXP# -- during processing of loop body:# address of JRST around body
During processing of iterparts:# address of head of fix-up chain for
references to the first word of the body.  In the case of SUM, PROD,
MAX and MIN, the body is compiled first, so the address of the
first word of body code goes here.
.skip 1
.indent -10
/FRET# -- RXLVAR address where loop return address is stored.
.skip 1
.indent -10
/FTYP# -- type of itervarb
.skip 1
.indent -10
/FLVAR -- RXLVAR location of itervarb
.skip 1
.indent -10
/FFLG# -- =1 for SUM, PROD, MAX and MIN
=0 otherwise
.skip 1
.left margin 10
FDLV, FDTP, and FDND:# RXLVAR address, type, and number of dimensions
of dummy SUM, PROD, MAX or MIN variable, respectively.
.skip 1
As part of runside initialization of indirect statements, RUNIZL
stores the address of word 2 of the code into each /FRET
location (except for SUM, PROD, MAX and MIN).
This word contains the instruction JRST 0,0(1).
.subtitle User-Defined Procedures
.page
.index User-^Defined ^Procedures
.skip 1
.center 80
User-Defined Procedures
.index Procedures, ^User-^Defined
.skip 1
.left margin 10
Each procedure has an entry point (PEPT) and a parameter
.index <PEPT
.index <PVEC
vector (PVEC).
PEPT is the location (in the hiseg) of the procedure body,
while ><PVEC is the location (in the loseg) of a block which
holds the data local to the procedure.
.index <LRT
.index <LCOD
PEPT is kept in LRT/LCOD for the line of the ><DEF of the
.X <SDT
.INDEX <SLOC
procedure, while ><PVEC is in the SDT/SLOC field of the name of the
procedure.
.skip 1
.index Return ^Address
The first word of ><PVEC holds the return address
for the procedure.
.index Parameters, ^User-^Defined ^Procedure
Successive groups of words hold, in order, the parameters.
The number of words allocated to each parameter depends upon
the kind of parameter.
Numeric scalars are simply allocated the one or two words required
to hold a scalar value of that type.
When the procedure is called, the value of the scalar argument
.X <PVEC
is stored into the allocated portion of the PVEC.
.skip 1
.index String ^Parameters
For a string parameter, two words are allocated for a string
.index String ^Descriptors
descriptor.
At call time, a block of storage is allocated into which the
contents of the argument body is moved.
The descriptor is then set so that
.skip 1
.left margin 24
.indent -7
.index <SDADR
.index <SDCL
.index <SDML
/SDADR = address of allocated block
.skip 1
.indent -7
/SDCL# = /SDML = length of argument, in characters
.skip 1
.left margin 10
.index Array ^Parameter, ^User-^Defined ^Procedures
.X <PVEC
For an array parameter, two items are allocated in PVEC.
.index Array ^Descriptors
First, a single word is used to point to the descriptor
currently being used for the parameter.
Following the array pointer word, storage is reserved for a
descriptor of the appropriate dimensionality.
the pointer word is mapped by:
.skip 1
.indent 5
.index <APR
.index <APLIF
.index <APLOC
REC##APR,_<_<APLIF,18_>,_<APLOC,18_>_>
.skip 1
.indent 10
.index Array ^Parameters, ^Call by ^Value
/APLIF -- ><NAM_# or ><VAL_#
.skip 1
.indent 10
/APLOC -- descriptor address
.skip 1
When an array argument is passed by name, then /APLIF
is set to NAM_# and /APLOC is set to the address of the
descriptor of the argument array.
When an array is passed by value, then a block is allocated
.X <PVEC
to hold a copy of the body, the descriptor in PVEC is set to
.X <VAL_#
describe that copy, /APLIF is set to VAL_#, and /APLOC is
set to point to the ><PVEC descriptor.
References to an array parameter within the body of the procedure
are always carried out indirectly through /APLOC.
.skip 1
.test page 8
One word is reserved in ><PVEC to hold the call time value
.X <RXL
.X <RXO
of register RXO_#; ><EXIT is thus able to restore the
environment of the calling statement.
When an ><EXIT is performed, local parameter bodies are de-allocated:
string parameter bodies are released and /SDADR is set to zero.
.X <VAL_#
.X <NAM_#
For array parameters with /APLIF = NAM_#, /APLIF is set to VAL_#,
and /APLOC is pointed to the ><PVEC descriptor.
.index <ADLN
.index <ADHN
.X <VAL_#
When /APLIF = VAL_#, then the body is released and /ADLN and /ADHN
are set to zero.
.skip 1
It is possible that control may leave a procedure by a ><GO#TO
.index Procedure ^Prologues
rather than an ><EXIT and that the procedure would be subsequently
called.
For this reason, special care must be taken at the time a procedure
is called.
.index String ^Parameters
.index Array ^Parameters
In particular, if any of the string or array parameters hold local
values, these must be released prior to setting ><PVEC to the
new arguments.
.skip 1
When a string or matrix expression is passed as an argument, note that
the body need not be physically copied to a new block.
.X <VAL_#
Such an expression is always an ><RAC entry with ><RACLIF = VAL_#,
.X <PVEC
and can be passed simply by storing ><RACLOC into the PVEC.
.skip 1
For those procedures which have string or array parameters, a location
.index <EXIT point
><PXPT (><EXIT point) is defined.
PXPT heads a sequence of code which releases storage allocated
.index Local ^Parameters
to local parameters.
This code is generated as part of the first ><EXIT compiled for a
.x <EXIT
given procedure, and is used by subsequent EXITs.
.skip 1
.index Procedures, ^String ^Valued
.index String ^Valued ^Procedures
If the procedure returns a string, an extra 2 words are allocated in
the ><PVEC for the descriptor. When the string being returned is a user
variable (global or local), the body must be copied.
.skip 1
The above policies governing procedure linkages are implemented
partly in pure generated code and partly by means of runtime
routines called from the code.
.index <RACAMX
.index <RACASA
.index <RACASS
.index <RXPSS
.index <RXPMX
The routines used are RACAMX, RACASA, RACASS, RXPSS and RXPMX.
After the arguments have been passed, the procedure is called by
.skip 1
.indent 5
.INDEX <RXJ
><JSP###RXJ_#,PEPT
.skip 1
Hence, the first word of the procedure is
.skip 1
.indent 5
.X <PVEC
><PEPT###MOVEM  RXJ_#,PVEC
.subtitle User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)
.page
.index <IO ^Management, ^User
.index User <IO ^Management <(IOCB, <FCB, <FNT, <XINT, <IOCW, ^Channel ^Numbers)
.index <IOCB
.index <FCB
.index <FNT
.index <XINT
.index <IOCW
.index Channel ^Numbers
.skip 1
.center 80
User IO Management (IOCB, FCB, FNT, XINT, IOCW, Channel Numbers)
.skip 1
TBA features a sophisticated IO system:# more than one IO statement can
.index <IO ^Statements, ^Multiply ^Active
be simultaneously active; errors and end of file can be independently
trapped for each file; IO may be performed by user-supplied routines
independently of the TBA IO system; >license can be set and
manipulated within TBA; random access is supported on a
character, word or record basis.
.skip 1
The user may designate (in an ><OPEN or ><ON condition statement)
any (unique per file) integer from 0 to 20 as a file number.
.skip 1
.index <FNT
.index <FCB
.index File ^Control ^Blocks
.index <INPUT
.index <PRINT
The array FNT[0:20], initially all 0, is set to the address of a
dynamically allocated file control block (FCB) when a file number
is first referenced in an OPEN or ON condition statement.
If an INPUT or ><PRINT statement references an FNT entry which is zero,
the condition is diagnosed.
.skip 1
An FCB contains the following kinds of information:
.skip 1
.left margin 20
.indent -5
#1.##whether file is open or closed
.skip 1
.indent -5
#2.##file nomen
.skip 1
.indent -5
#3.##count of elements left in current buffer
.skip 1
.indent -5
#4.##file size
.skip 1
.indent -5
#5.##mode in which file was opened
.skip 1
.indent -5
#6.##current cursor position
.skip 1
.indent -5
#7.##location and number of allocated buffers
.skip 1
.indent -5
#8.##channel number assigned to file
.skip 1
.indent -5
#9.##error number of most recent error condition occurring on
this file
.skip 1
.indent -5
10.##a byte pointer within current buffer to element just processed
.skip 1
.left margin 10
Whenever a file is closed the FCB will be released and the FNT entry
reset to 0.
.skip 1
During the life of the IO statement, the IOCB contains all status
information required for the operation of the element processing
routines (cf. above).
In essence, the element processing routines are designed to be serially
re-entrant with non-temporary local variables indexed off of the
IOCB address.
Some of the information in the IOCB is:
.skip 1
.left margin 20
.indent -5
1.###the file number (providing a link to the FCB)
.skip 1
.indent -5
2.###the displacement off ><DSAORG of a dynamically allocated block
holding the FORM or IMAGE (if any)
.skip 1
.indent -5
3.###the current scan point within the FORM or IMAGE
.skip 1
.left margin 10
Note the possibility that in between successive calls to element
processing routines for a given IO statement, the file involved could
be closed or otherwise seriously affected.
.skip 1
Therefore whenever an element processing routine is called, it first
validates the consistency of the operation being requested with the
current status of the associated FNT and FCB structures.
For efficiency, the significant data (symbolic vs binary, input vs
output, formatted vs free format, etc.) are packed into a
single word in the IOCB and the FCB.
Thus a single logical mask and test can be used to validate the
file/operation consistency.
.skip 1
.test page 5
When a file is opened, the monitor is asked to supply a free
channel number to be used and placed in the FCB.
Thus TBA will avoid using a channel already being used by a
user-supplied routine.
Similarly a user-supplied routine should not
expect pre-assembled channel assignments.
.title TYMBASIC GID -- Runside Routines
.no subtitle
.page
.skip 1
.center 80
RUNSIDE ROUTINES
.skip 1
.left margin 15
.indent -10
.index <RSLEN
.INDEX String ^Length
0.##RSLEN##--#LENGTH(string S)
.skip 1
.indent -5
in
.break
r2##--#S
.break
r5##--#string code
.skip 1
.indent -5
out
.break
r1##--#integer LENGTH(S)
.skip 2
.indent -10
.INDEX <RSBLK
.index Blank ^String
1.##RSBLK##--#blank string
.skip 1
.indent -5
input
.break
r1##--#requested length may be zero
.break
r4##--#address of result
.skip 1
.indent -5
do
.break
return a string of (r1) blanks
.skip 2
.indent -10
.index <RSVL1
.index String ^Value
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
2.##RSVL1##--#string value
.skip 1
.indent -5
input
.break
r2##--#string
.break
r5##--#string code
.skip 1
.indent -5
output
.break
r1##--#Real
.skip 1
.indent -5
do
.break
convert the string to a numeric value in free format
.skip 2
.indent -10
.index <RSST1
.index Numeric to ^String ^Conversion
.index Conversion, ^Numeric to ^String
3.##RSST1##--#STR(X)
.skip 1
.indent -5
in
.break
AC#--#X
.break
r5#--#type
.break
r4##--#address of result
.skip 1
.indent -5
output
.break
STR(X)
.skip 2
.indent -10
.index Left ^Substring
.index Substring
.index <RSLFT
4.##RSLFT##--#left substring
.skip 1
.indent -5
input
.break
r1##-#number of characters
.break
r2##--#string
.break
r5##--#string code
.break
r4##--#address of result
.skip 1
.indent -5
do
.break
return the left (r1)characters of the string
.skip 2
.indent -10
.index Right ^Substring
.index Substring
.index <RSRGT
5.##RSRGT##--#right substring
.skip 1
.indent -5
input
.break
r1##--#number of characters
.break
r2##--#string
.break
r4##--#address of result
.break
r5##--#string code
.skip 1
.indent -5
do
.break
return the right (r1)characters of the string
.skip 2
.indent -10
.index Substring
.index <RSBN2
6.##RSBN2##--#SUBSTR(S,N)
.skip 1
.indent -5
input
.break
r1##--#N (integer)
.break
r2##--#S (string)
.break
r4##--#address of result
.break 
r5##--#string code
.skip 1
.indent -5
output
.break
substring
.skip 2
.indent -10
.index <INDEX
7.##RNDX2 -- INDEX (S1,S2)
.skip 1
.indent -5
input
.break
r1 -- s1
.break
r2 -- s2
.break
r5 -- string code
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.indent -10
.index String ^Concatenation
.index Concatenation, ^String
.index <RSCAT
.index <RAC
8.##RSCAT##--#(s1+s2)#--#string concat
.skip 1
.indent -5
input (one argument may be in RAC)
.break
r1##--#s1
.break
r2##--#s2
.break
r4##--#address of result
.break
r5##--#string code
.skip 1
.indent -5
output
.break
s1 +s2
.skip 2
.indent -10
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
.index <ASC
.index <RSAS1
9.##RSAS1##--#ASC(S)
.skip 1
.indent -5
input
.break
r2#--#s
.break
r5##--#string code
.skip 1
.indent -5
output
.break
r1##--#ASC(S,5) integer
.skip 2
.indent -10
.index <CHAR
.index <RCHAR
.index Numeric to ^String ^Conversion
.index Conversion, ^Numeric to ^String
10.##RCHAR##--#CHAR(N)
.skip 1
.indent -5
input
.break
r1##--#integer
.break
r4##--#address of result
.skip 1
output
.break
CHAR(N)
.skip 2
.indent -10
.index <LPAD
.index <RSLPD
11.##RSLPD##--#LPAD(S,N)
.skip 1
.indent -5
input
.break
r1#--#integer N
.break
r2##--#string S
.break
r5##--#string code
.break
r4##--#address of result
.skip 1
.indent -5
output
.break
LPAD(S,N)
.skip 2
.indent -10
.index <RPAD
.index <RSRPD
12.## RSRPD# -- RPAD(s,N)
.skip 1
.indent -5
input
.break
r1 -- int N
.break
r2 -- str S
.break
r5 -- string code
.break
r4##--#address of result
.skip 1
.indent -5
 output
.break
RPAD(S,N)
.skip 2
.indent -10
.index <RPT
.index <RSRPT
13.##RSRPT##--#RPT(S,N)
.skip 1
.indent -5
input
.break
r1 -- integer N
.break
r2 -- string S
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
RPT(S,N)
.skip 2
.indent -10
.INDEX <RJUST
.INDEX <RSRJT
14.##--#RSRJT##--#RJUST(S)
.skip 1
.indent -5
input
.break
r2 -- str S
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
RJUST(S)
.skip 2
.indent -10
.INDEX <LJUST
.INDEX <RSLJT
15.##--#RSLJT##--#LJUST(S)
.skip 1
.indent -5
in
.break
r2 -- str S
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
out
.break
LJUST(S)
.skip 2
.indent -10
.INDEX <COUNT
.INDEX <RSCNT
16.##RSCNT##--#COUNT(s1,s2)
.skip 1
.indent -5
in
.break
r1 -- s1 (string)
.break
r2 -- s2 (string)
.break
r5 -- string code
.skip 1
.indent -5
do
.break
calculate COUNT (s1,s2)
.skip 2
.indent -10
.INDEX <RSVL2
.INDEX <VAL
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
17.##RSVL2
.skip 1
.indent -5
input
.break
r1 -- s1
.break
r2 -- s2
.break
r5 -- string code
.skip 1
.indent -5
output
.break
r1 -- real
.skip 1
.indent -5
do
.break
VAL(s1,s2)
.skip 2
.indent -10
.index <STR
.index <RSST2
.index Numeric to ^String ^Conversion
.index Conversion, ^Numeric to ^String
18.##RSST2##--#STR(X,S)
.skip 1
.indent -5
in
.break
r0,r1 -- X
.break
r2 -- S
.break
r3 -- type
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
out
.break
STR(X,S)
.skip 2
.indent -10
.index <SUBSTR
.index <RSBNL
.index Substring
19.##RSBNL##--#substr(s,N1,N2)
.skip 1
.indent -5
input
.break
r1 -- N1 (integer)
.break
r2 -- S(string)
.break
r3 -- N2 (integer)
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
substr (s,N1,N2)
.skip 1
.indent -5
do
.break
perform ><SUBSTR operation
.skip 2
.indent -10
.index <INDEX
.index <RNDX3
20.##RNDX3##--#INDEX(s1,s2,N)
.skip 1
.indent -10
input
.break
r1 -- s1
.break
r2 -- s2
.break
r3 -- N
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.indent -10
.index String to ^Numeric ^Conversion
.index Conversion, ^String to ^Numeric
.index <ASC
.index <RSASC
21.##RSASC##--#ASC(S,N)
.skip 1
.indent -5
in
.break
r1 -- N
.break
r2 -- S
.break
r5 -- string code
.skip 1
.indent -5
out
.break
r1 -- ASC(S,N), integer
.skip 2
.indent -10
.INDEX <TAB
.INDEX <RTAB1
22.## RTAB1 -- TAB(1 arg)
.skip 1
.indent -5
input
.break
r1 -- integer
.skip 1
.break
r4 -- address of result
.indent -5
output
.break
string of spaces
.skip 2
.indent -10
.INDEX <LOC
.INDEX <RLOC
23.## RLOC -- LOC
.skip 1
.indent -5
input
.break
r1 -- integer
.skip 1
.indent -5
output
.breAk
r1 -- integer
.skip 2
.indent -10
.INDEX <SIZE
.INDEX <RSIZ
24.## RSIZ -- SIZE
.skip 1
.indent -5
input
.break
r1 -- integer
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.indent -10
.INDEX <ERRMSG
.INDEX <RRMSG
25.## RRMSG -- ERRMSG
.skip 1
.indent -5
input
.break
r1 -- integer
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string
.skip 2
.indent -10
.INDEX <TAB
.INDEX <RTAB2
26.## RTAB2 -- TAB(2 args)
.skip 1
.indent -5
input
.break
r1,r3 -- integers
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string
.skip 2
.indent -10
.INDEX <POS
.INDEX <RPOS
27.##RPOS##--#POS(1arg)
.skip 1
.indent -5
input
.break
r1 -- integer
.skip 1
.indent -5
output
.break
r1 -- integer
.skip 2
.indent -10
.INDEX <RND
.INDEX <RRNDA
.index Random ^Number ^Generation
28.##RRNDA##--#RND(X)
.skip 1
.indent -5
input
.break
.indent 5
_>0 =_> initial value
.break
r1:##=0 =_> RND()
.break
.indent 5
_<0 =_> use clock to obtain initial value
.skip 1
.indent -5
output
.break
r1 -- RND(X)
.skip 2
.indent -10
.index <COMP
.index <RSCMP
29.##RSCMP##--#COMP(s1,s2)
.skip 1
.indent -5
input
.break
r1 -- s1
.break
r2 -- s2
.break
r5 -- string code
.skip 1
.indent -5
output
.break
r1 -- COMP(s1,s2) = (-1,0,1)
.skip 1
.indent -5
do
.break
return logical value in r1, corresponding to sign of source 1 - source 2
.skip 2
.indent -10
.INDEX <MAX
.INDEX <RSMAX
30.##RSMAX##--#max(s1,s2)
.skip 1
.indent -5
input
.break
r1 -- s1 (string)
.break
r2 -- s2 (string)
.break
r4 -- address of result
.break
r5 -- string code
.skip 1
.indent -5
output
.break
max(s1,s2)
.skip 2
.indent -10
.INDEX <MIN
.INDEX <RSMIN
31.##RSMIN##--#min(s1,s2)
.skip 1
.indent -5
input
.break
r1 -- s1 (string)
.break
r2 -- s2 (string)
.break
r5 -- string code
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
min(s1,s2)
.skip 2
.indent -10
.INDEX <RCDIV
.index Complex ^Division
.index Division, ^Complex
32.##RCDIV##--#complex division
.skip 1
.indent -5
input
.break
r1,r2 -- operand 1
.break
r3,r4 -- operand 2
.skip 1
.indent -5
output
.break
r1,r2 -- quotient
.skip 2
.indent -10
.index Complex ^Multiplication
.index Multiplication, ^Complex
.index <RCMUL
33.##RCMUL##--#complex multiplication
.skip 1
.indent -5
input
.break
r1,r2 -- operand 1
.break
r3,r4 -- operand 2
.skip 1
.indent -5
output
.break
r1,r2 -- product
.skip 2
.indent -10
.INDEX <RPHZ
.INDEX <PHASE
35.##RPOLR# -- POLAR(radius,theta)
.skip 1
.indent -5
input
.break
r1,r2 -- radius(double)
.break
r3,r4 -- theta(double)
.skip 1
.indent -5
output
.break
r1,r2 -- POLAR(radius,theta)(complex)
.skip 2
.indent -10
.INDEX <RSROP
.index _>_>
.index _<_<
.index =_#
.index Relational ^Routine for ^Special ^Operators
34.##RSROP##--#special relational operator
.skip 1
.indent -5
input
.break
r5 -- LH:##type of operands
.break
######RH:##operator:##_<_< is 17, _>_> is 16, =_# is 18
.break
AC -- value1
.break
AC2 -- value2
.skip 1
.indent -5
output
.break
r1 -- logical result
.skip 1
.indent -5
do
.break
evaluate (value1) operator (value2) and leave 0 or 1 in r1
.skip 2
.indent -10
.index <DATE
.index <RXDAT
36.##RXDAT##--#(DATE)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output type
.break
string
.skip 2
.indent -10
.INDEX <TIME
.INDEX <RXTIM
37.##RXTIM##--#(TIME)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output type
.break
string
.skip 2
.indent -10
.INDEX <TERM
.INDEX <RXTRM
.index Terminal ^Input
38.##RXTRM##--#(TERM)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
logical
.skip 2
.indent -10
.index <IXASC
.index <RIASC
39.##RIASC##--#(IXASC)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
integer array, 1 dim
.skip 2
.indent -10
.index <IXCHAR
.index <RICHR
40.##RICHR##--#(IXCHAR)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string array, 1 dim
.skip 2
.indent -10
.index <XASC
.index <RXASC
41.##RXASC##--#(XASC)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
integer array, 1 dim
.skip 2
.indent -10
.index <XCHAR
.index <RXCHR
42.##RXCHR##--#(XCHAR)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output
.break
string array, 1 dim
.skip 2
.indent -10
.index <TCP
.index <RTCP
43.##RTCP##--#(TCP)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
logical
.skip 2
.indent -10
.index <DET
.index <RDET
44.##RDET##-- (DET)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
double
.skip 2
.indent -10
.index <YEAR
.index <RXYR
45.##RXYR##--#(YEAR)
.skip 1
.indent -5
input
.break
r4 -- address of result
.skip 1
.indent -5
output type
.break
string
.skip 2
.indent -10
.index <ERRCD
.index <RRCD
46.##RRCD##--#(ERRCD)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.indent -10
.index <ERRLN
.index <RRLN
47.##RRLN##--#(ERRLN)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.indent -10
.index <ERRFL
.index <RRFL
48.##RRFL##-- (ERRFL)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.indent -10
.index <TRU
.index <RTRU
49.##RTRU##--#(TRU)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
real
.skip 2
.indent -10
.index <POS
.index <RPOST
50.##RPOST##--#(POS with no arguments)
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
output type
.break
integer
.skip 2
.indent -10
.index <INV
.index <RMINV
.index Array ^Inversion
.index Matrix ^Inversion
.index Inversion, ^Matrix
51.##RMINV##--#invert matrix
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r3 -- array
.break
r4 -- address of result
.skip 1
.indent -5
do
.break
invert a real or double 2-dim matrix
.skip 1
.indent -5
error
.break
1.##matrix not square
.break
2.##matrix singular
.skip 2
.indent -10
.x <TRN
.x <RMTRN
52.##RMTRN##--#transpose
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r3 -- array
.break
r4 -- address of result
.skip 1
.indent -5
do
.break
transpose 2-dim non-string matrix, same type
.skip 2
.indent -10
.X <RMPWR
.X Array ^Exponentiation
53.##RMPWR##--#matrix exponentiation
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r1 -- integer
.break
r2 -- array
.break
r3 -- address of result
.skip 2
.indent -10
.X <RSACT
54.##RSACT##--#string scalar + string array
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2 -- string
.break
r3 -- array
.break
r4 -- address of result
.break
r5 -- string code or string code +4 if scalar precedes array
.skip 2
.indent -10
.X Scalar ^Multiplication of ^Array
.x Array, ^Scalar ^Multiplication
.x <RMSCM
57.##RMSCM##--#scalar multiplication of array
.skip 1
.indent -5
input
.break
r0 -- array code
.break
AC -- scalar value (of same type as array)
.break
r3 -- array
.break
r4 -- address of result
.skip 1
.indent -5
do
.break
multiply array by scalar; resulting type should be same type as arguments
.skip 2
.indent -10
.X Array ^Operations, ^Element by ^Element
.x <REEOPS
58.##REEOPS##--#element-by-element array operation
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r1 -- OPID=22, 23, 24, 26, 27, or 28
.break
If OPID = 24, the compiler checks to make sure both arrays have integer
type.
.break
r2 -- first array
.break
r3 -- second array
.break
r4 -- address of result
.skip 2
.indent -10
.X <RAINT
.X Array ^Intersections
.x @ (^Array ^Intersections)
60.##><RAINT##--#array intersection
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2,r3 -- the arrays
.break
the compiler does no checking.
.break
r4 -- address of result
.skip 2
.indent -10
.x Array ^Multiplication
.x <RAMUL
61.##RAMUL##--#matrix multiplication
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2,r3 -- arrays
.break
r4 -- address of result
.skip 2
.indent -10
.x Array ^Exponentiation, ^Element by ^Element
.x <REPWR
64.##REPWR##--#element-by-element exponentiation
.skip 1
.indent -5
input
.break
r0 -- array code
.break 
r1 -- number -- same type as array
.break
r3 -- array
.break
r4 -- address of result
.break
r4 -- type, or type+10 if scalar precedes array
.skip 2
.indent -10
.X <RNEGA
.x Array ^Negation
.x Negation, ^Array
65.##RNEGA##--#negate a matrix
.skip 1
.indent -5
input
.break
r3 -- matrix to be negated
.break
r0 -- array code
.break
r4 -- address of result
.skip 2
.indent -10
.x Move ^Array
.X <RACMMX
66.##RACMMX##--#move matrix
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2 -- source
.break
r3 -- dest (must be NAM_)
.break
Physically move body
.skip 2
.indent -10
.X <RACXMX
.X Exchange ^Array
.x Array ^Exchange
67.##RACXMX##--#exchange matrices
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2,r3 -- the arrays
.break
exchange values of source 1, source 2
.skip 2
.indent -5
note:
.break
bodies need not be moved; RACLIF = NAM_# !
.skip 2
.indent -10
.x String ^Exchange
.x Exchange ^String
.X <RACXS
68.##RACXS##--#exchange scalar string or string array element
.skip 1
.indent -5
input
.break
r1 -- source 1 (must be NAM_#)
.break
r2 -- source 2 (must be NAM_#)
.break
r5 -- string code
.skip 1
.indent -5
do
.break
exchange values of source 1, source 2
.skip 2
.indent -10
.X <IDN
.X <RAIDN
71.##RAIDN##--#IDN without arguments
.skip 1
.indent -5
input
.break
r3 -- address of destination (must be user variable)
.skip 2
.indent -10
.X <RACMS
.x Move ^String
.x String ^Move
72.##RACMS##--#move scalar string or string array element
.skip 1
.indent -5
input
.break
r1 -- source
.break
r2 -- dest (must be NAM_#)
.break
r5 -- string code
.skip 2
.indent -10
.x Exponentiation
.X <RPWR
73.##RPWR##--#evaluate X**Y
.skip 1
.indent -5
input
.break
r5:##LH -- type of X
.break
#####RH -- type of Y ##(RH_<=LH)
.break
r1 -- X
.break
r3 -- Y
.skip 1
.indent -5
output
.break
AC -- X**Y
.skip 2
.indent -10
.X <RXAMX
.x Procedure ^Prologues, ^Array ^Parameter
.x Parameter, ^Array to ^Procedure
.x Array ^Parameter, to ^Procedure
74.##RXAMX##--#matrix procedure argument
.skip 1
.indent -5
input
.break
r0 -- array code for argument
.break
r2 -- address of pointer to parameter descriptor
.break
r3 -- argument
.skip 1
.indent -5
do
.break
de-allocate any old param value; pt param to arg;
.break 
fail to move body
.skip 2
.indent -10
.x String ^Parameter, to ^Procedure
.x Parameter, ^String to ^Procedure
.x Procedure ^Prologues
.X <RXAS
75.##RXAS # -- scalar string or string array element procedure
and argument
.skip 1
.indent -5
input
.break
r1 -- param
.break
r2 -- arg
.break
r5 -- string code
.skip 1
.indent -5
do
.break
de-allocate any old param value; set param to refer to argument
.skip 2
.indent -10
.X <RXPMX
.x Procedure ^Prologues
.x Array ^Parameter ^Deallocation
.x Deallocation of ^Array ^Parameter
76.##RXPMX# -- de-allocate matrix param
.skip 1
.indent -5
input
.break
r2 -- addr of pointer to param
.skip 1
.indent -5
do
.break
de-allocate body (if any);
.break
set /APLOC to local vector;
.break
set /ADLN = /ADHN = 0
.break
Note: This routine may not change r0 or r1.
.skip 2
.indent -10
.test page 8
.x Procedure ^Prologues
.x String ^Parameter ^Deallocation
.x Deallocation of ^String ^Parameter
.X <RXPSS
77.##RXPSS# -- de-allocate string param
.skip 1
.indent -5
input
.break
r2 -- addr of param
.skip 1
.indent -5
do
.break
de-allocate body (if any);
.break
set /SDADR = 0
.skip 1
.indent -5
Note: This routine may not change r0 or r1.
.skip 2
.indent -10
.x Return ^String
.X <RXRS
78.##RXRS -- return string
.skip 1
.indent -5
input
.break
r2 -- addr of string
.break
r3 -- ><PVEC addr of descriptor
.break
r5 -- string code
.skip 1
.indent -5
do
.break
return string. If string is a user variable (global or local), copy body
.X <PVEC
Put descriptor in PVEC.
.skip 2
.indent -10
.X <RSIG
.x Significance, ^Output
.x Set ^Output ^Significance
79.##RSIG#--#set output significance
.skip 1
.indent -5
input
.break
r1 -- number of significant digits (integer)
.break
error: r1_<1 or r1_>17.
.skip 1
.indent -10
.x Set ^Boundary
.x Boundary, ^Set
.X <RBND
80.##RBND## -- set boundary
.skip 1
.indent -5
input
.break
r1 -- boundary value (real)
.skip 1
.indent -5
do
.break
set boundary
.break
error: r1_<0
.skip 2
.indent -10
.X <RCIB
.x Clear ^Terminal ^Input ^Buffer
.x <CIB
.x Terminal ^Input ^Buffer
81.##RCIB -- Clear terminal input buffer
.skip 2
.indent -10
.X <RCLOS
.x File ^Closing
.x Close ^File
82.##RCLOS -- close a file
.skip 1
.indent -5
r1 -- file number
.skip 1
.indent -5
error -- file not open
.skip 2
.indent -10
.X <RCOB
.X <COB
.X Clear ^Output ^Buffer
.x Terminal ^Output ^Buffer
83.##RCOB -- Clear terminal output buffer
.skip 2
.indent -10
.skip 2
.X <RCOPY
.X <COPY
.x File ^Copy
84.##RCOPY -- Copy file S1 onto S2.
.skip 1
.indent -5
r1 -- s1
.skip 1
.indent -5
r2 -- s2
.skip 1
.indent -5
r5 -- string code
.skip 2
.indent -10
.X <RDCDV
.X <DECODE
85.##RDCDV -- DECODE statement format
.skip 1
.indent -5
input
.break
r0 -- array code
.break
r2 - format (string)
.break
r5 - string code
.break
r3 -- string array
.skip 2
.indent -10
.X <RDCOD
.X <DECODE ^String ^Array
86.##RDCOD -- DECODE string array
.skip 1
.indent -5
input
.break
r1 -- RXLVAR address of variable.
.break
r3 -- type
.skip 2
.indent -10
.X <ENCODE
.X <RECDV
87.##RECDV -- ENCODE statement format
.skip 1
.indent -5
r0 -- array code
.indent -5
r2 -- string format
.indent -5
r3 -- string array
.indent -5
r5 -- string code
.skip 2
.indent -10
.X <RECOD
.X <ENCODE
88.##RECOD -- ENCODE item
.skip 1
.indent -5
input
.break
r1 -- (and r2 if double) -- value
.break
r3 -- type
.skip 2
.indent -10
.X <ERASE
.X <RERAS
89.##RERAS -- erase specified records on specified file
.skip 1
.indent -5
r3 -- final record number
.skip 1
.indent -5
r1 -- beginning record number
.skip 1
.indent -5
r4 -- file number
.skip 2
.indent -10
.X <RFOLD
.X <LOL
.x Terminal ^Carriage ^Width
.x Width , ^Terminal
90.##RFOLD# -- set terminal width
.skip 1
.indent -5
input
.break
r1 -- terminal width
.skip 1
.indent -5
do
.break
set terminal width to the number in r1
.skip 2
.indent -10
.X <RINPF
.x File ^Setup for ^Formatted ^Input
.x Formatted ^Input
91.##RIOF# -- Set up the file and format for INPUT or PRINT.
FORM used.
.skip 1
.indent -5
r1 -- record (if any)
.skip 1
.indent -5
r3 -- file number (if any)
.skip 1
.indent -5
r2 -- FORM string
.skip 1
.indent -5
r5 -- string code
.skip 1
.indent -5
FW1 -- ><INPFF or ><PRTFF+16
.skip 2
.indent -10
.X <RINPT
.x Input of ^Variable
92.##RINPT# -- INPUT a variable
.skip 1
.indent -5
input
.break
r1# -- RXLVAR address of the variable
.break
HW1 -- variable class (ONSC_#, OSSC_#, etc.)
.break
HW2 -- variable type
.skip 2
.indent -10
.test page 8
.X <RKLFMT
.x Format, ^Discard
93.##RKLFMT -- Discard current IO format
.skip 2
.indent -10
.X <RLOCAT
.x <LOCATE ^Record
94.##RLOCAT -- locate specified record on the specified file
.skip 1
.indent -5
r3 -- file number (-1 = command file)
.skip 1
.indent -5
r1 -- record number
.skip 1
.indent -5
error
.break
1. file not open
.break
2. file not random
.skip 2
.indent -10
.X <ROPEN
.X <OPEN
.x File ^Open
95.##ROPEN -- execute OPEN statement
.skip 1
.indent -5
r4 -- line number for error trap (if any)
.indent -5
r3 -- file number (if any)
.indent -5
r0 -- record length (if any)
.indent -5
r2 -- file
.indent -5
r5 -- string code
.indent -5
FW1 -- Access mode
.indent -5
r1 -- protection code (if any)
.skip 2
.indent -10
.X <RPRTF
.x File ^Setup for ^Formatted ^Print
.X <PRINT
96.##RIOI# -- Set up the file and format for PRINT or INPUT.
FORM not used.
.skip 1
.indent -5
input -- same as for RIOF, except that r2 contains IMAGE string,
if any, and r5 contains string code, if any.
.skip 2
.indent -10
.X <RPRTS
.x Print ^Spacing
97.##RPRTS# -- print spacing (ignored if formatted)
.skip 1
.indent -5
input
.break
r3 -- spacing code 0-3 (see pmc Formats, OPTYPE = 41)
.skip 1
.indent -5
do
.break
print spacing for unformatted symbolic output
.skip 2
.indent -10
.test page 12
.X <RPRTV
.x Print ^Value
98.##RPRTV# -- print value
.skip 1
.indent -5
input
.break
HW1 -- class and type
.break
HW2 -- spacing code
.skip 1
.indent -5
value is passed in:
.break
AC -- if numeric scalar
.break
r2 -- if string with string code in r5
.break
r3 -- matrix
.skip 1
.indent -5
do
.break
print value as specified to file, terminal,  or ENCODE array.
ignore spacing if file is binary or if destination is ENCODE array
.skip 2
.indent -10
1X <RREAD
.x Read a ^Variable
99.##RREAD -- READ a variable
.skip 1
.indent -5
input
.break
r1# -- RXLVAR address of the variable
.break
HW1 -- variable class (ONSC_#, OSSC_#, etc.)
.break
HW2 -- variable type
.skip 2
.indent -10
.X <RRMOV
.X <REMOVE
100.##RRMOV -- Remove specified file
.skip 1
.indent -5
r2 -- S1
.indent -5
r5 -- string code
.skip 2
.indent -10
.X <RRNAM
.X <RENAME
101.##RRNAM -- rename file S1 as S2.
.skip 1
.indent -5
r1 -- s1
.skip 1
.indent -5
r2 -- s2
.skip 1
.indent -5
r5 -- string code
.skip 2
.indent -10
.X <RRSTR
.x <DATA ^Block ^Index, ^Reset
102.##><RRSTR -- restore data block
.skip 1
.indent -5
input
.break
none
.skip 1
.indent -5
do
.break
reset the data block index to zero
.skip 2
.indent -10
.X <R8IN
.X <EIGHTI
103.##R8IN -- EIGHTI
.skip 1
.indent -5
r1 -- RXLVAR location of variable
.skip 2
.indent -10
.X <R8OUT
.X <EIGHTO
104.##R8OUT -- EIGHTO
.skip 1
.indent -5
r1 -- integer value
.SKIP 2
.INDENT -10
.index Direct ^Statements
.X <RDSDUN
.x Direct ^Statement ^Termination
105.##RDSDUN -- direct statement done
.skip 1
.indent -5
input
.break
none
.skip 2
.indent -10
.X <RDXMX
.X <DIM
.X Array ^Declaration
.x Declaration of ^Array
106.##RDXMX -- declare or redeclare array (matrix)
.skip 1
.indent -5
input
.break
r1 -- addr of descriptor
.break
r2 -- declared length (if string)
.indent -5
.skip 1
Dimensions bounds must already be in the descriptor. See ARRAYS.
.skip 1
.indent -5
do
.break
allocate storage for the array; set body to zero; fill in descriptor;
set header words (of string elements)
.skip 2
.indent -10
.X <RDXSS
.x String ^Declaration
.x Declaration of ^String
107.##RDXSS# -- declare scalar string
.skip 1
.indent -5
input
.break
r1 -- addr of descriptor
.break
r3 -- declared length
.skip 1
.indent -5
do
.break
allocate body; set it to zero; set descriptor to zero current length
.break
Note: string may already have been declared, possibly with different
declared length.
.skip 2
.indent -10
.X <RERR
.x Run ^Error
.x Error in ^Run
108.##RERR## -- run error
.skip 1
.indent -5
input
.break
r1 -- number of appropriate error message
.skip 1
.indent -5
do
.break
print error message and exit to current resume point
.SKIP 1
.SKIP 1
.INDENT -10
.X <RGOSUB
.X <GOSUB
109.##RGOSUB -- ><GOSUB call
.skip 1
.indent -5
input
.break
r2 -- line location.
.SKIP 2
.INDENT -10
.X <RSQRT
.X <SQRT
.X Square ^Root
.X <RSIN
.X <SIN
110.##RSQRT##--#SQUARE ROOT
.SKIP 1
.INDENT -5
INPUT
.BREAK
R1,(R2) -- OPERAND
.BREAK
R3 -- OPERAND TYPE
.SKIP 1
.INDENT -5
OUTPUT
.BREAK
R1,R2 -- SQRT(OPERAND)
.SKIP 2
.INDENT -10
111.##RSIN##--#SINE
.SKIP 1
.INDENT -5
INPUT
.BREAK
R1,(R2) -- OPERAND
.BREAK
R3 -- OPERAND TYPE
.SKIP 1
.INDENT -5
OUTPUT
.BREAK
R1,R2 -- SIN(OPERAND)
.SKIP 2
.INDENT -10
.X <RCOS
.X <COS
112.##RCOS##--#Cosine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
r1,r2 -- COS(operand)
.skip 2
.indent -10
.X <RTAN
.X <TAN
113.##RTAN##--#Tangent
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- TAN(operand)
.skip 2
.indent -10
.X <RGRET
.X <RETURN
.X <GOSUB <RETURN
114.##RGRET##-- Return from ><GOSUB call
.skip 2
.indent -10
.X <RHED
.X <DEBUG
.X <BREAK
.X <TRACE
115.##><RHED -- Used to support BREAK and TRACE
.skip 2
.indent -10
.test page 17
.X <RINTP
.x Interrupts
116.##RINTP# -- interrupt program
.skip 1
.indent -5
input
.break
##H -- 0 = ><STOP
.break
#######2 = ><END
.break
#######4 = ><PAUSE
.break
#######6 = ><QUIT
.break
#######8 = ><LOGOUT
.skip 1
(Add 1 to above calues if expression has already been printed.)
.skip 1
.indent -5
do
.break
perform indicated interrupt (see TBA spec, pp 39, 73-74); printout for
><LOG like that for others plus logout info
.skip 2
.indent -10
.X <RNOCN
.X <NO ^Condition ^Statement
118.##RNOCN -- set condition OFF
.skip 1
.indent -5
input
.break
r3 -- if FILE or ENDFILE,filenumber
.break
r5 -- kind of condition
.indent 5
EOF_#==0
.indent 5
ESC_#==1
.indent 5
MTH_#==2
.indent 5
TRN_#==3
.indent 5
FIL_#==4
.indent 5
DAT_#==5
.indent 5
ERR_#==6
.skip 2
.indent -10
.X <RASIN
.X <ASIN
119.##RASIN##--#Arcsine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- ASIN(operand)
.skip 2
.indent -10
.X <RACOS
.X <ACOS
120.##RACOS##--#Arccosine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- ACOS(operand)
.skip 2
.indent -10
.X <RATAN
.X <ATAN
121.##RATAN##--#Arctangent (single argument)
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- ATAN(operand)
.skip 2
.indent -10
.X <RSINH
.X <SINH
122.##RSINH##--#Hyperbolic Sine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- SINH(operand)
.skip 2
.indent -10
.X <RCOSH
.X <COSH
123.##RCOSH##--#Hyperbolic Cosine
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- COSH(operand)
.skip 2
.indent -10
.X <RTANH
.X <TANH
124.##RTANH##--#Hyperbolic Tangent
.skip 1
.indent -5
input
.break
r1,r2 -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- TANH(operand)
.skip 2
.indent -10
.X <RLOG
.X <LOG
125.##><RLOG##--#Natural log
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- LOG(operand)
.skip 2
.indent -10
.X <RONCN
.X <ON ^Condition
126.##RONCN##--#set condition ON
.skip 1
.indent -5
input
.break
r1 -- branch address
.break
r3 -- if FILE or ENDFILE, filenumber
.break
r5 -- kind of condition
.indent 5
ESC_#==0
.indent 5
ERR_#==1
.indent 5
MTH_#==2
.indent 5
TRN_#==3
.indent 5
DAT_#==4
.indent 5
EOF_#==5
.indent 5
FIL_#==6
.skip 2
.indent -10
.X <RLOG10
.X <LOG10
.X <LOGT
127.##RLOG10##--#Common log
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- LOG10(operand)
.skip 2
.indent -10
.X <REXP
.X **
.X Exponentiation
128.##REXP##--#Exponential (e**x)
.skip 1
.indent -5
input
.break
r1,(r2) -- operand
.break
r3 -- operand type
.skip 1
.indent -5
output
.break
r1,r2 -- EXP(operand)
.skip 2
.indent -10
.X <RPGDUN
.x Program ^Done
129.##RPGDUN##--#program done, last line executed
.skip 1
.indent -5
input
.break
none
.skip 2
.indent -10
.X <RATAN2
.X <ATAN
130.##RATAN2##--#Arctangent (double argument)
.skip 1
.indent -5
input
.break
r1,(r2) -- operand 1
.break
r3,(r4) -- operand 2
.break
r5 -- operand type (both operands have same type)
.skip 1
.indent -5
output
.break
r1,r2 -- ATAN(operand 1)/(operand 2)
.skip 2
.indent -10
.X <RRSUM
.X <RESUME
131.##RRSUM##--#executes RESUME statement
.skip 1
.skip 1
.indent -10
.X <RWAIT
.X <WAIT
132.##RWAIT##--#wait
.skip 1
.indent -5
input
.break
r1 -- WAIN
.skip 1
.indent -5
do
.break
wait WAIN seconds
.skip 2
.indent -10
.X <RGSLC
.X Array ^Slicing
133.##RGSLC##--#Create array slice
.skip 1
.indent -5
input
.break
r3#--#descriptor address of N-dimensional parent array
.break
PR[0:N-1]#--#dimension specifications for dimensions
.break
0 through N-1 of the parent array (N greater than 2)
.skip 1
.break
r1#--#dimension specification for dimension 0 (N=1 or 2)
.skip 1
r2#--#dimension specification for dimension 1 (N=2)
.skip 1
FW1#--#dimension map
.skip 1
.indent -5
output
.break
array slice
.skip 1
.indent 10
Note:  if only one subscript is specified for a given dimension,
the dimension specification will simply be that subscript.  
If two subscripts are specified, the lower (upper) bound will be in 
the left (right) halfword of the dimension specification.  
The bit in the 2**J place of the dimension map will be 0 if only 
one subscript is specified for dimension J, and 1 if 2 subscripts 
are specified.
.left margin 5
.subtitle Bibliography
.page
.skip 1
.center 80
BIBLIOGRAPHY
.skip 2
EXTERNAL SPECIFICATION
.skip 1
*##Tymbasic language external reference specification
(updated January 1975 and May 1975)
.skip 1
*##Tymshare Super Basic reference manual
.skip 1
*##Differences between Super Basic and Tymbasic
.skip 4
INTERNAL DESIGN
.skip 1
*##Tymbasic general internal design
.skip 1
*##Tymbasic task descriptions (maintained in the file (TBA4:17)PEBBLE)
.skip 1
*##Tymbasic project schedule (maintained in the file (TBA4:17)CHART)
.skip 1
*##Programming standards and procedures--Tymbasic project
.skip 1
*##A few words about paging
.skip 1
*##Memo on test programs
.skip 4
INTERFACES
.skip 1
*##Tymcom X monitor version PO.2 information
.skip 1
*##Quick reference for Tymcom X monitor calls
.skip 1
*##Reference manual for KI10 software interrupt system on the Tymcom X
.skip 1
*##Terminal interface standards for Tymbasic
.skip 1
*##Specification for intraline editing for Tymbasic
.skip 1
*##Specification for file name syntax and semantics for Tymbasic
.skip 1
*##Files (symbolic file format)
.skip 1
*##The care and feeding of CREF
.skip 4
MANUALS
.skip 1
*##DEC system 10 assembly language handbook
.skip 1
*##DEC system 10 system reference manual
.skip 1
*##Tymshare Editor -- instant series
.skip 1
*##Tymshare Editor -- reference series
.skip 1
*##Addendum to editor -- January 1972
.skip 1
*##Tymshare Executive -- reference series
.skip 1
*##Tymshare XEXEC manual 
.skip 1
*##FET -- a file editing tool
.skip 1
*##Tymcom X user program index
.skip 1
*##Tymex
.skip 1
*##Tymcom X file creation and modification
.skip 1
*##Runoff
.skip 1
*##The beginner's guide
.title TYMBASIC GID
.subtitle INDEX
.page
.left margin 3
.print index
  M5o"