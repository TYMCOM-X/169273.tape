
::      MULTIPLEXER OPTIONS SETUP

ENGINE  EQ      1               :ENGINE ONLY
ISIS2   EQ      1               :ISIS2 VERSION
NUSERS  EQ      USR             :NUMBER OF USERS
MAXHST  EQ      1               :MAX NO. OF HOSTS
MAXPRT  EQ      NPORT-1         :MAX NO. OF PORTS
HOST0   EQ      HOSTNO          :HOST NMBR
HPRT0   EQ      NPORT/4         :1/4 OF PORTS FOR INPUT
CNTRL   EQ      200             :ISIS STATE WORD
NTOUT   EQ      2               :TIMEOUT LIST LENGTH
        SUBTTL  ISIS Assembly Switch Definitions        - START.LIB
:******************************************************************
:
:       This program is the sole property and confidential
:       information of Tymshare, Inc., and may not be copied
:       in whole or in part or disclosed to any third party
:       without the prior written consent of Tymshare.
:
:*******************************************************************

        REMARK %Start.Lib Version 
SREV    EQ      0;      NUMBER SREV; REMARK .0
SLEV    EQ      05;     NUMBER SLEV

: Version 0.05 01/19/83 MDS
:       Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:       Add new fields to SYS SVC Sub-operand definitions,
:       per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:       Add new fields to Seg F table per ISIS 5.01
:       (note - Start.lib ** NOT ** compatible with ISIS 5.00
:       because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:       Add QSTART remark, add I/O sub-ops for mother board.
:       Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:       Correct relative addresses of local clock index and values.

        RA      0               :       START.LIB

:       this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2   EQ      1       :Force ISIS2 for other library routines
                        :Note - ISIS 1 is no longer supported

:                       ISIS - II Version
:
:       The following parameters should be defined in the *.TYM file:
:       MAXHST  maximum number of hosts associated with this interface slot
:       MAXPRT  number of highest port associated with this interface slot
:                       (number of ports - 1)
:       IRSIZE   number of bytes to provide for input ring, from dispatcher
:       ORSIZE   number of bytes to provide for output ring, to dispatcher
:       CNTRL   dispatcher control bits
:       ENGINE  set to 1 if executing on a Tymnet Engine

:       the following symbols MUST be defined SOMEWHERE in the assembly:
:       IRING   the start of the input ring, from dispatcher
:       ORING   the start of the output ring, to dispatcher
:       ENTRY   the location of the first instruction to be executed

:       the following symbols are defined for convenience:
:       RATE    the rate of the fast clock (ticks/second)
:       NRATE   word containing the value of RATE
:       FASTC   word containing  realtime fast clock
:       SLOWC   word containing  realtime slow clock (1-second)
:       GMT     word containing GMT clock
:       TEMPER  byte containing machine temperature
:       VOLTS   byte containing machine voltage
:       VERNO   halfword containing ISIS version number
:       WWVBT   word containing WWVB time
:       HOSTX   halfword containing kernel host number
:       NODEX   halfword containing kernel node number
:       LCX     halfword, offset of local clocks within seg F
:       SLCNT   halfword, number of slots known to ISIS dispatcher
:       LCT     halfword, pointer to crash table
:       MAXP0   halfword, highest port 0 msg. #
:       MAXMSG  halfword, highest msg # for all other ports
:       LP0LST  halfword, length table for port 0 msgs.
:       LENGTH  length table for msgs. all other ports
:       R0-R15  symbolic names for the registers
:       SEGn    the start address of segment n (0-0E)
:       HOSTS   halfword array of host numbers as known by the dispatcher (R/O)
:       PORTS   halfword array of ports/host as known by dispatcher (R/O)
:
:       the following symbols MAY be defined. defaults used otherwise
:       APROTn  protection byte for area n. default area 1 write protected,
:               other areas execution protected.
:       HOSTn   host number for host position n. default none.
:       HPRTn   number of ports for host position n. default none.
:       DSTART  user DDT execution start address. default none.
:       QSTART  user DDT query handler start address, default none.
:       FPANEL  halfword cell for front panel display. default cell allocated
:       FRISIS  bit array for input backpressure (1=no backpressure) default
:                       array allocated.
:       TOISIS  bit array for output backpressure (1=no backpressure) default
:                       array allocated.
:       VERSION version number for slot code (default zero)
:       PCTTBL  bit array for indicating terminating character for project
:                       code. (default none)
:       REVLEV  revision level for slot code (default zero)
:       A.DATA  segment number for data area. Default 0
:       A.CODE  segment number for code area. Default 1
:       A.BDAT  segment number for based data. Default 2.
:       A.RING  segment number for rings. Default 2.
:       A.BUFF  segment numberfor buffer(let)s. Default 2.
:
:       in addition most SVC calls have been assigned symbolic names.

	

        GL      FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
        GL      R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
        GL      IRSIZE,ORSIZE,CNTRL
        GL      ENTRY,IRING,ORING,ENGINE,LCX
        GL      VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:       DEFINE SEG 15d LOCATIONS
RATE    EQ      $A 600          :clock rate, ticks per second
NRATE   EQ      0F0000          :word, contains RATE
FASTC   EQ      0F0004          :word, contains fast clock (ticks)
SLOWC   EQ      0F0008          :word, contains slow clock (seconds)
GMT     EQ      0F000C          :word, contains GMT (seconds since 1/1/72)
TEMPER  EQ      0F0010          :byte, contains machine temperature
VOLTS   EQ      0F0011          :byte, contains machine voltage
VERNO   EQ      0F0012          :halfword, ISIS version number
WWVBT   EQ      0F0014          :word, WWVB time (format ??)
HOSTX   EQ      0F0018          :halfword, kernel host number
NODEX   EQ      0F001A          :halfword, kernel node number

: Local clocks displacements

LCX     EQ      0F001C  :1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX EQ      LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS EQ      Seg F + contents of LCX
                        :clocks for slots, array of word entries per slot
                        :1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT   EQ      0F001E          :halfword, number of dispatcher slots
LCT     EQ      0F0020          :halfword, pointer to crash table
MAXP0   EQ      0F0022          :halfword, max. msg. # for port 0
MAXMSG  EQ      0F0024          :halfword, max. msg #, all non-0 ports
LP0LST  EQ      0F0026          :halfword, offset to port 0 msg length table
LENGTH  EQ      0F0028          :byte table, lengths of non-0 port msgs

:       Define Registers
R0      EQ      0
R1      EQ      1
R2      EQ      2
R3      EQ      3
R4      EQ      4
R5      EQ      5
R6      EQ      6
R7      EQ      7
R8      EQ      8
R9      EQ      9
R10     EQ      $A 10
R11     EQ      $A 11
R12     EQ      $A 12
R13     EQ      $A 13
R14     EQ      $A 14
R15     EQ      $A 15

	

:       AREA DEFINITIONS
        GL      A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF    \A.DATA
  ELSE
A.DATA  EQ      0       :DEFAULT DATA AREA
  EI

  IF    \A.CODE
  ELSE
A.CODE  EQ      1       :DEFAULT CODE AREA
  EI

  IF    \A.BDAT
  ELSE
A.BDAT  EQ      2       :DEFAULT BASED DATA AREA
  EI

  IF    \A.RING
  ELSE
A.RING  EQ      2       :DEFAULT RING AREA
  EI

  IF    \A.BUFF
  ELSE
A.BUFF  EQ      2       :DEFAULT BUFFER AREA
  EI

	

:       SVC DEFINITIONS
:
        GL      DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
        GL      FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
        GL      RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
        GL      SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
        GL      CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
        GL      SFREZ.,HALT.,SHALT.
        GL      TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
        GL      SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS  EQ      0       :DISMISS SVC
FASTD   EQ      1       :FAST DISMISS SVC
:
SYS     EQ      2       :SYS SVC

:       SYS SVC SUBOPERANDS
RSTRT.  EQ      0       :Restart syscall
CFGND.  EQ      1       :Connect foreground syscall
DBGON.  EQ      2       :Debug mode ON syscall
DBGOF.  EQ      3       :Debug mode OFF syscall
TSTDB.  EQ      4       :Test debug mode syscall
FREEZ.  EQ      5       :Freeze slot syscall
THAW.   EQ      6       :Thaw slot syscall
TFREZ.  EQ      7       :Test freeze syscall
RDDTR.  EQ      8       :Read DDT register syscall
RDDTP.  EQ      9       :Read DDT PSD syscall
RBREG.  EQ      0A      :Read background register syscall
RBPSD.  EQ      0B      :Read background PSD syscall
RFREG.  EQ      0C      :Read foreground register syscall
RFPSD.  EQ      0D      :Read foreground PSD syscall
RDMAC.  EQ      0E      :Read DDT MAC register syscall
RBMAC.  EQ      0F      :Read background MAC register syscall
RFMAC.  EQ      10      :Read foreground MAC register syscall
SET1P.  EQ      11      :Set 1 protect syscall
SETP.   EQ      12      :Set protection syscall
SETBE.  EQ      13      :Set background execution addr syscall
SETFE.  EQ      14      :Set foreground execution addr syscall
LMAC.   EQ      15      :Set up MAC from CTA (DDT only)
CSUPF.  EQ      16      :Check SUP freeze state
CSUPR.  EQ      17      :Check SUP run Q state
FREZS.  EQ      18      :Freeze the SUP
THAWS.  EQ      19      :Thaw the SUP
ALARM.  EQ      1A      :Set/Clear alarm
RSCLK.  EQ      1B      :Read the super-clock
SSCLK.  EQ      1C      :Set the super-clock
SUDIA.  EQ      1D      :Set user diagnostic
UCORE.  EQ      1E      :Get slot physical addr & size (DDT only)
SFREZ.  EQ      1F      :Super-freeze slot
HALT.   EQ      20      :Halt the slot
SHALT.  EQ      21      :Super-halt the slot
SVSPY.  EQ      22      :Start/Stop SPY
DISCO.  EQ      23      :Disconnect Logical Unit

	

IO      EQ      3       :I/O SVC
:       I/O SUBOPERANDS
IOQRY.  EQ      8000    :Query I/O attributes
CSYNI.  EQ      0       :Connect SYNC input
CSYNO.  EQ      1       :Connect SYNC output
FSYNO.  EQ      2       :Force SYNC output
CASYN.  EQ      3       :Connect ASYNC
CPRT.   EQ      4       :Connect Printer
FPRT.   EQ      5       :Force Printer
TIISC.  EQ      6       :T-II SYNC Connect
TIISI.  EQ      7       :T-II SYNC Idle test
CSIO.   EQ      8       :Connect SIO
CMBRD.  EQ      9       :Connect SIO mother board
FMBIN.  EQ      0A      :Force mother board input
FMBOT.  EQ      0B      :Force mother board output
SHARE   EQ      04      :Shared device SVC
K.IN    EQ      0A      :Kernel Input SVC
K.OUT   EQ      0B      :Kernel Output SVC
KIO     EQ      0D      :Kernel-I/O (general) SVC
BDISC   EQ      0E      :Big disc SVC (obsolete)
SDISC   EQ      0F      :Small disc SVC (obsolete)

	

        IF      IRSIZE&3;       REMARK  %IRSIZE should be multiple of 4
IRSIZE  EQ      (IRSIZE!3)+1;   EI
        IF      ORSIZE&3;       REMARK  %ORSIZE should be multiple of 4
ORSIZE  EQ      (ORSIZE!3)+1;   EI

  IF    \MAXPRT
  ELSE
        REMARK  %PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT  EQ      NPORTT-1
HPRT0   EQ      MAXPRT
  EI

  IF    \MAXHST
  ELSE
        REMARK  %PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST  EQ      1
HOST0   EQ      HOSTNO
  EI


:       DEFINE START OF SEGMENTS
Q       EQ      0
        NOLIST
        RE      0F
  IF    \SEG|Q|
        GL      SEG|Q|
  ELSE
        SEG     Q
        GL      SEG|Q|
SEG|Q|
  EI
Q       EQ      Q+1
        ER
        LIST

:GENERATE DIAGNOSTICS
Q       EQ      0
        NOLIST
QQ      EQ      0;      RE      0F
        IF      ((Q*10000)%SEG|Q|)&7FFFFFFF
QQ      EQ      1;      REMARK  %SYMBOL SEG
        NUMBER  Q
        REMARK   IS NOT DEFINED PROPERLY. VALUE IS 
        NUMBER  SEG|Q|
        EI
Q       EQ      Q+1;    ER
        LIST

        IF      QQ;
        REMARK  %START.LIB **MUST** be assembled FIRST!!%;
        EI
        SUBTTL  ISIS Ring Handling Routines     - FRING.LIB
:******************************************************************
:
:       This program is the sole property and confidential
:       information of Tymshare, Inc., and may not be copied
:       in whole or in part or disclosed to any third party
:       without the prior written consent of Tymshare.
:
:*******************************************************************
        RA      0               :       FRING.LIB

:       ISIS RING HANDLERS

:       This package is the fast, efficient ring handler set
:       The following CONSTRAINTS apply:
:       1.  Once started, register 14 or 15 is dedicated to that
:               operation, until it is "ended".
:       2.  If a new operation is started before the previous operation is
:               "ended", the previous operation is aborted, and the
:               appropriate ring is effectively left unchanged.
:
:       This package now permits simultaneous input and output!!!
:               R15 is used for output operations
:               R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:     To convert this package, remove all lines with ':*:' in them,
:*:     and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:       The package contains both utility and primitive routines:

:       utility routines are called with link R5,
:       they preserve registers R6--R14.
:       OCS     Output Canned String
:               R2 = port #, R3 = pointer to string (SC format)
:               OCS will output string as a data message to the specified
:               port. OCS goes to completion, and "ends the operation.
:       OCM     Output Canned Message
:               R2 = port #, R3 = pointer to string (SC format)
:               OCM will output the string as a message to the specified port
:               OCM goes to completion, and "ends the operation.
:       OBS     Output Byte String
:               R2 = number of characters, R3 = pointer to string
:               OBS will output specified string into the current message
:               message must have already been "started", and is NOT "ended".

:       primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:       LOOK    Determine if an input message exists...normal return if not
:               skip (4) return if so, and then:
:               R1 = port number
:               R2 = message type code (peek)
:               On skip return, condition codes are set such that JE will
:               succeed on port 0.  The port number will have been removed
:               from the message but the message code will not have been
:               removed (you get a peek at it).
:       GETCH   Get a character, returned in R0.
:       GETH    Get a halfword, returned in R0.  An even number of bytes 
:               should have been removed previously for expected results.
:       GETW    Get a word, returned in R0.  An even number of halfwords 
:               should have been removed previously for expected results.
:       FLUSH   Flush away ("end") remainder of input message.  R0 is number
:               of bytes remaining to flush.
:       ELIR    End-Logical-Input-Record.  "Ends" current message, sets
:               up pointers for next message.

:       Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:       unless used for arguments, or otherwise specified:
:       SPACE   Returns R0 = number of characters of space available in 
:               output ring. Sets up R15 for "start" of message.
:       ROOM    R0 = number of characters required for next message,
:               returns when that much room is available in output ring.
:               MAY DISMISS.
:               sets up R15 for "start" of message. SMASHES R1.
:       SLOR    Start Logical Output Record.
:               R0 = number of bytes required.
:               R1 = port #
:               R2 = message type code.
:               Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:               of message. MAY DISMISS. SMASHES R3.
:       PUTCH   places character in R0 in next position of ring.
:       PUTH    places halfword in R0 in next position of ring.  Even number
:               of bytes have been output previously in this message.
:       PUTW    places word in R0 in next position of ring.  Even number of
:               halfwords should have been output previously in this message.
:       ELODR   End Logical Output Data Record
:               places byte count into message type to make data message,
:               then "ends" message.  Smashes R0, R1.
:       ELOR    End Logical Output Record
:               "ends" message.

:       CONVENTIONS:
:       ROUTINES USE DEDICATED REGISTERS:
:       R15     OUTPUT RING INDEX
:       R14     INPUT RING INDEX
:
:       NOTE....
:               IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	

        GL      IRING,ORING,IRSIZE,ORSIZE
        GL      OCS,OCM,OBS
        GL      LOOK,GETCH,GETH,GETW,FLUSH,ELIR
        GL      SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEGNG		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

	

:       CODE AREA
        SEG     A.CODE
:       INPUT ROUTINES

:       LOOK AT A RING ENTRY
:       NORMAL RETURN IF RING EMPTY
:       ELSE SKIP RETURN, PORT RETURNED IN R1
:       MESSAGE TYPE RETURNED IN R2
:       ALL REGISTERS SET UP FOR TRANSFER
:       POSITION IS ADVANCED PAST PORT#
        IF      \LOOK;.LOOK.     HS     0;      ELSE;LOOK        HS     0;      EI
        LHL     R14,CEI+IRING,, :GET CURRENT EMPTY INDEX
        CLH     R14,NFMI+IRING,,        :TEST IF CAUGHT UP
        JER     R4              :EMPTY...NORMAL RETURN
        SHI     R14,IRSIZE      :*: CONVERT TO NEGATIVE INDEX
        LHL     R1,IRING+RING+IRSIZE,R14,       :GET PORT #
        AIS     R14,2           :BUMP POINTER PAST PORT #
        LB      R2,IRING+RING+IRSIZE,R14,       :GET MESSAGE TYPE
        LR      R1,R1           :SET CONDITION CODES
        J       4,R4            :THEN SKIP RETURN

:       GET A CHARACTER FROM THE INPUT RING
:       CHARACTER RETURNED IN R0
GETCH   LB      R0,IRING+RING+IRSIZE,R14,       :GET THE CHAR
        AIS     R14,1           :BUMP INDEX
        JLR     R4              :RETURN IF NOT
        LHI     R14,-IRSIZE     :ELSE FOLD IT
        JR      R4              :AND EXIT

:       GET A HALF-WORD FROM THE INPUT RING
:       ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:       HALF-WORD RETURNED IN R0
GETH    LHL     R0,IRING+RING+IRSIZE,R14,       :GET THE DATA
        AIS     R14,2           :BUMP INDEX
        JLR     R4              :RETURN IF NOT
        LHI     R14,-IRSIZE     :ELSE FOLD IT
        JR      R4              :AND EXIT

:       GET A WORD FROM THE INPUT RING
:       ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:       WORD RETURNED IN R0
GETW    L       R0,IRING+RING+IRSIZE,R14,       :GET THE DATA
        AIS     R14,4           :BUMP INDEX
        JLR     R4              :RETURN IF NOT
        LHI     R14,-IRSIZE     :ELSE FOLD IT
        JR      R4              :AND EXIT

:       FLUSH AN INPUT RECORD
:       NUMBER OF CHARS TO FLUSH IN R0
FLUSH   AR      R14,R0          :ADVANCE RING AND FALL THROUGH

:       END LOGICAL INPUT RECORD
ELIR    AIS     R14,3           :FORCE TO NEXT WORD
        NHI     R14,-4
        JLFS    ELIR2           :NO
        SHI     R14,IRSIZE      :YES
ELIR2
        AHI     R14,IRSIZE      :*: CONVERT TO POSITIVE INDEX
        STH     R14,CEI+IRING,,
        JR      R4              :AND EXIT

	

:       OUTPUT ROUTINES

:       OUTPUT "CANNED" MESSAGE
:       LINK ON R5
:       R2 = PORT #
:       R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM     LB      R0,0,R3         :GET COUNT n
        AIS     R0,5            :COMPUTE SPACE REQUIREMENTS
        NHI     R0,-4
        JAL     R4,ROOM         :INSURE THERE IS ROOM
        LR      R0,R2           :COPY PORT #
        JAL     R4,PUTH         :PLACE PORT NUMBER
        LB      R2,0,R3         :GET COUNT AGAIN
        J       OCS1            :SKIP TO PLACE THE STRING

:       OUTPUT "CANNED" STRING
:       LINK ON R5
:       R2 = PORT #
:       R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS     LB      R0,0,R3         GET COUNT n
        AIS     R0,6            :COMPUTE SPACE REQUIREMENTS
        NHI     R0,-4
        JAL     R4,ROOM         :INSURE THERE IS ROOM
        LR      R0,R2
        JAL     R4,PUTH         :PLACE PORT NUMBER
        LB      R2,0,R3
        LR      R0,R2           :GET THE COUNT n
        JAL     R4,PUTCH        :PLACE IT...MESSAGE TYPE 1-7D
OCS1    AIS     R3,1            :BUMP SOURCE CHARACTER POINTER
        LB      R0,0,R3         :GET THE NEXT CHARACTER
        JAL     R4,PUTCH        :PLACE IT INTO RING
        SIS     R2,1            :REDUCE COUNT
        JGBS    OCS1            :REPEAT UNTIL ALL CHARACTERS PLACED
        JAL     R4,ELOR         :END LOGICAL OUTPUT RECORD
        JR      R5              :THEN EXIT

:       OUTPUT A BYTE STRING
:       LINK ON R5
:       R3 = POINTER TO STRING
:       R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1    AIS     R3,1            :BUMP CHARACTER POINTER
OBS     LB      R0,0,R3         :GET THE NEXT CHARACTER
        JAL     R4,PUTCH        :PLACE IT INTO RING
        SIS     R2,1            :REDUCE COUNT
        JGBS    OBS1            :REPEAT UNTIL ALL CHARACTERS PLACED
        JR      R5              :THEN EXIT

:       FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:       RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE   LCS     R0,4            :SET MASK
        LHL     R15,NFMI+ORING,,
        NH      R0,CEI+ORING,,  :FORCE EMPTIER TO WORD BOUNDARY
        SR      R0,R15          :SPACE BETWEEN US AND EMPTIER
        JGFS    SPACE1          :SKIP IF NO WRAP-AROUND
        AHI     R0,ORSIZE       :ELSE CORRECT FOR WRAP
SPACE1  SIS     R0,4            :CORRECT FOR POSSIBLE OVERFLOW
        SHI     R15,ORSIZE      :*: CONVERT TO NEGATIVE INDEX
        JR      R4              :AND RETURN

:       INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:       EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM    LHL     R15,NFMI+ORING,,
        SHI     R15,ORSIZE      :*: CONVERT TO NEG. INDEX
ROOM1   LCS     R1,4            :SET MASK
        NH      R1,CEI+ORING,,  :FORCE HIM TO WORD BOUNDARY
        SHI     R1,ORSIZE       :*:
        SR      R1,R15          :CHECK RELATIVE POSITIONS
        JGFS    ROOM2           :SKIP IF HE'S AHEAD OF US
        JER     R4              :EQUAL...HE'S EMPTY...GO DO IT
        AHI     R1,ORSIZE               :HE'S BEHIND US
ROOM2   SIS     R1,4            :ALLOW FOR POTENTIAL OVERFLOW
        CR      R0,R1
        JLER    R4              :ROOM EXISTS...GO DO IT
        SVC     DISMISS,0
        J       ROOM1           :AND GO TRY AGAIN

:       START LOGICAL OUTPUT RECORD
:       PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:       R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:       R1 = PORT #
:       R2 = MESSAGE CHARACTER CODE
SLOR    LHL     R15,NFMI+ORING,,
        SHI     R15,ORSIZE      :*: CONVERT TO NEG. INDEX
SLOR1   LCS     R3,4            :SET A MASK
        NH      R3,CEI+ORING,,  :FORCE RECEIVER TO WORD BOUNDARY
        SHI     R3,ORSIZE       :*:
        SR      R3,R15
        JGFS    SLOR2
        AHI     R3,ORSIZE       :ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2   SIS     R3,4            :ALLOW FOR POTENTIAL OVERFLOW
        CR      R3,R0
        JGEFS   SLOR3           :SKIP IF WE CAN GO
        SVC     DISMISS,0
        JBS     SLOR1
SLOR3   STH     R1,ORING+RING+ORSIZE,R15,       :OK...PLACE MESSAGE
        STB     R2,2+ORING+RING+ORSIZE,R15,
        AIS     R15,3           :BUMP PAST THESE CHARACTERS
        JR      R4              :AND EXIT

:       PUT A CHARACTER INTO THE RING
:       R0 = CHARACTER
PUTCH   STB     R0,ORING+RING+ORSIZE,R15,       :PLACE THE CHARACTER
        AIS     R15,1           :BUMP INDEX
        JLR     R4              :SKIP IF NOT
        LHI     R15,-ORSIZE     :ELSE WRAP AROUND
        JR      R4              :AND EXIT

:       PUT A HALF-WORD INTO THE RING
:       R0 = HALF-WORD
PUTH    STH     R0,ORING+RING+ORSIZE,R15,       :PLACE THE HALF-WORD
        AIS     R15,2           :BUMP INDEX
        JLR     R4              :EXIT IF NOT
        LHI     R15,-ORSIZE     :ELSE WRAP AROUND
        JR      R4              :AND EXIT

:       PUT A WORD INTO THE RING
:       R0 = WORD
PUTW    ST      R0,ORING+RING+ORSIZE,R15,       :PLACE THE WORD
        AIS     R15,4           :BUMP INDEX
        JLR     R4              :SKIP IF NOT
        LHI     R15,-ORSIZE     :ELSE WRAP AROUND
        JR      R4              :AND EXIT

:       END LOGICAL OUTPUT DATA RECORD
ELODR   LHL     R1,NFMI+ORING,, :GET START OF THIS MESSAGE
        SHI     R1,ORSIZE       :*: CONVERT TO NEG. INDEX
        LR      R0,R15          :COPY MESSAGE END
        SR      R0,R1           :COMPUTE SIZE OF THIS MESSAGE
        JGEFS   ELODR2          :SKIP IF NO WRAP-AROUND
        AHI     R0,ORSIZE               :ELSE CORRECT FOR WRAP
ELODR2  SIS     R0,3            :MAKE ALLOWANCE FOR HEADER
        JER     R4              :EXIT IF ZERO LENGTH MESSAGE
        STB     R0,2+ORING+RING+ORSIZE,R1,      :INSERT MESSAGE TYPE INTO MESSAGE
                                :AND FALL THROUGH

:       END LOGICAL OUTPUT RECORD
ELOR    AIS     R15,3
        NHI     R15,-4
        JLFS    ELOR2
        LHI     R15,-ORSIZE     :FOLD IF NECESSARY
ELOR2
        AHI     R15,ORSIZE      :*: CONVERT BACK
        STH     R15,NFMI+ORING,,        :NOW ADVANCE POINTER TO NEXT MESSAGE
        JR      R4              :AND EXIT
        EM
        SUBTTL  ISIS STARTUP AND CRASH LIBRARY  - CRASH.LIB
:******************************************************************
:
:       This program is the sole property and confidential
:       information of Tymshare, Inc., and may not be copied
:       in whole or in part or disclosed to any third party
:       without the prior written consent of Tymshare.
:
:*******************************************************************
        RA      0               :       CRASH.LIB       MFR 07/14/81

:       Changed the supervisor's log message to report the PRODID.
:       Sep. 20, 1982 SCY.
:       ENTRY2 (restart service) changed to clear input and output
:       rings PRIOR to issuing Restart SVC to prevent crash-loop if
:       Dispatcher has crashed. June 17, 1982 MDS.

:                       ISIS - II Version
:
        GL      CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID
        MO      .,CRASH


:       Generalized crash package.
:       Handles both software and hardware crashes.  On any crash, the
:       registers are saved in CRREG, and CRSHCT is incremented.
:       Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:       CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:       calling sequence is:

:               JAL     R10,CRASH
:                                               from a bad one
:               HC      0               :this key distinguishes a good crash
:               BC      4*L,Y           :first byte is 4*register linked to
:                                               routine, Y is the reason
:       then register (L) is saved in CFROM, and Y is saved in CRASHC

:       in the event of a hardware failure, CPOINT contains the instruction
:       address at the time of failure, CRASHC contains the failure reason,
:       and CFROM is set =-1.

:       On completion of crash, transfers to label START, defined
:       in the user code.
:
:       The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:       be executed only once.  the second time through the crash area will
:       be set up as specified above and then registers will be restored to
:       their entry value and the slot will be frozen. If it is thawed it
:       will restart.
:
:       Entering :RCRAT,4B in NAD will dump the crash table.
:

	

  IF    \CRSTOP
  ELSE
CRSTOP  EQ      0
  EI

        SEG     A.DATA
CRAT    HS      0               :START OF CRASH TABLE AREA
CRSHCT  HC      0               :CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC  HC      1               :CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT  HC      0,0             :WHERE CRASH OCCURED
CFROM   HC      -1,-1           :WHERE CRASH WAS CALLED FROM
CRREG   HS      20              :CRASH REGISTER SAVE AREA
FGNDFL  HS      1               :FOREGROUND FLAG


        SEG     A.CODE          :CODE AREA
CRSHCD  BC      1       :MANUAL RESTART
        BC      0       :POWER FAILURE
        BC      0E      :PARITY ERROR
        BC      10      :DISPATCHER CRASH
        BC      11      :ILLEGAL INSTRUCTION
        BC      12      :ILLEGAL SVC
        BC      13      :SYSTEM CRASH
        BC      14      :PROTECTION VIOLATION
        BC      15      :NON-RECOVERABLE DEVICE CHECK

        RA      0
:       GENERAL MACHINE FAILURE
FAIL    HS      4               :PSD SAVED HERE
        HS      4               :R0,R1 SAVED HERE
        LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
        CLHI    R0,12           :TEST IF ILLEGAL SVC
        JNFS    FAIL1           :NO...SKIP
        LHL     R0,FGNDFL       :DID FOREGROUND CAUSE THE CRASH?
        JN      ENTRY2          :YES....JUMP OVER
FAIL1   STM     R2,CRREG+8      :SAVE THE REGISTERS
        STH     R0,CRASHC       :SAVE CRASH CODE
        LM      R12,FAIL        :GET THE REST
        STM     R14,CRREG       :SAVE R0 & R1
        ST      R13,CPOINT      :SAVE FAILURE ADDRESS
        LCS     R1,1
        ST      R1,CFROM        :FLUSH PLACE CALLED FROM
        J       ENTRY1          :AND SKIP TO START UP AGAIN



:       CRASH ROUTINE AND GENERAL INITIALIZER
:       IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:       THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   STM     R0,CRREG        :SAVE REGISTERS AND
        ST      R10,CPOINT
        LIS     R0,$A10         :FAKE UNKNOWN CRASH
        LCS     R1,1            :FROM NOWHERE
        LHL     R2,0,R10        :CHECK WHERE CALLED FROM
        JNFS    CRASH1          :NOT KNOWN...USE DEFAULT
        LB      R0,3,R10        :GET CRASH CONDITION
        LB      R2,2,R10        :GET CALLING REGISTER
        L       R1,CRREG,R2     :GET CONTENTS OF REGISTER
CRASH1  STH     R0,CRASHC       :SAVE CRASH CODE
        ST      R1,CFROM        :SAVE PLACE CRASHED FROM
        JFS     ENTRY1

:       ENTER HERE WITH RESTART
ENTRY   LIS     R0,1            :LOAD CRASH CODE REGISTER
        STH     R0,CRASHC       :STORE IT
ENTRY1  LIS     R1,1
        AHM     R1,CRSHCT       :SAVE INTERESTING DATA

  IF    CRSTOP          :IF STOPPING ON CONSECUTIVE CRASHES
        CLHI    R0,1
        JLE     ENTRY2          :IF POWER FAILURE OR MANUAL RESTART
        OHI     R0,0CC00        :CRASH INDICATOR FOR FRONT PANEL
        STH     R0,FPANEL,,     :SET PANEL TO BAD CRASH
        LM      R0,CRREG        :RESTORE REGISTERS
        SVC     SYS,HALT.       :HALT THE SLOT
  EI    CRSTOP

        LIS     R0,1            :WANT SECOND WORD OF PSD
        SVC     SYS,RFPSD.      :READ FOREGROUND PSD
        CLI     R0,.            :TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
        JNFS    ENTRY2          :SKIP IF NOT
        STH     R0,FGNDFL       :SET THE FOREGROUND FLAG

ENTRY2          : NOW RESET OUTPUT RING, REPORT CRASH
        LIS     R0,0
        ST      R0,ORING,,      :EMPTY OUTPUT RING
        ST      R0,IRING,,      :EMPTY INPUT RING

        LA      R0,FAIL         :LOAD TRAP AREA ADDRESS
        SVC     SYS,RSTRT.      :RESTART SVC
        JAL     R10,CRASH       :NON-SKIP RETURN...CRASH


        LIS     R0,0
        STH     R0,FGNDFL       :CLEAR THE FOREGROUND FLAG

        JAL     R4,SPACE,,      :SET UP FOR DIAGNOSTIC
        LHI     R0,0300
        JAL     R4,PUTW,,       :PORT 0 + DIAGNOSTIC MESSAGE + PAD
        LHL     R0,CRSHCT
        JAL     R4,PUTCH,,      :HW4 LOW = CRASH COUNT
        LIS     R0,0
        JAL     R4,PUTCH,,      :RESERVED BYTE
        LIS     R0,1
        JAL     R4,PUTCH,,      :REPORT TYPE = 1
        LHL     R0,CRASHC
        JAL     R4,PUTCH,,      :HW3 HIGH = CRASH CODE
        LHI     R0,PRODID
        JAL     R4,PUTCH,,      :HW2 LOW IS PRODUCT ID
        JAL     R4,ELOR,,       :END LOGICAL OUTPUT RECORD
        J       START,,         :NOW GO TO INITIALIZATION CODE
        EM

	

        SUBTTL  Standard Timeout Routine Library        - TIMOUT.LIB
:******************************************************************
:
:       This program is the sole property and confidential
:       information of Tymshare, Inc., and may not be copied
:       in whole or in part or disclosed to any third party
:       without the prior written consent of Tymshare.
:
:*******************************************************************
        RA      0               :       TIMOUT.LIB

:       This package contains the standard timeout routines
:       The following parameters MUST be defined on entry:
:       NTOUT   number of timeout entries which may be active at any one time

:       expects to JAL R10,CRASH if list overflows

:       six symbols are declared:
:       IZT     called at initilization, link on R0
:       TIMOUT  to be called periodicaly, link on on R0
:               will in turn jump to any routines which should be serviced:
:               R0 = routine address
:               R1 = current fast-clock time.
:       TORET   routines called by TIMOUT should exit to here
:       TOPUT   any code may call this to place an entry on timeout list:
:               link on R5...R6--R15 preserved
:               R0 = address to transfer to
:               R1 = next time to call routine
:       TOGET   called to delete an entry already on timout list
:               link on R5...R6--R15 preserved
:               R0 = routine address...entry with this address will be deleted
:       TONOW   called to flush an entry, and execute it NOW!
:               link on R5...NO registers preserved! NOW!
:               routine address in R0
:       NOTE...when a routine is called from timeout list, it is removed from list,
:       and must call TOPUT to be called again.
:       ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	

        GL      IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
        MO      .,TIMOUT

        SEG     A.DATA          :PLACE IN DATA AREA

  IF    6-.
        BS      6-.             :UNUSED 
  EI
TO9     HS      2               :link for timeout processor
LSIZ    EQ      $A 10           :number of bytes in list entry
TLIST   BS      (NTOUT+1)*LSIZ  :timeout list
:                               active list entry = halfword chain pointer
:                               word routine address
:                               word time of next activiation

:               free list pointer is at TLIST
:               active list chain pointer is at TLIST+2
:       CODE SEGMENT
        SEG     A.CODE

TORET   L       R0,TO9          :TIMEOUT ROUTINES EXIT HERE
:       CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT  LHL     R2,TLIST+2      :GET ACTIVE LIST POINTER
        JER     R0              :EXIT IF NO ACTIVE ENTRIES
        L       R1,FASTC,,      :GET CURRENT CLOCK TIME
        CL      R1,TLIST+6,R2   :IS 1ST ACTIVE LIST TIMEOUT DUE
        JLR     R0              :NO TIMEOUTS DUE TO PROCESS
        ST      R0,TO9          :ROUTINE MUST TERMINATE BY JUMPING TO TORET
        LHL     R3,TLIST,R2
        STH     R3,TLIST+2      :SHORTEN ACTIVE LIST
        LHL     R4,TLIST
        STH     R4,TLIST,R2     :SPLICE INTO HEAD OF FREE CHAIN
        STH     R2,TLIST
        L       R0,TLIST+2,R2
        JR      R0              :FETCH ADRS AND ENTER TIMED OUT ROUTINE

:       PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT   LIS     R2,2            :FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1    LR      R3,R2
        LHL     R2,TLIST,R2     :CHECK NEXT TIMEOUT ENTRY
        JEFS    TPT2            :ACTIVE LIST IS EMPTY
        CL      R1,TLIST+6,R2   :IS IT EARLIER THAN ARGUMENT DUE TIME
        JGBS    TPT1            :YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2    LHL     R4,TLIST
        JGFS    TPT3
        JAL     R10,CRASH       :FREE LIST EXHAUSTED
        BC      0,0,4*R5,0F     :FLAG--LINK R5, TYPE 15d CRASH
TPT3    STH     R4,TLIST,R3     :MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
        LHL     R3,TLIST,R4
        STH     R3,TLIST        :SHORTEN FREE LIST
        STH     R2,TLIST,R4     :HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
        ST      R0,TLIST+2,R4
        ST      R1,TLIST+6,R4
        JR      R5              :STORE ARGUMENTS AND RETURN

TONOW   LIS     R1,2            :SEARCH ACTIVE LIST
TONOW1  LR      R2,R1           :COPY CURRENT ENTRY POINTER
        LHL     R1,TLIST,R2     :GET NEXT ENTRY
        JER     R5              :LIST EXHAUSTED...EXIT
        CL      R0,TLIST+2,R1   :CHECK THIS ENTRY
        JNBS    TONOW1          :LOOP IF NOT MATCH
        LHL     R3,TLIST,R1     :WE GOT A MATCH
        STH     R3,TLIST,R2     :UNLINK THIS ENTRY
        LHL     R3,TLIST        :GET START OF FREE LIST
        STH     R3,TLIST,R1     :LINK THIS ENTRY TO FREE LIST
        STH     R1,TLIST        :PLACE ON FREE LIST
        ST      R5,TO9          :SAVE RETURN ADDRESS
        JR      R0              :AND GO TO ROUTINE

TOGET   LIS     R1,2            :SEARCH ACTIVE LIST
TOGET1  LR      R2,R1           :COPY CURRENT ENTRY POINTER
        LHL     R1,TLIST,R2     :GET NEXT ENTRY
        JER     R5              :LIST EXHAUSTED...EXIT
        CL      R0,TLIST+2,R1   :CHECK THIS ENTRY
        JNBS    TOGET1          :LOOP IF NOT MATCH
        LHL     R3,TLIST,R1     :WE GOT A MATCH
        STH     R3,TLIST,R2     :UNLINK THIS ENTRY
        LHL     R3,TLIST        :GET START OF FREE LIST
        STH     R3,TLIST,R1     :LINK THIS ENTRY TO FREE LIST
        STH     R1,TLIST        :PLACE ON FREE LIST
        JR      R5              :AND EXIT

IZT     LHI     R1,NTOUT*LSIZ   :INITIALIZE TIMEOUT FREE LIST
        LIS     R2,0            :0 TERMINATES LIST
        STH     R2,TLIST+2      :ACTIVE LIST IS EMPTY
        STH     R2,TLIST,R1     :TERMINATE FREE LIST
        STH     R1,TLIST-LSIZ,R1
        SIS     R1,LSIZ
        JGBS    .-6
        JR      R0
        EM
        SUBTTL  Data Conversion Routines        - CONVRT.LIB
:******************************************************************
:
:       This program is the sole property and confidential
:       information of Tymshare, Inc., and may not be copied
:       in whole or in part or disclosed to any third party
:       without the prior written consent of Tymshare.
:
:*******************************************************************
:
        RA      0
:
        MO      .,CONVRT
:
        GL      BINDEC
:
:*****************************************************************
:
:       BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:       DATA TO ASCII DECIMAL CHARACTERS.
:
:       ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:                  R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:                  R11 POINTS TO OUTPUT AREA
:       LINK ON R4
:
:****************************************************************
:
        SEG     A.DATA
:
RSAVE   HS      10      :REGISTER SAVE AREA
:
        SEG     A.CODE
:
DIGIT   AC      /0123456789ABCDEF/
:
:       FIRST CHECK FOR A NEGATIVE NUMBER
:               IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC  STM     R8,RSAVE        :PRESERVE REGISTERS
        LR      R9,R9           : TEST FOR NEGATIVE NUMBER
        JGEFS   NOTNEG          :JUMP IF NOT NEGATIVE
        LHI     R12,$0 00AD     :'ASCII '-'
        STB     R12,0,R11
        SIS     R10,1           : ROOM FOR ONE LESS DIGIT
        AIS     R11,1           : DITTO
        JLE     RTRN            :NO ROOM FOR DIGIT AFTER MINUS SINE
:       COMPLEMENT THE NUMBER TO POSITIVE
        XI      R9,-1
        AIS     R9,1
NOTNEG  SIS     R11,1
        LIS     R12,$A 10       : DIVISOR
DIVIDE  SR      R8,R8           : CLEAR HI ORDER BITS OF DIVIDEND
        DR      R8,R12          :GET LOW DIGIT IN R9
        LB      R13,DIGIT,R8    :GET ASCII EQUIVALENT OF DEC NUMBER
        STB     R13,0,R10,R11   :STORE IN REVERSE ORDER
        SIS     R10,1           :DECREMENT COUNTER
        JGBS    DIVIDE          : KEEP LOOPING
RTRN    LM      R8,RSAVE        :RESTORE THE REGISTERS
        JR      R4              :AND RETURN

        EM
:
        SUBTTL  GMT Clock Conversion Routines   - DATIME.LIB
:******************************************************************
:
:       This program is the sole property and confidential
:       information of Tymshare, Inc., and may not be copied
:       in whole or in part or disclosed to any third party
:       without the prior written consent of Tymshare.
:
:*******************************************************************
:
        RA      $0 0A
:
        MO      .,DATIME
:
        GL      DATIME,TMSTMP,DATE
:
:***************************************************************
:
:       THIS PROCEDURE CONVERTS THE GMT CLOCK
:       RELATIVE TO 1/1/74 FROM SECONDS TO
:       DDMMMYY HH:MM (GMT) OR
:       DDMMMYY HH:MM:SS (GMT)
:
:       PARMS
:               R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:               R4 = CHARACTERS OF OUTPUT (13 OR 16)
:               R5 = ADDRESS OF OUTPUT STRING
:               R6 = LINK REGISTER
:       ALL REGISTERS ARE PRESERVED
:
:**************************************************************
:
        SEG     A.DATA
:
RSAVE   HS      $020    :REGISTER SAVE AREA
:
        SEG     A.CODE
DATIME  STM     R0,RSAVE        :PRESERVE THE REGISTERS
        S       R3,SEC745       
:       MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:       A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:       YEAR + 3 REGULAR YEARS.  THERE ARE
:       24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
        SR      R2,R2           : CLEAR HI ORDER BYTES
        D       R2,SECDAY       :QUOTIENT IS # OF DAYS
:                               :REMAINDER IS TIME
        LR      R14,R2          :COPY TIME OF DAY
        SR      R2,R2           :CLEAR HI ORDER BYTES
        D       R2,QUADAY       :DIVIDE BY DAYS IN A QUAD
:
:       QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:       REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
        LHI     R8,76           :BASE YEAR
        SLLS    R3,2            :QUAD YEAR * 4
        AR      R8,R3           :ADD TO BASE YEAR
        LA      R7,LEPYEA       :POINT TO DAYS IN MONTH
        C       R2,W366         :IS IT IN CURRENT YEAR?
        JL      MONTHD          :JUMP IF SO
        S       R2,W366         :SUBTRACT DAYS IN YEAR
        AIS     R8,1            :ADD 1 TO YEAR
        LR      R11,R2          :GET REMAIN DAYS IN QUAD
        SR      R10,R10
        D       R10,W365        :AND DIVIDE BY REGYEAR
:       R11 HAS ADDTL YEARS
:       R10 HAS DAYS IN YEAR
        LR      R2,10
        AR      R8,R11
        LI      R7,REGYER       :POINT TO DAYS IN MONTHS
:
:       DAYS IN R2
:       YEAR IN R8
MONTHD  SR      R6,R6           :MONTH COUNTER
        AIS     R2,1            :MAKE 1/1/76 = DAY 1
MONLOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MONLOP
:
:       DAYS IN R3
:       MONTH NUMBER - 1 IN R6
:       YEAR IN R8
:
:       SAVE R4 AND R5
DAZE    SIS     R4,8            :SUBTRACT OUT DATE LENGTH
        LR      R13,R4          :PRESERVE IT
        LR      R11,R5          :COPY OUPUT AREA POINTER
:
:       CONVERT DAY
        LIS     R10,2           :# OF OUTPUT CHARACTERS
        JAL     R4,BINDEC       :CONVERT TO DECIMAL ASCII
:
:       MOVE IN MONTH
        AIS     R11,2
        SLHLS   R6,2            :MULTIPLY MONTH NUMBER BY 4
        L       R4,MONTHS,R6    :GET THE NAME IN R4
        STB     R4,2,R11
        SRLS    R4,8
        STB     R4,1,R11
        SRLS    R4,8
        STB     R4,0,R11
        AIS     R11,3
:
:       CONVERT YEAR
        LR      R9,R8
        LIS     R10,2
        JAL     R4,BINDEC       :CONVERT TO CHARACTERS
        LHI     R3,$00A0        :ASCII SPACE
        STB     R3,2,R11        :PUT IT AFTER DATE
        LHI     R5,3,R11        :SET UP OUTPUT POINTER
        LR      R4,R13          :COPY LENGTH ARGUEMENT
        LR      R3,R14          :COPY TIME OF DAY
        JFS     TIME1           :JUMP
:*************************************************************
:
:       GET THE TIME STAMP
:
:       TIME STAMP ROUTINE
:               THIS ROUTINE CONVERTS THE FULLWORD GMT TIME OF DAY
:       TO HH:MM OR HH:MM:SS
:
:       PARAMETERS:
:               R3 = FULLWORD TIME OF DAY (GMT CLOCK)
:               R4 = 5 OR 8 (# OF CHARACTERS TO OUTPUT)
:               R5 = FULLWORD ADDRESS OF OUTPUT
:               R6 = LINK REGISTER
:
:       DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:       IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:       ROUTINE IS ALL ABOUT
:
:****************************************************************
TMSTMP  STM     R0,RSAVE        :PRESERVE THE REGISTERS
  IF \TIMZON
        AHI     R3,TIMZON*$A3600        :TIME ZONE CONVERSION
  EI
TIME1   SR      R8,R8           :INDEX FOR OUTPUT AREA
:
        SR      R2,R2           :CLEAR HI-ORDER BITS
        D       R2,SECDAY
:               SECONDS NOW IN R2
        LR      R3,R2           :GET READY FOR
        SR      R2,R2           :ANOTHER DIVIDE
        D       R2,TENOUR       :GET TENS OF HOURS
        JAL     R6,ASCOUT       :PRINT IT OUT IN ASCII
        DH      R2,OURS         :GET HOURS
:               R2 HAS REMAINDER, R3 HAS QUOTIENT
        JAL     R6,ASCOUT       :PRINT IT OUT
        LHI     R3,$00BA        :COLON
        JAL     R6,PRTOUT
        DH      R2,TENMIN
        JAL     R6,ASCOUT
        DH      R2,MIN
        JAL     R6,ASCOUT
:       THE CONDITION CODE HAS BEEN SET -
:       SET IF ANY MORE CHARACTER WANTED
        JE      RETRN           :JUMP IF ONLY 5 CHAR
:
:       PUT IN COLON BEFORE SECONDS
        LHI     R3,$00BA
        JAL     R6,PRTOUT
        DH      R2,TENSEC
        JAL     R6,ASCOUT
        LR      R3,R2           :GET SECONDS IN R3
        JAL     R6,ASCOUT
RETRN   LM      R0,RSAVE        :RESTORE THE REGISTERS
        JR      R6              :RETURN
:
:
ASCOUT  AHI     R3,$00B0
PRTOUT  STB     R3,0,R8,R5
        AIS     R8,1    : UPDATE INDEX
        SIS     R4,1
        JR      R6
:
:****************************************************************
:
:       THIS ROUTINE RETURNS A FULLWORD REPRESENTATION OF THE DATE
:       AND TIME. THE FORMAT OF THE RESULT IS MMDDHHMM WHERE
:       MM, DD, HH, & MM REPRESENT MONTH, DAY, HOUR, & MINUTES RESPECTIVELY
:       ALL IN DECIMAL FORMAT. I.E. DEC 12 13:41 WOULD BE 12121341.
:
:       IF THE SYMBOL TIMEZON IS DEFINED IT SHOULD BE THE TIME-ZONE
:       CORRECTION FACTOR FROM CUT (COORDINATED UNIVERSAL TIME)
:       I.E. PST IS -8.
:
:       PARMS
:               R3 = GMT CLOCK VALUE
:               R6 = RESULT FULLWORD
:
:       LINKS R5
:
:       PRESERVES REGISTERS R7 - R15
:
:******************************************************************
DATE    STM     R7,RSAVE        :PRESERVE THE REGISTERS
        S       R3,SEC745
:       MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:       A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:       YEAR + 3 REGULAR YEARS.  THERE ARE
:       24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
        SR      R2,R2           : CLEAR HI ORDER BYTES
        D       R2,SECDAY       :QUOTIENT IS # OF DAYS
:                               :REMAINDER IS TIME
        LR      R14,R2          :COPY TIME OF DAY
        SR      R2,R2           :CLEAR HI ORDER BYTES
        D       R2,QUADAY       :DIVIDE BY DAYS IN A QUAD
:
:       QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:       REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
        LHI     R8,76           :BASE YEAR
        SLLS    R3,2            :QUAD YEAR * 4
        AR      R8,R3           :ADD TO BASE YEAR
        LA      R7,LEPYEA       :POINT TO DAYS IN MONTH
        C       R2,W366         :IS IT IN CURRENT YEAR?
        JL      MNTHD           :JUMP IF SO
        S       R2,W366         :SUBTRACT DAYS IN YEAR
        AIS     R8,1            :ADD 1 TO YEAR
        LR      R11,R2          :GET REMAIN DAYS IN QUAD
        SR      R10,R10
        D       R10,W365        :AND DIVIDE BY REGYEAR
:       R11 HAS ADDTL YEARS
:       R10 HAS DAYS IN YEAR
        LR      R2,10
        AR      R8,R11
        LI      R7,REGYER       :POINT TO DAYS IN MONTHS
:
:       DAYS IN R2
:       YEAR IN R8
MNTHD   SR      R6,R6           :MONTH COUNTER
        AIS     R2,1            :MAKE 1/1/76 = DAY 1
MLOOP   LR      R9,R2           :SAVE DAYS
        LB      R3,0,R6,R7      :GET DAYS IN MONTH
        SR      R2,R3           :AND SUBTRACT FROM DAYS IN YEAR
        JLEFS   DAZE1           :IF MINUS OR ZERO WE'RE IN THE MONTH
        AIS     R6,1            :INCREMENT INDEX
        JBS     MLOOP
:
:       DAYS IN R9
:       MONTH NUMBER - 1 IN R6
:       YEAR IN R8
:
DAZE1   AIS     R6,1            :CONVERT TO MONTH NUMBER
        LB      R6,DECMAL,R6    :CONVERT TO DECIMAL REPRESENTATION
        SLLS    R6,8            :MOVE IT OVER
        LB      R9,DECMAL,R9    :CONVERT DAY TO DECIMAL
        OR      R6,R9           :OR IT IN
        SLLS    R6,8            :SHIFT IT OVER
        LR      R2,R14          :COPY SECONDS IN THE DAY
        DH      R2,OURS         :R3 HAS NUMBER OF HOURS
        LB      R3,DECMAL,R3    :CONVERT TO DECIMAL
        OR      R6,R3           :OR IT IN
        SLLS    R6,4            :SHIFT IT OVER
        DH      R2,TENMIN       :R3 HAS TENS OF MINUTES
        OR      R6,R3           :OR IT IN
        SLLS    R6,4            :SHIFT IT OVER
        DH      R2,MIN          :R3 HAS MINUTES
        OR      R6,R3           :OR IT IN
:
        LM      R7,RSAVE        :RESTORE REGISTERS
        JR      R5              :RETURN
:
DECMAL  XC      0001020304050607080910111213141516171819202122232425262728293031
SECDAY  WC      24*60*60        :SECONDS IN A DAY
TENOUR  WC      10*60*60        :TENS OF HOURS
OURS    HC      60*60           :HOURS
TENMIN  HC      10*60           :TENS OF MINS
MIN     HC      60              :MIN
TENSEC  HC      10              :TENS OF SECS
  IF    \TIMZON
SEC745  WC      24*60*60*365*2-TIMZON*60*60     :SECONDS IN 74 & 75 PLUS 
                                                :TIME-ZONE CORRECTION
  ELSE
SEC745  WC      24*60*60*365*2  :SECONDS IN 74 AND 75
  EI
W365    WC      365
W366    WC      366
QUADAY  WC      4*365+1
LEPYEA  BC      31,29,31,30,31,30,31,31,30,31,30,31
REGYER  BC      31,28,31,30,31,30,31,31,30,31,30,31
        WS      0
MONTHS  AC      / Jan/
        AC      / Feb/
        AC      / Mar/
        AC      / Apr/
        AC      / May/
        AC      / Jun/
        AC      / Jul/
        AC      / Aug/
        AC      / Sep/
        AC      / Oct/
        AC      / Nov/
        AC      / Dec/
        EM
        RA      0
        SUBTTL  MACROS AND TYM CHECKING
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                    MACROS AND TYM CHECKING                 ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        IF      1-\HP
HP      EQ      0                       :DEFAULT HP OFF
        EI      :1-\HP

: COMMAND TABLE MACRO

CMDTLN  EQ      0C                      :THE LENGTH OF TEXT IN A COMMAND
CMDLEN  EQ      CMDTLN+4                :THE LENGTH OF A COMMAND ENTRY
CMD.DEF MACRO(TEXT,ADDR)[
        AC      'TEXT'
        ORG     Q+CMDTLN
        WC      ADDR
Q       EQ      Q+CMDLEN
]
        SUBTTL  DATA SECTION
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                      E Q U A T E S                       ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

NGRP    EQ      (NPORT+0F)/10           :NUMBER OF PORT GROUPS
LGINSZ  EQ      28                      :MAX SIZE FOR THE LOGON STRING
UBUFSZ  EQ      $A 128                  :USER BFR SIZE
NTRMCH  EQ      14                      :NMBR OF TERM CHARS SUPPORTED

:       CRASH CODES:    MEANING                 CFROM VALUE

CCINDT  EQ      0F0     ILLEGAL ISIS MSG TYPE   MSG TYPE
CCMXPT  EQ      0F1     ISIS PORT NO. TOO BIG   ISIS PORT NUMBER
CCINOD  EQ      0F2     ILLEGAL INTRA-NODE MSG  INTRA-NODE MSG TYPE
CCHANG  EQ      0F3     HANG NON-CONNECT PORT   ISIS PORT NUMBER
CCDUPT  EQ      0F4     NEEDLE ON CON'D PORT    ISIS PORT NUMBER
CCBADZ  EQ      0F5     BAD PORT CHAIN ON ZAP   ISIS PORT NUMBER

:       INTERFACE MSG DATA TYPES

FIRST   EQ      09E                     :FIRST MESSAGE IN LIST

DETMSG  EQ      09E                     :DETACH MESSAGE
ZAPMSG  EQ      09F                     :DISCONNECT MESSAGE
NOSMSG  EQ      0A0                     :APPLY BACK-PRESSURE
SNDMSG  EQ      0A1                     :RELEASE BACK-PRESSURE
GOBMSG  EQ      0A2                     :FLUSH OUTPUT
BKGMSG  EQ      0A3                     :FLUSH INPUT
BLKMSG  EQ      0A4                     :DATA LOST IN THIS DIRECTION
GRYMSG  EQ      0A5                     :DATA LOST IN OPPOSITE DIRECTION
EDMMSG  EQ      0A6                     :ENTER DEFERED ECHO MESSAGE
LDMMSG  EQ      0A7                     :LEAVE DEFERED ECHO MESSAGE
ETMMSG  EQ      0A8                     :ENTER TRANSPARENCY MODE
LTMMSG  EQ      0A9                     :LEAVE TRANSPARENCY MODE
GBMSG   EQ      0AA                     :GREEN BALL
RBMSG   EQ      0AB                     :RED BALL
YBMSG   EQ      0AC                     :YELLOW BALL
OBMSG   EQ      0AD                     :ORANGE BALL
BRKMSG  EQ      0AE                     :BREAK DETECTED
HNGMSG  EQ      0AF                     :HANG UP
QTPMSG  EQ      0B0                     :QUERY TERMINAL PARAMETER
STPMSG  EQ      0B1                     :SET TERMINAL PARAMETER
APNMSG  EQ      0B2                     :AUX PSEUDO NEEDLE
NLOGCH  EQ      0B3                     :NORMAL LOGON CHAR
NLOGST  EQ      0B4                     :NORMAL LOGON STATUS
LGFAIL  EQ      0B5                     :LOGON FAILURE
NLOGOK  EQ      0B6                     :SUCCESSFUL LOGON
SHGMSG  EQ      0B8                     :SUPER-HANG UP
SXMLMT  EQ      0B9                     :SET TRANSMIT LIMIT
BREMSG  EQ      0BA                     :BREAK END
ZAPACK  EQ      0BB                     :ZAP ACK
EAODM   EQ      0BC                     :ENTER ALT DEV. MODE
LAODM   EQ      0BD                     :LEAVE ALT DEV. MODE
ZAPREA  EQ      0BE                     :ZAP WITH REASON
SIIXM   EQ      0BF                     :SIIX
TIIXM   EQ      0C0                     :TIIX

MAXTYP  EQ      0C0                     :MAX TYPE DEFINED
NRMTYP  EQ      7                       :NORMAL CKT PSEUDO-NEEDLE REQUEST
AUXTYP  EQ      8                       :AUX CKT PSEUDO-NEEDLE REQUEST

: IMMEDIATE COMMANDS

        IF      HP                      :TEST FOR HP TERMINAL OPTION
AT.SC   EQ      50                      :<ESC>-P SELECT COMMAND MODE.
AT.NM   EQ      51                      :<ESC>-Q SEND USER NAME
AT.LC   EQ      52                      :<ESC>-R LABEL CIRCUIT
Q       EQ      53                    :<ESC>-S
AT.NC   EQ      54                      :<ESC>-T NEXT CIRCUIT
AT.FL   EQ      55                      :<ESC>-U FLUSH/STEP
AT.BP   EQ      56                      :<ESC>-V BACK PESSURE/STEP
Q       EQ      57                      :<ESC>-W

        ELSE    :HP

AT.SC   EQ      5A                      :<ESC>-Z SELECT COMMAND MODE
AT.NM   EQ      4E                      :<ESC>-N SEND USER NAME 
AT.LC   EQ      43                      :<ESC>-C LABEL CIRCUIT
AT.NC   EQ      45                      :<ESC>-E NEXT CIRCUIT
AT.FL   EQ      46                      :<ESC>-F FLUSH DATA
AT.BP   EQ      42                      :<ESC>-B BACKPRESSURE & STEP

        EI      :HP

	

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              V A R I A B L E     S T O R A G E               ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        SEG     0

START0  HS      0                       :BEGINNING OF AREA TO ZERO ON START-UP
LOGSAV  HS      3
NLEN    EQ      10                      :LENGTH OF A NAME
NLENS   EQ      4                       :SHIFT AMT FOR NAME (NLEN=2**NLENS)
NTBLE   HS      NLEN*NPORT/2            :USER DEFINABLE PORT NAME
:                                       :FORMAT = <LEN><15 CHRS OF NAME>
PTBLE   HS      NPORT                   :DEST FOR GIVEN PORT, 0 IF INACTIVE
BTBLE   HS      NPORT                   :USER BASE FOR THE GIVEN PORT
CTBLE   HS      NPORT                   :LINK TO NEXT PORT ON THIS BOSS
:       IF THE PORT IS A BOSS THEN THE USER BASE HAS BIT X'8000' SET
PSNEDL  HS      NGRP                    :PSEUDO NEEDLE RECEIVED
APORT   HS      NGRP                    :ARRAY FOR PORTS THAT ARE ACTIVE
DUMP    HS      NGRP                    :USERS MAY HAVE PORTS FLUSHED
TYMSAT  HS      NGRP                    :SET IF CIRCUIT CAME FROM NEEDLE
BKPRSR  HS      NGRP                    :BACKPRESSURED PORT ARRAY(0 = BACKPRSR)
TOISIS  HS      NGRP                    :BACKPRESSURE ARRAY
ECHO    HS      NGRP                    :ECHO ARRAY(ECHO BACK TO BOSS PORT)
DEM     HS      NGRP                    :IF ECHO AND CANT ECHO THEN DEM
NBO     HS      NGRP                    :NO BALLS OUT FOR THIS PORT
EXPECT  HS      NGRP                    :EXPECTING A RETURNED BALL
ECTLI   HS      NGRP                    :ECHO CONTROL-I
ELFCR   HS      NGRP                    :ECHO LF W/CR
ECRLF   HS      NGRP                    :ECHO CR W/LF
CRDE    HS      NGRP                    :CR DELAY
PARITY  HS      NGRP                    :BIT FOR PARITY
HAFDUX  HS      NGRP                    :HALF DUPLEX PORTS
XONENA  HS      NGRP                    :X ON-ENABLE
ECTLH   HS      NGRP                    :ECHO CONTROL-H
YONENA  HS      NGRP                    :REVERSE X-ENABLE
TBOA    HS      NGRP                    :THESE ARE TIMEOUT FLAGS
TBOB    HS      NGRP                    :THESE ARE PROBABLY USELESS
KATA    HS      NGRP                    :KATAKANA
T.BRK   HS      NGRP                    :TERMINATE OUTPUT ON BREAK
EC.ESC  HS      NGRP                    :ECHO ESCAPE
Q.MOD   HS      NGRP                    :'Q' -MODE, DEM ON CR
BRATE   BS      NPORT                   :IO BAUD RATES
PAB     BS      NPORT                   :PARAMETERS A,B
PCD     BS      NPORT                   :PARAMETERS C,D

ZAPSAV  WS      1                       :SEE ZAP
NXTSAV  WS      1                       :SEE NXTPT SAVE FOR LINK
TEMP    WS      10                      :GENERAL SAVE AREA
TEMP1   HS      1
CNKTMP  WS      1                       :SAVE AREA FOR CONNECT RTN.
SVNRM1  WS      1                       :SAVE FOR USER NAME LOGIN
CSTRBA  HS      1                       :BIT ARRAY ADDRESS (LESS 10000X)
ALLWHO  HS      1                       :FLAG 0=ACTIVE WHOS, -1=ALL WHOS
CSAVE   WS      2                       :SPACE TO SAVE RING REGISTERS
END0    WS      0                       :END OF AREA TO ZERO AT STARTUP

RLINK   WS      1
TEMP3   WS      2
TEMP2   HS      1
CHRSAV  BS      1                       :SAVE CHARACTER FOR USER

FRISIS  HS                              :FROM ISIS BACKPRESSURE ARRAY
        RE      NGRP+1
        HC      -1
        ER
STOPPD  RE      NGRP+1                  :RECORD OF BOSS BCKPRS REQUEST
        HC      -1
        ER

: MODIFYABLE MESSAGES

TALKFRM sc      /"8D"8AIncoming TALK from                       "07"8D"8A/
TALKNDX EQ      TALKFRM+$016   : where to put username
TALKCNT EQ      $00E

NLCHAR  BC      2,NLOGCH,0              :NORMAL LOGON CHAR MSG

:       QUERY TERMINAL PARAMETERS

        HS      0
QUMSG   BC      2
        BC      $0 0B0
QUERX   BS      1

:       SET TERMINAL PARAMETERS

        BND     2                       :SO ONE CAN 'STH'
SETMSG  BC      3                       :MESSAGE LENGTH(AFTER PORTNUMBER)
        BC      $0 0B1                  :MESSAGE TYPE
TERPAR  BS      1                       :PARAMETER TO BE SET
TERVAL  BS      1                       :VALUE TO SET TO

:       PSEUDO-NEEDLE REQUEST
                
        BND     2
        BS      1                       :FILLER TO ALIGN HALFWORDS
PNREQ   BC      9                       :MSG LENGTH (SC FORMAT)
PNTYP   BC      7                       :MSG TYPE
PNKEY   BC      0                       :KEY
PNLKEY  HS      1                       :LOCAL KEY
PNDIAL  HC      0                       :DIALECT
PNHOST  HS      1                       :ORIG HOST
PNTID   BS      1                       :TID

:       EXTENDED HOST STATUS

        BND     2
        BS      1                       :FILLER TO ALIGN HW'S
ANSMSG  BC      $A 11                   :LENGTH OF MESSAGE
        BC      10,0                    :MSG TYPE / KEY
ANSHST  HS      1                       :HOST #
ANSPRT  HS      1                       :# PORTS
ANSRHN  HC      0                       :RELATIVE HOST 
        BC      0                       :HOST STATUS = ANSWERED
        HC      PRODID                  :PRODUCT ID

	

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                  B U F F E R   S T O R A G E                   ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: USER BLOCK LAYOUT

BLCKS   WS      0                       :START OF USER BLOCK STORAGE
        ORG     0                       :LAYOUT OF USER BLOCKS
NAME    HS      6                       :USER NAME (12 CHARS MAX)
DUMMY	BS	1			:MAKE BLOCK CORRECT LENGTH
ATCHAR  BS      1                       :USERS ATTEN CHAR
STATU   BS      1                       :USERS STATUS
BOSSP   HS      1                       :BOSS PORT FOR THIS USER
LPORT   HS      1                       :PORT CURRENTLY IN LOGON FOR THIS USER
SPORT   HS      1                       :PORT CURRENTLY IN COMMUNICATION
XPORT   HS      1                       :LAST PORT LABEL PRINTED
FPORT   HS      1                       :FIRST PORT IN CHAIN
UFLAG   HS      1                       :FLAGS INDICATING CONDITION OF BOSS
CMNDR6  HS      2
CMNDR7  HS      2
CMNDR8  HS      2
CMNDR9  HS      2
CMNDAD  HS      2                       :CMND PROCESSOR LAST CALL REGISTER
CVALUE  HS      1                       :COMMAND STRING NUMBER VALUE
NFLAG   HS      1                       :THIS FLAG SET IF CR AFTER LAST CMD LTR
TALKFG  HS      1                       :FLAGS CONTROLLING TALKING TO USER
ESCAPE  HS      1
UTEMP   WS      1
CYBTIM  HS      2
LGINEM  HS      1                       :CURRENT EMPTY INDEX FOR LOGIN
LGINFL  HS      1                       :CURRENT FILL INDEX FOR LOGIN
STRSIZ  HS      1                       :SIZE OF STRING FOR INPUT (MAX)
ITCFLG  HS      (NTRMCH+0F)/10          :INITIAL TERM CHARS NOT IN YET
ITCVAL  BS      NTRMCH                  :INITIAL VAL OF TERM CHARS FOR BOSS
SETN    HS      1                       :TERMINAL PARAMETER NUMBER TO SET
UBUFER  HS      UBUFSZ/2                :GENERAL USER STORAGE

:       FLAG EQUATES (FOR UFLAG, 1 BIT EACH)

FFRZ    EQ      8000                    :INDICATES BOSS IS FROZEN
FSEND   EQ      4000                    :INDICATES BOSS IN SEND MODE
FLAB    EQ      2000                    :SET IF USER WANTS LABELING
FMSGPR  EQ      1000                    :SET IF MESSAGE NOT YET PRINTED
FLOG    EQ      800                     :SET IF USER IS LOGGING
FPASEC  EQ      40                      :PASSWORD ECHO BIT 1=ECHO ON

:       FLAG EQUATES (FOR TALKFG, 1 BIT EACH)

TKNVR   EQ      8000                    :INDICATES TALK NEVER ALLOWED
TKNB    EQ      4000                    :INDICATES TALK ONLY IF NOT BUSY
TASK    EQ      2000                    :INDICATES ASK USER IF OK (FUTURE)

ENDBLK  WS      0                       :MARKS START OF NEXT USER BLOCK

: GENERATE USER BLOCKS

        ORG     BLCKS
USR     EQ      0

        RE      NUSERS
        BND     4
USER|USR| HS    0
        ORG     USER|USR|+NAME
        U|USR|NAM
        ORG     USER|USR|+ATCHAR
        BC      U|USR|ATT
        ORG     USER|USR|+STATU
        BC      U|USR|STT
        ORG     USER|USR|+TALKFG
        HC      U|USR|TFG
        ORG     USER|USR|+ENDBLK
        KILL    U|USR|NAM,U|USR|ATT,U|USR|TFG,U|USR|STT
USR     EQ      USR+1
        ER

LSTBLK  WS      0

: GREETING MESSAGE BUFFER

GRETMG  BC      0                       :156 BYTES OF GREETING MESSAGE
        BS      $A 156                  :INITIALIZED TO NULL
GRETME  EQ      .-2

	

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              U N M O D I F I E D   D A T A                   ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        SEG     1
ZAPPED  SC      /"8D"8ATalk - Circuit terminated: /
GREY    SC      /"8D"8ATalk - Grey ball"8D"8A/
BLACK   SC      /"8D"8ATalk - Black ball"8D"8A/

PROMPT  sc      /"8D"8ATalk: /

CRLFMG  BC      02,8D,8A                :2 LONG, CR, LF
UPCRMG  BC      03,5E,0D,0A             :3 LONG, ^, CR, LF
BKSPMG  BC      01,08                   :1 LONG, BS (BACK SPACE)
STARMG  BC      04,0A0,0AA,8D,8A        :4 LONG, ' ',':',CR,LF

BOSSMG  WC      04C2CFD3,0D3000000      :4 LONG, "BOSS"
SLAVMG  WC      05D3CCC1,0D6C50000      :5 LONG, "SLAVE"

SETXMT  BC      2,0B9,09D               :SET TRANSMIT LIMIT
ECHON   BC      3,0B1,0,1               :SET ECHO ON
ECHOF   BC      3,0B1,0,0               :SET ECHO OFF

DLMARY  WC      00000000,800B0020,00000000,00000001  :DELIMITERS
CTLDLM  WC      08000000                :MESSAGES END WITH ^D

BMSG1   SC      /"8A"8DTalk - Invalid port specified"8A"8D/  :port # not valid
BMSG2   SC      /"8A"8DTalk - No such command"8A"8D/         :command not valid
BMSG3   SC      /"8A"8DTalk - User not available"8A"8D/      :user not entered
BMSG4   SC      /"8A"8DTalk - Line too long"8A"8D/           :line too long
BMSG5   SC      /"8A"8DTalk - Invalid number"8A"8D/          :number invalid
BMSG7   SC      /"8A"8DTalk - Can not switch to BOSS port"8A"8D/   :can not switch boss
bmsg8   sc      /"8A"8DTalk - User not allowing TALK access"8A"8D/ :user has talk never
bmsg9   sc      /"8A"8DTalk - User busy, try later"8A"8D/          :user has talk @busy

: LOGON MESSAGES

NLSTYP  WC      NLS0
        WC      PLIMSG
        WC      NLS2
        WC      NLS3
        WC      NLS4
        WC      NLS5
        WC      NLSILL
        WC      NLSILL

NLS0    SC      /"8D"8ATalk - Illegal responce - circuit zapped"8D"8A/
PLIMSG  SC      /"8D"8ATalk - Please log in: /
NLS2    SC      /"8D"8ATalk - Error, type username: /
NLS3    SC      /"8D"8ATalk - Error, type password: /
NLS4    SC      /"8D"8ATalk - Type username: /
NLS5    SC      /"8D"8ATalk - Enter password: /
NLSILL  SC      /"8D"8ATalk - Got Bad Logon Status!"87"8D"8A/

: PSEUDO-NEEDLE REJECT MESSAGES

ARJTYP  WC      ARJ0
        WC      ARJ1
        WC      ARJ2
        WC      ARJ3
        WC      ARJ4
        WC      ARJ5
        WC      ARJ6
        WC      ARJ7
        WC      ARJ8
        WC      ARJ9
        WC      ARJA

ARJ0    SC      /Talk - Can not communicate with Supervisor, try later"8D"8A/
ARJ1    SC      /Talk - Username format error"8D"8A/
ARJ2    SC      /Talk - Bad User Name"8D"8A/
ARJ3    SC      /Talk - Error in Master User Directory"8D"8A/
ARJ4    SC      /Talk - Destination system unavailable"8D"8A/
ARJ5    SC      /Talk - Down-line load or dial-out failure"8D"8A/
ARJ6    SC      /Talk - Login timeout"8D"8A/
ARJ7    SC      /Talk - Destination access not permitted"8D"8A/
ARJ8    SC      /Talk - Out of origination ports"8D"8A/
ARJ9    SC      /Talk - Please try again later"8D"8A/
ARJA    SC      /Talk - Unknown logon error"8D"8A/
ARJMAX  EQ      $0 0A                   :LAST VALID #

: INVALID USER MESSAGE

BADGY   EQ      .
        BDMSG

: HELP MESSAGES

MSGH    SC      /Commands for use at the 'Talk:' prompt:"8D"8A/
        SC      /  Allwho       List all valid users         NOLabel     Stop labeling output"8D"8A/
        SC      /  CHar <chr>   Set\display attn char        OFf <pl>    Flush output"8D"8A/
        SC      /  COnn <p1,p2> Connect output of 1st        ON <pl>     Stop flushing output"8D"8A/
        SC      /               port to input of 2nd         QUit        Zap all circuits"8D"8A/
        SC      /  EXit         Leave the TALK service       Send <pl>   Send to port"8D"8A/
        SC      /  Freeze       Freeze current boss          SET <n1,n2> Set boss term param"8D"8A/
        SC      /  HEAr         Allow incoming TALK          TAlk <user> Talk to another user"8D"8A/
        SC      /  Help         Print this list              THaw        Allow boss to float"8D"8A/
        SC      /  List         List ports                   Time        Print date & time"8D"8A/
        SC      /  LAbel        Label output to boss         TRans <pl>  Transfer boss"8D"8A/
        SC      /  Make         Make a new circuit           Version     Print TALK version"8D"8A/
        SC      /  MEssage      Print last greeting msg      Who         List active users"8D"8A/
        sc      /  NOBusy       Disallow TALK when busy      NOHear      Always disallow TALK"8D"8A/
	sc	/  Zap <pl>     Zap a port/
        SC      /"8D"8A/
        SC      /Commands for use when not at the 'Talk:' prompt:"8D"8A/
        SC      /  <attn>-B     Backpressure & goto next     <attn>-F    Flush & goto next"8D"8A/
        SC      /  <attn>-C     Label current circuit        <attn>-N    Send username"8D"8A/
        SC      /  <attn>-E     Go to next circuit           <attn>-Z    Get 'Talk:' prompt back"8D"8A/
        SC      /"8D"8A/
        HPMSG
        BC      0
:
: HEADER/VERSION/HOST MESSAGES
:
MSGHI   SC      /"8D"8A"8A"8A>>> Welcome to the FAA demo Talk Service <<<"8D"8A"8A"8A/

        HC      MSGVLN                  :FAKE SC FORMAT
MSGVER  EQ      .-1
        AC      /Version /
        BC      0B0+VERSION
        AC      /./
        BC      0B0+REVLEV/8
        BC      0B0+REVLEV-((REVLEV)/8)*8)
        AC      /, Host /

:       COMPUTE Q1 TO Q6 FOR HOST NUMBER
:       EXAMPLE :   0  0  1  1  5  7 
:                  Q1 Q2 Q3 Q4 Q5 Q6
:
QH      EQ      HOST0                   :HOST #
MAXDIG  EQ      6
QN      EQ      MAXDIG                  :MAX # ALLOWED
QQ      EQ      1                       : DEFAULT TO 1

  RE    MAXDIG
Q|QN|   EQ      QH-(QH/$A10)*10         :ASSIGN NEXT DIGIT
QH      EQ      QH/$A10                 :SET 'HOST #' TO HOST #/ 10d

   IF   Q|QN|                             : IF # WAS NOT ZERO...
QQ      EQ      QN                        : SET QQ TO HIGHEST SIG BYTE SO FAR
   EI   

QN      EQ      QN-1
  ER
:       PLACE DATA INTO BYTES

  RE    MAXDIG-QQ+1
        BC      Q|QQ|+0B0
QQ      EQ      QQ+1
  ER

        BC      8D,8A                   :CR,LF
MSGVLN  EQ      .-MSGVER-1
        SUBTTL  INITIALIZATION
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              I N I T I A L I Z A T I O N                     ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       BRING HOST UP

START   LA      R1,USER0                :START OF USER BLOCKS
        LIS     R0,0                    :GET A NULL
START1  STH     R0,BOSSP,R1             :ZERO THE BOSSP
        STH     R0,LPORT,R1
        STH     R0,FPORT,R1             :CLEAR PORT CHAIN
        STH     R0,UFLAG,R1             :INITIALIZE THE FLAGS
        AHI     R1,ENDBLK               :NEXT USER
        CLHI    R1,LSTBLK               :ALL DONE?
        JL      START1
        LHI     R10,2*NGRP-2            :THIS MANY GROUPS
        LIS     R0,0
START4  STH     R0,APORT,R10            :RESET ACTIVE PORT ARRAY
        STH     R0,FRISIS,R10           :RESET FROM ISIS BP ARRAY
        STH     R0,DUMP,R10             :RESET PORT DUMPING BIT ARRAY
        STH     R0,PSNEDL,R10           :RESET PSEUDO NEEDLE MODE
        SIS     R10,2                   :NONE THERE DO NEXT GROUP
        JGEBS   START4

        LIS     R12,MAXHST-1
STA005  LHL     R0,HOSTS,R12,R12        :GET HOST 
        STH     R0,ANSHST               :PUT IT IN MSG
        LHL     R0,PORTS,,              :GET # OF PORTS
        NHI     R0,1FF                  :EXTRACT # PORTS
        STH     R0,ANSPRT               :PUT IT IN MSG
        STH     R12,ANSRHN              :SAVE RELATIVE HOST NUMBER
        LIS     R2,0                    :SEND TO PORT 0
        LA      R3,ANSMSG               :ADDR OF MSG
        JAL     R5,OCM                  :OUTPUT MSG
        SIS     R12,1
        JGE     STA005
        LIS     R0,0
        LHI     R1,END0-START0-4
STA010  ST      R0,START0,R1            :INIT TO ZERO
        SIS     R1,4
        JGEBS   STA010                  :ZERO ENTIRE AREA
        LCS     R0,1

:       SET UP TIMEOUT LIST

        JAL     R0,IZT                  :INITIALIZE TIMEOUT LIST
        L       R7,FASTC,,              :GET REFERENCE TIME
        LHI     R1,RATE/4,R7            :TIME FOR QSEC LOGIC
        LA      R0,QSEC
        JAL     R5,TOPUT
        LHI     R1,RATE*8
        LA      R0,SEC8                 :RUNS EVERY EIGHT SECONDS
        JAL     R5,TOPUT
        J       INPUT                   :START MAIN LOOP
        SUBTTL  INPUT FROM ISIS DISPATCHER
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              I N P U T      F R O M      I S I S             ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

IPRMPT  HS      0                       :PRINT PROMPT AND WAIT FOR INPUT
        LA      R3,PROMPT               :PRINT COMMAND PROMPT
        TS      UBUFER,R13              :SET USER BUFFER TO NOT USABLE
        LHL     R2,BOSSP,R13            :GET BOSS PORT
        JEFS    INPUT                   :NO BOSS, SKIP
        JAL     R5,OCS
        LA      R0,CGETW                :SET UP FOR INPUT
        ST      R0,CMNDAD,R13           :/

INPUT   LIS     R0,0
        JAL     R0,TIMOUT               :PROCESS PERIODIC LOGIC
        JAL     R4,LOOK                 :ANYTHING FROM ISIS?
        J       OUTPUT                  :SEND ANY MESSAGES TO BOSS
        JN      INEEDL                  :JUMP NOT INTRA-NODE COMMUNICATION

:       INTRA-NODE COM - EAT IF ALLOWED, ELSE CRASH

        CLHI    R2,9                    :PSEUDO NEEDLE REJECT?
        JE      PSNRJT                  :IF SO
        CLHI    R2,NOSTYPE-1            :CHECK FOR MAX SUBTYPE
        JGFS    IIND10                  :CRASH IF ILLEGAL SUBTYPE
        LB      R0,INODTS,R2            :ALLOWED TO EAT ?
        JEFS    IIND10                  :NOPE, CRASH
        JAL     R4,FLUSH                :EAT
        J       INPUT                   :CHECK INPUT AGAIN

IIND10  JAL     R10,CRASH               :CRASH, CFROM GIVES MSG TYPE
        BC      0,0,R2*4,CCINOD

:       INTRA-NODE MSG TABLE:
:               BYTE COUNT TO EAT (NOT INCLUDING RPORT)
:               0 IF ILLEGAL MESSAGE

INODTS  BC      0                       :00 - VOLUNTARY INTERFACE DISC
        BC      1                       :01 - RESTART INTERFACE
        BC      1                       :02 - NODE TAKEN OVER
        BC      0                       :03 - REPORT TO SUP LOG
        BC      0                       :04 - REPORT HOST STATUS
        BC      0                       :05 - REPORT ACCOUNTING
        BC      6                       :06 - TELL HOST TIME
        BC      0                       :07 - ORIGINATE NORMAL CIR PSEUDO-NDL
        BC      0                       :08 - ORIGINATE AUX CKT
        BC      0                       :09 - CAN'T PROVIDE PSEUDO NEEDLE
        BC      0                       :0A - REPORT HOST AVAILABILITY
        BC      0                       :0B - HOST UNACCEPTBLE
        BC      0                       :0C - REPORT HOST COST
NOSTYPE EQ      .-INODTS                :# OF SUBTYPES

: NEEDLE PROCESSING
:       CRASH IF ALREADY CONNECTED, ELSE ASSIGN
:       AS A TYMSAT PORT TO BOSS OR SLAVE

INEEDL  CLHI    R1,NPORT                :TOO MANY PORTS ASSIGNED ?
        JLEFS   INED05                  :JUMP IF NOT
        JAL     R10,CRASH               :CRASH, CFORON GIVES ISIS PORT NUMBER
        BC      0,0,R1*4,CCMXPT

INED05  LR      R2,R2                   :NEEDLE (0) ?
        JN      IDATA                   :JUMP IF NOT
        JAL     R4,GETH                 :GET ADDITIONAL LENGTH
        LR      R3,R0                   :SAVE
        JAL     R4,GETW                 :EAT INVOICE
        JAL     R4,GETW                 :EAT DEST HOST / ORIG NODE
        JAL     R4,GETW                 :EAT ORIG HOST / ORIG PORT
        JAL     R4,GETW                 :EAT XXXX
        JAL     R4,GETH                 :EAT ORIG PORT (DIALECT CODE IN ISIS-2)
        JAL     R4,GETCH                :GET TID
        LH      R0,BTBLE,R1,R1          :DOES IT HAVE A BOSS
        JEFS    INED20                  :JUMP WAS'NT ACTIVE

        JAL     R10,CRASH               :CRASH, CFROM GIVES ISIS PORT NUMBER
        BC      0,0,R1*4,CCDUPT


INED20  JAL     R4,GETCH                :GET THE SIZE OF THE USERNAME
        LR      R3,R0                   :SAVE IT
        LIS     R5,0                    :MAKE AN INDEX
INED21  JAL     R4,GETCH
        OHI     R0,80                   :SET MSB
        CLHI    R0,0A1                  :DID THE SUP MESS THE NAME
        JE      INED2A                  :YES,TOSS THIS
        STB     R0,LOGSAV,R5
        AIS     R5,1
INED2A  SIS     R3,1
        JG      INED21                  :KEEP LOOKING.
        STB     R3,LOGSAV-1,R5          :SET LAST BYTE TO '00'
        JAL     R4,ELIR
:       FIND USER NAME IN USER'S BUFFER
        LA      R6,USER0                :FIRST ENTRY
        LA      R7,LOGSAV               :KEY TO SEARCH FOR
        LA      R9,LSTBLK,,             :END OF LAST ENTRY
        LHI     R14,ENDBLK              :SIZE OF EACH ENTRY
        JAL     R3,FIND                 :GO FIND IT!
        JFS     .+6                     :NOT FOUND, ZAP PORT
        J       DORTHY                  :FOUND, CONTINUE
        LR      R2,R1                   :SEND THE MESSAGE FOR A BAD GUY
        LR      R6,R1                   :SAVE THE PORT NUMBER
        LA      R3,BADGY
        JAL     R5,OCS
        LIS     R0,3                    :#BYTES IN MESSAGE
        LR      R1,R6                   :RECOVER THE PORT NUMBER
        LHI     R2,DETMSG               :MESSAGE TYPE
        JAL     R4,SLOR                 :SEND IT
        JAL     R4,ELOR
        J       INPUT

:       THIS CIRCUIT WILL BE A BOSS
:       IF BOSS ALREADY THERE IT BECOMES SLAVE

DORTHY  LHL     R2,FPORT,R6             :PUT ON CHAIN FOR THIS BOSS
        STH     R1,FPORT,R6
        STH     R2,CTBLE,R1,R1
        SBT     R1,DEM                  :TYMSATS START IN DEM

INED22  LHI     R8,NTRMCH               :SET UP INDEX FOR TERMINAL QUERY
        LR      R10,R1                  :SAVE THE PORT NUMBER
        SBT     R1,APORT                :SET ACTIVE PORT
INED23  SIS     R8,1
        STB     R8,QUERX
        LA      R3,QUMSG                :ADDRESS OF QUERY TERMINAL
        LR      R2,R10                  :GET PORT NUMBER AGAIN
        JAL     R5,OCM
        LR      R8,R8
        JGBS    INED23                  :SEND ANOTHER

        LA      R3,SETXMT               :SET XMIT LIMIT TO MAX
        LR      R2,R10                  :PORT #
        JAL     R5,OCM

        LIS     R0,1
        SBT     R10,TYMSAT              :SET THIS BIT
        SBT     R10,NBO                 :NO BALLS OUT
        RBT     R10,EXPECT
        RBT     R10,DUMP                :NOT FLUSHING
        LHL     R1,BOSSP,R6             :GET THE BOSS PORT FOR THIS BLOCK
        JE      INED24                  :NO BOSS YET,SET THIS ONE UP
:       WE HAVE A BOSS ALREADY,IS IT FROZEN
        LHI     R0,FFRZ                 :FREEZE FLAG
        NH      R0,UFLAG,R6             :IS IT SET
        JE      INEDXX                  :NO, SET UP NEW BOSS
:       THIS NEEDLE CREATES A SLAVE PORT
        STH     R1,PTBLE,R10,R10        :INITIALIZE DESTINATION
        STH     R6,BTBLE,R10,R10        :SET UP BOSS BASE
        SLLS    R10,NLENS               :INITIALIZE THE NAME
        L       R2,SLAVMG               :STORE NAME ("SLAVE")
        ST      R2,NTBLE,R10
        L       R2,SLAVMG+4
        ST      R2,NTBLE+4,R10
        J       INPUT                   :CONTINUE
:       DOWN GRADE OLD BOSS TO SLAVE
INEDXX  STH     R10,PTBLE,R1,R1         :SET THE DESTINATION
        STH     R6,BTBLE,R1,R1          :SAVE THE CONTROL BASE
        SLLS    R1,NLENS                        :MAKE AN INDEX
        L       R2,SLAVMG               :STORE NAME ("SLAVE")
        ST      R2,NTBLE,R1
        L       R2,SLAVMG+4
        ST      R2,NTBLE+4,R1
:       SET UP NEW BOSS PORT
INED24  LR      R13,R6                  :SET UP USER REGISTER
        STH     R10,BOSSP,R13           :SAVE ISIS PORT NUMBER
        SBT     R10,FRISIS              :RESET BACK PRESSURE
        LR      R2,R13
        OHI     R2,8000                 :SET THE SIGN BIT
        STH     R2,BTBLE,R10,R10        :THIS PORT IS A BOSS
        LHL     R2,UFLAG,R13
        NHI     R2,@FSEND&@FLOG         :CLEAR SEND MODE
        STH     R2,UFLAG,R13
        LI      R2,7FFFFFFF             :INDICATE NO INITIAL TERM CHARS IN
        ST      R2,ITCFLG,R13           :*EXCEPT ECHO
        SLLS    R10,NLENS
        L       R2,BOSSMG               :GIVING THE PORT A NAME
        ST      R2,NTBLE,R10
        L       R2,BOSSMG+4
        ST      R2,NTBLE+4,R10
        SRLS    R10,NLENS               :RESTORE PORT NUMBER
        LR      R2,R10
        LA      R3,ECHON                :TURN ECHO ON
        JAL     R5,OCM
        SBT     R10,ECHO
        LIS     R2,1
        STB     R2,ITCVAL,R13
        LR      R2,R10
        LA      R3,MSGHI
        JAL     R5,OCS                  :START CLEANED UP
        LR      R2,R10                  :BOSS #
        LA      R3,MSGVER               :
        JAL     R5,OCS                  :PRINT IT
        LHL     R2,UFLAG,R13            :GET USERS FLAG
        NHI     R2,FMSGPR               :TEST FOR MESSAGE TO SEND?
        JE      INED30                  :BIT NOT SET, SKIP MESSAGE

        LB      R0,GRETMG,,             :SEE IF ANY GREETING MSG
        JEFS    INED31                  :BR IF NOT
        LR      R2,R10                  :GET PORT #
        LA      R3,GRETMG,,             :GET AND PRINT A GREETING MESSAGE
        JAL     R5,OCS                  :PRINT IT TO BOSS

INED31  LHL     R2,UFLAG,R13            :GET USER FLAG
        NHI     R2,@FMSGPR              :TURN OFF BIT
        STH     R2,UFLAG,R13            :STORE USER'S FLAG

INED30  LR      R6,R10
INED25  JAL     R9,NXTCRQ               :CHECK OUT ALL USER PORTS
        LH      R0,SPORT,R13            :CHECK FOR PORT ASSIGNED
        JNFS    INED28                  :YES, SKIP ASSIGNMENT
        CR      R3,R10                  :SEE IF BOSS
        JNFS    INED29                  :BR IF NOT
        LR      R6,R3
        JAL     R9,NXTCRQ               :GET NEXT AFTER BOSS
        CR      R3,R10                  :SEE IF BOSS AGAIN
        JEFS    INED28                  :BR IF SO
INED29  STH     R3,SPORT,R13            :NO, ASSIGN IT
INED28  JAL     R9,CRQPRI               :PRINT CIRCUIT NAME
        STH     R10,PTBLE,R8,R8         :MUST BE RESET IF USER IS RELOGGING 
        CLR     R8,R10
        JEFS    INED26                  :DONE WITH ALL USER PORTS?
        LR      R6,R8
        J       INED25
INED26  LA      R3,PROMPT
INED27  LR      R2,R10                  :GET THE BOSS PORT
        JAL     R5,OCS
        TS      UBUFER,R13              :VOID USER BUFFER
        LA      R3,CGETW                :SET NEW BOSS TI START IN COMMAND MODE
        ST      R3,CMNDAD,R13
        J       INPUT                   :CHECK INPUT AGAIN

: DATA MSG - GIVE TO INPUT COMMAND PROCESSOR IF BOSS
:               ELSE OUTPUT ON CRQ.
:
:       THE INPUT COMMAND PROCESSOR DOES A 'JALR R5,R11'
:       TO GET EACH CHARACTER AS IT COMES IN.  A NEEDLE INITIALIZES
:       US TO RETURN TO THE COMMAND PROCESSOR THE 1ST CHARACTER.
:       REG CONVENTIONS ARE:
:               R0      CHARACTER INPUT TO CMND PROCESSOR
:               R1      ISIS PORT NUMBER
:               R2-R5   UNSAVED CMND PROCESSOR REGS
:               R6-R7   CMDN PROCESSOR REGS SAVED BETWEEN CHAR CALLS
:               R8-R10  UNSAVED COMND PROCESSOR REGS
:               R11     CHAR INPUT RET ADDR USED BY COMMAND PROCESSOR
:               R12     CHARACTERS REMAINING IN RECORD (INCLUDING CURRENT CHAR)
:               R13-R15 UNSAVED CMND PROCESSOR REGS

IDATA   CLHI    R2,0B2                  :PSEUDONEDL?
        JE      INDAPN
        CLHI    R2,FIRST                :DATA MSG?
        JGE     INDATA                  :JUMP IF NOT
        TBT     R1,APORT
        JE      IDATA2
        LH      R13,BTBLE,R1,R1         :GET THE USER BASE FOR THE PORT
        JL      IDAT05                  :THIS IS A BOSS

        TBT     R1,DUMP                 :FLUSHING FOR THIS PORT?
        JN      IDATA2                  :YES
        LR      R8,R1                   :COPY PORT NO.
:       FIRST CHECK TO SEE IF USER WANTS CIRCUITS LABELED
        LHI     R0,FLAB                 :GET 'LABEL' FLAG
        NH      R0,UFLAG,R13            :IS IT SET?
        JE      NOLAB                   :NO, SKIP IT.
        CH      R1,XPORT,R13            :HAVE WE PRINTED THIS LBL?
        JE      NOLAB                   :YES, SKIP IT
        LHL     R10,BOSSP,R13           :GET BOSS PORT
        JE      NOLAB                   :NO BOSS, SKIP IT.
        LR      R3,R1                   :GET PORT #
        ST      R14,TEMP3               :SAVE R14
        ST      R2,TEMP3+4              :AND R2
        STH     R3,XPORT,R13            :SAVE LAST PRINTED
        JAL     R9,CRQPRI               :PRINT LABEL TO USER
        LR      R1,R3                   :SET UP TO CONTINUE
        L       R14,TEMP3               :RESTORE R14
        L       R2,TEMP3+4              :AND R12

NOLAB   HS      0
        LHL     R1,PTBLE,R1,R1          :GET DESTINATION
        JE      IDATA2                  :DEST SHOULD BE HERE
:       SEND MESSAGE TO DEST
        LHI     R0,3,R2                 :COMPUTE MSG BYTE COUNT
        JAL     R4,SLOR                 :START OUTPUT RECORD
        JAL     R4,GETCH                :FLUSH MSG TYPE

IDATA0  JAL     R4,GETCH                :GET CHAR FROM IRING
        JAL     R4,PUTCH                :PUT IT IN ORING
        SIS     R2,1                    :DEC BYTE COUNT
        JG      IDATA0                  :COPY ALL CHARS IN MSG

        JAL     R4,ELIR                 :END INPUT
        JAL     R4,ELOR                 :END OUTPUT
        J       INPUT                   :GO CHECK INPUT AGAIN

IDATA2  LHI     R0,1,R2                 :MAKE BYTE COUNT TO FLUSH
        JAL     R4,FLUSH                :FLUSH
        J       INPUT                   :GO CHECK INPUT AGAIN

IDAT05  NHI     R13,7FFF                :REMOVE THE SIGN BIT
        LR      R10,R1                  :R10 WILL KEEP THE BOSSP
        JAL     R4,GETCH                :READ PAST MSG TYPE (CNT)
        LR      R12,R2                  :COPY CHAR COUNT
        L       R5,CMNDAD,R13           :GET ADDR LAST CALL FOR CHAR
        L       R6,CMNDR6,R13           :RESTORE SAVED REGISTERS
        L       R7,CMNDR7,R13
        L       R8,CMNDR8,R13
        L       R9,CMNDR9,R13

IDAT10  JAL     R4,GETCH                :GET A CHAR
        LH      R4,ESCAPE,R13
        JL      SPECIA
        LR      R3,R0
        NHI     R3,7F
        CLB     R3,ATCHAR,R13           :USER'S ATTENTION CHARACTER?
        JNFS    IDAT15
        TS      ESCAPE,R13              :SET FOR RESPONSE TO NEXT CHAR
        JFS     IDAT20
IDAT15  STM     R14,CSAVE               :SAVE REGS
        JALR    R11,R5                  :GIVE CHAR TO USER PROCESS
        LM      R14,CSAVE               :RESTORE RING REGISTERS
IDAT20  SIS     R12,1                   :DEC COUNT FOR THIS RECORD
        JN      IDAT10                  :JUMP MORE IN RECORD

        JAL     R4,ELIR                 :END INPUT RECORD
        ST      R5,CMNDAD,R13           :SAVE LAST CALL FOR CHAR ADDR
        ST      R6,CMNDR6,R13           :SAVE REGS
        ST      R7,CMNDR7,R13
        ST      R8,CMNDR8,R13           :SAVE REG
        ST      R9,CMNDR9,R13
        J       INPUT                   :CHECK INPUT AGAIN

SPECIA  LIS     R3,0
        STH     R3,ESCAPE,R13
        LR      R3,R0                   :GET THE CHARACTER
        NHI     R3,5F                   :REMOVE THESE BITS
        CLHI    R3,AT.SC                :SELECT CMD MODE?
        JE      SPEC1                   :SKIP IF SO
        LA      R11,IDAT15+6            :BETTER INITIALIZEE THIS RETURN
        STM     R14,CSAVE               :SAVE THE RING REGISTERS
        J       4,R5                    :SKIP RETURN IF ESCAPED CHARACTER

SPEC1   JAL     R6,CMODE                :SET FOR COMMAND MODE
        J       IDAT20                  :GO DIRECTLY TO COMMAND MODE

: NON-DATA MSG ( ON PORT # >0)  - FAN OUT BY TYPE
:               R1 - PORT #
:               R2 - MESSAGE TYPE

INDATA  TBT     R1,APORT                :ACTIVE?
        JE      INDEAT                  :NOI
        CLHI    R2,MAXTYP               :TYPE IN OUR TABLE ?
        JGFS    INDCRH                  :JUMP TO CRASH IF NOT
        LHI     R13,7FFF                :GET A MASK
        NH      R13,BTBLE,R1,R1                 :HGET BOSS BASE
        JE      CRASH                   :MUST HAVE A BOSS
        LH      R10,BOSSP,R13           :GET THE BOSS PORT
        LHL     R3,INDFAN-FIRST*2,R2,R2
        J       SEG1,R3                 :FAN OUT

:       NON-DATA UNKNOWN - CRASH

INDCRH  JAL     R10,CRASH               :CRASH, CFROM HAS MSG TYPE
        BC      0,0,R2*4,CCINDT

: NON-DATA MESSAGE TYPE FAN-OUT TABLE

INDFAN  HC      INDCRH-SEG1             :9E - DETACH(YELLOW BALL & ZAP)
        HC      INDZAP-SEG1             :9F - DISCONNECT(ZAPPER)
        HC      INDBKP-SEG1             :A0 - APPLY BACKPRESSURE
        HC      INDBKP-SEG1             :A1 - REELEASE BACKPREESSURE
        HC      INDPAS-SEG1             :A2 - FLUSH OUTPUT (GOBBLE)
        HC      INDEAT-SEG1             :A3 - FLUSH INPUT
        HC      INDBLK-SEG1             :A4 - DATA LOST IN THIS DIRECTION
        HC      INDGRY-SEG1             :A5 - DATA LOST IN OTHER DIRECTION
        HC      INDEDM-SEG1             :A6 - ENTER DEFFERED ECHO MODE
        HC      INDLDM-SEG1             :A7 - LEAVE DEFERED ECHO MODE
        HC      INDEAT-SEG1             :A8 - ENTER TRANSPERENCY  &&X.25 FIX&&
        HC      INDEAT-SEG1             :A9 - LEAVE TRANSEPERENCY &&WAS PAS &&
        HC      INDGRN-SEG1             :AA - GREEN BALL
        HC      INDRED-SEG1             :AB - RED BALL
        HC      INDYEL-SEG1             :AC - YELLOW BALL
        HC      INDORN-SEG1             :AD - ORANGE BALL
        HC      INDBRK-SEG1             :AE - BREAK DETECTED
        HC      INDHNG-SEG1             :AF - HANG UP
        HC      QPARAM-SEG1             :B0 - QUERY TERMINAL PARAMETER
        HC      SPARAM-SEG1             :B1 - SET TERMINAL PARAMETER
        HC      INDCRH-SEG1             :B2 - AUX PSEUDO NEEDLE
        HC      INDCRH-SEG1             :B3 - NORMAL LOGON CHAR
        HC      INDNLS-SEG1             :B4 - NORMAL LOGON STATUS
        HC      INDLOF-SEG1             :B5 - LOGON FAILURE
        HC      INDLON-SEG1             :B6 - SUCCESSFUL LOGON
        HC      INDCRH-SEG1             :B7 - ADDENDUM TO ACCOUNTING
        HC      INDEAT-SEG1             :B8 - SUPER-HANG UP /IGNORE FOR SUP
        HC      INDEAT-SEG1             :B9 - TRANSMIT LIMIT
        HC      INDEAT-SEG1             :BA - 'BREAK' END
        HC      INDCRH-SEG1             :BB - ZAP ACK
        HC      INDPAS-SEG1             :BC - LEAVE ALTERNATE DEVICE
        HC      INDPAS-SEG1             :BD - ENTER ALTERNATE DEVICE
        HC      INDZAP-SEG1             :BE - ZAP WITH REASON
        HC      INDPAS-SEG1             :BF - SIIX
        HC      INDPAS-SEG1             :C0 - TIIX

: NON-DATA MESSAGE SIZES (BYTES, NOT INCLUDING RPORT)

INDSIZ  BC      1                       : 9E    DETACH
        BC      1                       : 9F    DISCONNECT
        BC      1                       : A0    APPLY BACKPRESSURE
        BC      1                       : A1    RELEASE BACKPRESSURE
        BC      1                       : A2    FLUSH FORWARD
        BC      1                       : A3    FLUSH BACKWARD
        BC      1                       : A4    BLACK BALL
        BC      1                       : A5    GREY BALL
        BC      1                       : A6    ENTER "DEM"
        BC      1                       : A7    LEAVE "DEM"
        BC      1                       : A8    ENTER "TRANSPARENCY"
        BC      1                       : A9    LEAVE "TRANSPARENCY"
        BC      1                       : AA    GREEN BALL
        BC      1                       : AB    RED BALL
        BC      1                       : AC    YELLOW BALL
        BC      1                       : AD    ORANGE BALL
        BC      1                       : AE    "BREAK" DETECTED
        BC      1                       : AF    "HANG UP"
        BC      2                       : B0    QUERY TERMINAL PARAMETER
        BC      3                       : B1    SET TERMINAL PARAMETER
        BC      4                       : B2    AUX PSEUDO-NEEDLE
        BC      2                       : B3    NORMAL LOGON CHAR
        BC      2                       : B4    NORMAL LOGON STATUS
        BC      2                       : B5    LOGON FAILURE
        BC      8                       : B6    SUCCESSFUL LOGON
        BC      6                       : B7    ADDENDUM TO ACCOUNTING
        BC      1                       : B8    SUPER-"HANG UP"
        BC      2                       : B9    TRANSMIT LIMIT
        BC      1                       : BA    'BREAK' END
        BC      1                       : BB    ZAP ACK
        BC      1                       : BC    ENTER ALTERNATE DEVICE
        BC      1                       : BD    LEAVE ALTERNATE MODE
        BC      1                       : BE    ZAP WITH REASON
        BC      1                       : BF    SIIX
        BC      1                       : C0    TIIX

: QUERY TERMINAL PARAMETER (B0)

QPARAM  JAL     R4,GETCH                :READ PAST MESSAGE TYPE
        JAL     R4,GETCH                :GET THE PARAMETER NUMBER
        LR      R9,R0                   :SAVE IT
        JAL     R4,ELIR                 :END THE INPUT
QPARM1  TBT     R1,TYMSAT               :DONT RESPOND TO TYMSATS
        JN      INPUT                   :IF SO RETURN TO INPUT
        LR      R9,R9                   :SEE IF ECHO
        JEFS    QECHO                   :GO HANDLE SPECIALLY IF SO
        JAL     R8,QTPAR                :GET TERM PARAM
        JFS     QRESP

QECHO   LIS     R5,1                    :PREPARE FOR ECHO ON RESULT
        TBT     R1,ECHO                 :ECHO ON?
        JNFS    QRESP                   :YES
        TBT     R1,DEM                  :ABOUT TO GO ON
        JNFS    QRESP                   :YES,RETURN AS ON
        LIS     R5,0

QRESP   LHI     R2,STPMSG               :RESPONSE IS 'SET TERMINAL MESSAGE'
        LIS     R0,5
        JAL     R4,SLOR
        LR      R0,R9
        JAL     R4,PUTCH                :PUT THE PARAMETER NUMBER
        LR      R0,R5                   :PLACE THE VALUE
        JAL     R4,PUTCH
        JAL     R4,ELOR                 :END IT
        J       INPUT

: SET TERMINAL PARAMETER (B1)

SPARAM  JAL     R4,GETCH                :READ PAST MESSAGE TYPE
        JAL     R4,GETCH                :GET THE PARAMETER NUMBER
        LR      R9,R0
        JAL     R4,GETCH
        JAL     R4,ELIR                 :END THE MESSAGE
        LR      R5,R0                   :SAVE VALUE
:       SET TERM PARAM FROM BOSS
        CR      R1,R10                  :SEE IF BOSS
        JN      SPAR3                   :BR IF NOT
        CLHI    R9,NTRMCH               :SEE IF WE KNOW ABOUT TERM PARAM
        JGE     QPARM1                  :BR IF NOT
        RBT     R9,ITCFLG,R13           :SEE IF NEED INITIAL VALUE
        JE      QPARM1                  :BR IF NOT
        STB     R5,ITCVAL,R13,R9        :SAVE INITIAL VALUE
        JAL     R8,STPAR                :SET BOSS VALUE
        TBT     R9,INITIT               :SEE IF TO PASS TO ALL PORTS
        JE      QPARM1                  :BR IF NOT
        LHL     R1,FPORT,R13
SPAR4   JAL     R8,STPAR                :SET ON ALL PORTS FOR THIS BOSS
        LHL     R1,CTBLE,R1,R1          :GET NEXT IN CHAIN
        JNBS    SPAR4                   :BR UNLESS DONE
        LR      R1,R10                  :GET PORT BACK
        J       QPARM1
:       SET ECHO ON
SPAR3   LR      R9,R9
        JN      SPAR6                   :BR IF NOT ECHO
        NHI     R0,1
        JEFS    SECHO1
        TBT     R1,ECHO                 :SET THE ECHO
        JN      SPAR5                   :ALREADY ON ACKNOWLEDGE
        SBT     R1,DEM                  :OFF, LET USUAL MECHANISM DO IT
        J       SPAR5
:       SET ECHO OFF
SECHO1  RBT     R1,ECHO                 :RESET ECHO
        JEFS    SECHO2                  :MAKE SURE IT STAYS OFF
        LIS     R0,3                    :PREPARE ENTER DEF ECHO MSG
        LHI     R2,EDMMSG               :MESSAGE TYPE
        JAL     R4,SLOR                 :START RECORD,R1 HAS PORT
        JAL     R4,ELOR                 :END IT
SECHO2  RBT     R1,DEM                  :DISARM GREEN BALLSTUFF
        RBT     R1,EXPECT               :DONT EXPECT ANY BALLS
        JEFS    SPAR5                   :REPORT BACK IF NONE WERE OUT
        LIS     R0,3                    :MSG SIZE
        LHI     R2,RBMSG                :CANCEL BALL THATS OUT
        JAL     R4,SLOR
        JAL     R4,ELOR                 :SEND TO THE RING
        RBT     R1,TBOA                 :RESET THE RED BALL TIMEOUTS
        RBT     R1,TBOB
        JFS     SPAR5                   :GO ACKNOWLEDGE
:       SET TERM PARAM
SPAR6   JAL     R8,STPAR                :SET TERM PARAM
SPAR5   LHL     R2,UFLAG,R13
        THI     R2,FSEND                :SEE IF THIS IS CURRENT SEND PORT
        JE      QPARM1                  :BR IF NOT
        CLH     R1,SPORT,R13
        JN      QPARM1                  :BR IF NOT
        ST      R1,TEMP
        JAL     R8,SBPAR                :SEND TO BOSS NOW
        L       R1,TEMP
        J       QPARM1                  :GO SEND RESPONSE

INITIT  WC      $2 00001111111110010000000000000000 :TERM PARAMS TO PASS TO
                                                :*ALL CIRCUITS IF BOSS CHANGES
: ORANGE BALL (AD)
:       IF YELLOW BALL OUT, CONNECT INPUT AGAIN

INDORN  LH      R13,BTBLE,R1,R1         :FIND THE BOSS
        JGE     INDEAT                  :THIS ISNT A BOSS, GO EAT
        NHI     R13,7FFF                :REMOVE THE SIGN BIT
        L       R0,CYBTIM,R13           :YELLOW BALL OUT
        JEFS    INDEAT                  :NOPE, EAT
        LIS     R0,0                    :RESET YELLOW BALL OUT
        ST      R0,CYBTIM,R13
        LA      R0,CGETW                :CONNECT INPUT PROCESS
        ST      R0,CMNDAD,R13

: NON-DATA DON'T CARE - EAT REMAINDER OF MESSAGE

INDEAT  LB      R0,INDSIZ-FIRST,R2      :GET MSG SIZE
        JAL     R4,FLUSH                :EAT IT
        J       INPUT                   :CHECK INPUT AGAIN

: PSEUDO-NEEDLE REJECT (0000,09)

PSNRJT  JAL     R4,GETH                 :SUBTYPE / KEY
        JAL     R4,GETH                 :LOCAL KEY
        LR      R13,R0                  :SAVE KEY AS INDEX
        LIS     R0,0
        STH     R0,LGINFL,R13           :MARK LOGIN STRING STORAGE AS UNUSED
        JAL     R4,GETCH                :TYPE OF ERROR
PSNRJ0  JAL     R4,ELIR
PSNRJ1  CLHI    R0,ARJMAX               :CHECK ERR #
        JLEFS   PSNRJ4                  :SKIP IF OK
        LIS     R0,ARJMAX               :OUT OF RANGE - FORCE 7
PSNRJ4  SLHLS   R0,2                    :MAKE WORD INDEX
        LR      R2,R0
        L       R3,ARJTYP,R2            :GET REJECT MSG TYPE
        JAL     R5,OMSG                 :OUTPUT TO RING
        J       IPRMPT                  :GO PRINT PROMPT AND INPUT /\/

: NORMAL LOGON STATUS (B4)

INDNLS  JAL     R4,GETH                 :GET STATUS
        JAL     R4,ELIR
        LIS     R12,7                   :MASK 'ERROR' TYPE
        NR      R12,R0
        JEFS    INDNL5                  :IF ZERO (CONTINUE) SKIP MESSAGE
:       SEND 'ERROR' MESSAGE TO BOSS (ERROR, TYPE PASSWD,...)
        SLLS    R12,2                   :CREATE WORD INDEX
        LHL     R2,BOSSP,R13            :GET BOSS PORT FOR MESSAGE
        JEFS    INDNL5                  :SKIP OUTPUT IF NO BOSS
        L       R3,NLSTYP,R12           :GET ADDR OF MESSAGE
        LR      R6,R1                   :SAVE PORT NUMBER
        LR      R7,R0                   :SAVE REG 0 (FOR ECHO/EMPTY INFO)
        JAL     R5,OCS                  :PRINT STRING
        LR      R1,R6                   :RESTORE PORT #
        LR      R0,R7                   :RESTORE REG 0

INDNL5  HS      0
        THI     R0,$210100000           :EMPTY BUFFER (EITHER) ?
        JEFS    INDNL6                  :NO, SKIP
        LIS     R6,0
        STH     R6,LGINFL,R13           :SET FILL POINTER AND
        STH     R6,LGINEM,R13           :EMPTY POINTER TO ZERO
INDNL6  HS      0
:               SET ECHO ON/OFF BASED ON SUP FLAG
        NHI     R0,FPASEC               :ISOLATE PASWORD ECHO BIT
        LHL     R2,UFLAG,R13            :GET USER FLAGS
        NHI     R2,@FPASEC              :ZERO PASSWORD BIT
        OR      R0,R2                   :SUM THEM
        STH     R0,UFLAG,R13            :SAVE IT BACK

        STH     R1,LPORT,R13            :START SENDING MORE B3'S
        J       INPUT                   :CONTUINUE

: LOGON FAILURE (B5)

INDLOF  JAL     R4,GETH                 :GET MSG / ERR #
        JAL     R4,ELIR
        LBR     R12,R0
        JAL     R6,ZAP
        LHL     R1,BOSSP,R13            :GET BOSS PORT
        LR      R0,R12
        J       PSNRJ1                  :TELL BOSS THE REASON

: PSEUDO-NEEDLE RECEIVED (B2)

INDAPN  JAL     R4,GETH                 :SKIP TYPE AND KEY
        JAL     R4,GETH                 :LOCAL KEY
        LR      R13,R0
        JAL     R4,ELIR
        SBT     R1,PSNEDL               :INDICATE PSEUDO NEEDLE RECEIVED
        JN      INDCRH                  :THIS SHOULD BE ZERO
        SBT     R1,APORT                :SET ACTIVE PORT
        STH     R1,LPORT,R13            :PORT CURRENTLY IN LOGON
        STH     R1,SPORT,R13            :CURRENT PORT
        RBT     R1,DEM                  :RESET DEM MODE
        RBT     R1,EXPECT
        STH     R13,BTBLE,R1,R1
        LHL     R4,FPORT,R13            :PUT ON CHAIN FOR THIS BOSS
        STH     R1,FPORT,R13
        STH     R4,CTBLE,R1,R1

        SBT     R1,FRISIS               :INIT UN-BACKPRESSURED
        RBT     R1,DUMP                 :NOT FLUSHING DATA ON THIS PORT
        LHL     R10,BOSSP,R13           :OUTPUT GOES TO BOSS
        STH     R10,PTBLE,R1,R1         :/

        LR      R12,R14
        SLLS    R1,NLENS
        LHI     R4,3                    :PATCH IN A LENGTH
        STB     R4,NTBLE,R1
        LA      R14,NTBLE+1,R1
        SRLS    R1,NLENS
        LIS     R4,0A                   :DECIMAL
        LIS     R15,3
        JAL     R5,CBAL
        LR      R14,R12

        LIS     R12,0
        STH     R12,LGINEM,R13          :INITIAL LOGIN INDEX (EMPTY)
        J       INPUT                   :YES, WAIT FOR SUCCESSFUL LOGON MSG

: SUCCESSFUL LOGON (B6)

INDLON  LIS     R0,8                    :#CHARS TO FLUSH
        JAL     R4,FLUSH                :FLUSH REMAINDER OF MESSAGE
        SBT     R1,BKPRSR               :RESET BACK PRESSURE
        SBT     R1,FRISIS
        RBT     R1,ECHO                 :START MODE FOR TYMSAT SIDE
        SBT     R1,NBO                  :NO BALLS OUT FOR THIS PORT
        RBT     R1,DUMP                 :NOT FLUSHING
        RBT     R1,TYMSAT
        RBT     R1,PSNEDL               :INDICATE LOGON COMPLETE
        JE      INDCRH                  :CRASH IF NOT ALREADY SET
        STH     R1,SPORT,R13            :SEND BOSS RIGHT INTO TRANSPERENCY
        ST      R1,CMNDR6,R13           :SET UP THE COMMAND REGISTERS
        STH     R10,PTBLE,R1,R1         :SET DESTINATION
        LIS     R2,0
        STH     R2,LPORT,R13            :REMOVE PORT FROM LOGON MODE
        ST      R2,CMNDR7,R13           :INITIATE COMMAND REGISTER
        LA      R5,CSEND2               :PUT BOSS IN SEND MODE
        ST      R5,CMNDAD,R13           :NEEDLE TO COMMAND PROCESSOR
        LHI     R0,FSEND
        OH      R0,UFLAG,R13            :SET SEND FLAG
        NHI     R0,@FLOG                :TURN OFF LOG
        STH     R0,UFLAG,R13

        LR      R6,R1                   :SAVE PORT #
        LIS     R9,1
INL10   LR      R1,R10                  :GET CURRENT BOSS TERM PARAM
        JAL     R8,QTPAR
        LR      R1,R6
        JAL     R8,STPAR                :SET NEW CIRCUIT TERM PARAMS
        AIS     R9,1                    :*TO BOSS'S INITIAL VALUES
        CLHI    R9,NTRMCH
        JL      INL10

:       SET XMIT LIMIT TO MAX FOR BETTER THROUGHPUT

        LR      R2,R6                   :PORT FOR OCM
        LA      R3,SETXMT               :SET XMIT LIMIT MESSAGE
        JAL     R5,OCM

:       COPY LOGIN BUFFER OUT TO PORT FOR 'TYPE AHEAD'

        LR      R1,R6                   :RESTORE PORT # (WIPED BY OCM)
        LH      R12,LGINEM,R13          :R12=EMPTY INX.GET EMPTY INDEX
        LA      R3,UBUFER,R12,R13       :R03=START OF DATA
        LH      R12,LGINFL,R13          :R12=FILL INX.COMPARE TO FILL POINTER
        SH      R12,LGINEM,R13          :R12=LENGTH
        JLE     INPUT                   :CAUGHT UP, NO DATA TO SEND

        LHI     R0,3,R12                :R00=LEN+3 :COMPUTE RECORD SIZE
        LR      R2,R12                  :R02=LENGTH :GET MSG NMBR (BYTE LEN)
        JAL     R4,SLOR                 :START OUTPUT
        LH      R12,LGINEM,R13          :R12=EMPTY INX.
        LA      R3,UBUFER,R12,R13       :R03=STRING ADDRESS
:               PORT # AND LENGTH ARE THERE ALREADY
        JAL     R5,OBS                  :OUTPUT STRING
        JAL     R4,ELOR                 :CLOSE OFF RECORD
        J       INPUT

: NON-DATA BACKPRESSURE (A0/A1)
:       APPLY THE MESSAGE (AO,A1)TO ALL PORTS WITH THIS AS DEST

INDBKP  LR      R5,R1                   :SAVE THE PORT
        LIS     R0,3                    :SENDING 3 BYTES
        LHI     R1,NPORT                :CHECK ALL PORTS
BKP0    CH      R5,PTBLE,R1,R1          :DO THIS ONE?
        JNFS    BKP1
        CR      R10,R1                  :DONT BFPRSR BOSS
        JEFS    BKP1
        TBT     R1,STOPPD               :UNLESS REQUESTED BY BOSS
        JEFS    BKP1
        JAL     R4,SLOR                 :SEND MESSAGE IN R2
        JAL     R4,ELOR
BKP1    SIS     R1,1
        JL      INDEAT
        J       BKP0

: CIRCUIT ZAPPER/HANG (9F/AF)

INDZAP  LIS     R0,1                    :EAT ZAPPER AND CLOSE RECORD
        JAL     R4,FLUSH
        JAL     R6,ZAP1                 :PROCESS PORT ZAP
        J       INPUT

INDHNG  LIS     R0,1                    :EAT HANG AND CLOSE RECORD
        JAL     R4,FLUSH
        JAL     R6,ZAP                  :RETURN ZAPPER
        J       INPUT

: BLACK/GRAY BALL (A4/A5)

INDBLK  LA      R3,BLACK                :BLACK BALL MSG
INDB10  LIS     R0,1
        JAL     R4,FLUSH                :EAT MSG
        JAL     R5,OMSG                 :GO TELL THE BOSS
INDB30  J       INPUT

INDGRY  LA      R3,GREY
        J       INDB10

: BREAK DETECTED (AE)
:       SEND GOBBLER DOWN THE LINE

INDBRK  LHI     R2,GOBMSG
        LIS     R0,3
        JAL     R4,SLOR
        JAL     R4,ELOR
        LHI     R2,BRKMSG
        CLH     R1,BOSSP,R13            :IS IT THE BOSS?
        JN      INDPAS                  :NOPE.  JUST PASS IT.
        LHL     R1,SPORT,R13            :YEP, SEND BREAK ON OUR CURRENT PORT
        JE      INDEAT                  :UNLESS WE DON'T HAVE ONE
        J       INDBNC

: ENTER OR LEAVE DEFFERED ECHO MODE (A6/A7)

INDEDM  SBT     R1,DEM
        J       INDEAT

INDLDM  RBT     R1,DEM                  :RESET IT
        J       INDEAT

: GREEN BALL (AA)
:       IF FROM BOSS TREAT AS IF THIS WERE BASE
:       IF FROM BASE, TREAT AS IF THIS WERE TYMSAT

INDGRN  CR      R1,R10                  :IS THIS THE BOSS?
        JE      BOSGRN                  :IF SO HANDLE DIFFERENT
        RBT     R1,EXPECT               :WERE WE EXPECTING?
        JE      INDEAT                  :NO
        SBT     R1,NBO                  :NO MORE BALLS OUT
        SBT     R1,ECHO                 :RESTORE ECHO
        RBT     R1,DEM                  :AND EMIT NO MORE(IN ECHO MODE NO MORE)
        JE      INDEAT                  :IF OFF ALREADY DONT SEND LDMMSG
        LIS     R0,1                    :EAT REMAINDER OF INPUT
        JAL     R4,FLUSH                :FLUSH IT(R0 HAS BYTES TO FLUSH)
        LIS     R0,3                    :PREPARE NEW MESSAGE
        LHI     R2,LDMMSG               :TELLING BASE"LEAVE DEFFERED ECHO"
        JAL     R4,SLOR                 :START IT
        JAL     R4,ELOR                 :END IT
        LR      R1,R10                  :GET BOSS PORT
        JE      INPUT
        RBT     R1,EXPECT               :SEE IF BOSS WAITING TO END DEM
        JE      INPUT                   :BR IF NOT
        LIS     R0,3
        LHI     R2,GBMSG                :SEND GREEN BALL ON TO BOSS
        JAL     R4,SLOR
        JAL     R4,ELOR
        J       INPUT

BOSGRN  LHI     R0,FSEND                :IN SEND MODE?
        NH      R0,UFLAG,R13
        JE      INDBNC                  :GO BOUNCE GB IF NOT
        LH      R0,SPORT,R13            :GET CURRENT SEND PORT
        JE      INDEAT
        TBT     R0,DEM                  :SEND PORT IN DEM?
        JE      INDBNC                  :GO BOUNCE GB IF NOT
        SBT     R1,EXPECT               :WAIT FOR SEND PORT TO LEAVE DEM
        J       INDEAT

: RED BALL (AB)
:       LIKE GREEN, THE RED HAS TWO MODES, BASE AND TYMSAT

INDRED  LH      R4,BTBLE,R1,R1          :LOOK AT THE BOSS BLOCK
        JLFS    INRED2                  :BR IF FROM BOSS
        SBT     R1,NBO                  :ELSE, JUST NOTE ITS RETURN
        J       INDEAT

INRED2  RBT     R1,EXPECT               :BOSS NOT WAITING FOR GRN BALL NOW
        JFS     INDBNC                  :GO BOUNCE RED BALL

: YELLOW BALL (AC)

INDYEL  AIS     R2,1                    :CONVERT TO ORANGE

: BOUNCE NON-DATA MSG - SEND MSG JUST RECEIVED BACK TO SENDER
:                       R2 HAS MSG TYPE, ASSUMED TO BE LENGTH 3
INDBNC  LIS     R0,1                    :EAT REMAINDER OF INPUT
        JAL     R4,FLUSH
        LIS     R0,3                    :MSG LENGTH 3
        JAL     R4,SLOR                 :SEND MSG TYPE IN R2
        JAL     R4,ELOR
        J       INPUT                   :CHECK INPUT AGAIN

: SEND NON-DATA MESSAGE ALONG TO DESTINATION
:               R1 = INPUT PORT #
:               R2 = MESSAGE TYPE

INDPAS  HS      0
        LHL     R1,PTBLE,R1,R1          :GET DESTINATION PORT #
        JE      INDEAT                  :SKIP IF PORT NOT ASSIGNED
        JBS     INDBNC                  :GO SENT DATA ON
        SUBTTL  LOGIN CHAR SENDER
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              L O G I N  C H A R  S E N D E R                 ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

OUTPUT  LA      R13,USER0               :GET THE FIRST USER BLOCK
OUTP2   LHL     R9,LPORT,R13            :IS THIS USER IN LOGIN MODE
        JE      OUTP3
        LH      R12,LGINEM,R13          :GET LOGIN CHARACTER INDEX
LGG0    CLH     R12,LGINFL,R13          :IS THE BUFFER EMPTY
        JGE     LGG2                    :YES WAIT TIL USER ADD CHAR
        LB      R8,UBUFER,R12,R13       :GET LOGIN CHAR
        OHI     R8,80                   :SET MSB FOR SUP
        STB     R8,NLCHAR+2             :PUT CHAR IN MSG
        LA      R3,NLCHAR               :ADDR OF MSG
        LR      R2,R9                   :PORT#
        JAL     R5,OCM                  :OUTPUT LOGIN CHAR
        AIS     R12,1                   :INC CHAR INDEX
        CLHI    R8,0BB                  :SEMI-COLON?
        JE      LGG1                    :YES
        CLHI    R8,8D                   :<CR>?
        JN      LGG0                    :NO, SEND NEXT CHAR
LGG1    LIS     R9,0
        STH     R9,LPORT,R13            :DONT PASS THRU HERE UNTIL B4 OR B2
        JFS     LGG2
LGG4    LIS     R12,0                   :IF BOTH INDEXES ARE EQUAL...
        STH     R12,LGINFL,R13          : ...RESET TO ZERO (MAKE BUFFER 
:                                       :    LOOK BIGGER)
LGG2    STH     R12,LGINEM,R13          :SAVE LOGIN CHAR INDEX
OUTP3   LA      R13,ENDBLK,R13          :GET THE NEXT USER
        CLHI    R13,LSTBLK              :LAST BLOCK?
        JN      OUTP2                   :NO, GO DO IT
        SVC     FASTD,0                 :DISMISS THEN RESTART
        J       INPUT
        SUBTTL  COMMAND PROCESSOR
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              C O M M A N D     P R O C E S S O R               ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: EAT ALL INPUT - WATCH YELLOW BALL OUT TIMER

CEAT    HS      0                       :EAT DATA.
        LHL     R2,BOSSP,R13            :GET THE BOSS PORT
        LA      R3,PROMPT               :GET PROMPT
        JAL     R5,OCS                  :OUTPUT PROMPT STRING
        TS      UBUFER,R13              :VOID INPUT BUFFER

CEAT1   JALR    R5,R11                  :GET ANOTHER INPUT CHAR
        L       R2,CYBTIM,R13           :YELLOW BALL OUT?
        JEBS    CEAT1                   :NOPE,EAT INPUT:NOPE, EAT INPUT
        CL      R2,SLOWC,,              :YEP,IS TIMEOUT UP?
        JGBS    CEAT1                   :NOPE, EAT INPUT
        LIS     R2,0
        ST      R2,CYBTIM,R13           :RESET YELLOW BALL OUT

:       GET AND PROCESS A COMMAND, STARTING WITH CHAR IN R5

CGETW   HS      0
        NOP
        LCS     R6,9
        LA      R7,UBUFER+9,R13
        LA      R9,SRCH                 :WHERE TO GO WHEN DONE
        J       CSTART

: PRINT PROMPT AND GET COMMAND

CPRMPT  LA      R3,PROMPT               :PRINT COMMAND PROMPT
        TS      UBUFER,R13              :SET USER BUFFER TO NOT USABLE
        LR      R2,R10                  :ENTER HERE TO OUTPUT MSG IN R3
        JAL     R5,OCS
        JAL     R9,CGETOK

:       SEARCH THE COMMAND LIST FOR THE COMMAND

SRCH    HS      0                       :SEARCH FOR COMMAND
        CHI     R6,-9                   :TEST FOR NO LETTERS STORED YET
        JE      CPRMPT                  :YES, JUST A DELIMETER, PROMPT
        LA      R6,CFAN
        LA      R9,CEND
        LI      R14,CMDLEN
        LA      R7,UBUFER,R13
        JAL     R3,FIND
        JFS     CBTCH2                  :COMMAND NOT KNOWN
        L       R5,CMDTLN,R6
        JR      R5

:       ILLEGAL COMMAND - BITCH

CBTCH1  LA      R3,BMSG1
        J       CBITCH
CBTCH2  LA      R3,BMSG2
        J       CBITCH
CBTCH3  LA      R3,BMSG3
        J       CBITCH
CBTCH4  LA      R3,BMSG4
        J       CBITCH
CBTCH5  LA      R3,BMSG5
        J       CBITCH
CBTCH7  LA      R3,BMSG7
        jfs     cbitch
cbtch8  la      r3,bmsg8
        jfs     cbitch
cbtch9  la      r3,bmsg9
CBITCH  LR      R2,R10                  :GET PORT NUMBER
        JAL     R5,OCS                  :SEND BITCH MSG

        LIS     R0,3                    :TAG YELLOW BALL TO OUTPUT
        LR      R1,R10                  :SO TYPE AHEAD CAN BE DISCARDED
        LHI     R2,YBMSG                :TILL ORANGE BALL IS BOUNCED
        JAL     R4,SLOR
        JAL     R4,ELOR
        L       R2,SLOWC,,              :SET YELLOW BALL OUT TIMER
        AIS     R2,0A                   :10 SECONDS
        ST      R2,CYBTIM,R13
        J       CEAT                    :EAT TILL ORANGE OR TIMEOUT

: COMMAND PROCESS FAN OUT TABLE

        BND     4
Q       EQ      .               :REQUIRED BY CMD.DEF MACRO!
CFAN    HS      0
        NOLIST
        CMD.DEF(ALLWHO,CALWHO)
        CMD.DEF(C,CBTCH2)
        CMD.DEF(CHARACTER,CCHAR)
        CMD.DEF(CONNECT,CCNKT)
        CMD.DEF(E,CBTCH2)
        CMD.DEF(EXIT,CEXI)
        CMD.DEF(FREEZE,CFRZ)
        CMD.DEF(GREETING,CGREET)
        CMD.DEF(HELP,CHELP)
        CMD.DEF(HEAR,CHEAR)
        CMD.DEF(LIST,CLISPT)
        CMD.DEF(LABEL,CLAB)
        CMD.DEF(MAKE,CNORM)
        CMD.DEF(MESSAGE,CMSG)
        cmd.def(NOBUSY,CNOBSY)
        CMD.DEF(NOHEAR,CNOHEA)
        CMD.DEF(NOLABEL,CNOL)
        CMD.DEF(OFF,COFF)
        CMD.DEF(ON,CON)
        CMD.DEF(Q,CBTCH2)
        CMD.DEF(QUIT,CQUI)
        CMD.DEF(SEND,CSEND)
        CMD.DEF(SET,CSET)
        CMD.DEF(TIME,CTIM)
        CMD.DEF(TALK,CTALK)
        CMD.DEF(THAW,CTHAW)
        CMD.DEF(TRANSFER,CTRANS)
        CMD.DEF(VERSION,CVERS)
        CMD.DEF(WHO,CWHO)
        CMD.DEF(ZAP,CZAP)
        LIST
CEND    HS      0
CSIZE   EQ      CFAN-CEND

: TALK COMMAND - TALK TO ANOTHER USER

ctlks   j       cbtch3                  :for short jump

CTALK   JAL     R9,CGETOK               :GET A TOKEN
        LA      R7,UBUFER,R13
        LA      R6,USER0
        LA      R9,LSTBLK,,
        LHI     R14,ENDBLK
        JAL     R3,FIND                 :skip return if found

        jbs     ctlks                   :user not available
        lb      r3,statu,r13            :see if overide status
        clhi    r3,1                    :\
        je      ctkgo                   :overide
        lhi     r3,tknvr                :see if user ever wants to talk
        nh      r3,talkfg,r6            :\
        jn      cbtch8                  :nope, say user refuses to talk
        lhi     r3,tknb                 :talk if not busy?
        nh      r3,talkfg,r6
        je      ctkgo                   :it's ok to talk if busy, go
        lhi     r3,fsend                :have to check if he is busy
        nh      r3,uflag,r6             :\
        jn      cbtch9                  :he is busy, say so

ctkgo   LHL     R6,BOSSP,R6             :NAME IS VALID, AND DEST DOESN'T CARE
        JE      cbtch3                  :DESTINATION NOT HOME
                                        :r6 is other users boss port
: NOW SEND INCOMMING TALK MESSAGE
: first, move username of originator to 'Incoming TALK from' message

        lis     r9,0                    :initialize counter
mvname  lb      r0,name,r9,r13          :get char of name
        je      mvnm1                   :done with name
        stb     r0,talkndx,r9           :store it in message
        ais     r9,1                    :increment counter
        jbs     mvname                  :continue
mvnm1   chi     r9,talkcnt              :see if need to fill
        je      sndname                 :go send it if done
        lhi     r0,$020                 :fill to end with spaces
        stb     r0,talkndx,r9           :stuff it
        ais     r9,1                    :increment count
        jbs     mvnm1                   :continue
sndname la      r3,talkfrm              :point to message
        lr      r2,r6                   :port to send it to
        jal     r5,ocs                  :send message

CTALK0  JALR    R5,R11                  :GET A CHARACTER
        NOP
        JAL     R5,CECHOC
        STH     R10,TEMP3               :SAVE THE BOSS PORT
        LR      R10,R6                  :STUFF THE DESTTINATION PORT
        LR      R0,R8                   :GET THE CHARACTER AGAIN
        JAL     R5,CCHO1                :JUST LET CECHOC SEND IT
        LH      R10,TEMP3               :RECOVER R10
        J       CTALK0                  :USER EXITS WITHC (ESC)Z

: SEND COMMAND - CONNECT BOSS TO A PORT

CSEND   LH      R6,NFLAG,R13
        JL      CSENDF
        JAL     R1,CPORT                :GET THE PORT NUMBER
        J       CBTCH1
        LR      R6,R3
        JL      CBTCH1                  :BAD
        CHI     R6,NPORT                :TEST FOR LAST PORT
        JGE     CBTCH1                  :BAD, TOO BIG
        CLH     R13,BTBLE,R6,R6         :DOES HE OWN IT
        JN      CBTCH1
        STH     R6,SPORT,R13            :STORE IT
CSENDF  LH      R6,SPORT,R13            :GET THE CURRENT SEND PORT
        JE      CBTCH1                  :BITCH IF NONE
        LIS     R7,0
        J       CSENDN

:       GET A CHAR & CHECK FOR IMMEDIATE COMMAND

CSEND1  JALR    R5,R11                  :GET THE NEXT CHARACTER
CSEND2  J       CSEND6
        LR      R3,R0                   :GET CHARACTER BACK
        NHI     R3,7F                   :STRIP PARITY
        CLB     R3,ATCHAR,R13           :CHECK IF ITS USERS SPECIAL
        JE      CSEND6                  :IF SO JUST SEND IT ALONG
        NHI     R3,5F                   :SET CHARACTER TO UPPER CASE ONLY
        CLHI    R3,AT.LC                :TEST FOR GIVE CRQ A NAME
        JE      CSEND8                  :GO AHEAD IF SO
        CLHI    R3,AT.NM                :TEST FOR SEND USERNAME
        JE      CSENDC                  :YES
        CLHI    R3,AT.NC                :TEST FOR SWITCH CIRCUIT
        JEFS    CSENDK                  :YES
        CLHI    R3,AT.FL                :IS IT SWITCH AND FLUSH?
        JNFS    CSENDM                  :SKIP IF NOT
CSENDH  SBT     R6,DUMP                 :ELSE SET FLUSH
        JFS     CSENDK                  :AND SKIP
CSENDM  CLHI    R3,AT.BP                :IS IT  SWITCH AND BACKPRESSURE
        JN      CSEND1
CSENDB  RBT     R6,FRISIS               :ELSE SET BACKPRESSURE ON OLD
        RBT     R6,STOPPD               :AND NOTE THE REQUEST(FOR OUR USE)

:       MOVE TO NEXT CIRCUIT

CSENDK  LHL     R0,UFLAG,R13            :TURN OFF SEND FLAG
        NHI     R0,@FSEND&@FLOG
        STH     R0,UFLAG,R13
        JAL     R9,NXTCRQ               :GET NEXT CIRCUIT
        CLH     R3,BOSSP,R13            :SEE IF BOSS
        JNFS    CSENDL                  :BR IF NOT
        LR      R6,R3
        JAL     R9,NXTCRQ               :TRY AGAIN
        CLH     R3,BOSSP,R13            :SEE IF BOSS THIS TIME
        JE      CPRMPT                  :CMD MODE IF ONLY BOSS
CSENDL  STH     R3,SPORT,R13            :SAVE NEW PORT
        STH     R3,XPORT,R13            :RECORD THIS PORT AS LAST PRINTED!
        JAL     R9,CRQPRI               :PRINT CIRCUIT NAME
CSENDN  RBT     R6,DUMP                 :RESET FLUSH ARRAY
        SBT     R6,FRISIS
        SBT     R6,STOPPD               :AND RESET OUR RECORD
        CLH     R6,LPORT,R13            :SEE IF IN LOGIN MODE
        JE      CNORMA                  :GO TO LOGIN PROCESSOR IF SO

        LHI     R0,FSEND                :MUST SET HIS SEND FLAG
        OH      R0,UFLAG,R13            :SET IT
        STH     R0,UFLAG,R13            :RETURN IT
        LIS     R9,0
CSENDQ  LR      R1,R10                  :GET BOSS'S CUR TERM PARAM
        JAL     R8,QTPAR
        LR      R2,R5
        LR      R1,R6                   :GET NEW PORT'S TERM PARAM
        JAL     R8,QTPAR
        CR      R5,R2                   :SEE IF THEY ARE THE SAME
        JEFS    CSENDS                  :BR IF SO
        JAL     R8,SBPAR                :SEND PORT'S TERM PARAM TO BOSS
CSENDS  AIS     R9,1                    :BUMP TO NEXT TERM PARAM
        CLHI    R9,NTRMCH
        JL      CSENDQ                  :BR UNLESS DONE

        LR      R7,R7                   :HAVE WE LOADED ANY CHARACTERS
        JN      CSEND7                  :DONE WITH TRANSMISSION
        J       CSEND1                  :END THIS TRANSMISSION

:       HANDLE DEFERRED ECHO MODE

CSEND6  STB     R0,CHRSAV               :SAVE CHAR SO THAT 'PARITY' IS RIGHT
        NHI     R0,7F
        LR      R8,R0
        TBT     R10,DEM                 :HAS IT BEEN ECHOED ALREADY?
        JE      CECHOX                  :SKIP IF SO
        TBT     R6,ECHO
        JE      QAED0
        LIS     R0,7                    :WILL SEND ISIS AT LEAST 7 CHAR MESSAGE
        LR      R1,R10                  :GET THE BOSSP
        JAL     R4,SLOR
        LR      R0,R8
        TBT     R0,PABLE
        JNFS    CECHO1                  :SKIP IF NOT EASILY  PRINTABLE
        JAL     R4,PUTCH                :OUTPUT THE CHAR
        J       QAEND                   :CLEAN UP

CECHO1  LHI     R3,-0D,R8               :UNECHOABLE CHAR
        JNFS    CECHO2                  :NOT A CR
        JAL     R4,PUTCH                :OUTPUT THE CHAR
        TBT     R6,ECRLF
        JE      QAEND                   :G CLEAN UP
        LIS     R0,0A
        JAL     R4,PUTCH                :OUTPUT A LINEFEED TO
        J       QAEND

CECHO2  AIS     R3,0D-0A                :IS IT A LINE FEED?
        JN      CECHO3                  :NOT A LF
        JAL     R4,PUTCH                :OUTPUT THA CHAR
        TBT     R6,ELFCR
        JE      QAEND                   :CLEAN UP IF NOT ECHO CR TOO
        LIS     R0,0D
        JAL     R4,PUTCH                :ECHO CR ALSO
        LHI     R0,7F                   :RUBOUT
        JAL     R4,PUTCH
        J       QAEND

CECHO3  AIS     R3,0A-9
        JNFS    CECHO4                  :NOT A TAB
        TBT     R6,ECTLI
        JE      QAED                    :DON'T ECHO TABS
        JAL     R4,PUTCH                :ECHO IT
        JFS     QAEND                   :CLEAN UP

CECHO4  SIS     R3,9-8
        JNFS    QAED                    :UNPRINTABLE CHR, ENTER DEFERRED ECHO
        TBT     R6,ECTLH
        JEFS    QAED                    :DON'T ECHO CONTROL-H
        JAL     R4,PUTCH                :ECHO IT

QAEND   LR      R3,R1                   :SAVE PORT NUMBER
        JAL     R4,ELODR                :END WHATEVER WAS SENT
        LR      R1,R3                   :RESTORE PORT NUMBER
        LR      R0,R8                   :RESTORE FOR FURTHER PROCESS
        J       CECHOX

QAED    JAL     R5,CSNDIT               :SEND BUFFERED CHARS
        LIS     R0,3                    :THREE CHARACTER MSG
        LR      R1,R6                   :GET THE DESTINATION PORT
        LHI     R2,EDMMSG
        JAL     R4,SLOR
        JAL     R4,ELOR
        SBT     R6,DEM
        RBT     R6,ECHO

QAED0   RBT     R6,EXPECT               :WERE NOT ECHOING
        JEFS    CECHOX
        RBT     R6,TBOA
        RBT     R6,TBOB
        LIS     R0,3
        LR      R1,R6                   :GET PORT # BACK
        LHI     R2,RBMSG
        JAL     R4,SLOR
        JAL     R4,ELOR

:       SAVE CHAR IN BUFFER & OUTPUT

CECHOX  CHI     R7,UBUFSZ-2             :BUFFER FULL ?
        JLEFS   CSENDR                  :NO, CONTINUE WITH BUFFER STUFFING
        JAL     R5,CSNDIT               :YES, SEND BUFFER
CSENDR  AIS     R7,1                    :INCREMENT POINTER
        LB      R8,CHRSAV               :RESTORE CHAR W/PARITY
        STB     R8,UBUFER,R7,R13        :PUT THE CHARACTER IN  STRING FORMAT
CSENDX  CHI     R12,1                   :HAS THIS ISIS MESSAGE ENDED
        JN      CSEND1                  :GET MORE CHARACTERS
CSEND7  JAL     R5,CSNDIT               :SEND BUFFER TO ISIS
        J       CSEND1

:       FILL CIRCUIT NAME

CSEND8  LIS     R9,0                    :MAKE A POINTER
        SLLS    R6,NLENS                :MAKE A DOUBLE WORD INDEX
CSEND9  JALR    R5,R11
        NOP
        JAL     R5,CECHOC               :
        TBT     R8,DLMARY               :IS THIS A DELIMITER
        JNFS    CSENDA
        CLHI    R8,0D                   :AND RECALL THAT CR IS A DELIMITER, TOO
        JEFS    CSENDA  
        OHI     R8,80                   :SET PARITY ON
        STB     R8,NTBLE+1,R9,R6        :STORE IT
        AIS     R9,1
        CLHI    R9,NLEN-1               :IS THIS THE CHARACTER LIMIT?
        JN      CSEND9                  :NO DO ANOTHER
CSENDA  HS      0
        LR      R9,R9                   :TEST FOR NULL ENTRY
        JNFS    CSENDG                  :SKIP THIS IF NOT.
        STB     R9,NTBLE+1,R6           :STORE 0 (NULL) IN NAME
        LIS     R9,1                    :GET COUNT (1-NULL) FOR NAME
CSENDG  HS      0
        STB     R9,NTBLE,R6             :SAVE SIZE 
        SRLS    R6,NLENS                :RESTORE R6
        J       CSEND1                  :AND FINISHED

:       SEND USERNAME ALONG CIRCUIT

CSENDC  LIS     R9,0                    :GET AN INDEX
CSENDD  LB      R0,NAME,R9,R13          :GET ANOTHER LETTER OF NAME
        JE      CSENDE                  :ALL DONE
        LR      R8,R0
        TBT     R6,ECHO                 :IS HOST ECHOING?
        JEFS    CSENDZ                  :YES, WE NEEDN'T
        JAL     R5,CCHO1                :ELSE DO IT
CSENDZ  CHI     R7,UBUFSZ-2             :BFR FULL?
        JLEFS   CSENDY
        JAL     R5,CSNDIT               :YES, SEND IT
CSENDY  AIS     R7,1
        STB     R8,UBUFER,R7,R13        :STORE IT
        AIS     R9,1                    :BUMP THIS
        J       CSENDD

CSENDE  LHI     R0,0BA                  :GET A COLON
        LR      R8,R0
        TBT     R6,ECHO                 :WILL HOST ECHO?
        JEFS    CSENDU                  :YES
        JAL     R5,CCHO1                :ELSE DO IT HERE
CSENDU  CHI     R7,UBUFSZ-2             :BFR FULL?
        JLEFS   CSENDV
        JAL     R5,CSNDIT               :YES, SEND IT
CSENDV  AIS     R7,1                    :SAVE POINTER
        STB     R8,UBUFER,R7,R13        :SAVE CHAR
        J       CSENDX                  :EXIT

:       CSNDIT - SEND USER BUFFER TO ISIS & RESET COUNTER

CSNDIT  STB     R7,UBUFER,R13           :STORE NUMBER OF CHARS (OCS FORMAT)
        LR      R7,R7                   :SEE IF ANYTHING TO SEND
        JER     R5                      :RETURN IF NOT
        LR      R2,R6                   :GET CURRENT SEND PORT
        CLH     R13,BTBLE,R6,R6         :DOES THIS BOSS OWN THE PORT
        JN      CBTCH1                  :NO
        LH      R7,PTBLE,R6,R6          :IS THE PORT ACTIVE
        JE      CBTCH1                  :PROCESS
        LIS     R7,0                    :RESET CNTR
        LA      R3,UBUFER,R13
        J       OCS                     :GO SEND THE CURRENT DATA

PABLE   WC      -1,0,0,3                :0 - 37,176 - 177 ARE UNPRINTABLE

: SET COMMAND - SET TERMINAL PARAMETER OF BOSS
:       SYNTAX:  SET 06 08<CR>  (SET'S OUTPUT BAUD RATE TO 300BAUD, 10CPS)

CSET    HS      0
        JAL     R9,CNUM                 :PUT # IN CVALUE AND REG 6
        STH     R6,SETN,R13             :SAVE "N" FOR SET COMMAND
        JAL     R9,CNUM                 :PUT 2ND # IN CVALUE AND R6
        LHL     R9,SETN,R13             :GET PARAMETER TO BE SET
        ST      R5,TEMP
        CLHI    R9,NTRMCH               :MAKE SURE PARAM NUM OKAY
        JGE     CBTCH5                  :BITCH IF NOT
        RBT     R9,ITCFLG,R13           :INDIC INITIAL VALUE SET
        STB     R6,ITCVAL,R13,R9        :SET INITIAL VALUE
        LR      R5,R6                   :GET PARAMETER VALUE
        JAL     R8,SBPAR                :SEND TO BOSS
        L       R5,TEMP
        J       CPRMPT                  :EXIT TO PROMPT

: LABEL COMMAND - TURN ON CIRCUIT LABELING

CLAB    HS      0
        LHI     R0,FLAB                 :GET LABEL FLAG
        OH      R0,UFLAG,R13            :OR IN THE USER'S FLAG
        STH     R0,UFLAG,R13            :SAVE USER'S FLAFS BACK
        J       CPRMPT

: NOLABEL COMMAND- TURN OFF LABELING OPTION

CNOL    HS      0
        LHI     R0,@FLAB                :GET COMPLIMENT OF LABEL FLAG
        NH      R0,UFLAG,R13            :AND IN USER'S FLAGS
        STH     R0,UFLAG,R13            :SAVE NEW FLAGS
        J       CPRMPT

: FREEZE COMMAND - FREEZE THE BOSS PORT

CFRZ    LHL     R0,UFLAG,R13            :GET THIS FLAG WORD
        OHI     R0,FFRZ                 :SET THE FREEZE BIT
        STH     R0,UFLAG,R13            :RETURN IT
        J       CPRMPT                  :LOOK FOR MORE INPUT

: THAW COMMAND - FREE BOSS ENTRY

CTHAW   HS      0
        LHL     R0,UFLAG,R13            :GET USERS FLAG
        NHI     R0,@FFRZ                :CLEAR FREEZE BIT
        STH     R0,UFLAG,R13            :PUT IT BACK
        J       CPRMPT                  :LOOK FOR MORE INPUT

: MESSAGE COMMAND - REQUEST GREETING MESSAGE BE PRINTED

CMSG    HS      0
        LB      R0,GRETMG,,             :SEE IF ANY GREET MSG
        JE      CPRMPT                  :BR IF NOT
        LR      R2,R10                  :GET PORT #
        LA      R3,GRETMG,,             :GET ADDR OF MESSAGE
        JAL     R5,OCS                  :PRINT IT TO BOSS
        J       CPRMPT

: HELP COMMAND - PRINT HELP MESSAGE

CHELP   LA      R6,MSGH                 :ADDRESS OF HELP MSGS
CHEL2   LR      R3,R6
        LB      R0,0,R6                 :SEE IF DONE
        JE      CPRMPT                  :BR IF SO
        AR      R6,R0                   :BUMP TO NEXT MSG
        AIS     R6,1
        LR      R2,R10                  :GET THE BOSS PORT
        JAL     R5,OCS                  :SEND MSG
        JBS     CHEL2                   :LOOK FOR MORE MSGS

: VERSION COMMAND - PRINT VERSION/HOST MESSAGE

CVERS   LA      R3,MSGVER               :ADDR. OF VERSION MSG.
        LR      R2,R10                  :GET THE BOSS PORT
        JAL     R5,OCS                  :SEND DATA
        J       CPRMPT                  :LOOK FOR MORE INPUT

: MAKE COMMAND - MAKE A NEW CIRCUIT
:       ONLY ONE LOGIN ALLOWED AT A TIME

CNORM   LHL     R1,LPORT,R13            :CHECK IF ONE IN PROGRESS
        JEFS    CNORM0                  :NO, CONTINUE
        JAL     R6,ZAP                  :ZAP OLD ONE
CNORM0  LHI     R0,FLOG                 :SET LOGGING FLAG
        OH      R0,UFLAG,R13            :SET IT
        STH     R0,UFLAG,R13            :REPLACE IT
        LR      R2,R10                  :GET THE PORT NUMBER
        LA      R3,ECHOF
        JAL     R5,OCM                  :TURN ECHO OFF
        RBT     R10,ECHO
        LR      R2,R10
        LA      R3,PLIMSG
        JAL     R5,OCS                  :SET PLI MESSAGE
        JAL     R6,REQCKT               :ISSUE PSEUDONDL REQUEST
        LIS     R6,0                    :INIT LOGBFR INDEX
        LH      R7,UFLAG,R13            :INIT ECHO STATE TO ON
        OHI     R7,FPASEC               : /
        STH     R7,UFLAG,R13            :/
        J       CNORM3
CNORM6  HS      0
        ST      R9,SVNRM1               :SAVE R9 (USE AS INDEX)
        LIS     R9,0
        LH      R7,UFLAG,R13            :IN ECHO STATE ?
        NHI     R7,FPASEC               :/
CNORM1  HS      0
        LB      R0,NAME,R9,R13          :GET USER'S NAME
        JE      CNORM5                  :GOT ALL CHARACTERS IF ZERO
        LR      R8,R0
        LR      R7,R7                   :ECHO STATE?
        JEFS    CNORMX                  :NO, SKIP ECHO
        JAL     R5,CCHO1                :ECHO THIS
CNORMX  STB     R8,UBUFER,R6,R13        :STORE IT FOR THE LOGGER
        AIS     R6,1
        CLHI    R6,LGINSZ               :LOGIN STR LEN EXCEEDED?
        JGE     CBTCH4                  :YES, BITCH
        AIS     R9,1                    :NEXT NAME LETTER
        CLHI    R9,8                    :ONLY EIGHT CHARACTERS ALLOWED
        JN      CNORM1
        L       R9,SVNRM1               :RESTORE R9
CNORM5  HS      0                       :ADD COLON TO USER NAME
        LHI     R0,3A                   :GET A COLON
        LR      R8,R0
        LR      R7,R7                   :ECHO STATE?
        JEFS    CNORMB                  :BR IF NOT
        JAL     R5,CCHO1                :ECHO IT TO TERMINAL
CNORMB  STB     R8,UBUFER,R6,R13        :SAVE IT AWAY
        AIS     R6,1                    :BUMP POINTER
CNORM3  STH     R6,LGINFL,R13           :STORE FILL INDEX FOR LOGGER
CNORM7  JALR    R5,R11                  :GET NEXT CHARACTER
        J       CNORM4
        LIS     R7,0                    :(IN CASE WE GO TO CSEND)
        LHL     R6,LPORT,R13            :CURRENT PORT NMBR
        CLHI    R3,AT.NC                :NEXT CIRCUIT CMD?
        JE      CSENDK
        CLHI    R3,AT.FL                :FLUSH & NEXT CMD?
        JE      CSENDH
        CLHI    R3,AT.BP                :BKPR & NEXT CMD?
        JE      CSENDB
        LHL     R6,LGINFL,R13           :NEW FILL POINTER
        CLHI    R3,AT.NM                :IS IT THE USERNAME COMMAND?
        JE      CNORM6                  :GO LOG HIS USERNAME
        CLB     R3,ATCHAR,R13           :EQUAL HIS ESCAPE CHAR ?
        JN      CNORM3                  :NO, IGNORE

CNORM4  LHL     R6,LGINFL,R13           :GET NEW FILL POINTER
        LR      R8,R0                   :R8 IS WORKING REGISTER
        NHI     R8,7F                   :REMOVE HIGHER BIT
        STB     R8,UBUFER,R6,R13        :STORE CHARACTER IN BUFFER
        AIS     R6,1                    :INC INDEX
        CLHI    R6,LGINSZ               :LOGIN STRING LENGTH EXCEEDED?
        JGE     CBTCH4                  :YES
        LH      R7,UFLAG,R13            :IN ECHO STATE ?
        NHI     R7,FPASEC               :/
        JEFS    CNORM8                  :NO, SKIP ECHO
        JAL     R5,CECHOC               :YES, ECHO IT
CNORM8  CLHI    R8,3B                   :SEMI?
        JEFS    CNORM9                  :YES
        CLHI    R8,0D                   :CARRET?
        JN      CNORM3                  :NO
CNORM9  LH      R7,UFLAG,R13            :YES, GET FLAGS
        NHI     R7,@FPASEC              :REMOVE ECHO BIT FOR PASSWORD
        STH     R7,UFLAG,R13            :SAVE FLAGS BACK
        J       CNORM3                  :DO ANOTHER

CNORMA  LHI     R0,FLOG                 :ENTRY FROM CSEND
        OHI     R0,UFLAG,R13
        STH     R0,UFLAG,R13            :SET LOGIN FLAG
        LR      R2,R10
        LA      R3,ECHOF                :TURN ECHO OFF
        JAL     R5,OCM
        RBT     R10,ECHO
        J       CNORM7

: LIST COMMAND - PRINT LIST OF PORTS

CLISPT  LR      R6,R10                  :START WITH THE BOSS
CLIST0  JAL     R9,NXTCRQ               :GET NEXT CRQ
        JAL     R9,CRQPRI               :PRINT LABEL(S)
        CR      R8,R10
        JEFS    CLIST1                  :NO OTHER THAN THE BOSS
        LR      R6,R8                   :CHECK AGAIN
        JBS     CLIST0
CLIST1  J       CPRMPT                  :LOOK FOR MORE INPUT

: QUIT COMMAND - ZAP ALL PORTS AND EXIT

CQUI    LIS     R1,0                    :NO MORE CURR SEND PORT
        STH     R1,SPORT,R13
CQUI0   LHL     R1,FPORT,R13            :GET NEXT PORT FOR THIS BOSS
        JE      INPUT                   :BR IF NONE
        JAL     R6,ZAPN                 :ZAP A PORT (NO PRINTING)
        JBS     CQUI0                   :GO GET MORE

: CONNECT COMMAND - CONNECT OUTPUT OF 1ST PORT TO INPUT OF 2ND

CCNKT   HS      0
        JAL     R1,CPORT
        J       CBTCH1
        CLH     R13,BTBLE,R3,R3         :DOES THE USER OWN IT
        JN      CBTCH1
        ST      R3,CNKTMP               :SAVE PORT #
        LH      R14,NFLAG,R13
        JGEFS   CCNKT0
        LR      R3,R10
        JFS     CCNKT1
CCNKT0  JAL     R1,CPORT
        J       CBTCH1
        CLH     R13,BTBLE,R3,R3
        JN      CBTCH1
CCNKT1  HS      0
        L       R2,CNKTMP               :RESTORE PORT #
        STH     R3,PTBLE,R2,R2          :SET DESTINATION
        J       CPRMPT                  :LOOK FOR MORE INPUT

: OFF & ON COMMANDS - FLUSH AND UN-FLUSH DATA FROM PORT
:       BOTH USE THE SAME CODE, BUT SET A FLAG FOR ON OR OFF

COFF    TS      UBUFER+2,R13
        JFS     CFLSH
CON     ST      R10,UBUFER+2,R13
CFLSH   JAL     R1,CPORT
        J       CBTCH1
        LH      R14,BTBLE,R3,R3
        JE      CFLSH0
        NHI     R14,7FFF                :MAKING SURE THIS USER OWNS THE PORT
        CR      R13,R14                 :THE SAME?
        JN      CFLSH0                  :NO TRY AGAIN
        SBT     R3,DUMP                 :FIRST SET IT
        LH      R7,UBUFER+2,R13         :CHECK THIS FLAG
        JLFS    CFLSH0                  :SET CORRECTLY
        RBT     R3,DUMP
CFLSH0  LH      R14,NFLAG,R13           :THIS IS THE "LAST NUMBER FLAG"
        JGE     CFLSH
        J       CPRMPT                  :LOOK FOR MORE INPUT

: EXIT COMMAND - EXIT BUT LEAVE PORTS INTACT

CEXI    LHL     R1,BOSSP,R13            :GET BOSS PORT
        JAL     R6,ZAP
        J       INPUT

: ZAP COMMAND - ZAP A PORT

CZAP    STH     R10,UBUFER,R13          :SET A FLAG
        LH      R6,NFLAG,R13            :SEE IF ANY PORT SPECIFIED
        JGEFS   CZAP0                   :BR IF SO
        LHL     R3,SPORT,R13            :GET CURRENT PORT
        JE      CBTCH1                  :BR IF NONE
        JFS     CZAP1
CZAP0   JAL     R1,CPORT                :GET THE FIRST PORT
        J       CBTCH1
CZAP1   LHL     R14,BTBLE,R3,R3         :GET THE USER FOR THE PORT
        JE      CZAP2                   :NOTHING TO DO
        NHI     R14,7FFF
        CR      R14,R13                 :DOES THIS USER OWN THE PORT
        JN      CZAP2                   :NO
        STH     R3,TEMP1                :SAVE THE PORT NUMBER
        LR      R1,R3                   :GET PORT NUMBER
        JAL     R6,ZAP                  :GO PROCESS THE ZAP
        LHL     R1,TEMP1
        LHL     R2,BOSSP,R13
        JE      INPUT                   :BOSS ZAPPED HIMSELF...CONTINUE
CZAP2   LH      R14,NFLAG,R13
        JGE     CZAP0
        J       CPRMPT                  :LOOK FOR MORE INPUT

: TIME COMMAND - PRINT DATE AND TIME

CTIM    LIS     R4,0D                   :DONT DO SECONDS
        STB     R4,UBUFER+1,R13         :NUMBER OF BYTES(OCS)
        L       R3,0F000C,,             :GET GMT
        LA      R5,UBUFER+2,R13         :WHERE TO PLACCE
        JAL     R6,DATIME               :GO DO IT
        LR      R2,R10                  :GET BOSS PORT
        LA      R3,UBUFER+1,R13         :AND STRING
        JAL     R5,OCS                  :OUT IT
        J       CPRMPT                  :QUIT

: TRANSFER COMMAND - SWITCH TO A NEW BOSS

CTRANS  HS      0
        JAL     R1,CPORT                :GET THE SPECIFIED PORT
        J       CBTCH1
        TBT     R3,TYMSAT               :MUST BE A TYMSAT
        JE      CBTCH7
        LHI     R4,7FFF                 :GET A MASK
        NH      R4,BTBLE,R3,R3          :GET THE OWNER
        CR      R13,R4                  :DOES THIS USER OWN IT
        JN      CBTCH1
        LR      R1,R3                   :PORT IN R1
        LR      R6,R13                  :SET UP ROUTINE NEEDS BOSS HERE
        LA      R4,INED22               :NEEDLE ROUTINE SETS THING UP
        LM      R14,CSAVE               :GET RING REGISTERS
        SIS     R12,1                   :PREPARE TO FLUSH HIS COMMAND INPUT
        JE      ELIR
        LR      R0,R12
        J       FLUSH

: ALLWHO & WHO COMMANDS - LIST ALL USERS

CALWHO  HS      0                       :PRINT ==ALL== VALID USERS
        TS      ALLWHO                  :SET TO -1
        JFS     CWHO7                   :PRINT LIST

CWHO    HS      0                       :PRINT ACTIVE USERS
        LIS     R6,0                    :SET TO ZERO
        STH     R6,ALLWHO               :/

CWHO7   HS      0                       :COMMON CODE (BOTH WHO'S)
        LIS     R6,0
        LA      R7,USER0
CWHO1   LB      R8,NAME,R7,R6
        JEFS    CWHO2
        STB     R8,UBUFER+1,R13,R6
        AIS     R6,1
        JBS     CWHO1
CWHO2   LHI     R8,0A0A0                :TWO BLANKS (INCASE IT'S INACTIVE)
        LHL     R5,BOSSP,R7
        JN      CWHO8                   :PORT ACTIVE
        LHL     R0,ALLWHO               :ALL OR ACTIVE
        JE      CWHO5                   : JUST ACTIVE (& THIS IS NOT)
        LHI     R8,0A0A0                :GET TWO BLANKS ("  ")
        JFS     CWHO4                   : PRINT IT

CWHO8   HS      0
        LHI     R8,0A0A1                :SEND " !" TO OUTPUT
        CR      R5,R10                  :IS IT REQUESTING BOSS?
        JN      CWHO4                   :NO, SKIP (OUTPUT THE " !")
        LHI     R8,0A02A                :GET A " *" INSTEAD
CWHO4   HS      0
        STB     R8,UBUFER+2,R13,R6
        EXBR    R8,R8                   :GET OTHER BYTE
        STB     R8,UBUFER+1,R13,R6      :STORE IT IN BUFFER
        AIS     R6,2                    :BUMP BUFFER POINTER
CWHO3   LIS     R8,0D
        STB     R8,UBUFER+1,R13,R6
        LIS     R8,0A
        STB     R8,UBUFER+2,R13,R6
        AIS     R6,2
        STB     R6,UBUFER,R13
        LR      R2,R10
        LA      R3,UBUFER,R13
        JAL     R5,OCS                  :PRINT A LINE
CWHO5   HS      0
        LIS     R6,0
        AHI     R7,ENDBLK
        CLHI    R7,LSTBLK
        JL      CWHO1                   :FIND THE NEXT USER
        J       CPRMPT                  :LOOK FOR MORE INPUT

: CHAR COMMAND - CHANGE/DISPLAY ATTENTION CHARACTER

CCHAR   HS      0
        LH      R0,NFLAG,R13            :GET THE DELIMITER
        JGE     CCHAR2                  :SKIP IF IT WASN'T A CR
        LB      R1,ATCHAR,R13
        LI      R4,10                   :USE HEX...
        LA      R14,UBUFER+2,R13          :USE THE BUFFER
        LIS     R15,2                   :TWO CHARACTERS
        STB     R15,UBUFER+1,R13
        JAL     R5,CBA                  :CONVERT TO ASCII
        LR      R2,R10
        LA      R3,UBUFER+1,R13
        JAL     R5,OCS                  :PRINT THE HEX CHAR
        J       CPRMPT

CCHAR2  JALR    R5,R11                  :GET A CHARACTER
        NHI     R0,7F                   :REMOVE THESE
        STB     R0,ATCHAR,R13           :STORE IT
        JAL     R5,CECHOC               :ECHO IT
        J       CPRMPT                  :LOOK FOR MORE INPUT

: HEAR COMMAND - ALLOW TALKING TO USER

CHEAR   HS      0
        LIS     R0,0            
        STH     R0,TALKFG,R13           :TURN OFF THE FLAG
        J       CPRMPT

: NOHEAR COMMAND - DON'T ALLOW TALKING TO THIS USER

CNOHEA  HS      0
        lis     r0,0
        sth     r0,talkfg,r13           :first, turn off flags
        lhl     r0,talkfg,r13
        ohi     r0,tknvr                :talk never allowed
        sth     r0,talkfg,r13
        J       CPRMPT

: NOBUSY COMMAND - DON'T ALLOW TALKING IF BUSY

CNOBSY  HS  0
        lis     r0,0
        sth     r0,talkfg,r13           :first, turn off flags
        lhl     r0,talkfg,r13
        ohi     r0,tknb                 :talk if not busy
        sth     r0,talkfg,r13
	J	CPRMPT

: GREETING COMMAND - SET GREETING MESSAGE

CGREET  HS      0                       :ENTER A GREETING INTO BUFFER
        LA      R7,GRETMG+1,,           :GET START ADDR TO STORE STRING IN
CGREE0  LA      R6,GRETME,,             :CALC REMAINING BFR LENGTH
        SR      R6,R7
        JLE     CGREE1                  :BR IF NO MORE
        JAL     R9,CSTRNG               :GET A LINE OF GREETING
        LR      R6,R6                   :SEE IF END OF GREETING
        JE      CGREE1                  :BR IF SO
        AR      R7,R6                   :BUMP TO END OF LINE
        LIS     R0,0A                   :ADD IN LF CHAR
        STB     R0,1,R7
        AIS     R7,2
        J       CGREE0                  :GO GET NEXT LINE

:       GOT GREETING MSG - SET FLAGS ON ALL USER'S BLOCKS

CGREE1  HS      0
        SI      R7,GRETMG+1             :CALC TOTAL CHAR COUNT
        STB     R7,GRETMG,,             :PUT IN BFR

        LA      R2,USER0+UFLAG          :GET STARTING ADDRESS
CGREE2  LHL     R7,0,R2                 :GET USER'S FLAGS
        OHI     R7,FMSGPR               :'OR' MESSAGE FLAG INTO USER FLAG
        STH     R7,0,R2                 :SAVE IT BACK
        AHI     R2,ENDBLK               :GET NEXT USER BLOCK
        CHI     R2,LSTBLK               :TEST FOR LAST USER
        JLBS    CGREE2                  :NOT YET
        J       CPRMPT                  :CONTINUE ON
        SUBTTL  UTILITY ROUTINES
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                U T I L I T Y   R O U T I N E S               ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: FIND - FINDS THE MATCH TO AN ASCII STRING FROM A SYMBOL SET
:       LINK,R3
:       R6,ADDRESS OF THE FIRST SYMBOL IN THE TABLE
:       R7,ADDRESS OF SYMBOL TO MATCH
:       R9,END OF TABLE 
:       R14,SIZE OF ONE TABLE ENTRY
:       RUINS R4,R5,R8

:       SKIP (+2) FOR FOUND, NORMAL RETURN FOR NOT FOUND


FIND    JAL     R4,MTCH
        JFS     FIND2
        J       2,R3
FIND2   AR      R6,R14
        CR      R6,R9
        JLBS    FIND                    :KEEP LOOKING
        JR      R3                      :RETURN

: MTCH - MATCH TWO STRINGS
:       RUINS R8
:       LINK R4
:       PATTERN ADDRESS,R6
:       MATCH TO STRING AT ADDRESS IN R7

MTCH    LCS     R5,1
MTCH1   AIS     R5,1
        CR      R5,R14                  :TEST FOR > ELEMENT SIZE
        JER     R4                      :EXIT, NOT FOUND
        LB      R8,0,R7,R5              :CHECK FOR THE END OF THE STRING
        JE      2,R4
        LB      R8,0,R6,R5              :GET LETTER FROM TABLE
        CHI     R8,0E1                  :UPPERCASE IT, IF NEED BE
        JLFS    MTCH2
        CHI     R8,0FA
        JGFS    MTCH2
        SHI     R8,20
MTCH2
        CLB     R8,0,R7,R5              :COMPARE TO INPUT STRING
        JE      MTCH1
        JR      R4                      :EXIT, NOT FOUND

: CBA - CONVERT BINARY TO ASCII.
:
:       ASCII NUMBER WILL BE OUTPUT IN REQUESTED RADIX RIGHT JUSTIFIED
:       WITH BLANK FILL IN A GIVEN FIELD IN MEMORY.
:
:       ENTRY   R1      BINARY #
:               R4      RADIX (2 TO 10 HEX)
:               R5      LINK
:               R14     ADDRESS TO DEPOSIT STRING
:               R15     SIZE OF FIELD IN CHARACTERS
:
:       DESTROYS R2,3, R11

CBA     LR      R3,R1                   :GET NUMBER TO SCRATCH REGISTER
CBA010  LIS     R2,0                    :CLEAR UPPER HALF
        DR      R2,R4                   :DIVIDE BY RADIX
        LB      R2,CBAASC,R2            :CONVERT TO ASCII
CBA020  STB     R2,-1,R14,R15           :SAVE CHARACTER
        SIS     R15,1                   :COUNT CHARACTER IN STRING
        JLER    R5                      :IF FIELD FULL
        LR      R3,R3                   :NUMBER FULLY PROCESSED?
        JGBS    CBA010                  :IF NOT
        LHI     R2,0A0                  :BLANK
        JBS     CBA020                  :GO BLANK FILL

CBAASC  AC      "0123456789ABCDEF"

: CBAL - CONVERT BINARY TO ASCII LEFT JUSTIFIED.
:
:   USES AND DISTROYS SAME REGISTERS AS CBA ABOVE

CBAL
        LHI     R3,0A0                  :FIRST WE'RE GOING TO BLANK FILL
        AR      R15,R14                 :GET THE END OF THE STRING
CBAL2   SIS     R15,1
        STB     R3,0,R15
        CR      R14,R15
        JNBS    CBAL2
        STB     R3,R15                  :NOW IT'S ALL BLANKS

        LIS     R15,0                   :NOW WE'LL COUNT THE DIGITS
        LR      R3,R1
CBAL3
        LIS     R2,0
        AIS     R15,1
        DR      R2,R4
        LR      R3,R3
        JNBS    CBAL3
        J       CBA

: OMSG - GENERAL TRANMISSION ROUTINE
:       OUTPUTS A MESSAGE WITH A NUMBER INSERTED IN THE BEGINNING
:
:
:       R5      RETURN REGISTER
:       R1      BINARY NUMBER
:       JUST LIKE OCS, BUT SENDS TO BOSS PORT
:       R13     CONTAINS THE BASE OF THE USER BLOCK WHICH RECEIVES THE MESSAGE
:

OMSG    LHL     R2,BOSSP,R13
        JER     R5
        J       OCS             :OCS WILL LINK ON R5

: ZAP - PROCESS CIRCUIT ZAP
:       R1 = PORT#
:       R6 = LINK

:       ZAP IS CALLED TO PROCESS A PORT ZAP 
:       ON INPUT R1 CONTAINS THE PORT TO ZAP, LINK ON R6
:       THERE ARE THREE CASES OF ZAPPING
:       1- THE PORT IS A NORMAL SLAVE
:       2- THE PORT IS IN PSEUDONEDL STATE
:       3- THE PORT IS A BOSS
:       4- THE PORT IS THE CURRENT SEND PORT

ZAP     HS      0
        LHI     R2,ZAPMSG
        LIS     R0,3
        JAL     R4,SLOR
        JAL     R4,ELOR                 :SEND A ZAPPER

:       CALL HERE TO DO ALL ZAPPING EXCEPT SENDING THE ZAPPER
ZAP1    ST      R1,ZAPSAV               :SAVE ZAP UPON THIS ENTRY
        LA      R3,ZAPPED               :NOTIFY THE BOSS
        JAL     R5,OMSG
        L       R1,ZAPSAV               :RECOVER PORT
        SLLS    R1,NLENS                :INDEX FOR PORT DESCR.
        LA      R3,NTBLE,R1             :OUTPUT STRING
        JAL     R5,OMSG                 :DO IT.
        L       R1,ZAPSAV               :RECOVER PORT
        JFS     ZAP1A

:       CALL HERE TO DO ALL ZAPPING EXCEPT TYPING MESSAGE
ZAPN    LHI     R2,ZAPMSG
        LIS     R0,3
        JAL     R4,SLOR                 :SEND ZAP MSG TO ISIS
        JAL     R4,ELOR
        ST      R1,ZAPSAV
:       TEST FOR PORTS WITH ZAPPED PORT AS DESTINATION.
:               ZERO OUT ANY THAT DID EXIST.
ZAP1A   LIS     R0,0                    :GET A NULL
        LHI     R2,MAXPRT*2             :GET LOC OF LAST PORT.
ZAP2    CLH     R1,PTBLE,R2             :ZAP PORT = DEST PORT ?
        JNFS    ZAP3                    :NOPE, TRY AGAIN
        STH     R0,PTBLE,R2             :ZERO PORT OUT
ZAP3    SIS     R2,2                    :GET NEXT PORT TO TRY
        JGEBS   ZAP2                    :CONTINUE IF MORE
:       REMOVE PORT FROM BOSS'S CHAIN
        STH     R0,PTBLE,R1,R1          :ZERO DESTINATION
        STH     R0,BTBLE,R1,R1          :ZERO BOSS INDEX

        LI      R2,FPORT-CTBLE,R13      :SEARCH THRU CHAIN FOR PORT
        SRLS    R2,1
ZAP8    CLH     R1,CTBLE,R2,R2
        JEFS    ZAP9                    :BR IF FOUND
        LHL     R2,CTBLE,R2,R2          :BUMP TO NEXT
        JNBS    ZAP8
        JAL     R10,CRASH               :NOT FOUND, SOMETHING IS AMISS
        BC      0,0,R1*4,CCBADZ
ZAP9    LHL     R3,CTBLE,R1,R1          :REMOVE FROM CHAIN
        STH     R3,CTBLE,R2,R2
        LIS     R3,0
        STH     R3,CTBLE,R1,R1

        SBT     R1,FRISIS
        RBT     R1,DUMP
        RBT     R1,APORT                :RESET ACTIVE PORT
        RBT     R1,PSNEDL               :RESET PSEUDO NEEDLE STATE BIT
        JE      ZAP5                    :SKIP AHEAD NOT IN LOGGIN
::      ZAPPER FOR PORT IN LOGIN MODE (SUP SENT IT)             ::
        L       R1,ZAPSAV               : RECOVER PORT
        LIS     R0,0
        STH     R0,LPORT,R13            :QUIT THE B3 PROCESS
        CH      R1,SPORT,R13            :SEE IF CURRENT PORT
        JNR     R6                      :DONE IF NOT
        LHL     R0,UFLAG,R13
        NHI     R0,FLOG                 :MOVE LOGIN FLAG TO SEND FLAG
        JEFS    ZAP4
        LHI     R0,FSEND
ZAP4    OH      R0,UFLAG,R13
        STH     R0,UFLAG,R13
        J       ZAP6A                   :GO TO COMMAND MODE
::      BOSS PORT
ZAP5    CH      R1,BOSSP,R13            :IS THIS THE BOSS?
        JN      ZAP6                    :BR IF NOT A BOSS
        STH     R0,BOSSP,R13            :INDICATE NO BOSS
        STH     R0,SPORT,R13            :RESET THE SEND PORT
        ST      R0,CYBTIM,R13           :RESET YELLOW BALL TIMER
        LA      R0,CEAT                 :SET CMD PROCESSOR TO EAT INPUT
        ST      R0,CMNDAD,R13
        JR      R6
::      CURRENT SEND PORT - GO TO COMMAND MODE
ZAP6    CH      R1,SPORT,R13            :SEE IF CURRENT PORT
        JNR     R6                      :DONE IF NOT
ZAP6A   LR      R7,R6                   :SAVE RTRN ADDR
        LHL     R6,SPORT,R13
        JAL     R9,NXTCRQ               :FIND NEXT PORT
        CH      R3,BOSSP,R13            :SEE IF BOSS
        JNFS    ZAP7
        LR      R6,R3
        JAL     R9,NXTCRQ               :GET NEXT AFTER BOSS
        CH      R3,BOSSP,R13            :SEE IF BOSS AGAIN
        JNFS    ZAP7
        LIS     R3,0                    :NO NEW CURRENT PORT IF SO
ZAP7    STH     R3,SPORT,R13            :SET NEW CURRENT PORT
        LHL     R0,UFLAG,R13            :SEE IF IN SEND MODE
        THI     R0,FSEND
        JER     R7                      :DONE IF NOT
        JAL     R6,CMODE                :SET UP FOR COMMAND MODE
        ST      R5,CMNDAD,R13
        JR      R7                      :RETURN

: SETDEM - PUT A PORT IN 'DEM', BUT IT IS ASSUMED TO
:       BE A TYMSAT, PROBABLY THE BOSS.
:       R10 = PORT NUMBER
:       DESTROYS R3,R2,R1,R4,R5
:       LINK R6

SETDEM  LR      R2,R10                  :GET PORT NUMBER
        JER     R6                      :SKIP IT IF ZERO
        LA      R3,SETMSG               :SETMSG IS TYPE B1
        LIS     R0,0                    :GOING TO SET ECHO PARAM
        STH     R0,TERPAR               :SETTING PARM=ECH0,VAL=0
        JAL     R5,OCM                  :SET IT OFF
        LA      R3,SETMSG
        LR      R2,R10                  :GET PORT AGAIN
        LIS     R0,1                    :VALUE = ON
        STB     R0,TERVAL               :PUT IT IN
        JAL     R5,OCM                  :SET IT ON
        JR      R6

: NXTCRQ - GET NEXT ACTIVE CIRCUIT ROUTINE.  DOES NOT PRINT.
:       ENTERED WITH:
:               R6 = LAST PORT TO CHECK
:               R9 = LINK REGISTER
:               R13= BOSS PORT REQUESTING (FOR SEARCHING)
:       RETURNS WITH:
:               R3 = NEXT PORT FOUND 

NXTCRQ  LHL     R3,CTBLE,R6,R6          :GET NEXT CIRCUIT FOR THIS BOSS
        JNR     R9                      :RETURN IF GOT IT
        LHL     R3,FPORT,R13            :WRAP TO FIRST IN CHAIN
        JR      R9                      :RETURN

: CRQPRI - PRINT 'CURRENT', OR GIVEN CIRCUIT NUMBER.
:       ON ENTRY:
:               R3 = CIRCUIT NUMBER TO PRINT NAME OF.  IF CRQ # + 8000X 
:                       THEN AN ASTERISK WILL ALSO BE PRINTED (IF R6=SPORT)
:                       THAT IS THE GIVEN PORT IS 'CURRENT'.
:               R9 = LINK REGISTER

CRQPRI  STH     R3,TEMP2                :SAVE IT (R6 IS DESTROYED)
        ST      R9,RLINK                :SAVE LINK REG.
        NHI     R3,7FFF                 :CLEAR H.O. BIT
        LR      R8,R3
        SLLS    R8,NLENS                :DOUBLE WD INDEX
        LA      R3,NTBLE,R8             :GET CIRCUIT LABEL STRING
        LR      R2,R10                  :GET THE BOSS PORT
        JAL     R5,OCS                  :SEND THE PORT NAME
        SRLS    R8,NLENS                :RESTORE
        LH      R6,TEMP2                :RESTORE PORT #
        LA      R3,STARMG               :ASSUME 'STAR(*)' MESSAGE.
        CLH     R6,SPORT,R13            :EQUAL CURRENT?
        JEFS    CRQPR3                  :YES, MSG IS 'OK'
CRQPR2  HS      0
        LA      R3,CRLFMG               :NOPE, GET DEFAULT MSG (CR/LF)
CRQPR3  HS      0
        LR      R2,R10                  :GET OUTPUT PORT
        JAL     R5,OCS                  :OUTPUT MESSAGE
        LHL     R3,TEMP2                :RESTORE ORIGINAL
        L       R9,RLINK                :GET RETURN
        JR      R9                      :RETURN

: QTPAR - QUERY A TERMINAL PARAMETER
:       R1 = PORT NMBR
:       R9 = PARAMETER NMBR
:       R8 = LINK REG
:       R5 = RETURNED VALUE (-1 IF ERROR)

QTPAR   CLHI    R9,QFANSZ/2             :SEE IF PARAM NMBR TOO BIG
        JGEFS   QTPER                   :BR IF SO
        LHL     R3,QSADDR,R9,R9         :GET PARAM ADDR PTR
        LHL     R5,QFAN,R9,R9           :GET ROUTINE ADDR
        J       SEG1,R5                 :GO DO IT
QTPER   LCS     R5,1                    :INDICATE ERROR
        JR      R8                      :RETURN
:       QUERY A BIT
QBIT    LIS     R5,0                    :EXPECT TO RETURN A ZERO
        TBT     R1,0,R3                 :IS THE BIT ON?
        JER     R8                      :YES
        LIS     R5,1                    :YES...RETURN A ONE
        JR      R8
:       QUERY LEFT PARAMETER
QFLEFT  LB      R5,0,R3,R1              :GET PARAMETER
        SRHLS   R5,4                    :AND JUSTIFY IT
        JR      R8
:       QUERY RIGHT PARAMETER
QFRITE  LB      R5,0,R3,R1              :GET IT
        NHI     R5,0F                   :AND MASK IT OFF
        JR      R8

QFAN    HC      QBIT-SEG1               :0 - ECHO CONTROL
        HC      QBIT-SEG1               :1 - ECHO CONTROL-I
        HC      QBIT-SEG1               :2 - ECHO LF W/CR
        HC      QBIT-SEG1               :3 - ECHO CR W/LF
        HC      QBIT-SEG1               :4 - CR DELAY
        HC      QFLEFT-SEG1             :5 - INPUT BAUD RATE
        HC      QFRITE-SEG1             :6 - OUTPUT BAUD RATE
        HC      QBIT-SEG1               :7 - PARITY
        HC      QBIT-SEG1               :8 - HALF DUPLEX
        HC      QFLEFT-SEG1             :9 - PARAMETER A
        HC      QFRITE-SEG1             :10 - PARAMETER B
        HC      QFLEFT-SEG1             :11 - PARAMETER C
        HC      QBIT-SEG1               :12 - X-ENABLE
        HC      QBIT-SEG1               :13 - ECHO CONTROL-H
        HC      QBIT-SEG1               :14 - REVERSE X-ENABLE
        HC      QFRITE-SEG1             :15 - PARAMETER D
        HC      QBIT-SEG1               :16 - KATAKANA
        HC      QBIT-SEG1               :17 - TERM OUT ON BRK
        HC      QBIT-SEG1               :18 - ECHO ESCAPE
        HC      QBIT-SEG1               :19 - 'Q' - MODE
QFANSZ  EQ      .-QFAN

:       POINTERS TO PARAMETER TABLES

QSADDR  HC      ECHO                    :0 - ECHO CONTROL
        HC      ECTLI                   :1 - ECHO CONTROL-I
        HC      ELFCR                   :2 - ECHO LF W/CR
        HC      ECRLF                   :3 - ECHO CR W/LF
        HC      CRDE                    :4 - CR DELAY
        HC      BRATE                   :5 - INPUT BAUD RATE
        HC      BRATE                   :6 - OUTPUT BAUD RATE
        HC      PARITY                  :7 - PARITY
        HC      HAFDUX                  :8 - HALF-DUPLEX
        HC      PAB                     :9 - PARAMETER A
        HC      PAB                     :10 - PARAMETER B
        HC      PCD                     :11 - PARAMETER C
        HC      XONENA                  :12 - X-ENABLE
        HC      ECTLH                   :13 - ECHO CONTROL-H
        HC      YONENA                  :14 - REVERSE X-ENABLE
        HC      PCD                     :15 - PARAMETER D
        HC      KATA                    :16 - KATAKANA
        HC      T.BRK                   :17 - TERM OUT ON BRK
        HC      EC.ESC                  :18 - ECHO ESCAPE
        HC      Q.MOD                   :19 - 'Q' MODE

: SBPAR - SEND TERMINAL PARAMETER TO BOSS PORT
:       R5 = NEW PARAMETER VALUE
:       R9 = PARAMETER NMBR (NOT ECHO)
:       R10 = BOSS PORT NMBR

SBPAR   LR      R1,R10                  :GET BOSS PORT NMBR
        JE      STPAR                   :BR IF NO BOSS
        CLHI    R9,5                    :DON'T SEND BAUD RATE CHANGES
        JER     R8
        CLHI    R9,6
        JER     R8
        LIS     R0,5
        LHI     R2,STPMSG               :SEND SET TERM MSG
        JAL     R4,SLOR
        LR      R0,R9
        JAL     R4,PUTCH                :SEND PARAM NMBR
        LR      R0,R5
        JAL     R4,PUTCH                :SEND PARAM VALUE
        JAL     R4,ELOR                 :END MSG & CONTINUE

: STPAR - SET A TERMINAL PARAMETER
:       R1 = PORT NMBR
:       R5 = PARAMETER VALUE
:       R9 = PARAMETER NMBR

STPAR   CLHI    R9,SFANSZ/2             :SEE IF TOO BIG
        JGE     STPER                   :BR IF SO
        LHL     R3,QSADDR,R9,R9         :GET PARAM ADDR
        LHL     R4,SFAN,R9,R9           :GET ROUTINE ADDR
        J       SEG1,R4                 :GO DO IT
:       ADJUST A BIT
SBIT    RBT     R1,0,R3                 :TURN IT OFF
        THI     R5,1
        JER     R8
        SBT     R1,0,R3                 :ELSE TURN IT BACK ON AGAIN
STPER   JR      R8
:       SET LEFT PARAMETER
SFLEFT  LB      R4,0,R3,R1              :REMOVE CURRENT VALUE
        NHI     R4,0F
        LR      R2,R5
        SLHLS   R2,4                    :JUSTIFY VALUE
        JFS     SFIELD                  :AND SKIP
:       SET RIGHT PARAMETER
SFRITE  LB      R4,0,R3,R1              :REMOVE CURRENT VALUE
        NHI     R4,0F0
        LR      R2,R5
SFIELD  OR      R4,R2                   :PLACE NEW VALUE
        STB     R4,0,R3,R1              :PUT NEW VALUE CK
        JR      R8

SFAN    HC      SBIT-SEG1               :0 - SET ECHO
        HC      SBIT-SEG1               :1 - ECHO CONTROL-I
        HC      SBIT-SEG1               :2 - ECHO LF W/CR
        HC      SBIT-SEG1               :3 - ECHO CR W/LF
        HC      SBIT-SEG1               :4 - CR DELAY
        HC      SFLEFT-SEG1             :5 - INPUT BAUD RATE
        HC      SFRITE-SEG1             :6 - OUTPUT BAUD RATE
        HC      SBIT-SEG1               :7 - PARITY
        HC      SBIT-SEG1               :8 - HALF DUPLEX
        HC      SFLEFT-SEG1             :9 - PARAMETER A
        HC      SFRITE-SEG1             :10 - PARAMETER B
        HC      SFLEFT-SEG1             :11 - PARAMETER C
        HC      SBIT-SEG1               :12 - X-ENABLE
        HC      SBIT-SEG1               :13 - ECHO CONTROL-H
        HC      SBIT-SEG1               :14 - REVERSE X-ENABLE
        HC      SFRITE-SEG1             :15 - PARAMETER D
        HC      SBIT-SEG1               :16 - KATAKANA
        HC      SBIT-SEG1               :17 - TERM OUTPUT ON BRK
        HC      SBIT-SEG1               :18 - ECHO ESCAPE
        HC      SBIT-SEG1               :19 - 'Q' - MODE
SFANSZ  EQ      .-SFAN

: CMODE - GO TO COMMAND MODE
:       R13 = USER BLOCK ADDR
:       R6 = LINK
:       R5 = RETURNED COMMAND LINK ADDR

CMODE   LHL     R1,BOSSP,R13            :GET BOSS PORT
        LIS     R9,0
CMOD1   TBT     R9,ITCFLG,R13           :SEE IF WE HAVE INITIAL TC VAL
        JNFS    CMOD2                   :NOPE
        JAL     R8,QTPAR                :GET BOSS'S CUR TERM PARAM
        CLB     R5,ITCVAL,R13,R9        :CMP TO INITIAL TERM PARAM
        JEFS    CMOD2                   :BR IF THE SAME
        LB      R5,ITCVAL,R13,R9        :SET TO INITAL VAL
        JAL     R8,SBPAR
CMOD2   AIS     R9,1                    :BUMP TO NEXT TERM PARAM
        CLHI    R9,NTRMCH               :SEE IF DONE
        JL      CMOD1                   :LOOP IF NOT

        LA      R3,PROMPT               :SEND CMD PROMPT
        LHL     R2,BOSSP,R13
        JAL     R5,OCS
        TS      UBUFER,R13              :VOID USER BUFFER
        LHI     R0,@FSEND&@FLOG         :HAVE TO RESET SEND
        NH      R0,UFLAG,R13
        STH     R0,UFLAG,R13            :PUT IT BACK
        LA      R5,CGETW
        JR      R6

: CGETOK - GET A TOKEN

CGETOK  HS      0
        LCS     R6,9
        LA      R7,UBUFER+9,R13
CGETL1  JALR    R5,R11
        JFS     CSTART
        NOPR
        JBS     CGETL1
CSTART  JAL     R5,CECHOC
        CLHI    R8,0D                   :TEST FOR CARRIAGE RETURN
        JN      CGETL2
        TS      NFLAG,R13               :SET THE "NO NUMBERS FLAG"
        JR      R9                      :RETURN

CGETL2  TBT     R8,DLMARY               :TEST FOR A DELIMITER
        JE      CGETL3                  :CONTINUE IF NOT DELIMITER

        STH     R8,NFLAG,R13
        JR      R9                      :RETURN
CGETL3  OHI     R8,80                   :SET PARITY
        CHI     R8,0E1                  :CHECK FOR UPPER CASING
        JLFS    CGETL4
        CHI     R8,0FA
        JGFS    CGETL4
        SHI     R8,20
CGETL4  STB     R8,0,R7,R6
        LIS     R5,0                    : / STORE ZERO TO FINISH
        STB     R5,1,R7,R6              :/  OFF INPUT COMMAND.
        AIS     R6,1
        JG      CBTCH4                  :TOO LONG
        J       CGETL1

: CSTRNG - GET A STRING, PLACE IN BUFFER
:       R6 - MAX LEN OF STRING ON INPUT
:            LEN OF STRING ENTERED ON RETURN
:       R7 - ADDRESS OF STORAGE AREA FOR STRING
:       R9 - LINK TO THIS ROUTINE
:       R10- BOSS PORT
:       R11- RETURN LINK FOR GET A CHAR
:       R13- USER BASE REGISTER

CSTRNG  STH     R6,STRSIZ,R13           :SAVE MAX STRING SIZE
CSTR01  LIS     R6,0                    :START WITH LENGTH OF 0
CSTR02  JALR    R5,R11                  :GET A CHARACTER
        NOP                             :SKIP <ESC> DETECTION FOR NOW
        JAL     R5,CECHOC               :ECHO THE CHARACTER
        LR      R8,R8                   :IS IT A NULL?
        JEBS    CSTR02                  :YES, IGNORE
        CLHI    R8,0011                 :IS IT A ^Q?
        JE      CSTR07                  :YES, RESTART THIS INPUT
        CLHI    R8,0001                 :IS IT A ^A?
        JE      CSTR05                  :YES, BACKSPACE IT
        CLHI    R8,0008                 :IS IT A ^H? (BACKSPACE)
        JE      CSTR06                  :YES, BACKSPACE IT
        CLHI    R8,000D                 :IS IT A CR?
        JE      CSTR04                  :YES, PUT A CR/LF OUT

:       NOT A SPECIAL CHARACTER, STORE IT AWAY (EXIT IF LAST CHAR)
        STB     R8,0,R7,R6              :SAVE INTO USERS BUFFER
        AIS     R6,1                    :BUMP INDEX
        CLH     R6,STRSIZ,R13           :CHECK FOR MAXIMUM
        JL      CSTR02                  :GET NEXT CHARACTER
:       MAXIMUM CHAR COUNT EXCEEDED, TERMINATE STRING
        LA      R3,CRLFMG               :GET THE <CR>,<LF> MESSAGE
        LR      R2,R10                  :GET BOSS PORT # FOR OUTPUT
        JAL     R5,OCS                  :PRINT 'CR','LF'
        LIS     R8,0D                   :FAKE A CR AT END
:       END OF STRING
CSTR04  STH     R6,STRSIZ,R13           :SAVE LENGTH
        STB     R8,0,R7,R6              :SAVE CR IN BFR (BUT UNCOUNTED)
        JR      R9                      :EXIT

:       BACKSPACE
CSTR05  LA      R3,BKSPMG               :GET THE BACK SPACE MESSAGE
        LR      R2,R10                  :GET BOSS PORT
        JAL     R5,OCS                  :PRINT 'BS' MESSAGE
CSTR06  SIS     R6,1                    :BUMP BACK THE CHAR PTR
        JG      CSTR02                  :GET NEXT CHAR UNLESS AT START

:       DELETE LINE
CSTR07  LA      R3,UPCRMG               :GET "^",<CR>,<LF> MESSAGE
        LR      R2,R10                  :GET BOSS
        JAL     R5,OCS                  :PRINT IT
        J       CSTR01                  :START WITH INDEX = 0

: CPORT - GET A PORT NAME AND CONVERT TO NUMBER.

:       THIS ROUTINE SCANS THE INPUT STREAM UP TO A DELIMITER, AND, TREATING
:       THAT AS THE NAME OF A PORT, TRIES TO FIND THE PORT WITH THAT NAME
:       OWNED BY THE USER.  

:       R1 - LINK REGISTER
:       R3 - PORT NUMBER (RESULT RETURNED)
:       R4 - TRASHED
:       R6 - NTBLE POINTER
:       R7 - POINTS TO NAME TYPED
:       R8 - OWNER OF CURRENT PORT
:       R9 - TRASH
:       R13 - BASE OF USER BLOCK

CPORT   HS      0
        ST      R1,UTEMP,R13            :SAVE THE RETURN
        JAL     R9,CGETOK               :GET A TOKEN
        L       R1,UTEMP,R13            :RESTORE
        LA      R7,UBUFER,R13
        LHL     R3,FPORT,R13            :START SEARCHING PORTS IN CHAIN
        JFS     CPORT2
CPORT1  LHL     R3,CTBLE,R3,R3          :GET NEXT IN CHAIN
CPORT2  JER     R1                      :NOT FOUND, RETURN
        LR      R6,R3
        SLLS    R6,NLENS
        AI      R6,NTBLE+1              :PNT TO NAME TABLE ENTRY
        JAL     R4,MTCH
        JBS     CPORT1                  :NOT A MATCH
        J       4,R1                    :WE MADE IT!

: CNUM - GET NUMBER TILL A DELIMITER

:       REGISTER USAGE:
:               R5 - LINK TO GET A CHAR AND SCRATCH
:               R6 - ACCUMULATOR FOR #
:               R8 - CHARACTER IN FROM GET A CHAR (MSB=0)
:               R9 - LINK FROM CALLING ROUTINE
:               R11- LINK BACK FROM GET A CHAR ROUTINE

CNUM    LIS     R6,0                    :R6 IS THE ACCUMULATOR
        STH     R6,NFLAG,R13            :THIS FLAG OFF
        STH     R6,CVALUE,R13           :INITIAL VALUE
        J       CNUM1                   :GO START OFF
CNUM0   CLHI    R8,30                   :TEST FOR DIGIT RANGE
        JL      CNUM2                   :JUMP NOT DIGIT
        CLHI    R8,3A                   :TEST FOR "9" (+1)
        JGE     CNUM2                   :JUMP NOT DIGIT
        SHI     R8,30                   :ADJUST FOR #
        LIS     R5,0A                   :MULTIPLY BY 10
        MHR     R6,R5                   :PREVIOUS NUMBER X 10
        AR      R6,R8                   :MAKE NEW NUMBER
        CHI     R6,MAXPRT               :MUST BE <= LAST PORT
        JG      CBTCH1                  :ERROR IF NOT
CNUM1   JALR    R5,R11                  :GET NEXT CHAR
        NOP
        JAL     R5,CECHOC
        J       CNUM0                   :GO PROCESS

:       NOT A DIGIT, MUST BE CR OR COMMA

CNUM2   STH     R6,CVALUE,R13           :SAVE THS NUMBER
        CLHI    R8,0D                   :CHAR = <CR>?
        JNFS    CNUM3                   :NO TRY ANOTHER DELIM.
        TS      NFLAG,R13               :YEP, SET LAST # FLAG
        JR      R9                      :EXIT, (NUMBER FOUND)

CNUM3   HS      0
        TBT     R8,DLMARY               :IS IT A VALID DLM?
        JNR     R9                      :YES, RETURN W/ NUMBER
        J       CBTCH5                  :NO, BITCH

: CECHOC - ROUTINE TO ECHO CHAR
:       INPUT   - R0 = ASCII CHAR
:                 R1 = ISIS PORT NUMBER
:       OUTPUT  - R8 = 7 BIT ASCII CHAR
:       NOTES   - LF OUTPUT AFTER ALL CR'S
:               - REG 0,2-4 NOT SAVED
:               - LINK ON R5

CECHOC  NHI     R0,7F
        LR      R8,R0
        TBT     R10,DEM
        JER     R5
CCHO1   NHI     R0,7F
        TBT     R0,PASSIT               :PRINTABLE ?
        JER     R5                      :NO, SKIP IT

CCHO2   LR      R8,R0
        LIS     R0,5                    :AT LEAST 5 CHARS
        LR      R1,R10                  :GET THE BOSS PORT
        JAL     R4,SLOR
        LR      R0,R8
        JAL     R4,PUTCH
        CLHI    R8,0D
        JNFS    CCHO3
        LIS     R0,0A
        JAL     R4,PUTCH
CCHO3   JAL     R4,ELODR
        JR      R5

PASSIT  WC      01E40000,-1,-1,-4       : Pass all characters
: SET TO -1,-1,-1,-1 TO PASS ALL CHARACTERS
: Was           01E40000,-1,-1,-4 : bel,bs,tab,cr,lf,etc
: 

: REQCKT - REQUEST A PSEUDO-NEEDLE
:       R13 = INDEX INTO LOGIN (LOCAL KEY)
:       R6 = LINK
:       R0-R5 DESTROYED


REQCKT  HS      0
        LHL     R3,HOSTS,,
        STH     R3,PNHOST               :ORIG HOST
        STH     R13,PNLKEY              :STORE THE BASE TO FIND  IT ON RETURN
        LHI     R3,0CC                  :TID - ASCII 1200 BAUD
        STB     R3,PNTID                :STORE TID IN REQUEST

        LIS     R2,0                    :MSG TO PORT 0
        LA      R3,PNREQ                :ADDR OF MSG
        JAL     R5,OCM                  :OUTPUT PSEUDO NEEDLE
        JR      R6                      :RETURN
        SUBTTL  TIME OUT ROUTINES
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              T I M E    O U T    R O U T I N E S             ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: QUARTER SECOND LOGIC

QSEC    AHI     R1,RATE/4
        JAL     R5,TOPUT                :RUN 4 TIMES A SECOND
        LHI     R7,2*NGRP-2             :THIS MANY GROUPS OF HALFWORDS
QSEC1   LCS     R0,1
        XH      R0,TYMSAT,R7            :NOT TYMSAT PORTS
        NH      R0,NBO,R7               :THOSE WITH NO BALLS OUT
        NH      R0,DEM,R7               :THOSE IN DEM
        NH      R0,APORT,R7             :AND THOSE ACTIVE
        STH     R0,TEMP3
QSEC2   LH      R0,TEMP3                :ANY PORTS TO DO
        JFFOH   R0,QSEC3                :FIND FIRST BIT
        SIS     R7,2                    :NONE THERE,DO NEXT GROUP
        JGEBS   QSEC1                   :NEXT GROUP
        J       TORET                   :ALL DONE
QSEC3   RBT     R1,TEMP3                :DONT DO THIS PORT AGAIN
        LR      R0,R7                   :COMPUTING THE PORT NUMBER
        SLHLS   R0,3                    :WHICH GROUP
        AR      R1,R0                   :ACTUAL PORT NUMBER
        RBT     R1,NBO                  :R1 HAS THE PORT NUMBER
        RBT     R1,TBOB                 :TIME OUT BITS
        RBT     R1,TBOA                 :MORE TIMEOUT BITS
        SBT     R1,EXPECT               :EXPECTING RETURNS
        LHI     R2,GBMSG                :MESSAGE TYPE
        LIS     R0,3                    :SIZE
        JAL     R4,SLOR                 :START IT
        JAL     R4,ELOR                 :END IT
        J       QSEC2                   :ANY MORE IN THE HALFWORD GROUP?

: 8 SEC LOGIC

SEC8    AI      R1,RATE*8
        JAL     R5,TOPUT                :RUN AGAIN IN EIGHT SECONDS
        LHI     R7,2*NGRP-2             :THIS MANY HALFWORD GROUPS
SEC81   LH      R0,TYMSAT,R7            :NOT TYMSAT PORTS
        OH      R0,NBO,R7               :THOSE WITH BALLS OUT
        XHI     R0,-1
        NH      R0,APORT,R7             :AND ACTIVE
        NH      R0,DEM,R7               :AND IN DEM MODE
        NH      R0,TBOA,R7              :AND  HAVING ACTUALLY TIMED OUT
        STH     R0,TEMP3                :SAVE THE EXAMINED WORD
SEC82   LHL     R0,TEMP3                :GET THE GROUP
        JFFOH   R0,SEC83                :FIND 1ST ONE,GO TO SEC83,ELSE CONT
        LHL     R1,TBOB,R7
        STH     R1,TBOA,R7
        LCS     R1,1
        STH     R1,TBOB,R7
        SIS     R7,2                    :NONE THERE DO NEXT GROUP
        JGE     SEC81                   :DO NEXT GROUP
        J       TORET                   :ALL DONE,EXIT
SEC83   RBT     R1,TEMP3                :DON'T DO THIS PORT AGAIN
        LR      R0,R7                   :COMPUTING PORT NUMBER
        SLHLS   R0,3                    :WHICH GROUP?
        AR      R1,R0                   :ACTUAL PORT NUMBER
        RBT     R1,TBOA                 :NOT SURE WHAT THIS DOES
        RBT     R1,TBOB                 :SAME HERE
        RBT     R1,EXPECT               :GOING TO CANCEL OUTSTANDING BALLS
        LIS     R0,3                    :MSG SIZE
        LHI     R2,RBMSG                :WHAT WE ARE SENDING
        JAL     R4,SLOR                 :R1 CONTAINS PORT NUMBER
        JAL     R4,ELOR                 :END IT
        J       SEC82                   :ANY MORE THIS GROUP?
        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

        RA      0               :       FINISH.LIB

:       this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF    \FPANEL
  ELSE
        SEG     A.DATA
FPANEL  HS      1
  EI
  IF    \FRISIS
  ELSE
        SEG     0
FRISIS  HS      $A (MAXPRT+15)/16
  EI
  IF    \TOISIS
  ELSE
        SEG     0
TOISIS  HS      $A (MAXPRT+15)/16
  EI

:GENERATE DIAGNOSTICS
Q       EQ      0
        NOLIST
        RE      0F
SEG|Q|  EQ      SEG|Q|&07FFFFFFF
        IF      SEG|Q|%(Q*10000)
        REMARK  %"SEG
        NUMBER  Q
        REMARK  " has been redefined
        EI

  IF    1-(\PATCH0)
        SEG     0
PATCH0  WS      20      :SEGMENT ZERO PATCH AREA
  EI
  IF    1-(\PATCH1)
        SEG     1
PATCH1  WS      20      :SEGMENT ONE PATCH AREA
  EI
  IF    1-(\PATCH2)
        SEG     2
PATCH2  WS      20      :SEGMENT TWO PATCH AREA
  EI
:       DEFINE SIZES
        SEG     Q
S|Q|SIZE EQ     .-SEG|Q|
Q       EQ      Q+1
        ER
        LIST

:       BITCH IF ANY SEGMENTS OVERFLOW
        NOLIST
Q       EQ      0;      RE      0F;     IF      S|Q|SIZE-10000; REMARK  %Segment 
        NUMBER  Q;      REMARK  - overflow, exceeded by 
        NUMBER  $A ($0S|Q|SIZE-10000);  REMARK  d bytes;        EI
Q       EQ      Q+1;    ER
        LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:       SET UP CTA TABLE
  IF    SESIZE
        REMARK  %SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
        SEG     0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA     WC      CNTRL   :CONTROL FLAGS
      EI

        WC      CTASIZ  :SIZE OF CTA AREA
AREAS
Q       EQ      0
        RE      0E
        WC      S|Q|SIZE        :AREA SIZE
Q       EQ      Q+1
        ER

        HC      0E      :NUMBER OF PROTECTION BYTES
    IF  \APROT0
        BC      APROT0  :SET AREA 0 PROTECTION
    ELSE
        REMARK  %DEFAULT AREA PROTECTIONS ASSUMED.%
        BC      6       :EXECUTION PROTECTED
    EI
    IF  \APROT1
        BC      APROT1  :SET AREA ONE PROTECTION
    ELSE
        BC      5       :WRITE PROTECTED
    EI
Q       EQ      2
        RE      0C
    IF  \APROT|Q|
        BC      APROT|Q|
    ELSE
        BC      6       :EXECUTION PROTECTED
    EI
Q       EQ      Q+1
        ER

        WC      ENTRY   :ENTRY POINT ADDRESS
    IF  \DSTART
        WC      DSTART  :DDT START ADDRESS
    ELSE
        WC      0       :NO USER DDT CODE
    EI

        WC      FPANEL  :ADDRESS OF FRONT PANEL DISPLAY CELL

        WC      HOSTS   :HOST TABLE ADDRESS
        WC      PORTS   :PORT TABLE ADDRESS
        WC      PTABLE  :PERMUTER TABLE ADDRESS
        WC      IRING   :INPUT RING ADDRESS
        WC      ORING   :OUTPUT RING ADDRESS
        WC      FRISIS  :ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
        WC      TOISIS  :ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF    \PCTTBL
        WC      PCTTBL  :PROJECT CODE TERMINATION TABLE
  ELSE
        WC      0       :NULL TABLE
  EI
COREST  WS      1       :ABSOLUTE CORE ADDRESS OF START OF SLOT
        HC      MAXHST  :MAXIMUM HOSTS FOR SLOT
        HC      MAXPRT  :HIGHEST PORT NUMBER FOR SLOT
        HC      IRSIZE  :INPUT RING SIZE
        HC      ORSIZE  :OUTPUT RING SIZE
SLOTNO  HS      1       :SLOT NUMBER (SUPPLIED BY ISIS)
VERREV  HS      0
  IF    \VERSION
        BC      VERSION :VERSION NUMBER
  ELSE
        BC      0
  EI
  IF    \REVLEV
        BC      REVLEV  :REVISION LEVEL
  ELSE
        BC      0
  EI

    IF  \QSTART
        WC      QSTART  :DDT QUERRY START ADDRESS
    ELSE
        WC      0       :NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

        WS      10      :RESERVED FOR FUTURE EXPANSION

HOSTS   HS      0       :BEGINNING OF HOST TABLE
Q       EQ      0
        RE      MAXHST
    IF  \HOST|Q|
        HC      HOST|Q| :HOST NUMBER
    ELSE
        HC      0       :NO ASSEMBLED IN HOST NUMBER
    EI
Q       EQ      Q+1
        ER

PORTS   HS      0       :BEGINNING OF PORT TABLE
Q       EQ      0
        RE      MAXHST
    IF  \HPRT|Q|
        HC      HPRT|Q|
    ELSE
        HC      0       :NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q       EQ      Q+1
        ER

PTABLE  HS      MAXPRT+1        :PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ  EQ      .-CTA   :CTA AREA SIZE
SESIZE  EQ      .-CTA   :SEG E SIZE
  EI

:       TELL MEMORY REQUIREMENTS
Q       EQ      0
QQ      EQ      0
QQQ     EQ      0
        RE      0F
        IF      S|Q|SIZE
        REMARK  %SEGMENT 
        NUMBER  Q
        REMARK  -length 
QQQ     EQ      S|Q|SIZE
        NUMBER  $A QQQ
        REMARK  d, requires 
Q3      EQ      (S|Q|SIZE+0FF)&(@0FF);  NUMBER  Q3
QQ      EQ      QQ+Q3
        REMARK  x bytes of core.
        EI
Q       EQ      Q+1
        ER

:       GIVE FINAL SIZES
        REMARK  %       
        NUMBER  (QQ+$03FF)/400$A        :FORCE TO BASE 10 FOR OUTPUT
        REMARK  d K-bytes of core

        UN              :spew out all undefined symbols

@*