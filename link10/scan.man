
          




                     SCAN USER'S MANUAL                     SCAN USER'S MANUAL                     SCAN USER'S MANUAL



                        Reed Powell
                  Digital Equipment Corp.
          Western Region Software Operations Group
                  Santa Clara, California
                         16 Dec 79

                       EDITION:  3.2                       EDITION:  3.2                       EDITION:  3.2



          This manual reflects the status of SCAN,
          Version 7B(541)

          Ownership rights to the contents  remain          Ownership rights to the contents  remain          Ownership rights to the contents  remain
          with  On-Line Systems, Inc., Pittsburgh,          with  On-Line Systems, Inc., Pittsburgh,          with  On-Line Systems, Inc., Pittsburgh,
          Pa.          Pa.          Pa.

CHAPTER 1       INTRODUCTION
        1.1     INTRODUCTION . . . . . . . . . . . . . . . . . . . 1-1

CHAPTER 2       ROUTINE CALL DEFINITIONS
        2.1     INITIALIZATION . . . . . . . . . . . . . . . . . . 2-1
        2.2     REGISTER SAVING  . . . . . . . . . . . . . . . . . 2-1
        2.3     OUTPUT ROUTINES  . . . . . . . . . . . . . . . . . 2-2
        2.3.1     OUTPUT ROUTINES - Text . . . . . . . . . . . . . 2-2
        2.3.2     OUTPUT ROUTINES - Date/Time  . . . . . . . . . . 2-2
        2.3.3     OUTPUT ROUTINES - Numbers  . . . . . . . . . . . 2-3
        2.3.4     OUTPUT ROUTINES - File Specifications  . . . . . 2-3
        2.3.5     OUTPUT ROUTINES - Character  . . . . . . . . . . 2-3
        2.4     INPUT ROUTINES . . . . . . . . . . . . . . . . . . 2-4
        2.4.1     INPUT ROUTINES - Introduction  . . . . . . . . . 2-4
        2.4.2     INPUT ROUTINES - String And Numeric  . . . . . . 2-4
        2.4.3     INPUT ROUTINES - Date/Time . . . . . . . . . . . 2-5
        2.4.4     INPUT ROUTINES - Version Number  . . . . . . . . 2-6
        2.4.5     INPUT ROUTINES - Core & File Sizes . . . . . . . 2-6
        2.4.6     INPUT ROUTINES - Characters  . . . . . . . . . . 2-6
        2.4.7     INPUT ROUTINE - File Specifications  . . . . . . 2-7
        2.5     MISCELLANEOUS ROUTINES . . . . . . . . . . . . . . 2-8
        2.5.1     /RUN PROCESSING  . . . . . . . . . . . . . . . . 2-8
        2.5.2     MAKING CCL job numbers . . . . . . . . . . . . . 2-8
        2.5.3     TABLE LOOKUPS  . . . . . . . . . . . . . . . . . 2-8
        2.5.4     DATE & TIME CONVERSION . . . . . . . . . . . . . 2-8
        2.5.5     SCAN BLOCK CONVERSION  . . . . . . . . . . . . . 2-9
        2.5.6     CHARACTER POSITIONING  . . . . . . . . . . . . . 2-9
        2.5.7     BUFFER CLEARING  . . . . . . . . . . . . . . .  2-10
        2.5.8     PROCESSING WORDS IN A LIST . . . . . . . . . .  2-10
        2.5.9     MAKING MASKS . . . . . . . . . . . . . . . . .  2-10
        2.5.10    TYPING DIRECTORY BLOCKS  . . . . . . . . . . .  2-11
        2.5.11    TESTING FOR LOGGED-IN JOBS . . . . . . . . . .  2-11

CHAPTER 3       THE COMMAND SCANNERS
        3.1     INTRODUCTION . . . . . . . . . . . . . . . . . . . 3-1
        3.2     OVERVIEW OF THE 4 SCANNERS . . . . . . . . . . . . 3-1
        3.2.1     TSCAN  . . . . . . . . . . . . . . . . . . . . . 3-1
        3.2.2     vscan  . . . . . . . . . . . . . . . . . . . . . 3-2
        3.2.3     OSCAN  . . . . . . . . . . . . . . . . . . . . . 3-2
        3.2.4     PSCAN  . . . . . . . . . . . . . . . . . . . . . 3-2
        3.3     SWITCH-FORMATS:  . . . . . . . . . . . . . . . . . 3-3
        3.4     FILE-SPECIFICATIONS  . . . . . . . . . . . . . . . 3-4
        3.5     DEFAULT VALUES FOR SWITCHES  . . . . . . . . . . . 3-5

CHAPTER 4       DEFINING SWITCHES - THE "SWTCHS" macro
        4.1     DEFINING SWITCHES - "SWTCHS" macro  . . . . . . . . . 4-1
        4.2     SWTCHS & DOSCAN -- usage  . . . . . . . . . . . . . . 4-1

        4.3     SWTCHS -- definition  . . . . . . . . . . . . . . . . 4-2
        4.4     PROCESSOR FIELD  . . . . . . . . . . . . . . . . . 4-4
        4.5     SCAN - CONTROLLING FLAGS:  . . . . . . . . . . . . 4-5

CHAPTER 5       THE "DM" & "KEYS" macros
        5.1     THE "DM" AND "KEYS" macros . . . . . . . . . . . . 5-1
        5.2     DM -- maximum & default values . . . . . . . . . . 5-1
        5.3     KEYS - keyword definition  . . . . . . . . . . . . 5-2
        5.4     CONSTRUCTED SYMBOLS - SUMMARY  . . . . . . . . . . 5-3

CHAPTER 6       DEFINING THE "STORAGE" FIELD
        6.1     DEFINING THE "STORAGE" FIELD . . . . . . . . . . . 6-1
        6.2     THE POINTR macro . . . . . . . . . . . . . . . . . 6-1
        6.3     STORAGE FIELD  . . . . . . . . . . . . . . . . . . 6-2
        6.4     EXAMPLES . . . . . . . . . . . . . . . . . . . . . 6-2

CHAPTER 7       DEFINING THE PROCESSOR FIELD
        7.1     USAGE  . . . . . . . . . . . . . . . . . . . . . . 7-1
        7.2     PROCESSOR VS STORAGE(WITH 7777 IN B-PTR) . . . . . 7-1
        7.3     CODING SPECS . . . . . . . . . . . . . . . . . . . 7-1
        7.4     EXAMPLES WITHOUT ALSO USING STORAGE  . . . . . . . 7-1
        7.5     EXAMPLES WITH THE USE OF STORAGE . . . . . . . . . 7-1

CHAPTER 8       DEFAULT VALUE HANDLING
        8.1     INTRODUCTION . . . . . . . . . . . . . . . . . . . 8-1
        8.2     FILE SPEC DEFAULTS . . . . . . . . . . . . . . . . 8-1
        8.3     ABSENT DEFAULTS VS PRESENT DEFAULTS  . . . . . . . 8-1
        8.4     IMPLEMENTING SUPPORT OF ABSENT DEFAULTS  . . . . . 8-3
        8.4.1     GENERATING TABLES AT COMPILE TIME  . . . . . . . 8-3
        8.4.2     EXECUTION TIME SUPPORT CODE  . . . . . . . . . . 8-4
        8.5     SUMMARY  . . . . . . . . . . . . . . . . . . . . . 8-5

CHAPTER 9       FILE-SPECIFICATION SCANNING
        9.1     FILE-SPEC SCANNING . . . . . . . . . . . . . . . . 9-1
        9.2     SCAN BLOCKS  . . . . . . . . . . . . . . . . . . . 9-1
        9.2.1     DEFINITION . . . . . . . . . . . . . . . . . . . 9-1
        9.2.2     SCAN'S BUILT IN SWITCHES . . . . . . . . . . . . 9-2
        9.2.3     SYNTAX REPRESENTATIONS . . . . . . . . . . . . . 9-2
        9.2.4     SCAN BLOCKS: SUMMARY . . . . . . . . . . . . . . 9-3
        9.3     F.ZER & P.ZER  . . . . . . . . . . . . . . . . . . 9-3
        9.3.1     LAYOUT OF SCAN BLOCK . . . . . . . . . . . . . . 9-4
        9.4     ^.STOPB  . . . . . . . . . . . . . . . . . . . . . 9-4
        9.5     USING .FILIN . . . . . . . . . . . . . . . . . . . 9-5
        9.6     SUMMARY OF FILE SPEC SCANNING  . . . . . . . . . . 9-5

CHAPTER 10      .ISCAN - SCANNER INITIALIZAITON
        10.1    ISCAN - SCANNER INITIALIZATION . . . . . . . . .  10-1
        10.2    INITIALIZATION CONCERNS  . . . . . . . . . . . .  10-1
        10.3    RESCANNING THE COMMAND LINE  . . . . . . . . . .  10-1
        10.4    CCL mode . . . . . . . . . . . . . . . . . . . .  10-2
        10.5    I/O ROUTINES . . . . . . . . . . . . . . . . . .  10-2
        10.6    PROGRAM TERMINATION  . . . . . . . . . . . . . .  10-3
        10.7    COMMAND PROMPTING  . . . . . . . . . . . . . . .  10-3
        10.8    FLAGS  . . . . . . . . . . . . . . . . . . . . .  10-3
        10.9    CALLING .ISCAN . . . . . . . . . . . . . . . . .  10-3

CHAPTER 11      .TSCAN - the traditional scanner
        11.1    .TSCAN - the traditional scanner . . . . . . . .  11-1
        11.2    /HELP  . . . . . . . . . . . . . . . . . . . . .  11-1
        11.3    POST PROCESSING OF SWITCHES  . . . . . . . . . .  11-1
        11.4    SCAN BLOCK ALLOCATION  . . . . . . . . . . . . .  11-2
        11.5    STICKY DEFAULTS  . . . . . . . . . . . . . . . .  11-2
        11.6    SCAN CONTROLLING FLAGS . . . . . . . . . . . . .  11-3
        11.7    SWITCH PROCESSING  . . . . . . . . . . . . . . .  11-3
        11.8    CALLING .TSCAN . . . . . . . . . . . . . . . . .  11-4
        11.9    STORAGE INITIALIZATION . . . . . . . . . . . . .  11-4
        11.10   SUMMARY  . . . . . . . . . . . . . . . . . . . .  11-5

CHAPTER 12      OSCAN - THE OPTIONS FILE SCANNER
        12.1    OSCAN - THE OPTIONS FILE SCANNER . . . . . . . .  12-1
        12.2    FORMAT OF THE OPTIONS FILE . . . . . . . . . . .  12-1
        12.2.1    Options List . . . . . . . . . . . . . . . . .  12-2
        12.2.2    Argument Block . . . . . . . . . . . . . . . .  12-2
        12.2.3    CALLING .OSCAN . . . . . . . . . . . . . . . .  12-2
        12.3    APPLYING DEFAULTS FOR .OSCAN . . . . . . . . . .  12-3

CHAPTER 13      .vscan - the verb form scanner
        13.1    vscan - the verb form scanner  . . . . . . . . .  13-1
        13.2    USING .vscan . . . . . . . . . . . . . . . . . .  13-1
        13.2.1    Argument Block Format  . . . . . . . . . . . .  13-2
        13.2.2    CALLING .vscan . . . . . . . . . . . . . . . .  13-2

CHAPTER 14      .PSCAN - THE PARTIAL SCANNER
        14.1    PSCAN & QSCAN - INTRODUCTION . . . . . . . . . .  14-1
        14.2    PSCAN/QSCAN ARGUMENT BLOCK FORMAT  . . . . . . .  14-2
        14.3    PSCAN/QSCAN CALLING FORMAT . . . . . . . . . . .  14-2
        14.4    PSCAN VS QSCAN . . . . . . . . . . . . . . . . .  14-2
        14.5    SUMMARY  . . . . . . . . . . . . . . . . . . . .  14-2

CHAPTER 15      ACCESSING SCAN
        15.1    ACCESSING SCAN . . . . . . . . . . . . . . . . .  15-1
        15.1.1    ASSEMBLY TIME FILES  . . . . . . . . . . . . .  15-1
        15.1.2    LINK-TIME FILES  . . . . . . . . . . . . . . .  15-2
        15.1.3    SOURCE FILES . . . . . . . . . . . . . . . . .  15-2
        15.1.4    SUMMARY  . . . . . . . . . . . . . . . . . . .  15-3
        15.2    SEGMENT ALLOCATION . . . . . . . . . . . . . . .  15-3

CHAPTER 16      EXAMPLES OF USING SCAN
        16.1    INTRODUCTION . . . . . . . . . . . . . . . . . .  16-1

CHAPTER 17      USING THE MISCELLANEOUS ROUTINES
        17.1    INTRODUCTION . . . . . . . . . . . . . . . . . .  17-1
        17.2     .LKNAM - TABLE LOOKUP . . . . . . . . . . . . .  17-1
        17.3    DATE AND TIME CONVERSION . . . . . . . . . . . .  17-2
        17.3.1     .CNTDT  . . . . . . . . . . . . . . . . . . .  17-2
        17.3.2     .CNVDT  . . . . . . . . . . . . . . . . . . .  17-3
        17.3.3     .GTNOW  . . . . . . . . . . . . . . . . . . .  17-3
        17.4    MANIPULATING LISTS OF DATA . . . . . . . . . . .  17-3
        17.5    .RUNCM - RUNNING OTHER PROGRAMS VIA /RUN . . . .  17-4
        17.6    .reeat - backing up the input pointer  . . . . .  17-5
        17.7    .MKMSK - MAKING MASKS  . . . . . . . . . . . . .  17-6
        17.8    .TDIRB - TYPING DIRECTORY BLOCKS . . . . . . . .  17-6
        17.9    .ISLGI - TESTING FOR LOGIN STATUS  . . . . . . .  17-6
        17.10   .MKPJN - MAKING A "CCL" JOB NUMBER . . . . . . .  17-7

APPENDIX A      NOTES ON USING THE SCANNERS

APPENDIX B      NOTES ON Using WILD

APPENDIX C      SCNMAC:  command scanner macros

APPENDIX D      $SCNDC:  COMMAND SCANNER DECLARATIONS

APPENDIX E      EXAMPLES:  SCAN'S INTERNAL SWITCH TABLES

APPENDIX F      EXAMPLES:  ALKFIL

APPENDIX G      CUSPS & THEIR SCANNERS

Index






                              CHAPTER 1
                             INTRODUCTION






 1.1  INTRODUCTION
      SCAN is a  library  of  well-written  routines  of  general
 applicability  to  a wide variety of user programs.  Included in
 SCAN are:  command scanners;  input and output routines for file
 specifications,  numbers,  dates,  strings and characters;  data
 management;  universal date-time conversions;  register  saving;
 and  indirect-file  handling.   All  routines  are written to be
 virtually   independent   of   the   main   program's   register
 conventions.  Only two constraints exist:
    o  AC17 must be a stack pointer, with a stack depth  at  call
       time of at least 15.
    o  AC1  and  AC7  are  used  to  pass  arguments,  and  (when
       applicable), return values.

 All routines will preserve  any  registers  which  they  do  not
 return a value in.
      The default  character  input  and  output  method  is  via
 TTCALLs,  but the user is free to specify the address of his own
 routine if he so desires.  For character input,  the  same  rule
 applies, but the user must always call an initialization routine
 as well.  The routines described in chapter two  will  be  those
 which are the most generally useful, and fall into the following
 groupings:
                                 1-1
INTRODUCTION
INTRODUCTION

        Initialization
        Register Saving
        Output Routines - all
        Input Routines - numbers, dates, file-specs, and words

 The register mnemonics used will be those of SCAN, which are:

 T1 - T4:  1-4 ("Temporaries")
 P1 - P4:  5-10 ("Permanents")
       P:  17 ("Stack Pointer")

      All calls are via a PUSHJ, and  return  at  the  call+1  or
 call+2.

















                                 1-2






                              CHAPTER 2
                       ROUTINE CALL DEFINITIONS


2.1  INITIALIZATION

       .TYOCH - Use the address in T1 as the typeout routine.  Returns
               the previous routine's address (if any) in T1.
       .ISCAN - Initialize for input.  T1 is a pointer to an  argument
               block:
               T1/ LENGTH,, BLOCK
               BLOCK:  Z
               +1:  Z
               +2:  INPUT ROUTINE,,OUTPUT ROUTINE
               +3:  Z
               +4:  Z
               +5:  Z
               If "Input Routine" or "Output  Routine"  (or  both)  is
               zero,  then  TTCALL  I/O  (e.g.:   INCHWL or OUTCHR) is
               used.  The chapter on ".ISCAN" describes  the  meanings
               and usages of the other words in the argument blocks.

 2.2  REGISTER SAVING

       .save1 - save p1
       .save2 - save p1-p2
       .save3 - save p1-p3
       .save4 - save p1-p4
       .popj  - non-skip return (do a popj)
       .popj1 - skip return
       .psh4t - stack t1-t4
       .pop4t - unstack t1-t4

                                 2-1
ROUTINE CALL DEFINITIONS
REGISTER SAVING

 all of the .savxx routines automatically restore the registers  on  a
 skip  or  non-skip  return  from  the routine which called the .savxx
 routine.  for example:
      routin: pushj p,.save2##
        .      .
        .      .
        .      .
              popj  p,  ;registers p1 and p2 are restored;
                        ;  this popj actually returns to
                        ;  the .save2 code, which then returns
                        ;  to whoever called "routin"




 2.3  OUTPUT ROUTINES
 2.3.1  OUTPUT ROUTINES - Text

       .TSIXN - Type T1 in SIXBIT.
       .tstrg - type asciz string which t1 points to.
       .txwww - type a wild octal word;   t1  contains  the  word,  t2
               contains the mask.
       .tmohw - type a wild octal half word;  the word is in lh of t1,
               the mask is in rh.


 2.3.2  OUTPUT ROUTINES - Date/Time

       .TDTTM - Type the date and time which is in T1;   the  argument
               is in the Universal Date/Time format.
       .tdate - type the date which is in t1;  the argument is in  the
               standard DEC format (a la date uuo).
       .tdatn - type the current date.
       .ttime - type the time which is in t1;   the  argument  is  the
               number of milliseconds past midnight (a la mstime uuo).
       .ttimn - type the current time.



                                 2-2
                                              ROUTINE CALL DEFINITIONS
                               output:  date/time, numbers, file-specs

 2.3.3  OUTPUT ROUTINES - Numbers

       .TDECW - Type T1 as a decimal number.
       .TDEC2 - Type  T1  as  a  decimal  number  with  at  least  two
               positions;  fill character is in T2.
       .TOCTW - Type T1 as an octal number.
       .TRDXW - Type T1 in the radix which is in T3.
       .TXWDW - Type T1 as an octal number, in XWD format (LH,,RH)
       .TVERW - Type T1 as a standard DEC version number.
       .tcorw - type t1 as a core size, in p, k, or words.
       .tblok - type t1 as a file size, in blocks or words.
       .tPPNw - type t1 as a PPN.


 2.3.4  OUTPUT ROUTINES - File Specifications

       .TOLEB - Type a file-spec.  T1 points to an OPEN UUO block;  T2
               points  to  an extended LOOKUP or ENTER UUO block of at
               least four words.


 2.3.5  OUTPUT ROUTINES - Character

       .tchar - type t1 as an ASCII character.
       .tfchr  -  type  t2,  using  mnemonics  and  abbreviations  for
               non-printing   characters,  and  preceeding  lower-case
               characters with an apostrophe.
       .tcrlf - type a crlf sequence.
       .tspac - type a single space.
       .ttabc - type a horizonal tab.
       .tcoln - type a colon.
       .tastr - type an asterisk.
       .trbrk - type a right bracket character.
       .tcoma - type a comma.





                                 2-3
ROUTINE CALL DEFINITIONS
INPUT ROUTINES

 2.4  INPUT ROUTINES
 2.4.1  INPUT ROUTINES - Introduction
      The  input  routines  will  normally  leave  their   result   in
 accumulator  "P3"  -  which  they  use  under  the alias "N".  Single
 character input routines will use "P4", under the alias "C".
      Most routine descriptions given below will list two names;   the
 second  one  will  often  be  the same as the first but with the last
 character of the name changed to "C".  The second routine entry point
 is  used  when  the  next character in the input stream is already in
 accumulator "C" ("P4"), while the first routine entry point  is  used
 when  the  next character in the stream has not yet been input.  This
 ability to already have the next input character waiting is  used  in
 conjunction  with  the  so  called  "re-eat"  facility of SCAN, which
 allows a program to look-ahead one character.  The  routine  ".reeat"
 is  used  to  perform thid is described later in this chapter in
 the section "miscellaneous routines."
      more information on this is included in the chapter on using the
 miscellaneous routines.

 2.4.2  INPUT ROUTINES - String And Numeric

       .sixsw, .sixsc - input a SIXBIT word into p3.
       .octnw, .octnc - input an octal number into p3.
       .decnw, .decnc - input a decimal number into p3.
                       optional suffixes for decimal and  octal  input
                       are:   k,  m  and g, for the base raised to the
                       third, sixth, and nineth power, respectively.
       .namew, .namec - input a possibly wild SIXBIT word;  word is in
                       p3, mask is in t2.
       .ascqw, .ascqc - input a possibly  quoted  ASCII  string.   the
                       string  will  be  input  into  the area (inside
                       scan) beginning at the global  symbol  ".nmul",
                       and   extending  no  further  than  the  symbol
                       ".nmue".   input  terminates   at   the   first
                       non-alphanumeric   character.   any  characters
                       within the string being typed, but which cannot
                       be  fit  into  the buffer, are lost.  since the
                       symbols ".nmue" & ".nmul" are global, they  are
                       accessable  from  the  calling  program,  which
                       should blt them to a safe place.
       .sixqw, .sixqc - this functions exactly as  does  .ascqw/.ascqc
                       above, except that the characters are stored in
                                 2-4
                                              ROUTINE CALL DEFINITIONS
                                    input:  string, numeric, date/time

                       SIXBIT rather than ASCII.
       .sixmw, .sixmc - this functions exactly as  does  .sixqw/.sixqc
                       above,  except  that the input string cannot be
                       quoted.

 2.4.3  INPUT ROUTINES - Date/Time
                       [More information on this subject is  contained
                       in the later chapter on USING THE MISCELLANEOUS
                       ROUTINES]
       .DATIM, .DATIC  -  Input  date-time  into  P3,  storing  it  in
                       universal format.
       .DATIP, .DATIQ - Input a date-time in the past into P3, storing
                       it in universal format.
       .DATIF, .DATIG - Input a  date-time  in  the  future  into  P3,
                       storing it in universal format.
      Legal date-time formats, examples and explanations are:

        FORMAT          EXAMPLE         EXPLANATION
 DATE-SPEC:
        day             WED             NEXT WEDNESDAY
        day offset      123D            123 days from today
        MM-DD           6-12            Jun. 12 this year
        MM-DD-Y         6-12-6          Jun. 12, 1976
        MMM-DD-YY       JUN-12-76       June 12, 1976
        DD-MMM-YYYY     12-JUN-1976     June 12, 1976
        Mnemonic        YESTERDAY       as appropriate for
                        TOMORROW        current date
                        TODAY
 TIME-SPEC:
        HH              12              12:00:00
        HH:MM           13:02           12:02:00
        HH:MM:SS        1:02:37         obvious
        mnemonic        NOON
                        LOGIN

 DATE-TIME:
        date-spec:time-spec     JUN-12-76:13:02:37


                                 2-5
ROUTINE CALL DEFINITIONS
input:  string, numeric, date/time

 2.4.4  INPUT ROUTINES - Version Number

       .VERSW, .VERSC - Input a  version  number  into  P3,storing  in
                       standard  DEC-10  format.  Version number input
                       format is:

                       VVMM(EE)-W where:
                            VV is the major version, blank to 511
                            MM is the minor version, blank to ZZ
                            (EE) is the edit number,
                              blank to 202,143 (octal 777777)
                            -W is code for source of last edit;
                              absent or 0 thru 7
                       The internal representation is:
                            bits 0-2:    -W
                            bits 3-11:   VV
                            bits 12-17:  MM
                            bits 18-35:  (ee)

 2.4.5  INPUT ROUTINES - Core & File Sizes

       .COREW, .COREC - Input a core  size  in  words,  pages,  or  K;
                       suffixes   are:    W   (default),   P   and  K,
                       respectively.  Returns size, in words, in P3.
       .BLOKW, .BLOKC  -  Input  a  file  size  in  words  or  blocks;
                       suffixes  are:  W (default) or B.  Returns size
                       in words in P3.

 2.4.6  INPUT ROUTINES - Characters

       .TICAN - Check for an alphanumeric character in P4.   Non-skips
               if not alphanumeric, skips if it is.
       .TIMUC - Convert character in P4 to upper case,  if  it  is  in
               lower case.
       .TIAUC - Input  a  character  into  P4,  handling  lower  case,
               altmodes and all compressions.
       .TIALT  -  Input  a  character,  handling  altmodes  and  space
               compression, into P4.
       .TIGET - Gets a character into P4, with no equivalencing.
                                 2-6
                                              ROUTINE CALL DEFINITIONS
                                Input:  Character, File Specifications

               For .TIAUC and .TIALT, P4 is returned in the  following
               format:
                    1-177:      actual character
                        0:      end-of-line character
                       -1:      altmode
                       -2:      end-of-file
                                  (Control Z, or EOF on indirect file)
               The following  are  Guide  Words  (pseudo  characters);
               these  are  recognized  during  the scan by their being
               enclosed in single quotes:
                     4000:      'AND'
                     4001:      'OR'
                     4002:      'NOT'
                     4003:      'TO'
                     4004:      'FROM'
                     4005:      'INPUT'
                     4006:      'OUTPUT'
                     4007:      'SOURCE'
                     4010:      'LIST'
                     4011:      'OBJECT'

                    For more information, see "SYNTAX REPRESENTATIONS"
               in Chapter 8.  Also refer to Appendix D - "SCNMAC."



 2.4.7  INPUT ROUTINE - File Specifications

       .FILIN - Input a file specification.  Details on its  usage  is
               the subject of a later chapter in this document.

 2.5  MISCELLANEOUS ROUTINES





                                 2-7
ROUTINE CALL DEFINITIONS
MISCELLANEOUS ROUTINES

 2.5.1  /RUN PROCESSING
       .RUNCM  -  Process  a  /RUN  specification,  if  any  has  been
               encountered.   No arguments are possible;  returns only
               if no /RUN was ever seen on the line, or if the RUN UUO
               failed.   usually  called  right  before normal program
               termination code.  more on this routine in included  in
               a later chapter on using the miscellaneous routines.

 2.5.2  MAKING CCL job numbers
       .MKPJN - Make a CCL job number.  call with the job  number  (or
               whatever)  in t1.  returns with SIXBIT form of argument
               in (rh) of t1.  more information is in a later  chapter
               on using the miscellaneous routines.

 2.5.3  TABLE LOOKUPS
       .LKNAM - Do a table search for an exact or  abbreviated  match.
               Call  with  SIXBIT  value in t2, and a pointer in t1 of
               the form:
                      iowd length, table-address

                    skip-returns if a match was found, with (rh) of t1
               pointing  to  the  match, and (lh) of t1 zero if it was
               abbreviated, or negative if an exact  match.   non-skip
               returns  if  unsuccessful, with t1 negative if no match
               was found, or positive if multiple matches were  found.
               a  later  chapter  (using  the  miscellaneous routines)
               covers this routine in greater detail.


 2.5.4  DATE & TIME CONVERSION
               [More information on the following  routines  for  date
               and  time  conversion  is  included in a later chapter:
               USING THE MISCELLANEOUS ROUTINES]
       .CNTDT - Convert universal date/times  to  DEC  formats.   call
               with universal form in t1, returns with DEC date in t2,
               and ms in t1.
       .gtnow - get current date and time, in universal  format,  into
               t1.
       .cnvdt - convert DEC  format  date/time  to  universal  format.
                                 2-8
                                              ROUTINE CALL DEFINITIONS
                                                MISCELLANEOUS ROUTINES

               call   with  time  in  t1,  stored  as  the  number  of
               milliseconds past midnight (mstime uuo).  the  date  is
               in  t2,  stored  in the standard DEC format (date uuo).
               returns universal form in t1 (or -1 if date was  beyond
               september   27,   2217).   note  that  "day  0"  was  a
               wednesday, and so (t1)/7 gives a  day  of  week  index,
               with wednesday being 0.


 2.5.5  SCAN BLOCK CONVERSION
       .stopb - convert a  "scan-block"  (see  the  later  section  on
               "file-spec scanning") to open and extended LOOKUP/ENTER
               blocks.  call with:
                  t1/ length,,address of scan-block
                  t2/       ,,address of open block
                  t3/ length,,address of lookup block
                  t4/       ,,address of path block (9 words)
               returns non-skip (error) if any wild cards were seen in
               the scan-block;  otherwise it skip-returns.

 2.5.6  CHARACTER POSITIONING
       .reeat - cause the contents of p4 to be the next  character  to
               be   read.    p4  will  normally  contain  the  current
               character.  call is simply
                  movei p4, char
                  pusht p,.reeat##
               more information  on  this  routine,  and  the  general
               concept  of positioning input from the command line, is
               covered in a later chapter on using  the  miscellaneous
               routines.

 2.5.7  BUFFER CLEARING
       .CLRBF - This routine will clear any type ahead  in  the  input
               stream.   No  arguments are passed, no values returned,
               and control always comes to the calling point +1.


                                 2-9
ROUTINE CALL DEFINITIONS
misc:  scan-block conversion, input back-spacing

 2.5.8  PROCESSING WORDS IN A LIST
       .GTWRD - Get a word from a list.  Call with:
                    T1/ table address
                    T2/ length of table
               PUSHJ  P,.GTWRD##
                    T1/ incremented by 1
                    T2/ decremented by 1
                    T3/ data from list, or 0 if at end
               This routine is covered in greater detail,  along  with
               the  following  routine (.PTWRD), in a later chapter on
               USING THE MISCELLANEOUS ROUTINES.
       .PTWRD - Put a word into a list.  This  is  meant  to  be  used
               along  with  .GTWRD,  above.  Control always returns to
               the call +1 location.  Calling sequence is:
                    T1/ table address
                    T2/ maximum table length
                    T3/ data to be stored
                    PUSHJ P,.PTWRD##
                    T1/ incremented by 1
                    T2/ decremented by 1
                    T3/ old data from location stored into


 2.5.9  MAKING MASKS
       .MKMSK - This routine makes a mask for its argument word.   The
               argument  must  be  SIXBIT  data.  the mask contains 1s
               where the argument had  non-blanks.   calling  sequence
               is:
                    move t3,argument
                    pushj p,.mkmsk##
                     -always returns here-
                    t1/ mask for argument
               more information on this  routine  is  in  the  chapter
               using the miscellaneous routines.


                                 2-10
                                              ROUTINE CALL DEFINITIONS
                      misc:  scan-block conversion, input back-spacing

 2.5.10  TYPING DIRECTORY BLOCKS
       .TDIRB - This routine is used to  type  out  directory  blocks.
               Three  formats  are accepted:  1) Extended LOOKUP/ENTER
               blocks;  2) PATH Blocks;  and 3) "bi-words",  which  is
               an internal scan format.  the calling sequence is:
                    hrli t1,code
                    hrri t1,address
                    pushj p,.tdirb##
                      -always returns here-
                    where "code" is one of the following:
                    1 if (rh) is address of LOOKUP/ENTER block
                    2 if (rh) is a path block address
                    3 if (rh) is address of "bi-words"
               more information on .tdirb is in the chapter using  the
               miscellaneous routines.

 2.5.11  TESTING FOR LOGGED-IN JOBS
       .ISLGI - This routine is used  to  test  to  determine  if  the
               calling  job is logged in.  No argument is passed.  The
               value returned is:
                    PUSHJ P,.ISLGI##
                     -here with T1=-1 if not logged in, or
                                T1= 1 if indeterminate
                     -here if logged in (skip ret)










                                 2-11






                              CHAPTER 3
                         THE COMMAND SCANNERS

 3.1  INTRODUCTION
      This chapter will discuss the types of command scanners provided
 by SCAN.  The actual details of usage are covered separately in later
 chapters on each scanner.  The purpose of this chapter is to  present
 the  concepts of command scanners and switch types which are relevant
 to determining which scanner is best for various applications.

 3.2  OVERVIEW OF THE 4 SCANNERS
      Within SCAN there are four basic Command Scanning routines,  and
 an  initialization  routine.   The  four scanners all accept the same
 switch formats;  their only differences lie in the structure  of  the
 command line itself.  The scanners are:


 3.2.1  TSCAN
      This is the so-called "Traditional Scanner." Command  lines  are
 of the form:
                      OUTPUT = INPUT
                      OUTPUT = INPUT,INPUT, ...
                           or
                      INPUT
 Users of this syntax are PIP and DIRECT.




                                 3-1
THE COMMAND SCANNERS
OVERVIEW OF THE 4 SCANNERS

 3.2.2  vscan
      This is the "Verb Form Scanner." Command lines look like:
                      COMMAND-WORD /SWITCH/SWITCH
                      COMMAND-WORD /SWITCH/SWITCH FILE-SPEC
                           or
                      COMMAND-WORD
 DUMP and BACKUP programs are users of this format.


 3.2.3  OSCAN
      This is the "Option File Scanner." This scans  the  options-file
 SWITCH.INI for entries of the form:
                      NAME /SWITCH/SWITCH
                           or
                      NAME:OPTION /SWITCH/SWITCH

 Users of this feature include LOGIN, DIRECT, BACKUP, SOS, and ALKFIL.


 3.2.4  PSCAN
      PSCAN is the "Partial Mode" Scanner.  Commands are of the  TSCAN
 style, but only part of the line is processed by SCAN.  command lines
 might be of the format:
                      mumble mumble /switch /switch
 in this case, the "mumble mumble" portion of  the  command  could  be
 parsed  by  the  user  program,  and  PSCAN  would  be used to do the
 "/switch" processing.  an example of a PSCAN user is CREDIR.






                                 3-2
                                                  THE COMMAND SCANNERS
                                                       SWITCH-FORMATS:

 3.3  SWITCH-FORMATS:

      The general formats of a switch specification are  quite  simple
 -- which format a particular switch will require depends on how it is
 defined in the SWTCHS  macro (described later).
      the simplest switches are those which take no  value  --  it  is
 their  presence (or absence) which is important.  the presence of the
 switch  will  cause  scan  to  deposit  a  predefined  value  into  a
 predefined  memory  byte  or  word.   it  is  also possible for these
 switches to be, in effect, three-way rather than two-way.  either the
 switch  is  absent,  present,  or  present  with "no" prefixed to it.
 examples of these types of switches are:
      /fast
      /help
      /map
      /nomap

      the second type of switch is one that takes a value (or  values)
 which  must  be  part  of a pre-defined list of legal values for that
 switch.  the "value" of the switch is then the  numeric  index,  into
 the  table  of legal values, of the value specified.  for example, if
 the legal values for "/mode" were "ASCII,  octal,  SIXBIT,  decimal,"
 then:
      /mode:octal       value = 1
      /mode:decimal     value = 3
      /mode             is illegal

      a variation of this switch allows for defaults when:
    .  the switch was not mentioned.
    or
    .  the switch was mentioned, but without an explicit value.

      the third type of switch is  one  that  takes  a  more  or  less
 arbitrary  value.  this value can be anything the user desires.  scan
 is supplied with the name of a routine to "pick-up" the value, and  a
 description  of  where  and  how  to  store the value.  if desired, a
 maximum value may be specified.  in addition, the comment above about
 defaults  for  type  2  switches  also holds here.  the switch may be
 defined to occur only once on a given command line,  or  to  occur  a
 number  of times on the same command.  typical values are numbers and
 file specifications;  for example:
                                 3-3
THE COMMAND SCANNERS
Switch Formats

      /width:75
      /abcd:12 /abcd:34 /abcd:56 /abcd:78
      /file:myfil.mac[70001,1]
 the three basic switch types can be summarized as:
      type 1 - no value
      type 2 - SPecific values only
      type 3 - arbitrary values



 3.4  FILE-SPECIFICATIONS

      The format of a file specification for SCAN  is  quite  general.
 No  ordering  between the components is either expected or necessary.
 The basic parts of a file-spec are:

  o  DEVICE:  1-6 SIXBIT characters followed by a colon ("foo:").
  o  filename:  1-6 SIXBIT characters ("mumble").
  o  extension:   1-3  SIXBIT  characters,  preceeded  by   a   period
     (".gup").
  o  PPN:  a project number  (1-377777  octal),  a  programmer  number
     (1-377777 octal) and (optionally) an sfd specification, in one of
     the following arrangements:
        [PROJECT,PROGRAMMER]
        [PROJECT,PROGRAMMER,sfd,sfd,...]
        [,PROGRAMMER]               uses logged-in PROJECT
        [,PROGRAMMER,sfd,sfd,...]         -dittoe-
        [PROJECT,]                  uses logged-in PROGRAMMER
        [PROJECT,,sfd,sfd,...]            -dittoe-
        [,]                         uses logged-in PPN
        [,,sfd,sfd,...]                  -dittoe-
        [-]                         uses default path
  o  switches:  any of the switches described later as "internal  scan
     switches." (see "file-spec scanning.")



                                 3-4
                                                  THE COMMAND SCANNERS
                                           DEFAULT VALUES FOR SWITCHES

 3.5  DEFAULT VALUES FOR SWITCHES
      When the user calls SCAN, he has the option of specifying a  set
 of  defaults  for  any  of the above components.  SCAN will use these
 defaults  in  the  event  that  the  user  does   not   specify   the
 corresponding  component of the specification.  More of this topic is
 covered in detail in a later chapter -- "DEFAULT VALUE HANDLING."























                                 3-5






                              CHAPTER 4
                 DEFINING SWITCHES - THE "SWTCHS" macro



4.1  DEFINING SWITCHES - "SWTCHS" macro
     the purpose of this chapter is  to  cover  the  topic  of  switch
definition.  it is necessary for the user program to provide SCAN with
information on the switches to be parsed.  this includes data such  as
the switch name, switch class, the type of argument (if any), where to
store the parsed values, and the like.   the  definition  process  has
been made relatively simple and painless by the use of macros supplied
in SCNMAC.

4.2  SWTCHS & DOSCAN -- usage
     The properties of each switch to be scanned are defined via calls
to  a  set  of  MACROs provided by SCAN.  There is always a one-to-one
correspondence between a switch and its  MACRO  specification.   These
switch  MACROs  are  all  included  within a user defined MACRO called
"SWTCHS".  the definition of SWTCHS  is of the following simple form:

          define SWTCHS  <
          macro-call .  .  .  .
          macro-call .  .  .  .
                 .
                 .
                 .
          macro-call .  .  .  .
          >;end of SWTCHS  macro


                                 4-1
DEFINING SWITCHES - THE "SWTCHS" macro
SWTCHS & DOSCAN -- usage

     once the switches are defined in SWTCHS,  the  scanning  tables  are
generated by calling the macro "DOSCAN".  the format of this call is:
          DOSCAN (name)

where "name" is a legal  macro-10  label  from  1-5  characters.   the
tables generated for use by SCAN will have labels of the form "namex,"
where "x" identifies the specific table.  the tables involved are:

    o  namen - the table of switch names (in SIXBIT), one per word.
    o  named - the table of default values.
    o  namem - the table of routine addresses  for  processing  switch
       values.
    o  namep - the table of pointers used for storing values.
    o  namel - this symbol's value is the length of each of the  above
       tables.


 4.3  SWTCHS -- definition
      There are four switch defining macros (invoked within SWTCHS)  used
 for  defining  each  class  of switch, which are described below:  ss                                                                    ss                                                                    ss
 (switch-storage),  sn  (switch-name),  sl   (switch-list),   and   sp  s      s          sn   s      n       sl    s      l              sp  s      s          sn   s      n       sl    s      l              sp
 (switch-pointer).  a "typical" switch-table definition might now look  s      p  s      p
 like:
      define SWTCHS  <
      ss...
      sn...
      sl...
      sp...
      >
      DOSCAN (test)

 the switch macros and their parameters are:

   1.  ss - this is for switches described  above  as  "type  1".   no
       value is specified on the command line;  instead, a pre-defined
       value is stored.  the ss format is:

                                 4-2
                                   DEFINING SWITCHES - THE "SWTCHS" macro
                                                     SWTCHS -- definition

            ss name, storage, value, flags
       when the switch is encountered, value will  be  placed  in  the
       location  described  by  storage.   flags  are scan-controlling
       flags which will be described later.  storage may be an address
       or  a  byte  pointer.  use of the POINTR macro for defining the
       storage field latter is described  later.   an  example  of  ss
       usage is:

            ss map,maploc,1,0
       in this case, "1" is stored in maploc if /map is  seen  on  the
       command line.
   2.  sn - this is also for "type 1" switches,  in  the  cases  where
       "no" may be prefixed to a switch's defined name.  the sn format
       is:

            sn name, storage, flags

            if the switch is  encountered  without  the  "no"  prefix,
       storage  takes  the value "1."  if the prefix "no" is included,
       the value of storage is then "0."  storage  and  flags  are  as
       defined for ss.  for example:
            sn interchange,intloc,0
       if /interchange were  define  in  this  manner,  then  whenever
       /interchange  appeared on the command line, "1" would be stored
       in intloc  (as  would  be  the  case  with  ss).   however,  if
       /nointerchange  were  seen  (which  would not be legal using ss
       unless a seperate ss definition were made), then "0"  would  be
       put into intloc.
   3.  sl - this is used to define "type 2" switches;  those with  one
       of  a  specific  set of values.  associated with this macro are
       two others -- "KEYS" and "dm" -- which are  called  outside  of                                                           _______
       SWTCHS.  the sl format is one of:
                 sl name,storage,table,default,flags
                 sl name,processor,table,default,flags

            storage  and  flags  are  as  described  for  ss  formats.
       processor is used to specify a non-standard (i.e.:  non-SIXBIT)
       input routine.  this  routine  is  then  also  responsible  for
       storing  the  value  as  well.   table  and  default  are names
       associated with the KEYS and DM macros, respectively.
                                 4-3
DEFINING SWITCHES - THE "SWTCHS" macro
SWTCHS -- definition

            the value placed in storage will be  the  index  into  the
       table  of values generated by KEYS.  the format of the macro-10
       labels generated are described below with the KEYS  macro.   an
       example of the sl format is:
                 sl parity,parloc,pary,par,
       this will  be  explained  once  the  KEYS  and  DM  macros  are
       described below.

   4.  sp - this format is used with "type 3" switches;   those  which
       take  an  arbitrary  value,  possibly  less  than  a predefined
       maximum.  the sp format is:
                 sp name,storage,processor,default,flags
            storage  and  flags  are  as  described  above   for   ss.
       processor  is  the  address  of  the  routine  (either  scan or
       user-supplied) to "pick-up" the value.  this routine must leave
       the value in p3 if it wants scan to store it.  the routine must
       return +1 for scan to store the value, or +2 for  scan  to  not
       store  the  value.   default  is as described for sl and may be
       null if no defaults (or maximum value) are desired.   examples,
       which will be explained in more detail later, are:
                 sp protection,protec,.octnw##,,0
                 sp protection,protec,.octnw##,pro,0


      each of these macros  will  uniquely  identify  and  describe  a
 switch in terms of the following characteristics:
    o  its name.
    o  where to place its value, if any (storage).
    o  how to read its value, if any (processor).
    o  what its legal values, if any, are (table).
    o  what its default and maximum values are, if any (default).
    o  the syntax in which it may or may not be used (flags).


 4.4  PROCESSOR FIELD
      More information on the use and  definition  of  this  field  is
 given  in  a  later  chapter  (DEFINING  THE  PROCESSOR  FIELD).  The
 locations defined by this parameter are normally  given  the  initial
 value  of "-1" by the program.  SCAN expects this, and uses this as a
 means of detecting attempts to store values into locations containing
 already  valid  data.   The  most  common  instance  of this would be
                                 4-4
                                   DEFINING SWITCHES - THE "SWTCHS" macro
                                                       PROCESSOR FIELD

 multiple occurances of the same switch on the same  line,  when  that
 switch was not defined for multiple occurances.

 4.5  SCAN - CONTROLLING FLAGS:
      Each switch may have associated with it a combination of any  of
 the  following flags.  These flags control how the switch may be used
 in a command line.
    o  FS.VRQ - A value is required.
    o  FS.NFS - The switch is  never  part  of  a  file-specification.
       This switch should be meant as a global switch.
    o  FS.LRG - The maximum and default values are 0 or  greater  than
       2**17.   If  set,  and  the maximum value (in DM macro) is set,
       then 36-bit values for this switch  are  possible.   otherwise,
       only 18-bit values are legal.
    o  fs.ncm - this switch is not a command switch (for vscan).
    o  fs.nue - no user exit on this switch.  this  means  that  /exit
       and ^z do not cause an exit via monret, as they normally would.
    o  fs.obv - "or bit values." this causes the value of  the  switch
       to  be or-ed with whatever existing value may already have been
       stored.  normally, the old value in  the  storage  location  is
       overwritten.   if  this  flag  is  set,  then scan will ldb the
       existing value, ior in the value of the switch as just  parsed,
       and then dpb the value back to storage again.
    o  fs.nos - for the sn macro calls only:   this  switch  may  take
       "no" as a prefix.









                                 4-5






                              CHAPTER 5
                       THE "DM" & "KEYS" macros



 5.1  THE "DM" AND "KEYS" macros
      These two scanning macros are those related to:  1) default (and
 maximum)  values,  and  2)  values for "TYPE 2" (SL) switches.  These
 were mentioned above in the discussions of the SL and SP macros,  and
 will now be described in detail.

 5.2  DM -- maximum & default values
      In order to supply SCAN  with  a  set  of  default  and  maximum
 values,  the programmer supplies a 1-3 character name in the SL or SP
 macro, in the field DEFAULT.  After SWTCHS   has  been  defined,  DM  is
 called for each switch referencing it.  a DM call has the form:
           dm (name,max,absent,present)
           where:
           name     is the 1-3 character name in the sl or sp
                    call.
           max      is the maximum value.
           absent   is the default value if the switch is not
                    encountered.
           present  is the default value if the switch is
                    present, but without a value.
      each of these values is given  a  symbolic  name,  if  the  name
 already  is  defined,  then  the existing definition takes precedence
 over the DM argument.  the three symbol names are of  the  respective
 forms:
      MX.name ad.name PD.name
                                 5-1
THE "DM" & "KEYS" macros
"dm"

 an example will clarify this somewhat.  given the following:
      define SWTCHS  <
      sp protection,protec,.octnw##,pro,0
      >
      dm (pro,777,057,155)

      this defines a switch "/protec" whose maximum  value  is  "777".
 if  the switch is not in the command line, the program (not scan) may
 use the symbol ad.pro for the value, which  may  be  "057."  if  only
 "/protec"  is  in  the  command string, then the value stored by scan
 will be that of PD.pro, in this case "155".

 5.3  KEYS - keyword definition
      "type 2" (sl) switches always take a  value  from  a  predefined
 list  of  keywords.   these  keywords  must  be  made from the SIXBIT
 characters, and are defined in the KEYS macro.  the sl macro's  table
 field  is then used as an argument to KEYS.  KEYS is called after SWTCHS
 is defined (just like DM is).  the call is of the form:
           KEYS (name,word1,word2,...wordn)
           where:
           name is the 1-4 character name from the sl call.
           word1 is the first possible value.
           word2 is the second possible value.
           wordn is the last possible value.

      the table of values is given the name name.t and  is  of  length
 name.l.   each possible value's position in the table is the value of
 the symbol namexx, where "xx" are the first  two  characters  of  the
 value.  this implies that if these scan constructed symbols are to be
 used by the program (not a necessity),  then  all  keywords  must  be
 unique in their first two letters.
      once again, an example is in order.  consider the following:
           define SWTCHS  <
           sl parity,parloc,pary,par
           >
           KEYS (pary,even,odd,none)
           dm (par,pary.l,paryno,paryod)

                                 5-2
                                              THE "DM" & "KEYS" macros
                                                                "KEYS"

      this generates a switch "PARITY" which takes as a "value" of  of
 the following keywords:
           even
           odd
           none
 the default is "none" if  only  "/parity"  is  seen  in  the  command
 without  an  explicit value.  if the "/PARITY" switch is missing from
 the command line altogether, then the default value (not supplied  by
 scan)  is  "odd".   the location "PARLOC" will receive the "value" of
 the switch, which is determined by the order in  which  the  keywords
 are listed in the KEYS macro:
           even=0
           odd =1
           none=2

      the maximum value for such  a  switch  is  the  value  (not  the
 contents)  of  the  symbol "pary.l" (ie, the 1-4 character designater
 used in KEYS, with ".l" catenated to the right).
      the elemets of the DM call specifying the defaults  may  be  the
 symbolic names constructed by the KEYS call, or the actual values (as
 literals or non-scan defined symbols) values.  the later is  normally
 undesireable,   as  it  makes  changing  a  switch's  characteristics
 difficult, but is used when the possible values (keywords) cannot  be
 unique  in their first two letters.  if the non-unique values are not
 to also be default or maximum values, then this poses no real problem
 (since  the  assembler  will  simply  use  the  latest  definition it
 encounters).

 5.4  CONSTRUCTED SYMBOLS - SUMMARY
      The previous sections has covered a number of  symbols  used  by
 SCAN  and  its  support  code  that  are  created  by the SCAN macros
 themselves.  To summarize them:
  o  MX.???  - ???  is first arg to dm;  this is created by DM as  the
     maximum value for the switch
  o  ad.???  - as above, but this is the absent default value for  the
     support program to use if it sees fit.
  o  PD.???  - as above, but this is the present default value for the
     switch, used by scan.
  o  ????.l - ????  is the first agr to  KEYS;   this  is  created  by
     KEYS,  and  has  as its value the length of the table of keywords
     created by KEYS for this switch.
                                 5-3
THE "DM" & "KEYS" macros
CONSTRUCTED SYMBOLS - SUMMARY

  o  ????.t - as above, but this  is  the  address  of  the  table  of
     keywords created by KEYS.
  o  ????xx - as above, but this is the  index  into  ????.t  for  the
     keyword whose first 2 characters are xx.
  o  ?????n - ?????  is the arg  to  DOSCAN  (see  previous  chapter);
     this is the table of switch names.
  o  ?????d - as above, this is the table of default values
  o  ?????m - as above, this is the table of  processor  routines  for
     the switch
  o  ?????p - as above, this is the table of information  for  storing
     values.
  o  ?????l - as above, this is the length of the other tables created
     by DOSCAN.

















                                 5-4






                              CHAPTER 6
                     DEFINING THE "STORAGE" FIELD



6.1  DEFINING THE "STORAGE" FIELD
     All of the Switch macros have the field denoted  "STORAGE."  This
field  can have a number of formats, sometimes depending on the switch
macro itself.  Each of the formats will be described here.

6.2  THE POINTR macro
     One of the principle uses  of  STORAGE  is  as  a  byte  pointer.
Because  of  this, it is useful to first mention the use of the POINTR
macro, since it is quite often the method used to define  the  storage
field.
     this macro is used to define  a  byte  pointer,  given:   1)  the
definition of the byte in terms of a mask, and 2) the storage location
containing the byte.  an example might prove useful here.   suppose  a
word  "y"  contains a byte "x," consisting of bits 11 through 19.  the
POINTR usage would then be:
      x=177600000;  mask for bits 11-19
      POINTR (y,x)      

 if "x" were changed to be some other byte, either in "y" or  in  some
 other  location,  the  only change needed would be to its definition;
 references to it via the POINTR macro would not need changing



                                 6-1
DEFINING THE "STORAGE" FIELD
STORAGE FIELD

 6.3  STORAGE FIELD
      There are five formats for STORAGE:
 1.  Word Address.  (SN,SS,SP,SL)
 2.  Byte Address.  (SN,SS,SP,SL)
 3.  Pointer to multiple-value storage.  (SS,SP,SL)
 4.  Pointer to a file-specification storage area.  (SP)
 5.  Address of a routine to process keyword.  (SS,SP,SL)

      For all formats except #1, STORAGE is in the format of a  PDP-10
 byte  pointer, although it may not always be used as such.  The exact
 format definitions for the five types, in order are:
  1.  (LH)=0
      (RH)=word address;  value is MOVEMed into the storage address.
  2.  Standard byte pointer format;  value is DPBed into  the  storage
      field.
  3.  The byte size field contains the number of words in the  storage
      area, in the form (65-#words).  (RH) points to the first word.
  4.  This  is  implicit:   ".FILIN"  will  have  been  given  as  the
      PROCESSOR.   (RH)  is  the address of the SCAN storage area (see
      later discussion of SCAN blocks).  The length of this area  (see
      later  discussion  of SCAN blocks) is the value of MX.name (from
      the DM call), which would otherwise  have  no  meaning  in  this
      context.
  5.  bits 0 through 11 in the "byte-pointer" being all 1s means  that
      (rh) is the dispatch address of a processor which will "pick-up"
      the keyword.  more information  on  this  usage,  including  the
      distinctions  between  this  usage of storage, and the processor
      field, is included  in  the  following  chapter:   defining  the
      processor field.


 6.4  EXAMPLES
      For each of the  formats  listed  above,  a  short  example  and
 explanation  is  given.   These  should help clarify the explanations
 given above.
 1.  Consider the switch MUMBLE.  Whenever it is seen on  the  command
     line,  the  support  program  desires to have 123 stored into the
     location FLAG.  MUMBLE might then be  defined  in  the  following
     manner:
     SS MUMBLE,FLAG,123,0
                                 6-2
                                          DEFINING THE "STORAGE" FIELD
                                                              EXAMPLES

 2.  For the sake of efficiency and storage management, the programmer
     realizes  that  123 only requires 9 bits.  This makes it possible
     to define MUMBLE so that only the left-most 9 bits  of  FLAG  are
     reserved for this use.  In this case, the definition might be:
     SS MUMBLE,<POINT 9,FLAG,8>,123,0
 3.  It would really be nice,  the  programmer  says  to  himself,  if
     MUMBLE  could  be  typed  more than once on the line, since it is
     such a common switch.  Since MUMBLE would never occur more than 5
     times on a line, the definition then might become:
     SS MUMBLE,<BYTE (6)0,60 (18)FLAG>,123,0 ;60= 65-5
 4.  In order to effectivly use MUMBLE, the INPUT switch must be  used
     to find the file for MUMBLE.  INPUT would probably be defined as:
     SP INPUT,SCNBLK,.FILIN##,INP,0
     DM(INP,10,0,0)
     Whenever /INPUT is seen, the file information is  stored  in  the
     SCAN  block starting at SCNBLK, and up to 10 words of information
     (value of MX.inp) will be stored there.
 5.  now that the program is almost complete, our programmer looks and
     sees that there is no hexidecimal input routine in scan!  this is
     simple to code, and to use it with a new switch called size:
     ss size,<byte(12)7777(6)0(18)hexinp>,0,0
     this causes scan to use the routine hexinp to get the value  from
     the command line.










                                 6-3






                              CHAPTER 7
                     DEFINING THE PROCESSOR FIELD

7.1  USAGE
7.2  PROCESSOR VS STORAGE(WITH 7777 IN B-PTR)
7.3  CODING SPECS
7.4  EXAMPLES WITHOUT ALSO USING STORAGE
7.5  EXAMPLES WITH THE USE OF STORAGE















                                 7-1






                              CHAPTER 8
                        DEFAULT VALUE HANDLING

8.1  INTRODUCTION
     In Chapter five ("THE 'DM' AND 'KEYS' macros"),  the  concept  of
specifying  default  values  for  the various switches was introduced.
this chapter will cover the topic in more detail.  both  scan-supplied
and user-supplied default values will be covered.

8.2  FILE SPEC DEFAULTS
     The "DM" macro gives the user the ability  to  specify  defaults,
but  the  user  program  must also do the enforcement of some of those
defaults.  This is especially true of default  values  used  when  the
switch  is  absent  on the command line:  SCAN will not go through the
tables DOSCAN produces to see what switches were not specified, to  be
able  to  apply  the  appropriate default values.  this entire area is
left to the user's program.

8.3  ABSENT DEFAULTS VS PRESENT DEFAULTS
     When the DM macro was introduced, the point  was  made  that  two
default  values  are  allowable.   one is the default value to be used
whenever the switch is absent from the command line (absent  default),
and  the  other  is  the  default  value to be used when the switch is
given, but without an explicit value (present default).  the arguments
given to DM are in the following format:





                                 8-1
DEFAULT VALUE HANDLING
ABSENT DEFAULTS VS PRESENT DEFAULTS

          dm    (abbrev,max,absent,present)
          where:
          abbrev is the 1-3 char name used
                  in the sl or sp macro
          max is the maximum value
          present is the present default
          absent is the absent default
          which generate the following symbols:
          MX.abbrev (maximum value)
          PD.abbrev (present default)
          ad.abbrev (absent default)

     the generated symbols  are  always  global,  and  dm  will  never
re-define  prior values.  in other words, one can manually give values
to some of the symbols to which DM normally assigns values, then  call
dm, without having the manually assigned values destroyed.
     scan will perform the following functions when it  is  processing
switches, or when it is applying default values (as in .aplst):
      o  range check values to be sure they are within 0<=MX.abbrev
      o  give PD.abbrev as the value when only /switch is seen on  the
         command line

     the generation of the ad.abbrev symbols by DM is solely  for  use
by the program which is using scan.  the text below outlines the steps
this support can take one of two forms:
      o  additional code to .aplst, so that all switches are defaulted
         whenever  file specifications are.  it is not clear that this
         is the way to go, since it is sometimes desirable to seperate
         the  handling  of file-spec and non-file-spec switches.  this
         is the reason, for the existence of the fs.nfs  (not  a  file
         switch) flag.
      o  the inclusion of an additional routine,  which  will  default
         the  user  switches.  this is the preferable method, since it
         does not impact the current operation of  scan.   if  support
         for  this  capability  should  be  diesired  on a more global
         basis, then a call to this routine could be placed in .filin.


                                 8-2
                                                DEFAULT VALUE HANDLING
                               IMPLEMENTING SUPPORT OF ABSENT DEFAULTS

8.4  IMPLEMENTING SUPPORT OF ABSENT DEFAULTS
     This support consists of  two  distinct  phases:   assembly  time
generation  of necessary table(s), and execution time code to scan the
SWTCHS  tables (as well as the added one(s)).  there is no  real  problem
or difficulty in either of these.

8.4.1  GENERATING TABLES AT COMPILE TIME
     This task will be performed immediately after the usual  call  to
DOSCAN,  and  will generate a table using the SWTCHS  macro.  one must be
careful to check to see if an absent default has indeed been given for
each  switch.   since the ad.abbrev symbols are not used for any other
purpose, the problem  of  determining  whether  or  not  a  switch  is
eligible  for  defaulting is conveniently avoided.  one possible macro
might be the following, which generates the table "xxxxxa":
          define dodflt(name),<
          define x(}name,}proc,}point,}deflt,}max,}flags),<
          ifndef ad.'}deflt,<
          z             ;}name - no absent default
          >
          ifdef ad.'}deflt,<
          xwd   400000,ad.'}deflt       ;}name
          >
          > ;end of dummy macro "x" for SWTCHS
          name'a::
          SWTCHS
          > ;end of dodflt macro

     the table "xxxxxa" is organized is such a manner  that  the  sign
bit  indicates whether or not an absent default is applicable for this
position's switch.  when the sign bit is on, the  right  half  of  the
same  word  is  the absent default.  if it is off, the rest of word is
ignored.  if desired,  the  right-half  micht  be  a  pointer  to  the
default;  this allows larger defaults (36 bits vs 18 bits).

8.4.2  EXECUTION TIME SUPPORT CODE
     The other task to be performed is  the  writing  of  code  to  be
called  at  about  the same time .APLST is called, but AFTER .OSDFS is
called to apply .OSCAN's default values.  The procedure to  follow  is
simple.  The following code gives a possible method.
                                 8-3
DEFAULT VALUE HANDLING
IMPLEMENTING SUPPORT OF ABSENT DEFAULTS

        .APLDF::HRLZI   T1,-xxxxxL
        LOOP:   SKIPL   T2,xxxxxA(T1)
                JRST    ENDLUP
                MOVE    T3,xxxxxP(T1)
        ;determine how to store value
        ;see the code around SWDPBE in SCAN
        ENDLUP: AOBJN   T1,LOOP
        ;here with all absent defaults applied

     As this example indicates, some thought needs to be given at  the
point  where  the  value in T2 is to be stored via the contents of T3.
T3 can take various forms, although it  is  usually  a  standard  byte
pointer.   The  principle exception in this context is when the switch
allows multiple arguments, and the STORAGE field in SWTCHS   is  used  to
specify  the  length  and  location  of the area in which to store the
values.  the other exception is the case where a full word  is  to  be
stored  for the value, in which case the left half of the "pointer" is
zero, and the right half is the location to store the value.
     as the example also indicated, the method for  properly  handling
this  is in scan, in the routine swdpbe, which is where all values for
switches are stored.  in this code, p2 is pointing to a 4  word  table
containing  the  addresses  of the tables produced by DOSCAN.  this is
done so that scan may use its own switch tables, as well as  those  of
the support program.  the offsets in this table are given the names:
          swn==0 (xxxxxn)
          swp==1 (xxxxxp)
          swm==2 (xxxxxm)
          swd==3 (xxxxxd)
p1 is used to index into the "xxxxx?" tables to access the entries for
the current command (ie:  xxxxxn(p1) is the SIXBIT name of the current
command, etc.).  knowing this, it is not difficult to follow the logic
of the code.

8.5  SUMMARY
     The purpose of this chapter is to provide information on handling
default values.  The defaults catagorized as "present defaults," which
are used whenever the switch is specified but its value  is  not,  are
already  handled  completely  by  SCAN.   The other catagory - "absent
defaults" - are not handled in any way  by  SCAN.   In  addition,  the
general method for implementing this in a user program was given.

                                 8-4






                              CHAPTER 9
                     FILE-SPECIFICATION SCANNING



 9.1  FILE-SPEC SCANNING
      An earlier  section  (The  Command  Scanners)  gave  a  detailed
 description of what a file-specification is.  What is of concern here
 is the use of .FILIN, the SCAN routine for inputting a file-spec.

 9.2  SCAN BLOCKS
 9.2.1  DEFINITION
      Crucial to this topic is  a  discussion  of  what  is  called  a
 "Scan-Block," which is SCAN's internal (mostly) representation of the
 information relevant to the file-spec which was scanned.  Appendix  D
 ("SCNMAC")  contains the exact definitions of the words and bits in a
 scan-block.  generally speaking, the information includes:
    o  device name.
    o  filename and its mask.
    o  extension and its mask.
    o  PPN and its mask, along with any path information.
    o  selection  criteria,  based  on  switches  encountered  (dates,
       times, etc.).
    o  indications of the various switches' presence or absence.
    o  syntax representations.





                                 9-1
FILE-SPECIFICATION SCANNING
Scan Blocks

 9.2.2  SCAN'S BUILT IN SWITCHES
      The switches referred to were  mentioned  earlier  as  "Internal
 SCAN  Switches."  These  are  mostly  used  to specify file selection
 criteria, especially for use by WILD (see  Appendix  B).   The  exact
 definitions  are  included  in  Appendix  E as one of the examples of
 Switch definitions.  Summarized, they are:

 /ABEFORE
 /ASINCE       - specify access-date-time criteria
 /BEFORE
 /SINCE        - specify creation-date-time criteria
 /ERNONE
 /OKNONE       - specify if no file-match is an error
 /ERPROTECTION
 /OKPROTECTION - specify if access-protection failure is an error
 /ERSUPERSEDE
 /OKSUPERSEDE  - specify if it is an error to  overwrite  an  existing
                 file
 /ESTIMATE     - specify an estimated file size
 /EXIT         - go to monitor
 /HELP         - type a help message /NOOPTION     -
 /OPTION       - control the use of options file (see "OSCAN")
 /PHYSICAL     - set the "physical only" bit on all OPENs.
 /PROTECTION   - specify the protection of a file
 /VERSION      - specify the version number of a file
 /RUN          -
 /RUNCORE      -
 /RUNOFFSET    - control the running of a new program when ".RUNCM" is
                 called  (see  "Routine Call Definitions" & "Using the
                 Miscellaneous Routines").

 9.2.3  SYNTAX REPRESENTATIONS
      "Syntax Representations" refer to bits, used primarily by  WILD,
 indicating  what  special constructs were seen.  These are made up of
 usages of what SCAN  terms  "Guide  Words,"  which  are  in  a  sense
 pseudo-characters.  The legal Guide Words, and their pseudo-character
 values, are:
            'AND'  4000     'INPUT'  4005
            'OR'   4001     'OUTPUT' 4006
            'NOT'  4002     'SOURCE' 4007
            'FROM' 4004     'LIST'   4010
            'TO'   4003     'OBJECT' 4011


                                 9-2
                                           FILE-SPECIFICATION SCANNING
                                        Built-in Switches; Guide Words

 These are used to express inter-filename relationships in  a  command
 string,  along  with  the  concatenation  operator  -- the plus sign.
 Refer to "INPUT ROUTINES -  CHARACTER"  in  Chapter  2,  and  to  the
 Appendix covering "SCNMAC."

 9.2.4  SCAN BLOCKS: SUMMARY
      So much for Scan-Blocks.  It is important to realize  that  they
 exist,  especially  if  any  of the switches listed are of use to the
 program, or if the user is  interfacing  with  WILD  (which  requires
 Scan-Blocks   for   input).    The   .stopb   routine  (see  "routine
 definitions")  is  used  to  convert  these  blocks   to   open   and
 LOOKUP/ENTER blocks.


 9.3  F.ZER & P.ZER
      The Scan-Block used by SCAN is  located  at  the  global  symbol
 "F.ZER", and extends to "F.EZER".  associated with this is a "default
 region," into which the user  places  his  default  values,  if  any,
 before  calling  scan.   this  area  goes  from P.ZER to P.EZER.  the
 definitions of the offsets into those blocks are in SCNMAC, a listing
 of  which is included in the appendices.  these symbols have names of
 the format ".fx???".  this area  should  be  zeroed  if  no  defaults
 exist.   to  have any defaults applied (after scan has returned), one
 issues the call:
      pushj p,.aplst##
 to apply what scan calls "sticky defaults." this is  covered  further
 in an earlier chapter, "default value handling."
      once the scan  block  at  F.ZER  has  had  the  user's  defaults
 applied,  then  it  remains  to:  1) apply scan's defaults, and 2) to
 move it to the user's area.  this is done in the following manner:
      movei t1, address ;user's scan-block address
      movei t2, length ;length of same
      pushj p,.gtspc##

 after this, the area of F.ZER can then be reused for more file-specs.



                                 9-3
FILE-SPECIFICATION SCANNING
F.ZER & P.ZER

 9.3.1  LAYOUT OF SCAN BLOCK
     ======================================================= F.ZER/P.ZER
     |.FXDEV= 0          SIXBIT DEVICE NAME                |
     =======================================================
     |.FXNAM= 1          SIXBIT FILE NAME                  |
     =======================================================
     |.FXNMM= 2          FILE NAME MASK                    |
     =======================================================
     |.FXEXT= 3          LH=EXT MASK   RH=SIXBIT EXTENSION |
     =======================================================
     |.FXMOD= 4          MODIFIER WORD                     |
     =======================================================
     |.FXMOM= 5          MASK FOR MODIFIER WORD            |
     =======================================================
     |.FXDIR= 6          FIRST DIRECTORY WORD              |
     =======================================================
     |.FXDIM= 7          MASK FOR FIRST DIRECTORY WORD     |
     Z=====================================================Z
     Z   the following words follow the same pattern:      Z
     Z   the first word of each pair is the directory info,Z
     Z   the second word of each pair is it's mask         Z
     Z=====================================================Z
     |.FXBFR=22          /BEFORE VALUE                     |
     =======================================================
     |.FXSNC=23          /SINCE VALUE                      |
     =======================================================
     |.FXABF=24          /ABEFORE VALUE                    |
     =======================================================
     |.FXASN=25          /ASINCE VALUE                     |
     =======================================================
     |.FXFLI=26          FILE MIN SIZE IN WORDS            |
     =======================================================
     |.FXFLM=27          FILE MAX SIZE IN WORDS            |
     =======================================================
     |.FXEST=30          /EXTIMATE VALUE                   |
     =======================================================
     |.FXVER=31          /VERSION VALUE                    |
     ======================================================= F.EZER/P.EZER

 9.4  ^.STOPB
      Once  the  scan  blocks  were  created  by  SCAN,  and  possibly
 processed  by  WILD  (to  expand  wild card expressions), the problem
 remains of doing something  with  them.   The  TOPS-10  monitor  will
 certainly  not accept them to specify file operations.  What needs to
 be done is to convert  from  the  SCAN  block  format  needed  during
 scanning,  to  the standard OPEN and LOOKUP/ENTER block format needed
 during processing.  the routine which performs this task is  ".stopb"                                                               .stopb                                                               .stopb
 (scan to open lookup block).  the call on .stopb is of the format:  s    t  op          b  s    t  op          b
                                 9-4
                                           FILE-SPECIFICATION SCANNING
                                                               ^.STOPB

           t1/  scan-block-len,,scan-block-address
           t2/               0,,open-block-address
           t3/ lookup-block-len,,lookup-block-address
           t4/               0,,path-block-address (9 words)
           pushj  p,.stopb##
                   -error- (wildcards not yet resolved)
                   -ok- scan block is translated

 9.5  USING .FILIN
      Now that all else has been taken care of, the actual scanning of
 file-specifications  is  simple  to explain.  The routine responsible
 for this is .FILIN, which is called in the following manner:
      PUSHJ P,.FILIN##
 and returns with T1 containing:
       0 if null expression
      -1 if file spec typed
       1 if only switches seen
           At this point, the SCAN block at F.ZER has the  information
      from the scanned command line in it.

 9.6  SUMMARY OF FILE SPEC SCANNING
      Summarizing the file-spec scanning process, we  have  seen  that
 the following sequence is the general method used:
    o  Setup defaults in P.ZER area
    o  call .filin
    o  call .aplst
    o  call .gtspc
    o  call wild
    o  call .stopb
    o  process LOOKUP/ENTER and open blocks





                                 9-5






                              CHAPTER 10
                   .ISCAN - SCANNER INITIALIZAITON



 10.1  ISCAN - SCANNER INITIALIZATION
      Before calling  one  of  the  command  scanners  (or  any  input
 routine),  it is necessary to give SCAN a set of parameters and other
 information describing how the user intends to go about doing things.
 In  "ROUTINE CALL DEFINITIONS" a skeleton format of an ISCAN call was
 given, which is sufficient for a job interested in doing only  simple
 TTCALL I/O, without any frills.  Here will be described in detail all
 of the various options available via ISCAN.

 10.2  INITIALIZATION CONCERNS
      A number of procedures are followed by SCAN during its  internal
 initialization, via ISCAN.  These tend to revolve around the one-time
 setting up of storage, for later use.  The specific functions,  which
 are   covered   in  detail  in  the  following  paragraphs,  include:
 Rescanning the command line which initiated the  program  being  run,
 determining  how  the  program  was entered (CCL vs normal), what I/O
 routines to use, what indirect files (if any) to use, etc.   Usually,
 many  of  these  are  not of great concern, and are either omitted or
 defaulted to.

 10.3  RESCANNING THE COMMAND LINE
      While ISCAN is not a scanner, it will sometimes process part  of
 the command line.  This occurs for programs which accept input on the
 same line as the monitor line which activated them.  In these  cases,
 ISCAN  is  given  a  list of the valid monitor level commands to look
 for.  It then RESCANS the  command  line,  and  positions  the  input
 routines to the end of that command.  On return, T1 indicates whether
 a command was actually seen or not (see call description below).   If
 no table of commands is supplied, ISCAN will not do a RESCAN.
                                 10-1
.ISCAN - SCANNER INITIALIZAITON
RESCANNING THE COMMAND LINE

      One of the more common usages of this feature is in the  writing
 of  a  program which is to be invoked by a spsecific monitor command.
 When commands are added to the monitor, in the module  COMCON,  their
 dispatch  address  in COMTAB can be to a routine which runs a program
 of the same name,, but starts it at the  CCL  entry  point  (see  the
 following  paragraphs).   This makes it possible for a program MUMBLE
 to be invoked by commands of the format:
           .MUMBLE /switch:value /switch:value ...
 In this case, .ISCAN would be told  to  perform  the  rescan  of  the
 command  line, in order to pick up the switches.  This is the process
 used by programs such as DIRECT.

 10.4  CCL mode
      When a program is in what is usually termed "CCL mode,"  it  was
 started  with  an offset other than 0 added to its start address.  In
 these cases, input usually comes to SCAN from a "CCL file."  In  this
 case,  ISCAN  must  be told:  1) the 3-character CCL name, and 2) the
 value of the starting offset.  if not in  CCL  mode,  then  iscan  is
 given a zero word.  this feature is most useful for programs (such as
 direct) which can be monitor commands.

 10.5  I/O ROUTINES
      As was stated in the Introduction, SCAN defaults to TTCALL input
 and   output.   If  the  user  wishes,  the  address(es)  of  special
 routine(s) for input or output may be given to SCAN.  Input  routines
 must  leave  their character in P4;  output routines take theirs from
 T1.  Neither may destroy any other accumulators.
      If the program knows ahead of time that indirect file input will
 be  used,  and  the  name  of the file, then a Scan-Block form of the
 specification is passed to ISCAN.  The .FXDEV word must  be  non-zero
 for ISCAN to honor it.

 10.6  PROGRAM TERMINATION
      Sometimes, it is useful for a program to always be given control
 whenever SCAN would otherwise return to the monitor.  In these cases,
 a "MONRET" ("MONitor RETurn") address is  given  to  ISCAN.   In  the
 absence of this, SCAN will simply issue an EXIT UUO.


                                 10-2
                                       .ISCAN - SCANNER INITIALIZAITON
                                                     COMMAND PROMPTING

 10.7  COMMAND PROMPTING
      Along the same lines, some programs  have  their  own  prompting
 schemes,  and  must  supply ISCAN with the appropriate address, which
 will later be PUSHJed to.  When it is called, T1 will be  set  up  as
 follows:
      (RH) the normal prompt character:
            "*" for first lines
            "#" for continuation lines
      (LH) 0 for first lines;
            -1 for continuation lines
 A "continuation line" is one following a  line  which  ended  with  a
 dash, which is SCAN's continuation character.

 10.8  FLAGS
      This word specifies any special handling required.  The possible
 flags  are described below, and are also listed in the appendices for
 SCNMAC and $scndc.
      fs.icl - if set, whis will cause scan to "ignore  command  line"
 handling.   in  other  words,  if the command line is not in a format
 scan understands (such as login), but scan is used to handle parts of
 it, the setting of this bit causes scan to ignore the fact that it is
 actually a command line.  the rescan will still be done, however.


 10.9  CALLING .ISCAN
      This brings us now to an exact description,  which  should  make
 sense  in the light of the preceeding paragraphs.  The calling format
 for .ISCAN is:







                                 10-3
.ISCAN - SCANNER INITIALIZAITON
Argument Block Definition

      MOVE  T1, [length,,argblock-address].
      PUSHJ P, .ISCAN##
        -return-
      T1 = index into table of monitor
      commands, or -1 if none found

 The argument block at "argblock-address" has the following format:

   BLOCK:
   BLOCK + 0 = 0 or IOWD length, monitor-commands
         + 1 = (RH) 0 or address of starting offset
               (LH) 0 or SIXBIT CCL name
         + 2 = (rh) 0 or address of output routine
               (lh) 0 or address of input routine
         + 3 =       0 or xwd length, indirect-scan-block
         + 4 = (rh) 0 or address of monret routine
               (lh) 0 or address of prompt routine
         + 5 =      flags
 length==.-block















                                 10-4






                              CHAPTER 11
                   .TSCAN - the traditional scanner



 11.1  .TSCAN - the traditional scanner
      The most common command formats are those with:  1)  one  output
 file-spec;   2) either one or more input-specs, or else no input spec
 at all;  and 3) command switches somewhere on the line.  This is  the
 type  of  command  line which TSCAN processes.  as well as needing to
 know where DOSCAN's tables are, a few other issues come into play.

 11.2  /HELP
      One of  the  built-in  "Internal  Switches"  listed  above  (see
 "File-Spec  Scanning")  was  /HELP.  It now becomes necessary to tell
 SCAN how to find the "HELP file" to be typed.  Four types of help are
 possible.
    o  None
    o  Type a preset string
    o  Call a prenamed routine
    o  Call HELPER
 It is necessary for the caller to tell TSCAN which of  the  above  to
 use.

 11.3  POST PROCESSING OF SWITCHES
      As a command line is processed, it is often  desirable  for  the
 user  to be given a chance to clear out various storage areas, before
 a new command line is processed.  This is accomplished by passing  to
 TSCAN the address of a routine to pushj to at the end of each line.

                                 11-1
.TSCAN - the traditional scanner
POST PROCESSING OF SWITCHES

      along the same lines, there is often data to be cleared or reset
 as  each  file-spec is processed.  scan will zero its F.ZER area, but
 the user may have other locations to worry about.  it may  also  want
 to  change the P.ZER default area.  to do so, the user provides TSCAN
 with an address to pushj to.

 11.4  SCAN BLOCK ALLOCATION
      In the chapter on "FILE-SPEC SCANNING," it  was  indicated  that
 SCAN assembles its data within its own core (F.ZER) since the command
 line may very well contain many file-specs.   this  means  that  some
 method  must  exist  for  moving  the  scan-blocks to a "safer" area.
 since the input and output streams may  require  different  handling,
 the user provides TSCAN with the addresses of two routines which will
 allocate space for a scan-block.  these routines return the following
 information to scan:
      t1 = address of scan-block area
      t2 = length of scan-block area

      the P.ZER area, as was mentioned earlier, contains  the  default
 file-spec  values.   often, information in one file-spec on a command
 line is the default for a later file-spec on that line.   because  of
 this,  scan  will  "memorize"  this  information by copying the F.ZER
 information into the P.ZER area.  if  the  user  would  like  control
 after  this  is done, an address to be pushjed to is passed to TSCAN.
 also, whenever scan applies the P.ZER defaults, the user may want  to
 be  called.   this  is  also  done  by giving TSCAN the address to be
 pushjed to.  finally, as the scan of a line is commenced,  the  P.ZER
 area  is cleared.  the user will then be called, if it had previously
 given TSCAN such an address.

 11.5  STICKY DEFAULTS
      A "sticky" default is what SCAN terms general  globals  defaults
 for  file  specifications.   These are applied by SCAN when .APLST is
 called.  When .TSCAN is called, the user has the option of specifying
 a  special  routine  to  call  whenever scan is going to apply sticky
 defaults.  the left half of word number 6 contains the  addresses  of
 the  routine  to  memorize  sticky  defaults  for  all files, and the
 address of the routine to apply these defaults to all succeeding file
 specifications:
           xwd  memorize-address, apply-defaults-address
 the other routine which may be specified it the routine to clear  any
 sticky defaults at the end of a file-spec scan.  this is given in the
 left half of word number 7:
                                 11-2
                                      .TSCAN - the traditional scanner
                                                       STICKY DEFAULTS

           xwd  clear-default-address, flags
 if the user program has not sticky switches of its  own,  then  these
 fields  should  be  left zero.  otherwise, whenever scan does its own
 sticky default handling, it will also can on the  user's  routine  to
 process the user's sticky defaults at the same time.

 11.6  SCAN CONTROLLING FLAGS
      Although there is normally only one output file-spec,  sometimes
 multiple  output  specs  are quite valid.  Also, many programs do not
 care if a switch  associated  with  one  side  of  the  "="  actually
 appeared  on  the  other  side.   To  allow either (or both) of these
 special cases, flags are passed to TSCAN which control  the  scanning
 process.  these flags are also listed in appendix d ("SCNMAC"):
      fs.mot - multiple output file specifications allowed.
      fs.mio - input and output specifications may  be  mixed  on  the
               command   line,   regardless   of  their  relationships
               position-wise to the "=" character.


 11.7  SWITCH PROCESSING
      Finally, it is sometimes the case that  the  user  wants  to  be
 called  whenever a switch value is to be stored, no matter how it was
 defined in SWTCHS.  to do this, TSCAN is pointed at the  routine  to  do
 this.  when this routine is called, the following are set up:
          t1 = switch-value
          t2 = pointer into switch tables
 the routine, after doing what it may, non-skip returns if scan should
 not  store  the  value,  or skip-returns if scan should store it.  in
 either case, all accumulators are to be left intact.







                                 11-3
.TSCAN - the traditional scanner
CALLING .TSCAN

 11.8  CALLING .TSCAN
      To call TSCAN, one first  sets  up  an  argument  block  of  the
 following form:

    block + 0 = iowd xxxxxl, xxxxxn
          + 1 = xwd xxxxxd, xxxxxm
          + 2 = xwd 0, xxxxxp
          + 3 = xwd help-type, help-address
                ;  help-type = 0 if none
                ;  = 1 if string
                ;  = 2 if subroutine
                ;if word = -1, use name in
                ;system table, and call helper
                ;if (lh) is greater than 77,
                ;but word is not -1, then word
                ;is the SIXBIT name to give helper.
          + 4 = (lh) 0 or routine to clear all answers
                (rh) 0 or routine to clear file answers
          + 5 = (lh) routine to allocate input file area
                (rh) routine to allocate output file area
          + 6 = (lh) 0 or routine to memorize defaults
                (rh) 0 or routine to apply defaults
          + 7 = (lh) 0 or routine to clear defaults
                (rh) flags:
                1b18 multiple output specs are legal
                1b19 switches may go anywhere on the line
         + 10 = (lh) 0 (reserved for future)
                (rh) 0 or routine to store switch values

 when "0" is given as an argument, then that option will not be  used.
 the "xxxxx" fields are from the DOSCAN argument.  to call TSCAN:
      move t1, [length,, block]
      pushj p, .TSCAN##
         -return- at end of line after
                  something was typed


 11.9  STORAGE INITIALIZATION
      When TSCAN returns, all of the switches and file-specs have been
 processed, and all values stored.  all switch value cells should have
 an initial value of -1.  this is because scan will detect attempts to
 give  a  switch  more than one value on the same line.  unless a user
 routine intervened, the first value would be lost.  if the user wants
 this  -- multiple values -- then the switch must have a routine to do
                                 11-4
                                      .TSCAN - the traditional scanner
                                                STORAGE INITIALIZATION

 the storing itself.  in any event,  -1  was  chosen  as  an  unlikely
 switch value, and therefore a reasonable initial value.
 n.b.:  read appendix "a" ("notes on using scan")

 11.10  SUMMARY
      This chapter has presented the use of  SCAN's  most  often  used
 scanner - .TSCAN.  much of what has been covered is relevant not only
 to .TSCAN, however, but also to the other scanners being discussed in
 the following chapters.




















                                 11-5






                              CHAPTER 12
                   OSCAN - THE OPTIONS FILE SCANNER


 12.1  OSCAN - THE OPTIONS FILE SCANNER

      It is often the case that a particular application has a set  of
 defaults that change somewhat from user to user.  In this case, it is
 not possible to define the defaults via DM, since each user  has  his
 own,  but  they  all  run  the  same  program.   A  solution which is
 particularly useful is called an "Options File."  This  is  a  single
 file,  under  the  user's  PPN,  which  contains  the  default switch
 settings for that user.  since this is feasible  for  many  programs,
 all use the same file, but preface their particular lines of defaults
 with their names.  finally, it is possible for one  program  to  have
 multiple, named, sets of defaults.


 12.2  FORMAT OF THE OPTIONS FILE
      This "Options File" is the file DSK:SWITCH.INI,  on  the  user's
 PPN.  entries in switch.ini are of the form:
         program /switch/switch...
            or
         program:option /switch/switch
         where:
         program is the program name.
         option is the name of the set of defaults.  this used as
                 the value to the /option:  switch in the command
                 line.
         /switch are the switches and their values.
 only switches are valid in the options file -- file-specs cannot
 be included.
                                 12-1
OSCAN - THE OPTIONS FILE SCANNER
FORMAT OF THE OPTIONS FILE

 12.2.1  Options List
      Only one calling parameter for OSCAN has not  been  covered
 already  under "TSCAN" -- the name(s) of options to select.  the
 program passes to oscan:  1) the pointer to a list of options to
 be selected, or 2) the name to be selected, or 3) 0 to imply the
 use of the program's name as the object of the selection.


 12.2.2  Argument Block
 The argument block for OSCAN closely resembles that for TSCAN:

    block + 0 = iowd xxxxxl, xxxxxn
          + 1 = xwd xxxxxd, xxxxxm
          + 2 = xwd 0, xxxxxp
          + 3 = help word
          + 4 = options word:
                SIXBIT/name/    or
                z               or
                xwd   len,  list
    length==.-block

                if block+4 references an options list, its format
                is:

    list:  SIXBIT/opt1/
           SIXBIT/opt2/
              .
              .
              .
           SIXBIT/optn/
    len==.-list



 12.2.3  CALLING .OSCAN
      To call OSCAN:
      MOVE T1, [LENGTH,,BLOCK]
      PUSHJ P, .OSCAN##

                                 12-2
                                      OSCAN - THE OPTIONS FILE SCANNER
                                          APPLYING DEFAULTS FOR .OSCAN

 12.3  APPLYING DEFAULTS FOR .OSCAN
      After OSCAN returns, it is usually necessary  to  have  the
 switches  applied  to  any  file-specs which were scanned off by
 TSCAN (or vscan).  this is  the  purpose  of  .osdfs,  which  is
 called in the following manner:
      movei t1, location of scan-block
      movei t2, length of scan-block
      pushj p, .osdfs##
 once this has been done for any or all file-specs  desired,  the
 scanning process is complete.




















                                 12-3






                              CHAPTER 13
                    .vscan - the verb form scanner



 13.1  vscan - the verb form scanner


      In some applications, it is desirable to have all command  lines
 begin with a keyword which indicates some function or operation to be
 performed.  This is then followed  on  succeeding  lines  by  related
 commands and file-specs.  In this case, the function-word is referred
 to as a "verb," and the associated scanner is therefore a "verb  form
 scanner," or ".vscan."
      normally, when vscan is  used,  the  user  enters  his  switches
 one-per-line.   although  scan views these as switches no differently
 than it does with TSCAN, it appears to the user that he  is  actually
 inputting  commands;   this  is  especially  true  since  it  is  not
 necessary with vscan to include the slash that normally  indicates  a
 switch.   in  some  applications, this lends itself very well to user
 oriented dialogues.  while it  would  be  possible  for  switches  to
 appear  on  the  line with the "verbs," this would tend to contradict
 the philosophy behind using vscan in the first place.

 13.2  USING .vscan
      From the programmer's point of view, there is really nothing new
 for vscan that was not also necessary for TSCAN.

      the only new calling  values  in  the  argument  block  are  the
 addresses  and  lengths of the default and permanent switch areas for
 file-specs (a la P.ZER and F.ZER, respectively).

                                 13-1
.vscan - the verb form scanner
USING .vscan

 13.2.1  Argument Block Format
      The exact argument block format for vscan is:
 block + 0 = iowd xxxxxl, xxxxxn
       + 1 = xwd xxxxxd, xxxxxm
       + 2 = xwd 0, xxxxxp
       + 3 = help word
       + 4 = (lh) length of file-spec areas
             (rh) address of permanent area
       + 5 = (lh) 0 (reserved for future)
             (rh) address of default area
       + 6 = option name, or 0 (to use program name)
 length==.-block


 13.2.2  CALLING .vscan
      The vscan call is:
      move t1, [length,,block]
      pushj p, .vscan##














                                 13-2






                              CHAPTER 14
                     .PSCAN - THE PARTIAL SCANNER



14.1  PSCAN & QSCAN - INTRODUCTION
     One of the drawbacks, in some  applications,  of  having  an  all
purpose  scanner  such  as  TSCAN  is  that  it  does  not  allow  any
flexability in the format of the command  lines.   all  commands  must
conform to the sytax used by scan.  usually, this presents no problem,
since scan's syntax is in itself quite flexable.  however, when it  is
necessary  for  the format of a command line to be somewhat different,
then another scanner is required.  this is the usefulness  of  the  so
called   "partial  scanner."  this  scanner  tends  to  operate  as  a
co-operative effort between the user program and scan.   part  of  the
command  line  is  processed  by  the  program,  and  the remainder is
processed by .pscan or .qscan.
     the process is simple.  either .pscan  or  .qscan  is  called  to
initialize  the  scanning process, then the user program processes the
command line to whatever extent it desires.
     the routine which is normally called to handle scan's side of the
command  line  handling  is  ".filin",  which  will  pick  up any file
specifications, as well as  whatever  switches  it  encounters.   this
makes for a relatively simple scanning process:
      o  call .iscan to initialize everything
      o  call .pscan to initialize for partial scanning (or .qscan)
      o  call whatever input routines are appropriate for  the  user's
         portion of the command line (.swdec, .swsix, etc.).
      o  call .filin to handle the rest of the command line
      o  process the scan-blocks, if  any,  which  were  generated  by
         .filin.

                                 14-1
.PSCAN - THE PARTIAL SCANNER
PSCAN & QSCAN - INTRODUCTION

      o  process the data returned by  the  switches  scanned  off  by
         .filin


14.2  PSCAN/QSCAN ARGUMENT BLOCK FORMAT
     The argument block used by both PSCAN and  QSCAN  is  similar  to
that of the other scanners:
     BLOCK + 0: IOWD    xxxxxL,xxxxxN
     BLOCK + 1: XWD     xxxxxD,xxxxxM
     BLOCK + 2: XWD          0,xxxxxP
     BLOCK + 3: HELP WORD
     LENGTH==.-BLOCK

 14.3  PSCAN/QSCAN CALLING FORMAT
      To call either of these routines:
      MOVE T1,[LENGTH,BLOCK]
      PUSHJ P,.PSCAN##  /   .qscan##


 14.4  PSCAN VS QSCAN
      Throughout  the  discussion  so  far,  two  routines  have  been
 referred  to  as  the  partial  scanners  --  .PSCAN & .qscan.  these
 operate in identical fashions, so far as  use  within  a  program  is
 concerned.   their  only difference lies in their scope.  .pscan sets
 up partial scanning on a global basis, which affects all input lines.
 .qscan, on the other hand, affects only the current line.  other than
 this, they are used identically.

 14.5  SUMMARY
      The purpose of this chapter has been to introduce the concept of
 a  partial  scanner,  which  is  sometimes  very  well  suited  for a
 particular application.  In addition, instruction on  using  the  two
 routines supplied by SCAN -- .PSCAN and .qscan -- to handle this type
 of scanning has been given.  an  excellant  example  on  the  use  of
 partial scanners is the digital cusp CREDIR.  a part of this program,
 in fact, is included in  a  later  chapter  as  a  guide  in  writing
 programs which interface with scan.

                                 14-2






                              CHAPTER 15
                            ACCESSING SCAN



 15.1  ACCESSING SCAN
 15.1.1  ASSEMBLY TIME FILES
      All of the MACROS, symbols and routine names referenced in  this
 document  are a part of SCAN and its associated files.  The following
 files are those used in the SCAN "system."
  o  UUOSYM.UNV
     MACTEN.UNV
     These define  symbols  used  in  the  DEC  reference  manuals  to
     describe uuos and their calling formats.  also defined are useful
     macros, such as:  POINTR, txxx, movx, etc.
     these are accessed by the macro-10 statement:
               search uuosym,macten
  o  SCNMAC.unv
     $scndc.unv
     these files define macros and symbol definitions for  scan.   sl,
     sn, sp, ss, dm, KEYS, DOSCAN, etc, are all defined here
     SCNMAC and $scndc are accessed by the macro-10 statement:
               search SCNMAC,$scndc




                                 15-1
ACCESSING SCAN
ACCESSING SCAN

 15.1.2  LINK-TIME FILES

  o  SCAN.REL
     This  is  SCAN  itself.   Contains  all  code  described  herein,
     including  $SCNDC.   SCAN.REL  should  not  be  loaded in library
     search mode, as it contains no SEARCH pseudo-ops.

  o  
     This is a module for the /HELP switch, and is loaded as any other
     file.
  o  WILD.REL
     ths is a module containing the code to support  wild  carding  of
     file   names,   extensions,  etc.   it  makes  the  searching  of
     directories  relatively  painless  for   the   support   program.
     included  in  it  are  a  number  of routines for typing standard
     LOOKUP/ENTER/rename error messages.


 15.1.3  SOURCE FILES
      Sources to SCAN, SCNMAC, helper, macten and uuosym are currently
 distributed on the cusp release tapes as:
            scan.mac
            SCNMAC.mac
            helper.mac
            macten.mac
            uuosym.mac
            wild.mac
 parts of $scndc and SCNMAC have been included as appendices d  and  e
 respectively.
      the universal (.unv) files for SCNMAC, $SCNDC, MACTEN and UUOSYM
 are  normally  kept on ersatz device "UNV:." the .REL files for SCAN,
 WILD, and HELPER are usually on device "REL:."




                                 15-2
                                                        ACCESSING SCAN
                                                        ACCESSING SCAN

 15.1.4  SUMMARY
      In summary, the following would normally be seen at the start of
 a program using SCAN:
        SEARCH COLS,C,SCNMAC,$scndc
        .require rel:scan
        .require rel:wild
        .require rel:helper

 15.2  SEGMENT ALLOCATION
      All of the code in SCAN is high segment;  no .LOW file  will  be
 generated unless the user's program needs one.
      Since SCAN contains no  PORTAL  instructions  at  its  routine's
 entry  points,  programs  using  scan  should  not  be  protected  as
 execute-only (<166>).
















                                 15-3






                              CHAPTER 16
                        EXAMPLES OF USING SCAN


16.1  INTRODUCTION
     This chapter will present two complete examples of using SCAN for
command  scanning.   It  will  use  much  of the material presented in
previous chapters.  The basic purpose in this is to unite the concepts
and routine descriptions presented into a cohesive structure.
     The first example chosen is from CREDIR, a digital cusp  used  to
create  directories  on  tops-10  systems.   the scanners used are the
partial mode scanners, .pscan & .qscan.
     a second example, from a private program, will present a  use  of
.TSCAN,  which  is  by  far  the  most  popular scanner.  by examining
closely both examples, the reader should gain a detailed understanding
of the use of scan.











                                 16-1
EXAMPLES OF USING SCAN
example:  CREDIR (.pscan/.oscan)

title   CREDIR -- routine to create a directory  %2(103)
        search  c,SCNMAC        ;set for universals
        subttl  initialization
CREDIR: tdza    t1,t1           ;not CCL start
        movei   t1,1            ;ccl start
        movem   t1,offset       ;store it
        reset                   ;reset any external i/o
;next go initialize the command scanner.  in
;particular, look for a command on the same line or a ccl
;file full of commands.
        move    t1,[ 2,,[iowd  1,['CREDIR']
                        offset,,'crr']]
        pushj   p,.iscan##      ;initialize command scanner

        subttl  main loop
;each pass, whether successful or not, always
;ends by returning to the label mainlp.  this causes the
;program to start over again.  it can be exited by the
;user by either a ^c or a ^z.  if the program had been
;invoked by  a command or CCL call, then scan will
;simulate the ^z when appropriate to exit.
mainlp: pushj   p,.runcm##      ;handle /run if set
        move    t1,[ 4,,[iowd swtl,swtn
                         swtd,,swtm
                         0,,swtp
                         -1     ]]
        pushj   p,.pscan##      ;invoke p-mode scanner
          outstr [asciz \create directory: \]
        camg    p4,[.cheof]     ;see if eof
        jrst    [pushj p,.aldon##  ;yes--handle normal cases
                 camg  p4,[.cheof] ;then check again
                 pushj p,.mnret##  ;yes--return to monitor
                 jrst  mainlp]  ;then start over again





                                 16-2
                                                EXAMPLES OF USING SCAN
                                      example:  CREDIR (.pscan/.oscan)

;having initialized the command scan for this line,
;now get a file specification, which must include
;the structure and directory and exclude the file name and
;extension.
        pushj   p,.filin##      ;get file spec
        jumpn   t1,getopt       ;jump if something input
;here if nothing typed before the separator.  the only
;legal cases are /run and indirect.
        cain    p4,"@"          ;see if indirect
        pushj   p,.gtind##      ;yes--setup indirect
        jumple  p4,mainlp       ;if end of line, go do more
        pjrst   e.ilsc##        ;otherwise, give error
;now check option file to see if any default switches.
getopt: jumpg   p4,e.incl##     ;error if more on line
        movei   t1,spec         ;point to spec area
        movei   t2,.fxlen       ; ..
        pushj   p,.gtspc##      ;copy to us
        move    t1,[ 4,,[iowd swtl,swtn
                         swtd,,swtm
                         0,,swtp
                         -1     ]]
        pushj   p,.oscan##      ;handle option file
        jrst    gotsom          ;then proceed












                                 16-3
EXAMPLES OF USING SCAN
example:  CREDIR (.pscan/.oscan)

;define switch table
define  SWTCHS,<
sp in,qtain,.swdec##,qta,fs.lrg
sp name,splnam,sixqww,nul,
sp out,qtaout,.swdec##,qta,fs.lrg
>
dm nul,1,0,0
dm qta,.infin,.infin,.infin
        DOSCAN  (swt)

;routine to input one word in SIXBIT possibly quoted
sixqww: pushj   p,.sixqw##      ;get string
        move    p3,.nmul##      ;get first word
        popj    p,              ;return result

gotsom: skipe   t1,fldial       ;see if dialog
        skipl   spec+.fxmod     ;see if device this time
        skipa                   ;ok--do nothing
        movem   t1,spec+.fxdev  ;lazy--default his device
;fall into other code not of interest in
;this example case.












                                 16-4
                                                EXAMPLES OF USING SCAN
                                      example:  CREDIR (.pscan/.oscan)

gotdir: movx    t1,fx.pro       ;get protection mask
        tdnn    t1,spec+.fxmom  ;see if user set it
        skipn   fldial          ;or not in dialog
        jrst    gotdr1          ;all ok--proceed
        move    t1,[ 4,,[0
                         0
                         0
                         -1     ]]
        pushj   p,.qscan##      ;invoke p-mode scanner
          outstr [asciz \protection: \]
        pushj   p,.octnw##      ;get octal value
        dpb     p3,[POINTR (spec+.fxmod,fx.pro)]
        jumpg   p4,e.incl##     ;error if more on line
gotdr1: skipge  splnam          ;see if /name
        skipn   fldial          ;no--see if dialogue
        jrst    gotdr2          ;yes--proceed
        move    t1,[ 4,,[0
                         0
                         0
                         -1     ]]
        pushj   p,.qscan##      ;invoke p-mode scanner
          outstr [asciz \name: \]
        pushj   p,sixqww        ;get SIXBIT name
        jumpg   p4,e.incl##     ;error if that's not all
        movem   p3,splnam       ;set name
gotdr2: movs    t2,spec+.fxext  ;get extension
        tlc     t1,-1           ;mask should be -1
        caie    t1,'ufd'        ;see if ufd
        cain    t1,'sfd'        ; or sfd
        setzb   t1,spec+.fxext  ;yes--clear out
        skipn   spec+.fxnam     ;see if file name
        skipe   spec+.fxext     ; or extension
        jrst    e$$fni          ;yes--file name illegal
        movei   t1,spec         ;point to scanned spec
        movei   t2,opnblk       ;point to an open block
        movei   t3,entblk       ;point to an enter block
        pushj   p,.stopn##      ;convert scan's spec
          jrst  e$$wci          ;wild cards are illegal
        jrst    devok           ;proceed
;fall into code which does actual processing of directories,
;etc., which is of no concern here as a scan example.



                                 16-5
EXAMPLES OF USING SCAN
TSCAN example

     the next example, of the use of TSCAN, is from a program  written
to  count  the  number  of  pages  (form-feeds) in an arbitrary set of
files.  no switches are used, but a dummy SWTCHS  definition is  used  to
keep  TSCAN  happy.   the  inclusion  of  additional switches would be
trivial.  the important parts to watch are the interfacing with TSCAN,
and  the  processing  of  the  scan  blocks.   the  actual  use of the
converted open and LOOKUP/ENTER blocks is left out.























                                 16-6
                                                EXAMPLES OF USING SCAN
                                                         TSCAN example

title   findff - find number of form-feeds in group of files
        .request scan
        .request wild
        search  uuosym,SCNMAC,$scndc
;*************************************************
; initialization routine
;*************************************************
findff: reset
        move    p,[iowd pdlsiz,pdl]
        movei   t1,1
        movem   t1,totff        ;starts at 1 page (no initial ff)
        move    t1,[isclen,,iscblk]
        pushj   p,.iscan##      ;initialize scan
        pushj   p,.tcrlf##
        setzm   wildsw          ;indicate no wild spec in force
;*************************************************
; routine to get next file specification from scan
;*************************************************
getnam: skipe   wildsw          ;skip if no wild spec in force
        jrst    calwld          ;jump if a wild spec is current
getspc: move    t1,[xwd P.ZER##,P.ZER##+1]
        setzm   P.ZER##
        blt     t1,P.EZER##     ;init default region for .TSCAN
        move    t1,[tsclen,,tscblk];argument block
        pushj   p,.TSCAN##      ;get next file specification 
                                ;from input source
        setom   wildsw          ;remember that a wild 
                                ;spec is current
        hllzs   wldblk+3        ;clear wild's pointer
        setz    0,              ;fix wild bug which clobbers 0
calwld: movei   t1,[scnblk]     ;reset scan block address in case
        hrlm    t1,wldblk       ;we already called .lkwld before,
        move    t1,[opnblk,,lkpblk]
        movem   t1,wldblk+1     ;fix wild bug which clobbers
        move    t1,[wldlen,,wldblk]     ;this word
        pushj   p,.lkwld##      ;get next file name from wild spec
        jrst    getspc          ;here when done with wild spec
        popj    p,




                                 16-7
EXAMPLES OF USING SCAN
TSCAN example

;*************************************************
; prompt routine for getfil
;*************************************************
prompt: movei   t1,[asciz /file: /]
        pushj   p,.tstrg##      ;type string
        popj    p,

;*************************************************
; routine to allocate output file space for scan
;*************************************************
getout: move    t1,[xwd scnblk,scnblk+1]
        setzm   scnblk
        blt     t1,scnblk+scnlen-1
        movei   t1,scnblk
        movei   t2,scnlen
        popj    p,

















                                 16-8
                                                EXAMPLES OF USING SCAN
                                                         TSCAN example

;***********************************************************
; definitions and workareas needed by scan and wild
;***********************************************************
.helpr==:.tcrlf##               ;eliminate link10 diagnostic
iscblk: z                       ;scan initialization block
        z
        z                       ;default tty i/o routines are ttcalls
        z
        xwd     prompt,monret   ;prompt routine,,monitor return
                                ;routine
        z
isclen=.-iscblk
scnblk: block   20              ;copy scan block into here
scnlen=.-scnblk
wldblk: xwd     [scnblk],0      ;scan-block pointer
        xwd     opnblk,lkpblk   ;open and lookup blocks
        xwd     scnlen,lkplen   ;lengths of scan block 
                                ;and lookup block
        exp     1b0             ;allow any device
        exp     .popj##         ;no routine to call at end of ufd
wldlen=.-wldblk
define  SWTCHS<
sp      foo,fooloc,.sixsw##,,,0 ;dummy switch for .TSCAN
>
DOSCAN  (foo)
tscblk: iowd    fool,foon       ;argument block for TSCAN
        xwd     food,foom
        xwd     0,food
        z
        z
        xwd     getout,getout
        z
        z
        z
tsclen=.-tscblk
fooloc: z




                                 16-9






                              CHAPTER 17
                   USING THE MISCELLANEOUS ROUTINES

17.1  INTRODUCTION
     The purpose of this chapter is to highlight the uses of  some  of
the  miscellaneous  routines in SCAN.  These are routines that are not
directly related to the task of  scanning  command  lines,  but  which
often  make  writing  programs  simpler.   The  initial chapter, which
listed the routines in SCAN, gave an adequate description of the Input
and Output routines, which will not be covered here.

17.2   .LKNAM - TABLE LOOKUP
     This routine is used to perform the commonly needed task of table
searching.   It  is,  in  fact, the routine which the command scanners
themselves use to lookup switch  and  command  names.   The  argument,
which  must  be  in  SIXBIT (like the table being searched), can be an
abbreviation of an entry in the table.  exact matches will  always  be
found,  even  if  they constitute an abbreviation for another command.
the lookup attempt into the table will fail for one  of  two  reasons:
1)  no  match  or  abbreviation  was found at all, or 2) more than one
abbreviation, and no exact match, was found.
     the call on .lknam is as follows:
          move t1,[iowd len,address]
          move t2,[SIXBIT/mumble/]
          pushj p,.lknam##
           -here if failure-
           -here if success-




                                 17-1
USING THE MISCELLANEOUS ROUTINES
 .LKNAM - TABLE LOOKUP

where:
          len     is the length of the table
          address is the address of the table
          mumble  is the word being searched for
on the failure return:
          t1<0 if no match was found
          t1>0 if multiple abbreviations were found
on success return:
          t1<0 if exact match was found
          t1>0 if abbreviation was found
          (rh) of t1 = address of table entry matched


17.3  DATE AND TIME CONVERSION
     Since the conversion between  Universal  Date/Time  and  the  DEC
standard  format  is  complex,  a  routine  is provided within scan to
perform this function.  the universal format contains the date in  the
left  half,  and  the time in the right half.  the DEC standard format
contains the date (derived in a different manner) in one word, and the
time  (also  of  a  different  derivation)  in another unrelated word.
three routines are provided to handle these functions:
      o   .cntdt - convert from universal to dec
      o   .cnvdt - convert from DEC to universal
      o   .gtnow - get the current time in universal format


17.3.1   .CNTDT
     To convert from universal format to DEC format, use the following
calling specification:
          MOVE T1,universal date-time
          PUSHJ P,.CNTDT##
           -always returns here-




                                 17-2
                                      USING THE MISCELLANEOUS ROUTINES
                                              DATE AND TIME CONVERSION

          with T1=time as MS past midnite
           and T2=DEC format date

17.3.2   .CNVDT
     This routine converts from DEC format to universal  format.   the
calling sequence for it is:
          move t1,time
          move t2,date
          pushj p,.cnvdt##
           -always returns here-
where
          "time" is the time in milleseconds past midnite
          "date" is the date in date uuo format
on return,
          t1=universal date/time, or
          t1=-1 if arguments were past sept.  27,2217
an advantage of the universal format is the ease  of  converting  from
date to day of week.  the base for the unviersal system, also referred
to as the astronomical standard, was a wednesday.  therefore, dividing
the  universal  date by seven yields a remainer that indicates the day
of the week.  zero would be  a  wednesday,  and  the  others  fall  in
sequence.

17.3.3   .GTNOW
Since the only method of finding the current Universal date/time  from
the  monitor  if  via a GETTAB, life is made a little simpler by using
this routine.  It takes no arguments, and simply returns  the  current
date and time in universal format, in T1.

17.4  MANIPULATING LISTS OF DATA
     SCAN provides two routines useful when a list  of  data  must  be
manipulated  in a sequential fashion.  One routine is used to remove a
data word from the list, another to place data into the list.



                                 17-3
USING THE MISCELLANEOUS ROUTINES
MANIPULATING LISTS OF DATA

     The accumulator usage for these routines is a follows:
      o  T1 is the current address in the list
      o  T2 is the number of words left in the list
      o  T3 is the data being manipulated.

     To place data into the list, .PTWRD is called  in  the  following
manner:
          MOVE T1,address
          MOVE T2,length
          MOVE T3,datum
          PUSHJ P,.PTWRD##
           -always returns here-
      with
          T1 incremented to the next list address
          T2 decremented by 1
          T3 contains the old data item

     To remove an item from the list, .GTWRD is called  in  a  similar
fashion:
          MOVE T1,address
          MOVE T2,length
          PUSHJ P,.GTWRD##
           -always returns here-
      with
          T1 incremented by 1 to the next location
          T2 decremented by 1
          T3 data item, or
             zero if nothing left in list (T2<=0)

     Note that since the routines automatically update their pointers,
the  setup  need  only  be  done  for the first usage of the routines.
After that, they can be called successively to  remove  arguments  (or
whatever)  from  a list, and to place return values (or whatever) into
the list.

17.5  .RUNCM - RUNNING OTHER PROGRAMS VIA /RUN
     This facility is useful for writing programs that may want to run
other  programs when execution is complete.  The mechanism used is the
/RUN switch, which takes as an argument the specification for the file
to  run.   Three  switches  control this, but only the first (/RUN) is
                                 17-4
                                      USING THE MISCELLANEOUS ROUTINES
                              .RUNCM - RUNNING OTHER PROGRAMS VIA /RUN

required:
      o  /RUN - Give the name and PPN of the file to run.
      o  /runcore - SPecifies the amount of core to initially run  the
         program  in.   if followed by a "p", then it is in pages (ex:
         /runcore:20p), if the size is followed by a "k", then  it  is
         in  k-core  (2-pages) (ex:  /runcore:10k).  the default is to
         load in just what the program requires to start with.
      o  /runoffset - this specifies the starting address offset (from
         whatever is given in the location .jbsa in jobdat).  whenever
         this is specified, it is usually "1", which specifies the CCL
         entry point for programs supporting such facilities.

     the actual switch processing is done by the  .filin  code  during
the  command  line  scanning.   because  of this, all that the support
programs needs to do is:
          pushj p,.runcm##


17.6  .reeat - backing up the input pointer
     It is often useful, when scanning across a command  line,  to  be
able  to  "back  up"  by  a  character.  The best example is a context
driven parse, where the parser doesn't know it is at the  end  of  one
section of the line until it sees the beginning of the next.  By then,
without a REEAT facility, it is too late to  begin  parsing  the  next
section of the line.
     To use this, simply call .reeat with the next character to use in
p4,  which is where the input routine would have left it.  a secondary
usage would be to replace the character actually read with some  other
character.
     the calling format is:
     movei p4,character
     pushj p,.reeat##


17.7  .MKMSK - MAKING MASKS
     This is a routine  used  for  assembling  the  mask  word  for  a
possibly  wild SIXBIT word.  the mask will have octal 77s wherever the
argument had non-zero SIXBIT characters.  the call is:
                                 17-5
USING THE MISCELLANEOUS ROUTINES
.MKMSK - MAKING MASKS

     move t3,word-to-be-masked
     pushj p,.mkmsk##


17.8  .TDIRB - TYPING DIRECTORY BLOCKS
     One of the more common functions performed in support programs is
the  typing  fo  file  information.  This routine is capable of typing
such  information  form  one  of  three  input  formats:   1)   normal
LOOKUP/ENTER format, 2) path.  uuo format, or 3) scan's internal (scan
block) format.  the distinction is made in the form of a  code  passed
to .tdirb.  the calling format is:
     move t1,[code,,address-of-block-to-type]
     pushj p,.tdirb##
     code=1 for LOOKUP/ENTER format
     code=2 for path.  uuo format
     code=3 for scan blocks


17.9  .ISLGI - TESTING FOR LOGIN STATUS
     Sometimes, with privileged programs that can run while not logged
in, the program needs to see if the caller is in fact logged in before
it performs certain functions.  This routine  makes  determining  this
pretty painless:
     PUSHJ P,.ISLGI##
       -not logged in-
       -logged in-


17.10  .MKPJN - MAKING A "CCL" JOB NUMBER
     Sometimes it is necessary to communicate with other parts of  the
system  via a special "CCL" name, which is comprised of the job number
and a 3-letter  code  for  the  program.   This  routine  is  used  to
translate  from  the binary number (which can really be any number) to
SIXBIT.  the call is rather simple:
     move t1,number
     pushj p,.mkpjn##
the routine always returns at +1, with the SIXBIT number in t1.

                                 17-6






                              APPENDIX A
                     NOTES ON USING THE SCANNERS




      o  When supplying a user-written character  input  routine,  the
         character  must  be  returned  in  P4.   No other accumulator
         should be altered.
      o  When  supplying  a  user-written  routine  for  processing  a
         switch, SCAN will call it via a PUSHJ, with P1 containing the
         index into the tables generated  by  DOSCAN  for  the  switch
         being processed.  if it is desired that scan store the value,
         then the routine must leave the  value  in  p3,  and  take  a
         skip-return.  a non-skip return to scan is an indication that
         scan should not store a value.
      o  initial values of the locations into which scan stores switch
         values should be -1.
      o  the maximum value handled by DM is 3777777;  the  minimum  is
         0.   if  these  are not suitable, then define the appropriate
         symbols before calling dm (dm will nor redefine  any  of  the
         MX.???,  ad.???,  or  PD.???   symbols  which  already have a
         defined value whenever DM is called).
      o  scan  will  generate  a  reference  to  the  external  symbol
         ".helpr".     this    is   normally   resolved   by   loading
         rel:HELPER.REL, and is used for processing the /help  switch.
         however,  if  no  help  processing  is  to  be done, then the
         following is sufficient:
                           .helpr==:.tcrlf##


                                 A-1






                              APPENDIX B
                         NOTES ON Using WILD




      For the most part, WILD is well documented in  its  write-up  in
 the  Software Notebooks.  However, there are a few things to be aware
 of.
   1.  WILD has a bug which clobbers AC0 in a  very  orderly  fashion;
       try to keep your own AC0 safe.
   2.  Because of the nature of #1, if  multiple  top-level  calls  to
       WILD  are made (i.e.:  multiple wild card specs not scanned off
       together), then WILD,  after  completely  expanding  the  first
       spec, will forever after think it is done.  This is because AC0
       is clobbered to a file-spec pointer, later to  something  else,
       and  then  even  later  looked at in the context of a file-spec
       pointer.  The "fix"  is  a  simple  SETZ  of  AC0  before  each
       top-level call to .LKWLD is started.
   3.  The documentation is incorrect in specifying that  .LKWLD  only
       needs  to  be  given  the  address of its argument block;  like
       almost all other code, it expects to see a length in  the  left
       half of T1.
   4.  For an unknown reason, WILD will, on occasion, write into  part
       of  its  argument  block,  usually to the OPEN block and LOOKUP
       block pointers.  Beware.





                                 B-1
NOTES ON Using WILD

      The following subroutines are also documented  in  the  Software
 Notebooks,  but  are  included  here  for  added exposure.  To type a
 standard LOOKUP or ENTER error message, the  following  routines  are
 quite useful:

  o  To type out a message which includes the  filename,  error  code,
     etc.:
          MOVEI T1, address of extended LOOKUP/ENTER block
          movei t2, length of lookup block
          movei t3, address of scan block
          pushj p, e.lken##

  o  to type out only the code and its meaning (no filename, etc.):
          move1 t1, error-code
          pushj p, .lkerr##

















                                 B-2






                              APPENDIX C
                   SCNMAC:  command scanner macros




      This is a listing of the contents of SCNMAC.mac,  which  is  the
 file  containing  most  of  the  macros and parameters used by scan's
 routines.  it is accessed by the
           search SCNMAC
 statement at the beginning of a program using scan.

                   SCNMAC - command scanner macros

        subttl  command scanner macros %7(105) 25-aug-74
  
  
  ;macro definitions of general use
  
  ;defaults
  
  ;dm abbreviation,max,adefault,pdefault
  ;  defines symbols MX.abbreviation,
  ;  ad.abbreviation, and PD.abbreviation to
  ;  be the maximum allowed value, the
  ;  default if the keyword is absent, and
  ;  the default if the keyword is present
  ;  respectively unless the corresponding
  ;  symbol is already defined.
  
  
   define       dm(abbr,max,adef,pdef),<
        nd      SWTCHS'abbr,max
                nd      ad.'abbr,adef
                nd      PD.'abbr,pdef>
                                 C-1
SCNMAC:  command scanner macros

  
  
  ;  KEYS (name,list) will define a list of KEYS by name name
  ;     name can be up to 4 chars.  (defines name.t and name.l)
  ;     list is SIXBIT names separated by commas.
  ;     defines name concatenated with start of item in list
  ;     as index in list unless the item begins with "*"
  
  
  
  
  
    ;switch scanning macros and tables
  
  ;  SWTCHS  is the macro listing all known
  ;  switches.  it includes the name and
  ;  storage location for value types, it
  ;  also has the max and default and
  ;  processor for key-value types, it points
  ;  to the KEYS and has the default if any
  ;  for stand-alone types, it has the value.   
  ;when the switch scanning tables are to be built, invoke
  ;the macro DOSCAN with 5-char argument to use as symbol prefix
  ;it will define xxxxxn,l,p,m,d
  
  













                                 C-2
                                       SCNMAC:  command scanner macros

  ;  sl name,storage,table-name,default,flags
  ;     defines a list of key-values (see KEYS macro)
  ;     default is the ordinal or 0 if no default
  ;     if lh(storage)=7777b11, storage = routine to process
  ;
  ;  sp name,storage,processor,abbreviation,flags
  ;     defines a value parameter whose defaults
  ;      are defined at the beginning of the program
  ;      by "dm" using the same abbreviation
  ;     processor is the jump address in switch processing
  ;      it will be called with p1=switch offset in table
  ;      and p2=pointer to 4-word block of
  ;      internal or external stuff
  ;     if max=0 and fs.lrg, then any value can be stored
  ;      else, 0.le.value.le.max
  ;
  ;     0.le.max,default.lt.2**17 unless fs.lrg
  ;
  ;     if max=0 and not fs.lrg, then
  ;     processor is an immediate action
  ;      which will always be called
  ;      else, processor will be called only if ":"
  ;
  ;  ss name,storage,value,flags
  ;     defines a stand-alone parameter
  ;
  ;     in all cases, storage is a byte pointer.
  ;      if a full word, only the address is needed
  ;      if a multiple word, the byte size is 65-#words
  ;      (up to 28)
  ;      if a file specification, the length is held
  ;      in MX.abbreviation
  ;      if pointer is 7777??,,??????  then rh(pointer)
  ;      is dispatch address of processor which takes
  ;      keyword switch values
  ;
  ;  sn name,storage,flags
  ;     defines a stand-alone parameter which takes value
  ;      1 if /name, and value 0 if /noname
  
  ;flags which can be defined in switch table
  >fs.nfs ==1b0 ;this switch is never part of a
                ;file specification
                ;  this should be set on global switches
                ;  ** very important to get right **
  >fs.lrg ==1b1 ;the max and default values are 0 or .gt.  2**17
  >fs.nue ==1b2 ;no user exit on this switch
  >fs.vrq ==1b3 ;value required
  >fs.obv ==1b4 ;or bit values to right half
  >fs.nos ==1b5 ;switch takes "no" prefix
                ;(internal for sn macro only)
  >fs.ncm ==1b6 ;switch does not constitute a command [102]
                ;  (for /run, /option, /exit)
                                 C-3
SCNMAC:  command scanner macros

  ;words in file spec area
  .fxdev==0     ;device (non-zero if any part of spec)
  .fxnam==1     ;name (non-zero if name present)
  .fxnmm==2     ;name mask
  .fxext==3     ;extension,,extension mask (non-zero dot present)
  .fxmod==4     ;modifier word
  .fxmom==5     ;modifier mask
  .fxdir==6     ;directory word (each half=0 if default;
                ;sfd:0 if end)
  .fxdim==7     ;directory mask
  .fxbfr==22    ;/before
  .fxsnc==23    ;/since
  .fxabf==24    ;/abefore
  .fxasn==25    ;/asince
  .fxfli==26    ;file min size (words)
  .fxflm==27    ;file max size (words)
  .fxest==30    ;/estimate
  .fxver==31    ;/version
  
  ;lengths of file spec area
  .fxlen==32    ;length of one specification
  .fxlnd==6     ;length of directory (ufd+sfd's)
  
  ;bytes in scan mod word
  fx.ndv==1b0   ;null device
  fx.nul==1b1   ;null extension
  fx.dir==1b2   ;directory specified (mod=0 if [-])
  fx.phy==1b3   ;/physical
  fx.nom==1b4   ;/oknone
  fx.dfx==1b5   ;directory does not need fix-up by wild
  fx.trm==7b8   ;code for spec's termination
        .fxtra==1       ;& (and)
        .fxtro==2       ;!  (or)
        .fxtrn==3       ;- (not)
        .fxtrc==4       ;+ (concatenate)
  fx.str==1b9   ;/strs
  fx.prt==1b10  ;/okprot
  fx.sup==1b11  ;/ersupersede
  
  fx.den==7b23  ;/density       [105]
  fx.par==1b24  ;/parity
  fx.pro==777b35        ;/protection
  





                                 C-4
                                       SCNMAC:  command scanner macros

  ;special characters for scan
  .chalx==0     ;altmode
  .cheol==-1    ;end of line
  .cheof==-2    ;end of file
  
  ;guide words (turned into pseudo characters)
  
  .chand==4000  ;'and'                                  [101]
  .chor==04001  ;'or'                                   [101]
  .chnot==4002  ;'not'                                  [101]
  .chto==04003  ;'to'                                   [103]
  .chfrm==4004  ;'from'                                 [103]
  .chinp==4005  ;'input'                                [103]
  .chout==4006  ;'output'                               [103]
  .chsrc==4007  ;'source'                               [103]
  .chlst==4010  ;'list'                                 [103]
  .chobj==4011  ;'object'                               [103]
  
  
  ;flags for .iscan call
  
  fs.icl==1b17  ;ignore special command-line handling
  
  ;flags for .TSCAN call
  
  fs.mot==1b18  ;multiple output specs possible
  fs.mio==1b19  ;mixed input and output specs
  
  ;flags for .tdirb call
  
  TS.DRW==0     ;single word
  TS.DRP==1     ;path pointer
  TS.DRB==2     ;biword (ie, scan spec format)
  
  ;values from .verbo
  
  jww.cn==1b33  ;/verbos:continuation
  jww.fl==1b34  ;/verbos:first
  jww.pr==1b35  ;/verbos:prefix







                                 C-5






                              APPENDIX D
                $SCNDC:  COMMAND SCANNER DECLARATIONS




$SCNDC is a part of SCAN.MAC, which generates $SCNDC.UNV whenever SCAN
is  assembled.   It contains the definitions of some SCAN/WILD related
symbols,  and  the  accumulators,  for  use  by  programs  which  must
interface with SCAN & WILD.  It is accessed by the
          SEARCH $SCNDC
statement at the beginning of the program using SCAN or WILD.













                                 D-1
$SCNDC:  COMMAND SCANNER DECLARATIONS



        UNIVERSAL $SCNDC -- DECLARATIONS FOR COMMAND SCANNER
        SEARCH  C,SCNMAC        ;search parameters for this file
 
 ;ac names
 
 t1=1           ;temporaries
 t2=2
 t3=3
 t4=4
 
 p1=5           ;preserved acs for calling routines
 p2=6
 p3=7
 p4=10
 
 p=17           ;push-down pointer
 
 
 dm msg,77777,0,7       ;message
 dm pro,777,0,277       ;protection
 dm rnc,777777,0,0      ;run core
 dm run,7,-1,1          ;run offset
 
 vrbadx==10             ;/message:address
 
 prgend












                                 D-2






                              APPENDIX E
               EXAMPLES:  SCAN'S INTERNAL SWITCH TABLES




It was mentioned at various points in the text that SCAN  has  certain
switches  built  into  it.   As might be expected, SCAN uses itself to
process htese switches.  Therefore, it is interesting  and  useful  to
see  just how SCAN defines its own switches, using the DOSCAN, SWTCHS, DM
and KEYS macros.














                                 E-1
EXAMPLES:  SCAN'S INTERNAL SWITCH TABLES





 ;here we define standard switches processed in scan
 
        define  SWTCHS,<
 sp abefore,f.abf,.swdtp,,fs.vrq
 sp asince,f.asn,.swdtp,,fs.vrq
 sp before,f.bfr,.swdtp,,fs.vrq
 sl density,<POINTR (f.mod,fx.den)>,dens,densin
 ss ernone,<POINTR (f.mod,fx.nom)>,0
 ss erprotection,<POINTR (f.mod,fx.prt)>,0
 ss ersupersede,<POINTR (f.mod,fx.sup)>,1
 sp estimate,f.est,.blokw,,fs.vrq
 sp exit,n.dev,swexit,,fs.nfs!fs.ncm
 sl *help,<-1,,.swhlp>,help,helptext,fs.nfs!fs.ncm
 sp length,f.flm,swlen,,fs.vrq
 sl message,<*f,.flvrb##>,vrb,PD.msg,fs.obv!fs.nfs!fs.ncm
 ss nooption,option,0,fs.nfs!fs.ncm
 
 ss oknone,<POINTR (f.mod,fx.nom)>,1
 ss okprotection,<POINTR (f.mod,fx.prt)>,1
 ss oksupersede,<POINTR (f.mod,fx.sup)>,0
 sp option,option,.swsix,opt,fs.nfs!fs.ncm
 sl parity,<POINTR (f.mod,fx.par)>,par,parodd
 sn physical,<POINTR (f.mod,fx.phy)>
 sp protection,<POINTR (f.mod,fx.pro)>,.swoct,pro
 sp run,n.zer,.swfil,rnl,fs.nfs!fs.ncm!fs.vrq
 sp runcore,n.core,.swcor,rnc,fs.lrg!fs.nfs!fs.ncm
 sp runoffset,n.offs,.swoct,run,fs.nfs!fs.ncm
 sp since,f.snc,.swdtp,,fs.vrq
 sn strs,<POINTR (f.mod,fx.str)>
 sp tmpfile,,swtmp,,fs.vrq!fs.nfs!fs.ncm
 sp version,f.ver,.versw,,fs.vrq
 >
 








                                 E-2
                              EXAMPLES:  SCAN'S INTERNAL SWITCH TABLES

 ;now build the tables from the SWTCHS  macro
        MX.opt==1
        PD.opt==0
        MX.rnl==n.ezer-n.zer+1
        PD.rnl==0
 
 
        DOSCAN  (stswt)
 
 
 ;here we build the KEYS
 
 KEYS (dens,<200,556,800,1600,6250,%%,$$,installation>)
 KEYS (help,<switches,text>)
 KEYS (par,<even,odd>)
                                ;  --dummies--          [321]
 KEYS (vrb,<prefix,first,continuation,$$,$%,%$,%%,address>)
 

















                                 E-3






                              APPENDIX F
                          EXAMPLES:  ALKFIL




ALKFIL is a non-DEC program written to perform the tasks of file space
allocation.   It  uses  SCAN  to  process  the command lines, and is a
useful example of the various options available to  the  SCAN  &  WILD
user.



 DEFINE SWTCHS<
 sp     size,filsiz,.decnw##,fil,fs.vrq!fs.ncm          ;[#46]
 sp     mindrives,mindrv,.decnw##,mnd,fs.vrq!fs.nfs     ;[#51]
 sp     maxdrives,maxdrv,.decnw##,mnd,fs.vrq!fs.nfs     ;[#51]
 sp     partitions,partns,getprt##,prt,fs.vrq!fs.nfs
 sp     repeat,rptfct,.decnw##,rpt,fs.vrq!fs.nfs        ;[#33]
 sl     split,splind,splt,,fs.vrq!fs.nfs
 sl     allocate,alcind,aloc,,fs.vrq!fs.nfs
 sl     addressing,adrind,adrs,,fs.vrq!fs.nfs
 sp     bufsiz,bufsiz,.decnw##,bufs,fs.vrq!fs.nfs
 sp     unit,uninam,getuni##,,fs.vrq!fs.nfs             ;[#25]
 sp     block,blknum,getblk##,,fs.vrq!fs.nfs            ;[#23]
 sp     lbn,lbnnum,getlbn##,,fs.vrq!fs.nfs              ;[#31]
 sp     status,stsobj,.sixsw##,,fs.nfs                  ;[#25]
 ss     strsts,<POINTR(f,f.strs)>,1
 ss     create,<POINTR(f,f.crea)>,1
 ss     prealloc,<POINTR(f,f.pral)>,1
 ss     copy,<POINTR(f,f.copy)>,1
 ss     nolog,<POINTR(f,f.nlog)>,1                      ;[#46]
 sp     spool,spool,.sixsw##,,fs.vrq!fs.nfs             ;[#57]
 ss     debug,<POINTR(f,f.debg)>,1                      ;[#60]
 >
 
 
                                 F-1
EXAMPLES:  ALKFIL

 ;expand switch tables for scan:
 DOSCAN(swit)
 
 
 ;define defaults and key-lists
 
 ;      name,max,absent-default,present-default
 dm     (mnd,^d31,1,1)                          ;[#51]
 dm     (mxd,^d32,32,32)                        ;[#51]
 dm     (prt,^d65,^d30,1)                       ;[#65]              ;0
implies minimum needed
 internal       MX.prt,ad.prt                   ;[#43] for use
                                                ;[#43] by other
                                                ;[#43] modules
 dm     (rpt,1,1,1)                             ;[#32]
 dm     (buf,^d100,^d25,^d5)                    ;[#52]
 dm     (fil,377777,^d1000,^d1000)              ;[#40]
 
 
 ;******** important *********
 ;if the order of arguments to the KEYS macro
 ;is changed, then the corresponding $$xxx
 ;table must also be changed.
 
 KEYS   (splt,<best,linear,prompt>)     ;[#61]
 KEYS   (aloc,<space,physical,logical,prompt>) ;[#60]
 KEYS   (adrs,<first,prompt>)           ;[#22]













                                 F-2






                              APPENDIX G
                        CUSPS & THEIR SCANNERS




Not all DEC programs use scan & wild.  most of the more  recent  (from
about  1976  on)  tend  to  use it, and some of the older ones use it.
many of the remaining programs, especially the very old cusps  (react,
soup,  etc.)  each  have  their own code to process their own (usually
different) styles of commands.  the list that follows indicates  which
DEC  (and  some  non-dec)  programs  use scan, and which use their own
scanners.  it should proves useful as a source of further  information
on  using  scan.   in  particular,  the module lnkscn of link-10 is an
excellant reference to using the switch-defining macros.


cusp            scanner         comments
----------      ------------    -----------------------

algol           own
backup          scan            .vscan
basic           own
batcon (mpb)    own
batcon (galaxy) scan
bliss-10        own             compiler fake's it (no sfds)
boot11          own
change          own
cobol           own
compil          own
CREDIR          scan            uses .pscan


                                 G-1
CUSPS & THEIR SCANNERS

cusp            scanner         comments
----------      ------------    -----------------------

cref            own
daemon          old scan        has scan v2 built into it
direct          scan
filcom          own
filex           own
fortran-10      scan
galaxy          scan            all components
help            scan
initia          own             even simulates .oscan
isam            own
jq              scan            (non-dec)  uses .TSCAN
kjob (mpb)      own
libary          own
lined           own
link-10         scan            excellant example (lnkscn)
login           scan
logout (mpb)    own
logout (galaxy) scan
lptspl (mpb)    own             same for other spoolers
lptspl (galaxy) scan            -dittoe-
macro           own
mail            own             (non-dec) good job of faking it
maklib          scan
omount          own
opser           own
pip             own
queue (mpb)     scan            .TSCAN
queue (galaxy)  scan            .TSCAN
react           own
rerun           own
runoff          scan            .TSCAN
setsrc          own
sort-10         scan
sos             own
soup            own
systat          own
teco            own
umount          own





                                 G-2


                                INDEX


$scndc . . . . . . . . . . . . . .  D-1
.aplst . . . . . . . . . . . . . .  8-2
.ascqw . . . . . . . . . . . . . .  2-4
.asqcq . . . . . . . . . . . . . .  2-4
.blokc . . . . . . . . . . . . . .  2-6
.blokw . . . . . . . . . . . . . .  2-6
.ch??? symbols . . . . . . . . . .  C-5
.clrbf . . . . . . . . . . . . . .  2-9
.cntdt . . . . . . . . . . . . . .  2-8, 17-2
.cnvdt . . . . . . . . . . . . . .  2-8, 17-3
.corec . . . . . . . . . . . . . .  2-6
.corew . . . . . . . . . . . . . .  2-6
.datic . . . . . . . . . . . . . .  2-5
.datif . . . . . . . . . . . . . .  2-5
.datig . . . . . . . . . . . . . .  2-5
.datim . . . . . . . . . . . . . .  2-5
.datip . . . . . . . . . . . . . .  2-5
.datiq . . . . . . . . . . . . . .  2-5
.decnc . . . . . . . . . . . . . .  2-4
.decnw . . . . . . . . . . . . . .  2-4
.filin . . . . . . . . . . . . . .  2-7, 6-2 to 6-3
.fx??? offsets . . . . . . . . . .  C-4
.gtnow . . . . . . . . . . . . . .  2-8, 17-3
.gtwrd . . . . . . . . . . . . . .  2-10
.helpr . . . . . . . . . . . . . .  A-1
.iscan . . . . . . . . . . . . . .  2-1, 10-1, C-5
.iscan flags . . . . . . . . . . .  C-5
.islgi . . . . . . . . . . . . . .  2-11, 17-6
.lkerr . . . . . . . . . . . . . .  B-2
.lknam . . . . . . . . . . . . . .  2-8, 17-1
.mkmsk . . . . . . . . . . . . . .  2-10, 17-5
.mkpjn . . . . . . . . . . . . . .  2-8, 17-6
.namec . . . . . . . . . . . . . .  2-4
.namew . . . . . . . . . . . . . .  2-4
.octnc . . . . . . . . . . . . . .  2-4
.octnw . . . . . . . . . . . . . .  2-4
.oscan . . . . . . . . . . . . . .  3-1 to 3-2, 8-3, 9-2, 
                                    12-1 to 12-2, 16-3, G-2
.oscan - calling format  . . . . .  12-2
.osdfs . . . . . . . . . . . . . .  12-3
.pop4t . . . . . . . . . . . . . .  2-1
.popj  . . . . . . . . . . . . . .  2-1
.popj1 . . . . . . . . . . . . . .  2-1
.pscan . . . . . . . . . . . . . .  14-1, 16-1 to 16-2, G-1
.pscan - example . . . . . . . . .  16-2
.psh4t . . . . . . . . . . . . . .  2-1
.ptwrd . . . . . . . . . . . . . .  2-10
.qscan . . . . . . . . . . . . . .  14-1, 16-1 to 16-2
                               Index-1


.qscan - example . . . . . . . . .  16-2
.reeat . . . . . . . . . . . . . .  2-9, 17-5
.runcm . . . . . . . . . . . . . .  2-8, 17-4
.save1 . . . . . . . . . . . . . .  2-1
.save2 . . . . . . . . . . . . . .  2-1
.save3 . . . . . . . . . . . . . .  2-1
.save4 . . . . . . . . . . . . . .  2-1
.sixmc . . . . . . . . . . . . . .  2-5
.sixmw . . . . . . . . . . . . . .  2-5
.sixqc . . . . . . . . . . . . . .  2-4
.sixqw . . . . . . . . . . . . . .  2-4
.sixsc . . . . . . . . . . . . . .  2-4
.sixsw . . . . . . . . . . . . . .  2-4
.stopb . . . . . . . . . . . . . .  2-9, 9-4
.tastr . . . . . . . . . . . . . .  2-3
.tblok . . . . . . . . . . . . . .  2-3
.tchar . . . . . . . . . . . . . .  2-3
.tcoln . . . . . . . . . . . . . .  2-3
.tcoma . . . . . . . . . . . . . .  2-3
.tcorw . . . . . . . . . . . . . .  2-3
.tcrlf . . . . . . . . . . . . . .  2-3
.tdate . . . . . . . . . . . . . .  2-2
.tdatn . . . . . . . . . . . . . .  2-2
.tdec2 . . . . . . . . . . . . . .  2-3
.tdecw . . . . . . . . . . . . . .  2-3
.tdirb . . . . . . . . . . . . . .  2-11, 17-6, C-5
.tdirb flags . . . . . . . . . . .  C-5
.tdttm . . . . . . . . . . . . . .  2-2
.tfchr . . . . . . . . . . . . . .  2-3
.tican . . . . . . . . . . . . . .  2-6
.tmohw . . . . . . . . . . . . . .  2-2
.toctw . . . . . . . . . . . . . .  2-3
.toleb . . . . . . . . . . . . . .  2-3
.tPPNw . . . . . . . . . . . . . .  2-3
.trbrk . . . . . . . . . . . . . .  2-3
.trdxw . . . . . . . . . . . . . .  2-3
.TSCAN . . . . . . . . . . . . . .  3-1, 11-1, 11-4, 12-3, 13-1, 16-1, 
                                    16-5, 16-7, C-5, G-2
.TSCAN - calling format  . . . . .  11-4
.TSCAN - example . . . . . . . . .  16-5, 16-7
.TSCAN flags . . . . . . . . . . .  C-5
.tsixn . . . . . . . . . . . . . .  2-2
.tspac . . . . . . . . . . . . . .  2-3
.tstrg . . . . . . . . . . . . . .  2-2
.ttabc . . . . . . . . . . . . . .  2-3
.ttime . . . . . . . . . . . . . .  2-2
.ttimn . . . . . . . . . . . . . .  2-2
.tverw . . . . . . . . . . . . . .  2-3
.txwdw . . . . . . . . . . . . . .  2-3
.txwww . . . . . . . . . . . . . .  2-2
.tyoch . . . . . . . . . . . . . .  2-1
.verbo . . . . . . . . . . . . . .  C-5
.verbo flags . . . . . . . . . . .  C-5
                               Index-2


.versc . . . . . . . . . . . . . .  2-6
.versw . . . . . . . . . . . . . .  2-6
.vscan . . . . . . . . . . . . . .  3-1 to 3-2, 4-5, 12-3, 
                                    13-1 to 13-2, 14-1, G-1
.vscan - calling format  . . . . .  13-2
/run switch processing . . . . . .  2-8
????.l . . . . . . . . . . . . . .  5-3
????.t . . . . . . . . . . . . . .  5-4
?????d . . . . . . . . . . . . . .  5-4
?????l . . . . . . . . . . . . . .  5-4
?????m . . . . . . . . . . . . . .  5-4
?????n . . . . . . . . . . . . . .  5-4
?????p . . . . . . . . . . . . . .  5-4
????xx . . . . . . . . . . . . . .  5-4
Accumulator names  . . . . . . . .  D-2
Acessing scan  . . . . . . . . . .  15-1
Ad.??? . . . . . . . . . . . . . .  5-1, 5-3, A-1
CCL job number . . . . . . . . . .  2-8
Chaining execution . . . . . . . .  2-8
Character checking . . . . . . . .  2-6
Character input  . . . . . . . . .  2-6, 2-9
Character output . . . . . . . . .  2-3
Charater input - positioning . . .  2-9
Clearing input buffers . . . . . .  2-9
Command scanners . . . . . . . . .  3-1
Constructed symbols  . . . . . . .  5-3
Conversion - scan blocks . . . . .  2-9
Core sizes - inputting . . . . . .  2-6
Core sizes - typing  . . . . . . .  2-3
CREDIR . . . . . . . . . . . . . .  3-2, 14-2, 16-2
Date conversion routines . . . . .  2-8
Date/time  . . . . . . . . . . . .  2-2, 2-5
Date/time conversion . . . . . . .  17-2
DEC date/time - conversion . . . .  2-8
Default values . . . . . . . . . .  3-5, 11-2, 12-3, 16-7
Defaults - absent  . . . . . . . .  5-3
Defaults - present . . . . . . . .  5-3
Defining default values  . . . . .  5-1
Defining keywords for sl switches   5-2
Defining scanner tables  . . . . .  4-1
Defining switch parameters . . . .  4-1
Defining switches  . . . . . . . .  3-5
Defining the storage field . . . .  4-4, 6-1
Defining values for sl switches  .  5-1
DM macro . . . . . . . . . . . . .  5-1, 6-3, 15-1, C-1
Dm . . . . . . . . . . . . . . . .  A-1
DM macro - definition  . . . . . .  C-1
DOSCAN macro . . . . . . . . . . .  4-1 to 4-2, 5-4, 11-1, 11-4, 15-1, 
                                    16-4, 16-9, A-1, C-2, E-3, F-2
                               Index-3


E.lken . . . . . . . . . . . . . .  B-2
ENTER/LOOKUP blocks  . . . . . . .  2-11
Enter/lookup/open blocks - typing   2-3
Error codes  . . . . . . . . . . .  B-2
Error messages . . . . . . . . . .  B-2
Example - CREDIR . . . . . . . . .  16-2
Execute only . . . . . . . . . . .  15-3
F.EZER . . . . . . . . . . . . . .  9-3
F.ZER  . . . . . . . . . . . . . .  9-3
F.ZER - layout . . . . . . . . . .  9-4
File sizes - inputting . . . . . .  2-6
File sizes - typing  . . . . . . .  2-3
File specification format  . . . .  3-4
File specification input . . . . .  2-7, 6-3, 9-1
File specification output  . . . .  2-3
Fs.??? flags . . . . . . . . . . .  4-5, C-3
Fs.??? symbols . . . . . . . . . .  C-4
Fs.icl . . . . . . . . . . . . . .  10-3, C-5
Fs.lrg . . . . . . . . . . . . . .  4-5
Fs.mio . . . . . . . . . . . . . .  11-3, C-5
Fs.mot . . . . . . . . . . . . . .  11-3, C-5
Fs.ncm . . . . . . . . . . . . . .  4-5
Fs.nfs . . . . . . . . . . . . . .  4-5
Fs.nos . . . . . . . . . . . . . .  4-5
Fs.nue . . . . . . . . . . . . . .  4-5
Fs.obv . . . . . . . . . . . . . .  4-5
Fs.vrq . . . . . . . . . . . . . .  4-5
Guide words  . . . . . . . . . . .  2-7, 9-2, C-5
Helper . . . . . . . . . . . . . .  11-1, 11-4
HELPER.REL . . . . . . . . . . . .  15-2, A-1
Initialization . . . . . . . . . .  2-1
Input line positioning . . . . . .  2-9
Input routines . . . . . . . . . .  2-4
Input routines - character . . . .  2-6, 2-9
Input routines - clearing input buffers  2-9
Input routines - core & file sizes  2-6
Input routines - date/time . . . .  2-5
Input routines - file specifications  2-7
Input routines - string and numeric  2-4
Input routines - version numbers .  2-6
Inputting ASCII strings  . . . . .  2-4
Inputting core sizes . . . . . . .  2-6
Inputting dates - future . . . . .  2-5
Inputting dates - general  . . . .  2-5
Inputting dates - past . . . . . .  2-5
Inputting dates - universal format  2-5
Inputting decimal numbers  . . . .  2-4
Inputting file sizes . . . . . . .  2-6
Inputting file specifications  . .  2-7, 9-1
                               Index-4


Inputting numbers - decimal  . . .  2-4
Inputting numbers - octal  . . . .  2-4
Inputting octal numbers  . . . . .  2-4
Inputting SIXBIT strings . . . . .  2-4 to 2-5
Inputting SIXBIT words . . . . . .  2-4
Inputting SIXBIT words - wild  . .  2-4
Inputting version numbers  . . . .  2-6
Inputting words/strings - ASCII  .  2-4
Inputting words/strings - SIXBIT .  2-4 to 2-5
Inputting words/strings - wild SIXBIT  2-4
Iscan  . . . . . . . . . . . . . .  10-1
Iscan flags  . . . . . . . . . . .  C-5
Jww.cn . . . . . . . . . . . . . .  C-5
Jww.fl . . . . . . . . . . . . . .  C-5
Jww.pr . . . . . . . . . . . . . .  C-5
KEYS KEYS  . . . . . . . . . . . .  15-1
KEYS macro . . . . . . . . . . . .  5-1 to 5-2, C-2
KEYS macro - definition  . . . . .  C-2
Keyword table - address  . . . . .  5-4
Keyword table - entries  . . . . .  5-4
Keyword table - length . . . . . .  5-3
Layout of scan block . . . . . . .  9-4
LOOKUP/ENTER blocks  . . . . . . .  2-11
Lookup/open blocks - typing  . . .  2-3
Macros - dm  . . . . . . . . . . .  5-1, 6-3, 15-1, C-1
Macros - DOSCAN  . . . . . . . . .  5-4, 11-1, 11-4, 15-1, 16-4, 16-9, 
                                    A-1, C-2, E-3, F-2
Macros - KEYS  . . . . . . . . . .  5-1 to 5-2, 15-1, C-2
Macros - SWTCHS . . . . . . . . . . .  C-2
Macros - SL  . . . . . . . . . . .  4-3, 6-2, 15-1, C-3
Macros - SN  . . . . . . . . . . .  4-3, 6-2, 15-1, C-3
Macros - SP  . . . . . . . . . . .  4-4, 6-2 to 6-3, 15-1, C-3
Macros - SS  . . . . . . . . . . .  4-2, 6-2 to 6-3, 15-1, C-3
Manipulating lists of data . . . .  2-10
Manipulating lists of date . . . .  17-3
Masks  . . . . . . . . . . . . . .  2-10
Miscellaneous routines . . . . . .  2-7
SWTCHS macro  . . . . . . . . . . . .  3-5, C-2
SWTCHS macro - definition . . . . . .  4-2, C-2
SWTCHS macro - usage  . . . . . . . .  4-1
MX.??? . . . . . . . . . . . . . .  5-3, A-1
MX.????  . . . . . . . . . . . . .  5-1
Numeric output . . . . . . . . . .  2-3
OPEN/LOOKUP blocks - typing  . . .  2-3
Options scanner  . . . . . . . . .  12-1
Oscan  . . . . . . . . . . . . . .  3-1 to 3-2, 8-3, 9-2, 
                                    12-1 to 12-2, 16-3, G-2
                               Index-5


Oscan - calling format . . . . . .  12-2
Output routines - core size  . . .  2-3
Output routines - date/time  . . .  2-2
Output routines - error codes  . .  B-2
Output routines - error messages .  B-2
Output routines - file size  . . .  2-3
Output routines - file specifications  2-3, 17-6
Output routines - numeric output .  2-3
Output routines - OPEN/LOOKUP block  2-3
Output routines - PPN  . . . . . .  2-3
Output routines - text . . . . . .  2-2
P.EZER . . . . . . . . . . . . . .  9-3, 16-7
P.ZER  . . . . . . . . . . . . . .  9-3, 11-2, 16-7
P.ZER - layout . . . . . . . . . .  9-4
Partial scanner  . . . . . . . . .  14-1
PD.??? . . . . . . . . . . . . . .  5-3, A-1
PD.????  . . . . . . . . . . . . .  5-1
POINTR macro . . . . . . . . . . .  6-1
PORTAL instructions  . . . . . . .  15-3
PPNs - typing  . . . . . . . . . .  2-3
Protection codes . . . . . . . . .  15-3
Pscan  . . . . . . . . . . . . . .  3-2, 14-1, 16-1 to 16-2, G-1
Pscan - example  . . . . . . . . .  16-2
Qscan  . . . . . . . . . . . . . .  14-1, 16-2
Qscan - example  . . . . . . . . .  16-2
Register mnemonics . . . . . . . .  1-2, D-2
Register saving  . . . . . . . . .  2-1
RUN UUO  . . . . . . . . . . . . .  2-8
Scan block conversion  . . . . . .  2-9
Scan block layout  . . . . . . . .  9-4
Scan blocks  . . . . . . . . . . .  2-9, 2-11, 6-2 to 6-3
Scan controlling flags . . . . . .  4-5
Scan flags - fs.lrg  . . . . . . .  4-5
Scan flags - fs.ncm  . . . . . . .  4-5
Scan flags - fs.nfs  . . . . . . .  4-5
Scan flags - fs.nos  . . . . . . .  4-5
Scan flags - fs.nue  . . . . . . .  4-5
Scan flags - fs.obv  . . . . . . .  4-5
Scan flags - fs.vrq  . . . . . . .  4-5
Scan switches - SL . . . . . . . .  6-2
Scan switches - SN . . . . . . . .  6-2
Scan switches - SP . . . . . . . .  6-2
Scan switches - SS . . . . . . . .  6-2
SCNMAC . . . . . . . . . . . . . .  9-3, C-1
SIXBIT masks . . . . . . . . . . .  2-10
Sl macro . . . . . . . . . . . . .  4-3, 6-2, 15-1, C-3
Sl macro - definition  . . . . . .  C-3
Sn macro . . . . . . . . . . . . .  4-3, 6-2, 15-1, C-3
Sn macro - definition  . . . . . .  C-3
                               Index-6


Sp macro . . . . . . . . . . . . .  4-4, 6-2 to 6-3, 15-1, C-3
Sp macro - definition  . . . . . .  C-3
Ss macro . . . . . . . . . . . . .  4-2, 6-2 to 6-3, 15-1, C-3
Ss macro - definition  . . . . . .  C-3
Storage field - arbitrary routine   6-3
Storage field - byte address . . .  6-3
Storage field - file spec  . . . .  6-3
Storage field - file specification  6-2
Storage field - multiple words . .  6-3
Storage field - word address . . .  6-2
Suffixes - decimal & octal input .  2-4
Switch formats . . . . . . . . . .  3-3
Switch tables - defaults . . . . .  5-4
Switch tables - length . . . . . .  5-4
Switch tables - names  . . . . . .  5-4
Switch tables - processors . . . .  5-4
Switch tables - storage  . . . . .  5-4
Switch types - SL  . . . . . . . .  4-3
Switch types - SN  . . . . . . . .  4-3
Switch types - SP  . . . . . . . .  4-4
Switch types - SS  . . . . . . . .  4-2
Table lookup routine . . . . . . .  17-1
Table searching  . . . . . . . . .  2-8
Testing for logged-in jobs . . . .  2-11
Traditional scanner  . . . . . . .  11-1
TS.DRB . . . . . . . . . . . . . .  C-5
TS.DRP . . . . . . . . . . . . . .  C-5
TS.DRW . . . . . . . . . . . . . .  C-5
TSCAN  . . . . . . . . . . . . . .  3-1, 11-1, 11-4, 12-3, 13-1, 16-1, 
                                    16-5, 16-7, G-2
TSCAN - calling format . . . . . .  11-4
TSCAN - example  . . . . . . . . .  16-5, 16-7
TSCAN flags  . . . . . . . . . . .  C-5
Typing directory information . . .  2-11
Typing error codes . . . . . . . .  B-2
Typing LOOKUP/ENTER blocks . . . .  2-11
Typing OPEN/LOOKUP blocks  . . . .  2-3
Typing PATH Blocks . . . . . . . .  2-11
Typing PPNs  . . . . . . . . . . .  2-3
Typing scan blocks . . . . . . . .  2-11
Universal date/time - conversion .  2-8
Universal date/time - current  . .  2-8
Unversal date/time input . . . . .  2-5
Using the miscellaneous routines .  2-8 to 2-11
Using the miscellaneous routines.   2-8, 2-10
Using WILD . . . . . . . . . . . .  B-1
Verb form scanner  . . . . . . . .  13-1
Version numbers - inputting  . . .  2-6
Version numbers - typing . . . . .  2-3
vscan  . . . . . . . . . . . . . .  3-1 to 3-2, 4-5, 12-3, 
                               Index-7


                                    13-1 to 13-2, 14-1, G-1
vscan - calling format . . . . . .  13-2
Wild . . . . . . . . . . . . . . .  9-2 to 9-3, 9-5
WILD.REL . . . . . . . . . . . . .  15-2
























                               Index-8
 w