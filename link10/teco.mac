	FT$TYM==-1	;TYMSHARE's monitor
IFN FT$TYM,<IF2,<PRINTX [Including TYMCOM-X features]>
;The following prevents CSM's TECO from running at TYMSHARE:
; 1) Cannot handle HISEG origin of other than 400000
; 2) DEVTYP uuo not implemented (to check for DSK)
; 3) GETTAB .GTRDI not implemented (to locate TECO.ERR file)
; 4) TRMOP. .TOTYP not implemented (to do automatic evVT100$)
	.HISEG==400K	;TYMCOM-X can't handle 600K
	F%TYPE==0	;Don't use ITTYPE.REL to read SYS:DISPLA.INI
	L%HALF==777777,,000000	;?not in MACTEN?
	.INFIN==377777,,777777	;?not in MACTEN?
>  ;End of IFN FT$TYM
	F%T20==0	;CSM is not running TOPS20

	SUBTTL	Text Editor and COrrector	RC CLEMENTS/PMH/CAM/JMP/GSB/RCM/CBD/JCS/Nothead/RWS/JMS
	SUBTTL	Introduction


	SEARCH	SYSUNV,JOBDAT,UUOSYM		;[1001] Universal files

	SALL
	.DIRECTIVE	.XTABM	;TENEX STYLE MACRO'S
	.TEXT		~/SYMSEG:HIGH~		;[1001] Put the symbol table
						;[1001]  in the high segment

;[1040] Default is to have the high segment start at 600K (400K for PDP-6 or
;[1040]  KA10)

	IFNDEF	.HISEG,<
	   IFLE <.CPU.-2>,< .HISEG==400K >	;[1040] PDP-6 or KA10
	   IFG <.CPU.-2>,< .HISEG==600K >>	;[1040] KI10, KL10/20 or KS10/20
	$RELOC	TWO,,.HISEG			;[1040] Two segments


	$SHOW	%%SYSU		;[1001] SYSUNV's version number
	$SHOW	%%JOBD		;[1001] JOBDAT's version number
	$SHOW	%%UUOS		;[1001] UUOSYM's version number


;COPYRIGHT 1970,1971,1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;COPYRIGHT 1975 SNEVETS CORP.,BOHOKEN, J.N.
;COPYRIGHT 1976 ARMADILLO U., AUSTINTATIOUS, USA
;Copyright 1978 Privateer U, Bourbon Strut, Nude Oleander, Lousyanna
;Copy-on-write 1979 Samauri Programming, Mile Hi City, Company (abbr.)
;Copywrite 1980 Coronado School of Minds, Coorsville, Color-radio
;Copy-on-write 1985 McDonnel Douglass What-ever-our-name-is-this-month

IFN	0	<

THE FOLLOWING SYMBOL IS USED BY THE 'EE' COMMAND CONTINUE ROUTINE
TO DECIDE WHETHER THE VERSION OF TECO.SHR THAT IT GOTSEG WILL WORK
PROPERLY WITH THE LOW FILE THAT GOTSEG IT.  IT MUST BE INCREMENTED
EVERY TIME THE LOW SEGMENT OF TECO IS ALTERED	>

$INT	%TECOV,	35				;[1001]


	SUBTTL	Table of Contents


;                  Table of Contents for TECO
;
;                            Section                          Page
;
;    1. Introduction . . . . . . . . . . . . . . . . . . . . .   1
;    2. Table of Contents  . . . . . . . . . . . . . . . . . .   2
;    3. Revision History . . . . . . . . . . . . . . . . . . .   3
;    4. Suggestion History . . . . . . . . . . . . . . . . . .   4
;    5. Macro Definitions - CHKEO and ERROR  . . . . . . . . .   5
;    6. Default Assembly Parameters  . . . . . . . . . . . . .   6
;    7. Accumulator Assignments  . . . . . . . . . . . . . . .   7
;    8. Control Flags
;         8.1   AC FF  . . . . . . . . . . . . . . . . . . . .   8
;         8.2   AC F2  . . . . . . . . . . . . . . . . . . . .   9
;         8.3   XFLAGS - Extended Flags  . . . . . . . . . . .  10
;    9. I-O Channels . . . . . . . . . . . . . . . . . . . . .  11
;   10. Miscellaneous Parameters . . . . . . . . . . . . . . .  12
;   11. Pseudo RUN UUO if Needed . . . . . . . . . . . . . . .  13
;   12. Startup Time Initialization  . . . . . . . . . . . . .  14
;   13. Text Buffer Initialization . . . . . . . . . . . . . .  16
;   14. REENTER Command  . . . . . . . . . . . . . . . . . . .  17
;   15. Initialization of Job Dependent Parameters . . . . . .  18
;   16. Rescan Command Processor . . . . . . . . . . . . . . .  19
;   17. CCL Command processor  . . . . . . . . . . . . . . . .  22
;   18. Get a Character in CH for Rescan . . . . . . . . . . .  26
;   19. Return Non-Null TTY Character in CH  . . . . . . . . .  27
;   20. Type a Character . . . . . . . . . . . . . . . . . . .  29
;   21. Message Type-Out & Number Type-Out . . . . . . . . . .  32
;   22. Return Next Command Character at Current Level . . . .  34
;   23. Scan Command String for Character in TT  . . . . . . .  35
;   24. SKAN Routine Dispatch Tables . . . . . . . . . . . . .  38
;   25. Accept Command String Routine  . . . . . . . . . . . .  40
;   26. Expand the Command Buffer  . . . . . . . . . . . . . .  43
;   27. Process Special Command Editing Characters . . . . . .  45
;   28. Special "Immediate" Command Processor  . . . . . . . .  48
;   29. Rubout Processor . . . . . . . . . . . . . . . . . . .  50
;   30. Video Rubout Processor . . . . . . . . . . . . . . . .  52
;   31. Type Current Page of Input . . . . . . . . . . . . . .  56
;   32. Command Decoder  . . . . . . . . . . . . . . . . . . .  57
;   33. Numeric Input, VALRET & ALTmode Processor  . . . . . .  58
;   34. Comma & Parentheses Processor  . . . . . . . . . . . .  59
;   35. Mathematical & Logical Operators . . . . . . . . . . .  60
;   36. Flags - EOF, Form Feed & . H Z Positions . . . . . . .  61
;   37. = (Numeric Input) and ^T (Character Input) Commands  .  62
;   38. ^H (Time), ^F  and ^^ Commands . . . . . . . . . . . .  63
;   39. Extended ^T Operations . . . . . . . . . . . . . . . .  64
;   40. \ (Backslash) Processor  . . . . . . . . . . . . . . .  65
;   41. nA (ASCII Value) Command . . . . . . . . . . . . . . .  66
;   42. Q-Register Commands
;        42.1   U & Q  . . . . . . . . . . . . . . . . . . . .  67
;        42.2   %  . . . . . . . . . . . . . . . . . . . . . .  69
;        42.3   X  . . . . . . . . . . . . . . . . . . . . . .  70
;        42.4   G  . . . . . . . . . . . . . . . . . . . . . .  72
;        42.5   M, W, [ & ]  . . . . . . . . . . . . . . . . .  73
;   43. Miscellaneous Character Dispatcher . . . . . . . . . .  74
;   44. ^G (GETTAB or Exit) Command  . . . . . . . . . . . . .  75
;   45. E Commands
;        45.1   Dispatch Routine & Table . . . . . . . . . . .  76
;        45.2   EL (Setup and Output Routines) . . . . . . . .  77
;        45.3   EE (Save TECO's State) . . . . . . . . . . . .  79
;        45.4   NEL & EE (Low Core)  . . . . . . . . . . . . .  81
;        45.5   EE (Restart Code)  . . . . . . . . . . . . . .  82
;        45.6   EI & EP (Edit Insert & Edit Put) . . . . . . .  83
;        45.7   EX & Exit Routines . . . . . . . . . . . . . .  87
;        45.8   ED (RUN UUO on Exit) . . . . . . . . . . . . .  89
;        45.9   ET, EO & EU  . . . . . . . . . . . . . . . . .  90
;        45.10  ES . . . . . . . . . . . . . . . . . . . . . .  91
;        45.11  EH (Change Error Message Level)  . . . . . . .  92
;        45.12  EV (Set Terminal Characteristics)  . . . . . .  93
;        45.13  Terminal Characteristics Tables  . . . . . . . 101
;        45.14  EK (Kill) and EN (Rename)  . . . . . . . . . . 105
;        45.15  ER (Prepare to Read a File)  . . . . . . . . . 106
;        45.16  File Spec Setup  . . . . . . . . . . . . . . . 108
;        45.17  EB (Edit Backup Processor) . . . . . . . . . . 109
;        45.18  I/O Error Routines . . . . . . . . . . . . . . 112
;        45.19  EW (Prepare to Write a File) . . . . . . . . . 113
;        45.20  EZ & EF  . . . . . . . . . . . . . . . . . . . 117
;        45.21  EM (MTAPE UUO's) . . . . . . . . . . . . . . . 118
;        45.22  EB (Finish Up Command) . . . . . . . . . . . . 119
;        45.23  EW (Subroutines for EW)  . . . . . . . . . . . 122
;        45.24  Miscellaneous Routines . . . . . . . . . . . . 123
;   46. ^V, ^W and ^X Commands . . . . . . . . . . . . . . . . 125
;   47. Routine to Parse File Designator . . . . . . . . . . . 126
;   48. Tables for File Spec Parser  . . . . . . . . . . . . . 130
;   49. Y (Yank) Command . . . . . . . . . . . . . . . . . . . 133
;   50. ^Y ! ^P - Quick Page Scan Commands . . . . . . . . . . 135
;   51. Read a Character from Input File . . . . . . . . . . . 136
;   52. I (Insert) Command . . . . . . . . . . . . . . . . . . 137
;   53. Alpha Case Converted . . . . . . . . . . . . . . . . . 141
;   54. Check for Non-Control Characters . . . . . . . . . . . 142
;   55. nI (Insert) Command  . . . . . . . . . . . . . . . . . 143
;   56. T (Type) Command . . . . . . . . . . . . . . . . . . . 144
;   57. V (View) Command . . . . . . . . . . . . . . . . . . . 145
;   58. Put a Character in the Output File . . . . . . . . . . 146
;   59. PW (Punch and Wait) Command  . . . . . . . . . . . . . 150
;   60. J (Jump), R (Reverse) and C (Character) Commands . . . 152
;   61. L (Line) Command . . . . . . . . . . . . . . . . . . . 153
;   62. K (Kill) and D (Delete) Commands . . . . . . . . . . . 154
;   63. Routine to Return Current Argument in B  . . . . . . . 155
;   64. Searches
;        64.1   Commands . . . . . . . . . . . . . . . . . . . 156
;        64.2   Pattern Source Setup . . . . . . . . . . . . . 157
;        64.3   Set up Search Matrix . . . . . . . . . . . . . 159
;        64.4   New Fast Search Routine  . . . . . . . . . . . 174
;        64.5   Old Slow But Sure Routine  . . . . . . . . . . 177
;        64.6   Pattern Found  . . . . . . . . . . . . . . . . 179
;        64.7   Autotype After Succesful Searches  . . . . . . 180
;        64.8   Pattern Not Found in this Buffer . . . . . . . 181
;   65. <> (Iteration) Commands  . . . . . . . . . . . . . . . 183
;   66. O (Goto) Command . . . . . . . . . . . . . . . . . . . 185
;   67. " ' (Conditional) Processing . . . . . . . . . . . . . 187
;   68. Execute Individual " Commands  . . . . . . . . . . . . 188
;   69. Routine to Test Character for $,%,.,0-9,A-Z  . . . . . 189
;   70. Error Message Printout . . . . . . . . . . . . . . . . 190
;   71. Routine to Type C(TT) in SIXBIT  . . . . . . . . . . . 195
;   72. Error Processing Routines  . . . . . . . . . . . . . . 196
;   73. Dispatch Table for Special Information Typeout . . . . 197
;   74. Special Information Typeout Routines . . . . . . . . . 198
;   75. UUO Handler  . . . . . . . . . . . . . . . . . . . . . 200
;   76. ? Command to Complement Trace Mode . . . . . . . . . . 201
;   77. Routine to Return String Operation String Arguments  . 202
;   78. Routine to Return in CH the Character to the Right o . 203
;   79. Routines to Move Characters Around . . . . . . . . . . 204
;   80. Garbage Collector  . . . . . . . . . . . . . . . . . . 207
;   81. Automatic Memory Expansion . . . . . . . . . . . . . . 211
;   82. Command Dispatch Table . . . . . . . . . . . . . . . . 213
;   83. Low Segment  . . . . . . . . . . . . . . . . . . . . . 214
;   84. The End  . . . . . . . . . . . . . . . . . . . . . . . 216
	SUBTTL	Revision History -- Original

COMMENT	|	Texas TECO edits

START OF VERSION 123A
205	FIX LOOPING EEE.
206	FIX FILE SPEC SCANNER WHEN TRACE MODE USED.
207	CHANGE CORE ERROR MESSAGE.
210	ADD ^G WITH NO ARGUMENT TO RETURN MY JOB NUMBER.
211	FIX :EP SO IT WORKS.
212	IMPLEMENT ^Y.
213	SO PEOPLE WITHOUT TECO.INI CAN ^G^G *I$$ FIRST COMMAND.
214	EI-EP SEES DEVICE.
215	NO TYPEOUT AFTER ^C^C REE.
216	EP[P,PN] INTERFERED WITH EB.
217	REMOVE FEATURE TO APPEND LOOKUP/ENTER/RENAME ERROR CODE TO PDL OV'S.
220	FIX RANDOM CORE MESSAGES FROM INI FILES.
221	INTERFACE TO JOBDAT.UNV AND CORRECT MISC BUGS.
	 A) FIX 'MAKE' OR 'TECO' FILE.'.' WORK CORRECTLY
	 B) SUPPORT SOS PAGE MARKS
	 C) SET TTY NO ALT COMPATIBLITY
	 D) DELAY IN CLEARING EB AND OUTPUT FLAGS ON EX
	    COMMAND IN CASE ERROR OCCURS IN PROCESSING
222	SEARCH MACTEN AS WELL AS JOBDAT
223	INTERFACE WITH MACTEN MORE COMPLETELY. CLEAN UP THE SUBTTLS AND
	CHANGE NUMERICS TO BE THE INSTRUCTIONS
224	FIX ENTER ERROR 17'S FOR PEEPLE WHO HAVE FANCY DISK ALLOCATION
	ON IN THE MONITOR.
225	FIX PROBLEM WITH U MACRO. ADD TED: AS THE DEFAULT DEVICE ON
	AN EI OR EP COMMAND.
226	MAKE EP DEFAULT TO DSK: INSTEAD OF TED:
227	MAKE ERROR MESSAGE FINDER FASTER
230	FIX ^Y WITH NO ARG TO NOT THROW AWAY CURRENT PAGE
231	ADD USETI ON ER'D FILE FOR CONVENIENCE.
232	FIX EA TO WORK IF FILE NO EXIST, MAKE TE FILE[NOT ME] TO
	WRITE FILE ON [DEFAULT]
233	PREVENT S^ES$ FROM ALLOWING "." TO ESCAPE THE TEXT BUFFER.
234	FIX :SEARCH IN AN ITERATION TO NOT LEAVE GARBAGE AROUND.
235	FIX PROBLEMS WITH TECENT-20 ERRORS. EXTENDED ENTER USED THE
	SAME AREA AS DID THE SEARCH MATRIX. THEREFORE TO SOLVE
	THE PROBLEM MAKE THAT AND THE DSKCHR BLOCK SEPERATE AREAS.

***START OF U. TX. REVISIONS****  (236-249 NOT USED;PATCHES ONLY,
				   SEE TEC124.DIF FOR NEW FEATURES)

250	INSTALLED DEBUG SWITCH TO SAVE SYMBOL TABLE AND READ TECO.ERR
	FROM [-] RATHER THAN SYS:.  (= DEC #140)
251	PATCH FOR LARGE Q-REG STACK (SPR # 13756)
252	DO AN INITIAL CORE UUO IF .JBFF > .JBREL-202 TO PREVENT
	ILL MEM REF'S.
253	MAKE ^G<SPACE> IGNORE ET SETTING AND ALWAYS USE ARROW MODE
254	FIX ^<LOWER CASE A> BUG  (SPR # 18802)
255	FIX ILL Q-REG NAME  (DEC EDIT # 170)
256	MAKE BYTE PTR. BACKUP MORE EFFICIENT
257	DONT LET EXTRA BLANKS IN AN ARITHMETIC EXPRESSION CAUSE TROUBLE
	(DEC EDIT # 167)
260	MAKE SURE M,NP FLAGS BIT 35 OF FIRST SEQ. NUMBER.
	REMOVE DEC #122 WHICH ONLY DID IT FOR HP.
261	MORE SEQ# FIXING:  /SUPLSN NEEDS TO USE SLOW PUNCH ROUTINE
	FILES PROCESSED BY SOS NO LONGER MESSED UP.  INSTALL EQUIVALENTS
	OF DEC #'S 115, 141, 150.
262	STILL MORE SEQ# FIXING:  DON'T ALLOW NULL CHARACTERS IN FILE
	(INTENDED FOR STARTING SEQ #'S ON WORD BOUNDARIES) IF /SUPLSN
	IS SET.
263	ZERO DOUBLE ARG FLAG IN SEARCHES SO THAT SUBSEQUENT COMMANDS
	DON'T GET CONFUSED.
264	FIX :FS...$$ SO IT RECOGNIZES DOUBLE ALTMODE.  (SPR # 18199)
265	FIX GARBAGE COLLECTION BUG (DEC EDIT # 161)
266	FIX ?ILL COMMAND ^<CHAR>  (SPR # 18607)

NOTE:  ALL DEC EDITS THROUGH 171 OR THEIR EQUIVALENTS ARE IN.
START OF VERSION 124

267	FIX ADDRESS CHECK ON LOOKUP OF TMP FILE WHEN TMPCOR FAILS.
270	MAKE UUO ERROR MSG TYPE ENTIRE INSTRUCTION (SPR#19879)
271	FIX GARBAGE COLLECTION FROM EC AND EP.  Q-REGISTER STACK WASN'T
	GETTING COLLECTED SINCE AC 17 CLOBBERED.
272	FIX ILL. UUO MSG AFTER .REENTER WHILE AC'S HAVE FAST CODE TO
	MOVE CHARACTERS.  FIX MINOR BUGS IN FILESPEC SCANNER AND /R.
273	MAKE EXTENDED CCL COMMAND STRING WORK WITH .TMP FILES
274	FIX ILL. UUO. BUG RIGHT THIS TIME...(EDIT 272 GOOFED).
275	FIX BAD ARG PROCESSING TO MAKE THINGS LIKE -1^F= AND
	:5-1^T== AND -1A==  WORK PROPERLY. FINALLY GET EI ARG
	PROCESSING TO WORK PROPERLY.  M,NEIFILE$ WORKS, AS WELL AS
	MEIFILE$ AS WELL AS M,EIFILE$  (WHERE FILE HAS THE SECOND
	ARG ALREADY).
276	FIX BUG IN ERROR MSG FILE ACCESS.  MAKE ^G WITH ONLY ONE
	ARG DO A PEEK INSTEAD OF A GETTAB.
277	SAVE A WORD WASTED BY EDIT 261.  INSTALL DEC EDIT 172 (PROPER BOUNDS
	CHECKING). INSTALL EQUIVALENT OF DEC EDIT # 174.
300	FIX FAILURE WHEN RENAMING THE .TMP FILE (EB) IN AN AREA NOT
	YOUR OWN.

*** BACK TO STEVENS/RAPIDATA AGAIN

277A	FIX BUG IN REENTER (P MAY NOT CONTAIN A PDL)
300A	FIX ARGS FOR TRMOP. TO GET TTY WIDTH
301	CHANGE E<CHAR> SELECTION ALGORITHM
302	CHANGE .RB??? DEFINITIONS SO THAT THEY USE UUOSYM.
303	Removed.
304	CHANGE THE FLAG NAMES AND THE DEFINITIONS.  NOW USE THE TX??
	MACROS	FROM MACTEN FOR THE FLAGS.
	FF	FLAGS ==>  F.????
	F2	FLAGS ==>  S.????
305	BISSW was added to allow TECO to make limited use of the
	Business Instruction Set.  The code will not be removed,
	but it will also not be used.  It turns out to be considerably
	slower than TECO's old mechanism and move string backwards.
	is not possible.
306	Change the error code for Undefined Terminal Type
307	See edit 277.
310	Add /INPLACE so that EB will ER EW to same place.
311	Finish fixing the flags (Edit 304).
312	Remove the PDP6 feature test.

***BACK TO TEXAS...

313	Increase efficiency of FS when both strings are the same length
	by skipping character-moving code.
314	Work on CRT stuff some more.  Make treatment of no wrap-around
	better.  Add ^N20 to error routines to type list of valid CRT types.
315	Modify EW defaulting so that it won't use the ER device if it is
	an ersatz. (For the same reason that it won't use ER's PPN.)

	Equivalents of DEC EDITS up to 174 are in. Also 176.
316	Fix SKAN routine so that the character after a PW
	is not ignored and so that  @FD/.../ gets scanned properly.
317	Fix /SUPLSN.  Slow punch routine will be used on a sequenced
	file IF /SUPLSN not set for INPUT file.  Minor bugs in
	default PPN handler, initalization, and edit 313.
320	Fix EA so that privileged programs don't bomb if the LOOKUP
	fails.  (Monitor thinks USETI is a super.)  Fix bug in *i
	command: X3 routine should not add the garbage collection
	constant in this case.  Add ADDS 580 terminal by popular
	demand.  Fix a very rare ill mem ref bug:  if MEMSIZ falls
	exactly on a 1K boundary, and Z is allowed to equal MEMSIZ,
	then the routine at NROOM6 fails, since it must reference
	(Z/5)+1. So make sure Z always stays less than MEMSIZ.
321	Fix X command to allow buffer length of greater than 2**18
	characters; i.e. do not use immediate instructions to perform
	necessary arithmetic.

***The following adapted from Storage Technology Corp.'s revisions.
322	Fix double OCT error if first character of new command is
	8 or 9.
323	Add "\\" command which reads/writes same as "\" but in octal.
324	Add VT50 terminal.

325	Add three immediate commands which work if they are the
	first things typed:   <LF> = 1LT, <^H> = -1LT, and, in the
	spirit of DDT, <;> = 0LT.  Fix several bugs in log file processing:
	^G's were getting inserted twice; * commands weren't being
	inserted at all; first character in log file (usually *)
	missing if previous command was ^G^G'ed.
326	Change INIT to OPEN in TTOPEN and CCLTMP.
	Fix an obscure search bug which makes S^ES$ blow up
	if the character after the end of the buffer HAPPENS
	to be a blank or tab.
327	Fix serious problem arising when ^P and ^Y are used on
	sequenced files.  n^P usually threw away page n-1; ^Y
	went into an infinite loop.
330	Fix bug in \\.
331	Fix Ill Mem Ref in ";" immediate command.  Add H1500, ADM3A,
	ACT-IV, ACT-V and HP2640 terminals.  Improve handling of
	; and ^H commands.  Modify ET command: 2ET means image typeout.
	Clear digit string bit to prevent 2.5 or 3Z4 from returning
	wierd values.
332	Improve U command.  m,nUi will now store the value n into
	Q-reg i, and return m.  This allows m,nUiUj to store two
	values, such as those passed to a macro.  Improve [ command.
	n[i now behaves like [inUi, allowing the Q-reg to be saved
	bea value is stored.  m,n[i[j will work as described
	above.  Issue error msg if attempt to store a number smaller than
	-377777,,0 octal.

333	Support File Daemon, improve protection logic for EB's.
	.BAK files will always be given a protection of 0xx or 4xx.
334	Replace complete searching algorithm. (U. of New Orleans)
335	Change EO level to 3, and restore several of the obolete
	DEC features for EO < 3, such as position of pointer after
	searches, etc. (NSA)
336	Don't shrink too much after an EI file is processed, so that
	the purpose of "R TECO 50K" isn't defeated by the initial
	EITECO.INI.
337	Change EI-EP file defaulting.  If no device or directory is
	specified, first look on [-], then on [,,TEC]/SCAN,
	and finally on TED:.  Add /DEFAULT I/O switch to clear
	sticky defaults.  Read TECO.ERR from the device and PPN that
	TECO was run from; if that fails, try SYS:.  Other minor
	changes to error message processing.  Change /READ to /READONLY.
340	Add warning message for ER and EB when file is found in
	directory other than the one specified (LIB: or /SCAN).
	Fix /INPLACE so it will really overwrite the file in these
	cases.  Fix EN so file stays in the same directory unless
	a new directory is explicitly given.
341	Fix Ill mem ref in ^N processing for new search.
342	Fix backwards bounded searches which occur after the pointer.
	For example, HK IA12345$ J 6,0S123$$ shouldn't fail.
	Fix core problem preventing REENTER after ^Z.
343	Modify CCL command handler to support MAKE A=B command.  Change
	our pseudo altmode character from % to $ (dollar sign).
	Make EWfile/APPEND$ equivalent to EAfile$.  Make EBfile/READONLY$
	equivalent to ERfile$.
344	Fix several bugs in slow search algorithm.  Due to overwhelming
	popular demand, finally remove DEC's "feature" which
	treats all searches inside iterations as colon searches.
	Such searches will never issue an error message, but
	if EO > 2, they will now return no value.  Semi-colons
	will still work correctly, since a ; with no arg looks at
	what happened in the last search.  Searches using a previous
	string will now remember the exact match setting.
345	Fix LSN routines to properly handle page marks. (DEC edit 217).
346	Implement generalized nA command, which returns the ASCII value
	of the nth character to the right of the pointer. 0A
	returns the character to the left, and -nA returns the
	n+1st character to the left of the pointer.  If .+n-1 is
	out of bounds, a 0 is returned.  An m,nA command will
	cause m to be returned if the character is out of bounds.
	Implement :nA command to append n lines to the buffer.
347	Implement the nV command equivalent to n-1TnT.

*** Start of Version 124A ***
NOTE:  All applicable DEC edits through 226 have been installed.

350	Make sure there is room for at least 5000 characters when
	TECO starts up.
351	Don't issue "Superseding existing file" message if /INPLACE.
	Fix V command for negative numbers.
352	Fix Ill mem ref in CCL command processor when TMP file doesn't
	end with <cr> or "}".
353	Fix problem with EB close routine so that it doesn't get fooled
	by old .BAK and .TMP files not in the default path.
354	Fix Ill. Mem. Ref. after TECO runs out of core.
355	Fix another Ill. Mem. Ref in EP command.  Make EP a little faster.

|  ;End of Original Revision History

EDTORG==355	;Highest original edit (before EE and CSM started hacking)
SUBTTL	Revision History -- Energy Enterprises

COMMENT	|
1001	Convert to use some local macro in SYSUNV and change the
	NROOM routine to be more symbolic when loading the ACs
	with the buffer moving code.
1002	Change some of the immediate commands, <^H> and <ESC> do
	'-LT', and <;> and <BEL> do '0LT'.
1003	Search SYS:DISPLA.INI for the default video type on start
	up and the command EV$, and add some new terminal types:
	  1) Concept 100 (CONCEP)
	  2) Computer Peripheral COPS-10 (COPS10)
	  3) CRT with standard rubout processing (CRTRUB)
	  4) Datamedia Elite 1521 (DM1521)
	  5) Soroc IQ-120 (IQ120)
	  6) DEC VT100 (VT100)
	  7) DEC VT105 (VT105)
1004	Change the FD command to the FK command (Find and Kill) and
	add a new FD command (Find and Delete) which searches for a
	string and deletes it and only it.
	  Example:  FD<string>$ -> FS<string>$^V$
1005	Clear the E-O-F flag (F.EOFI) on ^U command.
1006	Clear the ^V and ^W flags after the search potion, but before
	the insert portion of a FS or FN command.
1007	New command:  EQ - Edit Quit which is the same as the EX
	command except it doesn't return to monitor level.
1010	Fix the *q command on TOPS-20, the Q-register was being loaded
	with zeros.
1011	Add some code to rescan the monitor command line and a TOPS-20
	EG command.
1012	Remove the 'S' kludge from the CCL entry.
1013	New command:  n%q - add n to the contents of Q-register q and
	return the result.
1014	New command:  n"R - execute the conditional command(s) if n is
	the ASCII code for an alphanumeric (A-Z, a-z or 0-9).
1015	New command:  ^ER - Same as an ^E[^EA,^ED] in a search command.
1016	New command:  :nL - Same as a nL command except the pointer is
	placed before the EOL (and carriage-return if present) instead
	of after.
1017	New command:  F_ - Same as FN except the output is lost.
1020	New switch:  /NOYANK - Disable the automatic yank (EY) on a CCL
	EB or EW/ER command.
1021	New switch:  /YANK - Enable the automatic yank (EY) on an ER or
	EB command.
1022	Increment the page number on EOF.  So the last page doesn't have
	the same page number as the next to last page.
1023	New commands:  :I/:^I - Go to the end of the line then start
	inserting.
	Note:	:Itext$  -> :LItext$
		:^Itext$ -> :L^Itext$
1024	New command:  :nEF - Start adding the 'Truth-in-Paging' mode
	code.  When a page is read into core the entire page is read
	in, from form-feed to form-feed no matter long the page is.
	Note:   :nEF -> Sets the extended flags.
		:EF  -> Read the extended flags.
		  ^O1 = Set 'Truth-in-Paging' mode.
		  ^O2 = Output page number if changed from the last
			time.
		  ^O4 = Disable the immediate mode commands.
1025	Conform to the 'Error message standard' on the internal error
	messages, such as [4K Core].
1026	New command:  :Qi - Return the number of characters in Q-reg-
	ister i as a value.
1027	New command:  n^T - Output the character whose ASCII value is
	n.  Same as :n,1T.
1030	New commands:  n">/n"< - Same as n"G and n"L.
1031	Output a CR-LF after the immediate mode *.
1032	More of edit 337, don't save the PPN the second time TECO is
	started, AC 7 will probably contain junk.
1033	More of edit EE-7, the EQ command didn't work when executed in
	a macro, the PDL was left hosed up.
1034	Make the rescan code work on TOPS-10, TOPS20/EXEC doesn't put
	a carriage-return in the rescan buffer.
1035	New commands:  0^P/0^Y - which go to the end of the input file.
1036	Add support to get the terminal type from the monitor.  (From
	CSM)
1037	Add Q-register "@" which is executed when a space is typed as
	the first character after the prompt.  (From DEC)
1040	Add support to have a low segment larger than 128K, non-KA10.
	(The non-Q-register code came from DEC)
1041	Add support to allow a number of input and output buffer at
	assembly time.  (From DEC).
1042	If the TRMOP. to get the terminal type fails and we are
	running on TOPS-20 try the JSYS to get the terminal type.
	(From DEC)
1043	Add a new terminal type, Tektronix 4025 (TK4025).  (From
	CSM)
1044	Clear the run-offset for 7.01, it thinks its a very large core
	request, 1EDprog$
1045	Make TECO on TOPS-20 look up PS:TECO.INI[logged-in-directory].
1046	Force the MAKE or TECO command to abort if no previous command
	was given.
1047	Don't output "-n" if user doesn't want prefix.
1050	Add the :nK command which is a :nL command except it deletes
	everything is skips over.
1051	Add the n,mD command which is the same as the n,mK command.
1052	Allow spaces and tabs before the rescan command.
1053	Output the page number before the 'type' command is processed.
	This is an extension of the :2EF feature.
1054	Add support for pseudo non-PS LOGIN's.
1055	Improve on CSM Control-W support, allow it on non-CRT's, and make
	it work like TOPS-20.
1056	Make '^G*' work just like '^G.'.

|  ;End of EE Revision history

EDTEE==1056	;Last EE edit
SUBTTL	Revision History -- Colorado School of Mines

COMMENT	|
2001	Add a new terminal type, VIS200 for Visual 200 in VT52 mode.
2002	Watch out for comments, ^G, ^Z, etc. when doing a rescan.
2003	Output the appropriate message when rescan get "Make love".
2004	Add MUNG command (same as the 11 MUNG command).
2005	Ignore comments in SYS:DISPLA.INI.
2006	Get the lower case bit for the terminal early, so that lower-
	case characters will be flagged properly if output befor the
	first prompt (such as in TECO.INI or via a MUNG command).
2007	Allow "TK4006=TTY" in DISPLA.INI to mean that if the TRMOP.
	returns "TK4006", pretend it is "TTY".
2010	Add a new extended flag to suppress the core expansion mes-
	sages, such as "[TECXPN nK core]".  Useful in macros that
	expand core, it is set by default in the MUNG command.
2011	Fix a hole in the EB/FILDAE logic.  <777> means owner cannot
	rename or write, but a bug in the CHKACC UUO returns 0, imply-
	ing rename ok.  Also, looking at the FILDAE feature test bit
	is not enough, see if FILDAE is running.
2012	Use ITTYPE.REL to read SYS:DISPLA.INI if F%TYPE=-1.
2013	Add Control-W, delete word, support.
2014	Make sure .JBVER changes for each EE edit and each CSM edit.
2015	Remove EV CRTRUB$ because 7.01 or DISPLA.INI defines all terminal types,
	add LA34, and LA36 so ITTYPE won't have to read DISPLA.INI.
2016	Add /NOBAK as synonym for /INPLACE (new habits from SED editor).
2017	If ".SET TTY DISPLA", then set :16EF at startup so ^W deletes words.
	This feature may be turned off BY LOGIN/TERMINAL:(NODISPA) in SWITCH.INI
	or by TECO.INI.
2020	Add more terminal types.
2021	Add HP2621 and TYM444
|	;End of CSM revision history

EDTCSM==2021	;Last CSM edit number
SUBTTL	Define the version number and TITLE

	DEFINE $EDITL($EDIT),<	$VRSN	TEC,124A($EDIT)-2 > ;Combined edit level
	$EDITL \<EDTORG+<EDTEE&777>+<EDTCSM&777>>	;[2014] increment .JBVER

	$TITLE	TECO - Text Editor and COrrector,TEC
	$PASS	TECO,TEC

	$ABS	.JBCST		;[2014] .SET WATCH VERSION types this loc @ CSM
	<EDTEE&777>*1000+<EDTCSM&777>	;[2014] Put in EE and CSM edit numbers

	$ABS	.JBVER		;[1001] Inform the word of my version number
	TEC.VN			;[1001] The version number

	$ABS	.JBREN		;[1001] Inform the monitor of my reenter address
	EXP	REE		;REENTRY ADDRESS

	$HIGH			;[1001] Back to the high segment
	SUBTTL	Macro Definitions - CHKEO and ERROR

;CHECK EO FLAG: CHKEO	EO#,ADDR
;IF EOFLAG > EO#, RETURN AT CALL+1
;OTHERWISE GO TO ADDR

DEFINE	CHKEO(E,A)
	<1B22+<E>B30,,A>

;TYPE ERROR MSG: ERROR	E.XXX
;TYPE MESSAGE CORRESPONDING TO 'XXX'
;THEN GO TO GO

;THE FOLLOWING IS THE DEFINITION OF THE REGULAR ERROR UUO

DEFINE	ERROR(X)
	<1B8+'X'
	'X'=<''X''>&777777>

;THE FOLLOWING IS THE DEFINITION OF THE COLONABLE ERROR MESSAGES
;THIS IS USED FOR THE NEW ERROR HANDLING WITH COLON CONTRUCTION
;IF AN ERROR OCCURS AND THE ..ERROR UUO IS EXECUTED, THE COLON FLAG
;IS CHECKED TO SEE WHETHER YOU SHOULD RETURN A VALUE OF 0 OR PROCEED
;AND TYPE OUT THE ERROR MESSAGE

DEFINE	..ERROR(X)
	<1B8+10B12+'X'
	'X'=<''X''>&777777>

OPDEF	TYPR1 [2B8]
	SUBTTL	Default Assembly Parameters

$ND	CCL,    1			;CCL CAPABILITY
$ND	TEMP,   1			;TMPCOR UUO CAPABILITY
$ND	RUBSW,	0			;DON'T MIMIC MONITOR
$ND	NORUNS,	0			;RUN UUO CAPABILITY
$ND	AUTOFS,	0			;DEFAULT IS NON-AUTOTYPE AFTER SEARCHES
$ND	TYCASW,	0			;DEFAULT TYPE-OUT MODE CAUSES FLAGGING OF
					;CHARACTERS IN THE LOWER CASE RANGE WITH '
$ND	SRCHSW,	0			;DEFAULT PREVAILING SEARCH MODE IS ACCEPT
					;EITHER LC OR UC ALPHABETICS AS A MATCH
$ND	BUFSIZ,	^D128			;128 WORD I/O BUFFERS
$ND	LPDL,   ^D80			;80 WORD PDL
$ND	LPF,    ^D32			;32 WORD Q-REGISTER PDL
$ND	VC,	0			;OLD V COMMAND NOT IMPLEMENTED,
					;[347] USE NEW V COMMAND INSTEAD
$ND	EOVAL,	^D3			;[335] THE STANDARD SETTING OF THE EO FLAG FOR
					;THIS VERSION IS 3
$ND	BUGSW,	0			;STANDARD IS DON'T SAVE SYMBOLS
$ND	CRT,	1			;CRT RUBOUT HANDLING CAPABILITY
$ND	BISSW,	0			;SUPPORT BIS (SLOW...)
$ND	F%RSCN,	1			;[1011] Command line rescan
$ND	F%T20, -1			;[1052] TOPS-20 features, no saving
					;[1052]  of EXEC commands in TMPCOR
$ND	LNQTAB, ^D38			;[1037] Q-register table size
$ND	NIBUF,  ^D3			;[1041] Number of input buffers
$ND	NOBUF,  ^D3			;[1041] Number of output buffers
$ND	F%TYPE,  -1			;[2012] Use ITTYPE.REL to get TTY type

IFN F%TYPE,<
   .REQUEST REL:ITTYPE.REL		;[2012] Request REL:ITTYPE.REL
   IF2,<	PRINTX [Loads with REL:ITTYPE] >>


;FOR ANY OTHER VERSION ASSEMBLE AS FOLLOWS:
;.R MACRO
;*TECO_TTY:,DSK:TECO.MAC
;CCL=0				(IF CCL NOT WANTED)
;TEMP=0				(IF TMPCOR UUO NOT WANTED)
;ERRMSG=1			(IF SHORT ERROR MESSAGES WANTED OR
;				 =3 IF EXTRA LONG ERROR MESSAGES WANTED)
;NORUNS=1			(IF RUN UUO SIMULATION WANTED)
;AUTOFS=-1			(IF DEFAULT = AUTOTYPE AFTER SEARCHES WANTED)
;TYCASW=1			(IF TYPE-OUT CASE FLAGGING DEFAULT VALUE
;				 TO FLAG UPPER CASE INSTEAD OF LOWER CASE
;				 CHARS. WANTED)
;TYCASW=-1			(IF TYPE-OUT CASE FLAGGING DEFAULT VALUE
;				 FOR NO FLAGGING WANTED)
;SRCHSW=1			(IF EXACT MODE WANTED AS THE DEFAULT VALUE
;				 OF THE PREVAILING SEARCH MODE)
;BUFSIZ=^D256			(IF 256-WORD I/O BUFFERS WANTED. ANY
;				 OTHER CONSTANT BESIDES 256 MAY BE USED.
;				 TECO USES STANDARD MONITOR BUFFERING,
;				 BUT IF THE MONITOR PROVIDES BUFFERS
;				 LARGER THAN 128 WORDS, BUFSIZ MUST BE
;				 CHANGED SO THAT SUFFICIENT SPACE IS
;				 RESERVED.
;LPDL=N				(WHERE N	120, IF LARGER PDL WANTED)
;LPF=N				(WHERE N	40, IF LARGER Q-REGISTER PDL WANTED)
;EOVAL=N			(WHERE 0<N<3, IF EO-CONTROLLED FEATURES ADDED
;				 SINCE EO=N WAS STANDARD ARE NOT WANTED)
;BUGSW=1			(IF SAVE OF SYMBOL TABLE IS DESIRED)
;CRT=0				(IF CRT RUBOUT HANDLING NOT WANTED)
;BISSW=1			(If BIS support is wanted)
;F%RSCN=0			(If command line rescan isn't wanted)
;F%T20=0			(=0  TOPS-10 features are wanted,
;				 =+1 TOPS-20, to save EXEC command in TMPCOR
;				 =-1 TOPS-20, don't save EXEC command in TMPCOR)
;LNQTAB=n			(To change the size of Q-register table)
;NIBUF=n			(To change the number of input buffers)
;NOBUF=n			(To change the number of output buffers)
;F%TYPE=0			(To use internal routines for SYS:DISPLAY.INI)
;^Z
;^Z


IFN F%T20,<
   SEARCH	MONSYM		;[1011] Get some TOPS-20 symbols
   IF1,<
      PRINTX	[Assembling TECO for a TOPS-20 monitor] >>
	SUBTTL	Accumulator Assignments

FF=	0	;CONTROL FLAGS
P=	1	;PUSH DOWN POINTER
		;*** A, AA AND B MUST BE CONTIGUOUS AND IN THAT ORDER ***
A=	2
AA=	3	;TYPE-IN POINTER TO COMMAND BUFFER & SEARCH TABLE INDEX
		;*** B AND E MUST BE ADJACENT AND B<11 ***
B=	4	;COMMAND BUFFER END ADDRESS
E=	5
C=	6
D=	7
F2=	10	;MORE CONTROL FLAGS
T=	11
		;*** TT AND TT1 MUST BE ADJACENT ***
TT=	12
TT1=	TT+1
I=	14
OU=	15
CH=	OU+1	;CHARACTER AC
PF=	17	;Q-REGISTER PDL PTR
	SUBTTL	Control Flags -- AC FF

;RIGHT HALF - AC FF

F.ALT==	1B35		;ALT-MODE SEEN
F.ARG2==1B34		;THERE IS A SECOND ARGUMENT
F.ARG==	1B33		;THERE IS AN ARGUMENT
F.SRCH==1B32		;REPLACEMENT SEARCH
F.SLSL==1B31		;@ SEEN
F.NSRH==1B30		;N SEARCH
F.COLN==1B29		;COLON SEEN
F.SYL==	1B28		;SYLLABLE FLAG
F.XPLN==1B27		;HAVE TYPED EXTENSION OF ERROR MESSAGE ALREADY
F.EM==	1B26		;HAVE TYPED 1ST LINE OF ERROR MESSAGE
F.LARW==1B25		;LEFT ARROW SEARCH
F.EMSG==1B24		;PROSESSING ERROR MESSAGE
F.SQIN==1B23		;OUTPUT: AFTER EOL NEXT 5 CHARS ARE SEQ #
			;INPUT:  IGNORE CHAR AFTER SEQ# IF IT'S TAB
F.TRAC==1B22		;? SEEN
F.SEQ==	1B21		;SEQUENCE NUMBER SEEN ON INPUT
F.BELL==1B20		;^G SEEN
F.DDTM==1B19		;NEED TO TYI IN DDT MODE
F.FORM==1B18		;A FORM FEED TERMINATED THE LAST YANK OR APPEND COMMAND

;LEFT HALF - AC FF

F.IMAG==1B17		;[331] TYPEOUT IN IMAGE MODE
F.PMAT==1B16		;PREVAILING MATCH MODE
IFN VC,<
F.TABS==1B15		;TAB CORRECTION FOR VVAL
>
F.NNUL==1B14		;NON-NULL INSERT STRING (MIGHT BE ONLY ^V, SAY)
F.NEG==	1B13		;MINUS SIGN SEEN AS AN OPERATOR
F.KILL==1B12		;[1004] Processing an FK command
F.EOFI==1B11		;INPUT CLOSED BY EOF
F.IOPN==1B10		;INPUT FILE IS OPEN
F.OOPN==1B09		;OUTPUT FILE IS OPEN
F.EBTP==1B08		;EB FUNCTION TEMPORARY FLAG
F.FILE==1B07		;AT LEAST ONE ELEMENT OF FILE SPEC GIVEN
F.PROT==1B06		;FILE PROTECTION WAS SPECIFIED
F.INIT==1B05		;INIT FILE READING
F.UBAK==1B04		;EB IN EFFECT
F.TALK==1B03		;MESSAGE TYPE OUT IN GRABAK?
F.TYOF==1B02		;NEED TO OUTPUT A BUFFER
F.TCTL==1B01		;ALLOW CONTROL CHARS TYPED WITHOUT "^"
F.CCL==	1B00		;TECO COMMAND REQUESTS Y AFTER EB
	SUBTTL	Control Flags -- AC F2

;RIGHT HALF - AC F2

S.CTLV==1B35		;^V SEEN INSIDE TEXT
S.CTVV==1B34		;DOUBLE ^V SEEN INSIDE TEXT
S.CTLW==1B33		;^W SEEN INSIDE TEXT
S.CTWW==1B32		;DOUBLE ^W SEEN INSIDE TEXT
S.XMAT==1B31		;EXACT MATCH SEARCH MODE
S.EMAT==1B30		;TEMPORARILY ACCEPT EITHER UPPER OR LOWER CASE
S.LCTT==1B29		;TTY LINE HAS LC BIT ON
S.NCFL==1B28		;TYPE MESSAGE WITH NO CASE FLAGGING
S.OCTL==1B27		;OCTAL RADIX
S.CTLR==1B26		;^R SEEN AT INPUT TIME
S.SKMR==1B25		;WATCH FOR ^R WHEN SKIMMING
S.SKMQ==1B24		;WATCH FOR ^Q WHEN SKIMMING
S.NTRC==1B23		;DISABLE TRACING
S.TXTC==1B22		;TYPE <CR>, ETC INSTEAD OF PRINTER CONTROLS
S.SFSN==1B21		;SKANNING FS OR FN
S.NCCT==1B20		;NO CONTROL COMMANDS IN TEXT EXCEPT ^T, ^R
S.LCAS==1B19		;CONVERT UPPER CASE TO LOWER CASE BY DEFAULT
S.UCAS==1B18		;CONVERT LOWER CASE TO UPPER CASE BY DEFAULT

;LEFT HALF - AC F2

S.GOIN==1B17		;A COMMAND STRING HAS BEEN SEEN
S.CTLN==1B16		;^N IN SEARCH ARGUMENT
S.NALT==1B15		;DON'T CONVERT OLD ALTMODES TO 033
			;**** S.NRAD & S.YANK ARE EQUAL, THIS IS OK
S.NRAD==1B14		;NULL REPLACEMENT ALTMODE DELIMITED
S.YANK==1B14		;^Y NOT ^P IN PROGRESS
S.LOPN==1B13		;LOG FILE OPEN
S.INFO==1B12		;INFORM USER OF ANY CORE CHANGE WHEN DONE
S.DOIT==1B11		;M<FILE> AS OPPOSED JUST HX*<FILE>
S.CRLF==1B10		;[1037] If on DON'T output a CR-LF
S.EA==	1B09		;EDIT APPEND IN PROGRESS
S.MINS==1B08		;MINUS SEARCH
S.DELS==1B07		;TO DELETE TO FROM START TO PT SEARCH
S.ASTR==1B06		;DON'T PRINT STAR
S.SSEQ==1B05		;SUPPRESS SEQUENCE NOS ON INPUT
S.SLOG==1B04		;UNDER NO CIRCUMSTANCES SEN CHARACTER TO LOG FILE
S.OLOG==1B03		;WHEN AT TYOA, STICK IT IN THE LOG FILE ONLY
S.LIN==	1B02		;PUT YOUR TYPE IN IN THE LOG FILE
S.LOUT==1B01		;PUT TECO'S TYPE OUT IN THE LOG FILE
S.DPPN==1B00		;REMEMBER TO DEFAULT TO ZERO PPN
	SUBTTL	Control Flags -- XFLAGS - Extended Flags


;Define the flags used in XFLAGS

	XF.TIP==1B35		;[1024]  1 Truth-in-paging mode is in effect
	XF.CPN==1B34		;[1024]  2 Current page number is wanted
	XF.DIM==1B33		;[1024]  4 Disable immediate mode commands
	XF.NIM==1B32		;[2010]  8 No information messages
	XF.CNW==1B31		;[1055] 16 Allow Control-W processing
	SUBTTL	Control Flags -- DTB - Dispatch Command Flags


;Define the flags used in DTB

	DC.JMP==0B1		;[1055] Simple JRST command dispatch
	DC.SUB==1B1		;[1055] Subroutine command dispatch
	DC.NUM==2B1		;[1055] Numeric argument on JRST command dispatch
	DC.ALP==0B4		;[1055] The character is a alphanumeric
	DC.SPC==1B4		;[1055] The character is a space/tab
	DC.SYM==2B4		;[1055] The character is a non-alphanumeric
	DC.EOL==4B4		;[1055] The character is an E-O-L
	SUBTTL	I-O Channels

;I-O CHANNELS

INCHN==	2
OUTCHN==3
TTY==	4	;CHANNEL FOR TTY IO
CCLCHN==5	;CHANNEL FOR THE CCL TMP FILE
ERRCHN==6	;CHANNEL FOR ERROR MESSAGE FILE
LOGCHN==7	;CHANNEL TO WRITE LOG FILE ON (IF ANY)
SAVCHN==10	;TO WRITE LOW SEG SAVE ON
INICHN==11	;TO READ INI FILE ON
VIDCHN==12	;[1003] To read SYS:DISPLA.INI
	SUBTTL	Miscellaneous Parameters

BEGPAG==200	;FAKE ASCII CHAR = BEGINNING OF BUFFER
ENDPAG==201	;FAKE ASCII CHAR = END OF BUFFER IF NO EOL AT END
SPCTAB==202	;FAKE ASCII CHAR = SIGNAL TO SEARCH FOR A STRING OF SPACE/TABS

SMATLN==^D131	       ;[334] Number of characters in the search matricies
BITMLN==SMATLN/^D36+1  ;[334] Number of words needed to hold SMATLN bits

STABLN==^D131	;[334] Length of Otag$ build table
GCTBL==	LPF+40
EE1==1B12	;PRINT UUO ERROR CODE AFTER ?XXX
EE2==2B12	;PRINT I/O ERROR CODE AFTER ?XXX
EE3==3B12	;PRINT NOTHING AFTER ?XXX BECAUSE NO CORE FOR ERROR FILE

EO21==	1	;TURN OFF SPECIAL VERSION 22+ FEATURES IF EO VALUE = 1
EODEC==	2	;[335] Same for version 124+
	SUBTTL	Pseudo RUN UUO if Needed

IFN NORUNS,<
IFN CCL,<
NORUN1:	IOWD	.-.,INHERE	;MODIFIED FOR LENGTH
	0
NORUN2:	CORE	15,
	EXIT			;NOT ENOUGH CORE TO GET COMPIL
	IN	CCLCHN,NORUN1	;READ THE FILE
	JRST	NORBLT		;TO THE ACS
	EXIT			;NO GOOD.

INHERE:				;WHERE CODE APPEARS
NORAC:				;WHERE TO READ AC DATA FROM
	PHASE	0
NORBLT:	BLT	NORTOP,.-.	;ADR MODIFIED
	RESET
	AOS	1,.JBSA		;ADR + 1
	JRST	(1)		;START COMPIL
NORTOP:	XWD	INHERE+1,75	;MOVE COMPIL DOWN
	DEPHASE
	>>
	SUBTTL	Startup Time Initialization

	JRST	RST		;THIS MUST BE IN 400010 WHEN SSAVED
				;THIS IS USED BY THE EE COMMAND ROUTINE
				;SAVED IN THE LOW SEGMENT TO START TECO
				;AFTER A SAVE
TECO:
IFN <CCL*F%RSCN>,<		;[1011]
	SKIPA	B,[RSNIN]	;[1011] Normal entry (possible rescan)
	MOVEI	B,CCLIN		;[1011] The CCL entry
>
	RESET			;INITIALIZE ALL IO
	SETZB	F2,LOCORE	;CLR DATA IN CASE OF ^C,ST & CLEAR F2
	MOVE	A,[XWD LOCORE,LOCORE+1]
IFE BUGSW,<BLT	A,@.JBREL>
IFN BUGSW,<BLT A,LOWEND-1>
	SETO	A,		;[2006] Get the terminal
	GETLCH	A		;[2006]  characteristics
	TXNE	A,GL.LCM	;[2006] Skip the terminal can't do lowercase
	TXO	F2,S.LCTT	;[2006] Don't type 'A for A
	AOS	A,FIRST		;[1032] Get the START count
	CAXE	A,^D1		;[1032] Skip if the first time
	JRST	TECO01		;[1032] Don't save the device/PPN this time
IFN <CCL*F%RSCN>,<MOVEM	B,CCLSW>;[1011] Save the CCL flag
IFN FT$TYM,<	;[JMS] ACs are not set up on RUN like TOPS-10
	MOVSI	11,'DSK'	;[JMS] Only one structure
	HRROI	7,-25		;[JMS] GETTAB entry for where we came from
	GETTAB	7,		;[JMS]
	  MOVE	7,[1,,4]	;[JMS]
>  ;End of IFN FT$TYM
	MOVEM	11,ERRDEV	;[337] Save device we RUN from, for TECO.ERR
	MOVEM	7,ERRPPN	;[337] Save PPN as well
TECO01:	MOVX	A,.TODIS	;[2017] Read DISPLA bit
	SETO	AA,		;[2017] This terminal
	MOVE	B,[2,,A]	;[2017] Point to args
	TRMOP.	B,		;[2017] Read the bit
	  MOVEI	B,0		;[2017] In 603A, DISPLA bit is different
	MOVX	A,XF.CNW	;[2017] Control-W = delete flag
	SKIPE	B		;[2017] If TTY goes backspace-space-backspace,
	IORM	A,XFLAGS	;[2017]  enable Control-W deleting
	MOVE	A,[PUSHJ P,UUOH]  ;[1032] Setup the UUO trap
	MOVEM	A,.JB41
	MOVE	P,[XWD -LPDL,PDL]	;START ONE WORD DOWN
	HRRZ	B,.JBFF		;MAKE SURE WE HAVE AT LEAST 1000. FREE WDS
	ADDI	B,^D1000	;[350]
	CAML	B,.JBREL
	CORE	B,
	JFCL			;KEEP GOING...WITH LUCK WE WILL AT LEAST GET
				;THE PROPER ?COR MESSAGE
	HRRZ	A,.JBREL	;.JBFF=.JBREL-202
	SUBI	A,47		;[352] Buffer space for TMPCOR, etc.
	EXCH	A,.JBFF
IFN BUGSW,<MOVEM A,CMDBFR>
	HRLI	A,(POINT 7)	;[1010] CBUF=[440700,,FF]
	MOVEM	A,CBUF
	MOVEI	A,201(A)
	IMULI	A,5
	MOVEM	A,BEG		;BEG:=(CBUF+200)*5
	MOVEM	A,PT		;PT:=(CBUF+200)*5
	MOVEM	A,Z		;Z:=(CBUF+200)*5
	MOVEM	A,QRBUF		;QRBUF:=(CBUF+200)*5
	PUSHJ	P,SETUP		;SET UP STUFF

				;Fall through to next page...
	HRREI	A,TYCASW	;GET WHATEVER IS DEFAULT TYPE-OUT CASE FLAGGING MODE
	MOVEM	A,TYCASF	;AND MAKE IT CURRENT
	HRRZI	A,EOVAL		;INITIALIZE EO FLAG
	MOVEM	A,EOFLAG
	HRREI	A,AUTOFS	;INIT AUTOTYPE-AFTER-SEARCHES FLAG
	MOVEM	A,AUTOF
IFN CRT,<
	PUSHJ	P,DEFVID	;[1003] Set up the default video type
> ;End of 'IFN CRT'
	SETOM	INI		;REMEMBER TO DO INI FILE
IFN BISSW,< ;BIS SUPPORT
	SETZM	A		;SEE IF KL10
	BLT	A,0		;...
	MOVEM	A,BIS		;NOTE RESULT
> ;END IFN BISSW

				;Fall through to next page...
	SUBTTL	Text Buffer Initialization

;COMPUTE A VALUE WHICH IS 2/3 THE SIZE OF THE CHARACTER BUFFER.IF
;1/3 IS LESS THAN 128 CHARACTERS, THE BUFFER WILL BE 2/3 FILLED ON
;A "Y" OR "A" COMMAND,OTHERWISE, THE BUFFER WILL BE FILLED TO THE
;TOTAL AVAILABLE BUFFER - 128 CHARACTERS. PAYING ATTENTION TO THE
;FORM FEED AND LF OPERATORS.

;IT SHOULD BE NOTED THAT IN THE CASE OF AUTOMATIC
;MEMORY EXPANSION, THESE INSTRUCTIONS MUST BE RE-EXECUTED
;TO INSURE PROPER MEMORY BOUNDS.

	PUSH	P,INITG		;FOR IN LINE CODING POPJ
CRE23:	MOVE	A,.JBFF		;LATEST VALUE OF FF
	IMULI	A,5		;5 CHARACTERS PER MEM WORD
	MOVEM	A,MEMSIZ	;MEMSIZ:=C(.JBFF)*5
INITG:	POPJ	P,.+1		;EXIT OR CONTINUE

	MOVE	A,CBUF
	MOVEI	A,100(A)
	MOVEM	A,CBUFH		;CBUFH:=CBUF+77
	MOVEI	A,SYL
	MOVEM	A,DLIM		;DLIM:=SYL
	HRLOI	A,10014
	MOVEM	A,NROOM2	;NROOM2:=XWD 10014,-1
	MOVEI	FF,0		;CLEAR FLAG REGISTER
	SKIPE	SRHMOD		;IF DEFAULT SEARCH MODE IS NOT 0,
	TXOA	FF,F.PMAT	;MAKE EXACT MODE CURRENT
GOE:	TXZA	FF,777777-F.TRAC-F.EMSG-F.FORM-F.SEQ
GO:	TXZ	FF,777777-F.TRAC-F.FORM-F.SEQ
	TXZ	F2,S.SSEQ!S.SLOG!S.NTRC!S.OCTL	;[322]
	MOVE	P,[XWD -LPDL,PDL]	;INITIALIZE PUSHDOWN LIST
	MOVEM	P,PDLSAV
	SETZM	PDL		;FLAG PDL TOP - NOTE: PDL FLAGS ARE
				;0 = TOP OF PDL
				;-1= LAST ITEM IS AN ITERATION
				;+1= LAST ITEM IS A PARENTHESIS
				;>1= LAST ITEM IS A MACRO
	SETZM	XCTING		;NO LONGER DOING ANYTHING
	SETZM	EQM		;CLEAR THE MACRO LEVEL COUNT
	MOVE	PF,[XWD -LPF-1,PFL-1]
	AOSE	INI		;TO DO THE INI FILE?
	JRST	CLIS
	MOVSI	E,(MOVE B,)	;FIX ILL UUO PROB IN INI FILES
	HLLM	E,DLIM
	PUSHJ	P,CLREXT	;SET UP EXTENDED LOOKUP BLOCK
	TXO	F2,S.DOIT	;DO INI FILE
	SETOM	XCTING		;SO IT DO IT
	PUSHJ	P,TTOPEN	;OPEN THE TTY
	MOVSI	E,'INI'		;SET UP EXTENSION
	PUSHJ	P,INIFIL	;GET IT INTO CORE
	JRST	CLIS		;GO DO REST
	SUBTTL	REENTER Command

REE:	CLRBFO			;STOP TYPEOUT
	MOVEM	P,TEMPP		;PRESERVE P
	MOVE	P,[IOWD 4,TEMPDL]	;SET UP STACK FOR SURE
	PUSH	P,E		;SAVE AN AC
	MOVEI	E,TTY		;CLOSE TTY
	RESDV.	E,		;RESET TTY
	JFCL
	PUSHJ	P,TTOPEN	;REOPEN TTY
	POP	P,E		;RESTORE E, AFTER USE BY TTOPEN
	MOVE	P,TEMPP		;RESTORE P
	RELEAS	ERRCHN,		;FIX ADR CHECK
	AOSE	XCTING		;COMMAND IN PROGRESS?
	JRST	GO		;NO, GO AND LISTEN FOR INPUT
	JRSTF	@.JBOPC		;CONTINUE

;ROUTINE TO FIX PDL OV'S

PDLOV:	MOVSI	D,'PDL'		;FAKE AN ERROR MESSAGE
	TLNE	P,-1		;MAIN PDL ERROR?
	MOVSI	D,'PDQ'		;Q REG STACK
	HLRZM	D,.JBUUO	;PDL OV
	MOVEI	B,"["		;IN CASE PDQ
	SKIPE	CTGLEV		;WERE WE IN THE MIDDLE OF A ^G SEARCH?
	MOVEI	B,7		;YES
	MOVEM	B,ARGSTO	;SAVE IT
	SETZ	D,		;DON'T APPEND A LOOKUP/ENTER/RENAME ERROR CODE!
	JRSTF	ERRPDL		;CAUSE ERROR UUO TO HAPPEN
	SUBTTL	Initialization of Job Dependent Parameters

SETUP:	MOVEI	A,PDLOV		;WHERE TO GO ON PDLOV
	MOVEM	A,.JBAPR	;SAVE
	MOVX	A,AP.REN!AP.POV	;ENABLE FOR PDL OV TRAPPING
	APRENB	A,		;SET TRAP

IFE F%T20,<
	GETPPN	A,		;GET USER'S PROJ-PROG #
	 JFCL			;[317] IN CASE SKIP RETURN
	MOVEM	A,USRPPN	;Save for later >
IFN FT$TYM,<	.GTAUN==-23	;Accounting User Number
	HRROI	A,.GTAUN	;Get logged in PPN
	GETTAB	A,		; instead of PPN set by GFD
	  SKIPA	A,USRPPN	;Cannot fail on TYMCOM-X
	EXCH	A,USRPPN	;'A' has default PPN, USRPPN has logged in PPN
>  ;End of IFN FT$TYM		;Use what's in A when PATH. fails
IFN F%T20,<
	MOVEM	1,SAVAC1	;[1045] Save AC-1
	MOVEM	2,SAVAC2	;[1045]  AC-2,
	MOVEM	3,SAVAC3	;[1045]  AC-3, and
	MOVEM	4,SAVAC4	;[1045]  AC-4
	SETO	1,		;[1045] Get my
	HRROI	2,4		;[1045]  logged
	MOVEI	3,.JILNO	;[1045]  in
	GETJI			;[1045]  PPN
	 JRST	[GETPPN 4,		;[1045] Get connected PPN
		  JFCL			;[1045] In case skip return
		 JRST   SETUP1]		;[1045] Skip the kludge
	HRLI	4,^O4		;[1045] ** Kludge **
SETUP1:	MOVEM	4,USRPPN	;[1045] Save for later >

	SETOM	DEFPTH		;GET DEFAULT PATH
	MOVE	E,[11,,DEFPTH]
	PATH.	E,
IFE F%T20,<
	MOVEM	A,DEFPTH+2	;IF NOT, JUST PPN >
IFN F%T20,<
	MOVEM	4,DEFPTH+2	;[1045] Save just the PPN then
	MOVE	1,SAVAC1	;[1045] Restore AC-1
	MOVE	2,SAVAC2	;[1045]  AC-2,
	MOVE	3,SAVAC3	;[1045]  AC-3, and
	MOVE	4,SAVAC4	;[1045]  AC-4 >

	MOVSI	A,'DSK'		;DEFAULT DEVICE
	MOVEM	A,ERSPEC	;SAVE FOR DEFAULT ER COMMAND
	SETOM	MONITR		;GET MONITOR SERIES NUMBER
	MOVX	A,%CNSTS
	GETTAB	A,		;WHICH MONITOR?
	 JRST	TECO2		;3 SERIES (MONITR=-1)
	TXNE	A,ST%TDS	;WHAT MONITOR ?
	AOS	MONITR		;5 SERIES (MONITR=+1)
	AOS	MONITR		;4 SERIES (MONITR=0)
TECO2:	MOVX	A,%SIFDA	;[2011] See if the file DAEMON is around
	GETTAB	A,		;[2011]  by checking for it PID
	SETZ	A,		;[2011] Obviously not
	MOVEM	A,FDAEM		;[2011] Non-zero if FILDAE is running
	PJOB	A,		;GET JOB #
	MOVEM	A,JOBN
	MOVEI	C,3		;SET CTR
JOBLUP:	IDIVI	A,12		;CONVERT JOB# TO DECIMAL ASCII IN LEFT HALF
	ADDI	AA,20
	LSHC	AA,-6
	SOJG	C,JOBLUP
	HRRI	B,(SIXBIT /TEC/)	;FORM NAME ###TEC
	MOVEM	B,TMPTEC	;SAVE
	HRROI	A,.GTWCH	;GOING TO GET ERROR MESSAGE LEVEL BITS
	GETTAB	A,		;GET WATCH BITS
	 SETZ	A,
	TXNN	A,JW.WMS
	TXO	A,JW.WPR!JW.WFL	;ASSUME FIRST LINE!PREFIX
	TXNE	A,JW.WCN
	TXO	A,JW.WFL
	MOVEM	A,ERRLEN	;-1=SHORT, 0=MEDIUM, +1=LONG
	MOVEM	A,PRMERR	;SAVE FOR DEFAULT
	POPJ	P,
	SUBTTL	Rescan Command Processor

IFN F%RSCN,<			;[1011]

	R.ESC==1B0		;[1011] A fake ESCape has been input
	R.EQL==1B1		;[1011] An equal sign has been input

RSNIN:	RESCAN	1		;[1011] Rescan the input line
	SKPINL			;[1011] Skip if something to input
	 JRST	RSNI18		;[1011] No command typed
	SETZ	E,		;[1011] Clear the result
	MOVE	A,[POINT 6,E]	;[1011] Set up a byte pointer for command

RSNI00:	PUSHJ	P,TYIX		;[1052] Get a character
	CAXE	CH," "		;[1052] Skip if a space
	CAXN	CH,.CHTAB	;[1052] Skip if not a tab
	JRST	RSNI00		;[1052] Get the next character
	CAXE	CH,.CHLFD	;[1052] Skip if a line-feed
	CAXN	CH,.CHESC	;[1052] Skip if not an Escape
	JRST	RSNI18		;[1052] No command typed
	JRST	RSNI1A		;[1052] Get a valid character

RSNI01:	PUSHJ	P,TYIX		;[2002] Get at character from the input
RSNI1A:	CAXL	CH,"A"		;[1011] Skip if an upper
	CAXLE	CH,"Z"		;[1011]  case alpha
	JRST	[CAXL  CH,"a"		;[1011] Skip if a lower
		 CAXLE CH,"z"		;[1011]  case alpha
		 JRST  RSNI03		;[1011] Go see if a valid command
		 SUBI  CH,"a"-"A"	;[1011] Convert to upper case
		 JRST  RSNI02]		;[1011] Go store the character
RSNI02:	SUBI	CH,"A"-'A'	;[1011] Convert ASCII to SIXBIT
	TLNE	A,770000	;[1011] Skip no is room left
	IDPB	CH,A		;[1011] Store this character then
	JRST	RSNI01		;[1011] Go get another character

RSNI03:	CAME	E,MAKCOM	;[2003] Is this a MAKE or
	CAMN	E,CRECOM	;[2003]  CREATE command?
	SETOM	MAKCMD		;[2003] Remember this tidbit for later
	MOVE	T,[-MONLEN,,MONTAB]  ;[1011] Test all of the valid
	PUSHJ	P,TSTABR	     ;[1011]  monitor level commands
	 JRST	RSNI18		;[1011] No such command
	TXZ	T,L%HALF	;[2004] Clear the trash in the left half
	CAIN	T,MNGCOM-MONTAB	;[2004] Skip if not a MUNG command
	JRST	[MOVX  A,-^D2		;[2004] Set the MUNG flag to -2
		 MOVEM A,MNGCMD		;[2004]  to catch the next comma
		 MOVX  A,XF.NIM		;[2011] Turn on the "No inform-
		 ORM   A,XFLAGS		;[2011]  ation messages" flag
		 MOVX  A,"ep"		;[2004] File is TECO macro name
		 JRST RSNI05]		;[2004] Continue
	TXNN	T,^O1		;[1011] Skip if odd (EW is wanted)
	SKIPA	A,["eb"]	;[1011] Convert to an EB command
	SKIPA	A,["ew"]	;[1011] Convert to an EW command
	TXO	FF,F.CCL	;[1011] Request an EY after the EB
	JRST	RSNI05		;[1011] Go eat up the rest of the command

RSNI04:	PUSHJ	P,TYIX		;[2002] Get command character
RSNI05:	CAXE	CH," "		;[1011] Skip if a space
	CAXN	CH,.CHTAB	;[1011] Skip if not a tab
	JRST	RSNI04		;[1011] Get the next character
	CAXE	CH,.CHLFD	;[1011] Skip if a line-feed
	CAXN	CH,.CHESC	;[1011] Skip if not an ESCape
	JRST	RSNI15		;[1011] Use the old command
	MOVE	B,[POINT 7,RSNBUF,13]  ;[1011] Get pointer to command buffer
	MOVX	C,^D6		;[1011] Reset the character count and flags

RSNI06:	SKIPN	MNGCMD		;[2004] Skip if MUNG command
	JRST	RSNI6A		;[2004] Ignore path checking
	CAIE	CH,"<"		;[2004] Skip if start
	CAIN	CH,"["		;[2004]  of path spec.
	AOS	MNGCMD		;[2004] Ignore commas
	CAIE	CH,"]"		;[2004] Skip if end of
	CAIN	CH,">"		;[2004]  path spec.
	SOS	MNGCMD		;[2004] Don't ignore commas
	CAXE	CH,","		;[2004] Skip if a comma
	JRST	RSNI11		;[2004] Skip = and $ checks
	AOSL	MNGCMD		;[2004] Skip if end of file spec.
	JRST	[SETOM MNGCMD		;[2004] Reset the count
		 MOVX  CH,","		;[2004] Get the comma back
		 JRST  RSNI11]		;[2004] Go store the character
	MOVX	CH,.CHESC	;[2004] End of EP
	IDPB	CH,B		;[2004]  file spec.
	MOVX	CH,"i"		;[2004] Set up for the insert
	AOJA	C,RSNI11	;[2004] Count the Escape

RSNI6A:	CAXN	CH,"="		;[1011] Skip if not an equal sign
	TXNE	C,R.ESC!R.EQL	;[1011] Skip if the first = and $ seen
	JRST	RSNI09		;[1011] Get back into the flow of things
	TXON	FF,F.CCL	;[1011] Skip if CCL flag is set
	JRST	RSNI08		;[1011] Go store ER
RSNI07:	PUSHJ	P,TYIX		;[2004] Get a command character
	CAXE	CH,.CHLFD	;[1011] Skip if line-feed
	CAXN	CH,.CHESC	;[1011] Skip if not an ESCape
	JRST	RSNI13		;[1011] End of line
	CAXE	CH,"$"		;[1011] Skip if an fake ESCape
	JRST	RSNI07		;[1011] Get another character
	JRST	RSNI10		;[1011] Get back into the flow of things

RSNI08:	TXO	C,R.EQL		;[1011] Set the = seen flag
	MOVX	CH,.CHESC	;[1011] Convert the equals
	IDPB	CH,B		;[1011] to an ESCape
	MOVX	CH,"e"		;[1011] Now
	IDPB	CH,B		;[1011]  store
	MOVX	CH,"r"		;[1011]  ER
	ADDX	C,^D2		;[1011] Account for the ER

RSNI09:	CAXE	CH,"$"		;[1011] Skip if a monitor level ESCape
	JRST	RSNI11		;[1011] Go store the character then
RSNI10:	TXO	C,R.ESC		;[1011] Set the excape flag
	MOVX	CH,.CHESC	;[1011] Convert to a real ESCape

RSNI11:	IDPB	CH,B		;[1011] Save the character for later
RSNI12:	PUSHJ	P,TYIX		;[2004] Get the next character
	CAXE	CH,.CHLFD	;[1011] Skip if a line-feed
	CAXN	CH,.CHESC	;[1011] Skip if not an aescape
	JRST	RSNI13		;[1011] Go wrap everything up
	AOJA	C,RSNI06	;[1011] Go store the character

RSNI13:	SKIPL	MNGCMD		;[2004]
	JRST	RSN13A		;[2004] Avoid this kludge
	MOVX	CH,.CHESC	;[2004] Terminate the
	IDPB	CH,B		;[2004]  insert/EP
	MOVX	CH,"m"		;[2004] Execute
	IDPB	CH,B		;[2004] the
	MOVX	CH,"*"		;[2004] Q-register
	IDPB	CH,B		;[2004] astrisk
	ADDX	C,^D3		;[2004] Account the characters

RSN13A:	MOVEI	CH,.CHESC	;[1011] Store the
	IDPB	CH,B		;[1011]  terminating
	IDPB	CH,B		;[1011]  Altmodes
	MOVEM	C,RSNCNT	;[1011] Save the character count

IFGE F%T20,<
	MOVE	B,[.TCRWF,,TMPPTR]  ;[1011] Set up to save the command
	SKIPN	MNGCMD		;[2004] Don't save MUNG commands
	TMPCOR	B,		;[1011] Save the command for next time
	 JFCL			;[1011] These things happen!!! >

RSNI14:	DPB	A,[POINT 14,RSNBUF,13]  ;[1011] Store the EB or EW
	MOVE	B,[POINT 7,RSNBUF]  ;[1011] Store the pointer to
	MOVEM	B,TIB+.BFPTR	    ;[1011]  to the command
	HRRZM	C,TIB+.BFCNT	;[1011] Store the command length

	SKIPN	MAKCMD		;[2003] Skip if a MAKE command
	POPJ	P,		;[2003] Return
	MOVE	A,RSNBUF		  ;[2003] Is
	TXZ	A,<ASCII ~     ~>	  ;[2003]  the
	CAXE	A,<ASCII ~EWLOV~>	  ;[2003]  file
	POPJ	P,			  ;[2003]  being
	LDB	A,[POINT 14,RSNBUF+1,13]  ;[2003]  created
	TXZ	A,<"  ">		  ;[2003]  named
	CAXN	B,<"E">		  ;[2003]  LOVE?
	POPJ	P,			  ;[2003] No, return
	JSP	A,CONMES		  ;[2003] Yes, output a message
	ASCIZ	~Not War?
~
	POPJ	P,			  ;[2003] Return
IFL F%T20,<
RSNI15:	ERROR	E.NSC		;[1052] No saved command >

IFGE F%T20,<
RSNI15:	MOVE	B,[.TCRRF,,TMPPTR]  ;[1011] Set up to read the previous command
	SKIPN	MNGCMD		;[2004] Didn't save the previous MUNG command
	TMPCOR	B,		;[1011] Read the previous command
	 ERROR	E.NSC		;[1046] No saved command
	MOVE	C,RSNCNT	;[1011] Get the count and flags
	TXNE	C,R.EQL		;[1011] Skip if last command didn't have an equal
	TXON	FF,F.CCL	;[1011] Skip if an EB is wanted
	JRST	RSNI14		;[1011] Go store the EB or EW
	MOVE	B,[POINT 7,RSNBUF]  ;[1011] Get a pointer to the command buffer
RSNI16:	ILDB	CH,B		;[1011] Get a character
	CAXE	CH,.CHESC	;[1011] Skip if an ESCape
	JRST	RSNI16		;[1011] Go try the next character
	MOVX	D," "		;[1011] Get the fill character (a space)
RSNI17:	ILDB	CH,B		;[1011] Get the next character
	CAXN	CH,.CHESC	;[1011] Skip if it wasn't an ESCape
	JRST	RSNI14		;[1011] Go store the EB or EW
	DPB	D,B		;[1011] Store the fill character over it
	JRST	RSNI17		;[1011] Get the next character >

RSNI18:	SETZM	CCLSW		;[1011] Reset the CCL switch
	SETZM	TIB+.BFCNT	;[1011] Reset the command length
	PJRST	CPOPJ1		;[1011] Skip return


IFGE F%T20,<
TMPPTR:	'TEC',,0		;[1011] The file to read/write
	IOWD	16,RSNCNT	;[1011] Where to read/write the data >

MONTAB:	'TECO  '		;[1011] The valid commands
MAKCOM:	'MAKE  '		;[2003]
	'EDIT  '		;[1011]
CRECOM:	'CREATE'		;[2003]
MNGCOM:	'MUNG  '		;[2004]
MONLEN==.-MONTAB		;[1011] The number of valid commands >
	SUBTTL	CCL Command processor

IFN CCL,<
TTYPT:	XWD	440700,TTYBFS	;CCL COMMAND BUFFER PTR
TTYPT2:	XWD	260700,TTYBFS	;TO INSERT FILE NAME AFTER EW OR EB


CCLIN:
IFN TEMP,<
	SETZ	I,		;CLEAR TO DENOTE NO TMPCOR
	MOVE	A,[XWD 2,TT]	;SET UP FOR TMPCOR READ & DELETE
	HRLZI	TT,'EDT'	;SET UP READ BLOCK FOR TMPCOR UUO
	HRRZ	TT1,.JBFF	;[343] Get first free location
	ADDI	TT1,46		;[343] Allow more than enough space
	CAML	TT1,.JBREL	;[343] Do we have it?
	CORE	TT1,		;[343] No - expand
	  JFCL			;[343] Do the best we can
	HRRZ	TT1,.JBFF	;[343] Where to put it
	SUB	TT1,[XWD 46,1]	;[343] Make an IOWD
	TMPCOR	A,		;READ AND DELETE FILE EDT
	JRST	CCLTMP		;NO FILE EDT OR NO TMPCOR UUO
	HRRZ	AA,.JBFF	;[343] Start of buffer area
	HRLI	AA,(POINT 7)	;[1012] Pick up EDT characters
	JSP	I,CCLTM1	;[343] Denote we have TMPCOR and continue below
>;END OF IFN TEMP

;Here if TMPCOR failed.  Read DSK:nnnEDT.TMP.

CCLTMP:	HLLZ	B,TMPTEC	;GET SIXBIT JOB #
	HRRI	B,(SIXBIT /EDT/)	;REST OF NAME
	MOVEM	B,XFILNM+.RBNAM
	MOVSI	B,(SIXBIT /TMP/)
	MOVEM	B,XFILNM+.RBEXT
	SETZM	XFILNM+.RBSIZ	;USE DEFAULT PATH, PREVENT ADR. CHK.
	MOVE	T,.JBFF		;USE BUFFER SPACE BRIEFLY
	OPEN	CCLCHN,[EXP .IOASC	;[326]
			SIXBIT	/DSK/	;[326] TO READ THE FILE
			EXP	CCLB]	;[326] INPUT BUFFER
	JRST	TECO		;IF NO DSK, SAY "*"
	INBUF	CCLCHN,1	;DONT ADR CHECK
	LOOKUP	CCLCHN,XFILNM+.RBNAM	;OPEN THE FILE
	JRST	TECO		;IT WASNT THERE?
	INPUT	CCLCHN,0
	MOVEM	T,.JBFF		;GIVE BACK SPACE
;	IBP	CCLB+.BFPTR	;[1012] Don't skip if the LINED 'S'
	MOVE	AA,CCLB+.BFPTR	;[343] Get byte pointer to input

;Fall back into normal process on next page
;Here when we have the command, either from TMP: or from DSK:.

CCLTM1:	MOVE	T,TTYPT2	;[343] Get output byte pointer
	MOVEI	C,2		;[343] Initialize the character count
	HRLI	C,-<<46*5>-4>	;[343] Max of 186. chars
	MOVEI	A,"="		;[343] Flag no equals sign seen
	SETZ	TT1,		;[343] Flag no dollar sign seen

;Loop back here on each new character in TMP file

CCLIL:	ILDB	B,AA		;[343] Get next EDT character
	CAIN	B,"$"		;[343] Is it a dollar sign? (Our pseudo altmode)
	 JRST	CCLALT		;[343] Yes
	CAMN	B,A		;[343] First equals sign seen?
	 JRST	CCLEQL		;[343] Yes
	CAIE	B,.CHCRT	;[343] CR?
	CAIN	B,.CHALT	;[343] Old altmode?
	JRST	CCLNUL		;[343] Assume we're done
	SKIPE	B		;[352] Ignore nulls
CCLIL1:	IDPB	B,T		;[343] Else store the character
	AOBJN	C,CCLIL		;[343] Loop for all characters

; Fall through if too many characters; we can't overflow TTYBFS

CCLOVF:	JUMPN	B,CCLOV1	;[352] Is current char a null?
	LDB	B,T		;[352] Yes, assume we're OK, pick up last char
	ADD	T,[7B5]		;[352] Backup byte pointer
	JUMPG	T,CCLNUL	;[352]
	SUB	T,[430000,,1]	;[352] Fixup if necessary
	JRST	CCLNUL		;[352] Go wrap things up
CCLOV1:	ERROR	E.CTL		;[343] CCL command too long

; Here when a dollar sign seen

CCLALT:	MOVEI	B,.CHESC	;[343] Change it into a real altmode
	JUMPN	TT1,CCLIL1	;[343] Is this the first one we've seen?
	MOVE	TT1,AA		;[343] Yes, save input byte pointer
	JUMPL	A,CCLIL1	;[343] Was there a prior equal sign?
	MOVNI	A,2		;[343] No, so flag to ignore all future equal signs
	JRST	CCLIL1		;[343] Return to loop

; Here on the first "=" in the command string (unless $ seen first)

CCLEQL:	MOVEI	B,.CHESC	;[343] Replace first equals sign
	IDPB	B,T		;[343]  with <ESC>ER
	AOBJP	C,CCLOVF	;[343] Count the escape
	MOVE	D,T		;[343] Save T & C
	MOVE	E,C		;[343] In case .TE A=B
	ADD	C,[2,,2]	;[343] Count the "ER" we will add
	JUMPGE	C,CCLOVF	;[343] Error if too many characters
	MOVEI	B,"E"		;[343] Since we expect
	IDPB	B,T		;[343]  an input file
	MOVEI	B,"R"		;[343]  spec to follow
	IDPB	B,T		;[343]  the first one.
	SETO	A,		;[343] Prevent finding later equals
	TXO	FF,F.CCL	;[343] Do a EY in any case
	JRST	CCLIL		;[343] and loop back for next character
; Here on a null (End of command). See if it was MAKE or TECO

CCLNUL:	MOVEI	TT,"W"		;[343] Prepare for EW command
	CAILE	B,.CHCRT	;WAS BREAK A CRLF?
	JRST	CCLDUN		;NO. ALTMODE ASSUMED
	TXO	FF,F.CCL	;REQUEST Y AFTER EB
	MOVEI	TT,"B"		;[343] Now prepare for EB
	AOJN	A,CCLDUN	;[343]  continue unless EB and "=" was seen
	MOVE	T,D		;[343] If .TE A=B, we never saw the "="
	MOVE	C,E		;[343] In case .MA A=B, then .TE<CRLF>
	JUMPE	TT1,CCLDUN	;[343] Jump ahead unless there was a $ after "A=B"
	MOVE	AA,TT1		;[343] There was, so restore input BP to that point
	MOVNI	A,-2		;[343] Reset A so we don't do this again
	JRST	CCLIL		;[343] And return to that point, leaving out the "=B"

CCLDUN:	MOVEI	B,.CHESC
	IDPB	B,T		;[343] TERMINATING TWO ALT'S
	IDPB	B,T		;LAST ALT
	ADDI	C,3		;[343] COUNT BOTH ALTS & ADD 1 TO FOOL TYI0
	MOVEI	B,"E"		;NOW FILL IN THE EB OR EW
	MOVE	T,TTYPT		;AT THE BEGINNING OF STRING
	MOVEM	T,TIB+.BFPTR	;ALSO INITIALIZE TO READ THIS
	IDPB	B,T		;STORE "E"
	IDPB	TT,T		;[343] And either W or B
	HRRZM	C,TIB+.BFCNT	;SET BUFR CTR

IFN TEMP,<JUMPN	I,CCLDU2>	;[343] IF TMPCOR THEN DON'T HAVE TO CLOSE
	SETZM	XFILNM+.RBNAM	;BY RENAME TO 0
	RENAME	CCLCHN,XFILNM	;GO.
	  JFCL			;NOGO?
CCLDU2:	RELEAS	CCLCHN,
	POPJ	P,

>;END OF IFN CCL
	SUBTTL	Get a Character in CH for Rescan


; TYIX - Get a character from the rescan buffer
;Call:	PUSHJ	P,TYIX		;Get character from the command line
;	* Return *		;The character is in CH

IFN F%RSCN,<
TYIX:	PUSH	P,A		;[2002] In case of a Control-G
TYIX0:	PUSHJ	P,TYI		;[2002] Get the character
	CAXN	CH,.CHCRT	;[2002] Carriage return?
	 JRST	TYIX0		;[2002] Yes, ignore the character
	CAXE	CH,.CHVTB	;[2002] A vertical tab
	CAXN	CH,.CHFFD	;[2002]  or form-feed?
	 MOVX	CH,.CHLFD	;[2002] Yes, convert to a line-feed
	CAXE	CH,.CHBEL	;[2002] A Control-G (bell)
	CAXN	CH,.CHCNZ	;[2002]  or Control-Z?
	 MOVX	CH,.CHLFD	;[2002] Yes, convert to a line-feed
	CAXE	CH,"!"		;[2002] An exclaimation point
	CAXN	CH,";"		;[2002]  or semi-colon?
	 SETOM	RSNCMT		;[2002] A comment character was seen
	SKIPL	MNGCMD		;[2002] Skip if not a MUNG command
	 SETZM	RSNCMT		;[2002] No longer a comment
	CAXE	CH,.CHLFD	;[2002] A line-feed
	CAXN	CH,.CHESC	;[2002]  or ESCape?
	 SETZM	RSNCMT		;[2002] Yes, no longer a comment
	SKIPE	RSNCMT		;[2002] Skip if no longer in a comment
	 JRST	TYIX0		;[2002] Read the next character
	POP	P,A		;[2002] Restore the command
	POPJ	P,		;[2002] Return >
	SUBTTL	Return Non-Null TTY Character in CH

;CALL	PUSHJ PDP,TYI
;	RETURN

TYI:	TXZE	FF,F.TYOF	;NEED A TYO?
	OUTPUT	TTY,0		;YES. DO SO.
TYI0:	SOSG	TIB+.BFCNT	;CHARS IN NORMAL MODE?
	JRST	TYI1		;NONE LEFT
TYI2:	ILDB	CH,TIB+.BFPTR	;YES. GET ONE
	JUMPE	CH,TYI0		;FLUSH NULLS
TYI3:	TXZ	FF,F.DDTM	;CLR TTCALL REQUEST FLAG
IFN RUBSW,<
	SETO	A,		;AIM AT THIS TTY
	GETLCH	A		;GETSTS
	TXNN	A,GL.LCP	;SUPPRESS ECHO?
	>
	CAIE	CH,.CHBEL	;BELL?
	JRST	ALTLIN		;NO, BUT WATCH OUT FOR OLD ALTMODES
	TXO	F2,S.SLOG	;DON'T PUT THE ^G IN THE LOG FILE
	JSP	A,CONMES	;ECHO AN "^G" TOO
	ASCIZ	/^G/
	TXZ	F2,S.SLOG
	MOVEI	CH,.CHBEL	;GET BACK BELL
	POPJ	P,

TYI1:	TXNE	FF,F.DDTM	;SHOULD TYI BE TTCALL?
	JRST	TYIDDT		;YES
	INPUT	TTY,0		;NO. ORDINARY.
	STATO	TTY,IO.EOF	;END OF FILE?
	JRST	TYI2
	PUSHJ	P,TTOPEN	;CLEAR EOF THE HARD WAY
	JRST	TYI0		;^Z WAS SEEN ALREADY. GET ANOTHER CH

;CONVERT 175 & 176 TO ALTMODE (033) UNLESS TTY LC IS ON

ALTLIN:	CAIL	CH,.CHALT	;OLD ALTMODE?
	CAILE	CH,.CHAL2
	POPJ	P,		;NO
	TXNN	F2,S.NALT	;TEST TTY NO ALT BIT
ALTX:	MOVEI	CH,.CHESC	;NOT ON, SO CONVERT TO 033
	POPJ	P,

;CONVERT 175 & 176 TO ALTMODE (033) IF EO = 1

ALTEO:	CAIE	CH,.CHALT	;OLD ALTMODE?
	CAIN	CH,.CHAL2
	CHKEO	EO21,ALTX	;RUNNING OLD MACRO? IF SO, CONVERT
	POPJ	P,		;NO, 175=RIGHT BRACE, 176=TILDE
TYIDDT:	TXZE	FF,F.TYOF	;CHARACTERS WAITING FOR OUTPUT?
	OUTPUT	TTY,0		;YES, FORCE THEM OUT
	INCHRW	CH		;WAIT FOR A SINGLE CHARACTER
	JRST	TYI3

;USE E INSTEAD OF T IN THIS ROUTINE, SINCE IT MAY BE CALLED
;	AFTER A REENTER, WHILE T IS BEING USED TO MOVE CHARACTERS
;	(FAST AC CODE).  E HAS BEEN SAVED AT REE:.
TTOPEN:	MOVEI	E,TTYBFS
	EXCH	E,.JBFF		;SET .JBFF AND SAVE IT
	OPEN	TTY,TTYBLK	;[326] INIT THE CONSOLE
	JRST	.-1		;[326] I REALLY WANT TTY
	INBUF	TTY,1
	OUTBUF	TTY,1		;KEEP IT SMALL
	MOVEM	E,.JBFF		;RESTORE .JBFF
IFN CCL,<
	SETZM	TYIPT		;SIGNAL CCL BUFFER EMPTY
	>
	POPJ	P,

TTYBLK:	EXP	IO.FCS!.IOASC	;[326] TTY OPEN BLOCK
	SIXBIT	/TTY/
	TOB,,TIB
	SUBTTL	Type a Character

;FOR TYPING TEXT:		FOR TYPING MESSAGES:
;	MOVE CH,CHARACTER		MOVE CH,CHARACTER
;	PUSHJ P,TYO			PUSHJ P,TYOM
;	RETURN				RETURN

TYOS:	TXOA	F2,S.TXTC	;TYPE <CR>, ETC INSTEAD OF PRINTER CONTROLS
TYOM:	TXZ	F2,S.TXTC	;CLR SPECIAL TYPEOUT FLAG
	TXOA	F2,S.NCFL	;SET NO-CASE-FLAGGING FLAG
TYO:	TXZ	F2,S.NCFL+S.TXTC ;CLR NO-CASE-FLAGGING FLAG & SPECIAL FLAG
	PUSH	P,CH		;SAVE CHAR IN CASE ^ OR ' NEEDED
	TXZ	FF,F.TCTL!F.IMAG ;[331] Zero literal and image flags
	SKIPN	ETVAL		;[331] ET = 0?
	JRST	TYOF		;[331] It's 0, so use up-arrow mode
	PUSH	P,A		;[331] Save a #%&ing AC!
	MOVE	A,ETVAL		;[331] Get ET value
	CAIN	A,1		;[331] ET=1?
	TXO	FF,F.TCTL	;[331] Yes
	CAIN	A,2		;[331] ET=2?
	TXO	FF,F.IMAG	;[331] Yes, set image mode
	POP	P,A		;[331] Retore A
	JRST	TYOB		;[331] Go type character

TYOF:	PUSHJ	P,ALTEO		;[331] CONVERT OLD ALTMODES IF EO=1
IFN CRT,<SKIPN	CRTTYP		;IF CRT IN USE,
	CAIL	CH,.CHTAB
	CAIGE	CH,.CHCNH	;THEN TYPE ^H LITERALLY
	>
IFE CRT,<CAIGE	CH,.CHTAB	;^H TYPED WITH ARROW
	>
	JRST	TYO1		;BELOW TAB
	TXZN	F2,S.TXTC	;WANT <CR>, ETC INSTEAD OF PRINTER CONTROLS?
	JRST	TYOJ		;NO
	CAIG	CH,.CHCRT	;IS IT A PRINTER CONTROL?
	JRST	TYOH		;YES
	CAIE	CH,.CHESC	;OR AN ALTMODE?
	JRST	TYOG		;NO, DO NORMAL THING
	MOVEI	CH,16		;ADJUST INDEX FOR ALTMODE
TYOH:	MOVEI	A,5		;5 CHAR. CTR
	MOVE	AA,[POINT 7,TSPTAB-10]	;& PTR TO RIGHT COMBINATION
	ADDI	AA,(CH)
TYOI:	ILDB	CH,AA		;TYPE <CR> OR WHATEVER
	SOJLE	A,TYOB		;LAST CHAR GOES OUT VIA TYOB (TO POP CH)
	PUSHJ	P,TYOA
	JRST	TYOI
TYOJ:	CAIG	CH,.CHCRT	;NO, TAB, LF, VT, FF, OR CR?
	JRST	TYOB		;YES. TYPE IT AND RETURN
	CAIN	CH,.CHESC
	MOVEI	CH,"$"		;YES TYPE DOLLAR SIGN
TYOG:	CAIGE	CH," "		;NO. ANY OTHER CONTROL CHARACTER?
	JRST	TYO1		;YES.
TYOC:	TXNE	F2,S.LCTT+S.NCFL	;TTY LC ON? OR TYPING A MESSAGE?
	JRST	TYOB		;YES, NO CASE FLAGGING
	MOVE	A,TYCASF	;WHAT SHOULD BE FLAGGED?
	JUMPL	A,TYOB		;NOTHING
	JUMPG	A,TYOD		;UPPER CASE RANGE
	CAIGE	CH,"A"+" "-1	;LOWER CASE. IS THIS LC?
	JRST	TYOB		;NO, SO DON'T FLAG IT
TYOE:	MOVEI	CH,"'"		;YES, FLAG IT WITH '
	PUSHJ	P,TYOA
	MOVE	CH,(P)		;GET BACK THE CHARACTER
	TXZ	CH,40		;MAKE IT UPPER CASE
TYOB:	PUSHJ	P,TYOA		;TYPE CH.
	POP	P,CH		;RESTORE CH
	TXZN	FF,F.TCTL!F.IMAG	;[331] CLEAR LITERAL AND IMAGE FLAGS
	CAIE	CH,.CHBEL	;[331] IF BELL, WE NEED A DING
	POPJ	P,		;NO, RETURN
	JRST	TYOA1		;[325] BUT DON'T PUT THE DING INTO LOG FILE
TYOA:	TXNE	F2,S.OLOG!S.LOUT	;PUT CHARACTER IN LOG FILE
	PUSHJ	P,LOGOUT	;RIGHT!
TYOA1:	TXNE	FF,F.IMAG	;[331] Do we want image typeout?
	JRST	TYOK		;[331] Yes
	TXO	FF,F.TYOF	;[325]  MARK WILL NEED TO OUTPUT
	SOSG	TOB+.BFCNT	;OUTPUT SPACE AVAIL?
	OUTPUT	TTY,0		;NO. OUTPUT.
	IDPB	CH,TOB+.BFPTR
	CAILE	CH,.CHFFD	;FORCE OUTPUT ON LF,FF ETC
	POPJ	P,		;NO
	OUTPUT	TTY,0
	TXZ	FF,F.TYOF	;NO LONGER NEED TO OUTPUT
	POPJ	P,

TYOK:	TXZE	FF,F.TYOF	;[331] If output pending...
	OUTPUT	TTY,0		;[331] put it out
	IONEOU	CH		;[331] Output the image character
	POPJ	P,		;[331] Return

TYO1:	PUSH	P,CH		;TYPE CONTROL CHARACTER IN FORM "^CH"
	MOVEI	CH, "^"
	PUSHJ	P,TYOA		;TYPE ^
	POP	P,CH
	ADDI	CH,100		;CONVERT TO PRINTING CHARACTER
	JRST	TYOB		;AND TYPE IT.

TYOD:	CAIL	CH,100		;IS THIS UPPER CASE?
	CAILE	CH,137
	JRST	TYOB		;NO
	JRST	TYOE		;YES, FLAG IT WITH '


;PRINT THESE INSTEAD OF PRINTER CONTROLS IF S.TXTC FLAG IS ON

TSPTAB:	ASCII	/^H/
	ASCII	/<TAB>/
	ASCII	/<LF>/
	ASCII	/<VT>/
	ASCII	/<FF>/
	ASCII	/<CR>/
	ASCII	/<ALT>/
	SUBTTL	Message Type-Out & Number Type-Out

;CALL	JSP A,CONMES
;	ASCIZ /MESSAGE/
;	RETURN

CONMES:	HRLI	A,(POINT 7,,)	;A=POINT 7,MESSAGE-ADDR
	ILDB	CH,A		;GET MSG CHAR
	JUMPE	CH,1(A)		;RETURN WHEN 0 FOUND
	PUSHJ	P,TYOM		;TYPE WITH NO CASE FLAGGING
	JRST	.-3

;ROUTINE TO OUTPUT DECIMAL (OCTAL IF S.OCTL IS ON) INTEGER
;CALL	MOVE B,INTEGER
;	MOVEI A,ADDRESS OF OUTPUT ROUTINE
;	PUSHJ P,DPT
;	RETURN

DPT:	MOVEM	A,LISTF5
	JUMPGE	B,DPT1		;NUMBER > 0?
	MOVEI	CH,"-"		;NO. OUTPUT -
	PUSHJ	P,@LISTF5
	MOVMS	B		;B:=ABSOLUTE VALUE OF B
DPT1:	MOVEI	A,12		;RADIX 10
	TXZE	F2,S.OCTL	;[323] OCTAL RADIX?
	MOVEI	A,10		;YES, CHANGE TO RADIX 8
	IDIVI	B,(A)		;E:=DIGIT
	HRLM	E,(P)		;PUT DIGIT ON LEFT HALF OF TOP OF PUSH DOWN LIST
	JUMPE	B,.+2		;DONE?
	PUSHJ	P,.-3		;NO. PUSH THIS DIGIT AND PRINT RETURN ADDRESS.
	HLRZ	CH,(P)		;YES. CH:=DIGIT
	ADDI	CH,"0"		;CONVERT IT TO ASCII.
	JRST	@LISTF5		;PRINT IT

;ROUTINE TO TYPE CARRIAGE RETURN LINE FEED
;CALL	PUSHJ P,CRR
;	RETURN

CRR:	JSP	A,CONMES	;OUTPUT CRLF
	ASCIZ	/
/
	POPJ	P,

;ROUTINE TO TYPE A STRING LITERALLY

OUTIMG:	TXO	FF,F.IMAG	;[331] Use image mode
OUTMES:	HRLI	A,(POINT 7,,)	;THIS ROUTINE WILL OUTPUT A STRING LITERALLY
OUTMS1:	ILDB	CH,A
	JUMPE	CH,OUTMS2	;[331]
	PUSHJ	P,TYOA
	TLNE	A,700000	;NO MORE THAN 5 CHARACTERS, THOUGH
	JRST	OUTMS1
OUTMS2:	TXZ	FF,F.IMAG	;[331] Clear image flag
	POPJ	P,
	SUBTTL	Return Next Command Character at Current Level

;CALL:	PUSHJ	P,SKRCH
;	ERROR RETURN IF NO MORE CHARS AT THIS LEVEL
;	NORMAL RETURN WITH CHAR IN CH

SKRCH:	SKIPG	COMCNT		;ANY CHARS LEFT?
	POPJ	P,		;NO, TAKE ERROR RETURN
	PUSHJ	P,RCH		;YES, GET NEXT
CPOPJ1:	AOS	(P)		;SKIP RETURN
	POPJ	P,

;ROUTINE TO RETURN NEXT CHARACTER FROM COMMAND BUFFER.
;CALL	PUSHJ P,RCH
;	RETURN ALWAYS WITH CHARACTER IN CH

RCH:	SOSGE	COMCNT		;DECREMENT COMMAND BUFFER CHARACTER COUNT
				;IS COMMAND BUFFER EMPTY?
	JRST	RCH2		;YES. POP UP TO HIGHER MACRO LEVEL.
	ILDB	CH,CPTR		;NO. GET COMMAND CHARACTER IN CH
	PUSHJ	P,ALTEO		;CONVERT OLD ALTMODES IF EO = 1
	HRRM	CH,EATCH	;IN CASE OF FAILURE DURING COLON ANYTHING
	TXNE	FF,F.TRAC	;IN TRACE MODE?
	TXNE	F2,S.NTRC	;TRACE ENABLED?
	POPJ	P,		;NO, RETURN
	JRST	TYO		;YES, TYPE THE COMMAND

RCH2:	POP	P,CH		;SAVE RETURN FOR POPJ IN CH
	POP	P,COMCNT	;GET RID OF FLAG
	SOSGE	EQM		;DECREMENT THE MACRO COUNT
	SETZM	EQM		;NEVER ALLOW IT TO GO NEG OR PEOPLE WILL SCREW UP
	SOSGE	COMCNT		;IF ANG BRAK ON PDL, ITS A INCOMPLETE MACRO
	ERROR	E.IAB
	POP	P,COMCNT	;GET COUNT FROM NEXT MACRO LEVEL
	POP	P,CPTR		;CURRENT POINTER TOO
	POP	P,COMAX		;NUMBER OF COMMANDS
	PUSH	P,CH		;GET RETURN BACK ON PDL.
	JRST	RCH		;TRY AGAIN.

;GET NEXT CHAR FROM CURRENT COMMAND LEVEL WHERE A CHAR IS
;KNOWN TO BE THERE, AND NO TRACING IS WANTED

GCH:	SOS	COMCNT		;REDUCE CHAR COUNT
	ILDB	CH,CPTR		;GET CHAR.
	JRST	ALTEO		;CONVERT OLD ALTMODES AND RETURN
	SUBTTL	Scan Command String for Character in TT

;IGNORING PAIRS STARTING WITH CHAR. IN TT1 AND ENDING WITH (TT)
;ASSUMED THAT CPTR IS SET
;NON-SKIP RETURN IF (TT) CAN'T BE FOUND
;SKIP RETURN IF FOUND
;CPTR LEFT SET FOR NEXT CHAR. IN COMMAND STRING

SKAN:	TXO	F2,S.NTRC	;INHIBIT TRACE ACTION WHILE SKANNING
	MOVEI	C,0		;CTR FOR <> AND "...' PAIRS
SKAN0:	TXZ	F2,S.SKMQ+S.SKMR+S.SFSN	;CLR SKIM FLAGS
	PUSHJ	P,SKRCH2	;GET COMMAND CHAR.
SKAN01:	CAIN	CH,(TT1)	;SECONDARY CHARACTER?
	AOJA	C,SKAN1		;YES, COUNT IT
	CAIN	CH,(TT)		;PRIMARY CHAR?
	JRST	SKAN10		;YES!
SKAN1:	CHKEO	EO21,SKAN0	;OLD STYLE SKAN IF EO = 1
	MOVEI	T,SKNTAB	;NO, WATCH OUT FOR TEXT STRINGS
SKAN00:	PUSHJ	P,DISPAT
	JRST	SKAN0		;NOT A TEXT-ARG COMMAND, IGNORE IT
SKAN2:	PUSHJ	P,SKRCH2	;GET CHAR AFTER "^"
	CAIE	CH,"A"+" "	;COULD BE LOWER CASE
	CAIN	CH,"A"
	JRST	SKAN7		;^A COMMAND
	CAIN	CH,"^"
	JRST	SKAN11		;^^ COMMAND
	JRST	SKAN0		;ORDINARY CTRL-COMMAND, FORGET IT
SKAN3:	PUSHJ	P,SKRCH2
	MOVEI	T,SK3TAB	;WHICH E COMMAND?
	JRST	SKAN00
SKAN4:	PUSHJ	P,SKRCH2	;WHAT FOLLOWS @?
	MOVEI	T,SK4TAB
	PUSHJ	P,DISPAT
	JRST	SKAN4		;MUST BE 1 OF THESE 4
SKAN09:	TXZ	F2,S.SFSN	;[1004] For FD or FK case
	JRST	SKAN12
SKAN9:	PUSHJ	P,SKIM		;IGNORE TO $
	JRST	SKAN0
SKAN7:	MOVEI	T,1		;IGNORE TO ^A
	JRST	SKAN5
SKAN8:	MOVEI	T,"!"		;IGNORE TO !
SKAN5:	PUSHJ	P,SKIM1		;IGNORE TO CHAR IN T
	JRST	SKAN0
SKAN66:	TXZ	F2,S.SFSN	;[1004] For @FD or @FK case
SKAN6:	PUSHJ	P,SKRCH2	;GET SEARCH DELIMITER
	SKIPA	T,CH		;IGNORE TO NEXT OCCURRENCE
SKAN12:	MOVEI	T,.CHESC	;DELIMITER IS ALTMODE
	PUSHJ	P,SKIMRQ	;SKIP TO DELIMITER & WATCH OUT FOR ^Q,^R
	JRST	SKAN0
SKAN13:	PUSHJ	P,SKRCH2	;GET INSERT DELIMITER
	SKIPA	T,CH		;IGNORE TO NEXT OCCURRENCE
SKAN14:	MOVEI	T,.CHESC	;DELIMITER IS ALTMODE
	PUSHJ	P,SKIM.R	;SKIP TO DELIMITER & WATCH OUT FOR ^R
	JRST	SKAN0
SKAN11:	PUSHJ	P,SKRCH2	;IGNORE NEXT CHAR.
	JRST	SKAN0
SKAN16:	MOVEI	T,SK5TAB	;TABLE FOR @F
	JRST	SKAN17
SKAN15:	MOVEI	T,SK1TAB	;TABLE FOR F COMMANDS
SKAN17:	TXO	F2,S.SFSN	;SIGNAL FS OR FN IN PROGRESS
	PUSHJ	P,SKRCH2	;GET CHAR AFTER F
	JRST	SKAN00
SKAN18:	PUSHJ	P,SKRCH2	;CHECK FOR POSSIBLE "PW"
	CAIE	CH,"W"
	CAIN	CH,"W"+" "	
	JRST	SKAN0		;IT IS...FORGET IT
	JRST	SKAN01		;IT'S NOT...WE MUST CHECK THIS CHAR FURTHER
SKAN10:	SOJGE	C,SKAN0		;IF MATCH JUST ENDS A PAIR, LOOP BACK
	TXZ	F2,S.NTRC	;ENABLE TRACING
	JRST	CPOPJ1		;OTHERWISE, WE HAVE WHAT WE WANT
;SKIM OVER TEXT
;ENTER AT SKIM TO SKIP TO NEXT ALTMODE, GIVING ^R & ^Q NO SPECIAL TREATMENT
;ENTER AT SKIM1 TO SKIP OVER ARBITRARY CHAR IN T, GIVING ^R & ^Q NO SPECIAL TREATMENT
;ENTER AT SKIM.R TO SKIP TO ARBITRARY CHAR IN T, UNLESS IT IS AFTER ^R
;ENTER AT SKIMRQ TO SKIP TO ARBITRARY CHAR IN T, UNLESS IT IS AFTER EITHER ^R OR ^Q

SKIMRQ:	TXO	F2,S.SKMQ	;CK FOR ^Q AND ^R
SKIM.R:	TXOA	F2,S.SKMR	;CK FOR ^R
SKIM:	MOVEI	T,.CHESC	;SKIP TO NEXT ALTMODE
SKIM1:	PUSHJ	P,SKRCH		;GET NEXT TEXT CHAR.
	JRST	APOPJ		;ERROR RETURN FROM SKAN ROUTINE
	CAIN	CH,(T)		;CHARACTER WE WANT?
	JRST	SKIM3		;YES
	CAIN	CH,.CHCNQ	;^Q?
	TXNN	F2,S.SKMQ	;YES, CK FLAG ON?
	JRST	.+2		;NO
	JRST	SKIM2		;YES
	CAIN	CH,.CHCNR	;^R?
	TXNN	F2,S.SKMR	;YES, CK FLAG ON?
	JRST	SKIM1		;NO, KEEP LOOKING
SKIM2:	PUSHJ	P,SKRCH		;GOBBLE UP NEXT CHARACTER
	JRST	APOPJ		;ERROR RETURN FROM SKAN
	JRST	SKIM1		;CONTINUE SKIMMING
SKIM3:	TXZE	F2,S.SFSN	;SKIMMING OVER FS OR FN?
	JRST	SKIM1		;YES, IGNORE 1ST DELIMITER
	POPJ	P,

;GET A SINGLE CHARACTER FROM COMMAND STRING
;TAKE ERROR RETURN FROM SKAN IF THERE ARE NO MORE

SKRCH2:	PUSHJ	P,SKRCH		;GET A COMMAND CHAR.
APOPJ:	POP	P,A		;ERROR RETURN FROM SKAN IF NO MORE CHARS.
	POPJ	P,
	SUBTTL	SKAN Routine Dispatch Tables

SKNTAB:	XWD	SKAN15,"F"
	XWD	SKAN14,"I"
	XWD	SKAN14,.CHTAB	;TAB
	XWD	SKAN12,"_"
	XWD	SKAN9,"O"
	XWD	SKAN8,"!"
	XWD	SKAN7,.CHCNA	;^A
	XWD	SKAN11,.CHCCF	;^^
	XWD	SKAN2,"^"
	XWD	SKAN3,"E"
	XWD	SKAN11,"U"
	XWD	SKAN11,"Q"
	XWD	SKAN11,"X"
	XWD	SKAN11,"G"
	XWD	SKAN11,"W"
	XWD	SKAN11,"M"
	XWD	SKAN11,"%"
	XWD	SKAN11,"["
	XWD	SKAN11,"]"
	XWD	SKAN4,"@"
	XWD	SKAN11,""""	;"
	XWD	SKAN12,"S"
	XWD	SKAN12,"N"
	XWD	SKAN18,"P"
	XWD	0,0
SK1TAB:	XWD	SKAN12,"S"	;S OR FS
	XWD	SKAN12,"N"	;N OR FN
	XWD	SKAN09,"D"	;[1004] FD
	XWD	SKAN09,"K"	;[1004] FK
	XWD	SKAN12,"_"	;[1017] F_
	XWD	0,0		;LIST TERMINATOR

SK3TAB:	XWD	SKAN9,"I"
	XWD	SKAN9,"P"
	XWD	SKAN9,"B"	;EB
	XWD	SKAN9,"R"	;ER
	XWD	SKAN9,"W"	;EW
	XWD	SKAN9,"Z"	;EZ
	XWD	SKAN9,"D"
	XWD	SKAN9,"L"
	XWD	SKAN9,"E"
	XWD	SKAN9,"N"
	XWD	SKAN9,"A"
	XWD	SKAN9,"V"
	XWD	0,0

SK4TAB:	XWD	SKAN16,"F"	;@F
	XWD	SKAN13,"I"	;@I
	XWD	SKAN6,"_"	;@_
	XWD	SKAN6,"S"	;@S
	XWD	SKAN6,"N"	;@N
	XWD	0,0
SK5TAB:	XWD	SKAN6,"S"	;@FS
	XWD	SKAN6,"N"	;@FN
	XWD	SKAN66,"D"	;[1004] @FD
	XWD	SKAN66,"K"	;[1004] @FK
	XWD	SKAN6,"_"	;[1017] @F_
	XWD	0,0
	SUBTTL	Accept Command String Routine

CLIS1:	PUSHJ	P,CRR		;TYPE CRLF
CLIS:
IFN <CCL*F%RSCN>,<		;[1011]
	SKIPN	CCLSW		;NEED CCL COMMAND?
	JRST	LIS0		;NO
	PUSHJ	P,@CCLSW	;[1011] Get the monitor or CCL command
	 JRST	LIS02		;[1011]  and don't say * (the prompt)
>
LIS0:	AOS	INI		;ALLOW ^G^G *I ON FIRST COMMAND
	PUSHJ	P,TTOPEN	;GET TELETYPE
	TXNE	FF,F.EMSG	;1ST CHARACTER IN ALREADY?
	JRST	LIS01		;YES
	PUSHJ	P,TYPPAG	;[1024] Type page number
	MOVEI	CH,"*"
	TXZ	F2,S.LCTT	;CLR TTY LC BIT
	SETO	A,		;GETLCH ON THIS LINE
	GETLCH	A
	TXNE	A,GL.LCM	;TTY LC ON?
	TXO	F2,S.LCTT	;YES, SET TTY LC BIT
	TXNN	F2,S.LIN	;WANT OUTPUT?
	TXO	F2,S.SLOG	;SUPPRESS * IN LOG FILE
	TXZ	FF,F.CCL	;NOT THIS AGAIN
	HRRZ	TT1,A		;GET UNIVERSAL I/O INDEX
	MOVEI	TT,.TOALT	;CODE FOR ALT TESTING
	MOVE	A,[XWD 2,TT]	;SET UP FOR TRMOP
	TRMOP.	A,		;GET ALTMODE INFO FROM MONITOR
	 LDB	A,[$POINT (F2,S.LCTT)] ;[1001] If this fails use LC bit
	SKIPE	A		;SHOULD WE CHANGE TO OLD ALTMODES?
	 TXOA	F2,S.NALT	;DON'T CONVERT
	  TXZ	F2,S.NALT	;DO CONVERT
IFN CRT,<
	MOVX	TT,.TOWID	;GET WIDTH OF TTY
	MOVE	A,[XWD 2,TT]	;USING A TRMOP.
	TRMOP.	A,
	  MOVEI	A,^D72		;ASSUME 72 IF NO TRMOP.
	MOVEM	A,TTYWID	;STORE IT
	SETZM	WRDFLG		;[2013] Reset the Control-W flag >
	PUSHJ	P,TYOM		;TYPE *
LIS01:	TXZ	F2,S.SLOG!S.ASTR!S.CRLF  ;[1037] Log file is fully active and
					 ;[1037]  the CR-LF suppress disabled
	TXOE	FF,F.EMSG	;[325] IS ONE ALREADY IN?
	JRST	LIS01A		;[325] YES
	TXO	FF,F.DDTM	;[325] NO, FORCE CHARACTER MODE ON IT
	PUSHJ	P,TYI
LIS01A:	MOVE	A,XFLAGS	;[1024] Get the extended flags
	TXNE	A,XF.DIM	;[1024] Are the immediate mode commands wanted?
	JRST	LIS01B		;[1024] No, go see if an '*'
	CAXN	CH,.CHLFD	;[325] IF 1ST CHAR IS LF,
	JRST	IM1LT		;[325] DO A 1LT
	CAXE	CH,.CHESC	;[1002] If it's an ESCape
	CAXN	CH,.CHCNH	;[325] If it's a backspace
	JRST	IMN1LT		;[325] Do a -1LT
	CAXE	CH,.CHBEL	;[1002] If it's a bell
	CAXN	CH,";"		;[325] If it's a semicolon
	JRST	IM0LT		;[325] Do a 0LT
	CAXN	CH," "		;[1037] If it's a space,
	JRST	IMXCT		;[1037] Do a M@
LIS01B:	CAIE	CH,"*"		;1ST CHAR AN ASTERISK?
	JRST	LIS02		;NO, CONTINUE NORMALLY
;SAVE PREVIOUS COMMAND STRING IN NAMED Q-REGISTER

	TXNE	F2,S.LIN	;[325] PUT THE * INTO LOG FILE?
	PUSHJ	P,LOGOUT	;[325] YES
	SETZM	EATCH		;NO CHARACTER READ YET
	TXNE	F2,S.GOIN	;ANY CMD STRG SEEN YET? IF NOT, * IS ILLEGAL
	JRST	LIS03		;OK
$NCS:	PUSHJ	P,CRR		;MUST PUT CR/LF BEFORE ?NCS
	ERROR	E.NCS
LIS03:	MOVE	C,COMLEN	;LENGTH OF STRING
	TXNE	F2,S.NRAD	;IS IT AN FS...$$?
	ADDI	C,1		;YES, DON'T OMIT LAST ALTMODE
	ADDI	C,2		;OMIT LAST ALTMODE
	HRRZ	B,CBUF		;[1010] Position to the first
IFN BUGSW,<MOVE B,CMDBFR>
	IMULI	B,5		;[1010]  character in bytes
	PUSHJ	P,X3		;TRANSFER STRING TO Q-REG
	TXO	FF,F.DDTM	;[1031] Get Q-register name for * command
	PUSHJ	P,TYI		;GET Q-REG NAME FOR * COMMAND
	MOVEM	CH,EATCH	;SAVE IN CASE ERROR
	TXNE	F2,S.LIN	;[325] PUT IN LOG FILE?
	PUSHJ	P,LOGOUT	;[325] YES
	MOVE	A,TIB+.BFPTR	;GET POINTER TO CURRENT CH
	MOVEM	A,CPTR		;STORE FOR POSSIBLE ERROR
	PUSHJ	P,QREGV2	;STORE 400000 IN QTAB
	MOVEM	B,QTAB-"0"(CH)
	TXZ	FF,F.EMSG	;NEXT INPUT CHAR NOT IN
	JRST	CLIS1		;[1031] So much for that command

LIS02:	SETZM	COMCNT		;COMCNT:=0
	TXZ	F2,S.NRAD	;CLEAR FLAG
	SETZM	SYMS
	MOVE	T,[XWD SYMS,SYMS+1]
	BLT	T,SYMEND-1
	MOVE	AA,CBUF
	MOVE	B,CBUFH

LI1:	TXZ	FF,F.ALT+F.BELL+F.XPLN+F.EM
LI2:	TXZ	F2,S.SLOG	;THINGS MAY AGAIN ENTER LOG FILE
	CAILE	B,(AA)		;COMMAND BUFFER EXCEEDED?
	JRST	LI3		;NO


;TO SEE IF TECO WILL NEED MORE CORE FOR COMMAND
;BUFFER EXPANSION. IF SO, GET IT

	MOVE	C,Z		;GET THE NUMBER OF CHARACTERS NOW
	ADDI	C,500		;WILL WE OVERFLOW IF THIS IS REQUESTED?
	CAMGE	C,MEMSIZ	;[320] WILL THIS OVERFLOW?
	JRST	.+5		;NO, FORGET THIS EVER HAPPENED
	MOVEM	17,AC2+15	;[354] Will overflow, therefore save AC#17
	MOVE	17,C		;THIS IS THE REQUEST FOR MEMORY
	PUSHJ	P,GRABKQ	;GET THE NECESSARY CORE
	MOVE	17,AC2+15	;[354] Restore AC#17
	SUBTTL	 Expand the Command Buffer

	ADDI	B,100		;YES. EXPAND COMMAND BUFFER 100 WORDS.
	MOVE	C,Z
	IDIVI	C,5		;C:=DATA BUFFER END WORD ADDRESS.
	MOVE	D,QRBUF
	PUSH	P,F2		;KLUDGE TO PROTECT F2 UNTIL AC'S ARE REORDERED
	IDIVI	D,5		;D:=Q-REG BUFFER BASE WORD ADDRESS.
	POP	P,F2		;RESTORE FLAGS
	SUBM	C,D		;D:=NO. OF WORDS IN Q-REG BUFFER AND DATA BUFFER.
	MOVE	CH,(C)
	MOVEM	CH,100(C)	;MOVE Q-REG AND DATA BUFFERS UP 100 WORDS.
	SOS	C
	SOJGE	D,.-3
	MOVEI	C,500
	ADDM	C,BEG		;BEG:=C(BEG)+500
	ADDM	C,PT		;PT:=C(PT)+500
	ADDM	C,Z		;Z:=C(Z)+500
	ADDM	C,QRBUF		;QRBUF:=C(QRBUF)+500
	MOVE	D,Z
LI3:	MOVEM	B,CBUFH		;NO. RESET HIGH END OF COMMAND BUFFER.
IFN CRT,<
	SKIPE	WRDFLG		;[2013] Control-W in progress?
	JRST	[SKIPE CRTTYP		;[1055] Yes, is the terminal a CRT
		 JRST  DELCH1		;[1055] Yes, continue deleting
		 JRST  RUBOUT]		;[1055] Continue deleting >
	TXZN	FF,F.EMSG	;1ST CHAR IN ALREADY?
	PUSHJ	P,TYI		;GET A NON-NULL CHARACTER IN CH
IFN CRT,<SKIPE	CRTTYP		;IF TTY, THEN NO AUX CHARACTER
	 CAME	CH,BACRUB	;EXTRA DELETE CHARACTER OR
	>
	CAIN	CH,.CHDEL	;RUBOUT?
	JRST	DELCHR		;YES
IFN CRT,<
	CAXN	CH,.CHCNW	;[2013] Is the character a Control-W?
	JRST	[MOVE  A,XFLAGS		;[1055] Get the extended flags
		 TXNN  A,XF.CNW		;[1055] Skip if word delete is wanted
		 JRST  LI3A		;[1055] Assume it's for uppercase
		 SETOM WRDFLG		;[1055] Set the Control-W flag
		 TXO   F2,S.SLOG	;[1055] Suppress output to the log
		 SKIPN CRTTYP		;[1055] Is the terminal a CRT?
		 JRST  RUBOUT		;[1055] Yes, continue deleting
		 PUSHJ P,BAC2		;[2013] Eat the ^ and W
		 JRST  DELCH1]		;[2013] Start the delete process >

LI3A:	TXZ	F2,S.SLOG
	AOS	A,COMCNT	;NO. INCREMENT COMMAND CHARACTER COUNT
	IDPB	CH,AA		;STORE CHARACTER IN COMMAND BUFFER.
LI4:	CAIE	CH,.CHESC	;ALT-MODE?
	JRST	LI5		;NO
	TXZN	F2,S.CTLR	;PREVIOUS CHAR. A ^R?
	JRST	LI7		;NO
	CHKEO	EO21,LI7	;IF EO=1, NEVERMIND ^R
LI9:	TXZ	FF,F.BELL	;ALTMODE CLEARS BELL FLAG
	JRST	LI2

LI7:	TXON	FF,F.ALT	;YES. SET ALT-MODE FLAG. WAS IT ON?
	JRST	LI9		;NO
LI7A:	MOVEM	A,COMAX		;[1037] Set command character address upper bound
	MOVEM	A,COMLEN	;SAVE IN CASE OF * COMMAND NEXT
	MOVE	AA,CBUF		;INIT COMMAND BYTE PTR
	MOVE	B,AA		;IN CASE INTO LOG FILE
	MOVEM	AA,CPTR
	SKIPE	CCLSW		;READING CCL CMD?
	PUSHJ	P,TTOPEN	;YES, INIT TTY
	TXNE	F2,S.LIN	;PUT YOUR TYPIN IN LOG FILE?
	PUSHJ	P,BUFTYP
	TXNN	F2,S.LIN	;INPUT TO FILE TOO?
	TXO	F2,S.SLOG	;NO, SO DON'T PUT THIS CRLF THERE
	TXZN	F2,S.CRLF	;[1037] Skip if CRLF isn't wanted
	PUSHJ	P,CRR		;TYPE CRLF
	TXZ	F2,S.SLOG
	SETZM	CCLSW		;FINISHED WITH CCL READ
	SETOM	XCTING		;SET NO SCREW I FLAG
	JRST	CD		;RIGHT, SO DECODE COMMAND
BUFTYP:	MOVE	A,COMCNT	;HOW MANY CHARACTERS TO TRANSFER
BUFTY0:	TXNE	F2,S.LOUT	;[325]
	TXO	F2,S.OLOG
LOGLP:	ILDB	CH,B		;GET CHARACTER
	TXNN	F2,S.LOUT	;SENDING OUTPUT TOO?
	PUSHJ	P,LOGOUT	;NO, SEND VEBATIM
	TXNE	F2,S.LOUT
	PUSHJ	P,TYOM		;SEND TO LOG FILE
	SOJG	A,LOGLP		;EMPTY BUFFER
	TXO	F2,S.OLOG	;ONLY IN LOG FILE IF ANYWHERE
	TXNN	F2,S.LOUT
	PUSHJ	P,CRR
	TXZ	F2,S.OLOG	;SO TYPE OUT HAPPENS CORRECTLY
	POPJ	P,
	SUBTTL	Process Special Command Editing Characters

LI5:	CAIN	CH,.CHCNR	;^R?
	JRST	CNTRLR		;YES
	TXZ	F2,S.CTLR	;NO, CLR FLAG IN CASE PRECEDING CHAR WAS
	TXO	F2,S.SLOG	;DON'T TYPE ANYTHING INTO LOG FILE HERE
	CAIN	CH,.CHCNU	;^U?
	JRST	CNTRLU		;YES
	CAIN	CH,.CHBEL	;BELL?
	JRST	LI6		;YES
	TXZN	FF,F.BELL	;NO, PREVIOUS CHAR A BELL?
	JRST	LI1		;NO, GET NEXT CHARACTER
	CAXE	CH,"*"		;[1056] Is this an astrisk?
	CAIN	CH,"."		;No, is this a period?
	JRST	[MOVE  D,COMCNT
		 SUBI  D,2
		 SETZM COMCNT
		 MOVE  AA,CBUF
		 ILDB  CH,AA
		 SKIPN D
		 PUSHJ P,BACKUP
		 PUSHJ P,RETYP3
		 JRST LI2]	;RETYPE ENTIRE COMMAND
	CAIE	CH," "		;YES, IS THIS A SPACE?
	JRST	LI1		;NO
	PUSHJ	P,RETYPE	;YES, GO DO A RETYPE
	JRST	LI2

RETYPE:	PUSHJ	P,BACKUP	;BACK OFF ^G<SPACE>
	SOS	D,COMCNT	;MARK CURRENT POSITION
	PUSHJ	P,BACKLN	;BACK UP TO BEG OF LINE
	JRST	RETYP3		;HIT BEG OF COMMAND STRING
	JRST	RETY3A		;[331] Found a CR-EOL

RETYP3:	PUSH	P,CH		;SAVE 1ST CHAR
	PUSHJ	P,CRR		;TYPE CR-LF BEFORE COMMAND LINE
	MOVEI	CH,"*"		;RETYPE THE *
	PUSHJ	P,TYOM
	POP	P,CH		;RETRIEVE 1ST CHARACTER
RETY3A:	PUSH	P,ETVAL		;[331] Save ET value
	SETZM	ETVAL		;[331] ET=0 for retyping
	JUMPE	CH,RETYP4	;DON'T PRINT ^@ IF NULL COMMAND STRING
RETYP1:	SKIPL	COMCNT		;SEE IF ANY COMMANDS
	PUSHJ	P,TYOM		;TYPE A CHAR OF COMMAND LINE
RETYP4:	AOS	C,COMCNT	;ADVANCE COMMAND CTR
	CAIL	C,(D)		;BACK IN PLACE?
	JRST	RETYP2		;YES
	ILDB	CH,AA		;NO, GET NEXT CHAR
	JRST	RETYP1

RETYP2:	POP	P,ETVAL		;[331] Restore ET value
	CAIN	CH,.CHESC	;LOOKING AT AN ALTMODE?
	TXO	FF,F.ALT	;YES, BETTER SET FLAG
	POPJ	P,		;RETURN
LI6:	TXOE	FF,F.BELL	;YES. SET BELL FLAG. TWO SUCCESSIVE BELLS?
	SOJA	A,LI8		;YES, REJECT COMMAND
	TXO	FF,F.DDTM	;GET ANOTHER CHAR WITH TTCALL 0
	JRST	LI2

LI8:	MOVEM	A,COMLEN
	PUSHJ	P,CRR		;YES. TYPE A CRLF
	TXO	F2,S.GOIN!S.ASTR	;SO YOU CAN DO *I AFTER ^G^G
	JRST	GO		;AND CLEAR COMMAND BUFFER.
;BACKUP BYTE POINTER IN AA, LOAD APPROPRIATE CHARACTER IN CH
; AND ADJUST COMCNT

BACKUP:	ADD	AA,[7B5]	;BACK UP CHAR PTR
	JUMPG	AA,.+2		;OK NOW?
	SUB	AA,[430000,,1]	;NO NEEDS FURTHER FIXING
	LDB	CH,AA		;LOAD CHAR
	SOS	C,COMCNT	;DECREMENT COMMAND COUNT
	POPJ	P,

;BACKUP TO BEGINNING OF CURRENT LINE
;CALL:	PUSHJ	P,BACKLN
;	RETURN IF BACKUP WENT TO BEGINNING OF COMMAND STRING
;	RETURN IF CR-EOL COMBINATION FOUND

BACKLN:	PUSHJ	P,BACKUP	;BACK UP ONE CHAR
	JUMPLE	C,CPOPJ		;RETURN IF NOTHING LEFT
BACKL1:	PUSHJ	P,CKEOL		;IS THIS AN EOL CHAR?
	JRST	BACKLN		;NO, KEEP BACKING UP
	PUSHJ	P,BACKUP	;YES, BACK UP ONE MORE
	CAIE	CH,.CHCRT	;IS THIS A CR?
	JRST	BACKL1		;NO, MAYBE ANOTHER EOL?
	JRST	CPOPJ1		;YES, TAKE SKIP RETURN

;PROCESS CONTROL-U

CNTRLU:	PUSHJ	P,TYOM		;ECHO THE ^U
	PUSHJ	P,BACKLN	;BACK UP TO BEG OF LINE
	JUMPLE	C,CTLU1		;IF NOTHING LEFT, RETYPE *
	AOS	COMCNT		;KEEP CRLF
	IBP	AA
CTLU1:
IFN CRT,<SKIPE	CRTTYP		;SPECIAL TERMINAL?
	JRST	[SKIPN CTUSEQ	;DO WE HAVE A SPECIAL SEQUENCE?
		 JRST  .+1	;NO, USE A REGULAR CRLF
		 MOVEI A,CTUSEQ	;YES, GET SPECIAL SEQUENCE
		 PUSHJ P,OUTMES	;OUTPUT IT
		 JRST .+2]
	>
	PUSHJ	P,CRR		;OUTPUT A REGULAR CRLF
	JUMPLE	C,CLIS		;IF NOTHING LEFT, START FROM SCRATCH
	JRST	LI1		;CONTINUE TYPE-IN

;CONTROL-R IN COMMAND MODE PREVENTS AN ALTMODE AFTER IT
;FROM BEING A TERMINATOR

CNTRLR:	TXZN	F2,S.CTLR	;^R ON ALREADY?
	TXO	F2,S.CTLR	;NO, SET FLAG
	JRST	LI1
	SUBTTL	Special "Immediate" Command Processor

;[325]  HERE TO MAKE AN INITIAL <LF> DO A "1LT$$"

IM1LT:	TXO	F2,S.SLOG	;TURN OFF LOG FILE BRIEFLY
	MOVEI	CH,.CHCRT	;[331] Type a <CR> to get to left margin
	PUSHJ	P,TYOA		;[331]
IFN CRT,<
	SKIPE	CRTTYP		;DO WE HAVE A SCREEN,
	SKIPN	DELLF		;AND A WAY OF GOING UP?
	JRST	IM1LTA		;NO
	MOVE	A,CRTTYP	;[1003] Get the terminal flags
	TRNE	A,.CDLF.	;[1003] Skip if not funny LF delete
	SKIPA	A,[DELVT]	;[1003] Use the other delete LF sequence
	MOVEI	A,DELLF		;WE ARE ON A CRT,
	PUSHJ	P,OUTIMG	;[331] CANCEL THE <LF> SO WE DON'T WASTE SPACE
	MOVEI	A,BACSEQ	;NOW GET RID OF THE "*" IN CASE OF BLANK LINE
	PUSHJ	P,OUTMES	;...
	>	;END OF CRT
IM1LTA:	HRRI	B,[BYTE (7) "+","L","T",.CHESC,.CHESC]	;LOG FILE COMMAND
	JRST	IMCOM		;GO TO THE COMMON CODE

;HERE TO MAKE A <^H> DO A "-LT$$"

IMN1LT:	HRRI	B,[BYTE (7) "-","L","T",.CHESC,.CHESC]	;[331] COMMAND FOR LOG FILE
	TXOA	FF,F.NEG	;[331] FAKE A -1 ARG
				;AND FALL INTO IM0LT FOR A WHILE...

;HERE TO MAKE A <;> DO A "0LT$$"

IM0LT:	TXZ	FF,F.NEG	;[331] MAKE SURE F.NEG IS OFF
	TXO	F2,S.SLOG	;TURN OFF LOG FILE
IFN CRT,<
	SKIPE	CRTTYP		;[331] ARE WE ON A SCREEN?
	JRST	[SKIPE	CTUSEQ		;[331] YES, DO WE HAVE A LINE DELETE MECHANISM?
		JRST	[MOVEI A,CTUSEQ	;[331] YES, WE MUST BE ON A SCREEN
			 PUSHJ P,OUTMES	;[331] DELETE THE LINE
			 JRST IM0LT1]	;[331] GET BACK IN LINE
					;[331] NO EOL, SO WE DO IT WITH BACKSPACE
		MOVEI	A,BAC2		;[1002] Delete 2 characters
		CAXN	CH,.CHCNH	;[1002] A backspace?
		MOVEI	A,BACONE	;[1002] Yes, delete 1 character
		CAXN	CH,.CHBEL	;[1002] A bell?
		MOVEI	A,BAC3		;[1002] Yes, delete 3 characterS
		PUSHJ	P,(A)		;[1002] Delete some characters
		JRST	IM0LT1]		;[331] NOW PROCEED
	>	;END OF CRT
	PUSHJ	P,CRR		;NOT A SCREEN--DO A CRLF
IM0LT1:	TXNE	FF,F.NEG	;HAVE WE ALREADY FAKED A -1 ARG?
	JRST	IMCOM		;YES, SKIP AHEAD TO COMMON CODE
	TXO	FF,F.ARG	;FAKE THE PRESENCE OF A 0 ARG.
	HRRI	B,[BYTE (7) "0","L","T",.CHESC,.CHESC]	;COMMAND FOR LOG FILE

	PFALL	IMCOM		;[1001] Fall into common code
IMCOM:	HRLI	B,(POINT 7,)	;FORM POINTER FOR LOG FILE COMMAND
	MOVEI	A,5		;FIVE CHARACTERS
	MOVEM	A,COMLEN	;SAVE IN CASE OF * COMMAND
	MOVE	AA,CBUF		;GET START OF COMMAND BUFFER
	POP	B,1(AA)		;STORE COMMAND THERE
	AOBJP	B,.+1		;READJUST B
	TXZ	F2,S.SLOG	;TURN LOG FILE BACK ON
	TXNN	F2,S.LIN	;TO PUT IT INTO LOG FILE?
	JRST	IMCOM1		;NO, SKIP THIS
	PUSH	P,F2		;SAVE FLAGS
	TXZ	F2,S.LOUT	;PRETEND /NOOUT SO CRLF GETS PUT IN
	PUSHJ	P,BUFTY0	;GO INSERT COMMAND IN LOG FILE
	POP	P,F2		;RESTORE FLAGS
IMCOM1:	SETZM	B		;PUT ZERO INTO B IN CASE WE'RE DOING "0LT"
	PUSHJ	P,GETARG	;COMPUTE +L/0L/-L
	XOR	B,C		;APPLY L MOVEMENT TO POINTER
	XORM	B,PT		;...
	TXZ	FF,F.ARG!F.ARG2	;FAKE NO ARGS
	PUSHJ	P,TYPE		;GO TYPE THE LINE
	JRST	GO

;[1037]	Here to make initial <space> do a "M@$$"

IMXCT:	MOVX	CH,<"Z"-<"A"-"9"-1>+2>  ;[1037] Fake up an "@"
	PUSHJ	P,QTXTS1	;[1037] See if Q-register "@" contains text
	 JRST	[MOVX CH," "		;[1037] Restore the space
		 JRST LIS02]		;[1037] No macro, do the normal thing
IFN CRT,<
	SKIPN	CRTTYP		;[1037] On a CRT
	JRST	IMXCT2		;[1037] No, don't be fancy then
	TXO	F2,S.CRLF	;[1037] Set the no CR-LF flag
	SKIPE	CTUSEQ		;[1037] Skip if no delete line mechanism
	JRST	[MOVEI A,CTUSEQ		;[1037] Delete the
		 PUSHJ P,OUTMES		;[1037] "* "
		 JRST  IMXCT1]		;[1037] Go execute the command
	PUSHJ	P,BACTWO	;[1037] Blank out
	MOVEI	A,BACCHR	;[1037]  the
	PUSHJ	P,OUTMES	;[1037]  "* "
IMXCT1:	OUTPUT	TTY,		;[1037] Dump the TTY buffer >
IMXCT2:	MOVX	A,^D4		;[1037] Set up the command
	MOVEM	A,COMCNT	;[1037]  string length
	MOVE	B,[BYTE (7) "M","@",.CHESC,.CHESC]  ;[1037] Fake a "M@$$"
	MOVEM	B,@CBUF				    ;[1037]  command
	JRST	LI7A		;[1037] Go do the command
	SUBTTL	Rubout Processor

IFE CRT,<
DELCHR:     >
RUBOUT:	TXO	F2,S.SLOG
	SKIPG	COMCNT		;ANYTHING TYPED IN?
	JRST	CLIS1		;NO, RETYPE *
IFN RUBSW,<
	SETO	A,		;GETLCH ON THIS TTY
	GETLCH	A		;SET TO SUPPRESS ECHOING
	TLO	A,4
	SETLCH	A
	PUSHJ	P,SPLAT		;ACT LIKE THE MONITOR
	JRST	RUB4
RUB1:	SKIPGE	COMCNT		;PAST BEGINNING OF COMMAND STRING YET?
	JRST	RUB3		;YES
	PUSHJ	P,TYIDDT	;GET ONE CHARACTER
	CAIE	CH,.CHDEL	;RUBOUT?
	JRST	RUB2		;NO
RUB4:	>
	LDB	CH,AA		;RELOAD THE CHAR.
	SKIPE	A,WRDFLG	;[1055] Doing a Control-W erase?
	JRST	[PUSHJ P,DELWRD		;[1055] Should the character be deleted?
		  JRST LI1		;[1055] No, back to normal processing
		 JRST RUB5]		;[1055] Don't echo the characters
	SKIPE	COMCNT		;UNLESS AT BEGINNING OF COMMAND STRING,
	PUSHJ	P,TYOM		;ECHO THE DELETED CHAR.
RUB5:	PUSHJ	P,BACKUP	;[1055] Back over the character
IFN	RUBSW,<JUMPLE	C,RUB1>
IFE	RUBSW,<JUMPLE	C,LI1>
	CAIN	CH,"R"-100	;IF PREVIOUS CHARACTER WAS ^R
	TXO	F2,S.CTLR	;RESET FLAG
IFE RUBSW,<JRST LI1>		;RESUME TYPE-IN
IFN RUBSW,<
	JRST	RUB1		;TRY NEXT INPUT CHAR.
RUB2:	PUSH	P,CH		;SAVE THIS GOOD GUY
	PUSHJ	P,SPLAT		;TYPE THE SECOND \
	POP	P,CH		;GET THAT CHAR. BACK
	CAIE	CH,.CHCNU	;CTRL-U?
	PUSHJ	P,TYOM		;NO, ECHO IT
	PUSHJ	P,TTCREE	;RESET TTCALL FOR ECHOING
	JRST	LI3A		;PROCESS THIS CHAR.
RUB3:	PUSHJ	P,SPLAT		;SECOND \
	PUSHJ	P,TTCREE	;RESET TTCALL MODE TO NORMAL
	JRST	CLIS1		;START A NEW COMMAND STRING
	>
;TYPE BACKSLASH

IFN RUBSW,<
SPLAT:	MOVEI	CH,"\"
	JRST	TYOM
	>

;RESET TTCALL FOR ECHOING

IFN RUBSW,<
TTCREE:	SETO	A,		;GETLCH ON THIS TTY
	GETLCH	A
	TLZ	A,GL.LCP	;TURN OFF NO ECHO BIT
	SETLCH	A
	POPJ	P,
	>
	SUBTTL	Video Rubout Processor

IFN CRT,<

DELCHR:	MOVE	A,CRTTYP	;GET CRT FLAGS
	SKIPN	CRTTYP		;[2015] If not a CRT
	JRST	RUBOUT		;THEN GO TO OLD ROUTINE
	TXO	F2,S.SLOG	;NOTHING GOES INTO LOG FILE
	MOVEI	A,CANRUB	;CANCEL THE EFFECT, IF ANY, OF THE RUBOUT
	CAIE	CH,.CHDEL
	MOVEI	A,CANBAK	;OR THE BACKSPACE
	PUSHJ	P,OUTMES
DELCH1:				;[2013] Here when looping on Control-W
	SKIPG	COMCNT		;HAS ANYTHING BEEN SEEN?
	JRST	BACNON		;NO
	PUSHJ	P,HORPOS	;GO FIGURE OUT HORIZONTAL POSITION
	LDB	CH,AA		;GET DOOMED CHARACTER

	SKIPN	A,WRDFLG	;[2013] Doing Control-W erase?
	JRST	DELCH2		;[2013] No, avoid some code
	PUSHJ	P,DELWRD	;[1055] Should the character be deleted?
	 JRST	LI1		;[1055] No, back to normal processing
	MOVEI	A,BACCHR	;[2013] Back up the cursor as
	PUSHJ	P,OUTMES	;[2013]  if a rubout was typed
	LDB	CH,AA		;[2013] Restore the deleted character

DELCH2:	CAIG	CH,.CHBEL	;[2013] ^G OR LESS?
	JRST	BACDUB		;YES, THEY ARE TWO WIDE
	CAIN	CH,.CHCNH	;BACKSPACE?
	JRST	BACBAK
	CAIN	CH,.CHTAB	;TAB?
	JRST	BACTAB
	CAIG	CH,.CHFFD	;EOL? (LF, VT, FF)
	JRST	BACEOL
	CAIN	CH,.CHCRT	;CARRIAGE RETURN?
	JRST	BACCR
	CAIE	CH,.CHESC	;ALTMODE,
	CAIL	CH," "		;BLANK OR GREATER?
	JRST	BACNOR
BACDUB:	PUSHJ	P,BACTWO	;HERE TO RUBOUT A CHAR OF WIDTH 2
	TRNA			;[331]
BACNOR:	PUSHJ	P,BACONE
DELDON:	PUSHJ	P,BACKUP	;WIPE IT FROM COMMAND STRING
	CAIL	E,(OU)		;ARE WE BACK TO A FREE CRLF?
	JRST	LI1		;NO, RETURN
DELFIN:	PUSHJ	P,HORPOS	;YES, GO RECALCULATE LENGTH
	PUSHJ	P,BACREW	;AND RETYPE ABOVE LINE
	JRST	LI1		;AND RETURN

BACEOL:	MOVEI	T,1		;GET MULTIPLIER (LF=1)
	CAIE	CH,.CHLFD	;IF NOT LF,
	MOVE	T,VTMUL-13(CH)	;GET REAL MULTIPLIER
	MOVEI	TT,DELLF-12(CH)	;GET PROPER STRING
	MOVEI	A,FORCHR	;GET READY TO UNDO THE BACKSPACE
	MOVE	CH,CRTTYP	;GET THE FLAGS FOR THIS CRT
	TRNE	CH,.CWAP.	;IF THIS CRT DOES WRAP AROUND,
	SKIPE	E		;OR IF WE ARE NOT AT THE LEFT MARGIN
	PUSHJ	P,OUTMES	;THEN CANCEL THE BACKSPACE
EOL1:	JUMPLE	T,DELDON	;FINISHED?
	MOVE	A,TT		;GET STRING
	PUSHJ	P,OUTIMG	;[331] AND TYPE IT
	SOJA	T,EOL1		;LOOP
BACCR:	MOVEI	A,DELCR
	PUSHJ	P,OUTIMG	;[331]
	IBP	AA
	AOS	COMCNT
	PUSHJ	P,RETYPE	;FAKE A ^G<SPACE>
	JRST	LI2		;WE'RE DONE

BACBAK:	MOVEI	A,FORCHR	;CANCEL A BACKSPACE
	PUSHJ	P,OUTMES
	PUSHJ	P,BACKUP
	JRST	LI1

BACNON:	MOVE	CH,CRTTYP	;GET FLAGS
	SETZM	WRDFLG		;[2013] Reset the Control-W flag
	TRNE	CH,.CNCR.	;SHOULD WE SEND A LONE CR?
	JRST	CLIS		;NOPE
	MOVEI	CH,.CHCRT	;TYPE A CR
	PUSHJ	P,TYOA
	JRST	CLIS		;AND RETYPE *

HORPOS:	MOVE	TT1,COMCNT	;SAVE CURRENT CHARACTER COUNT
	SETZ	E,		;INIT LINE WIDTH TO 0
	LDB	CH,AA		;GET CURRENT CHAR
	PUSHJ	P,BACKL1	;BACK UP TO THE BEGINNING OF CURRENT LINE
	AOS	E		;IF INITIAL LINE, THEN ACCOUNT FOR *
	MOVE	T,AA		;SAVE POINTER
	MOVE	TT,COMCNT	;AND COMMAND COUNT
	IBP	T		;BUMP THE POINTER UP, TO PLEASE RETYPE
POS2:	MOVE	OU,E		;SAVE LENGTH
	ILDB	CH,AA		;GET NEXT CHAR
	PUSHJ	P,LENCHR	;CALCULATE LENGTH OF CHARACTER
	AOS	D,COMCNT	;BUMP CHAR COUNT
	CAIL	D,(TT1)		;ARE WE BACK IN PLACE YET?
	POPJ	P,		;YES
	JRST	POS2

BACTAB:	PUSHJ	P,BACKUP	;GET RID OF THE TAB
	CAIGE	E,(OU)		;ARE WE AT A FREE CRLF?
	JRST	DELFIN		;YES
	SUBI	E,1(OU)		;GET LENGTH OF TAB-1
BTAB1:	JUMPLE	E,LI1		;RETURN IF LENGTH IS 0
	MOVEI	A,BACCHR	;BACK UP
	PUSHJ	P,OUTMES
	SOJA	E,BTAB1		;LOOP

BACREW:	MOVEM	T,AA		;HERE WHEN WE BACK UP OVER A FREE CRLF
	MOVEM	TT,COMCNT	;RESTORE AA AND COMCNT (LAST TIME POS=0)
	SKIPN	DELLF		;IF DELLF IS NULL, DONT BOTHER WITH THIS
	JRST	BACRW0
	MOVEI	A,DELLF
	PUSHJ	P,OUTIMG	;MOVE UP TWO LINES
	PUSHJ	P,OUTIMG
	PUSHJ	P,CRR		;TYPE A CRLF TO RESET HOR. POS.
BACRW0:	MOVEI	CH,"*"		;ARE WE AT THE BEGINING OF A COMMAND?
	SKIPN	COMCNT
	PUSHJ	P,TYOA		;YES
BACRW1:	LDB	CH,AA
	PUSHJ	P,CKEOL		;WE DONT WANT EOL'S
	PJRST	RETY3A		;[331] GO FAKE ^G<SPACE>
	IBP	AA		;GET THE NEXT ONE
	AOS	COMCNT
	JRST	BACRW1		;LOOP

;These routines are used to blank out characters on the screen.
;BAC1 will send backspace-space-backspace to rub out one character.
;BACONE will send space-backspace, when a backspace has already been done.
;BAC2 and BACTWO will eat two (2) characters off the screen.
;BAC3 and BACTRE will eat three (3) characters off the screen.

BAC3:	MOVEI	A,BACCHR	;[1002] Back up the
	PUSHJ	P,OUTMES	;[1002]  cursor
BACTRE:	PUSHJ	P,BACONE	;[1002] Erase the character,
				;[1002]  then fall into BAC2
BAC2:	MOVEI	A,BACCHR	;[1002] Back up the
	PUSHJ	P,OUTMES	;[1002]  cursor
BACTWO:	PUSHJ	P,BACONE	;[1002] Erase the character,
				;[1002]  then fall into BAC1
BAC1:	MOVEI	A,BACCHR	;[1002] Back up the
	PUSHJ	P,OUTMES	;[1002]   thecursor
BACONE:	MOVEI	A,BACSEQ	;[1002] Erase the character
	PJRST	OUTMES		;[1002]  and return
;ROUTINE TO CALCULATE THE WIDTH OF A CHARACTER

LENCHR:	SETZ	D,
	CAIE	CH,.CHESC	;AN ALTMODE
	CAIL	CH," "		;OR ANYTHING " " OR OVER
	AOJA	D,LEN1		;IS OF WIDTH 1
	CAIN	CH,.CHCNH	;A BACKSPACE IS -1
	SOJA	D,LEN2
	CAIN	CH,.CHLFD	;A LINEFEED IS 0
	JRST	LEN1
	CAIN	CH,.CHVTB	;A VERTICAL TAB MAY BE SPECIAL
	JRST	[ADD D,VTWID
		 JRST LEN1]
	CAIN	CH,.CHFFD	;A FORM FEED MIGHT ALSO
	JRST	[ADD D,FFWID
		 JRST LEN1]
	CAIE	CH,.CHTAB	;A TAB?
	JRST	[ADDI D,2	;NOPE, ALL ELSE OF WIDTH 2
		 JRST LEN1]
	ADDI	E,10		;STANDARD TAB WIDTH
	TXZ	E,7		;BUT MUST BE MULTIPLE OF 8
	MOVEI	D,10
	SKIPA
LEN1:	ADD	E,D		;THIS IS THE NEW LENGTH
LEN2:	CAMG	E,TTYWID
	POPJ	P,
	MOVE	E,D		;WE ARE AT A FREE CRLF
	MOVE	T,AA		;SO SAVE THE BP AND THE COUNT
	MOVE	TT,COMCNT
	POPJ	P,		;Return

>	;END OF CRT CONDITIONAL
	SUBTTL	DELWRD - Delete a Character from a Word


;DELWRT - Delete a character from a word
;Call:	MOVE	CH,<The previous character input>
;	PUSHJ	P,DELWRD	;See if the character should be deleted
;	 * Non-skip return - Finished deleting characters *
;	* Skip return - Delete the character *
;Uses:	A and CH

IFN CRT,<
DELWRD:	CAXLE	CH,"_"		;[1055] A lowercase character?
	ADDX	CH,"A"-"a"	;[1055] Yes, convert to uppercase
	MOVE	CH,DTB(CH)	;[1055] Get the Control-W flags
	JUMPL	A,DELWR2	;[1055] Go test for a trailing space/tab
	TXNN	CH,DC.SYM	;[1055] A leading special symbol?
	PJRST	CPOPJ1		;[1055] No, give a "Delete Return"
DELWR1:	SETZM	WRDFLG		;[1055] Stop deleting
	POPJ	P,		;[1055] Get the "Finished Return"

DELWR2:	TXNN	CH,DC.SPC	;[1055] A trailing space or tab?
	JRST	DELWR3		;[1055] No, go see if EOL character
	SOS	WRDFLG		;[1055] Increment the trailing space/tab count
	PJRST	CPOPJ1		;[1055] Give a "Delete Return"

DELWR3:	MOVNS	A,WRDFLG	;[1055] Get the trailing space/tab count
	TXNE	CH,DC.EOL	;[1055] An EOL character?
	CAXN	A,^D1		;[1055] Yes, any trailing spaces/tabs deleted?
	PJRST	CPOPJ1		;[1055] No, give a "Delete Return"
	JRST	DELWR1		;[1055] Turn off deleting flag >
	SUBTTL	Type Current Page of Input

TYPPAG:	SKIPE	CH,XFLAGS	;[1024] Skip if no flags are set
	TXNN	CH,XF.CPN	;[1024] Skip if current page number wanted
	POPJ	P,		;[1024] Return
	MOVE	B,NFORMS	;[1024] Get the current page number
	CAMN	B,CURPAG	;[1024] Skip if not the same page number
	POPJ	P,		;[1024] Return
	MOVEM	B,CURPAG	;[1024] Save for next time
	MOVEI	CH,"["		;[1024] Output
	PUSHJ	P,TYOM		;[1024]  "["
	MOVX	CH,JW.WPR	;[1024] Get the prefix flag
	TDNN	CH,ERRLEN	;[1024] Skip if the prefix is wanted
	JRST	TYPPA1		;[1024] Don't print the prefix
	TXNE	FF,F.EOFI	;[1024] Skip if not EOF on input
	JRST	[JSP	A,CONMES	;[1024] Output the
		 ASCIZ	~TECEOF~	;[1024]  prefix
		 JRST	TYPPA1]		;[1024] Skip some code
	JSP	A,CONMES	;[1024] Output the
	ASCIZ	~TECPAG~	;[1024]  prefix
TYPPA1:	MOVX	CH,JW.WFL	;[1024] Get the first line flag
	TDNN	CH,ERRLEN	;[1024] Skip if first line wanted
	JRST	TYPPA2		;[1024] Go output "]"
	JSP	A,CONMES	;[1024] Output
	ASCIZ	~ Page ~	;[1024]  "page"
	PUSHJ	P,DECMS		;[1024] Output the page number
	TXNN	FF,F.EOFI	;[1024] Skip if EOF on input
	JRST	TYPPA2		;[1024] Skip a message
	JSP	A,CONMES	;[1024] Output EOF message
	ASCIZ	~; EOF encountered~
TYPPA2:	JSP	A,CONMES	;[1024] Output the suffix
	ASCIZ	~]
~
	POPJ	P,		;[1024] Return
	SUBTTL	Command Decoder

STOP:	MONRT.			;SIMULATE ^C AT MACRO LEVEL
CD:RET:	HRRZS	EATCH		;FLAG NOT TO EAT AFTER : ANYTHING FAILS
	TXZE	FF,F.COLN	;F.COLN WHATEVER?
	JRST	FFOK		;RETURN -1, WHATEVER IT WAS IT WAS SUCCESSFUL
RETRET:	TXZ	FF,F.EBTP!F.KILL!F.ARG2!F.ARG!F.LARW!F.NSRH!F.SQIN!F.SRCH  ;[1004]
	TXZ	F2,S.SSEQ!S.DPPN!S.OLOG!S.SLOG!S.MINS!S.DOIT!S.INFO!S.DELS
	SKIPE	INI		;IF INI FILE IN PROGRESS, NO COMMAND SEEN
	TXO	F2,S.GOIN	;A COMMAND STRING IS IN
CD1:	SETZM	NUM		;NO ARGUMENT STRING SEEN
	SETZM	SYL
	TXZ	FF,F.NEG	;CLEAR MINUS SIGN FLAG
	MOVX	A,<MOVE B,>	;STANDARD ARG OPERATOR IS MOVE B,SYL
CD3:	HLLM	A,DLIM
CD5:	PUSHJ	P,RCH
CD9:	SKIPN	XCTING		;KEEP GOING?
	JRST	GO		;NO STOP
	MOVE	A,CH		;GET COMMAND CHARACTER
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"9"
	TRNA			;[331] No, go clear flags
	JRST	CD91		;[331] Yes, leave flags alone
	TXZ	FF,F.SYL	;[331] Clear digit string bit
	TXZ	F2,S.OCTL	;NO, CLEAR OCTAL RADIX FLAG
CD91:	CAIE	A,140		;[331] 140 IS ILLEGAL
	CAILE	A,172		;ALSO 173-177 ARE ILLEGAL
	MOVEI	A,0
	CAILE	A,137		;REDUCE LOWER CASE TO UPPER
	SUBI	A,40
	TXZ	F2,S.DOIT!S.INFO!S.MINS!S.EA!S.DPPN!S.YANK	;CLEAR INI FILE FLAGS
	TXZ	FF,F.INIT!F.FILE
	MOVE	A,DTB(A)	;[1040] Get XWD CODE,ADDR
	TXNN	A,DC.SUB!DC.NUM	;[1055] Is it a jrst dispatch with
				;[1055]  no argument processing?
	JRST	(A)		;YES, DO IT
	MOVE	B,NUM		;NO, TAKE CARE OF ARGUMENTS
	MOVE	C,DLIM		;GET DLIM
	TLNE	C,777K		;IF NO OPERATION DON'T DO IT!
	XCT	C		;NUM:=NUM (DLIM OPERATOR) SYL
	MOVEM	B,NUM
	SETZM	SYL		;CLEAR OLD OPERAND
	MOVSI	C,(MOVE B,)	;DON'T USE THE SAME OP TWICE!
	HLLM	C,DLIM		;SO RESET DLIM
	MOVE	C,SARG		;SAVE SECOND ARGUMENT IN C.
	TXZ	F2,S.CTLV+S.CTVV+S.CTLW+S.CTWW+S.EMAT+S.NCCT	;[344]
	MOVEM	P,PDLSAV
	TXNN	A,DC.SUB	;[1055] JRST or PUSHJ dispatch?
	JRST	(A)		;* JRST *
	PUSHJ	P,(A)		;* PUSHJ *
	JRST	RET
	SUBTTL	Numeric Input, VALRET & ALTmode Processor

;DIGITS FORM DECIMAL INTEGERS.

CDNUM:	TXON	FF,F.SYL	;DIGIT STRING ALREADY STARTED?
	SETZM	SYL		;NO, INIT TO ZERO
	MOVEI	A,12		;RADIX 10
	TXNN	F2,S.OCTL	;OCTAL FLAG ON?
	JRST	CDNUM1		;NO
	MOVEI	A,10		;YES, RADIX 8
	CAILE	CH,"7"		;FLAG 8 OR 9 IN OCTAL STRING
	ERROR	E.OCT
CDNUM1:	IMUL	A,SYL		;SCALE PREVIOUS VALUE
	ADDI	A,-60(CH)	;ADD IN NEW DIGIT

;SOME COMMANDS HAVE A NUMERIC VALUE
VALRET:	HRRZS	EATCH		;CLEAR THE EAT FLAG
	MOVEM	A,SYL
CD7:	TXO	FF,F.ARG
	JRST	CD5

ALTMOD:	SKIPN	COMCNT		;ANY COMMANDS LEFT?
	JRST	ALTM2		;NO
	MOVE	T,CPTR		;IF NEXT COMMAND CHARACTER IS ALT-MODE, GO
	ILDB	CH,T
	CAIE	CH,.CHESC
	JRST	CD
ALTM1:	TXNE	FF,F.TRAC	;TRACING?
	PUSHJ	P,CRR		;YES, TYPE CR/LF BEFORE *
	JRST	GO
ALTM2:	SKIPN	EQM		;WITHOUT A MACRO ?
	JRST	GO		;NO
	JRST	CD		;MACRO RETURN

; ^	Means that the next character is a control character.

UAR:	PUSHJ	P,SKRCH		;GET NEXT COMMAND CHARACTER.
	ERROR	E.MEU
	TRZ	CH,140		;CHANGE IT TO CONTROL CHARACTER
	JRST	CD9		;DISPATCH
	SUBTTL	Comma & Parentheses Processor

; ,	If a command takes two numeric arguments, comma is used
;	to separate them.

COMMA:	MOVEM	B,SARG		;SAVE CURRENT ARGUMENT IN SARG.
	TXZE	FF,F.ARG	;WAS THERE A CURRENT ARGUMENT?
	TXOE	FF,F.ARG2	;YES. WAS THERE ALREADY A SECOND ARGUMENT?
	ERROR	E.ARG
	JRST	CD1		;YES. CLEAR CURRENT ARGUMENT.

; ()	May be used to override left to right operator scan
;	for +, -, *, /, & and #.

OPENP:	PUSH	P,NUM		;PUSH CURRENT ARGUMENT.
	PUSH	P,DLIM		;CURRENT OPERATOR
	PUSH	P,[1]		;SET PAREN FLAG ON PDL
	JRST	CD1

CLOSEP:	POP	P,T		;LAST THING ON PDL A LEFT PAREN?
	JUMPL	T,CLOSE1	;SOMETHING LIKE (...<...)
	SOJN	T,CLOSE2	;MISSING (
	MOVEM	B,SYL		;YES. SAVE CURRENT ARGUMENT.
	POP	P,DLIM		;RESTORE OPERATOR
	POP	P,NUM		;RESTORE ARGUMENT.
	JRST	CD7

CLOSE1:	ERROR	E.PAR
CLOSE2:	ERROR	E.MLP

; ^O	Sets flag for octal radix input.

OCTIN:	TXO	F2,S.OCTL
	JRST	CD5		;RETURN WITHOUT MESSING UP ARGUMENTS


;IF 'HE' CAN HAVE ^F READ THE SWITCHES I CAN HAVE N^F RETURN
;THE TTY NUMBER OF JOB N + 200000 OCTAL OR ZERO IF NONE!!!!

WHERE:	TRMNO.	B,		;WHAT TTY HE ON
	JRST	BEGIN		;ZERO, NOT ONE ONE
	MOVE	A,B		;RETURN VALUE
	JRST	VALRET		;...
	SUBTTL	Mathematical & Logical Operators

; n&m	Preform a locical and.

CAND:	MOVSI	A,(AND B,)	;DLIM = AND B,SYL
	JRST	CD3


; n#m	Preform a logical or.

COR:	MOVSI	A,(OR B,)	;DLIM = OR B,SYL
	JRST	CD3


; n+m	Add takes one or two arguments.

PLUS:	MOVSI	A,(ADD B,)	;DLIM = ADD B,SYL
	JRST 	CD3


; n-m	Subtract takes one or two arguments.

MINUS:	MOVSI	A,(SUB B,)	;DLIM = SUB B,SYL
	TXO	FF,F.NEG	;SET FLAG FOR -L, -T, ETC...
	JRST	CD3


; n*m	Multiply takes two arguments.

TIMES:	MOVSI	A,(IMUL B,)	;DLIM = IMUL B,SYL
	JRST	CD3


; n/m	Divide (truncates) takes two arguments.

SLASH:	MOVSI	A,(IDIV B,)	;DLIM = IDIV B,SYL
	JRST	CD3
	SUBTTL	Flags - EOF, Form Feed & . H Z Positions

;RETURNS THE VALUE OF THE FORM FEED FLAG

FFEED:	TXNE	FF,F.FORM	;IS IT SET?
	JRST	FFOK		;YES, RETURN A -1
	JRST	BEGIN		;NO, DO BEGIN ROUTINE
;RETURNS THE NUMERIC VALUE 0.

ABEGIN:	SKIPL	EATCH		;TO MUNCH?
	JRST	BEGIN		;NO, PIG!
	MOVEI	B,.CHESC	;TECO'S ALTMODE
	HRRZS	CH,EATCH	;GET LAST CHARACTER INPUT FROM COMMAND
SAMECH:	CAMN	CH,B		;SAME?
	JRST	BEGIN		;RETURN FAILURE VALUE
READNT:	PUSHJ	P,SKRCH		;GET ANOTHER CHARACTER IF NOT
	ERROR	E.UCS
	JRST	SAMECH		;LOOP TIL U SEE IT
BEGIN:	MOVEI	A,0
	JRST	VALRET

; ^n	Returns value of EOF flag.

EOF:	TXNN	FF,F.EOFI	;EOF SEEN?
	JRST	BEGIN		;NO, RETURN 0
	JRST	FFOK		;YES, RETURN -1

;AN ABBREVIATION FOR B,Z

HOLE:	SETZM	SARG		;SET SECOND ARGUMENT TO 0.
	TXNE	FF,F.ARG2	;FLAG ANY ARGS BEFORE H
	ERROR	E.ARG
	TXOA	FF,F.ARG2

; .	Number of characters to the left of the pointer.

PNT:	SKIPA	A,PT

; Z	Number of characters in the buffer.

END1:	MOVE	A,Z
	SUB	A,BEG
	JRST	VALRET

;RETURN LENGTH OF LAST TEXT STRING PROCESSED

IFN VC,<
VCMD:	MOVE	A,VVAL		;LENGTH OF LAST TEXT
	JRST	VALRET
	>
	SUBTTL	= (Numeric Input) and ^T (Character Input) Commands

; n=	Causes the value of n to be typed out.

PRNT:	TXNN	FF,F.ARG	;INSIST ON ARG BEFORE =
	ERROR	E.NAE
	MOVE	A,CPTR		;SNEAK A LOOK AT NEXT COMMAND CHAR.
	ILDB	CH,A
	CAIE	CH,"="		;ANOTHER = SIGN?
	JRST	PRNT9		;NO
	TXO	F2,S.OCTL	;YES, THAT MEANS OCTAL RADIX TYPE-OUT
	PUSHJ	P,SKRCH		;SWALLOW THE EXTRA =
	TXZ	F2,S.OCTL	;AT END OF MACRO
PRNT9:	PUSHJ	P,PRNT9S	;PRINT NUMBER
	TXZN	FF,F.ARG2	;TWO ARGS?
	JRST	CRR		;CRLF AND RETURN TO CALLER
	JUMPL	C,CRR		;NEG ARG MEANS CRLF WANTED
	JUMPE	C,CPOPJ		;NOTHING IF ZERO
	MOVE	CH,C		;GET CHARACTER TO BE OUTPUT
	JRST	TYO		;ELSE TYPE CHAR AND RETURN

;TYPE C(B) IN OCTAL
OCTMS:	TXOA	F2,S.OCTL	;SET OCTAL RADIX
DECMS:	TXZ	F2,S.OCTL	;DECIMAL RADIX
PRNT9S:	MOVEI	A,TYO		;OUTPUT ON TTY
	PUSHJ	P,DPT		;TYPE NUMBER
;[323] S.OCTL IS NOW CLEARED IN DPT
;[323]	TXZ	F2,S.OCTL	;CLR RADIX FLAG
	POPJ	P,

;CAUSES COMMAND INTERPRETATION TO STOP UNTIL THE USER TYPES A CHARACTER
;ON THE TELETYPE AND THEN HAS THE ASCII VALUE OF THE CHARACTER TYPED IN.

SPTYI:	SETZM	XCTING		;SO NO WAIT FOR INPUT ON ^C REE
	TXZE	FF,F.COLN	;EXTENDED TTY OPERATIONS?
	JRST	EXTTTY		;YES
	TXNE	FF,F.ARG	;[1027] Skip if an argument wasn't given
	JRST	[MOVE   CH,B		;[1027] Get the ASCII character
		 PUSHJ  P,TYOM		;[1027] Type the character
		 SETOM  XCTING		;[1027] Set the run flag
		 TXNN   FF,F.TRAC	;[1027] Skip if in trace mode
		 OUTPUT TTY,		;[1027] Dump the TTY buffer
		 JRST   RET]		;[1027] Get something new to do
	TXO	FF,F.DDTM
	PUSHJ	P,TYI		;GET A SINGLE CHAR.
	SETOM	XCTING		;RESET FLAG, HAVE CHARACTER
	SKIPA	A,CH
	SUBTTL	^H (Time), ^F  and ^^ Commands

; ^H	Return the value of elapsed time, in 60ths of a second,
;	since midnight.

GTIME:	TIMER	A,
	JRST	VALRET


; ^F	Returns the value of the console data switches.

LAT:	TXZE	FF,F.ARG+F.ARG2	;EITHER OF THESE ON GO TO WHERE
	JRST	WHERE		;...
	SWITCH	A,
	JRST	VALRET


; ^^	Returns the value of the next character in the command
;	string.

CNTRUP:	PUSHJ	P,SKRCH		;^^ HAS VALUE OF CHAR FOLLOWING IT
	ERROR	E.MUU
	MOVE	A,CH
	JRST	VALRET
	SUBTTL	Extended ^T Operations

;TABLE FOR EXTENDED TTY OPERATIONS
;FORMAT FIRST WORD 1B<TTCALL #> ON = LEGAL TTCALL
;	SECOND WORD 1B<TTCALL #> ON = SHOULD SKIP (0 RETURNED IF NOT)
;	THIRD WORD 1B<TTCALL #> ON = RETURNS A VALUE ELSE NOTHING

TABLE1:	^B111011111111110000000000000000000000
TABLE2:	^B001001000001100000000000000000000000
TABLE3:	^B101011100000000000000000000000000000

EXTTTY:	MOVE	A,C		;I LIKE TO DO IT THIS WAY!!
	MOVN	E,B		;GET - TTCALL NUMBER
	SKIPLE	E		;WAS IT A NEGATIVE TTCALL?
	JRST	HACK		;YES
	MOVSI	CH,400K		;TO DETERMINE WHAT TO DO
	LSH	CH,(E)		;GET IT
	TDNN	CH,TABLE1	;LEGAL?
	ERROR	E.ITT
	CAIN	B,<RSCN==10>	;RESCAN FUDGE FUNCTIONS?
	JRST	REFUDG		;YES, DO THEM
	TXZ	FF,F.ARG2	;SO NO TWO ARGS RETURNS
	MOVE	E,[TTCALL 0,A]	;FOR XCT
	DPB	B,[POINT 4,E,12]	;MAKE A TTCALL N,
	XCT	E		;DO IT
	JRST	NOSKP		;SEE WHAT TO DO
	SETOM	XCTING		;RESET I AM DOING SOMETHING FLAG
	TDNN	CH,TABLE3	;DOES HE GET -1 OR C(A)
	SETO	A,		;-1
	JRST	VALRET		;MAKE IT AVAILABLR
NOSKP:	SETOM	XCTING		;FIX ACTIVE FLAG
	TDNE	CH,TABLE2	;SHOULD HAVE SKIPPED
	JRST	BEGIN		;RETURN ZERO
	TDNN	CH,TABLE3	;RETURN A VALUE?
	JRST	RET		;NO
	JRST	VALRET		;ELSE THROW THING IN A AT HIM


REFUDG:	SETOM	XCTING		;KEEP GOING!!!!
	MOVE	E,[RESCAN 1]	;ASSUME GOING TO RESCAN COMMAND LINE
	TXZE	FF,F.ARG2	;TWO ARGS = RETURN VALUE OF CCL FLAG
	MOVE	E,[SKIPE CCLSW]	;TEST CCL SWITCH
	XCT	E
	JRST	FFOK		;COMMAND THERE = -1
	JRST	BEGIN		;0, NOTHING THERE

HACK:	SETOM	XCTING
	CAILE	E,2		;LEGAL?
	ERROR	E.ITT
	SETSTS	TTY,@NOECHO-1(E)
	JRST	RET

NOECHO:	EXP	IO.SUP!IO.FCS!.IOASC
ECHO:	EXP	IO.FCS!.IOASC
	SUBTTL	\ (Backslash) Processor

; \	Returns the value of the number represented by the digits
;	(or minus sign) following the pointer in the buffer.  The
;	scan terminates on any other character.  The pointer is
;	moved over the number found (if any).

BAKSL:	MOVE	A,CPTR		;[323] GET THE COMMAND BYTE POINTER
	ILDB	CH,A		;[323] SNEAK A LOOK AT NEXT CHAR.
	CAIN	CH,"\"		;[323] IS IT ANOTHER BACKSLASH?
	PUSHJ	P,SKRCH		;[323] YES, TRY GETTING IT FOR REAL
	 TXZA	F2,S.OCTL	;[323] NOPE, CLEAR OCTAL FLAG
	TXO	F2,S.OCTL	;[323] SET OCTAL FLAG
	TXZE	FF,F.ARG	;WHICH KIND OF BACKSLASH?
	JRST	BAKSL1		;ARG TO MEMORY
	MOVEI	A,^D10		;[323] ASSUME DECIMAL RADIX
	TXZE	F2,S.OCTL	;[323] IS IT REALLY OCTAL?
	MOVEI	A,^D8		;[323] YES, SET IT
	MOVE	I,PT		;MEMORY TO VALRET
	CAML	I,Z		;CAN WE READ ANOTHER?
	JRST	BAKSL3		;NO
	PUSHJ	P,GETINC	;CK FOR +,- SIGN
	CAIN	CH,"+"
	JRST	BAKSLA		;IGNORE +
	CAIE	CH,"-"
	JRST	BAKSL0		;NO SIGN
	TXO	FF,F.ARG	;NEGATION FLAG
BAKSLA:	CAML	I,Z		;OVERDID IT ?
	JRST	BAKSL3		;YES. EXIT
	PUSHJ	P,GETINC	;NO. GET A CHAR
BAKSL0:	CAIGE	CH,"0"(A)	;[330] DIGIT?
	CAIGE	CH,"0"		;DIGIT?
	SOJA	I,BAKSL2	;NOT A DIGIT. BACKUP AND LEAVE LOOP
	SUBI	CH,"0"		;CONVERT TO NUMBER
	EXCH	CH,SYL
	IMULI	CH,(A)		;[323]
	ADDM	CH,SYL		;[323] SYL:= RADIX*SYL+CH
	JRST	BAKSLA		;LOOP

BAKSL3:	MOVE	I,Z		;HERE ON OVERFLOW
BAKSL2:	TXZE	FF,F.ARG	;MINUS SIGN SEEN?
	MOVNS	SYL		;YES. NEGATE
	MOVEM	I,PT		;MOVE POINTER PAST #
	JRST	CD7		;DONE
	SUBTTL	nA (ASCII Value) Command

; nA	(Where n is a numeric argument) = value in 7-bit ASCII
;	of the nth character to the right of the pointer.  0A
;	will return the character to the left of the pointer,
;	-nA will return the n+1st character to the left of the
;	pointer.  If .+n-1 is not within bounds, a 0 will be
;	returned, except in the case of m,nA, in which case m
;	is returned.


ACMD:	TXNE	FF,F.ARG	;[346] No argument implies Append
	TXNE	FF,F.COLN	;[346] Or is there a colon?
	JRST	APPEND		;Yes. THIS IN AN APPEND COMMAND.
	SETZ	CH,		;[346] Set up 0 for return value
	CHKEO	EODEC,ACMD2	;[346] If EO = 2, do old-style 1A
	TXZE	FF,F.ARG2	;[346] Was there a 2nd arg?
	MOVE	CH,C		;[346] Yes, use it instead
ACMD1:	SOS	I,B		;[346] Get arg-1
	ADD	I,PT		;[346] Add in point
	CAML	I,BEG		;[346] Check bounds
	CAML	I,Z		;BUFFER EMPTY OR PT=Z
	TRNA			;[346] Out of bounds
	PUSHJ	P,GET		;CH:=CHARACTER TO THE RIGHT OF PT.
	MOVE	A,CH		;RETURN CH AS VALUE.
	JRST	VALRET

ACMD2:	MOVEI	B,1		;[346] IF EO < 3, make arg=1
	JRST	ACMD1		;[346]
	SUBTTL	Q-Register Commands --  U & Q

; nUi	Puts the numeric value n in Q-register i.
;
; m,nUi	Puts n into Q-register i and returns m.

USE:	TXNN	FF,F.ARG	;INSIST ON ARG BEFORE U
	ERROR	E.NAU
	PUSHJ	P,CRANGE	;[332] Go check range of argument
USEA:	PUSHJ	P,QREGVI	;YES. CH:=Q-REGISTER INDEX.
USEA1:	MOVEM	B,QTAB-"0"(CH)	;STORE ARGUMENT IN SELECTED Q-REG.
	TXZN	FF,F.ARG2	;[332] IS THERE A SECOND ARG?
	JRST	RET		;[332] NO, RETURN
	MOVE	A,C		;[332] YES, RETURN IT
	JRST	VALRET		;[332]


; Qi	Returns the value of the latest quantity put into
;	Q-register i.
;
; :Qi	Returns the number of characters in Q-register i.

QREG:	PUSHJ	P,QTXTST	;GET Q-REGISTER INDEX & CHECK FOR TEXT
	 JRST	VALRET
	PUSHJ	P,QTEXEI	;GET Q REG ADR
	PUSHJ	P,GTQCNT	;# CHARS IN Q REG
	TXZE	FF,F.COLN	;[1026] Skip if colon wasn't supplied
	JRST	[MOVE A,C		;[1026] Return the number characters
		 JRST VALRET]		;[1026]  in the the Q-register
	MOVE	B,CPTR		;GET COMMAND POINTER
	ILDB	CH,B		;QA= (IE TYPE TEXT IN Q REG)?
	CAIE	CH,"="		;...
	..ERROR	E.NNQ
	PUSHJ	P,SKRCH		;EAT =
	..ERROR	E.NNQ
	MOVE	OU,I		;BEG OF Q REG
	MOVE	B,OU		;START CHARACTER
	ADD	B,C		;END
	MOVEI	D,TYO		;ROUTINE TO TYPE CHARS
	SETZM	XCTING		;SO ^C^C REE WORKS PROPERLY
	PUSHJ	P,TYPEQ		;TYPE CONTENTS OF Q-REG
	SETOM	XCTING		;DONE TYPING
	JRST	RET		;DONE

;ROUTINE TO RETURN Q-REGISTER INDEX IN CH AND CONTENT IN A.

QREGVI:	PUSHJ	P,SKRCH		;CH:=NEXT COMMAND STRING CHARACTER.
	ERROR	E.MIQ
QREGV2:	CAIE	CH,"*"		;EI REG?
	JRST	NOTEI
	MOVEI	CH,"Z"-<"A"-"9"-1>+1	;INDEX INTO QTAB
	POPJ	P,
NOTEI:	CAXE	CH,"@"		;[1037] Immediate command Q-register
	JRST	NOTAT		;[1037] See if a letter or number
	MOVX	CH,<"Z"-<"A"-"9"-1>+2>  ;[1037] Set up index into QTAB for "@"
	POPJ	P,		;[1037] Return
NOTAT:	CAIL	CH,"A"+" "-1	;[1037] Lower case letter?
	TXZ	CH,40		;MAKE UC
	CAIGE	CH,"0"		;DIGIT?
	ERROR	E.IQN		;BAD NAME
	CAIG	CH,"9"
	POPJ	P,		;YES
	CAIL	CH,"A"		;LETTER?
	CAILE	CH,"Z"
	ERROR	E.IQN		;BAD NAME
	SUBI	CH,"A"-"9"-1	;TRANSLATE LETTERS DOWN BY NUMBER OF
	POPJ	P,		;CHARACTERS BETWEEN 9 AND A. ONLY 36 Q-REG'S

;[332] Routine to check range of number to be stored in a Q-reg.

CRANGE:	TLNE	B,400000	;[1040] Does arg look like a text pointer?
	TLNE	B,377770	;[1040]  (I.E. less than -377770,,0?)
	POPJ	P,		;[332] OK, return
	ERROR	E.AOR		;[337] Out of range
	SUBTTL	Q-Register Commands -- %

; %q	Adds 1 to the quantity in Q-register q and stands for the
;	new value.
;
; n%q	Adds n to the quantity in Q-register q and stands for the
;	new value.

PCNT:	PUSHJ	P,QTXTST	;[1013] Get Q-reg and check for text
	JRST	PCNT1		;[1013] Go increment the Q-reg
	..ERROR	E.NNQ		;[1013] No numeric in Q-reg
PCNT1:	CHKEO	EODEC,PCNT2	;[1013] Jump if the old % is wanted
	PUSHJ	P,CHK2		;[1013] Get the default value
	ADDB	B,QTAB-"0"(CH)	;[1013] Add B to the Q-reg
	SKIPA	A,B		;[1013] Get the result
PCNT2:	AOS	A,QTAB-"0"(CH)	;[1013] Increment the Q-reg
	JRST	VALRET		;Return the result


;QTXTST - See if a Q-register contains text or a number
;Call:	MOVEI	CH,<the Q-register name>
;	PUSHJ	P,QTXTST
;	 * Non-skip return *	;The Q-register contains a number
;	* Skip return *		;The Q-register contains a text

QTXTST:	PUSHJ	P,QREGVI	;GET Q-REG INDEX
QTXTS1:	MOVE	A,QTAB-"0"(CH)	;[1037] Get Q-register contents
	TLNE	A,400000	;[1040] Does the Q-register
	TLNE	A,377770	;[1040]  contain text?
	POPJ	P,		;YES, NON-SKIP RETURN
	JRST	CPOPJ1		;ELSE CONTAINS TEXT
	SUBTTL	Q-Register Commands -- X

; m,nXi	Copies a portion of the buffer into Q-register i.  It
;	sets Q-register i to a duplicate of the (m+1)th	through
;	nth characters in the buffer.  The buffer is unchanged.
;
; nXi	Into Q-register i is copied the string of characters
;	starting immediately to the right of the pointer and
;	proceeding through the nth line feed.

X:
IFN VC,<SETZM	VVAL>		;CLR STRING LENGTH HOLD
	PUSHJ	P,GETARG	;C:=FIRST STRING ARGUMENT ADDRESS
				;B:=SECOND STRING ARGUMENT ADDRESS.
COPYEI:	PUSHJ	P,CHK1		;IS SECOND ARG. ADDR. > FIRST ARG. ADDR.?
	EXCH	B,C		;YES.
	SUB	C,B		;[321] C:=LENGTH OF STRING
	MOVE	A,C		;[321] A:=LENGTH OF STRING SAVED
	ADDI	C,3		;[321] C:=LENGTH OF STRING+3.
IFN VC,<MOVEM	A,VVAL>
	ADD	B,C		;B:=FIRST ARG ADDR + LENGTH OF STRING + 3
	PUSHJ	P,X3		;MOVE DATA TO Q-REG BUFR
	TXNN	FF,F.INIT	;INI FILE THING?
	JRST	X0		;[332] NO, MAKE QTAB ENTRY NORMALLY.
	MOVEM	B,QTAB-"0"+<STAR==124>	;INTO * Q-REG
	POPJ	P,		;AND RETURN
X0:	PUSHJ	P,QREGVI	;[332] CH:=Q-Register index
	MOVEM	B,QTAB-"0"(CH)	;[332] Store argument in selected Q-reg
	JRST	RET		;[332] Return

;TRANSFER DATA TO Q-REGISTER BUFR

X3:	PUSH	P,PT
	ADDM	C,(P)		;(P):=PT + LENGTH OF STRING + 3.
	MOVE	D,BEG
	MOVEM	D,PT		;PT:=BEG
	PUSHJ	P,NROOM		;INSERT STRING AT BEG
	MOVE	OU,RREL		;RREL CONTAINS RELOCATION CONSTANT IF
				;GARBAGE COL. OCCURRED.
	ADDM	OU,(P)		;RELOCATE TOP OF STRING POINTER.
	CAML	B,BEG		;[320] IF WE ARE DOING A *I, DON'T CHANGE B!!
	ADD	B,OU		;B:=FIRST ARG ADDR + LENGTH OF STRING + 3 + RREL
	MOVE	OU,BEG		;OU:=ADDRESS OF Q-REG BUFFER
	ADDM	C,BEG		;BEG:=C(BEG)+LENGTH OF STRING + 3
	MOVE	CH,C		;FIRST CHAR OF BUFFER :=LEAST SIGNIFICANT 7 BITS
	PUSHJ	P,PUT		;OF LENGTH OF STRING + 3
	AOS	OU		;SECOND CHAR = MIDDLE 7 BITS OF LENGTH
	ROT	CH,-7
	PUSHJ	P,PUT
	ROT	CH,-7
	MOVE	I,B		;THIRD CHAR OF BUFFER := MOST SIGNIFICANT 7 BITS
				;OF LENGTH OF STRING + 3
	AOS	OU
X1:	PUSHJ	P,PUT		;MOVE STRING TO Q-REG BUFFER.
	AOS	OU
	CAIN	C,3
	JRST	X2
	PUSHJ	P,GETINC
	SOJA	C,X1
X2:	MOVE	B,PT		;QTAB ENTRY :=XWD 400000,Q-REG BUFFER
				;ADDRESS RELATIVE TO C(QRBUF)
	SUB	B,QRBUF
	TLO	B,400000
	POP	P,PT		;MOVE PT PAST STRING.
	POPJ	P,
	SUBTTL	Q-Register Commands -- G

; Gi	The text in Q-register i is inserted into the buffer
;	at the current location of the pointer.  The pointer
;	is then put just to the right of the insertion.  The
;	Q-register is not changed.

QGET:
IFN VC,<SETZM	VVAL>		;CLR STRING LENGTH HOLD
	PUSHJ	P,QTEXT		;INIT Q-REG ACCESS
	MOVE	B,CH		;SAVE INDEX
	PUSHJ	P,GTQCNT	;C:=LENGTH OF STRING
	PUSHJ	P,NROOMC	;MOVE FROM PT THROUGH Z UP C POSITIONS
	MOVE	OU,PT
	MOVE	I,QTAB-"0"(B)	;[1040] Get the Q-register
	TLZ	I,400000	;[1040]  offset address
	ADD	I,QRBUF
	ADDI	I,3
QGET1:	JUMPE	C,RET		;MOVE STRING INTO DATA BUFFER
	PUSHJ	P,GETINC
	PUSHJ	P,PUT
	AOS	OU,PT
	SOJA	C,QGET1

;GET 21 BIT Q-REGISTER CHARACTER COUNT

GTQCNT:	PUSHJ	P,GETINC	;LOW ORDER 7 BITS
	MOVEM	CH,C
	PUSHJ	P,GETINC	;MIDDLE 7 BITS
	ROT	CH,7
	IORM	CH,C
	PUSHJ	P,GETINC	;HIGH 7 BITS
	ROT	CH,^D14
	IORM	CH,C
	SUBI	C,3		;LESS 3 WORDS USED TO STORE THIS COUNT
	POPJ	P,

;INITIALIZE ACCESS OF TEXT FROM A Q-REGISTER

QTEXT:	PUSHJ	P,QREGVI	;A=QTAB ENTRY, CH=Q-REG INDEX
QTEXEI:	MOVE	A,QTAB-"0"(CH)
	TLZE	A,400000	;[1040] Does the Q-register
	TLZE	A,377770	;[1040]  contain text?
	..ERROR	E.NTQ		;NO TEXT
	ADD	A,QRBUF
	MOVE	I,A		;I=Q-REG BUFFER ADDRESS
	POPJ	P,
	SUBTTL	Q-Register Commands -- M, W, [ & ]

; Mi	Perform now the text in Q-register i as a series of
;	commands.

MJRST:	SKIPE	EQM		;W @ CMD LEVEL = M
	JRST	QACCES		;ELSE OK

MAC:	PUSHJ	P,QTEXT		;INIT Q-REG ACCESS
MAC1:	PUSH	P,COMAX		;SAVE CURRENT COMMAND STATE
	PUSH	P,CPTR
	PUSH	P,COMCNT
	PUSH	P,.		;FLAG MACRO ON PDL (LARGE POS. NO.)
	AOSA	EQM		;INCREMENT THE MACRO LEVEL
QACCES:	PUSHJ	P,QTEXT		;INIT Q REG ACCESS FOR W COMMAND
	PUSHJ	P,GTQCNT	;GET NUMBER OF CHARACTERS IN MACRO
	MOVEM	C,COMCNT	;THAT MANY COMMANDS TO COUNT
	MOVEM	C,COMAX		;AND MAX.
	SUBI	I,1		;ADJUST TO SUIT BTAB
	IDIVI	I,5
	MOVE	OU,BTAB(OU)	;MAKE A BYTE POINTER
	HRR	OU,I
	MOVEM	OU,CPTR		;PUT IT IN CPTR
	JRST	CD5		;DON'T FLUSH ANY ARGUMENTS


; ]i	Pops Q-register i off the Q-register pushdown list.
;	THE Q-REGISTER PUSHDOWN LIST IS CLEARED EACH TIME $$ IS TYPED.

CLOSEB:	HLRZ	C,PF		;GET PDL COUNT
	MOVEI	B,"]"		;POP
	CAIG	C,-LPF-1	;UNDERFLOW?
	ERROR	E.PDQ
	PUSHJ	P,QREGVI	;[332] GET Q-REG INDEX
	POP	PF,QTAB-"0"(CH)	;[332] POP THE Q-REG
	JRST	RET		;[332] RETURN


; [i	Pushes Q-register i onto the Q-register pushdown list.
;
; n[i	Equivalent to [i followed by nUi.
;
; m,n[I	Equivalent to [i followed by m,nUi.

OPENB:	TXNE	FF,F.ARG	;[332] Is there an argument?
	PUSHJ	P,CRANGE	;[332] Yes, go check the range
	PUSHJ	P,QREGVI
	PUSH	PF,QTAB-"0"(CH)	;[332] PUSH Q-REG
	TXNN	FF,F.ARG	;[332] WAS THERE AN ARG?
	JRST	RET		;[332] NO, RETURN
	JRST	USEA1		;[332] YES, GO STORE IT
	SUBTTL	Miscellaneous Character Dispatcher

;CALL:	MOVE	CH,CHARACTER
;	MOVEI	T,TABLE ADDR
;	PUSHJ	P,DISPAT
;	NOT FOUND RETURN
;ENTER AT DISP1 TO AVOID CONVERTING LC TO UC

DISPAT:	CAIG	CH,"Z"+" "	;CONVERT LC TO UC
	CAIG	CH,137
	JRST	DISP1
	TXZ	CH,40
DISP1:	PUSH	P,A		;SAVE AC A WHILE WE USE IT
DISP2:	MOVE	A,(T)		;GET TABLE ENTRY
	JUMPE	A,APOPJ		;END OF TABLE
	CAIE	CH,(A)		;SAME
	AOJA	T,DISP2		;NOT A MATCH
	HLRZM	A,-1(P)		;GOT IT -- PUT DISPATCH ADDR ON PDL
	JRST	APOPJ		;RESTORE AC A & DISPATCH


; n^U	Select block n for the next block of input.  Only
;	legal if NOT EB and ER is true.

IUSET:	JUMPLE	B,USTERR	;ARG LESS THAN OR = ZERO LOSES
	TXNN	FF,F.UBAK	;MUST NOT BE EB IN FORCE
	TXNN	FF,F.IOPN	;BUT MUST HAVE INPUT FILE OPEN
USTERR:	ERROR	E.UST
	TXZ	FF,F.EOFI	;[1005] Clear the E-O-F flag
	USETI	INCHN,(B)	;DO THE USETI
	MOVX	T,BF.IOU	;MUST CLEAR ALL THE USE BITS
	HRRZ	A,IBUF		;STARTING HERE
	HRRZ	B,A		;ENDING HERE TOO
USTILP:	ANDCAM	T,(A)		;CLEAR THE BIT
	HRRZ	A,(A)		;NEXT BUFFER
	CAME	A,B		;DONE?
	JRST	USTILP		;LOOP FOR ALL BUFFERS
	SETZM	IBUF+.BFCNT	;FORCE A READ (IN)
	STATO	INCHN,IO.ERR!IO.EOF	;ANY PROBLEM ARISE?
	POPJ	P,		;NO, RETURN TO HIM
	USETI	INCHN,1		;BACK TO START OF FILE
	ERROR	E.UST
	SUBTTL	^G (GETTAB or Exit) Command

;ROUTINE TO EXIT IF EO = 1 (OLD ^G) OR DO GETTAB

BELDMP:	CHKEO	EO21,DECDMP	;OLD EXIT
	TXNE	FF,F.ARG	;IF NO ARG THEN RETURN JOB NUMBER
	JRST	BELDP0		;THERE IS AN ARG...
	PJOB	A,		;JOB NUMBER
	JRST	VALRET		;RETURN IT
BELDP0:	MOVE	A,B		;GET ADR OR TABLE NO.
	TXZN	FF,F.ARG2	;TWO ARGS?
	JRST	BELPEK		;NOPE, DO A PEEK
	HRL	A,C		;FORM GETTAB WORD
	GETTAB	A,		;DO THE GETTAB
	  SETZ	A,		;RETURN ZERO ON ERROR
	JRST	VALRET		;ELSE RETURN WHATEVER
BELPEK:	PEEK	A,		;WILL IT WORK?
	JRST	VALRET		;WE'LL NEVER KNOW...
	SUBTTL	E Commands -- Dispatch Routine & Table

ECMD:	PUSHJ	P,SKRCH		;GET CHAR AFTER E
	ERROR	E.MEE
	CAIG	CH,"Z"+" "	;LOWER CASE GOES TO UPPER
	CAIGE	CH,"A"+" "	;...
	  CAIA
	SUBI	CH," "		;TO UPPER CASE
	HRREI	TT,-"A"(CH)	;CONVERT TO TABLE OFFSET
	SKIPL	TT		;NEG IS ERROR
	CAILE	TT,"Z"-"A"	;IS BOUNDS
E$$IEC:	ERROR	E.IEC
	LSHC	TT,-1		;CALCULATE TABLE WORD & HALF
	MOVE	TT,ECTABL(TT)	;GET ADRS OF PROCESSORS
	SKIPL	TT1		;HAVE IT
	MOVSS	TT		;NO, NEED OTHER HALF
	JRST	(TT)		;GO

;E-COMMAND DISPATCH TABLE

ECTABL:	XWD	OPNWRA,EBAKUP	;EA,EB
	XWD	ECORE,RUNFX	;EC,ED
	XWD	EECMD,CLOSEF	;EE,EF
IFN CCL,<XWD	CCLFIN,ERRSET	;EG,EH> XWD	E$$IEC,ERRSET
	XWD	EICMD,E$$IEC	;EI,<EJ>
	XWD	EKILL,MAKLOG	;EK,EL
	XWD	EMTAPE,RENAM	;EM,EN
	XWD	OLDMOD,EPCMD	;EO,EP
	XWD	EDTQIT,OPNRD	;[1007] EQ,ER
	XWD	AUTOTY,TYOCTL	;ES,ET
	XWD	TYCASE,VIDEO	;EU,EV
	XWD	OPNWR,FINISH	;EW,EX
	XWD	YANK,ZERDIR	;EY,EZ
	SUBTTL	E Commands -- EL (Setup and Output Routines)

LOGOUT:	TXZN	F2,S.ASTR
	TXNE	F2,S.SLOG	;SKIP LOG FILE?
	POPJ	P,		;RIGHT
	SOSG	OLOG+.BFCNT	;DECREMENT BUFFER COUNTER
	OUTPUT	LOGCHN,		;DUMP BUFFER IF NO ROOM
	IDPB	CH,OLOG+.BFPTR	;PUT CHARACTER
	TXNE	F2,S.OLOG	;MISUSING TYOM?
	POP	P,CH		;YES, FORCE NICE RETURN
	POPJ	P,		;AND RETURN

MAKLOG:	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	CHANGL		;YES, CHANGE OUTPUT SPECIFICATION
	TXNE	F2,S.LOPN	;DO WE HAVE AN OPEN LOG FILE?
	RENAME	LOGCHN,LOGFL	;FINAL RENAME FOR PROTECTION
	  JFCL			;"IMPOSSIBLE ERROR"
	SETZM	LOGOPN+.OPMOD	;ASCII MODE FOR LOG FILE
	TXZ	F2,S.LIN!S.LOUT!S.LOPN!S.OLOG
	PUSHJ	P,DSPEC		;GET FILE SPEC AND DEFAULT
	MOVSI	E,OLOG		;BUFFER HEADER
	MOVEM	E,LOGOPN+.OPBUF	;SAVE
	MOVEI	B,"L"		;TO MAKE CORRECT ERROR MESSAGE TYPE
	OPEN	LOGCHN,LOGOPN	;OPEN DEVICE
	..ERROR	E.ODV
IFE FT$TYM,<IF2,<PRINTX [DEVTYP uuo not implemented in MAKLOG routine]>
	MOVEI	E,LOGCHN	;MUST BE A DSK!!
	DEVTYP	E,		;WELL?
	JRST	ERRILD
	TXNE	E,77		;DSK?
	JRST	ERRILD
>  ;End of IFE FT$TYM
	SKIPN	A,XFILNM+.RBEXT	;SPECIFY AN EXT?
	MOVSI	A,'LOG'		;THIS IS DEFAULT
	MOVEM	A,XFILNM+.RBEXT	;SAVE IT
	MOVE	B,SWITC		;GET SWITCHES
	TLNN	B,FS.APP	;TO SUPERSEDE OLD FILE?
	JRST	ENTLOG		;YES
	MOVEI	E,LOGCHN	;SET UP FOR CHKDEF
	LOOKUP	LOGCHN,XFILNM	;SEE FILE
	SKIPA			;NOT THERE
	PUSHJ	P,CHKPTH	;SEE IF FOUND ON SPECIFIED DIRECTORY
ENTLOG:	SETZM	LOGOPN+1	;NOPE
ENT02:	SKIPN	LOGOPN+1	;TO APPEND?
	CLOSE	LOGCHN,		;NO, CLOSE FILE
	PUSHJ	P,PPNSPC	;SET UP PPN IN CASE WIPED
	ENTER	LOGCHN,XFILNM	;ENTER LOG FILE
	EE1+..ERROR E.ENT	;ENTER ERROR ON LOG FILE
	MOVEI	E,LOGFL		;SAVE FILESPEC
	PUSHJ	P,SPCSAV
	SKIPE	LOGOPN+1	;TO USETO?
	USETI	LOGCHN,-1	;DO IT
	MOVEI	E,LOGSPC
	EXCH	E,.JBFF
	OUTBUF	LOGCHN,1
	MOVEM	E,.JBFF		;RESTORE .JBFF FOR LATER
	TXO	F2,S.LIN!S.LOUT!S.LOPN	;ASSUME ALL INTO LOG FILE
	TLNE	B,FS.NOO
	TXZ	F2,S.LOUT
	TLNE	B,FS.NOI
	TXZ	F2,S.LIN
	POPJ	P,		;AND RETURN

DSPEC:	PUSHJ	P,FILSPC	;GET FILE SPEC
DSPEC1:	SKIPN	E,XFILNM+.RBNAM	;SPECIFY A NAME?
	MOVE	E,['TECO  ']
	MOVEM	E,XFILNM+.RBNAM
	SKIPN	E,FILDEV	;HE SPECIFY A DEVICE
	MOVSI	E,'DSK'		;ASSUME DSK
	MOVEM	E,LOGOPN+1	;SAVE IN OPEN BLOCK
	MOVEM	E,FILDEV	;FIX IN CASE ERROR
	MOVEM	E,SPCDEV
	POPJ	P,

ERRILD:	RELEAS	LOGCHN,
	..ERROR	E.ILD
	SUBTTL	E Commands -- EE (Save TECO's State)

EECMD:	MOVEM	17,SAVEAC+17	;PRESERVE 17
	MOVEI	17,SAVEAC	;TO SAVE ALL AC'S
	BLT	17,SAVEAC+16	;SAVE THEM
	MOVE	17,SAVEAC+17	;RESTORE AC 17
	MOVX	E,S.LIN!S.LOUT!S.OLOG!S.LOPN	;CLEAR LOG FILE I-O FLAGS
	ANDCAM	E,SAVEAC+F2	;RESAVE FLAG
	MOVX	E,F.OOPN!F.IOPN!F.UBAK	;NO FILES OPEN
	ANDCAM	E,SAVEAC+FF	;SAVE IN LOW SEG
	PUSHJ	P,DSPEC		;DEFAULT
	SKIPN	E,XFILNM+.RBEXT	;SPECIFY AN EXT?
	MOVSI	E,'SAV'		;DEFAULT
	MOVEM	E,XFILNM+.RBEXT	;SAVE IT
	MOVSI	E,OSAV		;FOR OUTPUT
	MOVEM	E,LOGOPN+.OPBUF	;SAVE IT
	MOVE	E,LOGOPN+.OPDEV	;GET DEVICE WE WILL OPEN
	DEVCHR	E,		;WHAT IS IT
	JUMPE	E,ERRNXD	;DOESN'T EXIST
	TXNE	E,DV.OUT	;OUTPUT DEVICE MUST BE CAPABLE OF OUTPUT
	TXNN	E,DV.M13	;IN IMAGE BINARY
	..ERROR	E.ILD
	MOVEI	E,.IOIBN	;IB FOR SAVE FILE
	MOVEM	E,LOGOPN+.OPMOD	;SAVE IT
	OPEN	SAVCHN,LOGOPN	;OPEN IT
	..ERROR	E.ODV
	MOVE	E,[GETBLK,,STARTL]
	BLT	E,STARTL+12	;MAKE LITTLE PROGRAM IN LOW SEG
	ENTER	SAVCHN,XFILNM	;ENTER THE OUTPUT FILE
	EE1+..ERROR E.ENT	;ERROR
	MOVEI	E,EEFL		;SAVE FILE SPEC
	PUSHJ	P,SPCSAV
	PUSH	P,.JBSA		;SAVE FOR LATER RESTORE
	PUSH	P,.JBCOR	;...
	MOVEI	E,STARTL+6	;WHERE TO START
	HRRM	E,.JBSA		;FIX JOBSA
	MOVE	E,.JBFF		;GET .JBFF NOW
	HRLM	E,.JBSA
	HRLM	E,.JBCOR	;SO SUBSEQUENT SAV-GET PAIRS WORK
	HRRZ	A,.JBREL	;THIS IS OUR SIZE
	HRRM	A,.JBCOR	;FIX ILL MEM REF PROB FOR EE
	OUTBUF	SAVCHN,1	;1 OUTPUT BUFFER
	MOVEM	E,.JBFF		;SO WE NOT SAVE IT
	MOVEI	A,.JBPFI+1	;START SAVE AT 115
SAVTOP:	SKIPN	(A)		;ZERO?
	JSP	E,MORE		;MORE TO GO?
	CAML	A,.JBFF		;STOP?
	JRST	SAVSTP		;RIGHT!
	MOVE	B,A		;SAVE FIRST NON ZERO WORD
	SKIPE	(A)		;ZERO?
	JSP	E,MORE		;NO, SEE IF MORE
	SUBM	B,A		;NEG NO OF WORDS
	MOVSS	A		;FORM IOWD
	HRRI	A,-1(B)		;FORMED
	PUSHJ	P,SAVOUT	;SEND TO FILE
	MOVE	E,A		;GET IOWD
	MOVE	A,1(E)		;GET WORD
	PUSHJ	P,SAVOUT	;SEND TO FILE
	AOBJN	E,.-2		;LOOP FOR THIS GROUP
	HRRZI	A,1(E)		;NEXT WORD
	CAMGE	A,.JBFF		;DONE?
	JRST	SAVTOP		;NO, LOOP
SAVSTP:	MOVE	A,[JRST	STARTL+6]	;SO CORRECT THING HAPPENS
	PUSHJ	P,SAVOUT	;OUTPUT IT
	RENAME	SAVCHN,EEFL	;FINAL RENAME FOR PROTECTION
	  JFCL			;"IMPOSSIBLE ERROR"
	RELEAS	SAVCHN,		;CLOSE AND RELEASE CHANNEL FOR SAVE FILE
	POP	P,.JBCOR
	POP	P,.JBSA
	POPJ	P,		;DONE

SAVOUT:	SOSGE	OSAV+.BFCNT	;ROOM THIS BUFFER
	JRST	OUTSAV		;NO, DUMP AND COME BACK
	IDPB	A,OSAV+.BFPTR	;STICK WORD
	POPJ	P,		;RETURN
OUTSAV:	OUT	SAVCHN,		;DUMP BUFFER
	JRST	SAVOUT		;GO BACK
	GETSTS	SAVCHN,B	;ERROR STATUS
	POP	P,.JBCOR
	POP	P,.JBSA
	EE2+..ERROR E.OUT

MORE:	CAML	A,.JBFF		;MORE?
	JRST	(E)		;NO
	AOJA	A,-2(E)		;NO RETURN .-2
	SUBTTL	E Commands -- NEL & EE (Low Core)

GETBLK:	('SYS')
	'TECO  '
REPEAT	4,<0>
	MOVEI	E,STARTL
	GETSEG	E,
	HALT
	MOVEI	E,%TECOV	;TO MAKE SURE HI AND LOW SEG AGREE
	JRST	.HISEG+10	;[1040] Go to the restore code

;ROUTINE TO CHANGE LOG FILE OUTPUT PARAMETERS

CHANGL:	PUSHJ	P,SKRCH		;GET ANOTHER CHARACTER
	 ..ERROR E.NAL
	CAIE	CH,.CHESC	;MUST HAVE ALTMODE AFTER NEL
	..ERROR	E.NAL
	TXNN	F2,S.LOPN	;HAVE A LOG FILE OPEN?
	..ERROR	E.NLF
	TXZ	F2,S.LIN!S.LOUT	;ELSE CLEAR ALL
	TRNE	B,1		;OUTPUT?
	TXO	F2,S.LOUT	;YES
	TRNE	B,2		;INPUT?
	TXO	F2,S.LIN	;YES
	JUMPGE	B,CPOPJ		;UNLESS B WAS NEGATIVE,
	RENAME	LOGCHN,LOGFL	;RENAME FOR PROTECTION
 	  JFCL			;CANT HAPPEN
	RELEAS	LOGCHN,		;IN WHICH CASE JUST CLOSE THE FILE
	TXZ	F2,S.LIN!S.LOUT!S.LOPN!S.OLOG	;AND ZERO THE FLAGS
	POPJ	P,		;OK, NOW DO THAT
	SUBTTL	E Commands -- EE (Restart Code)

RST:	CAIN	E,%TECOV	;WILL THIS WORK
	JRST	RST1		;YES
	OUTSTR	[ASCIZ	.?TECWVT Wrong version of TECO GETSEG'd
.]
	EXIT
RST1:	MOVEI	E,REE		;RESET REN ADR
	MOVEM	E,.JBREN	;SAVE
	MOVE	E,[PUSHJ P,UUOH]	;FIX .JB41
	MOVEM	E,.JB41		;...
	MOVSI	17,SAVEAC	;TO RESTORE AC'S
	BLT	17,17		;DO IT
	PUSHJ	P,TTOPEN	;REOPEN TTY
	PUSHJ	P,SETUP		;RESET ALL DEFAULTS
	POP	P,E		;THROW OUT WHERE YOU CAME FROM
	MOVEI	A,TECO		;START ADR
	HRRM	A,.JBSA		;SAVE IT
	JRST	RET		;CONTINUE


;EDIT CORE (IE GARBAGE COLLECT AND SMALLIFY)

ECORE:	MOVEM	PF,AC2+PF-2	;[354] PUT PF WHERE GC EXPECTS IT
ECORE1:	MOVEI	E,CORER		;[354] WHERE GC WILL RETURN
	MOVEM	E,GCRET
	SETOM	GCFLG		;GARBAGE COLLECT!
	MOVEM	F2,SAVEAC	;PRESERVE FLAGS
	PUSH	P,.JBREL	;SAVE SIZE NOW IN CASE NO CHANGE
	JRST	GC		;DO IT
CORER:	HRRZ	A,.JBCOR	;DON'T GET SMALLER THAN THIS
	MOVE	F2,SAVEAC	;RESTORE FLAGS
	MOVE	B,Z		;CHARACTER ADR OF LAST CHARACTER
	IDIVI	B,5		;WORD ADR
	AOJ	B,		;YES
	CAMGE	B,A		;WELL?
	MOVE	B,A		;ELSE FORCE MIN TO (A)
	CORE	B,		;DO IT
	JFCL
	MOVE	A,.JBREL
	MOVEM	A,.JBFF
	PUSHJ	P,CRE23		;RECOMPUTE SIZE OF TEXT BUFFER
	POP	P,A		;GET OLD .JBREL BACK
	CAMN	A,.JBREL	;DIFFERENT?
	POPJ	P,		;NO, NO MESSAGE
	TXO	FF,F.INIT	;FAKE OUT CORE ROUTINE
	JRST	CORES		;SAY SIZE AND CONTINUE
	SUBTTL	E Commands -- EI & EP (Edit Insert & Edit Put)

EICMD:	TXOA	F2,S.DOIT	;NOTE TO DO MI WHEN DONE READING
EPCMD:	TXZ	F2,S.DOIT	;JUST READ IT INTO THE Q REG *
	PUSHJ	P,FILSPC	;GET FILE SPEC
	MOVEI	A,24		;EI DEFAULT
	PUSHJ	P,EIDFSP	;SET THEM UP
	SKIPN	E,XFILNM+.RBEXT	;SPECIFY EXT?
	MOVSI	E,'TEC'		;'TEC' IS DEFAULT FOR EI-EP
	TXOA	F2,S.INFO	;TELL USER OF ANY CORE CHANGE WHEN THRU
INIFIL:	TXZ	F2,S.INFO	;NEVER DO THIS!
	MOVEM	E,XFILNM+.RBEXT	;SAVE IT

;***[337]***
;Here to LOOKUP file for EI and EP.
;If no directory or device has been specified, then look for the
;file as follows:
;	[-]
;	[,,TEC]/SCAN
;	TED:

EPIGET:	SETZM	EPISEQ		;Clear search sequencer
	SKIPN	FILPPN		;Directory specified?
	SKIPE	FILDEV		;Or device?
	SETOM	EPISEQ		;Yes, flag that no search sequence needed
	PUSHJ	P,DSPEC1	;DEFAULT DEVICE ETC
	SKIPGE	EPISEQ		;Do we need a search sequence?
	JRST	EPIG6		;No, go read file
	TXNE	F2,S.INFO	;Are we processing TECO.INI?
	JRST	EPIG1		;No, skip ahead
IFN F%T20,<
	MOVX	E,'HOME  '	;[1054] Use default
	MOVEM	E,LOGOPN+.OPDEV	;[1054]  device of
	OPEN	INICHN,LOGOPN	;[1054]  HOME:
	 JRST	EPIG0		;[1054] No such device
	RELEAS	INICHN,		;[1054] That's all for now
	SETZM	E,XFILNM+.RBPPN	;[1054] Don't specify a directory
	JRST	EPIG6		;[1054] Go try and find it
EPIG0:	MOVX	E,'PS    '	;[1045] Use default
	MOVEM	E,LOGOPN+.OPDEV	;[1045]  device of PS >
	MOVE	E,USRPPN	;Yes, always use [,]
	MOVEM	E,XFILNM+.RBPPN	;Store it
	JRST	EPIG6		;Go find the file
EPIG1:	MOVEI	E,5		;Initialize search sequencer
	MOVEM	E,EPISEQ	;Store
EPIG2:	SOSG	E,EPISEQ	;Get next step in search sequence
	JRST	LOOKIN		;Finished.  File was not found
	SETZM	FILDEV		;Clear device for possible error msg.
	CAIE	E,4		;First step?
	JRST	EPIG3		;No
	MOVSI	E,'DSK'		;Use DSK device
	MOVEM	E,LOGOPN+1	;Store
	SETZM	XFILNM+.RBPPN	;Set default directory
	JRST	EPIG6		;Go straight to find it

EPIG3:	CAIE	E,3		;Second step?
	JRST	EPIG3A		;No
	MOVEI	E,FILPTH	;Set PATH pointer
	MOVEM	E,XFILNM+.RBPPN	;in LOOKUP block
	MOVSI	E,'TEC'		;Set [,,TEC]
	MOVEM	E,FILSFD	;Store
	SETZM	FILSFD+1	;Set trailing 0
	MOVE	E,USRPPN	;Get logged-in PPN
	MOVEM	E,FILPPN	;Store it
	CAMN	E,DEFPTH+2	;Same as default path PPN?
	SKIPE	DEFPTH+3	;And no SFD's?
	TRNA			;No, then search [,] also
	JRST	EPIG7		;Yes, don't bother setting /SCAN
EPIG4:	MOVEI	E,2		;Set /SCAN
	MOVEM	E,FILPTH+1	;Store
	JRST	EPIG7		;Go try
EPIG3A:	CAIE	E,2		;Third step?
	JRST	EPIG5		;No
	MOVE	E,USRPPN	;Get logged-in PPN
	MOVEM	E,XFILNM+.RBPPN	;Store
	CAMN	E,DEFPTH+2	;Same as default path?
	SKIPE	DEFPTH+3
	JRST	EPIG7		;No, go try
	JRST	EPIG2		;Yes, try next search

EPIG5:				;Must be fourth step
	MOVSI	E,'TED'		;Use TED:
	MOVEM	E,LOGOPN+1	;Store
	SETZM	E,XFILNM+1	;Clear directory spec
	SETZM	FILPPN		;Clear this too for possible error msg.

EPIG6:	TXO	FF,F.INIT	;INIT FILE READ IN PROGRESS
	SETZM	LOGOPN+.OPMOD	;ASCII MODE
	MOVEI	E,IINI		;INPUT BUFFER HEADER
	MOVEM	E,LOGOPN+.OPBUF	;SAVE IT
	MOVE	E,LOGOPN+.OPDEV	;DEVICE
	DEVCHR	E,		;CHARACTERISTICS=?
	JUMPE	E,ERRNXD	;NO SUCH DEVICE
	TXNE	E,DV.IN		;INPUT DEVICE SHOULD BE CAPABLE OF INPUT
	TXNN	E,DV.M0		;IN ASCII MODE
	..ERROR	E.ILD
	OPEN	INICHN,LOGOPN	;OPEN DEVICE
	..ERROR	E.IDV
EPIG7:	LOOKUP	INICHN,XFILNM	;LOOK FOR FILE
	JRST	EPIG2		;Failed, go step the sequencer

				;Found it...Fall through to next page
	PUSH	P,.JBREL	;SAVE FOR LATER
	PUSH	P,.JBFF		;[336] Save this too
	MOVE	E,Z		;END OF TEXT BUFFER
	SUB	E,BEG		;#CHARS IN IT
	MOVEM	E,SAVEAC	;REMEMBER IT FOR LATER CLEAN UP
	MOVE	TT,Z		;WHERE TO PUT BUFFER
	IDIVI	TT,5		;IN WORD ADR
	ADDI	TT,2		;ASSUME LEFT OVER + 1
	MOVEM	TT,.JBFF	;FIX IT
	INBUF	INICHN,1	;1 INPUT BUFFER
	MOVE	OU,.JBFF	;WHERE WE WILL PUT THIS
	IMULI	OU,5		;ADR AS A NUMBER OF CHARACTERS
	MOVEM	OU,SAVEAC+1	;SAVE FOR LATER TRANSFER
	MOVEM	17,AC2+15	;[354] Preserve 17
	MOVE	17,(P)		;[355] Retrieve original .JBFF
	MOVEM	17,.JBFF	;[355] Put it back so it agrees with MEMSIZ
	SETZM	17		;CLEAR FOR 1 K EXPAND
INILP:	SOSGE	IINI+.BFCNT	;MORE TO READ?
	JRST	[IN	INICHN,	;NO, READ SOME
		 JRST	INILP	;AND CONTINUE
		 GETSTS	INICHN,B	;GET ERROR BITS
		 TRNN	B,IO.ERR	;ERROR?
		 JRST	INIDON	;NO
		 JRST	EE2ERR]	;SAY INPUT ERROR
	ILDB	CH,IINI+.BFPTR	;GET CHARACTER
	JUMPE	CH,INILP	;IGNORE IT
	CAML	OU,MEMSIZ	;[355] FIT?
	PUSHJ	P,GRABKQ	;[355] GET A K
	PUSHJ	P,PUT		;[355] STICK IT IN TEXT BUFFER
	AOJA	OU,INILP	;[355] DO REST OF IT

CHKPUT:	CAML	OU,MEMSIZ	;FIT?
	PUSHJ	P,GRABKQ	;GET A K
	PUSHJ	P,PUT		;STICK IT IN TEXT BUFFER
	AOJA	OU,CPOPJ	;DO REST OF IT
INIDON:	RELEAS	INICHN,		;WE ARE DONE
	TXNE	F2,S.INFO	;IF THIS OFF, INI FILE
	JRST	SAVSIZ		;SAV SIZE
	MOVEI	CH,.CHESC	;TECO'S ALTMODE
	PUSHJ	P,CHKPUT
	PUSHJ	P,CHKPUT
SAVSIZ:	MOVE	17,AC2+15	;[354] Restore 17
	MOVEM	OU,Z		;SAVE ALL THAT STUFF
	MOVE	C,SAVEAC+1	;START OF IT
	MOVE	B,Z		;END OF IT
	PUSHJ	P,COPYEI	;COPY INTO * Q-REG
	MOVE	B,BEG		;WHERE IT ALL STARTS
	ADD	B,SAVEAC	;+ LENGTH
	MOVEM	B,Z		;WHERE IT ENDS
	IDIVI	B,5		;FOR NEW .JBFF
	ADDI	B,2		;ASSUME LEFT OVER +1
	IORI	B,1777		;MAKE LIKE A JOBREL
	SOJ	B,		;SAFE
	POP	P,E		;[336] Restore original .JBFF
	CAMLE	E,B		;[336] If it is larger than our new one...
	MOVE	B,E		;[336] then use old one so we don't shrink
	MOVEM	B,.JBFF		;SAVE
	PUSHJ	P,CRE23		;YOU KNOW BY NOW!!
	POP	P,E		;RESTORE OLD JOBREL
	CAMGE	B,E		;E<B?
	MOVE	B,E
	MOVE	A,B		;SAVE FOR LATER
	CORE	B,		;SMALLIFY YOURSELF
	  JFCL			;JUST BEING NICE!
	TXNN	F2,S.INFO	;HE WISH TO KNO?
	JRST	NOKNOW		;NO
	CAME	A,E		;SAME?
	PUSHJ	P,CORES		;NO, SAY SIZE
;FOLLOWING REMOVED TO ALLOW INITIAL ARG IN MACRO
;	TXNN	FF,F.COLN	;IF F.COLN IS ONE WANT PROCESSING
;	HRRZS	DLIM		;DON'T WANT DOUBLE ARG PROCESSING
	MOVE	B,NUM		;GET ARG
	MOVEM	B,SYL		;AND FAKE FOR DOUBLE ARG PROCESSING
NOKNOW:	TXZ	FF,F.INIT	;CLEAR SO AS TO NOT SCREW UP GRABK
	TXZN	F2,S.DOIT	;DO IT?
	POPJ	P,		;RETURN
	MOVEI	CH,STAR		;VALUE OF Q-REG *
	POP	P,E		;THROW AWAY HOW YOU GOT HERE
	PUSHJ	P,QTEXEI	;INITIALIZE Q-REG ACCESS
	JRST	MAC1		;DO IT
	SUBTTL	E Commands -- EX & Exit Routines

FINIS1:	SETSTS	TTY,0		;RETURN TO NORMAL TTY MODE
	OUTPUT	TTY,0		;DUMMY OUTPUT TO LET SCNSER IN ON THE NEW MODE
FINIS2:	TXO	FF,F.NSRH	;[1007] No free form-feeds
	TXNE	FF,F.SEQ	;SEQUENCED FILE?
	JRST	IDIOT		;GARBAGE IT UP SOMEHOW
	MOVE	E,BEG		;GET BEGIN OF BUF
	CAME	E,Z		;IF = TO END SKIP PUNCH
	PUSHJ	P,PUNCHR	;PUNCH OUT THE CURRENT BUFFER
	TXO	FF,F.SQIN	;FIX BEGINNING OF BUFFER FOR FS.GEN
	TXNE	FF,F.IOPN	;DON'T INPUT IF NO FILE
FINIS3:	PUSHJ	P,@INCH		;[1007] Read a character from the input file
	JRST	CLOSE0		;[1024] None left, rename files etc.
	TXNN	FF,F.OOPN	;CAN WRITE?
	ERROR	E.NFO
	PUSHJ	P,@OUTCH	;WRITE CHARACTER OUT
	SKIPN	XCTING		;HE TYPE ^C REE?
	PUSHJ	P,CKEOL		;CAN'T STOP UNLESS EOL
	JRST	FINIS3		;[1007] Do them all!!!
	JRST	YANK1		;GET A BUFFERFUL

FINISH:	PUSHJ	P,FINIS1	;FINISH UP.
	SETZM	NFORMS		;[1024] Clear the
	SETZM	CURPAG		;[1024]  page number

;^Z -- RETURN TO THE MONITOR (SAME AS THE OLD ^G)

DECDMP:	RELEAS	TTY,0
	RELEAS	INCHN,0
	TXNE	F2,S.LOPN	;IF WE HAVE A LOG FILE,
	RENAME	LOGCHN,LOGFL	;DO A RENAME FOR PROTECTION
	  JFCL			;CANT HAPPEN
	RELEASE	LOGCHN,
	TXNE	FF,F.UBAK!F.OOPN	;IF WE HAVE AN OUTPUT FILE
	RENAME 	OUTCHN,OUTFIL		;DO THE SAME
	  JFCL
	RELEAS	OUTCHN,0
	TXZ	FF,F.IOPN+F.OOPN+F.EOFI+F.UBAK	;IN CASE OF A CONTINUE
	TXZ	F2,S.LIN!S.LOUT!S.LOPN
	PUSH	P,.JBFF		;[342] Save .JBFF
	RESET
	POP	P,.JBFF		;[342] Restore it
	SKIPE	RUNIT+1		;TO RUN SOMETHING
	JRST	[MOVEI A,RUNIT		;YES
		 HLL   A,RUNIT+5	;MAYBE STARTING ADR INCREMENT
		 SETZM RUNIT+5		;[1044] Clear the run-offset for 7.01
		 RUN   A,
		 HALT]
	MONRT.
	MOVX	E,AP.REN!AP.POV	;RE-ENABLE FOR PDL OV'S
	APRENB	E,
	JRST	GO		;IF HE CONTINUES
;EQ -- Edit Quit

EDTQIT:	PUSHJ	P,FINIS2	;[1007] Finish up
	TXNE	FF,F.UBAK!F.OOPN;[1007] Skip if the output file isn't open
	RENAME 	OUTCHN,OUTFIL	;[1007] Do a RENAME for protection
	  JFCL			;[1007] Oh well, i tried!!!
	RELEAS	OUTCHN,0	;[1007] Rlease the output channel
	TXZ	FF,F.IOPN!F.OOPN!F.EOFI!F.UBAK!F.FORM  ;[1007] Clear some flags
	SETZM	NFORMS		;[1024] Clear the
	SETZM	CURPAG		;[1024]  page number
	TXO	FF,F.ARG!F.ARG2	;[1007] Clear
	MOVEI	C,0		;[1007]  the
	HRLOI	B,37		;[1007]  text
	PJRST	KILL		;[1033] buffer


IFN CCL,<
IFE F%T20,<			;[1011]
CCLFIN:	PUSHJ	P,FINIS1	;FINISH FILE IO
IFN NORUNS,<
	SKIPGE	MONITR		;CHECK FOR 4 SERIES MONITOR
	JRST	NORUN		;3 SERIES - SIMULATE RUN UUO >
	MOVEI	A,CCLBLK	;RUN COMPIL
	HRLI	A,1		;AT START ADR PLUS ONE
	RUN	A,		;RUN UUO
	JRST	DECDMP		;JUST EXIT IF NO RUN.

CCLBLK:	SIXBIT	/SYS/
	SIXBIT	/COMPIL/	;RUN SYS:COMPIL
	REPEAT	4,<0> >

IFN F%T20,<			;[1011]
CCLFIN:	PUSHJ	P,FINIS1	;[1011] Finish file IO
	MOVE	1,[XWD .PRAST,.FHSLF]	       ;[1011] Do the last
	MOVEI	2,[EXP ^O1		       ;[1011]  'Compile'
		   EXP <^O4B2!^O17B12!^O2B35>  ;[1011]  class
		   EXP ^O0]		       ;[1011]  command
	MOVEI	3,^D3			       ;[1011]  again
	PRARG			;[1011] Send the request off to the EXEC
	HALTF			;[1011] Exit to EXEC mode >>
	SUBTTL	E Commands -- ED (RUN UUO on Exit)

IFN NORUNS,<
IFN CCL,<
NORUN:	MOVE	1,[SIXBIT /COMPIL/]
	MOVSI	2,SAVEXT	;SIXBIT FOR SAV OR DMP
	SETZB	3,4
	INIT	CCLCHN,.IODMP
	SIXBIT	/SYS/
	0
	EXIT
	LOOKUP	CCLCHN,1
	EXIT
	CALL	1,[SIXBIT /SETNAM/]
	HLRO	15,4
	HRLM	15,NORUN1
	MOVNS	15
	MOVEI	16,73(15)
	ADDI	15,INHERE
	TXO	15,1777
	MOVSI	NORTOP,NORAC
	BLT	NORTOP,NORTOP
	HRR	NORBLT,16
	JRST	NORUN2
	>>


;ROUTINE TO SET UP FOR RUN UUO ON EXIT

RUNFX:	HRLZM	B,RUNIT+5	;SAVE STARTING ADR INCREMENT
	PUSHJ	P,FILSPC	;WHAT WE WILL RUN
	SKIPN	E,FILDEV	;HE SPECIFY A DEVICE?
	MOVSI	E,'SYS'		;DEFAULT TO 'SYS'
	MOVEM	E,RUNIT		;PUT IT IN THE BLOCK
	MOVE	A,[XFILNM+.RBNAM,,RUNIT+1]
	BLT	A,RUNIT+4	;SAVE FILE SPEC
	MOVE	A,[FILPTH,,RUNIT+6]
	BLT	A,RUNIT+17	;SAVE PATH
	POPJ	P,		;DONE

IDIOT:	MOVSI	E,1
	PUSHJ	P,PUN1
	JRST	CLOSE0		;[1024] Close the output file
	SUBTTL	E Commands -- ET, EO & EU

;ET COMMAND
;		 0 = Normal typeout
;		 1 = Literal typeout
;		 2 = Image typeout  (IONEOU)

TYOCTL:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	TYOCT1		;YES.
	SKIPE	A,ETVAL		;[331] Get ET value
	CHKEO	EODEC,FFOK	;[331] If EO > 2 and non-zero, return -1
	JRST	VALRET		;[331] Return the value

TYOCT1:	CHKEO	EODEC,TYOCT3	;[331] Jump if old style ET
	SKIPL	B		;[331] Check range
	CAILE	B,2		;[331] ...
	  ERROR	E.ETA		;[331] Illegal value
TYOCT2:	MOVEM	B,ETVAL		;[331] Store value
	JRST	RET		;RETURN

TYOCT3:	JUMPE	B,TYOCT2	;[331] Old ET can be only 0 or 1
	MOVEI	B,1		;[331] Non zero means 1
	JRST	TYOCT2		;[331] Go store and return

;EO COMMAND

OLDMOD:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	OLD1		;YES, SET FLAG
	MOVE	A,EOFLAG	;NO, RETURN VALUE OF EOFLAG
	JRST	VALRET

OLD1:	CAIG	B,0		;N <= 0?
	MOVEI	B,EOVAL		;YES, SET TO STANDARD
	CAILE	B,EOVAL		;N > STANDARD FOR THIS VERSION?
	ERROR	E.EOA
	MOVEM	B,EOFLAG	;SET EOFLAG
	JRST	RET

;EU COMMAND

TYCASE:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	TYCAS1		;YES
	MOVE	A,TYCASF	;NO, RETURN VALUE OF TYPE-OUT CASE FLAG
	JRST	VALRET

TYCAS1:	MOVEM	B,TYCASF	;SET TYPE-OUT CASE FLAG
	JRST	RET
	SUBTTL	E Commands -- ES

AUTOTY:	POP	P,CH		;CLR RET ADDR FROM PDL
	TXNE	FF,F.ARG	;ARG?
	JRST	AUTOT1		;YES
	MOVE	A,AUTOF		;NO, RETURN VALUE OF FLAG
	JRST	VALRET

AUTOT1:	MOVEI	A,.CHLFD	;USE LF FOR FLAG IF ARG = 1 TO 37
	CAIL	B,1
	CAILE	B,37
	MOVE	A,B		;OTHERWISE USE WHAT HE GAVE
	MOVEM	A,AUTOF		;SET NEW VALUE IN FLAG
	JRST	RET
	SUBTTL	E Commands -- EH (Change Error Message Level)

ERRSET:	POP	P,CH		;YOU GOT HERE BY PUSHJ DUMMY!!
	TXNE	FF,F.ARG	;ARG SEEN?
	JRST	ERRSE1		;YES, RESET INDICATOR
	HLLZ	B,ERRLEN	;NO, RETURN CURRENT VALUE OF FLAG
	MOVSI	E,-3		;NUMBER OF POSSIBILITIES
	TDNE	B,JWTABL(E)	;BIT ON?
	MOVEI	A,1(E)
	AOBJN	E,.-2		;NO, LOOP
	JRST	VALRET

JWTABL:	XWD	JW.WPR_-22,JW.WPR_-22
	XWD	JW.WFL_-22,<JW.WPR!JW.WFL>_-22
	XWD	JW.WCN_-22,<JW.WPR!JW.WFL!JW.WCN>_-22

ERRSE1:	CAILE	B,3		;3 IS HIEST
	MOVEI	B,3		;FORCE IT DOWN IF GREATER
	MOVE	A,PRMERR	;ASSUME DEFAULT
	SKIPLE	B		;OK ASSUMPTION?
	HRLZ	A,JWTABL-1(B)	;NO
	MOVEM	A,ERRLEN	;2 BECOMES 0  = MEDIUM
	JRST	RET		;3 BECOMES +1 = LONG
	SUBTTL	E Commands -- EV (Set Terminal Characteristics)

VIDEO:
IFE CRT,<..ERROR  E.CRT>
IFN CRT,<
	POP	P,CH		;[1003] Get rid of return adr
	TXNE	FF,F.ARG	;[1003] Arg seen?
	JRST	VIDCHG		;[1003] Yes, go poke
	SETZ	E,		;[1003] Init SIXBIT name
	MOVE	OU,[POINT 6,E]	;[1003] Inital pointer
VID1:	PUSHJ	P,SKRCH		;[1003] Get next character
	..ERROR	E.UTV		;[1003] No more
	CAIN 	CH,.CHESC	;[1003] Altmode?
	JRST	VID2		;[1003] Yes
	PUSHJ	P,CKSYM		;[1003] Legal character?
	TRCA	B,40		;[1003] Yes - convert to SIXBIT and skip
	..ERROR	E.ICV		;[1003] No
	TXNE	OU,77B5		;[1003] Skip if full
	IDPB	B,OU		;[1003] Pack the character
	JRST	VID1		;[1003] Loop

IFN F%TYPE,<			;[2012] Use ITTYPE.REL
VID2:	PUSHJ	P,VID3		;[2012] Do the right stuff
	JRST	RET		;[2012] All done

;Routine to check terminal type.  Call with TTY type in E, in SIXBIT.
DEFVID:	SETZ	E,		;[2012] Use default display type

VID3:	MOVEM	E,SWITHL	;[2012] Save in case it's bad

;NOTE: The routine in ITTYPE.REL expects T1=1, T2=2, and P=17
;This kludge with SAVAC1-3 is guarenteed to work, regardless of how P is defined
	MOVEM	1,SAVAC1	;[2012] #$%*& screwy AC definitions
	MOVEM	2,SAVAC2	;[2012] Save AC2 incase its important
	MOVEM	17,SAVAC3	;[2012] .ITTYPE preserves 0, 3-16, uses 1, 2, 17
	MOVE	17,P		;[2012] Stack pointer must be in AC17
	MOVE	1,[-NUMCRT,,CRTTAB]  ;[2012] Pointer to table must be in AC1
	MOVE	2,SWITHL	;[2012] Terminal type must be in AC2
	PUSHJ	17,.TTYPE##	;[2012] ITTYPE.REL understands aliases
	MOVE	T,1		;[2012] The answer is returned in AC1
	MOVE	1,SAVAC1	;[2012] Restore
	MOVE	2,SAVAC2	;[2012]  used
	MOVE	17,SAVAC3	;[2012]   ACs
;End of kludge

	JUMPL	T,[SKIPE   SWITHL	;[2012] Unknown type, asking for default?
		   ..ERROR E.UTT	;[2012] No, specified type is unknown
		   MOVEI   T,CRTGEN-CRTDSP  ;[2012] Yes, set type to CRT
		   PJRST   SETVID]	;[2012] Set up the video parameters
	PJRST	SETVID		;[2012] Set up the video parameters >

IFE F%TYPE,<			;[2012]
VID2:	JUMPE	E,VID3		;[1003] Go use the default
	MOVEM	E,SWITHL	;[1003] Save in case its bad
	MOVE	T,[-NUMCRT,,CRTTAB]  ;[1003] Set up index pointer
	PUSHJ	P,TSTABR	;[1003] Go see if a valid video type
	 JRST	[..ERROR E.UTT		;[1003] Unknown video type
		 ..ERROR E.ABT](A)	;[1003] Ambiguous video type
	PUSHJ	P,SETVID	;[1003] Set the video stuff up
	JRST	RET		;[1003] We're done

VID3:	PUSHJ	P,DEFVID	;[1003] Go get the default video type
	JRST	RET		;[1003] We're done
;Here to get the default video type for this terminal

DEFVID:	SETZM	TRMNAM		;[2007] Incase the TRMOP. fails
	MOVX	A,.TOTRM	;[1036] Get the
	SETO	AA,		;[1036]  terminal
	MOVE	E,[2,,A]	;[1036]  type from
	TRMOP.	E,		;[1036]  the monitor
	  JRST	DEFVI0		;[JMS] Try other method
DEFV00:	MOVEM	E,TRMNAM	;[2007] Save for equivalences
	MOVE	T,[-NUMCRT,,CRTTAB]  ;[1042] Check for a
	PUSHJ	P,TSTABR	     ;[1036]  known type
	 JRST	DEFV01		;[1036] Unknown, try DISPLA.INI then
	JRST	SETVID		;[1036] Found something good, use it

;Here when TRMOP. to get terminal type fails

DEFVI0:
IFN FT$TYM,<	OPDEF	AUXCAL	[042B8]	;TYMCOM-X's UUO
		.AXTTP==100		;Read terminal CLASS
	HRROI	A,.AXTTP	;[JMS] Our port, get class
	SETO	E,		;[JMS] -1 to read current value
	AUXCAL	A,E		;[JMS] Get SIXBIT terminal type/class
	CAME	E,[-1]		;[JMS] UUO not implemented if E unchanged
	 JRST	DEFV00		;[JMS] Got it
>  ;End of IFN FT$TYM
	
IFE F%T20,<
	JRST	DEFV01		;[1036] Pre-701, go do it the hard way >
IFN F%T20,<			;[1042]
	MOVX   A,%CNMNT	;[1042] Get the operating
	GETTAB A,		;[1042]  system type
	  JRST  DEFV01		;[1042] Go do it the hard way
	LDB    A,[$POINT A,CN%MNT]  ;[1042] Get the operating system type
	CAXE   A,.CNT20	;[1042] Skip if TOPS20
	JRST   DEFV01		;[1042] Go do it the hard way
	MOVEM  1,SAVAC1	;[1042] Save AC-1,
	MOVEM  2,SAVAC2	;[1042]  AC-2 and
	MOVEM  3,SAVAC3	;[1042]  AC-3
	MOVX   1,.PRIOU	;[1042] File designator
	GTTYP			;[1042] Do JSYS to get TTY type
	 ERJMP [HALT]		;[1042] Should never happen
				;[1042]  (Same old DEC answer)
	MOVE   E,2		;[1042] Save the TTY type
	MOVE   1,SAVAC1	;[1042] Restore AC-1,
	MOVE   2,SAVAC2	;[1042]  AC-2 and
	MOVE   3,SAVAC3	;[1042]  AC-3
	CAIGE  E,LENT20	;[1042] Out of range?
	SKIPA  E,T20NAM(E)	;[1042] Get SIXBIT name for TOPS20 TTY number
	 MOVX   E,'???   '	;[1042] If out of range give ???
	JRST   DEFV00		;[1042] See if a known CRT type >
DEFV01:	PUSH	P,.JBFF		;[1003] Save my current size
	MOVE	A,[VIDINI,,VIDOPN]  ;[1003] Set up to LOOKUP
	BLT	A,VIDEND	    ;[1003]  'SYS:DISPLA.INI'
	OPEN	VIDCHN,VIDOPN	;[1003] Get an I/O channel to 'SYS'
	 JRST	DEFV14		;[1003] No 'SYS'
	LOOKUP	VIDCHN,VIDLOK	;[1003] See if 'DISPLA.INI' is on SYS
	 JRST	DEFV14		;[1003] No file 'DISPLA.INI'
	INBUF	VIDCHN,1	;[1003] Get one buffer
	MOVSI	T,'TTY'		;[1003] Get my node/line
	GTNTN.	T,UU.PHY	;[1003]  Number
	 JRST	[PJOB	T,		;[1003] Get my terminal's
		 TRMNO.	T,		;[1003]  I/O index
		  JRST	DEFV14		;[1003] No such animal?
		 ANDI	T,777		;[1003] Get only the line number
		 JRST	.+1]		;[1003] Go save the line number
	HLRZM	T,NODNUM	;[1003] Save my node number
	HRRZM	T,LINNUM	;[1003] Save my terminal number

DEFV02:	SETZM	NODNAM		;[1003] Reset the node name
	PUSHJ	P,SIXIN		;[1003] Go get the node/terminal name
	CAIE	CH,"_"		;[1003] Skip if node name was input
	JRST	DEFV03		;[1003] Go see if terminal name
	JUMPE	T,DEFV14	;[1003] Jump if the node name is null
	MOVEM	T,NODNAM	;[1003] Save the node name
	PUSHJ	P,SIXIN		;[1003] Get the terminal name
DEFV03:	JUMPE	T,[CAXN  CH,.CHCRT	;[2005] If carriage-return
		   PUSHJ P,VIDIN	;[2005]  get the line-feed
		   CAXN  CH,.CHLFD	;[2005] If a blank line
		   JRST  DEFV02		;[2005]  ignore it
		   JRST  DEFV14]	;[2005] Error on input data
	CAXN	CH,"="		;[2005] Equal sign for synonym
	JRST	[AOS  NODNAM		;[2005] +1 implies
		 JRST DEFV3A]		;[2005]  equal seen
	CAIE	CH,":"		;[1003] Skip if a colon
	JRST	DEFV14		;[1003] Error on input data
DEFV3A:	MOVEM	T,LINNAM	;[1003] Save the line number
	PUSHJ	P,SIXIN		;[1003] Get the video name
	CAIE	CH,.CHCRT	;[1003] Skip if a carriage return
	JRST	DEFV14		;[1003] Error in the input data
	PUSHJ	P,VIDIN		;[1003] Get the next character
	CAIN	CH,.CHLFD	;[1003] Skip if not a line feed
	CAIN	T,0		;[1003] Skip if a non-null video type
	JRST	DEFV14		;[1003] Error in the input data
	MOVEM	T,VIDNAM	;[1003] Save the video name
	SKIPGE	E,NODNAM	;[1003] Get the node name/number
	JRST	DEFV05		;[1003] Jump if a node name
	JUMPE	E,DEFV04	;[1003] Jump if node name is zero
	CAIN	E,^O1		;[2005] Was an equal sign seen
	JRST	[MOVE  E,LINNAM		;[2005] Yes, get the alias information
		 CAME  E,TRMNAM		;[2005] Does it match what the TRMOP. said?
		 JRST  DEFV02		;[2005] No, try again
		 MOVE  E,VIDNAM		;[2005] Get what it translates into
		 MOVE  T,[-NUMCRT,,CRTTAB]  ;[2005] See if this new
		 PUSHJ P,TSTABR		    ;[2005]  info helps any
		  JRST  DEFV02		;[2005] No, keep looking
		 JRST  DEFV15]		;[2005] Inform the world
	PUSHJ	P,SIXOCT	;[1003] Convert SIXBIT to octal
	 JRST	DEFV06		;[1003] Not octal go try the next entry
	JUMPN	T,DEFV07	;[1003] Go see if the right node
DEFV04:	HRRZI	T,.GTLOC	;[1003] Get the central
	GETTAB	T,		;[1003]  site node number
	 SETZ	T,		;[1003] No network code
	JRST	DEFV07		;[1003] Go see if the one we want
DEFV05:	CAMN	T,['ALL   ']	;[1003] Skip if not 'ALL'
	JRST	DEFV08		;[1003] This one is always a match
DEFV06:	MOVE	T,[.NDRNN,,B]	;[1003] Get the node
	MOVEI	B,2		;[1003]  number of
	NODE.	T,		;[1003]  the node
	 JRST	DEFV02		;[1003] No such node name

DEFV07:	CAME	T,NODNUM	;[1003] Skip if they match
	JRST	DEFV02		;[1003] Try the next entry
DEFV08:	HLRZ	T,LINNAM	;[1003] Get the type of terminal
	CAIN	T,'TTY'		;[1003] Skip if not 'TTY'
	JRST	DEFV11		;[1003] Get the relative line number
	CAIN	T,'CTY'		;[1003] Skip if not 'CTY'
	JRST	DEFV09		;[1003] Get the cty line number
	CAIN	T,'ALL'		;[1003] Skip if not 'ALL'
	JRST	DEFV13		;[1003] This one always matches
	CAIE	T,'OPR'		;[1003] Skip if 'OPR'
	JRST	DEFV10		;[1003] Try the next entry

	MOVE	T,NODNUM	;[1003] Get my node number
	SETZ	TT,		;[1003] Get the node
	LSHC	T,-^D3		;[1003]  number in
	LSH	T,^D3		;[1003]  the left
	LSHC	T,^D9		;[1003]  half of
	TDOA	T,['OPR00 ']	;[1003]  the name

DEFV09:	MOVSI	T,'CTY'		;[1003] Get the line number to the CTY
	MOVE	TT,T		;[1003] Save T in case of an error
	GTNTN.	T,UU.PHY	;[1003] Get the line number wanted
	 JRST	[MOVE	T,TT		;[1003] Get the terminal name back
		 IONDX.	T,		;[1003] Get the I/O index
		  JRST	DEFV02		;[1003] No such animal?
		 JRST	.+1]
	ANDI	T,777		;[1003] Get rid of some junk
	JRST	DEFV12		;[1003] Go see if the right line

DEFV10:	SKIPA	E,LINNAM	;[1003] Assume the name is in octal
DEFV11:	HRLZ	E,LINNAM	;[1003] Get the terminal number
	PUSHJ	P,SIXOCT	;[1003] Convert SIXBIT to octal
	 JRST	DEFV14		;[1003] Error on input
DEFV12:	CAME	T,LINNUM	;[1003] Skip if we found the right entry
	JRST	DEFV02		;[1003] No - try the next entry

DEFV13:	MOVE	E,VIDNAM	     ;[1003] Go see if
	MOVE	T,[-NUMCRT,,CRTTAB]  ;[1003]  a valid
	PUSHJ	P,TSTABR	     ;[1003]  video type
DEFV14:	 MOVEI	T,CRTGEN-CRTDSP	;[1003] Assume 'CRT'
DEFV15:	RELEAS	VIDCHN,		;[1003] Release the disk file
	POP	P,.JBFF		;[1003] Restore .JBFF
	HRRZ	A,.JBFF		;[1003] Restore my
	CORE	A,		;[1003]  core size
	 JFCL			;[1003] Well, I tried
	PFALL	SETVID		;[1003] Fall into video setup stuff >
;Here to set up the video stuff

SETVID:	MOVS	A,CRTDSP(T)	;[1003] Store the
	HRRZM	A,CRTTYP	;[1003]  video stuff
	HRRI	A,BACRUB	;[1003]  some place
	BLT	A,CTUSEQ	;[1003]  accessable
	TLZ	T,-1		;[1003] Clear the left half
	POPJ	P,		;[1003] Return


IFE F%TYPE,<			;[2012]

;Here for a character from 'SYS:DISPLA.INI'

VIDIN:	SOSG	VIDHED+.BFCTR	;[1003] Skip if the buffer isn't empty
	JRST	VIDIN1		;[1003] Go fill the buffer
VIDIN0:	ILDB	CH,VIDHED+.BFPTR;[1003] Get a character
	JUMPE	CH,VIDIN	;[1003] Get another character if a null
	POPJ	P,		;[1003] Return
VIDIN1:	IN	VIDCHN,		;[1003] Fill the input buffer
	JRST	VIDIN0		;[1003] Full to empty it
	 MOVEI	CH,-1		;[1003] Assume E-O-F, inform the caller
	 POPJ	P,		;[1003] Return


;Here to input a SIXBIT word

SIXIN:	SETZ	T,		;[1003] Reset the SIXBIT word
	MOVE	OU,[POINT 6,T]	;[1003] Set up a byte pointer

SIXIN0:	PUSHJ	P,VIDIN		;[1003] Get a character for the file
	CAXE	CH," "		;[2005] Space
	CAXN	CH,.CHTAB	;[2005]  or tab?
	JRST	SIXIN0		;[2005] Yes, eat leading ones
	CAXE	CH,";"		;[2005] Semicolon or
	CAXN	CH,"!"		;[2005]  exclaimation point
	SETOM	RSNCMT		;[2005] Yes, set the comment flag
	CAXE	CH,.CHCRT	;[2005] Carriage-return
	CAXN	CH,.CHLFD	;[2005]  or line-feed?
	SETZM	RSNCMT		;[2005] Yes, end of comment
	SKIPE	RSNCMT		;[2005] Still in the comment
	JRST	SIXIN0		;[2005] Yes, eat some another character
	CAIL	CH,"a"		;[1003] Skip if less than an "a"
	CAILE	CH,"z"		;[1003] Skip if less than a "z"
	JRST	SIXIN2		;[1003] Go store the character
	MOVEI	CH,"A"-"a"(CH)	;[1003] Convert lower case to upper case

SIXIN1:	MOVEI	CH,' '-" "(CH)	;[1003] Convert ASCII to SIXBIT
	TXNE	OU,77B5		;[1003] Skip if the SIXBIT word is full
	IDPB	CH,OU		;[1003] Store the character
	JRST	SIXIN0		;[1003] Go get the next character

SIXIN2:	CAIG	CH,"Z"		;[1003] Skip if greater than a "Z"
	CAIGE	CH,"0"		;[1003] Skip if greater than a "0"
	POPJ	P,		;[1003] Return
	CAIGE	CH,"A"		;[1003] Skip if greater than a "A"
	CAIG	CH,"9"		;[1003] Skip if greater than a "9"
	JRST	SIXIN1		;[1003] Go store the character
	POPJ	P,		;[1003] Return
;Here to convert SIXBIT to octal

SIXOCT:	JUMPE	E,CPOPJ		;[1003] Jump if equal to zero
	SETZ	T,		;[1003] Reset the number
	MOVE	OU,[POINT 6,E]	;[1003] Set up the byte pointer
SIXOC0:	ILDB	TT,OU		;[1003] Get a character
	JUMPE	TT,CPOPJ1	;[1003] Return if null
	CAIL	TT,'0'		;[1003] Skip if less than a '0'
	CAILE	TT,'7'		;[1003] Skip if less than a '7'
	POPJ	P,		;[1003] Give an error return
	LSH	T,3		;[1003] Multiply by eight
	ORI	T,-'0'(TT)	;[1003] Add in the new digit
	TXNE	OU,77B5		;[1003] Skip if the end of the word is reached
	JRST	SIXOC0		;[1003] Go try the next byte
	JRST	CPOPJ1		;[1003] Give a good return


;Here are the initial OPEN/LOOKUP blocks for 'SYS:DISPLA.INI'

VIDINI:	.IOASC		;[1003] I/O mode
	'SYS   '	;[1003] Device
	VIDHED		;[1003] Buffer header

	'DISPLA'	;[1003] File-name
	'INI   '	;[1003] File-extension
	0		;[1003] Protection
	0		;[1003] PPN (default path) >
;Here to test for an abbreviated name

IFN F%RSCN!<-^F%TYPE>,<		;[2012]
TSTABR:	SETO	TT,		;[1003] Reset a counter

TSTAB0:	LSH	TT,-6		;[1003] Shift the mask to the right
	TDNE	E,TT		;[1003] Skip if out of characters
	JRST	TSTAB0		;[1003] Loop back until finished

	SETZ	A,		;[1003] Clear the flag for later
	HRRZ	I,T		;[1003] Save the base address for later

TSTAB1:	MOVE	B,(T)		;[1003] Get a word to test
	XOR	B,E		;[1003] Try to clear some characters
	JUMPE	B,TSTAB3	;[1003] Jump if a match was found
	ANDCM	B,TT		;[1003] Clear any extra characters
	JUMPN	B,TSTAB2	;[1003] Jump if not a valid abbreviation
	TRON	A,1		;[1003] Skip a if not the first match
	TLOA	A,(T)		;[1003] Set the flag for an abreviation found
	TLZ	A,-1		;[1003] More than one abbreviation found
TSTAB2:	AOBJN	T,TSTAB1	;[1003] Loop back if not finished

	TLNN	A,-1		;[1003] Skip if an abbreviation was found
	POPJ	P,		;[1003] Error - no such animal

	HLRZ	T,A		;[1003] Set up t to point to the abbreviation
TSTAB3:	SUB	T,I		;[1003] Set up T to be 0, 1, 2, ...
	JRST	CPOPJ1		;[1003] Give a good return >

;HERE IF EV HAD NUMERICAL ARGUMENTS.

VIDCHG:	PUSHJ	P,SKRCH		;GET ANOTHER CHARACTER
	..ERROR	E.NAV
	CAIE	CH,.CHESC	;MUST BE ALTMODE
	..ERROR	E.NAV
	TXZN	FF,F.ARG2	;ONLY ONE ARG?
	JRST	RETEV		;YES, GO RETURN THE VALUE
	SKIPLE	C
	CAILE	C,20		;MAKE SURE FIRST ARG IS BETWEEN 1 AND 16.
	..ERROR	E.VOR
	CAIE	C,20		;EQUAL TO 16?
	JRST	VDC1		;NO
	CAMN	B,[-1]		;YES, IS ARG -1?
	HRLZI	B,032120	;YES, CHANGE TO CRLF (SHIFTED 1 RIGHT)
VDC1:	CAILE	C,6		;IS THE 1ST ARG GREATER THAN 6?
	LSH	B,1		;YES, SHIFT (TECO CAN'T HANDLE BIG NEG. #S)
	MOVEM	B,CRTTYP-1(C)	;STORE VALUE
	JRST	RET

RETEV:	SKIPLE	B		;CHECK RANGE
	CAILE	B,20
	..ERROR	E.VOR
	MOVE	A,CRTTYP-1(B)	;GET VALUE
	CAILE	B,6		;NEED TO SHIFT AN ASCIZ TO MAKE IT POS?
	LSH	A,-1		;YES
	JRST	VALRET
	SUBTTL	E Commands -- Terminal Characteristics Tables

CRTTAB:	SIXBIT	/TTY/		;TYPES OF CRT'S
	SIXBIT	/CRT/		;Generic CRT must be at CRTTAB+1
	SIXBIT	/ACT4/		;[331]
	SIXBIT	/ACT5/		;[331]
	SIXBIT	/ADD580/
	SIXBIT	/ADM2/
	SIXBIT	/ADM3/
	SIXBIT	/ADM3A/		;[331]
	SIXBIT	/BEE/
	SIXBIT	/CDC/
	SIXBIT	/CONCEP/	;[1003] Concept 100
	SIXBIT	/COPS10/	;[1003] Computer Peripheral COPS-10
	SIXBIT	/DM1521/	;[1003] Datamedia Elite 1521
	SIXBIT	/DPT/
	SIXBIT	/GIGI/		;[2020] GIGI = VT100
	SIXBIT	/H1200/
	SIXBIT	/H1500/		;[331]
	SIXBIT	/H19/		;[2020] Heathkit H-19 in VT52 mode
	SIXBIT	/H2000/
	SIXBIT	/HP2621/	;[2021] Hewlett Packard 2621
	SIXBIT	/HP2640/	;[331]
	SIXBIT	/IQ120/		;[1003] Soroc IQ-120
	SIXBIT	/LA12/		;[2020] LA12  = LA36
	SIXBIT	/LA120/		;[2020] LA120 = LA36
	SIXBIT	/LA34/		;[2015] DECwriter-IV
	SIXBIT	/LA36/		;[2015] DECwriter-II
	SIXBIT	/MINIBE/	;[1003] Same as BEE
	SIXBIT	/TK4025/	;[1043] Tektronix 4025
	SIXBIT	/TYM444/	;[2021] Hewlett Packard 2621
	SIXBIT	/VIS200/	;[2001] Visual 200 in VT52 mode
	SIXBIT	/VK100/		;[2020] VK100 = VT100
	SIXBIT	/VT05/
	SIXBIT	/VT50/		;[324]
	SIXBIT	/VT52/
	SIXBIT	/VT100/		;[1003] VT100 in ANSI mode
	SIXBIT	/VT101/		;[2020] VT101 = VT100
	SIXBIT	/VT102/		;[2020] VT102 = VT100
	SIXBIT	/VT105/		;[1003] VT105 in ANSI mode
	SIXBIT	/VT125/		;[2020] VT125 = VT100
	SIXBIT	/VT131/		;[2020] VT131 = VT100
	SIXBIT	/VT132/		;[2020] VT132 = VT100
	SIXBIT	/VT180/		;[2020] VT180 = VT100
	SIXBIT	/VT200/		;[2020] VT200 = VT100
	SIXBIT	/VT220/		;[2020] VT220 = VT100
	SIXBIT	/VT240/		;[2020] VT240 = VT100
	SIXBIT	/VT241/		;[2020] VT241 = VT100
NUMCRT==.-CRTTAB
;[1042] Table of Terminal names which get assigned to the TOPS20 terminal
;[1042]  type number.

IFE F%TYPE,<			;[2012]
IFN F%T20,<			;[1042]
T20NAM:	SIXBIT	~TTY~		;[1042]  0 - Model 33 TTY
	SIXBIT	~TTY~		;[1042]  1 - Model 35 TTY
	SIXBIT	~TTY~		;[1042]  2 - Model 37 TTY
	SIXBIT	~EXECUP~	;[1042]  3 - TI/EXECUPORT
	SIXBIT	~DM1521~	;[1042]  4 - Customer defined (Datamedia 1521)
	SIXBIT	~CUSTOM~	;[1042]  5 - Customer defined
	SIXBIT	~CUSTOM~	;[1042]  6 - Customer defined
	SIXBIT	~CUSTOM~	;[1042]  7 - Customer defined
	SIXBIT	~DEFAUL~	;[1042] 10 - Default
	SIXBIT	~IDEAL~		;[1042] 11 - Ideal
	SIXBIT	~VT05~		;[1042] 12 - VT05
	SIXBIT	~VT50~		;[1042] 13 - VT50
	SIXBIT	~LA30~		;[1042] 14 - LA30
	SIXBIT	~GT40~		;[1042] 15 - GT40
	SIXBIT	~LA36~		;[1042] 16 - LA36
	SIXBIT	~VT52~		;[1042] 17 - VT52
	SIXBIT	~VT100~		;[1042] 20 - VT100
	SIXBIT	~LA38~		;[1042] 21 - LA38
	SIXBIT	~LA120~		;[1042] 22 - LA120
LENT20==.-T20NAM		;[1042] >>
;FLAG BITS--STORED IN CRTTYP (PARAMETER 1).
.CTTY.==0		;[1003] Terminal isn't a CRT
.CCRT.==1		;TERMINAL IS A CRT
.CNCR.==2		;DON'T OUTPUT LONE CR TO TERMINAL
.CWAP.==4		;TERMINAL DOESN'T WRAP AROUND ON BACKSPACE FROM LEFT MARGIN
.CDLF.==10		;[1003] Use DELVT to delete an immediate mode LF

;ADDRESSES OF TERMINAL BLOCKS
;LEFT HALF CONTAINS VALUE OF CRTTYP (PARAMETER 1)

CRTDSP:	              .CTTY.,,VTTY	;For TTY (non-CRT's)
CRTGEN:	       .CWAP.+.CCRT.,,VCRT	;General CRT setting
	       .CWAP.+.CCRT.,,VACT4	;ACT4
	       .CWAP.+.CCRT.,,VACT5	;ACT5
	              .CCRT.,,VADD5	;ADD580
	              .CCRT.,,VADM2	;ADM2
	       .CWAP.+.CCRT.,,VADM3	;ADM3
	       .CWAP.+.CCRT.,,VADM3A	;ADM3A
	              .CCRT.,,VBEE	;MINIBEE
	              .CCRT.,,VCDC	;CDC
	       .CDLF.+.CCRT.,,VCONCP	;[1003] Concept 100
	       .CWAP.+.CCRT.,,VDCOPS	;[1003] COPS10
	       .CWAP.+.CCRT.,,VD1521	;[1003] DM1521
	       .CWAP.+.CCRT.,,VDPT	;DPT
	       .CWAP.+.CCRT.,,VVT100	;[2020] GIGI = VT100
	              .CCRT.,,VHZL1	;H1200
	              .CCRT.,,VHZL15	;H1500
	       .CWAP.+.CCRT.,,VVT52	;[2020] H19 same as VT52
	              .CCRT.,,VHZL2	;H2000
	       .CWAP.+.CCRT.,,VHP26	;[2021]HP2621
	       .CWAP.+.CCRT.,,VHP26	;[331] HP2640
	              .CCRT.,,VIQ120	;[1003] IQ120 same as ADM2
	              .CTTY.,,VLA36	;[2020] LA12 = LA36
	              .CTTY.,,VLA36	;[2020] LA120 = LA36
	              .CTTY.,,VLA34	;[2015] DECwriter-IV
	              .CTTY.,,VLA36	;[2015] DECwriter-II
	              .CCRT.,,VMINBE	;[1003] MINIBEE
	              .CCRT.,,VTEK25	;[1043] Tektronix 4025
	       .CWAP.+.CCRT.,,VHP26	;[2021] TYM444=HP2621
	       .CWAP.+.CCRT.,,VVS200	;[2001] Visual 200 in VT52 mode
	       .CWAP.+.CCRT.,,VVT100	;[2020] VK100 = VT100
	       .CWAP.+.CCRT.,,VVT05	;       VT05
	       .CWAP.+.CCRT.,,VVT50	;[331]  VT50
	       .CWAP.+.CCRT.,,VVT52	;[331]  VT52 same as VT50
CRT100:	       .CWAP.+.CCRT.,,VVT100	;[1003] VT100 in ANSI mode
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT101 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT102 = VT100
	       .CWAP.+.CCRT.,,VVT105	;[1003] VT105 same as VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT125 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT131 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT132 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT180 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT200 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT220 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT240 = VT100
	       .CWAP.+.CCRT.,,VVT100	;[2020] VT241 = VT100
IFN <.-CRTDSP>-NUMCRT,<PRINTX ?CRTDSP does not match CRTTAB>
VTTY:			;Dummy address - all this is ignored
VLA34:	VLA36:		;[2015] More dummy labels
VCRT:			;General CRT setting = ADM3

;The 1,nEV$ settings are in the previous table (CRT flags).  The next 5
;parameters are:
;  2) Supplementary rubout character
;  3) Horizontal width of vertical tab
;  4) Horizontal width of formfeed
;  5) Number of linefeeds in a vertical tab
;  6) number of linefeeds in a formfeed
VADM3:	EXP      10,0,0,0,0	;2-6)
	BYTE (7) 10,0		;7) Cursor left
	BYTE (7) 40,0		;8) Cursor right
	BYTE (7) 40,10,0	;9) Destructive backspace
	BYTE (7) 0		;10) Cursor up
	BYTE (7) 0		;11) Cursor up to delete vertical tab
	BYTE (7) 0		;12) Cursor up to delete form feed
	BYTE (7) 0		;13) Delete CR (up-cursor if .CWAP., 0 if wrap)
	BYTE (7) 10,0		;14) Character to make rubout do one backspace
	BYTE (7) 0		;15) Character to make 2) do backspace (if printing)
	BYTE (7) 0		;16) Control-U (CR,EOL)

VMINBE:
VBEE:	EXP      10,0,0,4,10
	BYTE (7) 10
	BYTE (7) 33,103
	BYTE (7) 40,10
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 0
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,33,113,15

VACT5:
VACT4:	EXP      10,0,0,4,10
	BYTE (7) 10
	BYTE (7) 40
	BYTE (7) 40,10
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,36

VIQ120:				;[1003] IQ120
VADM2:	EXP      10,0,1,4,10
	BYTE (7) 10
	BYTE (7) 40
	BYTE (7) 40,10
	BYTE (7) 13
	BYTE (7) 13
	BYTE (7) 13
	BYTE (7) 0
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,33,124,15

VADM3A:	EXP      10,0,1,4,10
	BYTE (7) 10
	BYTE (7) 40
	BYTE (7) 40,10
	BYTE (7) 13
	BYTE (7) 13
	BYTE (7) 13
	BYTE (7) 13
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 0

VDPT:	EXP      10,0,0,4,8
	BYTE (7) 10,31
	BYTE (7) 40
	BYTE (7) 36		;THIS MAY BE A LOCAL MOD AT U. OF T.
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 10,31
	BYTE (7) 31
	BYTE (7) 15,36

VCDC:	EXP      10,0,0,4,8
	BYTE (7) 10
	BYTE (7) 25
	BYTE (7) 40,10
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 0
	BYTE (7) 10,40,10,10
	BYTE (7) 0
	BYTE (7) 0	;EOL SEEMS TO BE DISABLED ON A CDC (SHOULD BE ^V)

VHP26:	EXP      10,0,0,4,10
	BYTE (7) 10
	BYTE (7) 33,103
	BYTE (7) 40,10
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,33,113,15

VHZL1:	EXP      10,0,0,1,1
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 20,10
	BYTE (7) 12
	BYTE (7) 0
	BYTE (7) 0
	BYTE (7) 0
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 0

VHZL15:	EXP      10,0,0,4,10
	BYTE (7) 10
	BYTE (7) 40
	BYTE (7) 40,10
	BYTE (7) 176,14
	BYTE (7) 0
	BYTE (7) 0
	BYTE (7) 0
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,176,17,15

VHZL2:	EXP      10,0,0,0,0
	BYTE (7) 10
	BYTE (7) 40
	BYTE (7) 40,10
	BYTE (7) 0
	BYTE (7) 0
	BYTE (7) 0
	BYTE (7) 0
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 176,23,177,15	;[331]

VVS200:		;Visual 200 in VT52 mode
VVT52:
VVT50:	EXP      10,0,0,4,10
	BYTE (7) 10
	BYTE (7) 33,103
	BYTE (7) 40,10
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 33,101
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,33,113,15

VVT05:	EXP      10,0,0,4,8
	BYTE (7) 10
	BYTE (7) 40
	BYTE (7) 40,10
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 36,32		;[331]
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,36

VADD5:	EXP      10,0,0,4,8
	BYTE (7) 25,10
	BYTE (7) 40
	BYTE (7) 40,25,10
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 32
	BYTE (7) 0
	BYTE (7) 25,10
	BYTE (7) 25,10
	BYTE (7) 0

VD1521:	EXP      10,0,0,1,1	;[1003] Datamedia Elite 1521
	BYTE (7) 10
	BYTE (7) 34
	BYTE (7) 40,10
	BYTE (7) 37
	BYTE (7) 37
	BYTE (7) 37
	BYTE (7) 37
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,35,15

VDCOPS:	EXP      10,0,1,1,1	;[1003] Computer Peripheral's COPS10
	BYTE (7) 10
	BYTE (7) 14
	BYTE (7) 40,10
	BYTE (7) 13
	BYTE (7) 13
	BYTE (7) 13
	BYTE (7) 0
	BYTE (7) 10
	BYTE (7) 0
	BYTE (7) 15,26,15

VVT100:
VVT105:	EXP      10,0,0,1,1	;[1003] VT100/VT105 in ANSI mode
	BYTE (7) 10,0
	BYTE (7) 33,133,103,0
	BYTE (7) 40,10,0
	BYTE (7) 33,133,101,0
	BYTE (7) 33,133,64,101,0
	BYTE (7) 33,133,70,101,0
	BYTE (7) 33,133,101,0
	BYTE (7) 10,0
	BYTE (7) 0
	BYTE (7) 33,133,62,113,15,0

VCONCP:	EXP      10,0,0,4,10	;[1003] Concept 100
	BYTE (7) 10,0
	BYTE (7) 33,75,0
	BYTE (7) 40,10,0
	BYTE (7) 33,5,33,134,0
	BYTE (7) 33,73,0
	BYTE (7) 33,73,0
	BYTE (7) 0
	BYTE (7) 10,0
	BYTE (7) 0
	BYTE (7) 15,33,23,15,0

VTEK25:	EXP	10,0,1,1,1	;[1043] Tektronix 4025
	BYTE	(7) 10,0
	BYTE	(7) 40,0
	BYTE	(7) 40,10,0
	BYTE	(7) 13,0
	BYTE	(7) 12,0
	BYTE	(7) 10,0
	BYTE	(7) 0
	BYTE	(7) 10,0
	BYTE	(7) 0
	BYTE	(7) 0

> ;End of 'IFN CRT'
	SUBTTL	E Commands -- EK (Kill) and EN (Rename)

EKILL:	MOVEI	E,OUTCHN
	RESDV.	E,		;DISCARD FILE
	CLOSE	OUTCHN,CL.RST	;DO THE BEST WE CAN
	TXZ	FF,F.UBAK+F.OOPN	;ZERO EB AND EW FLAGS
	POPJ	P,		;AND RETURN



RENAM:	TXNE	FF,F.UBAK	;EB IN PROGRESS
	..ERROR	E.EBO
	PUSHJ	P,FILSPC	;GET A FILE SPEC (IF ANY)
	SKIPE	FILDEV
	..ERROR	E.END
	TXZN	FF,F.IOPN	;ER IN PROGRESS?
	..ERROR	E.ENO
	TXNN	FF,F.FILE	;DID WE SEE ANY FILSPEC AT ALL
	JRST	RENAM1		;NO, MUST BE A DELETE
	PUSH	P,FILPPN	;[340] Save directory spec
	PUSHJ	P,ERDFSP	;YES, SO FILL IN ALL MISSING PARTS
	HRRZ	E,INFILE+1	;INCLUDING DATE STUFF- <000> NEEDS THIS
	HRRM	E,XFILNM+.RBEXT
	POP	P,(P)		;[340] Pop the stack
	SKIPN	1(P)		;[340] Was an explicit directory given?
	 SETZM	XFILNM+.RBPPN	;[340] No, don't move the file
	MOVE	E,INFILE+2
	TXNE	FF,F.PROT	;WAS A FILE PROTECTION SPECIFIED?
	TLZ	E,777000	;YES, SO CLEAR OLD PROTECTION
	IORM	E,XFILNM+.RBPRV	;STORE IT
RENAM1:	RENAME	INCHN,XFILNM	;CHANGE NAME OR DELETE
	JRST	RENFLD
	RELEASE	INCHN,
	POPJ	P,		;SUCCESSFUL
RENFLD:	RELEASE	INCHN,
	EE1+..ERROR E.RNF
	SUBTTL	E Commands -- ER (Prepare to Read a File)

OPNRD:	TXZ	FF,F.EOFI+F.IOPN	;NOT EOF & CLOSE PREVIOUS INPUT
	RELEAS	INCHN,0		;YES. RELEASE IT BEFORE OPENING NEW FILE.
	PUSHJ	P,CLREXT	;CLEAR LOOKUP BLOCK
	PUSHJ	P,FILSPC	;GET FILE SPEC
	SETZM	NFORMS		;HAVE NOT SEEN ANY FORM FEEDS YET
	SETZM	CURPAG		;[1024] Reset the current page number
	SETZM	OPNRI+.OPMOD	;ASCII MODE
	PUSHJ	P,ERDFSP	;NO SO SET UP DEFAULT FILE SPEC
	SKIPN	FILPPN		;IS PPN 0?
	MOVE	E,FILDEV	;INITIALIZE OPEN UUO ARGUMENTS
	MOVEM	E,OPNR1
	PUSHJ	P,DEVCHK	;GET DEVICE CHARACTERISTICS
	MOVEM	E,DEVSAV	;SAVE FOR EB
	JUMPE	E,ERRNXD	;NO SUCH DEVICE
	TXNE	E,DV.IN		;MUST BE ABLE TO INPUT
	TXNN	E,DV.M0		;IN ASCII MODE
	..ERROR	E.ILD
	MOVEI	E,IBUF
	MOVEM	E,OPNRB
	OPEN	INCHN,OPNRI	;OPEN INPUT FILE
	..ERROR	E.IDV
	PUSHJ	P,OPNIN
	HLLZS	XFILNM+.RBEXT	;CLEAR EXT RH FOR MON ERR ON DTA
	SKIPG	MONITR		;IF SERIES 3 OR 4 MONITOR, SHORT LOOKUP
	JRST	OPNRD1		;SHORT
	MOVE	E,DEVSAV	;GET DEVICE CHARACTERISTICS SPR 10-8431
	TXNE	E,DV.DTA	;IS IT A DECTAPE? SPR 10-8431
	JRST	OPNRD1		;YES, SHORT LOOKUP SPR 10-8431
IFN FT$TYM,<
	MOVE	E,FILPPN	;[JMS] Don't use SFD path pointers
	MOVEM	E,XFILNM+.RBPPN	;[JMS] TYMCOM-X needs PPN here
>  ;End of IFN FT$TYM
	LOOKUP	INCHN,XFILNM	;EXTENDED LOOKUP
	JRST	LKUPER		;ERROR
	JRST	OPNRD2
OPNRD1:	LOOKUP	INCHN,XFILNM+.RBNAM	;SHORT LOOKUP
	JRST	LKUPER		;LOOKUP FAILURE
OPNRD2:	PUSHJ	P,CHKSPC	;[340] Issue warning if found elsewhere
	MOVEI	E,INFILE	;SAVE INPUT SPECS
	PUSHJ	P,SPCSAV
	TXO	FF,F.IOPN	;INPUT FILE NOW OPEN
	MOVSI	E,FS.SUP!FS.NOL	;CK SUPLSN SWITCH
	AND	E,SWITC		;GET SETTING
	XORM	E,SWITC		;[317]CLEAR THEM HERE, SO NO SUPLSN ON OUTPUT
	MOVEM	E,INSWIT	;STORE SETTING FOR INPUT
	TXZ	FF,F.SEQ	;CLR SEQUENCE NUMBER FLAG
	IN	INCHN,		;READ A BUFFER IN
	JRST	.+3
	PUSHJ	P,ANERR		;SOME ERROR, OR JUST EOF
	JRST	OPNRD3		;IT WAS EOF-FILE EMPTY MEANS UNSEQUENCED
	MOVE	B,IBUF+.BFPTR	;GET ADR OF BUFR
	MOVE	A,1(B)		;FIRST WORD OF BUFR
	IOR	A,2(B)		;!2ND
	MOVEI	B,RI		;SLOW INPUT ROUTINE
	TLNN	E,FS.NOL	;NO LSN'S
	TRNN	A,1		;SEQF

				;Fall through to next page...
OPNRD3:	MOVEI	B,RIQ		;USE QUICK ONE
	MOVEM	B,INCH		;SET UP INPUT ROUTINE
	CAIN	B,RI		;SLOW?
	TXO	FF,F.SEQ	;THEN MUST BE SEQUENCED FILE
	TXNE	FF,F.EBTP	;[343] EB in progress?
	POPJ	P,		;[343] Yes, return
	MOVE	E,SWITC		;[1020] Get the switches
	TLNE	E,FS.YAN	;[1021] Skip if /YANK wasn't given
	JRST	[TXZ   FF,F.CCL		;[1021] Make sure F.CCL is zero
		 PJRST YANK]		;[1021]  and yank in a buffer
	TXZE	FF,F.CCL	;[1020] Skip if normal entry
	TLNE	E,FS.NOY	;[1020] Skip if /NOYANK wasn't given
	POPJ	P,		;[1020] Return
	PJRST	YANK		;[1020] Go get a buffer and return

OPNIN:	MOVEI	T,IBUF1		;GET INPUT BUFFERS
	EXCH	T,.JBFF
	INBUF	INCHN,NIBUF	;[1041] Get the input buffers
	MOVEM	T,.JBFF
	POPJ	P,
	SUBTTL	E Commands -- File Spec Setup

ERDFSP:	TDZA	A,A
EWDFSP:	MOVEI	A,12
EIDFSP:	MOVE	E,SWITC		;[337] Get file switches
	TLNN	E,FS.DEF	;[337] /DEFAULT set?
	JRST	DEFSP1		;[337] No, continue
	MOVSI	E,ERSPEC(A)	;[337] Yes, we must clear the block
	HRRI	E,ERSPEC+1(A)	;[337] Set up the BLT
	SETZM	ERSPEC(A)	;[337] Zero the block
	BLT	E,ERSPEC+11(A)	;[337]
DEFSP1:	SKIPN	E,XFILNM+.RBNAM	;HE TYPE A NAME?
	SKIPA	E,ERSPEC+1(A)	;[337] NO, GET DEFAULT
	MOVEM	E,ERSPEC+1(A)	;SAVE IT
	MOVEM	E,XFILNM+.RBNAM
	SKIPN	E,XFILNM+.RBEXT	;HE TYPE EXT?
	SKIPA	E,ERSPEC+2(A)	;[337] NO, GET DEFAULT
	MOVEM	E,ERSPEC+2(A)	;SAVE
	MOVEM	E,XFILNM+.RBEXT
	MOVSI	B,ERSPEC+4(A)	;SET UP PPN
	HRRI	B,FILPPN
	MOVS	I,B
	SKIPE	FILPPN
	JRST	DFSP1
	TXNE	F2,S.DPPN
	HRLI	B,DEFPTH+2	;HE WANTS [-]
	PUSHJ	P,CHKERZ	;CHECK FOR ERSATZ DEVICE
	HRLI	B,SPCPPN	;IT WAS ERSATZ--GET RIGHT PPN
	MOVE	E,B		;[317]SAVE BLT AC
	BLT	E,FILPPN+5	;[317]
	HRRI	B,SPCPPN	;PUT IT HERE TOO
	BLT	B,SPCPPN+5
	TXNE	F2,S.DPPN	;[340] Make [-] default, but not ersatz PPN
DFSP1:	BLT	I,ERSPEC+9(A)	;NOW MAKE IT THE NEW DEFAULT
	MOVE	E,FILPPN
	MOVEM	E,XFILNM+.RBSIZ	;FOR SHORT LOOKUPS AND ENTERS
	MOVEI	E,FILPTH	;[340] Get pointer to PATH block
	SKIPE	FILPPN		;[340] Does PATH block have something
	MOVEM	E,XFILNM+.RBPPN	;[340] Yes, point to it
	SKIPN	E,FILDEV	;HE TYPE A DEVICE?
	SKIPA	E,ERSPEC(A)	;[337] NO, GET DEFAULT
	MOVEM	E,ERSPEC(A)	;SAVE
	MOVEM	E,FILDEV
	POPJ	P,
	SUBTTL	E Commands -- EB (Edit Backup Processor)

EBAKUP:	TXNE	FF,F.UBAK	;BACKUP IN PROGRESS NOW?
	..ERROR	E.EBO
	TXO	FF,F.EBTP	;SET EB UUO FLAG
	PUSHJ	P,OPNRD		;READ THE SPECIFIED FILE
	MOVE	E,SWITC		;[343] Get I/O switches
	TLNE	E,FS.REA	;[343] /READONLY?
	JRST	EBAKU3		;[343] Yes, cancel EB and do an ER
	MOVE	E,DEVSAV	;GET DEVICE CHARACTERISTICS
	TXNN	E,DV.DIR	;DEVICE MUST HAVE DIRECTORY
	..ERROR	E.EBD
	TXNE	E,DV.DTA	;SKIP IF NOT DECTAPE (E.G. DSK) SPR 10-8431
	JRST	EBAKU4		;DO SHORT LOOKUP/ENTER. SPR 10-8431
	HLLZS	XFILNM+.RBEXT	;CLEAR EXT RH
	MOVE	E,SWITC		;GET FILE SWITCHES
	TLNN	E,FS.INP	;/INPLACE EDIT?
	JRST	EBAKU0		;NO
	TXZ	FF,F.EBTP	;NO LONGER EB
	MOVE	E,[FILPPN,,SPCPPN]	;[340] Save the real path
	BLT	E,SPCPPN+5	;[340] so EW goes to the right place
	JRST	EBAKU6		;DO ER/EW
EBAKU0:	MOVEI	E,INCHN
	PUSHJ	P,CHKDEF	;CHECK TO SEE IF SAME AS DEFAULT
	JRST	EBAKU2		;NOPE-JUST DO ER-EW
	MOVE	E,FILDEV	;SAVE DEVICE NAME
	SKIPG	MONITR		;SERIES 5 MONITOR?
	JRST	EBAKU5		;NO
	MOVE	E,XFILNM+.RBSIZ	;COMPUTE # BLKS TO ASK FOR
	LSH	E,-7
	AOJ	E,
	MOVEM	E,XFILNM+.RBEST	;SAVE
	MOVE	E,XFILNM+.RBDEV	;GET PHYSICAL UNIT NAME IN-FILE IS ON
	MOVEM	E,DCLOC		;DO A DSKCHR ON IT
	MOVE	E,[5,,DCLOC]
	DSKCHR	E,
EBAKU4:	SKIPA	E,FILDEV	;ERROR, USE BEST NAME WE HAVE
	MOVE	E,DCLOC+.DCSNM	;GET NAME FOR FILESTR IN-FILE IS ON
	MOVEM	E,FILDEV	;SO WE CAN PUT NEW FILE ON SAME STR

	PFALL	EBAKU5		;[1001] Fall through to next page...
EBAKU5:	MOVEM	E,EBDEV
	MOVE	E,XFILNM+.RBNAM	;SAVE FILENAME
	MOVEM	E,BAKNAM	;IN BACKUP STORE
	HLRZ	E,XFILNM+.RBEXT	;AND THE EXTENSION
	CAIN	E,(SIXBIT /BAK/)	;CANNOT USE EB WITH FILE EXT = "BAK"
	..ERROR	E.EBF
	HRLZM	E,BAKNAM+1
	LDB	E,[POINT 9,XFILNM+.RBPRV,8]	;SAVE PROTECTION OF INPUT FILE
	MOVEM	E,PROTEC	;SAVE INPUT FILE PROTECTION
	MOVEM	E,EBPROT	;[333] Also in 2 RENAME switch
	MOVE	A,E		;[333] Make full access CHKACC block
	HRLI	A,.ACREN	;[333] and check for enough privs to do it straight
	MOVE	AA,FILPPN	;[333] PPN of file owner
	MOVE	B,USRPPN	;[333] Our PPN

;    The CHKACC UUO returns 0 (OK) if FILDAE would be invoked, saying  "Go
; ahead,  the  file  daemon  will  catch you later".  Unfortunately FILDAE
; isn't invoked when the owner tries to rename a file protected at  <777>,
; the  resulting  protection  failure will really messes up EB.  Until the
; physical-only bit is noticed on CHKACC, make it illegal to do an  EB  on
; <6??>  and <7??>.  Files should be protected <4??> and <5??> when FILDAE
; is to be called.

	LSH	E,-^O6		;[2011] Look at the owner's code
	SKIPN	FDAEM		;[2011] Is FILDAE running?
	CAXGE	E,^O4		;[2011] No, 4 and 5 are illegal without FILDAE
	CAXLE	E,^O5		;[2011] 4 and 5 OK with FILDAE
	..ERROR	E.EBP		;[2011] 6 and 7 are always illegal
	MOVEI	E,A		;[333] Point to block
	CHKACC	E,		;[333] See
	  SETZ	E,		;[333] Assume ok
	JUMPE	E,EBAKU9	;[333] OK if OK
	HRROS	EBPROT		;[333] Flag that 2 RENAME's needed at close time
	HRLI	A,.ACCPR	;[333] See if we can change protection to reasonable
	MOVEI	E,A		;[333]
	CHKACC	E,		;[333] Try that
	  SETZ	E,		;[333] Assume OK now  (??)
	SKIPE	E		;[333] Yes, skip to see if we are supposed to write
	..ERROR	E.EBP		;[333] No, it's too protected
	HRLI	A,.ACWRI	;[333] Yes, can we write to it
	MOVEI	E,A		;[333]
	CHKACC	E,		;[333]
	  SETZ	E,		;[333] ?????
	JUMPE	E,EBAKU9	;[333] OK
	..ERROR	E.EBP		;[333] So sorry

EBAKU9:	MOVE	E,PROTEC	;[333] Get input file protection back
	SKIPE	A,SPCPRO
	LDB	E,[POINT 9,A,8]
	MOVEM	E,BAKPRO	;THIS IS THE DESIRED PROTECTION FOR THE NEW FILE
	MOVSI	E,100000	;MEANWHILE, USE <100> FOR .TMP FILE
	MOVEM	E,SPCPRO	;SO FINAL RENAME NEVER FAILS.
	MOVE	E,TMPTEC	;GET "###TEC"
	CAME	E,XFILNM+.RBNAM	;FILNAM=###TEC?
	JRST	EBAKU1		;NO, OK
	HLRZ	A,XFILNM+.RBEXT	;ALSO EXT="TMP"?
	CAIN	A,(SIXBIT /TMP/)	;EB###TEC.TMP ILLEGAL
	..ERROR	E.EBF
EBAKU1:	MOVEM	E,XFILNM+.RBNAM
	MOVEM	E,BAKTMP	;SAVE FOR DTA RENAME
	MOVSI	E,(SIXBIT /TMP/)
	MOVEM	E,XFILNM+.RBEXT
EBAKU6:	PUSHJ	P,OPNW4		;WRITE THE TMP FILE
	PUSHJ	P,OPNW2
	TXNE	FF,F.EBTP	;UNLESS NOT BACK-UP,
	TXO	FF,F.UBAK	;SET IN PROGRESS
EBAKU3:	MOVE	E,SWITC		;[1020] Get the switches
	TLNE	E,FS.YAN	;[1021] Skip if /YANK wasn't given
	JRST	[TXZ   FF,F.CCL		;[1021] Make sure F.CCL is zero
		 PJRST YANK]		;[1021]  and yank in a buffer
	TXZE	FF,F.CCL	;[1020] Skip if normal entry
	TLNE	E,FS.NOY	;[1020] Skip if /NOYANK wasn't given
	POPJ	P,		;[1020] Return
	PJRST	YANK		;[1020] Go get a buffer and return
EBAKU2:	TXZ	FF,F.EBTP	;NO LONGER AN EB
	SETZM	SPCPPN		;FAKE DEFAULT PATH
	HLLZS	XFILNM+.RBEXT	;RESTORE FILE SPECS
	MOVSI	E,(SIXBIT /DSK/)
	MOVEM	E,FILDEV	;MAKE SURE DSK AND NOT SOME ERSATZ.
	MOVEM	E,SPCDEV	;HERE TOO
	JRST	EBAKU6
	SUBTTL	E Commands -- I/O Error Routines

LKUPER:	RELEAS	INCHN,0
	TXZ	FF,F.IOPN	;LET GO OF INPUT DEVICE
	EE1+..ERROR E.FNF

;TYPE OUTPUT ERROR

ENTERR:	RELEAS	OUTCHN,0
	TXZ	FF,F.OOPN+F.UBAK	;LET GO OF OUTPUT DEVICE & EB FLAG
	LDB	E,[POINT 6,XFILNM+.RBEXT,35]	;ERROR CODE
	CAIE	E,2		;ERROR CODE 2?
	JRST	ENTER2		;NO
	MOVE	E,WRICHR	;GET DEVICE BITS
	TXNE	E,DV.DTA	;IF DTA ITS FULL, OTHERWISE ENTER ERROR
	..ERROR	E.FUL
ENTER2:	EE1+..ERROR E.ENT

LOOKIN:	RELEAS	INICHN,		;DON'T WANT CHANNEL ANYMORE
	TXZN	F2,S.INFO	;WE PUSH ANYTHING?
	POPJ	P,		;NO, DON'T WORRY
	EE1+..ERROR E.FNF
	SUBTTL	E Commands -- EW (Prepare to Write a File)

OPNWRA:	TXOA	F2,S.EA		;WE ARE GOING TO APPEND
OPNWR:	TXZ	F2,S.EA
	PUSHJ	P,OPNW1

OPNW2:	MOVE	E,WRICHR	;GET DEVCHR WORD
	TXNN	E,DV.DTA	;DECTAPE?
	SKIPG	MONITR		;OR OLD MONITOR
	JRST	SHRTLK		;SHORT LOOKUP - ENTER
	TXNN	E,DV.DSK	;A DSK?
	JRST	SHRTLK		;NO, NO NEED FOR EXTENDED LOOKUP - ENTER
	SETO	B,		;SET FOR FANCY DISK ALLOCATION
	MOVEI	E,FILPTH	;[340] Make sure path pointer is set
	MOVEM	E,XFILNM+.RBPPN	;[340]
	TXNE	FF,F.EBTP	;THIS AN EB TEMP FILE ENTER?
	JRST	XENTER		;YES, CARE NOT OF SUPERCEDE
	PUSHJ	P,PPNSET	;SET UP DEFAULT, IF NECESSARY
	AOS	FILPTH+1	;NO SCANNING
IFN FT$TYM,<
	MOVE	E,FILPPN	;[JMS] Don't use SFD path pointers
	MOVEM	E,XFILNM+.RBPPN	;[JMS] TYMCOM-X needs PPN here
>  ;End of IFN FT$TYM
	LOOKUP	OUTCHN,XFILNM	;FILE THERE?
	JRST	XENTER		;NO, JUST ENTER IT
	MOVE	B,FILPPN	;SAVE PPN
	PUSHJ	P,PPNSET	;RESET PPN
	TXNE	F2,S.EA		;APPENDING?
	JRST	XENTRE		;YES, DON'T SCREW UP PROT/DATE
	CLOSE	OUTCHN,		;NO, CLOSE FOR SUPERCEDE
XENTER:	SETZM	XFILNM+.RBPRV	;CREATION DATE NOW
	HLLZS	XFILNM+.RBEXT	;...
	MOVE 	E,SPCPRO	;NOW SET UP RIGHT PROT.
	TRNE	E,1		;IF <000>, MAKE IT <100>
	TLO	E,100000
	HLLZM	E,XFILNM+.RBPRV
XENTRE:	SETZM	XFILNM+.RBALC	;CLEAR ALLOCATION
IFN FT$TYM,<
	MOVE	E,FILPPN	;[JMS] Don't use SFD path pointers
	MOVEM	E,XFILNM+.RBPPN	;[JMS] TYMCOM-X needs PPN here
>  ;End of IFN FT$TYM
	ENTER	OUTCHN,XFILNM	;ENTER THE FILE
	JRST	ENTERR		;???
	JUMPL	B,OPNW5		;[320] -1 MEANS LOOKUP FAILED, SO SKIP ALL THIS
	CAMN	B,FILPPN	;FILE IN SAME AREA?
	PUSHJ	P,SUPERC	;YES, THEN SUPERCEDING
	TXNE	F2,S.EA		;TO APPEND?
	USETI	OUTCHN,-1	;YES, TELL GOD



OPNW5:	MOVEI	T,OBUF1		;WHERE OUTPUT BUFFERS MUST BE
	EXCH	T,.JBFF		;TELL MONITOR TO PUT THEM THERE
	OUTBUF	OUTCHN,NOBUF	;[1041] Get the output buffers
	MOVEM	T,.JBFF		;AND RESTORE JOBFF
	MOVEI	E,OUTFIL	;SAVE FILESPEC
	PUSHJ	P,SPCSAV
	MOVSI	E,FS.GEN+FS.SUP	;GET OUTPUT FS.GEN & FS.SUP SWITCHES
	AND	E,SWITC
	MOVE	T,INSWIT	;[317]GET INPUT SWITCHES
	MOVEI	B,PPAQ		;ASSUME QUICK ROUTINE
	TLNE	E,FS.GEN	;[317]MUST GENERATE LSN'S?
	MOVEI	B,PPA		;= USE SLOW ONE
	TXNE	FF,F.SEQ	;[317]SEQUENCED FILE?
	TLNE	T,FS.SUP	;[317]YES, BUT IS INPUT SUPPRESSING THEM?
	SKIPA			;[317]BUFFER WILL NOT HAVE SEQUENCE NUMBERS
	MOVEI	B,PPA		;[317]USE SLOW ROUTINE
	MOVEM	B,OUTCH		;SAVE IT
	TXO	FF,F.OOPN	;OUTPUT FILE NOW OPEN
	TLNE	E,FS.GEN	;ARE BOTH SET?
	TLNN	E,FS.SUP
	JRST	.+2		;NO, OK
	..ERROR	E.COS
	MOVEM	E,OUTSWT	;STORE OUTPUT SWITCH
	MOVE	E,[<"00000">B34+1]	;INIT LSN GENERATION CTR
	MOVEM	E,LSNCTR
	POPJ	P,

DEVICL:	MOVE	E,OPNWI+.OPDEV	;DEVICE NAME
	DEVCHR	E,		;WHAT IS IT
	CAIN	E,0
ERRNXD:	..ERROR E.NXD
	TXNE	E,DV.OUT	;MUST BE CAPABLE OF OUTPUT
	TXNN	E,DV.M0		;IN ASCII MODE
	..ERROR	E.ILD
	POPJ	P,
OPNW1:	TXZE	FF,F.UBAK
	TXZA	FF,F.OOPN
	SKIPA
	CLOSE	OUTCHN,CL.RST
	PUSHJ	P,FILSPC
	PUSHJ	P,EWDFSP	;SET UP DEFAULTS
	MOVE	E,SWITC		;[343] Get I/O switches
	TLNE	E,FS.APP	;[343] /APPEND?
	TXO	F2,S.EA		;[343] Yes, set append flag
	SKIPE	E,FILDEV	;DO WE HAVE A DEVICE?
	JRST	OPNW11		;YES
	MOVE	E,ERSPEC	;NO, GET ER'S
	MOVE	T,[XWD 3,E]	;CHECK IF ITS ERSATZ
	PATH.	T,
	TRNE	E+1,40		;WELL?
	MOVSI	E,'DSK'		;IT IS ERSATZ...SO MAKE IT DSK:
OPNW11:	MOVEM	E,FILDEV	;STORE DEVICE
	MOVEM	E,SPCDEV	;HERE TOO
	SKIPN	E,XFILNM+.RBNAM	;HAVE A NAME?
	MOVE	E,ERSPEC+1	;USE ER'S NAME IF NOT
	MOVEM	E,XFILNM+.RBNAM	;SAVE IT
	SKIPN	E,XFILNM+.RBEXT	;GET EXT?
	MOVE	E,ERSPEC+2	;NO, USE ER'S
	HLLZM	E,XFILNM+.RBEXT
	MOVSI	B,(SIXBIT /SFD/)	;CHECK FOR AN .SFD FILE
	CAMN 	B,XFILNM+.RBEXT
	JRST	OPNW4		;IS AN .SFD, DONT GET DEFAULT PROT.
	SKIPE	E,SPCPRO	;WAS A PROTECTION SPECIFIED?
	JRST	OPNW1A		;YES, GO MAKE IT THE DEFAULT
	TXNN	F2,S.EA		;IF WE ARE DOING AN EA,
	SKIPN	E,EWSPEC+3	;OR IF NO PREVIOUS DEFAULT
	JRST	OPNW4		;THEN DONT FIDDLE WITH ANYTHING
	MOVEM	E,SPCPRO	;MAKE DEFAULT PROT THE CURRENT PROT
OPNW1A:	MOVEM	E,EWSPEC+3	;AND THE NEW DEFAULT
	TXO	FF,F.PROT	;AND SAY WE'VE GOT ONE
	PFALL	OPNW4		;[1001] Fall through

OPNW4:	TXZE	FF,F.OOPN	;CALL HERE FROM EB
	RENAME	OUTCHN,OUTFIL
	  JFCL			;CANT HAPPEN
	RELEAS	OUTCHN,0
	SETZM	OPNWI+.OPMOD
	MOVE	E,FILDEV
	MOVEM	E,OPNWD
	PUSHJ	P,DEVCHK	;GET DEVICE CHARACTERISTICS
	MOVEM	E,WRICHR
	MOVSI	E,OBF
	MOVEM	E,OPNWB
	PUSHJ	P,DEVICL	;LEGAL DEVICE?
	OPEN	OUTCHN,OPNWI
	..ERROR	E.ODV
	MOVEI	B,"A"
IFE FT$TYM,<IF2,<PRINTX [DEVTYP uuo not implemented, in OPNW4 routine]>
	MOVEI	E,OUTCHN
	DEVTYP	E,		;TYPE OF DEVICE
	JRST	OILDER
	TXNE	F2,S.EA		;EDIT APPEND (IE DSK ONLY)?
	TRNN	E,77		;.TYDSK?
	SKIPA
	JRST	OILDER
>  ;End of IFE FT$TYM
	MOVEI	T,OBUF1
	EXCH	T,.JBFF
	OUTBUF	OUTCHN,NOBUF	;[1041] Get the output buffers
	MOVEM	T,.JBFF
	POPJ	P,
OILDER:	RELEAS	OUTCHN,
	..ERROR	E.ILD

	SUBTTL	E Commands -- EZ & EF

;GET I-O DEVICE CHARACTERISTICS IN AC E
;IF TTY, IT MUST BE AVAILABLE & NOT CONTROLLING A JOB

DEVCHK:	DEVCHR	E,		;GET CHARACTERISTICS
	TXNN	E,DV.TTY	;TTY?
	POPJ	P,		;NO
	TXNE	E,DV.AVL	;YES, AVAILABLE?
	TXNE	E,DV.TTA	;CONTROLLING A JOB (INCLUDING USER)?
	..ERROR	E.TTY
	POPJ	P,		;NO, IT'S OK

;EZ	SELECTS THE OUTPUT DEVICE, ISSUES A REWIND COMMAND TO IT,
;	ISSUES A COMMAND TO ZERO ITS DIRECTORY, AND OPENS THE FILE
;	SPECIFIED (IF ANY).

ZERDIR:	PUSHJ	P,OPNW1		;DETERMINE OUTPUT DEVICE
	UTPCLR	OUTCHN,		;CLEAR DIRECTORY OF OUTPUT DEVICE
	MTAPE	OUTCHN,1	;REWIND OUTPUT DEVICE
	JRST	OPNW2		;ENTER FILE




;EF	FINISHES OUTPUT ON THE CURRENT OUTPUT FILE WITHOUT
;	SELECTING A NEW OUTPUT FILE.

CLOSEF:	TXZE	FF,F.COLN	;[1024] Skip if the colon wasn't supplied
	JRST	XFLAG		;[1024] Go do something with the flags
CLOSE0:	TXNN	FF,F.OOPN	;[1024]
	POPJ	P,
	CLOSE	OUTCHN,CL.IN
	STATZ	OUTCHN,IO.ERR
	JRST	OUTERR
	TXNE	FF,F.UBAK	;EB IN PROGRESS?
	PUSHJ	P,BAKCLS	;YES (THIS WILL SKIP RETURN)
	RENAME	OUTCHN,OUTFIL	;IF NOT EB, THEN RENAME FOR PROTECTION
	  JFCL			;CANT HAPPEN
	RELEAS	OUTCHN,0
	TXZ	FF,F.UBAK!F.OOPN	;CLEAR WRITE AND EB FLAGS
	POPJ	P,


; :nEF	Set the Extended Flags as follows, these values may be or'ed
;	together:
;	  If n=1:  Set 'Truth-in-Paging' mode.
;	  If n=2:  Set the page number output before the prompt.
;	  If n=4:  Disable the immediate mode commands.
;	  If n=8:  No warning/information message (don't say "[TECXPN
;		   nK core]").
; :EF	Return the Extended Flags as a value.

XFLAG:	TXNN	FF,F.ARG	;[1024] Skip a value was supplied
	JRST	XFLAG1		;[1024] Get return the current flags
	MOVEM	B,XFLAGS	;[1024] Save the extended flags
	POPJ	P,		;[1024] Return

XFLAG1:	POP	P,CH		;[1024] Clear the return address
	MOVE	A,XFLAGS	;[1024] Get the extended flags
	JRST	VALRET		;[1024] Return the value
	SUBTTL	E Commands -- EM (MTAPE UUO's)

EMTAPE:	TXNN	FF,F.IOPN
	ERROR	E.EMD
	MOVE	E,OPNR1		;SET UP INPUT DEVICE NAME
	MOVEM	E,FILDEV	;IN CASE OF AN ERROR
	PUSHJ	P,CHK2
	CAIGE	B,1
	ERROR	E.EMA
	MTAPE	INCHN,0(B)
	OPEN	INCHN,OPNRI	;RE-INIT BUFFERS
	ERROR	E.IEM
	PJRST	OPNIN
	SUBTTL	E Commands -- EB (Finish Up Command)

;THIS ROUTINE IS CALLED AT EF IF AN EB WAS DONE. IT DOES
;THE WORK OF MAKING THE INPUT FILE HAVE THE EXTENSION .BAK ,
;DELETING ANY PREVIOUS FILE.BAK, AND RENAMING THE NEW OUTPUT
;FILE AS THE ORIGINAL FILE.EXT

BAKCLS:	CLOSE	INCHN,0
	MOVE	E,EBDEV		;ORIGINAL EB DEVICE
	MOVEM	E,FILDEV	;IN CASE OF AN ERROR
	TXZN	FF,F.IOPN	;INPUT OPEN?
	JRST	BKCLS4		;NO
	CAMN	E,OPNR1		;ORIGINAL SAME AS CURRENT?
	JRST	BKCLS2		;YES
BKCLS4:	MOVEM	E,OPNR1		;NO, RE-OPEN ORIGINAL
	MOVE	E,WRICHR	;GET DEVICE CHARACTERISITECS
	TXNN	E,DV.DSK	;IS IT DISK ?
	 JRST	BKCLS6		;NO - JUST DO NORMAL OPEN
	MOVX	E,UU.PHS	;YES - DO PHYS ONLY OPEN
	IORM	E,OPNRI+.OPMOD	;. . .
BKCLS6:	MOVEI	E,<E.IRN=='IRN'>	;SETUP ERROR CODE
	OPEN	INCHN,OPNRI
	JRST	BKCERR		;ERROR ROUTINE
BKCLS2:	MOVE	E,BAKNAM
	MOVEM	E,XFILNM+.RBNAM
	MOVSI	E,(SIXBIT /BAK/)
	MOVEM	E,XFILNM+.RBEXT
	MOVE	E,WRICHR	;[353] Get device characteristics
	TXNE	E,DV.DTA	;[353] DEC-tape?
	JRST	BKCLSD		;[353] Yes
	MOVEI	E,FILPTH	;[353] Set up path pointer
	MOVEM	E,XFILNM+.RBPPN	;[353]
	PUSHJ	P,PPNDEF	;[353] Set default path
	AOS	FILPTH+1	;[353] No scanning!
	MOVE	B,PROTEC	;GET PROTECTION OF INPUT FILE
	SKIPN	FDAEM		;[333] See what protection we want file to be
	TRZN	B,700		;[333] No FILDAE, make owner protection 0
	TRZ	B,300		;[333] FILDAE, leave 400 on if it is
IFN FT$TYM,<
	MOVE	E,FILPPN	;[JMS] Don't use SFD path pointers
	MOVEM	E,XFILNM+.RBPPN	;[JMS] TYMCOM-X needs PPN here
>  ;End of IFN FT$TYM
BP1:	LOOKUP	INCHN,XFILNM	;[353]
	JRST	BKCLS0		;[333] .BAK file not there or protection failure
	LDB	B,[$POINT (XFILNM+.RBPRV,RB.PRV)]  ;[1001] Get protection of backup file
	SETZM	XFILNM+.RBNAM
	MOVEI	E,<E.BAK=='BAK'>	;ERROR CODE IN CASE WE NEED IT
BP2:	RENAME	INCHN,XFILNM	;[353]
	JRST	BKCERR		;ERROR
	JRST	BKCLS1		;[333] Now go rename original file to .BAK

;[353] Here to do short LOOKUP on DEC-tapes
BKCLSD:	LOOKUP	INCHN,XFILNM+.RBNAM	;[353] Short LOOKUP for DTA
	  JRST	BKCLS1		;[353] None, assume not there
	SETZM	XFILNM+.RBNAM	;[353] Zero the file name
	RENAME	INCHN,XFILNM+.RBNAM	;[353] Delete
	  JRST	BKCERR		;[353] Most strange
	JRST	BKCLS1		;[353] Move on

;Here when LOOKUP on .BAK file fails
BKCLS0:	HRRZ	E,XFILNM+.RBEXT	;[333] Get error code
	JUMPE	E,BKCLS1	;[333] 0 means not found, so we're OK
	MOVEI	E,<E.BFL=='BFL'>;[333] Otherwise, load error code
	JRST	BKCERR		;[333] Can't LOOKUP existing .BAK file

BKCLS1:	MOVE	E,BAKNAM
	MOVEM	E,XFILNM+.RBNAM
	HLLZ	E,BAKNAM+1
	MOVEM	E,XFILNM+.RBEXT
	MOVE	E,WRICHR	;[353] Get device characteristics
	TXNE	E,DV.DTA	;[353] DEC-tape?
	JRST	BKCLD1		;[353] Yes
	MOVEI	E,FILPTH	;[353] Set up default path again
	MOVEM	E,XFILNM+.RBPPN	;[353] (May have gotten wiped)
	PUSHJ	P,PPNDEF	;[353]
	AOS	FILPTH+1	;[353] No scanning
IFN FT$TYM,<
	MOVE	E,FILPPN	;[JMS] Don't use SFD path pointers
	MOVEM	E,XFILNM+.RBPPN	;[JMS] TYMCOM-X needs PPN here
>  ;End of IFN FT$TYM
	MOVEI	E,<E.ILR=='ILR'>	;ERROR CODE
BP3:	LOOKUP	INCHN,XFILNM	;[353]
	JRST	BKCERR		;ERROR
	SKIPG	MONITR		;SERIES 5?
	JRST	BKCLS5		;NO
	SKIPL	EBPROT		;[333] Need to do 2 RENAMEs due to protection?
	JRST	BKCLS5		;[333] No, skip this bother
	MOVE	E,PROTEC	;GET PROT OF INPUT FILE
;When we arrive at this point, we know the protection must be
;<2xx>, the only one which requires a double rename but still
;allows us to edit at all.
	XORI	E,300		;THEN RENAME IT TO 100 RANGE --
	DPB	E,[$POINT (XFILNM+.RBPRV,RB.PRV)]  ;[1001] So we can do the real rename to .BAK
	MOVEI	E,<E.IRB=='IRB'>	;ERROR
	RENAME	INCHN,XFILNM	;[353]
	JRST	BKCERR		;ERROR

BKCLS5:	MOVSI	E,(SIXBIT /BAK/)
	HLLM	E,XFILNM+.RBEXT	;DATE75
	DPB	B,[$POINT (XFILNM+.RBPRV,RB.PRV)]  ;[1001] Give BAK file same prot as old BAK
BP4:	RENAME	INCHN,XFILNM	;[353]
	  TRNA			;[333] Try to recover
	JRST	BKCLS8		;[333] Now go rename the .TMP file

;Here when renaming file to file.BAK with a lower protection fails.
;We will try again, this time keeping the protection the same.

	LDB	E,[POINT 15,XFILNM+.RBEXT,35]	;[333] Get error code
	CAIE	E,ERPRT%	;[333] Protection failure?
	  JRST	BKCLS7		;[333] No, complete loss
	HLLZ	E,BAKNAM+1	;[333] Retrieve original extension
	MOVEM	E,XFILNM+.RBEXT	;[333] Store
	MOVEI	E,<E.ILR=='ILR'>;[333] Setup error code
	LOOKUP	INCHN,XFILNM	;[353][333] Lookup old source again
	  JRST	BKCERR		;[333] Most strange
	MOVSI	E,'BAK'		;[333] New extension
	HLLM	E,XFILNM+.RBEXT	;[333] Change only extension
	RENAME	INCHN,XFILNM	;[353][333] Try the rename again
	  TRNA			;[333] It's hopeless
	JRST	BKCLS8		;[333] Good, now go rename .TMP file

BKCLS7:	MOVEI	E,'IRB'		;[333] Set error code
	JRST	BKCERR		;[333] Go issue message
;Here to rename original file to .BAK on a DEC-tape

BKCLD1:	MOVEI	E,<E.ILR=='ILR'>	;[353] Set up error code
	LOOKUP	INCHN,XFILNM+.RBNAM	;[353] Lookup original file
	  JRST	BKCERR			;[353] Curious
	MOVSI	E,'BAK'			;[353] New extension
	HLLM	E,XFILNM+.RBEXT		;[353] Store it
	RENAME	INCHN,XFILNM+.RBEXT	;[353] Change the name to .BAK
	  JRST	BKCLS7			;[353] Sigh
	PFALL	BKCLS8			;[1001] Fall thru...


;Here to rename .TMP file to new source file

BKCLS8:	RELEAS	INCHN,		;[353] Make sure input device finished
	MOVE	E,WRICHR	;[353] GET OUTPUT DEVICE CHARCATERISTICS
	TXNN	E,DV.DTA	;DECTAPE?
	JRST	BKCLS3		;NO
	MOVEI	E,<E.OLR=='OLR'>	;ERROR CODE
	LOOKUP	OUTCHN,OUTFIL	;DECTAPE, 4&5 SERIES MONITORS NEED EXTRA LOOKUP
	JRST	BKCERR		;ERROR
	CLOSE	OUTCHN,2	;CLOSE OUTPUT FOR RENAME
BKCLS3:	MOVE	E,BAKNAM	;RENAME ###TEC.TMP TO ORIGINAL NAME
	MOVEM	E,XFILNM+.RBNAM
	HLLZ	E,BAKNAM+1
	MOVEM	E,XFILNM+.RBEXT
	MOVE	E,BAKPRO	;GET PROTECTION WE WANTED
	SETZM	XFILNM+.RBPRV
	DPB	E,[$POINT (XFILNM+.RBPRV,RB.PRV)]  ;[1001] Put it in
	SETZM	XFILNM+.RBSIZ
	MOVEI	E,<E.RNO=='RNO'>	;ERROR CODE
BP5:	RENAME	OUTCHN,XFILNM+.RBNAM
	JRST	BKCERR		;ERROR
	JRST	CPOPJ1		;DO A SKIP RETURN


;ERROR ROUTINE TO MAKE SURE THE .TMP FILE GETS CLOSED WITH THE CORRECT
;PROTECTION

BKCERR:	MOVE	B,BAKPRO	;GET INTENDED PROTECTION.
	DPB	B,[POINT 9,OUTFIL+2,8]	;DEPOSIT IT
	RENAME	OUTCHN,OUTFIL	;PUT IN THE RIGHT ONE
	JFCL			;TOO BAD!! WE'VE ALREADY GOT ONE ERROR ON
				;OUR HANDS! WE TRIED.
	CAIE	E,'IRN'		;UNLESS ITS THE IRN ERROR,
	TLO	E,400		;FLAG THE UUO ERROR CODE TYPE OUT
	TLO	E,001000	;FINISH BUILDING THE ERROR UUO
	XCT	E		;DO IT!

	SUBTTL	E Commands -- EW (Subroutines for EW)

SHRTLK:	LOOKUP	OUTCHN,XFILNM+.RBNAM	;FILE THERE?
	JRST	SHRTOK		;NO, ENTER IT
	PUSHJ	P,SUPERC	;SAY SUPERCEDING MAYBE
	TXNE	F2,S.EA		;TO APPEND IS AN ERROR
	JRST	OILDER
SHRTOK:	CLOSE	OUTCHN,		;CLOSE FOR NO UPDATING
	MOVE	A,FILPPN	;GET THE FILE PPN BACK
	MOVEM	A,XFILNM+.RBSIZ	;SAVE IT
SHRTEN:	ENTER	OUTCHN,XFILNM+.RBNAM	;AND ENTER THE FILE
	JRST	ENTERR		;TOUGH COKIES
	JRST	OPNW5		;FIX BUFFERS, SWITCHES ETC.


SUPERC:	MOVE	E,WRICHR	;GET DEVICE CHARACTERISTICS
	TXNN	FF,F.EBTP	;TEMP FILE ENTER?
	TXNN	E,DV.DIR	;MUST BE DIRECTORY DEVICE
	POPJ	P,		;ELSE DO NOTHING
	MOVE	E,SWITC		;[351] Get I/O switches
	TLNN	E,FS.INP	;[351] /INPLACE?
	TXNE	F2,S.EA		;OR APPENDING?
	POPJ	P,		;YES, RETURN
	JSP	A,CONMES	;[1025] Type %TECSEF Superseding ...
	ASCIZ	~%TECSEF Superseding existing file
~
	POPJ	P,

	SUBTTL	E Commands -- Miscellaneous Routines

CLREXT:	MOVE	E,[XFILNM+1,,XFILNM+2]	;CLR EXTENDED LOOKUP ARG BLK
	SETZM	XFILNM+1
	BLT	E,SPCPRO
	MOVEI	E,16
	MOVEM	E,XFILNM
	POPJ	P,
;ROUTINE TO CHECK WHETHER THE PATH FILE WAS FOUND ON WAS THE ONE WE
;WANTED TO FIND IT ON.

CHKPTH:	MOVE	T,[SPCPPN(E)]	;WE WANT TO CHECK SPECIFIED PATH
	SKIPN	SPCPPN		;UNLESS ITS 0, IN WHICH CASE...
CHKDEF:	MOVE	T,[DEFPTH+2(E)]	;CHECK AGAINST DEFAULT PATH
	MOVEM	E,FILPTH
	MOVE	E,[11,,FILPTH]
	PATH.	E,
	JFCL			;Could be because PATH. works but SFDs don't
	SKIPN	FILPTH+2	;[JMS] See if PATH. set at least PPN
	 JRST	CPOPJ1		;[JMS] PATH. uuo not implemented, assume OK
	MOVSI	E,-6		;CHECK FOR INTENDED PATH
	MOVE	A,@T
	CAME	A,FILPPN(E)
	POPJ	P,		;NOT EQUAL
	AOBJN	E,.-3
	JRST	CPOPJ1		;EQUAL, SKIP RETURN

PPNSET:	SKIPN	SPCPPN		;WAS A PATH SPECIFIED?
	PUSHJ	P,CHKERZ	;NO, CHECK FOR ERSATZ DEVICE
	  JFCL
PPNSPC:	MOVE	E,[SPCPPN,,FILPTH+2]	;SET UP DIRECTORY PATH
	SKIPN	SPCPPN		;DEFAULT IF NOT SPECIFIED
PPNDEF:	MOVE	E,[DEFPTH+2,,FILPTH+2]	;ENTER HERE FOR DEFAULT PATH
	BLT	E,FILPTH+7
	SETZM	FILPTH+1	;ZERO THE SCAN SWITCH
	POPJ	P,


SPCSAV:	MOVE	A,E		;ROUTINE TO SAVE A FILESPEC
	HRLI	A,XFILNM+.RBNAM
	BLT	A,2(E)
	SETZM	3(E)
	MOVE	A,SPCPRO	;PUT CORRECT PROTECTION IN
	ROT	A,11		;POSITION IT
	TXNE	FF,F.PROT	;IF SPECIFIED
	DPB	A,[POINT 9,2(E),8]
	POPJ	P,

;ROUTINE TO CHECK FOR AN ERSATZ DEVICE

CHKERZ:	SKIPN	SPCDEV		;WAS DEVICE SPECIFIED?
	JRST	CPOPJ1		;NO, SKIP RETURN
	MOVE	E,[11,,SPCDEV]	;SET UP PATH.
	PATH.	E,
	  JRST	CPOPJ1		;PATH. FAILED, ASSUME NOT ERSATZ
	MOVE	E,SPCDEV+.PTSWT	;GET SCAN BITS
	TXNN	E,PT.IPP	;IS IT AN ERSATZ DEVICE?
	JRST	CPOPJ1		;NO, SKIP RETURN
	SETZM	SPCPPN+1	;YES, DO THE MONITORS JOB--WE DONT WANT SFDS
	POPJ	P,		;RETURN


;***[340]***
;ROUTINE TO ISSUE WARNING MESSAGE IF FILE NOT FOUND ON
;SPECIFIED DIRECTORY.

CHKSPC:	MOVEI	E,INCHN		;Set up input channel for PATH. UUO
	PUSHJ	P,CHKPTH	;See if file found on specified path
	TXNE	FF,F.COLN	;If : specified, no warning.
	POPJ	P,		;Yes, return
	JSP	A,CONMES	;[1025] Type a warning
	ASCIZ	~%TECFFI File found in [~
	HLRZ	B,FILPPN	;Type PPN
	PUSHJ	P,OCTMS
	MOVEI	CH,","
	PUSHJ	P,TYOM
	HRRZ	B,FILPPN
	PUSHJ	P,OCTMS
	MOVE	TT1,[-5,,FILSFD]	;Type SFD's
CHKSP1:	SKIPN	TT,(TT1)	;End of list?
	JRST	CHKSP2		;Yes
	MOVEI	CH,","		;No, type another comma
	PUSHJ	P,TYOM
	PUSHJ	P,SIXBMS	;And SFD
	AOBJN	TT1,CHKSP1	;Loop
CHKSP2:	JSP	A,CONMES	;Finish message
	ASCIZ	/]
/
	POPJ	P,
	SUBTTL	^V, ^W and ^X Commands

;^V COMMAND

LOWCAS:	TXNE	FF,F.ARG	;ARG SEEN?
	JUMPE	B,CLRCAS	;YES, IF 0 CLEAR ALL PREVAILING CASE FLAGS
	TXZ	F2,S.UCAS	;CLEAR ^W FLAG
	TXO	F2,S.LCAS	;& SET ^V FLAG
	JRST	RET

;^W COMMAND

STDCAS:	TXNE	FF,F.ARG	;ARG SEEN?
	JUMPE	B,CLRCAS	;YES, IF 0 CLEAR ALL PREVAILING CASE FLAGS
	TXZ	F2,S.LCAS	;CLEAR ^V FLAG
	TXOA	F2,S.UCAS	;& SET ^W FLAG

CLRCAS:	TXZ	F2,S.LCAS+S.UCAS	;0^V OR 0^W CLEARS BOTH FLAGS
	JRST	RET

;^X COMMAND

SETMCH:	TXNE	FF,F.ARG	;ANY ARGUMENT?
	JRST	SETMC1		;YES
	TXNE	FF,F.PMAT	;NO, FORCED EXACT MATCH FLAG ON?
	JRST	FFOK		;YES, RETURN -1
	JRST	BEGIN		;NO, RETURN 0

SETMC1:	TXZ	FF,F.PMAT	;CLR ^X FLAG
	JUMPE	B,RET		;IF ARG = 0, FLAG = 0
	TXO	FF,F.PMAT	;OTHERWISE, SET FLAG
	JRST	RET
	SUBTTL	Routine to Parse File Designator

FILSPC:	HRROS	EATCH		;IF THIS COMMAND FAILS, U MUST EAT TIL ALT
	PUSHJ	P,CLREXT	;CLEAR EXTENDED ARG BLOCK
	SETZM	SWITC
	MOVNI	A,5		;INITIALIZE SFD COUNTER
	MOVEM	A,PTHCNT
	MOVEI	A,1		;INITIALIZE STATE TO 1
	PUSHJ	P,ENDPUT	;INIT PACKING WORDS
	TXZ	FF,F.FILE!F.PROT	;BUT WE HAVEN'T SEEN ANY PART OF FILESPEC YET

FILSP1:	PUSH	P,A		;SAVE OUR STATE!
	PUSHJ	P,FILCHR	;GET A CHAR
	POP	P,A		;RESTORE THE DAMN THING
	ASH	A,1		;A HAS CURRENT STATE
	CAIG	B,6		;B HAS CHAR TYPE
	JRST	FILSP2
	SUBI	B,6		;MUNG FOR OFFSET
	AOS	A
FILSP2:	IMULI	B,6
	MOVE	T,STPROC-2(A)	;GET PROCEDURE
	ROT	T,(B)
	ANDI	T,77		;T NOW HAS PROC. NUM.
	PUSHJ	P,@FILPRO-1(T)	;DO IT
	MOVE	A,STNEXT-2(A)	;GET NEXT STATE
	ROT	A,(B)
	ANDI	A,77
	CAIE	A,^D15		;IF STATE=15, WE'RE DONE
	JRST	FILSP1
	POPJ	P,

FILCHR:	PUSHJ	P,SKRCH		;GET A CHAR.
	ERROR	E.UFS
	CAIL	CH,.CHLFD	;< LF OR
	CAILE	CH,.CHCRT	;> CR
	JRST	TOUP		;OK SO FAR
	JRST	FILCHR		;IGNORE LF,FF,CR,VT
TOUP:	CAIL	CH,"A"+" "	;CONVERT LOWER CASE
	CAILE	CH,"Z"+" "
	SKIPA
	TXC	CH," "
	MOVEI	T,FILDSP	;NOW WE CLASSIFY THE CHARACTER
FILCH1:	MOVE	B,(T)
	JUMPE	B,FILCH2
	CAIE	CH,(B)
	AOJA	T,FILCH1
	HLRZS	B
	POPJ	P,
FILCH2:	PUSHJ	P,CKSYM		;IS IT A-Z, 0-9, %, $?
	SKIPA	B,[1]		;YES
	MOVEI	B,^D12		;NO, MUST BE OTHER
	CAIL	CH,"0"		;BUT MIGHT BE OCTAL
	CAILE	CH,"7"		;...
	POPJ	P,		;NOPE
	AOJA	B,CPOPJ		;YES, B=2

PAKSIX:	SUBI	CH," "		;CONVERT TO SIXBIT
	TLNE	OU,770K		;IS THERE STILL ROOM?
	IDPB	CH,OU		;YES, PACK IT
	TLNE	E,7700		;SHIFT MASK?
	ASH	I,-6		;YES
	POPJ	P,

PAKOCT:	LSH	E,3		;STANDARD NUMBER PACKING
	IORI	E,-"0"(CH)
	POPJ	P,

PUTDEV:	JUMPE	E,ENDPUT	;DONT STORE NULL DEVICE
	SKIPE	FILDEV		;ALREADY GOT ONE?
	..ERROR	E.DDV		;YEP
	MOVEM	E,FILDEV	;STORE IT
	MOVEM	E,SPCDEV	;HERE TOO
	JRST	ENDPUT

PUTFIL:	JUMPE	E,ENDPU1	;DON'T SAVE NULL FILE NAMES
	SKIPE	XFILNM+.RBNAM	;DOUBLE FILE NAME?
	..ERROR	E.DFN
	MOVEM	E,XFILNM+.RBNAM	;SAVE IT
	JRST	ENDPUT		;GO RESET PACKING


PUTEXT:	IORI	E,1		;SAID .<NULL> SO REMEMBER NOT TO DEFAULT
	SKIPE	XFILNM+.RBEXT	;DOUBLE EXT ILLEGAL
	..ERROR	E.DEX
	MOVEM	E,XFILNM+.RBEXT	;STORE IT
	JRST	ENDPUT

PUTPRO:	SKIPE	XFILNM+.RBPRV	;DOUBLE PROTECTION LOSES
	..ERROR	E.DPR
	CAILE	E,777		;IS IT A LEGAL PROTECTION
	..ERROR	E.PRO		;NOPE
	DPB	E,[POINT 9,SPCPRO,8]	;SAVE IT HERE
	SKIPE	E		;IF <000>,
	JRST	.+3
	MOVEI	E,100		;THEN MAKE IT 100, SO RENAME WORKS
	AOS	SPCPRO		;AND FLAG SPCPRO
	DPB	E,[POINT 9,XFILNM+.RBPRV,8]	;PUT IT AWAY
	TXO	FF,F.PROT	;A PROTECTION WAS SPECIFIED
	JRST	ENDPUT

PUTPRJ:	SKIPN	FILPPN		;DO WE ALREADY HAVE A DIRECTORY?
	TXNE	F2,S.DPPN	;NO, BUT MAYBE HE SPECIFIED DEFAULT
	..ERROR	E.DDR		;2 DIRECTORY SPECS LOSE
	CAIN	E,0		;IS PROJ 0?
	HLRZ	E,USRPPN	;YES, GET LOGGED-IN PROJ
	HRLZM	E,FILPPN	;STORE IT
	JRST	ENDPUT

PUTPRG:	CAIN	E,0		;IS PROG 0?
	HRRZ	E,USRPPN	;YES, GET LOGGED-IN PROG
	HRRM	E,FILPPN	;STORE IT
	MOVE	E,FILPPN
	MOVEM	E,XFILNM+.RBSIZ
	MOVEM	E,SPCPPN	;SAVE IT HERE TOO
	JRST	ENDPUT

PUTPTH:	JUMPE	E,ENDPUT	;DONT STORE NULL SFD'S
	AOSLE	T,PTHCNT	;COUNT TOTAL SFD'S
	..ERROR	E.TMS		;TOO MANY
	MOVEM	E,FILSFD+4(T)	;STORE IT
	MOVEM	E,SPCPPN+5(T)	;SAVE HERE TOO
ENDPUT:	TXO	FF,F.FILE	;WE'VE SEEN AT LEAST ONE PART OF FILESPEC
ENDPU1:	SETZ	E,		;ZERO PACKING WORD
	MOVE	OU,[POINT 6,E]	;INIT SIXBIT BYTE POINTER
	MOVSI	I,770K		;INIT SWITCH MASK
	POPJ	P,

PUTSWI:	MOVEM	E,SWITHL	;SAVE IN CASE BAD
	SETZM	SWINDX		;NO SWITCH SEEN YET
	MOVSI	T,-SWS		;NUMBER OF SWITCHES IN THE WORLD
SWLOOP:	CAMN	E,SWITAB(T)	;THIS IS IT?
	JRST	SETSWH		;YES, SET IT
	MOVE	OU,SWITAB(T)	;YES, GET SWITCH FROM TABLE
	AND	OU,I		;APPLY MASK TO SWITCH
	CAME	OU,E		;SAME?
	JRST	SWHLP		;NO, LOOP
	SKIPE	SWINDX		;ALREADY HAVE MATCH?
	..ERROR	E.ABS
	MOVEM	T,SWINDX	;ELSE SAVE INDEX AND GO ON
SWHLP:	AOBJN	T,SWLOOP	;LOOP FOR ALL (MAYBE)
	SKIPN	T,SWINDX	;HAVE SEEN A MATCH?
	..ERROR	E.UIS
SETSWH:	MOVSI	OU,400K		;LITE SIGN BIT
	MOVNS	T
	LSH	OU,(T)		;SHIFT INTO POSITION
	TLZE	OU,FS.NOB	;[2016] /NOBAK?
	 TLO	OU,FS.INP	;[2016] Yes, treat as /INPLACE
	IORM	OU,SWITC	;AND SAVE IT
	JRST	ENDPUT

DEFDIR:	SKIPN	FILPPN		;DOUBLE DIRECTORY LOSES
	TXOE	F2,S.DPPN	;SET THE DEFAULT DIRECTORY BIT
	..ERROR	E.DDR		;EVEN DOUBLE DEFAULT LOSES-WE ARE MEAN
	JRST	ENDPUT

FILERR:	MOVE	A,STNEXT-2(A)	;IN THE CASE OF AN ERROR, "NEXT STATE"
	ROT	A,(B)		;IS REALLY THE ERROR NUMBER
	ANDI	A,77
	JRST	FILERT-1(A)	;GO TO IT

FILERT:	..ERROR	E.IFN		;ERROR DISPATCH TABLE
	..ERROR	E.DEX
	..ERROR	E.BFS
	..ERROR	E.DIR
	..ERROR	E.IOS

	SUBTTL	Tables for File Spec Parser

;CHARACTER TYPE CLASSIFICATION TABLE

FILDSP:	^D3,,.CHESC
	^D4,," "
	^D4,,.CHTAB
	^D5,,","
	^D7,,"."
	^D8,,"/"
	^D9,,":"
	^D10,,"["
	^D11,,"]"
	^D6,,"-"
	^D10,,"<"
	^D11,,">"
	0,,0

;PROCEDURE DISPATCH TABLE

FILPRO:	EXP	PAKSIX
	EXP	PAKOCT
	EXP	PUTDEV
	EXP	PUTFIL
	EXP	PUTEXT
	EXP	PUTPRJ
	EXP	PUTPRG
	EXP	PUTPTH
	EXP	PUTSWI
	EXP	CPOPJ
	EXP	FILERR
	EXP	DEFDIR
	EXP	PUTPRO

	RADIX	10		;NOTE!!!!

;PROCEDURE TABLE

STPROC:	BYTE	(6)1,1,4,4,11,11,4,4,3,4,11,11		;STATE 1
	BYTE	(6)1,1,5,5,11,11,11,5,11,5,11,11	;STATE 2
	BYTE	(6)11,2,11,6,6,12,11,11,11,11,13,11	;STATE 3
	BYTE	(6)11,2,7,7,7,11,7,7,11,11,7,11		;STATE 4
	BYTE	(6)1,1,8,8,8,11,8,8,11,11,8,11		;STATE 5
	BYTE	(6)1,1,9,9,11,11,9,9,11,9,11,11		;STATE 6
	BYTE	(6)1,1,10,10,11,11,10,10,11,11,10,11	;STATE 7
	BYTE	(6)1,1,10,10,10,11,10,10,11,11,10,11	;STATE 8
	BYTE	(6)11,11,11,10,10,11,11,11,11,11,11,11	;STATE 9

;"NEXT STATE" TABLE

STNEXT:	BYTE	(6)1,1,15,1,1,1,2,6,1,3,1,1	;STATE 1
	BYTE	(6)2,2,15,1,1,1,2,6,3,3,1,1	;STATE 2
	BYTE	(6)1,3,3,9,4,7,3,3,3,3,1,1	;STATE 3
	BYTE	(6)4,4,15,8,5,4,2,6,4,4,1,4	;STATE 4
	BYTE	(6)5,5,15,8,5,4,2,6,4,4,1,4	;STATE 5
	BYTE	(6)6,6,15,1,1,1,2,6,3,3,1,1	;STATE 6
	BYTE	(6)1,1,15,7,4,4,2,6,3,4,1,1	;STATE 7
	BYTE	(6)1,1,15,13,5,4,2,6,3,4,1,4	;STATE 8
	BYTE	(6)4,4,4,14,4,4,4,4,4,4,4,4	;STATE 9


	RADIX	8
;FILE SELCTION COMMAND SWITCH TABLE

DEFINE	SWTCHS,<
SW APPEND	;;APPEND TO THE LOG FILE (NOT SUPERSEDE)
SW DEFAUL	;;[337] CLEAR STICKY DEFAULTS BEFORE APPLYING FILESPEC
SW GENLSN	;;GENERATE LINE SEQUENCE NUMBER ON OUTPUT
SW INPLACE	;;.TECO <FILESPEC> DOES ER/EW TO SAME FILESPEC
SW NOBAK	;;[2016] Same as /INPLACE
SW NOIN		;;NO INPUT FROM TTY IN THE LOG FILE
SW NOLSN	;;INTELLIGENT PERSON NOT WANTING LSN'S
SW NOOUT	;;NO TTY TYPEOUT IN THE LOG FILE
SW NOYANK	;;[1020] Disable CCL entry yank on TECO command
SW READON	;;[337] READ ONLY WHEN .TECO <FILESPEC>
SW SUPLSN	;;SUPPRESS LINE SEQUENCE NUMBERS ON INPUT
SW YANK		;;[1021] Allow ER/EB command to yank in a buffer
>
DEFINE	SW,(SWT),<
	EXP	SIXBIT	/SWT/
	FS.'SWT==<.BIT.==.BIT._-1>>
.BIT.==1B17

SWITAB:	SWTCHS		;GENERATE SWITCH TABLE
SWS==.-SWITAB
	SUBTTL	Y (Yank) Command

; Y	Render the buffer empty.  Read into the buffer
;	until:
;	 1)  a form feed character is read
;	 2)  the buffer is within one third or 128
;	     characters of capacity and a line feed
;	     is read
;	 3)  an end of file is read
;	 4)  the buffer is completely full.
;THE FORM FEED (IF PRESENT) DOES NOT ENTER THE BUFFER.

YANKER:	CHKEO	EODEC,YANK	;[335] Y is OK if EO level is 2 or less
	SKIPN	EQM		;Y ILLEGAL FROM TTY
	ERROR	E.UEY
YANK:

YANK1:	MOVE	OU,BEG
	MOVEM	OU,PT		;PT:=BEG
	MOVSI	C,377777	;[346] Set up "infinite" line count
	MOVEM	C,LFCNT		;[346]

YANK2:	TXZ	FF,F.FORM	;RESET THE YANK,APPEND FORM FEED FLAG
	TXNN	FF,F.IOPN	;ERROR IF INPUT NOT SPECIFIED
	ERROR	E.NFI

;MAINTAIN AT LEAST A MINIMUM SIZE BUFFER OF 3000
;CHARACTERS AT ALL TIMES, WHEN TECO ASKS FOR INPUT FROM
;ANYTHING BUT THE CONSOLE.

	MOVE	C,PT		;GET .
	MOVEM	C,Z		;TELL NROOM IT'S AN EXPAND
	SUBM	OU,C		;BUT EXPAND WITH REAL Z IN MIND
	ADDI	C,^D3000	;NEED 3000 ABOVE Z
	PUSHJ	P,NROOM
YANK6:	ADD	OU,RREL		;RELOCATE IN CASE GARBAGE COLLECTION DONE
	MOVE	TT,MEMSIZ	;TOP OF BUFFER
	MOVE	CH,TT
	SUB	TT,OU
	IDIVI	TT,3
	SUBM	CH,TT
	MOVEM	TT,M23		;M23 HAS 2/3 PT
	SUBI	CH,200
	MOVEM	CH,M23PL	;M23PL HAS 200 BELOW TOP
	MOVE	TT,OU		;CHAR ADR
	IDIVI	TT,5		;TO WORD ADR
	HLL	TT,BTAB-1(TT1)	;MAKE BYTE POINTER
YANK4:	CAMGE	OU,M23		;2/3 FULL YET?
	JRST	YANK3		;NO, KEEP GOING
	CAMG	OU,M23PL	;YES, GETTING NEAR TOP?
	CAIN	CH,.CHLFD	;NO. LINE FEED?
	JRST	[SKIPE C,XFLAGS		;[1024] Yes, skip no are flags set
		 TXNN  C,XF.TIP		;[1024] Skip if 'Truth-in-Paging'
		 JRST  YANK51		;[1024] That's all then
		 JRST  YANK2]		;[1024] Go append some more core
YANK3:	PUSHJ	P,@INCH		;READ A CHARACTER
	JRST	YANK51		;NONE LEFT, CLEAR BUFFER AND RETURN.
	IDPB	CH,TT		;PUT CHARACTER IN MEMORY
	CAIN	CH,.CHFFD	;[346] FORM FEED?
	JRST	YANK5		;[346] Yes
	CAIE	CH,.CHLFD	;[346] Line feed?
	AOJA	OU,YANK4	;NO. UPDATE DATA BUFFER PTR AND CHECK FOR OVERFLOW.
	SOSLE	LFCNT		;[346] Yes, decrement line count
	AOJA	OU,YANK4	;[346] Still positive...Keep going
	AOJA	OU,YANK51	;[346] Time to stop
YANK5:	TXO	FF,F.FORM	;[346] YANK AND/OR APPEND ENDS ON A FORM FEED
YANK51:	MOVEM	OU,Z		;YES. SET END OF DATA BUFFER AND RETURN
	SKIPE	XCTING		;IF OFF STOP
	POPJ	P,
	JRST	GO		;RESTART

;A   APPEND TO THE END OF THE BUFFER FROM THE SELECTED INPUT
;	TERMINATING THE READ IN THE SAME MANNER AS Y.  THE POINTER
;	IS NOT MOVED BY A.
;:nA	SAME AS A EXCEPT THAT INPUT STOPS AFTER THE NTH LINE FEED,
;	UNLESS ONE OF THE REGULAR CONDITIONS TERMINATES IT FIRST.
;	IF n IS MISSING, 0, OR NEGATIVE, IT IS TAKEN AS 1.

APPEND:	MOVE	OU,Z		;STORE DATA AT END OF BUFFER.
	PUSHJ	P,CHK2		;[346] GET ARG
	TXZN	FF,F.COLN	;[346] WAS COLON SET?
	MOVSI	B,377777	;[346] NO, REGULAR APPEND, SO SET LARGE COUNT
	MOVEM	B,LFCNT		;[346] STORE COUNT
	PUSHJ	P,YANK2
	JRST	RET
	SUBTTL	^Y ! ^P - Quick Page Scan Commands

QYANK:	TXO	F2,S.YANK	;NOTE QUICK YANK
QPAGE:	TXNN	FF,F.ARG	;NO ARG MEANS RETURN # OF FF'S SEEN
	JRST	[MOVE	A,NFORMS	;# FF'S SEEN
		 JRST	VALRET]		;SAY IT UNTO THE USER
	CAXN	B,^D0		;[1035] Skip if non-zero
	MOVX	B,.INFIN	;[1035] Set the page counter to infinity
	SKIPL	B		;[1035] Skip if negative
	CAMGE	B,NFORMS	;BACKWARD OR NEGATIVE ARG?
	..ERROR	E.IPA
	CAMN	B,NFORMS	;REQUEST IS FOR THIS PAGE?
	JRST	RET		;YES, GO AWAY FROM HERE MY BROTHER
	TXNE	FF,F.EOFI	;EOF?
QERR:	..ERROR	E.PTL
	PUSH	P,B		;SAVE PAGE WE WANT FOR LATER AND
	TXO	FF,F.NSRH	;NO FREE FORM FEEDS
	TXNN	F2,S.YANK	;NO OUTPUT?
	PUSHJ	P,PUNCHR	;PUNCH ANY BUFFER THERE NOW
	MOVE	B,BEG		;WHERE TEXT BUFFER STARTS
	MOVEM	B,Z		;NOTHING IN IT NOW
	MOVEM	B,PT		;PT ALSO = BEG
	POP	P,B		;GET THE ARGUMENT BACK
	SOJ	B,		;MINUS 1 SO THAT WHEN NFORMS = B
				;WE WANT THE NEXT PAGE
	TXNN	FF,F.IOPN	;SOMETHING TO READ?
	..ERROR	E.NFI
	TXNN	F2,S.YANK	;^Y REQUIRES NO OUTPUT FILE
	TXNE	FF,F.OOPN	;FILE MUST BE OPEN FOR OUTPUT HERE
	CAIA
	ERROR	E.NFO
	TXNE	FF,F.SEQ	;SEQUENCED FILE= USE STUPID ROUTINE
	JRST	STUPID
QLOOP:	CAMG	B,NFORMS	;FOUND IT YET?
	JRST	APPEND		;YES, YANK AND RETURN
	PUSHJ	P,@INCH		;READ A CHARACTER
	AOJA	B,[CAXN B,.INFIN	;[1035] Skip if not the end-of-file flag
		   JRST RET		;[1035] Finished - return
		   JRST QERR]		;[1035] Page Too Large
	TXNN	F2,S.YANK	;NO OUTPUT ON ^Y
	PUSHJ	P,@OUTCH	;SEND IT TO OUTPUT FILE
	SKIPN	XCTING		;HE WANT ME TO STOP?
	PUSHJ	P,CKEOL		;YES, BUT STOP ON EOL
	  JRST	QLOOP		;NOT EOL OR NOT TO STOP
	JRST	APPEND		;AND YANK A PAGE

STUPID:	MOVEM	B,SAVEAC	;SAVE B
STUP1:	TXNE	FF,F.EOFI	;[327] ANYTHING LEFT?
	AOJA	B,[CAXN B,.INFIN	;[1035] Skip if not the end-of-file flag
		   JRST RET		;[1035] Finished - return
		   JRST QERR]		;[1035] Page Too Large
	PUSHJ	P,YANK1		;[327] GET A BUFFER-FULL
	TXNN	F2,S.YANK	;[327] IF ^Y, WE DON'T NEED TO OUTPUT
	PUSHJ	P,PUNCHR	;[327] OUTPUT CURRENT BUFFER
	MOVE	B,SAVEAC	;[327] RESTORE B
	CAMLE	B,NFORMS	;[327] ARE WE DONE?
	JRST	STUP1		;[327] NO, LOOP BACK
	PUSHJ	P,YANK1		;[327] YES, SO DO ONE MORE Y
	JRST	RET		;[327] AND RETURN
	SUBTTL	Read a Character from Input File

RI:	SOSGE	IBUF+.BFCNT	;MORE IN THE BUFFER?
	JRST	RI3		;NO, CAUSE THERE TO BE MORE
RI0:	ILDB	CH,IBUF+.BFPTR	;GET ONE
	JUMPE	CH,RI		;EAT NULLS
	CAIN	CH,.CHFFD	;FF?
	AOS	NFORMS		;NOTE IT IN CASE NEW ^P COMMAND USED
	TXZN	F2,S.SSEQ	;LAST THIS WAS A SUPPRESSED SEQUENCE #?
	JRST	RI1		;NO..
	CAIE	CH,.CHCRT	;CR (FOR SOS) OR
	CAIN	CH,.CHTAB	;<TAB> FOLLOWING IT?
	JRST	RI		;= EAT IT UP
RI1:	LDB	T,[POINT 1,@IBUF+.BFPTR,35]	;GET BIT 35 OUT OF CURRENT WORD
	JUMPE	T,CPOPJ1	;LEAVE,  A LSN
	MOVE	T,INSWIT	;SUPPRESS SEQ # FLAF ON?
	TLNN	T,FS.SUP	;?
	JRST	CPOPJ1
RI2:	MOVEI	T,4		;THINGS TO EAT
	IBP	IBUF+.BFPTR	;INCREMENT BYTE POINTER
	SOS	IBUF+.BFCNT	;DECREMENT COUNT
	SOJG	T,.-2		;A BUNCH OF TIMES
	TXO	F2,S.SSEQ	;JUST ATE A SEQUENCE NUMBER
	JRST	RI		;NEXT CHARACTER PLS

RI3:	IN	INCHN,		;GET A BUFFER
	JRST	RI		;AND CHAR TOO
ANNERR:	TXON	FF,F.EOFI	;[1022] Skip EOF has already been set
	AOS	NFORMS		;[1022] Increment the page number
ANERR:	STATO	INCHN,IO.ERR	;ERROR?
	POPJ	P,		;SINGLE RETURN

INERR:	GETSTS	INCHN,B		;SAVE ERROR FLAGS
	RELEAS	INCHN,0
	TXZ	FF,F.IOPN
EE2ERR:	EE2+ERROR E.INP

RIQ:	SOSGE	IBUF+.BFCNT	;MORE THERE?
	JRST	[IN	INCHN,	;GET SOME
		 JRST	RIQ	;YANK CHAR
		 JRST	ANNERR]	;CHECK FOR ERRORS OR EOF
	ILDB	CH,IBUF+.BFPTR	;GET CHARACTER
	CAIN	CH,.CHFFD	;<FF>?
	AOS	NFORMS		;YES, COUNT IT
	JUMPN	CH,CPOPJ1	;AND RETURN
	JRST	RIQ		;ELSE LOOP
	SUBTTL	I (Insert) Command

;^Itext$	Inserts at the current pointer location the ^I (tab)
;		and the text following the ^I up to but NOT including
;		the ESCape.  The pointer is put to the right of the
;		inserted material.
;
;:n^Itext$	Skips to the end of line n, then does the ^I command.

TAB:	TXNE	FF,F.COLN	;[1023] Skip if colon wasn't supplied
	PUSHJ	P,LINE		;[1023] Skip some lines
	MOVX	CH,.CHTAB	;[1023] Get a tab back
	PUSHJ	P,TAB2		;INSERT TAB
IFN VC,<TXO	FF,F.TABS>	;ADJUST VVAL

;Itext$		Insert, at the current pointer location, the text
;		following the I up to but NOT including the first
;		ESCape.  The pointer is put to the right of the
;		inserted material.
;
;:nItext$	Skips to the end of line n, then does the I command.

INSERT:	TXNE	FF,F.COLN	;[1023] Skip if colon wasn't supplied
	PUSHJ	P,LINE		;[1023] Skip some lines
	TXNE	FF,F.ARG	;IS THERE AN ARGUMENT?
	JRST	INS1A		;YES. NI COMMAND.
	MOVEI	CH,.CHESC	;NORMAL TERMINATOR
	TXZN	FF,F.SLSL	;DID @ PRECEED I?
	JRST	INSERA		;NO, TERMINATOR = ALTMODE
	PUSHJ	P,SKRCH		;YES. CH:=USER SELECTED TERMINATOR.
	ERROR	E.UIN
INSERA:	MOVEI	B,(CH)		;B=INSERTION TERMINATOR.
	SETZM	CTGLEV		;ZERO THE ^G NEST COUNTER
	MOVEI	T,INSER0	;AND SET ^G ROUTINE RETURN POINT
	MOVEM	T,CTGRET
	PUSH	P,CPTR		;SAVE CURRENT POSITION IN CMD STRING
	PUSH	P,COMCNT
	MOVEI	C,0		;COUNT # CHARACTERS TO INSERT IN C AND
				;MOVE CPTR TO END OF STRING.
INSER0:	PUSHJ	P,SKRCH		;GET NEXT CHARACTER
	JRST	INS0A		;NO MORE CHARS AT THIS LEVEL
	SKIPN	CTGLEV		;IF WE ARE IN A ^G NEST, IGNORE TERMINATOR
	CAIE	CH,(B)		;IS IT THE TERMINATOR?
	TRNA			;NO, SKIP
	JRST	INSER2		;YES, END OF 1ST PASS
	TXO	FF,F.NNUL	;FLAG NON-NULL STRING (FOR F-SEARCH)
	CHKEO	EO21,INSER1	;IF EO=1, CTRL-CHARS ARE JUST TEXT
	MOVEI	T,IN1TAB	;CK FOR ^V, ^W, ^R, ^T, ^^
	TXNE	F2,S.NCCT	;^T FLAG ON?
	MOVEI	T,IN2TAB	;YES, USE RESTRICTED TABLE
	PUSHJ	P,DISP1
	TXNN	F2,S.NCCT	;IF ^T ON, ALL OTHER CTL-CHARS LEGAL TEXT
	PUSHJ	P,CKNCC		;CHECK FOR OTHER CTRL-CHARS (THEY ARE ILLEGAL)
INSER1:	AOJA	C,INSER0	;COUNT TEXT CHARACTERS
INSER2:	MOVEM	C,VVAL		;SAVE LENGTH OF STRING
IFN VC,<
	TXZE	FF,F.TABS	;TAB INSERTED?
	AOS	VVAL>		;YES, COUNT IT
	TXZ	F2,S.NCCT	;REFRESH ^T FLAG
	TXNE	FF,F.SRCH	;DOING FS OR FN?
	JRST	SERCHJ		;YES
	POP	P,COMCNT	;RESET TO BEGINNING OF INSERT TEXT
	POP	P,CPTR
	PUSHJ	P,NROOM		;YES. MOVE FROM PT THROUGH Z UP C POSITIONS.

;MOVE INSERTION INTO DATA BUFFER

INS1B:	MOVE	OU,PT
	SETZM	CTGLEV		;ZERO ^G NEST COUNTER
	MOVEI	T,INS1C		;AND SET RETURN POINT
	MOVEM	T,CTGRET
INS1C:	PUSHJ	P,GCH		;CH:=CHARACTER FROM COMMAND STRING.
	SKIPGE	COMCNT		;END OF COMMAND AT THIS LEVEL?
	JRST	INS0A		;YES
INS1F:	CAIN	CH,(B)		;IS IT THE TERMINATOR?
	SKIPE	CTGLEV		;YES, BUT IGNORE IT IF IN ^G NEST
	TRNA			;NO, SKIP
	POPJ	P,		;BUT WE'RE NOT, SO LEAVE
	CHKEO	EO21,INS1D	;IF EO=1, THERE ARE NO CTL-CHAR. COMMANDS
	MOVEI	T,INSTAB	;CK FOR CONTROL CHARACTERS
	TXNE	F2,S.NCCT	;^T FLAG ON?
	MOVEI	T,INTTAB	;YES, ONLY ^T AND ^R ARE SPECIAL
	PUSHJ	P,DISP1
INS1E:	PUSHJ	P,CASE		;CONVERT UC TO LC IF FLAGS WARRANT
INS1D:	PUSHJ	P,PUT		;NO. STORE CHARACTER IN DATA BUFFER TO RIGHT OF PT.
	AOS	OU,PT		;PT:=PT+1
	JRST	INS1C		;LOOP
;DISPATCH TABLE FOR INSERT STRING CONTROL CHARACTERS (COUNT PASS)

IN1TAB:	XWD	CTRGI,7		;^G
	XWD	INSER0,.CHCNV	;^V
	XWD	INSER0,.CHCNW	;^W
	XWD	INSER0,.CHCCF	;^^
IN2TAB:	XWD	INSER4,.CHCNT	;^T
	XWD	INSER3,.CHCNR	;^R
	XWD	0,0		;END OF LIST

;GET CHARACTER AFTER ^R

INSER3:	PUSHJ	P,SKRCH		;DON'T COUNT ^R & DON'T DO CHECKS ON CHAR AFTER IT
	ERROR	E.UIN
	JRST	INSER1

;CHANGE NO-CONTROL-COMMANDS FLAG

INSER4:	TXC	F2,S.NCCT
	JRST	INSER0		;DON'T COUNT ^T


;^GI CAUSES THE CONTENTS OF Q REG I TO BE INSERTED INTO THE TEXT STRING
;AT THIS POINT

CTRGI:	PUSHJ	P,SKRCH		;GET THE NAME OF THE Q-REG
	ERROR	E.ICG		;NOT THERE
	PUSH	PF,CPTR		;SAVE POINTER
	PUSH	PF,COMCNT	;AND COUNT
	PUSH	P,C		;AND LENGTH OF STRING SO FAR
	AOS	CTGLEV		;BUMP ^G NEST COUNTER
	PUSHJ	P,QREGV2	;ACCESS THE Q REGISTER
	PUSHJ	P,QTEXEI
	PUSHJ	P,GTQCNT	;LENTH OF Q REG STRING IN C
	MOVEI	A,(I)
	IDIVI	A,5		;FIX THE POINTER
	HLL	A,BTAB-1(A+1)
	MOVEM	A,CPTR		;AND STORE IT
	MOVEM	C,COMCNT	;THE NEW COUNT
	POP	P,C		;RESTORE INSERT STRING LENGTH
	JRST	@CTGRET		;RETURN

INS0A:	SKIPN	CTGLEV		;ARE WE IN A Q-REGISTER?
	ERROR	E.UIN		;NO, UNTERMINATED INSERT COMMAND
	POP	PF,COMCNT	;RESTORE COUNT
	POP	PF,CPTR		;AND POINTER
	SOS	CTGLEV		;DECREMENT NEST COUNT
	JRST	@CTGRET		;RETURN
;DISPATCH TABLE FOR INSERT STRING CONTROL CHARACTERS (INSERT PASS)

INSTAB:	XWD	CTRGI,7		;^G
	XWD	INSLOW,.CHCNV	;^V
	XWD	INSSTD,.CHCNW	;^W
	XWD	INSSPC,.CHCCF	;^^
INTTAB:	XWD	INSMAC,.CHCNT	;^T
	XWD	INSIGR,.CHCNR	;^R
	XWD	0,0		;END OF LIST

;^V CAUSES THE NEXT CHARACTER TO BE CONVERTED TO LOWER CASE (IF UPPER CASE)
;^V^V SETS LOWER CASE MODE UNTIL THE END OF THE TEXT STRING (OR FURTHER NOTICE)

INSLOW:	PUSHJ	P,C.V		;SET ^V FLAGS
	JRST	INS1C		;CONTINUE TO NEXT CHAR.

;^W CAUSES NEXT CHAR. TO BE TAKEN AS IS (STANDARD MODE)
;^W^W SETS STANDARD MODE UNTIL END OF TEXT STRING (OR FURTHER NOTICE)

INSSTD:	PUSHJ	P,C.W		;SET ^W FLAGS
	JRST	INS1C		;CONTINUE TO NEXT CHAR.

;^R CAUSES NEXT CHAR. TO BE TAKEN AS TEXT
;EVEN IF IT IS A CONTROL CHAR. OR THE TEXT TERMINATOR

INSIGR:	PUSHJ	P,GCH		;GET NEXT CHAR.
	JRST	INS1E		;TREAT AS TEXT

;^^ -- IF NEXT CHAR IS @,[,\,],^, OR _, CONVERT IT TO LC RANGE

INSSPC:	PUSHJ	P,GCH		;GET NEXT CHAR
	PUSHJ	P,CVTSPC	;CONVERT IF WARRANTED
	JRST	INS1F

;CHANGE NO-CONTROL-COMMANDS MODE

INSMAC:	TXC	F2,S.NCCT	;COMPLEMENT ^T FLAG
	JRST	INS1C		;GO ON TO NEXT CHAR
	SUBTTL	Alpha Case Converted

;SET ^V FLAGS

C.V:	TXON	F2,S.CTLV	;SET ^V FLAG -- WAS IT ON BEFORE?
	POPJ	P,		;NO
	TXZ	F2,S.CTLV+S.CTWW	;YES, SET ^V^V FLAG & CLR OTHERS
	TXO	F2,S.CTVV
	POPJ	P,

;SET ^W FLAGS

C.W:	TXON	F2,S.CTLW	;SET ^W FLAG -- WAS IT ON BEFORE?
	POPJ	P,		;NO
	TXZ	F2,S.CTLW+S.CTVV	;YES, SET ^W^W FLAG & CLR OTHERS
	TXO	F2,S.CTWW
	POPJ	P,

;CONVERT ALPHABETIC CH TO UPPER OR LOWER CASE ACCORDING TO CASE CONTROL FLAGS

CASE:	CAIL	CH,"A"		;IS CHAR IN UPPER CASE RANGE?
	CAILE	CH,"Z"
	CAIL	CH,"A"+40	;IS IT IN LOWER CASE RANGE?
	CAILE	CH,"Z"+40
	JRST	CASE3		;NO
CASE2:	TXNE	F2,S.LCAS	;PREVAILING LOWER CASE?
	TRO	CH,40		;YES, CONVERT TO LOWER
	TXNE	F2,S.UCAS	;PREVAILING UPPER CASE?
	TRZ	CH,40		;YES, CONVERT TO UPPER
	TXNE	F2,S.CTVV	;DOUBLE ^V ON?
	TRO	CH,40		;YES, CONVERT TO LC
	TXNE	F2,S.CTWW	;DOUBLE ^W ON?
	TRZ	CH,40		;YES, CONVERT TO UC
	TXZE	F2,S.CTLV	;SINGLE ^V ON?
	TRO	CH,40		;YES, CONVERT TO LC
	TXZE	F2,S.CTLW	;SINGLE ^W ON?
	TRZ	CH,40		;YES, CONVERT TO UC
CASE3:	TXZ	F2,S.CTLV+S.CTLW	;CLR IN CASE NO CONVERSION
	POPJ	P,

;CONVERT @, [, \, ], ^, AND _ TO THE EQUIVALENT LC CHARACTER

CVTSPC:	CAIL	CH,"["
	CAILE	CH,"_"
	CAIN	CH,"@"
	TRO	CH,40		;CONVERT TO LOWER CASE RANGE
	POPJ	P,
	SUBTTL	Check for Non-Control Characters

;IF CH<10, OR 15<CH<33, OR 33<CH<40, CH IS AN ILLEGAL CTRL-CHAR

CKNCC:	CAIGE	CH," "
	CAIG	CH,.CHCRT
	CAIGE	CH,.CHCNH
	CAIN	CH,.CHESC
	POPJ	P,		;IT IS 10-15 OR 33 OR 40+
	MOVEI	B,(CH)		;SAVE CHAR FOR ERROR MSG ROUTINE
	ERROR	E.ICT
	SUBTTL	nI (Insert) Command

;NI	INSERT AT THE POINTER A CHARACTER WHOSE 7-BIT ASCII CODE IS N
;	(BASE 10).  THE POINTER IS MOVED TO THE RIGHT OF THE NEW CHARACTER.

INS1A:	CHKEO	EO21,INS1X	;IF EO=1 SKIP NEXT STUFF
	PUSHJ	P,SKRCH		;GET CHAR AFTER I
	ERROR	E.NAI
	CAIE	CH,.CHESC	;IT HAD BETTER BE AN ALTMODE
	ERROR	E.NAI
INS1X:	MOVE	CH,NUM		;CH:=NUM

;INSERT CH IN DATA BUFFER AT PT

TAB2:	MOVEI	C,1		;MOVE FROM PT THROUGH Z UP 1 POSITION.
	PUSHJ	P,NROOMC
	AOS	OU,PT		;PT:=PT+1
	SOJA	OU,PUT		;STORE CH AT PT-1

;NBACKSLASH	INSERT AT THE CURRENT POINTER LOCATION THE ASCII NUMBERS
;	EQUAL TO N.

BAKSL1:	MOVE	T,[XWD 700,STAB-1]
	MOVEI	C,0		;COUNT # DIGITS IN C.
	MOVEI	A,BAKSL4	;SET DPT TO RETURN TO BAKSL4
	PUSHJ	P,DPT		;CONVERT C(B) TO ASCII AND STORE STRING IN STAB.
	MOVE	B,[XWD 700,STAB-1]
	PUSHJ	P,NROOMC	;MOVE FROM PT THROUGH Z UP C POSITIONS.
BAKSL5:	MOVE	OU,PT		;POSITION TO PUT CHAR IN
	ILDB	CH,B		;GET NEXT CHAR OF THE #
	PUSHJ	P,PUT		;STORE THE CHAR
	AOS	PT		;MOVE THE POINTER
	SOJG	C,BAKSL5	;DECREMENT THE CHAR CTR
	JRST	RET

BAKSL4:	IDPB	CH,T		;STORE DIGIT IN STAB
	AOJA	C,CPOPJ		;C:=C+1. RETURNS TO DPT CALL + 1 ON COMPLETION.

;@ COMMAND MODIFIER

ATSIGN:	TXOA	FF,F.SLSL	;SET @ SEEN FLAG

;COLON COMMAND MODIFIER

COLON:	TXO	FF,F.COLN	;SET : SEEN FLAG
	JRST	RETRET
	SUBTTL	T (Type) Command

;	TYPE OUT STRING OF CHARACTERS STARTING AT THE RIGHT OF THE
;	POINTER AND CONTINUING THROUGH THE NTH LINE FEED ENCOUNTERED.
;	IF N IS NEGATIVE, N LINES TO THE LEFT OF THE POINTER ARE TYPED.
;T	SAME AS 1T.
;I,JT	TYPE OUT THE (I+1)TH THROUGH THE JTH CHARACTER OF THE BUFFER.

TYPE:	SETZM	XCTING		;SO ^C^C REE WORKS PROPERLY

	PUSH	P,B		;[1053] Save register B (TYPPAG uses it)
	PUSHJ	P,TYPPAG	;[1053] Type current page number
	POP	P,B		;[1053] Restore register B

	PUSHJ	P,TYPE4		;TYPE IT
	SETOM	XCTING		;KEEP GOING
	POPJ	P,		;RETURN

TYPE4:	MOVEI	D,TYO		;D:=ADDRESS OF OUTPUT ROUTINE.

TYPE0:	PUSHJ	P,GETARG	;C:=FIRST STRING ARGUMENT ADDRESS.
				;B:=SECOND STRING ARGUMENT ADDRESS.

TYPE1:	PUSHJ	P,CHK1		;C:=MAX(C(C),BEG), B:=MIN(C(B),Z)
	MOVE	I,C		;START GETTING CHARACTERS AT C.
	MOVE	OU,C		;STARTING CHAR
TYPEQ:	IDIVI	OU,5		;WORD ADR
	HLL	OU,BTAB-1(OU+1)	;FORMED POINTER
	JUMPG	OU,.+2
	SUB	OU,[430000,,1]	;ADJUST IF CHAR IS IN PREV WORD.
	LDB	CH,OU		;PICK UP PREVIOUS CHARACTER
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	CAMN	I,BEG		;NO, ARE WE AT BEG. OF BUFFER?
	TXO	FF,F.SQIN	;YES, START WITH A SEQ # IF NECESSARY
TYPE3:	CAML	I,B		;DONE?
	JRST	TYPE5		;YES.
	ILDB	CH,OU		;CHARACTER
	PUSHJ	P,(D)		;OUTPUT IT
	AOJA	I,TYPE3		;LOOP FOR ALL
TYPE5:	MOVE	A,OUTCH		;IF TYPING OR I,JP DON'T APPEND FF
	MOVEI	CH,.CHFFD	;IF PUNCHING, APPEND FF.
	CAIE	A,(D)		;D=PPA?
	POPJ	P,		;NO
	TXNN	FF,F.NSRH	;IS THIS AN "N" SEARCH?
	JRST	CPPA
	TXNN	FF,F.FORM	;DID LAST Y,A TERMINATE ON A FORM FEED?
	POPJ	P,
CPPA:	TXNN	FF,F.OOPN	;WE HAVE AN OUTPUT FILE OPEN?
	ERROR	E.NFO
	JRST	@OUTCH		;DISPATCH TO OUTPUT A CHARACTER

	SUBTTL	V (View) Command

;nV Command --	Equivalent to (1-n)T nT

IFE VC,<	;In case anybody is really using the old V command

VCMD:	PUSHJ	P,CHK2		;[347] Get argument
	TXZ	FF,F.ARG2	;[347] Ignore second arg if any
	PUSH	P,B		;[347] Save it
	MOVN	B,B		;[351] Calculate 1-n
	ADDI	B,1		;[351]
	PUSHJ	P,TYPE		;[347] Type the lines above
	POP	P,B		;[347] Restore arg
	PJRST	TYPE		;[347] Type the lines below
>
	SUBTTL	Put a Character in the Output File

PPA:
PPA05:	SOSGE	OBF+.BFCNT	;YES. IS OUTPUT BUFFER FULL?
	JRST	OUTBFR
	MOVE	A,OUTSWT	;GET OUTPUT SWITCHES
	TXNN	FF,F.SEQ	;SEQUENCED FILE?
	TLNE	A,FS.GEN	;NO, OUTPUT FS.GEN ON?
	JRST	PPA02		;YES, GENERATE LSN
	TXZ	FF,F.SQIN
PPA01:	IDPB	CH,OBF+.BFPTR	;CH TO OUTPUT BUFFER.
	POPJ	P,		;RETURN

OUTBFR:	OUT	OUTCHN,		;DUMP BUFFER
	JRST	PPA05		;AND CONTINUE
OUTERR:	GETSTS	OUTCHN,B	;SAVE ERROR FLAGS
	RELEAS	OUTCHN,0	;CLOSE FILE AND RELEASE OUTPUT DEVICE.
	TXZ	FF,F.OOPN+F.UBAK	;CLEAR OUTPUT FILE OPEN INDICATOR.
	EE2+ERROR E.OUT

PPAQ:	SOSGE	OBF+.BFCNT	;MORE ROOM?
	JRST	[OUT	OUTCHN,	;DUMP BUFFER
		 JRST	PPAQ	;LOOP
		 JRST	OUTERR]	;ELSE ERROR
	IDPB	CH,OBF+.BFPTR	;SAVE CHARACTER
	POPJ	P,		;LEAVE
PPA02:	TXNN	FF,F.SQIN	;WAS LAST CHAR AN EOL OR BEG OF BUFR?
	JRST	PPA03		;NO
	MOVE	AA,OUTSWT	;GET OUTPUT SWITCHES
	TLNE	AA,FS.SUP	;IF WE ARE SUPRESSING SEQUENCE #'S,
	JRST	PPA06		;DON'T WORRY ABOUT PADDING WITH NULLS
	MOVE	A,OBF+.BFCNT	;ROOM FOR SEQ# IN OUTPUT BUFR?
	CAIG	A,^D12		;[345] Page marks need 12 positions
	JRST	PPA05		;NO, OUTPUT & COME BACK
	PUSHJ	P,NULPAD	;[345] Go pad with nulls if necessary
PPA06:	TXZ	FF,F.SQIN
	TXNE	FF,F.SEQ	;GENERATE NEW LSN OR OUTPUT EXISTING LSN?
	JRST	PPA04		;OUTPUT EXISTING LSN
	CAIN	CH,.CHFFD	;[345] Form feed?
	JRST	PPA14		;[345] Yes, go handle it
	MOVE	A,LSNCTR	;GET LAST CREATED LSN WITH BIT 35 ON
	ADD	A,[BYTE (7)106,106,106,107]	;& ADD ASCII 10 TO IT
	MOVE	T,A
	AND	T,[BYTE (7)60,60,60,60]
	LSH	T,-3
	MOVE	TT,A
	AND	TT,[BYTE (7)160,160,160,160]
	IOR	T,TT
	SUB	A,T
	ADD	A,[BYTE (7)60,60,60,60]
	MOVEM	A,LSNCTR	;STORE NEW LSN
PPA06A:	AOS	OBF+.BFPTR	;& OUTPUT THE 5 DIGITS + BIT 35
	MOVEM	A,@OBF+.BFPTR
	MOVEI	A,.CHTAB	;FOLLOWED BY TAB
	IDPB	A,OBF+.BFPTR
	MOVNI	A,6		;ADJUST BUFR CTR
	ADDM	A,OBF+.BFCNT
PPA03:	PUSHJ	P,CKEOL		;IS THIS CHAR AN EOL?
	JRST	PPA01		;NO
	TXO	FF,F.SQIN
	CAIE	CH,.CHFFD	;[345] Form feed?
	JRST	PPA01		;[345] No, just output
	TLNE	AA,FS.SUP	;[345] Suppressing LSN's?
	JRST	PPA01		;[345] Yes
	MOVEI	A,.CHCRT	;[345] No, insert a CRLF
	IDPB	A,OBF+.BFPTR	;[345] before a page mark
	MOVEI	A,.CHLFD	;[345] So it will be recognized
	IDPB	A,OBF+.BFPTR	;[345]
	SOS	OBF+.BFCNT	;[345] Update the counter
	SOS	OBF+.BFCNT	;[345]
	PUSHJ	P,NULPAD	;[345] Go pad with nulls if necessary
	JRST	PPA14		;[345] Mark the page

;Routine to pad buffer with nulls till next word boundary
;
NULPAD:	LDB	A,[POINT 6,OBF+.BFPTR,5]	;GET CURRENT BYTE POSITION
	CAIG	A,1		;AT END OF WORD?
	POPJ	P,		;Yes, return
	IBP	OBF+.BFPTR	;NO, PAD OUT WORD WITH NULLS
	SOS	OBF+.BFCNT
	JRST	NULPAD		;TRY AGAIN
;OUTPUT EXISTING LSN WITH LEADING ZEROS

PPA04:	MOVEI	A,4		;INIT 5 DIGIT CTR
	MOVEM	A,LSNCTR
	MOVE	A,[<"00000">B34]	;INIT LSN ACCUMULATOR
	CAIL	CH,"0"		;IS CURRENT CHAR A DIGIT?
	CAILE	CH,"9"
	JRST	PPA08		;NO, FILL IN 5 SPACES
	JRST	PPA12
PPA10:	SOSGE	LSNCTR		;DONE 5 DIGITS YET?
	JRST	PPA09		;YES
PPA12:	LSH	A,7		;PUT DIGIT INTO ACCUMULATOR
	DPB	CH,[POINT 7,A,34]
	CAML	I,B
	JRST	PPA09
	ILDB	CH,OU		;GET THE NEXT CHARACTER
	ADDI	I,1		;INCREMENT TEXT PTR
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"9"
	JRST	PPA09		;NO
	JRST	PPA10		;YES, STORE IT

PPA08:	MOVE	A,[<"     ">B34]	;GET 5 SPACES
PPA08X:	CAIE	CH," "		;SPACE?
	JRST	PPA08B		;NO, INSERT 5 SPACES
	SOSGE	LSNCTR		;HAVE WE SEEN 5 SPACES?
	JRST	PPA08C		;IF SO, CHECK FOR TAB OR CR
	ILDB	CH,OU		;GET NEXT CHARACTER
	AOJA	I,PPA08X	;TRY AGAIN

;	HERE IF WE'VE SEEN 5 SPACES MAY BE TECO BLANK SEQUENCE NUMBER,
;	SOS PAGE MARK, OR SPACES THE USER HAS INSERTED.
PPA08C:	ILDB	CH,OU		;GET THE CHAR
	AOS	I
	CAIE	CH,.CHCRT	;TEST FOR CR (FOR SOS) OR
	CAIN	CH,.CHTAB	;TAB TO BE OUTPUT WITH SPACES
	JRST	PPA09		;OUTPUT 5 SPACES + CHAR IN CH

;	HERE IF NOT 5 SPACES FOLLOWED BY TAB OR CR.  THIS IMPLIES
;	THAT ANY SPACES SEEN WERE USERS'S TEXT.
PPA08B:	SUBI	I,4		;BACK UP TO FIRST CHARACTER
	ADD	I,LSNCTR	;AND OUTPUT IT WITH BLANK LSN
	MOVE	OU,I		;FIX BYTE POINTER
	IDIVI	OU,5
	HLL	OU,BTAB-1(OU+1)
	ILDB	CH,OU		;GET PROPER CHARACTER
	MOVE	AA,OUTSWT	;GET SWITCHES
	TLNE	AA,FS.SUP	;SUPPRESS SEQ#
	JRST	PPA01		;YES
	TRO	A,1		;NO SET BIT 35
	JRST	PPA06A		;OUTPUT SEQ# WITH A TAB
PPA09:	MOVE	AA,OUTSWT	;GET SWITCHES
	TLNE	AA,FS.SUP	;SUPPRESS SEQ#'S?
	JRST	PPA13		;YES
	TRO	A,1		;SET BIT 35
	AOS	OBF+.BFPTR	;& OUTPUT SEQ #
	MOVEM	A,@OBF+.BFPTR
	MOVNI	A,5
	ADDM	A,OBF+.BFCNT	;& ADJUST BUFR CTR
	JRST	PPA03		;CONTINUE

PPA13:	CAIE	CH,.CHCRT	;ELEMINATE CR (FOR SOS)
	CAIN	CH,.CHTAB	;IS TERMINATOR A TAB?
	AOSA	OBF+.BFCNT	;YES, ADJUST BYTE COUNT
	JRST	PPA01		;NO, OUTPUT IT
	POPJ	P,		;AND OMIT IT

;
;	Here to insert an SOS type page mark.
;
PPA14:	MOVE	A,[BYTE (7) 40,40,40,40,40]	;[345] Five spaces
	TRO	A,1			;[345] Set the bit
	AOS	OBF+.BFPTR		;[345] Increment pointer
	MOVEM	A,@OBF+.BFPTR		;[345] and output
	MOVE	A,[BYTE (7) .CHCRT,.CHFFD,0,0,0] ;[345] CR,FF
	AOS	OBF+.BFPTR		;[345] Increment
	MOVEM	A,@OBF+.BFPTR		;[345] and deposit
	MOVNI	A,^D9			;[345] Adjust buffer counter
	ADDM	A,OBF+.BFCNT		;[345] (We already counted one at PPA:)
	TRO	FF,F.SQIN		;[345] Set the EOL flag
	MOVE	A,[<"00000">B34+1]	;[345] Reset the LSN's
	MOVEM	A,LSNCTR		;[345]
	POPJ	P,			;[345] Return
	SUBTTL	PW (Punch and Wait) Command

;PW	OUTPUT THE ENTIRE BUFFER, FOLLOWED BY A FORM FEED CHARACTER.
;	TO THE SELECTED OUTPUT DEVICE.  BUFFER IS UNCHANGED AND POINTER
;	IS UNMOVED.
;P	IS IDENTICAL TO PWY.
;NP	IS IDENTICAL TO PP...P (P PERFORMED N TIMES).
;I,JP	OUTPUTS (I+1)TH THROUGH JTH CHARACTERS OF BUFFER.  NO FORM
;	FEED IS PUT AT THE END.  BUFFER UNCHANGED;POINTER UNMOVED.

PUNCHA:	MOVEI	D,CPPA		;SELECT PPA FOR OUTPUT INDIRECTLY IN CASE I,JP.
	TXNE	FF,F.ARG2	;I,JP?
	JRST	TYPE0		;YES. GET STRING ARGUMENTS AND OUTPUT.
	MOVE	E,B		;NO. E:=N
	MOVE	B,CPTR
	ILDB	T,B		;T:=COMMAND CHARACTER FOLLOWING P.
	TRZ	T,40		;FILTER L.C.
	JUMPL	E,CPOPJ		;IF N<0, IGNORE P.
	CHKEO	EO21,PUN1	;OLD STYLE P ALWAYS GIVES FORM FEED
	CAIE	T,"W"		;PW ALWAYS GIVES FORM FEED
	TXO	FF,F.NSRH	;OTHERWISE, FORM GOES OUT ONLY IF FORM CAME IN
PUN1:	PUSHJ	P,PUNCHR	;PUNCH OUT BUFFER
	SKIPE	COMCNT		;IF NO COMMANDS LEFT
	CAIE	T,"W"		;OR COMMAND IS NOT W
	JRST	PUN3		;READ NEXT PAGE
	CAIG	E,1		;ARG DOWN TO 1 YET?
	PUSHJ	P,RCH		;YES, THROW AWAY THE W
PUN4:	SKIPN	XCTING
	JRST	GO
	MOVE	C,Z
	CAMN	C,BEG		;EMPTY BUFFER?
	TXNN	FF,F.EOFI	;NO. QUIT ON EOF
	SOJG	E,PUN1		;YES. E:=E-1. DONE?
CPOPJ:	POPJ	P,		;YES

PUN2:	MOVE	OU,BEG		;IF NOTHING READ IN, CLEAR THE BUFFER
	MOVEM	OU,PT
	TXZ	FF,F.FORM	;AND THE FORM FEED FLAG
	JRST	YANK51		;SET Z=BEG & POPJ

PUNCHR:	MOVE	C,BEG		;OUTPUT DATA BUFFER.
	MOVE	B,Z
	MOVE	D,OUTCH
	CAME	B,C		;IS PAGE BUFFER EMPTY?
	JRST	PUNCH1		;NO
	TXNE	FF,F.FORM	;YES, IS THERE A FORM-FEED ON THIS BLANK PAGE?
	JRST	TYPE5		;YES, OUTPUT IT
	POPJ	P,
PUNCH1:	TXNN	FF,F.OOPN	;CAN WRITE?
	ERROR	E.NFO
	JRST	TYPE1
PUN3:	TXNE	FF,F.IOPN	;ANY INPUT FILE?
	TXNE	FF,F.EOFI	;DONT TRY TO READ IF NO DATA LEFT
	JRST	PUN2
	PUSHJ	P,YANK1		;RENEW BUFFER
	JRST	PUN4		;CONTINUE
	SUBTTL	J (Jump), R (Reverse) and C (Character) Commands

; nJ	Move the pointer to the right of the nth character in the
;	buffer.  (i.e., Give "." the value n.)
; J	Same as 0J.

JMP:	ADD	B,BEG		;PT:=N+BEG
	JRST	JMP1


; nR	Move the pointer backward n characters from the current
;	pointer position.

REVERS:	PUSHJ	P,CHK2		;MAKE SURE THERE IS AN ARGUMENT
	MOVNS	B		;B:=-C(B)
	SKIPA


; nC	Move the pointer forward n characters from the current
;	pointer position.

CHARAC:	PUSHJ	P,CHK2		;MAKE SURE THERE IS AN ARGUMENT
	ADD	B,PT		;B:=PT+C(B)

;If B lies between BEG and Z, store it in PT.

JMP1:	PUSHJ	P,CHK		;IS C(B) WITHIN DATA BUFFER?
	MOVEM	B,PT		;YES. PT:=C(B)
	JRST	RET
	SUBTTL	L (Line) Command

; nL	If n>0:	move pointer to the right, stopping when it has
;		passed over n EOL characters.
;	If n<0:	Move pointer to the left; stopping when it has passed
;		over n+1 EOL characters and then move it to the right
;		of the last EOL character passed over.
;
; L	Same as 1L.
;
; :nL	Will preform the same as a nL command except will place the
;	pointer before EOLs (and carraige-return if present) instead
;	of after.

LINE:	TXNE	FF,F.ARG2	;[1023] Error if there are 2 arguments
	ERROR	E.TAR		;[1023] Two arguments

	PUSHJ	P,GETARG	;[1016] C:=First string argument address
				;[1016] B:=Second string argument address
	XOR	B,C		;[1016] Remove the common address either upper
	XORM	B,PT		;[1016]  (-n) or lower (+n) and store the other
	TXZN	FF,F.COLN	;[1016] Skip if a colon was supplied
	JRST	LINE1		;[1023] Clear the argument flag and return

	MOVE	I,PT		;[1016] Get my current location
	SUBX	I,^D1		;[1016] Backup one character
	CAMGE	I,BEG		;[1016] Skip if still in the buffer
	JRST	LINE1		;[1023] Clear the argument flag and return
	PUSHJ	P,GET		;[1016] Get a character
	PUSHJ	P,CKEOL		;[1016] Skip if an E-O-L character
	 JRST	LINE1		;[1023] Clear the argument flag and return
	SOS	PT		;[1016] Account the E-O-L character
	SUBX	I,^D1		;[1016] Backup one more character
	CAMGE	I,BEG		;[1016] Skip if still in the buffer
	JRST	LINE1		;[1023] Clear the argument flag and return
	PUSHJ	P,GET		;[1016] Get the character
	CAXN	CH,.CHCRT	;[1016] Skip if not a carriage-return
	SOS	PT		;[1016] Account for the carriage-return
LINE1:	TXZ	FF,F.ARG	;[1023] Clear the argument flag
	POPJ	P,		;[1023] Return
	SUBTTL	K (Kill) and D (Delete) Commands

; nK	Perform nL but delete everything the pointer moves over.
; m,nK	Delete the (M+1)th through the nth character from the buffer.
;	The pointer is then put where the deletion took place.
; K	Same as 1K.

KILL:	TXNE	FF,F.COLN	;[1050] Skip no colon seen
	JRST	[PUSH  P,PT		;[1050] Save point for later
		 PUSHJ P,LINE		;[1050] Skip to end-of-line
		 POP   P,B		;[1050] Restore the old point
		 SUB   B,PT		;[1050] The number of char to delete
		 TXO   FF,F.ARG		;[1050] Set the argument flag
		 JRST  KILL2]		;[1050] Go delete the characters
KILL1:	PUSHJ	P,GETARG	;[1051] C:=First string arg. address
				;[1051] B:=Second string arg. address
	PUSHJ	P,CHK1		;C:=MAX(C(C),BEG), B:=MIN(C(B),Z)
	MOVEM	C,PT		;PT:=C(C)
	SUB	B,C		;B:=NO. OF CHARACTERS TO KILL.
KILL2:	JUMPE	B,CPOPJ		;[1050] If nothing to kill, return
	PFALL	DELETE		;[1001] Otherwise, fall into DELETE


; nD	Delete N characters from the buffer position.
;	If n>0:	Delete them just to the right of the pointer.
;	If n<0:	Delete them just to the left of the pointer.
; D	Same as 1D.

DELETE:	TXNE	FF,F.ARG2	;[1051] Skip only one argument
	JRST	KILL1		;[1051] Same as n,mK
	PUSHJ	P,CHK2		;MAKE SURE B CONTAINS AN ARGUMENT
DEL1:	MOVM	C,B
	MOVNS	C		;C:=-ABS(B)
	ADD	B,PT		;B:=PT+B
	PUSHJ	P,CHK		;STILL IN DATA BUFFER?
	CAMGE	B,PT		;YES. IS N NEGATIVE?
	MOVEM	B,PT		;YES. MOVE PT BACK FOR DELETION.
	PJRST	NROOM		;[1033] Move from PT+ABS(C) through Z down
				;[1033]  ABS(C) positions and return
	SUBTTL	Routine to Return Current Argument in B

;ROUTINE TO CHECK DATA BUFFER POINTER
;CALL	MOVE B,POINTER
;	PUSHJ P,CHK
;	RETURN IF B LIES BETWEEN BEG AND Z

CHK:	MOVE	TT,[MOVE B,SYL]
	MOVEM	TT,DLIM
	CAMG	B,Z
	CAMGE	B,BEG
	..ERROR	E.POP
	POPJ	P,


;ROUTINE TO PUT STRING ARGUMENT ADDRESSES WITHIN DATA BUFFER
;BOUNDS AND CHECK ORDER RELATION.
;CALL	MOVE C,FIRST STRING ARGUMENT ADDRESS
;	MOVE B,SECOND STRING ARGUMENT ADDRESS
;	PUSHJ P,CHK1
;	RETURN
;IF C>B, DOES NOT RETURN.
;C:=MIN(MAX(C,BEG),Z)
;B:=MIN(MAX(B,BEG),Z)

CHK1:	CAMLE	C,B		;C>B?
	ERROR	E.SAL
	CAMGE	C,BEG		;C:=MAX(C(C),BEG)
	MOVE	C,BEG
	CAMLE	C,Z		;C:=MIN(C(C),Z)
	MOVE	C,Z
	CAMGE	B,BEG		;B:=MAX(C(B),BEG)
	MOVE	B,BEG
	CAMLE	B,Z		;B:=MIN(C(B),Z)
	MOVE	B,Z
	POPJ	P,		;RETURN


;ASSUMES A VALUE OF 1 WITH SIGN OF LAST OPERATOR IF THERE IS NO CURRENT ARGUMENT
;CALL	PUSHJ P,CHK2
;	RETURN WITH B:=CURRENT ARG.,+1 OR -1

CHK2:	TXOE	FF,F.ARG	;IS THERE AN ARGUMENT?
	POPJ	P,		;YES. IT'S ALREADY IN B.
CHK22:	MOVEI	B,1		;B=1*SIGN OF LAST OP
	TXZE	FF,F.NEG	;WAS IT A MINUS SIGN?
	MOVNS	B		;YUP
	POPJ	P,		;RETURN

	SUBTTL	Searches -- Commands

;F Search

FCMD:	PUSHJ	P,SKRCH		;[334] Get char after F
	ERROR	E.MEF		;[334] F must be followed a char
	TXO	FF,F.SRCH	;[334] Set F-search flag
	CAIN	CH,"_"		;[1017] F_?
	JRST	LARR		;[1017] Yes
	TRZ	CH,40		;[334] Upper or lower case
	CAIN	CH,"S"		;[334] FS?
	JRST	SERCH		;[334] Yes
	CAIN	CH,"N"		;[334] FN?
	JRST	SERCHP		;[334] Yes
	TXZ	FF,F.SRCH	;[334] Must not be on
	CAIN	CH,"D"		;[1004] Find and Delete?
	JRST	FCMD0		;[1004] Yes
	CAIE	CH,"K"		;[1004] Find and Kill?
	ERROR	E.IFC		;[1004] No
	TXO	FF,F.KILL	;[1004] This is a kill
FCMD0:	TXO	F2,S.DELS	;[1004] This is a delete
	JRST	SERCH		;[334] S search only

;_ Search

LARR:	TXOA	FF,F.LARW	;[334] F.LARW:=1 for left arrow search

;N Search

SERCHP:	TXO	FF,F.NSRH	;[334] F.NSRH:=1 for N search

;S Search

SERCH:	MOVE	E,PT		;[334] Old point
	MOVEM	E,SAVEAC	;[334] Save in case the search fails
	MOVEM	E,UPPERB	;[342] PT is upper bound on backward searchs
	SETZ	E,		;[334] Assume first occurrence if bounded
	TXZE	FF,F.ARG2	;[334] Two args = bounded search
	JRST	BOUNDS		;[334] Bounded search
	SETZM	LOWERB		;[334] Save as default lower bound
	PUSHJ	P,CHK2		;[334] Get 1st arg
	SKIPE	B		;[334] Zero?
	JRST	SERC33		;[334] No
	TXNE	FF,F.ARG	;[334] There must be no arg
	ERROR	E.ISA		;[334] Invalid search argument
SERC33:	SKIPGE	E,B		;[334] Get arg where it wants it
	TXOA	F2,S.MINS	;[342] Minus search
	SETZM	UPPERB		;[342] No upper bound on forward searches
	JRST	SERCHA		;[334] Go do something useful
	SUBTTL	Searches -- Pattern Source Setup

;Here if bounded search, set up bounds

BOUNDS:	PUSHJ	P,GETAG6	;[334] Get the string pointers
	TXZ	FF,F.NSRH!F.LARW!F.ARG	;[334] FN + N go to FS and S
	CAMLE	C,Z		;[334] Too big
	MOVE	C,Z		;[334] Use Z then
	CAMGE	C,BEG		;[334] Too small
	MOVE	C,BEG		;[334] Use B then
	MOVEM	C,PT		;[334] Place to start searchin'
	CAML	B,C		;[334] Minus implied?
	JRST	SAVESH		;[334] No, save bounds
	EXCH	C,B		;[334] Yes, exchange args
	TXO	F2,S.MINS	;[334] Say minus search
SAVESH:	MOVEM	C,LOWERB	;[334] Save the lower bound
	MOVEM	B,UPPERB	;[334] Save the upper bound

;Adjust upper and lower bounds

SERCHA:	MOVE	A,BEG		;[334] Good lower bound
	MOVE	B,Z		;[334] Good upper bound
	CAMLE	A,LOWERB	;[334] Skip if the lower bound is big enough
	MOVEM	A,LOWERB	;[334] Use the beginning of the buffer
	CAMGE	B,LOWERB	;[334] Skip if the lower bound is small enough
	MOVEM	B,LOWERB	;[334] Use the end of the buffer
	SKIPE	UPPERB		;[334] Fix zero upper bound
	CAMGE	B,UPPERB	;[334] Skip if the upper bound is small enough
	MOVEM	B,UPPERB	;[334] Use the end of the buffer
	CAMLE	A,UPPERB	;[334] Skip if the upper bound is big enough
	MOVEM	A,UPPERB	;[334] Use the beginning of the buffer
	MOVMS	E		;[334] For correct minus serch
	MOVEI	CH,.CHESC	;[334] Use alt-mode delimiter if no @ seen
	TXZN	FF,F.SLSL	;[334] @ Seen?
	JRST	SERCHB		;[334] No, terminator = altmode
	PUSHJ	P,SKRCH		;[334] Yes, CH:=user specified delimiter
	ERROR	E.USR		;[334] Unterminated search command

;Determine whether we can use the previous pattern

SERCHB:	MOVEM	CH,B		;[334] B:=Pattern source string delimiter
	MOVEM	CH,ARGTRM	;[334] Save delimiter for FS insertion
	SETZM	SCNEST		;[334] Search nest level is zero

	PUSHJ	P,SKRCH		;[334] Look ahead 1 character
	ERROR	E.USR		;[334] Unterminated search command
	CAIE	CH,(B)		;[334] Is it the delimiter?
	JRST	SERCHT		;[334] No, an argument is given

	SKIPL	SRHCTR		;[334] Yes, use previous pattern string unless
				;[334]  there was none or last had error
	ERROR	E.SNA		;[334] Inital search with no argument
	SKIPN	SCTLGA		;[334] Remembered pattern source used ^Gi?
	JRST	SCH.E		;[334] Yes, use previous matrices
;Move a new pattern source to storage

SERCHT:	TXZ	F2,S.XMAT	;[344] Clear the exact match flag
	STORE	A,SMATRX,SMATRX+SCLRLN-1,0 ;[334] Clear previous matrices
	SETZM	SRHCTR		;[334] Clear source pattern length counter
	SETZM	SCTLGA		;[334] Assume pattern source doesn't use ^Gi
	MOVE	AA,[POINT 7,SRHARG] ;[334] Point to start of storage area
	JRST	SERCHD		;[334] 1st character already in

SERCHC:	PUSHJ	P,SKRCH		;[334] Get next character of pattern source
	ERROR	E.USR		;[334] Unterminated search command
SERCHD:	CHKEO	EO21,SERCHE	;[334] If EO=1, ^R is just text
	CAIE	CH,.CHCNR	;[334] ^R?
SERCHE:	CAIN	CH,.CHCNQ	;[334] ^Q?
	JRST	SERCHG		;[334] Yes, next character is text
	CAIN	CH,(B)		;[334] The delimiter?
	JRST	SERCH0		;[334] Yes
	CAIN	CH,.CHCNT	;[334] ^T?
	JRST	SERCHU		;[334] Yes
	TXNE	F2,S.NCCT	;[334] ^T flag on?
	JRST	SERCHF		;[334] Yes, ^V and ^W are just text
	CAIE	CH,.CHCNV	;[334] ^V?
	CAIN	CH,.CHCNW	;[334] ^W?
	TXO	F2,S.XMAT	;[334] Yes, set exact match flag

SERCHF:	AOS	A,SRHCTR	;[334] Bump string counter
	CAILE	A,^D80		;[334] Still fit in store?
	ERROR	E.STC		;[334] Search string too long
	IDPB	CH,AA		;[334] Yes, store character
	JRST	SERCHC		;[334]  and go back for more

SERCHG:	AOS	A,SRHCTR	;[334] Count the ^R (^Q)
	CAILE	A,^D80		;[334] Will it fit?
	ERROR	E.STC		;[334] Search string too long
	IDPB	CH,AA		;[334] Yes, store it
	PUSHJ	P,SKRCH		;[334] Get next character
	 ERROR	E.USR		;[334] Unterminated search command
	JRST	SERCHF		;[334] Store it as text

SERCHU:	TXC	F2,S.NCCT	;[334] ^T, complement control command switch
	JRST	SERCHF		;[334] Store it as text
	SUBTTL	Searches -- Set up Search Matrix

SERCH0:	TXZ	F2,S.NCCT	;[334] Refresh ^T flag
	MOVE	B,SRHCTR	;[334] Set source pattern length counter
	MOVE	AA,[POINT 7,SRHARG] ;[334]  and pointer
	MOVEI	D,0		;[334] Start at beginning of pattern

;Set up a 131 by 36 bit table based on  the  pattern  source.  The
; table  is implemented as a four word by 36 table, with the first
; 32 bits of the words used for the four  portions  of  the  ASCII
; character set (i.e.  0-37, 40-77, 100-137, 140-177) and three of
; the bits left over  in  the  last  word  used  for  the  "bogus"
; characters  BEGPAG, ENDPAG, and SPCTAB.  This is a little harder
; to set up for single letters in the pattern source, but is  much
; easier for ranges and makes the fast search algorithm setup much
; faster.  The table is then rotated into the old TECO 36  by  131
; bit table for the actual search matrix.

SCH.1:	ILDB	CH,AA		;[334] CH:=Next pattern source character
	SOJL	B,SCH.8		;[334] End of string?
	MOVEI	T,S2TABL	;[334] Check for control character in string
	TXNE	F2,S.NCCT	;[334] ^T flag on?
	MOVEI	T,S3TABL	;[334] Yes, use restricted table
	PUSHJ	P,DISP1		;[334] Go search table, don't return if found

	CHKEO	EO21,SCH.4	;[334] Not control, if EO=1, force exact mode
	TXNN	F2,S.NCCT	;[334] If ^T flag on, all characters are legal
	PUSHJ	P,CKNCC		;[334] Off, all other control characters
				;[334]  area illegal (Don't return if any)
SCH.2:	TXNE	F2,S.EMAT	;[334] Forced either match on?
	JRST	SCH.3		;[334] Yes, match either
	TXNN	F2,S.XMAT	;[334] No, want an exact match?
	TXNE	FF,F.PMAT	;[334] No, want global exact match?
	JRST	SCH.4		;[334] Asked for exact match

SCH.3:	CAIL	CH,"a"		;[334] Match either, is
	CAILE	CH,"z"		;[334]  it lower case?
	JRST	.+2		;[334] No
	SUBI	CH,"a"-"A"	;[334] Yes, make it upper case
	CAIL	CH,"A"		;[334] Is it upper?
	CAILE	CH,"Z"		;[334]  case?
	JRST	SCH.5		;[334] No
	MOVSI	TT1,400000	;[334] Yes, convert character to bit of 131
	MOVNI	TT,-"@"(CH)	;[334]  want - (<ch>-100) for LSH
	LSH	TT1,0(TT)	;[334] Position bit to letter range
	IORM	TT1,BITMAT+2(D)	;[334] Set match on upper case
	IORM	TT1,BITMAT+3(D)	;[334]  and lower case characters
	JRST	SCH.6		;[334]
SCH.4:	PUSHJ	P,CASE		;[334] Exact mode, adjust pattern char case

SCH.5:	MOVSI	T,400000	;[334] Convert character to bit of 131
	MOVE	TT,CH		;[334] Copy of character
	IDIVI	TT,^D32		;[334] Using 32 bits per word, figure word and
	ADDI	TT,0(D)		;[334]  bit word plus current pattern position
	MOVNS	TT1		;[334] Negative of remainder for bit shift
	LSH	T,0(TT1)	;[334] Position bit within 32 bit range
	IORM	T,BITMAT(TT)	;[334]  and include it in appropriate word

SCH.6:	SKIPE	SCNEST		;[334] Nested? (^N, ^E[], ^Gi)
	POPJ	P,		;[334] Yes, return to caller

	ADDI	D,4		;[334] End of a pattern position, on to next
	JUMPE	B,SCH.8		;[334] Done if no more characters in pattern
	CAILE	D,^D36*4	;[334]  and error if more than 36 positions
	ERROR	E.STL		;[334] Search string too long
	JRST	SCH.1		;[334] More pattern source, get some

;Finished building the 131 by 36 bit search table

SCH.8:	SKIPE	SCNEST		;[334] In a nest (^E[ with no ] or ^Gi)
	POPJ	P,		;[334] Yes, let caller carry on

	LSH	D,-2		;[334] Convert index to pattern length
	MOVEM	D,PATLEN	;[334]  and save it
	MOVNS	SRHCTR		;[334] A legal source pattern length
	JRST	ROTATE		;[334] Skip 131 by 36 build subs to ROTATE
;Control character dispatch table  for  second  scan  of  pattern
; source

S2TABL:	XWD	CNTLE,.CHCNE	;[334] ^E
	XWD	CNTLG,.CHBEL	;[334] ^G
	XWD	CNTLX,.CHCNX	;[334] ^X
	XWD	CNTLN,.CHCNN	;[334] ^N
	XWD	CNTLS,.CHCNS	;[334] ^S
	XWD	CNTLV,.CHCNV	;[334] ^V
	XWD	CNTLW,.CHCNW	;[334] ^W
	XWD	CNTLBS,.CHCBS	;[334] ^\
	XWD	CNTLCF,.CHCCF	;[334] ^^

;Shorter table used for ^T on mode starts here

S3TABL:	XWD	CNTLT,.CHCNT	;[334] ^T
	XWD	CNTLQ,.CHCNQ	;[334] ^Q
	XWD	CNTLR,.CHCNR	;[334] ^R
	XWD	CNTLLB,.CHESC	;[334] ESCape
	XWD	0,0		;[334] End of list


;Control-S matches any separator character (i.e.,  any  character
; not a letter, number, period, dollar, or percent)

CNTLS:	MOVX	T,<XWD	377777,777760>	;[334] All control characters
	IORM	T,BITMAT(D)		;[334]  except null
	MOVX	T,<XWD	747764,001760>	;[334] All non-symbol special
	IORM	T,BITMAT+1(D)		;[334]  character
	MOVX	T,<XWD	400000,000760>	;[334] Upper case range
	IORM	T,BITMAT+2(D)		;[334]  specials
	MOVX	T,<XWD	400000,000774>	;[334] Lower case range specials
	IORM	T,BITMAT+3(D)		;[334]  and end-of-page
	JRST	SCH.6		;[334] To next character

;Control-X matches any single character

CNTLX:	MOVX	T,<XWD	377777,777760>	;[334] All control characters
	IORM	T,BITMAT(D)		;[334]  except null
	TLO	T,400000	;[334] Plus space, @, grave,
	IORM	T,BITMAT+1(D)	;[334]  all specials and numbers,
	IORM	T,BITMAT+2(D)	;[334]  all upper case
	IORM	T,BITMAT+3(D)	;[334]  and all lower case
	JRST	SCH.6		;[334] To next character
;Control-R is the same as Control Q (Provided EO > 1)  except  it
; doesn't cause rubout problems

CNTLR:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^R is just text

;Control-Q causes the next character to be taken as text, even if
; it is a control character or the delimiter

CNTLQ:	ILDB	CH,AA		;[334] Get the next character
	SOJA	B,SCH.2		;[334]  and process it as ordinary text

;Control-V causes the next character to be made lower  case,  two
; control-V's set lower case mode until further notice

CNTLV:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^V is just text
	PUSHJ	P,C.V		;[334] Set ^V flags
	JRST	SCH.1		;[334]  and on to next character

;Control-W causes the next character to  be  taken  without  case
; conversion,  two  control-W's  set  standard  case  mode  until
; further notice

CNTLW:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^W is just text
	PUSHJ	P,C.W		;[334] Set ^W flags
	JRST	SCH.1		;[334]  and on to next character

;Control-\ inverts case match mode, starting at accept either

CNTLBS:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^\ is just text
	TXC	F2,S.EMAT	;[334] Complement accept either flag
	JRST	SCH.1		;[334]  and on to next character

;When  searching  for ALTmode under EO=1, both ESCape and ALTmode
; match

CNTLLB:	CHKEO	EO21,.+2	;[334] EO=1?
	JRST	SCH.5		;[334] No, accept ESCape only
	MOVEI	T,000040	;[334] Yes, mark ALTmode as an
	IORM	T,BITMAT+3(D)	;[334]  acceptable character
	JRST	SCH.5		;[334]  and ESCape

;Control-circumflex  causes  immediately  following  @[\]^_ to be
; converted to the appropriate character in the lower case range

CNTLCF:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^^ is just text
	JUMPE	B,SCH.1		;[344] If no next character, ignore
	ILDB	CH,AA		;[334] Get the next character
	PUSHJ	P,CVTSPC	;[334] Convert it to lower case if appropriate
	SOJA	B,SCH.2		;[334]  and go process it
;Control-T  inverts  the control character interpretation switch,
; the initial setting is that all control character commands  are
; active  with the switch on, only ^Q, ^R, and ^T commands exist,
; but all other control characters are legal

CNTLT:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^T is just text
	TXC	F2,S.NCCT	;[334] Complement current setting
	JRST	SCH.1		;[334]  and on to next character

;Control-N  invert  the  sense of the following "character", i.e.
; accept anything but the specified character

CNTLN:	MOVSI	T,-4		;[334] Set AOBJN count for the 4 words
	HRR	T,D		;[334]  of this position of the pattern
	PUSH	P,BITMAT(T)	;[334] Save the current status of the pattern
				;[334]  (in case of ^E[A,^N^EW] for example)
	SETZM	BITMAT(T)	;[334] Start over again
	AOBJN	T,.-2		;[334] Loop through this position

	AOS	SCNEST		;[334] Go up a level in complexity
	PUSHJ	P,SCH.1		;[334] Build the table for the character
	SOS	SCNEST		;[334] Now less complex

	MOVEI	T,4		;[334] Now go back through the 4 word
	MOVEI	TT,BITMAT+3(D)	;[334]  starting at the high end 'cause of
CTLN.1:	SETCM	TT1,0(TT)	;[334]  stack complementing the resulting
	TRZ	TT1,17		;[334]  setting (Note: 32 bits per word)
	POP	P,0(TT)		;[334] Get back the original bits
	IORM	TT1,0(TT)	;[334] Include the new bits wanted
	SUBI	TT,1		;[334] Back up to previous word (need a
	SOJG	T,CTLN.1	;[334]  AOBJN) and loop through all 4 words
	JRST	SCH.6		;[334] Done this "character" position
;Control-Gi  causes  the  text  in Q register i to be substituted
; into the search string at this point

CNTLG:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^G is just text
	ILDB	CH,AA		;[334] Get name of Q register
	SOJL	B,CNTLGR	;[334] If none there, error
	PUSH	PF,AA		;[334] Save source pointer (using Q stack)
	PUSH	PF,B		;[334]  and count
	AOS	SCNEST		;[334] Bump search nest level
	PUSH	P,CPTR		;[334] Set up CPTR in case of error (PAIN!)
	MOVEM	AA,CPTR		;[334]  so that error will get the right Q
	PUSHJ	P,QREGV2	;[334] Figure out which Q register
	PUSHJ	P,QTEXEI	;[334] Set up to read from it
	PUSHJ	P,GTQCNT	;[334] Set how long it is
	POP	P,CPTR		;[334] Restore CPTR
	MOVE	TT,I		;[334] Set up new byte pointer
	IDIVI	TT,5		;[334]  from bogus PT
	HLLZ	AA,BTAB-1(TT1)	;[334] Get byte pointer value
	HRR	AA,TT		;[334]  and quotient is address
	MOVE	B,C		;[334] Copy the string length from GTQCNT

CTLG.1:	PUSHJ	P,SCH.1		;[334] Go process the string as pattern source
	JUMPLE	B,CTLG.2	;[334] Done yet?
	ADDI	D,4		;[334] No, on to next character position
	CAILE	D,^D36*4	;[334] Full?   (see SCH.6)
	ERROR	E.STL		;[334] Search string too long
	JRST	CTLG.1		;[334] No, get next

CTLG.2:	POP	PF,B		;[334] Restore to scan
	POP	PF,AA		;[334]  after the ^Gi
	SOS	SCNEST		;[334] Nesting is back down one
	JRST	SCH.6		;[334]  and go do next character

CNTLGR:	ERROR	E.ICG		;[334] Illegal Control-G command
;Control-E commands all go through here

CNTLE:	CHKEO	EO21,SCH.5	;[334] If EO=1, ^E is just text
	ILDB	CH,AA		;[334] Get character after the ^E
	SOJL	B,$$$ICE	;[334] If none, an error
	MOVEI	T,S4TABL	;[334] Set to search for ^E command character
	PUSHJ	P,DISPAT	;[334]  and look for legal commands
$$$ICE:	ERROR	E.ICE		;[334] Illegal Control-E command

;Dispatch table for ^E commands

S4TABL:	XWD	CNTLEA,"A"	;[334] ^EA	accept any alpha
	XWD	CNTLEV,"V"	;[334] ^EV	accept any lower case alpha
	XWD	CNTLEW,"W"	;[334] ^EW	accept any upper case alpha
	XWD	CNTLED,"D"	;[334] ^ED	accept any digit
	XWD	CNTLEL,"L"	;[334] ^EL	accept any E-O-L character
	XWD	CNTLES,"S"	;[334] ^ES	accept a string of spaces/TABs
	XWD	CNTLER,"R"	;[1015] ^ER	accept any alphanumeric
	XWD	CNTLEN,74	;[334] ^E<NNN>	accept the ACSII char <nnn>
	XWD	CNTLEB,133	;[334] ^E[A,B,...] accept A or B or ...
	XWD	0,0		;[334] End of list


;Control-ER - accept any alphanumeric character

CNTLER:	MOVX	T,<XWD	000003,776000>  ;[1015] All
	IORM	T,BITMAT+1(D)		;[1015]  digits

;Control-EA - accept any alphabetic character

CNTLEA:	MOVX	T,<XWD	377777,777000>	;[334] All letters
	IORM	T,BITMAT+2(D)		;[334]  (upper case)

;Control-EV - accept any lower case alphabetic character

CNTLEV:	MOVX	T,<XWD	377777,777000>	;[334] All letters (lower
	IORM	T,BITMAT+3(D)		;[334]  case) and on to
	JRST	SCH.6			;[334]  next character

;Control-EW - accept any upper case alphabetic character

CNTLEW:	MOVX	T,<XWD	377777,777000>	;[334] All letters (upper
	IORM	T,BITMAT+2(D)		;[334]  case) and on to
	JRST	SCH.6			;[334]  next character

;Control-ED - accept any digit

CNTLED:	MOVX	T,<XWD	000003,776000>	;[334] All digits
	IORM	T,BITMAT+1(D)		;[334]  and on to
	JRST	SCH.6			;[334]  next character
;Control-EL - accept  any end of line character (including buffer
; end)

CNTLEL:	MOVX	T,<XWD	000340,000000>	;[334] LF, VT, FF
	IORM	T,BITMAT(D)		;[334]  and
	MOVX	T,<XWD	000000,000004>	;[334]  end-of-page
	IORM	T,BITMAT+3(D)		;[334]  and on to
	JRST	SCH.6			;[334]  next character

;Control-ES - accept any string of spaces and/or TABs

CNTLES:	MOVX	T,<XWD	000400,000000>	;[334] A TAB
	IORM	T,BITMAT(D)		;[334]  and a
	MOVX	T,<XWD	400000,000000>	;[334]  space
	IORM	T,BITMAT+1(D)		;[334]  and the
	MOVX	T,<XWD	000000,000002>	;[334]  special space/tab
	IORM	T,BITMAT+3(D)		;[334]  bit and on to
	JRST	SCH.6			;[334]  next character

;Control-E[a,b,c,...] - accept any of "characters" a or b or c

CNTLEB:	AOS	SCNEST		;[334] Up one nest level (down?)
CTEB.1:	PUSHJ	P,SCH.1		;[334] Process the next "character"
	ILDB	CH,AA		;[334] Get the next pattern source (if
				;[334]  already off end of string, will
				;[334]  catch that anyway at .+1)
	SOJL	B,$$$ICE	;[334] Error if off end of string
	CAIN	CH,","		;[334] Another "character" to come?
	JRST	CTEB.1		;[334] Yes, go include it too
	CAIE	CH,"]"		;[334] No, correct ending to ^E command?
	ERROR	E.ICE		;[334] Invalid Control-E command
	SOS	SCNEST		;[334] Yes, one fewer level of nesting now
	JRST	SCH.6		;[334]  and have finished a "char" position

;Control-E<nnn>  -  accept  the  ASCII  character  whose   octal
; representation is nnn

CNTLEN:	MOVEI	A,0		;[334] Clear number accumulator
CTEN.1:	ILDB	CH,AA		;[334] Get an OIT
	SOJL	B,$$$ICE	;[334] Error if run out
	CAIN	CH,">"		;[334] The other end of the number?
	JRST	CTEN.2		;[334] Yes, done
	CAIL	CH,"0"		;[334] Is it
	CAILE	CH,"7"		;[334]  an OIT?
	ERROR	E.ICE		;[334] Invalid Control-E command
	LSH	A,3		;[334] Yes, scale up the previous value
	ADDI	A,-60(CH)	;[334]  and add in the new OIT
	JRST	CTEN.1		;[334]  then go try for more

CTEN.2:	CAILE	A,177		;[334] Make sure it's legitimate
	ERROR	E.ICE		;[334] Invalid Control-E command
	MOVE	CH,A		;[334] Copy the result as the character
	JRST	SCH.5		;[334]  and go set the appropriate bit
;Now we need to build up TECO's standard search table,  a  36  bit
; by  131.  word table with each pattern position being a slice of
; the 131 words, with all of the acceptable  characters  for  each
; position  marked  by  a  bit on in the word reached by using the
; character directly as an index into the table (the extra 3 words
; are  for  "beginning of page", "end of page", and "this position
; matches strings of spaces and/or TABs").  At the  same  time  we
; will  set up the two simple tables for the fast search algorithm
; (DELTA0 and DELTA1), since it is much quicker to do this now  if
; we  use  the  fast one.  Since DELTA0 and DELTA1 are the same at
; all points except for entries which are not needed in DELTA1, we
; will  build them as one.  The conversion is done by rotating the
; 131.  bit by 36 word table 90 degrees.   Since  that  table  was
; built  first  (instead  of  the normal TECO table as in standard
; TECO), the loop is only needed for as many times as  there  were
; pattern  characters (doing it in the other order requires a loop
; through all 131 characters with no possibility for less).

;AC usage: (Other than poor, I want P1-P4)
; D       AOBJN  pointer with "virtual" index into 131 by 36 table
;         (word index/4)
; I       Actual word index into 131 by 36 table
; A       Bit  mask  specifying  pattern  position we're currently
;         doing
; AA      AOBJN  pointer  into the 131 bits of an entry of the 131
;         by 36 table
; TT+TT1  Current words worth of the 131 bits and the JFFO result

SLARGE==10777777		;[334] A special large number for DELTA0
				;[334]  used for the characters defining
				;[334]  the rightmost pattern position

ROTATE:	MOVN	D,PATLEN	;[334] Get the number of pattern positions
	HRLZS	D		;[334]  used as an AOBJN pointer
	MOVEI	I,0		;[334] Clear the actual index

	MOVE	A,PATLEN	;[334] Initialize DELTA0 and DELTA1 to the
	MOVEM	A,DELTA0	;[334]  number of positions in the pattern
	MOVE	AA,[XWD	DELTA0,DELTA0+1];[334]
	BLT	AA,DELTA0+SPCTAB	;[334]

	SUBI	A,1		;[334] Pattern length - 1 is the distance
	MOVEM	A,ROTLEN	;[334]  we are from the end of the pattern
				;[334]  at the moment
	MOVSI	A,400000	;[334] Start mask at first pattern position
ROTA.1:	MOVSI	AA,-BITMLN	;[334] Set AOBJN pointer into the 131 bits
ROTA.2:	SKIPE	TT,BITMAT(I)	;[334] Get 32 of those, seeing if any are on &
ROTA.3:	JFFO	TT,[		;[334]  if any are, see which the first one is

		MOVSI	CH,400000	;[334] Got one, make
		MOVN	T,TT1		;[334]  a make to
		LSH	CH,0(T)		;[334]  to turn it
		ANDCM	TT,CH		;[334]  off

		ADDI	TT1,0(AA)	;[334] Add 0, 32, 64, or 96 to the
		IORM	A,SMATRX(TT1)	;[334]  bit number and turn on the
					;[334]  position bit for the char
		SKIPN	CH,ROTLEN	;[334] Get the current distance from
					;[334]  the right end of the pattern
		MOVX	CH,SLARGE	;[334] Change to the special number
		MOVEM	CH,DELTA0(TT1)	;[334] Set that in fast loop table

		JRST	ROTA.3]		;[334] On to next bit

	ADDI	I,1		;[334] Finished a word of the 131 bit string
	ADDI	AA,^D31		;[334] Next word is 32 farther
				;[334]  into the 36 by 131 table
	AOBJN	AA,ROTA.2	;[334] Loop until all 131 bits done

	LSH	A,-1		;[334] On to the next pattern mask position
	SOS	ROTLEN		;[334]  and distance from the end and loop
	AOBJN	D,ROTA.1	;[334]  through all used pattern position
;Now determine which search method we will use.  If  ^ES  appeared
; we  have  to  use  the old slow method.  Initially if we need to
; match BEGPAG or ENDPAG, we will use the  old  method.   Also  we
; will  arbitrarily  select  3  as  the shortest string which will
; benefit from using the new search.  As  an  aid,  turn  off  the
; BEGPAG and ENDPAG bits which don't appear at the appropriate end
; of the pattern, since they obviously won't match except there.

FIGSCH:	SETZB	A,SCHTYP	;[334] Assume an old style search

	MOVN	D,PATLEN	;[334] Generate a bit mask for last pattern
	MOVSI	AA,400000	;[334]  position used in this search
	ANDM	AA,SMATRX+BEGPAG;[334]  (with a side effect of clearing
	LSH	AA,1(D)		;[334]  extra begin page bits)

	MOVE	D,PATLEN	;[334] Now see how long the pattern is
	CAILE	D,2		;[334] If it is fewer than 3 positions long,
	SKIPE	SMATRX+SPCTAB	;[334]  or if there were any ^ES positions,
	JRST	SCH.E		;[334]  just go use the old search

	ANDM	AA,SMATRX+ENDPAG;[334] We know pattern is longer than 1,
				;[334]  so clear extra end page bits
	SKIPN	SMATRX+BEGPAG	;[334] If either end of
	SKIPE	SMATRX+ENDPAG	;[334]  buffer will match
	JRST	SCH.E		;[334]  go use old search

	SETOM	SCHTYP		;[334] We win with the new one, remember that
				;[334]  in case this was an nSFOO$ type
;We  are  going  to  use  the  new  search, set up the more costly
; DELTA2 table.   This  table  is  based  on  the  arrangement  of
; characters   in   the   pattern.   It  uses  the  existence  (or
; non-existance) of matching substrings in the pattern to be  able
; to  shift the pattern farther than would be indicated by DELTA1,
; e.g.  if the pattern is  ACACACACACAABC  and  the  part  of  the
; searched  string  being examined is CABC, DELTA1 will only shift
; the pattern right 3 positions, while "looking"  at  the  pattern
; will  tell  a human observer that the pattern can be shifted its
; whole length without missing any possible matches.

;A few bits in B for use during the DELTA2 setup
NEDSET==1B35		;[334] This position of DELTA2 still needs setting up
WNTOFF==1B34		;[334] We shifted off the end of the pattern this pass
FSTIME==1B33		;[334] This is the first pass - use a special value
			;[334]  instead of having to initialize the index
			;[334]  matrix (INDMAT)

;AC usage (see comment at ROTATE)
; A       The highest entry currently being used in INDMAT
; AA      A  number  used  to  indicate how far the pattern can be
;         shifted when we find  a  mismatch  between   sub-pattern
;         strings
; B       Used for the above flag bits
; C       Index into INDMAT for updates to it as matches occur  in
;         sub-patterns
; CH      Index into INDMAT for loop
; I       Index  into  pattern  (*4  since  4  words  per  pattern
;         position)
; J       Temporary index into pattern (also *4)

;We  want  to  look  for  sub-strings  in  the  pattern   matching
; rightmost  sub-strings  of the pattern.  If none are found, then
; as in the above example when more than one pattern position  has
; been  matched  we  know  we  can  shift farther than to the next
; occurance of single pattern characters.   If  some  matches  are
; found then we can try them next immediately.  The examination is
; implemented by using an array  of  pointers  (indices  into  the
; pattern)  (INDMAT),  stored  in decreasing order and overwritten
; each pass by the pointers for the next pass.  When I  points  to
; the beginning of the rightmost n characters of the pattern, then
; each pointer in INDMAT points to the beginning of  a  sub-string
; which matches those n characters.  When INDMAT has been emptied,
; all of these sub-strings have  been  matched  and  the  rest  of
; DELTA2  can  be set to shift the pattern its entire length.  The
; initial setting of INDMAT (implemented by FSTIME) is  such  that
; every pattern position is examined on the first pass.

	MOVEI	A,-1(D)		;[334] The top of INDMAT at pattern length - 1
	MOVEI	AA,-1(D)	;[334] Start the non-match shift at pattern
				;[334]  length (adjusted because a 0-index
				;[334]  is subtracted from it)
	MOVX	B,NEDSET!FSTIME	;[334] The first setting is needs setting, 1st
				;[334]  pass, and haven't gone off the end

	MOVEI	I,-1(D)		;[334] Start at right end of pattern, 0-index
	LSH	I,2		;[334]  adjusted for being 4 word bit strings
	MOVEI	D,0(I)		;[334] Set initial INDMAT value to shift all
				;[334]  less 1 remembering the first SUBI 4
SET2.2:	MOVEI	C,0		;[334] Start used INDMAT entry index off
	MOVN	CH,A		;[334] Make an AOBJN pointer for
	HRLZS	CH		;[334]  loop through INDMAT

SET2.3:	TXNN	B,FSTIME	;[334] Get the appropriate INDMAT entry
	SKIPA	D,INDMAT(CH)	;[334] Not the first time, use the real array
	SUBI	D,4		;[334] The first pass, use our fake value

	MOVE	TT,BITMAT(I)	;[334] Figure out if any of the characters
	AND	TT,BITMAT(D)	;[334]  matched by the position we are looking
	MOVE	TT1,BITMAT+1(I)	;[334]  at, at highest level (I) match at the
	AND	TT1,BITMAT+1(D)	;[334]  position idicated by the substring
	OR	TT,TT1		;[334]  table (INDMAT - D)
	MOVE	TT1,BITMAT+2(I)	;[334] (AND the strings
	AND	TT1,BITMAT+2(D)	;[334]  together, if
	OR	TT,TT1		;[334]  the result is
	MOVE	TT1,BITMAT+3(I)	;[334]  zero then no
	AND	TT1,BITMAT+3(D)	;[334]  characters
	OR	TT,TT1		;[334]  match!!!)
	JUMPE	TT,SET2.5	;[334] If zero, no matches here

	JUMPE	D,SET2.4	;[334] Did we match with leftmost position?
	MOVEI	T,-4(D)		;[334] No, update the index matrix to check
	MOVEM	T,INDMAT(C)	;[334]  substrings in front of this
	AOSA	C		;[334] We used another element of INDMAT

SET2.4:	TXO	B,WNTOFF	;[334] We matched at the left end,
				;[334]  that goes off the end
SET2.5:	TXNN	B,NEDSET	;[334] Do we still need to set up position?
	JRST	SET2.6		;[334] No, skip all the logical stuff
	MOVE	TT,BITMAT(D)	;[334] Yes, then we need
	ANDCM	TT,BITMAT(I)	;[334]  to figure out if
	MOVE	TT1,BITMAT+1(D)	;[334]  the substring
	ANDCM	TT1,BITMAT+1(I)	;[334]  indicated position
	OR	TT,TT1		;[334]  (D) character set
	MOVE	TT1,BITMAT+2(D)	;[334]  is a subset of the
	ANDCM	TT1,BITMAT+2(I)	;[334]  of the high level
	OR	TT,TT1		;[334]  (I) character set
	MOVE	TT1,BITMAT+3(D) ;[334]  (Done by:
	ANDCM	TT1,BITMAT+3(I)	;[334]     D .AND. .NOT.
	OR	TT,TT1		;[334]     I .NE. 0)
	JUMPE	TT,SET2.6	;[334] Skip out if it's not
	TXZ	B,NEDSET	;[334] It is, don't do this again
	MOVNI	T,4(D)		;[334] We know that we can shift at least at
	ASH	T,-2		;[334]  much as the distance from here to the
	ADD	T,PATLEN	;[334]  right end since no substrings matched
	MOVE	TT1,I		;[334] Figure out where to put
	LSH	TT1,-2		;[334]  it with a word table
	MOVEM	T,DELTA2(TT1)	;[334] Put it there
SET2.6:	AOBJN	CH,SET2.3	;[334] Loop through current index matrix
	TXZ	B,FSTIME	;[334] Finished the first pass
	MOVE	A,C		;[334] Remember the highest index
				;[334]  matrix element used
	TXOE	B,NEDSET	;[334] Do we still need to set this position?
	JRST	[			;[334] Yes
		MOVE	T,AA		;[334] Then we can shift
		MOVE	TT,I		;[334]  it based on how
		LSH	TT,-2		;[334]  far the highest
		SUB	T,TT		;[334]  level loop is
		ADD	T,PATLEN	;[334]  from the right
		MOVEM	T,DELTA2(TT)	;[334]  end of the
		JRST	.+1]		;[334]  pattern

	TXZE	B,WNTOFF	;[334] Did pass go off the end of the pattern
	JRST	[			;[334] Yes, need to adjust the amount
		MOVEI	AA,-4(I)	;[334]  we can shift when NEDSET is
		LSH	AA,-2		;[334]  used immediately above
		JRST	.+1]		;[334]

	SUBI	I,4		;[334] Now look a position to the left of last
	SKIPE	A		;[334]  unless there is no need to cause no
	JUMPGE	I,SET2.2	;[334]  matches or because we looked at all
				;[334]  of them
	JUMPL	I,SET2.E	;[334] Did we look at all of them?

	ADD	AA,PATLEN	;[334] No, need to fill in the rest with the
	LSH	I,-2		;[334]  largest possible number based on how
	SUB	AA,I		;[334]  fare we are from the right end of the
				;[334]  pattern and how far the setup got
	MOVEM	AA,DELTA2(I)	;[334] Save for later
	ADDI	AA,1		;[334] Each position to the left can shift one
	SOJGE	I,.-2		;[334] Loop until finished

SET2.E:				;[334]
;Now, if F search, scan insert argument

SCH.E:	TXNN	FF,F.SRCH	;[334] An F search?
	JRST	WCHSCH		;[334] No, go start search

	TXZ	F2,S.NCCT	;[334] Refresh ^T flag
	MOVE	CH,ARGTRM	;[334] Get delimiter back
	TXZ	FF,F.NNUL	;[334] Reset non-null string flag
	JRST	INSERA		;[334] Go scan insert argument

SERCHJ:	POP	P,COMBAK	;[334] Save pointers for
	POP	P,CPTBAK	;[334]  the insertion and
	PFALL	WCHSCH		;[334]  fall into search

;Here to call the appropriate search

WCHSCH:	TXNN	F2,S.MINS	;[334] Skip if this is a minus search
	SKIPN	SCHTYP		;[334] Skip if we can user the new search
	JRST	SLOSCH		;[334] Use the old search algorithm
	PFALL	FSTSCH		;[334] Fall into the new search algorithm
	SUBTTL	Searches -- New Fast Search Routine

;This is an implementation of the algorithm of  Boyer  and  Moore,
; published in the Communications of the ACM, October 1977, Volume
; 20 Number 10, page 762.  This  article  serves  as  the  primary
; documentation  for  this  routine  (and  the DELTA?  table setup
; routines).

;This  is  the  actual  search,  which uses the numbers in DELTA0,
; DELTA1, and DELTA2 for determining where in the searched  string
; to look.  The actual character comparisons are done in the tried
; and  true TECO way, with TECO's original bit map (there can't be
; a better way).

;AC usage (ditto)
; A       During the slow loop, counts down through the pattern
; AA      Contains the bit mask for the last pattern position
; B       The base register into the byte pointer table, including
;         (C)
; C       A negative index into the byte pointer table
; D       The length of the string to be searched
; T       During the slow loop, shifts the bit  mask  through  the
;         pattern
; TT      The word address of the first byte of the portion of the
;         searched string currently being examined
; TT1     The value of C at the start of the current FAST and SLOW
;         loop execution

;The bytes in the searched string are obtained  through  a  window
; by  a  table of constant byte pointers indexed into by B, C, and
; TT.

FSTSCH:	MOVN	T,PATLEN	;[334] Generate the bit mask
	MOVSI	AA,400000	;[334]  for the rightmost
	LSH	AA,1(T)		;[334]  pattern position

	MOVE	I,PT		;[334] Start searching at .

	MOVE	D,UPPERB	;[334] Figure out how many characters
	SUB	D,I		;[334]  are to be searched
	ADDI	D,1		;[334] Note:  That all this code must use full
				;[334]  word arithmetic when referring to I,
				;[334]  since its maximum value is 128K * 5
				;[334]  characters!!!

	TXNE	FF,F.ARG	;[334] Is this an nSFOO$$?
	JUMPLE	E,FND		;[334] Yes, done if we've found that many

	MOVX	B,<0(C)>	;[334] Start the byte pointer base at 0(C)

FSTS.1:	MOVE	TT,I		;[334] Convert I into a word
	IDIVI	TT,5		;[334]  and byte address

	MOVE	T,D		;[334] Figure the current byte pointer window
	CAILE	T,SCHBPL	;[334]  length the length of string left or
	MOVEI	T,SCHBPL	;[334]  the window size, whichever is less

				;[334] Fall through to next page ...
	MOVN	C,T		;[334] Copy that as negative index into table
	ADD	T,TT1		;[334] Add the byte in word offset plus the
	ADDI	T,SCHBPT-1	;[334]  address of the start of the table
	HRR	B,T		;[334]  equals the base address to be
				;[334]  negatively indexed from

	ADD	C,PATLEN	;[334] This search starts at the right end
	JUMPG	C,NOFND3	;[334] If that is to the right of the last
				;[334]  character of the string, then we
				;[334]  didn't find it

	MOVE	TT1,C		;[334] Save C at the start of the loop, so we
				;[334]  can tell how many chars we've skipped

;[334] FAST:				;** The FAST loop in the ACM article **
FSTS.3:	LDB	CH,@B		;[334] Get a char from the searched string
	ADD	C,DELTA0(CH)	;[334] Shift down based on its existance in
	JUMPLE	C,FSTS.3	;[334]  the pattern and loop unless it is in
				;[334]  the rightmost position

	TLON	C,-1		;[334] Did it match
	JRST	FSTS.5		;[334] No, we used up our window

	MOVE	T,AA		;[334] Start at right end of pattern bit
	MOVE	A,PATLEN	;[334]  mask for that many characters

;[334] SLOW:				;** The SLOW loop in the ACM article **
FSTS.4:	SOJLE	A,FSTS.6	;[334] A match if we run out of pattern char
	LSH	T,1		;[334] Set bit mask to previous pattern
	LDB	CH,@B		;[334] Get the next searched string character
	TDNE	T,SMATRX(CH)	;[334] Does it match?
	SOJA	C,FSTS.4	;[334] Yes, back up pointer index one and loop

	MOVE	T,DELTA0(CH)	;[334] No, which table shift us the most
	TLNN	T,-1		;[334] If we just got SLARGE, use DELTA2
	CAMGE	T,DELTA2-1(A)	;[334]
	MOVE	T,DELTA2-1(A)	;[334]
	ADD	C,T		;[334] Update our current position by
	JUMPL	C,FSTS.3	;[334]  than much and go back to FAST
				;[334]  unless we exceeded window
;Search failed in this window, see what to do

FSTS.5:	JUMPLE	D,NOFND3	;[334] Not found if there is no
				;[334]  searched string left

	SUB	C,TT1		;[334] See how many characters we skipped
	ADDI	I,0(C)		;[334] Update current position by that much
	SUBI	D,0(C)		;[334]  and amount left by that much
	JRST	FSTS.1		;[334]  and try again

;Here when string found, decide where the right end of the pattern is

FSTS.6:	SUB	C,TT1		;[334] How much we moved
	ADD	I,C		;[334] Adjust pointer by that much
	ADD	I,PATLEN	;[334]  but we scanned back by that much too
	MOVEM	I,PT		;[334] Update . to that point
	ADD	I,PATLEN	;[334] Now get to right end of pattern
	JRST	FND		;[334] We did it

;Build  the fixed byte pointer table.  The following code is done
; again under an XLIST

SCHBPL==^D200			;[334] Length of window of byte pointers
$A==0				;[334] Start the base address at zero

;SCHBPT:REPEAT	SCHBPL/5+1,<	;Build 5 for each word of bytes, plus extra for
;				; the fact that the first byte may be one of 5
;	$M==177B6		;A mask for the current character of the word
;		REPEAT	5,<		;For each word of bytes
;			$POINT	$A(TT),$M	;Build 5 pointers
;		$M==$M_-7			;Moving mask each time
;		>
;	$A==$A+1		;To next word
;	>

	XLIST			;[334]
SCHBPT:				;[334]
IF1,<				;[334]
	BLOCK	SCHBPL+5	;[334]
>				;[334]
IF2,<				;[334]
	REPEAT	SCHBPL/5+1,<	;[334] ;
$M==177B6			;[334] ;
	REPEAT	5,<		;[334]
	$POINT	$A(TT),$M	;[334][1001]
$M==$M_-7			;[334]
>				;[334]
$A==$A+1			;[334]
>				;[334]
>				;[334]
	LIST			;[334]
	SUBTTL	Searches -- Old Slow But Sure Routine

SLOSCH:
SERCH1:	MOVN	T,PATLEN	;[334] Figure old end of search comparator
	MOVSI	AA,400000	;[334]
	LSH	AA,0(T)		;[334] Which is bit one past end of pattern
	MOVE	I,PT		;[334] Start searching at PT
S1:	TXNE	FF,F.ARG	;[334] Is there an argument?
	JUMPLE	E,FND		;[334] Yes, seen string N times?
	MOVE	TT,I		;[334] No, form byte pointer which will be
	SUBI	TT,1		;[334] Incremented before use
	IDIVI	TT,5		;[334]
	HLL	TT,BTAB(TT1)	;[334]
	CAMG	I,BEG		;[334] At beginning of buffer?
	SKIPL	SMATRX+BEGPAG	;[334] 1st serch char = beginning of buffer
	JRST	S3		;[334] No
	MOVSI	D,200000	;[334] Yes, start search at 2nd search char
	MOVE	TT1,TT		;[334] Set dynamic pointer = static pointer
	SETOM	BCOUNT		;[334] Flag 1st is BEGPAG
	JRST	S4B		;[334] Enter search loop

S3:	MOVSI	D,400000	;[334] Start seeking match for 1st char
	MOVE	TT1,TT		;[334] Set dynamic pointer = static pointer
	JRST	S4A		;[334]
S4:	TDNE	D,SMATRX+SPCTAB	;[334] Is space/tab string bit set?
	JRST	SPTB		;[334] Yes
S4E:	CAML	I,UPPERB	;[334] Don't allow I outside bounds
	JRST	S4D		;[334] ...
	ADDI	I,1		;[334] Look at next loc, xcept 1st time thru
S4C:	LSH	D,-1		;[334] Advance to next char position
S4B:	CAMN	D,AA		;[334] End of search table?
	JRST	FND		;[334] Yes
S4A:	ILDB	CH,TT1		;[334] No, get next char
	TDNE	D,SMATRX(CH)	;[334] Is it a match?
	JRST	S4		;[334] Yes, go to next table entry
S4D:	AOSN	BCOUNT		;[334] If we failed with BEGPAG
	JRST	S3		;[334] Then try again with 1st char
	TXNE	F2,S.MINS	;[334] Backwards search?
	JRST	SR4A		;[334] Yes
	CAML	I,UPPERB	;[334] No, too far?
	JRST	NOFND		;[334] Yes
	AOS	I,PT		;[334] No, PT:=PT+1
	IBP	TT		;[334] Move static byte pointer
	JRST	S3		;[334] Keep looking
SR4A:	SOS	I,PT		;[334] Decrement PT
	CAMGE	I,LOWERB	;[334] Done
	JRST	NOFND		;[334] Yes
	ADD	TT,[7B5]	;[334] Previous byte (maybe)
	JUMPGE	TT,S3		;[334] Definitely
	HRLI	TT,(POINT 7,,34);[334] Fix
	SOJA	TT,S3		;[334] Decrement and go
;Skip over a string of spaces and/or TABs while searching

SPTB:	CAIE	CH," "		;[334] But was the char we matched a space
	CAIN	CH,.CHTAB	;[334]  or a TAB?
	JRST	SPTB.1		;[334] Yes, then accept more
	JRST	S4E		;[334] No, look at next pattern position
SPTB.1:	ADDI	I,1		;[334] Advance to next buffer location
	CAML	I,UPPERB	;[334] End of buffer?
	JRST	S4C		;[334] Yes, no more then
	MOVEM	TT1,ERR1	;[334] Save current byte pointer
	ILDB	CH,TT1		;[334] Look at next character
	CAIE	CH," "		;[334] Is it a space
	CAIN	CH,.CHTAB	;[334]  or a TAB?
	JRST	SPTB.1		;[334] Yes, keep on trucking
	MOVE	TT1,ERR1	;[334] No, end of string, restore pointer
	JRST	S4C		;[334]  and continue search
	SUBTTL	Searches -- Pattern Found

FND:	SETOM	SFINDF		;[334] No, SFINDF:=-1
	MOVE	A,I		;[334]
	SUB	A,PT		;[334] Compute length of search arg
	MOVE	B,I		;[334] Save current pointer
	TXNN	F2,S.MINS	;[334]
	JRST	NOTMIN		;[334]
	SOSA	I,PT		;[334]
	JRST	WCHSCH		;[334] No, continue search
NOTMIN:	MOVEM	I,PT		;[334] Else go forward
	SOJG	E,WCHSCH	;[334] Try again if haven't found it N times
	MOVEM	B,PT		;[334]
	TXZE	F2,S.DELS	;[1033] FD or FK?
	JRST	FND7		;[1004] Go do the FD and FK stuff
	TXNN	FF,F.SRCH	;[334] F-search?
	JRST	FND3		;[334] No
	MOVE	C,VVAL		;[334] Yes, get insert size
	SUB	C,A		;[334] [321]Insert minus delete
	MOVNS	A		;[334] Set PT to beginning of string found
	ADDM	A,PT		;[334]
	PUSHJ	P,NROOM		;[334] Stretch or scrunch the hole
	MOVE	B,ARGTRM	;[334] Get terminator to look for
	MOVE	A,COMBAK	;[334] Reset COMCNT &
	MOVEM	A,COMCNT	;[334]  CPTR to beginning
	MOVE	A,CPTBAK	;[334]  of the insert
	MOVEM	A,CPTR		;[334]  argument
	TXZ	F2,S.CTLV!S.CTVV!S.CTLW!S.CTWW!S.EMAT!S.NCCT  ;[1006]
				;[1006] Clear some upper/lower flags
	PUSHJ	P,INS1B		;[334] Insert the 2nd arg
	PUSHJ	P,ZEROTT	;[334] Do auto-type if required
	MOVE	CH,ARGTRM	;[334]
	TXZN	FF,F.NNUL	;[334] Was there a non-null insert?
	CAIE	CH,.CHESC	;[334] Altmode terminator?
	JRST	FND2		;[334] No
	TXO	F2,S.NRAD	;[334] Flag so 2nd altmode stays around
	JRST	ALTM1		;[334] Yes, FS<string>$$ terminates execution

FND7:	TXZN	FF,F.KILL	;[1004] Skip if FK command
	JRST	FND6		;[1004] Go handle FD command
	MOVE	B,SAVEAC	;[1004] Get old PT
	SUB	B,PT		;[1004] Minus point after search
	JRST	FND5		;[1033] Go delete some text
FND6:	MOVN	B,A		;[1004] Get the length of the string
FND5:	PUSHJ	P,DEL1		;[1033] Delete some text
	JRST	FND2		;[1033] See if colon modifier was present
FND3:				;[334]
IFN VC,<MOVEM	A,VVAL>		;[334] Save length of string
	PUSHJ	P,ZEROTT	;[334] Auto-type
FND2:	TXZE	FF,F.COLN	;[334] Colon modifier?
	JRST	FFOK		;[334] Yes, return value
	CHKEO	EODEC,FND4	;[344] If old TECO, must check for < ... >
	JRST	RET		;[344] Don't return a value
FND4:	SKIPL	(P)		;[334] In an iteration?
	JRST	RET		;[334] No, return no value

FFOK:	MOVNI	A,1		;[334] Yes, return value of -1
	JRST	VALRET		;[334]
	SUBTTL	Searches -- Autotype After Succesful Searches

;If AUTOF is non-zero
;Include pointer marker = ASCII char in AUTOF if AUTOF > 0

ZEROTT:	TXNE	FF,F.COLN	;[334] No auto-type on colon searches
	POPJ	P,		;[334] Return
	SKIPL	-1(P)		;[334] In an iteration?
	SKIPN	AUTOF		;[334] Auto-type wanted?
	POPJ	P,		;[334] Return

	TXO	FF,F.ARG	;[334] Do 0T$$
	SETZ	B,		;[334] ...
	PUSHJ	P,TYPE		;[334] ...
	HRRZ	CH,AUTOF	;[334] Get the marker character
	SKIPL	AUTOF		;[334] Is the marker character wanted?
	PUSHJ	P,TYOM		;[334] Yes
	MOVEI	B,1		;[334] Do 1T$$
	PUSHJ	P,TYPE		;[334] Return
	TXZ	FF,F.ARG	;[334] Clear the flag
	POPJ	P,		;[334] Return
	SUBTTL	Searches -- Pattern Not Found in this Buffer

NOFND:	TDNN	D,SMATRX+ENDPAG	;[344] ENDPAG good for a match here?
	JRST	NOFND3		;[334] No
	CAMN	I,Z		;[344] Yes, but only if we're at Z
	JRST	FND		;[334] ENDPAG matches!
NOFND3:	MOVE	I,BEG		;[334] Search failed
	MOVEM	I,PT		;[334] PT=BEG
	SETZM	SFINDF		;[334] SFINDF=0
	TXNN	F2,S.MINS	;[334] Does this needs to look at a new buffer
	TXNN	FF,F.NSRH!F.LARW;[334] Minus searches never do, but N and _ do
	JRST	RESTPT		;[334] No new buffer, the search lost

	MOVEM	E,SRHCNT	;[334] Yes, save search count
	MOVEI	B,1		;[334] "Punch" 1 page only
	TXNE	FF,F.NSRH	;[334] N search?
	PUSHJ	P,PUNCHA	;[334] Yes, punch this buffer and refill it
	TXNN	FF,F.IOPN	;[334] Any input file?
	JRST	BEGIN1		;[334] No
	TXNE	FF,F.EOFI	;[334] More data?
	TXNE	FF,F.FORM	;[334]
	JRST	NOFND4		;[334] Yes
	MOVE	E,BEG		;[334] EOF & no form seen
	CAMN	E,Z		;[334] Check buffer contents
	JRST	BEGIN1		;[334] No more data

NOFND4:	TXNE	FF,F.LARW	;[334] Left arrow search?
	PUSHJ	P,YANK1		;[334] Yes, fill buffer
	MOVE	E,SRHCNT	;[334] Restore search count
	MOVE	A,BEG		;[334]
	MOVEM	A,LOWERB	;[334]
	MOVE	A,Z		;[334]
	MOVEM	A,UPPERB	;[334]
	JRST	WCHSCH		;[334] Go do search with this buffer full
RESTPT:	CHKEO	EODEC,BEGIN1	;[335] Leave the pointer at top for EO
				;[335]  of 2 or less
	MOVE	A,SAVEAC	;[334] Get old PT
	MOVEM	A,PT		;[334] Restore it

BEGIN1:	TXZ	FF,F.NSRH+F.LARW;[344] Clear N and _ flags
	TXNN	FF,F.SRCH	;[334] F-search?
	JRST	NOFND5		;[344] No
	MOVE	CH,ARGTRM	;[334] Get insert terminator
	TXZN	FF,F.NNUL	;[334] Was it a null insert?
	CAIE	CH,.CHESC	;[334] Yes, was it an altmode terminator?
	JRST	NOFND5		;[344] No
	TXO	F2,S.NRAD	;[344] Flag so second altmode gets put in *i

NOFND5:	TXZE	FF,F.COLN	;[344] Colon modified?
	JRST	NOFND6		;[344] Yes, return a 0
NOFND2:	SKIPL	(P)		;[344] In an iteration?
	ERROR	E.SRH		;[344] No, Give an error message
	CHKEO	EODEC,NOFND6	;[344] If old TECO, return 0
	TXNN	F2,S.NRAD	;[344] Null Insert?
	JRST	RET		;[344] No, new teco returns nothing
	JRST	ALTM1		;[344] Yes, end of command

NOFND6:	TXNE	F2,S.NRAD	;[344] Null Insert?
	JRST	ALTM1		;[344] Yes, end of command
	JRST	BEGIN		;[344] No, return a 0


SRHMOD:	EXP	SRCHSW		;[334] Default search mode
	SUBTTL	<> (Iteration) Commands	

; <>	Iteration brackets.  Command interpretation is sent back
;	to the < when the > is encountered.

LSSTH:	PUSH	P,ITERCT	;SAVE ITERATION COUNT
	PUSH	P,COMAX		;KEEP MAX FOR GARBAGE COLLECTION
	PUSH	P,CPTR		;SAVE COMMAND STATE
	PUSH	P,COMCNT
	SETOM	ITERCT		;ITERCT:=-1
	PUSH	P,ITERCT	;-1 FLAGS ITERATION ON PDL
	TXZN	FF,F.ARG	;IS THERE AN ARGUMENT?
	JRST	RET		;NO
	JUMPLE	B,INCMA1	;IF ARG NOT > 0, SKIP OVER <>
	MOVEM	B,ITERCT	;YES. ITERCT:=ARGUMENT
	JRST	RET


GRTH:	SKIPN	XCTING		;CONTINUE?
	JRST	GO
	SKIPGE	A,(P)		;IS THERE A LEFT ANGLE BRACKET?
	JRST	GRTH2		;YES. OTHERWISE ITS A MISSING < OR
	SOJE	A,GRTH9		;SOMETHING LIKE <...(...>
	ERROR	E.MLA
GRTH2:	SOSN	ITERCT		;ITERCT:=ITERCT-1. DONE?
	JRST	INCMA2		;YES
	MOVE	A,-2(P)		;NO. RESTORE COMMAND STATE TO START OF ITERATION.
	MOVEM	A,CPTR
	MOVE	A,-1(P)
	MOVEM	A,COMCNT
	TXNE	FF,F.TRAC	;TRACING?
	PUSHJ	P,CRR		;YES. OUTPUT CRLF
	JRST	RET

GRTH9:	ERROR	E.MRP
; ;	If not in an iteration, gives error.  If in an iteration
;	and if the most recent search failed, send command to first
;	unmatched > to the right.  Otherwise, no effect.

SEMICL:	SKIPL	(P)		;ERROR IF NOT IN <...>
	ERROR	E.SNI
	TXNN	FF,F.ARG	;YES. IF NO ARG,
	MOVE	B,SFINDF	;USE LAST SEARCH SWITCH (0 OR -1).
	JUMPL	B,CD		;IF ARG <0, JUST RET + EXECUTE LOOP
INCMA1:	MOVEI	TT,">"		;SKAN FOR >
	MOVEI	TT1,"<"		;IGNORE <...> STRINGS
	PUSHJ	P,SKAN

	ERROR	E.MRA
INCMA2:	SUB	P,[XWD 3,3]	;POP OUT A LEVEL
	POP	P,COMAX		;RESTORE MAX. COUNT
	POP	P,ITERCT
	JRST	RET



; !tag!	Tag definition.  The tag is a name for the location it
;	appears in in a macro, iteration or command string.

EXCLAM:	PUSHJ	P,SKRCH		;LOOK FOR NEXT !
	ERROR	E.UTG
	CAIE	CH,"!"
	JRST	EXCLAM
	JRST	RET
	SUBTTL	O (Goto) Command	

; Otag$	Go to the tag named TAG.  The tag must appear in the
;	current macro or command string.

OG:	MOVE	A,CPTR
	MOVE	AA,A
	IDIVI	AA,17
	CAMN	A,SYMS(B)
	JRST	OGFND
	SKIPN	SYMS(B)
	JRST	OGNF
	CAMN	A,SYMS+1(B)

ES1:	AOJA	B,OGFND
	SKIPN	SYMS+1(B)
ES2:	AOJA	B,OGNF
	CAMN	A,SYMS+2(B)
	AOJA	B,ES1
	SKIPN	SYMS+2(B)
	ADDI	B,2

OGNF:	PUSH	P,CPTR
	PUSH	P,B
	MOVEI	D,STAB
OG1:	PUSHJ	P,SKRCH		;GET NEXT COMMAND CHAR

	ERROR	E.MEO
	CAIL	D,STAB+STABLN-1	;DON'T RAVAGE YOURSELF
	ERROR	E.TTL
	MOVEM	CH,(D)		;STAB ... _ TAG
	CAIE	CH,.CHESC
	AOJA	D,OG1
	MOVEI	A,"!"		;TAG TERMINATOR
	MOVEM	A,(D)
	SETZM	1(D)
	MOVE	B,COMCNT	;MAKE PTR TO START OF THIS COMMAND LEVEL
	SUB	B,COMAX
	IDIVI	B,5
	ADD	B,CPTR
	JUMPE	E,OG7		;NO REMAINDER
	SOS	B
	MOVMS	E
	JRST	.(E)
	IBP	B
	IBP	B
	IBP	B
	IBP	B
OG7:	MOVEM	B,CPTR
	MOVE	B,COMAX		;GET # OF CMD CHARS AT THIS LEVEL
	MOVEM	B,COMCNT
OG2:	MOVEI	TT,"!"		;SKAN FOR !
	MOVEI	TT1,-1		;NO SECONDARY CHAR.
	PUSHJ	P,SKAN
	ERROR	E.TAG
	TXO	F2,S.NTRC	;DON'T TYPE EVERY TAG WHILE TRACING
	MOVEI	E,STAB		;INIT SEARCH STRING TO 1ST CHAR AFTER !
OG5:	SKIPN	(E)		;OVER STRING?
	JRST	OG3		;YES
	PUSHJ	P,SKRCH		;NO. GET A CHAR
	ERROR	E.TAG
	CAMN	CH,(E)		;MATCH ?
	AOJA	E,OG5		;YES. MOVE ON.
	CAIN	CH,"!"		;NO, ARE WE AT END OF A TAG?
	JRST	OG2		;YES, LOOK FOR ANOTHER
	MOVEI	E,"!"		;NO, SKIP TO NEXT !
OG6:	PUSHJ	P,SKRCH		;GET NEXT CHAR OF TAG
	ERROR	E.UTG
	CAIE	CH,(E)		;!?
	JRST	OG6		;NO, KEEP GOING
	JRST	OG2		;YES, LOOK FOR ANOTHER TAG

OG3:	TXZ	F2,S.NTRC	;RE-ENABLE TRACING
	POP	P,A		;GET INDEX TO SYMBOL TABLE
	POP	P,SYMS(A)	;SAVE POSITION OF THIS O COMMAND
	MOVE	B,COMCNT	;SAVE COMCNT FOR THIS TAG
	MOVEM	B,CNTS(A)
	MOVE	B,CPTR		;SAVE TAG POSITION IN COMMAND STRING
	MOVEM	B,VALS(A)
	JRST	RET


OGFND:	MOVE	A,VALS(B)
	MOVEM	A,CPTR
	MOVE	A,CNTS(B)
	MOVEM	A,COMCNT
	JRST	RET
	SUBTTL	" ' (Conditional) Processing

; n"G	Has no effect if n is greater that 0.  Otherwise, send
;	command interpretation to next matching '.  The " and '
;	match similar to ( and ).
; n"L	Send command to matching ' unless n<0.
; n"N	Send command to matching ' unless n not = 0.
; n"E	Send command to matching ' unless n=0.
; n"F	Send command to matching ' unless n=0.
; n"U	Send command to matching ' unless n=0.
; n"T	Send command to matching ' unless n<0.
; n"S	Send command to matching ' unless n<0.
; n"C	Send command to matching ' unless the value of n is an
;	ASCII character is a letter, number, period (.), dollar
;	sign ($) or percent (%).
; n"R	Send command to matching ' unless the value of n is an
;	ASCII alphanumeric (A-Z, a-z, or 0-9).
; n"A	Send command to matching ' unless the value of n is an
;	ASCII character is alphabetic.
; n"D	Send command to matching ' unless the value of n is an
;	ASCII character is a digit.
; n"V	Send command to matching ' unless the value of n is an
;	ASCII character is lower case alphabetic.
; n"W	Send command to matching ' unless the value of n is an
;	ASCII character is upper case alphabetic.
; n">	Send command to matching ' unless n>0.
; n"<	Send command to matching ' unless n<0.

DQUOTE:	TXNN	FF,F.ARG	;ERROR IF NO ARG BEFORE "
	ERROR	E.NAQ
	PUSHJ	P,SKRCH		;GET CHAR AFTER "
	ERROR	E.MEQ
	MOVEI	T,DQTABL	;INDEX DISPATCH TABLE
	PUSHJ	P,DISPAT	;DISPATCH FOR CHAR. AFTER "
	ERROR	E.IQC

;" COMMAND DISPATCH TABLE

DQTABL:	XWD	DQ.G,"G"
	XWD	DQ.L,"L"
	XWD	DQ.N,"N"
	XWD	DQ.E,"E"
	XWD	DQ.C,"C"
	XWD	DQ.R,"R"	;[1014] Skip if not an alphanumeric
	XWD	DQ.L,"T"
	XWD	DQ.E,"F"
	XWD	DQ.L,"S"
	XWD	DQ.E,"U"
	XWD	DQ.A,"A"
	XWD	DQ.D,"D"
	XWD	DQ.V,"V"
	XWD	DQ.W,"W"
	XWD	DQ.G,">"	;[1030] Greater than
	XWD	DQ.L,"<"	;[1030] Less than
	XWD	0,0		;END OF LIST
	SUBTTL	Execute Individual " Commands

DQ.V:	TRZN	B,40		;EXECUTE "V
	JRST	NOGO		;IF BIT 30 NOT ON IT CAN'T BE L.C.
DQ.A:	TRZ	B,40		;EXECUTE "A -- TREAT UC & LC ALIKE
DQ.W:	CAIL	B,"A"		;EXECUTE "W
	CAILE	B,"Z"
	JRST	NOGO		;IT IS NOT A LETTER
	JRST	RET		;IT IS A LETTER
DQ.D:	CAIL	B,"0"		;EXECUTE "D
	CAILE	B,"9"
	JRST	NOGO		;IT IS NOT A DIGIT
	JRST	RET		;IT IS A DIGIT
DQ.C:	PUSHJ	P,CKSYM1	;EXECUTE "C
	JRST	RET		;IT IS A SYMBOL CHAR
	JRST	NOGO		;IT'S NOT A SYMBOL CHAR
DQ.R:	PUSHJ	P,CKSYM2	;[1014] Execute "R
	JRST	RET		;[1014] It is an alphanumeric character
	JRST	NOGO		;[1014] It's some turkey character
DQ.G:	MOVNS	B		;EXECUTE "G
DQ.L:	JUMPL	B,RET		;EXECUTE "L
	JRST	NOGO		;TEST FAILED
DQ.N:	JUMPN	B,RET		;EXECUTE "N
	JRST	NOGO		;TEST FAILED
DQ.E:	JUMPE	B,RET		;EXECUTE "E, "F, "U
NOGO:	MOVEI	TT,"'"		;SKAN FOR '
	MOVEI	TT1,""""	;IGNORE "...' STRINGS
	PUSHJ	P,SKAN
	ERROR	E.MAP
	JRST	RET
	SUBTTL	Routine to Test Character for $,%,.,0-9,A-Z

;CALL	PUSHJ P,CKSYM
;	RETURN IF $,%,.,0-9,A-Z
;	RETURN ON ALL OTHER CHARACTERS

CKSYM:	MOVEI	B,(CH)		;ENTER AT CKSYM1 IF CHAR ALREADY IN B
CKSYM1:	CAIE	B,"$"		;$ OR %?
	CAIN	B,"%"
	POPJ	P,		;YES
	CAIN	B,"."		;NO. POINT?
	POPJ	P,		;YES.
CKSYM2:	CAIGE	B,"0"		;[1014] No, digit or letter?
	JRST	CPOPJ1		;NO
	CAIG	B,"9"		;MAYBE. DIGIT?
	POPJ	P,		;YES.
	TRZ	B,40		;LC TO UC
	CAIL	B,"A"		;LETTER?
	CAILE	B,"Z"
	JRST	CPOPJ1		;NO.
	POPJ	P,		;YES
	SUBTTL	Error Message Printout

ERRP:	MOVE	P,PDLSAV	;RESTORE PDL
	HRRZ	B,.JBUUO	;GET ERROR CODE
	LDB	D,[POINT 4,.JBUUO,12]	;GET SPECIAL CODE
	CAIE	B,'COR'		;CORE IS ALWAYS FATAL
	TRNN	D,10		;COLONABLE ERROR?
	TXZ	FF,F.COLN	;NO,TURN OFF FLAG
	TXZE	FF,F.COLN
	JRST	ABEGIN
ERRPDL:	SETZM	XCTING		;NO LONGER XCTING
	MOVE	B,.JBREL	;.JBREL NOW
	MOVEM	B,RELSAV
	SETZM	CCLSW		;NO PECULIAR THINGS FOR ME
	TXO	FF,F.EMSG	;ERROR PROCEDURE IN PROGRESS
	HRLZ	B,.JBUUO	;GET ERROR CODE
	CLRBFI			;CLEAR TTY
	PUSHJ	P,TTOPEN
	MOVEI	CH,"?"		;TYPE ?
	PUSHJ	P,TYOM
	MOVSI	TT,'TEC'
	HLR	TT,B
	MOVX	A,JW.WPR	;HOW MUCH WE PRINT
	TDNN	A,ERRLEN	;[1047] Skip the prefix is wanted
	JRST	ERRP04		;[1047] Don't print the prefix or "-n"
	PUSHJ	P,SIXBMS
	TRZ	D,10		;SPECIAL FLAG
	JUMPE	D,ERRP04	;NO SPECIAL ERROR EXTENSION
	CAIN	D,3		;FLAG=EE-4?
	JRST	ERRP05		;YES
	MOVEI	CH,"-"		;NO, TYPE EXTENSION (MONITOR ERROR CODE)
	PUSHJ	P,TYOM
	LDB	B,[POINT 6,XFILNM+.RBEXT,35]	;GET UUO ERROR FLAG
	SOJLE	D,ERRP03	;1 IMPLIES IT IS A UUO ERROR
	HRRZI	B,IO.ERR	;GET I-O ERROR FLAGS
	AND	B,ARGSTO
ERRP03:	PUSHJ	P,OCTMS		;TYPE ERROR CODE IN OCTAL
ERRP04:	MOVE	B,ERRLEN	;HOW MUCH MESSAGE WANTED?
	TXNE	B,JW.WFL
	JRST	ERRP02
	PUSHJ	P,CRR		;HE WANTS ONLY ?XXX, SO END LINE
	JRST	ERRP5		;BETTER SEE IF HE WANTS MORE
ERRP02:	MOVEI	CH," "		;1ST LINE OF MESSAGE AUTOMATIC
	PUSHJ	P,TYOM		;TYPE TAB
ERRP0:	SKIPN	TT,ERRDEV	;[337] Get device TECO was run from
	MOVSI	TT,'DSK'	;[337] If 0, we're probably debugging: use DSK
	DEVCHR	TT,		;[337] Legal device?
	  JUMPE	TT,ERRPSY	;[337] Nope, go use SYS:
	TXNN	TT,DV.DIR	;[337] Had better be a directory device
	  JRST	ERRPSY		;[337] Strange...
	SKIPN	TT,ERRDEV	;[337] Retrieve name again
	MOVSI	TT,'DSK'	;[337]
	MOVEM	TT,ERRBLK+1	;[337] Store in OPEN block
	MOVEI	TT,IO.SYN	;[337] Set status
	MOVEM	TT,ERRBLK	;[337]
	MOVEI	TT,ERRHDR	;[337] Set input buffer header
	MOVEM	TT,ERRBLK+.OPBUF;[337]
	OPEN	ERRCHN,ERRBLK	;[337] Open TECO.ERR device
	  JRST	ERRPSY		;[337] Failed
	JRST	ERRP00		;[337] Success
ERRPSY:	MOVE	TT,ERRDEV	;[337] Get device
	CAMN	TT,[SIXBIT/SYS/] ;[337] Equal to SYS:?
	JRST	NOERRS		;[337] Yes, give up
	MOVSI	TT,'SYS'	;[337] No, try SYS:
	MOVEM	TT,ERRDEV	;[337] Remember for next time
	JRST	ERRP0		;[337] Try again


;Here when OPEN succeeds

ERRP00:	MOVE	TT,Z		;[337] GET ACTUAL FIRST FREE LOC
	IDIVI	TT,5
	ADDI	TT,2
	MOVEI	T,<BUFSIZ+3>*2(TT)	;ROOM FOR 2 DISK BUFFERS?
	MOVE	B,.JBREL	;NO COMMENT
	CAML	T,.JBFF
	PUSHJ	P,GRABJR	;NO, GET 1K CORE
	EXCH	TT,.JBFF	;GET INPUT BUFFER
	INBUF	ERRCHN,2
	MOVEM	TT,.JBFF
	MOVSI	A,(SIXBIT /ERR/)
	MOVEM	A,TECERR+1	;SET UP FILE EXTENSION
	SETZM	TECERR+2
	MOVE	TT,ERRPPN	;[337] Get PPN used in RUN
	MOVEM	TT,TECERR+3	;[337] Store
	HRL	A,JOBN		;GET JOBNUMBER
	HRRI	A,.GTPRG	;& JOBNAME TABLE ADDRESS
	GETTAB	A,		;GET JOBNAME
	JRST	ERRP01		;CAN'T
	MOVEM	A,TECERR	;SET FILE NAME
	LOOKUP	ERRCHN,TECERR	;LOOKUP JOBNAME.ERR
	JRST	ERRP01		;NOT THERE, SO USE TECO.ERR
	JRST	ERRP1		;FOUND
ERRP01:	MOVE	A,[SIXBIT /TECO/]
	MOVEM	A,TECERR
	MOVEM	TT,TECERR+3	;[337] Store PPN again
	LOOKUP	ERRCHN,TECERR	;FIND TECO.ERR
	JRST	ERRPSY		;[337] Lookup failed
ERRP1:	HRRZ	D,.JBUUO	;GET ERROR CODE AGAIN
ERRP2:	PUSHJ	P,ERRWRD	;GET A WORD FROM FILE IN A
	CAIN	D,(A)		;IS THIS THE CODE WE WANT?
	JRST	ERRP3		;YES
	JUMPN	A,ERRP2		;NO, KEEP LOOKING IF NOT END OF INDEX

;FALL INTO ?TECEEE IF END OF INDEX

NOERRS:	TXO	FF,F.XPLN+F.EM	;CANT DO /
	JSP	A,CONMES	;PRINT BAD NEWS
	ASCIZ	/
?TECEEE	Unable to Read Error Message File
/
	JRST	ERRP5
ERRP3:	HLRZS	A		;GET DISK ADR OF MESSAGE
	IDIVI	A,BUFSIZ	;GET DISK BLOCK AND WORD ADDR
	USETI	ERRCHN,1(A)	;TELL MONITOR WHAT BLOCK I WANT
	IN	ERRCHN,0	;GET THAT BLOCK
	CAIA			;BETTER WORK
	JRST	NOERRS		;DIDN'T
	ADDM	AA,ERRHDR+.BFPTR	;FIX ADDR
	IMULI	AA,5		;CHANGE TO CHARS
	SUB	AA,ERRHDR+.BFCNT	;GET CORRECT COUNT
	MOVNM	AA,ERRHDR+.BFCNT	;FIX IT
	PUSHJ	P,ERRPRN	;YES, PRINT EVERYTHING UP TO THE LF
	TXO	FF,F.EM		;NOTE THAT THE 1ST LINE HAS BEEN TYPED
ERRP5:	MOVE	A,COMAX
	SUB	A,COMCNT
	MOVEM	A,ERR1		;ERR1:=COMAX-COMCNT
	MOVE	A,CPTR
	MOVEM	A,ERR2		;ERR2:=CPTR
	MOVE	A,ERRLEN	;DOES HE WANT THE WHOLE THING AUTOMATICALLY?
	TXNE	FF,F.XPLN	;MAYBE PREVENT LOOPING IF NO ERROR MES FILE
	JRST	ERRP6
	TXNE	A,JW.WCN
	JRST	XPLAIN

ERRP6:	TXZN	FF,F.CCL	;GET HERE FROM A "TECO" COMMAND?
	JRST	ERRP6A		;NO
	HRRZ	CH,.JBUUO	;[1046] Get the error suffix
	CAIN	CH,'NSC'	;[1046] Skip if not 'No saved command'
	JRST	ERRP6B		;[1046] Go exit to monitor level
	CAIE	CH,'FNF'	;[1046] Skip if 'File not found'
	JRST	ERRP6A		;[1046] See if the user wants more
	LDB	CH,[POINT 6,XFILNM+.RBEXT,35]  ;[1046] Check for
	CAIN	CH,^O0			       ;[1046]  ?FNF-00
ERRP6B:	MONRT.			;[1046] Exit, but allow continue "/" for error
ERRP6A:	PUSHJ	P,TYPPAG	;[1024] Type page number
	MOVEI	CH,"*"		;TYPE * FOR NEXT COMMAND
	PUSHJ	P,TYOM
	TXO	FF,F.DDTM
	PUSHJ	P,TYI		;GET A CHARACTER NOW
	CAIN	CH,"?"		;QUESTION MARK?
	JRST	ERRTYP		;YES, TYPE BAD COMMAND
	TXNE	FF,F.XPLN	;EXPLANATION TYPED YET?
	JRST	ERRP7		;YES, CAN'T DO THAT AGAIN
	CAIE	CH,"/"		;NO, IS IT A SLASH?
	JRST	ERRP7		;NO
	TXNN	FF,F.EM		;YES, 1ST LINE DONE YET?
	JRST	ERRP0		;NO
	JRST	XPLAIN		;OK, TYPE MORE EXPLANATION OF ERROR

ERRP7:	RELEAS	ERRCHN,
	TXNN	FF,F.XPLN!F.EM	;MED OR LONG MSG TYPED ?
	JRST	GOE		;NO, SKIPE CORE CONTRACTION
	MOVE	B,RELSAV	;GO BACK TO CORE WE HAD BEFORE
	CORE	B,
	JFCL			;REDUCTION WON'T FAIL
	JRST	GOE		;GET REST OF COMMAND
ERRPRN:	PUSHJ	P,ERRCHR	;GET A CHAR FROM ERR. FILE
ERRPR2:	CAIE	CH,.CHCNN	;^N?
	JRST	ERRPR3		;NO, SKIP
	PUSHJ	P,ERRCHR	;GET 1ST DIGIT AFTER ^N
	MOVEI	T,-60(CH)
	IMULI	T,^D10		;PUT IT IN TEN'S PLACE
	PUSHJ	P,ERRCHR	;GET 2ND DIGIT
	ADDI	T,-60(CH)
	ROT	T,-1		;DIVIDE TOTAL BY 2 & SAVE BIT 35
	HLRZ	CH,ETABL(T)	;GET LEFT SIDE ADDR IN CASE EVEN
	TLNE	T,400000	;EVEN OR ODD?
	HRRZ	CH,ETABL(T)	;ODD, GET ADDR FROM RIGHT SIDE
	JRST	(CH)		;TYPE SPECIAL INFORMATION

ERRPR3:	PUSHJ	P,TYOM		;PRINT NORMAL CHARS.
	CAIE	CH,.CHLFD	;LF?
	JRST	ERRPRN		;NO
	POPJ	P,

;GET A CHARACTER FROM SYS:TECO.ERR

ERRCHR:	SOSGE	ERRHDR+.BFCNT	;ANY CHARS. IN BUFFER?
	JRST	ERRCH2		;NO
	ILDB	CH,ERRHDR+.BFPTR	;YES, GET NEXT
	POPJ	P,		;DO NOT IGNORE NULLS
ERRCH2:	IN	ERRCHN,0	;GET NEXT BUFFER
	JRST	ERRCHR		;OK, NOW GET A CHAR.
ERRCH3:	POP	P,A		;UNABLE TO READ TECO.ERR
	JRST	NOERRS

;GET 1K CORE FOR ERROR MESSAGE FILE READ-IN

GRABJR:	ADDI	B,^D1024	;ADD 1K
	CORE	B,
	JRST	ERRCH3		;CAN'T GET IT
	POPJ	P,

;CAN'T PRINT ERROR FILE BECAUSE OF NO CORE

ERRP05:	TXO	FF,F.XPLN+F.EM
	RELEAS	INICHN,
	JSP	A,CONMES
	ASCIZ	/ Storage Capacity Exceeded
/
	PUSHJ	P,ECORE1	;[354] GARBAGE COLLECT AND SMALLIFY
	MOVE	B,.JBREL	;.JBREL NOW
	MOVEM	B,RELSAV	;SO AS TO NOT CAUSE HUGIFICATION
	JRST	ERRP6A		;DON'T GET I-O TO UNASSIGNED CHANNEL
	SUBTTL	Routine to Type C(TT) in SIXBIT

;CALL	MOVE TT,[SIXBIT /MESSAGE/]
;	PUSHJ P,SIXBMS
;	RETURN


SIXBMS:	SKIPN	CH,TT		;ALL SPACES?
	JRST	SIXBM2		;YES
	MOVNI	B,6
	MOVE	E,[POINT 6,TT]
	ILDB	CH,E
	JUMPE	CH,CPOPJ
SIXBM2:	ADDI	CH," "
	PUSHJ	P,TYOM
	AOJL	B,.-4
	POPJ	P,
	SUBTTL	Error Processing Routines

ERRTYP:	SKIPN	AA,ERR2		;VALUE OF CPTR WHEN LAST ERROR OCCURRED.
	JRST	[MOVEI	CH,"*"	;THIS HAD TO BE IT
		 PUSHJ	P,TYOM	;TYPE IT
		 SKIPE	CH,EATCH	;GET Q REG NAME IF GOT THAT FAR
		 PUSHJ	P,TYOM	;TYPE IT
		 JRST	LASTQ]	;AND TYPE FINAL QUESTION MARK
	MOVEI	B,12
	SUBI	AA,2		;BACK POINTER UP 10 CHARACTERS.
	ILDB	CH,AA		;GET CHARACTER
	CAMG	B,ERR1		;WAS IT IN THE COMMAND BUFFER?
	PUSHJ	P,TYOM		;YES. TYPE IT.
	CAME	AA,ERR2		;HAVE WE REACHED THE BAD COMMAND?
	SOJA	B,.-4		;NO. DO IT AGAIN.
LASTQ:	JSP	A,CONMES	;PRINT A ? TO MARK END
	ASCIZ	/?
/
	JRST	ERRP6A

XPLA2:	PUSHJ	P,ERRPR2	;PRINT UP TO LF
XPLAIN:	PUSHJ	P,ERRCHR	;IS NEXT CHAR A "?" OR ^A,^B, ... ^H?
	CAILE	CH,10		;TEXT ENDS WITH A NULL OR CONTROL-A OR B
	JRST	XPLA2		;NO, KEEP GOING
XPLA1:	TXO	FF,F.XPLN	;SET FLAG THAT XPLANATION IS TYPED
	JRST	ERRP6		;YES, STOP HERE

;ROUTINE TO READ A WORD FROM THE FILE OPEN IN ASCII MODE

ERRWRD:	SOSGE	ERRHDR+.BFCNT	;ANY LEFT?
	JRST	ERRWR2		;NO, GET SOME
	MOVNI	A,4		;SUBTRACT 5 FROM COUNT
	ADDM	A,ERRHDR+.BFCNT	;(1 SUBTRACTED BY SOS ABOVE)
	AOS	A,ERRHDR+.BFPTR	;INCR ADR
	MOVE	A,(A)		;GET THE WORD
	POPJ	P,
ERRWR2:	IN	ERRCHN,0	;GET NEXT BUFFER
	JRST	ERRWRD		;READ
	JRST	ERRCH3		;ERROR
	SUBTTL	Dispatch Table for Special Information Typeout

;BASED ON CHARACTER AFTER CONTROL-N

ETABL:	XWD	ECOMCH,EOUTFL	;00  01
	XWD	EFILEN,EERNUM	;02  03
	XWD	EDEVNM,EPROJN	;04  05
	XWD	EARG1,EPROTC	;06  07
	XWD	EEBFN,EINFIL	;08  09
	XWD	EEBFIL,EIOFLG	;10  11
	XWD	ESTAB,ESKIP	;12  13
	XWD	EISKIP,0	;14  15
	XWD	EEOVAL,EESRCH	;16  17
	XWD	EECTRL,EESWIT	;18  19
	XWD	EECRTS,0	;20  21
	SUBTTL	Special Information Typeout Routines

EECTRL:	SKIPA	CH,ARGSTO	;GET BAD CHAR FROM TEXT STRING
ECOMCH:	LDB	CH,CPTR		;GET LAST COMMAND STRING CHAR.
	PUSHJ	P,TYOS
	JRST	ERRPRN

EOUTFL:	MOVEI	TT1,OUTFIL	;AIM AT OUTPUT FILENAME
EOUTF2:	MOVE	TT,(TT1)
	PUSHJ	P,SIXBMS	;PRINT FILENAME
	HLLZ	TT,1(TT1)
	JUMPE	TT,ERRPRN	;SKIP REST IF NO EXTENSION
	MOVEI	CH,"."
	PUSHJ	P,TYOM
EOUTF3:	PUSHJ	P,SIXBMS	;PRINT EXTENSION
	JRST	ERRPRN

EFILEN:	MOVEI	TT1,XFILNM+.RBNAM	;GET FILENAME REF'D BY UUO
	JRST	EOUTF2

EERNUM:	LDB	B,[POINT 6,XFILNM+.RBEXT,35]	;GET 2-DIGIT ERROR CODE
EERNU1:	PUSHJ	P,OCTMS		;TYPE IT
	JRST	ERRPRN

EDEVNM:	SKIPN	TT,FILDEV	;[337] GET DEVICE NAME
	JRST	ERRPRN		;[337] No device to be typed.
	PUSHJ	P,SIXBMS	;[337] Type it
	MOVEI	CH,":"		;[337] Get colon
	PUSHJ	P,TYOM		;[337] Type it
	JRST	ERRPRN		;[337] Continue

EPROJN:	SKIPN	FILPPN		;[337] Is there a PPN?
	JRST	ERRPRN		;[337] No, skip this.
	MOVEI	CH,"["		;[337] Get a bracket
	PUSHJ	P,TYOM		;[337] Type it
	HLRZ	B,FILPPN	;TYPE PROJECT NUMBER
	PUSHJ	P,OCTMS
	MOVEI	CH,","		;TYPE COMMA
	PUSHJ	P,TYOM
	HRRZ	B,FILPPN	;TYPE PROGRAMMER NUMBER
	PUSHJ	P,OCTMS
	MOVE	TT1,[XWD -5,FILSFD]	;TYPE SFD'S
ERSFDS:	SKIPN	TT,(TT1)	;GET ONE
	JRST	EPROJ2		;[337] IF ZERO, WE'RE DONE
	MOVEI	CH,","
	PUSHJ	P,TYOM
ERSFD1:	PUSHJ	P,SIXBMS
	AOBJN	TT1,ERSFDS	;LOOP BACK
EPROJ2:	MOVEI	CH,"]"		;[337] Close the brackets
	PUSHJ	P,TYOM		;[337]
	JRST	ERRPRN
EECRTS:
IFN CRT,<
	MOVE	CH,"["		;[337] Make it look good
	PUSHJ	P,TYOM		;[337]
	MOVE	TT1,[IOWD NUMCRT,CRTTAB+1]	;TYPE OUT VALID CRT TYPES
	MOVE	TT,(TT1)
	JRST	ERSFD1   >
IFE CRT,<JRST	ERRPPN>

EESWIT:	MOVE	TT,SWITHL	;GET I/O SWITCH NAME
	JRST	EOUTF3

EARG1:	MOVE	B,ARGSTO	;GET ARG BACK
EARG1A:	PUSHJ	P,DECMS		;PRINT IT
	JRST	ERRPRN

EPROTC:	LDB	B,[POINT 9,XFILNM+.RBPRV,8]	;GET FILE PROTECTION
	MOVEI	CH,"0"		;[337] Possible leading 0
	CAIGE	B,100		;[337] 3 digit protection?
	PUSHJ	P,TYOM		;[337] No, type a leading 0
	MOVEI	CH,"0"		;[337] Once again...
	CAIGE	B,10		;[337] 2 digit protection?
	PUSHJ	P,TYOM		;[337] No, type another leading 0
	JRST	EERNU1

EEBFN:	MOVE	TT,BAKNAM	;EB FILENAME
	JRST	EOUTF3		;PRINT IT WITHOUT EXTENSION

EINFIL:	MOVEI	TT1,INFILE	;AIM AT INPUT FILENAME
	JRST	EOUTF2

EEBFIL:	MOVEI	TT1,BAKNAM	;AIM AT EB ORIGINAL FILENAME
	JRST	EOUTF2
EIOFLG:	HRRZI	B,IO.ERR	;RETRIEVE I/O ERROR FLAGS
	AND	B,ARGSTO
	JRST	EERNU1

ESTAB:	MOVEI	TT,STAB		;INDEX STAB WHERE TAG RESIDES
ESTAB1:	MOVE	CH,(TT)
	JUMPE	CH,ERRPRN	;THAT'S ALL
	PUSHJ	P,TYOS
	AOJA	TT,ESTAB1

EISKIP:	LDB	TT,[POINT 4,ARGSTO,21]	;GET I/O ERROR FLAGS
	SKIPA
ESKIP:	LDB	TT,[POINT 6,XFILNM+.RBEXT,35]
ESKIP2:	PUSHJ	P,ERRCHR	;LOOK FOR ^A
	CAIN	CH,2		;^B ENCOUNTERED?
	JRST	ERRPRN		;YES, PRINT DEFAULT MESSAGE
	CAIE	CH,1
	JRST	ESKIP2		;NOT ^A
	PUSHJ	P,ERRCHR	;GET 1ST DIGIT AFTER ^A
	MOVEI	T,-60(CH)
	LSH	T,3		;MULT BY 8
	PUSHJ	P,ERRCHR	;GET NEXT DIGIT
	ADDI	T,-60(CH)
	CAME	TT,T		;THIS THE NUMBER WE WANT?
	JRST	ESKIP2		;NO
	JRST	ERRPRN		;YES, NOW START PRINTING

EEOVAL:	MOVEI	B,EOVAL		;GET MAXIMUM EOFLAG FOR THIS VERSION
	JRST	EARG1A

EESRCH:	MOVE	TT,[POINT 7,SRHARG]  ;GET PTR TO SEARCH STRING
	MOVM	B,SRHCTR	     ;[344] & STRING CTR
EESRH2:	ILDB	CH,TT		;GET STRING CHAR
	PUSHJ	P,TYOS		;TYPE IT
	SOJE	B,ERRPRN	;WATCH STRING CTR
	JRST	EESRH2		;NOT FINISHED YET
	SUBTTL	UUO Handler

UUOH:
	MOVEM	B,ARGSTO	;SAVE POSSIBLE ARG
	LDB	B,[POINT 9,.JBUUO,8]	;GET UUO TYPE
	CAIL	B,20		;CHKEO?
	JRST	CEO		;YES
	CAIN	B,1		;ERROR UUO?
	JRST	ERRP		;YES
UUOERR:	HRRZ	B,(P)		;ADDRESS OF ILLEGAL UUO
	SUBI	B,1
	MOVE	D,@B		;GET COMPLETE UUO INSTRUCTION
	MOVEM	D,FILPPN	;STORE IT
	SETZM	FILPPN+1	;WE DON'T WANT ANY SFD'S TYPED!
	ERROR	E.UUO

;CHKEO EO#,ADDR
;IF EOFLAG > EO#, RETURN AT CALL+1 (FEATURE IS LEFT ON)
;OTHERWISE GO TO ADDR (FEATURE IS TURNED OFF)

CEO:	PUSH	P,A		;SAVE AC
	LDB	B,[POINT 8,.JBUUO,12]	;GET EO TEST VALUE
	MOVE	A,EOFLAG	;GET LAST SETTING OF EOFLAG
	CAIG	A,(B)		;EOFLAG > TEST VALUE?
	JRST	CEO1		;NO
CEO2:	POP	P,A		;RESTORE AC A
	MOVE	B,ARGSTO	;RESTORE AC B
	POPJ	P,		;RETURN

CEO1:	HRRZ	A,.JBUUO	;GET DISPATCH ADDR
	HRRM	A,-1(P)		;PUT ON PDL AS RET. ADDR.
	JRST	CEO2
	SUBTTL	? Command to Complement Trace Mode

QUESTN:	TXCN	FF,F.TRAC	;COMPLEMENT TRACE FLAG
	JRST	RET
	PUSHJ	P,CRR		;TYPE CR/LF AFTER TRACE MODE EXIT
	JRST	RET

COMMEN:	PUSHJ	P,SKRCH		;GET A COMMENT CHAR
	ERROR	E.UCA
	CAIN	CH,1		;^A
	JRST	[TXNN	FF,F.TRAC
		 OUTPUT	TTY,	;FORCE OUTPUT TO TTY
		 JRST	RET]	;AND LEAVE
	TXNN	FF,F.TRAC	;OMIT DOUBLE TYPE-OUT WHEN TRACING
	PUSHJ	P,TYOM		;TYPE IT
	JRST	COMMEN

;ILLEGAL CHARACTER OR COMMAND

ERRA:	MOVE	B,CH		;DONT USE TEXT BUFFER, SO THAT ^<CHAR> WORKS
	ERROR	E.ILL
	SUBTTL	Routine to Return String Operation String Arguments

;ARGUMENTS ARE CHARACTER ADDRESSES IN THE DATA BUFFER.
;TRANSFORMS M,N OR N, WHERE THE LATTER SPECIFIES A NUMBER OF LINES,
;TO ARGUMENTS.
;CALL	PUSHJ P,GETARG
;	RETURN WITH FIRST ARGUMENT ADDRESS IN C, SECOND IN B.
;IF THE EO VALUE HAS BEEN SET TO 1, THE ONLY EOL CHAR IS LINE FEED.
;IF EO > 1, THE EOL CHARS ARE LF, VT, AND FF (& END OF BUFFER IF
;LAST CHAR IN BUFR IS NOT AN EOL)

GETARG:	TXZE	FF,F.ARG2	;[1051] Is there a second arguemnt?
	JRST	GETAG6		;YES

;N	SIGN INDICATES DIRECTION RELATIVE TO PT.
GETNAG:	PUSHJ	P,CHK2		;NO, GET 1ST ARG (+ OR - 1 IF NONE THERE)
	MOVE	I,PT		;IN:=PT
GETAG4:	JUMPLE	B,GETAG2	;WAS LAST ARGUMENT FUNCTION -?
	CAMN	I,Z		;NO. ARGUMENT IS LOCATION OF NTH EOL FORWARD FROM PT.
				;IS PT AT END OF BUFFER?
	JRST	GETAG1		;YES.
	PUSHJ	P,GETINC	;NO. CH:=NEXT DATA BUFFER CHARACTER, IN:=IN+1
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	JRST	GETAG4		;NO. TRY AGAIN.
	SOJG	B,GETAG4	;YES. NTH EOL?

GETAG1:	MOVE	B,I		;YES. RETURN FIRST ARGUMENT IN C
	MOVE	C,PT		;SECOND IN B.
	POPJ	P,

;M,N
GETAG6:	ADD	B,BEG		;C:=M+BEG
	ADD	C,BEG		;B:=N+BEG
	POPJ	P,

GETAG2:	SOS	I		;SET I FOR CHAR BEFORE PT
	CAMGE	I,BEG		;PASSED BEGINNING OF BUFFER?
	JRST	GETAG3		;YES. IN:=BEG
	PUSHJ	P,GETINC	;NO. CH:=NEXT DATA BUFFER CHARACTER. IN:=IN+1
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	SOJA	I,GETAG2	;NO. BACK UP ONE POSITION AND TRY AGAIN.
	AOJLE	B,.-1		;YES. NTH EOL?

GETAG3:	CAMGE	I,BEG		;YES. PASSED BEGINNING OF BUFFER?
	MOVE	I,BEG		;YES. RESET TO BEGINNING.
	MOVE	C,I		;NO. RETURN FIRST ARGUMENT IN C.
	MOVE	B,PT		;SECOND IN B
	POPJ	P,
	SUBTTL	Routine to Return in CH the Character to the Right of the Pointer

;AND INCREMENT THE POINTER.
;CALL	MOVE I,POINTER (AS A CHARACTER ADDRESS)
;	PUSHJ P,GETINC
;	RETURN WITH CHARACTER IN CH AND POINTER TO CHARACTER IN IN.

GETINC:	PUSHJ	P,GET
	AOJA	I,CPOPJ

GET:	MOVE	TT,I
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	LDB	CH,TT
	POPJ	P,

PUT:	MOVE	TT,OU
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	DPB	CH,TT
	POPJ	P,

;CHARACTER TRANSLATION BYTE POINTER TABLE
;TRANSLATES 1 CHARACTER POSITION TO THE RIGHT OF A CHARACTER ADDRESS POINTER

	XWD	440700,0
BTAB:	XWD	350700,0
	XWD	260700,0
	XWD	170700,0
	XWD	100700,0
	XWD	10700,0

;CHECK IF CH = EOL CHARACTER
;CALL:	PUSHJ	P,CKEOL
;	RETURN IF CH NOT = EOL
;	RETURN IF CH IS EOL CHAR

CKEOL:	CAIN	CH,.CHLFD	;LINE FEED?
	JRST	CPOPJ1		;YES, IT IS AN EOL!
	CHKEO	EO21,CPOPJ	;IF EO=1, LF IS ONLY POSSIBLE EOL
	CAIE	CH,.CHVTB	;VERTICAL TAB?
	CAIN	CH,.CHFFD	;FORM FEED?
	AOS	(P)		;YES, SKIP RETURN
	POPJ	P,		;NO
	SUBTTL	Routines to Move Characters Around

NROOMC:
IFN VC,<MOVEM	C,VVAL>		;SAVE LENGTH OF STRING
NROOM:	SETZM	CRREL		;[317]ZERO THE RELOCATION WORDS
	SETZM	RREL		;[317]
	JUMPE	C,CPOPJ		;IF 0, THERE'S NOTHING TO DO
	MOVEM	17,AC2+15	;SAVE 17
	MOVEI	17,NROOM9	;ANTICIPATE GARBAGE COLLECTION
	MOVEM	17,GCRET	;THIS THE EXIT DISPATCH
	MOVE	17,PT
	CAMN	17,Z		;PT=Z? I.E., DATA BUFFER EXPANSION?
	JRST	NROOM1		;YES.
NROOM0:	MOVE	17,[XWD 2,AC2]	;NO. SAVE ACS 2 THROUGH 16.
	BLT	17,AC2+14
	JUMPL	C,NROOM6	;DELETION?
	SETOM	GCFLG		;NO.

;MOVE STRING STORAGE UP C CHARACTERS STARTING AT PT.

NROOM9:	MOVE	F2,AC2+F2-2	;IN CASE CORE ERROR
	MOVE	17,Z
	ADD	17,C
	CAML	17,MEMSIZ	;WILL REQUEST OVERFLOW MEMORY?
	JRST	GC		;YES. GARBAGE COLLECT.
;MOVE FROM PT THROUGH Z UP C POSITIONS
	MOVE	14,C		;NO.
	IDIVI	14,5		;AC14:=Q(REQ/5), AC15:=REM(REQ/5)
	IMULI	15,7		;AC15:=(REM(REQ/5))*7
	MOVN	13,15		;AC13:=-(REM(REQ/5))*7
	MOVEI	15,-43(15)	;AC15:=(REM(REQ/5))*7-43
	MOVE	11,PT
	IDIVI	11,5		;AC11:=Q(PT/5), AC12:=REM(PT/5)
	MOVNI	16,-5(12)
	IMULI	16,7		;AC16:=-(REM(PT/5)-5)*7
	DPB	16,[XWD 300600,NROOM2]	;SET SIZE FIELD OF LAST PARTIAL WORD POINTER.
	ADDI	14,1(11)	;AC14:=Q(REQ/5)+Q(PT/5)+1
	MOVE	16,Z
	IDIVI	16,5		;AC16:=Q(Z/5)
	MOVEI	B,1(16)
	SUB	B,11		;B:=Q(Z/5)+1-Q(PT/5)=NO. OF WORDS TO MOVE.
;PUT MOVE ROUTINE IN FAST ACS
	HRLI	11,(MOVE  A,(B))	;AC11:=MOVE  A,[Q(PT/5)](B)
	HRLOI	12,(ROT   A,)		;AC12:=ROT   A,-1
	HRLI	13,(ROTC  A,)		;AC13:=ROTC  A,-(REM(REQ/5))*7
	HRLI	14,(MOVEM AA,(B))	;AC14:=MOVEM AA,[Q(PT/5)+1](B)
	HRLI	15,(ROTC  A,)		;AC15:=ROTC  A,(REM(REQ/5))*7-43
	MOVE	17,[JRST  NROOM7]	;AC16:=SOJGE B,11
	MOVE	16,.+1			;AC17:=JRST  NROOM7
	SOJGE	B,11		;B:=B-1. DONE?
NROOM7:	ROTC	A,43(13)	;YES. STORE LAST PARTIAL WORD.
	DPB	A,NROOM2
	ADDM	C,Z		;Z:=Z+REQ
NROOM5:	MOVE	17,[XWD 2,AC2]	;RESTORE ACS AND RETURN.
	MOVSS	17
	BLT	17,17
	POPJ	P,

;A CALL FOR A BUFFER EXPANSION, WHERE PT=Z. IF
;THERE IS NOT ENOUGH ROOM, PERFORM THE GARBAGE COLLECTION ROUTINE
;IF THERE IS STILL NO ROOM, GET THE NECESSARY CORE FROM THE
;MONITOR TO SATISFY THIS REQUEST

NROOM1:	ADD	17,C		;TOTAL SPACE REQUIREMENT
	CAMGE	17,MEMSIZ	;[320] IS THERE ENOUGH?
	JRST	.+4		;YES, THEREFORE, UPDATE Z AND EXIT
	MOVEI	17,GCRETA	;EXIT DISPATCH FOR THE
	MOVEM	17,GCRET	;GARBAGE COLLECTION ROUTINE
	JRST	NROOM0		;GO DO THE GARBAGE COLLECTION
	ADDM	C,Z		;UPDATE Z, SIZE IS OK
	MOVE	17,AC2+15	;RESTORE AC#17
	POPJ	P,		;EXIT OUT


;NOT ENOUGH ROOM FOR THE EXPANSION, GARBAGE COLLECTION HAS BEEN
;PERFORMED, IF NEED BE, GRAB A K FROM THE MONITOR (OR MORE)

GCRETA:	MOVE	17,Z		;GET TOTAL SO FAR
	ADD	17,C		;ADD IN THE REQUEST
	MOVE	F2,AC2+F2-2
	CAML	17,MEMSIZ	;STILL IN NEED OF CORE?
	PUSHJ	P,GRABAK	;YES, GET THE REQUIRED CORE FROM THE MONITOR
	ADDM	C,Z		;UPDATE Z AND EXIT
	JRST	NROOM5		;RESTORE ALL AC'S AND RETURN TO SEQUENCE
;MOVE FROM PT+ABS(C) THROUGH Z DOWN ABS(C) POSITIONS
NROOM6:IFN BISSW,< ;KL10 BIS SUPPORT
	SKIPN	BIS		;KL10?
	JRST	NBIS6		;NO
	MOVE	15,PT		;CHARACTER ADDRESS OF TEXT POINTER
	IDIVI	15,5		;WORD ADDR
	HLL	15,BTAB-1(16)	;BYTE POINTER TO DESTINATION
	MOVE	11,Z		;LAST BYTE ADDR IN TEXT BUFFER
	ADDM	C,Z		;UPDATE Z
	MOVMS	12,C		;NUMBER OF CHARACTERS TO MOVE DOWN
	ADD	12,PT		;SOURCE BYTE
	SUB	11,12		;# BYTES TO MOVE
	MOVE	14,11		;# BYTES TO MOVE TO DESTINATION
	IDIVI	12,5		;SOURCE WORD ADDR
	HLL	12,BTAB-1(13)	;SOURCE BYTE POINTER
	SETZM	13		;NOT USED BY US
	EXTEND	11,[MOVSLJ	;MOVE STRING LEFT JUSTIFIED
		    EXP	0]	;NO FILL
E$$EMF:	ERROR	(EMF)		;EXTENDED MOVE FAILED
	JRST	NROOM3		;RESTORE ACS
NBIS6:> ;END IFN BISSW
	MOVE	14,PT		;INITIALIZE PARTIAL WORD POINTER.
	IDIVI	14,5		;AC14:=Q(PT/5), AC15:=REM(PT/5)
	MOVEM	14,B		;B:=Q(PT/5)
	HRRZM	14,NROOM4
	IMULI	15,7
	DPB	15,[XWD 300600,NROOM4]	;SIZE:=(REM(PT/5))*7
	MOVNI	15,-44(15)
	DPB	15,[XWD 360600,NROOM4]	;POSITION:=44-(REM(PT/5))*7
	MOVE	11,Z
	IDIVI	11,5		;AC11:=Q(Z/5)+1, AC12:=REM(Z/5)
	ADDI	11,1
	MOVE	13,C
	IDIVI	13,5
	ADDI	13,-1(11)	;AC13:=Q(Z/5)-Q(REQ/5)
	MOVNM	14,12		;AC12:=(REM(REQ/5))*7
	IMULI	12,7
	MOVNI	15,-43(12)	;AC15:=43-(REM(REQ/5))*7
	SUBI	B,1(13)		;B:=Q(PT/5)+Q(REQ/5)-Q(Z/5)-1:=# WORDS TO MOVE

NROOM8:	HRLI	11,(MOVE  AA,(B))	;AC11:=MOVE  AA,[Q(Z/5)+1](B)
	HRLI	12,(ROTC  A,)		;AC12:=ROTC  A,(REM(REQ/5))*7
	HRLI	13,(MOVEM A,(B))	;AC13:=MOVEM A,[Q(Z/5)-Q(REQ/5)](B)
	MOVE	14,[ADDM  A,@13]	;AC14:=ADDM  A,@13
	HRLI	15,(ROTC  A,)		;AC15:=ROTC  A,43-(REM(REQ/5))*7
	MOVE	17,[JRST  NROOM3]	;AC16:=AOJLE B,11
	ADDM	C,Z			;AC17:=JRST  NROOM3
	LDB	C,NROOM4
	MOVE	A,@11		;Z:=C(Z)-REQ
	ROT	A,-1		;A:=Q(PT/5)+Q(REQ/5) RIGHT JUSTIFIED.
	MOVE	16,.+1
	AOJLE	B,11		;B:=B+1.  DONE?

NROOM3:	DPB	C,NROOM4	;YES. DEPOSIT PARTIAL WORD.
	JRST	NROOM5
	SUBTTL	Garbage Collector

GC:	AOSE	GCFLG		;FIRST ATTEMPT?
	JRST	PRENR9		;TRY TO EXPAND MEMORY
	SETOM	GCPTR		;YES. GCPTR:=-1
	SETZM	SYMS		;CLEAR SYMS,VALS AND CNTS TABLES
	MOVE	T,[XWD SYMS,SYMS+1]
	BLT	T,SYMEND-1
	MOVEI	T,CPTR		;COMMAND BUFFER
	PUSHJ	P,GCMA
	MOVEI	T,(P)
	PUSHJ	P,GCMA		;NO. GARBAGE COLLECT ALL BYTE POINTERS ON IT.
	CAILE	T,PDL+1
	SOJA	T,.-2
	HRRZ	T,AC2+PF-2	;GARBAGE COLLECT Q-REG PUSHDOWN LIST.
	CAIL	T,PFL
	PUSHJ	P,GCM
	CAILE	T,PFL
	SOJA	T,.-2
	MOVE	T,[XWD -LNQTAB,QTAB]	;[1037] Garbage collect Q-registers
	PUSHJ	P,GCM
	AOBJN	T,.-1
	MOVE	I,BEG		;MAKE SURE STUFF BEFORE BEG
	SUB	I,QRBUF		;IS COLLECTED
	MOVEI	T,0		;MARK THIS AS LAST COLLECTION
	PUSHJ	P,GCM3		;STORE IT ON TH GC LIST
	MOVE	I,QRBUF
GCS1A:	MOVSI	TT,200000	;TT>MAX. NO. CHARACTERS IN WORLD
	MOVE	OU,GCPTR	;GO BACKWARDS THROUGH GCTAB
GCS1:	HRRZ	A,GCTAB(OU)	;RELOCATE
	ADD	A,QRBUF
	CAMGE	A,I
	JRST	GCS2
	CAMGE	A,TT		;SET TT TO HIGHEST CHARACTER POSITION
	MOVE	TT,A
GCS2:	SOJGE	OU,GCS1
	CAMN	TT,[1B1]	;ANYTHING IN GCTAB ?	[EDIT #116]
	JRST	GCS4A		;NO, DON'T SAVE INFINITY[EDIT #116]
	MOVE	F2,TT		;HIGHEST CHARACTER.
	IDIVI	I,5		;C(QRBUF)/5
	IDIVI	F2,5		;HIGH CHAR/5
	AOS	I		;C(QRBUF)/5+1
	MOVS	OU,F2
	MOVE	T,F2
	SUB	T,I		;HIGH CHAR/5-C(QRBUF)/5+1
	JUMPLE	T,GCS4A		;ANYTHING TO GET?
	HRR	OU,I		;XWD HIGH CH/5,C(QRBUF)/5+1=NREG
	MOVE	B,Z		;GET TOP OF BUFR FOR BLT
	HRRZ	F2,(P)		;SEE WHO CALLED NROOM
	CAIN	F2,YANK6	;WAS IT APPEND?
	MOVE	B,AC2+OU-2	;YES, MUST USE THE REAL Z FOR THE BLT
	IDIVI	B,5
	SUB	B,T		;Z/5-NREG
	BLT	OU,(B)		;MOVE STUFF DOWN
	MOVNS	OU,T
	IMULI	OU,5		;OUT:=-5*NREG
	ADDM	OU,BEG		;BEG:=C(BEG)-5*NREG
	ADDM	OU,PT		;PT:=C(PT)-5*NREG
	ADDM	OU,Z		;Z:=C(Z)-5*NREG
	ADDM	OU,RREL		;RREL:=C(RREL)-5*NREG
	MOVE	CH,GCPTR	;UPDATE INSERTER
GCS3:	HRRZI	TT1,GCTAB(CH)
	HRRZ	A,(TT1)
	ADD	A,QRBUF
	CAMGE	A,TT
	JRST	GCS4
	ADDM	OU,(TT1)
	HLRZ	A,(TT1)
	JUMPE	A,GCS4		;NO PTR TO BEG
	CAIN	A,CPTR		;IN COMMAND BUFFER?
	ADDM	T,CRREL		;YES. UPDATE COMMAND POINTER RELOCATION
	SKIPL	(A)		;Q-REG?
	ADDM	T,(A)		;NO
	SKIPGE	(A)		;Q-REG?
	ADDM	OU,(A)		;YES. RELOCATE BASE POINTER.

GCS4:	SOJGE	CH,GCS3		;DONE?
	ADD	TT,OU		;YES. IN:=C(TT)-5*NREG

GCS4A:	CAML	TT,BEG		;LAST COLLECTION?
	JRST	@GCRET		;YES, RETURN
	MOVE	I,TT
	PUSH	P,C
	PUSHJ	P,GTQCNT
	ADD	I,C
	POP	P,C
	JRST	GCS1A
GCM:	MOVE	I,(T)
	TLZE	I,400000	;[1040] Does the Q-register
	TLZE	I,377770	;[1040]  contain text?
	POPJ	P,		;NO
	ADD	I,QRBUF		;YES. ENTER POINTER IN GCTAB

GCM2:	CAML	I,BEG		;REGION BEFORE TEXT BUFFER?
	POPJ	P,		;NO. FORGET IT.
	SUB	I,QRBUF		;YES. IN:=# CHARACTERS TO RETREIVE.
				;IN Q-REG BUFFER AREA?
	JUMPL	I,CPOPJ		;NO. FORGET IT.
GCM3:	AOS	TT,GCPTR	;YES. TO BE GRABBED.
	CAIL	TT,GCTBL	;AM I WINNING?
	ERROR	E.GCE
	HRL	I,T		;XWD ADDRESS OF BYTE POINTER,NO. CHARACTERS
	MOVEM	I,GCTAB(TT)	;SAVE DATA
	POPJ	P,		;DONE THIS POINTER
;IF T POINTS TO AN ASCII BYTE POINTER, IN:=CHARACTER ADDRESS OF TOP
;OF STRING - NO. OF CHARACTERS.
GCMA:	HLRZ	TT,(T)		;LEFT HALF OF PTR
	TRC	TT,700		;DOES T POINT TO A TEXT BYTE POINTER?
	TRNE	TT,7700
	POPJ	P,		;NO
	MOVE	I,-1(T)		;MAYBE. GET WORD BEFORE POINTER. (MAX)
	SUB	I,1(T)		;MAX-CT
	LSH	TT,-14		;BYTE POSITION
	IDIVI	TT,7		;NO. OF CHARACTERS
	MOVEI	TT1,4-3+1	;2
	SUB	TT1,TT		;2-NO. OF CHARACTERS
	HRRZ	TT,(T)		;POINTER WORD ADDRESS (UNRELOCATED)
	IMULI	TT,5		;5*ADDRESS
	ADD	TT,TT1
	SUBM	TT,I		;5*ADDRESS-NO. CHARS+2+CT-MAX
	JRST	GCM2
	SUBTTL	Automatic Memory Expansion

;MEMORY WILL BE EXPANDED UNDER ONE OF THESE CONDITIONS.

;	1.AN INTERNAL BUFFER EXPANSION CANNOT BE PERFORMED,
;	  TO DO SO WOULD OVERFLOW THE PRESENT MEMORY
;	  CAPACITY. THE INTERNAL OPERATIONS WHICH DESCOVER
;	  THE NEED FOR EXPANSION ARE:

;	  A.COMMAND BUFFER EXPANDING
;	  B.THE Q-REG GET (GI)
;	  C.THE Q-REG LOAD (NXI)
;	  D.ANY OF THE INSERTS
;	  E.COMMAND ACCEPTANCE ROUTINE


;	2.THE DATA BUFFER WILL BE MAINTAINED AT A MINIMUM
;	  NUMBER OF 5000 CHARACTERS BEFORE NEW DATA IS LOADED
;	  FROM AN INPUT DEVICE OTHER THAN THE CONSOLE. Q-REG
;	  USAGE SHORTENS THE NUMBER OF AVAILABLE CHARACTERS
;	  DIRECTLY, AND NORMAL TECO COMMANDS ARE GREATLY IMPARED
;	  OTHERWISE.


;SAVE THE ACCUMULATORS


GRABAK:	TXOA	FF,F.TALK	;TALKATIVE GRAB
GRABKQ:	TXZ	FF,F.TALK	;GRAB A K QUIETLY
	MOVEM	CH,SAV16	;TO SAVE THE ACCUMULATORS
	MOVEI	CH,SAVE		;WHILE WE SCOOT ALL OVER THE
	BLT	CH,SAV16-1	;THE PLACE

;COUNT THE NUMBER OF BLOCKS NEEDED TO FILL THE REQUEST

	MOVEI	F2,^D1024	;1 BLOCK OF CORE
	MOVEI	B,1		;WE WILL NEED AT LEAST ONE BLOCK
	ADDM	F2,.JBFF	;UP THE FIRST FREE COUNT
	PUSHJ	P,CRE23		;COMPUTE A NEW MEMSIZ AND 2/3 VALUE
	CAML	17,MEMSIZ	;WILL THIS BE ENOUGH CORE?
	AOJA	B,.-3		;NO, COMPUTE ANOTHER BLOCK
;NUMBER OF BLOCKS HAVE BEEN FOUND
;OBTAIN THE NEEDED CORE FROM THE MONITOR

	MOVE	B,.JBFF		;TO HELP OUT THE MONITOR
	CAMG	B,.JBREL	;NEED TO ASK?
	JRST	EXITZ		;NO
	CORE	B,		;MAKE THE CALL TO THE MONITOR
	JRST	NOTANY		;NO CORE (OR NOT ENOUGH) AVAILABLE
	TXNN	FF,F.INIT	;IF PROCESSING INI FILE NO RANDON [NK...
	TXNN	FF,F.TALK	;MESSAGE DESIRABLE?
	JRST	EXITZ		;NO
CORES:	MOVE	A,XFLAGS	;[2010] Get the extended flags
	TXNE	A,XF.NIM	;[2010] Are information message wanted?
	 JRST	CORES0		;[2010] Yes, be quiet
	JSP	A,CONMES	;[1025] Output the
	ASCIZ	~[TECXPN ~	;[1025]  prefix
	MOVE	B,.JBREL	;SIZE OF CORE NOW
	ADDI	B,1
	ASH	B,-12
	PUSHJ	P,DECMS		;PRINT
	JSP	A,CONMES
	ASCIZ	/K Core]
/
CORES0:	TXNE	FF,F.INIT	;INIT FILES NEED NO AC RESTORE!
	POPJ	P,		;SO DON'T

;RESTORE THE AC'S AND EXIT FROM THIS COR GET ROUTINE

EXITZ:	MOVSI	CH,SAVE		;FROM TO
	BLT	CH,CH		;ALL AC'S AS THEY WERE
	POPJ	P,		;AND EXIT

;NO CORE AVAILABLE (OR NOT ENOUGH)

NOTANY:	HLRZ	A,.JBSA		;GET LAST FIGURE OF CORE BOUND
	MOVEM	A,.JBFF		;AND STORE IT
	PUSHJ	P,CRE23		;COMPUTE THE MEMSIZE VALUES AGAIN
	MOVSI	CH,SAVE		;RESTORE THE ACCUMULATORS
	BLT	CH,CH		;& INFORM THE OUTSIDE WORLD THAT THEY LOSE
	EE3+ERROR E.COR

;THIS IS AN AUXILARY SPOT FOR ENTRANCE FROM GC2
;GET THE REQUIRED CORE TO SAVE THE JOB IF POSSIBLE

PRENR9:	PUSHJ	P,GRABAK	;GET THE REQUIRED CORE
	JRST	NROOM9		;GO TRY THE INSERT AGAIN
	SUBTTL	Command Dispatch Table


; Note:  The entire command dispatch table has been changed by edit 1055


DTB:	DC.JMP!DC.SYM+ERRA		;^@
	DC.JMP!DC.SYM+COMMEN		;^A
	DC.JMP!DC.SYM+ERRA		;^B
	DC.JMP!DC.SYM+STOP		;^C
	DC.JMP!DC.SYM+ERRA		;^D
	DC.JMP!DC.SYM+FFEED		;^E
	DC.NUM!DC.SYM+LAT		;^F
	DC.NUM!DC.SYM+BELDMP		;^G <Bell>
	DC.JMP!DC.SYM+GTIME		;^H
	DC.SUB!DC.SPC!DC.SYM+TAB	;^I <Tab>
	DC.JMP!DC.SYM!DC.EOL+CD5	;^J <Line-Feed>
	DC.JMP!DC.SYM!DC.EOL+ERRA	;^K <Vertical-Tab>
	DC.SUB!DC.SYM!DC.EOL+TYO	;^L <Form-Feed>
	DC.JMP!DC.ALP+CD5		;^M <Carriage-Return>
	DC.JMP!DC.SYM+EOF		;^N
	DC.JMP!DC.SYM+OCTIN		;^O
	DC.NUM!DC.SYM+QPAGE		;^P
	DC.JMP!DC.SYM+ERRA		;^Q
	DC.JMP!DC.SYM+ERRA		;^R
	DC.JMP!DC.SYM+ERRA		;^S
	DC.NUM!DC.SYM+SPTYI		;^T
	DC.SUB!DC.SYM+IUSET		;^U
	DC.NUM!DC.SYM+LOWCAS		;^V
	DC.NUM!DC.SYM+STDCAS		;^W
	DC.NUM!DC.SYM+SETMCH		;^X
	DC.NUM!DC.SYM+QYANK		;^Y
	DC.JMP!DC.SYM+DECDMP		;^Z
	DC.JMP!DC.SYM+ALTMOD		;^[
	DC.JMP!DC.SYM+ERRA		;^\
	DC.JMP!DC.SYM+ERRA		;^]
	DC.JMP!DC.SYM+CNTRUP		;^^
	DC.JMP!DC.SYM+ERRA		;^_
	DC.NUM!DC.SPC!DC.SYM+PLUS	;<Space>
	DC.JMP!DC.SYM+EXCLAM		;!
	DC.NUM!DC.SYM+DQUOTE		;"
	DC.NUM!DC.SYM+COR		;#
	DC.JMP!DC.SYM+ERRA		;$
	DC.NUM!DC.SYM+PCNT		;%  [1013] Process numeric argument
	DC.NUM!DC.SYM+CAND		;&
	DC.JMP!DC.SYM+CD		;'
	DC.JMP!DC.SYM+OPENP		;(
	DC.NUM!DC.SYM+CLOSEP		;)
	DC.NUM!DC.SYM+TIMES		;*
	DC.NUM!DC.SYM+PLUS		;+
	DC.NUM!DC.SYM+COMMA		;,
	DC.NUM!DC.SYM+MINUS		;-
	DC.JMP!DC.SYM+PNT		;.
	DC.NUM!DC.SYM+SLASH		;/
	DC.JMP!DC.ALP+CDNUM		;0
	DC.JMP!DC.ALP+CDNUM		;1
	DC.JMP!DC.ALP+CDNUM		;2
	DC.JMP!DC.ALP+CDNUM		;3
	DC.JMP!DC.ALP+CDNUM		;4
	DC.JMP!DC.ALP+CDNUM		;5
	DC.JMP!DC.ALP+CDNUM		;6
	DC.JMP!DC.ALP+CDNUM		;7
	DC.JMP!DC.ALP+CDNUM		;8
	DC.JMP!DC.ALP+CDNUM		;9
	DC.NUM!DC.SYM+COLON		;:
	DC.NUM!DC.SYM+SEMICL		;;
	DC.NUM!DC.SYM+LSSTH		;<
	DC.SUB!DC.SYM+PRNT		;=
	DC.JMP!DC.SYM+GRTH		;>
	DC.JMP!DC.SYM+QUESTN		;?
	DC.NUM!DC.SYM+ATSIGN		;@
	DC.NUM!DC.ALP+ACMD		;A
	DC.JMP!DC.ALP+BEGIN		;B
	DC.NUM!DC.ALP+CHARAC		;C
	DC.SUB!DC.ALP+DELETE		;D  [1013] Call the delete code
	DC.SUB!DC.ALP+ECMD		;E
	DC.NUM!DC.ALP+FCMD		;F
	DC.JMP!DC.ALP+QGET		;G
	DC.JMP!DC.ALP+HOLE		;H
	DC.SUB!DC.ALP+INSERT		;I
	DC.NUM!DC.ALP+JMP		;J
	DC.SUB!DC.ALP+KILL		;K  [1033] Call the kill code
	DC.SUB!DC.ALP+LINE		;L  [1023] Call the line code
	DC.JMP!DC.ALP+MAC		;M
	DC.NUM!DC.ALP+SERCHP		;N
	DC.JMP!DC.ALP+OG		;O
	DC.SUB!DC.ALP+PUNCHA		;P
	DC.JMP!DC.ALP+QREG		;Q
	DC.NUM!DC.ALP+REVERS		;R
	DC.NUM!DC.ALP+SERCH		;S
	DC.SUB!DC.ALP+TYPE		;T
	DC.NUM!DC.ALP+USE		;U
	DC.SUB!DC.ALP+VCMD		;V
	DC.JMP!DC.ALP+MJRST		;W
	DC.NUM!DC.ALP+X			;X
	DC.SUB!DC.ALP+YANKER		;Y
	DC.JMP!DC.ALP+END1		;Z
	DC.NUM!DC.SYM+OPENB		;[
	DC.NUM!DC.SYM+BAKSL		;\
	DC.NUM!DC.SYM+CLOSEB		;]
	DC.JMP!DC.SYM+UAR		;^
	DC.NUM!DC.SYM+LARR		;_
	SUBTTL	Low Segment

	$LOW			;[1001] Relocate to the low segment

FIRST:	BLOCK	1		;[1032] The START count

LOCORE==.			;START OF THE LOW SEGMENT
IFN BISSW,<
BIS:	BLOCK	1		;FLAG TO INDICATE KL-10
>
INI:	BLOCK	1		;FLAG FOR TO DO INI FILE
TEMPP:	BLOCK	1		;PLACE TO SAVE P ON REENTER
TEMPDL:	BLOCK	1		;TEMP PDL
IFN CCL,<
CCLB:	BLOCK	3		;THE HEADER FOR CCL FILE IO
TYIPT:	BLOCK	1
> ;END IFN CCL
IFN F%RSCN,<			;[1011]
MAKCMD:	BLOCK	1		;[2002] MAKE command flag
MNGCMD:	BLOCK	1		;[2002] MUNG command flag
RSNCMT:	BLOCK	1		;[2002] Comment flag (Rescan buffer only)
RSNCNT:	BLOCK	1		;[1011] Rscan character count
RSNBUF:	BLOCK	15		;[1011] Rescan buffer >
TTYBFS:	BLOCK	46		;100 MODE TTY BFRS
TIB:	BLOCK	3		;BUFFER HEADER
TOB:	BLOCK	3		;DITTO
JOBN:	BLOCK	1		;JOB #
USRPPN:	BLOCK	1		;USER PROJ-PROG #
MONITR:	BLOCK	1		;MONITOR LEVEL: 0=3,1=4,2=5
IBUF:	BLOCK	3
OBF:	BLOCK	3
IBUF1:	BLOCK	NIBUF*<BUFSIZ+3>  ;[1041] Input buffer space
OBUF1:	BLOCK	NOBUF*<BUFSIZ+3>  ;[1041] Output buffer space
EATCH:	BLOCK	1		;FOR LAST INPUT CHARACTER IN CASE ERROR OCCURS
DLIM:	BLOCK	1
NUM:	BLOCK	1
SYL:	BLOCK	1
SARG:	BLOCK	1
PDLSAV:	BLOCK	1
VVAL:	BLOCK	1		;LENGTH OF LAST TEXT STRING PROCESSED
XFILNM:	BLOCK	17
FILDEV:	BLOCK	1		;DEVICE SPECIFIED
FILPTH:	BLOCK	2		;DIRECTORY BLOCK
FILPPN:	BLOCK	1
FILSFD:	BLOCK	5		;UP TO 5 SFD'S
SWITC:	BLOCK	1		;SWITCH BIT STORE (EACH BIT IS 1 SWITCH)
SPCDEV:	BLOCK	2		;FOR SAVING DEVICE LAST SPECIFIED
				;(1 EXTRA WD FOR PATH. UUO)
SPCPPN:	BLOCK	7		;FOR SAVING PATH LAST SPECIFIED
SPCPRO:	BLOCK	1		;FOR SAVING PROTECTION
BAKNAM:	BLOCK	2		;FOR THE BACKUP NAME
PTHCNT:	BLOCK	1		;TO COUNT SFD'S

	;***** DO NOT SEPARATE
ERSPEC:	BLOCK	12		;FOR DEFAULT ER FILE SPEC
EWSPEC:	BLOCK	12		;FOR DEFAULT EW FILE SPEC
				;(SAME AS XFILNM ABOVE EXCEPT
				;EWSPEC=DEVICE, EWSPEC+(4 - 9) = PATH
EISPEC:	BLOCK	12		;FOR DEFAULT INI FILE SPEC
	;***** DO NOT SEPARATE

RUNIT:	BLOCK	17		;FOR RUN ON SOMETHING WHEN YOU EXIT
PRMERR:	BLOCK	1		;FOR PERMANENT ERROR BITS
LOGOPN:	BLOCK	3		;FOR LOG FILE OPEN BLOCK AND FLAG FOR APPEND
OLOG:	BLOCK	3		;BUFFER HEADER FOR LOG FILE
EEFL:	BLOCK	4		;BLOCK FOR STORING EE FILSPEC
LOGFL:	BLOCK	4		;FOR LOG FILE FILESPEC
IINI:	BLOCK	3		;BUFR HEADER FOR INI FILES
LOGSPC:	BLOCK	BUFSIZ+3	;RESERVE 200 WORDS IN CASE A LOG FILE IS DESIRED
OSAV:	BLOCK	3		;OUTPUT BUFFER HEADER FOR SAVE CHANNEL
STARTL:	BLOCK	13		;FOR GET SEG STUFF
EOFLAG:	BLOCK	1		;EDIT OLD FLAG
TYCASF:	BLOCK	1		;TYPE-OUT CASE FLAG: 0 = TYPE ' BEFORE LC
				;+ = TYPE ' BEFORE UC;- = DON'T TYPE FLAGS
AUTOF:	BLOCK	1		;NON-ZERO IMPLIES AUTOTYPE AFTER SEARCHES
				;POSITIVE IMPLIES TYPE AUTOF AS A PTR MARKER

SAVAC1:	BLOCK	1		;[1042] Saved AC 1
SAVAC2:	BLOCK	1		;[1042] Saved AC 2
SAVAC3:	BLOCK	1		;[1042] Saved AC 3
SAVAC4:	BLOCK	1		;[1042] Saved AC 4

IFN CRT,<
TRMNAM:	BLOCK	1		;[2007] Terminal name from TRMOP.
NODNAM:	BLOCK	1		;[1003] The node name from 'DISPLA.INI'
LINNAM:	BLOCK	1		;[1003] The line name from 'DISPLA.INI'
VIDNAM:	BLOCK	1		;[1003] The video name from 'DISPLA.INI'
NODNUM:	BLOCK	1		;[1003] My current node number
LINNUM:	BLOCK	1		;[1003] My current line number
VIDOPN:	BLOCK	3		;[1003] 'DISPLA.INI' OPEN block
VIDLOK:	BLOCK	4		;[1003] 'DISPLA.INI' LOOKUP block
VIDHED:	BLOCK	3		;[1003] The buffer header
VIDEND=.-1			;[1003] The size of the video area
TTYWID:	BLOCK	1		;CURRENT LINE WIDTH
CRTTYP:	BLOCK	1		;TYPE OF CRT IN USE
BACRUB:	BLOCK	1		;AUXILLARY DELETE CHAR, RIGHT JUSTIFIED
VTWID:	BLOCK	1		;WIDTH OF VERTICAL TAB
FFWID:	BLOCK	1		;WIDTH OF FORM FEED
VTMUL:	BLOCK	1		;MULTIPLIER FOR DELVT
FFMUL:	BLOCK	1		;MULTIPLIER FOR DELFF
BACCHR:	BLOCK	1		;BACKSPACE CHARACTER SEQUENCE
FORCHR:	BLOCK	1		;NONDESTRUCTIVE FORWARD CURSOR, OR BLANK
BACSEQ:	BLOCK	1		;BACKUP AND DELETE SEQUENCE
DELLF:	BLOCK	1		;EOL RUBOUT STRINGS (LF, VT, FF)
DELVT:	BLOCK	1
DELFF:	BLOCK	1
DELCR:	BLOCK	1		;CARRIAGE RETURN RUBOUT STRING
CANRUB:	BLOCK	1		;STRING TO CANCEL RUBOUT
CANBAK:	BLOCK	1		;STRING TO CANCEL BACKSPACE
CTUSEQ:	BLOCK	1		;STRING TO PROCESS CONTROL-U
WRDFLG:	BLOCK	1		;[2013] Control-W flag
				;[2013]  +1:  Deleting alphanumerics
				;[2013]   0:  No special processing
				;[2013]  -1:  Deleting trailing spaces/tabs
> ;END IFN CRT

OUTCH:	BLOCK	1		;ADR OF OUTPUT ROUTINE
INCH:	BLOCK	1		;ADR OF INPUT ROUTINE
OPNRI:	BLOCK	1		;INPUT FILE OPEN ARGUMENTS, OPNRD+4(1)
OPNR1:	BLOCK	1		;INPUT DEVICE.  INIT+27(0),OPNRD+6
OPNRB:	BLOCK	1		;INITIALIZE TO XWD 0,INBUF. OPNRD+10
BAKTMP:	BLOCK	1		;FOR DECTAPE TEMP NAME
PROTEC:	BLOCK	1		;EB INPUT FILE PROTECTION
DEVSAV:	BLOCK	1		;DEVICE CHARACTERISTICS
EBDEV:	BLOCK	1		;EB DEVICE NAME
TMPTEC:	BLOCK	1		;SAVE FOR ###TEC. FILE NAME
BAKPRO:	BLOCK	1		;DESIRED PROTECTION FOR THE NEW FILE
OPNWI:	BLOCK	1		;OUTPUT FILE OPEN ARGUMENTS. OPNW1+4(1)
OPNWD:	BLOCK	1		;OUTPUT DEVICE.  OPNW1+6
OPNWB:	BLOCK	1		;OUTBUT BUFFER HEADER ADDRESS. OPNW1+10(OUTBUF)
WRICHR:	BLOCK	1		;CHARACTERISTICS OF WRITE DEVICE
OUTFIL:	BLOCK	4		;STORE FOR OUTPUT FILENAME
INFILE:	BLOCK	4		;STORE FOR INPUT FILENAME
SWINDX:	BLOCK	1		;FOR SWITCH INDEX SCAN
SWITHL:	BLOCK	1		;SWITCH CHAR HOLD
INSWIT:	BLOCK	1		;INPUT SWITCHES
OUTSWT:	BLOCK	1		;OUTPUT SWITCHES
LSNCTR:	BLOCK	1		;LSN GENERATION CTR
CTGRET:	BLOCK	1		;RETURN ADDRESS FOR ^G ROUTINE
ARGTRM:	BLOCK	1		;FS, FN 2ND ARG TERMINATOR
COMBAK:	BLOCK	1		;STORE FOR COMCNT DURING FS, FN
CPTBAK:	BLOCK	1		;DITTO CPTR
SRHCNT:	BLOCK	1		;SEARCH COUNT STORE

;Search table stuff
; *** Do not separate vvv
SMATRX:	BLOCK	SMATLN		;[334] The old TECO search bit table
BITMAT:	BLOCK	BITMLN*^D36	;[334] The new rotated search bit table
DELTA2:	BLOCK	^D36		;[334] The table which knows what the pattern looks like
SCLRLN==.-SMATRX
; *** Do not separate ^^^
DELTA0:	BLOCK	SMATLN		;[334] The tables which know where
DELTA1:	BLOCK	SMATLN		;[334] characters are in the pattern
INDMAT:	BLOCK	^D36		;[334] A table of indicies into the pattern

PATLEN:	BLOCK	1		;[334] Number of positions in pattern
ROTLEN:	BLOCK	1		;[334] Current distance from the right end of the pattern
SCNEST:	BLOCK	1		;[334] Nest level counter during searches, 0 if none
SCHTYP:	BLOCK	1		;[334] 0 if old TECO search, -1 if new search
SCTLGA:	BLOCK	1		;[334] 0 if pattern source has no ^Gi, -1 if it does

CTGLEV:	BLOCK	1		;SEARCH FOR TEXT IN Q-REG NEST COUNTER
ITERCT:	BLOCK	1
SFINDF:	BLOCK	1
ERRDEV:	BLOCK	1		;[337] Device for TECO.ERR
ERRPPN:	BLOCK	1		;[337] PPN for TECO.ERR
ERRBLK:	BLOCK	3		;[337] OPEN block for TECO.ERR
TECERR:	BLOCK	4		;LOOKUP SPECS FOR TECO.ERR
ERRHDR:	BLOCK	3		;RING HEADER FOR TECO.ERR
RELSAV:	BLOCK	1		;STORE FOR .JBREL
ARGSTO:	BLOCK	1		;STORE FOR ARGUMENT (IF ANY)
ERR1:	BLOCK	1
ERR2:	BLOCK	1
COMLEN:	BLOCK	1		;LENGTH OF BASIC COMMAND STRING
LISTF5:	BLOCK	1		;OUTPUT DISPATCH
NROOM2:	BLOCK	1		;POINTER TO LAST PARTIAL WORD ON UPWARD MOVE.
GCRET:	BLOCK	1		;GC EXIT DISPATCH
NROOM4:	BLOCK	1		;PARTIAL WORD POINTER FOR DOWNWARD MOVE
BEG:	BLOCK	1
PT:	BLOCK	1
Z:	BLOCK	1
QRBUF:	BLOCK	1
	;*** DO NOT SEPARATE ***
COMAX:	BLOCK	1		;TOTAL # OF CHARS AT CUR. CMD. LEVEL
CPTR:	BLOCK	1		;EXECUTION-TIME CMD STRING PTR
COMCNT:	BLOCK	1		;# OF CHARS REMAINING TO BE EXECUTED AT THIS LEVEL
	;*** DO NOT SEPARATE ***
CBUFH:	BLOCK	1
CBUF:	BLOCK	1
MEMSIZ:	BLOCK	1
IFN <CCL*F%RSCN>,<		;[1011]
CCLSW:	BLOCK	1
> ;END IFN CCL*F%RSCN
GCPTR:	BLOCK	1
CRREL:	BLOCK	1
GCFLG:	BLOCK	1
RREL:	BLOCK	1
M23:	BLOCK	1
M23PL:	BLOCK	1
ERRLEN:	BLOCK	1		;TYPE OF ERROR MESSAGES WANTED BY DEFAULT
AC2:	BLOCK	16		;SAVE AC2-AC17 IN NROOM ROUTINE
STAB:	BLOCK	STABLN		;SEARCH MATRIX
DEFPTH:	BLOCK	11		;DEFAULT PATH
DCLOC:	BLOCK	5		;DSKCHR BLOCK
XFLAGS:	BLOCK	1		;[1024] Extended flags
NFORMS:	BLOCK	1		;NUMBER OF FORM FEED SEEN
CURPAG:	BLOCK	1		;[1024] The current page number
XCTING:	BLOCK	1
BCOUNT:	BLOCK	1
ETVAL:	BLOCK	1		;[331] ET VALUE
EBPROT:	BLOCK	1		;[333] BAK PROTECTION & 2 RENAME SWITCH
FDAEM:	BLOCK	1		;[333] FILE DAEMON PRESENCE IF NON-ZERO
EPISEQ:	BLOCK	1		;[337] Controls EI-EP LOOKUP sequence
LFCNT:	BLOCK	1		;[346] Line feed count for :nA command

;*********
EXTRAS:	BLOCK	17		;[331] AVAILABLE LOCATIONS SO LOW SEG
				;      DOESN'T HAVE TO CHANGE
;*********

SYMS:	BLOCK	22		;LIS+4(0),OG3+1,GC+3(0)
VALS:	BLOCK	22		;LIS+4(0),OG3+3,GC+3(0)
CNTS:	BLOCK	22		;LIS+4(0),OG3+2,GC+3(0)
SYMEND:	BLOCK	0
EQM:	BLOCK	1		;LEVEL OF MACRO NESTING
SRHCTR:	BLOCK	1		;# OF CHARS IN SEARCH ARGUMENT (MUST PRECEDE SRHARG)
SRHARG:	BLOCK	^D16		;STORE FOR SEARCH ARGUMENT
PFL:	BLOCK	LPF+1
GCTAB:	BLOCK	GCTBL		;GCS3+4,GCM2+13
QTAB:	BLOCK	LNQTAB		;[1037] Q-register table
				;USEA+1,PCNT+1
PDL:	BLOCK	LPDL+1
SAVEAC:	BLOCK	2		;THIS MUST BE IMMEDIATELY BEFORE SAVE!
	LOWERB==SAVEAC+1
	UPPERB==SAVEAC+2
SAVE:	BLOCK	16		;AC STORAGE FOR GC
SAV16:	BLOCK	1
IFE BUGSW,<
CMDBFR:	BLOCK	0		;COMMAND BUFFER
> ;END IFE BUGSW
IFN BUGSW,<
CMDBFR:	BLOCK	1
>;END IFN BUGSW
LOWEND==.-1


	$LIT	NOLIST,HIGH	;[1001] So the patch space is at the
				;[1001]  top of the high segment
	SUBTTL	The End

PATCH:	$END	TECO		;[1001] End of 'TECO'
     JQ\'