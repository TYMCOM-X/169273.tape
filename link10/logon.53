	TITLE	LOGON	POST LOGIN INITIALIZATION PROGRAM
	SUBTTL	M. KOSTER/CAB/ECM/CAB/CAB

	SEARCH	ECM12,MACTEN,JOBDAT,UUOSYM,SCNMAC

	SALL

	VERSION	LON,1A(53)

	.REQUEST SYS:SCAN
	.REQUEST SYS:HELPER

	.TWOSEG
	SUBTTL	Table of contents

;			Section					Page
;    1.	Title Page..............................................   1
;    2.	Table of Contents.......................................   2
;    3.	Revision History........................................   3
;    4.	Conditional Assembly Parameters.........................   4
;    5.	Definitions, Macros.....................................   5
;    6.	Main Program............................................   6
;    7.	Subroutines.............................................   9
;    8.	    Assign:Device:Logical...............................   9
;    9.	    GT40................................................  10
;   10.	    Hazel...............................................  11
;   11.	    Hp2621..............................................  12
;   12.	    Mount:Structure.....................................  13
;   13.	    Select:Condition:Option.............................  14
;   14.	    Set:Arg { Arg2 { Arg3 } }...........................  22
;   15.	    Status..............................................  27
;   16.	    Tell................................................  28
;   17.	Error Messages..........................................  29
;   18.	Warning Messages........................................  30
;   19.	Info Messages...........................................  31
;   20.	Switches Macro..........................................  32
;   21.	OSCAN Data block........................................  33
;   22. Impure Data area........................................  34

	SUBTTL	Revision history

; %1(1) Feb 1975
;
;    2	Corrected to only /SET:TTY BLANKS
;    3	FIX UP THE GETLCH TTCALLS
;    4	ALLOW WILD CARD FOR /SELECT:PPNUSR AND OUTPUT TTY #
;    5	FIX UP TO USE ECM12 AND SCN7B FILES
;    6	DO NOT GIVE HELP BY DEFAULT
;    7	FIX AND ADD OTHER TRMOP. SETTINGS
;   10	REMOVE /NOTIFY:HELP PROCESSING
;   11	ALLOW ABBREVIATIONS FOR SELECT AND SET FUNCTIONS
;   12	ELEMINATE SOME EXTRA MONITOR CALLS
;   13	SPRUCE UP /SELECT PROCESSING
;   14	FIX UP RUN MESSAGE
;   15	ADD /SELECT:<NODE>_<CONDITION>:OPTION
;   16	Fix sense of TTY ALTMODE to be same as monitor command
;   17	Allow shorter names for some commands for small SWITCH.INI files
;   20	Enhance SET inform message and SET error message
;   21	Change messages to print <CrLf> at end of message, not beginning
;   22	Change TRMOP calls to work (conditionally) at tymshare
;   23	Partially implement Node:Line for Tymnet node,line.
;   24	Fixup /SELECT:PPN??? to look at .GTAUN at Tymshare, not GFD PPN.
;   25	Add /SELECT:(KI10,KL10,KS10,Foonly,F3) options.
;   26	Add /HP2621 switch to set tab-stops, & clear screen on Hp-2621's.
;   27	Add /Status switch to display [<config><Processor-type><#0 States>].
;   30	Add code for AUX-Circuit testing /Select:(Aux,NoAux):<option>.
;   31	Add /Select:System@<Sysname>:<option>.
;   32	Fix PPNUSR selection to check for /NOTIFY:USER before printing.
;   33	Add CPU Load!Average and Response!Time to /Status line.
;   34	Fix /PPNxxx:user-ppn to check for job logged in! .jbtsts bit 0.
;   35	Fix /Set:tty code in Chktty to forget lch wait for Aux Circuits.
;   36	Add /Set:tty RBSPACE for remote backspace echo <tymshare only>.
;   37	Fix PPNUSR message to pickup name correctly <if .gt. 10 ???>.
;   40	Fix PPNUSR msg to not print [0,0] ppns.
;   41	Add Job wait state to PPNUSR message.
;   42	Fix CVppn mis-conversions to do the appropriate things.
;   43	Fix bad return from I$$USR code, move label to POP P,T1.
;   44	Add /Set:tty TYPE xxxxxx to set tty type, .Axttp/.Totrm calls.
;   45	Add /Set:tty DEFER to TOPS-10 code using the .TODEM trmop.
;   46	Add Current date-time to /Status switch.
;   47	Add TYMNET (Node-TTY) to PPNUSR message.
;   50	Modify PPNUSR message, remove PPN@Tymshare, add AUN(PPN).
;   51	Remove /Assign:dev:log at Tymshare, IFE TYMCOM,<...>.
;   52	Fix /SELECT code to accept [p,pn] if specified, vis #42.
;   53	Fix /STATUS code to timeout for lost yellow balls and type frame #.


	Subttl	Conditional assembly parameters

ifndef	Tymcom,<Tymcom==-1>	; Default to Tymcom-X monitor

ifn Tymcom,<
	.Rbunm==27			;[50] UFD username (2 words)
	.Gtnm1==.Gtunm			; Fix DEC's def == Username part 1
	.Gtnm2==.Gtun1			; Fix DEC's def == Username part 2
	%NSHJB==.Nshjb,,.Gtnsw		; Highest job,,Non-swapping table

	%CNFG0==.Cnfg0,,.Gtcnf		; System name,,Config table
	%CNFG1==.Cnfg0+1,,.Gtcnf	; System name,,Config table
	%CNFG2==.Cnfg0+2,,.Gtcnf	; System name,,Config table
	%CNFG3==.Cnfg0+3,,.Gtcnf	; System name,,Config table
	%CNFG4==.Cnfg0+4,,.Gtcnf	; System name,,Config table

	%CNSTS==.Cnsts,,.Gtcnf		; States-word,,Config table

	.Opdev==1		; Open block Device name
	.Toset==0		; Make this go away!

	.Axbsd==77		;[36] Backspace delete
	.Axttp==100		;[44] Terminal type
>
	SUBTTL	DEFINITIONS

	ND	PDLSIZ,^D100		;PDLSIZE
	ND	OPT.NO,^D10		;MAXIMUM LEVEL OF /SELECT NESTING

	OPTION==.SCANZ##+535		;DEFINE OPTION FOR LINK
	N.DEV==N.ZER##			;RUN BLOCK DEVICE

DEFINE	MSG	(BITS),<	;;MACRO TO DECIDE IF A MESSAGE CAN BE TYPED
	SETCM	T1,NOTES	;;GET COMPLIMENTED NOTIFY BITS THE USER WANTS
	TRNE	T1,%'BITS	;;DOES HE WANT TO BE DISTURBED?
	RETURN			;NO--JUST RETURN
>

DEFINE	IFSTRG	(BITS,STRING)<		;;MACRO TO DECIDE IF A MESSAGE
	MOVEI	T1,[ASCIZ\ STRING\]	;;SHOULD BE PRINTED & TO PRINT
	TXNE	P1,BITS			;;IT IF SO, ELSE NO PRINTING IS
	XCALL	.TSTRG			;;DONE.
>
	SUBTTL	MAIN PROGRAM

LOGON::	.RESET				;[5]RESET THE WORLD
	SKPINL				;DEFEAT THE ^O
	  JFCL
	MOVEI	T1,1			;GET A 1
	MOVEM	T1,STRLTH		;PUT A 1 THERE
	SETO	T1,			;[12]SETUP AND
	GETLCH	T1			;[12]GET OUR LINE CHARACTERISTICS
	MOVEM	T1,LINCHR		;[12]SAVE THE LINE CHARACTERISTICS
	HRRZM	T1,TTYNO		;[12]AND SAVE THE TTY NUMBER
	GETLIN	T1,			;[12]GET THE TTY NAME
	MOVEM	T1,TTYNAM		;[12]AND SAVE IT
ife tymcom,<
	HRRZ	T1,TTYNO		;[15]GET TTY NUMBER AGAIN
	GTNTN.	T1,			;[15] TO RETURN NODE,,LINE
	  SETO	T1,			;[15]ASSUME -1,,-1 IF CANNOT GET IT
	HLREM	T1,TTYNOD		;[15]AND SAVE THE RESULTS
	HRREM	T1,TTYLIN		;[15]FOR THE SELECT INFO.
	MOVE	T3,TTYNOD		;[15] ...
	CALL	GETNOD			;[15]GET THE CURRENT NODE
	MOVEM	T1,NODNAM		;[15] AND STORE IT.
	> ; End ife tymcom
ifn tymcom,<
	hrroi	T1,.Gtlog		;[23] Get the Tymnet Node:line, etc.
	Gettab	T1,			;[23] ...
	  Setz	T1,			;[23] Shouldn't happen
	Move	T2,T1			;[23] Copy it
	Setom	Tymaux			;[30] Set Aux Circuit field (-1)
	Txne	T1,17b11		;[30] Skip if bits are off
	  Setzm	Tymaux			;[30] Clear Aux Circuit field (0)
	Andi	T2,177			;[23] Save Line number
	Movem	T2,TTYNOD		;[23] ...
	Lshc	T1,-^d14		;[23] First set of 6 bits
	Lsh	T1,-2			;[23] Throw away garbage bits
	Lshc	T1,-^d30		;[23] Should now have the right ones
	Andi	T2,7777			;[23] Make it Octal Node #
	Movem	T2,NODNAM		;[23] Store it
	> ; End ifn tymcom

	SUBTTL	MORE MAIN PROGRAM.

	Store	T1,Cnfnam,Cnfend,0	;[27] Clear data area
	Movx	T1,%Cnfg0		;[27] Get the name of the system
	Gettab	T1,			;[27]     from the monitor
	  Setz	T1,			;[27]     tables.
	Movem	T1,Cnfnam		;[27] and store it away for
	Movx	T1,%Cnfg1		;[27] later printing.
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+1		;[27] ...
	Movx	T1,%Cnfg2		;[27] ...
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+2		;[27] ...
	Movx	T1,%Cnfg3		;[27] ...
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+3		;[27] ...
	Movx	T1,%Cnfg4		;[27] ...
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+4		;[27] ... Done!
ifn tymcom,<	;; Depends upon name in form (Xnnnn-...), C930-P034/H.
	Move	T1,[Point 7,Cnfnam]	;[31] Pointer to name
	Move	T2,[Point 6,Chname]	;[31] Pointer for Char-name
	Move	T3,[Point 6,Syname]	;[31] Pointer to Number-name
	Ildb	T4,T1			;[31] Get first Char
	Movei	T4,' '-" "(T4)		;[31] Convert to Sixbit
	Idpb	T4,T2			;[31] Deposit it
Sysnlp:	Ildb	T4,T1			;[31] Get a Char
	Cain	T4,"-"			;[31] Read up to a dash (-)
	  Jrst	Sysndn			;[31] Then stop!
	Movei	T4,' '-" "(T4)		;[31] Convert to Sixbit
	Idpb	T4,T2			;[31] Deposit it Ch-name
	Idpb	T4,T3			;[31] Deposit it Nu-name
	Jrst	Sysnlp			;[31] Loop till find a dash
Sysndn:	> ; End ifn tymcom
	PJOB	T1,			;[12]GET OUR JOB NUMBER
	MOVEM	T1,MYJOB		;[12]AND SAVE IT

	SUBTTL	MORE MAIN PROGRAM.

	SETZ	T1,			;NULL .ISCAN CALL
	XCALL	.ISCAN			;INIT SCAN
	MOVE	T1,OBLK			;MOVE BLK HEADER FOR OSCAN
	XCALL	.OSCAN	
	MOVEI	T1,OPT.NO		;GET  NESTING MAX FOR /SELECT
	MOVEM	T1,OPTCNT		;AND STORE IT AWAY
LOGON0:	SKIPN	T1,SELOPT		;/SELECT:OPTION SPECIFIED?
	JRST	LOGON1			;N0--NO MORE .OSCAN CALLS
	MOVEM	T1,OPTION		;YES--STORE IN SCAN
	SETZM	SELOPT			;AND CLEAR THE FLAG
	MOVE	T1,OBLK			;MOVE BLK HEADER FOR OSCAN
	CALL	.OSCAN			;YES--DO ANOTHER .OSCAN
	SOSLE	OPTCNT			;IS THIS SELECT NESTED TOO DEEP?
	JRST	LOGON0			;NO--GO PROCESS IT
	CALL	E$$SNE			;YES--TYPE ERROR
	EXIT				;AND QUIT

LOGON1:	MOVS	T1,STRLTH		;NO--GET THE LENGTH OF THE LIST
	HRRI	T1,STRLST		;GET THE ADDRESS
	SOSG	STRLTH			;SKIP IF ANY /MOUNT'S DONE
	JRST	LOGON2			;SKIP TO MISS SEARCHLIST ERRORS
	STRUUO	T1,			;PUT UP THE LIST
	  CALL	E$$CSS			;NO--CAN'T SET SEARCH-LIST
LOGON2:	SKIPE	N.DEV			;IS THERE A PROGRAM TO RUN?
	CALL	I$$RUN			;YES--GO TELL USER
	XCALL	.RUNCM			;RUN ANOTHER PROGRAM
	XCALL	.TCRLF			;ADD A FREE CR-LF
	EXIT				;   THEN PERMANENTLY EXIT
	SUBTTL	SUBROUTINES

Ife Tymcom,<	;[51] Remove Assign code until we find how to do it here!
;ASSIGN -- ASSIGN A DEVICE AND GIVE IT A LOGICAL NAME
;CALL:	PUSHJ	P,ASSIGN	OR (CALL ASSIGN) /ASSIGN: PROCESSOR
;	RETURN

ASSIGN:	XCALL	.FILIN			;GET DEVICE FILESPEC
	MOVEI	T1,DEVICE		;LOC OF DEVICE
	MOVX	T2,2			;JUST DEVICE & LOGICAL NAME
	XCALL	.GTSPC			;ASK SCAN TO TRANSFER
	SETZ	T1,			;GO TO THE NULL JOB
	MOVE	T2,LOGNAM		;GET THE  LOGICAL NAME
	REASSI	T1,			;DEASSIGN IT
	MOVE	T1,DEVICE		;GET THE DEVICE NAME
	MOVEM	T1,LGNOPK+.OPDEV	;PUT IN THE OPN BLK
	OPEN	1,LGNOPK		;OPEN SESAMIE??
	  PJRST	W$CAD			;DEVICE NOT AVAILABLE
	SETO	T1,			;ZAP TO -1
	MOVEI	T2,1			;GET THE CHAN
	REASSI	T1,			;REASSIGN THE CHANNEL
	MOVEI	T1,1			;GET IT AGAIN
	MOVE	T2,LOGNAM		;GET THE LOGICAL NAME
	DEVLNM	T1,			;GET THE DEVICE SET
	  PJRST	W$CAD			;ASSIGNMENT ERROR
	CALL	I$$ASD			;ASSIGNMENT INFO
	RELEAS	1,			;RELEASE THE CHANNEL
	RETURN

W$CAD:	RELEAS	1,			;LET IT GO
	MSG	<WARN>			;ONLY GIVE MESSAGE IF WANT WARNINGS
	PGOTO	W$$CAD			;CAN'T ASSIGN DEV:LOGNAM

>	; End Ife Tymcom
;GT40 -- CLEAR THE SCREEN ON A GT40 DISPLAY
;CALL:	PUSHJ	P,GT40		OR (CALL GT40) /GT40 PROCESSOR
;	RETURN

GT40:	IONEOU	[.CHFFD]		;CLEAR SCREEN WITH IMAGE FORM FEED
	RETURN
;HAZEL -- CLEAR THE SCREEN ON A HAZELTINE
;CALL:	PUSHJ	P,HAZEL		OR (CALL HAZEL) /HAZEL PROCESSOR
;	RETURN

HAZEL:	XCALL	.TCRLF			;TYPE A CRLF TO NEARLY CLEAR HOR POS
	IONEOU	[176]			;CLEAR THE HAZELTINE SCREEN
	IONEOU	[234]
	IONEOU	[377]
	IONEOU	[377]
	Return

;HP2621 -- CLEAR THE SCREEN ON A HP2621 (Tymshare 444)
;CALL:	PUSHJ	P,HP2621	OR (CALL HP2621) /HP2621 PROCESSOR
;	RETURN

HP2621:	Ioneou	[15]			;[26] Make sure at left margin
	Ioneou	[33]			;[26] then clear tab settings.
	Ioneou	["3"]			;[26] (All of them)
	Hrroi	T1,.Axwid		;[26] Get width
	Seto	T2,			;[26] from the monitor
	Auxcal	T1,T2			;[26] (it might be accurrate)
	Movei	T3,1			;[26] simulate WRS code 2 step 1
Hploop:	Caml	T3,T2			;[26]    until WID
	  Jrst	Hpend			;[26]
	Ioneou	[40]			;[26]    Type  (space)
	Trnn	T3,7			;[26]    If mod (8) then
	  pushj	P,[Ioneou    [33]	;[26]        set tab stop
		   Ioneou    ["1"]	;[26]        (esc 1)
		   Return]		;[26]
	Aoja	T3,Hploop		;[26] Loop across the line
Hpend:	Ioneou	[15]			;[26] return to left margin
	Ioneou	[33]			;[26] home cursor
	Ioneou	["H"]			;[26]
	Ioneou	[33]			;[26] Clear screen
	Ioneou	["J"]			;[26]
	Return
ife tymcom,<

;MOUNT -- ADD PACK TO SEARCH LIST
;CALL:	PUSHJ	P,MOUNT	OR (CALL MOUNT) /MOUNT: PROCESSOR
;	RETURN

MOUNT:	XCALL	.SWSXQ			;PARSE PACK NAME
	MOVE	T1,.NMUL##		;GET SIXBIT PACK-NAME
	MOVEM	T1,LGNOPK+.OPDEV	;PUT IT INTO OPEN BLOCK
	OPEN	1,LGNOPK		;OPEN THE FILE-DEV
	  JRST	MOUFIN			;LOGON - PACK NOT AVAILABEL
	MOVE	T2,STRLTH		;GET THE CONTENTS OF THEIS
	MOVEM	T1,STRLST(T2)		;PUT THIS INTO CURRENT LIST
	MOVEI	T2,3			;GET A 3
	ADDM	T2,STRLTH		;ADD TO THE STR-LENGTH
	MOVE	T1,.MYPPN##		;GET OUR PPN
	MOVSI	T2,'UFD'		;GET THE EXT FOR UFD
	SETZB	T3,UFDFLG		;CLEAR 3RD ARG & UFDFLG
	MOVE	T4,[1,,1]		;GET 1,1 MFD
	LOOKUP	1,T1			;SEE IF A UFD HERE
	  SETOM	UFDFLG			;SET FLAG TO -1 -- NO UFD
	CALL	I$$MOU			;INFO ON WHETHER MOUNTED, ETC.
MOUFIN:	RELEAS	1,			;RELEASE THE CHANNEL
	RETURN
> ; end ife tymcom
;SELECT -- DETERMINE OPTIONS TO TAKE ON SUBSEQUENT .OSCAN CALL
;CALL:	PUSHJ	P,SELECT	OR (CALL SELECT) /SELECT: PROCESSOR
;
SELECT:	SETZM	SPNODE			;[15]CLEAR THE SPECIFIED NODE
	Call	Getfil			;[32] Read in the arguments
ife tymcom,<
	CAIN	C,"_"			;[15]HAVE WE A "NODE" SELECTION?
	  CALL	NODE			;[15]PERFORM SPECIAL NODE FUNCTIONS
>
	SKIPE	SELOPT			;HAVE WE BEEN THIS WAY BEFORE?
Ifn Tymcom,<  Jrst	Selec2>		;[31] Do some checking then, return
Ife Tymcom,<  Return	>		;[31] then return
	MOVE	T1,[IOWD SELSIZ,SELNAM]	;[11]POINT TO LEGAL VALUE TABLE
	HLLZ	T2,OPTFUN		;[13]GET THE CONDITION(LH)
	IF	(T2,NE,<[SIXBIT/TTY/]>)	;[13]IF NOT TTYNNN, THEN
	  MOVE	T2,OPTFUN		;[13]  GET THE WHOLE WORD
Ifn Tymcom,<
	If	(T2,EQ,<[SIXBIT/DSK/]>)	;[31] If it's DSK...
	  Move	T2,OPTARG		;[31] Then use the ARG word.
	> ; End Ifn Tymcom
	XCALL	.LKNAM			;[11]LOOK FOR A MATCH
	  PGOTO	E$USF			;[11]ERROR--UNKNOWN OR AMBIGUOUS SET FUNCTION
	CALL	@SELPRO-SELNAM(T1)	;[11,13]GOOD--DISPATCH TO PROCESSING ROUTINE
	  RETURN			;[13]NO MATCH--JUST RETURN

SELEC1:	MOVE	T1,OPTARG		;GET THE NEW OPTION
	MOVEM	T1,SELOPT		;ASK FOR NEW OPTION LATER
	RETURN


Ifn tymcom,<
Selec2:	Move	T2,Optfun		;[31] Get the function name
	If	(T2,EQ,<[SIXBIT/DSK/]>)	;[31] re-do disk /sel:sys... check
	  Xcall	.FILIN			;[31] read another spec.
	Return				;[31] then return
	> ; End ifn tymcom

ife tymcom,<
NODE:	MOVE	T3,OPTARG		;[15]GET NODE NAME
	CALL	GETNOD			;[15] NUMERIC VALUE
	MOVEM	T1,SPNODE		;[15]SAVE THIS ONE...
	XCALL	.FILIN			;GET LOC:OPTION[PPN]
	MOVEI	T1,OPTFUN		;START OF OPTIONS STORAGE
	MOVEI	T2,OPTSIZ		;SIZE DESIRED
	XCALL	.GTSPC			;ASK SCAN TO TRANSFER
	RETURN				;[15]AND RETURN
>
	Subttl	Routine to read in a file spec & do the necessary stuff

Getfil:	XCALL	.FILIN			;GET LOC:OPTION[PPN]
	MOVEI	T1,OPTFUN		;START OF OPTIONS STORAGE
	MOVEI	T2,OPTSIZ		;SIZE DESIRED
	XCALL	.GTSPC			;ASK SCAN TO TRANSFER
ifn tymcom,<
	Skipe	optppn			;[52] Only convert if no PPN
	  Return			;[52]
	Move	T2,optmore		; Get Name
	Move	T3,optmore+2
	Pushj	P,CVppn			; Make a ppn?
	  Setz	T1,
	Movem	T1,optppn		; !
>
	Return

ifn tymcom,<
	Subttl	Routine to convert PPN from name

;CVPPN 	- Routine to Take the two words of sixbit in T2 & T3  and
;	  return a PPN descriptor word [Gan,Uun] in T1
;	  This is done by dirtying (wiping out) a channel!!! OOPS!
;
;	Call:	Dmove	T2,<Username>
;		Pushj	P,CVPPN
;		  <Error Return>	; PPN conversion not done
;		<Good Return>		; T1 contains PPN
;
CVPPN:	Hrloi	T1,.Chopn		; Use a scratch channel
	Chanio	T1,[17
		    Sixbit/DSK/
		    0]
	  Return			; Sickkk!!! So return
	Hrli	T1,.Chlk		; Now lookup him
	Pushj	P,.Save4##		; Use ScAN. to save registers
	Movei	P1,3			; for the lookup
	Move	P2,[1,,1]		; Use standard MFD place
	Movei	P3,T2			; address of routine
	Movsi	P4,'ufd'		; UFD of course (ext)
	Chanio	T1,P1			; Do the lookup
	  jfcl				; It fails sometimes if not priv.lic
	Hrli	T1,.Chrel		; Release the channel
	Chanio	T1,			; ...
	Move	T1,P3			; Get some information
	caie	T1,T2			; If it still says T2 then failed
	 Aos	(p)			; Else, it's good!
	Return				; Bye
> ; end ifn tymcom

	SUBTTL	/SELECT:FUNCTION:OPTION[PPN] TABLES

	DEFINE	SELTBL	<
	X	ALWAYS
ife tymcom,<
	X	BATCH
	X	PTY
>
	X	PPNON
	X	PPNOFF
	X	PPNUSR
;	X	OPSER
	X	CCL
	X	NOCCL
ife tymcom,<
	X	REMOTE
	X	LOCAL
	X	DATASET
	X	CTY
>
ifn tymcom,<
	X	AUX
	X	NOAUX
	X	SYSTEM
	X	SYSNO
>
	X	DET
	X	TTY
	X	KL10
	X	KI10
	X	KS10
	X	F3
	X	FOONLY
>
	DEFINE	X (NAME)	<EXP SIXBIT/NAME/>

SELNAM:	SELTBL
SELSIZ==.-SELNAM

	DEFINE	X (NAME)	<EXP NAME>

SELPRO:	SELTBL
	SUBTTL	/SELECT:FUNCTION SUBROUTINES

ALWAYS==SELEC1

ife tymcom,<
BATCH:	HRROI	T1,.GTLIM		;SETUP FOR GETTAB LIMITS WORD
	GETTAB	T1,			;PICK UP THE WORD
	  SETZ	T1,			;ERROR--ASSUME NOT BATCH
	TXNE	T1,JB.LBT		;[13]IS THIS A BATCH JOB?
	  AOS	(P)			;[13]YES--SKIP RETURN
	RETURN
>

ife tymcom,<
PTY:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.ITY		;ARE WE ON A PTY?
	  AOS	(P)			;[13]YES--SKIP RETURN
	RETURN
>

CCL:	IFI	(OFFSET,NE,0)		;[13]IF CCL ENTRY TO LOGN, THEN
	  AOS	(P)			;[13]YES--SKIP RETURN
	RETURN
NOCCL:	IFI	(OFFSET,EQ,0)		;[13]IF NORMAL ENTRY TO LOGON, THEN
	  AOS	(P)			;[13]  SKIP 
	RETURN

	Subttl	/Select:<Ppn-criteria>:  { PPNON, PPNOFF, PPNUSR }

PPNON:	CALL	CHKPPN			;IS THIS PPN ON SOMEWHERE?
	  RETURN			;NO--FORGET IT
	PGOTO	.POPJ1##		;[13]YES--THEN ACCEPT THIS OPTION

PPNOFF:	CALL	CHKPPN			;IS THIS PPN NOT! ON THE SYS?
	  AOS	(P)			;[13]YES--NOT ON, ACCEPT OPTION
	RETURN				;NO--PPN ON, SO FORGET IT

PPNUSR:	Skipe	Optppn			;[42] Make sure we have a ppn
	Call	PPNUS0			;[32] Permit multiple ppn's
	Caie	C,","			;[32] terminated with a comma?
	  Return			;[32] No -- no more.
	Call	Getfil			;[32] Get next file-spec & convert ppn
	Jrst	PPNUSR			;[32] Loop through list.

PPNUS0:	CALL	CHKPPN			;IS THIS PPN ON THE SYSTEM?	[4]
	  RETURN			;NO--FORGET IT			[4]
PPNUS1:	CALL	I$$USR			;YES--TELL USER ABOUT HIM	[4]
	CALL	CHKEND			;[13]ELSE CHECK FOR MORE PPN'S	[4]
	  RETURN			;NONE FOUND--RETURN		[4]
	JRST	PPNUS1			;GOT ONE--OUTPUT STUFF		[4]

CHKPPN:	MOVE	T3,MYJOB		;[12]GET OUR JOB SO WE DON'T CHECK US
	MOVE	T2,[%NSHJB]		;GET HIGHEST JOB NUMBER ASSIGNED
	GETTAB	T2,			; FROM .GTNSW TABLE
	  MOVEI	T2,^D512		;FAILURE--ASSUME 512
CHK.LP:	CAMN	T3,T2			;IS IT OUR 
	JRST	CHKEND			;YES--SO WE DON'T COUNT
	HRL	T1,T2			;GET THE JOB NUMBER TO CHECK
	HRRI	T1,.GTSTS		;[34] See if Job is logged in
	Gettab	T1,			;[34] by checking
	  Jrst	CHKEND			;[34] the JNA bit
	Txnn	T1,1b3			;[34] see if it's on
	  Jrst	CHKEND			;[34] No! Not a job.
	HRL	T1,T2			;GET THE JOB NUMBER TO CHECK
ife tymcom,<	;PPn at most sites
	HRRI	T1,.GTPPN		;SETUP FOR GETTAB
	> ; End ife tymcom
ifn tymcom,<	;Tymshare wants AUN 
	HRRI	T1,.GTAUN		;SETUP for GETTAB
	> ; End ifn tymcom
	GETTAB	T1,			;LOOK FOR THE JOB'S PPN
	  JRST	CHKEND			;FAILURE--ASSUME JOB NOT LOGGED IN
	ORCM	T1,OPTPPM		;MASK THE PPN WE GOT
	TXZ	T1,<1B0!1B18>		;WATCH THOSE FIRST BITS
	CAMN	T1,OPTPPN		;IS THE PPN ON ELSEWHERE?
	AOSA	(P)			;YES--DO A FUNNY SKIP RETURN
CHKEND:	SOJG	T2,CHK.LP		;NO--LOOP FOR ALL JOBS
	RETURN				;AND GO HOME

	Subttl	/Select:<Terminal-criteria>: { REM,LOC,DATA,DET,CTY,TTY,*AUX }

ife tymcom,<
REMOTE:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.REM		;IS THIS A REMOTE TTY?
	  AOS	(P)			;[13]YES--SKIP
	RETURN

LOCAL:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNN	T1,GL.REM		;IS THIS A LOCAL TERMINAL?
	  AOS	(P)			;[13]YES--SKIP
	RETURN

DATASET:MOVE	T1,LINCHR		;GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.DSL		;IS THIS A DATASET LINE?
	  AOS	(P)			;[13]YES--SKIP
	RETURN
>

DET:	HLLZ	T1,TTYNAM		;[12]GET TTY GENERIC NAME
	JUMPE	T1,.POPJ1##		;[12,13]MATCH IF NULL(DET)
	RETURN				;[12]NO--JUST RETURN

ife tymcom,<
CTY:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.CTY		;ARE WE ON THE CTY?
	  AOS	(P)			;[13]YES--SKIP
	RETURN
>

TTY:
ife tymcom,<
	IFI	(SPNODE,NE,0)		;[15]IF NODE 0, USE TTYnnn
	  PGOTO	NTTY			;[15]  ELSE USE SPECIAL NODE ROUTINE
>
	IF	(TTYNAM,EQ,OPTFUN)	;[13]IF THIS IS THE SELECTED TTY,
	  AOS	(P)			;[13]  THEN SKIP
	RETURN

ife tymcom,<
NTTY:	HRRZ	T1,OPTFUN		;[15]READ nnn FROM TTYnnn
	CALL	CNVT6O			;[15]CONVERT 6-BIT # TO OCTAL
	HRL	T1,SPNODE		;[15]FILL IN LINE # FOR TTY
	GTXTN.	T1,			;[15]NOW WE SHOULD HAVE TTYnnn IN SIXBIT
	  RETURN			;[15]ERROR--CAN'T GET IT RETURN
	IF	(T1,EQ,TTYNAM)		;[15]NOW SEE IF A MATCH
	  AOS	(P)			;[15]DO SKIP-RETURN
	RETURN				;[15]ELSE RETURN
>

Ifn tymcom,<	;;Aux Circuit testing!
Aux:	Skipe	Tymaux			;[30] Skip return if an Aux
	Aos	(P)			;[30] !!!
	Return
Noaux:	Skipn	Tymaux			;[30] Skip return if not an Aux
	Aos	(P)			;[30] !!!
	Return
	> ; End ifn tymcom
	Subttl	/Select:<Processor-type>: { Foonly,F3,KI10,KL10,KS10 }

Foonly:
F3:	Movei	T2,5			;[25] Foonley F3
	Jrst	K.Type			;[25] ...Check...

Ks10:	Movei	T2,3			;[25] KS-10 processor
	Jrst	K.Type			;[25] ...Check...
Kl10:	Movei	T2,2			;[25] KL-10 processor
	Jrst	K.Type			;[25] ...Check...
Ki10:	Movei	T2,1			;[25] KI-10 processor

K.Type:	push	p,			;[25] Save it.
	setz				;[25] Clear register
	blt				;[25] Try out BLT
	hrrzm				;[25] 0=KI/F3, 1=non-KI/F3;
	jumpg	K.Typ0			;[25]          ***********
	seto				;[25] Clear again
	aobjn				;[25] Try out AOBJN
	Movei	T1,1			;[25] Assume KI(1)
	Skipe				;[25] 0=non-F3, 1,,0=F3;
	  Movei	T1,5			;[25] No--Make it F3(5)
	Jrst	K.Tret			;[25] Return
K.Typ0:	Move	[20,,11]		;[25] Get serial number
	gettab				;[25] from the monitor
	  setz				;[25] ...don't forget skip...
	andi	70000			;[25] serial resolves KL vs KS;
	Movei	T1,2			;[25] Assume KL(2)
	Skipe				;[25] KL is [?:''07777];
	  Movei	T1,3			;[25] KS is ['10000:'70000];
K.Tret:	pop	p,			;[25] Restore it.
	Camn	T1,T2			;[25] Does it match?
	  Aos	(p)			;[25] Yes! Set skip return.
	Return				;[25] Then Return.

K.Tab:	Sixbit	/KA-10/			;[27] 0==KA (No test!!!)
	Sixbit	/KI-10/			;[27] 1==KI
	Sixbit	/KL-10/			;[27] 2==KL
	Sixbit	/KS-10/			;[27] 3==KS
	Sixbit	/UNK/			;[27] 4==Unknown
	Sixbit	/Foonly/		;[27] 5==Foonly F3
K.Len==.-K.Tab-1			;[27] Length based on 0-n

Ifn tymcom,<
System:
Sysno:	Cain	C,"@"			;[31] Documented char is "@"
	  Jrst	Sysnok			;[31] Ok!
	Caie	C," "			;[31] Separator should be " " or ","
	Cain	C,","			;[31]
	  Caia				;[31] Ok!
	Return				;[31] Bye .. Illegal separator
Sysnok:	XCALL	.FILIN			;[31] GET LOC:OPTION[PPN]
	MOVEI	T1,OPTFUN		;[31] START OF OPTIONS STORAGE
	MOVEI	T2,OPTSIZ		;[31] SIZE DESIRED
	XCALL	.GTSPC			;[31] ASK SCAN TO TRANSFER
	Move	T1,Optfun		;[31] Get system number
	Came	T1,Syname		;[31] try it first without char
	Camn	T1,Chname		;[31] then, with character (if missed)
	  Aos	(P)			;[31] Skip return if match!
	Return				;[31] Else, normal return.
> ; End ifn tymcom
	SUBTTL	SUBROUTINES FOR /SELECT:	GETNOD & CNVT6O

ife tymcom,<
GETNOD:	MOVE	T1,[XWD .NDRNN,T2]	;[15]SETUP FOR NODE. UUO
	MOVEI	T2,2			;[15] ...
	SETZ	T4,			;[15] ...
	NODE.	T1,			;[15]TRANSCRIBE THE NODE # TO
	  SETZ	T1,			;[15] SIXBIT FOR /SELECT CODE
	RETURN				;[15]RETURN  T1 CONTAINING NODE
>

CNVT6O:	PUSH	P,T1			;[15]THIS IS WHAT WE'RE CONVERTING
	MOVE	T3,[POINT 6,(P)]	;[15]SETUP BYTE POINTER
	MOVEI	T4,6			;[15]MAXIMUM OF 6 DIGITS
	SETZ	T1,			;[15]CLEAR REPOSITORY
CNVT60:	ILDB	T2,T3			;[15]READ A CHARACTER
	JUMPE	T2,CNVT61		;[15]IGNORE BLANKS
	CAIL	T2,'0'			;[15]NUMERICS FROM 0
	CAILE	T2,'7'			;[15]  THROUGH 7
	  RETURN			;[15]NO--RETURN AS IS
	LSH	T1,3			;[15]MAKE ROOM FOR MORE
	MOVEI	T2,-'0'(T2)		;[15]MAKE NUMERIC
	ADD	T1,T2			;[15]PUT NEXT DIGIT INTO RESULT
CNVT61:	SOJG	T4,CNVT60		;[15]LOOP TILL OUT OF CHARS
	POP	P,(P)			;[15]RESTORE REGISTERS
	RETURN				;[15] & RETURN
;SET -- EXECUTE MONITOR .SET COMMANDS
;CALL:	PUSHJ	P,SET	OR (CALL SET) /SET: PROCESSOR

SET:	SETZM	TT.NOP			;CLEAR THE NO ARG  FLAG
	SETOM	SETCMD+2		;PRESET NUMERIC SET CMD WORD
	XCALL	.FILIN			;GET FUNCTION & FIRST ARG
	MOVEI	T1,FUNCTION		;STORE FUNCTION ADR
	MOVEI	T2,FUNSIZ		; enough words!
	XCALL	.GTSPC			;ASK SCAN TO TRANSFERE
	Move	T1,FUNCTION		;See what function
	Camn	T1,[Sixbit 'DSK']	;Is it DSK?
	  MOVE	T1,ARG			;Yes--So use next value instead
	MOVEM	T1,SETCMD		;SAVE THE SET COMMAND NAME
	Move	N,T1			;Copy, since N has 'arg' already!
	MOVE	T1,[IOWD ST.LEN,SETTBL]	;[20] Point to legal SET args
	XCALL	.NAME			;[20] Check for a match
	  PGOTO	E$$ISC			;[20] No match or ambiguous
	HRRZ	T1,T1			;[20] Get offset in table
	SUBI	T1,SETTBL		;[20] Compute real offset
	MOVEM	T1,ST.IDX		;[20] Put this into an index
	PGOTO	@SETDSP(T1)		;[20] Ok, so process it

	SUBTTL	TABLE OF SET COMMANDS

DEFINE	SETLST<
	SETARG	TTY,DO.TTY
ifn Tymcom,<
	SETARG	ALP,DO.ALP
	>
>

DEFINE SETARG(ARG,PROC)<
	SIXBIT	/ARG/
>
SETTBL:	SETLST
	ST.LEN==.-SETTBL

DEFINE SETARG(ARG,PROC)<
	EXP	PROC
>
SETDSP:	SETLST
;SET TTY commands come here from /SET:TTY

DO.TTY:	Xcall	Chktty			;[tym] Make sure network setup
	CAIE	C," "			;MAKE SURE IT'S A SPACE
	PJRST	E$$IBC			;ILLEGAL BREAK CHAR
	XCALL	.SIXSW			;GET NEXT WORD
	CAME	N,[SIXBIT/NO/]		;IS CMD A TTY NO ...
	CAMN	N,[SIXBIT/N/]		;[17] Or shorter "N"
	  CAIA				;[17] Yes--Skip
	JRST	DO.TT0			;NO--ASSUME ITS A TTY ...
	SETOM	TT.NOP			;YES--FLAG AS SUCH
	CAIE	C," "			;IS THE DELIMETER A SPACE
	PJRST	E$$IBC			;NO--ILLEGAL BREAK CHAR
	XCALL	.SIXSW			;GET THE REAL TTY ARG
DO.TT0:	MOVEM	N,SETCMD+1		;SAVE  SET TTY ARG
	MOVE	T1,[IOWD TT.LEN,TTYTBL]	;[11]POINT TO LEGAL TTY ARGS
	XCALL	.NAME			;[11]CHECK FOR A MATCH
	  PGOTO	E$$ITS			;[11]NO MATCH OR AMBIG
	HRRZ	T1,T1			;GET OFFSET IN TABLE
	SUBI	T1,TTYTBL		;COMPUTE REAL OFFSET
	MOVEM	T1,TT.IDX		;PUT THIS INTO AN INDEX
	HRRZ	T1,TRMTBL(T1)		;[11]GET ADR OF ROUTINE
	PGOTO	(T1)			;[11]DISPATCH TO RIGHT PROCESSOR

Chktty:
ifn tymcom,<
	Skipn	Tymaux			;[35] Don't do this if an Aux Circuit
	Skipe	TTY.OK			;[24] See if first time through.
	  Return			;[24] No, simply return.
	Setom	TTY.OK			;[24] Set it so we don't do it again!
	Move	T3,[270,,500]		;[24] Return when output complete.
	Getlch	T2			;[24] Ok, now get it once
Chktt0:	Move	T1,T2			;[24] Swap T2,T1 2nd..times
	Hiber	T3,			;[24] Send yellowball & wait for done.
	  Jfcl				;[24] Ignore error.
	Getlch	T2			;[24] And again, see if changed.
	Came	T1,T2			;[24] Same?
	  Jrst	Chktt0			;[24] No, changeing, try again!
	> ; End ifn tymcom
	Return				;[24] Return.

ifn tymcom,<
LCHCOD:	Seto	T2,			;[22] Get set for command port
	Getlch	T2			;[22] Read current characteristics
	MOVE	T1,TT.IDX		;[22] JUST IN CASE NOT THERE
	HRRZ	T1,CLRSET(T1)		;[22] Get the sense of the set
	Skipn	T1			;[22] Check its sense
	 setcmm	TT.NOP			;[22]  and reverse sense of NO
	MOVE	T1,TT.IDX		;[22] JUST IN CASE NOT THERE
	TDO	T2,TRMTBL(T1)		;[22] Set them!
	SKIPE	TT.NOP			;[22] SKIP IF NOT SET (set already)
	  TDZ	T2,TRMTBL(T1)		;[22] Clear them as if [NO] Specified
	TRO	T2,777777		;[22] Make sure we mean us!
	Setlch	T2			;[22] Set the value
	Pjrst	Trmfin			;[22] Finish up
>

TRMCOD:	MOVE	T1,TT.IDX		;JUST IN CASE NOT THERE
	HRRZ	T2,CLRSET(T1)		;GET THE VALUE TO SET
	SKIPE	TT.NOP			;SKIP IF NOT SET
	HLRZ	T2,CLRSET(T1)		;GET THE VALUE TO CLEAR
TRMCO1:	MOVEM	T2,TRMBLK+2		;[7]PUT THIS AWAY
TRMCO0:	MOVE	T1,TT.IDX		;[7]RESTOR THE INDEX
ifn tymcom,<
	HLRO	T2,TRMTBL(T1)		;[22] GET THE Auxcal function
	Auxcal	T2,TRMBLK+2		;[22] Set the value
					;[22] No skip for his Auxcal
>
ife tymcom,<
	HLRZ	T2,TRMTBL(T1)		;[11]GET THE TRMOP. CODE
	MOVEM	T2,TRMBLK		;PUT IT AWAY HERE
	MOVE	T2,[XWD 3,TRMBLK]	;GET SET FOR TRMOP.
	TRMOP.	T2,			;SET THE TTY CONDITION
	  PGOTO	W$CNS			;[7]ERROR--SET TTY CMD FAILED
>
trmfin:	MOVE	T1,TT.IDX		;[20] Get index
	MOVE	T1,TTYTBL(T1)		;[20] For proper Name
	MOVEM	T1,SETCMD+1		;[20] For message
	PJRST	I$$SET			;GO TELL WHAT WAS SET IF DESIRED

TRMDEC:	SETCM	T2,TT.NOP		;[7]SKIP IF NOT-SET
	JUMPE	T2,TRMCO1		;[7]DO TRMCODE IF NO COMMAND
	XCALL	.DECNW			;GET THE NXT CHRS AS A DECIMAL
	HRRZM	N,TRMBLK+2		;STORE VALUE TO SET
	MOVEM	N,SETCMD+2		;STORE VALUE FOR INFO MSG
	PJRST	TRMCO0			;DO IT LIKE A REGULAR

TRMOCT:	SETCM	T2,TT.NOP		;[45] Skip if not set
	 JUMPE	T2,TRMCO1		;[45] DO TRMCOD stuff is no command
	XCALL	.OCTNW			;[45] Read as an OCTAL value
	Movem	N,TRMBLK+2		;[45] Store for set
	Movem	N,SETCMD+2		;[45] Store for message
	Pjrst	TRMCO0			;[45] Use common code

TRMSIX:	SETCM	T2,TT.NOP		;[44] Skip if not set
	 JUMPE	T2,TRMCO1		;[44] DO TRMCOD stuff is no command
	XCALL	.SIXSW			;[44] Read as a SIXBIT value
	Movem	N,TRMBLK+2		;[44] Store for set
	Movem	N,SETCMD+2		;[44] Store for message
	Pjrst	TRMCO0			;[44] Use common code


	SUBTTL	(.SET TTY) TABLES

ifn tymcom,<						;[22]
DEFINE TTYCMD<						;[22]
	LCHARG	(TAPE,lc.ptm,1,LCHCOD)			;[22]
	LCHARG	(LC,lc.ncm,1,LCHCOD)			;[22]
	LCHARG	(UC,lc.ncm,0,LCHCOD)			;[22]
	LCHARG	(TAB,lc.hht,1,LCHCOD)			;[22]
	LCHARG	(FORM,lc.hff,1,LCHCOD)			;[22]
	LCHARG	(ECHO,lc.hdx,0,LCHCOD)			;[22]
	LCHARG	(CRLF,lc.nfc,1,LCHCOD)			;[22]
	LCHARG	(DELAY,lc.crd,0,LCHCOD)			;[22]
							;[22]
	TTYARG	(PARITY,.Axep,1,0,TRMCOD)		;[22]
	TTYARG	(HALFDU,.Axhd,1,0,TRMCOD)		;[22]
	TTYARG	(FULLDU,.Axhd,0,1,TRMCOD)		;[22]
	TTYARG	(PARA,.Axpa,0,7,TRMDEC)			;[22]
	TTYARG	(PARB,.Axpa,0,7,TRMDEC)			;[22]
	TTYARG	(PARC,.Axpa,0,^D16,TRMDEC)		;[22]
	TTYARG	(HNXON,.Axhnx,1,0,TRMCOD)		;[22]
	TTYARG	(TABS,.Axnte,0,1,TRMCOD)		;[22]
	TTYARG	(TBREAK,.Axtbk,1,0,TRMCOD)		;[22]
	TTYARG	(FILL1,.Axfc1,1,0,TRMCOD)		;[22]
	TTYARG	(FILL2,.Axfc2,1,0,TRMCOD)		;[22]
	TTYARG	(WIDTH,.Axwid,^D16,^D200,TRMDEC)	;[22]
	TTYARG	(CODE,.Axtyp,0,17,TRMDEC)		;[22]
	TTYARG	(PAGE,.Axrvx,1,0,TRMCOD)		;[22]
	TTYARG	(ERASE,.Axera,1,0,TRMCOD)		;[22]
	TTYARG	(LOWER,.Axlco,1,0,TRMCOD)		;[22]
	TTYARG	(LC,.Axlco,1,0,TRMCOD)			;[22]
	TTYARG	(UC,.Axlco,0,1,TRMCOD)			;[22]
	TTYARG	(BACKSP,.Axbs,1,0,TRMCOD)		;[22]
	TTYARG	(REMXON,.Axrmx,1,0,TRMCOD)		;[22]
	TTYARG	(DEFER,.Axede,1,0,TRMCOD)		;[22]
	TTYARG	(RBSPAC,.Axrbs,1,0,TRMCOD)		;[36]
	TTYARG	(BSPUNC,.Axrbs,1,0,TRMCOD)		;[22]
	TTYARG	(BSDEL,.Axbsd,1,0,TRMCOD)		;[22]
	TTYARG	(TYPE,.Axttp,0,0,TRMSIX)		;[44]
>							;[22]
> ; end ifn tymcom					;[22]
ife tymcom,<
DEFINE TTYCMD<
	TTYARG	(TAPE,.TOXON,1,0,TRMCOD)
	TTYARG	(LC,.TOLCT,0,1,TRMCOD)
	TTYARG	(UC,.TOLCT,1,0,TRMCOD)
	TTYARG	(SLAVE,.TOSLV,1,0,TRMCOD)
	TTYARG	(TAB,.TOTAB,1,0,TRMCOD)
	TTYARG	(FORM,.TOFRM,1,0,TRMCOD)
	TTYARG	(ECHO,.TOLCP,0,1,TRMCOD)
	TTYARG	(CRLF,.TONFC,0,1,TRMCOD)
	TTYARG	(WIDTH,.TOWID,^D16,^D200,TRMDEC)
	TTYARG	(GAG,.TOSND,0,1,TRMCOD)
	TTYARG	(HALFDUPLEX,.TOHLF,1,0,TRMCOD)		;[7]
	TTYARG	(FULLDUPLEX,.TOHLF,0,1,TRMCOD)		;[7]
	TTYARG	(REMOTE,.TORMT,1,0,TRMCOD)
	TTYARG	(LOCAL,.TORMT,0,1,TRMCOD)
	TTYARG	(DISPLAY,.TODIS,1,0,TRMCOD)		;[7]
	TTYARG	(FILL,.TOFLC,0,3,TRMDEC)
	TTYARG	(PAGE,.TOPAG,1,0,TRMCOD)
	TTYARG	(PAGESIZE,.TOPSZ,0,^D63,TRMDEC)		;[7]
	TTYARG	(PAGECOUNT,.TOPCT,0,^D63,TRMDEC)	;[7]
	TTYARG	(BLANKS,.TOBLK,0,1,TRMCOD)		;[2]
	TTYARG	(ALTMOD,.TOALT,0,1,TRMCOD)		;[16]
	TTYARG	(APL,.TOAPL,1,0,TRMCOD)			;[7]
	TTYARG	(DEBREAK,.TODBK,1,0,TRMCOD)		;[7]
	TTYARG	(2741,.TO274,1,0,TRMCOD)		;[7]
	TTYARG	(TIDY,.TOTDY,1,0,TRMCOD)		;[7]
	TTYARG	(AUTOCR,.TOACR,1,0,TRMCOD)		;[7]
	TTYARG	(RTCOMP,.TORTC,1,0,TRMCOD)		;[7]
	TTYARG	(PIMBRK,.TOPBS,0,-1,TRMOCT)		;[45]
	TTYARG	(TYPE,.TOTRM,0,0,TRMSIX)		;[44]
	TTYARG	(DEFER,.TODEM,1,0,TRMCOD)		;[45]
>
> ; end ife tymcom



DEFINE TTYARG(ARG,TRM,SET,CLR,PROC)<
	EXP	SIXBIT/ARG/>
ifn tymcom,<
DEFINE LCHARG(ARG,TRM,SET,PROC)<
	EXP	SIXBIT/ARG/>
>

TTYTBL:	TTYCMD
	TT.LEN=.-TTYTBL

DEFINE	TTYARG(ARG,TRM,SET,CLR,PROC)<
	XWD	<.TOSET+TRM>,PROC>
ifn Tymcom,<
DEFINE	LCHARG(ARG,TRM,SET,PROC)<
	EXP	TRM+PROC>
>

TRMTBL:	TTYCMD

DEFINE	TTYARG(ARG,TRM,SET,CLR,PROC)<
	XWD	CLR,SET>
Ifn Tymcom,<
DEFINE LCHARG(ARG,TRM,SET,PROC)<
	XWD	0,SET>
>

CLRSET:	TTYCMD
ifn tymcom,<
	Subttl	SETALP	Routine

Do.ALP:	Skipe	T1,Funppn		; Only convert name if no ppn	[52]
	  Jrst	DoALP0			;   else 			[52]
	Move	T2,Funmore		; Get Name
	Move	T3,Funmore+2
	Pushj	P,CVppn			; Make a ppn?
	  PGOTO	W$ALP			; Oops! Can't get PPN		[42]
	Movem	T1,Funppn		; !
DoALP0:	Move	T2,Arg			; Setup for SETALP
	Movsi	T0,'DSK'
	Setz	T3,
	Setalp	T3,
	  PGOTO	W$ALP			; No `can do'			[42]
	Return

W$ALP:	MSG	<WARN>			; ONLY GIVE MESSAGE IF WANT WARNINGS
	PGOTO	W$$ALP			; Ok!

>
	Subttl	/STATUS  Switch Processor

;Status - Routine to obtain & type out the current status of the
;	  current hardware, software configuration.
;
;[<Config-data> <Cpu-Type> <Node#-Port#> <Schedule if # 0>]
;

Status:	MSG	<STATUS>		;[27] Only print if user wants Status
	Write	<[LONSTD	>;	;[27] Write out the beginning
	XCALL	.TDATN			;[46] Type Date
	XCALL	.Tspac			;[46] ..space..
	XCALL	.TTIMN			;[46] Type Time
	Write	<]
[LONSTS	>;				;[27] Write the second beginning.
Ifn Tymcom,<
	Move	T1,[Xwd 35,12]		;[33] Read the % null time for
	Gettab	T1,			;[33] the last minute
	  Jrst	Stat.0			;[33]
	Imuli	T1,^D100		;[33] Percentage
	Move	T2,[Xwd 27,11]		;[33] Divided by
	Gettab	T2,			;[33] the # ticks in a minute
	  Jrst	Stat.0			;[33] to make it real
	Idiv	T1,T2			;[33]
	Movei	T2,^D100		;[33] Subtract it from 100%
	Subm	T2,T1			;[33]
	Xcall	.Tdecw			;[33] Type it out
	Write	<% >;			;[33] with a per cent
Stat.0:	Movsi	T1,42			;[33] Send a yellow ball
	Hrri	T1,5			;[53] Timeout for lost balls @ 5 min
	Hiber	T1,			;[33]
	  Jfcl				;[33]
	Mstime	T2,			;[33] Then compare the time it
	Hiber	T1,			;[33] takes to send another
	  Jfcl				;[33] yellow ball
	Mstime	T1,			;[33]
	Sub	T1,T2			;[33] Subtract Start from Stop
	Xcall	.Tdecw			;[33] and print it.
	Write	<ms. >;			;[33]
	> ; End ifn tymcom
	Movei	T1,Cnfnam		;[27] Obtain string name
	Xcall	.Tstrg			;[27] Type it out.
	XCALL	.Tspac			;[27] ..space..
	Call	K.Type			;[27] Get the processor type-index
	  jfcl				;[27] Ignore error return here
	Move	T1,K.Tab(T1)		;[27] Get the processor string
	Xcall	.Tsixn			;[27] Print the sixbit name
Ifn Tymcom,<Write < Frame: >>;		;[53] Type the job number
Ife Tymcom,<Write < Job: >>;		;[53] Type the job number
	Pjob	T1,			;[53] ...
	XCALL	.Tdecw			;[53]
	Write	< on >;			;[53] on ... ttynnn
Ifn Tymcom,<
	hrroi	T1,.Gtlin		; Setup for getting users line	[22]
	Gettab	T1,			; Get his line number		[22]
	  setz	T1,
	tlnn	T1,777777		; Is he detached?		[22]
	  tlo	t1,'det'		; Yep! So tell user		[22]
	Xcall	.TSIXN			; Type it in sixbit		[22]
> ; End Ifn Tymcom
Ife Tymcom,<
	Write	<TTY>;			;TTY TEXT			[4]
	Seto	T1,			;Get for self			[53]
	TRMNO.	T1,			;  THE TERMINAL NUMBER		[4]
	  JRST	[MOVEI	T1,[ASCIZ/DET/]	;ERROR--ASSUME DETACHED		[4]
		 XCALL	.TSTRG		;SO SAY ON TTYDET		[4]
		 JRST	.+3]		;AND COME BACK			[4]
	TXZ	T1,.UXTRM		;CLEAR THE TERMINAL INDEX	[4]
	XCALL	.TOCTW			;OUTPUT THE TTY NUMBER		[4]
> ; End Ife Tymcom
	XCALL	.Tspac			;[27] ..space..
	Move	T1,NODNAM		;[27] Print the node
Ifn tymcom,<Xcall .Toctw>		;[27] Number
Ife tymcom,<Xcall .Tsixn>		;[27] or NAME
Ifn tymcom,<Write <->>;			;[27] Followed by "-"
Ife tymcom,<Write <_TTY>>;		;[27]   or "_TTY"
	Move	T1,TTYNOD		;[27] And nnn Port number.
	Xcall	.Toctw			;[27]
	Movx	T1,%Cnsts		;[27] Get the system STATES word
	Gettab	T1,			;[27] from the CONFIG tables
	  Jrst	Stat.1			;[27] ... oops!
	Tlz	T1,-1			;[27] Clear Feature test bits
	  Jumpe	T1,Stat.1		;[27] If non-zero, then
	Push	P,P1			;[27] Save 1 for pointer
	Move	P1,T1			;[27] Save states & type them out.
Ifn Tymcom,<
	Ifstrg	1b19,<Super>;		;[27] Any shut, Check Super first.
	Ifstrg	3b19,<Shut>;		;[27] This one is tricky!
	Ifstrg	1b20,<Restricted>;	;[27] Well, is it a No-No?
	> ; End Ifn Tymcom
Ife Tymcom,<
	Ifstrg	1b27,<No Oper Coverage>;;[27] No operator coverage	400
	Ifstrg	1b28,<Unspooling>;	;[27] Unspooling allowed	200
	Ifstrg	1b29,<No Restricted DEV>;[27] Unrestricted devices	100
	Ifstrg	1b32,<Stand Alone>;	;[27] No remote tty's		 10
	Ifstrg	1b33,<Batch Only>;	;[27] Batch logins only		  4
	Ifstrg	1b34,<Local Only>;	;[27] No Remote logins		  2
	Ifstrg	1b35,<CTY Only>;	;[27] No logins 'cept from CTY	  1
	> ; End Ife Tymcom
	Pop	P,P1			;[27] Restore register
Stat.1:	Xcall	.Trbrk			;[27] Finish with a Bracket!
	Write	<
>;					;[27] Carriage-return
	Return


;TELL -- OUTPUT A MESSAGE ON THE TTY:
;CALL:	PUSHJ	P,TELL		OR (CALL TELL) /TELL: PROCESSOR
;	RETURN

TELL:	XCALL	.ASCQW			;GET THE ASCII STRING TO TELL
	MSG	<TELL>			;ONLY TELL HIM IF HE WANTS IT
	WRITE	<[LONMSG >;		;[21]
	MOVEI	T1,.NMUL##		;POINT TO MESSAGE
	XCALL	.TSTRG			;OUTPUT IT
	XCALL	.TRBRK			;CLOSE UP WITH A "]"
	WRITE	<
>;					;[21]
	RETURN
	SUBTTL	ERROR PROCESSING

E$$CSS:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONCSS Can't set search-list
>
	RETURN

E$$IBC:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONIBC Illegal break character in switch
>
	RETURN

E$$ISC:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONISC Illegal set command >
	MOVE	T1,SETCMD
	XCALL	.TSIXN
	PGOTO	.TCRLF

E$$ITS:	MSG	<FATAL>			;[20] ENHANCED MESSAGES ETC
	WRITE	<
?LONITS	Illegal set TTY command >
	MOVE	T1,SETCMD+1
	XCALL	.TSIXN
	PGOTO	.TCRLF

E$USF:	JUMPGE	T1,E$ASF		;[11]JUMP IF AMBIGOUS
	MSG	<FATAL>
	WRITE	<
?LONUSF Unknown select function /SELECT:>
	MOVE	T1,OPTFUN		;[11]GET FUNCTION
	PGOTO	.TSIXN##		;[11]OUTPUT IT AND RETURN

E$ASF:	MSG	<FATAL>
	WRITE	<
?LONASF Ambiguous select function /SELECT:>
	MOVE	T1,OPTFUN		;[11]GET FUNCTION
	PGOTO	.TSIXN##		;[11]OUTPUT IT AND RETURN

E$$SNE:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONSNE /SELECT nesting exceeded
>
	RETURN
	SUBTTL	WARNING MESSAGES

W$$ALP:	Write	<%LONALP Could not set alternate logout program (>
	Move	T1,Funmore		;[42] Get first half of name
	Xcall	.Tsixn			;[42] Print.
	Move	T1,Funmore+2		;[42] 2nd half
	Xcall	.Tsixn			;[42] Print
	Write	<)>			;[42] Be safe?
	Move	T1,Arg			;[42] Get program name
T$SIXN:	XCALL	.TSIXN			;[21][7]PRINT IT
T$CRLF:	Write	<
>;					;[21]
	RETURN

Ife Tymcom,<	;[51] Remove /Assign code for now!
W$$CAD:	WRITE	<%LONCAD Could not assign device >
	MOVE	T1,DEVICE		;GET THE DEVICE
	XCALL	.TSIXN			;[7]PRINT THIS
	WRITE	< logical name >
	MOVE	T1,LOGNAM		;GET LOGICAL NAME
	Pgoto	T$Sixn			;[42] Print
>	; End Ife Tymcom

W$CNS:	MSG	<WARN>			;[7]ONLY PRINT IF USER WANTS WARNINGS
W$$CNS:	WRITE	<%LONCNS Could not SET >
	MOVE	T1,ST.IDX		;[20] Get command name index
	MOVE	T1,SETTBL(T1)		;[20][7]GET SET COMMAND NAME
	XCALL	.TSIXN			;[7]OUTPUT IT
	XCALL	.TSPAC			;[7]AND A SPACE
	MOVEI	T1,[ASCIZ/NO /]	
	IFI	(TT.NOP,NE,0)		;[7]IF THIS IS NO COMMAND
	  XCALL	.TSTRG			;[7]OUTPUT THE NO
	SKIPE	T1,SETCMD+1		;[7]GET THE ARGUMENT
	  XCALL	.TSIXN			;[7]OUTPUT IF THERE IS ONE
	IFI	(SETCMD+2,GE,0)		;[7]IF THERE IS A DECIMAL ARG
	  XCALL	.TSPAC			;[7]SPACE OVER
	SKIPL	T1,SETCMD+2		;[7]IF DECIMAL ARG
	  XCALL	.TDECW			;[7]OUTPUT IT
	PGOTO	T$CRLF			;[21] Finish up with CRLF
	SUBTTL	INFO	MESSAGES

I$$MOU:	MSG	<MOUNT>		;ONLY PRINT IF USER WANTS MOUNTS
	SKIPE	UFDFLG		;IS THERE A UFD??
	JRST	I$$MNU		;NO--SO SAY SO   N.S.S.S.
	WRITE	<[LONMOU .Mount >
	MOVE	T1,.NMUL##	;GET 6BIT NAME OF PACK
	XCALL	.TSIXN		;PRINT IT OUT
	XCALL	.TRBRK		;TYPE A "]"
	PGOTO	T$CRLF		;[21] Finish up with CRLF

I$$MNU:	WRITE	<[LONMNU .Mount >
	MOVE	T1,.NMUL##	;GET PACK NAME
	XCALL	.TSIXN		;TYPE PACK NAME
	WRITE	< ; No UFD created]
>
	RETURN

Ife Tymcom,<	;[51] Remove /Assign code!
I$$ASD:	MSG	<ASSIGN>	;ONLY PRINT IF USER WANTS ASSIGNMENTS
	WRITE	<[LONASD .Assign >
	MOVE	T1,DEVICE	;GET THE DEVICE
	XCALL	.TSIXN		;PRINT IT
	XCALL	.TCOLN		;PRINT OUT A ":"
	MOVE	T1,LOGNAM	;GET THE LOGICAL NAME
	XCALL	.TSIXN		;PRINT IT
	XCALL	.TRBRK		;TYPE A "]"
	PGOTO	T$CRLF		;[21] Finish up with CRLF
>	; End Ife Tymcom

I$$RUN:	MSG	<RUN>		;ONLY PRINT IF USER WANTS RUN MESSAGES
	WRITE	<[LONRUN .Run >;;[21]
	MOVEI	T1,N.DEV	;[14]POINT TO FILE BLOCK
	XCALL	.TFBLK		;[14]AND OUTPUT IT
	WRITE	<]
>
	RETURN

I$$SET:	MSG	<SET>		;ONLY PRINT IF USER WANTS SET MESSAGES
	WRITE	<[LONSET .Set >
	MOVE	T1,ST.IDX	;[20] Get proper command index
	MOVE	T1,SETTBL(T1)	;[20] And type entire command name
	XCALL	.TSIXN		;TYPE IT
	XCALL	.TSPAC		;FOLLOWED BY A SPACE
	MOVEI	T1,[ASCIZ/NO /]
	SKIPE	TT.NOP		;DID WE DO A SET ARG NO VAL CMD?
	XCALL	.TSTRG		;YES--TYPE OUT THE NO
	MOVE	T1,SETCMD+1	;GET SET COMMAND ARGUMENT
	XCALL	.TSIXN		;TYPE IT OUT
	SKIPL	T1,SETCMD+2	;IS THERE AN EXTRA NUMERIC ARG?
	XCALL	.TSPAC		;YES--TYPE AN EXTRA SPACE
	SKIPL	T1,SETCMD+2	;CHECK AGAIN FOR EXTRA NUMERIC ARG
	XCALL	.TDECW		;PRINT IT IF FOUND
	XCALL	.TRBRK		;TYPE A "]"
	PGOTO	T$CRLF		;[21] Finish up with CRLF


I$$USR:	MSG	<USER>			;Only Type this if /NOTIFY:USER	[32]
	XCALL	.PSH4T			;SAVE T1-T4			[4]
	PUSH	P,T2			;SAVE job WHERE WE CAN GET AT IT[4]
ife tymcom,<
	WRITE	<[LONUSR	Job: >;	; Beginning part		[23]
>
ifn tymcom,<
	Write	<[Frame: >;		;What Frame number		[23]
>
	HRRZ	T1,(P)			; We'd like to know		[23]
	XCALL	.TDECW			;Type it			[23]
	WRITE	< User: >;		;PREFACE MESSAGE		[23]
	MOVX	T1,.GTNM1		;OUTPUT THE USER'S NAME
	HRL	T1,(P)			;				[37]
	GETTAB	T1,
	  SETZ	T1,			;OOPS
	XCALL	.TSIXN			;
	MOVX	T1,.GTNM2		;OUTPUT THE USER'S NAME
	HRL	T1,(P)			;PUT IN THE JOB NUMBER
	GETTAB	T1,
	  SETZ	T1,			;OOPS!!
	XCALL	.TSIXN			;
	MOVX	T1,.GTPPN		;GET THE PPN			[4]
	HRL	T1,(P)			;FOR THE JOB			[4]
	GETTAB	T1,			;FROM THE GETTABS		[4]
	  CAIA				;OOPS!!	Skip so no [0,0]	[40]
ife tymcom,<
	XCALL	.TPPNW			;TYPE THAT			[50]
	> ; End ife tymcom
ifn tymcom,<
	Movx	T2,.GTAUN		;[50] GET users AUN
	HRL	T2,(P)			;[50] FOR THE JOB
	GETTAB	T2,			;[50] FROM THE GETTABS
	  Caia				;[50] Can't compare???
	Camn	T1,T2			;[50] Ok! Compare them PPn=AUN?
	  Jrst	I$$US2			;[50] Yes--Don't bother with more
	open	1,[     .iodmp		;[50] Get a disk channel
		   sixbit /dsk/		;[50] to lookup
		   0]			;[50] the UFD
	  Jrst	I$$Us2			;[50] Open failed - Don't try
	Movem	T1,LKBLOK+.Rbnam	;[50] put name in lookup block
	Movsi	T1,'UFD'		;[50] ...
	Movem	T1,LKBLOK+.Rbext	;[50] ... extension
	Move	T1,[1,,1]		;[50] ...
	Movem	T1,LKBLOK+.Rbppn	;[50] ... PPN (UFD)
	Movei	T1,.Rbunm+2		;[50] ... block size
	Movem	T1,LKBLOK		;[50] ... count
	Lookup	1,LKBLOK		;[50] See if the file is there
	  Jrst	I$$Us2			;[50] Can't read it... Don't go on
	Write	<(>;			;[50] Begin block.
	Move	T1,LKBLOK+.Rbunm	;[50] Get text
	Xcall	.TSIXN			;[50] Type it
	Skipe	T1,LKBLOK+.Rbunm+1	;[50] Any more
	Xcall	.TSIXN			;[50] Type it
	WRITE	<)>;			;[50] Finished!
I$$US2:	WRITE	< on >;			;TTY TEXT			[4]
ifn tymcom,<
	movei	T1,.Gtlin		; Setup for getting users line	[22]
	hrl	T1,(P)			; For job N			[22]
	Gettab	T1,			; Get his line number		[22]
	  setz	T1,
	Push	P,T1			;[47] Save this name...
	tlnn	T1,777777		; Is he detached?		[22]
	  tlo	t1,'det'		; Yep! So tell user		[22]
	Xcall	.TSIXN			; Type it in sixbit		[22]
	Pop	P,T2			;[47] Restore sixbit /ttynnn/
	Tlnn	T2,777777		;[47] Is he detached?
	  Jrst	I$$us8			;[47] Yes! -- Don't bother with Tymnet
	Push	P,T2			;[47] Save it again
	Write	< (>;			;[47] Whilst we type out something
	Pop	P,T2			;[47] (Probably didn't need to save)
	Push	P,[Point 6,T2,^D17]	;[47] Setup to convert to an integer
	Movei	T3,3			;[47] reading maximum of 3 digits
	Setz	T4,			;[47] with the result in T4
I$$us4:	Ildb	T1,(P)			;[47] Get a byte
	Jumpe	T1,I$$us6		;[47] Ok!
	Lsh	T4,3			;[47] Shift a digit
	Addi	T4,-'0'(T1)		;[47] Add it in
	Sojg	T3,I$$us4		;[47] Loop.
I$$us6:	Pop	P,(P)			;[47] Free the stack location
	movei	T1,.Gtlog		;[47] Get the Tymnet Node:line, etc.
	hrl	T1,T4			;[47] For Port N
	Gettab	T1,			;[47] ...
	  Setz	T1,			;[47] Shouldn't happen
	Move	T2,T1			;[47] Copy it
	Andi	T2,177			;[47] Save Line number
	Push	P,T2			;[47] ...
	Lshc	T1,-^d14		;[47] First set of 6 bits
	Lsh	T1,-2			;[47] Throw away garbage bits
	Lshc	T1,-^d30		;[47] Should now have the right ones
	Andi	T2,7777			;[23] Make it Octal Node #
	Move	T1,T2			;[47] Copy for printing
	Xcall	.Toctw			;[47] Node number..
	Write	<->;			;[47]  -
	Pop	P,T1			;[47] Remember the tty number
	Xcall	.Toctw			;[47] Print it
	Write	<)>;			;[47] Finish!
I$$us8:
>
ife tymcom,<
	WRITE	<TTY>;			;TTY TEXT			[4]
	HRRZ	T1,(P)			;Get Job number from stack	[22]
	TRMNO.	T1,			;GET THE TERMINAL NUMBER	[4]
	  JRST	[MOVEI	T1,[ASCIZ/DET/]	;ERROR--ASSUME DETACHED		[4]
		 XCALL	.TSTRG		;SO SAY ON TTYDET		[4]
		 JRST	.+3]		;AND COME BACK			[4]
	TXZ	T1,.UXTRM		;CLEAR THE TERMINAL INDEX	[4]
	XCALL	.TOCTW			;OUTPUT THE TTY NUMBER		[4]
>
	hrrzi	T1,.Gtnam		;Now the program name		[23]
	HRL	T1,(P)			;Get Job number from stack	[22]
	Gettab	T1,			; From the monitor		[23]
	  setz	T1,			; Assumming there is one	[23]
	Jumpe	T1,I$$US1		; No? -- Skip this		[23]
	push	p,T1			; Save...			[23]
	WRITE	< program >;		;	Type text		[23]
	pop	p,T1			; Restore			[23]
	Xcall	.Tsixn			; Then type it			[23]
ifn tymcom,<	;Not sure if this works on tops-10
	Xcall	.Tspac			; Space				[41]
	hrrzi	T1,.Gtsts		; Frame status word		[41]
	HRL	T1,(P)			; Get Job number from stack	[41]
	Setz	T2,			; Precaution: so zero shift	[41]
	Gettab	T1,			;  Well, maybe...		[41]
	  setz	T1,			;  Oh well, say ^C anway	[41]
	Txnn	T1,1b0			; Skip if Job is RUNable	[41]  
	  Jrst	I$$US0			;  No!! so print ^C		[41]
	Lsh	T1,-^D21		; Shift this			[41]
	Andi	T1,37			; Must be within range		[41]
	Idivi	T1,3			; Now divide since table in 3s	[41]
	Movss	T1			; Swap halves			[41]
	Imuli	T2,^d12			; Ready for shift		[41]
	Hrri	T1,.Gtwsc		; Wait states list		[41]
	Gettab	T1,			;  Well, maybe...		[41]
I$$US0:	  Movsi	T1,'^C '		; If error here -- ^C		[41]
	Lsh	T1,(T2)			;  Ok!				[41]
	Tdz	T1,[77777777]		; Clear garbage			[41]
	Xcall	.Tsixn			; Type it			[41]	
	> ; End ifn tymcom
I$$US1:	POP	P,T1			;GET THE JOB NUMBER		[43]
	XCALL	.TRBRK			;CLOSE UP THE MESSAGE		[43]
	XCALL	.TCRLF			; Type ending			[21]
	XCALL	.POP4T			;RESTORE ALL TEMP ACS		[4]
	RETURN
	SUBTTL	SCAN SWITCH MACRO TABLES

	DEFINE	SWTCHS	<

ife tymcom,<
	SP	*ASSIGN,,ASSIGN,,FS.NFS
>
	SP	*GT40,,GT40,,FS.NFS
	SP	*HAZEL,,HAZEL,,FS.NFS
	SP	HP2621,,HP2621,,FS.NFS
ife tymcom,<
	SP	*MOUNT,,MOUNT,,FS.NFS
>
	SL	*NOTIFY,NOTES,NOTF,0,FS.OBV!FS.NFS
	SP	SELECT,,SELECT,,FS.NFS
	SP	SET,,SET,,FS.NFS
	SP	STATUS,,STATUS,,FS.NFS
	SP	*TELL,,TELL,,FS.NFS

>

KEYS NOTF,<ASSIGN,MOUNT,SELECT,SET,TELL,RUN,FATAL,WARN,INFO,HELP,USER,STATUS>

	%ASSIGN==1B35	;DEFINE NOTIFY BITS IN SAME ORDER AS KEYS MACRO
	%MOUNT== 1B34
	%SELECT==1B33
	%SET==   1B32
	%TELL==  1B31
	%RUN==   1B30
	%FATAL== 1B29
	%WARN==  1B28
	%INFO==  1B27
	%HELP==  1B26			;[6]
	%USER==	 1B25
	%STATUS==1B24			;[25]
	DOSCAN	(SW)
	SUBTTL	.OSCAN ARGUEMENT BLOCK

;.OSCAN -- SUBROUTINE TO SCAN OPTIONS FILE (DSK:SWITCH.INI[,])
;	RETURNS CPOPJ AFTER UPDATING GLOBAL SWITCHES FROM FILE
;	THIS ROUTINE SHOULD BE CALLED AFTER TSCAN OR PSCAN
;		BUT BEFORE DEFAULTING.
;	CALL THIS ONLY AT END OF LINE.
;	IT SHOULD BE CALLED BETWEEN ISCAN AND VSCAN FOR VERBS.
;ARGS:	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES (IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=NAME OF OPTIONS TO SELECT IN FILE (0 IF NAME OF PROGRAM)
;			OR LENGTH,,LIST OF OPTION NAMES
;IF CALL FROM VSCAN, C(T3)= SAME AS BLOCK+4 ABOVE

OBLK:	OEND-OBLK0,,OBLK0		;LENGTH,,BLOCK
OBLK0:	IOWD	SWL,SWN			;POINT TO SWITCH NAMES
OBLK1:	SWD,,SWM			;DEFAULT SW,,PROCESSOR SW
OBLK2:	0,,SWP				;0,,SW POINTERS
OBLK3:	-1				;NO HELP FILE YET
OBLK4:	0				;SELECT OPTIONS=PROGRAM NAME
OEND:
	SUBTTL	DATA AREA

	IMPURE

ZCORE:				;START OF CORE TO ZERO ON RESET
DEVICE:	BLOCK	1			;DEVICE
LOGNAM:	BLOCK	1			;LOGICAL NAME
FUNCTIO:BLOCK	1			;.SET FUNCTION
ARG:	BLOCK	1			;           ARG
FUNMSK:	BLOCK	1			; ...
FUNEXT:	BLOCK	1			; ...
FUNSWT:	BLOCK	1			; ...
FUNSWM:	BLOCK	1			; ...
FUNPPN:	BLOCK	1			; PPN , eg <MPL> etc...
FUNPPM:	BLOCK	1			; ...
FUNmor:	block	30
FUNSIZ==.-FUNction

SELOPT:	BLOCK	1			;OPTION SELECTED
OPTCNT:	BLOCK	1			;OPTION NESTING LEVEL COUNTER
SETCMD:	BLOCK	3			;STORAGE FOR SET CMD VALUES

OPTFUN:	BLOCK	1			;FUNCTION
OPTARG:	BLOCK	1			;THE OPTIONS TO SELECT
OPTMSK:	BLOCK	1			;OPTIONS MASK
OPTEXT:	BLOCK	1			; MEANINGLESS
OPTSWT:	BLOCK	1			; SWITCHES
OPTSWM:	BLOCK	1			; SWITCHES MASK
OPTPPN:	BLOCK	1			;THE OPTIONS PPN
OPTPPM:	BLOCK	1			; PPN MASK
Optmor:	block	30
OPTSIZ==.-OPTFUN

LKBLOK:	block	.rbunm+2		;[50] .rbcnt :: .rbunm+1

LGNOPK:	BLOCK	3			;SPACE FOR OPENBLOCK
TT.NOP:	BLOCK	1			;NO - CODE
TT.IDX:	BLOCK	1			;INDEX HOLDER - TTY .... command
ST.IDX:	BLOCK	1			;[20] INDEX HOLDER - Set Command
TRMBLK:					;[12]FOR TRMOP. UUO
TRMWHT:	BLOCK	1			;[12]TRMOP. CODE
TTYNO:	BLOCK	1			;[12]TTY UDX
TRMVAL:	BLOCK	1			;[12]TRMOP. VALUE
LINCHR:	BLOCK	1			;[12]TTY LINE CHARACTERISTICS
TTYNAM:	BLOCK	1			;[12]TTY LINE NAME (TTYNNN)
TTYNOD:	BLOCK	1			;[15]TTY NODE NUMBER (.GTNTN)
TTYLIN:	BLOCK	1			;[15]TTY LINE NUMBER (.GTNTN)
SPNODE:	BLOCK	1			;[15]NODENAME SPECIFIED
NODNAM:	BLOCK	1			;[15]NODE NAME IN SIXBIT
MYJOB:	BLOCK	1			;[12]MY JOB NUMBER
STRLTH:	BLOCK	1			;LENGTH OF STRLST
STRLST:	BLOCK	25			;PLENTY OF SPACE
UFDFLG:	BLOCK	1			;FLAG FOR UFD EXISTENCE
NOTES:	BLOCK	2			;/NOTIFY:(args)
CNFNAM:	BLOCK	5			;[27] Configuration data
CNFEND:	Block	1			;[27] Zero word for .Tstrg of CNFNAM
ifn tymcom,<
TTY.OK:	BLOCK	1			;[25] First time flag for TTY stuff.
Tymaux:	Block	1			;[30] Aux Circuit flag
Chname:	Block	1			;[31] System number with "chr"
Syname:	Block	1			;[31] System number without "chr"
	> ; End ifn tymcom

	FIN	LOGON
 "
