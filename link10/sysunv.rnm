.standard
.;The following edits are NOT documented yet
.;  353 Allow relative byte in $DSBIT macro
.;  355 $BYTES macro for $BYT substitution
.;  357 $USR is now a user defined substitution (not the same as $DIR)
.disable TOC
.enable bar
.paper size 66,64.;  60 lines of 64 columns
.page size 60,64
.right margin 64
.layout 3,3
.style header 1,0,0
.autosubtitle 1
.header mixed
.display number RL
.no number
.subtitle
.autoparagraph
.set paragraph 0,1,2
.flag index
.figure 7
.center;##SSSS####YY####YY####SSSS####UU####UU##NN####NN##VV####VV
.center;#SSSSSS####YY##YY####SSSSSS###UU####UU##NN####NN##VV####VV
.center;SS####SS####YYYY####SS####SS##UU####UU##NNN###NN##VV####VV
.center;SS###########YY#####SS########UU####UU##NNNN##NN##VV####VV
.center;#SSSSS#######YY######SSSSS####UU####UU##NN#NN#NN##VV####VV
.center;##SSSSS######YY#######SSSSS###UU####UU##NN#NN#NN##VV####VV
.center;######SS#####YY###########SS##UU####UU##NN##NNNN##VV####VV
.center;SS####SS#####YY#####SS####SS##UU####UU##NN###NNN###VV##VV#
.center;#SSSSSS######YY######SSSSSS####UUUUUU###NN####NN####VVVV##
.center;##SSSS#######YY#######SSSS######UUUU####NN####NN#####VV###
.figure 4
.center;UU####UU####SSSS####EEEEEEEE##RRRRRR#######''#######SSSS##
.center;UU####UU###SSSSSS###EEEEEEEE##RRRRRRR#####''''#####SSSSSS#
.center;UU####UU##SS####SS##EE########RR####RR#####''#####SS####SS
.center;UU####UU##SS########EE########RR####RR####''######SS######
.center;UU####UU###SSSSS####EEEEEE####RRRRRRR##############SSSSS##
.center;UU####UU####SSSSS###EEEEEE####RRRRRR################SSSSS#
.center;UU####UU########SS##EE########RR#RR#####################SS
.center;UU####UU##SS####SS##EE########RR##RR##############SS####SS
.center;#UUUUUU####SSSSSS###EEEEEEEE##RR###RR##############SSSSSS#
.center;##UUUU######SSSS####EEEEEEEE##RR####RR##############SSSS##
.figure 4
.center;##GGGG####UU####UU####IIII####DDDDDD####EEEEEEEE
.center;#GGGGGG###UU####UU####IIII####DDDDDDD###EEEEEEEE
.center;GG####GG##UU####UU#####II#####DD####DD##EE######
.center;GG########UU####UU#####II#####DD####DD##EE######
.center;GG########UU####UU#####II#####DD####DD##EEEEEE##
.center;GG########UU####UU#####II#####DD####DD##EEEEEE##
.center;GG##GGGG##UU####UU#####II#####DD####DD##EE######
.center;GG####GG##UU####UU#####II#####DD####DD##EE######
.center;#GGGGGG####UUUUUU#####IIII####DDDDDDD###EEEEEEEE
.center;##GGGG######UUUU######IIII####DDDDDD####EEEEEEEE
.page
.figure 12
.center ;SYSUNV User's Guide
.blank 6
.center ;A Product of
.blank
.center ;Samurai Programming
.blank 15
.note Fourth Edition, October 1982
This document describes user procedures for the SYSUNV universal file
facility.
.blank
Operating System:##TOPS-10 or TOPS-20
.blank
Software Version:##SYSUNV %7(340)
.end note
.page
.tab stops 8,16,24,32,40,48
.center;First Edition, October 1978#
.center;Second Edition, August 1981#
.center;Third Edition, July 1982####
.center;Fourth Edition, October 1982
.blank 2
The information in this document is subject to change without notice
and should not be construed as a commitment by Samurai Programming.
Samurai Programming assumes no responsibility for any errors that may
appear in this document.
 The software described in this document is subject to change without
notice and should not be construed as a commitment by Samurai
Programming.
 No responsibility is assumed for the use or reliability of software on
equipment that is not supplied by Samurai Programming.
.blank 3
.Center ;Copy on Write 1981, 1982 by Samurai Programming
.blank 3
Any comments/suggestions/complaints concerning this document
should be directed to:
.blank 2
.center ;Rex W. Shadrick
.center ;SOHIO Petroleum Company
.center ;5400 LBJ Freeway
.center ;1 Lincoln Centre
.center ;Suite 1200 / LB25
.center ;Dallax, TX##75240
.center ;(214)960-4017
.page
.figure 4
.note To Hackers Everywhere
Don't part with your illusions.  When they are gone you may still
exist but you have ceased to live.
.end note
.page
.title Table of Contents
.number
.center ;Table of Contents
.figure 4
.require "SYSUNV.RNT"
.display number D
.page
.enable TOC
.chapter >Description
 SYSUNV contains definitions for commonly used macros which are
intended to make life easier for the MACRO-10/20 hacker.
>TYP7I.REL>, >TYP7S.REL and >TYP7N.REL
contain support routines for some of the macros contained in >SYSUNV>.
 SYSUNV also contains all macros (or equivalent macros) contained in MACTEN.
Caution should be taken, since some of the MACTEN macros exist by a different
name in SYSUNV.
.chapter Version/Title Macros
 There are two macros which manipulate version numbers.  They
are: >$VRSN and >$TITLE>.  Note:  These macros define
symbols which are required by other SYSUNV macros and routines.
.header level 1 The $VRSN Macro
 This macro is used to define the program's version number in
TOPS-10/20 compatible format.  It requires two arguments: a three
letter abbreviation of the program name (preferably the
program's CCL name), and the version number in the format that
is typed by DIRECT.  Example:
.blank
.nofill
.nojustify ;	$VRSN	SYS,7(340)
.fill.justify
 This defines six symbols of importance to the programmer.  These are:
>xxxVER>, >xxxMIN>, >xxxEDT>, >xxxWHO>, >xxx.VN>, and >TP.PFX>, where
"xxx" is the CCL name given as the first argument.  xxxVER is the major
version number, xxxMIN is the minor version number, xxxEDT is the edit
level, xxxWHO is the programmer who last modified the program, xxx.VN
is a 36 bit version number which is the combined form of the previous
four numbers and >TP.PFX is an 18 bit quantity which is the SIXBIT CCL
name.
.header level 1 The $TITLE Macro
 This macro is used in conjunction with the >$VRSN macro to generate a
>TITLE pseudo-op, with the program's version number appended to the
text of the title statement.  This macro takes five arguments: a text
string which is the main body of the title statement, the program's CCL
name (the same as the one given to the $VRSN macro), an optional
pseudo-op to be used instead of TITLE (e.g. >UNIVERSAL to generate a
universal file), a number to specify in which pass to execute the
macro (more of this later), and another text string which will be
appended to the line that is generated.
 This macro can be used to construct virtually any type of statement
the programmer would want that contains the program's version number in
text format, but is normally used to generate a TITLE/UNIVERSAL
pseudo-op.  Some examples of the use of $TITLE are:
.nofill.nojustify.blank ;	$TITLE	SYSUNV - System Macro Definitions,SYS,UNIVERSAL
.blank ;Would generate:
.blank ;	UNIVERSAL  SYSUNV - System Macro Definitions %7(340)
.blank 2;	$TITLE	_<_\EBUTIL _>,EBU,SIXBIT,3,_<_\_>
.blank ;Would generate:
.blank ;	SIXBIT	_\EBUTIL %1(1)-4_\
.blank 2;	$TITLE	_<[Assembling SYSUNV version_>,SYS,PRINTX,1,_<, pass 1]_>
.blank ;	$TITLE	_<[Assembling SYSUNV version_>,SYS,PRINTX,2,_<, pass 2]_>
.blank ;Would generate:
.blank ;IF1,_<	PRINTX	[Assembling SYSUNV version %7(340), pass 1]
_>
.blank ;IF2,_<	PRINTX	[Assembling SYSUNV version %7(340), pass 2]
_>
.fill.justify
 The pass number argument to $TITLE is a two bit number which
instructs $TITLE in which passes to assemble this macro.  This value
is assumed to be 3 if blank or omitted.  An argument of 1 will direct
it to assemble only during pass 1, 2 for pass 2 or 3 for both passes.
.header level 1 The >$PASS Macro
 The last two examples are contained in a single special-case macro
called $PASS.  This is a single macro whose main function is to type
on the user's console what it is that he is assembling.  The two
arguments passed to this macro are the program's name and the CCL
prefix (as given in the >$TITLE macro).
.test page 6
 An example of its use:
.nofill.nojustify.blank ;	>$PASS	SYSUNV,SYS
.fill.justify
 Would generate the last two >$TITLE macros given above.
.header level 1 The >$BEGIN Macro
 The >$BEGIN macro is used to execute some of the common pieces of
code normally found at the beginning of a program (e.g. title/version,
AC definitions, etc).  This macro uses the >$TITLE>, >$VRSN>, and
>$PASS macros as well as others.
 The format of the $BEGIN call is:
.blank.nofill.nojustify ;	$BEGIN	($TTL,$PFX,$VSN,$FLG)
.fill.justify
 Where >$TTL is the title string (as given in the >$TITLE macro or
TITLE pseudo-op), >$PFX is the CCL prefix (as given to the >$VRSN
macro), >$VSN is the version number string (something like "1B(27)-4")
and >$FLG is a list of flags.  The flags are defined in the following
manner:  _<flag-1,flag-2, ... flag-n_>.  Where flag-1, flag-2, flag-n
are one of the following:
.left margin 18.set paragraph -13,1,1.tab stops 18
 ###Flag	Desciption
 >ACS	Define the AC's; the argument is the base address for register
T1 (the default is 1).  The AC's are defined in the following manner:
T1 equals the base address, >T2#=#>T1#+#1, >T3#=#>T2#+#1, >T4#=#>T3#+#1,
>P1#=#>T4#+#1, >P2#=#>P1#+#1, >P3#=#>P2#+#1, >P4#=#>P3#+#1, and >P#=#17.
(Default if >TITLE is given.)
 >BINARY	Don't suppress the generation of the binary (.REL) file.
(Default if >TITLE or >STRINGS is given/defaulted.)
 >BITS	Define the bits symbols:  >B0 for bit 0, >B1 for bit 1, ...,
B35 for bit 35.
.index B0
.index B1
.index B2
.index B3
.index B4
.index B5
.index B6
.index B7
.index B8
.index B9
.index B10
.index B11
.index B12
.index B13
.index B14
.index B15
.index B16
.index B17
.index B18
.index B19
.index B20
.index B21
.index B22
.index B23
.index B24
.index B25
.index B26
.index B27
.index B28
.index B29
.index B30
.index B31
.index B32
.index B33
.index B34
.index B35
 >ENTRY	Define a list of entry points in this module.
 >FAILING	Suppress listing of failing conditionals (.DIRECTIVE
SFCOND).  (Default is >NOFAILING>.)
 >HELPER	Request REL:HELPER.REL at load time.  (Default if >SCAN>
is given.)
 >IOSEC	Request >REL:IOSEC.REL at load time and >SYS:IOSEC.EXE at
execution time.
 >LIT	Dump the literal pool when the segment changes.  (Default is
>NOLIT>.)
 >MANY	Create a segmented (PSECTs) program.  (Default is >TWO>.)
 >MACSYM	Search >MACSYM and request REL:MACSYM.REL at load time.
 >MACTEN	Search >MACTEN.
 >MULTILINE	Suppress multiline expansions.
 >NOACS	Don't define the AC's.  (Default if >UNIVERSAL or >STRINGS is
given.)
 >NOBINARY	Suppress the output of the binary object file (.REL).
(Default if >UNIVERSAL is given, unless $PRGEND is used)
 >NOFAILING	Don't suppress the listing of failing conditionals.
(Default)
 >NOLIT	Don't dump the literal pool when the segment (high/low) changes.
(Default)
 >NOSUPPRESS	Don't suppress the AC symbols from DDT output.  (Default)
 >NOVERSION	Don't put the version number in location 137.  (This is
the default, unless the $END or $PRGEND macro is given a starting address.)
 >ONE	Create a one segment program.  (Default is >TWO>.)
 >SCAN	Search >SCNMAC (TOPS-10) or >SCNM20 (TOPS-20) for >SCAN>/>WILD
macros and symbols, and request REL:SCN7C.REL (TOPS-10) or REL:SCAN11.REL
(TOPS-20) at load time.
 >SCANNER	Search >SCNPRM for the >SCANER macros and symbols, and
request REL:SCANER.REL at load time.
 >SEARCH	Search some universal files; the argument is the list
of files to be searched.
 >STRINGS	Create a external string file (the REL file) and a
universal file.
 >SUPPRESS	Suppress the AC symbols from DDT typeout.  (Default is
>NOSUPPRESS>.)
 >TITLE	Create a program (use the TITLE pseudo-op).  (Default)
 >TOPS10	Assemble for >TOPS-10>; this causes >UUOSYM to be
searched.
 >TOPS20	Assemble for >TOPS-20>; this causes >MONSYM to be
searched.
 >TWO	Create a two segment program, the argument is the high segment
base address, the default is 400000.  (Default)
 >TYPER	Request REL:>TYP7S.REL if >SCAN is given or REL:>TYP7N.REL if
>SCAN isn't given.  (Default if >IOSEC is given.)
 >UNIVERSAL	Create a universal file (implies .DIRECTIVE .NOBIN).
 >VERSION	Put the version number in absolute location 137
(>.JBVER>).
 >WILD	Request REL:WLD7A.REL (TOPS-10) or REL:WILD11.REL (TOPS-20) at
load time.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.note $BEGIN Expansion
The $RELOCATION macro is executed by the $BEGIN macro, unless a
universal file is requested.  The $RELOCATION macro set the
relocation counter to the low segment.
 If the >TOPS10 or >TOPS20 flag is supplied to the $BEGIN macro, then
the >$TOPS macro is defined with the value of 10 or 20 depending on
which monitor was requested.
.end note
.chapter Symbol Definition Macros
 There are a few macros to define assembly parameters or constant
symbols. These are:
.test page 20.left margin 13.set paragraph -8,1,1.tab stops 13
 Macro	Description
 >$SHOW	This displays the value of a previously defined symbol.
 >$ND	This macro defines a symbol if it is not already defined.
The second argument to this macro is the value to be assigned to
the symbol.  (example: "$ND##PSICHN,1").
 >$INT	This macro will define a symbol and declare it as
internal.  The usage is similar to $ND except that it has a
third argument, which if non-blank, will cause the symbol to be
suppressed from DDT output.
 >$EXT	This macro will define a symbol as external.  Its only
argument is the symbol name.
 >$GLB	This macro will force a symbol to be either internal or
external depending on whether or not the symbol is defined at the
time that this macro is invoked.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.chapter Listing Control Macros
 Here are some macros to control the listing generated by
MACRO-10/20.  They are:
.test page 26.left margin 17.set paragraph -12,1,1.tab stops 5,17,22
 ##Macro	Description
 >$CONTINUE	This macro is used to force a page overflow.
.note Proposed DEC Stardard
According to the proposed DEC standard, all source for a routine
must occur on one page.  However, it is important for the user
to find "sentence" breaks to form the overflow (eject) points.
Whenever overflow occurs, a comment to that effect should appear
in the listing.  All this is accomplished by the user including
the $CONTINUE in his source at the point of the overflow.
.end note
 >$LSTOF	This macro turns off the listing and/or the CREF
information.  The parameter is what to turn off:  LIST, CREF, or
blank (for both).
 >$LSTON	This macro turns on the listing and/or the CREF
information.  The parameter is what to turn on:  LIST, CREF, or
blank (for both).
 >$TOC	This macro is used in place of the SUBTTL pseudo-op.
Its only argument is placed in the SUBTTL line of the listing,
then the text "(cont.)" is appended to the end of the SUBTTL
line for the next page of the listing.
 >$PURGE	This macro purges all of the macro generated
symbols (..nnnn).  It is automatically invoked by the $END and
$PRGEND macros.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.chapter Relocation Macros
 There are several macros defined which are used to control
program relocation, phase, and literal/variable pool.  These
macros are:  >$RELOCATION>, >$ABS>, >$END>, >$HIGH>, >$LIT>,
>$LOW>, >$PRGEND>, >$SECTION and >$VAR>.
.header level 1 The >$RELOCATION Macro
 This macro is invoked a maximum of once per program and should
be used before any other relocation macros are called.  There
are three optional arguments:  the first specifies the type of
segment code to be generated, the second determines whether
literals are to be dumped when the segment changes and the
third is the high segment base relocation address.  The first
argument is "ONE" for single segment code (low segment only),
"TWO" for two segment code (high and low segments) or "MANY"
for segmented code (PSECT's).  The second argument is either
"LIT" to dump literals when the segment changes (via >$HIGH
or >$LOW>) or "NOLIT" to suppress dumping of literals.  When
"LIT" is set, the literal pool will be dumped in the current
segment before the segment is changed.  The defaults for the
arguments are "TWO,NOLIT,400000".  An example of its use:
.blank.nofill.nojustify;	$RELOCATION##TWO,LIT
.fill.justify
 The literal and variable pools will be dumped in the section
where they are defined/used, for sectioned (PSECT'ed) programs
only.  This is a feature of MACRO and not the macros.
.header level 1 The >$ABS Macro
 This macro is used to generate absolute assembly code (i.e.
LOC pseudo-op).  Its single argument is the address to begin
assembly.  Example:
.blank.nofill.nojustify;	$ABS	137
.fill.justify
.header level 1 The >$END Macro
 This macro will dump the literal pool (in the high segment)
and variable pool (in the low segment), purge all of the macro
generated symbols, and generate an END statement.  The
single optional argument is the start address or entry vector
for the program.  Example:
.blank.nofill.nojustify;	$END	START
.fill.justify
.header level 1 The >$HIGH Macro
 This macro will set the relocation to high segment code.
This macro should only be used if two segments were specified
to the $RELOCATION macro.  If the "LIT" option was specified
to >$RELOCATION>, the literal pool will be dumped in the
current segment before changing to the high segment.  Example:
.blank.nofill.nojustify;	$HIGH
.fill.justify
.header level 1 The >$LIT Macro
 This macro will dump the literal pool.  It has two optional
arguments:  the first is the listing option and the second is
the segment in which to dump the literals.  The first argument
is either "LIST" to list the literals or "NOLIST" to suppress
the listing.  The second argument is either "HIGH" to put the
literals in the high segment, "LOW" to put them in the low
segment, or blank to put them in the current segment.  The
defaults for the arguments are "LIST,".  Example:
.blank.nofill.nojustify;	$LIT	NOLIST,LOW
.fill.justify
.header level 1 The >$LOW Macro
 This will set the program relocation to the low segment.  If
"LIT" was given in the >$RELOCATION call, the literals will
be dumped in the current segment before changing to the low
segment.  Example:
.blank.nofill.nojustify;	$LOW
.fill.justify
.header level 1 The >$PRGEND Macro
 This macro will dump the literal pool (in thh segment)
and variable pool (in the low segment), purge all of the macro
generated symbols, and generate an PRGEND statement.  The
single optional argument is the start address or entry vector
for the program.  Example:
.blank.nofill.nojustify;	$PRGEND
.fill.justify
.header level 1 The >$SECTION Macro
 This macro will set the program relocation to a section
(PSECT).  It has two arguments:  the first is the section name
and the second is the section starting address.  The first
argument is the section name, a 1 to 6 character symbol name.
The second argument is the starting address for the section
(PSECT) and is NOT required when switching back to a section.
Example:
.blank.nofill.nojustify;	$SECTION SECNAM,_^O600000
.fill.justify
.header level 1 The >$VAR Macro
 This macro will dump the variable pool.  It has two optional
arguments:  the first is the listing option and the second is
the segment in which to dump the variables.  The first
argument is either "LIST" to list the variables or "NOLIST" to
suppress the listing.  The second argument is either "HIGH" to
put the variables in the high segment, "LOW" to put them
in the low segment, or blank to put them in the current segment.
The defaults for the arguments are "LIST,".  Example:
.blank.nofill.nojustify;	$VAR	NOLIST,HIGH
.fill.justify
.chapter Byte Manipulation Macros
 The byte manipulation macros are used to build byte pointers
from masks, insert values into a word using a bit mask or to
determine the absolute position of a byte in a word given the
mask.
.header level 1 The >$WID Macro
 This macro computes the width (in bits) of a byte given a bit
mask.  The single argument to this macro is a word containing
the mask; the macro returns a value which is the number of
consecutive one bits in the mask.
.header level 1 The >$POS Macro
 The macro computes the position of a byte described by a bit
mask.  The single argument to this macro is a word containing
the mask describing the byte,  the returned value is the bit
number of the right most one bit in the byte.  This value
can be used as the third argument to MACRO's >POINT
pseudo-op.
.header level 1 The >$POINT Macro
 This macro is used to build a byte pointer given a bit mask.
The first argument to this macro is the location that the
byte pointer will point to (i.e. the I, X and Y fields).  The
second argument is a one word bit mask which describes the
byte.  Note that the byte pointer produced is not
predecremented (i.e. it is to be used with DPB/LDB, not ILDB).
.header level 1 The >$MASK Macro
 This macro is used to build a mask.  There are two arguments
to this macro, the first is the width of the mask, the second
is the bit number of the rightmost bit in the mask.
.header level 1 The >$RITBT Macro
 The value of this macro is a word which has one bit set which
is the rightmost bit in the mask given as the argument.  For
example, $RITBT(_<777000,,0_>) equals 1000,,0.
.header level 1 The >$LFTBT Macro
 This macro is similar to the >$RITBT macro, except that the
returned value is the leftmost bit instead of the rightmost
bit.
.header level 1 The >$FILIN Macro
 This macro will return a bit mask containing a string of
consectutive one bits starting at the leftmost one bit in
the mask given as the argument thru the rightmost bit in the
argument.  For example, $FILIN(_<1,,400_>) equals 1,,777400.
.header level 1 The >$ALIGN Macro
 This macro returns the number of trailing zeros in the
argument mask.  This number is the number of right shifts that
would be needed to position the byte described by the given bit
mask to align the byte in the least most significant bits of
the word.
.header level 1 The >$INSVL Macro
 This macro takes two arguments which are a value and a bit
mask which describes a byte.  The value returned is a word
containing that value positioned into the mask.  For example,
$INSVL(3,_<700,,0_>) equals 300,,0.
.chapter Data Structure Macros
 The data structure macros are used to define and access a
data structure.  The term "data structure" is used here to
describe a block of words which constitute a single group of
data values (similar in concept to a COBOL record).
 These macros can allocate words, bits or bytes in a block of
consecutive virtual words.  The macros will define symbols
which describe the exact location of a given item within the
data structure.  The symbol naming conventions consist of a
two character prefix which is used throughout the data
structure, and describes which structure the given symbol
belongs to.  The other alphanumeric portion of the symbol
is a three character identifier which describles the field
itself.  The format of the generated symbols are:
.test page 16.left margin 14.set paragraph -9,1,1.tab stops 14
 Symbol	Description
 xx.yyy	A word offset for a mask.  This is the number of
words from the base of the structure for a given mask.
 xx%yyy	A bit mask describing a a byte within the word.
 xx$yyy	A shift offset for extracting or positioning the
byte, or the word or byte count.
 .xxyyy	A value to be stored within a byte (0 thru n).
 %xxyyy	A bit mask within a byte.
 $zzzzz	A macro definition.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 Where "xx" is the data structure's prefix and "yyy" is the
symbol suffix in the structure.
 To define a structure,  the structure symbols are first
initialized with the >$DSBEG macro, then defined using
one of the other definition macros, ending with the
>$DSEND macro.  The storage defined by these macros can
be accessed via the >$MOVE and >$MOVEM macros.  These
macros are defined in the following paragraphs:
.header level 1 The >$DSBEG Macro
 This is the first macro used when defining a data
structure.  This macro declares the structure's name,
beginning offset and type.  This macro MUST be used before
any of the other data structure macros, since this macro
will define the other macros according to the arguments
given here.  The syntax for this macro is:
.blank.nofill.nojustify;	$DSBEG	($PFX,$TYP,$MSK,$BEG,$MAX,$TST)
.fill.justify
 >$PFX is the two character name of the data structure.
This prefix is used in all symbols defined for this data
structure.
 >$TYP is the code for the mask to be used in the first
word of the data structure.   This is used to insure that
certain bits in the first word of the data structure will
not be used.  The options are:
.test page 26.left margin 14.set paragraph -9,1,1.tab stops 14
 #Type	Description
 >ALIGN	This will start the data structure in the first
word following an existing data structure.  If this option
is used,  the $MSK argument should be given to specify
the end of the data structure that this will be aligned
with.  See $MSK.
 >APPEND	This is similar to "ALIGN" except that the
new data structure will be started in the first available
byte in the last word of the data structure that this will
be appended to.
 >CALL	This specifies that the argument block has a
subroutine address in the right 23 bits of the first word
(used by standard SYSUNV calling convention).   This will
.index SYSUNV Calling Conventions
cause only the non-address bits (opcode and AC fields) of
the first word in the data structure to be used.  See $MSK.
 >MASK	This specifies that the user wants to specify his
own mask for the initial word of the data structure.  See
$MSK.
 >NORMAL	This is used in the normal case.  All of
the first word of the data structure will be used.  This
is the default if this field is omitted.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 >$MSK is the initial mask to be used in the data structure.
If $MSK is used with the "ALIGN" and "APPEND" options to
$TYP to specify the end of the data structure that this
structure is to be appended to then this must be a symbol
of the form "xx.yyy" as described above.  If $MSK is used
with the "MASK" then this is actual mask to be used for
the initial word of the data structure.  This parameter is
ignored if "CALL" or "NORMAL" is specified to $TYP.
 >$BEG  is the beginning word offset for this data structure.
If omitted, this value will default to zero for the "CALL",
"MASK" or "NORMAL" options to $TYP, or "xx.yyy" for "ALIGN"
or "APPEND".
 >$MAX is the maximum number of words allowed in the data
structure.  The default value for this field is positive
infinity.
 >$TST if supplied is a "feature test switch" value.  If
this argument is supplied, the data structure will not be
defined or allocated unless the value of the feature test
switch is non-zero.
.header level 1 The >$DSFLG Macro
 The $DSFLG macro is used to allocate a block of sequential
bits (or a byte) in the next available space within the
structure.  This can be used either to allocate a byte
containing a value, or to allocate a string of consectutive
bits.  The format of a call to $DSFLG is:
.blank.nofill.nojustify;	$DSFLG	$SFX,$WID,$FLG,$TST
.fill.justify
 >$SFX is a three character name for this symbol. This will
be the "yyy" portion of the symbol format described above.
 >$WID is the width of the field (in bits) or a keyword.
The keywords are:
.test page 21.left margin 16.set paragraph -11,1,1.tab stops 16
 #Width	Descrition
 >ADDRESS	To allocate an address field.  This will
assign the low order 23 bits of a word for storage of a
full (non multisection) address.
 >DOUBLE	This will allocate a double word quanitity.
 >LEFT	This will allocate a left halfword.
 >HALF	This will allocate a halfword with no preference as
to whether it will be the left or right half of the word.
 >REDEFINE	This will redefine the previous field defined
by the $DSFLG macro.  This is used if the same set of bits
are to be given two different names.
 >RIGHT	This will allocate a right halfword.
 >WORD	This will allocate a whole word quantity.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 The default for this field is "1"  (like a flag bit).
 >$FLG is the suffix of a previously defined symbol in this
data structure to be backed up to.  This allows a block of
the data structure to be redefined.  More that the pointer
is backed up before this symbol is defined.  This means that
the symbol specified here will be the first overlayed storage.
 >$TST if supplied is a "feature test switch" value.  If this
argument is supplied,  the storage (and associated symbols)
will not be defined or allocated unless the value of the
feature test switch is non-zero. This is useful for allocating
storage which is dependent on assembly conditionals.
 The symbols defined by the $DSFLG macro are of the form "xx.yyy",
"xx$yyy" and "xx%yyy" as described above.
.header level 1 The >$DSVAL Macro
 The $DSVAL macro is used to assign sequential values to be
stored in a mask as defined by the >$DSFLG macro.  An example
of how this would be used would be as follows:   A file
specification data structure (like a >SCAN filespec block)
might contain a word containing many switch values.  One of
these would be the tape density.  The tape density field
would be defined using the >$DSFLG macro, and each tape
density value within this field would be defined via the
>$DSVAL following the $DSFLG.   This macro should
immediately follow the $DSFLG that it is subdividing, since
this macro is defined by (and depends on symbols from) the
$DSFLG macro.
 The format of a call to the $DSVAL macro is:
.blank.nofill.nojustify;	$DSVAL	$SFX,$VAL,$TST
.fill.justify
 >$SFX and >$TST are similar to the arguments of the same
name for $DSFLG.  >$VAL is the value to be assigned to
this symbol.  If $VAL is omitted, it is assigned the next
sequential value from the previous $DSVAL invokation.
The $VAL argument is normally supplied only on the first
call to $DSVAL (following a $DSFLG) to define the intial
value for the assignments within the field.
 This macro will define symbols of the form ".xxyyy" as
described above.
.header level 1 The >$DSBIT Macro
 The $DSBIT macro is used to assign a sequential bit within
the $DSFLG field.  This would be used when $DSFLG is used to
allocate a block of sequential flag bits.  $DSBIT would be
used here to assign individual bits within the block.  The
format of a call to $DSBIT is:
.blank.nofill.nojustify;	$DSBIT	$SFX,$VAL,$TST
.fill.justify
 >$SFX and >$TST are used the same as in the $DSFLG and
$DSVAL macros.  >$VAL is the initial bit value to be used
for this symbol (analagous to the $VAL field in the $DSVAL
macro).  If this field is omitted,  the value assigned will
be the value assigned to the previous $DSBIT shifted right
one.  In other words, this macro will allocate the bits from
the leftmost bit in the field to the rightmost bit on each
successive call.  This macro defines symbols of the form
"%xxyyy" as described above.
.header level 1 The >$DSBYT Macro
 The $DSBYT macro is used to allocate a block of contiguous
bytes within a data structure.  This is useful for
allocating an ASCII or SIXBIT string in a data structure.
The format of a call to $DSBYT is:
.blank.nofill.nojustify;	$DSBYT  $SFX,$BYT,$SIZ,$TST
.fill.justify
 The $SFX and $TST arguments are the same as for the $DSFLG
macro.  The $BYT argument is the size of the bytes to be
allocated.  This is the actual byte size or one of the
following keywords:
.test page 16.left margin 14.set paragraph -9,1,1.tab stops 14
 Type	Description
 >ASCII	The size of the bytes to be alloacted is 7.
 >ASCIZ	The size of the bytes to be allocated is 7 and the
number of bytes allocated will be increated by one,
internally only.
 >EBCDIC	The size of the bytes to be allocated is 8.
 >HALF	The size of the bytes to be allocated is 18.
 >SIXBIT	The size of the bytes to be allocated is 6.
 >WORD	The size of the bytes to be alloacted is 36.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 The default value is ASCII.
 The $SIZ argument is the number of bytes to be allocated.
The default is 1.
.header level 1 The >$DSWRD Macro
 The $DSWRD macro is used to allocate a block of contiguous
words within the data structure.  This is useful for
allocating a word or an array in the data structure.  The
format of a call to $DSWRD is:
.blank.nofill.nojustify;	$DSWRD	$SFX,$SIZ,$TST
.fill.justify
 The >$SFX and >$TST fields are the same as for the $DSFLG,
$DSVAL and $DSBIT macros.  The >$SIZ argument specifies the
number of words to be allocated.  If this parameter is
omitted,  it is assumed to be one (1).  Note that if $SIZ
is set to one,  this will have roughly the same effect as a
$DSFLG macro with "WORD" specified as $WID argument.  This
macro will generate a symbol of the form "xx.yyy" as described
above.
.header level 1 The >$DSNXT Macro
 The $DSNXT macro does not allocate any storage or define any
symbols.  It is used to force the next allocation to start in
the next word of the data structure.  This macro has one
argument the "feature test switch" value, the same as the
$DSFLG macro.
.header level 1 The >$DSSKP Macro
 The $DSSKP macro is used to skip words in a data structure.
The format of a call to $DSSKP is:
.blank.nofill.nojustify;	$DSSKP  $WRD,$TST
.fill.justify
 The $TST field is the same as for the $DSFLG macro.  $WRD
argument is the number of whole or partial words to be
skipped.
.header level 1 The >$DSEND Macro
 The $DSEND macro is used to define the end of a data
structure.  After this macro has been called,  all the
other data structure definition macros will be undefined
until the next $DSBEG macro invokation.  The two arguments
to this macro are the prefix as given in the $DSBEG macro
(for verification) and a suffix for the symbol which will
be defined as the length of the data structure in words.
The format of this symbol is a standard word offset symbol
("xx.yyy").
.header level 1 The >$MOVE and >$MOVEM Macros
 The $MOVE and $MOVEM macros do not define the data
structure, but rather access them.  These are analagous to
the >MOVE and >MOVEM instructions.  The format of both of
these macros consists of 1) the register to be moved to or
stored from, 2) the symbol name of the storage (as defined
by one of the data structure macros) in the form "xx%yyy"
or "xx.yyy" and 3) the address of the base of the data
structure.  Note that the address may contain the "I", "X"
and "Y" fields of the effective address computation.
.chapter "X" Macros
.header level 1 Literal Manipulation Macros
 The "X" macros are used to reference literal constants.
These eliminate the need for the programmer to keep track
of whether a symbol is a full word or half word quantity
(right or left).  These definitions are similar to the
machine opcodes that they replace.  The format for the use
of these macro is:
.blank.nofill.nojustify;	>MOVX	T1,.CHEOF
.fill.justify
 In the above example, .CHEOF is a symbol which has a
full word value.  In the case of a >MOVX instruction,
the generated code could be one of  >MOVE>, >MOVEI>,
>MOVSI>, >HRROI or >HRLOI depending on the value of
the symbol used.
 The macros that are implemented in this manner are:
>MOVX>, >CAX>, >CAXL>, >CAXLE>, >CAXE>, >CAXG>, >CAXGE>,
>CAXN>, >CAXA>, >ADDX>, >SUBX>, >MULX>, >IMULX>,
>DIVX>, >IDIVX>, >FADRX>, >FSBRX>, >FMPRX>, >FDVRX>,
>ANDX>, >IORX>, >ORX>, >XORX> and >TX>ab
.index TX macros
(where "a" is one of N, Z, O or C and "b" is one of "~",
E, N or A; (as in the TRNN, etc opcodes).
.header level 1 Bit/Byte Definition Macros
 The >$FLAGS and >$FLAG macros are used to allocate
bit or byte fields within a word.  These definitions may
be used in conjunction with the "X" macros.
 The >$FLAGS macro is used to initialize the >$FLAG macro.
The format of this call is:
.blank.nofill.nojustify;	$FLAGS	$PFX,$MSK
.fill.justify
 Where >$PFX is the prefix to be used on the subsequent
>$FLAG calls and >$MSK is the mask of contiguous bits
to be used by the $FLAG macro (-1 is the default).  This
macro MUST always be invoked before the >$FLAG macro in
order to insure that everything is setup properly.  The
$FLAG macro is used to sequentially (starting at the left
most bit of the mask, $MSK) assign bit or byte values
within a word.  The format of this macro is:
.blank.nofill.nojustify;	$FLAG	$FLG,$WID,$PFX
.fill.justify
 Where >$FLG is the suffix for the symbol name.  The symbol
generated is a concatenation of the prefix name given in
the >$FLAGS macro and this argument.
 >$WID is the number of bits wide that this field is to be
(defaults to 1).
 >$PFX is the prefix to be used on the subsequent $VALUE
calls.  If $PFX is blank, $VALUE isn't defined.
 The $VALUE macro can be used to define flag bits in an AC
or packed argument blocks.  The >$FLAG macro defines the
>$VALUE macro which can be used to assign sequential values
to be used within the byte.  The format of the >$VALUE
macro call is:
.blank.nofill.nojustify;	$VALUE	$SYM,$VAL
.fill.justify
 Where >$SYM is the suffix to be used in the symbol name
(as in the >$FLAG macro) and >$VAL is the value to be
assigned to this symbol.  If the $VAL parameter is omitted,
the value is defaulted to the previous value assigned by
this macro plus 1.
 Using all these macros together would look something like:
.blank.test page 23
.left margin 5.tab stops 13,21,29,37,45,53
.set paragraph 0,0,1
 .FXMOD==4		; The modifier word:
.set paragraph 1,0,1
 $FLAGS  FX.		; Initialize the word
.set paragraph 2,0,1
 $FLAG   NDV		; Null device
 $FLAG   NUL		; Null extension
 $FLAG   DIR		; Directory specified   (mod=0 if [-])
 $FLAG   PHY		; /PHYSICAL
 $FLAG   NOM		; /OKNONE
 $FLAG   DFX		; Directory does not need fix-up by WILD
 $FLAG   TRM,3,.FX	; Code for spec's termination
.set paragraph 3,0,1
 $VALUE  TRA,1		; _& (AND)
 $VALUE  TRO		; ! (OR)
 $VALUE  TRN		; - (NOT)
 $VALUE  TRC		; + (concatenate)
.set paragraph 2,0,1
 $FLAG   STR		; /STRS
 $FLAG   PRT		; /OKPROT
 $FLAG   SUP		; /ERSUPERSEDE
 $FLAG   SCN,2,.FX	; /SCAN
.set paragraph 3,0,1
 $VALUE  SFD,1		; Scan SFD before UFD
 $VALUE  UFD		; Scan UFD before SFD
 $VALUE  UP		; Scan up the path
.set paragraph 2,0,1
 $FLAG   DEN,3		; /DENSITY
 $FLAG   PAR		; /PARITY
 $FLAG   PRO,_^D9		; /PROTECTION
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.chapter Stack Macros
 SYSUNV contains macros which allocate frames or local
variables on the software stack.  These routines
require that the stack pointer is in register 17,
defined as "P", and will also save register 16 and use
it for a frame pointer during the context of the
variables/frame.
.header level 1 The >$VARIABLE Macro
 This macro is used to stack registers 1 through 16 and
allocate local variables on the stack.  This macro
generates a call to the routine with the entry point
>.FRAM0>, >.FRAM1>, >.FRAM2>, >.FRAM3 or >.FRAM4>.  The
$VARIABLE call generates a "PUSHJ#P,@[#...#]".
.index ^Local ^Variables
.index ^Frame ^Pointer
 The format of the call is:
.blank.nofill.nojustify;	>$VARIABLE ($TYP,_<$LST_>,$CAL,$REG,$ACS)
.fill.justify
 Where $TYP is the type of call, $LST is the list of
variables to be defined, $CAL the name of the call
variable, $REG the name of the register variable and
$ACS is the list of variables to be that point to the
saved registers.  These arguments are described below:
.disable TOC
.header level 2 >$TYP
 $TYP defines the type of variables to be setup.  These
differ in scope and usage.  These types are:
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >ENTRY
 The "ENTRY" variable call is used to allocate stack
variables which are global to the current routine and
to get the address of the literal block of the caller's
call.  This call will save registers 1-16.  On return
from this call, register >P1 is left pointing to the
literal block of the caller's call, "PUSHJ P,@[#...#]",
register 16 is left pointing at the stack frame and
registers 1-15, except >P1, are in an unknown state.
The layout of the frame generated by this call is:
.blank.test page 13.nofill.nojustify
!======================================================!
!              Original return address                 !
!------------------------------------------------------!
/                                                      /
/             The saved registers (1-16)               /
/                                                      /
!------------------------------------------------------!
/                                                      /
/                The stack variables                   /
/                                                      /
!------------------------------------------------------!
!               .FRAM0 return address                  !
!======================================================!
.fill.justify
.header level 3 >GLOBAL
 The "GLOBAL" variable call is used to allocate stack
variables which are global to the current routine.
These variables are pointed to by register 16 in the
frame allocated off the stack.  A minimum of three words
are allocated on the stack for variables, if a list of
variables smaller than three is given, three will be
allocated.  This restriction is a result of the scratch
space used by the frame allocator.  On return from this
call, register 16 is updated by this routine after
saving it on the stack. The layout of the frame
generated by this call is:
.blank.test page 11.nofill.nojustify
!======================================================!
!              Original return address                 !
!------------------------------------------------------!
/                                                      /
/      The stack variables (minimum of 3 words)        /
/                                                      /
!------------------------------------------------------!
!              The saved register (16)                 !
!------------------------------------------------------!
!               .FRAM1 return address                  !
!======================================================!
.fill.justify
.header level 3 >INTERRUPT
 The "INTERRUPT" variable call is identical to the
"ENTRY" call, except that register P1 is NOT left
pointing to the literal block of the caller's call.
This call is used by a software interrupt routine
to save registers 1-16 and set up some stack
variables, if desired.  When the routine that
invoked the $VARIABLE call returns (via a POPJ) a
DEBRK. or DEBRK% monitor call will be executed.  On
return from this call, register 16 is left pointing
at the stack frame and registers 1-15 are in an
unknown state.  The layout of the frame generated by
this call is the same as the "ENTRY" call.
.header level 3 >LOCAL
 The "LOCAL" variable call used to allocate stack
variables which are local to the current routine;
they are allocated as negative offsets on the stack
pointer (register 17) and are not valid if anything
is PUSHed on the stack.  A minimum of three words
are allocated on the stack for variables, if a list
of variables smaller than three is given, three
will be allocated.  This restriction is a result of
the scratch space used by the frame allocator.  No
registers are modified by this routine.  The layout
of the frame generated by this call is:
.blank.test page 11.nofill.nojustify
!======================================================!
!              Original return address                 !
!------------------------------------------------------!
/                                                      /
/      The stack variables (minimum of 3 words)        /
/                                                      /
!------------------------------------------------------!
!           The deallocation stack pointer             !
!------------------------------------------------------!
!                .FRAM3 return address                 !
!======================================================!
.fill.justify
.header level 3 >SAVE
 The "SAVE" variable call is identical to the
"ENTRY" call, except that register P1 is NOT left
pointing to the literal block of the caller's call.
This call is used to save registers 1-16 and set up
some stack variables, if desired.  On return
from this call, register 16 is left pointing at
the stack frame and registers 1-15 are in an
unknown state.  The layout of the frame generated
by this call is the same as the "ENTRY" call.
.header level 3 >SYMBOLS
 The "SYMBOLS" variables call is used to generate
some variables, but does NOT generate the stack
space.  These variables have a base register and
an initial offset of zero.  The >$CAL parameter
is the base register to be used with these
variables, the default is 16.  The >$REG and >$ACS
parameters are ignored.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 >$LST
 This parameter is a list of the variable names to be
allocated (enclosed in angle brackets).  The general
form of the variable list is:
.blank.center ;_<_<$VAR,$SIZ,$TST_>,_<$VAR,$SIZ,$TST_>,#...#_>
 Where $VAR is the variable name, $SIZ is the size of
the variable and $TST is the feature test flag.  These
arguments are described below:
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >$VAR
 This argument is the variable name to allocated on the
stack.  Also the symbol $'$VAR is created for ease of DDT
output (i.e. just type "$'$VAR_<ESC_>/").
.header level 3 >$SIZ
 This argument is the amount of space to be allocated to
the variable.  If this argument is zero, the variable will
NOT be allocated.  The default value is "1".
.header level 3 >$TST
 This argument is the feature test value for the variable.
If value of the parameter is zero the variable will NOT be
allocated, else the variable will be allocated.  The
default value is "-1".
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.note Angle Brackets Around Variables
If both >$SIZ and >$TST are being defaulted, the angle
brackets around >$VAR are NOT required for this variable.
The maximum amount of stack variable space that can be
allocated on one call to $VARIABLE is 8191.
.end note
.header level 2 >$CAL
 The call variable is a stack variable which points to
the return address of the current routine on the stack.
This is useful for finding the calling instruction.
 Note:  The call variable is NOT valid with INTERRUPT calls.
.header level 2 >$REG
 The register variable points to the saved registers on
the stack.  This allows a routine to retrieve the contents
of any registers which were stacked at the time of the
call.
 Note:  The register variable is NOT valid with INTERRUPT
or LOCAL calls.
 On return from the $VARIABLE call, the variables have
been allocated, but NOT zeroed.  Since these variables are
macro definitions which use index register 16 or 17, they
may not be used with another index register.  Register 17
is pointing at the >.FRAMx return address on the stack.
.header level 2 >$ACS
 This parameter is a list of the register variable names
to be allocated (enclosed in angle brackets).  The general
form of the register variable list is:
.blank.center ;_<_<$VAR,$ACN_>,_<$VAR,$ACN_>,#...#_>
 Where $VAR is the register variable name and $ACN is the
number of the register.  These arguments are described below:
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >$VAR
 This argument is the register variable name allocated on
the stack.  Also the symbol $'$VAR is created for ease of
DDT output (i.e. just type "$'$VAR_<ESC_>/").
.header level 3 >$ACN
 This argument is the saved register number to be
associated with the register variable name.
.enable TOC
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 The >$FRAME Macro
 This macro generates the subroutine which is called by the
>$VARIABLE macro.  This macro is expanded in >TYPER.MAC>.  The
generated code is a subroutine which has several global entry
points called .FRAMx, where "x" is between 0 and 4, and
.index .FRAM0
.index .FRAM1
.index .FRAM2
.index .FRAM3
.index .FRAM4
will call the routines generated by the >$LOCATE and
>$PARAMETER macros.
 The first optional argument to this macro which is the CPU
type (PDP6, KA10, KI10, KL10, KL20, KS10 or KS20), which if
omitted will default to the CPU type that it is being
expanded on.  This routine produces adjust stack pointer
(>ADJSP>) instructions if running on a KL-10, KL-20, KS-10
or KS-20 CPU.  The second optional argument is the monitor
type (TOPS10 or TOPS20), which if omitted will default to
"TOPS10" if the symbol DEBRK. is defined or "TOPS20" if the
symbol DEBRK% is defined.  If either or both DEBRK. and
DEBRK% are defined an error message is generated.
.header level 1 The >$LOCATE Macro
 This macro expands to a routine which calculates an effective
address.  The reason there is a subroutine to do this rather
than relying on the hardware is to handle the case where the
address is a register that has been saved on the stack.  In
this event, this routine will properly point to the location
on the stack where the register has been saved.  This assumes
that register 16 points to a frame on the stack which contains
the registers, as setup by the >$VARIABLE macro and >.FRAME
subroutine.
 The routine generated has a global entry point of >.LOCAT>,
expects the address to be calculated in T1, will return the
effective address in T1 and destroys T2.  This macro is
expanded in >TYPER.MAC>.
.header level 1 The >$PARAMETER Macro
 The $PARAMETER macro generates a routine to find the address
of the instruction which called the current routine.  This
routine is used by >$FRAME>, and assumes the calling
instruction to be an "ERCAL#@" or "PUSHJ#P,@".  This routine
properly detects >DDT >breakpoint>s.  The entry point to this
.index DDT breakpoint
routine is >.PARAM>, and is contained in >TYPER.MAC along
with >$FRAME and >$LOCAT macro expansions.
.chapter >TYPER Macros
 The TYPER macros are a set of macro definitions and
subroutines which are designed to make ASCII output easier for
the programmer, thus leaving him more time for more esoteric
programming.  Although they are primarily used for TTY output,
they may also be used to do output to any device or file.
These macros depend on symbols that are generated by the
>$VRSN and >$RELOCATION macros.
.note The SYSUNV Calling Standard
The code generated by the >$ERROR>, >$TYPE and >$TYPES macros
is one location of inline code which is a "ERCAL#@[#...#]" or
"PUSHJ#P,@[#...#]".  All >$ERROR>, >$TYPE and >$TYPES calls can
therefore be SKIPped around.
.end note
.header level 1 The >$BITS Macro
 The $BITS macro is used in conjunction with the >$BIT
substitution type of the >$ERROR or >$TYPE call to generate
an argument block.  The >$BIT substitution type is used to
decode bit masks/fields into some kind of English text.
The >$BITS macro is used to describe this field and the
ASCII strings represented.  The format of a $BITS call is:
.blank.nofill.nojustify;	$BITS	($TYP,$MSG,$BIT,$MSK,$FLG,$XTR)
.fill.justify
 These fields are described below:
.disable TOC
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 2 >$TYP
 This parameter describes the type of field and how it is
to be output.  For normal bit masks, a string is typed for
each corresponding bit turned on in the mask (normally with
commas separating all but the last two strings).  For a
field type, the field value is used as an index into the
table of strings for the proper message to be used.  These
types are:
.test page 30.left margin 20.set paragraph -10,1,2.tab stops 20
 #Type	Description
 >AND	Separate the bit strings with a comma, except for the last
two strings, which are separated with the word "and".
 >COMMA	Separate all the bit strings with a comma (",").
 >CRLF	Separate all the bit strings with a carriage-return/line-feed
(_<CR_>_<LF_>).
 >EXCLAIM	Separate all the bit strings with an exclaimation
point ("!").
 >FIELD	Use the value of the field as an index into the table of
strings.  See the $XTR argument.
 >NONE	Don't separate the bit strings with anything.
 >OR	Separate the bit strings with a comma, except for the last
two strings, which are separated with the word "or".
 >PLUS	Separate all the bit strings with a plus sign ("+").
 >SPACE	Separate all the bit strings with a space ("#").
 >USER	Separate the bit strings with a user supplied strings.  See
the $XTR argument.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 Note:  "AND" is the default if this field is omitted.
.header level 2 >$MSG
 This parameter is the address of the table of ASCIZ strings (the
strings may be internal, external or a combination of both, see
>$TYPES >EXT>),
.subindex $TYPES >EXT
a one word SIXBIT strings or an indirect pointer to the table.

Note:  Address-1 is the string for the default message; the
string output if all bits in the mask are zero, or if the field
value is out of range.
.header level 2 >$BIT
 This parameter is the bit mask to be tested or an indirect pointer
to the bit mask to be tested.
.header level 2 >$MSK
 This parameter is the mask or an indirect pointer to the mask to
be used to extract the bits.
.header level 2 >$FLG
 This is a list of flags which further describe the arguments.
There can be one or more of the following:
.test page 28.left margin 21.set paragraph -11,1,2.tab stops 21
 ##Flag	Description
 >ASCII	The message table contains pointers to the ASCIZ strings
or external strings.
 >BIT	The argument to the $BIT parameter is an indirect
pointer to the actual bits.
 >EXTRA	The argument to the $XTR parameter is an indirect
pointer to the actual bits.
 >MASK	The argument to the $MSK parameter is an indirect
pointer to the mask.
 >MESSAGES	The argument to the $MSG parameter is an indirect
pointer to the messages.
 >NUMBER	The bit number is to be output, "1Bn" where "n" is
the bit number, (non-"FIELD" only).  The message pointer, $MSG,
is used only if the default message is needed.
 >OCTAL	The octal value of the field is to be output after the
default message, if the value is out of range ("FIELD" only).
 >SIXBIT	The message table contains one word SIXBIT strings.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 Note: "ASCII" is the default if none given.  "1Bn" is the default
for a message if an individual ASCIZ pointer or SIXBIT string
contains a zero.
.header level 2 >$XTR
 This parameter is only used with the "FIELD" and "USER" output
types.  For the "FIELD" function this argument is the maximum
field value.  For the "USER" function, this argument contains the
address of the ASCIZ string to separate all but the last two bit
strings (in the left half) and the address of the ASCIZ string to
be used to separate the last two bit strings (in the right half).
.enable TOC
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 The >$ERROR macro
 See the >$TYPE macro for an explanation of the the $ERROR macro
parameters.  In code for TOPS-10 $ERROR may be used anywhere and
it is literally identical to a $TYPE call.  In code for TOPS-20
$ERROR should ONLY be used in places where a ERCAL may be used.
The call is:
.nofill.nojustify.blank ;	$ERROR  ($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG)
.fill.justify
.header level 1 The >$NUMBER Macro
 The $NUMBER macro is used to generate an argument block for the
>$NUM output substitution call (used by the >$ERROR or >$TYPE
macro).  This macro creates a block of words which describes the
location for the number to be output, and the format in which it
is to be typed.  The call is:
.nofill.nojustify.blank ;	$NUMBER	($ADR,$TYP,$DTP,$DPT,$NOT,$EX1,$EX2,$EX3)
.fill.justify
 The parameters are described below:
.disable TOC
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 >$ADR
 This parameter is the address of the number to be typed, or a
pointer to it.
.header level 2 >$TYP
 This parameter is the type of output conversion to be performed.
The allowed conversions are:
.test page 12.left margin 20.set paragraph -10,1,1.tab stops 20
 #Type	Description
 >FLOAT	For floating point conversion.  The data is assumed to be
in standard DECsystem-10/DECSYSTEM-20 floating point format.
 >INTEGER	The data is output as an integer.
 >SPECIAL	The output type is one of alpha, roman numerals,
English or picture conversion.  See the >$NOT parameter.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 2 >$DTP
.set paragraph 0,1,2
 The argument to this parameter is the input data type.  This can
be one of "SINGLE" for single precision, "DOUBLE" for double
precision, "BYTE" for an arbitrary byte of data, "LEFT" for a left
half word quantity or "RIGHT" for a right half word quantity.
Note that "SINGLE" and "DOUBLE" are the only allowed arguments if
the data type ($TYP parameter) is "FLOAT".
 Note: "SINGLE" is the default if this argument is left blank.
.header level 2 >$DPT
 This argument is the type of data pointer.  These types are:
.test page 12.left margin 22.set paragraph -12,1,1.tab stops 22
 ##Type	Description
 >ADDRESS	The >$ADR argument is the address of the number to
be typed.
 >IMMEDIATE	The >$ADR argument is the data to be typed.
 >INDIRECT	The >$ADR argument is an indirect pointer to the
data.
 >POINTER	The >$ADR argument is a byte pointer to the data.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 Note:  That "POINTER" is not allowed for the "FLOAT" output type.
"ADDRESS" is the default for this field if not given unless the
data type is "BYTE", then the default is "POINTER".
.header level 2 >$NOT
 This parameter is the notation for output:
 For floating point output this can be either "NORMAL" for normal
floating point output or "SCIENTIFIC" for scientific notation.
The default is "NORMAL".
 For integer output this is either "SIGNED" for a signed number or
"UNSIGNED" for an unsigned number.  The default is "UNSIGNED".
 For the "SPECIAL" output type, this argument can be one of:
.test page 14.left margin 20.set paragraph -10,1,1.tab stops 20
 #Type	Description
 >ALPHA	For alpha notation (used for outputting minor version
numbers).
 >ROMAN	For roman numeral output.  The data must be between 1
and 3999 inclusive.
 >ENGLISH	For English output (i.e. "three hundred
seventy-five").
 >PICTURE	For outputting data according to a COBOL picture
string.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 "PICTURE" is the default for this field if not given.
.header level 2 >$EX1
 For the "FLOAT" output type this is the total field width (from
0 thru 125) or the keyword "FREE".  The keyword "FREE" implies
that the width is calculated.  "0" is the default for this field.
 For the "INTEGER" output type this is the total field width
(from 0 thru 125).  "0" is the default for this field.
 For "ALPHA", "ENGLISH" or "ROMAN" output notations, this field
is either "UPPER" or "LOWER" to describe the case that the number
is to be output in.  If this parameter is not given, lower case is
assumed.
 For the "PICTURE" notation, this argument is the actual picture
string enclosed in angle brackets (i.e. _<Z(5)9.99_>) or a pointer
to it (see the >$EX2 argument).  There is no default for this
field.
.header level 2 >$EX2
 For the "FLOAT" output type this field is either the number of
digits to be typed in the fractional part of the number or the
keywords "FREE" and "INTEGER".  The keyword "FREE" implies that
the fractional width is to be calculated and the decimal point
is not typed if the width is 0.  The keyword "INTEGER" implies
the decimal point is not typed.  "5" is the default for this
field if not given.
 For the "INTEGER" output type, this field is the output radix
to be used.  This can be specified as either a number (from 2 thru
36) or one of "DEC", "HEX" or "OCT" for decimal, hexadecimal or
octal radix respectively.  "OCT" is the default if this parameter
is not given.
 For the "ENGLISH" or "ROMAN" notations, this is either "CARDINAL"
or "ORDINAL" for cardinal or ordinal numbers.  "CARDINAL" is the
default if not given.
 For the "PICTURE" notation, this argument is "LITERAL" if the
argument to the >$EX1 parameter was the actual picture string or
"POINTER" if the >$EX1 parameter is a pointer to the picture
string.  "LITERAL" is assumed if this parameter is omitted.
.header level 2 >$EX3
 This field describes the leading fill for the "FLOAT" or "INTEGER"
data types.  This may be "BLANK" for leading blank fill, "ZERO" for
leading zero fill or some character to be used to replace leading
zeros.  If the data type is "FLOAT", this argument may be "DOLLAR"
to output the number with leading space fill, preceded by a dollar
sign.  "BLANK" is the default for the "FLOAT" data type, "ZERO" is
the default for "INTEGER".
 For the "PICTURE" notation, this is either "SAVE" to save the
compiled picture string in the scratch space provided by the >$TYPES>
.subindex $TYPES >PIC
>PIC call, or "NOSAVE" to discard the compiled picture when done.
The default for this field is "SAVE" if the argument to >$EX2 was
"LITERAL", "NOSAVE" if it was "POINTER".
.test page 6
.enable TOC
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 The >$TYPE Macro
 The $TYPE macro is the macro which is used to output an ASCII string
with output conversions for numbers, ASCIZ or SIXBIT substrings, etc.
The arguments to the macro call describe the type of message (error,
warning, information, or operator intervention required), the message
prefix, and the type of output conversion to be used for the supplied
arguments at runtime.  The format of the call is:
.nojustify.nofill.blank
	$TYPE	($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG)
.just.fill
 Where >$HDR is the message type, >$SFX is the last three
characters of the message prefix, >$SUB is the substitution type,
>$TXT is the ASCII text, >$TRL is the trailer code (i.e.
whether or not a trailing a carriage-return/line-feed should be
output), >$RET is the type of return to take, >$BAS is the
address of the database to be used, >$LST is the substitution
parameter list and >$MSG is the message level. These are
described in detail below:
.disable TOC
.header level 2 >$HDR
 This argument specifies the header type to be used.  The header
types available are:
.blank.test page 12.left margin 26.set paragraph -21,0,1.tab stops 14,26
 Option	#Leading	Description
 #Type	Character
.blank
 ##B	#_<space_>	For a leading space, no prefix.
 ##C		For a continuation message, no prefix.
 ##F	####?	For a fatal error message.
 ##I	####[	For an information message.
 ##M	####"	For an operator information message.
 ##N		For no header or prefix.
 ##O	####$	For an operator intervention required.
 ##T	##_<tab_>	For a leading tab, no prefix.
 ##W	####%	For a warning message.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 A six character message prefix consisting of the program's CCL
name (as defined for the >$VRSN macro) and a three character
abbreviation (supplied as the >$SFX argument) will be output
for header types F, I, M, O and W, then the address of the call
in parentheses, followed by a space character will be output at
the beginning of the message.  If the header type is I, a "]"
will be output at the end of the line, unless the "N" option is
given as the argument >$TRL>, in which case the "]" will be
deferred until the next $TYPE call which ends the line without
specifying that the trailer be omitted.
.header level 2 >$SFX
 This argument is a three character suffix which is appended to
the program's CCL name to be output as part of the message
prefix.  If the suffix is non-blank, the text blank and the
substutition type blank when used with the header type "N", a
"PUSHJ P,@$$$sfx" will be generated (where "sfx" is this
argument).  The $TYPE macro will generate a label of the form
"$$$sfx", which implies that there can be only one call which
uses this suffix with any header type other than "N".
.header level 2 >$SUB
 This argument specifies the substitution type to be performed
on the argument passed in accumulator 1 (normally called >T1>,
see >$BEGIN macro).  This substitution is performed on the first
occurrence of a "|" (vertical bar)
.index vertical bar
character which is encountered in the supplied ASCII string.
These substitutions are:
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >$ASC
 Output the ASCIZ string pointed to by T1.  For memory resident
strings T1 contains an address or a standard byte pointer to an
ASCIZ string.  For external strings T1 contains >TF%EXT plus
the external string number, for more information see >$TYPES
>EXT>.
.subindex $TYPES >EXT
.header level 3 >$BIT
 T1 contains the address of the parameter block created by the
>$BITS macro.
 Output a text string which corresponds to the non-zero bit(s)
in the bit mask given.  Examples of this substitution type are
given later.
 This substitution type is useful for outputting error messages
in which the program is given a bit mask of what errors occured
(as in the case of the device status bits on an I/O error).
For the case of having an error number (like a LOOKUP/ENTER or
an IPCF error), the "FIELD" option can be used.
.header level 3 >$BLK
 Output the number in T1 in decimal unless it is an integral
multiple of 128, in which case it will type the number divided
by 128, followed by a "B" (for blocks).  This substitution
type is used to output file sizes.
.header level 3 >$CHR
 Output the contents of T1 as a single right justified ASCII
character.
.header level 3 >$CON
 This specifies the start on a continuation message.  This is
used with the non-continutation message and works just like the
header type C, except the trailer is output.
.header level 3 >$COR
 Output the contents of T1 as a core size.  If the number is an
integral multiple of 512 (1024 if running on a KA-10 or PDP-6),
the number will be divided by 512 (or 1024) and output with a
"P" ("K" for KA-10 or PDP-6) appended.  Otherwise, the number
is typed in decimal.
.header level 3 >$DAT
 Output the contents of T1 as "dd-mmm-yy", where "dd" is the
day of the month, "mmm" is the three letter abbreviation of
the month, and "yy" is the year.
 If the argument in T1 is negative the current date is output,
if the left half is non-zero, the date is assumed to be in
universal date/time format, if the left half is zero,
.index ^Universal date/time
the date is in DEC 15 bit date format:
.blank.center ;(((year-1964)*12+month-1)*31+day-1)
.header level 3 >$DAY
 Output the contents of T1 as a day of the week.  The argument
in T1 is in the same format as the >$DAT substitution.
.header level 3 >$DEC
 Output the contents of T1 as a decimal integer.
.header level 3 >$DIR
 Output the directory name associated with the directory number
in T1.  This substitution can also be used to output the user
name associated with the user number in T1.
.header level 3 >$DTL
 Output the contents of T1 in a "long" data format (e.g.
September 30, 1978).  The argument in T1 is the same as for the
>$DAT substitution.
.header level 3 >$ELS
 This is used in conjuction with the >$SKP substitution type,
and is a logical >ELSE to the skip.  The >$ELS will invert
the output condition.  This output condition remains in
effect until either another >$ELS or an >$EOS substitution
is encountered.  Note:  More than one >$ELS may be specified
between a >$SKP and >$EOS pair.
.header level 3 >$ENT
 Output the OPEN and LOOKUP/ENTER blocks pointed to by T1.
The left half of T1 contains the address of the open block,
.index OPEN/LOOKUP/ENTER/RENAME ^Blocks
the right half contains the address of the LOOKUP/ENTER
block.  This will output the file name in the format:
"dev:file.ext[p,pn,sfd1, ... ]".  If the left half of T1 is
zero, then the right half is assumed to be a pointer to a
>FILOP. argument block.
.header level 3 >$EOS
 This ends a conditional output string.  See the >$SKP
substitution type.
.header level 3 >$ERR
 Output a LOOKUP/ENTER/RENAME error using the arguments pointed
to by T1.  The contents of T1 are the same as for the >$ENT
substitution type.  The output produced is an English error
message (like "File not found"), followed by the file name.
Note:  If a FILOP. block is given with a RENAME subblock, the
error code if any in the RENAME subblock is used.
.header level 3 >$ERS
 Output the error string associated with the error number in T1.
The right half contains the JSYS error number, external string
number or zero for the most recent error and the left half
contains the process or zero for the current process, the left
half is ignored on TOPS-10.
.header level 3 >$FUL
 This assumes that the contents of T1 is six SIXBIT characters,
and will output them converted to ASCII including trailing spaces.
.header level 3 >$FUN
 Output a character or string of characters in "funny" format.
The "funny" format is as follows:  lower case characters are output
as "'X" and controls characters are output as "_^X" if they're not
in the table given below:
.blank.test page 9.left margin 25.set paragraph -15,0,1.tab stops 25
 #Character	Output
.blank
 >.CHBEL#(007)	_<BEL_>
 >.CHTAB#(011)	_<TAB_>
 >.CHLFD#(012)	_<LF_>
 >.CHVTB#(013)	_<VT_>
 >.CHFFD#(014)	_<FF_>
 >.CHCRT#(015)	_<CR_>
 >.CHESC#(033)	_<ESC_>
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 If the left half of T1 contains a 0 or -1, then a single right
justified character is output.  Else T1 is assumed to be a
pointer to an ASCIZ string.  This pointer has two forms:  1) a
standard byte pointer or 2) if bits 0 thru 11 contain 4000
(which is translated into "POINT 7,effective-address").
.header level 3 >$HEX
Output the contents of T1 as a >hexadecimal integer.
.header level 3 >$JFN
 Output the contents of T1 in JFN format, >TOPS-20 only.  The
right half of T1 contains the JFN of the file and the left half
of T1 contains the output control flags.  >TF%DEV thru >TF%ACT
are 2 bits values, each byte represents a field in the file
specification.  The value of the byte indicates the output
desired for the field.  The output control values are:
.blank.test page 6.left margin 19.set paragraph -9,0,1.tab stops 19
 Value	Description
.blank
 >.TFNOF	Do NOT output this field.
 >.TFAOF	Always output this field.
 >.TFSSD	Suppress this field if the same as the system
default.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 The output control flags are:
.blank.test page 13.left margin 19.set paragraph -9,0,1.tab stops 19
 #Flag	Description
.blank
 >TF%DEV	Output flag for device field.
 >TF%DIR	Output flag for directory field.
 >TF%NAM	Output flag for file name field.
 >TF%TYP	Output flag for file type field.
 >TF%GEN	Ouptut flag for file generation number field.
 >TF%PRO	Output flag for file protection field.
 >TF%ACT	Output flag for file account field.
 >TF%TMP	Output temporary flag (;T) if appropriate.
 >TF%TBR	Output a tab before all fields returned.
 >TF%TBP	Output a tab before all possible fields returned.
 >TF%PAF	Output punctuation for all fields.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 If the left half of T1 contains zero, the following default
will be supplied:  Always output the device, directory, file
name, file type and generation, and puntuate all field.
.header level 3 >$LFT
 Output the contents of the left half of T1 as three or less
SIXBIT characters).  Trailing spaces are deleted.
.header level 3 >$LIN
 Output a carriage-return/line-feed sequence.  The argument in
T1 is the number of _<CR_>_<LF_> sequences to type, or negative
if a form-feed is wanted.
.header level 3 >$LKP
 This substitution type is identical to the >$ENT substitution.
.header level 3 >$NAM
 Output the TOPS-10 user name pointed to by in T1, up to twelve
characters in length.  On entry, T1 contains the address of the
first of the two SIXBIT words.  Trailing spaces are deleted.
.header level 3 >$NON
 No substitution is to be performed.
.header level 3 >$NUM
 Output a number according to a format defined by the user.  The
contents of T1 points to the argument block generated by the
>$NUMBER macro, which describes the format for the number to be
output.
.header level 3 >$OCT
 Output the contents of T1 as an >octal integer.
.header level 3 >$OPC
 Output the contents of T1 in PC format, 6 octal digits with
leading zero fill.  If T1 contains >.TFCUR output the PC of the
$ERROR or $TYPE call, or if T1 contains >.TFPRE output the PC of
the previous or upper level call, a >$VARIABLE macro must have
been executed on the upper level.
.header level 3 >$PFX
 Output the program's CCL name followed by the contents of T1.
If T1 is positive it is typed as a right justified ASCII
character, if negative, as a three character SIXBIT string (left
justified in T1).
.header level 3 >$PPN
 Output the contents of T1 in "PPN" format (i.e. [p,pn]).
.header level 3 >$PRO
 Output the contents of T1 as a three digit octal number with
leading zeros, enclosed in an angle brackets (_<nnn_>), as a file
protection code.  If the high order 9 bits of T1 are non-zero,
then the protection code is assumed to be those bits.  This allows
the user to output a file protection directly from the >.RBPRV
word in a LOOKUP/ENTER block.
.header level 3 >$PTH
 Output the path block pointed to by T1 as [p,pn,sfd1,sfd2, ... ].
.header level 3 >$R50
 Output the contents of T1 as six RADIX-50 characters, trailing
spaces deleted.
.header level 3 >$RUN
 Output the contents of T1 as program runtime.  If >TF%JIF is off
in T1, then T1 is assumed to be in milliseconds, otherwise in
jiffies.  The format in which it is typed out depends upon the
width of the field given in the >$TYPES >JST call.  If the width
.subindex $TYPES >JST
is negative, then the null fields of the output (i.e. hours and
minutes) are space filled; if zero they are suppressed; if
positive, all fields are output.  >TF%SIZ contains the number of
fractional digits wanted:
.blank.test page 6.left margin 19.set paragraph -9,0,1.tab stops 19
 #Size	Description
.blank
 >%TFSZ0	No decimal point or fractional digits.
 >%TFSZ1	A decimal point and 1 fractional digit.
 >%TFSZ2	A decimal point and 2 fractional digits.
 >%TFSZ3	A decimal point and 3 fractional digits.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >$SCN
 Output a >SCAN compatible file specification block which is
pointed to by T1.  The file name is output as
"dev:file.exe[p,pn,sfd1,sfd2, ... ]" with any wildcards output in
the appropriate places (e.g."DSKA:A?????.*[?,?]").
.header level 3 >$SIX
 Output the contents of T1 as up to six SIXBIT characters with
trailing spaces deleted.
.header level 3 >$SKP
 This substitution type will cause the instruction in T1 to be
executed.  If the instruction skips, then all output is flushed
until the corresponding >$EOS or >$ELS substitution is
encountered.  >$SKP>/>$EOS and >$SKT>/>$EOS pairs may be nested.
.note Warning
The effective address of the instruction to be executed is used
literally, it is NOT interpreted for the sake of "test" and "CAI"
instructions.  Registers T1 thru T4 are restored before the
instruction is executed, but if modified the new contents of these
registers will NOT be placed back on the stack frame.
.end note
.header level 3 >$SKT
 This substitution type will test the value in T1, if true
(non-zero) then all output is flushed until the corresponding
>$EOS or >$ELS substitution is encountered.  >$SKP>/>$EOS
and >$SKT>/>$EOS pairs may be nested.
.header level 3 >$SPC
 Output a string of spaces.  T1 contains the number of spaces
to be output.
.header level 3 >$SUB
 Output the string pointed to by T1, the same format as the >$ASC
substitution, as an ASCIZ string, but with substitutions, similar
to the >$TXT argument to the $TYPE call.
.header level 3 >$TIM
 Output the contents of T1 as a time of day in the form
"hh:mm:ss".  The argument in T1 is considered to be in
milliseconds if bits 1 and 2 are zero, universal date/time format
.index ^Universal date/time
if bit 1 or 2 is non-zero.  If T1 is negative, then the current
time is printed.
.header level 3 >$TML
 Output the contents of T1 in "long" time format (e.g. "hh:mm
{a.m./p.m.} {time zone}", where the argument in T1 is the same as
the >$TIM substitution.
.header level 3 >$UNV
 Output a date/time in the format "dd-mmm-yy:hh:mm:ss".  The
contents of T1 are assumed to contain a date/time in universal
date/time format.
.index ^Universal date/time
.header level 3 >$USR
 Output the user name associated with the user number in T1.
This substitution can also be used to output the directory name
associated with the directory number in T1.
.header level 3 >$VER
 Output the contents of T1 in version number format (i.e.
12D(123)-4).
.header level 3 >$XCT
 This will perform an "indirect" function: when called, T1
contains the real substitution type and address.
.header level 3 >$XWD
 Similar to >$PPN except that the square brackets ("[]") are
not output.
.header level 3 >$UR1 thru >$UR7
.index $UR1
.index $UR2
.index $UR3
.index $UR4
.index $UR5
.index $UR6
.index $UR7
 Uses a user supplied output conversion routine as given in the
>$TYPES >RTN call.
.subindex $TYPES >RTN
.header level 3 >$IND
 This performs no immediate substitution or conversion, but is
used to give multiple substitution types in a single >$TYPE call.
This specifies to >TYPER that T1 contains in the left half the
negative number of arguments supplied, in the right half the
address of the table of words which contain the substitution
types and addresses of the arguments (the addresses may contain
indirect bits and indexing).  Each word is used successively to
control a substitution as a "|" character is encountered in the
text string.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 If no argument is given as the substitution type, >$NON is
assumed to be the default.
.header level 2 >$TXT
 This argument is the ASCII string to be output.  Any "|"
characters found in the string will flag a substitution to be
performed and call the indicated conversion routine.
.header level 2 >$TRL
 This specifies the trailing string to be appended to the text.
It may be one of: "N" for no trailer, or "C" for a
carriage-return/line-feed sequence.  In the case of "C", if the
message type was information ("I"), then the "]" will be
inserted before the _<CR_>_<LF_> sequence.  If this argument
is left blank, "C" is assumed.
.header level 2 >$RET
 This specifies the address to return to on completion of the
>$ERROR or $TYPE call.  If left blank, "N" is assumed, which
will return to the next instruction following the call.  The
returns are:
.test page 28.left margin 14.set paragraph -9,1,1.tab stops 14
 Return	Description
 ##A	Type a fatal error message and then enter >DDT if
present.
 ##C	Return to the monitor and allow a CONTINUE.
 ##D	Enter >DDT if present, else the same as "M".
 ##E	Return to the monitor and reset all I/O.
 ##I	Return from interrupt, via DEBRK. or DEBRK% monitor
call.
 ##M	Return without resetting I/O, but don't allow a
CONTINUE.
 ##N	Return to the next instruction.
 ##N1	Return to the next instruction plus 1.
 ##P	Perform a return in behalf of the caller (similar to
calling with >PJRST>).
 ##P1	Similar to "P", but skip returns.
 ##S	Calls >.FMSGE in >SCAN following the message, for fatal
error processing.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 If there is a return code given, but does not match any of
the above, then it is assumed to be an address, and will be
transfered to upon completion.
.header level 2 >$BAS
 This specifies the address of the database to be used on this
>TYPER call (or any lower level >TYPER calls).  If left blank,
"C" is assumed, use the current database (as defined by the
last >$TYPES >INI>/>BAS>
.subindex $TYPES >INI
.subindex $TYPES >BAS
or an upper level >TYPER calls).  The database types are:
.blank.test page 5.left margin 12.set paragraph -7,0,1.tab stops 12
 Base	Description
.blank
 #C	Use the current database.
 #D	Use the default database.
 #E	Use the error database.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 If there is a database code given, but doesn't match any of
the above then it is assumed to be the address of the database
to use.
.note Warning
The >$BAS argument to the $ERROR, $TYPE and $TYPES macros will
change the database for this call and any lower level calls.
The original database is restored at the end of the call.
.end note
.header level 2 >$LST
 This is the substitution parameter list to be used by >TYPER>.
If left blank the argument is expected to be in T1.  If the
substitution type is NOT >$IND>, then the parameter is the
address of the argument.  If the substitution type is >$IND and
only one parameter is supplied it is assumed to be the indirect
pointer, else it is expected to be the actual indirect argument
list.
.header level 2 >$MSG
 The message level to be assigned.  If not given the current
message level is assigned.  Note:  The message level must be
between 0 and 999, inclusive.
 The message level is only reset to the default message level
(as defined by >$TYPES >MSG>)
.subindex $TYPES >MSG
when the trailer type (>$TRL>) of "C" is encountered.
.page
 Some examples of the $TYPE call are:
.blank.nofill.nojustify
	$TYPE	(N,,$NON,_<This is a message._>)
	$TYPE	(I,MSG,$NON,_<This is an information message_>)
.blank ;Would type:
.blank ;This is a message.
[PFXMSG#This is an information message]
.blank ;Some substitutions:
.blank ;	MOVEI	T1,[SIXBIT _\USER NAME_\]
	$TYPE	(I,USR,$NAM,_<The user name is |_>)
.blank ;Produces:
.blank ;[PFXUSR#The user name is USER NAME]
.blank ;	MOVE	T1,.MYPPN_#_#
	$TYPE	(W,PPN,$PPN,_<The PPn is |_>)
.blank ;Produces:
.blank ;%PFXPPN#The PPn is [1,2]
.blank ;	DATE	T2,
	MOVE	T1,[-3,,[$DAY	[-1]
			 $DTL	T2
			 $TML	[-1]]]
	$TYPE	(M,DAY,$IND,_<Today is |, | |_>)
.blank ;Produces something like:
.blank ;"PFXDAY#Today is Monday, September 25, 1978 08:30 a.m.
.blank ;An example of the >$BIT substitution:
.blank ;	OUT	DSK,
	POPJ	P,
	GETSTS	DSK,T2
	MOVEI	T1,[$BITS AND,MSGTAB,T2,IO.ERR,_<ASCII,BIT_>]
	$TYPE	(F,ODE,$BIT,_<Output DSK error, status = |_>,,P)
.blank ;	[ASCIZ	_\No error bits_\]
MSGTAB:	[ASCIZ	_\Improper mode_\]
	[ASCIZ	_\Hard device error_\]
	[ASCIZ	_\Hard data error_\]
	[ASCIZ	_\Block too large_\]
.blank ;Would print something like:
.blank ;?PFXODE#Output DSK error, status = Improper mode and Hard data error
.fill.justify
.page
.enable TOC
.header level 1 The $TYPEB Macro
 See the >$TYPE macro for an explanation of the the $TYPEB macro
parameters.  This macro don't generate any executable code only the
argument block to be used by the $ERROR or $TYPE macros.  The call
is:
.nofill.nojustify.blank ;	$TYPEB  ($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG)
.fill.justify
.header level 1 The >$TYPED Macro
 The $TYPED macro is used to create TYPER "database".  This database
is used to specify the output parameters for a TYPER output stream.
This macro is used to assemble in some of the parameters which would
otherwise be set by the >$TYPES macro at runtime.  This should be
assembled into low segment storage, as the data contained in it will
be considered impure by TYPER.  The argument to this macro is a list
of arguments collectively enclosed in angle brackets.  If a
sub-argument is to be assigned a value, it and its value will be
nested in one extra level of brackets (MACRO kroque).  The allowed
functions are:
.disable TOC
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 2 >EMP
 This takes as its value the address of the routine to empty the
output buffer.  This routine gets called whenever a >$TYPES >DMP>
.subindex $TYPES >DMP
is called.
.header level 2 >ERR
 This option causes .JBERR to be incremented on fatal errors
(whenever a header type of "F" is used in a >$ERROR or >$TYPE
call).
.header level 2 >JST
 This will set the horizontal justification tab stops.  The value
of this function is the address of the tab stop table, in the right
half, and negative the length of the table in the left half.
.header level 2 >MSG
 The value given to this function is the initial message level,
see $TYPES MSG.
.header level 2 >OUT
 The value of this function is the address of the output routine to
get called on each character output.
.header level 2 >SYS
 The value of this function is the system prefix.
.header level 2 >TIM
 The value of this function is the same as for the >$TYPES >TIM>
.subindex $TYPES >TIM
call.  This will set timestamping.
.header level 2 >VER
 The value of this function is the address of the vertical
justification database.  (See the >$TYPES description for the format
of this database).
.header level 2 >VRB
 The value of this function is the verbosity bits for this database.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 A sample call to the $TYPED macro would look like:
.blank.nojustify.nofill
TYPBAS:	$TYPED (_<_<JST,_<-JSTSIZ,,JSTTAB_>_>,_<TIM,,_<-1,,TIMSIX_>_>_>)
.fill.justify
 This would set the tab stops from the table at JSTTAB and turn
on timestamping, with the value at TIMSIX as the timestamp
label.  See the >$TYPES function descriptions for further details
on these options.
.enable TOC
.header level 1 The >$TYPER OPDEF
 The $TYPER OPDEF is used when debugging programs that contain
$ERROR, $TYPE or $TYPES calls that enter DDT.  When the user has
looked at everything worth looking in DDT, the following command
can be used to return to the instruction following the TYPER call:
$TYPER_<ESC_>X
.header level 1 The >$TYPES Macro
 The $TYPES macro is used in conjunction with the >$ERROR or
>$TYPE macro to initialize TYPER, modify TYPER databases, etc.
The format of the call is:
.blank.nofill.nojustify ;	$TYPES	$FNC,$RET,$BAS,$LOC
.fill.justify
.disable TOC
.header level 2 >$FNC
 This argument specifies the function to be performed by $TYPES.
The functions available are:
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >BAS
 This will change the database to be used as the default
database.  The right half of T1 should contain the database
address.  The left half of T1 may contain a flag to specify the
action to be taken. These are >.TFCLR to clear the database
specified and make it the default, >.TFINI to initialize the
database, but don't make it the default, >.TFRST to initialize
the database and set it as the default or >.TFUSE to make this
database the default without changing anything in it.  On return
T1 contains the address of the previous database in the right
half and .TFUSE in the left half.
 An alternate way to reset several database is the give a
negative count in the left half and the address of a list of
databases to reset in the right half.  On return T1 is unchanged.
.note Database Initialization
All databases must be initialized (>.TFINI>) or reset (>.TFRST>)
before they are used by the $ERROR, $TYPE or $TYPES macros.
.end note
.header level 3 >BUG
.subindex $TYPES >BUG
 This option is used where the programmer has detected a fatal
program bug, i.e. some section of code that he thinks is
impossible or improbable to get to, or anything that he doesn't
want to handle. This macro can be used in place of a >HALT
instruction or something equally gross.  This macro generates
one line of inline code and will produce an error message which
informs the user that a program logic error has occurred and
will give the absolute and relative (to the module) PC of the
error.
.header level 3 >COL
.subindex $TYPES >COL
 Will return in AC T1 the current horizontal position in the
output line.  This column counter is valid only when horizontal
justification ($TYPES JST) is being used.
.header level 3 >CMP
.subindex $TYPES >CMP
 Inform the TYPER system to convert multiple spaces to tabs.  If
the value in T1 is zero no conversion if performed, else the
multiple spaces are converted to tabs.  On return the previous
value is returned in T1.
.header level 3 >DMP
.subindex $TYPES >DMP
 Will force the text buffer to be dumped if the standard output
routine is being used.  This routine normally buffers in core
the entire line to be output, then outputs it all at once when
end of line is encountered.  This call will force the partial
line to be output.
.header level 3 >EMP
.subindex $TYPES >EMP
 This will change the address of the routine to empty buffers
when >$TYPES >DMP>
.subindex $TYPES >DMP
is called.  The user is responsible for buffering the data.
.header level 3 >ERR
.subindex $TYPES >ERR
 This will cause all fatal error messages (i.e., all with the
header type "F") to increment >.JBERR>.  This is used as a flag
to other programs that a system program error has occured.  On
entry T1 is non-zero to set this mode, zero to clear it.
.header level 3 >ESN
.subindex $TYPES >ESN
 This will change the default JSYS error number or external
string number used by the >$ERS substitution.  On entry T1
contains the JSYS error number or external string number to be
used when the default is requested from >$ERS, or >.TFCUR to
just read the current value.  On return T1 contains the previous
error number or external string number.
.note Error Number Storage
On TOPS-20 the error is stored in the monitor via a SETER JSYS
and returned via the GETER JSYS.  Therefore on TOPS-20 any JSYS
error will change this value.
.end note
.header level 3 >EXT
.subindex $TYPES >EXT
 This will add an additional external file to the list of
external files.  On entry T1 contains the address of the $TYPES
EXT block:
.blank.test page 2.nofill.nojustify
	MAX,,MIN	;#Word 0 of the block
	PTR		;#Word 1 of the block
.fill.justify
 Where this arguments are:
.test page 12.left margin 21.set paragraph -11,1,1.tab stops 21
 Argument	Description
 ##MAX	The maximum string number contained in the external
string file.
 ##MIN	The minimum string number contained in the external
string file.
 ##PTR	The address of a FILOP. block (TOPS-10) or a byte
pointer to an ASCIZ string (TOPS-20) containing the file
specification to the external string file.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
 On return the left half of T1 contains the I/O channel or
JFN, and the right half contains one of the following values:
.test page 15.left margin 19.set paragraph -9,1,1.tab stops 19
 Error	Description
 >.TFNON	No errors detected.
 >.TFNRA	No room available.  TYPER's internal database
needs to be expaned to allow for more external string files
(the default is ten) or the user is in a loop adding files.
 >.TFOVR	The range given overlaps and exsisting string
file.
 >.TFRNG	The range is invalid.  The minimum and maximum
may have been swapped.
 >.TFUGA	Unable to get access to the file specified.
You don't have access to the file or the file doesn't exsist.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >INI
.subindex $TYPES >INI
 This call should be performed before any other >$ERROR>,
>$TYPE or >$TYPES calls.  This will initialize >TYPER>, setup
the program's CCL name and reset the initial database.  On
entry, >TYPER assumes that the CCL name is in SIXBIT in the
left half of T1, the initial database in the right half of
T1.  If the database is left zero, the default database will
be used.  A sample call is:
.blank.nofill.nojustify ;	MOVSI	T1,>TP.PFX
	$TYPES	>INI
.fill.justify
.header level 3 >JST
.subindex $TYPES >JST
 This is used to setup software tab stops in the output line.
On entry, T1 contains in the left half the negative number of
tab stops, in the right half the address of the table of tab
stops formatted "XWD width,column".  The tab stop table must
be in ascending order by column.  For a tab stop with a
non-zero width, if a >$BLK>, >$COR>, >$DEC>, >$HEX>, >$NUM>,
>$OCT>, >$RUN> or >$XWD substitution is used, the number will
be output right justified in the field, with leading space
fill.
.header level 3 >LOC
.subindex $TYPES >LOC
 This routine is used to obtain the contents of a memory
location.  It is assumed that the calling routine has issued
a >$VARIABLE macro call prior to calling this function.
On entry, T1 contains an address (indexing and indirect may
be used), on return T1 will contain the contents of that
location.
.header level 3 >MSG
.subindex $TYPES >MSG
 This sets the message level for >$ERROR or >$TYPE calls.
This should be called with T1 containing the default message
level in the right half and the maximum message level to be
output by >$ERROR or >$TYPE in the left half.
.header level 3 >OUT
.subindex $TYPES >OUT
 This will change the default output routine to be used.  T1
contains the address of new output routine or zero, to use
the default output routine and the flag >TF%CTL if output is
NOT going to the controlling terminal, used only for fatal
error messages.
 The output routine specified will be given the character to
be output in the right half of T1.  The left half of T1 will
contain a -1 if the character is part of a time stamp, -2 if
it is part of a time stamp label or zero if none of the above.
The output routine  may NOT destroy any AC.  Note:  While in
the context of this routine, the user AC's 1 thru 16 have been
pushed on the stack, AC 15 contains the current message level
in the left half and the current database address in the right
half, and AC 16 contains a frame pointer.
.header level 3 >PIC
.subindex $TYPES >PIC
 This call expects T1 to contain the negative word count of
the picture buffer in the left half and the address of the
buffer in the right half.  This buffer is used to save
compiled picture strings.  If no space is allocated for the
picture buffer, no strings will be saved.
.header level 3 >PRM
.subindex $TYPES >PRM
 This call will clear a possible Control-O, then output a
prompt on the user console.  On entry, T1 should contain
(right justified) "_>" for a standard prompt, "!" for a
running prompt, "/" for a paused prompt or "_#" for a
continuation line on any of the above.  The prompt output
is of the form "ccl_>#", where "ccl" is the program's CCL
name as given in the >$TYPES >INI>
.subindex $TYPES >INI
call, and the character following is the character passed
in T1 on entry.  This routine does an implied >$TYPES >DMP>
.subindex $TYPES >DMP
to insure that the prompt gets output.
.header level 3 >RTN
.subindex $TYPES >RTN
.index $UR1
.index $UR2
.index $UR3
.index $UR4
.index $UR5
.index $UR6
.index $UR7
 This call is used to identify user defined output routines
to be used with the >$UR1 thru >$UR7 substitution types
for the >$ERROR or >$TYPE call.  T1 should contain in the
left half the number of routines given, and the address of
the table of the routines in the right half.  The first
routine in the table is assigned to >$UR1>, the second to
>$UR2>, etc.  These output routines will be given the argument
in T1 and the width in T4 on entry and may destroy T1, T2, T3
and T4.  Note:  While in the context of these routines, the
user AC's 1 thru 16 have been pushed on the stack, AC 15
contains the current message level in the right half and the
current database address in the left half, and AC 16 contains
a frame pointer.
.header level 3 >SYS
.subindex $TYPES >SYS
 This call will change the system prefix (the program's CCL
name).  On entry T1 should contain the new prefix in the left
half (in SIXBIT).
.header level 3 >TIM
.subindex $TYPES >TIM
 This will instruct TYPER to precede all output produced by
>$ERROR or >$TYPE calls with a time stamp.  The time stamp is
of the form "hh:mm:ss msg_<TAB_>", which is the time of the
day, and "msg" is an optional SIXBIT label which is some kind
of message abbreviation (like the "USER" and "MONTR" labels
in a batch log file).  On entry T1 contains a -1 for normal
time stamps, zero to turn off time stamps, -1 in the left
half and the address of a location (in the right half) which
contains a SIXBIT label to be output following the stamp, or
0 in the left half and the address of a routine to call in the
right half.  In all cases, on return T1 contains the previous
time stamp argument.
 The time stamp routine may destroy T1, T2, T3 and T4.  Note:
While in the context of this routine, the user AC's 1 thru 16
have been pushed on the stack, AC 15 contains the current
message level in the right half and the current database address
in the left half, and AC 16 contains a frame pointer.
.header level 3 >VER
.subindex $TYPES >VER
 This sets or clears the vertical justification.  Call with T1
containing the argument to the vertical justification system.
If T1 is zero on entry, vertical justification is cleared and
no special action will be taken at top of form (this is the
default case).  To set the vertical justification,  call with
T1 containing a pointer to the vertical justification database.
The format of this data base is:
.blank.test page 6.left margin 20.set paragraph -10,1,1.tab stops 20
 word+0/	The address of the page header routine
 word+1/	The address of the page trailer routine
 word+2/	The number of line in the header text
 word+3/	The first line number in the trailer
 word+4/	The number of lines per page or -1 to output
a formfeed instead of counting lines)
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >VRB
.subindex $TYPES >VRB
On entry, T1 contains the verbosity level bits.  Set the
verbosity level for output (e.g. >PREFIX>, >FIRST>,
>CONTINUATION or >ADDRESS>).  The verbosity level follows
the standard >TOPS-10 message format.  Here are the
verbosity level settings:
.blank.test page 6.left margin 19.set paragraph -9,0,1.tab stops 19
 #Flag	Description
.blank
 >%TFWPR	Output the prefix.
 >%TFWFL	Output the first line.
 >%TFWCN	Output the continuation line(s).
 >%TFWAD	Output the address of the call in parentheses.
.left margin 5.set paragraph 0,1,2.tab stops 13,21,29,37,45,53
.header level 3 >ZON>
.subindex $TYPES >ZON
 This will instruct TYPER to use a specific time zone.  T1
contains the time zone in the right half and if daylight
savings time is in effect, flag >TF%DLS should be on.  This
value will be initialized by the >$TYPES >INI> call.
.subindex $TYPES >INI
Note:  The time stamps are also adjusted by this call if
running on >TOPS-20>.
 The time zone values are as follows:
.blank.test page 10.left margin 19.set paragraph -9,0,1.tab stops 19
 #Zone	Description
.blank
 >.TFAST	Atlantic time zone
 >.TFEST	Eastern time zone
 >.TFCST	Central time zone
 >.TFMST	Mountain time zone
 >.TFPST	Pacific time zone
 >.TFYST	Yukon time zone
 >.TFHST	Hawaii time zone
 >.TFBST	Bering time zone
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 >$RET
 This specifies the address to return to on completion of the
>$TYPES call.  If left blank, "N" is assumed, which will return
to the next instruction following the call, unless $FNC is
">BUG>" then "D" is assumed.  The returns are:
.test page 28.left margin 14.set paragraph -9,1,1.tab stops 14
 Return	Description
 ##A	Type a fatal error message and then enter >DDT if
present.
 ##C	Return to the monitor and allow a CONTINUE.
 ##D	Enter >DDT if present, else the same as "M".
 ##E	Return to the monitor and reset all I/O.
 ##I	Return from interrupt, via DEBRK. or DEBRK% monitor
call.
 ##M	Return without resetting I/O, but don't allow a
CONTINUE.
 ##N	Return to the next instruction.
 ##N1	Return to the next instruction plus 1.
 ##P	Perform a return in behalf of the caller (similar to
calling with >PJRST>).
 ##P1	Similar to "P", but skip returns.
 ##S	Calls >.FMSGE in >SCAN following the message, for fatal
error processing.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 If there is a return code given, but does not match any of
the above, then it is assumed to be an address, and will be
transfered to upon completion.
.header level 2 >$BAS
 This specifies the address of the database to be used on
this >TYPER call.  If left blank, "C" is assumed, use the
current database (as defined by the last >$TYPES >INI>/>BAS>
.subindex $TYPES >INI
.subindex $TYPES >BAS
or an upper level >TYPER calls).  The database types are:
.blank.test page 4.left margin 12.set paragraph -7,0,1.tab stops 12
 Base	Description
.blank
 #C	Use the current database.
 #D	Use the default database.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
 If there is a database code given, but doesn't match any of
the above then it is assumed to be the address of the database
to use.
.test page 9.note Warning
The >$BAS argument to the $ERROR, $TYPE and $TYPES macros will
change the database for this call and any lower level calls.
The original database is restored at the end of the call.
.end note
.header level 2 >$LOC
 This specifies the address of the data for the specified
function.  The data is obtained and returned to this address.
The default value is T1.
.enable TOC
.chapter External String Support
 The external strings are used with TYPER, see >$ERS substitution,
>$TYPES >ESN, and >$TYPES >EXT>.
.subindex $TYPES >ESN
.subindex $TYPES >EXT
These macro are used with the >STRINGS flag to the >$BEGIN macro.
Here is a description of the External String macros:
.header level 1 The >$ESBEG Macro
 The >$ESBEG macro is something like the >$DSBEG macro in that it
defines the beginning of a set of external strings.  The format
of a call to $ESBEG is:
.blank.nofill.nojustify ;	$ESBEG $PFX,$BEG,$MAX
.fill.justify
 >$PFX is the two character prefix for all external strings
generated.  The symbols generated are of the form .xxyyy, where
"xx" is $PFX and "yyy" is the external string suffix ($SFX).
 >$BEG is the beginning value to be used by >$ESDEF when defining
the external string offset.
 >$MAX is the maximum number of external strings to be allocated.
This feature is not yet implemented.
.header level 1 The >$ESDEF Macro
 The >$ESDEF macro is used to define an external string.  The
format of a call to $DSDEF is:
.blank.nofill.nojustify ;	$ESDEF  $SFX,$TXT,$ARG,$TST
.fill.justify
 >$SFX is the symbol suffix.  The symbol defined is .xxyyy,
where "yyy" is $SFX.
 >$TXT is the text to be associated with the symbol.  The text
at the current moment has a maximum of 494 characters.
 >$ARG is a list of external arguments, which are NOT used by
the TYPER system.  This data is placed in the external string
file for the user convenience.
 >$TST is the feature test value, if the value is zero the
external string is not generated.  The default value is -1.
.header level 1 The $ESEND Macro
 >$ESEND is the end of this external string file.  It is used
to terminate a >$ESBEG.  The format of a call to $ESEND is:
.blank.nofill.nojustify ;	$ESEND  $SIZ,$TXT,$ARG
.fill.justify
 >$SIZ is the symbol suffix for the number of symbols defined.
The value is required when opening an external string file.
 >$TXT is the default text string to be used if a external
string is to be output, but can't be found in the file.  If
left blank the TYPER default will be used.
 >$ARG is a list of external arguments, which are NOT used
by the TYPER system.  This data is placed in the external
string file for the user convenience.
.chapter Miscellaneous Definitions
.header level 1 The >$PRINT Macro
 >$PRINT is a macro to produce assembly time error messages
via >PRINTX pseudo-op.  The format and use of the macro is
similar to that of >$ERROR or >$TYPE except that there is
no substitution performed, or alternate return addresses or
output routines (for nearly obvious reasons).  The format
of the call is:
.blank.nofill.nojustify ;	$PRINT	($HDR,$SFX,$TXT)
.fill.justify
 Where $HDR is one of F, I, O and W (which do roughly the same
things as in the >$ERROR or >$TYPE call), $SFX is a three
character string to be appended to the CCL name (>TP.PFX>) for
a message prefix, and $TXT is the text to be output.  This
macro generates no code, and is only of value at assembly time.
Note:  If the header type is F, a macro "A" error is generated
on pass 2.
.header level 1 The >PFALL Macro
 This macro is similar to the >PJRST OPDEF except that no code
is generated.  The single argument to this macro is the label
(or address) of the routine that we are falling into.  If this
is found not to be the next instruction, an error message is
generated.  This macro is used only to add clarity to a
program.  Example:
.nofill.nojustify.blank ;	PFALL	TTYOUT		; Fall into output routine
.fill.justify
 The next instruction MUST have the label TTYOUT.
.chapter Putting it All Together
 This chapter deals with how to use all of what has been
explained in the previous sections.  Using these macros is
very simple after the programmer has gotten some experience
with them; however they may look a bit complicated at first.
This chapter will attempt to make some of the interactions
between the macros a little bit more clear.
 The most probable reason anybody would want to use any of
these macros is to take advantage of the >$ERROR or >$TYPE
macro to type his error/warning messages.  A good rule of
thumb to keep in mind is that since this macro references
symbols produced by most of the other macros, it is generally
a good idea to use all of them (>$BEGIN>, >$VRSN>, >$TITLE>,
>$RELOCATION>, etc.).  If the program uses >SCAN>, it is
advisable to use the >TYP7S.REL module, which contains the
processors for the >$ERROR>, >$TYPE>, >$TYPES> and >$VARIABLE
macros.  If the program does not use >SCAN>, the >TYP7N.REL
module should be used.
 The following sections deal with the specifics of how to
properly setup and use everything.
.note Energy Enterprises's MACRO
The SYSUNV macros use a special macro definition format defined
in Energy Enterprises's local version of MACRO-10/20, see some
examples in appendix A.  This is the macro expansion format
(SALL, LALL and XALL) enclosed in square brackets preceding the
argument list.
 This version of MACRO also has the IFIDNX and IFDIFX macro
pseudo-ops defined, which are identical to the IFIDN and
IFDIF pseudo-ops except they do case conversion.
.end note
.header level 1 Initializing Everything
 Before any of the heavy macros can be used, things should be
properly initialized.  This consists of defining the version
number, setting up the title, requesting the proper relocation,
searching >UUOSYM or >MONSYM>.  These can all be accomplisted
by using the >$BEGIN macro.
 The first page of a program could look something like:
.tab stops 8,16,24,32,40,48,56,64
.blank 2.nofill.nojust
; Required symbols and macros
.blank
	SEARCH	SYSUNV			; Get some local goodies
.blank
; Assembly directives
.blank
; Setup the world
.blank
	$BEGIN	EXEUTL -- Utility for Tweaking EXE Files,EXE,1(7)-4,_^__
		_<TOPS10,TYPER,SCAN_>
.fill.justify
.header level 1 Register Definitions
 Some of the macros require specific definitions for some
register names.  Generally, using >SCAN compatible
definitions (registers 1 thru 4 named T1 thru T4, registers
5 thru 10 named P1 thru P4 and P = 17) will work.
.index T1
.index T2
.index T3
.index T4
.index P1
.index P2
.index P3
.index P4
.index P
The main requirement is that the stack pointer is in
register 17 with the name P and that there are register
definitions for T1 thru T4 and P1 thru P4.  If the
register definitions are not >SCAN compatible, the >TYPER
module must be reassembled with the proper definitions for
the program.  If the AC defintions are inconsistent, >SYSUNV
will issue an error message (using the >$PRINT macro) to warn
the programmer.
.header level 1 Runtime Initialization of the TYPER Routines
Before any >$ERROR>, >$TYPE or >$TYPES calls can be executed
by the user program, the >$TYPES >INI call should be issued.
.subindex $TYPES >INI
Thish will properly initialize the TYPER routines so that
everything will function normally.  If using >SCAN>, the best
place to put this call is fairly soon after the >.ISCAN call.
.test page 10
 An example of the initialization is:
.blank.nofill.nojust
	MOVE	T1,ISCNPT		; Get the ISCAN pointer
	PUSHJ	P,.ISCAN_#_#		; Go initialize SCAN
	MOVSI	T1,TP.PFX		; Get system prefix
	$TYPES	INI			; Initialize TYPER
.fill.justify
 Note:  The symbol >TP.PFX is defined by the >$VRSN or
>$BEGIN macro.  After this initialization, the programmer
is free to use any of the >$ERROR>, >$TYPE and >$TYPES
calls.
.header level 1 Some Hints on Using SYSUNV
 There are some useful things associated with these macros,
which may not justify using SYSUNV to begin with, but nice to
have anyway.
.disable TOC
.header level 2 >$VARIABLE>, >.LOCAT and >.PARAM
 These are useful for subroutine entry and parameter fetching.
The >$VARIABLE macro is used on entry to the subroutine to stack
AC's 1 thru 16, and allocate any required stack variables.  On
return, P1 will contain a pointer to the argument list (assuming
that the subroutine was called with an "ERCAL#@[#...#]" or a
"PUSHJ#P,@[#...#]").  Any addresses passed as arguments (including
saved AC's) can be located using the >.LOCAT routine.  An example
of how this can be done is shown in appendix A.
.header level 2 The >$PRINT Macro
 This macro is useful for outputting assembly time error messages
or information.
.header level 2 >$TYPES >BAS
.subindex $TYPES >BAS
 By changing the database the programmer can affect the time
stamps, justification, verbosity, etc. without worry of doing
several $TYPES calls to save the world.  This is very useful
if you are doing formatted output, the program gets an interrupt
and must reprompt the user for a command.
.header level 2 >$TYPES >OUT
.subindex $TYPES >OUT
 By changing the default output routine via this call, the
programmer can direct his output to virtually anything he wants.
It can be used to output to a file, build a string in core, etc.
Having done so, the programmer then has full access to the
>$ERROR or >$TYPE macro and all associated routines to do
formatted output to a file (or any other destination he has in
mind).  The >$TYPE macro has a fairly high per character
overhead, but for limited applications, it can make life a lot
easier.  Care should be taken that the program always keeps
track of where the output is going so that error messages don't
end up in a user file when they should have been printed on the
console.
.enable TOC
.header level 1 Building SYSUNV from Scratch
 This section deals with how to build the SYSUNV.UNV from
scratch.  The problem in building SYSUNV is that SYSUNV
searches itself.  This can cause problems if you don't have a
copy of >SYSUNV.UNV when you try to assemble it.  A special
file (>SYSBLD.MAC>) has been made to bootstrap the assembly
procedure.  To build SYSUNV type:
.nofill.nojustify.blank
COMPILE/NOBINARY SYSBLD+SYSUNV,SYSUNV/CREF
.fill.justify
 This will produce >SYSUNV.UNV and >SYSUNV.CRF>.  Energy
Enterprises's copy of MACRO-10/20 must be used, otherwise the
listings will contain very lengthy macro expansions and a very
large number of undefined global symbols.
.chapter Miscellaneous Symbols
 This chapter is used to defines several of the miscellaneous
symbols that are available in the SYSUNV.
.page
.header level 1 OPDEF's of Some Useful Opcodes
.blank.left margin 14.set paragraph -9,1,1.tab stops 14
 OPDEF	Description
 >PJRST	JRST - a subroutine that is returning via another
routine.
 >PJRSTF	JRSTF - a subroutine that will be returning
via another routine and is restoring the flags.
 >PJSP	JSP - a subroutine that will be returning via another
routine, but loads its return address in an AC.
 >PJMPE	JUMPE - a subroutine that will be returning via
another routine, if the value in an AC is equal to zero.
 >PJMPG	JUMPG - a subroutine that will be returning via
another routine, if the value in an AC is greater than zero.
 >PJMPGE	JUMPGE - a subroutine that will be returning
via another routine, if the value in an AC is greater than or
equal to zero.
 >PJMPL	JUMPL - a subroutine that will be returning via
another routine, if the value in an AC is less than zero.
 >PJMPLE	JUMPLE - a subroutine that will be returning
via another routine, if the value in an AC is less than or
equal zero.
 >PJMPN	JUMPN - a subroutine that will be returning via
another routine, if the value in an AC is not equal to zero.
.page
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols for ASCII Characters
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >.CHNUL	Control-@##NUL##Null
 >.CHCNA	Control-A##SOH##Start of header
 >.CHCNB	Control-B##STX##Start of text
 >.CHCNC	Control-C##ETX##End of text
 >.CHCND	Control-D##EOT##End of transmission
 >.CHCNE	Control-E##ENQ##Enquiry
 >.CHCNF	Control-F##ACK##Acknowledge
 >.CHBEL	Control-G##BEL##Bell
 >.CHCNH	Control-H##BS###Backspace
 >.CHTAB	Control-I##HT###Horizontal tab
 >.CHLFD	Control-J##LF###Line-feed
 >.CHVTB	Control-K##VT###Vertical tab
 >.CHFFD	Control-L##FF###Form-feed
 >.CHCRT	Control-M##CR###Carriage return
 >.CHCNN	Control-N##SO###Shift out
 >.CHCNO	Control-O##SI###Shift in
 >.CHCNP	Control-P##DLE##Data link escape
 >.CHCNQ	Control-Q##DC1##Device control 1
 >.CHCNR	Control-R##DC2##Device control 2
 >.CHCNS	Control-S##DC3##Device control 3
 >.CHCNT	Control-T##DC4##Device control 4
 >.CHCNU	Control-U##NAK##Negative acknowledge
 >.CHCNV	Control-V##SYN##Synchronous
 >.CHCNW	Control-W##ETB##End of transmission block
 >.CHCNX	Control-X##CAN##Cancel
 >.CHCNY	Control-Y##EM###End of medium
 >.CHCNZ	Control-Z##SUB##Substitute
 >.CHESC	Control-_[##ESC##Escape
 >.CHCBS	Control-_\##FS###File separator
 >.CHCRB	Control-_]##GS###Group separator
 >.CHCCF	Control-_^##RS###Record separator
 >.CHCUN	Control-__##US###Unit Separator
.blank
 >.CHLPR	Left parenthesis, "_("
 >.CHRPR	Right parenthesis, "_)"
 >.CHLAB	Left angle bracket, "_<"
 >.CHRAB	Right angle bracket, "_>"
 >.CHLSB	Left square bracket, "_["
 >.CHRSB	Right square bracket, "_]"
 >.CHLCB	Left curly bracket, "_{"
 >.CHRCB	Right curly bracket, "_}"
.blank
 >.CHALT	Old Altmode
 >.CHAL2	Alternate old Altmode
 >.CHDEL	Delete
.page
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols for the Days of the Week
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Day
.blank
 >.DWSUN	Sunday
 >.DWMON	Monday
 >.DWTUE	Tuesday
 >.DWWED	Wednesday
 >.DWTHU	Thursday
 >.DWFRI	Friday
 >.DWSAT	Saturday
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols for the Times of the Day
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >TD%NON	The time is after noon
 >TD%EVE	The time is after evening, if >TD%NON is on
 >TD%NIT	The time is after night, if >TD%NON and >TD%EVE are on
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols for TOPS-20 users
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Descripton
.blank
 >%ICAVA	Available software interrupt channels
.page
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols for PC Flags
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >PC%OVF	Overflow
 >PC%PCB	Previous context public
 >PC%CY0	Carry 0
 >PC%CY1	Carry 1
 >PC%FOV	Floating overflow
 >PC%BIS	Byte increment suppression
 >PC%USR	User mode
 >PC%UIO	User IOT mode
 >PC%PCU	Previous context user
 >PC%LIP	Last instruction public
 >PC%AFI	Address failure inhibit
 >PC%ATN	APR trap number
 >PC%FUF	Floating underflow
 >PC%NDV	No divide
.page
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols for Hardware Data Types
.disable TOC
.header level 2 Symbols Related to Words
.blank.left margin 15.set paragraph -10,0,1.tab stops 15
 Symbol Description
.blank
 >WD%WRD	The whole word
 #>.WDWRD	The size of the word
 #>.WDINF	Plus infinity
 #>.WDMIN	Minus infinity
 >WD%LFT	The left half
 #>.WDLFT	The size of the left half
 >WD%RIT	The right half
 #>.WDRIT	The size of the right half
 #>.WDHLF	The size of a half word
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for Instruction Formats
.blank.left margin 15.set paragraph -10,0,1.tab stops 15
 Symbol	Description
.blank
 >IC%OPC	Operation code
 >IC%ACF	AC field
 >IC%ADR	The address field
 #>%ICIND	#Indirect bit
 #>%ICIDX	#Index field
 #>%ICYHF	#"Y" half
.blank
 >IC%IOP	I/O operation code
 >IC%IDV	I/O device code
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for Byte Pointer Format
.blank.left margin 15.set paragraph -10,0,1.tab stops 15
 Symbol	Descripton
.blank
 >BP%POS	Position of byte, "P" field
 >BP%SIZ	Size of the byte, "S" field
 >BP%ADR	The address field
 #>%BPIND	#Indirect bit
 #>%BPIDX	#Index field
 #>%BPYHF	#"Y" half
.page
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for Integer Number Format
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >IN%SGN	The sign
 >IN%NUM	The integer number
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for Floating-point Number Format
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >FN%SGN	The sign
 >FN%EXP	The exponent
 >FN%MAN	The mantissa
.page
.enable TOC
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols for CPUs
.disable TOC
.header level 2 Symbols for CPU types
.blank.left margin 15.set paragraph -9,0,1.tab stops 15
 #Type	CPU
.blank
 >.CTPDP6	PDP-6 CPU
 >.CTKA10	KA-10 CPU
 >.CTKI10	KI-10 CPU
 >.CTKL10	KL-10 CPU
 >.CTKS10	KS-10 CPU
 >.CTKC10	KC-10 CPU
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for Units of Memory Allocation
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	CPU
.blank
 >.SUAP6	1024 words on a PDP-6 CPU
 >.SUAKA	1024 words on a KA-10 CPU
 >.SUAKI	512 words on a KI-10 CPU
 >.SUAKL	512 words on a KL-10 CPU
 >.SUAKS	512 words on a KS-10 CPU
 >.SUAKC	512 words on a KC-10 CPU
.page
.enable TOC
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 1 Symbols Used by the EXTEND Instructions:
.disable TOC
.header level 2 Symbols for the Translation Flags
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >TF%SIG	Significant
 >TF%LEN	Length (CVTBDO and CVTBDT)
 >TF%NON	Non-zero
 >TF%MIN	Minus (negative)
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for the MOVST
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >.MOISB	If significant (S) is 1, take the substitute in
place of the source byte.
 >.MOTRM	Terminate the translation.
 >.MOICM	Clear minus (M), and if significant (S) is 1,
take the substitute in place of the source byte.
 >.MOISM	Set minus (M), and if significant (S) is 1,
take the substitute in place of the source byte.
 >.MOSSB	Set significant (S) and non-zero (N), and
take the subtitute in place of the source byte.
 >.MOTMN	Set non-zero (N) and terminate the translation.
 >.MOSCM	Set significant (S) and non-zero (N), clear minus
(M), and take the subtitute in place of the source byte.
 >.MOSSM	Set significant (S), non-zero (N) minus (M),
and take the subtitute in place of the source byte.
.page
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for CVTDBT
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Desciption
.blank
 >.COISD	If significant (S) is 1, substitute the table
for the byte.  If significant (S) is 0, ignore this byte and
go to the next.
 >.COTRM	Terminate the translation.
 >.COICM	Clear minus (M), and if significant (S) is 1,
substitute the table for the byte.  If significant (S) is 0,
ignore this byte and go to the next.
 >.COISM	Set minus (M), and if significant (S) is 1,
substitute the table for the byte.  If significant (S) is 0,
ignore this byte and go to the next.
 >.COSSD	Set significant (S) and non-zero (N), and
substitute the table digit for the byte.
 >.COTMN	Set non-zero (N) and terminate the translation.
 >.COSCM	Set significant (S) and non-zero (N), clear
minus (M), and substitute the table digit for the byte.
 >.COSSM	Set significant (S), non-zero (N) and minus
(M), and substitute the table digit for the byte.
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for EDIT
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >.EOISB	If significant (S) is 1, place the substitute
in the next position in the desination string space.  Otherwise
if location E0+1 is non-zero, place the fill character from it
in the next destination position.
 >.EOTRM	Increment the pattern pointer, and go on to
the next instruction.
 >.EOICM	Clear minus (M) and then perform function .EOISB.
 >.EOISM	Set minus (M) and then perform function .EOISB.
 >.EOSSB	Set non-zero (N).  If significant (S) is 1,
place the substitute in the next position in the desination
string space.  Otherwise do the following; set significant (S);
put the current value of the destination byte pointer at the
location specified by the mark address; if location E0+1 is
non-zero, put the float character from it in the next
destination position; then place the substitute in the next
destination position after that.
 >.EOTMN	Set non-zero (N), increment the pattern pointer,
and go on to the next instruction.
 >.EOSCM	Clear minus (M) and then perform function .EOSSB.
 >.EOSSM	Set minus (M) and then perform function .EOSSB.
.page
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.header level 2 Symbols for EDIT Pattern Commands
.blank.left margin 14.set paragraph -9,0,1.tab stops 14
 Symbol	Description
.blank
 >.EPSTP	Stop edit
 >.EPSEL	Select next source byte
 >.EPSIG	Start significance
 >.EPSEP	Separate field
 >.EPEXM	Exchange mark and desination pointers
 >.EPNOP	No-op
 >.EPMES	Insert message character
 >.EPSKM	Skip on M
 >.EPSKN	Skip on N
 >.EPSKP	Skip always
.enable TOC
.left margin 0.set paragraph 0,1,2.tab stops 8,16,24,32,40,48
.appendix A Sample Program
 The following is an example of a program which uses most of
the macros and their options.  In no way should this be
considered the only way to use these things, just an example.
This is not the entire program, just selected portions.
.page.nofill.nojustify

	$TOC	Dawn R. Banks  July 1981
.blank 2
; Required symbols and macros
.blank
	SEARCH	SYSUNV,IBMPRM,QSRMAC
.blank 2
; Assembly directives
.blank
	INTERN	DOTPOP			; For IBMLBL
.blank 2
; Required modules
.blank
	.REQUIRE DSK:IBMLBL		; For tape label calls
.blank 2
; Setup common stuff
.blank
	$BEGIN	EBUTIL -- General EBCDIC Tape Utility,EBU,1(3)-4,_^__
		_<TOPS10,SCAN,WILD,TYPER,HELPER_>
.page
	$TOC	Table of Contents
.blank 2
;		     	Table of Contents for EBUTIL
;
;				Section			   Page
;
;    1. Dawn R. Banks July 1981  . . . . . . . . . . . . .  A-2
;    2. Definitions
;      2.1    AC's . . . . . . . . . . . . . . . . . . . .  A-4
;      2.2    Macros . . . . . . . . . . . . . . . . . . .  A-5
;    3. Storage
;      3.1    LOWsegment . . . . . . . . . . . . . . . . .  A-8
;    4. Top Level
;      4.1    Initialization . . . . . . . . . . . . . . .  A-9
;      4.2    Main Loop  . . . . . . . . . . . . . . . . . A-10
;    5. Tape to Disk Routines
;      5.1    EBCOPY . . . . . . . . . . . . . . . . . . . A-11
;      5.2    EBCDON . . . . . . . . . . . . . . . . . . . A-13
;    6. Switch Processors
;      6.1    TABLST . . . . . . . . . . . . . . . . . . . A-14
;    7. Runtime Command Processor
;      7.1    Turn on PSI  . . . . . . . . . . . . . . . . A-15
;      7.2    Turn PSI Off . . . . . . . . . . . . . . . . A-16
;      7.3    TTY Interrupt  . . . . . . . . . . . . . . . A-17
;    8. Subroutines
;      8.1    Prompt Routine . . . . . . . . . . . . . . . A-18
;      8.2    PRTCHR - Put a Character . . . . . . . . . . A-19
;      8.3    DOTPOP - Perform a TAPOP.  . . . . . . . . . A-20
;      8.4    Handle $SWP Macro  . . . . . . . . . . . . . A-21
;    9. The End  . . . . . . . . . . . . . . . . . . . . . A-22
.page
	$TOC	Definitions -- AC's
.blank 2
; AC definitions
.blank
				; These AC definitions
				;  are SCAN compatible
.blank
     F=0			; Flag AC
.blank
				; AC's T1-T4, P1-P4, C, N and
				;  P are defined by $BEGIN
.blank
    M1=11			; Marginal AC's
    M2=12			;  (may or may
    M3=13			;  NOT be
    M4=14			;  saved)
.blank
   LVL=15			; Output message level
.page
	$TOC	Definitions -- Macros
.blank 2
; Macro to perform a TAPOP. function
.blank
DEFINE	$TAPOP [SALL] ($FUN,$VAL),_<
	PUSHJ	P,@[BYTE (12) $FUN (6) 0 (18) %TAPOP
		    $VAL]
_>				; End of 'DEFINE $TAPOP'
.blank 2
; Macro to perform a GETTAB function
.blank
DEFINE	$GETAB [SALL] ($FNC,$LOC),_<
	PUSHJ	P,@[%GETAB	;; Call the GETTAB routine
		    $FNC	;; The fuction to process
		    $LOC]	;; Where to place the result
_>				; End of 'DEFINE $GETAB'
.page
; Macro to save some locations
.blank
DEFINE	$SAV [SALL] ($LST),_<
	PUSHJ	P,[
IRP	$LST,_<	   PUSH	P,$LST	;; Save the location
		   $SWPN -1(P),(P)_>;; Swap it with the return
		   POPJ	P,]	;; Return
_>				; End of 'DEFINE $SAV'
.blank 2
; Macro to restore some locations saved by $SAV
.blank
DEFINE	$RST [SALL] ($LST),_<
	PUSHJ	P,[
IRP	$LST,_<	   $SWPN -1(P),(P);; Swap with return
		   POP	P,$LST_>	;; Restore the location
		   POPJ P,]	;; Return
_>				; End of 'DEFINE $RST'
.page
; Macro to swap the contents of two memory locations
; * Note * This instruction cannot be SKIP'ed around
.blank
DEFINE	$SWPN [SALL] ($ADR1,$ADR2),_<
	EXCH	T1,$ADR1	;; Exchange
	EXCH	T1,$ADR2	;;  the two
	EXCH	T1,$ADR1	;;  locations
_>				; End of 'DEFINE $SWPN'
.blank 2
; Macro to swap the contents of n pairs of memory locations.
; * Note * This macro can be SKIP'ed, but is very slow.

DEFINE	$SWP [SALL] ($LST),_<
	PUSHJ	P,@[%SWP	;; Call the swap routine
IRP	$LST,_<
		    $SWP1 $LST_>	;; Insert the two locations
		     0]		;; Nothing left to swap
_>				; End of 'DEFINE SWP'
.blank 2
DEFINE	$SWP1 [SALL] ($LST),_<$SWP2 ($LST)_>
.blank 2
DEFINE	$SWP2 [SALL] ($VAR1,$VAR2),_<
		    _<EXP 1B0+$VAR1_>;; The first location
		    _<EXP     $VAR2_>;; The second location
_>				; End of 'DEFINE SWP1'
.page
	$TOC	Storage -- LOWsegment
.blank 2
	$LOW			; Relocate to low segment
.blank
PDL:	BLOCK	PDLSIZ		; Push down stack
OFFSET:	BLOCK	1		; Starting offset
.blank
CHRBAS:	$TYPED	_<_<OUT,PRTCHR_>_>	; The default database
.page
	$TOC	Top Level -- Initialization
.blank 2
	$HIGH				; Set to high segment
.blank
EBUTIL::TDZA	T1,T1			; No starting offset
	MOVEI	T1,1			; CCL entry
	MOVEM	T1,OFFSET		; Save starting offset
	RESET				; All I/O
	STORE	17,0,17,0		; Zero the AC's
	MOVE	P,[IOWD PDLSIZ,PDL]	; Setup the PDP
	STORE	T1,BZ$INI,EZ$INI,0	; Zero the low segment
.blank
;     Here  with  the  basic  info  setup,  now  initialize  the
; scanner and the typeout routines.
.blank
	MOVE	T1,ISCNPT		; Get the ISCAN pointer
	PUSHJ	P,.ISCAN_#_#		; Go initialize SCAN
.blank
	MOVE	T1,[TP.PFX,,CHRBAS]	; Initialize the
	$TYPES	INI			;  TYPER system
.blank
	MOVEI	T1,AD.LOG		; Store the default
	MOVEM	T1,LOGLVL		;  LOG-level
	MOVEI	T1,AD.MSG		; Store the default
	MOVEM	T1,MSGLVL		;  MSG-level
.page
	$TOC	Top Level -- Main Loop
.blank 2
MAIN:	PUSH	P,.JBFF_#_#	; Save free core pointer
	PUSHJ	P,CLRANS	; Go reset low segment
	TXZ	F,F$CLR		; Clear per command bits
.blank
	MOVE	T1,TSCNPT	; Get .TSCAN pointer
	PUSHJ	P,.TSCAN_#_#	; Go call the scanner
	MOVE	T1,OSCNPT	; Get the .OSCAN pointer
	PUSHJ	P,.OSCAN_#_#	;  and read SWITCH.INI
.page
	$TOC	Tape to Disk Routines -- EBCOPY
.blank 2
; Here to read a tape.
.blank
EBCOPY:	TXNE	F,F.WRT		; Reading tape?
	$TYPES	BUG		; No, should never get here
	MOVEI	T1,MSGNON	; Set global
	$TYPES	MSG		;  message level
	PUSHJ	P,PSI%ON	; Go turn on the PSI system
	 SKIPA			; Can't, skip prompt
	PUSHJ	P,DOPRMT	; Give a prompt
.blank
	PFALL	EBCLOP		; Fall into the main loop
.page
; Open the disk channel
.blank
	MOVEI	T1,.IODMP		; Get dump mode I/O
	IORM	T1,OPNDSK+.OPMOD	; Store
	SETZM	OPNDSK+.OPBUF		; No buffers
	MOVE	T1,OPNDSK+.OPDEV	; Get the device name
	OPEN	DSK,OPNDSK		; Get the disk
	 $ERROR	(F,EOO,$SIX,_<Error opening output device |:_>,,ABORTF)
.blank
; Go create the file on disk
.blank
	MOVEI	T1,.RBTIM		; Get size of ENTER
	MOVEM	T1,DSKBLK+.RBCNT	; Store it
	ENTER	DSK,DSKBLK		; Go create the file
	 JRST	[HRRZ T2,DSKBLK+.RBEXT	 ; Error, get code
		 MOVE T1,[-2,,[$OCT T2	 ;  and pointers
			       $ENT [OPNDSK,,DSKBLK]]]
		 $ERROR	(F,ECF,$IND,_<Enter error | creating |_>,,ABORTF)]
.page
	$TOC	Tape to Disk Routines -- EBCDON
.blank 2
; Here at the end of command
.blank
EBCDON:	PUSHJ	P,PSI%OF	; Turn off PSI
	$TYPE	(N,,,,,P1)	; Give a blank line
				;  and a skip return
.page
	$TOC	Switch Processors -- TABLST
.blank 2
;     Here from SCAN on a /TABLE switch to list the  translation
; table parameters.
.blank
; Calling sequence:
;	PUSHJ	P,TABLST
;	 non-skip return - never returns here
;	skip return - always returns here
.blank
; Uses AC's T1-4 and M1-3
.blank
TABLST:	SKIPN	TABNAM			; Is there one?
	 $TYPE	(I,NTL,$NON,_<No Table Loaded_>,,P1)
.blank
	MOVE	T1,[-4,,[$SIX TABNAM	 ; Table name
			 $PPN TABPPN	 ; PPn of modifier
			 $NAM [TABNM1]	 ; Name of modifier
			 $UNV TABDAT]]	 ; Date of creation
	$TYPE	(I,TBL,$IND,_<Using table | from | (|), created |_>)
.blank
	SKIPE	TABTXT			; Any text?
	$TYPE	(I,TBD,$ASC,_<Description:
|_>,,,,[TABTXT])
.blank
	SKIPN	TABCHG			; Any changes?
	$TYPE	(I,NCT,$NON,_<No changes to standard table_>,,P1)
.blank
	$TYPE	(N,,$NON,_<Alterations to standard table:
EBCDIC	was	is	(Was and is are octal of ASCII)_>)
	MOVE	T4,[-100,,TABCHG]	; Get AOBJN pointer
.blank
TABL01:	SKIPN	T2,(T4)			; Get an entry
	$TYPE	(N,,$NON,,,P1)		; Give blank line at end
	LDB	M1,[POINT 8,T2,7]	; Get Hex number
	LDB	M2,[POINT 9,T2,16]	; Get was
	LDB	M3,[POINT 9,T2,25]	; Get is
	MOVE	T1,[-3,,[$HEX M1	 ; EBCDIC
			 $OCT M2	 ; Was
			 $OCT M3]]	 ; Is
	$TYPE	(N,,$IND,_<|	|	|_>)
	AOBJN	T4,TABL01		; Loop for all

	$TYPE	(N,,$NON,,,P1)		; Give blank line at end
.page
	$TOC	Runtime Command Processor -- Turn on PSI
.blank 2
;     Here from top level  to  enable  the  Programmed  Software
; Interrupt  system  to  give interrupts when a line of input is
; typed by the user.
.blank
; Calling sequence:
;	PUSHJ	P,PSI%ON
;	 non-skip return - interrupts can't be enabled for TTY
;	skip return - interrupts are enabled on the TTY
.blank
; Uses AC's T1-4
.blank
PSI%ON:	TXZ	F,F.PSI			; Don't assume anything
	MOVEI	T1,TTYSER		; Trap address
	MOVEM	T1,PSIVCT+.PSVNP	; Put it in the block
	MOVX	T1,PS.VTO		; Disable with DEBRK. UUO
	MOVEM	T1,PSIVCT+.PSVFL	; Store in flags
	MOVEI	T1,PSIVCT		; Get the addr
	PIINI.	T1,			; Initialize PSI
	 $ERROR	(W,PUF,$NON,_<Cannot enable for TTY_>,,P)
	MOVX	T1,PS.FON!PS.FAC	; Turn on+add condition
	HRRI	T1,T2			; Get address of args
	MOVSI	T2,'TTY'		; Get device name
	MOVX	T3,PS.RID		; Interrupt input done
	SETZ	T4,			; No priority
	PISYS.	T1,			; Turn it on
	 $ERROR	(N,PUF)			; Error
	SETZ	T1,			; Insure proper prompt
	TXO	F,F.PSI			; Success!!
	JRST	.POPJ1_#_#		; Return
.page
	$TOC	Runtime Command Processor -- Turn PSI Off
.blank 2
;      Here from the top level to disable PSI interrupts.
.blank
; Calling sequence:
;	PUSHJ	P,PSI%OF
.blank
; Uses no AC's
.blank
PSI%OF:	TXZN	F,F.PSI			; PSI on?
	POPJ	P,			; No, just return here
	PUSHJ	P,.SAVE1_#_#		; Save P1
	MOVX	P1,PS.FOF		; Get turn off bit
	PISYS.	P1,			; Do it
	 $ERROR	(W,CRT,$NON,_<Cannot remove TTY from interrupt_>)
	POPJ	P,			; Restore P1 and return
.page
	$TOC	Runtime Command Processor -- TTY Interrupt
.blank 2
;     Here  on  a  PSI interrupt.  Stacks all AC's and calls the
; runtime command processor.
.blank
;     Called  when  a line of input ready on the user's console,
; returns with DEBRK. UUO.
.blank
;     Preserves  all AC's except P, which is left pointer at the
; same thing  on  the  stack  when  this  routine  returns  from
; interrupt.
.blank
TTYSER:	$VARIA	(INTERRUPT)		; Save the ACs
.blank
	MOVX	P1,_<.TFUSE,,TTYBAS_>	; Set the address
	$TYPES	BAS,,,P1		;  of the database
.blank
	TXNE	F,F.LOG			; Logging?
	$TYPE	(N,,,,,,LOGBAS)		; Yes, force a free CRLF
	PUSHJ	P,RUNCOM		; Go do some commands
	TXNE	F,F.LOG			; Logging?
	$TYPE	(N,,,,,,LOGBAS)		; Yes, force a free CRLF
.blank
	$TYPES	BAS,P,,P1		; Reset the database and
					;  return from interrupt
.page
	$TOC	Subroutines -- Prompt Routine
.blank 2
;     Routine  to  type a prompt on the user console.  Called by
; SCAN or runtime command processor.  Prompts are  of  the  form
; "EBUc ", where  "c" is one of: "_>" if top level prompt, "!" if
; running,  "/"  if  stopped  during  a  command,  or   "_#"   if
; continuation in any above case.
.blank
; Calling sequence:
;	PUSHJ	P,DOPRMT
;	return - always returns here
.blank
; Uses AC T1
.blank
DOPRMT:	TXNE	F,F.RUN			; Doing a command now?
	JRST	DOPR02			; Yes, other chars
	TLZE	T1,-1			; Continuation?
.blank
DOPR01:	SKIPA	T1,["_#"]		; Yes, inform the user
	MOVEI	T1,"_>"			; No, output a carrot
	$TYPES	PRM,P			; Go type ASCII string
.blank
DOPR02:	TLZE	T1,-1			; Continuation?
	JRST	DOPR01			; Yes, go do it
	TXNE	F,F.STOP		; Stopped?
	SKIPA	T1,["/"]		; Yes, say so
	MOVEI	T1,"!"			; No, say running
	$TYPES	PRM,P			; Give prompt and return
.page
	$TOC	Subroutines -- PRTCHR - Put a Character
.blank 2
;   Here from TYPER with char in T1, _<LH_> non-zero if time stamp
; character.  Compare  LVL  to  MSGLVL  and  LOGLVL to see if we
; really want to print this.
.blank
; Calling sequence:
;	MOVE	T1,character, _<LH_> non-zero if time-stamp
;	PUSHJ	P,PRTCHR
;	return - always returns here
.blank
; Uses no AC's
.blank
PRTCHR:	JUMPL	T1,PRTCH1		; Time stamp character?
	CAML	LVL,MSGLVL		; No, MSGLVL low enough
	OUTCHR	T1			; Yes, output the TTY
.blank
PRTCH1:	TXNE	F,F.LOG			; Log file open?
	CAMGE	LVL,LOGLVL		; Yes, LOGLVL low enough
	POPJ	P,			; No, just return
	PJRST	LOGOUT			; Output to the LOG file
.page
	$TOC	Subroutines -- DOTPOP - Perform a TAPOP.
.blank 2
;      Here to perform an internal $TAPOP macro call.
.blank
; Calling sequence:
;	PUSHJ	P,@[BYTE (12) function, (6) 0, (18) %TAPOP
;		    value]
;	return - returns the value of the TAPOP. in T1, aborts
;                the job if fatal error occurs
.blank
; Uses AC T1
.blank
%TAPOP:	$VARIA	(ENTRY,,TAPCAL,TAPREG)	; Set some stuff up
.blank
	LDB	T2,[POINT 12,0(P1),11]	; Get the function code
	MOVEM	T2,TOPBLK+0		; Store in the block
	MOVE	T1,1(P1)		; Get the value
	TLNE	T1,37			; Skip if immediate
	PUSHJ	P,.LOCAT_#_#		; Get effective addr
	MOVEM	T1,TOPBLK+2		; Store in the block
	PUSHJ	P,DOTP01		; Enter the routine
	 PJRST	ERTPOP			; Error, issue message
	MOVEM	T1,T1-1+TAPREG		; Store result in T1
	POPJ	P,			; Return
.page
	$TOC	Subroutines -- Handle $SWP Macro
.blank 2
;     Routine  to  swap  the  contents  of  n  pairs  of  memory
; locations without destroying anything
.blank
; Calling sequence:
;	PUSHJ	P,@[%SWP
;		    addr1		; Swap with:
;		    addr2
;		    addr1
;		    addr2
;		       etc.		; Indefinite number
;		    0]			; To terminate the list
;	return - always returns here
.blank
; Uses no AC's
.blank
%SWP:	$VARIA	(ENTRY,,SWPCAL,SWPREG)	; Save the regs
	MOVEI	T3,1(P1)		; Point to first addr
.blank
%SWP01:	SKIPN	T1,(T3)			; Get the first addr
	POPJ	P,			; Zero, done
	PUSHJ	P,.LOCAT_#_#		; Get the effective addr
	MOVE	T4,T1			; Put it in T4
	MOVE	T1,1(T3)		; Get the second addr
	PUSHJ	P,.LOCAT_#_#		; Get the effective addr
	EXCH	T2,(P1)			; Get contents of second
	EXCH	T2,(T4)			; EXCH with first loc
	EXCH	T2,(P1)			; Finish off
	ADDI	T3,2			; Point to next pair
	JRST	%SWP01			; Loop for all pairs
.page
	$TOC	The End
.blank 2
	$END	EBUTIL			; End of 'EBUTIL'
.break
.number
.appendix The SYSUNV Error Messages
 The following is a list of all of the error messages that will
be output by the SYSUNV macros.  A brief description of the
error message is also included.
.blank 2.test page 5
?SYSADN PFALL - The address specified is not the next address
 The label of the next instruction wasn't the same as the label
specified in the call to the PFALL macro.
.blank 2.test page 5
?SYSAIM $DSBEG - An illegal maximum specified ($PFX, $MAX)
 The maximum specified is either negative or zero.
.blank 2.test page 5
?SYSAIP $DSBEG - An illegal prefix ($PFX)
 The prefix specified contains more that 2 characters.
.blank 2.test page 5
?SYSAIP $DSEND - An illegal prefix ($DSBEG=$PFX, $DSEND=$SFX)
 The prefix specified wasn't the same as the prefix specified
to the previous $DSBEG.
.blank 2.test page 5
?SYSAND $ERROR - The ACs are not defined correctly
 Register P must equal 17.
.blank 2.test page 5
?SYSAND $FRAME - The ACs are not defined correctly
 The registers must be defined as follows:  T1 must be greater
than or equal to 1 and less than or equal to 7, T1, T2, T3 and
T4 must be in ascending order and P must equal 17.
.blank 2.test page 5
?SYSAND $LOCATE - The ACs are not defined correctly
 The registers must be defined as follows:  T1 must be greater
than or equal to 1 and less than or equal to 7, T1, T2, T3 and
T4 must be in ascending order and P must equal 17.
.blank 2.test page 5
?SYSAND $PARAMETER - The ACs are not defined correctly
 The registers must be defined as follows:  T1 must be greater
than or equal to 1 and less than or equal to 7, T1, T2, T3 and
T4 must be in ascending order and P must equal 17.
.blank 2.test page 5
?SYSAND $TYPE - The ACs are not defined correctly
 Register P must equal 17.
.blank 2.test page 5
?SYSAND $TYPES - The ACs are not defined correctly
 Register P must equal 17.
.blank 2.test page 5
?SYSAND $VARIABLE - The ACs are not defined correctly
 Register P must equal 17.
.blank 2.test page 5
?SYSAUD $ERROR - An undefined database ($BAS)
 The the database given wasn't one of the defined defined
database types.  The database types are:  D, C and E.
.blank 2.test page 5
?SYSAUD $TYPE - An undefined database ($BAS)
 The the database given wasn't one of the defined defined
base types.  The database types are:  D, C and E.
.blank 2.test page 5
?SYSAUC $NUMBER - An undefined case ($EX1)
 The case given wasn't one of the defined case types.  The
case types are:  LOWER and UPPER.
.blank 2.test page 5
?SYSAUF $BITS - An undefined function ($FNC)
 The function given wasn't one of the defined function types.
The function types are:  AND, COMMA, CRLF, EXCLAIM, FIELD,
NONE, OR, PLUS and USER.
.blank 2.test page 5
?SYSAUF $NUMBER - An undefined fill ($EX3)
 The fill given wasn't one of the defined fill types.  The
fill types are: BLANK, ZERO and DOLLAR, or any single
character.
.blank 2.test page 5
?SYSAUF $NUMBER - An undefined fraction ($EX2)
 The number of fractional digits wanted must be greater than
or equal 0 and less than or equal 56, or equal to the keyword
INTEGER (floating-point only).
.blank 2.test page 5
?SYSAUF $TYPES - An undefined function ($FNC)
 The function given wasn't one of the defined function codes.
The function codes are:  BAS, BUG, COL, DMP, EMP, ERR, INI,
JST, LOC, MSG, PIC, PRM, RTN, SYS, TIM, VRB and ZON.
.blank 2.test page 5
?SYSAUH $ERROR - An undefined header ($HDR)
 The header given wasn't one of the defined header types.  The
header types are:  B, C, F, I, M, N, O, T and W.
.blank 2.test page 5
?SYSAUH $PRINT - An undefined header ($HDR)
 The header given wasn't one of the defined header types.  The
header types are:  F, I, O and W.
.blank 2.test page 5
?SYSAUH $TYPE - An undefined header ($HDR)
 The header given wasn't one of the defined header types.  The
header types are:  B, C, F, I, M, N, O, T and W.
.blank 2.test page 5
?SYSAUL $ERROR - An undefined list ($LST)
 The substitution parameter list has an error.
.blank 2.test page 5
?SYSAUL $LIT - An undefined list option ($LST)
 The list option given wasn't one of the defined list options.
The list options are:  LIST and NOLIST.
.blank 2.test page 5
?SYSAUL $RELOCATION - An undefined literal option ($LIT)
 The option given wasn't one of the defined literal options.
The literal options are:  LIT and NOLIT.
.blank 2.test page 5
?SYSAUL $TYPE - An undefined list ($LST)
 The substitution parameter list has an error.
.blank 2.test page 5
?SYSAUL $VAR - An undefined list option ($LST)
 The list option given wasn't one of the defined list options.
The list options are:  LIST and NOLIST.
.blank 2.test page 5
?SYSAUM $ERROR - An undefined message level ($MSG)
 The message level type is either D, C, or value less than
1000.
.blank 2.test page 5
?SYSAUM $TYPE - An undefined message level ($MSG)
 The message level type is either D, C, or value less than
1000.
.blank 2.test page 5
?SYSAUN $NUMBER - An undefined notation ($NOT)
 The notation given wasn't one of the defined notation types.
The notation types are:  NORMAL/SCIENTIFIC (FLOAT),
SIGNED/UNSIGNED (INTEGER) or ALPHA/ENGLISH/PICTURE/ROMAN
(SPECIAL).
.blank 2.test page 5
?SYSAUN $NUMBER - An undefined number type ($EX2)
 The number type given wasn't one of the defined number types.
The number types are:  CARDINAL and ORDINAL.
.blank 2.test page 5
?SYSAUP $NUMBER - An undefined pointer ($EX2)
 The pointer type given wasn't one of the defined pointer
types.  The pointer types are:  LITERAL and POINTER.
.blank 2.test page 5
?SYSAUR $ERROR - An undefined return ($RET)
 The return given wasn't one of the defined return types.  The
return types are:  A, C, D, E, I, M, N, N1, P, P1 and S.
.blank 2.test page 5
?SYSAUR $NUMBER - An undefined radix ($EX2)
 The radix wanted must between 2 and 36 inclusive, or equal to
one of the key words (DEC, HEX or OCT).
.blank 2.test page 5
?SYSAUR $TYPE - An undefined return ($RET)
 The return given wasn't one of the defined return types.  The
return types are:  A, C, D, E, I, M, N, N1, P, P1 and S.
.blank 2.test page 5
?SYSAUR $TYPES - An undefined return ($RET)
 The return given wasn't one of the defined return types.  The
return types are:  A, C, D, E, I, M, N, N1, P, P1 and S.
.blank 2.test page 5
?SYSAUS $ERROR - An undefined substitution ($SUB)
 The substitution given wasn't one of the defined substitution
types.  The substitution types are:  $ASC, $BIT, $BLK, $CHR,
$CON, $COR, $DAT, $DAY, $DEC, $DIR, $DTL, $ELS, $ENT, $EOS,
$ERR, $ERS, $FUL, $FUN, $HEX, $JFN, $IND, $LFT, $LIN, $LKP,
$NAM, $NON, $NUM, $OCT, $OPC, $PFX, $PPN, $PRO, $PTH, $R50,
$RUN, $SCN, $SIX, $SKP, $SPC, $SUB, $TIM, $TML, $UNV, $UR1,
$UR2, $UR3, $UR4, $UR5, $UR6, $UR7, $USR, $VER, $XCT and
$XWD.
.blank 2.test page 5
?SYSAUS $ERROR - An undefined suffix ($SFX)
 The suffix wasn't defined.
.blank 2.test page 5
?SYSAUS $LIT - An undefined segment option ($SEG)
 The segment option given wasn't one of the defined segment
options.
The segment options are:  LOW and HIGH.
.blank 2.test page 5
?SYSAUS $NUMBER - An undefined save ($EX3)
 The save option given wasn't one of the defined save options.
The save options are:  NOSAVE and SAVE.
.blank 2.test page 5
?SYSAUS $RELOCATION - An undefined segment option ($SEG)
 The option given wasn't one of the defined segment options.
The segment options are:  ONE, TWO and MANY.
.blank 2.test page 5
?SYSAUS $TYPE - An undefined substitution ($SUB)
 The substitution given wasn't one of the defined substitution
types.  The substitution types are:  $ASC, $BIT, $BLK, $CHR,
$CON, $COR, $DAT, $DAY, $DEC, $DIR, $DTL, $ELS, $ENT, $EOS,
$ERR, $ERS, $FUL, $FUN, $HEX, $JFN, $IND, $LFT, $LIN, $LKP,
$NAM, $NON, $NUM, $OCT, $OPC, $PFX, $PPN, $PRO, $PTH, $R50,
$RUN, $SCN, $SIX, $SKP, $SPC, $SUB, $TIM, $TML, $UNV, $UR1,
$UR2, $UR3, $UR4, $UR5, $UR6, $UR7, $USR, $VER, $XCT and
$XWD.
.blank 2.test page 5
?SYSAUS $TYPE - An undefined suffix ($SFX)
 The suffix wasn't defined.
.blank 2.test page 5
?SYSAUS $VAR - An undefined segment option ($SEG)
 The segment option given wasn't one of the defined segment
options.  The segment options are:  LOW and HIGH.
.blank 2.test page 5
?SYSAUT $ERROR - An undefined trailer ($TRL)
 The type given wasn't one of the defined trailer types.
The trailer types are:  C and N.
.blank 2.test page 5
?SYSAUT $NUMBER - An undefined type ($TYP)
 The type given wasn't one of the defined types.  The types
are:  FLOAT, INTEGER and SPECIAL.
.blank 2.test page 5
?SYSAUT $TYPE - An undefined trailer ($TRL)
 The type given wasn't one of the defined trailer types.
The trailer types are:  C and N.
.blank 2.test page 5
?SYSAUT $VARIABLE - An undefined type ($TYP)
 The type given wasn't one of the defined types.  The types
are:  ENTRY, GLOBAL, INTERRUPT, LOCAL and SAVE.
.blank 2.test page 5
?SYSAUW $NUMBER - An undefined width ($EX1)
 The number of integeral digits wanted must be greater than
or equal 0 and less than or equal 125, or the keyword FREE
(floating-point only).
.blank 2.test page 5
?SYSBAR $BITS - Bits are required ($BIT)
 The $BIT parameter must be supplied to the $BITS macro.
.blank 2.test page 5
?SYSCNF $BITS - Conflicting flags ($FLG)
 The flags given conflict (i.e. SIXBIT and ASCII were both
given).
.blank 2.test page 5
?SYSIBV $DSBEG - Illegal beginning value ($PFX, $BEG)
 The beginning value specified was negative.
.blank 2.test page 5
?SYSIDN $DSBEG - Illegal data name ($PFX, $SYM)
 The data name specified for ALIGN or APPEND was invalid or
undefined, this symbol must be defined in a previous data
structure.
.blank 2.test page 5
?SYSIDN $MOVE - Illegal data name ($FLG)
 The data name specified was invalid or undefined, this symbol
must be defined in a previous data structure.
.blank 2.test page 5
?SYSIDN $MOVEM - Illegal data name ($FLG)
 The data name specified was invalid or undefined, this symbol
must be defined in a previous data structure.
.blank 2.test page 5
?SYSIFB $DSBIT - Illegal flag bit ($PFX, $SFX, $VAL)
 The flag bit specified was negative.
.blank 2.test page 2
?SYSIFV $DSVAL - Illegal flag value ($PFX, $SFX, $VAL)
 The flag value specified was negative.
.blank 2.test page 2
?SYSIMG $DSFLG - Illegal mask given ($PFX, $MSK)
 The mask specified was null.
.blank 2.test page 5
?SYSIMS $VARIABLE - Too much stack space is being used
 The variable space can't exceed 8191 words.
.blank 2.test page 5
?SYSIND $NUMBER - Incorrect number of data words ($ADR)
 The number data word(s) doesn't match the data type given.
.blank 2.test page 5
?SYSINW $DSWRD - Illegal number of words to skip ($PFX, $SFX, $SIZ)
 The number of words to skip must be a positive value.
.blank 2.test page 5
?SYSIUA $ERROR - Illegal use of the arguments
 There is a conflict between header type and the suffix.
.blank 2.test page 5
?SYSIUA $TYPE - Illegal use of the arguments
 There is a conflict between header type and the suffix.
.blank 2.test page 5
?SYSIUS $TITLE - Illegal or undefined version symbol
 One or more of the version number symbols is undefined or
out of range.
.blank 2.test page 5
?SYSIVN $VRSN - Illegal version number or character
 One or more of the version number symbols is out of range
or an illegal character was input.
.blank 2.test page 5
?SYSIVS $VARIABLE - Illegal variable size ($SIZ)
 A variable, specified to the $VARIABLE macro, has requested
a size (length) a less than or equal to zero.
.blank 2.test page 5
?SYSIWS $DSFLG - Illegal width specified ($PFX, $SFX, $WID)
 The width specified must be a positive value or one of the
defined width types.  The width types are:  ADDRESS, DOUBLE,
LEFT, HALF, REDEFINE, RIGHT and WORD.
.blank 2.test page 5
?SYSIWS $FLAG - Illegal width specified ($WID)
 The mask width wanted must be greater than 0 and less than
or equal to number of bits left in the word.
.blank 2.test page 5
?SYSLVA $VARIABLE - Local variables don't have any saved ACs
 The $REG argument can't be supplied when the $VARIABLE macro
is used to define local variables, because there aren't any
ACs saved on the stack.
.blank 2.test page 5
?SYSMAR $BITS - Messages are required ($MSG)
 The $MSG parameter must be supplied to the $BITS macro.
.blank 2.test page 5
?SYSMDF $BITS - Multiply defined flag ($FLG)
 The same flag has been defined more than once.
.blank 2.test page 5
?SYSMDM $FRAME - Muliply defined monitor type
 The monitor type can NOT be defaulted because both DEBRK. and
DEBRK% are defined.
.blank 2.test page 5
?SYSMDS $ERROR - Multiply defined suffix ($SFX)
 The same suffix is used in more that one $ERROR or $TYPE call.
.blank 2.test page 5
?SYSMDS $TYPE - Multiply defined suffix ($SFX)
 The same suffix is used in more that one $ERROR or $TYPE call.
.blank 2.test page 5
?SYSMIR $BITS - Mask is required ($MSK)
 The $MSK parameter must be supplied to the $BITS macro.
.blank 2.test page 5
?SYSMUF $BEGIN - Multiply used flags ($FLG)
 The same or conflicting flags have been used in the $BEGIN
macro.
.blank 2.test page 5
[SYSMWC $DSBEG - The $DSEND macro wasn't called ($PFX)]
 The $DSEND macro was called for the previously defined data
structure.
.blank 2.test page 5
?SYSNOU $BITS - NUMBER can only be used with non-FIELD
 The NUMBER flag can only be supplied when the function isn't
FIELD.
.blank 2.test page 5
?SYSNPD $DSBEG - No previous data structure defined ($PFX)
 The request to ALIGN or APPEND to the previous data structure
is invalid, because no previous data structure has been defined.
.blank 2.test page 5
?SYSNPG $NUMBER - No picture given ($EX1)
 A pointer to the picture or the literal picture text must be
supplied.
.blank 2.test page 5
?SYSNPM $DSFLG - No previous mask available ($PFX, $SFX)
 There isn't a previous mask available to redefine.
.blank 2.test page 5
?SYSNSS $SECTION - Not setup for sections
 The $RELOCATION macro wasn't called with MANY for the first
argument.
.blank 2.test page 5
?SYSOOU $BITS - OCTAL can only be used with FIELD
 The OCTAL flag can only be supplied when the function is FIELD.
.blank 2.test page 5
?SYSRCO $RELOCATION - $RELOCATION can only be called once
 The $RELOCATION macro can only be called once.
.blank 2.test page 5
?SYSRHN $ABS - $RELOCATION has not been called
 The $RELOCATION macro must be called before any of the other
relocation macros are called.
.blank 2.test page 5
?SYSRHN $HIGH - $RELOCATION has not been called
 The $RELOCATION macro must be called before any of the other
relocation macros are called.
.blank 2.test page 5
?SYSRHN $LIT - $RELOCATION has not been called
 The $RELOCATION macro must be called before any of the other
relocation macros are called.
.blank 2.test page 5
?SYSRHN $LOW - $RELOCATION has not been called
 The $RELOCATION macro must be called before any of the other
relocation macros are called.
.blank 2.test page 5
?SYSRHN $SECTION - $RELOCATION has not been called
 The $RELOCATION macro must be called before any of the other
relocation macros are called.
.blank 2.test page 5
?SYSRHN $VAR - $RELOCATION has not been called
 The $RELOCATION macro must be called before any of the other
relocation macros are called.
.blank 2.test page 5
?SYSTMB $DSBIT - Too many bits defined ($PFX, $SFX, $VAL)
 More bits have been defined that will fit into the mask
specified in the previous $DSFLG call.
.blank 2.test page 5
?SYSTMF $FLAG - Too many flags defined ($PFX'$FLG)
 More mask bits have been defined that will fit in the given
mask/word.
.blank 2.test page 5
?SYSTMV $DSVAL - Too many values defined ($PFX, $SFX, $VAL)
 More values have been defined that will fit into the mask
specified in the previous $DSFLG call.
.blank 2.test page 5
?SYSTMV $VALUE - Too many values defined ($PFX'$FLG)
 More values have been defined that will fit in the given mask.
.blank 2.test page 5
?SYSTMW $DSBEG - Too many words used ($PFX)
 More words have been defined that will fit in the data
structure, the maximum should be increased.
.blank 2.test page 5
?SYSTMW $DSNXT - Too many words used ($PFX)
 More words have been defined that will fit in the data
structure, the maximum should be increased.
.blank 2.test page 5
?SYSTMW $DSWRD - Too many words used ($PFX, $SFX)
 More words have been defined that will fit in the data
structure, the maximum should be increased.
.blank 2.test page 5
?SYSUCO $FRAME - An undefined CPU option ($CPU)
 The option given wasn't one of the defined CPU options.
The CPU options are:  PDP6, KA10, KI10, KL10, KL20, KS10
and KS20.
.blank 2.test page 5
?SYSUDP $NUMBER - An undefined data-pointer ($DPT)
 The data-pointer given wasn't one of the defined
data-pointer types.  The data-pointer types are:  ADDRESS,
IMMEDIATE, INDIRECT and POINTER.
.blank 2.test page 5
?SYSUDT $NUMBER - An undefined data-type ($DTP)
 The data-type given wasn't one of the defined data-types.
The data-types are: BYTE, DOUBLE, LEFT, RIGHT and SINGLE.
.blank 2.test page 5
?SYSUMR $BITS - User separator or maximum is required
 The $XTR parameter is required when the function type is
FIELD or USER.
.blank 2.test page 5
?SYSUMT $FRAME - Undefined monitor type ($MON)
 The option given wasn't one of the defined monitor options.
The monitor options are:  TOPS-10 and TOPS20.
.blank 2.test page 5
?SYSUNS $DSFLG  Undefined symbol ($PFX'.'$RED)
 The symbol to reset the data structure back to is undefined.
.blank 2.test page 5
?SYSVDT $VARIABLE - Variable is defined twice ($VAR)
 A variable name has been used more than once.
.blank 2.test page 5
?SYSXNA MOVX - $REG is not an accumulator
 The $REG parameter isn't a register (0-17).
.blank 2.test page 5
?SYSXNA TX'$TST - $REG is not an accumulator
 The $REG parameter isn't a register (0-17).
.blank 2.test page 5
?SYSXUF $BITS - EXTRA can only be used with FIELD and USER
 The EXTRA flag can only be supplied when the function is
FIELD or USER.
.appendix The TYPER System Messages
 The following is a list of all of the messages that will be
output by the TYPER system.  This list contains only the
runtime system messages.  A brief description of each message
is also included.
.blank 2.test page 5
?FRMDIU DEBRK. is unimplemented
 A $VARIABLE call was requested to return from an interrupt
and the DEBRK. UUO is unsupported or unimplemented in the
monitor.
.blank 2.test page 5
?FRMNIP No interrupt in progress
 A $VARIABLE call was requested to return from an interrupt
and none are currently pending.
.blank 2.test page 5
?FRMPDL PDL overflow in .FRAME
 There wasn't enough room on the push down stack for the
registers and the stack variables.  Cause:  The push down
stack was too small or the program was recursing.
.blank 2.test page 5
?pfxABT Program aborting, PC:xxxxxx
 The TYPER system was requested to abort the program.  Note:
xxxxxx is the PC of the $ERROR, $TYPE or $TYPES call.
.blank 2.test page 5
?pfxAIA An invalid alpha number (x)
 The argument given to the >$NUMBER macro with ALPHA output
type is zero or negative.  x is the invalid alpha number.
.blank 2.test page 5
?pfxBEF Bad EDIT function (x)
 The non-KL/KS EDIT instruction interpreter encounted an
invalid EDIT micro instruction.  Note:  x is the invalid
micro instruction.
.blank 2.test page 5
?pfxCPF The support code for $TYPES (PIC) wasn't loaded
 A call referencing the picture output code has been made,
but the support code hasn't been loaded.  Make sure all
modules referencing this output type are loaded before
TYPER.
.blank 2.test page 5
?pfxCTE CVTBDT took the error return
 During a picture substitution, the CVTBDT (ConVert Binary
to Decimal with Translation) instruction (or subroutine) took
the error return.  This is not expected to happen, and
probably indicates a bug in TYPER.
.blank 2.test page 5
[pfxDDT Entering DDT]
 The TYPER system was requested to enter DDT.
.blank 2.test page 5
?pfxDIU DEBRK. is unimplemented
 A $ERROR, $TYPE or $TYPES call was requested to return from
an interrupt and the DEBRK. UUO is unsupported or unimplemented
in the monitor.
.blank 2.test page 5
?pfxDNS Directory/user names are not supported on TOPS-10
 The TYPER system was requested to output a directory/user
name associated with a directory/user number, but they are
only supported on TOPS-20.
.blank 2.test page 5
?pfxETE EDIT took the error return
 During a picture substitution, the EDIT instruction (or
subroutine) took the error return.  This is not expected to
happen, and probably indicates a bug in the TYPER system.
.blank 2.test page 5
?pfxINP Illegal null picture
 The picture string used as an argument to the picture
substitution is null.  The picture should contain at least
one character.
.blank 2.test page 5
?pfxIPC Illegal picture character x
 During the picture substitution, an illegal picture
character was encountered.  The allowed characters are:
"_$", "_*", "_+", "_,", "_-", "_.", "9", "B", "C", "D"
and "Z".
.blank 2.test page 5
?pfxIPF Illegal picture format
 During the picture substitution, the "C" or "D" was
followed by an illegal character.  "C" must be followed by
"R" and "D" must be followed by "B".
.blank 2.test page 5
?pfxIVR x isn't a valid Roman numeral
 The number passed to the roman numeral output routine ("x")
is either negative or too large.  The largest allowed number
is 3999.
.blank 2.test page 5
?pfxJAS JFN's are not supported on TOPS-10
 The TYPER system was requested to output a file specification
associated with a job-file-number (JFN), but JFN's are only
supported on TOPS-20.
.blank 2.test page 5
?pfxMTL Error message too long to be processed
 The error message for the $ERS substitution is too long for
the internal buffer.
.blank 2.test page 5
?pfxNIP No interrupt in progress
 A $ERROR, $TYPE or $TYPES call was requested to return from
an interrupt and none are currently pending.
.blank 2.test page 5
?pfxNSJ No such JFN (x)
 The TYPER system was requested to output a file specification
associated with a job-file-number (JFN), but the JFN wasn't
associated with a file.  Note:  x is the JFN.
.blank 2.test page 5
?pfxPLE Program logic error, PC:xxxxxx (xxxxxx')
 The TYPER system was requested to abort the program, because
of an internal logic error that could NOT be self corrected.
Cause:  The programmer assumed that this code was impossible
or improbable to get to.  Note:  xxxxxx is the absolute PC
and xxxxxx' is the relative PC of the $TYPES BUG call.
.blank 2.test page 5
?pfxSCL The support code for the $xxx substitution wasn't loaded
 The substitution type of "$xxx" was encounterred, but the
support code for this substitution type wasn't loaded.  Using
the >$BITS or >$NUMBER macro in the main program will cause
the proper code to get loaded.  To avoid this message, insure
that TYPER is loaded after all modules which use it.
.blank 2.test page 5
?pfxSRS SCAN return and not using SCAN, PC:xxxxxx
 The TYPER system was requested to return to SCAN, but the
TYPER system was loaded without SCAN support.  Note:  xxxxxx
is the PC of the $TYPE call.
.blank 2.test page 5
?pfxTMC Too many commas
 The picture compiling code found a picture with two consecutive
commas.
.page
.title
.subtitle
.require "SYSUNV.RNX"
     {tc