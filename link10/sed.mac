TITLE	SED - Screen Editor
SUBTTL	A CHRISTOPHER HALL FECIT

	SEARCH	SEDSYM
TOPS10<	SEARCH	UUOSYM >
TOPS20<	SEARCH	MONSYM >
TOPS30<	PRINTX	?Cannot do both TOPS-10 and TOPS-20 yet>
IFTYM<	SEARCH	UUOTYM >

;[CSM] Minor modifications made by Joe Smith @ Colorado School of Mines
;[JMS] Minor modifications to make SED run on TYMCOM-X

;To create SED.EXE:
;	.LOAD SETSYM.MAC/COMPIL,SEDTTY.MAC,SED.MAC   ;SED.REL must be last


	.DIRECTIVE FLBLST	;[CSM] List first line binary of ASCIZ

;TREATMENT BY TOPS10:
;	PIM MODE: NO CODES ECHOED; NO INTERRUPTS
;	<C> IS A LEGAL COMMAND DISPATCHING TO ROUTINE "ABORT"
;TREATMENT BY TOPS20:
;	CODES .GT. 040 ECHOED NORMALLY, GO TO ROUTINE ALPNUM
;	<H> <J> <\> <]> <UP> <_> ECHOED NORMALLY
;	<I> <M> <O> <Q> <S> <T> CAUSE SOFTWARE INTERRUPTS
;	<C> INTERCEPTED BY MONITOR, CAUSING ABORT

	TWOSEG
	RELOC	400000

	EXTERN	TERMNL		;Address of dispatch table
	INTERN	CPOPJ,PUTSTG,PUTNUM,PUTSQ1,PUTTYP,TRMNAM,TYPBUF
	INTERN	CHOME,CDOWN,CRIGHT
	EXTERN	.JBREL,.JBAPR,.JBTPC,.JBREN
IFN CM-<RW+1>,<PRINTX ?DMOVEM RW,SAVPOS requires that CM=RW+1>

;         Table of Contents for SED - Full screen editor
;
;
;			   Section			      Page
;
;    1. Startup  . . . . . . . . . . . . . . . . . . . . . . .   2
;    2. Main input loop  . . . . . . . . . . . . . . . . . . .   3
;    3. Decode ESCape-sequence sub-table . . . . . . . . . . .   4
;    4. ALPNUM - Store non-control character on the screen . .   5
;    5. Process cursor movements . . . . . . . . . . . . . . .   6
;    6. Search for string  . . . . . . . . . . . . . . . . . .   7
;    7. Set INSERT mode  . . . . . . . . . . . . . . . . . . .   8
;    8. PERCEN - Goto position in file . . . . . . . . . . . .   9
;    9. EXIT and ABORT commands  . . . . . . . . . . . . . . .  10
;   10. Insert line  . . . . . . . . . . . . . . . . . . . . .  11
;   11. Delete lines . . . . . . . . . . . . . . . . . . . . .  12
;   12. Copy lines into buffer . . . . . . . . . . . . . . . .  13
;   13. Insert spaces  . . . . . . . . . . . . . . . . . . . .  14
;   14. Delete characters  . . . . . . . . . . . . . . . . . .  15
;   15. PICK command . . . . . . . . . . . . . . . . . . . . .  16
;   16. PUT command  . . . . . . . . . . . . . . . . . . . . .  17
;   17. SLIDE left and right . . . . . . . . . . . . . . . . .  18
;   18. EXECUTE command  . . . . . . . . . . . . . . . . . . .  19
;   19. Select input file  . . . . . . . . . . . . . . . . . .  20
;   20. The ENTER command  . . . . . . . . . . . . . . . . . .  21
;   21. Roll forward/backward pages  . . . . . . . . . . . . .  22
;   22. RESET command  . . . . . . . . . . . . . . . . . . . .  23
;   23. Change switch settings . . . . . . . . . . . . . . . .  24
;   24. RECALL command . . . . . . . . . . . . . . . . . . . .  25
;   25. REAL TAB, MARK, and COUNTER  . . . . . . . . . . . . .  26
;   26. Utility subroutines  . . . . . . . . . . . . . . . . .  27
;   27. Terminal output routines . . . . . . . . . . . . . . .  28
;   28. HISEG data . . . . . . . . . . . . . . . . . . . . . .  29
;   29. Command dispatch table . . . . . . . . . . . . . . . .  30
;   30. LOWSEG data  . . . . . . . . . . . . . . . . . . . . .  31
;   31. End of LOWSEG, start of text buffer  . . . . . . . . .  32
SUBTTL	Startup


START:	JFCL			;(TO ACCOUNT FOR CCL ENTRY)
	MOVE	P,[IOWD 20,STACK]
	MOVE	TY,[010700,,TYPBUF-1] ;SET UP TYPE BUFFER POINTER
IFN SAVETY,<
	MOVE	T1,[POINT 7,DEBBUF]
	MOVEM	T1,DEBPTR
>
	MOVE	T1,[%CNMNT]	;Get monitor type
	GETTAB	T1,
	  MOVEI	T1,0
	LDB	T1,[POINT 6,T1,23] ;Get CN%MNT
	SUBI	T1,.CNT10	;Check for TOPS-10
	MOVEM	T1,TYMCOM	;Nonzero if on TYMCOM-X
	SETZB	F,GOPERC	;SET UP NOMINAL PERCENT TO GO TO
	SETZB	TM,ADDLSP	;  AND SPACES ADDED WITH LINES
	SETZM	PICKSP		;  AND SPACES TO PICK
	SETZM	XCTITR		;  AND NUMBER OF TIMES TO ITERATE AN EXECUTE
	SETOM	SLDFLG
	SETOM	BAKFLG
	SETZM	UPPFLG		;UPPER CASE FLAG IS INITIALLY OFF
	SETZM	PREDP		;SAY THERE'S NO PRE-SET DISPLAY POINTER
	MOVE	EN,[350700,,BUFFEN] ;SET UP THAT "WELCOME TO E" MESSAGE
	SETZ	SL,		;CLEAR SLIDE OFFSET
TOPS10<	IFN FT$TYM,<
	HRROI	T1,.GTAUN	;Get accounting user number
	GETTAB	T1,		;The PPN used to LOGIN with
>  ;End of IFN FT$TYM		      ;If this succeeds, skip over GETPPN
	GETPPN	T1,		;GET USER'S PPN
	  JFCL
	MOVEM	T1,USRPPN	;SAVE IT FOR FUTURE REFERENCE
	PJOB	T1,		;GET JOB NUMBER FOR .TMP FILES
	MOVE	PT,[POINT 6,T4,17]
	IDIVI	T1,^D100	;CONVERT NUMBER TO 3 SIXBIT DIGITS
	IDIVI	T2,^D10		;IN RH OF T4
	IDPB	T1,PT
	IDPB	T2,PT
	IDPB	T3,PT
	ADDI	T4,'000'
	HRLM	T4,PIKFIL	;SET UP AS PICK FILE NAME (nnnPIK)
	HRLM	T4,CLSFIL	;AND AS CLOSE FILE NAME   (nnnCLS)
	HRLM	T4,STTFIL	;AND AS STAT FILE NAME	  (nnnSTT)
>
TOPS20<	SETO	T1,		;GET THIS JOB NUMBER IN T1
	MOVE	T2,[-1,,1]
	SETZB	T3,T4
	GETJI
	  SETZ	T1,		;HOW CAN IT MISS?
	MOVE	PT,[POINT 7,T4]
	IDIVI	T1,^D100	;CONVERT NUMBER TO 3 SIXBIT DIGITS
	IDIVI	T2,^D10		;IN RH OF T4
	IDPB	T1,PT
	IDPB	T2,PT
	IDPB	T3,PT
	ORM	T4,PIKFIL	;SET UP AS PICK FILE NAME (nnnPIK)
	ORM	T4,CLSFIL	;AND AS CLOSE FILE NAME   (nnnCLS)
	ORM	T4,STTFIL	;AND AS STAT FILE NAME	  (nnnSTT)
>
	PUSHJ	P,REDSWH	;READ SWITCH.INI, IF INI
	PUSHJ	P,REDTMP	;nnnSTT.TMP, IF ANY
	PUSHJ	P,RSCANL	;IF USER ENTERED WITH FILESPECS SET THEM UP
	PUSHJ	P,TTYINI	;[JMS] Set up for image-mode input
	HRR	TM,TERMNL	;Set pointer to default terminal characteristics
	MOVE	T1,TERMNL	;[CSM] Get flags or instruction
	TLNE	T1,777000	;[CSM] Is TERMNL the start of a subroutine?
	 PUSHJ	P,TERMNL	;[CSM] Yes, go ask monitor for terminal type
	PUSHJ	P,@RTE(TM)	;CALL USER'S ENTRY ROUTINE
	MOVEI	T1,^D500	;[CSM] Pause 1/2 second
TOPS10<	HIBER	T1,		;[CSM] For .SET WATCH FILES messages
	  JFCL	>		;[CSM]
TOPS20<	DISMS	>		;[CSM]
	HRLZ	T1,TCH(TM)	;GET TERMINAL-SPECIFIC FLAGS
	OR	TM,T1		;SET THEM UP
	TLNE	TM,NRU		;CAN TERMINAL ROLL UP?
	TRO	F,NRC		;NO - DON'T AUTOMATICALLY ROLL FROM LAST LINE
	MOVEI	T1,XBFNUM-1	;MAKE LAST (NULL) EXECUTE BUFFER ACTIVE
	MOVE	T1,XCTADR(T1)
	MOVEM	T1,XCTACW
TOPS10<	MOVEI	T1,REEERR	;SET UP RE-ENTRY ADDRESS
	MOVEM	T1,.JBREN
	MOVEI	T1,GETAK	;SET UP SO AN ILL MEM REF
	HRRM	T1,.JBAPR	;  EXPANDS CORE AUTOMATICALLY
	MOVEI	T1,420000
	APRENB	T1,
>
	MOVE	T1,LPP(TM)	;SET UP LINES PER ROLL
	HRREI	T3,-1(T1)
	IDIVI	T1,3
	MOVEM	T1,LPR
	MOVEM	T3,LPP.1	;SAVE LINES PER PAGE - 1
	MOVEM	T3,LPP.2	;SAVE BOTTOM LINE OF SCREEN
	TLNE	TM,NEL		;IF BOTTOM IS SCRATCH, USE NEXT LINE UP
	SOS	LPP.2
	MOVE	T1,CPL(TM)	;SET UP CPL - 1
	SOJ	T1,
	MOVEM	T1,CPL.1

	MOVEI	T1,1
	MOVEM	T1,ROLPGS	;SET UP NOMINAL PAGES TO ROLL
	MOVEM	T1,PICKLN	;  AND LINES TO PICK
	MOVEM	T1,ADDSPC	;  AND SPACES TO OPEN/CLOSE
	MOVEM	T1,ADDLNS	;  AND LINES DITTO
	MOVEI	T1,10		;SET UP NOMINAL SPACES TO SLIDE
	MOVEM	T1,SLIDES
	MOVE	T1,LPR		;SET UP NOMINAL LINES TO ROLL
	MOVEM	T1,ROLLIN
	SKIPE	RSCANF		;GOT A FILE FROM RESCAN?
	JRST	SETSCN		;YES - SET IT UP AND GO TO LOOP1
	SKIPN	FILSPC		;GOT A FILE FROM nnnSTT.TMP?
	JRST	REDNO		;NO - START OUT WITH CHEERY MESSAGE
	PUSH	P,TM		;YES - DISABLE ERROR MESSAGES
	SETZ	TM,
	PUSHJ	P,PARSEF	;PARSE AND UNPARSE THE FILESPECS
	POP	P,TM
	JRST	SETFL1		;AND GO SET UP THAT FILE

REDNO:	PUSHJ	P,PNTSTT	;ELSE DISPLAY CHEERY MESSAGE
	TLO	F,RDO		;MESSAGE IS READ-ONLY

NEWFIL:	TLZ	F,ENT!CHG!PCM	;FILE UNCHANGED; ENTER OFF; NO MARK
	TLO	F,XPB		;LAST-LINE POINTER IS INVALID
	MOVEI	T1,SQZVAL	;SET UP # OF COMMANDS TO SKIP BETWEEN SQUEEZES
	MOVEM	T1,SQZCNT
	CAMN	EN,[010700,,BUFFER-1] ;ANYTHING IN THE BUFFER?
	JRST	LOOP
	SKIPE	T1,GOPRCT	;WANT TO START SOME PERCENT IN?
	JRST	[MOVEM T1,GOPERC ;YES - SET UP THE RIGHT PERCENT
		 SETZM GOPRCT	 ;FORGET THAT IT WAS GIVEN
		 JRST  PERNPM]	 ;AND LET THE PERCENT COMMAND DO THE DISPLAY
	PUSHJ	P,DISPLL	;YES - DISPLAY A SCREENFUL
	PUSHJ	P,POSCUR	;POSITION THE CURSOR
SUBTTL	Main input loop


;NOW ACCEPT CHARACTERS AND DO THINGS
;NOTE: NON-SOFTWARE INTERRUPT COMMANDS ARE ARE AT LOOP
;      HOWEVER, ALL COMMANDS ARE HANDLED STARTING AT LOOP1

TOPS10<
INTEND:
>
LOOP:	SETZ	DO,		;SAY NO COMMAND IS BEING HANDLED
	TRNE	F,RST		;RESTORE NOMINALS?
	PUSHJ	P,RSTNOM	;YES - DO SO
	TRNE	F,XCT		;TAKE COMMAND FROM EXECUTE BUFFER?
	JRST	XCTGET		;YES - DO SO (GOES TO ALPNUM OR LOOP)
	TRZE	F,CWT		;IS CHARACTER ALREADY WAITING?
	JRST	[MOVE T1,TYPCHR ;YES - PICK IT UP
		 JRST LOOP1]	;AND USE IT AS CURRENT TERMINAL INPUT
TOPS10<	INCHRW T1>		;READ A CHARACTER
TOPS20<	PBIN>			;READ A CHARACTER

LOOP1:
IFN SAVETY,<
	IDPB	T1,DEBPTR	;SAVE CHARACTER FOR DEBUG
>
	TLNE	F,CCH		;CANCEL ENTER-CONTROL-CHAR FLAG - ON?
	JRST	[CAIE  T1,33	;YES - WAS ENTER TYPED?
		 JRST  .+1	;NO - CONTINUE
		 MOVEI T1,"["	;YES - HANDLE LIKE E-C-C "["
		 JRST  ALPNUM]
	CAIL	T1," "		;SOME CONTROL CHARACTER?
	JRST	ALPNUM		;NO - JUST PUT IT IN FILE OR BUFFER
	TLZ	F,ERF!CCH	;CLEAR CONSECUTIVE ERROR FLAG
	ADD	T1,ITB(TM)	;GET OFFSET IN TERMINAL TABLE
	SKIPGE	T1,(T1)		;IS IT A NORMAL COMMAND?
	PUSHJ	P,SUBTAB	;NO - READ MORE CHARACTERS

LOOP2:	TRNE	F,XSV		;SAVE COMMAND IN EXECUTE BUFFER?
	JRST	[MOVEI T2,"^"	 ;YES - DO SO
		 CAIL  T1," "	 ;GOT A HIGH-NUMBERED COMMAND?
		 IDPB  T2,XCTPTW ;YES - SAVE UP-ARROW AS FLAG
		 IDPB  T1,XCTPTW ;SAVE COMMAND
		 MOVE  T2,XCTACW ;SEE IF BUFFER WILL OVERFLOW
		 ADDI  T2,XBFSIZ
		 CAME  T2,XCTPTW
		 JRST  .+1	 ;NO OVERFLOW - CONTINUE
		 TRZ   F,XSV	 ;OVERFLOW - STOP SAVING
		 JRST  XCTERR]	 ;AND GIVE ERROR MESSAGE
	TLNE	F,ENT		;ENTERING A PARAMETER?
	JRST	[HLRZ T2,CMDTBL(T1) ;GET PROPER DISPATCH ADDRESS
		 TRNE F,CMV
		 JRST .+2
		 MOVE RW,SAVPOS	;RESTORE SAVED POSITION
		 MOVE CM,SAVPOS+1
		 JRST .+2]
	MOVE	T2,CMDTBL(T1)	;NO - GET PROPER DISPATCH ADDRESS
	MOVE	DO,T1		;SAVE COMMAND THAT WAS TYPED
	JUMPN	T2,(T2)		;IF THERE IS AN ADDRESS, GO TO IT AND DO IT
ILCERR:	MOVEI	T1,[ASCIZ /#########Illegal command/]
	JRST	ERROR
SUBTTL	Decode ESCape-sequence sub-table

;SUBROUTINE TO REFERENCE A TERMINAL'S SUBTABLES

SUBTAB:	MOVE	T4,T1		;SET UP ADDRESS OF SUBTABLE
SUBTB1:
TOPS10<	INCHRW T1 >		;GET NEXT CHARACTER
TOPS20<	PBIN >			;GET NEXT CHARACTER
SUBTB2:	SKIPN	T3,(T4)		;GET A SUBTABLE ENTRY - END?
	JRST	ILCERR		;YES - INPUT SEQUENCE NOT FOUND
	TRNN	T3,-1		;MATCH ON ANY CHARACTER?
	JRST	SUBTB3		;YES - SET UP REAL COMMAND NOW
	CAIE	T1,(T3)		;DO USER'S AND TABLE'S CHARS MATCH?
	AOBJN	T4,SUBTB2	;NO - LOOP ON THE TABLE
	JUMPG	T4,ILCERR	;JUMP IF END OF TABLE AND NOT FOUND
SUBTB3:	JUMPL	T3,SUBTBS	;ELSE FOUND - JUMP IF WANT ANOTHER LEVEL
	HLRZ	T1,T3		;ELSE SET UP REAL COMMAND
	POPJ	P,		;AND DONE, SUCCESSFULLY

SUBTBS:	HLRZ	T4,T3		;POINT TO NEW SUBTABLE
	HRLI	T4,-^D128	;[CSM] Set length to max (terminated by zero)
	JRST	SUBTB1		;READ ANOTHER CHARACTER FROM TERMINAL

;SUBROUTINE TO RESTORE NOMINALS, IF RST FLAG IS SET

RSTNOM:	MOVEI	T1,1
	SETZM	GOPERC
	MOVEM	T1,ADDLNS
	SETZM	ADDLSP
	MOVEM	T1,ADDSPC
	MOVEM	T1,PICKLN
	SETZM	PICKSP
	MOVEM	T1,ROLPGS
	MOVE	T1,LPR
	MOVEM	T1,ROLLIN
	MOVEI	T1,10
	MOVEM	T1,SLIDES
	POPJ	P,

;HERE ON SOFTWARE INTERRUPTS: SET UP THE DESIRED CHARACTER AND TREAT
;LIKE ALL THE OTHERS

;NOTE: INTERRUPTS ARE ONLY KOSHER WHEN THE EDITOR IS WAITING FOR A COMMAND
;(IE, DO/ 0). IF NOT, THE COMMAND IS IGNORED (FOR NOW)

TOPS20<
RUBOUT:	CAIE	DO,"R"-100	;DOING A SEARCH COMMAND?
	CAIN	DO,"E"-100
	JRST	RUBSRC		;YES - ABORT THE SEARCH
	CAIN	DO,"X"-100	;DOING AN EXECUTE?
	JRST	RUBEXC		;YES - ABORT IT
	TLZE	F,SCN		;IN SCAN MODE?
	DEBRK			;YES - CLEARING FLAG WILL END IT
	MOVEI	T0,177		;ELSE PICK UP A REAL RUBOUT

	JRST	CTRL		;AND PROCESS IT
CTRLI:	MOVEI	T0,11
	JRST	CTRL
CTRLM:	MOVEI	T0,15
	JRST	CTRL
CTRLO:	MOVEI	T0,"O"-100
	JRST	CTRL
CTRLQ:	MOVEI	T0,"Q"-100
	JRST	CTRL
CTRLS:	MOVEI	T0,"S"-100
	JRST	CTRL
CTRLT:	MOVEI	T0,"T"-100

CTRL:	CAIN	DO,1000		;GIVING HELP?
	JRST	CTRHLP		;YES - HANDLE SPECIALLY
	JUMPN	DO,CTRLSV	;IF NOT WAITING FOR A COMMAND, SAVE THIS ONE
	TLO	F,INT		;SET INTERRUPT-LEVEL FLAG
	MOVE	T1,T0		;SET UP COMMAND
	JRST	LOOP1		;AND PROCESS IT

CTRHLP:	TLO	F,INT
	CAIN	T0,177		;GOT A RUBOUT?
	JRST	CTRHL1		;YES - GET ITS COMMAND
	MOVE	T1,T0		;ELSE SET COMMAND UP
	ADD	T1,ITB(TM)	;GET OFFSET IN TERMINAL TABLE
	JRST	ENTHL2		;AND GIVE HELP AT INTERRUPT LEVEL

CTRHL1:	MOVE	T1,ITB(TM)	;GET THE COMMAND INVOKED BY RUBOUT
	MOVE	T1,-1(T1)
	JRST	ENTHL3		;GIVE WITH THE HELP

;ALL INTERRUPT ROUTINES JUMP HERE WHEN DONE TO RESET THEIR STATUS
;OTHER ROUTINES DO, TOO, IF THEY ARE NOT SURE IF THEY ARE AT INTERRUPT LEVEL

INTEND:	TLZN	F,INT		;CLEAR INTERRUPT FLAG - WAS IT ON?
	JRST	LOOP		;NO - GET ANOTHER COMMAND
	SETZ	DO,		;YES - SAY NO COMMAND IS BEING PROCESSED
	DEBRK			;DISMISS THE INTERRUPT

CTRLSV:	TRON	 F,CWT		 ;SAY CHARACTER HAS BEEN READ - HAS ONE?
	MOVEM	 T0,TYPCHR	 ;NO - SAVE COMMAND FOR LATER
	DEBRK			 ;DISMISS IT IN EITHER CASE
> ;END TOPS20

;HERE IF USER TYPED RUBOUT DURING A SEARCH - ABORT THE SEARCH

RUBSRC:	MOVEI	T1,[ASCIZ /##########Search aborted/]
TOPS20<	RUBSR1:	MOVEI	T2,LOOP+1	;MAKE INTERRUPT RETURN TO CHARACTER INPUT
	MOVEM	T2,PC2
	TLO	F,INT		;SET FLAG FOR INTERRUPT LEVEL
>
	JRST	ERROR

;HERE IF USER TYPED RUBOUT DURING AN EXECUTE - ABORT THE EXECUTE

RUBEXC:	MOVEI	T1,[ASCIZ /#########Execution stopped/]
TOPS10<	JRST	ERROR
>
TOPS20<	JRST	RUBSR1
>
SUBTTL	ALPNUM - Store non-control character on the screen

;HERE IF A NON-CONTROL CHARACTER WAS TYPED - PUT IT IN FILE OR
;PARAMETER BUFFER, AND ADJUST CURSOR POSITION ONE TO THE RIGHT

ALPNUM:	CAIN	T1,177		;REALLY A RUBOUT?
	JRST	[MOVE T1,ITB(TM);YES - GET ITS COMMAND
		 MOVE T1,-1(T1)
		 JRST LOOP2]
	SETO	DO,		;NOTE THAT A COMMAND IS ACTIVE
	SKIPE	UPPFLG		;WANT UPPER CASE ALPHABETICS?
	JRST	[CAIGE T1,"a"	;YES - IS CHARACTER LOWER CASE?
		 JRST  .+1	;NO - O.K.
		 CAIG  T1,"z"
		 SUBI  T1,40	;YES - CONVERT TO LOWER
		 JRST  .+1]	;CONTINUE
	TRNE	F,XSV		;SAVE COMMAND IN EXECUTE BUFFER?
	JRST	[IDPB T1,XCTPTW	;YES - DO SO
		 CAIN T1,"^"	;IS CHARACTER A REAL UP-ARROW?
		 IDPB T1,XCTPTW	;YES - SAVE TWO OF THEM
		 MOVE T2,XCTACW	;SEE IF BUFFER WILL OVERFLOW
		 ADDI T2,XBFSIZ
		 CAME T2,XCTPTW
		 JRST .+1	;NO OVERFLOW - CONTINUE
		 TRZ  F,XSV	;OVERFLOW - STOP SAVING
		 JRST XCTERR]	;AND GIVE ERROR MESSAGE
	TLZE	F,CCH		;WANT A CONTROL CHARACTER?
	ANDI	T1,37		;YES - MAKE IT ONE
	TLNE	F,ENT		;ENTERING A PARAMETER?
	JRST	ALPENT		;YES - HANDLE SEPARATELY

	TLNE	F,RDO		;NO - IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	TLO	F,CHG!INS	;LET LINE BE EXTENDED IF NECESSARY
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	TLZ	F,INS!PCM
	TRNE	F,IMD		;IN INSERT MODE?
	JRST	ALPIMD		;YES - HANDLE SEPARATELY

;HERE TO PUT CHARACTER IN FILE (NON-INSERT-MODE)

	SETZ	T4,		;CLEAR (MAYBE) POINTER TO FIRST NULL
ALPNM2:	ILDB	T2,CHRPTR	;GET CHARACTER THAT WILL BE OVERWRITTEN
	JUMPE	T2,ALPNUL	;IF NULL, SAVE POINTER
	CAIN	T2,11		;TAB?
	JRST	ALPTAB		;YES - NEED TO BREAK THE TAB APART
	CAIN	T2,15		;CARRIAGE RETURN?
	PUSHJ	P,ALPEXT	;YES - MAY NEED TO EXTEND LINE
ALPNM3:	DPB	T1,CHRPTR	;SAVE CHARACTER IN BUFFER
	CAMN	EN,CHRPTR	;AT THE END OF FILE?
	IBP	EN		;YES - INCREASE FILE SIZE BY ONE CHARACTER

;HERE TO DISPLAY CHARACTER, FROM REPLACE MODE OR PARAMETER

ALPDIS:	MOVEM	T1,CHARAC	;SAVE USER'S CHARACTER
	TRNE	F,XCT		;EXECUTING?
	 JRST	ALPPOS		;YES - POSITION, BUT NO ECHO
	CAIGE	T1," "		;GOT A CONTROL CHARACTER?
	 JRST	ALPCCH		;YES - DISPLAY SPECIALLY
	CAMN	RW,LPP.1	;AT LAST LINE?
	 JRST	[TLZN  F,FNC	;YES - IS FENCE UP?
		 JRST  .+1	;NO - DRIVE ON
		 PUSH  P,T1	;YES - SAVE CHARACTER TYPED
		 PUSHJ P,CBOTOM ;TAKE FENCE DOWN
		 PUSHJ P,POSCUR ;RE-POSITION CURSOR
		 POP   P,T1	;GET CHARACTER BACK
		 JRST  .+1]	;CONTINUE
TOPS10<	IONEOU T1>		;ELSE ECHO CHARACTER
TOPS20<	PBOUT>		;ECHO CHARACTER
	JRST	RIGHT+1		;DONE

;HERE TO OUTPUT A PROTECTED CONTROL CHARACTER

ALPCCH:	MOVE	T2,T1		;GET CHARACTER
	ADDI	T2,100		;  AS A REAL CHARACTER
	CAIN	T1,11		;GOT A TAB?
	 JRST	ALPDTB		;YES - HANDLE SPECIALLY
	PUSH	P,T1		;SAVE KNOCKED CHARACTER
	PUSHJ	P,PROTON	;OUTPUT THE CHARACTER PROTECTED
	MOVE	T1,T2
	IDPB	T1,TY
	PUSHJ	P,PROTOF
	PUSHJ	P,PUTTYP	;OUTPUT IT NOW
	POP	P,T1		;GET CONTROL CHAR BACK AGAIN
	JRST	RIGHT+1

	MOVEI	DO,37		;CAUSE POSITIONING TO OCCUR
ALPDTB:	MOVSI	T1,70000	;MOVE POINTER BEHIND THE LATEST CHARACTER
	ADD	T1,CHRPTR
	JUMPGE	T1,.+2
	SUB	T1,[430000,,1]
	MOVEM	T1,CHRPTR	;SAVE CHARACTER POINTER
	PUSHJ	P,DISLIN	;REWRITE REMAINDER OF LINE
	IBP	CHRPTR		;MAKE CHARACTER POINTER RIGHT
	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
ALPPOS:	CAIE	T1,11		;TAB?
	JRST	RIGHT+1		;NO - MOVE TO THE RIGHT AND LOOP
	TRZ	CM,7		;YES - POINT TO CHARACTER AFTER TAB
	ADDI	CM,10
	JRST	DISCUR		;RE-POSITION AND LOOP

;HERE IF NULL FOUND WHERE CHARACTER POINTER POINTS

ALPNUL:	JUMPN	T4,.+2		;IF NOT FIRST NULL, DON'T SAVE POINTER
	MOVE	T4,CHRPTR	;ELSE SAVE POINTER TO FIRST NULL
	CAME	EN,CHRPTR	;AT END OF FILE?
	JRST	ALPNM2		;NO - LOOP
	MOVEM	T4,CHRPTR	;YES - POINT BACK TO FIRST NULL
	JUMPE	T4,ALPERR	;ERROR IF NO NULL FOUND (SHOULDN'T HAPPEN)
	JRST	ALPNM3		;SAVE CHARACTER THERE

ALPERR:	MOVEI	T1,[ASCIZ /########BUG - No null found/]
	JRST	ERROR

;HERE IF CHARACTER TO OVERWRITE IS A TAB - PRECEDE IT WITH SPACES AND CHAR
;IF CHARACTER IS GOING INTO THE 7TH POSITION OF THE TAB, TAKE THE TAB OUT

ALPTAB:	PUSH	P,T1		;SAVE CHARACTER USER TYPED
	MOVE	T2,[70000,,0]	;ELSE BACK POINTER UP BEFORE THE TAB
	ADDB	T2,CHRPTR
	JUMPGE	T2,.+3
	MOVN	T2,[430000,,1]
	ADDM	T2,CHRPTR
	AOS	T2,TABSPC	;GET SPACES (+ CHAR) TO ADD BEFORE TAB
	MOVEM	T2,NUMCHR	;ADD THAT MANY SPACES TO THE FILE
	PUSHJ	P,MAKSPC	;NOTE: T4 HAS PTR TO LAST THING ADDED

;MAKCHR POINTS TO START OF ADDED SPACES
;MAKPTR   "    "  LAST SPACE ADDED
;T4	  "    "  POINTS TO THE TAB

	SETZ	T1,		;NULL OUT THE FORMER TAB
	IDPB	T1,T4
	POP	P,T1		;GET USER'S CHARACTER BACK AGAIN
	TLO	F,XPB		;NOW BOTTOM PTR IS BAD
	MOVE	T4,MAKPTR
	DPB	T1,T4		;SAVE IT OVER THE LAST THING TYPED
	MOVEM	T4,CHRPTR	;SAVE AS CURRENT POSITION
	MOVN	T2,TABSPC
	ADDB	T2,TABSIZ	;SEE IF ENTIRE TAB HAS BEEN USED UP
	SETZM	TABSPC		;NO LONGER ANY SPACES TO LEFT OF TAB
	JUMPG	T2,.+2		;IS TAB NOW EXPRESSED ENTIRELY IN CHARS?
	TDZA	T2,T2		;YES - NULL OUT THE TAB
	MOVEI	T2,11		;NO - MOVE TAB OVER
	IDPB	T2,T4
	JRST	ALPDIS		;DONE - GO DISPLAY

;SUBROUTINE FOR IF GOING TO OVERWRITE A <CR>. IF IT'S <CRLF> EXTEND LINE
;HOWEVER, IF A NUS PASSED OVER, SAVE CHARACTER THERE; LEAVE <CR> ALONE

ALPEXT:	JUMPN	T4,ALPEX1	;IF FOUND A NULL, SAVE CHARACTER THERE
	MOVE	T3,CHRPTR
	ILDB	T2,T3
	CAIE	T2,12		;IS IT A LINEFEED?
	POPJ	P,		;NO - JUST OVERWRITE THE LONE <CR>
	PUSH	P,T1		;YES - SAVE CHARACTER USER TYPED

	MOVSI	T1,70000	;MOVE POINTER BEHIND THE <CR>
	ADD	T1,CHRPTR
	JUMPGE	T1,.+2
	SUB	T1,[430000,,1]
	MOVEM	T1,CHRPTR	;SAVE IT AGAIN

	MOVEI	T1,12		;GO ADD 12 NULLS TO THE FILE
	MOVEM	T1,NUMCHR
	PUSHJ	P,MAKSPC	;PUT IN SOME SPACES
	POP	P,T1		;GET CHARACTER BACK
	IBP	CHRPTR		;POINT BACK TO REAL CHARACTER POSITION
	TLO	F,XPB		;MARK BOTTOM POINTER AS BAD
	POPJ	P,		;AND GO PUT IT INTO BUFFER

ALPEX1:	MOVEM	T4,CHRPTR	;GO SAVE CHARACTER OVER THAT NULL
	POPJ	P,		;..

;HERE IF EDITOR IS IN INSERT MODE - ADD CHARACTER AT CURSOR; DON'T REPLACE

ALPIMD:	CAMLE	CM,CPL.1	;AT 80TH COLUMN?
	JRST	ALPIBP		;YES - INSERT NOT ALLOWED
	MOVE	PT,CHRPTR	;GET CHARACTER POINTER
	MOVEM	T1,CHARAC	;SAVE USER'S CHARACTER
	ILDB	T2,PT		;GET CHARACTER AT POINTER
	JUMPE	T2,ALPIM4	;IF NULL, SAVE NEW CHAR THERE
	LDB	T2,CHRPTR	;ELSE GET CHARACTER BEFORE POINTER
	JUMPE	T2,ALPIM5	;IF NULL, SAVE NEW CHAR THERE
				;ELSE NEED TO INSERT SOME SPACE:
	MOVEI	T1,1		;TELL MAKCHR TO INSERT ONE CHARACTER
	MOVEM	T1,NUMCHR
	PUSHJ	P,MAKCHR	;INSERT THAT CHARACTER
	IBP	CHRPTR		;POINT TO CHARACTER AFTER THIS ONE
	TLO	F,XPB		;MARK BOTTOM POINTER AS BAD
ALPIM1:	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
	CAIN	T1,11		;IS IT A TAB?
	JRST	ALPDTB		;YES - REWRITE REST OF LINE
	MOVEI	T4,1		;SET TO OPEN LINE ONE CHARACTER
	SKIPE	T3,ISP(TM)	;CAN TERMINAL OPEN SPACES ON ITS OWN?
	PUSHJ	P,OPNSPI	;YES - OPEN UP THE LINE (SKIP RETURN)
	JRST	ALPDTB-1	;NO - REWRITE THE LINE CURSOR IS ON
	PUSHJ	P,POSCUR	;GET BACK TO START OF NEWLY-OPENED SPACE
	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
	CAIGE	T1," "		;GOT A CONTROL CHARACTER?
	JRST	ALPCCH		;YES - DISPLAY SPECIALLY
	IDPB	T1,TY		;DISPLAY IT
	AOJA	CM,DISCUR	;RE-DISPLAY THE CURSOR; DONE

ALPIBP:	MOVEI	T1,7		;IF AT 80TH COLUMN, JUST BEEP
TOPS10<	IONEOU T1>
TOPS20<	PBOUT>
	JRST	LOOP

;HERE IF NULL FOUND AT (ALPIM4) OR BEFORE (ALPIM5) CURSOR POSITION
;SAVE NEW CHARACTER THERE; NO INSERT NECESSARY

ALPIM4:	IBP	CHRPTR		;SKIP OVER THIS NEW CHARACTER
ALPIM5:	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
	DPB	T1,CHRPTR	;SAVE NEW CHARACTER JUST BEFORE POINTER
	JRST	ALPIM1		;GO DISPLAY WHAT HAPPENED

;HERE FOR A CHARACTER TYPED AS PART OF A PARAMETER

ALPENT:	TRZE	F,CMV		;DOING CURSOR MOVEMENT?
	JRST	CMXERR		;YES - CAN'T MIX CURSOR AND OTHERWISE
	IDPB	T1,PARPTR	;SAVE THIS CHARACTER IN PARAMETER BUFFER
	TRNE	F,XCT		;EXECUTING?
	AOJA	CM,LOOP		;YES - NO OUTPUT
	CAIGE	T1," "		;GOT A CONTROL CHARACTER?
	JRST	ALPENC		;YES - OUTPUT IT PROTECTED
TOPS10<	IONEOU T1>		;ECHO CHARACTER
TOPS20<	PBOUT>		;ECHO CHARACTER
	AOJA	CM,LOOP		;GET ANOTHER COMMAND

ALPENC:	MOVE	T4,T1		;SAVE CHARACTER
	PUSHJ	P,PROTON	;PROTECT CHARACTER
	MOVEI	T1,100(T4)	;GET REAL CHARACTER BACK
	IDPB	T1,TY		;SAVE IT
	PUSHJ	P,PROTOF
	PUSHJ	P,PUTTYP
	AOJA	CM,LOOP		;GET ANOTHER COMMAND
SUBTTL	Process cursor movements

;DISPATCH AREAS FOR CURSOR CONTROL CHARACTERS
;IF ENTER WAS TYPED, RIGHT GOES TO RGTARG; ALSO LFTARG, UPARG, DWNARG, HOMARG

RIGHT:	TLO	F,XPC		;CHARACTER POINTER IS NO LONGER GOOD
	CAMGE	CM,CPL.1	;OFF THE RIGHT SIDE?
	AOJA	CM,AJDONE	;NO - JUST MOVE RIGHT
	SETZ	CM,		;YES - MOVE TO LEFT MARGIN
	MOVEI	DO,37		;MAKE CURSOR POSITION ABSOLUTELY
	TLO	F,XPL!XPC	;LINE POINTER IS NO GOOD EITHER
	CAMGE	RW,LPP.2	;AT BOTTOM?
	AOJA	RW,AJDONE	;NO - DROP DOWN ONE MORE
	AOJA	RW,RETROL	;YES - SEE IF SCREEN SHOULD BE ROLLED

DOWN:	TLO	F,XPL!XPC	;LINE POINTER IS NO LONGER GOOD
	CAML	RW,LPP.2	;AT BOTTOM?
	TDZA	RW,RW		;YES - MOVE TO TOP
	AOJA	RW,AJDONE	;NO - DROP DOWN ONE MORE
	MOVEI	DO,37		;MAKE CURSOR POSITION ABSOLUTELY
	JRST	AJDONE

LEFT0:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT?
	PUSHJ	P,MARKUP	;NO - PUT CURSOR BACK IN TEXT
;	PUSHJ	P,PUTTYP
LEFT:	TLO	F,XPC		;CHARACTER POINTER IS NO LONGER GOOD
	SOJGE	CM,AJDONE	;MOVE LEFT - OFF THE EDGE?
	MOVE	CM,CPL.1	;YES - SET TO RIGHT EDGE
				;AND GO UP ONE
	MOVEI	DO,37		;MAKE CURSOR POSITION ABSOLUTELY
UP:	TLO	F,XPL!XPC	;LINE POINTER IS NO LONGER GOOD
	SOJGE	RW,AJDONE	;MOVE UP - OFF THE TOP?
	MOVE	RW,LPP.2	;YES - SET TO BOTTOM
	MOVEI	DO,37		;MAKE CURSOR POSITION ABSOLUTELY

AJDONE:	CAIN	DO,10		;ELSE WANT A CURSOR LEFT?
	JRST	[PUSHJ P,CLEFT	;YES - HANDLE SEPARATELY
		 JRST  AJDON1]
	CAIGE	DO,34		;GOT A REAL CURSOR MOVE?
	JRST	AJDON1+1	;NO - NO OUTPUT, THEN
	PUSHJ	P,@CMVTBL-34(DO) ;YES - MOVE THE CURSOR THE RIGHT WAY
AJDON1:	PUSHJ	P,PUTTYP
	TLNE	F,FLG		;WANT A SUBROUTINE RETURN?
CPOPJ:	POPJ	P,		;YES
	JRST	LOOP		;NO - GO GET MORE INPUT

HOMARG:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT?
	PUSHJ	P,MARKUP	;NO - PUT CURSOR BACK IN TEXT
HOME:	SETZB	RW,CM		;SET TO TOP AND LEFT MARGIN OF SCREEN
	TLO	F,XPL!XPC	;LINE AND CHARACTER POINTERS ARE INVALID
	PUSHJ	P,CHOME		;MOVE THE CURSOR HOME
	PUSHJ	P,PUTTYP	;ELSE OUTPUT IT NOW
	JRST	INTEND

UPARG:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT?
	PUSHJ	P,MARKUP	;NO - PUT CURSOR BACK IN TEXT
	JRST	UP

DWNARG:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT?
	PUSHJ	P,MARKUP	;NO - PUT CURSOR BACK IN TEXT
	JRST	DOWN

RGTARG:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT?
	PUSHJ	P,MARKUP	;NO - PUT CURSOR BACK IN TEXT
	JRST	RIGHT

;LFTARG IS SPECIAL: IT OPERATES BOTH AS CURSOR MOVEMENT AND TO DELETE
;FROM THE PARAMETER BUFFER.

LFTARG:	TRNE	F,CMV		;DOING CURSOR MOVEMENT?
	JRST	LEFT		;YES - MOVE THE CURSOR
	MOVE	T2,PARPTR	;IS THIS THE 1ST CHARACTER OF THE ARGUMENT?
	CAMN	T2,[POINT 7,PARBUF]
	JRST	LEFT0		;YES - START CURSOR MOVEMENT
	CAMN	T2,[010700,,PARBUF-1]
	JRST	LOOP		;SKIP, IF USER DELETED ALL OF ARG
	ADD	T2,[70000,,0]	;FUDGE A DECREMENT OF THE PARM POINTER
	JUMPGE	T2,.+2		;IE, DELETE THE LATEST CHARACTER
	SUB	T2,[430000,,1]
	MOVEM	T2,PARPTR	;SAVE IT AGAIN
	PUSHJ	P,CLEFT		;ERASE A CHARACTER OF PARAMETER
	MOVEI	T1," "
	IDPB	T1,TY
	PUSHJ	P,CLEFT
	PUSHJ	P,PUTTYP
	JRST	LOOP		;AND GET A NEW COMMAND

;HERE FOR <CR> - OUTPUT A CARRIAGE RETURN-LINEFEED

RETARG:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT?
	PUSHJ	P,MARKUP	;NO - PUT CURSOR BACK IN TEXT
	JRST	RETUR0		;IT'S NEVER INSERT MODE IN A PARAMETER

RETURN:	TRNE	F,IMD		;IN INSERT MODE?
	JRST	RETIMD		;YES - ACT LIKE AN OPEN-LINE COMMAND
RETUR0:	SETZ	CM,		;GO TO THE LEFT
	AOS	T4,RW		;AND DOWN ONE (AND GET FOR POSLIN)
	TLO	F,XPL!XPC	;LINE AND CHARACTER POINTERS ARE INVALID
	CAMLE	RW,LPP.2	;OFF THE BOTTOM?
	JRST	RETROL		;YES - MOVE TO THE TOP OR ROLL
RETUR1:	PUSHJ	P,POSLIN	;MOVE TO THE RIGHT LINE
	JRST	INTEND		;AND GET ANOTHER COMMAND

;HERE FOR RETURN IN INSERT MODE: INSERT A LINE, THEN RETURN

RETIMD:	TRNE	F,NCR		;BEHAVE LIKE A NORMAL CR?
	JRST	RETUR0		;YES - GO BACK AND RETURN
	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	PUSHJ	P,CLRLNR	;CLEAR TO END OF PRESENT LINE
	TLO	F,XPB!CHG	;SAY BOTTOM POINTER BAD; FILE MODIFIED
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	MOVEI	T4,2		;SET TO INSERT TWO LINEFEEDS
	MOVEM	T4,NUMCHR
	MOVEI	T1,12		;  (CHANGE ONE OF 'EM TO A <CR> LATER)
	MOVEM	T1,CHARAC
	PUSHJ	P,MAKCHR

	MOVE	PT,CHRPTR	;GET POINTER TO CURSOR POSITION
	MOVEI	T1,15		;GET A CARRIAGE RETURN
	IDPB	T1,PT		;SET UP A NEW LINE
	IBP	PT		;SKIP OVER LINEFEED
	MOVEM	PT,CHRPTR	;SAVE CHARACTER POINTER AGAIN
	MOVEM	PT,LINPTR	;IT'S NOW THE LINE POINTER, TOO
	SETZ	CM,		;DO THE ACTUAL CARRIAGE RETURN
	AOJ	RW,
	CAML	RW,LPP(TM)	;WORKING ON BOTTOM LINE?
	JRST	RETROL		;YES - MOVE TO THE TOP OR ROLL
	MOVEI	T4,1		;GET SIZE OF OPEN
	SKIPN	T3,ILN(TM)	;CAN TERMINAL OPEN ITS OWN LINES?
	JRST	DISDWN		;NO - GO REDISPLAY FROM HERE DOWN
	PUSHJ	P,OPENLD	;OPEN UP THE SCREEN
	PUSHJ	P,DISONE	;RE-WRITE LINE
	JRST	INTEND		;DONE

;HERE IF RETURN TYPED AT BOTTOM OF SCREEN. IF NRC FLAG IS SET
;ROLL THE SCREEN ONE LINE, POSITION TO NEW BOTTOM, ELSE GO TO TOP
;ROLL A LINE; ELSE MOVE TO TOP OF SCREEN

RETROL:	TRNE	F,NRC		;WANT TO ROLL?
	JRST	[SETZB T4,RW	;NO - MOVE TO THE TOP
		 JRST  RETUR1]	;AND CONTINUE
	SKIPE	MRKPTR		;HAS A MARK BEEN MADE?
	JRST	.+3		;YES - O.K.
	TLNE	F,ENT		;NO - ENTERING A PARAMETER?
	SOJA	RW,INTEND	;PARAMETER, BUT NO MARK - DO NOTHING
	MOVEI	T4,1		;SET TO ROLL ONE LINE
	JRST	RFLNPM+1	;DO THE ROLL AND LOOP

;HERE FOR TAB - MOVE CURSOR POINTER AND CURSOR ON SCREEN

TABARG:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT?
	PUSHJ	P,MARKUP	;NO - PUT CURSOR BACK IN TEXT

TAB:	TRNE	F,WTB		;WANT WORD-WISE TABS?
	JRST	WTAB		;YES - GO DO THEM
	MOVE	T3,TABLEN	;GET LENGTH OF A TAB
	CAIE	T3,10		;IS IT THE USUAL?
	JRST	TAB0		;NO - HANDLE IT SPECIALLY
	TRZ	CM,7		;ELSE TAB OVER
	ADDI	CM,10
	JRST	TAB1-1

TAB0:	MOVE	T1,CM		;MOVE TO NEXT USER-SET TAB STOP
	IDIV	T1,T3		;MOVE BACK TO PREVIOUS STOP
	IMUL	T1,T3
	ADD	T1,T3		;THEN JUMP TO NEXT ONE
	MOVE	CM,T1

	TLO	F,XPC		;CHARACTER POINTER IS BAD
TAB1:	CAML	CM,CPL.1	;OFF THE RIGHT SIDE?
	JRST	RETURN		;YES - GO TO START OF NEXT LINE
	PUSHJ	P,POSCUR	;NO - POSITION THE CURSOR
	JRST	INTEND		;AND GET ANOTHER COMMAND

;HERE FOR DOING A TAB IN WORD-PROCESSING MODE: MOVE TO START OF NEXT WORD
;IE, LOOK FOR NEXT SPACE OR TAB; POINT TO NON- SPACE OR TAB AFTER THAT
;IF BEYOND END OF LINE JUST DO REGULAR TABS
;IF TAB WOULD GO OFF SCREEN MOVE TO START OF NEXT LINE

WTAB:	TLNE	F,XPC		;GOT POINTER TO CURRENT POSITION?
	PUSHJ	P,MAKCPT	;NO - RE-MAKE IT
	MOVE	PT,CHRPTR
	MOVE	T3,CM		;SAVE CURRENT POSITION
	ILDB	T1,PT		;GET FIRST CHARACTER
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIN	T1,15		;CARRIAGE RETURN?
	JRST	WTABT		;YES - DO A NORMAL TAB
	CAIN	T1," "		;SPACE?
	AOJA	CM,WTABS	;YES - CHECK FOR TRAILING SPACES
	CAIN	T1,11		;TAB?
	JRST	WTABS1		;YES - CHECK FOR TRAILING SPACES

	AOSA	T3,CM		;BUMP AND GET POSITION NUMBER
WTABC:	MOVE	T3,CM		;SAVE POSITION NUMBER
	MOVE	T2,PT		;  AND CHARACTER POINTER
	ILDB	T1,PT		;GET NEXT CHARACTER
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIN	T1," "		;IS IT A SPACE?
	AOJA	CM,WTABCS	;YES - PHASE TWO
	CAIN	T1,11		;NO - IS IT A TAB?
	JRST	WTABCT		;YES - COUNT IT AND SKIP SPACES
	CAIE	T1,15		;NO - GOT A CARRIAGE RETURN?
	AOJA	CM,WTABC	;NO - SKIP THIS REAL CHARACTER

WTABX:	MOVE	CM,T3		;GET POSITION BEFORE TRAILING SPACES
WTABX0:	MOVEM	T2,CHRPTR	;SAVE CHARACTER POINTER
	JRST	TAB1		;AND FINISH OFF

WTABCT:	TRZ	CM,7		;TAB OVER
	ADDI	CM,10
WTABCS:	MOVEM	CM,SAVEAC	;SAVE POSITION
	MOVE	T0,PT		;AND CHARACTER POINTER
	ILDB	T1,PT		;GET NEXT CHARACTER
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIN	T1,15		;NO - GOT A CARRIAGE RETURN?
	JRST	WTABX		;YES - POSITION TO END OF LINE
	CAIN	T1," "		;SPACE?
	AOJA	CM,WTABCS	;YES - SKIP UNTIL NOT ONE OF THOSE
	CAIN	T1,11		;TAB?
	JRST	WTABCT		;YES - COUNT THE TAB AND SKIP IT
	MOVE	CM,SAVEAC	;GET POINTER TO THIS CHARACTER
	MOVEM	T0,CHRPTR
	JRST	TAB1		;AND MOVE CURSOR HERE

;HERE IF CHARACTER AT CURSOR IS SPACE OR TAB

WTABS:	MOVE	T2,PT		;SAVE POSITION
	ILDB	T1,PT		;GET CHARACTER AFTER <CR>
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIN	T1," "		;SPACE?
	AOJA	CM,WTABS	;YES - COUNT AND SKIP IT
	CAIN	T1,15		;CARRIAGE RETURN?
	JRST	WTABT		;YES - POSITION TO END OF LINE
	CAIE	T1,11		;TAB?
	JRST	WTABX0		;NO - POSITION TO CURRENT CHARACTER
WTABS1:	TRZ	CM,7		;YES - TAB OVER
	ADDI	CM,10
	JRST	WTABS		;AND KEEP SKIPPING

WTABT:	MOVE	CM,T3		;HERE IF AT END OF LINE - DO NORMAL TAB
	JRST	TAB+2

;HERE TO HANDLE A BACK-TAB - MOVE BACK TO THE NEAREST TAB STOP

BTBARG:	TRON	F,CMV		;ALREADY DOING CURSOR MOVEMENT
	PUSHJ	P,MARKUP	;NO - SET UP FOR IT

BAKTAB:	TRNE	F,WTB		;WANT WORD-WISE BACKTABS?
	JRST	WBTAB		;YES - GO DO THEM
	TLO	F,XPC		;CHARACTER POINTER IS BAD
	MOVE	T3,TABLEN	;GET LENGTH OF A TAB
	CAIE	T3,10		;IS IT THE USUAL?
	JRST	BAKTB0		;NO - HANDLE IT SPECIALLY
	TRZN	CM,7		;YES - TAB BACKWARD
	SUBI	CM,10
	JRST	BAKTB1		;FINISH OFF

BAKTB0:	SOSGE	T1,CM		;GET AND DECREMENT POSITION. IF AT LEFT,
	JRST	BAKTB1+1	;  MOVE TO RIGHT OF PREVIOUS LINE
	IDIV	T1,T3		;ELSE MOVE TO PREVIOUS TAB STOP
	IMUL	T1,T3
	MOVE	CM,T1

BAKTB1:	JUMPGE	CM,DISCUR	;DONE, IF ON SCREEN
	MOVE	CM,CPL.1	;ELSE MOVE TO RIGHT
	SOJGE	RW,DISCUR	; OF NEXT HIGHER LINE
	MOVE	RW,LPP.2	;IF AT TOP, MOVE TO BOTTOM
	JRST	DISCUR

;HERE FOR DOING A BACK-TAB IN WORD-PROCESSING MODE
;MOVE TO START OF PREVIOUS WORD
;IE, LOOK FOR NEXT SPACE OR TAB; POINT TO NEXT NON- SPACE OR TAB
;IF AT START OF LINE, MOVE TO END OF PREVIOUS LINE (BUT NOT OFF SCREEN)

WBTAB:	TLNE	F,XPC		;GOT POINTER TO CURRENT POSITION?
	PUSHJ	P,MAKCPT	;NO - RE-MAKE IT
	TLNE	F,XPL		;IS CURSOR BEYOND END OF BUFFER?
	JRST	WBTABO		;YES - MOVE IT TO END OF LAST LINE
	JUMPE	CM,WBTABB	;IF AT START OF LINE, MOVE TO END OF PREVIOUS
	MOVE	PT,CHRPTR
	JRST	.+4		;START WITH CHARACTER AT CURSOR

WBTABS:	ADD	PT,[70000,,0]	;SKIP SPACES AFTER WORD
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	LDB	T1,PT		;GET IT
	JUMPE	T1,WBTABS	;IGNORE IF NULL
	CAIE	T1," "		;SPACE
	CAIN	T1,11		;  OR TAB?
	JRST	WBTABS		;YES - SKIP UNTIL NOT ONE OF THOSE
	CAIN	T1,12		;NO - GOT A CARRIAGE RETURN?
	JRST	WBTABL		;YES - CHECK FOR END OF LINE

WBTABC:	ADD	PT,[70000,,0]	;SKIP TO BEGINNING OF PREVIOUS WORD
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	LDB	T1,PT		;GET IT
WBTBC1:	CAIE	T1," "		;IS IT A SPACE
	CAIN	T1,11		;  OR A TAB?
	JRST	WBTABX		;YES - DONE
	CAIN	T1,12		;NO - GOT A LINEFEED?
	JRST	WBTABL		;YES - CHECK FOR END OF LINE
	JRST	WBTABC		;NO - KEEP SKIPPING

WBTABX:	MOVEM	PT,CHRPTR	;SAVE POINTER TO START OF NEXT WORD
	MOVE	PT,LINPTR	;GET POINTER TO START OF LINE
	JRST	WBTABE		;AND FINISH OFF

WBTABL:	ADD	PT,[70000,,0]	;POINT TO PREVIOUS CHARACTER
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	LDB	T1,PT		;GET CHARACTER BEFORE <LF>
	CAIE	T1,15		;CARRIAGE RETURN?
	JRST	WBTBC1		;NO - KEEP LOOKING
WBTBL1:	SETZ	CM,		;YES - POSITION TO START OF THE LINE
	TLO	F,XPC		;MAKE CHAR PTR GET REMADE
	JRST	DISCUR		;POSITION CURSOR; DONE

WBTABB:	SOJL	RW,HOME		;MOVE UP A LINE - IF AT TOP, GO HOME
	MOVE	T3,LINPTR	;GET POINTER TO START OF LINE
	EXCH	T3,DISPTR	;FUDGE IT TO BE DISPLAY PTR
	MOVEI	T4,1		;BACK UP TO START OF PREVIOUS LINE
	JUMPN	SL,[MOVE  T1,LINPTR ;IF SLIDE, PRETEND POINTING
		    MOVEM T1,CHRPTR ;TO START OF LINE
		    JRST  .+1]
	PUSHJ	P,BAKDPT
	MOVEM	T3,DISPTR	;SAVE REAL DISPLAY POINTER AGAIN
	MOVEM	PT,LINPTR	;SAVE RE-DONE LINE POINTER

	MOVE	T4,CHRPTR	;NOW FIND END OF LINE
WBTBB1:	ADD	T4,[70000,,0]	;POINT TO PREVIOUS CHARACTER
	JUMPGE	T4,.+2
	SUB	T4,[430000,,1]
WBTBB2:	LDB	T1,T4		;GET PREVIOUS CHARACTER
	CAIN	T1,15		;CARRIAGE RETURN?
	JRST	WBTBB1		;YES - SKIP IT
	CAIE	T1," "		;TRAILING SPACE
	CAIN	T1,11		;  OR TAB?
	JRST	WBTBB1		;YES - SKIP IT
	CAIN	T1,12		;NOTHING ON THIS LINE?
	JRST	[TLZE  F,FLG	;YES - WANT TO RE-DO RW?
		 PUSHJ P,CALCRW	;YES (ONLY IF BEYOND END OF BUFFER)
		 JRST  WBTBL1]	;MOVE TO START OF LINE
	MOVEM	T4,CHRPTR	;SAVE CHARACTER POINTER
	TLZE	F,FLG		;WANT TO RE-DO RW?
	PUSHJ	P,CALCRW	;YES (ONLY IF BEYOND END OF BUFFER)
	MOVE	PT,LINPTR	;SAVE RE-DONE LINE POINTER

WBTABE:	SETZ	CM,		;CLEAR COLUMN NUMBER
WBTBE0:	CAMN	PT,CHRPTR	;UP TO CHARACTER POSITION?
	JRST	WBTBE1		;YES - FINISH OFF
	ILDB	T1,PT		;GET NEXT CHARACTER
	JUMPE	T1,WBTBE0	;IGNORE IF NULL
	CAIE	T1,11		;TAB?
	AOJA	CM,WBTBE0	;NO - COUNT AS ONE CHARACTER
	TRZ	CM,7		;YES - COUNT THE TAB
	ADDI	CM,10
	JRST	WBTBE0		;AND LOOP

WBTBE1:	SUB	CM,SL		;REMOVE THE SLIDE FROM THE COLUMN
	JUMPL	CM,WBTBE2	;JUMP IF OFF THE LEFT
	CAMG	CM,CPL.1	;OFF THE RIGHT?
	JRST	DISCUR		;NO - GO DISPLAY
	SKIPA	CM,CPL.1	;POSITION CURSOR AT RIGHT
WBTBE2:	SETZ	CM,		;POSITION CURSOR AT LEFT
	TLO	F,XPC		;COLUMN POINTER IS NOT GOOD
	JRST	DISCUR

WBTABO:	TLO	F,FLG		;SET FLAG SO RW WILL BE REMADE
	MOVE	T4,CHRPTR	;GET POINTER TO CURRENT CHARACTER
	JRST	WBTBB2		;BACK UP TO END OF LAST LINE

;HERE ON LINEFEED, WHICH ERASES THE LINE THAT THE CURSOR GOES TO

LNFPAR:	TLNN	TM,LSD		;IS LINEFEED REALLY A CURSOR DOWN?
	JRST	ILCERR		;NO - ENTER LINEFEED IS ILLEGAL
	MOVEI	DO,34		;YES - DO A DOWN INSTEAD
	JRST	DWNARG

LNFEED:	TLNE	TM,LSD		;IS LINEFEED REALLY A CURSOR DOWN?
	JRST	[MOVEI DO,34	;YES - DO A DOWN INSTEAD
		 JRST  DOWN]
	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	TLO	F,CHG		;SAY FILE HAS BEEN MODIFIED
	CAMN	RW,LPP.1	;AT BOTTOM OF SCREEN?
	JRST	LNFERR		;YES - ILLEGAL
	AOJ	RW,		;MOVE TO NEXT ROW
	MOVEI	T1,15		;MOVE TO START OF LINE
	IDPB	T1,TY
	PUSHJ	P,CDOWN		;MOVE DOWN ONE
	PUSHJ	P,CLRLNA	;ERASE THE ENTIRE LINE
	PUSHJ	P,POSCUR
	TLZ	F,XPL!PCM	;SAY LINE POINTER IS BE GOOD; KILL MARK
	PUSHJ	P,MAKLPT	;AND MAKE IT (IN LINPTR AND PT)
	SETZ	T2,		;GET A NULL
LNFED1:	ILDB	T1,PT		;GET A CHARACTER
	CAIN	T1,15		;CARRIAGE RETURN?
	JRST	LNFED3		;YES - CHECK FOR END OF LINE
LNFED2:	DPB	T2,PT		;ELSE NULL OUT THE CHARACTER
	JRST	LNFED1		;AND GET ANOTHER

LNFED3:	MOVE	T4,PT		;GET FRAGGABLE POINTER
	ILDB	T1,T4		;GET (MAYBE) LINEFEED
	CAIE	T1,12		;IS IT REALLY?
	JRST	LNFED2		;NO - JUST NULL OUT THE <CR>
	TLO	F,XPC		;SAY CHARACTER POINTER IS BAD
	JRST	LOOP		;DONE

LNFERR:	MOVEI	T1,[ASCIZ /#Can't erase last line of display/]
	JRST	ERROR
SUBTTL	Search for string

;HERE FOR THE SEARCH BACKWARD COMMAND

SRCBAK:	MOVE	T3,[POINT 7,SRCKEY]
	PUSHJ	P,PELS.1	;GET SEARCH KEY
	PUSHJ	P,ERASPM	;ERASE PARAMETER

SRBNPM:	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POINTER
	MOVE	T0,DISPTR	;GET POINTER TO TOP OF SCREEN
	MOVE	PT,CHRPTR	;GET POINTER TO CURRENT POSITION
	MOVE	T4,[350700,,SRCKEY] ;AND POINTER TO START OF SEARCH KEY
	LDB	T3,T4		;GET THE FIRST KEY CHARACTER
	TRNE	F,NLC		;WANT CASE INDEPENDENCE?
	JRST	[CAIL T3,"a"	;YES - LOWER CASE?
		 SUBI T3,40	;YES - CONVERT TO UPPER
		 JRST .+1]	;CONTINUE
	JUMPN	T3,SRCBK3	;O.K. IF SOMETHING TO SEARCH FOR
	JRST	SRXERR		;ELSE ERROR

SRCBK1:	ADD	PT,[70000,,0]	;NO - BACK POINTER UP A NOTCH
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
SRCBK3:	CAMN	PT,[010700,,BUFFER-1] ;AT START OF FILE YET?
	JRST	SRCERR		;YES - NOT-FOUND ERROR
	LDB	T1,PT		;GET A CHARACTER
	CAMN	T0,PT		;BACK TO START OF SCREEN?
	PUSHJ	P,SRCDKY	;YES - REMIND USER WHAT KEY IS
	TRNE	F,NLC		;WANT CASE INDEPENDENCE?
	JRST	[CAIL T1,"a"	;YES - LOWER CASE?
		 SUBI T1,40	;YES - CONVERT TO UPPER
		 JRST .+1]	;CONTINUE
	CAMN	T1,T3		;SAME AS FIRST CHAR OF KEY?
	JRST	SRCB2A		;YES - CHECK REST OF MATCH
	CAIE	T3,37		;GOT A WILD KEY CHARACTER?
	JRST	SRCBK1		;NO - KEEP GOING

SRCB2A:	MOVEM	PT,SRCPTR	;SAVE POINTER TO BUFFER
TOPS10<	PUSHJ	P,SRCIPT	;SEE IF USER WANTS TO INTERRUPT
>
SRCBK2:	ILDB	T2,T4		;GET NEXT CHARACTER OF KEY
	JUMPE	T2,SRCMAT	;IF NULL, GOT A MATCH
	ILDB	T1,PT		;LIKEWISE FROM BUFFER
	JUMPE	T1,.-1		;IGNORE IF NULL
	TRNE	F,NLC		;WANT CASE INDEPENDENCE?
	JRST	[CAIL T2,"a"	;YES - GOT A LOWER CASE?
		 SUBI T2,40	;YES - CONVERT TO UPPER
		 CAIL T1,"a"	;GOT A LOWER CASE?
		 SUBI T1,40	;YES - CONVERT TO UPPER
		 JRST .+1]	;CONTINUE
	CAME	T1,T2		;SAME?
	CAIN	T2,37		;  OR KEY CHAR IS WILD?
	JRST	SRCBK2		;YES - O.K. SO FAR

	MOVE	PT,SRCPTR	;NO - NO MATCH - RESTORE BUFFER POINTER
	MOVE	T4,[350700,,SRCKEY] ;AND POINTER TO START OF SEARCH KEY
	JRST	SRCBK1		;AND CONTINUE LOOKING FOR THE ENTIRE KEY

TOPS10<
SRCIPT:	INCHRS	T1		;SEE IF USER TYPED ANYTHING
	  POPJ	P,		;NO - CONTINUE
	ANDI	T1,177		;YES - GET THE CHARACTER
	CAIN	T1,177		;IS IT A RUBOUT?
	JRST	RUBSRC		;YES - ABORT THE SEARCH
	POPJ	P,		;NO - CONTINUE
>
;HERE FOR THE SEARCH FORWARD COMMAND

SRCFWD:	MOVE	T3,[POINT 7,SRCKEY]
	PUSHJ	P,PELS.1	;GET SEARCH KEY
	PUSHJ	P,ERASPM	;ERASE PARAMETER

SRFNPM:	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POINTER
	CAMN	RW,LPP.1	;IS CURSOR ON THE BOTTOM LINE?
	JRST	[PUSHJ P,SRCDKY ;YES - SCREEN WILL BE RE-DONE
		 JRST  SRFNP1]
	TLZE	F,XPB		;GOT A VALID BOTTOM POINTER?
	PUSHJ	P,MAKBPT	;NO - RE-MAKE IT
	MOVE	T0,BOTPTR	;GET BOTTOM PTR TO SEE WHEN SRCH IS OFF SCREEN
SRFNP1:	MOVE	PT,CHRPTR	;GET POINTER TO CURRENT POSITION
	ILDB	T1,PT		;SKIP FIRST REAL CHARACTER
	JUMPE	T1,.-1		;  AT THIS LOCATION
	MOVE	T4,[350700,,SRCKEY] ;AND POINTER TO START OF SEARCH KEY
	LDB	T3,T4		;GET THE FIRST KEY CHARACTER
	JUMPE	T3,SRXERR	;ERROR IF NOTHING TO SEARCH FOR
	TRNE	F,NLC		;WANT CASE INDEPENDENCE?
	JRST	[CAIL T3,"a"	;YES - LOWER CASE?
		 SUBI T3,40	;YES - CONVERT TO UPPER
		 JRST .+1]	;CONTINUE

SRCFW1:	CAMN	PT,EN		;AT END OF FILE YET?
	JRST	SRCERR		;YES - NOT-FOUND ERROR
	ILDB	T1,PT		;ELSE GET A CHARACTER
	CAMN	T0,PT		;GOING OFF THE BOTTOM OF THE SCREEN?
	PUSHJ	P,SRCDKY	;YES - REMIND USER WHAT KEY IS
	TRNE	F,NLC		;WANT CASE INDEPENDENCE?
	JRST	[CAIL T1,"a"	;YES - LOWER CASE?
		 SUBI T1,40	;YES - CONVERT TO UPPER
		 JRST .+1]	;CONTINUE
	CAMN	T1,T3		;SAME AS FIRST CHAR OF KEY?
	JRST	SRCF2A		;YES - CHECK REST OF KEY
	CAIE	T3,37		;WILD SEARCH CHARACTER?
	JRST	SRCFW1		;NO - KEEP GOING

SRCF2A:	MOVEM	PT,SRCPTR	;SAVE POINTER TO BUFFER
TOPS10<	PUSHJ	P,SRCIPT	;SEE IF USER WANTS TO INTERRUPT
>
SRCFW2:	ILDB	T2,T4		;GET NEXT CHARACTER OF KEY
	JUMPE	T2,SRCMAT	;IF NULL, GOT A MATCH
SRCFW3:	ILDB	T1,PT		;LIKEWISE FROM BUFFER
	JUMPE	T1,SRCFW3	;IGNORE IF NULL
	TRNE	F,NLC		;WANT CASE INDEPENDENCE?
	JRST	[CAIL T1,"a"	;YES - LOWER CASE?
		 SUBI T1,40	;YES - CONVERT TO UPPER
		 CAIL T2,"a"	;LOWER CASE?
		 SUBI T2,40	;YES - CONVERT TO UPPER
		 JRST .+1]	;CONTINUE
	CAME	T1,T2		;SAME?
	CAIN	T2,37		;  OR KEY CHAR IS WILD?
	JRST	SRCFW2		;YES - O.K. SO FAR

	MOVE	PT,SRCPTR	;NO - NO MATCH - RESTORE BUFFER POINTER
	MOVE	T4,[350700,,SRCKEY] ;AND POINTER TO START OF SEARCH KEY
	JRST	SRCFW1		;AND CONTINUE LOOKING FOR THE ENTIRE KEY

;SUBROUTINE FOR WHEN THE SEARCH HAS GONE BEYOND THE LIMITS OF THE SCREEN
;DISPLAY SEARCH KEY ON BOTTOM LINE AND SET T0 TO -1
;(THUS T0/-1 IF MATCH NOT ON SCREEN, ELSE NONZERO). FRAGS T1 ONLY.

SRCDKY:	TRNE	F,XCT		;EXECUTING?
	JRST	SRCDK1		;YES - DON'T DISPLAY
	PUSHJ	P,CBOTOM	;MOVE CURSOR TO BOTTOM
	PUSHJ	P,PROTON	;TURN PROTECTION ON
	MOVEI	T1,[ASCIZ /Search for: /]
	PUSHJ	P,PUTSTG	;DISPLAY SEARCH KEY
	MOVEI	T1,SRCKEY
	PUSHJ	P,PUTSTC
	PUSHJ	P,PROTOF	;TURN PROTECTION OFF
SRCDK1:	SETO	T0,		;CLEAR ON-SCREEN INDICATOR
	JRST	PUTTYP		;OUTPUT ALL THIS AND RETURN

;HERE WHEN A SEARCHER HAS FOUND A MATCH - DISPLAY A FEW LINES BEFORE MATCH

SRCMAT:	MOVE	PT,SRCPTR	;RESTORE PTR TO START OF MATCH
	LDB	T1,PT		;GET FIRST CHARACTER OF MATCH
	CAIN	T1,12		;LINEFEED?
	IBP	PT		;YES - POINT TO FIRST CHARACTER
	MOVEM	PT,SRCPTR	;SAVE ADJUSTED POINTER
	CAMN	T0,[-1]		;IS MATCH ON SCREEN?
	JRST	SRCMT0		;NO - GO RE-DISPLAY

;HERE IF MATCH IS ON SCREEN - JUST POSITION CURSOR AT MATCH

	ADD	PT,[70000,,0]	;BACK IT UP A NOTCH
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	MOVEM	PT,CHRPTR	;CHARACTER POSITION WILL BE START OF THE MATCH
	PUSHJ	P,CALCRW	;CALCULATE PROPER VALUE OF RW
	MOVE	PT,LINPTR	;POINT TO START OF LINE
	PUSHJ	P,CALCCM	;CALCULATE PROPER VALUE OF CM
	  PUSHJ	P,DISPLL	;RE-DISPLAY IF THERE WAS A SLIDE
	TLZ	F,XPL!XPC
	JRST	DISCUR		;POSITION CURSOR TO START OF MATCH; RETURN

;HERE IF MATCH IS NOT ON THE SCREEN

SRCMT0:	PUSHJ	P,SRCSET	;SET UP THE RIGHT POINTERS
	PUSHJ	P,DISPLL	;RE-DISPLAY THE ENTIRE SCREEN
	JRST	DISCUR		;POSITION TO START OF MATCH; RETURN

SRCSET:	MOVE	T4,LPR		;BACK UP ONE ROLL'S WORTH
	AOJ	T4,
	MOVEM	PT,DISPTR	;FROM THE MATCH
	ADD	PT,[70000,,0]	;BACK IT UP A NOTCH
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	MOVEM	PT,CHRPTR	;CHARACTER POSITION WILL BE START OF THE MATCH

	PUSHJ	P,BAKDPT
	MOVE	RW,LPR		;POINT TO START OF LINE WITH MATCH
	SUB	RW,T4		;  (WHICH MAY NOT BE THE FULL DISTANCE DOWN)
	PUSHJ	P,MAKLPT	;MAKE LINE PTR (IN LINPTR AND PT)
	PUSHJ	P,CALCCM
	  TLZA	F,XPL!XPC!FBL	;ROW AND COLUMN POINTERS ARE RIGHT
	TLZ	F,XPL!XPC!FBL	;  AND BOTTOM LINE IS GOOD, TOO
	TLO	F,XPB		;BUT BOTTOM POINTER IS NOT GOOD
	POPJ	P,

SRXERR:	MOVEI	T1,[ASCIZ /#######Nothing to search for/]
	JRST	ERROR
SRCERR:	MOVEI	T1,[ASCIZ /##########Search failure/]
	JRST	ERROR
SUBTTL	Set INSERT mode

;HERE ON ENTER-CONTROL-CHARACTER COMMAND. SET FLAG SO IF NEXT
;CHARACTER IS ASCII IT WILL BE MADE A CONTROL CHARACTER
;(ELSE THERE IS NO EFFECT)

ENTCCH:	TLO	F,CCH		;SET THAT OL' FLAG
	JRST	INTEND		;THAT'S ALL



;HERE ON INSERT MODE TOGGLE COMMAND. SET FLAG SO CHARACTERS TYPED
;WILL BE INSERTED AT CURSOR POSITION, AND NOT REPLACE THE EXISTING CHARACTER
;TYPING THE COMMAND AGAIN REVERSES THIS EFFECT

INSMOD:	TLNE	TM,BEP		;WANT TO BEEP INSTEAD OF WORKING WITH MESSAGE?
	JRST	INSBEP		;YES - GO DO SO
	TRCN	F,IMD		;TOGGLE THE INSERT MODE FLAG - JUST TURNED ON?
	JRST	INSMDO		;YES - DISPLAY MESSAGE AT BOTTOM
	PUSHJ	P,CBOTOM	;NO - MOVE TO BOTTOM LINE AND CLEAR IT
	PUSHJ	P,MAKLPT	;GET CURRENT LINE POINTER
	TLZ	F,FBL		;BOTTOM LINE IS HEREBY GOOD
	TLZE	F,XPB		;ERASE MESSAGE AT BOTTOM
	PUSHJ	P,MAKBPT	;GET A VALID BOTTOM POINTER
	SKIPN	PT,BOTPTR	;  AT THE BOTTOM OF THE SCREEN
	JRST	INSMDF		;IF BEYOND FILE, PUT UP THE FENCE
	MOVEI	T4,1		;ELSE WRITE ONE LINE
	TLNN	TM,NEL		;LEAVE LAST LINE ALONE?
	PUSHJ	P,DISPLY	;NO - RE-DO IT
	TLNE	TM,NEL		;[CSM] No end line from file?
	 PUSHJ	P,CBOTOM	;[CSM] Yes, clear it from screen
	PUSHJ	P,POSCUR	;REPOSITION THE CURSOR
	JRST	LOOP		;AND LOOP

INSMDF:	PUSHJ	P,FNCPUT	;DISPLAY THE FENCE
	PUSHJ	P,POSCUR	;REPOSITION THE CURSOR
	JRST	LOOP		;DONE

INSMDO:	PUSHJ	P,INSMSG	;OUTPUT INSERT MODE MESSAGE
	JRST	LOOP		;DONE

INSBEP:	TRCN	F,IMD		;TOGGLE THE INSERT MODE FLAG - JUST TURNED ON?
	JRST	INSBP1		;YES - BEEP ONCE
	MOVEI	T1,7		;BEEP ONCE
TOPS10<	IONEOU T1>
TOPS20<	PBOUT>
	MOVEI	T1,^D0500	;WAIT A WHILE
TOPS10<	HIBER T1,
	      JFCL>
TOPS20<	DISMS>
INSBP1:	MOVEI	T1,7		;BEEP AGAIN
TOPS10<	IONEOU T1>
TOPS20<	PBOUT>
	JRST	LOOP

;SUBROUTINE TO OUTPUT INSERT MODE MESSAGE

INSMSG:	TLNE	TM,BEP		;BEEPING?
	POPJ	P,		;YES - NO MESSAGE
	PUSHJ	P,CBOTOM	;ELSE MOVE TO BOTTOM LINE AND CLEAR IT
	PUSHJ	P,PROTON	;TURN PROTECTION ON
	MOVEI	T1,[ASCIZ / *** INSERT MODE *** /]
	PUSHJ	P,PUTSTG
	PUSHJ	P,PROTOF
	TLO	F,FBL		;MARK BOTTOM LINE AS FRAGGED
	JRST	POSCUR		;REPOSITION THE CURSOR AND RETURN
SUBTTL	PERCEN - Goto position in file

;HERE TO GO TO SOME GIVEN PERCENT OF THE FILE
;EXCEPTION: GOTO 100% PUTS UP THE LAST LPR LINES INVARIABLY

PERCEN:	MOVE	T4,GOPERC	;SET UP LAST TIME'S NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	JUMPE	T1,.+2		;JUMP IF JUST ENTER-PERCENT TYPED
	SKIPA	T4,PARG1	;ELSE GET PERCENT TO MOVE
	MOVEI	T4,^D100	;TREAT ENTER-PERCENT LIKE ENTER-100-PERCENT
	PUSHJ	P,RESTPM
	JUMPL	T4,PERERR	;ERROR IF NEGATIVE
	CAILE	T4,^D100	;OR LARGER THAN 100
	JRST	PERERR
	MOVEM	T4,GOPERC	;ELSE SAVE AS NEW NOMINAL
PERNPM:	MOVE	T4,GOPERC	;SET UP LAST TIME'S NOMINAL
	SETZB	RW,CM		;PUT CURSOR IN UPPER LEFT
	JUMPE	T4,PERCST	;IF GOTO 0 PERCENT, GO TO START
	TLO	F,XPL!XPC!XPB	;MARK NO POINTERS AS VALID
	CAIN	T4,^D100	;GOTO 100 PERCENT?
	JRST	PERCND		;YES - HANDLE SPECIALLY

	HRRZ	T1,EN		;GET SIZE OF FILE
	SUBI	T1,BUFFER
	IMUL	T1,T4		;TIMES DISTANCE USER WANTS TO GO
	IDIVI	T1,^D100	;DIVIDED INTO 100-WORD PIECES
	ADD	T1,[010700,,BUFFER-1] ;GIVES POINTER INTO FILE
	MOVEM	T1,DISPTR	;SAVE AS NEW DISPLAY POINTER
	MOVEI	T4,1		;GO TO THE START OF THE NEXT LINE
	CAME	T1,[010700,,BUFFER-1] ;DON'T BACK UP IF AT START
	PUSHJ	P,ADVDPT
	PUSHJ	P,DISPLL	;RE-DISPLAY THE SCREEN
	JRST	DISCUR		;REPOSITION AND GET ANOTHER COMMAD

PERCND:	MOVEM	EN,DISPTR	;DISPLAY FROM ONE ROLLS-WORTH FROM END OF FILE
	MOVE	T4,LPR
	PUSHJ	P,BAKDPT

	MOVE	T2,EN		;POINT TO LAST REAL FILE CHARACTER
PERCD1:	ADD	T2,[70000,,0]	;BACK IT UP A NOTCH
	JUMPGE	T2,.+2
	SUB	T2,[430000,,1]
	LDB	T1,T2		;GET CHARACTER
	CAIGE	T1," "		;IS IT A REAL CHARACTER?
	JRST	PERCD1		;NO - KEEP LOOKING

	HRRZ	T1,DISPTR	;IS CHARACTER POINTER ON SCREEN?
	CAIL	T1,(T2)
	JRST	[SETZB RW,CM	;NO - MOVE CURSOR HOME
		 TLO   F,XPC	;CHARACTER POINTER IS BAD
		 JRST  PERCD2]	;FINISH OFF
	MOVEM	T2,CHRPTR	;POSITION CURSOR TO VERY END OF FILE
	PUSHJ	P,CALCRW	;CALCULATE PROPER VALUE OF RW
	MOVE	PT,LINPTR	;POINT TO START OF LINE
	PUSHJ	P,CALCCM	;CALCULATE PROPER VALUE OF CM
	  AOJA  RW,.+2		;IF SLIDE, MOVE TO START OF NEXT LINE
	AOJA	CM,PERCD2	;MOVE TWO COLUMNS AWAY FROM LAST CHARACTER
	SETZB	CM,SL		;ELSE MOVE TO START OF NEXT LINE
	TLOA	F,XPL!XPC!XPB	;AND MARK NO POINTERS AS VALID
PERCD2:	TLO	F,XPC!XPB	;LINE POINTER IS THE ONLY ONE O.K.
	PUSHJ	P,DISPLL	;RE-DISPLAY THE SCREEN
	JRST	DISCUR		;REPOSITION AND GET ANOTHER COMMAD

PERCST:	PUSHJ	P,PNTSTT	;SET UP POINTERS TO START OF FILE
	PUSHJ	P,DISPLL	;RE-DISPLAY THE SCREEN
	JRST	DISCUR		;RE-POSITION AND GET ANOTHER COMMAD

PERERR:	MOVEI	T1,[ASCIZ /#Percent must be between 0 and 100/]
	JRST	ERROR
SUBTTL	EXIT and ABORT commands

EXIPAR:	TLO	F,FLG		;SET FLAG TO DO A RUN ON COMPIL
EEXIT:
TOPS10<	CLOSE	1,		;[CSM] Close to clear PIM mode
	OPEN	1,[EXP 1,'TTY   ',0] ;[CSM] Open in ASCII LINE mode
	  JFCL			;[CSM] So that typeahead is echoed properly
;[CSM] There is a problem with SET TTY DEFER in the 7.01 monitor.  Only the 1st
;[CSM] character of typeahead gets echoed, the rest of the line doesn't appear
;[CSM] until the job hits monitor level, which can take minutes on ENTER ^Z.
	SKPINL			;[CSM] This TTCALL tells monitor to allow
	 JFCL			;[CSM]  the deferred echo of a full line
>
	PUSHJ	P,CLRALL	;HOME AND CLEAR SCREEN
	PUSHJ	P,PUTTYP	;OUTPUT IT NOW
IFN SAVETY,<
	OPEN	5,DEBBLK	;SAVE OFF THE DEBUG COMMAND FILE
	  HALT	.
	ENTER	5,DEBFIL
	  HALT	.
	OUTPUT	5,DEBCCL
	RELEAS	5,
>
TOPS10<	MOVEI	PT,FILBLK	;POINT TO NAME OF CURRENT FILE
>
	MOVEI	T4,FILSPC
	SKIPE	INJFN		;IS THERE A JFN?
	PUSHJ	P,SAVFIL	;YES - SAVE THE FILE
	SKIPE	FILSPC		;GOT A CURRENT FILE?
	JRST	.+3		;YES - CONTINUE
	SKIPN	OLDSPC		;NO - GOT AN OLD FILE?
	JRST	ABORT		;NEITHER - DON'T WRITE nnnSTT.TMP

	MOVE	TY,[POINT 7,PIKBUF+PCBSIZ-400]
	MOVEI	T1,FILSPC	;GET CURRENT FILE SPECS
	MOVE	T4,DISPTR	;AND DISPLAY POINTER
	PUSHJ	P,EXIFIL	;OUTPUT THE STATUS OF THE ACTIVE FILE
	SKIPN	OLDSPC		;IS THERE AN ALTERNATE FILE?
	JRST	EEXIT0		;NO - DON'T OUTPUT ITS STATUS
	MOVEI	T1,OLDSPC	;GET ALTERNATE FILE SPECS
	MOVE	T4,SAVEDP	;AND DISPLAY POINTER
	HRRZ	RW,SAVERW
	HLRZ	CM,SAVERW
	MOVE	SL,SAVESL
	PUSHJ	P,EXIFIL	;OUTPUT THE STATUS OF THE ALTERNATE FILE
EEXIT0:	SETZ	T1,		;MAKE SURE LAST WORD IS NULL
	IDPB	T1,TY
	IDPB	T1,TY
	IDPB	T1,TY
	IDPB	T1,TY
	IDPB	T1,TY
	HRRZS	TY		;FIND SIZE OF STUFF TO OUTPUT
	SUBI	TY,PIKBUF+PCBSIZ-400
TOPS10<		;[CSM] Try writing TMP:SED before using DSK:000SST.TMP
	MOVN	T1,TY		;[CSM] Get negative word count
	HRLM	T1,STTCCL	;[CSM] Store in IOWD
	MOVE	T1,[3,,STTCCL-1];[CSM] Code to write file
	TMPCOR	T1,		;[CSM] Write TMP:SED
	  SKIPA			;[CSM] Can't, write to disk
	 JRST	EEXIT1		;[CSM] Did it
>
	HRROI	T2,STTFIL	;SET UP nnnSTT.TMP FILE FOR OUTPUT
	PUSHJ	P,SETOUT
TOPS10<	OUTPUT	5,STTCCL	;OUTPUT THE STATUS STUFF
	RELEAS	5,		;MAKE IT SOUP (YET)
EEXIT1:	MOVE	TY,[POINT 7,TYPBUF]

ABORT1:	MOVEI	T1,.TOPAG+.TOSET;Change TTY PAGE setting
	MOVE	T2,TTYNUM	;For this terminal
	MOVEI	T3,1		;To be ON
	MOVE	T4,[XWD 3,T1]
	TRMOP.	T4,
	  JFCL
	MOVE	T1,[5,,SAVEAC]	;SAVE ACS IN CASE OF REENTER
	BLT	T1,SAVEAC+12
	PUSHJ	P,@RTX(TM)	;CALL USER'S EXIT ROUTINE
	RELEAS	1,		;[CSM] Finished with TTY after RTX routine
	TLZE	F,FLG		;WANT TO EXIT AND GO?
	JRST	EXITGO		;YES
	EXIT	1,
	JRST	REEERR		;[CSM] Treat ".CONTINUE" as ".REENTER"

EXITGO:	MOVE	T1,[1,,GOBLK]	;CODE TO RUN COMPIL
	RUN	T1,		;LET COMPIL TAKE OVER
	  HALT	START		;IF IT DOESN'T WORK, ACT INNOCENT
>
TOPS20<	MOVE	T2,[POINT 7,PIKBUF+PCBSIZ-400]
	SETZ	T3,
	SOUT			;WRITE OUT THE STATUS
	CLOSF			;CLOSE THE FILE
	  HALTF
	MOVE	TY,[POINT 7,TYPBUF]

ABORT1:	MOVEI	T1,.PRIIN
	MOVE	T2,FMDSAV	;GET BACK THE ORIGINAL FMOD WORD
	SFMOD
	STPAR
	PUSHJ	P,@RTX(TM)	;CALL USER'S EXIT ROUTINE
	HALTF			;BYE
>
ABORT:
TOPS10<	CLOSE	1,		;[CSM] Close to clear PIM mode
	OPEN	1,[EXP 1,'TTY   ',0] ;[CSM] Open in ASCII LINE mode
	  JFCL			;[CSM] So that typeahead is echoed properly
>
	MOVEI	T4,FILSPC	;TELL USER THAT FILE IS NOT CHANGED
	PUSHJ	P,SAVMGN
	JRST	ABORT1		;THEN GO FINISH OFF

;SUBROUTINE TO OUTPUT A FILESPEC STATUS LINE.
;ENTER WITH T1/ADDR FILESPEC, T4/DISPTR; ALSO RW, CM, SL SET UP
;USES T0, T1, T2, T3

EXIFIL:	PUSHJ	P,PUTSTG	;PUT FILESPECS IN BUFFER
	JUMPE	T4,EXIFL1	;IF DISPLAY PTR ZERO, JUST END LINE
	HRRZ	T2,T4		;GET DISPLAY POINTER
	SUBI	T2,BUFFER	;CONVERT TO CHARACTER POSITION
	IMULI	T2,5
	HLRZ	T0,T4		;FIND CHARACTERS IN LAST WORD, TOO
	SETZ	T1,
	CAME	T0,PTRTBL(T1)
	AOJA	T1,.-1
	ADD	T2,T1
	MOVE	T1,[ASCII ?/FD:?]
	PUSHJ	P,EXINUM	;ALWAYS OUTPUT DISPLAY POINTER
	MOVE	T1,[ASCII ?/FR:?]
	SKIPE	T2,RW		;IS ROW ZERO?
	PUSHJ	P,EXINUM	;NO - OUTPUT IT
	SKIPE	T2,CM		;IS COLUMN ZERO?
	PUSHJ	P,EXICOL	;NO - OUTPUT IT
	SKIPE	T2,SL		;IS SLIDE ZERO?
	PUSHJ	P,EXISLI	;NO - OUTPUT IT
EXIFL1:	MOVEI	T1,15		;END LINE WITH A CARRIAGE RETURN
	IDPB	T1,TY
	MOVEI	T1,12
	IDPB	T1,TY
	POPJ	P,		;DONE

EXISLI:	SKIPA	T1,[ASCII ?/FS:?]
EXICOL:	MOVE	T1,[ASCII ?/FC:?]
EXINUM:	PUSHJ	P,PUTSQ1	;OUTPUT THE SWITCH NAME (IN T1)
	MOVE	T1,T2		;GET THE VALUE
	JRST	PUTNUM		;OUTPUT IT AND RETURN
SUBTTL	Insert line

;HERE TO ADD BLANK LINES TO THE BUFFER

OPENLN:	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	MOVE	T4,ADDLNS	;GET LAST TIME'S NOMINAL
	TLNN	F,ENT		;IS THERE A PARAMETER TYPED?
	JRST	OPLNPM		;NO - USE THE ONE ALREADY SET UP
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET LINES TO ADD
	MOVEM	T4,ADDLNS	;SAVE AS NEW NOMINAL
	TRNE	F,CMV		;CURSOR MOVEMENT?
	JRST	[MOVE  T1,PARG2    ;YES - GET SPACES TO OPEN, TOO
		 ADD   T1,SAVPOS+1 ;COUNT SPACES FROM LEFT MARGIN
		 ADD   T1,SL
		 MOVEM T1,ADDLSP
		 JRST  OPLNPM-1]
	SETZM	ADDLSP		;IF NO CURSOR MOVE, CLEAR EXTRA SPACES
	PUSHJ	P,ERASPM	;RESET ENTER MODE
OPLNPM:	JUMPLE	T4,DISCUR	;DONE, IF OPENING ZERO LINES
	TLZ	F,PCM		;CANCEL THE PICK-CLOSE MARK, IF ANY
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	CAIN	T3,11		;IS CHARACTER AT CURSOR A TAB?
	PUSHJ	P,RPLTAB	;YES - REPLACE IT WITH SPACES

	TLO	F,XPB!CHG	;SAY BOTTOM POINTER BAD; FILE MODIFIED
	MOVE	T4,ADDLNS	;GET LINES TO ADD - ANY?
	LSH	T4,1		;MULTIPLY COUNT BY 2, FOR <CR><LF>
	MOVEM	T4,NUMCHR	;GO ADD THAT MANY <LF>S
	MOVEI	T1,12		;  (CHANGE HALF OF 'EM TO <CR>S LATER)
	MOVEM	T1,CHARAC
	PUSHJ	P,MAKCHR

	MOVEI	T1,15		;NOW CHANGE HALF THE <LF>S TO <CR>S
	MOVE	PT,CHRPTR	;GET POINTER TO CURSOR POSITION
	MOVE	T4,ADDLNS	;AND NUMBER OF LINES TO ADD
	IDPB	T1,PT		;SET UP A NEW LINE
	IBP	PT
	SOJG	T4,.-2		;LOOP UNTIL ALL LINES SET UP
	SKIPG	T4,ADDLSP	;NOW GOT SOME SPACES TO ADD?
	JRST	OPNLD0		;NO - JUST RE-DISPLAY
	MOVEM	T4,NUMCHR
	EXCH	PT,CHRPTR
	PUSH	P,PT
	PUSHJ	P,MAKSPC	;ADD THE SPACES
	POP	P,PT		;RESTORE THE REAL CHARACTER POINTER
	EXCH	PT,CHRPTR
OPNLD0:	MOVE	T4,ADDLNS	;GET SIZE OF OPEN
	PUSHJ	P,OPENLD	;OPEN UP THE SCREEN **MAY NOT RETURN**
	JUMPN	CM,OPNLDX	;JUMP IF STARTING WITHIN A LINE
	SKIPN	ADDLSP		;ELSE ENDING WITH A PARTIAL LINE?
	JRST	OPNLDX+1	;NO - JUST POSITION AND LOOP
	PUSHJ	P,CDOWN		;YES - MOVE DOWN
OPNLDX:	PUSHJ	P,DISONE	;RE-DO THAT LINE
	TRNE	F,IMD		;IN INSERT MODE?
	PUSHJ	P,INSMSG	;YES - OUTPUT INSERT MESSAGE
	JRST	DISCUR		;RE-POSITION CURSOR AND RETURN

;SUBROUTINE TO OPEN (T4) LINES ON THE SCREEN (USED BY OPENLN, PUT)
;NOTE: WILL NOT RETURN IF REST OF SCREEN MUST BE DISPLAYED (DOES JRST LOOP)

OPENLD:	MOVE	T1,LPP(TM)	;FIND NUMBER OF LINES BELOW CURSOR
	SUB	T1,RW
	CAMG	T1,T4		;ADDING MORE THAN THAT?
	JRST	[PUSHJ P,POSCUR ;YES - REPOSITION THE CURSOR
		 MOVE  T0,CM	;GET COLUMN POSITION FOR CLEAR
		 PUSHJ P,CLEARP ;CLEAR TO END OF SCREEN
		 JRST  PUTTYP]	;OUTPUT AND RETURN
	SKIPN	T3,ILN(TM)	;CAN TERMINAL OPEN ITS OWN LINES?
	JRST	[POP  P,	;NO - GO REDISPLAY FROM HERE DOWN
		 JRST DISDWN]	;  AND GO DIRECTLY TO LOOP
	PUSHJ	P,POSCUR	;YES - POSITION THE CURSOR
	TLZ	F,FBL		;BOTTOM LINE WILL BE IN GOOD SHAPE
	TLNN	T3,774000	;[CSM] ASCII string?
	TLNN	T3,IDARGS	;[CSM] No, does subroutine take INS/DEL args?
	 JRST	OPNDLA		;[CSM] No, do it one line at a time
	MOVE	T3,RW		;[CSM] Where to do it
	JUMPE	CM,OPNDLB	;[CSM] At beginning of line?
	PUSHJ	P,CLRLNR	;[CSM] No, clear partial line
	MOVEI	T1,CR		;[CSM] Some terminals don't work right
	IDPB	T1,TY		;[CSM]  unless in column 1
	PUSHJ	P,CDOWN		;[CSM] Go to where new line belongs
	MOVEI	T3,1(RW)	;[CSM] Start scrolling below the current line
OPNDLB:	PJRST	@ILN(TM)	;[CSM] Insert T4 lines at row T3

OPNDLA:	JUMPE	CM,OPNLD1+1	;WITHIN A LINE?
	PUSHJ	P,CLRLNR	;YES - CLEAR TO END OF LINE
	MOVEI	T1,15		;DROP TO START OF NEXT LINE
	IDPB	T1,TY
OPNLD1:	PUSHJ	P,CDOWN
	MOVE	T1,T3		;OPEN UP ONE LINE
	PUSHJ	P,PUTSEQ
	SOJG	T4,OPNLD1	;LOOP THROUGH ALL LINES
	POPJ	P,		;DONE
SUBTTL	Delete lines

;HERE TO REMOVE LINES FROM THE BUFFER (NULL THEM OVER, REALLY)

CLOSLN:	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	MOVE	T4,ADDLNS	;SET UP LAST TIME'S NOMINAL
	TLNN	F,ENT		;IS THERE A PARAMETER TYPED?
	JRST	CLLNPM		;NO - USE THE ONE ALREADY SET UP
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET SPACES TO ADD
	MOVEM	T4,ADDLNS	;SAVE AS NEW NOMINAL
	TRNE	F,CMV		;CURSOR MOVEMENT?
	JRST	[MOVE  T1,PARG2 ;YES - GET SPACES TO CLOSE, TOO
		 ADD   T1,SAVPOS+1 ;COUNT SPACES FROM LEFT MARGIN
		 ADD   T1,SL
		 CAIN  T4,0	   ;CLOSING ZERO LINES?
		 MOVE  T1,PARG2    ;YES - COUNT ONLY SPACES PASSED OVER
		 MOVEM T1,ADDLSP
		 JRST  .+2]
	SETZM	ADDLSP		;IF NO CURSOR MOVE, CLEAR EXTRA SPACES
	PUSHJ	P,ERASPM	;ERASE PARAMETER

CLLNPM:	TRZ	F,COV		;ASSUME CLOSE BUFFER WILL NOT OVERFLOW
	TLNE	F,PCM		;HAS A MARK BEEN MADE?
	JRST	CLSMRK		;YES - DO THINGS DIFFERENTLY
	JUMPG	T4,.+3		;IF CLOSING SOME LINES, CONTINUE
	SKIPN	ADDLSP		;IF ZERO LINES, GOT ZERO SPACES TOO?
	JRST	DISCUR		;YES - NOTHING TO DO
	TLO	F,INS!XPB!CHG	;LET LINE BE EXTENDED; BOTPTR BAD; FILE MOD'D
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	TLZ	F,INS
	CAIN	T3,11		;IS CHARACTER AT CURSOR A TAB?
	PUSHJ	P,RPLTAB	;YES - REPLACE WITH SPACES BEFORE CURSOR
	MOVE	PT,CHRPTR	;GET CURRENT CURSOR POSITION
	SETZB	T2,CLSCNT	;AND A NULL, AND PTR TO CLOSE BUFFER
	MOVE	T3,[POINT 7,CLSBUF]
	SKIPN	T4,ADDLNS	;GET NUMBER OF LINES TO CLOSE - ANY?
	JRST	CLSLN3		;NO - JUST GO CLOSE SPACES

CLSLN1:	CAMN	EN,PT		;AT END OF USEABLE BUFFER?
	JRST	CLOSEN		;YES - DO END OF BUFFER-Y THINGS
	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,CLSLN1	;IF NULL, GET ANOTHER ONE
	DPB	T2,PT		;REPLACE IT WITH A NULL
CLSLN2:	CAMN	T3,[010700,,CLSBUF+PCBSIZ-1]
	PUSHJ	P,CLSOVF	;IF ABOUT TO OVERFLOW, STORE ON DISK
	IDPB	T1,T3		;SAVE CHARACTER IN THE CLOSE BUFFER
	AOS	CLSCNT		;BUMP COUNT
	CAIE	T1,15		;CARRIAGE RETURN?
	JRST	CLSLN1		;NO - DRIVE ON

	ILDB	T1,PT		;YES - PICK UP THE <LF>
	DPB	T2,PT		;REPLACE IT WITH A NULL
	CAIE	T1,12		;IS IT REALLY A LINEFEED?
	JRST	CLSLN2		;NO - IT'S NOT THE END OF THE LINE
	SOJG	T4,CLSLN2	;YES - LOOP THROUGH DESIRED NUMBER OF ROWS
	CAMN	T3,[010700,,CLSBUF+PCBSIZ-1]
	PUSHJ	P,CLSOVF	;IF ABOUT TO OVERFLOW, STORE ON DISK
	IDPB	T1,T3		;SAVE THE LINEFEED IN THE CLOSE BUFFER
CLSLN3:	SKIPLE	T4,ADDLSP	;GOT SOME SPACES TO CLOSE TOO?
	PUSHJ	P,CLLSPS	;YES - DO THEM

CLSLN4:	SETZ	T1,		;AND END BUFFER WITH A NULL
	IDPB	T1,T3
	AOS	CLSCNT		;BUMP COUNT FOR <LF>
	TRNE	F,COV		;HAS BUFFER OVERFLOWED?
	PUSHJ	P,CLSLST	;YES - WRITE OUT THE LAST PIECE

	SOSG	SQZCNT		;TIME TO DO A SQUEEZE?
	PUSHJ	P,SQUEZW	;YES - REMOVE ALL NULL WORDS
	TLZE	F,PCM		;WAS THERE A MARK?
	JRST	[PUSHJ P,DISPLL	;YES - RE-DISPLAY THE SCREEN
		 JRST  DISCUR]
	SKIPN	ADDLNS		;REALLY CLOSE ANY LINES?
	JRST	CLSLNL		;NO - JUST SPACES - RE-DO ONE LINE
	SKIPN	T3,DLN(TM)	;CAN TERMINAL DO ITS OWN CLOSES?
	JRST	DISDWN		;NO - DISPLAY ALL FROM HERE DOWN
	MOVE	T4,LPP(TM)	;GET NUMBER OF LINES PER PAGE
	SUB	T4,RW		;LESS CURRENT POSITION
	SUB	T4,ADDLNS	;LESS SIZE OF DELETE, GIVES LINES LEFT
	JUMPL	T4,DISDWN	;IF NONE (BIG DELETE), JUST RE-DISPLAY
;[CSM]	TLNE	F,FNC		;IS FENCE ON SCREEN?
	TLNE	F,FNC!FBL	;[CSM] Is FENCE or INSERT-MODE on screen?
	PUSHJ	P,CBOTOM	;YES - ERASE IT
	MOVE	T4,RW		;MOVE TO START OF THE LINE THE CURSOR IS ON
	PUSHJ	P,POSLIN
	MOVE	T2,ADDLNS	;GET SIZE OF DELETE
	MOVEM	T2,ROLLS	;SET IT UP FOR ROLFW1
	TLNE	F,FBL		;IS BOTTOM LINE O.K.?
	AOS	ROLLS		;NO - REWRITE ONE MORE LINE
	TLNN	T3,771000	;[CSM] String of ASCII?
	TLNN	T3,IDARGS	;[CSM] No, does subroutine take INS/DEL args?
	 JRST	CLSLN5		;[CSM] No, do one line at a time
	MOVEI	T3,(RW)		;[CSM] Where to do it
	MOVE	T4,T2		;[CSM] How many to do
	PUSHJ	P,@DLN(TM)	;[CSM] Delete T4 lines starting at row T3
	JRST	CLSLN6		;[CSM] Continue

CLSLN5:	MOVE	T1,T3		;GET CODE TO CLOSE LINES
	PUSHJ	P,PUTSEQ	;CLOSE A LINE
	SOJG	T2,CLSLN5	;LOOP THROUGH ALL LINES

CLSLN6:	SKIPN	ADDLSP
	JUMPE	CM,.+3		;JUMP IF AT START OF A LINE
	MOVE	PT,LINPTR
	PUSHJ	P,DISONE	;ELSE DISPLAY SINGLE CLOSED-UP LINE
	MOVE	T4,LPP(TM)	;GET LINE NUMBER OF START OF REWRITE
	SUB	T4,ADDLNS
	TLNE	F,FBL		;IS BOTTOM LINE O.K.?
	SOJ	T4,		;NO - RE-DO IT, TOO
	MOVEM	T4,SAVEAC	;SET IT UP IN T4 AND SAVEAC
	PUSHJ	P,ROLFW1	;AND REWRITE FROM THERE DOWN
	JRST	LOOP

CLSLNL:	PUSHJ	P,DISLIN	;DISPLAY REST OF LINE CURSOR IS ON
	MOVNI	T1,2		;UN-COUNT THE <CRLF> THAT WAS COUNTED BEFORE
	ADDM	T1,CLSCNT
	JRST	DISCUR		;RESTORE CURSOR AND LOOP

;HERE IF END OF BUFFER REACHED DURING THE CLOSE

CLOSEN:	MOVE	PT,CHRPTR	;GET POINTER TO FIRST DELETED CHARACTER
	IBP	PT		;PLUS A CHARACTER
	MOVE	EN,PT		;SAVE AS NEW END OF BUFFER
	JUMPN	SL,.+2		;DID CLOSE START AT START OF A LINE?
	JUMPE	CM,.+2
	PUSHJ	P,ADDCR		;NO - PUT A <CRLF> AFTER THAT PARTIAL LINE
	PUSHJ	P,POSCUR	;PUT CURSOR WHERE IT BELONGS
	MOVE	T0,CM		;MAKE THE CLEAR GO FROM THE CURSOR POSITION
	PUSHJ	P,FNCCLR	;CLEAR AND PUT UP THE FENCE
	PUSHJ	P,POSCUR	;GET BACK TO PROPER POSITION
	TRNE	F,COV		;HAS BUFFER OVERFLOWED?
	PUSHJ	P,CLSLST	;YES - WRITE OUT THE LAST PIECE
	JRST	LOOP		;AND GET ANOTHER COMMAND

;SUBROUTINE TO WRITE OUT THE LAST PIECE OF THE CLOSE BUFFER

CLSLST:	SETZ	T1,		;MAKE SURE LAST WORD OF BUFFER IS NULLED
	IDPB	T1,T3
	IDPB	T1,T3
	IDPB	T1,T3
	IDPB	T1,T3
	IDPB	T1,T3
	MOVE	T1,CLSCNT	;GET COUNT OF WORDS CLOSED
	IDIVI	T1,5
	AOJ	T1,
	SUBI	T1,PCBSIZ	;FIND SIZE OF LAST PIECE
	CAIL	T1,PCBSIZ	;SMALL ENOUGH?
	JRST	.-2		;NO - SUBTRACT SOME MORE
TOPS10<	MOVNS	T1
	HRLM	T1,CLSCCL	;SET TO OUTPUT THAT MANY WORDS
	PUSHJ	P,CLSOV0	;YES - WRITE OUT THE LAST PIECE
>
TOPS10<	MOVNI	T1,PCBSIZ	;RESTORE FULL BUFFER SIZE
	HRLM	T1,CLSCCL	;  TO CHANNEL COMMAND
>
	JRST	CLSOVE		;CLOSE THE DISK FILE AND RETURN

;SUBROUTINE FOR WHEN USER WANTS TO CLOSE SOME SPACES AFTER CLOSING LINES
;(WHICH HE'S INDICATED BY USING CURSOR MOVEMENT)

CLLSPS:	TLO	F,FLG
	PUSHJ	P,SPCBUF	;NULL OUT (T4)S WORTH OF CHARACTERS
	TLZ	F,FLG
	MOVE	T1,SPCCNT	;GET COUNT OF CHARACTERS
	ADDM	T1,CLSCNT	;ADD TO TOTAL COUNT
	AOS	CLSCNT		;(IT WAS ONE TOO SMALL)
	POPJ	P,		;FINISH OFF

;HERE IF MARK WAS MADE - CLOSE FROM STARTING CHARACTER TO CURRENT POSITION
;note: does nothing about starting or ending in a tab

CLSMRK:	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	TLO	F,XPL!XPC!XPB!CHG;NO POINTERS ARE GOOD; FILE IS CHANGED
	PUSHJ	P,MRKSET	;SET UP TO USE THE MARK
	MOVE	T3,[POINT 7,CLSBUF]
CLSMK1:	CAMN	PT,MRKPTR	;AT END OF THE CLOSE?
	JRST	CLSMKE		;YES - FINISH OFF
        CAMN	T3,[010700,,CLSBUF+PCBSIZ-1]
	PUSHJ	P,CLSOVF	;WRITE TO DISK ON CLOSE BUFFER OVERFLOW
	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,CLSMK1	;SKIP, IF NULL
	IDPB	T1,T3		;SAVE IT IN THE CLOSE BUFFER
	DPB	T4,PT		;NULL OUT THE CHARACTER IN THE FILE
	AOJA	T2,CLSMK1	;COUNT CHARACTER AND LOOP

CLSMKE:	MOVEM	T2,CLSCNT	;SAVE COUNT OF CHARACTERS CLOSED
	JRST	CLSLN4		;FINISH OFF

MRKSET:	MOVE	T1,CHRPTR	;GET POINTER TO ENDING POSITION
	EXCH	T1,MRKPTR	;SAVE IT AND GET OLD DISPLAY POINTER
	EXCH	T1,DISPTR	;SWAP WITH OLD DISPLAY POINTER
	EXCH	RW,SVPMRK
	EXCH	CM,SVPMRK+1
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POINTER
	MOVE	PT,CHRPTR	;GET POINTER TO STARTING POSITION
	SETZB	T2,T4		;CLEAR COUNT OF CHARACTERS CLOSED
	HRRZ	T0,MRKPTR	;GET ENDING ADDRESS
	CAILE	T0,(PT)		;REALLY WANT TO GO BACKWARDS?
	POPJ	P,		;NO - DONE
	EXCH	PT,MRKPTR	;YES - SWAP POINTERS
	MOVEM	T1,DISPTR	;AND GET OLD DISPLAY STATUS BACK
	MOVE	RW,SVPMRK
	MOVE	CM,SVPMRK+1
	POPJ	P,		;DONE
SUBTTL	Copy lines into buffer


;SUBROUTINE TO FIND (T4) REAL CHARACTERS (NOT NULLS) AT (PT), WHICH IS FRAGGED
;AND PUT THEM IN THE AREA POINTED TO BY T3
;IF FLG IS SET, NULLS THE CHARACTER IN THE FILE BUFFER; ELSE LEAVES IT ALONE
;STOPS WHEN COUNTED OUT. IF END OF LINE REACHED, PADS WITH SPACES
;RETURNS COUNT OF CHARACTERS MOVED IN SPCCNT

;NOTE: PICK OR CLOSE BUFFER can't OVERFLOW WHILE IN THIS ROUTINE, AS LONG AS
;BUFFER SIZE IS LARGER THAN ONE SCREENFUL (80*20/5 = 320 WORDS)
;THAT'S BECAUSE THIS IS REACHED FROM A CURSOR MOVE COMMAND, AND CURSOR MOVE
;CAN'T ENCOMPASS MORE THAN A SCREENFUL.
;WELL, ALMOST:	REAL LONG LINES can OVERFLOW. SO BEWARE OF, SAY, OBJECT FILES

SPCBUF:	MOVEM	T4,WRTNUM	;SAVE NUMBER OF CHARS TO NULL
	SETZM	SPCCNT		;CLEAR COUNT OF CHARACTERS MOVED
	SETZB	T1,NUMCHR	;GET A NULL; CLEAR # SPACES TO ADD

SPCBF1:	ILDB	T2,PT		;GET A CHARACTER
	CAMN	PT,EN		;AT END OF BUFFER?
	POPJ	P,		;YES - GO HOME EARLY
	JUMPE	T2,SPCBF1	;IGNORE IF NULL
	CAIN	T2,15		;IS IT A <CR>?
	PUSHJ	P,SPCBF3	;YES - DONE, IF FOLLOWED BY <LF>
	TLNE	F,FLG		;ELSE WANT TO NULL IT OUT?
	DPB	T1,PT		;YES - ZAP
	AOS	SPCCNT		;BUMP COUNT OF CHARACTERS
	CAIN	T2,11		;IS IT A TAB?
	JRST	SPCBTB		;YES - SEE HOW LONG THE TAB IS
	IDPB	T2,T3		;NO - SAVE CHARACTER IN THE DESIRED BUFFER
	SOJG	T4,SPCBF1	;AND COUNT IT - GOT ENOUGH?
SPCBEN:	SKIPE	NUMCHR		;GOT ANY SPACES TO ADD,
	TLZN	F,FLG		;REALLY WANT TO ADD THEM?
	POPJ	P,		;NO - JUST RETURN
	JRST	MAKSPC		;YES - ADD THEM AND RETURN

SPCBF3:	MOVE	T0,PT		;GOT <CR>: GET SCRATCH BUFFER POINTER
	ILDB	T0,T0		;GET NEXT CHARACTER
	CAIE	T0,12		;<LF>?
	POPJ	P,		;NO - NULL OUT THE <CR>, TOO
	POP	P,		;YES - KILL THE RETURN FROM HERE
	ADDM	T4,SPCCNT	;COUNT THE EXTRA SPACES
	MOVEI	T1," "		;PAD OUT WITH SPACES:
	IDPB	T1,T3		;SAVE SPACES UNTIL COUNTED OUT
	SOJG	T4,.-1
	POPJ	P,		;DONE FOR KEEPS

SPCBTB:	MOVE	T0,WRTNUM	;GET LENGTH OF DELETE
	ADD	T0,CM		;  PLUS STARTING CURSOR POSITION
	SUB	T0,T4		;  LESS NUMBER TO GO, GIVES PRESENT POSITION
	ANDI	T0,7		;FIND NEGATIVE SIZE OF TAB
	SUBI	T0,10
	ADD	T4,T0		;COUNT OFF THAT MANY SPACES FROM DELETE
	JUMPG	T4,[IDPB T2,T3	;IF STILL MORE TO GO, SAVE TAB
		    JRST SPCBF1];AND CONTINUE
	SOS	SPCCNT		;REMOVE TAB FROM COUNT OF CHARACTERS
	MOVN	T1,T4		;GET COUNT OF SPACES TO ADD TO FILE
	ADDM	T1,NUMCHR
	SUB	T4,T0		;GET COUNT OF SPACES TO ADD TO BUFFER
	MOVEI	T1," "		;AND SAVE OFF THOSE SPACES
	IDPB	T1,T3
	AOS	SPCCNT		;BUMP COUNT OF CHARACTERS
	SOJG	T4,.-2
	JRST	SPCBEN		;AND FINISH UP

;SUBROUTINE FOR OVERFLOW OF CLOSE BUFFER - SAVE ON DISK; SET COV FLAG

CLSOVF:	PUSH	P,T1		;SAVE LIVE CHARACTER
	SETZ	T1,		;STORE A NULL AT END OF CLOSE BUFFER
	IDPB	T1,T3
	TROE	F,COV		;SET CLOSE OVERFLOW FLAG - ALREADY SET?
	JRST	CLSOV1		;YES - FILE ALREADY OPEN
	PUSH	P,T2		;SAVE AN AC
	HRROI	T2,CLSFIL
TOPS10<	PUSHJ	P,SETDEL	;DELETE OLD .TMP FILE
>
	PUSHJ	P,SETOUT	;SET UP THE CLOSE OUTPUT FILE
	MOVEM	T1,CLSJFN
	JRST	CLSOV2

CLSOV0:	PUSH	P,T1		;SAVE AN AC
CLSOV1:	PUSH	P,T2		;SAVE AN AC
TOPS10<	CLSOV2:	OUTPUT	5,CLSCCL	;WRITE OUT THE CLOSE BUFFER
>
TOPS20<	MOVE	T1,CLSJFN
CLSOV2:	HRROI	T2,CLSBUF	;WRITE OUT THE CLOSE BUFFER
	SETZ	T3,
	SOUT
>
	MOVE	T3,[POINT 7,CLSBUF] ;START THE BUFFER AFRESH
	POP	P,T2		;RESTORE ACS
	POP	P,T1		;RESTORE ACS
	POPJ	P,		;CONTINUE

CLSOVE:
TOPS10<	RELEAS	5,		;FINISH OFF THE FILE
>
TOPS20<	MOVE	T1,CLSJFN	;GET FILE HANDLE
	CLOSF			;CLOSE IT
	  HALTF			;IT BETTER WORK
>
	POPJ	P,		;DONE
SUBTTL	Insert spaces

;HERE TO ADD SPACES TO THE BUFFER

OPENSP:	MOVE	T4,ADDSPC	;SET UP LAST TIME'S NOMINAL
	MOVEM	T4,PARG1	;AS DEFAULT FOR THIS TIME
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET SPACES TO ADD
	TRNE	F,CMV		;DOING CURSOR MOVEMENT?
	PUSHJ	P,SPSCUR	;YES - HANDLE THINGS A LITTLE DIFFERENTLY
	MOVEM	T4,ADDSPC	;SAVE NEW NOMINAL
	PUSHJ	P,ERASPM	;ERASE PARAMETER
OPSNPM:	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	SKIPG	T1,ADDSPC	;SET UP LAST TIME'S NOMINAL
	JRST	DISCUR		;DONE, IF NOTHING TO ADD
	TLO	F,XPB!CHG	;SAY BOTTOM POINTER BAD; FILE MODIFIED
OPSNP1:	TLO	F,INS		;LET LINE BE EXTENDED IF NECESSARY
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	TLZ	F,INS!PCM
	MOVEM	T1,NUMCHR	;ADD THE RIGHT NUMBER OF SPACES
	CAIE	T3,11		;IS CHARACTER AT CURSOR A TAB?
	JRST	OPNSP1		;NO - CONTINUE
	MOVE	T1,TABSIZ	;YES - CONVERT THE TAB TO SPACES
	ADDM	T1,NUMCHR
	SETZ	T1,		;AND NULL OUT THE TAB
	DPB	T1,TABPTR
	SKIPN	TABSPC		;POINTING TO START OF TAB?
	TLO	F,XPC		;NO - CHARACTER POINTER IS BAD

OPNSP1:	PUSHJ	P,MAKSPC	;GO ADD THE SPACES
	MOVE	T4,ADDSPC	;GET NUMBER OF SPACES TO ADD
	SKIPE	T3,ISP(TM)	;CAN TERMINAL OPEN SPACES ON ITS OWN?
	PUSHJ	P,OPNSPI	;YES - LET IT (SKIP RETURNS)
	PUSHJ	P,DISLIN	;NO - REWRITE THE LINE CURSOR IS ON
	SOSGE	ADDSLN		;WANT TO WORK WITH OTHER LINES?
	JRST	DISCUR		;NO - JUST GET ANOTHER COMMAND
	TLO	F,XPC!XPL	;YES - RE-MAKE SOME POINTERS
	MOVE	T1,ADDSPC	;GET SIZE OF INSERT
	AOJA	RW,OPSNP1	;AND DO THE SAME WITH THE NEXT LINE

;SUBROUTINES TO USE THE TERMINAL HARDWARE TO INSERT OR DELETE SPACES
;ENTER WITH T4/ NUMBER OF TIMES TO OUTPUT (T3)
;NORMAL RETURN: LINE HAS TABS, MUST BE RE-DISPLAYED
;SKIP	RETURN: LINE HAS BEEN HANDLED; NO FURTHER ACTION NECESSARY

CLSSPI:	MOVE	T2,CHRPTR	;SEE IF THERE ARE ANY TABS FROM HERE TO EOL
	MOVE	T0,CPL(TM)	;GET LENGTH OF REMAINDER OF LINE
	SUB	T0,ADDSPC
	SUB	T0,CM
CLSSI1:	ILDB	T1,T2
	JUMPE	T1,CLSSI1	;IGNORE IF NULL
	CAIN	T1,11		;TAB?
	POPJ	P,		;YES - GO RE-DISPLAY ENTIRE LINE
	CAIE	T1,15		;END OF LINE?
	SOJG	T0,CLSSI1	;NO - KEEP LOOKING
	JUMPG	T0,OPNSI2	;NO TAB - IF LINE SHORT DO IT WITH HARDWARE
	POPJ	P,		;LONG LINE - GO REDISPLAY

OPNSPI:	MOVE	T2,CHRPTR	;SEE IF THERE ARE ANY TABS FROM HERE TO EOL
OPNSI1:	ILDB	T1,T2
	CAIN	T1,11		;TAB?
	POPJ	P,		;YES - GO RE-DISPLAY ENTIRE LINE
	CAIE	T1,15		;END OF LINE?
	JRST	OPNSI1		;NO - KEEP LOOKING

OPNSI2:	AOS	(P)		;SET UP FOR SKIP RETURN
	PUSHJ	P,POSCUR	;POINT TO THE RIGHT POSITION
	TLNN	T3,771000	;[CSM] String of ASCII?
	TLNN	T3,IDARGS	;[CSM] No, does subroutine take INS/DEL args?
	 JRST	OPNSI3		;[CSM] No, do one space at a time
	PUSHJ	P,(T3)		;[CSM] INS/DEL T4 spaces at current position
	PJRST	PUTTYP		;[CSM] Continue

OPNSI3:	MOVE	T1,T3		;GET CODE TO DO THE OPEN
	PUSHJ	P,PUTSEQ	;OPEN ONE SPACE
	SOJG	T4,.-2		;LOOP THROUGH ALL SPACES
	JRST	PUTTYP		;OUTPUT THE BUFFER AND SKIP RETURN
SUBTTL	Delete characters

;HERE TO REMOVE THE PREVIOUS CHARACTER FROM THE BUFFER

DELCHR:	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	SOJL	CM,[AOJA CM,LOOP] ;BACK UP A NOTCH - IF AT START, DO NOTHING
	MOVEI	T1,1		;SET TO REMOVE ONE CHARACTER
	MOVEM	T1,ADDSPS	;YES - SET UP THE VALUE
	TLO	F,XPC		;FORCE RE-MAKE OF CHARACTER POINTER
	PUSHJ	P,MAKCPT	;RE-MAKE IT
	TLO	F,XPB!CHG!XPC	;SAY BOTTOM POINTER BAD; FILE MODIFIED
	TLZ	F,PCM		;CANCEL THE PICK-CLOSE MARK, IF ANY
	MOVE	PT,CHRPTR	;GET CHARACTER POINTER
	ILDB	T1,PT		;GET CHARACTER BEFORE THE CURSOR
	CAIE	T1,11		;TAB?
	JRST	CLSNP1+1	;NO - CONTINUE
	SETZ	T1,		;YES - CLEAR OUT THE TAB
	DPB	T1,PT
	PUSHJ	P,DISONL	;RE-DISPLAY THAT LINE
	MOVE	PT,LINPTR	;GET POINTER TO START OF LINE
	PUSHJ	P,CALCCM	;POSITION TO THE START OF THE TAB
	  JRST	DISCUR		;POSITION CURSOR AND LOOP
	JRST	DISCUR

;HERE TO REMOVE CHARACTERS FROM THE BUFFER

CLOSSP:	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	TLNN	F,ENT		;IS THERE A PARAMETER TYPED?
	JRST	CLSNPM		;NO - USE THE ONE ALREADY SET UP
	MOVE	T4,ADDSPC	;SET UP LAST TIME'S NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET SPACES TO DELETE
	TRNE	F,CMV		;DOING CURSOR MOVEMENT?
	PUSHJ	P,SPSCUR	;YES - HANDLE THINGS A LITTLE DIFFERENTLY
	MOVEM	T4,ADDSPC	;SAVE NEW NOMINAL
	PUSHJ	P,ERASPM	;ERASE PARAMETER

CLSNPM:	SKIPG	T1,ADDSPC	;GOT ANYTHING TO DELETE?
	JRST	CLOSP1		;NO - DONE
	TLZ	F,PCM		;CANCEL THE PICK-CLOSE MARK, IF ANY
	MOVEM	T1,ADDSPS	;YES - SET UP THE VALUE
	TLO	F,XPB!CHG	;SAY BOTTOM POINTER BAD; FILE MODIFIED
CLSNP1:	PUSHJ	P,MAKCPT	;RE-MAKE CHARACTER POINTER
	SETZM	NUMCHR		;ASSUME A TAB WON'T BE BROKEN
	CAIE	T3,11		;IS CHARACTER AT CURSOR A TAB?
	JRST	CLSNP2		;NO - CONTINUE
	MOVE	T1,TABSPC	;YES - ADD SPACES TO LEFT OF TAB, AFTER CLOSE
	MOVEM	T1,NUMCHR

CLSNP2:	MOVE	PT,CHRPTR
	MOVE	T4,ADDSPS	;GET NUMBER OF SPACES TO CLOSE
	PUSHJ	P,WRTNUL	;NULL OUT THAT MANY CHARACTERS
	MOVEM	T4,WRTNUM	;SAVE SIZE OF LEFTOVER, IF IT'S SHORT
	SKIPE	NUMCHR		;WANT TO ADD SPACES FOR A BROKEN TAB?
	PUSHJ	P,MAKSPC	;YES - DO IT
	MOVE	T4,ADDSPS	;GET NUMBER OF SPACES TO CLOSE
	SUB	T4,WRTNUM	;MINUS UNNEEDED OVERAGE
	SKIPE	T3,DSP(TM)	;CAN TERMINAL CLOSE SPACES ON ITS OWN?
	PUSHJ	P,CLSSPI	;YES - LET IT (SKIP RETURNS)
	PUSHJ	P,DISLIN	;NO - REWRITE THE LINE CURSOR IS ON
	SOSGE	ADDSLN		;WANT TO DO IT WITH ANOTHER LINE?
	JRST	CLOSP1		;NO - JUST GET ANOTHER COMMAND
	TLO	F,XPC!XPL	;YES - RE-MAKE SOME POINTERS
	AOJA	RW,CLSNP1	;AND DO THE SAME WITH THE NEXT LINE

CLOSP1:	PUSHJ	P,POSCUR	;RE-POSITION THE CURSOR
	SOSG	SQZCNT		;TIME TO DO A SQUEEZE?
	PUSHJ	P,SQUEZW	;YES - REMOVE ALL NULL WORDS
	JRST	INTEND		;AND GET ANOTHER COMMAND

;HERE FOR CURSOR MOVE OPENSP OR CLOSSP - COUNT LINES AND SPACES

SPSCUR:	MOVEM	T4,ADDSLN	;SAVE LINES TO WORK WITH
	SKIPN	T4,PARG2	;GET NUMBER OF SPACES - ANY?
	MOVE	T4,ADDSPC	;NO - USE CURRENT NOMINAL
	POPJ	P,
SUBTTL	PICK command

;HERE TO TAKE LINES FROM THE BUFFER AND PUT THEM IN THE PICK BUFFER

PICK:	MOVE	T4,PICKLN	;SET UP LAST TIME'S NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET LINES TO PICK
	JUMPE	T1,[SETZM PICKLN    ;IF GOT A TOKEN, READ ZERO LINES
		    MOVEM T4,PICKSP ;AND GIVEN NUMBER OF SPACES
		    JRST  PICK0]    ;CONTINUE
	MOVEM	T4,PICKLN	;SAVE AS NEW NOMINAL
	TRNE	F,CMV		;CURSOR MOVEMENT?
	JRST	[MOVE  T1,PARG2    ;YES - GET SPACES TO PICK, TOO
		 MOVEM T1,PICKSP   ;IF NO LINES, COUNT SPACES FROM CURSOR
		 JUMPE T4,PICK0
		 ADD   T1,SAVPOS+1 ;IF SOME LINES, COUNT FROM LEFT MARGIN
		 ADD   T1,SL
		 MOVEM T1,PICKSP
		 JRST  PICK0]
	SETZM	PICKSP		;IF NO CURSOR MOVE, CLEAR EXTRA SPACES
PICK0:	PUSHJ	P,ERASPM	;ERASE PARAMETER

PIKNPM:	TRZ	F,POV		;ASSUME PICK BUFFER WILL NOT OVERFLOW
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POINTER
	TLNE	F,PCM		;HAS A MARK BEEN MADE?
	JRST	PIKMRK		;YES - DO THINGS DIFFERENTLY
	SETZ	T2,		;CLEAR COUNT (IN CASE THERE AREN'T ANY LINES)
	MOVE	T1,T3		;SAVE CHARACTER AT CURSOR
	MOVE	PT,CHRPTR	;GET CURRENT CURSOR POSITION
	MOVE	T3,[POINT 7,PIKBUF]
	SKIPG	T4,PICKLN	;GET NUMBER OF LINES TO PICK - ANY?
	JRST	PICK3		;NO - DONE

	CAIE	T1,11		;GOT A TAB AT THE CURSOR?
	JRST	PICK1-1		;NO - SKIP THIS
	MOVE	T2,PT		;GET CURSOR PTR AGAIN FOR SCRATCH
	ILDB	T1,T2		;GET CHARACTER CURSOR POINTS TO
	CAIE	T1,11		;FOUND THE TAB?
	JRST	.-2		;NO - KEEP LOOKING
	SKIPG	TABSPC		;YES - AT BEGINNING OF TAB?
	JRST	PICK1-1		;YES - DON'T TOUCH THE TAB, THEN
	MOVE	PT,T2		;WITHIN - POINT AFTER TAB
	MOVE	T2,TABSIZ	;GET TAB'S SIZE TO RIGHT OF CURSOR
	SUB	T2,TABSPC
	PUSH	P,T2		;SAVE COUNT FOR A WHILE
	MOVEI	T1," "		;PUT SOME SPACES IN THE PICK BUFFER
	IDPB	T1,T3
	SOJG	T2,.-1
	POP	P,T2		;RESTORE COUNT OF SPACES PUT IN
	JRST	PICK1

	SETZ	T2,		;CLEAR COUNT OF CHARACTERS PICKED
PICK1:	CAMN	EN,PT		;AT END OF USEABLE BUFFER?
	JRST	PIKPAD		;YES - PAD IN THE REMAINING <CRLF>S
	CAMN	T3,[010700,,PIKBUF+PCBSIZ-1]
	PUSHJ	P,PIKOVF	;WRITE TO DISK ON PICK BUFFER OVERFLOW
	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,PICK1	;SKIP, IF NULL
	IDPB	T1,T3		;SAVE IT IN THE PICK BUFFER
	CAIE	T1,15		;CARRIAGE RETURN?
	AOJA	T2,PICK1	;NO - IGNORE IT

	CAMN	T3,[010700,,PIKBUF+PCBSIZ-1]
	PUSHJ	P,PIKOVF	;WRITE TO DISK ON PICK BUFFER OVERFLOW
	ILDB	T1,PT		;YES - PICK UP THE <LF>
	IDPB	T1,T3		;SAVE IT IN THE PICK BUFFER
	ADDI	T2,2		;COUNT IT
	CAIE	T1,12		;IS IT REALLY?
	JRST	PICK1		;NO - IT'S NOT THE END OF THE LINE
	SOJG	T4,PICK1	;YES - LOOP THROUGH DESIRED NUMBER OF LINES
PICK3:	MOVEM	T2,PIKCNT	;SAVE COUNT OF CHARACTERS PICKED
	SKIPLE	T4,PICKSP	;DONE WITH LINES - GOT ANY SPACES?
	PUSHJ	P,PIKSPS	;YES - PICK THEM, TOO
PICK4:	SETZ	T1,		;DONE - END PICK BUFFER WITH A NULL
	IDPB	T1,T3
TOPS10<	IDPB	T1,T3		;CLEAR OUT ENTIRE LAST WORD
	IDPB	T1,T3
	IDPB	T1,T3
	IDPB	T1,T3
>
	TLZE	F,PCM		;WAS THERE A MARK?
	PUSHJ	P,DISPLL	;YES - RE-DISPLAY THE SCREEN
	PUSHJ	P,POSCUR	;RE-POSITION THE CURSOR
	TRNN	F,POV		;HAS BUFFER OVERFLOWED?
	JRST	LOOP		;NO - DONE
	MOVE	T1,PIKCNT	;GET COUNT OF WORDS PICKED
	IDIVI	T1,5
	AOJ	T1,
	SUBI	T1,PCBSIZ	;FIND SIZE OF LAST PIECE
	CAIL	T1,PCBSIZ	;SMALL ENOUGH?
	JRST	.-2		;NO - SUBTRACT SOME MORE
TOPS10<	MOVNS	T1
	HRLM	T1,PIKCCL	;SET TO OUTPUT THAT MANY WORDS
>
	PUSHJ	P,PIKOV1	;YES - WRITE OUT THE LAST PIECE
TOPS10<	MOVNI	T1,PCBSIZ	;RESTORE FULL BUFFER SIZE
	HRLM	T1,PIKCCL	;  TO CHANNEL COMMAND
>
	PUSHJ	P,PIKOVE	;CLOSE THE DISK FILE
	JRST	LOOP		;AND GET ANOTHER COMMAND

;HERE IF PICK EXTENDS BEYOND FILE, TO PAD OUT WITH EXTRA <CR>S
;(IE, YOU ALWAYS GET THE NUMBER OF LINES YOU ASK FOR)

PIKPAD:	MOVEI	T1,15
	MOVEI	PT,12
PIKPD1:	CAMN	T3,[010700,,PIKBUF+PCBSIZ-1]
	PUSHJ	P,PIKOVF	;WRITE TO DISK ON PICK BUFFER OVERFLOW
	IDPB	T1,T3		;SAVE OFF ANOTHER <CRLF>
	CAMN	T3,[010700,,PIKBUF+PCBSIZ-1]
	PUSHJ	P,PIKOVF	;WRITE TO DISK ON PICK BUFFER OVERFLOW
	IDPB	PT,T3
	ADDI	T2,2		;COUNT THE <CRLF>
	SOJG	T4,PIKPD1	;CONTINUE THROUGH ALL LEFTOVER LINES
	JRST	PICK3		;THEN FINISH OFF

;HERE TO PICK (T4) EXTRA SPACES AFTER THE LINES

PIKSPS:	TLZ	F,FLG		;DON'T NULL OUT THE PICKED CHARACTERS
	PUSHJ	P,SPCBUF	;PICK (T4)S WORTH OF CHARACTERS AND RETURN
	MOVE	T1,SPCCNT	;GET COUNT OF CHARACTERS
	ADDM	T1,PIKCNT	;ADD TO TOTAL COUNT
	POPJ	P,		;DONE

;HERE IF MARK WAS MADE - PICK FROM STARTING CHARACTER TO (MRKPTR)
;note: does nothing about starting or ending in a tab

PIKMRK:	TLO	F,XPL!XPC!XPB	;NO POINTERS ARE GOOD
	PUSHJ	P,MRKSET	;SET UP TO USE THE MARK
	MOVE	T3,[POINT 7,PIKBUF]
PIKMK1:	CAMN	PT,MRKPTR	;AT END OF THE PICK?
	JRST	PIKMKE		;YES - FINISH OFF
        CAMN	T3,[010700,,PIKBUF+PCBSIZ-1]
	PUSHJ	P,PIKOVF	;WRITE TO DISK ON PICK BUFFER OVERFLOW
	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,PIKMK1	;SKIP, IF NULL
	IDPB	T1,T3		;SAVE IT IN THE PICK BUFFER
	AOJA	T2,PIKMK1	;COUNT CHARACTER AND LOOP

PIKMKE:	MOVEM	T2,PIKCNT	;SAVE COUNT OF CHARACTERS PICKED
	JRST	PICK4		;FINISH OFF

;SUBROUTINE FOR OVERFLOW OF PICK BUFFER - SAVE ON DISK; SET POV FLAG

PIKOVF:	SETZ	T1,		;SAVE A NULL AT END OF PICK BUFFER
	IDPB	T1,T3
	TROE	F,POV		;SET PICK OVERFLOW FLAG - ALREADY SET?
	JRST	PIKOV1		;YES - FILE ALREADY OPEN
	PUSH	P,T2		;SAVE AN AC
	HRROI	T2,PIKFIL
TOPS10<	PUSHJ	P,SETDEL	;DELETE OLD .TMP FILE
>
	PUSHJ	P,SETOUT	;SET UP THE PICK OUTPUT FILE
	MOVEM	T1,PIKJFN
	JRST	PIKOV2

PIKOV1:	PUSH	P,T2		;SAVE AN AC
TOPS10<	PIKOV2:	OUTPUT	5,PIKCCL	;WRITE OUT THE PICK BUFFER
>
TOPS20<	MOVE	T1,PIKJFN
PIKOV2:	HRROI	T2,PIKBUF	;WRITE OUT THE PICK BUFFER
	SETZ	T3,
	SOUT
>
	MOVE	T3,[POINT 7,PIKBUF] ;START THE BUFFER AFRESH
	POP	P,T2		;RESTORE AC
	POPJ	P,		;CONTINUE

PIKOVE:
TOPS10<	RELEAS	5,		;FINISH OFF THE FILE
>
TOPS20<	MOVE	T1,PIKJFN	;GET FILE HANDLE
	CLOSF			;CLOSE IT
	  HALTF			;IT BETTER WORK
>
	POPJ	P,		;DONE
SUBTTL	PUT command

;HERE TO PUT THE CONTENTS OF THE PICK BUFFER INTO THE BUFFER
;HERE, SPECIFICALLY, TO DO AN IN-LINE PUT: PUT TEXT IN THE MIDDLE OF A LINE

PUT:	TLNE	F,RDO		;IS FILE READ-ONLY?
	JRST	RDOERR		;YES - COMMAND IS ILLEGAL
	SETZM	PIKJFN		;ASSUME NOT READING FROM DISK
	TLO	F,INS		;LET LINE BE EXTENDED IF NECESSARY
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	TLZ	F,INS!PCM
	CAIN	T3,11		;IS CHARACTER AT CURSOR A TAB?
	PUSHJ	P,RPLTAB	;YES - REPLACE IT WITH SPACES
	TLO	F,CHG!WRH	;SET TO READ FROM THE PICK BUFFER
	MOVE	T3,[010700,,PIKBUF-1]
	MOVEM	T3,PUTPTR	;ASSUME WILL READ FROM PUT BUFFER
	TLNN	F,ENT		;IS THERE A PARAMETER TYPED?
	JRST	PUTNPM		;NO - USE THE PICK BUFFER
	PUSHJ	P,PELS.1	;GET STRING TO PUT, IF ANY
	JUMPE	T1,PUTCLS	;IF ENTER-PERCENT TYPED GO USE THE CLOSE BFR
	TLZ	F,POV		;IF IMMEDIATE, BUFFER CAN'T OVERFLOW
	MOVEM	T1,PIKCNT	;SAVE SIZE OF STRING
	MOVEM	T1,NUMCHR	;SAVE AS NUMBER OF CHARACTERS TO ADD
	PUSHJ	P,ERASPM	;CLEAN THE SCREEN UP
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION, IF CURSOR MVMT USED
	SKIPN	T1,PIKCNT	;GET COUNT OF CHARACTERS PICKED - ANY?
	JRST	PUTERR		;NO - ERROR
	PUSHJ	P,MAKCHR	;GO PUT IT IN

;HERE FOR AN IN-LINE PUT (IE, NO <CRLF>S IN THE BUFFER)

PUT0:	TLZE	F,XPL		;IS LINE POINTER O.K.?
	PUSHJ	P,MAKLPT	;NO - RE-MAKE IT
	TLO	F,XPB		;BOTTOM POINTER IS BAD
	MOVE	T4,NUMCHR	;GET DISTANCE TO OPEN
	SKIPE	T3,ISP(TM)	;CAN TERMINAL OPEN SPACES ON ITS OWN?
	PUSHJ	P,OPNSPI	;YES - OPEN UP THE LINE (SKIP RETURN)
	JRST	PUT0D		;NO - REWRITE THE LINE CURSOR IS ON
	PUSHJ	P,POSCUR	;GET BACK TO START OF NEWLY-OPENED SPACE
	AOS	T1,PUTPTR	;WRITE PICK OR CLOSE BUFFER THERE
	PUSHJ	P,PUTSTS
	CAME	RW,LPP.1	;PUTTING ON BOTTOM LINE?
	JRST	DISCUR		;NO - RE-DISPLAY THE CURSOR AND LOOP
	TLZE	F,FNC		;YES - IS FENCE UP?
	PUSHJ	P,CLRLNA	;YES - ERASE IT
	JRST	DISCUR		;THEN RE-DISPLAY THE CURSOR AND LOOP

PUT0D:	PUSHJ	P,DISLIN	;TERMINAL CAN'T HELP - RE-DO ENTIRE LINE
	CAMN	RW,LPP.1	;PUTTING ON BOTTOM LINE?
	TLZ	F,FNC		;YES - IF FENCE WAS UP, IT AIN'T NO MO
	JRST	DISCUR		;RE-POSITION CURSOR AND RETURN

;HERE TO PUT OLD CONTENTS OF PICK BUFFER

PUTNPM:	SKIPN	T1,PIKCNT	;GET COUNT OF CHARACTERS PICKED - ANY?
	JRST	PUTERR		;NO - ERROR
	MOVEM	T1,NUMCHR	;SAVE AS NUMBER OF CHARACTERS TO ADD
	TLO	F,CHG!WRH	;SET TO READ FROM THE PICK BUFFER
	TRNN	F,POV		;WANT TO READ OFF DISK?
	JRST	PUTNP2		;NO - READ FROM BUFFER
	HRROI	T2,PIKFIL
	PUSHJ	P,SETIN		;YES - SET FILE UP
	MOVEM	T1,PUTJFN	;SAVE JFN FOR MAKSPC
PUTNP2:	SETZM	MAKLNS		;CLEAR NUMBER OF <CRLF>S IN BUFFER
	PUSHJ	P,MAKCHR	;PUT THE BUFFER
	SKIPN	T4,MAKLNS	;ARE THERE <CRLF>S IN THE PICK BUFFER?
	JRST	PUT0		;NO - JUST REWRITE ONE LINE
	TLO	F,XPB		;YES - BOTTOM POINTER IS BAD
	PUSHJ	P,OPENLD	;OPEN UP, SOMEHOW **NOTE: MAY NOT RETURN**
	PUSHJ	P,POSCUR	;POSITION TO START OF PUT
	MOVE	T4,MAKLNS	;GET NUMBER OF LINES TO DISPLAY
	JUMPN	CM,.+3		;JUMP IF NOT AT START OF A COLUMN
	LDB	T1,MAKPTR	;GET LAST CHARACTER PUT
	CAIE	T1,12		;END OF LINE?
	AOJ	T4,		;DO ONE MORE LINE IF START OR END W/IN LINE

	MOVE	T1,LPP(TM)	;FIND NUMBER OF LINES BELOW CURSOR
	SUB	T1,RW
	CAMG	T1,T4		;IS PUT LONGER THAN THAT?
	MOVE	T4,T1		;YES - DISPLAY ONLY WHAT WILL FIT

	MOVE	PT,CHRPTR	;DISPLAY FROM CURSOR POSITION
	PUSHJ	P,DISPLY
	JRST	DISCUR		;RE-POSITION CURSOR AND RETURN

;HERE TO PUT THE CONTENTS OF THE CLOSE BUFFER

PUTCLS:	MOVE	T1,[010700,,CLSBUF-1]
	MOVEM	T1,PUTPTR	;SET TO READ FROM CLOSE BUFFER
	PUSHJ	P,ERASPM	;ERASE PARAMETER
	TRNN	F,COV		;WANT TO READ OFF DISK?
	JRST	PUTCS1		;NO - READ FROM BUFFER
	HRROI	T2,CLSFIL
	PUSHJ	P,SETIN		;YES - SET FILE UP
	MOVEM	T1,PUTJFN	;SAVE JFN FOR MAKSPC
PUTCS1:	SKIPG	T1,CLSCNT	;GET COUNT OF CHARS IN BUFFER - ANY?
	JRST	PUCERR		;NO - ERROR
	MOVEM	T1,NUMCHR	;YES - SAVE AS NUMBER OF CHARACTERS TO ADD
	JRST	PUTNP2		;GO PUT THEM IN

PUCERR:	MOVEI	T1,[ASCIZ /#######Close buffer is empty/]
	JRST	ERROR
PUTERR:	MOVEI	T1,[ASCIZ /########Put buffer is empty/]
	JRST	ERROR
SUBTTL	SLIDE left and right

;HERE TO SLIDE THE VIEWING WINDOW TO THE LEFT

SLIDEL:	MOVE	T4,SLIDES	;SET UP LAST TIME'S SLIDE AS NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET LINES TO ROLL
	MOVEM	T4,SLIDES	;SAVE AS NEW NOMINAL
	PUSHJ	P,ERASPM
SLLNPM:	SKIPN	SLDFLG		;NEVER WANT TO SLIDE?
	JRST	DISCUR		;RIGHT - DON'T
	SUB	SL,SLIDES	;SLIDE TO THE LEFT
	ADD	CM,SLIDES	;KEEP CURSOR IN SAME POSITION IN TEXT
	JUMPL	SL,[ADD  CM,SL	;IF GONE TOO FAR, STOP AT LEFT EDGE
		    SETZ SL,	;YES - STOP AT THE LEFT EDGE
		    JRST .+1]
	CAMGE	CM,CPL.1	;HAS CURSOR GONE OFF THE RIGHT?
	JRST	.+3		;NO - O.K.
	MOVE	CM,CPL.1	;YES - MOVE IT TO THE EDGE OF THE SCREEN
	TLO	F,XPC		;  (CHARACTER POINTER IS NOW BAD)
	PUSHJ	P,DISPLL	;RE-DISPLAY THE SCREEN
	JRST	DISCUR		;RE-POSITION CURSOR AND RETURN

;HERE TO SLIDE THE VIEWING WINDOW TO THE RIGHT

SLIDER:	MOVE	T4,SLIDES	;SET UP LAST TIME'S SLIDE AS NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET LINES TO ROLL
	TRNE	F,CMV		;CURSOR MOVEMENT?
	MOVE	T4,PARG2	;YES -	GET CHANGE IN COLUMNS
	MOVEM	T4,SLIDES	;SAVE AS NEW NOMINAL
	PUSHJ	P,ERASPM
SLRNPM:	SKIPN	SLDFLG		;NEVER WANT TO SLIDE?
	JRST	DISCUR		;RIGHT - DON'T
	ADD	SL,SLIDES	;SLIDE TO THE RIGHT
	SUB	CM,SLIDES	;KEEP CURSOR IN SAME POSITION IN TEXT
	JUMPGE	CM,.+3		;HAS CURSOR GONE OFF THE LEFT?
	SETZ	CM,		;YES - MOVE IT TO THE EDGE OF THE SCREEN
	TLO	F,XPC		;  (CHARACTER POINTER IS NOW BAD)
	PUSHJ	P,DISPLL	;RE-DISPLAY THE SCREEN
	JRST	DISCUR		;RE-POSITION CURSOR AND RETURN
SUBTTL	EXECUTE command

;HERE TO OPEN OR CLOSE THE EXECUTE BUFFER OR SET UP TO ITERATE IT A FEW TIMES

EXECUT:	TLZ	F,PCM		;CANCEL THE PICK-CLOSE MARK, IF ANY
	TRZE	F,CMV		;DID USER USER CURSOR MOVEMENT?
	JRST	[MOVE  T3,[POINT 7,PARBUF]
		 PUSHJ P,PELS.M	;YES - READ PARAMETER FROM THE FILE
		 JRST  .+3]	;CONTINUE
	SETZ	T1,		;END BUFFER WITH A NULL
	IDPB	T1,PARPTR
	HLRZ	T1,PARBUF	;GET FIRST CHARACTER OF PARAMETER
	LSH	T1,-^D11
	CAIL	T1,"a"		;LOWER CASE?
	SUBI	T1,40		;YES - CONVERT TO UPPER
	CAIN	T1,"S"		;SET UP A BUFFER?
	JRST	XCTSET		;YES - DO IT
	CAIN	T1,"K"		;KILL A BUFFER?
	JRST	XCTKIL		;YES - DO IT
	CAIN	T1,"W"		;WRITE INTO A BUFFER?
	JRST	XCTWRT		;YES - DO IT
	CAIN	T1,"R"		;READ AND LIST A BUFFER?
	JRST	XCTRDL		;YES - DO IT
	CAIN	T1,"N"		;LIST THE DEFINED BUFFER NAMES?
	JRST	XCTNML		;YES - DO IT

;HERE TO SET UP A NUMBER OF ITERATIONS

	PUSHJ	P,PEEL.1	;READ ARGUMENT, IF ANY
	JUMPE	T1,EXCOPN	;IF NO ARG, JUST OPEN EXECUTE BUFFER
	MOVE	T4,PARG1	;ELSE GET NUMBER OF ITERATIONS
	MOVE	T3,T4		;HERE, TOOL
	EXCH	T4,XCTITR	;SAVE AS NEW NOMINAL
EXCUT1:	EXCH	T3,XCTNUM	;AND AS CURRENT NUMBER
	MOVE	T1,XCTACW	;GET BUFFER POINTER
	ILDB	T1,T1		;MAKE SURE THERE'S SOMETHING THERE
	JUMPE	T1,XCXERR	;IF NOTHING THERE, ERROR
	TROE	F,XCT		;ALREADY EXECUTING?
	PUSHJ	P,EXCSVX	;YES - SAVE CURRENT CONTEXT
	MOVE	T1,XCTACW	;GET BUFFER POINTER
	MOVEM	T1,XCTACR	;SET BUFFER UP FOR READING
	MOVEM	T1,XCTPTR
	TRZN	F,XSV		;SAVING COMMANDS?
	JRST	EXCOP1		;NO - SKIP THIS
	MOVE	PT,XCTPTW	;YES - GET POINTER TO END OF BUFFER
EXCUT2:	ADD	PT,[70000,,0]	;BACK IT UP A NOTCH
	JUMPGE	PT,.+2		;(USER TYPED ENTER NUMBER EXECUTE:
	SUB	PT,[430000,,1]	;  WANT TO REMOVE THAT FROM BUFFER)
	LDB	T1,PT		;GET CHARACTER
	CAIE	T1,33		;ENTER?
	JRST	EXCUT2		;NO - KEEP SKIPPING
	SETZ	T1,		;YES - END BUFFER WITH A NULL
	DPB	T1,PT
	JRST	XCTEND		;FINISH OFF

;SUBROUTINE TO SAVE CURRENT BUFFER STATUS SO ANOTHER CAN BE EXECUTED

EXCSVX:	SKIPE	XCTPSV		;ALREADY DOWN A LEVEL?
	JRST	XSXERR		;YES - ONLY ONE STACK ALLOWED
	MOVE	T1,XCTPTR	;NO - SAVE ACTIVE BUFFER POINTER
	MOVEM	T1,XCTPSV
	MOVE	T1,XCTACR	;AND ACTIVE BUFFER STARTING POINTER
	MOVEM	T1,XCTASV
	MOVEM	T3,XCTNSV       ;SAVE ACTIVE NUMBER OF ITERATIONS
	MOVEM	T4,XCTISV       ;SAVE NOMINAL NUMBER OF ITERATIONS
	POPJ	P,		;NOW GO BACK AND DO THE SET-UP

;HERE FOR JUST ENTER EXECUTE: OPEN BUFFER AND START SAVING COMMANDS

EXCOPN:	TRO	F,XSV		;SET FLAG TO SAVE COMMANDS
	SETZM	XCTITR		;CLEAR NUMBER OF ITERATIONS
	SETZM	XCTNUM
EXCOP1:	SKIPN	T1,XCTACW	;GET POINTER TO THE ACTIVE BUFFER
	JRST	XCOERR		;ERROR - NO BUFFER IS ACTIVE
	MOVEM	T1,XCTPTW	;SET IT UP
XCTEND:	PUSHJ	P,ERASPM
	JRST	DISCUR		;RE-POSITION CURSOR AND RETURN

;HERE TO SET UP AN EXECUTE BUFFER - IF GIVEN NAME IS NOT FOUND,
;CREATE BUFFER WITH THAT NAME

XCTSET:	TRZ	F,XSV		;IF OLD BUFFER WAS OPEN, CLOSE IT
	PUSHJ	P,XCTRED	;READ BUFFER NAME AND FIND IT
	JUMPGE	T1,XCTST1	;JUMP IF FOUND
	MOVEI	T1,XBFNUM-1	;ELSE CREATE IT - FIND OPEN SLOT
	SKIPE	XCTNAM(T1)
	SOJGE	T1,.-1		;NOT OPEN - TRY AGAIN
	JUMPL	T1,XCSERR	;JUMP IF NONE OPEN - ERROR
	MOVEM	T4,XCTNAM(T1)	;SAVE NAME IN THIS SLOT
	MOVE	T2,XCTADR(T1)	;GET POINTER TO THIS BUFFER
	SETZM	1(T2)		;CLEAR WHATEVER USED TO BE THERE
XCTST1:	MOVE	T2,XCTADR(T1)	;GET POINTER TO THIS BUFFER
	MOVEM	T2,XCTACW	;SAVE AS ACTIVE POINTER
	TLNN	F,FLG		;WANT TO RETURN (TO SWHMNY)?
	JRST	XCTEND		;NO
	POPJ	P,		;YES

;HERE TO KILL OFF A GIVEN EXECUTE BUFFER

XCTKIL:	PUSHJ	P,XCTRED	;READ AND FIND NAME OF BUFFER
	JUMPL	T1,XCKERR	;NOT FOUND - ERROR
	SETZM	XCTNAM(T1)	;ELSE ZERO OUT ITS NAME
	MOVE	T2,XCTADR(T1)	;SEE IF IT IS THE ACTIVE ONE
	CAMN	T2,XCTACW	;IS IT?
	SETZM	XCTACW		;YES - SAY THERE IS NO ACTIVE BUFFER
	JRST	XCTEND		;DONE

;HERE TO SAVE A STRING INTO THE ACTIVE BUFFER

XCTWRT:	MOVE	PT,[POINT 7,PARBUF,6]
	MOVE	T4,XCTACW	;GET POINTERS TO SOURCE AND TARGET
	SETZ	T0,		;CLEAR PARENTHETICAL FLAG

XCWRT1:	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,XCWEND	;DONE IF NULL
	CAIN	T1,"^"		;SOME COMMAND?
	JRST	XCWCMD		;YES - PURSUE IT
	CAIN	T1,"$"		;ENTER (OR ESCAPE)?
	MOVEI	T1,33		;YES - SET IT UP
	CAIN	T1,")"		;MAYBE THE END OF A REPEAT?
	JUMPN	T0,XCWRPE	;IF SO, STOP THE REPEAT
XCWRT2:	IDPB	T1,T4		;SAVE CHARACTER
	JRST	XCWRT1		;AND GET ANOTHER

XCWCMD:	ILDB	T1,PT		;GET 1ST LETTER OF COMMAND NAME
	CAIE	T1,")"		;REALLY WANT A CLOSE PAREN,
	CAIN	T1,"$"		;  OR A DOLLAR SIGN?
	JRST	XCWRT2		;YES - JUST SAVE IT
	CAIN	T1,"^"		;REALLY WANT AN UP-ARROW?
	JRST	[IDPB T1,T4	;YES - JUST GO SAVE IT TWICE
		 JRST XCWRT2]
	CAIG	T1,"9"		;NO - GOT A REPEAT COUNT?
	JRST	XCWRPT		;YES - SET COUNT UP
XCWCM1:	MOVEI	T2,"^"		;NO - GET AN UP-ARROW
	PUSHJ	P,XCWGET+1	;PUT NEW CHARACTER IN WITH IT
	PUSHJ	P,XCWGET	;GET REST OF COMMAND NAME
	CAME	T2,["^RF"]	;GOT A ROLL FORWARD
	CAMN	T2,["^RB"]	;  OR BACKWARD?
	JRST	XCWRT3		;YES - NEED TO GET ANOTHER CHARACTER
	LSH	T2,^D15		;NO - LEFT-JUSTIFY COMMAND NAME
XCWRT4:	MOVEI	T1,CMDLEN-1	;LOOK FOR COMMAND AMONG NAMES
	CAME	T2,CMDNAM(T1)	;IS THIS IT?
	SOJGE	T1,.-1		;NO - KEEP LOOKING
	JUMPL	T1,XCWERR	;ERROR IF NOT FOUND
	CAIGE	T1," "		;GOT A HIGH-NUMBERED COMMAND?
	JRST	XCWRT2		;NO - O.K.
	MOVEI	T2,"^"		;YES - PRECEDE IT WITH AN UP-ARROW
	IDPB	T2,T4
	JRST	XCWRT2		;THEN SAVE COMMAND

XCWRT3:	PUSHJ	P,XCWGET	;GET REST OF COMMAND NAME
	LSH	T2,^D8		;LEFT-JUSTIFY COMMAND NAME
	JRST	XCWRT4		;GO FIND THE COMMAND

XCWGET:	ILDB	T1,PT		;GET NEXT CHARACTER
	CAIL	T1,"a"		;LOWER CASE?
	SUBI	T1,40		;YES - CONVERT TO UPPER
	LSH	T2,7		;SHIFT OVER ALREADY-GOTS
	OR	T2,T1		;PUT NEW CHARACTER IN WITH THEM
	POPJ	P,		;DONE

XCWRPT:	HRREI	T2,-60(T1)	;CONVERT CHARACTER TO A DIGIT
	JUMPL	T2,XCWERR	;ERROR IF NOT NUMERIC
	SETO	T0,		;SET WITHIN-REPEAT FLAG
	MOVEI	T1,"^"		;ANNOUNCE START OF COUNT
	IDPB	T1,T4
	MOVEI	T1,"_"
	IDPB	T1,T4
XCWRP1:	ILDB	T1,PT		;GET NEXT CHARACTER
	CAIG	T1,"9"		;NUMERIC?
	CAIGE	T1,"0"
	JRST	XCWRP2		;NO - END OF COUNT
	SUBI	T1,"0"		;MAYBE - CONVERT TO A DIGIT
	IMULI	T2,^D10		;SHIFT OVER THE OLD STUFF
	ADD	T2,T1		;PUT NEW DIGIT IN
	JRST	XCWRP1		;AND GET ANOTHER ONE

XCWRP2:	IDPB	T2,T4		;SAVE REPEAT COUNT
	CAIN	T1,"("		;GOT START OF THE REPEAT BLOCK?
	JRST	XCWRT1		;YES - IGNORE IT
	JRST	XCWRT1+1	;ELSE PROCESS CHARACTER, WHATEVER IT IS

XCWRPE:	MOVEI	T1,"^"		;MARK THE END OF THE REPEAT SECTION
	IDPB	T1,T4
	MOVEI	T1,"_"
	IDPB	T1,T4
	SETZ	T0,		;CLEAR REPEAT FLAG
	JRST	XCWRT1		;GET NEXT CHARACTER

XCWEND:	SETZ	T1,		;END BUFFER WITH A NULL
	IDPB	T1,T4
	JUMPN	T0,XCWERP	;ERROR IF REPEAT BLOCK NOT CLOSED
	TLNN	F,FLG		;WANT TO RETURN (TO SWHMNY)?
	JRST	XCTEND		;NO
	POPJ	P,		;YES

XCWERR:	MOVEI	T1,[ASCIZ /#########Bad command name/]
	JRST	ERROR
XCWERP:	MOVEI	T1,[ASCIZ /#####Repeat block not closed/]
	JRST	ERROR

;HERE TO OUTPUT NAME AND CONTENTS OF ACTIVE BUFFER

XCTRDL:	MOVE	TY,[POINT 7,PARBUF] ;WRITE TO PARAMETER BUFFER
	MOVE	PT,XCTACW	;POINT TO ACTIVE EXECUTE BUFFER
	MOVEI	T2,XBFNUM-1	;LOOK FOR NAME OF BUFFER
	CAME	PT,XCTADR(T2)	;FIND WHEN POINTERS MATCH - NOW?
	SOJGE	T2,.-1		;NO - LOOP
	MOVE	T1,XCTNAM(T2)	;YES - GET NAME
	TRZ	T1,1		;CLEAR FLAG BIT IN NAME
	SKIPN	T1		;IS NAME NULL
	MOVE	T1,[ASCII /<NUL>/] ;YES - SET UP NULL NAME
	PUSHJ	P,PUTSEQ	;OUTPUT IT
	MOVEI	T1,":"		;SEPARATE NAME AND CONTENTS
	IDPB	T1,TY
	SETZ	T4,		;CLEAR REPEAT FLAG

XCRDL0:	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,XCREND	;IF NULL FINISH OFF
	CAIN	T1,"^"		;SPECIAL FLAG?
	JRST	XCRSPC		;YES - HANDLE SEPARATELY
	CAIGE	T1," "		;CONTROL CHARACTER?
	JRST	XCRCTL		;YES - HANDLE SEPARATELY
	CAIN	T1,"$"		;WANT A REAL DOLLAR SIGN?
	JRST	[MOVEI T1,"^"	;YES - DISPLAY IT AS UP-ARROW DOLLAR SIGN
		 IDPB  T1,TY
		 MOVEI T1,"$"
		 JRST  .+1]
XCRDL1:	IDPB	T1,TY		;OUTPUT CHARACTER
	JRST	XCRDL0		;AND GET ANOTHER

XCRSPC:	ILDB	T1,PT		;GET CHARACTER AFTER SPECIAL FLAG
	CAIN	T1,"_"		;GOT A REPEAT COUNT?
	JRST	XCRRPT		;YES - HANDLE SEPARATELY
	CAIE	T1,"^"		;WANT A REAL UP-ARROW?
	JRST	XCRCTL		;NO - IT'S REALLY A COMMAND
	IDPB	T1,TY		;YES - OUTPUT TWO ARROWS TO SHOW IT'S REAL
	JRST	XCRDL1

XCRCTL:	MOVE	T1,CMDNAM(T1)	;GET COMMAND NAME
	PUSHJ	P,PUTSQ1	;OUTPUT IT
	JRST	XCRDL0		;BACK TO FLOW

XCRRPT:	JUMPN	T4,XCRRPE	;IF IN A REPEAT BLOCK, END IT
	SETO	T4,		;ELSE SET REPEAT FLAG
	MOVEI	T1,"^"		;FLAG NUMBER AS A COUNT
	IDPB	T1,TY
	ILDB	T1,PT		;GET REPEAT COUNT
	PUSHJ	P,PUTNUM	;OUTPUT IT
	MOVEI	T1,"("		;START OFF THE REPEAT BLOCK
	JRST	XCRDL1		;SAVE CHARACTER AND FLOW

XCRRPE:	MOVEI	T1,")"		;END THE REPEAT BLOCK
	SETZ	T4,		;CLEAR REPEAT FLAG
	JRST	XCRDL1		;SAVE CHARACTER AND FLOW

XCREND:	SETZ	T1,		;END WITH A NULL
	IDPB	T1,TY
	MOVEM	TY,PARPTR	;SAVE TYPE POINTER AS PARAMETER POINTER
	MOVE	TY,[010700,,TYPBUF-1] ;POINT BACK TO TYPE BUFFER
	JRST	RECALL		;PRETEND THIS WAS THE LAST PARAM TYPED

;HERE TO OUTPUT LIST OF DEFINED NAMES

XCTNML:	PUSHJ	P,ERASPM	;FIX UP THE SCREEN
	PUSHJ	P,CBOTOM	;MOVE TO BOTTOM LINE AND CLEAR IT
	PUSHJ	P,PROTON	;PROTECT THE OUTPUT
	MOVEI	T2,XBFNUM-1	;LOOK FOR NAME OF BUFFER
XCNAM1:	SKIPN	T1,XCTNAM(T2)	;GET A NAME - ANY?
	SOJGE	T2,.-1
	JUMPL	T2,XCNEND	;JUMP WHEN DONE
	TRZ	T1,1		;ELSE CLEAR FLAG BIT IN NAME
	SKIPN	T1		;IS THIS THE NULL BUFFER?
	MOVE	T1,[ASCII /<NUL>/] ;YES - SET UP NULL NAME
	PUSHJ	P,PUTSEQ	;OUTPUT NAME
	MOVE	T1,[ASCII /   /];SEPARATE NAME FROM NEXT NAME
	PUSHJ	P,PUTSEQ
	SOJGE	T2,XCNAM1	;GET NEXT NAME

XCNEND:	PUSHJ	P,PROTOF	;DONE - ERASE PARAMETER
	TLO	F,FBL		;MARK BOTTOM LINE AS FRAGGED
	JRST	DISCUR		;AND RE-POSITION THE CURSOR

;SUBROUTINE TO READ THE BUFFER NAME AND FIND IT AMONG XCTNAM
;RETURNS NAME IN T4; INDEX IN T1. T1/-1 IF NOT FOUND

XCTRED:	MOVE	PT,[POINT 7,T4] ;GET POINTERS TO TARGET, SOURCE OF NAME
	MOVE	T2,[POINT 7,PARBUF,6]
	MOVEI	T4,1		;CLEAR TARGET - NAME WILL HAVE LOW BIT ON
	MOVEI	T3,5		;READ AT MOST 5 CHARACTERS
XCTRD1:	PUSHJ	P,REDCHR	;GET A CHARACTER
	JUMPE	T1,XCTRD2	;DONE IF NULL
	IDPB	T1,PT		;STORE IT IN TARGET
	SOJG	T3,XCTRD1	;GET ANOTHER CHARACTER
XCTRD2:	MOVEI	T1,XBFNUM-1	;NOW LOOK FOR NAME
	CAME	T4,XCTNAM(T1)	;IS THIS IT?
	SOJGE	T1,.-1		;NO - LOOP
	POPJ	P,		;YES (OR NOT FOUND) - RETURN

;EXECUTE, NO PARAMETER: IF BUFFER IS OPEN, JUST CLOSE IT
;IF ALREADY CLOSED, SET TO DO SAME NUMBER OF ITERATIONS AS LAST TIME

EXCNPM:	TRZN	F,XSV		;NO LONGER SAVING COMMANDS
	JRST	EXCNP1		;WEREN'T ANYWAY - SET UP FOR ITERATING
	SETZ	T1,		;END EXECUTE BUFFER WITH A NULL
	DPB	T1,XCTPTW	;  (PUT IT OVER THE X-COMMAND)
	JRST	LOOP		;GET A NEW COMMAND

EXCNP1:	MOVE	T3,XCTITR	;GET NUMBER OF ITERATIONS
	SKIPLE	T4,T3		;ANY?
	JRST	EXCUT1		;YES - GO SET IT UP
	MOVEI	T1,[ASCIZ /####Enter number of iterations/]
	JRST	ERROR

;GET A COMMAND FROM THE EXECUTE BUFFER, FROM LOOP

XCTGET:	ILDB	T1,XCTPTR	;GET A COMMAND FROM READ BUFFER
	CAIN	T1,"^"		;SPECIAL CHARACTER FLAG?
	JRST	XCTGT1		;YES - HANDLE SPECIALLY
	JUMPN	T1,XCTGTE	;IF GOT A REAL CHARACTER, USE IT
	MOVE	T1,XCTACR	;ELSE POINT BACK TO START OF BUFFER
	MOVEM	T1,XCTPTR
	SOSG	T2,XCTNUM	;WANT TO DO ANOTHER ITERATION?
	JRST	XCTDUN		;NO - FINISH OFF
TOPS10<	TRNN	T2,7		;YES - REALLY WANT TO WHISTLE?
	IONEOU	[7]		;YES - WHISTLE
	INCHRS	T1		;ANY TYPEAHEAD?
	  JRST	XCTGET		;NO - CONTINUE
	ANDI	T1,177
	CAIN	T1,177		;IS IT A RUBOUT?
	JRST	RUBEXC		;YES - ABORT THE EXECUTE
>
TOPS20<	MOVEI	T1,7		;YES - GET SET TO WHISTLE
	TRNN	T2,7		;REALLY WANT TO?
	PBOUT			;YES - DO SO
>
	JRST	XCTGET		;AND GET FIRST COMMAND

XCTGTE:	CAIL	T1," "		;SOME CONTROL CHARACTER?
	JRST	ALPNUM		;NO - JUST PUT IT IN FILE OR BUFFER
	JRST	LOOP2		;YES - HANDLE IT

XCTGT1:	ILDB	T1,XCTPTR	;GET CHARACTER AFTER THE UP-ARROW
	CAIN	T1,"_"		;GOT THE START OR END OF A REPEAT?
	JRST	XCTGRP		;YES - HANDLE IT
	CAIN	T1,"^"		;WANT A REAL UP-ARROW?
	JRST	ALPNUM		;YES - HANDLE IT
	JRST	LOOP2		;NO - PROCESS THE COMMAND

XCTGRP:	SOSL	T1,XCTRPT	;ENTERING OR EXITING THE REPEAT?
	JRST	XCTGRX		;EXITING - SET UP ANOTHER LOOP
	ILDB	T1,XCTPTR	;GET REPEAT COUNT
	MOVEM	T1,XCTRPT	;SAVE IT
	MOVE	T1,XCTPTR	;GET POINTER TO REPEATABLE COMMAND
	MOVEM	T1,XCTRPR	;SAVE IT
	JRST	XCTGET		;PICK UP THE FIRST ITERATION

XCTGRX:	JUMPE	T1,XCTGET	;IF REPEAT DONE, JUST FORGE ON
	MOVE	T1,XCTRPR	;ELSE GET REPEAT POINTER
	MOVEM	T1,XCTPTR	;DO ANOTHER LOOP
	JRST	XCTGET

XCTDUN:	SETZ	T1,		;GET READY TO ZERO THINGS
	SKIPN	XCTPSV		;DONE - GOT A SAVED POINTER?
	JRST	XCTDN1		;NO - REALLY DONE
	EXCH	T1,XCTPSV	;YES - GET AND ZERO SAVED POINTER
	MOVEM	T1,XCTPTR	;MAKE IT ACTIVE AGAIN
	MOVE	T1,XCTASV	;GET SAVED STARTING POINTER
	MOVEM	T1,XCTACR	;SET IT UP
	MOVE	T1,XCTISV	;GET NOMINAL SAVED ITERATIONS
	MOVEM	T1,XCTITR	;SET THEM UP, TOO
	MOVE	T1,XCTNSV	;GET SAVED ITERATIONS
	MOVEM	T1,XCTNUM	;SET THEM UP, TOO
	JRST	XCTGET		;AND CONTINUE WITH THEM

XCTDN1:	TRZ	F,XCT		;STOP READING FROM BUFFER
	EXCH	T1,XCTASV	;GET AND ZERO SAVED STARTING POINTER
	JUMPE	T1,XCTDN2	;IS THERE ONE?
	MOVEM	T1,XCTACW	;YES - MAKE IT REALLY ACTIVE
XCTDN2:	MOVE	TY,[010700,,TYPBUF-1]
	PUSHJ	P,DISPLL	;DISPLAY A NEW SCREENFUL
	PUSHJ	P,POSCUR	;RE-POSITION THE CURSOR
	JRST	LOOP		;AND GET A NEW COMMAND

;EXECUTE ERROR MESSAGES

XSXERR:	MOVEI	T1,[ASCIZ /####Execute stacked too deeply/]
	SETZM	XCTPSV
	JRST	ERROR
XCXERR:	MOVEI	T1,[ASCIZ /######Current buffer is empty/]
	JRST	ERROR
XCOERR:	MOVEI	T1,[ASCIZ /########No buffer is active/]
	JRST	ERROR
XCSERR:	MOVEI	T1,[ASCIZ /#No free buffers - kill something/]
	JRST	ERROR
XCKERR:	MOVEI	T1,[ASCIZ /####Can't kill - name not found/]
	JRST	ERROR
XCEERR:	MOVEI	T1,[ASCIZ /####Start or end of file reached/]
	SKIPA	TY,[010700,,TYPBUF-1]
XCTERR:	MOVEI	T1,[ASCIZ /Execute buffer is about to overflow/]
	JRST	ERROR
SUBTTL	Select input file

;HERE TO SET UP A NEW FILE FOR EDITING

SETFIL:	MOVE	T1,[FILSPC,,OLDSPC]
TOPS10<	BLT	T1,OLDSPC+13+11+4+SFDS >
TOPS20<	BLT	T1,OLDSPC+13 >	;SAVE CURRENT SPECS IN OLD SPEC AREA
SETFLC:	SETZM	MFLPTR		;FORGET STAT.TMP STUFF IF USER GIVES A FILE
	MOVEM	RW,SAVERW	;SAVE CURRENT ROW AND COLUMN POSITIONS
	HRLM	CM,SAVERW
	MOVE	T1,DISPTR	;SAVE CURRENT DISPLAY POINTER
	MOVEM	T1,SAVEDP
	MOVEM	SL,SAVESL	;SAVE SLIDE
	MOVE	T3,[POINT 7,FILSPC]
	PUSHJ	P,PELS.F	;PICK UP USERS FILESPEC, IF ANY
	MOVEM	RW,SAVERW	;SAVE POSITION AGAIN IN CASE OF CUR MVMT
	HRLM	CM,SAVERW
	PUSHJ	P,PNTSTT	;SET UP POINTERS TO START OF FILE
	PUSHJ	P,PARSEF	;PARSE FILESPEC AND (MAYBE) SWITCHES
	PUSHJ	P,SAMFIL	;SEE IF NEW FILE IS SAME AS OLD ONE
	TLZ	F,PCM!FLG!ENT	;CLEAR MARK, PARSE, AND ENTER FLAGS
	SETZ	T1,		;CLEAR FLAG - GOT A FILE FROM RESCAN?
	EXCH	T1,RSCANF
	JUMPN	T1,SETFL1	;YES - DON'T SAVE; JUST GO LOOK IT UP
	TLNE	F,SMF		;ARE FILES THE SAME?
	JRST	NEWFIL+1	;YES - JUST SET THE THE NEW POSITION

	MOVEI	T4,OLDSPC	;NO - PREPARE TO SAVE FILE
TOPS10<	MOVEI	PT,OLDBLK
>
	SKIPN	OLDSPC		;IS THERE AN ACTIVE FILE?
	JRST	SETFL1		;NO - DON'T SAVE IT
	MOVE	T1,SAVEDP	
	MOVEM	T1,DISPTR
	PUSHJ	P,SAVFIL	;SAVE THE CURRENT FILE
	MOVE	T1,[010700,,BUFFER-1]
	EXCH	T1,DISPTR	
	MOVEM	T1,SAVEDP

TOPS10<	SETFL1:	TLZ	F,FLG		;CLEAR FLAG FROM PARSEF
	OPEN	2,FILBLK	;OPEN FILE FOR EDITING
	  JRST	SETERR
	SETZM	FILFIL+.RBPPN	;[CSM] Monitor does not like pointer to 0 PPN
	MOVE	T1,FILPPN	;[JMS] Get PPN (zero if default)
	SKIPE	FILUNM		;[JMS] If user name,
	 MOVEI	T1,FILUNM	;[JMS] Use it
	SKIPE	FILSFD		;[JMS] If any SFDs,
	 MOVEI	T1,FILPTH	;[CSM] Get pointer to path
	MOVEM	T1,FILFIL+.RBPPN;[CSM] Store PPN if no SFDs, else pointer to SFD
LK:	LOOKUP	2,FILFIL	;SET UP FILE FOR READING AND WRITING
	  JRST	SETERR
IFDEC<	MOVEI	T1,FILPTH	;[CSM] Make sure pointer to path is there
	MOVEM	T1,FILFIL+.RBPPN;[CSM]  in case SKIPE T2,FILPPN skipped
	MOVEI	T1,2		;[CSM] Get channel number
	MOVEM	T1,FILPTH	;[CSM] Put in PATH block
	MOVE	T1,[SFDS+4,,FILPTH]
	MOVE	T2,FILPPN	;[JMS]
	PATH.	T1,		;[CSM] Find out where the file really is
	  JRST	SETERR
	MOVE	T1,FILPTH+0	;[CSM] Get device it was found on
	MOVEM	T1,FILBLK+1	;[CSM] Create new file on same disk
	SKIPN	T2		;[CSM] Was the old PPN zero?
>  ;End IFDEC
	 PUSHJ	P,UNPARS	;[CSM] Yes, file may be in LIB:, so check it
;[CSM] Check for write access by trying to ENTER the file
IFDEC<	TLNE	F,RDO		;[CSM] Want file read-only?
	 JRST	SETFL2		;[CSM] Yes
	OPEN	5,FILBLK	;[CSM] Open scratch channel
	  HALT	.		;[CSM] Cannot fail
	MOVE	T1,FILFIL+.RBNAM;[CSM] Get file name
	MOVE	T2,FILFIL+.RBEXT;[CSM] Extension
	MOVE	T3,FILFIL+.RBPRV;[CSM] Protection
	MOVE	T4,FILFIL+.RBPPN;[CSM] Actual path
	ENTER	5,T1		;[CSM] Try to create
	  TLOA	F,RDO		;NO - READ ONLY
	TLZ	F,RDO		;YES - ENABLE FOR WRITING
	MOVEI	T1,5		;[CSM] Channel number
	RESDV.	T1,		;[CSM] Reset channel, without superseding file
	  RELEAS 5,		;[CSM] RESDV. not implemented
SETFL2:	>  ;End IFDEC
	SETOM	INJFN		;SAY FILE HAS BEEN SET UP
	MOVE	T1,FILFIL+.RBSIZ;GET SIZE OF FILE (IN WORDS)
;	SKIPE	FILSBK		;GOT A LIMIT ON THE AMOUNT TO READ?
;	JRST	[CAML T1,FILSBK	;YES - IS FILE LARGER THAT THE LIMIT?
;		 EXCH T1,FILSBK	;YES - SWAP THE TWO
;		 JRST .+1]	;CONTINUE
	CAILE	T1,MAXSIZ	;[CSM] Is file too big?
	 JRST	SSZERR		;YES - ERROR
	MOVEM	T1,FILSIZ	;NO - SAVE FILE SIZE
	HRRZ	T2,DISPTR	;GET DISPLAY POINTER ADDRESS
	SUBI	T2,BUFFER
	CAMGE	T1,T2		;IS IT POINTING BEYOND THE BUFFER?
	JRST	[MOVE  T2,[010700,,BUFFER-1]
		 MOVEM T2,DISPTR ;YES - POINT TO START OF BUFFER
		 JRST  .+1]
	LSH	T1,-7		;GET SIZE IN BLOCKS
	MOVEM	T1,FILBSZ	;SAVE IT, TOO
	HLLZS	FILFIL+.RBEXT	;CLEAN UP FILESPEC BLOCK
	SETZM	FILFIL+.RBPRV
	MOVEI	T1,BUFFER-1	;SHRINK CORE TO GET RID OF OLD FILE
	CORE	T1,
	  HALT	.
	MOVE	T1,FILSIZ	;EXPAND CORE TO ACCOMMODATE NEW FILE
	ADDI	T1,BUFFER
	CAMGE	T1,.JBREL	;IS IT WITHIN PRESENT CORE?
	JRST	[SETZM BUFFER	;YES - CLEAR OUT ALL OF CORE
		 MOVE  T2,[BUFFER,,BUFFER+1]
		 MOVE  T3,.JBREL
		 BLT   T2,(T3)
		 JRST  .+1]
	ADDI	T1,2000
	CORE	T1,
	  HALT	.
	MOVN	T1,FILSIZ
	SKIPN	T1		;[CSM] Zero length file?
	 MOVNI	T1,1		;[CSM] Yes, use 1 word
	HRLM	T1,FILCCL	;READ ENTIRE FILE IN
	INPUT	2,FILCCL
	RELEAS	2,		;GET RID OF CHANNEL
	MOVE	T1,FILSIZ
>  ;End TOPS10
TOPS20<
SETFL1:	MOVE	T1,[GJ%OLD+GJ%SHT]
	HRROI	T2,FILSPC	;GET A JFN FOR THIS FILE
	GTJFN
	  JRST	SETERR
	MOVEM	T1,INJFN

	MOVE	T2,[OF%THW+OF%RD+OF%WR]
	OPENF
	  JRST	SETERR		;won't work if write protected, etc.
	TLZ	F,RDO		;FILE WILL ALWAYS BE WRITEABLE (FOR NOW)

	MOVE	T2,[1,,.FBBYV]	;FIND BYTE SIZE OF THE FILE
	MOVEI	T3,T4		;  IN T4
	GTFDB
	HLRZS	T4
	ANDI	T4,7700		;CLEAR OUT ALL FIELDS BUT BYTE SIZE
	MOVEI	PT,1		;ASSUME BYTE SIZE IS 7
	CAIN	T4,4400		;IS IT REALLY 36?
	MOVEI	PT,5		;YES - MAKE ADJUSTMENT

	SIZEF			;FIND THE SIZE OF THE FILE
	  JRST	SETERR
	IMUL	T2,PT		;CONVERT BYTE COUNT INTO CHARACTER COUNT
	MOVEM	T2,FILSIZ	;AND SAVE IT
	MOVEM	T3,FILBSZ	;AND BLOCK COUNT

	HRLZ	T1,INJFN	;READ IN THE ENTIRE FILE
	MOVE	T2,[400000,,BUFBLK]
	ADD	T3,[PM%CNT+PM%RD+PM%CPY]
	PMAP

	MOVE	T1,FILSIZ	;GET BYTE SIZE
	IDIVI	T1,5		;CONVERT TO WORDS
>  ;End TOPS20
	MOVE	EN,[010700,,BUFFER]
	ADDB	EN,T1		;SET UP POINTER TO END OF FILE
	TRO	F,GFL		;NOTE THAT A FILE HAS BEEN SET UP
	TLZ	F,FLG		;CLEAR EXTENSION FLAG
	SKIPN	DISPTR		;WANT TO USE PRE-SET POINTERS?
	PUSHJ	P,PRESET	;YES - SET THEM UP
	JRST	SETCR0		;NOW DRIVE ON

SETCR:	ADD	T1,[70000,,0]	;BACK UP END POINTER A NOTCH
	JUMPGE	T1,.+2
	SUB	T1,[430000,,1]
SETCR0:	LDB	T2,T1		;GET CHARACTER
	JUMPE	T2,SETCR	;SKIP IF NULL
	CAIE	T2,12		;ELSE GOT A LINEFEED?
	JRST	SETCR2		;NO - GO ADD A CRLF
	ADD	T1,[70000,,0]	;YES - SEE IF IT'S PRECEDED BY A <CR>
	JUMPGE	T1,.+2		;BACK UP A NOTCH
	SUB	T1,[430000,,1]
	LDB	T2,T1		;GET CHARACTER
	CAIN	T2,15		;GOT A <CR>
	JRST	SETLNO		;YES - O.K.

SETCR2:	MOVE	T1,[BYTE (7) 15,12] ;GET A <CRLF>
	MOVEM	T1,1(EN)	;SAVE AS LAST WORD OF FILE
	AOJA	EN,SETLNO	;NOW GO CHECK FOR LINE NUMBERS

;NOW SEE IF LOW ORDER BITS IS ON IN FILE WORDS: IF SO, FILE HAS
;LINE NUMBERS OR IS NOT TEXT. SET READ-ONLY FLAG AND WARN USER

SETLNO:	MOVEI	T3,BUFFER	;POINT TO START OF BUFFER
	MOVEI	T4,BUFFER+200	;AND 128 WORDS OUT, OR END
	CAILE	T4,(EN)		;FILE SMALLER THAN 128?
	HRR	T4,EN		;YES - POINT TO END INSTEAD
	MOVEI	T2,1		;GET BIT FOR COMPARISONS
SETLN1:	TDNE	T2,(T3)		;DOES THIS WORD HAVE LOW BIT ON?
	JRST	SETLNL		;YES - SCREAM
	CAME	T3,T4		;NO - AT END?
	AOJA	T3,SETLN1	;NO - LOOP
	TLNN	F,RDO		;NO LINE NRS, BUT IS FILE READ-ONLY ANYWAY?
	JRST	NEWFIL		;NO - O.K.
	SKIPA	T1,[[ASCIZ /######File cannot be modified/]]

SETLNL:	MOVEI	T1,[ASCIZ /######Line numbers - read only/]
	PUSHJ	P,ERRDSP	;DISPLAY THE MESSAGE
	TLO	F,RDO		;MARK FILE AS READ ONLY
	JRST	NEWFIL		;AND GO EDIT IT

TOPS10<
SSZERR:	MOVEI	T1,[ASCIZ /#####File is too large to edit/]
	JRST	STFERR
>
;HERE IF NO PARAMETER WAS TYPED - SET UP PREVIOUS FILE, AND SAVE PRESENT
;ONE AS NEW PREVIOUS ONE

SETNPM:	SKIPN	OLDSPC		;ARE THERE OLD FILE SPECS?
	JRST	SETERX		;NO - ERROR
TOPS10<	MOVEI	PT,FILBLK	;POINT TO NAME OF CURRENT FILE
>
	MOVEI	T4,FILSPC	;POINT TO SPECS (BOTH FOR SAVFIL)
	TLNE	F,SMF		;ARE FILE AND ALTERNATE FILE THE SAME?
	JRST	.+3		;YES - DON'T SAVE
	SKIPE	FILSPC		;IS THERE AN ACTIVE FILE?
	PUSHJ	P,SAVFIL	;YES - SAVE IT NOW
	SKIPE	PT,MFLPTR	;GOT MORE FILES IN nnnSTT.TMP?
	PUSHJ	P,SETMFL	;YES - SET NEXT ONE UP AS ALTERNATE
TOPS10<	MOVEI	T1,13+11+4+SFDS >
TOPS20<	MOVEI	T1,13 >		;SWAP THE 8 WORDS OF THE FILE SPECS
SETNP1:	MOVE	T2,FILSPC(T1)
	EXCH	T2,OLDSPC(T1)
	MOVEM	T2,FILSPC(T1)
	SOJGE	T1,SETNP1
	HRL	RW,CM		;SWAP ROW AND COLUMN POSITIONS
	EXCH	RW,SAVERW
	HLRZ	CM,RW
	HRRZ	RW,RW
	MOVE	T1,DISPTR	;SWAP DISPLAY POINTER
	EXCH	T1,SAVEDP
	MOVEM	T1,DISPTR
	EXCH	SL,SAVESL	;SET UP SLIDE
	SKIPN	DISPTR		;NEED TO PARSE SPECS (FROM .TMP)?
	PUSHJ	P,PARSEF	;YES - DO SO
	TLO	F,XPC!XPL!XPB	;NO POINTERS ARE VALID
	TLZ	F,FLG		;CLEAR FLAG FROM PARSEF
;	SKIPN	DISPTR		;NEED TO SET UP PRE-SET POINTERS?
;	PUSHJ	P,PRESET	;YES - DO SO
	TLNN	F,SMF		;ARE FILE AND ALTERNATE FILE THE SAME?
	JRST	SETFL1		;NO - GO SET UP THAT FILE
	SKIPN	DISPTR		;NEED TO SET UP PRE-SET POINTERS?
	PUSHJ	P,PRESET	;YES - DO SO
	JRST	NEWFIL+1	;YES - DON'T LOOK FILE UP; JUST USE IT

;HERE TO CREATE FILE. WRITE FIRST LINE IN IT, CLOSE IT,
;AND PRETEND IT WAS THERE ALL THE TIME

TOPS10<
SETCRE:	OPEN	5,GENBLK	;OPEN A DUMP MODE OUTPUT FILE
	  HALT	.		;ON CHANNEL 5
	ENTER	5,FILFIL
	  HALT	.
	HLLZS	FILFIL+.RBEXT
	SETZM	FILFIL+.RBPRV
	OUTPUT	5,NEWCCL	;OUTPUT CHEERY MESSAGE
	RELEAS	5,		;CLOSE THE FILE
	POPJ	P,		;RETURN TO LOOK UP THE FILE FOR EDITING
>
TOPS20<
SETCRE:	HRROI	T2,FILSPC	;SET UP NEW FILE FOR OUTPUT
	PUSHJ	P,SETOUT
	MOVE	T2,[POINT 7,NEWMSG]
	SETZ	T3,
	SOUT			;WRITE STARTING MESSAGE TO NEW FILE
	MOVEI	T2,15		;END IT ALL WITH A <CR>
	BOUT
	MOVEI	T2,12
	BOUT
	CLOSF			;COMPLETE THE FILE
	  HALTF
	POPJ	P,		;RETURN TO LOOK UP THE FILE FOR EDITING
>
SETERR:	TRZN	F,CRE		;REALLY WANT TO CREATE?
	JRST	SETER0		;NO - IT'S A REAL ERROR
	PUSHJ	P,SETCRE	;YES - CREATE THE FILE
	JRST	SETFL1		;NOW LOOK IT UP
SETER0:
TOPS10<	TLNE	F,FLG		;WORKING ON A LIST OF EXT'S?
	JRST	SETER1		;YES - KEEP WORKING
	SKIPE	FILFIL+.RBEXT	;IS THERE NO CURRENT EXTENSION?
	JRST	SETER2		;NO - IT'S A REAL ERROR
	TLO	F,FLG		;YES - TRY SOME USUAL EXTENSIONS
	MOVE	PT,[POINT 18,EXTTBL]
	HLRZ	T1,FILBLK+1	;GET DEVICE NAME
	CAIE	T1,'DSK'	;IS IT DISK?
	JRST	SETR1A		;NO - TRY USING DEVICE AS EXT, TOO

SETER1:	ILDB	T1,PT		;SET UP ANOTHER EXTENSION
	JUMPE	T1,SETER2	;UNLESS NONE LEFT; THEN, ERROR
SETR1A:	HRLZM	T1,FILFIL+.RBEXT
	PUSHJ	P,UNPARS	;UNPARSE THESE NEW SPECS
	JRST	SETFL1
SETER2:	TLZ	F,FLG
>
	MOVEI	T1,[ASCIZ /##########File not found/]
	JRST	STFERR		;GO DISPLAY THE ERROR

SETERX:	MOVEI	T1,[ASCIZ /#########No alternate file/]
	JRST	ERROR

;SUBROUTINE TO READ NEXT LINE OF STAT.TMP FILE INTO (T4 - FRAGGED)
;ENTER ALSO WITH PT/MFLPTR
;works only with TOPS-10 just now; frags end of pick buffer

SETMFE:	MOVE	T4,[POINT 7,OLDSPC] ;(LET STFERR READ INTO ALTERNATE BLOCK)
	SETZM	SAVEDP		;CLEAR SAVED DISPLAY POINTER
	JRST	SETMF0		;CONTINUE

SETMFL:	MOVE	T4,[POINT 7,FILSPC] ;POINT TO FILSPC BLOCK
	SETZM	DISPTR		;CLEAR DISPLAY PTR SO SPECS WILL BE PARSED
SETMF0:
TOPS20<	POPJ	P,		;TOPS20: APRIL FOOL
>
TOPS10<	 ;[CSM] Try TMP:SED before DSK:000SST.TMP (should be there already)
	MOVE	T1,[1,,STTCCL-1];[CSM] Code to read a file
	TMPCOR	T1,		;[CSM] Read TMP:SED
	  SKIPA			;[CSM] Error, try disk
	 JRST	SETMF1		;[CSM] Got it
>
	HRROI	T2,STTFIL
	PUSHJ	P,SETIN		;GO FIND THE TEMPORARY FILE
	JUMPE	T1,CPOPJ	;IF NONE, JUST RETURN (BUT THERE BETTER BE)
TOPS10<	SETZ	T2,
	INPUT	5,STTCCL	;READ STATUS INTO PICK BUFFER
	RELEAS	5,
SETMF1: >
	TRZ	F,GFL		;CURRENT FILE IS NO LONGER AROUND
	PUSHJ	P,TMPGET	;READ NEW SPECS INTO CURRENT FILE AREA
	CAIGE	T1,"0"		;IS THERE AN ALPHANUMERIC ON THE NEXT LINE?
	SETZM	MFLPTR		;NO - FORGET THE POINTER
	POPJ	P,
SUBTTL	The ENTER command

;HERE TO ENTER AN ARGUMENT TO A COMMAND

ENTERA:	TLOE	F,ENT		;SAY ENTER TYPED - WAS IT ALREADY?
	JRST	ENTHLP		;YES - MAYBE GIVE SOME HELP
	MOVE	T1,[POINT 7,PARBUF] ;POINT TO START OF PARAMETER BUFFER
	MOVEM	T1,PARPTR
ENTER0:	DMOVEM	RW,SAVPOS	;SAVE POSITION, IN CASE OF CURSOR MOVE
	PUSHJ	P,MRKCUR	;MARK THE CURRENT CURSOR POSITION
	MOVE	RW,LPP.1	;MOVE TO THE BOTTOM LEFT OF THE SCREEN
	SETZ	CM,
	TRNE	F,XCT		;EXECUTING?
	JRST	LOOP		;YES - DONE NOW

ENTERM:	PUSHJ	P,CBOTOM	;MOVE TO BOTTOM OF SCREEN
	TLZ	F,FBL		;BOTTOM LINE IS REALLY O.K.
	PUSHJ	P,PROTON	;TURN PROTECTION ON
		   ;<
	MOVEI	T1,">"		;PUT UP ENTER MARK
	IDPB	T1,TY
	PUSHJ	P,PROTOF	;TURN OFF PROTECTION
	TLZE	F,FLG		;WANT TO RETURN (TO RECALL)?
	POPJ	P,		;YES
	PUSHJ	P,PUTTYP	;ELSE TYPE IT ALL OUT NOW
	JRST	LOOP

;SUBROUTINE TO MARK CURRENT CURSOR POSITION
;NOTE: EXPECTS CALLER TO CALL PUTTYP TO OUTPUT ALL THIS

MRKCUR:	PUSHJ	P,MAKCPT	;MAKE MARK AT CURSOR POSITION - MAKE POINTER
	MOVE	T2,CHRPTR	;GET CURSOR POINTER
	MOVEM	T2,SAVCPT	;SAVE FOR AFTER ENTER
	TRNE	F,XCT		;EXECUTING?
	POPJ	P,		;YES - DONE NOW
	CAIGE	T3," "		;POINTING TO A CONTROL CHARACTER?
	JRST	[CAIE  T3,15	;YES - GOT A <CR>,
		 CAIN  T3,11	;  OR A TAB?
		 MOVEI T3," "	;YES - USE A SPACE INSTEAD
		 JRST  .+1]
	MOVEM	T3,CHRCUR	;SAVE IT FOR LATER
	TLNE	TM,MRK		;WANT TO PUT UP A SPECIAL MARK?
	JRST	[MOVE T1,MAR(TM) ;YES - GET THE MARK
		 IDPB T1,TY	;SAVE IT
		 POPJ P,]	;AND DISPLAY IT
	CAIGE	T3," "		;GOT A CONTROL CHARACTER?
	POPJ	P,		;YES - IT'S ALREADY REVERSED
	PUSHJ	P,PROTON	;TURN PROTECTION ON
	IDPB	T3,TY
	JRST	PROTOF		;TURN OFF PROTECTION AND RETURN

;HERE ON ENTER ENTER. IF SOMETHING ELSE TYPED, IGNORE SECOND ENTER
;ELSE PREPARE TO GIVE HELP (UNLESS NO HELP [NHP] FLAG IS SET)

ENTHLP:	MOVE	T1,[POINT 7,PARBUF]
	TRNN	F,NHP!CMV	;REALLY DON'T WANT HELP, CURSOR MOVEMENT,
	CAME    T1,PARPTR	;  OR HAS PART OF A PARAMETER BEEN TYPED?
	JRST	LOOP		;EITHER - INGORE THIS EXTRA ENTER
	MOVEI	DO,1000		;NOTE THAT HELP IS BEING GIVEN
	DMOVE	RW,SAVPOS	;RESTORE SAVED POSITION
ENTHL0:	PUSHJ	P,PROTON	;NEITHER - SAY HELP IS ON THE WAY
	MOVEI	T1,[ASCIZ /Type any command to get help for it /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,[ASCIZ /(or G to get out): /]
	PUSHJ	P,PUTSTG
	PUSHJ	P,PROTOF
	PUSHJ	P,PUTTYP	;TYPE OUT THE MESSAGE

	SKIPE	T1,PIKCNT	;SEE IF PICK BUFFER WILL BE FRAGGED - LOADED?
	TRNE	F,POV		;  AND NOT ON DISK?
	JRST	ENTHL1		;NOT LOADED OR ON DISK - O.K.
	IDIVI	T1,5		;FIND NUMBER OF WORDS USED
	CAIL	T1,PCBSIZ-201	;WILL HELP MESSAGE FRAG IT?
	SETZM	PIKCNT		;YES - PRETEND PICK BUFFER IS EMPTY

ENTHL1:	TLO	F,FBL		;BOTTOM LINE IS FRAGGED
	TLZ	F,ENT		;NO LONGER ENTERING A PARAMETER
TOPS10<	INCHRW T1>		;GET CHARACTER FROM TERMINAL
TOPS20<	TLZE	F,INT		;AT INTERRUPT LEVEL?
	DEBRK			;YES - RETURN FROM IT TO DO THE PBIN
	PBIN			;READ A CHARACTER
>  ;End of TOPS20
	ANDI	T1,177		;TOPS-10 reads 8 bits in PIM
	CAIE	T1,"G"		;GOT A "G"?
	CAIN	T1,"g"
	JRST	ENTHLE		;YES - CAN'T GIVE HELP
	CAIL	T1," "		;SOME CONTROL CHARACTER?
	JRST	HLPERR		;NO - CAN'T GIVE HELP
	ADD	T1,ITB(TM)	;GET OFFSET IN TERMINAL TABLE
ENTHL2:	SKIPGE	T1,(T1)		;IS IT A NORMAL COMMAND?
	PUSHJ	P,SUBTAB	;NO - READ MORE CHARACTERS
	TLNE	TM,LSD		;ARE LINEFEED AND CURSOR-DOWN ALIKE?
	JRST	[CAIN  T1,12	;YES - GOT A LINEFEED?
		 MOVEI T1,34	;YES - IT'S REALLY A CURSOR-DOWN
		 JRST  .+1]
ENTHL3:
IFE NEWTAB,<
	CAIN	T1,"K"-100	;CONVERT OLD TABLE'S COMMANDS
	JRST	[MOVEI T1,"V"-100
		 JRST  ENTHLO]
	CAIN	T1,"L"-100
	MOVEI	T1,"K"-100
	CAIN	T1,"U"-100
	MOVEI	T1,"L"-100
	CAIN	T1,"N"-100
	MOVEI	T1,"U"-100
	CAIN	T1,"V"-100
	MOVEI	T1,"N"-100
ENTHLO:
>
	MOVE	PT,T1		;SAVE INDEX OF COMMAND
TOPS10<
IFDEC<	MOVE	T1,[2,,5]
	MOVSI	T2,'HLP'>	;LOOK ON DEVICE HLP:
IFTYM<	HRROI	T1,.GTFPN	;Get file PPN
	GETTAB	T1,		; (the directory that this program came from)
	  MOVEI	T1,0
	MOVSI	T2,'DSK'	;Look for file on DSK
>  ;End IFTYM
	MOVEM	T2,GENBLK+1
	MOVEI	T2,HLPFIL
	PUSHJ	P,SETIN1	;SET UP HELP FILE
	MOVSI	T2,'DSK'	;GO BACK TO DISK
	MOVEM	T2,GENBLK+1
	JUMPE	T1,NHPERR	;IF NOT THERE, SCREAM
	USETI	5,1(PT)		;READ BLOCK THAT COMMAND IS IN
	INPUT	5,HLPCCL	;READ IT INTO THE END OF THE PICK BUFFER
	RELEAS	5,		;GET RID OF FILE
	PUSHJ	P,CLRALL	;GO HOME AND CLEAR SCREEN
	PUSHJ	P,PUTTYP	;(NOW)
	OUTSTR	PIKBUF+PCBSIZ-200 ;OUTPUT THE HELP
>
TOPS20<	HRROI	T2,HLPFIL
	PUSHJ	P,SETIN		;SET UP HELP FILE
	JUMPE	T1,NHPERR	;IF NOT THERE, SCREAM
	PUSH	P,T1		;SAVE JFN

	MOVE	T1,PT		;COMVERT COMMAND TO PAGE AND POSITION
	SETZ	T2,
	LSHC	T1,-2
	ROT	T2,2
	MOVE	PT,T2		;SAVE POSITION IN PAGE
	LSH	PT,7

	HRL	T1,(P)		;READ IN THE RIGHT FILE BLOCK
	MOVE	T2,[400000,,377]
	MOVE	T3,[PM%CNT+PM%RD+1]
	PMAP
	PUSHJ	P,CLRALL	;GO HOME AND CLEAR SCREEN
	PUSHJ	P,PUTTYP	;(NOW)
	MOVEI	T1,377000	;OUTPUT THE HELP
	ADD	T1,PT
	PSOUT
	SETO	T1,		;UN-MAP THE BLOCK
	MOVE	T2,[400000,,377]
	MOVE	T3,[PM%CNT+1]
	PMAP

	POP	P,T1		;GET JFN AGAIN
	CLOSF			;CLOSE THE FILE
	  HALTF
>
	PUSHJ	P,CBOTOM
	JRST	ENTHL0		;LOOP TO GET NEW OPTION

ENTHLE:	PUSHJ	P,DISPLL	;RE-DISPLAY THE SCREEN
	JRST	DISCUR		;RE-POSITION AND LOOP

HLPERR:	CAIN	T1,177		;RUBOUT?
	JRST	[SETO T1,	;YES - GIVE HELP AFTER ALL
		 JRST ENTHL2]
	MOVEI	T1,[ASCIZ /##Can only give help for commands/]
	JRST	ERROR		;ELSE FLAKE

NHPERR:	MOVEI	T1,[ASCIZ /########No help file. Sorry./]
	JRST	ERROR
SUBTTL	Roll forward/backward pages

;HERE TO ROLL FORWARD A GIVEN NUMBER OF PAGES (THE EASY WAY)

ROLFWP:	MOVE	T4,ROLPGS	;SET UP LAST TIME'S ROLL AS NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET LINES TO ROLL
	MOVEM	T4,ROLPGS	;SAVE AS NEW NOMINAL
	PUSHJ	P,RESTPM	;ERASE PARAMETER FIRST
RFPNPM:	MOVE	T4,ROLPGS	;SET UP LAST TIME'S ROLL AS NOMINAL
	IMUL	T4,LPP(TM)	;GET NUMBER OF LINES TO ROLL
	MOVEM	T4,ROLLS	;SAVE AS ARG TO ROLFW
	PUSHJ	P,ROLFW		;GO DO THE ROLL
	JRST	LOOP		;THEN GET ANOTHER COMMAND

;HERE TO ROLL BACKWARD A GIVEN NUMBER OF PAGES (ALSO THE EASY WAY)

ROLBKP:	MOVE	T4,ROLPGS	;SET UP LAST TIME'S ROLL AS NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	MOVE	T4,PARG1	;GET LINES TO ROLL
	MOVEM	T4,ROLPGS	;SAVE AS NEW NOMINAL
	PUSHJ	P,RESTPM	;ERASE PARAMETER FIRST
RBKNPM:	MOVE	T4,ROLPGS	;SET UP LAST TIME'S ROLL AS NOMINAL
	IMUL	T4,LPP(TM)	;GET NUMBER OF LINES TO ROLL
	MOVEM	T4,ROLLS	;SAVE AS ARG TO ROLBK
	PUSHJ	P,ROLBK		;GO DO THE WORK
	JRST	INTEND		;AND GET ANOTHER COMMAND

;HERE TO ROLL FORWARD A GIVEN NUMBER OF LINES

ROLFWL:	MOVE	T4,ROLLIN	;SET UP LAST TIME'S ROLL AS NOMINAL
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	JUMPE	T1,[TLO  F,SCN	;SET FLAG IF WANT SCAN MODE
		    JRST RFLNPM-1]
	MOVE	T4,PARG1	;GET LINES TO ROLL
	MOVEM	T4,ROLLIN	;SAVE AS NEW NOMINAL
	PUSHJ	P,ERASPM	;ERASE PARAMETER FIRST
RFLNPM:	MOVE	T4,ROLLIN	;SET UP LAST TIME'S ROLL AS NOMINAL
	MOVEM	T4,ROLLS	;SAVE ALSO AS ARG TO ROLFW
	PUSHJ	P,ROLFW		;GO DO THE ACTUAL ROLLING
	TLNN	F,SCN		;SCANNING?
	JRST	INTEND		;NO - GET ANOTHER COMMAND
	MOVEI	T1,^D1200	;YES - WAIT A BIT
TOPS10<	HIBER	T1,
	  JFCL
>
TOPS20<	DISMS
>
	TLNN	F,FNC		;IS FENCE ON SCREEN?
	JRST	RFLNPM		;NO - CONTINUE (UNTIL USER TYPES SOMETHING)
	TLZ	F,SCN		;YES - TIME TO STOP SCANNING
	MOVEI	RW,^D15		;PUT CURSOR NEAR CENTER OF SCREEN
	MOVEI	CM,^D40
	JRST	RFLNPM		;AND DO THE LAST ONE

;SUBROUTINE TO DO THE ACTUAL ROLLING FORWARD (CALLED BY ROLFWL, ROLFWP)

ROLFW:	JUMPLE	T4,POSCUR	;DONE, IF NO ROLL
	TLO	F,XPB		;SAY BOTTOM POINTER IS INVALID
	PUSHJ	P,ADVDPT	;MOVE DISPLAY POINTER FORWARD
	MOVE	T4,ROLLS	;GET LINES TO ROLL AGAIN
	SUB	RW,T4		;ADJUST CURSOR POSITION
	JUMPL	RW,[TLO   F,XPL!XPC ;LINE AND CHARACTER POINTERS ARE INVALID
		    MOVM  RW,RW
		    SETZB RW,CM	    ;PUT CURSOR AT UPPER LEFT
		    JRST  .+1]
	TLZE	F,FLG		;HIT END OF FILE?
	JRST	ROLFW2-1	;YES - GO REWRITE THE SCREEN
	TLNN	TM,NRU		;NO ROLL UP SEQUENCE,
	CAML	T4,LPP(TM)	;  OR WANT TO ROLL MORE THAN A SCREENFUL?
	JRST	ROLFW2		;YES - GO REWRITE THE SCREEN

	PUSHJ	P,CMVBTM	;MOVE TO BOTTOM LINE
	TLNE	F,FNC!FBL	;IS FENCE THERE?
	PUSHJ	P,CLRLNA	;YES - ERASE IT
	PUSHJ	P,ROLLUP	;DO A ROLL
	SOJG	T4,.-1		;LOOP THROUGH PROPER NUMBER OF LINES

	MOVE	T4,LPP(TM)	;POSITION TO START OF LINES TO REWRITE
	SUB	T4,ROLLS
	MOVEM	T4,SAVEAC	;SAVE POSITION COUNT
ROLFW1:	MOVE	PT,DISPTR
	TLNN	F,FBL		;IS BOTTOM LINE ON SCREEN BAD?
	TLNE	TM,NEL		;..
	SOJ	T4,		;YES - WRITE FROM ONE HIGHER
	PUSHJ	P,ADVLPT	;ELSE GET POINTER TO START OF NEW STUFF
	JUMPL	T4,[PUSHJ P,FNCPUT ;IF BEYOND FILE OUTPUT THE FENCE
		    JRST  POSCUR]  ;POSITION CURSOR AND RETURN
	MOVE	T4,SAVEAC	;RESTORE POSITION COUNT
	TLNN	F,FBL		;IS BOTTOM LINE ON SCREEN BAD?
	TLNE	TM,NEL		;..
	SOJ	T4,		;YES - WRITE FROM ONE HIGHER
	PUSHJ	P,POSLIN	;POSITION CURSOR AT THE LINE
	MOVE	T4,ROLLS	;DISPLAY THE MISSING LINES
	TLNE	F,FBL		;IS BOTTOM LINE ON SCREEN BAD?
	AOJ	T4,		;YES - WRITE ONE MORE LINE
	TLZ	F,FNC!FBL	;FENCE WILL BE RE-DRAWN; BOTTOM LINE IS O.K.
	PUSHJ	P,DISPLY	;REWRITE BOTTOM OF THE SCREEN
	TRNE	F,IMD		;IN INSERT MODE?
	PUSHJ	P,INSMSG	;YES - PUT MESSAGE UP
	JRST	POSCUR		;RE-POSITION THE CURSOR AND RETURN

	ADD	RW,T4		;DE-ADJUST CURSOR POSITION (AT EOF)
ROLFW2:	PUSHJ	P,DISPLL	;RE-DO THE WHOLE SCREEN
	JRST	POSCUR		;RE-POSITION THE CURSOR AND RETURN

;HERE TO ROLL BACKWARD A GIVEN NUMBER OF LINES

ROLBKL:	MOVE	T4,ROLLIN	;SET UP LAST TIME'S ROLL AS NOMINAL
	TLNN	F,ENT		;IS THERE A PARAMETER TYPED?
	JRST	RBLNPM		;NO - USE THE ONE ALREADY SET UP
	MOVEM	T4,PARG1
	PUSHJ	P,PEEL.1	;READ NEW ARG, IF ANY
	JUMPE	T1,[TLO  F,SCN	;SET FLAG IF WANT SCAN MODE
		    MOVE T4,ROLLIN ;GET SIZE OF SCAN
		    JRST RBLNPM-1]
	MOVE	T4,PARG1	;GET LINES TO ROLL
	MOVEM	T4,ROLLIN	;SAVE AS NEW NOMINAL
	PUSHJ	P,RESTPM	;ERASE PARAMETER
RBLNPM:	MOVEM	T4,ROLLS	;SAVE ALSO AS ARG TO ROLBK
	PUSH	P,F		;SAVE FENCE FLAG FOR LATER
	PUSHJ	P,ROLBK		;DO THE ACTUAL WORK
	POP	P,T1		;GET OLD FLAGS BACK
	TLNE	T1,FNC		;DID FENCE USED TO BE ON SCREEN?
	PUSHJ	P,RBLFNC	;YES - SEE IF IT NEEDS TO BE UP NOW
	TLNN	F,SCN		;SCANNING?
	JRST	LOOP		;NO - GET ANOTHER COMMAND
	MOVEI	T1,^D1200	;NO - WAIT A BIT
TOPS10<	HIBER	T1,
	  JFCL
>
TOPS20<	DISMS
>
	MOVE	T4,ROLLIN	;GET SIZE OF ROLL AGAIN
	JRST	RBLNPM		;AND CONTINUE (UNTIL USER TYPES SOMETHING)

RBLFNC:	PUSHJ	P,MAKBPT	;YES - RE-MAKE PTR TO BOTTOM OF SCREEN
	TLZ	F,XPB		;MARK THAT IT'S GOOD
	JUMPN	PT,CPOPJ	;IF NOT BEYOND END OF FILE, O.K.
	PUSHJ	P,FNCPUT
	JRST	POSCUR		;POSITION CURSOR AND RETURN

;SUBROUTINE TO ROLL BACKWARDS (CALLED BY ROLBKL AND ROLBKP)
;IT CAN'T JUST BE A FLOW, SINCE ONE GOES TO LOOP AND THE OTHER DEBRK'S

ROLBK:	JUMPLE	T4,POSCUR	;DONE IF NO ROLL
	TLO	F,XPB		;SAY BOTTOM POINTER IS INVALID
	PUSHJ	P,BAKDPT	;MOVE DISPLAY POINTER BACKWARD (T4) LINES
	JUMPE	T4,ROLBK1	;HIT START OF FILE?
	TLZE	F,SCN		;YES - SCANNING?
	JRST	[MOVEI RW,^D5	;YES - PUT CURSOR NEAR CENTER OF SCREEN
		 MOVEI CM,^D40
		 JRST  .+1]	;AND CONTINUE
	TRZE	F,XCT		;ALSO STOP EXECUTING - WERE WE?
	JRST	XCEERR		;YES - GIVE SPECIAL MESSAGE
ROLBK1:	MOVNS	T4		;SUBTRACT FROM LINES ROLLED
	ADDB	T4,ROLLS	;  (BOTH IN ROLLIN AND IN T4)
	MOVN	T1,T4
	JUMPE	T4,POSCUR	;IF ALREADY AT START OF BUFFER, QUIT
	ADD	RW,T4		;ADJUST CURSOR POSITION
	CAMGE	RW,LPP(TM)	;WILL CURSOR BE OFF THE SCREEN?
	JRST	.+3		;NO - O.K.
	SETZB	RW,CM		;YES - PUT IT AT UPPER LEFT
	TLZ	F,FBL		;BOTTOM LINE IS ALL RIGHT
	TLO	F,XPL!XPC	;LINE AND CHARACTER POINTERS ARE INVALID
	TLNN	TM,NRD		;NO ROLL DOWN SEQUENCE,
	CAML	T4,LPP(TM)	;  OR WANT TO ROLL MORE THAN A SCREENFUL?
	JRST	ROLBK2		;EITHER - JUST REWRITE THE SCREEN

	PUSHJ	P,CHOME		;HOME THE CURSOR
	PUSHJ	P,ROLLDN	;ROLL AND CLEAR A LINE
	SOJG	T4,.-1		;DO THE PHYSICAL ROLL OF THE SCREEN

	MOVE	PT,DISPTR	;POINT TO DESIRED POSITION IN BUFFER
	MOVE	T4,ROLLS	;GET NUMBER OF LINES TO REWRITE
	PUSHJ	P,DISPLY	;REWRITE THEN
	TLZ	F,XPB		;SAY BOTTOM POINTER IS VALID
	PUSHJ	P,MAKBPT	;RE-MAKE POINTER TO BOTTOM OF SCREEN
	JUMPE	PT,POSCUR	;IF FENCE IS UP, LEAVE IT UP
	TLZ	F,FNC		;ELSE TAKE IT DOWN
	TRNE	F,IMD		;IN INSERT MODE?
	PUSHJ	P,INSMSG	;YES - OUTPUT INSERT MESSAGE
	JRST	POSCUR		;RE-POSITION THE CURSOR AND RETURN

ROLBK2:	PUSHJ	P,DISPLL	;RE-DO THE WHOLE SCREEN
	PUSHJ	P,RESTPM	;ERASE PARAMETER
	TLZ	F,FNC		;NO WAY FENCE CAN BE ON SCREEN
	JRST	POSCUR		;POSITION THE CURSOR
SUBTTL	RESET command

;HERE ON RESET (ALIAS RUBOUT) RESETS ENTER MODE, OR RE-WRITES SCREEN

RESET:	MOVE	RW,SAVPOS	;RESTORE SAVED POSITION
	MOVE	CM,SAVPOS+1
	MOVE	T2,PARPTR	;DID USER TYPE JUST ENTER RESET?
	CAME	T2,[POINT 7,PARBUF]
	CAMN	T2,[010700,,PARBUF-1]
	JRST	RESET1		;YES - LEAVE BUFFER ALONE
	SETZ	T1,		;ELSE END PARAMETER BUFFER WITH A NULL
	IDPB	T1,T2
	MOVE	T2,[POINT 7,PARBUF]
	ILDB	T1,T2		;GET 1ST CHARACTER OF ARG
	CAIN	T1,136		;UP-ARROW?
	JRST	[PUSHJ P,RESTPM ;YES - RESET ENTER PARAMETERS
		 PUSHJ P,DISPLL ;RE-DISPLAY THE SCREEN
		 JRST  RESNPM]	;AND GO RE-POSITION THE CURSOR
RESET2:	PUSHJ	P,ERASPM	;ERASE THE PARAMETER
RESNPM:	PUSHJ	P,POSCUR	;AND RE-POSITION THE CURSOR
	JRST	INTEND		;AND GET ANOTHER COMMAND

RESET1:	TRNE	F,CMV		;CURSOR MOVE?
	JRST    RESET2          ;YES - THEN IT'S NOT A TOKEN
	TLZE	F,XPL		;ELSE RE-DO CURRENT LINE
	PUSHJ	P,MAKLPT	;RE-MAKE LINE POINTER, IF NEEDED
	PUSHJ	P,DISONL
	JRST	RESET2		;CONTINUE
SUBTTL	Change switch settings

;HERE FOR THE COMMAND TO SET A NUMBER OF SWITCHES

SWITCH:	MOVE	T1,PARPTR	;DID USER TYPE JUST ENTER SWITCH?
	CAME	T1,[POINT 7,PARBUF]
	CAMN	T1,[010700,,PARBUF-1]
	JRST	SWHSTS		;YES - GIVE HIM SOME STATUS INFORMATION
	PUSHJ	P,ERASPM	;ELSE ERASE ARGUMENT
	SETZ	T1,		;END PARAMETER WITH A NULL
	IDPB	T1,PARPTR
	MOVE	T2,[POINT 7,PARBUF]
	MOVE	T3,T2
	ILDB	T1,T3		;GET FIRST CHARACTER
	CAIN	T1,"/"		;SUPERFLUOUS SLASH?
	MOVE	T2,T3		;YES - SKIP IT
	PUSHJ	P,SWHMNY	;HANDLE THE SWITCH(S) IN THE PARAMETER BUFFER
	JRST	DISCUR		;RE-POSITION CURSOR AND GET NEW COMMAND

;HERE ON SWITCH WITH NO PARAMETER: GIVE FILE STATUS

SWHNPM:	PUSHJ	P,CBOTOM	;MOVE TO BOTTOM LINE AND CLEAR IT
	PUSHJ	P,PUTTYP	;DO THAT MOVE NOW
	PUSHJ	P,PROTON	;TURN PROTECTION ON
	MOVEI	T1,[ASCIZ /File: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,FILSPC
	PUSHJ	P,PUTSTF

	PUSHJ	P,MAKCPT	;MAKE A GOOD CHARACTER POINTER
	MOVE	T2,RW		;SAVE REAL ROW POINTER
	MOVE	PT,[010700,,BUFFER-1]
	PUSHJ	P,FINDRW	;COUNT PAGES AND LINES FROM START OF BUFFER
	EXCH	T2,RW
	EXCH	T2,SAVEAC

	SKIPN	PAGFLG		;WANT BOTH PAGES AND LINES?
	JRST	SWHNP1		;NO - JUST LINES
	MOVEI	T1,[ASCIZ / Page: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,1(T3)	;GET PAGE NUMBER
	PUSHJ	P,PUTNUM	;OUTPUT PAGE
	MOVEI	T1,"-"
	IDPB	T1,TY
	AOS	T1,SAVEAC	;GET LINE NUMBER
	PUSHJ	P,PUTNUM	;OUTPUT IT
	JRST	SWHNP2		;SKIP LINES-ONLY STUFF

SWHNP1:	MOVEI	T1,[ASCIZ / Line: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,1(T2)	;GET LINE NUMBER
	PUSHJ	P,PUTNUM	;OUTPUT IT

SWHNP2:	MOVEI	T1,"("
	IDPB	T1,TY
	HRRZ	T1,LINPTR	;GET OFFET OF PAGE INTO BUFFER
	SUBI	T1,BUFFER-1
	IMULI	T1,^D100	;TIMES 100
	HRRZ	T2,EN		;DIVIDED BY SIZE OF FILE
	SUBI	T2,BUFFER
	IDIV	T1,T2
	PUSHJ	P,PUTNUM	;OUTPUT PERCENT THROUGH FILE

	MOVEI	T1,[ASCIZ /%) Pos: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,1(CM)	;OUTPUT COLUMN + SLIDE + 1
	ADD	T1,SL
	PUSHJ	P,PUTNUM
	SKIPN	OLDSPC		;GOT AN ALTERNATE FILE?
	JRST	SWHNPE		;NO - DON'T TALK ABOUT IT
	MOVEI	T1,[ASCIZ / Alt: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,OLDSPC
	PUSHJ	P,PUTSTF
SWHNPE:	MOVEI	T1," "
	IDPB	T1,TY
	IDPB	T1,TY
	PUSHJ	P,PROTOF	;TURN PROTECTION OFF
	TLO	F,FBL		;SAY BOTTOM LINE HAS BEEN FRAGGED
	JRST	DISCUR		;RE-POSITION CURSOR AND RETURN

;HERE ON ENTER SWITCH WITH NO PARAMETER: GIVE NOMINAL SETTINGS

SWHSTS:	PUSHJ	P,RESTPM	;CLEAN UP THE PARAMETER ENTRY
	PUSHJ	P,CBOTOM	;MOVE TO BOTTOM LINE AND CLEAR IT
	PUSHJ	P,PROTON	;TURN PROTECTION ON
	MOVEI	T1,[ASCIZ / RL: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,ROLLIN	;OUTPUT NUMBER OF LINES TO ROLL
	PUSHJ	P,PUTNUM
	MOVEI	T1,[ASCIZ /, RP: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,ROLPGS	;OUTPUT NUMBER OF PAGES TO ROLL
	PUSHJ	P,PUTNUM
	MOVEI	T1,[ASCIZ /, PC: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,GOPERC	;OUTPUT PERCENT-GOTO NOMINAL
	PUSHJ	P,PUTNUM
	MOVEI	T1,[ASCIZ /, SL: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,SLIDES	;OUTPUT SIZE OF SLIDE
	PUSHJ	P,PUTNUM
	MOVEI	T1,[ASCIZ /, IL: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,ADDLNS	;OUTPUT NUMBER OF LINES TO INSERT/DELETE
	PUSHJ	P,PUTNUM
	SKIPN	T1,ADDLSP	;GOT SPACES TO GO WITH THOSE LINES?
	JRST	SWHST1		;NO - SKIP OUTPUT
	MOVEI	T1,","
	IDPB	T1,TY
	MOVE	T1,ADDLSP	;AND SPACES TO GO WITH THOSE LINES
	PUSHJ	P,PUTNUM
SWHST1:	MOVEI	T1,[ASCIZ /, IS: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,ADDSPC	;OUTPUT NUMBER OF SPACES TO INSERT/DELETE
	PUSHJ	P,PUTNUM
	MOVEI	T1,[ASCIZ /, PK: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,PICKLN	;OUTPUT NUMBER OF LINES TO PICK
	PUSHJ	P,PUTNUM
	SKIPN	T1,PICKSP	;GOT SPACES TO GO WITH THOSE LINES?
	JRST	SWHST2		;NO - SKIP OUTPUT
	MOVEI	T1,","
	IDPB	T1,TY
	MOVE	T1,PICKSP	;AND SPACES TO PICK, TOO
	PUSHJ	P,PUTNUM
SWHST2:	MOVEI	T1,[ASCIZ /, TB: /]
	PUSHJ	P,PUTSTG	;OUTPUT SIZE OF TAB
	TRNE	F,WTB		;GOT WORD-WISE TABS?
	JRST	[MOVEI T1,"W"	;YES - CALL THEM SIZE "W"
		 IDPB  T1,TY
		 JRST  SWHST3]
	MOVE	T1,TABLEN	;NO - OUTPUT SIZE OF TAB
	PUSHJ	P,PUTNUM
SWHST3:	SKIPN	SRCKEY		;GOT A SEARCH KEY?
	JRST	SWHNPE		;NO
	MOVEI	T1,[ASCIZ /; Key: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,SRCKEY
	PUSHJ	P,PUTSTC
	JRST	SWHNPE		;FINISH OFF
SUBTTL	RECALL command

;HERE TO DO A RECALL COMMAND -
;GIVES BACK PREVIOUS ARGUMENT FOR EDITING AND REUSING

RECALL:	TLO	F,ENT!FLG	;PRETEND ENTER WAS TYPED
	MOVE	T1,PARPTR
	CAMN	T1,[POINT 7,PARBUF]
	PUSHJ	P,RECAL1	;FUDGE, IF POINTER HAS BEEN RESET
	PUSHJ	P,ENTER0	;SET UP LIKE AN ENTER
	MOVE	T1,PARPTR	;GET RID OF NULL AT END OF PARAMETER BUFFER
	ADD	T1,[70000,,0]	;FUDGE A DECREMENT OF THE PARM POINTER
	JUMPGE	T1,.+2
	SUB	T1,[430000,,1]
	MOVEM	T1,PARPTR
	MOVEI	T1,PARBUF	;OUTPUT CURRENT PARAMETER
	PUSHJ	P,PUTSTS
	PUSHJ	P,PUTTYP	;TYPE IT ALL OUT NOW
	JRST	LOOP		;LET USER EDIT IT

RECAL1:	ILDB	T2,T1		;IF BUFFER NOT EMPTY SET UP LATEST PARAMETER
	JUMPN	T2,.-1		;  BY POINTING TO FIRST NULL
	MOVEM	T1,PARPTR
	POPJ	P,
SUBTTL	REAL TAB, MARK, and COUNTER

;HERE TO INSERT A REAL TAB IN THE FILE - SAME AS IF USER TYPED E-C-C I

REALTB:	MOVEI	T1,"I"		;GET AN I
	TLO	F,CCH		;MAKE IT BE A CONTROL CHARACTER
	MOVEI	T2,"O"-100
	TRNE	F,XSV		;SAVING IN EXECUTE BUFFER?
	DPB	T2,XCTPTW	;YES - MAKE REAL TAB LOOK LIKE E-C-C
	JRST	ALPNUM		;EITHER WAY, TREAT IT LIKE E-C-C I

;**********************************************************************
;HERE TO MARK POSITION FOR PICK OR CLOSE-LINES. THE NEXT SUCH COMMAND
;WILL TAKE TEXT FROM THE MARK TO THE CURSOR POSITION.

MARK:	MOVE	T1,DISPTR
	MOVEM	T1,MRKPTR	;SAVE CURRENT DISPLAY POINTER
	TLO	F,PCM		;SET MARK FLAG
	MOVEM	RW,SVPMRK	;SAVE STARTING POSITION
	MOVEM	CM,SVPMRK+1
	PUSHJ	P,MRKCUR	;MARK THE CURSOR POSITION
	PUSHJ	P,POSCUR	;RE-POSITION AND OUTPUT
	JRST	LOOP		;THAT'S ALL

;**********************************************************************
;HERE TO WORK WITH THE INCREMENTING COUNTER
;NO PARAMETER: RESET COUNTER; PARAMETER: INCLUDE COUNTER IN PARM

CNTNPM:	SETZM	COUNTS		;RESET COUNTER
	JRST	LOOP		;THAT'S ALL

COUNTR:	MOVEI	T1,177		;SAVE COUNTER FLAG IN BUFFER
	IDPB	T1,PARPTR
	IDPB	T1,PARPTR
	PUSHJ	P,PUTCNT	;NO - OUTPUT COUNTER FLAG
	JRST	LOOP		;YES - NO OUTPUT

PUTCNT:	MOVEI	T1,"#"		;OUTPUT COUNTER FLAG
	IDPB	T1,TY
	JRST	PUTTYP
SUBTTL	Utility subroutines

;**********************************************************************
;			UTILITY SUBROUTINES
;**********************************************************************
;THE ROUTINES BELOW DEAL WITH DISPLAYING PART OF THE BUFFER ON THE SCREEN

;HERE TO DISPLAY FROM THE LINE THE CURSOR IS ON TO THE BOTTOM,
;POSITION THE CURSOR WHERE IT BELONGS, AND GO GET A NEW COMMAND

DISDWN:	TRNE	F,XCT		;DOING AN EXECUTE?
	JRST	DISCUR		;YES - NO DISPLAY
	MOVE	T4,RW		;MOVE CURSOR TO START OF LINE
	PUSHJ	P,POSLIN
	SETZ	T0,		;DO THE CLEAR FROM THE START OF THE LINE
	PUSHJ	P,CLEARP	;CLEAR TO END OF PAGE
	MOVE	PT,LINPTR
	MOVE	T4,LPP(TM)
	SUB	T4,RW
	TLZ	F,FNC!FBL	;FENCE WILL BE RE-DRAWN; BOTTOM LINE O.K.
	PUSHJ	P,DISPLY	;RE-DISPLAY ALL LINES AFTER CURSOR POSITION
	TRNE	F,IMD		;IN INSERT MODE?
	PUSHJ	P,INSMSG	;YES - PUT UP INSERT MESSAGE
DISCUR:	PUSHJ	P,POSCUR	;RE-POSITION THE CURSOR AND RETURN
	JRST	INTEND		;AND GET ANOTHER COMMAND

;SUBROUTINE TO DISPLAY A SCREENFUL OF DATA, STARTING FROM DISPTR
;T1-T4 AND PT ARE FRAGGED

DISPLL:	TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	PUSHJ	P,CLRALL	;GO HOME AND CLEAR THE SCREEN
	MOVE	PT,DISPTR	;GET POINTER TO START OF DISPLAY
	MOVE	T4,LPP(TM)	;GO DISPLAY ENTIRE SCREEN
	PUSHJ	P,DISPS0
	MOVE	T1,DISPPT	;GET POINTER TO LAST LINE
	MOVEM	T1,BOTPTR	;SAVE AS BOTTOM POINTER
	TLNN	F,FNC		;IS THE FENCE ON THE SCREEN?
	TLZA	F,XPB		;NO - MARK BOTTOM POINTER AS GOOD
	TLO	F,XPB		;YES - BOTTOM POINTER IS BAD
	TLZ	F,FBL		;BUT BOTTON LINE ITSELF IS O.K.
	TRNE	F,IMD		;IN INSERT MODE?
	JRST	INSMSG		;YES - PUT INSERT MESSAGE UP
	POPJ	P,		;NO - DONE

;SUBROUTINE TO DISPLAY ONE LINE, FROM CURSOR POSITION TO END
;CURSOR DOES NOT HAVE TO BE POSITIONED; CHRPTR MUST BE RIGHT

DISLIN:	TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	PUSHJ	P,POSCUR	;MOVE CURSOR TO ITS RIGHTFUL POSITION
	PUSHJ	P,CLRLNR	;CLEAR OUT REST OF PRESENT LINE
	MOVE	PT,CHRPTR	;SET TO WRITE ONE LINE WHERE CURSOR IS
	MOVEI	T4,1		;SAY ONE LINE WILL BE DISPLAYED

	MOVN	T2,CPL(TM)	;GET IOWD FOR CHARACTER COUNT:
	ADD	T2,CM		;  COUNT: CHARS REMAINING IN LINE
	TLNE	TM,WRP		;  WILL LINES WRAP AROUND?
	SOJ	T2,		;  YES - DO ONE MORE CHARACTER
	HRLI	T2,-1(T2)
	HRR	T2,SL		;  OFFSET: SLIDE + CHARS NOT REMAINING
	ADD	T2,CM
	JRST	DISPL0		;DISPLAY FROM CURSOR TO END OF LINE

;HERE TO DISPLAY ONE ENTIRE LINE
;IF CURSOR IS ALREADY POSITIONED ENTER AT DISONE

DISONL:	TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	MOVE	T4,RW
	PUSHJ	P,POSLIN	;MOVE CURSOR TO START OF LINE
	MOVE	PT,LINPTR
DISONE:	PUSHJ	P,CLRLNA	;CLEAR THE LINE
	MOVEI	T4,1		;DISPLAY ONE ENTIRE LINE

;SUBROUTINE TO DISPLAY (T4) LINES STARTING AT WHERE PT POINTS IN BUFFER
;CURSOR IS ASSUMED TO BE AT THE RIGHT POSITION
;T1-T4 AND PT ARE FRAGGED

DISPLY:	TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	TLZA	F,LFF
DISPS0:	TLZ	F,FNC!LFF
	PUSHJ	P,DISSLD	;SKIP OVER, IF THERE'S A SLIDE
DISPL0:	MOVEI	T3,TYPBUF+TYPSIZ+1 ;SET UP END-OF-TYPE-BUFFER ADDRESS

;NOW COPY LINE INTO DISPLAY BUFFER

DISPL1:	CAMN	PT,EN		;AT END OF BUFFER?
	JRST	DISPEN		;YES - DISPLAY THE REST, THEN DONE
	ILDB	T1,PT		;GET A CHARACTER FROM THE FILE BUFFER
	JUMPE	T1,DISPL1	;IGNORE A NULL
	AOBJP	T2,DISSKP	;JUMP IF LINE HAS FILLED SCREEN
	TLZE	F,LFF		;LOOKING FOR A LINEFEED?
	JRST	DISPLF		;YES - SEE IF THIS IS ONE
DISPL2:	CAIE	T1,177		;[JMS] Rubout?
	CAIGE	T1," "		;SOME KIND OF CONTROL CHARACTER?
	JRST	DISCTL		;YES - HANDLE IT SEPARATELY
DISPL3:	IDPB	T1,TY		;STORE CHARACTER IN TYPE BUFFER

DISPL4:	CAIGE	T3,(TY)		;IS BUFFER FILLED?
	PUSHJ	P,PUTTYP	;YES - FINISH BUFFER AND OUTPUT IT
	JRST	DISPL1		;EITHER WAY, GET SOME MORE
;HERE IF A FULL LINE OF CHARACTERS HAS BEEN FOUND; IGNORE REST OF LINE

DISSKP:	CAIN	T1,12		;IS LAST CHARACTER A <LF>?
	JRST	[TLZ  F,LFF	;YES - CLEAR LINEFEED FLAG
		 JRST DISPLF]	;AND END LINE
	CAIE	T1,15		;USE THIS CHAR IF IT'S A <CR>
DISKP1:	ILDB	T1,PT		;IGNORE REST OF LINE
	CAIE	T1,15		;END OF LINE?
	JRST	DISKP1		;NO - IGNORE ANOTHER CHARACTER
	ILDB	T1,PT		;FOUND <CR> - GET <LF>
	CAIE	T1,12		;IS IT REALLY?
	JRST	DISKP1+1	;OF COURSE NOT - KEEP IGNORING
	TLNN	TM,WRP		;NEED A CARRIAGE RETURN AT END OF LONG LINE?
	JRST	DISPF1		;YES - FINISH LINE WITH CR
	SOJG	T4,DISPF2	;NO - WORKING ON LAST LINE?

;need to know if this is last line on screen or just last of display

	SETZ	T1,		;YES - OVERWRITE LAST CHAR WITH A NULL
	DPB	T1,TY
	JRST	PUTTYP		;FINISH THE DISPLAY AND RETURN

;HERE IF CHARACTER IS A CONTROL CHARACTER
;IF NOT <CR>, <LF>, OR <TB>, DISPLAY AS REVERSED-ASCII CHARACTER

DISCTL:	CAIN	T1,15		;JUST A <CR>?
	JRST	[TLO  F,LFF	;MAYBE - SET FLAG TO LOOK FOR <LF>
		 JRST DISPL4]	;AND CHECK NO FURTHER
	CAIN	T1,11		;TAB?
	JRST	DISTAB		;YES - TREAT SPECIALLY
	CAIN	T1,177		;[JMS] Rubout?
	 MOVEI	T1,"?"-100	;[JMS] Yes, display reversed "?"
	PUSHJ	P,DISREV	;ELSE OUTPUT REVERSED CHARACTER
	JRST	DISPL4

;HERE TO HANDLE A TAB - DE-BUMP POSITION BY SIZE OF TAB
;IF SLIDE IS A MULTIPLE OF 8, WORK WITH TAB; ELSE CONVERT TO SPACES

DISTAB:	TRNN	SL,7		;IS SLIDE A MULTIPLE OF 8?
	TLNN	TM,TBS		;  OR GOT HARDWARE TABS?
	JRST	DISTBX		;NEITHER - SIMULATE WITH SPACES
	TRNE	F,DTB		;WANT TO DISPLAY TABS?
	JRST	DISTBA
  ;Adjust position, output a hardware tab
DISTB0:	TRNE	T2,7		;MOVE OVER TO TAB BOUNDARY
	AOBJN	T2,.-1
	JRST	DISPL3		;SAVE TAB IN DISPLAY BUFFER

  ;Output inverse video "I" then send a hardware tab
DISTBA:	PUSHJ	P,DISREV	;OUTPUT A REVERSED "I"
	TRNN	T2,7		;IS TAB REALLY ONLY ONE SPACE LONG?
	JRST	DISPL4		;YES - DON'T OUTPUT THE TAB
	MOVEI	T1,11		;ELSE - GET THE TAB BACK AGAIN
	JRST	DISTB0	        ;AND OUTPUT IT

  ;Here when hardware tabs cannot be used
DISTBX:	TRNE	F,DTB		;WANT TO DISPLAY TABS?
	JRST	DISTBB
  ;Output up to 8 spaces
DISTX1:	MOVEI	T1," "		;SIMULATE TAB: GET A SPACE
	IDPB	T1,TY
	TRNE	T2,7		;SAVE UNTIL AT TAB BOUNDARY
	AOBJN	T2,.-2
	JRST	DISPL4

  ;Outut inverse video "I" then up to 7 spaces
DISTBB:	PUSHJ	P,DISREV	;OUTPUT A REVERSED "I"
	TRNN	T2,7		;AT TAB BOUNDARY?
	JRST	DISPL4		;YES - CONTINUE
	AOBJN	T2,DISTX1	;NO - OUTPUT SOME SPACES, TOO
	JRST	DISTX1
;SUBROUTINE TO OUTPUT THE CHARACTER IN T1 AS HIGHLIGHTED ASCII

DISREV:	PUSH	P,T1		;OUTPUT REVERSED CHARACTER
	PUSHJ	P,PROTON
	POP	P,T1		;RESTORE REVERSABLE CHARACTER
	ADDI	T1,"A"-1	;MAKE IT A CHARACTER
	IDPB	T1,TY
	PUSHJ	P,PROTOF
	CAIGE	T3,(TY)		;IS BUFFER FILLED?
	JRST	PUTTYP		;YES - FINISH BUFFER AND OUTPUT IT
	POPJ	P,		;NO - JUST RETURN

;HERE IF EOF REACHED BEFORE E.O. SCREEN. OUTPUT FENCE; DONE

DISPEN:	IDPB	T1,TY		;SAVE LATEST CHARACTER
	PUSHJ	P,PUTTYP	;FINISH BUFFER AND OUTPUT IT
	HRRZ	T0,T2		;GET POSITION TO CLEAR FROM
	JRST	FNCCLR		;DISPLAY FENCE AND RETURN

;HERE IF EXPECTING A <LF> AFTER A <CR>. IF GOT ONE, COUNT AN END OF LINE

DISPLF:	CAIE	T1,12		;IS THIS CHARACTER A <LF>?
	JRST	DISPCR		;NO - REVERSE THE <CR> AND CONTINUE
DISPF1:	MOVEI	T1,15		;ELSE SAVE THE OLD <CR>
	IDPB	T1,TY
	SOJLE	T4,[PUSHJ P,PUTTYP
		    TLNE  F,SCN	 ;SCANNING?
		    JRST  DISTST ;YES - SEE IF USER WANTS TO STOP
		    POPJ  P,]
	PUSHJ	P,CDOWN		;ELSE MOVE TO NEXT LINE DOWN

DISPF2:	PUSHJ	P,DISTST	;YES - INTERRUPT DISPLAY IF IT'S A COMMAND
	PUSHJ	P,DISSLD	;SKIP OVER, IF THERE'S A SLIDE
	MOVEM	PT,DISPPT	;SAVE POINTER TO THE START OF THIS LINE
	JRST	DISPL4		;AND CONTINUE

;HERE IF CHARACTER FOLLOWING <CR> IS NOT <LF> - MAKE <CR> REVERSED CTRL-M

DISPCR:	PUSH	P,T1		;SAVE CURRENT CHARACTER
	MOVEI	T1,15		;SET TO OUTPUT A REVERSED <CR>
	PUSHJ	P,DISREV
	POP	P,T1		;RESTORE CURRENT CHARACTER
	JRST	DISPL2

;HERE IF USER TYPED A CHARACTER DURING THE DISPLAY - STOP IT IF
;ENTER OR COMMAND, ELSE DRIVE ON

DISTST:
TOPS10<	SKPINC		;SEE IF USER TYPED ANYTHING
	     POPJ  P,	>	;NO - CONTINUE
TOPS20<	MOVE   T1,[.PRIIN]
	    SIBE	>	;SKIP IF NO INPUT
DISCHR:	     TROE  F,CWT	;SAY CHARACTER HAS BEEN READ - HAS ONE?
	      POPJ P,		;YES - JUST HAVE TO FORGET THIS ONE, THEN
	PUSH	P,T1		;NO - SAVE STATE
TOPS10<	INCHRW T1>		;GET CHARACTER FROM TERMINAL
TOPS20<	PBIN>		;GET CHARACTER FROM TERMINAL
	TLZE	F,SCN		;SCANNING?
	JRST	[TRZ   F,CWT	;YES - NO WAITING COMMAND
		 MOVEI RW,^D12	;PUT CURSOR NEAR CENTER OF SCREEN
		 MOVEI CM,^D40
		 POP   P,T1	;RESTORE T1
		 POPJ  P,]	;AND QUIT
	MOVEM	T1,TYPCHR	;SAVE CHARACTER FOR LATER
	CAIL	T1,34		;CONTROL CHARACTER (BUT NOT CURSOR MOVE)?
	JRST	[POP  P,T1	;NO - JUST CONTINUE WITH THE DISPLAY
		 POPJ P,]
	MOVE	P,[IOWD 20,STACK] ;YES - CLEAN UP THE STACK
	JRST	INTEND		;GET ANOTHER COMMAND

;SUBROUTINE TO SKIP OVER A SLIDE'S WORTH OF SPACES

DISSLD:	JUMPE	SL,DISSLE	;IF NO SLIDE, JUST SET UP SIZE
	MOVN	T2,SL		;ELSE SKIP THAT MANY REAL CHARACTERS
	HRLZ	T2,T2		;  GET AN IOWD FOR SLIDE SKIPPING
DISSL1:	ILDB	T1,PT		;GET A CHARACTER FROM THE FILE BUFFER
	CAMN	PT,EN		;AT END OF BUFFER?
	JRST	[POP  P,	;YES - KILL CALL TO DISSLD
		 JRST DISPEN+1] ;DISPLAY THE REST, THEN DONE
	JUMPE	T1,DISSL1	;IGNORE A NULL
	CAIN	T1,15		;IF <CR>, SEE IF END OF LINE
	JRST	[MOVE  T1,PT	;GET FRAGGABLE POINTER
		 ILDB  T1,T1	;GET LINEFEED
		 CAIE  T1,12	;IS IT REALLY?
		 JRST  .+1	;NO - SKIP THE <CR>
		 IBP   PT	;YES - SKIP <CRLF>
		 POP   P,	;KILL CALL TO DISSLD
		 JRST  DISPLF]	;AND END THE LINE
	CAIN	T1,11		;TAB?
	JRST	DISSLT		;YES - COUNT IT
	AOBJN	T2,DISSL1	;GO UNTIL SKIPPED OUT
DISSLE:	MOVN	T2,CPL(TM)	;GET IOWD FOR CHARACTER COUNT
	HRLI	T2,-1(T2)
	HRR	T2,SL
	POPJ	P,		;THEN RETURN

DISSLT:	HRRZ	T1,T2		;HERE IF TAB - FIND ITS SIZE
	ANDI	T1,7
	SUBI	T1,10
	AOBJP	T2,DISLFP	;COUNT A SPACE; JUMP IF END OF SLIDE
	AOJL	T1,.-1		;LOOP THROUGH TAB
	JRST	DISSL1		;GET ANOTHER CHARACTER

DISLFP:	AOJE	T1,DISSLE	;IF EXACTLY COUNTED OUT, PUT NOTHING IN
	HRLZ	T1,T1		;GET IOWD FOR SPACES ADDED
	MOVEI	T2," "		;SLIDE ENDS IN MIDDLE OF TAB - PUT IN SPACES
	IDPB	T2,TY		;STORE CHARACTER IN TYPE BUFFER
	AOBJN	T1,.-1		;PUT IN ALL EXTRA SPACES
	HRLZ	T2,T1		;SET UP LENGTH OF REMAINDER OF LINE
	HRLZ	T0,CPL(TM)
	ADD	T0,[1,,0]
	SUB	T2,T0
	POPJ	P,		;THEN DONE

;************************************************************************
;SUBROUTINE TO INITIALIZE CURSOR MOVEMENT PARAMETERS
;PUT CURSOR BACK INTO TEXT AND MARK STARTING POSITION

MARKUP:	TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY, THEN
	PUSH	P,T1		;SAVE CHARACTER TYPED BY USER
	MOVE	T1,[POINT 7,PARBUF]
	CAME	T1,PARPTR	;POINTING TO START OF PARAMETER BUFFER?
	JRST	[POP  P,T1	;NO - DON'T WANT TO ALLOW CURSOR MOVE
		 POP  P,
		 TRZ  F,CMV
		 JRST INTEND]
	DMOVE	RW,SAVPOS	;RESTORE SAVED POSITION
	PUSHJ	P,CBOTOM	;GO TO BOTTOM AND CLEAR LINE
	PUSHJ	P,PROTON
	MOVEI	T1,[BYTE (7) 076," ","*","*","*"
		    ASCIZ / Arg defined by cursor movement ***/]
	PUSHJ	P,PUTSTG
	PUSHJ	P,PROTOF
	PUSHJ	P,POSCUR	;RE-POSITION THE CURSOR
	POP	P,T1		;RESTORE USER'S CHARACTER
	POPJ	P,

;************************************************************************
;SUBROUTINE TO SQUEEZE ENTIRE NULL WORDS OUT OF THE BUFFER
;CALLED DURING EDITING, TO TAKE CARE OF MASSIVE DELETIONS

SQUEZW:	MOVEI	T0,SQZVAL	;RESET NUMBER OF COMMANDS TO LET GO BY
	MOVEM	T0,SQZCNT
	TRNE	F,RDO		;IS FILE READ-ONLY?
	POPJ	P,		;YES - DO NOTHING
	PUSH	P,T1		;SAVE CURRENT COMMAND

	SKIPN	(EN)		;IS END PTR POINTING TO A NULL WORD
	SOJA	EN,.-1		;YES - BACK UP OVER IT
	HRLI	EN,010700	;NO - POINT TO LAST BYTE OF NON-0 WORD
	LDB	T1,EN		;GET THAT BYTE
	JUMPE	T1,.+2		;IF NULL, O.K.
	IBP	EN		;ELSE SKIP TO NEXT BYTE (WHICH IS ZERO)

	MOVEI	T3,BUFFER	;GET TWO BUFFER POINTERS
	MOVE	T4,T3
	HRRZ	T2,DISPTR	;SET UP ADDRESS FROM DISPLAY PTR
	CAIN	T2,BUFFER-1
	HRR	T2,EN		;YES - SET UP END POINTER INSTEAD

SQUEW1:	CAMN	T3,T2		;REACHED DISPLAY OR END POINTER?
	JRST	SQUEW2		;YES - DO SOMETHING
	SKIPN	T1,(T3)		;GET A WORD - NULL?
	AOJA	T3,SQUEW1	;YES - SKIP OVER IT
	AOJ	T3,		;NO - SAVE IT OFF
	MOVEM	T1,(T4)
	AOJA	T4,SQUEW1	;AND GET ANOTHER ONE

SQUEW2:	CAIE	T2,(EN)		;FOUND DISPLAY POINTER?
	JRST	[HRRM T4,DISPTR ;YES - SAVE ITS NEW ADDRESS
		 HRR  T2,EN
		 JRST SQUEW1]	;AND CONTINUE
	MOVE	T1,(EN)		;NO - SAVE LAST WORD OF BUFFER
	MOVEM	T1,(T4)
	HRR	EN,T4		;POINT TO SQUEEZED-OUT END OF BUFFER
TOPS10<	MOVEI	T1,2(EN)	;CLEAR FROM END OF FILE TO TOP OF CORE
	HRLI	T1,-1(T1)
	MOVE	T2,.JBREL
	SETZM	1(EN)
	BLT	T1,(T2)
>
	TLO	F,XPB!XPL!XPC	;POINTERS ARE NO LONGER VALID
	POP	P,T1		;RESTORE CURRENT COMMAND
	POPJ	P,		;DONE

;SUBROUTINE CALLED ON EXIT TO REMOVE ALL NULLS AND TRAILING SPACES FROM FILE

TRAILL:	MOVE	T4,[POINT 7,BUFFER]
	MOVE	PT,T4		;SET UP SOURCE AND TARGET POINTERS
	MOVE	T3,DISPTR	;GET DISPLAY POINTER
	PUSH	P,DO		;SAVE UNFRAGGABLE AC
	SETZ	DO,
	MOVEI	T2," "
	ILDB	T1,EN		;MAKE SURE LAST CHARACTER IS A NULL
	JUMPE	T1,TRAIL1	;IF SO, O.K.
	DPB	T2,EN		;ELSE MAKE IT ONE

TRAIL1:	CAMN	T4,T3		;REACHED DISPTR?
	MOVEM	PT,DISPTR	;YES - SAVE ADJUSTED POINTER
	ILDB	T1,T4		;GET A CHARACTER
	CAIG	T1," "		;IS IT A CONTROL CHAR OR A SPACE?
	JRST	TRAILX		;YES - CHECK DEEPER
TRAIL2:	JUMPE	DO,TRAIL3	;JUMP IF NO SPACES TO PUT IN
	IDPB	T2,PT		;ELSE PUT THEM IN
	SOJG	DO,.-1
TRAIL3:	IDPB	T1,PT		;SAVE CHARACTER
	JRST	TRAIL1		;AND GET ANOTHER

TRAILX:	JUMPE	T1,[CAME T4,EN	;IF NULL, AT END OF BUFFER?
		    JRST TRAIL1 ;NO - IGNORE THE NULL
		    MOVE EN,PT	;YES - SAVE ADJUSTED END POINTER
		    IDPB T1,EN	;MAKE SURE IT ENDS ON A NULL
		    IDPB T1,EN
		    POP  P,DO
		    POPJ P,]
	CAIN	T1,15		;IS CHARACTER A CR?
	JRST	TRAILC		;YES - HANDLE IT
	CAIN	T1," "		;IS IT A SPACE?
	AOJA	DO,TRAIL1	;YES - COUNT IT AND LOOP
	JRST	TRAIL2		;NO - SAVE THE CHARACTER

TRAILC:	MOVE	T0,T4		;GET CHARACTER AFTER CR
	ILDB	T0,T0
	CAIE	T0,12		;IS IT A LINEFEED?
	JRST	TRAIL2		;NO - GO SAVE CR
	SETZ	DO,		;YES - FORGET THE TRAILING SPACES
	JRST	TRAIL3		;AND SAVE THE CRLF

;************************************************************************
;SUBROUTINE TO SAVE THE CURRENT FILE
;TOPS10: ENTER WITH ADDRESS OF FILBLK OR OLDBLK SET UP IN AC PT
;BOTH:	 ENTER WITH ADDRESS OF FILSPC OR OLDSPC SET UP IN AC T4

SAVFIL:	TLZN	F,CHG		;HAS FILE BEEN MODIFIED?
	JRST	SAVFNO		;NO - DON'T SAVE IT, THEN
	PUSHJ	P,SAVMGS	;YES - OUTPUT FILE-MODIFIED MESSAGE
	MOVEM	PT,SAVEAC+1	;SAVE POINTER TO TOPS10 FILE DATA
	PUSHJ	P,TRAILL	;CHOP OUT TRAILING SPACES AND NULLS
	MOVE	PT,SAVEAC+1	;RESTORE TOPS10 POINTER

	SETZ	T1,		;MAKE SURE THE REST OF LAST WORD IS NULL
	MOVEI	T2,5
	IDPB	T1,EN
	SOJG	T2,.-1

	SETZM	(EN)
	MOVEI	T1,1(EN)	;THEN NULL OUT FROM END OF FILE
	HRL	T1,EN
TOPS10<	HRRZ	T2,.JBREL	;TO END OF CORE
	BLT	T1,(T2)

	OPEN	2,(PT)		;SET UP CHANNEL FOR THE EXISTING FILE
	  HALT	.
	DMOVE	T0,5(PT)	;GET FILE NAME AND EXTENSION
	SETZ	T2,
	MOVE	T3,4(PT)	;GET FILE PPN
	SKIPN	BAKFLG		;WANT A BACKUP FILE?
	JRST	SAVFLB		;NO
	MOVSI	T1,'BAK'	;YES - SET UP A BACKUP FLAVORED FILE
	DMOVEM	T0,BAKFIL	;SAVE BACKUP NAME AND EXT
	MOVEM	T3,BAKFIL+3	;SAVE BACKUP PPN
	OPEN	5,(PT)		;ELIMINATE CURRENT BACKUP FILE (IF ANY)
	  HALT	.
	LOOKUP	5,BAKFIL
	  CAIA			;(DON'T DO IT IF IT'S NOT THERE)
	RENAME	5,DELFIL
	  JFCL
	RELEAS	5,
	DMOVEM	T0,BAKFIL	;GET A CLEAN LOOKUP BLOCK
	DMOVEM	T2,BAKFIL+2
	LOOKUP	2,3(PT)		;RENAME THE OLD FILE TO *.BAK
	  CAIA			;IF NONE, DON'T WORRY ABOUT IT
	RENAME	2,BAKFIL
	  JFCL
	CLOSE	2,
	HLL	T1,6(PT)	;GET REAL FILE'S EXTENSION
	HLLZ	T2,7(PT)	;  AND ITS PROTECTION
	TLZ	T2,000777
	DMOVEM	T0,5(PT)	;SET UP EXT AND PROTECTION IN FILE BLOCK
	MOVEM	T2,7(PT)	;SAVE FILE PROTECTION
	MOVEM	T3,4(PT)	;  AND PPN

SAVFLB:	ENTER	2,3(PT)		;FIND THE FILE AGAIN (FOR OUTPUT)
	  HALT	.		;  (IT BETTER WORK)
	MOVE	T1,EN
	SUBI	T1,BUFFER
	MOVN	T1,T1
	HRLM	T1,FILCCL	;SET UP FILE SIZE IN COMMAND
	OUTPUT	2,FILCCL	;OUTPUT THE ENTIRE FILE
;[CSM] Make it ASCII mode instead of BINARY
	MOVSI	T1,000740	;RB.MOD - mask for mode
	ANDCAM	T1,7(PT)	;Set to ASCII mode (instead of binary DUMP)
	RENAME	2,3(PT)		;RENAME closes the file
	  JFCL
	RELEAS	2,		;CLOSE THE FILE UP
>
TOPS20<	HRRZ	T2,EN		;TO END OF PAGE
	TRZ	T2,777
	ADDI	T2,1000
	BLT	T1,(T2)
	HRRZ	T1,EN		;FIND FINAL FILE SIZE
	SUBI	T1,BUFSTT
	MOVE	T3,T1		;FIND IT IN BYTES
	ADDI	T3,777		;ROUND TO NEXT HIGHER PAGE
	LSH	T3,-11
	MOVEM	T3,FILBSZ

	SOJ	T1,		;FIND IT IN CHARACTERS
	IMULI	T1,5
	HLRZ	T0,EN		;GET POINTER PART OF POINTER
	SETZ	T2,		;FIND NUMBER OF CHARACTERS IN FINAL WORD
	CAME	T0,PTRTBL(T2)
	AOJA	T2,.-1
	ADD	T1,T2
	MOVEM	T1,FILSIZ

	MOVE	T1,[400000,,BUFBLK]
	HRLZ	T2,INJFN	;WRITE ALL OF BUFFER INTO FILE
	MOVE	T3,[PM%CNT+PM%WR]
	ADD	T3,FILBSZ
	PMAP

	SETO	T1,		;UN-MAP THE ENTIRE BUFFER
	MOVE	T2,[400000,,BUFBLK]
	MOVE	T3,[PM%CNT]
	HRR	T3,FILBSZ
	PMAP

	MOVE	T1,[CO%NRJ]	;CLOSE FILE; DON'T RELEASE JFN
	HRR	T1,INJFN
	CLOSF
	  HALTF

	HRLI	T1,.FBSIZ	;CHANGE FILE SIZE IN DESCRIPTOR BLOCK
	OR	T1,[CF%NUD]
	SETO	T2,
	MOVE	T3,FILSIZ
	CHFDB

	HRLI	T1,.FBBYV	;TELL FILE IT'S BYTE SIZE IS NOW 7
	MOVE	T2,[FB%BSZ]
	MOVSI	T3,700
	CHFDB

	MOVE	T1,INJFN	;NOW RELEASE THE JFN
	RLJFN
	  HALTF
	TRZ	F,GFL		;SAY FILE IS NO LONGER AROUND
>
	POPJ	P,

SAVFNO:
TOPS20<	SETO	T1,		;UN-MAP THE ENTIRE BUFFER
	MOVE	T2,[400000,,BUFBLK]
	MOVE	T3,[PM%CNT]
	HRR	T3,FILBSZ
	PMAP
	MOVE	T1,INJFN	;CLOSE FILE AND RELEASE JFN
	CLOSF
	  HALTF
	TRZ	F,GFL		;SAY FILE IS NO LONGER AROUND
>
	PUSHJ	P,SAVMGN	;TELL USER THAT FILE IS NOT CHANGED
	MOVEI	T1,^D0700	;WAIT A WHILE
TOPS10<	HIBER	T1,
	  JFCL
>
TOPS20<	DISMS
>
	POPJ	P,

;ROUTINES TO OUTPUT FILE SAVE MESSAGES
;ENTER WITH T4/ ADDR OF OLDSPC OR FILSPC (WHICHEVER IS CURRENT FILE)

SAVMGN:	PUSHJ	P,CLRALL	;TELL USER THAT FILE IS NOT CHANGED
	MOVEI	T1,[ASCIZ /Not modified: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,T4		;OUTPUT FILESPECS
	PUSHJ	P,PUTSTG
	JRST	SAVMG1

SAVMGS:	PUSHJ	P,CLRALL
	MOVEI	T1,[ASCIZ /Saving file: /]
	PUSHJ	P,PUTSTG
	MOVE	T1,T4		;OUTPUT FILESPECS
	PUSHJ	P,PUTSTG
	MOVEI	T1,[ASCIZ / (no .BAK)/]
	SKIPN	BAKFLG		;IS A BACKUP WANTED?
	PUSHJ	P,PUTSTG	;YES - SAY SO

SAVMG1:	MOVEI	T1,15		;END WITH A CARRIAGE RETURN
	IDPB	T1,TY
	MOVEI	T1,12
	IDPB	T1,TY
	JRST	PUTTYP

;************************************************************************
;SUBROUTINE TO LOOK UP THE FILE POINTED TO BY T2, FOR OUTPUT
;TOPS10 CALL: MOVEI T2,FILFIL;	       PUSHJ P,SETOUT
;TOPS20 CALL: HRROI T2,[ASCIZ /FILE/]; PUSHJ P,SETOUT

TOPS10<
SETOUT:	MOVE	T1,USRPPN	;SET UP USER'S PPN
	MOVEM	T1,3(T2)
	OPEN	5,GENBLK	;OPEN A DUMP MODE OUTPUT FILE
	  HALT	.		;ON CHANNEL 5
	ENTER	5,(T2)
	  HALT	.
	HLLZS	1(T2)
	SETZM	2(T2)
	SETO	T1,
	POPJ	P,
>
TOPS20<
SETOUT:	MOVE	T1,[GJ%SHT]	;IT COULDN'T BE MORE STRAIGHTFORWARD
	GTJFN
	  HALTF
	MOVE	T2,[7B5+OF%WR]
	OPENF
	  HALTF
	POPJ	P,
>
;SUBROUTINE TO LOOK UP THE FILE POINTED TO BY T2, FOR INPUT
;TOPS10 CALL: MOVEI T2,FILFIL;	       PUSHJ P,SETIN
;TOPS20 CALL: HRROI T2,[ASCIZ /FILE/]; PUSHJ P,SETIN
;RETURNS -FILE SIZE OR HANDLE IN T1 IF LOOKUP SUCCESSFUL, ELSE 0

TOPS10<
SETIN:	MOVE	T1,USRPPN	;SET UP USER'S PPN
SETIN1:	MOVEM	T1,3(T2)
	OPEN	5,GENBLK	;OPEN A DUMP MODE INPUT FILE
	  POPJ	P,		;ON CHANNEL 5
	SETZ	T1,		;ASSUME FILE'S NOT THERE
	LOOKUP	5,(T2)
	  POPJ  P,		;NO SUCH FILE - RETURN ZERO
	HLLZS	1(T2)
	SETZM	2(T2)
	MOVE	T1,USRPPN	;GET USER'S PPN
	EXCH	T1,3(T2)	;SWAP FOR NEGATIVE FILE SIZE
	POPJ	P,
>
TOPS20<
SETIN:	MOVE	T1,[GJ%OLD+GJ%SHT]
	GTJFN
	JRST	SETIN0
	MOVE	T2,[7B5+OF%RD]
	OPENF
SETIN0:	  SETZ	T1,
	POPJ	P,
>
TOPS10<	;SUBROUTINE TO DELETE A FILE. SPECS IN T2

SETDEL:	MOVE	T1,USRPPN	;SET UP USER'S PPN
	MOVEM	T1,3(T2)
	OPEN	5,GENBLK	;OPEN A DUMP MODE INPUT FILE
	  HALT	.		;ON CHANNEL 5
	LOOKUP	5,(T2)
	  CAIA			;NO FILE - DON'T DELETE IT
	RENAME	5,DELFIL	;DELETE IT
	  JFCL
	RELEAS	5,		;GET RID OF IT
	POPJ	P,
>
;************************************************************************
;ROUTINES TO UN-DO THE DAMAGE CAUSED BY ENTER MODE, WHICH CAN BE:
;  1. REVERSED-SPACE AT CURSOR POSITION (COVER WITH CHARACTER FROM BUFFER)
;  2. ENTER LINE AT BOTTOM OF SCREEN (RE-WRITE WITH LINE FROM BUFFER)
;  3. ENTER FLAG (RESET IT)
;  4. CURSOR IS ILL-POSITIONED (RE-POSITION IT)

;THE ENTER FLAG MUST ALWAYS BE CLEARED. THE OTHER THINGS MAY NOT NEED TO
;BE UNDONE, DEPENDING ON HOW MUCH OF THE SCREEN HAS BEEN OVERWRITTEN.
;THUS THE ABOVE ARE HANDLED BY DIFFERENT SUBROUTINES, SO NO MORE WORK NEEDS
;TO BE DONE THAN NECESSARY.

;THE LINE AT THE BOTTOM MUST BE RE-DONE QUICKLY IF IT NEEDS TO BE DONE AT ALL
;THE TEXT MARK SHOULD ALSO BE DONE QUICKLY, SO CHRPTR MAY NOT NEED RE-MAKING
;CURSOR POSITIONING SHOULD BE THE LAST THING DONE BY THE COMMAND ROUTINE

;SUBROUTINE TO RESET ENTER MODE (NOTE: CAN'T FRAG T4)

RESTPM:	TLZN	F,ENT		;WAS ENTER TYPED?
	POPJ	P,		;NO - NOTHING TO DO
	PUSH	P,T4		;SAVE T4 SO IT CAN BE RESTORED
	JRST	ERSPM1

;SUBROUTINE TO WRITE LAST LINE OF SCREEN OVER ENTERED PARAMETER

ERASPM:	TLZN	F,ENT		;WAS ENTER TYPED?
	POPJ	P,		;NO - NOTHING TO DO
	PUSH	P,T4		;SAVE OLD T4
	TLNE	TM,NEL		;IS BOTTOM LINE SCRATCH?
	JRST	ERSPM0		;[CSM] Yes, don't update INSERT message
	TRNE	F,IMD		;IN INSERT MODE?
	JRST	[PUSHJ P,INSMSG ;YES - RESTORE INSERT MESSAGE
		 JRST  ERSPM1]
ERSPM0:	TLZ	F,FBL		;BOTTOM LINE IS NOW O.K.
	PUSHJ	P,CBOTOM	;MOVE TO BOTTOM OF SCREEN
	TLNE	TM,NEL		;[CSM] No bottom line?
	 JRST	ERSPM1		;[CSM] Just keep it blank
	TLZE	F,XPB		;IS POINTER TO LAST LINE VALID?
	PUSHJ	P,MAKBPT	;NO - MAKE IT
	SKIPN	PT,BOTPTR	;IS THERE REALLY A BOTTOM LINE?
	JRST	ERASFN		;NO - PUT UP THE FENCE
	PUSHJ	P,DISONE	;ELSE RE-DO THE BOTTOM LINE
ERSPM1:	MOVE	T1,CHRCUR	;DE-BLIP THE BLIP
	CAIGE	T1," "		;IS CHARACTER A CONTROL CHARACTER?
	JRST	[TLNN  TM,MRK	;YES - GOT A MARK THERE?
		 JRST  .+4	;NO - DON'T DE-BLIP IT
		 ADDI  T1,100	;YES - MAKE CHARACTER A REAL CHARACTER
		 MOVEM T1,CHRCUR
		 JRST  .+1]	;AND DRIVE ON
	PUSHJ	P,POSCUR	;ELSE POSITION THE CURSOR
	MOVE	T1,CHRCUR
	IDPB	T1,TY		;AND PUT THE PROPER CHARACTER BACK THERE
	POP	P,T4		;RESTORE THE T4 THAT WAS ENTERED WITH
	TRZN	F,CMV		;CLEAR CURSOR MOVEMENT FLAG - ON?
	POPJ	P,		;NO - RETURN
	CAME	RW,SAVPOS	;YES - WAS ROW CHANGED?
	TLO	F,XPL!XPC	;YES - POINTERS ARE NO GOOD
	MOVE	RW,SAVPOS	;RESTORE SAVED POSITION
	CAME	CM,SAVPOS+2	;WAS COLUMN CHANGED?
	TLO	F,XPC		;YES - CURSOR POINTER IS NO GOOD
	MOVE	CM,SAVPOS+1
	POPJ	P,		;THEN RETURN

ERASFN:	PUSHJ	P,FNCPUT	;OUTPUT THE FENCE
	JRST	ERSPM1		;FINISH OFF

;**********************************************************************
;SUBROUTINES TO POSITION THE CURSOR
;THESE JUST CALL THE ACTUAL POSITIONING ROUTINES IN THE TERMINAL-DEPENDENT
;CODE, OUTPUT IDLES AS DESIRED, AND TYPE OUT THE TYPE BUFFER

POSLIN:	PUSHJ	P,@PSL(TM)	;ELSE POSITION TO THE RIGHT LINE
	JRST    POSEND          ;GO FINISH OFF

POSCUR:	PUSHJ	P,@PSC(TM)	;ELSE POSITION TO THE RIGHT CHARACTER
POSEND:	TLNN	TM,NLP		;FOLLOW WITH SOME NULLS?
	JRST	PUTTYP		;NO - OUTPUT THE POSITIONING AND QUIT
	MOVE	T1,NUL(TM)	;YES - GET NULL CHARACTER
	HLRZ	T2,T1		;AND NUMBER OF NULLS TO OUTPUT
	IDPB	T1,TY		;OUTPUT A NULL
	SOJG	T2,.-1		;OUTPUT ALL THE NULLS, IN FACT
	JRST	PUTTYP		;THEN SEND IT ALL AND RETURN

;************************************************************************
;SUBROUTINES TO MANIPULATE POINTERS

;SUBROUTINE TO BACK UP THE DISPLAY POINTER BY (T4) LINES
;STOPS, NATURALLY, IF IT HITS THE START OF BUFFER. IN THAT CASE, T4 HAS
;NUMBER OF LINES NOT BACKED UP, SO SUBTRACT T4 FROM THE DISTANCE YOU
;THINK YOU WENT TO GET THE ACTUAL DISTANCE

BAKDPT:	MOVE	PT,DISPTR	;GET POINTER TO START OF SCREEN
	CAMN	PT,[010700,,BUFFER-1] ;AT START OF BUFFER?
	POPJ	P,		      ;YES - NOTHING TO DO AT ALL
BAKDP1:	ADD	PT,[70000,,0]	;FUDGE A DECREMENT OF THE BUFFER POINTER
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	LDB	T2,PT		;GET A CHARACTER
BAKDP2:	CAIE	T2,12		;LINEFEED?
	JRST	BAKDP1		;NO - IGNORE IT

	CAMN	PT,[010700,,BUFFER-1] ;AT START OF BUFFER?
	JRST	[MOVEM PT,DISPTR      ;YES - POINT TO START OF BUFFER
		 SOJA  T4,CPOPJ]      ;ADJUST COUNT AND RETURN
	ADD	PT,[70000,,0]	;FUDGE A DECREMENT OF THE BUFFER POINTER
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	LDB	T2,PT		;YES - PICK UP THE <CR>
	CAIE	T2,15		;IS IT REALLY?
	JRST	BAKDP2		;NO - IT'S NOT THE END OF THE LINE
	SOJG	T4,BAKDP1	;YES - LOOP THROUGH DESIRED NUMBER OF ROWS
	IBP	PT		;SKIP OVER THAT LAST LINEFEED
	MOVEM	PT,DISPTR	;SAVE SET-UP DISPLAY POINTER
	POPJ	P,		;DONE

;SUBROUTINE TO ADVANCE DISPLAY POINTER BY (T4) LINES
;IF END OF FILE FOUND, SETS DISPTR TO LPR LINES BEFORE END OF FILE

ADVDPT:	MOVE	PT,DISPTR	;GET DISPLAY POINTER
	PUSHJ	P,ADVLPT	;ADVANCE IT
	MOVEM	PT,DISPTR	;SAVE IT AGAIN
	JUMPGE	T4,CPOPJ	;IF NOT HIT END JUST RETURN
	TRZE	F,XCT		;TURN OFF EXECUTE FLAG - ON?
	JRST	XCEERR		;YES - SAY FINISHED PREMATURELY
	ADD	T4,ROLLS	;ELSE FIND DISTANCE OF REAL ROLL
	SUB	T4,LPR
	SOJ	T4,
	MOVEM	T4,ROLLS	;SAVE REAL ROLL
	MOVE	T4,LPR		;BACK UP LPR LINES
	TLO	F,FLG		;SET FLAG FOR RE-DISPLAY
	JRST	BAKDPT		;AND RETURN WITH THAT

;SUBROUTINE TO MAKE A POINTER TO THE CHARACTER WHERE THE CURSOR IS
;CANNOT USE T1, SINCE THERE MAY BE A LIVE CHARACTER THERE
;RETURNS CHARACTER POINTED TO BY CHRPTR, IN T3
;IF THAT CHARACTER IS A TAB, RETURNS PTR TO IT IN TABPTR

MAKCPT:	TLZN	F,XPC		;IS CHARACTER POINTER ALREADY GOOD?
	JRST	MAKCOK		;YES - CHECK FOR TAB (MAY COME BACK TO .+1)
MAKCK1:	TLZE	F,XPL		;IS LINE POINTER GOOD?
	PUSHJ	P,MAKLPT	;NO - MAKE IT FIRST

MAKCP0:	MOVE	T3,LINPTR	;GET LINE POINTER
	MOVEM	T3,CHRPTR	;SAVE AS STARTING CHARACTER POINTER
	MOVE	T2,CM		;GET COLUMN TO MOVE TO
	ADD	T2,SL		;  (INCLUDING SLIDE OFFSET)
	JUMPE	T2,MAKCP2	;IF ZERO, JUST CHECK FOR A TAB
MAKCP1:	CAMN	EN,CHRPTR	;AT END OF USEABLE BUFFER?
	JRST	MAKCCR		;YES - ADD A FEW SPACES buggy if here
	ILDB	T3,CHRPTR	;GET A CHARACTER
	JUMPE	T3,MAKCP1	;IGNORE IF NULL
	CAIN	T3,15		;CARRIAGE RETURN?
	JRST	MAKCCR		;YES - NEED TO EXTEND LINE
	CAIN	T3,11		;TAB?
	JRST	MAKCTB		;YES - NEED TO USE THE RIGHT NUMBER OF SPACES
	SOJG	T2,MAKCP1	;LOOP THROUGH DESIRED NUMBER OF COLUMNS
MAKCP2:	MOVE	T2,CHRPTR	;DONE - SEE WHAT CHARACTER IS POINTED TO
	CAMN	T2,EN		;AT END OF BUFFER?
	JRST	[MOVEI T2,15	;YES - NEED A FINAL <CR>
		 IDPB  T2,EN
		 MOVEI T2,12
		 IDPB  T2,EN
		 POPJ  P,]
	ILDB	T3,T2
	JUMPE	T3,MAKCP2+1	;SKIP, IF NULL
	CAIE	T3,11		;IF IT'S A TAB, SET UP COUNTS AND RETURN
	POPJ	P,		;ELSE JUST RETURN
	MOVEM	T2,TABPTR	;SAVE POINTER TO TAB
	MOVE	T2,CM		;FIND NEGATIVE HOW LONG THIS TAB SHOULD BE
	ADD	T2,SL
	ANDI	T2,7
	SUBI	T2,10
	SETZM	TABSPC		;WANT NO SPACES TO LEFT OF TAB
	MOVNM	T2,TABSIZ	;SAVE LENGTH OF TAB
	POPJ	P,		;NOW RETURN

;HERE WHEN TAB FOUND. JUMP THE CORRECT NUMBER OF SPACES
;IF DESIRED POSITION IS WITHIN THE TAB, POINT TO START OF TAB

MAKCTB:	MOVE	T3,CM		;FIND NEGATIVE HOW LONG THIS TAB SHOULD BE
	ADD	T3,SL
	SUB	T3,T2
	ANDI	T3,7
	SUBI	T3,10
	DPB	T2,[POINT 3,TABSPC,35]
	MOVNM	T3,TABSIZ
	ADD	T2,T3		;MOVE OVER THAT MANY POSITIONS
	MOVEI	T3,11		;GET THE TAB BACK
	JUMPG	T2,MAKCP1	;O.K. IF STILL MORE TO GO
	JUMPE	T2,MAKCP2	;OR JUMP IF COUNTED OUT EXACTLY
	MOVE	T2,CHRPTR	;BACK POINTER UP BEFORE THE TAB
	MOVEM	T2,TABPTR
	ADD	T2,[70000,,0]
	JUMPGE	T2,.+2
	SUB	T2,[430000,,1]
	MOVEM	T2,CHRPTR
	POPJ	P,		;AND THEN DONE

;HERE IS CHARACTER POINTER IS O.K. - RECALCULATE IF IT POINTS TO A TAB

MAKCOK:	MOVE	T2,CHRPTR	;DONE - SEE WHAT CHARACTER IS POINTED TO
	CAMN	T2,EN		;AT END OF BUFFER?
	JRST	[MOVEI T2,15	;YES - NEED A FINAL <CR>
		 IDPB  T2,EN
		 MOVEI T2,12
		 IDPB  T2,EN
		 JRST  MAKCK1]
	ILDB	T3,T2
	JUMPE	T3,MAKCOK+1	;SKIP, IF NULL
	CAIN	T3,15		;GET A <CR>?
	JRST	[TLNN  F,INS	;YES - WANT TO INSERT IF CURSOR OUT OF RANGE?
		 POPJ  P,	;NO - RETURN FROM MAKCPT
		 JRST  MAKCK1]	;YES - RE-CALC CURSOR POINTER
	CAIE	T3,11		;TAB?
	POPJ	P,		;NO - RETURN FROM MAKCPT
	JRST	MAKCK1		;ELSE RE-DO CHARACTER POINTER

;HERE IF END OF LINE FOUND, BUT NOT ENOUGH CHARACTERS
;IF FLAG INS IS SET, ADD SPACES TO THE LINE, THEN POINT BEYOND THEM
;ELSE JUST POINT TO THE <CR>

MAKCCR:	TLNN	F,INS		;WANT TO EXTEND THE LINE?
	JRST	MAKCC1		;NO - JUST RETURN POINTING TO <CR>
	MOVEM	T2,NUMCHR	;ADD (T3) SPACES (AND SOME NULLS) TO THE FILE
	PUSH	P,T1		;SAVE CHARACTER TO BE EVENTUALLY ADDED
	MOVSI	T1,70000	;MOVE POINTER BEHIND THE <CR>
	ADD	T1,CHRPTR
	JUMPGE	T1,.+2
	SUB	T1,[430000,,1]
	MOVEM	T1,CHRPTR	;SAVE IT AGAIN
	PUSHJ	P,MAKSPC	;PUNCH A HOLE IN THE FILE
	POP	P,T1
	JRST	MAKCP0		;MAKE CURSOR POINTER RIGHT

MAKCC1:	MOVSI	T1,70000	;BACK THE CHARACTER POINTER ONE NOTCH
	ADD	T1,CHRPTR
	JUMPGE	T1,.+2
	SUB	T1,[430000,,1]
	MOVEM	T1,CHRPTR
	POPJ	P,

;SUBROUTINE TO MAKE A POINTER TO THE START OF THE LINE THE CURSOR IS ON
;CANNOT USE T1, SINCE THERE MAY BE A LIVE CHARACTER THERE

MAKLPT:	MOVE	PT,DISPTR	;GET POINTER TO START OF SCREEN
	MOVEM	PT,LINPTR	;SAVE IT AS INITIAL LINE POINTER
	SKIPN	T4,RW		;GET ROW TO MOVE TO - ZERO?
	POPJ	P,		;YES - DONE
	PUSHJ	P,ADVLPT	;NO - ADVANCE THE POINTER
	JUMPL	T4,MAKLP2	;ADD LINES IF AT END OF FILE
	MOVEM	PT,LINPTR	;SAVE THE CORRECT LINE POINTER
	MOVE	T3,PT		;GET FRAGGABLE POINTER
MAKLP0:	CAMN	T3,EN		;AT END OF BUFFER?
	JRST	ADDCR		;YES - NEED TO ADD A <CRLF> AT END
	ILDB	T2,T3		;NO - FIND A NON-NULL CHARACTER
	JUMPE	T2,MAKLP0
	POPJ	P,		;GOT ONE - O.K.

;HERE IF END OF BUFFER FOUND, BUT NOT ENOUGH <CR>S
;IF THE INS FLAG IS SET, ADD THE DESIRED <CR>S TO BUFFER, PLUS SOME NULLS
;THEN POINT BEYOND THE <CR>S
;IF INS NOT SET, POINT TO LAST <CR>

MAKLP2:	TLNN	F,INS		;WANT TO INSERT STUFF?
	JRST	MAKLP3		;NO - JUST POINT TO LAST <CR>
	MOVEI	T3,15		;NO - SAVE OFF <CRLF>S
	MOVEI	T2,12
	IDPB	T3,EN
	IDPB	T2,EN
	AOJL	T4,.-2		;UNTIL GOT ENOUGH
	MOVEM	EN,LINPTR	;SAVE AS POINTER TO DESIRED LINE
	IDPB	T3,EN		;AND A FINAL <CR>
	IDPB	T2,EN
	SETZ	T3,
	IDPB	T3,EN
	POPJ	P,

MAKLP3:	ADD	PT,[70000,,0]	;BACK THE LINE POINTER ONE NOTCH
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	LDB	T1,PT		;LOOK FOR A <CR>
	CAIE	T1,15		;IS IT?
	JRST	MAKLP3		;NO - LOOP
	ADD	PT,[70000,,0]	;BACK UP BEFORE THE <CR>
	JUMPGE	PT,.+2
	SUB	PT,[430000,,1]
	MOVEM	PT,LINPTR	;SAVE LINE POINTER
	TLO	F,XPL!XPC	;BUT SAY IT'S INVALID
	POPJ	P,		;AND RETURN

ADDCR:	MOVEI	T2,15		;END BUFFER WITH A <CRLF>
	IDPB	T2,EN		;  AND A NULL
	MOVEI	T2,12
	IDPB	T2,EN
	SETZ	T2,
	IDPB	T2,EN
	POPJ	P,

;SUBROUTINE TO SET UP THE POINTER TO THE LAST LINE ON THE SCREEN
;WORKS WITH LINPTR IF IT'S VALID (BEING CLOSER); ELSE USES DISPTR
;RETURNS BOTTOM POINTER BOTH IN PT AND BOTPTR

;RETURNS 0 IF LAST LINE IS BEYOND END OF BUFFER, HENCE NOTHING TO DISPLAY
;  (ALSO, IF ZERO, FENCE SHOULD BE ON SCREEN)

MAKBPT:	MOVE	T4,LPP.1	;GET DISTANCE OF BOTTOM LINE FROM TOP LINE
	TLNE	F,XPL		;IS LINE POINTER VALID?
	JRST	[MOVE  PT,DISPTR ;NO - USE DISPLAY POINTER
		 JRST  MAKBP1]
	MOVE	PT,LINPTR	;YES - USE IT
	SUB	T4,RW		;AND WORK A FEW LINES LESS
	JUMPE	T4,MAKBP2	;ALREADY AT BOTTOM LINE. WADDYA KNOW

MAKBP1:	PUSHJ	P,ADVLPT	;ADVANCE THE POINTER
	JUMPGE	T4,.+2		;BEYOND END OF FILE?
	SETZ	PT,		;YES - NO POINTER, THEN
MAKBP2:	MOVEM	PT,BOTPTR	;SAVE POINTER (OR NON-POINTER)
	POPJ	P,

;SUBROUTINE TO ADVANCE THE POINTER IN PT (T4) LINES
;T4 IS RETURNED WITH NEGATIVE NUMBER OF LINES NOT FOUND (0 IF ALL FOUND)

ADVLPT:	CAMN	EN,PT		;AT END OF USEABLE BUFFER?
	JRST	[MOVN T4,T4	;NO - RETURN NEGATIVE # LINES NOT FOUND
		 POPJ P,]	;AND RETURN
	ILDB	T2,PT		;GET A CHARACTER
ADVLP1:	CAIE	T2,15		;CARRIAGE RETURN?
	JRST	ADVLPT		;NO - IGNORE IT

	ILDB	T2,PT		;YES - PICK UP THE <LF>
	CAIE	T2,12		;IS IT REALLY?
	JRST	ADVLP1		;NO - IT'S NOT THE END OF THE LINE
	SOJG	T4,ADVLPT	;YES - LOOP THROUGH DESIRED NUMBER OF ROWS
	POPJ	P,		;DONE

;************************************************************************
;SUBROUTINE TO OVERWRITE (T4) REAL CHARACTERS (NOT NULLS) WITH NULLS
;AT (PT), WHICH IS FRAGGED
;STOPS WHEN COUNTED OUT, OR AT END OF LINE

WRTNUL:	MOVEM	T4,WRTNUM	;SAVE NUMBER OF CHARS TO NULL
	SETZ	T1,		;GET A NULL
	ILDB	T2,PT		;GET FIRST CHARACTER
	JUMPE	T2,[CAME PT,EN	;IF NULL, REACHED END OF BUFFER?
		    JRST .-1	;NO - JUST IGNORE THE NULL
		    POPJ P,]	;YES - RETURN NOW
	CAIE	T2,11		;IS IT A TAB?
	JRST	WRTNL2-2	;NO - CONTINUE
	MOVE	T2,TABSPC	;YES - FIND NUMBER OF SPACES RIGHT OF CURSOR
	SUB	T2,TABSIZ
	JRST	WRTNT1		;PROCESS THE TAB

WRTNL1:	ILDB	T2,PT		;GET A CHARACTER
	CAMN	PT,EN		;AT END OF BUFFER?
	POPJ	P,		;YES - GO HOME EARLY
	JUMPE	T2,WRTNL1	;IGNORE IF NULL
	CAIN	T2,11		;IS IT A TAB?
	JRST	WRTNTB		;YES - SEE HOW LONG THE TAB IS
	CAIN	T2,15		;IS IT A <CR>?
	PUSHJ	P,WRTNL3	;YES - DONE, IF FOLLOWED BY  <LF>
WRTNL2:	DPB	T1,PT		;ELSE OVERWRITE WITH A NULL
	SOJG	T4,WRTNL1	;AND COUNT IT - GOT ENOUGH?
	POPJ	P,		;YES - RETURN

WRTNL3:	MOVE	T3,PT		;GET SCRATCH BUFFER POINTER
	ILDB	T2,T3		;GET NEXT CHARACTER
	CAIN	T2,12		;<LF>?
	POP	P,		;YES - FINISHED. NOW.
	POPJ	P,		;NO - NULL OUT THE <CR>, TOO

WRTNTB:	MOVE	T2,CM		;GET STARTING COLUMN POSITION
	ADD	T2,WRTNUM	;PLUS LENGTH OF DELETE
	SUB	T2,T4		;LESS NUMBER TO GO, GIVES PRESENT POSITION
	ANDI	T2,7		;FIND NEGATIVE SIZE OF TAB
	SUBI	T2,10
WRTNT1:	ADD	T4,T2		;COUNT OFF THAT MANY SPACES FROM DELETE
	DPB	T1,PT		;NULL OUT THE TAB
	JUMPG	T4,WRTNL1	;CONTINUE, IF STILL MORE TO GO
	MOVN	T4,T4		;AND ADD SOME SPACES FOR THIS TAB, TOO
	ADDM	T4,NUMCHR
	POPJ	P,		;AND GO ADD THEM

;************************************************************************
;SUBROUTINE TO CALCULATE RW AND LINPTR, GIVEN CHRPTR AND DISPTR

CALCRW:	MOVE	PT,DISPTR	;START FROM START OF SCREEN
	MOVEM	PT,LINPTR	;SAVE (TENTATIVE) LINE POINTER
	SETZ	RW,		;CLEAR ROW NUMBER
CALRW1:	CAMN	PT,CHRPTR	;AT DESIRED POSITION?
	POPJ	P,		;YES - DONE
	ILDB	T1,PT		;NO - GET CHARACTER
CALRW2:	CAIE	T1,15		;<CR>?
	JRST	CALRW1		;NO - SKIP IT
	ILDB	T1,PT		;YES - GET NEXT CHARACTER
	CAIE	T1,12		;<LF>?
	JRST	CALRW2		;NO - SKIP IT
	MOVEM	PT,LINPTR	;SAVE (TENTATIVE) LINE POINTER
	AOJA	RW,CALRW1	;YES - COUNT LINE AND LOOP

;SUBROUTINE TO CALCULATE THE NUMBER OF LINES AND PAGES, AND TOTAL LINES
;SINCE THE START OF THE FILE

FINDRW:	SETZB	T3,SAVEAC	;CLEAR PAGE NUMBER AND TOTAL LINES
	JRST	.+2		;SKIP SUMMING THE FIRST TIME
FNDRW0:	ADDM	RW,SAVEAC	;ADD UP TOTAL LINES PASSED OVER
	SETZ	RW,		;CLEAR ROW NUMBER
FNDRW1:	CAMN	PT,CHRPTR	;AT DESIRED POSITION?
	JRST	[ADDM RW,SAVEAC	;YES - ADD IN LINES FROM LAST PAGE
		 POPJ P,]	;DONE
	ILDB	T1,PT		;NO - GET CHARACTER
FNDRW2:	CAIN	T1,14		;FORMFEED?
	AOJA	T3,FNDRW0	;YES - BUMP PAGES AND ZERO LINES
	CAIE	T1,15		;<CR>?
	JRST	FNDRW1		;NO - SKIP IT
	ILDB	T1,PT		;YES - GET NEXT CHARACTER
	CAIE	T1,12		;<LF>?
	JRST	FNDRW2		;NO - SKIP IT
	AOJA	RW,FNDRW1	;YES - COUNT LINE AND LOOP

;SUBROUTINE TO CALCULATE CM, GIVEN CHRPTR, AND LINPTR IN PT
;IF CM IS BEYOND SCREEN LIMITS, DOES A SLIDE TO PUT IT WITHIN LIMITS
;NORMAL RETURN IF SLIDE, ELSE SKIP RETURN

CALCCM:	SETZ	CM,		;CLEAR COLUMN NUMBER
	AOS	(P)		;ASSUME THERE WON'T BE A SLIDE
CALCM1:	CAMN	PT,CHRPTR	;AT CHARACTER POSITION?
	JRST	CALCCD		;YES - DONE
	ILDB	T1,PT		;NO - GET CHARACTER
	JUMPE	T1,CALCM1	;IGNORE IF NULL
	CAIE	T1,11		;TAB?
	AOJA	CM,CALCM1	;NO - COUNT CHARACTER AND LOOP
	ADDI	CM,10		;YES - COUNT THE RIGHT AMOUNT
	TRZ	CM,7
	JRST	CALCM1

CALCCD:	SUB	CM,SL		;ACCOUNT FOR THE SLIDE
	CAMGE	CM,CPL(TM)	;OFF THE RIGHT SIDE?
	JRST	CALCD1		;NO - CHECK LEFT
	MOVE	T1,CM		;YES - SLIDE A BIT TO SHOW THE MATCH
	MOVE	T2,CPL(TM)
	IDIVI	T2,3
	LSH	T2,1
	SUB	T1,T2
	ADD	SL,T1
	SUB	CM,T1
	SOS	(P)		;GIVE A NORMAL RETURN
	POPJ	P,		;RETURN

CALCD1:	JUMPGE	CM,CPOPJ	;OFF THE LEFT SIDE?
	ADD	SL,CM		;YES - MOVE LEFT SO KEY IS ON SCREEN
	SETZ	CM,
	SOS	(P)		;GIVE A NORMAL RETURN
	POPJ	P,		;RETURN

;************************************************************************
;SWITCH HANDLING SUBROUTINES. THERE BE:
;SWHMNY - HANDLES A STRING OF SWITCHES. T2 POINTS TO START OF FIRST ONE
;SWHONE - HANDLES A SINGLE SWITCH IN PARBUF

;MANY SWITCHES: TRANSFER EACH TO PARBUF; CALL SWHONE; LOOP
;SWITCHES END WITH A RETURN OR A NULL
;SWITCHES ARE NULLED OUT OF (T2) AS THEY ARE TRANFERRED
;CALL WITH T2 POINTING AFTER THE "/" OF THE FIRST SWITCH

SWHMNY:	MOVE	T3,[POINT 7,PARBUF]
	MOVEM	T3,PARPTR
	SETZ	T0,		;GET A NULL FOR NULLING
SWHMN0:	ILDB	T1,T2		;TRANSFER SWITCH TO PARAMETER BUFFER
	JUMPE	T1,SWHMN1	;IF NULL, HANDLE LAST SWITCH
	DPB	T0,T2		;NULL OUT THE SOURCE CHARACTER
	CAIN	T1," "		;IGNORE SPACES
	JRST	SWHMN0
	CAIN	T1,"X"		;EXECUTE SWITCH?
	JRST	SWHMNX		;YES - SPECIAL CASE
	CAIE	T1,"/"		;START OF ANOTHER SWITCH?
	CAIN	T1,15		;OR END OF LINE?
	JRST	SWHMN1		;YES - PROCESS THE SWITCH
	IDPB	T1,T3		;ELSE SAVE CHARACTER
	JRST	SWHMN0		;AND GET ANOTHER

SWHMN1:	DMOVEM	T1,SAVEAC+4	;SAVE LATEST CHARACTER AND SWITCH POINTER
	IDPB	T0,T3		;END WITH A NULL
	PUSHJ	P,SWHONE	;PROCESS THE SWITCH
SWHMN2:	DMOVE	T1,SAVEAC+4	;GET CHARACTER AND POINTER BACK
SWHMN3:	JUMPE	T1,CPOPJ	;RETURN, IF DONE
	CAIE	T1,15		;AT END OF LINE?
	JRST	SWHMNY		;NO - LOOK FOR ANOTHER SWITCH
	SETZ	T0,		;YES - GET THE NULL AGAIN
SWHMNS:	ILDB	T1,T2		;SKIP REST OF LINE
	DPB	T0,T2		;NULLING ALONG THE WAY
	CAIE	T1,12		;UNTIL LINEFEED
	JRST	SWHMNS
	POPJ	P,		;DONE

;HERE TO HANDLE THE EXECUTE SWITCH SEPARATELY

SWHMNX:	IDPB	T1,T3
	ILDB	T1,T2		;SAVE BUFFER NAME IN PARM BUFFER
	CAIE	T1,"/"		;START OF ANOTHER SWITCH?
	CAIE	T1,15
	JRST	SWHMN3		;YES - IGNORE THIS BAD FORMAT
	CAIE	T1,":"		;START OF CONTENTS?
	JRST	SWHMNX+1	;NO - KEEP GOING

	TLO	F,FLG		;SET TO GET A RETURN FROM XCT ROUTINES
	SETZ	T1,		;END WITH A NULL
	IDPB	T1,T3
	MOVEM	T2,SAVEAC+4	;SAVE POINTER
	PUSHJ	P,XCTSET	;SET UP THAT BUFFER
	MOVE	T2,SAVEAC+4	;RESTORE POINTER
	MOVE	T3,[POINT 7,PARBUF,6]

SWHMX1:	ILDB	T1,T2		;MOVE CONTENTS TO PARM BUFFER
	CAIE	T1,"/"		;START OF A NEW SWITCH
	CAIN	T1,15		;  OR END OF LINE?
	JRST	SWHMX2		;YES - SET UP CONTENTS
	IDPB	T1,T3		;NO - SAVE CHARACTER
	JRST	SWHMX1		;AND LOOP

SWHMX2:	DMOVEM	T1,SAVEAC+4	;SAVE CHARACTER AND POINTER
	SETZ	T1,		;END WITH A NULL
	IDPB	T1,T3
	PUSHJ	P,XCTWRT	;WRITE THE BUFFER
	TLZ	F,FLG		;CLEAR RETURN FLAG
	JRST	SWHMN2		;RESTORE ACS AND CONTINUE

;SUBROUTINE TO PARSE AND HANDLE A SINGLE SWITCH, WHICH IS IN PARAMETER BUFFER

SWHONE:	MOVE	PT,[POINT 7,PARBUF]
	SETO	T4,		;SET TO SET SWITCH
	MOVEI	T3,SWHNUM	;SET UP INDEX TO SWITCHES
	PUSHJ	P,SWHLUR	;GET NEXT CHARACTER
	CAIE	T1,"N"		;IS IT A NO-SWITCH?
	JRST	SWHLUK		;NO - CONTINUE
	SETZ	T4,		;YES - WANT TO CLEAR SWITCH
	PUSHJ	P,SWHLUR	;GET NEXT CHARACTER
	CAIE	T1,"O"		;IS IT AN "O"?
	JRST	SWHLUK		;NO - CONTINUE
	PUSHJ	P,SWHLUR	;GET NEXT CHARACTER
SWHLUK:	LDB	T2,[POINT 7,SWCHES-1(T3),6]
	CAME	T1,T2		;IS THIS THE SWITCH?
	SOJG	T3,SWHLUK	;NO - LOOK AT THE NEXT ONE
	JUMPLE	T3,SWHERR	;ERROR IF NOT FOUND
	JRST	@SWHADR-1(T3)	;HANDLE THE SWITCH AND RETURN

SWHLUR:	ILDB	T1,PT		;GET NEXT CHARACTER
	CAIN	T1," "		;SPACE?
	JRST	SWHLUR		;YES - IGNORE IT
	CAIL	T1,"a"		;LOWER CASE?
	SUBI	T1,40		;YES - CONVERT TO UPPER
	POPJ	P,		;RETURN

;ROUTINES TO HANDLE EACH SWITCH (POPJ WHEN DONE)

SWHSLD:	MOVEM	T4,SLDFLG	;SAVE SLIDE FLAG
	POPJ	P,
SWHUPP:	MOVEM	T4,UPPFLG	;SAVE UPPER-LOWER CASE FLAG
	POPJ	P,

SWHCAS:	JUMPGE	T4,.+2		;MAKE SEARCHES CASE-DEPENDENT?
	TRZA	F,NLC		;YES
	TRO	F,NLC		;NO
	POPJ	P,

SWHBBB:	PUSHJ	P,SWHLUR	;HERE FOR BA OR BE - READ CHARACTER
	CAIN	T1,"E"		;BEEP SWITCH?
	JRST	SWHBEP		;YES - HANDLE IT
	CAIN	T1,"L"		;BLOCK SWITCH?
	JRST	SWHSBK		;YES - HANDLE IT
	CAIE	T1,"A"		;BACKUP SWITCH?
	JRST	SWAERR		;NO - IT'S AMBIGUOUS
	MOVEM	T4,BAKFLG	;YES - SAVE BACKUP FILE FLAG
	POPJ	P,

SWHBEP:	JUMPE	T4,.+2		;SET BEEP-ON-INSERT-MODE FLAG?
	TLOA	TM,BEP		;YES
	TLZ	TM,BEP		;NO
	POPJ	P,

SWHSBK:	PUSHJ	P,SWHARG	;GET AMOUNT OF FILE TO READ IN, IN BLOCKS
	  TDZA	T3,T3		;IF NO ARG USE ZERO (READ ENTIRE FILE)
	LSH	T3,7		;CONVERT BLOCKS INTO WORDS
	MOVEM	T3,FILSBK	;SAVE AMOUNT
	POPJ	P,

SWHRRR:	PUSHJ	P,SWHLUR	;HERE FOR RO OR RE - READ CHARACTER
	CAIN	T1,"E"		;RESET SWITCH?
	JRST	SWHNOM		;YES - HANDLE IT
	CAIE	T1,"O"		;ROLL SWITCH?
	JRST	SWAERR		;NO - IT'S AMBIGUOUS
	JUMPGE	T4,.+2		;ROLL IF USER TYPES RETURN ON BOTTOM LINE?
	TRZA	F,NRC		;NO
	TRO	F,NRC		;YES
	POPJ	P,

SWHNOM:	JUMPE	T4,.+2		;SET RESET NOMINALS FLAG?
	TROA	F,RST		;YES
	TRZ	F,RST		;NO
	POPJ	P,

SWHLSD:	JUMPGE	T4,.+2		;SET LINEFEED-CURSOR DOWN FLAG?
	TLZA	TM,LSD		;NO
	TLO	TM,LSD		;YES
	POPJ	P,

SWHRDO:	JUMPN	T4,.+2		;[CSM] Set READONLY flag?
	TLZA	F,RDO		;[CSM] No
	TLO	F,RDO		;[CSM] Yes
	POPJ	P,

SWHWRT:	JUMPE	T4,.+2		;SET READ-ONLY FLAG?
	TLZA	F,RDO		;NO
	TLO	F,RDO		;YES
	POPJ	P,

SWHTBB:	JUMPE	T4,.+2		;SET DISPLAY TABS FLAG?
	TROA	F,DTB		;YES
	TRZ	F,DTB		;NO
	POPJ	P,

SWHHLP:	JUMPE	T4,.+2		;SET NO-HELP-WANTED FLAG?
	TRZA	F,NHP		;NO
	TRO	F,NHP		;YES
	POPJ	P,

SWHICR:	JUMPE	T4,.+2		;SET NO CR IN INSERT MODE FLAG?
	TRZA	F,NCR		;NO
	TRO	F,NCR		;YES
	POPJ	P,

SWHTAB:	JUMPE	T4,SWHTBW	;IF NOTABS, SET UP WORDWISE TABS
	PUSHJ	P,SWHARG	;ELSE READ ARGUMENT
	  JRST	SWHTNW		;NO ARG - SET UP NORMAL TABS
	MOVEM	T3,TABLEN	;SAVE ARG AS LENGTH OF A TAB
SWHTNW:	TRZA	F,WTB		;CLEAR WORDWISE TAB FLAG
SWHTBW:	TRO	F,WTB		;SET WORDWISE TAB FLAG
	POPJ	P,		;DONE

SWHPRC:	PUSHJ	P,SWHARG	;GET PERCENTAGE TO GO TO
	  SKIPA	T3,GOPERC	;IF NO ARG USE CURRENT PERCENT
	JUMPL	T3,SWHERR	;PERCENT MUST BE WITHIN [0,100]
	CAILE	T3,^D100
	JRST	SWHERR		;IT'S NOT - ERROR
	MOVEM	T3,GOPRCT	;O.K. - SAVE STARTING PERCENT VALUE
	POPJ	P,

SWHPPP:	PUSHJ	P,SWHLUR	;HERE FOR PA OR PR - READ CHARACTER
	CAIN	T1,"A"		;PAGE-AND-LINE STATUS SWITCH?
	JRST	SWHPAG		;YES - HANDLE IT
	CAIE	T1,"R"		;PROG TO RUN ON EXIT SWITCH?
	JRST	SWAERR		;NO - IT'S AMBIGUOUS
	PUSHJ	P,SWHAGS	;READ NAME OF SYSTEM CUSP TO RUN
	  JRST	SWHERR		;NO ARG - ERROR
	MOVEM	T3,GOBLK+1	;SAVE IN RUN BLOCK
	POPJ	P,		;THAT'S ALL

SWHPAG:	MOVEM	T4,PAGFLG	;SAVE PAGE/LINES FLAG
	POPJ	P,

SWHTRM:	PUSHJ	P,SWHAGS	;READ NAME OF TERMINAL TO USE
	  JRST	SWHERR		;NO ARG - ERROR
	MOVEM	T3,TRMNAM	;SAVE TERMINAL NAME
	POPJ	P,		;THAT'S ALL

;HERE FOR VARIOUS FILE STATUS SWITCHES: FC, FR, FS, FD, FO
;IF THESE ARE USED, /FD MUST APPEAR AND BE FIRST

SWHSTT:	PUSHJ	P,SWHLUR	;GET FLAVOR OF F SWITCH
	MOVE	T2,T1		;SAVE FLAVOR
	PUSHJ	P,SWHARG	;READ ARGUMENT OF SWITCH
	  JRST	SWHERR		;NO ARG - ERROR
	CAIN	T2,"C"		;FC (COLUMN POSITION) SWITCH?
	JRST	SWHSTC		;YES - GO DO IT
	CAIN	T2,"R"		;FR (ROW POSITION) SWITCH?
	JRST	SWHSTR		;YES - GO DO IT
	CAIN	T2,"S"		;FS (SLIDE OFFSET) SWITCH?
	JRST	SWHSTL		;YES - GO DO IT
	CAIN	T2,"D"		;FD (DISPLAY POINTER) SWITCH?
	JRST	SWHSTD		;YES - GO DO IT
	CAIN	T2,"O"		;FO (ONE-SHOT) SWITCH?
	JRST	SWHOSH		;YES - GO DO IT
	JRST	SWHERR		;ANYTHING ELSE IS AN ERROR

SWHSTC:	HRLM	T3,PRERW	;SET UP COLUMN POSITION
	POPJ	P,
SWHSTR:	HRRM	T3,PRERW	;SET UP ROW POSITION
	POPJ	P,
SWHSTL:	MOVEM	T3,PRESL	;SET UP SLIDE OFFSET
	POPJ	P,
SWHOSH:	MOVEM	T3,PREONE	;SET UP ONE-SHOT POINTER
	POPJ	P,

SWHSTD:	SETZM	PRERW		;CLEAR THE OTHER POINTERS
	SETZM	PRESL
	IDIVI	T3,5		;SEPARATE INTO WORD, POSITION IN WORD
	ADDI	T3,BUFFER	;MAKE POINTER RELATIVE TO START OF BUFFER
	JUMPE	T4,SWHSD1	;HANDLE POINTING TO START OF WORD SPECIALLY
	HRL	T3,PTRTBL(T4)	;MAKE IT POINT AT THE RIGHT BIGHT
SWHSD0:	MOVEM	T3,PREDP	;SAVE POINTER IN THE RYTE PLACE
	POPJ	P,		;DONE
SWHSD1:	HRLI	T3,010700
	SOJA	T3,SWHSD0

;THE ONE-SHOT ARGUMENT IS THE CHARACTER IN THE FILE WHICH THE CURSOR SHOULD
;POINT TO. IT WILL BE SET UP 1/3 DOWN THE SCREEN. SO  NEED TO CALCULATE
;CHRPTR, LINPTR, DISPTR, RW, CM, AND SL

;SWHOSH:	IDIVI	T3,5		;SEPARATE INTO WORD, POSITION IN WORD
;	ADDI	T3,BUFFER	;MAKE POINTER RELATIVE TO START OF BUFFER
;	HRL	T3,PTRTBL(T4)	;MAKE IT POINT AT THE RIGHT BYTE
;	MOVE	PT,T3		;SAVE POINTER IN THE RIGHT PLACE
;	JRST	SRCSET		;SET EVERYTHING UP AND RETURN

;SUBROUTINE TO READ COLON (MAYBE) AND NUMERIC ARGUMENT OF A SWITCH
;RETURNS VALUE IN T3; USES T1
;GIVES SKIP RETURN IF VALUE FOUND, NON-SKIP IF NO COLON FOUND

SWHARG:	ILDB	T1,PT		;GET THE COLON
	CAIE	T1,":"		;IS IT REALLY?
	JUMPN	T1,SWHARG	;NO - TRY NEXT ONE, IF ANY
	JUMPE	T1,CPOPJ	;NO COLON - NON-SKIP RETURN
	AOS	(P)		;GOT THE COLON - GIVE SKIP RETURN
	SETZ	T3,		;YES - CLEAR TARGET
SWHAG1:	ILDB	T1,PT		;GET A DIGIT
	JUMPE	T1,CPOPJ	;RETURN, IF NULL
	SUBI	T1,"0"		;CONVERT TO NUMERIC
	JUMPL	T1,SWHER0	;ERROR IF NOT A NUMBER
	CAILE	T1,9
	JRST	SWHER0		;DITTO
	IMULI	T3,^D10		;ELSE MULTIPLY BY TEN
	ADD	T3,T1		;ADD IN NEW DIGIT
	JRST	SWHAG1		;AND GET ANOTHER ONE

;SUBROUTINE TO READ COLON (MAYBE) AND ASCII ARGUMENT OF A SWITCH
;RETURNS VALUE, IN SIXBIT, IN T3
;GIVES SKIP RETURN IF VALUE FOUND, NON-SKIP IF NO COLON FOUND

SWHAGS:	ILDB	T1,PT		;GET THE COLON
	CAIE	T1,":"		;IS IT REALLY?
	JUMPN	T1,SWHAGS	;NO - TRY NEXT ONE, IF ANY
	JUMPE	T1,CPOPJ	;NO COLON - NON-SKIP RETURN
	AOS	(P)		;GOT THE COLON - GIVE SKIP RETURN
	SETZ	T3,		;YES - CLEAR TARGET
	MOVE	T4,[POINT 6,T3] ;AND POINT TO IT
	MOVEI	T0,6		;EXPECT A MAXIMUM OF SIX
SWHGS1:	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,CPOPJ	;RETURN, IF NULL
	CAIL	T1,"a"		;LOWER CASE?
	TRZA	T1,100		;YES - MAKE IT LOWER
	SUBI	T1," "		;CONVERT TO SIXBIT
	JUMPL	T1,SWHER0	;ERROR IF NOT LEGALLY SIXBIT
	IDPB	T1,T4		;ELSE SAVE IT WITH THE REST
	SOJG	T0,SWHGS1	;GET MORE - COUNTED OUT?
	POPJ	P,		;YES - USE ONLY 6 CHARACTERS

;IF SWITCH ERROR OUTPUT MESSAGE, RETURN TO CALLER OF SWHONE

SWHER0:	POP	P,		;RETURN TO CALLER OF SWHONE
SWHERR:	MOVEI	T1,[ASCIZ /##########Bad switch name/]
	TRNN	TM,-1		;IN RESCAN OR SWITCH.INI?
	POPJ	P,		;YES -  NO MESSAGE
	CAIN	DO,"B"-100	;DOING A SET-FILE?
	JRST	STFERR		;YES - GIVE SET-FILE-FLAVORED ERROR
	JRST	ERROR		;ELSE DISPLAY THE ERROR AND RETURN

SWAERR:	MOVEI	T1,[ASCIZ /#########Ambiguous switch/]
	JRST	SWHERR+1	;DISPLAY THE ERROR AND RETURN

;************************************************************************
;SUBROUTINES TO FILL WITH SPACES OR NULLS (OR CONTENTS OF CHARAC)
;ENTER WITH NUMCHR/ NUMBER OF CHARACTERS TO INSERT
;	    CHRPTR/ PLACE TO START INSERTING THEM (PRESERVED)
;IF ENTER AT MAKCHR, SET UP CHARACTER IN CHARAC
;ON RETURN, CHRPTR WILL POINT TO THE START OF THE STUFF ADDED,
;	    T4 POINTS TO THE FIRST CHARACTER AFTER THE NEW STUFF
;	    MAKPTR POINTS TO LAST REAL CHARACTER ADDED

;NOTE: THIS IS THE only PLACE WHERE THINGS ARE INSERTED INTO THE BUFFER

MAKSPC:	MOVEI	T1," "		;GET A SPACE
	MOVEM	T1,CHARAC	;SAVE AS THE FILL CHARACTER
	JRST	MAKCHR		;GO PUT THEM IN
MAKNUL:	SETZM	CHARAC		;SET TO FILL WITH NULLS

MAKCHR:	SKIPN	T3,NUMCHR	;GET COUNT OF CHARACTERS TO PUT IN - ANY?
	POPJ	P,		;NO - JUST RETURN
	IDIVI	T3,5		;CONVERT IT TO COUNT OF WORDS
	JUMPE	T4,.+2		;ANY EXCESS?
	AOJ	T3,		;YES - ROUND UP TO NEXT FULL WORD
	MOVEM	T3,NUMWDS	;SAVE NUMBER OF WORDS TO ADD
	HRRZ	T4,CHRPTR	;GET ADDRESS OF START OF INSERT

;FIRST SEE IF THERE ARE ENOUGH NULL WORDS RIGHT WHERE THE CURSOR IS
;IF SO, JUST GO AND WRITE THEM

	SKIPE	(T4)		;COUNT CONSECUTIVE NULLS AT START: GOT ONE?
	JRST	MAKCH0		;NO - GO LOOK AND SQUEEZE
	SOJLE	T3,.+2		;YES - JUMP IF FOUND ENOUGH
	AOJA	T4,.-3		;ELSE LOOK FOR MORE
	CAIL	T4,(EN)		;MOVED BEYOND END OF BUFFER?
	HRRI	EN,1(T4)	;YES - EXTEND END BY THAT PLUS ONE WORD
	HRLI	T4,010700	;POINT TO END OF LAST NULL WORD
	HLLM	T4,CHRPTR	;AND POINT CHRPTR BEFORE START OF 1ST WORD
	SOS	CHRPTR
	JRST	MAKCH4		;GO PUT DATA IN

;HERE IF NOT ENOUGH NULLS WORDS AT CURSOR. LOOK (NOBYTE) WORDS AHEAD AND
;SHUFFLE THOSE UP TO THE TOP

MAKCH0:	MOVEM	T4,SAVEAC	;SAVE ADDRESS OF FIRST NON-NULL WORD
	MOVEI	T2,NOBYTE	;GET # OF WORDS TO LOOK AHEAD FOR NULLS
MAKCH1:	CAIN	T4,(EN)		;AT END OF BUFFER?
	AOJ	EN,		;YES - EXTEND BUFFER A WORD
	SKIPN	(T4)		;IS THIS WORD NULL?
	SOJLE	T3,MAKCH2	;YES - COUNT IT - COUNTED OUT?
	AOJ	T4,		;NO - POINT TO NEXT WORD
	SOJGE	T2,MAKCH1	;AND LOOP, IF NOT LOOKED FAR ENOUGH

;HERE IF NOT ENOUGH NULLS FOUND IN RANGE - SHUFFLE REST OF FILE DOWN
;IF ANY NULLS HAVE BEEN FOUND, LEAVE THEM ALONE

	HRRZ	T3,EN		;GET ADDRESS OF END OF FILE
	ADD	EN,NUMWDS	;EXTEND FILE BY THAT AMOUNT
	HRRZ	T4,EN		;GET ADDRESS OF NEW END OF FILE
	MOVE	T2,SAVEAC	;GET ADDRESS OF LAST WORD TO MOVE

MAKADD:	MOVE	T1,(T3)		;GET A WORD
	MOVEM	T1,(T4)		;SAVE IT
	SOJ	T4,
	CAME	T3,T2		;BACK TO START?
	SOJA	T3,MAKADD	;NO - KEEP GOING
	AOJA	T4,MAKCH4	;YES - PUT STUFF IN THAT NEW GAP

;NOW SQUEEZE ALL THE NULL WORDS UP TO THE LOCATION OF THE FILE POINTER

MAKCH2:	MOVE	T2,SAVEAC	;GET ADDRESS OF LAST WORD TO SHUFFLE
	MOVE	T3,T4		;POINT TO END OF SHUFFLE
MAKCH3:	CAMGE	T3,T2		;AT STARTING WORD?
	AOJA	T4,MAKCH4	;YES - DONE SHUFFLING BYTES
	SKIPN	T1,(T3)		;GET A WORD - NULL
	SOJA	T3,MAKCH3	;YES - DON'T SHUFFLE
	MOVEM	T1,(T4)		;NO - SAVE FARTHER DOWN
	SOJ	T4,
	SOJA	T3,MAKCH3	;DE-BUMP BOTH POINTERS AND LOOP

;NOW WRITE THE DESIRED STUFF INTO THE OPENED-UP AREA

MAKCH4:	HLL	T4,CHRPTR	;GET POINTER TO FIRST CHAR AFTER INSERT
	MOVEM	T4,NUMNUL	;SAVE IT FOR LATER
	MOVE	T4,CHRPTR	;POINT TO START OF INSERTED STUFF
	MOVE	T3,NUMCHR	;GET THE NUMBER OF CHARACTERS TO WRITE
	TLZE	F,WRH		;WANT TO READ FROM THE PICK OR CLOSE BUFFER?
	JRST	MAKPTP		;YES - HANDLE SEPARATELY
	MOVE	T1,CHARAC	;NO - GET THE CHARACTER TO PUT IN
	IDPB	T1,T4		;PUT THE CHARACTER IN
	SOJG	T3,.-1		;LOOP <NOCH> TIMES

;PAD OUT THE REMAINDER OF THE LAST WORD WITH NULLS; THEN RETURN

MAKPT1:	MOVEM	T4,MAKPTR	;SAVE POINTER TO LAST REAL THING ADDED
	SETZ	T1,		;GET A NULL
	CAMN	T4,NUMNUL	;REACHED GOOD STUFF?
	POPJ	P,		;YES - DONE
	IDPB	T1,T4		;NO - PUT THE NULL IN
	JRST	MAKPT1+2	;AND LOOP THROUGH THE DESIRED NUMBER

;HERE TO WRITE FROM THE PICK OR CLOSE BUFFER INTO THE OPENED-UP SPACE

MAKPTP:	SKIPN	PUTJFN		;WANT TO READ FROM DISK?
	JRST	MAKPT0+1	;NO - DON'T INITIALIZE
	PUSHJ	P,MAKPB0	;YES - INITIALIZE
MAKPT0:	PUSHJ	P,MAKPTB	;SET UP A PIECE IN THE BUFFER
	MOVE	PT,PUTPTR
MAKPPT:	ILDB	T1,PT		;GET CHARACTER FROM THE PICK BUFFER
	CAIN	T1,177		;WANT TO GET THE COUNTER?
	JRST	MAKPCT		;YES - GET IT
MAKPP0:	IDPB	T1,T4		;SAVE IT IN THE FILE BUFFER
	CAIN	T1,15		;<CR>?
	SOJG	T3,MAKPP1	;YES - SEE IF END OF LINE
	SOJG	T3,MAKPPT	;LOOP <NOCH> TIMES
	SKIPG	MAKCNT		;GOT MORE TO READ FROM BUFFER?
	JRST	MAKPT1		;NO - PUT ENDING NULLS IN, IF ANY
	JRST	MAKPT0		;YES - GET AND PUT IT

MAKPP1:	ILDB	T1,PT		;PICK UP LINEFEED
	CAIN	T1,12		;IS IT REALLY?
	AOS	MAKLNS		;YES - BUMP COUNT OF LINES FOUND
	JRST	MAKPP0		;CONTINUE

;SUBROUTINE TO WORK WITH THE INCREMENTING COUNTER

MAKPCT:	ILDB	T1,PT		;GET SECOND FLAG
	AOS	T1,COUNTS	;BUMP AND GET COUNTER
	CAIL	T1,^D99		;IS IT GOING TO OVEFLOW?
	SETOM	COUNTS		;YES - MAKE IT BE 0 NEXT TIME
	IDIVI	T1,^D10		;CONVERT TO DIGITS
	JUMPE	T1,.+2		;GET ASCII 10'S DIGIT ONLY IF NON-ZERO
	ADDI	T1,"0"
	IDPB	T1,T4		;OUTPUT 10'S (OR A NULL)
	MOVEI	T1,"0"(T2)	;GET ONE'S PLACE IN ASCII
	SOJA	T3,MAKPP0	;GO OUTPUT IT

;SUBROUTINE FOR WHEN READING FROM DISK: READ NEXT BUFFERFUL OF TEXT
;AND SET UP COUNTS. WHEN LAST BUFFERFUL HAS BEEN READ, CLOSE DISK FILE

MAKPB0:	MOVE	PT,PUTPTR	;SAVE POINTER TO THE PROPER BUFFER
	MOVEM	PT,PTMPTR
	MOVEM	T3,MAKCNT	;SAVE COUNT OF CHARACTERS TO ADD
TOPS10<	HRLI	PT,-PCBSIZ	;MAKE IOWD PCBSIZ,(PICK/CLOSE BUFFER)
	MOVEM	PT,PUTCCL
>
	POPJ	P,

MAKPTB:
TOPS20<	MOVE	T1,PUTJFN	;GET BUFFER JFN
>
	MOVE	T2,PTMPTR	;GET POINTER TO THE RIGHT BUFFER
	MOVEM	T2,PUTPTR	;SAVE IT
	MOVNI	T3,PCBSIZ*5	;DECREASE CHAR COUNT BY ONE BUFFERFUL
	ADDM	T3,MAKCNT	;UNLESS THERE'S NOT THAT MUCH OUT THERE
	SKIPGE	MAKCNT		;GOT SOMETHING LEFT FOR NEXT TIME?
	JRST	[SUB   T3,MAKCNT ;NO - READ ONLY A PARTIAL BUFFER
TOPS10<		 MOVE  T1,T3	;SET UP I/O WORDCOUNT FOR FINAL READ
		 IDIVI T1,5
		 SOJ   T1,
		 HRLM  T1,PUTCCL
>
		 SETZM MAKCNT	;CLEAR COUNT TO INDICATE FINISHED-NESS
		 SETZM PUTJFN	;CLEAR BUFFER JFN
		 JRST  .+1]
TOPS10<	INPUT	5,PUTCCL	;READ THE BUFFERFUL
>
TOPS20<	PUSH	P,T3
	SIN			;READ THE BUFFERFUL
	POP	P,T3
>
	MOVN	T3,T3		;MAKE COUNT POSITIVE
	SKIPE	PUTJFN		;TIME TO CLOSE THE BUFFER FILE?
	POPJ	P,		;NO - JUST PROCESS THE BUFFER
TOPS10<	RELEAS	5,		;YES
>
TOPS20<	CLOSF			;YES
	  HALTF
>
	POPJ	P,

;************************************************************************
;SUBROUTINES FOR WHEN THE USER WANTS TO DO SOMETHING IN THE MIDDLE OF A TAB
;CHANGE THE TAB TO SPACES,  RE-ADJUST CURSOR POSITION, AND DRIVE ON
;CALL WITH T1/POINTER TO THE TAB

RPLTAB:	SKIPN	TABSPC		;SITTING AT START OF TAB?
	POPJ	P,		;YES - DON'T BUST THE TAB THIS TIME
	MOVE	T1,TABSIZ	;ELSE GET SIZE OF TAB
	MOVEM	T1,NUMCHR	;SAVE AS NUMBER OF CHARACTERS TO MAKE
	SETZ	T1,		;NULL OUT THE TAB
	IDPB	T1,T2
	PUSHJ	P,MAKSPC	;ADD THOSE SPACES
	TLO	F,XPC
	JRST	MAKCPT		;RE-MAKE CURSOR POINTER AND RETURN

;************************************************************************
;PEEL ROUTINES - THESE CONVERT A PART OF THE PARAMETER BUFFER TO
;A NUMBER (PEEL.1), OR MOVE A FILE SPEC TO ITS OWN SPEC-IAL AREA (PELS.1)

;CAN ENTER IN ONE OF THREE SITUATIONS:
;ENTER, PARAMETER
;ENTER, NO PARAMETER		PARPTR UNCHANGED; GET TOKEN (OR SPECIAL)
;ENTER, CURSOR MOVE		CMV SET; TWO ARGS SET UP

;CAN RETURN IN ONE OF THREE SITUATIONS:
;NO ENTER TYPED			ENT FLAG IS NOT SET
;ENTER, BUT NO PARAMETER TYPED	ENT SET; T1/0
;ENTER AND PARAMETER TYPED	ENT SET; T1/NON-0

;SUBROUTINE TO READ A DECIMAL NUMBER FROM BUFFER. RETURN IS IN PARG1
;RETURNS T1/0 IF ARG NULL; ELSE -1

PEEL.1:	SETZB	T1,PARG2	;CLEAR ARG SET BY CURSOR MOVE
	TRNE	F,CMV		;WAS ARG DEFINED USING CURSOR MOVEMENT?
	JRST	PEEL.M		;YES - THAT'S A WHOLE NUTHER STORY
	MOVE	T4,[POINT 7,PARBUF]
	CAMN	T4,PARPTR	;ENTER-NO ARG TYPED?
	JRST	PEEL.C		;YES - MAY WANT TO COUNT UP A TOKEN
	IDPB	T1,PARPTR	;MAKE SURE PARAMETER ENDS WITH A NULL
	SETZB	T1,T3		;CLEAR FLAG AND RETURN VALUE

PEEL1:	ILDB	T2,T4		;GET A CHARACTER
	JUMPE	T2,PEEL3	;DONE IF NULL
	SETO	T1,		;ELSE INDICATE A NON-NULL PARAMETER
	SUBI	T2,60		;CONVERT TO OCTAL
	CAIL	T2,12		;IS IT REALLY A NUMBER?
	JRST	PGTERR		;NO - GIVE ERROR MESSAGE
	JUMPL	T2,PGTERR
	IMULI	T3,12		;YES - SHIFT TARGET
	ADD	T3,T2		;ADD IN NEW DIGIT
	JRST	PEEL1		;GET SOME MORE

PEEL3:	JUMPE	T1,CPOPJ	;IF NULL ARG FOUND, JUST RETURN
	MOVEM	T3,PARG1	;SAVE ARG
	POPJ	P,		;DONE

PGTERR:	MOVEI	T1,[ASCIZ /#####Argument must be numeric/]
	JRST	ERROR

;HERE IF ARGUMENT WAS MADE USING CURSOR MOVEMENT
;SET PARG1 TO ROWS MOVED AND PARG2 TO COLUMNS
;CALLER SHOULD RESTORE MARK AT (RW,CM), THEN GET (RW,CM) FROM (SAVPOS,+1)

PEEL.M:	DMOVEM	RW,SAVEAC	;SAVE ENDING POSITION
	SUB	RW,SAVPOS	;FIND DIFFERENCE IN ROW
	MOVMM	RW,PARG1	;SAVE MAGNITUDE OF DIFFERENCE
	JUMPGE	RW,[MOVE  RW,SAVPOS ;IF POSITIVE GO FROM STARTING POSITION
		    JRST  PEL.M1]   ;NOW CHECK COLUMN
	MOVE	RW,SAVEAC	;IF NEGATIVE GO FROM ENDING POSITION
	EXCH	RW,SAVPOS
	TLO	F,XPL!XPC	;RE-DO ROW AND COLUMN POINTERS
PEL.M1:	SUB	CM,SAVPOS+1	;FIND DIFFERENCE IN COLUMN
	CAIE	DO,"D"-100	;OPEN-
	CAIN	DO,"F"-100	;  OR CLOSE-LINES COMMAND?
	JRST	PEL.M3		;YES - HANDLE SPECIALLY
IFN NEWTAB,<
	CAIN	DO,"V"-100	;SAME WITH A PICK COMMAND
>
IFE NEWTAB,<
	CAIN	DO,"K"-100	;SAME WITH A PICK COMMAND
>
	JRST	PEL.M3		;YES - DON'T ADJUST COLUMN
	MOVMM	CM,PARG2	;SAVE MAGNITUDE OF DIFFERENCE
	JUMPL	CM,[MOVE CM,SAVEAC+1 ;IF NEGATIVE GO FROM ENDING POSITION
		    EXCH CM,SAVPOS+1
		    TLO	 F,XPC	     ;RE-DO COLUMN POINTER
		    JRST PEL.M2]     ;NOW FINISH OFF
	MOVE	CM,SAVPOS+1	;IF POSITIVE GO FROM STARTING POSITION
PEL.M2:	MOVE	T1,SAVCPT	;RE-SET ORIGINAL CHARACTER POINTER
	CAME	T1,CHRPTR	;HAS IT CHANGED ANY (W-WISE TABS)?
	TLO	F,XPL!XPC	;YES - RE-DO IT
	POPJ	P,		;AND LET CALLER WORRY ABOUT IT

PEL.M3:	MOVEM	CM,PARG2	;USE ACTUAL COLUMN DIFFERENCE
	JRST	PEL.M2-1	;CONTINUE

;SUBROUTINE TO COUNT THE SIZE OF THE CURRENT FILE TOKEN

PEEL.C:	CAIE	DO,"T"-100	;IS IT A ROLL LINES COMMAND?
	CAIN	DO,"W"-100
	POPJ	P,		;YES - SPECIAL NON-TOKEN CASE
	CAIE	DO,"P"-100	;IS IT A PERCENT COMMAND
	CAIN	DO,"X"-100	;  OR AN EXECUTE COMMAND?
	POPJ	P,		;YES - ANOTHER NON-TOKEN CASE
	PUSHJ	P,MAKCPT	;MAKE POINTER TO CURSOR LOCATION
	MOVE	PT,CHRPTR	;GET CURSOR POINTER
	SETZ	T2,		;CLEAR COUNT

PEL.C1:	ILDB	T1,PT		;GET CHARACTER FROM THE BUFFER
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIGE	T1,"0"		;TOO SMALL FOR A NUMBER?
	AOJA	T2,PEL.C3	;YES - END OF TOKEN
	CAIG	T1,"9"		;IS IT A NUMBER?
	AOJA	T2,PEL.C1	;YES - GOOD
	CAIGE	T1,"A"		;TOO SMALL FOR A UC LETTER?
	AOJA	T2,PEL.C3	;YES - END OF TOKEN
	CAIG	T1,"Z"		;IS IT A UC LETTER?
	AOJA	T2,PEL.C1	;YES - GOOD
	CAIL	T1,"a"		;TOO SMALL FOR A lc LETTER?
	CAILE	T1,"z"		;IS IT A lc LETTER?
	AOJA	T2,PEL.C3	;NOT LC - END OF TOKEN
	AOJA	T2,PEL.C1	;AND GET ANOTHER ONE

PEL.C3:	MOVEM	T2,PARG1	;SAVE SIZE OF TOKEN
	CAIN	DO,"K"-100	;DOING A PICK?
	SETZ	T1,		;YES - CLEAR GOT-AN-ARG FLAG
	POPJ	P,		;DONE

;SUBROUTINE TO PEEL OFF A STRING (FOR SEARCHES, SET-FILE, PUT)
;CALL WITH T3/ ASCII POINTER TO STRING SAVE AREA
;RETURNS T1/LENGTH OF STRING

PELS.1:	TRZE	F,CMV		;GOT A CURSOR MOVEMENT PARAMETER?
	JRST	PELS.M		;YES - HANDLE IT
	SETZ	T1,		;CLEAR GOT-AN-ARG FLAG
	MOVE	T4,[POINT 7,PARBUF]
	CAMN	T4,PARPTR	;ENTER-NO ARG TYPED?
	JRST	PEEL.T		;YES - MAY WANT TO PICK UP A TOKEN
	IDPB	T1,PARPTR	;MAKE SURE PARAMETER ENDS WITH A NULL
	ILDB	T2,T4		;GET THE FIRST CHARACTER
	JUMPN	T2,.+3		;IF NULL, JUST ENTER WAS TYPED
	POPJ	P,		;SO JUST RETURN

	ILDB	T2,T4		;GET A CHARACTER
	IDPB	T2,T3		;SAVE IT WHEREVER USER WANTS
	JUMPE	T2,CPOPJ	;DONE, IF NULL
	AOJA	T1,.-3		;ELSE COUNT CHARACTER AND LOOP

;HERE TO PEEL A CURSOR MOVEMENT STRING
;CALLER SHOULD RESTORE MARK AT (RW,CM), THEN GET (RW,CM) FROM (SAVPOS,+1)

PELS.M:	CAME	CM,SAVPOS+1	;ONLY LEGAL IF NOT ON THE SAME COLUMN,
	CAME	RW,SAVPOS	;  BUT ON THE SAME LINE - O.K.
	JRST	CMVERR		;NO - ILLEGAL
	PUSH	P,T3		;SAVE POINTER TO PLACE TO SAVE STRING
	MOVE	T1,CM		;YES - GET LENGTH OF STRING TO PICK UP
	SUB	T1,SAVPOS+1	;(MAKCPT PRESERVES ONLY T1)
	JUMPL	T1,.+2		;IS COUNT NEGATIVE?
	MOVE	CM,SAVPOS+1	;NO - GET ORIGINAL POSITION BACK
	TLO	F,XPC		;ALWAYS RE-DO CHARACTER POINTER
	PUSHJ	P,MAKCPT	;RE-DO IT, ALREADY
	POP	P,T3
	JUMPL	T1,[TLO  F,XPC	;YES - MAKE CHARACTER POINTER BE RE-DONE
		    MOVE CM,SAVPOS+1
		    JRST .+1]
	MOVM	T4,T1		;SET UP SIZE OF PICK
	MOVE	PT,CHRPTR	;GET THAT POINTER
	PUSHJ	P,SPCBUF	;PICK UP THE STRING FROM THE BUFFER
	MOVE	T1,SPCCNT	;GET COUNT OF CHARACTERS PICKED
	SETZ	T2,		;END ARGUMENT WITH A NULL
	IDPB	T2,T3
	POPJ	P,		;DONE

;SUBROUTINE TO PEEL OFF A TOKEN FROM THE FILE.
;THE TOKEN IS DEFINED AS EXTENDING FROM THE CURSOR LOCATION TO THE
;NEXT NON-ALPHANUMERIC CHARACTER
;TOKEN IS STORED AT AREA POINTED TO BY T3

PEEL.T:	CAIN	DO,"G"-100	;GOT A PUT COMMAND?
	POPJ	P,		;YES - DON'T READ TOKEN
	MOVEM	T3,PARPTR	;SAVE SAVE POINTER
	PUSHJ	P,MAKCPT	;MAKE POINTER TO CURSOR LOCATION
	MOVE	T3,[POINT 7,PARBUF]
	EXCH	T3,PARPTR	;RESTORE SAVE POINTER
	CAIN	DO,"B"-100	;IS COMMAND A SETFIL?
	JRST	PEEL.F		;YES - GET A FILESPEC-FLAVORED TOKEN
	MOVE	PT,CHRPTR	;GET CURSOR POINTER
	JRST	.+3

PEL.T1:	IDPB	T1,T3		;SAVE CHARACTER IN CALLER'S BUFFER
	IDPB	T1,PARPTR	;SAVE CHARACTER IN PARAMETER BUFFER
	ILDB	T1,PT		;GET CHARACTER FROM THE BUFFER
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIGE	T1,"0"		;TOO SMALL FOR A NUMBER?
	JRST	PEL.T3		;YES - END OF TOKEN
	CAIG	T1,"9"		;IS IT A NUMBER?
	JRST	PEL.T1		;YES - GOOD
	CAIGE	T1,"A"		;TOO SMALL FOR A UC LETTER?
	JRST	PEL.T3		;YES - END OF TOKEN
	CAIG	T1,"Z"		;IS IT A UC LETTER?
	JRST	PEL.T1		;YES - GOOD
	CAIL	T1,"a"		;TOO SMALL FOR A lc LETTER?
	CAILE	T1,"z"		;IS IT A lc LETTER?
	JRST	PEL.T3		;NOT LC - END OF TOKEN
	JRST	PEL.T1		;AND GET ANOTHER ONE

;SUBROUTINE TO PEEL OFF A FILESPEC STRING.
;CALL WITH T3/ ASCII POINTER TO STRING SAVE AREA
;RETURNS T1/LENGTH OF STRING

PELS.F:	TRZE	F,CMV		;GOT A CURSOR MOVEMENT PARAMETER?
	JRST	PELS.M		;YES - HANDLE IT
	TRZ	F,CRE		;ASSUME FILE IS NOT TO BE CREATED
	SETZB	T1,FILSPC	;CLEAR GOT-AN-ARG FLAG
TOPS10<	MOVE	T2,[FILSPC,,FILSPC+1]
	BLT	T2,FILSPC+6	;CLEAR OUT PREVIOUS FILE SPECS
>
	MOVE	T4,[POINT 7,PARBUF]
	CAMN	T4,PARPTR	;ENTER-NO ARG TYPED?
	JRST	PEEL.T		;YES - MAY WANT TO PICK UP A TOKEN
	IDPB	T1,PARPTR
	ILDB	T2,T4		;GET THE FIRST CHARACTER
	JUMPN	T2,PELSF1	;IF NULL, JUST ENTER WAS TYPED
	POPJ	P,		;SO JUST RETURN

PELSF0:	ILDB	T2,T4		;GET A CHARACTER
PELSF1:	CAIN	T2,"="		;WANT TO CREATE A FILE?
	JRST	[TRO  F,CRE	;YES - FLAG AS SUCH
		 JRST PELSF0]	;AND GET ANOTHER CHARACTER
	IDPB	T2,T3		;SAVE IT WHEREVER USER WANTS
	JUMPE	T2,CPOPJ	;DONE, IF NULL
	AOJA	T1,PELSF0	;ELSE COUNT CHARACTER AND LOOP

;SUBROUTINE TO PEEL OFF A FILESPEC TOKEN FROM THE FILE.
;TOKEN INCLUDES ALL LETTERS AND NUMBERS, PLUS ":.["
;IF "[" IS FOUND ONLY OCTAL NUMBERS AND ",]" ARE LEGAL
;OTHER CHARACTERS, OR MORE THAN 32 OF THESE, END THE TOKEN

PEEL.F:	MOVE	PT,CHRPTR	;GET CURSOR POINTER
	MOVEI	T0,40		;SAVE AT MOST 32 CHARACTERS
	JRST	.+3
PEL.F1:	IDPB	T1,T3		;SAVE CHARACTER IN CALLER'S BUFFER
	IDPB	T1,PARPTR	;SAVE CHARACTER IN PARAMETER BUFFER
	ILDB	T1,PT		;GET CHARACTER FROM THE BUFFER
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIL	T1,"a"		;LOWER CASE?
	SUBI	T1,40		;YES - CONVERT TO UPPER
	CAIE	T1,"."		;DOT,
	CAIN	T1,":"		;  OR COLON?
	JRST	PEL.F3		;YES - CONTINUE
	CAIN	T1,"["		;OPEN BRACKET?
	JRST	PEL.F2		;YES - CONTINUE IN PPN MODE
	CAIGE	T1,"0"		;NUMERIC?
	JRST	PEL.T3		;NO - END OF TOKEN
	CAIG	T1,"9"		;NUMERIC?
	JRST	PEL.F3		;YES - CONTINUE
	CAIGE	T1,"A"		;ALPHABETIC?
	JRST	PEL.T3		;NO - END OF TOKEN
	CAIG	T1,"Z"		;ALPHABETIC?
PEL.F3:	SOJG	T0,PEL.F1	;YES - CONTINUE

PEL.T3:	SETZ	T1,		;END BUFFER WITH A NULL
	IDPB	T1,T3
	IDPB	T1,PARPTR
	POPJ	P,		;DONE

PEL.F2:	IDPB	T1,T3		;SAVE CHARACTER IN CALLER'S BUFFER
	IDPB	T1,PARPTR	;SAVE CHARACTER IN PARAMETER BUFFER
	ILDB	T1,PT		;GET CHARACTER FROM THE BUFFER
	JUMPE	T1,.-1		;IGNORE IF NULL
	CAIN	T1,","		;COMMA?
	JRST	PEL.F4		;YES - CONTINUE
	CAIN	T1,"]"		;CLOSE BRACKET?
	JRST	PEL.F3		;YES - CONTINUE IN NON-PPN MODE
	CAIGE	T1,"0"		;NUMERIC?
	JRST	PEL.T3		;NO - END OF TOKEN
	CAIG	T1,"7"		;OCTAL NUMERIC?
PEL.F4:	SOJG	T0,PEL.F2	;YES - GO STORE CHARACTER
	JRST	PEL.T3		;BUT END IF COUNTED OUT

CMVERR:	SKIPA	T1,[[ASCIZ /######Stay on the same line/]]
CMXERR:	MOVEI	T1,[ASCIZ /###Can't mix characters and moves/]
	MOVE	RW,SAVPOS	;RESTORE SAVED POSITION
	MOVE	CM,SAVPOS+1
	JRST	ERROR

;SUBROUTINE TO PARSE THE FILE SPECS IN FILSPC INTO THE OPEN AND LOOKUP BLOCKS
;ALSO HANDLES SWITCHES. IF TOPS20, PARSEF HANDLES ONLY SWITCHES

PARSEF:	MOVEI	T1,UNPARS	;RETURN FROM HERE TO UNPARS
	PUSH	P,T1		;  AND FROM UNPARS TO CALLER
	MOVE	PT,[POINT 7,FILSPC]
TOPS10<	MOVEI	T1,16		;SET UP OPEN BLOCK
	MOVSI	T2,'DSK'	;  (MODE AND DEVICE)
	DMOVEM	T1,FILBLK
	SETZM	FILFIL+.RBPPN	;(NOTE: PATH STAYS THE SAME AS LAST TIME
	SETZM	FILFIL+.RBNAM	; UNTIL USER GIVES A PPN)
	SETZM	FILFIL+.RBEXT
	SETZM	FILFIL+.RBPRV
	SETZM	FILSBK		;TRY TO READ IN THE WHOLE FILE
	SETZM	FILPPN
	SETZM	FILSFD		;[JMS]
	SETZM	FILUNM+0	;[JMS]
	SETZM	FILUNM+1	;[JMS]

PARSF0:	MOVE	T4,[POINT 6,FILFIL+.RBNAM]
	MOVEI	T0,^D9		;SAVE AT MOST 9 CHARACTERS
PARSF1:	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,CPOPJ	;DONE, IF NULL
	CAIE	T1,11		;IGNORE TABS
	CAIN	T1," "		;  AND SPACES
	JRST	PARSF1
	CAIN	T1,":"		;END OF DEVICE?
	JRST	PARSED		;YES - GO SET DEVICE UP
	CAIN	T1,"."		;START OF EXTENSION?
	JRST	PARSEE		;YES - GO PARSE IT
	CAIN	T1,"["		;START OF PPN?
	JRST	PARSEP		;YES - GO PARSE IT
	CAIN	T1,"("		;[JMS] START OF TYMCOM-X directory?
	JRST	PARSEX		;[JMS] YES - GO PARSE IT
	CAIN	T1,"/"		;START OF SWITCHES?
	JRST	PARSES		;YES - GO HANDLE THEM
	CAIL	T1,"a"		;LOWER CASE?
	TRZA	T1,100		;YES - CONVERT TO SIXBIT
	SUBI	T1,40		;NO - CONVERT TO SIXBIT
	JUMPL	T1,PRSERR	;ERROR IF CHARACTER IS NOT ALPHANUMERIC
	CAIGE	T1,'0'
	JRST	PRSERR
	CAIG	T1,'9'
	JRST	PARSF2
	CAIL	T1,'A'
	CAILE	T1,'Z'
	JRST	PRSERR

PARSF2:	SOJL	T0,PARSF1	;IGNORE, IF GOT TOO MANY CHARACTERS
	IDPB	T1,T4		;ELSE SAVE IT
	JRST	PARSF1		;AND GET ANOTHER

PARSED:	MOVE	T1,FILFIL+.RBNAM;GET DEVICE NAME
	MOVEM	T1,FILBLK+1	;SAVE AS DEVICE
	SETZM	FILFIL+.RBNAM	;CLEAR FILE NAME
IFDEC<
	MOVEM	T1,FILPTH	;[CSM] Put device name in PATH. block
	MOVE	T1,[SFDS+4,,FILPTH]
	PATH.	T1,		;[CSM] Get the impled path for this device
	  SETZM	FILPPN		;[CSM] Cannot fail for disk devices
>  ;End IFDEC
	JRST	PARSF0		;GO GET FILE NAME AGAIN

PARSEE:	MOVE	T4,[POINT 6,FILFIL+.RBEXT]
	MOVEI	T0,3		;SAVE AT MOST 3 CHARACTERS
	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,CPOPJ	;DONE, IF NULL
	CAIE	T1,11		;IGNORE TABS
	CAIN	T1," "		;  AND SPACES
	JRST	PARSEE+2
	CAIN	T1,"["		;START OF PPN?
	JRST	PARSEP		;YES - GO PARSE IT
	CAIN	T1,"/"		;START OF SWITCHES?
	JRST	PARSES		;YES - GO HANDLE THEM
	CAIL	T1,"a"		;LOWER CASE?
	TRZA	T1,100		;YES - CONVERT TO SIXBIT
	SUBI	T1,40		;NO - CONVERT TO SIXBIT
	JUMPL	T1,PRSERR	;ERROR IF CHARACTER IS NOT ALPHANUMERIC
	CAIGE	T1,'0'
	JRST	PRSERR
	CAIG	T1,'9'
	JRST	PARSE2
	CAIL	T1,'A'
	CAILE	T1,'Z'
	JRST	PRSERR

PARSE2:	SOJL	T0,PARSEE+2	;IGNORE, IF GOT TOO MANY CHARACTERS
	IDPB	T1,T4		;SAVE CHARACTER
	JRST	PARSEE+2	;AND GET ANOTHER

PARSEP:	SETZ	T1,		;CLEAR TARGET
PARSP1:	ILDB	T2,PT		;GET CHARACTER OF PPN
	JUMPE	T2,PARSP3	;DONE IF NULL
	CAIN	T2,","		;END OF PROJECT NUMBER?
	JRST	PARSP2		;YES - SAVE IT AND GET PROG NUMBER
	CAIN	T2,"]"		;END OF PROGRAMMER NUMBER?
	JRST	PARSP3		;YES - SAVE IT AND QUIT
	CAIL	T2,"0"		;ERROR IF NOT OCTAL
	CAILE	T2,"7"
	JRST	PRSERR
	ROT	T2,-3		;ELSE SHIFT IT INTO TARGET
	LSHC	T1,3
	JRST	PARSP1		;AND GET SOME MORE

PARSP2:	TLOE	F,FLG		;IT THIS PROGRAMMER NUMBER?
	JRST	PARSSF		;YES - THERE'S AN SFD COMING
	JUMPE	T1,PARSEP	;NO - IF NOTHING THERE, DON'T SAVE
	HRLM	T1,FILPPN	;ELSE SAVE PROJECT NUMBER
	JRST	PARSEP		;AND GET PROGRAMMER NUMBER

PARSSF:	SETZ	T2,		;FINISH OFF PPN
	PUSHJ	P,PARSP3+1
	TLZ	F,FLG		;CLEAR PROJECT NUMBER FLAG
	SETZ	T1,		;CLEAR SFD LEVEL COUNTER
PARSS0:	MOVE	T4,[POINT 6,T3]
	MOVEI	T0,^D6		;SAVE AT MOST 6 CHARACTERS
	SETZ	T3,		;CLEAR TARGET OF SFD NAME
PARSS1:	ILDB	T2,PT		;GET CHARACTER OF SFD
	JUMPE	T2,PARSS3	;DONE IF NULL
	CAIN	T2,","		;START OF ANOTHER SFD LEVEL?
	AOJA	T1,PARSS2	;YES - SET UP FOR IT
	CAIN	T2,"]"		;END OF SFDS?
	JRST	PARSS3		;YES - SAVE IT AND QUIT
	CAIL	T2,"a"		;LOWER CASE?
	TRZA	T2,100		;YES - CONVERT TO SIXBIT
	SUBI	T2,40		;NO - CONVERT TO SIXBIT
	JUMPL	T2,PRSERR	;ERROR IF ILLEGAL SIXBIT
	CAILE	T2,77
	JRST	PRSERR
	IDPB	T2,T4		;O.K. - ADD TO SFD NAME
	SOJGE	T0,PARSS1	;AND GET SOME MORE
	JRST	PRSERR		;UNLESS COUNTED OUT

PARSS2:	JUMPE	T3,.+2		;USE OLD SFD NAME IF NONE GIVEN
	MOVEM	T3,FILSFD-1(T1)	;ELSE SAVE SFD NAME
	CAIGE	T1,SFDS	;DOWN TOO MANY SFD LEVELS?
	JRST	PARSS0		;NO - GO PARSE THE NEXT LEVEL
	MOVEI	T1,[ASCIZ /#########SFD level too deep/]
	JRST	STFERR		;YES - NO GOOD

PARSP3:	SETZM	FILSFD		;PATH ENDS WITH PPN
	JUMPE	T1,.+2		;IS PROGRAMMER NUMBER NON-0?
	HRRM	T1,FILPPN	;YES - SAVE IT
	JUMPN	T2,PARSF0	;IF NOT END, SEE WHAT ELSE AWAITS
	POPJ	P,		;ELSE DONE

PARSS3:	MOVEM	T3,FILSFD(T1)	;SAVE LATEST SFD NAME
	SETZM	FILSFD+1(T1)	;CLEAR WORD AFTER LAST SFD NAME
	JUMPN	T2,PARSF0	;IF NOT END, SEE WHAT ELSE AWAITS
	POPJ	P,		;ELSE DONE
PARSES:	MOVE	T2,PT		;PUT INPUT POINTER IN THE RIGHT AC
	SETZ	T1,		;NULL OUT THE FIRST SLASH
	DPB	T1,PT
	JRST	SWHMNY		;HANDLE THE SWITCHES AND RETURN

PARSEX:	MOVE	T4,[POINT 6,FILUNM]	;[JMS] Place to store user name
	MOVEI	T0,^D12		;SAVE AT MOST 6 CHARACTERS
PARSX1:	ILDB	T2,PT		;GET CHARACTER OF DIRECTORY
	CAIE	T2,0		;DONE IF NULL
	CAIN	T2,")"		;END OF DIRECTORY?
	 JRST	PARSX2		;YES - SAVE IT AND QUIT
	CAIL	T2,"a"		;LOWER CASE?
	TRZA	T2,100		;YES - CONVERT TO SIXBIT
	SUBI	T2,40		;NO - CONVERT TO SIXBIT
	JUMPL	T2,PRSERR	;ERROR IF ILLEGAL SIXBIT
	CAILE	T2,77
	JRST	PRSERR
	IDPB	T2,T4		;O.K. - ADD TO SFD NAME
	SOJGE	T0,PARSX1	;AND GET SOME MORE
	JRST	PRSERR		;UNLESS COUNTED OUT
PARSX2:	JUMPN	T2,PARSF0	;IF NOT END, SEE WHAT ELSE AWAITS
	POPJ	P,              ;[JMS]

PRSERR:	MOVEI	T1,[ASCIZ /###########Bad file specs/]
	JRST	STFERR		;OUTPUT THE ERROR AND CONTINUE
>  ;End TOPS10
TOPS20<
PARSF0:	ILDB	T1,PT		;GET A CHARACTER
	JUMPE	T1,CPOPJ	;DONE IF NULL
	CAIE	T1,"/"		;START OF SWITCHES?
	JRST	PARSF0		;NO - KEEP LOOKING
	MOVE	T2,PT		;YES - PUT INPUT POINTER IN THE RIGHT AC
	SETZ	T1,		;NULL OUT THE FIRST SLASH
	DPB	T1,PT
	JRST	SWHMNY		;HANDLE THE SWITCHES AND RETURN
>
;SUBROUTINE TO UNPARSE THE FILE SPEC BLOCKS INTO FILSPC
;POPJ'D TO FROM PARSEF

TOPS10<
UNPARS:	MOVE	PT,[POINT 7,FILSPC]
	MOVE	T2,FILBLK+1	;GET DEVICE
	CAMN	T2,[SIXBIT /DSK/] ;IS IT JUST DISK?
	 JRST	UNPRSF		;YES - SKIP IT
	PUSHJ	P,PUTSIX
	MOVEI	T1,":"
	IDPB	T1,PT

UNPRSF:	IFN FT$TYM,<	;Decode default directory name
	SKIPN	FILUNM		;Username specified?
	SKIPN	TYMCOM		;No, TYMCOM-X?
	 JRST	UNPRS1		;Don't bother
	SKIPN	T1,FILPPN	;Get PPN
	 MOVE	T1,FILFIL+.RBPPN
	HRROI	T2,.GTPPN	;Get connected PPN
	GETTAB	T2,
	  MOVE	T1,T2
	CAME	T1,T2		;Match?
	 JRST	UNPRS1		;No, give up
	HRROI	T2,.GTNM1	;Yes, get name belonging to this PPN
	GETTAB	T2,
	  MOVEI	T2,0
	MOVEM	T2,FILUNM
	HRROI	T2,.GTNM2	;Get 2nd half of user name
	GETTAB	T2,
	  MOVEI	T2,0
	MOVEM	T2,FILUNM+1
UNPRS1:	SKIPE	FILUNM		;[JMS] Username specified?
	 JRST	[SKIPE	FILSFD	  ;[JMS] Yes, output it if no SFDs
		  PUSHJ	P,UNPRSY  ;[JMS] Output username in parenthesis
		 JRST	.+1]	  ;[JMS]
>  ;End of IFN FT$TYM
	MOVE	T2,FILFIL+.RBNAM;SET UP FILE NAME
	PUSHJ	P,PUTSIX
	MOVEI	T1,"."
	IDPB	T1,PT
	HLLZ	T2,FILFIL+.RBEXT;SET UP EXTENSION
	PUSHJ	P,PUTSIX
	SKIPN	T1,FILPPN	;[JMS] GOT A PPN?
	 MOVE	T1,FILFIL+.RBPPN;[JMS] No, use LOOKUP block
	MOVEM	T1,FILPPN	;[JMS]
	JUMPE	T1,UNPRSX	;[JMS] NO - DON'T OUTPUT IT
	MOVEI	T1,"["		;START THE PPN
	IDPB	T1,PT

	SETO	T3,
	HLRZ	T1,FILPPN	;GET THE PROJECT
	SKIPA	T4,[","]	;GET SEPARATOR CHARACTER
UNPRSP:	HRRZ	T1,FILPPN	;GET THE PROGRAMMER
	MOVSI	T2,700000
	LSHC	T1,-3
	JUMPN	T1,.-1		;PUT NUMBER ALL IN T2
UNPSP1:	SETZ	T1,
	LSHC	T1,3		;GET A DIGIT IN T1
	JUMPE	T2,UNPSP2	;DONE IF NOTHING LEFT
	ADDI	T1,"0"
	IDPB	T1,PT
	JRST	UNPSP1

UNPSP2:	IDPB	T4,PT		;SAVE SEPARATOR OR END BRACKET
	MOVEI	T4,"]"		;GET THE END BRACKET
	AOJE	T3,UNPRSP	;IF DID PROJ, GO DO PROG
	SETZ	T3,		;CLEAR SFD INDEX
UNPSSF:	SKIPN	T2,FILSFD(T3)	;GOT AN(OTHER) SFD NAME?
	JRST	UNPRSX		;NO - FINISH OFF
	MOVEI	T1,","		;YES - CHANGE BRACKET TO A COMMA
	DPB	T1,PT
	PUSHJ	P,PUTSIX	;OUTPUT SIXBIT SFD NAME
	IDPB	T4,PT		;END WITH A RIGHT BRACKET
	AOJA	T3,UNPSSF	;GET NEXT LEVEL, IF ANY

UNPRSY:	MOVEI	T2,"("		;Output user name
	IDPB	T2,PT
	MOVEI	T3,^D12		;[JMS] Up to 12 characters
	MOVE	T4,[POINT 6,FILUNM]
UNPRY1:	ILDB	T2,T4		;Get a character
	JUMPE	T2,UNPRY2	;Stop at first blank
	ADDI	T2,40		;To ASCII
	IDPB	T2,PT
	SOJG	T3,UNPRY1	;Do 12
UNPRY2:	MOVEI	T2,")"
	IDPB	T2,PT
	POPJ	P,		;[JMS] End of UNPRSY

UNPRSX:	SETZ	T2,
	IDPB	T2,PT		;END WITH A NULL
	POPJ	P,		;AND RETURN

PUTSIX:	SETZ	T1,		;GET A SIXBIT CHARACTER
	LSHC	T1,6
	JUMPE	T1,CPOPJ	;DONE, IF NULL
	ADDI	T1,40		;ELSE CONVERT TO ASCII
	IDPB	T1,PT		;STORE CHARACTER
	JRST	PUTSIX		;AND LOOP
>
TOPS20<
UNPARS:	POPJ	P,
>
;************************************************************************
;INITIALIZING SUBROUTINES

;SUBROUTINE TO RESCAN USER'S RUN LINE TO SEE IF HE TYPED "R EDIT;FILESPECS"
;LOOKS FOR AN "E", SKIPS TO NEXT SPACE OR ";", ASSUMES THE REST IS SPECS
;MOVE SPACES TO PARM BUFFER AND SET FLAG SO THEY WILL BE PARSED

TOPS10<
RSCANL:	RESCAN			;GO TO START OF RUN LINE
	SETZM	RSCANF
RSCAN0:	INCHRS	T1		;IS THERE A CHARACTER WAITING?
	  POPJ	P,		;NO - DONE
	CAIN	T1,"E"		;BEGINNING OF EDITOR NAME?
	JRST	RSCAN1		;NO - KEEP LOOKING
	CAIE	T1,"e"		;BEGINNING OF EDITOR NAME?
	JRST	RSCAN0		;NO - KEEP LOOKING

RSCAN1:	INCHRS	T1		;YES - SKIP CHARACTERS
	  POPJ	P,		;UNTIL END OF LINE,
	CAIE	T1," "		;OR SPACE
	CAIN	T1,";"		;OR SEMICOLON IS FOUND
	JRST	RSCA1A
	JRST	RSCAN1		;ELSE KEEP SKIPPING

RSCA1A:	MOVE	T1,[POINT 7,CLSBUF] ;POINT TO START OF CLOSE BUFFER
	MOVEM	T1,PARPTR
	INCHRS	T1		;GET FIRST FILE CHARACTER
	  JRST	RSCAN3		;DONE IF NOTHING WAITING
	CAIN	T1," "		;SKIP ANY LEADING SPACES
	JRST	.-3
	CAIN	T1,15		;END OF LINE?
	JRST	RSCAN3		;YES - SET UP NO FILE
	SETOM	RSCANF		;NO - SET ENTER-PARAMETER FLAG
;	TLZ	F,SMF		;FILES AIN'T THE SAME, CAUSE THEY AIN'T NONE
	JRST	.+3		;GO SAVE THE FILE NAME

RSCAN2:	INCHRS	T1		;YES - SAVE FROM HERE ON AS A PARAMETER
	  JRST	RSCAN3		;DONE IF NOTHING LEFT
	CAIN	T1,15		;END OF LINE?
	JRST	RSCAN3		;YES - CLEAN BUFFER OUT AND RETURN
	IDPB	T1,PARPTR	;ELSE SAVE THE CHARACTER
	JRST	RSCAN2		;AND GET ANOTHER ONE

RSCAN3:	CLRBFI
	SETZ	T0,		;END BUFFER WITH A NULL
	IDPB	T0,PARPTR
>

TOPS20<
RSCANL:	SETZB	T1,RSCANF	;SET TO RE-READ RUN LINE
	RSCAN
	  POPJ	P,		;IF THERE'S A PROBLEM, FORGET IT
RSCAN0:	PBIN			;GET A CHARACTER
	CAIN	T1,12		;END OF LINE?
	POPJ	P,		;YES - RETURN
	CAIN	T1,"E"		;BEGINNING OF EDITOR NAME?
	JRST	RSCAN1		;YES - SKIP TO A SPACE
	CAIN	T1,"e"		;BEGINNING?
	JRST	RSCAN0		;NO - KEEP LOOKING

RSCAN1:	PBIN			;GET A CHARACTER
	CAIN	T1,12		;END OF LINE?
	POPJ	P,		;YES - RETURN
	CAIE	T1," "		;GOT A SPACE YET?
	JRST	RSCAN1		;NO - KEEP SKIPPING

	MOVE	T1,[POINT 7,CLSBUF]
	MOVEM	T1,PARPTR	;POINT TO START OF CLOSE BUFFER
RSCN1A:	PBIN			;GET A FILESPEC CHARACTER
	CAIN	T1,12		;END OF LINE?
	POPJ	P,		;YES - FINISH OFF
	CAIN	T1," "		;SKIP ANY LEADING SPACES
	JRST	RSCN1A
	SETOM	RSCANF		;SAY FILESPECS HAVE BEEN FOUND
	JRST	RSCN2A		;AND GO SET UP THE SPECS

RSCAN2:	PBIN			;GET A FILESPEC CHARACTER
	CAIN	T1,12		;END OF LINE?
	JRST	RSCAN3		;YES - FINISH OFF
RSCN2A:	IDPB	T1,PARPTR	;ELSE SAVE THE CHARACTER
	JRST	RSCAN2		;AND GET ANOTHER ONE

RSCAN3:	SETZ	T0,		;END BUFFER WITH A NULL
	IDPB	T0,PARPTR
>
	MOVE	T2,[POINT 7,CLSBUF] ;NOW LOOK OVER SPECS AGAIN
RSCAN4:	ILDB	T1,T2		;SEE IF THERE ARE ANY SWITCHES
	JUMPE	T1,CPOPJ	;IF END OF BUFFER, DONE
	CAIE	T1,"/"		;ELSE GOT START OF SWITCHES?
	JRST	RSCAN4		;NO - KEEP LOOKING
	DPB	T0,T2		;YES - NULL OUT THE FIRST SLASH
	JRST	SWHMNY		;GO HANDLE THE SWITCHES AND RETURN

;HERE ON ENTRY TO TRANSFER RESCANNED SPECS TO PARM BUFFER

SETSCN:	MOVE	T1,[POINT 7,PARBUF]
	MOVE	T2,[POINT 7,CLSBUF]
	ILDB	T0,T2		;GET A CHARACTER FROM THE CLOSE BUFFER
	JUMPE	T0,.+3		;STOP, IF NULL
	IDPB	T0,T1		;SAVE IT IN THE PARAMETER BUFFER
	JRST	.-3		;GET ANOTHER CHARACTER
	MOVEM	T1,PARPTR	;SAVE PARAMETER POINTER
	IDPB	T0,T1		;SAVE THE NULL IN THE PARAMETER BUFFER
	MOVEI	DO,2		;PRETEND A SET-FILE COMMAND WAS TYPED
	MOVE	T1,[FILSPC,,OLDSPC] ;COPY CURRENT SPECS INTO OLD SPECS
	BLT	T1,OLDSPC+13+11+4+SFDS
	JRST	SETFLC		;GO DO THAT SET-FILE

;HERE TO READ nnnSTT.TMP, IF ANY, AND SET UP THE FILE STATUS THERE
;IF NONE, SETS UP FOR THE DEFAULT "WELCOME TO E" MESSAGE

REDTMP:
TOPS10<		;[CSM] Try TMP:SED before DSK:000STT.TMP
	MOVEI	T1,-400		;[CSM] Set to MAX size
	HRLM	T1,STTCCL	;[CSM]  in IOWD
	MOVE	T1,[1,,STTCCL-1];[CSM] Code to read
	TMPCOR	T1,		;[CSM] Read TMP:SED
	  SKIPA			;[CSM] Not there, try disk
	 JRST   RDTMP1		;[CSM] Got it
>
	HRROI	T2,STTFIL
	PUSHJ	P,SETIN		;GO FIND THE TEMPORARY FILE
	JUMPE	T1,CPOPJ	;IF NONE, JUST RETURN
TOPS10<	HLRZS	T1		;READ ONLY FIRST TWO BLOCKS, IF FILE IS LARGE
	CAILE	T1,-400
	MOVEI	T1,-400
	HRLM	T1,STTCCL	;SET UP SIZE OF FILE
	INPUT	5,STTCCL	;READ STATUS INTO PICK BUFFER
	RELEAS	5,
RDTMP1:	>
TOPS20<	MOVE	T2,[POINT 7,PIKBUF+PCBSIZ-400]
	SETZ	T3,		;READ THE FILE INTO THE PICK BUFFER
	SIN
	CLOSF			;CLOSE THE FILE
	  HALTF
>
	SETZ	T2,
	MOVE	PT,[POINT 7,PIKBUF+PCBSIZ-400]
	MOVE	T4,[POINT 7,FILSPC]
	PUSHJ	P,TMPGET	;READ ACTIVE SPECS INTO ACTIVE AREA
	JUMPE	T1,REDTM1	;IS THERE ANOTHER LINE (WITH ALTERNATE SPECS)?
	MOVE	T4,[POINT 7,OLDSPC] ;YES - READ IT
	PUSHJ	P,TMPGT1	;READ ALTERNATE SPECS INTO OLD AREA
	CAIGE	T1,"0"		;IS THERE AN ALPHANUMERIC ON THE NEXT LINE?
	SETZM	MFLPTR		;NO - FORGET THE POINTER

REDTM1:	SETZM	DISPTR		;CLEAR POINTERS
	SETZM	SAVEDP		;  TO NOTE THAT PARSING MUST BE DONE
	TLO	F,XPL!XPC!XPB	;SAY NO POINTERS ARE VALID; FALL INTO:

;SUBROUTINE TO SEE IF FILE AND ALTERNATE ARE THE SAME
;SETS FLAG SMF IF FILES ARE THE SAME, ELSE CLEARS SMF

SAMFIL:	TLZ	F,SMF		;ASSUME FILES AREN'T THE SAME
	MOVE	T3,[POINT 7,FILSPC]
	MOVE	T4,[POINT 7,OLDSPC]
SAMFL1:	ILDB	T1,T3		;SEE IF BOTH FILE SPECS ARE THE SAME
	ILDB	T2,T4
	CAIN	T1,"/"		;TREAT START OF SWITCHES
	SETZ	T1,		;  LIKE END OF SPECS
	CAIN	T2,"/"
	SETZ	T2,
	CAME	T1,T2		;ARE THEY SO FAR?
	POPJ	P,		;NO - DONE
	JUMPN	T1,SAMFL1	;ELSE LOOP THROUGH ENTIRE STRING
	TLO	F,SMF		;FILES ARE THE SAME IF CONTROL GETS HERE
	POPJ	P,		;DONE

;SUBROUTINE TO READ FROM (PT) AND SAVE IN (T4). EXPECTS T2/0
;RETURNS FIRST CHARACTER OF NEXT LINE IN T1

TMPGET:	ILDB	T1,PT		;READ SPECS INTO ACTIVE OR ALTERNATE AREA
TMPGT1:	IDPB	T1,T4
	CAIE	T1,15
	 JUMPN	T1,TMPGET	;[CSM] Loop unless null
	DPB	T2,T4		;NULL OUT THE CARRIAGE RETURN
	ILDB	T1,PT		;SKIP OVER THE LINEFEED
	MOVEM	PT,MFLPTR	;SAVE POINTER TO (MAYBE) NEW SPECS
	ILDB	T1,PT		;PICK UP FIRST CHARACTER OF NEXT LINE
	POPJ	P,		;GIVE IT BACK TO CALLER
SUBTTL	TOPS-10 TTY I/O routines
TOPS10<	
;TTYINI - Initialize terminal to accept all control-characters on input

TTYINI:	OPEN	1,[EXP .IOPIM,'TTY   ',0]	;INIT terminal
	  HALT	.		;Must be able to use mode 2

	SETO	T2,		;Find terminal number
	TRMNO.	T2,
	  SETO	T2,		;-1 if TRMNO./TRMOP. not implemented
	MOVEM	T2,TTYNUM

	MOVEI	T1,.TOPBS+.TOSET;Change the PIM Break Set
	SETZ	T3,		;To break on all characters
	MOVE	T4,[XWD 3,T1]
	TRMOP.	T4,
	  JRST	TTXINI		;Error - TRMOP. does not work

	MOVEI	T1,.TOPAG+.TOSET;Change TTY PAGE bit
	MOVEI	T3,0		; to pass ^S and ^Q
	MOVE	T4,[XWD 3,T1]
	TLNN	TM,NPG		;Leave XON and XOFF alone?
	TRMOP.	T4,		;No, tell monitor to pass them to us
	  JFCL	
	POPJ	P,		;End of TOPS-10 TTYINI

IFDEC<	;Give up if .TOPBS fails
TTXINI:	OUTSTR	[ASCIZ	/?TRMOP. failed, cannot proceed/]
	HALT	TTXINI
>  ;End IFDEC

IFTYM<	;Use TYMCOM-X AUXCAL to set image mode, break on all
TTXINI:	HRROI	T1,.AXCFS	;Change port file sataus
	AUXCAL	T1,IO.NEC+.IOBIN;Set image-mode input (without timout)
	POPJ	P,		;End of TYMCOM-X TTYINI
>  ;End IFTYM

>  ;End of TOPS10
SUBTTL	TOPS-20 TTY I/O routines
TOPS20<	
;TTYINI - Initialize terminal to accept all control-characters on input

TTYINI:	MOVEI	T1,-1		;MAKE ALL CONTROL CHARACTERS GIVE THEIR CODE
	MOVE	T2,[525252,,525252]
	MOVE	T3,T2
	SFCOC

	MOVEI	T1,.PRIIN
	RFMOD			;READ MODE WORD
	MOVEM	T2,FMDSAV	;SAVE IT FOR EXIT
	TLZ	T2,37777	;SET PAGE LENGTH, WIDTH ZERO (NO FREE CRLFS)
	TRO	T2,300		;TURN ON NO-TRANSLATE-OUTPUT BITS
	TRZ	T2,4000		;MAKE NOTHING ECHO
	SFMOD
	STPAR

;SET UP SOFTWARE INTERRUPT SYSTEM
;SO MONITOR WON'T MESS AROUND WITH CERTAIN CHARACTERS

	MOVEI	T1,.FHSLF
	MOVE	T2,[LEVTAB,,CHNTAB]
	SIR
	EIR
	MOVE	T2,[370000,,5]
	AIC
	MOVE	T1,[.TICCM,,1]
	ATI
	MOVE	T1,[.TICCO,,2]
	ATI
	MOVE	T1,[.TICCQ,,3]
	ATI
	MOVE	T1,[.TICCS,,4]
	ATI
	MOVE	T1,[.TICCT,,5]
	ATI
;	MOVE	T1,[.TICCC,,40]
;	ATI
	MOVE	T1,[.TICRB,,41]
	ATI
	MOVE	T1,[.TICCI,,43]
	ATI
	POPJ	P,		;End of TTYINI
>  ;End of IFE TOPS10

;SUBROUTINE TO MOVE PRE-SET FILE STATUS INFORMATION INTO THE ACTIVE PLACES
;PNTSTT CAN BE CALLED TO SET UP POINTERS TO START OF FILE (PERCEN, NEWFIL)

PRESET:	HRRZ	T2,PREDP	;GET ADDRESS OF DISPLAY POINTER
	CAIL	T2,(EN)		;DOES IT POINT BEYOND END OF FILE?
	JRST	PNTSTT		;YES - POINT TO START OF FILE
	TLO	F,XPL!XPC!XPB	;NO - NO POINTERS ARE GOOD
	HRRZ	RW,PRERW	;GET PRE-SET ROW
	HLRZ	CM,PRERW	;AND COLUMN
	MOVE	SL,PRESL	;AND SLIDE
	SETZ	T2,		;GET AND ZERO DISPLAY POINTER
	EXCH	T2,PREDP
	MOVEM	T2,DISPTR
	POPJ	P,

PNTSTT:	MOVE	T2,[010700,,BUFFER-1]
	MOVEM	T2,DISPTR	;POINT TO START OF FILE
	MOVEM	T2,LINPTR
	MOVEM	T2,CHRPTR
	SETZB	RW,CM
	SETZ	SL,
	TLZ	F,XPC!XPL	;LINE AND CHARACTER POINTERS ARE O.K.
	TLO	F,XPB		;BUT BOTTOM POINTER IS BAD
	POPJ	P,

;****************************************************************
;SUBROUTINE TO READ SWITCH.INI AND SET UP THE SWITCHES THEREIN

REDSWH:	HRROI	T2,SWHFIL
	PUSHJ	P,SETIN		;SET FILE UP
	JUMPE	T1,CPOPJ	;JUST RETURN, IF NO SWITCH.INI
TOPS10<	HRRI	T1,PIKBUF-1
	MOVEM	T1,PIKCCL
	INPUT	5,PIKCCL	;O.K. - READ IT INTO PICK BUFFER
	RELEAS	5,
	MOVEI	T1,-PCBSIZ	;SET PROPER PICK SIZE BACK UP
	HRLM	T1,PIKCCL
>
TOPS20<	MOVE	T2,[POINT 7,PIKBUF]
	SETZ	T3,
	SIN			;READ THE FILE INTO THE PICK BUFFER
	CLOSF			;CLOSE THE FILE
	  HALTF
>
	MOVE	T2,[POINT 7,PIKBUF]
REDSW1:	PUSHJ	P,REDCHR	;GET 1ST CHARACTER OF A LINE
	JUMPE	T1,CPOPJ	;DONE IF NULL
	CAIN	T1," "		;IGNORE SPACES
	JRST	REDSW1
	CAIE	T1,"S"		;START OF "SED"?
	JRST	REDSWS		;NO - SKIP THE LINE
	PUSHJ	P,REDCHR	;YES - GET THE "E"
	CAIE	T1,"E"		;IS IT?
	JRST	REDSWS		;NO - SKIP THE LINE
	PUSHJ	P,REDCHR	;YES - GET THE "D"
	CAIE	T1,"D"		;IS IT?
	JRST	REDSWS		;NO - SKIP THE LINE

REDSW2:	ILDB	T1,T2		;YES - LOOK FOR THE "/"
	CAIN	T1,12		;AT END OF LINE?
	JRST	REDSW1		;YES - TRY OUT THE NEXT LINE
	CAIE	T1,"/"		;GOT A SLASH?
	JRST	REDSW2		;NO - KEEP LOOKING
	PUSHJ	P,SWHMNY	;YES - HANDLE ALL THE SWITCHES
	JRST	REDSW1		;SEE IS THERE'S ANOTHER LINE

REDSWS:	ILDB	T1,T2		;SKIP REST OF LINE
	CAIE	T1,12		;UNTIL LINEFEED
	JRST	REDSWS
	JRST	REDSW1		;THEN CHECK NEXT LINE

REDCHR:	ILDB	T1,T2		;GET NEXT CHARACTER
	CAIL	T1,"a"		;LOWER CASE?
	SUBI	T1,40		;YES - CONVERT TO UPPER
	POPJ	P,		;RETURN
SUBTTL	Terminal output routines

;TERMINAL DEPENDENT OUTPUT SECTION
;STORE VARIOUS CHARACTER SEQUENCES IN THE TYPE BUFFER

;NOTE: THE TWO CLEAR LINE ROUTINES ARE DISTINCT ONLY FOR THOSE
;TERMINALS WHICH MUST SIMULATE THE CLEAR BY OUTPUTTING SPACES.
;THEY SHOULD OUTPUT (T0) SPACES. T0 IS FRAGGED BY ALL OTHER ROUTINES

CBOTOM:	PUSHJ	P,CMVBTM	;MOVE TO BOTTOM LINE
				;AND FALL INTO CLEAR-IT CODE
CLRLNA:	TDOA	T0,[-1]		;SET TO CLEAR ENTIRE LINE
CLRLNR:	MOVE	T0,CM		;SET TO CLEAR TO END OF LINE
	SKIPA	T1,CLN(TM)	;CLEAR TO END OF LINE
CLEARP:	MOVE	T1,CPG(TM)	;CLEAR TO END OF PAGE
	JRST	PUTSEQ
PROTON:	SKIPA	T1,PON(TM)	;PROTECT ON
PROTOF:	MOVE	T1,POF(TM)	;PROTECT OFF
	JRST	PUTSEQ
CRIGHT:	SKIPA	T1,CRG(TM)	;CURSOR RIGHT
CLEFT:	MOVE	T1,CLF(TM)	;CURSOR LEFT
	JRST	PUTSEQ
CURUP:	SKIPA	T1,CUP(TM)	;CURSOR UP
CDOWN:	MOVE	T1,CDN(TM)	;CURSOR DOWN
	JRST	PUTSEQ
ROLLUP:	SKIPA	T1,RUP(TM)	;ROLL UP AND CLEAR LINE
ROLLDN:	MOVE	T1,RLD(TM)	;ROLL DOWN AND CLEAR LINE
	JRST	PUTSEQ
CLRALL:	MOVE	T1,HCP(TM)	;HOME AND CLEAR PAGE
	JRST	PUTSEQ
CHOME:	SKIPA	T1,CHM(TM)	;CURSOR HOME
CMVBTM:	MOVE	T1,MVB(TM)	;CURSOR TO BOTTOM

;SUBROUTINE TO DEAL WITH SEQUENCE/ROUTINE IN TERMINAL OUTPUT TABLE

PUTSEQ:	TLNN	T1,774000+37	;[CSM] Nothing but flag bits? (003740)
	JRST	@T1		;YES - DISPATCH TO THAT ROUTINE
PUTSQ1:	LSHC	T0,7		;SHIFT IN A CHARACTER
	IDPB	T0,TY		;SAVE IT IN TYPE BUFFER
	JUMPN	T1,PUTSQ1	;LOOP THROUGH ALL CHARACTERS
	POPJ	P,		;THEN DOWN

;SUBROUTINE TO OUTPUT A STRING. ADDRESS IN T1 (FRAGGED)

PUTSTG:	HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
PUTSG1:	ILDB	T0,T1		;GET A CHARACTER
	JUMPE	T0,CPOPJ	;DONE IF NULL
	IDPB	T0,TY		;ELSE SAVE IN TYPE BUFFER
	JRST	PUTSG1		;AND LOOP

;SUBROUTINE TO OUTPUT A STRING. ADDRESS IN T1 (FRAGGED). USES T0, T2
;SAME AS PUTSTG, BUT CONTROL CHARACTERS ARE SIMULATED BY BEING PROTECTED
;IF STRING BEING OUTPUT IS ALREADY PROTECTED ENTER PUTSTC; ELSE PUTSTS

PUTSTS:	TDZA	T2,T2		;CLEAR FLAG TO GET SIMULATION
PUTSTC:	SETO	T2,		;SET FLAG SO NO SIMULATION
	HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
PUTSC1:	ILDB	T0,T1		;GET A CHARACTER
	CAIGE	T0,40		;GOT A PRINTING CHARACTER?
	JRST	PUTSC2		;NO - SIMULATE IT
	CAIN	T0,177		;GOT THE COUNTER?
	JRST	PUTSCC		;YES - OUTPUT IT
	IDPB	T0,TY		;SAVE CHARACTER IN TYPE BUFFER
	JRST	PUTSC1		;AND LOOP

PUTSCC:	MOVEM	T1,SAVEAC	;SAVE BYTE POINTER
	MOVE	T0,COUNTS	;GET CURRENT COUNTER
	IDIVI	T0,^D10		;CONVERT TO DIGITS
	JUMPE	T0,.+3		;OUTPUT 10'S ONLY IF NON-ZERO
	ADDI	T0,"0"
	IDPB	T0,TY
	ADDI	T1,"0"		;1'S PLACE ALWAYS PRINTS
	IDPB	T1,TY
	MOVE	T1,SAVEAC	;GET BYTE POINTER BACK
	ILDB	T0,T1		;GET SECOND FLAG
	JRST	PUTSC1		;CONTINUE

PUTSC2:	JUMPE	T0,CPOPJ	;DONE, IF NULL
	PUSH	P,T1		;ELSE SAVE CHARACTER
	PUSH	P,T0
	JUMPN	T2,.+2		;WANT TO PROTECT?
	PUSHJ	P,PROTON	;YES - DO SO
	POP	P,T0
	ADDI	T0,100		;OUTPUT PRINTING CHARACTER
	IDPB	T0,TY
	JUMPN	T2,.+2		;WANT TO PROTECT
	PUSHJ	P,PROTOF	;YES - DO SO
	POP	P,T1
	JRST	PUTSC1		;CONTINUE

;SUBROUTINE TO OUTPUT AN ERROR MESSAGE (ADDRESS IN T1, FRAGGED)
;SAME AS PUTSTG, BUT #'S ARE CONVERTED TO SPACES

PUTSTX:	HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
	ILDB	T0,T1		;GET A CHARACTER
	JUMPE	T0,CPOPJ	;DONE IF NULL
	CAIN	T0,"#"		;ELSE GOT AN ARTIFICIAL SPACE?
	MOVEI	T0," "		;YES - MAKE IT A REAL ONE
	IDPB	T0,TY		;SAVE IN TYPE BUFFER
	JRST	PUTSTX+1	;AND LOOP

;SUBROUTINE TO OUTPUT FILESPECS (FOR THE SWITCH COMMAND)
;SAME AS PUTSTG, BUT OUTPUTS ONLY UNTIL FIRST "/"

PUTSTF:	HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
	ILDB	T0,T1		;GET A CHARACTER
	JUMPE	T0,CPOPJ	;DONE IF NULL
	CAIN	T0,"/"		;ELSE GOT START OF SWITCHES?
	POPJ	P,		;YES - DONE
	IDPB	T0,TY		;SAVE IN TYPE BUFFER
	JRST	PUTSTF+1	;AND LOOP

;SUBROUTINE TO OUTPUT THE TYPE BUFFER

PUTTYP:	TRNE	F,XCT		;EXECUTING?
	JRST	PUTTY1		;YES - THROW BUFFER AWAY
	CAMN	TY,[010700,,TYPBUF-1]
	POPJ	P,		;DO NOTHING IF NOTHING TO OUTPUT
	SETZ	T1,		;ELSE OUTPUT TYPE BUFFER:
	IDPB	T1,TY		;  END IT WITH A NULL
TOPS10<
IFDEC<	OUTSTR	TYPBUF	>	;OUTPUT THE BUFFER
IFTYM<  MOVE	TY,[POINT 7,TYPBUF]
PUTTY0:	ILDB	T1,TY
	JUMPE	T1,PUTTY1
	IONEOU	T1
	JRST	PUTTY0	>
>
TOPS20<	MOVEI	T1,TYPBUF
	PSOUT			;OUTPUT THE BUFFER
>
PUTTY1:	MOVE	TY,[010700,,TYPBUF-1]
	POPJ	P,		;RESTORE TYPE POINTER AND RETURN

;SUBROUTINE TO OUTPUT A DECIMAL NUMBER
;ENTER WITH NUMBER IN T1; USES T1, T2

PUTNUM:	IDIVI	T1,^D10		;GET A DIGIT IN T2
	HRLM	T2,(P)		;SAVE IT ON THE STACK
	JUMPE	T1,.+2		;IF ZERO, START POPPING
	PUSHJ	P,PUTNUM	;ELSE CALL RECURSIVELY
	HLRZ	T1,(P)		;GET A DIGIT OFF THE STACK
	ADDI	T1,"0"		;CONVERT TO ASCII
	IDPB	T1,TY		;PUT IT IN THE TYPE BUFFER
	POPJ	P,		;RETURN RECURSIVELY AND FINALLY

;************************************************************************
;SUBROUTINE TO OUTPUT THE FENCE (FNCCLR CLEARS TO END OF SCREEN)

FNCCLR:	PUSHJ	P,CLEARP	;CLEAR TO END OF SCREEN
FNCPUT:	MOVEI	T1,3(RW)	;GET ROW+3
	CAML	T1,LPP.1	;CLOSE TO THE BOTTOM OF THE SCREEN?
	JRST	PUTTYP		;YES - NO FENCE
	PUSHJ	P,CBOTOM	;MOVE TO BOTTOM OF SCREEN
	PUSHJ	P,PROTON	;TURN ON PROTECTION
	MOVEI	T1,FENCE	;OUTPUT THE FENCE
	PUSHJ	P,PUTSTG
	PUSHJ	P,PROTOF
	TLO	F,FNC		;SET FLAG TO SAY FENCE IS UP
	JRST	PUTTYP

;************************************************************************
;HERE TO REENTER EDITOR AFTER EXIT. RESTORES SAVED ACS AND FLIES

TOPS10<
REEERR:	MOVS	T1,[5,,SAVEAC]	;RESTORE ACS
	BLT	T1,P
	PUSHJ	P,TTYINI	;[JMS] Re-INIT terminal
	PUSHJ	P,@RTE(TM)	;[CSM] Set up terminal (enable keypad)
	MOVEI	T1,[ASCIZ /#########Re-entering editor/]
	JRST	ERROR		;(THIS IS IF USER TYPES ^C, REE)
>
;HERE TO CLEAR SCREEN, OUTPUT AN ERROR MESSAGE, REWRITE SCREEN, AND
;GO GET ANOTHER COMMAND. THE COMMAND THAT CAUSED THE ERROR IS IGNORED

;THIS ROUTINE CAN BE CALLED FROM ANY LEVEL SINCE IT RESETS THE P-D STACK

RDOERR:	MOVEI	T1,[ASCIZ /######File cannot be modified/]

ERROR:	TLOE	F,ERF		;JUST HAD AN ERROR?
	JRST	ERRORX		;YES - DON'T OUTPUT THIS ONE, THEN
	TRZN	F,XCT		;EXECUTING?
	TLZA	F,FLG		;NO - CLEAR XCT AND FLG
	TLO	F,FLG		;YES - CLEAR XCT AND SET FLG
	PUSHJ	P,ERRDSP	;ELSE DISPLAY THE ERROR MESSAGE
	TLNN	TM,SLW		;SLOW TERMINAL?
	PUSHJ	P,DISPLL	;NO - REWRITE THE SCREEN
	PUSHJ	P,RESTPM
ERRORX:	PUSHJ	P,POSCUR
	MOVE	P,[IOWD 20,STACK] ;CLEAN UP THE STACK
	TDZ	F,[FLG,,ENT]	;STOP DOING COMMANDS; CLEAR ENTER MODE
	JRST	INTEND		;AND GET ANOTHER COMMAND

;HERE TO HANDLE ERRORS FROM SETTING FILES. THEY ARE SPECIAL SINCE SED CAN'T
;JUST REDISPLAY THE SCREEN - THERE MIGHT NOT BE A FILE TO REDISPLAY
;ACTION: MOVE OLD SPECS BACK TO CURRENT; CLEAR OLD SPECS
;IF GTF DO A NORMAL ERROR, ELSE GET CURRENT FILE OR CHEERY MESSAGE

STFERR:
TOPS10<	MOVEI	T3,13+11+4+SFDS+2 >	;[CSM] Include .RBVER and .RBSPL
TOPS20<	MOVEI	T3,13 >		;GET OLD SPECS BACK AND CLEAR OLD SPECS
	MOVE	T2,OLDSPC(T3)
	SETZM	OLDSPC(T3)
	MOVEM	T2,FILSPC(T3)
	SOJGE	T3,.-3
TOPS10<	MOVEI	T2,7		;[CSM] Restore the length of the LOOKUP block
	MOVEM	T2,OLDFIL
	MOVEI	T2,2		;RESTORE THE PATH ACTION CODE
	MOVNM	T2,OLDPTH
	HLRZ	CM,SAVERW	;GET ROW AND COLUMN BACK
	HRRZ	RW,SAVERW
	MOVE	T2,SAVEDP	;GET DISPLAY POINTER
	MOVEM	T2,DISPTR
	MOVE	SL,SAVESL	;SET UP SLIDE
	TLO	F,XPC!XPL!XPB	;NO POINTERS ARE VALID
	SKIPE	PT,MFLPTR	;GOT ANOTHER SPEC IN STAT.TMP FILE?
	JRST	[PUSH  P,T1	;YES - SAVE ERROR MESSAGE
		 PUSHJ P,SETMFE	;READ NEW SPECS INTO OLDSPC
		 POP   P,T1	;GET ERROR MESSAGE BACK
		 JRST  .+1]	;AND CONTINUE
	TRNE	F,GFL		;GOT A FILE TO REDISPLAY?
	JRST	ERROR		;YES - OUTPUT THE ERROR NORMALLY
	PUSHJ	P,ERRDSP	;NO - OUTPUT THE MESSAGE
	SKIPN	FILSPC		;ARE THERE ANY OTHER FILESPECS?
	JRST	REDNO		;NO - GO SET UP CHEERY MESSAGE
	SKIPN	DISPTR		;YES - NEED TO PARSE SPECS?
	PUSHJ	P,PARSEF	;YES - DO SO
	JRST	SETFL1		;GO TRY THE OTHER FILE

;SUBROUTINE TO OUTPUT THE ERROR MESSAGE IN (T1)

ERRDSP:	PUSH	P,T1		;SAVE MESSAGE ADDRESS
	TLNE	TM,SLW		;GOT A SLOW TERMINAL?
	JRST	ERRDSW		;YES - OUTPUT ONLY ON FIRST LINE
	PUSHJ	P,CLRALL	;HOME AND CLEAR THE SCREEN
	MOVEI	T1,STARS	;PUT UP UPPER STARS
	PUSHJ	P,PUTSTG
	POP	P,T1
	PUSHJ	P,PUTSTX
	MOVEI	T1,STARS	;PUT UP LOWER STARS
	PUSHJ	P,PUTSTG
	PUSHJ	P,PUTTYP	;OUTPUT THE MESSAGE
	MOVEI	T1,^D1500	;WAIT A WHILE
TOPS10<	HRLI	T1,(HB.RTL)	;Wake on line of input (Control-C)
	HIBER	T1,
	  JFCL
>
TOPS20<	DISMS
>
	PUSHJ	P,DISTST	;[CSM] Process ^C at this time
	POPJ	P,		;DONE

;IF TERMINAL IS SLOW (SLW FLAG) PUT ERROR MESSAGE ON BOTTOM LINE

ERRDSW:	PUSHJ	P,CBOTOM	;GO TO BOTTOM LINE
	MOVEI	T1,7		;BEEP ONCE
	IDPB	T1,TY
	PUSHJ	P,PROTON	;TURN PROTECTION ON
	POP	P,T1		;RESTORE MESSAGE ADDRESS
	PUSHJ	P,PUTSTX	;OUTPUT MESSAGE
	PUSHJ	P,PROTOF	;TURN PROTECTION OFF AGAIN
	PUSHJ	P,PUTTYP	;OUTPUT THE MESSAGE
	TLZ	F,FBL		;BOTTOM LINE HAS BEEN FRAGGED
	TLO	F,ENT		;MAKE SURE MESSAGE IS ERASED
	MOVEI	T1,^D1000	;WAIT A WHILE
TOPS10<	HIBER	T1,
	  JFCL
>
TOPS20<	DISMS
>
	TLNN	F,FLG		;EXECUTING?
	POPJ	P,		;NO - DONE
	JRST	DISPLL		;YES - RE-DISPLAY THE SCEEEN

;************************************************************************
;TOPS10 INTERRUPT ROUTINE TO EXPAND CORE BY 1K

TOPS10<	GETAK:	PUSH	P,T1		;SAVE AN AC
	HRRZ	T1,.JBREL	;FIND CURRENT LIMIT
	ADDI	T1,1000		;PLUS ONE K
	CORE	T1,		;EXPAND
	  JRST	GAKERR		;OOPS (PROBABLY RAN OUT)
	POP	P,T1		;RESTORE AC
	JRST	2,@.JBTPC	;RETURN FROM THE INTERRUPT

;HERE ON A FATAL CORE GRAB, PROBABLY A ILL MEM REF
;IF THIS HAPPENS, IT'S A BUG, BUT JUST TRY TO ISOLATE IT

GAKERR:	MOVEI	T1,[ASCIZ /####Fatal error - save and exit/]
	PUSHJ	P,ERRDSP	;DISPLAY THE ERROR
	JRST	EEXIT		;SAVE FILE AND EXIT
>
SUBTTL	HISEG data

CMVTBL:	CDOWN		;CURSOR MOVE TABLE -
	CRIGHT		;  USED BY AJDONE TO MOVE CURSOR
	CURUP
	POSCUR

PTRTBL:	440700		;TABLE OF ASCII POINTER LH'S
	350700
	260700
	170700
	100700
	010700

;SWITCH DEFINITIONS AND DISPATCH ADDRESSES

SWCHES:
ASCII /TABS/		;TABS (ELSE WORD-TABS)		(ON   AT START)
ASCII /CASE/		;CASE-DEPENDENT SEARCHES	(ON)
ASCII /SLIDE/		;ENABLE SLIDING			(ON)
ASCII /LINEF/		;ENABLE LINEFEED COMMAND	(ON)
ASCII /UPPER/		;CONVERT TO UPPER CASE		(OFF)
ASCII /WRITE/		;FILE CAN BE WRITTEN		(ON)
ASCII /B/		;BACKUP, BEEP AND BLOCK		(ON, OFF)
ASCII /R/		;ROLL AND RESET			(ON, OFF)
ASCII /P/		;PAGES AND PROG              	(ON, COMPIL)
ASCII /FSTAT/		;FILE STATUS INFORMATION	(NONE)
ASCII /GOTO/		;PERCENT GOTO ON ENTRY, SETFIL	(NONE)
ASCII /DISTB/		;DISPLAY TABS AS PROTECTED I'S	(OFF)
ASCII /HELP/		;HELP IS DESIRED ON ENTER ENTER	(ON)
ASCII /ICR/		;CR IN INSERT MODE INSERTS LINE	(ON)
ASCII /Z/		;NAME OF TERMINAL TO RUN ON	(AS IMPLEMENTED)
ASCII /READO/		;[CSM] READONLY (=NOWRITE)
SWHNUM=.-SWCHES

SWHADR:	SWHTAB		;TAB AND BACKTAB TO START OF WORDS
	SWHCAS		;MATCH SEARCHES INDEPENDENTLY OF CASE
	SWHSLD		;DISABLE ^L AND ^U
	SWHLSD		;LINEFEED SAME AS CURSOR DOWN
	SWHUPP		;CONVERT ALPHABETICS TO UPPER CASE
	SWHWRT		;MARK FILE AS READ-ONLY
	SWHBBB		;BACK AND BEEP
	SWHRRR		;ROLL AND RESET
	SWHPPP		;PROGRAM TO RUN ON EXIT
	SWHSTT		;FILE STATUS INFORMATION SWITCHES
	SWHPRC		;PERCENT GOTO ON ENTRY
	SWHTBB		;DISPLAY TABS AS PROTECTED I'S AND SPACES
	SWHHLP		;HELP IS DESIRED
	SWHICR		;CR DURING INSERT MODE
	SWHTRM		;NAME OF TERMINAL TO RUN ON
	SWHRDO		;[CSM] READONLY
SUBTTL	Command dispatch table

CMDTBL:	RESET,,RESNPM	;	RESET (LOOKS LIKE A NULL)
	OPENSP,,OPSNPM	; A	OPEN SPACES
	SETFIL,,SETNPM	; B	SET UP A FILE FOR EDITING
	ABORT,,ABORT	; C NO? ABORT
	OPENLN,,OPENLN	; D	OPEN LINES
	SRCBAK,,SRBNPM	; E	SEARCH BACKWARD
	CLOSLN,,CLOSLN	; F	CLOSE LINES
	PUT,,PUT	; G	PUT
	LFTARG,,LEFT	; H	CURSOR LEFT
	TABARG,,TAB	; I NO	TAB
	LNFPAR,,LNFEED	; J	LINEFEED
IFN NEWTAB,<
	SLIDEL,,SLLNPM	; K	SLIDE LEFT
	SLIDER,,SLRNPM	; L	SLIDE RIGHT
	RETARG,,RETURN	; M NO	CARRIAGE RETURN
	SWITCH,,SWHNPM	; N	SET SWITCHES
>
IFE NEWTAB,<
	PICK,,PIKNPM	; K	PICK
	SLIDEL,,SLLNPM	; L	SLIDE LEFT
	RETARG,,RETURN	; M NO	CARRIAGE RETURN
	BTBARG,,BAKTAB	; N	BACK-TAB
>
	ENTCCH,,ENTCCH	; O NO	ENTER CONTROL CHARACTER
	PERCEN,,PERNPM	; P	PERCENT GOTO
	ROLBKP,,RBKNPM	; Q NO	ROLL BACK PAGES
	SRCFWD,,SRFNPM	; R	SEARCH FORWARD
	CLOSSP,,CLOSSP	; S NO	CLOSE SPACES
	ROLFWL,,RFLNPM	; T NO	ROLL FORWARD LINES
IFN NEWTAB,<
	BTBARG,,BAKTAB	; U	BACK-TAB
	PICK,,PIKNPM	; V	PICK
>
IFE NEWTAB,<
	SLIDER,,SLRNPM	; U	SLIDE RIGHT
	SWITCH,,SWHNPM	; V	SET SWITCHES
>
	ROLBKL,,ROLBKL	; W	ROLL BACK LINES
	EXECUT,,EXCNPM	; X	DO COMMAND SEQUENCE
	ROLFWP,,RFPNPM	; Y	ROLL FORWARD PAGES
	EXIPAR,,EEXIT	; Z	NORMAL EXIT
	ENTERA,,ENTERA	; $	ENTER PARAMS
	DWNARG,,DOWN	; \	CURSOR DOWN
	RGTARG,,RIGHT	; ]	CURSOR RIGHT
	UPARG,,UP	; ^	CURSOR UP
	HOMARG,,HOME	; _	HOME
	0,,RECALL	;40	RECALL (MUST BE TERMINAL-DEFINED)
	0,,INSMOD	;41	INSERT MODE (MUST BE TERMINAL-DEFINED)
	LFTARG,,DELCHR	;42	DELETE CHAR (MUST BE TERMINAL-DEFINED)
	REALTB,,REALTB	;43	TYPE A REAL TAB (SAME AS E-C-C I)
	0,,MARK		;44	MARK POSITION FOR PICK AND CLOSE
	COUNTR,,CNTNPM	;45	USE OR SET INCREMENTING COUNTER
CMDLEN=.-CMDTBL

;COMMAND NAMES (FOR EXECUTE, MAINLY)

DEFINE	X(ARG),<IFIDN <ARG>,<$>,<ASCII /ARG/;>	ASCII	/^ARG/>

CMDNAM:	CMDS

FENCE:	ASCII	/   *** This FENCE marks the last page of the file /
	ASCIZ	/but is NOT a part of it ***  /
STARS:	ASCIZ /

            ************************************

            /
LITS:	XLIST           ;LIT
	LIT
	LIST		;DUMP THE LITERALS IN THE HISEG
SUBTTL	LOWSEG data
	RELOC	0	;*** LOWSEG STARTS HERE ***

;SOFTWARE INTERRUPT TABLES

TOPS20<
LEVTAB:	0		;LEVEL TABLE
	PC2
	0
PC2:	Z

CHNTAB:	0
	2,,CTRLM	;CHANNEL 1 HAS CTRL-M
	2,,CTRLO	;CHANNEL 2 HAS CTRL-O
	2,,CTRLQ	;CHANNEL 3 HAS CTRL-Q
	2,,CTRLS	;CHANNEL 4 HAS CTRL-S
	2,,CTRLT	;CHANNEL 5 HAS CTRL-T
	BLOCK	33
	2,,RUBOUT	;CHANNEL 33 HAS RUBOUT
	0
	2,,CTRLI	;CHANNEL 35 HAS CTRL-I
>

;NOMINAL ARGUMENTS TO COMMANDS

STACK:	BLOCK	20

ADDSPC:	BLOCK	1	;SPACES TO ADD OR DELETE (OPENSP, CLOSSP)
ADDSPS:	BLOCK	1	;DITTO, FRAGGABLE	 (OPENSP, CLOSSP)
ADDSLN:	BLOCK	1	;NUMBER OF LINES TO DO A RECTANGULAR OPEN/CLOSE TO
ADDLNS:	BLOCK	1	;LINES TO ADD OR DELETE (OPENLN, CLOSLN)
ADDLSP:	BLOCK	1	;SPACES TO ADD OR DELETE ALONG WITH LINES
ROLLIN:	BLOCK	1	;LINES TO ROLL (ROLFWL, ROLBKL)
ROLPGS:	BLOCK	1	;PAGES TO ROLL (ROLFWP, ROLBKP)
ROLLS:	BLOCK	1	;HOLDS ROLLIN OR LPP*ROLPGS, FOR ROLBK & ROLFW
GOPERC:	BLOCK	1	;PERCENT TO GO TO (PERCEN)
GOPRCT:	BLOCK	1	;PERCENT GOTO SET UP BY SWITCH
SRCPTR:	BLOCK	1	;SAVED BUFFER POINTER FOR SEARCHES
SRCKEY:	BLOCK	10	;SEARCH KEY (SRCFWD, SRCBAK)
PICKLN:	BLOCK	1	;NUMBER OF LINES TO PICK (PICK)
PICKSP:	BLOCK	1	;NUMBER OF SPACES TO PICK (PICK, WITH CURSOR MOVE)
SLIDES:	BLOCK	1	;LENGTH OF ONE SLIDE (SLIDEL, SLIDER)
XCTNUM:	BLOCK	1	;CURRENT # OF TIMES TO ITERATE EXECUTE BUFFER (EXECUT)
XCTITR:	BLOCK	1	;NOMINAL # OF TIMES TO ITERATE EXECUTE BUFFER (EXECUT)
XCTPTW:	BLOCK	1	;USED ACTIVE EXECUTE BUFFER POINTER (WRITING)
XCTACW:	BLOCK	1	;STARTING ACTIVE EXECUTE BUFFER POINTER (WRITING)
XCTPTR:	BLOCK	1	;USED ACTIVE EXECUTE BUFFER POINTER (READING)
XCTACR:	BLOCK	1	;STARTING ACTIVE EXECUTE BUFFER POINTER (READING)
XCTISV:	BLOCK	1	;SAVED # OF ITERATIONS (EXECUT, STACKED)
XCTNSV:	BLOCK	1	;SAVED NOMINAL ITERATIONS (EXECUT, STACKED)
XCTPSV:	BLOCK	1	;SAVED EXECUTE BUFFER READ POINTER
XCTASV:	BLOCK	1	;SAVED STARTING EXECUTE BUFFER READ POINTER
XCTRPT:	BLOCK	1	;NUMBER OF TIMES TO REPEAT THIS EXECUTE COMMAND
XCTRPR:	BLOCK	1	;POINTER TO COMMAND TO REPEAT
PRERW:	BLOCK	1	;PRE-SET ROW AND COLUMN
PRESL:	BLOCK	1	;PRE-SET SLIDE
PREDP:	BLOCK	1	;PRE-SET DISPLAY POINTER
PREONE:	BLOCK	1	;PRE-SET ONE-SHOT POINTER
COUNTS:	BLOCK	1	;INCREMENTING COUNTER

NEWMSG:	ASCII	/; This file is /	;THIS IS 3 WORDS LONG
TOPS20<
FILSPC:	BLOCK	14	;FILE SPECS (SETFIL)
>
TOPS10<
FILSPC:	BLOCK	13	;FILE SPECS (SETFIL)
	BYTE (7) 15,12
FILBLK:	BLOCK	3
FILFIL:	7		;[CSM] Extended LOOKUP block for current file
	BLOCK	7	;[CSM] Preserve version number and spooling name
  SFDS==5
FILPTH:	-2		;PATH OF CURRENT FILE
	0
FILPPN:	BLOCK	1	;FILE'S PPN
FILSFD:	BLOCK	SFDS
FILUNM=.-2		;[JMS] TYMCOM-X user name specification
>  ;End of TOPS10
FILSIZ:	BLOCK	1	;SIZE OF FILE, IN BYTES
FILBSZ:	BLOCK	1	;SIZE OF FILE, IN BLOCKS
INJFN:	BLOCK	1	;JFN FOR THE FILE
OLDSPC:	BLOCK	14	;OLD FILE SPECS, FROM LAST SETFIL
TOPS10<
OLDBLK:	BLOCK	3	;OPEN BLOCK FOR ALTERNATE FILE
OLDFIL:	7		;[CSM] Extended LOOKUP block for ditto
	BLOCK	7	;[CSM] Include .RBVER and .RBSPL
OLDPTH:	-2		;PATH OF DITTO
	BLOCK	SFDS+3
>
TYMCOM:	BLOCK	1	;Zero for TOPS-10, nonzero for TYMCOM-X
SAVERW:	BLOCK	1	;OLD ROW AND COLUMN ACS
SAVEDP:	BLOCK	1	;OLD DISPLAY POINTER
SAVESL:	BLOCK	1	;OLD SLIDE OFFSET

GOBLK:	SIXBIT	/SYS/	;RUN BLOCK FOR EXIT AND GO
	SIXBIT	/COMPIL/
	EXP	0,0,0,0
TOPS10<
DEFPTH:	-1		;RUNNER'S STARTING PATH
	BLOCK	SFDS+3
USRPPN:	BLOCK	1	;PPN OF RUNNER OF EDITOR
GENBLK:	16		;GENERAL OPEN BLOCK
	SIXBIT	/DSK/
	0
FILCCL:	IOWD	0,BUFFER	;CHANNEL COMMAND FOR INPUTTING EDITABLE FILE
	0
PIKFIL:	SIXBIT	/000PIK/	;FILE BLOCK FOR PICK FILE
	SIXBIT	/TMP/
	EXP	0,0
PIKCCL:	IOWD	PCBSIZ,PIKBUF	;CHANNEL COMMAND FOR PICK BUFFER
	0
CLSFIL:	SIXBIT	/000CLS/	;FILE BLOCK FOR CLOSE FILE
	SIXBIT	/TMP/
	EXP	0,0
CLSCCL:	IOWD	PCBSIZ,CLSBUF	;CHANNEL COMMAND FOR CLOSE BUFFER
	0
STTFIL:	SIXBIT	/000STT/	;FILE BLOCK FOR STATISTICS FILE
	SIXBIT	/TMP/
	EXP	0,0
	SIXBIT	/SED/		;[CSM] Name of TMPCOR file, at STTCCL-1
STTCCL:	IOWD	1,PIKBUF+PCBSIZ-400
	0			;CHANNEL COMMAND FOR STATISTICS FILE
DELFIL:	BLOCK	4		;FILE BLOCK FOR DELETING
BAKFIL:	BLOCK	4		;FILE BLOCK FOR RENAMING BACKUP FILE
NEWCCL:	IOWD	13,NEWMSG	;CHANNEL COMMAND FOR NEW FILE
	0
PUTCCL:	BLOCK	2		;CHANNEL COMMAND FOR PICK OR CLOSE BUFFER
SWHFIL:	SIXBIT	/SWITCH/	;FILE BLOCK FOR SWITCH.INI
	SIXBIT	/INI/
	EXP	0,0
EXTTBL:	SIXBIT	/MACTXT/	;EXTENSIONS TO BE TRIED IN SETFIL
	SIXBIT	/RNOFOR/
	SIXBIT	/DAT000/
REDACC:	BLOCK	3		;CHKACC BLOCKS FOR READING
WRTACC:	BLOCK	3		;  AND WRITING
HLPFIL:	SIXBIT	/SEDONL/	;FILE BLOCK FOR SWITCH.INI
	SIXBIT	/HLP/
	EXP	0,0
HLPCCL:	IOWD	200,PIKBUF+PCBSIZ-200 ;CHANNEL COMMAND FOR HELP FILE
	0
TTYNUM:	BLOCK	1		;TRMNO.
>  ;End of TOPS10
TOPS20<
PIKFIL:	ASCIZ	/000PIK.TMP/
CLSFIL:	ASCIZ	/000CLS.TMP/
STTFIL:	ASCIZ	/000STT.TMP/
SWHFIL:	ASCIZ	/SWITCH.INI/
HLPFIL:	ASCIZ	/HLP:SEDONL.HLP/
>
;GENERAL DATA

SAVEAC:	BLOCK	13	;PLACE TO SAVE ACS ON EXIT, IN CASE OF REE
LPP.1:	BLOCK	1	;LINES PER PAGE - 1
LPP.2:	BLOCK	1	;NUMBER OF BOTTOM LINE (NEXT TO BOTTOM IF NEL SET)
CPL.1:	BLOCK	1	;CHARACTERS PER LINE - 1
LPR:	BLOCK	1	;LINES PER ROLL
CHRCUR:	BLOCK	1	;CHARACTER AT THE CURSOR POSITION, BLIPPED
SAVPOS:	BLOCK	2	;CURSOR POSITION SAVED ON ENTER
SVPMRK:	BLOCK	2	;CURSOR POSITION SAVED WHEN MARK COMMAND IS TYPED
TYPCHR:	BLOCK	1	;CHARACTER TYPED USER DURING A DISPLAY
WRTNUM:	BLOCK	1	;NUMBER OF CHARACTERS TO NULL OUT (WRTNUL)
NUMCHR:	BLOCK	1	;NUMBER OF CHARACTERS TO DEAL WITH (MAKSPC, &C)
NUMWDS:	BLOCK	1	;NUMBER OF WORDS TO DEAL WITH (MAKSPC, &C)
NUMNUL:	BLOCK	1	;NUMBER OF EXTRA NULLS PUT IN
CHARAC:	BLOCK	1	;CHARACTER TO DEAL WITH (IN MAKSPC, &C)
MAKPTR:	BLOCK	1	;POINTER TO LAST REAL CHAR ADDED BY MAKSPC &C.
TABLEN:	10		;LENGTH OF AN ENTIRE TAB
TABSIZ:	BLOCK	1	;LENGTH OF TAB THAT CURSOR POINTS TO
TABSPC:	BLOCK	1	;NUMBER OF SPACES TO LEFT OF CURSOR, IF IT'S IN A TAB
TABPTR:	BLOCK	1	;POINTER TO TAB, IN FILE BUFFER
SPCCNT:	BLOCK	1	;COUNT OF CHARACTERS MOVED BY SPCBUF
SQZCNT:	BLOCK	1	;COUNT OF COMMANDS REMAINING UNTIL NEXT SQUEZW
DISPPT:	BLOCK	1	;POINTER TO LAST LINE; SET BY DISPLL
MAKLNS:	BLOCK	1	;NUMBER OF <CRLF>S IN PICK OF CLOSE BUFFER
RSCANF:	BLOCK	1	;FLAG - SET IF USER GAVE A FILE IN THE RUN COMMAND
SAVCPT:	BLOCK	1	;CHRPTR SAVED WHEN ENTER IS TYPED
MRKPTR:	BLOCK	1	;MARK POINTER, FOR PICK AND CLOSE-LINES
MFLPTR:	BLOCK	1	;POINTER TO START OF NEXT FILE IN nnnSTT.TMP
;MFLBLK:	BLOCK	1	;BLOCK OF nnnSTT.TMP WHICH POINTER IS IN
TOPS20<
FMDSAV:	BLOCK	1	;SAVED FMOD BITS (TOPS20)
>
;SWITCH FLAG WORDS

SLDFLG:	BLOCK	1	;0 == DISABLE ^L AND ^U
UPPFLG:	BLOCK	1	;0 == CONVERT ALPHABETICS TO UPPER CASE
BAKFLG:	BLOCK	1	;0 == NO BACKUP FILE WILL BE WRITTEN
PAGFLG:	BLOCK	1	;0 == SWITCH OUTPUTS PAGES-LINES; ELSE LINES
TRMNAM:	BLOCK	1	;NAME OF TERMINAL GIVEN BY USER
FILSBK:	BLOCK	1	;AMOUNT OF FILE TO READ IN (IN BLOCKS)

;VARIOUS BUFFERS

PUTPTR:	BLOCK	1	;POINTER, FOR MAKSPC, TO CLOSE OR PICK BUFFER
PTMPTR:	BLOCK	1	;COPY OF ABOVE SET UP BY MAKSPC
MAKCNT:	BLOCK	1	;COUNT OF CHARACTERS TO INSERT, FOR MAKSPC
PUTJFN:	BLOCK	1	;JFN OF PICK OR CLOSE BUFFER, FROM PUT TO MAKSPC
PIKCNT:	BLOCK	1	;COUNT OF CHARACTERS IN THE PICK BUFFER
PIKJFN:	BLOCK	1	;JFN FOR PICK FILE ON DISK (GENERATED ON OVERFLOW)
PIKBUF:	BLOCK	PCBSIZ	;PICK BUFFER (PICK, PUT)
	BLOCK	1	;ZERO AT THE END OF PICK BUFFER
CLSCNT:	BLOCK	1	;COUNT OF CHARACTERS IN THE CLOSE BUFFER
CLSJFN:	BLOCK	1	;JFN FOR CLOSE FILE ON DISK (GENERATED ON OVERFLOW)
CLSBUF:	BLOCK	PCBSIZ	;CLOSE BUFFER (CLOSELN, PUT)
	BLOCK	1	;ZERO AT THE END OF CLOSE BUFFER

TYPBUF:	BLOCK	TYPSIZ	;BUFFER FOR OUTPUTTING TO TERMINAL
	BLOCK	10	;OVERFLOW FOR TYPE BUFFER

DEFINE XBFADR(X..X),<
	010700,,XCTBF'X..X-1
>
DEFINE XBFBUF(X..X),<
XCTBF'X..X:  BLOCK XBFSIZ
>
DEFINE XCTDEF,<		;(SAVE SOME CREF OUTPUT)
XCTNAM:	<ASCII /SUB/>+1	;PRE-SET SUBSTITUTE SEQUENCE
	BLOCK	XBFNUM-2
	1		;NO-NAME BUFFER
XCTADR:			;POINTERS TO EXECUTE BUFFERS
	X.X=-1
REPEAT XBFNUM,<
	X.X=X.X+1
	XBFADR(\X.X)
>

XCTBF0:	BYTE (7) 22,23,7 ;PUT [SEARCH, CLOSE, PUT] IN 1ST BUFFER
	BLOCK	XBFSIZ-1
	X.X=0		;SET UP ALL BUT ONE BUFFER
REPEAT XBFNUM-1,<
	X.X=X.X+1
	XBFBUF(\X.X)
>>
	XLIST
	XCTDEF
	LIST

PARPTR:	BLOCK	1	;POINTER INTO PARAMETER BUFFER
PARBUF:	BLOCK	20	;PARAMETER BUFFER
PARG1:	BLOCK	1	;STORAGE AREAS FOR CONVERTED PARAMETERS
PARG2:	BLOCK	1

LINPTR:	BLOCK	1	;POINTER TO START OF LINE
CHRPTR:	BLOCK	1	;POINTER TO CHARACTER AT CURSOR
DISPTR:	BLOCK	1	;POINTER TO FIRST CHARACTER DISPLAYED
BOTPTR:	BLOCK	1	;POINTER TO START OF LAST LINE OF SCREEN

IFN SAVETY,<	;Put text in DSK:EDEBUG.TMP for debugging
DEBPTR:	POINT	7,DEBBUF
DEBBLK:	16
	SIXBIT	/DSK/
	0
DEBFIL:	SIXBIT	/EDEBUG/
	SIXBIT	/TMP/
	EXP	0,0
DEBCCL:	IOWD	400,DEBBUF
	0
DEBBUF:	BLOCK	400
>  ;End of IFN SAVETY
TOPS10<	6424		;NONZERO, NON-ODD WORD TO PRECEDE BUFFER
BUFFER:
>
TOPS20<	BUFFER==BUFSTT		;START OF BUFFER
LOC	BUFSTT-1
	6424		;NONZERO, NON-ODD WORD TO PRECEDE BUFFER
>

ASCIZ	/**************************************************************************

     Hi!  This is SED, the full screen editor.  It is easier and  more
natural to use than line or character editors, and is generally faster
too.  To  use  it, just  type.  You can move the cursor (which is that
blinking mark in the upper left corner) to other parts of the  screen.
To change existing text, just type over it.

     There  are  also  commands  to the editor.  They move the viewing
window around, insert or delete lines or spaces,  move text  from  one
place to another, search, and other useful things.

     For a summary of the editor commands see the file HLP:SED.HLP.
     For a tutorial manual see the file                MAN:SED.MAN.
     For complete editor documentation see the file    DOC:SED.DOC.

You  can  also get on-line help. Type ENTER ENTER and then any command
to get a description of that command.

To exit from SED type CTRL-Z.





/
	0
BUFFEN==.
IFN FTDDT,<
TOPS10<	.TEXT ?/SYMSEG:HIGH? >
TOPS20<	LOC	401000
		0 ;Allocate this page >
>  ;End of IFN FTDDT


SUBTTL	End of LOWSEG, start of text buffer

SEDEND:	END	START	;EXPENDABLE STUFF AT THE END
   @10