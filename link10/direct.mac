	TITLE	DIRECT -- DIRECTORY LISTING CUSP  -- %5(336)
	SUBTTL	P.CONKLIN/PFC/JBC/DCE/MD/JEF		16-JAN-76


;***COPYRIGHT 1970, 1971, 1972, 1973, 1974, 1975, 1976  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***


DRTWHO==1		;CUSTOMER VERSION [/CAB - Tymshare]
DRTVER==5		;DEC VERSION
DRTMIN==0		;DEC MINOR VERSION
DRTEDT==336		;DEC EDIT VERSION

	SEARCH	MACTEN,JOBDAT,UUOSYM,SCNMAC
%%JOBD==%%JOBD	;SHOW VERSION
%%SCNM==%%SCNM	; ..

	.REQUE	REL:SCN7B
%%%SCN==:7	;PROTECT VERSION
	.REQUE	REL:HELPER
	.REQUE	REL:WLD7A
%%%WLD==:7	;PROTECT VERSION

	SALL


;ASSEMBLY INSTRUCTIONS:
;
;	.LOAD DIRECT
;	.SSAVE
;
;ASSUMES C.UNV AND SCNMAC.UNV ON UNV:
;	 SCAN.REL, HELPER.REL, AND WILD.REL ON REL:
;ASSEMBLY PARAMETERS

ND FT$TYM,-1		;Tymshare Features
ND FT$IPF,0		;1=IGNORE PROTECTED FILES
ND FT$LPW,0		;1=WAIT IF LPT NOT AVAILABLE
ND FT$MTA,-1		;INCLUDE MAGTAPE FEATURES IN GENERAL
ND FT$MTB,-1		;INCLUDE MAGTAPE FEATURES FOR BACKUP
ND FT$MTF,-1		;INCLUDE MAGTAPE FEATURES FOR FAILSAFE
ND FT$MTR,0		;INCLUDE MAGTAPE FEATURES FOR OLD BACKUP/RESTORE
ND FT$MTS,-1		;INCLUDE MAGTAPE FEATURES FOR FRS
ND FT$SFD,-1		;SFD FEATURES

ND LN$DRB,6		;LENGTH OF SFD NESTING
ND LN$LPP,^D50		;LINES PER PAGE OF DATA
ND LN$MRC,^D674		;LENGTH OF MAX MAG TAPE RECORD
ND LN$PDL,50		;LENGTH OF PUSH-DOWN LIST
ND LN$RIB,44		;LENGTH OF DIRECTORY LOOKUP BLOCK [TYmshare=44]

ND NM$DBF,^D10		;NUMBER OF DISK BUFFERS FOR INPUT


IFLE LN$DRB-1,< FT$SFD==0
		LN$DRB==1>

IFE FT$MTA,<	FT$MTB==0
		FT$MTF==0
		FT$MTR==0
		FT$MTS==0>

IFN FT$MTS,<	FT$MTB==-1>


	RADIX	10
DM ACC,100000,0,5
DM FIL,100000,0,1
DM WID,250,0,64
	RADIX	8


IFL LN$RIB-41,<PRINTX ? RIB BLOCK TOO SMALL FOR FAILSAFE>
;       	TABLE OF CONTENTS FOR DIRECT
;
;
;                          SECTION                            PAGE
;    1. REVISION HISTORY......................................   4
;    2. STANDARD MNEMONICS--REGISTERS, BITS, UUOS.............   7
;    3. INITIALIZE............................................  13
;    4. MAIN LOOP FOR COMMAND SCANNING........................  14
;    5. FILL IN DEFAULTS AFTER COMMAND SCANNING...............  16
;    6. PERFORM ONE DISK DIRECTORY LISTING....................  21
;    7. PERFORM MAG TAPE DIRECTORY LISTING....................  25
;    8. PERFORM MAG TAPE DIRECTORY LISTING--BACKUP/RESTORE....  34
;    9. PERFORM MAG TAPE DIRECTORY LISTING--FAILSAFE..........  38
;   10. PERFORM MAG TAPE DIRECTORY LISTING--SUBROUTINES.......  43
;   11. ROUTINE FOR DISK AND MAGTAPE DIRECTORY LINE...........  47
;   12. PERFORM DECTAPE DIRECTORY LISTING.....................  72
;   13. PERFORM TMPCOR DIRECTORY LISTING......................  75
;   14. MISC. DIRECTORY SUBROUTINES...........................  77
;   15. SUBROUTINES FOR LISTING OUTPUT........................  84
;   16. STORAGE............................................... 102
	SUBTTL	REVISION HISTORY

;%1 -- 6/71 WITH 5.03 MONITOR

;A)  REARRANGE TO USE SCAN.MAC AND ELIMINATE THE
;	BUILT IN SCANNER.  THIS GIVES INDIRECT FILES AND ALL
;	THE SCAN IMPROVEMENTS OVER SCANER.
;B)  EXPAND TOTAL LINE TO INCLUDE NUMBER OF LOOKUP FAILURES
;C)  FIX BUG ASSOCIATED WITH SYS: AND + UNDER 5.03
;D)  EXPAND TO HANDLE SUB-FILE DIRECTORIES.
;E)  REARRANGE TO USE REVAMPED LOKWLD (WILD)
;F)  IN /SORT, GIVE DATES AS " YYYYMMDD"
;G)  IN /SORT, LIST DIRECTORY IF AND ONLY IF THE REQUEST HAS
;	WILD CARDS IN THE DIRECTORY
;H)  IN /WIDTH, LIST STR OR DIRECTORY AS A SEPARATE LINE
;I)  IN /SORT, LIST STR IF AND ONLY IF DSK OR WILDCARDS
;J)  CHANGE DTA TO USE 300 MODE
;K)  ADD SWITCH /WORDS TO PRINT DISK LENGTHS IN WORDS NOT BLOCKS
;L)  IF MAG TAPE, INTERPRET FAILSAFE TAPE AS DISK DIRECTORY
;M)  OUTPUT VERSION IN FRONT OF STRUCTURE AND DIRECTORY
;N)  OUTPUT SPOOLED NAME (IF NON-ZERO) AT RIGHT END
;O)  /F/SUM WILL GIVE FAST LIST PLUS A SUMMARY
;P)  ADD FREE SPACE TO TMP: DIRECTORY
;Q)  /DETAIL WILL GIVE A LISTING LIKE LOOKFL DID (IE, ALL INTERESTING
;	ITEMS FROM THE EXTENDED LOOKUP
;R)  SUPPORT /DENSITY, /PROTECT, /PARITY SWITCHES FROM SCAN
;S)  DETECT ANSI-LIKE LABELS AND BACKUP TAPES
;T)  CORRECT A BUG WHICH GAVE EXTRA NON-EX. MESSAGES
;U)  ADD SUBTOTALS FOR EACH DIRECTORY AND STRUCTURE
;V)  INCLUDE CHECKSUM IN TOTALS
;W)  SUPPORT /BEFORE AND /SINCE
;X)  ADD /MARKS
;Y)  HANDLE + ON MTA, DTA, TMPCOR
;Z)  USE VERSION FROM RIB IF PRESENT.  IN /DETAIL, GIVE BOTH IF
;	DIFFERENT.
;AA)  REMOVE 'UFD' IN REGULAR LISTING SO COLUMNS LINE UP.
;AB)  USE 317 MODE ON DECTAPES.
;AC)  EXPAND ALL TABS IN /SORT MODE
;AD)  FIX TYPE/LIST LOGIC TO NOT TYPE TITLES, OR DOUBLE TYPE SUMMARIES.
;AE)  FIX BUG TO CORRECTLY SUPPRESS TRAILING TABS.
				CONT.
;%2(125) -- 5/72 WITH SCAN AND WILD

;126	(7613) LIST DIRECTORIES IF WILD AND /SORT
;127	MOVE SWITCHES AIMED AT F TO WORD FLAGS FOR SCAN %3
;	ALSO MOVE S.LODV AND S.TITL TO S.MIN AREA.
;130	CALL .OSCAN TO IMPLEMENT USER OPTIONS
;	ALSO ADD /NORMAL TO OVERRIDE /FAST IN OPTIONS FILE
;131	(8314) SUMMARY OF LOOKUP ERRORS WAS PREMATURE
;132	(8280) DIRECTORY CHECKSUMS WERE INCORRECT IN SUMMARY
;133	(QAR 149) NEEDED 3 EOFS TO END MAG TAPE
;134	(7635) CORRECT MAG TAPE SUB-TOTALS TO COME AT RIGHT TIME
;135	HANDLE FILE NOT MATCHING ON MAG TAPE
;136	OUTPUT RIB INTERNAL FORMAT CREATION TIME IN HUMAN TERMS
;137	(7613) IF /SORT, LIST DIRECTORIES AS 2*6 DIGITS
;140	CORRECT FORMATTING ERROR IN FIXED FORMAT OCTAL 7.
;141	ADD /NOREWIND, /NOEOT, /FILES:N  (QAR 177)
;142	FIX /MARKS TO INDICATE LAST EOF AS WELL (IE, EOT)
;143	CORRECT NULL DEVICE BUG INTRODUCED BY 127.
;144	CORRECT INF.0 BUG INTRODUCED BY 140.
;145	RESTORE .JBFF EACH OPEN. ALSO USE 10. BUFFER RING ON DISK INPUT
;146	ADD /NOSUMMARY, /NODETAIL, AND /NOUNITS.
;147	IF /DETAIL/SUMMARY, DO BOTH. IF /NOSUM NEVER GIVE ONE. IF
;	/NOUNITS, ALWAYS GIVE STR.
;150	IF /SORT, ALLOCATE 15 COLUMNS FOR VERSION
;151	/SORT OF MTA FAILED TO INCLUDE STRUCTURE
;152	IF /SUM, ALWAYS INCLUDE SUMMARIES

;%3(152) 12/72

;153	(10-9943) GET LAST SUB-TOTAL
;154	(10-10979) AVOID ILL UUO ON SOME COMMAND ERRORS
;155	(10-10590) AVOID "NO FILES" ON MTA:/F
;156	MTA BUFFER HEADER INDICATED LENGTH WAS 2 TOO BIG
;157	DEFAULT /OKPROT IF WILDCARDS IN UFD
;160	IF OUTPUT NOT TO TTY:, FORCE ALL SUMMARIES
;161	(10-9981) REJECT NUL: GRACEFULLY IN 5.07
;162	SUPPORT DATE75
;163	HANDLE INDEFINITE NUMBER OF INPUT FILES IN SPEC
;164	STANDARDIZE ERROR MESSAGES
;165	CHANGE TO USE .STOPN TO SUPPORT OUTPUT SFD
;166	GIVE RIGHT MESSAGE ON MTA ERRORS
;167	HANDLE NULL COMMAND (BUG IN EDIT 163)
;170	FIX BUG IN 155
;171	(10-XXXX) PRINT LH(.RBELB) AS CONI IN OCTAL
;172	PICK UP 507 MTCHR. DATA ON TAPES
;173	(10-10324) USE % PREFIX ON FILE NOT FOUND
;174	(10-11580) ADD /AUTHOR /PRDIRECTORY /PRDEVICE
;175	SUPPRESS TOTAL OF 0 FILES MESSAGE
;176	FIX BUGS IN EDIT 162
;177	FIX FORMAT BUG IN 173
				CONT.
;200	(10-11,233) PRINT RIB BLOCK NUMBER IN /DETAIL
;201	COUNT BLOCKS ON DTA FOR /SUM LINE
;202	SUPPRESS TITLES ON DTA, TMP LISTINGS
;203	COMMENT OUT BACKUP/RESTORE CODE
;204	USE C,SCNMAC AS UNIVERSALS
;205	PRINT SUMMARIES BEFORE SUBSEQUENT ERROR MESSAGES
;206	PRINT UFD NAME AS [P,PN] IN FILE READING ERROR MESSAGE
;207	LIST SFD CONTENTS AFTER DIRECTORY CONTAINING SFD
;210	EXTEND 164 TO SUPPORT /MESSAGE LEVEL
;211	REMOVE BUG OF LISTING [,,SFD] TWICE
;212	IN /F WITHOUT /W, GIVE NAME.EXT FOR SPEED
;213	RECOGNIZE SIXBIT TAPE LABELS
;214	(10-11,493) FORCE OUTPUT AT END OF DIRECTORY IN /F
;215	(10-12,805) INDICATE THAT /DEN/PAR ARE AS READ, NOT AS WRITTEN
;216	(10-12,995) WARN OF PARITY ERROR ON DTA, BUT STILL GIVE DIRECTORY
;217	DON'T FORCE OUTPUT ON A TAB
;220	(10-13049) IMPLEMELT /SUM IF DTA, TMP
;221	(10-13048) IMPLEMELT /CHECK, /AUTH, /ACCESS IF IN /F
;222	EXCLUDE THE RIBS FROM MTA CHECKSUM
;223	HANDLE /F/SUM TO NOT SAY 0 BLOCKS
;224	FIX MISC BUGS SINCE V. 3
;225	(10-13458) ADD /FDTA
;226	(QAR 2173) ALLOW DTA3:=DTA3:, ETC.
;227	CANCEL 157
;230	ADD FRS FORMAT AND PRELIMINARY BACKUP FORMAT
;231	ADD FS.NFS
;232	SUPPORT .OSDFS
;233	SUPPORT /OKPROTECTION
;234	(Q2811-2) CANCEL 227 WITH FT$IPF

;%4(234) 11/74

;235	(10-14824) CORRECTION FOR FRS FORMAT
;236	(10-14820) REMOVE DOT IN F.EXT WHEN /F/SORT
;237	(10-14828) FIX PROBLEM WITH FILE CONSTRAINTS BEING IGNORED
;240	(10-14942) FIX PROBLEM WITH JUNK LABELS CAUSING ILL MEM REF
;241	(10-14972) FIX BAD MFS ERROR MESSAGE DURING FRS DIRECTORIES
;242	(10-14975) FIX FRS TAPE ERROR PROCESSING FOR ILL UUO, ETC.
;243	(10-15399) FIX FRS %DRTJFS ERROR FOR NULL FILES
;244	(10-15717) FIX BUG CAUSING ALL FILE OUTPUT TO BE
;		DUPLICATED ON TTY AFTER PREFIX-ONLY "DRTLKE"
;245	(10-16555) BREAK FOR SUBTOTALS CORRECTLY AND
;		SHOW UNIT ONLY WHEN /UNITS
;246	(10-16552) /SORT SUPPRESS PUTTING DIRECTORY AND
;		STRUCTURE ON SEPARATE LINE IN /WIDTH
				CONT.
;300	(10-15,415) IMPROVE EDIT 243
;301	FIX BACKUP BUGS
;302	SUPPORT REWORKED BACKUP FORMAT TO /INTERCHANGE LEVEL
;303	CHANGE ASSEMBLY PROCEEDURE TO USE .REQUEST
;304	CHANGE SYMBOLS F$???? TO B$????
;305	FIX BUG IN FRS/CHECKSUM IF DISK FILE WAS 4(MOD 5) BLOCKS
;306	SUPPORT .EXE FILES
;307	(S70-427) BUG-SUPPRESS DIRECTORY FROM SUMMARY
;		IF 2 ONE FILE OUTPUTS
;310	(Q2489) LIST VERSION Z, AZ, BZ CORRECTLY
;311	(Q2990) SPEED UP BY LETTING WILD KEEP CHANNEL 0 OPEN
;312	DON'T FORCE LINES ON LPT:
;313	(S55-134) CLEAR INITIAL FLAGS SO TCHR OK FROM .ISCAN
;314	(S70-152) CHANGE "INPUT" TO "SOURCE" IN MESSAGES
;315	ADD FEATURE TESTS FOR MAGTAPE CODE
;316	EXTEND 302 TO FILES NOT STARTING AT 0
;317	ADD /COMPARE TO SUPPRESS ALL OVERHEAD LINES
;320	(SER 55-219) IMPROVE /W WITH /N, ETC.
;321	REMOVE WAIT FOR LPT (VIA FT$LPW)
;322	ADD /INDIRECT TO MAKE AN INDIRECT FILE
;323	(QAR 3647) FIX PRINT DECISION ON /UNITS
;324	REMOVE EXTRA BLANK LINES INADVERTENTLY INSERTED
;		BY EDIT 307
;325	USE JOBDAT AS A UNIVERSAL; CHANGE EXTERNS TO ##
;326	CORRECT BUG IN WHICH OUTPUT FILE DIRECTORY WAS IGNORED
;327	REMOVE BLANK LINES ON /SUMMARY
;330	PERMIT /W FOR DECTAPES TOO
;331	FIX LISTING OF BACKUP FORMAT MAG-TAPE WITH SFD'S
;332	(SPR-17317) SEARCH SYS AFTER NEW IF ERSATZ DEVICE SYS
;	REQUESTED AND /NEW ENABLED.
;333	MAKE VERSION CHECKING FOR .EXE FILES WORK
;334	MAKE [226] WORK WHEN EXPLICIT EXTENSION GIVEN (OR NOT A DISK)
;335	CLEAN UP LISTINGS UNDER /TITLE (NOTE THAT THE "SPOOLING"
;	WORD IS NOT REALLY HANDLED - SPACED - CORRECTLY YET)
;336	FIX /NOPRDEVICE & /NOPRDIRECTORY WITH /INDIRECT
	SUBTTL	STANDARD MNEMONICS--REGISTERS, BITS, UUOS

;AC NAMES

F=0		;FLAGS (LH=PERMANENT, RH=TEMPORARY)
T1=1		;TEMPORARIES
T2=2
T3=3
T4=4

P1=5		;PRESERVED
P2=6
P3=7
P4=10

I=11		;GENERAL INDEX REGISTERS
J=12

C=14		;TEMP DEFS FOR LISTING ROUTINES
N=15
M=16
P=17		;PUSH-DOWN POINTER

;I/O CHANNELS

DC==1		;READ DATA FILE
LC==2		;OUTPUT (DIRECTORY LISTING)
;FLAGS (LH)

L.SVST==(1B0)	;SAVE SET FLAG FOR MT UNTANGLING
L.FKEF==(1B1)	;FAKE EOF TO TRICK DISK CODE
L.BKSS==(1B2)	;OLD BACKUP/RESTORE STYLE SAVE SET
L.SVDW==(1B3)	;SAVED WORD IN INPUT AREA
L.LEVD==(1B4)	;THIS DATA CAME FROM LEVEL-D OR MORE
L.ILEN==(1B5)	;INCORRECT LENGTH
L.IMLB==(1B6)	;IMBEDDED LABEL
L.LENT==(1B7)	;LONG ENTER OK
L.FRSS==(1B8)	;BACKUP/FRS SAVE SET
L.FRMT==(1B9)	;[335] FORMAT OUTPUT (I.E., EITHER /SORT OR /TITLES)

;FLAGS (RH)

R.WORD==1B18	;QUANTITIES ARE IN WORDS NOT BLOCKS
R.TYPE==1B19	;FORCE TYPEOUT AS WELL AS LISTING
R.ACCS==1B20	;FORCE A FILE ACCESS
R.LSOM==1B21	;SOME OUTPUT SENT
R.OUTD==1B22	;OUTPUT DEVICE INITTED
R.OUTL==1B23	;FORCE OUTPUT AFTER EACH LINE
R.SLOW==1B24	;SLOW FORMAT  --DO NOT MOVE OR INTERCHANGE
R.FAST==1B25	;FAST FORMAT  --THIS ORDER REQUIRED
R.OUTO==1B26	;OUTPUT DEVICE OPEN AND IT IS OUR TTY:
R.LPTB==1B27	;LPT BUSY--WAITING
R.LTAB==1B28	;SET IF TAB TO BE LISTED NEXT
R.MARK==1B29	;SET IF /MARK SWITCH (IE, LIST TAPE MARKS)
R.NDSK==1B30	;SET IF NOT A DISK DIRECTORY			[202]
R.LBSX==1B31	;SET IF SIXBIT LABELS				[213]
R.MTOH==1B32	;MT OVERHEAD WORD COMING NEXT			[222]
R.NSF==1B33	;NOT START OF FILE				[316]
R.SPLN==1B34	;SUPPRESS LINE					[317]
R.STAB==1B35	;[335] SUPPRESS NEXT TAB (AT CALL TO LTAB)
;DEFINE LOCAL NAME OF LOCATIONS WITHIN THE RIB

.RBXTR==36	;DUMMY LENGTH FOR EXCESS RIB WORDS

IF2,<		;ONLY PASS 2 SINCE LOCATION OF LOOKUP BLOCK DEFINED AT END

	DEFINE DR(A,B),<
IFL .RB'B-LN$RIB,<A=LBLOCK+.RB'B>
>
	DEFINE DQ(A),<DR (F'A,A)>

DR RIBLEN,CNT;	BLOCK LENGTH
DR UFDPPN,PPN;	PROJECT-PROGRAMMER NUMBER OR POINTER TO DIRECTORY
DQ NAM;	FILE NAME
DQ EXT;	FILE EXTENSION
DR FCRE,PRV;	PROTECTION, CREATION, ETC.
DR FLEN,SIZ;	FILE LENGTH
DQ VER;	VERSION
DQ SPL;	SPOOLED NAME
DQ EST;	ESTIMATED LENGTH
DQ ALC;	ALLOCATED LENGTH
DQ POS;	POSITION ALLOCATED
DQ FT1;	DEC NON-PRIV FUTURE
DQ NCA;	CUSTOMER NON-PRIV
DQ MTA;	DISK BACKUP TAPE
DQ DEV;	LOGICAL UNIT
DQ STS;	FILE STATUS BITS
DQ ELB;	ERROR LOGICAL BLOCK
DQ EUN;	ERROR UNIT AND LENGTH
DQ QTF;	FCFS QUOTA
DQ QTO;	LOGGED OUT QUOTA
DQ QTR;	RESERVED QUOTA
DQ USD;	BLOCK IN USE
DQ AUT;	AUTHOR
DQ NXT;	CONTINUED STR
DQ PRD;	PREVIOUS STR
DQ PCA;	PRIV CUSTOMER ARG
DQ UFD;	POINTER BACK TO UFD
DQ FLR; RELATIVE BLOCK IN FILE COVERED BY THIS RIB
DQ XRA; POINTER TO NEXT RIB IN CHAIN
DQ TIM; CREATION DATE,,TIME IN INTERNAL FORMAT
DQ XTR;	EXTRA RIB WORDS START HERE

>	;END IF2
;FORMAT OF BACKUP TAPES
;	(TAKEN FROM BACKRS SOURCE)

T$FIL==4	;DISK FILE DATA

T$MAX==10	;LARGEST RECORD TYPE

G$FLAG==3	;RECORD DEPENDENT BITS

GF$EOF==1B0	;LAST RECORD OF FILE
GF$RPT==1B1	;REPEAT OF LAST RECORD WRITE ERROR

A$FHLN==0	;ATTRIBUTE HEADER FIXED LENGTH REGION
A$FLGS==1	;ATTRIBUTE FLAGS
A$WRIT==2	;LAST WRITE DATE
A$ALLS==3	;ALLOCATED SIZE
A$MODE==4	;MODE
A$LENG==5	;LENGTH
A$BSIZ==6	;BYTE SIZE
A$VERS==7	;VERSION
A$PROT==10	;PROTECTION
	PR$ATR==7B31	;ATTRIBUTES
	PR$WRT==3B33	;WRITE
	PR$RED==3B35	;READ
A$NOTE==12	;ANNOTATION
A$REDT==14	;LAST READ (ACCESS)
A$ESTS==16	;ESTIMATED SIZE
A$RADR==17	;REQUESTED ADDRESS
A$CUSR==22	;AUTHOR
A$BKID==23	;LAST BACKUP TAPE
A$USRW==30	;NON-PRIVILEGED CUSTOMER WORD
A$PCAW==31	;PRIVILEGED CUSTOMER WORD

.FCDEV==1	;DEVICE
.FCNAM==2	;NAME
.FCEXT==3	;EXTENSION
.FCVER==4	;VERSION
.FCGEN==5	;GENERATION
.FCDIR==40	;TOP LEVEL DIRECTORY
.FCSFD==41	;SFD NAME					[331]

;ALSO SEE STORAGE BLOCKS B$???? IN STORAGE SECTION
;N$FAIL <XYZ,FOO> SENDS FOO WITH PREFIX "DRTXYZ" AS A FATAL ERROR

DEFINE	N$FAIL ($PFX,$TEXT),<
E$$'$PFX':
	MOVEI	T1,''$PFX''
	PJSP	T2,ERROR
	XLIST
	ASCIZ	\$TEXT\
	LIST
>

;N$FAIN <XYZ,FOO> SENDS FOO WITH PREFIX "DRTXYZ" AS A FATAL ERROR WITH P3 IN SIXBIT

DEFINE	N$FAIN ($PFX,$TEXT),<
E$$'$PFX':
	MOVEI	T1,''$PFX''
	XLIST
IFNB <$TEXT>,<	MOVEI	T2,[ASCIZ \$TEXT \] >
IFB  <$TEXT>,<	MOVEI	T2,0 >
	PUSHJ	P,ERRORC
	TXNN	T1,JWW.FL
	JRST	LFERX
	MOVE	T1,P3
	PUSHJ	P,.TSIXN##
	JRST	LFERX
	LIST
>

;N$FAID <XYZ,FOO> SENDS FOO WITH PREFIX "DRTXYZ" AS A FATAL ERROR WITH P3 IN DECIMAL

DEFINE	N$FAID ($PFX,$TEXT) <
E$$'$PFX':
	MOVEI	T1,''$PFX''
	XLIST
IFNB <$TEXT>,<	MOVEI	T2,[ASCIZ \$TEXT \] >
IFB  <$TEXT>,<	MOVEI	T2,0 >
	PUSHJ	P,ERRORC
	TXNN	T1,JWW.FL
	JRST	LFERX
	MOVE	T1,P3
	PUSHJ	P,.TDECW##
	JRST	LFERX
	LIST	
>
;N$FAIO <XYZ,FOO> SENDS FOO WITH PREFIX "DRTXYZ" AS A FATAL ERROR WITH P3 IN OCTAL

DEFINE	N$FAIO ($PFX,$TEXT),<
E$$'$PFX':
	MOVEI	T1,''$PFX''
	XLIST
IFNB <$TEXT>,<	MOVEI	T2,[ASCIZ \$TEXT \] >
IFB  <$TEXT>,<	MOVEI	T2,0 >
	PUSHJ	P,ERRORC
	TXNN	T1,JWW.FL
	JRST	LFERX
	MOVE	T1,P3
	PUSHJ	P,.TOCTW##
	JRST	LFERX
	LIST
>

;N$WARN <XYZ,FOO> SEND FOO WITH PREFIX "DRTXYZ" AS A WARNING MESSAGE

DEFINE	N$WARN ($PFX,$TEXT),<
E$$'$PFX':
	MOVEI	T1,''$PFX''
	XLIST
	MOVEI	T2,[ASCIZ \$TEXT\]
	PUSHJ	P,WARN
	PUSHJ	P,.TCRLF##
	LIST
>

;N$WRNX <XYZ,FOO> SEND FOO WITH PREFIX "DRTXYZ" AS START OF A WARNING MESSAGE
;FINAL CALL TO .TCRLF MUST BE LABELLED "X$$XYZ"

DEFINE	N$WRNX ($PFX,$TEXT),<
E$$'$PFX':
	MOVEI	T1,''$PFX''
	XLIST
IFNB <$TEXT>,<	MOVEI	T2,[ASCIZ \$TEXT \] >
IFB  <$TEXT>,<	MOVEI	T2,0 >
	PUSHJ	P,WARN
	TXNN	T1,JWW.FL
	JRST	X$$'$PFX'
	LIST
>
;COMMUNICATION WITH WILD

	INTERN	.TNEWL

;JOB DATA LOCATIONS OF INTEREST

	LOC	.JBVER
	VRSN.	(DRT)
	RELOC




	TWOSEG
	RELOC	.JBHGH
SUBTTL	INITIALIZE

;HERE AFTER START OR RUN OR DIRECTORY COMMAND OR RUN UUO

DIRECT:	TDZA	T1,T1		;CLEAR OFFSET
	MOVEI	T1,1		;SET OFFSET
	MOVEM	T1,OFFSET	;STORE IT

	RESET			;RESET ANY EXTERNAL I/O
	SETZB	F,ZCOR		;CLEAR CORE			[313]
	MOVE	T1,[ZCOR,,ZCOR+1]
	BLT	T1,EZCOR
	MOVE	P,[IOWD LN$PDL,PDLST]	;ESTABLISH PUSH-DOWN LIST

	GETPPN	T1,		;DETERMINE THIS JOB'S PPN
	  JFCL			;(IN CASE OF JACCT)
	MOVEM	T1,MYPPN	;SAVE FOR THE FUTURE

	MOVE	T1,[ 3,,[IOWD  1,['DIRECT']
			OFFSET,,'DIR'
			0,,TCHR]]
	PUSHJ	P,.ISCAN##	;INITIALIZE COMMAND SCANNER

	MOVE	T1,.JBFF	;SAVE ORIGINAL VALUE
	HRL	T1,.JBREL	; OF .JBREL AND			[163]
	MOVEM	T1,ORGFF	; OF .JBFF
				CONT.
SUBTTL	MAIN LOOP FOR COMMAND SCANNING

MAINLP:	MOVE	P,[IOWD LN$PDL,PDLST]
	MOVE	T1,[ 6,,[IOWD DRSWTL,DRSWTN
			DRSWTD,,DRSWTM
			0,,DRSWTP
			-1
			CLANS,,0
			AIN,,AOUT]]
	PUSHJ	P,.TSCAN##	;GET THE COMMAND
	SKIPN	I.NXZR		;SEE IF ANYTHING		[167]
	JRST	[PUSHJ P,.CLRFL##  ;NO--CLEAR FILE AREA		[167]
		 PUSHJ P,AIN	;ALLOCATE ONE SPEC		[167]
		 PUSHJ P,.GTSPC##  ;COPY IT IN			[167]
		 JRST  .+1]	;AND PROCEED			[167]
	MOVE	T1,[ 4,,[IOWD DRSWTL,DRSWTN
			DRSWTD,,DRSWTM
			0,,DRSWTP
			-1]]
	PUSHJ	P,.OSCAN##	;SCAN USER OPTIONS
	MOVE	F,FLAGS		;GET INITIAL FLAGS
	JRST	DEFAUL		;GO FILL IN DEFAULTS


;SUBROUTINE TO CLEAR ANSWER AREA

CLANS:	SETZM	S.ZER		;ZERO OUT COMMAND ACCUMULATORS
	MOVE	T1,[S.ZER,,S.ZER+1]
	BLT	T1,S.EZER
	SETOM	S.MIN		;PRESET SWITCH PARAMETERS
	MOVE	T1,[S.MIN,,S.MIN+1]
	BLT	T1,S.EMIN
	SETZM	I.NXZR		; AND FOR SCANING
	CLOSE	LC,CL.ACS!CL.DAT  ;TERMINATE LISTING IF OPEN
	RELEAS	LC,		;  IN CASE OF ERROR RESTART
	SETZM	B.LC+.BFPTR	;SET FLAG FOR LISTING CLOSED
	TRZ	F,-1		;CLEAR ALL LOCAL FLAGS
	HRRZ	T1,ORGFF	;RESTORE ORIGINAL VALUE		[163]
	MOVEM	T1,.JBFF	; OF .JBFF
	MOVEM	T1,I.INZR	; FOR .WILD			[163]
	HLRZ	T1,ORGFF	;RESTORE .JBREL			[163]
	CAME	T1,.JBREL	; UNLESS OK			[163]
	CORE	T1,		; TELL MONITOR			[163]
	  JFCL			;(IGNORE ERROR)			[163]
	POPJ	P,		;RETURN
;SUBROUTINE TO ALLOCATE OUTPUT FILE AREA

AOUT:	MOVEI	T1,O.ZER	;POINT TO IT
	MOVEI	T2,O.LZER	;AND LENGTH
	POPJ	P,		;AND RETURN

;SUBROUTINE TO ALLOCATE INPLE AREA

AIN:	MOVEI	T1,I.LZER	;ADVANCE ALLOCATION
	SKIPN	I.NXZR		;SEE IF STARTED YET
	MOVE	T1,I.INZR	;NO--START AT BEGINNING
	ADDB	T1,I.NXZR	;AND STORE NEW VALUE
	MOVEI	T2,I.LZER(T1)	;COMPUTE NEXT FREE		[163]
	MOVEM	T2,.JBFF	; STORE FOR LATER		[163]
	SOS	T2		;GET END			[163]
	CAMG	T2,.JBREL	;SEE IF IN CORE			[163]
	JRST	AINX		;YES--NO SWEAT			[163]
	CORE	T2,		;NO--GET MORE CORE		[163]
	  JRST	E$$TMI		;ERROR IF NO ROOM		[163]
AINX:	HRLZ	T2,T1		;POINT TO START			[163]
	HRRI	T2,1(T1)	;SETUP NEXT ADDR		[163]
	SETZM	(T1)		;CLEAR NEW			[163]
	BLT	T2,I.LZER-1(T1)	; AREA				[163]
	MOVEI	T2,I.LZER	;SET LENGTH
	POPJ	P,		;RETURN
	SUBTTL	FILL IN DEFAULTS AFTER COMMAND SCANNING

;HERE AT END OF COMMAND -- SUPPLY ABSENT FILE DEFAULTS

DEFAUL:	MOVEI	T1,O.ZER	;POINT TO OUTPUT SPEC		[232]
	MOVEI	T2,O.LZER	;INDICATE LENGTH		[232]
	PUSHJ	P,.OSDFS##	;INCLUDE USER DEFAULTS		[232]
	MOVSI	T1,'TTY'	;DEFAULT OUTPUT DEVICE
	SKIPLE	S.DODV		;SEE IF /L SWITCH
	MOVSI	T1,'LPT'	;YES--CHANGE DEFAULT
	SKIPN	O.DEV
	MOVEM	T1,O.DEV
	HRLOI	T1,'DIR'	;DEFAULT OUTPUT EXTENSION
	SKIPLE	S.IND		;IF /INDIRECT,			[322]
	HRLOI	T1,'CCL'	;USE DIFFERENT DEFAULT		[322]
	SKIPN	O.EXT
	MOVEM	T1,O.EXT

	MOVE	T2,O.DEV
	MOVE	T1,O.PROT	;GET PHYSICAL FLAG
	TXNN	T1,FX.PHY	;SEE IF /PHY
	DEVCHR	T2,
	TXNE	T1,FX.PHY	;SEE IF /PHY
	DEVCHR	T2,UU.PHY	;YES
	TLZ	F,L.LENT	;SEE IF				[224]
;[334]	REPLACE @ DEFAUL + 21L 
	TXNE	T2,DV.DSK	;[334] SEE IF DISK
	TLO	F,L.LENT	;YES--INDICATE LONG ENTER	[224]
	TXNN	T2,DV.LPT	;SEE IF TYPE LPT
	JRST	DEFAU2		;NO--PROCEED
	TRNN	F,R.FAST!R.SLOW	;SEE IF ANY SPEED SWITCH
	TRO	F,R.SLOW	;NONE--SET TO SLOW MODE
	MOVEI	T1,1		;  (PRESET VALUE)
	SKIPGE	S.TITL		;  AND NO TITLE SWITCH
	MOVEM	T1,S.TITL	;YES--SET DEFAULT TITLE ON
DEFAU2:	MOVE	T1,S.SUM	;GET /SUMMARY			[160]
	TXNE	T2,DV.TTA	;SEE IF CONTROLLING TTY		[160]
	TROA	F,R.OUTO	;YES--SET FLAG			[160]
	JRST	[SKIPGE T1	;UNLESS USER SET /SUM, FORCE SUMMARIES  [160]
		 MOVEI T1,1	;  OK--SET SUMMARIES		[160]
		 JRST  .+1]	;PROCEED			[160]
	MOVEM	T1,FLFSUM	;STORE FLAG FOR FORCED SUMMARIES [160]
	TXNE	T2,DV.TTY	;SEE IF LINE MODE DEVICE	[160,312]
	TRO	F,R.OUTL	;YES--SET FLAG			[160]
	SKIPN	O.NAM
	TXNN	T2,DV.DIR	;SEE IF FILE NAME NEEDED
	JRST	OUDEF2		;NO--GO ON
	TLC	T2,-1-<(DV.TTA)> ;SEE IF NUL:			[161]
	TLCN	T2,-1-<(DV.TTA)> ; ..				[161]
	JRST	OUDEF2		;YES--ENTER NOT NEEDED		[161]
				CONT.
	MSTIME	T1,		;YES--MANUFACTURE NAME HHMMSS
	IDIVI	T1,^D1000	;GET SECONDS
	MOVE	T4,[POINT 6,O.NAM]	;SETUP BYTE POINTER
	MOVSI	T3,-6		;INITIALIZE LOOP COUNTER
OUDEF1:	IDIV	T1,[^D36000
		    ^D3600
		    ^D600
		    ^D60
		    ^D10
		    ^D1](T3)	;GET NEXT DIGIT
	ADDI	T1,'0'		;CONVERT TO SIXBIT DIGIT
	IDPB	T1,T4		;STORE INTO NAME
	MOVE	T1,T2		;RESTORE REMAINDER
	AOBJN	T3,OUDEF1	;LOOP
	SETOM	O.NAMM		;INDICATE NOT WILD		[165]
	MOVEI	T1,[ASCIZ /Directory listing on file /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,O.NAM	;GET NAME
	PUSHJ	P,.TSIXN##
	MOVEI	T1,"."		;GET PERIOD			[161]
	PUSHJ	P,.TCHAR##	;OUTPUT IT			[161]
	HLLZ	T1,O.EXT	;GET ACTUAL EXTENSION		[161]
	PUSHJ	P,.TSIXN##	;OUTPUT IT			[161]
	PUSHJ	P,.TCRLF##

OUDEF2:	SETZM	H.ZER		;CLEAR OUT SUMMARY AREA FOR OUTPUT
	MOVE	T1,[H.ZER,,H.ZER+1]
	BLT	T1,H.EZER
	SETOM	LNPP		;PRESET TO FORCE PAGE EJECT

	PUSHJ	P,OUTIN		;OPEN OUTPUT FILE		[165]
				CONT.
;HERE TO SUPPLY INPUT SIDE DEFAULTS

INDEF:	MOVE	P1,I.INZR	;INITIALIZE BLOCK POINTER

INDEF1:	MOVE	T1,P1		;POINT TO SPEC			[232]
	MOVEI	T2,.FXLEN	;INDICATE LENGTH		[232]
	PUSHJ	P,.OSDFS##	;INCLUDE USER DEFAULTS		[232]
	MOVSI	T1,'DSK'	;FORCE DEFAULT DEVICE
	SKIPN	I.DEV(P1)	;SEE IF NEED IT
	MOVEM	T1,I.DEV(P1)	;YES--DO IT
	SKIPE	I.NAM(P1)	;SEE IF FILE NAME
	JRST	INDEF2		;YES--NO DEFAULT
	MOVSI	T1,'*  '	;NO--SET WILD DEFAULT
	CAME	P1,I.INZR	; FOR FIRST ONE
	MOVE	T1,I.NAM-I.LZER(P1)	;PREVIOUS FOR REST
	MOVEM	T1,I.NAM(P1)	;STORE IN ARRAY
	MOVEI	T1,0		;SET WILD MASK
	CAME	P1,I.INZR	; FOR FIRST ONE
	MOVE	T1,I.NAMM-I.LZER(P1)	;PREVIOUS FOR REST
	MOVEM	T1,I.NAMM(P1)	;STORE IN ARRAY
INDEF2:	MOVSI	T1,'*  '	;PRESET WILD EXTENSION
	SKIPN	I.EXT(P1)
	MOVEM	T1,I.EXT(P1)
	MOVX	T1,FX.STR	;SET MULTIPLE STR CODE
	TDNN	T1,I.MODM(P1)	;UNLESS USER HAS DEFEATED IT
	IORM	T1,I.MOD(P1)	;AND INCLUDE
IFE FT$IPF,<			;				[227,234]
	MOVX	T1,FX.PRT	;DEFAULT TO /ERPROT		[157]
	TDNN	T1,I.MODM(P1)	; ..				[157]
	IORM	T1,I.MODM(P1)	; ..				[157]
>;END FT$IPF							[227,234]

	ADDI	P1,I.LZER	;ADVANCE POINTER
	CAMG	P1,I.NXZR	;SEE IF DONE YET
	JRST	INDEF1		;NO--LOOP BACK
				CONT.
;HERE TO SUPPLY DEFAULTS FOR GLOBAL SWITCHES

	SKIPLE	S.IND		;IF INDIRECT,			[322]
	JRST	[TRZ   F,R.SLOW	;CLEAR /S			[322]
		 TRO   F,R.FAST	;SET /F				[322]
		 SETZM S.DTL	;CLEAR /DETAIL			[322]
		 MOVEI T1,1	;SET				[322]
		 MOVEM T1,S.CMP	; /COMPARE (KILL HEADERS)	[322]
		 SETZM S.SORT	;CLEAR /SORT			[322]
		 SETZM S.WDTH	;CLEAR /WIDTH			[322]
		 JRST  .+1]	;AND PROCEED			[322]
	SKIPLE	S.CMP		;IF /COMPARE,			[317]
	SKIPL	S.TITL		; AND NO /TITLE			[317]
	SKIPA			;NO				[317]
	SETZM	S.TITL		; SET /NOTITLE			[317]

	SKIPLE	S.DTL		;SEE IF /DETAIL
	TRZ	F,R.FAST!R.SLOW  ;YES--CLEAR /FAST/SLOW
	SKIPGE	S.SORT		;IS SORT MODE SPECIFIED
	SETZM	S.SORT		;NO--CLEAR FLAG
	MOVEI	T1,AD.WID	;GET ABSENT WIDTH DEFAULT
	SKIPGE	S.WDTH		;SEE IF NEEDED
	MOVEM	T1,S.WDTH	;YES--SUPPLY IT
	MOVEI	T1,1
	SKIPGE	S.REWS		;SEE IF /NOREW
	MOVEM	T1,S.REWS	;NO--SET /REW
	SKIPGE	S.EOT		;SEE IF /NOEOT
	MOVEM	T1,S.EOT	;NO--SET /EOT

;**;[330] INSERT 9 INSTR IN GLOBAL DEFAULTS	JBC	13-JAN-76
	MOVE	T1,I.INZR	;[330] GET PTR TO INPUT DEV
	MOVE	T1,I.DEV(T1)	;[330]
	DEVCHR	T1,		;[330] 
	TXNN	T1,DV.DTA	;[330] DECTAPE?
	JRST	GLDEF1		;[330] NO, BYPASS DTA DEFAULTS
	MOVEI	T1,^D32		;[330] NORMAL DEFAULT FOR DTA:
	TRNE	F,R.FAST	;[330]
	MOVEI	T1,^D16		;[330] /F
	JRST	GLDEF2		;[330] TEST FOR /WIDTH
GLDEF1:	MOVEI	T1,^D40		;WIDTH IF /N			[320] [330]
	TRNE	F,R.FAST	;				[320]
	MOVEI	T1,^D16		;/F				[320]
	TRNE	F,R.SLOW	;				[320]
	MOVEI	T1,^D64		;/S				[320]
	SKIPLE	S.CHK		;				[320]
	ADDI	T1,^D8		;/CHECKSUM			[320]
	SKIPLE	S.AUT		;				[320]
	ADDI	T1,^D16		;/AUTHOR			[320]
;**;[330] ADD LABEL	JBC	13-JAN-76
GLDEF2:	SKIPLE	T2,S.WDTH	;GET /WIDTH			[320] [330]
	SUB	T2,T1		;REMOVE LENGTH OF AN ENTRY	[320]
	SKIPL	T2		;IF NEGATIVE			[320]
	SKIPLE	S.DTL		; OR /DETAIL			[320]
	MOVEI	T2,0		; KILL WIDTH			[320]
	MOVEM	T2,MXWDTH	;STORE AS RIGHTMOST BEFORE NEW LINE
	SKIPG	S.TITL		;[335] IF TITLE'ING, OR
	SKIPLE	S.SORT		;[335] IF SORT'ING
	 TXO	F,L.FRMT	;[335] THEN FLAG FORMATTED OUTPUT
				CONT.
;HERE TO RUN OVER THE INPUTS, AND DO THE WORK

	MOVE	T1,I.INZR	;INITIALIZE POINTER
	MOVEM	T1,I.NXRD	;  TO INTERP. COMMANDS
	MOVE	T1,.JBFF	;SAVE INPUT 
	MOVEM	T1,SVJBFF	; .JBFF

ISLOOP:	PUSHJ	P,DIR		;GO DO A DIRECTORY
	MOVEI	T1,I.LZER	;ADVANCE TO NEXT REQUEST
	ADDB	T1,I.NXRD
	CAMG	T1,I.NXZR
	JRST	ISLOOP		;LOOP BACK

	SKIPN	B.LC+.BFPTR	;SEE IF OPEN
	JRST	ISLOP1		;NO--SKIP THE CLOSE
	CLOSE	LC,		;CLOSE OFF LISTING FILE
	STATZ	LC,IO.ERR	;SEE IF ANY ERROR
	  PUSHJ	P,LCHRWR	;YES--REPORT IT
	RELEAS	LC,		;AND RELEASE DEVICE
ISLOP1:	SETZM	B.LC+.BFPTR	;CLEAR INITED FLAG
	JRST	MAINLP		;ALL DONE
;FILE SCANNING ERRORS

E$$TMI:	MOVE	T1,['DRTTMI']	;INDICATE DIRECT MESSAGE CODE
	MOVE	T2,["?",,[ ASCIZ \Too many source files\ ] ] ; [314]
	MOVEI	T3,E$$TMI	;POINT TO ERROR CODE
	PUSHJ	P,.ERMSA##	;ISSUE MESSAGE
	PJRST	.FMSGE##	;COMPLETE ERROR PROCESSING
SUBTTL	PERFORM ONE DISK DIRECTORY LISTING

;DIR -- PERFORM A DIRECTORY LISTING
;CALL:	PUSHJ	P,DIR
;	RETURN WHEN DONE
;OUTPUT FILE ALREADY OPENED; INPUT POINTED TO BY I.NXRD

DIR:	TLZ	F,L.LEVD	;CLEAR LEVEL-D FLAG
	MOVX	T1,%CNSTS	;GET SYSTEM STATES
	GETTAB	T1,		;FROM MONITOR
	  MOVEI	T1,0		;(ASSUME LEV C)
	TXNE	T1,ST%DSK	;SEE IF LEVEL D
	TLO	F,L.LEVD	;YES--SET FLAG

	SETZM	H.ZER1		;CLEAR OUT COUNTERS
	MOVE	T1,[H.ZER1,,H.ZER1+1]
	BLT	T1,H.EZER
	MOVEI	I,0		;FLAG LOKWLD TO START
	TRZ	F,R.WORD	;CLEAR WORD MODE
IFN FT$MTA, TLZ	F,L.SVST!L.FKEF!L.BKSS!L.SVDW!L.FRSS  ;CLEAR SAVE SET MODE FLAGS [166,230]
	SKIPLE	S.WORD		;SEE IF /WORD
	TRO	F,R.WORD	;YES--SET WORD MODE

;HERE TO SEE IF IT IS A DISK
;USE WILD TO PROCESS ALL CONSECUTIVE DISK REQUESTS AS ONE

DSKLOP:	PUSH	P,FSTR		;SAVE OLD DEVICE
	PUSH	P,OPENBL	;  AND OLD /PHYSICAL
	MOVE	T1,[5,,[I.NXRD,,I.NXZR
			OPENBL,,LBLOCK
			I.LZER,,LN$RIB+1
;**;[332], DSKLOP+5L ,MD ,16-JAN-76
			<(1B1!1B2!1B3)>!DC,,I  ;[332]			[207,311]
						;[332] 1B3 = SEARCH SYS AFTER NEW
			WLDEOD ]]	;			[205]
	PUSHJ	P,.LKWLD##	;GET NEXT FILE
	  JRST	DIRED		;ALL DONE--OUTPUT TOTALS
	PUSHJ	P,CHKNXF	;CHECK FOR NON-EXISTENT PREVIOUS FILE
	POP	P,T2		;RESTORE OLD PHYSICAL
	XOR	T2,OPENBL	;COMPARE /PHYS
	POP	P,T1		;RESTORE OLD STRUCTURE
	JUMPL	T2,DOOPEN	;IF /PHYS DIFFERENT, DO OPEN
	CAMN	T1,FSTR		;SEE IF DIFFERENT
	JRST	DOLOOK		;NO--PROCEED
DOOPEN:	MOVEI	T1,.IOBIN	;SET BINARY MODE		[166]
	HRRM	T1,OPENBL	;  FOR THE OPEN
	MOVEI	T1,BFHD		;SET FOR OUR			[166]
	MOVEM	T1,OPENBL+.OPBUF  ;  BUFFERS			[166]
	MOVE	T1,SVJBFF	;RESTORE INPUT
	MOVEM	T1,.JBFF	; .JBFF
	OPEN	DC,OPENBL	;OPEN DATA CHANNEL
	  JRST	[PUSHJ P,E.DFO##
		 JRST  DSKLOP]
	INBUF	DC,NM$DBF	;INITIALIZE BUFFER RING
				CONT.
;HERE TO LOOKUP FILE

DOLOOK:	TRZ	F,R.ACCS	;CLEAR ACCESS NEEDED FLAG
	TRNE	F,R.FAST	;SEE IF SUPER-SPEEDY MODE
	SKIPLE	S.SUM		;AND NOT /SUM
	JRST	DOLOK1		;NO--DO LOOKUP
	SKIPL	.WLDFL##	;YES--SEE IF WILD CARD
	JRST	DOLOK1		;NO--NEED A LOOKUP
	SKIPG	S.SUM		;SEE IF/SUM			[221]
	SKIPLE	S.AUT		; OR IF /AUTH			[221]
	JRST	DOLOK1		;YES--FORCE LOOKUP		[221]
	SKIPG	S.CHK		;SEE IF /CHECKSUM		[221]
	SKIPL	S.ACCS		;SEE IF /ACCESS			[221]
	JRST	DOLOK1		;YES--FORCE LOOKUP		[221]

	PUSH	P,I		;SAVE SPEC INDEX		[237]
	MOVE	I,.WIFIR##	;START AT START
DOLOOP:	SKIPG	.FXBFR(I)	;SEE IF /BEFORE			[237]
	SKIPLE	.FXSNC(I)	; OR /SINCE			[237]
	JRST	DOLOK0		;YES--NEED A LOOKUP		[237]
	SKIPG	.FXABF(I)	;SEE IF /ABEFORE		[237]
	SKIPLE	.FXASN(I)	; OR /ASINCE			[237]
	JRST	DOLOK0		;YES--NEED A LOOKUP		[237]
	SKIPG	.FXFLI(I)	;SEE IF MIN /LENGTH		[237]
	SKIPL	.FXFLM(I)	; OR MAX /LENGTH		[237]
	JRST	DOLOK0		;YES--NEED A LOOKUP		[237]
	ADDI	I,I.LZER	;ON ONE FILE SPEC		[237]
	CAMG	I,.WILAS##	;SEE IF DONE ALL		[237]
	JRST	DOLOOP		;NO, LOOP			[237]
	POP	P,I		;YES, NO LOOKUP			[237]
	JRST	GOANAL		; AND GO ANALYZE		[237]
DOLOK0:	POP	P,I		;SOMEONE NEEDS A LOOKUP		[237]
				CONT.
;HERE WHEN WE CAN NOT SKIP THE LOOKUP

DOLOK1:	MOVEI	T1,0		;PRESET FOR LEVEL D
	TLNN	F,L.LEVD	;SEE IF C
	MOVEI	T1,2		;YES--CHANGE POINTER
	PUSH	P,UFDPPN	;SAVE ARGUMENT DIRECTORY
	LOOKUP	DC,LBLOCK(T1)	;LOOKUP FILE TO GET ITS DATA
	  JRST	[POP   P,UFDPPN
		 PUSHJ P,E.DFLL
		 JRST  DSKLOP]
	SKIPG	S.DTL		;SEE IF /DETAIL			[200]
	JRST	DOLOK2		;NO--SKIP ON			[200]
	USETI	DC,0		;POSITION TO RIB		[200]
	IN	DC,		;READ RIB			[200]
	  SKIPA	T1,BFHD+.BFPTR	;GET BUFFER POINTER		[200]
	JRST	DOLOK2		;ERROR--CAN'T READ RIB		[200]
	MOVE	T1,200(T1)	;GET POINTER TO SELF		[200]
	SETZM	BFHD+.BFCTR	;CLEAR COUNT TO FORCE NEW BLOCK	[200]
	MOVEM	T1,FRIBLK	;SAVE FOR OUTPUT		[200]
DOLOK2:	AOS	NXFCNT		;COUNT AS A SUCCESSFUL FILE
	POP	P,T1		;RESTORE ARGUMENT DIRECTORY
	SKIPN	UFDPPN		;SEE IF CLOBBERED BY MONITOR
	MOVEM	T1,UFDPPN	;YES--RESTORE ARGUMENT
IFN FT$SFD,<
	JUMPN	T1,GOANAL	;IF NOT 0 ARG, THEN LOKWLD DID ITS JOB
	MOVEI	T1,DC		;  IT DIDN'T--ASK MONITOR
	MOVEM	T1,THSPTH	;SET FOR CHANNEL STYLE CALL
	MOVE	T1,[3+LN$DRB,,THSPTH]
	PATH.	T1,		;ASK MONITOR
	  JRST	GOANAL		;GIVE UP IF MONITOR IS UPITY
	MOVEI	T1,THSPTH	;OK--SET POINTER
	MOVEM	T1,UFDPPN	;FOR REST OF PROGRAM
>

GOANAL:	PUSHJ	P,ANALYZ	;GO ANALYZE AND PRINT RESULTS
	  SOS	NXFCNT		;DIDN'T MATCH AFTER ALL
	JRST	DSKLOP		;AND LOOP BACK FOR MORE
;HERE AT END OF DISK DIRECTORY

DIRED:	POP	P,(P)		;CLEAN UP STACK
	EXCH	T1,(P)		;SAVE NEXT DEVCHR
	MOVEM	I,I.NXRD	;STORE PROGRESS
	JUMPE	T1,DIRDON	;IF NO DISKS PENDING, GO WRAP UP
	PUSHJ	P,CHKNXF	;CHECK FOR NON-EX. FILE LEFT OVER
	PUSHJ	P,DIRET		;GO OUTPUT TOTALS LINE

;HERE WHEN DONE WITH DISKS--SEE IF NEXT DEVICE IS
;REASONABLE AND GO DISPATCH

DIRDON:	MOVE	T1,SVJBFF	;RESTORE INPUT
	MOVEM	T1,.JBFF	; .JBFF
	TRZ	F,R.WORD	;CLEAR WORD SWITCH
	SETZM	H.ZER1		;CLEAR ACCUMULATION AREA
	MOVE	T2,[H.ZER1,,H.ZER1+1]  ; ..
	BLT	T2,H.EZER	; ..
	POP	P,T1		;RESTORE DEVCHR OF NEXT DEVICE
	CAMN	T1,[-1]		;SEE IF ALL DONE
	POPJ	P,		;YES--RETURN
	JUMPN	T1,NOTDON	;JUMP IF REAL DEVICE
	HLRZ	T1,I.DEV(I)	;NONE--SEE
	CAIN	T1,'TMP'	;  IF TMP???:
	JRST	TMPDIR		;YES--OUTPUT TEMP CORE
	JRST	E.NSD		;NO--NO SUCH DEVICE

NOTDON:	TLZ	F,L.LEVD	;CLEAR LEVEL D FLAG
	TLC	T1,-1-<(DV.TTA)> ;SEE IF			[161]
	TLCN	T1,-1-<(DV.TTA)> ;  NUL:			[161]
	JRST	E.NDD		;YES--ERROR			[161]
	TXNE	T1,DV.DTA	;SEE IF DECTAPE
	JRST	DTDIR		;YES--GO OUTPUT IT
IFN FT$MTA,<	;MAGTAPES
	TXNE	T1,DV.MTA	;SEE IF MAG TAPE
	JRST	MTDIR		;YES--GO OUTPUT IT
>;END IFN FT$MTA
	TXNN	T1,DV.DIR	;UNKNOWN--SEE IF DIRECTORY TYPE
	JRST	E.NDD		;NO--ISSUE MESSAGE
	JRST	E.UDV		;YES--ISSUE MESSAGE

;CALLED FROM WILD AT END OF DIRECTORY

WLDEOD:	PUSHJ	P,CHKNXF	;CHECK FOR NON-EX FILE ERROR	[205]
	TRNE	F,R.FAST	;IF /F				[205]
	SKIPLE	S.SUM		; AND NOT /SUM			[205]
	SKIPN	.WLDFL##	;SEE IF MULTIPLE DIRECTORIES	[205]
	PJRST	.TNEWL		;RETURN				[205,214]
	PJRST	SUBTOT		;YES--ISSUE SUBTOTALS		[205]
	SUBTTL	PERFORM MAG TAPE DIRECTORY LISTING

IFN FT$MTA,<	;MAGTAPES

;HERE WHEN MAG TAPE IS DISCOVERED

MTDIR:	MOVX	T1,FX.DIR	;SEE IF DIRECTORY SPECIFIED
	TDNE	T1,I.MOD(I)	; BY THE USER
	JRST	MTDIR3		;YES--GO USE IT
	MOVNI	T1,2		;SET FOR WILD
	MOVEM	T1,.WLDFL##	; FILE AND STRUCTURE
	MOVE	T1,.WIFIR##	;NO--RESET TO FULL WILDCARD ON TAPE
MTDIR1:	MOVSI	T2,-LN$DRB	;SET LENGTH OF BLOCK
	HRR	T2,T1		;START AT THIS AREA
MTDIR2:	SETOM	I.DIR(T2)	;SET WILD CARD IN MATCH
	SETZM	I.DIRM(T2)	;SET TO MATCH ALL
	AOS	T2		;ADVANCE BY 2
	AOBJN	T2,MTDIR2	;LOOP FOR WHOLE AREA
	ADDI	T1,I.LZER	;ADVANCE TO NEXT AREA
	CAMG	T1,.WILAS##	;SEE IF DONE
	JRST	MTDIR1		;NO--LOOP

MTDIR3:	SKIPN	T1,.WLDFL##	;SEE IF NO WILD FILE OR STR
	AOS	T1,.WLDFL##	;YES--MAKE WILD STR ONLY
	CAMN	T1,[-1]		;SEE IF WILD FILE ONLY
	SOS	.WLDFL##	;YES--MAKE WILD FILE AND STR
	SKIPLE	S.WORD		;SEE IF /WORD
	TRO	F,R.WORD	;YES--SET FLAG
	MOVE	T1,.JBFF	;SAVE .JBFF TO AVOID
	MOVEM	T1,MTSVFF	;  CORE GROWTH ON REOPENS
	PUSHJ	P,MTOPEN	;OPEN MAG TAPE
	  PJRST	E.DFO##		;GIVE UP IF NOT POSSIBLE
	MOVEI	T1,DC		;GET PHYSICAL			[166]
	DEVNAM	T1,		; NAME OF TAPE			[166]
	  MOVE	T1,I.DEV(I)	;(OR LOGICAL IF UNKNOWN)	[166]
	MOVEM	T1,MTNAME	;DRIVE FOR MESSAGES		[166]
	MOVE	T1,S.FILE	;SET /FILE
	MOVEM	T1,MTFLCT	;INTO FILE COUNTER
	SKIPE	S.REWS		;UNLESS /NOREW
	MTREW.	DC,		;REWIND TAPE TO START
	MTWAT.	DC,		;WAIT TO COMPLETE		[224]
>;END IFN FT$MTA
				CONT.
IFN FT$MTA,<	;MAGTAPES

	SETZB	P1,P2		;CLEAR REGISTERS FOR LATER	[172]
	MOVE	T4,[2,,T2]	;SETUP FOR 5.07 MTCHR.		[172]
	MOVEI	T2,DC		;POINT TO RIGHT CHANNEL		[172]
	MTCHR.	T4,		;TRY IT				[172]
	  JRST	MTDN57		;NOT 5.07 YET			[172]
	MOVE	T2,T4		;OK--COPY AC BITS		[172]
	MOVE	P2,T3		;SAVE REELID			[172]
	TRNE	T4,1B32		;COPY 7-TRACK FLAG		[172]
	TRO	P1,1B32		;(SAME AS DEVSTS)		[172]
	TRNE	T4,1B31		;COPY RING STATUS		[172]
	TRO	P1,1B33		;(SAME AS DEVSTS)		[172]
	JRST	MTDI57		;AND PROCEED			[172]

MTDN57:	SETOM	P1		;FLAG DEVSTS NEEDED		[172]
	MOVEI	T2,DC		;GET TAPE DENSITY
	MTCHR.	T2,		; FROM MONITOR
	  JRST	[GETSTS DC,T2	;NO--FROM INIT
		 ANDI	T2,IO.DEN  ;JUST GET DENSITY
		 JUMPE	T2,MTNODN  ;JUMP IF UNKNOWN
		 LSH	T2,^D33-^L<IO.DEN>  ;POSITION
		 JRST	.+1]	;PROCEED
MTDI57:	MOVEI	T1,[ASCIZ /   Read Density:/]
	PUSHJ	P,.TSTRG##	;LIST LABEL
	ANDI	T2,7		;MASK TO DENSITY
	MOVE	T2,[ASCIZ /???/
		    ASCIZ /200/
		    ASCIZ /556/
		    ASCIZ /800/
		    ASCIZ /1600/
		    ASCIZ /6250/
		    ASCIZ /(6)/
		    ASCIZ /(7)/](T2)
	MOVEI	T1,T2		;SET MESSAGE
	PUSHJ	P,.TSTRG##	;LIST IT
>;END IFN FT$MTA
				CONT.
IFN FT$MTA,<	;MAGTAPES

MTNODN:	MOVEI	T1,[ASCIZ /  Parity:/]
	PUSHJ	P,.TSTRG##	;LABEL
	MOVEI	T1,[ASCIZ /Odd/]
	STATZ	DC,IO.PAR
	  MOVEI	T1,[ASCIZ /Even/]
	PUSHJ	P,.TSTRG##	;LIST PARITY
	PUSHJ	P,NEXOVW	;FORCE SOME I/O			[222]
	  TLO	F,L.FKEF	;SET EOF FLAG
	PUSH	P,T1		;SAVE WORD
	JUMPGE	P1,MTNODO	;SKIP DEVSTS IF 5.07		[172]
	MOVEI	P1,DC		;NOW GET DEVICE STATUS
	DEVSTS	P1,		;(HARDWARE STATUS SINCE SOFTWARE LOOSES)
	  JRST	MTNODS		;GIVE UP IF WE CAN'T
MTNODO:	MOVEI	T1,[ASCIZ /  7-Track/]
	TRNN	P1,1B33		;CHECK NUMBER OF TRACKS
	MOVEI	T1,[ASCIZ /  9-Track/]
	PUSHJ	P,.TSTRG##	;LIST THAT
	MOVEI	T1,[ASCIZ /  Read only/]
	TRNN	P1,1B32		;CHECK WRITE LOCK
	MOVEI	T1,[ASCIZ /  Write enabled/]
	PUSHJ	P,.TSTRG##	;LIST THAT
	JUMPE	P2,MTNODS	;DONE IF NO REELID		[172]
	MOVEI	T1,[ASCIZ /  REELID:/]		;		[172]
	PUSHJ	P,.TSTRG##	;ISSUE PREFIX			[172]
	MOVE	T1,P2		;GET ID				[172]
	PUSHJ	P,.TSIXN##	;OUTPUT IT			[172]

MTNODS:	PUSHJ	P,.TCRLF##	;END LINE
	POP	P,T1		;RESTORE DATA READ
	TLZN	F,L.FKEF	;CHECK IF EOF
	JRST	MTEXAM		;NO--GO HANDLE DATA
	N$WARN	(TSM,Tape starts with tape mark)
MTSTEF:	PUSHJ	P,MTOPEN	;REOPEN TO CLEAR EOF
	  JRST	E.DFO##		;GIVE UP IF IT WENT AWAY
	JUMPE	T1,MTDONX	;EXIT IF /FILE COUNTED OUT
	PUSHJ	P,NEXOVW	;AGAIN, TRY TO READ A WORD	[222]
	  JRST	.+2		;ANOTHER EOF
	JRST	MTEXAM		;NO--GO EXAMINE TAPE
	N$WARN	(ATM,     and another tape mark)
	JRST	MTSTEF		;LOOP UNTIL WE GET SOME DATA
>;END IFN FT$MTA
IFN FT$MTA,<	;MAGTAPES

;HERE WHEN DEVICE IS OPEN AND TIME TO LOOK AT NEXT FILE TO SEE IF
;IT IS A SAVE SET
;FORMATS:	IF THE FIRST WORD IS NON-ZERO AND,
;	0-17 = 0, THEN BACKUP FORMAT
;	0-14 = 0, 15-17 NOT 0, THEN FRS FORMAT
;	0-17 = 1???, THEN .EXE OR SOME SUCH
;	0-17 GE 27, THEN FAILSA (LEVEL-D) FORMAT
;     [ 0-5 NOT 0, 6-17 = 0, THEN OLD BACKUP/RESTORE FORMAT ]
;	0-17 NEGATIVE, THEN EITHER:
;		ASCII OR SIXBIT LABEL
;		HRI FORMAT
;		SAVE FORMAT

MTFIND:	PUSHJ	P,NEXOVW	;GET NEXT WORD			[222]
	  JRST	MTEOF		;END OF FILE--GO HANDLE THAT CASE
MTEXAM:	MOVEM	T1,CHKSUM	;SETUP CHECKSUM IN CASE THAT'S IMPORTANT
	MOVEI	T2,1		;SET WORD COUNTER
IFN FT$MTB,<	;BACKUP/FRS
	TLNN	T1,777770	;SEE IF FRS OR BACKUP		[230]
	JUMPN	T1,MTFRSS	;YES--GO HANDLE			[230]
>;END IFN FT$MTB
IFN FT$MTR,<	;OLD BACKUP/RESTORE
	TLNN	T1,7777		;SEE IF OLD BACKUP/RESTORE SAVE SET
	JRST	MTBKSS		;YES--GO PROCESS
>;END IFN FT$MTR
	TLNN	T1,776000	;IF 1???			[306]
	TLNN	T1,1000		; ..				[306]
	SKIPA			;NO--PROCEED			[306]
	JRST	MTIOW		;YES--HANDLE AS SAVE FILE	[306]
IFN FT$MTF, JUMPG T1,MTSVST	;JUMP IF LOOKS LIKE FAILSA SAVE SET
>;END IFN FT$MTA
				CONT.
IFN FT$MTA,<	;MAGTAPES

	MOVE	T3,T1		;GET COPY OF WORD
	TRZ	T3,77777	;REDUCE TO FIRST THREE ASCII CHARS
	MOVSI	T4,-LNLBLT	;POINT TO LABEL TYPES TABLE
	CAME	T3,LABTYP(T4)	;SEE IF ASCII LABEL
	AOBJN	T4,.-1		;LOOP TO MATCH
	JUMPL	T4,MTLABL	;YES--GO READ ASCII LABEL
	TRZ	T3,-1		;CLEAR DOWN TO SIXBIT TYPE	[213]
	MOVSI	T4,-LNLB6T	;POINT TO SIXBIT LABELS TABLE	[213]
	CAME	T3,LABTY6(T4)	;SEE IF SIXBIT LABEL		[213]
	AOBJN	T4,.-1		;LOOP TO MATCH			[213]
	JUMPL	T4,MTLAB6	;YES--GO READ SIXBIT LABEL	[213]
	JRST	MTIOW		;ELSE, GO READ AS SAVE OR HRI FILE

;ASCII LABELS
LABTYP:	ASCII	/VOL/		;BEGINNING OF VOLUME
	ASCII	/UVL/		;USER VOLUME
	ASCII	/EOV/		;END OF VOLUME
	ASCII	/UTL/		;USER TRAILER
	ASCII	/HDR/		;BEGINNING OF FILE
	ASCII	/UHL/		;USER HEADER
	ASCII	/EOF/		;END OF FILE
LNLBLT==.-LABTYP

;SIXBIT LABELS
LABTY6:	SIXBIT	/VOL/		;BEGINNING OF VOLUME
	SIXBIT	/UVL/		;USER VOLUME
	SIXBIT	/EOV/		;END OF VOLUME
	SIXBIT	/UTL/		;USER TRAILER
	SIXBIT	/HDR/		;BEGINNING OF FILE
	SIXBIT	/UHL/		;USER HEADER
	SIXBIT	/EOF/		;END OF FILE
LNLB6T==.-LABTY6
>;END IFN FT$MTA
IFN FT$MTA,<	;MAGTAPES

;HERE WHEN THE FILE IS AN IOWD (IE, SAVE OR HRI FORMAT) OR .EXE

MTIOW:	SETOM	P1		;SET FLAG FOR FIRST IOWD
	SETZM	FVER		;CLEAR VERSION NUMBER
	JUMPG	T1,MTEXE	;IF .EXE, GO HANDLE		[306]
MTIOWD:	MOVE	T3,T1		;GET COUNT OF IOWD
	JUMPE	T1,MTIOHR	;IF ZERO, JUNK OR HRI FORMAT
	AOS	P1		;ADVANCE IOWD COUNTER
	JUMPG	T1,MTIOJK	;JUMP IF JUNK FORMAT
MTIODT:	PUSHJ	P,NEXDTW	;GET DATA WORD
	  JRST	MTIOJF		;JUMP IF EOF
	AOS	T2		;COUNT WORD READ
	MOVEI	T4,1(T3)	;GET LOCATION OF DATA
	CAIN	T4,.JBVER	;SEE IF VERSION NUMBER
	MOVEM	T1,FVER		;YES--SAVE FOR LATER
	MOVE	T4,T1		;SAVE DATA WORD IN CASE OF HRI FORMAT
	AOBJN	T3,MTIODT	;COUNT OFF WORDS IN IOWD
	PUSHJ	P,NEXDTW	;GET NEXT IOWD OR JRST
	  JRST	MTIOHE		;SEE IF HRI FORMAT
	AOS	T2		;COUNT WORD READ
	JUMPLE	T1,MTIOWD	;LOOP IF ANOTHER IOWD
	MOVE	T4,T1		;NO--SAVE DATA WORD (MAYBE JRST WORD)

MTIODN:	PUSHJ	P,NEXDTW	;GET ANY MORE OF RECORD
	  JRST	.+2		;JUMP TO OUTPUT
	AOJA	T2,MTIODN	;LOOP UNTIL DONE
	MOVEI	P1,[ASCIZ /  Save format:    length = /]
	JRST	MTIOJM		;GO CHECK FOR JRST WORD

;HERE IF LOOKS LIKE HRI FORMAT

MTIOHR:	PUSHJ	P,NEXDTW	;IF ONLY ZEROS TO EOF
	  JRST	MTIOHE		;  THEN MUST BE OK
	JUMPN	T1,MTIOJK	;NO--JUNK
	AOJA	T2,MTIOHR	;LOOP TO EOF

MTIOHE:	JUMPN	P1,MTIOJK	;JUNK IF NOT FIRST IOWD
	MOVE	T1,T4		;RESTORE LAST DATA WORD
	MOVEI	P1,[ASCIZ /  HRI format:     length = /]
	SETZM	FVER		;CLEAR VERSION NUMBER
	JRST	MTIOJM		;GO FINISH UP			[306]
>;END IFN FT$MTA
				CONT.
IFN FT$MTA,<	;MAGTAPES
MTEXE:	MOVEI	T3,0		;CLEAR PROGRESS COUNT		[306]
	JRST	MTEX.1		;START WITH FIRST WORD
MTEX.0:	PUSHJ	P,NEXDTW	;GET BLOCK TYPE OF HEADER
	  JRST	MTIOJF		;NONE IF EOF
	AOS	T2		;COUNT WORD
	AOS	T3		;COUNT WORD
MTEX.1:	HLRZ	P1,T1		;GET BLOCK TYPE
	CAIN	P1,1776		;SEE IF EXE DIRECTORY
	JRST	MTEX.3		;YES--GO LOOKUP PAGE 0
	CAIL	P1,1776		;IF NOT VALID TYPE,
	JRST	MTIOJK		; EXIT WITHOUT VERSION
	HRRZ	P1,T1		;OK--GET BLOCK SIZE
MTEX.2:	SOJLE	T1,MTEX.0	;(ALLOW FOR FIRST WORD)
	PUSHJ	P,NEXDTW	;SKIP THIS BLOCK
	  JRST	MTIOJF		;GIVE UP IF EOF
	AOS	T2		;COUNT WORD
	AOS	T3		;COUNT PROGRESS
	JRST	MTEX.2		;LOOP
MTEX.3:	HRRZ	T4,T1		;DIRECTORY--GET SIZE
	LSH	T4,-1		;GET COUNT OF BIWORDS
MTEX.4:	SOJL	T4,MTIOJK	;GIVE UP IF NOT IN DIRECTORY
	PUSHJ	P,NEXDTW	;GET FIRST WORD OF PAIR
	  JRST	MTIOJF		;GIVE UP IF END
	AOS	T2		;COUNT WORD
	MOVE	P1,T1		;SAVE FOR A MINUTE
	PUSHJ	P,NEXDTW	;GET SECOND WORD OF PAIR
	  JRST	MTIOJF		;GIVE UP
	AOS	T2		;COUNT WORD
	ADDI	T3,2		;COUNT PROGRESS
	TRNE	T1,-1		;SEE IF PAGE 0
	JRST	MTEX.4		;NO--LOOP OVER DIRECTORY
	HRRZ	T4,P1		;GET POSITION IN FILE
	LSH	T4,^D9		;CONVERT TO WORDS
	SUB	T4,T3		;ALLOW FOR CURRENT POSITION
	JUMPLE	T4,MTIOJK	;ERROR IF BEHIND US
	ADDI	T4,.JBVER	;SET TO VERSION LOCATION
MTEX.5:	PUSHJ	P,NEXDTW	;ADVANCE TO WORD
	  JRST	MTIOJF		;GIVE UP IF END
	AOS	T2		;COUNT WORD
	SOJGE	T4,MTEX.5	;LOOP THROUGH .JBVER


MTEX.9:	PUSHJ	P,NEXDTW	;LOOP TO END
	  SKIPA			;DONE
	AOJA	T2,MTEX.9	;LOOP
	MOVEI	P1,[ASCIZ /  .EXE format:    length = /]
	MOVEI	T4,0		;INDICATE NO START ADDRESS KNOWN
	JRST	MTIOJN		;OUTPUT MESSAGE			[306]
>;END IFN FT$MTA
				CONT.
IFN FT$MTA,<	;MAGTAPES

;HERE WHEN DONE WITH HRI OR SAVE FORMAT READ

MTIOJM:	HLRZ	T3,T4		;SEE IF START
	TRZ	T3,(<HALT>-<JRST>)  ;CLEAR HALT BITS
	CAIE	T3,(JRST)	;TEST FOR JUMP
	JRST	MTIOJK		;NO--JUNK
MTIOJN:	MOVE	M,P1		;FETCH CORRECT MESSAGE
	PUSHJ	P,LSTR		;TYPE LABEL
	MOVE	T1,T2		;GET LENGTH IN WORDS
	PUSHJ	P,LDEC		;LIST DECIMAL
	MOVEI	M,[ASCIZ /, start = /]
	SKIPE	T4		;IF KNOWN,
	PUSHJ	P,LSTR		;LIST LABEL
	HRRZ	T1,T4		;GET START ADDRESS
	SKIPE	T4		;IF KNOWN,
	PUSHJ	P,LOCT		;LIST OCTAL
	MOVEI	M,[ASCIZ /, checksum = /]
	PUSHJ	P,LSTR		;LIST LABEL
	PUSHJ	P,LCHECK	;LIST CHECKSUM
	MOVEI	M,[ASCIZ /, version = /]
	SKIPE	T4,FVER		;SEE IF VERSION
	PUSHJ	P,LSTR		;YES--PREFIX IT
	PUSHJ	P,LVER		;AND LIST IT
	PUSHJ	P,LCRLF		;END LINE
	JRST	MTEF		;JUMP TO END OF FILE PROCESSING
>;END IFN FT$MTA
IFN FT$MTA,<	;MAGTAPES

;HERE IF JUNK BUT NOT YET EOF

MTIOJK:	PUSHJ	P,NEXDTW	;GET NEXT WORD
	  JRST	MTIOJF		;JUMP WHEN DONE
	AOJA	T2,MTIOJK	;LOOP COUNTING WORDS

;HERE IF JUNK AT EOF

MTIOJF:	MOVEI	M,[ASCIZ /  Unknown format: length =/]
	PUSHJ	P,LSTR		;LIST LABEL
	MOVE	T1,T2		;GET LENGTH
	PUSHJ	P,LDEC		;LIST DECIMAL
	MOVEI	M,[ASCIZ /, checksum = /]
	PUSHJ	P,LSTR		;LIST LABEL
	PUSHJ	P,LCHECK	;LIST CHECKSUM
	PUSHJ	P,LCRLF		;END LINE

;HERE AT EOF AFTER JUNK OR IOWD FILE

MTEF:	MOVEI	M,[ASCIZ /<Tape mark>
/]
MTEFM:	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--TELL USER
MTEFX:	REPEAT	0,<		;NEED THIS ONLY IF TAPE ENDS WITH 3 EOFS
	PUSHJ	P,MTOPEN	;REOPEN MAG TAPE TO CLEAR EOF BIT
	  PJRST	E.DFO##		;GACK!
	JUMPE	T1,MTDONX	;EXIT IF /FILE COUNTED OUT
	JRST	MTFIND		;NEW FILE--GO PROCESS IT
>
	JRST	MTEOFH		;HANDLE EOF


;HERE AFTER NEW FILE FOUND EOF

MTEOF:	MOVEI	M,[ASCIZ /<Tape mark>
/]
	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--LIST COMMENT
MTEOFH:	PUSHJ	P,MTOPEN	;REOPEN MAG TAPE TO CLEAR EOF BIT
	  PJRST	E.DFO##		;GACK!!
	JUMPE	T1,MTDONX	;JUMP IF DONE WITH /FILES
	PUSHJ	P,NEXOVW	;READ WORD TO SEE IF DOUBLE EOF	[222]
	  JRST	.+2		;YES--CLEAN UP
	JRST	MTEXAM		;NO--START OVER
	MOVEI	M,[ASCIZ /<Second tape mark in succession>
/]
	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--LIST COMMENT
	JRST	MTDONE		;AND GO FINISH UP
>;END IFN FT$MTA
IFN FT$MTA,<	;MAGTAPES

;HERE WHEN ANSI-LIKE TAPE LABEL SEEN

MTLAB6:	MOVEI	M,[ASCIZ /	 SIXBIT Label "/]
	TROA	F,R.LBSX	;INDICATE SIXBIT LABEL		[213]
MTLABL:	MOVEI	M,[ASCIZ /	 Label "/]
MTLABR:	MOVE	T4,BFHD+.BFCTR	;GET LENGTH			[166]
MTLABS:	PUSHJ	P,LSTR		;LIST PREFIX
	MOVEI	T2,^D80/5	;GET ASCII LABEL LENGTH		[213]
	TRNE	F,R.LBSX	;SEE IF SIXBIT			[213]
	MOVEI	T2,^D80/6	;YES--GET SIXBIT LABEL LENGTH	[213]
				;NOTE--COBOL WRITES 78 CHARS, NOT 84
	CAIE	T4,-1(T2)	;SEE IF STANDARD LABEL LENGTH	[213]
	TLO	F,L.ILEN	;NO--SET FLAG
	MOVEI	P1,1(T4)	;SET END TO LENGTH
	CAILE	P1,(T2)		;BUT NOT BEYOND			[213]
	MOVEI	P1,(T2)		;  STANDARD LENGTH		[213]
	MOVEI	T2,1		;PRESET WORD COUNT
MTLAB1:	MOVE	T4,T1		;MOVE WORD TO PAIR
	MOVEI	T1,5		;SET TO COUNT CHARS
	TRNE	F,R.LBSX	;IF SIXBIT,			[213]
	MOVEI	T1,6		; GET 6 CHARS PER WORD		[213]

;HERE FOR EACH CHARACTER IN LABEL

MTLAB2:	MOVEI	T3,0		;CLEAR RESULT
	TRNE	F,R.LBSX	;SEE IF SIXBIT LABEL		[213]
	JRST	[LSHC T3,6	;YES--GET NEXT CHAR		[213]
		 ADDI T3,40	;CONVERT TO ASCII		[213]
		 JRST MTLAB4]	;AND GO OUTPUT IT		[213]
	LSHC	T3,7		;GET CHAR
	CAILE	T3,37		;SEE IF CONTROL CHAR (OR NULL)
	JRST	MTLAB3		;NO--PROCEED
	MOVEI	C,"^"		;YES--LIST FLAG
	PUSHJ	P,LCHR		; FOR USER
	ADDI	T3,100		;CONVERT TO ALPHA
MTLAB3:	CAIGE	T3,140		;SEE IF LOWER CASE
	JRST	MTLAB4		;NO--PROCEED
	MOVEI	C,"'"		;YES--LIST FLAG
	PUSHJ	P,LCHR		; FOR USER
	SUBI	T3,40		;CONVERT TO UPPER CASE
MTLAB4:	MOVE	C,T3		;GET CHAR
	PUSHJ	P,LCHR		;LIST
	SOJG	T1,MTLAB2	;LOOP FOR THIS WORD

	PUSHJ	P,NEXDTW	;GO GET NEXT WORD
	  JRST	MTLABX		;AT EOF
	CAIE	T2,(P1)		;DON'T GO TOO FAR
	AOJA	T2,MTLAB1	;LOOP DOWN LABEL
>;END IFN FT$MTA
				CONT.
IFN FT$MTA,<	;MAGTAPES

	TLO	F,L.FKEF	;TOO FAR, SET FAKE EOF FLAG
	MOVE	P1,T1		;SAVE WORD FOR LATER

;HERE AT END OF LABEL

MTLABX:	TRZ	F,R.LBSX	;CLEAR SIXBIT LABEL INDICATOR	[213]
	MOVEI	C,""""		;END OF QUOTE
	PUSHJ	P,LCHR		;LIST END
	PUSHJ	P,LCRLF		;END LINE
	TLNN	F,L.ILEN!L.FKEF	;SEE IF BAD LENGTH
	JRST	MTEF		;NO--GO CLEAR EOF AND PROCEED
	TLZN	F,L.ILEN	;TEST INCORRECT LENGTH
	JRST	MTLNOK		;LENGTH OK
	N$WARN	(ILL,Incorrect length for label)
MTLNOK:	TLZN	F,L.FKEF	;CLEAR FAKE EOF
	JRST	MTEF		;NOT SET--PROCEED
IFN FT$MTR,<	;OLD BACKUP/RESTORE
	TLZE	F,L.IMLB	;SEE IF IMBEDDED LABEL
	JRST	MTBKSR		;YES--RETURN TO THAT LOOP
>;END IFN FT$MTR

	MOVE	T3,P1		;GET NEXT WORD
	TRZ	T3,77777	;REDUCE TO FIRST THREE ASCII CHARS
	MOVSI	T4,-LNLBLT	;POINT TO LABEL TYPES TABLE
	CAME	T3,LABTYP(T4)	;SEE IF LABEL
	AOBJN	T4,.-1		;LOOP TO MATCH
	JUMPL	T4,MTLBCN	;CONSECUTIVE LABELS
	TRZ	T3,-1		;REDUCE TO FIRST THREE SIXBIT CHARS	[213]
	MOVSI	T4,-LNLB6T	;POINT TO SIXBIT LABEL TYPES TABLE	[213]
	CAME	T3,LABTY6(T4)	;SEE IF SIXBIT LABEL		[213]
	AOBJN	T4,.-1		;LOOP TO MATCH			[213]
	JUMPL	T4,MTLBC6	;CONSECUTIVE SIXBIT LABELS	[213]
	N$WARN	(MTM,Missing tape mark after label)
	MOVE	T1,P1		;RESTORE WORD
	JRST	MTEXAM		;AND GO EXAMINE DATA

MTLBC6:	MOVEI	M,[ASCIZ / Grouped SIXBIT label "/]
	TROA	F,R.LBSX	;SET SIXBIT LABEL FLAG		[213]
MTLBCN:	MOVEI	M,[ASCIZ / Grouped label "/]
	MOVE	T1,P1		;RESTORE WORD
	JRST	MTLABR		;GO DO NEXT LABEL
>;END IFN FT$MTA
	SUBTTL	PERFORM MAG TAPE DIRECTORY LISTING--OLD BACKUP/RESTORE

IFN FT$MTR,<	;OLD BACKUP/RESTORE

MTBKSR:	PUSHJ	P,NEXOVW	;GET NEXT CONTROL WORD
	  JRST	E$$MBS		;UNEXPECTED EOF
MTBKSS:	TLO	F,L.LEVD	;SET LEVEL-D DATA
	MOVEM	T1,MTSVVR	;SAVE HEADER WORD
	HLRZ	T2,T1		;GET CONTROL WORD
	CAIE	T2,100000	;SEE IF FILE HEADER
	CAIN	T2,200000	;SEE IF DIRECTORY HEADER
	JRST	MTBKLK		;YES--GO READ LOOKUP BLOCK
	CAIN	T2,40000	;SEE IF IMBEDDED LABEL
	JRST	MTBKIL		;YES--GO HANDLE IT

;HERE WHEN JUNK IN OLD BACKUP/RESTORE SET

	N$WARN	(JBS,Junk during BACKUP/RESTORE save set)
MTBKJL:	TLO	F,L.BKSS	;SET FLAG FOR SAVE SET
	PUSHJ	P,NEXOVW	;READ ON
	  JRST	MTBKJM		;AT END OF DATA
	MOVE	T1,BFHD+.BFCTR	;GET DATA LEFT IN BLOCK		[166]
	SOJG	T1,MTBKJL	;SOME--LOOP THRU DATA
MTBKJM:	TLZ	F,L.BKSS!L.FKEF	;CLEAR FLAGS
	PUSHJ	P,NEXOVW	;LOOK AT RESULTS
	  JRST	MTBKJG		;EOF--GO HANDLE
	HLRZ	T2,T1		;GET HEADER TYPE
	CAIE	T2,100000	;SEE IF DIRECTORY
	CAIN	T2,200000	; OR FILE HEADER
	JRST	MTBKSS		;YES--GO PROCESS IT
	CAIN	T2,40000	;SEE IF LABEL
	JRST	MTBKIL		;YES--GO HANDLE
	JRST	MTBKJL		;NO--LOOP ONWARDS
>;END IFN FT$MTR
IFN FT$MTR,<	;OLD BACKUP/RESTORE

;HERE AT UNEXPECTED EOF

	N$WARN	(MBS,Tape mark during BACKUP/RESTORE save set)
MTBKJG:	JRST	MTEFX		;GO ISSUE MESSAGE

;HERE AT IMBEDDED LABEL

MTBKIL:	ANDI	T1,777		;GET LABEL LENGTH
	SOSG	T4,T1		;MOVE TO LOC. FOR LABEL PRINTER
	JRST	E$$JBS		;NO--JUNK
	TLO	F,L.IMLB	;YES--SET FLAG
	PUSHJ	P,NEXOVW	;SKIP CHECKSUM
	  JRST	E$$MBS		;GIVE UP
	PUSHJ	P,NEXOVW	;GET START OF LABEL
	  JRST	MTBKIF		;GO HANDLE EOF
	MOVEI	M,[ASCIZ / Blocked label "/]
	JRST	MTLABS		;GO DO LABEL

;HERE WHEN IMBEDDED LABEL IS SEPARATE FILE

MTBKIF:	MOVEI	M,[ASCIZ /<Tape mark preceeded by label flag>
/]
	JRST	MTEFM		;GO ISSUE MESSAGE
>;END IFN FT$MTR
IFN FT$MTR,<	;OLD BACKUP/RESTORE

;HERE WHEN LOOKUP BLOCK COMING

MTBKLK:	MOVEI	T2,(T1)		;GET LOOKUP WORDS
	ANDI	T2,777		;CLEAR JUNK
	CAILE	T2,LN$RIB	;PROTECT LOOKUP AREA
	JRST	E$$JBS		;BAD--GIVE UP
	MOVEI	T3,0		;SET TO START OF LOOKUP BLOCK
	PUSHJ	P,NEXOVW	;GET NEXT WORD
	  JRST	E$$MBS		;BAD TO EOF HERE
				;THROW AWAY WORD
MTBKLL:	PUSHJ	P,NEXOVW	;GET NEXT LOOKUP WORD
	  JRST	E$$MBS		;BAD TO EOF IN MIDDLE
	MOVEM	T1,LBLOCK(T3)	;SAVE IN STANDARD AREA
	AOS	T3		;ADVANCE BLOCK
	SOJG	T2,MTBKLL	;LOOP UNTIL DONE
	HRRZ	T2,MTSVVR	;GET LENGTH AGAIN
	SOS	T2		;SUBTRACT ONE
	ANDI	T2,777		;MASK TO FORWARD LENGTH
	CAME	T2,RIBLEN	;COMPARE TO LOOKUP LENGTH
	JRST	E$$JBS		;BAD--GIVE UP
	TRNE	F,R.MARK	;SEE IF /MARKS
	JRST	MTBKLM		;YES--TYPE UFD
	HLRZ	T2,MTSVVR	;REFETCH HEADER
	CAIE	T2,100000	;SEE IF FILE HEADER
	JRST	MTBKNW		;NO--SKIP TO NEXT HEADER
>;END IFN FT$MTR
				CONT.
IFN FT$MTR,<	;OLD BACKUP/RESTORE

;HERE WHEN FILE HEADER IS IN LOOKUP AREA

MTBKLM:	MOVE	T1,FMTA		;GET MAG TAPE WORD
	MOVEM	T1,FSTR		;STORE AS STUCTURE
	SETZM	FMTA		;CLEAR OUT TAPE WORD
	TLO	F,L.BKSS	;SET SAVE SET FLAG
	PUSHJ	P,MTDOFL	;GO DO MAG TAPE FILE

	TLZ	F,L.BKSS!L.FKEF	;CLEAR SCREWBALL FLAGS
	HLRZ	T2,MTSVVR	;SEE WHAT KIND OF FILE
	CAIE	T2,100000	;CHECK FILE
	JRST	MTBKNW		;NO--SKIP BELOW
	PUSHJ	P,NEXOVW	;GET NEXT CONTROL
	  JRST	E$$MBS		;NEED END OF DATA FILE
	HLRZ	T2,T1		;GET TYPE
	CAIE	T2,20000	;SEE IF END OF FILE
	JRST	E$$JBS		;NO--JUNK
	PUSHJ	P,NEXOVW	;YES--GET CHECKSUM
	  JRST	E$$MBS		;ERROR IF ABSENT
MTBKNW:	PUSHJ	P,NEXOVW	;GET NEXT HEADER WORD
	  JRST	MTEF		;GO TO EOF PROCESSING
	TLNN	T1,7777		;SEE IF OLD BACKUP/RESTORE HEADER
	JRST	MTBKSS		;GO HANDLE HEADER
	PUSH	P,T1		;SAVE NEXT WORD
	N$WARN	(MMB,Missing tape mark after BACKUP/RESTORE save set)
	POP	P,T1		;RESTORE NEXT WORD
	JRST	MTEXAM		;GO EXAMINE THE DATA
>;END IFN FT$MTR
IFE FT$MTR,<
	E$$JBS==6B20	;SAVE SYMBOL
	E$$MBS==6B20	;SAVE SYMBOL
	E$$MMB==6B20	;SAVE SYMBOL
>;END IFE FT$MTB
	SUBTTL	PERFORM MAG TAPE DIRECTORY LISTING--FRS OR BACKUP

IFN FT$MTB,<	;BACKUP/FRS

MTFRSS:	SETZM	H.MZER		;CLEAR FOR THIS SAVESET
	MOVE	T3,[H.MZER,,H.MZER+1]
	BLT	T3,H.EMZR	; ..
	PUSHJ	P,FRSLAH	;DO BACKUP/FRS LOOK-AHEAD
	JRST	MTFRSH		;GO HANDLE HEADER

;BACK HERE AFTER EACH RECORD

MTFRSR:	PUSHJ	P,NEXOVW	;GET FIRST WORD
	  JRST	E$$MFS		;END OF FILE IS ERROR
	PUSHJ	P,FRSLAH	;DO BACKUP/FRS LOOK-AHEAD
IFN FT$MTS,<	;FRS
	HLLZ	T4,T1		;GET COPY OF FRS/BACKUP FLAG
	TLNE	T4,-1		;IF FRS,
	TLO	T4,-1		; SET WHOLE FLAG
	XOR	T4,B$GTYP	;COMPARE WITH PREVIOUS RECORD
	JUMPL	T4,E$$JFS	;JUNK IF DIFFERENT
>;END IFN FT$MTS

MTFRSH:	TLO	F,L.LEVD	;SET LEVEL-D FORMAT DATA
	TLNN	T1,-1		;SEE IF BACKUP FORMAT
	JRST	MTFRSP		;YES--GO HANDLE HEADER
IFN FT$MTS,<	;FRS
	TLNE	T1,777770	;SEE IF VALID FOR FRS		[240]
	JRST	E$$JFS		;NO, GO PROCESS AS JUNK		[240]
>;END IFN FT$MTS
>;END IFN FT$MTB
				CONT.
IFN FT$MTS,<	;FRS

;HERE IF FRS HEADER FORMAT--READ HEADER AND CONVERT TO BACKUP FORMAT

	HRLZM	T1,B$GFLG	;STORE FLAGS
	HLRZS	T1		;POSITION RECORD TYPE
	MOVE	T1,[0		;ERROR
		    1		;LABEL
		    2		;START SAVE SET
		    3		;END SAVE SET
		    4		;FILE DATA
		    5		;DIRECTORY DATA
		    0		;ERROR
		    0](T1)	;ERROR
	JUMPE	T1,MTIOJK	;JUNK IF ERROR(NOT FRS FORMAT)
	HRROM	T1,B$GTYP	;SET AS TYPE
	PUSHJ	P,NEXOVR	;GET RELATIVE VOLUME NUMBER
	  JRST	MTIOJF		;JUNK
	MOVEM	T1,B$GRTN	;SAVE
	MOVE	T4,B$GTYP	;GET TYPE
	MOVE	T4,FRSTBL-1(T4)	;GET TABLE OF TRANSLATIONS
MTFRSL:	MOVE	T1,(T4)		;GET -COUNT,,ITEM
	TLNN	T1,-1		;IF BLANK,			[302]
	TLO	T1,-1		; SET FOR ONE WORD		[302]
	PUSHJ	P,BLKOVR	;COPY TO STORAGE AREA		[302]
	  JRST	MTIOJF		;JUNK IF END			[302]
	AOBJN	T4,MTFRSL	;LOOP OVER HEADER
	JRST	MTFRSD		;GO HANDLE DATA PORTION
>;END IFN FT$MTS
IFN FT$MTS,<	;FRS

;FRS TRANSLATION TABLE POINTERS

FRSTBL:	-FRSLLB,,FRSTLB		;BACKUP 1=LABEL
	-FRSLSS,,FRSTSS		;BACKUP 2=START SAVE SET
	-FRSLSS,,FRSTSS		;BACKUP 3=END SAVE SET
	-FRSLFL,,FRSTFL		;BACKUP 4=FILE			[235]
	-FRSLDR,,FRSTDR		;BACKUP 5=DIRECTORY		[235]

;TABLES CONTAINING -NO WORDS (0=1),,ADDRESS TO STORE

FRSTLB:				;LABEL
	    B$LREL		;REEL
	-21,,B$LTIM		;TIME, DATE, DESTROY DATE, LABEL COMMENT
FRSLLB==.-FRSTLB


FRSTSS:				;START/END SAVE SET
	-5,,B$SSNM		;SYSTEM NAME
	    B$SSVR		;VERSION
	-2,,B$SFMT		;FORMAT VERSION, FRS VERSION
	-5,,B$STIM		;TIME, DATE, MODE, TRACKS, SAVE SET NAME
	    B$SDEV		;DEVICE				[300]
	-4,,B$SCMT		;COMMENT			[300]
FRSLSS==.-FRSTSS

FRSTDR:				;DIRECTORY
	    B$USTR		;UFD STRUCTURE
	    B$ULVL		;DIRECTORY LEVEL
	-20,,DIRB		;DISCARD JUNK
FRSLDR==.-FRSTDR


FRSTFL:				;FILE
	-11,,B$FSTR		;STR, NAME, EXT, PPN, REL BLK,
				;  CHECKSUM, BLKS IN REC,
				;  WRDS IN L.BLK, DIRECTORY LEVEL
	-11,,DIRB		;DISCARD JUNK
FRSLFL==.-FRSTFL
>;END IFN FT$MTS
				CONT.
IFN FT$MTB,<	;BACKUP/FRS
	N$WARN	(JFS,Junk during BACKUP/FRS save set)
MTFJKL:	SETZM	BFHD+.BFCTR	;CLEAR REST OF RECORD
	PUSHJ	P,NEXOVW	;GET START OF NEXT RECORD
	  JRST	MTFJKG		;EOF--GO HANDLE
	TLNE	T1,777770	;SEE IF OK YET
	JRST	MTFJKL		;NO--LOOP ON
	HLLZ	T4,T1		;GET BACKUP/FRS FLAG
	TLNE	T4,-1		;IF FRS,
	TLO	T4,-1		; SET WHOLE HALF WORD
	XOR	T4,B$GTYP	;COMPARE WITH FRS FLAG
	JUMPL	T4,MTFJKL	;IF DIFFERENT, JUNK
	JRST	MTFRSH		;ELSE, GO HANDLE HEADER

	N$WARN	(MFS,Tape mark during BACKUP/FRS save set)
MTFJKG:	JRST	MTEFX		;GO HANDLE EOF
>;END IFN FT$MTB
IFN FT$MTB,<	;BACKUP/FRS

;HERE TO HANDLE BACKUP STYLE HEADER

MTFRSP:	JUMPLE	T1,MTIOJK	;ERROR IF BAD TYPE		[302]
	CAILE	T1,T$MAX	;SEE IF VALID			[302]
	JRST	MTIOJK		;NO--ERROR			[302]
	MOVEM	T1,B$GTYP	;STORE TYPE			[302]
	MOVE	T1,[-^D11,,B$GBNM] ;GET REST			[302]
	PUSHJ	P,BLKOVR	; OF STANDARD HEADER		[302]
	  JRST	MTIOJF		;JUNK IF TRUNCATED		[302]

	MOVE	T1,B$GTYP	;GET TYPE
	MOVE	T1,[B$LBL	;1=LABEL
		    B$SSS	;2=START OF SAVE SET
		    B$SSS	;3=END OF SAVE SET
		    B$FIL	;4=FILE
		    B$DIR	;5=DIRECTORY
		    B$EOV	;6=END OF VOLUME
		    B$CMT	;7=COMMENT
		    B$SSS]-1(T1) ;10=CONTINUE SAVE SET
	HRLI	T1,-^D20	;SET REST OF HEADER LENGTH	[302]
	PUSHJ	P,BLKOVR	;GET REST OF HEADER		[302]
	  JRST	MTIOJF		;JUNK IF NOT ALL THERE		[302]

;HERE WHEN HEADER READ

MTFRSD:	MOVE	T4,B$GTYP	;GET RECORD TYPE
	JRST	@[MTFLBL	;1=LABEL
		  MTFSSS	;2=START OF SAVE SET
		  MTFESS	;3=END OF SAVE SET
		  MTFFIL	;4=FILE
		  MTFDIR	;5=DIRECTORY
		  MTFEOV	;6=END OF VOLUME
		  MTFCMT	;7=COMMENT
		  MTFCSS]-1(T4)	;10=CONTINUE SAVE SET
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

;HERE ON BACKUP/FRS LABEL RECORD

MTFLBL:	SETZM	BFHD+.BFCTR	;CLEAR REST OF BLOCK
	PUSHJ	P,NEXOVW	;GET EOF
	  SKIPA			;OK
	JRST	E$$JSS		;ERROR IF NOT EOF

	SKIPL	B$GTYP		;SEE IF BACKUP
	SKIPN	T1,B$LDDT	;GET LABEL DESTROY DATE
	JRST	MTFLB1		;CLEAR--LEAVE ALONE
	PUSHJ	P,.CNTDT##	;SPLIT IT
	MOVEM	T2,B$LDSD	;STORE DESTROY DATE
>;END OF IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

MTFLB1:	MOVEI	M,[ASCIZ /  BACKUP label /]
IFN FT$MTS,<	;FRS
	SKIPGE	B$GTYP		;IF FRS,
	MOVEI	M,[ASCIZ /  FRS label /]
>;END IFN FT$MTS
	PUSHJ	P,LSTR		;LIST LABEL
	MOVEI	M,[ASCIZ / reel=/]
	SKIPE	T2,B$LREL	;IF REEL,
	PUSHJ	P,LSTR		; LABEL OUTPUT
	PUSHJ	P,LSIX		; AND OUTPUT REEL
	MOVEI	M,[ASCIZ / destroy on /]
	SKIPE	T4,B$LDSD	;IF DESTROY DATE,
	PUSHJ	P,LSTR		; LABEL OUTPUT
	SKIPE	T4		; AND
	PUSHJ	P,LDATE		; OUTPUT DESTROY DATE
	PUSHJ	P,LCRLF		;END LINE

	MOVE	T1,[B$LCDT,,B$SCDT] ;COPY STANDARD STUFF
	BLT	T1,B$SMTC	; WHERE SAVE-SET HEADERS
	MOVE	T1,[B$LTIM,,B$STIM]
	BLT	T1,B$SDAT
	SETZM	B$SMOD
	SETZM	B$STRK
	SETZM	B$BSYS
	PUSHJ	P,MTFXSL	;ISSUE LINES COMMON TO SAVE-SET
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

	SKIPE	B$LCMT		;SEE IF COMMENT
	JRST	[PUSHJ P,LSPC5	;YES--SPACE IN
		 MOVEI M,[ASCIZ /Comment: /]
		 PUSHJ P,LSTR	;LABEL RESULT
		 SETZM B$LCMT+16 ;PROTECT ASCIZ
		 MOVEI M,B$LCMT	;POINT TO COMMENT
		 PUSHJ P,LSTR	;OUTPUT IT
		 PUSHJ P,LCRLF	;END LINE
		 JRST  .+1]
	JRST	MTEOF		;GO CLEAR FAKE EOF AND REPEAT BACKUP PROCESSING	[241]
>;END IFN FT$MTB
IFN FT$MTB,<	;BACKUP/FRS

;HERE ON BACKUP/FRS END OF VOLUME

MTFEOV:	SETZM	BFHD+.BFCTR
	PUSHJ	P,NEXOVW	;GET NEXT WORD
	  SKIPA			;EOF--OK
	JRST	E$$JFS		;ELSE JUNK

;HERE AFTER READING END OF VOLUME

	MOVEI	M,[ASCIZ /  BACKUP end of volume/]
	PUSHJ	P,LSTR		;INDICATE EOV
	JRST	MTENDS		;GO END LISTING OF SAVE SET

;HERE ON BACKUP/FRS COMMENT

MTFCMT:	SETZM	BFHD+.BFCTR	;CLEAR REST OF BLOCK
	PUSHJ	P,NEXOVW	;GET NEXT WORD
	  SKIPA			;EOF--OK
	JRST	MTIOJK		;ELSE JUNK

;HERE AFTER READING COMMENT

	MOVEI	M,[ASCIZ /  BACKUP comment: /]
	PUSHJ	P,LSTR		;INDICATE COMMENT
	MOVEI	M,B$CMT		;POINT TO COMMENT AREA
	PUSHJ	P,LSTR		;ISSUE IT
	JRST	MTENDS		;GO END LISTING OF SAVE SET

;HERE ON BACKUP/FRS END OF SAVE SET

MTFESS:	PUSHJ	P,MTFBGO	;UPDATE ANY OVERHEAD REGIONS	[302]
	  JRST	MTIOJK		;ERROR IF GARBAGED		[302]
	SETZM	BFHD+.BFCTR	;DISCARD REST OF BLOCK
	PUSHJ	P,NEXOVW	;GET NEXT WORD
	  SKIPA			;EOF--OK
	JRST	MTIOJK		;ELSE JUNK

;HERE AFTER READING END OF SAVE SET

	PUSHJ	P,DIRE		;GIVE TOTAL LINE
	MOVEI	T1,[ASCIZ / end /]
	PUSHJ	P,MTFXSS	;INDICATE END OF SAVE SET
	JRST	MTENDT		;GO END LISTING OF SAVE SET
>;END IFN FT$MTB
IFN FT$MTB,<	;BACKUP/FRS

;HERE AT START OR CONTINUATION OF FRS OR BACKUP SAVE SET

MTFCSS:	MOVEI	T1,[ASCIZ /cont./]
	SKIPA
MTFSSS:	MOVEI	T1,[ASCIZ /start/]
	PUSH	P,T1		;SAVE LABEL			[302]
	MOVE	T1,MTFBOT+3	;CLEAR SYSTEM HEADER		[302]
	PUSHJ	P,MTFBCB	; ..				[302]
	MOVE	T1,MTFBOT+4	;CLEAR SAVE SET NAME		[302]
	PUSHJ	P,MTFBCB	; ..				[302]
	PUSHJ	P,MTFBGO	;UPDATE OVERHEAD REGIONS	[302]
	  JRST	MTIOJK		;ERROR IF GARBAGED		[302]
	POP	P,T1		;RESTORE LABEL			[302]
	SETZM	BFHD+.BFCTR	;DISCARD REST OF BLOCK
	PUSHJ	P,MTFXSS	;OUTPUT START
	JRST	MTFRSR		;RESUME FRS LISTING

;ROUTINE TO OUTPUT START, CONTINUATION, OR END OF SAVE SET

MTFXSS:	MOVEI	M,[ASCIZ /  BACKUP /]
IFN FT$MTS,<	;FRS
	SKIPGE	B$GTYP		;SEE IF FRS
	MOVEI	M,[ASCIZ /  FRS /]
>;END IFN FT$MTS
	PUSHJ	P,LSTR		;ISSUE SAVER
	MOVE	M,T1		;GET START/END
	PUSHJ	P,LSTR		;ISSUE IT
	MOVEI	M,[ASCIZ / save set: /]
	PUSHJ	P,LSTR		;ISSUE START OF SAVE SET
	SKIPL	B$GTYP		;IF BACKUP,			[302]
	JRST	[MOVEI M,B$BSSN	; POINT TO SAVE SET NAME	[302]
		 PUSHJ P,LSTR	; LIST IT			[302]
		 JRST  MTFXS1]	; AND PROCEED			[302]
	MOVE	T2,B$SNAM	;GET SAVE SET NAME
	PUSHJ	P,LSIXN		;ISSUE IT
MTFXS1:	PUSHJ	P,LCRLF		;END LINE			[302]
	PUSHJ	P,MTFXSL	;ISSUE LINES COMMON TO LABEL
	SKIPE	B$SCMT		;SEE IF COMMENT
	JRST	[PUSHJ P,LSPC5	;SPACE IN
		 MOVEI M,[ASCIZ /Comment: /]
		 PUSHJ P,LSTR	;LABEL IT
		 SETZM B$SCMT+4 ;PROTECT ASCIZ
		 MOVEI M,B$SCMT	;OUTPUT
		 PUSHJ P,LSTR	; COMMENT
		 PUSHJ P,LCRLF	;END LINE
		 JRST  .+1]	;RETURN
	POPJ	P,		;RETURN
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

;ISSUE LINES COMMON BETWEEN LABEL AND SAVE SET HEADERS

MTFXSL:	PUSHJ	P,LSPC5		;INDENT				[302]
	MOVEI	M,[ASCIZ / by version /]
	SKIPE	T4,B$SVER	;IF FRS/BACKUP VERSION SET,
	PUSHJ	P,LSTR		;INDICATE VERSION
	SKIPE	T4		;IF SET,
	PUSHJ	P,LVER		;LIST IT

	SKIPL	B$GTYP		;IF NOT FRS
	SKIPN	T1,B$SCDT	;AND DATE SET
	JRST	MTFXS2		;NO--SKIP ON
	PUSHJ	P,.CNTDT##	;SPLIT
	MOVEM	T1,B$STIM	;STORE CREATION TIME
	MOVEM	T2,B$SDAT	;STORE CREATION DATE
MTFXS2:
IFN FT$MTS,<	;FRS
	SKIPE	T1,B$STRK	;GET 7-TRACK FLAG
	MOVX	T1,MT.7TR	;SET FOR MTCHR.
	LDB	T2,[POINTR (B$SMOD,IO.DEN)]
	DPB	T2,[POINTR (T1,MT.DEN)]
	SKIPGE	B$GTYP		;IF FRS,
	MOVEM	T1,B$SMTC	; STORE MTCHR.
>;END IFN FT$MTS

	MOVEI	M,[ASCIZ / at /]
	PUSHJ	P,LSTR		;LABEL TIME
	MOVE	T1,B$STIM	;GET TIME
	PUSHJ	P,LMSECS	;LIST IT
	MOVEI	M,[ASCIZ / on /]
	PUSHJ	P,LSTR		;LABEL DATE
	MOVE	T4,B$SDAT	;GET DATE
	PUSHJ	P,LDATE		;LIST IT
	PUSHJ	P,LCRLF		;END LINE
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

	PUSHJ	P,LSPC5		;SPACE IN
	MOVEI	M,[ASCIZ / written on /]
	SKIPE	T2,B$SDEV	;IF DEVICE,
	PUSHJ	P,LSTR		;LABEL DEVICE
	SKIPE	T2		;SKIP IF BLANK
	PUSHJ	P,LSIXCL	;LIST DEVICE
	MOVEI	M,[ASCIZ \ on S/N \]
	SKIPE	T1,B$SAPR
	PUSHJ	P,LSTR
	SKIPE	T1
	PUSHJ	P,LDEC
	LDB	T1,[POINTR (B$SMTC,MT.DEN)]
	JUMPE	T1,MTFXS3	;IF DENSITY SET,
	MOVEI	M,[ASCIZ / at /]
	PUSHJ	P,LSTR
	MOVE	T1,[ASCII /200/
		    ASCII /556/
		    ASCII /800/
		    ASCII /1600/
		    ASCII /6250/
		    ASCII /(6)/
		    ASCII /(7)/]-1(T1)
	MOVEI	M,T1		;ASCII OF DENSITY
	PUSHJ	P,LSTR		;ISSUE IT
	MOVX	T1,MT.7TR	;LOOK AT 7-TRACK FLAG
	MOVEI	M,[ASCIZ / 9-track/]
	TDNE	T1,B$SMTC	;SEE IF ON
	MOVEI	M,[ASCIZ / 7-track/]
	PUSHJ	P,LSTR		;ISSUE TRACKS
MTFXS3:	PUSHJ	P,LCRLF		;GO TO NEW LINE
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

	PUSHJ	P,LSPC5		;SPACE 5
	MOVEI	M,[ASCIZ / under/]
	PUSHJ	P,LSTR		;ISSUE LABEL			[302]
	SKIPGE	B$SMTY		;GET SYSTEM TYPE		[302]
	TDZA	T1,T1		;IGNORE IF FUNNY		[302]
	LDB	T1,[POINTR (B$SMTY,CN%MNT)]
	CAILE	T1,3		;IS IT KNOWN?			[302]
	MOVEI	T1,0		;NO--FORGET IT			[302]
	MOVE	M,[	[ASCIZ \\]
			[ASCIZ \ TOPS-10\]
			[ASCIZ \ I.T.S.\]
			[ASCIZ \ TENEX\]  ](T1)
	PUSHJ	P,LSTR		;GIVE SYSTEM TYPE		[302]
	MOVEI	M,[ASCIZ / system/]
	PUSHJ	P,LSTR		;LABEL SYSTEM VERSION
	SKIPE	B$SSVR		;AND
	PUSHJ	P,LSPC		;SPACE
	SKIPE	T4,B$SSVR	;GET SYSTEM VERSION
	PUSHJ	P,LVER		;LIST IN VERSION		[302]
	MOVEI	M,[ASCIZ /: /]
	PUSHJ	P,LSTR		;SEPARATE SYSTEM NAME		[302]
	MOVEI	M,B$SSNM	;POINT TO SYSTEM NAME
	SKIPL	B$GTYP		;IF BACKUP,			[302]
	MOVEI	M,B$BSYS	; POINT TO SPECIAL REGION	[302]
	PUSHJ	P,LSTR		;OUTPUT IT
	PJRST	LCRLF		;END LINE
>;END IFN FT$MTB
IFN FT$MTB,<	;BACKUP/FRS

;HERE ON BACKUP/FRS DIRECTORY

MTFDIR:	PUSHJ	P,WLDEOD	;OUTPUT SUMMARIES
	SETZM	BFHD+.BFCTR	;DISCARD REST OF BLOCK
	JRST	MTFRSR		;AND CONTINUE ONWARD

;HERE ON BACKUP/FRS FILE

MTFFIL:	SETZM	LBLOCK		;CLEAR OUT ANY EXCESS
	MOVE	T1,[LBLOCK,,LBLOCK+1]
	BLT	T1,FRIBLK	; ..
IFN FT$MTS,<	;FRS
	SKIPL	B$GTYP		;IF BACKUP,			[302]
	JRST	MTFBFL		; GO HANDLE SEPARATELY		[302]
	MOVE	T1,B$FRBN	;GET RELATIVE BLOCK NO.		[302]
	LSH	T1,7		;CONVERT TO WORDS		[302]
	MOVEM	T1,B$FRDW	;STORE SIMILAR TO BACKUP	[302]
	SKIPL	T1,B$FNDW	;GET NUMBER OF WORDS
	CAILE	T1,200		;SEE IF OK
	JRST	MTIOJK		;NO--ERROR
	SKIPN	T1,B$FNDB	;GET NUMBER OF DATA BLOCKS
	SKIPGE	B$GFLG		;UNLESS EOF			[305]
	SKIPA			;YES				[305]
	MOVEI	T1,5		;(BUG IN OLD VERSION OF FRS)
	SKIPL	T1		;SEE IF
	CAILE	T1,20		; MAKES SENSE
	JRST	MTIOJK		;NO--ERROR
	IMULI	T1,200		;CONVERT TO WORDS
	ADD	T1,B$FNDW	;ADD LAST PARTIAL BLOCK
	CAIL	T1,200		;IN CASE JUST RIB, SKIP		[243,300]
	SUBI	T1,200		; REMOVE LAST BLOCK IN COUNT
	MOVEM	T1,BFHD+.BFCTR	;STORE AS ACTUAL DATA LENGTH
	MOVE	T1,B$FSTR	;GET STRUCTURE
	MOVEM	T1,FSTR		;SET FOR LISTER
	SKIPE	B$FRBN		;GET STARTING BLOCK
	JRST	[MOVE  T1,B$FNAM ;GET HEADER NAME
		 MOVEM T1,FNAM	;STORE
		 MOVE  T1,B$FEXT ;GET EXTENSION
		 HLLZM T1,FEXT	;STORE
		 MOVE  T1,B$FUFD ;GET DIRECTORY
		 MOVEM T1,UFDPPN ;STORE DIRECTORY
		 JRST  MTFDFM]	;GO STORE
>;END IFN FT$MTS
>;END IFN FT$MTB
				CONT.
IFN FT$MTS,<	;FRS

IFE FT$SFD, MOVNI T2,177	;PRESET COUNT OF RIB
IFN FT$SFD, MOVNI T2,177-LN$DRB	;PRESET COUNT OF RIB
	PUSHJ	P,NEXOVR	;GET RIB POINTER
	  JRST	E$$JFS		;UNEXPECTED END OF RECORD
	HRRZM	T1,RIBLEN	;SET AS RIB LENGTH
	TLZ	T1,-1		;CLEAR JUNK
	CAILE	T1,LN$RIB	;SEE IF IT FITS
	JRST	E$$JFS		;NO--ERROR
	MOVNS	T1		;GET NEGATIVE COUNT		[302]
	HRLZS	T1		;POSITION FOR AOBJN		[302]
	HRRI	T1,LBLOCK+1	;POINT TO RIB			[302]
	PUSHJ	P,BLKOVR	;TRANSFER BLOCK OF DATA		[302]
	  JRST	E$$JFS		;JUNK IF NOT THERE		[302]
MTFFR2:	PUSHJ	P,NEXOVR	;GET JUNK RIB
	  JRST	E$$JFS		;UNEXPECTED END OF RECORD
	JUMPN	T2,MTFFR2	;LOOP UNTIL DONE
IFN FT$SFD,<
	MOVEI	T4,LN$DRB	;GET SFD DEPTH
	SETZM	THSPTH+.PTPPN+1(T4) ;SET END FLAG
MTFFR3:	PUSHJ	P,NEXOVR	;GET SFD
	  JRST	E$$JFS		;UNEXPECTED END OF RECORD
	MOVEM	T1,THSPTH+.PTPPN(T4) ;STORE SFD
	SOJGE	T4,MTFFR3	;GO GET NEXT ONE
	MOVE	T1,B$FLVL	;GET SFD LEVEL
	SETZM	THSPTH+.PTPPN+1(T1) ; CLEAR BEYOND IT

	SETZM	THSPTH		;CLEAR UNUSED AREA
	SETZM	THSPTH+1	; ..
	MOVEI	T1,THSPTH	;POINT TO SFD AREA
	SKIPE	THSPTH+.PTPPN+1	;SEE IF SFD NEEDED
	MOVEM	T1,UFDPPN	;YES--POINT TO IT
>;END IFN FT$SFD
	JRST	MTFDFL		;GO HANDLE FILE
>;END IFN FT$MTS
				CONT.
IFN FT$MTB,<;	BACKUP/FRS

;HERE ON START OF BACKUP FILE TO ACQUIRE ATTRIBUTES, ETC.

MTFBFL:	MOVE	T1,MTFBOT	;CLEAR
	PUSHJ	P,MTFBCB	; NAME BLOCK
	MOVE	T1,MTFBOT+1	;CLEAR
	PUSHJ	P,MTFBCB	; ATTRIBUTES BLOCK
	TRZ	F,R.NSF		;INDICATE THAT STARTS AT BEGINNING
	SKIPE	B$FRDW		;SEE IF AT START OF FILE	[316]
	JRST	[TRO  F,R.NSF	;RECOVER NAME
		 JRST  MTFB.1]	;GO PROCESS
	PUSHJ	P,MTFBGO	;GET OVERHEAD DATA
	  JRST	E$$JFS		;JUNK IF SCREWY
MTFB.1:	MOVEI	T1,.FCDEV	;GET
	PUSHJ	P,MTFBDT	; DEVICE
	MOVEM	T1,FSTR		;SAVE FOR DIRECTORY
	MOVEI	T1,.FCNAM	;GET
	PUSHJ	P,MTFBDT	; NAME
	MOVEM	T1,FNAM		;SAVE
	MOVEI	T1,.FCEXT	;GET
	PUSHJ	P,MTFBDT	; EXTENSION
	MOVEM	T1,FEXT		;SAVE
	MOVEI	T1,.FCDIR	;INDICATE UFD
	PUSHJ	P,MTFBDT	; GET IT
IFN FT$SFD,<
	JUMPE	T1,MTFB.3	;JUMP IF NOT THERE
	MOVEM	T1,MTPATH+.PTPPN ;ELSE SET IN PATH
	MOVSI	P1,1-LN$DRB	;COUNT SFDS			[331]
MTFB.2:	MOVEI	T1,.FCSFD(P1)	;INDICATE SFD			[331]
	PUSHJ	P,MTFBDT	;GET IT
	MOVEM	T1,MTPATH+.PTPPN+1(P1) ;STORE IT
	SKIPE	T1		;UNLESS DONE,
	AOBJN	P1,MTFB.2	; LOOP
	MOVEI	T1,MTPATH	;POINT TO PATH
>;END IFN FT$SFD
MTFB.3:	MOVEM	T1,UFDPPN	;STORE AS DIRECTORY
	TRZE	F,R.NSF		;IF NOT START AT START,		[316]
	JRST	MTFDFM		; GO ISSUE MESSAGE		[316]
	MOVE	T1,B$BATT+A$FHLN ;GET ATTRIBUTE LENGTH
	CAIGE	T1,^D8		;MAKE SURE BIG ENOUGH
	JRST	E$$JFS		;BAD IF TOO SMALL
	MOVEI	T1,LN$RIB	;SET FULL
	MOVEM	T1,RIBLEN	; RIB LENGTH
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

;NOW DO ATTRIBUTES

	MOVEI	T2,0		;PRECLEAR ACCESS
	SKIPE	T1,B$BATT+A$REDT ;GET ACCESS TIME
	PUSHJ	P,.CNTDT##	;CONVERT FORMAT
	DPB	T2,[POINTR (FEXT,RB.ACD)]
	SKIPE	T1,B$BATT+A$PROT ;GET PROTECTION
	PUSHJ	P,MTFDPR	;CONVERT TO TOPS-10
	DPB	T1,[POINTR (FCRE,RB.PRV)]
	SKIPN	B$BATT+A$PROT	;IF MISSING PROTECTION,
	SETOM	FPRV		;NO PROTECTION IN INTERCHANGE
	MOVE	T1,B$BATT+A$MODE ;GET MODE
	DPB	T1,[POINTR (FCRE,RB.MOD)]
	MOVE	T1,B$BATT+A$WRIT ;GET WRITE DATE
	PUSHJ	P,.CNTDT##	;TAKE APART
	DPB	T2,[POINTR (FCRE,RB.CRD)]
	LSH	T2,-^D12	;DATE75 EXCESS
	DPB	T2,[POINTR (FEXT,RB.CRX)]
	IDIVI	T1,^D60000	;CONVERT TO MINUTES
	SKIPE	T2		;IF EXCESS,
	AOS	T1		; ROUND UP
	DPB	T1,[POINTR (FCRE,RB.CRT)]
	MOVEI	T2,^D36		;GET WORD WIDTH IN BITS
	IDIV	T2,B$BATT+A$BSIZ ;CONVERT TO LENGTH IN BYTES
	SKIPGE	T1,B$BATT+A$LENG ;LENGTH IN BYTES
	MOVEI	T2,1		;IF OVERFLOW, KILL DIVISOR
	IDIV	T1,T2		;CONVERT TO LENGTH IN WORDS
	SKIPE	T2		;IF PARTIAL WORD,
	AOS	T1		; ROUND UP
	MOVEM	T1,FLEN		;STORE AS SIZE
	MOVE	T1,B$BATT+A$VERS ;GET VERSION
	MOVEM	T1,FVER		;STORE
	MOVE	T1,B$BATT+A$NOTE ;POINT TO ANNOTATION
	PUSHJ	P,MTGTSX	;CONVERT TO SIXBIT
	MOVEM	T1,FSPL		;SET IN SPOOL WORD
	MOVEI	T2,0		;PRECLEAR
	SKIPL	T1,B$BATT+A$ESTS ;GET ESTIMATE
	IDIVI	T1,^D128	;CONVERT TO BLOCKS
	SKIPE	T2		;IF OVERFLOW,
	AOS	T1		; INCREMENT
	MOVEM	T1,FEST		;SET AS ESTIMATE
	MOVEI	T2,0		;PRECLEAR
	SKIPL	T1,B$BATT+A$ALLS ;ALLOCATED SIZE IN WORDS
	IDIVI	T1,^D128	;CONVERT TO BLOCKS
	SKIPE	T2		;IF PARTIAL BLOCK,
	AOS	T1		; ROUND UP
	MOVEM	T1,FALC		;STORE
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

	SKIPL	T1,B$BATT+A$RADR ;GET REQUESTED ADDRESS
	IDIVI	T1,^D128	;CONVERT TO BLOCKS
	MOVEM	T1,FPOS		;STORE
	MOVE	T1,B$BATT+A$USRW ;GET USER WORD
	MOVEM	T1,FNCA		;STORE
	MOVE	T1,B$BATT+A$BKID ;GET LAST BACKUP TAPE
	PUSHJ	P,MTGTSX	;CONVERT TO SIXBIT
	MOVEM	T1,FMTA		;STORE
	MOVEI	T1,0		;PRECLEAR STATUS BITS
	MOVSI	T2,(1B0)	;SET FIRST BIT
	MOVSI	T3,-LMTRBT	;SET LOOP LENGTH
MTFB.4:	TDNE	T2,B$BATT+A$FLGS ;TEST BACKUP FLAG
	IOR	T1,MTRBT(T3)	;ON--SET TOPS-10 BIT
	LSH	T2,-1		;MOVE TO NEXT BACKUP BIT
	AOBJN	T3,MTFB.4	;LOOP OVER TABLE
	MOVEM	T1,FSTS		;STORE STATUS
	MOVE	T1,B$BATT+A$CUSR ;GET AUTHOR
	PUSHJ	P,MTGTPP	;CONVERT TO PPN
	MOVEM	T1,FAUT		;STORE
	MOVE	T1,B$BATT+A$PCAW ;GET PRIV USER WORD
	MOVEM	T1,FPCA		;STORE
	JRST	MTFDFL		;GO HANDLE FILE

;TABLE OF TOPS-10 FILE RIB STATUS BITS IN BACKUP ORDER

MTRBT:	RP.NDL
	Z
	Z
	RP.ABU
	RP.NQC
	RP.ABC
	RP.FCE
	RP.FWE
	RP.BFA
	RP.BDA
LMTRBT==.-MTRBT


;HERE WHEN FILE ACTUALLY FOUND ON TAPE

MTFDFM:	MOVEI	M,[ASCIZ \ File starts in middle: \]
	PUSHJ	P,LSTR		;NOT START OF FILE!

MTFDFL:	TLO	F,L.FRSS	;INDICATE FRS/BACKUP DATA
	PUSHJ	P,MTDOFL	;GO HANDLE FILE

	TLZ	F,L.FRSS!L.FKEF	;CLEAR FLAGS
	JRST	MTFRSR		;PROCEED TO NEXT BLOCK
>;END FT$MTB
	SUBTTL	PERFORM MAG TAPE DIRECTORY LISTING--FAILSAFE

IFN FT$MTF,<	;FAILSAFE

MTSVST:	SETZM	H.MZER		;CLEAR FOR THIS SAVESET		[222]
	MOVE	T3,[H.MZER,,H.MZER+1]
	BLT	T3,H.EMZR	; ..

	TLO	F,L.LEVD	;SET LEVEL-D FORMAT DATA
	MOVEM	T1,MTSVVR	;SAVE HEADER
	PUSHJ	P,NEXOVW	;GET CODE WORD			[222]
	  JRST	MTIOJF		;JUNK
	AOS	T2		;COUNT WORD
	CAME	T1,[SIXBIT /*FAILS/]
	JRST	MTIOJK		;NOT FAILSAFE TAPE
	PUSHJ	P,NEXOVW	;GET TAPE NUMBER		[222]
	  JRST	MTIOJF		;DEATH
	AOS	T2		;COUNT STILL
	HRRM	T1,MTSVVR	;SAVE TAPE NUMBER
	TRZ	T1,377777	;CLEAR TAPE NUMBER
	CAME	T1,[SIXBIT /AFE/]
	JRST	MTIOJK		;JUNK
	PUSHJ	P,NEXOVW	;GET DATE, ETC.			[222]
	  JRST	MTIOJF		;NOT ENOUGH
	AOS	T2		;COUNT RECORD
	MOVE	P2,T1		;SAVE TAPE AND DATE
	PUSHJ	P,NEXOVW	;LAST WORD			[222]
	  JRST	MTIOJF		;SORRY
	AOS	T2		;COUNT WORD IN RECORD
	CAME	T1,[1,,2]	;CHECK THAT TOO
	JRST	MTIOJK		;NO--GIVE UP
	PUSHJ	P,NEXOVW	;READ THE EOF			[222]
	  JRST	.+2		;GOOD
	AOJA	T2,MTIOJK	;NO--JUNK

	MOVEI	M,[ASCIZ /  FAILSAFE save set by version /]
	PUSHJ	P,LSTR		;LIST LABEL
	HLRZ	T1,MTSVVR	;GET VERSION OF FAILSA
	PUSHJ	P,LOCT		;LIST OCTAL
	PUSHJ	P,MTLTDT	;LIST TAPE'S DATE AND TIME
	MOVEI	M,[ASCIZ /  tape /]
	PUSHJ	P,LSTR		;LIST LABEL
	HRRZ	T1,MTSVVR	;GET TAPE NUMBER
	PUSHJ	P,LDEC		;LIST IT
	PUSHJ	P,LCRLF		;END LINE
>;END IFN FT$MTF
				CONT.
IFN FT$MTF,<	;FAILSAFE

;HERE AFTER SAVE SET HEADER IS OUTPUT AND
;BACK HERE AFTER EACH FILE TO LOOK FOR NEXT USER/STR

MTUSER:	MOVEI	M,[ASCIZ /<Tape mark>
/]
	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--TELL USER
	STATZ	DC,IO.EOT	;SEE IF EOT
	  JRST	E$$PET		;YES--GO WRAP UP
	PUSHJ	P,MTOPEN	;OPEN TO CLEAR EOF
	  JRST	E.DFO##		;GRUMBLE
	JUMPE	T1,MTDONX	;JUMP IF DONE WITH /FILE
	PUSHJ	P,NEXOVW	;READ NEXT HEADER		[222]
	  JRST	[N$WARN	(DTM,Double tape mark)
		 JRST  MTUSER]	;AND TRY AGAIN

;BACK HERE TO PROCESS NEXT FILE

MTLOOK:	JUMPGE	T1,MTRAIL	;MUST BE AT TRAILER
	TLC	T1,-1		;FLIP FLAG
	TLNN	T1,-1		;MAKE SURE IT WAS -1
	CAIGE	T1,42		;MAKE SURE FULL BLOCK THERE
	JRST	MTSVJK		;NO--JUNK IN SAVE SET
	PUSHJ	P,NEXOVW	;GET STR NAME			[222]
	  JRST	E$$JSS		;ERROR
	MOVEM	T1,FSTR		;SAVE FOR TYPEOUT
	MOVSI	P1,-41		;PRESET LOOKUP COPY LOOP
MTLOK1:	PUSHJ	P,NEXOVW	;GET WORD			[222]
	  JRST	E$$JSS		;ERROR
	MOVEM	T1,LBLOCK(P1)	;SAVE WORD
	AOBJN	P1,MTLOK1	;LOOP UNTIL DONE
	MOVE	T1,RIBLEN	;GET COUNT FROM TAPE
	CAIE	T1,40		;MUST BE 40
	JRST	MTSVJK		;NO--JUNK
	TLO	F,L.SVST	;FLAG SAVE SET READ TO SKIP OVER
				;  THE RECORD PREFIXES

;HERE WHEN FILE FOUND ON TAPE

	PUSHJ	P,MTDOFL	;GO HANDLE FILE

	TLZ	F,L.SVST	;CLEAR FUNNY MODE
	TLZN	F,L.FKEF	;SEE IF REAL OR FAKE EOF
	JRST	MTUSER		;REAL--GO TO NEXT STR OR PPN OR TRAILER
	MOVE	T1,MTSVHD	;FAKE--GET NEXT HEADER
	JRST	MTLOOK		;GO PROCESS NEXT FILE
>;END IFN FT$MTF
IFN FT$MTB!FT$MTF!FT$MTR,<	;BACKUP/FRS, FAILSAFE, OLD BACKUP/RESTORE

;MTDOFL -- ROUTINE TO ANALYZE FILE IF USER WANTS IT AND SKIP OVER DATA
;USES T1-4

MTDOFL:	PUSHJ	P,ISMATC	;GO SEE IF IT MATCHES
	  JRST	MTSKIP		;NO--SKIP FILE
	SOS	NOFILF		;DECREMENT FILE COUNT (ANALYZE DOES SUB COUNT)

;HERE WHEN FILE IS FOUND TO OUTPUT

	PUSHJ	P,ANALYZ	;GO LIST IN APPROPRIATE FORMAT
	  SOS	NXFCNT		;DIDN'T MATCH AFTER ALL

MTSKIP:	PUSHJ	P,NEXDTW	;READ REST OF DATA FILE
	  POPJ	P,		;GOOD--WE'RE DONE
	JRST	MTSKIP		;LOOP TO FILE'S END
>;END IFN FT$MTB!FT$MTF!FT$MTR
IFN FT$MTF,<	;FAILSAFE

;HERE WHEN TRAILER SEEN ON TAPE

MTRAIL:	HLLZ	T2,MTSVVR	;GET VERSION FROM HEADER
	PUSHJ	P,NEXOVW	;GET CHECK WORD			[222]
	  JRST	E$$JSS		;ERROR
	CAME	T1,[SIXBIT /*FAILS/]
	JRST	MTSVJK		;JUNK
	PUSHJ	P,NEXOVW	;AND COUNT			[222]
	  JRST	E$$JSS		;ERROR
	HRRZ	T2,MTSVVR	;GET SAVED TAPE NUMBER
	ADD	T1,T2		;MATCH AGAINST TRAILER'S
	CAME	T1,[<SIXBIT /AFE/>+1B17]
	JRST	MTSVJK		;ERROR
	PUSHJ	P,NEXOVW	;GET DATE, ETC.			[222]
	  JRST	E$$JSS		;ERROR
	MOVE	P2,T1		;SAVE FOR OUTPUT ROUTINE
	PUSHJ	P,NEXOVW	;GET FINAL CHECK		[222]
	  JRST	E$$JSS		;ERROR
	CAME	T1,[1,,2]	;CHECK CODE
	JRST	MTSVJK		;ERROR
	PUSHJ	P,NEXOVW	;READ EOF			[222]
	  JRST	.+2		;GOOD
	JRST	MTSVJK		;ERROR

;HERE AFTER READING THE TRAILER FILE

	PUSHJ	P,DIRE		;GIVE TOTAL LINE
	MOVEI	M,[ASCIZ /  End of save set/]
	PUSHJ	P,LSTR		;TYPE INDICATOR
	PUSHJ	P,MTLTDT	;LIST TIME AND DATE
MTENDS:	PUSHJ	P,LCRLF		;AND END LINE
MTENDT:	PUSHJ	P,LCRLF		;AND ADD A BLANK LINE
	SETZM	H.MZER		;CLEAR TOTALS
	MOVE	T1,[H.MZER,,H.MZER+1]
	BLT	T1,H.EMZR
	JRST	MTFIND		;GO BACK TO START
>;END IFN FT$MTF
IFN FT$MTA,<	;MAGTAPES
IFN FT$MTF,<	;FAILSAFE

;HERE WHEN JUNK IN SAVE SET

MTSVJK:	SETZM	BFHD+.BFCTR	;CLEAR REST OF RECORD
	PUSHJ	P,NEXOVW	;READ ON TO EOF			[222]
	  JRST	E$$JSS		;GOT IT
	JRST	MTSVJK		;NO--LOOP
>;END IFN FT$MTF

;HERE WHEN EOF JUNK

	N$WARN	(JSS,Junk in save set)
	JRST	MTUSER		;GO START OVER

IFN FT$MTF,<	;FAILSAFE

;HERE ON PREMATURE EOT

	N$WARN	(PET,Premature end of tape in save set)
	PUSHJ	P,DIRE		;GIVE FINAL TOTALS		[153]
>;END IFN FT$MTF

;HERE AT EOT ON MAG TAPE

MTDONE:	SKIPE	S.EOT		;SEE IF /NOEOT
	JRST	MTDONX		;NO--GO FINISH UP
	PUSHJ	P,MTOPEN	;YES--REOPEN FROM TAPE MARK
	  PJRST	E.DFO##		;OOOPS
	JUMPN	T1,MTFIND	;START OVER UNLESS /FILE COUNTED OUT

;HERE WHEN TRULY TIME TO STOP

MTDONX:	PUSHJ	P,CHKNXF	;CHECK FOR NON-EX FILES		[170]
	PUSHJ	P,DIRET		;ISSUE TOTALS, ETC.		[170]
	SKIPE	S.REWS		;SEE IF /NOREW
	MTREW.	DC,		;REWIND TAPE AT END
	RELEAS	DC,		;RELEASE THE DATA CHANNEL
	TRZ	F,R.WORD	;CLEAR WORD MODE
	POPJ	P,		;RETURN
>;END IFN FT$MTA
	SUBTTL	PERFORM MAG TAPE DIRECTORY LISTING--SUBROUTINES

IFN FT$MTF,<	;FAILSAFE

;MTLTDT -- ROUTINE TO LIST TIME AND DATE FROM FAILSAFE TAPE
;CALL:	MOVE	P2,WORD FROM HEADER
;	PUSHJ	P,MTLTDT
;LISTS " AT HH:MM:SS ON DATE"

MTLTDT:	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	M,[ASCIZ / at /]
	PUSHJ	P,LSTR		;LIST LABEL
	HLRZ	T1,MTSVVR	;GET VERSION NUMBER
	CAIG	T1,27		;IF SINCE V.27 OK
	JRST	[LDB	T4,[POINT 11,P2,23]
		 PUSHJ	P,LTIME
		 JRST	MTSVDT]
	LDB	T4,[POINT 17,P2,23]
	CAILE	T1,77		;SEE IF V.100			[176]
	LDB	T4,[POINT 17,P2,20]  ;YES--GET NEW FORMAT	[176]
	PUSHJ	P,LSECS		;ISSUE TIME IN SECONDS
MTSVDT:	MOVEI	M,[ASCIZ / on /]
	PUSHJ	P,LSTR		;LIST LABEL
	HRRZ	T4,P2		;GET DATE			[162]
	ANDI	T4,77777	;MASK TO DATE			[176]
	HLRZ	T1,MTSVVR	;GET FAILSA VERSION		[162]
	CAIG	T1,77		;IF BEFORE VERSION 100,		[176]
	ANDI	T4,7777		;MASK OUT JUNK
	PJRST	LDATE		;LIST IT AND RETURN
>;END IFN FT$MTF
IFN FT$MTA,<	;MAGTAPES

;SUBROUTINE TO OPEN MAG TAPE
;CALL:	PUSHJ	P,MTOPEN
;RETURNS T1=0 IF FILE COUNT DONE (/FILE SWITCH)

MTOPEN:	MOVE	T1,MTSVFF	;RESTORE JOBFF
	MOVEM	T1,.JBFF	;  TO AVOID GROWTH
	MOVX	T1,FX.PAR	;CHECK FOR /PARITY
	TDNN	T1,I.MOD(I)	; SUPPLIED BY USER
	TDZA	T1,T1		;NO--CLEAR IT
	MOVX	T1,IO.PAR	;YES--SET IT
	LDB	T2,[POINTR (I.MOD(I),FX.DEN)]
	DPB	T2,[POINTR (T1,IO.DEN)]
	MOVE	T2,I.MOD(I)	;GET PHYSICAL BIT
	TXNE	T2,FX.PHY	;TEST IT
	TXO	T1,UU.PHS	;YES--SET FOR OPEN
	IORI	T1,.IOBIN	;SET BINARY MODE
	MOVE	T2,I.DEV(I)	;GET DEVICE NAME
	MOVEI	T3,BFHD		;GET INPUT BUFFER HEADERS	[166]
	OPEN	DC,T1		;OPEN CHANNEL
	  POPJ	P,		;RETURN WITH ERROR

;HERE WHEN TAPE IS OPENED--SETUP BUFFERS

	MOVEI	T4,T1		;GET SYSTEM BUFFERING
	DEVSIZ	T4,		;FROM MONITOR
	  MOVSI	T4,2		;(ASSUME 2)
	HRRZ	T1,T4		;GET BUFFER SIZE
	CAIGE	T1,LN$MRC+3	;SEE IF MIN TAPE OR BIGGER SIZE	[230]
	MOVEI	T1,LN$MRC+3	;NO--FORCE UP			[230]
	HLL	T1,T4		;GET NUMBER OF BUFFERS
	MOVEI	T2,BFHD		;POINT TO HEADER		[166]
	PUSHJ	P,MAKBUF	;MAKE A BUFFER RING
	SOS	T1,MTFLCT	;COUNT DOWN FILE COUNTER
	JRST	.POPJ1##	;WIN RETURN
>;END IFN FT$MTA
IFN FT$MTA,<	;MAGTAPES

;MAKBUF -- ROUTINE TO MAKE A BUFFER RING
;CALL:	HRLI	T1,NUMBER OF BUFFERS
;	HRRI	T1,SIZE OF EACH (INCLUDING HEADERS)
;	MOVEI	T2,LOCATION OF BUFFER HEADER
;	PUSHJ	P,MAKBUF
;RETURNS UNLESS NOT ENOUGH CORE

MAKBUF:	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	HLRZ	P1,T1		;GET BUFFER COUNT
	MOVEI	T3,(T1)		;GET BUFFER SIZE
	TLZ	T1,-1		;CLEAR JUNK
	IMUL	T1,P1		;GET TOTAL SPACE
	PUSHJ	P,GETCOR	;GET CORE AT .JBFF
	MOVE	P2,T1		;SAVE OLD .JBFF
	AOS	T1		;POINT TO LINK WORD
	MOVE	T4,T1		;AND MAKE A COPY
	HRLI	T4,-2(T3)	;PUT SIZE IN POINTERS		[156]

MAKBF1:	ADD	T4,T3		;ADVANCE TO NEXT BUFFER
	MOVEM	T4,(T1)		;STORE POINTER IN PREVIOUS BUFFER
	MOVE	T1,T4		;STEP TO NEXT BUFFER
	SOJG	P1,MAKBF1	;LOOP UNTIL DONE
	SUB	T1,T3		;BACKUP TO LAST POINTER
	HRRI	T4,1(P2)	;GET FIRST BUFFER LINK WORD ADDRESS
	MOVEM	T4,(T1)		;STORE POINTER TO FIRST BUFFER
	HRLI	T4,(1B0)	;SET USE BIT
	MOVEM	T4,(T2)		;STORE IN HEADER
	POPJ	P,		;RETURN
>;END IFN FT$MTA
IFN FT$MTA,<	;MAGTAPES

;GETCOR -- ROUTINE TO GET SOME CORE AT .JBFF
;WILL EXPAND LOW SEG IF NECESSARY
;CALL:	MOVEI	T1,AMOUNT NEEDED
;	PUSHJ	P,GETCOR
;RETURN WITH T1=START OF AREA (OLD .JBFF)

GETCOR:	PUSH	P,T2		;SAVE TEMP
	MOVE	T2,T1		;GET ARG
	MOVE	T1,.JBFF	;SAVE OLD .JBFF
	ADDM	T2,.JBFF	;ADVANCE .JBFF

GTCOR1:	MOVE	T2,.JBFF	;GET AMOUNT NEEDED
	CAMG	T2,.JBREL	;SEE IF MORE THAN WE HAVE
	JRST	GTCOR2		;NO--OK TO RETURN
	CORE	T2,		;TELL MONITOR
	  JRST	E.NEC		;ERROR--TELL USER
	JRST	GTCOR1		;LOOP TO VERIFY IT'S OK

GTCOR2:	POP	P,T2		;RESTORE TEMP
	POPJ	P,		;RETURN

E.NEC:	MOVE	P3,.JBFF	;GET VALUE NEEDED
	N$FAID	(NEC,Not enough core--need)
>;END IFN FT$MTA
IFN FT$MTB,<	;BACKUP/FRS

;MTFBGO -- GET OVERHEAD REGIONS FROM BACKUP/FRS TAPE
;CALL:	PUSHJ	P,MTFBGO
;	RETURN +1 IF ERRORS
;	RETURN +2 IF OK

MTFBGO:	PUSHJ	P,.SAVE3##	;MAKE SOME WORK ROOM
	MOVE	P1,B$GLND	;GET OVERHEAD LENGTH

;LOOP OVER OVERHEAD BLOCKS
MTFG.1:	SOJL	P1,MTFG.3	;EXIT IF DONE
	PUSHJ	P,NEXOVR	;GET NEXT BLOCK HEADER
	  POPJ	P,		;ERROR IF MISSING
	HLRZ	P3,T1		;GET TYPE
	CAILE	P3,MTFBOL	;SEE IF TOO BIG
	POPJ	P,		;ERROR IF SO
	MOVEI	P2,-1(T1)	;GET LENGTH OF DATA PORTION
	SUB	P1,P2		;COUNT IF DOWN
	JUMPL	P1,.POPJ##	;ERROR IF TOO LONG
	MOVE	T1,MTFBOT-1(P3)	;GET AREA
	PUSHJ	P,MTFBCB	;CLEAR OUT AREA
	HLRE	T3,MTFBOT-1(P3)	;GET MAX LENGTH WE CAN HANDLE
	MOVN	T1,P2		;GET NEGATIVE LENGTH
	CAMG	T1,T3		;IF TOO NEGATIVE TO FIT,
	MOVE	T1,T3		; JUST USE OUR SPACE
	ADD	P2,T1		;SUBTRACT FROM TAPE SIZE
	HRLZS	T1		;POSITION FOR AOBJN
	HRR	T1,MTFBOT-1(P3)	;GET START
	PUSHJ	P,BLKOVR	;GET BLOCK OF DATA
	  POPJ	P,		;ERROR IF NOT ALL THERE
	MOVEI	T1,377		;MASK OF RIGHTMOST ASCIZ CHARACTER
	SKIPE	MTFBOU-1(P3)	;IF SET,
	ANDCAM	T1,@MTFBOU-1(P3); PROTECT AGAINST JUNK
MTFG.2:	JUMPLE	P2,MTFG.1	;SKIP REST
	PUSHJ	P,NEXOVR	; IF WE DIDN'T USE IT
	  POPJ	P,		;ERROR IF NOT ALL THERE
	SOJA	P2,MTFG.2	; LOOP
MTFG.3:	MOVE	T1,B$GSIZ	;UPDATE
	MOVEM	T1,BFHD+.BFCTR	; WORDS OF DATA
	JRST	.POPJ1##	;GIVE GOOD RETURN
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

MTFBOT:	-^D30,,B$BNAM	;1=NAME BLOCK
	-^D50,,B$BATT	;2=FILE ATTRIBUTES
	0		;3=DIRECTORY ATTRIBUTES
	 -^D6,,B$BSYS	;4=SYSTEM HEADER
	 -^D7,,B$BSSN	;5=SAVE SET NAME
MTFBOL==.-MTFBOT

MTFBOU:	0		;1=NAME BLOCK
	0		;2=FILE ATTRIBUTES
	0		;3=DIRECTORY ATTRIBUTES
	B$BSYS+5	;4=SYSTEM HEADER
	B$BSSN+6	;5=SAVE SET NAME


;MTFBCB -- ROUTINE TO CLEAR A SPECIFIC OVERHEAD BLOCK
;CALL:	T1/ AOBJN TO BLOCK
;	PUSHJ	P,MTFBCB
;	RETURN +1
;USES ONLY T1

MTFBCB:	SKIPGE	T1		;UNLESS NULL,
	SETZM	(T1)		; CLEAR WORD
	AOBJN	T1,.-1		;LOOP
	POPJ	P,		;RETURN
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<

;MTFBDT -- ROUTINE TO GET A SPECIFIC NAME COMPONENT
;CALL:	T1/ CODE OF COMPONENT TO GET
;	PUSHJ	P,MTFBDT
;	RETURN +1 WITH T1/ VALUE (CONVERTED TO SIXBIT) OR 0

MTFBDT:	PUSHJ	P,.SAVE2##	;SAVE SPACE
	MOVE	P2,T1		;COPY REQUEST FOR SAFE KEEPING
	MOVEI	P1,0		;SET COUNT
	TRNE	F,R.NSF		;IF NOT AT START,
	MOVEI	P1,B$FPTH-1	; USE RECOVERY HEADER
MTFD.1:	TRNE	F,R.NSF		;IF NOT AT START,
	JRST	[HRLI P1,(POINT 7,,35)
		 ILDB T2,P1	;GET SUB-BLOCK CODE
		 ILDB T4,P1	;GET LENGTH
		 JRST MTFD.2]	;AND PROCEED
	HLRZ	T2,B$BNAM(P1)	;GET NEXT SUB-BLOCK CODE
	HRRZ	T4,B$BNAM(P1)	;GET LENGTH
MTFD.2:	SKIPN	T4		;IF EMPTY,
	MOVEI	T4,1		; SET FOR JUST HEADER
	CAMN	T2,P2		;SEE IF MATCH
	JRST	MTFD.4		;YES--GO HANDLE
	TRNE	F,R.NSF		;IF NOT AT START,
	JRST	[HRRZ  T2,P1	;GET CURRENT WORD
		 CAIGE T2,B$FPTH+^D12 ;MAKE SURE FITS
		 JRST  MTFD.1	;OK--CONTINUE
		 JRST  MTFD.3]	;BAD--LOOSE
	ADD	P1,T4		;NO--ADVANCE
	CAIGE	P1,^D30		;SEE IF OVERFLOW YET
	JRST	MTFD.1		;NO--TRY AGAIN
MTFD.3:	MOVEI	T1,0		;YES--RETURN 0
	POPJ	P,		; TO CALLER
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

;HERE WHEN FOUND THE COMPONENT

MTFD.4:	TRNE	F,R.NSF		;IF NOT AT START,
	JRST	[HRRZ  T1,P1	;GET LOCATION
		 MOVNS T1	;GET -AMOUNT USED
		 CAILE T4,B$FPTH+^D12(T1) ;SEE IF FITS
		 MOVEI T4,B$FPTH+^D12(T1) ;NO--TRUNCATE
		 IMULI T4,5	;GET CHARACTER COUNT
		 SUBI  T4,2	;ALLOW FOR OVERHEAD
		 JRST  MTFD.5]	;AND PROCEED
	MOVN	T1,P1		;GET -AMOUNT USED
	CAILE	T4,^D30(T1)	;SEE IF LENGTH FITS
	MOVEI	T4,^D30(T1)	;NO--USE ACTUAL IN CORE
	SOS	T4		;REMOVE OVERHEAD WORD
	IMULI	T4,^D5		;CONVERT TO CHARACTERS
	ADD	P1,[POINT 7,B$BNAM,35] ;POINT TO START IN NEXT WORD
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS
MTFD.5:	MOVEI	T1,0		;CLEAR SIXBIT ANSWER
	MOVE	T2,[POINT 6,T1]	;POINT TO ANSWER
	CAIN	P2,.FCDIR	;IF UFD,
MTFDPP:	JRST	[PUSHJ P,MTFD.G	; GET FIRST CHARACTER
		 CAILE T3,"7"	;IF ALPHA,
		 JRST  MTFD.7	; HANDLE AS SIXBIT
		 JRST  MTFD.8]	;ELSE, HANDLE IN OCTAL
MTFDSX:!
MTFD.6:	PUSHJ	P,MTFD.G	;GET NEXT CHARACTER
MTFD.7:	JUMPE	T3,.POPJ##	;EXIT WHEN DONE
	CAIG	T3,137		; IN ASCII COL 0-5
	TRC	T3,40		; FORCE TO ALPHA (COL 4-5)
	IDPB	T3,T2		;STORE
	TLNE	T2,(77B5)	;IF NOT DONE,
	JRST	MTFD.6		; LOOP FOR MORE
	POPJ	P,		;RETURN WHEN FULL

MTFD.8:	PUSHJ	P,MTFOCT	;UFD--GET PROJECT IN OCTAL
	PUSH	P,T1		;SAVE
	PUSHJ	P,MTFD.G	;SKIP SEPARATOR (_)
	PUSHJ	P,MTFOCT	;GET PROGRAMMER IN OCTAL
	HRL	T1,(P)		;INSERT PROJECT
	POP	P,(P)		;DISCARD TEMP
	POPJ	P,		;RETURN UFD

;HELPER TO CONVERT OCTAL

MTFOCT:	TDZA	T1,T1		;STARTS WITH CHAR
MTFO.1:	PUSHJ	P,MTFD.G	;GET CHAR
	CAIL	T3,"0"		;IF
	CAILE	T3,"7"		; OCTAL DIGIT,
	POPJ	P,		;NO--DONE
	LSH	T1,3		;ADVANCE RESULT
	ADDI	T1,-"0"(T3)	;INCLUDE DIGIT
	JRST	MTFO.1		;LOOP

;HELPER ROUTINE TO GET NEXT CHARACTER
; COUNTS IN T4, POINTER IN P1
; RESULT IN T3

MTFD.G:	SOSGE	T4		;SEE IF ROOM
	TDZA	T3,T3		;NO--GIVE NULL
	ILDB	T3,P1		;YES--GET IT
	POPJ	P,		;RETURN
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

;MTGTPP -- ROUTINE TO CONVERT ATTRIBUTE STRING TO UFD
;CALL:	1/ RELATIVE BYTE POINTER IN ATTRIBUTES
;	PUSHJ	P,MTGTPP
;	1/ CONVERSION

MTGTPP:	PUSHJ	P,.SAVE1	;SAVE P1
	PUSHJ	P,MTGT.P	;FIXUP POINTER SET COUNT
	MOVEI	T1,0		;PRESET ANSWER
	MOVE	T2,[POINT 6,T1]	;POINT TO ANSWER
	PJRST	MTFDPP		;GO USE ABOVE ROUTINE

;MTGTSX -- ROUTINE TO CONVERT ATTRIBUTE STRING TO SIXBIT
;CALL:	1/ RELATIVE BYTE POINTER IN ATTRIBUTES
;	PUSHJ	P,MTGTSX
;	1/ CONVERSION

MTGTSX:	PUSHJ	P,.SAVE1	;SAVE P1
	PUSHJ	P,MTGT.P	;FIXUP POINTER SET COUNT
	MOVEI	T1,0		;PRESET ANSWER
	MOVE	T2,[POINT 6,T1]	;POINT TO ANSWER
	PJRST	MTFDSX		;GO USE ABOVE ROUTINE

;HELPER TO SET STRING POINTER

MTGT.P:	MOVEI	T4,0		;PRESET TO DONE
	JUMPE	T1,.POPJ	;RETURN IF NO POINTER
	HRRZ	T2,T1		;GET ADDRESS OF POINTER
	CAIL	T2,^D50		;SEE IF BAD
	POPJ	P,		;YES--GIVE UP
	HRRI	T1,B$BATT(T2)	;COMPUTE REAL LOCATION
	MOVE	P1,T1		;SET FOR CHAR GETTER
	MOVEI	T4,^D50		;SET MAX LENGTH
	SUB	T4,T2		;REMOVE HEADER
	IMULI	T4,5		;CONVERT TO BYTES
	POPJ	P,		;RETURN
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

;MTFDPR -- ROUTINE TO CONVERT PROTECTION ATTRIBUTE
;CALL:	1/ BACKUP PROTECTION
;	PUSHJ	P,MTFDPR
;	1/ TOPS-10 PROTECTION

MTFDPR:	PUSH	P,T1		;SAVE ARG
	LSH	T1,-^D16	;GET OWNER
	PUSHJ	P,MTFDPF	;CONVERT OWNER FIELD
	MOVE	T4,T1		;SAVE
	MOVE	T1,(P)		;GET ARG
	LSH	T1,-^D8		;GET AFFINITY GROUP
	PUSHJ	P,MTFDPF	;CONVERT AFFINITY
	LSH	T4,3		;SHIFT ANSWER
	IOR	T4,T1		;INCLUDE GROUP
	POP	P,T1		;RESTORE WORLD
	PUSHJ	P,MTFDPF	;CONVERT WORLD
	LSH	T4,3		;POSITON ANSWER
	IOR	T1,T4		;COMBINE RESULT
	POPJ	P,		;RETURN

;HELPER TO CONVERT ONE FIELD

MTFDPF:	MOVEI	T3,7		;SET WORST
	LDB	T2,[POINTR (T1,PR$RED)]
	SUB	T3,T2		;REMOVE READ ACCESS
	CAIGE	T3,5		;BUT NOT LESS
	MOVEI	T3,5		; THAN 5
	LDB	T2,[POINTR (T1,PR$WRT)]
	JUMPN	T2,[MOVEI T3,5	;IF SOME WRITE,
		    SUB   T3,T2	; USE THAT INSTEAD
		    JRST  .+1]	; AND CONTINUE
	LDB	T2,[POINTR (T1,PR$ATR)]
	CAIN	T2,7		;IF DELETE,
	MOVEI	T3,1		; SET THAT
	CAIN	T2,6		;IF CHANGE PROT,
	MOVEI	T3,0		; SET THAT
	MOVE	T1,T3		;SET RESULT
	POPJ	P,		;RETURN
>;END IFN FT$MTB
	SUBTTL	ROUTINE FOR DISK AND MAGTAPE DIRECTORY LINE

;SUBROUTINE TO ANALYZE AND PRINT FROM AN EXTENDED LOOKUP
;BLOCK AND READ THE FILE IF NECESSARY
;	SKIPS IF MATCHES, NON-SKIP IF TOO OLD OR TOO YOUNG

ANALYZ:	PUSHJ	P,.CHKTA##	;CHECK /BEFORE AND /SINCE
	  POPJ	P,		;FAIL--GIVE NO MATCH RETURN
	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;NO SPECIAL OFFSET
	AOS	(P)		;WIN--GIVE OK RETURN
	SETZM	CHKSUM		;CLEAR CHECKSUM ACCUMULATOR
	SKIPLE	S.UNIT		;SEE IF USER REQUESTED UNITS	[245]
	SKIPN	T1,FDEV		;YES--SEE IF FILSER TOLD US
	JRST	GOTSTR		;NO--DON'T CHANGE
	SKIPN	S.UNIT		;YES--SEE IF /NOUNITS
	SKIPE	.WLDFL##	;AND NO STR WILDCARD
	JRST	NEWSTR		;NO--OK
	MOVEM	T1,DCHBLK	;YES--SETUP FOR DSKCHR
	SETZM	DCHBLK+.DCSNM	;CLEAR ANSWER
	MOVE	T1,[.DCSNM+1,,DCHBLK] ;POINT TO BLOCK
	DSKCHR	T1,		;ASK MONITOR STR NAME
	  JRST	GOTSTR		;NICE TRY
	SKIPE	T1,DCHBLK+.DCSNM  ;GET STR NAME
NEWSTR:	MOVEM	T1,FSTR		;YES--UPDATE INFO TO PRINT
GOTSTR:	PUSHJ	P,SSTRDR	;SET STATUS AND TYPE SUMMARY	[323]
	AOS	SNFILF		;COUNT FILE FOUND		[323]
	SKIPG	S.SUM		;SEE IF /SUM
	TRNN	F,R.FAST	;NO SEE IF /F
	JRST	.+2		;NO--ANALYZE
	JRST	VERNON		;YES--NO ANALYSIS		[221]
				CONT.
	MOVE	T1,FLEN		;GET LENGTH
	TLNE	F,L.LEVD	;SEE IF LEVEL D
	JRST	DLEN		;YES--USE LENGTH
	HLRE	T1,T1		;GET LENGTH FOR ACCESS TEST
	JUMPGE	T1,[ASH T1,7	;SEE IF ALREADY IN BLOCKS
		   JRST DLEN]	;CONVERT TO WORDS
	MOVNS	T1		;NO--CONVERT
DLEN:	TRNE	F,R.WORD	;SEE IF WORDS DESIRED
	JRST	CHKLEN		;YES--LEAVE ALONE
Ife FT$TYM,<	; Non-Tymshare used blocks
	ADDI	T1,177		;NO--CONVERT TO BLOCKS
	ASH	T1,-7		; ..
> ; End Ife FT$TYM
Ifn FT$TYM,<	; Use pages at Tymshare
	ADDI	T1,1777		;NO--Convert to pages
	ASH	T1,-^D9		; ..
> ; End Ifn FT$TYM
CHKLEN:	SKIPE	FALC		;SEE IF FILE ALLOCATED
	SKIPG	S.ALC		;YES--SEE IF USER PREFERS THAT
	JRST	NOTALC		;NO--USE COMPUTED LENGTH
	MOVE	T1,FALC		;YES--PICK UP ALLOCATED LENGTH
	TRNE	F,R.WORD	;SEE IF WORDS NEEDED
Ife FT$TYM,<	; Non-Tymshare used blocks
	ASH	T1,7		;YES--CONVERT
> ; End Ife FT$TYM
Ifn FT$TYM,<	; Use pages at Tymshare
	ASH	T1,-^D9		; ..
> ; End Ifn FT$TYM
NOTALC:	SKIPG	S.DTL		;IF /DETAIL, DON'T CLOBBER INFO
	MOVEM	T1,FLEN		;STORE AWAY FOR PINTING
	ADDM	T1,SNBLKS	;ACCUMULATE TOTALS
	CAMG	T1,S.ACCS	;SEE IF SHORT ENOUGH TO ACCESS
	TRO	F,R.ACCS	;YES--SET FLAG
				CONT.
	SETZM	FRVER		;CLEAR RIB VERSION FOR /DET
	SKIPE	T1,FVER		;SEE IF FILE HAS A VERSION ALREADY
	SKIPLE	S.DTL		;YES--SEE IF /DETAIL
	JRST	.+2		;NO VERSION OR /DET
	JRST	VERNON		;YES--SKIP READING
	MOVEM	T1,FRVER	;SAVE RIB VERSION FOR /DETAIL
	HLRZ	T1,FEXT		;SEE IF VERSION SEARCH USEFUL
	CAIN	T1,'EXE'	;				[306]
	JRST	VEREXE 		;YES--HANDLE .EXE		[306]
	CAIE	T1,'HGH'
	CAIN	T1,'SHR'
	JRST	VERHGH		;YES--HIGH SEGMENT VARIETY
Ifn FT$TYM,<	; Tymshare also has SWR files
	CAIN	T1,'SWR'
	JRST	VERHGH		;YES--HIGH SEGMENT VARIETY
> ; End Ifn FT$TYM
	CAIE	T1,'SAV'
	CAIN	T1,'LOW'
	JRST	VERLOW		;YES--LOW SEGMENT VARIETY
	CAIE	T1,'SVE'
	JRST	VERNON		;NO--FORGET THE IDEA

VERLOW:	PUSHJ	P,NEXDTW	;GET NEXT IOWD POINTER
	  JRST	VERNOF		;GIVE UP IF EOF
	JUMPE	T1,VERNOF	;GIVE UP IF JUNK
	SKIPA	T2,T1		;SAVE IT
VERLO1:	AOBJP	T2,VERLOW	;IF ALL USED UP, LOOP BACK FOR ANOTHER
	PUSHJ	P,NEXDTW	;GET A DATA WORD
	  JRST	VERNOF		;GIVE UP IF EOF
	HRRZ	T3,T2		;LOOK AT CURRENT ADDRESS
	CAIGE	T3,.JBVER-1	;  (NOTE-T3 IS ADDR-1)
	JRST	VERLO1		;NOT THERE YET SO LOOP BACK FOR MORE
	CAIN	T3,.JBVER-1	;MAKE SURE NOT TOO FAR
	JRST	VERGOT		;A WINNER--GO SAVE IT
	JRST	VERNON		;AND PROCEED

VERHGH:	MOVEI	T2,.JBHVR	;GUESS HOW FAR TO READ
VERHG1:	PUSHJ	P,NEXDTW	;GET NEXT WORD
	  JRST	VERNOF		;GIVE UP IF EOF
	SOJGE	T2,VERHG1	;COUNT AND LOOP UNTIL THERE
	JRST	VERGOT		;GO FINISH WITH RESULT		[306]
				CONT.
VEREXE:	MOVEI	T3,0		;CLEAR PROGRESS COUNT		[306]
VERE.1:	PUSHJ	P,NEXDTW	;GET BLOCK TYPE OF HEADER
	  JRST	VERNOF		;NONE IF EOF
	AOS	T3		;COUNT WORD
	HLRZ	T2,T1		;GET BLOCK TYPE
	CAIN	T2,1776		;SEE IF EXE DIRECTORY
	JRST	VERE.3		;YES--GO LOOKUP PAGE 0
	CAIL	T2,1776		;IF NOT VALID TYPE,
	JRST	VERNON		; EXIT WITHOUT VERSION
	HRRZ	T2,T1		;OK--GET BLOCK SIZE
VERE.2:	SOJLE	T1,VERE.1	;(ALLOW FOR FIRST WORD)
	PUSHJ	P,NEXDTW	;SKIP THIS BLOCK
	  JRST	VERNOF		;GIVE UP IF EOF
	AOS	T3		;COUNT PROGRESS
	JRST	VERE.2		;LOOP
VERE.3:	HRRZ	T4,T1		;DIRECTORY--GET SIZE
	LSH	T4,-1		;GET COUNT OF BIWORDS
VERE.4:	SOJL	T4,VERNON	;GIVE UP IF NOT IN DIRECTORY
	PUSHJ	P,NEXDTW	;GET FIRST WORD OF PAIR
	  JRST	VERNOF		;GIVE UP IF END
	MOVE	T2,T1		;SAVE FOR A MINUTE
	PUSHJ	P,NEXDTW	;GET SECOND WORD OF PAIR
	  JRST	VERNOF		;GIVE UP
	ADDI	T3,2		;COUNT PROGRESS
	TRNE	T1,-1		;SEE IF PAGE 0
	JRST	VERE.4		;NO--LOOP OVER DIRECTORY
	HRRZ	T4,T2		;GET POSITION IN FILE
	LSH	T4,^D9		;CONVERT TO WORDS
	SUB	T4,T3		;ALLOW FOR CURRENT POSITION
	JUMPLE	T4,VERNON	;ERROR IF BEHIND US
	ADDI	T4,.JBVER	;SET TO VERSION LOCATION
VERE.5:	PUSHJ	P,NEXDTW	;ADVANCE TO WORD
	  JRST	VERNOF		;GIVE UP IF END
	SOJGE	T4,VERE.5	;[333] (@ VERE.5 + 2L) READ TO .JBVER
				CONT.
VERGOT:	SKIPE	T1		;SEE IF WE GOT SOMETHING
	MOVEM	T1,FVER		;GOT IT! SO SAVE IT
VERNON:
	TRNN	F,R.ACCS	;SEE IF ACCESS NEEDED
	SKIPLE	S.CHK		; OR IF CHECKSUM NEEDED
	JRST	.+2		;YES--READ
	JRST	VERNOF		;NO--DON'T FORCE IT
VERCHK:	PUSHJ	P,NEXDTW	;YES--READ ONE WORD
	  JRST	VERNOF		;DONE IF EOF
	SKIPLE	S.CHK		;SEE IF CHECKSUM NEEDED
	JRST	VERCHK		;YES--KEEP GOING TO EOF
VERNOF:	TLNE	F,L.SVST!L.BKSS!L.FRSS  ;SEE IF MAG TAPE	[230]
	JRST	FILEND		;YES--SKIP THE CLOSES
	TRZN	F,R.ACCS	;SEE IF ACCESS NEEDED
	JRST	FILNOA		;NO--CLOSE WITHOUT IT
	CLOSE	DC,CL.DAT	;CLOSE AND INDICATE ACCESSED
	JRST	.+2		;AND CONTINUE BELOW
FILNOA:	CLOSE	DC,CL.ACS!CL.DAT  ;DON'T UPDATE ACCESS DATES
FILEND:				CONT.
;HERE WHEN IT IS TIME TO OUTPUT ONE LINE OF THE DIRECTORY

	SKIPLE	S.DTL		;SEE IF /DETAIL
	JRST	DLIST		;YES--GO ISSUE LISTING
	SKIPLE	S.SUM		;SEE IF SUMMARY MODE
	TRNE	F,R.FAST	;YES--CHECK /F
	JRST	.+2		;YES--GIVE OUTPUT
	POPJ	P,		;NO--SKIP LISTING
	PUSHJ	P,LSTFNM	;LIST FILE NAME
	PUSHJ	P,LTBEXT	;SPACE OVER			[177,212]
FLEXT:	HLLZ	T2,FEXT		;OUTPUT EXTENSION
	TRNN	F,R.FAST	;SEE IF /F MODE
	JRST	FLEXT3		;NO--GO DO SLOW FORMAT
	MOVEI	T3,3		;IN CASE DOING /SORT		[236]
	SKIPE	S.SORT		;SEE IF WE ARE			[236]
	PUSHJ	P,LSIXC		;LIST IN 3 COLUMNS		[236]
	SKIPN	S.SORT		;IF NOT /SORT, ONLY AS NEEDED	[236]
	PUSHJ	P,LSIXN		;YES--OUTPUT EXT.
	SKIPLE	S.CHK		;SEE IF /CHECKSUM		[221]
	PUSHJ	P,LSPC2		;YES--SPACE OVER TO IT		[221]
	JRST	FLCHEK		;AND END LINE			[221]
FLEXT3:	CAMN	T2,['UFD   ']	;SEE IF .UFD
	SKIPGE	FNAM		;AND NUMERIC
	JRST	FLEXT4		;NO--PROCEED
	MOVE	T1,FLEN		;YES--SKIP EXT
	PUSHJ	P,LDEC		;LIST LENGTH
	JRST	FLEXT5		;AND PROCEED
FLEXT4:	MOVEI	T3,3		;AS THREE CHARACTERS
	PUSHJ	P,LSIXC
	PUSHJ	P,LSPC2		;NO--POSITION FOR LENGTH
	MOVE	T1,FLEN		;GET FILE LENGTH
	PUSHJ	P,LDEC4

FLEXT5:
Ifn FT$TYM,<
	MOVEI	M,[ASCIZ /  /]
> ; End Ifn FT$TYM
Ife FT$TYM,<	;Non-Tymshare -- Use numerics, thus keep bracket
	MOVEI	M,[ASCIZ /  </];> ???
> ; End Ife FT$TYM
	PUSHJ	P,LSTR
	SKIPN	T1,FPRV		;SEE IF FORCED KNOWN PRIV	[316]
	LDB	T1,[POINTR (FCRE,RB.PRV)]	;		[162]
	JUMPL	T1,[MOVEI M,[ASCIZ /***/]
		    PUSHJ P,LSTR ;LIST "UNKNOWN"
		    JRST  .+2]	;AND PROCEED
Ife FT$TYM,<	;Non-Tymshare -- Use numerics, thus keep bracket
	PUSHJ	P,LOCT3Z	; < ???
	MOVEI	M,[ASCIZ />   /]
> ; End Ife FT$TYM
Ifn FT$TYM,<	; Print text protections
	PUSHJ	P,TYMPRV
	MOVEI	M,[ASCIZ / /]
> ; End Ifn FT$TYM
	PUSHJ	P,LSTR
FLCHEK:	SKIPG	S.CHK		;SEE IF CHECKSUM
	JRST	FCHKN		;NO--SKIP OUTPUT
	PUSHJ	P,LCHECK	;LIST CHECKSUM
	PUSHJ	P,LSPC2		;AND SPACE OVER
				CONT.
FCHKN:
Ife FT$TYM,<LDB	T4,[POINTR (FEXT,RB.ACD)]>	;		[162]
Ifn FT$TYM,<	; Tymshare uses different Date format!!!
	Push	P,T1		; Save this
	Push	P,T2		;   and this!
	Hrroi	T1,.Gtprv	; Read priv bits @ Tymshare
	Gettab	T1,		;  to get your time zone
	  Movsi	T1,4000		; GMT if none
	Ldb	T1,[POINT 5,T1,7] ; Get the time zone
	Movei	T2,20		; Setup GMT
	Subm	T2,T1		; Subtract GMT - Results to Memory
	Ldb	T2,[POINT 14,FEXT,35] ; Get access date
	Jumpge	T1,FACCGD	; Access date ok!
	Soj	T2,		; Decrement date by 1
	Addi	T1,^D24		; Add a day of hours
FACCGD:	Imul	T1,[^D60*^D60*^D1000] ; make into milliseconds
	Pushj	P,.CNDCT##	; Convert to DEC
	Movem	T2,T4		; Use new date
> ; End Ifn FT$TYM
	TRNN	F,R.SLOW	;SEE IF IN SLOW MODE
	 JRST	FTCRED		;NO--SKIP ACCESS DATE & Creation Time
	PUSHJ	P,LDATE		;OUTPUT ACCESS DATE
Ife FT$TYM,<PUSHJ P,LTAB>	; Tab over
Ifn FT$TYM,<PUSHJ P,LSPC2>	; Space a couple
FTCRED:	LDB	T2,[POINTR (FCRE,RB.CRD)]	;GET DATE
Ife FT$TYM,<LDB	T1,[POINTR (FEXT,RB.CRX)]>	; Get High order bits
Ifn FT$TYM,<LDB	T1,[POINT 2,FEXT,21]>		; Get High order bits
	DPB	T1,[POINT 3,T2,23]		;ADD INTO RESULT
	LDB	T1,[POINTR (FCRE,RB.CRT)]	;GET TIME
Ifn FT$TYM,<	; Tymshare uses different Date format!!!
	Imuli	T1,^D60*^D1000	; Convert minutes to milliseconds
	Pushj	P,.CNDCT##	; Convert to DEC
	Exch	T1,T2		; Swap
	Idivi	T2,^D60*^D1000	; Convert back to minutes
	Exch	T1,T2		; Swap back
> ; End Ifn FT$TYM
	Push	P,T2		; Save Date
	Move	T4,T1		; Copy for printing
	TRNN	F,R.SLOW	;SEE IF IN SLOW MODE
	 JRST	FCRED		;NO--SKIP CREATION TIME
	PUSHJ	P,LTIMEB	;OUTPUT CREATION TIME
Ife FT$TYM,<PUSHJ P,LTAB>	; Tab over
Ifn FT$TYM,<PUSHJ P,LSPC2>	; Space a couple
FCRED:	Pop	P,T4		; Got Date.
Ifn FT$TYM,<	; Did we save some registers?
	Pop	P,T2		; YES -- RESTORE THEM
	Pop	P,T1		;    ... before we jrst away
> ; End Ifn FT$TYM
	TRNE	F,R.FAST	;SEE IF /FAST			[221]
	JRST	FNVER		;YES--SKIP ON			[221]
	PUSHJ	P,LDATE		;OUTPUT CREATION DATE FROM T4
	TRNN	F,R.SLOW	;SEE IF IN SLOW MODE
	JRST	FLSEND		;NO--SKIP FILE MODE
	PUSHJ	P,LSPC2
	LDB	T1,[POINTR (FCRE,RB.MOD)]	;		[162]
	PUSHJ	P,LOCT2		;OUTPUT FILE MODE
FLSEND:	MOVE	T4,FVER		;OUTPUT FILE VERSION
	TXNN	F,L.FRMT	;[335] FORCE OUTPUT IF FORMATTING
	JUMPE	T4,FNVER	;UNLESS 0
	PUSHJ	P,LTAB
	MOVE	P1,NOCHRS	;GET POSITION
	ADDI	P1,7		;ALLOW FOR DELAYED TABBING
	TRZ	P1,7		;TAB OVER
	MOVNS	P1		;PREPARE TO SUBTRACT
	PUSHJ	P,LVER
	ADD	P1,NOCHRS	;GET DISTANCE MOVED BY VERSION
	TXNN	F,L.FRMT	;[335] IF NICE OUTPUT FORMAT
	JRST	FNVER		;[335] NO - SKIP FORMATTING STUFF
	CAIG	P1,7		;[335] AND LESS THAN ONE TAB
	PUSHJ	P,LTAB		;[335] YES--MOVE ANOTHER TAB
	SKIPLE	S.SORT		;[335] /SORT'ING ?
	 JRST	FNVER		;[335] YES - DON'T AFFECT TAB PLACEMENT
FLS335:	PUSHJ	P,LSPC		;[335] MOVE (AT LEAST) ONE SPACE
	MOVE	P1,NOCHRS	;[335] GET COLUMN (CHARACTER) COUNT
	TRNE	P1,4		;[335] 1.5 TAB COLUMNS YET?
	 JRST	FL335A		;[335] YES - NO MORE SPACING
	TRNE	P1,3		;[335] 1.5 TAB COLUMNS OVER?????
	 JRST	FLS335		;[335] NOT YET - KEEP SPACING
FL335A:	TXO	F,R.STAB	;[335] AND FLAG SUPPRESS NEXT TAB
				;[335] AS ALREADY PROPERLY POSITIONED.
				CONT.
FNVER:	SKIPG	S.AUT		;SEE IF /AUTHOR			[174]
	JRST	FLSDIR		;NO--JUST GO DO DIRECTORY	[174]
	SKIPE	T2,UFDPPN	;GET FILE'S OWNER		[174]
	TLNE	T2,-1		;SEE IF SFD			[174]
	SKIPA			;NO				[174]
	MOVE	T2,.PTPPN(T2)	;YES--GET OWNER			[174]
	SKIPE	T1,FAUT		;SEE IF AUTHOR			[174]
	XOR	T1,T2		;YES--COMPARE TO OWNER		[174]
	TXNN	F,L.FRMT	;[335] SEE IF NICE OUTPUT FORMAT
	JUMPE	T1,FLSDIR	;NO--SEE IF SAME AS OWNER	[174]
	PUSHJ	P,LTAB		;TAB OVER			[174]
	PUSHJ	P,LAUT		;YES--GO LIST AUTHOR		[174]
FLSDIR:	TXZ	F,R.STAB	;[335] ONLY SUPRESS TAB IF IN AUTHOR
	SKIPN	S.SORT		;UNLESS /SORT			[246]
	SKIPN	S.WDTH		;SEE IF /W
	PUSHJ	P,LSTRDR	;NO--OUTPUT STR AND DIRECT.
	TRNN	F,R.FAST	;SEE IF /F
	SKIPN	T2,FSPL		;NO--SEE IF SPOOLED NAME
	JRST	FNSPL		;NO--SKIP OUTPUT
	PUSHJ	P,LTAB		;YES--SPACE OVER
	PUSHJ	P,LSIXN		;AND TYPE SPOOLED NAME
FNSPL:	MOVE	T1,NOCHRS	;SEE IF DONE WITH THIS LINE
	CAMG	T1,MXWDTH	;SEE IF OVER REQUEST		[320]
	PJRST	LTAB		;NO--GO ISSUE TAB
	PJRST	LCRLF

;ROUTINE TO ISSUE DOT OR SPACE BEFORE EXTENSION

LTBEXT:	TRNE	F,R.FAST	;SEE IF /F
	SKIPE	S.WDTH		;YES--SEE IF NOT /WIDTH
	PJRST	LTAB		;NO--ISSUE TAB
	SKIPE	S.SORT		;SEE IF /SORT			[236]
	PJRST	LTAB		;YES, THEN NO .			[236]
	MOVEI	C,"."		;YES--USE DOT (IT'S FASTER)
	PJRST	LCHR		; AND RETURN
;HERE TO OUTPUT A DETAILED DIRECTORY LISTING

DLIST:	SKIPE	T2,FDEV		;GET UNIT
	SKIPN	S.UNIT		;IF /NOUNITS
	SKIPE	T2,FSTR		;  OR IF UNIT NOT AVAILABLE, USE STR	[316]
	PUSHJ	P,LSIXCL	;LIST IN SIXBIT WITH COLON
	HLRZ	T1,FEXT		;GET EXTENSION
	CAIN	T1,'UFD'	;SEE IF UFD
	SKIPGE	T4,FNAM		;AND NOT ALPHA
	JRST	DLNAME		;NO--LIST AS ALPHA
	PUSHJ	P,LXWD		;LIST AS XWD
	JRST	DLEXT		;GO HANDLE EXTENSION
DLNAME:	MOVE	T2,FNAM		;GET NAME
	PUSHJ	P,LSIXN		;LIST IN SIXBIT
DLEXT:	MOVEI	C,"."		;LIST
	PUSHJ	P,LCHR		;PUNCTUATION
	HLLZ	T2,FEXT		;GET EXTENSION
	PUSHJ	P,LSIXN		;LIST IT
	MOVEI	P1,0		;CLEAR OFFSET POINTER
	PUSHJ	P,FLBDIR	;LIST DIRECTORY WITH []

	DEFINE	MSG(A),<
	MOVEI	M,[ASCIZ /
A: /]
	PUSHJ	P,LSTR
	>

	HRRZ	T4,FEXT		;GET ACCESS DATE
Ife FT$TYM,<ANDX T4,RB.ACD>	;MASK DOWN			[176]
Ifn FT$TYM,<ANDX T4,740000>	; Mask down to Tymshare size
	JUMPE	T4,DLCREA
	MSG	<Access date>
Ifn FT$TYM,<	; Tymshare uses different Date format!!!
	Push	P,T1		; Save this
	Push	P,T2		;   and this!
	Hrroi	T1,.Gtprv	; Read priv bits @ Tymshare
	Gettab	T1,		;  to get your time zone
	  Movsi	T1,4000		; GMT if none
	Ldb	T1,[POINT 5,T1,7] ; Get the time zone
	Movei	T2,20		; Setup GMT
	Subm	T2,T1		; Subtract GMT - Results to Memory
	Move	T2,T4		; Copy date
	Jumpge	T1,DACCGD	; Access date ok!
	Soj	T2,		; Decrement date by 1
	Addi	T1,^D24		; Add a day of hours
DACCGD:	Imul	T1,[^D60*^D60*^D1000] ; make into milliseconds
	Pushj	P,.CNDCT##	; Convert to DEC
	Movem	T2,T4		; Use new date
	Pop	P,T2		; Restore registers
	Pop	P,T1		; .. and proceed
> ; End Ifn FT$TYM
	PUSHJ	P,LDATE
				CONT.
DLCREA:	MOVE	T4,FCRE		;GET CREATION
	ANDX	T4,RB.CRD!RB.CRT  ; TIME AND DATE		[162]
	ROT	T4,-<WID(RB.CRD)>  ;DATE AT HIGH END		[162]
Ife FT$TYM,<LDB	T3,[POINTR (FEXT,RB.CRX)]>	; GET DATE EXTENSION	[162]
Ifn FT$TYM,<LDB	T3,[POINT 2,FEXT,21]>		; Get High order bits
	LSHC	T3,WID(RB.CRD)	;GET DATE TOGETHER		[162]
	SKIPN	T3		;				[162]
	JUMPE	T4,DLPROT
	MSG	<Creation time, date>
	LSH	T4,-<WID(RB.CRD)>  ;POSITION TIME		[162]
Ifn FT$TYM,<	; Tymshare uses different Date format!!!
	Push	P,T1		; Save this
	Push	P,T2		;   and this!
	Move	T1,T4		; 0 time
	Move	T2,T3		; Copy date
	Pushj	P,.CNDCT##	; Convert to DEC
	Movem	T2,T3		; Use new date
	Movem	T1,T4		;    and time
	Pop	P,T2		; Restore registers
	Pop	P,T1		; .. and proceed
> ; End Ifn FT$TYM
	PUSH	P,T3		;SAVE DATE			[162]
	PUSHJ	P,LTIME
	PUSHJ	P,LSPC		;MAKE SOME ROOM
	POP	P,T4		;RESTORE DATE			[162]
	PUSHJ	P,LDATE
DLPROT:	SKIPN	T1,FPRV		;SEE IF FORCING			[316]
	LDB	T1,[POINTR (FCRE,RB.PRV)]	;		[162]
	JUMPL	T1,DLMODE	;SKIP IF NO PROTECTION		[316]
	MSG	<Access protection>
Ife FT$TYM,<	; For non-tymshare type octal protections
	PUSHJ	P,LOCT3Z
> ; End Ife FT$TYM
Ifn FT$TYM,<	; Print text protections
	PUSHJ	P,TYMPRV
> ; End Ifn FT$TYM
DLMODE:	MSG	<Mode>
	LDB	T1,[POINTR (FCRE,RB.MOD)]	;		[162]
	PUSHJ	P,LOCT
				CONT.
	MOVE	T1,FLEN		;GET FILE LENGTH
	SKIPE	RIBLEN		;SEE IF EXTENDED LOOKUP
	JRST	DLSIZE		;YES--GO LIST LENGTH
	HLRE	T1,T1		;NO--GET LEVEL-C STYLE
	SKIPLE	T1		;SEE IF IN BLOCKS
	ASH	T1,7		;YES--MAKE INTO WORDS
	MOVM	T1,T1		;GET NUMBER OF WORDS
DLSIZE:	JUMPE	T1,DLVERS
	MSG	<Words written>
	PUSHJ	P,LDECP

DLVERS:	SKIPN	T4,FVER		;GET VERSION
	JRST	DLVERR
	MSG	<Version>
	PUSHJ	P,LVER
DLVERR:	SKIPE	T4,FRVER	;SEE IF RIB VERSION DIFFERENT
	CAMN	T4,FVER		; FROM FILE VERSION
	JRST	DLCHEK		;NO--PROCEED
	MSG	<RIB version>
	PUSHJ	P,LVER		;OUTPUT RIB VERSION NUMBER
DLCHEK:	SKIPG	S.CHK		;SEE IF /CHECKSUM
	JRST	DLSPOL		;NO--SKIP ON
	MSG	<Computed checksum>
	PUSHJ	P,LCHECK

DLSPOL:	SKIPN	T2,FSPL		;GET SPOOLED FILE NAME
	JRST	DLESTL
	MSG	<Spooled name in ENTER>
	PUSHJ	P,LSIXN
DLESTL:	SKIPN	T1,FEST		;GET ESTIMATED LENGTH
	JRST	DLALLB
	MSG	<Estimated length>
	PUSHJ	P,LDECP
DLALLB:	SKIPN	T1,FALC		;GET ALLOCATED LENGTH
	JRST	DLALLP
	MSG	<Blocks allocated>
	PUSHJ	P,LDECP
DLALLP:	SKIPN	T1,FPOS		;GET POSITION ALLOCATED
	JRST	DLFUT1
	MSG	<Position of last allocation>
	PUSHJ	P,LDECP
				CONT.
DLFUT1:	SKIPN	T1,FFT1		;GET DEC FUTURE
	JRST	DLNCAR
	MSG	<Future DEC argument>
	PUSHJ	P,LOCT
DLNCAR:	SKIPN	T1,FNCA		;GET CUST ARG
	JRST	DLMTAP
	MSG	<Nonprivileged customer arg>
	PUSHJ	P,LOCT
DLMTAP:	SKIPN	T2,FMTA		;GET DISK BACKUP TAPE
	JRST	DLSTAT
	MSG	<Backup tape>
	PUSHJ	P,LSIXN

DLSTAT:	MOVE	T1,FSTS		;GET STATUS BITS
	HLRZ	T2,FEXT		;SEE WHAT KIND OF FILE
	CAIE	T2,'UFD'	;IF KNOWN DIRECTORY,
	CAIN	T2,'SFD'	; ..
	TXC	T1,<RP.LOG!RP.DIR!RP.ABC>  ;CORRECT STANDARD SETTINGS
	JUMPE	T1,DLERRB
	MOVE	T1,FSTS		;GET BACK STATUS
	MSG	<Status bits>
	PUSHJ	P,LOCT
DLERRB:	MOVE	T1,FELB		;GET ERROR BLOCK
	IOR	T1,FEUN		;INCLUDE ERROR UNIT AND COUNT
	JUMPE	T1,DLQUTF
	MSG	<Error logical block>
	HRRZ	T1,FELB		;GET ERROR BLOCK		[171]
	PUSHJ	P,LDECP
	MSG	<Error CONI>
	HLRZ	T1,FELB		;GET ERROR CONI BITS 12-29	[171]
	PUSHJ	P,LOCT6Z	;LIST WITH LEADING 0		[171]
	MOVEI	M,[ASCIZ /xx/]
	PUSHJ	P,LSTR		;INDICATE MISSING BITS		[171]
	MSG	<Error unit>
	HLRZ	T1,FEUN		;GET ERROR UNIT
	PUSHJ	P,LDECP
	MSG	<Number of bad blocks>
	HRRZ	T1,FEUN		;GET ERROR LENGTH IN BLOCKS
	PUSHJ	P,LDECP
				CONT.
DLQUTF:	MOVE	T1,FQTF		;GET QUOTAS
	IOR	T1,FQTO
	IOR	T1,FQTR
	IOR	T1,FUSD		;AND BLOCKS USED
	HLRZ	T2,FEXT		;AND EXTENSION
	CAIE	T2,'UFD'	;IF NOT UFD
	JUMPE	T1,DLAUTH	;AND ZERO, SKIP ON
	MSG	<Logged in quota>
	MOVE	T1,FQTF		;GET FCFS QUOTA
	PUSHJ	P,LDECP
	MSG	<Logged out quota>
	MOVE	T1,FQTO		;GET LOGGED OUT QUOTA
	PUSHJ	P,LDECP
	SKIPN	T1,FQTR		;GET RESERVED BLOCKS
	JRST	DLUSED
	MSG	<Reserved quota>
	PUSHJ	P,LDECP
DLUSED:	MSG	<Blocks used>
	MOVE	T1,FUSD
	PUSHJ	P,LDECP

DLAUTH:	HLRZ	T1,FEXT		;SEE IF
	CAIE	T1,'UFD'	; DIRECTORY
	JRST	DLAUTF		;NO--PROCEED
	MOVE	T1,FNAM		;YES--AUTHOR IS NORMALLY UFD NAME
	JRST	DLAUTC		;SO GO DO IT
DLAUTF:	SKIPN	T1,UFDPPN	;GET OWNER OF FILE
	MOVE	T1,MYPPN	;IF NONE, USE SELF
	TLNN	T1,-1		;SEE IF SFD POINTER
	MOVE	T1,.PTPPN(T1)	;YES--GET UFD
DLAUTC:	SKIPE	T4,FAUT		;GET AUTHOR
	CAMN	T4,T1		;SEE IF SAME AS OWNER
	JRST	DLNXTS		;YES--PROCEED BELOW
	MSG	<Author>
	JUMPL	T4,DLAUAL	;IF ALPHA, GO BELOW
	PUSHJ	P,LXWD
	JRST	DLNXTS
DLAUAL:	MOVE	T2,T4
	PUSHJ	P,LSIXN
				CONT.
DLNXTS:	SKIPN	T2,FNXT		;GET NEXT STR
	JRST	DLPRVS
	MSG	<Next str>
	PUSHJ	P,LSIXN
DLPRVS:	SKIPN	T2,FPRD		;GET PREVIOUS STR
	JRST	DLPCAR
	MSG	<Previous str>
	PUSHJ	P,LSIXN
DLPCAR:	SKIPN	T1,FPCA		;GET PRIV CUST ARG
	JRST	DLUFDB
	MSG	<Privileged customer arg>
	PUSHJ	P,LOCT
DLUFDB:	SKIPN	T1,FUFD		;GET DIRECTORY POINTER
	JRST	DLFLR
	MSG	<Data block in directory>
	PUSHJ	P,LDECP

DLFLR:	SKIPN	T1,FFLR		;GET RELATIVE BLOCK IN FILE
	JRST	DLXRA		;NONE--SKIP ON
	MSG	<Relative block in file>
	PUSHJ	P,LDECP
DLXRA:	SKIPN	T1,FXRA		;GET POINTER TO NEXT RIB
	JRST	DLTIM		;NONE--DO REST
	MSG	<Pointer to next RIB>
	PUSHJ	P,LOCT		;LIST IN OCTAL
DLTIM:	SKIPN	T1,FTIM		;GET INTERNAL CREATION TIME
	JRST	DLRBLK		;NONE--PROCEED			[200]
	MSG	<Internal creation date,time>
	PUSHJ	P,.CNTDT##	;CONVERT TO EASY FORMAT
	PUSH	P,T1		;SAVE TIME
	MOVE	T4,T2		;POSITION DATE
	PUSHJ	P,LDATE		;LIST DATE
	PUSHJ	P,LSPC		;SPACE OVER
	POP	P,T4		;RESTORE TIME
	IDIVI	T4,^D60000	;GET MINS
	PUSHJ	P,LTIME		;LIST HH:MM
	MOVE	T1,P1		;GET MILLI-SECS
	IDIVI	T1,^D1000	;CONVERT TO SECS
	PUSHJ	P,LTIMES	;LIST :SS
				CONT.
DLRBLK:	SKIPN	T1,FRIBLK	;SEE IF BLOCK NUMBER KNOWN	[200]
	JRST	DLXTRA		;NO--PROCEED			[200]
	MSG	<RIB block number>
	PUSHJ	P,LDECP		;YES--PRINT IN DECIMAL		[200]

;HERE WHEN ALL DONE, PRINT IN OCTAL ANY MORE THAT EXIST

DLXTRA:	MOVEI	P1,.RBXTR	;POINT TO FIRST UNDEFINED AREA
	HRLI	P1,.RBXTR-LN$RIB  ;AND COUNT OF ARGS
DLXTRL:	SKIPN	LBLOCK(P1)	;GET NEXT WORD
	JRST	DLXTRC
	MOVEI	M,[ASCIZ /
Unknown arg #/]
	PUSHJ	P,LSTR
	MOVEI	T1,(P1)		;GET POSITION
	PUSHJ	P,LOCT
	MOVEI	M,[ASCIZ /: /]
	PUSHJ	P,LSTR
	MOVE	T1,LBLOCK(P1)
	PUSHJ	P,LOCT
DLXTRC:	AOBJN	P1,DLXTRL	;LOOP UNTIL DONE

	PUSHJ	P,LCRLF		;END LINE
	PJRST	LCRLF		;ISSUE BLANK LINE AND RETURN
IFN FT$MTA,<	;MAGTAPES

;BLKOVR -- READ BLOCK OF OVERHEAD WORDS
;CALL:	T1/ AOBJN TO READ
;	PUSHJ	P,BLKOVR
;	RETURN +1 AT END OF RECORD
;	RETURN +2 IF READ OK
;COUNTS WORDS IN T2
;USES T1-4

BLKOVR:	SKIPL	T3,T1		;PUT COUNT IN SAFE PLACE
	JRST	.POPJ1##	;GOOD RETURN IF NONE TO TRANSFER
BLKO.1:	PUSHJ	P,NEXOVR	;GET NEXT WORD
	  POPJ	P,		;RETURN IF EOF
	MOVEM	T1,(T3)		;STORE AWAY
	AOBJN	T3,BLKO.1	;LOOP
	JRST	.POPJ1##	;GOOD RETURN


;NEXDTW -- READ ONE WORD COMPUTING CHECKSUM
;NEXOVW -- DITTO, BUT DON'T INCLUDE IN CHECKSUM
;NEXOVR -- DITTO, BUT STOP AT END OF RECORD
;CALL:	PUSHJ	P,NEXDTW/NEXOVW/NEXOVR
;RETURN CPOPJ IF END OF FILE
;SKIP RETURN WITH DATUM IN T1
; NEXOVR COUNTS WORDS IN T2
;USES M, C

NEXOVR:	SKIPN	BFHD+.BFCTR	;SEE IF SOMETHING HERE		[230]
	POPJ	P,		;NO--RETURN			[230]
	PUSHJ	P,NEXOVW	;YES--GET IT			[230]
	  POPJ	P,		;EOF!				[230]
	AOS	T2		;COUNT WORD			[230]
	JRST	.POPJ1##	;OK RETURN			[230]
>;END IFN FT$MTA
				CONT.

NEXOVW:	TRO	F,R.MTOH	;INDICATE OVERHEAD WORD		[222]
NEXDTW:	TLNE	F,L.FKEF	;SEE IF FAKE EOF SET
	POPJ	P,		;YES--GIVE IT AGAIN
	TLZE	F,L.SVDW	;SEE IF SAVED WORD
	JRST	[MOVE	T1,MTSVWD
		 JRST	NEXDT3]
IFN FT$MTR,<	;OLD BACKUP/RESTORE
	TLNE	F,L.BKSS	;SEE IF OLD BACKUP/RESTORE SAVE SET
	JRST	NEXDT1		;YES--GO HANDLE IT
>;END IFN FT$MTR
	SKIPN	BFHD+.BFCTR	;NO--SEE IF READY TO READ NEXT RECORD  [166]
	TLNN	F,L.SVST!L.FRSS	;AND IN SAVE SET MODE
	JRST	NEXDT2		;NO--JUST PROCEED
IFN FT$MTB,<	;BACKUP/FRS
	TLNE	F,L.FRSS	;SEE IF BACKUP/FRS
	JRST	NEXDF1		;YES--GO HANDLE
>;END IFN FT$MTB
IFN FT$MTF,<	;FAILSAFE
	PUSHJ	P,NEXDT		;FAILSAFE--READ THE NEXT WORD	[166]
	  POPJ	P,		;EOF--ALL DONE
	TLNN	T1,-1		;SEE IF MORE DATA
	JRST	NEXDT2		;YES--GO READ DATA WORD
	MOVEM	T1,MTSVHD	;NO--SAVE HEADER
	TLO	F,L.FKEF	;AND SET FAKE EOF
	POPJ	P,		;RETURN EOF
>;END IFN FT$MTF

;HERE FOR BACKUP/FRS SAVE SETS

IFN FT$MTB,<	;BACKUP/FRS
NEXDF1:	SKIPGE	B$GFLG		;SEE IF END OF FILE
		..==GF$EOF	;(FOR CREF)			[302]
	TLOA	F,L.FKEF	;YES--SET EOF
	PUSHJ	P,NEXDT		;NO--GET START OF RECORD
	  POPJ	P,		;RETURN IF EOF
	PUSHJ	P,FRSLAH	;HANDLE BACKUP/FRS LOOK-AHEAD
	MOVEM	T1,MTSVWD	;SAVE WORD JUST IN CASE
	TLNE	T1,777770	;MAKE SURE FRS OR BACKUP
	JRST	NEXDF9		;NO--SET ERROR
	TLNE	T1,-1		;SEE IF FRS
	TLO	T1,-1		;YES--SET WHOLE HALF
	XOR	T1,B$GTYP	;COMPARE WITH PREVIOUS
	JUMPL	T1,NEXDF9	;IF DIFFERENT, ERROR
>;END IFN FT$MTB
				CONT.
IFN FT$MTB,<	;BACKUP/FRS

	MOVE	T1,MTSVWD	;RESTORE WORD
IFN FT$MTS,<	;FRS
	TLNE	T1,-1		;IF FRS,
	JRST	NEXDF2		;JUMP BELOW IF FRS		[302]
>;END IFN FT$MTS
	CAIE	T1,T$FIL	;MAKE SURE FILE			[302]
	JRST	NEXDF9		;NO--ERROR			[302]
	PUSHJ	P,NEXDT		;GET RECORD NUMBER
	  POPJ	P,		;EOF!
	MOVEM	T1,B$GBNM	;STORE RECORD NUMBER		[301]
	PUSHJ	P,NEXDT		;GET TAPE NUMBER
	  POPJ	P,		;EOF!
	CAME	T1,B$GRTN	;MUST BE THE SAME
	JRST	NEXDF9		;NO--ERROR
	PUSHJ	P,NEXDT		;GET FLAGS
	  POPJ	P,		;EOF!
	MOVEM	T1,B$GFLG	;STORE
	PUSHJ	P,NEXDT		;GET CHECKSUM			[302]
	  POPJ	P,		;EOF!
	MOVEM	T1,B$GCHK	;STORE
	PUSHJ	P,NEXDT		;GET SIZE
	  POPJ	P,		;EOF!
	JUMPL	T1,NEXDF9	;ERROR IF NEGATIVE
	CAILE	T1,^D512	;SEE IF TOO BIG
	JRST	NEXDF9		;YES--ERROR
	MOVEM	T1,B$GSIZ	;STORE
	PUSHJ	P,NEXDT		;GET SKIP REGION
	  POPJ	P,		;EOF!
	JUMPL	T1,NEXDF9	;ERROR IF NEGATIVE
	MOVEM	T1,B$GLND	;STORE
	ADDI	T1,31		;COUNT OF REST OF HEADER
	JRST	NEXDF5		;GO SKIP HEADER AND JUNK
>;END IFN FT$MTB
IFN FT$MTS,<	;FRS

;HERE IF FRS--READ BLOCK HEADER
NEXDF2:	HRLZM	T1,B$GFLG	;UPDATE FLAGS			[302]
	HLRZS	T1		;GET TYPE			[302]
	CAIE	T1,4		;SEE IF FILE			[302]
	JRST	NEXDF9		;NO--ERROR			[302]
	PUSH	P,[5]		;SAVE COUNT TO SKIP FORWARD	[301]
NEXDF3:	PUSHJ	P,NEXDT		;GET HEADER
	  JRST	[POP  P,(P)	;CLEAN UP STACK
		 POPJ P,]	;RETURN EOF
	SOSLE	(P)		;COUNT DOWN
	JRST	NEXDF3		;REPEAT
	POP	P,(P)		;CLEAN UP STACK
	PUSHJ	P,NEXDT		;GET STARTING BLOCK		[302]
	  POPJ	P,		;EOF!				[302]
	MOVEM	T1,B$FRBN	;SAVE				[302]
	LSH	T1,7		;CONVERT TO WORDS		[302]
	MOVEM	T1,B$FRDW	;SAVE				[302]
	PUSHJ	P,NEXDT		;GET WORD TO SKIP		[302]
	  POPJ	P,		;EOF!				[302]
	PUSHJ	P,NEXDT		;GET DATA BLOCK IN RECORD
	  POPJ	P,		;EOF!
	SKIPL	T1		;CHECK FOR
	CAILE	T1,20		; REASONABLENESS
	JRST	NEXDF9		;NO--JUNK
	MOVEM	T1,B$FNDB	;SAVE
	PUSHJ	P,NEXDT		;GET WORDS IN LAST BLOCK
	  POPJ	P,		;EOF!
	SKIPL	T1		;CHECK FOR
	CAILE	T1,200		; REASONABLENESS
	JRST	NEXDF9		;NO--JUNK
	MOVEM	T1,B$FNDW	;SAVE
	SKIPN	T1,B$FNDB	;GET NUMBER OF BLOCKS
	SKIPGE	B$GFLG		;UNLESS EOF			[305]
	SKIPA			;YES				[305]
	MOVEI	T1,5		;(BUG IN OLD VERSION OF FRS)
	IMULI	T1,200		;CONVERT TO WORDS
	ADD	T1,B$FNDW	;GET NUMBER OF WORDS IN LAST
	CAIL	T1,200		;ALLOW FOR NO DATA		[300]
	SUBI	T1,200		;ALLOW FOR DOUBLE COUNT
	MOVEM	T1,B$GSIZ	;SAVE AS DATA SIZE		[302]
	MOVEI	T1,12		;INDICATE REST OF HEADER
>;END IFN FT$MTS
				CONT.
IFN FT$MTB,<	;BACKUP/FRS
;HERE TO SKIP REST OF FRS/BACKUP BLOCK HEADER
NEXDF5:	PUSH	P,T1		;SAVE DISTANCE
NEXDF6:	PUSHJ	P,NEXDT		;GET MORE HEADER
	   JRST	[POP  P,(P)	;CLEAN UP STACK
		 POPJ P,]	;RETURN EOF
	SOSLE	(P)		;COUNT DOWN
	JRST	NEXDF6		;LOOP OVER HEADER
	POP	P,(P)		;RESTORE STACK
	MOVE	T1,B$GSIZ	;GET LENGTH OF DATA AREA	[302]
	MOVEM	T1,BFHD+.BFCTR	;STORE AS REAL STUFF TO READ
	JRST	NEXDTW		;GO GET SOME DATA		[300]

NEXDF9:	TLO	F,L.FKEF!L.SVDW	;INDICATE ERROR
	POPJ	P,		;RETURN
>;END IFN FT$MTB
IFN FT$MTR,<	;OLD BACKUP/RESTORE

;HERE FOR OLD BACKUP/RESTORE SAVE SETS

NEXDT1:	SOSLE	MTSVCT		;DECREMENT COUNT
	JRST	NEXDT2		;STILL IN THIS HEADER
	PUSHJ	P,NEXDT		;GET NEXT HEADER		[166]
	  POPJ	P,		;RETURN IF EOF
	MOVEM	T1,MTSVWD	;SAVE WORD IN CASE
	TRZ	T1,777000	;CLEAR BACK POINTER
	HRRZM	T1,MTSVCT	;SET COUNT
	HLRZS	T1		;GET CONTROL HEADER
	CAIE	T1,400000	;IS IT DATA?
	JRST	[TLO F,L.FKEF!L.SVDW  ;SET FLAGS
		 JRST NEXDT4]	;GIVE EOF RETURN
	PUSHJ	P,NEXDT		;THROW AWAY CHECKSUM		[166]
	  POPJ	P,		;EOF
	JRST	NEXDT2		;GO DO NORMAL READ NOW
>;END IFN FT$MTR

Define	TYM$CK(MEM)<
	EXCH	T1,MEM		;GET CHECKSUM SO FAR
  Ife FT$TYM,<	; Use DEC's Checksum routine
	ROT	T1,1		;ROTATE
	ADD	T1,MEM		;ADD THIS WORD
  > ; End Ife FT$TYM
  Ifn FT$TYM,<	; Tymshare Checksum routine
	ROT	T1,7		; Rotate
	XOR	T1,MEM		; Xor
	AOJ	T1,		; Add
  > ; End Ifn FT$TYM
	EXCH	T1,MEM		;STORE AWAY
> ; End Define TYM$CK

NEXDT2:	PUSHJ	P,NEXDT		;READ FILE			[166]
	  JRST	NEXDT4		;RETURN IF EOF
NEXDT3:	TRZE	F,R.MTOH	;SEE IF MAG TAPE OVERHEAD	[222]
	JRST	.POPJ1##	;YES--DON'T CHECKSUM IT	[222]
	TYM$CK	CHKSUM		; Checksum file
	TYM$CK	SCHKSM		; Checksum summary
	TYM$CK	TCHKSM		; Checksum grand total
	JRST	.POPJ1##	;AND SKIP RETURN

NEXDT4:	SETZM	MTSVCT		;CLEAR COUNTER
	POPJ	P,		;RETURN
IFN FT$MTB,<	;BACKUP/FRS

;FRSLAH -- ROUTINE TO HANDLE FRS/BACKUP LOOK-AHEAD TO CORRECT ERRORS
;CALL:	1/ FIRST WORD OF A RECORD
;	PUSHJ	P,FRSLAH
;	RETURNS 1/FIRST WORD OF FIRST GOOD RECORD
;USES NO AC'S

FRSLAH:	PUSH	P,T1		;SAVE T1
	MOVE	T1,@BFHD+.BFADR	;GET POINTER TO NEXT BUFFER
	SKIPL	.BFHDR-1(T1)	;MAKE SURE IT IS FULL
	JRST	FRSLHG		;NO--ASSUME ALL OK
	SKIPL	B$GTYP		;IS IT FRS OR BACKUP
	SKIPA	T1,.BFCNT+G$FLAG(T1) ;BACKUP--GET FLAGS		[302]
	HRLZ	T1,.BFCNT(T1)	;FRS--GET FLAGS
	TXNN	T1,GF$RPT	;IS IT A REPEAT			[302]
	JRST	FRSLHG		;NO--OK TO RETURN
	POP	P,(P)		;DISCARD OLD RECORD
	SETZM	BFHD+.BFCTR	; ..
	PUSHJ	P,NEXDT		;GET NEXT
	  TLO	F,L.FKEF	;EOF!
	JRST	FRSLAH		;AND TRY AGAIN

FRSLHG:	POP	P,T1		;RESTORE FIRST WORD
	POPJ	P,		;RETURN
>;END IFN FT$MTB
;NEXDT -- ROUTINE TO READ ONE WORD FROM THE BUFFER
;NON-SKIP RETURN IF EOF
;SKIP RETURN WITH WORD IN T1

NEXDT:	SOSGE	BFHD+.BFCTR	;SEE IF ANY LEFT
	JRST	NEXDTR		;NO--GO DO A READ
	ILDB	T1,BFHD+.BFPTR	;YES--GET IT
	JRST	.POPJ1##	;SKIP RETURN

NEXDTR:	IN	DC,		;READ NEXT BLOCK
	  JRST	NEXDT		;GO ANALYZE
	STATO	DC,IO.ERR	;ERROR--SEE IF ERROR OR EOF
	  JRST	NEXDTF		;NOT ERROR--CHECK EOF

	PUSHJ	P,.PSH4T##	;SAVE ALL TEMPS
	N$WRNX	(IDE,Error)
	GETSTS	DC,T1		;GET ERROR STATUS
	MOVE	T2,T1		;MAKE A COPY
	TRZ	T2,IO.ERR	;CLEAR OUT ERROR BITS
	SETSTS	DC,(T2)		;SET CLEARED STATUS
	PUSHJ	P,.TOCTW##	;TYPE STATUS IN OCTAL
	MOVEI	T1,[ASCIZ / while reading /]
	PUSHJ	P,.TSTRG##	;OUTPUT MORE OF MESSAGE
IFN FT$MTA,<	;MAGTAPE
	SKIPE	T1,MTNAME	;SEE IF MAG-TAPE NAME
	JRST	[PUSHJ P,.TSIXN##  ;YES--TYPE IT
		 MOVEI T1,[ASCIZ /: file /]
		 PUSHJ P,.TSTRG##  ;MORE MESSAGE
		 JRST  .+1]	;PROCEED
>;END IFN FT$MTA
	MOVEI	T1,OPENBL	;POINT TO OPEN BLOCK
	MOVEI	T2,LBLOCK	;POINT TO LOOKUP BLOCK
	PUSHJ	P,.TOLEB##	;ISSUE FILE SPEC
X$$IDE:	PUSHJ	P,.TCRLF##	;END LINE
	PUSHJ	P,.POP4T##	;RESTORE TEMPS

NEXDTF:	STATO	DC,IO.EOF	;SEE IF EOF
	  JRST	NEXDT		;NO--GO PROCESS INPUT
	POPJ	P,		;YES--GIVE EOF RETURN
;CHKNXF -- CHECK FOR PREVIOUS SPEC. WAS NON-EXISTENT EVERY PLACE
;PRESERVES T1-4

CHKNXF:	CAMN	I,LASI		;SEE IF STILL SAME REQUEST
	POPJ	P,		;YES--DON'T WORRY YET
	MOVEM	I,LASI		;SAVE LAST REQUEST
	SKIPN	NXFCNT		;SEE IF ANY FILE FOUND
	SKIPN	NXFI		;NO--SEE IF ERROR FOUND
	JRST	CHKNXY		;NO--JUST CLEAN UP AND RETURN
	PUSH	P,T1		;PRESERVE T1-4
	PUSH	P,T2	
	PUSH	P,T3
	PUSH	P,T4
	EXCH	I,NXFI		;GET OLD I
	MOVEI	T1,H.ZERX-H.ZER1  ;POINT TO OLD COPY AREA
	MOVE	T2,I.DEV(I)	;GET ORIGINAL DEVICE REQUESTED
	MOVEM	T2,FSTR(T1)	;SAVE AWAY FOR LATER
	HLLZS	FEXT(T1)	;CLEAR ERROR CODE
	SKIPN	NXUCNT		;SEE IF UFD FOUND
	JRST	[MOVEI T2,1	;NO--SET UFD NOT FOUND
		 SKIPE NXSCNT	;SEE IF SFD MISSING
		 MOVEI T2,23	;YES--SET THAT CODE
		 HRRM  T2,FEXT(T1)  ;AND STORE THE
		 JRST  .+1]	;  CODE AWAY
	PUSHJ	P,E.DFLS	;ISSUE ERROR
	MOVE	I,NXFI		;RESTORE I
	POP	P,T4		;RESTORE T1-4
	POP	P,T3
	POP	P,T2
	POP	P,T1

CHKNXY:	SETZM	NXFI		;CLEAR ERROR FLAG
	SETZM	NXFCNT		;CLEAR FOUND COUNT
	SETZM	NXSCNT		;CLEAR NX SFD COUNT
	POPJ	P,		;RETURN
;SUBROUTINE IF LOOKUP ERROR

E.DFLL:	HRRZ	T1,FEXT		;GET ERROR CODE
	CAIN	T1,ERPRT%	;SEE IF PROTECTION ERROR	[233]
	JRST	[MOVX  T2,FX.PRT ;YES--SEE IF /OKPROT		[233]
		 TDNN  T2,.FXMOD(I) ; ..			[233]
		 JRST  .+1	;NO--PROCEED			[233]
		 MOVEI T1,LBLOCK ;YES--USE			[233]
		 MOVEI T2,LN$RIB ; E.LKEN			[233]
		 MOVEI T3,(I)	; TO GET WILD			[233]
		 PJRST E.LKEN##] ; ERROR COUNTS			[233]
	CAIE	T1,ERSNF%	;SEE IF NX SFD
	CAIG	T1,ERIPP%	;NO--SEE IF NX FILE OR NX UFD
	SKIPG	.WLDFL##	;YES--SEE IF STR WILDCARDING
	JRST	E.DFLC		;NO--ISSUE MESSAGE NOW ANYWAY
	SKIPN	T1		;SEE IF UFD PRESENT
	AOS	NXUCNT		;NON-X FILE
	CAIN	T1,ERSNF%	;SEE IF SFD
	AOS	NXSCNT		;YES--COUNT IT
	MOVEM	I,NXFI		;YES--SAVE I AS FLAG FOR LATER
				;THIS IS NEEDED BECAUSE WE WISH TO
				; GIVE NX FILE MESSAGE ONLY IF IT DOES
				; NOT EXIST ON ANY STR IN THE LIST
	MOVE	T1,[H.ZER1,,H.ZERX]
	BLT	T1,H.ZERY-1	;COPY TO ALTERNATE AREA
IFN FT$SFD,<
	SKIPE	T1,UFDPPN	;SEE IF SFD TO COPY
	TLNE	T1,-1		;  ..
	POPJ	P,		;NO--RETURN
	HRLZ	T1,T1		;YES--COPY TO ALTERNATE
	HRRI	T1,H.ZERY	;  AREA
	BLT	T1,H.ZERY+2+LN$DRB  ; ..
>
	POPJ	P,		;GO AROUND THE LOOP

E.DFLC:	MOVEI	T1,0		;POINT TO REGULAR AREA
	PUSHJ	P,E.DFLS	;ISSUE ERROR MESSAGE
	AOS	SNFILR		;COUNT LOOKUP ERROR
	AOS	NXFCNT		;COUNT FILE FOUND
	POPJ	P,		;AND GO AROUND LOOP
;E.DFLS -- SUBROUTINE TO PRINT ERROR IN FILE LINE
;T1 MUST BE SET TO 0 FOR REGULAR AREA
;USES T1, T2, T3, T4, M, C

E.DFLS:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,T1		;SAVE POINTER THERE
	TRO	F,R.TYPE	;DUPLICATE TO TTY:		[173]
	PUSHJ	P,SSTRDR	;OUTPUT DIR AND DEV		[173]
	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	N$WRNX	(LKE,)
	HRRZ	T1,FEXT(P1)	;GET ERROR CODE			[173]
	MOVE	T3,FCRE(P1)	;GET LOOKUP ANSWER (PROT. CODE)	[173]
	PUSHJ	P,.LKERR##	;LIST ERROR CODE		[173]
	MOVEI	T1,[ASCIZ / file    /]
	PUSHJ	P,.TSTRG##	;OUTPUT HEADING			[173]
	PUSHJ	P,LSTFNX	;LIST FILE NAME
	MOVEI	C,"."		;SEPARATE WITH			[177]
	PUSHJ	P,LCHR		; A DOT				[177]
	HLLZ	T2,FEXT(P1)	;GET EXTENSION
	PUSHJ	P,LSIXT		;LIST IT
	MOVEI	T1,.CHTAB	;PICK UP TAB
	PUSHJ	P,.TTCHR	; AND TYPE IT
	SKIPN	S.WDTH		;SEE IF /WIDTH
	PUSHJ	P,LSTRDX	;LIST STR/DIR
X$$LKE:	TRZ	F,R.TYPE	;CLEAR FLAG			[244]
	PJRST	.TCRLF##	;END LINE			[244]
;LSTFNM -- LIST FILE NAME IN APPROPRIATE MODE
;USES T1, T2, T3, T4

LSTFNM:	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;SET TO NO OFFSET
LSTFNX:	HLRZ	T1,FEXT(P1)	;LOOK AT EXTENSION
	CAIN	T1,'UFD'	;TO SEE IF IT IS A UFD
	SKIPGE	FNAM(P1)	;YES--SEE IF ALPHA
	JRST	.+2		;YES--USE SIXBIT ANYWAY
	JRST	FLUFD		;NO--SPECIAL PRINT
	MOVE	T2,FNAM(P1)	;OUTPUT FILE NAME
	PJRST	LSIX		;LIST IN SIXBIT			[177]

FLUFD:	HLRZ	T1,FNAM(P1)	;GET PROJECT
	PUSHJ	P,LOCT6B	;ISSUE RIGHT ADJUSTED
	MOVEI	C,","		;ISSUE COMMA
	PUSHJ	P,LCHR		; ..
	HRRZ	T1,FNAM(P1)	;GET PROGRAMMER
	PJRST	LOCT		;ISSUE LEFT ADJUSTED		[177]
;SSTRDR -- SET FLAGS TO LIST STR AND OR DIRECTORY
;CALL:	PUSHJ	P,SSTRDR
;	WITH I AND P1 SETUP
;USES T1-4

SSTRDR:	MOVE	T1,FSTR(P1)	;SEE IF SAME FILE STRUCTURE
	CAMN	T1,[SIXBIT /DSK/]
	SKIPE	LASSTR		;IS IT THE FIRST ONE?
	JRST	.+2		;NO--PRINT IT
	MOVEI	T1,0		;IF FIRST DSK, NEVER PRINT
	MOVEM	T1,LSTSTR	;SAVE FOR PRINTING
	EXCH	T1,LASSTR	;UPDATE MEMORY
	CAMN	T1,LASSTR	;SEE IF DIFFERENT
	SETZM	LSTSTR		;SAME--FLAG TO NOT PRINT

	MOVEI	T3,(I)		;POINT TO DIRECTORIES
	HRLI	T3,-LN$DRB	;SET COUNT
SSTRD1:	SKIPN	I.DIR-I.DEV(T3)	;SEE IF NULL DIRECTORY
	SKIPE	T2,I.DIRM-I.DEV(T3)  ;YES--USE WILDCARD STRAIGHT
	SETCM	T2,I.DIRM-I.DEV(T3)
IFN FT$SFD,<
	JUMPN	T2,SSTRD2	;IF WILD--PROCEED
	AOS	T3		;ADVANCE EXTRA SHOT
	SKIPN	I.DIR-I.DEV-1(T3)  ;SEE IF AT END
	SKIPE	I.DIRM-I.DEV-1(T3)  ; ..
	AOBJN	T3,SSTRD1	;LOOP UNTIL DONE
SSTRD2:
>

;HERE WITH T2=0 IF NOT WILD DIRECTORY, .NE. 0 IF WILD
;COPY THIS DIRECTORY TO OLD ONE WATCHING FOR CHANGES

	MOVE	T1,UFDPPN(P1)	;SEE IF SAME DIRECTORY
	MOVEM	T1,LSTDIR	;SAVE FOR LISTING
	EXCH	T1,LASDIR	;UPDATE MEMORY
	PUSH	P,T2
IFN FT$SFD,<
	MOVE	T2,T1		;SETUP POINTER TO OLD AREA
	MOVE	T3,UFDPPN(P1)	;  AND TO NEW AREA
	TLNE	T3,-1		;SEE IF NEW HAS PATH
	JRST	SSTRD4		;NO--PROCEED
	TLNE	T2,-1		;IF OLD DIDN'T,		[211]
	SETOM	T1		; THEN DEFINITELY DON'T MATCH	[211]
				CONT.
	MOVEI	T2,LASPTH	;POINT TO LAST PATH
	HRLI	T3,-LN$DRB	;SET LOOP COUNTER
SSTRD3:	MOVE	T4,.PTPPN(T3)	;GET NEW DIRECTORY
	CAME	T4,.PTPPN(T2)	;SEE IF SAME AS OLD ONE
	SETOM	T1		;NO--SET DIFFERENT FLAG
	MOVEM	T4,.PTPPN(T2)	;STORE FOR OLD MEMORY
	AOS	T2		;ADVANCE OLD POINTER
	SKIPE	T4		;SEE IF END OF PATH YET
	AOBJN	T3,SSTRD3	;NO--LOOP UNTIL DONE
	CAME	T1,[-1]		;SEE IF DIFFERENT
	MOVE	T1,LASDIR	;SAME--FAKE OUT CHECK BELOW
SSTRD4:>

;HERE WITH T1=OLD DIRECTORY (OR -1 IF KNOWN DIFFERENT)

	CAMN	T1,LASDIR	;NO--SEE IF CHANGED
	SETZM	LSTDIR		;NO--CLEAR LISTING FLAG

	TRNE	F,R.FAST	;SEE IF /F
	SKIPLE	S.SUM		;YES--SEE IF /SUM
	JRST	.+2		;/F/SUM OR NOT /F
	JRST	SSTRD6		;/F AND NOT /SUM--NO SUBTOTALS
	SKIPN	LSTSTR		;SEE IF SEVERAL STRS
	SKIPE	LSTDIR		;OR SEVERAL DIRS
	PUSHJ	P,SUBTOT	;YES--ISSUE SUBTOTALS
	MOVE	T1,LASSTR	;GET LAST STRUCTURE
	MOVEM	T1,SUBSTR	;SAVE FOR SUBTOTALS
IFE FT$SFD,<
	MOVE	T1,LASDIR>
IFN FT$SFD,<
	SKIPE	T1,LASDIR	;GET LAST DIRECTORY
	TLNE	T1,-1		;SEE IF PATH POINTER
	JRST	SSTRD5		;NO--JUST STORE WORD
	HRLZS	T1		;SET AS FROM POINTER
	HRRI	T1,SUBPTH	;SET TO POINTER
	BLT	T1,SUBEND	;COPY PATH
	MOVEI	T1,SUBPTH	;SET POINTER TO SUBTOTAL PATH
SSTRD5:>
	MOVEM	T1,SUBDIR	;SAVE SUBTOTAL DIRECTORY
				CONT.
SSTRD6:	POP	P,T2		;RESTORE WILD FLAG (.NE. 0 IF WILD)
	SKIPN	S.SORT		;SEE IF SORTING
	JRST	SSTRD7		;NO--PROCEED
	SETOM	LSTSTR		;YES--SET TO LIST
	SETOM	LSTDIR		;LIST DIRECTORY
	SKIPGE	T1,.WLDFL##	;SEE IF WILD STR
	SETCM	T1,T1		;  OR WILD FILE AND STR
	CAIE	T1,1		; ..
	SETZM	LSTSTR		;NO--CLEAR LIST
	SKIPN	T2		;CHECK WILD DIRECT
	SETZM	LSTDIR		;NO--CLEAR LIST DIRECT
SSTRD7:	SKIPLE	S.IND		;IF /INDIRECT			[322]
	JRST	[SKIPN S.PRDE	;[336] IF /NOPRDEVICE
		  POPJ	P,	;[336] THEN DON'T OUTPUT DEVICE NAME
		 SKIPE T2,FSTR	; IF STRUCTURE KNOWN,		[322]
		 PUSHJ P,LSIXCL	; OUTPUT IT ALWAYS		[322]
		 POPJ  P,]	;AND RETURN			[322]
	SKIPN	S.SORT		;UNLESS /SORT,			[246]
	SKIPN	S.WDTH		;SEE IF /W SPECIFIED
	JRST	SSTRD8		;NO--PROCEED			[174]
	SKIPN	LSTSTR		;YES--SEE IF CHANGE OF STR
	SKIPE	LSTDIR		; OR OF DIRECTORY
	JRST	.+2		;YES--PRINT THEM
	JRST	SSTRD8		;NO--SKIP OUTPUT		[174]
	PUSHJ	P,.TNEWL	;FORCE NEW LINE
	PUSHJ	P,LSTRDX	;PRINT STR AND DIRECTORY
	PUSHJ	P,.TNEWL	;SPACE OVER AND RETURN		[174]

SSTRD8:	SKIPL	T1,S.PRDE	;SEE IF /PRDEVICE		[174]
	MOVEM	T1,LSTSTR	;YES--USE THAT			[174]
	SKIPL	T1,S.PRDI	;SEE IF /PRDIRECTORY		[174]
	MOVEM	T1,LSTDIR	;YES--USE THAT			[174]
	POPJ	P,		;RETURN				[174]
;LSTRDR -- LIST STRUCTURE AND DIRECTORY IF APPROPRIATE
;CALL:	PUSHJ	P,LSTRDR
;RETURNS
;USES T1, T2, T3, T4, C, M

LSTRDR:	SKIPLE	S.IND		;IF /INDIRECT,			[322]
	 JRST	[SKIPN	S.PRDI	;[336] DOES HE WANT DIRECTORY?
		 POPJ	P,	;[336] NO - JUST RETURN NOW
		 JRST	FLBDIR] ;[336] YES - PRINT DIRECTORY SANS <TAB>
	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;SET TO NO OFFSET
LSTRDX:	SKIPN	LSTSTR		;SEE IF APPROPRIATE TO LIST
	JRST	FNSTR		;NO--PROCEED
	SKIPE	T1,NOCHRS	;SEE IF INTO LINE
	JRST	[CAIG  T1,7	;SEE IF AT LEAST COL 8 YET
		 PUSHJ P,LTAB	;NO--MOVE OVER
		 PUSHJ P,LTAB	;YES--POSITION
		 JRST  .+1]	;PROCEED
	SKIPE	T2,FSTR(P1)
	PUSHJ	P,LSIXCL	;DO SO IN SIXBIT WITH COLON
FNSTR:	SKIPN	LSTDIR		;SEE IF TIME TO LIST
	POPJ	P,		;NO--PROCEED
FLDIR:	SKIPE	NOCHRS		;SEE IF INTO LINE
	PUSHJ	P,LTAB

;FLBDIR -- SUBROUTINE TO LIST DIRECTORY INSIDE []

FLBDIR:	SKIPN	T4,UFDPPN(P1)	;IF UFD,			[316]
	POPJ	P,		;(NO--RETURN)			[316]
	MOVEI	C,"["
	PUSHJ	P,LCHR
	PUSHJ	P,LDIRB
	MOVEI	C,"]"
	PJRST	LCHR		;AND RETURN
SUBTTL	PERFORM DECTAPE DIRECTORY LISTING

;HERE WHEN DEVICE IS A DECTAPE

DTDIR:	TRO	F,R.NDSK	;INDICATE NOT A DISK		[202]
	MOVX	T1,FX.PHY	;SET /PHYSICAL BIT
	TDZE	T1,I.MOD(I)	;SEE IF /PHYS
	TLOA	T1,(UU.PHS)	;YES--SET UUOO FLAG
	MOVEI	T1,0		;NO--CLEAR FLAGS
	MOVE	T2,I.DEV(I)	;GET DEVICE NAME
	MOVEI	T3,BFHD		;BUFFER				[166]
	OPEN	DC,T1		;OPEN
	  PJRST	E.DFO##		;IF FAILED
	SKIPLE	S.FDTA		;SEE IF FAST DECTAPE MODE	[225]
	JRST	[MOVEI T1,DIRB-2 ;SET BUFFER RING		[225]
		 EXCH  T1,.JBFF ; FOR REGULAR			[225]
		 INBUF DC,1	;SINGLE BUFFER			[225]
		 EXCH T1,.JBFF ;FOR DIRECTORY			[225]
		 CAILE T1,DIRB+200 ;SEE IF FITS			[225]
		 JRST  .+1	;NO--USE DUMP			[225]
		 MOVEI T2,-T1	;OFFSET IN IN UUO		[225]
		 JRST  DTDIRF]	;PROCEED			[025]
	SETSTS	DC,.IODMP	;SET FOR DUMP MODE		[225]
	MOVE	T1,[IOWD 200,DIRB]
	MOVEI	T2,0
	MOVX	T3,%CNVER	;GET MONITOR
	GETTAB	T3,		; VERSION
	  MOVEI	T3,0		; (DEFAULT TO OLD)
	TLZ	T3,-1		;CLEAR CUSTOMER AREA
	CAIL	T3,50311	;SEE IF 504 YET
	JRST	DTDIRP		;YES--USE NEW MODE TO JUST POSITION
	USETI	DC,^D98		;POSITION AHEAD OF DIRECTORY
	INPUT	DC,T1		;READ BLOCK TO FORCE POSITIONING
DTDIRP:	SETSTS	DC,IO.SSD!IO.NSD!.IODMP  ;CHANGE TO SPECIAL MODE
DTDIRF:	USETI	DC,^D100	;READ DIRECTORY BLOCK
	IN	DC,T1(T2)	; =0 IF ASCII			[225]
	  JRST	.+2		;IF OK
	PUSHJ	P,DTERR		;IF ERROR READING		[216]
	SETSTS	DC,.IOASC	;SET TO ASCII (BUFFER) IN CASE	[226]
				; SAME DEVICE IS LISTING DEVICE	[226]
	RELEASE	DC,		;GIVE DEVICE BACK NOW

	SKIPE	T2,DIRB+177	;SEE IF TAPE IDENT FIELD
	CAMN	T2,[-1]		;IS 0 OR -1
	JRST	DTDIR1		;YES--DON'T PRINT
	MOVEI	M,[ASCIZ /Tape ID: /]
	PUSHJ	P,LSTR		;LIST NAME
	PUSHJ	P,LSIX		;LIST IDENTIFICATION
	PUSHJ	P,LCRLF		;END OF LINE
				CONT.
DTDIR1:	MOVEI	M,[ASCIZ /Free: /]
	PUSHJ	P,LSTR		;LIST LABEL FOR SPACE
	MOVSI	J,-27		;COUNT FREE BLOCKS
				;  ALSO PRESET J FOR LATER
	PUSHJ	P,DTCNT		;FREE IF IN FILE #0
	PUSHJ	P,LDEC3		;PRINT AS 3 DIGITS
	MOVEI	M,[ASCIZ / blks, /]
	PUSHJ	P,LSTR		;HEADER

	MOVEI	T1,0		;INITIALIZE FREE FILE COUNTER
	MOVEI	T2,26		;INITIALIZE FILE COUNTER
DTDIR2:	SKIPN	DIRB+122(T2)	;LOOK AT FILE NAME FIELD
	ADDI	T1,1		;IF =0, COUNT FREE
	SOJG	T2,DTDIR2	;LOOP FOR 22 FILES
	PUSHJ	P,LDEC2		;PRINT RESULT
	MOVEI	M,[ASCIZ / files/]
	PUSHJ	P,LSTR		;AND FINISH LABELING
	PUSHJ	P,LCRLF		;AND FINISH LINE
				CONT.
;HERE TO LOOP OVER FILES AND PRINT ONE LINE EACH

DTFIL1:	AOBJP	J,DIREND	;INCREMENT TO NEXT FILE
	SKIPN	T1,DIRB+122(J)	;SEE IF IN USE
	JRST	DTFIL1		;NO--LOOP BACK
	MOVEM	T1,FNAM		;SAVE FILE NAME
	HLLZ	T1,DIRB+150(J)	;GET EXTENSION
	MOVEM	T1,FEXT		;SAVE
	SETZM	UFDPPN		;CLEAR DIRECTORY WORD
	PUSHJ	P,ISMATC	;CHECK FOR MATCH
	  JRST	DTFIL1		;NO MATCH--LOOP FOR MORE
	TRNN	F,R.FAST	;SEE IF /FAST			[220]
	SKIPG	S.SUM		; OR NOT /SUM			[220]
	SKIPA			;YES--PROCEED			[220]
	JRST	DTFIL2		;NO--SKIP OUTPUT		[220]
	MOVE	T2,FNAM		;GET FILE NAME
	MOVEI	T3,6		;USE 6 SPACES
	PUSHJ	P,LSIXC		;LIST IT
	MOVEI	C,"."		;USE . AS SEPARATOR
	PUSHJ	P,LCHR		;PRINT IT
	HLLZ	T2,FEXT		;GET EXTENSION
	MOVEI	T3,3		;USE 3 SPACES
	PUSHJ	P,LSIXC		;LIST IT
DTFIL2:	PUSHJ	P,DTCNT		;COUNT BLOCKS			[201]
	ADDM	T1,NOBLKS	;COUNT FOR SUMMARY		[201]
	SKIPG	S.SUM		;IF /SUMMARY			[220]
	TRNE	F,R.FAST	;SEE IF /FAST SWITCH
	JRST	DTFIL3		;YES--THAT'S ALL
	PUSHJ	P,LSPC		;NO--ADD A SPACE
	PUSHJ	P,LDEC3		;TYPE AS THREE DIGITS
	PUSHJ	P,LSPC2		;TYPE TWO SPACES
	LDB	T4,[POINT 12,DIRB+150(J),35]	;GET CREATION
	HRRZ	T1,J		;GET FILE NUMBER (1-22.)	[162]
	MOVEI	T2,1		;GET A TEST BIT			[162]
	TDNE	T2,DIRB+^D43(J)	;TEST THE EXTENSION BITS	[162]
	TRO	T4,1B21		; AND COPY TO RESULT		[162]
	TDNE	T2,DIRB+^D21(J)	; ..				[162]
	TRO	T4,1B22		; ..				[162]
	TDNE	T2,DIRB-1(J)	; ..				[162]
	TRO	T4,1B23		; ..				[162]
	PUSHJ	P,LDATE		;LIST CREATION DATE
;**;[330] REPLACE @ DTFIL3	JBC	13-JAN-76
DTFIL3:	TRNE	F,R.FAST	;[330] IF /F
	JRST	DTFIL4		;[330] THEN DON'T TEST /SUM
	SKIPLE	S.SUM		;[330] IF /SUM
	JRST	DTFIL1		;[330] BACK FOR MORE FILES
DTFIL4:	MOVE	T2,NOCHRS	;[330] GET # CHARS SO FAR
	CAMG	T2,MXWDTH	;[330] END OF LINE?
	JRST	DTFIL5		;[330] NO, OUTPUT TAB
	PUSHJ	P,LCRLF		;[330] FINISH OFF LINE
	JRST	DTFIL1		;[330] LOOP BACK FOR MORE
DTFIL5:	PUSHJ	P,LTAB		;[330] OUTPUT TAB
	JRST	DTFIL1		;[330] LOOP BACK FOR MORE

;DTCNT -- ROUTINE TO COUNT NUMBER OF BLOCKS IN A FILE
;CALL:	HRRI	J,FILE NUMBER (0-22)
;	PUSHJ	P,DTCNT
;	RETURN	WITH T1=NUMBER OF BLOCKS ALLOCATED
;USES T2, T3, T4

DTCNT:	MOVEI	T1,0		;PRESET COUNT
	MOVE	T2,[POINT 5,DIRB]	;PRESET POINTER TO ALLOCATION TABLE
	MOVEI	T3,1101		;PRESET COUNT OF NUMBER ON TAPE
DTCNT1:	ILDB	T4,T2		;PICK UP FILE OF NEXT BLOCK ON TAPE
	CAIN	T4,(J)		;COMPARE WITH REQUEST
	ADDI	T1,1		;MATCHES--COUNT
	SOJG	T3,DTCNT1	;LOOP OVER ENTIRE TAPE
	POPJ	P,		;RETURN


;ERRORS

DTERR:	GETSTS	DC,P3		;GET STATUS
	SETSTS	DC,.IOASC	;SET TO ASCII (BUFFER) FOR LISTING	[226]
	TXNN	P3,IO.DTE!IO.DER  ;UNLESS PAR.ERR. OR DEV.ERR.,
	PJRST	E.TFR		; GO GIVE FATAL ERROR
	TXNN	P3,IO.DTE	;SEE IF PARITY ERROR
	JRST	E$$DDM		;NO--MUST BE DEVICE ERROR
	N$WRNX	(DPE,<Parity error, status>)
	JRST	DTERR1		;GO DO COMMON STUFF
	N$WRNX	(DDM,<Data missed, status>)
DTERR1:	HRRZ	T1,P3		;GET STATUS
	PUSHJ	P,.TOCTW##	;ISSUE IN OCTAL
	MOVEI	T1,[ASCIZ \, in directory block on \]
	PUSHJ	P,.TSTRG##	;ISSUE EXPLANATION
	MOVE	T1,I.DEV(I)	;GET DEVICE
	PUSHJ	P,.TSIXN##	;ISSUE IN SIXBIT
	PUSHJ	P,.TCOLN##	;INDICATE IT'S A DEVICE
X$$DDM:!
X$$DPE:	PJRST	.TCRLF##	;END MESSAGE

E.TFR:	N$FAIO	(TFR,Data error reading DECtape directory, status)

E.NDD:	MOVE	P3,I.DEV(I)
	N$FAIN	(NDD,source device not a directory device) ;	[314]
E.UDV:	MOVE	P3,I.DEV(I)
	N$FAIN	(UDV,source device of unknown type) ;		[314]
E.NSD:	MOVE	P3,I.DEV(I)
	N$FAIN	(NSD,No such device)
SUBTTL	PERFORM TMPCOR DIRECTORY LISTING

;HERE WHEN DEVICE IS "TMP:" AND DOES NOT EXIST

TMPDIR:	TRO	F,R.WORD!R.NDSK	;SET WORD MODE AND NOT A DISK	[202]
	MOVE	T2,[.TCRRD,,[0
			     IOWD 200,DIRB]]
	TMPCOR	T2,		;GET DIRECTORY
	  JRST	E$$NTD		;ERROR IF NOT IMPLEMENTED
	CAIG	T2,200		;SEE IF DIRECTORY OVERFLOW
	JRST	MFTOK		;OK--PROCEED
	N$WARN	(MFT,More than 200 files in TMPCOR)
MFTOK:	MOVE	J,[IOWD 200,DIRB]
	MOVEI	M,[ASCIZ /TMPCOR directory
Free: /]
	PUSHJ	P,LSTR		;OUTPUT HEADING
	MOVEI	T1,.TCRFS	;GET FREE COUNT
	TMPCOR	T1,		;FROM MONITOR
	  JRST	E$$NTD		;IF POSSIBLE
	PUSHJ	P,LDEC		;AND TELL USER
	PUSHJ	P,LCRLF		;THEN END LINE

TMPDRL:	AOBJP	J,DIREND	;SEE IF DONE
	SKIPN	T2,(J)		;SEE IF ENTRY NEXT
	JRST	TMPDRL		;NO--LOOP BACK
	TRZ	T2,-1		;CLEAR JUNK
	MOVEM	T2,FNAM		;SAVE NAME
	SETZM	FEXT		;CLEAR EXTENSION
	SETZM	UFDPPN		;CLEAR DIRECTORY
	PUSHJ	P,ISMATC	;SEE IF IT MATCHES
	  JRST	TMPDRL		;NO--LOOP FOR MORE
	SKIPLE	S.SUM		;SEE IF /SUM			[220]
	JRST	TMPDR1		;YES--SKIP OUTPUT		[220]
	MOVE	T2,FNAM		;GET NAME
	MOVEI	T3,4		;OUTPUT 4 CHARS
	PUSHJ	P,LSIXC		; (3 FOR NAME AND ONE SPACE)
TMPDR1:	HRRZ	T1,(J)		;GET FILE LENGTH
	ADDM	T1,NOBLKS	;COUNT IN TOTAL BLOCKS (REALLY WORDS)
	SKIPLE	S.SUM		;SEE IF /SUM			[220]
	JRST	TMPDRL		;YES--LOOP ON			[220]
	PUSHJ	P,LDEC2		;OUTPUT LENGTH
	PUSHJ	P,LCRLF		;END THE LINE
	JRST	TMPDRL		;AND LOOP BACK
;ERRORS

	N$FAIL	(NTD,TMPCOR not supported in this monitor)


;HERE AT END OF A NON-DISK DIRECTORY

DIREND:	PUSHJ	P,DIRE		;OUTPUT SUMMARY AND TOTAL LINE
	TRZ	F,R.WORD!R.NDSK	;CLEAR WORD MODE AND NOT DISK	[202]
	MOVE	I,.WILAS	;GET END OF SET
	MOVEM	I,I.NXRD	;SET FOR MASTER LOOP
	POPJ	P,		;RETURN
	SUBTTL	MISC. DIRECTORY SUBROUTINES

;ISMATC -- ROUTINE TO SEE IF PROPOSED FILE MATCHES REQUEST
;CALL:	SETUP LOOKBL
;	PUSHJ	P,ISMATC
;	  BAD MATCH
;	WIN WITH I POINTING TO AREA
;USES T1-4

ISMATC:	AOS	NOFIL		;COUNT FILE DISCOVERED
	PUSHJ	P,.CHKTA##	;CHECK FOR MATCH
	  POPJ	P,		;NO--GIVE UP
	AOS	NOFILF		;COUNT FILE FOUND
	JRST	.POPJ1##	;WIN
;ENDSUB -- ROUTINE TO CLEAN UP SUBTOTALS AT END

ENDSUB:	SKIPLE	NUMSUB		;SEE IF SUBTOTALS ALREADY	[307]
	PJRST	SUBTOT		;YES--DO SOME MORE		[307]
	PJRST	SUBLOP		;NO--JUST CLEAN END OF WORK	[307]


;SUBTOT -- ROUTINE TO ISSUE SUBTOTALS
;USES T1-4

SUBTOT:	SKIPN	S.SUM		;SEE IF /NOSUM
	POPJ	P,		;YES--NEVER GIVE IT
	PUSHJ	P,.SAVE1	;SAVE P1
	SKIPE	NOCHRS		;SEE IF AT START OF LINE
	PUSHJ	P,LCRLF		;NO--END THIS LINE
	MOVEI	P1,SUBT-TOT	;POINT TO SUBTOTALS
	SKIPLE	FLFSUM		;SEE IF FORCED SUMMARY		[160]
	JRST	SUBTDO		;YES--GO DO SUBTOTAL
	MOVEI	T1,1		;SET ONE
	CAML	T1,SNFILF	;IF MORE THAN ONE FILE
	CAMGE	T1,SNFILR	;OR MORE THAN ONE ERROR
SUBTDO:	PUSHJ	P,TOTALS	;GO ISSUE SUBTOTALS

;HERE FROM END OF DISK TO MOVE SUBT. TO TOT.

SUBLOP:	SKIPN	SNFILF		;SEE IF ANY FILE FOUND		[307]
	SKIPE	SNFILR		;OR ANY ERRORS			[307]
	AOS	NUMDIR		;COUNT DIRECTORY FOUND		[307]
	PUSH	P,TCHKSM	;PRESERVE TOTAL CHECKSUM
	MOVSI	T1,-<SUBT-TOT>	;SET COUNT TO COPY
SUBTL:	MOVE	T2,SUBT(T1)	;GET SUBTOTAL
	ADDM	T2,TOT(T1)	;ADD INTO TOTAL
	SETZM	SUBT(T1)	;CLEAR SUBTOTAL
	AOBJN	T1,SUBTL	;LOOP UNTIL DONE
	POP	P,TCHKSM	;RESTORE TOTAL CHECKSUM
	SETZM	SUBSTR		;CLEAR STRUCTURE FROM TOTAL	[245]
	POPJ	P,		;RETURN
;DIRE  -- OUTPUT EMPTY OR TOTAL LINE
;DIRET -- OUTPUT TOTAL LINE
;CALL:	PUSHJ	P,DIRE/DIRET
;USES T1-4

DIRE:	PUSHJ	P,ENDSUB	;FINISH LAST SUBTOTAL		[307]
	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	MOVEI	T1,[ASCIZ /Directory empty/]
	SKIPE	NOFIL
	MOVEI	T1,[ASCIZ /Directory has no such files/]
	SKIPN	NOFILF
	JRST	DIREL		;GO PRINT MESSAGE
DIRET:	PUSHJ	P,ENDSUB	;FINISH LAST SUBTOTAL		[307]
	PUSHJ	P,.TNEWL	;FORCE NEW LINE
	SKIPLE	FLFSUM		;SEE IF FORCED SUMMARY		[201]
	JRST	DIRETP		;YES--GO DO IT			[201]
	TRNE	F,R.NDSK	;NO--SEE IF NOT DISK FORMAT	[201]
	JRST	DIRELX		;RIGHT--NO SUMMARY		[201]
	MOVE	T1,NOFILR	;GET NUMBER OF LOOKUP ERRORS
	MOVE	T1,NOFILF	;SEE HOW MANY FILES FOUND
	CAILE	T1,1		;IF LE 1, NO SUMMARY NEEDED
	SKIPN	NOBLKS		;SEE IF BLOCKS ACCUMULATED
	JRST	DIRELX		;NO--JUST PRINT BLANK LINE AND RETURN
DIRETP:	SKIPN	S.SUM		;SEE IF /NOSUM
	POPJ	P,		;YES--NEVER DO IT
	SOSG	NUMSUB		;SEE IF SUBTOTALS
	PUSHJ	P,LCRLF		;NO--SEPARATE SUMMARY BY BLANK LINE
				CONT.
	SKPINL			;DEFEAT ^O
	  JFCL			; ..
	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;POINT TO TOTALS
	MOVEI	T1,[ASCIZ /  Grand total of /]
	SKIPGE	T2,NUMSUB	;GET NUMBER OF SUBTOTALS
	JRST	TOTALS		;IF NONE, DO TOTAL
	JUMPN	T2,TOTALO	;IF SEVERAL, DO GRAND TOTAL
	MOVE	T2,NUMDIR	;IF ONE, GET NUMBER OF DIRECTORIES
	CAIG	T2,1		;IF MORE THAN ONE, DO GRAND TOTAL
	JRST	DIRELX		;NO--JUST EXIT
	JRST	TOTALO		;YES--GIVE GRAND TOTAL

;TOTALS -- ROUTINE TO ISSUE EITHER SUB OR GRAND TOTALS
;CALL:	MOVEI	P1,0 FOR GRAND OR SUBT-TOT FOR SUBS
;USES T1-4

TOTALS:	MOVEI	T1,[ASCIZ /  Total of /]
TOTALO:	SKIPN	NOFILF(P1)	;SEE IF ANY FILES		[175]
	SKIPE	NOFILR(P1)	; OR ERRORS			[175]
	SKIPA			;YES--OUTPUT LINE		[175]
	POPJ	P,		;NO--SKIP TOTAL LINE		[175,324]
	PUSHJ	P,.TSTRG	;PRINT HEADING
	AOS	NUMSUB		;COUNT SUBTOTAL
	SKIPN	NOFILF(P1)	;SEE IF ANY FILES
	JRST	[SKIPN NOFILR(P1)  ;NO--SEE IF ANY ERRORS
		 JRST  DIRETF	;NO--SAY 0 FILES
		 JRST  DIRETL]	;YES--TELL ALL
	TRNE	F,R.FAST	;SEE IF /F			[223]
	SKIPLE	S.SUM		; AND NOT /SUM			[224]
	SKIPA			;NO--DO THE OUTPUT		[224]
	JRST	DIRETF		;YES--SKIP "N BLOCKS"		[223]
	MOVE	T1,NOBLKS(P1)	;GET NUMBER OF BLOCKS
	PUSHJ	P,.TDECW##	;PRINT NUMBER OF BLOCKS
Ife FT$TYM,<MOVEI T1,[ASCIZ / block/]>
Ifn FT$TYM,<MOVEI T1,[ASCIZ / page/]>
	TRNE	F,R.WORD	;SEE IF WORD MODE
	MOVEI	T1,[ASCIZ / word/]	;IF SO, CHANGE MESSAGE
	PUSHJ	P,.TSTRG##
	MOVE	T2,NOBLKS(P1)	;GET NUMBER OF BLOCKS
	MOVEI	T1,"s"		;MAKE PLURAL IF NEEDED
	CAIE	T2,1		; ..
	PUSHJ	P,.TCHAR##	;YES
				CONT.
	MOVEI	T1,[ASCIZ / in /]	;AND REST OF MESSAGE
	PUSHJ	P,.TSTRG##	; ..
DIRETF:	MOVE	T1,NOFILF(P1)	;GET NUMBER OF FILES
	PUSHJ	P,.TDECW##	;  FOUND AND PRINTED
	MOVEI	T1,[ASCIZ / file/]
	PUSHJ	P,.TSTRG##	;OUTPUT LINE
	MOVE	T2,NOFILF(P1)	;GET NUMBER FOUND
	MOVEI	T1,"s"		;GET PLURAL
	CAIE	T2,1		;SEE IF NOT ONE
	PUSHJ	P,.TCHAR##	;YES--TYPE PLURAL
	SKIPG	S.CHK		;SEE IF /CHECKSUM
	JRST	DIRETC		;NO--PROCEED
	MOVE	T1,TCHKSM(P1)	;GET AGGRAGATE CHECKSUM
	MOVEM	T1,CHKSUM	;SET FOR PRINTOUT
	SETZM	TCHKSM(P1)	;CLEAR FOR NEXT TIME
	MOVEI	M,[ASCIZ / Checksum = /]
	PUSHJ	P,LSTR
	PUSHJ	P,LCHECK	;LIST CHECKSUM
DIRETC:	SKIPN	NOFILR(P1)	;SEE IF ANY ERRORS
	JRST	DIRELE		;NO--THAT'S ALL
	MOVEI	T1,[ASCIZ / and /]
	PUSHJ	P,.TSTRG##	;YES--ISSUE CONNECTIVE
DIRETL:	MOVE	T1,NOFILR(P1)	;GET NUMBER OF ERRORS
	PUSHJ	P,.TDECW##	;TYPE THE COUNTER
	MOVEI	T1,[ASCIZ / LOOKUP error/]
	PUSHJ	P,.TSTRG##	;TYPE LABEL
	MOVE	T2,NOFILR(P1)	;GET COUNT
	MOVEI	T1,"s"		;GET PLURAL
	CAIE	T2,1		;SEE IF NOT ONE
	PUSHJ	P,.TCHAR##	;TYPE PLURAL
	JRST	DIRELE		;AND GO FINISH
DIREL:	PUSHJ	P,.TSTRG##
DIRELE:	MOVE	T1,NUMDIR	;SEE HOW MANY DIRECTORIES
	CAILE	T1,1		;SEE IF MORE THAN ONE
	JUMPE	P1,DIRELF	;YES--JUMP IF GRAND TOTAL
	SKIPN	SUBSTR		;SEE IF DEVICE KNOWN
	JRST	DIRELF		;NO--SKIP THIS LINE
	MOVEI	T1,[ASCIZ / on /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,SUBSTR	;GET STRUCTURE
	PUSHJ	P,.TSIXN##	;LIST IT
	MOVEI	T1,[ASCIZ /: /]
	PUSHJ	P,.TSTRG##	;LIST SEPARATION
	MOVEI	T1,SUBDIR	;POINT TO DIRECTORY
	PUSHJ	P,.TDIRB##	;PRINT IT
DIRELF:	PUSHJ	P,.TCRLF##
DIRELX:	SKIPG	S.SUM		;UNLESS /SUMMARY, 		[327]
	PUSHJ	P,LCRLF		; GIVE A BLANK LINE		[175]
	POPJ	P,		;RETURN
DEFINE	SWTCHS,<
SP ACCESS,S.ACCS,.SWDEC##,ACC,FS.NFS
SS ALLOCATED,S.ALC,1,FS.NFS
SN AUTHOR,S.AUT,FS.NFS
SS BLOCKS,S.WORD,0,FS.NFS
SN CHECKSUM,S.CHK,FS.NFS
SN COMPARE,S.CMP,FS.NFS
SN DETAIL,S.DTL,FS.NFS
SN EOTS,S.EOT,FS.NFS
SS *FAST,<POINTR (FLAGS,R.FAST!R.SLOW)>,R.FAST/R.FAST,FS.NFS
SN FDTA,S.FDTA,FS.NFS
SP FILES,S.FILE,.SWDEC##,FIL,FS.NFS
SN INDIRECT,S.IND,FS.NFS
SS *LIST,S.DODV,1,FS.NFS
SN MARKS,<POINTR (FLAGS,R.MARK)>,FS.NFS
SS *NORMAL,<POINTR (FLAGS,R.FAST!R.SLOW)>,0,FS.NFS
SN PRDEVICE,S.PRDE,FS.NFS
SN PRDIRECTORY,S.PRDI,FS.NFS
SN REWINDS,S.REWS,FS.NFS
SS *SLOW,<POINTR (FLAGS,R.FAST!R.SLOW)>,R.SLOW/R.FAST,FS.NFS
SN SORT,S.SORT,FS.NFS
SN SUMMARY,S.SUM,FS.NFS
SN TITLES,S.TITL,FS.NFS
SN UNITS,S.UNIT,FS.NFS
SP *WIDTH,S.WDTH,.SWDEC##,WID,FS.NFS
SS WORDS,S.WORD,1,FS.NFS
SS WRITTEN,S.ALC,0,FS.NFS
>
	DOSCAN	(DRSWT)
	SUBTTL	SUBROUTINES FOR LISTING OUTPUT


;ERROR -- ROUTINE TO ISSUE ERROR MESSAGE WITH JUST TEXT
;ERRORC -- ROUTINE TO ISSUE ERROR MESSAGE WITH MORE STUFF
;WARN -- ROUTINE TO ISSUE WARNING MESSAGE

ERROR:	HRLI	T2,(1B0)	;SET FLAG TO NOT RETURN
ERRORC:	TLOA	T2,"?"		;SET FATAL ERROR CODE
WARN:	HRLI	T2,"%"		;SET WARNING CODE
	HRLI	T1,'DRT'	;SET DIRECT'S PREFIX
	PUSHJ	P,.ERMSG##	;ISSUE MESSAGE
	JUMPGE	T1,.POPJ##	;RETURN UNLESS ERROR ENTRY

;LFERX -- ROUTINE TO CLEAN UP AFTER FATAL ERROR
;THE ROUTINES IN SCAN CANNOT BE USED AFTER ANOTHER PUSHJ

LFERX:	PUSHJ	P,.TCRLF##	;ISSUE FINAL <CRLF>
	RELEAS	LC,		;BIND OFF LISTING
	RESET			;CLEAR I/O AND CORE ASSIGNMENTS
	JRST	MAINLP		;AND TRY AGAIN
;TITLER -- PLACE PAGE TITLE IF USER REQUESTED ONE
;CALLED AT START OF FIRST PAGE AND END OF EACH PAGE BUT LAST
;CALL:	PUSHJ	P,TITLER

TITLER:	PUSHJ	P,SAVTYP	;CLEAR R.TYPE AND SAVE OLD VALUE
	PUSH	P,M		;PRESERVE POINTER
	PUSH	P,C		;PRESERVE CHARACTER
	SKIPG	S.TITL		;SEE IF TITLES ON
	JRST	TITLEY		;NO--RETURN
	MOVEI	M,LN$LPP+2	;RESET LINES THIS PAGE COUNT
	MOVEM	M,LNPP		; ..
	TRON	F,R.LSOM	;SEE IF FIRST CALL
	JRST	TITLEH		;YES--SKIP BIND-OFF OF PREVIOUS PAGE
	MOVEI	C,.CHFFD	;EJECT TO NEW PAGE
	PUSHJ	P,LCHR		; ..

;HERE WHEN IT IS DESIRED TO OUTPUT A PAGE HEADER

TITLEH:	PUSH	P,T1		;SAVE T1-P1
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	PUSH	P,P1
	MOVEI	M,[ASCIZ /	Directory listing	/]
	PUSHJ	P,LSTR		;SEND START OF LINE 1
	DATE	T4,		;GET CURRENT DATE
	PUSHJ	P,LDATE		;PRINT IT
	PUSHJ	P,LTAB		;SPACE OVER
	MSTIME	T4,		;GET CURRENT TIME
	IDIVI	T4,^D60000	;CONVERT TO MINUTES
	PUSH	P,P1		;SAVE REMAINDER
	PUSHJ	P,LTIME		;PRINT TIME (HH:MM)
	POP	P,T1		;RESTORE REMAINDER
	IDIVI	T1,^D1000	;CONVERT TO SECONDS
	PUSHJ	P,LTIMES	;PRINT SECONDS (:SS)
	MOVEI	M,[ASCIZ /	Page /]
	PUSHJ	P,LSTR		;SPACE OVER TO PAGE NUMBER
	AOS	T1,PAGCNT	;GET NEXT PAGE NUMBER
	PUSHJ	P,LDEC2		;LIST IT
	TRNE	F,R.NDSK	;SEE IF NOT A DISK		[202]
	JRST	TITLEX		;RIGHT--SKIP SUBTITLE		[202]
	PUSHJ	P,LCRLF		;END OF LINE
				CONT.
;HERE WHEN FIRST LINE HAS BEEN PRINTED, DO THE REST

	MOVEI	M,[ASCIZ /Name Extension/]
	PUSHJ	P,LSTR
	TRNE	F,R.FAST
	JRST	TITLEX
	MOVEI	M,[ASCIZ / Len     Prot   /]
	PUSHJ	P,LSTR
	MOVEI	M,[ASCIZ /Checksum/]
	SKIPLE	S.CHK
	PUSHJ	P,LSTR
	MOVEI	M,[ASCIZ /  Creation/]
	TRNE	F,R.SLOW
	MOVEI	M,[ASCIZ /   Access      ---Creation---   Mode/]
	PUSHJ	P,LSTR
Ife FT$TYM,<MOVEI M,[ASCIZ /	   Version/]> ;[335]
Ifn FT$TYM,<MOVEI M,[ASCIZ /	Version/]> ;[335]
	PUSHJ	P,LSTR		;[335] <TAB><SP><SP><SP>VERSION
	MOVEI	M,[ASCIZ/	Author/] ;[335]
	SKIPLE	S.AUT		;[335] NEED AN AUTHOR FIELD?
	PUSHJ	P,LSTR		;[335] <TAB>AUTHOR
	SKIPLE	S.WDTH		;[335] DOING FUNNY WIDTH STUFF?
	JRST	TITLEX		;[335] YES - DON'T ALLOW FOR DEV:[DIR]
	MOVEI	M,[ASCIZ/	Device/] ;[335] NO
	SKIPLE	S.PRDE		;[335] SEE IF DEVICE FIELD PRESENT
	PUSHJ	P,LSTR		;[335] <TAB>DEVICE
	MOVEI	M,[ASCIZ/	Directory/] ;[335]
	SKIPLE	S.PRDI		;[335] DIRECTORY FIELD?
	PUSHJ	P,LSTR		;[335] <TAB> [DIRECTORY]
				;[335] SPOOLNAME HERE IF FIGURE OUT
				;[335] WHAT TO DO WITH IT . . .


TITLEX:	POP	P,P1		;RESTORE THE ACS
	POP	P,T4
	POP	P,T3
	POP	P,T2
	POP	P,T1
	PUSHJ	P,LCRLF		;ISSUE END OF LINE
	PUSHJ	P,LCRLF		;AND A BLANK LINE

TITLEY:	SKIPGE	LNPP		;SEE IF FIRST TIME		[202]
	JRST	[HRLOI C,377777	;YES--SET COUNTER HIGH		[202]
		 MOVEM C,LNPP	;YES--CLEAR FLAG		[202]
		 SKIPG S.SUM	;UNLESS /SUMMARY,		[327]
		 PUSHJ P,LCRLF	;YES--SKIP ONE LINE		[202]
		 JRST  .+1]	; AND CONTINUE			[202]
	POP	P,C		;RESTORE CHARACTER
	POP	P,M		;RESTORE POINTER
	POPJ	P,		;RETURN
;LDIRB -- LIST DIRECTORY IN SFD FORMAT
;CALL:	MOVE	T4,CONTENTS OF UFDPPN
;	PUSHJ	P,LDIRB
;USES T1, T2, T3, T4, C

IFN FT$SFD,<
LDIRB:	JUMPE	T4,.POPJ##	;GIVE UP IF BLANK
	JUMPL	T4,[MOVE  T2,T4  ;IF SIXBIT, TYPE IT
		    PJRST LSIXN]
	TLNE	T4,-1		;SEE IF SFD POINTER
	JRST	[PUSH P,[[0]-3]	;NO--JUST DO UFD
		 JRST LDIRBU]

	PUSH	P,T4		;SAVE ARGUMENT
	MOVE	T4,2(T4)	;GET UFD IN PATH LIST
LDIRBU:	JUMPL	T4,[MOVE  T2,T4  ;IF SIXBIT, TYPE IT
		    MOVEI T3,6	 ;SET FOR 6 CHARS
		    SKIPLE S.SORT
		    PUSHJ P,LSIXC ; IF /SORT, DO 6 CHARS
		    SKIPG S.SORT
		    PUSHJ P,LSIXN
		    JRST  LDIRBR]
	SKIPG	S.SORT		;IF NOT /SORT
	JRST	LDIRBN		; PROCEED BELOW
	HLRZ	T1,T4		;IF /SORT,
	PUSHJ	P,LOCT6Z	; DO FIXED FORMAT
	MOVEI	C,","		;SEPARATE HALVES
	PUSHJ	P,LCHR		; WITH A COMMA
	HRRZ	T1,T4		;THEN DO
	PUSHJ	P,LOCT6Z	; RIGHT HALF
	JRST	LDIRBR		;CONTINUE BELOW
LDIRBN:	PUSHJ	P,LXWD		;TYPE UFD
LDIRBR:	POP	P,T4		;RESTORE ARGUMENT
	HRLI	T4,-LN$DRB+1	;SET MAX LIST LENGTH
LDIRB1:	SKIPN	T2,3(T4)	;GET NEXT SFD IN PATH
	POPJ	P,		;IF NONE, RETURN
	MOVEI	C,","		;YES--TYPE COMMA
	PUSHJ	P,LCHR		; ..
	MOVEI	T3,6		;SET FIXED LENGTH
	SKIPLE	S.SORT		;IF /SORT
	PUSHJ	P,LSIXC		; DO FIXED
	SKIPG	S.SORT		;ELSE,
	PUSHJ	P,LSIXN		;  AND SFD
	AOBJN	T4,LDIRB1	;LOOP UNTIL DONE
	POPJ	P,		;RETURN
>
;LVER -- LIST WORD IN VERSION NUMBER FORMAT
;CALL:	MOVE	T4,WORD
;	PUSHJ	P,LVER
;USES T1, T2, T3, T4, C

LVER:	LDB	T1,[POINT 9,T4,11]  ;GET MAJOR VERSION
	SKIPE	T1		;IF NON-ZERO,
	PUSHJ	P,LOCT		;  PRINT IN OCTAL
	LDB	T1,[POINT 6,T4,17]  ;GET MINOR VERSION
	JUMPE	T1,LVER2	;IF NON-ZERO,
	SOS	T1		;OFFSET				[310]
	IDIVI	T1,^D26		;  PRINT IN ALPHA
	JUMPE	T1,LVER1	;  ONE OR TWO
	MOVEI	C,"A"-1(T1)	;  CHARACTERS
	PUSHJ	P,LCHR		;  ..
LVER1:	MOVEI	C,"A"(T2)	;  ..				[310]
	PUSHJ	P,LCHR		;  ..
LVER2:	HRRZ	T1,T4		;GET EDIT NUMBER
	JUMPE	T1,LVER3	;IF NON-ZERO,
	MOVEI	C,"("		;  PRINT (
	PUSHJ	P,LCHR		;  ..
	PUSHJ	P,LOCT		;  IN OCTAL
	MOVEI	C,")"		;  AND )
	PUSHJ	P,LCHR		;  ..
LVER3:	LDB	T1,[POINT 3,T4,2]
	JUMPE	T1,.POPJ##	;IF CUST. NUMBER NON-ZERO,
	MOVEI	C,"-"		;  PRINT -
	PUSHJ	P,LCHR		;  ..
	PJRST	LOCT		;  AND NUMBER
;LAUT -- LIST THE AUTHOR FIELD
;CALL:	PUSHJ	P,LAUT
;USES T1-4,C

LAUT:	SKIPN	T2,FAUT		;SEE IF ANYTHING THERE
	PJRST	LTAB		;NO--JUST ISSUE TAB
	PJUMPL	T2,LSIXT	;IF SIXBIT, ISSUE AS SUCH
	HLRZ	T1,T2		;ELSE GET PROJECT
	SKIPG	S.SORT		;SEE IF /SORT
	PUSHJ	P,LOCT6B	;NO
	SKIPLE	S.SORT		;ELSE
	PUSHJ	P,LOCT6Z	;YES
	MOVEI	C,","		;SEPARATOR
	PUSHJ	P,LCHR		;TO FILE
	HRRZ	T1,FAUT		;GET PROGRAMMER
	SKIPG	S.SORT		;SEE IF /SORT
	PJRST	LOCT		;NO
	PJRST	LOCT6Z		;YES


;LCHECK< -- ROUTINE TO LIST THE ACCUMULATED CHECKSUM
;CALL:	PUSHJ	P,LCHECK
;USES T1, T2, T3, C

Ife FT$TYM,<	; Use DEC's typeout for checksums
LCHECK:	HLRZ	T1,CHKSUM	;YES--COMBINE HALVES
	HRRZ	T2,CHKSUM	;GET RH
	ADD	T2,T1		;ADD
	HLRZ	T1,T2		;GET CARRY
	ADDI	T1,(T2)		;COMBINE
	PJRST	LOCT6Z		;LIST AS 6 DIGIT OCTAL AND RETURN
> ; End Ife FT$TYM

Ifn FT$TYM,<	; Use Tymshare's Easy-speak checksums
LCHECK:	Move	T1,CHKSUM	; Get Checksum to print
	Tlz	T1,400000	; Clear Sign bit if set
	Pushj	P,LTRIGR	; Type first 3 digits (C,V,C)
LTRIGR:	Pushj	P,LCONS		;  -- Consonant ---
	Idivi	T1,5		; One of A-E-I-O-U
	Move	C,LVOWT(T2)	;   from the table
	Pushj	P,LCHR		;  -- Vowel --
LCONS:	Movei	T3,25		;  -- Consonant --
	Idiv	T1,T3		; Letters A-U
	Movei	C,"A"(T2)	;   from thin air
	Movsi	T3,-5		; Check if a vowel
LCONS1:	Camn	C,LVOWT(T3)	; ..
	  Jrst	LCONS2		; Yes -- Convert
	Aobjn	T3,LCONS1	; No --- Keep checking
	Jrst	LCHR		;   Not there? Print it.
LCONS2:	Movei	C,"V"(T3)	; Convert to consonant V-Z
	Jrst	LCHR		; Print it.

LVOWT:	Exp	"A","E","I","O","U"

> ; End Ifn FT$TYM

;LXWD -- LIST WORD IN XWD FORMAT (N,N)
;CALL:	MOVE	T4,WORD
;	PUSHJ	P,LXWD
;USES T1, T2, T3, C

IFE FT$SFD,<LDIRB:>
LXWD:	HLRZ	T1,T4		;GET LEFT HALF
	JUMPE	T1,LXWD1	;SKIP FIRST PART IF 0
	PUSHJ	P,LOCT		;OUTPUT LH IN OCTAL
	MOVEI	C,","		;SEND SEPARATOR
	PUSHJ	P,LCHR
LXWD1:	HRRZ	T1,T4		;DO RIGHT HALF
	PJRST	LOCT		;IN OCTAL AND RETURN



;LOCT6Z -- LIST 6 OCTAL DIGITS WITH LEADING ZEROS
;LOCTZ -- LIST N OCTAL DIGITS WITH LEADING ZEROS
;CALL:	(MOVE	T2,MASK OF LARGEST NUMBER  IF LOCTZ)
;	MOVE	T1,NUMBER
;	PUSHJ	P,LOCT6Z/LOCTZ
;USES T1, T2, T3, C

LOCT6Z:	MOVEI	T2,-1		;PRESET FOR 6 DIGITS

LOCTZ:	LSH	T2,-3		;COUNT DOWN MASK
	SKIPE	T2		;SEE IF ALL DONE
	CAMLE	T1,T2		;SEE IF DONE YET
	PJRST	LOCT		;REST ARE NON-ZERO
	PUSHJ	P,LZER		;NO--TYPE A ZERO
	JRST	LOCTZ		;AND GO AROUND AGAIN


;LOCT6B -- SAME ONLY LEADING BLANKS
;LOCTB -- SAME ONLY BLANKS

LOCT6B:	MOVEI	T2,-1		;SET FOR 6 DIGITS

LOCTB:	LSH	T2,-3		;COUNT DOWN MASK
	SKIPE	T2		;SEE IF ALL DONE
	CAMLE	T1,T2		;SEE IF DONE YET
	PJRST	LOCT		;REST ARE NON-ZERO
	PUSHJ	P,LSPC		;NO--TYPE A SPACE
	JRST	LOCTB		;AND GO AROUND AGAIN
Ifn FT$TYM,<	; Tymshare protection scheme

;TYMPRV - T1 contains the protection code
;
TYMPRV:	Idivi	T1,10		; Third digit
	Push	P,T2		; Save
	Idivi	T1,10		; Second digit
	Push	P,T2		; Save
	Movei	M,PRVTYM(T1)	; Get Text
	Pushj	P,LSTR		; Print it
	Pop	P,T1		; Restore next
	Movei	M,PRVTYM(T1)	; Get Text
	Pushj	P,LSTR		; Print it
	Pop	P,T1		; Restore next
	Movei	M,PRVTYM(T1)	; Get Text
	Jrst	LSTR		; Print it and return

PRVTYM:	Asciz	\ALL \
	Asciz	\CP  \
	Asciz	\UPD \
	Asciz	\AP  \
	Asciz	\RD  \
	Asciz	\RUN \
	Asciz	\LK  \
	Asciz	\NO  \

> ; End Ifn FT$TYM

;LDATE -- OUTPUT DATE IN FORM DD-MMM-YY
;CALL:	MOVE	T4,DATE IN SYSTEM FORMAT
;	PUSHJ	P,LDATE
;USES T1, T2, T3, T4, M, C

LDATE:	PUSHJ	P,.SAVE1	;SAVE P1
	SKIPE	S.SORT		;SEE IF /SORT
	JRST	LDATEN		;YES--USE SORTABLE FORMAT
	JUMPE	T4,LDATEZ	;JUMP IF NO DATE
	IDIVI	T4,^D31		;GET DAY
	MOVEI	T1,1(P1)
	PUSHJ	P,LDEC2
	IDIVI	T4,^D12		;GET MONTH

	MOVE	T1,[ASCII /-Jan--Feb--Mar--Apr--May--Jun--Jul--Aug--Sep--Oct--Nov--Dec-/](P1)
	MOVEI	T2,0
	MOVEI	M,T1
	PUSHJ	P,LSTR
	MOVEI	T1,^D64(T4)	;GET YEAR
	IDIVI	T1,^D100	;GET YEAR IN CENTURY		[176]
	MOVE	T1,T2		;GET REMAINDER			[176]
	PJRST	LDEC2Z		;OUTPUT YEAR AND RETURN

LDATEZ:	MOVEI	M,[ASCIZ /(undated)/]
	PJRST	LSTR

;HERE WHEN /SORT TO USE ANSI FORMAT:  YYYYMMDD

LDATEN:	PUSHJ	P,LSPC		;SPACE ONE TO USE SAME WIDTH
	IDIVI	T4,^D31		;GET DAYS
	MOVE	T2,P1		;SAVE FOR LATER
	IDIVI	T4,^D12		;GET MONTHS VS. YEARS
	MOVEI	T1,^D1964(T4)	;START WITH YEARS A.D.
	IMULI	T1,^D100	;MAKE ROOM FOR MONTHS
	ADDI	T1,1(P1)	;INCLUDE MONTHS (1=JAN)
	IMULI	T1,^D100	;MAKE ROOM FOR DAYS
	ADDI	T1,1(T2)	;INCLUDE DAYS
	PJRST	LDEC		;OUTPUT THIS MESS
;LOCT3Z -- LIST OCTAL 3 DIGITS (LEADING ZEROS)
;LOCT2Z -- DITTO 2 DIGITS
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LOCT3Z/2Z
;USES T1, T2, T3, C

LOCT3Z:	CAIGE	T1,100		;TEST FOR FIRST ZERO
	PUSHJ	P,LZER		;YES--DO IT
LOCT2Z:	CAIGE	T1,10		;SEE IF NEXT
	PUSHJ	P,LZER		;YES--DO IT
	PJRST	LOCT		;THEN FINISH NUMBER


;LDECP -- LIST DECIMAL (POSSIBLY NEGATIVE) FOLLOWED BY .
;CALL:	MOVE	T1,NUMBER
;	PUSHJ	P,LDECP
;USES T1, T2, T3, C

LDECP:	JUMPGE	T1,LDECPP	;JUMP IF NOT NEGATIVE
	MOVEI	C,"-"		;TYPE MINUS
	PUSHJ	P,LCHR		; SIGN
	MOVMS	T1		;AND MAKE POSITIVE
LDECPP:	PUSHJ	P,LDEC		;LIST DECIMAL NUMBER
	MOVEI	C,"."		;LIST .
	PJRST	LCHR		;TO INDICATE DECIMAL NUMBER


;LOCT2 -- LIST OCTAL AT LEAST TWO DIGITS
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LOCT2
;USES T1, T2, T3, C

LOCT2:	CAIGE	T1,10		;SEE IF LARGE ENOUGH
	PUSHJ	P,LSPC		;NO--SEND A SPACE
	PJRST	LOCT		;SEND IN OCTAL
;LTIME -- OUTPUT TIME IN FORM HH:MM
;LTIMEB-- OUTPUT TIME OR BLANKS IF 00:00
;LTIMES-- OUTPUT JUST ":DD" FOR SECONDS CALL
;LSECS -- OUTPUT TIME IN FORM HH:MM:SS
;LMSECS-- DITTO WITH INPUT IN MILLISEC.
;CALL:	(MOVE	T4,TIME IN MINUTES    FOR LTIME/LTIMEB)
;	(MOVE	T1,SECONDS            FOR LTIMES)
;	(MOVE	T4,TIME IN SECONDS    FOR LSECS)
;	(MOVE	T1,TIME IN MSEC       FOR LMSECS)
;	PUSHJ	P,LTIME
;USES T1, T2, T3, T4, C

LSECS:	SKIPA	T1,T4		;MOVE ARGUMENT
LMSECS:	IDIVI	T1,^D1000	;CONVERT TO SECONDS
	IDIVI	T1,^D60		;GET HH:MM PART
	PUSH	P,T2		;SAVE SECONDS
	MOVE	T4,T1		;POSITION HH:MM
	PUSHJ	P,LTIME		;ISSUE HH:MM
	POP	P,T1		;RESTORE SECONDS
	PJRST	LTIMES		;ISSUE :SS AND RETURN

LTIMEB:	JUMPE	T4,LSPC5	;IF 0, PRINT BLANKS

LTIME:	PUSHJ	P,.SAVE1	;SAVE P1
	IDIVI	T4,^D60		;GET HOURS
	MOVE	T1,T4
	PUSHJ	P,LDEC2		;LIST HOURS
	MOVE	T1,P1		;LIST MINUTES

LTIMES:	PUSHJ	P,LCOLON
				;FALL INTO LDEC2Z

;LDEC2Z -- LIST DECIMAL AT LEAST 2 DIGITS WITH LEADING ZERO
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LDEC2Z
;USES T1, T2, T3, C

LDEC2Z:	CAIGE	T1,^D10		;TEST TO SEE IF NEEDED
	PUSHJ	P,LZER		;YES--SEND ZERO
	PJRST	LDEC		;GO FINISH WORK
;LDEC4 -- LIST DECIMAL AT LEAST FOUR DIGITS
;LDEC3 -- LIST DECIMAL AT LEAST THREE DIGITS
;LDEC2 -- LIST DECIMAL AT LEAST TWO DIGITS
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LDEC2
;USES T1, T2, T3, C

LDEC4:	CAIGE	T1,^D1000	;SEE IF NEEDED
	PUSHJ	P,LSPC
LDEC3:	CAIGE	T1,^D100
	PUSHJ	P,LSPC
LDEC2:	CAIGE	T1,^D10
	PUSHJ	P,LSPC		;YES
	PJRST	LDEC		;GO LIST IN DECIMAL

;LDEC -- LIST DECIMAL NUMBER
;LOCT -- LIST OCTAL NUMBER
;LRDX -- LIST VIA PRESET RADIX
;CALL:	MOVEI	T1,NUMBER
;      (MOVEI	T3,RADIX    LRDX ONLY)
;	PUSHJ	P,LDEC/LOCT/LRDX
;USES T1, T2, T3, C

LOCT:	JUMPGE	T1,LOCTC	;IF POS, EASY TO DO
	MOVE	T2,T1		;NO--USE OTHER WAY
	MOVEI	T3,^D12		;SET DIGIT COUNT
LOCTL:	MOVEI	T1,0		;CLEAR RESULT
	LSHC	T1,3		;GET NEXT DIGIT
	MOVEI	C,"0"(T1)	;CONVERT TO ASCII
	PUSHJ	P,LCHR		;OUTPUT IT
	SOJG	T3,LOCTL	;AND LOOP UNTIL DONE
	POPJ	P,		;RETURN

LDEC:	SKIPA	T3,[^D10]	;INITIALIZE FOR DECIMAL RADIX
LOCTC:	MOVEI	T3,10		;INITIALIZE FOR OCTAL RADIX

LRDX:	IDIV	T1,T3		;DIVIDE BY RADIX
	HRLM	T2,(P)		;SAVE REMAINDER
	SKIPE	T1		;SEE IF ANYTHING LEFT
	PUSHJ	P,LRDX		;YES--LOOP BACK WITH PD LIST
	HLRZ	C,(P)		;GET BACK A DIGIT
	ADDI	C,"0"		;CONVERT TO ASCII
	PJRST	LCHR		;GO LIST IT
;LCRLF - LIST END OF LINE
;CALL:	PUSHJ	P,LCRLF
;USES M, C

LCRLF:	MOVEI	M,[ASCIZ /
/]
				;FALL INTO LSTR

;LSTR - LIST ASCII STRING
;CALL:	MOVEI	M,STRING (END WITH 0 BYTE)
;	PUSHJ	P,LSTR
;USES M, C

LSTR:	TLOA	M,(POINT 7,)	;CONVERT TO BYTE POINTER
LSTR1:	PUSHJ	P,LCHR		;OUTPUT CHARACTER
	ILDB	C,M		;GET NEXT CHARACTER
	JUMPN	C,LSTR1		;LOOP UNLESS NULL
	POPJ	P,		;RETURN


;LSIXT -- LIST SIXBIT WORD FOLLOWED BY TAB
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,LSIXT
;USES T1, T2, C

LSIXT:	PUSHJ	P,LSIX		;OUTPUT WORD
	PJRST	LTAB		;GO OUTPUT TAB AND RETURN


;LSIXCL -- LIST SIXBIT WORD FOLLOWED BY COLON
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,LSIXCL
;USES T1, T2, C

LSIXCL:	PUSHJ	P,LSIX		;ISSUE IN SIXBIT
LCOLON:	MOVEI	C,":"		;GET COLON
	PJRST	LCHR		;ISSUE AND RETURN
;LSIX  -- LIST SIXBIT WORD (AT LEAST ONE SPACE)
;LSIXN -- SAME EXCEPT 0 GIVES NO SPACES
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,LSIX/LSIXN
;USES T1, T2, C

LSIX:	MOVEI	T1,0		;CLEAR NEXT CHARACTER
	LSHC	T1,6		;FETCH NEXT CHAR
	PUSHJ	P,LCHRS		;LIST IT IN SIXBIT

LSIXN:	JUMPN	T2,LSIX		;LOOP UNTIL ONLY BLANKS LEFT
	POPJ	P,		;RETURN


;LSIXC -- LIST SIXBIT WORD FIXED NUMBER OF CHARACTERS
;CALL:	MOVE	T2,WORD
;	MOVEI	T3,NUM CHARS TO PRINT
;	PUSHJ	P,LSIXC
;USES T1, T2, T3, C

LSIXC:	MOVEI	T1,0		;CLEAR NEXT CHAR
	LSHC	T1,6		;GET NEXT CHAR
	PUSHJ	P,LCHRS		;LIST IT IN SIXBIT
	SOJG	T3,LSIXC	;LOOP UNTIL DONE
	POPJ	P,		;RETURN


;LSPC2 -- LIST TWO SPACES
;LSPC4 -- LIST FOUR SPACES
;LSPC5 -- LIST FIVE SPACES
;CALL:	PUSHJ	P,LSPC2
;USES C

LSPC5:	PUSHJ	P,LSPC		;SPACE ONE
LSPC4:	PUSHJ	P,LSPC2		;SPACE TWO MORE
LSPC2:	PUSHJ	P,LSPC		;DO ONE
	PJRST	LSPC		;DO ANOTHER AND RETURN



;LZER -- LIST A ZERO
;CALL:	PUSHJ	P,LZER
;USES C

LZER:	MOVEI	C,"0"		;GET CHARACTER
	PJRST	LCHR1		;GO LIST IT
;LTAB -- LIST TAB
;LSPC -- LIST SPACE
;LCHR -- LIST CHARACTER
;LCHRS -- LIST CHARACTER IN SIXBIT
;CALL:	(MOVEI	C,CHARACTER    IF LCHR)
;	(MOVEI	T1,CHARACTER   IF LCHRS)
;	PUSHJ	P,LTAB/LSPC/LCHR
;USES C EXCEPT LCHR USES NO AC'S

LCHRS:	MOVEI	C," "-' '(T1)	;CONVERT TO ASCII AND MOVE TO C
LCHR:	CAIE	C,.CHTAB	;SEE IF A TAB
	JRST	LCHR1		;NO--GO SEND IT

LTAB:	TRZN	F,R.STAB	;[335] KILL TAB IF SO REQUESTED
	TRON	F,R.LTAB	;SET/TEST TAB
	POPJ	P,		;RETURN IF NOT TWO IN A ROW

LTAB1:	SKIPA	C,[.CHTAB]	;GET THE TAB
LSPC:	MOVEI	C," "		;GET THE SPACE

LCHR1:	SKIPGE	LNPP		;SEE IF AT END OF PAGE
	PUSHJ	P,TITLER	;YES--GO ISSUE PAGE HEADER
	CAIN	C,.CHCRT	;SEE IF CARRIAGE RETURN
	TRZ	F,R.LTAB	;YES--CLEAR TAB MEMORY
	CAIN	C,.CHLFD	;SEE IF END OF LINE
	JRST	[SOS  LNPP	;YES--DECREMENT LINES PER PAGE
		 TRZE F,R.SPLN	;STOP SUPPRESSING LINE		[317]
		 JRST LCHR4	;FINISH LAST SUPPRESSION	[317]
		 JRST .+1]	;AND PROCEED			[317]
	SKIPLE	S.CMP		;IF /COMPARE,			[317]
	JRST	[SKIPE NOCHRS	; AND AT START OF LINE		[317]
		 JRST  .+1	;NO--PROCEED			[317]
		 CAIE  C,"%"	;YES--IF WARNING		[317]
		 CAIN  C,"?"	; OR ERROR			[317]
		 TRO   F,R.SPLN	; SUPPRESS			[317]
		 CAIE  C,.CHCRT ;IF BLANK LINE, OR		[317]
		 CAIN  C," "	;IF BLANK,			[317]
		 TRO   F,R.SPLN	; SUPPRESS			[317]
		 JRST  .+1]	;AND PROCEED			[317]
	TRNE	F,R.SPLN	;IF SUPPRESSING,		[317]
	JRST	LCHR4		; HANDLE EXIT			[317]
				CONT.
	TRZE	F,R.LTAB	;CLEAR TAB MEMORY
	JRST	LCHR5		;IF SET, GO ISSUE ONE
	AOS	NOCHRS		;ADVANCE CHARACTER POSITION COUNTER
	CAIE	C,.CHTAB	;SEE IF TAB
	JRST	LCHR3		;NO--PROCEED BELOW
	PUSH	P,T1		;YES--SAVE AN AC
	MOVE	T1,NOCHRS	;GET CHARACTER COUNTER
	ADDI	T1,7		;ROUND UP
	TRZ	T1,7		;ROUND OFF
	SUB	T1,NOCHRS	;FIND EXCESS
	ADDM	T1,NOCHRS	;UPDATE CHARACTER COUNTER
	SKIPE	T1		;IF NO FILLING
	SKIPN	S.SORT		; OR NOT /SORT
	JRST	LCHR2		; DON'T FILL IN SPACES
	MOVEI	C," "		;GET A SPACE
	PUSHJ	P,LCHR3		;OUTPUT IT
	SOJG	T1,.-1		;LOOP FOR ENOUGH SPACE
	MOVEI	C,.CHTAB	;RESTORE THE TAB
LCHR2:	POP	P,T1		;RESTORE AC
				CONT.
LCHR3:	CAIL	C,.CHLFD	;SEE IF VERTICAL MOTION
	CAILE	C,.CHFFD	; ..
	JRST	.+2		;NO
	SETZM	NOCHRS		;YES--CLEAR POSITION
	SOSG	B.LC+.BFCTR	;SEE IF ROOM IN THE BUFFER
	PUSHJ	P,LCHRW		;NO--GO WRITE THIS BUFFER
	IDPB	C,B.LC+.BFPTR	;YES--SEND CHARACTER
	SKIPN	NOCHRS		;SEE IF END OF LINE		[217]
	PUSHJ	P,LCHRWL	;YES--OUTPUT BUFFER IF APPROPRIATE
LCHR4:	TRNN	F,R.TYPE	;SEE IF NEED TO DUPLICATE	[317]
	POPJ	P,		;NO--RETURN
	PUSH	P,T1		;PRESERVE TEMP
	MOVE	T1,C		;GET CHARACTER
	PUSHJ	P,.TTCHR	;YES--TYPE IT (IF NOT SAME)
	POP	P,T1		;RESTORE TEMP
	POPJ	P,		;RETURN


LCHR5:	PUSH	P,C		;SAVE REQUESTED CHARACTER
	PUSHJ	P,LTAB1		;SEND A TAB
	POP	P,C		;RESTORE CHARACTER
	JRST	LCHR1		;PROCEED


LCHRWL:	TRNE	F,R.OUTL	;SEE IF OUTPUT APPROPRIATE FOR EACH END OF LINE
LCHRW:	OUT	LC,		;OUTPUT BUFFER
	  POPJ	P,		;OK--RETURN
LCHRWR:	PUSH	P,T1		;ERROR--SAVE SOME ACS
	PUSH	P,T2		; ..
	PUSH	P,T3		; ..
	PUSH	P,F		;SAVE F
	TRZ	F,R.OUTO!R.OUTD	;CLEAR OUTPUT FLAGS
	N$WRNX	(LOE,Listing device output error, status)
	GETSTS	LC,T1		;GET ERROR STATUS
	MOVE	T2,T1		;PREPARE TO CLEAR
	ANDI	T2,-1-IO.ERR-IO.EOF  ;  BY PRESERVING JUST
	SETSTS	LC,(T2)		;  THE CONTROL BITS
	PUSHJ	P,.TOCTW##	;TYPE VALUE IN OCTAL
X$$LOE:	PUSHJ	P,.TCRLF##	;AND END LINE
	POP	P,F		;RESTORE THE ACS
	POP	P,T3		; ..
	POP	P,T2		; ..
	POP	P,T1		; ..
	POPJ	P,		;RETURN
;OUTIN -- SUBROUTINE TO OPEN THE OUTPUT LISTING FILE
;USES T1-4

OUTIN:	MOVE	T1,[O.LZER,,O.DEV]  ;POINT TO OUTPUT SPEC	[165]
	MOVEI	T2,O.LC		;POINT TO OUTPUT OPEN BLOCK	[165]
	MOVE	T3,[LE.LC,,E.LC]  ;POINT TO OUTPUT ENTER BLOCK	[165]
	PUSHJ	P,.STOPN##	;SETUP BLOCKS			[165]
	  JRST	E.OWI		;ERROR IF WILD-CARDS		[165]
	MOVEI	T1,LE.LC-1	;GET ENTER LENGTH		[165]
	IORM	T1,E.LC		;SET IN ENTER BLOCK		[165]
	MOVSI	T1,B.LC		;GET BUFFER HEADERS		[165]
	MOVEM	T1,O.LC+.OPBUF	;STORE IN OPEN BLOCK		[165]

OUTIN1:	OPEN	LC,O.LC		;OPEN DEVICE			[165]
	  JRST	E.OPO
	MOVE	T1,O.NAM	;ENTER IF NEEDED
	JUMPE	T1,OUTIN2
	MOVEI	T1,0		;LONG OFFSET			[224]
	TLNN	F,L.LENT	;IF SHORT ENTER,		[224]
	MOVEI	T1,2		; SET SHORT OFFSET		[224]
	ENTER	LC,E.LC(T1)	;ENTER FILE			[165]
	  JRST	E.OPE

OUTIN2:	OUTBUF	LC,0		;SETUP STANDARD BUFFERS		[165,312]
	TRO	F,R.OUTD	;INDICATE OUTPUT INITIALIZED
	POPJ	P,		;RETURN

E.OWI:	TRZ	F,R.OUTD!R.OUTO!R.OUTL	;CLEAR LISTING FLAGS
	N$FAIL	(OWI,Output wildcard illegal)

E.OPO:
IFN FT$LPW,<			;				[321]
	MOVE	T1,O.DEV	;SEE WHAT TYPE
	DEVCHR	T1,		;  OF DEVICE
	TXNN	T1,DV.LPT	;IS IT LINE PRINTER
	JRST	E.OPO1		;NO--FAIL
	TRON	F,R.LPTB	;YES--SECOND TIME?
	OUTSTR	[ASCIZ /LPT busy--waiting
/]
	MOVEI	T1,5		;SLEEP 5 SECONDS AND TRY AGAIN
	SLEEP	T1,		; ..
	JRST	OUTIN1		; ..
E.OPO1:
>;END IFN FT$LPW						[321]
	TRZ	F,R.OUTD!R.OUTO!R.OUTL  ;CLEAR LISTING FLAGS
	MOVE	P3,O.DEV
	N$FAIN	(OPO,Output OPEN failed on device)
E.OPE:	TRZ	F,R.OUTD!R.OUTO!R.OUTL  ;CLEAR LISTING FLAGS
	MOVE	P3,O.NAM
	N$FAIN	(OPE,Output ENTER failed on file)
;.TNEWL -- FORCE LISTING OUTPUT TO START OF LINE
;CALL:	PUSHJ	P,.TNEWL
;RETURNS AT BEGINNING OF LINE
;PRESERVES ALL ACS

.TNEWL:	TRNE	F,R.OUTD	;SEE IF OUTPUT
	SKIPN	NOCHRS		;YES--SEE IF AT START OF LINE
	POPJ	P,		;YES--RETURN
	PJRST	LCRLF		;NO--OUTPUT END OF LINE


;TCHR -- TYPE CHARACTER ON TTY
;CALL:	MOVEI	T1,CHARACTER
;	PUSHJ	P,TCHR
;PRESERVES ALL ACS

TCHR:	PUSHJ	P,SAVTYP	;SAVE R.TYPE AND CLEAR IT
	MOVE	C,T1		;(TEMP)
	TRNN	F,R.OUTD	;SEE IF OUTPUT
	JRST	TTCHR1		;NOT OPEN--FORCE TO TTY
	PUSHJ	P,LCHR		;YES--LIST CHARACTER
.TTCHR:	TRNN	F,R.OUTO	;SEE IF LISTING ON CONSOLE
TTCHR1:	OUTCHR	T1		;NO--TYPE IT ALSO
	POPJ	P,		;RETURN


;SAVTYP -- ROUTINE TO SAVE R.TYPE ON THE STACK AND CLEAR IT
;	THIS AVOIDS TYPING TITLES AND DOUBLE LISTINGS
;CALL:	PUSHJ	P,SAVTYP
;RETURNS CPOPJ.  SETS STACK TO RESTORE R.TYPE WHEN CALLER
;	RETURNS (CPOPJ OR CPOPJ1)
;PRESERVES ALL ACS

SAVTYP:	EXCH	T1,(P)		;GET CALLING PC
	MOVEM	T1,1(P)		;STASH AWAY FOR THE NEXT CALL
	MOVE	T1,(P)		;RESTORE T1
	SETZM	(P)		;FLAG R.TYPE=0
	TRZE	F,R.TYPE	;CLEAR R.TYPE
	SETOM	(P)		;FLAG THAT IT WAS ON
	PUSHJ	P,@1(P)		;CALL BACK TO CALLER
	  JRST	.+2		;HANDLE NON-SKIP
	AOS	-1(P)		;HANDLE SKIP
	SKIPE	(P)		;TEST MEMORY OF FLAG
	TRO	F,R.TYPE	;RESTORE R.TYPE
	POP	P,(P)		;DISCARD MEMORY
	POPJ	P,		;RETURN TO CALLER'S CALLER
SUBTTL	STORAGE

	XLIST		;LITERALS
	LIT
	LIST

	RELOC

OFFSET:	BLOCK	1		;STARTING ADDRESS OFFSET
ZCOR:!			;START OF AREA TO ZERO ON INITIAL LOAD

PDLST:	BLOCK	LN$PDL+1	;PUSH DOWN LIST
SAVCOR:	BLOCK	1		;LENGTH OF CORE ORIGINALLY
MYPPN:	BLOCK	1		;PROJECT-PROGRAMMER NUMBER OF THIS JOB
ORGFF:	BLOCK	1		;ORIGINAL .JBFF
H.ZER:!			;START OF AREA FOR OUTPUT PARAMETERS
O.LC:	BLOCK	3		;LISTING OPEN BLOCK		[165]
E.LC:	BLOCK	1+.RBEST	;LISTING ENTER BLOCK		[165]
LE.LC==.-E.LC
B.LC:	BLOCK	3		;LISTING BUFFER HEADERS
LNPP:	BLOCK	1		;LINES LEFT TO GO ON PAGE
PAGCNT:	BLOCK	1		;PAGE COUNTER
SVJBFF:	BLOCK	1		;INPUT SIDE .JBFF


H.ZER1:!		;START OF AREA FOR ONE OUTPUT
DCHBLK:	BLOCK	.DCSNM+1	;DSKCHR BLOCK
OPENBL:	BLOCK	1		;OPEN BLOCK
FSTR:	BLOCK	1		;CURRENT FILE STRUCTURE NAME
	BLOCK	1		; ..
MTNAME:	BLOCK	1		;DEVICE NAME OF MAG-TAPE	[166]
BFHD:	BLOCK	3		;BUFFER HEADERS FOR INPUT	[166]

LBLOCK:	BLOCK	LN$RIB		;EXTENDED LOOKUP BLOCK
FRVER:	BLOCK	1		;RIB VERSION IF DIFF. FROM FILE
FPRV:	BLOCK	1		;FILE PRIVILEGE
FRIBLK:	BLOCK	1		;RIB BLOCK NUMBER		[200]
H.ZERX:	BLOCK	.-H.ZER1	;REGION FOR PREVIOUS FILE
H.ZERY:
IFN FT$SFD,<
	BLOCK	3+LN$DRB	;  ..
MTPATH:	BLOCK	3+LN$DRB	;FOR PATH ON TAPES
>

MTSVFF:	BLOCK	1		;.JBFF AT FIRST MTOPEN

H.MZER:!		;START OF AREA FOR ONE MT SAVE SET
MTSVHD:	BLOCK	1		;LAST WORD READ FOR FAILSAFE MODE
MTSVVR:	BLOCK	1		;VERSION,,TAPE NUMBER
MTSVWD:	BLOCK	1		;SAVE HEADERS DURING BACKUP TAPES
MTSVCT:	BLOCK	1		;COUNTER FOR BACKUP DATA READS
LASI:	BLOCK	1		;LAST FILE FOUND
LASDIR:	BLOCK	1		;LAST DIRECTORY LISTED
LASSTR:	BLOCK	1		;LAST STRUCTURE LISTED
IFN FT$SFD,<
LASPTH:	BLOCK	3+LN$DRB	;ROOM FOR PREVIOUS PATH
THSPTH:	BLOCK	3+LN$DRB	;ROOM FOR CURRENT PATH
>
SUBDIR:	BLOCK	1		;SUBTOTAL DIRECTORY
SUBSTR:	BLOCK	1		;SUBTOTAL STRUCTURE
IFN FT$SFD,<
SUBPTH:	BLOCK	3+LN$DRB	;SUBTOTAL PATH
SUBEND==.-1
>
NOFIL:	BLOCK	1		;NUMBER OF FILES IN UFDS SCANNED
TOT:!			;GRAND TOTALS
NOFILF:	BLOCK	1		;NUMBER OF FILES ACTUALLY USED
NOFILR:	BLOCK	1		;NUMBER OF LOOKUP ERRORS
NOBLKS:	BLOCK	1		;NUMBER BLOCKS IN FILES PRINTED
TCHKSM:	BLOCK	1		;GRAND CHECKSUM
SUBT:!			;SUB TOTALS
SNFILF:	BLOCK	1		; (MUST PARALLEL AND IMMED. FOLLOW TOT)
SNFILR:	BLOCK	1
SNBLKS:	BLOCK	1
SCHKSM:	BLOCK	1

NUMDIR:	BLOCK	1		;NUMBER OF DIRECTORIES
NUMSUB:	BLOCK	1		;NUMBER OF SUBTOTALS
CHKSUM:	BLOCK	1		;CHECKSUM ACCUMULATOR
NOCHRS:	BLOCK	1		;CURRENT HORIZONTAL POSITION
LSTSTR:	BLOCK	1		;STR TO LIST IF NEEDED
LSTDIR:	BLOCK	1		;DIRECTORY TO LIST IF NEEDED
NXUCNT:	BLOCK	1		;COUNT OF UFDS FOUND
NXSCNT:	BLOCK	1		;COUNT OF SFDS MISSED
NXFCNT:	BLOCK	1		;COUNT OF FILES FOUND
NXFI:	BLOCK	1		;I OF LAST NON-EX FILE
H.EMZR==.-1
MTFLCT:	BLOCK	1		;COUNT DOWN ON MT FROM /FILE:N

;BACKUP/FRS FORMAT HEADER STORAGE AREAS

B$GTYP:	BLOCK	1		;RH=TYPE, LH=-1 IF FRS
B$GBNM:	BLOCK	1		;BLOCK NUMBER
B$GRTN:	BLOCK	1		;RELATIVE TAPE NUMBER
B$GFLG:	BLOCK	1		;FLAGS
B$GCHK:	BLOCK	1		;CHECKSUM
B$GSIZ:	BLOCK	1		;DATA SIZE
B$GLND:	BLOCK	1		;OVERHEAD WORDS
	BLOCK	5		;(FUTURE) WASTE SPACE

;LABEL HEADER

B$LBL:!
B$LCDT:	BLOCK	1		;CREATION DATE/TIME
B$LFRM:	BLOCK	1		;FORMAT STYLE
B$LFVR:	BLOCK	1		;FRS/BACKUP VERSION NUMBER
B$LMTY:	BLOCK	1		;MONITOR TYPE
B$LSVR:	BLOCK	1		;SYSTEM VERSION
B$LAPR:	BLOCK	1		;APR S/N WRITTEN ON
B$LDEV:	BLOCK	1		;DEVICE WRITTEN ON
B$LMTC:	BLOCK	1		;MTCHR.
B$LREL:	BLOCK	1		;REEL
B$LDDT:	BLOCK	1		;DESTROY DATE/TIME
	BLOCK	^D10		;WASTE SPACE
B$LTIM:	BLOCK	1		;TIME
B$LDAT:	BLOCK	1		;DATE
B$LDSD:	BLOCK	1		;DESTROY DATE
B$LCMT:	BLOCK	16		;COMMENT
	BLOCK	1		;PROTECT ASCIZ
;START/END OF SAVE SET

B$SSS:!
B$SCDT:	BLOCK	1		;SAVE DATE/TIME
B$SFMT:	BLOCK	1		;TAPE FORMAT
B$SVER:	BLOCK	1		;BACKUP/FRS VERSION
B$SMTY:	BLOCK	1		;MONITOR TYPE
B$SSVR:	BLOCK	1		;SYSTEM VERSION
B$SAPR:	BLOCK	1		;SAVE APR S/N
B$SDEV:	BLOCK	1		;DEVICE SAVED ON
B$SMTC:	BLOCK	1		;SAVE MTCHR.
	BLOCK	^D12		;WASTE SPACE
B$SSNM:	BLOCK	5		;SYSTEM NAME
B$STIM:	BLOCK	1		;SAVE TIME
B$SDAT:	BLOCK	1		;SAVE DATE
B$SMOD:	BLOCK	1		;MODE
B$STRK:	BLOCK	1		;TRACKS
B$SNAM:	BLOCK	1		;SAVE SET NAME
B$SCMT:	BLOCK	4		;COMMENT
	BLOCK	1		;PROTECT ASCIZ

;DIRECTORY RECORD

B$DIR:!
B$UPCH:	BLOCK	1		;PATH CHECKSUM
B$ULVL:	BLOCK	1		;DIRECTORY LEVEL (0=UFD)
B$USTA:	BLOCK	^D12		;DIRECTORY NAME
	BLOCK	6		;WASTE SPACE
B$USTR:	BLOCK	1		;STRUCTURE OF DIRECTORY
				CONT.
;FILE RECORD

B$FIL:!
B$FPCH:	BLOCK	1		;PATH CHECKSUM
B$FRDW:	BLOCK	1		;RELATIVE DATA WORD
B$FPTH:	BLOCK	^D12		;REDUNDANT PATH
	BLOCK	6		;WASTE SPACE
B$FSTR:	BLOCK	1		;STRUCTURE
B$FNAM:	BLOCK	1		;NAME
B$FEXT:	BLOCK	1		;EXTENSION
B$FUFD:	BLOCK	1		;UFD
B$FRBN:	BLOCK	1		;RELATIVE BLOCK NUMBER
B$FCHK:	BLOCK	1		;CHECKSUM
B$FNDB:	BLOCK	1		;NUMBER OF DATA BLOCKS
B$FNDW:	BLOCK	1		;NUMBER OF DATA WORDS
B$FLVL:	BLOCK	1		;FILE DIRECTORY LEVEL

;END OF VOLUME

B$EOV:	BLOCK	^D20		;WASTE SPACE

;COMMENT

B$CMT:	BLOCK	^D20		;COMMENT
	BLOCK	1		;PROTECT ASCIZ

;VARIOUS "DATA" REGION BLOCKS

B$BNAM:	BLOCK	^D30		;FILE PATH
B$BATT:	BLOCK	^D50		;FILE ATTRIBUTES
B$BSYS:	BLOCK	^D6		;SYSTEM NAME
B$BSSN:	BLOCK	^D7		;SAVE SET NAME

H.EZER==.-1
S.MIN:!			;START OF AREA FOR COMMAND ACCUMULATION
S.ACCS:	BLOCK	1		;VALUE OF /ACCESS SWITCH
S.ALC:	BLOCK	1		;/ALLOCAT SWITCH
S.AUT:	BLOCK	1		;/AUTHOR SWITCH			[174]
S.CHK:	BLOCK	1		;/CHECKSUM SWITCH
S.CMP:	BLOCK	1		;/COMPARE SWITCH
S.DODV:	BLOCK	1		;CODE FOR DEFAULT OUTPUT DEVICE
S.DTL:	BLOCK	1		;/DETAIL SWITCH
S.EOT:	BLOCK	1		;/EOT SWITCH
S.FDTA:	BLOCK	1		;/FDTA SWITCH			[225]
S.FILE:	BLOCK	1		;/FILES:N SWITCH
S.IND:	BLOCK	1		;/INDIRECT SWITCH
S.PRDE:	BLOCK	1		;/PRDEVICE SWITCH		[174]
S.PRDI:	BLOCK	1		;/PRDIRECTORY SWITCH		[174]
S.REWS:	BLOCK	1		;/REWINDS SWITCH
S.SORT:	BLOCK	1		;/SORT SWITCH
S.SUM:	BLOCK	1		;/SUMMARY SWITCH
S.TITL:	BLOCK	1		;-1,1=TITLE, 0=2=NO TITLE
S.UNIT:	BLOCK	1		;/UNITS SWITCH
S.WDTH:	BLOCK	1		;VALUE OF /WIDTH SWITCH
S.WORD:	BLOCK	1		;/WORD SWITCH
FLFSUM:	BLOCK	1		;FORCE SUMMARY IF 1		[160]
S.EMIN==.-1

S.ZER:!

O.ZER:!			;START OF OUTPUT SPEC STORAGE
O.DEV:	BLOCK	1		;DEVICE
O.NAM:	BLOCK	1		;NAME
O.NAMM:	BLOCK	1		;NAME MASK
O.EXT:	BLOCK	1		;EXT,,MASK
O.PROT:	BLOCK	2		;OUTPUT PROTECTION
	BLOCK	.FXLEN-.+O.ZER	;OTHER SWITCHES
O.LZER==.-O.ZER

I.INZR:	BLOCK	1		;POINTER TO START OF INPUT SPEC
I.NXZR:	BLOCK	1		;POINTER TO NEXT INPUT SPEC STORAGE
I.NXRD:	BLOCK	1		;POINTER TO NEXT INPUT SPEC TO DO
FLAGS:	BLOCK	1		;COPY OF F DURING SCAN
FLAGSM:	BLOCK	1		;DITTO--MASKS
MXWDTH:	BLOCK	1		;MAX WIDTH IF /W
	PHASE	0	;INPUT SPEC STORAGE FORMAT		[163]
I.DEV:!	BLOCK	1		;DEVICE
I.NAM:!	BLOCK	1		;NAME
I.NAMM:!BLOCK	1		;NAME MASK
I.EXT:!	BLOCK	1		;EXT,,MASK
I.MOD:!	BLOCK	1		;SWITCHES
I.MODM:!BLOCK	1		;SWITCH MASK (ON IF USER SUPPLIED)
I.DIR:!	BLOCK	1		;DIRECTORY
I.DIRM:!BLOCK	2*LN$DRB-1	;DIRECTORY MASK
	BLOCK	.FXLEN-.	;OTHER SWITCHES
I.LZER:!			;LENGTH				[163]
	DEPHASE

	BLOCK	2		;ROOM FOR BUFFER HEADERS	[225]
DIRB:	BLOCK	200		;DIRECTORY BLOCK FOR DECTAPE

S.EZER==.-1
EZCOR==.-1		;END OF AREA TO ZERO

	END	DIRECT
  Obf