	TITLE	.WILD -- SUBROUTINE TO PERFORM WILDCARD LOOKUP  %4(122)
	SUBTTL	P.CONKLIN/PFC		19-OCT-72


;***COPYRIGHT 1970, 1971, 1972  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***


CUSTVR==0		;CUSTOMER VERSION
DECVER==4		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==122		;DEC EDIT VERSION

XP %%WILD,CUSTVR*1B2+DECVER*1B11+DECMVR*1B17+DECEVR


;SUBROUTINE TO SCAN DIRECTORIES AND RETURN LOOKUP BLOCKS FOR THE
;VARIOUS NAMES WHICH MATCH WILD-CARDS.

;ASSEMBLY INSTRUCTIONS:
;
IF1,<	..==%%C+%%SCNM
IFNDEF	..,<
PRINTX	?	.COMPILE C+SCNMAC+WILD
	PASS2
	END>
	PURGE	..>

;
;THEN LOAD THE .REL FILE WITH ANY PROGRAM NEEDING IT.
;THIS SUBROUTINE WORKS ON THE DATA BASE LEFT BY THE COMMAND SCANER.
;A LIST OF PARAMETER AREAS DEFINES THE FILES REQUESTED AND THE VARIOUS
;SYSTEM STRUCTURES AND DIRECTORIES ARE SEARCHED.

	ENTRY	.LKWLD

;ONLY ONE PRINCIPLE ENTRY POINT IS DEFINED--GET THE FIRST OR NEXT FILE.
;CALL:	MOVE	T1,[LENGTH,,BLOCK]
;	PUSHJ	P,.LKWLD
; RETURN CPOPJ IF NO MORE FILES WITH T1=-1 (OR DEVCHR IF DISK ONLY)
;SKIP RETURN WITH OPEN BLOCK AND LOOKUP BLOCK PRESET
;	INDEX LOCATION WILL POINT TO CURRENT SCANER FILE SPEC
;		WITH T1=THE DEVCHR OF THE NEXT DEVICE
;		WITH T2=-1 IF DISK, 0 IF DTA, 1 OTHERS

;BLOCK+0: LH = LOCATION CONTAINING FIRST WORD OF FIRST SCANER FILE SPEC
;	  RH = 0 OR LOCATION CONTAINING FIRST WORD OF LAST SPEC
;      1: LH = LOCATION OF OPEN BLOCK (3 WORDS LONG)
;	  RH = LOCATION OF LOOKUP BLOCK
;      2: LH = LENGTH OF FILE SPEC FROM SCANER
;	  RH = LENGTH OF LOOKUP BLOCK
;      3: LH = CHANNEL FOR DATA FILE READING IF ANY AND FLAGS
;		1B0=1	HANDLE ALL DEVICES (ELSE, JUST DISK)
;	  RH = LOCATION OF POINTER TO FILE SPEC (INITIALLY 0)
;SECONDARY ENTRY POINTS:
;	PUSHJ	P,E.DFO
;		REPORTS OPEN ERROR FOR DATA FILE
;	PUSHJ	P,.NXDTW
;	  EOF RETURN
;	NORMAL RETURN WITH NEXT WORD IN T1
;		READS ONE BYTE
;	PUSHJ	P,E.DFL
;		REPORTS LOOKUP ERROR 
;		ERROR INFO IN LOOKUP BLOCK
;	PUSHJ	P,.LKERR
;		REPORTS LOOKUP ERROR MESSAGE (NO FILE)
;		(CODE IN T1)
;		(PROT. IN 0-8 OF T3)
;	PUSHJ	P,.CHKTM
;		CHECKS /BEFORE AND /SINCE CONSTRAINTS
;		(ASSUMES LOOKUP WAS DONE INTO AREA LAST
;		 POINTED TO BY LAST CALL TO .LKWLD)
;		(ASSUMES PARAM AREA POINTED TO BY RH(E+3)
;		 IN LAST CALL TO .LKWLD)


;.WLDFL	=FLAG (-1 IF WILD, +1 IF STR WILD, -2 IF BOTH)
;.WIFIR	=LOCATION OF START OF CONCATENATED SET
;.WILAS	=LOCATION OF END ...  (X+Y)
;B.DC	=LOCATION OF BUFFER HEADER
;.WLDBF =BUFFER WITH CURRENT DIRECTORY BLOCK

	TWOSEG
	RELOC	400000


ND FTSFD,-1		;SUB-FILE DIRECTORIES

IFLE .FXLND-1,<FTSFD==0
		.FXLND==1>
	SUBTTL	REVISION HISTORY

;%1 -- 6/71 WITH 5.03 MONITOR (NAMED LOKWLD)

;A)  SHIFT INDEX TO P1 WHICH IS PRESERVED.  UPDATE USER'S
;	INDEX VIA ARGUMENT.
;B)  UPDATE TO USE THE REVISED TYPEOUT ROUTINES IN SCAN.
;C)  CHANGE CALL TO BE A BLOCK POINTED TO FROM T1.
;D)  USE CHANNEL 0 FOR ALL DIRECTORY READING.  HANDLE SFDS.  DIRECTORY
;	READING IS NOW IN DUMP MODE.
;E)  USE ARGUMENT CHANNEL FOR DATA READS.
;F)  USE C.MAC (AND SCNMAC.MAC) FOR ALL BITS AND BYTES INCLUDING THE
;	FILE SPEC AREA.
;G)  HANDLE [,] [P,] [,P] AND [-] NOTATIONS.
;H)  HANDLE + FOR UFDS (DEFICIENCY OF VERSION 1).
;I)  USE PATH. WHERE POSSIBLE FOR SYS:, ETC.
;J)  HANDLE STR, CONTROLLER CLASS, AND CONTROLLER ABBREVIATIONS.
;K)  FLAG FOR CALLER BOTH STRS AND WILD (.WLDFL=-2).
;L)  DO NOT OPEN DATA CHANNEL.
;M)  RETURN LOOKUP BLOCK IN CORE INSTEAD OF ACS.
;N)  ADD ROUTINE (.CHKTM) TO CHECK /BEFORE AND /SINCE SWITCHES.
;O)  DELAY DIRECTORY LOOKUP ERRORS TO END IN CASE SOME OTHER
;	STRUCTURE GETS IT OK.
;P)  MAKE OPEN FAILURE FATAL.  INCLUDE ASSIGNED JOB NUMBER IF KNOWN.
;Q)  ADD SEARCH LIST EMPTY (24) TO STANDARD LOOKUP ERRORS.
;R)  CHKACC DIRECTORIES
;S)  HANDLE SPECIAL DEVICES SUCH AS HLP:, ALL:, SXS:, ETC.

;%2(76) -- 5/72 WITH DIRECT %2.

;77	CORRECT BUG WHEN READING BLOCKS OF THE DIRECTORY.  EXAMINED
;	ONLY 63 FILES PER BLOCK INSTEAD OF 64.

;%3(77) -- 6/72

;100	USE .FX SYMBOLS FROM SCNMAC %3(50)
;101	USE .FXDFX TO FLAG MFD FIXUPS. HANDLE SYS:.UFD
;102	ALLOW REENTRY AFTER NON-DISK DEVICE.
;103	ALLOW FX.ADD OR .FXTRO FOR OR FUNCTION.
;104	ADD DEFENSIVE HALT IN CASE LH(DIRECTORY)=0.  (SPR 10-7182)
;105	REPLACE INTERNS BY :: FLAG.
;106	USE REAL EXTENSION IN LOOKUP ERROR MESSAGE
;107	ADD DTA HANDLING
;110	CORRECT SUBSCRIPTS IN E.DFL ROUTINE
;111	SET /DEN/PAR SWITCHES FOR MTA
;112	CONSIDER /BEFORE AND /SINCE =-1 TO BE ABSENT
;113	[*,NOT *,...] WILL NOT MATCH FOR USER PROJECT GT 7
;		AND TARGET PROJECT LE 7
;114	HANDLE [1,1].UFD CORRECTLY.  THIS ELIMINATES THE OLD NOTATION
;		OF #X0000YY.UFD[1,1]
;115	FIX BUG IN CHKACC LOGIC OF MFD.
;116	FIX BUG IN SYS: INTRODUCED BY 107.
;117	ADD ENTRY .CHKTA FOR DIRECT
;120	INCLUDE "." IN MODULE NAME.
;121	ADD SYMBOLS .WILDZ AND .WILDL FOR START AND LENGTH OF
;	LOW CORE AREA
;122	HANDLE NO MFD MESSAGE GRACEFULLY.
	SUBTTL	MISC. DEFINITIONS

;ACCUMULATORS


T1=1	;SCRATCH
T2=2
T3=3
T4=4

P1=5	;INDEX TO COMMAND SCANNER DATA BASE

P=17	;PUSH DOWN LIST

;CHANNELS

WC==0	;CHANNEL FOR DIRECTORY READING
DC==0	;READ DATA (UPDATED BY ARGUMENT)

;FLAGS

DOALDV==1B0	;DO ALL DEVICES
	SUBTTL	INITIALIZE AND PRESET CALL

;HERE ON EXTERNAL CALL

.LKWLD:	HLRZ	T2,T1		;GET LENGTH OF BLOCK
	PUSHJ	P,.GTWRD##	;GET BLOCK+0
	TRNE	T3,-1		;SEE IF END GIVEN
	HRR	T3,(T3)		;YES--GET END OF SPECS
	MOVS	T4,T3		;SWITCH TO START
	HRR	T4,(T4)		;GET START OF SPECS
	TLNN	T4,-1		;SEE IF END SPECIFIED
	HRL	T4,T4		;NO--USE START
	HLRZM	T4,AGLIMS	;STORE END FOR TESTS
	TLZ	T4,-1		;CLEAR JUNK FOR LATER
	PUSH	P,T4		;SAVE AWAY
	PUSHJ	P,.GTWRD	;GET BLOCK+1
	HLRZM	T3,AGOPEN	;SAVE OPEN BLOCK
	HRRZM	T3,AGLOOK	;SAVE LOOKUP BLOCK
	SKIPE	AGOPEN		;PROTECT AGAINST JUNK
	SKIPN	AGLOOK		; ..
	HALT	.+1		;BAD USER CALL
	PUSHJ	P,.GTWRD	;GET BLOCK+2
	HRRZM	T3,AGLENL	;SAVE LENGTH OF LOOKUP BLOCK
	HLRZ	T3,T3		;GET LENGTH OF PARAMETER AREA
	MOVEM	T3,AGLENP	;SAVE FOR LATER
	PUSHJ	P,.GTWRD	;GET BLOCK+3
	HRRZM	T3,AGPNTR	;SAVE LOCATION OF POINTER
	HLLZ	T4,T3		;ISOLATE CHANNEL
	MOVEM	T3,AGFLAG	;STORE FLAGS
	LSH	T4,5		;POSITION FOR UUOS
	MOVEM	T4,AGDCHN	;SAVE FOR DODCHN ROUTINE
	POP	P,T4		;RESTORE SPEC POINTER
	MOVEM	P1,SAVEP1	;SAVE POINTER
	HRRZ	P1,(T3)		;SETUP USER'S POINTER
	SUBTTL	LOOKUP ONE FILE

	JUMPN	P1,[SKIPN	NOTDSK	;IF ALREADY SETUP, CONTINUE
		    JRST	WILDN	;WITH DISK
		    MOVE	P1,.WILAS  ;OR AFTER
		    JRST	LOOKST]	; NON-DISK
	MOVX	T1,%LDMFD	;GET LOCATION OF MFD
	GETTAB	T1,		;FROM MONITOR
	  MOVE	T1,[1,,1]	;(LEV C)
	MOVEM	T1,MFDPPN	;SAVE FOR LATER

IFN FTSFD,<
	SETZM	PTHARG		;CLEAR PATH
	MOVE	T1,[PTHARG,,PTHARG+1]
	BLT	T1,PTHEND	; ..
	MOVE	T1,[PTHLEN-1,,PTHARG]
	SETOM	PTHARG		;-1 MEANS RETURN DEFAULT PATH
	PATH.	T1,		;GET DEFAULT PATH
	  SETZM	PTHARG		;IF ERROR, CLEAR ARGUMENT
>
	GETPPN	T1,		;GET USER'S NUMBER
	  JFCL			;IN CASE OF JACCT
	MOVEM	T1,MYPPN	;STORE FOR LATER
IFN FTSFD,<
	SKIPN	PTHDIR		;SEE IF PATH. WORKED
	MOVEM	T1,PTHDIR	;NO--SIMULATE IT
>

	SKIPA	P1,T4		;BRAND NEW--GET STARTING POINT

;LOOP OVER EACH FILE SPECIFICATION IN THE REQUEST
; TO FIND ANY AND ALL FILES WHICH MATCH IT

LOOKST:	ADD	P1,AGLENP	;NOT BRAND NEW--ADVANCE PARAMETER
	HRRZM	P1,@AGPNTR	;STORE CURRENT POINTER FOR USER
	CAMG	P1,AGLIMS	;SEE IF AT END YET
	JRST	LOOKGO		;NO--GO DO OUR BIT
	SETO	T1,		;YES--FLAG ALL DONE
	EXCH	P1,SAVEP1	;RESTORE POINTER
	POPJ	P,	

;HERE WHEN AN INPUT REQUEST HAS BEEN SPECIFIED AND SETUP IN P1

LOOKGO:	SETZM	FWAZER		;CLEAR TEMPORARIES
	MOVE	T1,[FWAZER,,FWAZER+1]	; ..
	BLT	T1,LWAZER	; ..
	MOVEM	P1,.WIFIR	;SAVE STARTING BLOCK
;LOOP TO DISCOVER A SET OF CONCATENATED FILE SPECIFICATIONS
;THE USER HAS CONCATENATED THEM TO CAUSE A SINGLE PASS WILD SEARCH.

LOOK1:	MOVEM	P1,.WILAS	;SAVE ENDING BLOCK
	PUSHJ	P,SETDIR	;SETUP DIRECTORY DEFAULTS
	LDB	T1,[POINTR (.FXMOD(P1),FX.TRM)]  ;GET TERMINATION
	JUMPE	T1,DIR1		;COMMA--GO AHEAD AND WORK
	MOVE	T1,.FXDEV(P1)	;YES--COMPARE DEVICES
	ADD	P1,AGLENP	;ADVANCE TO NEXT ONE
	CAMG	P1,AGLIMS	;SEE IF OFF END
	CAME	T1,.FXDEV(P1)	;TEST
	JRST	DIR1		;DIFFERENT--IGNORE +
	PUSHJ	P,SETDIR	;SETUP DIRECTORY DEFAULTS
	MOVE	T1,.WIFIR	;SAME--COMPARE DIRECTORY
	MOVE	T2,P1		; ENTRY
	HRLI	T1,-2*.FXLND	; BY
LOOK2:	MOVE	T3,.FXDIR(T2)	; ENTRY
	AOS	T2		; ..
	CAMN	T3,.FXDIR(T1)	; ..
	AOBJN	T1,LOOK2	;LOOP BACK
	JUMPGE	T1,LOOK1	;LOOP IF MATCHED
;HERE WHEN CONCATENATED REQUESTS HAVE BEEN SELECTED TO DETERMINE
; WHAT TYPE OF SEARCHING TO DO ACROSS STRS

DIR1:	MOVE	P1,.WIFIR	;REFETCH POINTER
	MOVX	T1,FX.PHY	;SEE IF USER ASKED FOR PHYS.
	TDNN	T1,.FXMOD(P1)	; ..
	JRST	NOTPHY		;NO--SKIP TESTS
	MOVSI	T1,'SYS'	;YES--SEE IF POSSIBLE
	DEVCHR	T1,UU.PHY	; BY TRYING ONE
	TRNE	T1,-1		;SEE IF GOT SOMETHING BACK
	SETOM	PHYS		;YES--SET FOR PHYS I/O
NOTPHY:	MOVSI	T2,.FXDEV(P1)	;POINT TO ARGUMENT AREA
	HRRI	T2,FSTR		;POINT TO INTERNAL AREA
	BLT	T2,ENDERR	;COPY FOR ANY ERROR MESSAGES
	MOVE	T2,.FXDEV(P1)	;FIND OUT IF STRUCTURE SEARCH NECESSARY
	PUSHJ	P,DOPHYS	;PERFORM PHYSICAL I/O CALL
	  DEVCHR T2,		;SEE IF DISK TYPE DEVICE
	MOVEM	T2,DVCH		;SAVE FOR USER
	TXNE	T2,DV.DSK	; ..
	JRST	ISDISK		;OK--PROCEED
	SKIPL	AGFLAG		;SEE IF ALL DEVICES TO BE HANDLED
	JRST	[MOVE	T1,T2	;NO--POSITION DEVCHR
		 EXCH	P1,SAVEP1 ;RESTORE P1
		 SETOM	NOTDSK	;SET FLAG
		 POPJ	P,]	;AND RETURN
	MOVX	T3,FX.DIR	;CLEAR
	ANDCAM	T3,.FXMOD(P1)	;  DIRECTORY
	SETZM	.FXDIR(P1)	;CLEAR DIRECTORY
	SETZM	.FXDIM(P1)	; TO AVOID CONFUSION
	TXNE	T2,DV.DTA	;SEE IF DECTAPE
	JRST	ISDTA		;YES--GO HANDLE
	SETOM	NOTDSK		;FLAG FOR REENTRY
	JRST	STR7		;GO SETUP OPEN BLOCK
ISDTA:	SETOM	FLDTA		;SET FLAG FOR LATER ON
ISDISK:	HLRZ	T1,.FXEXT(P1)	;GET EXTENSION
	SKIPN	FLDTA		;IF NOT DECTAPE
	CAIE	T1,'UFD'	;AND UFD
	SETCM	T1,.FXNMM(P1)	;CHECK NAME MASK FOR WILDCARD
	JUMPN	T1,SEEIFD	;IF SO, GO DO WILD THINGS
	MOVEI	T2,.FXDIR(P1)	;NO--CHECK DIRECTORY
	HRLI	T2,-.FXLND	;ENTRY BY ENTRY
NOTPH1:	SKIPN	(T2)		;CHECK DIRECTORY
	SKIPE	1(T2)		; AND WILDCARD
	JRST	.+2		;SOMETHING THERE
	JRST	NOTPH2		;IF NULL, MUST BE DONE
	SETCM	T1,1(T2)	;NO--CHECK DIRECTORY MASK
	JUMPN	T1,SEEIFD	;IF WILD GO SEE IF LEVEL D
	AOS	T2		;ANDVANCE
	AOBJN	T2,NOTPH1	;AND LOOP BACK
NOTPH2:	SETCM	T1,.FXEXT(P1)	;NO--CHECK EXTENSION
	CAMN	P1,.WILAS	;SEE IF CONCATENATION
	TRNE	T1,-1		;TEST EXT. MASK
	JRST	SEEIFD		;WILD--GO SEE IF LEVEL D

;HERE IF NOT A WILD FILE SPECIFICATION

	MOVX	T1,FX.STR	;NOT WILD--SEE IF STR WILD
	TDNE	T1,.FXMOD(P1)	; BEING RQUESTED
	SKIPE	FLDTA		;AND NOT DTA:
	JRST	STR7		;NO--JUST USE USER'S DEVICE
	MOVEI	T1,1		;YES--FLAG STR WILD (BUT NOT FILE)
	JRST	DIR2		;AND GO SELECT A SEARCH LIST

;HERE WHEN THE FILE IS WILD

SEEIFD:	SETOB	T1,.WLDFL	;SET WILD FILE FLAG
	SKIPE	FLDTA		;SEE IF DECTAPE
	JRST	STR7		;YES--NO DIRECTORY JUNK
DIR2:	MOVX	T2,%CNSTS	;SEE IF LEVEL D SYSTEM
	GETTAB	T2,		; ..
	  MOVEI	T2,0		;(NO)
	TXNN	T2,ST%TDS	;TEST FIELD
	JRST	DIR4		;NO--NO FUNNY F/S LOGIC
	MOVEM	T1,.WLDFL	;YES--STORE FILE WILD FLAG
	TXNE	T2,<ST%TDS-1B9>	;SEE IF 5.03 OR LATER
	SETOM	SY2RCH		;YES--SET FLAG THAT REAL SYS: SL IS AVAILABLE

;HERE WHEN STRUCTURE WILD-CARD IS INDICATED
;CHECK DEVICE TO DETERMINE WHAT TYPE OF SEARCH LIST TO USE

IFN FTSFD,<
	MOVE	T3,FSTR		;GET STRUCTURE
	MOVEI	T4,0		;CLEAR ANSWER
	MOVE	T2,[3,,T3]	;SETUP CODE
	PUSHJ	P,DOPHYS	;ASK MONITOR FOR
	  PATH.	T2,		;  SYS IDENT.
	    JRST DIR3		;NOT IMPLEMENTED--TRY OLD WAY
	MOVE	T1,P1		;SAVE DEVICE PPN
	MOVE	P1,.WIFIR	;RESTORE P1
	HLRZ	T2,T3		;GET GENERIC STR NAME
	CAIE	T2,'SYS'	;LOOK FOR SYS:
	TXNE	T4,PT.IPP	;NO--SEE IF IGNORE DIRECTORY ARGS
	JRST	.+2		;YES--CLOBBER ARGUMENT
	JRST	DIR2A		;NO--PROCEED
	CAIN	T2,'SYS'	;IF SYS,
	HRLI	T3,'DSK'	;SWITCH TO DSK TO GET RIGHT SUBSET
	MOVEM	T3,FSTR		;  LIKE "SYSA:", ETC.
	PUSHJ	P,SETPPN	;SET REQUESTED PPN
	TXNN	T4,PT.IPP	;SEE IF IGNORE PPN
	SETOM	SYSRCH		;NO--SET SYS FLAG
;HERE TO SEE IF SPECIAL SEARCH LIST NEEDED

DIR2A:	LDB	T1,[POINTR (T4,PT.SLT)]  ;GET S/L CODE
	JUMPE	T1,DIR3		;PROCEED IF NOTHING SPECIAL
	SETZM	SY2RCH		;EXPLICIT INFO, SO CLEAR FLAGS
	SETZM	SYSRCH		; ..
	CAIE	T1,.PTSLA	;SEE IF ALL S/L
	CAIN	T1,.PTSLS	;OR SYS S/L
	SETOM	SYSRCH		;YES--FLAG FOR ALL OR SYS
	CAIN	T1,.PTSLS	;SEE IF SYS S/L
	SETOM	SY2RCH		;YES--FLAG FOR SYS
	JRST	DIR7		;AND SKIP AD HOC KLUDGERY
>

DIR3:	MOVE	T2,FSTR		;GET DEVICE NAME
	MOVE	T3,[1,,T2]	;SET FOR DSKCHR
	PUSHJ	P,DOPHYS	;DO PHYS I/O CALL
	  DSKCHR T3,		;SEE IF SYS OR GENERIC
	    JRST DIR5		;FAILED--MUST BE SYS:
	LDB	T1,[POINTR (T3,DC.TYP)]  ;GET NAME CLASS
	JUMPE	T1,DIR7		;JUMP IF DSK:
	CAIN	T1,.DCTAB	;IF STR ABBR. (SE:)
	JRST	DIRM1		;  GO SET MASK
	CAIN	T1,.DCTCN	;IF CONTROLLER CLASS (DP:)
	JRST	DIRM4		;  GO SET DSKCHR MASK
	CAIN	T1,.DCTCC	;IF CONTROLLER (DPA:)
	JRST	DIRM5		;  GO SET IT
	SKIPL	.WLDFL		;NOTHING SPECIAL--SEE IF WILD FILE FLAG
	SETZM	.WLDFL		;YES--CLEAR WILD CARD INDICATOR
	JRST	STR7		;USE USER'S DEVICE
;HERE IF LEVEL-C WILDCARD INDICATED
;NEED TO CHECK FOR "SYS:" AND FIXUP DIRECTORY IF SO

DIR4:	MOVS	T1,.FXDEV(P1)	;GET DEVICE
	CAIN	T1,'SYS'	;SEE IF "SYS:"
	PUSHJ	P,SETSYS	;YES--SETUP FOR SYS:
	JRST	STR7		;PROCEED WITHOUT F/S LOGIC

;HERE WHEN STR ABBREVIATION FOUND (LIKE SE: FOR SEFI: AND SEMA:)

DIRM1:	MOVE	T3,FSTR		;GET ABBREVIATION
	DEVNAM	T3,		;CONVERT TO PHYSICAL IF WE CAN
	  MOVE	T3,FSTR		;IF NOT DO THE BEST WE CAN
	PUSHJ	P,.MKMSK##	;GET MASK OF SIZE
	JRST	DIRM8		;AND GO STORE

;HERE WHEN CONTROLLER CLASS (DP:)

DIRM4:	MOVX	T1,DC.CNT	;SET MASK FOR TYPE OF CONTROLLER
	JRST	DIRM8		;AND GO STORE

;HERE WHEN CONTROLLER (DPA:)

DIRM5:	MOVX	T1,<DC.CNT!DC.CNN>	;SET MASK FOR TYPE AND NUMBER OF CONTROLLER

;HERE WITH T1=MASK, T3=MATCH

DIRM8:	MOVEM	T1,STRMSK	;STORE MASK
	MOVEM	T3,STRMTH	;STORE MATCH
	JRST	DIR6		;AND FLAG FOR SYSSTR TYPE SEARCHING

;HERE WHEN SYS SEARCH LIST IS SELECTED

DIR5:	SKIPN	SYSRCH		;SEE IF ALREADY SETUP
	PUSHJ	P,SETSYS	;SETUP DIRECTORY FOR SYS:
DIR6:	SETOM	SYSRCH		;FLAG FOR SYSTEM SEARCH LIST (F/S LIST)

;HERE WHEN ANY SEARCH LIST IS SELECTED

DIR7:	SETZM	LASSTR		;PRESET FOR SEARCH UUO
	SETOM	SRCH		;FLAG TO USE A SEARCH LIST
	SKIPGE	.WLDFL		;IF WILD FILES,
	SOS	.WLDFL		;SET FLAG TO -2 TO INDICATE WILD STRS AS WELL
	MOVSI	T1,'SYS'	;SEE IF PHYSICAL IS POSSIBLE
	DEVCHR	T1,UU.PHY	;BY TRYING A DEVICE KNOWN TO EXIST
	TRNE	T1,-1		;IF IT WORKED,
	SETOM	PHYS		;  FORCE PHYSICAL SINCE STR NAMES
				;  SHOULD NOT BE TRANSFORMED
;BACK HERE TO GO TO NEXT STRUCTURE

STR1:	MOVE	P1,.WIFIR	;RESET INDEX
	SKIPN	SRCH		;HERE FOR NEXT--SEE IF SEARCHING
	JRST	LOOKEN		;NO--GO TO NEXT REQUEST
STR2:	MOVE	T1,LASSTR	;GET F/S NAME FOR LIST
	SKIPE	SYSRCH		;NEED A NEW F/S
	JRST	STR3		;FROM SYSTEM F/S LIST
	SKIPN	T1		;SEE IF FIRST PASS
	SETOM	T1		;YES--BLANKETY-BLANK UUO
	MOVE	T2,[1,,T1]	;SETUP POINTER
	JOBSTR	T2,		;FROM JOB'S SEARCH LIST
	  HALT	LOOKEN
	JRST	STR5		;GOT IT

STR3:	SKIPE	SY2RCH		;NEEDS SYS: S.L.
	SKIPE	STRMSK		;IF MASK, NEEDS ALL STR LIST
	JRST	.+2		;YES--USE IT
	JRST	STR4		;GO USE REAL SYS: SEARCH LIST
	SYSSTR	T1,		;CAN'T--USE ALL STRS IN SYSTEM
	  HALT	LOOKEN
	JRST	STR5		;GOT IT--GO PROCESS

STR4:	SKIPN	T1		;SEE IF AT START
	SETOM	T1		;YES--FOOLISH UUO
	MOVEM	T1,GOBST+2	;STORE STR IN GOBSTR'S ARG LIST
	SETZM	GOBST		;SPECIFY JOB 0
	MOVE	T1,.FXDIR(P1)	;GET SYSPPN
	MOVEM	T1,GOBST+1	;STORE IN ARGUMENT
	MOVEI	T1,GOBST	;SETUP SHORT BLOCK
	GOBSTR	T1,		;ASK MONITOR
	  HALT	LOOKEN		;GIVE UP IF ERROR
	MOVE	T1,GOBST+2	;GET ANSWER

STR5:	CAMN	T1,[-1]		;LOOK FOR END
	JRST	LOOKEN		;YES--DONE
	JUMPE	T1,LOOKEN	;IF ZERO, ALL DONE
	MOVEM	T1,FSTR
	MOVEM	T1,LASSTR	;SAVE FOR SEARCH
	SKIPN	T2,STRMSK	;SEE IF MASKING RESULTS
	JRST	STR7		;NO--PROCEED WITH RESULTS
	JUMPL	T2,STR6		;JUMP IF NAME MASKING
	MOVE	T3,T1		;SET FOR
	MOVE	T2,[1,,T3]	;DSKCHR
	PUSHJ	P,DOPHYS	;AND DO IT
	  DSKCHR T2,		;  ..
	    HALT LOOKEN		;  ..
	MOVE	T1,T2		;POSITION RESULT
STR6:	XOR	T1,STRMTH	;SEE IF MATCHES
	TDNE	T1,STRMSK	;WHERE IMPORTANT
	JRST	STR2		;NO--GO GET NEXT STR

;HERE TO START ONE DEVICE (FILE STRUCTURE)

STR7:	AOS	NOSTRS		;COUNT STR SELECTED
	PUSHJ	P,SETOPN	;SETUP AN OPEN BLOCK
	MOVE	T4,DVCH		;GET DEVICE CHARS
	TXNN	T4,DV.MTA	;XEE IF MAG TAPE
	JRST	NOTMTA		;NO--PROCEED
	MOVX	T4,FX.PAR	;GET BIT FOR TEST
	TDNE	T4,.FXMOD(P1)	;SEE IF /PAR:EVEN
	TXO	T1,IO.PAR	;YES--SET INTO OPEN
	LDB	T4,[POINTR (.FXMOD(P1),FX.DEN)] ;GET /DEN
	DPB	T4,[POINTR (T1,IO.DEN)] ;SET INTO OPEN
NOTMTA:	MOVE	T4,AGOPEN	;POINT TO USER AREA
	MOVEM	T1,(T4)		;STORE PHYSICAL BIT, ETC.
	MOVEM	T2,1(T4)	;STORE DEVICE NAME
	MOVEI	T3,B.DC		;POINT TO BUFFER HEADER FOR INPUT
	MOVEM	T3,2(T4)	;STORE FOR USER
	SKIPE	NOTDSK		;SEE IF NOT DIRECTORY
	JRST	UFD6		;RIGHT--GO GIVE ANSWERS
	SETZB	T4,DEPTH	;CLEAR DEPTH OF NEST
	JRST	WILDSN		;GO START A NEW UFD
;BACK HERE TO GET NEXT FILE IN THIS DIRECTORY

WILDN:	MOVE	P1,.WIFIR	;RESET SPEC POINTER
	MOVE	T4,DEPTH	;SET INDEX TO TABLES
	SETZB	T3,DIRBU(T4)	;CLEAR DIRECTORY AT THIS LEVEL
	LSH	T4,1		;GET DOUBLE WORD POINTER
	SETZM	UFDPPN(T4)	;CLEAR ERROR MESSAGE STORAGE
	SETZM	UFDPPN+1(T4)	;  AND ITS MASK
	LSH	T4,-1		;REPOSITION COUNTER
	SKIPG	DIRSTI(T4)	;SEE IF WILD AT THIS LEVEL
	JRST	WILDE		;NO--PRETEND EOF THIS DIRECTORY
	SKIPE	DIRFLG		;SEE IF DIRECTORY BEING REPEATED
	JRST	WILDP		;YES--DON'T ADVANCE BUFFER
	SOSGE	BUFCNT(T4)	;COUNT DOWN FILES IN THIS BLOCK
	JRST	WILDR		;NON LEFT--GO READ NEXT BLOCK
	MOVEI	T3,2		;OK--ADVANCE TWO WORDS
	SKIPE	FLDTA		;SEE IF DECTAPE
	MOVEI	T3,1		;YES--ADVANCE ONE WORD
WILDP:	ADDB	T3,BUFPOS(T4)	;NOTE NEW POSITION
	SKIPE	FLDTA		;SEE IF DECTAPE
	ADDI	T3,^D84		;POSITION TO FILE NAME
	MOVE	T1,.WLDBF-2(T3)  ;GET FILE NAME
	JUMPE	T1,WILDN	;NULL--LOOP FOR NEXT FILE
	SKIPE	FLDTA		;SEE IF DECTAPE
	ADDI	T3,^D21		;POINT TO EXTENSION
	HLRZ	T2,.WLDBF-1(T3)  ;GET EXTENSION
	LSH	T4,1		;DOUBLE DEPTH
	SKIPE	FLDTA		;SEE IF DECTAPE
	JRST	WILDF		;YES--NO DIRECTORY JUNK
	CAIN	T2,'SFD'	;SEE IF SUB-FILE DIRECTORY
	JUMPN	T4,WILDS	;YES--GO HANDLE
	CAIN	T2,'UFD'	;SEE IF DIRECTORY
	JUMPE	T4,WILDU	;YES--GO HANDLE
WILDF:	ADDI	T4,(P1)		;POINT TO INPUT SPEC
	MOVE	T3,.FXDIR(T4)	;GET DIRECTORY
	TDNE	T3,.FXDIM(T4)	;SEE IF END OF DIRECTORIES
	JRST	WILDN		;NO--NO FILE ALLOWED HERE
;HERE WHEN FOUND A POSSIBLE FILE--SEE IF IT MATCHES
WILDM:	AOS	NOFIL		;COUNT FILE AS SEEN
WILDC:	MOVE	T3,T1		;GET THIS FILE
	XOR	TNAM(P1)	;COMPARE
	HRLZ	T4,T2		;GET THIS EXT
	XOR	T4,.FXEXT(P1)	;COMPARE,,FETCH MASK
	TDNN	T3,.FXNMM(P1)	;CHECK NAME
	TLNE	T4,(T4)		;CHECK EXT
	JRST	.+2		;FAIL--GO LOOP
	JRST	UFD7		;WIN--GO GIVE ANSWER TO USER
	ADD	P1,AGLENP	;ADVANCE SPEC POINTER
	CAMG	P1,.WILAS	;SEE IF STILL IN RANGE
	JRST	WILDC		;YES--GO BACK AND CHECK
	JRST	WILDN		;NO--GO GET NEXT FILE

;BACK HERE WHEN NEW DIRECTORY AND NO WILDCARD NEEDED
WILDNW:	MOVE	T1,.FXDIR(T3)	;GET NAME
	SETOM	DIRSTI(T4)	;SET -1 FOR NO-WILD FLAG
	MOVE	T4,T3		;SETUP INDEX TO ARGS
	JRST	WILDK		;GO HANDLE DIRECTORY
;HERE WHEN UFD OR SFD SEEN IN SCANNING THE DIRECTORIES

WILDS:	SKIPE	DIRFLG		;SEE IF DIRECTORY REPEATED
	JRST	WILDL		;YES--HANDLE AS DIRECTORY NOW
	SETOM	DIRFLG		;NOT YET--SET FLAG
	JRST	WILDF		;AND HANDLE AS FILE FIRST
WILDU:
WILDL:	SETZM	DIRFLG		;CLEAR DIRECTORY FLAG
	ADDI	T4,(P1)		;POINT TO INPUT SPEC
WILDK:	SKIPN	.FXDIR(T4)	;GET THIS DIRECTORY IN REQUEST
	SKIPE	.FXDIM(T4)	;TO SEE IF IT IS
	JRST	.+2		;THERE
	JRST	WILDN		;NO--GO HANDLE AS FILE

	TLNN	T1,-1		;SEE IF LH=0
	HALT	WILDN		;YES--CAN'T HAPPEN UNLESS MONITOR ERROR
	MOVE	T3,DEPTH	;YES--GET DEPTH OF OUR WORK
	MOVEM	T1,DIRBU(T3)	;SAVE DIRECTORY NAME
	LSH	T3,1		;DOUBLE POINTER
	MOVEM	T1,UFDPPN(T3)	;STORE FOR POSSIBLE ERROR MESSAGE
	SETOM	UFDPPN+1(T3)	;SET MASK ON FULL
	XOR	T1,.FXDIR(T4)	;COMPARE TO REQUEST
	TDNE	T1,.FXDIM(T4)	;SEE IF MATCH
	JRST	WILDN		;NO--GO TRY AGAIN
	JUMPN	T3,WILDJ	;SEE IF UFD
	SKIPE	T1,.FXDIM(T4)	;YES--SEE IF [*,NOT*]
	TLNE	T1,-1		; ..
	JRST	WILDJ		;NO--OK TO PROCEED
	MOVE	T1,MYPPN	;YES--GET OUR NUMBER
	MOVE	T2,UFDPPN	;AND TARGET NUMBER
	TLNE	T1,777770	;SEE IF WE ARE GT PROJ 7
	TLNE	T2,777770	;AND TARGET IS LE PROJ 7
	JRST	WILDJ		;NO--PROCEED
	JRST	WILDN		;YES--SKIP MATCH SINCE THIS
				; IS TO A SYSTEM FILE FROM USER
WILDJ:	AOS	T4,DEPTH	;LOOKS GOOD--ADVANCE DEPTH OF SEARCH
	CAIG	T4,.FXLND	;SEE IF TOO DEEP
	JRST	WILDSN		;NO--PROCEED
	SOS	DEPTH		;YES--BACK UP
	JRST	WILDN		;AND TRY AGAIN
;HERE WHEN NEW DIRECTORY SELECTED

WILDSN:	MOVEI	T3,(T4)		;GET DEPTH
	LSH	T3,1		;DOUBLE IT
	ADDI	T3,(P1)		;POINT TO INPUT SPEC
	SETCM	T2,.FXDIM(T3)	;GET MASK
	JUMPE	T2,WILDNW	;IF NO WILD CARD, GO DOWN ONE LEVEL
	SKIPN	.FXDIM(T3)	;SEE IF AT END
	SKIPE	.FXDIR(T3)	;  OF REQUESTED DIRS.
	JRST	WILDD		;NO--SKIP ON
	AOS	NOUFDF		;YES--COUNT DIRECTORY AS FOUND
	AOS	NSUFD		;PRECOUNT SUCCESSFUL LOOKUP
	SKIPL	.WLDFL		;SEE IF WILD FILE NAME
	JRST	UFD6		;NO--GIVE TO CALLER
WILDD:	SETZM	DIRSTI(T4)	;CLEAR USETI POINTER

;HERE WHEN TIME TO READ NEXT BLOCK OF A DIRECTORY

WILDR:	MOVEI	T1,100		;SET FOR 100
	SKIPE	FLDTA		;SEE IF DECTAPE
	MOVEI	T1,^D22		;YES--ONLY 22 FILES
	MOVEM	T1,BUFCNT(T4)	;  FILES IN A BLOCK
	SETZM	BUFPOS(T4)	;CLEAR POSITION IN BLOCK
WILDRR:	PUSHJ	P,SETOPN	;SETUP OPEN BLOCK
	HRRI	T1,.IODMP	;READ IN DUMP MODE
	OPEN	WC,T1		;OPEN WILD CHANNEL
	  JRST	E.UFO		;ERROR--GO ISSUE MESSAGE
	SKIPN	FLDTA		;SEE IF DECTAPE
	JRST	WILDRD		;NO--CHECK DIRECTORY
	SKIPE	DIRSTI		;SEE IF FIRST TIME HERE
	JRST	WILDE		;NO--GO HANDLE AS EOF
	MOVEI	T1,^D100	;SET FOR DECTAPE POSITION
	MOVEM	T1,DIRSTI	;FLAG FOR NEXT TIME
	JRST	WILDRI		;GO READ BUFFER
WILDRD:	SETZM	DIRBU-1		;ALWAYS CLEAR SWITCHES (AND MFD)
	MOVE	T1,DIRBU-1(T4)	;GET THIS DIRECTORY'S NAME
	SETZM	DIRBU-1(T4)	;CLEAR DIRECTORY
	CAIG	T4,1		;SEE IF UFD
	JRST	WILDRM		;YES--GO HANDLE IT
	MOVSI	T2,'SFD'	;SET FOR SFD
	MOVEI	T4,DIRB		;POINT TO PATH
	MOVEI	T3,1		;INDICATE NO
	MOVEM	T3,DIRBS	;  DIRECTORY SCANNING
	SKIPN	DIRBU+1		;SEE IF FIRST SFD
	MOVE	T4,DIRBU	;YES--GET UFD
	JRST	WILDRL		;GO LOOKUP DIRECTORY
WILDRM:	MOVSI	T2,'UFD'	;SET UFD
	MOVE	T4,MFDPPN	;SET MFD
	SKIPN	T1		;SEE IF TOP LEVEL
	MOVE	T1,T4		;YES--READ MFD ITSELF
WILDRL:	MOVEI	T3,0		;CLEAR E+2
	LOOKUP	WC,T1		;LOOKUP DIRECTORY
	  JRST	E.UFL		;ERROR--GO GIVE MESSAGE
	SETZM	DIRBU-1		;CLEAR SWITCHES (AND MFD)
	SKIPE	T4,DEPTH	;RESTORE DEPTH
	MOVEM	T1,DIRBU-1(T4)	;SET DIRECTORY
	HLRZ	T1,T3		;GET PROTECTION CODE
	ANDI	T1,777000	;CLEAR TO JUST DIRECT. PROT.
	HRLI	T1,.ACSRC	;SET SEARCH DIRECTORY FUNCTION
	MOVE	T3,MYPPN	;GET USER'S NUMBER
	SKIPN	T2,DIRBU	;GET DIRECTORY OWNER
	MOVE	T2,MFDPPN	;IF MFD, USE MFD NUMBER
	MOVEI	T4,T1		;POINT TO ARGS
	CHKACC	T4,		;CHECK ACCESS RIGHTS
	  MOVEI	T4,0		;(ASSUME OK)
	MOVEI	T2,ERPRT%	;SET PROTECTION ERROR JUST IN CASE
	HRLZ	T3,T1		;RESTORE PROTECTION JUST IN CASE
	JUMPN	T4,E.UFL1	;GIVE ERROR IF NOT PERMITTED

	MOVE	T4,DEPTH	;RESTORE DEPTH INDEX
	AOS	T1,DIRSTI(T4)	;ADVANCE BLOCK COUNT
	CAILE	T1,1
WILDRI:	USETI	WC,(T1)		;POSITION FILE
	MOVE	T1,[-200,,.WLDBF-1]
	MOVEI	T2,0		;SETUP DUMP LIST
	IN	WC,T1		;READ BUFFER
	  JRST	WILDRK		;OK
	STATZ	WC,IO.ERR	;SEE IF ANY ERRORS
	  PUSHJ	P,E.UFE		;YES--GO TELL USER
	STATO	WC,IO.EOF	;SEE IF END OF FILE
	  JRST	WILDRK		;NO--PROCEED WITH THIS BLOCK

;HERE AT END OF FILE IN A DIRECTORY

WILDE:	CLOSE	WC,CL.ACS!CL.DAT  ;CLOSE DELETING ACCESS TABLES
	RELEAS	WC,		;RELEASE CHANNEL
	SOSGE	T4,DEPTH	;BACK OFF DEPTH
	JRST	STR1		;DONE WITH MFD--GO TO NEXT STR
	SETZM	DIRBU(T4)	;CLEAR DIRECTORY ENTRY
	SOSL	DIRSTI(T4)	;BACKUP BUFFER INDEX(TO FILE)
	JRST	WILDRR		;AND RE-READ BUFFER
	JRST	WILDN		;NOT WILD--GO UP AGAIN

;HERE WHEN BLOCK READ

WILDRK:	CLOSE	WC,CL.ACS	;DON'T UPDATE ACCESS DATES
	RELEAS	WC,
	JRST	WILDN		;AND GO READ FOR FILES
;HERE  WHEN FILE PRESUMED (NO WILD CARD)
UFD6:	MOVE	T1,.FXNAM(P1)	;GET USER'S NAME
	HLRZ	T2,.FXEXT(P1)	;AND EXTENSION
	AOS	NOFIL		;COUNT FILE SEEN
;HERE WHEN A FILE IS FOUND
;SETUP ANSWER BLOCK FOR CALLING PROGRAM

UFD7:	AOS	NOFILF		;COUNT FILE FOUND
	MOVEM	T1,FNAM		;SAVE FILE NAME
	HRLZM	T2,FEXT		;SAVE FILE EXTENSION
	MOVE	T2,AGLENL	;GET LENGTH OF LOOKUP BLOCK
	MOVE	T1,AGLOOK	;GET START OF LOOKUP BLOCK
	MOVEI	T3,-1(T2)	;SET LENGTH IN BLOCK
	PUSHJ	P,.PTWRD	;STORE IN BLOCK+0
IFE FTSFD,<
	MOVE	T3,UFDPPN
>
IFN FTSFD,<
	SKIPN	DIRBU+1		;SEE IF PATH NEEDED
	SKIPA	T3,DIRBU	;NO--GET UFD
	MOVEI	T3,DIRB		;YES--SETUP POINTER
>
	JUMPN	T3,UFD8		;IF DIRECTORY SETUP, PROCEED
	MOVX	T4,FX.DIR	;SEE IF USER SAID NO DIRECT.
	TDNE	T4,.FXMOD(P1)	; ...
	MOVE	T3,MFDPPN	;NO--SO MUST BE MFD
UFD8:	MOVE	T4,T3		;SAVE FOR LATER
	PUSHJ	P,.PTWRD	;STORE IN BLOCK+1
	MOVE	T3,FNAM		;GET FILE NAME
	PUSHJ	P,.PTWRD	;STORE IN BLOCK+2
	HLLZ	T3,FEXT		;GET EXTENSION
	PUSHJ	P,.PTWRD	;STORE IN BLOCK+3
	MOVEI	T3,0		;CLEAR PRIV WORD
	PUSHJ	P,.PTWRD	;STORE IN BLOCK+4
	MOVE	T3,T4		;GET DIRECTORY AGAIN FOR LEVEL C
	PUSHJ	P,.PTWRD	;STORE IN BLOCK+5
	MOVEI	T3,0		;ZERO ALL THE REST
	PUSHJ	P,.PTWRD	;STORE IN BLOCK+6, ETC.
	JUMPG	T2,.-1		;LOOP UNTIL DONE
	EXCH	P1,SAVEP1	;RESTORE ARGUMENT
	SETCM	T2,FLDTA	;GET -1 IF DISK, 0 IF DECTAPE
	SKIPE	NOTDSK		;SEE IF NOT DIRECTORY DEVICE
	MOVEI	T2,1		;RIGHT--SET FLAG
	MOVE	T1,DVCH		;RESTORE DEVICE CHARS.
	JRST	CPOPJ1		;RETURN SUCCESSFULLY
;.CHKTM -- SUBROUTINE TO CHECK CREATION DATE/TIME OF FILE
;	AGAINST /BEFORE AND /SINCE SWITCHES
;.CHKTA -- DITTO EXCEPT TESTS FOR ANY DEVICE
;CALL:	(AFTER LOOKUP AFTER LAST RETURN FROM .LKWLD)
;	PUSHJ	P,.CHKTM
;	  RETURN IF TOO OLD OR TOO YOUNG
;	RETURN IF OK
;USES T1-4

.CHKTM::SKIPN	FLDTA		;SEE IF DECTAPE
	SKIPE	NOTDSK		;SEE IF NONDIRECTORY
	JRST	CPOPJ1		;YES--ASSUME OK
.CHKTA::MOVE	T1,AGLOOK	;GET POINTER TO LOOKUP BLOCK
	MOVE	T2,.RBPRV(T1)	;CREATION TIME/DATE MUST EXIST
	LDB	T1,[POINTR (T2,RB.CRT)]  ;GET CREATION TIME
	IMULI	T1,^D60000	;CONVERT TO MILLI-SEC.
	ANDI	T2,RB.CRD	;MASK DATE
	PUSHJ	P,.CNVDT##	;CONVERT TO INTERNAL FORMAT
	MOVE	T2,@AGPNTR	;POINT TO PARAM AREA
	CAMGE	T1,.FXSNC(T2)	;SEE IF TOO OLD
	JRST	CHKTMF		;YES--FAIL
	SKIPLE	.FXBFR(T2)	;SEE IF /BEFORE GIVEN
	CAMG	T1,.FXBFR(T2)	;YES--SEE IF TOO YOUNG
	JRST	CPOPJ1		;NO--JUST RIGHT

;HERE IF TOO OLD OR TOO YOUNG
;	BACK DOWN SUCCESS COUNTER

CHKTMF:	SOS	NOFILF		;DECREMENT SUCCESS COUNTER
	POPJ	P,		;GIVE BAD NEWS TO CALLER
;HERE AT END OF A REQUEST TO SEE IF ANYTHING WAS FOUND
;IF NOT, AN APPROPRIATE ERROR MESSAGE WILL BE TYPED

LOOKEN:	MOVX	T1,FX.NOM	;SEE IF WE CARE IF ANY MATCHED
	TDNN	T1,.FXMOD(P1)	; ..
	SKIPE	NOFILF		;YES--SEE IF ANYTHING FOUND
	JRST	LOOKNY		;YES--GO BACK TO NEXT REQUEST
	PUSHJ	P,.TNEWL##	;FORCE BEGINNING OF LINE
	HRLZI	T1,.FXDEV(P1)	;COPY ORIGINAL REQUEST
	HRRI	T1,FSTR		;  INTO ANSWER AREA
	BLT	T1,ENDERR	;  FOR TYPE OUT
	SKIPE	NOFIL		;NO--SEE IF ANY FILES EXAMINED
	JRST	E.NSF		;YES--JUST NO SUCH FILES
	SKIPE	NOUFDF		;NO--SEE IF ANY DIRECTORIES MATCHED
	JRST	E.DEM		;YES--DIRECTORY EMPTY
	SKIPE	T2,LASERR	;SEE IF ANY ERRORS LEFT LYING AROUND
	JRST	DLYERR		;YES--GO GIVE THEM AS EXPLANATION
	SKIPE	NOSTRS		;SEE IF ANY STRUCTURES FOUND
	JRST	E.NSD		;YES--JUST NO SUCH DIRECTORY

;ERROR:	SEARCH LIST IS EMPTY

E.SLE:	MOVEI	T1,[ASCIZ /% Search list empty for device /]
	PUSHJ	P,.TSTRG##	;TYPE MESSAGE
	PUSHJ	P,TYPSTR	;AND STR NAME
	JRST	LOOKNX		;AND RETURN

;ERROR:	NO DIRECTORY MATCHES THE USER'S REQUEST

E.NSD:	MOVEI	T1,[ASCIZ /% No such d/]	;NO--NO SUCH DIRECTORY
	PUSHJ	P,DIRERR	;ISSUE DIRECTORY ERROR
	JRST	LOOKNX		;GO ISSUE CRLF AND RETURN

;ERROR:	THE DIRECTORY IS EMPTY

E.DEM:	SKIPE	UFDEF		;SEE IF WE FOUND AN ERROR YET
	JRST	LOOKNY		;YES--DON'T REPORT IT AGAIN
	SKIPN	NSUFD		;SEE IF ANY SUCCESSFULLY LOOKED UP
	JRST	E.NXD		;NO--GO GIVE MESSAGE
	MOVEI	T1,[ASCIZ /% D/]
	PUSHJ	P,DIRERR	;ISSUE DIRECTORY ERROR
	MOVEI	T1,[ASCIZ / is empty/]
	PUSHJ	P,.TSTRG	;DIRECTORY EMPTY MESSAGE
	JRST	LOOKNX		;GO ISSUE CRLF AND RETURN
;ERROR: DIRECTORY COULD NOT BE FOUND ON SOME STRUCTURE

DLYERR:	MOVE	T2,[ERIPP%	;MFD MISSING
		    ERSNF%	;SFD MISSING
		    ERFNF%]-1(T2)  ;OR FILE MISSING
	SKIPN	UFDEF		;SEE IF ERROR ALREADY GIVEN
	PUSHJ	P,LKERRD	;NO--GIVE THIS ONE
	JRST	LOOKNY		;AND FINISH UP

;ERROR:	ALL MATCHING UFDS WERE NON-EXISTENT

E.NXD:	MOVEI	T1,[ASCIZ /% Non-existent/]
	PUSHJ	P,UFDERR	;ISSUE DEVICE AND UFD CODE
	JRST	LOOKNY		;AND START OVER

;ERROR:	NO FILE MATCHES THE USER'S REQUEST

E.NSF:	MOVEI	T1,[ASCIZ /% No such files as /]
	PUSHJ	P,FILOUT	;ISSUE FILE ERROR

LOOKNX:	PUSHJ	P,.TCRLF##	;ISSUE NEW LINE
LOOKNY:	MOVE	P1,.WILAS	;POSITION POINTER
	JRST	LOOKST		;GO BACK FOR NEXT REQUEST
	SUBTTL	DIRECTORY SUBROUTINES

;SUBROUTINE TO SUPPLY DEFAULTS FOR DIRECTORIES
;CALL:	MOVEI	P1,POINTER TO SPECIFICATION
;	PUSHJ	P,SETDIR
;USES T1-4
;
;HANDLES [,] (IE, DEFAULT PROJECT, DEFAULT PROGRAMMER),
;HANDLES [-] (IE, DEFAULT TO DEFAULT DIRECTORY)
;HANDLES .UFD (IE, DIRECTORY IS REALLY FILE NAME)

SETDIR:	MOVX	T1,FX.DFX	;GET FLAG
	TDNE	T1,.FXMOD(P1)	;SEE IF HERE ALREADY
	POPJ	P,		;YES--RETURN
	IORM	T1,.FXMOD(P1)	;NO--SET FLAG FOR LATER
	MOVX	T1,FX.DIR	;SEE IF DIRECTORY
	TDNE	T1,.FXMOD(P1)	;  SPECIFIED
	JRST	SETDR2		;YES--GO HANDLE IT
	HLRZ	T1,.FXEXT(P1)	;GET EXTENSION
	CAIN	T1,'UFD'	;SEE IF UFD
	JRST	SETDR		;YES--GO DO DEFAULTS
	MOVX	T1,FX.TRM	;SEE IF CONCATENATED
	CAMN	P1,.WIFIR	;  OR SECOND FILE
	TDNE	T1,.FXMOD(P1)	; ..
	JRST	SETDR		;YES--SAME AS WILD CARDS
	SETCM	T1,.FXNMM(P1)	;SEE IF WILD NAME
	SETCM	T2,.FXEXT(P1)	;  OR EXT
	TRNN	T2,-1		;IF SO,
	JUMPE	T1,SETDR3	;  LEAVE DIRECTORY CLEAR
SETDR:
IFN FTSFD,<
	MOVE	T1,[-.FXLND,,PTHDIR]
	MOVEI	T2,.FXDIR(P1)	;NO--COPY DEFAULT DIRECTORY
SETDR1:	SKIPN	T3,(T1)		;GET NEXT LEVEL
	SOS	T1		;BLANK--HOLD POINTER
	MOVEM	T3,(T2)		;STORE IN ARGUMENT AREA
	SKIPE	T3		;SEE IF BLANK
	SETOM	T3		;NO--FULL MATCH
	MOVEM	T3,1(T2)	;STORE AWAY
	ADDI	T2,2		;ADVANCE STORAGE
	AOBJN	T1,SETDR1	;LOOP UNTIL DONE
	JRST	SETDR3		;AND PROCEED BELOW
>
SETDR2:	MOVE	T1,.FXDIR(P1)	;GET DIRECTORY
	IOR	T1,.FXDIM(P1)	;  AND MASK
	MOVE	T2,MYPPN	;DEFAULT PPN--GET USER
	TLNN	T1,-1		;SEE IF PROJECT PRESENT
	HLLM	T2,.FXDIR(P1)	;NO--FILL IN MY PROJECT
	TLNN	T1,-1		; ..
	HRROS	.FXDIM(P1)	; AND NO WILDCARD
	TRNN	T1,-1		;SEE IF PROGRAMMER PRESENT
	HRRM	T2,.FXDIR(P1)	;NO--FILL IN MY PROGRAMMER
	TRNN	T1,-1		; ..
	HLLOS	.FXDIM(P1)	; AND NO WILDCARD
SETDR3:	HLRZ	T1,.FXEXT(P1)	;GET EXTENSION
	CAIE	T1,'UFD'	;SEE IF .UFD
	POPJ	P,		;NO--ALREADY SETUP CORRECTLY
	MOVE	T1,MFDPPN	;YES--GET CORRECT DIRECTORY
	EXCH	T1,.FXDIR(P1)	;STORE (MFD)
	SETO	T2,		;CLEAR WILDCARDS
	EXCH	T2,.FXDIM(P1)	;SET INTO DIRECTORY
	MOVEM	T1,.FXNAM(P1)	;MOVE DIRECTORY TO NAME
	MOVEM	T2,.FXNMM(P1)	;MOVE DIRECTORY TO NAME
IFN FTSFD,<
	SETZM	.FXDIR+2(P1)	;CLEAR SUB DIRECTORY
	SETZM	.FXDIM+2(P1)	; ..
>
	POPJ	P,		;RETURN
;ERROR:	DIRECTORY OPEN

E.UFO:	MOVEI	T1,[ASCIZ /Directory on /]
	PUSHJ	P,OPNERR
	SETOM	UFDEF		;INDICATE ERROR MESS FOR DIRECTORY
	JRST	STR1

;ERROR:	DIRECTORY LOOKUP FAILURE

E.UFL:	SKIPE	T4,DEPTH	;RESTORE DEPTH POINTER
	MOVEM	T1,DIRBU-1(T4)	;RESTORE DIRECTORY LIST
E.UFL1:	TLZ	T2,-1		;CLEAR JUNK
	JUMPE	T4,[PUSHJ P,E.MFL  ;ISSUE MFD ERROR
		    JRST  WILDE]   ;AND LOOP
	SOS	NSUFD		;DISCOUNT UFD FOUND SUCCESSFULLY
	CAIE	T2,ERSNF%	;SEE IF SFD ERROR
	CAIG	T2,ERIPP%	;SEE IF NON-EXISTENT ERROR
	SKIPL	SRCH		;AND STR SEARCHING
	JRST	.+2		;NO--PROCEED
	JRST	E.UFLX		;YES--SKIP MESSAGE FOR NOW
	PUSHJ	P,LKERRD	;ISSUE ERROR MESSAGE
	JRST	WILDE		;AND TRY NEXT DIRECTORY

E.UFLX:	CAIN	T2,ERSNF%	;COMPACT ERROR CODE
	MOVEI	T2,2		; SFD IS WORST
	SKIPN	T2		; ..
	MOVEI	T2,3		;EXCEPT FOR FILE MISSING
	CAMLE	T2,LASERR	;SEE IF WORST YET
	MOVEM	T2,LASERR	;YES--REMEMBER IT
	JRST	WILDE		;AND CONTINUE ONWARDS

;ISSUE ERROR IN SFD/UFD/MFD
LKERRD:	PUSHJ	P,LKERR		;OUTPUT LOOKUP ERROR
	  JRST	E.MFL1		; (IF MFD FAILED)
	SETOM	UFDEF		;FLAG THAT ERROR WAS FOUND
	PJRST	UFDER1		;OUTPUT UFD ERROR AND RETURN

E.MFL1:	MOVEI	T2,0		;FUDGE FILE NOT FOUND ERROR
E.MFL:	CAIN	T2,ERIPP%	;SEE IF ILL PPN
	MOVEI	T2,ERFNF%	;CHANGE TO NO SUCH FILE (MFD)
	PUSHJ	P,LKERR		;OUTPUT LOOKUP ERROR
	  HALT	.+1
	PJRST	MFDERR		;OUTPUT MFD ERROR AND RETURN

;ERROR:	I/O ERROR WHILE READING DIRECTORY

E.UFE:	GETSTS	WC,T1		;DATA ERROR--GET STATUS
	PUSHJ	P,STSERR	;OUTPUT MESSAGE
	SETSTS	WC,(T1)		;AND CLEAR ERROR BITS
	PJRST	UFDER1		;OUTPUT UFD ERROR
;.NXDTW -- GET NEXT WORD FROM DATA FILE
;CALL:	PUSHJ	P,.NXDTW
;	ERROR RETURN IF END-OF-FILE
;	NORMAL RETURN WITH WORD IN T1

.NXDTW::SOSGE	B.DC+2		;SEE IF WORD IN BUFFER
	JRST	NXDATR		;NO--READ SOME MORE OF FILE
	ILDB	T1,B.DC+1	;FETCH WORD
	JRST	CPOPJ1		;SKIP RETURN

NXDATR:	PUSHJ	P,DODCHN	;EXECUTE DATA CHANNEL UUO
	  IN	DC,		;READ
	    JRST  .NXDTW	;OK TO PROCEED

	PUSHJ	P,DODCHN	;EXECUTE DATA CHANNEL UUO
	  STATZ	DC,IO.ERR	;SEE IF ANY ERRORS
	    PUSHJ P,E.DFE  	;YES
	PUSHJ	P,DODCHN	;EXECUTE DATA CHANNEL UUO
	  STATO	DC,IO.EOF	;SEE IF EOF
	    JRST .NXDTW  	;NO--GET MORE DATA
	POPJ	P,		;YES--EOF RETURN



;ERROR:	DATA FILE OPEN

E.DFO::	MOVEI	T1,[0]
OPNERR:	PUSH	P,T1		;SAVE MESSAGE INSERT
	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	MOVEI	T1,[ASCIZ /? Open failure for /]
	PUSHJ	P,.TSTRG	;OUTPUT ERROR
	POP	P,T1		;RECOVER INSERT
	PUSHJ	P,STRER1	;OUTPUT STRUCTURE NAME
	MOVE	T2,FSTR		;GET DEVICE
	PUSHJ	P,DOPHYS	;GET PHYSICAL BIT
	  DEVTYP T2,		;GET JOB USING IT
	    JRST OPNER1		;GIVE UP IF NOT IMPLEMENTED
	LDB	T2,[POINTR (T2,TY.JOB)]  ;GET USER JOB
	JUMPE	T2,OPNER1	;GIVE UP IF NOT ON RECORD
	MOVEI	T1,[ASCIZ / in use by job /]
	PUSHJ	P,.TSTRG	;TYPE PREFIX
	HRRZ	T1,T2		;GET JOB NUMBER
	PUSHJ	P,.TDECW##	;TYPE JOB NUMBER
OPNER1:	PJRST	.TCRLF		;END LINE AND RETURN
;ERROR:	DATA FILE LOOKUP ERROR

E.DFL::	MOVE	T1,AGLOOK	;POINT TO LOOKUP BLOCK
	MOVE	T2,AGLENL	;GET LENGTH
	CAIG	T2,.RBDEV	;SEE IF STR IS INCLUDED
	JRST	EDFL1		;NO--USE ARGUMENT
	SKIPE	T3,.RBDEV(T1)	;SEE IF BETTER STR SPECIFIED
	MOVEM	T3,FSTR		;YES--UPDATE DIAGNOSTIC
EDFL1:	HLLZ	T3,.RBEXT(T1)	;GET REAL EXTENSION
	CAIL	T2,.RBEXT	;SEE IF EXISTS
	MOVEM	T3,FEXT		;YES--USE IT IN MESSAGE
	CAIGE	T2,.RBPPN	;SEE IF UFD INCLUDED
	TDZA	T3,T3		;NO--CLEAR IT
	MOVE	T3,.RBPPN(T1)	;YES--GET BETTER PPN
	TLNE	T3,-1		;SEE IF BETTER UFD SPECIFIED
	MOVEM	T3,UFDPPN	;YES--UPDATE DIAGNOSTIC
	CAIGE	T2,.RBPRV	;SEE IF PROTECTION INCLUDED
	TDZA	T3,T3		;NO--CLEAR WORD
	MOVE	T3,.RBPRV(T1)	;YES--GET PROTECTION
	CAIGE	T2,.RBEXT	;SEE IF ERROR CODE INCLUDED
	TDZA	T2,T2		;NO--CLEAR
	HRRZ	T2,.RBEXT(T1)	;YES--GET CODE
	PUSHJ	P,LKERR		;OUTPUT LOOKUP ERROR
	  JRST	.+2		; (IF UFD FAILED)
	PJRST	.TFILE		;OUTPUT FILE NAME AND RETURN
	SKIPN	SRCH		;SEE IF MULTIPLE STRS
	JRST	E.NXU		;NO--ISSUE MESSAGE
	SOS	NOSTRS		;YES--BACK OFF COUNTER
	POPJ	P,		;AND RETURN
E.NXU:	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	MOVEI	T1,[ASCIZ /% Non-existent/]
	PJRST	UFDERR		;OUTPUT UFD NAME AND RETURN

;ERROR:	I/O ERROR WHILE READING DATA FILE

E.DFE:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,SAVEP1	;GET BACK LOCAL P1
	PUSHJ	P,DODCHN	;DO DATA CHANNEL UUO
	  GETSTS DC,T1		;GET STATUS BITS
	PUSHJ	P,STSERR	;OUTPUT STATUS MESSAGE
	PUSHJ	P,DODCHN	;DO DATA CHANNEL UUO
	  SETSTS DC,(T1)	;CLEAR ERROR BITS
	PJRST	.TFILE		;OUTPUT FILE NAME
;LKERR -- OUTPUT LOOKUP ERROR MESSAGE
;CALL:	MOVEI	T2,ERROR CODE
;	MOVEI	T3,PROTECTION IF ERROR 2
;	PUSHJ	P,LKERR
;	ERROR RETURN IF UFD BAD
;USES T1, T2, T3

LKERR:	HRRZ	T2,T2		;GET ERROR CODE
	CAIN	T2,1		;SEE IF UFD ERROR
	POPJ	P,		;YES--ERROR RETURN
	AOS	(P)		;NO--ADVANCE RETURN
	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	MOVEI	T1,[ASCIZ /% /]
	PUSHJ	P,.TSTRG	;LIST FLAG
	MOVE	T1,T2		;SETUP ERROR CODE

;SUBROUTINE ENTRY TO TYPEOUT A LOOKUP ERROR CODE
;CALL IS SAME AS LKERR EXCEPT ERROR IN T1 (LH=0)
;AND ALWAYS RETURNS CPOPJ
;WILL GIVE HUMAN MESSAGE FOR COMMON ERRORS

.LKERR::MOVE	T2,T1		;PRESERVE ERROR CODE
	CAIE	T2,ERTRN%	;SEE IF RIB ERROR OR
	CAIG	T2,ERPRT%	; OTHER KIND OF COMMON ERROR
	JRST	LKERR1		;YES--GO HANDLE
	CAIE	T2,ERSNF%	;MAYBE SFD
	CAIN	T2,ERSLE%	;  OR S.L. PROBLEM
	JRST	LKERR1		;YES--GO HANDLE
	MOVEI	T1,[ASCIZ /Lookup failure /]
	PUSHJ	P,.TSTRG	;NO--PRINT OCTAL CODE
	MOVE	T1,T2		;GET ERROR CODE
	PJRST	.TOCTW##	;  AND RETURN
LKERR1:	MOVEI	T1,[ASCIZ /Non-existent/]
	CAIN	T2,ERIPP%
	MOVEI	T1,[ASCIZ /Non-existent UFD/]
	CAIN	T2,ERTRN%
	MOVEI	T1,[ASCIZ /RIB or directory read error/]
	CAIN	T2,ERSNF%
	MOVEI	T1,[ASCIZ /Non-existent SFD/]
	CAIN	T2,ERSLE%
	MOVEI	T1,[ASCIZ /Search list empty/]
	CAIE	T2,ERPRT%
	PJRST	.TSTRG		;ISSUE MESSAGE AND RETURN
	MOVEI	T1,[ASCIZ /Protection/]
	PUSHJ	P,.TSTRG	;ISSUE PROTECTION MESSAGE
	LSH	T3,-^D27	;POSITION PROTECTION CODE
	MOVEI	T1," "
	SKIPE	T3
	PUSHJ	P,.TCHAR##
	SKIPE	T1,T3
	PUSHJ	P,.TOCTW
	MOVEI	T1,[ASCIZ / failure/]
	PJRST	.TSTRG		;AND RETURN
;STSERR -- ISSUE I/O STATUS ERROR MESSAGE
;CALL:	GETSTS	T1
;	PUSHJ	P,STSERR
;UPDATES T1 TO CLEAR ERROR BITS

STSERR:	PUSH	P,T1		;SAVE STATUS
	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	MOVEI	T1,[ASCIZ /% Error /]
	PUSHJ	P,.TSTRG	;ISSUE MESSAGE
	MOVE	T1,(P)		;GET STATUS
	PUSH	P,T2		;SAVE ACS
	PUSH	P,T3		; ..
	PUSHJ	P,.TOCTW	;LIST STATUS
	POP	P,T3		;RESTORE ACS
	POP	P,T2		; ..
	MOVEI	T1,[ASCIZ / while reading/]
	PUSHJ	P,.TSTRG	;AND REST OF MESSAGE
	POP	P,T1		;RESTORE STATUS
	TRZ	T1,IO.ERR	;CLEAR ERROR BITS
	POPJ	P,		;RETURN
;MFDERR -- ISSUE MESSAGE THAT ERROR IS IN MFD
;CALL:	PUSHJ	P,MFDERR
;USES T1

MFDERR:	MOVEI	T1,[ASCIZ / MFD/]
	PUSHJ	P,STRERR	;OUTPUT STRUCTURE NAME
	PJRST	.TCRLF		;END LINE AND RETURN



;.TFILE--OUTPUT UFD OR FILE NAME
;CALL:	PUSHJ	P,.TFILE
;USES T1

.TFILE::HLRZ	T1,FEXT		;SEE WHAT KIND OF FILE
	CAIE	T1,'UFD'	;SEE IF DIRECTORY
	JRST	DATERR		;NO--OUTPUT NORMAL FILE NAME
	JRST	UFDER1		;YES--OUTPUT DIRECTORY



;UFDERR -- ISSUE MESSAGE THAT ERROR IS IN UFD
;CALL:	MOVEI	T1,MESSAGE
;	PUSHJ	P,UFDERR
;USES T1

UFDERR:	PUSHJ	P,.TSTRG	;SEND REST OF MESSAGE
UFDER1:	MOVEI	T1," "		;SPACE OVER
	PUSHJ	P,.TCHAR	; ..
	PUSHJ	P,TYPSTR	;OUTPUT STRUCTURE
	SKIPN	FLDTA		;SEE IF NOT DECTAPE
	PUSHJ	P,UFDLSN	;OUTPUT DIRECTORY
	MOVEI	T1,[ASCIZ /.UFD/]
IFN FTSFD,<
	SKIPE	UFDPPN+2	;SEE IF SFD INCLUDED
	MOVEI	T1,[ASCIZ /.SFD/]
>
	SKIPE	FLDTA		;SEE IF DECTAPE
	MOVEI	T1,[ASCIZ / directory/]
	PUSHJ	P,.TSTRG	;SEND EXTENSION
	PJRST	.TCRLF		;END LINE AND RETURN
;DATERR -- ISSUE MESSAGE THAT ERROR IS IN A FILE
;CALL:	PUSHJ	P,DATERR
;USES T1

DATERR:	MOVEI	T1,[ASCIZ / file /]
	PUSH	P,T2		;SAVE AC
IFN FTSFD,<
	HLRZ	T2,FEXT		;CHECK EXTENSION FOR SFD
	CAIN	T2,'SFD'	; ..
	MOVEI	T1,[ASCIZ / directory /]
>
	PUSHJ	P,FILOUT	;OUTPUT FILE NAME AND EXTENSION
	POP	P,T2		;RESTORE AC
	PJRST	.TCRLF		;AND END LINE AND RETURN


;DODCHN -- ROUTINE TO INCLUDE THE DATA CHANNEL IN A UUO AND EXECUTE IT
;CALL:	PUSHJ	P,DODCHN
;	  UUO TO EXECUTE
;	    NON-SKIP POINT
;	SKIP POINT
;USES NO ACS

DODCHN:	PUSH	P,T1		;PRESERVE T1
	MOVE	T1,-1(P)	;GET UUO
	MOVE	T1,(T1)		;GET UUO
	AOS	-1(P)		;ADVANCE RETURN
	IOR	T1,AGDCHN	;INCLUDE DATA CHANNEL
	EXCH	T1,(P)		;RESTORE T1 SAVE UUO
	XCT	(P)		;DO THE UUO
	  JRST	.+2		;NON-SKIP
	AOS	-1(P)		;SKIP
	POP	P,(P)		;DISCARD UUO
	POPJ	P,		;RETURN
;FILOUT -- OUTPUT MESSAGE AND NAME OF FILE AND EXTENSION
;CALL:	MOVEI	T1,MESSAGE
;	PUSHJ	P,FILOUT
;USES T1, T2

FILOUT:	PUSHJ	P,.TSTRG	;TYPE PREFIX
	PUSHJ	P,TYPSTR	;OUTPUT DEVICE
	MOVE	T1,FNAM		;GET FILE NAME
	PUSHJ	P,.TSIXN##	;LIST IT
	HLLZ	T2,FEXT		;GET FILE EXTENSION
	MOVX	T1,FX.NUL	;SEE IF USER SPECIFIED NO EXT
	TDNE	T1,.FXMOD(P1)	; SEE IF HE GAVE .
	JUMPE	T2,FILOU1	;NO--SEE IF HE LEFT AS NULL
	MOVEI	T1,"."		;AND SEPARATOR
	PUSHJ	P,.TCHAR	;YES--TYPE SEPARATOR
	MOVE	T1,T2		;GET NAME
	PUSHJ	P,.TSIXN	;LIST EXTENSION
FILOU1:	PJRST	UFDLSN		;OUTPUT DIRECTORY AND RETURN



;DIRERR -- ISSUE DIRECTORY ERROR MESSAGE
;CALL:	MOVEI	T1,MESSAGE + D
;	PUSHJ	P,DIRERR
;USES T1

DIRERR:	PUSHJ	P,.TSTRG	;OUTPUT FIRST LETTER
	MOVEI	T1,[ASCIZ /irectory /]
	PUSHJ	P,STRER1	;OUTPUT DEVICE
				;FALL INTO UFDLSN


;UFDLSN -- ISSUE NAME OF DIRECTORY
;CALL:	PUSHJ	P,UFDLSN
;USES T1

UFDLSN:	PUSH	P,T3		;SAVE SOME ACS
	PUSH	P,T2		; ..
	MOVEI	T1,UFDPPN	;GET UFD NUMBER
IFN FTSFD,<
	TLO	T1,2		;INDICATE DOUBLE WORD PATH
>
	PUSHJ	P,.TDIRB##	;AND LIST IT
	POP	P,T2		;RESTORE THOSE ACS
	POP	P,T3		; ..
	POPJ	P,		;AND RETURN
;STRERR -- OUTPUT MESSAGE AND STRUCTURE NAME
;CALL:	MOVEI	T1,MESSAGE
;	PUSHJ	P,STRERR
;USES T1

STRERR:	PUSHJ	P,.TSTRG	;OUTPUT MESSAGE
	MOVEI	T1,[ASCIZ / on /]
STRER1:	PUSHJ	P,.TSTRG	;OUTPUT IDENTIFICATION
TYPSTR:	SKIPN	T1,FSTR		;GET DEVICE NAME
	POPJ	P,		;RETURN IF NULL
	PUSH	P,T2		;SAVE AC
	PUSHJ	P,.TSIXN	;OUTPUT IT
	POP	P,T2		;RESTORE AC
	MOVEI	T1,":"		;AND SEPARATOR
	PJRST	.TCHAR		; ..



;SETSYS -- SETUP DIRECTORY FOR SYS:
;CALL:	PUSHJ	P,SETSYS
;USES T1, T2

SETSYS:	MOVX	T1,%LDSYS	;GET LOCATION OF SYS:
	GETTAB	T1,		;FROM MONITOR
	  MOVE	T1,[1,,1]	;(LEV C)
SETPPN:	MOVE	T2,MFDPPN	;GET MFD
	CAMN	T2,.FXDIR(P1)	;SEE IF SAME
	JRST	SETPP1		;YES--GO DIDDLE NAME
	MOVEM	T1,.FXDIR(P1)	;AND OVERSTORE REQUEST
	SETOM	.FXDIM(P1)	;AND NO WILD DIRECTORY
IFN FTSFD,<
	SETZM	.FXDIR+2(P1)	;CLEAR SUB DIRECTORY
	SETZM	.FXDIM+2(P1)	; AND MASK
>
	POPJ	P,		;RETURN
SETPP1:	MOVEM	T1,.FXNAM(P1)	;STORE OVER NAME
	SETOM	.FXNMM(P1)	;CLEAR WILD CARD
	POPJ	P,		;RETURN
;DOPHYS -- PERFORM A LOGICAL OR PHYSICAL CALLI AS NEEDED
;CALL:	PUSHJ	P,DOPHYS
;	CALLI TO BE EXECUTED
;	CPOPJ RETURN POINT
;	SKIP RETURN POINT
;USES T1

DOPHYS:	MOVE	T1,(P)		;FETCH CALLI
	MOVE	T1,(T1)		; ..
	AOS	(P)		;ADVANCE RETURN POINT
	SKIPE	PHYS		;SEE IF PHYS I/O REQUESTED
	TRO	T1,UU.PHY	;YES--TURN ON PHYSICAL BIT
	XCT	T1		;DO THE CALLI
	POPJ	P,		;OK RETURN
CPOPJ1:	AOS	(P)		;SKIP
	POPJ	P,		;RETURN



;SETOPN -- SETUP OPEN BLOCK WORD 1 AND 2
;CALL:	PUSHJ	P,SETOPN
;RETURNS WITH T1, T2 SETUP, T3=0
;USES NO ACS

SETOPN:	SETZB	T1,T3		;OPEN MFD
	SKIPN	PHYS		;SEE IF PHYS I/O REQUESTED
	SKIPE	SRCH		;OR IF USING A SEARCH LIST
	TLO	T1,(UU.PHS)	;YES--SET FOR PHYS OPEN
	MOVE	T2,FSTR
	POPJ	P,		;RETURN


;.PTWRD -- STORE WORD IN USER PARAMETER AREA IF ROOM
;CALL:	MOVE	T1,LOCATION (WILL BE INCREMENTED BY ONE)
;	MOVE	T2,LENGTH TO GO (WILL BE DECREMENTED BY ONE)
;	MOVE	T3,DATA ITEM
;	PUSHJ	P,.PTWRD
;RETURNS WITH T1=T1+1, T2=T2-1, WORD STORED (OLD T1) IF OLD T2.GT.0

.PTWRD::SOSL	T2		;DECREMENT COUNT
	MOVEM	T3,(T1)		;STORE VALUE
	AOS	T1		;ADVANCE LOCATION
	POPJ	P,		;RETURN
	XLIST	;LITERALS
	LIT
	LIST
	RELOC

.WILDZ::!		;START OF LOW CORE AREA

FWAZER:!	;START OF TEMPORARIES (CLEARED EACH REQUEST)
		;THIS PARALLELS INPUT PARAMETER AREA
FSTR:	BLOCK	1		;CURRENT STRUCTURE
FNAM:	BLOCK	2		;CURRENT FILE NAME
FEXT:	BLOCK	1		;CURRENT FILE EXTENSION
MOD:	BLOCK	2		;CURRENT SWITCHES
UFDPPN:	BLOCK	2*.FXLND+2	;CURRENT DIRECTORY
ENDERR==.-1

FLDTA:	BLOCK	1		;FLAG THAT DISK DEVICE
NOTDSK:	BLOCK	1		;FLAG THAT NOT A DTA/DISK DEVICE
LASSTR:	BLOCK	1		;LAST STR FROM SEARCH UUOS
LASERR:	BLOCK	1		;LAST ERROR OF DIRECTORY NATURE
NOSTRS:	BLOCK	1		;NUMBER OF STRS IN SEARCH LIST
NOFILF:	BLOCK	1		;NUMBER OF FILES FOUND
NOFIL:	BLOCK	1		;NUMBER OF FILES LOOKED AT
NOUFDF:	BLOCK	1		;NUMBER OF UFDS FOUND
NOUFD:	BLOCK	1		;NUMBER OF UFDS LOOKED AT
NSUFD:	BLOCK	1		;NUMBER OF EXISTENT UFDS FOUND
DIRFLG:	BLOCK	1		;-1 IF THIS IS A DIRECTORY
.WLDFL::BLOCK	1		;FILE WILD FLAG (-1=WILD FILE, +1=WILD STR ONLY,
				;  0=NEITHER, -2 IF WILD FILE AND WILD STR)
STRMSK:	BLOCK	1		;MASK FOR MATCHING STRS
				;  BY NAME IF LT 0, BY DSKCHR IF GT 0
STRMTH:	BLOCK	1		;MATCH FOR ABOVE
UFDEF:	BLOCK	1		;FLAG THAT UFD ERROR WAS REPORTED
PHYS:	BLOCK	1		;FLAG TO FORCE PHYSICAL I/O
SRCH:	BLOCK	1		;FLAG FOR SEARCH LIST IN USE
SYSRCH:	BLOCK	1		;FLAG FOR SYSTEM SEARCH LIST IN USE
SY2RCH:	BLOCK	1		;FLAG FOR REAL SYS: SEARCH LIST
.WIFIR::BLOCK	1		;FIRST P1 IN LINKED SET
.WILAS::BLOCK	1		;LAST P1 IN LINKED SET
GOBST:	BLOCK	5		;GOBSTR PARAMETER AREA

IFN FTSFD,<
DIRB:	BLOCK	1		;BLOCK FOR DIRECTORY FOR SFD LOOKUPS
DIRBS:	BLOCK	1		; (SCANNING SWITCH)
DIRBU:	BLOCK	.FXLND		; (ACTUAL DIRECTORY LIST)
DIRBE:	BLOCK	1		;0 TO FORCE END
>
DEPTH:	BLOCK	1		;INDEX OF DIRECTORY DEPTH (0=MFD)
BUFCNT:	BLOCK	.FXLND+1	;COUNT DOWN OF FILES IN BLOCK
BUFPOS:	BLOCK	.FXLND+1	;INDEX IN BLOCK
DIRSTI:	BLOCK	.FXLND+1	;USETI IN DIRECTORY
.WLDBF::BLOCK	200		;BUFFER FOR READING DIRECTORIES
DVCH:	BLOCK	1		;LAST DEVICE CHARACTERISTICS
LWAZER==.-1	;END OF CLEARED AREA

MFDPPN:	BLOCK	1		;DIRECTORY FOR MFD
MYPPN:	BLOCK	1		;PPN OF THIS JOB

IFN FTSFD,<
PTHARG:	BLOCK	1		;ARGUMENT/FLAG FOR PATH UUO
PTHSCN:	BLOCK	1		;SCAN SWITCH FOR PATH UUO
PTHDIR:	BLOCK	.FXLND		;ACTUAL PATH
PTHEND:	BLOCK	1		;0 TO FORCE END
PTHLEN==.-PTHARG
>

AGLENL:	BLOCK	1	;LENGTH OF LOOKUP BLOCK
AGLENP:	BLOCK	1	;LENGTH OF PARAMETER AREAS FROM SCANER
AGLIMS:	BLOCK	1	;LOCATION OF LAST AREA FROM SCANER
AGLOOK:	BLOCK	1	;LOCATION OF LOOKUP BLOCK
AGOPEN:	BLOCK	1	;LOCATION OF OPEN BLOCK
AGPNTR:	BLOCK	1	;LOCATION OF INDEX TO SCANER AREAS
AGDCHN:	BLOCK	1	;DATA CHANNEL
AGFLAG:	BLOCK	1	;USER'S FLAGS

SAVEP1:	BLOCK	1	;STORAGE FOR USER'S P1


B.DC::	BLOCK	3		;DATA

.WILDL==:.-.WILDZ	;LENGTH OF LOW CORE AREA

	END
 W=X,