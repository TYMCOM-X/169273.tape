	$TOC	Initialization  Rex W. Shadrick  15-May-83


; Search a universal file

IFNDEF FT%BLD,<
	SEARCH	SYSUNV			; Some local macros >


; Define the version numbers

	$VRSN	SYS,7(370)		; Version number of SYSUNV
	$VRSN	TYP,7(263)		; Version number of TYPER
	$VRSN	EXT,1(3)		; Version number of external files


; Define the title

	$BEGIN	SYSUNV - System Macro Definitions,SYS,,<UNIVERSAL,BITS>


; Generate version numbers for those who care

	%%%SYS==:SYSVER			; The version number
	%%SYSU==SYS.VN			;  of SYSUNV

	%%%TYP==:TYPVER			; The version number
	%%TYPE==TYP.VN			;  of TYPER
	$TOC	Non-Disclaimer


;      The information in this software is  subject  to  change  without
; notice  and  should  not  be  construed  as  a  commitment  by Samurai
; Programming.  Samurai Programming assumes no  responsibility  for  any
; errors that may appear in this software.
;
;      No responsibility is  assumed  for  the  use  or  reliability  of
; software on equipment that is not supplied by Samurai Programming.
;
;
;
;      Copy on Write 1981, 1982, 1983 by Samurai Programming
	$TOC	Table of Contents


;		     	Table of Contents for SYSUNV
;
;				  Section			    Page
;
;    1. Initialization Rex W. Shadrick 15-May-83 . . . . . . . . . .   1
;    2. Non-Disclaimer . . . . . . . . . . . . . . . . . . . . . . .   2
;    3. History
;      3.1    Revisions  . . . . . . . . . . . . . . . . . . . . . .   6
;      3.2    Suggestions  . . . . . . . . . . . . . . . . . . . . .  22
;      3.3    Deficiencies . . . . . . . . . . . . . . . . . . . . .  23
;    4. Description of the Symbol Definitions  . . . . . . . . . . .  24
;    5. Miscellaneous Symbols
;      5.1    ASCII Characters . . . . . . . . . . . . . . . . . . .  25
;      5.2    Useful Symbols . . . . . . . . . . . . . . . . . . . .  26
;    6. Transfer of Control Macros
;      6.1    PFALL Description  . . . . . . . . . . . . . . . . . .  27
;      6.2    PFALL Macro  . . . . . . . . . . . . . . . . . . . . .  28
;      6.3    Useful OPDEFs  . . . . . . . . . . . . . . . . . . . .  29
;    7. Error Message Macro
;      7.1    $PRINT Description . . . . . . . . . . . . . . . . . .  30
;      7.2    $PRINT Macro . . . . . . . . . . . . . . . . . . . . .  31
;    8. Title/Version Macros
;      8.1    $VRSN Description  . . . . . . . . . . . . . . . . . .  32
;      8.2    $TITLE Description . . . . . . . . . . . . . . . . . .  34
;      8.3    $PASS Description  . . . . . . . . . . . . . . . . . .  35
;      8.4    $BEGIN Description . . . . . . . . . . . . . . . . . .  36
;      8.5    $VRSN Macro  . . . . . . . . . . . . . . . . . . . . .  38
;      8.6    $TITLE Macro . . . . . . . . . . . . . . . . . . . . .  39
;      8.7    $PASS Macro  . . . . . . . . . . . . . . . . . . . . .  40
;      8.8    $BEGIN Macro . . . . . . . . . . . . . . . . . . . . .  41
;    9. Listing Control Macros
;      9.1    $CONTINUE Macro  . . . . . . . . . . . . . . . . . . .  42
;      9.2    $LSTOF and $LSTON Macros . . . . . . . . . . . . . . .  43
;      9.3    $TOC Macro . . . . . . . . . . . . . . . . . . . . . .  44
;      9.4    $PURGE Macro . . . . . . . . . . . . . . . . . . . . .  45
;   10. Symbol Definition Macros
;     10.1    $SHOW, $ND, $INT, $EXT and $GLB Macros . . . . . . . .  46
;   11. Byte Manipulation Macros . . . . . . . . . . . . . . . . . .  47
	$TOC	Table of Contents (page 2)


;		     	Table of Contents for SYSUNV
;
;				  Section			    Page
;
;   12. Relocation Macros
;     12.1    $RELOCATION Description  . . . . . . . . . . . . . . .  48
;     12.2    $ABS Description . . . . . . . . . . . . . . . . . . .  50
;     12.3    $END Description . . . . . . . . . . . . . . . . . . .  51
;     12.4    $HIGH Description  . . . . . . . . . . . . . . . . . .  52
;     12.5    $LIT Description . . . . . . . . . . . . . . . . . . .  53
;     12.6    $LOW Description . . . . . . . . . . . . . . . . . . .  55
;     12.7    $PRGEND Description  . . . . . . . . . . . . . . . . .  56
;     12.8    $SECTION Description . . . . . . . . . . . . . . . . .  57
;     12.9    $VAR Description . . . . . . . . . . . . . . . . . . .  58
;     12.10   $RELOCATION Macro  . . . . . . . . . . . . . . . . . .  60
;     12.11   $ABS Macro . . . . . . . . . . . . . . . . . . . . . .  61
;     12.12   $END Macro . . . . . . . . . . . . . . . . . . . . . .  62
;     12.13   $HIGH Macro  . . . . . . . . . . . . . . . . . . . . .  63
;     12.14   $LIT Macro . . . . . . . . . . . . . . . . . . . . . .  64
;     12.15   $LOW Macro . . . . . . . . . . . . . . . . . . . . . .  65
;     12.16   $PRGEND Macro  . . . . . . . . . . . . . . . . . . . .  66
;     12.17   $SECTION Macro . . . . . . . . . . . . . . . . . . . .  67
;     12.18   $VAR Macro . . . . . . . . . . . . . . . . . . . . . .  68
;   13. Data Structure Macros
;     13.1    Descriptions . . . . . . . . . . . . . . . . . . . . .  69
;     13.2    The Macros . . . . . . . . . . . . . . . . . . . . . .  71
;   14. 'X' Macros
;     14.1    $FLAGS Description . . . . . . . . . . . . . . . . . .  73
;     14.2    $FLAGS, $FLAG and $VALUE Macros  . . . . . . . . . . .  74
;     14.3    MOVX Macro . . . . . . . . . . . . . . . . . . . . . .  76
;     14.4    CAX Macros . . . . . . . . . . . . . . . . . . . . . .  77
;     14.5    Integer Arithmetic Macros  . . . . . . . . . . . . . .  78
;     14.6    Floating-point Arithmetic Macros . . . . . . . . . . .  80
;     14.7    TX Macros  . . . . . . . . . . . . . . . . . . . . . .  81
;     14.8    ANDX, IORX, ORX and XORX Macros  . . . . . . . . . . .  84
;     14.9    $TY Macros . . . . . . . . . . . . . . . . . . . . . .  85
;   15. Stack Macros
;     15.1    $ERRET Description . . . . . . . . . . . . . . . . . .  86
;     15.2    $VARIABLE Description  . . . . . . . . . . . . . . . .  87
;     15.3    $FRAME Description . . . . . . . . . . . . . . . . . .  89
;     15.4    $LOCATE Description  . . . . . . . . . . . . . . . . .  93
;     15.5    $PARAMETER Description . . . . . . . . . . . . . . . .  94
;     15.6    $ERRET Macro . . . . . . . . . . . . . . . . . . . . .  95
;     15.7    $VARIABLE Macros . . . . . . . . . . . . . . . . . . .  96
;     15.8    $FRAME Macro . . . . . . . . . . . . . . . . . . . . . 103
;     15.9    $LOCATE Macro  . . . . . . . . . . . . . . . . . . . . 104
;     15.10   $PARAMETER Macro . . . . . . . . . . . . . . . . . . . 105
	$TOC	Table of Contents (page 3)


;		     	Table of Contents for SYSUNV
;
;				  Section			    Page
;
;   16. TYPER Macros
;     16.1    $BITS Description  . . . . . . . . . . . . . . . . . . 106
;     16.2    $BYTES Description . . . . . . . . . . . . . . . . . . 108
;     16.3    $ERROR Description . . . . . . . . . . . . . . . . . . 110
;     16.4    $NUMBER Description  . . . . . . . . . . . . . . . . . 111
;     16.5    $TYPE Description  . . . . . . . . . . . . . . . . . . 113
;     16.6    $TYPEB Description . . . . . . . . . . . . . . . . . . 117
;     16.7    $TYPED Description . . . . . . . . . . . . . . . . . . 118
;     16.8    $TYPER Description . . . . . . . . . . . . . . . . . . 120
;     16.9    $TYPES Description . . . . . . . . . . . . . . . . . . 121
;     16.10   TYPER Symbols  . . . . . . . . . . . . . . . . . . . . 130
;     16.11   $BITS Macro  . . . . . . . . . . . . . . . . . . . . . 134
;     16.12   $BYTES Macro . . . . . . . . . . . . . . . . . . . . . 135
;     16.13   $ERROR Macro . . . . . . . . . . . . . . . . . . . . . 136
;     16.14   $NUMBER Macro  . . . . . . . . . . . . . . . . . . . . 137
;     16.15   $TYPE Macro  . . . . . . . . . . . . . . . . . . . . . 138
;     16.16   $TYPEB Macro . . . . . . . . . . . . . . . . . . . . . 139
;     16.17   $TYPE1 Macro . . . . . . . . . . . . . . . . . . . . . 140
;     16.18   $TYPE2 Macro . . . . . . . . . . . . . . . . . . . . . 141
;     16.19   $TYPED Macro . . . . . . . . . . . . . . . . . . . . . 142
;     16.20   $TYPES Macro . . . . . . . . . . . . . . . . . . . . . 143
;   17. External String Macros
;     17.1    Definitions  . . . . . . . . . . . . . . . . . . . . . 144
;     17.2    The Macros . . . . . . . . . . . . . . . . . . . . . . 145
;   18. Hardware Bits
;     18.1    CPU Type Values  . . . . . . . . . . . . . . . . . . . 146
;     18.2    CPU Flags and Instruction Fields . . . . . . . . . . . 147
;     18.3    Number Fields  . . . . . . . . . . . . . . . . . . . . 148
;     18.4    EXTEND Instrucion Bits . . . . . . . . . . . . . . . . 149
;   19. Software Bits
;     19.1    TOPS-20 Only . . . . . . . . . . . . . . . . . . . . . 152
;   20. The End  . . . . . . . . . . . . . . . . . . . . . . . . . . 153
	$TOC	History -- Revisions


;		   Revision History of SYSUNV
;
; Edit    Date     Who                    Comment
;
;    1  15-Jun-76  DVB	Initial edit level.
;
;    2  19-Aug-76  DVB	Don't preserve AC 0 thru TYPER so user has an AC
;			available if needed for output.
;
;    3  19-Aug-76  DVB	Add  $CODE$ as name of program, user defines his
;			name as '$CODE$==SIXBIT/XXX/',  where  'XXX'  is
;			prefix on errors.
;
;    4  21-Aug-76  DVB	Clear  INFFLG  (the information flag) after use,
;			used to be cleared only on next header.
;
;    5  19-Jan-77  DRB	Fixed  some  code  which assumed arguments to be
;			passed in AC 1 rather than AC 'T1' as symbolicly
;			defined in the user's program.
;
;    6  22-Jan-77  DRB	Fix the mask at GTSB01.
;
;    7  04-Feb-77  DVB	Redefined  as  STCMAC.MAC,  added TITLE., VRSN.,
;			and relocation control  macros  ($RELOC,  $HIGH,
;			$LOW, $ABS and $LIT).
;
;   10  04-Feb-77  DVB	Add  'O'  prefix to TYPER for operator interven-
;			tion messages.
;
;   11  17-Jun-77  DRB	General  listing  cleanup,  convert  comments to
;			upper/lower case.
;
;   12  17-Jun-77  RWS	Change  the  TITLE. macro to $TITLE, because DEC
;			added a TITLE. macro to MACTEN.
;
;   13  21-Jun-77  RWS	Add  the $VRSN macro, used to set up the version
;			number stuff.
;
;   14  24-Jun-77  RWS	Add  the  $PRINT  macro which outputs a message,
;			then stops assembly if the message started  with
;			a '?'.
;
;   15  24-Jun-77  RWS	Rewrite  the $TITLE macro to allow two character
;			minor edits and a pass flag.
;
;   16  16-Aug-77  RWS	Add our local CALLI's (USRNM. and USRLG.).
;
;   17  15-Nov-77  RWS	Add  some new TYPER macros ($TYPE/$TYPER/$TYPES)
;			and redo the old TYPE$ macro.
;
;   20  29-Nov-77  RWS	Replace the relocation macros.
; Edit    Date     Who                    Comment
;
;   21  29-Nov-77  RWS	Add a fifth (5) argument to the $TITLE macro.
;
;   22  08-Dec-77  RWS	Make TYPER recursive.
;
;   23  15-Dec-77  RWS	More of edit 22 and some new features.
;
;   24  16-Dec-77  RWS	Allow DDT break-points on TYPER calls.
;
;   25  22-Dec-77  RWS	Make some minor improvements add support for the
;			macro listing feature.
;
;   26  27-Dec-77  RWS	Create  STCUNV  which is STCMAC minus the $TYPER
;			macro.
;
;   27  04-Jan-78  RWS	Add   some  new  features  to  the  $BIT  output
;			routine.
;
;   30  17-Jan-78  RWS	More of edit 22.
;
;   31  31-Jan-78  RWS	Do some general code clean up and remove the old
;			TYPE$ macro.
;
;   32  09-Feb-78  RWS	Change  the  OUT  function to $TYPES and do some
;			minor code changes.
;
;   33  12-Mar-78  RWS	Add  a  new  argument  to  the  $TYPE macro, the
;			output routine to use on this call.
;
;   34  19-Mar-78  RWS	Add  a  new substitution type ($NAM) and allow a
;			null text string in a $TYPE call ($HDR =  F,  I,
;			O or W).
;
;   35  18-Apr-78  DRB	Clean up some of the typo's.
;
;   36  27-Apr-78  RWS	To  add  a  new  macro  $PASS, which outputs the
;			program name, version  number  and  the  current
;			pass of the assembler, via PRINTX.
;
;   37  23-May-78  RWS	Add some STC locals symbols.
;
;   40  24-May-78  RWS	Allow indexed XCT's on TYPER calls.
;
;   41  31-May-78  RWS	Change  $FUN such that 1B0 is used instead of -1
;			in the left half to  specify  an  ASCIZ  string.
;			This  allows  'EOF'  and  'EOL'  to be output as
;			'Funny' characters.
; Edit    Date     Who                    Comment
;
;   42  16-Jun-78  RWS	Create STCBLD (a subset of STCMAC), which can be
;			used to create STCUNV from scratch.  Example:
;			  .R MACRO
;			  *=STCBLD,STCMAC
;			  .R MACRO		!Build the real UNV's
;			  *,STCUNV/C=STCUNV,STCMAC
;			  *,STCMAC/C=STCMAC
;
;   43  05-Jul-78  RWS	Change  the $FUN and $NAM output routines to the
;			calculate  effective  address  before  the  byte
;			pointer stuff is put into the left half.
;
;   44  10-Jul-78  RWS	Do some minor code clean up.
;
;   45  09-Aug-78  RWS	Add 'M' prefix to TYPER for operator information
;			messages.  Note:  These messages  don't  require
;			operator intervention.
;
;   46  09-Aug-78  RWS	Rewrite  the $TITLE macro using a new feature of
;			MACRO %53.
;
;   47  16-Aug-78  DRB	Clean  up  some  more  typo's,  with the help of
;			SPELL.
;
;   50  16-Aug-78  RWS	Add a new FACT file entry code for REATTAches.
;
;   51  01-Sep-78  RWS	Don't print time stamps on internal $TYPE calls.
;
;   52  06-Sep-78  RWS	Add  the  save  AC  routines, .SAVEx, in SCAN to
;			TYPER.
;
;   53  06-Sep-78  RWS	Add  support  to  output 'X for lower case char-
;			acters in a $FUN ASCIZ string.
;
;   54  08-Sep-78  RWS	Add  the  'N1' return type to $TYPE, which skips
;			the following instruction.
;
;   55  08-Sep-78  RWS	Convert   .TCHAR  to  use  OUTSTR's  instead  of
;			OUTCHR's, this feature is about 60% faster.
;
;   56  13-Sep-78  RWS	Add  ERR  function  to  $TYPES,  which adds 1 to
;			.JBERR on all fatal errors.
;
;   57  13-Sep-78  RWS	Allow the $RUN substitution, in TYPER, to output
;			parts of a second.
;
;   60  19-Sep-78  RWS	Add  $DTL  substitution,  which  outputs date as
;			'Month day, year', and $TML substitution,  which
;			output time as 'hh:mm a.m./p.m.'.
;
;   61  22-Sep-78  RWS	Change  STCMAC/STCUNV's  version number to 2 and
;			TYPER's version number to 4.
; Edit    Date     Who                    Comment
;
;   62  22-Sep-78  RWS	Remove  the  delimiter  character from the $TYPE
;			macro and make  the  delimiter  character  be  a
;			vertical bar (|).
;
;   63  26-Sep-78  RWS	Remove  the  $DTN,  $DYN  and  $TMN substitution
;			types and change the $DAT, $DAY and $TIM substi-
;			tution  types  to  allow  the user to output the
;			current date, day and time.
;
;   64  28-Sep-78  RWS	Make   the   .SAVEx  routines  be  conditionally
;			assembled if SCAN isn't being used.
;
;   65  28-Sep-78  RWS	Add the PFALL macro, which is used at the end of
;			a routine that is to  fall  into  the  following
;			routine.
;
;   66  29-Sep-78  RWS	Remove the RST function from $TYPES and make the
;			SAV function save the data on the stack.
;
;   67  04-Oct-78  RWS	Add  the $ERR substitution type, which outputs a
;			file LOOKUP/ENTER error  message  and  the  file
;			name.
;
;   70  06-Oct-78  RWS	Add  a comma (TF.COM) as a separater to the $BIT
;			substitution.
;
;   71  09-Oct-78  RWS	Change  the  return  routines  to  use  SCAN  if
;			loaded.   The  new   return  routines  work   as
;			follows:
;			  C - Do a monitor return (.MONRT) followed by a
;			       POPJ on a continue.
;			  D - Enter DDT if present else the same as an M
;			       return.
;			  E - Process  the  /RUN  or  /EXIT  (.RUNCM) if
;			       given, then do a monitor return  (.MONRT)
;			       followed by an EXIT on a continue.
;			  M - Do  a  monitor return (.MONRT) followed by
;			       an EXIT on a continue.
;
;   72  09-Oct-78  RWS	Add  'C'  prefix  to  TYPER  for  a continuation
;			message and support for the error message stand-
;			ard (prefix, first-line and continuation).
;
;   73  11-Oct-78  RWS	Add  support for left justified protection codes
;			in the $PRO substitution routine.
;
;   74  12-Oct-78  RWS	Allow  $ENT,  $ERR  and  $LKP  substitutions  to
;			accept a .FILOP block pointer.
; Edit    Date     Who                    Comment
;
;   75	17-Oct-78  DRB	Fix  a bug in the new '$TYPES SAV' routine which
;			implicitly calls the restore code on a 'POPJ P,'
;			or  '.POPJ1'.   The  wrong  item on the stack is
;			being adjusted for non-skip return.
;
;   76  23-Oct-78  RWS	The  $LIN  substitution now has a parameter, the
;			number of CR-LF's to output  or  if  negative  a
;			form-feed.
;
;   77  25-Oct-78  RWS	Add  $SKP  and  $EOS  substitutions,  which will
;			conditionally suppress output on a $TYPE call.
;
;  100  26-Oct-78  RWS	Allow  the user to specify an optional substitu-
;			tion character in the $TYPER macro.
;
;  101  26-Oct-78  RWS	Change  STCMAC/STCUNV and TYPER's version number
;			to 5.
;
;  102  01-Nov-78  RWS	Fix  a  bug  if SCAN isn't being used in $TYPER,
;			you can't send the MOVX macro a '<' or a '>'.
;
;  103  16-Nov-78  RWS	Allow  $ASC,  $FUN  and  $SUB  to specify a byte
;			pointer and an effective address.
;
;  104  16-Nov-78  RWS	Add  a  new  output  type  (BYTE) to the $NUMBER
;			macro, the address contains a  byte  pointer  to
;			a byte to be output as an unsigned integer.
;
;  105  20-Nov-78  RWS	More of edit 103.
;
;  106  29-Nov-78  RWS	Do some general code clean up.
;
;  107  07-Dec-78  RWS	More  of  edit  72,  forgot to implement the MSG
;			function in the $TYPES call.
;
;  110  03-Jan-79  RWS	Allow the substitution parameters to be supplied
;			in the $TYPE call.
;
;  111  17-Jan-79  RWS	Add  'A'  (Abort) return type, which outputs the
;			PC of the $TYPE call before it does a 'D'  (DDT)
;			return.
;
;  112  17-Jan-79  RWS	Don't  output  time  stamps  on 'D' (DDT) return
;			type.
;
;  113  13-Mar-79  RWS	Make   the   abort  message  be  output  to  the
;			terminal.
;
;  114  05-Apr-79  RWS	Allow  the  macros, variable name(s), created by
;			the $VARIABLE macro to have  offsets  after  the
;			macro name.
; Edit    Date     Who                    Comment
;
;  115  05-Apr-79  RWS	Add  support  for the KL20, KS10 and KS20 in the
;			$FRAME macro.
;
;  116  06-Apr-79  RWS	Start adding T0 support and do some general
;			code clean up.
;
;  117  12-Apr-79  RWS	Add  the $JFN substitution type, which outputs a
;			TOPS-20 file specification.
;
;  120  26-Apr-79  RWS	Convert  to use the IFDIFX and IFIDNX psuedo-OPs
;			in MACRO (a local patch).
;
;  121  21-May-79  RWS	More  of  edit  116, the dates and times are in-
;			correct (due to time zones).
;
;  122  23-May-79  RWS	Add  the ZON function to $TYPES, allows the user
;			to specify the time zone for the $TML  substitu-
;			tion.
;
;  123  23-May-79  RWS	If  time stamps are being output and a prompt is
;			requested you get 2 time stamps.
;
;  124  12-Jun-79  RWS	In  the  expansion of TYPER search UUOSYM and/or
;			SCNMAC if %%UUOS and/or %%SCNM are not defined.
;
;  125  12-Jun-79  RWS	Add  a "+" (TF.PLS), nothing output (TF.NON) and
;			"!" (TF.XCL) as a separater to the $BIT  substi-
;			tution.
;
;  126  14-Jun-79  RWS	Add the $ERS substitution type, which outputs an
;			error string.
;
;  127  14-Jun-79  RWS	Change $VRSN so that it doesn't require VRSN.
;
;  130  14-Jun-79  RWS	Add the .GTNOW routine to TYPER.
;
;  131  19-Jun-79  RWS	Add  the  PC  to  the output message if the user
;			specified a SCAN return and not using SCAN.
;
;  132  19-Jun-79  RWS	Add  most  of the useful macros and symbols from
;			MACTEN,  changing  the  names  on  most  of  the
;			macros.
;
;  133  19-Jun-79  RWS	Remove the STC specific code.
;
;  134  19-Jun-79  RWS	Change the name from STCxxx to SYSxxx, the names
;			were changed the protect the guilty.
;
;  135  20-Jun-79  RWS	Add  the $BITS macro to build the $BIT substitu-
;			tion type output block.
; Edit    Date     Who                    Comment
;
;  136  28-Jun-79  RWS	Add  the $ROM substitution type, which outputs a
;			Roman numeral.
;
;  137  28-Jun-79  RWS	Add the $ALP substitution type, which outputs an
;			alpha number (1-A, ... 26-Z, 27-AA, ...).
;
;  140  05-Jul-79  RWS	Increase the size of the frame block to 2047.
;
;  141  10-Jul-79  RWS	Rewrite the $VARIABLE and $FRAME macros.
;
;  142  20-Jul-79  RWS	Add support for floating-point output.
;
;  143  24-Jul-79  RWS	Add some routines to save T1-4.
;
;  144  30-Jul-79  RWS	Improve  the  PDL  overflow  tests in the $FRAME
;			macro code.
;
;  145  01-Aug-79  RWS	Define  the $SETUP macro which will set up a few
;			things for the user.
;
;  146  06-Aug-79  RWS	Remove  the  SYSMAC  conditionals and the $TYPER
;			macro.  TYPER is now stand-alone.
;
;  ***  06-AUG-79  RWS	The first field test release of SYSUNV/TYPER.
;
;  147  29-Aug-79  RWS	The  TX  and MOVX macros aren't putting the mask
;			symbols in the CREF listing.
;
;  150  29-Aug-79  RWS	Move some symbols out of SYSUNV and into TYPER.
;
;  151  30-Aug-79  DRB	The  $NUMBER macro didn't set the correct symbol
;			when the keyword of BLANK was given.
;
;  152  05-Sep-79  RWS	Add some EXTEND instruction symbols.
;
;  153  05-Sep-79  RWS	Correct one of the time zone symbols.
;
;  154  18-Sep-79  RWS	Add two new options (listing and segment) to the
;			$LIT and $VAR macros.
;
;  155  20-Sep-79  RWS	Fix  a  bug  in  the  ADDX/SUBX macros, then the
;			value being added/subtracted is -1000000.
;
;  156  03-Oct-79  DRB	Add  the  $PIC  substitution (to $TYPE), the PIC
;			function (to $TYPES) and the $PICTURE macro.
;
;  157  12-Oct-79  JMS	Fix  the  frame  alloction  code for a KA-10, it
;			didn't  handle  the  stack  overflow   condition
;			correctly.
; Edit    Date     Who                    Comment
;
;  160  26-Oct-79  RWS	Fix  the  STORE  macro,  it  would  cause  phase
;			errors if  the  $LST  parameter  was  used,  but
;			wasn't defined until pass 2.
;
;  161  01-Nov-79  RWS	Add some symbols for day of the week and time of
;			the day.
;
;  162  03-Jan-80  RWS	Add a mask to the $FLAGS macro.
;
;  163  17-Jan-80  RWS	Rewrite  the  $NUMBER  macro and remove the $ALP
;			and $ROM substitutions, they  have  been  imple-
;			mented in the $NUMBER macro.
;
;  164  22-Jan-80  RWS	Remove  the TYPER substitution type $PIC and the
;			$PICTURE macro (incorporate it into the  $NUMBER
;			macro).
;
;  165  02-Apr-80  RWS	Add  a  [NO]VERSION  flag  to  the $SETUP macro,
;			which will put the version  number  in  location
;			137.
;
;  166  11-Apr-80  RWS	Add  the  $XCT  substitution type, which does an
;			indirect substitution.
;
;  167  17-Apr-80  RWS	Add  the  $VALUE macro, which is used in conjuc-
;			tion with the $FLAG macro.
;
;  ***  17-Apr-80  RWS	Change the major version number to 6.
;
;  170  28-Apr-80  RWS	Request   TYP6N/S.REL   instead  of  TYP5N/S.REL
;			inside the $SETUP macro.
;
;  171  02-May-80  RWS	Start adding PSECT support to the $RELOC marco.
;
;  172  15-May-80  RWS	Allow  the  user  to  specify an optional return
;			optional return address on a $TYPES BUG.
;
;  173  15-May-80  RWS	Support  external  symbols  in  the  MOVX and TX
;			macros.
;
;  174  16-May-80  RWS	Add a $SHOW macro.
;
;  175  21-May-80  RWS	Make VERSION be the default in the $SETUP macro,
;			if the  $END/$PRGEND  macro  is  called  with  a
;			starting address.
;
;  176  24-May-80  RWS	Load HELPER by default when SCAN is loaded.
;
;  177  31-May-80  RWS	Make  the  SYSBLD  feature (used to build SYSUNV
;			from scratch) work again.
; Edit    Date     Who                    Comment
;
;  200  15-Sep-80  RWS	Modify  the  $NUMBER  macro  to  support the new
;			floating-number output code.
;
;  201  22-Oct-80  RWS	Allow $BITS to output the bit number (1B35).
;
;  202  12-Nov-80  RWS	Add  the $DIR and $USR substitution types, which
;			are the identical and output a user or directory
;			name.
;
;  203  14-Nov-80  RWS	Add  the  $ERROR macro which is identical to the
;			$TYPE macro, except an 'ERCAL @[...]' is  gener-
;			ated instead of a PUSHJ P,@[...] on TOPS-20.
;
;  204  14-Nov-80  RWS	Have  the  $ND  macro  put the value used in the
;			listing for those that care.
;
;  205  16-Nov-80  RWS	Change  the  $VARIABLE  macro  such  that if the
;			lenth of a variable is zero no symbol (macro) is
;			generated.
;
;  206  16-Nov-80  RWS	Once  again  replace  the relocation macro, this
;			time to finish adding PSECT support.
;
;  207  23-Nov-80  RWS	Add  support for the IOSEC and JSYS stuff to the
;			$SETUP macro.
;
;  210  25-Nov-80  RWS	Change  the  EXTERN from TYPPIC to .TYPIC in the
;			$TYPE and $TYPES macros.
;
;  211  26-Nov-80  RWS	Add the new data structure macros.
;
;  212  02-Dec-80  DRB	Another iteration of the $ND macro.
;
;  213  02-Dec-80  JMS	Fix  the  $PARAMETER macro to correctly find the
;			instruction on the DDT break-point, change  from
;			+2 to -1.
;
;  214  03-Dec-80  RWS	Fix a bug in the relocation marcos.  When creat-
;			ing PSECT'ed code,  the  data  and/or  code  was
;			being  placed in the absolute segment instead of
;			the low segment.
;
;  215  03-Dec-80  RWS	The $END and $PRGEND macros didn't define SU$ADR
;			if section code was being generated.
;
;  216  08-Dec-80  RWS	Have  the  $PARAM  macro calculate the effective
;			address of the call, excluding the indirect bit.
;
;  217  08-Dec-80  RWS	Finish  converting  over  to  the data structure
;			macros.
; Edit    Date     Who                    Comment
;
;  220  08-Dec-80  RWS	Add  the BAS function to $TYPES, allows the user
;			to change databases.
;
;  221  12-Dec-80  RWS	Change  the  MSG  function  (of  $TYPES)  to VRB
;			(verbosity) and add a new  MSG  function,  which
;			sets the message level.
;
;  222  15-Dec-80  RWS	Request  SCANER  instead  of  JSYS in the $SETUP
;			macro.
;
;  223  15-Dec-80  RWS	Add  message  level  support  to  the $ERROR and
;			$TYPE macros.
;
;  224  15-Dec-80  RWS	Add  support  for  the  database  address in the
;			$ERROR and $TYPE macros.
;
;  225  15-Dec-80  RWS	Add  the  EMP  function  ($TYPES), which is used
;			specify the routine to empty the buffer.
;
;  226  16-Dec-80  RWS	Make   the   $SETUP  macro  request  TYP7N/S.REL
;			instead of TYP6N/S.REL.
;
;  227  19-Dec-80  RWS	Add  the  $TYPED macro, which sets up a database
;			for TYPER.
;
;  230  23-Dec-80  RWS	Add support for the TYPER error database.
;
;  231  05-Jan-81  RWS	Don't  generate  a  label  on  an $ERROR call if
;			ERCAL is defined.
;
;  232  10-Feb-81  RWS	Allow the same return types from $TYPES as there
;			are in the $ERROR and $TYPE macros.
;
;  233  13-Feb-81  RWS	Add support for the TYPER database, internal use
;			only.
;
;  234  16-Feb-81  RWS	Add  'B'  prefix  to the $ERROR and $TYPE macro,
;			like the 'T' prefix except a blank is output.
;
;  ***  16-Feb-81  RWS	Change the version number to 7.
;
;  235  23-Feb-81  DRB	More  of  edit 223, test the correct symbol when
;			seeing if the message level is defined.
;
;  236  23-Feb-81  RWS	Add  the  BINARY  and  NOBINARY  options  to the
;			$SETUP macro, which  are  used  to  control  the
;			generation of a REL file.
;
;  237  23-Feb-81  RWS	Add  the VER function ($TYPED and $TYPES), which
;			is used to specify vertical justification.
;
;  240  23-FEB-81  RWS	Change the $CONTINUE macro a little.
; Edit    Date     Who                    Comment
;
;  241  09-Mar-81  RWS	Add  some offsets for the vertical justification
;			table to be supplied on  the  $TYPES  VER  macro
;			call.
;
;  242  15-May-81  RWS	Don't  allow  an  argument to be supplied to the
;			stack variables created by the  $VARIABLE  macro
;			if the size is 1.
;
;  243  20-May-81  RWS	More  of  edit  242,  forgot  that  local  stack
;			variables use register 17, not 16, as the  index
;			register.
;
;  244  02-Jun-81  RWS	Change  the  $SETUP  macro so it searches SCNPRM
;			before MONSYM and loads SCANER before TYPER.
;
;  245  03-Jun-81  RWS	Update  the  $TYPES  BAS  symbols to add .TFINI,
;			used to initialize a database.
;
;  246  03-Jun-81  RWS	Allow  the  argument  address to be specified in
; 			the $TYPES call, this would allow  the  argument
;			to  be  supplied  in  and returned to some place
;			other than T1.
;
;  247  04-Jun-81  RWS	Update  the  $TYPES  VRB  symbols to add %TFWAD,
;			used to output the address of the message.
;
;  250  04-Jun-81  RWS	Add the $OPC substitution type, which is used to
;			output a PC.
;
;  251  05-Jun-81  RWS	Add the new $JFN substitution output flags.
;
;  252  26-Jun-81  RWS	More  of  edit  203, the $PARAM macro didn't for
;			for JUMP opcode (ERCAL).
;
;  253  29-Jun-81  RWS	Replace  the  $DSBEG  and $DSFLG macros, because
;			several new features were added.
;
;  254  01-Jul-81  RWS	Allow a feature test flag for the list variables
;			defined by the $VARIABLE macro.
;
;  255  15-Jul-81  RWS	Allow  an  I return from $ERROR, $TYPE or $TYPES
;			macro, which is a return from interrupt.
;
;  256  15-Jul-81  RWS	Allow INTERRUPT variables to $VARIABLE, which is
;			the same as SAVE except on a POPJ  a  DEBRK.  or
;			DEBRK% is executed.
;
;  257  20-Jul-81  RWS	More  of  edit  256,  make the $FRAME macro also
;			support INTERRUPT variables.
;
;  260  30-Jul-81  RWS	More  of  edit 256, forgot the change the $FRAME
;			entry point for LOCAL variables.
; Edit    Date     Who                    Comment
;
;  261  30-Jul-81  RWS	Have  the  $PRINT  macro  output  an  'A'  error
;			during pass 2 on a fatal error.
;
;  262  30-Jul-81  RWS	Make sure the set subfunction (.TFSET) of $TYPES
;			BAS is zero.
;
;  263  30-Jul-81  RWS	Start adding support for external ASCIZ strings.
;
;  264  30-Jul-81  RWS	Change the name of the $SETUP macro to $BEGIN.
;
;  265  03-Aug-81  RWS	Add support to add external string files, $TYPES
;			(EXT).
;
;  266  04-Aug-81  RWS	Add  support  to change the error string number,
;			$TYPES (ESN).
;
;  267  07-Aug-81  RWS	Allow  the  user  to  supply  the database to be
;			modified on this $TYPES call.
;
;  270  12-Aug-81  RWS	Have  the  $BEGIN macro store the version number
;			in bytes.
;
;  271  13-Aug-81  RWS	Make  some changes to the data structure macros;
;			add the $DSBYT and $DSSKP macros, and add a $TST
;			argument to most of the other macros.
;
;  272  16-Aug-81  RWS	Change  $BEGIN  to add a SEARCH flag, which will
;			search user supplied universals, and output  the
;			keyword  'program'  or  'universal'  on the pass
;			stuff.
;
;  273  16-Aug-81  RWS	Add  external  string  ($ES)  macros  and  add a
;			STRINGS flag to the $BEGIN macro.
;
;  274  18-Aug-81  RWS	Convert  to  the  latest  macro  listing option,
;			$BEGIN only.
;
;  275  19-Aug-81  RWS	More  of  edit  267,  didn't  define .TSBSA on a
;			jump return.
;
;  276  19-Aug-81  RWS	More  of  edit  267, referenced the wrong symbol
;			(.TRLOC) on a jump return.
;
;  277  19-Aug-81  RWS	The $TYPES BUG data can be reduced by one word.
;
;  300  24-Aug-81  RWS	Supply a preable in external string files, which
;			contains the version number and range  of  valid
;			string numbers.
;
;  301  26-Aug-81  RWS	Add the 'Non-Disclaimer' page.
;
;  ***  26-Aug-81  RWS	Release the current copy of SYSUNV on the world.
; Edit    Date     Who                    Comment
;
;  302  26-Aug-81  RWS	Allow  message  type N ($ERROR or $TYPE) to have
;			a suffix so they  can  be  specified  later  via
;			$TYPE (N,xxx).
;
;  303  26-Aug-81  RWS	Add the $TOC macro.
;
;  304  27-Aug-81  RWS	More  of  edit  303,  need  to suppress the $TOC
;			macro from the CREF listing or else the  listing
;			isn't correct.
;
;  305  16-Sep-81  RWS	Add  support  to  do  space compression (convert
;			spaces to tabs), $TYPES (CMP).
;
;  306  17-Sep-81  RWS	Change .TFSET to .TFUSE, to avoid conflicts with
;			UUOSYM.
;
;  307  15-Oct-81  RWS	Add the symbol .BEMON which is the monitor type,
;			as setup by $BEGIN.
;
;  310  20-Oct-81  RWS	Add  the  SPACE option to the $BITS macro, which
;			is used to output a space bewteen the messages.
;
;  311  21-Oct-81  RWS	Add  the  $TYPER  OPDEF  which is used to return
;			from DDT after a TYPER call entered DDT.
;
;  312  21-Oct-81  RWS	Fix  a  bug in the $MOVE and $MOVEM macros, base
;			displacement was being added in.
;
;  313  21-Oct-81  RWS	If the user sends to many arguments to the $TYPE
;			complain.
;
;  314  23-Oct-81  RWS	Change  the  $PARAM macro to meet the new SYSUNV
;			calling standard.
;
;  315  23-Oct-81  RWS	Change  the  $TYPE  macro  to conform to the new
;			SYSUNV calling standard.
;
;  316  30-Oct-81  RWS	Allow $DSBYT to be given the keywords, HALF (18)
;			and WORD (36).
;
;  317  30-Oct-81  RWS	Allow $DSFLG to be given the keyword DOUBLE.
;
;  320  30-Oct-81  RWS	Make  $MOVE  and  $MOVEM  understand double word
;			quantities.
;
;  321  30-Oct-81  RWS	Add the $SKT substitution, suppress if TRUE.
;
;  322  03-Nov-81  RWS	Add   the  $TYPEB  macro,  which  generates  the
;			contents of the $ERROR/$TYPE argument block.
;
;  323  03-Nov-81  RWS	Allow the user to create variables that point to
;			the saved ACs within a frame on the stack.
; Edit    Date     Who                    Comment
;
;  324  03-Nov-81  RWS	Suppress the TYPER labels from DDT typeout.
;
;  325  04-Nov-81  RWS	Fix  a  minor  bug  in  $DSBEG,  not enough <>'s
;			around the $SYM parameter.
;
;  326  04-Nov-81  RWS	More  of  edit  324, make the $POINT, $FILIN and
;			$ALIGN macros accept half word arguemnts.
;
;  327  04-Nov-81  RWS	Add  the  ENTRY  flag  to  $BEGIN, which is used
;			define entry points.
;
;  330  12-Nov-81  RWS	Add  some  more angle brackets, this time to the
;			$FLAGS macros.
;
;  331	12-Nov-81  RWS	Improve edit 306, instead of defining the symbol
;			.BEMON define the macro $TOPS, which  equals  10
;			or 20.
;
;  332  12-Nov-81  RWS	Add the MACSYM and MACTEM flags to $BEGIN, which
;			is used to search MACSYM and request MACSYM,  or
;			search MACTEN.
;
;  333  12-Nov-81  RWS	Add  the BITS flag to $BEGIN, which defines some
;			bit symbols (B0, B1, ... B35).
;
;  334  12-Nov-81  RWS	Add  the MULTILINE flag to $BEGIN, whick is used
;			to suppress the multiline expansions.
;
;  335  03-Dec-81  RWS	Add a pass print option to the $PRINT macro.
;
;  336  17-Jan-82  RWS	Fix a bug in the $DSBYT.
;
;  337  10-Mar-82  RWS	Allow $BEGIN to automatically turn on the BINARY
;			flag for $PRGENDed universal files.
;
;  340  12-May-82  RWS	$DSGEN  didn't  always  handle single word moves
;			correctly.
;
;  341  16-May-82  RWS	Do  some  minor  enhancements  in  the  external
;			string support.
;
;  342  16-May-82  RWS	Allow the user to just create stack variables.
;
;  343  18-Jun-82  RWS	Allow  continuation  messages  to  start  in the
;			middle of  a  non-continuation  message,  header
;			type other that C.
;
;  344  18-Jun-82  RWS	Define   a   mask   of  the  available  software
;			interrupt channels on TOPS-20.
;
;  345  21-Jun-82  RWS	Define some CPU type constants.
; Edit    Date     Who                    Comment
;
;  346  07-Jul-82  RMP	Add  a  macro  ($PURGE)  to  delete  the created
;			symbols and have $END and $PRGEND call it.
;
;  347  25-Oct-82  RWS	Fill  in  the  external string ranges defined by
;			the $ESEND macro.
;
;  350  25-Oct-82  RWS	Put  the  version  number of the external string
;			file format in  the  preamble  of  the  external
;			string file.
;
;  351  31-Oct-82  RWS	Put  the  address of the display database in the
;			TYPER database.
;
;  352  22-Dec-82  RWS	Add some offsets for the entry vector.
;
;  353  01-Jan-83  RWS	Allow  bit  definitions  created by $DSBIT to be
;			relative to the byte specified.
;
;  354  01-Jan-83  RWS	Allow values and bits to be defined for one word
;			quantities, $DSWRD.
;
;  355  01-Jan-83  RWS	Add the $BYTES macro, which sets up the argument
;			block for the $BYT TYPER substitution.
;
;  356  03-Jan-83  RWS	Change  the  name  of  the  symbols  used in the
;			external string file preamble.
;
;  357  16-Jan-83  RWS	The  $USR substitution is now different that the
;			$DIR substitution, so assign $USR is own OPDEF.
;
;  360  17-Jan-83  RWS	Implement  the  maximum  feature in the external
;			string macros ($ESBEG).
;
;  361  18-Jan-83  RWS	Add a new error code returned by $TYPES (EXT).
;
;  362  24-Jan-83  RWS	Create  the OPDEF's $ERCAL [JUMP 17,] and $ERJMP
;			[JUMP 16,].  These OFDEF's are the same as ERCAL
;			ERJMP for the TOPS-20 programmers.
;
;  363  24-Jan-83  RWS	Allow  $FRAME to handle $ERCAL and $ERJMP at the
;			return address.
;
;  364  24-Jan-83  RWS	Add  the  $ERRET macro, which will set a flag so
;			the frame deallocation routines know whether  or
;			not  to  test  for  an  error  return ($ERCAL or
;			$ERJMP).
;
;  365  24-Jan-83  RWS	Change  the  $ERROR macro to use $ERCAL on both
;			flavors of the 'Total Operating System' (TOPS).
;
;  366  29-Jan-83  RWS	Banks'ize the comments.
; Edit    Date     Who                    Comment
;
;  367  03-Feb-83  RWS	Get  the  opcode  at  the  return  address when
;			testing for  an  error  return  in  the  $FRAME
;			macro.
;
;  370  15-May-83  RWS	Do a little clean before leaving EE.
;
;[CSM]	10-Oct-82  JMS	Remove DDT symbol conflicts with PJRST etc.
;
;[CSM]	10-Oct-82  JMS	Add ND and CONT. macros so that an unmodified
;			SCNMAC.UNV can be used with SYSUNV.
;
;[CSM]  10-Jun-83  JMS	Fix $FLAG so that value shows up in listing.
;
;[CSM]	10-Jun-83  JMS	Don't PRINTX from $BEGIN on PASS1
;
;[CSM]	13-Jun-83  JMS	Fix $DSFLG and such to show up in the listing.

;		*** The End of the Revision History ***
	$TOC	History -- Suggestions


;		Suggestion History for SYSUNV
;
; Number    Date    Who			Comment
;
;    1* 26-Nov-80  GEB	Get  the  final  mask  from $DSEND, so it can be
;			passed to the $DSBEG macro,  so  tightly  linked
;			data structures can be appended together.
;
;    2* 26-Nov-80  GEB	Give the $DSBEG a starting offset.
;
;    3  26-Nov-80  RWS	A macro to set zeros or ones to a flag in a data
;			structure.
;
;    4  26-Nov-80  RWS	A macro to clear a data structure.
;
;    5  26-Nov-80  RWS	Create  a  macro  to  BLT  sections  of  a  data
;			structure around.
;
;    6* 20-Jul-81  RWS	Allow $TST on $DSBEG and $DSNXT macros.
;
;    7  27-Jul-81  DVB	Turn off the CREF information during most of the
;			macros
;
;   10* 27-Jul-81  DVB	Cause  an  'A' error to appear in the listing if
;			an error is encountered.
;
;   11* 29-Jul-81  RWS	Allow the $TYPES macro to specify which database
;			is to be modified.
;
;   12  04-Feb-83  RWS	Add macro to create the version number word.
;
;   13* 10-Jun-83  JMS	Make $FLAG definitions show up in the listing.
;
;   14* 10-Jun-83  JMS	Make PJRST distinct from JRST for DDT.
;
;   15* 10-Jun-83  JMS	Define ND, WID, POS, etc for unmodified SCNMAC.
;
;   16* 10-Jun-83  JMS	Change $BEGIN to not waste a page on pass 1.
;
;   17* 13-Jun-83  JMS	Make $DSFLG etc show values in CREF listing.

;     * - Implemented features.
;
;		*** The End of the Suggestion History ***
	$TOC	History -- Deficiencies


;		Deficiency History of SYSUNV
;
; Number   Date    Who                 Comment
;
;    1  20-Jul-81  RWS	The  length of a data structure may be incorrect
;			if redefined.
;
;    2  01-Nov-82  DRB	If an information message is interrupted  before
;			it  completes and another information message is
;			using the  same  data-base  only  the  interrupt
;			level message gets a "]".
;
;     * - No longer a deficiency.
;
;		*** The End of the Deficiency History ***


;Address:
;	Rex Shadrick
;	SOHIO Petroleum Company
;	5400 LBJ Freeway
;	1 Lincoln Centre
;	Suite 1200 / LB25
;	Dallas, TX  75240
;	(214) 960-4017
	$TOC	Description of the Symbol Definitions


; The symbols in SYSUNV have the following characteristics:
;
;   Symbol                           Type
;
;   xx.yyy   The word offset for mask.
;
;   xx%yyy   The byte mask.
;
;   xx$yyy   The byte shift offset.
;
;   .xxyyy   A value to be stored in the byte (0 - n).
;
;   %xxyyy   A bit mask (a subset of xx%yyy).
;
;   $zzzzz   A macro definition.
;
;
;    xx    - The  data structure name; should be two characters, but can
;            be one character.
;    yyy   - The flag or value name.
;    zzzzz - The macro name.
	$TOC	Miscellaneous Symbols -- ASCII Characters


; Define ASCII character symbols:

	.CHNUL==000			; Control-@ (null)
	.CHCNA==001			; Control-A
	.CHCNB==002			; Control-B
	.CHCNC==003			; Control-C
	.CHCND==004			; Control-D
	.CHCNE==005			; Control-E
	.CHCNF==006			; Control-F
	.CHBEL==007			; Control-G (bell)
	.CHCNH==010			; Control-H (backspace)
	.CHTAB==011			; Control-I (horizontal tab)
	.CHLFD==012			; Control-J (line-feed)
	.CHVTB==013			; Control-K (vertical tab)
	.CHFFD==014			; Control-L (form-feed)
	.CHCRT==015			; Control-M (carriage return)
	.CHCNN==016			; Control-N
	.CHCNO==017			; Control-O
	.CHCNP==020			; Control-P
	.CHCNQ==021			; Control-S
	.CHCNR==022			; Control-R
	.CHCNS==023			; Control-S
	.CHCNT==024			; Control-T
	.CHCNU==025			; Control-U
	.CHCNV==026			; Control-V
	.CHCNW==027			; Control-W
	.CHCNX==030			; Control-X
	.CHCNY==031			; Control-Y
	.CHCNZ==032			; Control-Z
	.CHESC==033			; Control-[ (Escape)
	.CHCBS==034			; Control-\
	.CHCRB==035			; Control-]
	.CHCCF==036			; Control-^
	.CHCUN==037			; Control-_

	.CHLPR=="("			; Left parenthesis
	.CHRPR==")"			; Right parenthesis
	.CHLAB=="<"			; Left angle bracket
	.CHRAB==">"			; Right angle bracket
	.CHLSB=="["			; Left square bracket
	.CHRSB=="]"			; Right square bracket
	.CHLCB=="{"			; Left curly bracket
	.CHRCB=="}"			; Right curly bracket

	.CHALT==175			; Old Altmode
	.CHAL2==176			; Alternate old Altmode
	.CHDEL==177			; Delete
	$TOC	Miscellaneous Symbols -- Useful Symbols


; Define the days of the week (universal date/time):

	.DWWED==0			; Wednesday
	.DWTHU==1			; Thursday
	.DWFRI==2			; Friday
	.DWSAT==3			; Saturday
	.DWSUN==4			; Sunday
	.DWMON==5			; Monday
	.DWTUE==6			; Tuesday


; Define the times of the day (universal date/time):

	TD%NON==B18			; The time is after 12 a.m. (noon)
	TD%EVE==B19			; The time is after 6 p.m. (if TD%NON
					;  is on)
	TD%NIT==B20			; The time is after 9 p.m. (if TD%NON
					;  and TD%EVE are on)
	$TOC	Transfer of Control Macros -- PFALL Description


; PFALL -- A macro to see if the address specified is the address of the
;          next location,  used  by  routines  that  fall  into  another
;          routine.
;
; Call:
;
;	PFALL	$ADR
;
; Where:
;
;	$ADR - The address to be checked.
	$TOC	Transfer of Control Macros -- PFALL Macro


DEFINE	PFALL [SALL] ($ADR),<

IF2,<
   IFN <.-$ADR>,<
      $PRINT F,ADN,PFALL - The address specified is not the next address >>

>					; End of 'DEFINE PFALL'
	$TOC	Transfer of Control Macros -- Useful OPDEFs


; Define some useful OPDEFs for transfer of control:

;[CSM]	OPDEF	PJRST	[JRST]		; PUSHJ/POPJ
	OPDEF	PJRST	[JUMPA 17,]	; Use MACTEN's definition	[CSM]
	OPDEF	PJRSTF	[JRSTF]		; PUSHJ/POPJ
	OPDEF	PJSP	[JSP]		; MOVEI .+1/PUSHJ/POPJ

	OPDEF	PJMPL	[JUMPL]		; PUSHJ/JUMPL/POPJ
	OPDEF	PJMPLE	[JUMPLE]	; PUSHJ/JUMPLE/POPJ
	OPDEF	PJMPE	[JUMPE]		; PUSHJ/JUMPE/POPJ
	OPDEF	PJMPN	[JUMPN]		; PUSHJ/JUMPN/POPJ
	OPDEF	PJMPG	[JUMPG]		; PUSHJ/JUMPG/POPJ
	OPDEF	PJMPGE	[JUMPGE]	; PUSHJ/JUMPGE/POPJ

	.NODDT	PJRSTF,PJSP,PJMPL,PJMPLE,PJMPN,PJMPG,PJMPGE		;[CSM]
	$TOC	Error Message Macro -- $PRINT Description


; $PRINT -- Macro to do a PRINTX with a leading '?', '%', '$' or '['.
;
; Call:
;
;	$PRINT	($HDR,$PFX,$TXT,$PAS
;
; Where:
;
;	$HDR - The code for the type of message to output:
;		 F - Fatal message.
;		 I - Information message.
;		 O - Operation message.
;		 W - Warning message.
;
;	$PFX - The 3 character prefix to output.
;
;	$TXT - The text message to output.
;
;	$PAS - The pass assemble option.
	$TOC	Error Message Macro -- $PRINT Macro


DEFINE	$PRINT [SALL] ($HDR,$PFX,$TXT,$PAS<^O3>,%ERR,%PAS),<

%ERR==^O0				;; Set the error flag

IF1,<%PAS==^O1>				;; Pass 1
IF2,<%PAS==^O2>				;; Pass 2

IFN <<$PAS>&%PAS>,<
  IFIDNX <$HDR><F>,<			;; A fatal message?
    PRINTX ?SYS'$PFX $TXT
    %ERR==^O1
    IF2,<STOPI> >			;; Force an 'A' error on fatal errors

  IFIDNX <$HDR><I>,<			;; An information message?
    PRINTX [SYS'$PFX $TXT]
    %ERR==^O1 >

  IFIDNX <$HDR><O>,<			;; An operator message?
    PRINTX $SYS'$PFX $TXT
    %ERR==^O1 >

  IFIDNX <$HDR><W>,<			;; A warning message?
    PRINTX %SYS'$PFX $TXT
    %ERR==^O1 >

  IFE %ERR,<$PRINT F,AUH,$PRINT - An undefined header ($HDR)> >

PURGE	%ERR,%PAS

>					; End of 'DEFINE $PRINT'
	$TOC	Title/Version Macros -- $VRSN Description


; $VRSN -- Macro to define the version number symbols.
;
; Call:
;
;	$VRSN	($PFX,$VSN)
;
; Where:
;
;	$PFX - The prefix for the version symbols.
;
;	$VSN - A standard version number text, 12A(345)-6.
; General format of the version number format:

;  !======================================================!
;  !    Who    !    Version    !    Minor    !    Edit    !
;  !======================================================!

	$DSBEG    VN			; The $VRSN data structure
	 $DSFLG   WHO,^D3		 ; The 'who' field
	 $DSFLG   VER,^D9		 ; The major version number field
	 $DSFLG   MIN,^D6		 ; The minor version number field
	 $DSFLG   EDT,^D18		 ; The edit level field
	$DSEND    VN			; That's all
	$TOC	Title/Version Macros -- $TITLE Description


; $TITLE -- Macro  to  make a title with the version number appended to
;           the end.
;
; Call:
;
;	$TITLE	($TXT,$PFX,$TTL,$PAS,$XTR)
;
; Where:
;
;	$TXT - The text to be used.
;
;	$PFX - The prefix of the version symbols.
;
;	$TTL - An optional argument to be used inplace of the TITLE.
;
;	$PAS - An optional assemble in this pass.
;
;	$XTR - An additional text string.
	$TOC	Title/Version Macros -- $PASS Description


; $PASS -- Macro to output the program name, version number and the
;	   current pass of the assembler.
;
; Call:
;
;	$PASS	($TXT,$PFX)
;
; Where:
;
;	$TXT - The title of the program.
;
;	$PFX - The prefix of the version symbols.
	$TOC	Title/Version Macros -- $BEGIN Description


; $BEGIN -- Macro to setup some of the cheap stuff for the user.
;
; Call:
;
;	$BEGIN	($TTL,$PFX,$VSN,$FLG)
;
; Where:
;
;	$TTL - The text to be used as the title/universal line.
;
;	$PFX - The prefix for the version symbols.
;
;	$VSN - A standard version number text, 12A(345)-6.
;
;	$FLG - Some special flags:
;	         ACS        - Define  the  ACs, the argument is the base
;	                      address for register T1 (the default is
;	                      ^O1).
;	         NOACS      - Don't define the ACs.
;	         BINARY     - Don't suppress the REL file.
;	         NOBINARY   - Suppress the REL file.
;	         BITS       - Define the bit symbols (B0, B1, ..., B34).
;	         NOBITS     - Don't define the bit symbols.
;	         FAILING    - Suppress  failing  conditionals from being
;	                      listed.
;	         NOFAILING  - Don't  suppress  failing conditionals from
;	                      being listed.
;		 HELPER     - Request REL:HELPER.REL at load time.
;		 IOSEC      - Request  REL:IOSEC.REL at load time, which
;	                      will require  SYS:IOSEC.EXE  at  execution
;	                      time.
;	         LIT	    - Dump  the  literal  pool  when the segment
;	                      changes.
;	         NOLIT      - Don't  dump  the  literal  pool  when  the
;	                      segment changes.
;	         MANY       - Create a PSECT'ed program.
;	         ONE        - Create a one segment program.
;	         SCAN       - Search  SCNMAC  for  SCAN/WILD  macros and
;	                      symbols  and  request   REL:SCN7C.REL   or
;	                      REL:SCAN11.REL at load time.
;	         SEARCH     - Search  some universal files, the argument
;	                      is list of files to search.
;	         SCANNER    - Search  SCNPRM  for  the SCANER macros and
;	                      symbols and request REL:SCANER.REL at load
;	                      time.
;	         STRINGS    - Create an external string file.
;	         SUPPRESS   - Suppress the ACs from DDT output.
;	         NOSUPPRESS - Don't suppress the ACs from DDT output.
;	         TITLE      - Create a program.
;	         TOPS10     - Search UUOSYM for UUO symbols.
;	         TOPS20     - Search MONSYM for JSYS symbols.
;	         TWO	    - Create a two segment program, the argument
;	                      is the  high  segment  base  address  (the
;	                      default is 400000).
;	         TYPER      - Request REL:TYPER.REL at load time.
;	         UNIVERSAL  - Create a universal file.
;	         VERSION    - Put the version number in location 137.
;	         NOVERSION  - Don't  put  the version number in location
;	                      137.
;		 WILD       - Request REL:WLD7A.REL or REL:WILD11.REL at
;	                      load time.
;	       Note:  ACS,  BINARY,  BITS, NOFAILING, NOLIT, NOSUPPRESS,
;	              TITLE, TWO and NOVERSION are the defaults  if  not
;	              given.  NOACS  and  NOBINARY  are  the defaults if
;	              UNIVERSAL is given.  VERSION is the default if the
;	              $END or $PRGEND macros is called with an address.
;
; Note:
;
;	At  the  completion  of  this  macro  the  relocation counter is
;       pointing at the low segment.
; Define some flags:

	$FLAGS	BE$			; Define the $BEGIN symbol prefix
	 $FLAG	ACS		 	; Define the ACs
	 $FLAG	BIN		 	; Create a REL file
	 $FLAG  BIT			; Define some bit symbols
	 $FLAG	DMP		 	; Dump the literal pool
	 $FLAG	FAL		 	; Suppress failing conditionals
	 $FLAG	HLP		 	; Request HELPER
	 $FLAG	IOS		 	; Request IOSEC
	 $FLAG  MAC			; Search MACSYM or MACTEN
	 $FLAG	MAN		 	; PSECT code
	 $FLAG  MUL			; Multiline expansions
	 $FLAG	ONE		 	; One segment code
	 $FLAG	SCN		 	; Search SCNMAC/SCNM20 and request
					;  SCN7C/SCAN11
	 $FLAG	SNR		 	; Request SCANER
	 $FLAG  STR		 	; External strings
	 $FLAG	SUP		 	; Suppress the ACs from DDT output
	 $FLAG	T10		 	; Search UUOSYM
	 $FLAG	T20		 	; Search MONSYM
	 $FLAG	TTL		 	; Setup a title
	 $FLAG	TWO		 	; Two segment code
	 $FLAG	TYP		 	; Request TYPER
	 $FLAG  UNV		 	; Setup a universal
	 $FLAG	VRN		 	; Put the version in location 137
	 $FLAG	WLD		 	; Request WLD7A/WILD11


; Define the external string file preamble:

	$DSBEG   ES			; The external string data structure:
	 $DSWRD  CNT		 	 ; The preamble length
	 $DSWRD  FMT			 ; The external string format
	 $DSWRD  VER		 	 ; The version of external string file
	 $DSWRD  RNG			 ; The range of string numbers
	  $DSFLG MAX,LEFT,RNG	 	  ; The maximum string number
	  $DSFLG MIN,RIGHT	 	  ; The minimum string number
 	$DSEND   ES,SIZ			; That's all
	$TOC	Title/Version Macros -- $VRSN Macro


DEFINE	$VRSN [SALL] ($PFX,$TXT,%LVL,%SEC),<

$PFX'WHO==0				;; Reset the who last edited this code
$PFX'VER==0				;; Reset the version number
$PFX'MIN==0				;; Reset the minor version number
$PFX'EDT==0				;; Reset the edit number

%LVL==1					;; Reset the level counter
%SEC==1					;; Reset the section counter

IRPC $TXT,<				;; Loop thru the version text
  IFE %LVL-^O1,<			 ;; The version number
    IFGE "$TXT"-"0",<			  ;; Is this char .GE. 0
      IFLE "$TXT"-"7",<			   ;; Yes, is this char .LE. 7
        $PFX'VER==<$PFX'VER*^O10+$TXT>	    ;; Yes, add in the digit
        IFG $PFX'VER-^O777,<%LVL==^O0> >>   ;; See if still valid
    IFL "$TXT"-"0",<%LVL==^O2>		  ;; If not octal try minor version
    IFG "$TXT"-"7",<%LVL==^O2> >	  ;; If not octal try minor version

  IFE %LVL-^O2,<			 ;; The minor version number
    IFGE "$TXT"-"A",<			  ;; Is this char .GE. A
      IFLE "$TXT"-"Z",<			   ;; Yes, is this char .LE. Z
        $PFX'MIN==<$PFX'MIN*^O32+"$TXT"-"@">;; Yes, add in the level
        IFG $PFX'MIN-^O77,<%LVL==^O0> >>    ;; See if still valid
    IFL "$TXT"-"A",<%LVL==^O3>		  ;; If not alpha try edit number
    IFG "$TXT"-"Z",<%LVL==^O3>>		  ;; If not alpha try edit number

  IFE %LVL-^O3,<			 ;; The edit number
    IFE %SEC-^O1,<			  ;; Look for '('
      IFE "$TXT"-"(",<%SEC==^O2>	  ;; Set a flag
      IFN "$TXT"-"(",<			  ;; If not '(' try who number
        %LVL==^O4			   ;; Try WHO
        %SEC==^O1 >>			   ;; The char must be a '-'
    IFE %SEC-^O3,<			  ;; Get the edit number
      IFGE "$TXT"-"0",<			   ;; Is this char .GE. 0
        IFLE "$TXT"-"7",<		    ;; Yes, is this char .LE. 7
          $PFX'EDT==<$PFX'EDT*^O10+$TXT>     ;; Yes, add in the digit
          IFG $PFX'EDT-^O777777,<%LVL==^O0>>>;; See if still valid
      IFL "$TXT"-"0",<%SEC==^O4>	   ;; If not octal try for a ')'
      IFG "$TXT"-"7",<%SEC==^O4> >	   ;; If not octal try for a ')'
    IFE %SEC-^O4,<			  ;; Check for ')'
      IFE "$TXT"-")",<			   ;; Is this char a ')'
        %LVL==^O4			    ;; Yes, look for WHO
        %SEC==^O0 >			    ;; Skip this char
      IFN "$TXT"-")",<%LVL==^O0> >	   ;; Not a ')' an error
    IFE %SEC-^O2,<%SEC==^O3> >		  ;; Start reading the edit number

  IFE %LVL-^O4,<			 ;; The who number
    IFE %SEC-^O1,<			  ;; Check for a '-'
      IFN "$TXT"-"-",<%LVL==0> >	   ;; An error if not a '-'
    IFE %SEC-^O2,<			  ;; Check for a digit
      IFGE "$TXT"-"1",<			   ;; Is this char .GE. 1
        IFLE "$TXT"-"7",<		    ;; Yes, is this char .LE. 7
          $PFX'WHO=<"$TXT"-"0"> >>	     ;; Yes, set up WHO
      IFL "$TXT"-"1",<%LVL==^O0>	   ;; If not octal an error
      IFG "$TXT"-"7",<%LVL==^O0> >	   ;; If not octal an error
    IFE %SEC-^O3,<%LVL==^O0>		  ;; Too much data
    %SEC==%SEC+^O1 >			  ;; Increment the section number

  IFE %LVL,<				 ;; An error
    STOPI				 ;; Quit
    $PRINT F,IVN,$VRSN - Illegal version number or character >
  >

$PFX'.VN==<<$PFX'WHO_VN$WHO>!<$PFX'VER_VN$VER>!<$PFX'MIN_VN$MIN>!<$PFX'EDT_VN$EDT>>

TP.PFX==''$PFX''			;; Define the system prefix for .TYPER

PURGE	%LVL,%SEC

>					; End of 'DEFINE $VRSN'
	$TOC	Title/Version Macros -- $TITLE Macro


DEFINE	$TITLE [SALL] ($TXT,$PFX,$TTL<TITLE>,$PAS<3>,$XTR,%FLG,%FST,%SND),<

%FLG==0					;; See if the world is kool

IFDEF $PFX'WHO,<			;; Make sure who is valid
  IFGE $PFX'WHO,<			 ;; Is it .GE. 0
    IFLE $PFX'WHO-^O7,<%FLG==%FLG+^O1> >> ;; Yes, is it .LE. 7

IFDEF $PFX'VER,<			;; Make sure version is valid
  IFGE $PFX'VER,<			 ;; Is it .GE. 0
    IFLE $PFX'VER-^O777,<%FLG==%FLG+^O1>>>;; Yes, is it .LE. 777

IFDEF $PFX'MIN,<			;; Make sure minor version is valid
  IFGE $PFX'MIN,<			 ;; Is it .GE. 0
    IFLE $PFX'MIN-^O77,<%FLG==%FLG+^O1> >>;; Yes, is it .LE. 77

IFDEF $PFX'EDT,<			;; Make sure edit is valid
  IFGE $PFX'EDT,<			 ;; Is it .GE. 0
    IFLE $PFX'EDT-^O777777,<%FLG==%FLG+^O1>>>;; Yes, is it .LE. 777777

IFN <%FLG-^O4>,<			;; If not all valid an error
   $PRINT F,IUS,$TITLE - Illegal or undefined version symbol >


IF1,<%FLG==^O1>				;; Pass one
IF2,<%FLG==^O2>				;; Pass two

IFN <<$PAS>&%FLG>,<			;; The right pass


  DEFINE $TITL0 [SALL] ($VER,$MIN,$EDT,$WHO),<

    IFE $VER,<
      IFE $WHO,<$TTL $TXT %'$MIN($EDT)$XTR>
      IFN $WHO,<$TTL $TXT %'$MIN($EDT)-$WHO'$XTR>>
    IFN $VER,<
      IFE $WHO,<$TTL $TXT %'$VER'$MIN($EDT)$XTR>
      IFN $WHO,<$TTL $TXT %'$VER'$MIN($EDT)-$WHO'$XTR>>

    >					;; End of 'DEFINE $TITL0'


  %FST==<$PFX'MIN-^O1>/^O32		;; Offset for the first part of minor version
  %SND==$PFX'MIN-%FST*^O32		;; Offset for the second part of minor version

  IFN %SND,<				;; Is there a minor version number?
    %FLG==^O0				;; Yes, reset the minor version
    IFN %FST,<				;; Are there 2 characters?
      %FLG==<%FST+"@">*^O200 >		;; Yes, store the first character
    %FLG==%FLG+<%SND+"@">		;; Store the second character
    $TITL0 (\$PFX'VER,\"%FLG,\$PFX'EDT,\$PFX'WHO) >

  IFE %SND,<				;; No minor version
    $TITL0 (\$PFX'VER,,\$PFX'EDT,\$PFX'WHO) >>

PURGE	$TITL0,%FLG,%FST,%SND

>					; End of 'DEFINE $TITLE'
	$TOC	Title/Version Macros -- $PASS Macro


DEFINE	$PASS [SALL] ($TXT,$PFX),<

$TITLE (<[Assembling $TXT version>,$PFX,PRINTX,1,<, pass 1]>)
$TITLE (<[Assembling $TXT version>,$PFX,PRINTX,2,<, pass 2]>)

>					; End of 'DEFINE $PASS'
	$TOC	Title/Version Macros -- $BEGIN Macro


DEFINE	$BEGIN [SALL/PERMANENT] ($TTL,$PFX,$VSN,$FLG),<

BE$AUX==^O0				;; Reset the auxillary flags
BE$FLG==<BE$TTL!BE$TWO!BE$ACS!BE$BIN!BE$MUL>  ;; Setup the default flags

BE$NAM==^O0				;; Reset the program name
BE$LIT=='NOLIT'				;; Don't flush the literals
BE$REG==^O1				;; The ACs base number
BE$SEG==^O400000			;; The high segment base address

.XCREF	$LSTON,$LSTOF,$TOC		;; Don't put these in the CREF listing

IRPC $TTL,<				;; Generate the title
  IFE <<"$TTL"-" ">*<"$TTL"-.CHTAB>>,<
    STOPI >
  IFN <<"$TTL"-" ">*<"$TTL"-.CHTAB>>,<
    BE$NAM=<<BE$NAM_^D6>!''$TTL''>
    IFN <BE$NAM&^O77B5>,<
      STOPI >>>

IFDEF BE$ADR,<
  BE$FLG==<BE$FLG!BE$VRN> >		;; Include version if starting address

IRP $FLG,<
  $BEGI1 ($FLG) >

IFNB <$VSN>,<
  $VRSN ($PFX,$VSN) >			;; Get the version number info

IFN <BE$FLG&BE$STR>,<			;; Generate external string
  $TITLE <$TTL>,$PFX,UNIVERSAL
  $BEGI6 strings,\'BE$NAM,$PFX		;; Inform the world of our intentions
  IFE <BE$AUX&BE$ACS>,<
    BE$FLG==<BE$FLG&<^-BE$ACS>> >
  RIM10					;; Special format REL
  LOC ^O0				;;  file starting at zero
  ES.SIZ				;; The length of the preamble
  BYTE (3)EXTWHO (9)EXTVER (6)EXTMIN (18)EXTEDT
  BYTE (3)$PFX'WHO (9)$PFX'VER (6)$PFX'MIN (18)$PFX'EDT
  .ESEND,,.ESBEG >			;; The external string range

IFN <BE$FLG&BE$TTL>,<			;; Generate the program
  $TITLE <$TTL>,$PFX
  $BEGI6 program,\'BE$NAM,$PFX		;; Inform the world of our intentions
  IFN <BE$FLG&BE$MAN>,<
    $RELOC MANY,\'BE$LIT >		;; Generate PSECT code
  IFN <BE$FLG&BE$ONE>,<
    $RELOC ONE,\'BE$LIT >		;; Generate one segment code
  IFN <BE$FLG&BE$TWO>,<
    $RELOC TWO,\'BE$LIT,BE$SEG >	;; Generate two segment code
  IFN <BE$FLG&BE$VRN>,<
    $ABS 137				;; Open location 137
    BYTE (3)$PFX'WHO (9)$PFX'VER (6)$PFX'MIN (18)$PFX'EDT
    $LOW >>				;; Back to the low segment

IFN <BE$FLG&BE$UNV>,<			;; Generate a universal file
  $TITLE <$TTL>,$PFX,UNIVERSAL
  $BEGI6 universal,\'BE$NAM,$PFX	;; Inform the world of our intentions
  IFE <BE$AUX&BE$ACS>,<
    BE$FLG=<BE$FLG&<^-BE$ACS>> >
  IF2,<
    IFNDEF BE$PRG,<
      IFE <BE$AUX&BE$BIN>,<
        BE$FLG=<BE$FLG&<^-BE$BIN>> >>>>

IFE <BE$FLG&BE$BIN>,<
  .DIREC .NOBIN >			;; Suppress the REL file

IFE <BE$FLG&BE$MUL>,<
  .DIRECT NO FLBLST >			;; List mulity line text
IFN <BE$FLG&BE$MUL>,<
  .DIREC FLBLST >			;; List only the first line of multi-line test

IFN <BE$FLG&<BE$IOS!BE$SNR>>,<
  SEARCH SCNPRM >			;; Request the SCANER macros

IFN <BE$FLG&BE$T10>,<
  DEFINE $TOPS [SALL],<10>		;; TOPS-10 program
  SEARCH UUOSYM				;; DEC's UUO symbols
  IFN <BE$FLG&BE$MAC>,<
    SEARCH MACTEN >>			;; DEC's macros
IFN <BE$FLG&BE$T20>,<
  DEFINE $TOPS [SALL],<20>		;; TOPS-20 program
  SEARCH MONSYM				;; DEC's JSYS symbols
  IFN <BE$FLG&BE$MAC>,<
    SEARCH MACSYM			;; DEC's macros
    .REQUE REL:MACSYM.REL >>		;; Request MACSYM

IFN <BE$FLG&BE$IOS>,<
  .REQUE REL:IOSEC.REL >		;; Request the IOSEC subroutines

IFN <BE$FLG&BE$SNR>,<
  .REQUE REL:SCANER.REL >		;; Request the SCANER subroutines

IFN <BE$FLG&BE$TYP>,<
  OPDEF $TYPER [JRSTF @.JBOPC##]	;; Return from DDT after calling TYPER
  IFN <BE$FLG&BE$SCN>,<
    .REQUE REL:TYP7S.REL >		;; Request the TYPER with SCAN support
  IFE <BE$FLG&BE$SCN>,<
    .REQUE REL:TYP7N.REL >>		;; Request the TYPER without SCAN support

IFN <BE$FLG&BE$SCN>,<
  IFN <BE$FLG&BE$T10>,<
    SEARCH SCNMAC			;; DEC's SCAN/WILD macros
    .REQUE REL:SCN7C.REL >		;; DEC's SCAN subroutines
  IFN <BE$FLG&BE$T20>,<
    SEARCH SCNM20			;; DEC's SCAN/WILD macros
    .REQUE REL:SCAN11.REL >		;; DEC's SCAN subroutines
  BE$FLG==<BE$FLG!BE$HLP> >		;; Load HELPER with SCAN

IFN <BE$FLG&BE$WLD>,<
  IFN <BE$FLG&BE$T10>,<
    .REQUE REL:WLD7A.REL >		;; DEC's WILD subroutines
  IFN <BE$FLG&BE$T20>,<
    .REQUE REL:WILD11.REL >>		;; DEC's WILD subroutines

IFN <BE$FLG&BE$HLP>,<
  .REQUI REL:HELPER.REL >		;; DEC's help processor

IFN <BE$FLG&BE$FAL>,<
  .DIREC SFCOND > 			;; Suppress failing conditionals

IFN <BE$FLG&BE$ACS>,<
  IFN <BE$FLG&BE$SUP>,<
    F==^O0				;; The flags
    T1==BE$REG				;; Temporary ACs
    T2==T1+^O1				;;  usually not
    T3==T2+^O1				;;  saved across
    T4==T3+^O1				;;  routines
    P1==T4+^O1				;; Permanent ACs
    P2==P1+^O1				;;  usually saved
    P3==P2+^O1				;;  across
    P4==P3+^O1				;;  routines
    IFN <BE$FLG&BE$SCN>,<
      N==P3				;; Holds a number (input)
      C==P4 >				;; Holds a character (input)
    FP==^O16				;; Frame pointer
    P==^O17 >				;; Push down list pointer
  IFE <BE$FLG&BE$SUP>,<
    F=^O0				;; The flags
    T1=BE$REG				;; Temporary ACs
    T2=T1+^O1				;;  usually not
    T3=T2+^O1				;;  saved across
    T4=T3+^O1				;;  routines
    P1=T4+^O1				;; Permanent ACs
    P2=P1+^O1				;;  usually saved
    P3=P2+^O1				;;  across
    P4=P3+^O1				;;  routines
    IFN <BE$FLG&BE$SCN>,<
      N=P3				;; Holds a number (input)
      C=P4 >				;; Holds a character (input)
    FP=^O16				;; Frame pointer
    P=^O17 >>				;; Push down list pointer

IFN <BE$FLG&BE$BIT>,<
  $FLAGS  B				;; Define symbols for all the bits
   $FLAG  0				 ;; Define bit 0
   $FLAG  1				 ;; Define bit 1
   $FLAG  2				 ;; Define bit 2
   $FLAG  3				 ;; Define bit 3
   $FLAG  4				 ;; Define bit 4
   $FLAG  5				 ;; Define bit 5
   $FLAG  6				 ;; Define bit 6
   $FLAG  7				 ;; Define bit 7
   $FLAG  8				 ;; Define bit 8
   $FLAG  9				 ;; Define bit 9
   $FLAG  10				 ;; Define bit 10
   $FLAG  11				 ;; Define bit 11
   $FLAG  12				 ;; Define bit 12
   $FLAG  13				 ;; Define bit 13
   $FLAG  14				 ;; Define bit 14
   $FLAG  15				 ;; Define bit 15
   $FLAG  16				 ;; Define bit 16
   $FLAG  17				 ;; Define bit 17
   $FLAG  18				 ;; Define bit 18
   $FLAG  19				 ;; Define bit 19
   $FLAG  20				 ;; Define bit 20
   $FLAG  21				 ;; Define bit 21
   $FLAG  22				 ;; Define bit 22
   $FLAG  23				 ;; Define bit 23
   $FLAG  24				 ;; Define bit 24
   $FLAG  25				 ;; Define bit 25
   $FLAG  26				 ;; Define bit 26
   $FLAG  27				 ;; Define bit 27
   $FLAG  28				 ;; Define bit 28
   $FLAG  29				 ;; Define bit 29
   $FLAG  30				 ;; Define bit 30
   $FLAG  31				 ;; Define bit 31
   $FLAG  32				 ;; Define bit 32
   $FLAG  33				 ;; Define bit 33
   $FLAG  34				 ;; Define bit 34
   $FLAG  35 >				 ;; Define bit 35

>					; End of 'DEFINE $BEGIN'


DEFINE	$BEGI1 [SALL] ($FLG),<

	$BEGI2	($FLG)

>					; End of 'DEFINE $BEGI1'


DEFINE	$BEGI2 [SALL] ($FLG,$ARG),<

IFIDNX <$FLG><ACS>,<			;; Define the ACs
  $BEGI4 ($FLG,BE$ACS)
  IFNB <$ARG>,<
    BE$REG==<$ARG> >>
IFIDNX <$FLG><NOACS>,<			;; Don't define the ACs
  $BEGI5 ($FLG,BE$ACS) >

IFIDNX <$FLG><BINARY>,<			;; Don't suppress the REL file
  $BEGI4 ($FLG,BE$BIN) >
IFIDNX <$FLG><NOBINARY>,<		;; Suppress the REL file
  $BEGI5 ($FLG,BE$BIN) >

IFIDNX <$FLG><BITS>,<			;; Define bit symbols
  $BEGI4 ($FLG,BE$BIT) >
IFIDNX <$FLG><NOBITS>,<			;; Don't define bit symbols
  $BEGI5 ($FLG,BE$BIT) >

IFIDNX <$FLG><ENTRY>,<			;; Define an entry point
  IRP $ARG,<
    ENTRY $ARG >>

IFIDNX <$FLG><FAILING>,<		;; Suppress failing conditions
  $BEGI4 ($FLG,BE$FAL) >
IFIDNX <$FLG><NOFAILING>,<		;; Don't suppress failing conditions
  $BEGI5 ($FLG,BE$FAL) >

IFIDNX <$FLG><HELPER>,<			;; Request HELPER
  $BEGI4 ($FLG,BE$HLP) >

IFIDNX <$FLG><IOSEC>,<			;; Request IOSEC
  $BEGI4 ($FLG,BE$IOS) >

IFIDNX <$FLG><LIT>,<			;; Dump the literal pool
  $BEGI4 ($FLG,BE$DMP)
  BE$LIT=='LIT' >
IFIDNX <$FLG><NOLIT>,<			;; Don't dump the literal pool
  $BEGI5 ($FLG,BE$DMP)
  BE$LIT=='NOLIT' >

IFIDNX <$FLG><MACROS>,<			;; Load macros
  $BEGI4 ($FLG,BE$MAC) >

IFIDNX <$FLG><MANY>,<			;; PSECT code
  $BEGI3 ($FLG,BE$MAN,BE$ONE!BE$TWO) >

IFIDNX <$FLG><ONE>,<			;; One segment code
  $BEGI3 ($FLG,BE$ONE,BE$TWO!BE$MAN) >

IFIDNX <$FLG><SCAN>,<			;; SCAN/WILD macros and request SCN7C/SCAN11
  $BEGI3 ($FLG,BE$SCN,BE$SNR!BE$IOS) >

IFIDNX <$FLG><SCANNER>,<		;; Request SCANER
  $BEGI3 ($FLG,BE$SNR,BE$SCN)
  BE$FLG==BE$FLG!BE$TYP >

IFIDNX <$FLG><SEARCH>,<			;; Search some universal files
  IRP $ARG,<
    SEARCH $ARG >>

IFIDNX <$FLG><STRINGS>,<		;; Strings
  $BEGI3 ($FLG,BE$STR,BE$TTL!BE$UNV) >

IFIDNX <$FLG><SUPPRESS>,<		;; Suppress ACs from DDT output
  $BEGI4 ($FLG,BE$SUP) >
IFIDNX <$FLG><NOSUPPRESS>,<		;; Don't suppress ACs from DDT output
  $BEGI5 ($FLG,BE$SUP) >

IFIDNX <$FLG><TITLE>,<			;; Title
  $BEGI3 ($FLG,BE$TTL,BE$STR!BE$UNV) >

IFIDNX <$FLG><TOPS10>,<			;; TOPS10
  $BEGI3 ($FLG,BE$T10,BE$T20) >

IFIDNX <$FLG><TOPS20>,<			;; TOPS20
  $BEGI3 ($FLG,BE$T20,BE$T10) >

IFIDNX <$FLG><TWO>,<			;; Two segment code
  $BEGI3 ($FLG,BE$TWO,BE$ONE!BE$MAN)
  IFNB <$ARG>,<
    BE$SEG==<$ARG> >>

IFIDNX <$FLG><TYPER>,<			;; Request TYPER
  $BEGI4 ($FLG,BE$TYP) >

IFIDNX <$FLG><UNIVERSAL>,<		;; Universal
  $BEGI3 ($FLG,BE$UNV,BE$STR!BE$TTL) >

IFIDNX <$FLG><VERSION>,<		;; Store the version number
  $BEGI4 ($FLG,BE$VRN) >
IFIDNX <$FLG><NOVERSION>,<		;; Don't store the version number
  $BEGI5 ($FLG,BE$VRN) >

IFIDNX <$FLG><WILD>,<			;; Request WLD7A/WILD11
  $BEGI4 ($FLG,BE$WLD) >

>					; End of 'DEFINE $BEGI2'


DEFINE $BEGI3 [SALL] ($FLG,$SET,$CLR),<

IFN <BE$AUX&<<$SET>!<$CLR>>>,<
  $PRINT F,MUF,$BEGIN - Multiply used flags ($FLG) >
BE$AUX==<BE$AUX!<$SET>>
BE$FLG==<<BE$FLG!<$SET>>&<^-<$CLR>>>

>					; End of 'DEFINE $BEGI3'


DEFINE $BEGI4 [SALL] ($FLG,$SET),<

IFN <BE$AUX&<$SET>>,<
  $PRINT F,MUF,$BEGIN - Multiply used flags ($FLG) >
BE$AUX==<BE$AUX!<$SET>>
BE$FLG==<BE$FLG!<$SET>>

>					; End of 'DEFINE $BEGI4'


DEFINE $BEGI5 [SALL] ($FLG,$CLR),<

IFN <BE$AUX&<$CLR>>,<
  $PRINT F,MUF,$BEGIN - Multiply used flags ($FLG) >
BE$AUX==<BE$AUX!<$CLR>>
BE$FLG==<BE$FLG&<^-<$CLR>>>

>					; End of 'DEFINE $BEGI5'


DEFINE $BEGI6 [SALL] ($TXT,$TTL,$PFX),<
;;[CSM]	$PASS <$TXT $TTL>,$PFX
$TITLE (<[Assembling $TXT $TTL version>,$PFX,PRINTX,2,<, pass 2]>)
;;[CSM] Don't PRINTX on PASS1, it just wastes a page of paper.
>					; End of 'DEFINE $BEGI6'
	$TOC	Listing Control Macros -- $CONTINUE Macro


; $CONTINUE -- This macro is invoked whenever a page overflow would have
;              happened.
;
; Note:
;
;	According to the proposed standard, all  source  for  a  routine
;	must  occur  on one page.  However, it is important for the user
;	to find "sentence" breaks to form the overflow  (eject)  points.
;	Whenever overflow occurs, a comment to that effect should appear
;	in the listing.  All this is accomplished by the user  including
;	the macro $CONTINUE in his source at the point of the overflow.

DEFINE	$CONTINUE [SALL] <PAGE>
	$TOC	Listing Control Macros -- $LSTOF and $LSTON Macros


; Macros to turn on and off listings when nesting:
;
; Call:
;
;	$LSTOF		Turns off the listing and CREF
;	$LSTOF	LIST	Turns off the listing
;	$LSTOF	CREF	Turns off the CREF
;	$LSTON		Restores the listing and CREF, if top level
;	$LSTON	LIST	Restores the listing, if top level
;	$LSTON	CREF	Restores the CREF, if top level
; Note:
;
;	If LSTIN. is defined as .WDMIN, then all listings on.
;	If CRFIN. is defined as .WDMIN, then all CREFs on

DEFINE	$LSTOF [SALL] ($SPC),<

IFDIFX <$SPC><LIST>,<
  IFNDEF CRFIN.,<CRFIN.==^O0>		;; Define the CREF counter
  IFGE CRFIN.,<.XCREF>			;; Suppress the CREF
  CRFIN.==CRFIN.+^O1 >			;; Increment the CREF counter

IFDIFX <$SPC><CREF>,<
  IFNDEF LSTIN.,<LSTIN.==^O0>		;; Define the listing counter
  IFGE LSTIN.,<XLIST>			;; Suppress the listing
  LSTIN.==LSTIN.+^O1 >			;; Increment the listing flag

>					; End of 'DEFINE $LSTOF'


DEFINE	$LSTON [SALL] ($SPC),<

IFDIFX <$SPC><LIST>,<
  IFNDEF CRFIN.,<CRFIN.==^O1>		;; Define the CREF counter
  CRFIN.==CRFIN.-^O1			;; Decrement the CREF counter
  IFLE CRFIN.,<.CREF> >			;; Restore the CREF

IFDIFX <$SPC><CREF>,<
  IFNDEF LSTIN.,<LSTIN.==^O1>		;; Define the listing counter
  LSTIN.==LSTIN.-^O1			;; Decrement the listing counter
  IFLE LSTIN.,<LIST> >			;; Restore the listing

>					; End of 'DEFINE $LSTON
	$TOC	Listing Control Macros -- $TOC Macro


; $TOC -- Macro to create a SUBTTL.
;
; Call:
;
;	$TOC	($TXT)
;
; Where:
;
;	$TXT - The text for the SUBTTL pseudo.


DEFINE	$TOC [SALL] ($TXT,%DUM),<

	SUBTTL	$TXT
	$LSTOF				;; A macro kludge
	SUBTTL	$TXT (cont.)
	$LSTON				;; A macro kludge

>					; End of 'DEFINE $TOC'


	.XCREF	$TOC			;; A kludge by any name is still a KLUDGE
	$TOC	Listing Control Macros -- $PURGE Macro


; $PURGE Macro - Delete all macro created symbols (..nnnn)
;
; Call:
;
;	$PURGE

DEFINE	$PURGE	[SALL] (%MAX),<

IF2,<					;; Only on pass 2

  ..MAX==<''%MAX''_^D12>		;; Get the number of symbols that must
					;;  be purged, also get rid of the dots
  $PURG1 (\'..MAX)			;; Go purge to macro created symbols

  PURGE ..BAS,..MAX,..SYM >		;; Finish the clean up

>					; End of 'DEFINE $PURGE'


DEFINE	$PURG1 [SALL] ($MAX),<

..BAS==^O1				;; Start a one

REPEAT <$MAX>,<
  ..SYM==<..BAS!<'..0000'>>		;; Get a created symbol
  $PURG2 (\'..SYM)			;;  to be purged
  ..BAS==<..BAS+^O000070707071>		;; Increment the base value
  ..BAS==<..BAS&^O000007070707>	>	;; Propagate any carry bits

>					; End of 'DEFINE $PURG1'


DEFINE	$PURG2 [SALL] ($SYM),<

PURGE	$SYM				;; Purge the symbol

>					; End of 'DEFINE $PURG2'
	$TOC	<Symbol Definition Macros -- $SHOW, $ND, $INT, $EXT and $GLB Macros>


; Macro to show the value of a symbol in the listing
;	$SHOW  $SYM

	DEFINE	$SHOW [SALL] ($SYM,%SYM),< %SYM==<$SYM> >


; Macro to define a symbol if not already defined
;	$ND  $SYM,$VAL

DEFINE	$ND [SALL] ($SYM,$VAL,%SYM),<
  IFNDEF $SYM,<$SYM==<$VAL>>
  %SYM==$SYM >


; Macro to define a symbol and force it internal
;	$INT  ($SYM,$VAL,$DDT)
; Note:	If $DDT is non-blank will be output from DDT

DEFINE	$INT [SALL] ($SYM,$VAL,$DDT),<

INTERN $SYM				;; Make the symbol internal
IFB <$DDT>,<$SYM==<$VAL>>		;; Suppress DDT output
IFNB <$DDT>,<$SYM=<$VAL>>		;; Don't suppress DDT output

>					; End of 'DEFINE $INT'


; Macro to define a symbol as external
;	$EXT ($SYM)

DEFINE	$EXT [SALL] ($SYM),<

IRP $SYM,<
  EXTERN $SYM >				;; Make the symbol external

>					; End of 'DEFINE $EXT'


; Macro to define a symbol as external or internal
;	$GLB  $SYM

DEFINE	$GLB [SALL] ($SYM),<

IRP $SYM,<
  IF2,<					;; Pass 2 only
    IFNDEF $SYM,<EXTERN $SYM>		;; An external symbol
    IFDEF $SYM,<INTERN $SYM> >>		;; An internal symbol

>					; End of 'DEFINE $GLB'
	$TOC	Byte Manipulation Macros


; Macro to compute the width of a mask.  $WID returns the length
; of the leftmost string of consecutive ones in the word.

DEFINE	$WID [SALL] ($MSK),<<^L<-<<$MSK>_<^L<$MSK>>>-1>>>


; Macro to compute the position of a mask.  $POS returns the position
; of the rightmost one in the word.

DEFINE	$POS [SALL] ($MSK),<<^L<$MSK>+^L<-<<$MSK>_<^L<$MSK>>>-1>-1>>


; Macro to build a pointer to a masked quantity.

DEFINE	$POINT [SALL] ($LOC,$MSK),<<POINT $WID(<$MSK>),$LOC,$POS(<$MSK>)>>


; Macro to build a mask $WID bits wide, with its rightmost bit
; in the bit position $POS.  (i.e. A mask for the byte pointed to
; by the byte pointer "POINT  $WID,$LOC,$POS")

DEFINE	$MASK [SALL] ($WID,$POS),<<<<1_<$WID>>-1>B<$POS>>>


; Macro to define a symbol with only one bit on, in the same position as
; the rightmost bit in $MSK (or 0, if $MSK = 0)

DEFINE	$RITBT [SALL] ($MSK),<<<$MSK>&-<$MSK>>>


; Macro to define a symbol with only one bit on, in the same position as
; the leftmost bit in $MSK (or 0, if $MSK = 0)

DEFINE	$LFTBT [SALL] ($MSK),<<1B<^L<$MSK>>>>

; $FILIN returns a word with a consecutive string of ones from the
; bit position of the leftmost one in MSK through the bit position
; of the rightmost one in $MSK inclusive.

DEFINE	$FILIN [SALL] ($MSK),<<<$MSK>!<<$LFTBT(<$MSK>)>-<$RITBT(<$MSK>)>>>>


; $ALIGN returns the number of trailing zeros in $MSK (i.e. a value
; which is the right counterpart of the value returned by the
; MACRO-10/20 operator ^L)

DEFINE	$ALIGN [SALL] ($MSK),<<^D35-<^L<$RITBT(<$MSK>)>>+<^D37*<<^L<$RITBT(<$MSK>)>>/^D36>>>>


; $INSVL positions value in mask

DEFINE	$INSVL [SALL] ($VAL,$MSK),<<<<$VAL>B<$POS(<$MSK>)>>&<$MSK>>>
	;
;[CSM] Define some macro synonyms to be compatible with an unmodified SCNMAC
	;
DEFINE ND (SYM,VAL),<;; This definition on 1 line to print on pass 2
IF2,<IFDEF SYM,<SYM==SYM>> IFNDEF SYM,<SYM==<VAL>>  >		;[CSM]
	;
SYN $WID,WID		;Width of a field			;[CSM]
	;
SYN $POS,POS		;Position of a byte			;[CSM]
	;
SYN $POINT,POINTR	;LDB byte pointer			;[CSM]
	;
SYN $ALIGN,ALIGN.	;Number of trailing zeros		;[CSM]
	;
DEFINE CONT.,<PAGE>	;Continued on next page			;[CSM]
	$TOC	Relocation Macros -- $RELOCATION Description


; $RELOC -- Macro to set up the relocation macros.
;
; Call:
;
;	$RELOC	($SEG,$LIT,$HGH)
;
; Where:
;
;	$SEG - An option to enable one or two segment code:
;	         MANY - Make PSECT segment code.
;	         ONE  - Make  one  segment  code ($HIGH and $LOW are the
;	                same).
;	         TWO  - Make two segment code.
;	       Note:  TWO is the default if not given.
;
;	$LIT - An  option  to  dump  the  literal  pool when the segment
;	       changes:
;	         LIT   - Dump the literal pool.
;	         NOLIT - Don't dump the literal pool.
;	       Note:  NOLIT is the default if not given.
;
;	$HGH - The address of the high segment origin.
;	       Note:  400000 Is the default if not given.
;
; Note:
;
;	At  the  completion  of  this  macro  the  relocation counter is
;	pointing at the low segment.
; Define the segment types:

	RL%ONE==^O1			; One segment code
	RL%TWO==^O2			; Two segment code
	RL%MAN==^O3			; PSECT code


; Define the literal types:

	RL%ON==-^O1			; The feature is on
	RL%OFF==^O0			; The feature is off


; Define the data segment types:

	RL%ABS==^O0			; The absolute segment
	RL%LOW==^O1			; The low segment
	RL%HGH==^O2			; The high segment
	RL%SEC==^O3			; A section segment
	$TOC	Relocation Macros -- $ABS Description


; $ABS -- Macro to change to the absolute segment.
;
; Call:
;
;	$ABS	($ADR)
;
; Where:
;
;	$ADR - The address of the absolute segment.
;	       Note:  The previous absolute address segment address will
;	              be used if not given.
	$TOC	Relocation Macros -- $END Description


; $END -- Macro to end the program.
;
; Call:
;
;	$END	($ADR)
;
; Where:
;
;	$ADR - The starting address or the entry vector of the program.
	$TOC	Relocation Macros -- $HIGH Description


; $HIGH -- Macro to change to the high segment.
;
; Call:
;
;	$HIGH	($ADR)
;
; Where:
;
;	$ADR - The address of the high segment.
;	       Note:  The  previous high address segment address will be
;	              used if not given.
	$TOC	Relocation Macros -- $LIT Description


; $LIT -- Macro to dump the literal pool.
;
; Call:
;
;	$LIT	($LST,$SEG)
;
; Where:
;
;	$LST - The listing option:
;		 LIST   - List the literal pool expansion.
;		 NOLIST - Don't list the literal pool expansion.
;	       Note:  LIST is the default if not given.
;
;	$SEG - The segment to dump the literal pool into:
;		 HIGH - Dump the literal pool into the high segment.
;		 LOW  - Dump the literal pool into the low segment.
;	       Note:  HIGH is the default if not given.
; Define the literal types:

	LT%ON==-^O1			; The feature is on
	LT%OFF==^O0			; The feature is off


;Define the data segment types:

	LT%DEF==^O0			; The current segment
	LT%LOW==^O1			; The low segment
	LT%HGH==^O2			; The high segment
	$TOC	Relocation Macros -- $LOW Description


; $LOW -- Macro to change to the low segment.
;
; Call:
;
;	$LOW	($ADR)
;
; Where:
;
;	$ADR - The address of the low segment.
;	       Note:  The  previous  low address segment address will be
;	       used if not given.
	$TOC	Relocation Macros -- $PRGEND Description


; $PRGEND -- Macro to end the program (same as PRGEND).
;
; Call:
;
;	$PRGEND	($ADR)
;
; Where:
;
;	$ADR - The starting address or the entry vector of the program.
	$TOC	Relocation Macros -- $SECTION Description


; $SECTION -- Macro to change to a different section.
;
; Call:
;
;	$SECTION ($SEC,$BAS)
;
; Where:
;
;	$SEC - The name of the section to be switched to.
;
;	$BAS - The base if the section, this argument shouldn't be given
;	       if this isn't the first reference to this section.
	$TOC	Relocation Macros -- $VAR Description


; $VAR -- Macro to dump the variable pool.
;
; Call:
;
;	$VAR	($LST,$SEG)
;
; Where:
;
;	$LST - The listing option:
;		 LIST   - List the variable pool expansion.
;		 NOLIST - Don't list the variable pool expansion.
;	       Note:  LIST is the default if not given.
;
;	$SEG - The segment to dump the variable pool into:
;		 HIGH - Dump the variable pool into the high segment.
;		 LOW  - Dump the variable pool into the low segment.
;	       Note:  LOW is the default if not given.
; Define the literal types:

	VR%ON==-^O1			; The feature is on
	VR%OFF==^O0			; The feature is off


; Define the data segment types:

	VR%DEF==^O0			; The current segment
	VR%LOW==^O1			; The low segment
	VR%HGH==^O2			; The high segment
	$TOC	Relocation Macros -- $RELOCATION Macro


DEFINE	$RELOC [SALL] ($SEG,$LIT,$HGH),<

;;		** Verify the first time here **

IF1,<
  IFDEF RL%SEG,<$PRINT F,RCO,$RELOCATION - $RELOCATION can only be called once> >

PURGE	RL%SEG,RL%LIT			;; Reset the world

;;		** Verify the segment option **

IFB <$SEG>,<RL%SEG==RL%TWO>		;; Two segment code (default)
IFIDNX <$SEG><MANY>,<RL%SEG==RL%MAN>	;; PSECT segment code
IFIDNX <$SEG><ONE>,<RL%SEG==RL%ONE>	;; One segment code
IFIDNX <$SEG><TWO>,<RL%SEG==RL%TWO>	;; Two segment code

IFNDEF RL%SEG,<$PRINT F,AUS,$RELOCATION - An undefined segment option ($SEG)>

;;		** Verify the literal option **

IFB <$LIT>,<RL%LIT==RL%OFF>		;; Don't dump literals (default)
IFIDNX <$LIT><LIT>,<RL%LIT==RL%ON>	;; Dump literals
IFIDNX <$LIT><NOLIT>,<RL%LIT==RL%OFF>	;; Don't dump literals

IFNDEF RL%LIT,<$PRINT F,AUL,$RELOCATION - An undefined literal option ($LIT)>

;;		** Set up the world correctly **

IFE <RL%SEG-RL%ONE>,<
  SYN $LOW,$HIGH			;; $HIGH and $LOW are the same
  RL%LOA==^O0				;; The low segment origin
  RELOC RL%LOA				;; Low segment code
  RL%LOL==RL%LOA			;; Low segment listing
  RL%LOR==. >				;; Low segment relative

IFE <RL%SEG-RL%TWO>,<
  IFB <$HGH><RL%HIA==^O400000>		;; The high segment origin (default)
  IFNB <$HGH>,<RL%HIA==<$HGH>>		;; The high segment origin
  TWOSEG RL%HIA				;; We want two segments
  RELOC RL%HIA				;; High segment code
  RL%HIL==RL%HIA			;; High segment listing
  RL%HIR==.				;; High segment relative
  RL%LOA==^O0				;; The low segment origin
  RELOC RL%LOA				;; Low segment code
  RL%LOL==RL%LOA			;; Low segment listing
  RL%LOR==. >				;; Low segment relative

IFE <RL%SEG-RL%MAN>,<
  IFB <$HGH>,<RL%HIA==-^O1>		;; No high segment origin
  IFNB <$HGH>,<
    RL%HIA==<$HGH>			;; The high segment origin
    .PSECT .HIGH.,RL%HIA		;; High segment address
    RL%HIL==RL%HIA			;; High segment listing
    RL%HIR==.				;; High segment relative
    .ENDPS >				;; End the high segment
  .PSECT				;; Low segment
  RL%SCL==-^O1 >			;; Section segment listing

RL%ABA==^O0				;; The absolute segment origin
RL%ABL==-^O1				;; Absolute segment listing

RL%ADR==RL%LOW				;; Low segment address

>					; End of 'DEFINE $RELOC'
	$TOC	Relocation Macros -- $ABS Macro


DEFINE	$ABS [SALL] ($ADR),<

IFNDEF RL%SEG,<$PRINT F,RHN,$ABS - $RELOCATION has not been called>

IFE <RL%LIT-RL%ON>,<$LIT NOLIST>	;; Dump the literal pool

IFL <RL%SEG-RL%MAN>,<			;; Non-PSECT code
  IFE <RL%ADR-RL%ABS>,<RL%ABA==.>	;; The absolute segment address
  IFE <RL%ADR-RL%LOW>,<RL%LOA==.>	;; The low segment address
  IFE <RL%ADR-RL%HGH>,<RL%HIA==.> >	;; The high segment address

IFE <RL%SEG-RL%MAN>,<			;; PSECT code
  IFE <RL%ADR-RL%ABS>,<RL%ABA==.>	;; The absolute segment address
  IFE <RL%ADR-RL%HGH>,<.ENDPS>		;; End the high segment
  IFE <RL%ADR-RL%SEC>,<.ENDPS> >	;; End the section

IFNB <$ADR>,<RL%ABA==<$ADR>>		;; The absolute segment address
LOC RL%ABA				;; Point to a absolute address
RL%ADR==RL%ABS				;; Absolute segment address

>					; End of 'DEFINE $ABS'
	$TOC	Relocation Macros -- $END Macro


DEFINE	$END [SALL] ($ADR),<

	XALL				;; Kludge

.IF $DSAPN,MACRO,<$DSAPN>		;; Clean up after $DS

IFDEF RL%SEG,<
  IFN <RL%SEG-RL%MAN>,<
    XLIST				;; Suppress the listing

    IFE <RL%SEG-RL%TWO>,<$LIT ,HIGH>	;; Dump the literals in high segment
    IFN <RL%SEG-RL%TWO>,<$LIT ,LOW>	;; Dump the literals in low segment
    $VAR ,LOW				;; Dump the variables

    LIST >				;; Restore the listing

  IFNB <$ADR>,<BE$ADR==^O1> >		;; Starting address

	$PURGE				;; Delete all the created symbols

	END	<$ADR>			;; End it all

>					; End of 'DEFINE $END'
	$TOC	Relocation Macros -- $HIGH Macro


DEFINE	$HIGH [SALL] ($ADR),<

IFNDEF RL%SEG,<$PRINT F,RHN,$HIGH - $RELOCATION has not been called>

IFE <RL%LIT-RL%ON>,<$LIT NOLIST>	;; Dump the literal pool

IFL <RL%SEG-RL%MAN>,<			;; Non-PSECT code
  IFE <RL%ADR-RL%ABS>,<RL%ABA==.>	;; The absolute segment address
  IFE <RL%ADR-RL%LOW>,<RL%LOA==.>	;; The low segment address
  IFE <RL%ADR-RL%HGH>,<RL%HIA==.>	;; The high segment address
  IFNB <$ADR>,<RL%HIA==<$ADR>>		;; The high segment address
  RELOC RL%HIA >			;; Point to a high address

IFE <RL%SEG-RL%MAN>,<			;; PSECT code
  IFE <RL%ADR-RL%ABS>,<
    RL%ABA==.				;; The absolute segment address
    RELOC >				;; Back to the low segment
  IFL <RL%HIA>,<RL%HIA==^O400000>	;; Get high segment base
  IFE <RL%ADR-RL%HGH>,<.ENDPS>		;; End the high segment
  IFE <RL%ADR-RL%SEC>,<.ENDPS>		;; End the segment
  .PSECT .HIGH. >			;; High segment address

RL%ADR==RL%HGH				;; High segment address

>					; End of 'DEFINE $HIGH'
	$TOC	Relocation Macros -- $LIT Macro


DEFINE	$LIT [SALL] ($LST,$SEG),<

IFNDEF RL%SEG,<$PRINT F,RHN,$LIT - $RELOCATION has not been called>

PURGE	LT%LST,LT%SEG			;; Reset some symbols

;;		** Verify the list option **

IFB <$LST><LT%LST==LT%ON>		;; List (default)
IFIDNX <$LST><LIST>,<LT%LST==LT%ON>	;; List
IFIDNX <$LST><NOLIST>,<LT%LST==LT%OFF>	;; No list

IFNDEF LT%LST,<$PRINT F,AUL,$LIT - An undefined list option ($LST)>

;;		** Verify the segment option **

IFB <$SEG>,<LT%SEG==LT%DEF>		;; Default
IFIDNX <$SEG><LOW>,<LT%SEG==LT%LOW>	;; Low
IFIDNX <$SEG><HIGH>,<LT%SEG==LT%HGH>	;; High

IFNDEF LT%SEG,<$PRINT F,AUS,$LIT - An undefined segment option ($SEG)>

;;		** Dump the literal pool **

IFE <LT%LST-LT%OFF>,<$LSTOF LIST>	;; Suppress the listing

IFE <LT%SEG-LT%LOW>,<$LOW>		;; Put the literals in the low segment
IFE <LT%SEG-LT%HGH>,<$HIGH>		;; Put the literals in the high segment

  LIT					;; Dump the literals

IFE <LT%LST-LT%OFF>,<$LSTON LIST>	;; Restore the listing

>					; End of 'DEFINE $LIT'
	$TOC	Relocation Macros -- $LOW Macro


DEFINE	$LOW [SALL] ($ADR),<

IFNDEF RL%SEG,<$PRINT F,RHN,$LOW - $RELOCATION has not been called>

IFE <RL%LIT-RL%ON>,<$LIT NOLIST>	;; Dump the literal pool

IFL <RL%SEG-RL%MAN>,<			;; Non-PSECT code
  IFE <RL%ADR-RL%ABS>,<RL%ABA==.>	;; The absolute segment address
  IFE <RL%ADR-RL%LOW>,<RL%LOA==.>	;; The low segment address
  IFE <RL%ADR-RL%HGH>,<RL%HIA==.>	;; The high segment address
  IFNB <$ADR>,<RL%LOA==<$ADR>>		;; The low segment address
  RELOC RL%LOA >			;; Point to a low address

IFE <RL%SEG-RL%MAN>,<			;; PSECT code
  IFE <RL%ADR-RL%ABS>,<
    RL%ABA==.				;; The absolute segment address
    RELOC >				;; Back to the low segment
  IFE <RL%ADR-RL%HGH>,<.ENDPS>		;; End the high segment
  IFE <RL%ADR-RL%SEC>,<.ENDPS> >	;; End the section

RL%ADR==RL%LOW				;; Low segment address

>					; End of 'DEFINE $LOW'
	$TOC	Relocation Macros -- $PRGEND Macro


DEFINE	$PRGEN [SALL] ($ADR),<

	XALL				;; Kludge

.IF $DSAPN,MACRO,<$DSAPN>		;; Clean up after $DS

IFDEF RL%SEG,<
  IFN <RL%SEG-RL%MAN>,<
    XLIST				;; Suppress the listing

    IFE <RL%SEG-RL%TWO>,<$LIT ,HIGH>	;; Dump the literals in high segment
    IFN <RL%SEG-RL%TWO>,<$LIT ,LOW>	;; Dump the literals in low segment
    $VAR ,LOW				;; Dump the variables

    LIST >	 			;; Restore the listing

  IFNB <$ADR>,<BE$ADR==^O1> >		;; Starting address

	BE$PRG==^O1			;; PRGENDed program

	$PURGE				;; Delete all the created symbols

	PRGEND	<$ADR>			;; End it all

>					; End of 'DEFINE $PRGEN'
	$TOC	Relocation Macros -- $SECTION Macro


DEFINE	$SECTI [SALL] ($SEC,$BAS),<

IFNDEF RL%SEG,<$PRINT F,RHN,$SECTION - $RELOCATION has not been called>
IFN <RL%SEG-RL%MAN>,<$PRINT F,NSS,$SECTION - Not setup for sections>

IFE <RL%LIT-RL%ON>,<$LIT NOLIST>	;; Dump the literal pool

IFE <RL%ADR-RL%ABS>,<
  RL%ABA==.				;; The absolute segment address
  RELOC >				;; Back to the low segment
IFE <RL%ADR-RL%HGH>,<.ENDPS>		;; End the high segment
IFE <RL%ADR-RL%SEC>,<.ENDPS>		;; End the section

IFB <$BAS>,<.PSECT $SEC>		;; Section segment address
IFNB <$BAS>,<.PSECT $SEC,<$BAS>>	;; Section segment address

RL%ADR==RL%SEC				;; Section segment address

>					; End of 'DEFINE $SECTI'
	$TOC	Relocation Macros -- $VAR Macro


DEFINE	$VAR [SALL] ($LST,$SEG),<

IFNDEF RL%SEG,<$PRINT F,RHN,$VAR - $RELOCATION has not been called>

PURGE	VR%LST,VR%SEG			;; Reset some symbols

;;		** Verify the list option **

IFB <$LST><VR%LST==VR%ON>		;; List (default)
IFIDNX <$LST><LIST>,<VR%LST==VR%ON>	;; List
IFIDNX <$LST><NOLIST>,<VR%LST==VR%OFF>	;; No list

IFNDEF VR%LST,<$PRINT F,AUL,$VAR - An undefined list option ($LST)>

;;		** Verify the segment option **

IFB <$SEG>,<VR%SEG==VR%DEF>		;; Default
IFIDNX <$SEG><LOW>,<VR%SEG==VR%LOW>	;; Low
IFIDNX <$SEG><HIGH>,<VR%SEG==VR%HGH>	;; High

IFNDEF VR%SEG,<$PRINT F,AUS,$VAR - An undefined segment option ($SEG)>

;;		** Dump the literal pool **

IFE <VR%LST-VR%OFF>,<$LSTOF LIST>	;; Suppress the listing

IFE <VR%SEG-VR%LOW>,<$LOW>		;; Put the variables in the low segment
IFE <VR%SEG-VR%HGH>,<$HIGH>		;; Put the variables in the high segment

   VAR					;; Dump the variables

IFE <VR%LST-VR%OFF>,<$LSTON LIST>	;; Restore the listing

>					; End of 'DEFINE $VAR'
	$TOC	Data Structure Macros -- Descriptions


; Description of the '$DS' macros:
;
;   1)  $DSBEG ($PFX,$TYP,$SYM,$BEG,$MAX,$TST)  ; Define a data structure
;
;         $PFX - The two (2) character symbol prefix.
;
;         $TYP - The code for the initial mask to be used.
;		   ALIGN  - This will start the data structure in the
;			    first word following an existing data
;			    structure.  If this option is used, the
;			    "$SYM" argument should be given to spec-
;			    ify the end of the data structure that
;			    this will be aligned with.
;		   APPEND - This is similar to ALIGN except that the
;			    new data structre will be started in the
;			    first available byte in the last word of
;			    the data structure that this will be
;			    appended to.
;		   CALL   - This specified that the argument block has
;			    a subroutine address in the right 23 bits
;			    the first word (used by standard SYSUNV
;			    calling convention).  This will cause only
;			    the non-address bits (opcode and AC fields)
;			    of the first word in the data structure to
;			    be used.
;		   MASK   - This specifies that the user wants to
;			    specified his own mask for the initial word
;			    of the data structure, see $SYM.
;		   NORMAL - This is used in the normal case.  All of the
;			    first word of the data structure will be
;			    used.  This is the default if this field is
;			    omitted.
;		 Note:  The default is NORMAL.
;
;	  $SYM - The symbol to use for the ALIGN and APPEND.
;
;	  $BEG - The starting offset to be used.  Note:  The
;		 default is 0, unless $SYM is supplied, then its
;		 offset will be used.
;
;         $MAX - The maximum number of words allowed in the data
;                structure, the default is .WDINF .
;
;         $TST - The feature test value, non-zero == define the symbol/-
;                flag.  The default is -1.
;
;   2)  $DSFLG ($SFX,$WID,$FLG,$TST)	; Define a flag
;
;         $SFX - The three (3) character flag symbol suffix.
;
;         $WID - The width of the flag or a keyword, the default is one
;                (1).
;                  ADDRESS  - An address is wanted, the low order 23
;                             bits of a word.
;                  LEFT     - A left half word is wanted.
;                  HALF     - A half word is wanted.
;                  REDEFINE - Redefines the previous flag given.
;                  RIGHT    - A right half word is wanted.
;                  WORD     - A whole word is wanted.
;
;	  $FLG - The flag to be redefined back to before the above
;		 symbol is to be defined.
;
;         $TST - The feature test value, non-zero == define the symbol/-
;                flag.  The default is -1.
;
;   3)  $DSVAL ($SFX,$VAL,$TST)		; Define a value for flag
;
;         $SFX - The three (3) character value symbol suffix.
;
;         $VAL - The value to use for this value symbol, default is use
;                the previous value plus one (1).
;
;         $TST - The feature test value, non-zero == define the symbol/-
;                value.  The default is -1.
;
;   4)  $DSBIT ($SFX,$REL,$VAL,$TST)	; Define a bit for flag
;
;         $SFX - The three (3) character bit symbol suffix.
;
;         $REL - The type of relative bit symbol to create.
;                  BYTE - Create a bit symbol that is realtive to the
;                         byte symbol created.
;                  WORD - Create a bit symbol that is relative to the
;                         word the byte is created within.
;                Note: The default is WORD.
;
;         $VAL - The value to use for this bit symbol, defalut is use
;                the previous bit shift one (1) to the right.
;
;         $TST - The feature test value, non-zero == define the symbol/-
;                bit.  The default is -1.
;
;   5)  $DSBYT ($SFX,$BYT,$SIZ,$TST)	; Assign some bytes
;
;	  $SFX - The three (3) character byte symbol suffix.
;
;	  $BYT - The size of the byte or one of the following keywords:
;		   ASCII  - The byte size is 7.
;		   ASCIZ  - The byte size is 7 and the size specified
;			    will be increased by one.
;		   EBCDIC - The byte size is 8.
;		   HALF   - The byte size is 18.
;		   SIXBIT - The byte size is 6.
;		   WORD   - The byte size is 36.
;		 The default is ASCIZ.
;
;	  $SIZ - The number of bytes to be allocated.  The default is 1.
;
;	  $TST - The feature test value, non-zero == define the byte
;		 array.  The default is -1.
;
;   5)  $DSWRD ($SFX,$SIZ,$TST)		; Define a word array
;
;         $SFX - The three (3) character array suffix.
;
;         $SIZ - The size of the array in words, the default is one
;                (1).
;
;         $TST - The feature test value, non-zero == define the symbol/-
;                array.  The default is -1.
;
;   6)  $DSNXT ($TST)			; Word align the next flag
;
;         $TST - The feature test value, non-zero == word align the data
;		 structure.  The default is -1.
;
;   7)  $DSSKP ($WRD,$TST)		; The number of word to skip
;
;         $WRD - The number of words (hole or partical) to skip.  The
;		 default is 1.
;
;         $TST - The feature test value, non-zero == skip the words.  The
;		 default is -1.
;
;   8)  $DSEND ($PFX,$LEN)		; End of the data structure
;
;         $PFX - The same two (2) character prefix as was given to
;                be $DSBEG macro.
;
;         $LEN - The three (3) character length symbol suffix.
;
;   9)  $MOVE ($REG,$FLG,$BAS)		; Move a flag into a register
;
;         $REG - The register to be loaded.
;
;         $FLG - The flag to be loaded, in the form of DS%FLG or DS.FLG.
;
;         $BAS - The base address offset of the data structure.
;
;  10)  $MOVEM ($REG,$FLG,$BAS)		; Store a register in a flag
;
;         $REG - The register to be stored.
;
;         $FLG - The flag where the register is to be stored, in the
;                form of DS%FLG or DS.FLG.
;
;         $BAS - The base address offset of the data structure.
; Define the data structure used by the $ZERO and $ONES macros:

	$DSBEG    DS			; The $ZERO and $ONES data structure:
	 $DSFLG   FNC,^D1		 ; The function field
	  $DSVAL  ZER,^D0		  ; Zero
	  $DSVAL  ONE,^D1		  ; Ones
	 $DSFLG   PTR,WORD		 ; The pointer field
	$DSEND    DS			; That's all


; Define the data structure used by the $BLT macro:

	$DSBEG    DS			; The $BLT data structure:
	 $DSFLG   FNC,^D3		 ; The function field
	 $DSFLG   BAF,WORD		 ; The 'from' base address field
	 $DSFLG   BAT,WORD		 ; The 'to' base address field
	 $DSFLG   BP1,WORD		 ; The starting byte pointer field
	 $DSFLG   BP2,WORD		 ; The ending byte pointer field
	$DSEND    DS			; That's all
	$TOC	Data Structure Macros -- The Macros


DEFINE	$DSBEG [SALL] ($PFX,$TYP,$SYM,$BEG,$MAX,$TST<-^O1>,%BYT,%CNT,%DEF,%FLG,%MAX,%MSK,%POS,%SIZ,%STR,%TMP,%TES,%VAL,%WID,%WRD),<

;;		** See if the data structure should be turned on **

IFN <$TST>,<
  %BYT==<%CNT==<%DEF==<%FLG==<%MAX==<%MSK==<%POS==<%SIZ==<%STR==<%TMP==<%TES==<%VAL==<%WID==<%WRD==^O0>>>>>>>>>>>>>
  .XCREF %BYT,%CNT,%DEF,%FLG,%MAX,%MSK,%POS,%SIZ,%STR,%TMP,%TES,%VAL,%WID,%WRD

;;		** Verify that everything was cleaned up **

  .IF $DSEND,MACRO,<$DSEND (,,Clean-up)>;;Clean up for the user


;;		** Define the $DSBE1 macro **

  DEFINE $DSBE1 [SALL] ($FNC),<

  IFB <$SYM>,<
    .IFN $DSAPN,MACRO,<$PRINT F,NPD,$DSBEG - No previous data structure defined ($PFX)>
    $DSAPN ($TYP,%WRD,%WID,%CNT,%POS) >	;; Use old symbol

  IFNB <$SYM>,<
    .IFN $SYM,SYMBOL,<$PRINT F,IDN,$DSBEG - Illegal data name ($PFX, $SYM)>
    %TMP==<EXP <SIXBIT ~$SYM~>>
    %STR==^O0
    IFE <%TMP&^O006000000000>,<		;; One character
      %STR==<%TMP_-^D30>
      %FLG==<%TMP&^O77777777B35> >
    IFE <%TMP&^O000060000000>,<		;; Two characters
      %STR==<%TMP_-^D24>
      %FLG==<%TMP&^O777777B35> >
    .IFE <%STR>,<$PRINT F,IDN,$DSBEG - Illegal data name ($PFX, $SYM)>
    $DSBE2 ($FNC,\'%STR,\'%FLG) >	;; Redefine structure

  >					;; End of 'DEFINE $DSBE1'


;;		** Define the $DSBE2 macro **

  DEFINE $DSBE2 [SALL] ($FNC,$STR,$FLG),<

  %WID==^D0				;; Get the previous width

  IFIDNX <$FNC><ALIGN>,<
    %WRD==$STR'.'$FLG+^O1		;; Get the relative offset
    %CNT==.WDWRD			;; Get the width
    %POS==.WDWRD >			;; Get the position

  IFIDNX <$FNC><APPEND>,<
    %WRD==$STR'.'$FLG			;; Get the relative offset
    %CNT==$ALIGN($STR'%'$FLG)		;; Get the width
    %POS==%CNT >			;; Get the position

  IFIDNX <$FNC><NEW>,<
    %WRD==^O0				;; Get the relative offset
    %CNT==$WID(<$STR>)			;; Get the width
    %POS==%CNT+$ALIGN(<$STR>) >		;; Get the position

  IFIDNX <$FNC><REDEFINE>,<
    %WRD==$STR'.'$FLG			;; Get the relative offset
    %CNT==$WID($STR'%'$FLG)+$ALIGN($STR'%'$FLG)  ;; Get the width
    %POS==%CNT >			;; Get the position

  >					;; End of 'DEFINE $DSBE2'

;;		** Verify the prefix option **

  IFN <<''$PFX''>&^O777777770000>,<	;; Only two characters
    $PRINT F,AIP,$DSBEG - An illegal prefix ($PFX)>

;;		** Verify the type option **

  IFB <$TYP>,<$DSBE2 (NEW,WD%WRD)>		    ;; Default (Normal)
  IFIDNX <$TYP><ALIGN>,<$DSBE1 (ALIGN,$SYM)>	    ;; Align
  IFIDNX <$TYP><APPEND>,<$DSBE1 (APPEND,$SYM)>	    ;; Append
  IFIDNX <$TYP><CALL>,<$DSBE2 (NEW,IC%OPC!IC%ACF)>  ;; Call
  IFIDNX <$TYP><MASK>,<$DSBE2 (NEW,<$SYM>)>	    ;; Mask
  IFIDNX <$TYP><NORMAL>,<$DSBE2 (NEW,WD%WRD)>	    ;; Normal

;;		** Verify the beginning option **

  IFNB <$BEG>,<
    IFL <$BEG>,<$PRINT F,IBV,$DSBEG - Illegal beginning value ($PFX, $BEG)>
    %WRD==<$BEG> >			;; Get the relative offset

;;		** Verify the maximum option **

  IFB <$MAX>,<%MAX==.WDINF>		;; Default
  IFNB <$MAX>,<%MAX==<$MAX>>		;; Get the maximum

  IFLE <%MAX>,<$PRINT F,AIM,$DSBEG - An illegal maximum specified ($PFX, $MAX)>
  IFGE <%WRD-%MAX>,<$PRINT F,TMW,$DSBEG - Too many words used ($PFX, $MAX)>


;;		** Define the $DSFLG macro **

  DEFINE $DSFLG [SALL] ($SFX,$WID,$RED,$TES<-^O1>),<

  %TMP==^O0				;; .FALSE.

  %TES==<$TES>				;; Feature test value

  IFN <%TES>,<				;; Don't assemble is flag

;;		** Verify the redefine option **

    IFNB <$RED>,<
      .IFN $PFX'.'$RED,SYMBOL,<$PRINT F,UNS,$DSFLG - Undefined symbol ($PFX'.'$RED) >
      $DSBE2 (REDEFINE,$PFX,$RED) >	;; Redefine to previous symbol

;;		** Verify the width option **

    IFDIFX <$WID><DOUBLE>,<
      IFIDNX <$WID><ADDRESS>,<$DSFL1 IC%ADR>	    ;; Address
      IFIDNX <$WID><LEFT>,<$DSFL1 WD%LFT>	    ;; Left half
      IFIDNX <$WID><HALF>,<$DSFL1 <WD%LFT,WD%RIT>>  ;; Half word
      IFIDNX <$WID><REDEFINE>,<			    ;; Redefine the last flag
        %TMP==-^O1				    ;; .TRUE.
        IFE <%WID>,<$PRINT F,NPM,$DSFLG - No previous mask available ($PFX, $SFX)> >
      IFIDNX <$WID><RIGHT>,<$DSFL1 WD%RIT>	    ;; Right half
      IFIDNX <$WID><WORD>,<$DSFL1 WD%WRD>	    ;; Full word
      IFE %TMP,<
        IFB <$WID>,<%TMP==^D1>			    ;; Default
        IFNB <$WID>,<%TMP==<$WID>>
        IFLE <%TMP>,<$PRINT F,IWS,$DSFLG - Illegal width specified ($PFX, $SFX, $WID)>
        IFG <<%TMP>-.WDWRD>,<$PRINT F,IWS,$DSFLG - Illegal width specified ($PFX, $SFX, $WID)>
        IFL <%CNT-%TMP>,<$DSNXT>	;; Time for next word
        %WID==<%TMP>
        %CNT==%CNT-<%WID>
        %POS==%POS-<%WID> >
      %VAL==<-^O1>
      $PFX'.'$SFX==%WRD			;; Define the word offset
      $PFX'%'$SFX==<<^O1_%WID-^O1>_%POS>;; Define the mask
      $PFX'$'$SFX==%POS >		;; Define the shift offset

    IFIDNX <$WID><DOUBLE>,<$DSWRD $SFX,^O2> >	    ;; Double word
  ;[CSM] Reference bit mask so it shows up in the listing
  $PFX'%'$SFX==$PFX'%'$SFX>		;; End of 'DEFINE $DSFLG'


;;		** Define the $DSFL1 macro **

  DEFINE $DSFL1 [SALL] ($MSK),<

  %DEF==^O1
  %MSK==^O1
  %TMP==^O0

  IRP <$MSK>,<
    IFE <$MSK>,<$PRINT F,IMG,$DSFLG - Illegal mask given ($PFX, $MSK)>
    IFG <$ALIGN($LFTBT($MSK))-$ALIGN($LFTBT(%DEF))>,<%DEF==<$MSK>>
    IFE <<$MSK>&<<<^O1_%CNT-^O1>_<%POS-%CNT>>^!<$MSK>>>,<
      IFG <$ALIGN($LFTBT($MSK))-$ALIGN($LFTBT(%MSK))>,<
        %MSK==<$MSK>
        %TMP==^O1 >>>
  IFE <%TMP>,<
    %MSK==%DEF
    $DSNXT >				;; Get the next word

  %WID==$WID(%MSK)			;; Get the previous width
  %CNT==$ALIGN(%MSK)-<%POS-%CNT>	;; Get the width
  %POS==$ALIGN(%MSK)			;; Get the position

  %TMP==-^O1				;; .TRUE.

  >					;; End of 'DEFINE $DSFL1'


;;		** Define the $DSVAL macro **

  DEFINE $DSVAL [SALL] ($SFX,$VAL,$TES<-^O1>),<

  IFN <<$TES>*<%TES>>,<			;; Don't assemble values
    IFB <$VAL>,<			;; Assume old value plus 1
      %VAL==<%VAL+^O1> >

    IFNB <$VAL>,<			;; Use given value
      IFDIFX <$VAL><REDEFINE>,<
        %VAL==<$VAL> >>

    IFN <%WID-.WDWRD>,<
      IFL <%VAL>,<
        $PRINT F,IFV,$DSVAL - Illegal flag value ($PFX, $SFX, $VAL) >
      IFG <%VAL-<^O1_<%WID>-^O1>>,<
        $PRINT F,TMV,$DSVAL - Too many values defined ($PFX, $SFX, $VAL) >>

    ;[CSM] Moved angle brackets to value will show up in CREF listing
    .'$PFX''$SFX==%VAL >  >		;; End of 'DEFINE $DSVAL'

;;		** Define the $DSBIT macro **

  DEFINE $DSBIT [SALL] ($SFX,$REL,$VAL,$TES<-^O1>),<

  IFN <<$TES>*<%TES>>,<			;; Don't assemble bits
    IFB <$VAL>,<
      %VAL==<%VAL+^O1> >

    IFNB <$VAL>,<
      IFDIFX <$VAL><REDEFINE>,<
        %VAL==<$VAL> >>

    IFL <%VAL>,<
      $PRINT F,IFB,$DSBIT - Illegal flag bit ($PFX, $SFX, $VAL) >
    IFGE <%VAL-%WID>,<
      $PRINT F,TMB,$DSBIT - Too many bits defined ($PFX, $SFX, $VAL) >

    IFB <$REL>,<			;; Word relative (default)
      %'$PFX''$SFX==<^O1_<%WID-%VAL+%POS-^O1>> >
    IFIDNX <$REL><BYTE>,<		;; Byte relative
      %'$PFX''$SFX==<^O1_<%WID-%VAL-^O1>> >
    IFIDNX <$REL><WORD>,<		;; Word relative
      %'$PFX''$SFX==<^O1_<%WID-%VAL+%POS-^O1>> >
    IFNDEF %'$PFX''$SFX,<
      $PRINT F,IRS,$DSBIT - Illegal relative value sepecified ($PFX, $SFX, $REL) >>
  ;[CSM] Reference bit mask so it shows up in the listing
  %'$PFX''$SFX==%'$PFX''$SFX  >		;; End of 'Define $DSBIT'


;;		** Define the $DSBYT macro **

  DEFINE $DSBYT [SALL] ($SFX,$BYT,$SIZ<^D1>,$TES<-^O1>),<

  IFN <$TES>,<

    %BYT==^D0
    %TMP==^O0

    IFB <$BYT>,<	 		;; Default (ASCIZ)
      %BYT==^D7
      %TMP==^O1 >
    IFIDNX <$BYT><ASCII>,<%BYT==^D7>	;; ASCII
    IFIDNX <$BYT><ASCIZ>,<		;; ASCIZ
      %BYT==^D7
      %TMP==^O1 >
    IFIDNX <$BYT><EBCDIC>,<%BYT==^D8>	;; EBCDIC
    IFIDNX <$BYT><HALF>,<%BYT==.DWHLF>	;; Half
    IFIDNX <$BYT><SIXBIT>,<%BYT==^D6>	;; SIXBIT
    IFIDNX <$BYT><WORD>,<%BYT==.DWWRD>	;; Word
    IFE <%BYT>,<%BYT==<$BYT>>

    IFLE <%BYT>,<
      $PRINT F,IBS,$DSBYT - Illegal byte size ($PFX, $SFX, $BYT)>
    IFG <%BYT-.WDWRD>,<
       $PRINT F,IBS,$DSBYT - Illegal byte size ($PFX, $SFX, $BYT)>

    IFLE <$SIZ>,<
      $PRINT F,INB,$DSBYT - Illegal number of bytes to allocate ($PFX, $SFX, $SIZ)>

    %SIZ==%TMP+<$SIZ>

    IFGE <<%CNT/%BYT>-%SIZ>,<
      $PFX'.'$SFX==%WRD			;; Define the word offset
      $PFX'%'$SFX==<<^O1_%BYT-^O1>_<%POS-%BYT>>  ;; Define the mask
      $PFX'$'$SFX==-%SIZ+%TMP		;; Define the byte length

      %CNT==%CNT-<%BYT*%SIZ>
      %POS==%POS-<%BYT*%SIZ>
      %SIZ==^O0 >

    IFN <%SIZ>,<
      IFN <%CNT-%POS>,<$DSNXT>
      IFL <%CNT-%BYT>,<$DSNXT>
      $PFX'.'$SFX==%WRD			;; Define the word offset
      $PFX'%'$SFX==<<^O1_%BYT-^O1>_<%POS-%BYT>>  ;; Define the mask
      $PFX'$'$SFX==-%SIZ+%TMP		;; Define the byte length

      %TMP==%SIZ-<%CNT/%BYT>
      IFG <%TMP>,<%SIZ==%TMP>
      %TMP==%SIZ/<.WDWRD/%BYT>
      IFN <%TMP>,<
        %SIZ==%SIZ-<<.WDWRD/%BYT>*%TMP>
        $DSSKP (%TMP)
        %CNT==%CNT-<<.WDWRD/%BYT>*%BYT>
        %POS==%POS-<<.WDWRD/%BYT>*%BYT> >
      IFN <%SIZ>,<
        $DSSKP
        %CNT==%CNT-<%BYT*%SIZ>
        %POS==%POS-<%BYT*%SIZ> >>

    %WID==%BYT
    %VAL==-^O1 >
  ;[CSM] Reference bit mask so it shows up in the listing
  $PFX'%'$SFX==$PFX'%'$SFX >		;; End of 'DEFINE $DSBYT'


;;		** Define the $DSWRD macro **

  DEFINE $DSWRD [SALL] ($SFX,$SIZ<^O1>,$TES<-^O1>),<

  IFN <$TES>,<
    IFLE <$SIZ>,<
      $PRINT F,INW,$DSWRD - Illegal number of words to skip ($PFX, $SFX, $SIZ) >

    $DSNXT				;; Get word aligned

    $PFX'.'$SFX==%WRD			;; Define the word offset
    $PFX'%'$SFX==WD%WRD			;; Define the mask
    $PFX'$'$SFX==-<$SIZ>		;; Define the shift offset

    IFE <$SIZ-^O1>,<
      %WID==.WDWRD			;; The width is of one word
      %VAL==-^O1 >			;; Allow values to be defined
    IFN <$SIZ-^O1>,<
      %WID==^O0 >			;; The width is of one word

    %WRD==%WRD+<$SIZ>			;; Get the next available word
    IFGE <%WRD-%MAX>,<$PRINT F,TMW,$DSWRD - Too many words used ($PFX, $SFX, $MAX)> >

  ;[CSM] Reference word offset so it shows up in the listing
  $PFX'.'$SFX==$PFX'.'$SFX >		;; End of 'DEFINE $DSWRD'


;;		** Define the $DSNXT macro **

  DEFINE $DSNXT [SALL] ($TES<-^O1>),<

  IFN <$TES>,<
    IFN <%CNT-.WDWRD>,<
      %WRD==%WRD+^O1			;; Time for next word
      %WID==^D0				;; Get the previous width
      %CNT==.WDWRD			;; Get the width
      %POS==.WDWRD			;; Get the position

      IFGE <%WRD-%MAX>,<$PRINT F,TMW,$DSNXT - Too many words used ($PFX, $MAX)> >>

  ;[CSM] Reference word offset so it shows up in the listing
  %WRD==%WRD   >			;;End of 'DEFINE $DSNXT'

;;		** Define the $DSSKP macro **

  DEFINE $DSSKP [SALL] ($WRD<^O1>,$TES<-^O1>),<

  IFN <$TES>,<

    IFLE <$WRD>,<$PRINT F,INW,$DSSKP - Illegal number of words to skip ($PFX, $WRD)>

    %WRD==%WRD+<$WRD>			;; Get the next available word
    %WID==^D0				;; Get the previous width
    %CNT==.WDWRD			;; Get the width
    %POS==.WDWRD			;; Get the position

    IFGE <%WRD-%MAX>,<$PRINT F,TMW,$DSSKP - Too many word used ($PFX, $WRD, $MAX)> >

  ;[CSM] Reference word offset so it shows up in the listing
  %WRD==%WRD   >			;;End of 'DEFINE $DSSKP'


;;		** Define the $DSAPN macro **

  .IF $DSAPN,MACRO,<$DSAPN (Clean-up)>	;; Clean up old stuff

  DEFINE $DSAPN [SALL] ($FNC,$WRD,$WID,$CNT,$POS),<

  IFIDNX <$FNC><ALIGN>,<		;; Align
    IFN <%CNT-.WDWRD>,<%WRD==%WRD+^O1>	;; Time for next word
    $WRD==%WRD				;; Get the relative offset
    $WID==^D0				;; Get the previous width
    $CNT==.WDWRD			;; Get the width
    $POS==.WDWRD >			;; Get the position

  IFIDNX <$FNC><APPEND>,<		;; Append
    $WRD==%WRD				;; Get the relative offset
    $WID==^D0				;; Get the previous width
    $CNT==%CNT				;; Get the width
    $POS==%POS >			;; Get the position

  PURGE $DSAPN				;; Clean-up
  IF2,<					;;  after
    PURGE %CNT,%POS,%WRD >		;;  ourselves

  >					;; End of 'DEFINE $DSAPN'


;;		** Define the $DSEND macro **

  DEFINE $DSEND [SALL] ($SFX,$LEN,$MSG,%LEN),<;;[CSM] Added %LEN

;;		** Define the length **

  IFE <%POS-.WDWRD>,<
    %LEN==%WRD >
  IFN <%POS-.WDWRD>,<
    %LEN==%WRD+^O1 >
  IFNB <$LEN>,<
    $PFX'.'$LEN==%LEN >
  IFB <$LEN>,<IFE <%WRD>,<
    %LEN==0>> ;;[CSM] Show zero for flag bits that all fit in one AC

  .XCREF %LEN ;;[CSM]

;;		** Clean up after ourselves **

  PURGE $DSBE1,$DSBE2,$DSFLG,$DSFL1,$DSVAL,$DSBIT,$DSBYT,$DSWRD,$DSNXT,$DSEND
  IF2,<
    PURGE %BYT,%DEF,%FLG,%MAX,%MSK,%SIZ,%STR,%TMP,%TES,%VAL,%WID >

;;		** Verify the correct data structure was given **

  IFNB <$SFX>,<
    IFDIFX <$PFX><$SFX>,<
      $PRINT F,AIP,$DSEND - An illegal prefix ($DSBEG=$PFX, $DSEND=$SFX) >>

  IFNB <$MSG>,<
    $PRINT I,MWC,$DSBEG - The $DSEND macro wasn't called ($PFX) >

  ;[CSM] Reference length so it shows up in the listing
  IFN <%LEN>,<%LEN==%LEN>  > >		;; End of 'DEFINE $DSEND'


;;		** See if the data structure should be turned off **

IFE <$TST>,<
  DEFINE $DSFLG [SALL] ($SFX,$WID,$RED,$TES),<>
  DEFINE $DSVAL [SALL] ($SFX,$VAL,$TES),<>
  DEFINE $DSBIT [SALL] ($SFX,$VAL,$TES),<>
  DEFINE $DSBYT [SALL] ($SFX,$BYT,$SIZ,$TES),<>
  DEFINE $DSWRD [SALL] ($SFX,$SIZ,$TES),<>
  DEFINE $DSNXT [SALL] ($TES),<>
  DEFINE $DSSKP [SALL] ($WRD,$TES),<>
  DEFINE $DSEND [SALL] ($SFX,$LEN,$MSG),<

;;		** Define the length **

  IFNB <$LEN>,<$PFX'.'$LEN==^O0>

;;		** Clean up after ourselves **

  PURGE $DSFLG,$DSVAL,$DSBIT,$DSBYT,$DSWRD,$DSNXT,$DSSKP,$DSEND

;;		** Verify the correct data structure was given **

  IFNB <$SFX>,<
    IFDIFX <$PFX><$SFX>,<
      $PRINT F,AIP,$DSEND - An illegal prefix ($DSBEG=$PFX, $DSEND=$SFX) >>

  IFNB <$MSG>,<
    $PRINT I,MWC,$DSBEG - The $DSEND macro wasn't called ($PFX) >

  > >					;; End of 'DEFINE $DSEND'

>					; End of 'DEFINE $DSBEG'


; $MOVE - A macro to get a chunk of information from a data structure.

DEFINE	$MOVE [SALL] ($REG,$FLG,$BAS),<

.IFN $FLG,SYMBOL,<$PRINT F,IDN,$MOVE - Illegal data name ($FLG) >

..MX1==<EXP <SIXBIT ~$FLG~>>
..MX2==^O0

IFE <..MX1&^O006000000000>,<		;; One character
  ..MX2==<..MX1_-^D30>
  ..MX3==<..MX1&^O77777777B35> >
IFE <..MX1&^O000060000000>,<		;; Two characters
  ..MX2==<..MX1_-^D24>
  ..MX3==<..MX1&^O777777B35> >

IFE <..MX2>,<$PRINT F,IDN,$MOVE - Illegal data name ($FLG)>

	$DSGEN ($REG,\'..MX2,\'..MX3,$BAS,DMOVE,MOVE,HLRZ,HRRZ,LDB)

>					; End of 'DEFINE $MOVE'


; $MOVEM - A macro to store a chunk of information into a 'data
;          structure.

DEFINE	$MOVEM [SALL] ($REG,$FLG,$BAS),<

.IFN $FLG,SYMBOL,<$PRINT F,IDN,$MOVEM - Illegal data name ($FLG)>

..MX1==<EXP <SIXBIT ~$FLG~>>
..MX2==^O0

IFE <..MX1&^O006000000000>,<		;; One character
  ..MX2==<..MX1_-^D30>
  ..MX3==<..MX1&^O77777777B35> >
IFE <..MX1&^O000060000000>,<		;; Two characters
  ..MX2==<..MX1_-^D24>
  ..MX3==<..MX1&^O777777B35> >

IFE <..MX2>,<$PRINT F,IDN,$MOVEM - Illegal data name ($FLG)>

	$DSGEN ($REG,\'..MX2,\'..MX3,$BAS,DMOVEM,MOVEM,HRLM,HRRM,DPB)

>					; End of 'DEFINE $MOVEM'


DEFINE	$DSGEN [SALL] ($REG,$STR,$FLG,$BAS,$DBL,$WRD,$LFT,$RIT,$BYT),<

%WID==$WID($STR'%'$FLG)
%POS==$STR'$'$FLG

IFGE <%POS>,<
  IFE <%WID-.WDWRD>,<
	$WRD	$REG,$STR'.'$FLG+$BAS >	;; Full word
  IFN <%WID-.WDWRD>,<
    IFE <%WID-.WDHLF>,<
      IFE <%POS-.WDHLF>,<
	$LFT	$REG,$STR'.'$FLG+$BAS >	;; Left half
      IFE <%POS-^D0>,<
	$RIT	$REG,$STR'.'$FLG+$BAS >	;; Right half
      IFN <<%POS-^D0>*<%POS-.WDHLF>>,<
	$BYT	$REG,[$POINT (<$STR'.'$FLG'+$BAS>,$STR'%'$FLG)] >>  ;; A byte
    IFN <%WID-.WDHLF>,<
	$BYT	$REG,[$POINT (<$STR'.'$FLG'+$BAS>,$STR'%'$FLG)] >>> ;; A byte
IFL <%POS>,<
  IFE <%POS+^O1>,<
	$WRD 	$REG,$STR'.'$FLG+$BAS >	;; Full word
  IFE <%POS+^O2>,<
	$DBL	$REG,$STR'.'$FLG+$BAS >	;; Double word
  IFL <%POS+^O2>,<$PRINT F,UMT,$'$WRD - Unable to move more that two words>>

>					; End of 'DEFINE $DSGEN'
; STORE ($REG,$FST,$LST,$VAL) Puts $VAL in $FST thru $LST.

DEFINE	STORE [SALL] ($REG,$FST,$LST,$VAL),<

;;		** Generate the right value **

IFE <$VAL>,<
	SETZM	<$FST> >		;; If $VAL=0, set $FST to 0

IFE <<$VAL>+^O1>,<
	SETOM	<$FST> >		;; If $VAL=-1, set $FST to -1

IFN <<$VAL>*<<$VAL>+^O1>>,<
	MOVX	$REG,<$VAL>		;; Else do it
	MOVEM	$REG,<$FST> >		;;  the hard way

;		** See if the BLT is wanted **

IFNB <$LST>,<				;; If more than one location
	MOVE	$REG,[<$FST>,,<$FST>+^O1]  ;; Distribute
	BLT	$REG,<$LST> >	           ;;  the value

>					; End of 'DEFINE STORE'
	$TOC	'X' Macros -- $FLAGS Description


; Macro  $FLAG defines a list of flags as being in a particular register
; in such a fashion that the bits are assigned at assembly time and  the
; register and bits are "remembered" for future use in the TX?? macros.

; General format of the flag pointer:

;  !================================================================!
;  ! Position ! Width !               Address of flag               !
;  !================================================================!


	$DSBEG    FL			; The $FLAG data structure
	 $DSFLG   POS,^D6		 ; The position field
	 $DSFLG   WID,^D6		 ; The width field
	 $DSFLG   ADR,ADDRESS		 ; The address field
	$DSEND    FL			; That's all
	$TOC	<'X' Macros -- $FLAGS, $FLAG and $VALUE Macros>


DEFINE	$FLAGS [SALL] ($PFX,$MSK<-^O1>,$ADR,%POS,%CNT),<

%CNT==$WID(<$MSK>)
%POS==%CNT+$ALIGN(<$MSK>)

IFB <$ADR>,<

  DEFINE $FLAG [SALL] ($FLG,$WID<^D1>,$VAL),<

  $LSTOF CREF

  IFLE <$WID>,<$PRINT F,IWS,$FLAG - Illegal width specified ($WID)>

  %POS==%POS-<$WID>
  %CNT==%CNT-<$WID>

  IFL <%CNT>,<$PRINT F,TMF,$FLAG - Too many flags defined ($PFX''$FLG)>

  $LSTON CREF

  $PFX''$FLG==<<^O1_<$WID>-^O1>_<%POS>>
  $FLAG1 (<$VAL>,<$WID>)
  $PFX''$FLG==$PFX''$FLG> >;;[CSM] Put in listing file	; End of 'DEFINE $FLAG'

IFNB <$ADR>,<

  DEFINE $FLAG [SALL] ($FLG,$WID<^D1>,$VAL),<

  $LSTOF CREF

  IFLE <$WID>,<$PRINT F,IWS,$FLAG - Illegal width specified ($WID)>

  %POS==%POS-<$WID>
  %CNT==%CNT-<$WID>

  IFL <%CNT>,<$PRINT F,TMF,$FLAG - Too many flags defined ($PFX''$FLG)>

  $LSTON CREF

  $PFX''$FLG==<<<%POS>_FL$POS>!<<$WID>_FL$WID>!<$ADR>>
  $FLAG1 (<$VAL>,<$WID>)
  $PFX''$FLG==$PFX''$FLG> >;;[CSM] Put in listing file	; End of 'DEFINE $FLAG'

>					; End of 'DEFINE $FLAGS'
DEFINE	$FLAG1 [SALL] ($PFX,$WID,%VAL),<

IFB <$PFX>,<PURGE $VALUE>

IFNB <$PFX>,<

%VAL==<-^O1>


DEFINE	$VALUE [SALL] ($FLG,$VAL),<

IFB <$VAL>,<
  $PFX''$FLG==<%VAL==<%VAL+1>> >

IFNB <$VAL>,<
  $PFX''$FLG==<%VAL==<$VAL>> >

IFN <<$WID>-^D36>,<
  IFG <%VAL-<^O1_<$WID>-^O1>>,<
    $PRINT F,TMV,$VALUE - Too many values defined ($PFX''$FLG) >>

>>					; End of 'DEFINE $VALUE'


>					; End of 'DEFINE $FLAG1'
	$TOC	'X' Macros -- MOVX Macro


; MOVX - Macro to load an AC with a constant

DEFINE	MOVX [SALL] ($REG,$MSK)<

$LSTOF	CREF

IFB <$MSK>,<
  $LSTON CREF
  MOVX (<FL%ADR&<$REG>>,<<<^O1_<<<$REG>&FL%WID>_-FL$WID>>-^O1>_<<<$REG>&FL%POS>_-FL$POS>>)
  $LSTOF CREF >

IFNB <$MSK>,<
  IFN <<$REG>&^O777777777760>,<
    $PRINT F,XNA,MOVX - $REG is not an accumulator >

  ..MX1==<$MSK>				;; Evalate expression if any

  .IFN ..MX1,ABSOLUTE,<
    $LSTON CREF
	MOVE	$REG,[$MSK]		;; Generate MOVE
    $LSTOF CREF >

  .IF ..MX1,ABSOLUTE,<
    ..MX2==^O0				;; Flag says haven't done it yet

    IFE <<..MX1>&WD%LFT>,<
      ..MX2==^O1			;; Left half is zero
      $LSTON CREF
	HRRZI	$REG,<$MSK>		;; Generate HRRZI
      $LSTOF CREF >

    IFE ..MX2,<				;; If haven't done it yet
      IFE <<..MX1>&WD%RIT>,<
        ..MX2==^O1			;; Right half if zero
        $LSTON CREF
	HRLZI	$REG,($MSK)		;; Generate HRLZI
        $LSTOF CREF >>

    IFE ..MX2,<				;; If haven't done it yet
      IFE <<..MX1>B53-WD%RIT>,<
        ..MX2==^O1			;; Left half is ones
        $LSTOF CREF
	HRROI	$REG,<$MSK>		;; Generate HRROI
        $LSTON CREF >>

   IFE ..MX2,<				;; If haven't done it yet
     IFE <<..MX1>B17-WD%LFT>,<
        ..MX2==^O1			;; Right half is ones
        $LSTOF CREF
	HRLOI	$REG,(<$MSK>-WD%RIT)	;; Generate HRLOI
        $LSTON CREF >>

   IFE ..MX2,<				;; If still haven't done it
     $LSTOF CREF
	MOVE	$REG,[$MSK]		;; Generate MOVE
     $LSTON CREF >>

  PURGE ..MX1,..MX2 >

$LSTON	CREF

>					; End of 'DEFINE MOVX'
	$TOC	'X' Macros -- CAX Macros


DEFINE	CAX$$ [SALL] ($CMP),<

IRP $CMP,<
DEFINE CAX'$CMP [SALL] ($REG,$VAL),<

	$LSTOF	CREF
	OP$$CA	($REG,<$VAL>,$CMP)
	$LSTON	CREF

>>					; End of 'DEFINE CAX'$CMP'

>					; End of 'DEFINE CAX$$'

	CAX$$	<,L,LE,E,G,GE,N,A>	; Generate CAX macros

	PURGE	CAX$$			; Purge the CAX$$ macro


DEFINE	OP$$CA [SALL] ($REG,$VAL,$CMP),<

IFE <<$VAL>&WD%LFT>,<
  $LSTON CREF
	CAI'$CMP	$REG,<$VAL>	;; Generate a CAI'$CMP
  $LSTOF CREF >

IFN <<$VAL>&WD%LFT>,<
  $LSTON CREF
	CAM'$CMP	$REG,[$VAL]	;; Generate a CAM'$CMP
  $LSTOF CREF >

>					; End of 'DEFINE OP$$CA'
	$TOC	'X' Macros -- Integer Arithmetic Macros


DEFINE	ATH$$ [SALL] ($COD,$ALT,%COD,%ALT),<

%COD==0					;; Reset the $COD counter
IRP $COD,<
  %ALT==0				;; Reset the $ALT counter
  IRP $ALT,<
    IFE <%COD-%ALT>,<

      IFB <$ALT>,<
DEFINE $COD'X [SALL] ($REG,$VAL),<

	$LSTOF	CREF
	OP$$IN	($REG,<$VAL>,$COD)
	$LSTON	CREF

> >					;; End of 'DEFINE $COD'X'

      IFNB <$ALT>,<
DEFINE $COD'X [SALL] ($REG,$VAL),<

	$LSTOF	CREF
	OP$$IA	($REG,<$VAL>,$COD,$ALT)
	$LSTON	CREF

> >>					;; End of 'DEFINE $COD'X'

    %ALT==%ALT+^O1 >
  %COD==%COD+^O1 >

PURGE	%COD,%ALT

>					; End of 'DEFINE ATH$$'

	ATH$$	(<ADD,SUB,MUL,IMUL,DIV,IDIV>,<SUB,ADD,,,,>)

	PURGE	ATH$$
DEFINE	OP$$IA [SALL] ($REG,$VAL,$COD,$ALT),<

IFE <<$VAL>B53-WD%RIT>,<		;; Left half equal to -1
  IFN <<$VAL>&WD%RIT>,<			;; Right half not equal to 0
    $LSTON CREF
	$ALT'I	$REG,-<$VAL>		;; Generate $ALT'I
    $LSTOF CREF >
  IFE <<$VAL>&WD%RIT>,<			;; Right half equal to 0
    $LSTON CREF
	$COD	$REG,[$VAL]		;; Generate $COD
    $LSTOF CREF >>

IFN <<$VAL>B53-WD%RIT>,<
  OP$$IN ($REG,<$VAL>,$COD) >		;; Generate $COD

>					; End of 'DEFINE OP$$IA'


DEFINE	OP$$IN [SALL] ($REG,$VAL,$COD),<

IFE <<$VAL>&WD%LFT>,<
  $LSTON CREF
	$COD'I	$REG,<$VAL>		;; Generate $COD'I
  $LSTOF CREF >

IFN <<$VAL>&WD%LFT>,<
  $LSTON CREF
	$COD	$REG,[$VAL]		;; Generate $COD
  $LSTOF CREF >

>					; End of 'DEFINE OP$$IN'
	$TOC	'X' Macros -- Floating-point Arithmetic Macros


DEFINE	ATH$$ [SALL] ($COD),<

IRP $COD,<
DEFINE	$COD'X [SALL] ($REG,$VAL),<

	$LSTOF	CREF
	OP$$FP	($REG,<$VAL>,$COD)
	$LSTON	CREF

> >					;; End of 'DEFINE $COD'X'

>	;End of 'DEFINE ATH$$'

	ATH$$	(<FADR,FSBR,FMPR,FDVR>)

	PURGE	ATH$$


DEFINE	OP$$FP [SALL] ($REG,$VAL,$COD),<

IFE <<$VAL>&WD%RIT>,<
  $LSTON CREF
	$COD'I	$REG,($VAL)		;; Generate $COD'I
  $LSTOF CREF >

IFN <<$VAL>&WD%RIT>,<
  $LSTON CREF
	$COD	$REG,[$VAL]		;; Generate $COD
  $LSTOF CREF >

>					; End of 'DEFINE OP$$FP'
	$TOC	'X' Macros -- TX Macros


; Macro  to  generate  macros  of  the  form TXYY.  These macro replace a
; TLYY, TRYY or TDYY depending upon their argument.
;
; See examples:
;
;		Call				Result
;
;	TXNE	F,B20			TRNE	F,B20
;	TXON	F,B0			TLON	F,(B0)
;	TXZ	F,B1!B31		TDZ	F,[B1!B31]
;
; If called with only one arguement, it is assumed to be defined by a
; $FLAG macro.

DEFINE	TX0$$ [SALL] ($MOD,$SKP),<

IRP $MOD,<
  IRP $SKP,<

DEFINE	TX'$MOD'$SKP [SALL] ($REG,$MSK),<

$LSTOF	CREF

IFB <$MSK>,<
   OP$$TX (<FL%ADR&$REG>,<<<<^O1_<<<$REG>&FL%WID>_-FL$WID>>-^O1>_<<<$REG>&FL%POS>_-FL$POS>>>,$MOD'$SKP) >

IFNB <$MSK>,<
   OP$$TX ($REG,<$MSK>,$MOD'$SKP) >

$LSTON	CREF

> >>					; End of 'DEFINE TX'$MOD'$SKP

>					; End of 'DEFINE TX0$$'


	TX0$$	(<N,Z,O,C>,<,E,N,A>)

	PURGE	TX0$$
DEFINE	OP$$TX [SALL] ($REG,$MSK,$TST),<

IFN <<$REG>&^O777777777760>,<
  $PRINT F,XNA,TX'$TST - $REG is not an accumulator >

..TX1==<$MSK>				;; Evalate expression if any

.IFN ..TX1,ABSOLUTE,<
  $LSTON CREF
	TD'$TST	$REG,[$MSK]		;; Generate TDyy
  $LSTOF CREF >

.IF ..TX1,ABSOLUTE,<
  ..TX2==0				;; Flag says haven't done it yet

  IFE <<..TX1>&WD%LFT>,<
    ..TX2==^O1				;; Left half is zero
    $LSTON CREF
	TR'$TST	$REG,<$MSK>		;; Generate TRyy
    $LSTOF CREF >

  IFE ..TX2,<		        	;; If haven't done it yet
    IFE <<..TX1>&WD%RIT>,<
      ..TX2==^O1			;; Right half is zero
      $LSTON CREF
	TL'$TST	$REG,($MSK)		;; Generate TLyy
      $LSTOF CREF >>

  IFE ..TX2,<				;; If haven't done it yet
    IFE <<..TX1>B53-WD%RIT>,<		;; If left half is all ones
         OP$$TY ($REG,$MSK,$TST) >>	;; Try Z, O or C special cases

  IFE ..TX2,<				;; If still haven't done it
    $LSTON CREF
	TD'$TST	$REG,[$MSK]		;; Generate TDyy
    $LSTOF CREF >>

PURGE ..TX1,..TX2			;; Clean up after ourselves

>					; End of 'DEFINE OP$$TX'
; Special case for left half all ones

DEFINE	OP$$TY [SALL] ($REG,$MSK,$TST),<

IFIDNX <$TST><Z>,<			;; If zeroing wanted
  ..TX2==^O1
  $LSTON CREF
	ANDI	$REG,<^-<$MSK>>		;; Generate ANDI
  $LSTOF CREF >

IFIDNX <$TST><O>,<			;;If set to ones wanted
  ..TX2==^O1
  $LSTON CREF
	ORCMI	$REG,<^-<$MSK>>		;; Generate ORCMI
  $LSTOF CREF >

IFIDNX <$TST><C>,<			;; If complement wanted
  ..TX2==^O1
  $LSTON CREF
	EQVI	$REG,<^-<$MSK>>		;; Generate EQVI
  $LSTOF CREF >

>					; End of 'DEFINE OP$$TY'
	$TOC	<'X' Macros -- ANDX, IORX, ORX and XORX Macros>


; Define mnemonic codes for some of above:

DEFINE	ANDX [SALL] ($REG,$FLG),<

IFB <$FLG>,<				;; Don't send '^-<>'
   TXZ $REG >

IFNB <$FLG>,<
   TXZ $REG,<^-<$FLG>> >

>					; End of 'DEFINE ANDX'


DEFINE	IORX [SALL] ($REG,$FLG),<

	TXO $REG,<$FLG>

>					; End of 'DEFINE IORX'


DEFINE	ORX [SALL] ($REG,$FLG),<

	TXO $REG,<$FLG>

>					; End of 'DEFINE ORX'


DEFINE	XORX [SALL] ($REG,$FLG),<

	TXC $REG,<$FLG>

>					; End of 'DEFINE XORX'
	$TOC	'X' Macros -- $TY Macros


; Macros  to  test  and  set/clear/complement  flags  which  are  not in
; accumulators.  Be very careful that these generate  two  instructions,
; so can NOT be skipped over.
;
; They each have two arguments, the first is a scratch AC and the second
; is the flag which was defined by the $FLAG macro.

DEFINE	$TYNE [SALL] ($REG,$FLG),<

	MOVX	$REG,<<<<^O1_<<<$FLG>&FL%WID>_-FL$WID>>-^O1>_<<<$FLG>&FL%POS>_-FL$POS>>>
	<TDNE	$REG,>!<FL%ADR&<$FLG>>

>					; End of 'DEFINE $TYNE'


DEFINE	$TYNN [SALL] ($REG,$FLG),<

	MOVX	$REG,<<<<^O1_<<<$FLG>&FL%WID>_-FL$WID>>-^O1>_<<<$FLG>&FL%POS>_-FL$POS>>>
	<TDNN	$REG,>!<FL%ADR&<$FLG>>

>					; End of 'DEFINE $TYNN'


DEFINE	$TYO [SALL] ($REG,$FLG),<

	MOVX	$REG,<<<<^O1_<<<$FLG>&FL%WID>_-FL$WID>>-^O1>_<<<$FLG>&FL%POS>_-FL$POS>>>
	<ORM	$REG,>!<FL%ADR&<$FLG>>

>					; End of 'DEFINE $TYO'


DEFINE	$TYZ [SALL] ($REG,$FLG),<

	MOVX	$REG,<<<<^O1_<<<$FLG>&FL%WID>_-FL$WID>>-^O1>_<<<$FLG>&FL%POS>_-FL$POS>>>
	<ANDCAM	$REG,>!<FL%ADR&<$FLG>>

>					; End of 'DEFINE $TYZ'


DEFINE	$TYC [SALL] ($REG,$FLG),<

	MOVX	$REG,<<<<^O1_<<<$FLG>&FL%WID>_-FL$WID>>-^O1>_<<<$FLG>&FL%POS>_-FL$POS>>>
	<XORM	$REG,>!<FL%ADR&<$FLG>>

>					; End of 'DEFINE $TYC'
	$TOC	Stack Macros -- $ERRET Description


; $ERRET -- A macro to set the error flag so frame deallocation routines
;           know whether or not to test for an error return  ($ERCAL  or
;           $ERJMP).
;
; Call:
;
;	$ERRET
	$TOC	Stack Macros -- $VARIABLE Description


; $VARIABLE -- Macro to define stack variables.
;
; Call:
;
;	$VARIA	($TYP,$LST,$CAL,$REG,$ACS)
;
; Where:
;
;	$TYP - The type of variables to be created:
;	         ENTRY     - The  variables  are  global,  pointed to by
;	                     register 16, and registers 1-16 are  saved.
;	                     Note:  Register P1 will contain the address
;	                            of the caller argument block.
;	         GLOBAL    - The  variables  are  global,  pointed to by
;	                     register 16 (which is saved).
;		 INTERRUPT - The  variables  are  global,  pointed to by
;			     register 16, and regiester 1-16 are  saved.
;			     On  POPJ  all  registers are restored and a
;	                     DEBRK. or DEBRK% is performed.
;		 LOCAL     - The  variables  are  local,  pointed  to by
;			     register 17 (P).
;		 SAVE      - The  variables  are  global,  pointed to by
;			     register 16, and registers 1-16 are saved.
;		 SYMBOLS   - Only create the symbols.
;	       Note:  ENTRY is the default if not given.
;
;	$LST - The  list of stack variables.  The stack variables are of
;	       the form:  $VAR,$SIZ,$TST
;		 $VAR - Is the stack variable to be create.
;		 $SIZ - Is  the  size  of  stack  variable.  If the size
;			equals zero stack variable is NOT created.
;			Note:  The default is 1.
;		 $TST - Is  the feature test flag, if it is non-zero the
;			stack variable is created.  The default is -1.
;	       See the examples on the next page.
;
;	$CAL - Variable name for the pointer to the return address.  Not
;	       valid for INTERRUPT variables.  For SYMBOL variables this
;	       is the base register to be used, the default is 16.
;
;	$REG - Variable  name  for  the pointer to the register block on
;	       the stack, valid only for ENTRY, GLOBAL and SAVE.  GLOBAL
;	       points   to   register  16.  ENTRY  and  SAVE  points  to
;	       registers 1-16.
;
;	$ACS - The list of saved AC pointers.  These pointers are of the
;	       form:  $VAR,$REG
;		 $VAR - Is the AC pointer variable to be created.
;		 $REG - Is the frame to be pointed at.
;
; Note:
;
;	An  index register (16 or 17) is used to point to the variables,
;	so the user can't use indexing.  The  stack  variables  are  NOT
;	cleared!
; Examples:
;
; Generate only save registers option:
;
; RTN:	$VARIA	(ENTRY,,CALPTR,REGPTR)
;
;	; Note:  Call  MUST  be  of  the  form:  'PUSHJ  P,@[RTN]'.  The
;	;        The address of  the  argument  block  (literal)  is  in
;	;        register P1
;
;	MOVE	T1,REGPTR+T1-1		; Get the contents of T1
;	.
;	.
;	POPJ	P,			; Return to caller and remove stack
;					;  variables from the stack
;
;
; Generate some stack variables:
;
; RTN:	$VARIA	(LOCAL,<<VARIA1,,FT%T20>,<VARIA2,^D4>,VARIA3>)
;					; This call will generate three
;					;  variables:
;					;    VARIA1 - A variable with the
;					;	      size of 1 word, if
;					;	      FT%T20 is non-zero
;					;    VARIA2 - A variable with the
;					;	      size of 4 words
;					;    VARIA3 - A variable with the
;					;	      size of 1 word
;	IFN FT%T20,<
;		SETZM	VARIA1		; Reset the variable >
;		SETOM	VARIA2+RT.FLG	; Reset word (RT.FLG) of the
;					;  variable
;		.
;		.
;		PJRST	.POPJ1		; Give a skip return and remove
;					; the stack variables from the
;					; stack
;
;
; Generate an interrupt call:
;
; RTN:	$VARIA	(INTERRUPT)		; Save the ACs
;	.
;	.
;	POPJ	P,			; Return from interrupt
	$TOC	Stack Macros -- $FRAME Description


; $FRAME -- Macro  to  do  the actual stack allocation for the $VARIABLE
;           macro.
;
; Call:
;
;	$FRAME	($CPU,$MON)
;
; Where:
;
;	$CPU - An option to define the CPU type:
;	         PDP6 - The CPU is a PDP6.
;	         KA10 - The CPU is a KA10 (1040, 1050 or 1055).
;	         KI10 - The CPU is a KI10 (1060, 1070 or 1077).
;	         KL10 - The  CPU  is  a  KL10 (1080, 1088, 1090, 1091 or
;	                1099).
;	         KL20 - The CPU is a KL20 (2040, 2050 or 2060).
;	         KS10 - The CPU is a KS10 (2020 running TOPS-10).
;	         KS20 - The CPU is a KS20 (2020 running TOPS-20).
;	       Note:  The  default is the CPU that the macro is expanded
;	              on.
;
;	$MON - An option to define the monitor type:
;		 TOPS10 - The monitor is TOPS-10.
;		 TOPS20 - The monitor is TOPS-20.
;	       Note:  The  default  is  dependent  on symbols DEBRK. and
;	              DEBRK%.  If DEBRK.  is  defined  then  TOPS-10  is
;	              assumed,  if  DEBRK%  is  defined  then TOPS-20 is
;	              assumed or if both are defined an error message is
;	              typed.
; General format of the .FRAMx parameter block:

;  !================================================================!
;  ! Count !                        .FRAMx                          !
;  !================================================================!


	$DSBEG    FR			; The $FRAME data structure
	 $DSFLG   CNT,^D13		 ; The count field
	 $DSFLG   ROU,ADDRESS		 ; The address field
	$DSEND    FR			; That's all


; Define the variable types:

	.FRENT==^O0			; Entry
	.FRGLB==^O1			; Global
	.FRINT==^O2			; Interrupt
	.FRLOC==^O3			; Local
	.FRSAV==^O4			; Save
	.FRSYM==^O5			; Symbols


; Define the CPU types:

	FR%PDP==^O1			; PDP-6
	FR%KA1==^O2			; KA10 (1040, 1050 or 1055)
	FR%KI1==^O3			; KI10 (1060, 1070 or 1077)
	FR%KL1==^O4			; KL10 (1080, 1088, 1090, 1091 or 1099)
	FR%KL2==^O4			; KL20 (2040, 2050 or 2060)
	FR%KS1==^O4			; KS10 (2020 running TOPS-10)
	FR%KS2==^O4			; KS20 (2020 running TOPS-20)


; Define the monitor types:

	FR%T10==^O1			; TOPS-10
	FR%T20==^O2			; TOPS-20
; General format of the push down stack after a .FRAM0 (ENTRY) call:

;  !==================================================================!
;  !                     Original return address                      !
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /                       The saved ACs (1-16)                       /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /                       The stack variables                        /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  !                       .FRAM0 return address                      !
;  !==================================================================!


; General format of the push down stack after a .FRAM1 (GLOBAL) call:

;  !==================================================================!
;  !                     Original return address                      !
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /             The stack variables (minimum of 3 words)             /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  !                        The saved AC (16)                         !
;  !------------------------------------------------------------------!
;  !                       .FRAM1 return address                      !
;  !==================================================================!


; General format of the push down stack after a .FRAM2 (INTERRUPT) call:

;  !==================================================================!
;  !                     Original return address                      !
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /                       The saved ACs (1-16)                       /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /                       The stack variables                        /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  !                       .FRAM2 return address                      !
;  !==================================================================!
; General format of the push down stack after a .FRAM3 (LOCAL) call:

;  !==================================================================!
;  !                     Original return address                      !
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /             The stack variables (minimum of 3 words)             /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  !                  The dealloaction stack pointer                  !
;  !------------------------------------------------------------------!
;  !                       .FRAM3 return address                      !
;  !==================================================================!


; General format of the push down stack after a .FRAM4 (SAVE) call:

;  !==================================================================!
;  !                     Original return address                      !
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /                       The saved ACs (1-16)                       /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  /                                                                  /
;  /                       The stack variables                        /
;  /                                                                  /
;  !------------------------------------------------------------------!
;  !                       .FRAM4 return address                      !
;  !==================================================================!


; General format of the symbol allocation (SYMBOL) call:

;  !==================================================================!
;  /                                                                  /
;  /                      The symbol variables                        /
;  /                                                                  /
;  !==================================================================!
	$TOC	Stack Macros -- $LOCATE Description


; $LOCATE -- Macro  to  generate  the  code  to  calculate  an effective
;            address.  Note:  If indexing is used AC 16 must be set up.
;
; Call:
;
;	$LOCAT
	$TOC	Stack Macros -- $PARAMETER Description


; $PARAMETER -- Macro  to  generate  the  code to get the address of the
;               parameter block on a 'PUSHJ P,@[ROUTIN]' call.
;
; Call:
;
;	$PARAM
	$TOC	Stack Macros -- $ERRET Macro


DEFINE	$ERRET [SALL],<

	HRROS	(^O16)			; Test for an error return

>	; End of 'DEFINE $ERRET'

	OPDEF	$ERJMP	[JUMP ^O16,]	; If error, jump to routine on return
	OPDEF	$ERCAL	[JUMP ^O17,]	; If error, call routine on return
	$TOC	Stack Macros -- $VARIABLE Macros


DEFINE	$VARIA [SALL] ($TYP,$LST,$CAL,$REG,$ACS,%RDX),<

%RDX==10				;; Save the current radix
RADIX 8					;; Change the radix to octal

PURGE	.FRTYP,.FRCNT

;;		** Verify the type code **

IFB <$TYP>,<.FRTYP==.FRENT>		;; Entry (default)
IFIDNX <$TYP><ENTRY>,<.FRTYP==.FRENT>	;; Entry
IFIDNX <$TYP><GLOBAL>,<.FRTYP==.FRGLB>	;; Global
IFIDNX <$TYP><INTERRUPT>,<.FRTYP==.FRINT>;; Interrupt
IFIDNX <$TYP><LOCAL>,<.FRTYP==.FRLOC>	;; Local
IFIDNX <$TYP><SAVE>,<.FRTYP==.FRSAV>	;; Save
IFIDNX <$TYP><SYMBOLS>,<.FRTYP==.FRSYM>	;; Symbols

IFNDEF .FRTYP,<$PRINT F,AUT,$VARIABLE - An undefined type ($TYP)>

;;		** Verify the rest of the parameters **

$VAR0 (\.FRTYP,<$LST>,$CAL,$REG,<$ACS>)

RADIX %RDX				;; Restore the radix
PURGE %RDX

>					; End of 'DEFINE $VARIA'


DEFINE	$VAR0 [SALL] ($TYP,$LST,$CAL,$REG,$ACS),<

$VAR'$TYP'0 (<$LST>,$CAL,$REG,<$ACS>)

>					; End of 'DEFINE $VAR0'
; Here for ENTRY variables

DEFINE	$VAR00 [SALL] ($LST,$CAL,$REG,$ACS,%ACS),<

;;		** Verify the variable list **

.FRCNT==^O0				;; Reset the count

IRP $LST,<
  $VAR01 ($LST) >

;;		** Verify the 'CALL' and 'AC' variables **

IFNB <$CAL>,<
  $VAR05 ($CAL,0,^O1) >			;; Define pointer to the return address

IFNB <$REG>,<
  $VAR05 ($REG,1,^O16) >		;; Define pointer to AC block

;;		** Verify the register variables **

IRP $ACS,<
  $VAR03 ($ACS) >

;;		** Verify that everything is kool **

%ACS==^O0				;; Reset the ACs are good flag

IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O1>,<$PRINT F,AND,$VARIABLE - The ACs are not defined correctly >

;;		** Generate the .FRAM0 call **

IF2,<
  IFNDEF .FRAM0,<
    EXTERN .FRAM0 >>
	PUSHJ	P,@[<.FRCNT_FR$CNT>+.FRAM0]

PURGE	%ACS

>					; End of 'DEFINE $VAR00'


DEFINE	$VAR01 [SALL] ($LST),<

$VAR02	($LST)

>					; End of 'DEFINE $VAR01'


DEFINE	$VAR02 [SALL] ($VAR,$SIZ,$TST<-^O1>),<

IFB <$SIZ>,<
  IFN <$TST>,<
    $VAR05 ($VAR,\<.FRCNT+^O17>,^O1)
    .FRCNT==.FRCNT+^O1			;; The size
    IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>

IFNB <$SIZ>,<
  IFL <$SIZ>,<$PRINT F,IVS,$VARIABLE - Illegal variable size ($SIZ)>
  IFG <$SIZ>,<				;; Generate a symbol
    IFN <$TST>,<
      $VAR05 ($VAR,\<.FRCNT+^O17>,$SIZ)
      .FRCNT==.FRCNT+<$SIZ>	;;The size
      IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>>

>					; End of 'DEFINE $VAR02'


DEFINE	$VAR03 [SALL] ($ACS),<

$VAR04 ($ACS)

>					; End of 'DEFINE $VAR03'


DEFINE	$VAR04 [SALL] ($VAR,$OFF),<

IFLE <$OFF>,<$PRINT F,IRS,$VARIABLE - Illegal register specified>
IFG <<$OFF>-^O16>,<$PRINT F,IRS,$VARIABLE - Illegal register specified>

$VAR05 ($VAR,\<$OFF>,^O1)		;; Generate the symbol

>					; End of 'DEFINE $VAR04'


DEFINE	$VAR05 [SALL] ($VAR,$OFF,$SIZ),<

IF1,<
  IFDEF $VAR,<
    .IFN $VAR,MACRO,<
      $PRINT F,VDT,$VARIABLE - Variable is defined twice ($VAR)>>>

IFE <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] <^O'$OFF(^O16)> >
IFN <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] ($ADJ<0>),<^O'$OFF+<$ADJ>(^O16)> >

$'$VAR==<Z $VAR>			;; Generate a DDT offset symbol

>					; End of 'DEFINE $VAR05'
; Here for GLOBAL variables:

DEFINE	$VAR10 [SALL] ($LST,$CAL,$REG,$ACS,%ACS),<

;;		** Verify the 'CALL' variable **

IFNB <$CAL>,<
  $VAR13 ($CAL,0,^O1) >			;; Define pointer to the return address

;;		** Verify the variable list **

.FRCNT==^O0				;; Reset the count

IRP $LST,<
  $VAR11 ($LST) >

IFL <.FRCNT-^O3>,<.FRCNT==^O3>		;; Minimum size allowed

;;		** Verify the 'AC' variable **

IFNB <$REG>,<
  $VAR13 ($REG,\<.FRCNT+^O1>,^O1) >

;;		** Verify the ACs pointers **

IFNB <$ACS>,<$PRINT F,API,$VARIABLE - AC pointers are invalid for GLOBAL variabls>

;;		** Verify that everything is kool **

%ACS==^O0				;; Reset the ACs are good flag

IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O1>,<$PRINT F,AND,$VARIABLE - The ACs are not defined correctly >

;;		** Generate the .FRAM1 call **

IF2,<
  IFNDEF .FRAM1,<
    EXTERN .FRAM1 >>
	PUSHJ	P,@[<.FRCNT_FR$CNT>+.FRAM1]

PURGE	%ACS

>					; End of 'DEFINE $VAR10'


DEFINE	$VAR11 [SALL] ($LST),<

$VAR12	($LST)

>					; End of 'DEFINE $VAR11'


DEFINE	$VAR12 [SALL] ($VAR,$SIZ,$TST<-^O1>),<

IFB <$SIZ>,<
  IFN <$TST>,<
    $VAR13 ($VAR,\<.FRCNT+^O1>,^O1)
    .FRCNT==.FRCNT+^O1			;; The size
    IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>

IFNB <$SIZ>,<
  IFL <$SIZ>,<$PRINT F,IVS,$VARIABLE - Illegal variable size ($SIZ)>
  IFG <$SIZ>,<				;; Generate a symbol
    IFN <$TST>,<
      $VAR13 ($VAR,\<.FRCNT+^O1>,$SIZ)
      .FRCNT==.FRCNT+<$SIZ>		;; The size
      IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>>

>					; End of 'DEFINE $VAR12'


DEFINE	$VAR13 [SALL] ($VAR,$OFF,$SIZ),<

IF1,<
  IFDEF $VAR,<
    .IFN $VAR,MACRO,<
      $PRINT F,VDT,$VARIABLE - Variable is defined twice ($VAR) >>>

IFE <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] <^O'$OFF(^O16)> >
IFN <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] ($ADJ<0>),<^O'$OFF+<$ADJ>(^O16)> >

$'$VAR==<Z $VAR>			;; Generate a DDT offset symbol

>					; End of 'DEFINE $VAR13'
; Here for INTERRUPT variables:

DEFINE	$VAR20 [SALL] ($LST,$CAL,$REG,$ACS,%ACS),<

;;		** Verify the variable list **

.FRCNT==^O0				;; Reset the count

IRP $LST,<
  $VAR21 ($LST) >

;;		** Verify the 'CALL' and 'AC' variables **

IFNB <$CAL>,<
  $VAR25 ($CAL,0,^O1) >			;; Define pointer to the return address

IFNB <$REG>,<
  $VAR25 ($REG,1,^O16) >		;; Define pointer to AC block

;;		** Verify the register variables **

IRP $ACS,<
  $VAR23 ($ACS) >

;;		** Verify that everything is kool **

%ACS==^O0				;; Reset the ACs are good flag

IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O1>,<$PRINT F,AND,$VARIABLE - The ACs are not defined correctly>

;;		** Generate the .FRAM2 call **

IF2,<
  IFNDEF .FRAM2,<
    EXTERN .FRAM2 >>
	PUSHJ	P,@[<.FRCNT_FR$CNT>+.FRAM2]

PURGE	%ACS

>					; End of 'DEFINE $VAR20'


DEFINE	$VAR21 [SALL] ($LST),<

$VAR22	($LST)

>					; End of 'DEFINE $VAR21'


DEFINE	$VAR22 [SALL] ($VAR,$SIZ,$TST<-^O1>),<

IFB <$SIZ>,<
  IFN <$TST>,<
    $VAR25 ($VAR,\<.FRCNT+^O17>,^O1)
    .FRCNT==.FRCNT+^O1			;; The size
    IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>

IFNB <$SIZ>,<
  IFL <$SIZ>,<$PRINT F,IVS,$VARIABLE - Illegal variable size ($SIZ)>
  IFG <$SIZ>,<				;; Generate a symbol
    IFN <$TST>,<
      $VAR25 ($VAR,\<.FRCNT+^O17>,$SIZ)
      .FRCNT==.FRCNT+<$SIZ>		;; The size
      IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>>

>					; End of 'DEFINE $VAR22'


DEFINE	$VAR23 [SALL] ($ACS),<

$VAR24 ($ACS)

>					; End of 'DEFINE $VAR23'


DEFINE	$VAR24 [SALL] ($VAR,$OFF),<

IFLE <$OFF>,<$PRINT F,IRS,$VARIABLE - Illegal register specified>
IFG <<$OFF>-^O16>,<$PRINT F,IRS,$VARIABLE - Illegal register specified>

$VAR25 ($VAR,\<$OFF>,^O1)		;; Generate the symbol

>					; End of 'DEFINE $VAR24'


DEFINE	$VAR25 [SALL] ($VAR,$OFF,$SIZ),<

IF1,<
  IFDEF $VAR,<
    .IFN $VAR,MACRO,<
      $PRINT F,VDT,$VARIABLE - Variable is defined twice ($VAR) >>>

IFE <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] <^O'$OFF(^O16)> >
IFN <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] ($ADJ<0>),<^O'$OFF+<$ADJ>(^O16)> >

$'$VAR==<Z $VAR>			;; Generate a DDT offset symbol

>					; End of 'DEFINE $VAR25'
; Here for LOCAL variables:

DEFINE	$VAR30 [SALL] ($LST,$CAL,$REG,$ACS,%ACS),<

;;		** Verify the variable list **

.FRCNT==^O0				;; Reset the count

IRP $LST,<
  $VAR31 ($LST) >

IFL <.FRCNT-^O3>,<.FRCNT==^O3>		;; Minimum size allowed

;;		** Verify the 'CALL' and 'AC' variables **

IFNB <$CAL>,<
  $VAR33 ($CAL,\<.FRCNT+^O2>,^O1) >	;; Define pointer to the return address

IFNB <$REG>,<
  $PRINT F,LVA,$VARIABLE - Local variables don't have any saved ACs >

;;		** Verify the ACs pointers **

IFNB <$ACS>,<$PRINT F,API,$VARIABLE - AC pointers are invalid for GLOBAL variabls>

;;		** Verify that everything is kool **

%ACS==^O0				;; Reset the ACs are good flag

IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O1>,<$PRINT F,AND,$VARIABLE - The ACs are not defined correctly>

;;		** Generate the .FRAM3 call **

IF2,<
  IFNDEF .FRAM3,<
    EXTERN .FRAM3 >>
	PUSHJ	P,@[<.FRCNT_FR$CNT>+.FRAM3]

PURGE	%ACS

>					; End of 'DEFINE $VAR30'


DEFINE	$VAR31 [SALL] ($LST),<

$VAR32	($LST)

>					; End of 'DEFINE $VAR31'


DEFINE	$VAR32 [SALL] ($VAR,$SIZ,$TST<-^O1>),<

IFB <$SIZ>,<
  IFN <$TST>,<
    .FRCNT==.FRCNT+^O1			;; The size
    $VAR33 ($VAR,\<.FRCNT+^O1>,^O1)
    IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>

IFNB <$SIZ>,<
  IFL <$SIZ>,<$PRINT F,IVS,$VARIABLE - Illegal variable size ($SIZ) >
  IFG <$SIZ>,<				;; Generate a symbol
    IFN <$TST>,<
      .FRCNT==.FRCNT+<$SIZ>		;; The size
      $VAR33 ($VAR,\<.FRCNT+^O1>,$SIZ)
      IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>>

>					; End of 'DEFINE $VAR32'


DEFINE	$VAR33 [SALL] ($VAR,$OFF,$SIZ),<

IF1,<
  IFDEF $VAR,<
    .IFN $VAR,MACRO,<
      $PRINT F,VDT,$VARIABLE - Variable is defined twice ($VAR) >>>

IFE <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] <-^O'$OFF(^O17)> >
IFN <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] ($ADJ<0>),<-^O'$OFF+<$ADJ>(^O17)> >

$'$VAR==<Z $VAR>			;; Generate a DDT offset symbol

>	;End of 'DEFINE $VAR33'
; Here for SAVE variables:

DEFINE	$VAR40 [SALL] ($LST,$CAL,$REG,$ACS,%ACS),<

;;		** Verify the variable list **

.FRCNT==^O0				;; Reset the count

IRP $LST,<
  $VAR41 ($LST) >

;;		** Verify the 'CALL' and 'AC' variables **

IFNB <$CAL>,<
  $VAR45 ($CAL,0,^O1) >			;; Define pointer to the return address

IFNB <$REG>,<
  $VAR45 ($REG,1,^O16) >		;; Define pointer to AC block

;;		** Verify the register variables **

IRP $ACS,<
  $VAR43 ($ACS) >

;;		** Verify that everything is kool **

%ACS==^O0				;; Reset the ACs are good flag

IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O1>,<$PRINT F,AND,$VARIABLE - The ACs are not defined correctly>

;;		** Generate the .FRAM4 call **

IF2,<
  IFNDEF .FRAM4,<
    EXTERN .FRAM4 >>
	PUSHJ	P,@[<.FRCNT_FR$CNT>+.FRAM4]

PURGE	%ACS

>					; End of 'DEFINE $VAR40'


DEFINE	$VAR41 [SALL] ($LST),<

$VAR42	($LST)

>					; End of 'DEFINE $VAR41'


DEFINE	$VAR42 [SALL] ($VAR,$SIZ,$TST<-^O1>),<

IFB <$SIZ>,<
  IFN <$TST>,<
    $VAR45 ($VAR,\<.FRCNT+^O17>,^O1)
    .FRCNT==.FRCNT+^O1			;; The size
    IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>

IFNB <$SIZ>,<
  IFL <$SIZ>,<$PRINT F,IVS,$VARIABLE - Illegal variable size ($SIZ)>
  IFG <$SIZ>,<				;; Generate a symbol
    IFN <$TST>,<
      $VAR45 ($VAR,\<.FRCNT+^O17>,$SIZ)
      .FRCNT==.FRCNT+<$SIZ>		;; The size
      IFG <.FRCNT-^O17777>,<$PRINT F,IMS,$VARIABLE - Too much stack space is being used> >>>

>					; End of 'DEFINE $VAR42'


DEFINE	$VAR43 [SALL] ($ACS),<

$VAR44 ($ACS)

>					; End of 'DEFINE $VAR43'


DEFINE	$VAR44 [SALL] ($VAR,$OFF),<

IFLE <$OFF>,<$PRINT F,IRS,$VARIABLE - Illegal register specified>
IFG <<$OFF>-^O16>,<$PRINT F,IRS,$VARIABLE - Illegal register specified>

$VAR45 ($VAR,\<$OFF>,^O1)		;; Generate the symbol

>					; End of 'DEFINE $VAR44'


DEFINE	$VAR45 [SALL] ($VAR,$OFF,$SIZ),<

IF1,<
  IFDEF $VAR,<
    .IFN $VAR,MACRO,<
      $PRINT F,VDT,$VARIABLE - Variable is defined twice ($VAR) >>>

IFE <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] <^O'$OFF(^O16)> >
IFN <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] ($ADJ<0>),<^O'$OFF+<$ADJ>(^O16)> >

$'$VAR==<Z $VAR>			;; Generate a DDT offset symbol

>					; End of 'DEFINE $VAR45'
; Here for SYMBOL variables:

DEFINE	$VAR50 [SALL] ($LST,$BAS),<

;;		** Verify that base register is valid **

IFNB <$BAS>,<
  IFLE <$BAS>,<$PRINT F,IBR,$VARIABLE - Invalid base register ($BAS)>
  IFG <$BAS-^O17>,<$PRINT F,IBR,$VARIABLE - Invalid base register ($BAS)>>

;;		** Verify the variable list **

.FRCNT==^O0				;; Reset the count

IRP $LST,<
  IFB <$BAS>,<$VAR51 (^O16,$LST)>
  IFNB <$BAS>,<$VAR51 ($BAS,$LST)> >

>					; End of 'DEFINE $VAR50'


DEFINE	$VAR51 [SALL] ($BAS,$LST),<

$VAR52	($BAS,$LST)

>	;End of 'DEFINE $VAR51'


DEFINE	$VAR52 [SALL] ($BAS,$VAR,$SIZ,$TST<-^O1>),<

IFB <$SIZ>,<
  IFN <$TST>,<
    $VAR53 ($BAS,$VAR,\<.FRCNT>,^O1)
    .FRCNT==.FRCNT+^O1			;; The size
    IFG <.FRCNT-^O777777>,<$PRINT F,TMS,$VARIABLE - Too much symbol space is being used> >>

IFNB <$SIZ>,<
  IFL <$SIZ>,<$PRINT F,IVS,$VARIABLE - Illegal variable size ($SIZ)>
  IFG <$SIZ>,<				;; Generate a symbol
    IFN <$TST>,<
      $VAR53 ($BAS,$VAR,\<.FRCNT>,$SIZ)
     .FRCNT==.FRCNT+<$SIZ>		;; The size
     IFG <.FRCNT-^O777777>,<$PRINT F,TMS,$VARIABLE - Too much symbol space is being used> >>>

>					; End of 'DEFINE $VAR52'


DEFINE	$VAR53 [SALL] ($BAS,$VAR,$OFF,$SIZ),<

IF1,<
  IFDEF $VAR,<
    .IFN $VAR,MACRO,<
       $PRINT F,VDT,$VARIABLE - Variable is defined twice ($VAR) >>>

IFE <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] <^O'$OFF($BAS)> >
IFN <<$SIZ>-^O1>,<
  DEFINE $VAR [SALL] ($ADJ<0>),<^O'$OFF+<$ADJ>($BAS)> >

$'$VAR==<Z $VAR>			;; Generate a DDT offset symbol

>					; End of 'DEFINE $VAR53'
	$TOC	Stack Macros -- $FRAME Macro


DEFINE	$FRAME [SALL] ($CPU,$MON,%ACS),<

PURGE	FR%CPU				;; Reset the
FR%MON==^O0				;;  world

;;		** Verify the CPU option **

IFB <$CPU>,<FR%CPU==.CPU.>		;; Default
IFIDNX <$CPU><PDP6>,<FR%CPU==FR%PDP>	;; PDP6
IFIDNX <$CPU><KA10>,<FR%CPU==FR%KA1>	;; KA10
IFIDNX <$CPU><KI10>,<FR%CPU==FR%KI1>	;; KI10
IFIDNX <$CPU><KL10>,<FR%CPU==FR%KL1>	;; KL10
IFIDNX <$CPU><KL20>,<FR%CPU==FR%KL2>	;; KL20
IFIDNX <$CPU><KS10>,<FR%CPU==FR%KS1>	;; KS10
IFIDNX <$CPU><KS20>,<FR%CPU==FR%KS2>	;; KS20

IFNDEF FR%CPU,<$PRINT F,UCO,$FRAME - An undefined CPU option ($CPU) >

;;		** Verify the monitor option

IFB <$MON>,<
  .IF DEBRK.,OPDEF,<FR%MON==FR%MON+FR%T10>  ;; TOPS-10 (default)
  .IF DEBRK%,OPDEF,<FR%MON==FR%MON+FR%T20>> ;; TOPS-20 (default)
IFIDNX <$MON><TOPS10>,<FR%MON==FR%T10>      ;; TOPS-10
IFIDNX <$MON><TOPS20>,<FR%MON==FR%T20>      ;; TOPS-20

IFE <FR%MON>,<$PRINT F,UMT,$FRAME - Undefined monitor type ($MON) >
IFE <FR%MON-<FR%T10+FR%T20>>,<$PRINT F,MDM,$FRAME - Multiply defined monitor type >

;;		** Assign the ACs used **

%1==^O1					;; AC-1
%2==^O2					;; AC-2
%15==^O15				;; AC-15
%16==^O16				;; AC-16

;;		** Verify that everything is kool **

%ACS==^O0				;; Reset the ACs are good flag

IFDEF T1,<IFG <T1-0>,<IFL <T1-^O7>,<%ACS==%ACS+^O1>>
  IFDEF T2,<IFE <T2-<T1+1>>,<%ACS==%ACS+^O1>
    IFDEF T3,<IFE <T3-<T2+1>>,<%ACS==%ACS+^O1>
      IFDEF T4,<IFE <T4-<T3+1>>,<%ACS==%ACS+^O1>
        IFDEF P1,<IFE <P1-<T4+1>>,<%ACS==%ACS+^O1>>>>>>
IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O6>,<$PRINT F,AND,$FRAME - The ACs are not defined correctly >

IF2,<
  IFNDEF .PARAM,<
    EXTERN .PARAM >>

	PURGE	%ACS

	LALL				;; List this for the user

; .FRAM0 - (ENTRY) A co-routine to save the ACs (1-16) on the stack, set
;          up some frame (stack) variables and setup P1 to  contain  the
;          address of the user argument block.
; Call:	PUSHJ	P,@[CNT+.FRAM0]
;	 * Return *
; Uses:	1-4, P1, 16 and P
; Note:	P1 - Contains the address of the user argument block.

.FRAM0::HRRZS	(P)			; Clear the error flag
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,^O15			; Make some room for the ACs >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags
	ADD	P,[^O15,,^O15]		; Make some room for the ACs
	JCRY	$$$PDL			; Jump if a PDL overflow >
	EXCH	%1,-^O15(P)		; Get the return address
	PUSH	P,%1			; Save the return address
	HRLZI	%1,%2			; Save the ACs
	HRRI	%1,-^O15(P)		;  on the
	BLT	%1,-^O1(P)		;  stack
	MOVE	%16,P			; Get a copy of the stack pointer
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	%16,-^O17		; Adjust to the start of the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	SUB	%16,[^O17,,^O17]	; Adjust to the start of the frame >
	POP	P,T4			; Get the return address
	HRRZ	T1,T4			; Get the address of
	PUSHJ	P,.PARAM		;  the parameter block
	$MOVE	T1,FR%CNT,(T1)		; Get the size of the frame
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,(T1)			; Make room for the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags
	HRLS	T1			; Make room for
	ADD	P,T1			;  the frame
	JCRY	$$$PDL			; Jump if a PDL overflow >
	HRRZ	T1,(%16)		; Get the address
	PUSHJ	P,.PARAM		;  of the callers
	HRRZ	P1,T1			;  parameter block
	PUSHJ	P,(T4)			; Return to the caller
	 TRNA				; Non-skip return
	AOS	(%16)			; Skip return
	PUSH	P,%16			; Save the unadjusted stack pointer
	HRLZI	%16,%1(%16)		; Restore
	HRRI	%16,%1			;  the
	BLT	%16,%16			;  ACs
	MOVE	P,(P)			; Get the unadjusted stack pointer
	SKIPL	(P)			; Test for $ERJMP/$ERCAL?
	POPJ	P,			; No, return
	JRST	FRAM90			; Go test for special return

			     $CONTINUE	; Continued on the next page
; .FRAM1 - (GLOBAL) A  co-routine  to save AC 16 on the stack and set up
;          some frame (stack) variables.
; Call:	PUSHJ	P,@[CNT+.FRAM1]
;	 * Return *
; Uses:	16 and P

.FRAM1::HRRZS	(P)			; Clear the error flag
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags >
	PUSH	P,T1			; Save
	PUSH	P,T2			;  T1-2
	HRRZ	T1,-^O2(P)		; Get the address of
	PUSHJ	P,.PARAM		;  the parameter block
	MOVE	T2,P			; Get a copy of the spack pointer
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	T2,-^O3			; Adjust to the start of the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	SUB	T2,[^O3,,^O3]		; Adjust to the start of the frame >
	$MOVE	T1,FR%CNT,(T1)		; Get the size of the frame
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,-^O3(T1)		; Make room for the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	SUBX	T1,^O3			; Make room
	JFCL	^O17,.+1		;  for
	HRLS	T1			;  the
	ADD	P,T1			;  frame
	JCRY	$$$PDL			; Jump if a PDL overflow >
	PUSH	P,%16			; Save the old frame pointer
	MOVE	%16,T2			; Get the new frame pointer
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>>,<
	DMOVE	T1,^O2(%16)		; Restore T1-2 >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>>,<
	MOVE	T1,^O2(%16)		; Restore
	MOVE	T2,^O3(%16)		;  T1-2 >
	PUSHJ	P,@^O1(%16)		; Return to the caller
	 TRNA				; Non-skip return
	AOS	(%16)			; Skip return
	EXCH	%16,(P)			; Restore 16
	MOVE	P,(P)			; Deallocate the frame
	SKIPL	(P)			; Test for $ERJMP/$ERCAL?
	POPJ	P,			; No, return
	JRST	FRAM90			; Go test for special return

			     $CONTINUE	; Continued on the next page
; .FRAM2 - (INTERRUPT) A co-routine to save the ACs (1-16) on the stack,
;          set up some frame (stack)  variables,  and  do  a  DEBRK.  or
;          DEBRK% on return.
; Call:	PUSHJ	P,@[CNT+.FRAM2]
;	 * Return *
; Uses:	T1-4, 16 and P

.FRAM2::
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,^O15			; Make some room for the ACs >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags
	ADD	P,[^O15,,^O15]		; Make some room for the ACs
	JCRY	$$$PDL			; Jump if a PDL overflow >
	EXCH	%1,-^O15(P)		; Get the return address
	PUSH	P,%1			; Save the return address
	HRLZI	%1,%2			; Save the ACs
	HRRI	%1,-^O15(P)		;  on the
	BLT	%1,-^O1(P)		;  stack
	MOVE	%16,P			; Get a copy of the stack pointer
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	%16,-^O17		; Adjust to the start of the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	SUB	%16,[^O17,,^O17]	; Adjust to the start of the frame >
	POP	P,T4			; Get the return address
	HRRZ	T1,T4			; Get the address of
	PUSHJ	P,.PARAM		;  the parameter block
	$MOVE	T1,FR%CNT,(T1)		; Get the size of the frame
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,(T1)			; Make room for the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags
	HRLS	T1			; Make room for
	ADD	P,T1			;  the frame
	JCRY	$$$PDL			; Jump if a PDL overflow >
	PUSHJ	P,(T4)			; Return to the caller
	PUSH	P,%16			; Save the unadjusted stack pointer
	HRLZI	%16,%1(%16)		; Restore
	HRRI	%16,%1			;  the
	BLT	%16,%16			;  ACs
	MOVE	P,(P)			; Get the unadjusted stack pointer
IFE <FR%MON-FR%T10>,<
	DEBRK.				; Return from interrupt
	 JRST	$$$DIU			; Error unimplemented
	JRST	$$$NIP			; No interrupt in progress >
IFE <FR%MON-FR%T20>,<
	DEBRK%				; Return from interrupt
	 ERJMP	$$$NIP			; No interrupt in progress >

			     $CONTINUE	; Continued on the next page
; .FRAM3 - (LOCAL) A co-routine to set up some frame (stack) variables.
; Call:	PUSHJ	P,@[CNT+.FRAM3]
;	 * Return *
; Uses:	P
; Note:	These frame variables use P as a pointer.

.FRAM3::
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags >
	PUSH	P,T1			; Save
	PUSH	P,T2			;  T1-2
	HRRZ	T1,-^O2(P)		; Get the address of
	PUSHJ	P,.PARAM		;  the parameter block
	MOVE	T2,P			; Get a copy of the stack pointer
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	T2,-^O3			; Adjust to the start of the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	SUB	T2,[^O3,,^O3]		; Adjust to the start of the frame >
	$MOVE	T1,FR%CNT,(T1)		; Get the size of the frame
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,-^O3(T1)		; Make room for the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	SUBX	T1,^O3			; Make room
	JFCL	^O17,.+1		;  for
	HRLS	T1			;  the
	ADD	P,T1			;  frame
	JCRY	$$$PDL			; Jump if a PDL overflow >
	PUSH	P,T2			; Save the frame pointer on the stack
	HRRZ	T1,^O1(T2)		; Get the return address
	HRLI	T1,^O2(T2)		; Get the address of T1
	MOVE	T2,^O3(T2)		; Restore T2
	PUSHJ	P,[JRA T1,(T1)]		; Restore T1 and return to the caller
	 PJRST	[MOVE P,(P)		 ; Deallocate the frame
		 POPJ P,]		 ; Non-skip return
	MOVE	P,(P)			; Deallocate the frame
	AOS	(P)			; Skip return
	POPJ	P,			;  return

			     $CONTINUE	; Continued on the next page
; .FRAM4 - (SAVE) A  co-routine  to save the ACs (1-16) on the stack and
;          set up some frame (stack) variables.
; Call:	PUSHJ	P,@[CNT+.FRAM4]
;	 * Return *
; Uses:	T1-4, 16 and P

.FRAM4::HRRZS	(P)			; Clear the error flag
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,^O15			; Make some room for the ACs >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags
	ADD	P,[^O15,,^O15]		; Make some room for the ACs
	JCRY	$$$PDL			; Jump if a PDL overflow >
	EXCH	%1,-^O15(P)		; Get the return address
	PUSH	P,%1			; Save the return address
	HRLZI	%1,%2			; Save the ACs
	HRRI	%1,-^O15(P)		;  on the
	BLT	%1,-^O1(P)		;  stack
	MOVE	%16,P			; Get a copy of the stack pointer
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	%16,-^O17		; Adjust to the start of the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	SUB	%16,[^O17,,^O17]	; Adjust to the start of the frame >
	POP	P,T4			; Get the return address
	HRRZ	T1,T4			; Get the address of
	PUSHJ	P,.PARAM		;  the parameter block
	$MOVE	T1,FR%CNT,(T1)		; Get the size of the frame
IFN <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	ADJSP	P,(T1)			; Make room for the frame >
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
	JFCL	^O17,.+1		; Clear the overflow flags
	HRLS	T1			; Make room for
	ADD	P,T1			;  the frame
	JCRY	$$$PDL			; Jump if a PDL overflow >
	PUSHJ	P,(T4)			; Return to the caller
	 TRNA				; Non-skip return
	AOS	(%16)			; Skip return
	PUSH	P,%16			; Save the unadjusted stack pointer
	HRLZI	%16,%1(%16)		; Restore
	HRRI	%16,%1			;  the
	BLT	%16,%16			;  ACs
	MOVE	P,(P)			; Get the unadjusted stack pointer
	SKIPL	(P)			; Test for $ERJMP/$ERCAL?
	POPJ	P,			; No, return
	PFALL	FRAM90			; Go test for special return

			     $CONTINUE	; Continued on the next page
; If  the  instruction  at the current return address is an $ERCAL or an
; $ERJMP call or jump to the routine specified.

FRAM90:	PUSH	P,%1			; Save register 1

	MOVX	%1,%ICIND!%ICYHF	; Make sure the indirect bit
	ANDB	%1,-^O1(P)		;  is set in the return PC

	LDB	%1,[$POINT ((T1),IC%OPC!IC%ACF)]  ; Get return opcode

	CAIN	%1,<<$ERCAL>_-^D23>	; Is it an $ERCAL?
	JRST	[MOVE  %1,(P)		 ; Yes, restore register 1
		 MOVEI %1,@-^O1(P)	 ; Put the new effective
		 EXCH  %1,(P)		 ;  address on the stack
		 AOS   -^O1(P)		 ; Account for the PUSHJ
		 POPJ  P,]		 ; Go to the error routine

	CAIE	%1,<<$ERJMP>_-^D23>	; Is it an $ERJMP?
	JRST	FRAM91			; No, return
	MOVE	%1,(P)			; Restore register 1
	MOVEI	%1,@-^O1(P)		; Put the new effective
	MOVEM	%1,-^O1(P)		;  address on the stack

FRAM91:	POP	P,%1			; Restore register 1
	POPJ	P,			; Return

			     $CONTINUE	; Continued on the next page
IFE <<FR%CPU-FR%PDP>*<FR%CPU-FR%KA1>*<FR%CPU-FR%KI1>>,<
$$$PDL:	OUTSTR	[ASCIZ ~
?FRMPDL	PDL overflow in .FRAME
~]
	MONRT.				; Return to monitor mode
	JRST	.-^O1			; Don't allow a CONTINUE  >

IFE <FR%MON-FR%T10>,<
$$$DIU:	OUTSTR	[ASCIZ ~
?FRMDIU DEBRK. is unimplemented
~]
	MONRT.				; Return to monitor mode
	JRST	.-^O1			; Don't allow a CONTINUE

$$$NIP:	OUTSTR	[ASCIZ ~
?FRMNIP No interrupt in progress
~]
	MONRT.				; Return to monitor mode
	JRST	.-^O1			; Don't allow a CONTINUE >

IFE <FR%MON-FR%T20>,<
$$$NIP:	PUSH	P,T1			; Save T1
	HRROI	T1,[ASCIZ ~FRMNIP No interrupt in progress
~]
	ESOUT%				; Output the error message
	POP	P,T1			; Restore T1
	HALTF%				; Return to EXEC mode
	JRST	.-^O1			; Don't allow a CONTINUE >

>	; End of 'DEFINE $FRAME'
	$TOC	Stack Macros -- $LOCATE Macro


DEFINE	$LOCAT [SALL] (%ACS),<

;;		** Assign the AC used **

%16==^O16				;; AC-16

;;		** Verify that everything is kool **

%ACS==^O0				;; Reset the ACs are good flag

IFDEF T1,<IFG <T1-0>,<IFL <T1-^O7>,<%ACS==%ACS+^O1>>
  IFDEF T2,<IFE <T2-<T1+1>>,<%ACS==%ACS+^O1>
    IFDEF T3,<IFE <T3-<T2+1>>,<%ACS==%ACS+^O1>
      IFDEF T4,<IFE <T4-<T3+1>>,<%ACS==%ACS+^O1> >>>>
IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O5>,<$PRINT F,AND,$LOCATE - The ACs are not defined correctly >

	PURGE	%ACS

	LALL				;; List this for the user

; .LOCAT - Calculate an effective address
; Call:	MOVX	T1,{the effective address to calculate}
;	PUSHJ	P,.LOCAT		; The address is in T1
; Uses:	T1-2
; Note:	If indexing is used AC 16 must point to the saved ACs.

.LOCAT::SKIPA	T2,T1			; Get the parameter in the right place
LOCAT1:	MOVE	T2,(T1)			; Get contents of the location
	LDB	T1,[$POINT T2,%ICIDX]	; Get the index register field
	JUMPE	T1,LOCAT2		; Jump if no indexing
	ADDI	T1,(%16)		; Get the address of the index register
	HRRZ	T1,(T1)			; Get the contents of the index register
LOCAT2:	ADDI	T1,(T2)			; Add in the address
	ANDX	T1,%ICYHF		; Clear the left half to be safe
	CAXGE	T1,^O17			; Was an AC specified,
	CAXN	T1,^O0			;  except 0 or 17?
	JRST	LOCAT3			; Yes, avoid some code
	ADDI	T1,(%16)		; Get the address of the register
	ANDX	T1,%ICYHF		; Clear the left half to be safe
LOCAT3:	TXNE	T2,%ICIND		; Skip if not indirect
	JRST	LOCAT1			; Keep on trying
	POPJ	P,			; Return

>	; End of 'DEFINE $LOCAT'
	$TOC	Stack Macros -- $PARAMETER Macro


DEFINE	$PARAM [SALL] (%ACS),<

;;		** Verify that everything is kool **

	%ACS==^O0			;; Reset the ACs are good flag

IFDEF T1,<IFG <T1-0>,<IFL <T1-^O7>,<%ACS==%ACS+^O1>>
  IFDEF T2,<IFE <T2-<T1+1>>,<%ACS==%ACS+^O1>
    IFDEF T3,<IFE <T3-<T2+1>>,<%ACS==%ACS+^O1>
      IFDEF T4,<IFE <T4-<T3+1>>,<%ACS==%ACS+^O1> >>>>
IFDEF P,<IFE <P-^O17>,<%ACS==%ACS+^O1>>

IFN <%ACS-^O5>,<$PRINT F,AND,$PARAMETER - The ACs are not defined correctly >

IF2,<
  IFNDEF .LOCAT,<
    EXTERN .LOCAT >>

	PURGE	%ACS

	LALL				;; List this for the user

; .PARAM - Get the address of the parameter block
; Call:	MOVX	T1,{the return address (call+1)}
;	PUSHJ	P,.PARAM		; The address is in T1
; Uses:	T1-2

.PARAM::SUBX	T1,^O1			; Adjust the address
PARAM1:	MOVE	T1,(T1)			; Get the contents of the parameter
	LDB	T2,[$POINT T1,IC%OPC]	; Get the opcode of the caller
	CAIN	T2,<<XCT>_-^D27>	; Skip if not an 'XCT'
	JRST	[PUSHJ P,.LOCAT		 ; Calculate the effective address
		 JRST  PARAM1]		 ; Go try the next opcode
	CAIN	T2,<<JSR>_-^D27>	; Skip if not a 'Break-Point'
	JRST	[PUSHJ P,.LOCAT		 ; Calculate the effective address
		 SUBX  T1,^O1		 ; Point to the real opcode
		 JRST  PARAM1]		 ; Go try the next opcode
	TXZ	T1,%ICIND		; Clear the indirect bit
PARAM2:	PUSHJ	P,.LOCAT		; Calculate the effective address
	MOVE	T2,(T1)			; Is this the first word
	TXZN	T2,%ICIND		;  argument block?
	POPJ	P,			; Yes, return
	MOVE	T1,T2			; Try the next
	JRST	PARAM2			;  level down

>	; End of 'DEFINE $PARAM'
	$TOC	TYPER Macros -- $BITS Description


; $BITS -- Macro  to generate a parameter block for the $BIT output type
;          ($TYPE macro).
;
; Call:
;
;	$BITS ($FNC,$MSG,$BIT,$BIT,$MSK,$FLG,$XTR)
;
; Where:
;
;	$FNC - The function (output) type:
;	         AND     - Output 'and' between the last two messages.
;	         COMMA   - Output ',' between all of the messages.
;		 CRLF    - Output   '<CR><LF>'   between   all   of  the
;	                   messages.
;	         EXCLAIM - Output '!' between all of the messages.
;	         FIELD   - Output a message associated with the contents
;	                   of a field.
;	         NONE    - Output nothing between any of the messages.
;	         OR      - Output 'or' between the last two messages.
;	         PLUS    - Output '+' between the all of the messages.
;	         SPACE   - Output ' ' between all the messages.
;	         USER    - Output  user  supplied separators between the
;	                   messages.
;	       Note:  AND is the default if not given.
;
;	$MSG - The  address  of  the  message  associated with the first
;	       message (non-FIELD) or the address of message  associated
;	       with a zero field (FIELD).
;	       Note:  The  address minus one (-1) is the message for the
;	       default message, no bits on (non-FIELD), or  the  maximum
;	       (FIELD).
;
;	$BIT - The  bits  to  be tested or the pointer to the bits to be
;	       tested.
;
;	$MSK - The  mask  to  be  used  or the pointer to the mask to be
;	       used.
;
;
;	$FLG - The  flags  that can be set.  Any number of following may
;	       be supplied:
;	         ASCII    - The messages are in ASCII.
;	         BIT      - $BIT  is  a pointer to the actual bits to be
;	                    tested.
;	         EXTRA    - $XTR  is  a pointer to the actual data to be
;	                    used.
;	         MASK     - $MSK  is  a pointer to the actual mask to be
;	                    used.
;	         MESSAGES - $MSG  is a pointer to the actual messages to
;	                    be used.
;	         NUMBERS  - The  bit  number (B35) is to be output (non-
;	                    FIELD only).
;	         OCTAL    - The octal value of the field is to be output
;	                    after the default message (FIELD only).
;	         SIXBIT   - The messages are one word of SIXBIT text.
;	       Note:  ASCII is the default if not given.
;
;	$XTR - An  extra  argument is only needed for the FIELD and USER
;	       functions.  For  the  FIELD  function  this  argument  is
;	       maximum field value.  For the USER function this argument
;	       contains  the  address of first ASCIZ string separator in
;	       the  left half and the last ASCIZ string separator in the
;	       right half.
; General format for the $BIT parameter block:

;  !===========================================================!
;  ! Flags ! Function !                Messages                !
;  !-----------------------------------------------------------!
;  !                       The bits                            !
;  !-----------------------------------------------------------!
;  !                       The mask                            !
;  !-----------------------------------------------------------!
;  !         User messages or maximum (optional)               !
;  !===========================================================!


	$DSBEG    BT			; The $BITS data structure
	 $DSFLG   FLG,^D8		 ; The flags field
	  $DSBIT  OCT	    		  ; Output octal values for unknown fields
	  $DSBIT  NUM,,REDEFINE		  ; Output bits number, non-fields
	  $DSBIT  ASC	    		  ; The messages are in ASCII
	  $DSBIT  SIX		    	  ; The messages are in SIXBIT
	  $DSBIT  MES		    	  ; Indirect pointer to the messages
	  $DSBIT  BIT		    	  ; Indirect pointer to the bits
	  $DSBIT  MSK		    	  ; Indirect pointer to the mask
	  $DSBIT  XTR		    	  ; Indirect pointer to the extra data
	  $DSBIT  FST		    	  ; First message was output (Internal only)
	 $DSFLG   FNC,^D4		 ; The function field
	  $DSVAL  AND		     	  ; Output 'and'
	  $DSVAL  COM			  ; Output ','
	  $DSVAL  LIN			  ; Output 'CR-LF'
	  $DSVAL  NON			  ; Output nothing
	  $DSVAL  OR			  ; Output 'or'
	  $DSVAL  PLS			  ; Output '+'
	  $DSVAL  SPC			  ; Output ' '
	  $DSVAL  USR			  ; Output user
	  $DSVAL  XCL			  ; Output '!'
	  $DSVAL  FLD			  ; Output field
	 $DSFLG   MSG,ADDRESS		 ; The message field
	 $DSFLG   BIT,WORD		 ; The bit field
	 $DSFLG   MSK,WORD		 ; The mask field
	 $DSFLG   XTR,WORD		 ; The extra field
	$DSEND    BT			; That's all
	$TOC	TYPER Macros -- $BYTES Description


; $BYTES -- Macro  to  generate  a  parameter block for the $BYT output
;           type ($TYPE macro).
;
; Call:
;
;	$BYTES ($TYP,$PTR,$CNT,$TRM,$SEP,$FLG,$XTR)
;
; Where:
;
;	$TYP - The  type  of  output  to  be  generated  from the string
;	       supplied:
;	         ASCII  - Output an ASCII text string.
;	         DEC    - Output  decimal  values  for  each byte in the
;	                  string.
;	         HEX    - Output hexadecimal values for each byte in the
;	                  string.
;	         OCT    - Output  octal  values  for  each  byte  in the
;	                  string.
;	         RADIX  - Output values for each byte in the string, see
;			  $FLG parameter.
;	         SIXBIT - Output a SIXBIT text string.
;              Note: The default is ASCII.
;
;	$PTR - The byte pointer to the string specified.
;
;	$CNT - The byte count of the number of bytes to output:
;	         - The count is positive, the maximum number of bytes to
;	           output is specified or the string  is  terminated  by
;	           the value specified to the $TRM parameter.
;	         - The  count  is  zero, the string is terminated by the
;	           value specified to the $TRM parameter.
;	         - The  count is negative, the number of bytes to output
;	           is specified.
;	       Note: The default is 0.
;
;	$TRM - The  byte to terminate the output string on.  If count is
;	       negative this value is ignored.  Note: The default  is  0
;	       (.CHNUL).
;
;	$SEP - The seperator string to be output between each byte:
;	         COMMA - A comma and space output between each byte.
;	         CRLF  - A  carriage-return  line-feed is output between
;	                 each byte.
;	         NONE  - Nothing is output between each byte.
;	         SPACE - A space is output between each byte.
;	         USER  - A  user  supplied string is output between each
;			 byte.
;	       Note: The default is NONE if the type is ASCII or SIXBIT,
;	             else the default is COMMA.
;
;	$FLG - The flags for additional control of the output:
;	         COUNT     - $CNT is a pointer to the actual count to be
;	                     used.
;	         POINTER   - $PTR  is  a  pointer  to  the  actual  byte
;	                     pointer to be used.
;	         RADIX     - The radix to be used, if RADIX is specified
;	                     to $TYPE.
;	         SEPERATOR - $SEP  is  a pointer to the actual seperator
;	                     string to be used.
;	         TERMINATE - $TRM is a pointer to the actual terminating
;	                     byte value to be used.
;
;	$XTR - An  extra  argument is only needed for the USER seperator
;	       type.  This is the pointer  to  seperator  string  to  be
;	       used.
; General format of the $BYT parameter block:

;  !==================================================================!
;  ! Type ! Flags ! Seperator ! Radix !                               !
;  !------------------------------------------------------------------!
;  !                            Pointer                               !
;  !------------------------------------------------------------------!
;  !                             Count                                !
;  !------------------------------------------------------------------!
;  !                        Terminating byte                          !
;  !------------------------------------------------------------------!
;  !                  User sperator string pointer                    !
;  !==================================================================!


	$DSBEG    BY			; The $BYTES data structure
	 $DSWRD   FLG			 ; The flag field
	  $DSFLG  TYP,^D2,FLG		  ; The type of output desired:
	   $DSVAL ASC			   ; ASCII output
	   $DSVAL RDX			   ; Radix output
	   $DSVAL SIX			   ; SIXBIT output
	  $DSFLG  XXX,^D4		  ; ** KLUDGE **
	  $DSBIT  PTR			  ; An indirect pointer
	  $DSBIT  CNT			  ; An indirect count
	  $DSBIT  TRM			  ; An indirect terminating byte
	  $DSBIT  SEP			  ; An indirect seperator string
	  $DSFLG  FST			  ; First digit output
	  $DSFLG  RDX,^D6		  ; The radix for output
	  $DSFLG  SEP,^D3		  ; The seperator string
	   $DSVAL NON			   ; No seperator
	   $DSVAL COM			   ; Comma and space
	   $DSVAL LIN			   ; Carriage-return line-feed
	   $DSVAL SPC			   ; Space only
	   $DSVAL USR			   ; User supplied string
	 $DSWRD   PTR			 ; The pointer field
	 $DSWRD   CNT			 ; The counter field
	 $DSWRD   TRM			 ; The terminating byte field
	 $DSWRD   XTR			 ; The extra field
	$DSEND    BY			; That's all
	$TOC	TYPER Macros -- $ERROR Description


; $ERROR -- Macro to do output to the terminal with substitutions.
;
; Warning:
;
;	This  macro  can  only  be used after a JSYS call (TOPS-20) or a
;       routine that supports $ERCAL/$ERJMP returns.
;
;                       Note:  $ERCAL/$ERJMP are no-op's.
;
; Call:
;
;	$ERROR	($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG)
;
; Note:
;
;	The arguments are identical to those of the $TYPE macro.
	$TOC	TYPER Macros -- $NUMBER Description


; $NUMBER -- The macro to generate a parameter block for the $NUM output
;            type ($TYPE MACRO).
;
; Call:
;
;	$NUMBER	($ADR,$TYP,$DTP,$DPT,$NOT,$EX1,$EX2,$EX3)
;
; Where:
;
;	$ADR - The address of the data or the data itself.
;
;	$TYP - The output type:
;	         FLOAT   - The data is floating point format.
;	         INTEGER - The data is integer format.
;	         SPECIAL - The data is special format.
;
;	$DTP - The input data type:
;	         FLOAT:
;	           DOUBLE - Double precision data.
;	           SINGLE - Single precision data.
;	         INTEGER/SPECIAL:
;	           BYTE   - Byte data ($ADR is a byte pointer).
;	           DOUBLE - Double precision data.
;	           LEFT   - Left half data.
;	           RIGHT  - Right half data.
;	           SINGLE - Single precision data.
;	       Note:  SINGLE is the default if not given.
;
;	$DPT - The type of data pointer:
;	         FLOAT:
;	           ADDRESS   - An address is supplied.
;	           IMMEDIATE - The data itself is supplied.
;	           INDIRECT  - An indirect address is supplied.
;	         INTEGER/SPECIAL:
;	           ADDRESS   - An address is supplied.
;	           IMMEDIATE - The data itself is supplied.
;	           INDIRECT  - An indirect address is supplied.
;	           POINTER   - A byte pointer is supplied.
;	       Note:  ADDRESS  is  the default if not given, unless BYTE
;	              was specified then the default is 'POINTER'.
;
;	$NOT - The notation for output:
;	         FLOAT:
;	           NORMAL     - Normal floating point notation.
;	           SCIENTIFIC - Scientific notation.
;	         INTEGER:
;	           SIGNED   - Signed notation.
;	           UNSIGNED - Signed notation.
;	         SPECIAL:
;	           ALPHA   - Alpha notation (i.e. minor version number).
;	           ROMAN   - Roman notation.
;	           ENGLISH - English notation.
;	           PICTURE - COBOL picture notation.
;	       Note:  NORMAL,  UNSIGNED or PICTURE is the default if not
;	              given.
;
;	$EX1 - Additional information:
;	         FLOAT:
;	           n    - The total field width (0-125).
;	           FREE - The total field width is to calcuated.
;	         INTEGER:
;	           n - The total field width (0-125).
;	         SPECIAL:
;	           ALPHA/ENGLISH/ROMAN:
;	             LOWER - Output lower case text.
;	             UPPER - Output upper case text.
;	           PICTURE:
;	              The picture to be used or the pointer to it.
;	       Note:  0  is  the  default for FLOAT/INTEGER if not given
;	              and      LOWER      is     the     default     for
;	              SPECIAL:ALPHA/ENGISH/ROMAN if not given.
;
;	$EX2 - Additional information:
;	         FLOAT:
;	           n       - The  number  of  fractional  digits  wanted
;	                     (0-56).
;	           FREE    - The fraction field width is to calcuated.
;	           INTEGER - Output only the integer portion.
;	         INTEGER:
;	           n   - The output radix to use (2-36).
;	           DEC - Set the output radix to decimal (10).
;	           HEX - Set the output radix to hexadecimal (16).
;	           OCT - Set the output radix to octal (8).
;	         SPECIAL:
;	           ENGLISH/ROMAN:
;	             CARDINAL - Output as a cardinal number.
;	             ORDINAL  - Output as an ordinal number.
;	           PICTURE:
;	             LITERAL - $EX1 is the actual picture to be used.
;	             POINTER - $EX1  is the pointer to the picture to be
;	                       used.
;	       Note:  5  is the default for FLOAT if not given, 8 is the
;	              default for INTEGER if not given, CARDINAL is  the
;	              default  for  SPECIAL:ENGLISH/ROMAN  if not given,
;	              and LITERAL is the default for 'SPECIAL:PICTURE'
;	              if not given.
;
;	$EX3 - Additional information:
;	         FLOAT:
;	           BLANK  - Leading fill with blanks.
;	           DOLLAR - Leading  fill  with  blanks,  but  output  a
;	                    preceding dollar sign.
;	           ZERO   - Leading fill with zeroes.
;	           x      - Leading fill with character 'x'.
;	         INTEGER:
;	           BLANK - Leading fill with blanks.
;	           ZERO  - Leading fill with zeroes.
;	           x     - Leading fill with character 'x'.
;	         SPECIAL:
;	           PICTURE:
;	             SAVE   - Save  the  compiled  picture  (see  $TYPES
;	                      PIC).
;	             NOSAVE - Discard   the   compiled   picture   after
;	                      processing.
;	       Note:  BLANK  is the default for FLOAT if not given, ZERO
;	              is the default for 'INTEGER' if not given,  unless
;	              SIGNED  was  specified inwhich case the default is
;	              BLANK, and SAVE is the default for SPECIAL:PICTURE
;	              if not given, unless POINTER was specified inwhich
;	              case the default is NOSAVE.
; General format of the $NUM parameter block:

;  !===================================================================!
;  ! Type ! Data-type ! Data ! Notation ! Flags ! Fill ! Width ! Radix !
;  !-------------------------------------------------------------------!
;  /                                                                   /
;  /                           Address/Data                            /
;  /                                                                   /
;  !-------------------------------------------------------------------!
;  !                          Picture-pointer                          !
;  !===================================================================!


	$DSBEG    NM			; The $NUMBER data structure
	 $DSFLG   TYP,^D2		 ; The type field
	  $DSVAL  FLT			  ; Float
	  $DSVAL  INT			  ; Integer
	  $DSVAL  SPC			  ; Special
	 $DSFLG   DTP,^D3		 ; The data type field
	  $DSVAL  BYT			  ; Byte
	  $DSVAL  DBL			  ; Double
	  $DSVAL  LFT			  ; Left half
	  $DSVAL  RIT			  ; Right half
	  $DSVAL  SNG			  ; Single
	  $DSVAL  XLT			  ; Left half, extended
	  $DSVAL  XRT			  ;Right half, extended
	 $DSFLG   DPT,^D2		 ; The data pointer field
	  $DSVAL  ADR			  ; Address
	  $DSVAL  IMD			  ; Immediate
	  $DSVAL  IND			  ; Indirect
	  $DSVAL  PTR			  ; Pointer
	 $DSFLG   NOT,^D2		 ; The notation field
	  $DSVAL  NRM,^D0		  ; Normal		(float)
	  $DSVAL  SCI			  ; Scientific		(float)
	  $DSVAL  SIN,^D0		  ; Signed		(integer)
	  $DSVAL  UNS			  ; Unsigned		(integer)
	  $DSVAL  ALP,^D0		  ; Alpha		(special)
	  $DSVAL  ENG			  ; English		(special)
	  $DSVAL  PIC			  ; Picture		(special)
	  $DSVAL  ROM			  ; Roman		(special)
	 $DSFLG   FLG,^D7		 ; The flag field
;**;	  %NMSML==B0			  ; Small number	(float)
;**;	  %NMFLD==B1			  ; Free total field	(float)
;**;	  %NMFRC==B2			  ; Free fractional field (float)
	  $DSBIT  NEG,,^D0		  ; Negative		(float)
	  $DSBIT  COM			  ; Comma needed	(float)
	  $DSBIT  OVL			  ; Astrisk on overflow	(float)
	  $DSBIT  DLR			  ; Dollar sign		(float)
	  $DSBIT  TRL			  ; Output a trailing sign (float)
	  $DSBIT  NDP			  ; No decimal point	(float)
	  $DSBIT  SGN			  ; Output a plus sign	(float)
	  $DSBIT  NEG,,^D0		  ; Negative		(integer)
	  $DSBIT  NEG,,^D0		  ; Negative		(special)
	  $DSBIT  COM			  ; Comma needed	(special)
	  $DSBIT  CRD			  ; Cardinal numbers	(special)
	  $DSBIT  DSH			  ; Dash needed		(special)
	  $DSBIT  FST			  ; First character	(special)
	  $DSBIT  LOW			  ; Lower case		(special)
	  $DSBIT  LIT,,^D0		  ; Literal		(special/picture)
	  $DSBIT  SAV			  ; Save		(special/picture)
	  $DSBIT  MAT			  ; Match		(special/picture)
	 $DSFLG   FIL,^D7		 ; The fill field
	 $DSFLG   WID,^D7		 ; The width field
	 $DSFLG   FRC,^D6		 ; The fraction width field (float)
	 $DSFLG   RDX,REDEFINE		 ; The radix field	(integer)
	 $DSFLG   ADR,ADDRESS		 ; The address field
	 $DSFLG   PIC,WORD		 ; The picture field	(special/picture)
	$DSEND    NM			; That's all
	$TOC	TYPER Macros -- $TYPE Description


; $TYPE -- Macro to do output to the terminal with substitutions.
;
; Call:
;
;	$TYPE	($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG)
;
; Where:
;
;	$HDR - The code for the type of header to be supplied:
;	         B - Blank, ' ' preceeds the message.
;	         C - Continuation, nothing proceeds the message.
;	         F - Fatal, '?' preceeds the message.
;	         I - Information, '[' preceeds the message.
;	         M - Message, '"' preceeds the message.
;	         N - None, nothing preceeds the message.
;	         O - Operator, '$' preceeds the message.
;	         T - Tab, 'TAB' preceeds the message.
;	         W - Warning, '%' preceeds the message.
;	       Note:  N  is  the default if not given.  F, I, M, O and W
;	              require message suffix ($SFX) and will output a  6
;	              character error identifier, 3 program (TP.PFX) and
;	              3 error ($SFX).
;
;	$SFX - The unique 3 letter suffix for this message.
;
;	$SUB - The type of substitution to be done:
;	         $NON - Output a vertical bar (|).
;	         $ASC - Output  the  ASCIZ string pointed to by T1 (bits
;	                0-11 contains the byte pointer zero,  implies  a
;	                left  justified  ASCII  byte  pointer,  or  5000
;	                implies an external error string).
;	         $BIT - Output  the  bit  messages  pointed to by T1, T1
;	                contains the address of a $BITS block.
;	         $BYT - Output  the  byte  string  pointer  to by T1, T1
;	                contains the address of a $BYTES block.
;	       * $BLK - Output the contents of T1 in block format.
;	         $CHR - Output the contents of T1 in ASCII.
;	         $CON - Start of continuation message.
;	       * $COR - Output the contents of T1 in core format.
;	         $DAT - Output the contents of T1 in date format.
;	         $DAY - Output the contents of T1 in day format.
;	       * $DEC - Output the contents of T1 in decimal.
;	         $DIR - Output the directory name string associated with
;	                the directory number in T1.
;	         $DTL - Output the contents of T1 in long date format.
;	         $ELS - Complement output, used with $SKP.
;	         $ENT - Output  the ENTER block pointed to by T1, one of
;	                the following formats:
;	                  $OPN,,$LOC
;	                    $OPN - The location of the OPEN block.
;	                    $LOC - The   location  of  the  ENTER  block
;	                           (short/extended).
;	                  ^O0,,$FOB
;	                    $FOB - The location of the .FILOP block.
;	         $EOS - End-of-skip, see $SKP.
;	         $ERR - Output  the  file error pointed to by T1, one of
;	                the following formats:
;	                  $OPN,,$LOC
;	                    $OPN - The location of the OPEN block.
;	                    $LOC - The   location  of  the  ENTER  block
;	                           (short/extended).
;	                  ^O0,,$FOB
;	                    $FOB - The location of the .FILOP block.
;	         $ERS - Output  the  error  string  associated  with the
;	                error number in T1.
;	         $FUL - Output  the  contents of T1 in SIXBIT, including
;	                trailing blanks.
;	         $FUN - Output  the  contents  of  T1 in Funny character
;	                format (LH contains 0 or -1) or an ASCIZ  string
;	                with  Funny character fixups (bits 0-11 contains
;	                the  byte  pointer,  4000B11  implies   a   left
;	                justified ASCII byte pointer).
;	       * $HEX - Output the contents of T1 in hexadecimal.
;	         $JFN - Output  the  file  specification associated with
;	                the JFN in T1.
;	         $LFT - Output  the  contents  of the left half of T1 in
;	                SIXBIT.
;	         $LIN - Output  a  number  of  CR-LF(s), T1 contains the
;	                number of CR-LFs or if negative a form-feed.
;	         $LKP - Output the LOOKUP block pointed to by T1, one of
;	                the following formats:
;	                  $OPN,,$LOC
;	                    $OPN - The location of the OPEN block.
;	                    $LOC - The   location  of  the  ENTER  block
;	                           (short/extended).
;	                  ^O0,,$FOB
;	                    $FOB - The location of the .FILOP block.
;	         $NAM - Output the user name (2 words SIXBIT) pointed to
;	                by T1.
;	       * $NUM - Output  the number pointed to by T1, T1 contains
;	                a $NUMBER block.
;	       * $OCT - Output the contents of T1 in octal.
;	         $OPC - Output  the contents of T1 in PC format, 6 octal
;	                digits (zero fill).
;	         $PFX - Output   the   system  prefix  followed  by  the
;	                contents of T1, in SIXBIT if negative else as an
;	                ASCII character.
;	         $PPN - Output the contents of T1 as a PPN.
;	         $PRO - Output the contents of T1 as a protection.
;	         $PTH - Output a PATH block pointed to by T1.
;	         $R50 - Output the contents of T1 in RADIX-50.
;	       * $RUN - Output the contents of T1 in runtime format.
;	                  If TF%JIF is off, millisecond runtime.
;	                                on, jiffies runtime.
;	                  If TF%SIZ is off, don't output the fraction.
;	                                on, Output n digits of fraction.
;	                  If width < 0, Blank fill null fields.
;	                           = 0, Suppress null fields.
;	                           > 0, Full field output.
;	         $SCN - Output a SCAN block pointed to by T1.
;	         $SIX - Output the contents of T1 in SIXBIT.
;	         $SKP - Suppress  output  the  if  the instruction in T1
;	                skips, output is resumed on an $ELS or $EOS.
;	         $SKT - Suppress output if T1 is TRUE (non-zero), output
;	                is resumed on an $ELS or $EOS.
;	         $SPC - Output  a  number  of  space(s), T1 contains the
;	                number of spaces.
;	         $SUB - Output  the  ASCIZ string pointed to by T1, bits
;	                0-11 contains the byte pointer (zero  implies  a
;	                left   justified   ASCII   byte   pointer)  with
;	                substitutions.  Same as the $TXT argument.
;	         $TIM - Output the contents of T1 in time format.
;	         $TML - Output the contents of T1 in long time format.
;	         $UNV - Output the contents of T1 in universal format.
;	         $USR - Output  the user name string associated with the
;	                user number in T1.
;	         $VER - Output the contents of T1 in version format.
;	         $XCT - Do  an  indirect  substitution type, T1 contains
;	                the real substitution to be performed.
;	       * $XWD - Output the contents of T1 in half word format.
;	         $UR1 - A user defined routine, See $TYPES macro.
;	           .
;	           .
;	         $UR8 - A user defined routine, See $TYPES macro.
;	         $IND - Type  indirect  block  via  T1,  T1 contains the
;	                following:
;	                  -$CNT,,$ADR
;	                    $CNT - The  count  of  the maximum number of
;	                            substitutions to be made.
;	                    $ADR - The    address   of   the   list   of
;	                           substitutions to be made.  The format
;	                           of the list is:
;	                             $SUB    $LOC
;	         $IND - Type  indirect  block  via  T1,  T1 contains the
;	       Note:  $NON  is the default if not given.  * Implies this
;	              field can be right justified.
;
;	$TXT - The  text  to be typed (in angle brackets if any commas).
;	       All occurances of vertical bars (|) in the text  will  be
;	       substituted.   If  there  are  more  vertical  bars  than
;	       substitution parameters, the extra vertical bars will  be
;	       ignored.   If   there   are   fewer  vertical  bars  than
;	       substitution   parameters,   the    extra    substitution
;	       parameters be ignored.
;
;	$TRL - The trailer code:
;	         C - Carriage return - line feed.
;	         N - Nothing.
;	       Note:  C is the default if not given.
;
;	$RET - The type of return to be taken:
;	         A  - Output the current PC then do a D return.
;	         C  - Return  to  monitor/EXEC mode and allow a continue
;	              to return to the next instruction.
;	         D  - Enter  DDT  if  present  else  the  same  as the M
;	              return.  The original return address is placed  in
;	              .JBOPC.
;	         E  - If  SCAN  is  being used process any RUN  switches
;	              else return to monitor/EXEC mode and don't allow a
;	              continue.
;	         I  - Return from interrupt.
;	         M  - Return  to  monitor/EXEC  mode  and  don't allow a
;	              continue.
;	         N  - Return to the next instruction.
;	         N1 - Return to the next instruction plus 1.
;	         P  - Return to the caller (.POPJ).
;	         P1 - Return to the caller plus one (.POPJ1).
;	         S  - Return to SCAN (.FMSGE).
;	       Note:  N  is  the default if not given.  If given and not
;	              one  of  the  above;  a  transfer  of  control  to
;	              location '$RET' will be generated.
;
;	$BAS - The  database  to  use  for  this  output  (and any lower
;	       levels).
;	         C - Use  the  current database, the database defined by
;	             the last $TYPES INI/BAS or an upper level $ERROR or
;	             $TYPE call.
;	         D - Use  the  default  database,  the  database defined
;	             within TYPER.
;	         E - Use the error database.
;	         T - Use the TYPER database, for internal use only.
;	       Note:  C  is  the default if not given.  If given and not
;	              one  of  the  above;  $BAS  is  the address of the
;	              database to use.
;
;	$LST - The  list  of  substitutions parameters.  If $SUB doesn't
;	       equal $IND, $LST is the address  of  the  data.  If  $SUB
;	       equals  $IND,  $LST  would  be  an  indirect  block (i.e.
;	       <$DEC T1,$OCT T2>).
;
;	$MSG - The message level for the message.  Must be between 0 and
;	       999, inclusive, or D for the default message level.  D is
;	       the default if not given.
; Examples:
;
; One substitution:
;
;	MOVX	T1,'STR   '		; Get structure name
;	$TYPE	(F,NSL,$SIX,<Structure | is not in search list>)
;
;
; Multiple substitutions:
;
;	MOVE	T1,[-^O2,,SLST]		; Get the pointer to the list
;	$TYPE	(F,CFF,$IND,<Can't find file |.|>)
;	.
;	.
; SLST:	$SIX	FILBLK+.RBFIL
;	$LFT	FILBLK+.RBEXT
;
;
; Multiple calls:
;
;	MOVE	T1,CURSTR		; Get structure name
;	$TYPE	(W,SLL,$SIX,<Space on | is less than >,N)
;	MOVE	T1,FRESPC		; Get the
;	IDIV	T1,BLKSIZ		;  free space
;	$TYPE	(N,,$DEC,<limit of | available>)
;
;
; Different output routine:
;
;	; ** Make sure output goes to the TTY then abort **
;
;	MOVE	T1,[$NUMBER ([POINT 18,.JBOPC,35],BYTE,^D6,^D8,ZERO)]
;	$TYPE	(F,IMR,$NUM,<Illegal memory reference at PC: |>,,A,E)
;
;
; Argument pointer supplied:
;
;	$TYPE	(F,IRN,$DEC,<Invalid roman numeral (|)>,,E,E,ROMNUM)
; General format of the .TYPER parameter block:

;  !================================================================!
;  ! Message ! Header !                   .TYPER                    !
;  !----------------------------------------------------------------!
;  ! Substitution ! Flags ! Trailer ! Return !        Suffix        !
;  !----------------------------------------------------------------!
;  ! Address of database (optional) !  Return location (optional)   !
;  !----------------------------------------------------------------!
;  !              Substitution pointer block (optional)             !
;  !----------------------------------------------------------------!
;  /                                                                /
;  /                         The ASCIZ text                         /
;  /                                                                /
;  !================================================================!


	$DSBEG    TR			; The $TYPE data structure
	 $DSFLG   MSG,^D10		 ; The message level
	  $DSVAL  MAX,^D999		  ; The maximum message level
	  $DSVAL  DEF			  ; The default message level
	 $DSFLG   HDR,^D3		 ; The head field
	  $DSVAL  NON			  ; None
	  $DSVAL  CNT			  ; Continuation
	  $DSVAL  FAT			  ; Fatal
	  $DSVAL  INF			  ; Information
	  $DSVAL  MES			  ; Message to the operator
	  $DSVAL  OPR			  ; Operator
	  $DSVAL  SPC			  ; Special
	  $DSVAL  WRN			  ; Warning
	 $DSFLG   ROU,ADDRESS		 ; The routine field
	 $DSFLG   SUB,^D9		 ; The substitution field
	  $DSVAL  USR,^D8		  ; The maximum number of user routines
	 $DSFLG   XTR,^D1		 ; The extra routine flag field
	  $DSVAL  NON			  ; No extra word needed
	  $DSVAL  YES			  ; The extra word is needed
	 $DSFLG   BAS,^D1		 ; The database flag field
	  $DSVAL  NON			  ; No database specifed
	  $DSVAL  YES			  ;The database is specified
	 $DSFLG   LST,^D1		 ; The substitution flag field
	  $DSVAL  NON			  ; None supplied
	  $DSVAL  YES			  ; The substitution block was supplied
	 $DSFLG   TRL,^D1		 ; The trailer field
	  $DSVAL  NON			  ; None
	  $DSVAL  YES			  ; CR-LF
	 $DSFLG   ENC,^D1		 ; The Encode field
	  $DSVAL  NON			  ; Not $ENCODE
	  $DSVAL  YES			  ; $ENCODE
	 $DSFLG   RET,^D4		 ; The return field
	  $DSVAL  ABT			  ; Abort
	  $DSVAL  CON			  ; Continue
	  $DSVAL  DDT			  ; DDT
	  $DSVAL  XIT			  ; Exit
	  $DSVAL  INT			  ; Interrupt
	  $DSVAL  JMP			  ; Jump
	  $DSVAL  MON			  ; Monitor
	  $DSVAL  NRM			  ; Normal
	  $DSVAL  NR1			  ; Normal plus 1
	  $DSVAL  PJ1			  ; POPJ1
	  $DSVAL  PJ0			  ; POPJ
	  $DSVAL  SCN			  ; SCAN
	 $DSFLG   SFX,RIGHT		 ; The suffix field
	  $DSVAL  NON			  ; None
	  $DSVAL  XCT			  ; Execute
	 $DSFLG   BSA,LEFT		 ; The database address field
	  $DSVAL  DDB,^O0		  ; The default database
	  $DSVAL  EDB,^O777776		  ; The error database
	  $DSVAL  TDB,^O777777		  ; The TYPER database
	 $DSFLG   LOC,RIGHT		 ; The return field
	 $DSFLG   BLK,WORD,BSA		 ; The substitution list field
	 $DSFLG   TXT,WORD,BSA		 ; The text field
	$DSEND    TR			; That's all
;Define the substitution types:

	OPDEF	$NON [000B8]		; None
	OPDEF	$ASC [001B8]		; ASCIZ
	OPDEF	$BIT [002B8]		; Bits ($BITS)
	OPDEF	$BYT [003B8]		; Bytes ($BYTES)
	OPDEF	$BLK [004B8]		; Block
	OPDEF	$CHR [005B8]		; Character
	OPDEF	$CON [006B8]		; Continuationn
	OPDEF	$COR [007B8]		; Core
	OPDEF	$DAT [010B8]		; Date
	OPDEF	$DAY [011B8]		; Day
	OPDEF	$DEC [012B8]		; Decimal
	OPDEF	$DIR [013B8]		; Directory name (TOPS-20)
	OPDEF	$DTL [014B8]		; Date in long format
	OPDEF	$ELS [015B8]		; Else
	OPDEF	$ENT [016B8]		; ENTER block
	OPDEF	$EOS [017B8]		; End-of-skip
	OPDEF	$ERR [020B8]		; LOOKUP/ENTER error
	OPDEF	$ERS [021B8]		; Error string
	OPDEF	$FUL [022B8]		; Full word SIXBIT
	OPDEF	$FUN [023B8]		; 'Funny' character/string
	OPDEF	$HEX [024B8]		; Hexadecimal
	OPDEF	$JFN [025B8]		; JFN
	OPDEF	$LFT [026B8]		; Left half SIXBIT
	OPDEF	$LIN [027B8]		; New line
	OPDEF	$LKP [016B8]		; LOOKUP block
	OPDEF	$NAM [030B8]		; SIXBIT user name
	OPDEF	$NUM [031B8]		; Number ($NUMBER)
	OPDEF	$OCT [032B8]		; Octal
	OPDEF	$OPC [033B8]		; PC
	OPDEF	$PFX [034B8]		; Prefix
	OPDEF	$PPN [035B8]		; PPN
	OPDEF	$PRO [036B8]		; Protection
	OPDEF	$PTH [037B8]		; PATH block
	OPDEF	$R50 [040B8]		; RADIX-50
	OPDEF	$RUN [041B8]		; Runtime
	OPDEF	$SCN [042B8]		; SCAN block
	OPDEF	$SIX [043B8]		; SIXBIT
	OPDEF	$SKP [044B8]		; Skip output
	OPDEF	$SKT [045B8]		; Skip output, if TRUE
	OPDEF	$SPC [046B8]		; Space(s)
	OPDEF	$SUB [047B8]		; Substitution
	OPDEF	$TIM [050B8]		; Time
	OPDEF	$TML [051B8]		; Time in long format
	OPDEF	$UNV [052B8]		; Universal date/time
	OPDEF	$USR [053B8]		; User name (TOPS-20)
	OPDEF	$VER [054B8]		; Version number
	OPDEF	$XCT [055B8]		; Execute an indirect substitutution
	OPDEF	$XWD [056B8]		; Octal half words

			     $CONTINUE	; Continued on the next page
	OPDEF	$UR1 [057B8]		; User routine 1
	OPDEF	$UR2 [060B8]		; User routine 2
	OPDEF	$UR3 [061B8]		; User routine 3
	OPDEF	$UR4 [062B8]		; User routine 4
	OPDEF	$UR5 [063B8]		; User routine 5
	OPDEF	$UR6 [064B8]		; User routine 6
	OPDEF	$UR7 [065B8]		; User routine 7
	OPDEF	$UR8 [066B8]		; User routine 8
	OPDEF	$IND [100B8]		; Indirect
	$TOC	TYPER Macros -- $TYPEB Description

; $TYPEB -- Macro  to  generate the argument block used by the $ERROR or
;           $TYPE macros.
;
; Call:
;
;	$TYPEB	($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG)
;
; Note:
;
;	The  arguments  in  this  call are identical to the $TYPE calls.
;	The code generated by this call is NOT in a literal.
	$TOC	TYPER Macros -- $TYPED Description


; $TYPED -- Macro  to  define  a  database  to  be  used by $TYPE/$TYPES
;           macros.
;
; Call:
;
;	$TYPED	($FNC)
;
; Where:
;
;	$FNC - The function(s), simular to $TYPES macro, to be defined.
;	         EMP - Set up the empty the output buffer routine.
;	         ERR - Increment the .JBERR on fatal errors.
;	         JST - Set up the horizonal justification.
;	         MSG - Set up the message levels.
;	         OUT - Set up the character output routine.
;	         SYS - Set  up  the  system prefix, the default value is
;	               'TP.PFX,,0'.
;	         TIM - Set up the time stamps.
;	         VER - Set up the vertical justification.
;	         VRB - Set up the verbosity level.
;	       Note:  The  $FNC  is a list of function/value pairs.  The
;	              values  are  the  same as those in T1 for the same
;	              $TYPES function.
;
; Example:
;
;	Create database with justification and time stamps:
;
;		MOVSI	T1,TP.PFX	; Get the default prefix
;		HRRI	T1,TYPBAS	; Set/reset the database
;		$TYPES	(INI)		; Initialize TYPER
;		.
;		.
;	TYPBAS:	$TYPED	(<<JST,<-JSTSIZ,,JSTTAB>>,<TIM,,<-1,,TIMSIX>>>)
; The general format of the TYPER database:

;  !===================================================================!
;  !              Flags              !              Column             !
;  !-------------------------------------------------------------------!
;  !                      Character Output Routine                     !
;  !-------------------------------------------------------------------!
;  !                      Space Compression Count                      !
;  !-------------------------------------------------------------------!
;  !                        Empty Buffer Routine                       !
;  !-------------------------------------------------------------------!
;  !                          Tab-stop Pointer                         !
;  !-------------------------------------------------------------------!
;  !                       Default Message Level                       !
;  !-------------------------------------------------------------------!
;  !                       Maximum Message Level                       !
;  !-------------------------------------------------------------------!
;  !                           Message Level                           !
;  !-------------------------------------------------------------------!
;  !                           System Prefix                           !
;  !-------------------------------------------------------------------!
;  !                            Time Stamps                            !
;  !-------------------------------------------------------------------!
;  !                          Verbosity Level                          !
;  !-------------------------------------------------------------------!
;  /                                                                   \
;  /                       Vertical Justification                      \
;  /                                                                   \
;  !===================================================================!


	$DSBEG    TB			; Define the TYPER data base
	 $DSFLG   FLG,LEFT		 ; The flags
	  $DSBIT  VHT			  ; Or of TB%VER, TB%HOR, TB%TIM and
					  ;  TB%CMP
	  $DSBIT  VER			  ; Vertical justification is wanted
	  $DSBIT  HOR			  ; Horizonal justification is wanted
	  $DSBIT  TIM			  ; Time stamps are wanted
	  $DSBIT  CMP			  ; Compress multiple spaces to tabs
	  $DSBIT  BOF			  ; At bottom of form
	  $DSBIT  CON			  ; A suppressed continuation message
	  $DSBIT  ERR			  ; Increment .JBERR on fatal errors
	  $DSBIT  INF			  ; An information header
	  $DSBIT  LCC			  ; Last character was a carriage-return
	  $DSBIT  SUP			  ; Suppress the rest of this message
	  $DSBIT  TOF			  ; At top of form
	  $DSBIT  TTS			  ; It is time for a time stamp
	 $DSFLG   COL,RIGHT		 ; The column count
	 $DSFLG   CHR,ADDRESS		 ; Routine to output a character
	 $DSFLG   CMP,WORD		 ; The space compression count
	 $DSFLG   EMP,ADDRESS		 ; Routine to empty the buffer
	 $DSFLG   HOR,WORD		 ; The pointer to the tab stops
	 $DSFLG   MDF,WORD		 ; The default message level
	 $DSFLG   MML,WORD		 ; The maximum message level
	 $DSFLG   MSG,WORD		 ; The message levels
	 $DSFLG   SYS,WORD		 ; The system prefix
	 $DSFLG   TIM,WORD		 ; The time stamp setting
	 $DSFLG   VRB,WORD		 ; The verbosity level
	 $DSFLG   VER,WORD		 ; The pointer to the vertical
					 ;  information
	 $DSFLG   HRT,WORD		 ; The vertical header routine
	 $DSFLG   TRT,WORD		 ; The vertical trailer routine
	 $DSFLG   HLN,WORD		 ; The vertical end of header, line
					 ;  number
	 $DSFLG   TLN,WORD		 ; The vertical start of trailer,
					 ;  line number
	 $DSFLG   PLN,WORD		 ; The vertical page length
	 $DSFLG   CLN,WORD		 ; The vertical current line number
	 $DSFLG   SCN,WORD		 ; The address display database
	$DSEND    TB,LEN		; The length of the data base
	$TOC	TYPER Macros -- $TYPER Description


; $TYPER -- An  OPDEF  used  to  return to the instruction following the
;           $ERROR, $TYPE or $TYPES which entered  DDT.  This  OPDEF  is
;           defined by the $BEGIN macro.
;
; Use:
;
;	$TYPER<ESC>X
;
; Note:
;
;	This  OPDEF  should only be used when returning from DDT after a
;	TYPER call entered DDT.
	$TOC	TYPER Macros -- $TYPES Description


; $TYPES -- Macro to do system calls to TYPER.
;
; Call:
;
;	$TYPES	($FNC,$RET,$BAS,$ADR)
;
; Where:
;
;	$FNC - The function to be performed:
;	         BAS - Change the database to use.
;	         BUG - System/program bug.
;	         CMP - Change the space compression flag.
;	         COL - Get the current column count.
;	         DMP - Dump the text buffer.
;	         EMP - Change the empty the character buffer routine.
;	         ERR - Change the increment of .JBERR on fatal messages.
;	         ESN - Change the error string number.
;	         EXT - Add an external string file.
;	         INI - Initialize TYPER.
;	         JST - Change the justification tab stop(s).
;	         LOC - Get the contents of a location.
;	         MSG - Change the message level.
;	         OUT - Change the character output routine.
;	         PIC - Change the address of the picture saving core.
;	         PRM - Output user prompt, clearing Control-O.
;	         RTN - Change the user substitution routine(s).
;	         SYS - Change the system prefix.
;	         TIM - Change the time stamp.
;	         VER - Change the vertical justification.
;	         VRB - Change the verbosity level.
;	         ZON - Change the time zone.
;
;	$RET - The type of return to be taken:
;	         A  - Output the current PC then do a D return.
;	         C  - Return  to  monitor/EXEC mode and allow a continue
;	              to return to the next instruction.
;	         D  - Enter  DDT  if  present  else  the  same  as the M
;	              return.  The original return address is placed  in
;	              .JBOPC.
;	         E  - If  SCAN  is  being used process any RUN  switches
;	              else return to monitor/EXEC mode and don't allow a
;	              continue.
;	         I  - Return from interrupt.
;	         M  - Return  to  monitor/EXEC  mode  and  don't allow a
;	              continue.
;	         N  - Return to the next instruction.
;	         N1 - Return to the next instruction plus 1.
;	         P  - Return to the caller (.POPJ).
;	         P1 - Return to the caller plus one (.POPJ1).
;	         S  - Return to SCAN (.FMSGE).
;	       Note:  N  is  the default if not given.  If given and not
;	              one  of  the  above;  a  transfer  of  control  to
;	              location $RET will be generated.
;
;	$BAS - The  database  to  use  for  this  output  (and any lower
;	       levels).
;	         C - Use  the  current database, the database defined by
;	             the last $TYPES INI/BAS or an upper level $ERROR or
;	             $TYPE call.
;	         D - Use  the  default  database,  the  database defined
;	             within TYPER.
;	         E - Use the error database.
;	         T - Use the TYPER database, for internal use only.
;	       Note:  C  is  the default if not given.  If given and not
;	              one  of  the  above;  $BAS  is  the address of the
;	              database to use.
;
;	$ADR - The address of where to get and store the argument.
;	       Note:  The default is 'T1'.
; Examples:
;
; Change the database to use:
;
;	MOVEI	T1,BASADR		; The address of the new database,
;					;  as defined by the $TYPED macro
;	HRLI	T1,BASFNC		; The subfunction to be performed:
;					;   .TFCLR - Clear the database
;					;	     specified, then make
;					;	     it the default
;					;   .TFINI - Initialize the database
;					;   .TFRST - Reset the database
;					;	     specified, then make
;					;	     it the default
;					;   .TFUSE - Make this database the
;					;	     default
;	$TYPES	(BAS)			; The old database address is
;					;  returned in T1
;
;
; System bug:
;
;	$TYPES	(BUG)			; Type the following message:
;					;  "?pfxPLE Program logic error,
;					;  PC: l (r')" doesn't return,
;					;  then enter DDT if present
;
;
; Change the space compression:
;
;	MOVX	T1,NEWVAL		; Get the new value setting:
;					;   =0 - Don't space compress
;					;   #0 - Do space compression
;	$TYPES	(CMP)			; The old setting is in T1
;
;
; Get the current column count:
;
;	$TYPES	(COL)			; Get the current column count,
;					;  the result is in T1
;
;
; Dump the text buffer:
;
;	$TYPES	(DMP)			; Dump the text buffer to the TTY
; Empty character buffer routine:
;
;	MOVEI	T1,RTN			; Get the new empty routine
;	$TYPES	(EMP)			; The old empty routine is in T1
;		.
;		.
; RTN -- The routine to empty the character buffer
; Call:	PUSHJ	P,RTN
;	 * Return *
; Uses:	No ACs
; RTN:		.
;
;
; Change the .JBERR update:
;
;	MOVX	T1,NEWVAL		; Get the new value setting:
;					;   =0 - Don't update .JBERR on
;					;        fatal error messages
;					;   #0 - Update .JBERR on fatal
;					;        error messages
;	$TYPES	(ERR)			; The old setting is in T1
;
;
; Change the external string number:
;
;	MOVX	T1,NUMBER		; Get the error string number to
;					;  be used on the next $ERS sub-
;					;  stitution, inwhich the default
;					;  is requested
;					; If the new value equals .TFCUR
;					;  only the old value is obtained
;	$TYPES	(ESN)			; The old value is in T1
;
;
; Add an external string file:
;
;	MOVEI	T1,ESF			; The new external string file
;		$TYPES	(EXT)		; On return T1 contains the JFN or
;					;  channel in the left half and
;					;  the error code in the right
;					;  half, the errors are:
;					;    .TFNON - No errors detected
;					;    .TFNRA - No room available
;					;    .TFOVR - Overlap with an
;					;	      exsisting file
;					;    .TFRNG - Invalid range
;					;    .TFUGA - Unable to get access
;					;	      to the string file
; ESF:	$FSPEC	EXTERN.STR		; The SCAN block for the external
;					;  string file
; Initialize TYPER:
;
;	MOVSI	T1,'PFX'		; Get the system prefix or zero
;					;  (same as the 'SYS' function)
;	HRRI	T1,RTN			; Get the output routine or zero
;					;  (same as the 'OUT' function)
;	$TYPES	(INI)			; Initialize TYPER, needed if SCAN
;					;  is being used and a different
;					;  output routine, justification,
;					;  and/or time stamps are wanted
;
;
; Justification (tab stop) change:
;
;	MOVE	T1,[-SIZ,,ADR]		; Set up the tab stop(s) for
;					;  justification:
;					;    SIZ - The size of the tab stop
;					;	   table
;					;    ADR - The address of the tab
;					;	   stop table
;	$TYPES	(JST)			; The old justification information
;		.			;  is in T1
;		.
; ADR:	WID,,TAB			; WID - The width of the field
;	WID,,TAB			; TAB - The tab stop for this field,
;		.			;       must be in ascending order
;		.
; SIZ==.-ADR				; Get the maximum number of tab stops
;
;
; Get the contents of a location:
;
;	MOVX	T1,LOCAT		; Get the contents of location
;					;  "LOCAT", indirect and indexing
;					;  are allowed
;	$TYPES	(LOC)			; The contents will be in T1
;
;
; Set the message level:
;
;	HRRZI	T1,MSGLVL		; The default message level
;	HRLI	T1,MAXLVL		; The maximum message level to be
;					;  output
;	$TYPES	(MSG)			; The old message level is in T1
; Change character output routine:
;
;	MOVEI	T1,RTN			; Get the new output routine
;	TXO	T1,TF.CTL		; Set if output is NOT going to the
;					;  controlling TTY
;	$TYPES	(OUT)			; The old output routine is in T1
;		.
;		.
; RTN -- The routine to output a character
; Call:	MOVX	T1,{the character to output}
;	PUSHJ	P,ROUTIN
;	 * Return *
; Uses:	No ACs
; RTN:		.
;
;
; Change the picture core:
;
;	MOVE	T1,[SIZ,,ADR]		; Set up the core address:
;					;   SIZ - The size of the core block
;					;   ADR - The address of the core
;					;         block
;	$TYPES	(PIC)			; The old core block is in T1
;
;
; Output user prompt:
;
;[CSM] Match angle brackets on next line
;	MOVX	T1,PROMPT		; Get the prompt character to output
;					;  after the system prefix:
;					; <  > - Normal
;					;    # - Continuation
;					;    ! - Running
;					;    / - Interrupt
;	$TYPES	(PRM)			; Output the prompt and dump text
;					;  buffer
; User substitution routine change:
;
;	MOVE	T1,[SIZ,,ADR]		; Set up the user substitution
;					;  routine(s):
;					;    SIZ - The maximum number of user
;					;	   substitution routines
;					;    ADR - The address of the table
;					;	   of substitution routines
;	$TYPES	(RTN)			; The old user substitution routine(s)
;					;  is in T1
;		.
;		.
; ** Note:  These routine(s) can only modify T1-T4
; ADR:	UR1				; User routine for $UR1
;	UR2				; User routine for $UR2
;	.
;	.
; SIZ==.-ADR				; Get the maximum number of user
;					;  routines
;
;
; System prefix change:
;
;	MOVSI	T1,'PFX'		; Get the new system prefix
;	$TYPES	(SYS)			; The old system prefix is in T1
;
;
; System time stamp change:
;
;	MOVX	T1,NEWTIM		; Get the time stamp setting:
;					;   <-1 - Add time stamps and type
;					;	  the contents of NEWTIM
;					;	  in SIXBIT
;					;    -1 - Add time stamps
;					;     0 - Remove time stamps
;					;    >0 - Add time stamps and call
;					;        routine NEWTIM
;	$TYPES	(TIM)			; The old time stamp value is in T1
;
;
; Set the vertical justication:
;
;	MOVEI	T1,VERTAB		; The address of the vertical just-
;					;  ification table
;	$TYPES	(VER)			; The old vertical justification
;					;  information is in T1
;
;
; Set the verbosity level:
;
;	MOVX	T1,VRBLVL		; Get the new verbosity level
;	$TYPES	(VRB)			; The old verbosity level is in T1
; Time zone change:
;
;	MOVX	T1,NEWZON		; The new time zone
;	TXO	T1,TF.DLS		; Turn on daylight saving if wanted
;	$TYPES	(ZON)			; The old time zone is in T1
; General format of the .TYPES parameter block:

;  !================================================================!
;  ! Function ! Return ! Flags !              .TYPES                !
;  !----------------------------------------------------------------!
;  ! Address of database (optional) !  Return location (optional)   !
;  !----------------------------------------------------------------!
;  !                  Argument address (Optional)                   !
;  !----------------------------------------------------------------!
;  !                    (Bug data #2 (optional)                     !
;  !================================================================!


	$DSBEG    TS			; The $TYPES data structure
	 $DSFLG   FNC,^D5		 ; The function field
	  $DSVAL  BAS			  ; Database
	  $DSVAL  BUG			  ; Bug
	  $DSVAL  CMP			  ; Compress
	  $DSVAL  COL			  ; Column
	  $DSVAL  DMP			  ; Dump
	  $DSVAL  EMP			  ; Empty
	  $DSVAL  ERR			  ; Error
	  $DSVAL  ESN			  ; Error string number
	  $DSVAL  EXT			  ; External
	  $DSVAL  INI			  ; Initialization
	  $DSVAL  JST			  ; Justification
	  $DSVAL  LOC			  ; Location
	  $DSVAL  MSG			  ; Message
	  $DSVAL  OUT			  ; Output
	  $DSVAL  PIC			  ; Picture
	  $DSVAL  PRM			  ; Prompt
	  $DSVAL  RTN			  ; Routine
	  $DSVAL  SYS			  ; System
	  $DSVAL  TIM			  ; Time stamp
	  $DSVAL  VER			  ; Vertical
	  $DSVAL  VRB			  ; Verbosity
	  $DSVAL  ZON			  ; Time zone
	 $DSFLG   RET,^D4		 ; The return field
	  $DSVAL  ABT			  ; Abort
	  $DSVAL  CON			  ; Continue
	  $DSVAL  DDT			  ; DDT
	  $DSVAL  XIT			  ; Exit
	  $DSVAL  INT			  ; Interrupt
	  $DSVAL  JMP			  ; Jump
	  $DSVAL  MON			  ; Monitor
	  $DSVAL  NRM			  ; Normal
	  $DSVAL  NR1			  ; Normal plus 1
	  $DSVAL  PJ1			  ; POPJ1
	  $DSVAL  PJ0			  ; POPJ
	  $DSVAL  SCN			  ; SCAN
	 $DSFLG   ARG,^D1		 ; The address is specified
	  $DSVAL  NON			  ; None supplied
	  $DSVAL  YES			  ; The argument address is supplied
	 $DSFLG   XTR,^D1		 ; The extra word flag field
	  $DSVAL  NON			  ; No extra word needed
	  $DSVAL  YES			  ; The extra word is needed
	 $DSFLG   BAS,^D1		 ; The database flag field
	  $DSVAL  NON			  ; No database specifed
	  $DSVAL  YES			  ; The database is specified
	 $DSFLG   ROU,ADDRESS		 ; The routine field
	 $DSFLG   BSA,LEFT		 ; The database address field
	  $DSVAL  DDB,^O0		  ; The default database
	  $DSVAL  EDB,^O777776	  	  ; The error database
	  $DSVAL  TDB,^O777777		  ; The TYPER database
	 $DSFLG   LOC,RIGHT		 ; The return field
	 $DSFLG   ADR,WORD,BSA		 ; The address of the argument
	 $DSFLG   BUG,WORD,BSA		 ; The bug data
	$DSEND    TS			; That's all
; The format of the $TYPES VER database:

;  !==========================================================!
;  !                   Header output routine                  !
;  !----------------------------------------------------------!
;  !                  Trailer output routine                  !
;  !----------------------------------------------------------!
;  !               Line number of end-of-header               !
;  !----------------------------------------------------------!
;  !              Line number of start-of-trailer             !
;  !----------------------------------------------------------!
;  !                Form length or -1, for <FF>               !
;  !==========================================================!


	$DSBEG	  TS			; The $TYPES VER database
	 $DSFLG   HRT,RIGHT		 ; The header routine
	 $DSFLG   TRT,RIGHT		 ; The trailer routine
	 $DSFLG   HLN,WORD		 ; The end of header, line number
	 $DSFLG   TLN,WORD		 ; The start of trailer, line number
	 $DSFLG   PLN,WORD		 ; The page length
	$DSEND    TS			; That's all folks
	$TOC	TYPER Macros -- TYPER Symbols


; Define some flags


	; The functions used by $TYPES (BAS), database

		TF%FNC==^O77B17		; The function code
		 .TFUSE==^O0		 ; Set the database only, must be zero
		 .TFCLR==^O1		 ; Clear the database
		 .TFINI==^O2		 ; Initialize the database
		 .TFRST==^O3		 ; Reset the database
		TF%BAS==^O777777	; The data base address


	; The flag used by $TYPES (ESN), error string number

		.TFCUR==-^O1		; Get the current error string number
					;  only


	; The errors returned by $TYPES (EXT), external string file

		.TFNON==^O0		; No errors detected
		.TFNRA==^O1		; No room available
		.TFOVR==^O2		; Overlap with an exsisting file
		.TFRNG==^O3		; Invalid range maximum less than
					;  minimum
		.TFUGA==^O4		; Unable to get access to the string
					;  file
		.TFIFF==^O5		; Illegal format for the external
					;  string file

	; The flag used by $TYPES (EXT), external string file

		.TFEND==^O777777	; End of the external string file


	; The flags used by $TYPES (MSG), output message level

		TF%WMS==^O207B35	; The mask for message output
		 %TFWAD==B28		 ; Output the address
		 %TFWCN==B33		 ; Output the continuation line
		 %TFWFL==B34		 ; Output the first line
		 %TFWPR==B35		 ; Output the prefix


	; The flag used by $TYPES (OUT), output routine

		TF%CTL==B0		; The output is NOT going to the
					;  controlling TTY, used only for
					;  error messages.
	; The flag used by $TYPES (ZON), time zone

		TF%DLS==B0		; Daylight savings time
		TF%ZON==^O777777	; The time zone
		 .TFAST==^O4		 ; Atlantic time zone
		 .TFEST==^O5		 ; Eastern time zone
		 .TFCST==^O6		 ; Central time zone
		 .TFMST==^O7		 ; Mountain time zone
		 .TFPST==^O10		 ; Pacific time zone
		 .TFYST==^O11		 ; Yukon time zone
		 .TFHST==^O12		 ; Hawaii time zone
		 .TFBST==^O13		 ; Bering time zone
	; The flags used by the $ASC (.TASCI) substitution

		TF%EXT==^O5B2		; An external ASCIZ string
		TF%ESN==^O777777	; The external string number


	; The flags used by the $JFS (.TJFNS) substitution

		TF%DEV==^O3B1		; Device field
		TF%DIR==^O3B3		; Directory field
		TF%NAM==^O3B5		; File name field
		TF%TYP==^O3B7		; File type field
		TF%GEN==^O3B9		; Generation number field
		TF%PRO==^O3B11		; Protection field
		TF%ACT==^O3B13		; Account field
		TF%TMP==B14		; Temporary (;T) field
		TF%TBR==B15		; Tab before all fields returned
		TF%TBP==B16		; Tab before all possible fields
					;  returned
		TF%PAF==B17		; Punctuate all fields
		 .TFNOF==^O0		 ; Don't output this field
		 .TFAOF==^O1		 ; Always output this field
		 .TFSSD==^O2		 ; Suppress this field if it is system
					 ;  default
		TF%JFN==^O777777	; The JFN

					; The default output flags
		TF%DEF==<$INSVL(.TFAOF,TF%DEV)!$INSVL(.TFAOF,TF%DIR)!$INSVL(.TFAOF,TF%NAM)!$INSVL(.TFAOF,TF%TYP)!$INSVL(.TFAOF,TF%GEN)!TF%PAF>


	; The flags used by the $OPC (.TOPC) substitution

		.TFCUR==-^O1		; Current caller's PC
		.TFPRE==-^O2		; Previous caller's PC
	; The flags used by the $RUN (.TRUNN) substitution

		TF%JIF==B0		; The runtime is in jiffies
		TF%SIZ==^O3B2		; The number of decimal places wanted
		 %TFSZ0==^O0B2		 ; Output HH:MM:SS
		 %TFSZ1==^O1B2		 ; Output HH:MM:SS.S
		 %TFSZ2==^O2B2		 ; Output HH:MM:SS.SS
		 %TFSZ3==^O3B2		 ; Output HH:MM:SS.SSS
		TF%RUN==^O77777777777	; The runtime


	; The flag used by the $SUB (.TSUBS) substitution

		.TFMAX==^D499		; The maximum external subtitution
					;  string


	; The special output character prefixes

		.TRNON==^O0		; Nothing
		.TRBNK==^O1		; Blank
		.TRTAB==^O2		; Tab
	$TOC	TYPER Macros -- $BITS Macro


DEFINE	$BITS [SALL] ($FNC,$MSG,$BIT,$MSK,$FLG,$XTR),<

	PURGE	.BTFNC,%BTFLG

;;		** Verify the function code **

IFB <$FNC>,<.BTFNC==.BTAND>		;; And (default)
IFIDNX <$FNC><AND>,<.BTFNC==.BTAND>	;; And
IFIDNX <$FNC><COMMA>,<.BTFNC==.BTCOM>	;; Comma
IFIDNX <$FNC><CRLF>,<.BTFNC==.BTLIN>	;; CR-LF
IFIDNX <$FNC><EXCLAIM>,<.BTFNC==.BTXCL>	;; Exclaim
IFIDNX <$FNC><FIELD>,<.BTFNC==.BTFLD>	;; Field
IFIDNX <$FNC><NONE>,<.BTFNC==.BTNON>	;; Nothing
IFIDNX <$FNC><OR>,<.BTFNC==.BTOR>	;; Or
IFIDNX <$FNC><PLUS>,<.BTFNC==.BTPLS>	;; Plus
IFIDNX <$FNC><SPACE>,<.BTFNC==.BTSPC>	;; Space
IFIDNX <$FNC><USER>,<.BTFNC==.BTUSR>	;; User

IFNDEF .BTFNC,<$PRINT F,AUF,$BITS - An undefined function ($FNC)>

;;		** Verify the messages, bits and mask **

IFB <$MSG>,<$PRINT F,MAR,$BITS - Messages are required ($MSG)>

IFB <$BIT>,<$PRINT F,BAR,$BITS - Bits are required ($BIT)>

IFB <$MSK>,<$PRINT F,MIR,$BITS - Mask is required ($MSK)>

;;		** Verify the flags **

IFB <$FLG>,<%BTFLG==%BTASC>		;; ASCII (default)
IFNB <$FLG>,<
  %BTFLG==0
  IRP $FLG,<
    IFIDNX <$FLG><ASCII>,<		;; ASCII
      IFN <%BTFLG&<%BTASC!%BTSIX>>,<
        $PRINT F,CNF,$BITS - Conflicting flags ($FLG) >
      %BTFLG==<%BTFLG!%BTASC> >
    IFIDNX <$FLG><BIT>,<		;; Bit
      IFN <%BTFLG&%BTBIT>,<
        $PRINT F,MDF,$BITS - Multiply defined flag ($FLG) >
      %BTFLG==<%BTFLG!%BTBIT> >
    IFIDNX <$FLG><EXTRA>,<		;; Extra
      IFN <%BTFLG&%BTXTR>,<
        $PRINT F,MDF,$BITS - Multiply defined flag ($FLG) >
      IFN <<.BTFNC-.BTFLD>*<.BTFNC-.BTUSR>>,<
        $PRINT F,XUF,$BITS - EXTRA can only be used with FIELD and USER >
      %BTFLG==<%BTFLG!%BTXTR> >
    IFIDNX <$FLG><MASK>,<		;; Mask
      IFN <%BTFLG&%BTMSK>,<
        $PRINT F,MDF,$BITS - Multiply defined flag ($FLG) >
      %BTFLG==<%BTFLG!%BTMSK> >
    IFIDNX <$FLG><MESSAGES>,<		;; Messages
      IFN <%BTFLG&%BTMES>,<
        $PRINT F,MDF,$BITS - Multiply defined flag ($FLG) >
       %BTFLG==<%BTFLG!%BTMES> >
    IFIDNX <$FLG><NUMBER>,<		;; Number
      IFN <%BTFLG&%BTNUM>,<
        $PRINT F,MDF,$BITS - Multiply defined flag ($FLG) >
      IFE <.BTFNC-.BTFLD>,<
        $PRINT F,NOU,$BITS - NUMBER can only be used with non-FIELD >
      %BTFLG==<%BTFLG!%BTNUM> >
    IFIDNX <$FLG><OCTAL>,<		;; Octal
      IFN <%BTFLG&%BTOCT>,<
        $PRINT F,MDF,$BITS - Multiply defined flag ($FLG) >
      IFN <.BTFNC-.BTFLD>,<
        $PRINT F,OOU,$BITS - OCTAL can only be used with FIELD >
      %BTFLG==<%BTFLG!%BTOCT> >
    IFIDNX <$FLG><SIXBIT>,<		;; SIXBIT
      IFN <%BTFLG&<%BTASC!%BTSIX>>,<
        $PRINT F,CNF,$BITS - Conflicting flags ($FLG) >
      %BTFLG==<%BTFLG!%BTSIX> >>>

;;		** Verify the extra argument **

IFE <<.BTFNC-.BTFLD>*<.BTFNC-.BTUSR>>,<
  IFB <$XTR>,<$PRINT F,UMR,$BITS - User separator or maximum is required >>

;;		** Generate the $BIT block **

IFNDEF .TBITS,<
  EXTERN .TBITS >

	%BTFLG!<.BTFNC_BT$FNC>+<$MSG>
	$BIT
	$MSK
IFE <<.BTFNC-.BTFLD>*<.BTFNC-.BTUSR>>,<
	$XTR >

>					; End of 'DEFINE $BITS'
	$TOC	TYPER Macros -- $BYTES Macro


DEFINE	$BYTES [SALL] ($TYP,$PTR,$CNT,$TRM,$SEP,$FLG,$XTR),<

	PURGE	.BYTYP,.BYCNT,.BYTRM,.BYSEP,.BYBAS

;;		 ** Verify the the type code **

IFB <$TYP>,<.BYTYP==.BYASC>		;; ASCII (default)
IFIDNX <$TYP><ASCII>,<.BYTYP==.BYASC>	;; ASCII
IFIDNX <$TYP><DEC>,<			;; DEC (decimal)
  .BYTYP==.BYRDX
  .BYBAS==^D10 >
IFIDNX <$TYP><HEX>,<			;; HEX (hexadecimal)
  .BYTYP==.BYRDX
  .BYBAS==^D16 >
IFIDNX <$TYP><OCT>,<			;; OCT (octal)
  .BYTYP==.BYRDX
  .BYBAS==^D8 >
IFIDNX <$TYP><RADIX>,<.BYTYP==.BYRDX>	;; Radix
IFIDNX <$TYP><SIXBIT>,<.BYTYP==.BYSIX>	;; SIXBIT

IFNDEF .BYTYP,<$PRINT F,AUT,$BYTES - An undefined type ($TYP)>

;;		** Verify the pointer **

IFB <$PTR>,<$PRINT F,PIR,$BYTES - The pointer is required>

;;		** Verify the count **

IFB <$CNT>,<.BYCNT==^O0>		;; Zero (default)
IFNB <$CNT>,<.BYCNT==<$CNT>>

;;		** Verify the terminating byte **

IFB <$TRM>,<.BYTRM==.CHNUL>		;; .CHNUL (default)
IFNB <$TRM>,<.BYTRM==<$TRM>>

;;		** Verify the seperator **

IFB <$SEP>,<
  IFE <.BYTYP-.BYRDX>,<.BYSEP==.BYCOM>	;; Comma (default)
  IFN <.BYTYP-.BYRDX>,<.BYSEP==.BYNON> >;; None (default)
IFIDNX <$SEP><COMMA><.BYSEP==.BYCOM>	;; Comma
IFIDNX <$SEP><CRLF><.BYSEP==.BYLIN>	;; CR-LF
IFIDNX <$SEP><NONE><.BYSEP==.BYNON>	;; None
IFIDNX <$SEP><SPACE><.BYSEP==.BYSPC>	;; Space
IFIDNX <$SEP><USER><.BYSEP==.BYUSR>	;; User

IFNDEF .BYSEP,<$PRINT F,AUS,$BYTES - An undefined seperator ($SEP)>

;;		** Verify the flags **

%BYFLG==^O0

IFNB <$FLG>,<
  IRP $FLG,<
    $BYTE1 ($FLG) >>

;;		** Verify the radix **

IFE <.BYTYP-.BYRDX>,<
  IFNDEF .BYBAS,<$PRINT F,AUR,$BYTES - An undefined radix> >
IFN <.BYTYP-.BYRDX>,<.BYBAS==^O0>

;;		** Verify the extra parameter **

IFE <.BYSEP-.BYUSR>,<
  IFB <$XTR>,<$PRINT F,USR,$BYTES - User seperator is required> >

;;		** Generate the argument block **

IFNDEF .TBYTE,<
  EXTERN .TBYTE >

	<.BYTYP_BY$TYP>!%BYFLG!<.BYSEP_BY$SEP>!<.BYBAS_BY$RDX>
	<$PTR>
	.BYCNT
	.BYTRM
IFE <.BYSEP-.BYUSR>,<
	<$XTR> >

>					; End of 'DEFINE $BYTES'


DEFINE	$BYTE1 [SALL] ($FLG),<

$BYTE2 ($FLG)

>					; End of 'DEFINE $BYTE1'


DEFINE	$BYTE2 [SALL] ($FLG,$VAL),<

IFIDNX <$FLG><COUNT>,<%BYFLG==%BYCNT>	;; Count
IFIDNX <$FLG><POINTER>,<%BYFLG==%BYPTR>	;; Pointer
IFIDNX <$FLG><RADIX>,<			;; Radix
  IFB <$VAL>,<.BYBAS==^D8>
  IFIDNX <$VAL><DEC>,<.BYBAS==^D10>	;; Radix - decimal
  IFIDNX <$VAL><HEX>,<.BYBAS==^D16>	;; Radix - hexadecimal
  IFIDNX <$VAL><OCT>,<.BYBAS==^D8>	;; Radix - octal
  IFNDEF .BYBAS,<
    IFGE <<$VAL>-^D2>,<
      IFLE <<$VAL>-^D36>,<.BYBAS==<$VAL>> >>
  IFNDEF .BYBAS,<$PRINT F,AUR,$BYTES - An undefined radix ($VAL)> >
IFIDNX <$FLG><SEPERATOR>,<%BYFLG==%BYSEP>;; Seperator
IFIDNX <$FLG><TERMINATE>,<%BYFLG==%BYTRM>;; Pointer

>					; End of 'DEFINE $BYTE2'
	$TOC	TYPER Macros -- $ERROR Macro


DEFINE	$ERROR [SALL] ($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG),<

;		** Verify the parameters sent **

$TYPE1 ($HDR,$SFX,$SUB,<$TXT>,$TRL,<$RET>,<$BAS>,<$LST>,<$MSG>,$ERROR)

;		** Generate the TYPER call **

IFE <.TRSFX-.TRXCT>,<
	$ERCAL	@$$$'$SFX >
IFN <.TRSFX-.TRXCT>,<
   IFN <.TRSFX-.TRNON>,<
      $$$'$SFX:! >
	$ERCAL	@[$TYPE2 (<$TXT>)] >

>					; End of 'DEFINE $ERROR'
	$TOC	TYPER Macros -- $NUMBER Macro


DEFINE	$NUMBE [SALL] ($ADR,$TYP,$DTP,$DPT,$NOT,$EX1,$EX2,$EX3,%CNT),<

PURGE	.NMTYP,.NMDTP,.NMDPT,.NMNOT,.NMFIL,.NMWID,.NMFRC,.NMRDX

%NMFLG==^D0
%NMAUX==^D0

;;		** Verify the type code **

IFB <$TYP>,<.NMTYP==.NMINT>		;; Integer (default)
IFIDNX <$TYP><FLOAT>,<.NMTYP==.NMFLT>	;; Float
IFIDNX <$TYP><INTEGER>,<.NMTYP==.NMINT>	;; Integer
IFIDNX <$TYP><SPECIAL>,<.NMTYP==.NMSPC>	;; Special

IFNDEF .NMTYP,<$PRINT F,AUT,$NUMBER - An undefined type ($TYP)>

;;		** Verifty the data-type code **

IFE <.NMTYP-.NMFLT>,<			;; Float
  IFB <$DTP>,<.NMDTP==.NMSNG>		;; Single (default)
  IFIDNX <$DTP><DOUBLE>,<.NMDTP==.NMDBL>;; Double
  IFIDNX <$DTP><SINGLE>,<.NMDTP==.NMSNG> >;; Single

IFE <<.NMTYP-.NMINT>*<.NMTYP-.NMSPC>>,<	;; Integer/special
  IFB <$DTP>,<.NMDTP==.NMSNG>		;; Single (default)
  IFIDNX <$DTP><BYTE>,<.NMDTP==.NMBYT>	;; Byte
  IFIDNX <$DTP><DOUBLE>,<.NMDTP==.NMDBL>;; Double
  IFIDNX <$DTP><LEFT>,<.NMDTP==.NMXLT>	;; Left half, extended
  IFIDNX <$DTP><RIGHT>,<.NMDTP==.NMXRT>	;; Right half, extended
  IFIDNX <$DTP><SINGLE>,<.NMDTP==.NMSNG> >;; Single

IFNDEF .NMDTP,<$PRINT F,UDT,$NUMBER - An undefined data-type ($DTP)>

;;		** Verify the data-pointer code **

IFE <.NMDTP-.NMBYT>,<			;; Byte
  IFB <$DPT>,<.NMDPT==.NMPTR>		;; Pointer (default)
  IFIDNX <$DPT><INDIRECT>,<.NMDPT==.NMIND>;; Indirect
  IFIDNX <$DPT><POINTER>,<.NMDPT==.NMPTR> >;; Pointer

IFN <.NMDTP-.NMBYT>,<			;; Double/left/right/single
  IFB <$DPT>,<.NMDPT==.NMADR>		;; Address (default)
  IFIDNX <$DPT><ADDRESS>,<.NMDPT==.NMADR>;; Address
  IFIDNX <$DPT><IMMEDIATE>,<.NMDPT==.NMIMD>;; Immediate
  IFIDNX <$DPT><INDIRECT>,<.NMDPT==.NMIND> >;; Indirect

IFNDEF .NMDPT,<$PRINT F,UDP,$NUMBER - An undefined data-pointer ($DPT)>

;;		** Verify the notation code **

IFE <.NMTYP-.NMFLT>,<			;; Float
  IFB <$NOT>,<.NMNOT==.NMNRM>		;; Normal (default)
  IFIDNX <$NOT><NORMAL>,<.NMNOT==.NMNRM>;; Normal
  IFIDNX <$NOT><SCIENTIFIC>,<.NMNOT==.NMSCI>>;; Scientific

IFE <.NMTYP-.NMINT>,<			;; Integer
  IFB <$NOT>,<.NMNOT==.NMUNS>		;; Unsigned (default)
  IFIDNX <$NOT><SIGNED>,<.NMNOT==.NMSIN>;; Signed
  IFIDNX <$NOT><UNSIGNED>,<.NMNOT==.NMUNS>;; Unsigned
  IFDEF .NMNOT,<
    IFE <.NMNOT-.NMUNS>,<
      IFE <.NMDTP-.NMXLT>,<.NMDTP==.NMLFT>;; Left half, zero fill
      IFE <.NMDTP-.NMXRT>,<.NMDTP==.NMRIT> >>>;; Right half, zero fill

IFE <.NMTYP-.NMSPC>,<			;; Special
  IFB <$NOT>,<.NMNOT==.NMPIC>		;; Picture (default)
  IFIDNX <$NOT><ALPHA>,<.NMNOT==.NMALP>	;; Alpha
  IFIDNX <$NOT><ENGLISH>,<.NMNOT==.NMENG>;; English
  IFIDNX <$NOT><PICTURE>,<.NMNOT==.NMPIC>;; Picture
  IFIDNX <$NOT><ROMAN>,<.NMNOT==.NMROM>>;; Roman

IFNDEF .NMNOT,<$PRINT F,AUN,$NUMBER - An undefined notation ($NOT)>

;;		** Verify the integer width or case convertion code **

IFE <.NMTYP-.NMFLT>,<			;; FLOAT
  IFB <$EX1>,<.NMWID==^D0>
  IFIDNX <$EX1><FREE>,<			;; Free format
    .NMWID==^D127>
  IFNDEF .NMWID,<
    IFGE <$EX1>,<
      IFLE <<$EX1>-^D125>,<.NMWID==<$EX1>> >>
  IFNDEF .NMWID,<$PRINT F,AUW,$NUMBER - An undefined width ($EX1)> >

IFE <.NMTYP-.NMINT>,<			;; INTEGER
  IFB <$EX1>,<.NMWID==^D0>		;; 0 (Default)
  IFNB <$EX1>,<
    IFGE <$EX1>,<
      IFLE <<$EX1>-^D125>,<.NMWID==<$EX1>> >>
  IFNDEF .NMWID,<$PRINT F,AUW,$NUMBER - An undefined width ($EX1)> >

IFE <.NMTYP-.NMSPC>,<			;; Special
  IFN <.NMNOT-.NMPIC>,<			;; Alpha/English/Roman
    IFB <$EX1>,<$NUMB1 (%NMLOW)>	;; Lower (default)
    IFIDNX <$EX1><LOWER>,<$NUMB1 (%NMLOW)>;; Lower
    IFIDNX <$EX1><UPPER>,<$NUMB2 (%NMLOW)>;; Upper
    IFE <%NMAUX&%NMLOW>,<$PRINT F,AUC,$NUMBER - An undefined case ($EX1)> >
  IFE <.NMNOT-.NMPIC>,<			;; Picture
    IFB <$EX1>,<$PRINT F,NPG,$NUMBER - No picture given ($EX1)> >>

;;		** Verify the digits, radix or number code **

IFE <.NMTYP-.NMFLT>,<			;; Float
  IFB <$EX2>,<.NMFRC==^D5>
  IFIDNX <$EX2><FREE>,<			;; Free format
    .NMFRC==^D127
    $NUMB1 (%NMNDP) >
  IFIDNX <$EX2><INTEGER>,<		;; Integer only
    .NMFRC==^D0
    $NUMB1 (%NMNDP) >
  IFNDEF .NMFRC,<
    IFGE <$EX2>,<
      IFLE <<$EX2>-^D56>,<.NMFRC==<$EX2>> >>
  IFNDEF .NMFRC,<$PRINT F,AUF,$NUMBER - An undefined fraction ($EX2)> >

IFE <.NMTYP-.NMINT>,<			;; Integer
  IFB <$EX2>,<.NMRDX==^D8>		;; Octal (default)
  IFIDNX <$EX2><DEC>,<.NMRDX==^D10>	;; Decimal
  IFIDNX <$EX2><HEX>,<.NMRDX==^D16>	;; Hexadecimal
  IFIDNX <$EX2><OCT>,<.NMRDX==^D8>	;; Octal
  IFNDEF .NMRDX,<
    IFGE <<$EX2>-^D2>,<
      IFLE <<$EX2>-^D36>,<.NMRDX==<$EX2>> >>
   IFNDEF .NMRDX,<$PRINT F,AUR,$NUMBER - An undefined radix ($EX2)> >

IFE <.NMTYP-.NMSPC>,<			;; Special
  IFE <<.NMNOT-.NMENG>*<.NMNOT-.NMROM>>,<;;English/Roman
    IFB <$EX2>,<$NUMB1 (%NMCRD)>	;; Cardinal (default)
    IFIDNX <$EX2><CARDINAL>,<$NUMB1 (%NMCRD)>;; Cardinal
    IFIDNX <$EX2><ORDINAL>,<$NUMB2 (%NMCRD)>;; Ordinal
    IFE <%NMAUX&%NMCRD>,<$PRINT F,AUN,$NUMBER - An undefined number type ($EX2) >>
  IFE <.NMNOT-.NMPIC>,<			;; Picture
    IFB <$EX2>,<$NUMB1 (%NMLIT)>	;; Literal (default)
      IFIDNX <$EX2><LITERAL>,<$NUMB1 (%NMLIT)>;; Literal
      IFIDNX <$EX2><POINTER>,<$NUMB2 (%NMLIT)>;; Pointer
      IFE <%NMAUX&%NMLIT>,<$PRINT F,AUP,$NUMBER - An undefined pointer ($EX2)> >>

;;		** Verify the fill or save code **

IFE <<.NMTYP-.NMFLT>*<.NMTYP-.NMINT>>,<	;; Float/integer
  IFE <.NMTYP-.NMFLT>,<			;; Float
    IFB <$EX3>,<.NMFIL==" ">		;; Blank (default)
    IFIDNX <$EX3><ZERO>,<.NMFIL=="0">	;; Zero
    IFIDNX <$EX3><BLANK>,<.NMFIL==" ">	;; Blank
    IFIDNX <$EX3><DOLLAR>,<		;; Dollar
      .NMFIL==" "
      $NUMB1 (%NMDLR) >
    IFNDEF .NMFIL,<
      IFE <<"$EX3">&<^-<^O177>>>,<
        .NMFIL=="$EX3" >>>

  IFE <.NMTYP-.NMINT>,<			;; Integer
    IFB <$EX3>,<
      IFE <.NMNOT-.NMSIN>,<.NMFIL==" ">	;; Blank (default - signed)
      IFE <.NMNOT-.NMUNS>,<.NMFIL=="0"> >;; Blank (default - unsigned)
    IFIDNX <$EX3><ZERO>,<.NMFIL=="0">	;; Zero
    IFIDNX <$EX3><BLANK>,<.NMFIL==" ">	;; Blank
    IFNDEF .NMFIL,<
      IFE <<"$EX3">&<^-<^O177>>>,<
        .NMFIL=="$EX3" >>>
  IFNDEF .NMFIL,<$PRINT F,AUF,$NUMBER - An undefined fill ($EX3)> >

IFE <.NMTYP-.NMSPC>,<			;; Special
  IFE <.NMNOT-.NMPIC>,<			;; Picture
    IFB <$EX3>,<
      IFE <%NMAUX&%NMLIT>,<$NUMB2 (%NMSAV)>;; Nosave (default - pointer)
      IFN <%NMAUX&%NMLIT>,<$NUMB1 (%NMSAV)> >;; Save (default - literal)
    IFIDNX <$EX3><NOSAVE>,<$NUMB2 (%NMSAV)>;; Nosave
    IFIDNX <$EX3><SAVE>,<$NUMB1 (%NMSAV)>;; Save
    IFE <%NMAUX&%NMSAV>,<$PRINT F,AUS,$NUMBER - An undefined save ($EX3)> >>

;;		** Generate the code **

IFE <.NMTYP-.NMFLT>,<
  IFNDEF .TFLOT,<
    EXTERN .TFLOT >
	<.NMTYP_NM$TYP>!<.NMDTP_NM$DTP>!<.NMDPT_NM$DPT>!<.NMNOT_NM$NOT>!%NMFLG!<.NMFIL_NM$FIL>!<.NMWID_NM$WID>!<.NMFRC_NM$FRC> >
IFE <.NMTYP-.NMINT>,<
  IFNDEF .TINTG,<
    EXTERN .TINTG >
	<.NMTYP_NM$TYP>!<.NMDTP_NM$DTP>!<.NMDPT_NM$DPT>!<.NMNOT_NM$NOT>!<.NMFIL_NM$FIL>!<.NMWID_NM$WID>!<.NMRDX_NM$RDX> >
IFE <.NMTYP-.NMSPC>,<
  IFE <.NMNOT-.NMENG>,<
    $NUMB1 (%NMFST)
    IFNDEF .TENGL,<
      EXTERN .TENGL >>
  IFE <.NMNOT-.NMPIC>,<
    IFNDEF .TPICT,<
      EXTERN .TPICT >
    IFNDEF .TYPIC,<
      EXTERN .TYPIC >>
  IFE <.NMNOT-.NMROM>,<
    IFNDEF .TROMN,<
      EXTERN .TROMN >>
	<.NMTYP_NM$TYP>!<.NMDTP_NM$DTP>!<.NMDPT_NM$DPT>!<.NMNOT_NM$NOT>!%NMFLG >

%CNT==^O0
IRP $ADR,<
  %CNT==%CNT+^O1
	<$ADR> >
IFE <.NMDTP-.NMDBL>,<
  IFE <.NMDPT-.NMIMD>,<
    IFN <%CNT-^O2>,<$PRINT F,IND,$NUMBER - Incorrect number of data words ($ADR)> >
  IFN <.NMDPT-.NMIMD>,<
    IFN <%CNT-^O1>,<$PRINT F,IND,$NUMBER - Incorrect number of data words ($ADR)> >>
IFN <.NMDTP-.NMDBL>,<
  IFN <%CNT-^O1>,<$PRINT F,IND,$NUMBER - Incorrect number of data words ($ADR)> >

IFE <.NMTYP-.NMSPC>,<			;; Special
  IFE <.NMNOT-.NMPIC>,<			;; Picture
    IFN <%NMFLG&%NMLIT>,<
	POINT 7,[ASCIZ ~$EX1~] >
    IFE <%NMFLG&%NMLIT>,<
	<$EX1> >>>

>					; End of 'DEFINE $NUMBER'


DEFINE	$NUMB1 [SALL] ($FLG),<

	%NMFLG==%NMFLG!<$FLG>
	%NMAUX==%NMAUX!<$FLG>

>					; End of 'DEFINE $NUMB1'


DEFINE	$NUMB2 [SALL] ($FLG),<

	%NMAUX==%NMAUX!<$FLG>

>					; End of 'DEFINE $NUMB2'
	$TOC	TYPER Macros -- $TYPE Macro


DEFINE	$TYPE [SALL] ($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG),<

;		** Verify the parameters sent **

$TYPE1 ($HDR,$SFX,$SUB,<$TXT>,$TRL,<$RET>,<$BAS>,<$LST>,<$MSG>,$TYPE)

;		** Generate the TYPER call **

IFE <.TRSFX-.TRXCT>,<
	PUSHJ	P,@$$$'$SFX >
IFN <.TRSFX-.TRXCT>,<
  IFN <.TRSFX-.TRNON>,<
    $$$'$SFX:! >
	PUSHJ	P,@[$TYPE2 (<$TXT>)] >

>					; End of 'DEFINE $TYPE'
	$TOC	TYPER Macros -- $TYPEB Macro


DEFINE	$TYPEB [SALL] ($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG),<

;;		** Verify the parameters sent **

$TYPE1 ($HDR,$SFX,$SUB,<$TXT>,$TRL,<$RET>,<$BAS>,<$LST>,<$MSG>,$TYPEB)

;;		** Generate the TYPER block **

IFE <.TRSFX-.TRXCT>,<
	@$$$'$SFX >
IFN <.TRSFX-.TRXCT>,<
	$TYPE2 (<$TXT>) >

>					; End of 'DEFINE $TYPEB'
	$TOC	TYPER Macros -- $TYPE1 Macro


DEFINE	$TYPE1 [SALL] ($HDR,$SFX,$SUB,$TXT,$TRL,$RET,$BAS,$LST,$MSG,$ERR),<

PURGE	.TRHDR,.TRSFX,.TRTRL,.TRSUB,.TRXTR,.TRBAS,.TRRET,.TRBSA,.TRLOC,.TRLST,.TRBLK,.TRMSG,.TRERR

.TRCHR==.TRNON				;; Nothing

;;		** Show the version number **

	TYP.VN==:TYP.VN			;; Inform the world

;;		** Verify the header code **

IFB <$HDR>,<.TRHDR==.TRNON>		;; Nothing (default)
IFIDNX <$HDR><B>,<			;; Blank
   .TRHDR==.TRSPC
   .TRCHR==.TRBNK >
IFIDNX <$HDR><C>,<.TRHDR==.TRCNT>	;; Continuation
IFIDNX <$HDR><F>,<.TRHDR==.TRFAT>	;; Fatal
IFIDNX <$HDR><I>,<.TRHDR==.TRINF>	;; Information
IFIDNX <$HDR><M>,<.TRHDR==.TRMES>	;; Message
IFIDNX <$HDR><N>,<.TRHDR==.TRNON>	;; Nothing
IFIDNX <$HDR><O>,<.TRHDR==.TROPR>	;; Operator
IFIDNX <$HDR><T>,<			;; Tab
   .TRHDR==.TRSPC
   .TRCHR==.TRTAB >
IFIDNX <$HDR><W>,<.TRHDR==.TRWRN>	;; Warning

IFNDEF .TRHDR,<$PRINT F,AUH,$ERR - An undefined header ($HDR)>

;;		** Verify the suffix code **

IFB <$SFX>,<
  IFN <<.TRHDR-.TRNON>*<.TRHDR-.TRSPC>*<.TRHDR-.TRCNT>>,<
    $PRINT F,IUA,$ERR - Illegal use of the arguments >
  .TRSFX==.TRNON >
IFNB <$SFX>,<
  IFB <$TXT>,<
    IFB <$SUB>,<
      IFN <.TRHDR-.TRNON>,<
        $PRINT F,IUA,$ERR - Illegal use of the arguments >
      IF2,<
        IFNDEF $$$'$SFX,<
          $PRINT F,USS,$ERR - Undefined suffix specified ($SFX) >>
      .TRSFX==.TRXCT >
    IFNB <$SUB>,<
      IF1,<
        IFDEF $$$'$SFX,<
          IFN <$$$'$SFX-.>,<
            $PRINT F,MDS,$ERR - Multiply defined suffix ($SFX) >>>
      .TRSFX==''$SFX'' >>
  IFNB <$TXT>,<
    IF1,<
      IFDEF $$$'$SFX,<
        IFN <$$$'$SFX-.>,<
          $PRINT F,MDS,$ERR - Multiply defined suffix ($SFX) >>>
    .TRSFX==''$SFX'' >>

;;		** Verify the substitution code **

IFB <$SUB>,<
  .TRSUB==$NON >			;; None (default)
IFNB <$SUB>,<
  .IFN $SUB,OPDEF,<
     $PRINT F,AUS,$ERR - An undefined substitution ($SUB) >
  .TRSUB==$SUB >			;; Substitution

;;		** Verify the trailer code **

IFB <$TRL>,<.TRTRL==.TRYES>		;; CR-LF (default)
IFIDNX <$TRL><C>,<.TRTRL==.TRYES>	;; CR-LF
IFIDNX <$TRL><N>,<.TRTRL==.TRNON>	;; None

IFNDEF .TRTRL,<$PRINT F,AUT,$ERR - An undefined trailer ($TRL)>

;;		** Verify the return code **

.TRRET==.TRJMP				;; Jump
IFB <$RET>,<.TRRET==.TRNRM>		;; Normal (default)
IFIDNX <$RET><A>,<.TRRET==.TRABT>	;; Abort
IFIDNX <$RET><C>,<.TRRET==.TRCON>	;; Continue
IFIDNX <$RET><D>,<.TRRET==.TRDDT>	;; DDT
IFIDNX <$RET><E>,<.TRRET==.TRXIT>	;; Exit
IFIDNX <$RET><I>,<.TRRET==.TRINT>	;; Interrupt
IFIDNX <$RET><M>,<.TRRET==.TRMON>	;; Monitor
IFIDNX <$RET><N>,<.TRRET==.TRNRM>	;; Normal
IFIDNX <$RET><N1>,<.TRRET==.TRNR1>	;; Normal plus 1
IFIDNX <$RET><P>,<.TRRET==.TRPJ0>	;; .POPJ
IFIDNX <$RET><P1>,<.TRRET==.TRPJ1>	;; .POPJ1
IFIDNX <$RET><S>,<.TRRET==.TRSCN>	;; SCAN

IFE <.TRRET-.TRJMP>,<
  IF2,<
    IFNDEF $RET,<
      $PRINT F,AUR,$ERR - An undefined return ($RET)>>
  .TRLOC==<$RET> >

;;		** Verify the database address **

.TRBAS==.TRYES
IFB <$BAS>,<.TRBAS==.TRNON>		;; Current (default)
IFIDNX <$BAS><C>,<.TRBAS==.TRNON>	;; Current
IFIDNX <$BAS><D>,<.TRBSA==.TRDDB>	;; Default
IFIDNX <$BAS><E>,<.TRBSA==.TREDB>	;; Error
IFIDNX <$BAS><T>,<.TRBSA==.TRTDB>	;; TYPER

IFE <.TRBAS-.TRYES>,<
  IFNDEF .TRBSA,<			;; Database
    IF2,<
      IFNDEF $BAS,<$PRINT F,AUD,$ERR - An undefined database ($BAS)>>
    .TRBSA==<$BAS> >>

;;		** See if the extra word is needed **

.TRXTR==.TRNON				;; None (default)
IFE <<.TRRET-.TRJMP>*<.TRBAS-.TRYES>>,<
  .TRXTR==.TRYES			;; Jump return or database address
  IFNDEF .TRBSA,<
    .TRBSA==0 >
  IFNDEF .TRLOC,<
    .TRLOC==0 >>

;;		** Verify the parameter list **

IFB <$LST>,<.TRLST==.TRNON>		;; None (default)
IFNB <$LST>,<				;; Substitution block
  IFDIFX <$SUB><$IND>,<			;; Direct substition block
    .TRBLK==<$LST> >
  IFIDNX <$SUB><$IND>,<			;; Indirect substitution block
    .TRLST==0
    IRP $LST,<.TRLST==.TRLST+1>
    IFE <.TRLST-1>,<
      .TRBLK==<$LST> >
    IFN <.TRLST-1>,<
      .TRBLK==<-.TRLST,,[
        IRP $LST,<
          <$LST>>] >>>
  .TRLST==.TRYES >

IFNDEF .TRLST,<$PRINT F,AUL,$ERR - An undefined list ($LST)>

;;		** Verify the message level code **

IFB <$MSG>,<.TRMSG==.TRDEF>		;; Default
IFNB <$MSG>,<
  IFIDNX <$MSG><D>,<.TRMSG==.TRDEF>	;; Default
  IFNDEF .TRMSG,<
    IFGE <$MSG>,<
      IFLE <<$MSG>-.TRMAX>,<.TRMSG==<$MSG>> >>>

IFNDEF .TRMSG,<$PRINT F,AUM,$ERR - An undefined message level ($MSG)>

;;		** Verify that everything is kool **

IFNDEF P,<$PRINT F,AND,$ERR - The ACs are not defined correctly>
IFN <P-^O17>,<$PRINT F,AND,$ERR - The ACs are not defined correctly>

>					; End of 'DEFINE $TYPE1'
	$TOC	TYPER Macros -- $TYPE2 Macro


DEFINE	$TYPE2 [SALL] ($TXT),<

IFNDEF .TYPER,<
  EXTERN .TYPER >

	<.TRHDR_TR$HDR>!<.TRMSG_TR$MSG>+.TYPER
	.TRSUB!<.TRXTR_TR$XTR>!<.TRBAS_TR$BAS>!<.TRLST_TR$LST>!<.TRTRL_TR$TRL>!<.TRRET_TR$RET>!<.TRSFX_TR$SFX>
IFE <.TRXTR-.TRYES>,<
	.TRBSA,,.TRLOC >		;; Database/Location
IFE <.TRLST-.TRYES>,<
	.TRBLK >			;; Substitution
IFE <.TRCHR-.TRNON>,<
	ASCIZ ~$TXT~ >			;; Text (nothing)
IFE <.TRCHR-.TRBNK>,<
	ASCIZ ~ $TXT~ >			;; Text (blank)
IFE <.TRCHR-.TRTAB>,<
	ASCIZ ~	$TXT~ >			;; Text (tab)

>					; End of 'DEFINE $TYPE2'
	$TOC	TYPER Macros -- $TYPED Macro


DEFINE	$TYPED [SALL] ($LST),<

	$LSTOF				;; Suppress the listing

;;		** Reset the world **

	$TBFLG==<$TBCHR==<$TBEMP==<$TBJST==<$TBMSG==<$TBSYS==<$TBTIM==<$TBVER==<$TBVRB==^O0>>>>>>>>

;;		** Process the argument list **

IRP $LST,<
  $TYPD1 ($LST) >

;;		** Dump the database **

	$TBFLG				;; The flags
	$TBCHR				;; The output character routine
	^O0				;; The space compression counter
	$TBEMP				;; The buffer dumping routine
	$TBJST				;; The justification pointer
	^O0				;; The default message level
	^O0				;; The minimum message level
	$TBMSG				;; The output message level
	$TBSYS				;; The system prefix
	$TBTIM				;; The time stamp setting
	$TBVRB				;; The verbosity level
	$TBVER				;; The vertical justification
	^O0				;; The vertical header routine
	^O0				;; The vertical trailer routine
	^O0				;; The vertical end of header
	^O0				;; The vertical start of trailer
	^O0				;; The vertical page length
	^O0				;; The vertical current line number
	^O0				;; The display database pointer

	$LSTON				;; Restore the listing

>					; End of 'DEFINE $TYPED'


DEFINE	$TYPD1 [SALL] ($LST),<

	$TYPD2 ($LST)

>	;End of 'DEFINE $TYPD1'


DEFINE	$TYPD2 [SALL] ($FNC,$VAL<^O0>),<

;;		** Test the function **

IFIDNX <$FNC><CMP>,<$TBFLG==$TBFLG!%TBCMP>;; Compress
IFIDNX <$FNC><EMP>,<$TBEMP==<$VAL>>	;; Empty
IFIDNX <$FNC><ERR>,<$TBFLG==$TBFLG!%TBERR>;; Error
IFIDNX <$FNC><JST>,<$TBJST==<$VAL>>	;; Justification
IFIDNX <$FNC><MSG>,<$TBMSG==<$VAL>>	;; Message
IFIDNX <$FNC><OUT>,<$TBCHR==<$VAL>>	;; Output
IFIDNX <$FNC><SYS>,<			;; System
  IFE <$VAL>,<$TBSYS==<TP.PFX,,0>>
  IFN <$VAL>,<$TBSYS==<$VAL>> >
IFIDNX <$FNC><TIM>,<$TBTIM==<$VAL>>	;; Time stamps
IFIDNX <$FNC><VER>,<$TBVER==<$VAL>>	;; Vertical
IFIDNX <$FNC><VRB>,<$TBVRB==<$VAL>>	;; Verbosity

>					; End of 'DEFINE $TYPD2'
	$TOC	TYPER Macros -- $TYPES Macro


DEFINE	$TYPES [SALL] ($FNC,$RET,$BAS,$ADR),<

PURGE	.TSFNC,.TSRET,.TSARG,.TSBSA,.TSLOC

;;		** Show the version number **

	TYP.VN==:TYP.VN			;; Inform the world

;;		** Verify the function code **

IFIDNX <$FNC><BAS>,<.TSFNC==.TSBAS>	;; Database
IFIDNX <$FNC><BUG>,<.TSFNC==.TSBUG>	;; Bug
IFIDNX <$FNC><CMP>,<.TSFNC==.TSCMP>	;; Compress
IFIDNX <$FNC><COL>,<.TSFNC==.TSCOL>	;; Column
IFIDNX <$FNC><DMP>,<.TSFNC==.TSDMP>	;; Dump
IFIDNX <$FNC><EMP>,<.TSFNC==.TSEMP>	;; Empty
IFIDNX <$FNC><ERR>,<.TSFNC==.TSERR>	;; Error
IFIDNX <$FNC><ESN>,<.TSFNC==.TSESN>	;; Error string number
IFIDNX <$FNC><EXT>,<.TSFNC==.TSEXT>	;; External
IFIDNX <$FNC><INI>,<.TSFNC==.TSINI>	;; Initialization
IFIDNX <$FNC><JST>,<.TSFNC==.TSJST>	;; Justification
IFIDNX <$FNC><LOC>,<.TSFNC==.TSLOC>	;; Location
IFIDNX <$FNC><MSG>,<.TSFNC==.TSMSG>	;; Message
IFIDNX <$FNC><OUT>,<.TSFNC==.TSOUT>	;; Output
IFIDNX <$FNC><PIC>,<.TSFNC==.TSPIC>	;; Picture
IFIDNX <$FNC><PRM>,<.TSFNC==.TSPRM>	;; Prompt
IFIDNX <$FNC><RTN>,<.TSFNC==.TSRTN>	;; Routine
IFIDNX <$FNC><SYS>,<.TSFNC==.TSSYS>	;; System
IFIDNX <$FNC><TIM>,<.TSFNC==.TSTIM>	;; Time stamp
IFIDNX <$FNC><VER>,<.TSFNC==.TSVER>	;; Vertical
IFIDNX <$FNC><VRB>,<.TSFNC==.TSVRB>	;; Verbosity
IFIDNX <$FNC><ZON>,<.TSFNC==.TSZON>	;; Time zone

IFNDEF .TSFNC,<$PRINT F,AUF,$TYPES - An undefined function ($FNC)>

;;		** Verify the return code **

.TSRET==.TSJMP				;; Jump
IFB <$RET>,<
  IFE <.TSFNC-.TSBUG>,<.TSRET==.TSDDT>	;; DDT (default)
  IFN <.TSFNC-.TSBUG>,<.TSRET==.TSNRM> >;; Normal (default)
IFIDNX <$RET><A>,<.TSRET==.TSABT>	;; Abort
IFIDNX <$RET><C>,<.TSRET==.TSCON>	;; Continue
IFIDNX <$RET><D>,<.TSRET==.TSDDT>	;; DDT
IFIDNX <$RET><E>,<.TSRET==.TSXIT>	;; Exit
IFIDNX <$RET><I>,<.TSRET==.TSINT>	;; Interrupt
IFIDNX <$RET><M>,<.TSRET==.TSMON>	;; Monitor
IFIDNX <$RET><N>,<.TSRET==.TSNRM>	;; Normal
IFIDNX <$RET><N1>,<.TSRET==.TSNR1>	;; Normal plus 1
IFIDNX <$RET><P>,<.TSRET==.TSPJ0>	;; .POPJ
IFIDNX <$RET><P1>,<.TSRET==.TSPJ1>	;; .POPJ1
IFIDNX <$RET><S>,<.TSRET==.TSSCN>	;; SCAN

IFE <.TSRET-.TSJMP>,<
  IF2,<
    IFNDEF $RET,<
      $PRINT F,AUR,$TYPES - An undefined return ($RET) >>
  .TSLOC==<$RET> >

;;		** Verify the database address **

.TSBAS==.TSYES
IFB <$BAS>,<.TSBAS==.TSNON>		;; Current (default)
IFIDNX <$BAS><C>,<.TSBAS==.TSNON>	;; Current
IFIDNX <$BAS><D>,<.TSBSA==.TSDDB>	;; Default
IFIDNX <$BAS><E>,<.TSBSA==.TSEDB>	;; Error
IFIDNX <$BAS><T>,<.TSBSA==.TSTDB>	;; TYPER

IFE <.TSBAS-.TSYES>,<
  IFNDEF .TSBSA,<			;; Database
    IF2,<
      IFNDEF $BAS,<$PRINT F,AUD,$TYPES - An undefined database ($BAS)> >
    .TSBSA==<$BAS> >>

;;		** See if the extra word is needed **

.TSXTR==.TSNON				;; None (default)
IFE <<.TSRET-.TSJMP>*<.TSBAS-.TSYES>>,<
  .TSXTR==.TSYES			;; Database or jump return
  IFNDEF .TSBSA,<
    .TSBSA==^O0 >
  IFNDEF .TSLOC,<
    .TSLOC==^O0 >>

;;		** Verify the argument **

IFB <$ADR>,<.TSARG==.TSNON>		;; No argument (default)
IFNB <$ADR>,<.TSARG==.TSYES>		;; An argument

;;		** Verify that everything is kool **

IFNDEF P,<$PRINT F,AND,$TYPES - The ACs are not defined correctly>
IFN <P-^O17>,<$PRINT F,AND,$TYPES - The ACs are not defined correctly>

;;		** Generate the .TYPES call **

IFNDEF .TYPES,<
  EXTERN .TYPES >

IFE <.TSFNC-.TSPIC>,<
  IFNDEF .TYPIC,<
    EXTERN .TYPIC >>

	PUSHJ	P,@[<.TSFNC_TS$FNC>!<.TSRET_TS$RET>!<.TSARG_TS$ARG>!<.TSBAS_TS$BAS>!<.TSXTR_TS$XTR>+.TYPES
IFE <.TSXTR-.TSYES>,<
		    .TSBSA,,.TSLOC >	;; Database/location
IFE <.TSARG-.TSYES>,<
		    <$ADR> >		;; Argument address
IFE <.TSFNC-.TSBUG>,<
   IFE <RL%ADR-RL%ABS>,<		;; Absolute segment
		    TP.PFX,,RL%ABL >
   IFE <RL%ADR-RL%LOW>,<		;; Low segment
		    TP.PFX,,RL%LOL+.-RL%LOR >
   IFE <RL%ADR-RL%HGH>,<		;; High segment
		    TP.PFX,,RL%HIL+.-RL%HIR >
   IFE <RL%ADR-RL%SEC>,<		;; Section segment
		    TP.PFX,,RL%SCL >> ]

>					; End of 'DEFINE $TYPES'
	$TOC	External String Macros -- Definitions


; The  external  strings  are  used  with  TYPER, see $ERS substitution,
; $TYPES ESN, and $TYPES EXT.  These macro are  used  with  the  STRINGS
; flag  to  the  $BEGIN  macro.  Here  is  a description of the External
; String macros:
;
; The $ESBEG Macro:
;
;   The $ESBEG macro is something like  the  $DSBEG  macro  in  that  it
;   defines the beginning of a set of external strings.  The format of a
;   call to $ESBEG is:
;
; Call:
;
;	$ESBEG $PFX,$BEG,$MAX
;
; Where:
;
;	$PFX - The  two  character  prefix  for  all  external   strings
;	       generated.  The symbols generated are of the form .xxyyy,
;	       where  "xx"  is  $PFX  and  "yyy"  is the external string
;	       suffix ($SFX).
;
;	$BEG - The  beginning  value  to be used by $ESDEF when defining
;	       the external string offset.
;
;	$MAX - The  maximum  number of external strings to be allocated.
;	       If specified this value will be placed in the preamble to
;	       the  external  string  file,  else  the  maximum  defined
;	       external string number will be used.
;
; The $ESDEF Macro:
;
;   The $ESDEF macro is used to define an external  string.  The  format
;   of a call to $DSDEF is:
;
; Call:
;
;	$ESDEF  $SFX,$TXT,$ARG,$TST
;
; Where:
;
;	$SFX - The  symbol  suffix.  The symbol defined is .xxyyy, where
;	       "yyy" is $SFX.
;
;	$TXT - The  text  to be associated with the symbol.  The text at
;	       the current moment has a maximum of 494 characters.
;
;	$ARG - The list of external arguments, which are NOT used by the
;	       TYPER system.  This data is placed in the external string
;	       file for the user convenience.
;
;	$TST - The feature test value, if the value is zero the external
;	       string is not generated.  The default value is -1.
;
;
; The $ESEND Macro:
;
;    $ESEND is the end of this external string  file.   It  is  used  to
;    terminate a $ESBEG.  The format of a call to $ESEND is:
;
; Call:
;
;	$ESEND  $SIZ,$TXT,$ARG
;
; Where:
;
;	$SIZ - The symbol suffix for the number of symbols defined.  The
;	       value is required when opening an external string file.
;
;        $TXT - The default text string to be used if a external  string
;	        is  to  be  output,  but can't be found in the file.  If
;	        left blank the TYPER default will be used.
;
;        $ARG - The list of external arguments, which are  NOT  used  by
;	        the  TYPER  system.  This data is placed in the external
;	        string file for the user convenience.
	$TOC	External String Macros -- The Macros


	DEFINE	$ESBEG [SALL] ($PFX,$BEG,$MAX,%ARG,%CHR,%MAX,%SFX),<

IFL <$BEG>,<$PRINT F,IBV,$ESBEG - Illegal beginning value specified ($PFX, $BEG)>
IFGE <<$BEG>-WD%RIT>,<$PRINT F,IBV,$ESBEG - Illegal beginning value specified ($PFX, $BEG)>

IFB <$MAX>,<
  %MAX==.WDINF >			;; Define the maximum value
IFNB <$MAX>,<
  IFL <$MAX>,<$PRINT F,IMV,$BEGIN - Illegal maximum value specified ($PFX, $MAX)>
  IFG <<$BEG>-<$MAX>>,<$PRINT F,IMV,$BEGIN - Illegal maximum value specified ($PFX, $MAX)>
  %MAX==<$MAX> >			;; Define the maximum value

%SFX==<$BEG>				;; Define the starting value


  DEFINE $ESBLD [SALL] ($TXT,$ARG),<

  IFB <$TXT>,<				;; No text input
    ^O0,,%SFX >

  IFNB <$TXT>,<				;; Some Text, count the characters
    %CHR==^D1
    IRPC $TXT,<%CHR==%CHR+^D1>

    IFB <$ARG>,<			;; No extra arguments supplied
      IFLE <%CHR-.TFMAX>,<
        [ASCIZ ~$TXT~],,%SFX >
      IFG <%CHR-.TFMAX>,<
        [BYTE (7).CHNUL (11)^O0 (18)%CHR
         ASCIZ ~$TXT~],,%SFX >>

    IFNB <$ARG>,<			;; Some extra arguments supplied
      %ARG==^O0
      IRP $ARG,<%ARG==%ARG+^O1>
      [BYTE (7).CHNUL (11)%ARG (18)%CHR
       IRP $ARG,<
          <$ARG> >
       ASCIZ ~$TXT~],,%SFX >>

  >					; End of 'DEFINE $ESBLD'


  DEFINE	$ESPRI [SALL] ($NUM),<

  IF1,<$PRINT I,SHG,$NUM symbols have been generated for $PFX>

  >					; End of 'DEFINE $ESPRI'


	DEFINE	$ESDEF [SALL] ($SFX,$TXT,$ARG,$TST<-^O1>),<

  IFN <$TST>,<
    IFG <%SFX-%MAX>,<$PRINT F,TMM,Too many messages defined ($PFX, $SFX, $TXT)>
    IFGE <%SFX-WD%RIT>,<$PRINT F,TMM,Too many messages defined ($PFX, $SFX, $TXT)>

    IFNB <$SFX>,<.'$PFX''$SFX==%SFX>

    $ESBLD (<$TXT>,<$ARG>)

    %SFX==%SFX+^O1 >

  >					; End of 'DEFINE $ESDEF'


	DEFINE	$ESEND [SALL] ($SIZ,$TXT,$ARG),<

  IFE <%SFX-<$BEG>>,<$PRINT W,NES,$ESEND - No external strings defined ($PFX) >

  IFNB <$SIZ>,<
    .'$PFX''$SIZ==<%SFX-<$BEG>-^O1> >	;; The number of external strings defined

  .ESBEG==<$BEG>			;; The beginning external string value
  IFB <$MAX>,<
    .ESEND==<%SFX-^O1> >		;; The ending external string value
  IFNB <$MAX>,<
    .ESEND==<%MAX> >			;; The ending external string value

  $ESPRI (\<%SFX-<$BEG>>)		;; Output the number external strings

  %SFX==.TFEND

  $ESBLD (<$TXT>,<$ARG>)

  PURGE $DSBEG,$DSBLD,$DSDEF,$DSEND,$DSPRI
  PURGE %ARG,%CHR,%SFX,%MAX

  >					; End of 'DEFINE $ESEND'

>					; End of 'DEFINE $ESBEG'
	$TOC	Hardware Bits -- CPU Type Values


; Define the CPU types:

	.CTPDP6==^O1			; PDP-6
	.CTKA10==^O2			; KA10
	.CTKI10==^O3			; KI10
	.CTKL10==^O4			; KL10
	.CTKL20==^O4			; KL20
	.CTKS10==^O5			; KS10
	.CTKS20==^O5			; KS20
	.CTKC10==^O6			; KC10
	.CTKC20==^O6			; KC20


; Define units of core allocation

	.SUAP6==^O2000			; PDP-6
	.SUAKA==^O2000			; KA10
	.SUAKI==^O1000			; KI10
	.SUAKL==^O1000			; KL10/KL20
	.SUAKS==^O1000			; KS10/KS20
	.SUAKC==^O1000			; KC10/KC20
	$TOC	Hardware Bits -- CPU Flags and Instruction Fields


; Define some PC flags

	PC%OVF==B0			; Overflow
	PC%CY0==B1			; Carry 0
	PC%CY1==B2			; Carry 1
	PC%FOV==B3			; Floating overflow
	PC%BIS==B4			; Byte increment suppression
	PC%USR==B5			; User mode
	PC%UIO==B6			; User IOT mode
	PC%LIP==B7			; Last instruction public
	PC%AFI==B8			; Address failure inhibit
	PC%ATN==^O3B10			; APR trap number
	PC%FUF==B11			; Floating underflow
	PC%NDV==B12			; No divide


; Define the instruction fields

	IC%OPC==^O777B8			; Operation code
	IC%ACF==^O17B12			; AC field
	IC%ADR==^O37777777B35		; The address field
	 %ICIND==^O1B13			 ; Indirect bit
	 %ICIDX==^O17B17		 ; Index field
	 %ICYHF==^O777777B35		 ; 'Y' half

	IC%IOP==^O70034B12		; I/O operation code
	IC%IDV==^O774B11		; I/O device channel


; Define the byte pointer fields

	BP%POS==^O77B5			; Position of byte
	BP%SIZ==^O77B11			; Size of the byte
	BP%EXT==^O1B12			; Use extended addressing
	BP%ADR==^O37777777B35		; The address field
	 %BPIND==^O1B13			 ; Indirect bit
	 %BPIDX==^O17B17		 ; Index field
	 %BPYHF==^O777777B35		 ; 'Y' half
	$TOC	Hardware Bits -- Number Fields


; Define the integer number fields

	IN%SGN==^O1B0			; The sign
	IN%NUM==^O377777777777B35	; The integer number


; Define the floating-point number fields

	FN%SGN==^O1B0			; The sign
	FN%EXP==^O377B8			; The exponent
	FN%MAN==^O777777777B35		; The mantissa


; Define some word related sysmbols

	$DSBEG    WD			; Define word related symbols
	 $DSFLG   WRD,WORD		 ; The hole word
	  $DSVAL  WRD,^D36		  ; The size in bits
	  $DSVAL  INF,^O377777777777	  ; Plus infinity
	  $DSVAL  MIN,^O400000000000	  ; Minus infinity
	 $DSFLG   LFT,LEFT,WRD		 ; The left half
	  $DSVAL  LFT,^D18		  ; The size
	  $DSVAL  HLF,^D18		  ;  in bits
	 $DSFLG   RIT,RIGHT,WRD		 ; The right half
	  $DSVAL  RIT,^D18		  ; The size
	  $DSVAL  HLF,^D18		  ;  in bits
	$DSEND    WD			; That's all folks
	$TOC	Hardware Bits -- EXTEND Instrucion Bits


; Define the translation flags (the translation instructions)

	TF%SIG==B0			; Significant
	TF%LEN==B0			; Length (CVTBDO and CVTBDT)
	TF%NON==B1			; Non-zero
	TF%MIN==B2			; Minus (negative)


; Define the translation op-code (MOVST)

	.MOISB==^O0			; If significant (S) is 1, take the
					;  substitute in place of the source
					;  byte.
	.MOTRM==^O1			; Terminate the translation.
	.MOICM==^O2			; Clear minus (M), and if significant
					;  (S) is 1, take the substitute in
					;  place of the source byte.
	.MOISM==^O3			; Set minus (M), and if significant
					;  (S) is 1, take the substitute in
					;  place of the source byte.
	.MOSSB==^O4			; Set significant (S) and non-zero (N),
					;  and take the subtitute in place of
					;  the source byte.
	.MOTMN==^O5			; Set non-zero (N) and terminate the
					;  translation.
	.MOSCM==^O6			; Set significant (S) and non-zero (N),
					;  clear minus (M), and take the
					;  subtitute in place of the source
					;  byte.
	.MOSSM==^O7			; Set significant (S), non-zero (N)
					;  minus (M), and take the subtitute
					;  in place of the source byte.
; Define the translation op-code (CVTDBT)

	.COISD==^O0			; If significant (S) is 1, substitute
					;  the table for the byte.  If signif-
					;  icant (S) is 0, ignore this byte and
					;  go to the next.
	.COTRM==^O1			; Terminate the translation.
	.COICM==^O2			; Clear minus (M), and if significant
					;  (S) is 1, substitute the table for
					; the byte.  If significant (S) is 0,
					; ignore this byte and go to the next.
	.COISM==^O3			; Set minus (M), and if significant (S)
					;  is 1, substitute the table for the
					;  byte.  If significant (S) is 0,
					;  ignore this byte and go to the next.
	.COSSD==^O4			; Set significant (S) and non-zero (N),
					;  and substitute the table digit for
					;  the byte.
	.COTMN==^O5			; Set non-zero (N) and terminate the
					;  translation.
	.COSCM==^O6			; Set significant (S) and non-zero (N),
					;  clear minus (M), and substitute the
					;  table digit for the byte.
	.COSSM==^O7			; Set significant (S), non-zero (N)
					;  and minus (M), and substitute the
					;  table digit for the byte.
; Define the translation op-code (EDIT)

	.EOISB==^O0			; If significant (S) is 1, place the
					;  substitute in the next position in
					;  the desination string space.  Other-
					;  wise if location E0+1 is non-zero,
					;  place the fill character from it in
					;  the next destination position.
	.EOTRM==^O1			; Increment the pattern pointer, and go
					;  on to the next instruction.
	.EOICM==^O2			; Clear minus (M) and then perform
					;  function .EOISB (0).
	.EOISM==^O3			; Set minus (M) and then perform func-
					;  tion .EOISB (0).
	.EOSSB==^O4			; Set non-zero (N).  If significant (S)
					;  is 1, place the substitute in the
					;  next position in the desination
					;  string space.  Otherwise do the
					;  following; set significant (S);
					;  put the current value of the
					;  destination byte pointer at the
					;  location specified by the mark
					;  address; if location E0+1 is non-
					;  zero, put the float character from
					;  it in the next destination position;
					;  then place the substitute in the
					;  next destination position after
					;  that.
	.EOTMN==^O5			; Set non-zero (N), increment the
					;  pattern pointer, and go on to the
					;  next instruction.
	.EOSCM==^O6			; Clear minus (M) and then perform
					;  function .EOSSB (4).
	.EOSSM==^O7			; Set minus (M) and then perform func-
					;  tion .EOSSB (4).


; Define the edit pattern commands

	.EPSTP==^O000			; Stop edit
	.EPSEL==^O001			; Select next source byte
	.EPSIG==^O002			; Start significance
	.EPSEP==^O003			; Separate field
	.EPEXM==^O004			; Exchange mark and desination pointers
	.EPNOP==^O005			; No-op
	.EPMES==^O100			; Insert message character
	.EPSKM==^O500			; Skip on M
	.EPSKN==^O600			; Skip on N
	.EPSKP==^O700			; Skip always
	$TOC	Software Bits -- TOPS-20 Only


; Define the available software interrupt channels (0-5 and 23-35)

	%ICAVA==<$FILIN(<B0!B5>)!$FILIN(<B23!B35>)>


; Define the entry vector offsets

	EV.STR==^O0			; The starting address
	EV.REE==^O1			; The reentry address
	EV.VER==^O2			; The version number
	$TOC	The End	


IF2,<
	IFDEF FT%BLD,<		;[CSM] If rebuilding from scratch
          IFG SYSEDT-FT%BLD,<	;[CSM] Warn if untested combination
	    PRINTX %SYSBLD needs to be have FT%BLD redefined>>
	PURGE	FT%BLD,TP.PFX		; Purge some symbols >


	$END				; End of 'SYSUNV'


Local modes:
TOC Indent Per Level:2
TOC Width:72
TOC Header:"
;		     	Table of Contents for ~Name~
;
;				  Section			    Page
;
"
TOC Separators:" -- "
TOC Use First Line:1
End:
      )3[D