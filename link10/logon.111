 	TITLE	LOGON	POST LOGIN INITIALIZATION PROGRAM
	SUBTTL	M. KOSTER/CAB/ECM/CAB/CAB

	SEARCH	ECM12,MACTEN,JOBDAT,UUOSYM,SCNMAC

	SALL

	VERSION	LON,2(111)

	.REQUEST SCAN
	.REQUEST SYS:HELPER

	.TWOSEG
	SUBTTL	Table of contents

;			Section					Page
;    1.	Title Page..............................................   1
;    2.	Table of Contents.......................................   2
;    3.	Revision History........................................   3
;    4.	Conditional Assembly Parameters.........................   4
;    5.	Definitions, Macros.....................................   5
;    6.	Main Program............................................   6
;    7.	Subroutines.............................................   9
;    8.	    Assign:Device:Logical...............................   9
;    9.	    GT40................................................  10
;   10.	    Hazel...............................................  11
;   11.	    Hp2621..............................................  12
;   12.	    Mount:Structure.....................................  13
;   13.	    Select:Condition:Option.............................  14
;   14.	    Set:Arg { Arg2 { Arg3 } }...........................  22
;   15.	    Info................................................  27
;   16.	    Tell................................................  29
;   17.	Error Messages..........................................  30
;   18.	Warning Messages........................................  31
;   19.	Info Messages...........................................  31
;   20.	Switches Macro..........................................  32
;   21.	OSCAN Data block........................................  33
;   22. Impure Data area........................................  34

	SUBTTL	Revision history

; %1(1) Feb 1975
;
;    2	Corrected to only /SET:TTY BLANKS
;    3	FIX UP THE GETLCH TTCALLS
;    4	ALLOW WILD CARD FOR /SELECT:PPNUSR AND OUTPUT TTY #
;    5	FIX UP TO USE ECM12 AND SCN7B FILES
;    6	DO NOT GIVE HELP BY DEFAULT
;    7	FIX AND ADD OTHER TRMOP. SETTINGS
;   10	REMOVE /NOTIFY:HELP PROCESSING
;   11	ALLOW ABBREVIATIONS FOR SELECT AND SET FUNCTIONS
;   12	ELEMINATE SOME EXTRA MONITOR CALLS
;   13	SPRUCE UP /SELECT PROCESSING
;   14	FIX UP RUN MESSAGE
;   15	ADD /SELECT:<NODE>_<CONDITION>:OPTION
;   16	Fix sense of TTY ALTMODE to be same as monitor command
;   17	Allow shorter names for some commands for small SWITCH.INI files
;   20	Enhance SET inform message and SET error message
;   21	Change messages to print <CrLf> at end of message, not beginning
;   22	Change TRMOP calls to work (conditionally) at tymshare
;   23	Partially implement Node:Line for Tymnet node,line.
;   24	Fixup /SELECT:PPN??? to look at .GTAUN at Tymshare, not GFD PPN.
;   25	Add /SELECT:(KI10,KL10,KS10,Foonly,F3) options.
;   26	Add /HP2621 switch to set tab-stops, & clear screen on Hp-2621's.
;   27	Add /Status switch to display [<config><Processor-type><#0 States>].
;   30	Add code for AUX-Circuit testing /Select:(Aux,NoAux):<option>.
;   31	Add /Select:System@<Sysname>:<option>.
;   32	Fix PPNUSR selection to check for /NOTIFY:USER before printing.
;   33	Add CPU Load!Average and Response!Time to /Status line.
;   34	Fix /PPNxxx:user-ppn to check for job logged in! .jbtsts bit 0.
;   35	Fix /Set:tty code in Chktty to forget lch wait for Aux Circuits.
;   36	Add /Set:tty RBSPACE for remote backspace echo <tymshare only>.
;   37	Fix PPNUSR message to pickup name correctly <if .gt. 10 ???>.
;   40	Fix PPNUSR msg to not print [0,0] ppns.
;   41	Add Job wait state to PPNUSR message.
;   42	** (obsolete - so removed by edit 64) **
;   43	Fix bad return from I$$USR code, move label to POP P,T1.
;   44	Add /Set:tty TYPE xxxxxx to set tty type, .Axttp/.Totrm calls.
;   45	Add /Set:tty DEFER to TOPS-10 code using the .TODEM trmop.
;   46	Add Current date-time to /Status switch.
;   47	Add TYMNET (Node-TTY) to PPNUSR message.
;   50	Modify PPNUSR message, remove PPN@Tymshare, add AUN(PPN).
;   51	Remove /Assign:dev:log at Tymshare, IFE TYMCOM,<...>.
;   52	Fix /SELECT code to accept [p,pn] if specified, vis #42.
;   53	Fix /STATUS code to timeout for lost yellow balls and type frame #.
;   54	Change F3 cputype check to use PUSH instead of AOBJN with Mu 327e.
;   55	Add /SET:[NO] ARG commands as separate from /SET:TTY [NO] ARG.
;   56	Allow : or <sp> so that /TTY:[NO] ARG works right.
;   57	Add /SET:x (Attach, DSTime, RCMode, Timezone, Mode, Disconn, Core).
;   60	Fix /TTY:CRLF to use correct value.  It was reversed.
;   61	Add /TTY:RTCOMP to TTY commands.
;   62	Add code to get UPTLOG when LDBLOG shows 0 for node & port.
;   63	Add /Select:Node:Option[node,node] under tymshare conditional.
;   64	Modify to use SLIGOS version of SCAN for usernames.
;   65	Re-arrange /Status printout and add status bits to /Notify.
;   66	Add memory size to /Status printout code (hardware)
;   67	Revamp 65 adding /INFO switch to define /Status output
;   70	Set absent default for /INFO by hand to INFMSK
;   71	Add /SET:SCMODE:(USER)FILE for /L14++ monitors.
;   72	Added :Uptime and more to /INFO.
;   73	Fixed /INFO:UPTIME to avoid integer overflow near 159 hours.
;   74	Remove /Status and print /INFO values at end if /NOTIFY:INFO set.
;   75	Allow Node number to be larger than 7777.  More later.
;   76	Change /INFO:MONITOR to :SYSTEM and add /INFO:MONID on 2nd line.
;   77	Fix /Select:Node:nnnn-ppp:option and /Select:Node:nnnn-all:option.


;  100	Revamp all /SELECT:option:<criteria> calls to be consistant!
;  101	Allow /Select:opt:NODE:nnn,nnn-ppp,nnn,nnn to work.
;  102	Allow /Set:tty <arg>,<arg> <arg> to work.
;  103	Add *Hack*  +10000 for nodes less than 2000.
;  104	/Select::Node:nnnn now uses port -1 instead of port 0.
;  105	Change to /Set:RCM filespec  (file), /Set:Priv [no] RCM  (bit).
;  106	Change bits on /USERS from FS.NFS to FS.VRQ to fix bug.
;  107	Fixup /SET:TTY error message to report proper SET functions.

; %2(107) Released 28-Mar-86 For TYMCOM-X systems /Carl

;  110	Fix LOGOUT on STOP definition, E$$ITS messages and add /PROGRAM
;  111	Fix * and [,*] and other wild things in /users and /program

	Subttl	Conditional assembly parameters

ifndef	Tymcom,<Tymcom==-1>	; Default to Tymcom-X monitor

	.GtRDI==136			;[110] Run directory (.gtFPN)
ifn Tymcom,<
	JP.LOS==1B0			;[110] Logout on Stop
	.Rbunm==27			;[50] UFD username (2 words)
	.Gtnm1==.Gtunm			; Fix DEC's def == Username part 1
	.Gtnm2==.Gtun1			; Fix DEC's def == Username part 2
	.CnSYS==33			;[76] System #, Not in UUOSYM?
	.CnMID==43			;[76] Software serial #, Not in UUOSYM
	%NSUPT==.Nsupt,,.Gtnsw		; Uptime,,Non-swapping table
	%NSHJB==.Nshjb,,.Gtnsw		; Highest job,,Non-swapping table
	%NSMMS==.Nsmms,,.Gtnsw		; Physical memory,,Non-swapping

	%CNFG0==.Cnfg0,,.Gtcnf		; System name,,Config table
	%CNFG1==.Cnfg0+1,,.Gtcnf	; System name,,Config table
	%CNFG2==.Cnfg0+2,,.Gtcnf	; System name,,Config table
	%CNFG3==.Cnfg0+3,,.Gtcnf	; System name,,Config table
	%CNFG4==.Cnfg0+4,,.Gtcnf	; System name,,Config table

	%CNNJB==.Cnnjb,,.Gtcnf		; Log Max,,Config table
	%CNSTS==.Cnsts,,.Gtcnf		; States-word,,Config table
	%CNSER==.Cnser,,.Gtcnf		; APR serial #,,Config table
	%CNPTS==.Cnpts,,.Gtcnf		; Ports,,Config table
	%CNSYS==.Cnsys,,.Gtcnf		; System number,,Config table
	%CNMID==.Cnmid,,.Gtcnf		; Software serial #,,Config table

	.Opdev==1		; Open block Device name
	.Toset==0		; Make this go away!

	.Axbsd==77		;[36] Backspace delete
	.Axttp==100		;[44] Terminal type
	.Axrtc==101		;[61] RT compatibility

	.foRFA==36		;[62] Read Frame Attribute
>
	SUBTTL	DEFINITIONS

	ND	PDLSIZ,^D100		;PDLSIZE
	ND	OPT.NO,^D10		;MAXIMUM LEVEL OF /SELECT NESTING

	N.DEV==N.ZER##			;RUN BLOCK DEVICE

DEFINE	MSG	(BITS),<	;;MACRO TO DECIDE IF A MESSAGE CAN BE TYPED
	SETCM	T1,NOTES	;;GET COMPLIMENTED NOTIFY BITS THE USER WANTS
	TRNE	T1,%'BITS	;;DOES HE WANT TO BE DISTURBED?
	RETURN			;NO--JUST RETURN
>

DEFINE	IFSTRG	(BITS,STRING)<		;;MACRO TO DECIDE IF A MESSAGE
	MOVEI	T1,[ASCIZ\ STRING\]	;;SHOULD BE PRINTED & TO PRINT
	TXNE	P1,BITS			;;IT IF SO, ELSE NO PRINTING IS
	XCALL	.TSTRG			;;DONE.
>
	SUBTTL	MAIN PROGRAM

LOGON::	.RESET				;[5]RESET THE WORLD
	SKPINL				;DEFEAT THE ^O
	  JFCL
	Setzm	INFOSW			;[74] /INFO default
	MOVEI	T1,1			;GET A 1
	MOVEM	T1,STRLTH		;PUT A 1 THERE
	SETO	T1,			;[12]SETUP AND
	GETLCH	T1			;[12]GET OUR LINE CHARACTERISTICS
	MOVEM	T1,LINCHR		;[12]SAVE THE LINE CHARACTERISTICS
	HRRZM	T1,TTYNO		;[12]AND SAVE THE TTY NUMBER
	GETLIN	T1,			;[12]GET THE TTY NAME
	MOVEM	T1,TTYNAM		;[12]AND SAVE IT
ife tymcom,<
	HRRZ	T1,TTYNO		;[15]GET TTY NUMBER AGAIN
	GTNTN.	T1,			;[15] TO RETURN NODE,,LINE
	  SETO	T1,			;[15]ASSUME -1,,-1 IF CANNOT GET IT
	HLREM	T1,TTYNOD		;[15]AND SAVE THE RESULTS
	HRREM	T1,TTYLIN		;[15]FOR THE SELECT INFO.
	MOVE	T3,TTYNOD		;[15] ...
	CALL	GETNOD			;[15]GET THE CURRENT NODE
	MOVEM	T1,NODNAM		;[15] AND STORE IT.
	> ; End ife tymcom
ifn tymcom,<
	hrroi	T1,.Gtlog		;[23] Get the Tymnet Node:line, etc.
	Gettab	T1,			;[23] ...
	  Setz	T1,			;[23] Shouldn't happen
	Setzm	TymLog			;[62] clear flag
	Tdne	T1,[77b19!77b27]	;[62] check for node 0
	  Jrst	LogGTL			;[62] no, we got a good one
	Setom	TymLog			;[62] set flag
	Hrloi	T1,.foRFA		;[62] Read frame attributes
	Move	T2,[1,,T1]		;[62] attribute #1,,result in T1
	Frmop	T1,T2			;[62] ...
	  Setz	T1,			;[62] Ignore error, make 0
LogGTL:	Move	T2,T1			;[23] Copy it
	Setom	Tymaux			;[30] Set Aux Circuit field (-1)
	Txne	T1,17b11		;[30] Skip if bits are off
	  Setzm	Tymaux			;[30] Clear Aux Circuit field (0)
	Andi	T2,177			;[23] Save Line number
	Movem	T2,TTYNOD		;[23] ...
;*;	Ldb	T1,[Point 16,T1,27]	;[NEW] Just load 16-bit field!
	Tlz	T1,777700		;[103] Throw away high bits
	Lshc	T1,-^d14		;[23] First set of 6-8 bits
	Lsh	T1,-2			;[23] Throw away garbage bits
	Lshc	T1,-^d30		;[23] Should now have the right ones
	Andi	T2,177777		;[75] Make it Octal Node #
	Caige	T2,2000			;[103] Old TYMNET-I range?
	  Addi	T2,10000		;[103] Hack till new code!
	Movem	T2,NODNAM		;[23] Store it
> ; End ifn tymcom

	SUBTTL	MORE MAIN PROGRAM.

	Store	T1,Cnfnam,Cnfend,0	;[27] Clear data area
	Movx	T1,%Cnfg0		;[27] Get the name of the system
	Gettab	T1,			;[27]     from the monitor
	  Setz	T1,			;[27]     tables.
	Movem	T1,Cnfnam		;[27] and store it away for
	Movx	T1,%Cnfg1		;[27] later printing.
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+1		;[27] ...
	Movx	T1,%Cnfg2		;[27] ...
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+2		;[27] ...
	Movx	T1,%Cnfg3		;[27] ...
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+3		;[27] ...
	Movx	T1,%Cnfg4		;[27] ...
	Gettab	T1,			;[27] ...
	  Setz	T1,			;[27] ...
	Movem	T1,Cnfnam+4		;[27] ... Done!
ifn tymcom,<	;; Depends upon name in form (Xnnnn-...), C930-P034/H.
	Move	T1,[Point 7,Cnfnam]	;[31] Pointer to name
	Move	T2,[Point 6,Chname]	;[31] Pointer for Char-name
	Move	T3,[Point 6,Syname]	;[31] Pointer to Number-name
	Ildb	T4,T1			;[31] Get first Char
	Movei	T4,' '-" "(T4)		;[31] Convert to Sixbit
	Idpb	T4,T2			;[31] Deposit it
Sysnlp:	Ildb	T4,T1			;[31] Get a Char
	Cain	T4,"-"			;[31] Read up to a dash (-)
	  Jrst	Sysndn			;[31] Then stop!
	Movei	T4,' '-" "(T4)		;[31] Convert to Sixbit
	Idpb	T4,T2			;[31] Deposit it Ch-name
	Idpb	T4,T3			;[31] Deposit it Nu-name
	Jrst	Sysnlp			;[31] Loop till find a dash
Sysndn:	Movx	T1,%CNSYS		;[76] Get system number
	Gettab	T1,			;[76]  from monitor tables
	  Setz	T1,			;[76] Hmmmm? Old monitor?
	Movem	T1,GTSYSN		;[76] Store it away
	Movx	T1,%CNMID		;[76] Get software serial #
	Gettab	T1,			;[76]  from monitor tables
	  Setz	T1,			;[76] Hmmmm? Pre /K monitor?
	Movem	T1,GTSIDN		;[76] Store it away
> ; End ifn tymcom
	Movx	T1,%CNSER		;[72] Get APR number from the
	Gettab	T1,			;[72] monitor table
	  Setz	T1,			;[72] Not available, skip it
	Movem	T1,GTAPRN		;[76] Store it for later
	PJOB	T1,			;[12]GET OUR JOB NUMBER
	MOVEM	T1,MYJOB		;[12]AND SAVE IT

	SUBTTL	MORE MAIN PROGRAM.

	SETZ	T1,			;NULL .ISCAN CALL
	XCALL	.ISCAN			;INIT SCAN
	MOVE	T1,OBLK			;MOVE BLK HEADER FOR OSCAN
	XCALL	.OSCAN	
	MOVEI	T1,OPT.NO		;GET  NESTING MAX FOR /SELECT
	MOVEM	T1,OPTCNT		;AND STORE IT AWAY
LOGON0:	SKIPN	T1,SELOPT		;/SELECT:OPTION SPECIFIED?
	  JRST	LOGON1			;No--NO MORE .OSCAN CALLS
	MOVEM	T1,.OPTN##		;Yes--STORE IN SCAN (OPTION)
	SETZM	SELOPT			;AND CLEAR THE FLAG
	MOVE	T1,OBLK			;MOVE BLK HEADER FOR OSCAN
	CALL	.OSCAN			;YES--DO ANOTHER .OSCAN
	SOSLE	OPTCNT			;IS THIS SELECT NESTED TOO DEEP?
	  JRST	LOGON0			;NO--GO PROCESS IT
	CALL	E$$SNE			;YES--TYPE ERROR
	EXIT				;AND QUIT

LOGON1:	MOVS	T1,STRLTH		;NO--GET THE LENGTH OF THE LIST
	HRRI	T1,STRLST		;GET THE ADDRESS
	SOSG	STRLTH			;SKIP IF ANY /MOUNT'S DONE
	  JRST	LOGON2			;SKIP TO MISS SEARCHLIST ERRORS
	STRUUO	T1,			;PUT UP THE LIST
	  CALL	E$$CSS			;NO--CAN'T SET SEARCH-LIST
LOGON2:	CALL	T.INFO			;Print any INFO messages
	SKIPE	N.DEV			;IS THERE A PROGRAM TO RUN?
	CALL	I$$RUN			;YES--GO TELL USER
	XCALL	.RUNCM			;RUN ANOTHER PROGRAM
	XCALL	.TCRLF			;ADD A FREE CR-LF
	EXIT				;   THEN PERMANENTLY EXIT
	SUBTTL	SUBROUTINES

Ife Tymcom,<	;[51] Remove Assign code until we find how to do it here!
;ASSIGN -- ASSIGN A DEVICE AND GIVE IT A LOGICAL NAME
;CALL:	PUSHJ	P,ASSIGN	OR (CALL ASSIGN) /ASSIGN: PROCESSOR
;	RETURN

ASSIGN:	XCALL	.FILIN			;GET DEVICE FILESPEC
	MOVEI	T1,DEVICE		;LOC OF DEVICE
	MOVX	T2,2			;JUST DEVICE & LOGICAL NAME
	XCALL	.GTSPC			;ASK SCAN TO TRANSFER
	SETZ	T1,			;GO TO THE NULL JOB
	MOVE	T2,LOGNAM		;GET THE  LOGICAL NAME
	REASSI	T1,			;DEASSIGN IT
	MOVE	T1,DEVICE		;GET THE DEVICE NAME
	MOVEM	T1,LGNOPK+.OPDEV	;PUT IN THE OPN BLK
	OPEN	1,LGNOPK		;OPEN SESAMIE??
	  PJRST	W$CAD			;DEVICE NOT AVAILABLE
	SETO	T1,			;ZAP TO -1
	MOVEI	T2,1			;GET THE CHAN
	REASSI	T1,			;REASSIGN THE CHANNEL
	MOVEI	T1,1			;GET IT AGAIN
	MOVE	T2,LOGNAM		;GET THE LOGICAL NAME
	DEVLNM	T1,			;GET THE DEVICE SET
	  PJRST	W$CAD			;ASSIGNMENT ERROR
	CALL	I$$ASD			;ASSIGNMENT INFO
	RELEAS	1,			;RELEASE THE CHANNEL
	RETURN

W$CAD:	RELEAS	1,			;LET IT GO
	MSG	<WARN>			;ONLY GIVE MESSAGE IF WANT WARNINGS
	PGOTO	W$$CAD			;CAN'T ASSIGN DEV:LOGNAM

>	; End Ife Tymcom
;CLEARS -- CLEAR THE SCREEN ON A DISPLAY
;CALL:	PUSHJ	P,CLEAR		OR (CALL CLEAR) /CLEAR PROCESSOR
;	RETURN

CLEARS:

GT4CLR:	IONEOU	[.CHFFD]		;CLEAR SCREEN WITH IMAGE FORM FEED
	RETURN

HZCLR:	XCALL	.TCRLF			;TYPE A CRLF TO NEARLY CLEAR HOR POS
	IONEOU	[176]			;CLEAR THE HAZELTINE SCREEN
	IONEOU	[234]
	IONEOU	[377]
	IONEOU	[377]
	Return

HPCLR:	Ioneou	[33]			;[26] home cursor
	Ioneou	["H"]			;[26]
	Ioneou	[33]			;[26] Clear screen
	Ioneou	["J"]			;[26]
	Return
;HP2621 -- SET TABS ON A HP2621 (Tymshare 444)
;CALL:	PUSHJ	P,HP2621	OR (CALL HP2621) /HP2621 PROCESSOR
;	RETURN

HP2621:	Ioneou	[15]			;[26] Make sure at left margin
	Ioneou	[33]			;[26] then clear tab settings.
	Ioneou	["3"]			;[26] (All of them)
	Hrroi	T1,.Axwid		;[26] Get width
	Seto	T2,			;[26] from the monitor
	Auxcal	T1,T2			;[26] (it might be accurrate)
	Movei	T3,1			;[26] simulate WRS code 2 step 1
Hploop:	Caml	T3,T2			;[26]    until WID
	  Jrst	Hpend			;[26]
	Ioneou	[40]			;[26]    Type  (space)
	Trnn	T3,7			;[26]    If mod (8) then
	  Pushj	P,[Ioneou    [33]	;[26]        set tab stop
		   Ioneou    ["1"]	;[26]        (esc 1)
		   Return]		;[26]
	Aoja	T3,Hploop		;[26] Loop across the line
Hpend:	Ioneou	[15]			;[26] return to left margin
	Return
ife tymcom,<

;MOUNT -- ADD PACK TO SEARCH LIST
;CALL:	PUSHJ	P,MOUNT	OR (CALL MOUNT) /MOUNT: PROCESSOR
;	RETURN

MOUNT:	XCALL	.SWSXQ			;PARSE PACK NAME
	MOVE	T1,.NMUL##		;GET SIXBIT PACK-NAME
	MOVEM	T1,LGNOPK+.OPDEV	;PUT IT INTO OPEN BLOCK
	OPEN	1,LGNOPK		;OPEN THE FILE-DEV
	  JRST	MOUFIN			;LOGON - PACK NOT AVAILABEL
	MOVE	T2,STRLTH		;GET THE CONTENTS OF THEIS
	MOVEM	T1,STRLST(T2)		;PUT THIS INTO CURRENT LIST
	MOVEI	T2,3			;GET A 3
	ADDM	T2,STRLTH		;ADD TO THE STR-LENGTH
	MOVE	T1,.MYPPN##		;GET OUR PPN
	MOVSI	T2,'UFD'		;GET THE EXT FOR UFD
	SETZB	T3,UFDFLG		;CLEAR 3RD ARG & UFDFLG
	MOVE	T4,[1,,1]		;GET 1,1 MFD
	LOOKUP	1,T1			;SEE IF A UFD HERE
	  SETOM	UFDFLG			;SET FLAG TO -1 -- NO UFD
	CALL	I$$MOU			;INFO ON WHETHER MOUNTED, ETC.
MOUFIN:	RELEAS	1,			;RELEASE THE CHANNEL
	RETURN
> ; end ife tymcom
;USERS -- PRINT OUT A MESSAGE FOR EACH USERNAME FOUND LOGGED IN
;CALL:	PUSHJ	P,USERS		OR (CALL USERS) /USERS: PROCESSOR
;

USERS:	XCall	.FILIN			;[32] GET [PPN] or (USERNAME)
	Movei	T1,OPTFUN		;[32] START OF OPTIONS STORAGE
	Movei	T2,.FXLEN		;[32] SIZE DESIRED
	XCall	.GTSPC			;[32] ASK SCAN TO TRANSFER
	Skipe	OPTARG			;[100] Illegal filename?
	  Return			;[100] Yes, so return
	Skipe	OPTPPN			;[100] Got a user or ppn?
	  Call	USERS0			;[100] Yes, check for printing
	Cain	C,","			;[100] Separated by a comma?
	  Jrst	USERS			;[100] Yes, Loop through list.
	Return				;[100]  No, Just return

USERS0:	CALL	CHKPPN			;IS THIS PPN ON THE SYSTEM?	[4]
	  RETURN			;NO--FORGET IT			[4]
USERS1:	CALL	I$$USR			;YES--TELL USER ABOUT HIM	[4]
	CALL	CHKEND			;[13]ELSE CHECK FOR MORE PPN'S	[4]
	  RETURN			;NONE FOUND--RETURN		[4]
	JRST	USERS1			;GOT ONE--OUTPUT STUFF		[4]

;PROGRAM -- PRINT OUT A MESSAGE FOR EACH PROGRAM FOUND RUNNING
;CALL:	PUSHJ	P,PROGRAM	OR (CALL PROGRAM) /PROGRAM: PROCESSOR
;

PROGRAM:XCall	.FILIN			; GET PROGRAM NAME
	Movei	T1,OPTFUN		; START OF OPTIONS STORAGE
	Movei	T2,.FXLEN		; SIZE DESIRED
	XCall	.GTSPC			; ASK SCAN TO TRANSFER
	Skipe	OPTARG			; Illegal filename?
	  Call	PROGR0			; Yes, check for printing
	Cain	C,","			; Separated by a comma?
	  Jrst	PROGRAM			; Yes, Loop through list.
	Return				;  No, Just return

PROGR0:	CALL	CHKPRG			; IS THIS PROGRAM RUNNING?
	  RETURN			; NO--FORGET IT
PROGR1:	CALL	I$$PRG			; YES--TELL USER ABOUT HIM
	CALL	CHKPRD			; ELSE CHECK FOR MORE NAMES
	  RETURN			; NONE FOUND--RETURN
	JRST	PROGR1			; GOT ONE--OUTPUT STUFF

CHKPRG:	MOVE	T3,MYJOB		; GET OUR JOB SO WE DON'T CHECK US
	MOVE	T2,[%NSHJB]		; GET HIGHEST JOB NUMBER ASSIGNED
	GETTAB	T2,			;  FROM .GTNSW TABLE
	  MOVEI	T2,^D512		; FAILURE--ASSUME 51KPRP:	CAMN	T3,T2			; IS IT OUR JOB?
	  JRST	CHKPRD			; YES--SO WE DON'T COUNT
	HRL	T1,T2			; GET THE JOB NUMBER TO CHECK
	HRRI	T1,.GTSTS		; See if Job is logged in
	Gettab	T1,			; by checking
	  Jrst	CHKPRD			; the JNA bit
	Txnn	T1,1B3			; see if it's on
	  Jrst	CHKPRD			; No! Not a job.
	HRL	T1,T2			; GET THE JOB NUMBER TO CHECK
	HRRI	T1,.GTNAM		; SETUP FOR GETTAB
	GETTAB	T1,			; LOOK FOR THE JOB'S NAME
	  JRST	CHKPRD			; FAILURE--ASSUME JOB NOT LOGGED IN
	XOR	T1,OPTARG		;[111] Get differences
	AND	T1,OPTMSK		;[111] MASK THEM
	JUMPN	T1,CHKPRD		; MATCH? NO, TRY NEXT JOB
	SKIPN	T1,OPTPPN		; PPN SPECIFIED?
	  JRST	CHKPRF			; No! Program found
	HRL	T1,T2			; GET THE JOB NUMBER TO CHECK
	HRRI	T1,.GTRDI		; SETUP FOR GETTAB
	GETTAB	T1,			; LOOK FOR THE JOB'S RUN DIRECTORY
	  JRST	CHKPRD			; FAILURE--ASSUME JOB NOT LOGGED IN
	XOR	T1,OPTPPN		; SAME RUN PPN?
	AND	T1,OPTPPM		; CHECK AGAINST MASK
	SKIPN	T1			; MATCH? No, so skip.
CHKPRF:	  AOSA	(P)			; YES--DO A FUNNY SKIP RETURN
CHKPRD:	SOJG	T2,CHKPRP		; NO--LOOP FOR ALL JOBS
	RETURN				; AND GO HOME

;SELECT -- DETERMINE OPTIONS TO TAKE ON SUBSEQUENT .OSCAN CALL
;CALL:	PUSHJ	P,SELECT	OR (CALL SELECT) /SELECT: PROCESSOR
;
SELECT:	SETZM	SPNODE			;[15]CLEAR THE SPECIFIED NODE
	Setzm	MMatch			;[101] Clear multi-match flag
	XCALL	.SIXSW			;[100] Read processor name
	MOVEM	N,OPTARG		;[100] Save option label
	XCALL	.SIXSW			;[100] Now get selection type
	MOVEM	N,OPTFUN		;[100] Put it in a good place
	MOVE	T1,[IOWD SELSIZ,SELNAM]	;[11]POINT TO LEGAL VALUE TABLE
Ife Tymcom,<
	HLLZ	T2,OPTFUN		;[100] GET THE CONDITION(LH)
	IF	(T2,NE,<[SIXBIT/TTY/]>)	;[100] IF NOT TTYNNN, THEN
> ; end ife tymcom
	  MOVE	T2,OPTFUN		;[100]  GET THE WHOLE WORD
	XCALL	.LKNAM			;[11]LOOK FOR A MATCH
	  PGOTO	E$USF			;[11]ERROR--UNKNOWN OR AMBIGUOUS SET FUNCTION
	CALL	@SELPRO-SELNAM(T1)	;[11,13]GOOD--DISPATCH TO PROCESSING ROUTINE
	  RETURN			;[13]NO MATCH--JUST RETURN

Always:	Skipe	SELOPT			;[100] Have we been this way before?
	  Return			;[100] Yes, only one per customer
	MOVE	T1,OPTARG		;GET THE NEW OPTION
	MOVEM	T1,SELOPT		;ASK FOR NEW OPTION LATER
	RETURN


	SUBTTL	/SELECT:OPTION:FUNCTION TABLES

	DEFINE	SELTBL	<
	X	ALWAYS
ife tymcom,<
	X	<BATCH,CTY,PTY>
	X	OPSER
	X	<PPNON,PPNOFF,PPNUSR>
> ; end ife tymcom
ifn tymcom,<
	X	USERS
> ; end ifn tymcom
	X	<CCL,NOCCL>
ife tymcom,<
	X	<REMOTE,LOCAL,DATASET>
	X	TTY
> ; end ife tymcom
	X	NODE
ifn tymcom,<
	X	<AUX,NOAUX>
	X	<SYSTEM,SYSNO>
> ; end ifn tymcom
	X	DET
	X	<KA10,KI10,KL10,KS10,F3,FOONLY>
> ; end define seltbl

DEFINE	X (NAME)<
    IRP <NAME>,<<SIXBIT/NAME/>>
>

SELNAM:	SELTBL
SELSIZ==.-SELNAM

DEFINE	X (NAME)<
    IRP <NAME>,<EXP NAME>
>

SELPRO:	SELTBL
	SUBTTL	/SELECT:FUNCTION SUBROUTINES

ife tymcom,<
BATCH:	HRROI	T1,.GTLIM		;SETUP FOR GETTAB LIMITS WORD
	GETTAB	T1,			;PICK UP THE WORD
	  SETZ	T1,			;ERROR--ASSUME NOT BATCH
	TXNE	T1,JB.LBT		;[13]IS THIS A BATCH JOB?
	  AOS	(P)			;[13]YES--SKIP RETURN
	RETURN

PTY:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.ITY		;ARE WE ON A PTY?
	  AOS	(P)			;[13]YES--SKIP RETURN
	RETURN
>

CCL:	IFI	(OFFSET,NE,0)		;[13]IF CCL ENTRY TO LOGN, THEN
	  AOS	(P)			;[13]YES--SKIP RETURN
	RETURN
NOCCL:	IFI	(OFFSET,EQ,0)		;[13]IF NORMAL ENTRY TO LOGON, THEN
	  AOS	(P)			;[13]  SKIP 
	RETURN

	Subttl	/Select:<Ppn-criteria>:  { PPNON, PPNOFF /USERS:list }

ife tymcom,<
PPNON:	CALL	CHKPPN			;IS THIS PPN ON SOMEWHERE?
	  RETURN			;NO--FORGET IT
	PGOTO	.POPJ1##		;[13]YES--THEN ACCEPT THIS OPTION

PPNOFF:	CALL	CHKPPN			;IS THIS PPN NOT! ON THE SYS?
	  AOS	(P)			;[13]YES--NOT ON, ACCEPT OPTION
	RETURN				;NO--PPN ON, SO FORGET IT
> ; end ife tymcom

CHKPPN:	MOVE	T3,MYJOB		;[12]GET OUR JOB SO WE DON'T CHECK US
	MOVE	T2,[%NSHJB]		;GET HIGHEST JOB NUMBER ASSIGNED
	GETTAB	T2,			; FROM .GTNSW TABLE
	  MOVEI	T2,^D512		;FAILURE--ASSUME 512
CHK.LP:	CAMN	T3,T2			;IS IT OUR JOB?
	  JRST	CHKEND			;YES--SO WE DON'T COUNT
	HRL	T1,T2			;GET THE JOB NUMBER TO CHECK
	HRRI	T1,.GTSTS		;[34] See if Job is logged in
	Gettab	T1,			;[34] by checking
	  Jrst	CHKEND			;[34] the JNA bit
	Txnn	T1,1b3			;[34] see if it's on
	  Jrst	CHKEND			;[34] No! Not a job.
	HRL	T1,T2			;GET THE JOB NUMBER TO CHECK
ife tymcom,<	;PPn at most sites
	HRRI	T1,.GTPPN		;SETUP FOR GETTAB
	> ; End ife tymcom
ifn tymcom,<	;Tymshare wants AUN 
	HRRI	T1,.GTAUN		;SETUP for GETTAB
	> ; End ifn tymcom
	GETTAB	T1,			;LOOK FOR THE JOB'S PPN
	  JRST	CHKEND			;FAILURE--ASSUME JOB NOT LOGGED IN
	XOR	T1,OPTPPN		;IS THE PPN ON ELSEWHERE?
	AND	T1,OPTPPM		;MASK THE PPN WE GOT
	SKIPN	T1			;MATCH? No! so skip
	  AOSA	(P)			;YES--DO A FUNNY SKIP RETURN
CHKEND:	SOJG	T2,CHK.LP		;NO--LOOP FOR ALL JOBS
	RETURN				;AND GO HOME

	Subttl	/Select:<Terminal-criteria>: { REM,LOC,DATA,DET,CTY,TTY }

ife tymcom,<
REMOTE:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.REM		;IS THIS A REMOTE TTY?
	  AOS	(P)			;[13]YES--SKIP
	RETURN

LOCAL:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNN	T1,GL.REM		;IS THIS A LOCAL TERMINAL?
	  AOS	(P)			;[13]YES--SKIP
	RETURN

DATASET:MOVE	T1,LINCHR		;GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.DSL		;IS THIS A DATASET LINE?
	  AOS	(P)			;[13]YES--SKIP
	RETURN

CTY:	MOVE	T1,LINCHR		;[12]GET OUR LINE CHARACTERISTICS
	TXNE	T1,GL.CTY		;ARE WE ON THE CTY?
	  AOS	(P)			;[13]YES--SKIP
	RETURN
> ; end ife tymcom

DET:	HLLZ	T1,TTYNAM		;[12]GET TTY GENERIC NAME
	JUMPE	T1,.POPJ1##		;[12,13]MATCH IF NULL(DET)
	RETURN				;[12]NO--JUST RETURN

ife tymcom,<
NODE:	XCall	.SIXSW			;[100] ANF-10/DECNET node name
	MOVE	T3,N			;[100] GET NODE NAME
	CALL	GETNOD			;[15] NUMERIC VALUE
	MOVEM	T1,SPNODE		;[15]SAVE THIS ONE TO CHECK

TTY:	XCall	.SIXSW			;[100] Read TTYnnn
	IFI	(SPNODE,NE,0)		;[100] IF NODE 0, USE TTYnnn
	  PGOTO	NTTY			;[100]  ELSE USE SPECIAL NODE ROUTINE
	IF	(N,EQ,TTYNAM)		;[100] IF THIS IS THE SELECTED TTY,
	  AOS	(P)			;[100]  THEN SKIP
	RETURN

NTTY:	HRRZ	T1,N			;[100] READ nnn FROM TTYnnn
	CALL	CNVT6O			;[15] CONVERT 6-BIT # TO OCTAL
	HRL	T1,SPNODE		;[15] FILL IN LINE # FOR TTY
	GTXTN.	T1,			;[15] NOW WE SHOULD HAVE TTYnnn IN SIXBIT
	  RETURN			;[15] ERROR--CAN'T GET IT RETURN
	IF	(T1,EQ,TTYNAM)		;[15,77]  or nnn matches port
	  AOS	(P)			;[15]DO SKIP-RETURN
	RETURN				;[15]ELSE RETURN
> ; end ife tymcom

	Subttl	/Select:<Terminal-criteria>: { AUX, NOAUX, NODE }

Ifn tymcom,<	;;Aux Circuit testing!

Aux:	Skipe	Tymaux			;[30] Skip return if an Aux
	Aos	(P)			;[30] !!!
	Return

Noaux:	Skipn	Tymaux			;[30] Skip return if not an Aux
	Aos	(P)			;[30] !!!
	Return

Node:	Call	Nodes			;[101] Check listed node
	  Caia				;[101] -- Not this one --
	 Aos	MMatch			;[101] Flag multiple matches
	Cain	C,","			;[101] More to come?
	  Jrst	Node			;[101] Yes, allow multiples
	Skipe	MMatch			;[101] Check for matches
	  Aos	(P)			;[101] Yes, indicate so
	Return				;[101]   and return

Nodes:	XCall	.OCTNW			;[100] Tymnet node number
	Movem	N,SPNODE		;[100] Save for later
	Seto	N,			;[100] Initialize port # to -1
	Cain	C,"-"			;[100] Tymnet port number?
	  XCall	.OCTNW			;[100] Yes, read it in
	If	(SPNODE,NE,NODNAM)	;[100] check node number match?
	  Return			;[100] -- no match --
	Skipl	N			;[100] port "-1" specified
	If	(N,EQ,TTYNOD)		;[100]  or nnn matches port
	  Aos	(P)			;[100] Do skip-return
	Return				;[100] -- return --
> ; end ifn tymcom


	Subttl	/Select:<Processor-type>: { Foonly,F3,KA10,KI10,KL10,KS10 }

Foonly:
F3:	Movei	T2,K.FOO		;[25] Foonley F3
	Jrst	K.Type			;[25] ...Check...

Ks10:	Movei	T2,K.KS10		;[25] KS-10 processor
	Jrst	K.Type			;[25] ...Check...
Kl10:	Movei	T2,K.KL10		;[25] KL-10 processor
	Jrst	K.Type			;[25] ...Check...
Ki10:	Movei	T2,K.KI10		;[25] KI-10 processor
	Jrst	K.Type			;[54] ...Check...
Ka10:	Movei	T2,K.KA10		;[54] KA-10 processor

K.Type:	push	p,			;[25] Save it.
	movei	T1,-1			;[54] New FOONLY/KA check
	push	T1,0			;[54] ...Look for carry...
	tlz	T1,1			;[54] Make 0 if normal DEC
	jumpn	T1,[Movei T1,K.FOO	;[54] Say that we are a foo
		    Jrst  K.Tret]	;[54] ...and continue.
	setz				;[25] Clear register
	blt				;[25] Try out BLT
	hrrzm				;[25] 0=KI/KA, 1=non-KI/F3;
	jumpg	K.Typ0			;[25]          ***********
	seto				;[25] Clear again
	aobjn				;[25] Try out AOBJN
	Movei	T1,K.KI10		;[25] Assume KI(1)
	Skipe				;[25] 0=non-KA, 1,,0=KA;
	  Movei	T1,K.KA10		;[25] No--Make it KA(0)
	Jrst	K.Tret			;[25] Return
K.Typ0:	Move	[20,,11]		;[25] Get serial number
	gettab				;[25] from the monitor
	  setz				;[25] ...don't forget skip...
	andi	70000			;[25] serial resolves KL vs KS;
	Movei	T1,K.KL10		;[25] Assume KL(2)
	Skipe				;[25] KL is [?:'07777];
	  Movei	T1,K.KS10		;[25] KS is ['10000:'70000];
K.Tret:	pop	p,			;[25] Restore it.
	Camn	T1,T2			;[25] Does it match?
	  Aos	(p)			;[25] Yes! Set skip return.
	Return				;[25] Then Return.

K.Tab:	K.KA10==.-K.Tab			;[54] KA
	Sixbit	/KA-10/			;[27] 0==KA
	K.KI10==.-K.Tab			;[54] KI
	Sixbit	/KI-10/			;[27] 1==KI
	K.KL10==.-K.Tab			;[54] KL
	Sixbit	/KL-10/			;[27] 2==KL
	K.KS10==.-K.Tab			;[54] KS
	Sixbit	/KS-10/			;[27] 3==KS
	K.UNK==.-K.Tab			;[54] UNK
	Sixbit	/UNK/			;[27] 4==Unknown
	K.FOO==.-K.Tab			;[54] FOONLY
	Sixbit	/Foonly/		;[27] 5==Foonly F3
K.Len==.-K.Tab-1			;[27] Length based on 0-n

	Subttl	/Select:option:<system-number>

Ifn tymcom,<
System:
Sysno:	Caie	C,":"			;[100] Allow :SYSTEM:X930
	Cain	C,"@"			;[31] Documented char is "@"
	  Jrst	Sysnok			;[31] Ok!
	Caie	C," "			;[31] Separator could be " "
	Cain	C,","			;[31]             or ","
	  Caia				;[31] Ok!
	Return				;[31] Bye .. Illegal separator

Sysnok:	XCall	.SIXSW			;[100] GET SYSTEM NUMBER
	Came	N,SyName		;[31] try it first without char
	Camn	N,ChName		;[31] then, with character (if missed)
	  Aos	(P)			;[31] Skip return if match!
	Return				;[31] Else, normal return.
> ; End ifn tymcom

	SUBTTL	SUBROUTINES FOR /SELECT:	GETNOD & CNVT6O

ife tymcom,<
GETNOD:	MOVE	T1,[XWD .NDRNN,T2]	;[15]SETUP FOR NODE. UUO
	MOVEI	T2,2			;[15] ...
	SETZ	T4,			;[15] ...
	NODE.	T1,			;[15]TRANSCRIBE THE NODE # TO
	  SETZ	T1,			;[15] SIXBIT FOR /SELECT CODE
	RETURN				;[15]RETURN  T1 CONTAINING NODE
> ; end ife tymcom

CNVT6O:	PUSH	P,T1			;[15]THIS IS WHAT WE'RE CONVERTING
	MOVE	T3,[POINT 6,(P)]	;[15]SETUP BYTE POINTER
	MOVEI	T4,6			;[15]MAXIMUM OF 6 DIGITS
	SETZ	T1,			;[15]CLEAR REPOSITORY
CNVT60:	ILDB	T2,T3			;[15]READ A CHARACTER
	JUMPE	T2,CNVT61		;[15]IGNORE BLANKS
	CAIL	T2,'0'			;[15]NUMERICS FROM 0
	CAILE	T2,'7'			;[15]  THROUGH 7
	  RETURN			;[15]NO--RETURN AS IS
	LSH	T1,3			;[15]MAKE ROOM FOR MORE
	MOVEI	T2,-'0'(T2)		;[15]MAKE NUMERIC
	ADD	T1,T2			;[15]PUT NEXT DIGIT INTO RESULT
CNVT61:	SOJG	T4,CNVT60		;[15]LOOP TILL OUT OF CHARS
	POP	P,(P)			;[15]RESTORE REGISTERS
	RETURN				;[15] & RETURN
;SET -- EXECUTE MONITOR .SET COMMANDS
;CALL:	PUSHJ	P,SET	OR (CALL SET) /SET: PROCESSOR

SET:	SETZM	SET.NO			;[55] CLEAR THE NO ARG  FLAG
	Store	T1,Setcmd,Setcmd+2,0	;[57] PRESET NUMERIC SET CMD WORD
	XCALL	.SIXSW			;[55] GET NEXT WORD
	CAME	N,[SIXBIT/NO/]		;[55] IS CMD A SET:NO ...
	CAMN	N,[SIXBIT/N/]		;[55] Or shorter "N"
	  CAIA				;[55] Yes--Skip
	 JRST	SET.0			;[55] NO--ASSUME ITS A SET: ...
	SETOM	SET.NO			;[55] YES--FLAG AS SUCH
	CAIE	C," "			;[55] IS THE DELIMETER A SPACE
	  PJRST	E$$IBC			;[55] NO--ILLEGAL BREAK CHAR
	XCALL	.SIXSW			;[55] GET THE REAL SET ARG
SET.0:	MOVEM	N,SETCMD		; SAVE  IT
	MOVE	T1,[IOWD ST.LEN,SETTBL]	;[20] Point to legal SET args
	XCALL	.NAME			;[20] Check for a match
	  PGOTO	E$$ISC			;[20] No match or ambiguous
	HRRZ	T1,T1			;[20] Get offset in table
	SUBI	T1,SETTBL		;[20] Compute real offset
	MOVEM	T1,ST.IDX		;[20] Put this into an index
	Move	N,SETTBL(T1)		;[57] Get entire name of set
	Movem	N,Setcmd		;[57] command.
	Call	@SETDSP(T1)		;[102] Ok, so process it
	CAIE	C,","			;[102] See if more args
	CAIN	C," "			;[102]  allow space or comma
	  GOTO	SET			;[102] Yes, so loop
	CAIN	C,":"			;[102]  allow colon also
	  GOTO	SET			;[102] Yes, so loop
	Return				;[102] No, just return


	SUBTTL	TABLE OF SET COMMANDS

DEFINE	SETLST<
	SETARG	*TTY,Do.TTY
ifn Tymcom,<				; Tymshare features
	SETARG	ALP,Do.Alp
	SETARG	ATTACH,Do.Att
	SETARG	DISCONNECT,Do.Dis
	SETARG	DSTIME,Do.DST
	SETARG	MODE,Do.Mod
	SETARG	RCMODE,Do.RCM
	SETARG	PRIVILAGE,Do.Pri
	SETARG	SCMODE,Do.SCM
	SETARG	TIMEZONE,Do.Tim
repeat 0,<	; not yet implemented
	SETARG	LICENSE,Do.Lic
	SETARG	WATCH,Do.Wat
	SETARG	PROJECT,Do.Pro
	> ; end repeat-0
	> ; end ifn tymcom
> ; end define setlst

DEFINE SETARG(ARG,Proc)< <SIXBIT /ARG/> >
SETTBL:	SETLST
	ST.LEN==.-SETTBL

DEFINE SETARG(ARG,Proc)< Exp Proc >
SETDSP:	SETLST
Subttl	SET TTY commands come here from /SET:TTY and /TTY

DoTTY:	Setzm	SET.NO			;[56] Come here on /TTY:command
	Store	T1,Setcmd,Setcmd+2,0	;[57] PRESET NUMERIC SET CMD WORD
	Movsi	T1,'TTY'		;[57] Put sixbit/TTY/
	Movem	T1,Setcmd		;[57]   into message
Do.TTY:	Xcall	Chktty			;[tym] Make sure network setup
	Skipn	T1,SET.NO		;[55] Look for "SET:NO TTY"
	  Setz	T1,			;[55] else assume "SET:TTY"
	Movem	T1,TT.NOP		;[55] ..if so force "TTY NO"
	CAIE	C," "			;MAKE SURE IT'S A SPACE
	CAIN	C,":"			;[56] Allow " " or ":"
	  Caia				;[56] Ok--Otherwise give error
	PJRST	E$$IBC			;ILLEGAL BREAK CHAR
	XCALL	.SIXSW			;GET NEXT WORD
	CAME	N,[SIXBIT/NO/]		;IS CMD A TTY NO ...
	CAMN	N,[SIXBIT/N/]		;[17] Or shorter "N"
	  CAIA				;[17] Yes--Skip
	 JRST	Do.TT0			;NO--ASSUME ITS A TTY ...
	SETCMM	TT.NOP			;YES--FLAG AS SUCH
	CAIE	C," "			;IS THE DELIMETER A SPACE
	  PJRST	E$$IBC			;NO--ILLEGAL BREAK CHAR
	XCALL	.SIXSW			;GET THE REAL TTY ARG
Do.TT0:	MOVEM	N,SETCMD+1		;SAVE  SET TTY ARG
	MOVE	T1,[IOWD TT.LEN,TTYTBL]	;[11]POINT TO LEGAL TTY ARGS
	XCALL	.NAME			;[11]CHECK FOR A MATCH
	  PGOTO	E$$ITS			;[11]NO MATCH OR AMBIG
	HRRZ	T1,T1			;GET OFFSET IN TABLE
	SUBI	T1,TTYTBL		;COMPUTE REAL OFFSET
	MOVEM	T1,TT.IDX		;PUT THIS INTO AN INDEX
	HRRZ	T1,TRMTBL(T1)		;[11]GET ADR OF ROUTINE
	Pushj	P,(T1)			;[102] DISPATCH TO RIGHT PROCESSOR
	CAIE	C,","			;[102] See if more args
	CAIN	C," "			;[102]  allow space or comma
	  GOTO	DoTTY			;[102] Yes, so loop
	CAIN	C,":"			;[102]  allow colon also
	  GOTO	DoTTY			;[102] Yes, so loop
	Return				;[102] No, just return

Chktty:
ifn tymcom,<
	Skipn	Tymaux			;[35] Don't do this if an Aux Circuit
	Skipe	TTY.OK			;[24] See if first time through.
	  Return			;[24] No, simply return.
	Setom	TTY.OK			;[24] Set it so we don't do it again!
	Movei	T4,10			;[24] Give it only a few tries
	Move	T3,[270,,500]		;[24] Return when output complete.
	Getlch	T2			;[24] Ok, now get it once
Chktt0:	Move	T1,T2			;[24] Swap T2,T1 2nd..times
	Hiber	T3,			;[24] Send yellowball & wait for done.
	  Jfcl				;[24] Ignore error.
	Getlch	T2			;[24] And again, see if changed.
	Came	T1,T2			;[24] Same?
	  Sojg	T4,Chktt0		;[24] No, changeing, try again!
> ; End ifn tymcom
	Return				;[24] Return.

ifn tymcom,<
LCHCOD:	Seto	T2,			;[22] Get set for command port
	Getlch	T2			;[22] Read current characteristics
	MOVE	T1,TT.IDX		;[22] JUST IN CASE NOT THERE
	HRRZ	T1,CLRSET(T1)		;[22] Get the sense of the set
	Skipn	T1			;[22] Check its sense
	 setcmm	TT.NOP			;[22]  and reverse sense of NO
	MOVE	T1,TT.IDX		;[22] JUST IN CASE NOT THERE
	TDO	T2,TRMTBL(T1)		;[22] Set them!
	SKIPE	TT.NOP			;[22] SKIP IF NOT SET (set already)
	  TDZ	T2,TRMTBL(T1)		;[22] Clear them as if [NO] Specified
	TRO	T2,777777		;[22] Make sure we mean us!
	Setlch	T2			;[22] Set the value
	Pjrst	Trmfin			;[22] Finish up
>

TRMCOD:	MOVE	T1,TT.IDX		;JUST IN CASE NOT THERE
	HRRZ	T2,CLRSET(T1)		;GET THE VALUE TO SET
	SKIPE	TT.NOP			;SKIP IF NOT SET
	HLRZ	T2,CLRSET(T1)		;GET THE VALUE TO CLEAR
TRMCO1:	MOVEM	T2,TRMBLK+2		;[7]PUT THIS AWAY
TRMCO0:	MOVE	T1,TT.IDX		;[7]RESTOR THE INDEX
ifn tymcom,<
	HLRO	T2,TRMTBL(T1)		;[22] GET THE Auxcal function
	Auxcal	T2,TRMBLK+2		;[22] Set the value
					;[22] No skip for his Auxcal
>
ife tymcom,<
	HLRZ	T2,TRMTBL(T1)		;[11]GET THE TRMOP. CODE
	MOVEM	T2,TRMBLK		;PUT IT AWAY HERE
	MOVE	T2,[XWD 3,TRMBLK]	;GET SET FOR TRMOP.
	TRMOP.	T2,			;SET THE TTY CONDITION
	  PGOTO	W$CNS			;[7]ERROR--SET TTY CMD FAILED
>
trmfin:	MOVE	T1,TT.IDX		;[20] Get index
	MOVE	T1,TTYTBL(T1)		;[20] For proper Name
	MOVEM	T1,SETCMD+1		;[20] For message
	PJRST	I$$SET			;GO TELL WHAT WAS SET IF DESIRED

TRMDEC:	SETCM	T2,TT.NOP		;[7]SKIP IF NOT-SET
	JUMPE	T2,TRMCO1		;[7]DO TRMCODE IF NO COMMAND
	XCALL	.DECNW			;GET THE NXT CHRS AS A DECIMAL
	HRRZM	N,TRMBLK+2		;STORE VALUE TO SET
	MOVEM	N,SETCMD+2		;STORE VALUE FOR INFO MSG
	Setzm	PrtMod			;[57] Decimal typeout
	PJRST	TRMCO0			;DO IT LIKE A REGULAR

TRMOCT:	SETCM	T2,TT.NOP		;[45] Skip if not set
	 JUMPE	T2,TRMCO1		;[45] DO TRMCOD stuff is no command
	XCALL	.OCTNW			;[45] Read as an OCTAL value
	Movem	N,TRMBLK+2		;[45] Store for set
	Movem	N,SETCMD+2		;[45] Store for message
	Setom	PrtMod			;[57] Octal Typeout
	Pjrst	TRMCO0			;[45] Use common code

TRMSIX:	SETCM	T2,TT.NOP		;[44] Skip if not set
	 JUMPE	T2,TRMCO1		;[44] DO TRMCOD stuff is no command
	XCALL	.SIXSW			;[44] Read as a SIXBIT value
	Movem	N,TRMBLK+2		;[44] Store for set
	Movem	N,SETCMD+2		;[44] Store for message
	Movei	N,1			;[57] Sixbit
	Movem	N,PrtMod		;[57] Typeout
	Pjrst	TRMCO0			;[44] Use common code


	SUBTTL	(.SET TTY) TABLES

ifn tymcom,<						;[22]
DEFINE TTYCMD<						;[22]
	LCHARG	(TAPE,lc.ptm,1,LCHCOD)			;[22]
	LCHARG	(LC,lc.ncm,1,LCHCOD)			;[22]
	LCHARG	(UC,lc.ncm,0,LCHCOD)			;[22]
	LCHARG	(TAB,lc.hht,1,LCHCOD)			;[22]
	LCHARG	(FORM,lc.hff,1,LCHCOD)			;[22]
	LCHARG	(ECHO,lc.hdx,0,LCHCOD)			;[22]
	LCHARG	(CRLF,lc.nfc,0,LCHCOD)			;[22]
	LCHARG	(DELAY,lc.crd,0,LCHCOD)			;[22]
							;[22]
	TTYARG	(PARITY,.Axep,1,0,TRMCOD)		;[22]
	TTYARG	(HALFDU,.Axhd,1,0,TRMCOD)		;[22]
	TTYARG	(FULLDU,.Axhd,0,1,TRMCOD)		;[22]
	TTYARG	(PARA,.Axpa,0,7,TRMDEC)			;[22]
	TTYARG	(PARB,.Axpa,0,7,TRMDEC)			;[22]
	TTYARG	(PARC,.Axpa,0,^D16,TRMDEC)		;[22]
	TTYARG	(HNXON,.Axhnx,1,0,TRMCOD)		;[22]
	TTYARG	(TABS,.Axnte,0,1,TRMCOD)		;[22]
	TTYARG	(TBREAK,.Axtbk,1,0,TRMCOD)		;[22]
	TTYARG	(FILL1,.Axfc1,1,0,TRMCOD)		;[22]
	TTYARG	(FILL2,.Axfc2,1,0,TRMCOD)		;[22]
	TTYARG	(WIDTH,.Axwid,^D16,^D200,TRMDEC)	;[22]
	TTYARG	(CODE,.Axtyp,0,17,TRMDEC)		;[22]
	TTYARG	(PAGE,.Axrvx,1,0,TRMCOD)		;[22]
	TTYARG	(XON,.Axrvx,1,0,TRMCOD)			;[22]
	TTYARG	(ERASE,.Axera,1,0,TRMCOD)		;[22]
	TTYARG	(LOWER,.Axlco,1,0,TRMCOD)		;[22]
	TTYARG	(UCO,.Axlco,0,1,TRMCOD)			;[22]
	TTYARG	(BACKSP,.Axbs,1,0,TRMCOD)		;[22]
	TTYARG	(REMXON,.Axrmx,1,0,TRMCOD)		;[22]
	TTYARG	(DEFER,.Axede,1,0,TRMCOD)		;[22]
	TTYARG	(RBSPAC,.Axrbs,1,0,TRMCOD)		;[36]
	TTYARG	(BSPUNC,.Axrbs,1,0,TRMCOD)		;[22]
	TTYARG	(BSDEL,.Axbsd,1,0,TRMCOD)		;[22]
	TTYARG	(TYPE,.Axttp,0,0,TRMSIX)		;[44]
	TTYARG	(RTCOMP,.Axrtc,1,0,TRMCOD)		;[61]
>							;[22]
> ; end ifn tymcom					;[22]
ife tymcom,<
DEFINE TTYCMD<
	TTYARG	(TAPE,.TOXON,1,0,TRMCOD)
	TTYARG	(LC,.TOLCT,0,1,TRMCOD)
	TTYARG	(UC,.TOLCT,1,0,TRMCOD)
	TTYARG	(SLAVE,.TOSLV,1,0,TRMCOD)
	TTYARG	(TAB,.TOTAB,1,0,TRMCOD)
	TTYARG	(FORM,.TOFRM,1,0,TRMCOD)
	TTYARG	(ECHO,.TOLCP,0,1,TRMCOD)
	TTYARG	(CRLF,.TONFC,0,1,TRMCOD)
	TTYARG	(WIDTH,.TOWID,^D16,^D200,TRMDEC)
	TTYARG	(GAG,.TOSND,0,1,TRMCOD)
	TTYARG	(HALFDUPLEX,.TOHLF,1,0,TRMCOD)		;[7]
	TTYARG	(FULLDUPLEX,.TOHLF,0,1,TRMCOD)		;[7]
	TTYARG	(REMOTE,.TORMT,1,0,TRMCOD)
	TTYARG	(LOCAL,.TORMT,0,1,TRMCOD)
	TTYARG	(DISPLAY,.TODIS,1,0,TRMCOD)		;[7]
	TTYARG	(FILL,.TOFLC,0,3,TRMDEC)
	TTYARG	(PAGE,.TOPAG,1,0,TRMCOD)
	TTYARG	(PAGESIZE,.TOPSZ,0,^D63,TRMDEC)		;[7]
	TTYARG	(PAGECOUNT,.TOPCT,0,^D63,TRMDEC)	;[7]
	TTYARG	(BLANKS,.TOBLK,0,1,TRMCOD)		;[2]
	TTYARG	(ALTMOD,.TOALT,0,1,TRMCOD)		;[16]
	TTYARG	(APL,.TOAPL,1,0,TRMCOD)			;[7]
	TTYARG	(DEBREAK,.TODBK,1,0,TRMCOD)		;[7]
	TTYARG	(2741,.TO274,1,0,TRMCOD)		;[7]
	TTYARG	(TIDY,.TOTDY,1,0,TRMCOD)		;[7]
	TTYARG	(AUTOCR,.TOACR,1,0,TRMCOD)		;[7]
	TTYARG	(RTCOMP,.TORTC,1,0,TRMCOD)		;[7]
	TTYARG	(PIMBRK,.TOPBS,0,-1,TRMOCT)		;[45]
	TTYARG	(TYPE,.TOTRM,0,0,TRMSIX)		;[44]
	TTYARG	(DEFER,.TODEM,1,0,TRMCOD)		;[45]
>
> ; end ife tymcom



DEFINE TTYARG(ARG,TRM,SET,CLR,PROC)<
	EXP	SIXBIT/ARG/>
ifn tymcom,<
DEFINE LCHARG(ARG,TRM,SET,PROC)<
	EXP	SIXBIT/ARG/>
>

TTYTBL:	TTYCMD
	TT.LEN=.-TTYTBL

DEFINE	TTYARG(ARG,TRM,SET,CLR,PROC)<
	XWD	<.TOSET+TRM>,PROC>
ifn Tymcom,<
DEFINE	LCHARG(ARG,TRM,SET,PROC)<
	EXP	TRM+PROC>
>

TRMTBL:	TTYCMD

DEFINE	TTYARG(ARG,TRM,SET,CLR,PROC)<
	XWD	CLR,SET>
Ifn Tymcom,<
DEFINE LCHARG(ARG,TRM,SET,PROC)<
	XWD	0,SET>
>

CLRSET:	TTYCMD
ifn tymcom,<
	Subttl	SETALP	Routine

Do.ALP:	XCall	.FILIN			; GET FUNCTION & FIRST ARG	[55]
	Movei	T1,Function		; STORE FUNCTION ADR		[55]
	Movei	T2,.FXLEN		;   enough words!		[55]
	XCall	.GTSPC			; ASK SCAN TO TRANSFER		[55]
DoALP0:	Move	T0,Function		; Setup for SETALP		[64]
	Move	T1,FunPPN		; .... DEV,PPN,PRG		[64]
	Move	T2,Arg			; ....				[64]
	Setz	T3,			; .... address ([T0,T1,T2])	[64]
	Setalp	T3,
	  PGOTO	W$ALP			; No `can do'			[42]
	PGOTO	I$$SET			; Tell about our experience	[57]

W$ALP:	MSG	<WARN>			; ONLY GIVE MESSAGE IF WANT WARNINGS
	XCall	W$$ALP			; Ok!
	Pgoto	T$CRLF			; Print <cr> and return

; Still in IFN TYMCOM conditional

ifn tymcom,<
	Subttl	SETSCM	Routine

	Opdef	SetSCM	[Calli -57]	;[71] new calli, not in MACRO.SHR

Do.RCM:	Tdza	T1,T1			;[105] restricted mode file
Do.SCM:	Seto	T1,			;[105] special command mode
	Movem	T1,RSMode		;[105] remember restricted-special
	XCall	.FILIN			;[71] GET FUNCTION & FIRST ARG
	Movei	T1,Function		;[71] STORE FUNCTION ADR
	Movei	T2,.FXLEN		;[71]   enough words!
	XCall	.GTSPC			;[71] ASK SCAN TO TRANSFER
	Hrroi	T1,6			;[71] Read privs
	Gettab	T1,			;[71]  for this frame
	  PGOTO	W$SCM			;[71] Error?
	Skipe	RSMode			;[105] restricted or special?
	  Tloa	T1,200			;[105] Set special bit
	 Tro	T1,JP.RCM		;[105] Set restricted bit
	Setprv	T1,			;[71]  in priv word
	Hrroi	T1,6			;[71] Read privs
	Gettab	T1,			;[71]  for this frame
	  PGOTO	W$SCM			;[71] Error?
	Skipe	RSMode			;[105] restricted or special?
	  Goto	DoSCM1			;[105] special...
	Txnn	T1,JP.RCM		;[105] Did it get set?
	  PGOTO	W$SCM			;[105]  No, not available
DoSCM1:	Tlnn	T1,200			;[105] Did it get set?
	  PGOTO	W$SCM			;[105]  No, not available
DoSCM0:	Move	T0,Arg			;[71] Setup for SET SCM
	Move	T1,FunPPN		;[71] .... PRG,PPN
	Setz	T3,			;[71] .... address ([T0,T1])
	Setscm	T3,
	PGOTO	I$$SET			;[71] Tell about our experience

W$SCM:	MSG	<WARN>			;[71] ONLY GIVE MESSAGE IF WANT WARNINGS
	XCall	W$$SCM			;[71] Ok!
	Pgoto	T$CRLF			;[71] Print <cr> and return

; Still in IFN TYMCOM conditional

Subttl	Privilage bit setting routines; /SET:PRIVILAGE [NO] Arg1[:Arg2]

;	Set commands which map into /SET:PRIVILAGE

Do.Att:		; /Set:[NO] Attach
Do.DST:		; /Set:[NO] DSTime
Do.Tim:		; /Set:[NO] Timezone {...}
Do.Mod:		; /Set:Mode {...}
Do.Dis:		; /Set:Disconnect {...}
Do.Cor:		; /Set:Core
	SETZM	Setcmd			; Clear command name
	PGOTO	Do.PV0			; Fall into Privilage code

Do.PRI:	CAIE	C," "			; MAKE SURE IT'S A SPACE
	PJRST	E$$IBC			; ILLEGAL BREAK CHAR
	XCALL	.SIXSW			; GET NEXT WORD
	CAME	N,[SIXBIT/NO/]		; IS CMD A TTY NO ...
	CAMN	N,[SIXBIT/N/]		; Or shorter "N"
	  CAIA				; Yes--Skip
	JRST	Do.PV0			; NO--ASSUME ITS A PRIV ...
	SETOM	SET.NO			; YES--FLAG AS SUCH
	CAIE	C," "			; IS THE DELIMETER A SPACE
	PJRST	E$$IBC			; NO--ILLEGAL BREAK CHAR
	XCALL	.SIXSW			; GET THE REAL TTY ARG
Do.PV0:	MOVEM	N,SETCMD+1		; SAVE  SET PRIV ARG
	MOVE	T1,[IOWD PV.LEN,PRITBL]	; POINT TO LEGAL PRIV ARGS
	XCALL	.NAME			; CHECK FOR A MATCH
	  PGOTO	E$$ISC			; NO MATCH OR AMBIG
	HRRZ	T1,T1			; GET OFFSET IN TABLE
	SUBI	T1,PRITBL		; COMPUTE REAL OFFSET
	MOVEM	T1,PV.IDX		; PUT THIS INTO AN INDEX
	Move	N,PRITBL(T1)		; Get Entire Name
	Movem	N,Setcmd+1		; Set for printing later
	HRRZ	T1,PRVTBL(T1)		; GET ADR OF ROUTINE
	PGOTO	(T1)			; DISPATCH TO RIGHT PROCESSOR

PRVSET:	Hrroi	T2,.GTPRV		; Get set for current user
	Gettab	T2,			; Read current characteristics
	  Setz	T2,			; Clear if gettab fails
	MOVE	T1,PV.IDX		; JUST IN CASE NOT THERE
	TDZ	T2,PRVFLD(T1)		; Clear the designated bits
	HLRZ	T1,PRVTBL(T1)		; Get the sense of the set
	Skipn	T1			; Check its sense
	 setcmm	SET.NO			;  and reverse sense of NO
	MOVE	T1,PV.IDX		; JUST IN CASE NOT THERE
	TDO	T2,PRVVAL(T1)		; Set them!
	SKIPE	SET.NO			; SKIP IF NOT SET (set already)
	  TDZ	T2,PRVVAL(T1)		; Clear them as if [NO] Specified
PRVSE0:	SetPRV	T2,			; Set the value
	PJRST	I$$SET			; GO TELL WHAT WAS SET IF DESIRED

; Still in IFN TYMCOM conditional

Subttl	More /SET:[NO] Privilage {...} [{...}] commands

PRVCOR:	Skipe	Set.No			; Make sure we're not playing games
	  Pgoto	PRVSET			; If so, go ahead and set to zero.
	Xcall	.SWCOR			; Read a core value
	Movem	N,SetCmd+2		; Store value for printing
	Setzm	PrtMod			;   and print in decimal
	Lsh	N,^D18			; Put into left half
PRVxRD:	Hrroi	T2,.GTPRV		; Read system privs
	Gettab	T2,			;  for the current user
	  Setz	T2,			;  none if error
	MOVE	T1,PV.IDX		; JUST IN CASE NOT THERE
	TDZ	T2,PRVFLD(T1)		; Clear the designated bits
	Ior	T2,N			; Grab value entered
	Pgoto	PRVSE0			; And set it!

PRVLST:	Xcall	.SIXSW			; Read a name
	Move	T1,PV.Idx		; Then compare it
	Move	T1,PRVVAL(T1)		;   to the proper list
	Xcall	.NAME			;   of items
	  Pgoto	E$$ISC			; Nope!  Bad item specified
	Hrrz	T1,T1			; First save the typed
	Move	N,(T1)			;   argument in the proper
	Movem	N,Setcmd+2		;   storage place
	Move	T2,PV.Idx		; Now point to shift constant
	Hlre	T2,PRVVAL(T2)		;   using the proper list
	Sub	T1,T2			; Depends on lists <names>,<info>
	Move	N,(T1)			;   to get new value in !N!
	Movei	T1,1			; Setup to print
	Movem	T1,PrtMod		;  values in sixbit
	Pgoto	PRVxRD			; Read and set new value

	SUBTTL	(.SET PRIVILAGE) TABLES

DEFINE PRVCMD<
	PRVARG	(ATTACH,jp.nat,jp.nat,0,PRVSET)
	PRVARG	(DST,jp.dst,jp.dst,1,PRVSET)
	PRVARG	(TIMEZONE,jp.zon!jp.dst,<Iowd Tz.Len,NamZon>,1,PRVLST)
	PRVARG	(CORE,jp.cor,0,1,PRVCOR)
	PRVARG	(LOGOUT,jp.los,jp.los,1,PRVSET)
	PRVARG	(DISCONNECT,jp.dop,<Iowd Ds.Len,NamDmo>,1,PRVLST)
	PRVARG	(RCM,jp.rcm,jp.rcm,0,1,PRVSET)
	PRVARG	(MODE,jp.mod!jp.rcm,<Iowd Md.Len,NamMod>,1,PRVLST)
>

DEFINE PRVARG(Nam,Fld,Val,Set,Proc)< <Sixbit /Nam/> >
PRITBL:	PRVCMD
	PV.Len==.-PRITBL	; Length

DEFINE PRVARG(Nam,Fld,Val,Set,Proc)< Xwd Set,Proc >
PRVTBL:	PRVCMD

DEFINE PRVARG(Nam,Fld,Val,Set,Proc)< Fld >
PRVFLD:	PRVCMD

DEFINE PRVARG(Nam,Fld,Val,Set,Proc)< Val >
PRVVAL:	PRVCMD

Define MShift(Mac,Len,Shift)<
    Define Mac(a,b)< <Sixbit /a/> >
    Nam'Mac: Mac's
	Len==.-Nam'Mac
    Define Mac(a,b)< <<b>>B'Shift >
    Val'Mac: Mac's
>

Define Modes<
	Mode	(PDP10,  .jpmpd)
	Mode	(XEXEC,  .jpmxe)
	Mode	(XEXECJ, .jpmxj)
	Mode	(SUDS,   .jpmsu)
	Mode	(RESTRI, .jpmpd!jp.rcm)
	Mode	(RPDP10, .jpmpd!jp.rcm)
	Mode	(RXEXEC, .jpmxe!jp.rcm)
	Mode	(RJAPAN, .jpmxj!jp.rcm)
	Mode	(RSUDS,  .jpmsu!jp.rcm)
>
	MShift(Mode,Md.Len,28)

Define Dmodes<
	Dmode	(LOGOUT,  .jplog)
	Dmode	(DETACH,  .jpdet)
	Dmode	(CONTINUE,.jpcon)
	Dmode	(TIMEOUT, .jpdto)
>
	Mshift(Dmode,Ds.Len,20)

Define	ZONES<	; Note: 2nd argument is OCTAL!
	Zone	(Y,4)
	Zone	(BST,5)
	Zone	(HST,6)
	Zone	(YST,7)
	Zone	(PST,10)
	Zone	(MST,11)
	Zone	(CST,12)
	Zone	(EST,13)
	Zone	(AST,14)
	Zone	(P,15)
	Zone	(O,16)
	Zone	(N,17)
	Zone	(GMT,20)
	Zone	(CET,21)
	Zone	(EET,22)
	Zone	(C,23)
	Zone	(D,24)
	Zone	(E,25)
	Zone	(F,26)
	Zone	(G,27)
	Zone	(H,30)
	Zone	(JST,31)
	Zone	(K,32)
	Zone	(L,33)
	Zone	(M,34)
; Some time zones missing below -- Use /Set:Dstime + /Set:Timezone xxx
	Zone	(BDT,45)
	Zone	(HDT,46)
	Zone	(YDT,47)
	Zone	(PDT,50)
	Zone	(MDT,51)
	Zone	(CDT,52)
	Zone	(EDT,53)
	Zone	(ADT,54)
	Zone	(WEST,60)
	Zone	(CEST,61)
	Zone	(EEST,62)

> ; End Zones

	Mshift(Zone,Tz.Len,7)


> ; End IFN TYMCOM conditional

	Subttl	/INFO  Switch Processor

;INFO - Routine to obtain & type out information about
;	the current hardware, software configuration.

Info:	Move	T1,N			;[74] copy value
	Came	N,[-1,,0]		;[74] /INFO:NONE ?
	  Jrst	Info.1			;[74] no, go set the word
	Movem	N,INFOSW		;[74] set index
	Movx	T1,%INFO		;[74] Get offset value
	Andcam	T1,NOTES		;[74]  clear /NOTIFY:INFO
	Return				;[74]   and return

Info.1:	Camn	N,[0,,-1]		;[74] /INFO:ALL ?
	  Jrst	Info.2			;[74] yes, skip ahead
	Caile	N,INFO.L		;[74] valid index?
	 Return				;[74]  no, return
	Movei	T1,1			;[74] yes, setup for bit value
	Lsh	T1,-1(N)		;[74] and shift into position
Info.2:	Iorm	T1,INFOSW		;[74] set proper bit
	Movx	T1,%INFO		;[74] Get offset value
	Iorm	T1,NOTES		;[74]  set /NOTIFY:INFO
	Return				;[74] Return.

	Subttl	/INFO  Printer

;INFO - Routine to type out information about the
;	current hardware, software configuration.
;
;[<Current-Date> <Current-Time> <Frame> <Port> <Node-Line>]
;[<Monitor> <Apr-Number> <Sys-Id> <Cpu-Type> <Memory> <Logmax> <Ttymax>]
;[<Load> <Response> <Uptime> <Users> <Schedule if # 0>]
;
T.INFO:	MSG	<INFO>			;[74] Must say /NOTIFY:INFO
	Move	T1,INFOSW		;[70] Get /INFO arguments
	Trnn	T1,-1			;[70] -1,,0 means :NONE
	  Return			;[70]  so return if empty.
	Tlne	T1,-1			;[70] 0,,MSK is absent, (skip 1)
	  Hlrm	T1,INFOSW		;[70] Copy !LH! bits to !RH!
	Move	T1,INFOSW		;[66] Check first line items
	Trnn	T1,%INFL1		;[66] against switch word
	  Jrst	StatL2			;[65] No, ignore this line
	Write	<[LONSTD>;		;[65] Write out the beginning
	Move	T1,INFOSW		;[65] Check date/time
	Trnn	T1,%DAYTIME		;[65]  against listed types
	  Jrst	StatX1			;[65] No, doesn't want it
	XCALL	.Tspac			;[65] ..space..
	XCALL	.TDATN			;[46] Type Date
	XCALL	.Tspac			;[46] ..space..
	XCALL	.TTIMN			;[46] Type Time
StatX1:	Move	T1,INFOSW		;[65] Check frame info
	Trnn	T1,%FRAME		;[65]  against listed types
	  Jrst	StatX2			;[65] No, doesn't want it
Ifn Tymcom,<Write < Frame: >>;		;[53] Type the job number
Ife Tymcom,<Write < Job: >>;		;[53] Type the job number
	Pjob	T1,			;[53] ...
	XCALL	.Tdecw			;[53]
StatX2:	Move	T1,INFOSW		;[66] Check network info
	Trnn	T1,%PORT		;[66]  against listed types
	  Jrst	StatX3			;[65] No, doesn't want it
	Write	< on >;			;[65] on TTYnnn
Ifn Tymcom,<
	hrroi	T1,.Gtlin		; Setup for getting users line	[22]
	Gettab	T1,			; Get his line number		[22]
	  setz	T1,
	tlnn	T1,777777		; Is he detached?		[22]
	  tlo	t1,'det'		; Yep! So tell user		[22]
	Xcall	.TSIXN			; Type it in sixbit		[22]
> ; End Ifn Tymcom
Ife Tymcom,<
	Write	<TTY>;			;TTY TEXT			[4]
	Seto	T1,			;Get for self			[53]
	TRMNO.	T1,			;  THE TERMINAL NUMBER		[4]
	  JRST	[MOVEI	T1,[ASCIZ/DET/]	;ERROR--ASSUME DETACHED		[4]
		 XCALL	.TSTRG		;SO SAY ON TTYDET		[4]
		 JRST	.+3]		;AND COME BACK			[4]
	TXZ	T1,.UXTRM		;CLEAR THE TERMINAL INDEX	[4]
	XCALL	.TOCTW			;OUTPUT THE TTY NUMBER		[4]
> ; End Ife Tymcom
STATX3:	Move	T1,INFOSW		;[66] Check network info
	Trnn	T1,%NETWORK		;[66]  against listed types
	  Jrst	StatX4			;[66] No, doesn't want it
	Write	< Network: >;		;[66] Info label
	Move	T1,NODNAM		;[27] Print the node
Ifn tymcom,<Xcall .Toctw>		;[27] Number
Ife tymcom,<Xcall .Tsixn>		;[27] or NAME
Ifn tymcom,<Write <->>;			;[27] Followed by "-"
Ife tymcom,<Write <_TTY>>;		;[27]   or "_TTY"
	Move	T1,TTYNOD		;[27] And nnn Port number.
	Xcall	.Toctw			;[27]
ifn tymcom,<
	Movei	T1,"*"			;[62] Let user know where we found
	Skipe	TymLog			;[62] the GTLOG info
	  Xcall	.TChar			;[62] with a *
>
StatX4:	Write	<]
>;

StatL2:	Move	T1,INFOSW		;[72] Check listed types (line 2)
	Trnn	T1,%INFL2		;[72] against specified types
	  Jrst	StatL3			;[72] No, go check next line
	Write	<[LONCNF>;		;[72] Write the beginning
	Move	T1,INFOSW		;[66] Get listed types
	Trnn	T1,%SYSTEM		;[66] Check system/hardware
	  Jrst	StatY1			;[65] No, doesn't want it
	XCALL	.Tspac			;[65] ..space..
	Movei	T1,Cnfnam		;[27] Obtain string name
	Xcall	.Tstrg			;[27] Type it out.
StatY1:	Move	T1,INFOSW		;[72] Get listed types
	Trnn	T1,%APR			;[72] Check APR serial number
	  Jrst	Stat2Y			;[72] No, doesn't want it
	Skipn	T1,GTAPRN		;[76] Available?
	  Jrst	Stat2Y			;[76] No, don't print it!
	Push	P,T1			;[72] Save!
	Write	< Apr# >;		;[72] Print leader
	Pop	P,T1			;[72] Restore!
	Xcall	.Tdecw			;[72] Print serial number
Stat2Y:	Move	T1,INFOSW		;[76] Get listed types
	Trnn	T1,%MONID		;[76] Check software serial #
	  Jrst	StatY2			;[76] No, doesn't want it
	XCALL	.Tspac			;[76] ..space..
	Move	T1,GTSIDN		;[76] Get software serial #
	Xcall	.Tsixn			;[76] Print the sixbit name
StatY2:	Move	T1,INFOSW		;[66] Get listed types
	Trnn	T1,%CPU			;[66] Check processor
	  Jrst	StatY3			;[66] No, doesn't want it
	XCALL	.Tspac			;[27] ..space..
	Call	K.Type			;[27] Get the processor type-index
	  jfcl				;[27] Ignore error return here
	Move	T1,K.Tab(T1)		;[27] Get the processor string
	Xcall	.Tsixn			;[27] Print the sixbit name
StatY3:	Move	T1,INFOSW		;[66] Get listed types
	Trnn	T1,%MEMORY		;[66] Check memory
	  Jrst	StatY4			;[66] No, doesn't want it
	Movx	T1,%NSMMS		;[66] Get number of physical
	Gettab	T1,			;[66] words from the monitor
	  Jrst	StatY4			;[66] Oops! Skip to space
	Lsh	T1,-11			;[66] Shift to make pages
	Push	P,T1			;[66] Save!
	Xcall	.Tspac			;[66] ..space..
	Pop	P,T1			;[66] Restore!
	Xcall	.Tdecw			;[66] and print it
	Write	< pages>;		;[66] include info text
StatY4:	Move	T1,INFOSW		;[72] Get listed types
	Trnn	T1,%LOGMAX		;[72] Check maximum frames
	  Jrst	StatY5			;[72] No, doesn't want it
	Xcall	.Tspac			;[72] ..space..
	Movx	T1,%CNNJB		;[72] Get number of maximum
	Gettab	T1,			;[72] frames from the monitor
	  Setz	T1,			;[72] clear frame count
	Xcall	.Tdecw			;[72] print number
	Write	< frames>;		;[72] of frames
StatY5:	Move	T1,INFOSW		;[72] Get listed types
	Trnn	T1,%TTYMAX		;[72] Check maximum ports
	  Jrst	StatY6			;[72] No, doesn't want it
	Xcall	.Tspac			;[72] ..space..
	Movx	T1,%CNPTS		;[72] Get number of maximum
	Gettab	T1,			;[72] ports from the monitor
	  Setz	T1,			;[72] clear port count
	Xcall	.Tdecw			;[72] print number
	Write	< ports>;		;[72] of ports
StatY6:	Write	<]
>;

StatL3:	Move	T1,INFOSW		;[66] Check listed types (line 3)
	Trnn	T1,%INFL2		;[66] against specified types
	  Return			;[65] No, doesn't want it
	Write	<[LONSTS>;		;[27] Write the third beginning.
Ifn Tymcom,<
	Move	T1,INFOSW		;[66] Get listed types
	Trnn	T1,%LOAD		;[66] Check load
	  Jrst	Stat.0			;[66] No, doesn't want it
	XCALL	.Tspac			;[65] ..space..
	Move	T1,[Xwd 35,12]		;[33] Read the % null time for
	Gettab	T1,			;[33] the last minute
	  Jrst	Stat.0			;[33]
	Imuli	T1,^D100		;[33] Percentage
	Move	T2,[Xwd 27,11]		;[33] Divided by
	Gettab	T2,			;[33] the # ticks in a minute
	  Jrst	Stat.0			;[33] to make it real
	Idiv	T1,T2			;[33]
	Movei	T2,^D100		;[33] Subtract it from 100%
	Subm	T2,T1			;[33]
	Xcall	.Tdecw			;[33] Type it out
	Write	<% >;			;[33] with a per cent
Stat.0:	Move	T1,INFOSW		;[66] Get listed types
	Trnn	T1,%RESPONSE		;[66] Check response
	  Jrst	StatZ1			;[65] No, doesn't want it
	Hrroi	T2,.AxSYB		;[33] Send a yellow ball
	Auxcal	T2,			;[33]
	Movsi	T1,41			;[33] Wait for orange ball
	Hrri	T1,1			;[53] Timeout for lost balls 1 sec
	Hiber	T1,			;[33]
	  Jfcl				;[33]
	Auxcal	T2,			;[33] Send a yellow ball
	Mstime	T2,			;[33] Then compare the time it
	Hiber	T1,			;[33] takes to send another
	  Jfcl				;[33] yellow ball
	Mstime	T1,			;[33]
	Sub	T1,T2			;[33] Subtract Start from Stop
	Xcall	.Tdecw			;[33] and print it.
	Write	<ms.>;			;[33]
	> ; End ifn tymcom

StatZ1:	Move	T1,INFOSW		;[72] Get listed types
	Trnn	T1,%UPTIME		;[72] Check uptime
	  Jrst	StatZ2			;[72] No, doesn't want it
	Movx	T1,%NSUPT		;[72] Get the system uptime
	Gettab	T1,			;[72] from the monitor in tics
	  Jrst	StatZ2			;[72] not available, sigh
	Push	P,T1			;[72] Save!
	Write	<  Uptime >;		;[72] Print message
	Pop	P,T1			;[72] Restore!
	Idivi	T1,^D60			;[73] Get time in seconds
	Idivi	T1,^D60			;[73] Get time in minutes
	Push	P,T2			;[73] Save seconds
	Idivi	T1,^D60			;[73] Get time in hours
	Push	P,T2			;[73] Save minutes
	Xcall	.Tdecw			;[73] Print hours
	Xcall	.Tcoln			;[73] Print a colon
	Pop	P,T1			;[73] Restore minutes
	Movei	T2,"0"			;[73] Use leading zeroes
	Xcall	.Tdec2			;[73] For printing minutes
	Xcall	.Tcoln			;[73] Print a colon
	Pop	P,T1			;[73] Restore seconds
	Movei	T2,"0"			;[73] Use leading zeroes
	Xcall	.Tdec2			;[73] Print seconds

StatZ2:	Move	T1,INFOSW		;[72] Get listed types
	Trnn	T1,%USERS		;[72] Check users
	  Jrst	StatZ3			;[72] No, doesn't want it
	Movx	T2,%NSHJB		;[72] Get highest job
	Gettab	T2,			;[72] number from monitor
	  Jrst	StatZ3			;[72] Can't read it, bye
	Setz	T1,			;[72] Clear counter
	Hrlz	T3,T2			;[72] Get job#,,0
	Gettab	T3,			;[72]  read status bits
	  Jrst	StatZ3			;[72] Abort on table failure
	Tlne	T3,(1B3)		;[72] Is it assigned?
	  Aoj	T1,			;[72] Yes, increment counter
	Sojg	T2,.-5			;[72] Loop till all counted
	Push	P,T1			;[72] Save!
	Xcall	.Tspac			;[72] ..space..
	Pop	P,T1			;[72] Restore!
	Xcall	.Tdecw			;[72] Print assigned jobs
	Write	< users>;		;[72] and associated text

StatZ3:	Move	T1,INFOSW		;[66] Get listed types
	Trnn	T1,%Schedule		;[66] Check schedule
	  Jrst	Stat.1			;[66] No, doesn't want it
	Movx	T1,%Cnsts		;[27] Get the system STATES word
	Gettab	T1,			;[27] from the CONFIG tables
	  Jrst	Stat.1			;[27] ... oops!
	Tlz	T1,-1			;[27] Clear Feature test bits
	  Jumpe	T1,Stat.1		;[27] If non-zero, then
	Push	P,P1			;[27] Save 1 for pointer
	Move	P1,T1			;[27] Save states & type them out.
	Xcall	.Tspac			;[65] ..space..
Ifn Tymcom,<
	Ifstrg	1b19,<Super>;		;[27] Any shut, Check Super first.
	Ifstrg	3b19,<Shut>;		;[27] This one is tricky!
	Ifstrg	1b20,<Restricted>;	;[27] Well, is it a No-No?
	> ; End Ifn Tymcom
Ife Tymcom,<
	Ifstrg	1b27,<No Oper Coverage>;;[27] No operator coverage	400
	Ifstrg	1b28,<Unspooling>;	;[27] Unspooling allowed	200
	Ifstrg	1b29,<No Restricted DEV>;[27] Unrestricted devices	100
	Ifstrg	1b32,<Stand Alone>;	;[27] No remote tty's		 10
	Ifstrg	1b33,<Batch Only>;	;[27] Batch logins only		  4
	Ifstrg	1b34,<Local Only>;	;[27] No Remote logins		  2
	Ifstrg	1b35,<CTY Only>;	;[27] No logins 'cept from CTY	  1
	> ; End Ife Tymcom
	Pop	P,P1			;[27] Restore register
Stat.1:	Write	<]
>;					;[27] Carriage-return
	Return


;TELL -- OUTPUT A MESSAGE ON THE TTY:
;CALL:	PUSHJ	P,TELL		OR (CALL TELL) /TELL: PROCESSOR
;	RETURN

TELL:	XCALL	.ASCQW			;GET THE ASCII STRING TO TELL
	MSG	<TELL>			;ONLY TELL HIM IF HE WANTS IT
	WRITE	<[LONMSG >;		;[21]
	MOVEI	T1,.NMUL##		;POINT TO MESSAGE
	XCALL	.TSTRG			;OUTPUT IT
	XCALL	.TRBRK			;CLOSE UP WITH A "]"
	WRITE	<
>;					;[21]
	RETURN
	SUBTTL	ERROR PROCESSING

E$$CSS:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONCSS Can't set search-list
>
	RETURN

E$$IBC:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONIBC Illegal break character in switch
>
	RETURN

E$$ISC:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONISC Illegal set >
	MOVE	T1,SETCMD
	XCALL	.TSIXN
	WRITE	< command>
	SKIPN	SETCMD+1		;[107] Skip if anything more
	  PGOTO	.TCRLF			;[107] done for now
	XCALL	.TSPAC			;[107] a little spacing
	MOVE	T1,SETCMD+1		;[107] Get more info
	XCALL	.TSIXN			;[107] Print it
	PGOTO	.TCRLF

E$$ITS:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONISC Illegal TTY >
	MOVE	T1,SETCMD
	XCALL	.TSIXN
	WRITE	< command>
	SKIPN	SETCMD+1		;[107] Skip if anything more
	  PGOTO	.TCRLF			;[107] done for now
	XCALL	.TSPAC			;[107] a little spacing
	MOVE	T1,SETCMD+1		;[107] Get more info
	XCALL	.TSIXN			;[107] Print it
	PGOTO	.TCRLF

E$USF:	JUMPGE	T1,E$ASF		;[11]JUMP IF AMBIGOUS
	MSG	<FATAL>
	WRITE	<
?LONUSF Unknown select function /SELECT:>
	MOVE	T1,OPTFUN		;[11]GET FUNCTION
	PGOTO	.TSIXN##		;[11]OUTPUT IT AND RETURN

E$ASF:	MSG	<FATAL>
	WRITE	<
?LONASF Ambiguous select function /SELECT:>
	MOVE	T1,OPTFUN		;[11]GET FUNCTION
	PGOTO	.TSIXN##		;[11]OUTPUT IT AND RETURN

E$$SNE:	MSG	<FATAL>			;ONLY PRINT IF USER WANTS ERRORS
	WRITE	<
?LONSNE /SELECT nesting exceeded
>
	RETURN
	SUBTTL	WARNING MESSAGES

W$$SCM:	Skipn	RSMode			;[105] restricted or special
	  PGoto	W$$RCM			;[105] use other message
	Write	<%LONSCM Could not set special command processor >
	PGoto	T$FName			;[71] Print filename & return

W$$RCM:	Write	<%LONSCM Could not set restricted command processor >
	PGoto	T$FName			;[71] Print filename & return

W$$ALP:	Write	<%LONALP Could not set alternate logout program >
T$FNam:	Write	<(>			;[57] Add capability to use this
	Move	T1,FunUSR		;[64] Get first half of name
	Xcall	.Tsixn			;[42] Print.
	Move	T1,FunUS1		;[64] 2nd half
	Xcall	.Tsixn			;[42] Print
	Write	<)>			;[42] Be safe?
	Move	T1,Arg			;[42] Get program name
	XCALL	.TSIXN			;[21][7]PRINT IT
	Return

Ife Tymcom,<	;[51] Remove /Assign code for now!
W$$CAD:	WRITE	<%LONCAD Could not assign device >
	MOVE	T1,DEVICE		;GET THE DEVICE
	XCALL	.TSIXN			;[7]PRINT THIS
	WRITE	< logical name >
	MOVE	T1,LOGNAM		;GET LOGICAL NAME
>	; End Ife Tymcom
T$SIXN:	XCALL	.TSIXN			;[21][7]PRINT IT
T$CRLF:	Write	<
>;					;[21]
	RETURN

W$CNS:	MSG	<WARN>			;[7]ONLY PRINT IF USER WANTS WARNINGS
W$$CNS:	WRITE	<%LONCNS Could not SET >
	MOVE	T1,ST.IDX		;[20] Get command name index
	MOVE	T1,SETTBL(T1)		;[20][7]GET SET COMMAND NAME
	XCALL	.TSIXN			;[7]OUTPUT IT
	XCALL	.TSPAC			;[7]AND A SPACE
	MOVEI	T1,[ASCIZ/NO /]	
	IFI	(TT.NOP,NE,0)		;[7]IF THIS IS NO COMMAND
	  XCALL	.TSTRG			;[7]OUTPUT THE NO
	Skipe	T1,SETCMD+1		;[7]GET THE ARGUMENT
	  XCALL	.TSIXN			;[7]OUTPUT IF THERE IS ONE
	IFI	(SETCMD+2,GE,0)		;[7]IF THERE IS A DECIMAL ARG
	  XCALL	.TSPAC			;[7]SPACE OVER
	SKIPL	T1,SETCMD+2		;[7]IF DECIMAL ARG
	  XCALL	.TDECW			;[7]OUTPUT IT
	PGOTO	T$CRLF			;[21] Finish up with CRLF


	SUBTTL	INFO	MESSAGES

I$$MOU:	MSG	<MOUNT>		;ONLY PRINT IF USER WANTS MOUNTS
	SKIPE	UFDFLG		;IS THERE A UFD??
	JRST	I$$MNU		;NO--SO SAY SO   N.S.S.S.
	WRITE	<[LONMOU .Mount >
	MOVE	T1,.NMUL##	;GET 6BIT NAME OF PACK
	XCALL	.TSIXN		;PRINT IT OUT
	XCALL	.TRBRK		;TYPE A "]"
	PGOTO	T$CRLF		;[21] Finish up with CRLF

I$$MNU:	WRITE	<[LONMNU .Mount >
	MOVE	T1,.NMUL##	;GET PACK NAME
	XCALL	.TSIXN		;TYPE PACK NAME
	WRITE	< ; No UFD created]
>
	RETURN

Ife Tymcom,<	;[51] Remove /Assign code!
I$$ASD:	MSG	<ASSIGN>	;ONLY PRINT IF USER WANTS ASSIGNMENTS
	WRITE	<[LONASD .Assign >
	MOVE	T1,DEVICE	;GET THE DEVICE
	XCALL	.TSIXN		;PRINT IT
	XCALL	.TCOLN		;PRINT OUT A ":"
	MOVE	T1,LOGNAM	;GET THE LOGICAL NAME
	XCALL	.TSIXN		;PRINT IT
	XCALL	.TRBRK		;TYPE A "]"
	PGOTO	T$CRLF		;[21] Finish up with CRLF
>	; End Ife Tymcom

I$$RUN:	MSG	<RUN>		;ONLY PRINT IF USER WANTS RUN MESSAGES
	WRITE	<[LONRUN .Run >;;[21]
	MOVEI	T1,N.DEV	;[14]POINT TO FILE BLOCK
	XCALL	.TFBLK		;[14]AND OUTPUT IT
	WRITE	<]
>
	RETURN

I$$SET:	MSG	<SET>		;ONLY PRINT IF USER WANTS SET MESSAGES
	WRITE	<[LONSET .Set >
	Movei	T1,[Asciz/NO /]	;[57] Check for "NO"
	Skipe	Set.No		;[57]  and type it if
	  XCALL	.TSTRG		;[57]  it was entered
	MOVE	T1,Setcmd	;[57] Type entire command name
	XCALL	.TSIXN		;TYPE IT
	XCALL	.TSPAC		;FOLLOWED BY A SPACE
	Movsi	T1,'ALP'	;[57] Is it an ALP?
	Camn	T1,SetCMD	;[57]   command?
	  Jrst	I$$Se0		;[57] Yes! -- Do special.
	MOVEI	T1,[ASCIZ/NO /]
	SKIPE	TT.NOP		;DID WE DO A SET ARG NO VAL CMD?
	XCALL	.TSTRG		;YES--TYPE OUT THE NO
	MOVE	T1,SETCMD+1	;GET SET COMMAND ARGUMENT
	XCALL	.TSIXN		;TYPE IT OUT
	Move	T2,PrtMod	;[57] Get typeout mode for setcmd+2
	Skipe	SETCMD+2	;[57] IF THERE IS A DECIMAL ARG
	  XCALL	.TSPAC		;[57] SPACE OVER
	Skipe	T1,SetCMD+2	;[57] If it's non-zero, then
	  CALL	@SetPrt(T2)	;[57] OUTPUT IT -1=oct,0=dec,1=six
T$RBRK:	XCALL	.TRBRK		;TYPE A "]"
	PGOTO	T$CRLF		;[21] Finish up with CRLF
I$$SE0:	XCall	T$FNam		;[57] Type out filename
	PGoto	T$RBRK		;[57] & Finish

I$$PRG:	MSG	<PROGRAM>		;[110] Only Type if /NOTIFY:PROGRAM
	JRST	I$$PR1			;[110] Use common code
I$$USR:	MSG	<USER>			;[32] Only Type this if /NOTIFY:USER
I$$PR1:	XCALL	.PSH4T			;[4] SAVE T1-T4
	PUSH	P,T2			;[4] SAVE job WHERE WE CAN GET AT IT
ife tymcom,<
	WRITE	<[LONUSR	Job: >;	;[23]  Beginning part
>
ifn tymcom,<
	Write	<[Frame: >;		;[23] What Frame number
>
	HRRZ	T1,(P)			;[23]  We'd like to know
	XCALL	.TDECW			;[23] Type it
	WRITE	< User: >;		;[23] PREFACE MESSAGE
	MOVX	T1,.GTNM1		;OUTPUT THE USER'S NAME
	HRL	T1,(P)			;[37]
	GETTAB	T1,
	  SETZ	T1,			;OOPS
	XCALL	.TSIXN			;
	MOVX	T1,.GTNM2		;OUTPUT THE USER'S NAME
	HRL	T1,(P)			;PUT IN THE JOB NUMBER
	GETTAB	T1,
	  SETZ	T1,			;OOPS!!
	XCALL	.TSIXN			;
	MOVX	T1,.GTPPN		;[4] GET THE PPN
	HRL	T1,(P)			;[4] FOR THE JOB
	GETTAB	T1,			;[4] FROM THE GETTABS
	  CAIA				;[40] OOPS!!	Skip so no [0,0]
ife tymcom,<
	XCALL	.TPPNW			;[50] TYPE THAT
	> ; End ife tymcom
ifn tymcom,<
	Movx	T2,.GTAUN		;[50] GET users AUN
	HRL	T2,(P)			;[50] FOR THE JOB
	GETTAB	T2,			;[50] FROM THE GETTABS
	  Caia				;[50] Can't compare???
	Camn	T1,T2			;[50] Ok! Compare them PPn=AUN?
	  Jrst	I$$US2			;[50] Yes--Don't bother with more
	open	1,[     .iodmp		;[50] Get a disk channel
		   sixbit /dsk/		;[50] to lookup
		   0]			;[50] the UFD
	  Jrst	I$$Us2			;[50] Open failed - Don't try
	Movem	T1,LKBLOK+.Rbnam	;[50] put name in lookup block
	Movsi	T1,'UFD'		;[50] ...
	Movem	T1,LKBLOK+.Rbext	;[50] ... extension
	Move	T1,[1,,1]		;[50] ...
	Movem	T1,LKBLOK+.Rbppn	;[50] ... PPN (UFD)
	Movei	T1,.Rbunm+2		;[50] ... block size
	Movem	T1,LKBLOK		;[50] ... count
	Lookup	1,LKBLOK		;[50] See if the file is there
	  Jrst	I$$Us2			;[50] Can't read it... Don't go on
	Write	<(>;			;[50] Begin block.
	Move	T1,LKBLOK+.Rbunm	;[50] Get text
	Xcall	.TSIXN			;[50] Type it
	Skipe	T1,LKBLOK+.Rbunm+1	;[50] Any more
	Xcall	.TSIXN			;[50] Type it
	WRITE	<)>;			;[50] Finished!
I$$US2:	WRITE	< on >;			;[4] TTY TEXT
ifn tymcom,<
	movei	T1,.Gtlin		;[22]  Setup for getting users line
	hrl	T1,(P)			;[22]  For job N
	Gettab	T1,			;[22]  Get his line number
	  setz	T1,
	Push	P,T1			;[47] Save this name...
	tlnn	T1,777777		;[22]  Is he detached?
	  tlo	t1,'det'		;[22]  Yep! So tell user
	Xcall	.TSIXN			;[22]  Type it in sixbit
	Pop	P,T2			;[47] Restore sixbit /ttynnn/
	Tlnn	T2,777777		;[47] Is he detached?
	  Jrst	I$$us8			;[47] Yes! -- Don't bother with Tymnet
	Push	P,T2			;[47] Save it again
	Write	< (>;			;[47] Whilst we type out something
	Pop	P,T2			;[47] (Probably didn't need to save)
	Push	P,[Point 6,T2,^D17]	;[47] Setup to convert to an integer
	Movei	T3,3			;[47] reading maximum of 3 digits
	Setz	T4,			;[47] with the result in T4
I$$us4:	Ildb	T1,(P)			;[47] Get a byte
	Jumpe	T1,I$$us6		;[47] Ok!
	Lsh	T4,3			;[47] Shift a digit
	Addi	T4,-'0'(T1)		;[47] Add it in
	Sojg	T3,I$$us4		;[47] Loop.
I$$us6:	Pop	P,(P)			;[47] Free the stack location
	movei	T1,.Gtlog		;[47] Get the Tymnet Node:line, etc.
	hrl	T1,T4			;[47] For Port N
	Gettab	T1,			;[47] ...
	  Setz	T1,			;[47] Shouldn't happen
	Move	T2,T1			;[47] Copy it
	Andi	T2,177			;[47] Save Line number
	Push	P,T2			;[47] ...
	Lshc	T1,-^d14		;[47] First set of 6 bits
	Lsh	T1,-2			;[47] Throw away garbage bits
	Lshc	T1,-^d30		;[47] Should now have the right ones
	Andi	T2,7777			;[23] Make it Octal Node #
	Move	T1,T2			;[47] Copy for printing
	Xcall	.Toctw			;[47] Node number..
	Write	<->;			;[47]  -
	Pop	P,T1			;[47] Remember the tty number
	Xcall	.Toctw			;[47] Print it
	Write	<)>;			;[47] Finish!
I$$us8:
>
ife tymcom,<
	WRITE	<TTY>;			;[4] TTY TEXT
	HRRZ	T1,(P)			;[22] Get Job number from stack
	TRMNO.	T1,			;[4] GET THE TERMINAL NUMBER
	  JRST	[MOVEI	T1,[ASCIZ/DET/]	;[4] ERROR--ASSUME DETACHED
		 XCALL	.TSTRG		;[4] SO SAY ON TTYDET
		 JRST	.+3]		;[4] AND COME BACK
	TXZ	T1,.UXTRM		;[4] CLEAR THE TERMINAL INDEX
	XCALL	.TOCTW			;[4] OUTPUT THE TTY NUMBER
>
	hrrzi	T1,.Gtnam		;[23] Now the program name
	HRL	T1,(P)			;[22] Get Job number from stack
	Gettab	T1,			;[23]  From the monitor
	  setz	T1,			;[23]  Assumming there is one
	Jumpe	T1,I$$US1		;[23]  No? -- Skip this
	push	p,T1			;[23]  Save...
	WRITE	< program >;		;[23] 	Type text
	pop	p,T1			;[23]  Restore
	Xcall	.Tsixn			;[23]  Then type it
ifn tymcom,<	;Not sure if this works on tops-10
	Xcall	.Tspac			;[41]  Space
	hrrzi	T1,.Gtsts		;[41]  Frame status word
	HRL	T1,(P)			;[41]  Get Job number from stack
	Setz	T2,			;[41]  Precaution: so zero shift
	Gettab	T1,			;[41]   Well, maybe...
	  setz	T1,			;[41]   Oh well, say ^C anway
	Txnn	T1,1b0			;[41]  Skip if Job is RUNable
	  Jrst	I$$US0			;[41]   No!! so print ^C
	Lsh	T1,-^D21		;[41]  Shift this
	Andi	T1,37			;[41]  Must be within range
	Idivi	T1,3			;[41]  Now divide since table in 3s
	Movss	T1			;[41]  Swap halves
	Imuli	T2,^d12			;[41]  Ready for shift
	Hrri	T1,.Gtwsc		;[41]  Wait states list
	Gettab	T1,			;[41]   Well, maybe...
I$$US0:	  Movsi	T1,'^C '		;[41]  If error here -- ^C
	Lsh	T1,(T2)			;[41]   Ok!
	Tdz	T1,[77777777]		;[41]  Clear garbage
	Xcall	.Tsixn			; Type it			[41]	
	> ; End ifn tymcom
I$$US1:	POP	P,T1			;[43] GET THE JOB NUMBER
	XCALL	.TRBRK			;[43] CLOSE UP THE MESSAGE
	XCALL	.TCRLF			;[21]  Type ending
	XCALL	.POP4T			;[4] RESTORE ALL TEMP ACS
	RETURN
	SUBTTL	SCAN SWITCH MACRO TABLES

	DEFINE	SWTCHS	<

ife tymcom,<
	SP	*ASSIGN,,ASSIGN,,FS.NFS
>
	SP	CLEAR,,CLEARS,,FS.NFS
	SP	HP2621,,HP2621,,FS.NFS
	SL	INFO,<-100,,INFO>,INFO,INFMSK,FS.OBV!FS.NFS
ife tymcom,<
	SP	*MOUNT,,MOUNT,,FS.NFS
>
	SL	*NOTIFY,NOTES,NOTF,0,FS.OBV!FS.NFS
	SP	PROGRAM,,PROGRAM,,FS.VRQ
	SP	SELECT,,SELECT,,FS.NFS!FS.VRQ
	SP	SET,,SET,,FS.NFS!FS.VRQ
	SP	*TELL,,TELL,,FS.NFS
	SP	TTY,,DOTTY,,FS.NFS!FS.VRQ
	SP	USERS,,USERS,,FS.VRQ

>

KEYS NOTF,<ASSIGN,MOUNT,SELECT,SET,TELL,RUN,FATAL,WARN,INFO,HELP,USERS,PROGRAM>

	%ASSIGN== 1B35	;;[6] DEFINE NOTIFY BITS IN SAME ORDER AS KEYS MACRO
	%MOUNT==  1B34
	%SELECT== 1B33
	%SET==    1B32
	%TELL==   1B31
	%RUN==    1B30
	%FATAL==  1B29
	%WARN==   1B28
	%INFO==   1B27
	%HELP==   1B26
	%USER==   1B25
	%PROGRAM==1B24

KEYS INFO,<DAYTIME,FRAME,PORT,NETWORK,SYSTEM,APR,MONID,CPU,MEMORY,LOGMAX,TTYMAX,LOAD,RESPONSE,UPTIME,USERS,SCHEDULE>

	%DAYTIME==1B35	;[65] Define INFO bits in same order as KEYS macro
	%FRAME==  1B34			;[66] Job/Frame number
	%PORT==   1B33			;[66] TTY # on system
	%NETWORK==1B32			;[66] Network node-line

	%SYSTEM== 1B31			;[66] Monitor name
	%APR==    1B30			;[72] Apr serial #
	%MONID==  1B29			;[76] Software serial #
	%CPU==    1B28			;[66] Processor type
	%MEMORY== 1B27			;[66] Physical memory
	%LOGMAX== 1B26			;[72] Maximum # frames
	%TTYMAX== 1B25			;[72] Maximum # ports

	%LOAD==   1B24			;[66] System load
	%RESPONS==1B23			;[66] Network turn around response
	%UPTIME== 1B22			;[72] System uptime
	%USERS==  1B21			;[72] Users with JNA set
	%SCHEDUL==1B20			;[66] System states word

	%INFL1==%DAYTIME!%FRAME!%PORT!%NETWORK
	%INFl2==%SYSTEM!%APR!%MONID!%CPU!%MEMORY!%LOGMAX!%TTYMAX
	%INFL3==%LOAD!%RESPONSE!%UPTIME!%USERS!%SCHEDULE
	INFMSK==%INFL1!%INFL2!%INFL3


	DOSCAN	(SW)
	SUBTTL	.OSCAN ARGUEMENT BLOCK

;.OSCAN -- SUBROUTINE TO SCAN OPTIONS FILE (DSK:SWITCH.INI[,])
;	RETURNS CPOPJ AFTER UPDATING GLOBAL SWITCHES FROM FILE
;	THIS ROUTINE SHOULD BE CALLED AFTER TSCAN OR PSCAN
;		BUT BEFORE DEFAULTING.
;	CALL THIS ONLY AT END OF LINE.
;	IT SHOULD BE CALLED BETWEEN ISCAN AND VSCAN FOR VERBS.
;ARGS:	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES (IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=NAME OF OPTIONS TO SELECT IN FILE (0 IF NAME OF PROGRAM)
;			OR LENGTH,,LIST OF OPTION NAMES
;IF CALL FROM VSCAN, C(T3)= SAME AS BLOCK+4 ABOVE

OBLK:	OEND-OBLK0,,OBLK0		;LENGTH,,BLOCK
OBLK0:	IOWD	SWL,SWN			;POINT TO SWITCH NAMES
OBLK1:	SWD,,SWM			;DEFAULT SW,,PROCESSOR SW
OBLK2:	0,,SWP				;0,,SW POINTERS
OBLK3:	-1				;NO HELP FILE YET
OBLK4:	0				;SELECT OPTIONS=PROGRAM NAME
OEND:
	SUBTTL	DATA AREA

	.TOCTW			; Octal typeout
SetPrt:	.TDECW			; Decimal typeout
	.TSIXN			; Sixbit typeout

	IMPURE

ZCORE:				;START OF CORE TO ZERO ON RESET

PrtMod:	Block	1			; Holds typeout mode for above
DEVICE:	BLOCK	1			;DEVICE
LOGNAM:	BLOCK	1			;LOGICAL NAME
MMATCH:	BLOCK	1			;[101] Multi-match flag

SELOPT:	BLOCK	1			;OPTION SELECTED
OPTCNT:	BLOCK	1			;OPTION NESTING LEVEL COUNTER
SETCMD:	BLOCK	4			;STORAGE FOR SET CMD VALUES

OPTFUN:	BLOCK	1			;FUNCTION
OPTARG==OPTFUN+.FXNAM			;[64] THE OPTIONS TO SELECT
OPTMSK==OPTFUN+.FXNMM			;[110] NAME MASK FOR /PROGRAM
OPTPPN==OPTFUN+.FXDIR			;[64] THE OPTIONS PPN
OPTPPM==OPTFUN+.FXDIM			;[64] PPN MASK

FUNCTION:BLOCK	.FXLEN			;[64] .SET FUNCTION
ARG==	FUNCTION+.FXNAM			;[64]      ARG
FUNPPN==FUNCTION+.FXDIR			;[64]      PPN (for ALP)
FUNUSR==FUNCTION+.FXUSN			;[64]      USERNAME (pt 1)
FUNUS1==FUNCTION+.FXUSN+1		;[64]      USERNAME (pt 2)

LKBLOK:	block	.rbunm+2		;[50] .rbcnt :: .rbunm+1

LGNOPK:	BLOCK	3			;SPACE FOR OPENBLOCK
TT.NOP:	BLOCK	1			;NO - CODE
TT.IDX:	BLOCK	1			;INDEX HOLDER - TTY .... command
SET.NO:	Block	1			;[55] NO - Code
ST.IDX:	BLOCK	1			;[20] INDEX HOLDER - Set Command
PV.IDX:	Block	1			;[55] Privilage index
TRMBLK:					;[12]FOR TRMOP. UUO
TRMWHT:	BLOCK	1			;[12]TRMOP. CODE
TTYNO:	BLOCK	1			;[12]TTY UDX
TRMVAL:	BLOCK	1			;[12]TRMOP. VALUE
LINCHR:	BLOCK	1			;[12]TTY LINE CHARACTERISTICS
TTYNAM:	BLOCK	1			;[12]TTY LINE NAME (TTYNNN)
ifn tymcom,<
TymLog:	Block	1			;[62]Flag that GTLOG came from UPT
>
TTYNOD:	BLOCK	1			;[15]TTY NODE NUMBER (.GTNTN)
TTYLIN:	BLOCK	1			;[15]TTY LINE NUMBER (.GTNTN)
SPNODE:	BLOCK	1			;[15]NODENAME SPECIFIED
NODNAM:	BLOCK	1			;[15]NODE NAME IN SIXBIT
MYJOB:	BLOCK	1			;[12]MY JOB NUMBER
STRLTH:	BLOCK	1			;LENGTH OF STRLST
STRLST:	BLOCK	25			;PLENTY OF SPACE
UFDFLG:	BLOCK	1			;FLAG FOR UFD EXISTENCE
NOTES:	BLOCK	2			;/NOTIFY:(args)
INFOSW:	BLOCK	2			;/INFO:(args)
RSMODE:	BLOCK	1			;[105] Flag restricted/special mode
CNFNAM:	BLOCK	5			;[27] Configuration data
CNFEND:	Block	1			;[27] Zero word for .Tstrg of CNFNAM
GTAPRN:	BLOCK	1			;[76] System APR serial #
ifn tymcom,<
GTSYSN:	BLOCK	1			;[76] System # from GETTAB
GTSIDN:	BLOCK	1			;[76] Software serial number
TTY.OK:	BLOCK	1			;[25] First time flag for TTY stuff.
Tymaux:	Block	1			;[30] Aux Circuit flag
Chname:	Block	1			;[31] System number with "chr"
Syname:	Block	1			;[31] System number without "chr"
	> ; End ifn tymcom
EZCORE==.-1

	FIN	LOGON
 XABo