	SUBTTL	Routine to Move to a Location on the Screen


; This routine is called with the desired position to move to in AC's
; LN and CL, and the current terminal curser position in locations
; yy.LIN(P2) and yy.COL(P2).  The best way to move to the new position
; is calculated, and the curser is moved there that way.

TDMOVE:	CAMN	LN,yy.LIN(P2)		; Is the cursor where
	CAME	CL,yy.COL(P2)		;  it is needed?
	SKIPA	T1,[.WDINF]		; No, assume a lot of movement
	 POPJ	P,			; Finished return
	HRRZM	T1,BEST			; Save large number
	MOVEI	XX,[HALT]		; No movement possible!

	PUSHJ	P,CHKADR		; Addressing characters needs

	CAML	LN,yy.LIN(P2)		; Is the new location lower?
	TDZA	T1,T1			; Yes, downward movement
	MOVX	T1,^O1			; Upward movement
	CAMGE	CL,yy.COL(P2)		; Is the new location left?
	ORX	T1,^O2			; Yes, left movement
	PJRST	@MOVTAB(T1)		; Dispatch in the correct direction

MOVTAB:	MOVDR				; Move down and right
	MOVUR				; Move up and right
	MOVDL				; Move down and left
	MOVUL				; Move up and left



MOVDR:	PUSHJ	P,CHKDR			; See if down and right is faster
	PJRST	(T1)			; Get ther the fastest way possible

MOVDL:	PUSHJ	P,CHKDL			; See if down and left is faster
	PUSHJ	P,CHKCDR		; See if a carriage return helps
	SKIPN	xx.CRT(P1)		; Can the terminal do a <CR>?
	PUSHJ	P,CHKHDR		; No, see if homing ther terminal helps
	PJRST	(T1)			; Get ther the fastest way possible

MOVUR:	PUSHJ	P,CHKUR			; See if up and right is faster
	PUSHJ	P,CHKHDR		; See if homing the terminal helps
	PJRST	(T1)			; Get ther the fastest way possible

MOVUL:	PUSHJ	P,CHKUL			; See if up and left is faster
	PUSHJ	P,CHKHDR		; See if homing the terminal helps
	PUSHJ	P,CHKCUR		; See if a carriage return helps
	PJRST	(T1)			; Get ther the fastest way possible
; Following are the routines to see if a particular way of moving
; takes fewer characters than the preceeding ways.  Lowest number of
; characters is in address best, and routine which does that action
; is in XX.


; Routine to compute the cost of addressing.  This routine knows it
; is the first routine called.

CHKADR:	SKIPN	T1,xx.ADR(P1)		; Is addressing is possible?
	 POPJ	P,			; No, finished
	TRNE	F,yy%ANS		; ANSI mode addressing used?
	JRST	ANSICK			; Yes, different computations
*******
	ADD	T1,T.ADR2(U)	;ADD IN MORE CHARACTERS
	ADD	T1,T.ADR3(U)	;AND ADD IN MORE CHARS
	ADDX	T1,^D2		;THEN ADD 2 CHARS FOR COORDINATES
CHKADF:	MOVEM	T1,BEST		;REMEMBER NUMBER OF CHARS NEEDED
	MOVEI	XX,DOADR	;SET UP ADDRESS FOR ADDRESSING
	POPJ	P,		;RETURN


ANSICK:	MOVEI	T1,1(N)		;GET COLUMN NUMBER
	PUSHJ	P,COLADD	;ADD IN DEPENDING ON SIZE
	MOVEI	T1,1(L)		;GET LINE NUMBER
	PUSHJ	P,COLADD	;ADD IN DEPENDING ON SIZE
	SKIPE	N		;ANY COLUMN?
	ADDI	T2,1		;YES, WILL NEED A SEMICOLON
	MOVEI	T2,1(T2)	;ACCOUNT FOR ENDING CHAR AND CLEAR JUNK
	JRST	CHKADF		;FINISH UP


COLADD:	CAIL	T1,^D100	;THREE DIGITS?
	ADDI	T2,1		;YES, COUNT IT
	CAIL	T1,^D10		;TWO DIGITS?
	ADDI	T2,1		;YES, COUNT IT
	CAIL	T1,2		;NEED ANY DIGITS?
	ADDI	T2,1		;YES, COUNT IT
	POPJ	P,		;DONE

;ROUTINE TO COMPUTE COST OF MOVING UP AND LEFT.


CHKUL:	SKIPE	T3,T.UP(U)	;CAN WE MOVE UP?
	SKIPN	T4,T.LEFT(U)	;AND CAN WE MOVE LEFT?
	  POPJ	P,		;NO, CAN'T DO THIS THEN
	MOVE	T2,TTYL(X)	;GET CURRENT LINE
	SUB	T2,L		;SUBTRACT DESIRED LINE
CHKANL:	IMULI	T2,(T3)		;COMPUTE CHARS NEEDED TO MOVE UP
	MOVE	T3,TTYN(X)	;GET CURRENT COLUMN
	SUB	T3,N		;AND SUBTRACT DESIRED COLUMN
CHKANY:	IMULI	T3,(T4)		;COMPUTE CHARS NEEDED TO MOVE LEFT
	MOVEI	T4,DOANY	;SET UP ROUTINE TO DO ACTION

CHKALL:	ADD	T2,T3		;ADD TOGETHER
	CAML	T2,BEST		;BETTER THAN OLD BEST?
	  POPJ	P,		;NO, RETURN
	MOVEM	T2,BEST		;YES, SAVE NUMBER
	MOVE	T1,T4		;AND ROUTINE TO DO IT
	MOVE	T4,TABNUM	;GET NUMBER OF TABS THAT WILL BE USED
	MOVEM	T4,TABUSE	;AND SET IT
	POPJ	P,		;RETURN

;ROUTINE TO COMPUTE COST OF MOVING DOWN AND LEFT.


CHKDL:	SKIPN	T3,T.DOWN(U)	;CAN WE MOVE DOWN?
	CAMN	L,TTYL(X)	;NO, BUT OK IF DON'T HAVE TO
	SKIPN	T4,T.LEFT(U)	;CAN WE MOVE LEFT TOO?
	  POPJ	P,		;NO, RETURN
	MOVE	T2,L		;GET DESIRED LINE NUMBER
	SUB	T2,TTYL(X)	;SUBTRACT PRESENT LINE
	JRST	CHKANL		;JOIN OTHER CODE




;ROUTINE TO COMPUTE COST OF MOVING DOWN AND RIGHT.


CHKDR:	SKIPN	T.DOWN(U)	;SEE IF CAN MOVE DOWN
	CAMN	L,TTYL(X)	;OR SEE IF DON'T NEED TO
	JRST	.+2		;OK, PROCEED
	  POPJ	P,		;CAN'T DO THIS, RETURN
	PUSHJ	P,CHKTAB	;COMPUTE COUNT FOR MOVING RIGHT
	MOVE	T3,L		;GET LINE TO MOVE TO
	SUB	T3,TTYL(X)	;SUBTRACT CURRENT LINE
	MOVE	T4,T.DOWN(U)	;GET NUMBER NEEDED TO GO DOWN
	JRST	CHKANY		;JOIN COMMON CODE




;ROUTINE TO COMPUTE COST OF MOVING UP AND RIGHT.


CHKUR:	SKIPN	T.UP(U)		;SEE IF WE CAN MOVE UP
	  POPJ	P,		;NO, RETURN
	PUSHJ	P,CHKTAB	;YES, COMPUTE COUNT FOR MOVING RIGHT
	MOVE	T3,TTYL(X)	;GET CURRENT LINE
	SUB	T3,L		;SUBTRACT DESTINATION LINE
	MOVE	T4,T.UP(U)	;GET CHARS NEEDED TO GO UP
	JRST	CHKANY		;JOIN OTHER CODE

;ROUTINE TO COMPUTE COST OF HOMING UP, THEN MOVING DOWN AND RIGHT.


CHKHDR:	SKIPN	T.DOWN(U)	;MAKE SURE WE CAN MOVE DOWN
	CAMN	L,TTYL(X)	;OR THAT WE DON'T HAVE TO
	SKIPN	T.HOM(U)	;AND MAKE SURE WE CAN HOME UP
	  POPJ	P,		;NO, THEN CAN'T DO THIS
	PUSH	P,TTYN(X)	;SAVE CURRENT POSITION
	SETZM	TTYN(X)		;CLEAR POSITION AS IF HOME WAS DONE
	PUSHJ	P,CHKTAB	;SEE HOW MANY TO MOVE RIGHT
	POP	P,TTYN(X)	;RESTORE TRUE COLUMN NUMBER
	MOVE	T3,T.HOM(U)	;GET CHARS NEEDED FOR CARRIAGE RETURN
	ADDI	T2,(T3)		;ADD INTO TOTAL
	HRRZ	T3,T.DOWN(U)	;GET CHARS NEEDED TO DO DOWN
	IMULI	T3,(L)		;MULTIPLY BY DESTINATION LINE
	MOVEI	T4,DOHDR	;GET ROUTINE FOR THIS ACTION
	JRST	CHKALL		;GO SEE IF THIS IS BEST



;ROUTINE TO COMPUTE COST OF DOING CR, THEN MOVING DOWN AND RIGHT.


CHKCDR:	SKIPN	T.DOWN(U)	;CAN WE MOVE DOWN?
	CAMN	L,TTYL(X)	;OR WE DON'T HAVE TO?
	SKIPN	T.CR(U)		;AND CAN WE DO A CARRIAGE RETURN?
	  POPJ	P,		;NO, RETURN
	PUSH	P,TTYN(X)	;SAVE CURRENT POSITION
	SETZM	TTYN(X)		;CLEAR POSITION AS IF A CR WAS DONE
	PUSHJ	P,CHKTAB	;AND COMPUTE COUNT FOR MOVING RIGHT
	POP	P,TTYN(X)	;RESTORE TRUE COLUMN NUMBER
	MOVE	T3,T.CR(U)	;GET CHARS USED FOR CARRIAGE RETURN
	ADDI	T2,(T3)		;ADD IT IN
	MOVE	T3,L		;GET DESTINATION LINE
	SUB	T3,TTYL(X)	;AND SUBTRACT CURRENT ONE
	MOVE	T4,T.DOWN(U)	;GET CHARS NEEDED TO MOVE DOWN
	IMULI	T3,(T4)		;FIND TOTAL CHARS TO MOVE DOWN
	MOVEI	T4,DOCDR	;GET ROUTINE TO DO ACTION
	JRST	CHKALL		;SEE IS THIS IS BEST METHOD

;ROUTINE TO COMPUTE COST OF DOING CARRIAGE RETURN, THEN UP AND RIGHT.


CHKCUR:	SKIPE	T.CR(U)		;SEE IF CAN DO CARRIAGE RETURN
	SKIPN	T.UP(U)		;AND SEE IF CAN GO UP
	  POPJ	P,		;NO, RETURN
	PUSH	P,TTYN(X)	;SAVE CURRENT COLUMN
	SETZM	TTYN(X)		;ASSUME WE DID A CARRIAGE RETURN
	PUSHJ	P,CHKTAB	;SEE HOW MANY TO MOVE RIGHT
	POP	P,TTYN(X)	;RESTORE TRUE COLUMN
	MOVE	T3,T.CR(U)	;GET CHARS NEEDED FOR CR
	ADDI	T2,(T3)		;ADD IN
	MOVE	T3,TTYL(X)	;GET CURRENT LINE NUMBER
	SUB	T3,L		;SUBTRACT DESTINATION LINE
	MOVE	T4,T.UP(U)	;GET COUNT TO MOVE UP
	IMULI	T3,(T4)		;FIND TOTAL CHARS NEEDED TO MOVE DOWN
	MOVEI	T4,DOCDR	;GET ROUTINE TO DO ACTION
	JRST	CHKALL		;AND SEE IF THIS IS BEST

;ROUTINE TO COMPUTE COST OF MOVING RIGHT.
;THIS IS A SUBROUTINE CALLED BY THE PREVIOUS ROUTINES.
;IT SAVES THE NUMBER OF TABS NEEDED FOR LATER.
;RETURNS WITH TOTAL CHARS NEEDED IN AC T2.


CHKTAB:	SETZB	T2,TABNUM	;CLEAR NUMBER OF TABS NEEDED
	CAMN	N,TTYN(X)	;ALREADY AT CORRECT COLUMN?
	  POPJ	P,		;YES, RETURN NOW
	TRNN	F,FR.TAB	;DOES THIS TERMINAL HAVE TABS?
	  JRST	CHKSPS		;NO, JUST MOVE RIGHT
	MOVE	T2,N		;GET COLUMN WE DESIRE TO GET TO
	IORI	T2,7		;MOVE TO FAR RIGHT OF TAB COLUMN
	SUB	T2,TTYN(X)	;SUBTRACT CURRENT POSITION
	LSH	T2,-3		;COMPUTE NUMBER OF TABS NEEDED
	MOVEM	T2,TABNUM	;SAVE NUMBER OF TABS NECESSARY
	TRNN	N,7		;GOING TO EXACT TAB STOP?
	  POPJ	P,		;YES, ALL DONE
	JUMPE	T2,CHKTBN	;JUMP SOME IF USING NO TABS
	MOVE	T3,N		;GET COLUMN MOVING TO
	TRZA	T3,7		;BACK UP TO PREVIOUS TAB STOP
CHKTBN:	MOVE	T3,TTYN(X)	;IF NO TABS, GET CURRENT POSITION
	MOVE	T2,N		;GET COPY OF POSITION
	SUB	T2,T3		;COMPUTE NUMBER OF SPACES NEEDED
	SKIPN	T4,T.LEFT(U)	;CAN WE GO LEFT?
	  JRST	CHKSPT		;NO, THEN ALWAYS MOVE RIGHT
	MOVEI	T3,^D10(N)	;GET COLUMN POSITION PLUS SOME
	CAMLE	T3,T.WID(U)	;GETTING NEAR END OF SCREEN?
	  JRST	CHKSPT		;YES, THEN CAN'T TAB AND BACK UP
	MOVE	T3,N		;GET COLUMN TO MOVE TO
	IORI	T3,7		;MOVE TO FAR RIGHT OF COLUMN
	SUBI	T3,-1(N)	;COMPUTE COLUMNS TO BACK UP BY
	IMULI	T3,(T4)		;MULTIPLY BY CHARS TO BACK UP 1 PLACE
	ADDI	T3,1		;ADD A CHAR DUE TO THE TAB
	CAML	T3,T2		;TAKES LESS CHARS TO BACK UP?
	  JRST	CHKSPT		;NO, GO USE SPACES
	AOS	T2,TABNUM	;YES, INCREMENT TAB COUNT
	ADDI	T2,-1(T3)	;ADD CHARS NEEDED TO BACKSPACE
	POPJ	P,		;AND RETURN


CHKSPS:	MOVE	T2,N		;GET COLUMN TO MOVE TO
	SUB	T2,TTYN(X)	;SUBTRACT COLUMN WE ARE AT
CHKSPT:	ADD	T2,TABNUM	;ADD IN TABS NEEDED
	POPJ	P,		;THEN RETURN

	SUBTTL	ROUTINES TO MOVE SLOWLY TO A LOCATION



;THESE ROUTINES ARE CALLED WITH THE COLUMN AND LINE NUMBERS IN N AND L,
;AND THE CURRENT POSITION IN TTYN AND TTYL.  THE ROUTINE MOVES THE
;CURSOR LEFT, RIGHT, UP, OR DOWN TO GET THERE.



DOHDR:	PUSHJ	P,DOHOM		;HOME UP
	JRST	DOANY		;THEN GO TO NORMAL CODE

DOCDR:	PUSHJ	P,DOCR		;DO A CARRIAGE RETURN FIRST
				;THEN FALL INTO NORMAL CODE



DOANY:	CAMN	L,TTYL(X)	;ALREADY AT RIGHT LINE?
	  JRST	MOVCOL		;YES, GO CHECK COLUMN
	CAMG	L,TTYL(X)	;WANT TO MOVE DOWN?
	  JRST	MOVUP		;NO, GO MOVE UP

MOVDWN:	PUSHJ	P,DODOWN	;YES, MOVE THAT WAY
	CAME	L,TTYL(X)	;AT RIGHT COLUMN YET?
	  JRST	MOVDWN		;NO, KEEP GOING
	JRST	MOVCOL		;YES, NOW CHECK COLUMN

MOVUP:	PUSHJ	P,DOUP		;MOVE UP
	CAME	L,TTYL(X)	;AT RIGHT LINE YET?
	  JRST	MOVUP		;NO, KEEP LOOKING





MOVCOL:	CAMLE	N,TTYN(X)	;WANT TO MOVE TO RIGHT?
	  JRST	MOVRHT		;YES, GO DO IT
MOVLFT:	CAMN	N,TTYN(X)	;AT RIGHT COLUMN YET?
	  POPJ	P,		;YES, RETURN
	PUSHJ	P,DOLEFT	;NO, GO LEFT
	JRST	MOVLFT		;AND CHECK AGAIN

MOVRHT:	SKIPN	T3,TABUSE	;ANY TABS USED TO MOVE RIGHT?
	  JRST	MOVSPS		;NO, GO USE SPACES
	PUSHJ	P,DOTAB		;YES, OUTPUT A TAB
	SOJG	T3,.-1		;LOOP UNTIL DID THEM ALL
	CAML	N,TTYN(X)	;DID WE TAB BEYOND DESTINATION?
	  JRST	MOVSPS		;NO, GO FINISH WITH SPACES

MOVBCK:	PUSHJ	P,DOLEFT	;YES, MOVE LEFT
	CAMN	N,TTYN(X)	;REACHED DESTINATION?
	  POPJ	P,		;YES, ALL DONE
	JRST	MOVBCK		;NO, KEEP GOING


MOVSPS:	CAMN	N,TTYN(X)	;AT DESTINATION YET?
	  POPJ	P,		;YES, RETURN
	MOVE	T1,TTYL(X)	;GET CURRENT LINE
	IMUL	T1,T.WRDS(U)	;MULTIPLY BY WORDS PER LINE
	MOVE	T2,TTYN(X)	;GET CURRENT COLUMN
	IDIVI	T2,4		;DIVIDE BY CHARS TO A WORD
	ADD	T2,T1		;ADD IN WORDS INTO THIS LINE
	ADD	T2,PNTTAB(T3)	;MAKE A BYTE POINTER
MOVSPL:	ILDB	C,T2		;GET CHAR AT THIS POSITION
	PUSHJ	P,DOONE		;OUTPUT IT
	CAME	N,TTYN(X)	;REACHED RIGHT PLACE YET?
	  JRST	MOVSPL		;NO, KEEP GOING
	POPJ	P,		;YES, DONE

	SUBTTL	SUBROUTINE TO ADDRESS



;CALLED WITH NEW X AND Y COORDINATES IN AC'S N AND L, TO ADDRESS TO
;THAT POSITION.  CAN ONLY BE CALLED FOR TERMINALS CAPABLE OF DOING
;ADDRESSING.





DOADR:	DMOVEM	L,TTYL(X)	;SET NEW TERMINAL CURSOR POSITION
	MOVE	T1,T.ADR(U)	;GET SEQUENCE TO START
	PUSHJ	P,SEQOUT	;OUTPUT IT
	TRNE	F,FR.ANS	;ANSI STYLE TERMINAL?
	JRST	ANSIAD		;YES, ADDRESSING DIFFERS
	HRRZ	T3,N		;GET POSITION ON LINE TO GO TO
	ADD	T3,T.XOFF(U)	;ADD IN OFFSET FOR OUTPUT
	HRRZ	C,L		;GET LINE NUMBER TO GO TO
	ADD	C,T.YOFF(U)	;ADD IN ITS OFFSET ALSO
	TRNE	F,FR.XBY	;SHOULD X COORDINATE BE FIRST?
	EXCH	C,T3		;YES, SWAP THE COORDINATES
	PUSHJ	P,TTYOUT	;OUTPUT THE FIRST COORDINATE
	SKIPE	T1,T.ADR2(U)	;ANY FILLER BETWEEN COORDINATES?
	PUSHJ	P,SEQOUT	;YES, OUTPUT THAT
	MOVE	C,T3		;GET SECOND COORDINATE
	PUSHJ	P,TTYOUT	;OUTPUT IT
	SKIPE	T1,T.ADR3(U)	;ANY FILLS AFTER COORDINATE?
	JRST	SEQOUT		;YES, GO GIVE IT AND RETURN
	POPJ	P,		;NO, ALL DONE



ANSIAD:	SKIPE	T1,L		;ANY LINE POSITION?
	PUSHJ	P,DECOU1	;YES, OUTPUT IT
	JUMPE	N,ANSIAE	;SKIP SOME IF AT FIRST COLUMN
	MOVEI	C,";"		;GET SEPARATOR CHAR
	PUSHJ	P,TTYOUT	;OUTPUT IT
	MOVE	T1,N		;GET COLUMN
	PUSHJ	P,DECOU1	;OUTPUT IT
ANSIAE:	MOVEI	C,"H"		;GET ENDING CHAR
	JRST	TTYOUT		;OUTPUT IT

	SUBTTL	SPECIAL SEQUENCE OUTPUT ROUTINES




;HERE TO OUTPUT SPECIAL SEQUENCES OF CHARACTERS FOR A TERMINAL.
;THESE ROUTINES KEEP THE VALUES OF TTYN AND TTYL CORRECT.
;THESE ROUTINE CAN USE T1, T2, AND C.




DOTAB:	MOVEI	C,7		;GET SET
	IORM	C,TTYN(X)	;SET TO FAR RIGHT OF CURRENT COLUMN
	AOS	TTYN(X)		;THEN MOVE TO NEXT TAB STOP
	MOVEI	C,TAB		;GET A TAB CHARACTER
	PJRST	TTYOUT		;OUTPUT IT AND RETURN



DOEOL:	MOVE	T3,LSTNON	;GET LOCATION OF LAST NONSPACE
	CAMGE	T3,LSTCHG	;IS LAST CHANGE BEYOND THAT?
	MOVE	T3,LSTCHG	;YES, GET THAT LOCATION
	SUB	T3,TTYN(X)	;GET NUMBER OF SPACES TO CLEAR LINE
	ADDI	T3,1		;ADD ONE MORE
	SKIPE	T1,T.EOL(U)	;GET SEQUENCE TO DO END OF LINE
	CAIGE	T3,(T1)		;AND SEE IF FASTER TO TYPE SPACES
	SKIPA	C,[SP]		;YES, GET A SPACE
	  PJRST	SEQOUT		;NO, FASTER TO DO END OF LINE SEQUENCE
	PUSHJ	P,DOONE		;OUTPUT A SPACE
	SOJG	T3,.-1		;LOOP REQUIRED TIMES
	POPJ	P,		;THEN RETURN


DOUP:	SOSA	TTYL(X)		;DECREMENT TERMINAL'S LINE NUMBER
DODOWN:	AOSA	TTYL(X)		;OR INCREMENT LINE NUMBER
	SKIPA	T1,T.UP(U)	;THEN GET SEQUENCE TO MOVE UP
	MOVE	T1,T.DOWN(U)	;OR SEQUENCE TO MOVE DOWN
	JRST	SEQOUT		;GO OUTPUT IT


DOCR:	SETZM	TTYN(X)		;CLEAR COLUMN USER SEES CURSER AT
	MOVE	T1,T.CR(U)	;GET SEQUENCE TO DO CR
	JRST	SEQOUT		;GO OUTPUT IT

DOLEFT:	SOSA	TTYN(X)		;DECREMENT COLUMN NUMBER
DORHT:	AOSA	TTYN(X)		;OR INCREMENT IT
	SKIPA	T1,T.LEFT(U)	;GET SEQUENCE TO MOVE LEFT
	MOVE	T1,T.RHT(U)	;OR SEQUENCE TO MOVE RIGHT
	JRST	SEQOUT		;OUTPUT IT AND RETURN



DOONE:	CAIN	C,SP		;OUTPUTTING A SPACE?
	MOVE	C,T.EATC(U)	;YES, CONVERT TO EATING CHAR
	AOS	T1,TTYN(X)	;INCREMENT COLUMN NUMBER
	CAMG	T1,T.WID(U)	;AT LAST COLUMN ON LINE?
	  JRST	TTYOUT		;NO, JUST OUTPUT CHAR AND RETURN
	SOS	TTYN(X)		;YES, BACK UP POSITION
	TRNN	F,FR.ELC	;GET A CRLF TYPING LAST COLUMN?
	  JRST	TTYOUT		;NO, THEN TYPE THE CHAR AND RETURN
	MOVE	T1,TTYL(X)	;GET CURRENT LINE
	CAML	T1,T.LEN(U)	;ON LAST LINE?
	  POPJ	P,		;YES, DON'T TYPE CHAR OR ELSE SCREEN SCROLLS!
	SETZM	TTYN(X)		;NO, CLEAR COLUMN
	AOS	TTYL(X)		;INCREMENT LINE NUMBER
	PJRST	TTYOUT		;THEN OUTPUT CHARACTER



DOCLR:	SKIPA	T1,T.CLR(U)	;GET SEQUENCE TO HOME AND CLEAR
DOHOM:	MOVE	T1,T.HOM(U)	;OR GET SEQUENCE TO JUST HOME
	SETZM	TTYL(X)		;RESET LINE POSITION USER SEES
	SETZM	TTYN(X)		;AND THE COLUMN POSITION
;	PJRST	SEQOUT		;GO OUTPUT IT

	SUBTTL	ROUTINES TO OUTPUT SEQUENCES OF CHARACTERS




;THIS ROUTINE IS CALLED WITH THE STANDARD POINTER TO A SEQUENCE OF
;CHARACTERS TO BE OUTPUT IN AC T1.  SUCH A POINTER IS OF THE FORM
; ADDR,,N  WHERE N IS THE NUMBER OF CHARACTERS IN THE STRING, AND
;ADDR IS THE ADDRESS OF THE STRING.




SEQOUT:	HLRZ	T2,T1		;GET ADDRESS OF STRING
	HRLI	T2,(POINT 7,)	;AND MAKE BYTE POINTER TO IT
	ANDI	T1,-1		;KEEP ONLY COUNT
	JUMPE	T1,[DIE CDS]	;IF NO CHARS, DIE

SEQOUL:	ILDB	C,T2		;GET NEXT CHARACTER IN SEQUENCE
	SOJLE	T1,TTYOUT	;IF LAST CHAR, GO OUTPUT AND RETURN
	PUSHJ	P,TTYOUT	;OUTPUT TO TERMINAL
	JRST	SEQOUL		;LOOP





;CALLED TO OUTPUT A DECIMAL NUMBER IN T1.  USED FOR ANSI MODE ADDRESSING,
;WHERE COORDINATES ARE DECIMAL INTEGERS.


DECOU1:	ADDI	T1,1		;COORDINATES ARE OFFSET BY ONE
DECOUT:	IDIVI	T1,^D10		;SPLIT OFF A DIGIT
	JUMPE	T1,DECFIN	;JUMP IF DONE
	HRLM	T2,(P)		;SAVE DIGIT
	PUSHJ	P,DECOUT	;LOOP UNTIL HAVE ALL DIGITS
	HLRZ	T2,(P)		;GET BACK A DIGIT
DECFIN:	MOVEI	C,"0"(T2)	;MAKE INTO ASCII
	JRST	TTYOUT		;OUTPUT IT AND RETURN
    