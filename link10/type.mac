	TITLE	TYPE	Program to type out files
	SUBTTL	Edward C. Mulrean	3-Dec-75

	SALL

	SEARCH	ECM12,MACTEN,JOBDAT,UUOSYM,SCNMAC

	VERSION	TYP,1F(73)-6

	EXTERN	.SWDEC,.TNEWL

ND	.RBLEN,32		;LENGTH OF INPUT FILE LOOKUP BLOCK
ND	AD.WLD,0		;DEFAULT TO /NOWILD (1 FOR /WILD)
ND	TXTSIZ,100		;[16]DEFAULT SIZE OF TEXT BUFFER
ND	TMPMAX,20		;[32]MAXIMUM # OF TMPCOR FILES IN DIRECTORY
ND	TMFMAX,100		;[32]MAXIMUM # OF WORDS IN A TMPCOR FILE
ND	FT$PIP,0		;[55] NON-ZERO TO ACCEPT /J AND /N SWITCHES

ND	TYMCOM,-1		;[TYM-1] Default this version to TYMCOM-X
IFN	TYMCOM,<TOPS==4		;[TYM-1] And attempt to use defaults
	Opdef	Auxcal	[42b8]	;[TYM-1] Auxport UUO
	Opdef	Chanio	[43b8]	;[TYM-1] Channel UUO
	.Axwid==27		;[TYM-1] Width trmop.
	Lc.HHT==1b14		;[TYM-1] GET/SETlch Hardware Tabs
	.Chfsi==27		;[TYM-2] USETI replacement for gtr 777777
	.Chfso==30		;[TYM-2] USETO replacement for gtr 777777
	> ; End IFN TYMCOM
ND	TOPS,10			;[72] Default to TOPS-10 TYPE Set to 20 for -20

	ICHAN==1		;INPUT FILE I/O CHANNEL
	OCHAN==2		;OUTPUT FILE I/O CHANNEL

;	PERMANENT AC USAGE DURING FILE PROCESSING
;
;	P1	- POINTS TO SCAN BLOCK
;	P2	- FILE MODE WORD ONE
;	P3	- LINE COUNTER FOR PAGING
;	P4(C)	- USED TO INPUT CHARACTERS

	.REQUEST	SYS:SCAN
	.REQUEST	SYS:WLD7A
	.REQUEST	SYS:ENDECR
	.REQUEST	SYS:HELPER
	.REQUEST	DSK:ERROR

	.TWOSEG

	ENTRY	TYPE
	SUBTTL	Revision history

; Edit	  Date		Reason
; ----	  ----		------
;   10	14-Jan-76	Use new universal file and SCN7B
;   11	14-Jan-76	Don't allow multiple form-feeds in paging mode
;   12	14-Jan-76	Implement /COBOL (reading COBOL SIXBIT files)
;   13	15-Jan-76	Implement /FORTRAN (interpret FORTRAN carriage controls)
;   14	16-Jan-76	Check for and skip header record on COBOL SIXBIT files
;   15	16-Jan-76	Interpret FORTRAN carriage control '*' properly
;   16	19-Jan-76	Implement the /HEADER switch
;   17	19-Jan-76	Fix bug so output can go to a PTY
;   20	19-Jan-76	Default a width of 132. on non-TTY devices
;   21	21-Jan-76	Fix /BSTART which broke when /NAME was added
;
;	%1A(21)		Release for use on 21-Jan-76
;
;   22	04-Feb-76	Implement the /CRYPT switch for encrypted files
;   23	05-Feb-76	Implement the /APPEND switch for disk output files
;   24	05-Feb-76	Recognize special pseudo device TMPCOR
;   25	05-Feb-76	Implement /OKBINARY, /ERBINARY, and /SKBINARY switches
;   26	09-Feb-76	Implement the MagTape positioning commands
;
;	%1B(26)		Release for use on 24-Feb-76
;
;   27	24-Feb-76	Add error message if input device can't do input
;   30	24-Feb-76	Fully implement /WIDTH checking and /TRUNCATE
;   31	01-Mar-76	More fixes for /WIDTH & /TRUNCATE switches
;   32	02-Mar-76	Implement ability to type out TMPCOR: files
;   33	02-Mar-76	Fix up TMPCOR error messages
;   34	02-Mar-76	Implement /OCTAL file dumping switch
;   35	04-Mar-76	Implement /ALTMODE and /BELL
;   36	09-Mar-76	Allow output to goto dectape (short LOOKUP block)
;   37	09-Mar-76	Implement the /IMAGE switch
;   40	10-Mar-76	Implement the /SEQUENCE switch processing
;   41	10-Mar-76	Implement /LSUPPRESS, /SPACING, and /INDENT
;   42	12-Mar-76	Implement the /COLUMN switch processing
;
;	%1C(42)		Release for use on 15-Mar-76
;
;   43	17-Mar-76	Check file creation/access time and length constraints
;   44	22-Apr-76	Minor fixup to use new error processors
;   45	02-Jul-76	Use WILD %7A and search SYS: after NEW:
;   46	02-Jul-76	Multiplex top of page wait with skipping
;   47	02-Jul-76	Fix up not enough core error message return
;
;	%1D(47)		Release for use on 09-Jul-76
;
;   50	16-Mar-77	Make /TABS global & default to /NOTABS unless output TTY set TABS
;   51	16-Mar-77	Add error message if output device can't do output
;   52	16-Mar-77	If both /OCTAL & /SKBINARY, ignore /SKBINARY
;   53	16-Mar-77	Implement /BUFFERS to allocate I/O buffers
;   54	18-Mar-77	Implement /PAUSE switch to wait for each form
;   55	30-Mar-77	Add FT$PIP conditional to accept /N and ignore /J
;   56	30-Mar-77	Only treat TTY as a line mode device
;   57	30-Mar-77	If no wildcards in 1st input name, use as output name else 'TYPE'
;   60	30-Mar-77	Only output extra trailing CR-LF if to attached TTY
;   61	30-Mar-77	Add binary extension .UNV to table
;   62	05-Jan-78	Change /FORM to /BREAKSIZE for future QUASAR FORMS support
;
;	%1E(62)		Released 5-Jan-78
;
;   63	06-Jul-78	Do ENTER on LPT: output to set spool name for QUASAR/QUEUE
;   64	25-May-79	Allow /PAUSE to work with /IMAGE mode output
;   65	25-May-79	Correct typo in applying sticky switches
;   66	25-May-79	Clear type-ahead when pausing (in case user type multi-char last pause)
;   67	17-Oct-79	Fix /BREAKSIZE:0 to not do a /BREAKSIZE:1 if sub-page
;   70	18-Oct-79	Only require filename for input from directory devices
;   71  17-Apr-80       Change extension MSG to MSB in binary ext table
;
;       %1F(71)         Released 17-Apr-80
;
;   72	07-May-80	Add TOPS-20 feature test and avoid IONDX. if -20 version
;   73	07-May-80	Make TYPE look for a ETYPE command if -20 version
;
; TYM-1	05-Feb-81	Add TYMCOM feature for TYMCOM-X monitor, avoid fancy
;			TOPS-10 style features, for now.
; TYM-2	19-Mar-82	Fix some minor problems with USETI/O, Dates, etc.
; TYM-3 11-Jun-83	Add /SIXBIT and /KATAKANA switches.
; TYM-4 23-Sep-83	Add /DEVICE:LA50 and /PITCH switches.
; TYM-5 19-Dec-85	Fix /KATAKANA switch to always set 9-bit bytes.
; TYM-6	20-Dec-85	Add KEYS for /DEV:(TTY,LA50,TI820,SCANSET,ADM11P)
;

	SUBTTL	OFFSETS FOR USER F.XXX AND P.XXX AREAS

$FXMD1== 0		;MODE WORD ONE
$FXMM1== 1		;MODE MASK FOR MODE WORD 1
$FXMD2== 2		;MODE WORD TWO
$FXMM2== 3		;MODE MASK FOR MODE WORD 2
$FXMD3== 4		;[TYM-4] MODE WORD THREE
$FXMM3== 5		;[TYM-4] MODE MASK FOR MODE WORD 3
$FXBST== 6		;/BSTART & FIRST  PART OF /BRANGE
$FXBEN== 7		;/BEND   & SECOND PART OF /BRANGE
$FXPST==10		;/PSTART & FIRST  PART OF /PRANGE
$FXPEN==11		;/PEND   & SECOND PART OF /PRANGE
$FXLST==12		;/LSTART & FIRST  PART OF /LRANGE
$FXLEN==13		;/LEND   & SECOND PART OF /LRANGE
$FXNBL==14		;/NBLOCKS
$FXNPG==15		;/NPAGES
$FXNLN==16		;/NLINES
$FXHDR==17		;[16]/HEADER
$FXCRP==20		;[22]/CRYPT
$FXMFL==21		;[26]/SKFILES/BKFILES
$FXMRC==22		;[26]/SKRECORDS/BKRECORDS
	$FXSIZ==23	;SIZE OF BLOCK


	SUBTTL	BIT POSITION MASKS FOR $FXMD1 & $FXMM1

FX$NAM==  1B0		;/NAME
FX$SEQ==  1B1		;/SEQUENCE
FX$PIP==  1B2		;[55] /J (DUMMY)
FX$SUP==  1B3		;/SUPPRESS
FX$LSP==  1B4		;/LSUPPRESS
FX$EBC==  1B5		;/EBCDIC
FX$COB==  1B6		;/COBOL
FX$FOR==  1B7		;/FORTRAN
FX$OCT==  1B8		;/OCTAL
FX$REW==  1B9		;/REWIND
FX$EOT==  1B10		;/EOT
FX$TRN==  1B11		;/TRUNCATE
FX$ACC==  1B12		;/ACCESS
FX$ENM==  1B13		;/ENAME
FX$LPT==  1B14		;/LPT
FX$FSF==  1B15		;/FAILSA
FX$BEL==  1B16		;[35]/BELL
FX$ALT==  1B17		;[35]/ALTMODE
FX$BIN==  3B19		;/ERBINARY,/OKBINARY,/SKBINARY
FX$SPC==  3B21		;/SPACING:XXX
FX$SIX==  1B22		;[TYM-3] /SIXBIT
FX$KAT==  1B23		;[TYM-3] /KATAKANA
FX$WID==377B35		;/WIDTH:N [TYM-3,4] Field is (b28-b35)

FX$BYT==  FX$COB!FX$OCT!FX$SIX!FX$KAT	;[TYM-3] BYTE MODES

F1$SPC==<<FX$SPC/2>&FX$SPC>	;[TYM-4] /SPACING DEFAULT
F1$SET==FX$SUP!FX$SEQ!F1$SPC	;[40,41,50,TYM-4] DEFAULT BITS TO SET

	SUBTTL	BIT POSITION MASKS FOR $FXMD2 & $FXMM2

FX$IND== 77B5		;/INDENT:N
FX$COP== 77B11		;/COPIES:N
FX$BUF== 77B17		;[53] /BUFFERS:N
FX$CL1==777B26		;/COLUMN:N:M
FX$CL2==777B35		;...


	SUBTTL	BIT POSITION MASKS FOR $FXMD3 & $FXMM3

FX$HZP==  7B32		;[TYM-4] /HPITCH:XXX  /PITCH:XXX:YYY
FX$VTP==  7B35		;[TYM-4] /VPITCH:YYY

	SUBTTL	SWITCH VALUE DEFAULTS

DM	DEV,     77,      0,      0
DM	HZP,      7,      0,      4
DM	VTP,      7,      0,      4
DM	WID,  ^D200,   ^D72,  ^D132
DM	PGS,    777,   ^D66,   ^D66
DM	FRM,     77,      6,      6
DM	PSB,     77,      0,      3
DM	PSS,   ^D60,      0,   ^D15
DM	IND,     77,      0,    ^D8
DM	COL, 777777,      0,      0
DM	COP,     77,      1,      1
DM	RNB, 377777,      1,      1
DM	RNE, 377777, 377777, 377777
DM	NUM, 377777, 377777,      1
DM	TXT,    777,      1,      1
DM	MTO, 377777,      0,      1
DM	MTN, 777777,      0,      1
DM	HDR, 377777,      0,      0
DM	BUF,     77,      0,      0


	SUBTTL	INTERNAL FLAG BIT DEFINITIONS

				;LEFT HALF
F.OIU==1B0			;OUTPUT FILE IN USE
F.TTY==1B1			;OUTPUT DEVICE IS A TTY
F.TTA==1B2			;OUTPUT DEVICE IS ATTATCHED TTY
F.LMD==1B3			;OUTPUT DEVICE IS LINE MODE DEVICE
F.TOP==1B4			;SET IF AT TOP OF A PAGE
F.SPC==1B5			;SET IF PROCESSING MULTI SPACES
F.PAG==1B6			;SET IF PAGINATION REQUIRED
F.REC==1B7			;[12]SET IF COBOL SIXBIT RECORD BEING PROCESSED
F.NUL==1B8			;[13]SET TO ALLOW NULLS ON INPUT
F.SFM==1B9			;[15]SUPPRESS AUTO FF ON NEXT LF FLAG
F.DSK==1B10			;[21]INPUT DEVICE IS A DISK
F.DTA==1B11			;[21]INPUT DEVICE IS A DTA
F.MTA==1B12			;[26]INPUT DEVICE IS A MAGTAPE
F.TMP==1B13			;[32]CURRENT INPUT DEVICE IS TMPCOR:
F.TNF==1B14			;[32]SET IF NO TMPCOR FILE MATCHES THIS SPEC
F.CHK==1B15			;[41]SPECIAL CHECKING CODE TO BE USED
F.COL==1B16			;[42]SET IF GETTING CERTAIN COLUMNS
F.PWT==1B17			;[46]SET IF HAVE TO WAIT FOR PAGE POSITION
				;RIGHT HALF
F.BOL==1B18			;[41]SET IF BEGINNING OF LOGICAL LINE
F.BIL==1B19			;[40]SET IF BEGINNING OF ACTUAL INPUT LINE

				;[26,32,41,46]BITS TO CLEAR AFTER WILD CALL
F.WCLR==F.NUL!F.REC!F.SFM!F.DSK!F.DTA!F.MTA!F.TMP!F.CHK!F.COL!F.PWT
F.WSET==F.BIL!F.BOL		;[40,41]BITS TO SET AFTER WILD CALL
	SUBTTL	Program initilization section

TYPE:	.RESET				;INITILIZE THE PROGRAM
	ERRSET	(TYP)			;INITILIZE THE ERROR MESSAGES
	MOVE	T1,.JBFF		;SAVE ORIGINAL VALUES
	HRL	T1,.JBREL		;  OF .JBREL AND
	MOVEM	T1,ORGFF		;  OR .JBFF
	MOVE	T1,IBLK			;GET .ISCAN BLOCK POINTER
	XCALL	.ISCAN			;INITILIZE THE SCANNER
	MOVE	T1,['TTY   '
		    'TTY   '
		    'LPT   ']+1(T1)	;GET DEFAULT OUTPUT DEVICE
	MOVEM	T1,DEFDEV		;AND SAVE IT
	CLEAR	F,			;PRESET OUR FLAGS
	SUBTTL	Command scanning and option scanning section

SCAN:	TXNE	F,F.OIU			;IS OUTPUT FILE IN USE?
	  CLOSE	OCHAN,			;YES--CLOSE UP
	RESET				;RESET ALL I/O
	SETPDL				;RESET THE PDL
	CLEAR	F,			;AND RESET OUR FLAGS
	MOVE	T1,TBLK			;POINT TO .TSCAN BLOCK
	XCALL	.TSCAN			;AND SCAN THE COMMAND LINE
	IF	(I.IOZR,EQ,I.NXZR)	;IF NO INPUT FILES, THEN
	  GOTO	SCAN			;  LOOP FOR NEXT COMMAND
	CALL	CLRFIL			;CLEAR OUR FILE SPEC AREA
	MOVE	T1,OBLK			;POINT TO OSCAN BLOCK
	XCALL	.OSCAN			;SCAN THE OPTIONS FILE
	MOVX	T1,F1$SET		;GET DEFAULT BITS FOR MASK 1
	ANDCM	T1,F$MM1		;MASK OUT PRESET ONES
	IORM	T1,F$MD1		;AND PUT NEW BITS IN MODE WORD
	IORM	T1,F$MM1		;  AND ITS MASK
	IFI	(S.PAUSE+1,GE,0,THEN)	;[54] IF /PAUSE SWITCH GIVEN
	 MOVEI	T1,PD.PSB		;[54] GET NUMBER OF BELLS DEFAULT
	 IFI	(S.PAUSE,LT,0)		;[54] IF NONE SPECIFIED,
	  MOVEM	T1,S.PAUSE		;[54] USE PRESENT DEFAULT
	ENDIF
	SKIPGE	T1,S.PAGE		;ANY PAGE SETTING?
	SKIPL	T2,S.FORM		;NO--ANY FORM SETTING?
	SKIPA	T2,S.FORM		;YES--AT LEAST ONE OF THEM
	GOTO	OUTDEF			;NO--NO PAGESIZE OR FORM SETTING
	IFI	(T1,LT,0)		;IF NO PAGESIZE,
	  MOVX	T1,AD.PGS		;  USE ABSENT DEFAULT
	IFI	(T2,LT,0)		;IF NO FORM,
	  MOVX	T2,AD.FRM		;  USE ABSENT DEFAULT
	IFI	(T1,LT,<4(T2)>)		;DO WE HAVE AT LEASE 4 PRINTABLE LINES?
	  ERROR PSF			;NO--ERROR--TELL USER
	MOVEM	T1,S.PAGE		;PUT BACK NEW PAGESIZE
	MOVEM	T2,S.FORM		;AND FORM SIZE
	TXO	F,F.PAG			;AND FLAG PAGINATION REQUIRED
	MOVX	T1,AD.WLD		;GET /WILD DEFAULT SETTING
	IFI	(S.WILD,LT,0)		;IS NONE GIVEN, THEN ...
	  MOVEM	T1,S.WILD		;USE INTERNAL DEFAULT
	SUBTTL	Section to default and open output file

OUTDEF:	MOVEI	T1,OUTSCN		;POINT TO OUTPUT SPEC
	MOVEI	T2,.FXLEN		;INDICATE LENGTH
	XCALL	.OSDFS			;DEFAULT OUTPUT FILE SPEC
	MOVE	T1,DEFDEV		;GET THE DEFAULT OUTPUT DEVICE
	IFI	(OUTSCN+.FXDEV,EQ,0)	;IF NO PART OF FILESPEC PRESENT,
	  MOVEM	T1,OUTSCN+.FXDEV	;  USE DEFAULT DEVICE
	IFI	(OUTSCN+.FXNAM,EQ,0,THEN) ;IF NO FILENAME, THEN ...
	 MOVE	T1,I.IOZR		;[57] GET ADDRESS OF FIRST INPUT SPEC
	 MOVE	T2,.FXNMM(T1)		;[57] GET MASK
	 AOJN	T2,.+2			;[57] SKIP IF ANY WILDCARDS (OR NO NAME)
	 SKIPA	T1,.FXNAM(T1)		;[57] NO WILD CARDS--USE FIRST INPUT NAME
	 MOVE	T1,['TYPE  ']		;[57] WILD CARDS--USE 'TYPE'
	 MOVEM	T1,OUTSCN+.FXNAM	;  SAVE DEFAULT NAME
	 SETOM	OUTSCN+.FXNMM		;SETUP FILE MASK PROPERLY
	ENDIF
	HRLOI	T1,'LST'		;GET DEFAULT EXTENSION
	IFI	(OUTSCN+.FXEXT,EQ,0)	;IF NO EXTENSION GIVEN,
	  MOVEM	T1,OUTSCN+.FXEXT	;  THEN USE DEFAULT
	MOVEI	T1,.RBLEN		;GET LENGTH OF ENTER BLOCK
	MOVEM	T1,OUTENT		;AND SAVE IN ENTER BLOCK
	MOVE	T1,[.FXLEN,,OUTSCN]	;POINT TO SCAN BLOCK
	MOVEI	T2,OUTOPN		;POINT TO OPEN BLOCK
	MOVE	T3,[.RBLEN+1,,OUTENT]	;POINT TO ENTER BLOCK
	MOVEI	T4,OUTPAT		;POINT TO PATH BLOCK
	XCALL	.STOPB			;SETUP OUTPUT FILE AREA
	  ERROR	WCI			;ERROR IF WILDCARDED
	MOVSI	T1,OUTHDR		;GET OUTPUT BUFFER HEADER ADR
	MOVEM	T1,OUTOPN+.OPBUF	;AND SAVE IN OPEN BLOCK
	OPEN	OCHAN,OUTOPN		;OPEN OUTPUT DEVICE
	  ERROR	OPO			;ERROR--TELL USER
	SUBTTL	Section to lookup output file & set TTY defaults

	MOVEI	T1,OCHAN		;GET THE CHANNEL NUMBER
	DEVCHR	T1,			;GET THE DEV'S CHARS
	TXNN	T1,DV.OUT		;[51] CAN DEVICE DO OUTPUT?
	  ERROR	CDO			;[51] NO--THIS IS FATAL
	TLC	T1,-1-<(DV.TTA)>	;SEE IF NUL:
	TLCE	T1,-1-<(DV.TTA)>	;IF SO--NOT TTY
	TXNN	T1,DV.TTY		;IS THE DEVICE A TTY?
	  GOTO	OUTDE1			;NO--SKIP IT
	TXO	F,F.TTY			;SHOW WE HAVE A TTY
	IFI	(S.IMAGE,GT,0,THEN)	;[37]IF IMAGE MODE OUTPUT, THEN
	 SETSTS	OCHAN,.IOIMG		;[37]CHANGE TO IMAGE MODE OUTPUT
	 MOVSI	T2,(POINT 36)		;[37]GET IMAGE MODE POINTER
	 MOVEM	T2,OUTHDR+.BFPTR	;[37]AND SAVE IN BUFFER HEADER
	ENDIF
IFE	TOPS-10,<       ; PA1050 has problems with IONDX. UUO
	MOVEI	T2,OCHAN		;GET THE CHANNEL NUMBER
	IONDX.	T2,			;GET THE INDEX FOR TRMNO. CALLS
	  ERROR	ION			;ERROR--TELL USER
	> ; End IFE TOPS-10
IFN	TOPS-10,<	; PA1050 has problems with IONDX. UUO -- TYMCOM-X too!
	MOVEI	T3,OCHAN		;[72] Get the channel number
	DEVNAM	T3,			;[72] Get name of the TTY
	  ERROR	ION			;[72] Error--Tell user
	LSH	T3,^D18			;[72] Position the unit number
	CLEAR	T2,			;[72] Setup to recieve number
	IFI	(T3,EQ,0,THEN)		;[72] If DEVNAM just returned 'TTY'
	 SETO	T2,			;[72] Setup for ourselves
	 GETLCH	T2			;[72] Get our TTY number
	ELSE				;[72] Else if not our TTY
XXX.X:	 TLZN	T3,200000		;[72] Is this still a number?
	  GOTO	XXX.XX			;[72] No--all done
	 LSH	T3,3			;[72] Yes--shift down to binary
	 LSHC	T2,3			;[72] And put in the digit
	 GOTO	XXX.X			;[72] Loop for all digits
	ENDIF
XXX.XX:
	> ; End IFN TOPS-10
IFE TOPS-4,<	; Tymcom-X doesn't care about .Uxtrm etc, use Auxcals
	MOVEM	T2,TTYUDX		;SAVE THE PORT #
	MOVEI	T2,.AXWID		;GET THE WIDTH IDENTIFIER
	HRL	T2,TTYUDX		;REMEMBER THE PORT #
	SETOM	CURWID			;INSURE THAT WE DO A 'READ'
	AUXCAL	T2,CURWID		;READ THE CURRENT WIDTH
	> ; End IFE TOPS-4
IFN TOPS-4,<	; Tymcom-X doesn't care about .UXTRM etc, use Auxcals
	ANDX	T2,UX.UNT		;[17]GET THE UNIT NUMBER
	TXO	T2,.UXTRM		;[17]PUT IN TERMINAL OFFSET
	MOVEM	T2,TTYUDX		;AND SAVE THE UDX
	MOVX	T2,.TOWID		;GET CODE TO READ TTY WIDTH
	MOVEM	T2,TRMCOD		;AND SAVE IT IN TRMOP. BLOCK
	MOVE	T2,[2,,TRMCOD]		;POINT TO TRMOP. BLOCK
	TRMOP.	T2,			;GET THE TTY WIDTH
	  ERROR	TRM			;??UNEXPECTED ERROR??
	MOVEM	T2,CURWID		;[30]SAVE CURRENT TTY WIDTH
	> ; End IFN TOPS-4
	TXNE	T1,DV.TTA		;IS THIS THE CONTROLLING TTY?
	  TXO	F,F.TTA			;YES--FLAG IT AS SUCH
					CONT.
OUTDE1:	SKIPG	T2,CURWID		;[20,30]USE WIDTH IF WE GOT IT
	  MOVEI	T2,^D132		;[20]  ELSE DEFAULT TO 132.
	MOVEM	T2,CURWID		;[20,30]STORE CURRENT WIDTH
	MOVEM	T2,ORGWID		;[20]AND SAVE ORIGINAL WIDTH
	IFI	(S.TABS,LT,0,THEN)	;[50]IF NO /TABS SETTING GIVEN, THEN ...
	 CLEARM	S.TABS			;[50] SET TO /NOTABS
	 TXNN	F,F.TTY			;[50] IS THIS A TTY?
	  GOTO	OUTDE6			;[50] NO--THEN /NOTABS IS CORRECT
IFE TOPS-4,<	; TYMCOM-X DOESN'T SEE IT THIS WAY
	 MOVE	T3,TTYUDX		;[TYM-1] GET PORT #
	 GETLCH	T3			;[TYM-1] READ CHARACTERISTICS
	 MOVEI	T2,1			;[TYM-1] ASSUME TABS
	 TXNN	T3,LC.HHT		;[TYM-1] DO WE HAVE THEM?
	> ; End IFE TOPS-4
IFN TOPS-4,<	; TYMCOM-X doesn't see any trmop.'s
	 MOVX	T2,.TOTAB		;[50] YES--SEE IF TTY UNDERSTANDS TABS
	 MOVEM	T2,TRMCOD		;[50]
	 MOVE	T2,[2,,TRMCOD]		;[50]
	 TRMOP.	T2,			;[50] READ TTY SETTING
	> ; End IFN TOPS-4
	  CLEAR	T2,			;[50] ERROR--ASSUME /NOTABS
	 MOVEM	T2,S.TABS		;[50] SET SETTING PROPERLY
OUTDE6:	ENDIF
	TLC	T1,-1-<(DV.TTA)>	;SEE IF NUL:
	TLCE	T1,-1-<(DV.TTA)>	;IF SO--NOT LINE MODE DEV
	TXNN	T1,DV.TTY		;[56] SEE IF LINE MODE DEVICE
	CAIA				;NO--NOT LINE MODE
	  TXO	F,F.LMD			;YES--FLAG IT
	TXNN	T1,DV.DIR		;[63] IS THIS A DIRECTORIED DEVICE
	 TXNE	T1,DV.LPT		;[63]  OR A LINE PRINTER (POSSIBLY SPOOLED)
	  TXNE	T1,DV.TTY		;[63]   AND NOT NUL:?
	   GOTO	OUTDE4			;NO--SKIP IT
	TXNE	T1,DV.DTA		;[23,36,63]IS THIS A DECTAPE?
	  GOTO	OUTDE5			;[36]YES--SHORT LOOKUP FOR DTA
	TXNN	T1,DV.LPT		;[63] DON'T APPEND IF LPT:
	 SKIPG	S.APPEND		;[23]DO WE WANT TO APPEND?
	  GOTO	OUTDE3			;[23]NO--JUST ENTER
	LOOKUP	OCHAN,OUTENT		;[23]TRY TO FIND THE FILE TO APPEND TO
	  GOTO	[HRRZ	T1,OUTENT+.RBEXT;[23]ERROR--GET THE REASON
		 JUMPN	T1,ERR(OPA)	;[23]IF NOT FNF--THEN BAD
		CLEARM	S.APPEND	;[23]PREVENT USETO IF FNF
		 GOTO	OUTDE2]		;[23]ELSE JUST DO THE ENTER
	MOVE	T1,OUTENT+.RBSIZ	;[23]GET FILE SIZE IN WORDS
	ADDI	T1,377			;[23]ROUND UP TO
	LSH	T1,-7			;[23]  BLOCKS + 1
	MOVEM	T1,S.APPEND		;[23]SAVE FOR LATER USETO
OUTDE2:	HLLZS	OUTENT+.RBEXT		;[23]CLEAR LOW DATE-75 STUFF
	MOVSI	T1,777000		;[23]GET PROTECTION MASK
	ANDM	T1,OUTENT+.RBPRV	;[23]AND MASK OUT REST OF DATE-75 STUFF
OUTDE3:	ENTER	OCHAN,OUTENT		;ENTER THE OUTPUT FILE
	  ERROR	OPE			;ERROR--TELL USER
IFE TOPS-20,<	; Don't worry about extended size on TOPS-20
	SKIPLE	T1,S.APPEND		;[23]IF APPENDING TO FILE
	  USETO	OCHAN,(T1)		;[23]  SKIP TO NEXT FREE BLOCK
    > ; End IFE TOPS-20
IFN TOPS-20,<	; Add extended block stuff for TOPS-10 & TYMCOM-X
	PUSH	P,T2			;[TYM-2] Donno if useable
IFE TOPS-4,<	; Use CHANIO for USETO on Tymcom-X
	Move	T2,[.Chfso,,Ochan]	;[TYM-2] Chanio setup
	SKIPLE	T1,S.APPEND		;[TYM-2]IF APPENDING TO FILE
	  Chanio T2,T1			;[TYM-2]  Skip to next free block
    > ; End IFE TOPS-4
IFE TOPS-10,<	; Use SUSET. for USETO on TOPS-10
	Move	T2,[Exp SU.SOT+<OCHAN>B12]
	Or	T2,T1			;[TYM-2] SUSET. setup
	Move	T1,S.APPEND		;[TYM-2] IF APPENDING TO FILE
	Jumple	T1,.+3			;[TYM-2] ... No ...
	  SUSET. T2,			;[TYM-2]   Skip to next free block
	   ERROR SUO			;[TYM-2]	**OR ***
    > ; End IFE TOPS-4
	POP	P,T2			;[TYM-2] Restore register
> ; End IFN TOPS-20
	GOTO	OUTDE4			;[36]SKIP AROUND
OUTDE5:	ENTER	OCHAN,OUTENT+.RBNAM	;[36]DO A SHORT ENTER FOR DECTAPE
	  ERROR	OPE			;[36]ERROR--TELL USER
OUTDE4:	TXO	F,F.OIU			;FLAG OUTPUT FILE IN USE
	SUBTTL	Section to default input file specifications

FILDEF:	MOVE	P1,I.IOZR		;POINT TO FIRST FILE SPEC
	MOVSI	T1,'DSK'		;GET DEFAULT DEVICE
	MOVX	T2,'*     '		;GET DEFAULT FILENAME IF /WILD
	CLEAR	T3,			;GET DEFAULT FILE MASK IF /WILD
	MOVSI	T4,'*  '		;GET DEFAULT EXT IF /WILD
FILDE1:	IFI	(.FXDEV(P1),EQ,0)	;IF NO DEVICE SPECIFIED,
	  MOVEM	T1,.FXDEV(P1)		;  USE DEFAULT
	IFI	(S.WILD,GT,0,THEN)	;IF /WILD DEFAULTING, THEN ...
	 IFI	(.FXNAM(P1),EQ,0,THEN)	;IF NO FILENAME, THEN ...
	  MOVEM	T2,.FXNAM(P1)		;USE DEFAULT FILENAME
	  MOVEM	T3,.FXNMM(P1)		;AND MASK
	 ENDIF
	 IFI	(.FXEXT(P1),EQ,0)	;IF NO EXT PSECIFIED,
	  MOVEM	T4,.FXEXT(P1)		;USE DEFAULT WILD
	 MOVE	T2,.FXNAM(P1)		;GET NEXT DEFAULT FILENAME
	 MOVE	T3,.FXNMM(P1)		;AND MASK
	ELSE				;IF /NOWILD PROCESSING, THEN ...
	 IFI	(.FXNAM(P1),EQ,0,THEN)	;[70] If no file name, THEN
	  PUSH	P,T1			;[70] Get a working register
	  MOVE	T1,.FXMOD(P1)		;[70] Get filespec modifier bits
	  TXNE	T1,FX.PHY		;[70] Is the device a physical name?
	   GOTO	FILDE2			;[70] Yes--must do a PHONLY CALLI
	  MOVE	T1,.FXDEV(P1)		;[70] Get the device name
	  DEVCHR T1,			;[70] Get the device's characteristics
	  GOTO	FILDE3			;[70] Skip around
FILDE2:	  MOVE	T1,.FXDEV(P1)		;[70] Get the physical device name
	  DEVCHR T1,UU.PHY		;[70] Get the device's characteristics
FILDE3:	  TXNE	T1,DV.DIR		;[70] Is this a directoried device?
	   TXNE	T1,DV.TTY		;[70] Maybe--is the the NUL device?
	    CAIA			;[70] Good--either NUL of no directory
	     ERROR IFR			;[70] Dir device--requires filename
	  POP	P,T1			;[70] Restore working register
	  SETOM	.FXNMM(P1)		;[70] And fix up filespec name mask
	 ENDIF				;[70]
	 IFI	(.FXEXT(P1),EQ,0)	;IF NO EXT SPECIFIED,
	  HLLOS	.FXEXT(P1)		;DEFAULT TO NULL EXT
	ENDIF
	ADDI	P1,.FXLEN+$FXSIZ	;POINT TO NEXT FILESPEC
	IF	(P1,LT,I.NXZR)		;IF STILL MORE TO GO
	  GOTO	FILDE1			;  THEN LOOP FOR NEXT
	SUBTTL	Section to default the input file switches

INDEF:	MOVE	P1,I.IOZR		;GET ADR OF FIRST INPUT FILE
INDEF1:	MOVEI	T1,(P1)			;GET ADR OF FILE BLOCK
	MOVEI	T2,.FXLEN+$FXSIZ	;SHOW FILE BLOCK LENGTH
	XCALL	.OSDFS			;FILLIN NORMAL DEFAULTS
	MOVEI	T1,.FXLEN(P1)		;GET FILE AREA POINTER AGAIN
	MOVEI	T2,F$ZER		;POINT TO DEFAULTS (OPTIONS)
INDEF2:	MOVE	T3,(T2)			;GET OPTION FILE SWITCHES
	ANDCM	T3,1(T1)		;MASK OUT PRESET ONES
	IORM	T3,(T1)			;AND STORE NEW SWITCHES
	MOVE	T3,1(T2)		;GET PERMENANT MASK
	IORM	T3,1(T1)		;AND FIX FILE MASK
	ADDI	T1,2			;POINT TO NEXT MODE/MASK
	ADDI	T2,2			;...
	CAIG	T2,F$EZER		;DONE WITH MODE/MASK WORDS?
	  GOTO	INDEF2			;NO--CONTINUE TO NEXT
INDEF3:	MOVE	T3,(T2)			;GET OPTION VALUE
	SKIPGE	(T1)			;WAS A VALUE GIVEN?
	MOVEM	T3,(T1)			;NO--USE OPTION VALUE
	AOJ	T1,			;POINT TO NEXT SWITCH
	CAIGE	T2,F$EMIN		;ALL DONE?
	  AOJA	T2,INDEF3		;NO--DO NEXT SWITCH
	SKIPG	T1,.FXLEN+$FXNBL(P1)	;GET NUMBER OF BLOCKS TO OUTPUT
	  GOTO	INDEF4			;SKIP IF NONE SET
	SKIPG	T2,.FXLEN+$FXBST(P1)	;GET FIRST BLOCK NUMBER
	  MOVEI	T2,1			;DEFAULT TO BLOCK 1 IF NONE GIVEN
	TRNE	T2,400000		;IS BLOCK START POSITIVE?
	  GOTO	INDEF7			;NO--NEGATIVE
	ADDI	T1,-1(T2)		;YES--COMPUTE LAST BLOCK NUMBER
	IFI	(T1,GT,MX.RNE)		;IF TOO BIG
	  MOVEI	T1,MX.RNE		;  THEN USE MAXIMUM
	GOTO	INDEF8			;AND SKIP AROUND
INDEF7:	ADDI	T1,-1(T2)		;NEGATIVE--COMPUTE LAST BLOCK #
	TXNN	T1,400000		;DID IT GET TOO LARGE?
	  HRRZI	T1,-MX.RNE		;YES--USE MAXIMUM NEGATIVE
INDEF8:	SKIPG	.FXLEN+$FXBEN(P1)	;WAS A LAST BLOCK ALREADY SPECIFIED?
	  MOVEM	T1,.FXLEN+$FXBEN(P1)	;NO--USE THE /NBLOCKS SWITCH VALUE
INDEF4:	SKIPG	T1,.FXLEN+$FXNPG(P1)	;GET THE NUMBER OF PAGES TO OUTPUT
	  GOTO	INDEF5			;SKIP IF NONE SET
	SKIPG	T2,.FXLEN+$FXPST(P1)	;GET THE FIRST PAGE NUMBER
	  MOVEI	T2,1			;DEFAULT TO 1 IF NONE GIVEN
	ADDI	T1,-1(T2)		;COMPUTE FINAL PAGE NUMBER
	SKIPG	.FXLEN+$FXPEN(P1)	;WAS LAST PAGE ALREADY SPECIFIED?
	  MOVEM	T1,.FXLEN+$FXPEN(P1)	;NO--USE THE /NPAGES SWIOTCH VALUE
INDEF5:	SKIPG	T1,.FXLEN+$FXNLN(P1)	;GET NUMBER OF LINES TO OUTPUT
	  GOTO	INDEF6			;SKIP IF NONE SET
	SKIPG	T2,.FXLEN+$FXLST(P1)	;GET FIRST LINE NUMBER
	  MOVEI	T2,1			;DEFAULT TO LINE 1 IF NONE GIVEN
	ADDI	T1,-1(T2)		;COMPUTE FINAL LINE NUMBER
	SKIPG	.FXLEN+$FXLEN(P1)	;WAS LAST LINE ALREADY SPECIFIED?
	  MOVEM	T1,.FXLEN+$FXLEN(P1)	;NO--USE THE /NLINES SWITCH VALUE
INDEF6:	ADDI	P1,.FXLEN+$FXSIZ	;POINT TO NEXT SPECIFICATION
	IF	(P1,LT,I.NXZR)		;IF MORE FILES, THEN ...
	  GOTO	INDEF1			;  GO PROCESS THEM
	SUBTTL	Section to start input file processing

INFILE:	MOVE	T1,I.IOZR		;GET ADR OF FIRST FILESPEC
	MOVEM	T1,SCNPTR		;SAVE IT FOR WILD
	MOVE	T1,I.NXZR		;GET ADR OF NEXT FILE
	SUBI	T1,.FXLEN+$FXSIZ	;MOVE BACK TO LAST FILE
	MOVEM	T1,SCNEND		;SAVE THIS ADR
	CLEARM	WLDPTR			;AND RESET WILD POINTER
	LDB	T1,[POINTR(OUTSCN+.FXLEN+$FXMD2,FX$BUF)] ;[53] GET # OF OUTPUT BUFFERS
	OUTBUF	OCHAN,(T1)		;[53] ALLOCATE OUTPUT BUFFER SPACE NOW
	MOVE	T1,.JBFF		;GETCURRENT FIRST FREE LOC
	HRL	T1,.JBREL		;AND THE CORE LIMIT
	MOVEM	T1,WLDFF		;AND SAVE TO RESTORE AFTER EACH FILE
	SUBTTL	Section to get next file spec from WILD

NXTFIL:	SETPDL				;FIX UP THE PDL
	STORE	T1,W.ZER,W.EZER,0	;CLEAR OUT EACH FILE VALUES
	HRRZ	T1,WLDFF		;GET BACK FIRST FREE LOC
	MOVEM	T1,.JBFF		;AND FIX UP .JBFF
	HLRZ	T1,WLDFF		;GET BACK CORE SIZE VALUE
	CAME	T1,.JBREL		;HAS CORE SIZE CHANGED?
	CORE	T1,			;YES--TELL MONITOR ABOUT IT
	  NOP				;  (IGNORE ERROR)
	MOVE	T1,WBLK			;POINT TO WILD'S BLOCK
	XCALL	.LKWLD			;GET A FILE SPECIFICATION
	  GOTO	SCAN			;NO MORE FILES RETURN
	TXZ	F,F.WCLR		;[26]CLEAR SOME FLAG BITS
	TXO	F,F.WSET		;[40]BITS TO SET AFTER WILD CALL
	TXNN	T1,DV.IN		;[27]CAN THIS DEVICE DO INPUT?
	  JUMPN	T1,ERR(CDI)		;[27]NO--ERROR IF NOT TMPCOR:
	TXNN	T1,DV.DSK		;[26]CHECK FOR NUL:
	TXNN	T1,DV.MTA		;[26]IS THIS DEVICE A MTA:?
	CAIA				;[26]NO--NOT MTA:
	  TXO	F,F.MTA			;[26]YES--SET FLAG BIT
	MOVEM	T1,IDEVCHR		;SAVE THE INPUT DEV CHARACTERISTICS
	MOVEI	T1,FILHDR		;GET INPUT HEADER ADR
	MOVEM	T1,OPNBLK+.OPBUF	;SAVE IN OPEN BLOCK
	IFI	(T2,LT,0)		;[21]IF DEVICE IS A DISK
	  TXO	F,F.DSK			;[21]  SET THE FLAG
	IFI	(T2,EQ,0)		;[21]IF DEVICE IS A DECTAPE
	  TXO	F,F.DTA			;[21]  SET THE FLAG
	MOVE	P1,WLDPTR		;GET ADR OF SCAN BLOCK
	MOVE	P2,.FXLEN+$FXMD1(P1)	;AND GET MODE WORD 1
	TXNE	P2,<<FX$SPC*2>&FX$SPC>!FX$LSP ;[41]MORE THAN SINGLE SPACING OR LSUPPRESS?
	  TXO	F,F.CHK			;[41]YES--SPECIAL CHECKING NEEDED
	MOVE	T1,.FXLEN+$FXMD2(P1)	;[41]GET MODE WORD 2
	TXNE	T1,FX$IND!FX$CL1!FX$CL2	;[41]ANY SPECIAL STUFF?
	  TXO	F,F.CHK			;[41]YES--SET THE FLAG
	LDB	T2,[POINTR (T1,FX$CL1)]	;[42]GET COLUMN 1 VALUE
	MOVEM	T2,COLBEG		;[42]AND SAVE VALUE
	LDB	T2,[POINTR (T1,FX$CL2)]	;[42]GET LAST COLUMN VALUE
	MOVEM	T2,COLEND		;[42]AND SAVE VALUE
	TXNE	T1,FX$CL1!FX$CL2	;[42]ANY COLUMN CHECKING?
	  TXO	F,F.COL			;[42]YES--SET FLAG
	TXNN	P2,FX$BYT		;[12,34,TYM-3] SPECIAL MODE FILE?
	  GOTO	NXTFI1			;[12]NO--SKIP AROUND
	MOVEI	T1,.IOBIN		;[12]YES--CHANGE THE MODE
	IORM	T1,OPNBLK		;[12]  TO BINARY FOR INPUT
	TXO	F,F.NUL			;[13]ALLOW NULL BYTES ON INPUT

					CONT.
NXTFI1:	TXNN	P2,FX$BIN		;[25]/ERBINARY OR /SKBINARY?
	  GOTO	INIFIL			;[25]NO--SKIP BINARY CHECK
	TXNE	P2,FX$OCT!FX$SIX!FX$KAT	;[52] /OCTAL OR SPECIAL LISTING?
	TXNN	P2,FX$BIN&<2*FX$BIN>	;[52] AND /SKBINARY?
	CAIA				;[52] NO--DO BINARY CHECK
	  GOTO	INIFIL			;[52] YES--ALLOW BINARY FILES THRU
	MOVE	T1,[-BINLEN,,BINEXT]	;[25]SETUP AOBJN POINTER/COUNTER
	HLRZ	T2,LKPBLK+.RBEXT	;[25]GET THE EXTENSION
NXTFI2:	HLRZ	T3,(T1)			;[25]GET EXT IN LH
	IF	(T2,NE,T3,THEN)		;[25]IF NO EXT MATCH, THEN ...
	 HRRZ	T3,(T1)			;[25]GET EXT IN RH
	 IF	(T2,NE,T3,THEN)		;[25]IF NO EXT MATCH, THEN ...
	  AOBJN	T1,NXTFI2		;[25]LOOP FOR ALL EXTENSIONS
	  GOTO	INIFIL			;[25]AND WHEN DONE--CONTINUE
	 ENDIF
	ENDIF
	TXNN	P2,FX$BIN&<2*FX$BIN>	;[25]IF THIS /ERBINARY?
	  ERROR	IBF			;[25]YES--GIVE ERROR MESSAGE
	GOTO	NXTFIL			;[25]NO--/SKBINARY--JUST SKIP IT
	SUBTTL	Section to initialize I/O to input file

INIFIL:	OPEN	ICHAN,OPNBLK		;OPEN INPUT DEVICE
	  GOTO	TRYTMP			;[24]ERROR--SEE IF TMPCOR:
	TXNN	F,F.DSK			;[21]IS THE DEVICE A DISK?
	  GOTO	INIFI1			;[21]NO--SKIP AROUND
	LOOKUP	ICHAN,LKPBLK		;LOOKUP THE FILE
	  GOTO	[XCALL	E.DFL		;ERROR--TELL USER
		 GOTO	NXTFIL]		;  AND TRY FOR NEXT FILE
	MOVE	T1,LKPBLK+.RBSIZ	;GET THE FILES SIZE IN WORDS
	ADDI	T1,377			;ROUND UP TO COMPUTE
	LSH	T1,-7			;  BLOCKS + 1
	MOVEM	T1,BLKSIZ		;AND SAVE FOR LATER USE
INIFI1:	TXNN	F,F.DTA			;[21]IS THE DEVICE A DTA?
	  GOTO	INIFI2			;[21]NO--SKIP AROUND
	LOOKUP	ICHAN,LKPBLK+.RBNAM	;LOOK UP THE FILE
	  GOTO	[XCALL	E.DFL		;ERROR--TELL USER
		 GOTO	NXTFIL]		;  AND GO TRY NEXT FILE
	MOVEI	T3,77777		;GET MASK
	ANDCAM	T3,LKPBLK+.RBEXT	;CLEAR WHERE ACCESS SHOULD BE
	CLEARM	LKPBLK+.RBSIZ		;NO SIZE FOR DTA FILES
INIFI2:	XCALL	.CHKTM			;[43]CHECK OUT TIME/LENGTH CONSTRAINTS
	  GOTO	FINFI1			;[43]SORRY--YOU LOSE!
	MOVEI	T1,GETBYT		;[12]DEFAULT INPUT ROUTINE
	TXNE	P2,FX$COB		;[12,TYM-3]OR A COBOL SIXBIT FILE?
	  MOVEI	T1,GETCOB		;[12,TYM-3]YES--USE COBOL ROUTINE
	TXNE	P2,FX$FOR		;[13]IS THIS A FORTRAN DATA FILE?
	  MOVEI	T1,GETFOR		;[13]YES--USE FORTRAN INPUT ROUTINE
	TXNE	P2,FX$OCT		;[34]IS THIS AN OCTAL DUMP?
	  MOVEI	T1,GETOCT		;[34]YES--USE OCTAL INPUT ROUTINE
	TXNE	P2,FX$SIX		;[TYM-3]IS THIS A SIXBIT FILE?
	  MOVEI	T1,GETSIX		;[TYM-3]YES--USE SIXBIT INPUT ROUTINE
	MOVEM	T1,INRTN		;[12]SAVE INPUT ROUTINE ADR
	TXZ	F,F.REC			;[12]CLEAR COBOL SIXBIT RECORD FLAG
	IFI	(.FXLEN+$FXBEN(P1),GT,0,THEN) ;IF ENDING BLOCK SPECIFIED, THEN ...
	 HRRE	T3,.FXLEN+$FXBEN(P1)	;GET THE OFFSET INTO THE FILE
	 IFI	(T3,LT,0,THEN)		;IF NEGATIVE, THEN ...
	  TXNN	F,F.DSK			;[21]IS THE DEVICE A DISK?
	   ERROR NBI			;[21]NO--DON'T ALLOW NEGATIVE BLOCK #
	  ADD	T3,BLKSIZ		;COMPUTE ACTUAL BLOCK NUMBER
	  MOVEM	T3,.FXLEN+$FXBEN(P1)	;AND STORE ACTUAL BLOCK NUMBER
	 ENDIF
	ENDIF
	SUBTTL	Section to perform MagTape positioning [26]

INIMTA:	TXNN	F,F.MTA			;IS THIS A MAGTAPE?
	  GOTO	INITTY			;NO--SO SKIP MTA STUFF
	TXNE	P2,FX$REW		;IF /REWIND SET
	  MTREW. ICHAN,			;  THEN REWIND IT
	TXNE	P2,FX$EOT		;IF /EOT SET
	  MTEOT. ICHAN,			;  THEN SKIP TO LOGICAL END OF TAPE
	IFI	(.FXLEN+$FXMFL(P1),GT,0,THEN) ;IF FILES SKIP/BACKSPACE, THEN ...
	 HRRE	T1,.FXLEN+$FXMFL(P1)	;GET NUMBER OF FILES TO SKIP/BACKSPACE
	 IFI	(T1,LT,0,THEN)		;IF BACKSPACE FILES, THEN ...
	  MTBSF. ICHAN,			;BACKSPACE GIVEN NUMBER OF
	  AOJLE	T1,.-1			;  FILE MARKS + 1
	  MTWAT. ICHAN,			;WAIT FOR TAPE TO FINISH
	  STATO	ICHAN,IO.BOT		;ARE WE AT BEGINNING OF TAPE?
	   MTSKF. ICHAN,		;NO--SKIP OVER THE FILE MARK
	 ELSE				;IF SKIPPING FILES ...
	  MTSKF. ICHAN,			;SKIP OVER GIVEN NUMBER
	  SOJG	T1,.-1			;  OF FILES
	 ENDIF
	ENDIF
	IFI	(.FXLEN+$FXMRC(P1),GT,0,THEN) ;IF RECORDS SKIP/BACKSPACE, THEN ...
	 HRRE	T1,.FXLEN+$FXMRC(P1)	;GET THE NUMBER OF RECORDS TO SKIP/BACKSPACE
	 IFI	(T1,LT,0,THEN)		;IF BACKSPACE RECORDS, THEN ...
	  MTBSR. ICHAN,			;BACKSPACE OVER GIVEN NUMBER
	  AOJL	T1,.-1			;  OF RECORDS
	 ELSE				;IF SKIPPING RECORDS ...
	  MTSKR. ICHAN,			;SKIP OVER GIVEN NUMBER
	  SOJG	T1,.-1			;  OF RECORDS
	 ENDIF
	ENDIF
	MTWAT.	ICHAN,			;WAIT FOR ALL MAGTAPE SPACING TO FINISH
	SUBTTL	Section to setup terminal for I/O

INITTY:	LDB	T1,[POINTR(.FXLEN+$FXMD1(P1),FX$WID)];[30]GET OUTPUT WIDTH VALUE
	IFI	(T1,EQ,0)		;[30]IF NO VALUE, THEN
	  MOVE	T1,ORGWID		;[30]  USE THE ORIGINAL VALUE
	MOVEM	T1,CURWID		;[30]AND SAVE AS CURRENT WIDTH
	MOVEM	T1,SPLEFT		;[30]AND SAVE THE SPACES LEFT ON THE LINE
	LDB	T3,[POINTR(.FXLEN+$FXMD2(P1),FX$BUF)] ;[53] GET NUMBER OF INPUT BUFFERS
	TXNN	F,F.TMP			;[53] SKIP INBUF IF TMPCOR READ
	  INBUF	ICHAN,(T3)		;[53] SETUP INPUT BUFFERS AND HEADER
	TXNN	P2,FX$OCT!FX$SIX	;[34,TYM-3]IS THIS OCTAL OR SIXBIT?
	  GOTO	INITT0			;[34]NO--SKIP THIS
	TXNE	P2,FX$OCT		;[TYM-3] OCTAL?
	  IDIVI	T1,^D16			;[34,TYM-3]COMPUTE # OF NUMBERS/LINE
	TXNE	P2,FX$SIX		;[TYM-3] SIXBIT?
	  IDIVI	T1,^D6			;[TYM-3] COMPUTE # WORDS/LINE
	IFI	(T1,LE,0)		;[34]IF NOT ROOM FOR ONE,
	  MOVEI	T1,1			;[34]DO ONE ANYWAY
	MOVEM	T1,BYTMAX		;[34]AND SAVE FOR COUNTER
INITT0:	HLLZ	T1,FILHDR+.BFPTR	;[TYM-5] GET OLD BUFFER POINTER
	TXNE	P2,FX$OCT		;[TYM-5] OCTAL?
	  MOVSI	T1,(POINT 3)		;[34]GET OCTAL DIGIT POINTER
	TXNE	P2,FX$SIX		;[TYM-3] SIXBIT?
	  MOVSI	T1,(POINT 6)		;[TYM-3] GET SIXBIT POINTER
	TXNE	P2,FX$KAT		;[TYM-5] KATAKANA?
	  MOVSI	T1,(POINT 9)		;[TYM-5] GET KATAKANA POINTER
	HLLM	T1,FILHDR+.BFPTR	;[34]AND STORE IT
	SKIPLE	T1,S.DEVICE		;[TYM-4] FOREIGN DEVICE?
	  CALL	TO$DEV			;[TYM-4] PRINT TO DEVICE
	TXNN	F,F.TTY			;IS OUTPUT DEVICE A TTY?
	  GOTO	INITT1			;NO--NO WIDTH SETTING
IFN TOPS-4,<	; Use Auxcal for TYMCOM-X
	MOVEI	T1,.TOSET+.TOWID	;GET TRMOP. SETTING CODE
	MOVEM	T1,TRMCOD		;AND PUT IN TRMOP. BLOCK
	MOVE	T1,[3,,TRMCOD]		;POINT TO TRMOP. BLOCK
	TRMOP. T1,			;AND SET THE WIDTH
	  NOP				;(IGNORE ERRORS)
	> ; End IFN TOPS-4
IFE TOPS-4,<	; Use Auxcal for TYMCOM-X
	PUSH	P,CURWID		;[TYM-1] SAVE THE WIDTH HERE
	MOVEI	T1,.AXWID		;[TYM-1] GET THE WIDTH CALL
	HRL	T1,TTYUDX		;[TYM-1] USE THE RIGHT TERMINAL
	AUXCAL	T1,CURWID		;[TYM-1] SET THE WIDTH
	POP	P,CURWID		;[TYM-1] MAKE SURE IT'S RESTORED
	> ; End IFE TOPS-4
INITT1:	SKPINL				;DEFEAT A CONTROL-O
	  NOP
	TXNE	P2,FX$NAM		;DOES HE WANT /NAME?
	  CALL	I$$NAM			;YES--GIVE FILE INFO
	IFI	(S.PAUSE,GE,0,THEN)	;[54] IF /PAUSE SPECIFIED, THEN ...
	 SKIPLE	T1,S.DEVICE		;[TYM-4] FOREIGN DEVICE?
	  CALL	FR$DEV			;[TYM-4] PRINT TO TTY
	 TYPE	<
Pausing for each page.
Type a space to start each page printing.
>
	 SKIPLE	T1,S.DEVICE		;[TYM-4] FOREIGN DEVICE?
	  CALL	TO$DEV			;[TYM-4] PRINT TO DEVICE
	ELSE
	 TXNE	F,F.PAG			;ARE WE GOING TO SIMULATE PAGES?
	 TXNN	F,F.TTA			;YES--IS THE OUTPUT TO THE ATTATCHED TTY?
	  GOTO	INITT2			;NO--SKIP PAGING MESSAGE
	 SKIPLE	T1,S.DEVICE		;[TYM-4] FOREIGN DEVICE?
	  CALL	FR$DEV			;[TYM-4] PRINT TO TTY
	 TYPE	<
Position paper at top of form and type a space.
>
	 SKIPLE	T1,S.DEVICE		;[TYM-4] FOREIGN DEVICE?
	  CALL	TO$DEV			;[TYM-4] PRINT TO DEVICE
	ENDIF				;[54]
	TXO	F,F.PWT			;[46]FLAG WAIT FOR POSITIONING
INITT2:	MOVE	P3,S.PAGE		;INITILIZE PAGE SIZE
	SUB	P3,S.FORM		;MAKE IT THE PRINTABLE PART
	TXO	F,F.TOP			;[11]SHOW AT TOP OF PAGE
	SUBTTL	Section to skip blocks/pages/lines

SKIPER:	TXNE	P2,FX$COB		;[12]COBOL SIXBIT FILE?
	  GOTO	SKIPE1			;[12]YES--CAN'T SKIP BLOCKS
	MOVE	T1,.FXLEN+$FXBST(P1)	;GET THE BLOCK STARTING POINT
	IFI	(T1,GT,0,THEN)		;IF ANY SET, THEN
	 HRRES	T1			;GET +/- VALUE
	 IFI	(T1,LT,0,THEN)		;IF NEGATIVE BLOCK NUMBER, THEN ...
	  TXNN	F,F.DSK			;[21]IS THE DEVICE A DISK?
	   ERROR NBI			;[21]NO--DON'T ALLOW NEG BLOCK #
	  ADD	T1,BLKSIZ		;COMPUTE ACTUAL BLOCK NUMBER
	 ENDIF
	 IFI	(T1,GT,1,THEN)		;IF IN SETABLE RANGE, THEN ...
IFN TOPS-20,<	; For TOPS-10 and TYMCOM-10 do extended stuff
IFE TOPS-10,<	; TOPS-10 uses SUSET.
	  Or	T1,[Exp <ICHAN>B12]	;[TYM-2] Get proper channel
	  TXNE	F,F.DSK			;[TYM-2]  ... IF DISK, THEN
	    SUSET. T2,			;[TYM-2] USETI
	      Jfcl			;[TYM-2]   Ignore error
    > ; End IFE TOPS-10
IFE TOPS-4,<	; TYMCOM-X uses Chanio
	  PUSH	P,T2			;[TYM-2] Save
	  Move	T2,[.Chfsi,,Ichan]	;[TYM-2] Setup channel
	  TXNE	F,F.DSK			;[TYM-2] ...AND IF DISK, THEN
	   Chanio T2,T1			;[TYM-2] Position to block
	  POP	P,T2			;[TYM-2] Restore this
    > ; End IFE TOSP-4
> ; End IFN TOPS-20
IFE TOPS-20,<	; Leave old code for TOPS-20
	  TXNE	F,F.DSK			;[21]AND IF DISK, THEN
	   USETI ICHAN,(T1)		;SET AS NEXT BLOCK TO INPUT
> ; End IFE TOPS-20
	 ENDIF
	ENDIF
	IFI	(T1,LE,0)		;IS NO START POINT,
SKIPE1:	  MOVEI	T1,1			;  THEN ASSUME BLOCK 1
	SOJ	T1,			;FUDGE THE STARTING BLOCK
	MOVEM	T1,BLOCKN		;AND SAVE FOR INPUT ROUTINE
	MOVEI	T1,1			;GET CONSTANT 1
	MOVEM	T1,PAGEN		;SAVE CURRENT PAGE NUMBER
	MOVEM	T1,LINEN		;SAVE CURRENT LINE #
	SKIPG	T1,.FXLEN+$FXPST(P1)	;GET FIRST PAGE NUMBER
	  MOVEI	T1,1			;DEFAULT TO PAGE 1
	TXNE	P2,FX$COB!FX$OCT!FX$SIX	;[12,34,TYM-3] NON-TEXT FILE?
	  GOTO	SKIPE3			;[12]YES--THEN NO PAGE SKIP ALLOWED
SKIPE2:	IF	(T1,GT,PAGEN,THEN)	;IF NOT ON RIGHT PAGE YET, THEN ...
	 CALL	@INRTN			;GET A BYTE
	  GOTO	FINFIL			;ENF OF FILE RETURN
	 IFI	(C,EQ,.CHFFD)		;IS THIS A PAGE BREAK?
	  AOS	PAGEN			;YES--INCREMENT COUNTER
	 GOTO	SKIPE2			;AND LOOP TILL ON RIGHT PAGE
	ENDIF
SKIPE3:	SKIPG	T1,.FXLEN+$FXLST(P1)	;GET FIRST LINE NUMBER
	  MOVEI	T1,1			;DEFAULT TO LINE 1
SKIPE4:	IF	(T1,GT,LINEN,THEN)	;IF NOT ON RIGHT LINE YET, THEN ...
	 CALL	@INRTN			;GET A BYTE
	  GOTO	FINFIL			;EOF RETURN
	 IFI	(C,EQ,.CHLFD)		;IS THIS A LINE BREAK?
	  AOS	LINEN			;YES--INCREMENT COUNTER
	 GOTO	SKIPE4			;AND LOOP TILL ON RIGHT LINE
	ENDIF
	TXZN	F,F.PWT			;[46]WAITING FOR PAGE POSITIONING?
	  GOTO	TYPFIL			;[46]NO--SKIP AROUND
	INCHRW	T1			;[46]WAIT FOR A CHARACTER TO BE TYPED
	OUTCHR	[.CHCRT]		;[46]EAT UP THE SPACE TYPED WITH A CR
	SUBTTL	Section to type out the file

TYPFIL:	CALL	@INRTN			;GET A BYTE FROM INPUT FILE
	  GOTO	FINFIL			;EOF RETURN
	IFI	(C,EQ,.CHFFD)		;YES--IS THIS CHAR A FORM FEED?
	  AOS	PAGEN			;YES--INCREMENT PAGE COUNTER
	SKIPG	T1,.FXLEN+$FXPEN(P1)	;IS THERE A /PEND LIMIT?
	  GOTO	TYPFI1			;NO--SKIP THIS
	IF	(T1,LT,PAGEN)		;IF ALL DONE
	  GOTO	FINFIL			;  THEN FINISH UP
TYPFI1:	TXNN	F,F.CHK			;[41]ANY SPECIAL CHECKING?
	  GOTO	TYPFI4			;[41]NO--SKIP THIS STUFF
	IFI	(C,EQ,.CHCRT,THEN)	;[41]IF THIS IS A CR, THEN
	 TXO	F,F.BOL			;[41]FLAG AT BEG OF LINE
	 CLEARM	COLCNT			;[42]RESET COLUMN COUNTER
	 GOTO	TYPFI4			;[41]AND OUTPUT THE CR
	ENDIF
	IFI	(C,EQ,.CHLFD,THEN)	;[41]IF CHAR IS A LF, THEN ...
	 LDB	T4,[POINTR (P2,FX$SPC)]	;[41]GET THE SPACING FACTOR
TYPFI3:	 SOJLE	T4,TYPFI4		;[41]SKIP IF JUST SINGLE
	 CALL	OUTC			;[41]SKIP A LINE
	 GOTO	TYPFI3			;[41]AND LOOP FOR ALL
	ENDIF
	CAIE	C,.CHVTB		;[41]IS CHAR A VT OR
	CAIN	C,.CHFFD		;[41]  A FORM-FEED?
	  GOTO	TYPFI4			;[41]YES--JUST DUMP THEM OUT
	TXNN	F,F.COL			;[42]ARE WE DOING COLUMN STUFF?
	  GOTO	TYPFI5			;[42]NO--SKIP THIS STUFF
	AOS	T1,COLCNT		;[42]YES--INCREMENT COUNTER
	IFI	(C,EQ,.CHTAB,THEN)	;[42]IS THE CHARACTER A TAB?
	 ADDI	T1,7			;[42]YES--ROUND UP TO
	 TXZ	T1,7			;[42]  NEXT TAB STOP
	 MOVEM	T1,COLCNT		;[42]AND SAVE RESULT
	ENDIF
;	[INSERT] BACKSPACE CHECKING
	SKIPE	T2,COLBEG		;[42]ANY BEGGINNING LIMIT?
	CAML	T1,T2			;[42]YES--ARE WE IN RANGE?
	CAIA				;[42]YES--ACCEPT CHARACTER
	  GOTO	TYPFIL			;[42]NO--REJECT THE CHARACTER
	SKIPE	T2,COLEND		;[42]ANY ENDING LIMIT?
	CAMG	T1,T2			;[42]YES--ARE WE IN RANGE?
	CAIA				;[42]YES--ACCEPT THE CHARACTER
	  GOTO	TYPFIL			;[42]NO--REJECT THE CHARACTER
TYPFI5:	TXNN	F,F.BOL			;[41]BEGINNING OF A LINE?
	  GOTO	TYPFI4			;[41]NO--SKIP AROUND
	TXNE	P2,FX$LSP		;[41]ARE WE SUPPRESSING LEADING SPACES?
	CAIE	C,.CHSPC		;[41]YES--IS THIS A SPACE?
	CAIA				;[41]NO--PAS IT
	  GOTO	TYPFIL			;[41]YES--IGNORE IT
	TXZ	F,F.BOL			;[41]CLEAR BEG OF LINE FLAG
	LDB	T4,[POINTR (.FXLEN+$FXMD2(P1),FX$IND)];[41]GET # OF SPACES TO INDENT
	IFI	(T4,GT,0,THEN)		;[41]IF ANY INDENTATION, THEN ...
	 PUSH	P,C			;[41]SAVE THE CHARACTER
	 MOVEI	C," "			;[41]AND GET A SPACE
TYPFI2:	 CALL	OUTC			;[41]AND OUTPUT IT
	 SOJG	T4,TYPFI2		;[41]AND LOOP FOR FULL INDENTATION
	 POP	P,C			;[41]RESTORE CHARACTER
	ENDIF
TYPFI4:	CALL	OUTC			;OUTPUT THIS BYTE
	SKIPG	T1,.FXLEN+$FXLEN(P1)	;IS THERE A /LEND LIMIT?
	  GOTO	TYPFIL			;NO--GO GET NEXT CHARACTER
	IFI	(C,EQ,.CHLFD)		;YES--IS THIS A LINE BREAK?
	  AOS	LINEN			;YES--INCREMENT LINE COUNTER
	IF	(T1,GE,LINEN)		;IF STILL MORE TO GO,
	  GOTO	TYPFIL			;  THEN LOOP TILL END OF FILE
					;ELSE FALL THRU TO FINISH UP
	SUBTTL	Section to finish up after typing a file

FINFIL:	SKIPGE	S.PAUSE			;[54,60] ARE WE PAUSING OR
	TXNE	F,F.PAG			;[60] ARE WE PAGING?
	  GOTO	FINFI2			;[60] YES--GO DO FORM FEED
	TXNN	F,F.TTA			;[60] OUTPUTTING TO ATTACHED TTY?
	  GOTO	FINFI3			;[60] NO--SKIP EXTRA CR-LF
	MOVEI	T1,.CHCRT		;GET A CARRIAGE RETURN
	CALL	OUTBYT			;OUTPUT IT
	MOVEI	T1,.CHLFD		;AND GET A LINE FEED
	CALL	OUTBYT			;OUTPUT IT
	GOTO	FINFI3			;[60] SKIP AROUND FORM-FEED
FINFI2:	MOVEI	T1,.CHFFD		;GET A FORM FEED CHARACTER
	CALL	OUTBYT			;FORM TO NEXT PAGE
FINFI3:	TXNE	P2,FX$ENM		;/ENAME SET?
	  CALL	I$$NAM			;YES--PUT NAME AT END OF FILE
	MOVEI	T1,.CHFFD		;[TYM-4] GET A FORM FEED CHARACTER
	SKIPLE	S.DEVICE		;[TYM-4] FOREIGN DEVICE?
	  CALL	OUTBYT			;[TYM-4] FORM TO NEXT PAGE
	TXNE	F,F.TMP			;[32]WAS THIS A TMPCOR: FILE?
	  GOTO	TMPNXT			;[32]YES--GO DO SPECIAL PROCESSING
FINFI1:	TXNE	P2,FX$ACC		;/ACCESS SET?
	  CLOSE	ICHAN,			;YES--UPDATE INPUT FILE ACCESS DATE
	TXNN	P2,FX$ACC		;/NOACCESS SET?
	  CLOSE	ICHAN,CL.ACS		;YES--DON'T UPDATE ACCESS DATE
	RELEASE	ICHAN,			;GET RID OF INPUT FILE
	SKIPLE	T1,S.DEVICE		;[TYM-4] FOREIGN DEVICE?
	  CALL	FR$DEV			;[TYM-4] PRINT TO TTY
	GOTO	NXTFIL			;AND TRY FOR ANOTHER FILE
	SUBTTL	Section to process TMPCOR files

TRYTMP:	HLRZ	T1,OPNBLK+.OPDEV	;[24]GET DEVICE NAME
	CAIE	T1,'TMP'		;[24]IS IT TMPCOR LIKE?
	  GOTO	[XCALL	E.DFO		;[24]NO--ERROR--TELL USER
		 GOTO	NXTFIL]		;[24]AND TRY NEXT FILE
	TXO	F,F.TMP!F.TNF		;[32]FLAG WE ARE PROCESSING TMPCOR: & NO FILE FND
	MOVE	T1,['TMPCOR']		;[32]GET AND SAVE DEVICE NAME
	MOVEM	T1,OPNBLK+.OPDEV	;[32]  FOR ANY TYPE OUTS
	CLEARM	LKPBLK+.RBEXT		;[32]EXTENSION IS MEANINGLESS
	CLEARM	LKPBLK+.RBPPN		;[32]SO IS THE DIRECTORY
	MOVE	T1,[.TCRRD,,[0
			     IOWD TMPMAX,TMPDIR]]
	TMPCOR	T1,			;[32]READ TMPCOR: DIRECTORY
	  GOTO	ERR(NTD)		;[32]ERROR--NOT IMPLEMENTED
	JUMPLE	T1,W$$TDE		;[33]WARN USER IF TMPCOR DIR IS EMPTY
	IFI	(T1,GT,TMPMAX)		;[32]IF DIRECTORY OVERFLOW
	  ERROR	MFT			;[32]  THEN WARN USER
	MOVNI	T1,1(T1)		;[32]GET -# OF FILES + 1
	HRLZS	T1			;[32]PUT IN LH
	HRRI	T1,TMPDIR-1		;[32]AND POINT TO DIRECTORY
	MOVEM	T1,TMPPTR		;[32]AND SAVE DIRECTORY IOWD
	SUBTTL	SECTION TO FIND THE NEXT TMPCOR: FILE [32]

TMPNXT:	MOVE	T1,TMPPTR		;POINT TO THE DIRECTORY
	MOVE	T2,.FXNAM(P1)		;GET THE CURRENT FILENAME
	AND	T2,.FXNMM(P1)		;AND MASK IT
TMPNX1:	AOBJP	T1,TMPNX2		;IF END OF DIRECTORY--GET OUT
	HLLZ	T3,(T1)			;GET THE NEXT DIRECTORY ENTRY
	MOVEM	T3,LKPBLK+.RBNAM	;SAVE FOR ERRORS
	AND	T3,.FXNMM(P1)		;MASK IT
	IF	(T2,NE,T3)		;IF IT DOESN'T MATCH, THEN
	  GOTO	TMPNX1			;  GO TRY THE NEXT ENTRY
	TXZ	F,F.TNF			;FLAG WE FOUND A FILE
	MOVEM	T1,TMPPTR		;SAVE TMPCOR: DIRECTORY POINTER
	HLLZ	T3,(T1)			;GET THE FILE NAME
	MOVE	T4,[IOWD TMFMAX,TMPFIL]	;POINT TO FILE AREA
	MOVE	T2,[XWD .TCRRF,T3]	;SETUP READ CODE
	TMPCOR	T2,			;READ THE FILE
	  GOTO	[ERROR	(TNF)		;[33]ERROR--TELL USER
		 GOTO	TMPNXT]		;AND TRY NEXT
	IFI	(T2,GT,TMFMAX)		;IF FILE WAS TOO LARGE THEN,
	  ERROR	TTL			;  WARN USER
	TXNE	P2,FX$OCT		;IF /OCTAL THEN
	  IMULI	T2,14			;  12. BYTES/WORD
	TXNE	P2,FX$SIX		;[TYM-3] IF /SIXBIT THEN
	  IMULI	T2,6			;[TYM-3]   6. BYTES/WORD
	TXNE	P2,FX$KAT		;[TYM-3] IF /KATAKANA THEN
	  IMULI T2,4			;[TYM-3]   4. BYTES/WORD
	TXNN	P2,FX$BYT		;[TYM-3] IF NOT SPECIAL-MODE, THEN
	  IMULI	T2,5			;CONVERT TO BYTE COUNT
	MOVEM	T2,FILHDR+.BFCTR	;AND SAVE IT
	MOVE	T1,[POINT 7,TMPFIL]	;GET TMPFILE POINTER
	TXNE	P2,FX$KAT		;[TYM-3] IF KATAKANA MODE, THEN
	  HRLI	T1,(POINT 9)		;[TYM-3]  CHANGE BYTE POINTER
	TXNE	P2,FX$COB		;IF COBOL SIXBIT, THEN
	  HRLI	T1,(POINT 36)		;  CHANGE BYTE POINTER
	MOVEM	T1,FILHDR+.BFPTR	;AND SAVE IT
	PGOTO	INIFI2			;[33]SET INPUT MODE AND TYPE OUT THE FILE

TMPNX2:	MOVE	T1,.FXNAM(P1)		;GET BACK NAME
	MOVEM	T1,LKPBLK+.RBNAM	;AND SAVE IN CASE ERRORS
	TXZE	F,F.TNF			;DID WE FIND ANYTHING?
	  ERROR	TNF			;[33]NO--TELL USER
	GOTO	NXTFIL			;AND BACK FOR NEXT FILE
	SUBTTL	TO$DEV	Routine to direct output to a foreign device [TYM-4]

;	CALLING SEQUENCE:
;		CALL	TO$DEV
;		<ONLY RETURN>
;
;	AC'S CHANGED:  --NONE--  (See .TSTRG)

TO$DEV:	TXNN	F,F.TTY			; MAKE SURE IT'S A TTY
	  RETURN			; NO!  DON'T DO ANYTHING
	CAILE	T1,DEVLEN		; WITHIN SUPPORTED RANGE?
	  RETURN			; NO!  DON'T DO ANYTHING
	PUSH	P,T1			; SAVE WORKING REGISTER
	SKIPE	T1,DVTTAB-1(T1)		; ANYTHING FOR POINT?
	  XCALL	.TSTRG			; YES, PRINT TO DEVICE
	MOVE	T1,(P)			; GET DEVICE INDEX
	SKIPN	T1,HZPTAB-1(T1)		; CAN DEV DO HORIZ PITCH?
	  JRST	TO$VTP			; NO, SO DO NEXT STEP
	PUSH	P,T1			; SAVE AGAIN
	LDB	T1,[POINTR(.FXLEN+$FXMD3(P1),FX$HZP)]
	ADD	T1,(P)			; INDEX INTO TABLE
	POP	P,(P)			; RESET STACK
	SKIPE	T1,(T1)			; SKIP IF HORIZ PITCH NOT AVAIL
	  XCALL	.TSTRG			; SET PITCH
TO$VTP:	MOVE	T1,(P)			; GET DEVICE INDEX
	SKIPN	T1,VTPTAB-1(T1)		; CAN DEV DO VERT PITCH?
	  JRST	TO$VFM			; NO, SO RETURN
	PUSH	P,T1			; SAVE AGAIN
	LDB	T1,[POINTR(.FXLEN+$FXMD3(P1),FX$VTP)]
	ADD	T1,(P)			; INDEX INTO TABLE
	POP	P,(P)			; RESET STACK
	SKIPE	T1,(T1)			; SKIP IF VERT PITCH NOT AVAIL
	  XCALL	.TSTRG			; SET PITCH

TO$VFM:	;; <> INSERT HERE -- CODE FOR SETTING FORMS LENGTH

TO$RET:	POP	P,T1			; RESTORE REGISTER
	RETURN

	SUBTTL	FR$DEV	Routine to direct output to the tty [TYM-4]

;	CALLING SEQUENCE:
;		CALL	FR$DEV
;		<ONLY RETURN>
;
;	AC'S CHANGED:  NONE

FR$DEV:	TXNN	F,F.TTY			; MAKE SURE IT'S A TTY
	  RETURN			; NO!  DON'T DO ANYTHING
	CAILE	T1,DEVLEN		; WITHIN SUPPORTED RANGE?
	  RETURN			; NO!  DON'T DO ANYTHING
	PUSH	P,T1			; SAVE WORKING REGISTER
	SKIPN	T1,HZPTAB-1(T1)		; CAN DEV DO HORIZONTAL PITCH?
	  JRST	FR$VTP			; NO, TRY VERTICAL
	SKIPE	T1,(T1)			; DO WE HAVE A DEFAULT?
	  XCALL	.TSTRG			; YES, SET HORIZONTAL PITCH
FR$VTP:	MOVE	T1,(P)			; GET DEVICE INDEX
	SKIPN	T1,VTPTAB-1(T1)		; CAN DEV DO VERTICAL PITCH?
	  JRST	FR$FIN			; NO, FINISH UP
	SKIPE	T1,(T1)			; DO WE HAVE A DEFAULT?
	  XCALL	.TSTRG			; YES, SET VERTICAL PITCH
FR$FIN:	MOVE	T1,(P)			; GET DEVICE INDEX
	SKIPE	T1,DVFTAB-1(T1)		; POINT TO DEVICE STRING
	  XCALL	.TSTRG			; PRINT TO DEVICE
FR$RET:	POP	P,T1			; RESTORE REGISTER
	RETURN

	SUBTTL	DEVICE INFO TABLES [TYM-4]

; DEVICE CHARACTERISTICS

	DV$HZT==  1B0			; HORIZONTAL TABS
	DV$VTT==  1B1			; VERTICAL TABS
	DV$FF==   1B2			; FORM FEEDS
	DV$HZP==  1B3			; HORIZONTAL PITCH
	DV$VTP==  1B4			; VERTICAL PITCH
	DV$FRM==  1B5			; SET FORM LENGTH
	DV$HLN==  1B6			; HALF LINE UP/DOWN
	DV$PLT==  1B7			; PLOT MODE UP/DOWN
	DV$UND==  1B8			; UNDERLINE
	DV$BLD==  1B9			; BOLD
	DV$DEN==  3B11			; MULTI-DENSITY
	DV$CHR== 77B17			; MULTI-CHARACTER SETS
	DV$ALT==  7B20			; ALTERNATE CHARACTER SETS
	DV$GRF==  1B21			; GRAPHIC MODE


DVCTAB:	Z				; DUMB TTY
	DV$HZP!DV$VTP!DV$FRM!DV$CHR	; LA50 CHARACTERISTICS
	DV$HZP!DV$VTP!DV$FRM		; TI-820 CHARACTERISTICS
	DV$CHR				; SCANSET CHARACTERISTICS (?)
	DV$HZP!DV$DEN			; ADM-11P CHARACTERISTICS (?)
DEVLEN==.-DVCTAB			; USE FOR LENGTH OF TABLE

DVTTAB:	Z				; DUMB TTY
	[BYTE (7) 33,"[","5","i",0]	; LA50 SETUP SEQUENCE
	Z				; TI-820 SETUP SEQUENCE
	[BYTE (7) 33,";","4",0,0]	; SCANSET SETUP SEQUENCE
	[BYTE (7) 33,"A","1",0,0]	; ADM-11P SETUP SEQUENCE

DVFTAB:	Z				; DUMB TTY
	[BYTE (7) 33,"[","0",";","m"	; LA50 RESET SEQUENCE
	 BYTE (7) 33,"[","4","i",0]
	Z				; TI-820 RESET SEQUENCE
	[BYTE (7) 33,";","0",0,0]	; SCANSET RESET SEQUENCE
	[BYTE (7) 33,"A","0",0,0]	; ADM-11P RESET SEQUENCE

HZPTAB:	Z				; DUMB TTY
	HPLA50				; LA50 HORIZONTAL PITCH
	HPT820				; TI-820 HORIZONTAL PITCH
	Z	;HPSCLP			; SCANSET HORIZONTAL PITCH
	HPLS11				; ADM-11P HORIZONTAL PITCH

VTPTAB:	Z				; DUMB TTY
	VPLA50				; LA50 VERTICAL PITCH
	VPT820				; TI-820 VERTICAL PITCH
	Z	;VPSCLP			; SCANSET VERTICAL PITCH
	Z	;VPLS11			; ADM-11P VERTICAL PITCH

SUBTTL	Horizontal pitch tables

HPLA50:	[BYTE (7) 33, "[", "0", "w", 0]	; Default PITCH = 10
	[BYTE (7) 33, "[", "5", "w", 0]	; PITCH = 5
	[BYTE (7) 33, "[", "6", "w", 0]	; PITCH = 6
	[BYTE (7) 33, "[", "8", "w", 0]	; PITCH = 8
	[BYTE (7) 33, "[", "0", "w", 0]	; PITCH = 10
	[BYTE (7) 33, "[", "2", "w", 0]	; PITCH = 12
	[BYTE (7) 33, "[", "4", "w", 0]	; PITCH = 16
	[BYTE (7) 33, "[", "0", "w", 0]	; Default PITCH = 10

HPT820:	[BYTE (7) 33,"P","C",33,"\",0]	; Default PITCH = 10
	[BYTE (7) 33,"P","I",33,"\",0]	; PITCH = 5
	Z				; PITCH = 6
	[BYTE (7) 33,"P","J",33,"\",0]	; PITCH = 8
	[BYTE (7) 33,"P","C",33,"\",0]	; PITCH = 10
	Z				; PITCH = 12
	[BYTE (7) 33,"P","D",33,"\",0]	; PITCH = 16
	[BYTE (7) 33,"P","C",33,"\",0]	; Default PITCH = 10

HPLS11:	[BYTE (7) 33, "E", 0, 0, 0]	; Default PITCH = 12
	[BYTE (7) 33, "P", 0, 0, 0]	; PITCH = 5 (proportional)
	Z				; PITCH = 6
	Z				; PITCH = 8
	[BYTE (7) 33, "N", 0, 0, 0]	; PITCH = 10
	[BYTE (7) 33, "E", 0, 0, 0]	; PITCH = 12
	[BYTE (7) 33, "Q", 0, 0, 0]	; PITCH = 16
	[BYTE (7) 33, "E", 0, 0, 0]	; Default PITCH = 12

SUBTTL	Vertical pitch tables

VPLA50:	[BYTE (7) 33, "[", "0", "z", 0]	; Default PITCH = 6
	[BYTE (7) 33, "[", "4", "z", 0]	; PITCH = 2
	[BYTE (7) 33, "[", "5", "z", 0]	; PITCH = 3
	[BYTE (7) 33, "[", "6", "z", 0]	; PITCH = 4
	[BYTE (7) 33, "[", "0", "z", 0]	; PITCH = 6
	[BYTE (7) 33, "[", "2", "z", 0]	; PITCH = 8
	[BYTE (7) 33, "[", "3", "z", 0]	; PITCH = 12
	[BYTE (7) 33, "[", "0", "z", 0]	; Default PITCH = 6

VPT820:	[BYTE (7) 33,"P","A",33,"\",0]	; Default PITCH = 6
	Z				; PITCH = 2
	[BYTE (7) 33,"P","B",33,"\",0]	; PITCH = 3
	[BYTE (7) 33,"P","G",33,"\",0]	; PITCH = 4
	[BYTE (7) 33,"P","A",33,"\",0]	; PITCH = 6
	[BYTE (7) 33,"P","H",33,"\",0]	; PITCH = 8
	Z				; PITCH = 12
	[BYTE (7) 33,"P","A",33,"\",0]	; Default PITCH = 6

	SUBTTL	CLRANS - Routine to setup all switches

CLRANS:	STORE	T1,S.ZER,S.EZER,0	;CLEAR FILE STUFF
	STORE	T1,S.MIN,S.EMIN,-1	;PRESET ALL SWITCHES
	MOVEI	T1,TXTBLK		;[16]POINT TO TEXT BLOCK
	MOVEM	T1,TXTPTR		;[16]TO REINITILIZE POINTER
	HRRZ	T1,ORGFF		;RESTORE ORIGINAL VALUE
	MOVEM	T1,.JBFF		;  OF .JBFF
	MOVEM	T1,I.IOZR		;  USE AS ADR FOR FIRST FILE SPEC
	MOVEM	T1,I.NXZR		;  AND FOR NEXT FILE SPEC
	HLRZ	T1,ORGFF		;RESTORE .JBREL
	CAME	T1,.JBREL		;  UNLESS OK
	CORE	T1,			;    TELL MONITOR
	  NOP				;      (IGNORE ERROR)
	RETURN


	SUBTTL	CLRFIL - Routine to clear out a single file spec

CLRFIL:	STORE	T1,F$ZER,F$EZER,0	;CLEAR FILE MODE WORDS
	STORE	T1,F$MIN,F$EMIN,-1	;PRESET FILE SWITCHES
	RETURN


	SUBTTL	CLRSTK - Routine to clear out sticky file defaults

CLRSTK:	STORE	T1,P$ZER,P$EZER,0	;CLEAR FILE MODE WORDS
	STORE	T1,P$MIN,P$EMIN,-1	;PRESET FILE SWITCHES
	RETURN
	SUBTTL	AOUT   - Routine to allocate the output file area

AOUT:	MOVEI	T1,OUTSCN		;POINT TO OUTPUT SCAN BLOCK
	MOVEI	T2,.FXLEN		;GET SPEC LENGTH
	RETURN


	SUBTTL	AIN    - Routine to allocate input file areas

AIN:	MOVEI	T2,.FXLEN+$FXSIZ	;GET NUMBER OF WORDS FOR SPEC
	ADDM	T2,I.NXZR		;POINT TO NEXT FILE AREA
	CALL	MORCOR			;GET THE SPACE
	MOVEI	T3,.FXLEN(T1)		;GET ADR OF OUR PART
	HRLI	T3,F$ZER		;PUT IN FROM PART
	BLT	T3,.FXLEN+$FXSIZ(T1)	;COPY OUR PART
	MOVEI	T2,.FXLEN+$FXSIZ	;RETURN SIZE IN T2
	RETURN
	SUBTTL	FILSTK - Routine to memorize sticky defaults

FILSTK:	MOVEI	T1,F$ZER		;SETUP FILE AREA POINTER
	MOVEI	T2,P$ZER		;SETUP PERMANENT AREA  POINTER
FILST1:	MOVE	T3,(T1)			;GET NEW MODE WORD
	MOVE	T4,1(T1)		;GET THE NEW MODE MASK
	ANDCAM	T4,(T2)			;CLEAR NEW PERMANENT BITS
	IORM	T3,(T2)			;OR IN NEW BIT VALUES
	IORM	T4,1(T2)		;OR IN NEW MASK BITS
	ADDI	T1,2			;POINT TO NEXT MODE/MASK
	ADDI	T2,2			;...
	CAIG	T1,F$EZER		;DONE WITH MODE MASK WORDS?
	  GOTO	FILST1			;NO--CONTINUE FOR NEXT
FILST2:	SKIPL	T3,(T1)			;GET VALUE
	MOVEM	T3,(T2)			;IF THERE--STORE IT
	AOJ	T1,			;POINT TO NEXT SWITCH
	CAIG	T1,F$EMIN		;ALL DONE ?
	  AOJA	T2,FILST2		;NO--DO NEXT SWITCH
	RETURN
	SUBTTL	APLSTK - Routine to apply sticky defaults

APLSTK:	MOVEI	T1,F$ZER		;SETUP FILE AREA POINTER
	MOVEI	T2,P$ZER		;SETUP PERMANENT AREA POINTER
APLST1:	MOVE	T3,(T2)			;GET STICKY FILE SWITCHES
	ANDCM	T3,1(T1)		;MASK OUT NEW ONES
	IORM	T3,(T1)			;AND STORE NEW SWITCHES
	MOVE	T3,1(T2)		;GET PERMENENT MASK
	IORM	T3,1(T1)		;AND FIX FILE MASK
	ADDI	T1,2			;POINT TO NEXT MODE/MASK
	ADDI	T2,2			;...
	CAIG	T1,F$EZER		;DONE WITH MODE/MASK WORDS?
	  GOTO	APLST1			;[65] NO--CONTINUE TO NEXT
APLST2:	MOVE	T3,(T2)			;GET PERMANENT VALUE
	SKIPGE	(T1)			;WAS A NEW VALUE GIVEN?
	MOVEM	T3,(T1)			;NO--USE STICKY VALUE
	AOJ	T1,			;POINT TO NEXT SWITCH
	CAIG	T1,F$EMIN		;ALL DONE?
	  AOJA	T2,APLST2		;NO--DO NEXT SWITCH
	RETURN
	SUBTTL	.SWRNG - Routine to process a range switch

	SWP==1				;OFFSET TO STORAGE POINTER

.SWRNG:	XCALL	.SWDEC			;GET START VALUE OF THE RANGE
	MOVE	T1,@SWP(P2)		;GET ADR OF STORAGE + 1
	SKIPL	-1(T1)			;WAS A VALUE GIVEN ALREADY?
	  PGOTO	E.DSI##			;YES--DUPLICATE ERROR
	MOVEM	N,-1(T1)		;NO--STORE VALUE
	IFI	(C,EQ,.CHCOL)		;IF SECOND VALUE PRESENT, THEN
	 XCALL	.SWDEC			;GET FINAL VALUE OF RANGE
					;ELSE USE THE FIRST VALUE
	RETURN				;AND STORE VALUE


SWRNGN:	CALL	SWDECN			;GET START VALUE OF THE RANGE
	MOVE	T1,@SWP(P2)		;GET ADR OF STORAGE + 1
	SKIPL	-1(T1)			;WAS A VALUE GIVEN ALREADY?
	  PGOTO	E.DSI##			;YES--DUPLICATE ERROR
	MOVEM	N,-1(T1)		;NO--STORE VALUE
	IFI	(C,EQ,.CHCOL)		;IF SECOND VALUE PRESENT, THEN
	 CALL	SWDECN			;GET FINAL VALUE OF RANGE
					;ELSE USE THE FIRST VALUE
	RETURN				;AND STORE VALUE
	SUBTTL	.SWPSE - Routine to process a PAUSE switch [54]

.SWPSE:	XCALL	.SWDEC			; GET NUMBER OF BELLS TO TYPE
	MOVE	T1,@SWP(P2)		; GET ADDRESS OF STORAGE+1
	MOVEM	N,-1(T1)		; STORE NUMBER OF BELLS
	MOVEI	N,PD.PSS		; GET PRESENT TIME DEFAULT
	IFI	(C,EQ,.CHCOL)		; IF SECOND VALUE PRESENT,
	  XCALL	.SWDEC			; GET IT
	RETURN				; TO STORE RESULT OR DEFAULT
	SUBTTL	.SWCOL - ROUTINE TO READ A COLUMN SWITCH [42]

.SWCOL:	XCALL	.SWDEC			;GET INITIAL COLUMN
	LSH	N,11			;SHIFT OVER 9. PLACES
	PUSH	P,N			;SAVE IT
	CLEAR	N,			;CLEAR N INCASE ONLY FIRST VAL
	IFI	(C,EQ,.CHCOL)		;IF A COLAN, THEN ...
	  XCALL	.SWDEC			;GET FINAL COLUMN
	POP	P,T1			;GET BACK INITIAL VALUE
	IOR	N,T1			;AND OR IT IN
	RETURN				;AND STORE THE VALUE

;	NOTE: SECOND VALUE NOT RANGE CHECKED.
	SUBTTL	SWDECN - Routine to process a decimal +/- switch
;			RANGE: [-377777:377777]

SWDECN:	XCALL	.DECNW			;GET THE DECIMAL SWITCH
	CLEARM	NEGFLG			;CLEAR NEGATIVE FLAG
	JUMPGE	N,SWDEC1		;JUMP AROUND IF POSITIVE VALUE
	SETOM	NEGFLG			;ELSE SET FLAG
	MOVMS	N			;AND GET ABSOLUTE VALUE
SWDEC1:	CAILE	N,MX.RNB		;IS SWITCH TOO LARGE?
	  PGOTO	E.SVTL##		;YES--OUTPUT ERROR MESSAGE
	SKIPL	NEGFLG			;IF A POSITIVE SWITCH,
	  RETURN			;JUST RETURN
	MOVNS	N			;ELSE CONVERT TO NEGATIVE NUMBER
	HRRZS	N			;AND USE LOWER HALF ONLY
	RETURN
	SUBTTL	.SWTXT - Routine to process a text switch [16]

.SWTXT:	XCALL	.ASCQW			;GET THE ASCIZ ARG
	MOVE	T1,TXTPTR		;GET NEXT FREE TEXT ADR
	MOVEI	T2,.NMUL##		;POINT TO SCAN TEXT BUFFER
SWTXT1:	AOJ	T1,			;INCREMENT STORAGE AREA POINTER
	CAIL	T1,E.TEXT		;IF END OF OUR TEXT BUFFER,
	  ERROR	TBO			;  ERROR--TEXT BUFFER OVERFLOW
	MOVE	T3,(T2)			;GET THE NEXT WORD
	MOVEM	T3,(T1)			;AND SAVE IT
	TXNE	T3,377			;END OF ASCIZ STRING?
	  AOJA	T2,SWTXT1		;NO--LOOP FOR ALL OF STRING
	SUBI	T2,.NMUL##-1		;COMPUTE # OF WORDS
	IMULI	T2,5			;COMPUTE # OF CHARACTERS
	SOJ	T2,			;FIX COUNT FOR .ASCIZ
	TXNN	T3,177B28		;NEXT CHARACTER THERE?
	  SOJ	T2,			;NO--ACCOUNT FOR IT
	TXNN	T3,177B21		;NEXT CHAR THERE?
	  SOJ	T2,			;NO--ACCOUNT FOR IT
	TXNN	T3,177B14		;NEXT CHAR THERE?
	  SOJ	T2,			;NO--ACCOUNT FOR IT
	TXNN	T3,177B7		;NEXT CHAR THERE?
	  SOJ	T2,			;NO--ACCOUNT FOR IT
	MOVE	N,TXTPTR		;GET BACK THE TEXT ADR
	MOVEM	T2,(N)			;SAVE THE CHARACTER COUNT
	AOJ	T1,			;POINT TO NEXT FREE ADR
	MOVEM	T1,TXTPTR		;RESET THE TEXT POINTER
	RETURN				;AND STORE THE ADR
	SUBTTL	.SWCRP - Routine to process a /CRYPT switch [22]

.SWCRP:	XCALL	.ASCQW			;GET THE ASCII ARGUEMENT
	MOVEM	6,SAVACS+6		;SAVE ACS
	MOVEI	6,SAVACS		;  0 THRU
	BLT	6,SAVACS+5		;    6
	MOVEI	7,.NMUL##		;POINT TO ASCIZ TEXT
	XCALL	CRASZ.			;AND GET THE ENCRYPTION SEED
	MOVE	N,5			;SAVE IT IN N (AC7)
	MOVSI	6,SAVACS		;RESTORE ACS
	BLT	6,6			;  0 THRU 6
	RETURN				;AND RETURN TO STORE SEED
	SUBTTL	.SWNDC - Routine to process a positive switch [26]
;			which is converted to a half-word negative

.SWNDC:	XCALL	.SWDEC			;GET THE DECIMAL SWITCH
	JUMPLE	N,.POPJ##		;JUST RETURN TO STORE IF <=0
	MOVNS	N			;ELSE GET ITS NEGATIVE
	HRRZS	N			;AND SAVE ONLY LOWER HALF
	RETURN				;AND STORE RESULT
	SUBTTL	GETFOR - Routine to read a byte from FORTRAN data files [13]

;	CALLING SEQUENCE:
;		CALL	GETFOR
;		<EOF RETURN (LOGICAL OR PHYSICAL)>
;		<NORMAL RETURN WITH CHAR IN C>
;
;	ACS CHANGED: C

GETFOR:	MOVEI	C,GETFO1		;ONCE ONLY ENTRY
	MOVEM	C,INRTN			;SET NEW ENTRY POINT
	GOTO	GETFO2			;AND SKIP AROUND

GETFO1:	CALL	GETBYT			;GET THE NEXT BYTE
	  RETURN			;EOF RETURN
	IFI	(C,NE,.CHLFD)		;IS CHAR A LINE-FEED?
	  PGOTO	.POPJ1##		;NO--JUST NORMAL RETURN CHAR
GETFO2:	CALL	GETBYT			;GET CARRIAGE CONTROL CHARACTER
	  RETURN			;EOF RETURN
	IFI	(C,EQ,.CHSPC)		;IF CONTROL IS A SPACE,
	  GOTO	GETFO4			;  THEN JUST CHANGE TO LF
	CAIG	C,"3"			;IS IT A VALID CONTROL-CHAR?
	CAIGE	C,"*"			;....
	  GOTO	GETFO4			;NO--JUST CHANGE TO LF
	IFI	(C,EQ,"*")		;[15]IF SPECIAL CASE OF "*"
	  GOTO	[TXO	F,F.SFM		;[15]  THEN SUPPRESS FORM-FEED
		 GOTO	GETFO4]		;[15]  AND CHANGE TO LF
	CAIG	C,"."			;LEFT HALF?
	SKIPA	C,FORTAB-<"*">(C)	;NO--RIGHT HALF
	MOVS	C,FORTAB-<"/">(C)	;YES--LEFT HALF
	TRNE	C,400000		;SPECIAL CONTROL CHARACTER?
	  GOTO	[ANDI	C,377		;YES--ISOLATE IT
		 PGOTO	.POPJ1##]	;  AND RETURN IT
	HRRZM	C,FORCNT		;NO--SAVE THE LF COUNT
	MOVEI	C,GETFO3		;GET NEW PLACE TO JUMP
	MOVEM	C,INRTN			;AND SAVE IT
GETFO3:	SOSGE	FORCNT			;MORE LF'S TO OUTPUT?
	  GOTO	GETFO5			;NO--CLEAN UP
GETFO4:	MOVEI	C,.CHLFD		;YES--GET A LINE FEED
	RETURN	1			;AND RETURN IT
GETFO5:	MOVEI	C,GETFO1		;RESET INPUT ROUTINE
	MOVEM	C,INRTN			;  TO STANDARD
	PGOTO	GETFO1			;AND GET NEXT CHAR

FORTAB:	XWD	    12,400012		; /  *
	XWD	     2,0		; 0  +
	XWD	400014,2		; 1  ,
	XWD	    36,3		; 2  -
	XWD	    24,3		; 3  .
	SUBTTL	GETSIX - Routine to read a byte from SIXBIT file [12]

;	CALLING SEQUENCE:
;		CALL	GETSIX
;		<EOF RETURN (LOGICAL OR PHYSICAL)>
;		<NORMAL RETURN WITH CHAR IN C>
;
;	ACS CHANGED: C

GETSIX:	AOS	C,BYTBYT		;INCREMENT BYTE COUNTER
	IFI	(C,LE,6,THEN)		;IF NOT END OF WORD, THEN
	 CALL	GETBYT			;GET NEXT BYTE
	  RETURN			;EOF RETURN
	 ADDI	C," "			;CONVERT TO ASCII
	 PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	ENDIF				;ELSE IF END OF WORD, THEN
	AOS	C,BYTWRD		;COUNT OFF THE WORDS
	IF	(C,LT,BYTMAX,THEN)	;IF STILL ROOM ON LINE, THEN ...
	 CLEARM	BYTBYT			;CLEAR THE BYTE COUNTER
	 PGOTO	GETSIX			;AND RETURN GETTING ANOTHER CHAR
	ENDIF				;ELSE FINISH UP THE LINE
	IF	(C,EQ,BYTMAX,THEN)	;IF JUST FINISHED LAST WORD, THEN
	 MOVEI	C,.CHCRT		;GET A CARRIAGE RETURN AND
	 PGOTO	.POPJ1##		;TAKE GOOD SKIP RETURN
	ENDIF				;ELSE FINISH LINE
	CLEARM	BYTBYT			;RESET THE BYTE COUNTER
	CLEARM	BYTWRD			;AND RESET THE WORD COUNTER
	MOVEI	C,.CHLFD		;GET A LINE-FEED
	PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	SUBTTL	GETCOB - Routine to read a byte from COBOL file [12]

;	CALLING SEQUENCE:
;		CALL	GETCOB
;		<EOF RETURN (LOGICAL OR PHYSICAL)>
;		<NORMAL RETURN WITH CHAR IN C>
;
;	ACS CHANGED: C

GETCOB:	MOVEI	C,GETCO2		;[14]ONCE ONLY CODING
	MOVEM	C,INRTN			;[14]SET NEXT PROCESSOR ADR
	CALL	GETBYT			;[14]GET THE FIRST WORD
	  RETURN			;[14]EOF RETURN
	HLRZS	C			;[14]GET LEFT HALF
	IFI	(C,NE,'HDR')		;[14]IF NO HEADER RECORD PRESENT,
	  GOTO	[LDB	C,FILHDR+.BFPTR	;[14]  GET BACK THE FULL WORD
		 GOTO	GETCO4]		;[14]  AND GO PROCESS AS A RECORD
	PUSH	P,[15]			;[14]ELSE SETUP A COUNTER
GETCO1:	CALL	GETBYT			;[14]DISCARD A WORD AT A TIME
	  GOTO	[POP	P,(P)		;[14]EOF--FIX STACK
		 RETURN
			]		;[14]AND RETURN
	SOSLE	(P)			;[14]DECREMENT COUNTER
	  GOTO	GETCO1			;[14]  LOOP TILL DONE
	POP	P,(P)			;[14]FIX UP THE PDL
GETCO2:	TXNE	F,F.REC			;ARE WE CURRENTLY PROCESSING A RECORD?
	  GOTO	GETCO5			;YES--SKIP HEADER WORD CODE
GETCO3:	CALL	GETBYT			;NO--GET THE NEXT WORD
	  RETURN			;EOF RETURN
GETCO4:	ANDI	C,7777			;[14]MASK TO 12 BITS
	JUMPLE	C,GETCO3		;[14]IGNORE ZERO COUNTS
	HRRZM	C,RECCNT		;ISOLATE AND SAVE THE RECORD COUNT
	CLEARM	WRDCNT			;SHOW WE HAVE NO WORD READY
	TXO	F,F.REC			;FLAG RECORD IN PROGRESS
						CONT.
GETCO5:	IFI	(RECCNT,GT,0,THEN)	;IF MORE DATA IN RECORD, THEN ...
	 SOSL	C,WRDCNT		;ANY PART OF WORD READY?
	  GOTO	GETCO6			;YES--DON'T HAVE TO READ
	 CALL	GETBYT			;NO--GET THE NEXT DATA WORD
	  RETURN			;EOF RETURN
	 MOVEM	C,BYTWRD		;SAVE THE NEW WORD IN BUFFER
	 MOVEI	C,5			;RESET THE WORD COUNTER
	 MOVEM	C,WRDCNT		;AND SAVE FOR LATER USE
GETCO6:	 LDB	C,[POINT 6,BYTWRD,35
		   POINT 6,BYTWRD,29
		   POINT 6,BYTWRD,23
		   POINT 6,BYTWRD,17
		   POINT 6,BYTWRD,11
		   POINT 6,BYTWRD,5](C)	;GET THE NEXT BYTE OF DATA
	 MOVEI	C," "(C)		;CONVERT TO ASCII
	 SOS	RECCNT			;DECREMENT THE RECORD COUNTER
	 PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	ENDIF
	IFI	(RECCNT,EQ,0,THEN)	;IF TIME FOR CR, THEN ...
	 MOVEI	C,.CHCRT		;GET THE CARRIAGE RETURN CODE
	 SOS	RECCNT			;DECREMENT THE RECORD COUNTER
	 PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	ENDIF
	MOVEI	C,.CHLFD		;ELSE MUST NEED LINE-FEED
	TXZ	F,F.REC			;SHOW RECORD IS FINISHED
	PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	SUBTTL	GETOCT - ROUTINE TO READ PSUEDO BYTE IN OCTAL DUMP MODE [34]

;	CALLING SEQUENCE:
;		CALL	GETOCT
;		<EOF RETURN (LOGICAL OR PHYSICAL)>
;		<NORMAL RETURN WITH CHAR IN C>
;
;	ACS CHANGED: C

GETOCT:	AOS	C,BYTBYT		;INCREMENT BYTE COUNTER
	IFI	(C,EQ,7,THEN)		;IF END OF HALF WORD, THEN
	 MOVEI	C,","			;GET A COMMA
	 PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	ENDIF
	IFI	(C,LT,16,THEN)		;IF NOT END OF WORD, THEN
	 CALL	GETBYT			;GET NEXT BYTE
	  RETURN			;EOF RETURN
	 ADDI	C,"0"			;CONVERT TO ASCII
	 PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	ENDIF				;ELSE IF END OF WORD, THEN
	AOS	C,BYTWRD		;INCREMENT THE WORD COUNT
	IF	(C,LT,BYTMAX,THEN)	;IF STILL ROOM ON LINE, THEN ...
	 CLEARM	BYTBYT			;RESET THE BYTE COUNT
	 MOVEI	C,.CHTAB		;GET A TAB AND
	 PGOTO	.POPJ1##		;  TAKE GOOD RETURN
	ENDIF
	IF	(C,EQ,BYTMAX,THEN)	;IF JUST FINISHED LAST WORD, THEN ...
	 MOVEI	C,.CHCRT		;GET A CARRIAGE RETUREN AND
	 PGOTO	.POPJ1##		;TAKE GOOD SKIP RETURN
	ENDIF				;ELSE FINISH UP THE LINE
	CLEARM	BYTBYT			;RESET THE BYTE COUNTER
	CLEARM	BYTWRD			;AND RESET THE WORD COUNTER
	MOVEI	C,.CHLFD		;GET A LINE-FEED
	PGOTO	.POPJ1##		;AND TAKE GOOD RETURN
	SUBTTL	GETBYT - ROUTINE TO INPUT A BYTE FROM FILE

;	CALLING SEQUENCE:
;		CALL	GETBYT
;		<EOF RETURN (LOGICAL OR PHYSICAL)>
;		<NORMAL RETURN WITH CHAR IN C>
;
;	ACS CHANGED: C

GETBYT:	SOSGE	FILHDR+.BFCTR		;ANY BYTES IN INPUT BUFFER?
	  GOTO	GETBY1			;NO--HAVE TO DO AN INPUT
	ILDB	C,FILHDR+.BFPTR		;YES--GET THE NEXT BYTE
	TXNE	F,F.NUL			;[13,40]ARE NULL BYTES ALLOWED?
	  PGOTO	.POPJ1##		;[40]YES--THEN NO SPECIAL CHECKS
	JUMPE	C,GETBYT		;[13]NO--IGNORE NULLS
	TXNE	P2,FX$SEQ		;[40]ARE WE SUPPRESSING SEQUENCE NUMBERS?
	  PGOTO	.POPJ1##		;[40]NO--JUST RETURN
	CAIE	C,.CHLFD		;[40]END OF LINE CHARACTER
	CAIN	C,.CHFFD		;[40]....?
	  GOTO	GETBY4			;[40]YES--FLAG AND RETURN
	TXZN	F,F.BIL			;[40]ARE WE AT START OF A LINE?
	  PGOTO	.POPJ1##		;[40]NO--JUST RETURN NOW WITH CHAR
	MOVE	C,@FILHDR+.BFPTR	;[40]GET THE LAST FULL WORD
	TXNN	C,1			;[40]IS THIS A SEQUENCE NUMBER?
	  GOTO	GETBY5			;[40]NO--GET BACK CHAR AND OUTPUT IT
	MOVNI	C,4			;[40]GET -4
	ADDM	C,FILHDR+.BFCTR		;[40]TO FIX COUNT PAST THIS WORD
	MOVSI	C,(POINT 7)		;[40]RESET POINTER TO
	AOS	FILHDR+.BFPTR		;[40] NEXT WORD
	HLLM	C,FILHDR+.BFPTR		;[40]AND FIRST CHARACTER
	TXO	F,F.NUL			;[40]PREVENT POSSIBEL LOOP
	CALL	GETBYT			;[40]GET THE NEXT BYTE
	  RETURN			;[40]OOPS!  EOF
	TXZ	F,F.NUL			;[40]FIX FLAG
	IFI	(C,EQ,.CHTAB)		;[40]IF CHAR IS A TAB,
	  PGOTO	GETBYT			;[40]  EAT IT TOO!
	PGOTO	.POPJ1##		;[40]ELSE JUST RETURN IT
GETBY4:	TXOA	F,F.BIL			;[40]SHOW AT BEGINNING OF LINE
GETBY5:	LDB	C,FILHDR+.BFPTR		;[40]GET BACK LAST CHARACTER
	RETURN	1			;AND TAKE SKIP RETURN WITH CHAR

					CONT.
GETBY1:	TXNE	F,F.TMP			;[32]ARE WE READING TMPCOR:?
	  RETURN			;[32]YES--THEN THIS IS EOF
	AOS	BLOCKN			;INCREMENT BLOCK COUNTER
	IN	ICHAN,			;GET THE NEXT BUFFER
	  GOTO	GETBY2			;OK--GO CHECK LIMIT IN BLOCKS
	GETSTS	ICHAN,C			;ERROR--GET THE CHANNEL STATUS
	TXNN	C,IO.ERR		;ANY ERRORS?
	  RETURN			;NO--MUST BE PHYSICAL EOF
	ERROR	IEF			;YES--TELL USER

GETBY2:	MOVE	C,.FXLEN+$FXCRP(P1)	;[22]GET THE ENCRYPTION ARG
	CAMN	C,[-1]			;[22]SKIP IF THERE IS ONE
	  GOTO	GETBY3			;[22]NO--SKIP IT
	MOVEM	7,SAVACS+7		;[22]SAVE ACS
	MOVEI	7,SAVACS		;[22]  0 THRU
	BLT	7,SAVACS+6		;[22]    7
	MOVE	5,C			;[22]GET THE SEED
	HRRZ	7,FILHDR		;[22]GET THE ADR OF THE BUFFER
	MOVN	6,.BFCNT-1(7)		;[22]GET NEGATIVE WORD IN RH
	ADDI	7,2			;[22]POINT TO BUFFER DATA
	HRL	7,6			;[22]AND MAKE [XWD -SIZE,DATA]
	MOVE	6,BLOCKN		;[22]GET THE BLOCK NUMBER
	SOJ	6,			;[22]MAKE IT BLOCK NUMBER - 1
	XCALL	CRYPT.			;[22]DECRYPT THE BLOCK
	MOVSI	7,SAVACS		;[22]RESTORE ACS
	BLT	7,7			;[22]  0 THRU 7
GETBY3:	SKIPG	C,.FXLEN+$FXBEN(P1)	;GET ENDING BLOCK NUMBER
	  GOTO	GETBYT			;SKIP IT IF WANT ALL
	IF	(C,GE,BLOCKN)		;IS THIS THE LOGICAL END OF FILE?
	  GOTO	GETBYT			;NO--GET NEXT BYTE
	RETURN				;YES--TAKE EOF RETURN
	SUBTTL	PUTBYT - ROUTINE TO OUTPUT A BYTE

;	CALLING SEQUENCE:
;		MOVE	T1,<CHAR>
;		CALL	PUTBYT
;		<RETURN>
;
;	ACS CHANGED: T1

OUTC:	MOVE	T1,C			;ENTRY TO OUTPUT CHAR IN C
OUTBYT:	IFI	(S.IMAGE,GT,0)		;[37]IF IMAGE MODE OUTPUT, THEN
	  PGOTO	PUTIMG			;[37,64]  SKIP ALMOST ALL THE FRILLS
	JUMPE	T1,.POPJ##		;IGNORE NULLS
	IFI	(T1,EQ,.CHDEL)		;IS CHAR A DELETE?
	  RETURN			;YES--IGNORE IT TOO
	TXNN	F,F.TOP			;[11]ARE WE AT TOP OF PAGE?
	  GOTO	OUTBY2			;[11]NO--SKIP IT
	TXNN	F,F.PAG			;[11]PAGING MODE?
	  GOTO	OUTBY1			;[11]NO--SKIP FORM CHECK
	IFI	(T1,EQ,.CHFFD,THEN)	;[11]IS THE CHAR A FORM-FEED?
	 CLEARM	SUBPAG			;[11]YES--RESET SUBPAGE NUMBER
	 RETURN				;[11]  AND RETURN
	ENDIF
OUTBY1:	TXZ	F,F.TOP			;[11]AND CLEAR TOP OF PAGE FLAG
	IFI	(.FXLEN+$FXHDR(P1),GE,0) ;[16]USER WANTS HEADER?
	  CALL	DOHDR			;YES--GIVE HIM ONE
OUTBY2:	CAILE	T1,.CHSPC		;IS THIS MAYBE SPECIAL?
	  GOTO	FRCHAR			;NO--NORMAL CHARACTER
	IFI	(T1,EQ,.CHSPC)		;IF JUST A SPACE, THEN
	  GOTO	SPCHAR			;  GO PROCESS IT
	IFI	(T1,EQ,.CHESC)		;[35]IS THIS AN ALTMODE(ESCAPE)?
	  GOTO	ALTCHR			;[35]YES--GO PROCESS IT
	CAIL	T1,.CHBEL		;[35]IS CHAR COLTROL-A THRU CONTROL-F?
	CAIL	T1,.CHCNN		;  OR CONTROL-N THRU CONTROL-UNDERLINE?
	  GOTO	CCHAR			;YES--NORMAL CONTROL CHARACTER
	GOTO	@.-.CHBEL+1(T1)		;[35]DISPATCH TO PROPER CHARACTER PROC
	EXP	BELCHR			;[35]BELL
	EXP	BSCHAR			;BACKSPACE
	EXP	TABCHR			;TAB
	EXP	LFCHAR			;LINE-FEED
	EXP	VTCHAR			;VERTICAL TAB
	EXP	FFCHAR			;FORM-FEED
	EXP	CRCHAR			;CARRIAGE-RETURN
	SUBTTL	Routines to process control chars, spaces, & backspace

ALTCHR:	TXNN	P2,FX$ALT		;[35]ECHO ALTMODE AS $?
	  GOTO	CCHAR			;[35]NO--DO IT AS ^]
	MOVEI	T1,"$"			;[35]YES--GET $
	GOTO	FRCHAR			;[35]AND OUTPUT IT

BELCHR:	TXNE	F,F.TTY			;[35]IS OUTPUT DEVICE A TTY?
	TXNN	P2,FX$BEL		;[35]YES--ARE WE RINGING THE BELL?
	CAIA				;[35]NO--SKIP IT
	CALL	PUTBYT			;[35]YES--RING THE BELL

CCHAR:	PUSH	P,T1			;SAVE THE CONTROL CHARACTER
	MOVEI	T1,"^"			;GET AN UP ARROW
	CALL	FRCHAR			;OUTPUT IT
	POP	P,T1			;RESTORE CONTROL CHAR
	MOVEI	T1,100(T1)		;GET CONTROL CHAR CONVERTED TO ASCII
	GOTO	FRCHAR			;AND OUTPUT AND RETURN

SPCHAR:	TXNN	P2,FX$SUP		;[50] ARE WE PLAYING SUPPRESS GAMES?
	SKIPLE	S.TABS			;[50] OR ARE WE CONVERTING TABS?
	CAIA				;[50] YES
	  GOTO	CNTCHR			;NO--TREAT AS NORMAL CHARACTER
	AOS	TABSN			;YES--INCREMENT TABS COUNTER
	TXO	F,F.SPC			;FLAG PROCESSING SPACES
	RETURN

BSCHAR:	SKIPG	S.BACK			;/BACKSPACE SET?
	  GOTO	CCHAR			;NO--TREAT AS NORMAL CONTROL CHAR
	TXZE	F,F.SPC			;ANY SPACES TO DUMP?
	  CALL	PADIT			;YES--DUMP THEM
	AOS	SPLEFT			;[30]SHOW MORE ROOM LEFT
	SOS	TABSN			;DECREMENT CHAR POSITION COUNTS
	SOSL	CHARN			;... AND SEE IF WENT TOO FAR
	  GOTO	PUTBYT			;NO--OK TO DUMP THE BYTE
	CLEARM	TABSN			;TOO FAR--CLEAR THE COUNTERS
	CLEARM	CHARN			;...
	SOS	SPLEFT			;[30]FIX SPACE LEFT ON THE LINE
	MOVEI	T1,.CHLFD		;GET A LINE FEED
	PGOTO	LFCHAR			;AND PROCESS AS THAT
	SUBTTL	Routine to process a tab

TABCHR:	TXZN	F,F.SPC			;ANY SPACES SAVED UP?
	  GOTO	TABCH1			;NO--NORMAL STUFF
	IFI	(S.TABS,GT,0,THEN)	;[50] IF WE ARE CONVERTING TO TABS, THEN ...
	 MOVE	T1,TABSN		;YES--GET TAB COUNTER
	 ADDI	T1,10			;GOTO NEXT TAB STOP
	 TRZ	T1,7			;...
	 MOVEM	T1,TABSN		;AND SAVE THE NEW VALUE
	 PGOTO	PADIT			;PAD OUT SPACES AND RETURN
	ENDIF
	CALL	PADIT			;PAD SPACES ONLY BEFORE TAB
TABCH1:	MOVE	T1,CHARN		;[30]GET THE CHARACTER POSITION
	ANDI	T1,7			;[30]ISOLATE THE NUMBER OF SPACES TO MOVE
	SUBI	T1,10			;[31]COMPUTE # OF SPACES WE WILL COVER
	ADDB	T1,SPLEFT		;[31]AND UPDATE SPACES LEFT
	IFI	(T1,LT,0,THEN)		;[30,31]IF WE WENT OVER THE LINE, THEN ...
	 TXNE	P2,FX$TRN		;[30]ARE WE TRUNCATING?
	  RETURN			;[30]YES--SO JUST RETURN
	 CALL	NEWLINE			;[31]FORCE OUTPUT TO NEXT LINE
	ENDIF
	MOVE	T1,CHARN		;GET CHARACTER COUNT
	ADDI	T1,10			;GO TO NEXT TAB STOP
	TRZ	T1,7			;...
	MOVEM	T1,CHARN		;SAVE CURRENT CHAR POSITION
	MOVEM	T1,TABSN		;AND TAB POSITION
	MOVEI	T1,.CHTAB		;RESTORE TAB CHARACTER
	GOTO	PUTBYT			;AND OUTPUT THE TAB
	SUBTTL	ROUTINES TO HANDLE END OF LINE CHARACTERS

LFCHAR:	TXZE	F,F.SPC			;ANY SPACES TO PAD?
	  CALL	PADIT			;YES--PAD LINE
LFCHA1:	CALL	PUTBYT			;AND OUTPUT LF/VT/FF
	TXNE	F,F.PAG			;IS THIS PAGING MODE?
	  SOJLE	P3,CHKPAG		;[15]YES--DEC LINE COUNT & CHECK PAGE IF NECCESS
LMDCHR:	TXNN	F,F.LMD			;IS THIS A LINE MODE DEVICE?
	  RETURN			;NO--IGNORE
	OUT	OCHAN,			;YES--FORCE BUFFER OUT
	  RETURN			;OK--GOOD
	ERROR	OEF			;ERROR--TELL USER

VTCHAR:	TXZE	F,F.SPC			;ANY SPACES TO PAD?
	  CALL	PADIT			;YES--PAD LINE
	CALL	PUTBYT			;AND OUTPUT LF/VT/FF
	TXNN	F,F.PAG			;IS THIS PAGING MODE?
	  PGOTO	LMDCHR			;NO--JUST FORCE LINE OUT
	IFI	(P3,LE,4)		;IF GOING TO NEXT PAGE,
	  PGOTO	NEWPAG			;FORCE IT OVER AND RETURN
	PUSH	P,T2			;SAVE AC T2
	MOVEI	T2,4			;COUNT OF VT'S
VTCHR1:	MOVEI	T1,.CHLFD		;GET A LINE FEED
	CALL	PUTBYT			;OUTPUT IT
	SOJG	T2,VTCHR1		;LOOP FOR ALL 4
	POP	P,T2			;RESTORE T2
	SUBI	P3,4			;FIX LINE COUNTER
	PGOTO	LMDCHR			;AND GO FINISH UP

FFCHAR:	TXZE	F,F.SPC			;ANY SPACES TO PAD?
	  CALL	PADIT			;YES--PAD LINE
	CLEARM	SUBPAG			;[11]CLEAR THE SUB-PAGE COUNTER
	TXNE	F,F.PAG			;IS THIS PAGING MODE?
	  PGOTO	NEWPAG			;YES--GO TO THE NEXT PAGE
	IFI	(S.PAUSE,GE,0)		;[54] PAUSING FOR EACH FORM?
	  PGOTO	DOPAUS			;[54] YES--PAUSE FOR THE USER
	CALL	PUTBYT			;NO--OUTPUT THE FORMFEED
	TXO	F,F.TOP			;[11]SHOW AT TOP OF PAGE
	PGOTO	LMDCHR			;AND GO FINISH UP

CRCHAR:	TXZE	F,F.SPC			;ANY SPACES TO PAD?
	TXNE	P2,FX$SUP		;YES--FINAL SPACES SUPPRESSED?
	CAIA				;YES--SKIP THE PAD
	  CALL	PADIT			;NO--PAD WITH SPACES
CRCHA1:	CLEARM	CHARN			;RESET CHAR POSITION TO START OF LINE
	CLEARM	TABSN			;...
	EXCH	T1,CURWID		;[30]GET CURRENT WODTH/SAVE CHARACTER
	MOVEM	T1,SPLEFT		;[30]RESET THE # SPACES LEFT ON LINE
	EXCH	T1,CURWID		;[30]RESTORE CHAR/CURRENT WIDTH
	GOTO	PUTBYT			;AND OUTPUT CR
	SUBTTL	ROUTINES TO OUTPUT 1 PRINTABLE CHARACTER

FRCHAR:	TXZE	F,F.SPC			;IF ANY SPACES HANGING AROUND,
	  CALL	PADIT			;PAD LINE
CNTCHR:	AOS	CHARN			;FIX UP THE CHARACTER COUNTERS
	AOS	TABSN			;...
	SOSL	SPLEFT			;[30]ANY ROOM ON THIS LINE?
	  GOTO	PUTBYT			;[30]YES--DUMP THE CHARACTER
	TXNE	P2,FX$TRN		;[30]ARE WE TRUNCATING?
	  RETURN			;[30]YES--IGNORE THE CHARACTER
	CALL	NEWLINE			;[31]FORCE OUTPUT TO NEXT LINE
	GOTO	OUTBYT			;[30]AND OUTPUT THE CHARACTER

PUTIMG:	CAIE	T1,.CHFFD		;[64] Is this a form feed?
	  GOTO	PUTBYTE			;[64] No--just output the image char
	IFI	(S.PAUSE,GE,0)		;[64] Yes--are we pausing for pages?
	  PGOTO	DOPAUSE			;[64] Yes--go do a pause
PUTBYT:	SOSGE	OUTHDR+.BFCTR		;IS THERE ROOM IN OUTPUT BUFFER?
	  GOTO	PUTBY1			;NO--HAVE TO DO AN OUTPUT
	IDPB	T1,OUTHDR+.BFPTR	;YES--PUT THIS BYTE IN BUFFER
	RETURN

PUTBY1:	OUT	OCHAN,			;OUTPUT THE CURRENT BUFFER
	  GOTO	PUTBYT			;OK--GOT NEXT BUFFER
	ERROR	OEF			;ERROR--TELL USER
	SUBTTL	PADIT	ROUTINE TO PAD OUT THE CURRENT SPAN OF SPACES

PADIT:	PUSH	P,T1			;SAVE CURRENT CHARACTER
	PUSH	P,T2			;SAVE T2
PADIT5:	MOVE	T2,CHARN		;GET CURRENT CHARACTER COUNTER
	MOVE	T1,TABSN		;[30]GET WHERE WE SHOULD SPACE TO
	IF	(T2,GE,T1)		;[30]IF NO PADDING, THEN
	  PGOTO	T2POPJ			;  RETURN
	SUB	T1,T2			;[30]GET # OF SPACES WE ARE PADING
	MOVNS	T1			;[31]MAKE IT NEGATIVE
	ADDB	T1,SPLEFT		;[30]COMPUTE ROOM LEFT ON LINE
	IFI	(T1,LE,0,THEN)		;[30IF NO ROOM, THEN ...
	 MOVE	T2,TABSN		;[30]GET WHERE WE SHOULD BE IN T2
	 TXNE	P2,FX$TRN		;[30]IF WE ARE TRUNCATING, THEN
	  GOTO	PADIT3			;[30]JUST FINISH UP
	 CALL	NEWLINE			;[31]FORCE OUTPUT TO NEXT LINE
	 SUB	T2,CURWID		;[30]FIX UP TAB POSITION
	 MOVEM	T2,TABSN		;[30,31]AND SAVE IT
	 GOTO	PADIT5			;[30]AND LOOP FOR MORE
	ENDIF
	IFI	(S.TABS,GT,0,THEN)	;[50] IF CONVERTING TO TABS, THEN ...
	 TRZ	T2,7			;CLEAR PARTIAL TAB POSITION
	 ADDI	T2,10			;COMPUTE NEXT TAB POSITION
	 IF	(T2,GT,TABSN,THEN)	;IF TOO SMALL FOR A TAB, THEN ...
	  MOVE	T2,CHARN		;  RESTORE POSITION
	 ELSE
	  MOVEI	T1,.CHTAB		;GET A TAB CHARACTER
PADIT1:	  CALL	PUTBYT			;OUTPUT A TAB
	  IF	(T2,EQ,TABSN)		;IF EXACT FIT,
	   GOTO	PADIT3			;  THEN GO FINISH UP
	  ADDI	T2,10			;POINT TO NEXT TAB STOP
	  IF	(T2,LE,TABSN)		;IF WE CAN STILL PAD,
	   GOTO	PADIT1			;GO DO IT
	  SUBI	T2,10			;ELSE RESET FOR SPACES
	 ENDIF
	ENDIF
	MOVEI	T1,.CHSPC		;GET A SPACE TO PAD WITH
PADIT2:	IF	(T2,LT,TABSN,THEN)	;IF MORE SPACES TO PAD, THEN
	 CALL	PUTBYT			;OUTPUT A SPACE
	 AOJA	T2,PADIT2		;AND LOOP TILL AT RIGHT SPOT
	ENDIF
PADIT3:	MOVEM	T2,CHARN		;RESET THE CHAR COUNTER
T2POPJ:	POP	P,T2			;RESTORE T2
TPOPJ:	POP	P,T1			;RESTORE CURRENT CHARACTER
	RETURN
	SUBTTL	NEWPAG - Routine to go to top of next page

;	CALLING SEQUENCE:
;		MOVE	P3,<LINES ON THIS PAGE>
;		CALL	NEWPAG
;		<RETURN>
;
;	ACS CHANGED: T1, P3

CHKPAG:	TXZN	F,F.SFM			;[15]SUPPRESS AUTO FF?
	  GOTO	NEWPAG			;[15]NO--PAGE IT
	ADD	P3,S.FORM		;[15]SEE IF END OF PAGE
	IFI	(P3,LE,0,THEN)		;[15]IF ON NEXT PAGE, THEN ...
	 AOS	SUBPAG			;[15]INCREMENT SUB PAGE COUNTER
	 GOTO	NEWPA2			;[15]AND RESET PAGE COUNTER
	ENDIF
	SUB	P3,S.FORM		;[15]ELSE FIX COUNTER
	PGOTO	LMDCHR			;[15]AND GO FINISH UP

NEWPAG:	IFI	(T1,NE,.CHFFD)		;[11]IF NOT A FORM FEED
	  AOS	SUBPAG			;[11]INCREMENT SUBPAGE COUNTER
	IFI	(S.PAUSE,GE,0)		;[54] IF USER WANTS TO PAUSE,
	  PGOTO	DOPAUS			;[54] GO WAIT FOR HIM
	ADD	P3,S.FORM		;ACCOUNT FOR FORM ROOM
	IFI	(P3,GT,0,THEN)		;[67] If have to pad page with any LFs,
NEWPA1:	 MOVEI	T1,.CHLFD		;GET A LINE FEED
	 CALL	PUTBYT			;OUTPUT IT
	 SOJG	P3,NEWPA1		;AND LOOP TILL NEXT PAGE
	ENDIF				;[67]
NEWPA3:	TXO	F,F.TOP			;[11]SHOW AT TOP OF PAGE
NEWPA2:	MOVE	P3,S.PAGE		;GET NUM LINES ON PAGE
	SUB	P3,S.FORM		;MAKE IFT NUM PRINTABLE
	PGOTO	LMDCHR			;AND GO FINISH UP

DOPAUS:	MOVEI	T1,.CHCRT		;[54] GET CR
	CALL	CRCHAR			;[54] OUTPUT A CR TO CLEANUP LAST LINE
	OUT	OCHAN,			;[54] FORCE OUT LAST BUFFER
	CAIA				;[54] OK
	  ERROR	OEF			;[54] ERROR OUTPUTTING FILE
	CLRBFI				;[66] Clear user type-ahead before pausing
DOPAU1:	SKIPG	T1,S.PAUSE		;[54] GET NUMBER OF BELLS
	  GOTO	DOPAU2			;[54] NONE--SO BE QUIET
	OUTCHR	[.CHBEL]		;[54] RING THOSE CHIMES
	SOJG	T1,.-1			;[54] LOOP FOR ALL
DOPAU2:	HRRZ	T1,S.PAUSE+1		;[54] GET SLEEP TIME IN SECONDS
	MOVE	T2,T1			;[54] COPY IN CASE WE HAVE TO SLEEP
	IMULI	T1,^D1000		;[54] CONVERT TO MILLISECONDS FOR HIBER
	HRLI	T1,(HB.RTL!HB.RTC)	;[54] SET TO WAKE ON CHARACTER
	HIBER	T1,			;[54] HIBERNATE TILL N SECONDS OR CHARACTER
	  SLEEP	T2,			;[54] ERROR--JUST SLEEP FOR N SECONDS
	INCHRS	T1			;[54] DID WE GET A CHARACTER?
	  GOTO	DOPAU1			;[54] NO--TIME MUST HAVE RUN OUT
	MOVEI	T1,.CHCRT		;[54] GET CR
	CALL	CRCHA1			;[54] YES--OUTPUT A CR TO EAT SPACE
	GOTO	NEWPA3			;[54] AND FIX UP PAGE STUFF
	SUBTTL	NEWLINE	Routine to force output to next line [31]

;	CALLING SEQUENCE:
;		CALL	NEWLINE
;		<RETURN>
;
;	ACS CHANGED: --NONE--

NEWLINE:PUSH	P,T1			;SAVE THE CHARACTER
	MOVEI	T1,.CHCRT		;GET A CARRIAGE RETURN
	CALL	CRCHA1			;OUTPUT IT
	MOVEI	T1,.CHLFD		;GET A LINE-FEED
	CALL	LFCHA1			;OUTPUT IT
	TXZE	F,F.TOP			;ARE WE AT TOP OF A PAGE?
	SKIPGE	.FXLEN+$FXHDR(P1)	;YES--DOES USER WANT A HEADER?
	PGOTO	TPOPJ			;NO--JUST RESTORE CHAR AND RETURN
	POP	P,T1			;RESTORE T1
	PGOTO	DOHDR			;OUTPUT A HEADER AND RETURN
	SUBTTL	MORCOR - Routine to allocate free core

;	CALLING SEQUENCE:
;		MOVE	T2,<AMOUNT OF WORDS NEEDED>
;		CALL	MORCOR
;		<RETURN WITH FIRST ADDRESS IN T1>
;
;	ACS CHANGED: T1, T2, T3

MORCOR:	MOVE	T1,.JBFF		;GET START OF FREE CORE
	ADD	T2,T1			;COMPUTE HIGHEST ADDRESS
	MOVEM	T2,.JBFF		;RESET FIRST FREE LOC
	SOJ	T2,			;LOOK LIKE HIGHEST ADR NEEDED
	IF	(T2,GT,.JBREL,THEN)	;ARE WE IN CORE?
	 MOVE	T3,T2			;NO--USE T3 FOR THE CORE REQUEST
	 CORE	T3,			; SINCE AC GET ZAPED BY CORE UUO
	  ERROR	NEC			;  ERROR--NO MORE CORE
	ENDIF
	HRL	T3,T1			;GET FIRST ADDRESS (LH)
	HRRI	T3,1(T1)		;FIRST ADDRESS + 1 (RH)
	CLEARM	(T1)			;CLEAR FIRST ADR OF NEW AREA
	BLT	T3,(T2)			;AND CLEAR REST OF AREA
	RETURN				;[47]
	SUBTTL	DOHDR	- Routine to print a header [16]

;	CALLING SEQUENCE:
;		CALL	DOHDR
;		<RETURN>
;
;	ACS CHANGED: --NONE--

DOHDR:	XCALL	.PSH4T			;SAVE T1-T4
	MOVEI	T1,OUTBYT		;GET ADR OF TYPOUT ROUTINE
	XCALL	.TYOCH			;AND TELL SCAN
	MOVEI	T1,.CHCRT		;GET A CR
	XCALL	.TCHAR			; TO MAKE SURE AT BEG OF LINE
	LDB	T4,[POINTR (.FXLEN+$FXMD2(P1),FX$IND)] ;[41]GET # OF SPACES TO INDENT
DOHDR0:	IFI	(T4,GT,0,THEN)		;[41] WHILE STILL MORE TO INDENT, DO ...
	 XCALL	.TSPAC			;[41]  OUTPUT A SPACE
	 SOJA	T4,DOHDR0		;[41]AND LOOP FOR ALL
	ENDIF
	MOVE	T1,LKPBLK+.RBNAM	;GET THE FILE NAME
	XCALL	.TSIXN			;OUTPUT IT
	XCALL	.TTABC			;AND A TAB
	HLLZ	T1,LKPBLK+.RBEXT	;GET THE EXTENSION
	XCALL	.TSIXN			;OUTPUT IT
	XCALL	.TTABC			;AND A TAB
	SKIPN	T4,.FXLEN+$FXHDR(P1)	;GET POINTER TO THE HEADER
	  GOTO	DOHDR1			;NO TEXT--SKIP THIS PART
	MOVEI	T1,1(T4)		;GET ADR OF TEXT
	MOVE	T4,(T4)			;AND GET THE CHARACTER COUNT
	XCALL	.TSTRG			;OUTPUT THE ASCIZ HEADER STRING
DOHDR1:	LDB	T3,[POINTR (.FXLEN+$FXMD2(P1),FX$IND)] ;[41]GET # OF SPACES TO INDENT
	ADDI	T4,^D28(T3)		;[41]COMPENSATE FOR FILENAME, PAGE, & INDENT
	SUB	T4,CURWID		;[30]COMPUTE FREE SPACE IN HEADER
DOHDR2:	XCALL	.TSPAC			;PAD WITH SPACES
	AOJL	T4,DOHDR2		;LOOP TILL PADDED
	WRITE	<Page >
	MOVE	T1,PAGEN		;GET THE PAGE NUMBER
	XCALL	.TDECW			;OUTPUT IT
	IFI	(SUBPAG,GT,0,THEN)	;IF A SUB-PAGE #, THEN ...
	 MOVN	T1,SUBPAG		;GET THE MINUS COUNT (FOR DASH)
	 XCALL	.TDECW			;AND OUTPUT IT
	ENDIF
	XCALL	.TNEWL			;AND SKIP A LINE
	XCALL	.TNEWL
	CLEAR	T1,			;RESET .TOUTS TO
	XCALL	.TYOCH			;  NORMAL TYPOUT
	XCALL	.POP4T			;AND RESTORE T1-T4
	RETURN
	SUBTTL	INFORMATION MESSAGE SECTION

	INFO	NAM
	  GOTO	I$NAM1			;NO FIRST LINE RETURN
	MOVEI	T1,OPNBLK		;POINT TO OPEN BLOCK
	MOVEI	T2,LKPBLK		;POINT TO LOOKUP BLOCK
	XCALL	.TOLEB			;OUTPUT FILE SPEC
	HRRZ	T2,LKPBLK+.RBPRV	;GET LOW 12 BITS OF CREATION DATE
	ANDI	T2,7777			;[TYM-4] INSURE 12 BITS
IFN TOPS-4,<	; Use Ed's Code
	LDB	T1,[POINT 3,LKPBLK+.RBEXT,20] ;GET HIGH ORDER 3 BITS
> ; End IFN TOPS-4
IFE TOPS-4,<	; Don't Use Ed's Code
	LDB	T1,[POINT 2,LKPBLK+.RBEXT,21] ;GET HIGH ORDER 2 BITS
> ; End IFE TOPS-4
	DPB	T1,[POINT 3,T2,23]			;ADD INTO RESULT
	LDB	T1,[POINTR (LKPBLK+.RBPRV,RB.CRT)]	;GET TIME
Ife Tops-4,<	; Tymshare uses different Date format!!!
	Imuli	T1,^D60*^D1000	; Convert minutes to milliseconds
	Pushj	P,.CNDCT##	; Convert to DEC
	Exch	T1,T2		; Swap
	Idivi	T2,^D60*^D1000	; Convert back to minutes
	Exch	T1,T2		; Swap back
> ; End Ife Tops-4
	IFI	(T2,NE,0,THEN)		;IF CREATION DATE PRESENT, THEN ...
	 PUSH	P,T1			; First save the time
	 PUSH	P,T2			;   then the date
	 WRITE	</Created:>
	 POP	P,T1			;GET DATE IN T1
	 XCALL	.TDATE			;OUTPUT IT
	 POP	P,T3			; Restore the time
	 IFI	(CURWID,GE,^D80,THEN)	;[30]IF ROOM FOR TIME, THEN ...
	 IFI	(T3,NE,0,THEN)		;IF CREATION TIME PRESENT, THEN ...
	  XCALL	.TSPAC			;OUTPUT A SPACE
	  IDIVI	T3,^D60			;HOURS IN T3/ MINUTES IN T4
	  MOVE	T1,T3			;GET THE HOURS
	  MOVEI	T2,"0"			;GET FILLER
	  XCALL	.TDEC2			;OUTPUT AS TWO DIGITS
	  XCALL	.TCOLN			;OUTPUT ANOTHER COLAN
	  MOVE	T1,T4			;GET MINUTES
	  MOVEI	T2,"0"			;GET BACK FILLER
	  XCALL	.TDEC2			;OUTPUT AS TWO DIGITS
	 ENDIF
	 ENDIF
	ENDIF
	LDB	T4,[POINT 15,LKPBLK+.RBEXT,35] ;GET ACCESS DATE
Ife TOPS-4,<	; Tymshare uses different Date format!!!
	Hrroi	T1,.Gtprv		; Read priv bits @ Tymshare
	Gettab	T1,			;  to get your time zone
	  Movsi	T1,4000			; GMT if none
	Ldb	T1,[POINT 5,T1,7]	; Get the time zone
	Movei	T2,20			; Setup GMT
	Subm	T2,T1			; Subtract GMT - Results to Memory
	Ldb	T2,[Point 14,LKPBLK+.RBEXT,35] ;GET ACCESS DATE
	Jumpge	T1,FACCGD		; Access date ok!
	Soj	T2,			; Decrement date by 1
	Addi	T1,^D24			; Add a day of hours
FACCGD:	Imul	T1,[^D60*^D60*^D1000]	; make into milliseconds
	Pushj	P,.CNDCT##		; Convert to DEC
	Movem	T2,T4			; Use new date
> ; End Ife Tops-4
	IFI	(T4,NE,0,THEN)		;IF ACCESS DATE PRESENT, THEN ...
	 WRITE	</Access:>
	 MOVE	T1,T4			;GET THE DATE
	 XCALL	.TDATE			;OUTPUT IT
	ENDIF
I$NAM1:	XCALL	ERRFIN			;GO FINISH UP MSG
	PGOTO	.TNEWL			;FINISH UP AND RETURN
	SUBTTL	Error message section

	FATAL	IBF,<Illegal binary file >
	  GOTO	E$NBI1			;[25]NO FIRST LINE RETURN
	GOTO	E$NBI0			;[25]GO TYPE FILENAME AND GO TO NEXT

	FATAL	CDI,<Device >
	  GOTO	E$CDI1			;[27]NO FIRST LINE RETURN
	MOVE	T1,OPNBLK+.OPDEV	;[27]GET THE DEVICE
	XCALL	.TSIXN			;[27]OUTPUT IT
	WRITE	< cannot do input.>
E$CDI1:	XCALL	ERRFIN			;[27]GO FINISH UP MESSAGE
	GOTO	NXTFIL			;[27]AND BACK FOR NEXT FILE

	FATAL	CDO,<Device >
	  GOTO	E$CDO1			;[51] NO FIRST LINE RETURN
	MOVE	T1,OUTOPN+.OPDEV	;[51] GET THE DEVICE
	XCALL	.TSIXN			;[51] OUTPUT IT
	WRITE	< cannot do OUTPUT.>
E$CDO1:	XCALL	ERRFIN			;[51] GO FINISH UP MESSAGE
	GOTO	SCAN			;[51] BACK FOR ANOTHER COMMAND

	FATAL	IEF,<Input error (>
	  GOTO	E$IEF1			;NO FIRST LINE RETURN
	MOVE	T1,C			;GET ERROR STATUS
	XCALL	.TOCTW			;OUTPUT IT
	WRITE	<) for file >
	MOVEI	T1,OPNBLK		;POINT TO OPEN BLOCK
	MOVEI	T2,LKPBLK		;POINT TO LOOKUP BLOCK
	XCALL	.TOLEB			;OUTPUT FILE SPEC
E$IEF1:	XCALL	ERRFIN			;GO TO NEXT LINE
	GOTO	FINFIL			;AND GO FINISH UP ON THE FILE

	FATAL	IFR,<Input filename required for >
	  GOTO	E$IFR1			;NO FIRST LINE RETURN
	MOVEI	T1,(P1)			;POINT TO SCANNER BLOCK
	XCALL	.TFBLK			;OUTPUT THE SCANNER BLOCK
E$IFR1:	XCALL	ERRFIN			;GO TO NEXT LINE
	GOTO	SCAN			;AND TRY AGAIN

	FATALX	ION,<IONDX. UUO failed!>
	GOTO	SCAN			;GO TRY AGAIN

	WARNX	MFT,<More than >,\TMPMAX,< files in TMPCOR.>
	MOVEI	T1,TMPMAX		;[32]GET ONLY WHAT WE CAN
	RETURN

	FATAL	NBI,<Negative block number illegal for non-disk file >
	  GOTO	E$NBI1			;NO FIRST LINE RETURN
E$NBI0:	MOVEI	T1,OPNBLK		;POINT TO OPEN BLOCK
	MOVEI	T2,LKPBLK		;POINT TO LOOKUP BLOCK
	XCALL	.TOLEB			;OUTPUT THE SPEC
E$NBI1:	XCALL	ERRFIN			;FINISH UP MESSAGE
	GOTO	NXTFIL			;AND GO TRY NEXT FILE

	FATALX	NEC,<Not enough CORE.>
	PGOTO	.FMSGE##		;[47]GO FINISH UP COMMAND LINE

	FATALX	NTD,<TMPCOR not supported in this monitor.>
	GOTO	NXTFIL			;[32]AND ON TO NEXT FILE

	FATAL	OEF,<Output error (>
	  GOTO	E$OEF1			;NO FIRST LINE RETURN
	GETSTS	OCHAN,T1		;GET THE ERROR STATUS
	XCALL	.TOCTW			;OUTPUT THE VALUE
	WRITE	<) for file >
	MOVEI	T1,OUTOPN		;POINT TO OPEN BLOCK
	MOVEI	T2,OUTENT		;POINT TO ENTER BLOCK
	XCALL	.TOLEB			;OUTPUT FILE SPEC
E$OEF1:	XCALL	ERRFIN			;GO TO NEXT LINE
	CLOSE	OCHAN,			;TRY TO SAVE PART OF FILE
	GOTO	SCAN			;AND RESTART

	FATAL	OPA,<Output APPEND error >
	  GOTO	E$OPE1			;[23]NO FIRST LINE RETURN
	GOTO	E$OPE0			;[23]GIVE REST OF MESSAGE

	FATAL	OPE,<Output ENTER error >
	  GOTO	E$OPE1			;SKIP AROUND IF NO FIRST LINE
E$OPE0:	HRRZ	T1,OUTENT+.RBEXT	;GET THE ERROR CODE
	CLEAR	T3,			;NO PROTECTION
	XCALL	.LKERR			;OUTPUT A READABLE ERROR MSG
	WRITE	< file >
	MOVEI	T1,OUTOPN		;POINT TO OPEN BLOCK
	MOVEI	T2,OUTENT		;POINT TO ENTER BLOCK
	XCALL	.TOLEB			;OUTPUT FILE SPEC
E$OPE1:	XCALL	ERRFIN			;GO TO NEXT LINE
	GOTO	SCAN			;AND RETRY

	FATAL	OPO,<Output OPEN failed on device >
	  GOTO	E$OPE1			;NO FIRST LINE RETURN
	MOVE	T1,OUTOPN+.OPDEV	;GET THE DEVICE NAME
	XCALL	.TSIXN			;OUTPUT THE NAME
	PGOTO	E$OPE1			;AND FINISH UP

	FATALX	PSF,<PAGESIZE must be at least 4 greater than BREAKSIZE.>
	GOTO	SCAN			;AND GO TRY AGAIN

	FATALX	SUO,<SUSET. Output error.  Check Output file Access.>
	GOTO	SCAN			;Start OVER.

	FATALX	TBO,<Text buffer overflow.>
	PGOTO	.FMSGE##		;GO FINISH UP COMMAND LINE

	WARNX	TDE,<TMPCOR directory is empty.>
	GOTO	NXTFIL			;[33]SO GO GET NEXT FILE

	WARN	TNF,<TMPCOR file >
	  GOTO	W$TNF1			;[33]NO FIRST LINE RETURN
	MOVE	T1,LKPBLK+.RBNAM	;[33]GET THE FILE NAME
	XCALL	.TSIXN			;[33]OUTPUT IT
	WRITE	< not found.>
W$TNF1:	PGOTO	ERRFNP##		;[33,44]GO FINISH UP ERROR MSG

	FATALX	TRM,<TRMOP. UUO failed!>
	GOTO	SCAN			;GO TRY AGAIN

	WARNX	TTL,<TMPCOR file larger than >,\TMFMAX,< words--truncated.>
	MOVEI	T2,TMFMAX		;[32]ONLY USE WHAT WE CAN
	RETURN

	FATALX	WCI,<Wild cards illegal in output specification.>
	GOTO	SCAN			;GO TRY AGAIN
	SUBTTL	DEFINITIONS OF USER SCAN SWITCHES

	KEYS	(DEV,<TTY,LA50,TI820,SCANSET,ADM11P>)
	KEYS	(HZP,<5,6,8,10,12,16>)
	KEYS	(VTP,<2,3,4,6,8,12>)
	KEYS	(SPC,<SINGLE,DOUBLE,TRIPLE>)
;	KEYS	(PLT,<SIXBIT,SEVENBIT>)

DEFINE	SWTCHS	<
	PAGE
SN	APPEND,S.APPEND
SN	ACCESS,<POINTR (F$MD1,FX$ACC)>
SN	WILD,S.WILD
SN	NAME,<POINTR (F$MD1,FX$NAM)>
SN	ENAME,<POINTR (F$MD1,FX$ENM)>
SN	SEQUENCE,<POINTR (F$MD1,FX$SEQ)>
SP	HEADER,F$HDR,.SWTXT,HDR
SS	OKBINARY,<POINTR (F$MD1,FX$BIN)>,0
SS	ERBINARY,<POINTR (F$MD1,FX$BIN)>,1
SS	SKBINARY,<POINTR (F$MD1,FX$BIN)>,2
SN	TABS,S.TABS,FS.NFS
SN	SUPPRESS,<POINTR (F$MD1,FX$SUP)>
SN	LSUPPRESS,<POINTR (F$MD1,FX$LSP)>
SP	WIDTH,<POINTR (F$MD1,FX$WID)>,.SWDEC,WID
SN	BACKSPACE,S.BACK,FS.NFS
SN	BELL,<POINTR (F$MD1,FX$BEL)>
SN	ALTMODE,<POINTR (F$MD1,FX$ALT)>
SL	SPACING,<POINTR (F$MD1,FX$SPC)>,SPC,SPCSIN
SN	TRUNCATE,<POINTR (F$MD1,FX$TRN)>
;SN	CRETURN,S.CRETURN,FS.NFS
SP	PAGESIZE,S.PAGE,.SWDEC,PGS,FS.NFS
SP	BREAKSIZE,S.FORM,.SWDEC,FRM,FS.NFS
SP	PAUSE,S.PAUSE+1,.SWPSE,PSS,FS.NFS
SP	INDENT,<POINTR (F$MD2,FX$IND)>,.SWDEC,IND
SP	COLUMN,<POINTR (F$MD2,FX$CL1!FX$CL2)>,.SWCOL,COL,FS.VRQ!FS.LRG
;SP	COPIES,<POINTR (F$MD2,FX$COP)>,.SWDEC,COP
;SS	EBCDIC,<POINTR (F$MD1,FX$EBC)>,1
SS	COBOL,<POINTR (F$MD1,FX$COB)>,1
SS	FORTRAN,<POINTR (F$MD1,FX$FOR)>,1
SS	KATAKANA,<POINTR (F$MD1,FX$KAT)>,1
SS	OCTAL,<POINTR (F$MD1,FX$OCT)>,1
SS	SIXBIT,<POINTR (F$MD1,FX$SIX)>,1
;SP	REPORT,?,.SWSIX,,FS.VRQ
;SL	PLOT,<POINTR(F$MD1,FX$PLT)>,PLT,PLTSIN
;SL	FPLOT,<POINTR(F$MD1,FX$PLT*2)>,PLT,PLTSIN
;SN	LPT,<POINTR(F$MD1,FX$LPT)>
SP	CRYPT,F$CRP,.SWCRP,,FS.VRQ!FS.LRG
;SS	FAILSA,<POINTR (F$MD1,FS$FSF)>,1
;SP	BACKUP,?,.SWSIX
SP	BSTART,F$BST,SWDECN,RNB,FS.VRQ
SP	PSTART,F$PST,.SWDEC,RNB,FS.VRQ
SP	LSTART,F$LST,.SWDEC,RNB,FS.VRQ
SP	BEND,F$BEN,SWDECN,RNE,FS.VRQ
SP	PEND,F$PEN,.SWDEC,RNE,FS.VRQ
SP	LEND,F$LEN,.SWDEC,RNE,FS.VRQ
SP	BRANGE,F$BEN,SWRNGN,RNB,FS.VRQ
SP	PRANGE,F$PEN,.SWRNG,RNB,FS.VRQ
SP	LRANGE,F$LEN,.SWRNG,RNB,FS.VRQ
SP	NBLOCKS,F$NBL,.SWDEC,NUM
SP	NPAGES,F$NPG,.SWDEC,NUM
SP	NLINES,F$NLN,.SWDEC,NUM
;SP	TSTART,?,.SWNTX,TXT,FS.VRQ
;SP	TEND,?,.SWNTX,TXT,FS.VRQ
;SP	NTEXT,?,.SWNTX,TXT,FS.VRQ
;SP	TLINE,?,.SWNTX,TXT,FS.VRQ
SN	IMAGE,S.IMAGE,FS.NFS
SN	REWIND,<POINTR (F$MD1,FX$REW)>
SN	EOT,<POINTR (F$MD1,FX$EOT)>
SP	SKFILES,F$MFL,.SWDEC,MTO
SP	BKFILES,F$MFL,.SWNDC,MTN,FS.LRG
SP	SKRECORDS,F$MRC,.SWDEC,MTO
SP	BKRECORDS,F$MRC,.SWNDC,MTN,FS.LRG
SP	BUFFERS,<POINTR (F$MD2,FX$BUF)>,.SWDEC,BUF,FS.VRQ
SL	DEVICE,S.DEVICE,DEV,DEVTTY,FS.VRQ
SL	PITCH,<POINTR(F$MD3,FX$HZP!FX$VTP)>,HZP,HZP10
;**SP	COLUMN,<POINTR (F$MD2,FX$CL1!FX$CL2)>,.SWCOL,COL,FS.VRQ!FS.LRG
SL	HPITCH,<POINTR(F$MD3,FX$HZP)>,HZP,HZP10
SL	VPITCH,<POINTR(F$MD3,FX$VTP)>,VTP,VTP6
IFN	FT$PIP,<			;[55]
SS	N,<POINTR (F$MD1,FX$SEQ)>,0
SS	J,<POINTR (F$MD1,FX$PIP)>,1
	> ; END IFN FT$PIP
>

	DOSCAN	(TYPSW)
	SUBTTL	Scan blocks and pointers (for calls)

IBLK:	 XWD	     2,IBLK0		;.ISCAN BLOCK POINTER
IFN	TOPS-20	<       ;[TYM-1] TOPS-10 uses the TYPE and LIST commands
IBLK0:	IOWD	     2,['TYPE  '
			'LIST  ']	;.ISCAN BLOCK
	 XWD	OFFSET,'TYP'
	> ; End TOPS-10 & TYMCOM
IFE     TOPS-20	<	; TOPS-20 uses the ETYPE and LIST commands
IBLK0:	IOWD	     2,['ETYPE '
			'LIST  ']	;[73].ISCAN Block
	 XWD	OFFSET,'TYP'
	> ; End TOPS-20

TBLK:	 XWD	    10,TBLK0		;.TSCAN BLOCK POINTER
TBLK0:	IOWD	TYPSWL,TYPSWN		;.TSCAN BLOCK (AND .OSCAN)
	 XWD	TYPSWD,TYPSWM
	 XWD	     0,TYPSWP
	 XWD	    -1,-1
	 XWD	CLRANS,CLRFIL
	 XWD	   AIN,AOUT
	 XWD	FILSTK,APLSTK
	 XWD	CLRSTK,0

OBLK:	 XWD	     4,TBLK0		;.OSCAN BLOCK POINTER

WBLK:	 XWD	     4,WBLK0		;.LKWLD BLOCK POINTER
WBLK0:	 XWD	SCNPTR,SCNEND		;.LKWLD BLOCK
	 XWD	OPNBLK,LKPBLK
	 XWD	.FXLEN+$FXSIZ,.RBLEN+1
	 XWD	540000,WLDPTR		;[45]
	SUBTTL	High segment data tables

BINEXT:	'ABS',,'AWT'			;[25]BINARY EXTENSIONS (FROM #2 APPENDIX A)
	'BAC',,'BIN'
	'BUG',,'CAL'
	'CKP',,'CHN'
	'DAE',,'DWR'
	'EXE',,'HGH'
	'LOW',,'MIM'
	'MSB',,'OBJ'
	'OVR',,'PLO'
	'QUE',,'QUF'
	'REL',,'RIM'
	'RTM',,'RTB'
	'SAV',,'SFD'
	'SHR',,'SVE'
	'SYM',,'SYS'
	'UFD',,'UNV'			;[61]
	'VMX',,'XOR'
	'XPN',,'SWR'			;[TYM-1] SWR is writeable SHR
	BINLEN==.-BINEXT
	SUBTTL	Low segment data storage section

	IMPURE

ZCORE:
ORGFF:	BLOCK	1		;ORIGINAL VALUES OF .JBREL,,.JBFF
DEFDEV:	BLOCK	1		;DEFAULT OUTPUT DEVICE
TRMCOD:	BLOCK	1		;.TRMOP FUNCTION CODE
TTYUDX:	BLOCK	1		;OUTPUT TTY I/O INDEX
CURWID:	BLOCK	1		;[30]TRMOP VALUE WORD
ORGWID:	BLOCK	1		;ORIGINAL TTY WIDTH
NEGFLG:	BLOCK	1		;FLAG USED BY SWDECN ROUTINE
I.IOZR:	BLOCK	1		;ADR OF FIRST INPUT SCAN BLOCK
I.NXZR:	BLOCK	1		;ADR FOR NEXT INPUT SCAN BLOCK
TXTPTR:	BLOCK	1		;[16]POINTER INTO FREE TEXT AREA
SCNPTR:	BLOCK	1		;ADR OF FIRST SCAN BLOCK
SCNEND:	BLOCK	1		;ADR OF LAST SCAN BLOCK
WLDPTR:	BLOCK	1		;WILD'S POINTER WORD
WLDFF:	BLOCK	1		;VALUES OF .JBREL,,.JBFF BEFORE WILD CALLS
OPNBLK:	BLOCK	3		;INPUT FILE OPEN BLOCK
LKPBLK:	BLOCK	.RBLEN+1	;INPUT FILE LOOKUP BLOCK
SAVACS:	BLOCK	^D8		;[22]USED TO SAVE ACS 0-7

S.MIN:			;START OF GLOBAL SCAN SWITCHES
S.APPEN:BLOCK	1		;/APPEND
S.WILD:	BLOCK	1		;/WILD
S.BACK:	BLOCK	1		;/BACKSPACE
S.TABS:	BLOCK	1		;[50] /TABS
S.CRET:	BLOCK	1		;/CRETURN
S.PAGE:	BLOCK	1		;/PAGESIZE:n
S.FORM:	BLOCK	1		;/BREAKSIZE:n
S.PAUSE:BLOCK	2		;[54] /PAUSE:n:m
S.IMAGE:BLOCK	1		;/IMAGE
S.DEVICE:BLOCK	1		;/DEVICE:xxx
S.EMIN==.-1

S.ZER:			;START OF ANSWERS TO BE CLEARED
OUTSCN:	BLOCK	.FXLEN		;OUTPUT SCAN BLOCK
OUTOPN:	BLOCK	3		;OUTPUT OPEN BLOCK
OUTENT:	BLOCK	.RBLEN+1	;OUTPUT ENTER BLOCK
OUTPAT:	BLOCK	^D9		;OUTPUT PATH BLOCK
OUTHDR:	BLOCK	3		;OUTPUT FILE I/O HEADER
TXTBLK:	BLOCK	TXTSIZ		;[16]BLOCK TO STORE TEXT STRINGS IN
	E.TEXT==.		;[16]END OF TEXT AREA
S.EZER==.-1
W.ZER:			;START OF VALUES TO BE CLEAR BEFORE EACH FILE
FILHDR:	BLOCK	3		;INPUT FILE I/O HEADER
IDEVCHR:BLOCK	1		;INPUT DEVICE CHARACTERISTICS
BLKSIZ:	BLOCK	1		;SIZE OF INPUT FILE IN BLOCKS+1
BLOCKN:	BLOCK	1		;CURRENT INPUT BLOCK #
PAGEN:	BLOCK	1		;CURRENT PAGE NUMBER
LINEN:	BLOCK	1		;CURRENT LINE NUMBER
CHARN:	BLOCK	1		;CURRENT CHAR ON A LINE
TABSN:	BLOCK	1		;CURRENT POSITION TO TAB/SPACE FROM
SPLEFT:	BLOCK	1		;[30]SPACES LEFT ON CURRENT LINE
SUBPAG:	BLOCK	1		;[11]SUB-PAGE COUNTER
TMPDIR:	BLOCK	TMPMAX		;[32]USED TO HOLD TMPCOR DIRECTORY
TMPPTR:	BLOCK	1		;[32]TMPCOR DIRECTORY IOWD POINTER
TMPFIL:	BLOCK	TMFMAX		;[32]USED TO HOLD TMPCOR FILE
INRTN:	BLOCK	1		;[12]POINTER TO INPUT ROUTINE
FORCNT:	BLOCK	1		;[13]FORTRAN FILE LF COUNTER
RECCNT:	BLOCK	1		;[12]SIXBIT FILE RECORD COUNTER
WRDCNT:	BLOCK	1		;[12]SIXBIT FILE WORD COUNTER
BYTBYT:	BLOCK	1		;[34]OCTAL,SIXBIT BYTE COUNTER
BYTWRD:	BLOCK	1		;[34]OCTAL,SIXBIT WORD COUNTER
BYTMAX:	BLOCK	1		;[34]OCTAL,SIXBIT MAX WORDS/LINE
COLCNT:	BLOCK	1		;[42]COLUMN NUMBER COUNTER
COLBEG:	BLOCK	1		;[42]FIRST COLUMN TO PRINT
COLEND:	BLOCK	1		;[42]LAST COLUMN TO PRINT
W.EZER==.-1
P$ZER:			;START OF STICKY FILE AREA
P$MD1:	BLOCK	1		;MODE WORD ONE
P$MM1:	BLOCK	1		;MODE MASK FOR WORD 1
P$MD2:	BLOCK	1		;MODE WORD TWO
P$MM2:	BLOCK	1		;MODE MASK FOR WORD 2
P$EZER==.-1
P$MIN:
P$BST:	BLOCK	1		;/BSTART & FIRST  PART OF /BRANGE
P$BEN:	BLOCK	1		;/BEND   & SECOND PART OF /BRANGE
P$PST:	BLOCK	1		;/PSTART & FIRST  PART OF /PRANGE
P$PEN:	BLOCK	1		;/PEND   & SECOND PART OF /PRANGE
P$LST:	BLOCK	1		;/LSTART & FIRST  PART OF /LRANGE
P$LEN:	BLOCK	1		;/LEND   & SECOND PART OF /LRANGE
P$NBL:	BLOCK	1		;/NBLOCKS
P$NPG:	BLOCK	1		;/NPAGES
P$NLN:	BLOCK	1		;/NLINES
P$HDR:	BLOCK	1		;[16]/HEADER
P$CRP:	BLOCK	1		;[22]/CRYPT
P$MFL:	BLOCK	1		;[26]/SKFILES/BKFILES
P$MRC:	BLOCK	1		;[26]/SKRECORDS/BKRECORDS
P$EMIN==.-1

F$ZER:			;START OF CURRENT FILE AREA
F$MD1:	BLOCK	1		;MODE WORD ONE
F$MM1:	BLOCK	1		;MODE MASK FOR WORD 1
F$MD2:	BLOCK	1		;MODE WORD TWO
F$MM2:	BLOCK	1		;MODE MASK FOR WORD 2
F$MD3:	BLOCK	1		;MODE WORD THREE
F$MM3:	BLOCK	1		;MODE MASK FOR WORD 3
F$EZER==.-1
F$MIN:
F$BST:	BLOCK	1		;/BSTART & FIRST  PART OF /BRANGE
F$BEN:	BLOCK	1		;/BEND   & SECOND PART OF /BRANGE
F$PST:	BLOCK	1		;/PSTART & FIRST  PART OF /PRANGE
F$PEN:	BLOCK	1		;/PEND   & SECOND PART OF /PRANGE
F$LST:	BLOCK	1		;/LSTART & FIRST  PART OF /LRANGE
F$LEN:	BLOCK	1		;/LEND   & SECOND PART OF /LRANGE
F$NBL:	BLOCK	1		;/NBLOCKS
F$NPG:	BLOCK	1		;/NPAGES
F$NLN:	BLOCK	1		;/NLINES
F$HDR:	BLOCK	1		;[16]/HEADER
F$CRP:	BLOCK	1		;[22]/CRYPT
F$MFL:	BLOCK	1		;[26]/SKFILES/BKFILES
F$MRC:	BLOCK	1		;[26]/SKRECORDS/BKRECORDS
F$EMIN==.-1

	FIN	TYPE
   >S<