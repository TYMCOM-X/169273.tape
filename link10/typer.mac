	$TOC	TYPUNV -- Initialization  Rex W. Shadrick  15-May-83


; Search a universal files

	SEARCH	SYSUNV			; Some local macros


; Define the prefix for TYPER

	TP.PFX=='TYP'			; The default prefix


; Define the title for TYPUNV

	$BEGIN	TYPUNV - The Universal File for TYPER,TYP,,<UNIVERSAL,BITS>
	$TOC	TYPUNV -- Non-Disclaimer


;       The information in this software is subject  to  change  without
;  notice  and  should  not  be  construed  as  a  commitment by Samurai
;  Programming.  Samurai Programming assumes no responsibility  for  any
;  errors that may appear in this software.
;
;       No responsibility is assumed  for  the  use  or  reliability  of
;  software on equipment that is not supplied by Samurai Programming.
;
;
;
;       Copy on Write 1981, 1982, 1983 by Samurai Programming
	$TOC	Table of Contents


;		     	Table of Contents for TYPER
;
;				  Section			    Page
;
;    1. TYPUNV
;      1.1    Initialization Rex W. Shadrick 15-May-83 . . . . . . .   1
;      1.2    Non-Disclaimer . . . . . . . . . . . . . . . . . . . .   2
;      1.3    History
;        1.3.1    Revisions  . . . . . . . . . . . . . . . . . . . .   9
;        1.3.2    Suggestions  . . . . . . . . . . . . . . . . . . .  22
;        1.3.3    Deficiencies . . . . . . . . . . . . . . . . . . .  24
;      1.4    Conditional Assembly Values
;        1.4.1    Description  . . . . . . . . . . . . . . . . . . .  25
;        1.4.2    Some Constants . . . . . . . . . . . . . . . . . .  27
;        1.4.3    Verification . . . . . . . . . . . . . . . . . . .  28
;        1.4.4    Display Options Selected . . . . . . . . . . . . .  31
;      1.5    Define the $INIT Macro . . . . . . . . . . . . . . . .  32
;      1.6    Miscellaneous Symbols
;        1.6.1    The ACs used . . . . . . . . . . . . . . . . . . .  33
;        1.6.2    The Flags Used . . . . . . . . . . . . . . . . . .  34
;      1.7    The End  . . . . . . . . . . . . . . . . . . . . . . .  35
;    2. .TBITS
;      2.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . .  36
;      2.2    .TYPER Support Routines  . . . . . . . . . . . . . . .  37
;      2.3    The End  . . . . . . . . . . . . . . . . . . . . . . .  42
;    3. .TBYTE
;      3.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . .  43
;      3.2    The Type and Seperator Tables  . . . . . . . . . . . .  44
;      3.3    Output a String of Bytes . . . . . . . . . . . . . . .  45
;      3.4    The End  . . . . . . . . . . . . . . . . . . . . . . .  49
;    4. .TENGL
;      4.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . .  50
;      4.2    The Numeric Text Strings . . . . . . . . . . . . . . .  51
;      4.3    Type a Number in English . . . . . . . . . . . . . . .  52
;      4.4    The End  . . . . . . . . . . . . . . . . . . . . . . .  55
;    5. .TFLOT
;      5.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . .  56
;      5.2    Powers of Ten Table  . . . . . . . . . . . . . . . . .  57
;      5.3    Output a Single Precision Floating-Point Number  . . .  58
;      5.4    The Flout Support Routines . . . . . . . . . . . . . .  64
;      5.5    The End  . . . . . . . . . . . . . . . . . . . . . . .  65
;    6. .TINTG
;      6.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . .  66
;      6.2    The Integer Output Routine . . . . . . . . . . . . . .  67
;      6.3    The End  . . . . . . . . . . . . . . . . . . . . . . .  70
	$TOC	Table of Contents (page 2)


;		     	Table of Contents for TYPER
;
;				  Section			    Page
;
;    7. .TPICT
;      7.1    Initialization 15-May-83 /DRB/RWS  . . . . . . . . . .  71
;      7.2    Storage
;        7.2.1    Message Characters . . . . . . . . . . . . . . . .  72
;        7.2.2    Picture Character Dispatch Table . . . . . . . . .  73
;        7.2.3    The Translate Table  . . . . . . . . . . . . . . .  74
;        7.2.4    Dispatch Tables for KA/KI-10 EDIT  . . . . . . . .  75
;      7.3    .TYPIC - $TYPES Support Routine  . . . . . . . . . . .  76
;      7.4    .TPICT - Type a Number with Picture Editing  . . . . .  77
;      7.5    GENPIC - Compile a Picture . . . . . . . . . . . . . .  82
;      7.6    Subroutines
;        7.6.1    Picture Character Processors . . . . . . . . . . .  84
;        7.6.2    KA/KI Simulation
;          7.6.2.1    CVTBDT . . . . . . . . . . . . . . . . . . . .  87
;          7.6.2.2    EDIT . . . . . . . . . . . . . . . . . . . . .  90
;          7.6.2.3    EDIT Subfunctions  . . . . . . . . . . . . . .  91
;      7.7    The End  . . . . . . . . . . . . . . . . . . . . . . .  93
;    8. .TROMN
;      8.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . .  94
;      8.2    Roman Numeral Conversion Table . . . . . . . . . . . .  95
;      8.3    Type a Roman Numeral . . . . . . . . . . . . . . . . .  96
;      8.4    The End  . . . . . . . . . . . . . . . . . . . . . . .  98
;    9. .TYPES
;      9.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . .  99
;      9.2    The $TYPES Support Module  . . . . . . . . . . . . . . 100
;      9.3    The Dispatch Table . . . . . . . . . . . . . . . . . . 101
;      9.4    The Return Type Support Modules  . . . . . . . . . . . 102
;      9.5    The End  . . . . . . . . . . . . . . . . . . . . . . . 105
;   10. .TYPER
;     10.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 106
;     10.2    The $TYPER Macro Support Module  . . . . . . . . . . . 107
;     10.3    The Various Dispatch Tables  . . . . . . . . . . . . . 113
;     10.4    The Return Type Support Modules  . . . . . . . . . . . 115
;     10.5    .TSKPT - $SKT Substitution Module  . . . . . . . . . . 118
;     10.6    .TSKIP - $SKP Substitution Module  . . . . . . . . . . 119
;     10.7    .TELSE - $ELS Substitution Module  . . . . . . . . . . 120
;     10.8    .TSUBS - $SUB Substitution Module  . . . . . . . . . . 121
;     10.9    .TXCT - $XCT Substitution Module . . . . . . . . . . . 122
;     10.10   .TOPC - $OPC Substitution Module . . . . . . . . . . . 123
;     10.11   .TCONT - $CON Substitution Module  . . . . . . . . . . 124
;     10.12   The End  . . . . . . . . . . . . . . . . . . . . . . . 125
	$TOC	Table of Contents (page 3)


;		     	Table of Contents for TYPER
;
;				  Section			    Page
;
;   11. .TSUPT
;     11.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 126
;     11.2    Error Message Table  . . . . . . . . . . . . . . . . . 127
;     11.3    .TYPER Support Routines
;       11.3.1    .TPNTR . . . . . . . . . . . . . . . . . . . . . . 130
;       11.3.2    .TASCI . . . . . . . . . . . . . . . . . . . . . . 131
;       11.3.3    .TEXTS . . . . . . . . . . . . . . . . . . . . . . 132
;       11.3.4    .TFUNN . . . . . . . . . . . . . . . . . . . . . . 133
;       11.3.5    .TTIML . . . . . . . . . . . . . . . . . . . . . . 134
;       11.3.6    .TTIMX . . . . . . . . . . . . . . . . . . . . . . 135
;       11.3.7    .TDATL . . . . . . . . . . . . . . . . . . . . . . 136
;       11.3.8    .TDATX . . . . . . . . . . . . . . . . . . . . . . 137
;       11.3.9    .TNAME . . . . . . . . . . . . . . . . . . . . . . 138
;       11.3.10   .TNUMB . . . . . . . . . . . . . . . . . . . . . . 139
;       11.3.11   .TSPEC . . . . . . . . . . . . . . . . . . . . . . 140
;       11.3.12   .TDAYN . . . . . . . . . . . . . . . . . . . . . . 141
;       11.3.13   .TFULN . . . . . . . . . . . . . . . . . . . . . . 142
;       11.3.14   .TALPH . . . . . . . . . . . . . . . . . . . . . . 143
;       11.3.15   .THEXW . . . . . . . . . . . . . . . . . . . . . . 144
;       11.3.16   .TBHXW . . . . . . . . . . . . . . . . . . . . . . 145
;       11.3.17   .TLINE . . . . . . . . . . . . . . . . . . . . . . 146
;       11.3.18   .TMULS . . . . . . . . . . . . . . . . . . . . . . 147
;       11.3.19   .TLEFT . . . . . . . . . . . . . . . . . . . . . . 148
;       11.3.20   .TFERR . . . . . . . . . . . . . . . . . . . . . . 149
;       11.3.21   .TLOOK . . . . . . . . . . . . . . . . . . . . . . 150
;       11.3.22   .TJFNS . . . . . . . . . . . . . . . . . . . . . . 151
;       11.3.23   .TJERR . . . . . . . . . . . . . . . . . . . . . . 152
;       11.3.24   .TDIRT/.TUSER  . . . . . . . . . . . . . . . . . . 153
;       11.3.25   .TPROW . . . . . . . . . . . . . . . . . . . . . . 154
;       11.3.26   .TBBLK and .TBCRW  . . . . . . . . . . . . . . . . 155
;       11.3.27   .TBXWW . . . . . . . . . . . . . . . . . . . . . . 156
;       11.3.28   .TBOCW, .TBDCW and .TBRXW  . . . . . . . . . . . . 157
;       11.3.29   .TRUNN . . . . . . . . . . . . . . . . . . . . . . 158
;       11.3.30   .TPFXN . . . . . . . . . . . . . . . . . . . . . . 159
;       11.3.31   .TSIXS . . . . . . . . . . . . . . . . . . . . . . 160
;       11.3.32   .T2TAB . . . . . . . . . . . . . . . . . . . . . . 161
;       11.3.33   .TSTMP . . . . . . . . . . . . . . . . . . . . . . 162
;       11.3.34   .TCHAR . . . . . . . . . . . . . . . . . . . . . . 163
;       11.3.35   .TTCHR . . . . . . . . . . . . . . . . . . . . . . 164
;       11.3.36   .TFBLK . . . . . . . . . . . . . . . . . . . . . . 165
;       11.3.37   .TOLEB . . . . . . . . . . . . . . . . . . . . . . 166
;       11.3.38   .TDIRB . . . . . . . . . . . . . . . . . . . . . . 167
;       11.3.39   .TXWWW . . . . . . . . . . . . . . . . . . . . . . 168
;       11.3.40   .TMOHW . . . . . . . . . . . . . . . . . . . . . . 169
;       11.3.41   .TDTTM . . . . . . . . . . . . . . . . . . . . . . 170
;       11.3.42   .TDATN . . . . . . . . . . . . . . . . . . . . . . 171
;       11.3.43   .TDATE . . . . . . . . . . . . . . . . . . . . . . 172
	$TOC	Table of Contents (page 4)


;		     	Table of Contents for TYPER
;
;				  Section			    Page
;
;       11.3.44   .TTIMN . . . . . . . . . . . . . . . . . . . . . . 173
;       11.3.45   .TTIME . . . . . . . . . . . . . . . . . . . . . . 174
;       11.3.46   TDEC2Z . . . . . . . . . . . . . . . . . . . . . . 175
;       11.3.47   .TDEC2 . . . . . . . . . . . . . . . . . . . . . . 176
;       11.3.48   .TFCHR . . . . . . . . . . . . . . . . . . . . . . 177
;       11.3.49   .TVERW . . . . . . . . . . . . . . . . . . . . . . 178
;       11.3.50   .TBLOK and .TCORW  . . . . . . . . . . . . . . . . 179
;       11.3.51   .TCRLF . . . . . . . . . . . . . . . . . . . . . . 180
;       11.3.52   .TPPNW . . . . . . . . . . . . . . . . . . . . . . 181
;       11.3.53   .TSIXN . . . . . . . . . . . . . . . . . . . . . . 182
;       11.3.54   .TXWDW . . . . . . . . . . . . . . . . . . . . . . 183
;       11.3.55   .TOCTW, .TDECW and .TRDXW  . . . . . . . . . . . . 184
;       11.3.56   .TSYMW . . . . . . . . . . . . . . . . . . . . . . 185
;       11.3.57   .TR50W . . . . . . . . . . . . . . . . . . . . . . 186
;       11.3.58   .R50SX . . . . . . . . . . . . . . . . . . . . . . 187
;       11.3.59   .TZOHW, .TZOFW, .TBOHW and .TBOFW  . . . . . . . . 188
;       11.3.60   .TFOCW, .TFDCW and .TFRXW  . . . . . . . . . . . . 189
;       11.3.61   .TOCPW . . . . . . . . . . . . . . . . . . . . . . 190
;       11.3.62   .TSTRG . . . . . . . . . . . . . . . . . . . . . . 191
;       11.3.63   Some Single Character Routines . . . . . . . . . . 192
;       11.3.64   .TVRBO . . . . . . . . . . . . . . . . . . . . . . 193
;     11.4    The End  . . . . . . . . . . . . . . . . . . . . . . . 194
;   12. .TSUPS
;     12.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 195
;     12.2    .TYBAS - BAS Support Module  . . . . . . . . . . . . . 196
;     12.3    .TYBUG - BUG Support Module  . . . . . . . . . . . . . 197
;     12.4    .TYCMP - CMP Support Module  . . . . . . . . . . . . . 198
;     12.5    .TYCOL - COL Support Module  . . . . . . . . . . . . . 199
;     12.6    .TYEMP - EMP Support Module  . . . . . . . . . . . . . 200
;     12.7    .TYERR - ERR Support Module  . . . . . . . . . . . . . 201
;     12.8    .TYESN - ESN Support Module  . . . . . . . . . . . . . 202
;     12.9    .TYEXT - EXT Support Module  . . . . . . . . . . . . . 203
;     12.10   .TYHOR - HOR Support Module  . . . . . . . . . . . . . 204
;     12.11   .TYINI - INI Support Module  . . . . . . . . . . . . . 205
;     12.12   .TYLOC - LOC Support Module  . . . . . . . . . . . . . 206
;     12.13   .TYMSG - MSG Support Module  . . . . . . . . . . . . . 207
;     12.14   .TYOCH - SCAN Support Module . . . . . . . . . . . . . 208
;     12.15   .TYOUT - OUT Support Module  . . . . . . . . . . . . . 209
;     12.16   .TYPRM - PRM Support Module  . . . . . . . . . . . . . 210
;     12.17   .TYDMP - DMP Support Module  . . . . . . . . . . . . . 211
;     12.18   .TYRTN - RTN Support Module  . . . . . . . . . . . . . 212
;     12.19   .TYSYS - SYS Support Module  . . . . . . . . . . . . . 213
;     12.20   .TYTIM - TIM Support Module  . . . . . . . . . . . . . 214
;     12.21   .TYVER - VER Support Module  . . . . . . . . . . . . . 215
;     12.22   .TYVRB - VRB Support Module  . . . . . . . . . . . . . 216
;     12.23   .TYZON - ZON Support Module  . . . . . . . . . . . . . 217
;     12.24   .TYDOR - Default Output Routine  . . . . . . . . . . . 218
	$TOC	Table of Contents (page 5)


;		     	Table of Contents for TYPER
;
;				  Section			    Page
;
;     12.25   .TDUMP - Default Buffer Flush Routine  . . . . . . . . 219
;     12.26   .TYFND - Find a String File  . . . . . . . . . . . . . 220
;     12.27   .TYVHT - Justification Flag Tester . . . . . . . . . . 221
;     12.28   The End  . . . . . . . . . . . . . . . . . . . . . . . 222
;   13. .TCVTD
;     13.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 223
;     13.2    Date/Time Convertions
;       13.2.1    .CNTDT . . . . . . . . . . . . . . . . . . . . . . 224
;       13.2.2    .CNNOW . . . . . . . . . . . . . . . . . . . . . . 226
;       13.2.3    .CNVDT . . . . . . . . . . . . . . . . . . . . . . 227
;     13.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 228
;   14. .TMISC
;     14.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 229
;     14.2    .TCPUT - Test for a CPU Type . . . . . . . . . . . . . 230
;     14.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 231
;   15. .TCRYP
;     15.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 232
;     15.2    The Encryption Count Table . . . . . . . . . . . . . . 233
;     15.3    .TCASC - Create a Seed from ASCIZ String . . . . . . . 234
;     15.4    .TCSIX - Create a Seed from SIXBIT Word  . . . . . . . 235
;     15.5    .TCRYP - Encrypt a Block of Data . . . . . . . . . . . 236
;     15.6    The End  . . . . . . . . . . . . . . . . . . . . . . . 238
;   16. .TSTPB
;     16.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 239
;     16.2    The TOPS-10 Code . . . . . . . . . . . . . . . . . . . 240
;     16.3    The TOPS-20 Code . . . . . . . . . . . . . . . . . . . 246
;     16.4    The End  . . . . . . . . . . . . . . . . . . . . . . . 247
;   17. .TFRAM
;     17.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 248
;     17.2    The $FRAME Macro Expansion . . . . . . . . . . . . . . 249
;     17.3    The $LOCAT Macro Expansion . . . . . . . . . . . . . . 250
;     17.4    The $PARAM Macro Expansion . . . . . . . . . . . . . . 251
;     17.5    The End  . . . . . . . . . . . . . . . . . . . . . . . 252
;   18. .TSAVE
;     18.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 253
;     18.2    Register Saving routines
;       18.2.1    .SAVEx . . . . . . . . . . . . . . . . . . . . . . 254
;       18.2.2    .PSH4T and .POP4T  . . . . . . . . . . . . . . . . 256
;       18.2.3    .SAVxT . . . . . . . . . . . . . . . . . . . . . . 257
;       18.2.4    .SAVET . . . . . . . . . . . . . . . . . . . . . . 259
;       18.2.5    .SAVEP . . . . . . . . . . . . . . . . . . . . . . 260
;     18.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 261
;   19. .TBITS
;     19.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 262
;     19.2    The Dummy Subroutine . . . . . . . . . . . . . . . . . 263
;     19.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 264
	$TOC	Table of Contents (page 6)


;		     	Table of Contents for TYPER
;
;				  Section			    Page
;
;   20. .TBYTE
;     20.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 265
;     20.2    The Dummy Subroutine . . . . . . . . . . . . . . . . . 266
;     20.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 267
;   21. .TENGL
;     21.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 268
;     21.2    The Dummy Subroutine . . . . . . . . . . . . . . . . . 269
;     21.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 270
;   22. .TFLOT
;     22.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 271
;     22.2    The Dummy Subroutine . . . . . . . . . . . . . . . . . 272
;     22.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 273
;   23. .TINTG
;     23.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 274
;     23.2    The Dummy Subroutine . . . . . . . . . . . . . . . . . 275
;     23.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 276
;   24. .TPICT
;     24.1    Initialization 15-May-83 /DRB  . . . . . . . . . . . . 277
;     24.2    The Dummy Subroutines
;       24.2.1    .TPICT . . . . . . . . . . . . . . . . . . . . . . 278
;       24.2.2    .TYPIC . . . . . . . . . . . . . . . . . . . . . . 279
;     24.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 280
;   25. .TROMN
;     25.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 281
;     25.2    The Dummy Subroutine . . . . . . . . . . . . . . . . . 282
;     25.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 283
;   26. .TNSUP
;     26.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 284
;     26.2    Type the Unsupported Message . . . . . . . . . . . . . 285
;     26.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 286
;   27. .TDATA
;     27.1    Initialization 15-May-83 /RWS  . . . . . . . . . . . . 287
;     27.2    Low Segment Data . . . . . . . . .  . . . . . . . 288
;     27.3    The End  . . . . . . . . . . . . . . . . . . . . . . . 289
	$TOC	TYPUNV -- History -- Revisions


;		   Revision History of TYPER
;
; Edit    Date     Who                    Comment
;
;    1  15-Nov-77  RWS	Initial edit level, %3(1).  The rewrite of TYPER
;			and add some new features:
;			   1. The $BLK substitution, size in block.
;			   2. The $CHR substitution, single right justi-
;			      fied ASCII character.
;			   3. The  $COR substitution, size in core (K or
;			      P).
;			   4. The  $DAT  and  $DTN  substitutions,  date
;			      (dd-mmm-yy).
;			   5. The  $DAY  and  $DYN substitutions, day of
;			      week.
;			   6. The  $LKP/$ENT  substitution, LOOKUP/ENTER
;			      block.
;			   7. $FUL   substitution,   full   word  SIXBIT
;			      without trailing blank suppression.
;			   8. The  $FUN  substitution, 'Funny' character
;			      (^x, 'x and SCAN-type).
;			   9. The $HEX substitution, hexadecimal.
;			  10. The $LIN substitution, new line (CR-LF).
;			  11. The $PRO substitution, protection.
;			  12. The $PTH substitution, path block.
;			  13. The $R50 substitution, RADIX-50.
;			  14. The  $RUN  substitution, jiffie and milli-
;			      second runtimes.
;			  15. The $SCN substitution, SCAN file block.
;			  16. The  $TIM  and $TMN substitutions, time of
;			      day.
;			  17. The     $UNV     substitution,   universal
;			      date/time.
;			  18. The $VER substitution, version number.
;			  19. The $XWD substitution, unsigned octal half
;			      words.
;			  20. The   $UR1-$UR7   substitutions   and  RTN
;			      function, user defined substitutions.
;			  21. The C return, return to monitor level, but
;			      allow a continue.
;			  22. The M return, return to monitor level.
;			  23. The   P  return,  return  to  the  calling
;			      routine (.POPJ).
;			  24. The  P1 return, skip return to the calling
;			      routine (.POPJ1).
;			  25. The  S  return,  return  to  SCAN's  error
;			      routine (.FMSGE).
;			  26. The  'address'  return,  return to a given
;			      location.
; Edit    Date     Who                    Comment
;
;			  27. The BUG function, system/program bug.
;			  28. The  COL  function, get the current column
;			      count.
;			  29. The INI function, initialize TYPER.
;			  30. The JST function, justification.
;			  31. The  LOC  function,  get the contents of a
;			      location when in a  user  defined  substi-
;			      tution.
;			  32. The   OUT   function,  change  the  output
;			      routine.
;			  33. The   SYS   function,  change  the  system
;			      prefix.
;			  34. The TIM function, time stamps.
;
;    2  08-Dec-77  RWS	Make TYPER recursive.
;
;    3  15-Dec-77  RWS	More of edit 2 and add some new features:
;			  1. The  $BIT  substitution, messages according
;			     to bit fields.
;			  2. The  $FUN substitution, allow 'Funny' ASCIZ
;			     strings.
;			  3. The $NUM substitution, numbers with special
;			     fill.
;			  4. The  $PFX  substitution, system prefix with
;			     an ASCII character or  3-SIXBIT  characters
;			     suffix.
;			  5. The $SPC substitution, multiple spaces.
;			  6. The  $SUB substitution, an indirect substi-
;			     tution string.
;			  7. The PRM function, output user prompts.
;			  8. The SAV and RST functions, save and restore
;			     TYPERs flags.
;
;    4  16-Dec-77  RWS	Allow DDT break-points on TYPER calls.
;
;    5  04-Jan-78  RWS	Add   some  new  features  to  the  $BIT  output
;			routine.
;
;    6  17-Jan-78  RWS	More of edit 2.
;
;    7  09-Feb-78  RWS	Change  the  OUT function and do some minor code
;			clean-up/changes.
;
;   10  12-Mar-78  RWS	Add a  new  argument  to  the  $TYPE  macro, the
;			routput outine to use on this call.
;
;   11  19-Mar-78  RWS	Add  a  new  substitution type ($NAM), a TOPS-10
;			user name with trailing blanks suppressed.
;
;   12  24-May-78  RWS	Allow indexed XCT's on TYPER calls.
; Edit    Date     Who                    Comment
;
;   13  31-May-78  RWS	Change  $FUN such that 1B0 is used instead of -1
;			in the left half to  specify  an  ASCIZ  string.
;			This  allows  'EOF'  and  'EOL'  to be output as
;			'Funny' characters.
;
;   14  05-Jul-78  RWS	Change  the  $FUN  and  $NAM  output routines to
;			calculate the effective address before the  byte
;			pointer stuff is put into the left half.
;
;   15  09-Aug-78  RWS	Add 'M' prefix to TYPER for operator information
;			messages.  Note:  These  message  don't  require
;			operator intervention.
;
;   16  01-Sep-78  RWS	Don't  output  time  stamps  on  internal  $TYPE
;			calls.
;
;   17  06-Sep-78  RWS	Add  the  save  AC  routines, .SAVEx, in SCAN to
;			TYPER.
;
;   20  06-Sep-78  RWS	Add  support  to  output 'X for lower case char-
;			acters in a $FUN ASCIZ string.
;
;   21  08-Sep-78  RWS	Add  the  'N1' return type to $TYPE, which skips
;			the following instruction.
;
;   22  08-Sep-78  RWS	Convert   .TCHAR  to  use  OUTSTR's  instead  of
;			OUTCHR's, this feature is about 60% faster, also
;			add the DMP $TYPES function to dump the buffer.
;
;   23  13-Sep-78  RWS	Add  ERR  function,  which  adds  1 to .JBERR on
;			fatal errors.
;
;   24  13-Sep-78  RWS	Allow  $RUN  substitution  to  output parts of a
;			second.
;
;   25  19-Sep-78  RWS	Add  $DTL  substitution,  which  outputs date as
;			'Month day, year', and $TML substitution,  which
;			outputs time as 'hh:mm a.m./p.m.'.
;
;   26  22-Sep-78  RWS	Change TYPER's version number to 4.
;
;   27  22-Sep-78  RWS	Remove  the  delimiter  character from the $TYPE
;			macro and make  the  delimiter  character  be  a
;			vertical bar (|).
;
;   30  26-Sep-78  RWS	Remove  the  $DTN,  $DYN  and  $TMN substitution
;			types and change the $DAT, $DAY and $TIM substi-
;			tution  types  to  allow  the user to output the
;			current date, day and time.
;
;   31  28-Sep-78  RWS	Make   the   .SAVEx  routines  be  conditionally
;			assembled if SCAN isn't being used.
; Edit    Date     Who                    Comment
;
;   32  28-Sep-78  RWS	Use the PFALL macro, to be on the safe side.
;
;   33  29-Sep-78  RWS	Remove the RST function from $TYPES and make the
;			SAV function save the data on the stack.
;
;   34  04-Oct-78  RWS	Add  the $ERR substitution type, which outputs a
;			file LOOKUP/ENTER error  message  and  the  file
;			name.
;
;   35  06-Oct-78  RWS	Add  a comma (TF.COM) as a separater to the $BIT
;			substitution.
;
;   36  09-Oct-78  RWS	Change  the  return  routines  to use SCAN if is
;			loaded.   The  new  return  routines   work   as
;			follows:
;			  C - Do a monitor return (.MONRT) followed by a
;			       POPJ on a continue.
;			  D - Enter DDT if present else the same as an M
;			       return.
;			  E - Process  the  /RUN  or  /EXIT  (.RUNCM) if
;			       given, then do a monitor return  (.MONRT)
;			       followed by an EXIT on a continue.
;			  M - Do  a  monitor return (.MONRT) followed by
;			       an EXIT on a continue.
;
;   37  09-Oct-78  RWS	Add  'C'  prefix  to  TYPER  for  a continuation
;			message and support for the error message stand-
;			ard (prefix, first-line and continuation).
;
;   40  11-Oct-78  RWS	Add  support for left justified protection codes
;			in the $PRO substitution routine.
;
;   41  12-Oct-78  RWS	Allow  $ENT,  $ERR  and  $LKP  substitutions  to
;			accept a .FILOP block pointer.
;
;   42	17-Oct-78  DRB	Fix  a bug in the new '$TYPES SAV' routine which
;			implicitly calls the restore code on a 'POPJ P,'
;			or  '.POPJ1'.   The  wrong  item on the stack is
;			being adjusted for non-skip return.
;
;   43  23-Oct-78  RWS	The  $LIN  substitution now has a parameter, the
;			number of CR-LF's to output  or  if  negative  a
;			form-feed.
;
;   44  25-Oct-78  RWS	Add  $SKP  and  $EOS  substitutions,  which will
;			conditionally suppress output on a $TYPE call.
;
;   45  26-Oct-78  RWS	Allow  the user to specify an optional substitu-
;			tion character in the $TYPER macro.
;
;   46  26-Oct-78  RWS	Change TYPER's version number to 5.
; Edit    Date     Who                    Comment
;
;   47  01-Nov-78  RWS	Fix  a  bug  if SCAN isn't being used in $TYPER,
;			you can't send the MOVX macro a '<' or a '>'.
;
;   50  16-Nov-78  RWS	Allow  $ASC,  $FUN  and  $SUB  to specify a byte
;			pointer and an effective address.
;
;   51  16-Nov-78  RWS	Add  a  new  output  type  (BYTE) to the $NUMBER
;			macro, the address contains a byte pointer to  a
;			byte to be output as an unsigned integer.
;
;   52  20-Nov-78  RWS	More of edit 50.
;
;   53  03-Jan-79  RWS	Allow the substitution parameters to be supplied
;			in the $TYPE call.
;
;   54  17-Jan-79  RWS	Add  support  to expand the $TYPER macro without
;			SCAN support.
;
;   55  17-Jan-79  RWS	Add  'A'  (Abort) return type, which outputs the
;			PC of the $TYPE call before it does a 'D'  (DDT)
;			return.
;
;   56  17-Jan-79  RWS	Don't  output  time  stamps  on 'D' (DDT) return
;			type.
;
;   57  13-Mar-79  RWS	Make   the   abort  message  be  output  to  the
;			terminal.
;
;   60  05-Apr-79  RWS	Allow  the  macros, variable name(s), created by
;			the $VARIABLE macro to have  offsets  after  the
;			macro name.
;
;   61  05-Apr-79  RWS	Add  support  for the KL20, KS10 and KS20 in the
;			$FRAME macro.
;
;   62  06-Apr-79  RWS	Start adding TOPS-20 support and do some general
;			code clean up.
;
;   63  12-Apr-79  RWS	Add  the $JFN substitution type, which outputs a
;			TOPS-20 file specification.
;
;   64  26-Apr-79  RWS	Convert  to use the IFDIFX and IFIDNX psuedo-OPs
;			in MACRO (a local patch).
;
;   65  21-May-79  RWS	More  of  edit  62;  the dates and times are in-
;			correct (due to time zones).
;
;   66  23-May-79  RWS	Add  ZON  function to $TYPES, allows the user to
;			specify the time zone for the $TML substitution.
;
;   67  23-May-79  RWS	If  time stamps are being output and a prompt is
;			requested you get 2 time stamps.
; Edit    Date     Who                    Comment
;
;   70  12-Jun-79  RWS	In  the  expansion of TYPER search UUOSYM and/or
;			SCNMAC if %%UUOS and/or %%SCNM are not defined.
;
;   71  12-Jun-79  RWS	Add  a '+' (TF.PLS), nothing output (TF.NON) and
;			'!' (TF.XCL) as a separater to the $BIT  substi-
;			tution.
;
;   72  14-Jun-79  RWS	Add the $ERS substitution type, which outputs an
;			error string.
;
;   73  14-Jun-79  RWS	Add the .GTNOW routine to TYPER.
;
;   74  19-Jun-79  RWS	Add  the  PC  to  the output message if the user
;			specified a SCAN return and not using SCAN.
;
;   75  19-Jun-79  RWS	Change some macro names and remove the search of
;			MACTEN.
;
;   76  19-Jun-79  RWS	Search SYSMAC instead of STCMAC.
;
;   77  20-Jun-79  RWS	Change the $BIT substitution code to support the
;			$BITS macro.
;
;  100  28-Jun-79  RWS	Add  the $ROM substitution type, which outputs a
;			Roman numeral.
;
;  101  28-Jun-79  RWS	Add the $ALP substitution type, which outputs an
;			alpha number (1-A, ... 26-Z, 27-AA ...).
;
;  102  10-Jul-79  RWS	Add  support  for  the  new $VARIABLE and $FRAME
;			macros (local/global variables).
;
;  103  20-Jul-79  RWS	Add  support for floating-point output.  Various
;			parts of this code were  borrowed  from  ALGLIB,
;			FOCAL and FOROTS.
;
;  104  24-Jul-79  RWS	Add some routines to save T1-4.
;
;  105  06-Aug-79  RWS	The $TYPER macro was removed from SYSMAC.
;
;  106  17-Aug-79  RWS	Try  to  make  TYPER compatible with SCAN-11 for
;			TOPS-20 and do some general code clean up.
;
;  ***  17-Aug-79  RWS	The first field test release of SYSUNV/TYPER.
;
;  107  28-Aug-79  DRB	Fix  right  justification  problem  with numeric
;			output, move the number of  spaces  needed  into
;			T1.
;
;  110  29-Aug-79  RWS	Don't  search MONSYM on TOPS-10, they don't have
;			one to search.
; Edit    Date     Who                    Comment
;
;  111  29-Aug-79  RWS	Move some symbols out of SYSUNV and into TYPER.
;
;  112  30-Aug-79  DRB	KI10's  don't  have an ADJSP instruction, so fix
;			the conditionals in  floating-point output.
;
;  113  05-Sep-79  RWS	Make the time zone code a little more symbolic.
;
;  114  18-Sep-79  RWS	More  of edit 105; remove the listing option, if
;			you don't want a listing don't print it.
;
;  115  03-Oct-79  DRB	Add  the  $PIC  substitution,  which will take a
;			COBOL format 'picture'  field,  and  compile  an
;			EDIT  pattern  string  (which will edit a string
;			according to the picture).
;
;  116  04-Oct-79  RWS	More  of  edit  115; fix a few minor bugs in the
;			$PIC substitution code.
;
;  117  04-Oct-79  RWS	Segment the code a little more.
;
;  120  05-Nov-79  RWS	More of edit 106; forgot a few symbols.
;
;  121  08-Nov-79  RWS	More  of  edit  115;  if  you output the maximum
;			number possible you got an error return from the
;			CVTBDT extend instruction.
;
;  122  03-Dec-79  RWS	More   of   edit   106;   some  ACs  were  being
;			destroyed.
;
;  123  17-Jan-80  RWS	Convert  to  use  the  new  $NUMBER  macro, also
;			remove $ALP and $ROM substitution support.
;
;  124	22-Jan-80  RWS	Remove the $PIC substitution and modify the $NUM
;			substitution to support $PIC functions.
;
;  125  21-Mar-80  RWS	Fix  a  bug  in the tab stop justification code.
;			If you did the following a tab stop was ignored:
;			  Tab		Go to a tab stop
;			   |		Do  a substitution that stops at
;					the next tab stop.
;			  Tab		Went   to  the  next  tab  stop,
;					instead of using the current one
;
;  126  11-Apr-80  RWS	Add  the  $XCT  substitution type, which does an
;			indirect substitution.
;
;  127  17-Apr-80  RWS	Fix  a  duplicate  label  in  the  picture  code
;			(TPIC06), non-KL/KS.
;
;  ***  17-Apr-80  RWS	Change the major version number to 6.
; Edit    Date     Who                    Comment
;
;  130  02-May-80  RWS	Do some minor clean-up and add QUASAR support.
;
;  131  02-May-80  RWS	Start adding PSECT support to TYPER.
;
;  132  15-May-80  RWS	Allow  the  user  to  specify an optional return
;			address on a $TYPES BUG.
;
;  133  15-May-80  RWS	On TOPS-20 if page 770 exists assume it contains
;			DDT.
;
;  134  15-May-80  RWS	Add support for negative time zones.
;
;  135  22-May-80  RWS	More of edit 117; continue segmenting the code.
;
;  136  24-May-80  RWS	More of edit 132; broke an old feature.
;
;  137  30-May-80  DRB	The  $ERS  substitution  was  loading the string
;			length into the wrong AC.
;
;  140  31-May-80  RWS	The  $DAY  substitution  didn't account for time
;			zones on TOPS-20.
;
;  141  05-Aug-80  RWS	Use  a  LSH  instead  of an ASH in the floating-
;			point output code incase someone is  using  also
;			using FOROTS; this avoids APR traps.
;
;  142  15-Sep-80  RWS	Replace the floating-point output code.
;
;  143  22-Oct-80  RWS	Allow  $BIT  substitution to output bit numbers,
;			1B35.
;
;  144  12-Nov-80  RWS	Add  support  for the $DIR and $USR substitution
;			types, which are the identical and output a user
;			or directory number.
;
;  145  16-Nov-80  RWS	Finish adding the PSECT support, use the section
;			called '.IOSEC'.
;
;  146  16-Nov-80  RWS	Make  the  picture  code use stack variables in-
;			stead of local storage for all variables.
;
;  147  16-Nov-80  RWS	Remove the picture saving conditional, it is now
;			always on.
;
;  150  25-Nov-80  RWS	Make the picture code run on non-KL's again.  It
;			isn't recursive for non-KL CPUs.
;
;  151  25-Nov-80  RWS	Change  the entry in picture code from TYPPIC to
;			.TYPIC.
; Edit    Date     Who                    Comment
;
;  152  30-Nov-80  RWS	Start  adding the database 'Phase I' code:  make
;			the low segment (database) be referenced with an
;			index register (TB).
;
;  153  08-Dec-80  RWS	Start  converting over to the new data structure
;			macros in SYSUNV.
;
;  154  08-Dec-80  RWS	More  of  edit  152; add the DAT function, which
;			allows user to change the databases.
;
;  155  12-Dec-80  RWS	Add  support  for  output message levels, change
;			the old message level stuff to verbosity levels.
;
;  156  15-Dec-80  RWS	Start  adding the database 'Phase II' code:  the
;			output routine is no  longer  specified  in  the
;			$TYPE call, the database address is specified.
;
;  157  15-Dec-80  RWS	Add  the  EMP function ($TYPES), which specifies
;			the routine to call on a $TYPES (DMP) call.
;
;  160  16-Dec-80  RWS	If  the  RENAME block in a FILOP. block contains
;			a valid error  number  use  it  instead  of  the
;			LOOKUP/ENTER block.
;
;  161  23-Dec-80  RWS	Add support for the error database.
;
;  162  26-Dec-80  RWS	Allow  the  user  to  supply the section name at
;			assembly time.
;
;  163  05-Jan-81  RWS	Process  an $XCT substitution when doing an $ELS
;			or $SKP substitution.
;
;  164  07-Jan-81  RWS	More  of  edits 152 and 156; fix wild transfers,
;			because TB wasn't set up.
;
;  165  30-Jan-81  RWS	More  of  edit  155, the message level was being
;			reset before end of line.
;
;  166  10-Feb-81  RWS	Add support for $TYPE type returns in $TYPES.
;
;  167  13-Feb-81  RWS	Add support for the TYPER database, internal use
;			only
;
;  170  16-Feb-81  RWS	Add support for the 'B' TYPER header type.
;
;  ***  16-Feb-81  RWS	Change the version number to 7.
;
;  171  09-Mar-81  RWS	Add support for vertical justification.
;
;  172  03-Jun-81  RWS	Add support to initialize a database, via $TYPES
;			BAS.
; Edit    Date     Who                    Comment
;
;  173  03-Jun-81  RWS	Allow  the  argument  address to be specified in
;			the $TYPES call, this would allow  the  argument
;			to  be  supplied  in  and returned to some place
;			other than T1.
;
;  174  04-Jun-81  RWS	More  of  edit  37,  output  the  address of the
;			message after the prefix and before the space.
;
;  175  04-Jun-81  RWS	Add the $OPC substitution, which will output a 6
;			character PC (zero fill).
;
;  176  05-Jun-81  RWS	Add  some new features to the $JFN substitution,
;			allow  the  user  to  specify  the   information
;			wanted.
;
;  177  18-Jun-81  RWS	More  of  edit  175,  set  up FP to point to the
;			previous stack frame.
;
;  200  01-Jul-81  RWS	More  of  edit  156,  fix  $TYPES  (LOC), it was
;			pointing to the wrong frame on the stack.
;
;  201  15-Jul-81  RWS	Add  support  for  the I (Interrupt) return from
;			TYPER, which does a DEBRK. or DEBRK%  to  return
;			from interrupt.
;
;  202  20-Jul-81  RWS	Add support for the new $FRAME macro.
;
;  203  27-Jul-81  JMS	The $VER substitution was outputting the version
;			number incorrectly; the $POINT macro  was  being
;			supplied the wrong mask.
;
;  204  30-Jul-81  RWS	More  of  edit 175, the $OPC substitution didn't
;			output the previous PC correctly.
;
;  205  30-Jul-81  RWS	Make sure the set subfunction (.TFSET) of $TYPES
;			(BAS) is zero.
;
;  206  30-Jul-81  RWS	Start adding support for external ASCIZ strings.
;
;  207  30-Jul-81  RWS	Change  $SETUP  to $BEGIN, because some nameless
;			person changed the name of the macro.
;
;  210  03-Aug-81  RWS	Add support for $TYPES (EXT), external strings.
;
;  211  04-Aug-81  RWS	Add  support  for  $TYPES  (ESN),  error  string
;			numbers.
;
;  212  07-Aug-81  RWS	Allow  the  user  to  supply  the database to be
;			modified on this $TYPES call.
;
;  213  12-Aug-81  RWS	If the external string address is zero, output a
;			default message.
; Edit    Date     Who                    Comment
;
;  214  12-Aug-81  RWS	Return  the  JFN assigned in the left half of T1
;			on a $TYPES (EXT) call.
;
;  215  18-Aug-81  RWS	Make two sections, one for code (.IOCOD) and one
;			for data (.IODAT).
;
;  216  19-Aug-81  RWS	Add support for the new macro listing feature.
;
;  217  19-Aug-81  RWS	The $TYPES BUG data can be reduced by one word.
;
;  220  24-Aug-81  JMS	Output the sign before the floating dollar sign,
;			floating point output, and  change  one  of  the
;			PRINTX information messages
;
;  221  24-Aug-81  RWS	Allow preamble in an external string file, which
;			contains the version number and range  of  valid
;			string numbers.
;
;  222	26-Aug-81  RWS	Add the 'Non-Disclaimer' page.
;
;  ***  26-Aug-81  RWS	Release the current copy of TYPER on the world.
;
;  223  27-Aug-81  RWS	Change SUBTTL's to $TOC's.
;
;  224  16-Sep-81  RWS	Add support to convert multiple spaces to tabs.
;
;  225  29-Sep-81  RWS	Change all $TYPES BUG's to fatal error messages.
;
;  226  30-Sep-81  RWS	More of edit 224, didn't clear the correct flags
;			and preserve register T3.
;
;  227  30-Sep-81  RWS	Banks'ize the comments.
;
;  230  30-Sep-81  RWS	Put in more TOPS-10 contitionals.
;
;  231  20-Oct-81  RWS	Add  support  to  separate  bit  messages with a
;			space.
;
;  232  21-Oct-81  RWS	Put  the  TYPER  return  address  in .JBOPC when
;			entering DDT.
;
;  233  30-Oct-81  RWS	Add  support for the $SKT substitution, suppress
;			(skip) output if TRUE.
;
;  234  10-Nov-81  RWS	Allow $EOS to be supplied an argument.
;
;  235  17-Feb-82  RWS	Don't  enter  DDT  if  JFN  not assigned on $JFN
;			substitution.
;
;  236  16-May-82  RWS	Convert to the new table of contents generator.
; Edit    Date     Who                    Comment
;
;  237  04-Jun-82  DRB	Don't abort on TOPS-10  if  the  GETTAB  to  get
;			Greenwich Mean Time fails.
;
;  240  18-Jun-82  RWS	Add  support  for  the  $CON substitution, which
;			allows  the  user  to  switch  to a continuation
;			message while in a non-C header type.
;
;  241  21-Jun-82  RWS	Add code to test for CPU type.
;
;  242  22-Dec-82  RWS	When outputting the version number test  to  see
;			if the contents of .JBVER or the entry vector is
;			wanted.
;
;  243  29-Dec-82  RWS	Change  the $NON substitution so that it outputs
;			a vertical bar (|).
;
;  244  01-Jan-83  RWS	Add  support  for  the  $BYT  substitution type,
;			which outputs a string of bytes.
;
;  245  03-Jan-83  RWS	The  wrong value was being returned from $TYPES
;			EXT if the external strings were out of range.
;
;  246  03-Jan-83  RWS	Add some ALC style encryption routines.
;
;  247  04-Jan-83  RWS	Move  the routines .TALPH and .TSPEC into module
;			.TSUPT to   reduce  the  amount  of core  needed
;			to compile TYPER.
;
;  250  16-Jan-83  RWS	Don't  output  the  seperator  space  after  the
;			leading character if the prefix isn't output
;
;  251  16-JAN-83  RWS	Allow  .TFCUR on any substitution type that it's
;			practical.
;
;  252  16-Jan-83  RWS	Modify  the  comments  that describe the calling
;			sequence on about all of routines.
;
;  253  17-Jan-83  RWS	Make $DIR and $USR seperate substitution types.
;
;  254  18-Jan-83  RWS	Add  a  new  module  .TSTPB,  which is very much
;			like SCAN's .STOPB.
;
;  255  18-Jan-83  RWS	After  17  months  finish  implementing external
;			strings for TOPS-10.
;
;  256  18-Jan-83  RWS  If  the  offset  to the external string is zero,
;			output the  default  message  for  the  external
;			string file.
;
;  257  22-Jan-83  RWS	Don't  read  the  preamble  if  searching for an
;			external string.
; Edit    Date     Who                    Comment
;
;  260  22-Jan-83  RWS	Reorganize things a little bit.
;
;  261  24-Jan-83  RWS	Inform the world what version of SYSUNV is being
;			is used to assemble TYPER.
;
;  262  03-Feb-83  RWS	Make  sure the CPU is defined, when assembling a
;			QUASAR interface and the CPU isn't defined.
;
;  263  15-May-83  RWS	Output  36-bit  bytes correctly in the $BYT sub-
;			stitution.
;
;		*** The End of the Revision History ***
	$TOC	TYPUNV -- History -- Suggestions


;		   Suggestion History for TYPER
;
; Number   Date    Who                   Comment
;
;    1* 15-Nov-77  RWS	Make  the  listing  look  nicer, by making TYPER
;			calls do "PUSHJ P,@[...]".
;
;    2* 29-Nov-78  RWS	Allow   some   sort  of  vertical  justification
;			support, something like $TYPES (JST).
;
;    3* 29-Nov-78  RWS	Output  a carriage return if a vertical position
;			isn't preceeded by one, time stamps only.
;
;    4  12-Jun-79  RWS	Add  the  $CHN  substitution  which is something
;			like the $JFN substitution,  except  in  TOPS-10
;			7.02.
;
;    5* 01-Aug-79  RWS	Add support for some sort of data-base.
;
;    6* 03-Jan-80  JMS	Add support to convert multiple spaces to tabs.
;
;    7  15-May-80  DRB	Allow  a  substitution to supply the argument by
;			doing an execute on the contents for T1.
;
;   10* 29-Oct-80  DRB	Add support for error/message level in the char-
;			acter routine.
;
;   11* 29-Oct-80  DRB	Finish the .PSECT feature.
;
;   12* 12-Nov-80  JMS	Get  the  error number for the FILOP. block from
;			the RENAME subblock if  present,  else  use  the
;			LOOKUP subblock.
;
;   13* 10-Feb-81  RWS	Allow  the  argument  address to be specified in
;			the $TYPES call, this would allow  the  argument
;			to be supplied in and  returned  to  some  place
;			other than T1.
;
;   14  05-Jul-81  RWS	Allow  the $IND substitution to be used like any
;			other substitutions.
;
;   15* 15-Jul-81  DRB	Allow something like $ERS on TOPS-10.
;
;   16* 29-Jul-81  RWS	Allow the $TYPES macro to specify which database
;			is to be modified.
; Number   Date    Who                   Comment
;
;   17* 14-Oct-82  JMS	If  the  prefix  isn't wanted and an information
;			message is being output don't output  the  space
;			after the "[".
;
;   20* 22-Dec-82  RWS	Allow .TFCUR any place it would be feasible.
;
;   21* 23-Dec-82  RWS	Finish implementing external strings on TOPS-10.
;
;   22  02-Jan-83  RWS	If either half of the PPN contains a zero in the
;			SCAN block, substitute the appropriate half word
;			from the user's logged in PPN.
;
;   23  02-Jan-83  RWS  Thirty-six  (36)  bit  bytes aren't being output
;			correctly by the $BYT substitution.
;
;     * - Implemented features.
;
;		*** The End of the Suggestion History ***
	$TOC	TYPUNV -- History -- Deficiencies


;		Deficiency History for TYPER
;
; Number   Date    Who			Comment
;
;    1* 15-Nov-77  RWS	Needs lots of new features.
;
;    2  06-APR-79  RWS  The TOPS-20 code won't work if T1 isn't register
;			1.
;
;    3  20-Jul-79  RWS	No support for double precision floating-point.
;
;    4* 18-Jun-81  RWS	$TYPES  (LOC)  it doesn't work as documented, FP
;			is pointing to the current  frame  and  NOT  the
;			previous one, broke by edit 156
;
;    5  29-Jun-81  RWS	A  $SKP  that skips over a $SUB doesn't work, it
;			should go down the $SUB branch.
;
;    6  05-Jul-81  RWS	TYPER only works in section 0.
;
;    7  13-Aug-82  RWS	The  date  routines  can't  output  dates before
;			January 1, 1964.  (Isn't that a strange date?)
;
;   10  01-Nov-82  DRB	If an information message is interrupted  before
;			it completes and another message  is  using  the
;			same  data-base only the interrupt level message
;			gets a "]".
;
;     * - No longer a deficiency.
;
;		*** The End of the Deficiency History ***
	$TOC	TYPUNV -- Conditional Assembly Values -- Description


;    TYPER is the support module for the $TYPE and  $TYPES  macros
; defined  in  SYSUNV.   It  also  contains  expansions of several
; support macros found in SYSUNV,  such  as  $FRAME,  $LOCATE  and
; $PARAMETER.   In  addition  it  contains  several stack routines
; (.PSHT4,  POPT4,  .SAVEx  and  .SAVxT)  and  date/time  routines
; (.CNTDT, .CNVDT and .GTNOW).
;
;
;    The following is a list of the conditional assembly  features
; test switches:
;
; T$MON - The monitor the TYPER is to executed on.
;           TOPS10 - The monitor is TOPS-10.
;           TOPS20 - The monitor is TOPS-20.
;         Note:  The default is TOPS20.
;
; T$SYS - The TYPER system to be defined.
;	    NORMAL - A normal support system.
;	    QUASAR - A QUASAR support system.
;	  Note:  The default is NORMAL.
;
; T$SCN - SCAN is being used.
;           NOSCAN - SCAN isn't being used.
;           SCAN   - SCAN is being used.
;         Note:  The default is NOSCAN.
;
; T$SEG - The number of segments TYPER is to be in.
;	    MANY - Two segment code, PSECT (TYPER) for code  and
;		   low for data.
;           ONE  - One segment code, low for code and data.
;           TWO  - Two segment code, high for code and  low  for
;                  data.
;         Note:  The default is TWO.
;
; T$COD - The name of the code section (PSECT).
;         Note:  The default is .IOCOD .
;
; T$DAT - The name of the data section (PSECT).
;         Note:  The default is .IODAT .
;
;		** Continued on the next page **
; T$CPU - The CPU TYPER will be executed on.
;           PDP6 - The CPU is a PDP-6.
;           KA10 - The CPU is a KA-10.
;	    KC10 - The CPU is a KC-10.
;	    KC20 - The CPU is a KC-20.
;           KI10 - The CPU is a KI-10.
;           KL10 - The CPU is a KL-10.
;           KL20 - The CPU is a KL-20.
;           KS10 - The CPU is a KS-10.
;           KS20 - The CPU is a KS-20.
;         Note:  The default is the CPU TYPER is assembled on.
;
; T$ACS - The base value for AC T1.
;         Note:  The  default  is  1,  unless  it is for a QUASAR
;	         system then the default is 3.
;
; T$SAP - If defined:  .SAVE1 thru .SAVE4 aren't assembled.
;
; T$SAT - If defined:  .SAV1T thru .SAV4T aren't assembled.
;
; T$SA4 - If defined:  .PSH4T and .POP4T aren't assembled.
;
; T$TBS - The number of words to use for the terminal buffer.
;	  Note:  The default is ^D27.
;
; T$EBS - The number of words to use for the external string buffer.
;	  Note:  The default is ^D128 for TOPS-10 and ^D64 for
;		 TOPS-20.
;
; T$ESF - The maximum number of external string files.
;	  Note:  The default is ^D10.
	$TOC	TYPUNV -- Conditional Assembly Values -- Some Constants


; Define the monitor types

	TF%T10==^O1			; TOPS10 monitor
	TF%T20==^O2			; TOPS20 monitor


; Define the system types

	TF%NRM==^O0			; Normal TYPER system
	TF%QSR==^O1			; QUASAR TYPER system


; Define the segment types

	TF%ONE==^O1			; One segment code
	TF%TWO==^O2			; Two segment code
	TF%MAN==^O3			; PSECT code


; Define the save types

	TF%SAP==^O1			; .SAVEx routines
	TF%SAT==^O2			; .SAVxT routines
	TF%SA4==^O4			; .PSH4T/.POP4T routines


; Define some ON/OFF feature types

	TF%ON==-^O1			; The feature is on
	TF%OFF==^O0			; The feature is off


; Define the CPUs

	TF%PDP==^O1			; PDP-6
	TF%KA1==^O2			; KA-10 (1040, 1050 or 1055)
	TF%KI1==^O3			; KI-10 (1060, 1070 or 1077)
	TF%KL1==^O4			; KL-10 (1080, 1088, 1090, 1091 or 1099)
	TF%KL2==^O4			; KL-20 (2040, 2050 or 2060)
	TF%KS1==^O4			; KS-10 (2020 running TOPS-10)
	TF%KS2==^O4			; KS-20 (2020 running TOPS-20)
	TF%KC1==^O5			; KC-10 (4050 running TOPS-10)
	TF%KC2==^O5			; KC-20 (4050 running TOPS-10)
	$TOC	TYPUNV -- Conditional Assembly Values -- Verification


;		** Reset some flags **

IF1,<
   PURGE TF%ACS,TF%TBS,TF%CPU,TF%EBS,TF%MON,TF%ESF,TF%SAV,TF%SCN,TF%SEG,TF%SVP,TF%SYS >


;		** Verify the monitor option **

IFNDEF T$MON,<
  TF%MON==TF%T20			; TOPS20 monitor (default)
  T$MON=='TOPS20' >
IFDEF T$MON,<
  IFE <T$MON-'TOPS10'>,<TF%MON==TF%T10>	; TOPS10 monitor
  IFE <T$MON-'TOPS20'>,<TF%MON==TF%T20>>; TOPS20 monitor

IFNDEF TF%MON,<$PRINT F,AUM,TYPUNV - An undefined monitor option >


;		** Verify the system option **

IFNDEF T$SYS,<TF%SYS==TF%NRM>		; Normal TYPER system (default)
IFDEF T$SYS,<
  IFE <T$SYS-'NORMAL'>,<TF%SYS==TF%NRM>	; Normal TYPER system
  IFE <T$SYS-'QUASAR'>,<		; QUASAR TYPER system
    TF%SYS==TF%QSR
    T$SAP=='QUASAR'>>

IFNDEF TF%SYS,<$PRINT F,AUS,TYPUNV - An undefined system option >


;		** Verify the SCAN option **

IFNDEF T$SCN,<TF%SCN==TF%OFF>		; Don't use SCAN (default)
IFDEF T$SCN,<
  IFE <T$SCN-'NOSCAN'>,<TF%SCN==TF%OFF>	; Don't use SCAN
  IFE <T$SCN-'SCAN'>,<TF%SCN==TF%ON>>	; Use SCAN

IFNDEF TF%SCN,<$PRINT F,AUS,TYPUNV - An undefined SCAN option >
;		** Verify the segment option **

IFNDEF T$SEG,<TF%SEG==TF%TWO>		; Force two segments (default)
IFDEF T$SEG,<
  IFE <T$SEG-'MANY'>,<TF%SEG==TF%MAN>	; Force many segments
  IFE <T$SEG-'ONE'>,<TF%SEG==TF%ONE>	; Force one segment
  IFE <T$SEG-'TWO'>,<TF%SEG==TF%TWO>>	; Force two (high/low) segments

IFNDEF TF%SEG,<$PRINT F,AUS,TYPUNV - An undefined segment option >


;		** Verify the code section name option **

IFNDEF T$COD,<TF%COD=='.IOCOD'>		; .IOCOD (default)
IFDEF T$COD,<TF%COD==T$COD>		; Section name


;		** Verify the data section name option **

IFNDEF T$DAT,<TF%DAT=='.IODAT'>		; .IODAT (default)
IFDEF T$DAT,<TF%DAT==T$DAT>		; Section name


;		** Verify the CPU option **

IF1,<
  IFNDEF T$CPU,<
    IFE <TF%SYS-TF%QSR>,<
      TF%CPU==TF%KL1 			; Default (QUASAR)
      T$CPU=='KL10' >
    IFN <TF%SYS-TF%QSR>,<
      TF%CPU==.CPU.			; Default (non-QUASAR)
      T$CPU==^O0 >>
  IFDEF T$CPU,<
    IFE <T$CPU-'PDP6'>,<TF%CPU==TF%PDP>	; PDP-6
    IFE <T$CPU-'KA10'>,<TF%CPU==TF%KA1>	; KA-10
    IFE <T$CPU-'KC10'>,<TF%CPU==TF%KC1>	; KC-10
    IFE <T$CPU-'KC20'>,<TF%CPU==TF%KC2>	; KC-20
    IFE <T$CPU-'KI10'>,<TF%CPU==TF%KI1>	; KI-10
    IFE <T$CPU-'KL10'>,<TF%CPU==TF%KL1>	; KL-10
    IFE <T$CPU-'KL20'>,<TF%CPU==TF%KL2>	; KL-20
    IFE <T$CPU-'KS10'>,<TF%CPU==TF%KS1>	; KS-10
    IFE <T$CPU-'KS20'>,<TF%CPU==TF%KS2>>>  ; KS-20

IFNDEF TF%CPU,<$PRINT F,UCO,TYPUNV - An undefined CPU option >


;		** See if 'Save' routines are needed **

TF%SAV==^O0				; Assume no save routines
IFDEF T$SAP,<TF%SAV==<TF%SAV!TF%SAP>>	; .SAVEx aren't needed
IFDEF T$SAT,<TF%SAV==<TF%SAV!TF%SAT>>	; .SAVxT aren't needed
IFDEF T$SA4,<TF%SAV==<TF%SAV!TF%SA4>>	; .PSH4T/.POP4T aren't needed
;		** Verify the ACs will be defined correctly **

IFNDEF T$ACS,<
  IFE <TF%SYS-TF%QSR>,<TF%ACS==^O3>	; AC base (QUASAR default)
  IFN <TF%SYS-TF%QSR>,<TF%ACS==^O1>>	; AC base (non-QUASAR default)
IFDEF T$ACS,<
  TF%ACS==T$ACS				; Define the AC base value
  IFGE <TF%ACS-^O6>,<$PRINT F,AND,TYPUNV - The ACs are not defined correctly >
  IFE <TF%SYS-TF%QSR>,<
    IFN <TF%ACS-^O3>,<$PRINT F,AND,TYPUNV - The ACs are not defined correctly >>
  IFE <TF%SCN-TF%ON>,<
    IFN <TF%ACS-^O1>,<$PRINT F,AND,TYPUNV - The ACs are not defined correctly >>
  IFE <TF%MON-TF%T20>,<
    IFN <TF%ACS-^O1>,<$PRINT F,AND,TYPUNV - The ACs are not defined correctly >>>


;		** Verify the character buffer siz e **

IFNDEF T$TBS,<TF%TBS==^D27>		; 27 (default)
IFDEF T$TBS,<
  IFG <T$TBS>,<TF%TBS==T$TBS>>

IFNDEF TF%TBS,<$PRINT F,ICB,TYPUNV - Illegal terminal buffer size >


;		** Verify the external buffer size **

IFNDEF T$EBS,<
  IFE <TF%MON-TF%T10>,<TF%EBS==^D128>	; 128 (TOPS-10 default)
  IFE <TF%MON-TF%T20>,<TF%EBS==^D64>>	; 64 (TOPS-20 default)
IFDEF T$EBS,<
  IFG <T$EBS>,<TF%EBS==T$EBS>>

IFNDEF TF%EBS,<$PRINT F,IEB,TYPUNV - Illegal external buffer size >


;		** Verify the number external string files **

IFNDEF T$ESF,<TF%ESF==^D10>		; 10 (default)
IFDEF T$ESF,<
  IFG <T$ESF>,<TF%ESF==T$ESF>>

IFNDEF TF%ESF,<$PRINT F,IES,TYPUNV - Illegal number of external string files >


;		** Verify the default encryption key **

IFNDEF T$CRP,<TF%CRP==^O13702175435>	; The default
IFDEF T$CRP,<TF%CRP==T$CRP>

IFNDEF TF%CRP,<$PRINT F,IEK,TYPUNV - Illegal default encryption key specified >
	$TOC	TYPUNV -- Conditional Assembly Values -- Display Options Selected


;		** Inform the user what he's getting **

IF1,<

;		** The version of SYSUNV used **

$TITLE	<[Assembling TYPER with SYSUNV version>,SYS,PRINTX,1,<]>

;		** The monitor option **

IFE <TF%MON-TF%T10>,<PRINTX [Assembling TYPER for a TOPS-10 monitor]>
IFE <TF%MON-TF%T20>,<PRINTX [Assembling TYPER for a TOPS-20 monitor]>

;		** The system option **

IFE <TF%SYS-TF%NRM>,<PRINTX [Assembling TYPER with normal interface]>
IFE <TF%SYS-TF%QSR>,<PRINTX [Assembling TYPER with QUASAR interface]>

;		** The SCAN option **

IFE <TF%SCN-TF%ON>,<PRINTX [Assembling TYPER with SCAN interface]>
IFE <TF%SCN-TF%OFF>,<PRINTX [Assembling TYPER without SCAN interface]>

;		** The segment option **

IFE <TF%SEG-TF%ONE>,<PRINTX [Assembling TYPER with one segment code]>
IFE <TF%SEG-TF%TWO>,<PRINTX [Assembling TYPER with two segment code]>
IFE <TF%SEG-TF%MAN>,<PRINTX [Assembling TYPER with section code]>

;		** The CPU option **

IFE <TF%CPU-TF%PDP>,<PRINTX [Assembling TYPER for a PDP-6 CPU]>
IFE <TF%CPU-TF%KA1>,<PRINTX [Assembling TYPER for a KA-10 CPU]>
IFE <TF%CPU-TF%KI1>,<PRINTX [Assembling TYPER for a KI-10 CPU]>
IFE <TF%CPU-TF%KL1>,<PRINTX [Assembling TYPER for a KL-10/20 and KS-10/20 CPU]>>
	$TOC	TYPUNV -- Define the $INIT Macro


DEFINE	$INIT [SALL/PERMANENT] ($TTL,$ENT,$SEC),<

;;		** Search some universal files **

SEARCH SYSUNV				;; Some local macros/symbols

IFE <TF%MON-TF%T10>,<
  SEARCH UUOSYM				;; DECs UUO symbols
  SEARCH SCNMAC				;; DECs SCAN/WILD macros (TOPS-10) >
IFE <TF%MON-TF%T20>,<
  SEARCH MONSYM				;; DECs JSYS symbols
  SEARCH SCNM20				;; DECs SCAN/WILD macros (TOPS-20) >

;;		** Define the title **

IFE <TF%SEG-TF%ONE>,<			;; One segment TYPER
  $BEGIN (<$TTL>,TYP,,<BITS,ONE,NOACS>) >
IFE <TF%SEG-TF%TWO>,<			;; Two segment TYPER
  $BEGIN (<$TTL>,TYP,,<BITS,TWO,NOACS>)
  $HIGH					;; High segment code >
IFE <TF%SEG-TF%MAN>,<			;; Section TYPER
  $BEGIN (<$TTL>,TYP,,<BITS,MANY,NOACS,LIT>)
  $SECTI $SEC				;; Section code >

;;		** Define the entry point(s) **

IFNB <$ENT>,<
  IRP $ENT,<
    ENTRY $ENT				;; Setup the symbol >>

>	; End of 'DEFINE $INIT'
	$TOC	TYPUNV -- Miscellaneous Symbols -- The ACs used


; Define the ACs used

	T1=TF%ACS			; Temporary ACs
	T2=T1+^O1			;  usually not
	T3=T2+^O1			;  saved across
	T4=T3+^O1			;  routines
	P1=T4+^O1			; Permanent ACs
	P2=P1+^O1			;  usually saved
	P3=P2+^O1			;  across
	P4=P3+^O1			;  routines
	TB=^O15				; TYPER database pointer
	FP=^O16				; Frame pointer
	P=^O17				; Push down list pointer
	$TOC	TYPUNV -- Miscellaneous Symbols -- The Flags Used


; The flags used in .TRUNN

	TF%BLK==B0			; Output leading blanks
	TF%DIG==B1			; A digit has been output


; The flag used in .TYPER

	TF%TAB==B0			; The previous character was a tab

	TF%VEX==B32			; The left justified %TBVER flag
	TF%HOX==B33			; The left justified %TBHOR flag
	TF%TIX==B34			; The left justified %TBTIM flag
	TF%CMX==B35			; The left justified %TBCMP flag

	TF%VER==B18			; Don't get the verbosity level
	TF%INF==B19			; An information message

; The flag used in TYPINI

	.TFTZO==^O25252			; The time zone offset
	$TOC	TYPUNV -- The End


	$PRGEND				; End of 'TYPUNV'	$TOC	.TBITS -- Initialization  15-May-83  /RWS


; Search some universal files

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TBITS

	$INIT	.TBITS - Output Bit Messages,.TBITS,\'TF%COD
	$TOC	.TBITS -- .TYPER Support Routines


; .TBITS - Output the messages corresponding to bits
; Call:	MOVX	T1,{the address of $BITS parameter block}
;	PUSHJ	P,.TBITS
;	 * Return *
; Uses:	T1-4

.TBITS::PUSHJ	P,.SAVE4##		; Save P1-4
	MOVE	P4,T1			; Save the pointer to the parameters
	PUSHJ	P,.TYLOD##		; Get the first parameter
	MOVE	T4,T1			;  (flags/messages)
	TXNN	T4,%BTMES!%ICIND!%ICIDX	; Skip if indirect message pointer
	JRST	TBITS1			; Skip some code
	PUSHJ	P,.LOCAT##		; Get the real pointer
	HRR	T4,T1			;  to the messages
TBITS1:	MOVEI	T1,BT.BIT(P4)		; Get the second
	PUSHJ	P,.TYLOD##		;  parameter (bits)
	TXNE	T4,%BTBIT		; Skip if not an indirect pointer
	PUSHJ	P,.TYLOD##		; Get the real bits
	MOVE	P1,T1			; Save the bits
	MOVEI	T1,BT.MSK(P4)		; Get the third
	PUSHJ	P,.TYLOD##		;  parameter (mask)
	TXNE	T4,%BTMSK		; Skip if not an indirect pointer
	PUSHJ	P,.TYLOD##		; Get the real mask
	MOVE	P2,T1			; Save the mask
	AND	P1,P2			; Clear any extraneous bits
	LDB	T1,[$POINT T4,BT%FNC]	; Get the function
	JRST	@BITTAB(T1)		; Go output the field message

BITTAB:	BITAND				; (0) Output 'and'
	BITCOM				; (1) Output 'comma'
	BITLIN				; (2) Output 'CR-LF'
	BITNON				; (3) Output nothing
	BITOR				; (4) Output 'or'
	BITPLS				; (5) Output '+'
	BITSPC				; (6) Output ' '
	BITUSR				; (7) Output user field
	BITXCL				; (10) Output '!'
	BITFLD				; (11) Output contents of a field
; BITxxx - Output some bit messages with separators
; Call:	MOVX	T4,{some flags,,pointer to messages}
;	MOVX	P1,{The bits to test}
;	MOVX	P2,{The mask to be tested against}
;	MOVX	P4,{the address of the $BITS parameter block}
;	PUSHJ	P,BITxxx
;	 * Return *
; Uses:	T1-4 and P1-4

BITAND:	SKIPA	P4,[[ASCIZ ~, ~],,[ASCIZ ~ and ~]]
BITCOM:	MOVE	P4,[[ASCIZ ~, ~],,[ASCIZ ~, ~]]
	JRST	BITTST			; Go do some useful output

BITLIN:	SKIPA	P4,[[BYTE (7).CHCRT,.CHLFD],,[BYTE (7).CHCRT,.CHLFD]]
BITNON:	MOVE	P4,[[BYTE (7).CHNUL],,[BYTE (7).CHNUL]]
	JRST	BITTST			; Go do some useful output

BITOR:	SKIPA	P4,[[ASCIZ ~, ~],,[ASCIZ ~ or ~]]
BITPLS:	MOVE	P4,[[ASCIZ ~+~],,[ASCIZ ~+~]]
	JRST	BITTST			; Go do some useful output

BITSPC:	SKIPA	P4,[[ASCIZ ~ ~],,[ASCIZ ~ ~]]
BITXCL:	MOVE	P4,[[ASCIZ ~!~],,[ASCIZ ~!~]]
	JRST	BITTST			; Go do some useful output

BITUSR:	MOVEI	T1,BT.XTR(P4)		; Get the fourth parameter,
	PUSHJ	P,.TYLOD##		;  user separators
	TXNE	T4,%BTXTR		; Skip if not an indirect pointer
	PUSHJ	P,.TYLOD##		; Get the real user separators
	MOVE	P4,T1			; Save the separators
	PFALL	BITTST			; Go do some useful output
; BITTST - Test some bits and output appropriate messages
; Call:	MOVX	T4,{some flags,,pointer to the messages}
;	MOVX	P1,{the bits to test}
;	MOVX	P2,{the mask to be tested against}
;	MOVX	P4,{the separator messages}
;	PUSHJ	P,BITTST
;	 * Return *
; Uses:	T1-4 and P1-4

BITTST:	$VARIA	(LOCAL,BITNUM)		; Allocate the
	SETZM	BITNUM			;  bit number
	CAXN	P1,^O0			; Skip if some bits set
	SOJA	T4,BITMSG		; Output the default message
	TXZ	T4,%BTFST		; Reset a counter
BITTS1:	JFFO	P2,BITTS2		; Get the first bit to test
	POPJ	P,			; Finished return
BITTS2:	ADDM	P3,BITNUM		; Update the bit counter
	LSHC	P1,(P3)			; Shift the bits and mask
	TXZ	P2,B0			; Skip if not in the mask
	TXZN	P1,B0			; Skip if in the bits
	AOJA	T4,BITTS1		; See if more to do
	TXON	T4,%BTFST		; Skip if not the first message
	JRST	BITTS3			; Go output the message
	CAXN	P1,^O0			; Skip if not the last message
	SKIPA	T1,P4			; Output the last separator
	HLRZ	T1,P4			; Output the first separator
	PUSHJ	P,.TSTRG##		; Output the separator
BITTS3:	TXNN	T4,%BTOCT		; Skip if the bit number is wanted
	SKIPN	(T4)			; Skip if real message to output
	JRST	[MOVX  T1,'1B    '	 ; Output
		 PUSHJ P,.TSIXN##	 ;  '1B'
		 MOVE  T1,BITNUM	 ;  and
		 PUSHJ P,.TDECW##	 ;  'n'
		 AOJA  T4,BITTS1]	 ; Increment the message pointer
	PUSHJ	P,BITMSG		; Output the message
	AOJA	T4,BITTS1		; Increment the message pointer
; BITFLD - Output a message according to a bit field
; Call:	MOVX	T4,{some flags,,pointer to messages}
;	MOVX	P1,{the field to test}
;	MOVX	P2,{the mask to be tested against}
;	MOVX	P4,{the address of the $BITS parameter block}
;	PUSHJ	P,BITFLD
;	 * Return *
; Uses:	T1-4 and P1-4

BITFLD:	MOVEI	T1,BT.XTR(P4)		; Get the fourth parameter,
	PUSHJ	P,.TYLOD##		;  the maximum
	TXNE	T4,%BTXTR		; Skip if not an indirect pointer
	PUSHJ	P,.TYLOD##		; Get the real maximum
	MOVN	P3,P2			; JLFO - Jump
	AND	P2,P3			;  on Last
	JFFO	P2,BITFL1		;  Found One
BITFL1:	LSH	P1,-^D35(P3)		; Right justify the field
	CAXL	P1,^D0			; Skip if less than zero
	CAILE	P1,(T1)			; Skip if less than the maximum
	SOJA	T4,BITFL2		; Go output the default message
	ADDI	T4,(P1)			; Get the address of the message
	SKIPE	(T4)			; Skip if no message to output
	JRST	BITMSG			; Go output the message
	SUBI	T4,^D1(P1)		; Point to the default message
BITFL2:	JUMPGE	T4,BITMSG		; Jump if the octal isn't wanted
	PUSHJ	P,BITMSG		; Output the message
	PUSHJ	P,.TSPAC##		; Output a space
	MOVE	T1,P1			; Get the field number
	PJRST	.TOCPW##		;  in parenthesis
; BITMSG - Output a message string in SIXBIT or ASCII
; Call:	MOVX	T4,{some flags,,pointer to current message}
;	PUSHJ	P,BITMSG
;	 * Return *
; Uses:	T1-3

BITMSG:	MOVE	T1,(T4)			; Get the pointer to the message
	TXNN	T4,%BTSIX		; Skip if SIXBIT
	PJRST	.TASCI##		; Output the ASCIZ message
	PJRST	.TSIXN##		; Output the SIXBIT message
	$TOC	.TBITS -- The End


	$PRGEND				; End of '.TBITS'	$TOC	.TBYTE -- Initialization  15-May-83  /RWS


; Search some universal files

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TBYTE

	$INIT	.TBYTE - Output Byte Strings,.TBYTE,\'TF%COD
	$TOC	.TBYTE -- The Type and Seperator Tables


; The function type dispatch table

BYTTAB:	BYTASC				; (0) ASCII
	BYTRDX				; (1) Radix
	BYTSIX				; (2) SIXBIT


; The byte seperator strings

BYTSEP:	0				; (0) Nothing wanted
	[ASCIZ ~, ~]			; (1) Comma and space
	[BYTE (7) .CHCRT,.CHLFD,.CHNUL]	; (2) Carriage-return line-feed
	[ASCIZ ~ ~]			; (3) Space
	$TOC	.TBYTE -- Output a String of Bytes


; .TBYTE - Output a string of bytes in several modes
; Call:	MOVX	T1,{the address of the $BYTE argument block}
;	PUSHJ	P,.TBYTE
;	 * Return *
; Uses:	T1-4

.TBYTE:	PUSHJ	P,.SAVE4##		; Save P1-4

	PUSHJ	P,.LOCAT##		; Find a safer place
	MOVE	P1,T1			;  for the pointer
	MOVE	P2,BY.FLG(P1)		; Get the flags
	$MOVE	T1,BY.PTR,(P1)		; Get the
	TXNE	P2,%BYPTR		;  pointer 
	PUSHJ	P,.TYLOD##		;  to the
	PUSHJ	P,.TPNTR##		;  byte
	MOVE	P3,T1			;  string
	$MOVE	T1,BY.CNT,(P1)		; Get the
	TXNE	P2,%BYCNT		;  number of
	PUSHJ	P,.TYLOD##		;  bytes to
	MOVE	P4,T1			;  output
	$MOVE	T1,BY.TRM,(P1)		; Get the
	TXNE	P2,%BYTRM		;  byte to
	PUSHJ	P,.TYLOD##		;  terminate
	MOVE	T4,T1			;  the output

	TXZ	P2,BY%FST		; Clear the first byte output

	$MOVE	T1,BY.TYP,P2		; Get the type
	PUSHJ	P,@BYTTAB(T1)		; Go output the byte string
	POPJ	P,			; Return
; BYTASC - Output the ASCII byte string
; Call:	MOVX	P2,{the flags}
;	MOVX	P3,{the pointer to the byte string}
;	MOVX	P4,{the count of the number of characters}
;	MOVX	T4,{the terminating byte}
;	PUSHJ	P,BYTASC
;	 * Return *

BYTASC:	SKIPLE	T3,P4			; A non-zero count supplied?
	MOVX	T3,^O1			; No, get a positive one
	CAXGE	P4,^O0			; A non-negative count supplied?
	MOVX	T3,-^O1			; No, get a negative one

BYTAS1:	ILDB	T2,P3			; Get a character
	JUMPL	T3,BYTAS2		; A negative count supplied?
	CAMN	T2,T4			; No, the terminating byte?
	POPJ	P,			; Yes, return
BYTAS2:	TXON	P2,BY%FST		; The first character output?
	JRST	BYTAS3			; Yes, don't output a seperator
	$MOVE	T1,BY.SEP,P2		; No, is seperating
	SKIPE	T1,BYTSEP(T1)		;  string wanted?
	PUSHJ	P,.TSTRG##		; Yes, output it
BYTAS3:	MOVE	T1,T2			; Output the
	PUSHJ	P,.TCHAR##		;  character
	XCT	[AOJL P4,BYTAS1		 ; Negative count
		 JRST BYTAS1		 ; No count
		 SOJG P4,BYTAS1]+^O1(T3) ; Positive count
	POPJ	P,			; Return	
; BYTSIX - Output the SIXBIT byte string
; Call:	MOVX	P2,{the flags}
;	MOVX	P3,{the pointer to the byte string}
;	MOVX	P4,{the count of the number of characters}
;	MOVX	T4,{the terminating byte}
;	PUSHJ	P,BYTSIX
;	 * Return *

BYTSIX:	SKIPLE	T3,P4			; A non-zero count supplied?
	MOVX	T3,^O1			; No, get a positive one
	CAXGE	P4,^O0			; A non-negative count supplied?
	MOVX	T3,-^O1			; No, get a negative one

BYTSI1:	ILDB	T2,P3			; Get a character
	JUMPL	T3,BYTSI2		; A negative count supplied?
	CAMN	T2,T4			; No, the terminating byte?
	POPJ	P,			; Yes, return
BYTSI2:	TXON	P2,BY%FST		; The first character output?
	JRST	BYTSI3			; Yes, don't output a seperator
	$MOVE	T1,BY.SEP,P2		; No, is seperating
	SKIPE	T1,BYTSEP(T1)		;  string wanted?
	PUSHJ	P,.TSTRG##		; Yes, output it
BYTSI3:	MOVEI	T1," "(T2)		; Output the
	PUSHJ	P,.TCHAR##		;  character
	XCT	[AOJL P4,BYTSI1		 ; Negative count
		 JRST BYTSI1		 ; No count
		 SOJG P4,BYTSI1]+^O1(T3) ; Positive count
	POPJ	P,			; Return	
; BYTRDX - Output the numeric byte string
; Call:	MOVX	P2,{the flags}
;	MOVX	P3,{the pointer to the byte string}
;	MOVX	P4,{the count of the number of characters}
;	MOVX	T4,{the terminating byte}
;	PUSHJ	P,BYTRDX
;	 * Return *

BYTRDX:	PUSHJ	P,.SAVE1##		; Save P1
	$MOVE	T3,BY.RDX,P2		; Get the radix

	SKIPLE	P1,P4			; A non-zero count supplied?
	MOVX	P1,^O1			; No, get a positive one
	CAXGE	P4,^O0			; A non-negative count supplied?
	MOVX	P1,-^O1			; No, get a negative one

BYTRD1:	ILDB	T2,P3			; Get a character
	JUMPL	P1,BYTRD2		; A negative count supplied?
	CAMN	T2,T4			; No, the terminating byte?
	POPJ	P,			; Yes, return
BYTRD2:	TXON	P2,BY%FST		; The first digit output?
	JRST	BYTRD3			; Yes, don't output a seperator
	$MOVE	T1,BY.SEP,P2		; No, is seperating
	SKIPE	T1,BYTSEP(T1)		;  string wanted?
	PUSHJ	P,.TSTRG##		; Yes, output it
BYTRD3:	PUSHJ	P,BYTR10		; Output the number
	XCT	[AOJL P4,BYTRD1		 ; Negative count
		 JRST BYTRD1		 ; No count
		 SOJG P4,BYTRD1]+^O1(P1) ; Positive count
	POPJ	P,			; Return

; Here to output the byte in the specified radix

BYTR10:	TXZN	T2,IN%SGN		; Is the number negative?
	TXZA	T1,T1			; No, the hi-order word is zero
	MOVX	T1,^O1			; The hi-order word is one
	DIV	T1,T3			; Get a digit
	JRST	BYTR12			;  to output
BYTR11:	IDIV	T1,T3			; Get a digit to output
BYTR12:	HRLM	T2,(P)			; Save the remainder
	CAXE	T1,^D0			; Finished yet?
	PUSHJ	P,BYTR11		; No, get another digit
	HLRZ	T1,(P)			; Restore a digit
	ADDX	T1,"0"			; Convert to ASCII
	CAXLE	T1,"9"			; A hexadecimal digit?
	ADDX	T1,"A"-"9"-^O1		; Yes, convert to an alpha
	PJRST	.TCHAR##		; Output the character
	$TOC	.TBYTE -- The End


	$PRGEND				; End of '.TBYTE'	$TOC	.TENGL -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TENGL

	$INIT	.TENGL - Output Cardinal and Ordinal Numbers,.TENGL,\'TF%COD
	$TOC	.TENGL -- The Numeric Text Strings


UNTTAB:	[ASCIZ ~zero~],,[ASCIZ ~zeroth~]		; 0
	[ASCIZ ~one~],,[ASCIZ ~first~]			; 1
	[ASCIZ ~two~],,[ASCIZ ~second~]			; 2
	[ASCIZ ~three~],,[ASCIZ ~third~]		; 3
	[ASCIZ ~four~],,[ASCIZ ~fourth~]		; 4
	[ASCIZ ~five~],,[ASCIZ ~fifth~]			; 5
	[ASCIZ ~six~],,[ASCIZ ~sixth~]			; 6
	[ASCIZ ~seven~],,[ASCIZ ~seventh~]		; 7
	[ASCIZ ~eight~],,[ASCIZ ~eighth~]		; 8
	[ASCIZ ~nine~],,[ASCIZ ~ninth~]			; 9
	[ASCIZ ~ten~],,[ASCIZ ~tenth~]			; 10
	[ASCIZ ~eleven~],,[ASCIZ ~eleventh~]		; 11
	[ASCIZ ~twelve~],,[ASCIZ ~twelfth~]		; 12
	[ASCIZ ~thirteen~],,[ASCIZ ~thirteenth~]	; 13
	[ASCIZ ~fourteen~],,[ASCIZ ~fourteenth~]	; 14
	[ASCIZ ~fifteen~],,[ASCIZ ~fifteenth~]		; 15
	[ASCIZ ~sixteen~],,[ASCIZ ~sixteenth~]		; 16
	[ASCIZ ~seventeen~],,[ASCIZ ~seventeenth~]	; 17
	[ASCIZ ~eighteen~],,[ASCIZ ~eighteenth~]	; 18
	[ASCIZ ~nineteen~],,[ASCIZ ~nineteenth~]	; 19

DECTAB:	[ASCIZ ~twenty~],,[ASCIZ ~twentieth~]		; 2E+01
	[ASCIZ ~thirty~],,[ASCIZ ~thirtieth~]		; 3E+01
	[ASCIZ ~forty~],,[ASCIZ ~fortieth~]		; 4E+01
	[ASCIZ ~fifty~],,[ASCIZ ~fiftieth~]		; 5E+01
	[ASCIZ ~sixty~],,[ASCIZ ~sixtieth~]		; 6E+01
	[ASCIZ ~seventy~],,[ASCIZ ~seventieth~]		; 7E+01
	[ASCIZ ~eighty~],,[ASCIZ ~eightieth~]		; 8E+01
	[ASCIZ ~ninety~],,[ASCIZ ~ninetieth~]		; 9E+01

HUNTAB:	[ASCIZ ~hundred~],,[ASCIZ ~hundredth~]		; 1E+02

MAGTAB:	[ASCIZ ~thousand~],,[ASCIZ ~thousandth~]	; 1E+03
	[ASCIZ ~million~],,[ASCIZ ~millionth~]		; 1E+06
	[ASCIZ ~billion~],,[ASCIZ ~billionth~]		; 1E+09
	[ASCIZ ~trillion~],,[ASCIZ ~trillionth~]	; 1E+12
	[ASCIZ ~quadrillion~],,[ASCIZ ~quadrillionth~]	; 1E+15
	[ASCIZ ~quintillion~],,[ASCIZ ~quintillionth~]	; 1E+18
	[ASCIZ ~sextillion~],,[ASCIZ ~sextillionth~]	; 1E+21
	$TOC	.TENGL -- Type a Number in English


; .TENGL - Output a number in English format
; Call:	DMOVX	T1,{the integer number to output}
;	MOVX	P1,{the first word of the $NUMBER parameter block}
;	PUSHJ	P,.TENGL
;	 * Return *
; Uses:	T1-4, P1-2

.TENGL::SKIPN	T2			; Skip if non-zero (low order)
	JUMPE	T1,[MOVE  P2,UNTTAB	 ; Set up to output
		    PJRST TENG10]	 ;  'zero' and return
	SETZB	P2,P3			; Clear the magnitude and text variables
	JUMPGE	T1,TENGL1		; Jump if positive
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	DMOVN	T1,T1			; Negate the number >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	SETCM	T1,T1			; Complement the high order
	MOVNS	T2			; Negate the low order
	TXZ	T2,IN%SGN		; Clear the sign bit (low order)
	SKIPN	T2			; Skip if the low order half isn't zero
	ADDX	T1,^D1			; Bump the high order half by one >
	TXO	P1,%NMNEG		; Set the negative flag

TENGL1:	MOVE	T3,T2			; Move the low order half a bit
	IDIVX	T1,^D1000		; Divide the high order part by 1000
	DIVX	T2,^D1000		; Finish off the divide (Rem. in T3)
	HRLM	T3,(P)			; Save for later
	SKIPN	T2			; Skip if something left (low order)
	JUMPE	T1,[TXNN  P1,%NMNEG	 ; Skip if a number was negative
		    JRST  TENGL2	 ; Go output the first word
		    MOVSI T1,[ASCIZ ~minus~]
		    PUSHJ P,TENG10	 ; Output the word 'minus'
		    JRST  TENGL2]	 ; Go output the first word
	ADDX	P3,^D1			; Increment the magnitude flag
	PUSHJ	P,TENGL1		; Get the next 3 digits
TENGL2:	HLRZ	T1,(P)			; Get 3 digits
	JUMPE	T1,TENGL5		; Jump if nothing to output
	IDIVX	T1,^D100		; Get the hundreds digit
	JUMPE	T1,TENGL3		; Jump if zero
	MOVE	T1,UNTTAB(T1)		; Get the units text string
	PUSHJ	P,TENG10		; Output the text string
	MOVE	T1,HUNTAB		; Get the 'hundred' pointer
	PUSHJ	P,TENG10		; Output the text string
TENGL3:	CAXG	T2,^D19			; Skip if greater than 19
	JRST	[JUMPE T2,TENGL4	 ; Jump if zero
		 MOVE  T1,UNTTAB(T2)	 ; Get the units text string
		 PUSHJ P,TENG10		 ; Output the text string
		 JRST  TENGL4]		 ; Go see if a magnitude is needed
	IDIVX	T2,^D10			; Get the tens digit
	MOVE	T1,DECTAB-2(T2)		; Get the tens text string pointer
	PUSHJ	P,TENG10		; Output the text string
	JUMPE	T3,TENGL4		; Jump if no units
	MOVE	T1,UNTTAB(T3)		; Get the units text string
	PUSHJ	P,TENG10		; Output the text string
	TXO	P1,%NMDSH		; Set the dash flag
TENGL4:	SOJL	P3,TENGL6		; Jump if no magnitude is needed
	MOVE	T1,MAGTAB(P3)		; Get the magnitude text string
	PUSHJ	P,TENG10		; Output the text string
	TXO	P1,%NMCOM		; Set the comma flag
	POPJ	P,			; Return
TENGL5:	SOJGE	P3,.POPJ##		; Return if magnitude isn't zero
TENGL6:	SETZ	T1,			; Set the flag to dump the last word
	PFALL	TENG10			; Output the last text string
; TENG10 - Output an ASCIZ string
; Call:	MOVX	T1,{the pointer to the current ASCIZ string}
;	MOVX	P1,{some flags}
;	MOVX	P2,{the pointer to the last ASCIZ string}
;	PUSHJ	P,TENG10
;	 * Return *
; Uses:	T1 and P1

TENG10:	EXCH	T1,P2			; Save the string pointer for later
	JUMPE	T1,.POPJ##		; Jump if the first time
	PUSH	P,T2			; Save some
	PUSH	P,T3			;  registers
	TXZE	P1,%NMFST		; Skip not the first time
	JRST	TENG11			; Go output the text string
	PUSH	P,T1			; Save the text string pointer
	MOVX	T1," "			; Assume a space is wanted
	TXZE	P1,%NMDSH		; Skip if a space will do
	MOVX	T1,"-"			; Get a dash
	PUSHJ	P,.TCHAR##		; Output the character
	POP	P,T1			; Restore the text string pointer
TENG11:	SKIPN	P2			; Skip if the last word
	TXNE	P1,%NMCRD		; Skip if an ordinal number is wanted
	MOVSS	T1			; Get the correct text pointer (cardinal)
	HRLI	T1,(POINT 7)		; Convert to an ASCII pointer
	TXOE	P1,%NMLOW		; Skip if the upper case is wanted
	JRST	TENG12			; Go dump the text string then
	MOVE	T2,T1			; Save the pointer
	ILDB	T1,T2			; Get the first character
	ADDX	T1,"A"-"a"		; Convert to upper case
	PUSHJ	P,.TCHAR##		; Output the character
	MOVE	T1,T2			; Get the pointer back in the correct place
TENG12:	PUSHJ	P,.TASCI##		; Output the text string
	JUMPE	P2,TENG13		; Jump if the last word
	TXZE	P1,%NMCOM		; Skip if a comma isn't wanted
	PUSHJ	P,.TCOMA##		; Output a comma
TENG13:	POP	P,T3			; Restore some
	POP	P,T2			;  registers
	POPJ	P,			; Return
	$TOC	.TENGL -- The End


	$PRGEND				; End of '.TENGL'	$TOC	.TFLOT -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TFLOT

	$INIT	.TFLOT - Output Flouting-Point Numbers,<.TFLOT,.TENS>,\'TF%COD


; Define some conditional value

	IFNDEF	FO$MAX,<FO$MAX==^D8>	; The default maximum number of
					;  digits to calculate
	IFNDEF	FO$TOT,<FO$TOT==^D125>	; The default maximum number of
					;  total characters allowed
	IFNDEF	FO$FRC,<FO$FRC==^D56>	; The default maximum number of
					;  fractional digits to print
	IFNDEF	FO$FTF,<FO$FTF==^D127>	; The default total free field flag
	IFNDEF	FO$FFF,<FO$FFF==^D63>	; The default total free field flag


; Define some flags used in P1

	%NMSML==B0			; The number is small (less than 1)
	%NMFLD==B1			; Total field width is free format
	%NMFRC==B2			; Fractional field width is free format
	$TOC	.TFLOT -- Powers of Ten Table


; Table of the powers of ten

	^O175631463146			; (-1) 1.0E-01
.TENS::	^O201400000000			; (0)  1.0E+00
	^O204500000000			; (1)  1.0E+01
	^O207620000000			; (2)  1.0E+02
	^O212764000000			; (3)  1.0E+03
	^O216470400000			; (4)  1.0E+04
	^O221606500000			; (5)  1.0E+05
	^O224750220000			; (6)  1.0E+06
	^O230461132000			; (7)  1.0E+07
	^O233575360400			; (10) 1.0E+08
	^O236734654500			; (11) 1.0E+09
	^O242452013710			; (12) 1.0E+10
	^O245564416672			; (13) 1.0E+11
	^O250721522451			; (14) 1.0E+12
	^O254443023471			; (15) 1.0E+13
	^O257553630410			; (16) 1.0E+14
	^O262706576512			; (17) 1.0E+15
	^O266434157116			; (20) 1.0E+16
	^O271543212741			; (21) 1.0E+17
	^O274674055532			; (22) 1.0E+18
	^O300425434430			; (23) 1.0E+19
	^O303532743536			; (24) 1.0E+20
	^O306661534466			; (25) 1.0E+21
	^O312417031702			; (26) 1.0E+22
	^O315522640262			; (27) 1.0E+23
	^O320647410336			; (30) 1.0E+24
	^O324410545213			; (31) 1.0E+25
	^O327512676456			; (32) 1.0E+26
	^O332635456171			; (33) 1.0E+27
	^O336402374714			; (34) 1.0E+28
	^O341503074077			; (35) 1.0E+29
	^O344623713116			; (36) 1.0E+30
	^O347770675742			; (37) 1.0E+31
	^O353473426555			; (40) 1.0E+32
	^O356612334311			; (41) 1.0E+33
	^O361755023373			; (42) 1.0E+34
	^O365464114135			; (43) 1.0E+35
	^O370601137164			; (44) 1.0E+36
	^O373741367021			; (45) 1.0E+37
	^O377454732313			; (46) 1.0E+38
	$TOC	.TFLOT -- Output a Single Precision Floating-Point Number


; .TFLOT - Output a single precision floating-point number
; Call:	DMOVX	T1,{the floating-point number to output}
;	MOVX	P1,{some flags}
;	PUSHJ	P,.TFLOT
;	 * Return *
; Uses:	T1-4 and P1-4

.TFLOT::$VARIA	(GLOBAL,<<TYPDIG,^D8>>)	; Get some stack variables

	TXZ	P1,%NMNEG!%NMSML!%NMFLD!%NMFRC  ; Clear some internal flags

	MOVEI	T4,TYPDIG-^O1		; Setup to store the digits
	MOVX	P4,^D1			; Assume an exponent of 1

	JUMPGE	T1,TFLO01		; Jump if the number is positive
	MOVNS	T1			; Get the magnitude
	TXO	P1,%NMNEG		; Note that the number was negative

TFLO01:	LDB	P2,[$POINT P1,NM%WID]	; Get the total field width
	CAXN	P2,FO$FTF		; Skip if not a free total field
	SETO	P2,			; Let everyone know
	LDB	P3,[$POINT P1,NM%FRC]	; Get the fractional field width
	CAXN	P3,FO$FFF		; Skip if not a free factional field
	SETO	P3,			; Let everyone know

	JUMPE	T1,TFLO06		; Jump if zero, you can't put it into range
	CAMGE	T1,.TENS+^D0		; Skip if greater than 1.0
	JRST	[TXO   P1,%NMSML	 ; Note that the number is small
		 CAML  T1,.TENS-^D1	 ; Skip if less than 0.1
		 SOJA  P4,TFLO06	 ; The number is in range
		 CAXGE T1,^O002663437347 ; Skip if greater than 1.0E-38
		 JRST  TFLO04		 ; Save a few overflows
		 MOVX  T2,<DEC 1.0>	 ; Get the
		 FDVR  T2,T1		 ;  reciprocal
		 JRST  TFLO02]		 ; Go put the number into range
	MOVE	T2,T1			; Get a spare copy of the number
TFLO02:	MOVSI	P4,-^D38		; Set up the counter
	CAMGE	T2,.TENS+^D6		; Skip greater than 1.0E+6
	JRST	TFLO03			; Go use 10 for the first guess
	CAXGE	P2,^D0			; Skip if not free total field
	TXO	P1,NM%NOT		; Set the scientific flag
	LDB	T3,[$POINT T2,FN%EXP]	; Get the exponent
	SUBX	T3,<^O200-^O2>		; Get rid of the excess 200 (-2 kludge)
	IMULX	T3,^O232		; Multiply by the LOG10(2)
	LSH	T3,-^D9			; Get rid of the fractional digits
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	ADJSP	P4,-^D1(T3)		; Adjust for the first guess >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	ADDX	T3,-^D1			; Adjust for
	HRLS	T3			;  the first
	ADD	P4,T3			;  guess >

TFLO03:	CAML	T2,.TENS+^D1(P4)	; Skip if less than some power of ten
	AOBJN	P4,TFLO03		; Loop until a large enough entry is found
	JUMPGE	P4,[FDVR T1,.TENS+^D38	 ; The entry was very large
		    FDVR T1,.TENS+^D1	 ;  (divide by 1.0E+39)
		    AOJA P4,TFLO06]	 ; Adjust the exponent

	ANDX	P4,WD%RIT		; Clear out the trash in the left half
	TXNE	P1,%NMSML		; Skip if not a small number
	JRST	TFLO05			; Go get the reciprocal
	FDVR	T1,.TENS+^D1(P4)	; Get the number into range
	AOJA	P4,TFLO06		; Adjust the exponent

TFLO04:	CAXGE	P2,^D0			; Skip if not free total field
	TXO	P1,NM%NOT		; Set the scientific flag
	MOVX	P4,^D38			; Deal with overflow in reciprocal
TFLO05:	FMPR	T1,.TENS+^D0(P4)	; Get the number into range
	MOVNS	P4			; Get the correct sign on the exponent
TFLO06:	JUMPL	P2,[TXO  P1,%NMFLD	 ; Set the free field flag
		    TXZ  P1,%NMOVL	 ; Clear the overflow flag
		    JRST TFLO08]	 ; Skip some code
	CAXLE	P2,FO$TOT		; Skip if less than the maximum total width
	MOVX	P2,FO$TOT		; Get the maximum total width
	TXNE	P1,NM%NOT		; Skip if scientific notation isn't wanted
	JRST	[SUBX P2,^D4		 ; Account for the exponent (four characters)
		 JRST TFLO07]		 ; Skip the comma kludge
	TXNN	P1,%NMCOM		; Skip if commas are wanted
	JRST	TFLO07			; Go do some bigger and better things
	JUMPLE	P4,TFLO07		; Jump if only a fraction
	HRREI	T2,-^D1(P4)		; Get the number of leading digits
	IDIVX	T2,^D3			; Get the number commas needed
	SUB	P2,T2			; Account for the commas
TFLO07:	TXNE	P1,%NMSGN!%NMNEG	; Skip if a sign isn't needed
	SUBX	P2,^D1			; Account for sign (one character)
	TXNE	P1,%NMDLR		; Skip if floating dollar isn't wanted
	SUBX	P2,^D1			; Account for the dollar sign (one character)
	TXNN	P1,NM%NOT		; Skip if scientific notation is wanted
	TXNE	P1,%NMSML		; Skip if a small number
	SOSA	P2			; Account for the leading digit
	SUB	P2,P4			; Account for the leading digits
	SUBX	P2,^D1			; Account for the decimal point (one character)

TFLO08:	JUMPGE	P3,TFLO10		; Jump if the fraction isn't free
	TXO	P1,%NMFRC		; Set the free fraction flag
	MOVX	P3,FO$MAX		; Get the maximum number of digits possible
	TXNE	P1,NM%NOT		; Skip if scientific notation isn't wanted
	SOSA	P3			; Decrement the number of fractional digits
	SUB	P3,P4			; Decrement by the number of integer digits
	JUMPLE	P3,TFLO09		; Jump if no fraction digits wanted
	TXNN	P1,%NMFLD		; Skip if free field
	CAMG	P3,P2			; Skip if more fraction digits than field space
	JRST	TFLO10			; Go see if decimal point is wanted
	SKIPGE	P3,P2			; Skip if an field space left
TFLO09:	SETZ	P3,			; None - givem zero digits
TFLO10:	CAXLE	P3,FO$FRC		; Skip if less than maximum fractional width
	MOVX	P3,FO$FRC		; Get the maximum fractional width allowed
	JUMPN	P3,TFLO11		; Jump if some fraction digits wanted
	TXNE	P1,%NMNDP		; Skip decimal point is wanted
	AOSA	P2			; Give a character back to fill
TFLO11:	TXZ	P1,%NMNDP		; A decimal point is wanted
	SUB	P2,P3			; Adjust the fill field width
	JUMPE	T1,TFLO14		; Jump if no need to round
	MOVE	T3,P3			; Get the number of fractional digits wanted
	TXNE	P1,NM%NOT		; Skip if normal notation is wanted
	AOSA	T3			; Account for the leading digit
	ADD	T3,P4			; Account for the actual size
	CAXLE	T3,FO$MAX		; Skip if less than the maximum
	MOVX	T3,FO$MAX		; Assume the maximum
	JUMPL	T3,TFLO14		; Jump if nothing left to round
	MOVX	T2,<DEC 5.0>		; Round
	FDVR	T2,.TENS+^D1(T3)	;  the
	FADR	T1,T2			;  number

	LDB	T2,[$POINT T1,FN%EXP]	; Get the exponent
	TXZ	T1,FN%EXP		; Clear the exponent
	LSH	T1,-^O170(T2)		; Convert to fractional form
	JUMPGE	T1,TFLO13		; Jump if NO overflow

	MOVX	T1,^O031463146315	; Correct if overflowed
	TXNE	P1,NM%NOT		; Skip if not scientific notation
	AOJA	P4,TFLO13		; Increase the exponent
	ADDX	P4,^D1			; Increase the exponent
	TXNN	P1,%NMCOM		; Skip commas are wanted
	JRST	TFLO12			; Don't worry about the size changing then
	MOVX	T2,^O1			; Shift a bit by the position
	LSH	T2,-^D4(P4)		;  of the old exponent
	TDNE	T2,[^O111111111111]	; Skip if no new commas
	SUBX	P2,^D1			; Account for the new comma
TFLO12:	TXNE	P1,%NMFRC		; Skip not free fractional size
	JRST	[TXNE P1,%NMSML		 ; Skip if a small number
		 ADDX P2,^D1		 ; Increment the free field by one
		 SOJA P3,TFLO13]	 ; Decrement the fractional field by one
	TXNN	P1,%NMSML		; Skip if a small number
	SUBX	P2,^D1			; Decrement the free field by one

TFLO13:	MULX	T1,^D10			; Multiply by 10
	ADDX	T1,"0"			; Convert to ASCII
	PUSH	T4,T1			; Save for later
	MOVE	T1,T2			; Get ready for the next digit
	SOJG	T3,TFLO13		; Loop until finished
TFLO14:	TXNE	P1,%NMOVL		; Skip if no overflow test
	JUMPL	P2,[LDB   P2,[$POINT P1,NM%WID]  ; Get the total field size
		    MOVX  T2,"*"	 ; Output the overflow
		    PJRST FLTFIL]	 ;  character

	LDB	T2,[$POINT P1,NM%FIL]	; Get the fill character
	CAXE	T2,"0"			; Skip if zero fill
	PUSHJ	P,FLTFIL		; Output the leading fill
	TXNN	P1,%NMTRL		; Skip if trailing sign wanted
	PUSHJ	P,FLTSGN		; Output the sign
	TXNE	P1,%NMDLR		; Skip if floating dollar sign isn't wanted
	PUSHJ	P,FLTDLR		; Output a dollar sign
	CAXN	T2,"0"			; Skip if not zero fill
	PUSHJ	P,FLTFIL		; Output the leading fill

	MOVN	T3,P4			; Get the exponent of the number
	TXNN	P1,NM%NOT		; Skip if scientific notation is wanted
	AOSA	T3			; Increment the number of leading zeros
	TDZA	T3,T3			; No leading zeros
	SKIPG	T2,P4			; Get the number of integer
	MOVX	T2,^D1			;  digits to output
	TLC	T4,-1			; Setup a counter for the
	HRRI	T4,TYPDIG-^O1		;  number of digits output

TFLO16:	PUSHJ	P,FLTDIG		; Output a digit
	TXNN	P1,%NMCOM		; Skip if commas are wanted
	JRST	TFLO17			; Go see if any for digits
	MOVX	T1,^O1			; Shift a bit by the position
	LSH	T1,-^D4(T2)		;  of the last digit printed
	TDNE	T1,[^O111111111111]	; Skip if not comma needed yet
	PUSHJ	P,.TCOMA##		; Output a comma
TFLO17:	SOJG	T2,TFLO16		; Loop until finished

	TXNE	P1,%NMNDP		; Skip if the decimal point is wanted
	JRST	TFLO19			; The decimal point and fraction aren't wanted

	PUSHJ	P,.TDOT##		; Output a decimal point
	JUMPLE	P3,TFLO19		; Return if none are wanted
TFLO18:	PUSHJ	P,FLTDIG		; Output a digit
	SOJG	P3,TFLO18		; Loop until finished
TFLO19:	TXNN	P1,NM%NOT		; Skip if scientific notation is wanted
	JRST	FLOU20			; Go reset the stack and return
	MOVX	T1,"E"			; Output an E for
	PUSHJ	P,.TCHAR##		;  scientific notation
	SOSL	P4			; Output the
	SKIPA	T1,["+"]		;  sign of
	MOVX	T1,"-"			;  the
	PUSHJ	P,.TCHAR##		;  exponent
	MOVM	T1,P4			; Output the exponent
	IDIVX	T1,^D10			;  ..
	ADDX	T1,"0"			;  ..
	PUSHJ	P,.TCHAR##		;  ..
	MOVEI	T1,"0"(T2)		;  ..
	PUSHJ	P,.TCHAR##		;  ..

FLOU20:	TXNE	P1,%NMTRL		; Skip if leading sign wanted
	PJRST	FLTSGN			; Output the sign
	POPJ	P,			; Return
	$TOC	.TFLOT -- The Flout Support Routines


; FLTDLR - Here to output a dollar sign
; Call:	PUSHJ	P,FLTDLR		; Output a dollar sign
;	 * Return *
; Uses:	T1

FLTDLR:	MOVX	T1,"$"			; Output the floating
	PJRST	.TCHAR##		;  dollar sign


; FLTSGN - Here to output the sign (if needed)
; Call:	PUSHJ	P,FLTSGN		; Output the sign
;					;  '-' if %NMNEG is on
;					;  '+' if %NMSGN is on
;	 * Return *
; Uses:	T1

FLTSGN:	TXNN	P1,%NMSGN!%NMNEG	; Skip if the sign is wanted
	POPJ	P,			; Return (no sign wanted/needed)
	TXNN	P1,%NMNEG		; Skip if negative
	SKIPA	T1,["+"]		; Get the plus sign
	MOVX	T1,"-"			; Get the minus sign
	PJRST	.TCHAR##		; Output the sign and return


; FLTFIL - Here to output the fill character(s)
; Call:	MOVX	T2,{the fill character to output}
;	MOVX	P2,{the number of fill character needed}
;	PUSHJ	P,FLTFIL		; Output the fill (%NMFIL contains the fill code)
;	 * Return *
; Uses:	T1 and P2

FLTFIL:	JUMPLE	P2,.POPJ##		; Return if nothing to output
	MOVE	T1,T2			; Get the fill character
FLTFI1:	PUSHJ	P,.TCHAR##		; Output the fill character
	SOJG	P2,FLTFI1		; Jump if not yet finished
	POPJ	P,			; Return


; FLTDIG - Here to get the next digit to output
; Call:	MOVX	T3,{the number of leading zero}
;	MOVX	T4,{an AOBJP pointer the digits on the stack}
;	PUSHJ	P,FLTDIG		; Output a digit
;	 * Return *
; Uses:	T1, T3 and T4

FLTDIG:	SOJGE	T3,FLTDI1		; Jump if a leading zero should be output
	AOBJP	T4,FLTDI1		; Jump if a trailing zero should be output
	SKIPA	T1,(T4)			; Get a digit
FLTDI1:	MOVX	T1,"0"			; Get a zero
	PJRST	.TCHAR##		; Output the digit
	$TOC	.TFLOT -- The End


	$PRGEND				; End of '.TFLOT'	$TOC	.TINTG -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TINTG

	$INIT	.TINTG - Output Integer Numbers,.TINTG,\'TF%COD
	$TOC	.TINTG -- The Integer Output Routine


; .TINTG - Output a double precision integer number
; Call:	DMOVX	T1,{the double precision integer number to output}
;	MOVX	P1,{the first word of the $NUMBER parameter block}
;	PUSHJ	P,.TINTG
;	 * Return *
; Uses:	T1-4 and P1-4

.TINTG::LDB	P2,[$POINT P1,NM%WID]	; Get the width
	LDB	P3,[$POINT P1,NM%RDX]	; Get the desired radix
	TXNE	P1,NM%NOT		; Skip if signed number
	JRST	TINTG7			; Output an unsigned number

; Here to output a signed single/double precision integer number

	JUMPGE	T1,TINTG1		; Jump if positive
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	DMOVN	T1,T1			; Negate the number >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	SETCM	T1,T1			; Complement the high order
	MOVNS	T2			; Negate the low order
	TXZ	T2,IN%SGN		; Clear the sign bit (low order)
	SKIPN	T2			; Skip if the low order half isn't zero
	ADDX	T1,^D1			; Bump the high order half by one >
	SUBX	P2,^D1			; Decrement the fill count
	TXO	P1,%NMNEG		; Set the negative flag

TINTG1:	MOVE	T3,T2			; Move the low order half a bit
	IDIVI	T1,(P3)			; Divide the high order part by the radix
	DIVI	T2,(P3)			; Finish off the divide (rem. in T3)
	HRLM	T3,(P)			; Save for later
	SUBX	P2,^D1			; Decrement the fill count
TINTG2:	SKIPN	T2			; Skip if something left (low order)
	JUMPE	T1,TINTG4		; Jump if nothing left
	PUSHJ	P,TINTG1		; Get the next 3 digits
	PFALL	TINTG3			; Fall into the output code
TINTG3:	HLRZ	T1,(P)			; Get back a digit
	ADDX	T1,"0"			; Convert to ASCII
	CAXLE	T1,"9"			; Skip if a digit
	ADDX	T1,"A"-"9"-^O1		; Swith to alphabetics
	PJRST	.TCHAR##		; Type it and return

TINTG4:	LDB	T1,[$POINT P1,NM%FIL]	; Get the fill character
	CAXE	T1,"0"			; Skip if the fill character is a zero
	PUSHJ	P,TINTG6		; Dump the fill character
	TXNN	P1,%NMNEG		; Skip if negative
	JRST	TINTG5			; No sign
	MOVX	T1,"-"			; Get minus sign
	PUSHJ	P,.TCHAR##		;  minus sign
	LDB	T1,[$POINT P1,NM%FIL]	; Get the fill character
TINTG5:	CAXN	T1,"0"			; Skip if the fill character isn't a zero
	PUSHJ	P,TINTG6		; Dump the fill character
	JRST	TINTG3			; Output the digits

TINTG6:	SOJL	P2,.POPJ##		; Return if done
	PUSHJ	P,.TCHAR##		; Output a fill character
	JRST	TINTG6			; See if more to output
; Here to output an unsigned single/double precision integer

TINTG7:	MOVE	T3,T2			; Move the number
	LSHC	T1,-^D34		; Rearrange the data
	LSH	T2,-^D1			;  so we can output
	TXZA	T3,IN%SGN		;  all 72 bits

TINTG8:	PUSH	P,[TINTG3]		; Put a fake PUSHJ onto the stack
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	DMOVE	T3,T2			; Move the low order part a little >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	MOVE	T4,T3			; Move the low order
	MOVE	T3,T2			;  part a little >
	IDIVI	T1,(P3)			; Get a
	DIVI	T2,(P3)			;  digit to
	DIVI	T3,(P3)			;  output
	SUBX	P2,^D1			; Decrement the fill count
	HRLM	T4,(P)			; Save for later
	JUMPN	T1,TINTG8		; Jump if more to do (i.e. binary)
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	DMOVE	T1,T2			; Move the result into the right place >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>>,<
	MOVE	T1,T2			; Move the result into
	MOVE	T2,T3			;  the right place >
	JRST	TINTG2			; Go see if anything left
	$TOC	.TINTG -- The End


	$PRGEND				; End of '.TINTG'	$TOC	.TPICT -- Initialization  15-May-83  /DRB/RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TPICT

	$INIT	.TPICT - Generate and Type Pictures (COBOL),<.TPICT,.TYPIC>,\'TF%COD


; Force the low segment to be loaded

	EXTERN	.TDATA			; Request the TYPER low segment
	$TOC	.TPICT -- Storage -- Message Characters


; The following give some symbol definitions for message chars.

EDTHGH:	EDIT	XLATE

; Define two macros to do this mess

DEFINE	.MCHAR [SALL] ($CHR,$NAM),<
  .MDEFI ($NAM,\<$OFST+^O1>)
  .MC'$NAM=.EPMES+$OFST
  $OFST==$OFST+^O1
	"$CHR"
>	; End of 'DEFINE .MCHAR'

DEFINE	.MDEFI [SALL] ($NAM,$ADJ),<
  DEFINE .MS'$NAM [SALL] <EDTBLK+$ADJ>
>	; End of 'DEFINE .MDEFI'

; Start at zero:

	$OFST==0

; Now, define that characters:

	.MCHAR	< >,FIL			; Default fill character
	.MCHAR	<$>,FLT			; Default float character
	.MCHAR	< >,SPC			; Space
	.MCHAR	<$>,DOL			; Dollar sign
	.MCHAR	<*>,AST			; Asterisk
	.MCHAR	<+>,PLS			; Plus sign
	.MCHAR	<,>,COM			; Comma
	.MCHAR	<->,MIN			; Minus sign
	.MCHAR	<.>,PER			; Decimal point
	.MCHAR	<B>,B			; "B"
	.MCHAR	<C>,C			; "C"
	.MCHAR	<D>,D			; "D"
	.MCHAR	<R>,R			; "R"

EDTEND==.-^O1				; The end of the fill block
EDTSIZ==.-EDTHGH			; The length of the EXTEND block

IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
  EDTLEN==EDTSIZ			; The length of the EXTEND block >

IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
  EDTLEN==^O0				; The length of the EXTEND block
   IFE <TF%SEG-TF%TWO>,<
	$LOW				; Point to the low segment
EDTBLK:	BLOCK	EDTSIZ			; Define a block a data
	$HIGH				; Point to high segment >
   IFN <TF%SEG-TF%TWO>,<
      EDTBLK==EDTHGH			; Define the block data >>
	$TOC	.TPICT -- Storage -- Picture Character Dispatch Table


; The following is the dispatch table for picture characters

PICTBL:	"$",,PICFLT
	"*",,PICFIL
	"+",,PICFLT
	",",,PICCOM
	"-",,PICFLT
	".",,PICPER
	"9",,PIC9
	"B",,PICB
	"C",,PICCR
	"D",,PICDB
	"Z",,PICFIL
PICLEN==.-PICTBL
	$TOC	.TPICT -- Storage -- The Translate Table


; The translate table for EDIT:

XLATE:	000060,,400061
	400062,,400063
	400064,,400065
	400066,,400067
	400070,,400071
	100000,,100000
	100000,,100000
	100000,,100000
	300060,,700061
	700062,,700063
	700064,,700065
	700066,,700067
	700070,,700071
	100000,,100000
	100000,,100000
	100000,,100000

; The translate table for CVTBDT:

CVT:	400020,,400000
	400021,,400001
	400022,,400002
	400023,,400003
	400024,,400004
	400025,,400005
	400026,,400006
	400027,,400007
	400030,,400010
	400031,,400011
	$TOC	.TPICT -- Storage -- Dispatch Tables for KA/KI-10 EDIT


;     The folowing are dispatch tables for the  EDIT  simulation
; for pre-KL-10 cpu's.

IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<

; The edit dispatch table:

EDTDSP:	ED%STP				; (000) Stop
	ED%SEL				; (001) Select
	ED%SIG				; (002) Significance start
	ED%SEP				; (003) Field separator
	ED%EXM				; (004) Exchange mark and dest
	EDIT03				; (005) No-op
	BADFCN				; (006) Error
	BADFCN				; (007) Error
	BADFCN				; (0nn) Error
	ED%MES				; (1nn) Message character
	BADFCN				; (2nn) Error
	BADFCN				; (3nn) Error
	BADFCN				; (4nn) Error
	ED%SKM				; (5nn) Skip on M
	ED%SKN				; (6nn) Skip on N
	ED%SKP				; (7nn) Skip always

BADFCN:	$TYPE	(F,BEF,$OCT,<Bad EDIT function (|)>,,A,T)

; Dispatch table for XLATE words:

SELDSP:	SL%ISB				; (0) Move a byte
	SL%TRM				; (1) Abort
	SL%ICM				; (2) Clear M
	SL%ISM				; (3) Set M
	SL%SSB				; (4) Set S, etc
	SL%TMN				; (5) Set N, abort
	SL%SCM				; (6) Clear M, set S, etc
	SL%SSM				; (7) Set S, M, etc

>					; End KA/KI-10 conditional
	$TOC	.TPICT -- .TYPIC - $TYPES Support Routine


; .TYPIC - TYPES function to set up the picture saving area.
; Call:	HRRZI	T1,{the address of the picture saving block}
;	HRLI	T1,{the length of the picture saving block}
;	PUSHJ	P,.TYPIC		; The old value is in T1
;	 * Return *
; Uses:	T1-4

.TYPIC::EXCH	T1,.TYPCT##		; Store the user's address
	SKIPN	T2,.TYPCT##		; Skip if a pointer wasn't supplied
	POPJ	P,			; Return

	SETZM	(T2)			; Clear the first word
	HLRZ	T4,T2			; Get the length of the block
	CAXN	T4,^O1			; Skip if more than one word
	POPJ	P,			; Return
	HRLZI	T3,(T2)			; Clear the
	HRRI	T3,^O1(T2)		;  picture
	ADDI	T4,(T2)			;  storage
	BLT	T3,-^O1(T4)		;  area

	POPJ	P,			; Return
	$TOC	.TPICT -- .TPICT - Type a Number with Picture Editing


; .TPICT - Output a number (single/double precision) via a COBOL
;  picture.  The argument block is set up by the $NUMBER macro.
; Call:	DMOVX	T1,{the number to be output}
;	MOVX	P1,{the flags}
;	MOVX	P2,{the address of the $NUMBER parameter block}
;	PUSHJ	P,.TPICT
;	 * Return *
; Uses:	T1-4 and P1-4

.TPICT::PUSH	P,T1			; Save T1
	PUSH	P,T2			;  and T2
	CAIN	P4,.NMDBL		; Skip in not double precision
	CAIE	T4,.NMIMD		; Skip if immediate mode
	SKIPA	T1,NM.PIC(P2)		; Get the picture pointer
	MOVE	T1,NM.PIC+^O1(P2)	; Get the picture pointer (double/immediate)
	PUSHJ	P,.TPNTR##		; Go locate it
	MOVE	P3,T1			; Copy into P3
	POP	P,T2			; Restore T1
	POP	P,T1			;  and T2

	$VARIA	(GLOBAL,<FLOAT,FILL,OLDCHR,PICPNT,PICPTR,PTNPNT,DIGCNT,MARK,<DECNUM,^D4>,<EDTSTR,^D10>,<PATTRN,^D24>,<EDTBLK,EDTLEN>>)
	MOVEM	P3,PICPTR		; Save the pointer
	MOVEM	P3,PICPNT		; Save the pointer
	MOVE	P3,P1			; Save the flags

IFE <<TF%CPU-TF%KL1>*<TF%CPU-TF%KL2>*<TF%CPU-TF%KS1>*<TF%CPU-TF%KS2>*<TF%SEG-TF%TWO>>,<
	HRLZI	T3,EDTHGH		; Get a copy
	HRRI	T3,EDTBLK		;  of the
	BLT	T3,EDTBLK+EDTSIZ-^O1	;  edit block >

; First, convert the number to decimal:

	SETZ	T3,			; Zero (not used)
	MOVX	T4,^D22			; Get string length
	TXO	T4,TF%LEN		; Set the "Length" bit
	MOVE	P1,[POINT 5,DECNUM]	; Get the pointer
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	EXTEND	T1,[CVTBDT CVT		 ; Convert binary to
		    0]			 ;  decimal translated >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	PUSHJ	P,.CVBDT		; Convert binary to decimal >
	 $TYPE	(F,CTE,$NON,<CVTBDT took the error return>,,A,T)
	TXNN	P3,%NMSAV		; Saving this picture?
	JRST	TPIC02			; No, skip this

; Here to search the user table for saved pictures:

	MOVE	T4,.TYPCT##		; Get the addr of the table
	HRRZ	T2,PICPTR		; Get the address of the picture

TPIC01:	HLRZ	T1,(T4)			; Get the addr of the picture
	JUMPE	T1,TPIC02		; End of list, quit
	CAMN	T1,T2			; Same as this one?
	JRST	TPIC03			; Yes, go do it
	HRRZ	T4,(T4)			; No, get addr of next one
	JUMPN	T4,TPIC01		; Loop if not end

; Here if no match found in saved table:

TPIC02:	PUSHJ	P,GENPIC		; Go convert the picture
	 POPJ	P,			; Pass on the error
	TXZA	P3,%NMMAT		; No match found!

TPIC03:	TXO	P3,%NMMAT		; Assume match
;     Here to perform an edit  function  on  an  integer.   This
; routine  uses  the  pattern  strings  as  generated  by  entry
; "GENPIC".

TPIC04:
	TXNN	P3,%NMMAT		; Match found?
	JRST	TPIC05			; No, skip this
	MOVE	P4,T4			; Copy the address of the block
	MOVE	T4,[POINT ^D9,^O1(P4)]	; Get a byte pointer
	ILDB	T3,T4			; Get the fill character
	MOVEM	T3,.MSFIL		; Store it
	ILDB	T3,T4			; Get the float character
	MOVEM	T3,.MSFLT		; Store it
	ILDB	T3,T4			; Get the digit count
	MOVEM	T3,DIGCNT		; Store it

; Now, point to the first desired digit:

TPIC05:	MOVX	T2,^D22			; Get the max digits
	SUB	T2,DIGCNT		; Subtract the number we want
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	ADJBP	T2,[POINT 5,DECNUM]	; Set the pointer >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	PUSH	P,[POINT 5,DECNUM]	; Get a byte pointer
	SKIPLE	T2			; Skip if no places to shift
TPIC06:	IBP	(P)			; Increment it
	SOJG	T2,TPIC06		; Loop for all digits
	POP	P,T2			; Restore the pointer >
; Now, setup the EDIT instruction:

	TXNN	P3,%NMMAT		; Match found?
	JRST	TPIC07			; No, skip this
	MOVEI	T1,^O2(P4)		; Yes, get the pattern string
	JRST	TPIC08			; Skip some stuff

TPIC07:	MOVE	T1,FILL			; Get the fill character
	MOVEM	T1,.MSFIL		; Store it
	MOVE	T1,FLOAT		; Get the float character
	MOVEM	T1,.MSFLT		; Store it
	MOVEI	T1,PATTRN		; Get the pattern string

TPIC08:	TXO	T1,TF%SIG		; Turn on S
	TXNE	T4,TF%MIN		; Minus?
	TXO	T1,TF%MIN		; Yes, flag it in EDIT
	MOVEI	T4,MARK			; Mark address
	SETZ	T3,			; Single segment byte pointer
	MOVE	P1,[POINT 7,EDTSTR]	; Final string

; Now!!!

IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	EXTEND	T1,EDTBLK		; Do the edit!! >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	PUSHJ	P,.EDIT			; Do the edit!! >
	 $TYPE	(F,ETE,$NON,<EDIT took the error return>,,A,T)
	SETZ	T1,			; Terminate the
	IDPB	T1,P1			;  string
	MOVEI	T1,EDTSTR		; Output the
	PUSHJ	P,.TSTRG##		;  picture string
	TXNE	P3,%NMSAV		; Saved pointer wanted?
	TXNE	P3,%NMMAT		; Already there?
	POPJ	P,			; Yes, return
; Here to save the picture, first see if it will fit:

	MOVE	T1,[POINT 9,PATTRN]	; Get a byte pointer
	SETZ	T3,			; Start with 0 bytes

TPIC09:	ILDB	T2,T1			; Get the next byte
	CAXE	T2,.EPSTP		; End of string?
	AOJA	T3,TPIC09		; Loop
	LSH	T3,-^O2			; Divide by 4
	ADDX	T3,^D3			; Account for last bytes + old

	HLRZ	T1,.TYPCT##		; Get the words remaining
	CAIG	T1,(T3)			; Enough space?
	POPJ	P,			; No, return

; Here with space in the table, put in the new entry

	HRRZ	T1,.TYPCT##		; Get the root address
TPIC10:	HRRZ	T2,(T1)			; Get word pointed to
	JUMPE	T2,TPIC11		; Got it if zero
	HRRZ	T1,T2			; No, get next addr
	JRST	TPIC10			; Loop until end

; Here with beginning of the block in T1

TPIC11:	MOVE	T2,[POINT ^D9,^O1(T1)]	; Get a byte pointer
	MOVE	T4,FILL			; Get the fill character
	IDPB	T4,T2			; Store it
	MOVE	T4,FLOAT		; Get the float character
	IDPB	T4,T2			; Store it
	MOVE	T4,DIGCNT		; Get the digit count
	IDPB	T4,T2			; Store it
	MOVEI	T4,^O2(T1)		; Get start of string
	HRLI	T4,(POINT 9,)		; Make it a byte pointer
	MOVE	P2,[POINT 9,PATTRN]	; Point to the pattern string

TPIC12:	ILDB	T2,P2			; Get a byte
	IDPB	T2,T4			; Store it
	JUMPN	T2,TPIC12		; Loop if more
	ADDX	T4,^D1			; Bump to the next word
	HRL	T4,PICPTR		; Get the string address
	SETZM	(T4)			; Zero the first free word
	MOVEM	T4,^O0(T1)		; Store the pointer
	HLRZ	T1,.TYPCT##		; Get the words remaining
	SUBI	T1,(T3)			; Correct it
	HRLM	T1,.TYPCT##		; Store the updated count
	POPJ	P,			; And return
	$TOC	.TPICT -- GENPIC - Compile a Picture


;     Here  on  entry  to  this  subroutine,  call  with  PICPNT
; containing  an  ASCIZ byte pointer to the picture.  The caller
; is responsible for setting the "M" bit  before  executing  the
; pattern string.

GENPIC:	SETZM	DIGCNT			; Start with no digits
	MOVE	T1,[POINT 9,PATTRN]	; Get the pattern pointer
	MOVEM	T1,PTNPNT		; Store it
	SETZM	FILL			; Zero the fill character
	SETZM	FLOAT			; And the float character
	ILDB	T1,PICPNT		; Get the first character
	SKIPN	T1			; Make sure there is one
	$TYPE	(F,INP,$NON,<Illegal null picture>,,P,T)

; Main compile loop here:

GENP01:	MOVSI	T2,-PICLEN		; Get table of characters
GENP02:	HLRZ	T3,PICTBL(T2)		; Get a character
	CAIE	T1,(T3)			; Is it the one?
	AOBJN	T2,GENP02		; No, try next
	SKIPL	T2			; Did we find one?
	$TYPE	(F,IPC,$CHR,<Illegal picture character |>,,P,T)
	MOVEI	T4,PICTBL(T2)		; Get the dispatch address
	MOVEM	T1,OLDCHR		; Store the old character
	ILDB	T1,PICPNT		; Get the next character
	CAXE	T1,"("			; Start of repeat?
	JRST	GENP05			; No, skip this
	SETZ	T2,			; Start with zero

GENP03:	ILDB	T1,PICPNT		; Get the next character
	CAXL	T1,"0"			; Is it a
	CAXLE	T1,"9"			;  digit?
	JRST	GENP04			; No, exit loop
	IMULI	T2,^D10			; Yes, shift a place
	ADDI	T2,-"0"(T1)		; Add in new digit
	JRST	GENP03			; Loop for all digits

; Done with repeat count, should find a ")" here:

GENP04:	CAXE	T1,")"			; End of repeat?
	$TYPE	(N,IPC)			; No, give error
	ILDB	T1,PICPNT		; Yes, get next character
	JRST	GENP07			; And skip next
; Here with a single picture character (no repeat), see how
; many of these buggers we got:

GENP05:	MOVX	T2,^D1			; Get a default count of "1"
	MOVE	T3,OLDCHR		; Restore old character
GENP06:	CAIE	T1,(T3)			; Same as old one?
	JRST	GENP07			; No, exit this mess
	ILDB	T1,PICPNT		; Yes, get next character
	AOJA	T2,GENP06		; Loop until done

; Here with repeat count in T2, dispatch this thing

GENP07:	HRRZ	T3,(T4)			; Get the dispatch address
	PUSHJ	P,(T3)			; Go do it
	 POPJ	P,			; Pass on error
	JUMPN	T1,GENP01		; Loop if more characters

; Here when done all picture chars, go finish trailing +-

GENDON:	MOVE	T1,FLOAT		; Get the float character
	CAXE	T1,"+"			; Plus?
	JRST	GEND01			; No, try minus
	MOVX	T1,.EPSKM+^O0		; Get SKIPM + 0
	IDPB	T1,PTNPNT		; Store it
	MOVX	T1,.EPSKP+^O2		; Get SKIPA + 2
	IDPB	T1,PTNPNT		;  ...
	MOVX	T1,.EPEXM		; Exchange mark and dest pointer
	IDPB	T1,PTNPNT		; Store
	MOVX	T1,.MCMIN		; Get minus
	IDPB	T1,PTNPNT		; Store it
	MOVX	T1,.EPEXM		; Swap them back
	IDPB	T1,PTNPNT		; Store
	JRST	GEND02			; Skip next

GEND01:	CAXE	T1,"-"			; Floating minus?
	JRST	GEND02			; No, skip this
	MOVX	T1,.EPSKM+^O2		; Get SKIPM + 2
	IDPB	T1,PTNPNT		; Store
	MOVX	T1,.EPEXM		; Swap pointers
	IDPB	T1,PTNPNT		;  pointers
	MOVX	T1,.MCSPC		; Get " "
	IDPB	T1,PTNPNT		; Store
	MOVX	T1,.EPEXM		; Swap them
	IDPB	T1,PTNPNT		;  back

GEND02:	MOVX	T1,.EPSTP		; Get STOP
	IDPB	T1,PTNPNT		; Store it
	JRST	.POPJ1##		; Done
	$TOC	.TPICT -- Subroutines -- Picture Character Processors


; The following are routines to compile picture characters

; Here for some kind of float character:

PICFLT:	CAXE	T2,^D1			; Want floating character?
	JRST	PICF02			; Yes, skip this
	MOVE	T2,OLDCHR		; Get the character
	CAXN	T2,"$"			; Dollar sign?
	JRST	[MOVX T3,.MCDOL		 ; Yes, get one
		 IDPB T3,PTNPNT		 ; Store it
		 JRST .POPJ1##]		 ; And go finish up
	MOVX	T3,.EPSKM+^O1		; No, get SKPM+1
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCSPC		; Get a space
	CAXN	T2,"+"			; Unless "+" wanted
	MOVX	T3,.MCPLS		; Then get a "+"
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.EPSKP+^O0		; Get SKPA+0
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCMIN		; Get "-"
	IDPB	T3,PTNPNT		; Store it

PICF01:	SKIPN	DIGCNT			; Skip if digit count is non-zero
	JRST	.POPJ1##		; Zero, ok
	JUMPE	T1,.POPJ1##		; Ok if last char
	$TYPE	(N,IPC)			; Return

PICF02:	SKIPE	T3,FLOAT		; Get float character
	JRST	PICF03			; Already have one
	SKIPE	DIGCNT			; Any digits yet?
	JRST	$$$IPF			; Yes, error
	MOVX	T3," "			; Get the fill character
	MOVEM	T3,FILL			; Store it
	MOVX	T3,.EPSEP		; Get FLDSEP
	IDPB	T3,PTNPNT		; Store it
	MOVE	T3,OLDCHR		; Get this character
	MOVEM	T3,FLOAT		; Store it
	SUBX	T2,^D1			; Account for float character

PICF03:	CAME	T3,OLDCHR		; Right float character?
	JRST	$$$IPF			; No, error
	ADDM	T2,DIGCNT		; Count these digits
	MOVX	T3,.EPSEL		; Get SELECT
PICF04:	IDPB	T3,PTNPNT		; Store it
	SOJG	T2,PICF04		; Loop for all digits
	JRST	.POPJ1##		; Return
; Here with a fill char:

PICFIL:	SKIPN	T3,FILL			; Get the fill character
	JRST	[MOVE  T3,OLDCHR	 ; Default to the picture char
		 CAXN  T3,"Z"		 ; Unless "Z" picture
		 MOVX T3," "		 ;  them make is a space
		 JRST  PICFI1]		 ; Continue
PICFI1:	EXCH	T3,FILL			; Store the fill character
	JUMPN	T3,PICFI2		; Skip if not the first time
	MOVX	T3,.EPSEP		; Get FLDSEP
	IDPB	T3,PTNPNT		; Store it

PICFI2:	ADDM	T2,DIGCNT		; Count these digits
	MOVX	T3,.EPSEL		; Get a select
PICFI3:	IDPB	T3,PTNPNT		; Store it
	SOJG	T2,PICFI3		; Loop
	JRST	.POPJ1##		; All done

; Here for ",":

PICCOM:	CAXE	T2,^D1			; Can only have one
	$TYPE	(F,TMC,$NON,<Too many commas>,,P,T)
	MOVX	T3,.MCCOM		; Get the character
	IDPB	T3,PTNPNT		; Store it
	JRST	.POPJ1##		; Exit

; Here for ".":

PICPER:	CAXE	T2,^D1			; Just one?
	JRST	$$$IPF			; No, error
	MOVX	T3,.EPSIG		; Get sig start
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCPER		; Get "."
	IDPB	T3,PTNPNT		; Store it
	JRST	.POPJ1##		; All done

; Here for "9":

PIC9:	SKIPN	T3,FILL			; Get the fill character
	MOVX	T3,"0"			; Default
	MOVEM	T3,FILL			; Incase it changed
	CAXE	T3," "			; Is it a space?
	JRST	PIC901			; No, skip this
	MOVX	T3,.EPSIG		; Yes, get SIGST
	IDPB	T3,PTNPNT		; Store it

PIC901:	ADDM	T2,DIGCNT		; Count these digits
	MOVX	T3,.EPSEL		; Get SELECT
PIC902:	IDPB	T3,PTNPNT		; Store it
	SOJG	T2,PIC902		; Loop for all
	JRST	.POPJ1##		; Return
; Here for "B":

PICB:	MOVX	T3,.MCSPC		; Get space
PICB01:	IDPB	T3,PTNPNT		; Store it
	SOJG	T2,PICB01		; Loop for all
	JRST	.POPJ1##		; Done

; Here for "CR":

PICCR:	CAXE	T2,^D1			; Check count
	JRST	$$$IPF			;  ...
	CAXE	T1,"R"			; Make sure "R" is next
	$TYPE	(N,IPC)			; Give error
	ILDB	T1,P4			; Get next character
	JUMPN	T1,$$$IPC		; Error if there is one
	MOVX	T3,.EPSKM+^O2		; Get SKIPM + 2
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCSPC		; Get space
	IDPB	T3,PTNPNT		; Store it
	IDPB	T3,PTNPNT		;  twice
	MOVX	T3,.EPSKP+^O1		; Get SKIPA + 1
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCC			; Get "C"
	IDPB	T3,PTNPNT		; Store
	MOVX	T3,.MCR			; Get "R"
	IDPB	T3,PTNPNT		; Store it
	JRST	.POPJ1##		; Give good return

; Here for "DB":

PICDB:	CAXE	T2,^D1			; Only 1 character?
	JRST	$$$IPF			; Error
	CAXE	T1,"B"			; DB?
	$TYPE	(N,IPC)			; Error
	ILDB	T1,P4			; Get next character
	JUMPN	T1,$$$IPC		; Error if more
	MOVX	T3,.EPSKM+^O2		; Get SKIPM + 2
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCSPC		; Get " "
	IDPB	T3,PTNPNT		; Store
	IDPB	T3,PTNPNT		;  twice
	MOVX	T3,.EPSKP+^O1		; Get SKIPA + 1
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCD			; Get "D"
	IDPB	T3,PTNPNT		; Store it
	MOVX	T3,.MCB			; Get "B"
	IDPB	T3,PTNPNT		; Store it
	JRST	.POPJ1##		; Give good return

; Here on some random error:

$$$IPF:	$TYPE	(F,IPF,$NON,<Illegal picture format>,,P,T)
	$TOC	.TPICT -- Subroutines -- KA/KI Simulation -- CVTBDT


; .CVBDT - The following is a routine to simulate the CVTBDT extended
;  instruction for non-KL/KS processors.
; Call:	DMOVX	T1,{the number to be converted to decimal}
;	MOVX	T4,{the string length}
;	TXO	T4,{some CVTBDT flags}
;	MOVX	P1,{the pointer to the string}
;	PUSHJ	P,.CVBDT
;	 * Non-skip return - An error in translation was detected *
;	* Skip return - No translation errors detected *
; Uses:	T1-2, T4 and P1
; Note:	T1 - Contains zero
;	T2 - Contains zero
;	T4 - Contains the updated flags and string length
;	P1 - Contains the updated byte pointer

IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
.CVBDT:	$VARIA	(SAVE,<>,BDTCAL,BDTREG)	; Save the AC's
	MOVE	T1,BDTREG+P1-^O1	; Get the byte pointer
	PUSHJ	P,.TPNTR##		; Go fix it up
	MOVE	P4,T1			; Put it in P4

IFE <TF%CPU-TF%KI1>,<
	DMOVE	T1,BDTREG+T1-^O1	; Get the number >
IFN <TF%CPU-TF%KI1>,<
	MOVE	T1,BDTREG+T1-^O1	; Get the
	MOVE	T2,BDTREG+T2-^O1	;  number >

	MOVE	P3,BDTREG+T4-^O1	; Get the length
	JUMPGE	T1,.CVB01		; Jump if positive number

IFE <TF%CPU-TF%KI1>,<
	DMOVN	T1,T1			; Negate the number >
IFN <TF%CPU-TF%KI1>,<
	SETCM	T1,T1			; Get one's complement of high order
	MOVN	T2,T2			; Get 2's complement of low order
	TXZ	T2,B0			; Clear the sign bit
	SKIPN	T2			; Low part zero?
	ADDX	T1,^D1			; Yes, bump high part >
	TXO	P3,TF%MIN		; Set M flag

; Now, go convert the number:

.CVB01:	PUSHJ	P,CVBD01		; Do it to it!
	 SOS	(P)			; Cause error return
	ANDX	P3,^O7B2		; Clear all but flags
	SETZM	BDTREG+T1-^O1		; Zero the
	SETZM	BDTREG+T2-^O1		;  argument
	MOVEM	P3,BDTREG+T4-^O1	; Store the flags
	MOVEM	P4,BDTREG+P1-^O1	; Store the new byte pointer
	JRST	.POPJ1##		; And return

					; Still under KA/KI-10 conditional
; Here to convert the number:

CVBD01:	MOVE	T3,T2			; Move the low order part a bit
	IDIVX	T1,^D10			; Divide the high order part by 10
	DIVX	T2,^D10			; Finish the divide (rem in T3)
	SKIPE	T3			; Zero remainder?
	TXO	P3,TF%NON		; No, set N flag
	SKIPN	T2			; Skip if something left (low order)
	JUMPE	T1,CVBD03		; Jump if nothing left (high order)
	HRRZ	T3,CVT(T3)		; Get the desired byte
	PUSHJ	P,CVBD05		; Go do some common stuff
	 POPJ	P,			; Pass on the abort
	TXNN	P3,TF%SIG		; S on?
	JUMPE	T3,CVBD01		; No, is S zero?
	HRLM	T3,(P)			; Ok to store
	SUBX	P3,^D1			; Count this digit
	PUSHJ	P,CVBD01		; Get next digit
	 SOS	(P)			; Pass on the abort

CVBD02:	HLRZ	T1,(P)			; Get the byte
	IDPB	T1,P4			; Store it
	JRST	.POPJ1##		; And return

; Here on last digit of the number:

CVBD03:	MOVE	T3,CVT(T3)		; Get the word
	TXNE	P3,TF%MIN		; Negative?
	MOVS	T3,T3			; Yes, get <LH>


	TLZ	T3,^O777777		; Clear junk
	PUSHJ	P,CVBD05		; Go do some stuff
	 SOS	(P)			; Pass on the abort
	HRLM	T3,(P)			; Store the number
	SUBX	P3,^D1			; Count this digit
	TXNN	P3,TF%SIG		; Sign up?
	JRST	CVBD02			; No, done
	SETZ	T1,			; Get fill character
	MOVX	T2,TF%LEN		; Get length bit
	TDNN	T2,BDTREG+T4-^O1	; Was it on?
	JRST	CVBD02			; No, continue
	HRRZ	P2,P3			; Get number remaining
	JUMPLE	P2,CVBD02		; Done if zero
CVBD04:	IDPB	T1,P4			; Store a zero
	SOJG	P2,CVBD04		; Loop for all remaining
	JRST	CVBD02			; Done, go finish up


					; Still under KA/KI-10 conditional
; Here to perform some common processing

CVBD05:	LDB	T4,[POINT ^D3,T3,^D20]	; Get the function code
	ANDX	T3,^O77777		; Mask off the junk

CVBD06:	JUMPE	T4,.POPJ1##		; Return if no sign
	CAXN	T4,.COTRM		; Terminate?
	 POPJ	P,			; Do an abort
	CAXN	T4,.COICM		; Turn off M?
	TXZ	P3,TF%MIN		; Yes
	CAXN	T4,.COISM		; Set M?
	TXO	P3,TF%MIN		; Yes
	TXZN	T4,.COSSD		; Subtract 4
	JRST	.POPJ1##		; Wasn't there, return
	TXO	P3,TF%SIG		; Set S
	JRST	CVBD06			; And try again

>					; End KA/KI-10 conditional
	$TOC	.TPICT -- Subroutines -- KA/KI Simulation -- EDIT


; .EDIT - The following is a routine to simulate the EDIT extended
;  instruction for non-KL/KS processors.
; Call:	MOVX	T1,{the pattern string address}
;	TXO	T1,{some EDIT flags}
;	MOVX	T2,{the address of the source string byte address}
;	MOVX	T4,{the address of the mark}
;	MOVX	P1,{the address of the desination string byte address}
;	PUSHJ	P,.EDIT
;	 * Non-skip return - The edit was aborted *
;	* Skip return - The edit didn't detect any errors *
; Uses:	T1-2, T4 and P1
; Note:	T1 - The updated flags and pattern pointer
;	T2 - The updated source pointer
;	T4 - The updated mark
;	P1 - The updated desination pointer

IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
.EDIT:	$VARIA	(SAVE,<>,EDTCAL,EDTREG)	; Save some AC's
	MOVE	P4,EDTREG+T1-^O1	; Get the pattern string+flags
	MOVE	T1,P4			; Copy the string address
	TLZ	T1,^O777740		; Mask off junk
	PUSHJ	P,.LOCAT##		; Find the string
	MOVE	P3,T1			; Copy into P3
	HRLI	P3,(POINT 9,)		; Make it a byte pointer
	LDB	T1,[POINT ^D2,P4,^D5]	; Get the byte number
	SOJL	T1,EDIT02		; Exit if there
EDIT01:	IBP	P3			; No, bump the pointer
	SOJGE	T1,EDIT01		; Exit if there

EDIT02:	MOVE	T1,EDTREG+T2-^O1; Get the source pointer
	PUSHJ	P,.TPNTR##		; Go locate it
	MOVE	P2,T1			; Copy into P2
	MOVE	T1,EDTREG+P1-^O1; Get the dest pointer
	PUSHJ	P,.TPNTR##		; Locate it
	MOVE	P1,T1			; Put it in P1
	MOVE	T1,EDTREG+T4-^O1; Get the mark address
	PUSHJ	P,.LOCAT##		; Locate it
	MOVE	T4,T1			; Put it in T4
	PFALL	EDIT03			; Fall into the loop

; Now for the loop:

EDIT03:	ILDB	T1,P3			; Get an opcode
	TXNN	T1,^O770		; Is it an easy one?
	JRST	@EDTDSP(T1)		; Yes, go do it
	LSHC	T1,-^D6			; No, separate the
	LSH	T2,-^D30		;  opcode from operand
	JRST	@EDTDSP+^O10(T1)	; Go dispatch it

					; Still under KA/KI-10 conditional
	$TOC	.TPICT -- Subroutines -- KA/KI Simulation -- EDIT Subfunctions


; Here on a STOP command, done!

ED%STP:	IBP	P3			; Point to next byte
	HRR	P4,P3			; Copy the pointer
	LDB	T1,[$POINT P3,BP%POS]	; Get the position
	IDIVX	T1,^D9			; Get the number remaining
	MOVX	T2,^D3			; Get max
	SUBI	T2,(T1)			; Get the next byte number
	DPB	T2,[POINT ^D2,P4,^D5]	; Stuff the position back
	MOVEM	P4,EDTREG+T1-^O1	; Store the address
	MOVEM	P2,EDTREG+T2-^O1	; Restore the source pointer
	MOVEM	P1,EDTREG+P1-^O1	; Restore the dest pointer
	JRST	.POPJ1##		; And return

; Here on a select command, move a byte:

ED%SEL:	ILDB	T1,P2			; Get a byte
	LSHC	T1,-^D1			; Divide by 2
	MOVE	T1,XLATE(T1)		; Get the proper word
	TXNN	T2,B0			; Do we want <LH>?
	MOVS	T1,T1			; Yes, get <LH>
	TLZ	T1,^O777777		; Get rid of junk
	LSHC	T1,-^D15		; Separate
	LSH	T2,-^D21		;  the opcode
	JRST	@SELDSP(T1)		; Go dispatch the function

SL%ICM:	TXZA	P4,TF%MIN		; Clear M
SL%ISM:	TXO	P4,TF%MIN		; Set M
SL%ISB:	TXNN	P4,TF%SIG		; S on?
	SKIPA	T1,.MSFIL		; No, get fill
	MOVEI	T1,^O400000(T2)		; Yes, get the character
	SKIPE	T1			; Zero byte?
	IDPB	T1,P1			; No, store it
	JRST	EDIT03			; Do next function

SL%TMN:	TXO	P4,TF%NON		; Set N
SL%TRM:	POPJ	P,			; Nothing to do here

SL%SCM:	TXZA	P4,TF%MIN		; Clear M
SL%SSM:	TXO	P4,TF%MIN		; Set M
SL%SSB:	TXO	P4,TF%NON		; Turn on N
	TXOE	P4,TF%SIG		; S already on?
	JRST	SL%ISB			; Yes, go finish up
	MOVEM	P1,(T4)			; Store the mark pointer
	SKIPE	T1,.MSFLT		; Get the float character
	IDPB	T1,P1			; Store if non-zero
	IDPB	T2,P1			; Store the character
	JRST	EDIT03			; Do next function

					; Still under KA/KI-10 conditional
; Here on a SIGST:

ED%SIG:	TXOE	P4,TF%SIG		; S already on?
	JRST	EDIT03			; Yes, done
	MOVEM	P1,(T4)			; Store the destination pointer
	SKIPE	T1,.MSFLT		; Get the float character
	IDPB	T1,P1			; Output it if non-zero
	JRST	EDIT03			; Do next


; Here on FLDSEP:

ED%SEP:	TXZ	P4,TF%SIG!TF%NON!TF%MIN	; Clear the flags
	JRST	EDIT03			; Do next function


; Here on EXCHMD:

ED%EXM:	EXCH	P1,(T4)			; Swap the pointers
	JRST	EDIT03			; Do next function


; Here on MESSAG:

ED%MES:	TXNN	P4,TF%SIG		; S on?
	SKIPA	T1,.MSFIL		; No, get the fill character
	MOVE	T1,.MSFIL(T2)		; Yes, get the character       ** POSSIBLE BUG **
	SKIPE	T1			; Is it zero?
	IDPB	T1,P1			; No, store it
	JRST	EDIT03			; Loop


; Here on SKPM:

ED%SKM:	TXNN	P4,TF%MIN		; Is M on?
	JRST	EDIT03			; No, do next function
	JRST	ED%SKP			; Yes, do the skip


; Here on SKPN

ED%SKN:	TXNN	P4,TF%NON		; Is N on?
	JRST	EDIT03			; No, do next function
	PFALL	ED%SKP			; Yes, do skip


; Here to do a skip:

ED%SKP:	IBP	P3			; Bump the pattern pointer
	SOJGE	T2,ED%SKP		; Loop for nn + 1
	JRST	EDIT03			; Do next function

>					; End KA/KI-10 conditional
	$TOC	.TPICT -- The End


	$PRGEND				; End of '.TPICT'	$TOC	.TROMN -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TROMN

	$INIT	.TROMN - Output a Roman Numeral,.TROMN,\'TF%COD
	$TOC	.TROMN -- Roman Numeral Conversion Table


TYPRMN:	   ^D1,,"I"			; (0) One
	   ^D5,,"V"			; (1) Five
	  ^D10,,"X"			; (2) Ten
	  ^D50,,"L"			; (3) Fifty
	 ^D100,,"C"			; (4) One hundred
	 ^D500,,"D"			; (5) Five hundred
	^D1000,,"M"			; (6) One thousand
TYPRMS==.-TYPRMN-^O1
	$TOC	.TROMN -- Type a Roman Numeral


; .TROMN -- Output a Roman numeral (upper or lower case)
; Call:	DMOVX	T1,{the number to output}
;	MOVX	P1,{the first word of the $NUMBER parameter block}
;	PUSHJ	P,.TROMN
;	 * Return *
; Uses:	T1-4, P1-4

.TROMN::TXNN	P1,%NMLOW		; Skip if lower case is wanted
	TDZA	P3,P3			; Set up to output upper case
	MOVX	P3,<"a"-"A">		; Set up to output lower case

	JUMPN	T1,$$$IVR		; Jump if high order part is non-zero
	SKIPLE	P2,T2			; Skip if negative, no such roman numeral
	CAXL	P2,^D4000		; Skip if less than 4000
	$TYPE	(F,IVR,$DEC,<| isn't a valid Roman numeral>,,A,T)

	MOVE	P4,P2			; Save for later
	MOVX	T4,TYPRMS		; Start at the top an work down
TROMN1:	HLRZ	T2,TYPRMN(T4)		; Get the decimal value
TROMN2:	CAMGE	P2,T2			; Skip if it can be output
	JRST	TROMN3			; Go see if a minus combination
	SUB	P2,T2			; Subtract out the value
	HRRZ	T1,TYPRMN(T4)		; Get the Roman numeral
	PUSHJ	P,TROMN5		; Output the character in the correct case
	JUMPN	P2,TROMN2		; Go try this number again
	JRST	TROMN4			; Go see if ordinal numbers are wanted

TROMN3:	SOS	T3,T4			; Decrement Roman numeral test
	TXZ	T3,^O1			; Try one or two less
	HLRZ	T1,TYPRMN+^D1(T4)	; Get the difference
	HLRZ	T2,TYPRMN(T3)		;  bewteen the
	SUB	T1,T2			;  two values
	CAMGE	P2,T1			; Skip if it can be output
	JRST	TROMN1			; Try the next numeral
	SUB	P2,T1			; Subtract out the value
	HRRZ	T1,TYPRMN(T3)		; Get the Roman numeral
	PUSHJ	P,TROMN5		; Output the character in the correct case
	HRRZ	T1,TYPRMN+^D1(T4)	; Get the Roman numeral
	PUSHJ	P,TROMN5		; Output the character in the correct case
	JUMPN	P2,TROMN1		; Try the next numeral if not finished
	PFALL	TROMN4			; See if ordinal numbers are wanted
TROMN4:	TXNE	P1,%NMCRD		; Skip if ordinal numbers are wanted
	POPJ	P,			; Return
	MOVE	T1,P4			; Get the original number back
	IDIVX	T1,^D100		; Remove some trash
	IDIVX	T2,^D10			; Divide in tens and units
	MOVEI	T1,[ASCIZ ~th~]		; Assume 'th' will do
	CAXN	T2,^D1			; Skip if not 10-19
	PJRST	.TASCI##		; Output the suffix
	CAXN	T3,^D1			; Skip if not 1
	MOVEI	T1,[ASCIZ ~st~]		; Make the suffix 'st'
	CAXN	T3,^D2			; Skip if not 2
	MOVEI	T1,[ASCIZ ~nd~]		; Make the suffix 'nd'
	CAXN	T3,^D3			; Skip if not 3
	MOVEI	T1,[ASCIZ ~rd~]		; Make the suffix 'rd'
	PJRST	.TASCI##		; Output the suffix

TROMN5:	ADD	T1,P3			; Get it into the correct case
	PJRST	.TCHAR##		; Output the character
	$TOC	.TROMN -- The End


	$PRGEND				; End of '.TROMN'	$TOC	.TYPES -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TYPES

	$INIT	.TYPES - $TYPES Macro Support Module,.TYPES,\'TF%COD


; Force the low segment to be loaded

	EXTERN	.TDATA			; Request the TYPER low segment
	$TOC	.TYPES -- The $TYPES Support Module


; .TYPES -- The routine to process the $TYPES macro calls
; Call:	MOVX	T1,{the new data}
;	PUSHJ	P,@[fnc!ret!adr!bas+.TYPES
;		    bas,,loc		; Optional word
;		    adr			; Optional word
;		    bug]		; Optional word
;	 * Return - Previous data in T1 *
; Uses:	T1

.TYPES::$VARIA	(ENTRY,TYPBAS,TYPCAL,TYPBLK)

	HRRZ	P3,P1			; Get the address of the argument

	MOVE	T2,TS.BAS(P1)		; Get some flags
	TXNE	T2,TS%BAS		; Skip if database wasn't given
	JRST	[HLRZ  T1,TS.BSA(P1)	 ; Get the database address
		 CAXN  T1,.TSEDB	 ; Skip if error database isn't wanted
		 MOVEI T1,.TYEDB##	 ; Get pointer to error database
		 CAXN  T1,.TSTDB	 ; Skip if TYPER database isn't wanted
		 MOVEI T1,.TYTDB##	 ; Get pointer to TYPER database
		 EXCH  T1,.TYBSA##	 ; Swap the database addresses
		 HRROM T1,TYPBAS	 ; Save for later
		 JRST  TYPES1]		 ; Go skip the database/location
	SETZM	TYPBAS			; The database wasn't given
	TXNE	T2,TS%XTR		; Skip if database/location isn't used
TYPES1:	ADDX	P3,^O1			; Adjust the option pointer

	SKIPN	TB,.TYBSA##		; Skip if user specified a database
	MOVEI	TB,.TYDDB##		; Use the default database

	TXNN	T2,TS%ARG		; Was an argument specified?
	JRST	TYPES2			; No, use the default then
	MOVE	T1,TS.ADR(P3)		; Calculate the
	PUSHJ	P,.LOCAT##		;  effective address
	MOVE	P4,T1			; Store in a safe place
	AOSA	P3			; Adjust the pointer
TYPES2:	MOVEI	P4,TYPBLK+T1-^O1	; Get the default address, T1
	MOVE	T1,(P4)			; Get the contents of the address

	LDB	T2,[$POINT TS.FNC(P1),TS%FNC]  ; Get the function
	MOVE	P2,TB.FLG(TB)		; Get the flags
	PUSHJ	P,@TYPFNC(T2)		; Go perform the function
	 MOVEM	T1,(P4)			; Save the return argument
	MOVEM	P2,TB.FLG(TB)		; Save the flags

	SKIPE	T1,TYPBAS		; Skip if the database wasn't changed
	HRRZM	T1,.TYBSA##		; Restore the database

	LDB	T1,[$POINT TS.RET(P1),TS%RET]  ; Get the return type
	PJRST	@TYPRET(T1)		; Return
	$TOC	.TYPES -- The Dispatch Table


; The systems changes dispatch table

TYPFNC:	.TYBAS##			; (0) Base
	.TYBUG##			; (1) Bug
	.TYCMP##			; (2) Compress
	.TYCOL##			; (3) Column
	.TYDMP##			; (4) Dump
	.TYEMP##			; (5) Empty
	.TYERR##			; (6) Error
	.TYESN##			; (7) Error string number
	.TYEXT##			; (10) External
	.TYINI##			; (11) Initialization
	.TYHOR##			; (12) Justification
	.TYLOC##			; (13) Location
	.TYMSG##			; (14) Message
	.TYOUT##			; (15) Output
	.TYPIC##			; (16) Picture
	.TYPRM##			; (17) Prompt
	.TYRTN##			; (20) Routine
	.TYSYS##			; (21) System
	.TYTIM##			; (22) Time stamp
	.TYVER##			; (23) Vertical
	.TYVRB##			; (24) Verbosity
	.TYZON##			; (25) Time zone


; The return dispatch table

TYPRET:	TYPABT				; (0) Abort
	TYPCON				; (1) Continue
	TYPDDT				; (2) DDT
	TYPXIT				; (3) Exit
	TYPINT				; (4) Interrupt
	TYPJMP				; (5) Jump
	TYPMON				; (6) Monitor
	.POPJ##				; (7) Normal
	.POPJ1##			; (10) Normal plus 1
	TYPPJ1				; (11) .POPJ1
	TYPPJ0				; (12) .POPJ
	TYPSCN				; (13) SCAN
	$TOC	.TYPES -- The Return Type Support Modules


; TYPABT - Type an aborting message and enter DDT
; Call:	PUSHJ	P,TYPABT		; Type the message and enter DDT
; Uses:	T1

TYPABT:	$TYPE	(F,ABT,$OPC,<Program aborting, PC:|>,,,E,<[.TFPRE]>)
	PFALL	TYPDDT			; Fall into TYPDDT


; TYPDDT - Return from TYPER to DDT
; Call:	PUSHJ	P,TYPDDT		; Puts DDT's start address on the stack
; Uses:	T1-2

TYPDDT:
IFE <TF%MON-TF%T10>,<
	SKIPN	T1,.JBDDT##		; Skip if DDT is loaded
	JRST	TYPMON			; Return to monitor mode >
IFE <TF%MON-TF%T20>,<
	MOVE	 T1,[.FHSLF,,^O770]	; Get the DDT page
	RPACS%				;  characterists
	 ERJMP	TYPMON			; Assume no DDT
	TXNN	T2,PA%PEX		; Skip if the page exists
	JRST	TYPMON			; Return to EXEC mode
	MOVX	T1,^O770000		; Get the DDT address >
	EXCH	T1,TYPCAL		; Return to DDT
	MOVEM	T1,.JBOPC##		; Save the original return address
	$TYPE	(I,DDT,$NON,<Entering DDT>,,P,T)
; TYPJMP - Return from TYPER to a given location
; Call:	MOVX	P1,{the address of the TYPER argument block}
;	PUSHJ	P,TYPJMP		; Puts location on the stack
; Uses:	T1

TYPJMP:	SKIPA	T1,TS.LOC(P1)		; Get the return location


; TYPPJ0 and TYPPJ1 - Return from TYPER via .POPJ or .POPJ1
; Call:	MOVX	T1,.TSPJ0		; Give a .POPJ
;    or	MOVX	T1,.TSPJ1		; Give a .POPJ1
;	PUSHJ	P,TYPPJ0/TYPPJ1		; Puts correct return on the stack
; Uses:	T1

TYPPJ0:
TYPPJ1:	MOVEI	T1,.POPJ1##-.TSPJ1(T1)	; POPJ returns
TYPPJ2:	HRRM	T1,TYPCAL		; Mung the return address
	POPJ	P,			; Return


; TYPINT - Return from TYPER via a DEBRK. or DEBRK%
; Call:	PUSHJ	P,TYPINT		; Return from interrupt
; Uses:	T1

TYPINT:
IFE <TF%MON-TF%T10>,<
	MOVEI	T1,[DEBRK.		 ; Return from interrupt
		     $ERROR (F,DIU,$NON,<DEBRK. is unimplemented>,,D,T)
		     $ERROR (F,NIP,$NON,<No interrupt in progress>,,D,T)] >
IFE <TF%MON-TF%T20>,<
	MOVEI	T1,[DEBRK%		 ; Return from interrupt
		     $ERROR (F,NIP,$NON,<No interrupt in progress>,,D,T)] >
	JRST	TYPPJ2			; Go return


; TYPSCN - Return from TYPER to SCAN (SCAN only)
; Call:	PUSHJ	P,TYPSCN
; Uses:	T1-4

IFE <TF%SCN-TF%ON>,<
TYPSCN:	MOVEI	T1,.FMSGE##		; Return to SCAN
	JRST	TYPPJ2			; Go store the location >
IFE <TF%SCN-TF%OFF>,<
TYPSCN:	$TYPE	(F,SRS,$OPC,<SCAN return and not using SCAN, PC:|>,,D,T,<[.TFPRE]>) >
; TYPCON - Return to monitor/EXEC mode and allow a continue
; TYPMON - Return to monitor/EXEC mode and don't allow a continue
; TYPXIT - Return to SCAN (to process /RUN switch) else return to
;	   monitor/EXEC mode and don't allow a continue
; Call:	PUSHJ	P,TYPCON/TYPMON/TYPXIT
; Uses:	T1-4

IFE <TF%SCN-TF%ON>,<
TYPCON:	PJRST	.MONRT##		; Do a monitor return

TYPXIT:	PUSHJ	P,.RUNCM##		; Process /RUN or /EXIT
	JUMPN	T1,TYPMO1		; Don't allow a continue

TYPMON:	PUSHJ	P,.MONRT##		; Do a monitor return
IFE <TF%MON-TF%T10>,<
TYPMO1:	EXIT				; Don't allow a continue >
IFE <TF%MON-TF%T20>,<
TYPMO1:	MOVX	T1,.FHSLF		; Close all
	CLZFF%				;  the files
TYPMO2:	HALTF%				; Return on EXEC level
	JRST	TYPMO2			; Don't allow a continue >>

IFE <TF%SCN-TF%OFF>,<
IFE <TF%MON-TF%T10>,<
TYPCON:	MONRT.				; Monitor return
	POPJ	P,			; Return

TYPMON:	MONRT.				; Do a monitor return

TYPXIT:	EXIT				; Don't allow a continue >
IFE <TF%MON-TF%T20>,<
TYPCON:	HALTF%				; Return to EXEC mode
	POPJ	P,			; Return

TYPXIT:	HALTF%				; Return to EXEC mode

TYPMON:	MOVX	T1,.FHSLF		; Close all
	CLZFF%				;  the files
TYPMO1:	HALTF%				; Return to EXEC mode
	JRST	TYPMO1			; Don't allow a continue >>
	$TOC	.TYPES -- The End


	$PRGEND				; End of '.TYPES'	$TOC	.TYPER -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TYPER

	$INIT	.TYPER - $TYPE Macro Support Module,.TYPER,\'TF%COD


; Force the low segment to be loaded

	EXTERN	.TDATA			; Request the TYPER low segment
	$TOC	.TYPER -- The $TYPER Macro Support Module


; .TYPER - The routine to process the $TYPE macro calls
; Call:		MOVX	T1,{the data to be output}
;	$$$sfx:	PUSHJ	P,@[msg!hdr+.TYPER
;			    sub!xtr!bas!lst!trl!enc!ret!'sfx'
;			    bsa,,loc		; Optional word
;			    ptr			; Optional word
;			    ASCIZ ~txt~]
; Uses:	No ACs

.TYPER::$VARIA	(ENTRY,<TYPDUM,TYPBAS,TYPWID,TYPXCT>,TYPCAL,TYPBLK)

	MOVX	P2,<POINT 7>		; Get an ASCII byte pointer
	HRRI	P2,TR.TXT(P1)		; Get the address of the text

	MOVE	T1,TR.BAS(P1)		; Get some flags
	TXNE	T1,TR%BAS		; Skip if database wasn't given
	JRST	[HLRZ  T1,TR.BSA(P1)	 ; Get the database address
		 CAXN  T1,.TREDB	 ; Skip if error database isn't wanted
		 MOVEI T1,.TYEDB##	 ; Get pointer to error database
		 CAXN  T1,.TRTDB	 ; Skip if TYPER database isn't wanted
		 MOVEI T1,.TYTDB##	 ; Get pointer to TYPER database
		 EXCH  T1,.TYBSA##	 ; Swap the database addresses
		 HRROM T1,TYPBAS	 ; Save for later
		 JRST  TYPE01]		 ; Go skip the database/location
	SETZM	TYPBAS			; The database wasn't given
	TXNE	T1,TR%XTR		; Skip if output/location isn't used
TYPE01:	ADDX	P2,^O1			; Adjust the pointer to the text

	SKIPN	TB,.TYBSA##		; Skip if user specified a database
	MOVEI	TB,.TYDDB##		; Use the default database

	LDB	T2,[$POINT TR.MSG(P1),TR%MSG]  ; Get the message level
	CAXN	T2,.TRDEF		; Skip if the default is wanted
	JRST	TYPE02			; Go get the current message level
	MOVEM	T2,TB.MDF(TB)		; Save the message level
	TLOA	TB,(T2)			; Save it away for later
TYPE02:	HRL	TB,TB.MDF(TB)		; Get the default message level
	CAMGE	TB,TB.MML(TB)		; Skip if the message should be output
	JRST	[TXNE T1,TR%TRL		 ; Skip if a trailer isn't wanted
		 JRST TYPE25		 ; Go reset the message level and return
		 JRST TYPE26]		 ; Go return

	LDB	T3,[$POINT TR.HDR(P1),TR%HDR]  ; Get the header code
	SKIPL	T3,TYPHDR(T3)		; Is the verbosity level is needed?
	PUSHJ	P,.TVRBO##		; Yes, get the verbosity level
	JRST	(T3)			; Go send the output
TYPE03:	TXNE	T4,%TFWCN		; Skip if the continuation isn't wanted
	JRST	TYPE11			; Skip some code
	MOVX	T1,%TBSUP!%TBCON	; Set the continuation
	ORM	T1,TB.FLG(TB)		;  and suppress flags
	JRST	TYPE23			; Go process the trailer

TYPE04:	MOVX	T1,%TBINF		; Get the information flag
	ORM	T1,TB.FLG(TB)		; Inform the world
	JRST	TYPE07			; Go output the message prefix

TYPE05:	MOVX	T1,%TBSUP		; Get the suppress flag
	TDNE	T1,TB.FLG(TB)		; Skip if the message is wanted
	JRST	TYPE23			; Go process the trailer
	JRST	TYPE11			; Go type the rest of the message
TYPE06:	SKIPGE	TB.CHR(TB)		; Skip if terminal output
	JRST	TYPE07			; Skip some code
	MOVX	T1,%TBERR		; Get the error flag
	TDNE	T1,TB.FLG(TB)		; Skip if .JBERR shouldn't be updated
	AOS	.JBERR##		; Increment .JBERR for this message
IFE <TF%SCN-TF%ON>,<
	SKIPE	.FLCBF##		; Skip if ^O was already cleared
	JRST	TYPE07			; Don't clear the ^O
	SETOM	.FLCBF##		; Inform SCAN >
IFE <TF%MON-TF%T10>,<
	SKPINL				; Clear ^O
	 JFCL				; Nothing typed yet >
IFE <TF%MON-TF%T20>,<
	MOVX	T1,.PRIOU		; Clear ^O
	RFMOD%				;  on the
	TXZE	T2,TT%OSP		;  primary
	SFMOD%				;  output
IFE <TF%SCN-TF%OFF>,<
	MOVX	T1,.PRIIN		; Clear the primary
	CFIBF%				;  input buffer >>
TYPE07:	HLRZ	T1,T3			; Get the header
	ANDX	T1,^O177B35		;  character
	PUSHJ	P,.TCHAR##		; Output the header character
	TXNN	T4,%TFWPR		; Skip if the prefix is wanted
	JRST	TYPE08			; Go type the address then
	HRLZ	T1,TR.SFX(P1)		; Get the message abbreviation
	PUSHJ	P,.TPFXN##		; Type the abbreviations

TYPE08:	TXNN	T4,%TFWAD		; Skip if the address is wanted
	JRST	TYPE09			; Go type the message then
	PUSHJ	P,.TLPAR##		; Output the (
	MOVX	T1,.TFCUR		; Output the PC
	PUSHJ	P,.TOPC			;  of the call
	PUSHJ	P,.TRPAR##		; Output the )

TYPE09:	TXNN	T4,%TFWFL		; Skip if the first line is wanted
	JRST	[MOVX T1,%TBSUP		 ; Suppress the rest
		 ORM  T1,TB.FLG(TB)	 ;  of this message
		 JRST TYPE23]		 ; Go process the trailer
	TXNE	T4,%TFWPR!%TFWAD	; Was the prefix or address output?
	PUSHJ	P,.TSPAC##		; Yes, type a space
	PFALL	TYPE11			; Fall into main routine
TYPE11:	MOVE	T2,TR.LST(P1)		; Get the substitutions specified flags
	LDB	T1,[$POINT TR.SUB(P1),TR%SUB]  ; Get the substitution code
	CAIN	T1,<<$IND>_-TR$SUB>	; Skip if not indirect
	JRST	TYPE12			; Go handle the indirect case
	HRROI	P3,TYPDUM		; Make a fake indirect pointer
	LSH	T1,TR$SUB		; Align the substitution type
	TXNE	T2,TR%LST		; Skip if the address wasn't specified
	TDOA	T1,(P2)			; Set the pointer ($TYPE)
	HRRI	T1,T1			; Set the pointer (T1)
	MOVEM	T1,TYPDUM		; Save for later
	JRST	TYPE13			; Go to work
TYPE12:	TXNE	T2,TR%LST		; Skip if the pointer wasn't specified
	SKIPA	P3,(P2)			; Get the indirect pointer ($TYPE)
	MOVE	P3,TYPBLK+T1-^O1	; Get the indirect pointer (T1)
TYPE13:	TXNE	T2,TR%LST		; Skip if substitution wasn't supplied
	ADDX	P2,^D1			; Adjust the pointer to the text

	SETZM	TYPWID			; Reset the width counter
	PUSH	P,[0]			; Reset the $SUB end flag
TYPE14:	TXZE	P1,TF%TAB		; Clear the tab flag
TYPE15:	SETZM	TYPWID			; Reset the width
TYPE16:	ILDB	T1,P2			; Get the next character
	JUMPE	T1,[POP   P,P2		 ; Get the previous pointer
		    JUMPE P2,TYPE23	 ; Jump if the top level
		    JRST  TYPE16]	 ; Finish up the string
	CAXN	T1,"|"			; Skip if not time for a substitution
	JRST	TYPE18			; Go do the substitution
	CAXN	T1,.CHTAB		; Skip if not a tab
	SKIPL	T3,TB.HOR(TB)		; Skip if justification is wanted
	JRST	[PUSHJ P,.TCHAR##	 ; Go type the character
		 JRST  TYPE14]		 ; Loop until finished

	TXOE	P1,TF%TAB		; Skip if the last character was a tab
	SKIPA	T2,[CAIG  T1,^D1(T4)]	; Test for next tab stop
	MOVE	T2,[CAIGE T1,^D1(T4)]	; Test for this or next tab stop
	HRRZ	T4,TB.COL(TB)		; Get the current column count
TYPE17:	HRRZ	T1,(T3)			; Get a tab stop
	XCT	T2			; Skip if found a tab stop
	AOBJN	T3,TYPE17		; Loop until a tab stop is found
	JUMPGE	T3,[PUSHJ P,.TTABC##	 ; Go type the tab
		    JRST  TYPE15]	 ; Loop until finished
	HLRE	T2,(T3)			; Get the width
	MOVEM	T2,TYPWID		;  of the field
	SUBI	T1,^D1(T4)		; Get the number of spaces needed
	PUSHJ	P,.TMULS		; Output the fill characters
	JRST	TYPE16			; Go get the next character

TYPE18:	JUMPGE	P3,TYPE15		; Jump if no substitutions left
	MOVE	T1,(P3)			; Get the substitution info
TYPE19:	LDB	T4,[$POINT (T1,TR%SUB)]	; Get the substitution code
	CAIL	T4,TYPSIZ		; Skip if a valid substitution
	JRST	[CAML T4,.TYMAX##	 ; Skip if less than user maximum
		 JRST TYPE22		 ; Go get the next character
		 ADD  T4,.TYUSE##	 ; Add in the user base address
		 MOVE T3,(T4)		 ; Get the pointer to the output routine
		 JRST TYPE20]		 ; Keep on truck'n
	MOVE	T3,TYPSUB(T4)		; Add in the base address
TYPE20:	PUSHJ	P,.TYLOD##		; Get the parameter
	SKIPN	T4,TYPWID		; Skip if a width was specified
	JRST	TYPE21			; Skip some crude code
	TXNE	T3,WD%LFT		; Skip if no right justify option
	MOVSS	T3			; Get the right justify option
TYPE21:	PUSHJ	P,(T3)			; Go output the contents of T1
TYPE22:	AOBJP	P3,TYPE14		; Adjust the indirect pointer
	JRST	TYPE14			; Go get the next character
TYPE23:	LDB	T2,[$POINT TR.TRL(P1),TR%TRL]  ; Get the trailer code
	JUMPE	T2,TYPE26		; Jump if no trailer

	MOVX	T1,%TBCON		; Get the continuation flag
	TDOE	T1,TB.FLG(TB)		; Skip if the trailer should be output
	JRST	TYPE24			; Go clear some flags
	TXNE	T1,%TBINF		; Skip if not an information header
	PUSHJ	P,.TRBRK##		; Output the right bracket
	MOVE	T1,T2			; Output a number
	PUSHJ	P,.TLINE		;  of CR-LF's
TYPE24:	MOVX	T2,%TBINF!%TBSUP!%TBCON	; Clear the information, suppress
	ANDCAM	T2,TB.FLG(TB)		;  and continuation flags
TYPE25:	HRRZ	T1,TB.MSG(TB)		; Set the default
	MOVEM	T1,TB.MDF(TB)		;  message level

TYPE26:	SKIPE	T1,TYPBAS		; Skip if the database wasn't changed
	HRRZM	T1,.TYBSA##		; Restore the database

	LDB	T1,[$POINT TR.RET(P1),TR%RET]  ; Get the return type
	PJRST	@TYPRET(T1)		; Return
	$TOC	.TYPER -- The Various Dispatch Tables


; The substitution dispatch table

TYPSUB:	       0,,.TBAR##		; (0) $NON - Vertical bar
	       0,,.TASCI##		; (1) $ASC - ASCIZ string
	       0,,.TBITS##		; (2) $BIT - Bits
	       0,,.TBYTE##		; (3) $BYT - Bytes
	.TBBLK##,,.TBLOK##		; (4) $BLK - Block
	       0,,.TCHAR##		; (5) $CHR - Character
	       0,,.TCONT		; (6) $CON - Continuation
	.TBCRW##,,.TCORW##		; (7) $COR - Core
	       0,,.TDATX##		; (10) $DAT - Date
	       0,,.TDAYN##		; (11) $DAY - Day
	.TBDCW##,,.TDECW##		; (12) $DEC - Decimal
	       0,,.TDIRT##		; (13) $DIR - Directory name
	       0,,.TDATL##		; (14) $DTL - Date in long format
	       0,,.TELSE		; (15) $ELS - Else
	       0,,.TLOOK##		; (16) $ENT/$LKP - ENTER/LOOKUP block
	       0,,.POPJ##		; (17) $EOS - End-of-skip
	       0,,.TFERR##		; (20) $ERR - LOOKUP/ENTER error
	       0,,.TJERR##		; (21) $ERS - Error string
	       0,,.TFULN##		; (22) $FUL - Full word SIXBIT
	       0,,.TFUNN##		; (23) $FUN - 'Funny' character/string
	.TBHXW##,,.THEXW##		; (24) $HEX - Hexadecimal
	       0,,.TJFNS##		; (25) $JFN - JFNS
	       0,,.TLEFT##		; (26) $LFT - Left half SIXBIT
	       0,,.TLINE##		; (27) $LIN - New line
	       0,,.TNAME##		; (30) $NAM - Name
	.TNUMB##,,.TNUMB##		; (31) $NUM - Number
	.TBOCW##,,.TOCTW##		; (32) $OCT - Octal
	       0,,.TOPC			; (33) $OPC - PC
	       0,,.TPFXN##		; (34) $PFX - Prefix
	       0,,.TPPNW##		; (35) $PPN - PPN
	       0,,.TPROW##		; (36) $PRO - Protection
	       0,,.TDIRB##		; (37) $PTH - PATH block
	       0,,.TR50W##		; (40) $R50 - RADIX-50
	       0,,.TRUNN##		; (41) $RUN - Runtime
	       0,,.TFBLK##		; (42) $SCN - SCAN block
	       0,,.TSIXN##		; (43) $SIX - SIXBIT
	       0,,.TSKIP		; (44) $SKP - Skip output
	       0,,.TSKPT		; (45) $SKT - Skip output if TRUE
	       0,,.TMULS##		; (46) $SPC - Space(s)
	       0,,.TSUBS		; (47) $SUB - Substitution
	       0,,.TTIMX##		; (50) $TIM - Time
	       0,,.TTIML##		; (51) $TML - Time in long format
	       0,,.TDTTM##		; (52) $UNV - Universal date/time
	       0,,.TUSER##		; (53) $USR - User name
	       0,,.TVERW##		; (54) $VER - Version
	       0,,.TXCT			; (55) $XCT - Execute a substitution type
	.TBXWW##,,.TXWDW##		; (56) $XWD - Octal half words
TYPSIZ==.-TYPSUB			; Length of substitution table
; The header dispatch table

TYPHDR:	TF%VER+.CHNUL,,TYPE05		; (0) Nothing
	       .CHNUL,,TYPE03		; (1) Continuation
	          "?",,TYPE06		; (2) Fatal
	TF%INF+.CHLSB,,TYPE04		; (3) Information
	         """",,TYPE07		; (4) Message
	          "$",,TYPE07		; (5) Operator
	TF%VER+.CHNUL,,TYPE05		; (6) Special
	          "%",,TYPE07		; (7) Warning


; The return dispatch table

TYPRET:	TYPABT				; (0) Abort
	TYPCON				; (1) Continue
	TYPDDT				; (2) DDT
	TYPXIT				; (3) Exit
	TYPINT				; (4) Interrupt
	TYPJMP				; (5) Jump
	TYPMON				; (6) Monitor
	.POPJ##				; (7) Normal
	.POPJ1##			; (10) Normal plus 1
	TYPPJ1				; (11) .POPJ1
	TYPPJ0				; (12) .POPJ
	TYPSCN				; (13) SCAN
	$TOC	.TYPER -- The Return Type Support Modules


; TYPABT - Type an aborting message and enter DDT
; Call:	PUSHJ	P,TYPABT		; Type the message and enter DDT
; Uses:	T1

TYPABT:	$TYPE	(F,ABT,$OPC,<Program aborting, PC:|>,,,E,<[.TFPRE]>)
	PFALL	TYPDDT			; Fall into TYPDDT


; TYPDDT - Return from TYPER to DDT
; Call:	PUSHJ	P,TYPDDT		; Puts DDT's start address on the stack
; Uses:	T1-2

TYPDDT:
IFE <TF%MON-TF%T10>,<
	SKIPN	T1,.JBDDT##		; Skip if DDT is loaded
	JRST	TYPMON			; Return to monitor mode >
IFE <TF%MON-TF%T20>,<
	MOVE	 T1,[.FHSLF,,^O770]	; Get the DDT page
	RPACS%				;  characterists
	 ERJMP	TYPMON			; Assume no DDT
	TXNN	T2,PA%PEX		; Skip if the page exists
	JRST	TYPMON			; Return to EXEC mode
	MOVX	T1,^O770000		; Get the DDT address >
	EXCH	T1,TYPCAL		; Return to DDT
	MOVEM	T1,.JBOPC##		; Save the original return address
	$TYPE	(I,DDT,$NON,<Entering DDT>,,P,T)
; TYPJMP - Return from TYPER to a given location
; Call:	MOVX	P1,{the address of the TYPER argument block}
;	PUSHJ	P,TYPJMP		; Puts location on the stack
; Uses:	T1

TYPJMP:	SKIPA	T1,TR.LOC(P1)		; Get the return location


; TYPPJ0 and TYPPJ1 - Return from TYPER via .POPJ or .POPJ1
; Call:	MOVX	T1,.TRPJ0		; Give a .POPJ
;    or	MOVX	T1,.TRPJ1		; Give a .POPJ1
;	PUSHJ	P,TYPPJ0/TYPPJ1		; Puts correct return on the stack
; Uses:	T1

TYPPJ0:
TYPPJ1:	MOVEI	T1,.POPJ1##-.TRPJ1(T1)	; POPJ returns
TYPPJ2:	HRRM	T1,TYPCAL		; Mung the return address
	POPJ	P,			; Return


; TYPINT - Return from TYPER via a DEBRK. or DEBRK%
; Call:	PUSHJ	P,TYPINT		; Return from interrupt
; Uses:	T1

TYPINT:
IFE <TF%MON-TF%T10>,<
	MOVEI	T1,[DEBRK.		 ; Return from interrupt
		     $ERROR (F,DIU,$NON,<DEBRK. is unimplemented>,,D,T)
		     $ERROR (F,NIP,$NON,<No interrupt in progress>,,D,T)] >
IFE <TF%MON-TF%T20>,<
	MOVEI	T1,[DEBRK%		 ; Return from interrupt
		     $ERROR (F,NIP,$NON,<No interrupt in progress>,,D,T)] >
	JRST	TYPPJ2			; Go return


; TYPSCN - Return from TYPER to SCAN (SCAN only)
; Call:	PUSHJ	P,TYPSCN
; Uses:	T1-4

IFE <TF%SCN-TF%ON>,<
TYPSCN:	MOVEI	T1,.FMSGE##		; Return to SCAN
	JRST	TYPPJ2			; Go store the location >
IFE <TF%SCN-TF%OFF>,<
TYPSCN:	$TYPE	(F,SRS,$OPC,<SCAN return and not using SCAN, PC:|>,,D,T,<[.TFPRE]>) >
; TYPCON - Return to monitor/EXEC mode and allow a continue
; TYPMON - Return to monitor/EXEC mode and don't allow a continue
; TYPXIT - Return to SCAN (to process /RUN switch) else return to
;	   monitor/EXEC mode and don't allow a continue
; Call:	PUSHJ	P,TYPCON/TYPMON/TYPXIT
; Uses:	T1-4

IFE <TF%SCN-TF%ON>,<
TYPCON:	PJRST	.MONRT##		; Do a monitor return

TYPXIT:	PUSHJ	P,.RUNCM##		; Process /RUN or /EXIT
	JUMPN	T1,TYPMO1		; Don't allow a continue

TYPMON:	PUSHJ	P,.MONRT##		; Do a monitor return
IFE <TF%MON-TF%T10>,<
TYPMO1:	EXIT				; Don't allow a continue >
IFE <TF%MON-TF%T20>,<
TYPMO1:	MOVX	T1,.FHSLF		; Close all
	CLZFF%				;  the files
TYPMO2:	HALTF%				; Return on EXEC level
	JRST	TYPMO2			; Don't allow a continue >>

IFE <TF%SCN-TF%OFF>,<
IFE <TF%MON-TF%T10>,<
TYPCON:	MONRT.				; Monitor return
	POPJ	P,			; Return

TYPMON:	MONRT.				; Do a monitor return

TYPXIT:	EXIT				; Don't allow a continue >
IFE <TF%MON-TF%T20>,<
TYPCON:	HALTF%				; Return to EXEC mode
	POPJ	P,			; Return

TYPXIT:	HALTF%				; Return to EXEC mode

TYPMON:	MOVX	T1,.FHSLF		; Close all
	CLZFF%				;  the files
TYPMO1:	HALTF%				; Return to EXEC mode
	JRST	TYPMO1			; Don't allow a continue >>
	$TOC	.TYPER -- .TSKPT - $SKT Substitution Module


; .TSKPT - Skip output if TRUE (non-zero)
; Call:	MOVX	T1,{the value to be test for TRUE}
;					; If the contents of T1 is FALSE (zero)
;					;  the output will be generated.  If
;					;  the contents of T1 is TRUE (non-
;					;  zero) the output will be suppressed
;					;  (skipped), until the next $ELS or
;					;  matching $EOS.
;	PUSHJ	P,.TSKPT		; Suppress if TRUE
;	 * Return *
; Uses:	T1-4 and P2-3
; Note: Can't be directly called by the user

.TSKPT:	JUMPN	T1,.TELSE		; Suppress the output if TRUE
	POPJ	P,			; Don't suppress the output
	$TOC	.TYPER -- .TSKIP - $SKP Substitution Module


; .TSKIP - See if the output should be skipped
; Call:	MOVX	T1,{the instruction to be XCT'ed}
;					; If the instruction doesn't skip the
;					;  output will be generated.  If the
;					;  instruction skips the output will
;					;  be suppressed up to the matching
;					;  $ELS or $EOS.
;	PUSHJ	P,.TSKIP		; Suppress if needed
;	 * Return *
; Uses:	T1-4 and P2-3
; Note: Can't be directly called by the user

.TSKIP:	MOVEM	T1,TYPXCT		; Save the instruction to be exectuted
	MOVSI	T4,TYPBLK+T1-^O1	; Restore
	HRRI	T4,T1			;  registers
	BLT	T4,T4			;  T1-T4
	XCT	TYPXCT			; See if the output should be suppressed
	 POPJ	P,			; Don't suppress the output
	PFALL	.TELSE			; Fall into .TELSE
	$TOC	.TYPER -- .TELSE - $ELS Substitution Module


; .TELSE - Skip some output
; Call:	PUSHJ	P,.TELSE
;	 * Return *
; Uses:	T1-4 and P2-3
; Note: Can't be directly called by the user

.TELSE:	SETZ	T4,			; Clear the skip counter
	POP	P,T3			; Get the return address

TELSE1:	ILDB	T1,P2			; Get the next bype
	JUMPE	T1,[POP   P,P2		 ; Get the previous pointer
		    JUMPE P2,TYPE23	 ; Jump if the top level
		    JRST  TELSE1]	 ; Finish up the string
	CAXE	T1,"|"			; Skip if the substitution character
	JRST	TELSE1			; Go get the next character

TELSE2:	JUMPGE	P3,TELSE1		; Jump if out of
	AOBJP	P3,TELSE1		;  substitutions
	MOVE	T1,(P3)			; Get the substitution word
TELSE3:	LDB	T2,[$POINT T1,TR%SUB]	; Get the substitution type
	CAIN	T2,<<$ELS>_-TR$SUB>	; Skip if not an $ELS substitution
	JUMPE	T4,(T3)			; Jump if no longer skipping
	CAIN	T2,<<$EOS>_-TR$SUB>	; Skip if not an $EOS substitution
	JRST	[TXNN  T1,IC%ADR	 ; Was the address supplied?
		 SKIPA T1,[^O1]		 ; No, assume one $EOS
		 PUSHJ P,.TYLOD##	 ; Get the number of $EOS's
		 SUB   T4,T1		 ; Account for the $EOS's
		 JUMPL T4,(T3)		 ; Jump if no longer skipping output
		 JRST  TELSE1]		 ; Keep on trying
	CAIN	T2,<<$SKP>_-TR$SUB>	; Skip if not a $SKP substitution
	AOJA	T4,TELSE1		; Account for the skip
	CAIE	T2,<<$XCT>_-TR$SUB>	; Skip if a $XCT substitution
	JRST	TELSE1			; Go try the next character
	PUSHJ	P,.TYLOD##		; Try the indirect
	JRST	TELSE3			;  substitution word
	$TOC	.TYPER -- .TSUBS - $SUB Substitution Module


; .TSUBS - Change the substitution string
; Call:	MOVX	T1,{the address of the string}
;	PUSHJ	P,.TSUBS
;	 * Return *
; Uses:	T1-3 and P2
; Note:	Can't be directly called by the user

.TSUBS:	PUSHJ	P,.TPNTR##		; Get the byte pointer to string
	EXCH	P2,(P)			; Save the old value
	EXCH	P2,T1			; Get the pointer to the string
	JRST	(T1)			; Return
	$TOC	.TYPER -- .TXCT - $XCT Substitution Module


; .TXCT - Execute an indirect subsutitution
; Call:	MOVX	T1,{the address of the indirect substitution}
;	PUSHJ	P,.TXCT
;	 * Returns to location TYPE19 *
; Uses:	No ACs
; Note:	Can't be directly called by the user

.TXCT:
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	ADJSP	P,-^O1			; Dump the return address >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	POP	P,(P)			; Dump the return address >
	JRST	TYPE19			; Go do the indirect substitution in T1
	$TOC	.TYPER -- .TOPC - $OPC Substitution Module


; .TOPC - Output a PC
; Call:	MOVX	T1,{the PC to be output}
;    or	MOVX	T1,.TFCUR		; Output the PC of call
;    or	MOVX	T1,.TFPRE		; Output the PC of previous call
;	PUSHJ	P,.TOPC
;	 * Return *
; Uses:	T1-3
; Note: Can't be directly called by the user

.TOPC:	PUSHJ	P,.SAV4T##		; Save T4, temporary
	CAXN	T1,.TFCUR		; Is the current call wanted?
	JRST	TOPC1			; Yes, go get the address then
	CAXE	T1,.TFPRE		; The previous caller's PC?
	JRST	TOPC2			; No, output the contents of T1 then
	PUSHJ	P,.SAVEP##		; Backup one frame
TOPC1:	HRRZ	T1,TYPCAL		; Get the calling
	MOVEI	T1,-^O1(T1)		;  address
TOPC2:	TXZ	T1,WD%LFT		; Make sure only the right half
	MOVX	T2,"0"			; Set the filler character
	MOVX	T4,^D6			; Get the width
	PJRST	.TFOCW##		; Output the PC
	$TOC	.TYPER -- .TCONT - $CON Substitution Module


; .TCONT - Start of continuation message, if continuation messages aren't
;          wanted suppress output
; Call:	PUSHJ	P,.TCONT
;	 * Returns here if continuation messages are wanted *
; Uses:	T1, T4 and P2

.TCONT:	PUSHJ	P,.TVRBO##		; Get the verbosity level
	TXNE	T4,%TFWCN		; Are continuation messages wanted?
	POPJ	P,			; Yes, output it

IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	ADJSP	P,-^O1			; Flush the return address >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	POP	P,(P)			; Flush the return address >

TCONT1:	POP	P,P2			; Get the upper level string pointer
	JUMPN	P2,TCONT1		; Jump if at top level

	MOVX	T1,%TBSUP		; Suppress output up
	ORM	T1,TB.FLG(TB)		;  to the trailer
	JRST	TYPE23			; Output the trailer
	$TOC	.TYPER -- The End


	$PRGEND				; End of '.TYPER'	$TOC	.TSUPT -- Initialization  15-May-83  /RWS


; Search some universal files

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TSUPT

	$INIT	.TSUPT - The Support Modules for .TYPER,.TCHAR,\'TF%COD


; Force the low segment to be loaded

	EXTERN	.TDATA			; Request the TYPER low segment
	EXTERN	.TYBAS			; Request the $TYPES support
	$TOC	.TSUPT -- Error Message Table


; Table of LOOKUP/ENTER error messages

IFE <TF%MON-TF%T10>,<
TYPFET:	ERFNF%,,[ASCIZ ~Non-existent file~]
	ERIPP%,,[ASCIZ ~Non-existent UFD~]
	ERPRT%,,[ASCIZ ~Protection failure~]
	ERFBM%,,[ASCIZ ~File being modified~]
	ERAEF%,,[ASCIZ ~Already existing file~]
	ERISU%,,[ASCIZ ~Illegal sequence of UUOs~]
	ERTRN%,,[ASCIZ ~RIB or directory read error~]
	ERNSF%,,[ASCIZ ~Not a save file~]
	ERNEC%,,[ASCIZ ~Not enough core~]
	ERDNA%,,[ASCIZ ~Device not available~]
	ERNSD%,,[ASCIZ ~No such device~]
	ERILU%,,[ASCIZ ~Illegal monitor UUO~]
	ERNRM%,,[ASCIZ ~No room or quota exceeded~]
	ERWLK%,,[ASCIZ ~Write locked~]
	ERNET%,,[ASCIZ ~Not enough table space in monitor~]
	ERPOA%,,[ASCIZ ~Patial allocation~]
	ERBNF%,,[ASCIZ ~Block not free~]
	ERCSD%,,[ASCIZ ~Can't supersede directory~]
	ERDNE%,,[ASCIZ ~Can't delete non-empty directory~]
	ERSNF%,,[ASCIZ ~Non-existent SFD~]
	ERSLE%,,[ASCIZ ~Search list empty~]
	ERLVL%,,[ASCIZ ~SFD too deep~]
	ERNCE%,,[ASCIZ ~No create~]
	ERSNS%,,[ASCIZ ~Segment not on swap space~]
	ERFCU%,,[ASCIZ ~Can't update file~]
	ERLOH%,,[ASCIZ ~Low segment overlaps high segment~]
	ERNLI%,,[ASCIZ ~Not logged in~]
	ERENQ%,,[ASCIZ ~File still has outstanding locks set~]
	ERBED%,,[ASCIZ ~Bad directory in EXE file~]
	ERBEE%,,[ASCIZ ~Bad extension for EXE file~]
	ERDTB%,,[ASCIZ ~Directory too big in EXE file~]
	ERENC%,,[ASCIZ ~Network capacity exceeded~]
	ERTNA%,,[ASCIZ ~Task not available~]
	ERUNN%,,[ASCIZ ~Undefined network node~]
	ERSIU%,,[ASCIZ ~SFD is in use~]
	ERNDR%,,[ASCIZ ~File has an NDR lock~]
	ERJCH%,,[ASCIZ ~Too many file readers~]
	ERSSL%,,[ASCIZ ~Can't rename SFD to a lower level~]
TYPLEN==.-TYPFET-^O1			; The size of the file error table >
; Table of the months of the year

TYPMTH:	[ASCIZ ~January~]		; (0)
	[ASCIZ ~February~]		; (1)
	[ASCIZ ~March~]			; (2)
	[ASCIZ ~April~]			; (3)
	[ASCIZ ~May~]			; (4)
	[ASCIZ ~June~]			; (5)
	[ASCIZ ~July~]			; (6)
	[ASCIZ ~August~]		; (7)
	[ASCIZ ~September~]		; (10)
	[ASCIZ ~October~]		; (11)
	[ASCIZ ~November~]		; (12)
	[ASCIZ ~December~]		; (13)


; Table of the days of the week

TYPDAY:	[ASCIZ ~Wednesday~]		; (0)
	[ASCIZ ~Thursday~]		; (1)
	[ASCIZ ~Friday~]		; (2)
	[ASCIZ ~Saturday~]		; (3)
	[ASCIZ ~Sunday~]		; (4)
	[ASCIZ ~Monday~]		; (5)
	[ASCIZ ~Tuesday~]		; (6)


; Table of runtime factors (milliseconds/jiffies)

TYPHOR:	^D<60*60*1000>			; Hours
	^D<60*60*60>

TYPMNT:	^D<60*1000>			; Minutes
	^D<60*60>

TYPSEC:	^D<1000>			; Seconds
	^D<60>

TYPMUL:	^D<10>				; One digit
	^D<100>				; Two digits
	^D<1000>			; Three digits


; Table of time zones

TYPTZT:	'ADT',,'AST'			; (4) Atlantic time zone
	'EDT',,'EST'			; (5) Eastern time zone
	'CDT',,'CST'			; (6) Central time zone
	'MDT',,'MST'			; (7) Mountain time zone
	'PDT',,'PST'			; (10) Pacific time zone
	'YDT',,'YST'			; (11) Yukon time zone
	'HDT',,'HST'			; (12) Hawaii time zone
	'BDT',,'BST'			; (13) Bering time zone
; Table of SCAN's funny characters

FUNTBL:
IFE <TF%SCN-TF%ON>,<
	'EOF',,.CHEOF			; (-2) End-of-File
	'EOL',,.CHEOL			; (-1) End-of-Line
	'ALT',,.CHALX			; (0) Altmode >
	'BEL',,.CHBEL			; (7) Bell
	'TAB',,.CHTAB			; (11) Tab
	'LF ',,.CHLFD			; (12) Line-feed
	'VT ',,.CHVTB			; (13) Vertical tab
	'FF ',,.CHFFD			; (14) Form-feed
	'CR ',,.CHCRT			; (15) Carriage-return
	'ESC',,.CHESC			; (33) Escape
FUNLEN==.-FUNTBL


; Table of known Guide words

IFE <TF%SCN-TF%ON>,<
GUIDT.::'AND   '			; (4000) And
	'OR    '			; (4001) Or
	'NOT   '			; (4002) Not
	'TO    '			; (4003) To
	'FROM  '			; (4004) From
	'INPUT '			; (4005) Input
	'OUTPUT'			; (4006) Output
	'SOURCE'			; (4007) Source
	'LIST  '			; (4010) List
	'OBJECT'			; (4011) Object
GUIDL.==:.-GUIDT.
GUIDM.==:-GUIDL. >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TPNTR


; .TPNTR - Calculate an effective address and add the byte pointer
; Call:	MOVX	T1,{a byte pointer}
;    or	HRRZI	T1,{an address}		; TOPS-10 style
;    or	HRROI	T1,{an address}		; TOPS-20 style
;	PUSHJ	P,.TPNTR
;	 * Return *
; Uses:	T1-3

.TPNTR::HLLZ	T3,T1			; Get the byte pointer info
	CAXE	T3,WD%LFT		; Skip if default TOPS-20 ASCIZ pointer
	JRST	TPNTR1			; Get the address then
	TXZ	T1,%BPIND!%BPIDX	; Clear some extraneous bits
	MOVX	T3,<POINT 7>		; Convert to an ASCIZ pointer
TPNTR1:	PUSHJ	P,.LOCAT##		; Calculate the effective address
	TXZ	T3,%BPIND!%BPIDX	; Clear some extraneous bits
	TXNN	T3,BP%POS!BP%SIZ	; Skip if byte pointer was specified
	TXOA	T1,<POINT 7>		; Make the default pointer
	HLL	T1,T3			; Get the supplied byte pointer
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TASCI


; .TASCI - Type an ASCIZ string
; Call:	MOVX	T1,{the byte pointer of an ASCIZ string}
;    or	HRRZI	T1,{the address of an ASCIZ string}  ; TOPS-10 standard
;    or	HRROI	T1,{the address of an ASCIZ string}  ; TOPS-20 standard
;    or	MOVEI	T1,{the external ASCIZ string number}
;	TXO	T1,TF%EXT		; Set the external ASCIZ string flag
; Uses: T1-3

.TASCI::HLLZ	T2,T1			; Get the byte pointer field
	CAXN	T2,TF%EXT		; Pointer to an external ASCIZ string?
	PJRST	.TEXTS			; Yes, go process it then
	PUSHJ	P,.TPNTR		; Get the byte pointer
	SKIPA	T2,T1			; Find a save pointer in a safe place
TASCI1:	PUSHJ	P,.TCHAR		; Type the character
	ILDB	T1,T2			; Get the next character
	JUMPN	T1,TASCI1		; Is it a null?
	POPJ	P,			; No, return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TEXTS


; .TEXTS - Output an external ASCIZ string
; Call:	MOVX	T1,{the external ASCIZ string number}
;	PUSHJ	P,.TEXTS
;	 * Return *
; Uses:	T1-4

.TEXTS::PUSHJ	P,.SAVE1##		; Save P1

IFE <TF%MON-TF%T10>,<
	$VARIA	(GLOBAL,<TYPCOD,TYPBLK,<TYPLST,^O2>,<TYPBUF,TF%EBS>>)
	HRLZI	T2,-TF%EBS		; Set up
	HRRI	T2,TYPBUF-^O1		;  the dump
	MOVEM	T2,TYPLST		;  mode I/O
	SETZM	TYPLST+^O1		;  list >
IFE <TF%MON-TF%T20>,<
	$VARIA	(GLOBAL,<TYPCOD,TYPBLK,<TYPBUF,TF%EBS>>) >

	TXZ	T1,WD%LFT		; Clear some junk and save
	MOVEM	T1,TYPCOD		;  for external string number
	PUSHJ	P,.TYFND##		; See which file the string is in
TEXTS1:	 $TYPE	(N,,$OCT,<No string available for code (|)>,N,P,,TYPCOD)
	MOVE	P1,.TYCHN##(T2)		; Get the channel/JFN of the file

	MOVX	T1,ES.SIZ		; Avoid the preamble in
	MOVEM	T1,TYPBLK		;  the external string file

		     $CONTINUE		; Continued on the next page
; Here to search for the external string in the file

TEXTS2:	PUSHJ	P,TEXT10		; Get some string numbers to test
TEXTS3:	HRRZ	T1,(T3)			; Get an string number
	CAME	T1,TYPCOD		; Do they match?
	CAXN	T1,.TFEND		; No, is this the default external string?
	JRST	TEXTS5			; Yes, output the string
TEXTS4:	AOBJN	T3,TEXTS3		; Finished with this buffer?
	JRST	TEXTS2			; Yes, get the next buffer

TEXTS5:	HLRZ	T2,(T3)			; Is there the string available?
	JUMPE	T2,[CAXE T1,.TFEND	 ; No, end of string number?
		    JRST TEXTS4		 ; No, find the default message
		    JRST TEXTS1]	 ; Use old stand by message
	MOVEM	T2,TYPBLK		; Save the string address

; Here to output the external string

TEXTS6:	PUSHJ	P,TEXT10		; Get a buffer
TEXTS7:	MOVX	T2,<POINT 7,(T3)>	; Get a pointer to the text string
TEXTS8:	ILDB	T1,T2			; Get a character of the string
	JUMPE	T1,.POPJ##		; Was it a null?
	PUSHJ	P,.TCHAR		; No, output the character
	TXNE	T2,<$INSVL(^O76,BP%POS)>; End of word yet?
	JRST	TEXTS8			; No, get the next character
	AOBJN	T3,TEXTS7		; End of buffer yet?
	JRST	TEXTS6			; Yes, go get the next buffer

		     $CONTINUE		; Continued on the next page
; Here to get the next buffer of text

IFE <TF%MON-TF%T10>,<
TEXT10:	MOVE	T2,P1			; Do USETI to
	HRRI	T2,.FOUSI		;  the desired
	MOVE	T3,TYPBLK		;  block within
	IDIVX	T3,TF%EBS		;  within the
	ADDX	T3,^O1			;  external
	MOVE	T1,[^O2,,T2]		;  string
	FILOP.	T1,			;  file
	 $TYPE	(F,EES,$NON,<Error encountered while processing an external string>,,A,E)

	HRRI	T2,.FOINP		; Can I
	MOVEI	T3,TYPLST		;  read the
	MOVE	T1,[^O2,,T2]		;  block of
	FILOP.	T1,			;  data?
	 $TYPE	(N,EES)			; No, inform the user

	PUSHJ	P,TEXT11		; Set/update some counters

	JUMPE	T4,.POPJ		; Any adjustment with the block needed?
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	ADJSP	T3,(T4)			; Yes, do the adjustment >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	HRL	T4,T4			; Yes, account for
	ADD	T3,T4			;  the adjustment >

	MOVNI	T4,(T4)			; Do the adjustment
	ADDM	T4,TYPBLK		; only on this block
	POPJ	P,			; Return >

IFE <TF%MON-TF%T20>,<
TEXT10:	MOVE	T1,P1			; Get the JFN in the correct place
	MOVE	T2,TYPBLK		; Set the file pointer
	SFPTR%				;  to the correct word
	 $TYPE	(F,EES,$ERS,<Error encountered while processing external string (|)>,,A,E,[0])
	MOVEI	T2,TYPBUF		; Read some
	TXO	T2,<POINT 36>		;  text from
	MOVX	T3,-TF%EBS		;  the string
	SIN%				;  file
	 ERJMP	[MOVX   T1,.FHSLF	 ; Get the
		 GETER%			 ;  last error
		 TXZ    T2,WD%LFT	 ; Clear some junk
		 CAXN   T2,IOX4		 ; End of file?
		 CAXN   T3,-TF%EBS	 ; Yes, any data read?
		 $TYPE	(N,EES)		 ; Output an error message
		 JRST   TEXT11]		 ; Yes, go to work
	PFALL	TEXT11			; Set up the buffer pointer >

			     $CONTINUE	; Continued on the next page
; Here to set up the buffer pointer

TEXT11:	MOVX	T3,TF%EBS		; Update the
	ADDM	T3,TYPBLK		;  file pointer
	HRRZI	T3,TYPBUF		; Make a pointer to
	HRLI	T3,-TF%EBS		;  the data/string
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TFUNN


; .TFUNN - Type ASCIZ string with 'Funny' character replacement
; Call:	MOVX	T1,{the address of the ASCIZ string}
;	TXO	T1,B0			; For ASCIZ string
;    or	MOVX	T1,{the byte pointer to the ASCIZ string}
;    or	MOVX	T1,{a single character}
;	PUSHJ	P,.TFUNN
;	 * Return *
; Uses:	T1-3

.TFUNN::HLRZ	T3,T1			; Get the left half
	CAXE	T3,^O0			; Skip if a 'Funny' character
	CAXN	T3,^O777777		; Skip if a 'Funny' string
	JRST	.TFCHR			; Output the single 'Funny' character
	TXNN	T1,^O3777B11		; Skip if byte pointer
	TXZ	T1,B0			; Clear the address flag
	PUSHJ	P,.TPNTR		; Calculate the byte pointer
	SKIPA	T3,T1			; Find a safer place

TFUNN1:	PUSHJ	P,.TFCHR		; Type the character
	ILDB	T1,T3			; Get a character
	JUMPN	T1,TFUNN1		; Loop if not finished
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TTIML


; .TTIML - Type the time as 'hh:mm a.m./p.m. (xST/xDT)'
; Call:	MOVX	T1,{the universal date/time}
;    or	MOVX	T1,{the time in milliseconds}
;    or	MOVX	T1,.TFCUR		; Output the current time
;	PUSHJ	P,.TTIML
;	 * Return *
; Uses:	T1-4

.TTIML::CAXN	T1,.TFCUR		; Is the current time wanted?
IFE <TF%MON-TF%T10>,<
	MSTIME	T1,			; Yes, get the current time >
IFE <TF%MON-TF%T20>,<
	PUSHJ	P,.GTNOW##		; Yes, get the current date/time >
	TXNE	T1,B0!B1!B2		; Skip if already in milliseconds
	PUSHJ	P,.CNTDT##		; Convert to milliseconds

	IDIV	T1,TYPHOR		; Get hours
	IDIV	T2,TYPMNT		; Get the mintues
	HRRZ	T4,T2			; Save the minutes
	IDIVX	T1,^D12			; Get years and months
	HRL	T4,T1			; Set the AM/PM flag
	SKIPN	T1,T2			; Skip if non-zero hours
	MOVX	T1,^D12			; Make it 12
	PUSHJ	P,.TDECW		; Type the hours
	PUSHJ	P,.TCOLN		; Type a colon
	HRRZ	T1,T4			; Get the minutes
	MOVX	T2,"0"			; Get the fill character
	PUSHJ	P,.TDEC2		; Type the minutes
	MOVEI	T1,[ASCIZ ~ a.m.~]
	TXNE	T4,B17			; Skip if AM
	MOVEI	T1,[ASCIZ ~ p.m.~]
	PUSHJ	P,.TASCI		; Type AM or PM
	SKIPN	T2,.TYTMZ##		; Skip if a time zone was specified
	POPJ	P,			; Return
	TXZE	T2,TF%DLS		; Skip if not daylight saving time
	SKIPA	T1,[HLLZ T1,TYPTZT-.TFAST(T2)]  ; Get 'xDT'
	MOVE	T1,[HRLZ T1,TYPTZT-.TFAST(T2)]  ; Get 'xST'
	HRRES	T2			; Account for a negative time zone
	CAXL	T2,.TFAST		; Skip if less than Atlantic time zone
	CAXLE	T2,.TFBST		; Skip if less than Bering time zone
	POPJ	P,			; Return
	XCT	T1			; Get the correct text
	HRRI	T1,') ('		; Put some parenthesis
	ROT	T1,-^D12		;  around the time zone
	PJRST	.TSIXN			; Type the time zone
	$TOC	.TSUPT -- .TYPER Support Routines -- .TTIMX


; .TTIMX - Type the time as 'hh:mm:ss'
; Call:	MOVX	T1,{the universal date/time}
;    or	MOVX	T1,{the time in milliseconds}
;    or	MOVX	T1,.TFCUR		; Output the current time
;	PUSHJ	P,.TTIMX
;	 * Return *
; Uses:	T1-4

.TTIMX::CAXN	T1,.TFCUR		; Is the current time wanted?
	JRST	.TTIMN			; Yes, output the current time
	TXNE	T1,B0!B1!B2		; Skip if already in milliseconds
	PUSHJ	P,.CNTDT##		; Convert to milliseconds
	JRST	.TTIME			; Output the time
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDATL


; .TDATL - Type the date in long format 'Month day, year'
; Call:	MOVX	T1,{the universal date/time}
;    or	MOVX	T1,{the 15-bit date format}
;    or	MOVX	T1,.TFCUR		; Output the current date
;	PUSHJ	P,.TDATL
;	 * Return *
; Uses:	T1-4

.TDATL::CAXN	T1,.TFCUR		; Is the current date wanted?
IFE <TF%MON-TF%T10>,<
	DATE	T1,			; Yes, get the current date >
IFE <TF%MON-TF%T20>,<
	PUSHJ	P,.GTNOW##		; Yes, get the current date/time >
	TXNN	T1,WD%LFT		; Skip if universal date/time
	JRST	TDATL1			; Go output the date
	PUSHJ	P,.CNTDT##		; Convert to 15-bit format
	MOVE	T1,T2			; Get the date in the right place

TDATL1:	IDIVX	T1,^D31			; Get the days
	MOVE	T3,T2			; Save the days
	IDIVX	T1,^D12			; Get the months
	MOVE	T4,T1			; Save the years
	MOVE	T1,TYPMTH(T2)		; Get the pointer to the month
	PUSHJ	P,.TSTRG		; Type the month
	PUSHJ	P,.TSPAC		; Type a space
	MOVEI	T1,^D1(T3)		; Get the days again
	PUSHJ	P,.TDECW		; Type the days
	PUSHJ	P,.TCOMA		; Type a comma
	PUSHJ	P,.TSPAC		;  and a space
	MOVEI	T1,^D1964(T4)		; Get the year again
	PJRST	.TDECW			; Type the year
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDATX


; .TDATX - Type the date in standard format 'dd-mmm-yy'
; Call:	MOVX	T1,{the universal date/time}
;    or	MOVX	T1,{the 15-bit date format}
;    or	MOVX	T1,.TFCUR		; Output the current date
;	PUSHJ	P,.TDATX
;	 * Return *
; Uses:	T1-4

.TDATX::CAXN	T1,.TFCUR		; Is the current date wanted?
	JRST	.TDATN			; Yes, go output it
	TXNN	T1,WD%LFT		; Skip if universal date/time
	JRST	.TDATE			; Go output the date
	PUSHJ	P,.CNTDT##		; Convert to 15-bit format
	MOVE	T1,T2			; Get the date in the right place
	JRST	.TDATE			; Go output the date
	$TOC	.TSUPT -- .TYPER Support Routines -- .TNAME


; .TNAME - Type the user name with trailing blank suppression
; Call:	MOVX	T1,{the address of the user name}
;    or	MOVX	T1,.TFCUR		; Output the my current user name
;	PUSHJ	P,.TNAME
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TNAME::CAXN	T1,.TFCUR		; Is the default wanted?
	JRST	[$VARIA (LOCAL,<<TYPNAM,^O2>>) ; Yes get it
		 HRROI  T1,.GTNM1	 ; Get the 1st
		 GETTAB T1,		 ;  half of
		  MOVX	T1,'??????'	 ;  the user's
		 MOVEM  T1,TYPNAM	 ;  name
		 HRROI  T1,.GTNM2	 ; Get the 2nd
		 GETTAB T1,		 ;  half of
		  MOVX  T1,'      '	 ;  the user's
		 MOVEM  T1,TYPNAM+^O1	 ;  name
		 MOVEI	T1,TYPNAM	 ; Go output the
		 JRST   TNAME1]		 ;  user name
	PUSHJ	P,.LOCAT##		; Calculate the effective address
TNAME1:	HRLI	T1,(POINT 6)		; Make a byte pointer
	MOVE	T4,T1			; Find a safer place
	MOVX	T3,^D12			; Get the length of the user name
	SETZ	T2,			; Reset the blanks counter
TNAME2:	ILDB	T1,T4			; Get a character
	JUMPE	T1,[AOJA T2,TNAME5]	 ; Account for the blank
	JUMPE	T2,TNAME4		; Jump if no blanks skipped
	MOVX	T1," "			; Get a blank
TNAME3:	PUSHJ	P,.TCHAR		; Output a blank
	SOJG	T2,TNAME3		; Enough blanks have been output
	LDB	T1,T4			; Get the character again
TNAME4:	ADDX	T1," "-' '		; Convert to ASCII
	PUSHJ	P,.TCHAR		; Type it
TNAME5:	SOJG	T3,TNAME2		; Loop until finished
	CAXN	T2,^D12			; Skip if something was output
	PJRST	.TSPAC			; Output a space and return
	POPJ	P,			; Return >
IFE <TF%MON-TF%T20>,<
.TNAME::MOVX	T1,<SIXBIT ~NAM~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TNUMB


; .TNUMB - Type a number in several formats
; Call:	MOVX	T1,{the address to the $NUMBER parameter block}
;	PUSHJ	P,.TNUMB
;	 * Return *
; Uses:	T1-4

.TNUMB::PUSHJ	P,.SAVE4##		; Save P1-4
	MOVE	P2,T1			; Save the pointer for later
	PUSHJ	P,.TYLOD##		; Get the output format
	MOVE	P1,T1			; Save the output format
	CAXLE	T4,^O0			; Skip if was a width was specified
	DPB	T4,[$POINT P1,NM%WID]	; Store the width
	LDB	P3,[$POINT P1,NM%TYP]	; Get the output type
	LDB	P4,[$POINT P1,NM%DTP]	; Get the data type
	LDB	T4,[$POINT P1,NM%DPT]	; Get the data pointer
	MOVEI	T1,NM.ADR(P2)		; Get the address of the address word
	CAXE	T4,.NMIMD		; Skip if immediate
	MOVE	T1,(T1)			; Get the data pointer
	CAXN	T4,.NMIND		; Skip if not indirect
	PUSHJ	P,.TYLOD##		; Get the read data pointer
	PUSHJ	P,.TPNTR		; Get the real address of the data
	XCT	DATTAB(P4)		; Get the data
	CAXN	P4,.NMDBL		; Skip if not double precision
	PJRST	@NUMTAB(P3)		; Go to the output routine
	CAXN	P3,.NMFLT		; Skip if not floating point
	JRST	[MOVE  T1,T2		 ; Get the data in the correct place
		 SETZ  T2,		 ; Clear the second word
		 PJRST @NUMTAB(P3)]	 ; Go to the output routine
	CAIE	P4,.NMBYT		; Skip if byte data
	SKIPL	T2			; Skip if the argument is negative
	TDZA	T1,T1			; Set the high order to zero
	SETO	T1,			; Set the high order to ones
	PJRST	@NUMTAB(P3)		; Go to the output routine

DATTAB:	LDB	T2,T1			; (0) Get a byte
IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	DMOVE	T1,(T1)			; (1) Get two words >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
	PUSHJ	P,[MOVE T2,^O1(T1)	 ; (1A) Get
		   MOVE T1,^O0(T1)	 ; (1B)  two
		   POPJ P,]		 ; (1C)  words >
	HLRZ	T2,(T1)			; (2) Get left half
	HRRZ	T2,(T1)			; (3) Get right half
	MOVE	T2,(T1)			; (4) Get one word
	HLRE	T2,(T1)			; (5) Get left half, extended
	HRRE	T2,(T1)			; (6) Get right half, extended

NUMTAB:	.TFLOT##			; (0) Float
	.TINTG##			; (1) Integer
	.TSPEC				; (2) Special

	$TOC	.TSUPT -- .TYPER Support Routines -- .TSPEC


; .TSPEC - Output a special format number
; Call:	DMOVX	T1,{the double precision integer number to output}
;	MOVX	P1,{the first word of the $NUMBER parameter block}
;	PUSHJ	P,.TSPEC
;	 * Return *
; Uses:	T1-4 and P1-4

.TSPEC::LDB	T3,[$POINT P1,NM%NOT]	; Go to the special
	JRST	@SPCTAB(T3)		;  output processor

SPCTAB:	.TALPH				; (0) Alpha
	.TENGL##			; (1) English
	.TPICT##			; (2) Picture
	.TROMN##			; (3) Roman
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDAYN


; .TDAYN - Type the day (Sunday, Monday, ...)
; Call:	MOVX	T1,{the universal date/time}
;    or	MOVX	T1,{the 15-bit date format}
;    or	MOVX	T1,.TFCUR		; Output the current day
;	PUSHJ	P,.TDAYN
;	 * Return *
; Uses:	T1-4

.TDAYN::CAXN	T1,.TFCUR		; Is the current day wanted?
	PUSHJ	P,.GTNOW##		; Yes, the current day
	TXNE	T1,WD%LFT		; Is it in 15-bit format?
	JRST	TDAYN1			; No, no need to convert
	MOVE	T2,T1			; Get the date in the right place
	SETZ	T1,			; Clear the time
	PUSHJ	P,.CNVDT##		; Go convert to universal date/time
TDAYN1:
IFE <TF%MON-TF%T20>,<
IFE <TF%SCN-TF%OFF>,<
	SUB	T1,.TYTZA##		; Account for the time zone >>

	HLRZS	T1			; Get the date
	IDIVX	T1,^D7			; Get the day
	MOVE	T1,TYPDAY(T2)		; Get the pointer to the day string
	PJRST	.TASCI			; Output the day
	$TOC	.TSUPT -- .TYPER Support Routines -- .TFULN


; .TFULN - Type out SIXBIT word, including trailing blanks
; Call:	MOVX	T1,{the SIXBIT word to output}
;	PUSHJ	P,.TFULN
;	 * Return *
; Uses:	T1-3

.TFULN::MOVE	T2,T1			; Move the parameter
	MOVX	T3,^D6			; Set up counter
TFULN1:	SETZ	T1,			; Clear next character
	LSHC	T1,^D6			; Get next character
	ADDX	T1," "-' '		; Convert to ASCII
	PUSHJ	P,.TCHAR		; Type it
	SOJG	T3,TFULN1		; Loop until finished
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TALPH


; .TALPH - Type an alpha number
; Call:	MOVX	T1,{the alpha number to output}
;	MOVX	P1,{the first word of the $NUMBER parameter block}
;	PUSHJ	P,.TALPH
;	 * Return *
; Uses:	T1-3, P1

.TALPH::TXNN	P1,%NMLOW		; Skip if lower case is wanted
	TDZA	T3,T3			; Set up for upper case
	MOVX	T3,<"a"-"A">		; Set up for lower case
	CAXN	T1,^O0			; Skip if high order is non-zero
	SKIPG	T1,T2			; Skip if a valid number
	$TYPE	(F,AIA,$OCT,<An invalid alpha number (|)>,,A,T)

TALPH1:	SUBX	T1,^D1			; Adjust the number
	IDIVX	T1,^D26			; Get a digit
	HRLM	T2,(P)			; Save for later
	CAXE	T1,^O0			; Skip if finished
	PUSHJ	P,TALPH1		; Go get another digit
	HLRZ	T1,(P)			; Get a digit to output
	ADDI	T1,"A"(T3)		; Convert to ASCII
	PJRST	.TCHAR			; Output the character
	$TOC	.TSUPT -- .TYPER Support Routines -- .THEXW


; .THEXW - Type out signed hexadecimal number
; Call:	MOVX	T1,{the hexadecimal number to output}
;	PUSHJ	P,.THEXW
;	 * Return *
; Uses:	T1-3

.THEXW::MOVX	T3,^D16			; Set up for hexadecimal output
	PJRST	.TRDXW			;  and output the number
	$TOC	.TSUPT -- .TYPER Support Routines -- .TBHXW


; .TBHXW - Type out signed hexadecimal number
; Call:	MOVX	T1,{the hexadecimal number to output}
;	MOVX	T4,{the width of the number}
;	PUSHJ	P,.TBHXW
;	 * Return *
; Uses:	T1-4

.TBHXW::MOVX	T3,^D16			; Set up for hexadecimal output
	PJRST	.TBRXW			;  and output the number
	$TOC	.TSUPT -- .TYPER Support Routines -- .TLINE


; .TLINE - Type multiple CR-LF's
; Call:	SETO	T1,{a form feed is wanted}
;    or	MOVX	T1,{the number of CR-LF's wanted}
;	PUSHJ	P,.TLINE
;	 * Return *
; Uses:	T1-2

.TLINE::SKIPN	T2,T1			; Skip is something is wanted
	POPJ	P,			; Return
	JUMPL	T2,[MOVX  T1,.CHFFD	 ; Output a
		    PJRST .TCHAR]	 ;  form-feed

TLINE1:	MOVX	T1,.CHCRT		; Output a
	PUSHJ	P,.TCHAR		;  carriage-return
	MOVX	T1,.CHLFD		; Output a
	PUSHJ	P,.TCHAR		;  line feed
	SOJG	T2,TLINE1		; Loop until finished
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TMULS


; .TMULS - Type multiple spaces
; Call:	MOVX	T1,{the number of spaces to output}
;	PUSHJ	P,.TMULS
;	 * Return *
; Uses:	T1-2

.TMULS::SKIPG	T2,T1			; Skip if some space(s) to output
	POPJ	P,			; Return
	MOVX	T1," "			; Get the fill character
TMULS1:	PUSHJ	P,.TCHAR		; Output a fill character
	SOJG	T2,TMULS1		; Loop until finished
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TLEFT


; .TLEFT - Type only the left half in SIXBIT
; Call:	MOVX	T1,{the SIXBIT word to output}
;	PUSHJ	P,.TLEFT
;	 * Return *
; Uses:	T1-2

.TLEFT::TXZ	T1,WD%RIT		; Clobber the right half
	PJRST	.TSIXN			;  and type the left half
	$TOC	.TSUPT -- .TYPER Support Routines -- .TFERR


; .TFERR - Type a LOOKUP/ENTER error code message and file name
; Call:	HRLZI	T1,{the address of OPEN block}
;	HRRI	T1,{the address of LOOKUP/ENTER block}
;    or	HRRZI	T1,{the address of the .FILOP block}
;	PUSHJ	P,.TFERR
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TFERR::TXNE	T1,WD%LFT		; Skip if a FILOP. block
	JRST	[HRRZ T2,T1		 ; Get the address of the LOOKUP/ENTER block
		 JRST TFERR2]		 ; Go get the error number
	HRLI	T1,.FOIOS(T1)		; Get the address of the OPEN block
	MOVS	T2,.FOLEB(T1)		; Get the address of the RENAME block
	TXNN	T2,WD%RIT		; Skip if RENAME block was specified
	JRST	TFERR1			; Go try the LOOKUP/ENTER block
	PUSHJ	P,[HRRZ T3,T2		 ; Get the address of the block
		   MOVE T4,.RBCNT(T3)	 ; Get the size of the block
		   TXNE T4,WD%LFT	 ; Skip if a extended block
		   SUBX T3,^O2		 ; Fake the address of the error word
		   HRRZ T4,.RBEXT(T3)	 ; Get the error code
		   POPJ P,]		 ; Return
	JUMPE	T4,TFERR1		; Jump if zero (assume invalid)
	CAXG	T4,TYPLEN		; Skip if out of range
	JRST	TFERR3			; Go output the error message
TFERR1:	HLRZS	T2			; Get the address of the LOOKUP/ENTER block
TFERR2:	PUSHJ	P,[HRRZ T3,T2		 ; Get the address of the block
		   MOVE T4,.RBCNT(T3)	 ; Get the size of the block
		   TXNE T4,WD%LFT	 ; Skip if a extended block
		   SUBX T3,^O2		 ; Fake the address of the error word
		   HRRZ T4,.RBEXT(T3)	 ; Get the error code
		   POPJ P,]		 ; Return
TFERR3:	HRR	T1,T2			; Save the address of the block
	PUSH	P,T1			; Save the pointer for awhile

	CAXLE	T4,TYPLEN		; Skip if a known error code
	JRST	[MOVEI T1,[ASCIZ ~LOOKUP/ENTER failure ~]
		 PUSHJ P,.TASCI		 ; Output the default message
		 MOVE  T1,T4		 ; Output the real
		 PUSHJ P,.TOCPW		 ;   error code
		 JRST  TFERR4]		 ; Keep on truck'n
	HRRZ	T1,TYPFET(T4)		; Get the address of the error message
	PUSHJ	P,.TASCI		; Output the error message
TFERR4:	PUSHJ	P,.TSPAC		; Output a space

	POP	P,T1			; Restore the file pointer
	PFALL	.TLOOK			;  and into .TLOOK >
IFE <TF%MON-TF%T20>,<
.TFERR::MOVX	T1,<SIXBIT ~ERR~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TLOOK


; .TLOOK - Type a LOOKUP/ENTER block (short/extended)
; Call:	HRLZI	T1,{the address of OPEN block}
;	HRRI	T1,{the address of LOOKUP/ENTER block}
;    or	HRRZI	T1,{the address of the .FILOP block}
;	PUSHJ	P,.TLOOK
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TLOOK::TXNN	T1,WD%LFT		; Skip if not a .FILOP block
	JRST	[HRRZ  T2,.FOLEB(T1)	 ; Get the address of the LOOKUP block
		 MOVEI T1,.FOIOS(T1)	 ; Get the address of the OPEN block
		 JRST  TLOOK1]		 ; Go do something useful
	HRRZ	T2,T1			; Get the address of the LOOKUP/ENTER block
	HLRZS	T1			; Get the address of the OPEN block
TLOOK1:	MOVE	T3,.RBCNT(T2)		; Get the size of the LOOKUP/ENTER block
	TXNN	T3,WD%LFT		; Skip if a short LOOKUP/ENTER block
	PJRST	.TOLEB			; Go output the information
	MOVE	T4,T2			; Make a safe copy
	MOVE	T1,.OPDEV(T1)		; Get device
	PUSHJ	P,.TSIXN		; Issue it
	PUSHJ	P,.TCOLN		; Issue separator
	MOVE	T1,^O0(T4)		; Get file name
	HLRZ	T2,^O1(T4)		; Get extension
	CAXN	T2,'UFD'		; See if UFD
	JUMPG	T1,[PUSHJ P,.TPPNW	 ; Yes, type as PPN
		    JRST  TLOOK2]	 ; Proceed
	PUSHJ	P,.TSIXN		; Else issue in SIXBIT
TLOOK2:	PUSHJ	P,.TDOT			; Indicate extension
	HLLZ	T1,^O1(T4)		; Get extension
	PJRST	.TSIXN			; Issue it and return >
IFE <TF%MON-TF%T20>,<
.TLOOK::MOVX	T1,<SIXBIT ~LKP~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TJFNS


; .TJFNS - Type a file specification from a JFN
; Call:	HRRZ	T1,{the JFN to be output}
;	TXO	T1,{the output flags to use or 0, for the defaults}
;	PUSHJ	P,.TJFNS
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TJFNS::MOVX	T1,<SIXBIT ~JFN~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message >
IFE <TF%MON-TF%T20>,<
.TJFNS::$VARIA	(LOCAL,<<TYPTMP,^D38>>)
	TXNN	T1,WD%LFT		; Skip if some output flags given
	TXO	T1,TF%DEF		; Load the default output flags
	HLLZ	T4,T1			; Get the output flags
	MOVEI	T2,^D7			; Shift over the first 7 flags
TJFNS1:	LSH	T3,^D1			; Convert from 2-bits wide
	LSHC	T3,^D2			;  to 3-bits wide for JFNS
	SOJG	T2,TJFNS1		; Loop for all 7
	LSH	T3,^D15			; Position them correctly of JFNS
	TXNE	T1,TF%TMP		; Is ';T' wanted
	TXO	T3,JS%TMP		; Yes, set the flag
	LDB	T4,[$POINT (T1,TF%TBR!TF%TBP!TF%PAF)]  ; Get some
	DPB	T4,[$POINT (T3,JS%TBR!JS%TBP!JS%PAF)]  ;  more flags

	HRRZ	T2,T1			; Get the JFN
	HRROI	T1,TYPTMP		; Get the pointer to the JFN table
	JFNS%				; Get the file specification
	 $ERROR	(N,,$ERS,<* | *>,N,P,,[.TFCUR])
	MOVEI	T1,TYPTMP		; Output the file
	PJRST	.TASCI			;  specification >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TJERR


; .TJERR - Type a error string associted with an error number
; Call:	MOVX	T1,{the external string number or 0, for current string}; TOPS-10
;    or	HRLZ	T1,{the process handle or 0, for current the process}	; TOPS-20
;	HRR	T1,{the error number or 0, for current the error}	; TOPS-20
;    or	MOVX	T1,.TFCUF		; Output the current error string
;	PUSHJ	P,.TJERR
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TJERR::CAXN	T1,.TFCUR		; Is the default error number wanted?
	HRRZ	T1,.TYDEN##		; Yes, Get the default error number
	PJRST	.TEXTS			; Output an external string >
IFE <TF%MON-TF%T20>,<
.TJERR::$VARIA	(LOCAL,<<TYPTMP,^D27>>)
	CAXN	T1,.TFCUR		; Is the current message wanted?
	SETZ	T1,			; Yes, set up the correct default
	TXNN	T1,WD%LFT		; Was the process supplied?
	TLO	T1,.FHSLF		; No, assume current process
	MOVE	T2,T1			; Just incase the error number was supplied
	TXNE	T2,WD%RIT		; Was the error number supplied?
	JRST	TJERR1			; Yes, go output the message
	HLRZS	T1			; Get the process in the right place
	GETER%				; Get the most recent error number
	 $ERROR	(N,,$NON,<No errors encountered>,N,P)
TJERR1:	HRROI	T1,TYPTMP		; Get the error string
	MOVSI	T3,-^D<27*5-1>		;  associated with
	ERSTR%				;  the error number
	 ERJMP	TJERR2			; Unknown error number/string
	 $ERROR	(F,MTL,$NON,<Error message too long to be processed>,,D,T)
	MOVEI	T1,TYPTMP		; Output the
	PJRST	.TASCI			;  error string
TJERR2:	HRRZ	T1,T2			; Output the external
	PJRST	.TEXTS			;  string number >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDIRT/.TUSER


; .TDIRT - Type a directory name
; .TUSER - Type a user name
; Call:	MOVX	T1,{the directory or user number}
;	PUSHJ	P,.TDIRT/.TUSER
;	 * Return *
; Uses:	T1-3

IFE <TF%MON-TF%T10>,<
.TDIRT::SKIPA	T1,[SIXBIT ~DIR~]	; Output the
.TUSER::MOVX	T1,<SIXBIT ~USR~>	;  no support
	PJRST	.TNSUP##		;  loaded message >
IFE <TF%MON-TF%T20>,<
.TDIRT::SKIPA	T3,[.JIDNO]		; The connected directory number
.TUSER::MOVX	T3,.JIUNO		; The user number
	CAXE	T1,.TFCUR		; Is the current value wanted?
	JRST	TUSER1			; No, use what we were given
	SETO	T1,			; Get the
	MOVX	T2,<-^O1,,T1>		;  current
	GETJI%				;  value
	 $ERROR	(N,,$NON,<* unknown directory/user name *>,N,P)

TUSER1:	$VARIA	(LOCAL,<<TYPTMP,^D10>>)
	MOVE	T2,T1			; Get the
	HRROI	T1,TYPTMP		;  directory or
	DIRST%				;  user name
	 $ERROR	(N,,$XWD,<* unknown directory/user number (|) *>,N,P,,T2)
	MOVEI	T1,TYPTMP		; Output the directory
	PJRST	.TASCI			;  or user name >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TPROW


; .TPROW - Type out protection code, with carrots
; Call:	MOVX	T1,{the protection code to output}
;	PUSHJ	P,.TPROW
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TPROW::PUSH	P,T1			; Save T1
	PUSHJ	P,.TLANG		; Output an open angle bracket
	POP	P,T1			; Restore T1
	TXNE	T1,RB.PRV		; Skip if left justified protection
	LSH	T1,-<$ALIGN(RB.PRV)>	; Right justify the protection
	ANDX	T1,<RB.PRV_-<$ALIGN(RB.PRV)>>  ; Clean an extraneous bits
	MOVX	T2,"0"			; Set the filler character
	MOVX	T4,^D3			; Set the width
	PUSHJ	P,.TFOCW		; Output the protection code
	PJRST	.TRANG			; Output a close angle bracket and return >
IFE <TF%MON-TF%T20>,<
.TPROW::MOVX	T1,<SIXBIT ~PRO~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TBBLK and .TBCRW


; .TBBLK - Type number in blocks (with fill)
; .TBCRW - Type number in core size (with fill)
; Call:	MOVX	T1,{the size to output}
;	MOVX	T4,{the width of the field}
;	PUSHJ	P,.TBBLK/.TBCRW
;	 * Return *
; Uses:	T1-4

.TBBLK::MOVE	T3,["B",,^O177]		; Preset for blocks
	JRST	TBCRW2			;  and go test

.TBCRW::JUMPE	T1,TBCRW3		; If null, do in words
	HRLOI	T2,-^O2			; Set up to get for KA10/PDP6
	AOBJN	T2,TBCRW1		; Jump if not a KA10/PDP6
	SKIPA	T3,["K",,^O1777]	; Else, indicate K
TBCRW1:	MOVE	T3,["P",,^O777]		; Indicate pages
TBCRW2:	TRNE	T1,(T3)			; Even number of units?
	JRST	TBCRW3			; No, do in words
	IDIVI	T1,^O1(T3)		; Divide by units
	SKIPA				;  and output
TBCRW3:	MOVSI	T3,"W"			; Indicate words
	HRRI	T3,^D10			; Set up for decimal radix
	PUSHJ	P,.TBRXW		; Issue size
	HLRZ	T1,T3			; Get size unit indicator
	PJRST	.TCHAR			; Issue that and return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TBXWW


; .TBXWW - Type out N as two octal half-words (with fill)
; Call:	MOVX	T1,{the word to output}
;	MOVX	T4,{the width of left half word}
;	PUSHJ	P,.TBXWW
;	 * Return *
; Uses:	T1-4

.TBXWW::PUSH	P,T1			; Preserve parameter
	HLRZ	T1,T1			; Get the left half
	PUSHJ	P,.TBOCW		; Output in octal
	PUSHJ	P,.TCOMA		; Issue comma
	POP	P,T1			; Restore parameter
	HRRZ	T1,T1			; Get the right half
	PJRST	.TOCTW			; Output the right half
	$TOC	<.TSUPT -- .TYPER Support Routines -- .TBOCW, .TBDCW and .TBRXW>


; .TBDCW - Type out signed decimal number
; .TBOCW - Type out signed octal number
; .TBRXW - Type out signed number (radix in T3)
; Call:	MOVX	T1,{the number to output}
;	MOVX	T4,{the width of the number}
;	PUSHJ	P,.TBOCW/.TBDCW/.TBRXW
;	 * Return *
; Uses:	T1-4

.TBOCW::SKIPA	T3,[^O10]		; Initialize for octal radix
.TBDCW::MOVX	T3,^D10			; Initialize for decimal radix

.TBRXW::JUMPGE	T1,TBRXW1		; Is the number negative?
	TXO	T3,B0			; Yes, remember this tidbit of information
	MOVNS	T1			; Save away parameter
	SUBX	T4,^D1			; Account for the minus sign
TBRXW1:	SUBX	T4,^D1			; Account for the digit
	IDIVI	T1,(T3)			; Divide by radix
	HRLM	T2,(P)			; Save remainder
	JUMPE	T1,TBRXW3		; See if anything left
	PUSHJ	P,TBRXW1		; Else recurse via stack
TBRXW2:	HLRZ	T1,(P)			; Get back a digit
	ADDX	T1,"0"			; Convert to ASCII
	CAXLE	T1,"9"			; Any overflow digits?
	ADDX	T1,"A"-"9"-^O1		; Yes, switch to alphabetics
	PJRST	.TCHAR			; Type it and return

TBRXW3:	SKIPLE	T1,T4			; Get the number of spaces needed
	PUSHJ	P,.TMULS		; Output the right amount of fill
	MOVX	T1,"-"			; Get a minus sign
	TXNE	T3,B0			; Skip if a minus sign isn't wanted
	PUSHJ	P,.TCHAR		; Output the minus sign
	JRST	TBRXW2			; Go output the number
	$TOC	.TSUPT -- .TYPER Support Routines -- .TRUNN


; .TRUNN - Type a runtime time
; Call:	MOVX	T1,{the runtime}
;	MOVX	T4,{the output type}	.LT. 0  Blank fill
;					.EQ. 0  Suppress blanks
;					.GT. 0  full output
;	PUSHJ	P,.TRUNN
;	 * Return *
; Uses:	T1-4

.TRUNN::CAXGE	T4,^O0			; Skip if blanking isn't wanted
	MOVX	T4,TF%BLK		; Set the blanking flag
	CAXLE	T4,^O0			; Skip if full output isn't wanted
	MOVX	T4,TF%DIG		; Set digit seen flag
	TXZE	T1,TF%JIF		; Skip if not jiffie runtime
	HRRI	T4,^D1			; Set up for jiffies
	LDB	T2,[$POINT T1,TF%SIZ]	; Get the number of
	TLO	T4,(T2)			;  digits to output
	TXZ	T1,TF%SIZ		; Clear then to avoid problems

	IDIV	T1,TYPHOR(T4)		; Get the hours
	PUSH	P,T2			; Save the minutes and seconds
	TXNN	T4,TF%DIG		; Skip if digits should be output
	JUMPE	T1,[TXNN  T4,TF%BLK	 ; Skip if suppressing
		    JRST  TRUNN1	 ; Keep on truck'n
		    MOVX  T1,^D3	 ; Set up to output
		    PUSHJ P,.TMULS	 ;  three spaces
		    JRST  TRUNN1]	 ; Keep on truck'n
	PUSHJ	P,TRUN10		; Output some digits
	PUSHJ	P,.TCOLN		; Output a colon
TRUNN1:	POP	P,T1			; Restore the minutes and seconds
	IDIV	T1,TYPMNT(T4)		; Get the minutes
	PUSH	P,T2			; Save the seconds
	TXNN	T4,TF%DIG		; Skip if digits should be output
	JUMPE	T1,[TXNN  T4,TF%BLK	 ; Skip if suppressing
		    JRST  TRUNN2	 ; Keep on truck'n
		    MOVX  T1,^D3	 ; Set up to output
		    PUSHJ P,.TMULS	 ;  three spaces
		    JRST  TRUNN2]	 ; Keep on truck'n
	PUSHJ	P,TRUN10		; Output some digits
	PUSHJ	P,.TCOLN		; Output a colon
TRUNN2:	POP	P,T1			; Restore the seconds
	IDIV	T1,TYPSEC(T4)		; Get the seconds
	TXNN	T4,^D3B17		; Skip if parts of a second are wanted
	PJRST	TRUN10			; Output the seconds and return

		    $CONTINUE		; Continued on the next page
; Here to output parts of a second

	PUSH	P,T2			; Save for later
	PUSHJ	P,TRUN10		; Output the seconds
	PUSHJ	P,.TDOT			; Output the decimal point
	POP	P,T1			; Restore the parts of a second
	MOVE	T3,T4			; Get the jiffie flag
	LDB	T4,[$POINT (T4,^O3B17)]	; Get number if digits wanted
	IMUL	T1,TYPMUL-^O1(T4)	; Get the number
	IDIV	T1,TYPSEC(T3)		;  digits to output
	MOVX	T2,"0"			; Get the fill character
	PJRST	.TFDCW			; Go output it

		     $CONTINUE		; Continued on the next page
; Here to output a section of the runtime

TRUN10:	TXON	T4,TF%DIG		; Skip if a full field is needed
	CAXL	T1,^D10			; Skip if less than 10
	PJRST	TRUN11			; Go output the number
	MOVE	T2,T1			; Get the digit
	TXNN	T4,TF%BLK		; Skip if blanking is on
	PJRST	TRUN13			; Output on a digit
	MOVX	T1," "			; Set up to output
	PJRST	TRUN12			;  a blank
TRUN11:	CAXL	T1,^D100		; Skip if less than 100
	PJRST	.TDECW			; Output the digits
	IDIVX	T1,^D10			; Split up the digits
	MOVEI	T1,"0"(T1)		; Convert to ASCII
TRUN12:	PUSHJ	P,.TCHAR		; Output the character (blank/digit)
TRUN13:	MOVEI	T1,"0"(T2)		; Convert to ASCII
	PJRST	.TCHAR			; Output the digit
	$TOC	.TSUPT -- .TYPER Support Routines -- .TPFXN


; .TPFXN - Type a prefix with a SIXBIT/character suffix
; Call:	HRLZI	T1,{the SIXBIT word to output}
;   or	MOVX	T1,{the character to output}
;	PUSHJ	P,.TPFXN
;	 * Return *
; Uses:	T1-3

.TPFXN::SKIPN	T3,TB.SYS(TB)		; Skip if a system prefix
	SKIPE	T3,TB.SYS+.TYDDB##	; Skip if no default prefix
	JRST	TPFXN1			; Go test the suffix now
	MOVSI	T3,TP.PFX		; Get the program abbreviation
TPFXN1:	EXCH	T1,T3			; Get the suffix
	JUMPG	T3,TPFXN2		; Jump if a character
	HLR	T1,T3			; Get the message abbreviation
	PJRST	.TSIXN			; Type the abbreviations and return
TPFXN2:	PUSHJ	P,.TSIXN		; Type the abbreviation
	MOVE	T1,T3			; Get the character
	PJRST	.TCHAR			; Type the character and return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TSIXS


; .TSIXS - Type a SIXBIT word for a time stamp
; Call:	MOVX	T1,{the SIXBIT word to output}
;	PUSHJ	P,.TSIXS
;	 * Return *
; Uses:	T1-2

.TSIXS::MOVE	T2,T1			; Move the parameter
TSIXS1:	JUMPE	T2,.POPJ##		; Loop until only blanks left
	SETZ	T1,			; Clear the next character
	LSHC	T1,^D6			; Get next character
	ADD	T1,[-^O2,," "-' ']	; Convert to ASCII with time stamp info
	PUSHJ	P,.TCHAR		; Type it
	JRST	TSIXS1			; Loop some more
	$TOC	.TSUPT -- .TYPER Support Routines -- .T2TAB


; .T2TAB - Type a null time stamp (<TAB><TAB>)
; Call:	PUSHJ	P,.T2TAB
;	 * Return *
; Uses:	No ACs

.T2TAB::PUSH	P,T1			; Save T1
	HRROI	T1,.CHTAB		; Output
	PUSHJ	P,.TCHAR		;  two
	PUSHJ	P,.TCHAR		;  tabs
	POP	P,T1			; Restore T1
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TSTMP


; .TSTMP - Type a time stamp (hh:mm:ss<TAB>)
; Call:	PUSHJ	P,.TSTMP
;	 * Return *
; Uses:	No ACs

.TSTMP::PUSHJ	P,.SAV1T##		; Save T1-4
IFE <TF%MON-TF%T10>,<
	MSTIME	T1,			; Get the current time >
IFE <TF%MON-TF%T20>,<
	PUSHJ	P,.GTNOW##		; Get the current date and time
	PUSHJ	P,.CNTDT##		; Convert to something useful >

	IDIV	T1,TYPHOR		; Get hours
	MOVE	T3,T2			; Save rest
	PUSHJ	P,TSTMP2		; Type two digits
	HRROI	T1,":"			; Type a
	PUSHJ	P,.TCHAR		;  colon
	MOVE	T1,T3			; Restore rest
	IDIV	T1,TYPMNT		; Get minutes
	MOVE	T3,T2			; Save rest
	PUSHJ	P,TSTMP2		; Type two digits
	HRROI	T1,":"			; Type a
	PUSHJ	P,.TCHAR		;  colon
	MOVE	T1,T3			; Restore rest
	IDIV	T1,TYPSEC		; Get seconds
	PUSHJ	P,TSTMP2		; Type two digits
	MOVE	T2,TB.TIM(TB)		; Get the time stamp stuff
	AOJE	T2,TSTMP1		; Jump if only the time stamp is wanted
	MOVE	T1,[-^O2,," "]		; Output a time
	PUSHJ	P,.TCHAR		;  stamp space
	JUMPG	T2,[PUSHJ P,-^O1(T2)	 ; Go to the user routine
		    JRST  TSTMP1]	 ; Type a tab
	MOVE	T1,-^O1(T2)		; Type the SIXBIT
	PUSHJ	P,.TSIXS		;  status info
TSTMP1:	HRROI	T1,.CHTAB		; Get a tab
	PUSHJ	P,.TCHAR		; Output it
	POPJ	P,			; Return

TSTMP2:	IDIVX	T1,^D10			; Split the digits
	HRROI	T1,"0"(T1)		; Get the first digit
	PUSHJ	P,.TCHAR		; Output it
	HRROI	T1,"0"(T2)		; Get the second digit
	PFALL	.TCHAR			;  and fall into .TCHAR
	$TOC	.TSUPT -- .TYPER Support Routines -- .TCHAR


; .TCHAR - Type an ASCII character (for SCAN)
; Call:	MOVX	T1,{the character to output}
;	PUSHJ	P,.TCHAR
;	 * Return *
; Uses:	No ACs

.TCHAR::
IFE <TF%SCN-TF%ON>,<
	PUSHJ	P,.SAVET##		; Save register TB >
	PFALL	.TTCHR			; Fall into .TTCHR
	$TOC	.TSUPT -- .TYPER Support Routines -- .TTCHR


; .TTCHR - Type an ASCII character
; Call:	MOVX	T1,{the character to output}
;	HRLI	T1,^O0			; Normal character
;    or	HRLI	T1,-^O1			; Time stamp time character
;    or	HRLI	T1,-^O2			; Time stamp text character
;	PUSHJ	P,.TTCHR
;	 * Return *
; Uses:	No ACs

.TTCHR::TXNN	T1,^O177B35		; See if null
	POPJ	P,			; Yes--ignore
	JUMPL	T1,TTCH02		; Jump if a time stamp character
	SKIPL	TB.FLG(TB)		; Skip if special justification
	JRST	TTCH02			; Avoid alot of code
	PUSHJ	P,.SAV1T##		; Save T1-4
	MOVE	T4,TB.FLG(TB)		; Get the flags
	LDB	T3,[$POINT T4,<%TBHOR!%TBVER!%TBTIM!%TBCMP>]
	JRST	@TTCH00(T3)		; Go to the output processor


TTCH00:	TTCH01				; (0) No time stamps or justification
	TTCH80				; (1) Space compression
	TTCH40				; (2) Time stamps
	TTCH40				; (3) Time stamps and space compression
	TTCH20				; (4) Horizonal justification
	TTCH20				; (5) Horizonal justification and space compression
	TTCH20				; (6) Horizonal justification and time stamps
	TTCH20				; (7) Horizonal justification, time stamps and
					;      space compression
	TTCH10				; (10) Vertical justification
	TTCH10				; (11) Vertical justification and space compression
	TTCH10				; (12) Vertical justification and time stamps
	TTCH10				; (13) Vertical justification, time stamps and
					;       space compression
	TTCH10				; (14) Vertical justification and horizonal
					;       justification
	TTCH10				; (15) Vertical justification, horizonal
					;       justification and space compression
	TTCH10				; (16) Vertical justification, horizonal
					;       justification and time stamps
	TTCH10				; (17) Vertical justification, horizonal
					;       justification, time stamps and
					;       space compression

		     $CONTINUE		; Continued on the next page
; Here to output the character

TTCH01:	MOVEM	T4,TB.FLG(TB)		; Save the flags
TTCH02:	SKIPE	TB.CHR(TB)		; Skip if special output routine
	PJRST	@TB.CHR(TB)		; Go use it then
	SKIPE	TB.CHR+.TYDDB##		; Skip if default output routine
	PJRST	@TB.CHR+.TYDDB##	; Go use it then
	SOSG	.TYROM##		; Skip still some room in the buffer
	PUSHJ	P,.TDUMP##		; Dump the buffer
	IDPB	T1,.TYPTR##		; Store the character in the buffer
	CAXL	T1,.CHLFD		; Skip if not a vertical
	CAXLE	T1,.CHFFD		;  position character
	POPJ	P,			; Return
	PJRST	.TDUMP##		; Dump the buffer

		     $CONTINUE		; Continued on the next page
; Here for vertical justification

TTCH10:	TXZ	T3,TF%VEX		; Clear the vertical justification flag

	TXNN	T4,%TBTOF		; Skip if waiting for useful character
	JRST	TTCH11			; Avoid some code
	CAXG	T1,.CHCRT		; Skip if .GT. carriage-return
	CAXGE	T1,.CHLFD		; Skip if .GE. line-feed
	TRNA				; Skip
	POPJ	P,			; Eat CR's and vertical motion characters
	SETZM	TB.CLN(TB)		; Reset the line count
	TXZ	T4,%TBTOF		; Reset the top of page flag
	MOVEM	T4,TB.FLG(TB)		; Restore the flags
	PUSHJ	P,.PSH4T##		; Save some AC's
	SKIPE	TB.HRT(TB)		; Skip if no a header routine
	PUSHJ	P,@TB.HRT(TB)		; Go output the header
	SKIPLE	T1,TB.HLN(TB)		; Get the length of the header
	PUSHJ	P,TTCH19		; Move to the bottom of the header
	PUSHJ	P,.POP4T##		; Restore the AC's
	MOVE	T4,TB.FLG(TB)		; Restore the flags

TTCH11:	CAXE	T1,.CHLFD		; Skip if a line-feed
	JRST	[CAXN T1,.CHFFD		 ; Skip if not a form-feed
		 TXNE T4,%TBBOF		 ; Skip not at the bottom
		 JRST @TTCH00(T3)	 ; Go output output the character
		 JRST TTCH12]		 ; Go output the trailer
	AOS	T2,TB.CLN(TB)		; Get the current line count
	CAME	T2,TB.TLN(TB)		; Skip if time for the trailer
	JRST	@TTCH00(T3)		; Jump if not time for a trailer
	PUSHJ	P,@TTCH00(T3)		; Output the LF, then output the trailer
TTCH12:	TXO	T4,%TBBOF		; Set the bottom flag
	MOVEM	T4,TB.FLG(TB)		; Save the flags
	PUSHJ	P,.PSH4T##		; Save some AC's
	SKIPN	TB.TRT(TB)		; Skip if there is a trailer routine
	JRST	TTCH13			; Avoid some code
	MOVE	T1,TB.TLN(TB)		; Get where the trailer starts
	PUSHJ	P,TTCH19		; Move down some lines
	PUSHJ	P,@TB.TRT(TB)		; Output the trailer
TTCH13:	SKIPE	T1,TB.PLN(TB)		; Skip if no length
	PUSHJ	P,TTCH19		; Move down some lines
	PUSHJ	P,.POP4T##		; Restore some AC's
	MOVX	T4,%TBTOF!%TBBOF	; Set the top
	XORM	T4,TB.FLG(TB)		;  of page flag
	POPJ	P,			; Return

TTCH19:	PJMPL	T1,.TLINE		; Output a Form-Feed
	SUB	T1,TB.CLN(TB)		; Get number of line needed
	PJMPG	T1,.TLINE		; Jump if something to output
	POPJ	P,			; Return

		     $CONTINUE		; Continued on the next page
; Here for horizonal justification

TTCH20:	TXZ	T3,TF%HOX		; Clear the horizonal justification flag

	CAXL	T1," "			; Skip if a control character
	AOJA	T4,@TTCH00(T3)		; Account for the character
	CAXN	T1,.CHCRT		; Skip if not a carriage return
	JRST	[TXZ  T4,TB%COL		 ; Clear the column count
		 JRST @TTCH00(T3)]	 ; Go to the next output processor
	CAXN	T1,.CHTAB		; Skip if not a tab
	JRST	[TXO  T4,^O7B35		 ; Account for the
		 AOJA T4,@TTCH00(T3)]	 ;  size of the tab
	CAXN	T1,.CHCNH		; Skip if not Control-H
	SUBX	T4,^D1			; Account for the Control-H
	JRST	@TTCH00(T3)		; Go to the next output processor

		     $CONTINUE		; Continued on the next page
; Here for time stamps

TTCH40:	TXZ	T3,TF%TIX		; Clear the time stamp flag

	TXNN	T4,%TBLCC		; Skip if the last character was a CR
	JRST	TTCH41			; No, just output this character
	CAXL	T1,.CHLFD		; Skip if .LT. line-feed
	CAXLE	T1,.CHFFD		; Skip if .LE. form-feed
	PUSHJ	P,.T2TAB		; Output two tabs (overprint)
TTCH41:	TXZE	T4,%TBTTS		; Skip if not time for a time stamp
	PUSHJ	P,.TSTMP		; Put on the time stamp
	CAXG	T1,.CHFFD		; Skip if .GT. form-feed
	CAXGE	T1,.CHLFD		; Skip if .GE. line-feed
	JRST	TTCH42			; The character has no vertical motion
	TXO	T4,%TBTTS		; Set the time stamp flag
	TXZE	T4,%TBLCC		; Skip if the last character was a CR
	JRST	@TTCH00(T3)		; Go to the next output processor
	HRROI	T1,.CHCRT		; Output the a
	PUSHJ	P,.TTCHR		;  carriage-return
	MOVE	T1,-^O1(P)		; Restore the character
	JRST	@TTCH00(T3)		; Go to the next output processor
TTCH42:	CAXN	T1,.CHCRT		; Skip if not a carriage return
	TXOA	T4,%TBLCC		; Last character was CR
	TXZ	T4,%TBLCC		; Last character wasn't a <CR>
	JRST	@TTCH00(T3)		; Go to the next output processor

		     $CONTINUE		; Continued on next page
; Here to convert multiple spaces to tabs

TTCH80:	TXZ	T3,TF%CMX		; Clear the compress flag

	MOVE	T2,TB.CMP(TB)		; Get the character count
	CAXN	T1," "			; Is the character a space?
	JRST	TTCH83			; Yes, go compress it
	CAXN	T1,.CHTAB		; Is the character a tab?
	JRST	TTCH85			; Yes, go output it

	TXNN	T2,WD%RIT		; Any spaces input?
	JRST	TTCH82			; No, don't output an then
	TXZ	T2,WD%LFT		; Get the character count
	MOVX	T1," "			; Output
TTCH81:	PUSHJ	P,TTCH02		;  a space
	SOJG	T2,TTCH81		; Any more spaces needed?
	MOVE	T1,-^O1(P)		; No, restore the character
	MOVE	T2,TB.CMP(TB)		; Restore the character count

TTCH82:	CAXN	T1,.CHCRT		; Is the character a CR?
	JRST	TTCH85			; Yes, go reset the count and output it
	TXZ	T2,WD%RIT		; Reset the space count
	CAXGE	T1," "			; Is it a printable character?
	JRST	TTCH86			; Don't adjust the count
	ADDX	T2,<^O1,,^O0>		; Adjust the count
	JUMPL	T2,TTCH86		; Time to reset the count
	JRST	TTCH85			; Reset the counter

TTCH83:	AOBJP	T2,TTCH84		; Time to output a tab?
	MOVEM	T2,TB.CMP(TB)		; Save the count
	MOVEM	T4,TB.FLG(TB)		; Save the flags
	POPJ	P,			; Finished

TTCH84:	MOVX	T1,.CHTAB		; Get a tab
TTCH85:	MOVX	T2,<-^O10,,^O0>		; Reset the count
TTCH86:	MOVEM	T2,TB.CMP(TB)		; Save the count
	JRST	@TTCH00(T3)		; Go to the next character processor
	$TOC	.TSUPT -- .TYPER Support Routines -- .TFBLK


; .TFBLK - Type a SCAN style file block
; Call:	MOVX	T1,{the address of SCAN block}
;	PUSHJ	P,.TFBLK
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TFBLK::MOVE	T4,T1			; Save away parameter
	SKIPN	T1,.FXDEV(T4)		; Get the device
	JRST	TFBLK1
	PUSHJ	P,.TSIXN		; Type device
	PUSHJ	P,.TCOLN		; Type colon
TFBLK1:	MOVE	T1,.FXNAM(T4)		; Type
	PUSHJ	P,.TSIXN		;  name
	HLLZ	T3,.FXEXT(T4)		; Get extension
	MOVX	T2,FX.NUL		; See if user
	TDNE	T2,.FXMOM(T4)		;  typed
	TDNE	T2,.FXMOD(T4)		;  a dot
	JUMPE	T3,TFBLK2		; Yes, is this a null extension?
	PUSHJ	P,.TDOT			; Indicate extension
	MOVE	T1,T3			; Output
	PUSHJ	P,.TSIXN		;  extension
TFBLK2:	MOVEI	T1,.FXDIR(T4)		; Position to directory
	TLO	T1,TS.DRB		; Flag for biwords
	PJRST	.TDIRB			;  and go to .TDIRB >

IFE <TF%MON-TF%T20>,<
.TFBLK::PUSHJ	P,.SAVE1##		; Save P1
	$VARIA	(LOCAL,<<TYPTMP,^D38>>)
	MOVE	P1,T1			; P1 is specification pointer
	MOVE	T1,.FXJFN(P1)		; Get the JFN
	GTSTS%				; Get the status
	TXNN	T2,GS%NAM		; A valid JFN?
	JRST	TFBLK1			; No, print input string
	HRROI	T1,TYPTMP		; Yes, store the name in TYPTMP
	HRRZ	T2,.FXJFN(P1)		; Get the JFN again
	MOVX	T3,^O0			; Default format
	JFNS%				; Do it
	MOVEI	T1,TYPTMP		; Output the file
	PJRST	.TASCI			;  specification

TFBLK1:	MOVEI	T1,.FXFIL(P1)		; Output the string
	PJRST	.TASCI			;  the user supplied >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TOLEB


; .TOLEB - Type a LOOKUP/ENTER block
; Call:	MOVX	T1,{the address of OPEN block}
;	MOVX	T2,{the address of extended LOOKUP/ENTER block}
;	PUSHJ	P,.TOLEB
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TOLEB::MOVE	T4,T2			; Make safe copy
	MOVE	T1,.OPDEV(T1)		; Get device
	PUSHJ	P,.TSIXN		; Issue it
	PUSHJ	P,.TCOLN		; Issue separator
	MOVE	T1,.RBNAM(T4)		; Get file name
	HLRZ	T2,.RBEXT(T4)		; Get extension
	CAXN	T2,'UFD'		; See if UFD
	JUMPG	T1,[PUSHJ P,.TPPNW	 ; Yes, type as PPN
		    JRST  TOLEB1]	 ; Proceed
	PUSHJ	P,.TSIXN		; Else issue in SIXBIT
TOLEB1:	PUSHJ	P,.TDOT			; Indicate extension
	HLLZ	T1,.RBEXT(T4)		; Get extension
	PUSHJ	P,.TSIXN		; Issue that
	MOVEI	T1,.RBPPN(T4)		; Point to directory
	PFALL	.TDIRB			; Fall into .TDIRB >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDIRB


; .TDIRB - Type a directory block
; Call:	MOVX	T1,{the address of directory word or PATH or biwords}
;	TLO	T1,{0 for word, 1 for PATH or 2 for biwords}
;	PUSHJ	P,.TDIRB
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TDIRB::MOVE	T4,T1			; Save pointer
	SKIPN	T1,(T4)			; See if something there
	JRST	[HLRZ  T2,T4		 ; No--see if biwords
		 CAXN  T2,TS.DRB	 ;  ..
		 SKIPN ^O2(T4)		 ; Yes--see if something later on
		 POPJ  P,		 ; No--return
		 JRST  TDIRB1]		 ; Proceed with output
	TXNE	T4,WD%LFT		; See if straight
	JRST	TDIRB1			; Nope--do it the hard way
	TXNE	T1,WD%LFT		; Yes--see if SFD
	PJRST	.TPPNW			; No--just UFD
	MOVEI	T4,^O2(T1)		; Yes--change pointer

TDIRB1:	HLRZ	T1,T4			; Get length
	SUBX	T1,TS.DRB		; Set flag -1 for single, 0 for biwords
	PUSH	P,T1			; Save for later testing
	HRLI	T4,-.FXLND		; Set length
	PUSHJ	P,.TLBRK		; Start PATH spec
	MOVE	T1,(T4)			; Get UFD
	CAXE	T1,-^O1			; Unless -1 or positive, use SIXBIT

	JUMPL	T1,[PUSHJ P,.TSIXN	 ; Type SIXBIT PPN
		    JRST  TDIRB2]	 ; Go see if finished
	SKIPL	(P)			; See if double
	JRST	[MOVE  T2,^O1(T4)	 ; Yes--get mask
		 PUSHJ P,.TXWWW		 ; Output masked octal XWD
		 JRST  TDIRB2]		 ;  and proceed
	PUSHJ	P,.TXWDW		; Type it
TDIRB2:	AOBJP	T4,TDIRB3		; Loop until done
	SKIPL	(P)			; If biwords,
	ADDX	T4,^O1			;  move up one extra
	SKIPN	(T4)			; Skip if more to do

	JRST	TDIRB3			; Yes--return typing last break
	PUSHJ	P,.TCOMA		; Type a comma
	MOVE	T1,(T4)			; Get SFD name
	PUSHJ	P,.TSIXN		; Type it
	JRST	TDIRB2			;  and loop until done
TDIRB3:	POP	P,(P)			; Throw away flag
	JRST	.TRBRK			;  and finish up >
IFE <TF%MON-TF%T20>,<
.TDIRB::MOVX	T1,<SIXBIT ~PTH~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TXWWW


; .TXWWW - Type a masked (wild) octal word in XWD format
; Call:	MOVX	T1,{the word to output}
;	MOVX	T2,{the mask to apply}
;	PUSHJ	P,.TXWWW
;	 * Return *
; Uses:	T1-3

IFE <TF%MON-TF%T10>,<
.TXWWW::MOVSS	T2			; T1,T2=LH(V),RH(V),RH(M),LH(M)
	ROTC	T1,-^D18		; T1,T2=LH(M),LH(V),RH(V),RH(M)
	PUSH	P,T2			; Save second half (V,,M)
	MOVSS	T1			; T1=LH  V,,M
	PUSHJ	P,.TMOHW		; Type masked octal half-word
	PUSHJ	P,.TCOMA		; Type comma
	POP	P,T1			; Restore RH  V,,M
	PFALL	.TMOHW			; Fall into .TMOHW >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TMOHW


; .TMOHW - Type a masked octal half-word
; Call:	HRLZI	T1,{the value to output}
;	HRRI	T1,{the mask to apply}
;	PUSHJ	P,.TMOHW
;	 * Return *
; Uses:	T1-3

IFE <TF%MON-TF%T10>,<
.TMOHW::TXCN	T1,WD%RIT		; Make mask bit 0 if not wild
	PJRST	.TASTR			; Type * if all wild
	MOVE	T2,T1			; Move to convenient place
	MOVX	T3,^D6			; Set loop count
TMOHW1:	SETZ	T1,			; Clear accumulator
	LSHC	T1,^D3			; Position first digit
	JUMPN	T1,TMOHW3		; Go if non-zero
	SOJG	T3,TMOHW1		; Loop until all done
TMOHW2:	SETZ	T1,			; Clear accumulator
	LSHC	T1,^D3			; Get next digit
TMOHW3:	ADDX	T1,"0"			; Convert to ASCII
	TXNE	T2,^O7B17		; Check mask
	MOVX	T1,"?"			; Change to ? if wild
	PUSHJ	P,.TCHAR		; Type character
	SOJG	T3,TMOHW2		; Loop until done
	POPJ	P,			; Return >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDTTM


; .TDTTM - Type a date and time in universal format (dd-mmm-yy:hh:mm:ss)
; Call:	MOVX	T1,{the universal date/time}
;    or	MOVX	T1,.TFCUR		; Output the current date/time
;	PUSHJ	P,.TDTTM
;	 * Return *
; Uses:	T1-4

.TDTTM::CAXN	T1,.TFCUR		; Is the current date/time wanted?
	PUSHJ	P,.GTNOW##		; Yes, get the current date/time
	PUSHJ	P,.CNTDT##		; Take apart
	ADDX	T1,^D500		; Round to second for printing
	CAXG	T1,^D<24*60*60*1000>	; Past midnight?
	JRST	TDTTM1			; No, normal case
	ADDX	T2,^D1			; Was 23:59:59.835, bump day
	SUBX	T1,^D<24*60*60*1000>	; Make time 0:0:0
TDTTM1:	PUSH	P,T1			; Save time
	MOVE	T1,T2			; Position date
	PUSHJ	P,.TDATE		; Type date
	PUSHJ	P,.TCOLN		; Type colon
	POP	P,T1			; Restore time
	PJRST	.TTIME			; Type time and return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDATN


; .TDATN - Type today's date in standard format 'dd-mmm-yy'
; Call:	PUSHJ	P,.TDATN
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TDATN::DATE	T1,			; Get the current date >
IFE <TF%MON-TF%T20>,<
.TDATN::PUSHJ	P,.GTNOW##		; Get the current date and time
	PUSHJ	P,.CNTDT##		; Convert to something useful
	MOVE	T1,T2			; Get the date in the right place >
	PFALL	.TDATE			; Fall into .TDATE
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDATE


; .TDATE - Type a date in standard format 'dd-mmm-yy'
; Call:	MOVX	T1,{the 15-bit date format>
;	PUSHJ	P,.TDATE
;	 * Return *
; Uses:	T1-4

.TDATE::PUSHJ	P,.SAVE1##		; Save P1
	IDIVX	T1,^D31			; Get days
	MOVE	T4,T1			; Save rest
	MOVEI	T1,^D1(T2)		; Get days as 1-31
	PUSHJ	P,TDEC2Z		; Type in decimal
	MOVX	T1,"-"			; Type a
	PUSHJ	P,.TCHAR		;  '-'
	IDIVX	T4,^D12			; Get months
	MOVEI	T1,T3			; Get pointer to month
	MOVE	T3,@TYPMTH(P1)		; Get the first 5 character of month
	TXZ	T3,^O77777B35		; Reduce to only 3 characters
	TXO	T3,<"-"_^D8>		; Add a trailing dash
	PUSHJ	P,.TSTRG		; Type it
	MOVEI	T1,^D64(T4)		; Get year since 1900
	IDIVX	T1,^D100		; Get just years in century
	MOVE	T1,T2			; Type years
	PJRST	TDEC2Z			;  and return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TTIMN


; .TTIMN - Type the current time in standard format (hh:mm:ss)
; Call:	PUSHJ	P,.TTIMN
;	 * Return *
; Uses:	T1-4

; Warning:  This routine truncates the time; it will print 15:59:59.995
;	   as 15:59:59, not 16:00:00.  This is because a round up could
;	   cause the day to increment and this routine doesn't know the
;	   day (it has probably already been printed).  The caller of
;	   this routine must make sure the time has already been rounded
;	   to the nearest second himself.  See the code at .TDTTM for an
;	   example.

IFE <TF%MON-TF%T10>,<
.TTIMN::MSTIME	T1,			; Get the current time >
IFE <TF%MON-TF%T20>,<
.TTIMN::PUSHJ	P,.GTNOW##		; Get the current date and time
	PUSHJ	P,.CNTDT##		; Convert the something useful >
	PFALL	.TTIME			; Fall into .TTIME
	$TOC	.TSUPT -- .TYPER Support Routines -- .TTIME


; .TTIME - Type a time in standard format (hh:mm:ss)
; Call:	MOVX	T1,{the time is milliseconds since midnight}
;	PUSHJ	P,.TTIME
;	 * Return *
; Uses:	T1-4

; Warning:  This routine truncates the time; it will print 15:59:59.995
;	   as 15:59:59, not 16:00:00.  This is because a round up could
;	   cause the day to increment and this routine doesn't know the
;	   day (it has probably already been printed).  The caller of
;	   this routine must make sure the time has already been rounded
;	   to the nearest second himself.  See the code at .TDTTM for an
;	   example.

.TTIME::IDIV	T1,TYPHOR		; Get hours
	MOVE	T4,T2			; Save rest
	PUSHJ	P,TDEC2Z		; Type two digits
	PUSHJ	P,.TCOLN		; Type colon
	MOVE	T1,T4			; Restore rest
	IDIV	T1,TYPMNT		; Get minutes
	MOVE	T4,T2			; Save rest
	PUSHJ	P,TDEC2Z		; Type two digits with 0 filler
	PUSHJ	P,.TCOLN		; Type colon
	MOVE	T1,T4			; Restore the rest
	IDIV	T1,TYPSEC		; Get seconds
	PFALL	TDEC2Z			; Fall into TDEC2Z
	$TOC	.TSUPT -- .TYPER Support Routines -- TDEC2Z


; TDEC2Z - Output at least to decimal digits with "0" fill
; Call:	MOVX	T1,{the number to output}
;	PUSHJ	P,TDEC2Z
;	 * Return *
; Uses:	T1-3

TDEC2Z:	MOVX	T2,"0"			; Fill with 0 and
	PFALL	.TDEC2			;  fall into .TDEC2
	$TOC	.TSUPT -- .TYPER Support Routines -- .TDEC2


; .TDEC2 - Type at least two decimal digits
; Call:	MOVX	T1,{the number to output}
;	MOVEI	T2,<The fill character>
;	PUSHJ	P,.TDEC2
;	 * Return *
; Uses:	T1-3

.TDEC2::JUMPL	T1,.TDECW		; Jump if negative
	CAXLE	T1,^D9			; See if one digit
	PJRST	.TDECW			; No--just output
	EXCH	T1,T2			; Get filler
	PUSHJ	P,.TCHAR		; Type
	MOVEI	T1,"0"(T2)		; Convert digit
	PJRST	.TCHAR			; Output it and return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TFCHR


; .TFCHR - Type a possible 'Funny' character
; Call:	MOVX	T1,{the 'Funny' character to output}
;	PUSHJ	P,.TFCHR
;	 * Return *
; Uses:	T1-2

.TFCHR::CAXL	T1," "			; See if control character
	JRST	TFCHR3			; No--proceed

	MOVSI	T2,-FUNLEN		; Set scan loop
TFCHR1:	HLL	T1,FUNTBL(T2)		; Make T1 agree
	CAME	T1,FUNTBL(T2)		; See if match
	AOBJN	T2,TFCHR1		; No--loop
	JUMPGE	T2,TFCHR2		; No match--proceed
	PUSHJ	P,.TLANG		; Match, type indicator
	HLLZ	T1,FUNTBL(T2)		; Get mnemonic
	PUSHJ	P,.TSIXN		; Type it
	PJRST	.TRANG			; Close field and return

TFCHR2:	ADDX	T1,"@"			; Convert and
	PUSH	P,T1			;  save character
	MOVX	T1,"^"			; Set indicator
	JRST	TFCHR5			;  and go finish up

TFCHR3:
IFE <TF%SCN-TF%ON>,<
	CAXGE	T1,^O4000		; See if GUIDE word
	JRST	TFCHR4			; No--proceed
	SUBX	T1,^O4000		; Remove offset
	PUSH	P,GUIDT.(T1)		; Save GUIDE word
	MOVX	T1,"'"			; Yes--indicate
	PUSHJ	P,.TCHAR		; Output open quote
	POP	P,T1			; Get GUIDE word
	PUSHJ	P,.TSIXN		; Output as SIXBIT
	MOVX	T1,"'"			; Type closing
	PJRST	.TCHAR			;  quote and return >

TFCHR4:	CAXGE	T1,"`"			; See if lower case
	PJRST	.TCHAR			; No--just type it
	SUBX	T1,"a"-"A"		; Yes--convert to upper
	PUSH	P,T1			; Save for a minute
	MOVX	T1,"'"			; Set indicator
TFCHR5:	PUSHJ	P,.TCHAR		; Issue indicator
	POP	P,T1			; Restore fixed character
	PJRST	.TCHAR			;  and type it
	$TOC	.TSUPT -- .TYPER Support Routines -- .TVERW


; .TVERW - Type a word in version number format
; Call:	MOVX	T1,{the version number to output}
;    or	MOVX	T1,.TFCUR		; Output the contents of .JBVER
;					;  or the entry vector
;	PUSHJ	P,.TVERW
;	 * Return *
; Uses:	T1-4

.TVERW::PUSHJ	P,.SAVE1##		; Save P1

IFE <TF%MON-TF%T10>,<
	CAXN	T1,.TFCUR		; Is the default wanted?
	MOVE	T1,.JBVER##		; Yes, get the program version number >
IFE <TF%MON-TF%T20>,<
	CAXE	T1,.TFCUR		; Is the default wanted?
	JRST	TVERW1			; No, use what I have
	MOVX	T1,.FHSLF		; Get the address of
	GEVEC%				;  my entry vector
	HLRZ	T1,T2			; Get it's length
	CAIE	T1,(JRST)		; Is it a TOPS-10 entry vector?
	CAXGE	T1,EV.VER+^O1		; No, does it contain a version number?
	SKIPA	T1,.JBVER##		; No, get the program version number
	MOVE	T1,EV.VER(T2)		; Get it from the entry vector >

TVERW1:	MOVE	T4,T1			; Put in safe place
	LDB	T1,[$POINT T4,VN%VER]	; Get major version
	CAXE	T1,^O0			; If non-zero,
	PUSHJ	P,.TOCTW		;  print in octal
	SETZB	T1,P1			; Clear the high order and the lower case flag
	LDB	T2,[$POINT T4,VN%MIN]	; Get minor version
	CAXE	T2,^O0			; Skip if no minor version number
	PUSHJ	P,.TALPH		; Output the minor version number
	HRRZ	T1,T4			; Get the edit number
	CAXE	T1,^O0			; Skip if no edit number
	PUSHJ	P,.TOCPW		; Print as octal in parens
	LDB	T2,[$POINT T4,VN%WHO]	; Get who field
	JUMPE	T2,.POPJ##		; If non-zero,
	MOVN	T1,T2			;  negate and print
	PJRST	.TOCTW			;  in octal
	$TOC	.TSUPT -- .TYPER Support Routines -- .TBLOK and .TCORW


; .TBLOK - Type a number in blocks
; .TCORW - Type a number in core size
; Call:	MOVX	T1,{the size to output}
;	PUSHJ	P,.TBLOK/.TCORW
;	 * Return *
; Uses:	T1-4

.TBLOK::MOVE	T4,["B",,^O177]		; Preset for blocks
	JRST	TCORW2			;  and go test

.TCORW::JUMPE	T1,TCORW3		; If null, do in words
	HRLOI	T2,-^O2			; Set up to get for KA10/PDP6
	AOBJN	T2,TCORW1		; Jump if not KA10/PDP6
	SKIPA	T4,["K",,^O1777]	; Else, indicate K
TCORW1:	MOVE	T4,["P",,^O777]		; Indicate pages
TCORW2:	TRNE	T1,(T4)			; See if round units
	JRST	TCORW3			; No--do in words
	IDIVI	T1,^O1(T4)		; Yes--divide by units
	SKIPA				;  and output
TCORW3:	MOVSI	T4,"W"			; Indicate words
	PUSHJ	P,.TDECW		; Issue size
	HLRZ	T1,T4			; Get size unit indicator
	PJRST	.TCHAR			; Issue that and return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TCRLF


; .TCRLF - Type a carriage return/line feed
; Call:	PUSHJ	P,.TCRLF
;	 * Return *
; Uses:	No ACs

IFE <TF%SCN-TF%ON>,<
.TCRLF::PUSH	P,T1			; Save T1
	MOVX	T1,.CHCRT		; Get carriage return
	PUSHJ	P,.TCHAR		; Type it
	MOVX	T1,.CHLFD		; Get line feed
	PUSHJ	P,.TCHAR		; Type it and return
	POP	P,T1			; Restore T1
	POPJ	P,			; Return >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TPPNW


; .TPPNW - Type a PPN
; Call:	MOVX	T1,{the PPN to output}
;    or	MOVX	T1,.TFCUR		; Output my logged-in PPN
;	PUSHJ	P,.TPPNW
;	 * Return *
; Uses:	T1-3

IFE <TF%MON-TF%T10>,<
.TPPNW::CAXE	T1,.TFCUR		; Is my current PPN wanted?
	JRST	TPPNW1			; No, output the PPN
	HRROI	T1,.GTPPN		; Get my current
	GETTAB	T1,			;  logged-in PPN
	 MOVX	T1,.TFCUR		; Give'm what they wanted
TPPNW1:	MOVE	T2,T1			; Find a safer place for PPN
	PUSHJ	P,.TLBRK		; Type left bracket
	SKIPGE	T1,T2			; Is it a SIXBIT PPN?
	JRST	[PUSHJ P,.TSIXN		 ; Yes, output it
		 JRST  .TRBRK]		 ; Go type right bracket
	PUSHJ	P,.TXWDW		; Type XWD
	PJRST	.TRBRK			; Go type right square bracket >
IFE <TF%MON-TF%T20>,<
.TPPNW::MOVX	T1,<SIXBIT ~PPN~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TSIXN


; .TSIXN - Type a SIXBIT word
; Call:	MOVX	T1,{the SIXBIT word to output}
;	PUSHJ	P,.TSIXN
;	 * Return *
; Uses:	T1-2

.TSIXN::MOVE	T2,T1			; Move parameter
TSIXN1:	JUMPE	T2,.POPJ##		; Loop until only blanks left
	SETZ	T1,			; Clear next character
	LSHC	T1,^D6			; Get next character
	ADDX	T1," "-' '		; Convert to ASCII
	PUSHJ	P,.TCHAR		; Type it
	JRST	TSIXN1			; Loop some more
	$TOC	.TSUPT -- .TYPER Support Routines -- .TXWDW


; .TXWDW - Type two octal half-words
; Call:	MOVX	T1,{the word to output}
;	PUSHJ	P,.TXWDW
;	 * Return *
; Uses:	T1-3

.TXWDW::PUSH	P,T1			; Preserve parameter
	HLRZ	T1,T1			; Get the left half
	PUSHJ	P,.TOCTW		; Output in octal
	PUSHJ	P,.TCOMA		; Issue comma
	POP	P,T1			; Restore parameter
	HRRZ	T1,T1			; Get the right half
	PFALL	.TOCTW			; Fall into .TOCTW
	$TOC	<.TSUPT -- .TYPER Support Routines -- .TOCTW, .TDECW and .TRDXW>

; .TDECW - Type A signed decimal number
; .TOCTW - Type A signed octal number
; .TRDXW - Type A signed number (radix in T3)
; Call:	MOVX	T1,{the integer number to output}
;	PUSHJ	P,.TOCTW/.TDECW/.TRDXW
;	 * Return *
; Uses:	T1-3

.TOCTW::SKIPA	T3,[^O10]		; Initialize for octal radix
.TDECW::MOVX	T3,^D10			; Initialize for decimal radix

.TRDXW::JUMPGE	T1,TRDXW1		; Check for negative
	MOVE	T2,T1			; Save away parameter
	MOVX	T1,"-"			; Yes--get minus
	PUSHJ	P,.TCHAR		; Print it
	MOVE	T1,T2			; Restore number
TRDXW1:	IDIV	T1,T3			; Divide by radix
	MOVMS	T2			; Get magnitude
	HRLM	T2,(P)			; Save remainder
	CAXE	T1,^O0			; See if anything left
	PUSHJ	P,TRDXW1		; Else recurse via stack
	HLRZ	T1,(P)			; Get back a digit
	ADDX	T1,"0"			; Convert to ASCII
	CAXLE	T1,"9"			; See if overflow digits
	ADDX	T1,"A"-"9"-^O1		; Yes--switch to alphabetics
	PJRST	.TCHAR			; Type it and return
	$TOC	.TSUPT -- .TYPER Support Routines -- .TSYMW


; .TSYMW - Type a RADIX-50 symbol, including code bits
; Call:	MOVX	T1,{the RADIX-50 symbol to output}
;	PUSHJ	P,.TSYMW
;	 * Return *
; Uses:	T1-3

IFE <TF%SCN-TF%ON>,<
.TSYMW::PUSH	P,T1			; Save symbol for RADIX-50 part
	LDB	T1,[POINT ^D4,(P),^D3]	; Grab code bits
	LSH	T1,^D2			; Left-justify in 2 digits
	IDIVX	T1,^O10			; Separate the digits
	ADDX	T1,"0"			; Make first digit ASCII
	PUSHJ	P,.TCHAR		; Type it
	MOVEI	T1,"0"(T2)		; Put ASCII 2nd digit in T1
	PUSHJ	P,.TCHAR		; Type
	PUSHJ	P,.TSPAC		; Space over one
	POP	P,T1			; Recover symbol
	PFALL	.TR50W			; Output the symbol name >
	$TOC	.TSUPT -- .TYPER Support Routines -- .TR50W


; .TR50W - Type a RADIX-50 portion of symbol only
; Call:	MOVX	T1,{the RADIX-50 symbol to output}
;	PUSHJ	P,.TR50W
;	 * Return *
; Uses:	T1-3

.TR50W::PUSHJ	P,.R50SX		; Convert RADIX-50 to SIXBIT
	PJRST	.TSIXN			; Type as SIXBIT
	$TOC	.TSUPT -- .TYPER Support Routines -- .R50SX


; .R50SX -- Convert a RADIX-50 to SIXBIT
; Call:	MOVX	T1,{the RADIX-50 symbol to convert}
;	PUSHJ	P,.R50SX
;	 * Return - The SIXBIT equivalent of the symbol in T1 *
; Uses:	T1-3

.R50SX::TXZ	T1,^O47B3		; Zap code bits
	SETZ	T3,			; Start with zero answer
R50SX1:	IDIVX	T1,^O50			; Extract next character
	JUMPE	T2,R50SX2		; Leave imbedded blanks alone
	CAXLE	T2,^O12			; Letter or digit?
	ADDX	T2,^O7			; Letter--add 26
	ADDX	T2,^O17			; Digit--add 17
	CAXE	T2,^O75			;  % ??
	CAXN	T2,^O74			; Or $ ??
	SUBX	T2,^O70			; Yes--special case
	CAXN	T2,^O73			;  . ??
	MOVX	T2,'.'			; Yes--last special case
R50SX2:	LSHC	T2,-^D6			; Store this char in answer
	JUMPN	T1,R50SX1		; Loop back till done
	MOVE	T1,T3			; Put answer in right place
	POPJ	P,			; Done
	$TOC	<.TSUPT -- .TYPER Support Routines -- .TZOHW, .TZOFW, .TBOHW and .TBOFW>


; .TZOHW - Type a zero filled unsigned octal half word
; .TZOFW - Type a zero filled unsigned octal full word
; .TBOHW - Type a blank filled unsigned octal half word
; .TBOFW - Type a blank filled unsigned octal full word
; Call:	MOVX	T1,{the integer number to output}
;	PUSHJ	P,.TZOHW/.TZOFW/.TBOHW/.TBOFW
;	 * Return *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TZOHW::HRRZ	T1,T1			; Make sure LH is zero
	SKIPA	T4,[^D6]		; Set 6 character width
.TZOFW::MOVX	T4,^D12			; Set 12 character field
	MOVX	T2,"0"			; Set zero filled
	JRST	.TFOCW			; Join common routine

.TBOHW::HRRZ	T1,T1			; Make sure LH is zero
	SKIPA	T4,[^D6]		; Field width 6 for half word
.TBOFW::MOVX	T4,^D12			; Field width 12 for full word
	MOVX	T2," "			; Set blank fill
	PFALL	.TFOCW			; Fall into .TFOCW >
	$TOC	<.TSUPT -- .TYPER Support Routines -- .TFOCW, .TFDCW and .TFRXW>


; .TFOCW - Type an unsigned octal field
; .TFDCW - Type an unsigned decimal field
; .TFRXW - Type an unsigned field (radix in T3)
; Call:	MOVX	T1,{the integer number to output}
;	MOVX	T2,{the fill character}
;	MOVX	T4,{the field width, 0 means variable width}
;	PUSHJ	P,.TFOCW/.TFDCW/.TFRXW
;	 * Return *
; Uses:	T1-4

.TFOCW::SKIPA	T3,[^O10]		; Set for octal radix
.TFDCW::MOVX	T3,^D10			; Set for decimal radix

.TFRXW::HRL	T3,T2			; Save fill in LH(T3)
TFRXW1:	SUBX	T4,^D1			; One more digit output
	MOVE	T2,T1			; Set low order part of dividend
	SETZ	T1,			;  and high order part
	DIVI	T1,(T3)			; Divide unsigned by radix
	HRLM	T2,(P)			; Store digit in standard place
	JUMPE	T1,TFRXW3		; Go output fill if done
	PUSHJ	P,TFRXW1		; Else recurse via stack
TFRXW2:	HLRZ	T1,(P)			; Retrieve next digit
	ADDX	T1,"0"			; Convert to ASCII
	CAXLE	T1,"9"			; Beyond digits?
	ADDX	T1,"A"-"9"-^O1		; Yes, make into correct letter
	PJRST	.TCHAR			; Type it out and unwind

TFRXW3:	HLRZ	T1,T3			; Retrieve fill character
TFRXW4:	SOJL	T4,TFRXW2		; Go print number if fill done
	PUSHJ	P,.TCHAR		; Else print next fill char
	JRST	TFRXW4			; Try again
	$TOC	.TSUPT -- .TYPER Support Routines -- .TOCPW


; .TOCPW - Type an octal number in parentheses
; Call:	MOVX	T1,{the octal number to output}
;	PUSHJ	P,.TOCPW
;	 * Return *
; Uses:	T1-3

.TOCPW::MOVE	T2,T1			; Save the number to type
	PUSHJ	P,.TLPAR		; Issue as
	MOVE	T1,T2			;  octal
	PUSHJ	P,.TOCTW		;  within
	PJRST	.TRPAR			;  parentheses
	$TOC	.TSUPT -- .TYPER Support Routines -- .TSTRG


; .TSTRG - Type an ASCIZ string
; Call:	MOVX	T1,{the address of the ASCIZ string}
;	PUSHJ	P,.TSTRG
;	 * Return *
; Uses:	T1

.TSTRG::PUSHJ	P,.SAVE1##		; Save P1
	HRLI	T1,(POINT 7)		; Convert address to pointer
	SKIPA	P1,T1			; Store in safe place
TSTRG1:	PUSHJ	P,.TCHAR		; Output character
	ILDB	T1,P1			; Get the next character
	JUMPN	T1,TSTRG1		; Loop until done
	POPJ	P,			; Return
	$TOC	.TSUPT -- .TYPER Support Routines -- Some Single Character Routines


; .TASTR - Type an ASCII asterisk
; .TBAR  - Type an ASCII vertical bar
; .TCOLN - Type an ASCII colon
; .TCOMA - Type an ASCII comma
; .TDOT  - Type an ASCII period
; .TLANG - Type an ASCII left angle
; .TLBRK - Type an ASCII left bracket
; .TLPAR - Type an ASCII left parenthesis
; .TRANG - Type an ASCII right angle
; .TRBRK - Type an ASCII right bracket
; .TRPAR - Type an ASCII right parenthesis
; .TSPAC - Type an ASCII space
; .TTABC - Type an ASCII tab
; Call:	PUSHJ	P,.Txxxx
;	 * Return *
; Uses:	T1

.TASTR::MOVX	T1,"*"			; Type *
	PJRST	.TCHAR
.TBAR::	MOVX	T1,"|"			; Type |
	PJRST	.TCHAR
.TCOLN::MOVX	T1,":"			; Type :
	PJRST	.TCHAR
.TCOMA::MOVX	T1,","			; Type , (comma)
	PJRST	.TCHAR
.TDOT::	MOVX	T1,"."			; Type . (dot)
	PJRST	.TCHAR
.TLANG::MOVX	T1,.CHLAB		; Type <
	PJRST	.TCHAR
.TLBRK::MOVX	T1,.CHLSB		; Type [
	PJRST	.TCHAR
.TLPAR::MOVX	T1,.CHLPR		; Type (
	PJRST	.TCHAR
.TRANG::MOVX	T1,.CHRAB		; Type >
	PJRST	.TCHAR
.TRBRK::MOVX	T1,.CHRSB		; Type [
	PJRST	.TCHAR
.TRPAR::MOVX	T1,.CHRPR		; Type )
	PJRST	.TCHAR
.TSPAC::MOVX	T1," "			; Type space
	PJRST	.TCHAR
.TTABC::MOVX	T1,.CHTAB		; Type tab
	PJRST	.TCHAR
	$TOC	.TSUPT -- .TYPER Support Routines -- .TVRBO


; .TVRBO - Get the current verbosity level
; Call:	PUSHJ	P,.TVRBO
;	 * Return here - The verbosity level is in T4 *
; Uses:	T1 and T4

.TVRBO::SKIPN	T4,TB.VRB(TB)		; Is the verbosity
	SKIPE	T4,TB.VRB+.TYDDB##	;  level available?
	POPJ	P,			; Yes, return

IFE <TF%SCN-TF%ON>,<
	PUSHJ	P,.VERBO##		; Go get the verbosity level
	MOVE	T4,T1			; Put it in the right place >
IFE <TF%SCN-TF%OFF>,<
IFE <TF%MON-TF%T10>,<
	HRROI	T4,.GTWCH		; Get the users
	GETTAB	T4,			;  watch bits
	 SETZ	T4,			; Assume 0 then
	TXNE	T4,JW.WMS		; Skip if none of verbosity bits are set
	TXNE	T4,JW.WCN		; Skip if continuation isn't wanted
	TXO	T4,JW.WPR!JW.WFL	; Assume prefix and first-line
	ANDX	T4,JW.WMS		; Clear any extraneous bits
	LSH	T4,-<$ALIGN(JW.WMS)>	; Right justify it >
IFE <TF%MON-TF%T20>,<
	MOVX	T4,%TFWPR!%TFWFL	; Set the default verbosity level >>
	POPJ	P,			; Return
	$TOC	.TSUPT -- The End


	$PRGEND				; End of '.TSUPT'	$TOC	.TSUPS -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TSUPS

	$INIT	.TSUPS - The Support Modules for .TYPES,.TYBAS,\'TF%COD


; Force the low segment to be loaded

	EXTERN	.TDATA			; Request the TYPER low segment
	$TOC	.TSUPS -- .TYBAS - BAS Support Module


; .TYBAS - TYPES function to change the database to use
; Call:	MOVX	T1,{the address of the database to use}
;	HRLI	T1,{the function to perform}
;	PUSHJ	P,.TYBAS
;	 * Return - The old database address is in T1 *
; Uses:	T1

.TYBAS::JUMPL	T1,TYPB80		; Jump if several database to initialize
	PUSH	P,T1			; Save the database address
	MOVE	TB,T1			; Move to a safer place
	TXNN	TB,WD%RIT		; Skip if not back to the default
	HRRI	TB,.TYDDB##		; Point to the default database
	MOVE	P2,TB.FLG(TB)		; Get the flags
	HLRZS	T1			; Get the function code
	CAILE	T1,TYPBFS		; Skip if a valid function
	SETZ	T1,			; Assume a no-op then
	PJRST	@TYPBFT(T1)		; Perform the requested function

TYPBFT:	TYPB00				; (0) Set the database
	TYPB10				; (1) Clear and set the database
	TYPB20				; (2) Initialize the database
	TYPB30				; (3) Reset and set the database
TYPBFS==.-TYPBFT-^O1			; The length of the function block

		$CONTINUE		; Continued on the next page
; Here to set a database

TYPB00:	POP	P,T1			; Restore the database address
	TXZ	T1,WD%LFT		; Clear the function
	EXCH	T1,.TYBSA##		; Get the previous database
	POPJ	P,			; Return

		$CONTINUE		; Continued on the next page
; Here to clear a database

TYPB10:	SETZB	P2,TB.FLG(TB)		; Clear
	HRLZI	T1,TB.FLG(TB)		;  the
	HRRI	T1,TB.FLG+1(TB)		;  data-
	BLT	T1,TB.LEN(TB)		;  base
	PJRST	TYPB00			; Set the database and return

		$CONTINUE		; Continued on the next page
; Here to initialize a database

IFN <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
TYPB20:	ADJSP	P,-^O1			; Clean up the stack >
IFE <<TF%CPU-TF%PDP>*<TF%CPU-TF%KA1>*<TF%CPU-TF%KI1>>,<
TYPB20:	POP	P,(P)			; Clean up the stack >
	AOS	(P)			; Give a skip return
	PJRST	TYPB90			; Initialize the database and return

		$CONTINUE		; Continued on the next page
; Here to reset a database

TYPB30:	PUSHJ	P,TYPB90		; Go reset/initialize the database
	PJRST	TYPB00			; Set the database and return

		$CONTINUE		; Continued on the next page
; Here to initialize a set of databases

TYPB80:	MOVE	T4,T1			; Put the database pointer in a safe place
TYPB81:	MOVE	TB,(T4)			; Get the database address
	TXNN	TB,WD%RIT		; Skip if not back to the default
	MOVEI	TB,.TYDDB##		; Point to the default database
	MOVE	P2,TB.FLG(TB)		; Get the flags
	PUSHJ	P,TYPB90		; Initialize the database
	AOBJN	T4,TYPB81		; Loop until all have been initialized
	PJRST	.POPJ1##		; Give a skip return

		$CONTINUE		; Continued on the next page
; Here to initialize a database

TYPB90:	TXZ	P2,%TBINF!%TBSUP!%TBCON	; Clear some flags
	LDB	T1,[$POINT TB.FLG(TB),%TBCMP]  ; Reset the
	PUSHJ	P,.TYCMP		       ;  space compression
	MOVE	T1,TB.EMP(TB)		; Reset the
	PUSHJ	P,.TYEMP		;  empty routine
	MOVE	T1,TB.HOR(TB)		; Reset the
	PUSHJ	P,.TYHOR		;  horizonal justification
	MOVE	T1,TB.MSG(TB)		; Reset the
	PUSHJ	P,.TYMSG		;  message level
	MOVE	T1,TB.CHR(TB)		; Reset the
	PUSHJ	P,.TYOUT		;  output routine
	MOVE	T1,TB.SYS(TB)		; Reset the
	PUSHJ	P,.TYSYS		;  system prefix
	MOVE	T1,TB.TIM(TB)		; Reset the
	PUSHJ	P,.TYTIM		;  time stamp
	MOVE	T1,TB.VER(TB)		; Reset the
	PUSHJ	P,.TYVER		;  vertical justification
	MOVE	T1,TB.VRB(TB)		; Reset the
	PJRST	.TYVRB			;  verbosity level
	$TOC	.TSUPS -- .TYBUG - BUG Support Module


; .TYBUG - TYPES function to output an bug message
; Call:	MOVX	P3,{the address of the $TYPES argument block}
;	PUSHJ	P,.TYBUG
;	 * Always skip returns *
; Uses:	T1-2

.TYBUG::HLLZ	T2,TS.BUG(P3)		; Set the error
	EXCH	T2,TB.SYS+.TYEDB##	;  prefix
	MOVX	T1,.TFPRE		; Get the PC of the error
	$TYPE	(F,PLE,$OPC,<Program logic error, PC:|>,N,,E)
	EXCH	T2,TB.SYS+.TYEDB##	; Restore the error prefix
	HRRZ	T1,TS.BUG(P3)		; Get the relocatable PC of the error
	CAXE	T1,^O777777		; Skip if not relocatable
	$TYPE	(N,,$OPC,< (|')>,N,,E)
	$TYPE	(N,,$NON,,,P1,E)	; Output a CR-LF and return
	$TOC	.TSUPS -- .TYCMP - CMP Support Module


; .TYCMP - TYPES function to enable/disable space compression
; Call:	MOVX	T1,^O0			; Don't space compress
;    or MOVX	T1,-^O1			; Do space compression
;	MOVX	P2,{the TYPER flags}
;	PUSHJ	P,.TYCMP
;	 * Return - The old value is in T1 *
; Uses:	T1-2 and P2

.TYCMP::JUMPE	T1,[TXZE  P2,%TBCMP	 ; Clear the space compression flag
		    SETO  T1,		 ; Inform user of the old value
		    PJRST .TYVHT]	 ; Go test the space compression flag
	TXON	P2,%TBCMP		; Set the space compression flag
	SETZ	T1,			; Inform user of the old value
	MOVX	T2,<-^O10,,^O0>		; Setup the space com-
	MOVEM	T2,TB.CMP(TB)		;  pression counter
	PJRST	.TYVHT			; Go test the space compression flag
	$TOC	.TSUPS -- .TYCOL - COL Support Module


; .TYCOL - TYPES function to get the current column count
; Call:	MOVX	P2,{the TYPER flags}
;	PUSHJ	P,.TYCOL
;	 * Return - The column width is in T1 *
; Uses:	T1

.TYCOL::LDB	T1,[$POINT P2,TB%COL]	; Get the current column
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYEMP - EMP Support Module


; .TYEMP - TYPES function to set the empty buffer routine
; Call:	MOVX	T1,{the address of the buffer emptying routine}
;	PUSHJ	P,.TYEMP
;	 * Return - The old empty routine is in T1 *
; Uses:	T1

.TYEMP::TXZ	T1,WD%LFT		; Clear any junk
	EXCH	T1,TB.EMP(TB)		; Save for later
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYERR - ERR Support Module


; .TYERR - TYPES function to enable/disable the incrementing of .JBERR
; Call:	MOVX	T1,^O0			; Don't increment .JBERR on fatal errors
;    or	MOVX	T1,-^O1			; Increment .JBERR on fatal errors
;	MOVX	P2,{the TYPER flags}
;	PUSHJ	P,.TYERR
;	 * Return - The old value is in T1 *
; Uses:	T1 and P2

.TYERR::JUMPE	T1,[TXZE P2,%TBERR	 ; Clear the error flag
		    SETO T1,		 ; Inform user of the old value
		    POPJ P,]		 ; Return
	TXON	P2,%TBERR		; Set the error flag
	SETZ	T1,			; Inform user of the old value
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYESN - ESN Support Module


; .TYESN - Change the external string number
; Call:	MOVX	T1,{the default external string number}
;    or	MOVX	T1,.TFCUR		; Get the current external string number
;	PUSHJ	P,.TYESN
;	 * Return - the old value is in T1 *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TYESN::CAXE	T1,.TFCUR		; Is this read-only?
	TXZA	T1,WD%LFT		; No, clear the left half and skip
	SKIPA	T1,.TYDEN##		; Get the external string number
	EXCH	T1,.TYDEN##		; Exchange the external string number
	POPJ	P,			; Return >
IFE <TF%MON-TF%T20>,<
.TYESN::MOVE	T4,T1			; Put in a safe place
	MOVX	T1,.FHSLF		; Get my current external
	GETER%				;  string number
	 ERJMP	TYESN1			; Punt off any errors
	SKIPA	T3,T2			; Save the external string number away
TYESN1:	MOVX	T3,LSTRX1		; No errors until now
	CAXN	T4,.TFCUR		; Is this read only?
	JRST	TYESN2			; Yes, go return the value
	MOVX	T1,.FHSLF		; Set my default
	HRRZ	T2,T4			;  external string
	SETER%				;  number
	 $ERROR	(F,USE,$ERS,<Unable to set the external string number (|)>,,A,T,[0])
TYESN2:	HRRZ	T1,T3			; Get the error string number
	POPJ	P,			; Return >
	$TOC	.TSUPS -- .TYEXT - EXT Support Module


; .TYEXT - TYPES function to add additional external string files
; Call:	MOVX	T1,{the address of the SCAN block}
;	PUSHJ	P,.TYEXT		; Add the new external string file
;	 * Return - The error code or .TFNON (no errors encountered) in the
;		    right half T1 and JFN in the left half *
; Uses:	T1-4

.TYEXT::PUSHJ	P,.SAVE1##		; Save P1

	MOVSI	P1,-TF%ESF		; Any
TYEXT1:	SKIPE	.TYRNG##(P1)		;  available
	AOBJN	P1,TYEXT1		;  slots?
	JUMPGE	P1,TYEXT5		; No, inform the caller

			     $CONTINUE	; Continued on the next page
IFE <TF%MON-TF%T10>,<
	$VARIA	(LOCAL,<<TYPPRE,ES.SIZ>,<TYPFLP,^O7>,<TYPLKP,^O4>,<TYPPTH,^O11>>)

	PUSHJ	P,.LOCAT##		; Convert
	HRLZI	T2,^O7			;  SCAN
	HRRI	T2,TYPFLP		;  block
	MOVEI	T3,TYPLKP		;  into
	MOVEI	T4,TYPPTH		;  FILOP.
	PUSHJ	P,.TSTPB##		;  block
	 JRST	TYEXT6			; A wild card was found

	MOVX	T1,FO.PRV!FO.ASC!.FORED	; Read the
	MOVEM	T1,TYPFLP+.FOFNC	;  file
	MOVX	T1,.IODMP			   ; Dump mode
	DPB	T1,[$POINT TYPFLP(.FOIOS),IO.MOD]  ;  I/O
	HRLZI	T1,^O7			; Does the
	HRRI	T1,TYPFLP		;  file
	FILOP.	T1,			;  exists?
	 JRST	TYEXT6			; No, inform the user

	LDB	T1,[$POINT TYPFLP(.FOFNC),FO.CHN]  ; Get the I/O
	DPB	T1,[$POINT .TYCHN##(P1),FO.CHN]	   ;  channel

	MOVE	T1,.TYCHN##(P1)		; Can I
	ADDX	T1,.FOINP		;  read
	MOVEM	T1,TYPFLP+.FOFNC	;  in the
	MOVEI	T1,T2			;  external
	MOVEM	T1,TYPFLP+^O1		;  string
	HRLZI	T2,-ES.SIZ		;  preamble
	HRRI	T2,TYPPRE-^O1		;  to get
	SETZ	T3,			;  range
	HRLZI	T1,^D2			;  of the
	HRRI	T1,TYPFLP		;  external
	FILOP.	T1,			;  strings?
	 JRST	TYEXT6			; No, can't read the string file >

			     $CONTINUE	; Continued on the next page
IFE <TF%MON-TF%T20>,<
	$VARIA	(LOCAL,<<TYPPRE,ES.SIZ>>)

	PUSHJ	P,.LOCAT##		; Get the address of the SCAN block
	PUSHJ	P,.TSTPB##		; File specified contain wild cards?
	 JRST	TYEXT6			; Yes, inform the caller

	HRROI	T2,.FXFIL(T1)		; Does the
	MOVX	T1,GJ%OLD!GJ%SHT	;  file
	GTJFN%				;  exist?
	 ERJMP	TYEXT6			; No, inform the caller
	HRRZM	T1,.TYCHN##(P1)		; Save the JFN

	MOVX	T2,$INSVL(^D36,OF%BSZ)!OF%RD ; Can the file
	OPENF%				     ;  be read?
	 ERJMP	TYEXT6			     ; No, inform the caller

	MOVE	T1,.TYCHN##(P1)		; Can I read in the
	MOVEI	T2,TYPPRE		;  external string
	TXO	T2,<POINT 36>		;  preamble to get
	MOVX	T3,-ES.SIZ		;  range of the
	SIN%				;  external strings?
	 ERJMP	TYEXT6			; No, can't read the string file >

			     $CONTINUE	; Continued on the next page
	$MOVE	T1,ES.FMT,TYPPRE	; Is this current external
	CAXE	T1,EXT.VN		;  string format type?
	JRST	TYEXT7			; No, inform the user

	$MOVE	T1,ES.MIN,TYPPRE	; Get the minimum
	$MOVE	T2,ES.MAX,TYPPRE	; Get the maximum
	CAXE	T2,^O0			; Is the maximum zero?
	CAMGE	T2,T1			; No, is maximum larger than minimum?
	JRST	TYEXT3			; No, inform the caller

	PUSHJ	P,.TYFND		; Is the minimum in another file?
	 JRST	TYEXT4			; No, good they doesn't over lap
TYEXT2:	SKIPA	T3,[.TFOVR]		; Error - Files overlap
TYEXT3:	MOVX	T3,.TFRNG		; Error - Invalid range
	JRST	TYEXT8			; Inform the user
TYEXT4:	$MOVE	T1,ES.MAX,TYPPRE	; Is the maximum in
	PUSHJ	P,.TYFND		;  another file?
	 SKIPA				; No,
	JRST	TYEXT2			; Files overlap error

	$MOVE	T1,ES.RNG,TYPPRE	; Save the range of
	MOVEM	T1,.TYRNG##(P1)		;  external strings

	MOVX	T1,.TFNON		; No errors detected
IFE <TF%MON-TF%T10>,<
	HLL	T1,.TYCHN##(P1)		; Get the I/O channel >
IFE <TF%MON-TF%T20>,<
	HRL	T1,.TYCHN##(P1)		; Get the JFN >
	POPJ	P,			; Return

			     $CONTINUE	; Continued on the next page
TYEXT5:	MOVX	T1,.TFNRA		; Error - No room available
	POPJ	P,			; Return

TYEXT6:	SKIPA	T3,[.TFUGA]		; Error - Can't read the string file
TYEXT7:	MOVX	T3,.TFIFF		; Error - Invalid format of external file

TYEXT8:
IFE <TF%MON-TF%T10>,<
	SKIPN	T2,.TYCHN##(P1)		; Release
	JRST	TYEXT9			;  any
	HRRI	T2,.FOREL		;  usuable
	MOVE	T1,[^O1,,T2]		;  I/O
	FILOP.	T1,			;  channels
	 JFCL				; Punt off any errors >
IFE <TF%MON-TF%T20>,<
	SKIPE	T1,.TYCHN##(P1)		; Release the
	CLOSF%				;  unusable JFN
	 JFCL				; Punt off any errors >

TYEXT9:	SETZM	T1,.TYCHN##(P1)		; Clear the channel/JFN used

	MOVE	T1,T3			; Let the user know
	POPJ	P,			;  happened and return
	$TOC	.TSUPS -- .TYHOR - HOR Support Module


; .TYHOR - TYPES function to set up horizontal justification
; Call:	HRLZI	T1,{the negative of the length of the tab stop table}
;	HRRI	T1,{the address of the tab stop table}
;	MOVX	P2,{the TYPER flags}
;	PUSHJ	P,.TYHOR
;	 * Return - The old tab stop information in T1 *
; Uses:	T1 and P2

.TYHOR::CAXE	T1,^O0			; Skip if no justification
	TXOA	P2,%TBHOR		; Set the justification flag
	TXZ	P2,%TBHOR		; Clear the justification flag
	TXZ	P2,TB%COL		; Clear the column counter
	EXCH	T1,TB.HOR(TB)		; Exchange the justification stuff
	PJRST	.TYVHT			; Go test the justification flags
	$TOC	.TSUPS -- .TYINI - INI Support Module


; .TYINI - TYPES function to initialize TYPER
; Call:	HRRZI	T1,{the database address or zero}
;	HRLI	T1,{the default system/program prefix or zero}
;	PUSHJ	P,.TYINI
;	 * Skip return always *
; Uses:	T1-4 and P2

.TYINI::SETZM	.TYBEG##		     ; Clear the
	MOVE	T2,[.TYBEG##,,.TYBEG##+^O1]  ;  low segment
	BLT	T2,.TYEND##		     ;  data

	MOVEI	T2,.TYDOR		; Get the primary output routine
	MOVEM	T2,TB.CHR+.TYEDB##	; Store in the error database
	MOVEM	T2,TB.CHR+.TYTDB##	; Store in the TYPER database
	MOVSI	T2,'TYP'		; Set the TYPER prefix
	MOVEM	T2,TB.SYS+.TYTDB##	;  in the TYPER database

	MOVEI	TB,.TYDDB##		; Get the default database
	HLLZM	T1,TB.SYS(TB)		; Save the system prefix
	HRLI	T1,.TFRST		; Reset the
	PUSHJ	P,.TYBAS		;  database

IFE <TF%MON-TF%T10>,<
	MOVX	T1,%CNGMT		; Get the Greenwich
	GETTAB	T1,			;  Mean Time offset
	 SETZ	T1,			; A really old monitor
	IDIVX	T1,.TFTZO		; Get the time zone >
IFE <TF%MON-TF%T20>,<
	SETO	T2,			; Get the
	SETZ	T4,			;  current
	ODCNV%				;  time
	LDB	T1,[$POINT T4,IC%TMZ]	; Get the local time zone
	TXNE	T1,^O40			; Skip if positive time zone
	TXO	T1,^O777700		; Set up for a negative time zone
	TXNE	T4,IC%ADS		; Skip if not daylight saving time
	TXO	T1,TF%DLS		; Daylight savings time >
	PUSHJ	P,.TYZON		; Go calculate the time zone adjustment
	PJRST	.POPJ1##		; Give a skip return
	$TOC	.TSUPS -- .TYLOC - LOC Support Module


; .TYLOC - TYPES function to get the contents of a location
; Call:	MOVX	T1,{the address to get the contents of}
;	PUSHJ	P,.TYLOC
;	 * Return - The contents of the address is in T1 *
; User:	T1-2

.TYLOC::PUSHJ	P,.SAVEP##		; Backup one frame
.TYLOD::PUSHJ	P,.LOCAT##		; Calculate the effective address
	MOVE	T1,(T1)			; Get the contents of the address
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYMSG - MSG Support Module


; .TYMSG - TYPES function to change the message level
; Call:	HRRZI	T1,{the default message level}
;	HRLI	T1,{the maximum message level}
;	PUSHJ	P,.TYMSG
;	 * Return - The old message level information is in T1 *
; Uses:	T1

.TYMSG::HRRZM	T1,TB.MDF(TB)		; The default message level
	HLLZM	T1,TB.MML(TB)		; The maximum message level
	EXCH	T1,TB.MSG(TB)		; Save for later
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYOCH - SCAN Support Module


; .TYOCH - Initialize the typeout routine
; Call:	MOVX	T1,{the address of output routine}
;	TXO	T1,TF%CTL		; The output is NOT going
;					;  to the controlling TTY
;	PUSHJ	P,.TYOCH
;	 * Return - The old output routine is in T1 *
; Uses:	T1

IFE <TF%SCN-TF%ON>,<
.TYOCH::PUSHJ	P,.SAVET##		; Save register TB
	PFALL	.TYOUT			; Fall into .TYOUT >
	$TOC	.TSUPS -- .TYOUT - OUT Support Module


; .TYOUT - TYPES function to change the output routine
; Call:	MOVX	T1,{the address of the output routine}
;	TXO	T1,TF%CTL		; The output is NOT going
;					;  to the controlling TTY
;	PUSHJ	P,.TYOUT		; The old value is in T1
;	 * Return - The old output routine is in T1 *
; Uses:	T1

.TYOUT::TXZ	T1,^O377777B17		; Clear some bits
	EXCH	T1,TB.CHR(TB)		; Swap output routines
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYPRM - PRM Support Module


; .TYPRM - TYPES function to send a prompt and dumps the buffer
; Call:	MOVX	T1,{the character to follow the system/program prefix}
;    or	MOVSI	T1,{the SIXBIT suffix to follow the system/progam prefix}
;	PUSHJ	P,.TYPRM
;	 * Skip returns always *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.TYPRM::SKPINL				; Clear ^O
	 JFCL				; Nothing typed yet >
IFE <TF%MON-TF%T20>,<
.TYPRM::PUSH	P,T1			; Save the prompt suffix
	MOVX	T1,.PRIOU		; Clear ^O
	RFMOD%				;  on the
	TXZE	T2,TT%OSP		;  primary
	SFMOD%				;  output
	POP	P,T1			; Restore the prompt suffix >
	PUSHJ	P,.TPFXN##		; Output the user prompt
	PUSHJ	P,.TSPAC##		; Output a space
	MOVE	P2,TB.FLG(TB)		; Get the updated flags back
	PFALL	.TYDMP			; Fall into .TYDMP
	$TOC	.TSUPS -- .TYDMP - DMP Support Module


; .TYDMP - TYPES function to dump the internal buffer
; Call:	PUSHJ	P,.TYDMP
;	 * Skip return always *
; Uses:	No ACs

.TYDMP::AOS	(P)			; Give a skip return
	SKIPN	TB.CHR(TB)		; Skip if a character routine
	JRST	[SKIPN TB.CHR+.TYDDB##	 ; Skip if a default character routine
		 PJRST .TDUMP		 ; Use the basic routine
		 SKIPE TB.EMP+.TYDDB##	 ; Skip if no default empty buffer routine
		 PJRST @TB.EMP+.TYDDB##	 ; Use the default empty routine
		 POPJ  P,]		 ; Return
	SKIPE	TB.EMP(TB)		; Skip if no empty buffer routine
	PJRST	@TB.EMP(TB)		; Use the empty routine
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYRTN - RTN Support Module


; .TYRTN - TYPES function to change the user substitution routine(s)
; Call:	HRLZI	T1,{the size of the user substitution routine table}
;	HRRI	T1,{the address of the user substitution routine table}
;	PUSHJ	P,.TYRTN
;	 * Return - The old substitution routine table information is in T1 *
; Uses:	T1-2

.TYRTN::HLRE	T2,T1			; Get the maximum user routine
	CAXLE	T2,.TRUSR		; Skip if small enough
	MOVX	T2,.TRUSR		; Assume the maximum
	ADDI	T2,<<$UR1>_-TR$SUB>	; Add in the minimum offset
	MOVEM	T2,.TYMAX##		; Save for later
	MOVEI	T2,-<<$UR1>_-TR$SUB>(T1); Get the user base
	HRRZM	T2,.TYUSE##		; Save for later
	EXCH	T1,.TYUSR##		; Get the previous value
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYSYS - SYS Support Module


; .TYSYS - TYPES function to change the system/program prefix
; Call:	HRLZI	T1,{the SIXBIT system/program prefix}
;	PUSHJ	P,.TYSYS
;	 * Return - The old prefix is in T1 *
; Uses:	T1

.TYSYS::TXZ	T1,WD%RIT		; Clear the right half
	EXCH	T1,TB.SYS(TB)		; Exchange the prefixes
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYTIM - TIM Support Module


; .TYTIM - TYPES function to enable/disable time stamps
; Call:	MOVX	T1,^O0			; Disable time stamps
;    or	MOVX	T1,-^O1			; Enable time stamps
;    or	HRROI	T1,LOC			; Enable time stamps and LOC is the address
;					;  of the SIXBIT text to be output
;    or	MOVEI	T1,LOC			; Enable time stamps and LOC is the address
;					;  of the routine to call
;	MOVX	P2,{the TYPER flags}
;	PUSHJ	P,.TYTIM
;	 * Return - The old time stamp value is in T1 *
; Uses:	T1 and P2

.TYTIM::CAXE	T1,^O0			; Skip if the user doesn't want time stamps
	TXOA	P2,%TBTIM!%TBTTS	; Set time stamps
	TXZ	P2,%TBTIM		; Clear time stamps
	TXZ	P2,%TBLCC		; Clear the last character was a CR flag
	EXCH	T1,TB.TIM(TB)		; Get the previous value
	PJRST	.TYVHT			; Go test the justification flags
	$TOC	.TSUPS -- .TYVER - VER Support Module


; .TYVER - TYPES function to change the vertical justification
; Call:	MOVX	T1,{the address of the vertical justification table}
;	PUSHJ	P,.TYVER
;	 * Return - The old vertical justification value is in T1 *
; Uses:	T1-2

.TYVER::TXZ	T1,WD%LFT		; Clear any junk in the left half
	JUMPE	T1,TYVER1		; Jump if clearing vertical justification
	HRRZ	T2,TS.HRT(T1)		; Get the new
	MOVEM	T2,TB.HRT(TB)		;  header routine
	HRRZ	T2,TS.TRT(T1)		; Get the new
	MOVEM	T2,TB.TRT(TB)		;  trailer routine
	MOVE	T2,TS.HLN(T1)		; Get the new end
	MOVEM	T2,TB.HLN(TB)		;  header line number
	MOVE	T2,TS.TLN(T1)		; Get the new end
	MOVEM	T2,TB.TLN(TB)		;  trailer line number
	MOVE	T2,TS.PLN(T1)		; Get the new
	MOVEM	T2,TB.PLN(TB)		;  page length
	SETZM	TB.CLN(TB)		; Clear the page length
	TXOA	P2,%TBVER!%TBTOF	; Set the vertical justification flag
TYVER1:	TXZ	P2,%TBVER		; Clear the vertical justification flag
	TXZ	P2,%TBBOF		; Clear the bottom of form flag
	EXCH	T1,TB.VER(TB)		; Save for later
	PJRST	.TYVHT			; Go test the justification flags
	$TOC	.TSUPS -- .TYVRB - VRB Support Module


; .TYVRB - TYPES function to change the verbosity level
; Call:	MOVX	T1,{the verbosity level}
;	PUSHJ	P,.TYVRB		; The old value is in T1
;	 * Return - The old verbosity level is in T1 *
; Uses:	T1

.TYVRB::ANDX	T1,TF%WMS		; Clear any extraneous bits
	TXNE	T1,%TFWCN		; Skip if no continuation
	TXO	T1,%TFWPR!%TFWFL	; Set prefix and first line
	EXCH	T1,TB.VRB(TB)		; Save for later
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYZON - ZON Support Module


; .TYZON - TYPES function to change the time zone
; Call:	MOVX	T1,{the time zone}
;	TLO	T1,TF%DLS		; If daylight savings time
;	PUSHJ	P,.TYZON
;	 * Return - The old time zone information is in T1 *
; Uses:	T1-3

.TYZON::EXCH	T1,.TYTMZ##		; Get the old time zone
IFE <TF%MON-TF%T20>,<
	MOVE	T2,.TYTMZ##		; Get the new time zone value
	TXZE	T2,TF%DLS		; Skip if not daylight savings time
	SUBX	T2,^O1			; Account for the time change
	HRRES	T2			; Account for a negative time zone
	IMULX	T2,^D<60*60*1000>	; Convert to milliseconds
	SETZ	T3,			; Convert to a
	ASHC	T2,-^D17		;  fraction of
	DIVX	T2,^D<24*60*60*1000>	;  a day
	MOVEM	T2,.TYTZA##		; Save for later >
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYDOR - Default Output Routine


; .TYDOR - The primary output routine
; Call:	MOVX	T1,{the character to be output to the terminal}
;	PUSHJ	P,.TYDOR
;	 * Return *
; Uses:	No ACs

.TYDOR:
IFE <TF%MON-TF%T10>,<
	OUTCHR	T1			; Output the character >
IFE <TF%MON-TF%T20>,<
	PBOUT%				; Output the character >
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TDUMP - Default Buffer Flush Routine


; .TDUMP - Dump the stored string
; Call:	PUSHJ	P,.TDUMP
;	 * Return *
; Uses:	No ACs

.TDUMP::PUSH	P,T1			; Save T1
	SKIPE	T1,.TYPTR##		; Skip if the pointer wasn't set up
	CAMN	T1,[POINT 7,.TYBUF##]	; Skip if some thing to output
	JRST	TDUMP1			; Don't output anything
	SETZ	T1,			; Store a null at the
	IDPB	T1,.TYPTR##		;  end of the string
IFE <TF%MON-TF%T10>,<
	OUTSTR	.TYBUF##		; Dump the string >
IFE <TF%MON-TF%T20>,<
	HRROI	T1,.TYBUF##		; Dump the
	PSOUT%				;  string >
TDUMP1:	MOVE	T1,[POINT 7,.TYBUF##]	; Reset the buffer
	MOVEM	T1,.TYPTR##		;  pointer
	MOVX	T1,^D<5*TF%TBS-1>	; Reset the
	MOVEM	T1,.TYROM##		;  count
	POP	P,T1			; Restore T1
	POPJ	P,			; Return
	$TOC	.TSUPS -- .TYFND - Find a String File


; .TYFND - Find which file an external string number is in
; Call:	MOVX	T1,{the external string number}
;	PUSHJ	P,.TYFND
;	 * Non-skip return - Unable to find string *
;	* Skip return - The index in T2 *
; Uses:	T2-3

.TYFND::MOVSI	T2,-TF%ESF		; Get the number of string files
TYFND1:	SKIPE	T3,.TYRNG##(T2)		; Is this one set up?
	CAIGE	T1,(T3)			; Yes, greater than the minimum?
	JRST	TYFND2			; No, see if any more files
	HLRZS	T3			; Get the maximum
	CAMG	T1,T3			; Less than the maximum?
	PJRST	.POPJ1##		; Yes, give a good return
TYFND2:	AOBJN	T2,TYFND1		; Any more possible file?
	POPJ	P,			; Can't find the file
	$TOC	.TSUPS -- .TYVHT - Justification Flag Tester


; .TYVHT - Test the justification and time stamp flags
; Call:	MOVE	P2,{the TYPER flags}
;	PUSHJ	P,.TYVHT
;	 * Return - Set/clear %TBVHT *
; Uses:	P2

.TYVHT:	TXNE	P2,%TBVER!%TBHOR!%TBTIM!%TBCMP  ; Skip none are set
	TXOA	P2,%TBVHT		; Set the V-H-T OR flag
	TXZ	P2,%TBVHT		; Clear the V-H-T OR flag
	POPJ	P,			; Return
	$TOC	.TSUPS -- The End


	$PRGEND				; End of '.TSUPS'	$TOC	.TCVTD -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TCVTD

	$INIT	.TCVTD - Convert Date and Times,<.CNTDT,.GTNOW,.CNVDT>,\'TF%COD
	$TOC	.TCVTD -- Date/Time Convertions -- .CNTDT


; .CNTDT - Convert from Universal date/time format
; Call:	MOVX	T1,{the universal date/time}
;	PUSHJ	P,.CNTDT
;	 * Return - T1 contains time in milliseconds *
;	 *          T2 contains 15-bit date          *
; Uses:	T1-4
; Note:	Based on ideas by John Barnaby, David Rosenberg, Peter Conklin

.CNTDT::
IFE <TF%MON-TF%T20>,<
IFE <TF%SCN-TF%OFF>,<
	SUB	T1,.TYTZA##		; Account for the time zone >>
	PUSH	P,T1			; Save time for later
	JUMPL	T1,CNTDT6		; Defend against junk input
	HLRZ	T1,T1			; Get date portion (days since 1858)

	ADDX	T1,^D<<1857-1500>*365+<1857-1500>/4-<1857-1500>/100+<1857-1500>/400+31+28+31+30+31+30+31+31+30+31+17>
					; T1=days since Jan 1, 1501
	IDIVX	T1,^D<400*365+400/4-400/100+400/400>
					; Split into quadracentury
	LSH	T2,^D2			; Convert to number of quarter days
	IDIVX	T2,^D<<100*365+100/4-100/100>*4+400/400>
					; Split into century
	TXO	T3,^D3B35		; Discard fractions of day
	IDIVX	T3,^D<4*365+1>		; Separate into years
	LSH	T4,-^D2			; T4=No days this year
	LSH	T1,^D2			; T1=4*No quadracenturies
	ADD	T1,T2			; T1=No centuries
	IMULX	T1,^D100		; T1=100*No centuries
	ADDI	T1,^D1501(T3)		; T1 Has year, T4 has day in year

	MOVE	T2,T1			; Copy year to see if leap year
	TXNE	T2,^D3B35		; Is the year a mult of 4?
	JRST	CNTDT1			; No--just indicate not a leap year
	IDIVX	T2,^D100		; See if year is mult of 100
	CAXN	T3,^O0			; If not, then leap
	TXNN	T2,^D3B35		; Is year mult of 400?
	TDZA	T3,T3			; Yes--leap year after all
CNTDT1:	MOVX	T3,^D1			; Set leap year flag
					;  T3 is 0 if leap year
	SUBX	T1,^D1964		; Set to system origin
	IMULX	T1,^D<31*12>		; Change to system pseudo days
	JUMPN	T3,CNTDT2		; If not leap year, proceed
	CAXGE	T4,^D<31+29>		; Leap year--see if beyond Feb 29
	JRST	CNTDT5			; No--just include in answer
	SUBX	T4,^D1			; Yes--back off one day
CNTDT2:	MOVSI	T2,-^D11		; Loop for 11 months

CNTDT3:	CAMGE	T4,MONTAB+^D1(T2)	; See if beyond this month
	JRST	CNTDT4			; Yes--go finish up
	ADDX	T1,^D31			; No--count system month
	AOBJN	T2,CNTDT3		; Loop through November

CNTDT4:	SUB	T4,MONTAB(T2)		; Get days in this month
CNTDT5:	ADD	T1,T4			; Include in final result

CNTDT6:	EXCH	T1,(P)			; Save answer, get time
	TXZ	T1,WD%LFT		; Clear date
	MULX	T1,^D<24*60*60*1000>	; Convert to milliseconds
	ASHC	T1,^D17			; Position result
	POP	P,T2			; Recover date
	POPJ	P,			; Return

MONTAB:	^D0				; 0
	^D31				; 1
	^D59				; 2
	^D90				; 3
	^D120				; 4
	^D151				; 5
	^D181				; 6
	^D212				; 7
	^D243				; 10
	^D273				; 11
	^D304				; 12
	^D334				; 13
	^D365				; 14
	$TOC	.TCVTD -- Date/Time Convertions -- .CNNOW


; .GTNOW - Compute current time in universal data/time format
; Call:	PUSHJ	P,.GTNOW
;	 * Return - The current date/time is in T1 *
; Uses:	T1-4

IFE <TF%MON-TF%T10>,<
.GTNOW::MOVX	T1,%CNDTM		; Ask monitor
	GETTAB	T1,			;  for answer
	 SETZ	T1,			; Old monitor
	JUMPN	T1,.POPJ##		; If known, go give result
	MSTIME	T1,			; Get system time in milliseconds
	DATE	T2,			; Get system date in common format
	PFALL	.CNVDT			; Fall into .CNVDT >
IFE <TF%MON-TF%T20>,<
.GTNOW::GTAD%				; Get the current date/time
IFE <TF%SCN-TF%ON>,<
	SUB	T1,.TYTZA##		; Account for the time zone >
	POPJ	P,			; Return >
	$TOC	.TCVTD -- Date/Time Convertions -- .CNVDT


; .CNVDT -- Convert to universal date/time format
; Call:	MOVX	T1,{the time of day in milliseconds}
;	MOVX	T2,{the date in 15-bit format}
;	PUSHJ	P,.CNVDT
;	 * Return - The universal date/time or -1, *
;	 *          if beyond Sept. 27, 2217       *
; Uses:	T1-4
; Note:  That in Universal format, the left half divided by 7 gives the
;	 day of the week, zero (0) equals Wednesday.

.CNVDT::PUSHJ	P,.SAVE1##		; Save P1
	PUSH	P,T1			; Save time for later
	IDIVX	T2,^D<12*31>		; T2=Years-1964
	CAXLE	T2,^D<2217-1964>	; See if beyond 2217
	JRST	CNVDT2			; Yes--return -1
	IDIVX	T3,^D31			; T3=Months-Jan, T4=Days-1
	ADD	T4,MONTAB(T3)		; T4=Days-Jan 1
	SETZ	P1,			; Leap year additive if Jan, Feb
	CAXL	T3,^D2			; Check month
	MOVX	P1,^D1			; Additive if Mar-Dec
	MOVE	T1,T2			; Save years for reuse
	ADDX	T2,^D3			; Offset since leap year does not get counted
	IDIVX	T2,^D4			; Handle regular leap years
	CAXE	T3,^D3			; See if this is leap year
	SETZ	P1,			; No--wipe out additive
	ADDI	T4,^D<<1964-1859>*365+<1964-1859>/4+<31-18>+31>(T2)
					; T4=Days before Jan 1,1964 +since Jan 1
					;  +allowance for all leap years since 1964
	MOVE	T2,T1			; Restore years since 1964
	IMULX	T2,^D365		; Days since 1964
	ADD	T4,T2			; T4=Days except for 100 year fudge
	HRREI	T2,^D<64-100-1>(T1)	; T2=Years since 2001
	JUMPLE	T2,CNVDT1		; All done if not yet 2001
	IDIVX	T2,^D100		; Get centuries since 2001
	SUB	T4,T2			; Allow for lost leap years
	CAXE	T3,^D99			; See if this is a lost leap year
CNVDT1:	ADD	T4,P1			; Allow for leap year this year
	CAXLE	T4,^O377777		; See if too big
CNVDT2:	SETOM	T4			; Yes--set -1

	POP	P,T1			; Get millisecond time
	SETZ	T2,			; Clear other half
	ASHC	T1,-^D17		; Position
	DIVX	T1,^D<24*60*60*1000>	; Convert to 1/2**18 days
	HRL	T1,T4			; Include date
IFE <TF%MON-TF%T20>,<
IFE <TF%SCN-TF%OFF>,<
	ADD	T1,.TYTZA##		; Account for the time zone >>
	POPJ	P,			; Return
	$TOC	.TCVTD -- The End


	$PRGEND				; End of '.TCVTD'	$TOC	.TMISC -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TMISC

	$INIT	.TMISC - Some Miscellaneous Routines,,\'TF%COD


; Define the entry point

	ENTRY	.TCPUT			; Test the CPU type
	$TOC	.TMISC -- .TCPUT - Test for a CPU Type


; .TCPUT - Try to determine the CPU type that we are currently
;  running on
; Call:	PUSHJ	P,.TCPUT
;	 * Return here - T1 contains the CPU type *
; Uses:	T1-4

.TCPUT::				; Test for a PDP-6
	JFCL	17,.+1			; Clear the CPU flags
	JRST	.+1			; Set change PC if possible
	JFCL	1,TCPUP6		; Is change PC flag on?
					; No, test for a KA-10
	MOVX	T1,-^O1			; Get all ones
	AOBJN	T1,.+1			; Increment both halves
	JUMPN	T1,TCPUKA		; Were the halves increment seperately?
					; No, test for a KI-10
	BLT	T1,^O0			; Try a no-op BLT
	JUMPE	T1,TCPUKI		; Did anything happen?
					; No, test for a KL-10
	MOVX	T1,^O1			; Get a one
	MOVX	T2,^O0			; Clear the byte pointer
	MOVX	T3,^O1			; Set double length binary result
	EXTEND	T1,[CVTBDO]		; Convert binary to decimal
	TXNE	T4,TF%NON		; Did KL-10 micro code
	JRST	TCPUKL			;  bug set this bit?
					; No, test for a KS-10
	JRSTF	@[PC%BIS!.+1]		; Set byte increment supression
	MOVX	T1,<POINT 7>		; Build a byte pointer
	ILDB	T2,T1			; Did we increment
	JUMPLE	T1,TCPUKS		;  the byte pointer?
	JRST	TCPUKC			; No, a KC-10!

TCPUP6:	SKIPA	T1,[.CTPDP6]		; CPU type is a PDP-6
TCPUKA:	MOVX	T1,.CTKA10		; CPU type is a KA-10
	POPJ	P,			; Return

TCPUKI:	SKIPA	T1,[.CTKI10]		; CPU type is a KI-10
TCPUKL:	MOVX	T1,.CTKL10		; CPU type is a KL-10
	POPJ	P,			; Return

TCPUKS:	SKIPA	T1,[.CTKS10]		; CPU type is a KS-10
TCPUKC:	MOVX	T1,.CTKC10		; CPU type is a KC-10
	POPJ	P,			; Return
	$TOC	.TMISC -- The End


	$PRGEND				; End of '.TMISC'	$TOC	.TCRYP -- Initialization  15-May-83  /RWS


; Search some universal files

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title of .TCRYP

	$INIT	.TCRYP - ALC Style Encryption Scheme,.TCRYP,\'TF%COD
	$TOC	.TCRYP -- The Encryption Count Table


; MAJIK - The table used generate the encryption tables.
;   The left half contains the size of the initial sub-table to be used
;      within the encryption table.
;   The right half contains the size of the encryption table to be
;      generated.

MAJIK:	 ^O4,, -^O7			; (0)
	 ^O5,,-^O11			; (1)
	 ^O7,,-^O12			; (2)
	^O11,,-^O13			; (3)
	^O10,,-^O17			; (4)
	^O13,,-^O17			; (5)
	 ^O5,,-^O21			; (6)
	^O13,,-^O22			; (7)
	$TOC	.TCRYP -- .TCASC - Create a Seed from ASCIZ String


; .TCASC - Create an encryption seed from an ASCIZ string
; Call:	MOVX	T1,{the address or byte pointer to an ASCIZ string}
;	PUSHJ	P,.TCASC
;	 * Return - register T1 contains the seed *
; Uses:	T1

.TCASC::$VARIA	(SAVE,,,TYPREG)		; Save the world

	MOVE	T1,TYPREG+T1-^O1	; Set up the byte
	PUSHJ	P,.TPNTR##		;  pointer of the
	MOVE	P1,T1			;  ASCIZ string

	MOVX	P2,^O0			; Plant the seed

TCASC1:	MOVX	T2,<POINT 6,T1>		; The SIXBIT word
	MOVX	T1,^O0			;  to create a seed
TCASC2:	ILDB	T3,P1			; Get a character
	JUMPE	T3,TCASC3		; Was the end of the string reached?
	CAXGE	T3," "			; No, is it a control character?
	JRST	TCASC2			; Yes, discard control characters
	CAXL	T3,"`"			; Is it a lower case character?
	SUBX	T3,"a"-"A"		; Yes, convert to upper case
	SUBX	T3,"A"-'A'		; Convert to 6-bit ASCII
	IDPB	T3,T2			; Save the character
	TXNE	T2,BP%POS		; Have 6 character been stored?
	JRST	TCASC2			; No, get the next character
	PUSHJ	P,.TCSIX		; Create a seed
	XOR	P2,T1			; Accumulate the result
	JRST	TCASC1			; Get the next 6 characters

TCASC3:	JUMPE	T1,TCASC4		; Was anything placed in the last word?
	PUSHJ	P,.TCSIX		; Create another seed
	XOR	P2,T1			; Accumulate the result

TCASC4:	CAXN	P2,^O0			; Was a seed generated?
	MOVX	P2,TF%CRP		; Yes, use the default seed
	MOVEM	P2,TYPREG+T1-^O1	; Return the seed

	POPJ	P,			; Many happy returns
	$TOC	.TCRYP -- .TCSIX - Create a Seed from SIXBIT Word


; .TCSIX - Create an encryption seed from an SIXBIT word
; Call:	MOVX	T1,{the SIXBIT word encryption seed}
;	PUSHJ	P,.TCSIX
;	 * Return - register T1 contains the seed *
; Uses:	T1-4

.TCSIX::LDB	T4,[POINT 3,T1,4]	; Yes, get a 3-bit number from the seed
	TXC	T1,TF%CRP		; Complement some bits
	TXZ	T1,B0!B1!B2!B3!B4	; Clear the high order 5 bits
	CAXN	T1,^O0			; Is the seed zero?
	MOVX	T1,TF%CRP		; Yes, use the default

	HRRE	T4,MAJIK(T4)		; Get counter out of the magic table
TCSIX1:	MOVX	T3,^D6			; Set up a loop counter
TCSIX2:	MOVE	T2,T1			; Get a copy of the seed
	ROT	T2,^D11			; Rotate the seed to the left by 11
	XOR	T2,T1			; XOR the two seeds
	ROT	T2,-^D6			; Rotate the seed to the right by 6
	LSHC	T1,^D6			; Shift both seeds to the left by 6
	SOJG	T3,TCSIX2		; Done it six times yet?
	AOJL	T4,TCSIX1		; Yes, really finished?

	POPJ	P,			; Yes, return
	$TOC	.TCRYP -- .TCRYP - Encrypt a Block of Data


; .TCRYP - Encrypt a block of data
; Call:	MOVX	T1,{the seed generated by .TCASZ or .TCSIX}
;	MOVX	T2,{the key number (block number will do just fine)}
;	MOVX	T3,{an AOBJN pointer to the block of data to encrypt}
;	PUSHJ	P,.TCRYP
;	 * Return *
; Uses:	T1-4

.TCRYP::PUSHJ	P,.SAVE2##		; Save P1-2
	
	MOVE	P1,T3			; Get the AOBJN pointer a safer place

	IMULX	T2,^O200401		; Make a couple extra copies
	ANDX	T2,^O11111111		; Pick up the LSBs
	MULX	T2,^O11111111		; Generate the product
	TXZ	T3,B0!B1		; Clear the high order two bits
	ADD	T1,T3			; Add it to the seed

	LDB	P2,[POINT 3,T1,4]	; Yes, get a 3-bit number from the seed
	TXC	T1,TF%CRP		; Complement some bits
	TXZ	T1,B0!B1!B2!B3!B4	; Clear the high order 5 bits
	CAXN	T1,^O0			; Is the seed zero?
	MOVX	T1,TF%CRP		; Yes, use the default

	HRRE	T4,MAJIK(P2)		; Get the size of the encryption table
TCRYP1:	MOVX	T3,^D6			; Set up a loop counter
TCRYP2:	MOVE	T2,T1			; Get a copy of the seed
	ROT	T2,^D11			; Rotate the seed to the left by 11
	XOR	T2,T1			; XOR the two seeds
	ROT	T2,-^D6			; Rotate the seed to the right by 6
	LSHC	T1,^D6			; Shift both seeds to the left by 6
	SOJG	T3,TCRYP2		; Done it six times yet?
	PUSH	P,T1			; Save the seed on the stack
	AOJL	T4,TCRYP1		; Is the encryption table full?
	HRRZ	T3,MAJIK(P2)		; Yes, make an AOBJN
	HRLI	T3,^O1(T3)		;  counter into the
	ADDI	T3,^O1(P)		;  encryption table
	SKIPA	T4,T3			; Save the a copy of the ABOJN counter

TCRYP3:	MOVE	T3,T4			; Restore the AOBJN counter
	HLLZ	T2,MAJIK(P2)		; Create a second AOBJN pointer
	HLR	T2,T2			;  access a sub-table within
	ADD	T2,T3			;  the encryption table
TCRYP4:	MOVE	T1,(T2)			; Get a random seed, add it
	ADDB	T1,(T3)			;  to another random seed and
	XORM	T1,(P1)			;  XOR the result with the data
	AOBJP	P1,TCRYP6		; Is the encryption finished?
	AOBJN	T2,TCRYP5		; No, still within the table?
	HRRZ	T2,T4			; No, the sub-table now starts at the
	TXO	T2,B0			;  beginning of the encryption table
TCRYP5:	AOBJN	T3,TCRYP4		; Still within the table?
	JRST	TCRYP3			; No, reset the encryption counters

TCRYP6:	HRRE	T1,MAJIK(P2)		; Remove the encryption
	ADJSP	P,(T1)			;  table from stack

	POPJ	P,			; Return
	$TOC	.TCRYP -- The End


	$PRGEND				; End of '.TCRYP'	$TOC	.TSTPB -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV				; Some TYPER parameters


; Define the title for .TSTPB

	$INIT	.TSTPB - Convert a SCAN File Specification Block,.TSTPB,\'TF%COD
	$TOC	.TSTPB -- The TOPS-10 Code


; .TSTPB - Routine to turn SCAN format file specifation blocks into
;  OPEN/LOOKUP blocks.  Wild cards are illegal!!!
; Call:	HRRZI	T1,{the address of the SCAN block}	; Must be atleast
;	HRLI	T1,{the length of the SCAN block	;  24 words long
;	MOVEI	T2,{the address of the OPEN block}	; Must atleast 3 words
;   or:	HRRZI	T2,{the address of the FILOP. block}	; Must be atleast
;	HRLI	T2,{the length of the FILOP. block}	;  6 words long
;	HRRZI	T3,{the address of the LOOKUP block}	; Must be atleast
;	HRLI	T3,{the length of the LOOKUP block}	;  4 words long
;	HRRZI	T4,{the address of the PATH. block}	; Must be atleast
;	HRLI	T4,{the lenght of the PATH. block}	;  9 word long
;	PUSHJ	P,.TSTPB
;	 * Non-skip return - A wild card was found in the file specification *
;	* Skip return - Everything is set up *
; Uses:	No ACs

IFE TF%MON-TF%T10,<

.TSTPB::$VARIA	(SAVE,<TYPPPN>,,TYPREG)	; Save the world

; Get my PPN for later

	HRROI	T1,.GTPPN		; Get my
	GETTAB	T1,			;  PPN
	 $TYPES	(BUG)			; Should never get here!
	MOVEM	T1,TYPPPN		; Save for later

; Setup the AC's for the rest of the routine

	MOVE	P1,TYPREG+T1-^O1	; Get the SCAN block address
	TXNN	P1,WD%LFT		; Did the user supply a count?
	HRLI	P1,.FXLEN		; No, use the default

	MOVE	P2,TYPREG+T2-^O1	; Get the OPEN block address

	MOVE	P3,TYPREG+T3-^O1	; Get the LOOKUP/ENTER block
	TXNN	P3,WD%LFT		; Did the user supply a count?
	HRLI	P3,.RBEXT+^O1		; No, use the default
	HLRZ	T4,P3			; Get the lenght

	MOVE	P4,TYPREG+T4-^O1	; Get the PATH. block
	TXNN	P4,WD%LFT		; Did the user supply a count?
	HRLI	P4,.PTMAX		; No, use the default
; Clear the OPEN/FILOP. block

	HRRZ	T1,P2			; Get the address of the OPEN/FILOP. block
	HLRZ	T2,P2			; Get the length of the OPEN/FILOP. block
	SKIPN	T2			; Was a length specified?
	MOVX	T2,.OPBUF+^O1		; No, assume 3 words
	ADDI	T2,-^O1(T1)		; Point to the end of it
	SETZM	(T1)			; Clear the first word
	HRL	T1,T1			; Get the from address
	ADDX	T1,^O1			;  and the to address
	BLT	T1,(T2)			; Clear some memory

	TXNE	P2,WD%LFT		; Was a length specified?
	HRRI	P2,.FOIOS(P2)		; Yes, assume a FILOP. block

; Clear the LOOKUP block

	HRRZ	T1,P3			; Get the address of the LOOKUP block
	HLRZ	T2,P3			; Get the length of the LOOKUP block
	SUBX	T2,^O1			; Store the count in
	MOVEM	T2,.RBCNT(T1)		;  the first word
	ADDI	T2,(T1)			; Point to the end of it
	SETZM	.RBPPN(T1)		; Clear the second word
	HRL	T1,T1			; Get the from address
	ADD	T1,[.RBPPN,,.RBNAM]	;  and the to address
	BLT	T1,(T2)			; Clear some memory

; Clear the PATH. block

	HRRZ	T1,P4			; Get the address of the PATH. block
	HLRZ	T2,P4			; Get the length of the PATH. block
	ADDI	T2,-^O1(T1)		; Point to the end of it
	SETZM	(T1)			; Clear the first word
	HRL	T1,T1			; Get the from address
	ADDX	T1,^O1			;  and the to address
	BLT	T1,(T2)			; Clear some memory
; First, setup the OPEN block

	SKIPN	T3,.FXDEV(P1)		; Get the device name
	MOVSI	T3,'DSK'		; Default to DSK
	MOVEM	T3,.OPDEV(P2)		; Store in the OPEN/FILOP. block

	MOVE	T1,.FXMOD(P1)		; Get the modes word
	MOVSI	T2,'SYS'		; Get a good name
	DEVCHR	T2,UU.PHY		; Do physical call
	TXNN	T2,WD%RIT		; Anything set?
	TXZ	T1,FX.PHY		; No, clear /PHYSICAL
	MOVE	T2,[DEVCHR T3,]		; Get a UUO
	TXNE	T1,FX.PHY		; Is /PHYSICAL set?
	TXO	T2,UU.PHY		; Yes, change UUO
	XCT	T2			; Do it to it
	TXNN	T1,FX.PHY		; Is /PHYSICAL set?
	TDZA	T2,T2			; No, don't set any OPEN/FILOP. bits
	MOVX	T2,UU.PHS		; Set physical OPEN/FILOP. bit

	TXNN	T3,DV.MTA		; Is it a mag-tape?
	JRST	TSTPB1			; No, proceed
	TXNE	T1,FX.PAR		; Is even parity wanted?
	TXO	T2,IO.PAR		; Yes, set for OPEN
	LDB	T3,[$POINT T1,FX.DEN]	; Get the density
	DPB	T3,[$POINT T2,IO.DEN]	; Set for OPEN

TSTPB1:	MOVEM	T2,.OPMOD(P2)		; Store in the modes word for the OPEN
; Setup the LOOKUP block

	HLRZ	T3,P1			; Get the lenght of the SCAN block

	SKIPE	T1,.FXNAM(P1)		; Get the file name
	SETCM	T1,.FXNMM(P1)		; Get the name mask
	JUMPN	T1,.POPJ##		; Error if wild
	MOVE	T1,.FXNAM(P1)		; Get the file name
	MOVEM	T1,.RBNAM(P3)		; Store for LOOKUP

	SKIPE	T1,.FXEXT(P1)		; Get extension
	TXC	T1,WD%RIT		; Unless blank, check mask
	TXNE	T1,WD%RIT		; See if wild
	POPJ	P,			; Yes, error
	MOVEM	T1,.RBEXT(P3)		; Store in LOOKUP block

	LDB	T1,[$POINT .FXMOD(P1),FX.PRO] ; Get protection
	LSH	T1,<$ALIGN RB.PRV>	; Position for LOOKUP
	CAXLE	T4,.RBPRV		; Is the block long enough?
	MOVEM	T1,.RBPRV(P3)		; Yes, store in LOOKUP block

	MOVX	T1,RB.NSE		; Get non-superseding error bit
	MOVX	T2,FX.SUP		; Get /ERSUPER bit
	TDNE	T2,.FXMOD(P1)		; See if user set
	ORM	T1,.RBCNT(P3)		; Set for enter

	CAXLE	T3,.FXEST		; Is /ESTIMATE in SCAN block?
	SKIPGE	T1,.FXEST(P1)		; Yes, did the user give one?
	MOVX	T1,^D0			; No, default it
	LSH	T1,-^D7			; Convert to blocks
	CAXLE	T4,.RBEST		; Is the LOOKUP block long enough?
	MOVEM	T1,.RBEST(P3)		; Yes, store it

	CAXLE	T3,.FXVER		; Is /VERSION in SCAN block?
	SKIPA	T1,.FXVER(P1)		; Yes, did the user give one?
	MOVX	T1,^O0			; No, set to zero
	CAXLE	T4,.RBVER		; Is the LOOKUP block long enough?
	CAXN	T1,-^O1			; Yes, was one set by the user?
	TRNA				; No, don't do any bad
	MOVEM	T1,.RBVER(P3)		; Store it
; Setup the path block

	MOVX	T1,FX.DIR		; Did the user specify
	TDNN	T1,.FXMOD(P1)		;  a directory?
	JRST	TSTPB3			; No, use [-]

	SETCM	T1,.FXDIM(P1)		; Get the UFD mask
	JUMPN	T1,.POPJ##		; Error if wild
	MOVE	T1,.FXDIR(P1)		; Get UFD
	TXNN	T1,WD%LFT		; Was the project defaulted?
	HLL	T1,TYPPPN		; Yes, use mine
	TXNN	T1,WD%RIT		; Was the programmer defaulted?
	HRR	T1,TYPPPN		; Yes
	MOVEM	T1,.PTPPN(P4)		; Store the PPn

	MOVEI	T1,.FXDIR+^O2(P1)	; Point to argument SFD
	MOVSI	T2,-.FXLND+^O1		; Count SFDs
	HRRI	T2,(P4)			; Indicate start of SFD block

TSTPB2:	SKIPN	T3,(T1)			; Done yet?
	JRST	TSTPB3			; Yes, finish up
	MOVEM	T3,.PTPPN+^O1(T2)	; Store in path
	SETCM	T3,^O1(T1)		; Get mask
	JUMPN	T3,.POPJ##		; Error if wild
	ADDX	T1,^O2			; Advance fetch
	AOBJN	T2,TSTPB2		; Loop until done

TSTPB3:	MOVEI	T1,(P4)			; Store the address
	MOVEM	T1,.RBPPN(P3)		;  of the PATH. block
;     Here to setup the FILOP. arguements if indeed we are doing
; a FILOP. block.  Such is the case if a length was given in the
; OPEN block argument.

	TXNN	P2,WD%LFT		; Any length?
	JRST	.POPJ1##		; No, return

	HRRI	P2,-.FOIOS(P2)		; Point to the beginning of it
	HLRZ	T1,P2			; Get the length of the block
	CAXLE	T1,.FOLEB		; Room for the LOOKUP block?
	HRRZM	P3,.FOLEB(P2)		; Store the LOOKUP block address
	CAXLE	T1,.FOPAT		; Enough room for path block?
	MOVEM	P4,.FOPAT(P2)		; Store the path block address

	JRST	.POPJ1##		; Return >
	$TOC	.TSTPB -- The TOPS-20 Code


; .TSTPB - Routine to see if SCAN format block contains wild cards
; Call:	HRRZI	T1,{the address of the SCAN block}	; Must be atleast
;	HRLI	T1,{the length of the SCAN block}	;  24 words long
;	PUSHJ	P,.TSTPB
;	 * Non-skip return - A wild card was found in the file specification *
;	* Skip return - Everything is set up *
; Uses:	No ACs

IFE TF%MON-TF%T20,<

.TSTPB:	$VARIA	(SAVE,,STBCAL,TYPREG)	; Save the world

	MOVX	T1,GJ%OFG!GJ%FLG!GJ%SHT	; Just parse the file specification
	MOVE	T2,TYPREG+T1-^O1	; Restore T1
	HRROI	T2,.FXFIL(T2)		; Make a string pointer to the file
	GTJFN%				; Look for wild cards
	 JRST	.POPJ1##		; Assume no wild cards
	TXNN	T1,GJ%DEV!GJ%UNT!GJ%DIR!GJ%NAM!GJ%EXT!GJ%VER  ; Any wild cards?
	AOS	(P)			; No, give a skip return

	RLJFN%				; Release the JFN
	 JFCL				; Punt off any errors

	POPJ	P,			; Return >
 	$TOC	.TSTPB -- The End


	$PRGEND				; End of '.TSTPB'	$TOC	.TFRAM -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TFRAM

	$INIT	<.TFRAM - $FRAME, $LOCAT and $PARAM Macro Expansions>,<.FRAM0,.FRAM1,.FRAM2,.FRAM3,.FRAM4,.LOCAT,.PARAM>,\'TF%COD
	$TOC	.TFRAM -- The $FRAME Macro Expansion


	$FRAME	\'T$CPU,\'T$MON		; Assemble .FRAME here
	$TOC	.TFRAM -- The $LOCAT Macro Expansion


	$LOCAT				; Assemble .LOCAT here
	$TOC	.TFRAM -- The $PARAM Macro Expansion


	$PARAM				; Assemble .PARAM here
	$TOC	.TFRAM -- The End


	$PRGEND				; End of '.TFRAM'	$TOC	.TSAVE -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TSAVE

	$INIT	.TSAVE - The Register Save/Restore Routine,,\'TF%COD


; Define the entry points

IFE <TF%SAV&TF%SAP>,<
	ENTRY	.SAVE1			; The P1 thru
	ENTRY	.SAVE2			;  P4 register
	ENTRY	.SAVE3			;  saving
	ENTRY	.SAVE4			;  routines
	ENTRY	.SAVX4			; The non-skip return, restore P1-4
	ENTRY	.POPJ			; The return
	ENTRY	.POPJ1			;  routines >

IFE <TF%SAV&TF%SAT>,<
	ENTRY	.SAV1T			; The T1 thru
	ENTRY	.SAV2T			;  T4 register
	ENTRY	.SAV3T			;  saving
	ENTRY	.SAV4T			;  routines >

IFE <TF%SAV&TF%SA4>,<
	ENTRY	.PSH4T			; Save and restore
	ENTRY	.POP4T			;  T1 thru T4 >

IFE <TF%SCN-TF%ON>,<
	ENTRY	.SAVET			; Save and restore TB >

	ENTRY	.SAVEP			; Save and restore FP
	$TOC	.TSAVE -- Register Saving routines -- .SAVEx


IFE <TF%SAV&TF%SAP>,<

; .SAVE1 - Co-routine to save P1 for a subroutine
; Call:	PUSHJ	P,.SAVE1
;	 * Return via .POPJ or .POPJ1, restores P1 and skips or not *
; Uses:	No ACs

.SAVE1::EXCH	P1,(P)			; Save P1, get callers PC
	HRLI	P1,(P)			; Get address where P1 is saved
	PUSHJ	P,RESTP1		; Stack new return PC and jump
	 SOS	-^O1(P)			; Non-skip return
	JRST	RESP1			; Restore P1 and exit


; .SAVE2 - Co-routine to save P1-2 for a subroutine
; Call:	PUSHJ	P,.SAVE2
;	 * Return via .POPJ or .POPJ1, restores P1-2 and skips or not *
; Uses:	No ACs

.SAVE2::EXCH	P1,(P)			; Save P1, get callers PC
	HRLI	P1,(P)			; Get address where P1 is saved
	PUSH	P,P2			; Save P2
	PUSHJ	P,RESTP1		; Stack new return PC and jump
	 SOS	-^O2(P)			; Non-skip return
	JRST	RESP2			; Restore P1-2 and exit


; .SAVE3 - Co-routine to save P1-3 for a subroutine
; Call:	PUSHJ	P,.SAVE3
;	 * Return via .POPJ or .POPJ1, restores P1-3 and skips or not *
; Uses:	No ACs

.SAVE3::EXCH	P1,(P)			; Save P1, get callers PC
	HRLI	P1,(P)			; Get address where P1 is saved
	PUSH	P,P2			; Save P2
	PUSH	P,P3			; Save P3
	PUSHJ	P,RESTP1		; Stack new return PC and jump
	 SOS	-^O3(P)			; Non-skip return
	JRST	RESP3			; Restore P1-3 and exit
; .SAVE4 - Co-routine to save P1-4 for a subroutine
; Call:	PUSHJ	P,.SAVE4
;	 * Return via .POPJ or .POPJ1, restores P1-4 and skips or not *
; Uses:	No ACs

.SAVE4::EXCH	P1,(P)			; Save P1, get callers PC
	HRLI	P1,(P)			; Get address where P1 is saved
	PUSH	P,P2			; Save P2
	PUSH	P,P3			; Save P3
	PUSH	P,P4			; Save P4
	PUSHJ	P,RESTP1		; Stack new return PC and jump
.SAVX4:: SOS	-^O4(P)			; Non-skip return
	PFALL	RESP4			; Fall into RESP4

RESP4:	POP	P,P4			; Restore P4
RESP3:	POP	P,P3			; Restore P3
RESP2:	POP	P,P2			; Restore P2
RESP1:	POP	P,P1			; Restore P1
	PFALL	.POPJ1			; Fall into .POPJ1


; .POPJ1 and .POPJ - Routines to return to the user
; Call:	PJRST	.POPJ			; A normal return
;    or	PJRST	.POPJ1			; A skip return
; Uses:	No ACs

.POPJ1::AOS	(P)			; Increment PC
.POPJ::	POPJ	P,			; Return


; The following instruction restores P1 and dispatches to the caller:

RESTP1:	JRA	P1,(P1)			; Return to caller

>	; End of 'IFE TF%SAV&TF%SAP'
	$TOC	.TSAVE -- Register Saving routines -- .PSH4T and .POP4T


IFE <TF%SAV&TF%SA4>,<

; .PSH4T - Pushes T1-4 onto the stack
; Call:	PUSHJ	P,.PSH4T
;	 * Return *
; Uses:	No ACs

.PSH4T::PUSH	P,T2			; Save T2
	PUSH	P,T3			; Save T3
	PUSH	P,T4			; Save T4
	EXCH	T1,-^O3(P)		; Save T1 and get return
	PUSH	P,T1			; Put into safe place
	MOVE	T1,-^O4(P)		; Restore T1
	POPJ	P,			; Return


; .POP4T - Pops T1-4 off the stack
; Call:	PUSHJ	P,.POP4T
;	 * Return *
; Uses:	No ACs

.POP4T::POP	P,T1			; Get return
	POP	P,T4			; Restore T4
	POP	P,T3			; Restore T3
	POP	P,T2			; Restore T2
	EXCH	T1,(P)			; Restore T1 and save return
	POPJ	P,			; Return

>	; End of 'IFE TF%SAV&TF%SA4'
	$TOC	.TSAVE -- Register Saving routines -- .SAVxT


IFE <TF%SAV&TF%SAT>,<
   IFN <TF%SAV&TF%SAP>,<
      EXTERN .POPJ,.POPJ1		; These symbols are external then >

; .SAV4T - Co-routine to save T4 for a subroutine
; Call:	PUSHJ	P,.SAV4T
;	 * Return .POPJ or .POPJ1, restores T4 and skips or not *
; Uses:	No ACs

.SAV4T::EXCH	T4,(P)			; Save T4, get callers PC
	HRLI	T4,(P)			; Get address where T4 is saved
	PUSHJ	P,RESTT4		; Stack new return PC and jump
	 SOS	-^O1(P)			; Non-skip return
	JRST	REST4			; Restore T4 and exit


; .SAV3T - Co-routine to save T3-4 for a subroutine
; Call:	PUSHJ	P,.SAV3T
;	 * Return .POPJ or .POPJ1, restores T3-4 and skips or not *
; Uses:	No ACs

.SAV3T::EXCH	T4,(P)			; Save T4, get callers PC
	HRLI	T4,(P)			; Get address where T4 is saved
	PUSH	P,T3			; Save T3
	PUSHJ	P,RESTT4		; Stack new return PC and jump
	 SOS	-^O2(P)			; Non-skip return
	JRST	REST3			; Restore T3-4 and exit


; .SAV2T - Co-routine to save T2-4 for a subroutine
; Call:	PUSHJ	P,.SAV2T
;	 * Return .POPJ or .POPJ1, restores T2-4 and skips or not *
; Uses:	No ACs

.SAV2T::EXCH	T4,(P)			; Save T4, get callers PC
	HRLI	T4,(P)			; Get address where T4 is saved
	PUSH	P,T3			; Save T3
	PUSH	P,T2			; Save T2
	PUSHJ	P,RESTT4		; Stack new return PC and jump
	 SOS	-^O3(P)			; Non-skip return
	JRST	REST2			; Restore T2-4 and exit
; .SAV1T - Co-routine to save T1-4 for a subroutine
; Call:	PUSHJ	P,.SAV1T
;	 * Return .POPJ or .POPJ1, restores T1-4 and skips or not *
; Uses:	No ACs

.SAV1T::EXCH	T4,(P)			; Save T4, get callers PC
	HRLI	T4,(P)			; Get address where T4 is saved
	PUSH	P,T3			; Save T3
	PUSH	P,T2			; Save T2
	PUSH	P,T1			; Save T1
	PUSHJ	P,RESTT4		; Stack new return PC and jump
	 SOS	-^O4(P)			; Non-skip return
	PFALL	REST1			; Fall into REST1

REST1:	POP	P,T1			; Restore T1
REST2:	POP	P,T2			; Restore T2
REST3:	POP	P,T3			; Restore T3
REST4:	POP	P,T4			; Restore T4
	JRST	.POPJ1			; Go to .POPJ1


; The following instruction restores T4 and dispatches to the caller:

RESTT4:	JRA	T4,(T4)			; Return to caller

>	; End of 'IFE TF%SAV&TF%SAT'
	$TOC	.TSAVE -- Register Saving Routines -- .SAVET


IFE <TF%SCN-TF%ON>,<
   IFN <TF%SAV&TF%SAP>,<
      EXTERN .POPJ,.POPJ1		; These symbols are external then >

; .SAVET - Co-routine to save TB for a subroutine
; Call:	PUSHJ	P,.SAVET
;	 * Return .POPJ or .POPJ1, restores TB and skips or not *
; Uses:	No ACs

.SAVET::EXCH	TB,(P)			; Save register 15
	TXZ	TB,WD%LFT		; Clear the left half
	SKIPE	.TYBSA##		; Skip if user specified a database
	TLOA	TB,.TYBSA##		; Use the user database
	TLO	TB,[.TYDDB##]		; Use the default database
	PUSHJ	P,[JRA TB,(TB)]		; Setup TB and return
	 SOS	-^O1(P)			; Non-skip return

	POP	P,TB			; Restore register 15
	JRST	.POPJ1			; Go to .POPJ1 >
	$TOC	.TSAVE -- Register Saving Routines -- .SAVEP


IFN <TF%SAV&TF%SAP>,<
   EXTERN .POPJ,.POPJ1			; These symbols are external then >

; .SAVEP - Co-routine to set FP to the previous frame, after saving FP
; Call:	PUSHJ	P,.SAVEP
;	 * Return .POPJ or .POPJ1, restores FP and skips or not *
; Uses:	No ACs

.SAVEP::EXCH	FP,(P)			; Save register 16
	MOVS	FP,FP			; Put the return address in the left half
	HRR	FP,(P)			; Get the address of the current frame
	HRRI	FP,FP(FP)		; Get the address of register 16 in the frame
	MOVS	FP,FP			; Set up for the JRA return, swap halves
	PUSHJ	P,[JRA FP,(FP)]		; Setup FP and return
	 SOS	-^O1(P)			; Non-skip return

	POP	P,FP			; Restore register 16
	JRST	.POPJ1			; Go to .POPJ1
	$TOC	.TSAVE -- The End


	$PRGEND				; End of '.TSAVE'	$TOC	.TBITS -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TBITS

	$INIT	.TBITS - Dummy $BIT Routine,.TBITS,\'TF%COD
	$TOC	.TBITS -- The Dummy Subroutine


; .TBITS - The dummy support code for the $BIT substitution
; Call:	PUSHJ	P,.TBITS
;	 * Never returns *
; Uses:	T1

.TBITS::MOVX	T1,<SIXBIT ~BIT~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message
	$TOC	.TBITS -- The End


	$PRGEND				; End of '.TBITS'	$TOC	.TBYTE -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TBYTE

	$INIT	.TBYTE - Dummy $BYT Routine,.TBYTE,\'TF%COD
	$TOC	.TBYTE -- The Dummy Subroutine


; .TBYTE - The dummy support code for the $BYT substitution
; Call:	PUSHJ	P,.TBYTE
;	 * Never returns *
; Uses:	T1

.TBYTE::MOVX	T1,<SIXBIT ~BYT~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message
	$TOC	.TBYTE -- The End


	$PRGEND				; End of '.TBYTE'	$TOC	.TENGL -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TENGL

	$INIT	.TENGL - Dummy .TENGL Routine,.TENGL,\'TF%COD
	$TOC	.TENGL -- The Dummy Subroutine


; .TENGL - The dummy support code for the $NUM substitution
; Call:	PUSHJ	P,.TENGL
;	 * Never returns *
; Uses:	T1

.TENGL::MOVX	T1,<SIXBIT ~NUM~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message
	$TOC	.TENGL -- The End


	$PRGEND				; End of '.TENGL'	$TOC	.TFLOT -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TFLOT

	$INIT	.TFLOT - Dummy Floating-Point Routine,.TFLOT,\'TF%COD
	$TOC	.TFLOT -- The Dummy Subroutine


; .TFLOT - The dummy support code for the $NUM substitution
; Call:	PUSHJ	P,.TFLOT
;	 * Never returns *
; Uses:	T1

.TFLOT::MOVX	T1,<SIXBIT ~NUM~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message
	$TOC	.TFLOT -- The End


	$PRGEND				; End of '.TFLOT'	$TOC	.TINTG -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TINTG

	$INIT	.TINTG - Dummy .TINTG Routine,.TINTG,\'TF%COD
	$TOC	.TINTG -- The Dummy Subroutine


; .TINTG - The dummy support code for the $NUM substitution
; Call:	PUSHJ	P,.TINTG
;	 * Never returns *
; Uses:	T1

.TINTG::MOVX	T1,<SIXBIT ~NUM~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message
	$TOC	.TINTG -- The End


	$PRGEND				; End of '.TINTG'	$TOC	.TPICT -- Initialization  15-May-83  /DRB


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TPICT

	$INIT	.TPICT - Generate a Dummy Picture Code,<.TPICT,.TYPIC>,\'TF%COD
	$TOC	.TPICT -- The Dummy Subroutines -- .TPICT


; .TPICT - The dummy support code for the $PIC substitution.
; Call:	PUSHJ	P,.TPICT
;	 * Never returns *
; Uses:	T1

.TPICT::MOVX	T1,<SIXBIT ~NUM~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message
	$TOC	.TPICT -- The Dummy Subroutines -- .TYPIC


; .TYPIC -- TYPES function to set up the picture storage core
; Call:	PUSHJ	P,.TYPIC
;	 * Never returns *
; Uses:	T1

.TYPIC::$TYPE	(F,CPF,$NON,<The support code for $TYPES (PIC) wasn't loaded>,,A,T)
	$TOC	.TPICT -- The End


	$PRGEND				; End of '.TPICT'	$TOC	.TROMN -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TROMN

	$INIT	.TROMN - Generate a dummy .TROMN Routine,.TROMN,\'TF%COD
	$TOC	.TROMN -- The Dummy Subroutine


; .TROMN - The dummy support code for the $NUM substitution.
; Call:	PUSHJ	P,.TROMN
;	 * Never returns *
; Uses:	T1

.TROMN::MOVX	T1,<SIXBIT ~NUM~>	; Output the no support
	PJRST	.TNSUP##		;  loaded message
	$TOC	.TROMN -- The End


	$PRGEND				; End of '.TROMN'	$TOC	.TNSUP -- Initialization  15-May-83  /RWS


; Search a universal file

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TNSUP

	$INIT	.TNSUP - No Support Code Messages,.TNSUP,\'TF%COD
	$TOC	.TNSUP -- Type the Unsupported Message


; .TNSUP - Type a no support loaded message
; Call:	HRLZI	T1,{the SIXBIT name of the support module}
;	PJRST	.TNSUP
;	 * Never Returns *

.TNSUP::$TYPE	(F,SCL,$SIX,<The support code for the $| substitution wasn't loaded>,,A,T)
	$TOC	.TNSUP -- The End


	$PRGEND				; End of '.TNSUP'	$TOC	.TDATA -- Initialization  15-May-83  /RWS


; Search some universal files

	SEARCH	TYPUNV			; Some TYPER parameters


; Define the title for .TDATA

	$INIT	.TDATA - TYPER Low Segment Data,.TDATA,\'TF%DAT
	$TOC	.TDATA -- Low Segment Data


IFN <TF%SEG-TF%MAN>,<$LOW>		; Put the data in the low segment

.TDATA::				; The fake entry point

.TYBEG==:.				; The beginning of the data to clear

.TYDDB::$TYPED				; Set up the TYPER default database
.TYEDB::$TYPED				; Set up the TYPER error database
.TYTDB::$TYPED				; Set up the TYPER database

.TYBSA::BLOCK	^O1			; The address of the current data base
IFE <TF%MON-TF%T10>,<
.TYDEN::BLOCK	^O1			; The error string number >
.TYRNG::BLOCK	TF%ESF			; The external string ranges
.TYCHN::BLOCK	TF%ESF			; The external string channel/JFN
.TYMAX::BLOCK	^O1			; The maximum user substitution
.TYUSE::BLOCK	^O1			; The base address of the user substitutions
.TYUSR::BLOCK	^O1			; The argument to $TYPES (RTN)
.TYPCT::BLOCK	^O1			; The argument to $TYPES (PIC)
.TYTMZ::BLOCK	^O1			; The time zone
IFE <TF%MON-TF%T20>,<
.TYTZA::BLOCK	^O1			; The time zone adjustment >
.TYROM::BLOCK	^O1			; The output character count
.TYPTR::BLOCK	^O1			; The output character byte pointer
.TYBUF::BLOCK	TF%TBS			; The output character buffer (134 char)

IFE <TF%MON-TF%T20>,<
   IFE <TF%SCN-TF%ON>,<
.STEMP::BLOCK	^D50			; General string space (very temporary) >>

.TYEND==:.-^D1				; The end of data to clear
	$TOC	.TDATA -- The End


	$END				; End of '.TDATA'
Local modes:
TOC Indent Per Level:2
TOC Width:72
TOC Header:"
;		     	Table of Contents for ~Name~
;
;				  Section			    Page
;
"
TOC Separators:" -- "
TOC Use First Line:1
End:
    @-b