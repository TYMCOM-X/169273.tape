        OPCODELOAD 6500
        NOSYM
; NUC00 IS A VERSION OF NUC65 WHICH HAS BEEN MODIFIED TO 
; SUPPORT THE NEW SEIKO Y-DRIVER CUSTOM CHIP.

;   EQUATES

QMASK   EQU     22H
QL2NWDS EQU     24H
QCHECK  EQU     25H
QPHNO1  EQU     26H
QBKTMSK EQU     28H
QNROMWDS EQU    29H
QSPEED  EQU     2CH     ; *************????????????????***********
QCLTMSK EQU     2DH
QHFCTAB EQU     2EH
QHFTAB  EQU     30H
QFTAB   EQU     32H
QNLANGS EQU     34H
QL1TAB  EQU     35H

ACCESS  EQU     08B86H  ; **************************************
NACCESS EQU     08B9CH  ; **************************************
UIRQVC  EQU     0A678H  ; **************************************
NMIVEC  EQU     0A67AH  ; **************************************

IOB63   EQU     3E00H   ; ADDRESS OF LOW I/O BLOCK
IOB0    EQU     3EFCH   ; ADDRESS OF HIGH I/O BLOCK
KB      EQU     3F00H   ; KEYBOARD START
DSPLY   EQU     KB      ; DISPLAY START
LOBAT   EQU     3FFAH   ; READ: 80 BIT ON = LO BAT
TLO     EQU     3FFBH   ; R/W: TIMER LO BYTE
TMID    EQU     TLO+1   ; R/W: TIMER MIDDLE BYTE
THI     EQU     TMID+1  ; R/W: TIMER HI BYTE
LATCH   EQU     3FFEH   ; WRITE: HARDWARE CTL LATCH
DMASK   EQU     80H     ; LATCH: DSPLY ENABLE/KB DISSABLE
CPUON   EQU     40H     ; LATCH: CPU LOCKED ON
BEEPER  EQU     20H     ; LATCH: BEEPER DRIVER
SLOMEM  EQU     10H     ; LATCH: ENABLE SLOW MEMORY
DISPON  EQU     08H     ; LATCH: ENABLE XDRIVER POWER
CAPOFF  EQU     04H     ; LATCH: DISABLE INTRINSIC CAPSULES
;               02H     ; LATCH: INTRINSIC CAP ADDR(HI)
;               01H     ; LATCH: INTRINSIC CAP ADDR(LO)
NMIOFF  EQU     3FFFH   ; WRITE: RESET NMI FLIPFLOP

ROMADDR EQU     4000H   ; ADDRESS OF CAPSULE SPACE
CTROM   EQU     9000H   ; ADDRESS OF CONTROL ROM
ROMPAGE EQU     ROMADDR SHR 8
INTPAGE EQU     0D0H
ROMDICT EQU     ROMADDR+21H
BKMASK  EQU     ROMADDR+QBKTMSK
ALARM   EQU     1       ; EVENT QUEUE CODE
EVQHI   EQU     15      ; SIZE OF EVENT QUEUE-1
EWDCH   EQU     5EH
VTAB    EQU     0
ATAB    EQU     1
DTAB    EQU     2
RAWCLR  EQU     00H     ; CLEAR KEY
RAWOFF  EQU     3DH     ; OFF KEY
RAWSHFT EQU     30H     ; SHIFT KEY
RAWFUN  EQU     20H     ; FUNCTION KEY


;   RAM ALLOCATION

        ORG     0

CHAINV: DS      3       ; JMP CHAIN
NEXTV:  DS      3       ; JMP NEXT
IVECT:  DS      3       ; JMP (IDICT)
EVECT:  DS      2       ; A(EXTRINSIC VECTOR LIST)
TECB:   DS      1       ; TIMER ECB
XVECT:  DS      3       ; JMP  (XDICT)
KBVECT: DS      2       ; A(KEYBOARD PATTERN)
CHVECT: DS      2       ; A(CHARACTER GENERATOR)
ACVECT: DS      2       ; A(ACCENT GENERATOR)
IC:     DS      2       ; HIGH LEVEL INSTR CNTR
FREEMEM: DS     2       ; PTR TO FREE RAM
USERRAM: DS     2       ; PTR TO USER SPACE
LATCHS: DS      1       ; LATCH SHADOW- CUR SETTING IN LATCH
KBOFFSET: DS    1       ; DISP TO CURRENT KEYBOARD FROM KBVECT
TIME:   DS      4       ; TIME OF CENTURY IN MINUTES
;                         BEGINNING AT 00:00:00 1-1-79

APTR:   DS      2       ; A(NEXT ALARM TIME)

PCH:    DS      1       ; PREV CHAR
CLRRAM  EQU     .       ; INIT CLEARS RAM FROM HERE ON

CURROM: DS      1
T00:     DS      1
T01:     DS      1
T02:     DS      1
T03:     DS      1
T04:     DS      1       
T05:     DS      1
T06:     DS      1       
T07:     DS      1       

IRQA:   DS      1

NMI0:   DS      5       ; NMI SAVE AREA

I0:     DS      1       
I1:     DS      1       

ITBL:   DS      16      ; 8 INTERRUPT VECTORS

STIME:  DS      2       ; COUNTER INCREMENTED EACH 62.5 MS (SEC/16)
DTIME:  DS      1       ; COUNTER DECREMENTED EACH 62.5 MS
DLYCON: DS      1       ; DTIME RESET VALUE
DLYCNT: DS      1       ; COUNT OF DTIME RESETS

EVQPI:  DS      1       ; EVQ I/P PTR
EVQPO:  DS      1       ; EVQ O/P PTR
EVQ:    DS      16      ; EVENT QUEUE

FLAG1:  DS      1       ; STATUS FLAGS
ROMBIT  EQU     80H     ; FLAG1- CURRENT ROM IS OLD FORMAT
ROLLBIT EQU     40H     ; FLAG1- PREV CHAR WAS ROLLOVER
SHFTB1  EQU     20H
SHFTB2  EQU     10H
SHFTLK  EQU     08H
ALTBIT  EQU     04H
FUNBIT  EQU     02H
STKBIT  EQU     01H

BASE:   DS      1       ; CURRENT NUMBER BASE
CRYBIT: DS      1       ; 0 IF NO CARRY, 1 IF CARRY
KBX:    DS      1       ; KB WORK AREA
KBY:    DS      1       ; KB WORK AREA
CH:     DS      2       ; CUR CHAR(S)
CHCNT:  DS      1       ; CNT OF CUR CHARS
PATSZ   EQU     5       ; NO OF BYTES IN DOT PATTERN ********************

CURSOR: DS      1       ; INDEX TO CURSOR, 80H=INACTIVE

PSP:    DS      1       ; PARAMETER STACK POINTER
STKSAV: DS      1       ; RSTK SAVE AREA DURING PWR OFF

ROMPTR: DS      2
        W0      EQU     T00
        W1      EQU     T01
PSTK:   DS      20H

NMIFLAG: DS     1

IRQY:   DS      1
CURBANK1: DS    1
CURBANK2: DS    1
IRQXV:  DS      3

IPQI:   DS      1
IPQO:   DS      1
IPQ:    DS      8

OPQI:   DS      1
OPQO:   DS      1
OPQ:    DS      8

        ORG     0DDH
GETDOTX: DS     3
PBUFPT: DS      1
IRQCT:  DS      1
DOTCTR1: DS     1
DOTCTR2: DS     1
PDOTS:  DS      2

        ORG     0FEH
WARM0:  DS      1
WARM1:  DS      1
WARMCODE EQU    5AH

        ORG     100H

P1      EQU     .
        DS      100     ; RSTK=100 BYTES
RSTK    EQU     .-1
        DS      2       ; PADDING**********************************

DSIZE   EQU     26
DBUFL   EQU     DSIZE+1 ; DISPLAY BUFFER SIZE
DBUF:   DS      DBUFL   ; DISPLAY CHARACTER BUFFER
DBUF1:  DS      DBUFL   ; DBUF CHARACTER FLAGS
CNEG    EQU     80H     ; DBUF1: DISPLAY NEGATIVE CHAR
CFLSH   EQU     40H     ; DBUF1: FLASH CHAR
CQMK    EQU     20H     ; DBUF1: ALTERNATE CHAR WITH '?'
CALT    EQU     10H     ; DBUF1: USE ALT CHAR SET
; DBUF1 10H IS UNASSIGNED.
; DBUF1 BITS 0-3 INDICATE ONE OF 15 ACCENT MARKS.
ARRAYV  EQU     .       ; BEGINNING OF FREE SPACE
PBUF:   DS      18      ; PRINTER BUFFER
HIRAM   EQU     400H    ; END OF FREE SPACE


        ORG     0F000H

IDICT   EQU     .
EOW     EQU     (.-IDICT)/2
        DW      EOWX
POP     EQU     (.-IDICT)/2
        DW      POPX
IFI     EQU     (.-IDICT)/2
        DW      IFX
ENDI    EQU     (.-IDICT)/2
        DW      ENDX
ELSE    EQU     (.-IDICT)/2
        DW      ELSEX
SWAP    EQU     (.-IDICT)/2
        DW      SWAPX
DUP     EQU     (.-IDICT)/2
        DW      DUPX
OVER    EQU     (.-IDICT)/2
        DW      OVERX
PLS1    EQU     (.-IDICT)/2
        DW      PLS1X
MNS1    EQU     (.-IDICT)/2
        DW      MNS1X
PLUS    EQU     (.-IDICT)/2
        DW      PLUSX
NOTI    EQU     (.-IDICT)/2
        DW      NOTX
ANDI    EQU     (.-IDICT)/2
        DW      ANDX
XORI    EQU     (.-IDICT)/2
        DW      XORX
ORI     EQU     (.-IDICT)/2
        DW      ORX
ROT     EQU     (.-IDICT)/2
        DW      ROTX
FSTK    EQU     (.-IDICT)/2
        DW      FSTKX
FRAM    EQU     (.-IDICT)/2
        DW      FRAMX
EQ      EQU     (.-IDICT)/2
        DW      EQX
NE      EQU     (.-IDICT)/2
        DW      NEX
GT      EQU     (.-IDICT)/2
        DW      GTX
GE      EQU     (.-IDICT)/2
        DW      GEX
LE      EQU     (.-IDICT)/2
        DW      LEX
LT      EQU     (.-IDICT)/2
        DW      LTX
SRAM    EQU     (.-IDICT)/2
        DW      SRAMX
FET     EQU     (.-IDICT)/2
        DW      FETX
MOVE    EQU     (.-IDICT)/2
        DW      MOVEX
PSH1    EQU     (.-IDICT)/2
        DW      PSH1X
RSET    EQU     (.-IDICT)/2
        DW      RSETX
RSHF    EQU     (.-IDICT)/2
        DW      RSHFX
LSHF    EQU     (.-IDICT)/2
        DW      LSHFX
MAP     EQU     (.-IDICT)/2
        DW      MAPH    ;MAP
GETCHR  EQU     (.-IDICT)/2
        DW      GNIX    ; GNI
SRCH    EQU     (.-IDICT)/2
        DW      SEARCH  ; LLKUP
STEPWD  EQU     (.-IDICT)/2
        DW      STPWDX  ; STPWD
STO     EQU     (.-IDICT)/2
        DW      STOX
PSET    EQU     (.-IDICT)/2
        DW      PSETX
XTND    EQU     (.-IDICT)/2
        DW      XTNDX
CASE    EQU     (.-IDICT)/2
        DW      CASEX
FORI    EQU     (.-IDICT)/2
        DW      FORX
DO      EQU     (.-IDICT)/2
        DW      DOX
LOOP    EQU     (.-IDICT)/2
        DW      LOOPX
PLOOP   EQU     (.-IDICT)/2
        DW      PLOOPX
XLOOP   EQU     (.-IDICT)/2
        DW      XLOOPX
LNDX    EQU     (.-IDICT)/2
        DW      LNDXX
GETKB   EQU     (.-IDICT)/2
        DW      DEQ
CVB     EQU     (.-IDICT)/2
        DW      CVBX
CVD     EQU     (.-IDICT)/2
        DW      CVDX
SETB    EQU     (.-IDICT)/2
        DW      SETBX
HEX     EQU     (.-IDICT)/2
        DW      HEXX
DECIMAL EQU     (.-IDICT)/2
        DW      DECX
OCTAL   EQU     (.-IDICT)/2
        DW      OCTX
BINARY  EQU     (.-IDICT)/2
        DW      BINX
TRU     EQU     (.-IDICT)/2
        DW      TRUE
FLS     EQU     (.-IDICT)/2
        DW      FALSE
OFET    EQU     (.-IDICT)/2
        DW      OFETX
OSTO    EQU     (.-IDICT)/2
        DW      OSTOX
PSTO    EQU     (.-IDICT)/2
        DW      PSTOX
MIN     EQU     (.-IDICT)/2
        DW      MINX
MAX     EQU     (.-IDICT)/2
        DW      MAXX
COMP    EQU     (.-IDICT)/2
        DW      CMPX
PSH2    EQU     (.-IDICT)/2
        DW      PSH2X
POP2    EQU     (.-IDICT)/2
        DW      POP2X
DUP2    EQU     (.-IDICT)/2
        DW      DUP2X
SWAP2   EQU     (.-IDICT)/2
        DW      SWAP2X
DARRAY  EQU     (.-IDICT)/2
        DW      DARRAYX
ARRAY   EQU     (.-IDICT)/2
        DW      ARRAYX
ABS     EQU     (.-IDICT)/2
        DW      ABSX
RDBUF   EQU     (.-IDICT)/2
        DW      RDBUFX
PRT     EQU     (.-IDICT)/2
        DW      PRTX
DOUT    EQU     (.-IDICT)/2
        DW      DOUTX
WSRCH   EQU     (.-IDICT)/2
        DW      0       ; **************************
NOWRD   EQU     (.-IDICT)/2
        DW      0       ; **************************
EXEC1   EQU     (.-IDICT)/2
        DW      0       ; **************************
EXEC9   EQU     (.-IDICT)/2
        DW      0       ; **************************
BSET    EQU     (.-IDICT)/2
        DW      BSETX
MINUS   EQU     (.-IDICT)/2
        DW      MINUSX
DADD    EQU     (.-IDICT)/2
        DW      DADDX
DCHAR   EQU     (.-IDICT)/2
        DW      DCHARX
UPDISP  EQU     (.-IDICT)/2
        DW      UPDISPX
PRTCHR  EQU     (.-IDICT)/2
        DW      PRTCHRX
RDCHR   EQU     (.-IDICT)/2
        DW      RDCHRX
ENAB    EQU     (.-IDICT)
        DW      ENABX
X2:


; INIT- INITIALIZE RAM & BEGIN HIGH LVL EXECUTION

INIT:   LDY     #CPUON
        LDA     THI     ; DID TIMER EXPIRE?
        BMI     .+4     ; BRANCH IF YES
        LDY     #CPUON+DISPON
        STY     LATCH
        LDA     #WARMCODE ; TEST FOR WARM START
        CMP     WARM0
        BNE     INIT1
        ASLA;ASLA
        CMP     WARM1
        BNE     INIT1
;   WARM START: RESTORE REGS & DISPLAY.
        LDA     FLAG1   ; TEST CONDITION OF STACK
        AND     #STKBIT ; *
        BEQ     CLEAR   ; BRANCH IF STK NOT SET
        EOR     FLAG1   ; RESET STK BIT
        STA     FLAG1   
        LDX     STKSAV
        TXS
        TYA
        JSR     ORLATCH ; LATCH CPU,(DISPLAY), AND REST OF LATCH
        INC     NMIFLAG ; SIMULATE NMI
        JMP     NMIEP1

INIT1:  TYA
        AND     #DISPON ; IS ON SWITCH ON?
        BNE     INIT2   ; BRANCH IF YES
        STA     THI     ; RESET TIMER
        STA     LATCH   ; TURN POWER OFF
        BEQ     .       ; WAIT FOR SLEEP
INIT2:  LDX     #(RSTK-P1)
        TXS             ; INIT RSTK
        JSR     INITMEM ; INIT RAM
        JSR     SETTIME ; GET TIME & DATE FROM USER
        JMP     CLR01

CLEAR:  LDX     #(RSTK-P1)
        TXS
        JSR     INITMEM
CLR01:  LDA     #0
        STA     TMID;**********************************************
        STA     NMIOFF ;**************************************
        JSR     UPDISPL
        LDA     #7FH;********************************
        STA     THI ;********************************
SEARCH:
GNIX:
MAPH:
STPWDX:
        CLI
        JMP     NEXT

INITMEM: SEI            ; DISSABLE IRQ
        CLD             ; CLR DEC FLG
        LDX     #CLRRAM
        LDA     #0
        STA     KBOFFSET ; USE ALPHA KB
INCLR:  STA     0,X     ; CLEAR RAM
        INX
        BNE     INCLR
        LDX     #(IOB0 MOD 256)
INCLR1: STA     IOB63+2,X
        DEX
        DEX
        DEX
        DEX
        BNE     INCLR1
        LDX     #DBUFL
INCLR2: LDA     #' '    ; CLR DISPLAY TO BLANKS
        STA     DBUF-1,X
        LDA     #0      ; CLR CHAR FLAGS TO 0
        STA     DBUF1-1,X
        DEX
        BNE     INCLR2  ; CLEAR DISPLAY
        LDA     #CPUON+CAPOFF+DISPON ; INIT LATCH
        STA     LATCHS
        STA     LATCH
        LDA     #(IDICT SHR 8)
        STA     IVECT+2 ; SET UP INTRINSIC VECTOR
        LDA     #6CH    ; 6C=JMP INDIRECT INSTR
        STA     IVECT   ; INIT IVECT
        STA     XVECT   ; AND XVECT
        LDA     #(KBSET MOD 256)
        STA     KBVECT  ; INIT KB VECTOR
        LDA     #(KBSET SHR 8)
        STA     KBVECT+1
        LDA     #((CHSET-0A0H) MOD 256)
        STA     CHVECT  ; INIT CHAR GEN VECTOR
        LDA     #((CHSET-0A0H) SHR 8)
        STA     CHVECT+1
        LDA     #(ACPAT MOD 256)
        STA     ACVECT  ; INIT ACCENT GEN VECTOR
        LDA     #(ACPAT SHR 8)
        STA     ACVECT+1
        LDA     #(HIRAM MOD 256)
        STA     FREEMEM
        LDA     #(HIRAM SHR 8)
        STA     FREEMEM+1
        LDA     #10     ; INIT BASE TO DECIMAL
        STA     BASE    ; *
; INIT CHAIN AND NEXT VECTORS...
        LDA     #4CH    ; JMP DIRECT OP CODE
        STA     IRQXV
        STA     GETDOTX
        STA     NEXTV   ; STORE INTO NEXT VECTOR
        STA     CHAINV  ; STORE INTO CHAIN VECTOR
        LDA     #(CHAIN MOD 256)
        STA     CHAINV+1
        LDA     #(CHAIN SHR 8)
        STA     CHAINV+2
        LDA     #(NEXT MOD 256)
        STA     NEXTV+1
        LDA     #(NEXT SHR 8)
        STA     NEXTV+2
        LDA     #(CTROM SHR 8)
        STA     IRQXV+2
        LDA     #(GETDOTS MOD 256)
        STA     GETDOTX+1
        LDA     #(GETDOTS SHR 8)
        STA     GETDOTX+2
; INIT IC...
        LDA     #(HILVL MOD 256)
        STA     IC
        LDA     #(HILVL SHR 8)
        STA     IC+1
        RTS

SETTIME: RTS            ; GET TIME & DATE *******************

BREAK:  JMP     RETINT  ; IGNORE BREAK FOR NOW********************

; IRQEP- ENTRY FOR I/O, AND BREAK INTERRUPTS

IRQEP:  PHA             ; SAVE REGS
        TXA
        PHA
        TYA
        PHA
        TSX             ; TEST FOR BRK
        LDA     P1+4,X  ; *
        AND     #10H    ; *
        BNE     BREAK   ; BRANCH IF BREAK INSTR

; CODE GOES HERE TO RESOLVE I/O INTERRUPT
        LDA     #SLOMEM
        JSR     ORLATCH
        LDY     #(IOB0 MOD 256)
IRQLP:  LDA     IOB63+3,Y ; TEST FOR INTERRUPT REQUEST
        BPL     IRQHIT  ; BRANCH IF GOT IT
        DEY
        DEY
        DEY
        DEY
        BNE     IRQLP   ; KEEP LOOKING
        JMP     RETINT  ; EXIT IF UNSOLICITED

IRQHIT: LDX     CURBANK1
        LDA     #0
        STA     IOB63+2,X ; DESELECT BANK
        LDA     #1      ; SELECT MEMORY BANK
        STA     IOB63+2,Y
        STY     IRQY    ; SAVE I/O ADDR
        LDA     CTROM+1   ; CHECK FOR ROM
        CMP     #'C'    ; IS ROM HERE?
        BNE     IRQSIMP ; BRANCH IF NO.
        LDA     CTROM   ; GET ENTRY VECTOR
        STA     IRQXV+1 ; SET UP ENTRY VECTOR
        JSR     IRQXV   ; GO TO LOW LVL INT
IRQHIT1: LDA    #0
        LDY     IRQY
        STA     IOB63+2,Y ; DISSABLE MEMORY BANK
        LDX     CURBANK1
        LDA     CURBANK2
        STA     IOB63+2,X ; RE-SELECT OLD BANK
        LDA     LATCHS
        STA     LATCH   ; RESTORE LATCH
        JMP     RETINT  ; RETURN FROM IRQ

IRQSIMP: BIT    IOB0+3  ; RCVE?
        BVS     SIMPXMIT ; BRANCH IF NO
        LDA     IOB0+1  ; READ DATA FROM UART
        JSR     ENIP    ; PUT IT IN I/P QUEUE
        BIT     IOB0+3  ; IS TRANSMIT ACTIVE TOO?
        BMI     IRQHIT1 ; BRANCH IF NO
SIMPXMIT: LDX   OPQO    ; IS ANYTHING IN O/P QUEUE?
        CPX     OPQI    ; ?
        BNE     SIMX2   ; BRANCH IF YES
        LDA     #5CH    ; RESET TRANSMIT IRQ
        STA     IOB0+3  ; *
        LDA     #7FH
        STA     IOB0+1  ; RESET IRQ
        BNE     IRQHIT1
SIMX2:  JSR     DEOP    ; GET O/P FROM QUEUE
        STA     IOB0+1  ; SEND BYTE TO UART
        LDX     OPQI
        CPX     OPQO    ; ANY DATA TO XMIT?
        BNE     IRQHIT1 ; BRANCH IF YES
        LDA     #5CH    ; RESET TRANS IRQ
        STA     IOB0+3  ; *
        BNE     IRQHIT1

ENABX:  LDA     #SLOMEM
        JSR     ORLATCH
        LDA     #3CH
        STA     IOB0    ; SET UP UART
        LDA     #5CH
        STA     IOB0+3  ; SET UP MODEM
        JMP     NEXT


; NMIEP- ENTRY FOR KEYBOARD AND TIMER INTERRUPTS

NMIEP:  INC     NMIFLAG ; INCREMENT NMI ENTRY COUNT
        PHA
        TXA
        PHA
        TYA
        PHA
NMIEP1: LDX     NMIFLAG
        DEX             ; 2ND ENTRY?
        BEQ     NORMAL  ; BRANCH IF CURRENT ENTRY ONLY
        JMP     CLEAR   ; RESET SYSTEM IF PROBLEM

NORMAL: LDA     THI     ; TIMER INTERRUPT?
        BMI     TIMER   ; BRANCH IF YES
NMIKB:  LDA     LATCHS  ; RESET POSSIBLE MASK
        AND     #255-DMASK
        STA     LATCH
        LDA     KB+255  ; IS KEY PRESSED?
        BNE     KBHOT   ; BRANCH IF YES

; THIS PATH IS TAKEN AFTER A KEY HAS BEEN RELEASED...

        LDA     #0FFH
        STA     PCH     ; INDICATE NO KEY PRESSED
        LDA     #SHFTB1+SHFTB2+SHFTLK
        AND     FLAG1
        CMP     #SHFTB1+SHFTB2 ; SHOULD SHIFT BE RESET?
        BNE     NMIXIT  ; BRANCH IF NO
        EOR     FLAG1   ; RESET SHIFT
        STA     FLAG1

NMIXIT: LDA     #0
        STA     NMIFLAG ; RESET NMI COUNT
        STA     NMIOFF  ; RESET NMI
        LDA     THI     ; HAS TIMER EXPIRED?
        BMI     TIMER1  ; BRANCH IF YES
        LDA     LATCHS
        STA     LATCH   ; RESTORE POSSIBLE MASK

RETINT: PLA             ; RESTORE REGS
        TAY
        PLA
        TAX
        PLA
        RTI             ; RETURN FROM INTERRUPTIMER1: INC     NMIFLAG
TIMER:  LDA     #40H ;***********************************
        STA     THI  ;***********************************
        INC     TECB ;***********************************
        JMP     NMIKB ;**********************************

KBHOT:  LDX     #1      ; INIT ROW PTR
        LDY     #0      ; INIT CH CNT
        STY     CHCNT   ; *
KBLP1:  LDA     KB,X    ; READ KB ROW X
        BNE     KBLP1Z  ; BRANCH IF HIT
KBLP1A: TXA             ; BMP TO NXT ROW
        ASLA;ASLA
        BCS     KBDONE  ; BRANCH IF ALL ROWS READ
        TAX
        INY             ; BMP ROW CNTR
        BNE     KBLP1   ; ALWAYS BRANCH

; ROW HAS KEY PRESSED
KBLP1Z: STX     KBX     ; SAVE X
        STY     KBY     ; SAVE Y
        TAX             ; SAVE ROW DATA IN X
        TYA             ; A=ROW NO.
        ASLA;ASLA            ; MPY ROW BY 8
        ASLA;ASLA
        ASLA;ASLA
        TAY
        TXA             ; GET ROW DATA BACK IN A
KBLP2:  LSRA ;LSRA            ; SHIFT KEYS THRU CARRY
        BCC     KBLP2A  ; BRANCH IF KEY NOT PRESSED
        LDX     CHCNT   ; 2 CHARS ALREADY READ?
        CPX     #2      ; ?
        BEQ     KBIGNX  ; BRANCH IF YES
        STY     CH,X    ; STORE NEW CHAR
        INC     CHCNT   ; BMP CHAR CNT
KBLP2A: INY             ; ADD 1 TO CHAR
        CMP     #0      ; IS ACC EMPTY?
        BNE     KBLP2   ; BRANCH IF NO
        LDY     KBY     ; RESTORE X & Y
        LDX     KBX     ; *
        BNE     KBLP1A  ; ALWAYS BRANCH

KBIGNX: JMP     KBIGN

; CH(0), CH(1) CONTAIN RAW CHARS
KBDONE: LDX     CHCNT   ; X=0,1,2
        BEQ     KBIGNX  ; EXIT IF NO KEY PRESSED
        DEX             ; IS 1 KEY PRESSED?
        BNE     KBROLL  ; BRANCH IF NO. 2.
        LDA     #255-ROLLBIT
        AND     FLAG1   ; INDICATE NO ROLLOVER
        STA     FLAG1   
KPD1:   LDA     CH      ; A=CHAR
        CMP     PCH     ; SAME AS PREV CHAR?
        BEQ     KBIGNX  ; EXIT IF YES
        TAY             ; GET RAW CHAR IN Y
KPD2:   STY     PCH     ; SAVE RAW CHAR
        CPY     #RAWCLR ; CLEAR KEY?
        BNE     .+5     ; BRANCH IF NO
        JMP     CLEAR
        CPY     #RAWOFF ; OFF KEY?
        BEQ     TURNOFF ; TURN OFF IF YES
        LDA     #FUNBIT
        AND     FLAG1   ; WORKING ON PREV FUNCTION?
        BNE     KBFUN   ; BRANCH IF YES
        CPY     #RAWSHFT ; SHIFT KEY?
        BEQ     KBSHFT  ; BRANCH IF YES
        CPY     #RAWFUN ; FUNCTION KEY?
        BEQ     KBFUNKY ; BRANCH IF YES
        LDA     #SHFTB1+SHFTLK ; SHIFTING THIS CHAR?
        AND     FLAG1
        BEQ     KBNOSH  ; BRANCH IF NO
        LDA     #SHFTB2 ; INDICATE THIS CHAR SHIFTED
        ORA     FLAG1
        STA     FLAG1
        LDA     #40H    ; ADD 64 IF YES
KBNOSH: ORA     PCH     ; COMBINE WITH CHAR
        CLC
        ADC     KBOFFSET ; ADD TO OFFSET
        TAY             ; GET DISP IN Y
        LDA     (KBVECT),Y ; A=REAL CHAR
        JSR     ENQ     ; RECORD THE EVENT
        JMP     KBXIT   ; CONTINUE

KBROLL: LDA     #ROLLBIT ; TEST PREV ROLLOVER
        BIT     FLAG1   ; *
        BNE     KBXIT   ; BRANCH IF PREV WAS ROLL
        LDX     PCH     ; X=PREV CHAR
        LDY     CH+1    ; Y=CH2
        CPX     CH      ; IS CH1 SAME AS PREV?
        BEQ     KBR1    ; BRANCH IF YES
        LDY     CH      ; Y=CH1
        CPX     CH+1    ; IS CH2 SAME AS PREV?
        BNE     KPD1    ; ACCEPT BOTH CHARS
KBR1:   ORA     FLAG1   ; TURN ON ROLL BIT
        STA     FLAG1   ; *
        JMP     KPD2    ; CONTINUE

KBFUN:  LDA     #255-FUNBIT     ; RESET FUNCTION FLAG
        AND     FLAG1
        STA     FLAG1
        CPY     #RAWSHFT ; FUN-SHIFT? (SHIFT LOCK?)
        BNE     KBFB    ; BRANCH IF NO
        EOR     #SHFTLK
        AND     #255-SHFTB1-SHFTB2 ; RESET SHIFT
        STA     FLAG1   ; TOGGLE SHIFT LOCK
        JMP     KBXIT

KBFB:   CPY     #10H    ; FUNCTION 10? (SHIFT TO/FROM KATA-KANA?)
        BNE     KBXIT   ; BRANCH IF NO
        LDA     #0
        CMP     KBOFFSET ; IS OFFSET =0?
        BNE     .+4     ; BRANCH IF NO
        LDA     #80H
        STA     KBOFFSET
        JMP     KBXIT

KBFUNKY: LDA    #FUNBIT ; INDICATE FUNCTION KEY PRESSED
        BNE     KBSHFT1 ; ALWAYS BRANCH

KBSHFT: LDA     #SHFTB1
KBSHFT1:ORA     FLAG1
        STA     FLAG1
;       FALL INTO KBXIT.....

KBIGN   EQU     .
KBXIT:  JMP     NMIXIT

TURNOFF: LDA    #0
        STA     NMIFLAG
        LDA     #255-DISPON
        JSR     ANDLATCH ; TURN OFF DISPLAY
        STA     NMIOFF  ; RESET LATCH
        TSX             ; GET STK IN X
        JMP     SLEEP1  ; CONTINUE

SLEEP:  PHP             ; SAVE STATUS
        SEI             ; DISSABLE IRQ
        PHA
        TXA
        PHA
        TYA
        PHA
        TSX
        INC     P1+5,X  ; SIMULATE INTERRUPT
        BNE     .+5
        INC     P1+6,X
SLEEP1: STX     STKSAV  ; SAVE STACK PTR
        LDA     FLAG1
        ORA     #STKBIT
        STA     FLAG1
        LDA     #WARMCODE
        STA     WARM0
        ASLA;ASLA
        STA     WARM1
        LDA     #255-CPUON
        AND     LATCHS
        STA     LATCHS
        STA     LATCH
        JMP     .       ; WAIT FOR SLEEP TO COME...

ANDLATCH: AND    LATCHS
        JMP     DOLATCH
ORLATCH: ORA    LATCHS
DOLATCH: STA    LATCHS
        STA     LATCH
        RTS

; ENQ- ENQUEUE EVENT ON EVENT QUEUE

ENQ:    LDX     EVQPI
        STA     EVQ,X
        DEX
        BPL     .+4
        LDX     #EVQHI
        STX     EVQPI
        RTS

; DEQ- DEQUEUE CHAR FROM EVENT QUEUE

DEQ:    LDY     EVQPO
        CPY     EVQPI
        BNE     DEQ01
        JSR     SLEEP   ; WAIT FOR KEY PRESS
        JMP     DEQ     ; TRY AGAIN
DEQ01:  LDA     EVQ,Y
        DEY
        BPL     .+4
        LDY     #EVQHI
        STY     EVQPO
        JMP     DUPX5

ENIP:   LDX     IPQI
        STA     IPQ,X
        DEX
        BPL     .+4
        LDX     #7
        STX     IPQI
        RTS

DEIP:   LDX     IPQO
        LDA     IPQ,X
        DEX
        BPL     .+4
        LDX     #7
        STX     IPQO
        RTS

ENOP:   LDX     OPQI
        STA     OPQ,X
        DEX
        BPL     .+4
        LDX     #7
        STX     OPQI
        RTS

DEOP:   LDX     OPQO
        LDA     OPQ,X
        DEX
        BPL     .+4
        LDX     #7
        STX     OPQO
        RTS

; EOW- UN-CHAIN HIGH LEVEL WORDS

EOWX:   PLA             ; REMOVE IC FROM STACK
        STA     IC      ; *
        PLA             ; *
        STA     IC+1    ; *
; FALL INTO NEXT....

; NEXT- FETCH THE NEXT TAG AND TRANSFER TO REQD WORD.

NEXT:   NOP             ; SET TO 00 FOR HL TRACE
        LDY     #0      ; SET INDEX=0
        LDA     (IC),Y  ; FETCH NEXT TAG
NEXT1:  INC     IC      ; BUMP THE IC BY 1
        BNE     NEXT2   ; *
        INC     IC+1    ; *
NEXT2:  LDX     PSP     ; INIT PSTK PTR
        ASLA;ASLA            ; OPCODE *2
        BCS     EXNEXT  ; BRANCH IF EXTRINSIC TAG
        STA     IVECT+1 ; STORE INTRINSIC VECTOR
        JMP     IVECT   ; JMP TO INDIR JMP
EXNEXT: TAY             ; Y=VECTOR INDEX
        INY             ; POINT TO LO BYTE
        LDA     (EVECT),Y ; A=LO BYTE OF DISP
        CLC
        ADC     EVECT   ; ADD TO A(VECTOR TABLE)
        STA     I0      ; BUILD A(EP)
        DEY             ; POINT TO HI BYTE
        LDA     (EVECT),Y ; A=HI BYTE OF DISP + FLAG
        BMI     ECHAIN  ; BRANCH IF EXTRINSIC WORD IS HIGH LVL
EXNXT1: ADC     EVECT+1 ; GET VECTOR
        STA     I1
        JMP     (I0)    ; GO TO EXTRINSIC LO LVL WORD

ECHAIN: AND     #7FH    ; STRIP HIGH LVL FLAG
        ADC     EVECT+1 ; GET A(HI LVL WORD)
        TAX             ; X=HI BYTE
        LDY     I0      ; Y=LO BYTE
        JMP     CHAIN1  ; CONTINUE

; CHAIN- CHAIN HIGH LEVEL WORDS TOGETHER

CHAIN:  PLA
        TAY             ; Y=LO ADDR
        PLA
        TAX             ; X=HI ADDR
        INY             ; BMP ADDR TO FIRST HL TAG
        BNE     CHAIN1
        INX
CHAIN1: LDA     IC+1    ; PUT CURRENT IC ON STK
        PHA
        LDA     IC
        PHA
        STY     IC      ; STORE IC(LO)
        STX     IC+1    ; STORE IC(HI)
        JMP     NEXT    ; CONTINUE

; CASE- EXECUTE ONE WORD OF A LIST OF WORDS.

CASEX:  LDY     PSTK,X  ; GET PSTK TOP IN Y
        DEC     PSP
        LDA     (IC),Y  ; A=CASE TAG
        TAX             ; SAVE IT IN X
        LDY     #0
        LDA     (IC),Y  ; GET DISP TO ECASE
        CLC
        ADC     IC      ; BMP IC TO ECASE
        STA     IC      ; *
        BCC     .+4     ; *
        INC     IC+1    ; *
        TXA             ; GET CURRENT CASE IN A
        JMP     NEXT2   ; CONTINUE

; XTND- EXTEND THE OPCODE BY 128. WORKS FOR INTRINSIC
;               AND EXTRINSIC OP CODES.

XTNDX:  LDX     #0      ; INIT EXTEND ACCUMULATOR
XTNDLP: INX             ; ADD 1 TO ACCUM
        JSR     FICW    ; FETCH NEXT BYTE
        CMP     #XTND   ; ANOTHER EXTEND REQUEST?
        BEQ     XTNDLP  ; BRANCH IF YES
        ASLA;ASLA            ; CONVERT OP TO VECTOR(LO)
        BCS     XTXT    ; BRANCH IF EXTRINSIC TAG
        STA     XVECT+1 ; STORE VECTOR(LO)
        TXA             ; GET ADDED DISP IN A
        ADC     IVECT+2 ; ADD TO INTRINSIC VECTOR(HI)
        STA     XVECT+2 ; STORE VECTOR(HI)
        JMP     XVECT   ; GO TO REQD ROUTINE

XTXT:   CLC
        ADC     EVECT   ; SET UP XVECT TO POINT TO DISP
        STA     XVECT+1
        TXA
        ADC     EVECT+1
        STA     XVECT+2
        LDY     #1      ; PREPARE TO LOAD LO BYTE OF DISP
        LDA     (XVECT+1),Y ; A=LO DISP
        CLC
        ADC     EVECT   ; SET I0, I1
        STA     I0
        DEY             ; POINT TO HI BYTE OF DISP
        LDA     (XVECT+1),Y ; A=HI DISP
        BMI     ECHAIN  ; BRANCH IF HI LVL
        JMP     EXNXT1  ; GO TO LO LVL

; IF- CONDITIONAL HIGH LEVEL JUMP

IFX:    LDA     PSTK,X  ; A=TOP OF STK
        BNE     EX1     ; BRANCH IF TRUE
        LDA     (IC),Y  ; A=FWD JMP DISP
        CLC
        ADC     IC      ; BMP IC BY REQD AMT
        STA     IC      ; *
        BCC     POPX    ; CONTINUE IF DONE
INCICH: INC     IC+1    ; INC IC(HI) IF CARRY
        JMP     POPX    ; CONTINUE
EX1:    INC     IC      ; BMP IC PAST FALSE VECTOR
        BNE     POPX    ; BRANCH IF NOT NEW PAGE
        BEQ     INCICH  ; BRANCH IF NEW PAGE

; END- CONDITIONAL BACKWARD HIGH LEVEL JUMP

ENDX:   LDA     PSTK,X  ; A=TOP OF PSTK
        BNE     EX1     ; BRANCH IF TRUE
        LDA     IC      ; A=IC(LO)
        SEC
        SBC     (IC),Y  ; A=IC-DISP
        STA     IC      ; STORE NEW IC
        BCS     POPX    ; BRANCH IF ON SAME PAGE
        DEC     IC+1    ; SET PREV PAGE
        JMP     POPX

; ELSE- UNCONDITIONAL FORWARD JUMP

ELSEX:  LDA     (IC),Y
        CLC
        ADC     IC      ; ADD TO IC
        STA     IC      ; *
        BCC     .+4     ; JMP IF ON SAME PAGE
        INC     IC+1    ; BMP TO NXT PAGE
        JMP     NEXT    ; CONTINUE

; POP- POP TOP ENTRY FROM PSTK
; POP2- POP TOP 2 BYTES FROM PSTK

POP2X:  DEC     PSP     ; DECREMENT PSTK PTR
POPX:   DEC     PSP     ; DECREMENT PSTK PTR
        JMP     NEXT    ; CONTINUE

; DARRAY- DEFINE ARRAY. (T)=SIZE, (FICW)=ARRAY ID.

DARRAYX: JSR    FICW    ; GET ARRAY ID
        ASLA;ASLA            ; A=DISP INTO ARRAY VECTOR
        TAY
        LDA     PSTK,X  ; A=ARRAY SIZE
        DEC     PSP
        EOR     #0FFH   ; SUB ARRAY SIZE FROM LAST LOC
        SEC
        ADC     FREEMEM
        STA     FREEMEM
        BCS     .+4
        DEC     FREEMEM+1 ; FREEMEM=A(NEW ARRAY)
        STA     ARRAYV,Y ; POINT TO ARRAY
        LDA     FREEMEM+1
        STA     ARRAYV+1,Y
        JMP     NEXT

; ARRAY- PUT ADDRESS OF ARRAY(FICW) ON PSTK

ARRAYX: JSR     FICW    ; GET ARRAY ID
        ASLA;ASLA
        TAY
        LDA     ARRAYV,Y
        STA     PSTK+1,X
        LDA     ARRAYV+1,Y
        INX
        JMP     DUPX5

; SWAP2- EXCHANGE ((T),(T-1)) WITH ((T-2),(T-3))

SWAP2X: LDA     PSTK,X
        LDY     PSTK-2,X
        STY     PSTK,X
        STA     PSTK-2,X
        LDA     PSTK-1,X
        LDY     PSTK-3,X
        STY     PSTK-1,X
        STA     PSTK-3,X
        JMP     NEXT

; SWAP- SWAP TOP OF PSTK WITH TOP-1

SWAPX:  LDA     PSTK,X  ; A=(TOP)
        LDY     PSTK-1,X ; Y=(TOP-1)
        STA     PSTK-1,X ; (TOP-1)=A
        STY     PSTK,X  ; (TOP)=Y
        JMP     NEXT    ; CONTINUE

; DUP2- DUPLICATE TOP 2 BYTES ON PSTK

DUP2X:  LDA     PSTK-1,X
        INX
        STA     PSTK,X
        LDA     PSTK-1,X
        JMP     DUPX5

; DUP- DUPLICATE TOP OF STACK

DUPX:   LDA     PSTK,X  ; A=(TOP)
DUPX5:  INX             ; INCR STK PTR
DUPX6:  STA     PSTK,X  ; (TOP+1)=A
        STX     PSP     ; UPDATE PTR
        JMP     NEXT    ; CONTINUE

; OVER- DUPLICATE (TOP-1) ON TOP OF STK

OVERX:  LDA     PSTK-1,X ; A=(TOP-1)
        JMP     DUPX5   ; CONTINUE

; ROT- EXCHANGE (TOP) WITH (TOP-2)

ROTX:   LDY     PSTK,X  ; Y=(TOP)
        LDA     PSTK-2,X ;A=(TOP-2)
        STY     PSTK-2,X
        STA     PSTK,X
        JMP     NEXT

; FSTK- FETCH STACK- REPLACE (TOP) WITH THE (TOP)TH STK ENTRY

FSTKX:  TXA             ; A=PSP
        SEC
        SBC     PSTK,X  ; A=PSP-(TOP)
        TAY
        LDA     PSTK,Y  ; A=(PSTK(TOP))
        STA     PSTK,X
        JMP     NEXT

; PLS1- ADD 1 TO (TOP)

PLS1X:  INC     PSTK,X  ; INC (TOP) BY 1
        JMP     NEXT    ; CONTINUE

; MNS1- SUB 1 FROM (TOP)

MNS1X:  DEC     PSTK,X  ; DEC (TOP) BY 1
        JMP     NEXT    ; CONTINUE

; PLUS- ADD (TOP) TO (TOP-1)

PLUSX:  LDA     PSTK,X  ; A=(TOP)
        CLC
        ADC     PSTK-1,X; ADD (TOP) TO (TOP-1)
PLUSX00: DEX            ; POINT TO TOP-1
PLUSX0: STA     PSTK,X
PLUSX1: STX     PSP
        ROL     CRYBIT  ; SAVE CARRY
        JMP     NEXT

; MINUS- SUBTRACT (T) FROM (T-1)

MINUSX: LDA     PSTK-1,X
        SEC
        SBC     PSTK,X
        DEX
        JMP     PLUSX0

; DADD- DECIMAL ADD (T) TO (T-1)

DADDX:  LDA     PSTK,X
        CLC
        SED
        ADC     PSTK-1,X
        CLD
        JMP     PLUSX00

; PSTO- PLUS STORE- ADD (TOP-2) TO ((TOP-1,TOP))

PSTOX:  LDA     PSTK-2,X
        CLC
        ADC     (PSTK-1,X)
        STA     (PSTK-1,X)
PSTOX1: DEX
        DEX
        DEX
        JMP     PLUSX1

; NOT- ONES COMPLEMENT (TOP)

NOTX:   LDA     #0FFH   ; SET UP EOR
        EOR     PSTK,X  ; A=NOT(TOP)
        STA     PSTK,X  ; (TOP)=NOT(TOP)
        JMP     NEXT

; ABS- (TOP)=ABS(TOP)

ABSX:   LDA     #0
        SEC
        SBC     PSTK,X  ; A=0-(TOP)
        BMI     .+4     ; BRANCH IF (TOP)>=0
        STA     PSTK,X
        JMP     NEXT

; AND- (TOP) AND (TOP-1)

ANDX:   LDA     PSTK,X  ; A=(TOP)
        AND     PSTK-1,X
DSTO:   STA     PSTK-1,X
DSTO1:  DEX
        STX     PSP
        JMP     NEXT

; OR- (TOP) OR (TOP-1)

ORX:    LDA     PSTK,X  ; A=(TOP)
        ORA     PSTK-1,X ; A=(TOP) OR (TOP-1)
        JMP     DSTO    ; CONTINUE

; XORX- (TOP) XOR (TOP-1)

XORX:   LDA     PSTK,X  ; A=(TOP)
        EOR     PSTK-1,X ; A=(TOP) XOR (TOP-1)
        JMP     DSTO    ; CONTINUE

; MIN- PUT LESSOR OF (TOP) AND (TOP-1) IN (TOP)

MINX:   LDA     PSTK,X
        CMP     PSTK-1,X
        BCS     DSTO1   ; BRANCH IF (TOP-1) IS LESS
        BCC     DSTO

; MAX- PUT GREATER OF (TOP) AND (TOP-1) IN (TOP)

MAXX:   LDA     PSTK,X
        CMP     PSTK-1,X
        BCS     DSTO
        BCC     DSTO1

; FRAM- (TOP)=((TOP))

FRAMX:  LDY     PSTK,X  ; Y=RAM ADDR
        LDA     0,Y     ; A=DATA
        STA     PSTK,X
        JMP     NEXT

; SRAM- STORE (TOP-1) INTO ((TOP))

SRAMX:  LDY     PSTK,X  ; Y=RAM ADDR
        DEX
        LDA     PSTK,X  ; A=(TOP-1)
        STA     0,Y     ; STORE (TOP-1) INTO ((TOP))
        JMP     DSTO1

; EQ- (TOP-1):(TOP). RETURN TRUE IF EQUAL.

EQX:    JSR     ACOMP   ; COMPARE
        BEQ     XTRUE

XFALSE: LDA     #0
        JMP     DSTO
XTRUE:  LDA     #0FFH
        JMP     DSTO

; NE- (TOP-1):(TOP). RETURN TRUE IF NOT EQUAL.

NEX:    JSR     ACOMP
        BNE     XTRUE
        BEQ     XFALSE

; GT- RETURN TRUE IF (TOP-1)>(TOP).

GTX:    JSR     SCOMP   ; DO SIGNED COMPARE
        BEQ     XFALSE
        BCS     XTRUE
        BCC     XFALSE
; GE- RETURN TRUE IF (TOP-1)>=(TOP).

GEX:    JSR     SCOMP
        BCS     XTRUE
        BCC     XFALSE

; LE- RETURN TRUE IF (TOP-1)<=(TOP).

LEX:    JSR     SCOMP
        BCC     XTRUE
        BEQ     XTRUE
        BNE     XFALSE

; LT- RETURN TRUE IF (TOP-1)<(TOP).

LTX:    JSR     SCOMP
        BCC     XTRUE
        BCS     XFALSE

SCOMP:  LDA     #80H
        EOR     PSTK,X
        STA     PSTK,X
        LDA     #80H
        EOR     PSTK-1,X
        STA     PSTK-1,X

ACOMP:  LDA     PSTK-1,X
        CMP     PSTK,X
        RTS

; CMP- COMPARE (TOP-1) TO (TOP). 1=LT, 2=EQ, 3=GT

CMPX:   LDA     PSTK-1,X
        INY             ; Y=1
        CMP     PSTK,X  ; (TOP-1):(TOP)
        BCC     CMP2    ; BRANCH IF Y SET
        BEQ     CMP1
        INY
CMP1:   INY
CMP2:   TYA             ; GET CODE IN A
        JMP     DSTO    ; CONTINUE

; TRUE- PUT FF ON PSTK

PTRUE:  LDX     PSP
TRUE:   LDA     #0FFH
        JMP     DUPX5

; FALSE- PUT 00 ON PSTK

PFALSE: LDX     PSP
FALSE:  LDA     #00
        JMP     DUPX5

; FET- FETCH A BYTE FROM 64K MEMORY

FETX:   LDA     (PSTK-1,X) ; A=DATA
        JMP     DSTO

; OFET- OFFSET FETCH- FETCH BYTE FROM (TOP)+(TOP-2,TOP-1)

OFETX:  LDY     PSTK,X  ; Y=DISP
        DEX
        LDA     PSTK,X
        STA     T01      ; T01=ADDR(HI)
        LDA     PSTK-1,X
        STA     T00      ; T00=ADDR(LO)
        LDA     (T00),Y  ; A=ARRAY(Y)
        JMP     DSTO    ; CONTINUE

; STO- STORE A BYTE INTO 64K MEMORY

STOX:   LDA     PSTK-2,X ; A=DATA BYTE
        STA     (PSTK-1,X) ; STORE INTO MEM
        DEX
        DEX
        JMP     DSTO1

; OSTO- OFFSET STORE- STORE (TOP-3) INTO (TOP)+(TOP-2,TOP-1)

OSTOX:  LDY     PSTK,X  ; Y=DISP
        LDA     PSTK-1,X
        STA     T01      ; T01=ADDR(HI)
        LDA     PSTK-2,X
        STA     T00      ; T00=ADDR(LO)
        LDA     PSTK-3,X
OSTOX1: STA     (T00),Y  ; STORE (TOP-3)
POP4:   TXA
        SEC
        SBC     #4      ; ADJUST PSP
        STA     PSP
        JMP     NEXT

; MOVE- MOVE (TOP) BYTES TO (TOP-1,TOP-2) FROM (TOP-3,TOP-4)

MOVEX:  LDA     PSTK-1,X
        STA     T03      ; T03=TO(HI)
        LDA     PSTK-2,X
        STA     T02      ; T02=TO(LO)
        LDA     PSTK-3,X
        STA     T01      ; T01=FROM(HI)
        LDA     PSTK-4,X
        STA     T00      ; T00=FROM(LO)
        LDA     PSTK,X
        TAX             ; X=LOOP CNT
MVLP:   LDA     (T00),Y
        STA     (T02),Y
        INY
        DEX
        BNE     MVLP    ; BRANCH IF MORE
POP5:   LDA     PSP     ; POP STK
        SEC
        SBC     #5
        STA     PSP
        JMP     NEXT

; BSET- SET ((T-2),(T-1)) FOR (T) BYTES TO (T-3)

BSETX:  LDA     PSTK-2,X
        STA     T00
        LDA     PSTK-1,X
        STA     T01
        LDY     PSTK,X
        DEY
        LDA     PSTK-3,X
BSLP:   STA     (T00),Y
        DEY
        CPY     #0FFH
        BNE     BSLP
        JMP     POP4

; PSH2- PUSH NEXT TWO BYTES ONTO PSTK
; PSH1- PUSH NEXT BYTE ONTO PSTK

PSH2X:  JSR     FICW    ; FETCH NEXT BYTE
        INX
        STA     PSTK,X
PSH1X:  JSR     FICW    ; GET NEXT BYTE
        JMP     DUPX5   ; CONTINUE

; RSET- RESET RETURN STACK PTR

RSETX:  LDX     #(RSTK-P1)
        TXS             ; SET STK PTR
        JMP     NEXT    ; CONTINUE

; PSET- RESET PARM STACK PTR

PSETX:  LDX     #0
        STX     PSP
        JMP     NEXT

; RSHF- RIGHT SHIFT (TOP-1) BY (TOP) BITS

RSHFX:  LDY     PSTK,X  ; Y=SHIFT CNT
RSHFLP: LSR     PSTK-1,X ; SHIFT RT 1 BIT
        DEY             ; DEC CTR
        BNE     RSHFLP  ; BRANCH IF MORE
        DEC     PSP
        JMP     NEXT

; LSHF- LEFT SHIFT (TOP-1) BY (TOP) BITS

LSHFX:  LDY     PSTK,X  ; Y=SHIFT CNT
LSHFLP: ASL     PSTK-1,X ; SHIFT LFT 1 BIT
        DEY             ; DEC CTR
        BNE     LSHFLP  ; BRANCH IF MORE
        DEC     PSP
        JMP     NEXT

; FOR/DO- INITIALIZE LOOP

FORX:   INX             ; PSH INIT VAL ONTO PSTK
        STY     PSTK,X  ; *
DOX:    LDA     IC+1    ; PUSH CURRENT IC ONTO RET STK
        PHA             ; *
        LDA     IC      ; *
        PHA             ; *
        LDA     PSTK-1,X ; A=LOOP LIMIT
        PHA
        LDA     PSTK,X  ; START VALUE
        PHA
        DEX             ; ADJUST PSTK
        DEX
        STX     PSP     ; *
        JMP     NEXT    ; CONTINUE

; LOOP- CONTROL LOOPING BASED ON VALUES ON RET STK
; PLOOP- ADD (TOP) TO LOOP INDEX

LOOPX:  LDA     #1      ; A=LOOP INDEX INCREMENT
        BNE     LOOPX1  ; ALWAYS BRANCH
PLOOPX: LDA     PSTK,X  ; A=LOOP INDEX INCREMENT
        DEC     PSP     ; ADJUST PSTK
LOOPX1: TSX             ; X=CURRENT RET STK INDEX
        CLC
        ADC     P1+1,X  ; ADD INCREMENT TO INDEX
        STA     P1+1,X  ; *
        CMP     P1+2,X  ; AT LIMIT YET?
        BCS     XLOOPX  ; BRANCH IF YES
        LDA     P1+3,X  ; A=IC(LO)
        STA     IC      ; *
        LDA     P1+4,X  ; A=IC(HI)
        STA     IC+1    ; *
        JMP     NEXT    ; GO THRU LOOP AGAIN

; XLOOP- EXIT LOOP

XLOOPX: PLA
        PLA
        PLA             ; STRT IC LO
        PLA             ; STRT IC HI
        JMP     NEXT

; LNDX- PUT LOOP INDEX ON PTOP.

LNDXX:  PLA             ; A=LOOP INDEX
        PHA             ; RETURN IT TO RSTK
        JMP     DUPX5   ; PUT IT ON PSTK AND EXIT

; CVB- CONVERT CHAR ON PSTK TO BINARY

CVBX:   LDA     PSTK,X  ; A=CHAR
        LDX     BASE    ; X=LOOP CTL
CVBL1:  CMP     BTBL,Y  ; IS THIS THE DIGIT?
        BEQ     CVBE1   ; BR IF YES
        INY             ; BMP CT
        DEX             ; DEC CTL
        BNE     CVBL1   ; CONTINUE
        LDX     PSP     ; CHAR NOT VALID
        DEX
        JMP     FALSE   ; RETURN FALSE
CVBE1:  LDX     PSP     ; SET PSTK PTR
        STY     PSTK,X  ; REPLACE CHAR WITH BINARY
        JMP     TRUE    ; RETURN TRUE

; CVD- CONVERT NUMBER ON PSTK TO CHAR.
;      (TOP),(TOP-1) IS DIVIDED BY BASE.
;      QUOTIENT AND REMAINDER(IN CHAR FORM) IS RETURNED.

CVDX:   LDA     PSTK,X  ; PUT DIVIDEND INTO T00,T01
        STA     T01
        LDA     PSTK-1,X
        STA     T00
        LDA     BASE    ; PUT CURRENT BASE INTO T02
        STA     T02
        JSR     IDIV    ; RETURN QUOTIENT IN T00,T01, ACC=REM
        TAY             ; Y=REMAINDER
        LDA     T00
        STA     PSTK-1,X
        LDA     T01
        STA     PSTK,X
        LDA     BTBL,Y  ; GET CHAR
        JMP     DUPX5   ; GO PUT CHAR ON PSTK

BTBL:   DB      '0123456789ABCDEF'

; SETB- SET NUMBER BASE

SETBX:  LDA     PSTK,X  ; GET BASE FROM PSTK
        DEC     PSP     ; ADJ PSTK
        JMP     DECX1

; HEX- SET BASE 16

HEXX:   LDA     #16
        BNE     DECX1

; DECIMAL- SET BASE 10

DECX:   LDA     #10
DECX1:  STA     BASE
        JMP     NEXT

; OCTAL- SET BASE 8

OCTX:   LDA     #8
        BNE     DECX1

; BIN- SET BASE 2

BINX:   LDA     #2
        BNE     DECX1

; DCHAR- DISPLAY DBUF((T))

DCHARX: LDA     PSTK,X  ; A=CHAR INDEX
        DEC     PSP     ; ADJUST PSTK
        JSR     ENCODE  ; DO CHAR
        JMP     NEXT

; UPDISP- UPDATE DISPLAY FROM DBUF((T)) TO END

UPDISPX: LDA    PSTK,X
        DEC     PSP
        JSR     UPDISPL
        JMP     NEXT

UPDISPL: STA    T05      ; SAVE START INDEX
UPDLP1: JSR     ENCODE
        INC     T05
        LDA     T05
        CMP     #DSIZE
        BMI     UPDLP1
        RTS

PRTCHRX: LDA    #SLOMEM
        JSR     ORLATCH
        LDY     #(IOB0 MOD 256)
        LDA     #1
        STA     IOB0+2  ; SELECT CTL ROM
        STY     CURBANK1
        STA     CURBANK2
        LDA     CTROM+1
        CMP     #'C'
        BNE     PRTX2   ; BRANCH IF NO CTL ROM
        LDA     CTROM   ; GET DISP TO VECTORS
        ADC     #5      ; CRRY=1 FROM CMP=
        STA     CHAINV+1
        LDA     #(CTROM SHR 8)
        STA     CHAINV+2
        JSR     CHAINV
PRTX1:  EOR     #0FFH
        SEC
        ADC     PSP
        STA     PSP
        JMP     NEXT

PRTX2:  LDA     IOB0    ; ID BYTE
        AND     #20H    ; COMPLEX?
        BNE     PRTX3   ; BRANCH IF NO
        JMP     POPX    ; IGNORE IF YES
PRTX3:  LDA     PSTK,X  ; GET CHAR FROM PSTK
        JSR     ENOP    ; ENQUEUE OUTPUT
        LDA     #7CH    ; ENABLE TRANSMIT IRQ
        STA     IOB0+3  ; *
        JMP     POPX    ; POP CHAR FROM PSTK

RDCHRX: TYA             ; CLR ACC
        LDY     IPQI    ; ANYTHINE IN I/P QUEUE?
        CPY     IPQO    ; ?
        BEQ     RDFLS   ; RETURN FALSE IF NO
        JSR     DEIP    ; GET CHAR IF YES
        AND     #7FH    ; STRIP HI BIT
        LDX     PSP     ; RESTORE X
        INX             ; ADJUST PSTK
        STA     PSTK,X  ; PUT CHAR ON PSTK
        LDA     #0FFH   ; RETURN TRUE
RDFLS:  JMP     DUPX5   ; EXIT


;       SUBROUTINES

;       SETROM

SETROM: AND     #060H
SETROM1: STA    CURROM
        ASLA;ASLA
        ROLA;ROLA
        ROLA;ROLA
        ROLA;ROLA            ; ACC=CAPSULE ADDR
        STA     T00
        LDA     LATCHS  ; ACC=SHADOW LATCH
        AND     #0F8H   ; RESET PREV CAPSULE
        ORA     T00     ; SET CURRENT CAPSULE
        STA     LATCHS
        STA     LATCH
        RTS

;       RDROM

RDROM:  LDY     #0
        LDA     (ROMPTR),Y
        INC     ROMPTR
        BNE     .+4
        INC     ROMPTR+1
        TAX             ; SET FLAGS
        RTS


;       TWOCMP

TWOCMP: LDA     #0
        SEC
        SBC     0,X
        STA     W0
        LDA     #0
        SBC     1,X
        STA     W1
        RTS

;       SUB2

SUB2:   LDA     0,X
        SEC
        SBC     0,Y
        STA     0,X
        LDA     1,X
        SBC     1,Y
        STA     1,X
        RTS

;       ADD2

ADD2:   LDA     0,X
        CLC
        ADC     0,Y
        STA     0,X
        LDA     1,X
        ADC     1,Y
        STA     1,X
        RTS

; FICW- FETCH IC WORD

FICW:   LDY     #0
        LDA     (IC),Y  ; A=NXT BYTE
INCIC:  INC     IC      ; BMP IC BY 1
        BNE     .+4
        INC     IC+1
        RTS             ; RETURN

; ENCODE- CONVERT DBUF(ACC) TO DOTS ON DISPLAY

ENCODE: TAY             ; Y=DBUF INDEX
;       STA     T00      ; FOR NONCONTINUOUS DISPLAY
        ASLA;ASLA
        STA     T00      ; FOR CONTINUOUS DISPLAY
        ASLA;ASLA
        ADC     T00
        TAX             ; X=DISPLAY INDEX
        LDA     DBUF1,Y ; A=CHAR FLAGS
        STA     T04      ; SAVE FOR LATER
        JMP     ENCMP   ; SKIP TIMER STUFF FOR NOW*****************
        CPY     CURSOR  ; IS THIS THE CURSOR?
        BNE     ENDORT  ; BRANCH IF NO
        LDA     #10H
        AND     STIME   ; IS CURSOR ON?
        BEQ     ENDORT  ; BRANCH IF NO
        LDA     #0FFH
        BNE     ENCOM   ; GO FLASH CURSOR
ENDORT: LDA     T04
        AND     #CFLSH  ; FLASHING CHAR?
        BEQ     ENFLRT  ; BRANCH IF NO
        LDA     #10H
        AND     STIME   ; TIME TO FLSH CHAR?
        BEQ     ENFLRT  ; BRANCH IF YES
        LDA     #0      ; FLASH BLANK OTHERWISE
ENCOM:  TAY
        LDA     LATCHS
        ORA     #DMASK
        STA     LATCH
        TYA
        LDY     T04
        BPL     .+4     ; BRANCH IF CHAR POSITIVE
        EOR     #0FFH   ; NEGATE PATTERN
        LDY     #PATSZ
ENLP1:  STA     DSPLY,X
        INX
        DEY
        BNE     ENLP1
        BEQ     ENXIT   ; BRANCH IF DONE
ENFLRT: LDA     T04
        AND     #CQMK   ; ALT WITH '?' ?
        BEQ     ENCMP   ; BRANCH IF NO
        LDA     #10H
        AND     STIME
        BEQ     ENCMP   ; BRANCH IF TIME TO DSPLY CHAR
        LDA     #'?'
        BNE     ENCMP1  ; DSPLY '?'
; COMPUTE A(DOT PATTERN) & PUT IT IN (T00,T01)
ENCMP:  LDA     DBUF,Y  ; A=CHAR
ENCMP1: JSR     GETDOTS ; GET DOTS FOR CHAR
; NOW SET UP ACCENT VECTOR...
        LDA     #0FH
        AND     T04      ; A=ACCENT INDEX
        STA     T02
        ASLA;ASLA
        ASLA;ASLA
        ADC     T02
        ADC     ACVECT  ; LOCATE ACCENT PATTERN
        STA     T02
        LDA     #0
        ADC     ACVECT+1
        STA     T03
; (T02,T03)=A(ACCENT PATTERN). SET T04=REVERSE MASK...
        LDY     #0
        BIT     T04      ; TEST CNEG (80H)
        BPL     .+3     ; BRANCH IF POS
        DEY             ; SET Y=FF
        STY     T04      ; T04=MASK
; NOW WRITE CHAR TO DISPLAY...
        LDY     #0
        LDA     LATCHS
        ORA     #DMASK
        STA     LATCH
ENLP2:  LDA     (T00),Y  ; A=CHAR PATTERN
        ORA     (T02),Y  ; A=CHAR+ACCENT PATTERN
        EOR     T04      ; NEGATE IF REQD
        STA     DSPLY,X ; STORE INTO DISPLAY
        INX
        INY
        CPY     #PATSZ
        BNE     ENLP2   ; BRANCH IF MORE
        LDA     #0      ; FOR CONTINUOUS DISPLAY
        EOR     T04      ; FOR CONTINUOUS DISPLAY
        STA     DSPLY,X ; FOR CONTINUOUS DISPLAY
ENXIT:  LDA     #255-DMASK
        JSR     ANDLATCH ; RESET MASK
        RTS

; GETDOTS- SET T00,T01 = A(DOT PATTERN) OF CHAR IN A

GETDOTS: STA    T02
        LDA     #PATSZ  ; A=PATTERN SIZE
        STA     T00
        JSR     IMPY    ; (T0,T01)=T00*T02
        CLC
        ADC     CHVECT  ; ADD T00,T01 TO A(CHAR SET)
        STA     T00
        LDA     T01
        ADC     CHVECT+1
        STA     T01
        RTS

; IMPY- INTEGER MULTIPLY: SET (T00,T01)=T00*T02

IMPY:   LDA     #0
        STA     T01      ; T01,ACC IS ACCUM
        LDY     #8      ; Y=LOOP CNTRL
IMLP1:  ASLA;ASLA
        ROL     T01
        ROL     T00
        BCC     IMLP1E
        CLC
        ADC     T02
        BCC     IMLP1E
        INC     T01
IMLP1E: DEY
        BNE     IMLP1
        STA     T00
        RTS

; IDIV- INTEGER DIVIDE. DIVIDE T00,T01 BY T02`. LEAVE QUOTIENT
;         IN T00,T01, REMAINDER IN ACC.

IDIV:   LDA     #0      ; CLR ACC
        LDY     #16     ; INIT LOOP CTL

IDIVLP: CMP     T02      ; CAN DIVISOR BE SUBTRACTED?
        BCC     .+4     ; BRANCH IF NO
        SBC     T02      ; SUBTRACT IT IF YES
        ROL     T00      ; ROTATE CARRY INTO QUOTIENT
        ROL     T01      ; *
        ROLA;ROLA            ; AND DIVIDEND INTO ACC
        DEY
        BNE     IDIVLP  ; CONTINUE IF MORE
        RTS             ; RETURN IF DONE

X3:

ACPAT:  DB      0,0,0,0,0,0,0,0 ; ACCENT(0)=BLANK

KBSET   EQU     .
        INCLUDE CHARS.MIC(KBSET)

CHSET   EQU     .
        INCLUDE CHARS.MIC(CHAR1)
;       INCLUDE CHARS.MIC(CHAR2)

        INCLUDE HITEST.MIC(HILVL)

        ORG     IDICT+0FFAH
NMIVECT:DW      NMIEP   ; NMI
RSTVECT:DW      INIT    ; RESTART
IRQVECT: DW     IRQEP   ; IRQ

        END
  7 <f