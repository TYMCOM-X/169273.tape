	UNIVERSAL  $SCNDC -- DECLARATIONS FOR COMMAND SCANNER

	IF1,<		;DEFINE ONLY DURING PASS 1

;DEFINE MACRO TO PASS DECLARATIONS ON TO EACH SUB-MODULE
	DEFINE	$SCNDC,<
	SUBTTL	P.CONKLIN/DJB/DMN/DAL/PFC -- %7(541)	 17-SEP-74

	LALL

;***COPYRIGHT 1970, 1971, 1972, 1973, 1974, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

	SALL		;;SUPPRESS MACRO LISTINGS

	SCNDC1		;;GET REST OF DECLARATIONS
>	;END OF $SCNDC


CUSTVR==1		;CUSTOMER VERSION
DECVER==7		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==541		;DEC EDIT VERSION


;ASSEMBLY INSTRUCTIONS:
;MAKE A FILE, U.MAC, CONTAINING JUST  %.C==-3
;.COMPILE	U+C(P,,),U+SCNMAC(P,,),SCAN(P,,),HELPER
;THEN LOAD THE .REL FILE WITH ANY PROGRAM


;************ W A R N I N G ************
;** CHANGE SCANDM IF LOW-SEG CHANGES  **
;***************************************


	SEARCH	C,SCNMAC	;SEARCH PARAMETERS FOR THIS FILE

;AC NAMES

T1=1		;TEMPORARIES
T2=2
T3=3
T4=4

P1=5		;PRESERVED ACS FOR CALLING ROUTINES
P2=6
P3=7
P4=10

P=17		;PUSH-DOWN POINTER
	SUBTTL	PARAMETERS AND DEFAULTS

;ASSEMBLY PARAMETERS

ND DEBUG$,1		;1=INCLUDE DEBUGGING FEATURES
ND ECHO$C,0		;1=ECHO COMMAND STRING AS CHARACTER PROCESSED
ND ECHO$P,0		;1=ECHO COMMAND STRING AS PHRASE PROCESSED
ND ECHO$W,0		;1=ECHO COMMAND STRING AS WORD PROCESSED
ND FT$ALT,0		;1=CONVERT 175,176 TO 033
ND FT$SFD,-1		;SUB-FILE DIRECTORIES
ND FT$UEQ,0		;1=UNDERLINE SAME AS EQUALS
ND LN$ABF,200		;LENGTH OF INDIRECT BUFFER
ND M$INDP,^D10		;MAX. INDIRECT DEPTH (-1=INF., 0=NONE)


DM MSG,77777,0,7	;MESSAGE
DM PRO,777,0,277	;PROTECTION
DM RNC,777777,0,0	;RUN CORE
DM RUN,7,-1,1		;RUN OFFSET

VRBADX==10	;/MESSAGE:ADDRESS

;COMPLETE DEFINITION OF DECLARATIONS MACRO
	DEFINE	SCNDC1,<

	SEARCH	C,SCNMAC	;;USE SYMBOLS FROM C.MAC+SCNMAC.MAC

XP %%SCAN,CUSTVR*1B2+DECVER*1B11+DECMVR*1B17+DECEVR
	....==%%C
	PURGE	CUSTVR,DECVER,DECMVR,DECEVR,....

	TWOSEG
	RELOC	400000
>	;END OF SCNDC1
;       	TABLE OF CONTENTS FOR SCAN
;
;
;                          SECTION                            PAGE
;    1. PARAMETERS AND DEFAULTS...............................   2
;    2. REVISION HISTORY......................................   4
;    3. DEFINITIONS FOR THIS SUB-MODULE.......................  12
;    4. INITIALIZE............................................  14
;    5. TRADITIONAL COMMAND SCANNER...........................  20
;    6. MAIN LOOP FOR TRADITIONAL COMMAND SCANNING............  23
;    7. VERB FORM COMMAND SCANNER.............................  26
;    8. OPTION FILE SCANNER...................................  29
;    9. PARTIAL SCANNER.......................................  32
;   10. INDIRECT FILE SETUP AND FINISH........................  35
;   11. RUN COMMAND PROCESSING................................  40
;   12. SUBROUTINES FOR COMMAND INPUT -- FILE SPECIFICATION...  41
;   13. SUBROUTINES FOR COMMAND INPUT -- SWITCH/VERB PROCESS..  50
;   14. SUBROUTINES FOR COMMAND INPUT -- GET DATE/TIME........  70
;   15. SUBROUTINES FOR COMMAND INPUT -- GET WORD/STRING......  80
;   16. SUBROUTINES FOR COMMAND INPUT -- GET NEXT CHARACTER...  94
;   17. INDIRECT FILE HANDLING................................ 103
;   18. ROUTINE TO CONVERT SCAN BLOCKS........................ 111
;   19. SUBROUTINES FOR ERROR MESSAGE OUTPUT.................. 112
;   20. STORAGE............................................... 118
;   21. .VERBO MODULE......................................... 123
;   22. .TNEWL DUMMY MODULE................................... 126
;   23. .TOUTS MODULE......................................... 127
;   24. .STOPB MODULE......................................... 140
;   25. .CNTDT MODULE......................................... 144
;   26. .GTPUT MODULE......................................... 148
;   27. .SAVEn MODULE......................................... 151
	SUBTTL	REVISION HISTORY

;%1 (SCANER) -- 6/71 WITH 5.03 MONITOR

;A)  MOVE MACROS TO C.MAC AND SCNMAC.MAC.  USE ALL BIT AND
;	BYTE DEFINITIONS FROM C.MAC.  DEFINE FILE SPEC AREA
;	IN SCNMAC.MAC.
;B)  RESTRICT AC USAGE TO 1-10 (1-4 TEMPS, 5-10 PRESERVED).
;	FLAGS AND MASK MOVED TO CORE.  NAME MOVED TO 7, CHARACTER
;	TO 10.
;C)  INDIRECT I/O REDUCED TO CHANNEL 0 AND READ ONE BLOCK AT A TIME.
;D)  CHARACTER CODING CHANGED TO FOLLOWING:  ESCAPE=0, END OF LINE=-1,
;	END OF FILE=-2.  OCCASIONALLY 200 IS END OF LINE (SAVCHR).
;E)  ALL UUOS AND THEIR BITS, BYTES, AND FUNCTIONS ARE SYMBOLIZED WITH
;	C.MAC.
;F)  CALLING SEQUENCES CHANGED TO BE A BLOCK POINTED TO FROM AC1 TO GIVE
;	UPWARD GROWTH COMPATIBLY.  MANY PARAMETERS ARE OPTIONAL.
;G)  INDIRECT/CCL CODE PLACED UNDER CONDITIONAL.
;H)  TYPEOUT CHARACTER ROUTINE SEPARATED.  CAN BE ARGUMENT.
;I)  ALLOW PROGRAM TO SPECIFY A PRESET INDIRECT FILE.
;J)  CHANGE ALL INTERNALS TO INCLUDE PERIOD IN NAME.
;K)  WHEN SKIPPING OVER RESCANNED LINE, AVOID POSSIBLE TT IN WAIT.
;L)  RECODE EOF HANDLING TO COVER ALL CASES.
;M)  ADD TSCAN ARGS TO GIVE USER CONTROL AT KEY POINTS IN SCAN.
;N)  CHANGE MESSAGE FROM "ILLEGAL COMMAND SYNTAX CHARACTER" TO
;	"ILLEGAL CHARACTER".  TYPEOUT ASCII 7,11-15,33 MNEMONICALLY.
;O)  IMPLEMENT MULTIPLE OUTPUT SPECS FOR COMPILERS.  IF MULT. OUTPUT,
;	THE = (OR _) IS MANDATORY.
;P)  ADD WORDS FOR /BEFORE/SINCE.  SWITCH SCAN WILL BE IMPLEMENTED
;	LATER.  ALSO ADD .GTNOW (INTERNAL DATE FORMAT CONVERTER).
;Q)  ADD MESSAGE "?PROTECTION SWITCH ILLEGAL IN INPUT FILE".
;	REMOVE "? TOO MANY INPUT FILES".
;R)  IMPLEMENT /RUN/RUNOFFSET SWITCHES.
;S)  IN VERB MODE, PERIOD BEFORE VERB SETS STICKY DEFAULTS.
;	CHANGE LOGIC SO VERBS FOR A FILE APPEAR AFTER THE
;	FILES DEFINITION.
;T)  DEFEAT ^O BEFORE TYPING * / OR #.
;U)  IN VERB MODE, ADD NEW MESSAGE
;	? EXCESS ARGUMENTS STARTING WITH ....
;V)  IN VERB MODE, IGNORE LEADING /.  THIS ALLOWS /HELP TO
;	WORK IN ANY PROGRAM.
;W)  .VSCAN WILL RETURN ONLY AT TOP LEVEL EOF.
;X)  GENERALIZE /HELP ARGUMENT TO GIVE SIXBIT PROGRAM NAME
;	(-1 FOR GETTAB 3)  TO USE AS ARGUMENT TO HELPER.
;Y)  PUT LIMIT OF 10 ON INDIRECT FILES (ASSEMBLY PARAM)
;	ADD MESSAGES:
;	? INDIRECT SPECIFICATION INCOMPLETE
;	? TOO MANY INDIRECT FILES
;	? WILDCARD ILLEGAL IN INDIRECT SPECIFICATION
;Z)  IN FILE SCAN, FORCE NAME TO LEFT HALF.
;AA)  IN /RUN, DON'T ALLOW SWITCHES.
;AB)  IF NO FILE NAME, MAKE FILE SPEC STICKY.
;AC)  DETECT NULL DEVICE PROPERLY.
;AD)  IMPLEMENT PATH SPECIFICATION. ALSO NOTATIONS [,] [P,]
;	[,P] AND [-].
;AE)  ADD ROUTINE .GTSPC TO MOVE FILE SPEC TO STORAGE.
;AF)  ADD DEFAULT DEVICE 'DSK:' IF USER TYPES PART OF A SPEC BUT
;	OMITS THE DEVICE.
;AG)  ADD INTERNAL (STANDARD) SWITCHES WHICH COMPETE EQUALLY
;	FOR ABBREVIATIONS, BUT ON EXACT EQUIVALENCE THE CALLER'S
;	SWITCHES OVERRIDE.
;AH)  ADD MESSAGE: ? AMBIGUOUS SWITCH.
;AI)  IF SWITCH TABLES GIVE NO MAX, THEN ALWAYS GO TO PROCESSOR.
;	IF SWITCH TABLES OMIT POINTER (LH=0), CALL ROUTINE
;	POINTED TO BY RH.
;AJ)  ALLOW KEYWORD SWITCHES TO GET VALUE "0" TO CLEAR INDEX.
;AK)  EXPAND TWO WORD SIXBIT SCAN TO BE MULTIWORD.
;AL)  ADD /HELP:SWITCHES TO LIST ACTUAL SWITCH TABLE.
;AM)  ADD SWITCH TABLE PREFIX '*' TO MEAN ALL ABBREVIATIONS ARE
;	EXACT MATCHES.
;AN)  ADD STANDARD SWITCHES /DENSITY,/OKNONE,/PARITY,/PHYSICAL,
;	/PROTECTION,/STRS.
;AO)  ADD MESSAGES:
;	? IMPROPER PROJECT NUMBER
;	? IMPROPER PROGRAMMER NUMBER
;	? SFD DEPTH GREATER THAN 5
;	? NULL SFD ILLEGAL
;	? NO SWITCH SPECIFIED
;	? SWITCH VALUE NEGATIVE
;AP)  CORRECT LOGIC WHICH MEMORIZED STICKY SWITCHES.
;AQ)  # PREFIX ON DECIMAL INPUT IMPLIES OCTAL INPUT.
;AR)  ALLOW - ON DECIMAL/OCTAL INPUT.
;AS)  RECODE ALGORITHM WHICH HANDLES CONTINUATION, COMMENTS, AND
;	MULTIPLE SPACES TO HANDLE ALL CASES CORRECTLY.
;AT)  ADD CHKACC UUO ON INDIRECT FILES LOOKUPS IN CASE CALLER
;	HAS JACCT ON.
;AU)  IF NO . IN @, CHECK .(NUL) AFTER .CCL.
;AV)  SKIP SEQUENCE NUMBERS IN @ FILE.
;AW)  RECODE END/ERROR LOGIC ON @ FILES TO ALWAYS HANDLE CCL
;	FILES CORRECTLY.  IN PARTICULAR, DELETE .TMP FILES
;	AFTER SUCCESSFUL CCL CALL.
;AX)  CHANGE OCTAL FATAL MESSAGE TO RH(N) FOR CONSISTENCY.
;AY)  ON ERROR IN INDIRECT FILE, SKIP TO END OF LINE.
;AZ)  ON VERB @ ERROR, TERMINATE @ FILE.
;BA)  WHEN DOING MONRT., RESET ALL I/O.  IF NOT LOGGED IN,
;	EXCLUDE THE ^D IN PREVIOUS VERSIONS.
;BB)  ADD NEW ROUTINE (.TFBLK) TO TYPE SCAN STYLE FILESPEC AREA.
;BC)  ADD NEW ROUTINE (.TDIRB) TO TYPE DIRECTORY IN SINGLE WORD,
;	SFD, OR SCAN FORMATS.
;BD)  ADD NEW ROUTINE (.TFCHR)  TO TYPE POSSIBLE FUNNY CHARS.
;	IT HANDLES CONTROL AND LOWER CASE FLAGGING.
;BE)  EXPAND ALL P,PN HANDLING TO ALLOW ONE SIXBIT WORD INSTEAD
;	OF TWO OCTAL HALF WORDS.
;BF)  CHANGE CALLS TO ALL TYPEOUT ROUTINES TO PASS ARGS IN T1.
;BG)  REMOVE ALL OUTSTR/OUTCHR CALLS EXCEPT PROMPTS.
;BH)  HANDLE SIGNED NUMBERS IN RADIX TYPER.
;BI)  CHANGE SAVEN CALL TO BE PUSHJ.
;BJ)  INTERN F.NAM AS FLAG FOR SWITCH SCANNERS.

;%2(127) -- 5/72 WITH DIRECT %2.

;130	REMOVE INTERNS. MAKE ALL DOT SYMBOLS INTERN WITH ::.
;131	REMOVE # OUTPUT ON INDIRECT CONTINUATIONS (SPR 10-7212).
;132	BAN MULTIPLE BUFFER INDIRECT FILE ONLY ON DTA (SPR 10-7212).
;133	SPLIT .TICHT FROM .TICHE
;134	FIX BUG IN .CNVDT
;135	ADD .CNTDT (INVERSE OF .CNVDT)
;136	CREATE .PSCAN FOR PEOPLE WITH PARTIAL SCAN NEEDS
;137	CHANGE ALLDON TO .ALDON
;140	CLEAR SCANPC ON .CLRBF
;141	ADD PROTECTIVE TESTS TO CNVDAT
;142	ADD TTY INPUT AND  MONRET ROUTINES IN ISCAN CALL
;143	CHANGE RUNXYZ TO N.XYZ; USE .FX SYMBOLS
;144	ADD /BEFORE/SINCE SWITCHES
;145	ALLOW / BETWEEN PROJ AND PROG IN DIRECTORIES
;146	DON'T FLUSH NULL FILE SPECS
;147	ADD DATE/TIME SCANNERS.
;150	ADD .OSCAN ROUTINE.
;151	ADD /OPTION SWITCH TO SELECT OPTIONS FROM SWITCH.INI FILE.
;152	ADD .SWFIL TO HANDLE FILE SWITCHES
;153	CANCEL 145 AS A BAD IDEA.
;154	HANDLE MISSING DIRECTORIES IN OPTIONS LOOKUPS.  CORRECT BUG
;	WHICH DECREMENTED START ADDRESS ON OPTIONS NOT FOUND.
;155	CREATE ROUTINE .TERRP (WAS FMADDR)
;156	SPLIT INTO 4 SUB-MODULES--SCAN, OUTPUT, DATE, SAVE
;157	CREATE UNIVERSAL .SCNDC TO PASS PARAMETERS TO EACH SUB-MODULE
;160	HANDLE NUMBERS IN ILL.CHAR MESSAGE
;161	UPDATE LASCHR ON STRING INPUT (.TIGET)
;162	DEFINE .SCANZ AND .SCANL FOR SEGMENT SHUFFLERS
;163	CLEAN UP EXTERNS WITH GLOB.SNO
;164	GIVE USER EXIT ONLY ON HIS OWN SWITCHES
;165	ADD .TTABC ROUTINE TO TYPE A TAB, ETC.
;166	ALLOW FOR PARTIAL WORD IN LAST WORD OF IND. FILE BUFFER
;167	ADD .TTIME, .TDATE TO TYPE OUT DATE AND TIME
;170	MAKE MULTIWORD AREA HANDLE WORST CASE (30. WORDS)
;171	FIX .TRDXW TO HANDLE 1B0 CORRECTLY
;172	FIX .NAME ON SIX LETTER * SWITCHES
;173	CORRECT PDL ERROR IN .FMSGX ROUTINE IF .TSCANNING

;%3(173) -- 12/72 WITH DIRECT%3 AND DUMP%4

;174	ADD /NOSTRS /NOPHYSICAL AND /ERNONE
;175	ADD /NOOPTION
;176	FIX .PSCAN BUG IF <EOL> AFTER MONITOR COMMAND
;177	ADD DEFENSIVE HALT TO ENSURE THAT .OSCAN IS CALLED ONLY AT <EOL>
;200	(10-SEVERAL) DETECT USER ERROR OF "0" AS PROJECT OR PROGRAMMER
;201	CLEAR STICKY DEFAULTS EACH LINE OF .VSCAN AND .PSCAN
;202	E.INCL, E.ILSC INTERN
;203	FIX BUG IN HANDLING OF [] IN /RUN:
;204	CLEAR .NMUL AREA ON EACH SWITCH
;205	FIX /H:S IF NO SWITCHES.  MAKE .SWHLP INTERNAL
;206	(10-9709) PRINT WILD PPNS WITH ? INSTEAD OF 7.
;207	(10-10004) ALLOW /RUN IN OPTION FILE; HANDLE AT END (AFTER
;	COMMAND); HANDLE /SW:FILE LIKE OTHER SWITCHES.
;	MAKE N.ZER AND N.EZER INTERN FOR .PSCAN CALLERS.
;210	MULTI-WORD STORE WAS MISCHECKING DUPLICATE SWTICHES
;211	DISTINGUISH AMBIGUOUS FROM UNKNOWN SWITCH VALUES
;212	REMOVE 175, 176 CHECKS.  CAN BE RESTORED BY FT$ALT==1
;213	SET FX.NDV EVEN IF NO DEVICE SET
;214	(10-10123) REMOVE PURESW SINCE IT DOESN'T WORK
;215	CREATE A DUMMY FILE "SCANDM.MAC" WHICH CAN BE LOADED
;	WITH OTHER OVERLAYS OF MULTI-SEGMENT PROGRAMS TO RESERVE
;	SCAN'S LOW SEG AREA.
;216	SUPPORT FS.NFS
;217	SUPPORT FS.LRG
;220	CHANGE U.MOUT TO FS.MOT
;221	ADD .CKNEG, .SENEG
;222	IMPLEMENT .STOPN.  SUPPORT SFDS ON @ AND /RUN. SUPPORT
;	/DENSITY/PARITY/PHYSICAL ON @.
;223	HANDLE MONITOR COMMANDS R, RUN, AND START.  IF ONE OF
;	THESE, AND LINE HAS "-" OR "(", THEN DO ONLY ONE COMMAND,
;	THAT WHICH IS AFTER THE "-" OR BETWEEN "(" AND ")".
;224	ACCEPT TMPXXX: FOR INDIRECT FILES.  IF THE DEVICE DOES NOT
;	EXIST, TRY TMPCOR USING FIRST THREE CHARS OF FILE
;	NAME.  IF THAT FAILS, TRY DSKXXX:NNNAAA.TMP WHERE NNN
;	IS THE JOB NUMBER IN DECIMAL WITH LEADING
;	ZEROS AND AAA IF THE FIRST THREE CHARS OF THE
;	FILE NAME.
;225	ADD .PSH4T AND .POP4T ROUTINES
;226	ADD /RUNCORE:CORE AND .SWCOR AND .COREW/.COREC
;227	ADD FS.NUE TO SUPPRESS USER EXIT ON SOME SWITCHES
;230	ADD .TICQT/.TISQT TO CONTROL/SUPPORT QUOTED STRINGS.  ALLOW
;	.NAMEW (FILE NAMES, ETC.) TO HAVE QUOTED STRINGS
;	WITHOUT WILD-CARDS.  ADD .SIXQW/C, .ASCQW/C, .SWASQ,
;	.SWSXQ TO HANDLE SIXBIT AND ASCII POSSIBLY QUOTED
;	STRINGS.  (QUOTE IS ' AND ").
;231	ADD .KLIND TO KILL INPUT FOR LINK-10 (/GO).  CALL IT
;	FROM /RUN PROCESSING FOR FORTRAN-10, ETC.
;232	ADD MULTIPLE SWITCH VALUES IN TSCAN/PSCAN MODES.
;	EXCERCIZED BY /SWITCH:(VAL1,VAL2,...,VALN)
;	REQUIRES USER EXIT SWITCH STORAGE TO AVOID DUPLICATE
;	VALUE MESSAGE.
;233	HANDLE LOWER CASE IN .TICAN
;234	ADD ROUTINE .REEAT
;235	REQUIRE THAT SWITCH VALUES END WITH A NON-ALPHANUMERIC
;236	ADD /OKPROT/ERPROT
;237	SUPPORT FS.VRQ
;240	MAKE OPTION ERRORS APPEAR AS WARNINGS
;241	HANDLE VSCAN STICKY (PXXXX) ON MULTI-WORDS BUT NOT FILES
;242	FIX USER APPLY STICKY FOR TSCAN TO BE CALLED BEFORE ALLOC.
;243	ADD .CLRFL
;244	FIX BUG IN * HANDLING FOR PROJECTS
;245	RECOGNIZE @ ONLY AT START OF .TSCAN LINE
;246	ADD PROMPT ROUTINE SET BY .ISCAN; REMOVE ALL OUTCHR/OUTSTRS
;247	STORE ALL TERMINATORS OF CONCATENATED SPEC
;250	CORRECT BUG IN DATE DEFAULTER WHICH (AT 21:00) GAVE
;	FOR /AFTER:21,  <DAY>:22:00 INSTEAD OF <DAY+1>:21:00
;251	CORRECT NOT-LOGGED IN BUG WHEN DOING A MONRT. TO CALLER
;252	FOR THE CONVENIENCE OF 2741 USERS, ALLOW <> AS == TO []
;253	ON INDIRECT FILE, TRY .CMD AFTER .CCL ON NULL EXTENSION
;254	FIX BUG IN EDIT 200 WHICH CAUSES .<NUL> TO BE .*
;255	(10-11399,11423) /SINCE/BEFORE DID NOT DEFAULT ACROSS FILES
;256	GET ALL FIVE SFDS IN .TDIRB
;257	HANDLE YEARS GE 2000 IN .TDATE
;260	FIX BUG IN CCL MODE IF GT 1 BLOCK IN TMP FILE
;261	(10-11663) ALLOW JAN-1-64 IN DATES
;262	(QAR 1400) PRINT . AFTER "KJOB"
;263	ADD ROUTINE .MNRET
;264	CHANGE .PSCAN TO NOT HANDLE /RUN IMMEDIATELY
;	ADD .RUNCM TO HANDLE /RUN SWITCH
;265	REMOVE ' AS A QUOTING CHARACTER TO AGREE WITH DEC
;	COMMAND STANDARD
;266	CORRECT PSCAN BUG IN MIDDLE OF LINE
;267	(QAR 1396) PROMPT CONTINUATIONS IN COMMAND MODE
;270	REMOVE THE - OPTION ON RUN COMMANDS
;271	CANCEL 247 UNTIL STANDARD LANGUAGE IS DEFINED
;272	ADOPT ! AS AN ALTERNATE COMMENT CHARACTER
;273	HAVE TRAILING "." FORCE DECIMAL NUMBER
;274	SPIFF UP MESSAGE IF MISSING DATE/TIME VALUE
;275	BUG INTRODUCED SINCE VERSION 3

;%4(275) DEC, 1973

;276	MOVE .PTWRD HERE FROM .WILD; PUT INTO NEW SUBMODULE
;		MOVE .MKMSK TO THAT ALSO
;277	SUPPORT FS.OBV
;300	ADD /MESSAGE, .FLVRB,.VERBO AS SEPARATE MODULE
;301	ADD ARG TO CLRFL
;302	SUPPORT FS.MIO
;303	OUTPUT SCN PREFIX SUPPORTING /MESSAGE
;304	ALLOW DEV:NAME ON RESCAN
;305	ADD YESTERDAY, TODAY, TOMORROW
;306	ADD .TVERW
;307	IMPLEMENT D.TODD'S LATEST .SAVEN
;310	USE GETTAB FOR .GTNOW IF AVAILABLE
;311	INCLUDE CLEANER DATE CONVERSION
;312	MAKE .MYPPN INTERNAL
;313	FIX ^Z IN .PSCAN; ALSO FIX RUN ()
;314	IMPROVE MESSAGES "FOLLOWING WORD"
;315	ADD .TDTYM
;316	SUPPORT "NO" SWITCHES
;317	(10-12400) FIX /RUN WHEN NOT LOGGED IN
;320	FIX @ LOGIC FOR NON-DIRECTORY DEVICES TO HANDLE MULTIPLE
;	BUFFERS.
;321	ADD OPTION /MESSAGE:ADDRESS TO INCLUDE ADDRESSES OF
;	ERROR ROUTINES
;322	HANDLE EOF CORRECTLY ON MULTIPLE PSCAN.
;323	FIX 312
;324	(10-12439) AVOID ERROR MESSAGES IF CCL FILE MISSING
;325	CONSIDER DUPLICATE SWITCH OF SAME VALUE NOT AN ERROR
;326	(10-12416) DETECT TIME GT 24 HOURS
;327	ADD .QSCAN
;330	(10-12344) IMPROVE MESSAGE IF JUNK AFTER IND FILE
;331	DETECT /BEFORE/SINCE DON'T OVERLAP
;332	ADD .STOPB AS SEPARATE MODULE
;333	ADD .ERMSG
;334	CHANGE .SCND? TO $SCND?
;335	HAVE .OSCAN CALL .QSCAN NOT .PSCAN
;336	ADD .TCORW, ALLOW W AT END OF CORE INPUT FOR WORDS AND
;	ALLOW B FOR BLOCKS
;337	ADD .TBLOK, .BLOKW/C (SAME AS .COREW/C) WHICH INVOKES .TBLOK
;340	ADD .TOLEB
;341	ON OR-KEYS, ALLOW ALL AND NONE
;342	SN SWITCHES CAN TAKE :0,1,NO,YES,OFF,ON
;343	CALL SW PROCESSORS  RET+1=DPB, +2=DON
;344	LIST OF NAMES TO .OSCAN
;345	DO ALL LINES IN SWITCH.INI
;346	ADD /LENGTH/ABEFORE/ASINCE/ERSUPERSEDE/ESTIMAT/VERSION. ERROR LVI.
;347	RECOMPUTE LOGGED IN STATUS FOR LOGIN.
;350	FIX EOF ON @ LINE
;351	(10-13045) CORRECT ERROR IF DEBUG$=0
;352	(QAR 1975) FIX BUG IN 316
;353	(QAR 1975) ALLOW DEFAULT OPTION IN VSCAN
;354	(QAR 1975) CLEAR ^O ON FIRST ? MESSAGE
;355	(QAR 1975) DEFINE .TNEWL IF CALLER DIDNt
;356	MOVE OPTION TEST TO E.DSI; MAKE E.DSI AND E.SVR GLOBAL
;357	ALLOW SWITCH ON FILE SPEC IN VSCAN IF FILE MODIFIER;
;	FILE MODIFIERS AT VERB LEVEL SET STICKY DEFAULTS
;360	HANDLE R..(....) IN VSCAN WITH "/"=EOL
;361	MORE OF 352
;362	(WITHDRAWN)
;363	USE SCNMAC EDIT 77

;%5(363)  JUNE, 1974

;364	DON'T CLOBBER FLVERB ON OSCAN/QSCAN
;365	ALLOW PSCAN RESCAN WITH JUST CUSP NAME TO HAVE MULT. LINES
;366	FIX EOF LOGIC FOR PSCAN FOR LOGIN
;367	REMOVE SPURIOUS NO-OPTION MESSAGE
;370	CLEANUP .OSCAN ERROR RECOVERY

;%6(370) JULY, 1974

;401	(QAR 2424) FIX 365 TO NOT FOUL UP TSCAN
;402	SAME AS 530

;501	(10-13597) MAKE .TSTRG REENTRANT
;502	(QAR 2384) LET @ WORK TO DTA:
;503	MAKE /MESS:(ALL,NOXX) WORK
;504	(QAR 2439) FIX .FOO/RUN
;505	ADD LOGIN AS A MNEMONIC TIME
;506	ADD /EXIT
;507	ADD GUIDE WORD CONCEPT
;510	RECOGNIZE FILE SEPARATORS 'AND', 'OR', 'NOT'
;511	PREPARE TO REMOVE UNDERLINE AS SAME AS EQUALS (UNDER FT$UEQ)
;512	ALLOW * AT END OF NAME (IN FUT., ? NOT MATCH NULL)
;513	ADD .OSDFS
;514	ADD NON-FILE SWITCHES BEFORE @ (ONLY FIRST LINE OF IND FILE)
;515	(QAR 1975) ALLOW A=B,C=D
;516	DON'T SET DSK: IF ONLY GLOBAL SWITCHES
;517	REMOVE DIALOGUE MODE INTRODUCTION
;520	ADD MNEMONIC DATE-TIME OF NOON AND MIDNIGHT
;521	IMPROVE SAVEN ROUTINES EVEN MORE
;522	ADD % ATTRIBUTES AND IGNORE THEM
;523	ADD GUIDES 4002-4011
;524	AVOID HALT ON @ ERRORS
;525	(10-13,818) FIX TO PROMPT ON CONTINUATION OF COMMAND
;526	(10-13,818) REMOVERP AS REDUNDANT
;527	(10-13,817) DON'T DISCARD LEADING SPACE OF CONT. LINE
;530	(10-13,999) FIX BUG IN 313 WHICH DISALLOWED CONT. OF MONITOR COMMAND
;531	ALLOW /MESSAGE TO DEFAULT TO :(PREFIX,FIRST,CONT)
;532	ADD /TMPFILE SWITCH TO WRITE TMPCOR
;533	(10-13,943) DETECT A,B ERROR ON FS.MOT
;534	ADD (...) TO SET CLEAR DEFAULTS
;535	ALLOW @A,@B
;536	ADD DENSITIES OF 1600 AND 6250 FOR 5.07 AND 6.02.
;537	REMOVE NON-SWITCHES FROM .OSDFS LOGIC.
;540	FIX 535
;541	DON'T RECOGNIZE GUIDE WORDS IN QUOTES

>	;END OF IF1 FROM FIRST PAGE
	PRGEND
	TITLE	.SCAN -- GENERALIZED USER MODE COMMAND SCANNER

	SEARCH	$SCNDC		;GET SCAN DECLARATIONS
	$SCNDC			;INITIALIZE LISTING, ETC.

;ENTRY POINTS

	ENTRY	.ISCAN		;ONLY INITIALIZER SINCE THAT MUST BE CALLED
	SUBTTL	DEFINITIONS FOR THIS SUB-MODULE

;AC NAMES

N=P3		;NUMBER OR NAME ACCUMULATION  PRESERVED ONLY AT TOP LEVEL
C=P4		;CHARACTER INPUT	      PRESERVED ONLY AT TOP LEVEL
			;WITH THE FOLLOWING ENCODING:
			;  -2   =EOF
			;  -1   =EOL
			;   0   =ESCAPE OR ALTMODE
			;  1-177=ASCII CHARACTER
			;THUS, TO TEST FOR END OF COMMAND LINE,
			;	JUMPLE	C,...JUMP ON EOL...

	PURGE	P3,P4	;NOT USED IN THIS SUB-MODULE

;I/O CHANNELS

IFN M$INDP,<
IND==0		;INDIRECT FILE (TEMPORARY; ONLY OPEN WHEN PC IS IN SCAN)
>

;CHARACTERS

C.TE==7777	;TEMPORARY EOL CODE FOR SAVCHR FLAG		[507]

;TEMPORARY DEFS UNTIL DEFINED LATER ON

IF1,<	FXNOTO==1,,1
	FXNOTI==1,,0
	FXNOTD==1,,0>
;M$FAIL (XYZ,FOO) SENDS TEXT FOO WITH PREFIX "SCNXYZ" AS A FATAL ERROR

DEFINE	M$FAIL ($PFX,$TEXT),<
E$$'$PFX:	PJSP	T1,FMSG
	XLIST
	''$PFX'',,[ASCIZ \$TEXT\]
	LIST
>

;M$FAIN (XYZ,FOO) SENDS TEXT FOO WITH PREFIX "SCNXYZ" AS A FATAL ERROR WITH N IN SIXBIT

DEFINE	M$FAIN ($PFX,$TEXT),<
E$$'$PFX:	PJSP	T1,FMSGN
	XLIST
	''$PFX'',,[ASCIZ \$TEXT\]
	LIST
>

;M$FAID (XYZ,FOO) SENDS TEXT FOO WITH PREFIX "SCNXYZ" AS A FATAL ERROR WITH N IN DECIMAL

DEFINE	M$FAID ($PFX,$TEXT),<
E$$'$PFX:	PJSP	T1,FMSGD
	XLIST
	''$PFX'',,[ASCIZ \$TEXT\]
	LIST	
>

;M$FAIO (XYZ,FOO) SENDS TEXT FOO WITH PREFIX "SCNXYZ" AS A FATAL ERROR WITH N IN OCTAL

DEFINE	M$FAIO ($PFX,$TEXT),<
E$$'$PFX:	PJSP	T1,FMSGO
	XLIST
	''$PFX'',,[ASCIZ \$TEXT\]
	LIST
>

;M$MAIF (XYZ,FOO) SENDS TEXT FOO WITH PREFIX "SCNXYZ" AS A FATAL ERROR WITH N=ADDR OF FILE DESCRIPTOR

DEFINE	M$FAIF ($PFX,$TEXT),<
E$$'$PFX:	PJSP	T1,FMSGF
	XLIST
	''$PFX'',,[ASCIZ \$TEXT\]
	LIST
>
	SUBTTL	INITIALIZE

;.ISCAN--SUBROUTINE TO INITIALIZE COMMAND SCANNER
;CALL	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=0 OR IOWD PTR TO A LIST OF LEGAL MONITOR COMMANDS
;		IF 0, NO RESCAN IS DONE
;	BLOCK+1=RH 0 OR SIXBIT CCL NAME
;		  IF 0, NO CCL MODE
;		LH 0 OR ADDRESS OF STARTING OFFSET
;	BLOCK+2=RH 0 OR ADDRESS OF CHARACTER TYPEOUT ROUTINE
;		  IF 0, OUTCHR WILL BE DONE FROM T1
;		LH 0 OR ADDRESS OF CHARACTER INPUT ROUTINE
;			MUST SAVE ALL ACS, CHAR IN P4
;	BLOCK+3=0 OR POINTER (XWD LEN,BLOCK) TO INDIRECT FILE BLOCK
;		  A.DEV NE 0 TO USE BLOCK
;	BLOCK+4=RH 0 OR ADDRESS OF MONRET ROUTINE
;		LH 0 OR ADDRESS OF PROMPT ROUTINE
;			CALLED WITH CHAR IN RH(T1), LH(T1) HAS
;			    0 FOR FIRST LINE, -1 FOR CONTINUATION LINES
;	BLOCK+5=LH FLAGS
;		RH (FUTURE)
;VALUE	AC1=INDEX IN TABLE OF COMMANDS IF FOUND(0,1,...), ELSE -1


.ISCAN::MOVEM	P,SAVPDP	;PRESET PDL MEMORY
	SETZM	SAVCAL		;CLEAR CALL MEMORY
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	HLRZ	T2,T1		;GET ARGUMENT COUNT
	PUSHJ	P,.GTWRD##	;GET BLOCK+0
	MOVEM	T3,SWTPTR	;STORE POINTER TO COMMAND NAMES
	PUSHJ	P,.GTWRD##	;GET BLOCK+1
IFN M$INDP,<
	HRRZM	T3,CCLNAM	;SAVE CCL NAME
	TRNE	T3,-1		;IF SETUP, CHECK OFFSET
	HLRZ	T3,T3		;GET ADDRESS OF OFFSET
	TRNE	T3,-1		;SKIP FETCH IF 0
	MOVE	P1,(T3)		;GET OFFSET
>
	PUSHJ	P,.GTWRD##	;GET BLOCK+2
	HLRZM	T3,TYPIN	;SAVE CHARACTER TYPEIN ROUTINE
	HRRZS	T3		;CLEAR TYPEIN NAME
	PUSH	P,T3		;SAVE CHARACTER TYPEOUT ROUTINE
	PUSHJ	P,.GTWRD##	;GET BLOCK+3
IFN M$INDP,<
	SKIPN	.FXDEV(T3)  	;SEE IF DEVICE
	MOVEI	T3,0		;NO--CLEAR POINTER
	MOVEM	T3,USRIND	;SET FLAG OF USER SUPPLIED IND. FILE
	JUMPE	T3,ISCANI	;PROCEED IF NO FILE
	HRLZ	T4,T3		;SETUP BLT
	HRRI	T4,A.ZER	;  FROM USER
	HLRZ	T3,T3		;  TO A.ZER
	CAILE	T3,A.EZER-A.ZER+1
	MOVEI	T3,A.EZER-A.ZER+1
	BLT	T4,A.ZER-1(T3)	;BUT NOT TOO FAR
>
ISCANI:	PUSHJ	P,.GTWRD##	;GET BLOCK+4
	HLRZM	T3,PROMPT	;SAVE USER PROMPT ROUTINE
	HRRZM	T3,MONRT	;SAVE USER MONRET
	PUSHJ	P,.GTWRD##	;GET BLOCK+5			[366]
	MOVEM	T3,INIFLG	;STORE FLAGS			[366]
	HRREI	C,.CHEOL	;PRESET EOL JUST IN CASE
	SETZM	ZCOR		;CLEAR CORE
	MOVE	T1,[ZCOR,,ZCOR+1]
	BLT	T1,EZCOR

	SETOM	OPTION		;CLEAR OPTION			[353]
	GETPPN	T1,		;GET OUR PPN
	  JFCL			;(IN CASE OF JACCT)
	MOVEM	T1,.MYPPN	;SAVE FOR LATER USE		[312]
IFN M$INDP,<
	CAIE	P1,1		;SEE IF OFFSET IS ONE
	JRST	ISCANR		;NO--SKIP ON
	AOS	FLCCL		;YES--INDICATE CCL (WITH FLAG FOR TMPCOR POSSIBLE)
	SETOM	FLCCMD		;ALSO INDICATE CCL OR COMMAND
ISCANR:	SETOM	N.OFFS		;CLEAR RUN OFFSET
	SETOM	N.CORE		;CLEAR RUN CORE
IFG M$INDP,<
	MOVEI	T1,M$INDP	;PRESET INDIRECT FILE
	SKIPN	A.DEV		;  COUNT TO CORRECT
	CAIN	P1,1		;  VALUE IF OFFSET ONE
	MOVEM	T1,INDCNT	;  OR IND. FILE POINTER
>
>

	POP	P,T1		;RESTORE NAME OF TYPEOUT ROUTINE
	PUSHJ	P,.TYOCH##	;INITIALIZE TYPEOUT ROUTINES
	SETOM	CALCNT		;PRESET CALL COUNTER
	PJOB	T1,		;GET THIS JOB'S NUMBER
IFN M$INDP,<
	PUSHJ	P,.MKPJN	;MAKE INTO SIXBIT
	HRLM	T1,CCLNAM	;  STORE JOB NUMBER
>

	MOVE	T1,.JBREL	;SAVE CURRENT CORE
	HRL	T1,.JBFF	;ALSO SAVE .JBFF
	MOVEM	T1,SAVCOR	;  FOR LATER TO RESTORE

IFN M$INDP,<
	SETZB	T1,T3		;GET "LOGIN"
	MOVSI	T2,'DSK'	; TIME
	OPEN	IND,T1		; ..
	  JRST	ISCAN9		;CAN'T!
	MOVE	T1,.MYPPN	;GET
	MOVSI	T2,'UFD'	; MY
	MOVX	T4,%LDMFD	; UFD
	GETTAB	T4,		; (IN
	  MOVE	T4,[1,,]	; MFD)
	LOOKUP	IND,T1		; ..
	  JRST	ISCAN9		;CAN'T!
	LDB	T1,[POINTR (T3,RB.CRT)] ;GET CREATION
	IMULI	T1,^D60000	; TIME INTO MILLI-SEC.
	LSH	T2,-3		;POSITION EXTENDED DATE
	ANDI	T2,70000	;REMOVE JUNK
	ANDX	T3,RB.CRD	;GET MAIN PART OF DATE
	IOR	T2,T3		;GET ENTIRE CREATION DATE
	PUSHJ	P,.CNVDT##	;CONVERT TO INTERNAL FORM
	MOVEM	T1,LOGTIM	;SAVE AS "LOGIN" TIME

ISCAN9:	SKIPE	A.DEV		;SEE IF PRESET INDIRECT
	PUSHJ	P,INDGT1	;YES--FINISH SETUP
	SKIPN	FLCCL		;SKIP IF CCL ENTRY
	JRST	COMND		;NO, LOOK FOR MONITOR COMMAND
	MOVSI	T1,'TMP'	;CCL DEVICE IS TMP:
	MOVEM	T1,A.DEV
	PUSHJ	P,INDGT1	;COMPLETE SETUP
	PJRST	COMND2		;RETURN INDICATING NOT A COMMAND


;.MKPJN--SUBROUTINE TO MAKE CCL JOB NUMBER
;CALL:	MOVE	T1,JOB NUMBER
;	PUSHJ	P,.MKPJN
;RETURNS VALUE IN RH(T1)
;CHANGES T2, T3, T4

.MKPJN::MOVEI	T4,3		;MAKE TEMP FILE NAME
MAKPJ1:	IDIVI	T1,^D10		; BY TRIED AND
	ADDI	T2,'0'		; TRUE CCL
	LSHC	T2,-6		; TECHNIQUE
	SOJG	T4,MAKPJ1	; ..
	HLRZ	T1,T3		;POSITION ANSWER
	POPJ	P,
>
;HERE ON A NORMAL START

COMND:	SKIPN	SWTPTR		;SEE IF ANY COMMANDS
	JRST	COMND2		;NO--IGNORE RESCAN
	RESCAN	1		;BACK UP TTY INPUT TO SEE IF COMMAND
	  SKPINC		;SEE IF ANYTHING THERE
	    JRST COMND2		;NO--MUST HAVE COME FROM CUSP LEVEL
	SETOM	P1		;SET PREFIX COUNTER		[304]
COMNDG:	PUSHJ	P,.SIXSW	;GET SIXBIT WORD
	JUMPLE	C,.+2		;IF END OF LINE, GIVE UP GRACEFULLY
	JUMPE	N,COMNDG	;IF NULL, LOOP BACK FOR MORE
	JUMPE	N,COMND2	;SKIP TESTS IF NO COMMAND ON LINE
	CAIN	C,":"		;SEE IF DEVICE			[304]
	AOJE	P1,COMNDG	;IF FIRST ONE, TRY AGAIN	[304]

	MOVE	T1,[IOWD 2,['RUN   '
			    'START '] ]
	SKIPGE	P1		;UNLESS DEVICE STARTER, 	[304]
	PUSHJ	P,.NAME		;SEE IF R, RUN, OR START
	  JRST	COMNDU		;NO--GO CHECK FOR NAME
COMNDL:	JUMPLE	C,COMND2	;IF END OF LINE, GIVE UP
	CAIN	C,"("		;SEE IF (...) FORMAT		[270]
	JRST	COMNDR		;YES--GO HANDLE
	SKPINC			;SEE IF MORE TO COME
	  TLOA	C,-1		;NO--SET END OF LINE
	PUSHJ	P,.TIALT	;YES--GET IT
	JRST	COMNDL		;LOOP UNTIL DONE

COMNDR:	SETOM	FLRCMD		;FLAG (...) INSTEAD		[270]
	HRRZ	T1,SWTPTR	;GIVE ERROR RETURN
	HRREI	C,.CHEOL	;INDICATE START OF LINE		[360]
	MOVEM	C,LASCHR	; IN CASE OSCAN CALLED NEXT	[360]
	JRST	COMNDC		;AND FINISH SETUP OF COMMAND
COMNDU:	MOVE	T1,SWTPTR	;POINTER TO LIST OF LEGAL SWITCHES
	PUSHJ	P,.NAME		;SEE IF ON LIST
	  JRST	COMND1		;NO--SKIP OVER COMMAND
	SETOM	FLJCNM		;INDICATE NAME			[365]
				;				[365,401]
	CAIE	C," "		;IF NOT A SPACE,
	PUSHJ	P,.REEAT	;  REEAT CHARACTER
COMNDC:	MOVX	T2,FS.ICL	;SEE IF NEED TO IGNORE COMMAND	[366]
	TDNN	T2,INIFLG	; LINE MODE FURTHER DOWN	[366]
	SETOM	FLCCMD		;FLAG AS SUCH AND REEAT SEPARATOR
	SKIPG	C		;SEE IF END OF LINE
	SETZM	SCANPC		;YES--CLEAR SCANNER SINCE C.TE WILL
				;  BE PICKED UP AGAIN
	HRRZ	T2,SWTPTR	;ADDR OF LIST -1
	HRRZI	T1,-1(T1)	;1=ADDRESS-1 OF COMMAND
	SUB	T1,T2		;1=INDEX INTO TABLE
	POPJ	P,		;END INITIALIZATION (.ISCAN)

COMNDS:	SKPINC			;SEE IF ANYTHING STILL THERE
	  TLOA	C,-1		;NO--SET END-OF-LINE
	PUSHJ	P,.TIALT	;GET NEXT CHARACTER
COMND1:	JUMPG	C,COMNDS	;LOOP FOR END OF LINE
COMND2:	SETO	T1,
	MOVEM	C,LASCHR	;SAVE FOR REUSE LATER

	POPJ	P,		;END OF .ISCAN
	SUBTTL	TRADITIONAL COMMAND SCANNER

;.TSCAN--SUBROUTINE FOR TRADITIONAL COMMAND SCANNER
;ARGS	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=0 OR IOWD POINTER TO LIST OF SWITCH NAMES
;			(IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=LH 0 OR SUBROUTINE TO CLEAR ALL ANSWERS
;		RH 0 OR SUBROUTINE TO CLEAR FILE ANSWERS
;	BLOCK+5=LH SUBROUTINE TO ALLOCATE INPUT FILE AREA
;		RH SUBROUTINE TO ALLOCATE OUTPUT FILE AREA
;		  BOTH RETURN T1=START OF AREA, T2=LENGTH
;	BLOCK+6=LH 0 OR SUBROUTINE TO MEMORIZE STICKY DEFAULTS
;		RH 0 OR SUBROUTINE TO APPLY STICKY DEFAULTS
;	BLOCK+7=LH 0 OR SUBROUTINE TO CLEAR STICKY DEFAULTS
;		RH FLAGS TO CONTROL SCAN:
;		   1B18=MORE THAN ONE OUTPUT SPEC POSSIBLE
;		   1B19=ALLOW INPUT SWITCHES ON OUTPUT AND VV
;	BLOCK+10=LH (FUTURE)
;		 RH 0 OR ROUTINE TO STORE SWITCH VALUES
;			;ENTERRED WITH T1=VALUE, T2=POINTER
;			;NON-SKIPS IF SCAN SHOULD NOT STORE
;			;SKIPS IF SCAN SHOULD STORE (T1-2 OK)
.TSCAN::PUSHJ	P,.CCLRB	;CLEAR TYPEAHEAD IF WAS AN ERROR
	MOVE	T2,(P)		;PRESERVE CALLING
	MOVEM	T2,SAVCAL	;  LOCATION
	MOVE	T2,.JBREL	;GET SIZE OF CORE
	HRL	T2,.JBFF	; AND CURRENT USAGE
	MOVEM	T2,SAVCOR	; AND SAVE IT
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	MOVE	C,LASCHR	;RESTORE LAST CHARACTER
	MOVEM	P,SAVPDP	;SAVE PUSH DOWN LIST POINTER
	PUSHJ	P,SETPR4	;SET STANDARD PARAMETERS
	PUSHJ	P,.GTWRD##	;GET BLOCK+4
	HLRZM	T3,CLRANS	;SUBROUTINE TO CLEAR ANSWER AREA
	HRRZM	T3,CLRFIL	;SUBROUTINE TO CLEAR FILE AREA
	PUSHJ	P,.GTWRD##	;GET BLOCK+5
	TLNE	T3,-1		;(REQUIRED)
	TRNN	T3,-1		;(REQUIRED)
	HALT	.		;PROTECTION
	HLRZM	T3,ALLIN	;SUBROUTINE TO ALLOCATE INPUT AREA
	HRRZM	T3,ALLOUT	;SUBROUTINE TO ALLOCATE OUTPUT AREA
	PUSHJ	P,.GTWRD##	;GET BLOCK+6
	HLRZM	T3,MEMSTK	;SUBROUTINE TO MEMORIZE STICKY DEFAULTS
	HRRZM	T3,APPSTK	;SUBROUTINE TO APPLY STICKY DEFAULTS
	PUSHJ	P,.GTWRD##	;GET BLOCK+7
	HLRZM	T3,CLRSTK	;SUBROUTINE TO CLEAR STICKY DEFAULTS
	HRRZM	T3,USRFLG	;STORE AWAY USER'S PARAMETER FLAGS
	PUSHJ	P,.GTWRD##	;GET BLOCK+10
	HRRZM	T3,STRSWT	;ADDRESS OF ROUTINE TO STORE RESULTS
	HRRZM	P,FLVERB	;SET FLVERB .GT. 0

	AOSE	CALCNT		;COUNT CALL
	JRST	RESTRT		;IF NOT FIRST, DO A RESTART
	SKIPE	FLCCMD		;SKIP IF NEITHER CCL OR COMMAND
	JRST	RESTRL		;THEY REQUIRE NO *
RESTRT:
IFN DEBUG$,<
	CAME	P,SAVPDP
	JRST	E$$PDL		;FAIL IF PDL PHASE ERROR
>
	MOVE	T1,SAVCOR	;RESTORE CORE
	HLRM	T1,.JBFF	;RESTORE FIRST FREE
	TLZ	T1,-1		;CLEAR JUNK
	CAME	T1,.JBREL	;  TO ITS INITIAL
	CORE	T1,		;  SETTING IF IT
	  JFCL			;  WAS CHANGED
IFN M$INDP,<
	SKIPE	A.DEV		;SEE IF INDIRECT
	JRST	RESTRC		;YES--SKIP END TEST
	SKIPE	FLCCL		;SEE IF CCL MODE
	SOS	.JBSA		;YES--RESTORE STARTING ADDRESS
	SKIPE	N.DEV		;SEE IF /RUN
	JRST	RESTRL		;YES--PROCEED
>
	SKIPE	FLCCMD		;SEE IF IN TRADITIONAL MODE
	PUSHJ	P,.MONRT	;NO--RETURN TO MONITOR

RESTRC:	SKIPE	FLSECE		;IF AFTER SECOND EQUALS,	[515]
	JRST	RESTRL		; SKIP OVER PROMPT		[515]
	CAMN	C,[.CHEOF]	;SEE IF END OF FILE		[504]
	JRST	[PUSHJ P,.ALDON ;YES--HANDLE EOF		[504]
		 JUMPG C,RESTRL ;CONTINUE IF NOT DONE YET	[535]
		 JRST  RESTRT]	;RETURN TO MAIN LINE		[504]
	SKIPG	C		;IF END OF LINE,		[540]
	HRREI	C,.CHEOL	; SET REAL END OF LINE		[540]
	HRRZI	T1,"*"		;SET PROMPT CHARACTER
	PUSHJ	P,DOPRMP	;GO DO IT
	SUBTTL	MAIN LOOP FOR TRADITIONAL COMMAND SCANNING

;HERE TO START ONE PASS THROUGH THE CUSP (ONE COMMAND LINE)

RESTRL:	PUSHJ	P,.CCLRB	;CONDITIONALLY CLEAR TYPEAHEAD	[524]
	SETOM	FLOUT		;FLAG THAT NOT TO = YET
	SETZM	FLSOME		;NOTE SOMETHING FOUND
	SETZM	.FLVRB##	;RESET /MESSAGE			[300]
	SKIPE	CLRANS		;SEE IF USER WANTS CONTROL
	PUSHJ	P,@CLRANS	;YES--CLEAR ANSWERS
IFN M$INDP,<
	PUSHJ	P,.RUNCM	;HANDLE /RUN IN NEEDED		[264]
	JUMPN	T1,RESTRT	;IF DID SOMETHING, START OVER	[506]
>
	PUSHJ	P,INILIN	;INITIALIZE LINE

;HERE TO SCAN ONE SIDE OF COMMAND LINE

RESTRS:	PUSHJ	P,INILIM	;INITIALIZE AT START OF LINE
	PUSHJ	P,CLERST	;CLEAR STICKY DEFAULTS		[534]

	SKIPE	FLSECE		;SEE IF SECOND EQUALS		[515]
	JRST	SEQEQR		;YES--GO HANDLE SECOND COMMAND	[515]
;HERE TO SCAN ONE FILE SPECIFICATION

RESTRF:	PUSHJ	P,.FILIN	;GET NEXT FILE SPECIFICATION
	MOVEI	P2,0		;CLEAR FLAG			[522]
IFN M$INDP,<
	CAIN	C,"@"		;SEE IF INDIRECT REQUESTED	[514]
	JUMPGE	T1,INDFIL	;YES--HANDLE IF NO FILE YET	[514]
>
	MOVE	P1,T1		;APPSTK CLOBBERS T1		[275]
	SKIPE	APPSTK		;SEE IF APPLY STICKY		[271]
	PUSHJ	P,@APPSTK	;  REQUESTED BY CALLER		[271]

	JUMPLE	C,INFILX	;IF END OF LINE OR
	SETOM	FLSOME		;NOTE SOMETHING FOUND
	LDB	T1,[POINTR (F.MOD,FX.TRM)]  ;GET TERMINATOR	[247,510]
	JUMPN	T1,INFIL	;MUST BE INPUT			[247,510]
	MOVSI	T2,-BREAKL	;SET LENGTH OF BREAK TABLE	[522]
	HLRZ	T3,BREAKT(T2)	;GET NEXT BREAK			[522]
	TRZ	T3,(1B0)	;CLEAR FLAG			[522]
	CAIE	T3,(C)		;SEE IF MATCH			[522]
	AOBJN	T2,.-3		;NO--LOOP			[522]
	MOVE	P2,BREAKT(T2)	;GET DISPATCH			[522]
	JRST	(P2)		;GO HANDLE IT			[522]

;TABLE OF  BREAK,,ADDRESS

	DEFINE	ZZ(A,B,C),<
	BYTE	(1) C (17) A (18) B
>

BREAKT:	ZZ	   054,INOFIL,	;","
	ZZ	   "=",OUTFIL,1
IFN FT$UEQ,<ZZ	   "_",OUTFIL,1>
	ZZ	.CHFRM,OUTFIL,1
	ZZ	.CHSRC,OUTFIL,1
	ZZ	.CHINP,OUTFIL,1
BREAKL==.-BREAKT
		    0,,E.ILSC		;FOR ERROR
;HERE TO SEE IF INPUT OR OUTPUT FILE JUST FOUND

INOFIL:	MOVX	T1,FS.MOT	;SEE IF MULTIPLE OUTPUT POSSIBLE
	TDNE	T1,USRFLG	;TEST USER'S FLAGS
	SKIPL	FLOUT		;YES--SEE IF = SEEN YET
	JRST	INFIL		;GO DO INPUT FILE
	JRST	OUFIL		;GO DO OUTPUT FILE

;HERE WHEN A SPECIFICATION FOR OUTPUT SIDE IS FOUND

OUTFIL:	AOSE	FLOUT		;SET/TEST IF ALREADY PAST THIS POINT
	JRST	SECEQL		;YES--PROCESS SECOND EQUAL SIGN	[516]
OUFIL:	MOVX	T1,FS.MIO	;SEE IF				[302]
	TDNE	T1,USRFLG	; LEGAL FOR SWITCHES		[302]
	JRST	OUFIL1		; TO BE ON WRONG SIDE		[302]
	MOVE	T1,F.MODM	;GET FILE MODIFIERS
	TXNE	T1,FXNOTO	;CHECK ILLEGAL ONES
	JRST	E.FMO		;ERROR IF WRONG ONES
	SKIPG	F.ABF		;SEE IF /ABEFORE		[346]
	SKIPLE	F.ASN		; OR IF /ASINCE			[346]
	JRST	E.FMO		;YES--ERROR			[346]
	SKIPG	F.FLI		;SEE IF MIN LENGTH		[346]
	SKIPLE	F.FLM		; OR IF MAX LENGTH		[346]
	JRST	E.FMO		;YES--ERROR			[346]
	SKIPG	F.BFR		;SEE IF /BEFORE
	SKIPLE	F.SNC		;OR /SINCE
	JRST	E.FMO		;YES--ERROR
OUFIL1:	PUSHJ	P,@ALLOUT	;ALLOCATE SOME OUTPUT SPACE
	JRST	INFIL2		;GO COPY SPEC AND LOOP

;HERE WHEN A SPECIFICATION FOR INPUT SIDE FOUND

INFILX:	JUMPE	P1,INFIL3	;IF NOTHING, SKIP ON		[275]
	MOVX	T1,FS.MOT	;SEE IF				[533]
	TDNE	T1,USRFLG	; MULT. OUTPUTS			[533]
	SKIPL	FLOUT		; AND NO =			[533]
	SKIPA			;NO--OK				[533]
	JRST	E$$ESM		;YES--ERROR			[533]
	SETOM	FLSOME		;OTHERWISE FLAG SOMETHING
INFIL:	AOS	FLOUT		;FORCE ANY OUTPUT SPEC ILLEGAL
	MOVX	T1,FS.MIO	;SEE IF LEGAL FOR SWITCHES ON WRONG SIDE  [302]
	TDNE	T1,USRFLG	;SEE IF MIXUP OK		[302]
	JRST	INFIL1		;OK--JUST GO AHEAD		[346]
	MOVE	T1,F.MODM	;GET FILE MODIFIERS
	TXNE	T1,FXNOTI	;CHECK ILLEGAL ONES
	JRST	E.FMI		;ERROR IF WRONG ONES
IFE	FT$RSX,<
	SETCM	T1,F.VER	;SEE IF /VERSION		[346]
	SKIPN	T1		; SKIP IF SET			[346]
>
	SKIPL	F.EST		;SEE IF /ESTIMATE		[346]
	JRST	E.FMI		;YES--ERROR ON INPUT		[346]
INFIL1:	PUSHJ	P,@ALLIN	;ALLOCATE SOME INPUT SPACE
INFIL2:	PUSHJ	P,.GTSPC	;AND COPY RESULTS TO IT
;HERE AFTER HANDLING ANY FILE SPEC

INFIL3:	JUMPL	P2,INDFI1	;GO SET SAFE CHARACTER		[515]
	JUMPG	C,RESTRF	;IF NOT END, LOOP BACK FOR MORE
	SKIPE	FLSOME		;SEE IF ANYTHING YET
	POPJ	P,		;YES--RETURN TO USER

;HERE WHEN NO ARGUMENTS TYPED, DO APPROPRIATE THING

IFN M$INDP,<
	SKIPE	A.DEV		;SEE IF INDIRECT
	JRST	RESTRT		;YES--JUST LOOP BACK
>
	SKIPE	FLCCMD		;SEE IF COMMAND MODE
	POPJ	P,		;YES--RETURN TO USER
	JRST	RESTRT		;IF ALL ELSE FAILS, TRY AGAIN

;HERE WHEN INDIRECT FILE SPECIFIER COMING

IFN M$INDP,<
INDFIL:	PUSHJ	P,.GTIND	;SET UP NAME OF INDIRECT FILE
	SETZM	SCANPC		;CLEAR COMPRESSOR (NEW FILE)
>
INDFI1:	MOVEI	C,","		;SET TO SAFE CHARACTER		[515]
	JRST	RESTRS		;AND GO BACK THROUGH THE LOOP

;HERE ON SECOND = ON A LINE

SECEQL:	MOVE	T1,[F.ZER,,FE.ZER]	;SAVE PRECEEDING FILE	[515]
	BLT	T1,FE.EZR	; SINCE IT IS ANOTHER COMMAND	[515]
	SETOM	FLSECE		;FLAG SECOND EQUALS MODE	[515]
	POPJ	P,		;TELL USER DONE WITH THIS COMMAND [515]

;HERE ON RE-ENTRY ON SECOND = ON A LINE

SEQEQR:	MOVE	T1,[FE.ZER,,F.ZER] ;RESTORE FILE		[515]
	BLT	T1,F.EZER	; SAVE ABOVE			[515]
	SETZM	FLSECE		;CLEAR SECOND EQUALS MODE	[515]
	JRST	OUTFIL		;PROCESS AS OUTPUT FILE		[515]
	SUBTTL	VERB FORM COMMAND SCANNER

;.VSCAN --SUBROUTINE FOR VERB ARGS FORM OF COMMAND SCANNER
;	RETURNS CPOPJ IF EOF DURING COMMAND OR CCL AT TOP LEVEL
;ARGS	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES
;			(IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=LH LENGTH OF FXXX AND PXXX AREAS
;		RH START OF FXXX (PER FILE SWITCHES)
;	BLOCK+5=LH (FUTURE)
;		RH START OF PXXX (STICKY FORM OF FXXX)
;	BLOCK+6=NAME OF OPTION LINES (0 IF THIS PROGRAM'S NAME)


.VSCAN::PUSHJ	P,.CCLRB	;CLEAR TYPEAHEAD IF WAS AN ERROR
	MOVEM	P,SAVPDP	;SAVE PUSH DOWN LIST POINTER
	PUSHJ	P,SETPR4	;SET STANDARD PARAMETERS
	PUSHJ	P,.GTWRD##	;GET BLOCK+4
	MOVE	P1,T3		;SAVE POINTER TO FXXX
	PUSHJ	P,.GTWRD##	;GET BLOCK+5
	TLZ	T3,-1		;GET START OF PXXX
	SUBI	T3,(P1)		;GET OFFSET TO PXXX FROM FXXX
	MOVEM	T3,SWTPFO	;STORE FOR LATER
	HRRZM	P1,SWTPFF	;STORE START OF FXXX
	HLRZ	T3,P1		;GET LENGTH OF FXXX
	ADDI	T3,(P1)		;GET END			[357]
	MOVEM	T3,SWTPFL	;SAVE END FOR LATER
	PUSHJ	P,.GTWRD##	;GET BLOCK+6
IFN M$INDP,<
	MOVEM	T3,VOPTN	;SAVE AS OPTION FILE LINE NAME
>
	SETOM	FLVERB		;NOTE VERB FORM
	MOVE	C,SAVCHR	;RESTORE RESCANNED CHARACTER
VRSTRT:	PUSHJ	P,.CCLRB	;CONDITIONAL CLEAR BUFFER
IFN DEBUG$,<
	CAME	P,SAVPDP
	JRST	E$$PDL
>
	PUSHJ	P,INILIN	;INITILIZE LINE
	CAMG	C,[.CHEOF]	;SKIP IF NOT AT EOF
	PUSHJ	P,.ALDON	;AT END--GO DO EOF PROCESSING
	CAMG	C,[.CHEOF]	;SKIP IF NOT STILL AT EOF
	POPJ	P,		;GO HANDLE FINAL END		[313]
	HRRZI	T1,"/"		;SET PROMPT CHARACTER
	SKIPN	FLCCMD		;UNLESS COMMAND MODE,		[360]
	PUSHJ	P,DOPRMP	;GO DO IT
	HRREI	C,.CHEOL	;CLEAR ALT FLAG

VRSTRL:	PUSHJ	P,.KEYWD	;PROCESS THE VERB
	  JRST	VRSTNL		;GO HANDLE NO VERB YET
	MOVE	C,LASCHR	;RESTORE CHARACTER JUST IN CASE

;HERE AT END OF COMMAND
	PJUMPG	C,E.INCL	;IF NOT EOL, ISSUE ERROR MESSAGE
IFN M$INDP,<
	PUSHJ	P,.RUNCM	;HANDLE /RUN IF NEEDED		[264]
	AOSE	OPTION		;SEE IF /OPTION
	SOSN	OPTION		;YES--CORRECT FOR AOS
	JRST	VRSTRT		;NO--LOOP
	MOVE	T3,VOPTN	;GET OPTION NAME
	PUSHJ	P,.OSCAN	;ENTER MIDDLE OF OSCAN		[370]
>
	JRST	VRSTRT		;LOOP
;HERE BEFORE VERB SEEN
VRSTNL:	CAIN	C,"/"		;SEE IF /
	JRST	VRSTRL		;YES--LET USER PRECEDE VERBS THIS WAY
IFN M$INDP,<
	CAIN	C,"@"		;SEE IF INDIRECT FILE
	PUSHJ	P,.GTIND	;YES--GET SPECIFICATION
>
	JUMPLE	C,VRSTRT	;LOOP IF NULL LINE
	PJRST	E.ILSC		;ELSE, GO TO ERROR MESSAGE
	SUBTTL	OPTION FILE SCANNER

;.OSCAN -- SUBROUTINE TO SCAN OPTIONS FILE (DSK:SWITCH.INI[,])
;	RETURNS CPOPJ AFTER UPDATING GLOBAL SWITCHES FROM FILE
;	THIS ROUTINE SHOULD BE CALLED AFTER TSCAN OR PSCAN
;		BUT BEFORE DEFAULTING.
;	CALL THIS ONLY AT END OF LINE.
;	IT SHOULD BE CALLED BETWEEN ISCAN AND VSCAN FOR VERBS.
;ARGS:	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES (IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=NAME OF OPTIONS TO SELECT IN FILE (0 IF NAME OF PROGRAM)
;			OR LENGTH,,LIST OF OPTION NAMES
;IF CALL FROM VSCAN, C(T3)= SAME AS BLOCK+4 ABOVE

IFN M$INDP,<
.OSCAN::PUSHJ	P,.SAVE4##	;SAVE P1-4
	PUSH	P,SCANPC	;SAVE STATE OF			[515]
	PUSH	P,SCANCH	; COMPRESSOR			[515]
	SETZM	SCANPC		;CLEAR				[515]
	SETZM	SCANCH		; COMPRESSOR			[515]
	PUSH	P,LASCHR	;SAVE ORIGINAL LAST-CHAR
	HRRZM	P,LASCHR	;FAKE OUT QSCAN
	PUSH	P,SAVCAL	;PRESERVE STACK			[366]
	PUSH	P,SAVPDP	; AND CALL POINT		[366]
	MOVEI	T2,OPTNSX	;SET TO				[366]
	MOVEM	T2,SAVCAL	; RE-ENTER HERE			[366]
	PUSH	P,FLVERB	;SAVE VERBOSITY FLAG		[370]
	SETZM	FLVERB		;TREAT LIKE PSCAN		[370]
	MOVE	T2,P		;COPY PDL POINTER		[366]
	PUSH	T2,T2		;INCREMENT STACK ONCE		[366]
	MOVEM	T2,SAVPDP	; WITH A GOOD PDL		[366]
	SKIPGE	(P)		;SEE IF VSCAN CALL		[370]
		....=FLVERB	;FORCE INTO CREF		[370]
	JRST	OSCANV		;YES--SKIP RE-INITIALIZE	[370]
	MOVE	P1,OPTION	;SAVE /OPTION TO FAKE QSCAN
	MOVE	P2,N.DEV	;SAVE /RUN TO FAKE QSCAN
	SETZM	N.DEV		; ..
	PUSHJ	P,.QSCAN	;SETUP FOR QSCAN		[335]
	  JRST	OPTNSX		;HERE ONLY IF ERROR IN FILE
	MOVEM	P1,OPTION	;RESTORE OPTION
	MOVEM	P2,N.DEV	;RESTORE /RUN TO PREVENT ERRORS
	PUSHJ	P,.GTWRD##	;GET BLOCK+4
	;STILL UNDER M$INDP

OSCANV:	JUMPN	T3,OSCAN1	;OK IF NAME
	HRROI	T3,.GTPRG	;ELSE, GET
	GETTAB	T3,		; PROGRAM NAME
	  JRST	OPTNSY		;GIVE UP IF WE CAN'T
	TLNN	T3,(77B5)	;PROTECT AGAINST JUNK NAME	[344]
	JRST	OPTNSY		;RIGHT--IGNORE OPTION FILE	[344]
OSCAN1:	SKIPE	A.DEV		;SEE IF IND FILE OPEN
	JRST	OPTNSY		;YES--GIVE UP UNTIL IND FILES NEST
	MOVEM	T3,OPTNAM	;SET OPTION NAME
	MOVE	T1,[OPTSPC,,F.ZER]
	BLT	T1,F.DIRM	;COPY PRESET SPEC
	SETZM	F.DIR+2		;CLEAR DIRECTORY
	MOVE	T1,[F.DIR+2,,F.DIR+3]
	BLT	T1,F.EZER	; AND REST OF SPEC
	SETOM	F.MZER		;CLEAR SWITCHES			[346]
	MOVE	T1,[F.MZER,,F.MZER+1]
	BLT	T1,F.EMZR
	PUSHJ	P,GTINDF	;SET INDIRECT FILE SPEC
	PUSHJ	P,.CLRFL	;CLEAR OUT FILE SPEC AREA	[513]

	SKIPN	OPTION		;SEE IF /NOOPTION
	JRST	OPTNSW		;YES--RETURN IMMEDIATELY
	;STILL UNDER M$INDP

	AOSE	OPTION		;IF OPTION IS -1,
	SOS	OPTION		;  MAKE IT 0
	MOVEI	P1,0		;CLEAR FLAG OF MATCHES		[345]
;HERE TO LOOP OVER LINES IN FILE LOOKING FOR OUR SET OF OPTIONS
OPTNSF:	AOJL	C,OPTNSW	;SEE IF END OF FILE
	SETOB	C,LASCHR	;CLEAR CHARACTER
	SETZM	SCANPC		;INDICATE START OF LINE
	PUSHJ	P,.SIXSW	;GET SIXBIT WORD
	MOVE	T1,OPTNAM	;GET OPTION NAME NEEDED		[344]
	TLNE	T1,(77B5)	;SEE IF LIST			[344]
	JRST	[CAME T1,N	;NO--SEE IF MATCH		[344]
		 JRST OPTNSD	;WRONG--IGNORE LINE		[344]
		 JRST OPTNSG]	;MATCH--GO DO IT		[344]
	TLC	T1,-1		;LIST--CHANGE TO AOBJN		[344]
	AOBJN	T1,.+1		;FIX FOR 2-COMPL		[344]
	CAME	N,-1(T1)	;SEE IF MATCH			[344]
	AOBJN	T1,.-1		;ADVANCE LOOP			[344]
	JUMPGE	T1,OPTNSD	;IF NO MATCH, FAIL		[344]
OPTNSG:	SKIPN	OPTION		;SEE IF /OPTION
	CAIN	C,":"		;NO--SEE IF SPECIAL OPTION LINE
	JRST	.+2		;NO--CHECK FOR USER WANTING SPECIAL
	JRST	OPTNSL		;NOT /OPTION AND NO COLON--OK
	SKIPE	OPTION		;SEE IF /OPTION
	CAIE	C,":"		;YES--SEE IF COLON IN FILE
	JRST	OPTNSD		;NO--GIVE UP ON THIS LINE
	PUSHJ	P,.SIXSW	;YES--GET OPTION NAME IN FILE
	CAMN	N,OPTION	;SEE IF IT MATCHES REQUEST
	JRST	OPTNSL		;YES--GO DO THIS ONE
;HERE TO LOOP OVER LINE DISCARDING IT
OPTNSD:	JUMPLE	C,OPTNSF	;BACK TO MAIN LOOP AT END OF LINE
	PUSHJ	P,.TICHR	;GET ONE CHARACTER
	JRST	OPTNSD		;LOOP

;HERE TO LOOP OVER SWITCHES IN LINE
OPTNSL:	SETOM	P1		;INDICATE FOUND A LINE		[345]
	JUMPLE	C,OPTNSF	;GO AGAIN IF DONE		[345]
	CAIE	C,"/"		;LOOK FOR SLASH
	CAIN	C,","		;OR COMMA
	MOVEI	C," "		;YES--OK
	CAIE	C," "		;SEE IF OK CHAR OR SPACE
	JRST	E.ILSC		;NO--IMPROPER CHARACTER
	PUSHJ	P,.KEYWD	;GET NEXT SWITCH
	  JRST	OPTNSL		;SKIP EXTRA SEPARATORS
	MOVE	C,LASCHR	;RESTORE CHARACTER
	JRST	OPTNSL		;LOOP UNTIL DONE
;HERE WHEN OPTION NOT FOUND OR NO FILE
OPTNSW:	JUMPN	P1,OPTNSX	;EXIT IF FOUND AT LEAST ONE LINE [345]
	MOVE	N,OPTION	;SEE IF OPTION SPECIFIED
	SKIPL	(P)		;IF ORIGINALLY VERB, ERROR	[370]
		....=FLVERB	;FORCE INTO CREF
	JUMPE	N,OPTNSX	;ELSE, IF NAME THEN ERROR
E$$NON:	MOVE	T1,['NON',,[ASCIZ /No option /] ]
	PUSHJ	P,.TERRP	;GIVE USER WARNING
	TXNN	T1,JWW.FL	;SEE IF /MESSAGE:NOFIRST
	JRST	OPTNSU		;YES--KILL REST
	MOVE	T1,N		;POSITION OPTION
	PUSHJ	P,.TSIXN##	;TYPE IT
OPTNSU:	PUSHJ	P,.TCRLF##	;TYPE END OF LINE
;HERE WHEN DONE WITH OPTIONS FILE
OPTNSX:	PUSHJ	P,.KLIND	;KILL INDIRECT FILE
OPTNSY:	POP	P,FLVERB	;RESTORE MODE OF SCAN **USED ABOVE**	[370]
	POP	P,SAVPDP	;RESTORE ORIGINAL ERROR PDL	[366]
	POP	P,SAVCAL	; AND ORIGINAL ERROR RETURN POINT	[366]
	POP	P,LASCHR	;RESTORE LAST CHAR FOR REGULAR FILES
	POP	P,SCANCH	;RESTORE STATE OF		[515]
	POP	P,SCANPC	; COMPRESSOR			[515]
	SETZM	OPTNAM		;CLEAR OPTIONS MODE
	POPJ	P,		;RETURN TO CALLER

;FILE SPEC FOR DSK:SWITCH.INI[,]/PHYSICAL/OKNONE

OPTSPC:	'DSK   '
	'SWITCH'
	-1
	'INI',,-1
	<FX.DIR!FX.NOM!FX.PHY>
	<FX.DIR!FX.NOM!FX.PHY>
	0
	-1
>	;END M$INDP
	SUBTTL	PARTIAL SCANNER

;.PSCAN --SUBROUTINE TO INITIALIZE PARTIAL MODE SCANNER
;.QSCAN -- DITTO BUT ONLY INITIALIZA THIS LINE
;	RETURNS CPOPJ AFTER INITIALIZING.  IN CASE OF ANY
;	FATAL ERRORS (.FMSGE/X), WILL RESTORE CONTROL AND PDP
;	AT RETURN FROM THIS PSCAN CALL.
;	THIS SHOULD BE CALLED BEFORE EACH PROMPT OR LINE
;	OF INPUT.
;	SKIP RETURNS IF NO PROMPT NEEDED
;ARGS	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES
;			(IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP

.PSCAN::SETZM	.FLVRB##	;CLEAR /MESSAGE			[327]
	SETZM	FLVERB		;INDICATE .PSCAN		[364]
	MOVE	T2,(P)		;GET RETURN POINT		[364]
	MOVEM	T2,SAVCAL	;SAVE FOR ERROR			[364]
	MOVEM	P,SAVPDP	;SAVE PUSH-DOWN POINTER		[364]
	MOVE	T2,SAVCHR	;GET SAVED CHARACTER		[401]
	CAIN	T2,C.TE		;CONVERT SPECIAL EOL		[401]
	MOVEI	T2,0		; TO EOL			[401]
	JUMPG	T2,PSCAN1	;IF SOME END			[401]
	SKIPGE	FLJCNM		; AND JUST COMMAND LINE		[401]
	SETZM	SAVCHR		; THEN CLEAR RE-EAT OF EOL	[401]
PSCAN1:	SKIPLE	FLJCNM		;IF SECOND TIME TO PSCAN,	[365]
	SETZM	FLJCNM		; CLEAR MULTI-LINE OK FLAG	[365]
	MOVMS	FLJCNM		;YES--INDICATE PSCAN RESCAN JUST NAME	[365]
				; THIS ALLOWS MORE LINES FOR COMMAND	[365]
				;FALL INTO QSCAN
				;FALL HERE FROM ABOVE

.QSCAN::PUSHJ	P,.CCLRB	;CLEAR TYPEAHEAD IF WAS AN ERROR
				;***DELETED HANDLING OF /RUN	[264]
	MOVEI	T2,0		;CLEAR FLAG			[313]
	MOVE	C,LASCHR	;GET LAST CHARACTER		[313]
	CAMN	C,[.CHEOF]	;SEE IF END OF FILE		[313]
	MOVEI	T2,1		;YES--FLAG NO PROMPT		[313]
	SKIPN	A.DEV		;SEE IF INDIRECT
	SKIPLE	C		;OR IN MIDDLE OF LINE
	MOVEI	T2,1		;YES--FLAG NO PROMPT		[313]
	ADDM	T2,(P)		;UPDATE RETURN IF NEEDED	[313]
	SKIPG	C		;SEE IF AT EOL
	SETZM	SAVCHR		;YES--CLEAR COMMAND MEMORY
	HRRE	T2,SCANCH	;GET SAVED CHARACTER		[266]
	SKIPE	SAVCHR		;SEE IF ANYTHING SAVED		[266]
	SKIPG	T2		;AND SOMETHING TO SAVE		[266]
	SKIPA			;OK				[266]
	HALT	.+1		;NO--ERROR			[266]
	SKIPLE	T2		;IF USEFUL,			[266]
	MOVEM	T2,SAVCHR	;  SAVE IT			[266]
	CAME	C,[.CHEOF]	;UNLESS AT END OF FILE,		[313]
	SETOB	C,LASCHR	; PRESET TO NEW LINE
				;FALL INTO SETPR4
				;FALL HERE FROM ABOVE

;SETPR4 -- SUBROUTINE TO STORE STANDARD PARAMETERS FROM GLOBAL CALLS
;	HANDLES ARGUMENT BLOCK THROUGH BLOCK+3
;CALL:	MOVE	T1,[LENGTH,,BLOCK]
;	PUSHJ	P,SETPR4
;USES T1-4

SETPR4:	JUMPE	T1,INILIN	;IF NO POINTER, DON'T CHANGE	[370]
	HLRZ	T2,T1		;SETUP COUNTER FOR .GTWRD
	PUSHJ	P,.GTWRD##	;GET BLOCK+0
	MOVEM	T3,SWTPTR	;SAVE POINTER FOR SCANNING
	ADDI	T3,1		;ADVANCE TO TABLE POINTER
	HRLI	T3,P1		;INCLUDE INDEX POINTER
	MOVEM	T3,SWTCHN	;SET ADDRESS FOR MESSAGES
	PUSHJ	P,.GTWRD##	;GET BLOCK+1
	HLRZ	T4,T3		;GET DEFAULT TABLE
	SKIPN	T4		;SKIP IF ONE SETUP
	SKIPA	T4,[[0]]	;NO--SET LOCATION OF ZERO
	HRLI	T4,P1		;INCLUDE INDEX
	MOVEM	T4,SWTCHD	;STORE FOR LATER
	HRRZ	T4,T3		;GET MAX,PROCESSOR TABLE
	SKIPN	T4		;SKIP IF ONE SETUP
	SKIPA	T4,[[0]]	;NO--SET LOCATION OF ZERO
	HRLI	T4,P1		;INCLUDE INDEX
	MOVEM	T4,SWTCHM	;STORE FOR LATER
	PUSHJ	P,.GTWRD##	;GET BLOCK+2
	HRRZ	T4,T3		;GET STORAGE POINTER TABLE
	SKIPN	T4		;SKIP IF ONE SETUP
	SKIPA	T4,[[0]]	;NO--SET LOCATION OF ZERO
	HRLI	T4,P1		;INCLUDE INDEX
	MOVEM	T4,SWTCHP	;STORE FOR LATER
	PUSHJ	P,.GTWRD##	;GET BLOCK+3
	CAME	T3,[-1]		;SEE IF DEFAULT NAME
	JRST	STRPRH		;NO--GO STORE AWAY
	HRROI	T3,.GTPRG	;YES--GET CURRENT
	GETTAB	T3,		;  PROGRAM'S NAME
	  MOVEI	T3,0		;CLEAR IF NOT AVAILABLE

STRPRH:	MOVEM	T3,SWTHLP	;STORE HELP POINTERS
				;FALL INTO INILIN
				;FALL HERE

;INILIN/INILIM -- ROUTINES TO INITIALIZE START OF LINE
;USE T3

INILIN:	SKIPG	LASCHR		;SEE IF AT START
	SETZM	SCANPC		;YES--CLEAR BLANK COMPRESSOR
	SETZM	FLFLLP		;CLEAR L.PAREN COUNT		[534]
IFN M$INDP,<
	SETOM	OPTION		;CLEAR /OPTION
>
INILIM:	PUSHJ	P,.PSH4T##	;SAVE SOME AC'S		[534]
	SKIPL	FLVERB		;SEE IF VERB MODE		[357]
	PUSHJ	P,CLERST	;NO--CLEAR STICKY DEFAULTS	[534]
	SETZM	SWTCNT		;CLEAR RECURSION COUNTER
	SETZM	.LASWD		;CLEAR LAST WORD TYPE		[314]
	PUSHJ	P,.POP4T##	;RESTORE TEMPS			[534]
	POPJ	P,		;RETURN
	SUBTTL	INDIRECT FILE SETUP AND FINISH

;.ALDON -- SUBROUTINE TO HANDLE EOF WHEN READING COMMANDS
;IF INDIRECT MODE, IT CLEARS IND AND EOF AND RETURNS
;ELSE, IT GOES TO MONITOR AND RETURNS ON A CONTINUE


.ALDON::HRREI	C,.CHEOL	;CLEAR EOF
	MOVEM	C,LASCHR	;UPDATE LAST CHARACTER		[313]
IFN M$INDP,<
	SKIPN	USRIND		;SEE IF USER SUPLIED INDIRECT
	SKIPN	A.DEV		;IF INDIRECT, GO BACK TO NORMAL MODE
	PJRST	.MONRT		;NO INDIRECT--GO HANDLE
	PUSHJ	P,.KLIND	;CLEAN UP INDIRECT PROCESSING
>
	POPJ	P,		;NO--CLEAR OUT INDIRECT FILE AND BACK TO TTY


IFN DEBUG$,<
E$$PDL:	OUTSTR	[ASCIZ	/?
?SCNPDL PDL phase error
/]
	CLRBFI			;CLEAR ANY TYPE-AHEAD
	MONRT.			;DIE WITHOUT TOUCHING ANY AC OR CORE
	JRST	.-1		;LOOP HOPELESSLY
>
;FILE SCANNING ERRORS

	M$FAIL	(ESM,Equal sign missing)
E.FMO::	M$FAIL	(FMO,File switches illegal in output file)
E.FMI::	M$FAIL	(FMI,Output switch illegal in input file)
E.INCL::
E$$EXA:	SKIPA	T1,['EXA',,[ASCIZ /Excess arguments starting with "/] ]
E.ILSC::
E$$ILC:	MOVE	T1,['ILC',,[ASCIZ /Illegal character "/] ]
	PUSH	P,T1		;SAVE TEXT			[314]
	TRZ	T1,-1		;REMOVE TEXT			[314]
	PUSHJ	P,.TERRP	;ISSUE MESSAGE PREFIX		[314]
	MOVE	T2,T1		;COPY /MESSAGE			[314]
	POP	P,T1		;RESTORE TEXT			[314]
	TXNN	T2,JWW.FL	;SEE IF FIRST LINE
	JRST	.FMSGE		;NO--JUST GO FINISH UP
	PUSHJ	P,.TSTRG##	;YES--ISSUE TEXT		[314]
	MOVE	T1,C		;GET CHARACTER IN ERROR
	PUSHJ	P,.TFCHR##	;OUTPUT CHARACTER
	SKIPE	.LASWD		;IF UNKNOWN LAST WORD		[314]
	SKIPN	.NMUL		; OR NO VALUE			[314]
	JRST	ILSC1		;JUMP IF NO WORD		[314]
	MOVEI	T1,[ASCIZ /" following word "/]
	PUSHJ	P,.TSTRG##	;TYPE STRING
	MOVE	T1,.NMUL	;POSITION WORD			[314]
	SKIPGE	T2,.LASWD	;SEE IF STRING MODE		[314]
	MOVEI	T1,.NMUL	;YES--SET POINTER TO STRING	[314]
	PUSHJ	P,(T2)		;AND ISSUE RESULT		[314]
ILSC1:	MOVEI	T1,""""		;DOUBLE QUOTE
	PUSHJ	P,.TCHAR##	;AND TYPE IT
	JRST	.FMSGE		;AND BOMB USER
;.GTIND--SUBROUTINE TO READ INDIRECT FILE SPECIFIER
;STORED IN AUXILIARY BLOCK STARTING AT A.ZER

IFN M$INDP,<
.GTIND::PUSHJ	P,.FILIN	;GET FILE SPECIFIER
	JUMPGE	T1,E.JFI	;ERROR IF NO FILE SPECIFIED	[516]
GTINDF:
IFG M$INDP,<
	MOVEI	T1,M$INDP	;IF FIRST, RESET COUNTER
	SKIPN	A.DEV		; ..
	MOVEM	T1,INDCNT	;TO LIMIT DEPTH
				;  THIS IS NEEDED TO PROTECT
				;  THE USER FROM INFINITE
				;  INDIRECT LOOPS (PARTICULARLY
				;  IF JACCT IS ON)
>
	SKIPN	A.DEV		;SEE IF TOP LEVEL		[350]
	MOVEM	C,INDSVC	;YES--SAVE CHARACTER		[350]
	SKIPGE	C		;SEE IF EOF			[350]
	HRROI	C,.CHEOL	;YES--TURN INTO EOL FOR NOW	[350]
	SKIPE	B.IND+1		;IF ALREADY ONE OPEN,
	PUSHJ	P,.KLIND	;  GO BIND IT OFF
	MOVEI	T1,A.ZER	;POINT TO @ AREA
	MOVEI	T2,A.EZER-A.ZER+1  ; ..
	PUSHJ	P,.GTSPC	;GO COPY SPEC
INDGT1:	SKIPN	T1,A.EXT	;SKIP IF EXT SPECIFIED
	HRLOI	T1,'CCL'	;DEFAULT IS CCL
	MOVEM	T1,A.EXT
	SKIPN	A.NAM		;SEE IF NAME
	SETOM	A.NAMM		;NO--DEFAULT TO NO WILD
	SKIPN	T1,A.NAM	;SKIP IF NAME SPECIFIED
	HRLZ	T1,CCLNAM
	MOVEM	T1,A.NAM
	SKIPN	T1,A.DEV
	JRST	E.JFI		;ERROR IF NO DEVICE
	DEVCHR	T1,		;GET CHARACTERISTICS
	TXNE	T1,DV.TTA	;SKIP IF NOT AN INTERACTIVE DEVICE
	SETOM	FLIIND		;NOTE INTERACTIVE
IFG M$INDP,<
	SOSGE	INDCNT		;DECREMENT COUNT TO PROTECT USER
	JRST	E.TMI		;TOO FAR--BOMB OUT
>
	HRROI	T1,"#"		;SETUP PROMPT			[515]
	JUMPLE	C,INDGT2	;EXIT IF END OF LINE
	SKIPGE	FLVERB		;IF VERB MODE,			[515]
	JRST	E.JFI		; ERROR IF NOT END OF LINE	[515]
	CAIN	C,","		;ELSE, MUST BE COMMA		[515]
INDGT2:	PJRST	DOPRMP		;DO PROMPT AND RETURN		[515]
E.JFI:	MOVEI	N,A.ZER		;POINT TO FILE SPEC
	SETOB	T2,FLKLIN	;NO ERROR CODE
	M$FAIF	(JFI,Junk after indirect command)
IFG M$INDP,<
E.TMI:	MOVEI	N,A.ZER		;POINT TO FILE SPEC JUST READ IN
	SETOB	T2,FLKLIN	;SET FLAG FOR NO ERROR CODE TO PRINT
	M$FAIF	(TMI,Too many indirect files)
>
>
	SUBTTL	RUN COMMAND PROCESSING

;.RUNCM -- ROUTINE TO HANDLE /RUN SWITCH IF ANY
;CALL:	PUSHJ	P,.RUNCM
;RETURNS T1=0 IF NO /RUN SWITCH
;RETURNS T1.NE.0 IF CONTINUE FROM /EXIT SWITCH
;ELSE, TRIES TO DO THE RUN
;IF FAILURE, IT WILL RESTART THIS PROGRAM AT .JBSA

IFN M$INDP,<
.RUNCM::PUSHJ	P,.CCLRB	;CLEAR TYPEAHEAD IF ERROR
	SKIPN	T1,N.DEV	;SEE IF /RUN			[264,506]
	POPJ	P,		;NO--RETURN			[264]
	CAIN	T1,1		;SEE IF /EXIT			[506]
	JRST	[SETZM N.DEV	;YES--CLEAR IN CASE OF CONT.	[506]
		 SETOM T1	;FLAG RETURN FOR LATER		[506]
		 PJRST .MONRT]	;GO EXIT TO MONITOR		[506]
	PUSHJ	P,.ISLGI##	;SEE IF LOGGED IN		[347]
	  PJUMPL T1,.MONRT	;NO--EXIT ASAP INSTEAD OF /RUN	[317,347]
	SKPINL			;DEFEAT ^O
	  JFCL			; ..
	MOVEI	T1,N.ZER	;POINT TO /RUN
	MOVEI	T2,N.OPEN	;POINT TO DUMMY OPEN BLOCK
	MOVEI	T3,N.LOOK	;POINT TO DUMMY LOOKUP BLOCK
	PUSHJ	P,.STOPN	;SETUP OPEN/LOOKUP
	  JRST	E.RWI		;ERROR IF WILD
	PUSHJ	P,.KLIND	;KILL CCL INDIRECT FILE TO
				;  CLEAN UP TMP: IF LAST LINE
				;  IS /RUN:
	MOVE	T1,N.LOOK+.RBPPN  ;MOVE DIRECTORY
	MOVEM	T1,N.LOOK+5	;  FOR RUN UUO
	MOVE	T2,N.OPEN+1	;GET DEVICE
	MOVX	T1,FX.NDV	;GET NULL DEVICE MASK
	TDNE	T1,N.MOD	;TEST SPECIFICATION
	MOVSI	T2,'SYS'	;YES--CHANGE TO 'SYS:'
	MOVEM	T2,N.LOOK+1	;SET INTO RUN UUO BLOCK
	SKIPGE	T1,N.CORE	;GET /N.CORE:XX
	MOVEI	T1,0		;DEFAULT TO 0
	CAIG	T1,777		;SEE IF AT LEAST 1P
	LSH	T1,^D10		;NO--ASSUME K
	MOVEM	T1,N.LOOK+6	;STORE IN ARG BLOCK
	HRLZ	T1,N.OFFS	;GET OFFSET
	HRRI	T1,N.LOOK+1	;POINT TO BLOCK
	SKIPL	N.OFFS		;SEE IF DEFAULT
	JRST	RUNCM2		;NO--PROCEED
	TLZ	T1,-1		;YES--CLEAR OFFSET
	SKIPE	FLCCL		;SEE IF CCL MODE
	TLO	T1,1		;YES--SET CCL MODE OFFSET
RUNCM2:	RUN	T1,		;RUN THE PROGRAM
	MOVE	P,SAVPDP	;IF FAILURE, GIVE MESSAGE
	PUSH	P,T1		;SAVE ERROR CODE
E$$RLF:	MOVE	T1,['RLF',,[ASCIZ /Run linkage failure /] ]
	PUSHJ	P,.TERRP	;TYPE IT
	MOVE	T2,T1		;SAVE /MESSAGE BITS
	POP	P,T1		;RESTORE ERROR CODE
	TXNN	T2,JWW.FL	;SEE IF TEXT NEEDED
	JRST	RUNCM3		;NO--JUST END LINE
	PUSHJ	P,.TOCTW##	;  CODE
	PUSHJ	P,.TSPACE	;SPACE OVER
	MOVEI	T1,N.DEV	;SET POINTER TO RUN BLOCK
	PUSHJ	P,.TFBLK##	;AND TYPE IT
RUNCM3:	PUSHJ	P,.TCRLF##	;END LINE
	PUSHJ	P,.TCRLF##	;AND LEAVE SPACE
	CLRBFI			;CLEAR TYPE AHEAD
	MOVE	T1,.JBSA	;GET START ADDRESS
	JRST	(T1)		;AND START OVER
E.RWI:	MOVEI	N,N.ZER		;POINT TO SPEC
	SETOM	T2		;FLAG FOR NO ERROR CODE
	M$FAIF	(RWI,Wildcard illegal in /RUN specification)
>
	SUBTTL	SUBROUTINES FOR COMMAND INPUT -- FILE SPECIFICATION

;.FILIN -- INPUT WHAT USER TYPES AS THE NEXT FILE SPECIFICATION
;REMEMBER PERMANENT ("STICKY") DEFAULTS
;APPLY STICKY (USER SUPPLIED) DEFAULTS
;PROCESSES SWITCHES, DEVICE, NAME, EXT., AND DIRECTORY
;RETURN ON FIRST BREAK NOT LEGITIMATELY PART OF A FILE SPEC.
;  (ALSO ON SOME SYNTAX ERRORS LIKE "*X")
;
;A FILE SPECIFICATION IS CRUDELY DESCRIBED AS FOLLOWS:
;	NOT MORE THAN ONE EACH OF
;		DEVICE:
;		FILENAME
;		.EXTENSION
;		[PROJECT,PROGRAMMER]
;		[,PROG] [PROJ,] [,]  IMPLY DEFAULT TO LOGGED IN NUMBER.
;		ANY OF ABOVE EXTENDED FOR SFDS: [P,PN, SFD1,SFD2,...]
;		[-] FOR DEFAULT DIRECTORY
;	ANY NUMBER OF NON-OBVIOUSLY CONFLICTING SWITCHES
;		/NAME
;		/NAME:VALUE
;		WHERE VALUE CAN BE A NUMBER, A NAME, A TIME, ETC.
;SOME SWITCHES APPLY TO FILE NAMES, OTHERS ARE GLOBAL TO THE COMMAND.
;THE DEVICE, EXTENSION, DIRECTORY, AND FILE SWITCHES ARE STICKY
;IF THEY APPEAR BEFORE A FILE NAME, AND LOCAL IT AFTER OR IF
;NO FILE NAME APPEARS.  SPACES MAY BE INSERTED FREELY WHERE NEEDED
;OR DESIRED BETWEEN WORDS, BUT MAY NOT SEPARATE THE PARTS OF A WORD.
;FOR EXAMPLE, "/SWITCH:VALUE" IS OK, BUT "/ SWITCH : VALUE" LOSES.
;
;CALL:	SET ZEROES OR DEFAULTS INTO P.XXX AREA
;	PUSHJ	P,.FILIN
;	RETURN WITH TYPE-INS IN F.XXX AREA, P.XXX UPDATED
;	T1 =0 IF NULL, =-1 IF FILE TYPED, =+1 IF JUST GLOBAL SWITCHES
;USES T2, T3, T4, N    UPDATES C (SEPARATOR)

.FILIN::PUSHJ	P,.SAVE1##	;PRESERVE P1
FILIN0:	MOVE	T1,SWTCNT	;GET RECURSION COUNTER		[301]
	PUSHJ	P,.CLRFL	;GO CLEAR FXXX AREA
	JRST	FILIN2		;GO START THE READ

;HERE WHEN SOMETHING FOUND
FILIN1:	SETOM	FLFSP		;SET SOMETHING FOUND FLAG

;HERE TO READ ANOTHER WORD
FILIN2:	PUSHJ	P,.TIAUC	;START THE READ
;HERE WITH WORD, SEE WHAT KIND OF SEPARATOR

FILIN3:	PUSHJ	P,.NAMEC	;READ REST OF WORD
	CAIN	C,":"		;SEE IF DEVICE
	JRST	FILDEV		;YES
IFN	FT$RSX,<
	CAIN	C,"_"		;SEE IF NODE
	JRST	FILNOD		;YES
>

	JUMPE	N,FILIN4	;IF NULL, NOT A FILE NAME
	SKIPE	F.NAM		;FILE NAME--SEE IF SECOND TIME
	JRST	E$$DFN		;YES--ISSUE DUPL. ERROR
	PUSHJ	P,FILSTK	;GO MEMORIZE STICKY DEFAULTS
	PUSHJ	P,.LEFTX	;GUARANTEE LH=0
	MOVEM	N,F.NAM		;OK--SAVE NAME
	MOVEM	T1,F.NAMM	;AND MASK
IFN	FT$RSX,<
	MOVE	T1,NAME1	;GET SECOND PART OF NAME
	MOVEM	T1,F.NAM1	;STORE
	MOVE	T1,MASK1	;GET SECOND PART OF MASK
	MOVEM	T1,F.NMM1	;STORE
>
	SETOM	FLFSP		;FLAG THAT SOMETHING FOUND

FILIN4:	IFN	FT$RSX,<
	CAIN	C,";"		;SEE IF VERSION #
	JRST	FILVER		;YES
>
	CAIN	C,"."		;SEE IF EXTENSION
	JRST	FILEXT		;YES
	CAIE	C,"<"		;SEE IF 2741 DIRECTORY		[252]
	CAIN	C,"["		;SEE IF DIRECTORY
	JRST	FILDIR		;YES
	CAIN	C,"%"		;SEE IF ATTRIBUTE		[522]
	JRST	FILATR		;YES--GO HANDLE			[522]
	CAIN	C,"("		;SEE IF OPEN PAREN		$x^6*\&h