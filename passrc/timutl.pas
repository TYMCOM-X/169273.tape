$TITLE TIMUTL.PAS, last modified 4/9/84, zw
MODULE timutl;
(*TYM-Pascal day/time utility*)

(*HEADER TIMUTL.HDR*)

$INCLUDE TIMUTL.TYP

CONST BASE_DTIME_INTERNAL: DTIME_INT = ( 0, 0 );

(*These are defined in TIMMAC.MAC*)
EXTERNAL FUNCTION EXTR_TIME(DTIME_INT): TIME_INT;
EXTERNAL FUNCTION EXTR_DATE(DTIME_INT): DATE_INT;
EXTERNAL FUNCTION DT_COMBINE(DATE_INT;TIME_INT):DTIME_INT;

FUNCTION magstr(value: INTEGER): STRING[11];
BEGIN
  PUTSTRING (magstr, ABS(value):0);
  IF IOSTATUS <> IO_OK THEN magstr := '***********'
END;

FUNCTION magstr2(value: -99 .. 99): PACKED ARRAY [1..2] OF CHAR;
BEGIN
  PUTSTRING(magstr2, ABS(value):2);
  IF IOSTATUS <> IO_OK THEN magstr2 := '**'
  ELSE IF magstr2[1] = ' ' THEN magstr2[1] := '0';
END;

FUNCTION DC_MONTH ( MTH: 1..12 ): PACKED ARRAY [1..3] OF CHAR;
CONST MONTH_TAB: ARRAY [1..12] OF PACKED ARRAY [1..3] OF CHAR :=
  (  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'  );
BEGIN
  IF (MTH < 1) OR (MTH > 12) THEN DC_MONTH := '***'
  ELSE DC_MONTH := MONTH_TAB[MTH]
END;

function dc_days ( date: date_int ): days;
begin
  dc_days := date.d;
END;

function dc_secs ( time: time_int ): seconds
  options special (word);
const secs_per_day: seconds = 86400;
var temp: machine_word;
begin
  temp := time.t * secs_per_day;
  temp := temp + 400000b;
  temp := temp div (2**18);
  dc_secs := temp;
END;

PUBLIC FUNCTION DC_DATE(DATE: DATE_INT): DATEREC;
CONST
  DAYS_BEFORE: ARRAY [1..13] OF -1..367 =
  ( -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 367  );
VAR
DAYS_LEFT:  0..MAXIMUM(INTEGER);
QUAD_CENTURYS:  0..10;
CENTURYS:  0..3;
QUARTER_DAYS:  0..MAXIMUM(INTEGER);
TIME_TEMP:  0..MAXIMUM(INTEGER);
TEMP_YR:  0..100;
MO_FOUND:  BOOLEAN;
YR: 1858..2217;
MO: 1..12;
DA: 1..31;
LEAP_YEAR: BOOLEAN;
BEGIN
  DAYS_LEFT := DC_DAYS ( DATE );
  (* CONVERT DAY ZERO FROM 11/17/1858 TO 1/1/1501 *)
  DAYS_LEFT := DAYS_LEFT + ((1857 - 1500) * 365) + ((1857 - 1500) DIV 4) -
               ((1857 - 1500) DIV 100) + ((1857 -1500) DIV 400) 
               + 31 +28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 17;
  (* FIND THE NUMBER OF QUADRCENTURIES SINCE THEN *)
  QUAD_CENTURYS := DAYS_LEFT DIV ((400 * 365) + (400 DIV 4) - (400 DIV 100) 
                                  + (400 DIV 400));
  DAYS_LEFT := DAYS_LEFT MOD ((400 * 365) + (400 DIV 4) - (400 DIV 100) +
                                   (400 DIV 400));
  (* FIND QUARTER DAYS LEFT *)
  QUARTER_DAYS := DAYS_LEFT * 4;
  (* DIVIDE THAT BY THE AVERAGE NUMBER OF QUARTER DAYS PER CENTURY *)
  CENTURYS := QUARTER_DAYS DIV (((100 * 365) + (100 DIV 4) - (100 DIV 100)) * 4
                                  + (400 DIV 400));
  QUARTER_DAYS := QUARTER_DAYS MOD (((100 * 365) + (100 DIV 4) - (100 DIV 100))
                                    * 4 + (400 DIV 400));
  (* DISCARD ANY FRACTIONS OF A DAY AND ADD IN 3/4 OF A DAY TO FORCE
      A LEAP DAY INTO THE FORTH YEAR OF EACH 4 YEAR CYCLE  *)
  QUARTER_DAYS := (QUARTER_DAYS DIV 4) * 4 + 3;
  TEMP_YR := QUARTER_DAYS DIV (365 * 4 + 1);
  QUARTER_DAYS := QUARTER_DAYS MOD (365 * 4 + 1);
  YR := TEMP_YR + 1501 + (QUAD_CENTURYS * 400) + (CENTURYS * 100);
  DAYS_LEFT := QUARTER_DAYS DIV 4;
  (* FAKE A FEBUARY 29TH IF ITS NOT A LEAP YEAR AND PAST FEB *)
  LEAP_YEAR := ((YR MOD 4) = 0) AND
    (((YR MOD 100) <> 0) OR
    (( YR MOD 400) = 0));
  IF (NOT LEAP_YEAR) AND (DAYS_LEFT > (30 + 28)) THEN
              DAYS_LEFT := DAYS_LEFT + 1;
  (* WHICH MONTH IS IT *)
  MO := 1;
  MO_FOUND := FALSE;
  WHILE NOT MO_FOUND DO BEGIN
    IF DAYS_LEFT <= DAYS_BEFORE[MO+1] THEN MO_FOUND := TRUE
    ELSE MO := MO + 1
  END;
  DA := DAYS_LEFT - DAYS_BEFORE[MO];
  DC_DATE.YEAR := YR;
  DC_DATE.MONTH := MO;
  DC_DATE.DAY := DA
END;

PUBLIC FUNCTION DC_TIME(TIME:TIME_INT): TIMEREC;
CONST SECS_PER_DAY = 86400;
VAR TIME_SECS: SECONDS; TIME_LEFT: SECONDS;
BEGIN
  WITH DC_TIME DO BEGIN
    TIME_SECS := DC_SECS ( TIME );
    HOURS := TIME_SECS DIV 3600;
    TIME_LEFT := TIME_SECS MOD 3600;
    MINS := TIME_LEFT DIV 60;
    SECS := TIME_LEFT MOD 60
  END
END;

PUBLIC FUNCTION DC_DTIME(DTIME: DTIME_INT): DTIMEREC;
VAR TIME_BIN: TIMEREC; DATE_BIN: DATEREC;
BEGIN
  TIME_BIN := DC_TIME(EXTR_TIME(DTIME));
  DATE_BIN := DC_DATE(EXTR_DATE(DTIME));
  WITH DC_DTIME DO BEGIN
    YEAR := DATE_BIN.YEAR;
    MONTH := DATE_BIN.MONTH;
    DAY := DATE_BIN.DAY;
    HOURS := TIME_BIN.HOURS;
    MINS := TIME_BIN.MINS;
    SECS := TIME_BIN.SECS
  END
END;

PUBLIC FUNCTION DC_EXT(DTIME: DTIME_INT): DTIME_EXT;
BEGIN
  WITH DC_DTIME(DTIME) DO
    DC_EXT := magstr2(DAY) || '-' || DC_MONTH(MONTH) || '-' ||
	SUBSTR(magstr(YEAR),3,2) || ' ' || magstr2(HOURS) ||
	':' || magstr2(MINS) || ':' || magstr2(SECS);
END;

function ec_secs ( secs: seconds ): time_int
  options special (word);
const secs_per_day: seconds = 86400;
var temp: machine_word;
begin
  ec_secs.d := 0;
  temp := secs * (2**18);
  temp := temp + secs_per_day div 2;	(* so following DIV will round *)
  ec_secs.t := temp div secs_per_day;
END;

public function ec_days ( days_since_base: days ): date_int;
begin
  ec_days.d := days_since_base;
  ec_days.t := 0;
END;

PUBLIC PROCEDURE EC_TIME(VAR ERR_CODE: DTIME_ERR;
   TIME_BIN: TIMEREC;  VAR TIME: TIME_INT);
CONST SECS_PER_DAY = 86400;
VAR TIME_SECS: INTEGER;
BEGIN
  WITH TIME_BIN DO BEGIN
    IF (HOURS < 0) ORIF
      (HOURS > 23) ORIF
      (MINS < 0) ORIF
      (MINS > 59) ORIF
      (SECS < 0) ORIF
      (SECS > 59)
    THEN ERR_CODE := DT_ERR
    ELSE BEGIN
      ERR_CODE := DT_NOERR;
      TIME_SECS := HOURS * 3600 + MINS * 60 + SECS;
      TIME := EC_SECS ( TIME_SECS );
    END
  END (* WITH *)
END;

PUBLIC PROCEDURE EC_DATE(VAR ERR_CODE: DTIME_ERR;
   DATE_BIN: DATEREC; VAR DATE: DATE_INT);
TYPE MONTH_TAB = ARRAY [1..12] OF 0..365;
CONST
DAYS_IN_MONTH: MONTH_TAB = (31, 29 , 31, 30, 31, 30,
  31, 31, 30, 31, 30, 31 );
DAYS_BEFORE: MONTH_TAB = (0 , 31, 59, 90, 120,
  151,181, 212, 243, 273, 304, 334 );
VAR
DAYS_SINCE: 0..MAXIMUM(INTEGER);
QUAD_CENT, CENTS, QUAD_YEARS: 0..MAXIMUM(INTEGER);
LEAP_YEAR: BOOLEAN;
BEGIN
  WITH DATE_BIN DO BEGIN
    (* ERROR CHECK DATE PASSED IN *)
    IF (YEAR < 1858) ORIF
       (MONTH < 1) ORIF
       (MONTH > 12) ORIF
       (DAY < 1) ORIF
       (DAY > DAYS_IN_MONTH[MONTH])
    THEN ERR_CODE := DT_ERR
    ELSE BEGIN
      ERR_CODE := DT_NOERR;
      IF YEAR <> 1858 THEN BEGIN
        DAYS_SINCE := 44; (*DAYS FROM YEAR 1858 *)
        DAYS_SINCE := DAYS_SINCE + (YEAR-1859) * 365;
        (* ADD IN 1 FOR EACH LEAP YEAR.  A LEAP YEAR IS
        ASSUMED TO BE ANY YEAR DIVISIBLE BY 4 BUT NOT DIVISIBLE
        BY 100, UNLESS DIVISIBLE BY 400 ALSO.  THUS 1900 WAS 
        NOT A LEAP YEAR, THE YEAR 2000 WILL BE *)
        QUAD_CENT := (YEAR-1) DIV 400 - (1858 DIV 400);
        CENTS := (YEAR-1) DIV 100 - (1858 DIV 100);
        QUAD_YEARS := (YEAR-1) DIV 4 - (1858 DIV 4);
        DAYS_SINCE := DAYS_SINCE + QUAD_CENT - CENTS + QUAD_YEARS;
        (* ADD IN DAYS FOR THE COMPLETED MONTHS OF THIS YEAR *)
        DAYS_SINCE := DAYS_SINCE + DAYS_BEFORE[MONTH];
        IF MONTH > 2 THEN BEGIN
          LEAP_YEAR := ((YEAR MOD 4) = 0) AND
             (((YEAR MOD 100) <> 0) OR
             ((YEAR MOD 400) = 0));
          IF LEAP_YEAR THEN DAYS_SINCE := DAYS_SINCE + 1;
        END;
        (* NOW ADD IN THE DAYS OF THIS MONTH *)
        DAYS_SINCE := DAYS_SINCE + DAY;
      END
      ELSE BEGIN (* SPECIAL CASE - DATE IN 1858 *)
        IF MONTH = 12 THEN DAYS_SINCE := DAY + 13
        ELSE IF MONTH = 11 THEN DAYS_SINCE := DAY - 17
        ELSE ERR_CODE := DT_ERR
      END;
      IF ERR_CODE <> DT_ERR THEN DATE := EC_DAYS ( DAYS_SINCE );
    END (* FIRST IF STATEMENT *)
  END (* WITH *)
END;

PUBLIC PROCEDURE EC_DTIME(VAR ERR_CODE: DTIME_ERR;
  DTIMEBIN: DTIMEREC; VAR DTIME: DTIME_INT);
VAR DATE_BIN: DATEREC; TIME_BIN: TIMEREC; DATE: DATE_INT; TIME: TIME_INT;
BEGIN
  WITH DTIMEBIN DO BEGIN
    DATE_BIN.YEAR := YEAR;
    DATE_BIN.MONTH := MONTH;
    DATE_BIN.DAY := DAY;
    EC_DATE(ERR_CODE, DATE_BIN, DATE);
    IF ERR_CODE = DT_NOERR THEN BEGIN
      TIME_BIN.HOURS := HOURS;
      TIME_BIN.MINS := MINS;
      TIME_BIN.SECS := SECS;
      EC_TIME(ERR_CODE,TIME_BIN, TIME);
      IF ERR_CODE = DT_NOERR THEN DTIME := DT_COMBINE(DATE,TIME)
    END
  END (* WITH *)
END;

PUBLIC PROCEDURE EC_EXT
  (VAR ERR_CODE: DTIME_ERR; DT_EXT: NS_EXT; VAR DTIME: DTIME_INT);
TYPE
MONTH_RANGE = 1..12;
CURSOR_RANGE = 1..160;
POS_INT = 0..MAXIMUM(INTEGER);
CONST CENTURY := 1900;	(* CENTURY USED FOR 2 DIGIT YEARS *)
VAR
DTIME_BIN: DTIMEREC;	(*WE FIRST CONVERT TO BINARY *)
CURSOR: CURSOR_RANGE;	(* CURSOR FOR SCANNING EXTERNAL STRING *)
EOS: BOOLEAN;		(* END OF STRING FLAG *)
CH: CHAR;
CASE_IDX: 0..MAXIMUM(INTEGER);  (* INDEX FOR MAINLINE CASE *)
LA_IDX: CURSOR_RANGE;	(* LOOK AHEAD STRING SCAN CURSOR *)
TIME_SCANNED: BOOLEAN;	(* TRUE IF EXTERNAL TIME SCANNED ALREADY *)

PROCEDURE SCAN_BLANKS(VAR CURSOR: CURSOR_RANGE; VAR EOS: BOOLEAN);
(*  SCAN_BLANKS - MOVES CURSOR PAST ANY BLANKS; 'EOS' IS
 *  SET TO TRUE IF THE END OF THE STRING IS REACHED BEFORE
 *  A NON-BLANK IS ENCOUNTERED. *)
BEGIN
  LOOP
    EOS := CURSOR > LENGTH(DT_EXT);
    EXIT IF EOS;
    EXIT IF DT_EXT[CURSOR] <> ' ';
    CURSOR := CURSOR + 1
  END
END;

PROCEDURE SCAN_MONTH(VAR ERR_CODE: DTIME_ERR; 
   VAR CURSOR: CURSOR_RANGE; VAR MONTH_IDX: MONTH_RANGE);
(*
 *  SCAN_MONTH - CURSOR SHOULD BE POINTING AT FIRST CHARACTER
 *  OF MONTH.  RETURNS INDEX OF MONTH IF ASSUMPTION
 *  HOLDS, OTHERWISE ERROR CODE IS RETURNED.
 *)
TYPE
MONTH_TEXT = PACKED ARRAY [1..3] OF CHAR;
MTH_NAME_TAB = ARRAY [MONTH_RANGE] OF MONTH_TEXT;
CONST
MONTH_NAME: MTH_NAME_TAB = ( 'JAN' , 'FEB' , 'MAR' , 'APR' ,
  'MAY' , 'JUN' , 'JUL' , 'AUG' , 'SEP' , 'OCT' , 'NOV' , 'DEC');
VAR THIS_MONTH: MONTH_TEXT; I: 1..13;
BEGIN
  ERR_CODE := DT_NOERR;
  IF CURSOR + 2 > LENGTH(DT_EXT) THEN ERR_CODE := DT_ERR
  ELSE BEGIN
    THIS_MONTH := UPPERCASE(SUBSTR(DT_EXT,CURSOR,3));
    CURSOR := CURSOR + 3;
    I := 1;
    WHILE (I <= 12) ANDIF (THIS_MONTH <> MONTH_NAME[I]) DO I := I + 1;
    IF I = 13 THEN ERR_CODE := DT_ERR ELSE MONTH_IDX := I
  END
END;

PROCEDURE SCAN_INTEGER(VAR ERR_CODE: DTIME_ERR;
   VAR CURSOR: CURSOR_RANGE;  VAR INT_VAL: POS_INT);
(*
 *  SCAN_INTEGER - CURSOR SHOULD BE POINTING AT FIRST DIGIT
 *  OF AN INTEGER.  CONVERTS INTEGER TO BINARY AND RETURNS ITS
 *  VALUE IF ASSUMPTION HOLDS, OTHERWISE ERROR CODE IS RETURNED.
 *)
TYPE
DIGIT_TAB = PACKED ARRAY ['0'..'9'] OF 0..9;
SET_OF_CHAR = SET OF CHAR;
CONST
DIGIT_VAL: DIGIT_TAB := (0,1,2,3,4,5,6,7,8,9);
DIGITS_SET: SET_OF_CHAR := ['0'..'9'];
BEGIN
  ERR_CODE := DT_NOERR;
  INT_VAL := 0;
  IF (CURSOR > LENGTH(DT_EXT)) ORIF NOT (DT_EXT[CURSOR] IN DIGITS_SET)
  THEN ERR_CODE := DT_ERR
  ELSE LOOP
    EXIT IF CURSOR > LENGTH(DT_EXT);
    CH := DT_EXT[CURSOR];
    EXIT IF NOT (CH IN DIGITS_SET);
    CURSOR := CURSOR + 1;
    INT_VAL := INT_VAL * 10 + DIGIT_VAL[CH]
  END
END;

PROCEDURE SCAN_DATE(VAR ERR_CODE: DTIME_ERR; VAR CURSOR: CURSOR_RANGE);
(*
 *  SCAN_DATE - PARSES DATE STRING WITH FORMAT: 'DD-MM-YY'.
 *  SETS FIELDS 'YEAR', 'MONTH' AND 'DAY' OF RECORD
 *  'DTIME_BIN'.
 *)
BEGIN
  SCAN_INTEGER(ERR_CODE, CURSOR, DTIME_BIN.DAY);
  IF ERR_CODE = DT_NOERR THEN BEGIN
    CURSOR := CURSOR + 1; (* SKIP FIRST '-' *)
    SCAN_MONTH(ERR_CODE,CURSOR,DTIME_BIN.MONTH);
    IF ERR_CODE = DT_NOERR THEN BEGIN
      CURSOR := CURSOR + 1; (* SKIP SECOND '-'  *)
      SCAN_INTEGER(ERR_CODE, CURSOR, DTIME_BIN.YEAR );
      IF ERR_CODE = DT_NOERR THEN DTIME_BIN.YEAR := DTIME_BIN.YEAR + CENTURY
    END
  END
END;

PROCEDURE SCAN_NS_D1(VAR ERR_CODE: DTIME_ERR; VAR CURSOR: CURSOR_RANGE);
(*
 *  SCAN_NS_D1 - PARSES DATE STRING WITH FORMAT: 'MM/DD/YY'.
 *  SETS FIELDS 'YEAR', 'MONTH' AND 'DAY' OF RECORD 'DTIME_BIN'.
 *)
VAR YR: 1858..MAX_YEAR;
BEGIN
  SCAN_INTEGER(ERR_CODE, CURSOR, DTIME_BIN.MONTH);
  IF ERR_CODE = DT_NOERR THEN BEGIN
    CURSOR := CURSOR + 1;  (* SKIP FIRST '/'  *)
    SCAN_INTEGER(ERR_CODE, CURSOR, DTIME_BIN.DAY);
    IF ERR_CODE = DT_NOERR THEN BEGIN
      CURSOR := CURSOR + 1;  (* SKIP SECOND '/'   *)
      SCAN_INTEGER(ERR_CODE, CURSOR, YR );
      IF ERR_CODE = DT_NOERR THEN DTIME_BIN.YEAR := YR + CENTURY
    END
  END
END;

PROCEDURE SCAN_NS_D2(VAR ERR_CODE: DTIME_ERR; VAR CURSOR: CURSOR_RANGE);
(*
 *  SCAN_NS_D2 - PARSES A DATE STRING WITH FORMAT 'MMM DD,YYYY'.
 *  SETS FIELDS 'YEAR', 'MONTH' AND 'DAY' OF RECORD 'DTIME_BIN'.
 *)
BEGIN
  SCAN_MONTH(ERR_CODE, CURSOR, DTIME_BIN.MONTH);
  IF ERR_CODE = DT_NOERR THEN BEGIN
    SCAN_BLANKS(CURSOR,EOS);
    SCAN_INTEGER(ERR_CODE, CURSOR, DTIME_BIN.DAY);
    IF ERR_CODE = DT_NOERR THEN BEGIN
      CURSOR := CURSOR + 1;  (* SKIP ','  *)
      SCAN_BLANKS(CURSOR,EOS);
      SCAN_INTEGER(ERR_CODE,CURSOR,DTIME_BIN.YEAR)
    END
  END
END;

PROCEDURE SCAN_TIME(VAR ERR_CODE: DTIME_ERR; VAR CURSOR: CURSOR_RANGE);
(*
 *  SCAN_TIME - PARSES TIME STRING WITH FORMAT: 'HH:MM:SS [A/P]M',
 *  WHERE FINAL 'AM' OR 'PM' IS OPTIONAL.  SETS FIELDS 'HOURS',
 *  'MINS' AND 'SECS' OF RECORD DTIME_BIN.
 *)
VAR HRS: 0..59; am: packed array [1..2] of char;
BEGIN
  TIME_SCANNED := TRUE;
  SCAN_INTEGER(ERR_CODE, CURSOR, HRS);
  IF ERR_CODE = DT_NOERR THEN BEGIN
    CURSOR := CURSOR + 1; (* SKIP FIRST ':'  *)
    SCAN_INTEGER(ERR_CODE, CURSOR, DTIME_BIN.MINS);
    IF ERR_CODE = DT_NOERR THEN BEGIN
      CURSOR := CURSOR + 1;  (* SKIP SECOND ':'  *)
      SCAN_INTEGER(ERR_CODE, CURSOR, DTIME_BIN.SECS);
      IF ERR_CODE = DT_NOERR THEN BEGIN
        SCAN_BLANKS(CURSOR, EOS);
        IF CURSOR + 1 <= LENGTH(DT_EXT)
	THEN am := uppercase ( substr ( dt_ext, cursor, 2 ) );
        if ( am = 'PM' ) and ( hrs < 12 ) then hrs := hrs + 12
        else if ( am = 'AM' ) and (hrs = 12) then hrs := hrs - 12;
        DTIME_BIN.HOURS := HRS
      END
    END
  END
END;

BEGIN (*  EC_EXT MAIN ROUTINE. *)
  DTIME := BASE_DTIME_INTERNAL;
  ERR_CODE := DT_NOERR;
  CURSOR := 1;
  TIME_SCANNED := FALSE;
  WITH DTIME_BIN DO
  BEGIN
    YEAR := 1858;
    MONTH := 11;
    DAY := 17;
    HOURS := 0;
    MINS := 0;
    SECS := 0
  END;
  SCAN_BLANKS(CURSOR,EOS);  (* SCAN PAST ANY INITIAL BLANKS *)
  IF NOT EOS THEN BEGIN
    CASE_IDX := 0;
    LA_IDX := CURSOR;
    LOOP
      EXIT IF LENGTH(DT_EXT) <= LA_IDX DO EOS := TRUE;
      CH := DT_EXT[LA_IDX];
      IF CH = '-' THEN CASE_IDX := 1
      ELSE IF CH = '/' THEN CASE_IDX := 2
      ELSE IF CH = ' ' THEN CASE_IDX := 3
      ELSE IF CH = ':' THEN CASE_IDX := 4
      ELSE LA_IDX := LA_IDX + 1;
      EXIT IF CASE_IDX <> 0
    END;
    CASE CASE_IDX OF
      0: ERR_CODE := DT_ERR;
      1: SCAN_DATE(ERR_CODE, CURSOR);
      2: SCAN_NS_D1(ERR_CODE, CURSOR);
      3: SCAN_NS_D2(ERR_CODE, CURSOR);
      4: SCAN_TIME(ERR_CODE, CURSOR)
    END;
    IF NOT TIME_SCANNED THEN BEGIN
      SCAN_BLANKS(CURSOR, EOS);
      IF NOT EOS THEN SCAN_TIME(ERR_CODE, CURSOR)
    END;
    (* CONVERT BINARY TO INTERNAL FORMAT *)
    IF ERR_CODE = DT_NOERR THEN EC_DTIME(ERR_CODE, DTIME_BIN, DTIME)
  END
END;

PUBLIC FUNCTION NS_D1(DATE: DATE_INT): NS_DATE1;
BEGIN
  WITH DC_DATE(DATE) DO
    NS_D1 := magstr2(MONTH) || '/' ||
       magstr2(DAY)   || '/' ||
       SUBSTR(magstr(YEAR),3,2);
END;

PUBLIC FUNCTION NS_D2(DATE: DATE_INT): NS_DATE2;
BEGIN
  WITH DC_DATE(DATE) DO
    PUTSTRING (NS_D2, DC_MONTH(MONTH), ' ', DAY:0, ', ', YEAR:4);
END;

PUBLIC FUNCTION NS_T1(TIME: TIME_INT): NS_TIME1;
VAR H: 0..23; AM: PACKED ARRAY [1..2] OF CHAR;
BEGIN
  WITH DC_TIME(TIME) DO BEGIN
    H := HOURS;
    if hours < 12 then begin
      am := 'AM';
      if H = 0 then H := 12;
    end
    else begin
      am := 'PM';
      if H > 12 then H := H - 12;
    end;
    NS_T1 := magstr2(H) || ':'
      || magstr2(MINS) || ':'
      || magstr2(SECS) || ' '
      || AM
  END
END;

PUBLIC FUNCTION EC_DCTIME(D_TIME: DEC_TIME): TIME_INT;
VAR
SECS_SINCE: DEC_TIME;	(* SECONDS SINCE MIDNIGHT *)
SECS_LEFT: DEC_TIME;
TIME_BIN: TIMEREC;
ERR_CODE: DTIME_ERR;
TIME: TIME_INT;
BEGIN
  WITH TIME_BIN DO BEGIN
    SECS_SINCE := D_TIME DIV 1000;
    HOURS := SECS_SINCE DIV 3600;
    SECS_LEFT := SECS_SINCE MOD 3600;
    MINS := SECS_LEFT DIV 60;
    SECS := SECS_LEFT MOD 60;
  END;
  EC_TIME(ERR_CODE, TIME_BIN, TIME );
  IF ERR_CODE = DT_NOERR THEN EC_DCTIME := TIME
  ELSE EC_DCTIME := ( 0, 0 )
END;

PUBLIC FUNCTION EC_DCDATE(D_DATE: DEC_DATE): DATE_INT;
VAR
DATE_BIN: DATEREC; DAYS_LEFT: DEC_DATE; ERR_CODE: DTIME_ERR; DATE: DATE_INT;
BEGIN
  WITH DATE_BIN DO BEGIN
    YEAR := D_DATE DIV (12 * 31) + 1964;
    DAYS_LEFT := D_DATE MOD (12 * 31);
    MONTH := DAYS_LEFT DIV 31 + 1;
    DAY := DAYS_LEFT MOD 31 + 1;
  END;
  EC_DATE(ERR_CODE, DATE_BIN, DATE);
  IF ERR_CODE = DT_NOERR THEN EC_DCDATE := DATE
  ELSE EC_DCDATE := ( 0, 0 )
END;

public function ec_tsdate ( ts_date: tym_date ): date_int;
(* EC_TSDATE - converts a standard TYMSHARE date to an internal date.
   The standard TYMSHARE date is the *exact* number of days since
   January 1, 1964.  *)
begin
  ec_tsdate.d := ts_date + 112773b;
END;

PUBLIC FUNCTION DAY_OF_WEEK(DATE: DATE_INT): WEEK_DAY;
VAR NORM_DATE: 0..777777B; DAY_INDEX,I: 0..6;
BEGIN
  NORM_DATE := DC_DAYS ( DATE );
  DAY_INDEX := (NORM_DATE + 3) MOD 7;  (* DAY ZERO WAS A WED *)
  DAY_OF_WEEK := SUNDAY;
  FOR I := 1 TO DAY_INDEX DO DAY_OF_WEEK := SUCC(DAY_OF_WEEK)
END.
 