	SEARCH	RTSYM
	$MODULE	QUICKFIT


	DEBUG=	0
;
;     ENTRY POINTS
;
	INTERN	ALC0.
	INTERN	NEW.
	INTERN	DSPOS.
;	INTERN	MARK.	;code left, but unused
;	INTERN	RLEAS.	;code left, but unused
	ENTRY	ON%HEAP%OVERFLOW

	EXTERN	SF$VFY
	EXTERN	OHP.TV
	INTERN	OHP.AC
	EXTERN	HRP.TV
	INTERN	HRP.AC
	EXTERN	HFL.TV
	INTERN	HFL.AC
;
;     TTY BREAK
;
	EXTERN	TWAIT.,DIE.,WRTPC.
;
;     HEAP HEADER
;
	LHEAP=	0		; PTR TO LAST HEAP
	TAIL=	1		; PTR TO WORD PAST END OF HEAP
	FLIST=	2		; PTR (0:ERSIZE+1) TO FREE LIST CHAINS
	ERSIZE=	20		; EXACT RANGE SIZE
	HSIZE=	FLIST+ERSIZE+2	; TOTAL HEADER SIZE
;
;     STORAGE PARAMETERS
;
	SMALL=	1		; DON'T SPLIT LEAVING REMNANTS OF THIS SIZE
	MINSZ=	2		; LIMITS OF EXACT RANGE
	MAXSZ=	MINSZ+ERSIZE-1
	MXTCNT=	4		; NUMBER OF TAIL EXTENSIONS BEFORE COLLAPSE
;
;     BLOCK FORMAT
;
	ASIZE=	0		; BLOCK IN USE, NEG. CNT IN FIRST WORD
	FSIZE=	1		; FREE BLOCK, CNT IN SECOND WORD
				; SIZES INCLUDE HEADER WORD
	FPREV=	0		; TO LAST BLOCK ON CHAIN (LEFT HW)
				;   OR FLIST(SLOT) IF FIRST
	FNEXT=	0		; TO NEXT BLOCK ON CHAIN (RIGHT HW)
;
;     REGISTER ASSIGNMENTS
;
	REGIN=	1
	HEAP=	EXP1+1	; PTR TO HEAP IN USE
	CNT=	EXP1		; SIZE TO BE ALLOCATED
	SLOT=	EXP1+2	; SLOT INDEX IN FLIST FOR BLOCK
	BLK=	1		; PTR TO BLOCK TO BE FREED
	T=	EXP1+3	; TEMPS
	R=	EXP1+4	; MUST BE T+1
	NB=	EXP1+5	; PTR TO NEXT BLOCK IN COLLAPSE
	RES=	EXP1+5	; PTR TO AREA RETURNED
	HP=	EXP1		; HEAP PTR FOR MARK AND RELEASE

;
; PSA STORAGE
;
	$STATIC	CHEAP,1
	$STATIC	PASS,1
	$STATIC	TCNT,1
	$STATIC	REGSAVE,6
	$STATIC	DESTREG,1	; where to put it
	$STATIC	NOCORE,1	;HANDLER FOR CORE UUO FAILURE
	$STATIC	HANDLER,1	;IF ON_HEAP_OVERFLOW CALLED:
				; (LH) = CALLER BASIS
				; (RH) = CALLER RETURN ADDRESS

;
; ON_HEAP_OVERFLOW is called to allow the user to specify a
; handler for a heap overflow condition. It is call by:
;
;  if on_heap_overflow then <statement>;
;
; The first call records the return address and stack frame
; and returns false. On an actual overflow the stack is unwound
; to the appropriate frame and true is returned.
;

ON%HEAP%OVERFLOW:
	$GETPSA	QFIT
	MOVE	R1,0(TOP)	;GET RETURN ADDRESS
	HRLI	R1,0(BASIS)	;AND CALLER STACK FRAME
	MOVEM	R1,HANDLER	;AND SAVE
	MOVEI	R1,OHP.TV	;INTERFACE TO USER (VECTORED FOR OVERLAYS)
	MOVEM	R1,NOCORE
	SETZM	FV(TOP)	;RETURN FALSE
	POPJ	TOP,

OHP.AC:				;CORE OVERFLOWED AND USER WANTS TO KNOW ABOUT IT
	HLRZ	R1,HANDLER	;GET HIS STACK FRAME
;
;  First call SF$VFY to guarantee that the overlay containing the
;  user handler is resident.  The return to this routine must be
;  through a transfer vector since SF$VFY may cause a high seg
;  swap; thus the call fakes a PUSHJ, pushing the transfer vector
;  address onto the stack as the return address.  
;  If the program is not overlaid, the 'xxx.TV' addresses are
;  equated to the 'xxx.AC' address and SF$VFY is simply a POPJ.
;
	PUSH	TOP,[EXP  HRP.TV]
	JRST	SF$VFY
;
; Cannot reasonably use UW.PRG or UW.RTN to unwind the stack
; since each jumps directly to the specified label and this
; routine must leave a boolean result on the stack.
; Thus the unwind is performed here.
;
HRP.AC:	CAIN	R1,0(BASIS)	;BACK TO APPROPRIATE FRAME YET?
	JRST	HOUT		;YES
	DMOVE	BASIS,1(BASIS)	;NO, BACK UP ANOTHER FRAME
	JRST	HRP.AC
HOUT:	MOVEI	R1,$TRUE	;BOOLEAN FUNCTION VALUE
	MOVEM	R1,FV(TOP)
	POP	TOP,R1		;CLEAR RETURN ADDRESS
	MOVE	R1,HANDLER	;HANDLER ADDRESS
	EXCH	PSA,$QFIT(PDA)	;RESTORE THE PSA
	JRST	0(R1)		;REPORT OVERFLOW

;
;     INITIALIZATION:  GET SPACE IN WHICH TO PUT INITIAL PORTION
;     OF HEAP. INITIALIZE NEW HEAP.
;
ALC0.:
INIT:	HRRZ	HEAP,.JBFF##	; GET PTR TO START OF LOW FREE
	MOVNI	R0,MXTCNT
	MOVEM	R0,TCNT
	MOVEI	R0,HFL.TV	; DEFAULT IS TO ABORT ON HEAP OVERFLOW
	MOVEM	R0,NOCORE
;
;     SUBROUTINE TO INITIALIZE A NEW HEAP HEADER.  ENTERED
;     WITH HEAP POINTING TO THE NEW HEAP AND CHEAP TO
;     THE LAST HEAP. MAKES SURE THERE IS SPACE FOR HEAP.
;
NEWHP:	MOVEI	T,1K(HEAP)	; MAKE SURE THERE IS A K FOR NEW HEAP
	CORE	T,		; TRY ALLOCATION
	JRST	@NOCORE		; TOO LITTLE CORE
	MOVEI	T,@CHEAP	; GET POINTER TO LAST HEAP
	MOVEM	T,LHEAP(HEAP)
	MOVEI	T,HSIZE(HEAP);	; GET POINTER TO FIRST FREE WORD
	MOVEM	T,TAIL(HEAP);
	MOVSI	T,-ERSIZE-2	; FAST LOOP TO ZERO FREE LIST
	HRRI	T,(HEAP)	; BUILD CONTROL WORD
	SETZM	FLIST(T)	; ZERO IT
	AOBJN	T,.-1
	MOVEM	HEAP,CHEAP	; UPDATE CURRENT HEAP PTR
	POPJ	TOP,		; RETURN
;
;     SUBROUTINE TO CALCULATE THE SLOT THAT BLOCK BELONGS IN.
;     ENTERED WITH SIZE LOADED IN CNT, AND RETURNS WITH SLOT
;     INDEX IN SLOT.
;
CSLOT:	CAIGE	CNT,MINSZ	; CHECK IF BELOW EXACT RANGE
	JRST	CSLOW
	CAILE	CNT,MAXSZ	; CHECK IF ABOVE
	JRST	CSHIGH
	MOVEI	SLOT,1-MINSZ(CNT)  ;COMPUTE SLOT NUMBER
	POPJ	TOP,
CSLOW:	SETZM	SLOT		; BELOW, SLOT = 0
	POPJ	TOP,
CSHIGH:	MOVEI	SLOT,ERSIZE+1	; ABOVE
	POPJ	TOP,
;
;     NEW -- ALLOCATE STORAGE OF CNT WORDS
;
NEWERR:	$FTERROR NEGSIZE
NEGSIZE:ASCIZ	/
?	Negative block size requested in NEW/
NEW.:
	MOVEI	R1,1		; get ARG business
	ADDB	R1,0(TOP)	; tick return addr too
	MOVEI	R0,@-1(R1)	; EA of arg is size needed
	LDB	R1,[point 4,-1(R1),12]	; ac bits give reg to store
	EXCH	PSA,$QFIT(PDA)
	MOVEM	R1,DESTREG	; store it
	$SAVE	REGSAVE,2,7
	MOVE	EXP1,R0		; load size where needed
	JUMPL	CNT,NEWERR	; ERROR OUT IF NEGATIVE BLOCK SIZE REQUESTED
	CAIG	CNT,0		; CAN ALLOCATE ZERO BLOCK ALRIGHT, BUT REQUIRE
	MOVEI	CNT,1		; AT LEAST TWO WORDS TO TRACK BLOCK WHEN
				; DISPOSED
	MOVEI	HEAP,@CHEAP	; GET PTR TO CURRENT HEAP
	CAIN	HEAP,0		; INIT, IF HAVE NOT ALREADY DONE SO
	PUSHJ	TOP,INIT
	ADDI	CNT,1		; ONE WORD FOR BLOCK DESCRIPTOR WROD
	IFN	DEBUG	<PUSHJ TOP,TELCNT>
	SETOM	PASS		; FLAG NO OF COLLAPSES
	PUSHJ	TOP,CSLOT	; CALC SLOT INDEX FOR BLOCK
	JUMPE	SLOT,BELOW	; SLOT 0 - BELOW RANGE
	CAILE	SLOT,ERSIZE	; SKIP IF IN EXACT RANGE
	JRST	ABOVE

;
;     REQUESTED ALLOCATION IS IN EXACT RANGE.  FIRST TRY TO FIND
;     A BLOCK OF THE REQUIRED SIZE.  ONE EXISTS IF THE FREE LIST
;     FOR THAT SIZE IS NON NULL.  IF THERE IS NOT SUCH BLOCK
;     THEN CONTINUE TO ATTEMPT ALLOCATIONS BY OTHER METHODS, BELOW.
;
EXACT:	MOVEI	T,FLIST(HEAP)	; GET ADDRESS OF FREELIST SLOT TO LOOK AT
	ADD	T,SLOT
	MOVEI	RES,@0(T)	; LOAD PTR TO FIRST SLOT
	JUMPE	RES,ESRCH	; IF ZERO, LIST IS NULL, TRY OTHER METHOOS

	HRRZ	R,FNEXT(RES)	; GET PTR TO NEXT ON LIST
	MOVEM	R,0(T)		; UNCHAIN BLOCK, SET FLIST TO NEXT
	HRLM	T,FPREV(R)	; NEXT.PREV = FLIST(SLOT)
	MOVNM	CNT,ASIZE(RES)	; FLAG BLOCK AS IN USE
	JRST	.+2		; NO NEED TO UNWIND STACK

DONE:	POP	TOP,T		; UNWIND CALL STACK
	SETZM	1(RES)		; ALWAYS ON WORD
	MOVN	R1,0(RES)	; GET BLOCK SIZE
	CAIG	R1,2
	JRST	NEWRET
	MOVEI	EXP1,2(RES)	; PREPARE BLT TO ZERO BLOCK
	HRLI	EXP1,1(RES)
	MOVEI	EXP2,-1(RES)
	ADD	EXP2,R1
	BLT	EXP1,0(EXP2)
NEWRET:	MOVEI	R1,1(RES)	; ADVANCE TO POINT TO DATA AREA
	IFN	DEBUG	<MOVEI  BLK,-1(EXP1)
			 PUSHJ TOP,TELBLK>
	$RESTORE REGSAVE,2,7
	MOVE	R0,DESTREG	; where to put it
	EXCH	PSA,$QFIT(PDA)
	MOVEM	R1,@R0		; put it there, bud
	POPJ	TOP,		; RETURN FROM NEW
;
;     REST OF EXACT RANGE SIZE METHODS.  TRY EACH IN TURN. IF THEY
;     FAIL, THEY WILL RETURN; OTHERWISE, THEY JUMP TO DONE.
;
ESRCH:	PUSHJ	TOP,TAILA	; ALLOCATE OFF THE TAIL
	PUSHJ	TOP,SPLIT	; TRY SPLITING BIGGER EXACT RANGE BLOCKS
	PUSHJ	TOP,GROWT	; CALL MONITOR TO EXTEND TAIL
	PUSHJ	TOP,MISCA	; TRY SPLITTING BLOCKS ABOVE RANGE
	AOSE	PASS		; IF FIRST PASS, TRY COLLAPSE
	JRST	@NOCORE		; IF SECOND, GIVE UP
	PUSHJ	TOP,COLLPS
	JRST	EXACT

HFL.AC:	$FTERROR HEAPOVERFLOW
HEAPOVERFLOW:
	ASCIZ	/
?	HEAP overflow. Try again with more core/
;
;     ALLOCATE A BLOCK BELOW THE EXACT RANGE.  TRY FINDING A BLOCK
;     IN SLOT 0, THEN GETTING SOMETHING FROM THE TAIL, THEN SPLITING
;     EXACT RANGE AND LARGER BLOCKS.
;
BELOW:	PUSHJ	TOP,MISCB	; SEARCH SMALL BLOCKS
	PUSHJ	TOP,TAILA	; GET FROM TAIL
	PUSHJ	TOP,SPLIT	; SPLIT ER BLOCKS
	PUSHJ	TOP,GROWT	; EXTEND TAIL
	PUSHJ	TOP,MISCA	; TRY BIG BLOCKS
	AOSE	PASS		; TRY COLLAPSE IF FIRST PASS
	JRST	@NOCORE
	PUSHJ	TOP,COLLPS
	JRST	BELOW
;
;     ALLOCATE A BLOCK ABOVE THE EXACT RANGE.  SEE IF THERE IS ONE
;     ON THE SLOT (ERSIZE+1) LIST, OTHERWISE TRY THE TAIL.
;
ABOVE:	PUSHJ	TOP,MISCA
	PUSHJ	TOP,TAILA
	PUSHJ	TOP,GROWT
	AOSE	PASS		; TRY COLLAPSE IF FIRST PASS
	JRST	@NOCORE
	PUSHJ	TOP,COLLPS
	JRST	ABOVE

;
;     SUBROUTINE TO ALLOCATE FROM TAIL.  CHECK IF DESIRED BLOCK SIZE
;     STAYS WITHIN ALLOCATED LOW SEGMENT SIZE.
;
TAILA:	MOVEI	RES,@TAIL(HEAP)	; GET PTR TO TAIL
	MOVE	T,RES		; SET T TO NEW TAIL PR
	ADD	T,CNT
	CAMLE	T,.JBREL##	; CHECK IF EXCEEDS LOW SEG SIZE
	POPJ	TOP,		; TOO BIG, RETURN
	MOVEM	T,TAIL(HEAP)	; OKAY, UPDATE TAIL PTR
	MOVNM	CNT,ASIZE(RES)	; MARK BLOCK AS ALLOCATED
	JRST	DONE
;
;     SUBROUTINE TO GROW TAIL.  CHECKS IF GROWTH WOULD EXCEED MAX
;     CORE AVAILABLE TO USER; IF OKAY, EXTENDS LOW SEGMENT.
;
GROWT:	AOSLE	TCNT		; ALLOW COLLAPSE EVERY MXCNT TIMES
	JRST	NOGROW
	MOVEI	RES,@TAIL(HEAP)	; GET PTR TO TAIL
	MOVE	T,RES		; SET T TO NEW END
	ADD	T,CNT
	MOVE	R,T		; REMEMBER NEW TAIL
	HRRZM	T,.JBFF##	;SAVE NEW TOP OF THE WORLD
	CORE	T,		; TRY TO EXTEND
SPLTFL:	POPJ	TOP,		; EXTENDING FAILS
	MOVEM	R,TAIL(HEAP)	; ADVANCE TAIL PTR
	MOVNM	CNT,ASIZE(RES)	; MARK BLOCK AS ALLOCATED
	JRST	DONE

NOGROW:	MOVNI	T,MXTCNT	; RESET COUNTER
	MOVEM	T,TCNT
	POPJ	TOP,		; RETURN HAVING DONE NOTHING
;
;     SUBROUTINE TO SPLIT EXACT RANGE BLOCKS.  SEARCHES LIST IN SLOTS FOR
;     SIZES GREATER THAN THAT REQUIRED.  IF A BLOCK IS FOUND, IT IS
;     SPLIT AND THE REMAINDER FREED.
;
SPLIT:	MOVNI	T,ERSIZE	; BUILD SEARCH CONTROL WORD
	ADD	T,SLOT		; LEFT: - (ERSIZE - (SLOT+1) + 1)
	HRLZI	T,0(T)		; MOVE TO LEFT HALF
	HRRI	T,0(HEAP)	; RIGHT: SLOT(HEAP)
	ADD	T,SLOT
	AOBJP	T,SPLTFL	; RETURN IF END OF SEARCH
	MOVEI	RES,@FLIST(T)	; GET FREE LIST PTR
	JUMPE	RES,.-2		; EXIT IF NONNULL LIST FOUND

SPLTDO:	MOVE	BLK,RES		; UNCHAIN THE BLOCK
	PUSHJ	TOP,UNCHN

	MOVE	R,FSIZE(RES)	; GET SIZE OF BLOCK FOUND
	SUB	R,CNT		; SEE IF REM TOO SMALL
	CAILE	R,SMALL
	JRST	SPLTOK		; LEFT OVER WEENABLE

	MOVE	R,FSIZE(RES)	; LEFT OVER TOO SMALL
	MOVNM	R,ASIZE(RES)	; MARK AS ALLOCATED WITH UNSPLIT COUNT
	JRST	DONE

SPLTOK:	MOVNM	CNT,ASIZE(RES)	; MARK AS ALLOCATED WITH SPLIT COUNT
	MOVEI	BLK,0(RES)	; SET T TO PORTION TO BE SPLIT
	ADD	BLK,CNT

	MOVE	CNT,R		; GET SIZE OF SPLIT BLOCK
	PUSHJ	TOP,FREE	; FREE IT
	JRST	DONE
;
;     SUBROUTINES TO SEARCH SLOT(0) AND SLOT(ERSIZE+1) LISTS FOR
;     BLOCK LARGE ENOUGH TO HOLD CNT WORDS.  IF FOUND, REMAINDER
;     IS SPLIT OFF AND FREED.
;
MISCA:	MOVEI	RES,FLIST+ERSIZE+1(HEAP)   ; PTR TO FREELIST SLOT TO SEARCH
	JRST	.+2
MISCB:	MOVEI	RES,FLIST+0(HEAP)	; SLOT(0) SEARCH

MSRCH:	HRRZ	RES,FNEXT(RES)	; ADVANCE TO NEXT SLOT
	JUMPN	RES,.+2		; IF ONE EXSISTS
	POPJ	TOP,
	CAMG	CNT,FSIZE(RES)	; SEE IF BLOCK LARGE ENOUGH
	JRST	SPLTDO
	JRST	MSRCH		; CONTINUE WITH NEXT
;
;     SUBROUTINE TO COLLAPSE ADJACENT BLOCKS OF FREE STORAGE. IN CODE
;     BLK POINTS TO CURRENT BLOCK, NB TO NEXT BLOCK.
;
COLLPS:	PUSH	TOP,CNT	; SAVE CNT OF BLOCK BEING ALLOCATED
	PUSH	TOP,SLOT	; AND SLOT NUMBER
	MOVEI	NB,HSIZE(HEAP)	; GET PTR TO FIRST BLOCK
CLLOOP:	MOVE	BLK,NB		; MOVE TO NEXT BLOCK
	CAML	BLK,TAIL(HEAP)	; SEE IF BLOCK IS OUT OF RANGE
	JRST	CLRET		; ALL DONE
	MOVN	CNT,ASIZE(BLK)	; IF SIZE NEG, THEN BLOCK FREE
	JUMPL	CNT,CLFREE	; BLK IS FREE, TRY TO COLLAPSE
	ADD	NB,CNT		; GET ADDRESS OF NEXT BLOCK
	JRST	CLLOOP

				; HERE, NB EQUALS BLK
CLFREE:	ADD	NB,FSIZE(BLK)	; GET ADDRESS OF NEXT
	CAML	NB,TAIL(HEAP)	; SEE IF NEXT IS REALLY END
	JRST	CLTAIL
	MOVN	R,ASIZE(NB)	; TEST IF NEXT IS FREE
	JUMPGE	R,CLLOOP	; IN USE, CONTINUE

	PUSHJ	TOP,UNCHN	; UNCHAIN BLK
	MOVE	CNT,FSIZE(BLK)	; GET SIZE OF COMBINED BLOCK
	ADD	CNT,FSIZE(NB)
	PUSHJ	TOP,FREE	; ADD CREATED BLOCK TO CHAIN
	EXCH	BLK,NB		; UNCHAIN SECOND PART
	PUSHJ	TOP,UNCHN
	MOVE	BLK,NB		; RESTORE BLK POINTER
	JRST	CLFREE

CLTAIL:	PUSHJ	TOP,UNCHN	; REMOVE THE BLK
	MOVEM	BLK,TAIL(HEAP)	; RESET THE TAIL POINTER
CLRET:	POP	TOP,SLOT	; RESTORE SLOT NO. OF BLOCK BEING ALLOC'ED
	POP	TOP,CNT	; AND CNT
	POPJ	TOP,

;
;     SUBROUTINE TO UNCHAIN A BLOCK, ENTERED WITH BLK POINTING
;     TO BLOCK TO UNCHAIN
;
UNCHN:	HLRZ	T,FPREV(BLK)	; GET PTR TO PREVIOUS BLOCK
	HRRZ	R,FNEXT(BLK)	; GET PTR TO NEXT BLOCK
	JUMPE	R,.+2		; IF NEXT NONNULL, SET NEXT.PREV = BLK.PREV
	HRLM	T,FPREV(R)
	HRRM	R,FNEXT(T)	; FLIST (SLOT) OR PREV.NEXT = BLK.NEXT
	POPJ	TOP,
;
;     DISPOSE -- OPERATOR TO FREE AN ALLOCATED BLOCK.  CHECKS THAT
;     BLOCK IS IN FACT ALLOCATED AND THAT BLOCK IS IN RANGE.
;     RETURNS A NIL PTR FOR NIL'ING PTR VAR DISPOSED.
;
DSPOS.:
	MOVEI	R1,1		; tick over ARG word
	ADDB	R1,0(TOP)
	MOVEI	R0,@-1(R1)	; EA is addr of record to dispose
	EXCH	PSA,$QFIT(PDA)
	$SAVE	REGSAVE,2,7
	MOVE	EXP1,R0		; put in right place
	MOVEI	BLK,-1(EXP1)	; POINT AT BLOCK DESC WORD
	IFN	DEBUG	<PUSHJ TOP,TELBLK>
	MOVEI	HEAP,@CHEAP	; GET PTR TO HEAP
	JUMPE	HEAP,DISERR	; IF NOT INIT'ED, PTR MUST BE BAD
	CAML	BLK,TAIL(HEAP)	; CHECK THAT PTR IS NOT PAST END OF HEAP
	JRST	DISERR
DISCHK:	CAIGE	BLK,HSIZE(HEAP)	; CHECK IF BLK IN THIS HEAP
	JRST	DISPOP		; NO, CHECK FOR PREVIOUS
	MOVN	CNT,ASIZE(BLK)	; MOVE NEG. ALLOCATED COUNT
	JUMPL	CNT,EFALLOC	; IF THIS IS NEG., BLOCK WAS FREE
	PUSHJ	TOP,FREE
	MOVEI	BLK,377777	; LOAD NIL PTR, TO BE STORED INTO PTR
	$RESTORE REGSAVE,2,7
	EXCH	PSA,$QFIT(PDA)
	POPJ	TOP,

DISPOP:	CAIL	BLK,0(HEAP)	; MAKE SURE NOT IN HEADER
	JRST	DISERR
	MOVEI	HEAP,@LHEAP(HEAP)	; CHECK PREVIOUS FRAME
	JUMPN	HEAP,DISCHK
DISERR:	$FTERROR DISM
DISM:	ASCIZ	/
?	Bad pointer in DISPOSE/

EFALLOC:$FTERROR EFALM
EFALM:	ASCIZ	/
?	Attempt to free freed block/
;
;     SUBROUTINE TO FREE A BLOCK.  ENTERED WITH BLK POINTING
;     TO BLOCK DESC WORD, AND SIZE IN CNT.
;
FREE:	PUSHJ	TOP,CSLOT	; GET SLOT INDEX FOR THIS SIZE BLOCK
	MOVEI	T,FLIST(HEAP)	; SET T TO POINT AT FLIST SLOT
	ADD	T,SLOT
	MOVEI	R,@0(T)		; SET R TO ADDR OF FIRST FREE
	MOVEM	CNT,FSIZE(BLK)	; SAVE SIZE OF BLOCK
	HRRZM	R,FNEXT(BLK)	; BLK.NEXT = FLIST(SLOT)
	HRLM	T,FPREV(BLK)	; BLK.PREV = ADDR (FLIST (SLOT))
	JUMPE	R,.+2		; SKIP IF THERE IS NO NEXT
	HRLM	BLK,FPREV(R)	; NEXT.PREV = BLK
	MOVEM	BLK,0(T)	; SET SLOT TO POINT TO THIS BLOCK
	POPJ	TOP,

;
;     MARK -- OPERATOR TO PUSH A HEAP FRAME.  INITIALIZES A NEW HEAP
;     HEADER AND UPDATES CURRENT HEAP PTR.
;
;
; This code left here, in case eventually needed.
;
;MARK.:
;	EXCH	PSA,$QFIT(PDA)
;	$SAVE	REGSAVE,3,7
;	PUSHJ	TOP,INIT
;	MOVEM	HEAP,HP		; SAVE PTR TO OLD (CURRENT) HEAP
;	IFN	DEBUG	<PUSHJ TOP,TELMAR>
;	MOVEI	HEAP,@TAIL(HEAP)	; PUT NEW (NEXT) FRAME AT TAIL OF OLD
;	PUSHJ	TOP,NEWHP	; INITIALIZE
;	$RESTORE REGSAVE,3,7
;	EXCH	PSA,$QFIT(PDA)
;	POPJ	TOP,
;
;     RELEASE -- OPERATOR TO POP HEAP FRAMES.  TAKES SUPPLIED HEAP
;     POINTER AND CHECKS THAT IT IS VALID.  THEN RESETS CURRENT
;     HEAP POINTER TO THAT HEAP.  MORE THAN ONE HEAP CAN BE UNWOUND.
;
;RLEAS.:
;	EXCH	PSA,$QFIT(PDA)
;	$SAVE	REGSAVE,3,7
;	MOVEI	HEAP,@CHEAP	; BACKWARDS SEARCH FOR CORRECT HEAP
;	IFN	DEBUG	<PUSHJ TOP,TELREL>
;	CAMN	HP,HEAP		; CHECK IF THE SAME AS SUPPLIED
;	JRST	RLOK		; HEAP FOUND
;	MOVEI	HEAP,@LHEAP(HEAP)	; CHECK PREVIOUS ONE
;	JUMPN	HEAP,.-3	; TRY AGAIN
;RLBAD:	$FTERROR RLBADM
;RLBADM:	ASCIZ	/
;?	Invalid HEAP pointer in RELEASE/
;RLOK:	MOVEM	HP,CHEAP	; UPDATE CURRENT POINTER
;	$RESTORE REGSAVE,3,7
;	EXCH	PSA,$QFIT(PDA)
;	POPJ	TOP,
;
;
;     DEBUGGING OUTPUT ROUTINES
;
	IFN	DEBUG	<
TELCNT:	MOVE	R,CNT
	SETZ	T,
	JUMPE	R,TCLOOP
	ROTC	T,3		; REMOVE LEADING ZEROS
	JUMPE	T,.-1
TCLOOP:	ANDI	T,7
	ADDI	T,060
	OUTCHR	T
	JUMPE	R,TELRET	; END OF NUMBER
	ROTC	T,3		; GET NEXT OCTAL DIGIT
	JRST	TCLOOP

TELBLK:	OUTSTR	[ASCIZ/@/]
	MOVEI	T,6		; LOOP COUNT
	MOVSS	BLK		; ADDR IN RIGHT HALF
TBLOOP:	ROT	BLK,3		; PUT NEXT OCTAL DIGIT IN BITS 33-35
	MOVE	R,BLK		; TAKE CHAR(BLK)
	ANDI	R,7
	ADDI	R,060
	OUTCHR	R
	SOJG	T,TBLOOP
	OUTSTR	[ASCIZ/	/]	; TAB
TELRET:	POPJ	TOP,

TELREL:	OUTSTR	[ASCIZ/R/]
	MOVE	BLK,HP
	PUSHJ	TOP,TELBLK
	POPJ	TOP,

TELMAR:	OUTSTR	[ASCIZ/M/]
	MOVE	BLK,HEAP
	PUSHJ	TOP,TELBLK
	POPJ	TOP,	>

	$END	QFIT,INIT
	END
 