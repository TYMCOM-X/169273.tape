


 









                                SI6800

                        BSO SIMULATOR/DEBUGGER

                                 for

                       6800 microprocessors by

                               MOTOROLA
                     (and all compatible devices)

                                  on

                            TYMSHARE, INC.




The material in this document is of a preliminary nature  and  is
subject  to  change  without  notice  or  obligation.  The Boston
Systems Office Inc., assumes no responsibility for any errors  or
omissions  which may appear in this document.  BSO encourages the
reader to comment on this  manual  and/or  the  features  of  the
SI6800 Simulator/Debugger.


           Copyright, The Boston Systems Office, Inc. 1978
                           469 Moody Street
                         Waltham, Ma.  02154
                            (617) 894-7800





                         Updated: 15-March-79
                                                                Page 2


                         GENERAL INFORMATION

This symbolic  simulator/debugger,  one  of  a  family  of  cross
assemblers and simulator/debuggers produced by The Boston Systems
Office,  is  a  powerful  programming  tool   used   to   develop
microprocessor  software.   It  allows  the  user  to  take  full
advantage of a larger computer,  whether  in  a  time-sharing  or
in-house  mode,  thereby  significantly  reducing  the  number of
man-hours spent in program  development.   The  advantages  of  a
larger computer include:

          .Faster processing speeds
          .More powerful editors
          .Higher speed peripherals

Another advantage, rather critical  on  many  projects,  is  that
program  development  and testing may begin before receipt of the
actual target hardware system.

This simulator is itself written  in  assembly  language  and  is
therefore faster, more efficient and hence, much more economical.

The simulator/debugger consists of  three  discrete  systems,  as
described below:

         .Loader - loads standard format object  code  and  reads
         symbols  from  a  listing  file  produced by BSO's cross
         assembler.

         .Simulator - a DECsystem10 program  that  simulates  the
         operation of a virtual microprocessor system.

         .Debugger -  a  symbolic  debugger  "invisible"  to  the
         simulated microprocessor.  It allows the user to examine
         and modify interactively  the  program  in  an  absolute
         and/or  symbolic  mode.   It  also gives the user strong
         control over the step-by-step execution of  his  program
         by   the   use   of   trace  printouts  of  any  of  the
         microprocessor registers or memory locations.


The symbolic instruction set of this  simulator/debugger  is  the
same  as documented in the manuals supplied by the microprocessor
manufacturer.  Mnemonics  exist  for  data  manipulation,  binary
arithmetic, jumps to subroutines, etc.


Please feel free to contact The Boston Systems Office for further
information  on  this or any other microprocessor related product
you require for program development.  BSO  also  has  a  complete
line  of  cross-assemblers for all commercial microprocessors and
will produce custom assemblers,  simulator/debuggers,  and  other
system  software  and  microprocessor  applications on a contract
basis.
                                                                Page 3


                          TABLE OF CONTENTS

SECTION                                                      PAGE


1.    SI6800 Capabilities                                   4

2.    General Operating Instructions                        5

3.    Command Specifications                                6

4.    Initialization                                        8
              Program                                      
              Memory                                       
              Radix Functions                              

5.    Execution Control                                     11

6.    Memory Modification/Display                           13
              Modification                                 
              Display                                      
              Mode Control                                 
              Symbol Control                               

7.    Print Command                                         21

8.    Macros                                                23
              Definition
              Execution
              Conditionals

9.    Break/Trace Functions                                 27
              Break Commands                               
              Trace Commands                               

10.   Input/Output Control                                  33

11.   Command Files                                         35

12.   Debugger Procedure                                    36

13.   Instruction Set                                       37

14.   SI6800 Register Names                                 38
                                                                Page 4


1.0  SI6800 CAPABILITIES     ______ ____________


USER CONFIGURED VIRTUAL 6800 MICROPROCESSOR SYSTEM
         - Simulated   6800   memory,   up   to   full    maximum
         configuration of 64K.
         - Input  and  output  port   definition/simulation   for
         numeric or ASCII.
         - I/O  through  the  user's  terminal  and/or  up  to  9
         DECsystem10 data files.

EXTENSIVE SIMULATION CONTROL
         - Break  points  may  be  defined  at  any  6800  memory
         location.
         - Trace printout of  various  registers  (user-selected)
         can  be  specified  for  any 6800 memory location during
         simulation.
         - Execution  can  be   initiated   for   either   single
         instruction  or multiple instructions and can be stopped
         by the user at any time.
         - Simulated 6800 interrupts  may  be  initiated  at  any
         time.
         -6800  program simulation can be initiated at any memory
         location  with  or  without trace printout even if trace
         points have been set.

EXTENSIVE DEBUGGING FACILITIES
         - Internal 6800 registers or 6800 memory  locations  may
         be examined and/or changed.
         - Contents  of  memory  can  be  displayed  as  symbolic
         instructions, numeric values, or as ASCII characters.
         - Default input and output radices can be explicitly set
         to Binary, Octal, Decimal, or Hexadecimal.
         - Complete user control of  trace  output  format.   The
         contents  of  any of the microprocessor registers can be
         printed as ASCII characters or  Numeric  values  in  the
         default  output  radix  or  in  a specific user selected
         radix.
         - Symbols may be  defined  or  redefined  while  in  the
         Debugger.
         - Standard MOTOROLA 6800 symbolic  instructions  can  be
         used when depositing into memory.
         - Expressions can be evaluated and the  resulting  value
         printed out for the user.
         - Commands to the Debugger can optionally  come  from  a
         file instead of the user's terminal.

BUILT IN 6800 PROGRAM LOADER
         - Full  loader  capability  for  standard  MOTOROLA  Hex
         format object file.
         - Enhanced symbolic capability via access to BSO'S  6800
         cross assembler symbol table listing.

                                                                Page 5


2.0  GENERAL OPERATING INSTRUCTIONS     _______ _________ ____________


To run the 6800 Simulator/Debugger, at the monitor level type:

        -R SI6800         _ ______

The Debugger will respond with the following:

        6800 Simulator Version 3A(16)
        Copyright, The Boston Systems Office, Inc.  1978
        (617) 894-7800
        #

The pound sign prompt (#) indicates that the Debugger is  waiting
for user input.  Usually the first response to the Debugger would
be to set up memory address boundaries  (see  "MEMORY"  command),
and then to load the object file and symbol table output from the
6800 cross assembler (See "LOAD" command).

During the typing of commands or the construction of  macros  the
following  control  characters are in effect as a function of the
operating system:

        (RUBOUT)         Delete one character
        Control-U        Delete entire line
        Control-R        Retype line
        Control-C        Exit to monitor
        Control-O        Supress remaining output to terminal

If Control-C  is  typed  while  simulation  of  the  6800  is  in
progress,  simulation will be stopped and control returned to the
Debugger.  (If printout is in progress, two  Control-C's  may  be
required)

To exit from  simulator/debugger  command  level  and  return  to
monitor, enter "QUIT".

                                 NOTE
        Because  of  a  bug  in  the  TOPS-10  monitor,
        sometimes  a  job will hang in a state (waiting
        for  output  to  be  done  but  no  output   in
        progress)  where no matter how many Control-C's
        are typed, nothing will happen (i.e., no return
        to  the  Debugger).  This only happens if trace
        printout is in progress  when  the  Control-C's
        are  typed.   If this should happen, typing any
        other character will free the  hung  condition,
        and control will return to the Debugger.
                                                                Page 6


3.0  COMMAND SPECIFICATIONS     _______ ______________


Many commands allow ranges of addresses  to  be  specified.   The
following  is the syntax of those range specifications.  Multiple
ranges can be specified by separating each range with a comma.


        {ranges}   ::=   {range}[,{range}...]
        
        {range}    ::=   {expr}
                   ::=   {expr}:{expr}
                   ::=   :{expr}
                   ::=   {expr}:
                   ::=   :


Where                    Means

{expr}           ==      a single address
{expr}:{expr}    ==      Low address to High address
:{expr}          ==      (Lowest defined Program memory address)
                         to High address
{expr}:          ==      Low address
                         to (Highest defined Program memory address)
:                ==      (Lowest defined Program memory address)
                         to  (Highest defined Program memory address)


{expressions} can consist  of  any  symbols  previously  defined,
numeric   contants,   ASCII   constants,   register  symbols  and
operators.

A {symbol} consists of up to 6 alpha-numeric characters  starting
with  a  letter.   A  symbol  must not be one of:  [ A, B, X ] as
these represent registers.

{file specification}
                ::=     dev:filename.ext[project-programmer#]

Numeric constants MUST start with  a  digit  (0  to  9)  and  are
assumed to be in the current input radix unless a radix specifier
is present following the number.

A radix specifier is of the form ^n

Where:       n  := Number between 2 and 16
                := B  -  Binary
                := O  -  Octal
                := D  -  Decimal
                := H  -  Hexadecimal

                                                                Page 7


The contents of any of the micro computer's registers can be used
in  an  expression  by  the use of special register symbols.  The
format is a period followed by the register name.   For  example,
".PC" has the value currently contained in the program counter.

In addition, the special symbol "." (DOT) has the  value  of  the
address  of  the  most  recently EXAMINED location.  When a break
from simulation back to the debugger occurs, "." is automatically
set to the value of the PC.

ASCII Constants - An ASCII constant is represented by a character_____ _________
string  enclosed  in  apostrophes.   The characters will be right
justified, 8 bits per character, with the parity bit (high  order
bit) zero.

Operators - The operators available for constructing  expressions_________
include both the unary and binary operators listed below

      OPERATOR  DESRIPTION
UNARY:  +       positive
        -       negative
        NOT     compliment function
        @       returns contents of memory location (value)
BINARY: +       addition
        -       subtraction
        *       multiplication
        /       division
        EQ      equivalance
        NE      non-equivalance
        LT      less than
        GT      greater than
        LE      less than or equal
        GE      greater than or equal
        AND     logical "AND"
        OR      logical "OR"
        XOR     logical "EXCLUSIVE OR"
        MOD     remainder function
        SHL     shift left
        SHR     shift right

Operators consisting of alphabetic characters must  be  seperated
from  their  operands  by at least one space or tab.  Expressions
will be evaluated according to the following operator precedence,
and from left to right when of equal precedence:

        1)  parenthesized sub-expressions
        2)  Unary +, Unary -, @
        3)  *, /, MOD, SHL, SHR
        4)  +, -
        5)  NOT
        6)  AND, XOR, OR
        7)  NE, GE, LE, GT, LT, EQ
                                                                Page 8


4.0  INITIALIZATION     ______________

4.1  PROGRAM     _______


SI6800 contains an integral MOTOROLA Hex format 6800 object  file
loader.   The  object file can reside in any area on the system's
disk structure.

Since the object file format is standard, any 6800 object program
can  be loaded, simulated, and debugged even if no source file is
available.

LOAD {file specification}

        Load the object file into memory and if present, read the
        symbol information from it.  In order to get symbols from
        the source program, the /D switch must be used with BSO's
        cross  assembler.   If  an  object data load is attempted
        into non-allocated memory, an error  is  generated.   The
        default  extension for the object file, if not explicitly
        stated when the command is given, is ".OBJ".

        #LOAD PROG1
        #LOAD PROG2.XYZ



4.2  MEMORY     ______



When SI6800 is first started the 6800 memory is set  up  to  have
address  boundaries of 0 AND 0FFF^H.  If desired, the memory size
can be redefined with the "MEMORY" command.   Any  references  to
non-existent  6800  memory  will return a value of 0FF^H if read.
Writes to non-existent memory have no effect.

If no arguments follow  the  memory  command,  then  the  current
memory allocations will be printed.

Changing memory allocations has no effect on the contents of  any
memory locations.


MEMORY {ranges}

        Allocate simulated Micro-computer memory  (RAM)  for  the
        indicated ranges of addresses


RAM {ranges}

        Allocate Read/Write memory (same as above MEMORY command)
                                                                Page 9


ROM {ranges}

        Allocate Read Only memory (ROM) for the indicated ranges.


MEMORY

        Show all the current simulated  memory  allocations  (ROM
        and RAM)


ROM

        Show the current Read Only memory allocations


RAM

        Show the current Read/Write memory allocations


NO MEMORY {ranges}
NO ROM {ranges}
NO RAM {ranges}

        Deallocates the specified ranges of memory


        
        #MEMORY 0:0FFF
        #MEMORY
        
                Read only memory (ROM) :
        
                Read/Write memory (RAM) :
        
                        0 to 0FFF
        
        #NO MEMORY 0F:0FFF
        #MEMORY
        
                Read only memory (ROM) :
        
                Read/Write memory (RAM) :
        
                        0 to 0E
        
                                                               Page 10


4.3  RADIX FUNCTIONS     _____ _________


The numbers used by SI6800 will default automatically to  decimal
if no special radix specifier is given.  However, it is sometimes
more convenient to have a default radix other than decimal.   The
"RADIX"  command allows the user to select any radix from 2 to 16
as the default radix for input, output, or both.

RADIX {radix value}

        Set the default input and output radices to the indicated
        value


RADIX IN {radix value}

        Set the default input radix


RADIX OUT {radix value}

        Set the default output radix


RADIX

        Show the current default input and output radices



        {radix value}  :=  number from 2 to 16
                       :=  BINARY
                       :=  OCTAL
                       :=  DECIMAL
                       :=  HEXADECIMAL
        
        
        #RADIX IN 16
        #RADIX OUT D
        #RADIX
        
        Input  Radix:  16
        Output Radix:  10
        
                                                               Page 11


5.0  EXECUTION CONTROL     _________ _______



The GO, PROCEED and STEP commands end the current  command  input
session  and transfer control to the debugger.  Program execution
under the simulator will continue until:

   - a breakpoint is encountered (see BREAK).
   - a proceed count condition is satisfied (see PROCEED).
   - a step count condition is satisfied (see STEP).
   - Control-C is typed by the user.
   - an illegal instruction is fetched for execution.
   - a software halt is encountered.


GO {expression}


   Start simulator execution at the  location  specified  by  the
   expression.  If no location is specified, then begin execution
   with a micro-processor RESET.


   
   #GO 100
   #GO START2
   #GO
   
   
PROCEED {expression}

   Resume simulator execution, proceeding  automatically  through
   the last encountered breakpoint the indicated numberimes.
   If no expression is given, proceed  to  the  next  breakpoint.
   When  the  proceed count on an encountered breakpoint is equal
   to zero, then  a  "PRINT  REASON"  (see  PRINT)  is  executed,
   producing  on  the  terminal,  the  cause of return to command
   level and the value of the program counter.
                                                               Page 12


   
   
   location 0000 contains:      DEC A
   
                        
                        
   12L#BREAK READ REGISTER A
   #BREAK AT 0          (see BREAK command)
   #GO 0
   
   BREAK AT 0           ("BREAK AT 0" is the "REASON")
   PC = 00000
   
   #PROCEED
   
   BREAK READ REGISTER A     ("BREAK READ REGISTER A" is the "REASON")
   PC = 00000             (Second break at same location caused)
                          (by having two different breakpoints)
                          ("hit" on one location, first PROCEED)
                          (still in effect.)


STEP {expression}

   Execute the indicated number of instructions.  Any breakpoints
   encountered  will  be  ignored.   If  no  count is given, then
   execute only one instruction.
   
   #STEP 16
   #STEP
   
                                                               Page 13


6.0  MEMORY MODIFICATION/DISPLAY     ______ ____________________



The user can interactivly display and modify;   the  contents  of
any  location  allocated as read/write memory, the 6800 registers
and the pseudo-registers.  The EXAMINE, DEPOSIT and ZERO commands
are  used  to  modify the contents of memory locations.  Register
contents can  be  modified  with  the  SET  command  (see  SYMBOL
CONTROL).   The  EXAMINE  and  LIST  commands  enable the user to
display memory locations to the terminal;  in addition  the  DUMP
command  can be used to write the contents of memory locations to
a file.




6.1  MODIFICATION     ____________


EXAMINE {expression}

   Examines the specified location  in  Program  memory.   If  no
   location  is given, then the location indicated by the current
   value of "." is opened.

   The debugger then prints the location followed by a slash  "/"
   and  the  contents of that address on the users terminal.  The
   contents will be printed in the current typeout mode (see MODE
   command),  or  if  NORMAL  mode  is  in  effect,  in  the mode
   indicated by the mode flags on that address.

   Then the debugger waits for input from the user.   If  just  a
   {RETURN}  is  typed, the debugger will return to command input
   level.  If only a {LINEFEED} is typed, the  next  location  is
   automatically  examined:   "next" is determined by the content
   of the just closed location.

   If desired, the contents of the location just printed  can  be
   changed  by typing an expression (the low 8 bits will be used)
   or an assembly language instruction;  including optional label
   field.   If  a  {RETURN}  is  then  typed the value(s) will be
   deposited into the location, then the debugger will return  to
   command  input  level.  If a {LINEFEED} is typed, the value(s)
   will be deposited, and then the  next  location  automatically
   examined.

                                                               Page 14


   #EXAMINE 100
   100 / START: CLR A   (User input is now required; if a <cr>)
   #                    (is typed the debugger returns to command)
                        (level.)
   
   #EXAMINE 100
   100 / START: CLR A      (If at this point a <lf> is typed,)
   101 /        NOP        (the next location is examined in)
   #                    (the same manner.)
   
   #EXAMINE 100
   100 / START: CLR A  JMP RESTRT<cr>    (typing in an instruction or)
   #EXAMINE 100                          (an expression deposits this)
   100 / START: JMP RESTRT               (into the examined location.)
   
   #EXAMINE 100
   100 / START: JMP RESTRT INC R0<lf>      (If a linefeed follows the)
   101 /        NOP       CLR R7  <lf>     (entered instruction or)
   102 /        DEC R6  <cr>            (expression; then the values)
                                           (are deposited and the next)
                                           (location is examined.)
   #LIST 100:102
   
   100 / START: INC R0
   101 /        CLR R7  
   102 /        DEC R6
   #
   
DEPOSIT {ranges} = {expression or instruction}

        Deposits the value(s) of the  expression  or  instruction
        into  the  specified  addresses of Program memory.  If an
        expression is given, only the low 8  bits  of  the  value
        will  be  deposited.  For instructions that generate more
        than one byte, the  additional  bytes  are  deposited  in
        succeeding  locations.  The depositing is thus repeatedly
        done until all locations  within  the  ranges  have  been
        done.


        #DEPOSIT 0:100 = FCB 2
        #DEPOSIT 54 = 45-SYMB2
        #DEPOSIT 22 = ADD A #10


ZERO {ranges}

        Zero the indicated memory locations.

        Same as "DEPOSIT [ranges] = 0"


        #ZERO SYMB3
        #ZERO 0F:0FFF
                                                               Page 15


6.2  DISPLAY     _______


LIST {ranges}

        Lists  on  the  user's  terminal,  the  contents  of  the
        indicated  locations in Program memory.  The output is in
        the current typeout mode

        (see MODE command for examples).


DUMP {file specification}/switch, {ranges}

        Dumps the contents of the indicated memory locations to a
        file.   If no file extention is given the file is created
        with a NULL extension.  If the /switch is  not  specified
        the  output  is in Instruction format which is compatable
        as source input to the cross assembler (some editing  may
        be required since the disassembly may not be in the exact
        form desired).  If a switch is specified, the  output  is
        in MOTOROLA 6800 object file format.

        /switch   :=  (none)   - Assembly Instruction format
                  :=  /OBJECT  - Manufacturer object format
                  :=  /PROLOG  - PROLOG prom programmer format
                  :=  /DEBUG   - Cross assembler object format
                                 (/D switch: ON)


                                                               Page 16


        #DUMP TTY:,017E:0184
        
                ORG     17EH
                FDB     2751
                FCB     0
        CLRBEG  LDX     #START
                STX     TEMP3
        
                END
        
        #DUMP TTY:/OBJECT,017E:0184
        
        S00600004844521B
        S10A017E0ABF00CE0100DFFF
        S9030000FC
        
        #DUMP TTY:/PROLOG,017E:0184
        
        0A BF 00 CE 01 00 DF
        
        #DUMP TTY:/DEBUG,017E:0184
        
        S00600004844521B
        S10A017E0ABF00CE0100DFFF
        S9030000FC
        
        >G
        ABSYM   0256
        ACSYM   0543
        BDCW    1170
        CCSYM ...(completes symbol listing)
        
                                                               Page 17


6.3  MODE CONTROL     ____ _______


MODE BYTE
MODE WORD
MODE ASCII
MODE INSTRUCTION

        Sets the debugger typeout mode used when  a  location  is
        examined or listed.


MODE NORMAL

        Causes the debugger to use the mode flags  on  individual
        locations  when  determining  the  mode to be used when a
        location is examined or listed.


MODE BYTE {ranges}
MODE WORD {ranges}
MODE ASCII {ranges}
MODE INSTRUCTION {ranges}

        Sets the mode flags on individual locations to  the  type
        indicated.   In addition to these commands, the flags are
        set up automatically to there correct  value  whenever  a
        deposit  is  made  to  a location.  Initially, all memory
        locations are defined as BYTE type.  Then when an  object
        file is loaded, the type will be changed on each location
        loaded based on the information supplied  in  the  object
        file  from the cross-assembler.  If the /D switch was not
        given when the object file  was  created,  all  locations
        loaded get INSTRUCTION typeout mode by default.


        #MODE BYTE
        #LIST 200:203
        200 /   0A
        201 /   0BF
        202 /   0
        203 /   0CE
        
        #MODE WORD
        #LIST 200:203
        200 /   0ABF
        202 /   0CF
        
        #MODE ASCII
        #LIST 200:203
        200 /   ^J
        201 /   ?
        202 /   ^@
        203 /   N
        
                                                               Page 18


        #MODE INST
        #LIST 200:203
        200 /           CLV
        201 /           STS     0CE
        
        #MODE NORMAL
        #LIST 200:203
        200 /           FDB     0ABF
        202 /           FCB     0
        203 /   LABEL2: LDX     #START
        
        
                                                               Page 19


7.0  SYMBOL CONTROL     ______ _______



The user can create new symbols,  alter  the  value  of  existing
symbols, control thier presense in the symbol tables and allow or
supress thier typeout by the debugger.  User defined symbols  can
function as reference points between debugger commands or macros,
or as a location reference when multiple programs are loaded.


SET {symbol} = {expression}

        Sets the  value  of  the  symbol  to  the  value  of  the
        expression.   If  the  symbol  is  of  the  form:   ( "."
        followed by a register name),  that  register's  contents
        will  be  changed.  When the value of an existing symbol,
        which occurs as a label, is altered, all future  debugger
        references  will  use  the new value of the symbol, while
        all existing symbol references will retain the old symbol
        value.   When a symbol is "SET" typeout of that symbol is
        DISABLED (see below).
        
        
        #SET START = 104
        #SET .PC   = START      (Program counter is now set to 104)
        
        

LOCAL {module name}

        Enable local symbol  usage  from  the  indicated  module.
        Only  one module's local symbols can enabled at any given
        time.  Local symbols always take precedence  over  Global
        symbols of the same name.


NO LOCAL

        Disables usage of all local symbols.  Only global symbols
        can be referenced from the debugger.


                                                               Page 20


KILL {symbol name}

        Removes the symbol from the debugger's symbol table.   If
        the  symbol is defined within the currently enabled Local
        symbol table then that entry will be removed.  Otherwise,
        the symbol will be deleted from the Global symbol table.


KILLALL

        Removes ALL symbols from all Local tables and the  Global
        table.


ENABLE {symbol name}

        Enables debugger typeout of the symbol when referenced.


DISABLE {symbol name}

        Disables debugger typeout of the  symbol.   However,  the
        symbol can still be referenced by the user in expressions
        or instructions.
        
        
        #EXAMINE SYMB2
        13F /   SYMB2:  INC     A<lf>
        140 /           DEC     R0<cr>
        
        #SET SYMB2 = 140
        #EXAMINE 13F
        13F /           INC     A<lf>
        140 /           DEC     R0<cr>
        
        #ENABLE SYMB2
        #EXAMINE 13F
        13F /           INC     A<lf>
        140 /   SYMB2:  DEC     R0<cr>
        
        
                                                               Page 21


8.0  PRINT COMMAND     _____ _______

PRINT {format specification}

        Print using the supplied format specification

PRINT

        Print a {carrige return,line feed} on users terminal


The {format specification} consists of  any  combination  of  the
following special items.

        'text' or "text"

                The inclosed text is printed on the terminal

        [expression]

                The 16 bit value of the expression is printed  in
                the current output radix

        REGISTER

                The contents of the indicated register is printed
                in the current output radix

        ^n

                Changes  the  default  output   radix   for   the
                remainder of the output

        [expression]^n

                Prints the value  of  the  expression  using  the
                indicated radix

        REGISTER^n

                Prints the contents of  the  register  using  the
                indicated radix

                Where:
                        n := Number between 2 and 16
                          := A  -  ASCII
                          := B  -  Binary
                          := O  -  Octal
                          := D  -  Decimal
                          := H  -  Hexadecimal

        Everything other than the above items will be printed  on
        the  users terminal (except the first character after the
        "PRINT" ).
                                                               Page 22


        REASON

                Prints the cause  of  the  most  previous  BREAK,
                TRACE  or  DO,  which caused the execution of the
                macro containing this command or which caused the
                return  to  the  debugger  command level.  "PRINT
                REASON" is valid only within a macro.


FPRINT [channel], [format specification]

        This command is the same as the  "PRINT"  command  except
        that output is to the file on the indicated channel.


EVALUATE {expression or instruction}

        Evaluates the expression or  instruction  and  print  the
        resultant value or values on the users terminal.
        
        
        #PRINT "text"
        text
        
        #PRINT " PC =" PC
         PC =  014F
        
        #PRINT [9999]^B
        10011100001111
        
        #FPRINT 1,TRACEF.LST
        
        #EVALUATE START
        104
        
        #EVALUATE 200+100*2     (Radix is decimal)
        400
        
        #EVALUATE .SP
        003F
        
        
                                                               Page 23


9.0  MACROS     ______



Macros allow logical sets of debugger commands to be  defined  by
the  user  and  subsequently be executed on call, thoroughout the
debugging session.  Macros can be defined to accept arguments and
conditionally   execute   routines.    These  capabilities  allow
creation of macros  to  perform  generalized  functions  such  as
input/output   device   simulation,   debugger   screen  control,
simulated memory search and execution of other macros.



9.1  DEFINITION     __________


MACRO {macro name}(arguments)

        Defines or redefines a macro.  The debugger  then  begins
        to  gather the set of commands to be associated with this
        macro.  This is indicated by the "##" prompt  instead  of
        the  usual "#" prompt.  As commands are accepted from the
        user, they are stored in the macro definition rather than
        being  executed  immediately.   The  only command that is
        checked for is "ENDM" which  terminates  the  definition.
        MACRO commands may be nested.





9.2  EXECUTION     _________


[macro name] (arguments) DO {macro name}(arguments)

        These commands cause the debugger commands  contained  in
        the  specified  macro  to  be executed with the arguments
        substituted.  The macro is expanded once.


DO {macro name}(arguments) REPEAT {expression}

        Causes the named  macro  to  be  expanded  the  indicated
        number of times.


DO {macro name}(arguments) READ MEMORY {location}
DO {macro name}(arguments) WRITE MEMORY {location}
DO {macro name}(arguments) READ,WRITE MEMORY {location}

        Causes the commands in the named  macro  to  be  executed
        whenever   the  location  specified  is  accessed  during
        simulation in the indicated manner.
                                                               Page 24


DO {macro name}(arguments) READ REGISTER {registername}
DO {macro name}(arguments) WRITE REGISTER {registername}
DO {macro name}(arguments) READ,WRITE REGISTER {registername}

        Commands in the named macro will be executed whenever the
        register  specified  is accessed during simulation in the
        indicated manner.


NO DO READ MEMORY {location}
NO DO WRITE MEMORY {location}
NO DO READ,WRITE MEMORY {location}

NO DO READ REGISTER {registername}
NO DO WRITE REGISTER {registername}
NO DO READ,WRITE REGISTER {registername}

        Removes any  DO  of  a  macro  on  the  indicated  memory
        location or register.


MLIST

        Turns on  listing  of  macro  expansions  on  the  user's
        terminal.


NO MLIST

        Turns listing of macro  expansions  off  (default).   Any
        output  produced  by  the commands contained in the macro
        will still appear on the user's terminal.
                                                               Page 25


A program to be debugged might  operate  interactively  with  the
user's  terminal.   The  following commands and macros illustrate
the use of the input/output commands,  the  DO  command  and  the
MACRO command to simulate program I/O.  The user program has been
set up to read from location 1000, one charactor at a  time,  and
to write to location 1001.
   
   
   
   #MACRO TTYIN                    (First define the I/O macros)
   ##READ 1,INBUFF                 (Read a character into symbol "INBUFF")
   ##DEPOSIT 1000=INBUFF           (Deposit the value of "INBUFF" into)
   ##ENDM                          (6800 memory.)
   
   #MACRO TTYOUT
   ##WRITE 2,@1001                (Output the value in 1001 to channel 2)
   ##ENDM
   
   #OPEN 1,TTY:/INPUT:NUMERIC   (Open input/output channels)
   #OPEN 2,TTY:/OUTPUT:NUMERIC
   
   #DO TTYIN READ MEMORY 1000   (Causes the debugger to execute the)
   #DO TTYOUT WRITE MEMORY 1001 (read/write macros when the I/O)
                                (memory locations are read or written.)
   
   
   
   
                                                               Page 26


9.3  CONDITIONALS     ____________


IF {expression}

        If the expression has a non-zero result, then execute the
        following  (up  to ELSE or ENDIF) commands.  This command
        is only available within macros.


ELSE

        Invert the conditional execution of commands.


ENDIF

        End of conditional.

STOP

        Return to debugger command level.  If  simulation  is  in
        progress,  do  not  automatically  resume after the macro
        expansion is finished.  Any  remaining  macro  expansions
        will be skiped.
                                                               Page 27


10.0  BREAK/TRACE FUNCTIONS      ___________ _________



Break/Trace points allow the user to implement specific  debugger
functions  when  selected  positions  in  memory or registers are
accessed.  These Break/Trace points can be  defined  to  function
only   on  read,  write  or  execute  modes  of  access,  or  any
combination of these.  The .BREAK and .TRACE macros are  executed
by  default  but  Break/Trace  points  can  alternatly  be set to
execute a user defined macro.



10.1  BREAK COMMAND      _____ _______


Breakpoints allow the user to stop 6800 simulation  automatically
at strategic points.  Any number of breakpoints are allowed to be
set on the simulated  6800  memory.   When  the  program  counter
reaches  an  address  which  contains a breakpoint, simulation is
stopped, the macro .BREAK is executed and control is returned  to
the user.
The initial format of .BREAK is:


        PRINT REASON    (see PRINT REASON)
        PRINT " PC=" PC
        STOP


                              NOTE

               When a breakpoint causes  a  return
               to the debugger, the instruction at
               that  location  has  not  yet  been
               executed.


These commands affect the overall breakpoint system  and  do  not
affect the individual breakpoints.


BREAK ON

        Break at each instruction


BREAK ENABLE

        Break at breakpoints


BREAK DISABLE
                                                               Page 28


        Disable breaking at breakpoints


BREAK OFF

        Never break at breakpoints (same as BREAK DISABLE )


These commands set the various forms of breakpoints and thus make
breakpoint entries


BREAK READ MEMORY {ranges}
BREAK WRITE MEMORY {ranges}
BREAK EXECUTE MEMORY {ranges}

        Sets the indicated  type  of  breakpoints  on  the  given
        ranges  of  memory  addresses.   If more than one type of
        break is wanted on locations, the keywords  READ,  WRITE,
        and  EXECUTE  may  be  combined  by  separating them with
        commas  (no  spaces),  i.e.   BREAK   READ,WRITE   MEMORY
        {ranges}.


BREAK AT {ranges}

        Same as BREAK EXECUTE MEMORY {ranges}


BREAK READ REGISTER {register name}
BREAK WRITE REGISTER {register name}

        Sets breakpoints on the specified registers.


BREAK DO macro(args)

        Sets up the indicated macro to  be  executed  whenever  a
        breakpoint occurs.  The default macro executed on a break
        is the ".BREAK" macro.



                                                               Page 29


The following commands remove breakpoints:


NO BREAK READ MEMORY {ranges}
NO BREAK WRITE MEMORY {ranges}
NO BREAK EXECUTE MEMORY {ranges}

        Removes  the  indicated  type  of  breakpoint  from   the
        specified locations.  If other types of breakpoints exist
        on the locations, they will  be  unaffected.   Also,  the
        keywords  READ,  WRITE,  and  EXECUTE  can be combined by
        separating with commas (no spaces are allowed).


NO BREAK AT {ranges}

        Same as NO BREAK EXECUTE MEMORY {ranges}


NO BREAK READ REGISTER {register name}
NO BREAK WRITE REGISTER {register name}

        Removes breakpoints from the specified register


        #BREAK READ MEMORY 0:204
        #BREAK WRITE REGISTER PC
        #BREAK AT 10F
        #NO BREAK 344:3FF
        #BREAK DO MAC1
                                                               Page 30


10.2  TRACE COMMANDS      _____ ________


Tracepoints allow the user to enable trace  printout  selectively
as  the  instructions  at specific memory locations are executed.
Like breakpoints, any number of tracepoints can be set.   When  a
6800  instruction  is executed from a location where a tracepoint
is set, the macro .TRACE is executed.
The initial content of .TRACE is:


        PRINT /PC       INST    A B  X  SP CC


                              NOTE

               All trace output is done after  the
               instruction   has   been  executed.
               With the exception of the "PC", the
               contents   of   all  registers  are
               displayed as  they  are  after  the
               instruction  has  been  done.   The
               value of the "PC" is always printed
               during   trace  output  as  it  was
               before the instruction was done.


These commands affect the overall  tracepoint  system  and  don't
affect the individual tracepoints.


TRACE ON

        Trace at each instruction


TRACE ENABLE

        Trace at tracepoints


TRACE DISABLE

        Disable traceing at tracepoints


TRACE OFF

        Never trace at tracepoints (same as TRACE DISABLE )


These commands set the various forms of tracepoints and thus make
tracepoint entries
                                                               Page 31


TRACE READ MEMORY {ranges}
TRACE WRITE MEMORY {ranges}
TRACE EXECUTE MEMORY {ranges}

        Sets the indicated  type  of  tracepoints  on  the  given
        ranges  of  memory  addresses.   If more than one type of
        trace is wanted on locations, the keywords  READ,  WRITE,
        and  EXECUTE  may  be  combined  by  separating them with
        commas  (no  spaces),  i.e.   TRACE   READ,WRITE   MEMORY
        {ranges}.


TRACE AT {ranges}

        Same as TRACE EXECUTE MEMORY {ranges}


TRACE READ REGISTER {register name}
TRACE WRITE REGISTER {register name}

        Sets tracepoints on the specified registers.


TRACE DO macro(args)

        Sets up the indicated macro to  be  executed  whenever  a
        tracepoint occurs.  The default macro executed on a trace
        is the ".TRACE" macro.



                                                               Page 32


The following commands remove tracepoints:

NO TRACE READ MEMORY {ranges}
NO TRACE WRITE MEMORY {ranges}
NO TRACE EXECUTE MEMORY {ranges}

        Removes  the  indicated  type  of  tracepoint  from   the
        specified locations.  If other types of tracepoints exist
        on the locations, they will  be  unaffected.   Also,  the
        keywords  READ,  WRITE,  and  EXECUTE  can be combined by
        separating with commas.


NO TRACE AT {ranges}

        Same as NO TRACE EXECUTE MEMORY {ranges}


NO TRACE READ REGISTER {register name}
NO TRACE WRITE REGISTER {register name}

        Removes tracepoints from the specified register


        #TRACE EXECUTE MEMORY 200:300
        #TRACE READ SP
        #NO TRACE AT 0:300
        #NO TRACE WRITE REGISTER A
                                                               Page 33


11.0  INPUT/OUTPUT      ____________



Each input and output  to  the  simulated  program  must  have  a
simulator  channel  assigned to it and a user defined macro to be
executed when the program produces  an  I/O  request.   The  OPEN
command  assigns the channel and defines its use.  The READ/WRITE
commands are used in conjunction with macros to simulate  program
I/O (see DO command).


OPEN {channel number},{file specification}/switch

   Opens  the  indicated  file  on  the  channel.   The   /switch
   indicates  whether  the file is to be read or written, and the
   interpritation of it's contents.  The supplied channel  number
   must  be  in  the  range  of  1  to  9.   If a file is already
   associated with the given channel, then an  error  message  is
   printed.

   One of the following switches must be  present  following  the
   filename:

       /INPUT:val    -   Input will be done from the file. The file
              must already exist else an error is generated.
       
       /OUTPUT:val   -   Output will be done to this file. If the file
              previously existed, the old version will
              be deleted when the file is closed.
       
       /APPEND:val   -   Output to this file. If it already exists,
              append subsiquent output to the end of the
              existing file rather than creating a new file.
              If a file of this name doesn't exist, will
              create a new file.
       
       One of these values must be present with the supplied switch:
       
       :ASCII    -   File consists of ASCII characters (7 bit characters)
              packed 5 per PDP10 word. When read, 8 bits are
              returned with the high bit always 0. On a write,
              the high bit is ignored.
       
       :NUMERIC  -   File is ASCII type. However reads and writes
              handle up to 16 bit numbers rather than the
              individual characters. Only one number per line
              of the file is allowed.
       
       :BINARY   -   File of 36 bit words. Each 16 bit value is stored
              right justified in a single word of the file.


                                                               Page 34


CLOSE {channel number}

        Closes the file on the given channel.


READ {channel number},{symbol name}

        Reads the next item from the file on the channel into the
        value  of  the  given symbol.  The symbol can be any user
        defined symbol or any of the special symbols  (.REG)  for
        the registers.


WRITE {channel number},{expression}

        Writes the value of the given expression to the  file  on
        the channel.
        
        
        #OPEN 1,TTY:/INPUT:NUMERIC
        #OPEN 4,DATA2.OBJ[100,201]/APPEND:BINARY
        #CLOSE 2
        #READ 3,SYMB3
        #WRITE 2,0FFF1
        
        
                                                               Page 35


11.1  COMMAND FILES      _______ _____


Command files permit logical groups of commands or macros  to  be
externally created and subsequently executed with a single CMDFIL
command.  Any command set which is likely to be executed often or
is   of   sufficient   size  to  require  editing,  warrants  its
construction as a command file.  As an example  a  set  of  LOAD,
MEMORY,  input/output  simulation  macros  and  Break/Trace point
initialization commands could be the contents  of  a  "start  up"
command file for debugging a certian program.

CMDFIL {file specification}

        Take commands from the  indicated  file  instead  of  the
        users  terminal.   The  file  should  contain commands in
        exactly the same format as those commands typed  directly
        from  the  users terminal.  The default extention for the
        command file if not explicitly stated when the command is
        given is ".CMD".


CLIST

        Causes commands from a command file to be listed  on  the
        user's terminal as they are read from the command file.


NO CLIST

        Turns off command file listing (default).
        
        
        #CMDFIL READER.XYZ
        #CMDFIL WRITER
        
        
                                                               Page 36


12.0  DEBUGGER PROCEDURE (ONE INSTRUCTION)      ________ _________ ____ ____________


     1.         Test simulate to determine places and assicoated 

                modes of access.


     2.         Check for breakpoints.


     3.         Check for DO READ flags.


     4.         Execute actual simulation (registers changed).


     5.         Check for DO WRITE flags.


     6.         Check for tracepoints.


     7.         Update:  PC with NPC, INST with NINST.



                                                               Page 37


13.0  INSTRUCTION SET      ___________ ___


The  following  6800  mnemonics  represent  the  instruction  set
supported  by  SI6800.   A  detailed  explanation  of each may be
obtained  by  referring  to  the  microprocessor   manufacturer's
programming manual.

            ABA     CLC     PSH
            ADC     CLI     PUL
            ADD     CLR     ROL
            AND     CLV     ROR
            ASL     CMP     RTI
            ASR     COM     RTS
            BCC     CPX     SBA
            BCS     DAA     SBC
            BEQ     DEC     SEC
            BGE     DES     SEI
            BGT     DEX     SEV
            BHI     EOR     STA
            BIT     INC     STS
            BLE     INS     STX
            BLS     INX     SUB
            BLT     JMP     SWI
            BMI     JSR     TAB
            BNE     LDA     TAP
            BPL     LDS     TBA
            BRA     LDX     TPA
            BSR     LSR     TST
            BVC     NEG     TSX
            BVS     NOP     TXS
            CBA     ORA     WAI

The following pseudo-ops may also  be  used  whenever  an  opcode
mnemonic is allowable.

            FCB     -   8-bit bytes 
            FDB     -   16-bit words 
            FCC     -   ASCII text
                                                               Page 38


14.0  SI6800 REGISTER NAMES      ______ ________ _____


6800 Registers which may be set, evaluated or printed:

A         8 bit accumulator *
B         8 bit accumulator *
X         16 bit index register *
SP        16 bit stack pointer *
PC        16 bit program counter
CC        8 bit condition code register
N         Negative condition bit
Z         Zero condition bit
V         Overflow condition bit
C         Carry condition bit
H         Half carry condition bit
I         Internal 6800 interrupt enable bit


* These are the only registers which can have
Breakpoints/Tracepoints/Do-commands set for read and/or write.

Pseudo registers which may be set, evaluated or printed:

NPC       Contains pointer to next instruction location
IRQ       Interrupt register
NMI       Non-maskable interrupt register
IPNT      Interrupt vector address
ITIME     Instruction cycle time
ETIME     36 bit elapsed time counter
EOF       End of file indicator


Special items for "PRINT" command only:

CR        Generates a new line on output
          (used to cause multiple line trace)
INST      Shows the current instruction mnemonic
NINST     Shows the next instruction mnemonic
REASON    Shows the reason for the last break



                 THE BOSTON SYSTEMS OFFICE, INC.
                  PROBLEM AND SUGGESTION REPORT


If you have any difficulty with BSO software,  if  you  note  any
errors  in  this  manual, or if you have any general suggestions,
please feel free to call us, or  mail  in  this  form  with  your
comments.



Product:                                       Version:
-----------------------------------------------------------------
Reported by:                                   Date:
-----------------------------------------------------------------
Company:                                       Phone:
-----------------------------------------------------------------
Address:
-----------------------------------------------------------------
Host computer/operating system:
-----------------------------------------------------------------

Description of bug or comments:
-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------


           Please return, along with terminal sessions
                 and listings, if available, to:

                 The Boston Systems Office, Inc.
                        469 Moody Street
                  Waltham, Massachusetts  02154
                         (617) 894-7800



                    DO YOU LIKE THIS MANUAL??



BSO  is  constantly  working  to  improve  the  quality  of   our
documentation.   If  you have any constructive comments regarding
this or any BSO publication, we would appreciate it if you  would
take  a few moments to jot them down in the space below, and then
mail the form to us at 469 Moody Street,  Waltham,  Massachusetts
02154.  Our customers' comments are always appreciated!

Title of document:
-----------------------------------------------------------------
Date of document revision:
-----------------------------------------------------------------
Your name:                                  Today's date:
-----------------------------------------------------------------
Company:                                    Phone:
-----------------------------------------------------------------
Address:
-----------------------------------------------------------------

Please rate this manual in the following categories with a number
between 0 (worst) and 5 (best):

Overall Readability: _________

Organization:        _________

Accuracy:            _________


Please  write  any  general  comments below.  If you require more
space, feel free to attach as many additional pages as you  wish.
Thanks for your help!
  e  