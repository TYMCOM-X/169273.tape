


 





                             CA8085

                  BSO Absolute Cross Assembler
                     (with Cross Reference)

                               for

                  8080/8085 Microprocessors by

                              INTEL
                  (and all compatible devices)

                               on

                         TYMSHARE, INC.










          This user's manual is intended as a  thorough
          product  description.   It is, to the best of
          our knowledge, complete and accurate.

          The Boston Systems Office does not,  however,
          warrant  this  document's accuracy, nor shall
          it be held responsible for errors of  content
          or   omission.   The  Boston  Systems  Office
          reserves the right to  update  this  document
          without prior notification.




         Copyright, THE BOSTON SYSTEMS OFFICE, INC. 1979
                        469 MOODY STREET
                       WALTHAM, MA  02154
                         (617) 894-7800


                        Updated JUNE-6-79
                                                           Page 2


                       GENERAL INFORMATION

The Boston Systems Office offers a family of extremely  effective
microprocessor   software   development  tools.   These  products
(cross-assembler, cross-compilers, simulator/debuggers, and other
products)  allow the user to take full advantage of the speed and
versatility of  microprocessor  program  development  on  a  host
computer,  thereby  significantly reducing the number of hours or
days spent in program development.   The  advantages  of  a  host
system  versus  a  microprocessor-based  development  programming
system include:

          - Faster processing speeds
          - More powerful editors
          - Multi-user capability
          - Higher speed peripherals
          - Multi-microprocessor capability on one system
          - Lower station cost in multi-user configurations

BSO/PASCAL is a new product of the BSO line  of  cross-compilers,
which has been specially optimized for microprocessor application
design.  Its benefits include faster software development through
the  use of a high-level language and a much higher percentage of
error-free code  because  of  PASCAL's  particular  capabilities.
Other advantages are simplified program maintenance due to better
program readability and a  recompilation  capability  which  will
permit  one source language program to be compiled for any number
of  suitable  microprocessors.   BSO/PASCAL  supports   interrupt
handling   instructions,   record-oriented   variables,  enhanced
microprocessor statements, extensive compiler-generated  comments
and many other features.

BSO's cross assemblers, unlike most other similar  products,  are
written  in  the  assembly  language  of the host computer.  They
generally require no more than 10-18K words of memory to assemble
any  program.   The  comprehensive  program  symbol  table can be
expanded for any program requirement or selectively condensed for
a  smaller  system,  as  required.  These assemblers require much
less  CPU  time  to  execute,  even  at   this   reduced   memory
requirement,  than manufacturer-supplied cross-assemblers written
in higher-level languages such as  Fortran.   Benchmarks  against
competitive  cross-assemblers  in  a timesharing environment have
shown that time  savings  of  up  to  50%  are  common.   Similar
efficiencies   can  also  be  realized  when  using  an  in-house
computer.

                                                           Page 3


The instruction set accepted by each cross-assembler is the  same
as  documented  in  the  assembly language manual supplied by the
microprocessor   manufacturer.    Mnemonics   exist   for    data
manipulation,  binary  arithmetic, jumps to subroutines, etc.  In
addition, all of  BSO's  cross-assemblers  have  full  macro  and
extended  conditional  assembly  capabilities.   The  object file
produced can then be processed by BSO's compatible  cross-linkage
editor, along with other relocatable and absolute object modules.
The assembled code can then be loaded directly  to  any  standard
peripheral  device  on  the  system.   The  absolute  load module
produced by the cross-linkage editor  can  be  punched  on  paper
tape,  loaded into a PROM burner, or downline loaded into memory,
depending on the available facilities.   The  assembler  is  also
capable  of  producing  an  object  format with additional symbol
information,  suitable  for  input  to  one  of  BSO's  companion
integrated symbolic simulator/debuggers.

Cross assemblers are now available for  all  major  manufacturers
including   Advanced   MicroDevices,   AMI,  Fairchild,  Fujitsu,
Hitachi,  Intel,  Intersil,  MOS  Technology,  Mostek,  Motorola,
National  Semiconductor, NEC, RCA, Rockwell, Signetics, Synertek,
Thomson-CSF, Texas Instruments, Zilog and others.

Please feel free to call  the  sales  department  of  the  Boston
Systems  Office  at (617) 894-7800 for further information on any
microprocessor including those not mentioned above.
                                                           Page 4


                        TABLE OF CONTENTS

Section   Contents

1.0       OPERATING INSTRUCTIONS
1.1       Using the Listing and Object files
1.2       Switch Summary
1.3       Listing Options
1.3.1          Omit Symbol Table (/T)
1.3.2          Cross-Reference Mode (/X)
1.4       Object file options
1.4.1          Debugger Support (/D)
1.5       Sample Commands

2.0       SOURCE PROGRAM PREPARATION
2.1       Program Entry
2.2       Program Format
2.2.1          Label Field
2.2.2          Instruction Field
2.2.3          Operand Field
2.2.4          Comment Field
2.3       Expressions
2.3.1          Symbols
2.3.2          Numeric Constants
2.3.3          ASCII Constants
2.3.4          Expression Operators

3.0       INSTRUCTION SET

4.0       ASSEMBLER DIRECTIVES (PSEUDO-OPS)
4.1       Conditional Assembly
4.2       The BSO Macro Facility
4.2.1          Nesting Of Macros
4.3       Listing Control
4.3.1          LIST/NLIST
4.3.2          TITLE
4.3.3          PAGE
4.3.4          FORMLN

                           (continued)
                                                           Page 5


                  TABLE OF CONTENTS (continued)

Section   Contents


5.0       OBJECT FILE FORMAT
5.1       Standard Absolute Object file 

6.0       ERROR HANDLING

7.0       SUMMARY OF DIFFERENCES

APPENDICES:

I         USER PROBLEM AND SUGGESTION REPORT

II        DO YOU LIKE THIS MANUAL?? (User manual suggestion and
          correction report)
                                                           Page 6


1.0 OPERATING INSTRUCTIONS

To run the 8085 cross assembler, at the monitor  (system)  level,
type:

     -R CA8085

The assembler will respond with the following:

     8085 Cross Assembler version 3A(44)
     Copyright, The Boston Systems Office, Inc. 1979
     (617) 894-7800
     Type "/H" for help
     *

By typing "*", the  assembler  is  indicating  its  readiness  to
accept  a  command  and perform an assembly.  To this prompt, you
should type a command of the form

*PROG.OBJ,PROG.LST=PROG.SRC/X/Y...

The filenames shown above (PROG.OBJ, PROG.LST, PROG.SRC) are used
for example purposes only, and any acceptable file specifications
may be used.

PROG.OBJ and PROG.LST are the names of the object and list  files
the assembler will create, respectively.  If either of these file
specifications is  omitted,  the  associated  file  will  not  be
generated.

If a list file is desired without an  object  file,  the  command
string  should  start  with  a  comma,  followed by the list file
specification, i.e., if only the  object  file  is  omitted,  its
trailing comma must still be included.

If only an object file is desired, without a list  file,  neither
the comma nor the list file specification need appear on the left
side of the "=" sign in  the  command  string  (see  examples  in
section 1.5).

The source program to be assembled is specified on the right side
of the "=" sign.  A source file is always required.

The source file is optionally  followed  by  "switches"  for  the
command string.  These take the form of a slash "/" followed by a
single letter (shown in the above example by "/X and /Y"), and as
many of these may be specified as desired (including none).  Each
switch slightly modifies the operation  of  the  assembler.   The
available switches are detailed in section 1.2.

If extensions are omitted from the  file  specifications  in  the
command string, the following assumed default extensions apply:

Object file     .OBJ
List file       .LST
Source file     .SRC
                                                           Page 7


1.1 USING THE LISTING AND OBJECT FILES

The listing and object files created are in ASCII formats and may
be   printed  or  punched  by  using  standard  operating  system
commands.  Any normal system commands may also be  used  to  move
these  files from device to device.  Consult your computer system
user's guide for more details.



1.2 SWITCH SUMMARY

The following switches are available in this assembler:

     /H  "Help".  Ignore command line and print helpful
         information.
     /N  Do not print assembly errors on user's terminal
     /P  Indicate the start of pass 2 on the terminal
     /T  No symbol table in listing (see section 1.4)
     /D  Debug switch; include symbol information in object file
         (for use by BSO symbolic simulator/debuggers)
     /X  Cross reference mode.  Produces a symbol table in the
         list file which includes cross reference information.
                                                           Page 8


1.3 LISTING OPTIONS

1.3.1 OMIT SYMBOL TABLE (/T)

The listing normally contains a table of user symbols  and  their
values.   This  table  can  be  omitted  by  specifying /T in the
command line.

1.3.2 CROSS-REFERENCE MODE (/X)

By adding the /X switch to the end of  the  command  string,  the
user  instructs the assembler to operate in cross-reference mode.
In this mode, the symbol table produced contains, in addition  to
the symbol names and values, the cross reference information.



1.4 OBJECT FILE OPTIONS

1.4.1 DEBUGGER SUPPORT (/D)

When the user adds the /D  switch  to  the  end  of  the  command
string,  the  assembler  includes  its symbol table in the object
module.  This symbol table is subsequently read by BSO's symbolic
simulator/debugger,  which  then  has access to the user's symbol
definitions.

This information is merely appended to the end  of  the  absolute
load  module  (object  file)  generated  by  the  assembler.  The
simulator recognizes the sepcially formated  information  at  the
end  of the file and loads the and loads the symbols accordingly.
Note that this information may or may not be considered a serious
error   by  various  manufacturer-supplied  loaders  and/or  PROM
burners.
                                                           Page 9


1.5 SAMPLE COMMANDS

The following examples are provided as illustrations of the sorts
of  commands normally given to the assembler.  Commentary text is
provided with each one.   Only  the  command  strings  are  shown
below;   note  that  they  are  always  typed  in response to the
assembler's prompt, "*".

     A.OBJ,A.LST=A.SRC
          Assemble source  file  A.SRC,  generating  object  file
          A.OBJ  and  list file A.LST.  The object and list files
          are in standard format.  Assembly errors appear on  the
          user's terminal and in the list file.

     A,A=A
          Same  effect  as  above  command  string,  because   of
          defaults.

     A=A
          Assemble source  file  A.SRC,  generating  object  file
          A.OBJ.  No list file is generated.  Erroneous lines are
          printed on the user's terminal.

     ,A=A
          Assemble source file A.SRC, generating list file A.LST.
          No  object  file.   Assembly  errors appear both in the
          list file and on the user's terminal.

     FOO,BAR=PROG/X/N
          Assemble source  program  PROG.SRC,  generating  object
          file FOO.OBJ and cross reference of symbols in the list
          file BAR.LST.  Erroneous lines appear only in the  list
          file;  they are not typed on the user's terminal.
                                                          Page 10


2.0 SOURCE PROGRAM PREPARATION

2.1 PROGRAM ENTRY

In general, source programs for this assembler are placed on  the
host  computer  disk either by use of a text editor program or by
copying an existing source program from paper tape, punch  cards,
magnetic  tape,  etc.   Once  a  program  resides on disk, a text
editor program can be used  to  alter  or  correct  the  file  in
preparation  for  assembly.  Consult the operating system manuals
supplied with your computer for further  information  on  copying
and editing files on your system.

2.2 PROGRAM FORMAT

Each source program for the 8085 consists  of  several  lines  of
ASCII   characters.   Each  line  must  be  no  longer  than  132
characters;  longer lines will be truncated and produce a warning
message from the assembler.

Lines beginning  with  a  semicolon  (";")  will  be  treated  as
comments.   Blank  lines  will  be  ignored.   Each  source  line
(statement) consists of four parts or "fields":  The label field,
the  instruction  field, the operand field and the comment field.
These are described below.

2.2.1 LABEL FIELD

The first field of a source program line  is  called  the  "label
field".   If  not  blank,  the  field contains a statement label,
which identifies a particular location in the program.   A  label
consists  of  from  1  to 6 alphanumeric characters, the first of
which must be a letter (A-Z).  The remaining  characters  may  be
letters  or  digits  (0-9).   No label may duplicate a label used
elsewhere in the same program.

All labels must appear in column  1  (the  left  margin)  of  the
source  program  line.   A  line  containing  only  a  label will
generate no code, but will define the label to be  equal  to  the
next available address.

The label field is also used (and  is  mandatory)  in  statements
with  MACRO,  EQU  or SET directives.  In this case, the label is
the name of the symbol being equated to a value or  the  name  of
the  MACRO  being  defined  (see  section  4.2 for more details).
Except in the case of these three directives, the label field  is
optional  and  may be omitted.  The label field is followed by at
least one colon, space or tab.

2.2.2 INSTRUCTION FIELD

The  instruction  field  must  contain  either   an   instruction
mnemonic,  an  assembler  directive (pseudo-op), or the name of a
user-defined macro (i.e., a macro call).  This field is  followed
by at least one space or tab and must not begin in column one.

                                                          Page 11


2.2.3 OPERAND FIELD

The operand field, if  required,  may  consist  of  one  or  more
operands  separated  by  commas.   An  operand  may  be  an ASCII
constant, numeric expression, character string, or the name of an
8085  register.   The expected contents of this field will depend
on the instruction, directive, or macro  name  appearing  in  the
instruction field.

2.2.4 COMMENT FIELD

This field is optional;  it will be  ignored  by  the  assembler.
All  comments  will  appear  in  the  listing,  but  will  not be
assembled.  The comment field is delimited from the  operand  and
instruction fields by a semicolon (;).

2.3 EXPRESSIONS

Expressions can be made up of user symbols and numeric and  ASCII
constants.   These elements may be combined by various operators,
as detailed in section 2.3.4.

2.3.1 SYMBOLS

Any alphanumeric symbol which has been used as a statement  label
or equated to a value may be used in an expression.  In addition,
a dollar sign ("$") may be used to denote  the  location  of  the
first byte of the current instruction.

2.3.2 NUMERIC CONSTANTS

Numeric constants may be specified as binary, octal, decimal,  or
hexadecimal  constants  by  following the number with a character
indicating the radix used.  The suffix characters used are  shown
below:

     B - BINARY                         0101B
     O or Q - OCTAL                     015O OR 015Q
     D or . - DECIMAL                   19D or 19.
     H - HEXADECIMAL                    0F8H

Note that hex constants using an "H"  suffix  must  always  start
with  a  numeric  digit  (0 if necessary) in order to distinguish
them from user symbols.  Numbers without any indication of  radix
(no suffix character) will be considered to be in decimal.

2.3.3 ASCII CONSTANTS

An ASCII  constant  is  represented  by  one  or  two  characters
enclosed  in  apostrophes.  This construct produces the seven-bit
ASCII value(s) of the character(s)  specified.   Characters  with
octal values greater than or equal to 40 (space) are permitted.

                                                          Page 12


2.3.4.  EXPRESSION OPERATORS

The operators available for constructing expressions include both
the unary and binary operators listed below:

   UNARY:  +       BINARY:    +     XOR   SHR   EQ    LE
           -                  -     MOD   AND   NE    GT
           NOT                *     SHL   OR    LT    GE
                                    /     HIGH  LOW

The full word operators must be separated from their operands  by
at  least  one  space  or  tab.   Expressions  will  be evaluated
according to the following operator precedence, and from left  to
right when of equal precedence:

     1)  parenthesized sub-expressions
     2)  *, /, MOD, SHL, SHR
     3)  +, - (unary and binary)
     4)  EQ, NE, LE, LT, GE, GT
     5)  NOT
     6)  AND
     7)  OR, XOR
     8)  HIGH, LOW
                                                     Page 13


3.0 INSTRUCTION SET

This assembler supports the standard set of instruction mnemonics
for  the 8085.  A detailed explanation of each may be obtained by
referring  to  the  microprocessor   manufacturer's   programming
manual.  The supported instruction mnemonics are:

          ACI       DAD       LHLD      RP
          ADC       DCR       LXI       RPE
          ADD       DCX       MOV       RPO
          ADI       DI        MVI       RRC
          ANA       EI        NOP       RST
          ANI       HLT       ORA       RZ
          CALL      IN        ORI       SBB
          CC        INR       OUT       SBI
          CM        INX       PCHL      SHLD
          CMA       JC        POP       SIM
          CMC       JM        PUSH      SPHL
          CMP       JMP       RAL       STA
          CNC       JNC       RAR       STAX
          CNZ       JNZ       RC        STC
          CP        JP        RET       SUB
          CPE       JPE       RIM       SUI
          CPI       JPO       RLC       XCHG
          CPO       JZ        RM        XRA
          CZ        LDA       RNC       XRI
          DAA       LDAX      RNZ       XTHL
                                                          Page 14


4.0 ASSEMBLER DIRECTIVES (PSEUDO-OPS)

In  addition  to  normal  8085   instructions,   this   assembler
recognizes   a  number  of  assembler  directives,  or  so-called
"pseudo-ops".  These may appear in the instruction field  of  any
statement instead of an instruction mnemonic.  Various directives
are provided for  equating  symbols  to  values,  for  generating
various  types  of  data  (instead of instructions), for handling
macro definitions and conditional assembly, and  for  controlling
the  list  file  format.   These directives are summarized below;
most of them are also explained in more depth  in  the  following
pages.

          DIRECTIVE      CATEGORY

          DB             1
          DS             1
          DW             1
          ELSE           4
          END            1
          ENDIF          4
          ENDM           3
          EQU            1
          FORMLN         2
          IF             4
          LIST           2
          MACRO          3
          NLIST          2
          ORG            1
          PAGE           2
          SET            1
          TITLE          2



Categories referenced above:

(1) These directives are  part  of  the  standard  8085  assembly
language,   and  details  of  their  use  can  be  found  in  the
manufacturer's documentation.

(2) These are listing control directives,  described  in  section
4.3 of this manual.

(3) These directives deal with BSO's macro facility, described at
length in section 4.2 of this manual.

(4)  These  directives  deal  with  BSO's  conditional   assembly
facility, described in detail in section 4.1 of this manual.
                                                          Page 15


4.1 CONDITIONAL ASSEMBLY

It is often necessary to make minor  changes  in  assembled  code
based  on  frequently-altered  parameters.   This assembler has a
conditional assembly feature which permits  such  changes  to  be
made with minimum effort.

Portions of a progran can be assembled or not depending upon  the
value  of  an  expression.  This is accomplished by preceding the
conditional section of code with a statement  containing  the  IF
pseudo op and the expression to be evaluated.  The end of a block
of conditional code is indicated  by  an  ENDIF  directive.   The
expression  following  the  IF pseudo op will be evaluated by the
assembler and the results compared to zero.   If  the  result  is
non-zero,  the conditional is true and the code will be assembled
normally.  If the condition is not true (zero result), all  lines
of source text between the conditional assembly directive and its
associated ENDIF directive are ignored by the assembler.

In addition, an optional  "ELSE"  directive  exists  which,  when
appearing  in  a  block of conditional code, reverses the current
true/false state of the conditional.  As many ELSE directives may
appear   as   are   desired;   each  causes  a  reversal  of  the
conditional.

The following example illustrates the use of conditional assembly
in a program.

                  IF   HSIZE GT 3  ;Test if the value of HSIZE
          ;                        ; is greater than 3
          ;
          ;
          ; Code here would be assembled if HSIZE > 3
          ;
          ;
                  ELSE
          ;
          ;
          ; Code here would be assembled if HSIZE <= 3
          ;
          ;
                  ELSE
          ;
          ;
          ; Code here would be assembled if HSIZE > 3
          ;
          ;
                  ENDIF

Conditional assembly directives may be nested to any depth;  that
is,  a  conditional  block  of  code  may  itself  contain  other
conditional blocks, each starting  with  one  of  the  previously
listed directives, ending with an ENDIF directive, and optionally
containing one or more ELSE directives.
                                                          Page 16


4.2 THE BSO MACRO FACILITY

Included in this assembler is a macro facility which permits  the
user  to define pseudo-instructions of sorts which are considered
by the assembler to be equivalent  to  any  number  of  lines  of
source  text.  Macros are very flexible and powerful in that they
provide the ability to generate many lines of code  with  only  a
single reference in the user program.

Macros operate strictly at the  source  level  and  work  on  the
easy-to-understand principles of simple text substitution.

The MACRO and ENDM directives  are  used  to  define  macros.   A
sample macro definition follows.

          XYZZY   MACRO   ARG1,ARG2
                  IFNDEF  ARG1
          ARG1    EQU     ARG2
                  ENDIF
                  ENDM

The first line contains the MACRO directive, which  indicates  to
the  assembler that the following lines define a macro.  The name
of the macro being defined in  this  case  is  XYZZY.   The  name
appears  in  the  label field of the macro definition line.  ARG1
and ARG2 are the macro's so-called "dummy  arguments".   A  dummy
argument is any series of characters which usually also appear at
least once in the body of the  macro.   The  body  of  the  macro
definition is terminated by the ENDM directive.

To examine how macros function, we must first  examine  a  sample
use of this "XYZZY" macro.  Let us assume that the following line
of source text appears in a program  somewhere  after  the  above
macro definition:

                  XYZZY   FOO,0

Upon seeing this line, the assembler functions as follows:

(1) The assembler sees "XYZZY" in the instruction mnemonic  field
of  the source line, and, recognizing that it is not an assembler
directive (pseudo-op), the  assembler  checks  if  "XYZZY"  is  a
user-defined  macro  before  checking  it  against  the  list  of
recognized instructions.  It then discovers that  XYZZY  was,  in
fact,  previously defined by the user as a macro, as demonstrated
earlier.

(2) The assembler then examines the definition of XYZZY which was
given  to  it  earlier,  and  discovers  that  it  has  two dummy
arguments, which were  called  ARG1  and  ARG2.   It  finds  ARG1
appearing in two places in the body of the macro definition (both
as  the  argument  to  IFNDEF  and  as  the  label  in  the   EQU
instruction)  and  ARG2 appearing in one place in the body of the
definition (as the value in the EQU instruction).  Looking at the
macro  call line, above, it finds the call to the macro XYZZY has
two parameters, "FOO" and "0".
                                                          Page 17


(3) The assembler replaces the appearance of the line
                  XYZZY   FOO,0
with the block of text which was defined for the macro XYZZY, but
it  replaces  all occurances of ARG1 (the first dummy argument in
the definition) with FOO (the first actual argument in the call),
and  all  occurances  of  ARG2 (the second dummy argument) with 0
(the second actual argument).  The resulting lines of code appear
as follows:

                  IFNDEF  FOO
          FOO     EQU     0
                  ENDIF

Note that all the lines between the MACRO line and the ENDM  line
in  the  macro  definition  are  substituted  verbatim, except in
places where dummy arguments appear in the macro definition.   In
these  places,  and  in  these  places only, the actual arguments
appearing in the macro call are substituted.  Note that  a  macro
call  is  always  only  one line, but a macro definition (and the
resulting expansion of the macro performed by  the  assembler  at
macro call time) can be many lines long.

There are several things to remember about  macros  in  order  to
minimize confusion on the part of the user.

First, it cannot be overemphasized  that  the  assembler's  macro
processor   opearates   strictly   at   the   source  text  (text
substitution) level, and that  the  macro  processor  is  not  in
itself  concerned  with the syntax of 8085 instructions.  This is
significant, because the macro processor portion of the assembler
does  not concern itself with whether or not the lines which will
result from  a  macro  call  will  be  considered  valid  by  the
assembler proper.  For example, a user could use the line
                  XYZZY   *GRUMPH,BLAH
as a call to the XYZZY  macro  defined  earlier,  and  the  macro
processor  would  (correctly)  substitute  "*GRUMPH" for ARG1 and
"BLAH" for ARG2.  The resulting lines would be

                  IFNDEF  *GRUMPH
          *GRUMPH EQU     BLAH
                  ENDIF

These lines would then be examined by the assembler  proper,  and
several  errors  would be encountered.  The IFNDEF directive, for
instance, would be followed by "*GRUMPH", which is  not  a  legal
symbol  name.   This  would  produce  an error message.  The line
originally intended as  an  EQU  statement  now  starts  with  an
asterisk,  and  is  thus  flagged as an erroneous line, since the
IFNDEF   would   evaluate   as   true   (IFNDEF    assumes    all
improperly-formatted  symbol  names  to be undefined).  The ENDIF
would still work properly.

Users frequently do not realize that, in  its  text  substitution
and  pattern  matching,  the normal "fields" of a source line are
not considered by the macro processor.  As an  example,  consider
the  following problematic macro definition which an unsuspecting
user might use:
                                                          Page 18


          THING   MACRO   D
                  DB      10+D
                  ENDM

The user suspects that this macro will generate a byte  equal  to
10  plus  the argument in the macro call.  Unfortunatly, the user
has elected to use the dummy argument  name  "D",  which  appears
TWICE  in  the  macro body, once after "10+", and once as part of
the DB directive.  Thus, the call
                  THING   20
would not generate the line
                  DB      10+20
but would instead generate
                  20B     10+20
Upon presentation of this line to the assembler proper, it  would
encounter  the  string  "20B" in the instruction field, and would
issue  an  error  message,  since  "20B"  is  not  a  valid  8085
instruction  or  assembler  directive.   The lesson to be learned
here is a simple one:  Users should select dummy  argument  names
which  are  complex  enough  as to not appear in undesired places
within the macro body.  The fact that any characters (other  than
comma)  may  be used in macro dummy argument names can be used to
one's advantage.  Users frequently find it  convenient  to  start
all  dummy  argument  names with an unusual character (e.g.  "%",
"&", etc.);  this helps to insure that the  dummy  argument  does
not  accidentally  appear  where  it  is not desired in the macro
body.  For example, the above macro definition  could  have  been
rewritten

          THING   MACRO   %D
                  DB      10+%D
                  ENDM

This would work correctly, since "%D" does not appear anywhere in
the macro body except in the desired position.

4.2.1 NESTING OF MACROS

The BSO macro facility  permits  a  variety  of  types  of  macro
nesting  and redefinition.  These features prove quite useful for
various purposes.  Macros may be redefined at any time;  that is,
if a macro "ABC" is defined (and used), and another definition of
"ABC" appears subsequently, the new definition supersedes the old
definition  and is in effect beginning with the next occurance of
a call to "ABC".  Macros may call other macros  (that  is,  macro
definitions  may  include  calls  to  other  macros).   When this
occurs, all macro expansion is done at macro call time,  so  that
it  is not necessary to define macros in any particular order, as
long as all nested macros have been defined by the  time  one  is
called.   This  feature,  combined with the redefinition feature,
makes it possible to use the macro  facility  to,  for  instance,
build  corresponding  entries  in  parallel tables.  Consider the
following lines of code:

                                                          Page 19


          STUFF   MACRO
                  XX      1,1
                  XX      2,4
                  XX      3,9
                  ENDM
          XX      MACRO   %A,%B
                  DB      %A
                  ENDM
          NUMTAB  STUFF
          XX      MACRO   %A,%B
                  DB      %B
                  ENDM
          SQRTAB  STUFF

The first thing we see in the example above is a definition for a
macro  called "STUFF".  This macro simply contains three calls to
another macro, called "XX".  The XX macro has  not  as  yet  been
defined, but this is of no consequence, since the user has merely
defined the "STUFF" macro, but has not yet attempted to call  it.
Had  the  user followed the definition immediately with a call to
"STUFF", the assembler would encounter three references to  "XX",
which  would  be an undefined instruction at that point and which
would generate errors.  Also note that the "STUFF" macro  has  no
parameters.   This  is  permissable.   A  macro need not have any
dummy arguments at all.

Following the definition of STUFF, we see a definition  of  "XX".
Note  that this macro has two dummy arguments, "%A" and "%B", but
that only "%A" is actually used within  the  macro  body.   While
this  is  not  probably normally done, the macro processor of the
assembler does not consider the condition an  error;   it  merely
notes  that "XX" has two dummy arguments, but that the second one
is never used.

The next line contains a label (NUMTAB) and a call to  the  macro
STUFF.   This  time,  XX  has been defined, so that STUFF expands
into three calls to XX, and each of them generates a DB directive
to  generate a byte containing the first argument to XX.  The end
result is a table which looks like

          NUMTAB  DB      1
                  DB      2
                  DB      3


Next, we see that "XX" is redefined.  This definition is  similar
to the first definition of XX, except that this time it generates
a byte for the SECOND argument,  and  ignores  the  first.   This
definition of XX supersedes the earlier definition.

Now, STUFF is  called  again,  and  generates  another  table  of
entries, which looks as follows:

          SQRTAB  DB      1
                  DB      4
                  DB      9
                                                          Page 20


The end result of all this work is that  we  have  generated  two
parallel tables, one containing integers and one containing their
associated squares.  More entries could easily be added to  these
tables  by  adding more "XX" entries within the definition of the
"STUFF" macro.  The two tables are guaranteed  to  be  in  phase,
because  they  are  generated  using  the  macro  facility of the
assembler.

BSO macros can directly and  indirectly  call  and  define  other
macros,  and  can  even  call or define themselves.  When a macro
calls itself, the user must be careful to  see  to  it  that  the
calling  process  does  not  continue indefinitely.  When a macro
defines itself, the new definition  takes  effect  in  subsequent
calls  to  the  macro,  but the current macro expansion continues
from the old definition.

Macro calls may be nested to a level of ten.  This parameter  can
be  altered  to  customer  specification.   Contact  BSO for more
information.
                                                          Page 21


4.3 LISTING CONTROL

This cross assembler permits the user to control to  some  extent
the  format of the list file produced.  The directives which deal
with this listing control are summarized below.

4.3.1 LIST/NLIST

The user can turn off the listing of sections of code  completely
by  using  NLIST.   The NLIST directive will cause the listing to
stop;  LIST will cause it to resume.

4.3.2 TITLE

The TITLE directive, in addition to  naming  the  object  module,
also specifies the title to be printed at the top of each listing
page.  Only one TITLE directive may appear in any program.

4.3.3 PAGE

The PAGE directive causes the listing to advance to  the  top  of
the  next  page.   This also occurs if a form feed (control/L) is
encountered in the source file, and automatically every 55  lines
(see  FORMLN, 4.3.9).  If a PAGE directive is used, only the page
throw occurs in the listing;  the PAGE directive itself does  not
appear.

4.3.4 FORMLN

The directive
                  FORMLN  n
where n is a decimal integer,  changes  the  assembler's  default
form  length  to  "n" lines.  Initially, this value is 55.  After
every n lines, the assembler will advance  automatically  to  the
next page in the list file.
                                                          Page 22


5.0 OBJECT FILE FORMAT

5.1 STANDARD ABSOLUTE OBJECT FILE

The default object file produced by this assembler  is  an  ASCII
file in the format required by the INTEL 8085.  The layout of the
INTEL absolute object file is as follows:

          :           A colon for the record mark
          2 chars     number of data bytes (0 for end of file)
          4 chars     load address of first byte of record
          2 chars     record type (always 00)
          2 chars     first data byte
          2 chars     for each additional data byte
          2 chars     checksum

The checksum is the negative of the sum of all the 8-bit bytes in
the  record,  including  the  one  byte  count  and two byte load
address, with carries above 8 bits ignored.
                                                          Page 23


6.0 ERROR HANDLING

This assembler will print error messages at the  user's  terminal
and  in the program listing if the list file was requested in the
command line.  Errors are indicated by one or more characters  at
the  left  of  the  listing  line in which they occurred.  In all
cases, the assembler will attempt to generate some code for  each
source line so addresses further on in the program do not get out
of phase.  This also allows for a location into which a patch may
be  inserted  if the object file is used for debugging, even with
its errors.

The following error codes and explanations apply to this, and  in
many cases, other BSO assemblers for different microprocessors.

Error   Meaning
 Code


A       Address error.  Address specified is  out  of  range  for
        given instruction.  Relative branch out of bounds, etc.

B       Balance  error.   Unmatched  delimiters  (e.g.    quotes,
        parentheses, brackets, etc.)

C       Character  error.   Indicates  a  character  not  in  the
        supported  subset  for the assembler, or one appearing in
        the wrong place (e.g.  invalid digit in number, etc.)

D       Macro definition error.  Indicates macro definition which
        is  missing  the  name of the macro, or one with too many
        dummy arguments specified (max.  10).  The  entire  macro
        definition (up to its matchine ENDM) is ignored.

E       Expression  error.   Invalid  syntax  in  an  expression,
        usually one of the following:
        (1) Undefined operators
        (2) Unary operators in binary positions, or vice-versa
        (3) Missing expression (blank field)

M       Multiply-defined symbol.  A symbol is defined  more  than
        once   (where  this  is  illegal).   All  but  the  first
        definition are ignored.

N       Nesting  error.   Mispaired  IF:ENDIF,  MACRO:ENDM,  etc.
        This  is  an  error which encompasses more than one line.
        Single-line delimiter pairing  errors  normally  generate
        "B"  errors.   Also,  an N error will be generated if the
        nesting of macro calls in a program goes  too  deep.   In
        this  case,  the  N  error will appear on the line of the
        macro call, and the macro call will be ignored.

O       Undefined instruction mnemonic (operator).
                                                          Page 24


P       Phase error.  Pass 2 value of symbol not equal to pass  1
        value  of symbol.  The pass 1 value prevails.  This error
        frequently indicates that a symbol used in an  expression
        argument  to an IF directive was not defined prior to the
        line where the IF appears.

Q       Questionable syntax.  Generally a warning which indicates
        a  line  is  not  entirely of proper syntax, and that the
        assembler  has  made  some  assumption  about  what   the
        programmer    intended.     Often    indicates   improper
        delimiters, extra delimiters, or missing delimiters.

R       Register error.  The register specified  is  illegal  for
        this particular instruction.

S       Invalid symbol.  Use of the wrong type of user symbol  in
        the  wrong  place  (e.g.   macro  name  used as part of a
        numeric expression, etc.).  This  error  code  will  also
        flag all lines on which references appear to symbols that
        are multiply-defined in the program.   While  the  latter
        does  not  strictly  indicate  an  error condition, it is
        possible that changing one of the multiply defined symbol
        names  might  require  changing lines which reference it;
        therefore, such lines are flagged  by  the  assembler  to
        facilitate locating them.

U       Undefined  symbol.   A  symbol  is   referenced   in   an
        expression,  but  that  symbol has no defined value.  The
        assembler assumes the symbol to have a value of zero.

V       Value error.  An operand value was out of  range,  or  an
        absolute  value  could  not  be  produced for a Pseudo op
        which requires it.

Y       Assembler  feature  not  implemented.    The   user   has
        attempted  to use an assembler directive or feature which
        is not implemented in the currently-running assembler.
                                                          Page 25


7.0 SUMMARY OF DIFFERENCES

This assembler is compatible with the one supplied for  the  8085
by Intel with several minor exceptions.  These are listed below.

(1) The following features  conform  to  BSO  standards  and  may
conflict with similar features offered by the manufacturer.

        (A)  Macro Processing
        (B)  Conditional Assembly Directives
        (C)  Listing Control
        (D)  Relocation Directives and Control

(2) User symbols may contain only the characters A-Z, 0-9.

(3) Labels must begin in column one.


Please note that in most cases, macros can be written by the user
to  duplicate  directives  that are supported by the manufacturer
but do not appear in BSO software.

The list of differences above is accurate  to  the  best  of  our
knowledge,  however BSO does not warrant that it is complete.  In
addition, this or  any  other  BSO  product  is  not  necessarily
compatible  with  any past, current or future implementation of a
similar product by any microprocessor manufacturer.



                 THE BOSTON SYSTEMS OFFICE, INC.
                  PROBLEM AND SUGGESTION REPORT


If you have any difficulty with BSO software,  if  you  note  any
errors  in  this  manual, or if you have any general suggestions,
please feel free to call us, or  mail  in  this  form  with  your
comments.



Product:                                       Version:
-----------------------------------------------------------------
Reported by:                                   Date:
-----------------------------------------------------------------
Company:                                       Phone:
-----------------------------------------------------------------
Address:
-----------------------------------------------------------------
Host computer/operating system:
-----------------------------------------------------------------

Description of bug or comments:
-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------


           Please return, along with terminal sessions
                 and listings, if available, to:

                 The Boston Systems Office, Inc.
                        469 Moody Street
                  Waltham, Massachusetts  02154
                         (617) 894-7800



                    DO YOU LIKE THIS MANUAL??



BSO  is  constantly  working  to  improve  the  quality  of   our
documentation.   If  you have any constructive comments regarding
this or any BSO publication, we would appreciate it if you  would
take  a few moments to jot them down in the space below, and then
mail the form to us at 469 Moody Street,  Waltham,  Massachusetts
02154.  Our customers' comments are always appreciated!

Title of document:
-----------------------------------------------------------------
Date of document revision:
-----------------------------------------------------------------
Your name:                                  Today's date:
-----------------------------------------------------------------
Company:                                    Phone:
-----------------------------------------------------------------
Address:
-----------------------------------------------------------------

Please rate this manual in the following categories with a number
between 0 (worst) and 5 (best):

Overall Readability: _________

Organization:        _________

Accuracy:            _________


Please  write  any  general  comments below.  If you require more
space, feel free to attach as many additional pages as you  wish.
Thanks for your help.
  &SppQ