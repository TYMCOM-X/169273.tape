
	NOTICE:
		There is a hard-copy manual available for Sail, 
	and a tutorial for learning the language.  Please contact
	your Tymshare Representative if you want either manual.






                               SECTION  1
                               -------  -

                              New Features
                              --- --------





This section describes  changes and additions  to Sail since  the August
1976 manual, AIM-289.



1.1 - Double Precision


Double  precision  floating-point  arithmetic  is  available.   Use  the
<type!qualifier> LONG in declarations.  For example,
        LONG REAL X, Y, Z;
        LONG REAL ARRAY XA[0:N];

Currently LONG has  meaning only when it  appears as part of  LONG REAL.
(At some future time LONG INTEGERs may also exist.)

The runtime routines  LREALIN and LREALSCAN  operate the same  as REALIN
and REALSCAN, except for  returning LONG REAL values.  The  routine CVEL
takes a LONG REAL value and returns a string representation like that of
CVE,  except that  "@@"  is used  to  signify LONG  when  delimiting the
exponent.   Any  of  "@",  "@@", "E",  or  "D"  are  acceptable exponent
delimiters to LREALIN and LREALSCAN.

Variables which are declared LONG REAL are represented in  KI10 hardware
format  double precision,  take two  consecutive words  of  storage, and
provide  62  bits  of precision  (approximately  18  decimal  digits) to
represent the  fraction part of  a floating-point number.   Regular REAL
variables occupy a  single word and have  27 bits (8 decimal  digits) of
precision.  The exponent range of  both REAL and LONG REAL  variables is
from -128 to 127, where 2^127 is approximately 10^38.

LONG REAL is a dominant type in arithmetic operations +-*/%^ MAX MIN and
arithmetic relationals  <>= LEQ GEQ  NEQ.  If one  operand is  LONG REAL
then both operands will be converted to LONG REAL (if  necessary) before
performing  the  operation.   An exponentiation  involving  a  LONG REAL
raised to a positive integer constant is an exception to this rule.  The
type coercion path is linear:   STRING -> INTEGER -> REAL ->  LONG REAL.
Conversion from REAL to LONG  REAL is performed by assigning  the (only)
word of  the REAL  to the  most significant  word of  the LONG  REAL and
setting the second  (least significant) word of  the LONG REAL  to zero.
Conversion from LONG REAL to REAL is by UUO which rounds.

Arithmetic and assignment operations are compiled into DFAD, DFSB, DFMP,
DFDV, DMOVE,  DMOVEM instructions.  The  Sail operations ASH,  LSH, ROT,
LAND, LOR,  EQV, XOR are  performed on both  words (ASHC, LSHC,  ROTC, 2
ANDs, 2 IORs, etc.).  LOCATION of a LONG REAL variable gives  an address
E such that  DMOVE AC,E fetches the  appropriate words of  memory.  When
passed by value  as an actual parameter  to a procedure, both  words are
placed on  the P stack:   PUSH P,X  ; PUSH P,X+1.   LONG REAL  fields in
record  classes are  handled much  like STRING  fields, except  that the
address in the record field points  to the first word of a  2-word block
(rather than to the second word as in the case with STRINGs).

LONG  REAL ARRAYs  are  stored as  contiguous blocks  of  2-word values.
ARRTRAN done on two LONG REAL arrays is a transparent operation, but for
ARRYIN, ARRYOUT,  or ARRBLT  the actual word  count is  specified; think
about whether you should multiply by 2!  At runtime the array descriptor
for a LONG ARRAY has bit  12 (40,,0 bit) set in MULT(n),  the multiplier
for the last dimension (which would otherwise be =1).  Similarly, a LONG
ARRAY is allocated by setting bit 12 (40,,0) bit in the  parameter which
specifies the number of dimensions to ARMAK.

Runtime support for LEAP items with LONG REAL datums does not yet exist,
although the compiler does generate suitable code.

Two new (compile-time evaluatable) math procedures are:
        LONG REAL PROCEDURE B2LOG(LONG REAL VALU);
        LONG REAL PROCEDURE B2EXP(LONG REAL VALU);
B2LOG is log base 2, and b2EXP is the inverse (2@@0^valu).


1.2 - Declarations and Scope


Sail declarations must occur before use.  For example, in  the following
program the argument to  PRINT is interpreted as  the K on line  2, even
though by the ALGOL60 notion of scope it should be interpreted as  the K
on line 5.

        BEGIN "FOO"
        INTEGER K;      COMMENT this is line 2;
          BEGIN "RUB"
          PROCEDURE BAR; BEGIN PRINT(K) END;
          INTEGER K;    COMMENT this is line 5;
          <statements>
          END "RUB"
        END "FOO"



1.3 - Two-character Operators


The compiler now recognizes "**" for "^", ":=" for "_", "<="  for "LEQ",
and ">=" for "GEQ".


1.4 - Requires


REQUIRE  OVERLAP!OK;   will  suppress  the   message  which   occurs  at
initialization when two programs have declared items.

REQUIRE VERIFY!DATUMS; causes the compiler to generate  three additional
instructions for each DATUM reference, to make sure (dynamically, at run
time) that the type  of the item in the  DATUM construct is the  same as
the compiler expected.  This is similar to (the unimplimented effect of)
declaring all itemvars CHECKED.   It is planned that  VERIFY!DATUMS will
soon be a bit in the  /A switch and that the corresponding  REQUIRE will
disappear.

REQUIRE   PROCESSES;  insures   that  MAINPR,   the  main   process,  is
initialized.  You  need not  specify this  REQUIRE if  you use  APPLY or
SPROUT, but if  the only use  of processes is  via INTSET then  you must
REQUIRE PROCESSES;.



1.5 - CASE Statement


In an explicitly numbered CASE statement the word ELSE can  appear where
a bracketed case number  is normally used.  The statement  following the
ELSE  is  a  catch-all  for any  case  number  not  mentioned, including
anything  which  would  otherwise  generate  a  CASE  index  error.  For
example,

        CASE K OF BEGIN [3] J_3; ELSE J_4; [5] J_5 END

is another way of accomplishing

             IF K=3 THEN J_3
        ELSE IF K=5 THEN J_5
        ELSE J_4

A CASE statement containing an ELSE case does not generate a call to the
CSERR runtime routine, and  in addition the jump table  usually contains
only  max!case - min!case +1  words (rather than max!case +1).  The ELSE
may also be written  between square brackets as  if it were another case
number.

A new syntax exists for numbered case elements to allow ranges:

    case!numl	::= 	integer!constant
		::=	integer!constant : integer!constant 
		::=	case!numl , case!numl

    case!label	::=	[ case!numl ]
		::=	[ ELSE ]
		::=	ELSE

This allows:

	CASE i OF BEGIN [1:5,10,25:29] j_i*4; [ELSE] outstr("ICK") END

In addition, numbered case elements may be used in case expressions.  In
that case, the ELSE clause will work normally, but failing to include an
ELSE will generate  a CASE index error if  unspecified indices are used.
Note that this is  unlike the  CASE statement, where  unspecified values
are sometimes treated as null statements.

	CASE i OF BEGIN [1] st1; [5] st2 END
behaves like:
	CASE i OF BEGIN [1] st1; [5] st2; [0,2:4] ; ELSE cause!error END

but
	CASE i OF ([1] v1, [5] v2)
behaves like:
	CASE i OF ([1] v1; [5] v2; [ELSE] cause!error)



1.6 - Circular RECORD!CLASSes


To  define  two record  classes,  both of  which  contain RECORD!POINTER
fields refering to the other class, say

        FORWARD RECORD!CLASS BAR (RECORD!POINTER (ANY!CLASS) Q2);
        RECORD!CLASS FOO (RECORD!POINTER (BAR) Q1);
        RECORD!CLASS BAR (RECORD!POINTER (FOO) Q2);

In general, declare one class to be FORWARD and list  its RECORD!POINTER
fields as pointers to ANY!CLASS.  This breaks the circularity and allows
maximum compile-time type checking.



1.7 - LOP


Finally, LOP is available as a statement.



1.8 - BBPP


BBPP is a POINT-like construct that may generate better code if its args
are constants.  Should be substitutable for POINT, but some Sail author
didn't think so, and therefore kept its existance un-documented.  It 
will now generate the equivalent of "MOVEI ac,ACCESS(x); HRLI ac,sizpos"
in appropriate situations (complex effective address, constant size,pos)
as well as generating constants for very simple elements.



1.9 - DFR1IN 

DFR1IN will accept either "AOBJN!POINTER" as before, or will take the
address of the call block with a zero left half  (i.e. what "LOCATION"
returns).


1.10 - COMPILER!SWITCH

This is a compile-time construct to examine the compilation switches
active during the compilation.  The construct is: COMPILER!SWITCH(char)
which is an integer constant expression equal to the setting of the 
switch.  This allows conditional compilation code like:
    IFCR COMPILER!SWITCH("B") NEQ 0	comment if compiled for BAIL;
	 THENC USERERR(0,1,"Jumping to BAIL","B");
					comment invoke BAIL via error;
	 ENDC


1.10 - COMPILER!VERSION

This is a compile-time construct which returns the version number of
the compiler doing the compilation.  No simple ordering relationship
exists between versions; this is provided primarily for maintennance 
purposes and to allow identifacation of particular compilers.

	Operating System


In  some cases,  user  programs may  wish to  determine  which operating
system they are running on.  At startup time, the Sail  runtimes execute
a special GETTAB  UUO that is supposed  to return a code  indicating the
operating system.   This GETTAB  is implemented  on all  known operating
systems  that use  PDP-10  hardware, except  for the  Stanford  A.I. Lab
monitor, TYMCOM-X, and certain  out-of-date Tenex  systems.  It  is even
implemented on ITS!  The value returned by this UUO is put in a variable
$OS, which may be declared as an EXTERNAL INTEGER by your program so you
can look at it.  The codes are returned in bits 18-23:

        1 - Tops-10
        2 - ITS
        3 - Tenex
        4 - Tops-20
        5 - Stanford A.I. Lab monitor
        6 - TYMCOM-X monitor


The other bits in this  word are reserved for indicating  subversions of
these various operating systems.

			BAIL

BAIL has had many additions to protect against "ILL MEM REF" problems.
In addition:

   (1) Ending a line to BAIL with a <CR> will make BAIL add a semicolon
	before evaluating the line.  the old behavior can be achieved by
	ending lines with <LF>.

   (2) !!QUERY has now been pre-declared, thus allowing certain "EVAL"-
	like functions to be specified.

   (3) The <block>.<variable> specification of a particular instance of
	a variable name has had the "." changed to "|".  This has been
	done to allow type-in of variable names that include periods.
	"|" is a Sail abbreviation for "SUCH THAT" in foreach statements
	(BAIL does not support foreach statements).

   (4) A shortened syntax for subfield accesses exists exclusively for
	BAIL:	<pointer-expression> [ <subfield name> ]
	This may only be used for subfields of the class of the actual
	record specified by the expression (no subfields for similar
	classes).  This syntax may be used recursively:
		PTR[LINK][LINK][LINK][NAME]
	instead of CL:NAME[ CL:LINK[ CL:LINK[ CL:LINK[ PTR ] ] ] ]


BAIL support for LONG REALS does not yet exist.

	New hooks into Sail

GOGTAB.DEF includes the definition of the size of the GOGTAB array.
To get the appropriate size for GOGTAB, use:
	REQUIRE "SYS:GOGTAB.DEF" SOURCE!FILE;
	EXTERNAL INTEGER ARRAY GOGTAB[0:ENDREN];

core allocation		GOGTAB[CORINS]
    =0 => behave normally
    ELSE  XCT the contents of of GOGTAB[CORINS], which should
	behave as follows: 
	 1) P('17) avaliable as stack,
	    USER('15) has address of user table base (GOGTAB[0])
	 2) TEMP('14) contains the desired address
	    to extend core to (from GOGTAB[TOP]-1)
	 3) failure: no ac's changed, return +1
	 4) success: LAST('6) gets highest address
	    provided (must be GEQ TEMP's value),
	    no ac's but LAST changed, return +2.

getchan hook		GOGTAB[BKGETC]
  preserve all AC's
    =0 => behave normally
    ELSE XCT the contents of GOGTAB[BKGETC], which should
	 1) ALWAYS (even if short-circuiting release code) exit with
	    USER('15) set to address of user table base (GOGTAB[0]).
	    This is set up to the proper value on entry.
	 2) either return +1 (to complete normal GETCHAN function)
		(eg GOGTAB[BKGETC] is PUSHJ P, to 0-arg procedure).
	    or be a complete substitute for the getchan function
		(eg GOGTAB[BKGETC] is JRST to 0-arg integer procedure).

release hook		GOGTAB[BKRELS]
  preserve all AC's
    =0 => behave normally
    ELSE XCT the contents of GOGTAB[BKRELS], which should
	 1) ALWAYS (even if short-circuiting release code) exit with
	    USER('15) set to address of user table base (GOGTAB[0]).
	    This is set up to the proper value on entry.
	 2) either return +1 (to complete normal RELEASE function)
		(eg GOGTAB[BKRELS] is PUSHJ P, to 0-arg procedure).
	    or be a complete substitute for the release function
		(eg GOGTAB[BKRELS] is JRST to 2-arg procedure).
    Note: RELEASE has 2 args (not 1), second is inhibit bits
    Also Note: RELEASE is called within the OPEN function

open hook		GOGTAB[BKOPEN]
  preserve all AC's
    =0 => behave normally
    ELSE XCT the contents of GOGTAB[BKOPEN], which should
	 1) ALWAYS (even if short-circuiting open code) exit with
	    USER('15) set to address of user table base (GOGTAB[0]).
	    This is set up to the proper value on entry.
	 2) either return +1 (to complete normal OPEN function)
		[in this case RELEASE will immediately be called]
	    or be a complete substitute for the open function
		(not described).

                          Documentation Errors
                          ------------- ------




This is a list of known bugs in the August 1976 Sail manual, AIM-289.

PAGE                    DESCRIPTION
abstr.  "varaiables" is a misspelling   [JFR 10-22-76]

iiiL    no period after LEAP (line 6 of paragraph)      [LES 10-22-76]

162L    "i.e" in the line "2. Recursive entry"  [JFR 10-23-76]

1R      "Nauer" for "Naur" (also References)    [JFR 11-2-76]

22L,26L "disjunct" -> "conjunct"                [JMC 11-12-76]

31L     line -9 "its" -> "it's"                 [JMC 11-12-76]

162R    The word PDA+'13 contains something other than indicated.
        The parameter descriptor words actually start at PDA+'14,
        but the way to find them is to follow the pointer in
        the right half of PDA+7.                [JFR 12-9-76]

9L      Another restriction on SIMPLE procedures: They should not do
        up-level addressing themselves (in addition to point 4.) unless
        the user really understands what is going on with the stack.
        It is possible to "screw up" without complaints from the
        compiler. SIMPLE ought to mean "I know what I am doing, so let
        me do it.". [JFR/DON 12-xx-76]

56L     CRLF="('15 & '12)", not '12 & '15       [JFR 1-15-77]

10R     It should be made clear that  LET A=B;  works even if
        A is a reserved word.  In particular, LET DEFINE=REDEFINE;
        Also note that B can be any reserved
        word except COMMENT. [COMMENT ALWAYS means "ignore through
        the next semicolon".]

4R      POLLING!POINTS is not a valid <require!spec>    [WFW 1-21-77]

50R     In FILEINFO, hidate2 occupies 3 bits    [JFR 2-3-77]

152L    CHNCDB and FILEINFO are defined everywhere except TENEX.
        [JFR 2-3-77]

65R     A better way of getting around the array problem is as follows:

        REQUIRE "<><>" DELIMITERS;

        DEFINE NewArray(type,name,bounds)=<
                BEGIN
                type ARRAY proxy bounds;
                MEMORY[LOCATION(name)] SWAP MEMORY[LOCATION(proxy)];
                END>;


        which hides all the hair of a poor facility and is perfectly
        general, unlike the present scheme in the manual. It will
	also de-allocate any array array storage formerly associated 
	with the array. A typical call would be:

        RECORD!CLASS RC(STRING ARRAY SA);
        RECORD!POINTER (RC) rp;

        rp _ NEW!RECORD(RC);
        NewArray(STRING,RC:SA[rp],[0:1,-2:3]); [MWK for KS 01-13-77]

27L     DIV and MOD use integer divide and are meant as a "integer
        divide" and "integer divide and remainder". This is NOT the
        real mod as written in Knuth volume 1. In fact, MOD would
        better have been named REM. [MWK 01-13-77]
@




STANFORD ARTIFICIAL INTELLIGENCE LABORATORY                MARCH 1974






                          SAIL USER MANUAL

                               UPDATE



                            James R. Low
                           Hanan J. Samet
                          Robert F. Sproull
                         Daniel C. Swinehart
                          Russell H. Taylor
                           Kurt A. VanLehn










                              ABSTRACT

This document describes recent changes to the Sail language since the
"new" manual (AIM-204) was  published in July 1973.  It  reflects the
various new  features implemented  as of 12  February, 1974  for Sail
version  7 and  corrects  a number  of  minor errors  in  the earlier
manual.
Sail Addendum  1                                    TABLE OF CONTENTS


  
                  T A B L E   O F   C O N T E N T S
                  - - - - -   - -   - - - - - - - -



SECTION                                                          PAGE



1    INTRODUCTION                                                   1



2    NUMERICAL ROUTINES                                             2

     1    OVERFLOW                                                  3
     2    ENTRY POINTS                                              4


3    NEW PROCESS FEATURES                                           5

     1    SPROUT APPLY                                              5
     2    SPROUT!DEFAULTS                                           5
     3    SUSPEND                                                   7
     4    FAIL AND SUCCEED                                     7


4    ERROR HANDLING                                                 8

     1    ERROR MODES                                               8
     2    USER ERROR PROCEDURES                                     8


5    INEXHAUSTIBLE STRING SPACE                                    10
Sail Addendum  1                                    TABLE OF CONTENTS


6    MISCELLANEOUS NEW FEATURES                                    12

     1    NEW MTAPE OPTIONS                                        12
     2    INITIALIZATION PHASES                                    12
     3    CHNCDB                                                   13
     4    ARRCLR                                                   13
     5    SETPL                                                    13
     6    EVALREDEFINE                                             14
     7    CVPS                                                     14
     8    EXPRESSIONS IN REQUIRES                                  14
     9    RELEASE                                                  14
     10   TTYUP                                                    14
     11   BREAKSET MODES "K" AND "F"                               15
     12   INOUT                                                    15
     13   GETSTS & SETSTS                                          15
     14   CHANGES TO "OPEN" ERROR HANDLING                         16
     15   ASH                                                      16
     16   ARG!LIST                                                 16


7    MINOR CORRECTIONS TO AIM-204                                  17
Sail Addendum  1                                         INTRODUCTION


                             SECTION  1
                             -------  -

                            INTRODUCTION
                            ------------





The following short manual  describes the changes that  have happened
to  Sail  since  the  publishing  of  the  Manual  in  July  1973. It
accurately reflects the state of Sail, version 7, which was put up on
December 4, 1973.  The reader should be warned that many of these new
features were designed for veteran Sail hackers.




































                                  1
Sail Addendum  1                                   NUMERICAL ROUTINES


                             SECTION  2
                             -------  -

                         NUMERICAL ROUTINES
                         --------- --------





A collection of numerical routines has been added to Sail.  These are
pre-declared in the compiler,  and are loaded from the  standard Sail
library.   The  functions  are  quite  standard;  following  are  the
equivalent definitions:

1.  The standard trigonometric functions.  ASIN, ACOS, ATAN and ATAN2
    return results in radians.   The ATAN2 call takes  arc-tangent of
    the  quotient  of  its  arguments;  in  this  way,  it  correctly
    preserves sign information.

        REAL PROCEDURE SIN (REAL RADIANS);
        REAL PROCEDURE COS (REAL RADIANS);
        REAL PROCEDURE SIND (REAL DEGREES);
        REAL PROCEDURE COSD (REAL DEGREES);

        REAL PROCEDURE ASIN (REAL ARGUMENT);
        REAL PROCEDURE ACOS (REAL ARGUMENT);
        REAL PROCEDURE ATAN (REAL ARGUMENT);
        REAL PROCEDURE ATAN2 (REAL NUMERATOR,DENOMINATOR);


2.  The hyperbolic trigonometric functions.

        REAL PROCEDURE SINH (REAL ARGUMENT);
        REAL PROCEDURE COSH (REAL ARGUMENT);
        REAL PROCEDURE TANH (REAL ARGUMENT);

3.  The square-root function:

        REAL PROCEDURE SQRT (REAL ARGUMENT);

4.  A pseudo-random number  generator.  The argument specifies  a new
    value for the seed (If the  argument is 0, the old seed  value is
    used.  Thus to get differing random numbers, this argument should
    be zero.)  Results are normalized to lie in the range [0,1].

        REAL PROCEDURE RAN (INTEGER SEED);




                                  2
Sail Addendum  1                                   NUMERICAL ROUTINES


5.  Logarithm and exponentiation functions.  These functions  are the
    same ones used by the Sail exponentiation operator.  The  base is
    e  (2.71828182845904).  The  logarithm  to the  base 10  of  e is
    .4342944819.

        REAL PROCEDURE LOG (REAL ARGUMENT);
        REAL PROCEDURE EXP (REAL ARGUMENT);

These functions may occasionally be asked to compute numbers that lie
outside the range of legal floating-point numbers on the  PDP-10.  In
these cases,  the routines  issue sprightly  error messages  that are
continuable.



2.1 - OVERFLOW
      --------


In order  to better  perform their tasks,  these routines  enable the
system interrupt facility  for floating-point overflow  and underflow
errors.  If  an underflow is  detected, the results  are set to  0 (a
feat not  done by  the PDP-10  hardware, alas).   Be aware  that such
underflow fixups will be done to every underflow that occurs  in your
program.

If you would like to be informed of any numerical exceptions, you can
call the runtime:

        TRIGINI ( LOCATION(simple-procedure-name) );

Every floating-point exception that is not expected by  the interrupt
handler (the numerical routines use a special convention  to indicate
that  arithmetic exception  was  expected) will  cause  the specified
simple procedure to  be called.  This  procedure may look  around the
world as  described in  the Manual  for 'export'  interrupt handlers,
page 79.   If no  TRIGINI call  is done,  the interrupt  routine will
simply dismiss unexpected floating-point interrupts.












                                  3
Sail Addendum  1                                   NUMERICAL ROUTINES


2.2 - ENTRY POINTS
      ----- ------


In order to avoid confusion (by the loader) with older trig packages,
the  entry points  of the  Sail arithmetic  routines all  have  a "$"
appended  to the  end.   Thus, SIN  has  the entry  point  SIN$, etc.
WARNING:  If a  program  plans to  use the  Sail  intrinsic numerical
routines, it should NOT include external declarations to  them, since
this will probably cause the FORTRAN library routines to be loaded.








































                                  4
Sail Addendum  1                                 NEW PROCESS FEATURES


                             SECTION  3
                             -------  -

                        NEW PROCESS FEATURES
                        --- ------- --------







3.1 - SPROUT APPLY
      ------ -----


The <procedure call> in a SPROUT statement may be an APPLY construct.
In  this case SPROUT will  do the "right" thing  about setting up the
static link  for  the  APPLY. That is,  "up-level" references  by the
process will  be made to  the same variable  instances that  would be
used if the APPLY did not  occur in a SPROUT statement. (See  page 77
of the manual.)

However, there  is a glitch.  The sprout mechanism  is not  yet smart
enough to find out the block of the declaration of the procedure used
to define the procedure item. It would be nice if it did,  since then
it could warn the user when that block was exited and yet the process
was still alive,  and thus potentially  able to refer  to deallocated
arrays and etc. What the sprout does instead is assume  the procedure
was declared in the outer  block. This may be fixed   eventually, but
in the meantime  some extra  care should be taken  when  using  apply
in   sprouts  to    avoid    exiting  a    block    with  dependents.
Similarly,  be warned   that the  "DEPENDENTS  (<blockid>)" construct
may  not give  the  "right"  result  for  sprout applies. Page  68 of
the Manual contains the description of this protection  mechanism for
non-APPLY Sprouts.



3.2 - SPROUT!DEFAULTS
      ---------------


Sail  now provides  a mechanism  by which  the user  may specify  the
"default" options to be used when individual procedures are sprouted.








                                  5
Sail Addendum  1                                 NEW PROCESS FEATURES



Syntax:
        PROCEDURE <procid> ...
         BEGIN
         <some declarations>;
         SPROUT!DEFAULTS <integer constant>;
         <perhaps some more declarations>;
         :
         :
         <statements>
         :
         END;


In other words, SPROUT!DEFAULTS is a declaration.

Semantics:

If  one of the "allocation" fields of  the options word passed to the
SPROUT routine -- i.e. QUANTUM,STRINGSTACK,PSTACK, or  PRIORITY -- is
zero,   then  SPROUT  will look  at  the corresponding  field of  the
specified <integer constant> for the procedure being sprouted. If the
field is  non-zero,   then  that value  will be  used; otherwise  the
current "system" default will be used.

NOTE:  SPROUT!DEFAULTS  only  applies  to  "allocations",  i.e.   the
process status control bits (e.g. SUSPME) are not affected.
Example:

        RECURSIVE PROCEDURE FOO;
         BEGIN
         SPROUT!DEFAULTS STRINGSTACK(10);
         INTEGER XXX;
         :
         :
         END;
        :
        SPROUT(P1,FOO,STRINGSTACK(3));
        SPROUT(P2,FOO);
        COMMENT P1 will have a string stack of 3*32 words.
         P2 will have a string stack of 10*32 words;








                                  6
Sail Addendum  1                                 NEW PROCESS FEATURES


3.3 - SUSPEND
      -------


SUSPEND now behaves like RESUME in that it returns an item.

        itm _ SUSPEND(<process item>)

Frequently, one is suspending some other process than the one that is
executing the SUSPEND statement.  In this case, the item  returned is
ANY.   However, in cases like:

        X _ SUSPEND(MYPROC);

where the process suspends itself, it might happen that  this process
is  made running  by a  RESUME from  another process.  If so,  then X
receives the <return!item>  that was an argument to the RESUME.



3.4 - FAIL AND SUCCEED
      ---- --- -------


FAIL and SUCCEED now behave like RESUME and SUSPEND in that they also
return  an  item.   The  item returned  is  ANY  unless  the Matching
Procedure  containing  the FAIL  or  SUCCEED was  (1)  sprouted  as a
process, and (2) made running  by a RESUME construct.  In  the latter
case, the item returned is the <return!item> that was an  argument to
the RESUME.  [Note that the  only case in which a  Matching Procedure
can be reactivated at a FAIL is by being RESUMEd.]




















                                  7
Sail Addendum  1                                       ERROR HANDLING


                             SECTION  4
                             -------  -

                           ERROR HANDLING
                           ----- --------







4.1 - ERROR MODES
      ----- -----


Sail's error  handler has at  long last been  modified to do  what is
claimed it will do  in Section 20 of the manual (pgs 95 - 97), and in
the description of USERERR (pg 42).  In brief, it allows one to  have
error  messages automatically  sent  to  a "log"  file  while one  is
compiling, and to use USERERR as a trace statement.

The description given in the manual differs from reality in two ways:
"Keep" mode has not  been implemented (the error handler   will flush
all type-ahead except  a <lf>);   all  of the  other  modes ("Quiet",
"Logging",  and "Numbers")  are  implemented ONLY   IN  THE COMPILER.
However, one  can get the effect of error modes at runtime by using a
brand new feature called user error procedures.



4.2 - USER ERROR PROCEDURES
      ---- ----- ----------


A  user error  procedure is a  user procedure  that is run  before or
instead of  the  Sail error  handler  everytime  an error  occurs  at
runtime.  This  includes all array errors, IO  errors, Leapish errors
and all USERERRs.  It does not include system errors, such as Ill Mem
Ref or Ill UUO.

The  procedure one uses  for a  user error procedure  must be  of the
following type:

    SIMPLE INTEGER PROCEDURE proc (INTEGER loc; STRING msg, rsp);


Only the names  proc, loc,  msg, and rsp  may vary  from the  example
above, except  that one  may declare  the procedure  INTERNAL if  one
wishes to use it across files.



                                  8
Sail Addendum  1                                       ERROR HANDLING


Whenever  the external integer !ERRP!  is loaded with LOCATION(proc),
the error handler will  call proc before it  does anything else.   It
will set loc to  the core location of the call  to the error handler.
Msg  will be  the message  that it  would have  printed.  Rsp will be
non-NULL only  if the  error was  from a  USERERR which  had response
string argument.  Proc can  do anything that  a simple  procedure can
do.  When it  exits, it should  return  an  integer which   tells the
error handler  if  it should do anything more.  If the integer  is 0,
the  error  handler will  (1)   print the   message,  (2)   print the
location,  and  (3)  query  the  tty  and  dispatch  on  the response
character (i.e ask for a <cr>, <lf>, etc.).  If the right half of the
integer is  non-zero, it  is taken as  the ascii  for a  character to
dispatch upon.  The left half may have two bits to  control printing.
If bit 17  in the integer is  on, message printing is  inhibited.  If
bit 16 is on, then  the location printing is inhibited.  For example,
"X"+(1 LSH 18) will cause the location to be printed and  the program
exited.  "C"+(3 LSH  18)  will cause  the error  handler  to continue
without printing anything.

Note that simple  procedures can not do  a non-local GOTO.   However,
the  effect of  a non-local  GOTO  can be  achieved in  a  user error
procedure by loading the external integer !ERRJ! with the LOCATION of
a label. The label  should be a on  a call to a  non-simple procedure
which does the desired GOTO.  The error handler clears  !ERRJ! before
calling the procedure  in  !ERRP!.  If  !ERRJ!  is non-zero  when the
user procedure returns, and continuing was specified, then  the error
handler's exit  consists of a simple transfer to  that location.

WARNING! Handling errors from strange places like the  string garbage
collector and  the core  management routines will  get you  into deep
trouble.


















                                  9
Sail Addendum  1                           INEXHAUSTIBLE STRING SPACE


                             SECTION  5
                             -------  -

                     INEXHAUSTIBLE STRING SPACE
                     ------------- ------ -----





The string garbage collector has been modified to expand string space
(using discontiguous blocks) whenever necessary to satisfy the demand
for places to put strings. To take advantage  of  this  feature,  one
need not change his programs.

Here are some points which might be of interest, however:

1)  Although  we  are  going  to  provide  user control over all size
    parameters  eventually,  currently  only   the   initial   string
    space size  is   settable  by  the   user, either via  REQUIRE or
    the ALLOC  sequence, as  before.  The size  of each  string space
    increment will be  the same as the original size, which  need not
    be monstrous  any more  unless you   know that  all runs  of your
    program  will  need   a monstrous   string  space   anyhow.   The
    threshold  (see below)  for  expanding will  be set  at  1/8  the
    string  space  size  (increment size).

2)  One can, in his program, modify these values independently, if he
    is  willing  to use  the  USERCON function,  and  to  follow this
    format:

     USER TABLE ENTRY NAME              VALUE
        STINCR          lh: number of chars. in increment
                        rh: number of words in increment + 4

        STREQD          lh: number of chars. in threshold
                        rh: number of words in threshold.


3)  The threshold.   After garbage  collection, let  us say  that M-1
    discontiguous string spaces  are   full,  and  the  M'th   has  n
    free  characters in it (available for new strings).  The  garbage
    collector  was  called because   some routine wanted to  create a
    string R characters long, and there were not that many  available
    (free).      After    garbage  collection,   the   new  algorithm
    requires  that N  be greater  than R+LH(STREQD).   If it  is not,
    expansion  takes  place  (to  M+1  spaces),  to    satisfy   this
    requirement.    In other words, if STREQD is 1/8 the size  of the
    current space, that space  will not be  allowed  to  become  more


                                 10
Sail Addendum  1                           INEXHAUSTIBLE STRING SPACE


    than   about   7/8   full.   This  helps  avoid  frequent, nearly
    useless calls on the garbage collector when  space is about gone.
    All  but the  current  space are  allowed  to become  as  full as
    possible, however.

4)  New  statistics  are  maintained  by  the    garbage   collector.
    Soon there   will  be  a built-in  routine you  can use  to print
    them.  For now, you may look at them using USERCON, although this
    document   does  not   say  what   they   are.      In   order to
    activate timing  of the  garbage collector  (slows it  down), set
    SGCTIME in the  user  table to -1.

5)  Future plans.  The  new  structure  not only allows  expansion of
    string  space,  it  also  will   allow   for    partial   garbage
    collections   (no   visible  benefits   except   increased speed,
    since  a partial  collection  will be  almost as  effective  as a
    complete one,  and  much   faster),  and  the  ability   to  move
    string  space  blocks, in order to compact memory.  Push  on your
    local representative  to  get  these  things done.






























                                 11
Sail Addendum  1                           MISCELLANEOUS NEW FEATURES


                             SECTION  6
                             -------  -

                     MISCELLANEOUS NEW FEATURES
                     ------------- --- --------







6.1 - NEW MTAPE OPTIONS
      --- ----- -------


        MTAPE(chan,NULL)


will cause an MTAPE 0 to be issued for channel chan.  For mag. tapes,
this will  cause you to  wait until all  activity ceases.   For other
devices, various  random things can  happen, depending on  the device
and system.

In export Sail, MTAPE(chnl,"I") sets the 'IBM compatible' mode  for a
tape drive.  (It does an MTAPE chnl,101.)



6.2 - INITIALIZATION PHASES
      -------------- ------


User initializations  are  now done  in successive  phases, with  all
initializations   required   for   one   phase   being  done   before
initializations required for the next phase.

Syntax:

        REQUIRE <procid> INITIALIZATION;
        REQUIRE <procid> INITIALIZATION [<phase no>];

where <phase no> is an integer constant.

Semantics:

<phase no> specifies  the number  of the user   initialization phase.
If  it is left out,   then one is used.   Currently, there  are three
phases,  numbered 0,  1, and   2.  If  the  demand  is  great enough,
additional phases may  be added later.   (Note for assembly  language
hackers: internally, user phases are numbered '400000, '400001, etc.)


                                 12
Sail Addendum  1                           MISCELLANEOUS NEW FEATURES


6.3 - CHNCDB
      ------


        val_CHNCDB(channel)

This integer procedure returns a pointer to the three word block used
to open the  specified channel.   It is provided  for the benefit  of
assembly language procedures that may want to do I/O inside some fast
inner loop, but which may want to live in a Sail core image & use the
SAIL OPEN, etc.



6.4 - ARRCLR
      ------


        ARRCLR(arry)

This new runtime routine clears any kind of array. That is, arthmetic
arrays get filled with  zeros, string arrays with NULLs,  and itemvar
arrays with ANYs.  One may  use ARRCLR with set and list  arrays, but
the set  and list space  will be lost  (i.e. un-garbage-collectable).
The alternative form:

        ARRCLR(arry,val)


where val is either an integer or a real number, will fill  arry with
that value.  Do not  do this to string  or list arrays unless  you do
not care whether  or not your program  works.  Also using a  real val
for an itemvar array is apt to cause strange results. (If you  use an
integer, arry will be filled with CVI(val).)



6.5 - SETPL
      -----


        SETPL(channel, @linnum, @pagnum, @sosnum)

This new runtime routine allows one to keep track of the string input
from CHANNEL.  Whenever a '12 is encountered, LINNUM  is incremented.
Whenever a '14 is  encountered, PAGNUM is incremented, and  LINNUM is
zeroed.  Whenever  an SOS  line number is  encountered, it  is placed
into SOSNUM.  When  fully implemented (soon),  this will work  on the
INPUT, INTIN, and REALIN functions as well.



                                 13
Sail Addendum  1                           MISCELLANEOUS NEW FEATURES


6.6 - EVALREDEFINE
      ------------


EVALREDEFINE bears  the same relationship  to REDEFINE  as EVALDEFINE
does to DEFINE.  See pages 47 and 50 of the Manual.



6.7 - CVPS
      ----


CVPS(<macro!parameter>)  converts <macro!parameter>  to a  string and
returns the  string. See  about macro  parameters on  page 48  of the
manual.



6.8 - EXPRESSIONS IN REQUIRES
      ----------- -- --------


Previously,  all REQUIRE  constructs had  to have  only  constants in
them. Now  Sail allows  compile time expressions  as well.  See about
compile time expressions on page 47 of the Manual.



6.9 - RELEASE
      -------


RELEASE  now takes  an optional  second argument,  the  CLOSE inhibit
bits.  These are described in the UUO manual (Stanford System). These
are defaulted to zero when  not specified so that old  programs which
did not specify them will work as before.



6.10 - TTYUP
       -----


        oldval_TTYUP(newval)


This  routine casuse  conversion of  lower case  characters  (a-z) to
their upper  case equivalents  for strings  read by  any of  the Sail
teletype routines that do not  use break tables.  If newval  is TRUE,
then conversion will take place on all subsequent inputs  until TTYUP
is called with newval FALSE.  Oldval will always get set to the value


                                 14
Sail Addendum  1                           MISCELLANEOUS NEW FEATURES


of newval used in the previous call. (If TTYUP has never been called,
then no conversions will take place, and the first call to TTYUP will
return FALSE).



6.11 - BREAKSET MODES "K" AND "F"
       -------- ----- --- --- ---


A "K" specification as a BREAKSET mode will cause lower to upper case
conversion when  that break  table is  used.  Conversion  takes place
before each character  is checked for  breaking or omission.   An "F"
specification turns off the conversion -- i.e. it undoes  the effects
of "K".



6.12 - INOUT
       -----


        INOUT(inchan,outchan,howmany)


INOUT reads howmany words from channel inchan and writes them  out on
channel outchan.  Each channel must  be open in a mode between  8 and
12.  on return,  the EOF variables for  the two channels will  be the
same as if ARRYIN & ARRYOUT  had been used.  If howmany is  less than
zero, then transfer  of data will  cease only upon  end of file  or a
device error.

(note: INOUT  uses BLTs  to transfer  data directly  from one  set of
buffers to the other)



6.13 - GETSTS & SETSTS
       ------ - ------


        SETSTS(chan,new!status)

issues a SETSTS uuo on channel chan with the status value new!status.

        status_GETSTS(chan)


returns the results of a GETSTS uuo on channel chan.



                                 15
Sail Addendum  1                           MISCELLANEOUS NEW FEATURES


6.14 - CHANGES TO "OPEN" ERROR HANDLING
       ------- -- ------ ----- --------


If the EOF variable supplied to OPEN is non-zero and the  device name
is  invalid, then  OPEN will  fail without  giving the  error message
"INVALID DEVICE NAME FOR OPEN", and the EOF value will  be unchanged.
If a device is unavailable, and EOF=0, then the user is now given the
options of trying  again or going on  without opening the  device, in
which case EOF will be set to non-zero as usual.



6.15 - ASH
       ---


ASH has  been added as  an arithmetic operator.   Its syntax  is just
like that of LSH, and  it generates similar code (except  for putting
out a PDP-10 ASH instruction instead of a LSH).



6.16 - ARG!LIST
       --------


        ARG!LIST(<arg1>,...,<argn>)


where each <arg> may be any valid argument to the REF!ITEM construct,
assembles a list of "temporary" reference items that will  be deleted
by APPLY after the applied procedure returns.  Thus

        APPLY(proc,ARG!LIST(foo,bar,VALUE baz))

is roughly equivalent to

        tmplst_{{REF!ITEM(foo),REF!ITEM(bar),REF!ITEM(VALUE baz)~~;
        APPLY(proc,tmplst);
        WHILE LENGTH(tmplst) DO DELETE(LOP(tmplst));


but  is  somewhat easier  to  type.  Note  that  the  reference items
created by ARG!LIST are  just like those created by  REF!ITEM, except
that they are marked so that APPLY will know to kill them.






                                 16
Sail Addendum  1                         MINOR CORRECTIONS TO AIM-204


                             SECTION  7
                             -------  -

                    MINOR CORRECTIONS TO AIM-204
                    ----- ----------- -- -------




This is a file of known Sail manual defects (mainly typos) that
are not already noted in the preface or covered by the "incremental"
Sail manual.  It is primarily an internal document for the Sail
hackers, put is being provided here as a stopgap measure pending
a full new edition for the manual.  This list is, however, not
complete in that it does not include a number of typos that do
not change the meaning.  If, however, you discover any defects
in the manual or in the update, please notify your friendly local
Sail representative.

99R     KVL     The synonym for "SUCH THAT" is "|" and not ""

32R     KVL     APPENDIX 5 has nothing to do with the 
                bits for IO errors or mode enablings

43L     RHT     FILEINFO documentation is a lie.  You usually get:

                FILENAME
                EXT,,DATE
                prot(9)Mode(4)time(11)date(12)
                negative swapped word count (if did a lookup).
                0  (unless you opened device in magic mode)
                0

                The whole point is that what you get is the six words
                from the last lookup or enter.  For details see the 
                monitor manual.

58R     JRL     if a designated bracketed triple is not found
                then bindit is returned and no error message is given

33L     JRL     release now takes a second defaultable value integer
                argument, the close inhibit bits (see RELEAS in UUO 
                manual).  These are defaulted to zero when unspecifie

72R     KVL     TELLALL does not do an implicit RESCHEDULE as the 
                description implies -- it just sets the status of
                the concerned processes to "ready".

102R    RFS     "33 through 36" S/B "33 through 35"


                                 17
Sail Addendum  1                         MINOR CORRECTIONS TO AIM-204


105R    RFS     ". her are several"    s/b " . There are several"

79R,L   KVL     JOBTPC should be loaded with the location of a CALL t
                a non-simple procedure. 

92R     JRL     20F will in future surround macro expansions with
                "<>" not "".

38R     RHT     The description of INCHWL is wrong.  Actually, the 
                activation character is never included in the string
                and is always put into !SKIP!.  (<crlf> puts a <cr> 
                into !SKIP! & throws away the <lf>).

24L     RHT     The compiler will not in fact turn division by a powe
                of two into an ASH.

90L     REG     "... See section 19 about these [compilation errors] 
                should be section 20.

90L     REG     19.1.3 "boundary" is misspelled.

41R     RHT     CVSIX left-justifies the sixbit value it builds.

43L     RHT     In POINT, it is "a PDP-10 byte pointer".

45R     RHT     FORC syntax should be "FORC <identifier> _ ... "

57R     RHT     " ... methods of searching the associative store ..."
                had "store" missing before.

105L    RHT     "omaname" should be "the symbolic name"

110L    RHT     added reference:
                Harvey, Brian  "Monitor Command Manual" SAILON 54.3
                (Dec 1973)
                Also, there is a more current SOS manual: SAILON 50.3

76L     RHT     Should be "REF!ITEM(VALUE <expression>)"











                                 18

hVè