
















                                   TYMBASIC

                             SUPPLEMENTAL FEATURES

                                    MANUAL






                                  4 June 1981


                                TYMSHARE, INC.
    


                               TABLE OF CONTENTS



    SECTION I.     TYMBASIC USER FUNCTION LIBRARY


       Introduction                                             2
           Use of User Library Functions                        2


       Terminal I/O                                             3
           Block I/O                                            6


       Interfacing with PERFORM                                 8


       Running Another Program                                  10
           Inter-Program Communication Facility                 13


       Job, User, and System Information                        15


       Dates                                                    26


       Formatted I/O                                            29


       File I/O                                                 31
           Scanning a File Directory                            33


       Array Operations                                         48


       Half-Word Manipulation                                   49


       Extended Escape Control                                  52


       FORTRAN string conversion                                56


       Tymbasic Sort                                            60


       Quick Sort                                               64
    


    SECTION II.     TYMBASIC UTILITY PROGRAMS                   66


       CREF -- Tymbasic Cross Reference Generator               67

       FORMAT -- Tymbasic Program Formatter                     69

       PERTST -- Enhancement for PERFORM files                  71

       TCA -- Tymbasic Conversion Aid                           73



    SECTION III.    INTERFACING WITH TYMQUOTE                   87



    SECTION IV.     INTERFACING WITH X22                        94



    SECTION V.      CONVERSION FROM XBASIC PROGRAMS             97



    INDEX                                                       101
    TYMBASIC Supplemental Features                                   Page 2
       Tymbasic User Function Library


                  SECTION I.  Tymbasic User Function Library                  _______ __  ________ ____ ________ _______


       The functions described here (also referred to as "procedures") are
       available for use in any Tymbasic program, and are intended to
       provide interfaces to some of the Tymcom-X operating system features
       and to supplement the built-in Tymbasic features and library
       functions.

       Use of User Library Functions       ___ __ ____ _______ _________

       The functions are accessed in the same manner as a user-defined
       procedure in Tymbasic.  First, the Tymbasic module that contains the
       call to the function must contain a statement of the form:

            DEF EXTERNAL FUNCTION.NAME(ARGS)

       In some cases, a keyword identifying the language type (i.e.,
       "SIMPL") must be inserted to provide the correct interface to the
       given function;  appearance of this keyword does not otherwise
       affect the use or the behavior of the function.  If the function
       returns a value, then a keyword identifying the type (i.e., INTEGER)
       must also be present.

       In some other cases, an "AKA" clause must appear because the actual
       name of the function contains characters which are illegal as
       identifiers in Tymbasic.  Many of the functions contain such
       characters to prevent conflicts with the names of user-defined
       procedures.

       The DEF statement may appear even if the function is not actually
       called in the Tymbasic module.  This allows the user to maintain a
       list of DEF's that make up a standard part of his Tymbasic module.
       The function will only be loaded into memory from the function
       library if referenced by a call (that is, by the CALL statement or
       by reference to the function from within an expression).

       The file (TBATLIB)DEFS.TBA contains DEF's for all procedures in the
       User Function Library, and may be included as part of any Tymbasic
       program.

       The exact form of the required DEF will be given with each function.
    TYMBASIC Supplemental Features                                   Page 3
       Terminal I/O                                             26 May 1977


       SET.EC
       ------                            Beginning with Ver 2.5

       Form of DEF:

           DEF EXTERNAL SET.EC(LOGICAL L)

       Arguments:

           L is TRUE to set ECHO on and FALSE to set it off.

       Results:

           Sets the Tymbasic ECHOing on or off for the current command
           source and all subsequent command sources (in the case of
           command file stacking).

           SET.EC has exactly the same effect as the ECHO and NO ECHO
           Tymbasic commands, which are not available within a Tymbasic
           program.

       Use:

           SET.EC is useful in writing applications where command files
           will be opened and ECHOing may be desired.
    TYMBASIC Supplemental Features                                   Page 4
       Terminal I/O                                        20 February 1981


       REPROMPT
       --------                        Beginning with Version 5.5

       Form of DEF:

           DEF EXTERNAL REPROMPT(LOGICAL DO.NOT) AKA ".REPRO"

       Arguments:

           DO.NOT is TRUE to disable reprompting after an error during
           terminal input;  FALSE to re-enable reprompting.

       Results:

           If REPROMPT(TRUE) is called, then if an error occurs during
           free-form input from the terminal, Tymbasic will NOT reprompt,
           but will rather generate a TRANSFORM error condition.
           REPROMPT(FALSE) re-enables reprompting.

       Use:

           Starting with Tymbasic Version 5.5, if an incorrect value is
           typed at the terminal in response to a free-form INPUT
           statement, Tymbasic will inform the user of the error and ask
           for new input.  REPROMPT is supplied to allow the user to
           inhibit this behavior.  For example, if

               INPUT I

           is executed, and the user mistakenly types

               1R

           instead of 15, Tymbasic will print

               Illegal character for numeric conversion
               1R
               Please reenter:
               ?

           and the user now has another chance to enter the correct number.

           Note that REPROMPT(TRUE) is called to INHIBIT this feature.
    TYMBASIC Supplemental Features                                   Page 5
       Terminal I/O                                        20 February 1981


       STUFIB
       ------

       Form of DEF:

           DEF EXTERNAL SIMPL STUFIB(STRING S)

       Arguments:

           S is a string containing the characters to be inserted into the
           job's input buffer.  It must contain any carriage returns
           desired;  Tymbasic will not provide a terminating carriage
           return.

       Results:

           Inserts the characters contained in S into the current job's
           terminal input buffer.  There is no guarantee that all
           characters will be inserted -- this depends on the size assigned
           to the input buffer by the operating system, and on the number
           of characters already in the buffer.  The characters inserted
           may be mixed arbitrarily with characters arriving from the
           user's terminal if the user's typing coincides with this call.

       Use:

           STUFIB is useful as a means of inter-program communication when
           short command strings can be used.
    TYMBASIC Supplemental Features                                   Page 6
       Terminal I/O                                        20 February 1981


       Block Output to the Terminal       _____ ______ __ ___ ________

       Overview

       Using block output instead of the normal method can reduce the
       terminal output component of the cost by 35-40%, when driving a 30
       CPS terminal.  Since there is a charge for the time the program
       spends in block output mode, slower terminals will cost more and
       faster ones cost less.  It is not cost-effective to use block output
       for small bursts of output;  each output operation is charged for a
       minimum of 80 characters.  A conservative way to proceed is to
       bracket any portion of the program that runs terminal-bound with
       calls to BEGIN.BLOCK.OUT and END.BLOCK.OUT.

       BEGIN.BLOCK.OUT
       ---------------                   Beginning with Ver 2.4

       Form of DEF

           DEF LOGICAL EXTERNAL SIMPL BEGIN.BLOCK.OUT AKA ".BBO"

       Arguments:

           None.

       Results:

           Returns TRUE if the terminal was put into block output mode.  If
           TRUE, characters currently buffered for output and all further
           terminal-directed output will be transmitted by blocks, until
           END.BLOCK.OUT is called.  Characters will be transmitted when
           the block (400 characters long) is full, rather than when a
           carriage return is output.  Of course, requests for input,
           execution of a WAIT -1 statement, and end of program cause the
           buffered characters to be transmitted just as for normal
           terminal output.
    TYMBASIC Supplemental Features                                   Page 7
       Terminal I/O                                        20 February 1981


       END.BLOCK.OUT
       -------------                      Beginning with Ver 2.4

       Form of DEF:

           DEF EXTERNAL SIMPL END.BLOCK.OUT AKA ".EBO"

       Arguments:

           None.

       Results:

           If the output buffer is not empty, ship it.  Terminate block
           output.
    TYMBASIC Supplemental Features                                   Page 8
       Interfacing with PERFORM                                 13 May 1977


       ST.PER       ______


       Form of DEF:

           DEF LOGICAL EXTERNAL ST.PER

       Arguments:

           None.

       Results:

           If a PERFORM command file is active, ST.PER opens it as the
           Tymbasic commmand file, positions to the next character to be
           input, and returns TRUE.  Otherwise, ST.PER returns FALSE.

       Use:

           It is safe to always call ST.PER at the beginning of the
           program, since it takes no action if it finds no active PERFORM
           command file.  ST.PER should be used in conjunction with EXITPE,
           discussed below.

           Note that when a Tymbasic command file is open, normal terminal
           input is taken from the command file.
    TYMBASIC Supplemental Features                                   Page 9
       Interfacing with Perform                                 13 May 1977


       EXITPE       ______

       Form of DEF:

           DEF EXTERNAL EXITPE

       Arguments:

           None.

       Results:

           If a Tymbasic command file is open, EXITPE writes its current
           cursor position out to the PERFORM cursor file and runs PERFORM;
           otherwise, it deletes the PERFORM command file, if any, and
           returns to XEXEC.

       Use:

           EXITPE should be called only if ST.PER was called earlier in the
           program.

           EXITPE deletes the PERFORM command file if no Tymbasic command
           file is open because it assumes that all the characters have
           been read out of the command file and that Tymbasic
           automatically closed the file.

           If the user wishes to merely exit to PERFORM without having made
           use of the PERFORM command file, he can use the RUNUUO function
           on "(SYS)PERFORM" with a starting offset of 1.

           EXITPE never returns.

           Also, command files may not be nested beyond the PERFORM command
           file at the time of the call.
    TYMBASIC Supplemental Features                                  Page 10
       Running Another Program                                  13 May 1977


       RUNUUO
       ------                            Beginning with ver 2.3

       Form of DEF:                            

           DEF EXTERNAL SIMPL RUNUUO (STRING S, INTEGER I)

       Arguments:

           S is the file nomen (see the Tymbasic Reference Manual) of the
           program to run.

           I is the offset from the startpoint in words at which the
           program is to be started.

       Results:

           RUNUUO runs the specified program at the given startpoint
           (limited to 1 if the user may not read the high segment about to
           be run, else limited to 77B).  If the file nomen specified by S
           is illegal, a FILE error condition results on file unit number
           -9.  If the run fails for any other reason, RUNUUO returns;
           however, all IO channels and various other attributes of the
           program will have been deactivated by the Monitor.  Therefore,
           the program should severely limit its actions following an error
           return from RUNUUO.

       Use:

           The startpoint offset is normally zero or one, the latter
           usually indicating that the RUN has been executed from another
           program (as opposed to the user at the terminal), and that its
           initial input or state vector may be found in an agreed-upon
           command file.  Start-up information is also sometimes passed in
           the registers (see ST.REG, below), or in TMPCOR files (see
           Inter-Program Communication, below).  Many TYMCOM-X utilities
           (PIP, CROSS, all the compilers) use this convention, and all
           programs created with the SAVE BINARY command in Tymbasic may be
           run with an offset of zero or one.  However, not all programs
           can be run with an offset of one.

           A Tymbasic program can examine the offset it was run with by
           looking at the special variable START.POINT.

           The standard convention on TYMCOM-X for one program to
           communicate some data to another is through a TMPCOR file, or a
           .TMP file named in the following manner:  the first three
           characters of the file name are the job number of the current
           job (see index), right-justified, in decimal with zero fill.
           The last three characters make up a unique keyword that
    TYMBASIC Supplemental Features                                  Page 11
       Running Another Program                                  13 May 1977


           identifies the second program.  This is very often the first
           three characters of the program name.  For example, if the
           user's job number is 48, and the program to be run is SAMPLE,
           the file name would be "048SAM.TMP".  SAMPLE will normally take
           its commands out of this file if run with an offset of one.
           However, the file may contain any sort of data meant for
           SAMPLE's consumption.

           Example:

               the program FIRSTP:
               .
               .
               .
               160 OPEN STR(JOBNO,"DDD")+"SAM.TMP-A", OUTPUT,3
               170 PRINT ON 3: "NYC.DAT,1967"
               180 PRINT ON 3: "CHI.DAT,1968"
               190 CLOSE 3
               200 CALL RUNUUO("SAMPLE", 1)
               210 STOP "Cannot run SAMPLE"

               the program SAMPLE:
               .
               .
               .
               100 IF START.POINT=1 THEN !open as command file
               110    OPEN STR(JOBNO,"DDD")+"SAM.TMP",INPUT, -1
               120 ENDIF
               130 INPUT COMMAND.LINE$ !Input the command
    TYMBASIC Supplemental Features                                  Page 12
       Running Another Program                                15 March 1978


       ST.REG       ______
                                       Beginning with Ver 4.5

       Form of DEF:

           DEF INTEGER EXTERNAL SIMPL ST.REG(INTEGER I)

       Arguments:

           I is the register number, from 0 to 17B.

       Results:

           ST.REG returns the contents of register I as they were when the
           program was run.  Like the TBA system-defined variable
           START.POINT, these values only have meaning when a program
           created by the SAVE BINARY command is run, and are zero
           otherwise.  If I is not between 0 and 17B, the resulting value
           is undefined.

       Use:

           Certain program pass information to programs they run through
           registers as well as through temporary files.
    TYMBASIC Supplemental Features                                  Page 13
       Running Another Program - Inter-Program Communication    17 May 1981


       Inter-Program Communication Facility       _____________ _____________ ________

       The Tymbasic User Function Library contains functions and procedures
       that facilitate inter-program communication, by providing a means
       for one program to pass a limited amount of information to another
       program.  This is accomplished via variables which are written into
       by the first program and read by another.

       There are three integer variables and two string variables that may
       be read or written using this facility.  The three integer variables
       and the first string variable are known as the CNC parameters;  the
       second string variable is known as the PICK parameter.  The
       parameters are implemenn Tymcom-X using TMPCOR files.

       Form of DEFs:                           Beginning with Ver 6.1

           DEF INTEGER EXTERNAL CNC(INTEGER INDEX)
           DEF         EXTERNAL WCNC(INTEGER(INDEX,VALUE))
           DEF STRING  EXTERNAL CN$
           DEF         EXTERNAL WCN$(STRING VALUE$)
           DEF STRING  EXTERNAL PICK
           DEF         EXTERNAL WPICK(STRING VALUE$)

       Arguments:

           INDEX is an integer from 1 to 3 indicating which CNC variable is
           to be read or written.  VALUE is the integer value to be
           written, and VALUE$ is the string value to be written.

       Use:

           A procedure must be CALLed to write a parameter;  a function is
           invoked to read a parameter.

           Calling conventions for these functions and procedures are:

               I = CNC(1)
               I = CNC(2)
               I = CNC(3)

               CALL WCNC(1,I)
               CALL WCNC(2,I)
               CALL WCNC(3,I)

               F$ = CN$
               CALL WCN$(F$)

               F$ = PICK
               CALL WPICK(F$)
    TYMBASIC Supplemental Features                                  Page 14
       Running Another Program - Inter-Program Communication    17 May 1981


           Usage notes:

           1.  If a CNC parameter has not yet been written, the CNC
               procedure will return a zero value.

           2.  If the CN$ parameter has not yet been written, the CN$
               procedure will return a null string value.

           3.  Calling the PICK procedure causes the PICK parameter to be
               reset to the null string.

           4.  If the PICK procedure is called when the PICK parameter is
               the null string, it will print

                   Command Parameter:

               at the terminal and wait for the user to enter a value for
               the PICK parameter.



           These procedures and functions may be used in conjunction with
           the PERTST utility (see Section II) when the PERFORM program is
           being used to execute a set of Tymcom-X commands.
    TYMBASIC Supplemental Features                                  Page 15
       Job, User, and System Information                     30 August 1977


       GETPJC
       ------                               Beginning with Ver 3.11

       Form of DEF:

           DEF STRING EXTERNAL GETPJC

       Arguments:

           None.

       Results:

           Returns a string containing the users project code.
    TYMBASIC Supplemental Features                                  Page 16
       Job, User, and System Information


       GET.GFD.PPN
       -----------

       Form of DEF:

           DEF STRING EXTERNAL GET.GFD.PPN

       Arguments:

           None

       Results:

           Returns PPN of GFDed user in the form [account,user number] or
           null string if error.
    TYMBASIC Supplemental Features                                  Page 17
       Job, User, and System Information


       GET.LOG.PPN
       -----------

       Form of DEF:

           DEF STRING EXTERNAL GET.LOG.PPN

       Arguments:

           None

       Results:

           Returns PPN of logged in user in the form [account,user number]
           or null string if error.
    TYMBASIC Supplemental Features                                  Page 18
       Job, User, and System Information


       GET.PROG.NAM
       ------------

       Form of DEF:

           DEF STRING EXTERNAL GET.PROG.NAM

       Arguments:

           None

       Results:

           Returns program name or null string if error.
    TYMBASIC Supplemental Features                                  Page 19
       Job, User, and System Information


       GET.RUN.PPN
       -----------

       Form of DEF:

           DEF STRING EXTERNAL GET.RUN.PPN

       Arguments:

           None

       Results:

           Returns PPN of run-from user in the form [account,user number]
           (or null string if error).  The run-from directory is the
           directory in which the running program is stored.
    TYMBASIC Supplemental Features                                  Page 20
       Job, User, and System Information                      1 August 1980


       ILOG.PPN
       --------

       Form of DEF:

           DEF INTEGER EXTERNAL ILOG.PPN

       Arguments:

           None

       Results:

           PPN of logged in user as an integer.
    TYMBASIC Supplemental Features                                  Page 21
       Job, User, and System Information                      1 August 1980


       IGFD.PPN
       --------

       Form of DEF:

           DEF INTEGER EXTERNAL IGFD.PPN

       Arguments:

           None

       Results:

           PPN of GFDed user as an integer.
    TYMBASIC Supplemental Features                                  Page 22
       Job, User, and System Information                      1 August 1980


       IRUN.PPN
       --------

       Form of DEF:

           DEF INTEGER EXTERNAL IRUN.PPN

       Arguments:

           None

       Results:

           PPN of run from user as an integer.  The run from directory is
           the directory in which the running program is stored.
    TYMBASIC Supplemental Features                                  Page 23
       Job, User, and System Information                     30 August 1977


       IFTP
       ----                             Beginning with Ver 3.3

       Form of DEF:

           DEF LOGICAL EXTERNAL SIMPL IFTP

       Arguments:

           None.

       Results:

           IFTP returns TRUE if the user is Tymshare PROPRIETARY
           (IN-HOUSE), else FALSE.
    TYMBASIC Supplemental Features                                  Page 24
       Job, User, and System Information                     30 August 1977


       JOBNO
       -----                              Beginning with Ver 2.3

       Form of DEF:                            

           DEF INTEGER EXTERNAL JOBNO AKA  ".JOBNO"

       Arguments:

           None.

       Results:

           Returns the integer-valued job number.

       Use:

           The job number is most often used to create file names that are
           unique for temporary files.
    TYMBASIC Supplemental Features                                  Page 25
       Job, User, and System Information                     30 August 1977


       SYSNO
       -----                                Beginning with Ver 3.3

       Form of DEF:

           DEF INTEGER EXTERNAL SIMPLE SYSNO

       Arguments:

           None.

       Results:

           Returns the Tymshare system number of the computer being run.

       Use:

           SYSNO is useful for programs that run on more than 1 system.
    TYMBASIC Supplemental Features                                  Page 26
       Dates                                                    13 May 1977


       FILE.DATE
       ---------                          Beginning with Ver 2.3

       Form of DEF: 

           DEF INTEGER EXTERNAL SIMPL FILE.DATE(STRING F)

       Arguments:

           F contains a file nomen.

       Results:

           Returns -1 if the file nomen is illegal or if the specified file
           cannot be opened for input.  Otherwise returns the creation date
           of the file as an integer in the following format:  days since
           Jan 1 1964 ,, seconds since midnight in Greenwich time.

       Use:

           FILE.DATE is useful for file date comparisons in which the
           converted string representing the date in the user's time zone
           is not needed (see DT.CNV) or in which a comparison needs to be
           made that includes the time down to the second.
    TYMBASIC Supplemental Features                                  Page 27
       Dates                                                    13 May 1977


       DAY.NO
       ------                            Beginning with Ver. 3.3

       Form of DEF:

           DEF INTEGER EXTERNAL DAY.NO(STRING YY.MM.DD)

       Arguments:

           YY.MM.DD is a string of the form "YY/MM/DD" where

           1.  All characters other than the slashes must be numeric.

           2.  The day number must be present but may have any positive
               value.

           3.  The month number must be present but may have any value.  If
               MM is greater than 12, it is adjusted to be in the range
               1-12 and the appropriate number of years is added to YY
               before YY is validated.

           4.  The year number must be present and must be either in the
               range 1964-2063 or in the range 0-99.  Years 0 through 63
               are interpreted as 2000 through 2063, and years 64-99 are
               interpreted as 1964-1999.


       Results:

           DAY.NO returns an integer which is the number of days since
           December 31, 1963 indicated by the input date string.  If any
           error occurs, DAY.NO returns zero.

       Use:

           DAY.NO converts dates from a string form to a numeric form.

       WARNING:  DAY.NO arms and dis-arms the TRANSFORM ON-condition.
    TYMBASIC Supplemental Features                                  Page 28
       Dates                                                    13 May 1977


       DT.CNV
       ------                            Beginning with Ver 2.3

       Form of DEF:                            

           DEF STRING EXTERNAL DT.CNV(INTEGER D)

       Arguments:

           D is an integer representing a date in the following format
           (returned by FILE.DATE):  days since Jan 1, 1964 ,, seconds
           since midnight in Greenwich time.

       Results:

           DT.CNV returns a 15 character string of the form 
           YY/MM/DD  HH:MM

       Use:

           DT.CNV converts file dates into a form that is printable and
           that can still be used to compare dates.
    TYMBASIC Supplemental Features                                  Page 29
       Formatted I/O                                       20 February 1981


       SET.FLDOVF.CH
       -------------                   Beginning with Version 5.5

       Form of DEF:

           DEF EXTERNAL SET.FLDOVF.CH(INTEGER CH.CODE) AKA ".FLDOC"

       Arguments:

           CH.CODE is the character code of the character used to fill
           format fields that overflow.  If zero is specified, fill on
           field overflow will be inhibited, and Tymbasic will return to
           its normal mode of treating field overflow.  To specify a
           character in quotation marks, one uses the ASC function.  For
           example, if the desired character is "*", then CH.CODE would be
           ASC("*").

       Results:

           Use of the SET.FLDOVF.CH procedure causes Tymbasic to substitute
           a string of the specified character for a field, instead of
           generating an error, when a value being PRINTed using IMAGE or
           FORM formatting is too large for the field.

       Use:

           Under normal operation, if a value being PRINTed using IMAGE or
           FORM formatting is too large for the specified field, an error
           condition is generated.

           However, SET.FLDOVF.CH causes Tymbasic to substitute a certain
           string of characters for the field, instead of generating an
           error condition.  The character passed as an argument to
           SET.FLDOVF.CH will be repeated as many times as necessary to
           fill the field.  For example, to cause a string of asterisks to
           be printed for all fields that otherwise would have overflowed
           and generated an error condition, one would execute:

               CALL SET.FLDOVF.CH(ASC("*"))

           Then, if the following was executed:

               PRINT IN FORM "3(DD.DD B)":  43.78, 4762.17, 19.43

           the following output would be generated:

               43.78 ***** 19.43

           Calling SET.FLDOVF.CH(0) will cause Tymbasic to return to its
           normal manner of handling field overflow.
    TYMBASIC Supplemental Features                                  Page 30
       Formatted I/O                                       20 February 1981


       BLANK.ZFP
       ---------                       Beginning with Version 5.5

       Form of DEF:

           DEF EXTERNAL BLANK.ZFP(LOGICAL DO.IT) AKA ".BLZFP"

       Arguments:

           DO.IT is TRUE to cause the decimal point and fractional part of
           a field to be replaced by blanks when the value being printed is
           zero.  DO.IT is FALSE to cause Tymbasic to return to its normal
           manner of printing zero values.

       Results:

           If a value being printed by a PRINT statement using IMAGE or
           FORM formatting is equal to zero, and there is no exponent part
           in the field used to print the value, and BLANK.ZFP(TRUE) has
           been called, then the decimal point and the fractional part
           places will be replaced by blanks.  The integer part will not be
           affected;  if Z, Y or Q format was used, blanks will appear as
           usual.

           Example:

           If you execute

               CALL BLANK.ZFP(TRUE) then:

               ZZZ.DD  prints  0       as      6 spaces
                               5.0     as      5.00
                               .01     as      .01
    TYMBASIC Supplemental Features                                  Page 31
       File I/O                                                 13 May 1977


       FILE.PARSE
       ----------                         Beginning with Ver 4.2



       Form of DEF:                            

            DEF INTEGER EXTERNAL FILE.PARSE (STRING F,  &
                       STRING A(*)) AKA "FL.PRS"

       Arguments:

           F is a string containing the file nomen (see Tymbasic Reference
           Manual).

           A is a string array in which will be returned the components of
           the file nomen.

       Results:

           FILE.PARSE returns zero if there are no syntactic errors in the
           file nomen;  otherwise, it returns the error number.  The string
           array A is filled as follows:

               A(1) - username in parentheses or ppn in brackets
                      or null string
               A(2) - file name, up to six characters, or "TERMIN" if the
                      file nomen specifies the terminal
               A(3) - extension, up to three characters, including the
                      period if one appeared (else null string)
               A(4) - confirmation, if any (else null string), including
                      the hyphen, as four characters, "-NEW", "-ANY", or
                      "-EXI"

           For example the file nomen "(Tba.user)Program.tba-e" would
           result in:

               A(1) = "(TBA.USER)"
               A(2) = "PROGRA"
               A(3) = ".TBA"
               A(4) = "-EXI"

           Note the upper case results.


       Use:

           The use of FILE.PARSE guarantees an error-free file nomen parse
           that is identical to the one used throughout Tymbasic.
    TYMBASIC Supplemental Features                                  Page 32
       File I/O                                                 13 May 1977


       GET.UN
       ------                             Beginning with Ver 2.3

       Form of DEF:                           

           DEF INTEGER EXTERNAL GET.UN

       Arguments:

           None.

       Results:

           Returns the first free Tymbasic file unit number, or zero if
           none are free.

       Use:

           GET.UN is important in writing procedures that must open a file
           but do not know which file unit numbers are in use.  Example:

               135 OPEN F$+".DAT", BINARY INPUT, I WHERE I=GET.UN
    TYMBASIC Supplemental Features                                  Page 33
       File I/O - Scanning a File Directory                     13 May 1977


       Overview of UFD SCAN package       ________ __ ___ ____ _______

       This set of procedures is designed to scan a specified UFD (User
       File Directory) and return all occurences of a specified file name
       and extension, and optionally the file's size, creation date,
       license, and status.  The file name and extension may include "wild
       carding" using "#" for the character wild card, and "*" for the name
       or extension wild card.  The UFD is not scanned in any particular
       order.

        The procedures are:

          FD.OPEN  - Open the UFD specified by the username.
          FD.WILD  - Specify file name and extension with 
                     wild carding.
          FD.EXACT - Specify file name and extension without 
                     wild carding.
          FD.STEP  - Advance to next file name.
          FD.QUERY - Did the last call to FD.STEP find another 
                     file name?
          FD.NAME  - Return current file name.
          FD.EXT   - Return current file extension.
          FD.SIZE  - Return current file size.
          FD.LIC   - Return current file license.
          FD.DATE  - Return current file date and time.
          FD.STAT  - Return current file status.
          FD.SET   - Set buffer size and enable optional file values.
          FD.CLOSE - Close current UFD.

       All of these procedures are callable as EXTERNAL TBA procedures.

    TYMBASIC Supplemental Features                                  Page 34
       File I/O - Scanning a File Directory                     13 May 1977


       The following artificial example may provide some insights:

          100 print "Directory: ":
          110 input in form "R": dir$
          120 if fd.open(dir$) then
          130   print "File name: ":
          140   input in form "R": fnam$
          150   if fnam$ # "" then
          160     print "File extension: ":
          170     input in form "R": fext$
          180     call fd.wild(fnam$,fext$)
          190     if fd.step then
          200       tnam$ = fd.name
          210       text$ = fd.ext
          220       tsize = fd.size
          230       tlic = fd.lic
          240       tdate = fd.date
          250       tstat = fd.stat
                        .
                        .
                        .
                        .
          390       go to 190
          400     endif
          410     go to 130
          420   endif
          430   call fd.close
          440 endif
          450 go to 100
    TYMBASIC Supplemental Features                                  Page 35
       File I/O - Scanning a File Directory                     13 May 1977


       FD.OPEN
       -------                            Beginning with Ver 2.3

       Form of DEF:                           

           DEF LOGICAL EXTERNAL FD.OPEN(STRING UFD.NAME)

       Arguments:

           UFD.NAME is the name of the directory (username) to scan.
           If it is null then the current directory is specified
           (the directory GFD'ed to).

       Results:

           FD.OPEN returns true if the directory was successfully opened
           and false if the username is too long.  Any other error will
           cause a FILE error condition to occur on unit -9 (which can be
           trapped with an ON statement).  FD.OPEN prepares a UFD for
           scanning, and enables the routines FD.STEP, FD.QUERY, FD.NAME,
           FD.EXT, FD.SIZE, FD.LIC, FD.DATE and FD.STAT (they return null
           values (false, zero, or null) until FD.OPEN has been
           successfully called).
    TYMBASIC Supplemental Features                                  Page 36
       File I/O - Scanning a File Directory                     13 May 1977


       FD.CLOSE
       --------                           Beginning with Ver 2.3

       Form of DEF:                           

           DEF EXTERNAL FD.CLOSE

       Arguments:

           None.

       Results:

           If a file directory has been successfully opened by FD.OPEN then
           it is closed and all internal buffers are released.  The
           routines FD.STEP, FD.QUERY, FD.NAME, FD.EXT, FD.SIZE, FD.LIC,
           FD.DATE and FD.STAT are disabled (will return null values) until
           FD.OPEN is again successfully called.
    TYMBASIC Supplemental Features                                  Page 37
       File I/O - Scanning a File Directory                     13 May 1977


       FD.STEP
       -------                           Beginning with Ver 2.3

       Form of DEF:

           DEF LOGICAL EXTERNAL FD.STEP

       Arguments:

           None.

       Results:

           FD.STEP advances the file name scan to the next specified file
           name and extension, if any.  Note that a call to FD.WILD or
           FD.EXACT does NOT locate the first match;  a call to FD.STEP
           must be made to do that.  FD.STEP will return true if another
           file name is found that matches the name given to FD.WILD or
           FD.EXACT, otherwise it will return false.
    TYMBASIC Supplemental Features                                  Page 38
       File I/O - Scanning a File Directory                     13 May 1977


       FD.EXACT
       --------                         Beginning with Ver 2.3

       Form of DEF:

           DEF EXTERNAL FD.EXACT(STRING (FILENAME, EXTENSION))

       Arguments:

           FILENAME is the file name. It will be truncated to six
           characters. EXTENSION is the extension. It will be truncated
           to three characters.

       Results:

           FD.EXACT specifies a file name and extension to be searched for
           within the UFD.  Special characters within the file name or
           extension are taken literally so that non-standard file names
           can be found.  FD.EXACT does not find the file;  FD.STEP must be
           used for that purpose.
    TYMBASIC Supplemental Features                                  Page 39
       File I/O - Scanning a File Directory                     13 May 1977


       FD.WILD
       -------                          Beginning with Ver 2.3

       Form of DEF:

           DEF EXTERNAL FD.WILD(STRING (FILENAME,EXTENSION))

       Arguments:

           FILENAME is the file name.  It will be truncated to six
           characters.  EXTENSION is the extension.  It will be truncated
           to three characters.

       Results:

           FD.WILD specifies a file name and extension to be searched for
           within the UFD.  The wild card characters "#" and "*" will match
           any character and any file name or extension, respectively.
           FD.WILD does not find the first match on the specified name;
           FD.STEP must be used for that purpose.
    TYMBASIC Supplemental Features                                  Page 40
       File I/O - Scanning a File Directory                     13 May 1977


       FD.QUERY
       --------                        Beginning with Ver 2.3

       Form of DEF:

           DEF LOGICAL EXTERNAL FD.QUERY

       Arguments:

           None.

       Results:

           FD.QUERY returns the value returned by the last call to FD.STEP
           (or false if no call to FD.STEP has been made since the last
           successful call to FD.OPEN).  Thus, FD.QUERY will return true if
           there is a match and false if not.

       Use:

           FD.QUERY is useful when the programmer wants to know if file
           information is available without advancing to the next match.
    TYMBASIC Supplemental Features                                  Page 41
       File I/O - Scanning a File Directory                     13 May 1977


       FD.SET
       ------                          Beginning with Ver 2.3

       Form of DEF:

           DEF EXTERNAL FD.SET(INTEGER (BUFFER.LENGTH,CONTROL.CODE))

       Arguments:

           BUFFER.LENGTH specifies the length to be used for the UFD SCAN
           internal buffer.  If BUFFER.LENGTH is negative, then no change
           is specified.  If it is zero or one, then a length of 100 is
           specified.

           When FD.STEP is initially called after a call to FD.OPEN, it
           asks the monitor to fill its internal buffer with data
           describing the file names which match the specified file name
           and extension.  The monitor only puts as many entries into the
           buffer as will fit.  When FD.STEP exhausts the data in that
           buffer, it requests another.  Each entry in the buffer takes two
           words plus one word for each of the following if requested:
           size, date, license and status (all four are requested unless
           the user specifies otherwise in this call).

           CONTROL.CODE specifies which data items are requested as
           follows:
               bit 32 - fetch file size (enable FD.SIZE) if 1
               bit 33 - fetch license (enable FD.LIC) if 1
               bit 34 - fetch date (enable FD.DATE) if 1
               bit 35 - fetch status (enable FD.STAT) if 1

           If CONTROL.CODE is negative then no change is specified.

       Results:

           FD.SET sets the buffer length parameter and enables or disables
           the capture of certain data items for the next call to FD.WILD
           or FD.EXACT.

       Use:

           FD.SET is used in applications where core space or the overhead
           of making monitor calls is critical.  If the buffer length is
           large, less monitor calls are made;  if less data items are
           requested, a smaller buffer will suffice.
    TYMBASIC Supplemental Features                                  Page 42
       File I/O - Scanning a File Directory                     13 May 1977


       FD.NAME
       -------                         Beginning with Ver 2.3

       Form of DEF:

           DEF STRING EXTERNAL FD.NAME

       Arguments:

           None.

       Results:

           If FD.QUERY would currently return TRUE then this function
           returns the current file name. Otherwise, it returns a null
           string.
    TYMBASIC Supplemental Features                                  Page 43
       File I/O - Scanning a File Directory                     13 May 1977


       FD.EXT
       ------                          Beginning with Ver 2.3

       Form of DEF:

           DEF STRING EXTERNAL FD.EXT

       Arguments:

           None

       Results:

           If FD.QUERY would currently return TRUE then this function
           returns the current file extension.  Otherwise it returns a null
           string.
    TYMBASIC Supplemental Features                                  Page 44
       File I/O - Scanning a File Directory                     13 May 1977


       FD.SIZE
       -------                        Beginning with Ver 2.3

       Form of DEF:

           DEF INTEGER EXTERNAL FD.SIZE

       Arguments:

           None

       Results:

           If FD.QUERY would currently return TRUE then this routine
           returns the current file size in blocks (unless FD.SIZE is
           disabled - see FD.SET).  Otherwise, it returns a minus one.
    TYMBASIC Supplemental Features                                  Page 45
       File I/O - Scanning a File Directory                     13 May 1977


       FD.LIC
       ------                          Beginning with Ver 2.3

       Form of DEF:

           DEF INTEGER EXTERNAL FD.LIC

       Arguments:

           None.

       Results:

           If FD.QUERY would currently return TRUE then this routine
           returns the current file license (unless FD.LIC is disabled -
           see FD.SET).  Otherwise, it returns a minus one.
    TYMBASIC Supplemental Features                                  Page 46
       File I/O - Scanning a File Directory                     13 May 1977


       FD.DATE
       -------                         Beginning with Ver 2.3

       Form of DEF:

           DEF INTEGER EXTERNAL FD.DATE

       Arguments:

           None.

       Results:

           If FD.QUERY would currently return TRUE then this routine
           returns the current file date and time in the following format:
           days since Jan 1, 1964,,seconds since midnight in Greenwich time
           (unless FD.DATE is disabled - see FD.SET).  Otherwise, it
           returns a minus one.
    TYMBASIC Supplemental Features                                  Page 47
       File I/O - Scanning a File Directory                     13 May 1977


       FD.STAT
       -------                        Beginning with Ver 2.3

       Form of DEF:

           DEF INTEGER EXTERNAL FD.STAT

       Arguments:

           None.

       Results:

           If FD.QUERY would currently return TRUE then this routine
           returns the file status as below (unless FD.STAT is disabled -
           see FD.SET).  Otherwise, it returns a minus one.

                     bits 26-35 = file protection
                     bits 23-26 = bits 8-11 from extended lookup word 14
                     bits 19-22 = bits 4-7 from extended lookup word 14
                     bits 17-18 = bits 2-3 from extended lookup word 14
                     bits 15-16 = bits 0-1 from extended lookup word 14

       Use:

           Bit 4 from extended lookup word 14 is the "file dumped" bit and
           indicates that the file has been written to backup tape.

           Bit 8 is the "file temporary" bit and indicates that the file
           will be automatically deleted upon GFD or LOGOUT.

           The protection is a 9-bit field consisting of three three-bit
           codes.  The first applies to the user himself, the second to all
           users in the same account, the third to any user.

           The codes are:

               0    ALL
               1    CP
               2    UFD
               3    AP
               4    RD
               5    RUN
               6    LK
               7    NO

           See File Protection in the Tymshare XEXEC manual for a
           description of each of these codes.
    TYMBASIC Supplemental Features                                  Page 48
       Array Operations                                         13 May 1977


       ARRAY.BOUNDS
       ------------                        Beginning with Ver 2.4

       Form of DEF:

           DEF INTEGER EXTERNAL ARRAY.BOUNDS(*) &
               (type A(*,*,...)) AKA "BND.AR"

           For the word "type" the user should substitute the type of the
           array he wishes to pass to ARRAY.BOUNDS.  He should also specify
           the number of dimensions of the array by including the proper
           number of asterisks as shown above.

           To pass arrays of differing types or dimensionalities to
           ARRAY.BOUNDS the module should contain one DEF for each needed
           type/dimensionality combination with a unique procedure name but
           containing identical AKA clauses.  For example:

           DEF INTEGER EXTERNAL INT.BOUNDS.1(*)(INTEGER A(*)) AKA "BND.AR"
           DEF INTEGER EXTERNAL REAL.BOUNDS.2(*)(REAL A(*,*)) AKA "BND.AR"

       Arguments:

           A is any array.

       Results:

           ARRAY.BOUNDS returns a one-dimensional integer array that
           contains one element for every dimension of the argument array.
           Each element contains the bounds pair for that dimension:  the
           lower bound in the left half of the integer, the upper bound in
           the right half.

       Use:

           ARRAY.BOUNDS is useful in procedures that expect an array
           argument but do not know the bounds.

           To extract the bounds pairs:

               INTEGER BOUNDS(1:N) !N is the dimensionality
               BOUNDS = INT.BOUNDS.1(SOME.INT.ARRAY)
               LOWER.BOUND.1 = RSH(BOUNDS(1), 18)
               UPPER.BOUND.1 = BOUNDS(1) BAN 777777B
    TYMBASIC Supplemental Features                                  Page 49
       Half-word Manipulation                                   2 June 1977


       RH       __

       Form of DEF:

           DEF INTEGER EXTERNAL SIMPL RH(INTEGER I) AKA ".RH"

       Arguments:

           I is any integer.

       Results:

           RH returns the right half-word of I as an integer.  This is bits
           18-35 in DEC terminology.  The left half of the result is always
           zero.
    TYMBASIC Supplemental Features                                  Page 50
       Half-word Manipulation                                   2 June 1977


       LH       __

       Form of DEF:

           DEF INTEGER EXTERNAL SIMPL LH(INTEGER I) AKA ".LH"

       Arguments:

           I is any integer.

       Results:

           LH returns the left half-word of I as an integer.  This is bits
           0-17 in DEC terminology.  The left half of the result is always
           zero.
    TYMBASIC Supplemental Features                                  Page 51
       Half-word Manipulation                                   2 June 1977


       XWD       ___

       Form of DEF:

           DEF INTEGER EXTERNAL SIMPL XWD(INTEGER (I,J)) AKA ".XWD"

       Arguments:

           I and J are integers.

       Results:

           XWD returns an integer whose left half-word is the right
           half-word of I and whose right half-word is the right half-word
           of J.  The left half-words of I and J are ignored.
    TYMBASIC Supplemental Features                                  Page 52
       Extended Escape Control                                  2 June 1977


                         DISABLE, ENABLE, and CENABLE


       The following three routines have been added to the User Function
       Library for the purpose of extending the user's escape control,
       specifically to give the user the ability to temporarily disable
       escapes.
    TYMBASIC Supplemental Features                                  Page 53
       Extended Escape Control


       DISABLE       _______
                                        Beginning with Ver 4.5

       Form of DEF:

            DEF EXTERNAL DISABLE AKA ".DISABLE"

       Arguments:

            None.

       Results:

            DISABLE disables escapes and increments an internal cell whose
            initial value is zero.  The internal cell is used for
            communication between DISABLE, ENABLE, and CENABLE.

            Whenever escapes have been disabled by DISABLE, any escapes
            that occur will be ignored.  They will, however, be remembered
            and will take effect as soon as ENABLE or CENABLE re-enables
            escapes.
    TYMBASIC Supplemental Features                                  Page 54
       Extended Escape Control


       ENABLE       ______
                                        Beginning with Ver 4.5

       Form of DEF:

            DEF EXTERNAL ENABLE AKA ".ENABLE"

       Arguments:

            None.

       Results:

            ENABLE decrements an internal cell which is incremented by
            DISABLE.  If the value of the decremented cell is less than or
            equal to zero then ENABLE zeroes the cell and re-enables
            escapes.  Any escapes which were not honored because of a
            previous call to DISABLE will occur at this time.
    TYMBASIC Supplemental Features                                  Page 55
       Extended Escape Control


       CENABLE       _______
                                        Beginning with Ver 4.5

       Form of DEF:

            DEF EXTERNAL CENABLE AKA ".CENABLE"

       Arguments:

            None.

       Results:

            CENABLE zeroes the internal cell used by DISABLE and ENABLE and
            then re-enables escapes.  Any escapes which were not honored
            because of a previous call to DISABLE will occur at this time.
    TYMBASIC Supplemental Features                                  Page 56
       FORTRAN string conversion


       F.CHR       _____

       Form of DEF:

         DEF STRING EXTERNAL F.CHR(INTEGER I)

       Arguments:

           I is an integer containing a FORTRAN string.

       Results:

           F.CHR returns a TBA string of 5 or fewer characters.

       Use:

           F.CHR is useful in converting a FORTRAN string of 5 or fewer
           characters to a TBA string.
    TYMBASIC Supplemental Features                                  Page 57
       FORTRAN string conversion


       F.ASC       _____

       Form of DEF:

           DEF INTEGER EXTERNAL F.ASC(STRING S)

       Arguments

           S contains a TBA string.

       Results:

           F.ASC returns an integer containing a FORTRAN string
           coresponding to the first five characters of S.  If S contains
           less than five characters, it is padded on the right with
           spaces.

       Use:

           F.ASC is useful in converting a TBA string of 5 or fewer
           characters to a FORTRAN string.
    TYMBASIC Supplemental Features                                  Page 58
       FORTRAN string conversion


       F.CHRA       ______

       Form of DEF:

           DEF STRING EXTERNAL F.CHRA(INTEGER K(*))

       Arguments:

           K is an integer array of one dimension which contains a FORTRAN
           string.

       Results:

           F.CHRA returns the coresponding TBA string.

       Use:

           F.CHRA is useful in converting FORTRAN strings that may be
           longer than 5 characters to a TBA string.
    TYMBASIC Supplemental Features                                  Page 59
       FORTRAN string conversion


       F.ASCA       ______

       Form of DEF:

           DEF INTEGER EXTERNAL F.ASCA(*)(STRING S)

       Arguments:

           S is a TBA string of any length.

       Results:

           F.ASCA returns a integer array of one dimension that contains
           the coresponding FORTRAN string.

       Use:

           F.ASCA is useful in converting a TBA string of any length to a
           FORTRAN string.
    TYMBASIC Supplemental Features                                  Page 60
       Tymbasic Sort                                       1 September 1977


       SORT                                Beginning with Ver 6.1       ____

       Form of DEF:

           DEF EXTERNAL SORT(Input.File$, Output.File$, Cmd.String$)

       Arguments:

           Input.File$ and Output.File$ are string expressions containing
           standard Tymbasic file nomens.  If no confirmation keyword is
           given for the output file, the user will be prompted when it is
           opened.  The output file may be the same as the input file.  The
           terminal may be specified as the output file, but not as the
           input file.

           Cmd.String$ is a string expression containing the sort keys and
           the maximum record length in the form:

             /switch /switch ...

           There are two switches which may be used:

             /Kabcm.n  The Key switch, /K, defines the sort key according
                       to the following parameters:

                          a = S (Signed) The field has an operational sign
                                (+ or -).  If no sign is present in a
                                field, it is assumed to be positive.
                          a = U (Unsigned) The field has no operational
                                sign;  any negative sign is ignored.

                       If this parameter is omitted, the default value is
                       S.  If the field type is alphanumeric, this
                       parameter is ignored.

                          b = X (Alphanumeric) The field is alphanumeric.
                          b = N (Numeric) The field is numeric (see below).

                       If this parameter is omitted, the default is X if
                       the sign parameter (a) is also omitted.  If this
                       parameter is omitted and the sign parameter is
                       included, the default is N.

                          c = A (Ascending) The field is to be sorted in
                                ascending order.
                          c = D (Descending) The field is to be sorted in
                                descending order.
    TYMBASIC Supplemental Features                                  Page 61
       Tymbasic Sort                                       1 September 1977


                       If this parameter is omitted, the field is sorted in
                       ascending order.

                          m     is the starting character position of the
                                field, with the first character on a line
                                being in position 1.  Each control
                                character, incuding a tab (control-I),
                                counts as one character.
                          n     is the size of the field in characters.

                       More than one key may be entered with the /K switch
                       if the keys are separated from one another by commas
                       (e.g., /Kabcm.n,abcm.n...).  Equivalently, the /K
                       switch may be used more than once (e.g.,
                       /Kabcm.n/Kabcm.n...).  Up to twenty keys may be
                       specified, and the fields may overlap.  The file is
                       sorted according to the order of the keys, with the
                       key entered first being most important.

             /Rm       The Record size switch, /R, indicates the maximum
                       record size, where m is the maximum length in
                       characters.  (not including the carriage return -
                       linefeed).  The default value is 80 characters, and
                       the maximum is 4095.  If a line is encountered
                       during the sort with a length greater than m, it
                       will be truncated on the right.  The number of
                       records which will fit in core increases as the
                       record size gets smaller, so a small record size may
                       result in faster execution time.  If more than one
                       /R switch is specified, an error will occur unless
                       the values are equal.

           Any combination of one or more of these switches may be put in
           the command string.  If the command string is empty, SORT will
           return without doing anything.  If the command string is not
           empty but there are no /K switches, an error condition will
           occur, with its associated message (see below).

           Any of the arguments to the SORT call may be any combination of
           upper and lower case.

       Results:

           SORT sorts any variable length record symbolic file on numeric
           and alphanumeric keys.  The data from the specified input file
           are sorted according to the contents of the command string and
           written to the specified output file.
    TYMBASIC Supplemental Features                                  Page 62
       Tymbasic Sort                                       1 September 1977


       Numeric Fields

           A numeric field is a set of numeric characters ("0" through "9")
           which form an integer.  A numeric field may have a + or - sign
           preceding the first digit.  An unsigned field is assumed to be
           positive.  The number in a field is terminated either by a
           non-numeric character or by the end-of-field, whichever comes
           first.  Any leading spaces or tabs are ignored, but an imbedded
           space or tab will terminate the number.

       Order of Sorting

           Numeric fields are sorted in ascending or descending order
           according to the numeric value of the field.  Alphanumeric
           fields are sorted character by character using the order
           currently in the ASCTABLE array.  (See the Tymbasic Reference
           Manual for details.) This allows the user to specify a
           nonstandard collating sequence for the sort.  If ASCTABLE is not
           changed by the user program, the standard ASCII collating
           sequence will be used.

       Value of SORT

           If the user desires, SORT can be used as a function, returning
           as its value the number of lines which were sorted.  To do this,
           SORT must be declared as an integer function with this
           statement:

                DEF INTEGER EXTERNAL SORT(IN$,OUT$,COM$)

           If this statement is used to define it, SORT may be used like a
           Tymbasic function.

       Examples

           The statement below will cause the sorting of the file SORT.IN
           on two alphanumeric keys, an 8 character field starting in
           position 5 and a 2 character field starting in position 3.

                CALL SORT("SORT.IN","SORTED.OUT","/KXA5.8/KXA3.2")

           Since no maximum record length is specified, it will be assumed
           to be 80.  The sorted output will go the the file SORTED.OUT,
           and the user will be prompted when it is opened.

           The following statements will cause the file DATA.A to be sorted
           onto itself.  SORT must have been declared as an integer
           function as shown above.  No prompting will take place.
    TYMBASIC Supplemental Features                                  Page 63
       Tymbasic Sort                                       1 September 1977


                COMSTR$="/KXA2.9,ND7.5/R55"
                RECORDS=SORT("DATA.A","DATA.A-E",COMSTR$)

           This will sort on an alphanumeric key in positions 2-10 and a
           numeric key in positions 7-11.  The numeric key will be sorted
           in descending order.  Note that the keys may overlap.  The
           maximum record length is specified to be 55 characters.  The
           number of lines which were sorted will be placed in the variable
           RECORDS.

       Errors

           One error message has been defined in Tymbasic to handle errors
           in SORT.  It has been given number 163 and is "Error encountered
           during SORT".  Before this message is printed, a more explicit
           message will be printed by SORT itself.  This allows errors in
           SORT to be trapped in the same manner as other Tymbasic errors.
           Error messages which may be received are:

               Improper SORT command string
               'x' is not a valid switch
               Only one /R allowed
               Record size must be greater than zero
               Record size must be less than 4095
               Too many keys
               Improper /K
               No keys specified
               Key m.n is outside record
               Key m.n has zero length

           Errors in opening the input or output file will be trapped as
           file error conditions on file unit number -9, and a file error
           message will be printed.

           If any other error message is received, it may be due to a
           problem within SORT and should be reported to Tymshare.

       Escapes

           Escapes are not currently supported within SORT.  If one is
           received, temporary files may be left open and temporary storage
           may not be disposed of properly.  If a restart is attempted
           after an escape, SORT is likely not to work, and the program
           will have to be restarted or loaded again.
    TYMBASIC Supplemental Features                                  Page 64
       Quick Sort


       QCKSRT       ______

       Form of def:

           Def Integer External Qcksrt(*)(integer n.recs)

       Arguments:

           n.recs is the number of records to be sorted

       Results:

           return an integer array containing a sorted list of record
           numbers.

       User-Supplied Procedure:

           Qcksrt calls a user-supplied procedure with the following DEF:

               DEF INTEGER EXTERNAL CMPARE(INTEGER(P1,P2))

           when CMPARE is called, P1 and P2 will be in the range 1 through
           N.RECS.  The procedure CMPARE must compare record P1 with record
           P2, using whatever compare algorithm is suitable for this sort,
           and return an intger -1,0, or 1 depending on whether record P1
           is less than, equal to, or greater than record P2.

       Use:

           This routine uses a very fast sort algorithm, and, since the
           compare is written by the user for his particular records, it
           can handle records of any complexity whatever without having to
           resort to an obscure command language.

       Example:
    TYMBASIC Supplemental Features                                  Page 65
       Quick Sort


       10 ! sample driver for the in-core quicksort.
       20 !
       30 ! We sort employees by month of review date and by name.
       40 !
       50 def integer external qcksrt(*) ( integer n.recs)
       100 data Frank, Nov
       110 data John, Oct
       120 data Carl, Jan
       130 data Mike, Jun
       140 data Lee, Jan
       150 data Allen, Dec
       160 data Karen, Dec
       170 data Polle, Jun
       180 data Dick, Dec
       190 data Don, Feb
       200 !
       210 integer i, num.records
       220 num.records = 9
       230 integer sorted( num.records)
       240 string field1(num.records), field2(num.records)
       250 read field2(i), field1(i) for i=1 to num.records
       260 sorted = qcksrt( num.records)
       270 print field1(sorted(i)), field2(sorted(i)) for i=1 to &
            num.records
       280 stop
       290 !
       300 !
       310 def integer entry scomp( integer ( p1, p2)) aka "CMPARE"
       320   integer result
       330   ! = = = = !
       340   result = comp( field1(p1), field1(p2))
       350   if result 0 then exit result else exit comp(field2(p1) &
              ,field2(p2))
       360 endf scomp
    TYMBASIC Supplemental Features                                  Page 66
       Tymbasic Utility Programs


                    SECTION II.  Tymbasic Utility Programs                    _______ ___  ________ _______ ________



       The programs described in this section are run independently from
       Tymbasic, and provide helpful functions not available within the
       Tymbasic system itself.

       All the programs reside in username (TBATLIB).  So, for example, to
       run the Tymbasic Program Formatter, one would type

           -RUN (TBATLIB)FORMAT
    TYMBASIC Supplemental Features                                  Page 67
       CREF:  Tymbasic Cross Reference Generator


       CREF:  Tymbasic Cross Reference Generator       _____  ________ _____ _________ _________


       When developing a program, especially a large or complicated one, it
       is very useful to have, along with a listing of the program, a list
       of where each variable is defined or referenced.  The CREF program
       provides this capability, much as does the XEXEC CREF program, but
       the Tymbasic CREF understands the long variable names that may occur
       in Tymbasic programs, whereas the XEXEC CREF program limits its
       knowledge of variable names to 6 characters.  The Tymbasic CREF also
       produces a table of the procedural block structure of the program.

       In order to produce a cross reference for your program, you must
       first type

           >DUMP REFS

       while your program is in the Tymbasic workspace.  This command
       creates an intermediate file that is appropriate for input to either
       the XEXEC or Tymbasic CREF program.  You must then exit Tymbasic and
       run the CREF program separately to produce a cross reference file
       that may be typed or printed on a line printer.  The cross reference
       does not contain a listing of the program -- the program must be
       typed or printed separately.

       There are two methods of running the Tymbasic CREF program.  The
       first is to set up by entering

           -CTE SETP CROSS = (TBATLIB)CREF

       at any point in your terminal session (its effect will last until
       you log out), and then

           -CROSS

       to actually run the CREF program.

       The second method is to enter

           -CTE RUN (TBATLIB)CREF

       to directly run the Tymbasic CREF program.

       The first method may be preferred when you anticipate running the
       CREF program several times during a single terminal session:  you
       must enter a long command once, but thereafter you may enter the
       short command "CROSS" to produce each cross reference.

       Notice that for either method you need not mention the name of the
       program you want a cross reference for.  This is because the CREF
    TYMBASIC Supplemental Features                                  Page 68
       CREF:  Tymbasic Cross Reference Generator


       program automatically finds all the intermediate cross reference
       files that haven't yet been processed into printable cross reference
       files, since the beginning of your terminal session.

       When you terminate your terminal session, the information about
       which intermediate files are awaiting processing is lost.  The
       easiest way to obtain a cross reference then is to issue the DUMP
       REFS command again.
    TYMBASIC Supplemental Features                                  Page 69
       FORMAT:  Tymbasic Program Formatter


       FORMAT:    Tymbasic Program Formatter       _______    ________ _______ _________


       The Tymbasic Program Formatter reformats any Tymbasic program
       without changing the logic of the program -- that is, only the
       appearance of the program is changed.

       The main function of the Formatter is to provide indentation for
       statements that lie within FOR/NEXT loops, IF statements, and
       procedures, making the program more readable as a result.  The
       Formatter also allows the user to easily reformat a program for
       printing on paper of different widths -- for example, to reformat a
       program originally intended to be printed on 132 column printer
       paper for 80 columns, or vice-versa.

       When the Formatter is run, it will type an asterisk and wait for the
       user to enter one of the following commands:

           HELP            Prints complete instructions.

           CHANGE          Allows the user to specify different
                           formatting parameters.

           RUN             Commences the formatting of the program.

           QUIT            Leaves the Formatter.

       The Formatter provides the user with flexibility in choosing the
       appearance of the program through the CHANGE command.  Any or all of
       the following parameters may be changed:

       1.  The maximum number of characters placed on a single line.

       2.  The maximum number of characters placed in a single statement.

       3.  The number of spaces used to indent statements at each level of
           indentation.

       4.  The column in which the text of each statement or the
           indentation begins.

       5.  The number of spaces used to indent the part of a statement that
           had to be placed on a separate line.

       6.  Whether or not to replace multiple spaces with a single space
           when not within a string.

       7.  Whether or not to leave the statement breaks where they are for
           statements that already span more than one line.

    TYMBASIC Supplemental Features                                  Page 70
       FORMAT:  Tymbasic Program Formatter


       When the RUN command is issued, the Formatter asks the user for the
       name of the original Tymbasic program and the name for the newly
       formatted program.  The two names may be the same, in which case the
       new, formatted program will replace the current program.
    TYMBASIC Supplemental Features                                  Page 71
       PERTST:  Enhancement for PERFORM files


       PERTST:    Enhancement for PERFORM files       _______    ___________ ___ _______ _____


       The PERTST mechanism provides a conditional branching capability
       within PERFORM command files.  The condition is always a single
       comparison test between one of the TMPCOR variables (CNC(1), CNC(2),
       CNC(3), CN$, PICK) and a constant.  The branch destination is
       specified by a label located after a semicolon on a PERFORM command
       line.  The label must contain no imbedded spaces.  The label is
       followed by a colon to clarify its use.  For example,

           FILES ;  FIL-LAB:

       specifies that "FIL-LAB" is the label for the "FILES" command.  The
       branch test occurs as a result of the execution of the PERTST
       utility.  PERTST is run simply by the command line
       "R (TBATLIB)PERTST" within the PERFORM command file.  The test line
       must immediately follow the "R (TBATLIB)PERTST" command line.  It is
       of the following form:

       IF <tmpcor-variable> <relop> <constant> GOTO <label>

       where:

       <tmpcor-variable> is one of the five tmpcor variables listed above

       <relop> is one of:  = # < >

       <constant> is an integer constant, such as 146, for the CNC
       variables, or a string constant enclosed in quotation marks, for CN$
       or PICK.  Either single or double quotes may be used to surround the
       string;  the quote not being used may be included within the text of
       the string.

       <label> is any string of characters without imbedded spaces.  It is
       not followed by a colon here.

       Example:

            R (TBATLIB)PERTST
            IF CNC(2) < 132 GOTO DO-CREDIT-REPORT

       For the string tests, two strings are equal only if their lengths
       are equal and their contents are equal.  It is permissible to have a
       label appear on the same line as the "R (TBATLIB)PERTST" command
       line.  For example:

            R (TBATLIB)PERTST; TEST-FOR-ERROR:
            IF PICK = "ERROR" GOTO BAIL-OUT
    TYMBASIC Supplemental Features                                  Page 72
       PERTST:  Enhancement for PERFORM files


       An entire PERFORM command file might look like this:

            DATE
            RUN PROG1
            RUN PROG3; PROG3:
            R (TBATLIB)PERTST
            IF CNC(1) < 4 GOTO PROG3
            RUN PROG4
            R (TBATLIB)PERTST
            IF PICK = "ERROR" GOTO BAIL-OUT
            RUN PROG5
            R (TBATLIB)PERTST
            IF PICK # "ERROR" GOTO ALL-OK
            RUN ERR ; BAIL-OUT:
            DATE ; ALL-OK:

    TYMBASIC Supplemental Features                                  Page 73
       TCA:  Tymbasic Conversion Aid


       TCA:  Tymbasic Conversion Aid       ____  ________ __________ ___


       This sub-section is addressed to the potential user of the TCA
       program.  The user is generally assumed to be competent in both
       Tymbasic and the BASIC from which he is converting.  In specific,
       the user is assumed to be capable of doing the conversion by hand if
       he had to.

       TCA is intended as an aid to conversion from other BASICs to
       Tymbasic.  It is not intended as an outright conversion program.  In
       essence, what TCA does is to perform certain mechanistic
       transformations on the user's source BASIC code.
    TYMBASIC Supplemental Features                                  Page 74
       TCA Starting It Up


       When TCA is run, it will begin by asking the user for an input file,
       an output file, and a set of options.

       Options are entered on one line, separated by commas or blanks.
       There are basically two types of options, logical ones and numeric
       ones.  Numeric options are followed by an optional equal sign and an
       integer.  Logical options may be preceeded by the word "NO".

       Option names are often comprised of more than one word.  Option
       names may be abbreviated to any left-subset of words.  For example,
       DUMP CORE USAGE could also be specified as DUMP CORE.  Furthermore,
       each word can be abbreviated to any left subset.  DUMP CORE USAGE
       may become DU CO US or even D C U.  Finally, blanks between words
       may be omitted so that DUMP CORE USAGE can be reduced to DCU or even
       DC.  Care should be taken when abbreviating since it is not always
       immediately obvious what will constitute a unique abbreviation.  If
       TCA doesn't understand, spell it out.

       1.  ARRAYS - This is a numeric option used to control the size of a
           TCA internal buffer which contains the definitions of arrays
           encountered during the processing of the user's program.  Its
           default value is 100 which means that TCA can handle up to 100
           different array definitions.  If this is insufficient then the
           user will get a message saying that the ARRAYS option
           overflowed.

       2.  USING - This is a numeric option used to control the size of two
           TCA internal buffers which contain data for handling PRINT USING
           statements.  Its default value is 100 which approximately means
           that TCA can handle up to 100 PRINT USING statements and 100
           formats.  If this is insufficient then the user will get a
           message saying that the USING option overflowed.

       3.  PROLOG - This is a numeric option used to control the size of a
           TCA internal buffer which contains statements that TCA wishes to
           insert at the front of the user's program.  Its default value is
           100 which means that TCA can handle up to 100 statements to be
           inserted.  If this is insufficient then the user will get a
           message saying that the PROLOG option overflowed.

       4.  OPENS - This is a numeric option used to control the size of a
           TCA internal buffer which is used to attempt to verify that I/O
           statements refer to file unit numbers which are, in fact, opened
           somewhere in the program.  Its default value is 100 which means
           that it can handle up to 100 different file unit numbers.  If
           this is insufficient then the user will get a message saying
           that the OPENS option overflowed.
    TYMBASIC Supplemental Features                                  Page 75
       TCA Starting It Up


       5.  REASSURE - This is a numeric option which can be used to make
           TCA print a message to the user's terminal for every Nth source
           line that is processed.  For example, setting it to five would
           cause TCA to print the message "Working on line xxx" for every
           5th source line, where xxx refers to the source statement
           number.  The default value is zero which causes no messages to
           be printed.

       6.  CHANGES ONLY - This is a logical option which causes TCA to only
           write the changed lines to the output file.  The default value
           is NO CHANGES ONLY.

       7.  DUMP ARRAYS - This is a logical option which causes TCA to print
           a table describing the arrays which were referenced by the
           user's program.  Included in the table are data indicating
           whether or not the array was mentioned in a DIM statement (vs.
           implied) and whether or not the array was actually referenced.
           The default value is NO DUMP ARRAYS.

       8.  SPECIAL ALPHAS - This is a logical option which causes TCA to
           consider the characters "@" and "#" to be alphas when scanning
           for identifiers, and to convert them to "AT" and "HA"
           respectively.  The default value is NO SPECIAL ALPHAS.

       9.  GE - This is a logical option which causes TCA to define a
           comment mark as a single quote mark (and to convert it to an
           exclamation mark), and a string delimiter to be only a double
           quote mark.  The default value is NO GE which causes TCA to
           define a comment mark as an exclamation mark and a string
           delimiter to be either a single quote or a double quote.

      10.  DUMP CORE USAGE - This is a logical option which causes TCA to
           tell the user how many entries were actually used by the ARRAYS,
           USING, PROLOG, and OPENS options.  The default value is NO DUMP
           CORE USAGE.

      11.  FORMAT TRANSLATION - This is a logical option which causes TCA
           to attempt to translate format statements.  The default is
           FORMAT TRANSLATION.

      12.  OPEN TRANSLATION - This is a logical option which causes TCA to
           attempt to translate OPEN statements.  The default is OPEN
           TRANSLATION.

      13.  XBASIC - This is a logical option which has the same effect on
           TCA as the GE option and additionally causes TCA to insert a
           "BASE 0" statement at the beginning of the output file.  The
           default is NO XBASIC.
    TYMBASIC Supplemental Features                                  Page 76
       TCA Starting It Up


      14.  STAR REMARK - This is a logical option which causes TCA to
           convert statements beginning with a star ("*") to comment lines.
           The default is NO STAR REMARK.

      15.  SETTINGS - This is not really an option.  If included in a list
           of options it will cause TCA to print the resulting option
           settings and then to again ask the user for options.

      16.  HELP - This is not really an option.  If included in a list of
           options it will cause TCA to print a list of option names and
           then to again ask the user for options.

    TYMBASIC Supplemental Features                                  Page 77
       TCA - What It Does


       The following section attempts to outline what action is taken by
       TCA when processing specific statement types or when handling
       specific special features (such as exclamation marks, quote marks,
       and array references).  Topics are arranged in alphabetical order.

       The topic headings are:
       Arrays
       Assignment
       At sign
       CHAIN
       CLOSE
       Comment
       DATA
       DEF
       DIM
       DIMENSION
       END
       Exclamation mark
       FOR
       Format
       GET
       GOSUB
       GOTO
       Cross-hatch
       IF
       INPUT
       LET
       MAT
       NEXT
       ON
       OPEN
       PAUSE
       PRINT
       PUT
       Quote mark, double
       Quote mark, single
       READ
       REM
       RESTORE
       RETURN
       STOP
       Strings
       WRITE

       Any statement types not listed above are not recognized by TCA.
       Such statements will generate a warning message and will be written
       to the output file in their original form.
    TYMBASIC Supplemental Features                                  Page 78
       TCA - What It Does


       Arrays       ______

       Tymbasic does not allow arrays and scalars to have the same names.
       Because of this, TCA changes array names in order to guarantee that
       they are unique.  The assumption is made that the source BASIC
       defines the syntax of a legal identifier as

            <alpha>[<numeric>][$]

       TCA changes the syntax of array names to

            <alpha>[<numeric>].A[$]

       For example, "A" becomes "A.A", "A1" becomes "A1.A", "A$" becomes
       "A.A$", and "A1$" becomes "A1.A$".

       All statements which TCA understands as possibly having array
       references are scanned and all array names encountered are changed.
       In addition, TCA keeps a table of all array names encountered and
       whether or not they were explicitly dimensioned or referenced.
       Array names that were not explicitly dimensioned are dimensioned to
       10 in DIM statements inserted at the front of the user's program.
       The DUMP ARRAYS option can be used to obtain a list of unreferenced
       array names.


       Assignment       __________

       Assignment statements are basically unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.


       At sign       __ ____

       If the SPECIAL ALPHA option was invoked then TCA scans all
       statements in which identifiers may appear and converts all
       identifiers that begin with "@" by changing the "@" to "AT.".


       CHAIN       _____

       The CHAIN statement is converted to a call to the library routine
       RUNUUO which is used to run an external program.  It is assumed that
       the first thing after the word CHAIN is a file name.  If the file
       name is quoted then it is used as is, otherwise it is enclosed in
       quotes.  If any other arguments were present for the CHAIN statement
       then they are treated as comments and a warning message is
       generated.
    TYMBASIC Supplemental Features                                  Page 79
       TCA - What It Does


       CLOSE       _____

       CLOSE statements are basically passed unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.


       Comment       _______

       TCA recognizes several different types of comment fields, depending
       on the options invoked.

       1.  REM statements - REM statements are always treated as comments
           and passed unchanged.

       2.  ' - Single quotes are recognized as starting a comment field if
           either the GE or XBASIC options were invoked.  In this case, the
           single quote is converted to an exclamation mark and the rest of
           the comment is passed unchanged.

       3.  ! - Exclamation marks are recognized as starting a comment field
           if neither the GE nor XBASIC options were invoked.  The comment
           field is passed unchanged.

       4.  * - Stars are recognized as starting a comment field if the STAR
           REMARK option is invoked and the star appears as the first
           nonblank character after the statement number.  The star is
           changed to REM and the remainder of the comment field is passed
           unchanged.


       When looking for a comment field, TCA attempts to ignore all comment
       marks that appear in the middle of a string literal.


       DATA       ____

       DATA statements are passed unchanged.


       DEF       ___

       DEF statements are basically passed unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.


    TYMBASIC Supplemental Features                                  Page 80
       TCA - What It Does


       DIM       ___

       DIM statements are basically passed unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.  The specified array names are marked internally as
       "explicitly dimensioned."


       DIMENSION       _________

       The word DIMENSION is changed to DIM and the statement is then
       handled exactly as a DIM statement.


       END       ___

       END statements are passed unchanged.


       Exclamation mark       ___________ ____

       If neither the GE nor XBASIC options were invoked then TCA treats
       exclamation marks as starting a comment field (except in the middle
       of a string literal).


       FOR       ___

       FOR statements are basically passed unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.  A comment is appended to the FOR statement indicating
       the nesting level.


       Format       ______

       Format statements are considered to be statements beginning with a
       colon.  Such statements are converted to string assignment
       statements of the form

            IMGxxxx$ = "format"

       where xxxx is the statement number of the original format and
       "format" contains the text of the original format.  The format
       statement is written to the output file as a null comment (statement
       number, exclamation mark, carriage return).  What happens to the
       assignment statement depends on how many times the original format
       was referenced.  If it was referenced only once then the assignment
       statement is written with the statement number of the referencing
       statement and the referencing statement has its statement number
    TYMBASIC Supplemental Features                                  Page 81
       TCA - What It Does


       increased by one.  If the format was referenced more than once then
       it is inserted in the front of the user's program.  Unreferenced
       formats are simply deleted.

       In addition, if the FORMAT TRANSLATION option was invoked then TCA
       replaces all occurances of the letters ', #, L, or C in the body of
       the format with the character %.


       GET       ___

       If the first thing after GET is either an integer or an identifier
       followed by a colon then the integer or identifier is assumed to be
       the file unit number.  Otherwise the file unit number is assumed to
       be one.

       The GET statement up to the start of the input I/O list is converted
       to "INPUT FROM <file unit number>:".  The remainder of the GET
       statement is basically unchanged.  Array names are converted.
       Special alphas are converted if the SPECIAL ALPHA option was
       invoked.

       TCA will remember the file unit number and check it against OPEN
       statements in an attempt to verify that it is probably opened.


       GOSUB       _____

       GOSUB statements are passed unchanged unless they contain the word
       ON in which case they are assumed to have the following syntax

            GOSUB st1, st2, st3, ...  ON <expression>

       and are converted to

            ON <expression> GOSUB st1, st2, st3, ...

       and <expression> is scanned for array name conversion and special
       alpha conversion if the SPECIAL ALPHA option was invoked.


       GOTO       ____

       GOTO statements are passed unchanged unless they contain the word ON
       in which case they are assumed to have the following syntax

            GOTO st1, st2, st3, ...  ON <expression>
    TYMBASIC Supplemental Features                                  Page 82
       TCA - What It Does


       and are converted to

            ON <expression> GOTO st1, st2, st3, ...

       and <expression> is scanned for array name conversion and special
       alpha conversion if the SPECIAL ALPHA option was invoked.


       Cross-hatch       ___________

       If the SPECIAL ALPHA option was invoked then TCA converts all
       identifiers beginning with "#" by changing the "#" to "HA".


       IF       __

       IF statements are assumed to have the following syntax

            IF <expression> [,] [THEN] [GOTO|GOSUB] <stmt #>

       and is converted to the form

            IF <expression> THEN GOTO|GOSUB <stmt #>

       <Expression> is scanned to convert array names.  Special alphas are
       converted if the SPECIAL ALPHA option was invoked.


       INPUT       _____

       INPUT statements are basically passed unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.


       LET       ___

       LET statements are basically passed unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.


       MAT       ___

       It is generally assumed that all identifiers in a MAT statement are
       array names and they are converted as such.  Special alphas are
       converted if the SPECIAL ALPHA option was invoked.  A special check
       is made for MAT statements of the form
    TYMBASIC Supplemental Features                                  Page 83
       TCA - What It Does


            MAT A = (B) * C

       so that B will not be considered as an array name.


       NEXT       ____

       NEXT statements are basically passed unchanged.  A comment field is
       added to indicate FOR level.  Note that the FOR/next level counter
       will get confused by NEXT statements which terminate more than one
       FOR statement (eg., NEXT I,J,K).


       ON       __

       ON statements are assumed to have the syntax

            ON <expression> [,] [THEN] [GOTO|GOSUB] st1, st2 ...

       and are changed to the form

            ON <expression> [GOTO|GOSUB] st1, st2 ...

       The expression is scanned for array name conversions.  Special
       alphas are converted if the SPECIAL ALPHA option was invoked.


       OPEN       ____

       If the OPEN TRANSLATION option was not invoked then OPEN statements
       are passed unchanged.  A side effect of this is that no attempt is
       made to locate the file unit number associated with the OPEN
       statement and TCA is unable to attempt to verify that file unit
       numbers used in I/O statements have corresponding OPEN statements.
       Currently this causes warning messages to be issued when processing
       I/O statements which have file unit numbers.

       If the OPEN TRANSLATION option was invoked then the portion of the
       OPEN statement following the word OPEN is enclosed in parentheses.
       Array names are converted.  Special alphas are converted if the
       SPECIAL ALPHA option was invoked.  The file unit number (assumed to
       be the first word after OPEN) is saved for matching with I/O
       statements.


    TYMBASIC Supplemental Features                                  Page 84
       TCA - What It Does


       PAUSE       _____

       PAUSE statements are passed unchanged.


       PRINT       _____

       PRINT statements are recognized in two forms:

            PRINT USING <format>, <I/O list>

            PRINT <I/O list>

       PRINT USING statements are converted to

            PRINT IN IMAGE IMGxxxx$:  <I/O list>

       where xxxx is the original format number.  The format statement will
       be converted to a string assignment statement when it is
       encountered.  If the format is only referenced in one place then the
       corresponding PRINT USING statement will have its statement number
       incremented by one and the string assignment statement will ge given
       the statement number of the original PRINT USING statement.
       Otherwise, the string assignment statement will be inserted at the
       front of the user's program and the PRINT USING statement will
       retain its original statement number.  See also the discussion of
       formats.

       For both PRINT statements and PRINT USING statements, the I/O list
       is scanned and converted.  Array names are converted.  Special
       alphas ar converted if the SPECIAL ALPHA option was invoked.

       Certain BASICs do not require element delimiters before or after
       string literals in an I/O list.  Tymbasic requires delimiters and
       TCA will insert commas where they are needed.  For example,

            "ABC"I"XYZ""123"

       is converted to

            "ABC",I,"XYZ","123"


       PUT       ___

       If the first thing after PUT is either an integer or an identifier
       followed by a colon then the integer or identifier is assumed to be
       the file unit number.  Otherwise the file unit number is assumed to
       be two.
    TYMBASIC Supplemental Features                                  Page 85
       TCA - What It Does


       The PUT statement up to the start of the output I/O list is
       converted to "PRINT ON <file unit number>:".  The remander of the
       PUT statement is basically unchanged.  Array names are converted.
       Special alphas are converted if the SPECIAL ALPHA option was
       invoked.


       Quote Mark, Double       _____ _____ ______

       Double quote marks are always assumed to be string literal
       delimiters.


       Quote Mark, Single       _____ _____ ______

       If the GE or XBASIC option was invoked then single quote marks are
       assumed to start comment fields.  Otherwise, single quote marks are
       assumed to be string literal delimiters.


       READ       ____

       READ statements are basically passed unchanged.  Array names are
       converted.  Special alphas are converted if the SPECIAL ALPHA option
       was invoked.


       REM       ___

       REM statements are passed unchanged.


       RESTORE       _______

       RESTORE statements are passed unchanged.


       RETURN       ______

       RETURN statements are passed unchanged.


       STOP       ____

       STOP statements are passed unchanged.


    TYMBASIC Supplemental Features                                  Page 86
       TCA - What It Does


       Strings       _______

       Double quote marks are always considered to be string literal
       delimiters.  Single quote marks are also considered to be string
       literal delimiters if neither the GE option nor the XBASIC option
       was invoked.

       In PRINT or PRINT USING I/O lists, commas are inserted before and
       after string literals as needed.  See PRINT discussion.


       WRITE       _____

       WRITE statements are recognized by TCA but no code has been written
       to do anything with them.  Currently WRITE statements are passed
       unchanged and cause the generation of a warning message.
    TYMBASIC Supplemental Features                                  Page 87
       Interfacing with TYMQUOTE                            3 February 1978


                    SECTION III.  Interfacing with TYMQUOTE                    _______ ____  ___________ ____ ________


       TYMQUOTE can be accessed using the FORTRAN interface within
       Tymbasic.  This feature makes available to the user the simplicity
       of using a BASIC language, the convenience of an interactive
       package, as well as the power and efficiency of Tymbasic, which was
       designed for creating major systems.

       Tymbasic requires that each of the functions and subroutines be
       defined explicitly.  There is also a special load string for
       Tymbasic users.  All of this has been taken care of with a command
       file available in TBATLIB.  To make use of this special command
       file, it is necessary to create programs with line numbers greater
       than 499.  It should become the custom of Tymbasic users to start
       numbering their programs at 500 or higher.  The command file adds
       code directly into the user's program.  To use the command file, the
       user should, while in Tymbasic, type:

       >DO (TBATLIB)TQMERG

       and Tymbasic will add the lines of code to the program and include
       the load strings.

       Once the code has been added to the program and saved, the load
       strings can be accessed separately by typing:

       >DO (TBATLIB)TQLOAD

       A typical compile and run of a TQ program called TQSAMP
       might be as follows:

       -TBA
       Ver 2.5-1.0
       >GET TQSAMP
       >DO (TBATLIB)TQMERG
       >RUN

       The sample program which the user has seen coded in FORTRAN and
       COBOL is shown below as it is directly translated into Tymbasic.  It
       should be noted that there are some differences that the coder must
       be aware of.  While using Tymbasic, all arrays must be declared
       explicitly.  Also, it is necessary to declare variables as integers
       even if the names begin with characters like I, J, K, etc.  Remember
       that in Tymbasic all numeric variables are assumed to be real unless
       otherwise declared.  The coder must also note that, unlike FORTRAN,
       Tymbasic differentiates between string and integer variables.  This
       introduces the need for additional code when passing string values
       to, or receiving string values from, FORTRAN.
    TYMBASIC Supplemental Features                                  Page 88
       Interfacing with TYMQUOTE                            3 February 1978


       Due to the fact that FORTRAN stores its string values in integer
       variables, it is necessary to convert the string values to integers
       and the returned integer values back to strings.  Included in TQMERG
       are four special functions to aid the programmer.  They are:

       F.CHR(INTEGER)             returns a string value from a FORTRAN
                                  integer
       F.CHRA(INTEGER ARRAY)      returns a single Tymbasic string
                                  value from an array of FORTRAN integers
       F.ASC(STRING$)             returns a scalar integer value for the
                                  first five characters of the string
       F.ASCA(STRING$)            returns an array of integer values each
                                  containing five characters

       When calling subroutines, Tymbasic requires that each parameter be
       fully declared within the definition.  The definitions for the
       TYMQUOTE calls have been created for the user and are automatically
       loaded into the program by the commands file TQMERG.  Because there
       is a choice of passing real or integer values for LOWVAL and HIVAL
       to the SLECT subroutine, it is necessary to use two different calls
       in Tymbasic.

       SLECT      will have all integer values
       SLECTR     will have integer values for the attribute and the count
                  and will require real values for the HIGH and LOW values

       The other major difference effects two subroutine calls.  SLNEXT and
       XDNEXT both pass a line number as an argument.  This cannot be done
       in Tymbasic.  Therefore, two new subroutine calls have been created
       for the Tymbasic user:

       SLNXT( ICTC, IER)
       XDNXT( IREC(*), IER)

       IER is the error return code.  As long as data is available, IER
       will have the value 0.  When there are no more NEXT values, IER will
       be returned as -1.  IER can be used as a logical variable:

       1000  IF IER THEN 1100

       where    IER = 0     is FALSE
       and      IER = -1    is TRUE
    TYMBASIC Supplemental Features                                  Page 89
       Interfacing with TYMQUOTE                            3 February 1978


       The following is the copy of the code, directly translated.  It
       might be noted that there has been no attempt to gain efficiency
       through the use of special features of Tymbasic, but rather to
       maintain consistency with the FORTRAN example.

            1500   STRING ISSUER$, ISSUE$, IDATE$, IPRICE$, IEX$
            1600   INTEGER ISSUER(6), ISSUE(4), IDATE(3), IPRICE(2), ICTC
            1700   INTEGER IER, IDAY, IDAY7, NC, ITEM, IROUND, IMODE, ASCII.
            1800   REAL PRICE
            2600   CALL XSET(0, -1, 1, 1, -1,0)
            2900   CALL RDAY ( IDAY, IER )
            3000   IF IER THEN STOP 'EXECUTION ENDED'
            3100   IDAY7 = ICHRON(IDAY,17)
            3400   CALL RDCTC( ICTC, IER)
            3600   IF IER=-1 THEN 2900
            3900   CALL XGET( ICTC, IER )
            4100   IF IER THEN 3400
            4400   PRICE = XPRICE( IDAY )
            4800   IEX$ = F.CHR( ITEMX( F.ASC( 'EXC' )))
            4900   IROUND = 2
            5000   IF IEX$ = 'F' OR IEX$ = 'G'  THEN IROUND= -1
            5100   CALL PRCVO( PRICE, IROUND, IPRICE )
            5200   IPRICE$ = F.CHRA( IPRICE )
            5300   CALL DAYCVO( IDAY7, 13, IDATE, NC )
            5600   CALL XITEM( F.ASC( 'NAM' ), ISSUER)
            5700   CALL XITEM( F.ASC( 'ISS' ), ISSUE )
            6000   PRINT
            6100   PRINT F.CHRA( ISSUER );F.CHRA( ISSUE )
            6200   PRINT '$':IPRICE$:' -- ':F.CHRA(IDATE)
            6300   PRINT
            6400   GOTO 3400

       The following is the identical program, showing in addition some
       comments to aid in understanding the design and flow of the program.
    TYMBASIC Supplemental Features                                  Page 90
       Interfacing with TYMQUOTE                            3 February 1978


            1000 !--  PROGRAM QUOTE  AS WRITTEN IN Tymbasic
            1100 !--  FUNCTION:  TO READ THE DATE, CUSIP NUMBER OR TICKER
            1200 !--    SYMBOL, AND TO TYPE OUT THE CLOSING PRICE.
            1300 !--    
            1400 !--  DECLARATION STATEMENTS:
            1500   STRING ISSUER$, ISSUE$, IDATE$, IPRICE$, IEX$
            1600   INTEGER ISSUER(6), ISSUE(4), IDATE(3), IPRICE(2), ICTC
            1700   INTEGER IER, IDAY, IDAY7, NC, ITEM, IROUND, IMODE, ASCII.
            1800   REAL PRICE
            1900 !--  NOTE:  ALL ARRAYS MUST BE DECLARED.  ALSO, IT IS NECESSARY
            2000 !--    TO DECLARE VARIABLES AS INTEGER EVEN IF THE NAMES BEGIN
            2100 !--    WITH CHARACTERS LIKE I, J, K, ETC.  REMEMBER ALSO THAT
            2200 !--    STRING AND INTEGER VARIABLES MUST BE DECLARED DIFFERENTLY
            2300 !--  EXTRACT UNADJUSTED PRICES, FILL IN MISSING PRICES
            2400 !--  WITH LAST PREVIOUS TRADES, AND USE BID FOR CLOSE
            2500 !--  FOR BID/ASK QUOTATIONS.
            2600   CALL XSET(0, -1, 1, 1, -1,0)
            2700 !--
            2800 !--  READ DATE FROM TTY
            2900   CALL RDAY ( IDAY, IER )
            3000   IF IER THEN STOP 'EXECUTION ENDED'
            3100   IDAY7 = ICHRON(IDAY,17)
            3200 !--
            3300 !--  READ CUSIP OR TICKER CODE FROM TTY
            3400   CALL RDCTC( ICTC, IER)
            3500 !--  IF <CR> ENTERED, RETURN TO DATE INPUT
            3600   IF IER=-1 THEN 2900
            3700 !--
            3800 !--  FIND ISSUE IN TQ DATABASE
            3900   CALL XGET( ICTC, IER )
            4000 !--  IF ISSUE NOT FOUND, READ ANOTHER FROM THE TERMINAL
            4100   IF IER THEN 3400
            4200 !--
            4300 !--  GET THE PRICE
            4400   PRICE = XPRICE( IDAY )
            4500 !--  
            4600 !--  REFORMAT THE PRICE AND DATE FOR OUTPUT.
            4700 !--  NOTE:  THE SPECIAL USE OF THE F.CHR AND F.ASC FUNCTIONS
            4800   IEX$ = F.CHR( ITEMX( F.ASC( 'EXC' )))
            4900   IROUND = 2
            5000   IF IEX$ = 'F' OR IEX$ = 'G'  THEN IROUND= -1
            5100   CALL PRCVO( PRICE, IROUND, IPRICE )
            5200   IPRICE$ = F.CHRA( IPRICE )
            5300   CALL DAYCVO( IDAY7, 13, IDATE, NC )
            5400 !--
            5500 !--  TYPE ISSUE DESCRIPTION, PRICE AND DATE
            5600   CALL XITEM( F.ASC( 'NAM' ), ISSUER)
            5700   CALL XITEM( F.ASC( 'ISS' ), ISSUE )
            5800 !--  NOTE:  THE USE OF THE CONVERSION FUNCTIONS CAN BE RESERVED
            5900 !--    UNTIL THEY ARE NEEDED (AS IN THE PRINT STATEMENT).
            6000   PRINT
            6100   PRINT F.CHRA( ISSUER );F.CHRA( ISSUE )
            6200   PRINT '$':IPRICE$:' -- ':F.CHRA(IDATE)
            6300   PRINT
            6400   GOTO 3400
    TYMBASIC Supplemental Features                                  Page 91
       Interfacing with TYMQUOTE                            3 February 1978


       The following are runs of the sample program using different
       methods.  Method 1 shows the steps involved when the TQSAMP program
       contains only the code generated by the user.  Method 2 shows the
       steps involved when the TQSAMP program contains both the user's code
       and the code portion of TQMERG.  Method 3 shows the steps involved
       in making and running a save version of the code.  This last method
       is more cost effective in production-type systems.

       Method 1:

            -TBA
            Ver 2.5-1.0
            >GET TQSAMP
            >DO (TBATLIB)TQMERG
            >RUN
            TQSAMP. added to module list
            DATE:  1/2/68
            ISSUE:  IBM

            INTERNATIONAL BUSINESS MACHS
                 $ 613 1/2   -- JANUARY 2, 1968

            ISSUE:  HJ

            HOWARD JOHNSON CO
                 $  42 5/8   -- JANUARY 2, 1968

            ISSUE:
            DATE:  1/2/75
            ISSUE:  IBM

            INTERNATIONAL BUSINESS MACHS
                 $ 168 7/8   -- JANUARY 2, 1975

            ISSUE:  
            DATE:
            EXECUTION ENDED

            >Q

            EXIT

            -



    TYMBASIC Supplemental Features                                  Page 92
       Interfacing with TYMQUOTE                            3 February 1978


       Method 2:

            -TBA
            Ver 2.5-1.0
            >GET TQSAMP
            >DO (TBATLIB)TQLOAD
            >RUN
                      |
                      |
                      |
                      |
                      |
                      |
            >Q

            EXIT

            -



       Method 3:  There are two steps
         Step 1:

            -TBA
            Ver 2.5-1.0
            >GET TQSAMP
            >DO (TBATLIB)TQMERG
            >SAVE BINARY
            TQSAMP.SHR: New file, OK? Y
            TQSAMP. added to module list

            >Q

            EXIT

            -

         Step 2:

            -GO TQSAMP
            DATE:  1/2/68
            ISSUE:  IBM

            INTERNATIONAL BUSINESS MACHS
                 $ 613 1/2   -- JANUARY 2, 1968

            ISSUE:
            DATE:
            EXECUTION ENDED

            -

    TYMBASIC Supplemental Features                                  Page 93
       Interfacing with TYMQUOTE                            3 February 1978


       Once the .SHR file has been generated, the user may rerun the
       program directly from XEXEC without entering Tymbasic.  This
       eliminates the need to compile and therefore reduces the cost of
       running the program.  Greater familiarity with both TYMQUOTE and
       Tymbasic on the part of the programmer and user will result in
       increased efficiency and flexibility in meeting the needs of the
       user.
    TYMBASIC Supplemental Features                                  Page 94
       Interfacing with X22                                 24 October 1977


                       SECTION IV.  Interfacing with X22                       _______ ___  ___________ ____ ___


       This section is intended to describe the relevant differences
       between using X22 with FORTRAN and using X22 with Tymbasic and is
       mainly comprised of notes accumulated during the effort to make
       Tymbasic and X22 compatible.

       The audience is assumed to be relatively conversant with Tymbasic
       and X22 and to have access to a current X22 User Manual (version
       December 1976, or later) describing the use of X22 with FORTRAN.


       1.  As with all references to external procedures, Tymbasic requires
           a DEF statement for each X22 routine to be called.

       2.  In order to code several calls to a given X22 routine and pass
           varying numbers of arguments, the user must provide one DEF
           statement for each number of arguments.  For example, if the
           user wanted to make two calls to FOO, once with two arguments
           and once with three arguments, his code might look as follows:

           100 DEF EXTERNAL SFO F2 (INTEGER (I,J)) AKA "FOO"
           200 DEF EXTERNAL SFO F3 (INTEGER (I,J,K)) AKA "FOO"
           500 CALL F2(1,2)
           700 CALL F3(1,2,3)

           The necessity to include multiple DEFs with AKAs in order to
           accomplish varying argument lists is, hopefully, temporary,
           although it may actually be quite some time before Tymbasic is
           modified to understand how to do this "correctly".

       3.  Attribute names and text attribute values passed to X22 routines
           are not converted to upper case by X22.  They must be in the
           same case as the names and values actually stored on the data
           base files.  The simplest solution is probably to always convert
           them to upper case.

       4.  Attribute names and text attribute values passed to X22 routines
           must be a multiple of 5 characters long, blank padded.  Contrary
           to the X22 manual, it is apparently not true that they must end
           in a blank.

       5.  Contrary to the X22 manual, it is apparently not true that text
           attribute values used in record selection must be blank padded
           to the same length as the target attribute.

       6.  The user name portion of a file nomen passed to X22 must be
           upper case.  Failure to have the user name in upper case will
           cause mysterious error messages which complain about PPN
    TYMBASIC Supplemental Features                                  Page 95
       Interfacing with X22                                 24 October 1977


           777777,,777777.

       7.  The DBGREC routine, when called from Tymbasic, returns a
           predicate value for indicating whether or not a record was
           successfully setup.  This contrasts with the FORTRAN method of
           specifying a label which DBGREC branches to when no record was
           setup.  The user must, however, pass an argument for the label
           or else DBGREC will complain about not having enough arguments.

       8.  The user must include the statements "DEF EXTERNAL X22INT" and
           "CALL X22INT" in his program.  For cleanliness sake, the CALL
           should probably appear near the first of the users' program,
           although in fact it is not really necessary that it be executed.
           Also, it doesn't matter if it is executed more than once.
           X22INT is just a dummy routine in the Tymbasic library which
           forces the loading of an X22 initilization routine from the X22
           library.  When this routine is loaded it automatically causes
           communication to occur between TBAs' core allocator and X22.

       9.  The user must place (UPL)HL1022 on his library list.

      10.  When X22 returns a string through an argument, it always returns
           it as an integer array.  Usually the user will want to convert
           it back to a string by using the CHAR function.

      11.  The DBERR routine must not be passed a statement number.  Pass
           it a zero or minus one only.

      12.  Beware of using outdated versions of the X22 manual.  There are
           significant differences between the 1974 and 1976 versions.

    TYMBASIC Supplemental Features                                  Page 96
       Interfacing with X22                                 24 October 1977


       The following piece of code is a string function which will convert
       strings to upper case and blank pad them to a multiple of 5
       characters:

       100 def string x22stg (string source)
       110   string result, c
       120   integer i
       130   !
       140   source = ljust(rjust(source))
       150   result = ""
       160   !
       170   for i = 1 to length(source)
       180     c = substr(source,i,1)
       190     if asc(c) >= asc("a") and asc(c) <= asc("z") then &
                c = char( asc("A") - asc("a") + asc(c) )
       200     result = result + c
       210   next i
       220   !
       230   i = length(result) mod 5
       240   if i # 0 then result = rpad(result,length(result)+5-i)
       250   !
       260   exit result
       270 endf x22stg

       The following piece of code is a string function which will convert
       an integer array into a string:

       100 DEF STRING ARRAY$(INTEGER ARRAY(*))
       110   STRING S$
       120   INTEGER I
       130   S$ = ""
       140   S$ = S$+CHAR(RSH(ARRAY(I),1),5) FOR I = 1 UNTIL ARRAY(I) = 0
       150   EXIT S$
       160 ENDF ARRAY$
    TYMBASIC Supplemental Features                                  Page 97
       Conversion from XBASIC Programs                    13 September 1977


                  SECTION V.  Conversion from XBASIC Programs                  _______ __  __________ ____ ______ ________


       This section is intended as an aid in converting programs from
       XBASIC to Tymbasic and is comprised mainly of notes made from a
       XBASIC to Tymbasic conversion which was done with the aid of the TCA
       program.  The reader is cautioned that this document probably does
       not represent a definitive list of differences and should be
       considered for the most part as a good starting reference.

       Scientific functions       __________ _________

       The following scientific functions exist in XBASIC and must be
       changed for Tymbasic.  The TCA program does not do the needed
       conversion.


       1.  COT(X) - Not supported in Tymbasic.

       2.  LN(X) - Change to LOG(X).

       3.  LOGE(X) - Change to LOG(X).

       4.  CLOG(X) - Change to LOG(X).


       String functions       ______ _________

       The following string functions exist in XBASIC and must be changed
       for Tymbasic.  The TCA program does not do the needed conversion.


       1.  LEN(A$) - Change to LENGTH(A$).

       2.  CHR$(I) - Change to CHAR(I).

       3.  STR$(I) - Change to STR(I).

       4.  LEFT$(A$,I) - Change to LEFT(A$,I).

       5.  RIGHT$(A$,I) - Change to RIGHT(A$,I).

       6.  MID$(A$,I,J) - Change to SUBSTR(A$,I,J).  Watch out for this one
           in left side of assignment statements and in the I/O lists of
           input statements.

       7.  SPACE$(I) - Change to SPACE(I).
    TYMBASIC Supplemental Features                                  Page 98
       Conversion from XBASIC Programs                    13 September 1977


       8.  INSTR(I,A$,B$) - Change to INDEX(B$,A$,I).  Note argument
           rearrangement.


       Array declaration       _____ ___________

       Arrays in XBASIC are normally based at zero.  TCA will generate a
       "BASE 0" statement at the start of the user's program if the XBASIC
       option is invoked.

       DIM can also be spelled DIMENSION in XBASIC.  TCA will handle this.

       Program control       _______ _______

       In XBASIC, an IF statement has the following syntax

            IF <expression> [,] [THEN] [GOTO] <statement #>

       The TCA program will correctly convert this to

            IF <expression> THEN GOTO <statement #>

       In XBASIC, computed GOTOs have to following syntax

            ON <expression> [,] [THEN] [GOTO] <statement list>

       The TCA program will correctly convert this to

            ON <expression> GOTO <statement list>

       String comparisons in XBASIC automatically ignore leading blanks.
       TCA does not handle this.  If it is a problem, then the Tymbasic
       statements should be modified to have LJUST functions wrapped around
       the operands of the comparison test.

       XBASIC supports "IF END #3 ..." as an end-of-file test for file unit
       number 3.  Tymbasic handles this in a totally different way and the
       program will have to be manually changed for these statements.

       User defined functions       ____ _______ _________

       XBASIC user functions are almost compatible with Tymbasic.  However,
       TCA does not attempt to make them fully compatible and the
       conversion must be done by hand.  XBASIC returns functions values
       a'la FORTRAN, that is "FNAME = expression".  Tymbasic returns
       function values with an "EXIT expression" statement.  XBASIC ends a
       user function with an "FNEND" statement.  Tymbasic ends a user
       function with "ENDF function name".
    TYMBASIC Supplemental Features                                  Page 99
       Conversion from XBASIC Programs                    13 September 1977


       XBASIC didn't seem to have explicit typing of user defined functions
       and this may be desirable to add.

       I/O       ___

       One of the thornier aspects of converting from XBASIC to Tymbasic is
       handling the I/O statements.  Such statements map very poorly
       between the two BASICs and for the most part the TCA program will
       not help.

       XBASIC I/O statements precede a file unit number with a hatch mark.
       This must be removed and the TCA program doesn't do it.

       The formatting characters map especially poorly and must be done by
       hand.  Some of the string formatting characters may require that
       functions be written to massage the string.  TCA will not help here
       and in fact should not even be allowed to try.  Specify NO FORMAT
       TRANSLATION to make TCA leave the formatting alone.

       PRINT USING statements in XBASIC are very free form up to the I/O
       list in the sense that the format number, the file unit number, and
       the word USING can be arranged in several different ways.  TCA
       recognizes only PRINT USING <format number>.

       A semi-colon is used to glue fields together for output.  TCA
       correctly converts this to a colon.

       XBASIC appends a blank to formatted numeric output.  This can only
       be simulated by manually changing the formats.

       The following statement types either have no corresponding statement
       or statements in Tymbasic or must be changed by hand.


       1.  FILES - Convert to an OPEN statement.

       2.  FILE - Convert to an OPEN statement.

       3.  SCRATCH - Normally accomplished within the OPEN statement,
           otherwise use either the LOCATE statement or re-open the file.

       4.  RESTORE (A file!!!) - Normally accomplished within the OPEN
           statement, otherwise use either the LOCATE statement or re-open
           the file.

       5.  READ (From a file!!!) - Change to INPUT FROM.

       6.  SET - ??
    TYMBASIC Supplemental Features                                 Page 100
       Conversion from XBASIC Programs                    13 September 1977


       7.  LAST - ??

       8.  QUOTE - ??

       9.  NOQUOTE - ??

      10.  MARGIN - Change to LOL.

      11.  PAGE - ??

      12.  NOPAGE - ??

      13.  WRITE (To a file!!!) - Change to PRINT ON.


       It is probably mandatory to thoroughly understand I/O in both XBASIC
       and Tymbasic before attempting to convert a program which contains
       more that the simplest I/O.

       Other areas of incompatibility       _____ _____ __ _______________

       XBASIC supports a RANDOMIZE statement which can also be abbreviated
       as RANDOM and must be converted to CALL RND(0).

       XBASIC supports a TIM function which is only approximately the TIME
       or TRU function in Tymbasic.

       Comments in XBASIC are indicated with a single quote.  TCA handles
       this if the XBASIC option is invoked.

       In XBASIC, the RESTORE statement (besides being used to restore a
       file) also has the property of being able to selectively restore
       either string or scalar data by appending a dollar sign or a star to
       the end of the statement.  Nothing like this exists in Tymbasic,
       although data blocks are handled separately for each module.

       The CHAIN statement in XBASIC allows for an optional starting
       statement number.  This can be simulated in Tymbasic with an
       incredible amount of effort (such as writing the line number to a
       file and having the target program read it in and do a computed
       GOTO).  XBASIC also does something about sharing variable values
       across CHAIN statements and this also is next to impossible to
       simulate without a lot of case-by-case effort.

       XBASIC supports a CHANGE statement which is approximately equal to
       taking the ASC function of each character in a string and storing
       the results in an array.
    TYMBASIC Supplemental Features                                 Page 101
       Index                                                    26 May 1977


       .TMP file . . . . . . . . . . . .  11

       Accessing User Library Functions   2
       AKA clause  . . . . . . . . . . .  2
       Array operations  . . . . . . . .  48
       Arrays 
         bounds  . . . . . . . . . . . .  48

       BLANK.ZFP . . . . . . . . . . . .  30
       Bounds of an array  . . . . . . .  48
       Bounds pairs of an array  . . . .  48

       CALL statement  . . . . . . . . .  2
       CENABLE . . . . . . . . . . . . .  53, 55
       CMPARE  . . . . . . . . . . . . .  64
       CN$ . . . . . . . . . . . . . . .  13-14
       CNC . . . . . . . . . . . . . . .  13-14, 71
       COBOL SORT  . . . . . . . . . . .  60
       Command files . . . . . . . . . .  8-11, 71
       Compilers . . . . . . . . . . . .  10
       Confirmation  . . . . . . . . . .  31
       Confirmation keyword  . . . . . .  31
       Conversion from XBASIC programs .  97
       Converting BASIC programs . . . .  73
       Core space  . . . . . . . . . . .  41
       Creation date of file including seconds  26
       CREF  . . . . . . . . . . . . . .  67
       CROSS . . . . . . . . . . . . . .  10, 67
       Cross reference generator . . . .  67

       Dates . . . . . . . . . . . . . .  26-28, 33
       DAY.NO  . . . . . . . . . . . . .  27
       DEF statement . . . . . . . . . .  2
       Dimension of an array . . . . . .  48
       DISABLE . . . . . . . . . . . . .  53-55
       DT.CNV  . . . . . . . . . . . . .  26
       DUMP REFS . . . . . . . . . . . .  67

       ENABLE  . . . . . . . . . . . . .  53-55
       Error condition . . . . . . . . .  10, 35
       Extended Escape Control . . . . .  52
       Extension . . . . . . . . . . . .  31

       F.ASC . . . . . . . . . . . . . .  57
       F.ASCA  . . . . . . . . . . . . .  59
       F.CHR . . . . . . . . . . . . . .  56
       F.CHRA  . . . . . . . . . . . . .  58
       FD.CLOSE  . . . . . . . . . . . .  33
       FD.DATE . . . . . . . . . . . . .  33
       FD.EXACT  . . . . . . . . . . . .  33, 37
       FD.EXT  . . . . . . . . . . . . .  33
       FD.LIC  . . . . . . . . . . . . .  33
       FD.NAME . . . . . . . . . . . . .  33
       FD.OPEN . . . . . . . . . . . . .  33
       FD.QUERY  . . . . . . . . . . . .  33
       FD.SET  . . . . . . . . . . . . .  33
       FD.SIZE . . . . . . . . . . . . .  33
       FD.STAT . . . . . . . . . . . . .  33
       FD.STEP . . . . . . . . . . . . .  33, 38-40
       FD.WILD . . . . . . . . . . . . .  33, 37
       File 
         creation date . . . . . . . . .  26, 33, 41
         date comparisons  . . . . . . .  26
         directory . . . . . . . . . . .  33, 35
         dumped bit  . . . . . . . . . .  47
         extension . . . . . . . . . . .  31, 33, 38-39, 43
         license . . . . . . . . . . . .  33, 41, 45
         lookup  . . . . . . . . . . . .  47
         name  . . . . . . . . . . . . .  11, 31, 33, 38-39, 42
         nomen . . . . . . . . . . . . .  10, 26, 31
         nomen parse . . . . . . . . . .  31
         protection  . . . . . . . . . .  47
         size  . . . . . . . . . . . . .  33, 41
         status  . . . . . . . . . . . .  33, 41
         temporary bit . . . . . . . . .  47
         unit number . . . . . . . . . .  32
         unit number -9  . . . . . . . .  10, 35
       FILE error condition  . . . . . .  10
       File I/O  . . . . . . . . . . . .  31-32
         SCANNING file directory . . . .  33-47
       FILE.DATE . . . . . . . . . . . .  28
       FILE.PARSE  . . . . . . . . . . .  31
       FORMAT  . . . . . . . . . . . . .  69
       Formatted I/O . . . . . . . . . .  29-30
       Formatter for Tymbasic programs .  69
       FORTRAN string conversion . . . .  56-59
       Function identifiers  . . . . . .  2
       Function names  . . . . . . . . .  2
       Function type . . . . . . . . . .  2

       GETPJC  . . . . . . . . . . . . .  15
       GFD . . . . . . . . . . . . . . .  35

       Half-word manipulation  . . . . .  49-51

       IFTP  . . . . . . . . . . . . . .  23
       IGFD.PPN  . . . . . . . . . . . .  21
       ILOG.PPN  . . . . . . . . . . . .  20
       Inter-program communication . . .  10, 13-14
       Interfacing with PERFORM  . . . .  8-9, 14
       Interfacing with TYMQUOTE . . . .  87
       Interfacing with X22  . . . . . .  94
       IO channels . . . . . . . . . . .  10
       IRUN.PPN  . . . . . . . . . . . .  22
       Job number  . . . . . . . . . . .  11, 24
       Job, user, and system information  15, 20-25
       JOBNO . . . . . . . . . . . . . .  24

       Language type . . . . . . . . . .  2

       Monitor calls . . . . . . . . . .  41

       ON condition statement  . . . . .  35
       On-condition  . . . . . . . . . .  27

       Parsing file nomens . . . . . . .  31
       PERFORM . . . . . . . . . . . . .  8-9, 14, 71
       PERFORM program enhancement . . .  71
       PERTST  . . . . . . . . . . . . .  14, 71
       PICK  . . . . . . . . . . . . . .  13-14, 71
       PIP . . . . . . . . . . . . . . .  10
       Procedures  . . . . . . . . . . .  48

       QCKSRT  . . . . . . . . . . . . .  64
       Quick sort  . . . . . . . . . . .  64

       Registers . . . . . . . . . . . .  10, 12
       REPROMPT  . . . . . . . . . . . .  4
       Running another program . . . . .  10-14
       RUNUUO  . . . . . . . . . . . . .  9-10

       SAVE  . . . . . . . . . . . . . .  10
       SAVE BINARY . . . . . . . . . . .  12
       SAVE BINARY command . . . . . . .  10
       SET.FLDOVF.CH . . . . . . . . . .  29
       SORT  . . . . . . . . . . . . . .  60
       ST.REG  . . . . . . . . . . . . .  10, 12
       START.POINT . . . . . . . . . . .  10-12
       Startpoint  . . . . . . . . . . .  10
       Startpoint offset . . . . . . . .  10-11
       STUFIB  . . . . . . . . . . . . .  5
       SYSNO . . . . . . . . . . . . . .  25

       Table of contents . . . . . . . .  2
       TCA . . . . . . . . . . . . . . .  73
       Terminal I/O  . . . . . . . . . .  3-7
       Terminal input  . . . . . . . . .  8
       Time zones  . . . . . . . . . . .  26, 28
       TMPCOR files  . . . . . . . . . .  13, 71
       TRANSFORM . . . . . . . . . . . .  27
       Tymbasic conversion aid . . . . .  73
       Tymbasic cross reference generator  67
       Tymbasic program formatter  . . .  69
       TYMQUOTE  . . . . . . . . . . . .  87
       Type  . . . . . . . . . . . . . .  2

       UFD . . . . . . . . . . . . . . .  33
       UFD SCAN internal buffer  . . . .  41
       UFD SCAN package, overview  . . .  33
       Use of User Library Functions . .  2
       User library functions 
         use of  . . . . . . . . . . . .  2
       User-defined procedures . . . . .  2
       Username  . . . . . . . . . . . .  31, 33, 35

       Value of a function . . . . . . .  2

       WCN$  . . . . . . . . . . . . . .  13-14
       WCNC  . . . . . . . . . . . . . .  13-14
       Wild carding  . . . . . . . . . .  33, 39
       WPICK . . . . . . . . . . . . . .  13-14

       X22 . . . . . . . . . . . . . . .  94
       XBASIC program conversion . . . .  97

 }Zx