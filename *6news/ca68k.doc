


  
                   **************************
                   *                        *
                   *         CA68K          *
                   *                        *
                   *   BSO Absolute Cross   *
                   *        Assembler       *
                   *                        *
                   * (with Cross Reference) *
                   *                        *
                   **************************



                               for

                    68000 Microprocessors by

                            Motorola

                  (and all compatible devices)


                               on

                         TYMSHARE, INC.












                      BOSTON SYSTEMS OFFICE
                        469 Moody Street
                       Waltham, MA  02154
                         (617) 894-7800




                                                    25-AUG-1981



 










           Copyright, The Boston Systems Office, 1978










     This user's manual is intended as  a  thorough  product
     description.   It  is,  to  the  best of our knowledge,
     complete and accurate.

     The Boston Systems Office does  not,  however,  warrant
     this   document's   accuracy,  nor  shall  it  be  held
     responsible for errors of  content  or  omission.   The
     Boston Systems Office reserves the right to update this
     document without prior notification.



                       GENERAL INFORMATION

     Boston Systems Office offers a family of extremely effective
microprocessor   software  development  tools.   This  family  of
products includes universal microprocessor  development  systems,
assemblers,   compilers,  symbolic  simulator/debuggers,  linkage
editors, cross reference  programs,  program  librarians,  object
code  conversion  programs,  and  emulator  and  PROM  programmer
communication programs.  These tools allow the BSO  product  user
to   experience   the   high   speed  and  great  versatility  of
microprocessor program development on a BSO  development  system,
thereby  significantly reducing the number of hours or days spent
in microprocessor program development.  The advantages of the BSO
software   development   method   versus  a  microprocessor-based
development system include:

    - Much faster editing and assembly response
    - Multi-user capability
    - More powerful editors
    - Higher speed peripherals
    - Multi-microprocessor capability on one system
    - Lower station cost in multi-user configurations
    - Well established and proven operating system 
      and hardware
    - Proven file backup utilities

Microprocessor Assemblers

     For the application designer  who  requires  the  precision,
control  and  program execution times that only assembly language
programming  can  provide,   Boston   Systems   Office   provides
microprocessor  assemblers.   BSO's microprocessor assemblers, in
order to provide  the  fastest  response  in  the  industry,  are
written  in  assembly  language  for  DEC's  LSI-11, PDP-11, VAX,
DECsystem-10 or DECsystem-20 and Data General's  microNova,  Nova
and Eclipse computers.  They generally require between 6K and 32K
words of  memory  to  assemble  any  program.   These  assemblers
require   much   less   CPU   time  to  execute  than  any  other
microprocessor   assembler.    Benchmarks   against   competitive
assemblers  have  shown that time savings of 20 to 1 and more are
common.

     The executable instruction set accepted by each assembler is
the  same  as documented in the assembly language manual supplied
by the microprocessor manufacturer.   Mnemonics  exist  for  data
manipulation,  binary arithmetic, jumps to subroutines, and other
instructions.  In addition, all of  BSO's  assemblers  have  full
macro and extended conditional assembly capabilities.  

Linkage Editor and Relocation Facility

     The  object  file  produced  by  BSO's  assembler   can   be
processed,  along  with  other  relocatable  and  absolute object
modules that might be produced from other segments of a  program,
by  BSO's  compatible  linkage  editor.   The output would be one
complete program in absolute object format.



Format Conversion and Object File Transmission

     The absolute load module produced by the linkage editor  can
be  re-formatted  through  BSO's  OBJCNV program to generate many
different  output  formats.   These  include  not  only  all  the
microprocessor  manufacturer's  formats but also various emulator
formats such as Applied Microsystems, Millenium and Tektronix  as
well  as  PROM  programmer input formats.  The reformatted object
program can then be  down-line  loaded  into  almost  any  device
including  many  development  systems, in-circuit emulators, PROM
programmers or microprocessor system prototypes.

     The assembler is also capable of producing an object  format
with  additional symbol information, suitable for input to one of
BSO's companion integrated symbolic simulator/debuggers or  to  a
symbolic emulator such as Intel's MDS.

Symbolic Debugging and Simulation

     BSO's  symbolic  microprocessor   debuggers   are   uniquely
powerful  tools.   They enable the microprocessor system designer
to fully debug the  operating  software  for  the  microprocessor
application.   Memory  manipulation  commands (both RAM and ROM),
any instruction,  program  jumps,  interrupts,  and  input/output
instructions  can  all be easily tested or traced.  Full symbolic
capablity eases the designer's  task  considerably  as  do  macro
instruction   constructs   that  permit  extremely  flexible  and
selective execution monitoring.

Universal Microprocessor Support

     BSO products now support  more  than  twenty  microprocessor
manufacturers  including  Advanced  MicroDevices, AMI, Fairchild,
Fujitsu, Hitachi, Intel, Intersil, Matra-Harris, MOS  Technology,
Mostek,  Motorola,  National  Semiconductor,  NEC, RCA, Rockwell,
Signetics, Synertek, Thomson-CSF, Texas  Instruments,  Zilog  and
others.    Products  for  over  thirty  different  microprocessor
families   are   available   including   all   current   16   bit
microprocessors  such  as  Intel's 8086, Motorola's M68000, Texas
Instruments'  9900   and   Zilog's   Z8000.    Most   eight   bit
microprocessors  are supported as well, including the 8085, 8048,
Z80, 6800, 6801, 6802, 6809, 6502, 1802, F8, 2900,  PACE,  IMP16,
and others.  

Sales Offices

     US and Canadian customers can call the sales  department  of
the   Boston   Systems  Office  at  (617)  894-7800  for  further
information  on  BSO  support  for  any  microprocessor.   Boston
Systems  Office  products are sold throughout the world through a
network of over twenty  representatives.   Represented  countries
include  the  United  Kingdom,  Belgium, the Netherlands, Sweden,
Norway,  Finland,  West  Germany,  Switzerland,  France,   Italy,
Israel,  South  Africa,  India, People's Republic of China, Japan
and Australia.  All foreign customers are welcome to call BSO  or
Telex  at  710-324-0760  or  contact specific BSO representatives
directly.



                        TABLE OF CONTENTS

     Section                  Contents

     1.0       OPERATING INSTRUCTIONS
     1.1          Using the Listing and Object files
     1.2          Switches
     1.3          Listing Options
     1.3.1           Short (Narrow) Forms (/S)
     1.3.2           Omit Symbol Table (/T)
     1.3.3           Cross-Reference Mode (/X, /V)
     1.4          Object file options
     1.4.1           Debugger Support (/D)
     1.5          Sample Commands

     2.0       SOURCE PROGRAM PREPARATION
     2.1          Program Entry
     2.2          Program Format
     2.2.1           Label Field
     2.2.1.1            Local Labels
     2.2.2           Instruction Field
     2.2.3           Operand Field
     2.2.4           Comment Field
     2.3          Expressions
     2.3.1           Symbols
     2.3.2           Numeric Constants
     2.3.3           ASCII Constants
     2.3.4           Expression Operators
      

     3.0       INSTRUCTION SET

     4.0       ASSEMBLER DIRECTIVES (PSEUDO-OPS)
     4.1          Conditional Assembly
     4.2          The BSO Macro Facility
     4.2.1           Nesting Of Macros
     4.2.2           Using IFB and IFIDN Conditionals
     4.2.3           Exit from Macro: EXITM
     4.3          Repeat Directives
     4.3.1           IRPC
     4.3.2           IRP
     4.3.3           REPEAT (REPT)
     4.3.4           Arguments within Angle Brackets
     4.4          Listing Control
     4.4.1           BLIST,MLIST,NMLIST
     4.4.2           CLIST,NCLIST
     4.4.3           FORMLN
                           (Continued)



                  TABLE OF CONTENTS (continued)

     Section              Contents

     4.4.4           GEN,NOGEN
     4.4.5           LIST,NLIST   
     4.4.6           NAME
     4.4.7           PAGE
     4.4.8           SPACE (SPC)
     4.4.9           SUBTTL
     4.4.10          TITLE
     4.5          Miscellaneous Directives
     4.5.1           Input Control: INCLUDE 
     4.5.2           Default Radix Control: RADIX 
     4.5.3           Printout during Assembly: MESSAGE (MESSG)
     4.5.4           Floating Point Constants: FLOAT
     4.5.5           Local Symbol Block Control
     4.5.5.1            ENABLE LOCAL
     4.5.5.2            DISABLE LOCAL/LOCAL
     4.5.6           Forward branching: BRL, BRS
     4.5.7           Forward referencing: FRL, FRS
     4.5.8           PC relative addressing: PCS, NOPCS
     4.6          Location Control
     4.6.1           SECT
     4.6.2           ORG 

     5.0       FILE FORMATS
     5.1          Listing File Format
     5.1.1           Heading
     5.1.2           Fields in the Listing
     5.1.3           Symbol Table
     5.1.4           Cross Reference Symbol Table
     5.2          Object File Format

     6.0       ERROR HANDLING

     7.0       SUMMARY OF DIFFERENCES

     APPENDICES:

     I.        HOW TO REPORT DOCUMENTATION OR SOFTWARE PROBLEMS

     II.       PROBLEM AND SUGGESTION REPORT
                                                           Page 8


1.0 OPERATING INSTRUCTIONS

To run the 68000 cross assembler, at the monitor (system)  level,
type:

     -R CA68K 

The assembler will respond with the following:

     68000 Cross Assembler
     Copyright, The Boston Systems Office, Inc. 1978
     (617) 894-7800
     Type "/H" for help
     *

By typing "*", the  assembler  is  indicating  its  readiness  to
accept  a  command  and perform an assembly.  To this prompt, you
should type a command of the form

     *PROG.ABS,PROG.LST=PROG1.SRC,PROG2.SRC/N/S

The filenames shown above (PROG.ABS, PROG.LST,  PROG1.SRC,  etc.)
are  used  for  example  purposes  only,  and any acceptable file
specifications may be used.

PROG.ABS and PROG.LST are the names of the object and list  files
the assembler will create, respectively.  If either of these file
specifications is  omitted,  the  associated  file  will  not  be
generated.

If a list file is desired without an  object  file,  the  command
string  should  start  with  a  comma,  followed by the list file
specification, i.e., if only the  object  file  is  omitted,  its
trailing comma must still be included.

If only an object file is desired, without a list  file,  neither
the comma nor the list file specification need appear on the left
side of the "=" sign in  the  command  string  (see  examples  in
Section 1.5).

The source program(s) to be assembled is (are) specified  on  the
right  side of the "=" sign.  If more than one file is specified,
the named files are assembled  together,  as  if  they  were  one
source  file.   The  individual  source files are combined in the
same order in which  they  appear  in  the  command  string  (see
examples  in  Section  1.5).   As  many  files as will fit on one
command line may be specified, separated by commas.  At least one
source file is always required.

Optional switches may be included anywhere on  the  command  line
(that  a  delimiter would be expected).  These take the form of a
slash "/" followed by a single letter (shown in the above example
by "/N and /S"), and as many of these may be specified as desired
(including none).  Each switch slightly modifies the operation of
the  assembler.   The  available switches are detailed in Section
1.2.
                                                           Page 9


If extensions are omitted from the  file  specifications  in  the
command string, the following assumed default extensions apply:

     Object file     .ABS
     List file       .LST 
     Source files    .SRC

The 68000 cross assembler also accepts input from command  files.
An  "@" sign preceding a filename indicates to the assembler that
the command(s) in the named file are to be executed  as  if  they
were typed in at the terminal.  If an extension is not specified,
it is assumed to be ".CMD".

For example, if the file "TEST.CMD" contained a  command  string,
the programmer could simply type:

     @TEST

at the "*" prompt, to cause the  commands  in  "TEST.CMD"  to  be
executed.

To exit back to the monitor from the assembler, type Control-Z.



1.1 USING THE LISTING AND OBJECT FILES

The listing files created are in ASCII formats and may be printed
or  punched  by  using  standard  operating system commands.  Any
normal system commands may also be used to move these files  from
device  to device.  Consult your computer system user's guide for
more details.

Object files are in BSO format and may be run through OBJCNV, the
Object  Conversion  Utility,  when  they  are  needed in Motorola
format.  It is unlikely that object files will be  usable  except
as  input to OBJCNV, but since they are in ASCII format, they may
also be printed or punched if desired.  



1.2 SWITCHES

The user has the option of setting the default operation  of  the
cross assembler at the time that the assembler is built to either
"cross reference" or "non-cross reference".  The  "/X"  and  "/V"
switches enable the user to specify a mode other than the default
mode.  Following is a listing of switches available on the  cross
assembler.  Some of them may be the default on the user's system.

The  default  configuration  of  the  assembler  for   users   on
timesharing networks is "absolute" and "non-cross reference".  

      /D  Debug switch.  Include symbol table in object file (for
          use  by  BSO symbolic simulator/debuggers) (see Section
          1.4.1).
      /H  "Help".   Ignore  command  line   and   print   helpful
                                                          Page 10


          information.
      /I  Incompatibilities.  List the incompatibilities  between
          previous  versions  of  the  cross  assembler  and  the
          present version.
      /L  Listing directives.  Ignore  listing  directives  which
          suppress the printing of source lines in the list file.
          All source lines (including lines containing the "PAGE"
          directive) will appear in the list file.
      /N  Do not print assembly errors on user's terminal.
      /P  Indicate the start of pass 2 on the terminal.
      /S  Short listing  lines  for  narrow  forms  (see  Section
          1.3.1).
      /T  No symbol table in listing (see Section 1.3.2).
      /V  Do not  include  cross  reference  information  in  the
          symbol table (see Section 1.3.3).
      /X  Cross reference mode.  Produce a symbol  table  in  the
          list  file  which  includes cross reference information
          (see Section 1.3.3).



1.3 LISTING OPTIONS


1.3.1 SHORT (NARROW) FORMS (/S)

The listing produced by this assembler is designed for 132-column
(wide  form)  printers.   If  the  listing  is  to  be printed on
narrower paper, /S causes a short-form  listing  to  be  produced
instead.   /S  should not be specified unless it is required that
listings print on narrow paper, since some information is omitted
from the listing in /S mode.


1.3.2 OMIT SYMBOL TABLE (/T)

The listing normally contains a table of user symbols  and  their
values.   This  table  can  be  omitted  by  specifying /T in the
command line.


1.3.3 CROSS REFERENCE MODE (/X, /V)

The default mode of the assembler may be either  cross  reference
or non-cross reference, depending on how it was configured.  This
mode may be changed by including the appropriate  switch  in  the
command line.

By adding the /X switch to the end of  the  command  string,  the
user  instructs the assembler to operate in cross reference mode.
In this mode, the symbol table produced contains, in addition  to
symbol names and values, the cross reference information.

Adding a /V switch in the command line will cause  the  assembler
to operate in a non-cross reference mode.

The Cross Reference feature of the cross assembler  is  an  extra
                                                          Page 11


cost  option.  The /X switch will not work if this option has not
been purchased with your  software  (an  error  message  will  be
generated and the assembly will not be performed).



1.4 OBJECT FILE OPTIONS


1.4.1 DEBUGGER SUPPORT (/D)

When the user adds the /D  switch  to  the  end  of  the  command
string,  the  assembler  includes  its symbol table in the object
module.  This symbol table is subsequently read by BSO's symbolic
simulator/debugger,  which  then  has access to the user's symbol
definitions.

In order for symbols to be present in the  Motorola  format  file
which will be read by the simulator, the "/D" switch must be used
when converting BSO format to manufacturer format with OBJCNV.




                                                          Page 12


1.5 SAMPLE COMMANDS

The following examples are provided as  an  illustration  of  the
sort  of  commands  normally  given to the assembler.  Commentary
textrovided with each one.  Only  the  command  strings  are
shown   below;    they  are  always  typed  in  response  to  the
assembler's  prompt,  "*".   The  assumed   default   modes   are
"Absolute" and "Non-cross reference".

     A.ABS,A.LST=A.SRC
          Assemble source  file  A.SRC,  generating  object  file
          A.ABS  and  list file A.LST.  The object and list files
          are in standard format.  Assembly errors appear on  the
          user's terminal and in the list file.

     A,A=A
          Same  effect  as  above  command  string,  because   of
          defaults.

     A,A=A,B,C
          Assemble source files A.SRC, B.SRC, and C.SRC as though
          they  were one source file.  Generate object file A.ABS
          and list file A.LST.

     A=A
          Assemble source  file  A.SRC,  generating  object  file
          A.ABS.  No list file is generated.  Erroneous lines are
          printed on the user's terminal.

     ,A=A
          Assemble source file A.SRC, generating list file A.LST.
          No  object  file.   Assembly  errors appear both in the
          list file and on the user's terminal.

     FOO,BAR=PROG/X/N
          Assemble source  program  PROG.SRC,  generating  object
          file FOO.ABS and cross reference of symbols in the list
          file BAR.LST.  Erroneous lines appear only in the  list
          file;  they are not typed on the user's terminal.  
                                                          Page 13


2.0 SOURCE PROGRAM PREPARATION



2.1 PROGRAM ENTRY

In general, source programs for this assembler are placed on  the
host  computer  disk either by use of a text editor program or by
copying an existing source program from paper tape, punch  cards,
magnetic  tape,  etc.   Once  a  program  resides on disk, a text
editor program can be used  to  alter  or  correct  the  file  in
preparation  for  assembly.  Consult the operating system manuals
supplied with your computer for further  information  on  copying
and editing files on your system.




2.2 PROGRAM FORMAT

Each source program for the  6800  consists  of  lines  of  ASCII
characters.   Each  line  must  be no longer than 132 characters;
longer lines will be truncated and produce a warning message from
the assembler.

Lines beginning  with  an  asterisk  ("*")  will  be  treated  as
comments.   Blank  lines  will  be  ignored.   Each  source  line
(statement) consists of four parts or "fields":  The label field,
the  instruction  field, the operand field and the comment field.
Fields must be separated from each other by at least one space or
tab.  They are described below.



2.2.1 LABEL FIELD

The first field of a source program line  is  called  the  "label
field".   If  not  blank, the label field contains a symbol which
may be (1) a label, identifying a point in the program, or (2)  a
symbol  used with a MACRO, EQU or SET directive.  Any symbol used
in the label field must begin in the first  column  and  must  be
followed by at least one space or tab.

Symbols (labels) must be composed of  one  or  more  alphanumeric
characters, where "alphanumeric" includes the letters A though Z,
the  digits  0  through  9,  and  the  special   characters   "_"
(underscore)  and  "$"  (dollar  sign).   Lowercase  letters  are
treated as identical to their uppercase equivalents.   The  first
character of a symbol must be a letter or underscore.

A special symbol  format  exists  for  local  labels,  which  are
discussed  in  Section  2.2.1.1.  Symbols used with MACRO, EQU or
SET may not use this special format.

Program labels are optional.  A line containing  only  a  program
label  will  generate  no  code,  but will define the label to be
equal to the next available address.  
                                                          Page 14


2.2.1.1 LOCAL LABELS

Labels of the form described above are permanent, i.e.  they  may
be  referenced  from any point in a module.  This cross assembler
also recognizes temporary or  local  labels  which  may  only  be
referenced  from  a  limited  area.   Local  labels have the form
"nnn$" where  "nnn"  is  a  decimal  number  between  1  and  255
inclusive.

Local labels may only  be  referenced  from  within  their  local
symbol  block.   A  local  symbol  block  is  defined as the code
beginning  with  a  line  containing  a   permanent   label   and
terminating  on the line before the next permanent label.  Thus a
permanent label may be  used  to  identify  the  beginning  of  a
significant  section  of  code,  and temporary labels may be used
within this section to identify locations to which branching  may
occur.   This simplifies the choice of a label name and makes the
beginning of significant sections more evident.

Labels of the same name may be used  in  different  local  symbol
blocks without being considered multiply defined.  For example:

        GETNUM  XXXXX   Beginning of local symbol block
        1$      XXXXX   
                XXXXX
                XXXXX   End of local symbol block
        ADDNUM  XXXXX   Beginning of new local symbol block
                XXXXX
        1$      XXXXX   This local label is not multiply
                        defined, since it is in a different
                        local symbol block from the 
                        previous label named "1$"

BSO directives exist which allow the programmer to  start  a  new
local  symbol block without using a permanent label) or to extend
a local symbol block past a permanent label.  These are described
in Section 4.5.



2.2.2 INSTRUCTION FIELD

The  instruction  field  must  contain  either   an   instruction
mnemonic,  an  assembler  directive (pseudo-op), or the name of a
user-defined macro (i.e., a macro call).  This field is  followed
by at least one space or tab and must not begin in column one.



2.2.3 OPERAND FIELD

The operand field, if  required,  may  consist  of  one  or  more
operands  separated  by  commas.   An  operand  may  be  an ASCII
constant, numeric expression, character string, symbol  name,  or
the name of a 6800 register.  The expected contents of this field
will  depend  on  the  instruction,  directive,  or  macro   name
appearing in the instruction field.
                                                          Page 15


2.2.4 COMMENT FIELD

This field is optional;  it will be  ignored  by  the  assembler.
All  comments  will  appear  in  the  listing,  but  will  not be
assembled.  The comment field must be preceded by  at  least  one
space or tab.  An asterisk "*" in the first column indicates that
the whole line is a comment.





2.3 EXPRESSIONS

Expressions can be made up of user symbols and numeric and  ASCII
constants.   These  elements  may  be  combined  by  the  various
operators described in Section 2.3.4.  



2.3.1 SYMBOLS

Any alphanumeric symbol which has been used as a statement  label
or  equated to a value may be used in an expression.  Symbols may
be any length.  The special symbol "*" (asterisk) may be used  to
denote the location of the first byte of the current instruction.



2.3.2 NUMERIC CONSTANTS

Numeric constants may be specified as binary, octal, decimal,  or
hexadecimal constants by preceding or following the number with a
character indicating the radix used.  Letters follow the  number;
special  characters  precede the number.  The characters used are
shown below:

         % or B - BINARY          %0101 or 0101B
      @, O or Q - OCTAL           @15, 15O or 015Q
              D - DECIMAL         19D
         $ or H - HEXADECIMAL     $F80 or 0F80H *

* Note that constants without a prefix must always start  with  a
numeric  digit (0 if necessary) in order to distinguish them from
user symbols.  Numbers without any indication of radix (no prefix
or  suffix  characters)  will  be considered to be in the default
radix, initially decimal.  The user can change the default  radix
of  his  numbers  by  using  the  "RADIX"  directive (see Section
4.5.2).



2.3.3 ASCII CONSTANTS

An ASCII  constant  is  represented  by  up  to  four  characters
enclosed  in  single  quotes  (').   This  construct produces the
seven-bit  ASCII  value  of  the  character(s)  specified.    Any
                                                          Page 16


printable character is permitted.



2.3.4 EXPRESSION OPERATORS

The operators available for constructing expressions include both
the unary and binary operators listed below:


UNARY:  +       Identity
        -       Negation
        .NOT.   Logical one's complement
        .BYTE0. Access low 8 bits of value
        .BYTE1. Access 2nd byte of value
        .BYTE2. Access 3rd byte of value
        .BYTE3. Access 4th byte of value
        .WORD0. Access low word of value
        .WORD1. Access high word of value
        .LOW.   Access low-order 8 bits of 16-bit value.
        .HIGH.  Access high-order 8 bits of 16-bit value.

BINARY: +       Addition
        -       Subtraction
        *       Multiplication (unsigned)
        /       Division (unsigned) Any remainder is discarded.
        .MOD.   Modulo.  Result is the remainder caused by a
                division operation.
        ^       Exponentiation

        &       Logical AND (= 1 if both ANDed bits are 1)
        .AND.   Logical AND
        !       Logical OR (=1 if either ORed bit is 1)
        .OR.    Logical OR 
        .XOR.   Logical Exclusive Or (=1 if bits are different)

        .EQ.    Equal
        =       Equal
        .NE.    Not equal
        .GE.    Signed greater than or equal
        .GT.    Signed greater than
        >       Signed greater than
        .LE.    Signed less than or equal
        .LT.    Signed less than
        <       Signed less than
        
        .UGE.   Unsigned greater than or equal
        .UGT.   Unsigned greater than
        .ULE.   Unsigned less than or equal
        .ULT.   Unsigned less than

        .ASL.   Arithmetic shift left
        .ASR.   Arithmetic shift right
        <<      Shift operand 'y' to the left 'x' bit
                positions  (y << x)
        .SHL.   Same as <<
        >>      Shift operand 'y' to the right 'x' bit 
                                                          Page 17


                positions (y >> x)
        .SHR.   Same as >>
        .ROL.   Rotate left
        .ROR.   Rotate right


The full word operators must be separated from their operands  by
at  least  one  space  or  tab.   Expressions  will  be evaluated
according to the following operator precedence, and from left  to
right when of equal precedence:

           
           1)  parenthesized sub-expressions
           2)  ^
           3)  Unary -
           4)  .ASL., .ASR., .ROL., .ROR., .SHL., .SHR., >>, <<
           5)  .NOT.
           6)  .AND., &
           7)  .OR., !, .XOR.
           8)  *,/, .MOD.
           9)  +, binary - 
           10) .EQ., .NE., .LE., .LT., .GE., .GT., =, <, >, 
               .UGT., .UGE., .ULT., .ULE.
           11) .HIGH., .LOW., .BYTE0., .BYTE1., .BYTE2., .BYTE3., 
               .WORD0., .WORD1.
                                                          Page 18


3.0 INSTRUCTION SET

This assembler supports the standard set of instruction mnemonics
for the 68000.  A detailed explanation of each may be obtained by
referring  to  the  Cross  Macro  Assembler   Reference   Manual,
(M68KXASM(D3).  The supported instruction mnemonics are:
          
          
          ABCD          ADD           ADDA          ADDI
          ADDQ          ADDX          AND           ANDI
          ASL           ASR           BCC           BCHG
          BCLR          BCS           BEQ           BGE          
          BGT           BHI           BLE           BLS          
          BLT           BMI           BNE           BPL          
          BRA           BSET          BSR           BTST         
          BVC           BVS           CHK           CLR          
          CMP           CMPA          CMPI          CMPM         
          DBCC          DBCS          DBEQ          DBF
          DBGE          DBGT          DBHI          DBLE
          DBLS          DBLT          DBMI          DBNE         
          DBPL          DBRA          DBT           DBVC         
          DBVS          DIVS          DIVU          EOR          
          EORI          EXG           EXT           JMP          
          JSR           LEA           LINK          LSL          
          LSR           MOVE          MOVEA         MOVEM        
          MOVEP         MOVEQ         MULS          MULU         
          NBCD          NEG           NEGX          NOP          
          NOT           OR            ORI           PEA          
          RESET         ROL           ROR           ROXL         
          ROXR          RTE           RTR           RTS          
          SBCD          SCC           SCS           SEQ          
          SF            SGE           SGT           SHI          
          SLE           SLS           SLT           SMI          
          SNE           SPL           ST            SVC          
          SVS           STOP          SUB           SUBA         
          SUBI          SUBQ          SUBX          SWAP         
          TAS           TRAP          TRAPV         TST          
          UNLK
          
          
                                                          Page 19


4.0 ASSEMBLER DIRECTIVES (PSEUDO-OPS)

In addition to 68000 instructions, this  assembler  recognizes  a
wide  range  of  directives or so-called "pseudo-ops".  These may
appear in the instruction field of any statement  instead  of  an
instruction mnemonic.

BSO directives are standard from one cross assembler to  another,
so  are  not  necessarily identical to manufacturer directives in
name or in function.   BSO  directives  are  summarized  in  this
section   and  described  in  the  rest  of  this  chapter.   For
compatibility, the names of certain manufacturer  directives  may
be  used  in place of BSO directives.  See category 7 below for a
list of equivalent directives.


DIRECTIVES          CATEGORY

BLIST               4
BRL                 Forward branching (see Sec. 4.5.6)
BRS                 Forward branching (see Sec. 4.5.6)
CLIST               4
DC                  5
DISABLE LOCAL       Local symbol control (see Sec. 4.5.5)
DS                  5
ELSE                1
ENABLE LOCAL        Local symbol control (see Sec. 4.5.5)
END                 5
ENDIF               1
ENDM                2
ENDR                3
EQU                 5
FLOAT               Floating point constants (see Sec. 4.5.4)
FORMLN              4
FRL                 Forward referencing (see Sec. 4.5.7)
FRS                 Forward referencing (see Sec. 4.5.7)
G                   7
GEN                 4
IF                  1
IFB                 1
IFDEF               1
IFE                 1
IFGE                1
IFGT                1
IFIDN               1
IFLE                1
IFLT                1
IFN                 1
IFNB                1
IFNDEF              1
IFNIDN              1
IF1                 1
IF2                 1
INCLUDE             Input control (see Sec. 4.5.1)
IRP                 3
IRPC                3
LIST                4
                                                          Page 20


LOCAL               Local symbol control (see Sec. 4.5.5)
MACRO               2
MESSAGE             Printout during assembly (Sec. 4.5.3)
MLIST               4
NAME                4 
NCLIST              4
NLIST               4
NMLIST              4
NOGEN               4
NOLIST              7
NOL                 7
NOPCS               PC relative addressing (see Sec. 4.5.8)
ORG                 6
ORG.L               6
PAGE                4
PCS                 PC relative addressing (see Sec. 4.5.8)
RADIX               Default radix control (see Sec. 4.5.2)
REPEAT              3
SECT                6
SET                 5
SPACE               4
SPC                 7
SUBTTL              4              
TITLE               4
TTL                 7



Categories referenced above:

(1)  These  directives  deal  with  BSO's  conditional   assembly
facility, described in detail in Section 4.1 of this manual.

(2) These directives deal with BSO's macro facility, described at
length in Section 4.2 of this manual.

(3) These are repeat directives, described in Section 4.3 of this
manual.

(4) These are listing control directives,  described  in  Section
4.4 of this manual.

(5) These directives are part  of  the  standard  68000  assembly
language and details of their use can be found in the Cross Macro
Assembler Reference Manual, No.  M68KXASM(D3).

(6) These are location directives, described in  Section  4.6  of
this manual.

(7) This Motorola directive name may be  used  in  place  of  the
corresponding  BSO  directive  but  must  conform to BSO rules of
operation.

         Motorola Directive          BSO Directive

             G                           GEN
             NOLIST                      NLIST
                                                          Page 21


             NOL                         NLIST
             TTL                         TITLE
                                                          Page 22


4.1 CONDITIONAL ASSEMBLY

It is often necessary to make minor  changes  in  assembled  code
based  on  frequently-altered  parameters.   This assembler has a
powerful conditional assembly feature which permits such  changes
to be made with minimum effort.

Several conditional assembly directives are available.  Each  has
the  capability  of  turning the assembly of particular blocks of
code  on  or  off,  depending  on  a  specific  condition.    The
directives are summarized below:


     Pseudo-     Syntax                Condition tested
       op
     
     IF        IF logical expr       true                        
     IF        IF expr               expr <> 0
     IFE       IFE expr              expr = 0
     IFN       IFN expr              expr <> 0
     IFLT      IFLT expr             expr < 0
     IFGT      IFGT expr             expr > 0
     IFLE      IFLE expr             expr <= 0
     IFGE      IFGE expr             expr >= 0
     IFDEF     IFDEF sym             sym is a defined symbol
     IFNDEF    IFNDEF sym            sym is an undefined symbol
     IF1       IF1                   this is pass 1#
     IF2       IF2                   this is pass 2#
     IFB   *   IFB <string>          string is blank
     IFNB  *   IFNB <string>         string is not blank
     IFIDN *   IFIDN <str1>,<str2>   str1 and str2 are identical
                                     character strings
     IFNIDN*   IFNIDN <str1>,<str2>  str1 and str2 are not 
                                     identical
     
* Directives denoted by an asterisk  are  useful  only  in  macro
bodies;   see  Section  4.2.2.   For  the  conventions  regarding
arguments within angle brackets, see Section 4.2.3.

#The first assembler pass assigns location values to symbols  and
labels.    It  resolves  forward  references.   The  second  pass
performs the remainder of the assembler  work,  creating  listing
lines,  object  code  and  evaluating  size  and syntax.  The IF1
conditional is used  to  encompass  code  that  is  known  to  be
resolved  in  PASS  1,  thus  saving  overhead  in  PASS 2 by not
performing the same operations on it in PASS  2.   Care  must  be
taken  in  using  IF1  (IF2).   In  PASS  1  there  is no forward
referencing in the code unless it is also operated upon  in  PASS                                     ____
2,  so  that the code must be examined in detail before assigning
any of the pass conditions to it.   Using  IF1  around  a  symbol
definition  will cause it to be treated as a forward reference in
PASS 2 and could possibly  cause  phase  errors  and  wasted-byte
errors.

                                                          Page 23


The end of a block of conditional code is indicated by  an  ENDIF
directive.   When the assembler encounters one of the conditional
assembly  directives  listed  above,  it  tests  the   associated
condition  and  determines whether or not that condition is true.
If the condition is not true, all lines of  source  text  between
the  conditional  assembly  directive  and  its  associated ENDIF
directive are ignored by the assembler (see Section 4.4  for  how
to  control  how  such lines appear in the assembly listing).  If
the condition tests true, the code is assembled normally.

In addition, an optional  "ELSE"  directive  exists  which,  when
appearing  in  a  block of conditional code, reverses the current
true/false state of the conditional.  

The following example illustrates the use of conditional assembly
in a program.

                  IF      HSIZE !G 3      
          *
          *
          * Code here would be assembled if HSIZE > 3
          *
          *
                  ELSE
          *
          *
          * Code here would be assembled if HSIZE <= 3
          *
          *
                  ENDIF

Conditional assembly directives may be nested to  any  reasonable
depth;   that  is, a conditional block of code may itself contain
other  conditional  blocks,  each  starting  with  one   of   the
previously listed directives, ending with an ENDIF directive, and
optionally containing one or more ELSE directives.  
                                                          Page 24


4.2 THE BSO MACRO FACILITY

Included in this assembler is a macro facility which permits  the
user  to define pseudo-instructions of sorts which are considered
by the assembler to be equivalent  to  any  number  of  lines  of
source  text.  Macros are very flexible and powerful in that they
provide the ability to generate many lines of code  with  only  a
single reference in the user program.

Macros operate strictly at the  source  level  and  work  on  the
easy-to-understand principles of simple text substitution.

The MACRO and ENDM directives  are  used  to  define  macros.   A
sample macro definition follows.

        XYZZY   MACRO   ARG1,ARG2
                ARG1    2,3,ARG2
                DC.B    ARG2
                ENDM

The first line contains the MACRO directive, which  indicates  to
the  assembler that the following lines define a macro.  The name
of the macro being defined in  this  case  is  XYZZY.   The  name
appears  in  the  label field of the macro definition line.  ARG1
and ARG2 are the macro's so-called "dummy  arguments".   A  dummy
argument is any series of characters which usually also appear at
least once in the body of the  macro.   The  body  of  the  macro
definition is terminated by the ENDM directive.

To examine how macros function, we must first  examine  a  sample
use of this "XYZZY" macro.  Let us assume that the following line
of source text appears in a program  somewhere  after  the  above
macro definition:

                XYZZY   DC.W,2

Upon seeing this line, the assembler functions as follows:

(1) The assembler sees "XYZZY" in the instruction mnemonic  field
of  the source line, and, recognizing that it is not an assembler
directive (pseudo-op), the assembler determines  whether  or  not
"XYZZY"  is  a  user-defined macro before checking it against the
list of recognized instructions.  It then  discovers  that  XYZZY
was,  in  fact,  previously  defined  by  the user as a macro, as
demonstrated earlier.

(2) The assembler then examines the definition of XYZZY which was
given  to  it  earlier,  and  discovers  that  it  has  two dummy
arguments, which were  called  ARG1  and  ARG2.   It  finds  ARG1
appearing  in  one  place in the body of the macro definition (as
the opcode of the first line) and ARG2 appearing  in  two  places
(as  an  operand  field  argument  in  both  lines of the macro).
Looking at the macro call line, above, it finds the call  to  the
macro XYZZY has two parameters, "DC.W" and "2".

                                                          Page 25


(3) The assembler replaces the appearance of the line

                XYZZY   DC.W,2

with the block of text which was defined for the macro XYZZY, but
it  replaces all occurrences of ARG1 (the first dummy argument in
the definition) with DC.W  (the  first  actual  argument  in  the
call),  and  all  occurrences of ARG2 (the second dummy argument)
with 2 (the second actual argument).  The resulting lines of code
appear as follows:

                DC.W    2,3,2
                DC.B    2

Note that all the lines between the MACRO line and the ENDM  line
in  the  macro  definition  are  substituted  verbatim, except in
places where dummy arguments appear in the macro definition.   In
these  places,  and  in  these  places only, the actual arguments
appearing in the macro call are substituted.  Note  also  that  a
macro  call  is always only one line, but a macro definition (and
the resulting expansion of the macro performed by  the  assembler
at macro call time) can be many lines long.

There are several things to remember about  macros  in  order  to
minimize confusion on the part of the user.

First, it cannot be overemphasized  that  the  assembler's  macro
processor   operates   strictly   at   the   source   text  (text
substitution) level, and that  the  macro  processor  is  not  in
itself  concerned with the syntax of 68000 instructions.  This is
significant, because the macro processor portion of the assembler
does  not concern itself with whether or not the lines which will
result from  a  macro  call  will  be  considered  valid  by  the
assembler proper.  For example, a programmer could use the line

                XYZZY   DC.B,DC.B

as a call to the XYZZY  macro  defined  earlier,  and  the  macro
processor would (correctly) substitute "DC.B" for ARG1 and "DC.B"
for ARG2.  The resulting lines would be

                DC.B    2,3,DC.B
                DC.B    DC.B

These lines would then be examined by the assembler  proper,  and
would obviously produce an error message.

Users frequently do not realize that, in  its  text  substitution
and  pattern  matching,  the normal "fields" of a source line are
not considered by the macro processor.  As an  example,  consider
the  following problematic macro definition which an unsuspecting
programmer might use:

        THING   MACRO   E
        SUM     EQU     10+E
                ENDM
                                                          Page 26


The user suspects that this macro will equate SUM to 10 plus  the
argument  in the macro call.  Unfortunately, the user has elected
to use the dummy argument name "E", which appears  TWICE  in  the
macro  body,  once  after  "10+",  and  once  as  part of the EQU
directive.  Thus, the call

                THING   20

would not generate the line

        SUM     EQU     10+20

but would instead generate

        SUM     20QU    10+20

Upon presentation of this line to the assembler proper, it  would
encounter  the  string "20QU" in the instruction field, and would
issue an error  message,  since  "20QU"  is  not  a  valid  68000
instruction  or  assembler  directive.   The lesson to be learned
here is a simple one:  Users should select dummy  argument  names
which are complex enough not to appear in undesired places within
the macro body.  The fact that any characters (other than  comma)
may  be  used  in macro dummy argument names can be used to one's
advantage.   To  insure  that  the  dummy   argument   does   not
accidentally  appear  where  it is not desired in the macro body,
users frequently find it convenient to start all  dummy  argument
names  with  an  unusual  character  (e.g.  "%", "&", etc.).  For
example, the above macro definition could have been rewritten

        THING   MACRO   %E
        SUM     EQU     10+%E
                ENDM

This would work correctly, since "%E" does not appear anywhere in
the macro body except in the desired position.



                                                          Page 27


4.2.1 NESTING OF MACROS

The BSO macro facility  permits  a  variety  of  types  of  macro
nesting  and redefinition.  These features prove quite useful for
various purposes.  Macros may be redefined at any time;  that is,
if a macro "ABC" is defined (and used), and another definition of
"ABC" appears subsequently, the new definition supersedes the old
definition and is in effect beginning with the next occurrence of
a call to "ABC".  Macros may call other macros  (that  is,  macro
definitions  may  include  calls  to  other  macros).   When this
occurs, all macro expansion is done at macro call time.  Thus, it
is  not  necessary  to  define macros in any particular order, as
long as all nested macros have been defined by the  time  one  is
called.   This  feature,  combined with the redefinition feature,
makes it possible to use the macro  facility  to,  for  instance,
build  corresponding  entries  in  parallel tables.  Consider the
following lines of code:

        STUFF   MACRO
                XX      1,1
                XX      2,4
                XX      3,9
                ENDM
        
        XX      MACRO   %A,%B
                DC.B    %A
                ENDM
        
        NUMTAB  STUFF
        
        XX      MACRO   %A,%B
                DC.B    %B
                ENDM
        
        SQRTAB  STUFF

The first thing we see in the example above is a definition for a
macro  called "STUFF".  This macro simply contains three calls to
another macro, called "XX".  The XX macro has  not  as  yet  been
defined, but this is of no consequence, since the user has merely
defined the "STUFF" macro, but has not yet attempted to call  it.
Had  the  user followed the definition immediately with a call to
"STUFF", the assembler would encounter three references to  "XX",
which  would  be an undefined instruction at that point and which
would generate errors.  Also note that the "STUFF" macro  has  no
parameters.   This  is  permissible.   A  macro need not have any
dummy arguments at all.

Following the definition of STUFF, we see a definition  of  "XX".
This  macro has two dummy arguments, "%A" and "%B", but only "%A"
is actually used within  the  macro  body.   While  this  is  not
normally  done,  the  macro  processor  of the assembler does not
consider the condition an error;  it merely notes that  "XX"  has
two dummy arguments, but that the second one is never used.

                                                          Page 28


The next line contains a label (NUMTAB) and a call to  the  macro
STUFF.   This  time,  XX  has been defined, so that STUFF expands
into three calls to  XX,  and  each  of  them  generates  a  DC.B
directive to generate a byte containing the first argument to XX.
The end result is a table which looks like

        NUMTAB  DC.B    1
                DC.B    2
                DC.B    3

Next, we see that "XX" is redefined.  This definition is  similar
to the first definition of XX, except that this time it generates
a byte for the SECOND argument,  and  ignores  the  first.   This
definition of XX supersedes the earlier definition.

Now, STUFF is  called  again,  and  generates  another  table  of
entries, which looks as follows:

        SQRTAB  DC.B    1
                DC.B    4
                DC.B    9

The end result of all this work is that  we  have  generated  two
parallel tables, one containing integers and one containing their
associated squares.  More entries could easily be added to  these
tables  by  adding more "XX" entries within the definition of the
"STUFF" macro.  The two tables are guaranteed  to  be  in  phase,
because  they  are  generated  using  the  macro  facility of the
assembler.

BSO macros can directly and  indirectly  call  and  define  other
macros,  and  can  even  call or define themselves.  When a macro
calls itself, the user must be careful to  see  to  it  that  the
calling  process  does  not  continue indefinitely.  When a macro
defines itself, the new definition  takes  effect  in  subsequent
calls  to  the  macro,  but the current macro expansion continues
from the old definition.



4.2.2 USING IFB AND IFIDN CONDITIONALS

The macro and conditional assembly features of this assembler are
frequently  combined  for  various  purposes.  In addition to the
normal set of conditional directives, there are several which are
useful   only  in  the  context  of  a  macro  expansion.   These
conditionals can test whether or not a character string is  blank
(IFB  and  IFNB)  and  whether  or  not two character strings are
identical (IFIDN and IFNIDN).  An example follows:

        ABC     MACRO   ARG1,ARG2
                JMP     ARG1
                IFNB    <ARG2>
                DC.W    ARG2
                ENDIF
                ENDM
                                                          Page 29


If the ABC macro is called with only one  actual  argument,  then
that  argument  is  substituted for the dummy argument ARG1.  The
dummy argument ARG2 would have a null (empty) string  substituted
for it, since no actual argument was supplied in the call.  Thus,
the call

                ABC     FOO

would expand as follows:

                JMP     FOO
                IFNB    <>
                DC.W
                ENDIF

Since the string following IFNB is  in  fact  blank,  IFNB  would
evaluate  false, and the result would essentially be just the JMP
instruction.

On the other hand, a call like

                ABC     FOO,5

would expand differently:

                JMP     FOO
                IFNB    <5>
                DC.W    5
                ENDIF

This time, the string argument to IFNB is in fact not  blank,  so
the DC.W would be generated in addition to the JMP.

IFIDN and IFNIDN perform similarly.  They compare two strings, at
least one of which is usually a macro argument.

Note that IFB, IFNB, IFIDN, and IFNIDN are not useful outside  of
macros  because their arguments in such a situtation would always
be constant, and they would always generate the same code.   Also
note  that  "0"  is not a blank argument.  It is an argument with
one character in it.  The only truly blank argument is one  which
is  omitted  from the macro call.  If it is not the last argument
on the line, an argument can be made blank by only including  its
trailing comma.  For example, in the macro call

                MAC     A,,B

the macro "MAC" is being called with the first argument "A",  the
second argument null, and the third argument "B".

Note that the argument to the four conditionals discussed in this
section  is  enclosed  in  angle brackets.  There are special BSO
conventions regarding arguments within angle brackets  which  are
discussed in Section 4.3.4.
                                                          Page 30


4.2.3 EXIT FROM NESTED MACRO:  EXITM

The EXITM directive terminates a macro expansion before  the  end
of   the  macro.   Termination  is  the  same  as  if  ENDM  were
encountered.  EXITM may also be used in Repeat blocks.

EXITM is particularly useful in conditional expansion  of  macros
as  it  eliminates  the  need  to  worry about nested conditional
directives and alternate assembly paths.

For example:

          XXX     MACRO %COUNT
                  . .
                  . .
                  IF %COUNT GT MAXIMUM
                  MESSAGE 'Count too great'
                  EXITM
                  ELSE
                  REPEAT %COUNT
                  . .
                  ENDR
                  ENDIF
                  ENDM
                                                          Page 31


4.3 REPEAT DIRECTIVES


4.3.1 IRPC

It is often desired to repeat one or  more  lines  of  a  program
several  times, with each repetition different in only one place.
The IRPC command (Repeat Character) allows an arbitrary number of
one character substitutions in a sequence of lines.  It is really
a special form of a macro, as follows:

                IRPC    dummy_arg, actual_args
                 .
                 .
        (The IRPC lines follow here.)
                 .
                 .
                ENDR

The following example:

                IRPC    ARG,ABCD
                DC.B    'ARG'
                ENDR

would generate the lines:

                DC.B    'A'
                DC.B    'B'
                DC.B    'C'
                DC.B    'D'

Since  the  repeat  directives  are in effect macros, they can be
nested just as regular macros are.  The following is  an  example
of the nested use of the IRPC directive.

        TABLE   MACRO   ARG
                IRPC    CHAR,ARG
                DC.B    'CHAR'
                ENDR
                ENDM
                TABLE ABXY

In this example, the IRPC  directive  in  the  macro  causes  the
argument "ARG" to be broken into subarguments, each consisting of
one character from the string substituted for "ARG".  Each of the
characters  is  then substituted in for the dummy argument "CHAR"
and the line between the IRPC and ENDR (End Repeat) directives is
repeated with this substitution for each character in the string.
The following assembly lines would be produced by the macro  call
line "TABLE ABXY".

                IRPC    CHAR,ABXY
                DC.B    'CHAR'
                ENDR
                DC.B    'A'
                DC.B    'B'
                                                          Page 32


                DC.B    'X'
                DC.B    'Y'


4.3.2 IRP

IRP is a more general form of IRPC, where  the  actual  arguments
are  character  strings separated by commas and enclosed in angle
brackets, rather than being individual characters.  For example:

                IRP     ARG,<HEL,LO>
                DC.B    'ARG'
                ENDR

would generate these lines:

                DC.B    'HEL'
                DC.B    'LO'

When an IRP is nested within a macro whose argument  will  become
the  IRP  actual  argument, care must be taken to ensure that the
IRP arguments end up enclosed in angle brackets.   Each  time  an
argument  substitution  is  made,  the  outermost  pair  of angle
brackets is stripped away.  So the following macro:

        MSGS    MACRO   TEXTS
                IRP     MSG,TEXTS
                DC.B    'MSG'
                ENDR
                ENDM

could be  called  with  an  argument  enclosed  in  double  angle
brackets:

                MSGS    <<HEL,LO>>

When the macro is expanded, the IRP is given the  two  arguments,
enclosed in a single pair of angle brackets:

                IRP     MSG,<HEL,LO>
                DC.B    'MSG'
                ENDR    

since one pair of brackets  was  stripped  away  when  the  macro
argument  substitution  was  made.  When the IRP is expanded, the
final pair of brackets is stripped away:

                DC.B    'HEL'
                DC.B    'LO'

A simpler method with an equivalent result would  be  to  enclose
the  actual  argument of the IRP in single angle brackets, and to
call the macro with arguments enclosed in single brackets.

        MSGS    MACRO   TEXTS
                IRP     MSG,<TEXTS>
                DC.B    'MSG'
                                                          Page 33


                ENDR
                ENDM

                MSGS    <HEL,LO>

It is good practice to use this  second  method.   This  way  the
programmer  will  not  have  to worry about the format of the IRP
when making the macro call.



4.3.3 REPEAT (or REPT)

The REPEAT directive causes  a  sequence  of  source  code  lines
between  REPEAT  and ENDR to be repeated identically an indicated
number of times.

For example, the following code deposits "0" in  five  successive
bytes:

                REPEAT  5
                DC.B    0
                ENDR

REPEAT's argument may be any absolute (i.e.  not relocatable  and
not  external) expression, except that forward references are not
allowed.



4.3.4 ARGUMENTS WITHIN ANGLE BRACKETS

IRP arguments and arguments used with IFB  and  IFIDN  directives
must  be  enclosed in angle brackets.  Angle brackets may also be
used when the programmer wants to use a macro or repeat directive
argument which contains a comma.  

Normally, a comma in an argument list separates  arguments.   For
example, the line:

        XYZ     ARG1,ARG,2,ARG3

is a call to the macro XYZ with  four  arguments.   However,  the
line:

        XYZ     ARG1,<ARG,2>,ARG3

calls XYZ with three arguments:  "ARG1", "ARG,2" and "ARG3".  Any
comma   occurring   within   enclosing  angle  brackets  will  be
considered a literal character, not an argument delimiter.   When
an  argument substitution is made, the (outermost) angle brackets
are stripped away.

When multiple argument substitutions are made, as when macros  or
repeat  directives  are  nested,  arguments containing commas may
need to be enclosed in multiple  pairs  of  angle  brackets.   An
example  and  description  of multiple angle brackets is given in
                                                          Page 34


Section 4.3.2.

As long as angle brackets are evenly paired, any number of  angle
brackets  may  be  nested  within  each  other.   However,  if an
argument must contain a  single  angle  bracket,  something  must
indicate  to  the assembler that this is not the beginning or end
of an argument.  The  convention  used  by  BSO  is  the  "tilde"
convention,  which specifies that the character immediately after
a tilde (~) will be taken literally.  For example, the call

                XYZ     <ARG~<> 

specifies the argument  string  "ARG<".   In  addition  to  angle
brackets,  a  comma,  a  tilde  itself,  or any character, may be
placed in a macro argument by preceding it with a tilde.

Several examples of the use of angle brackets, commas and  tildes
in argument passing are given below.

        MAC1    A,<B,C,~>>      (Two arguments: "A" and "B,C,>"
        MAC2    A~,B,C,<<A,B>>  (Three arguments: "A,B", "C",
                                 and "<A,B>")
        IRP     DUM,<2,3>       
        IRP     DUM,2~,3        (Same as previous line)
        IRP     DUM,2,3         (Incorrect)
        IRP     DUM,<A,B,<C,D>> (Three repetitions)

        IRPC    DUM,2345        (Four repetitions)
        IRPC    DUM,<2345>      (Same as previous line)

                                                          Page 35


4.4 LISTING CONTROL

This cross assembler permits the user to control to  some  extent
the  format of the list file produced.  The directives which deal
with this listing control are summarized below.

The three directives  TITLE,  SUBTTL  and  FORMLN  will  actually
appear  in  the list file;  all the rest will not unless there is
an error on the line including the directive.


4.4.1 BLIST/MLIST/NMLIST

When a user calls a macro, the assembler usually shows the  macro
call  and  its  expansion  (textually)  in the list file (MLIST).
This default mode can be changed through  the  BLIST  and  NMLIST
directives.   The  latter,  NMLIST,  causes the assembler to only
show the call to a macro, and never show  its  expansion  in  the
listing.   BLIST is a compromise mode, which causes only lines of
macro expansion which generate some code to be listed.  That  is,
when  BLIST  is  specified,  lines of a macro expansion will only
appear in the listing if they cause the current location  counter
value  to  be  printed on their listing line.  Such lines include
those which  define  values  as  well  as  those  which  actually
generate  code.   These three directives each represent different
macro listing modes;  using one will counteract a previous use of
either of the other two.

BLIST, MLIST and NMLIST similarly determine the manner  in  which
the Repeat Directives are listed.


4.4.2 CLIST/NCLIST

Normally, blocks of conditional  code  which  are  assembled  out
(condition  tests false) still appear in the listing (CLIST).  By
specifying NCLIST, the user can cause such lines to be eliminated
from the listing.

The lines containing the conditional directives (IF, ELSE, ENDIF)
will  not  show  in  the  list file unless there is an error on a
line.


4.4.3 FORMLN

The directive "FORMLN n" where n is a  decimal  integer,  changes
the  assembler's  default  form  length to "n" lines.  Initially,
this value is 55.   After  every  n  lines,  the  assembler  will
advance automatically to the next page in the list file.


                                                          Page 36


4.4.4 GEN/NOGEN

The listing format has room for a fixed number of bytes of object
code  per  listing  line.   Normally, if a line of source program
generates more than this fixed amount, the listing will show  the
additional  bytes  on  subsequent lines in the listing (GEN).  If
this is not desired, the user may  specify  NOGEN.   This  causes
only  the first line of object code to be printed in the listing.
The object file still contains the complete information in either
case.


4.4.5 LIST/NLIST

The user can turn off the listing of sections of code  completely
by  using  NLIST.   The NLIST directive will cause the listing to
stop;  LIST will cause it to resume.  

An NLIST directive will always turn off the listing even if there
have  been  nested  LIST  directives  before  it.   However,  the
opposite is not true.  If  there  are  nested  NLIST  directives,
there must be one LIST directive for each nested NLIST before the
listing can be turned back on.


4.4.6 NAME

The directive "NAME object_name" specifies the name to  be  given
to  the  object module.  If no name is given to the object module
with the "NAME" directive, but a title has  been  specified  with
the  "TITLE"  directive,  the first word of the title will be the
name of the object module.  If neither a  title  nor  a  name  is
specified,  the  name  of  the  file  will become the name of the
object module.


4.4.7 PAGE

The PAGE directive causes the listing to advance to  the  top  of
the  next  page.   This also occurs if a form feed (control/L) is
encountered in the source file, and automatically every 55 lines,
or  as  set  by FORMLN (see Sec.  4.4.3).  If a PAGE directive is
used, only the  form  feed  occurs  in  the  listing;   the  PAGE
directive  itself does not appear (unless "/L" has been specified
in the command line).


4.4.8 SPACE (or SPC)

The directive "SPACE expr" causes  the  assembler  to  leave  the
specified  number  of  blank  lines in the list file at the point
where the directive appears.  "Expr" is any expression which  can
be  resolved  to  an absolute value at assembly time.  The actual
SPACE directive does not appear in the listing.


                                                          Page 37


4.4.9 SUBTTL

The  directive  "SUBTTL  subtitle-name"  causes   the   specified
subtitle  to  be  printed  on the second line of each page of the
list file.  "Subtitle-name" includes all characters typed between
"SUBTTL" and a carriage return.

Subtitles may be changed as often as  desired.   This  helps  the
user  locate  sections  of a large listing quickly.  If the first
line on a page is a SUBTTL directive, that subtitle  will  appear
on  that  page in the listing.  If a SUBTTL appears in the middle
of a page, it  will  become  effective  starting  with  the  next
listing page.  


4.4.10 TITLE

The directive "TITLE  title-name",  in  addition  to  naming  the
object module (see Section 4.4.6), also specifies the title to be
printed at the top of each listing page.   "Title-name"  includes
all  characters  between "TITLE" and a carriage return.  Only one
"TITLE" directive may appear in any program.  
                                                          Page 38


4.5 MISCELLANEOUS DIRECTIVES


4.5.1 INPUT CONTROL:  INCLUDE

At any point in a source program, the assembler can  be  directed
to  include  the source text from another file as if it were part
of the source program requesting the inclusion.  

The argument is a standard file specification of  the  same  type
found in the assembler command line.  An example of this usage:

        * DEFINITIONS OF SOME PARAMETERS

        XX      EQU     1
        YY      EQU     2
        ZZ      EQU     3

        * INCLUDE COMMON MACRO DEFINITIONS

                INCLUDE COMMON.SRC

Common usage of INCLUDEs, as shown above, would be to INCLUDE the
text from a file containing definitions of macros used frequently
in many programs (in this example, the file is named COMMON.SRC).
This may be preferable to listing a number of source files in the
assembly command line, as there is no  limit  to  the  number  of
files which may be included with the INCLUDE directive.

INCLUDEd files may  also  INCLUDE  other  files;   i.e.   INCLUDE
directives may be nested (to a maximum of 10 levels).



4.5.2 DEFAULT RADIX CONTROL:  RADIX

Normally, numbers appearing without any indication of  radix  are
assumed  to  be  decimal  (base  10) numbers.  By using the RADIX
directive, the user can change the default to  any  base  from  2
through 16 (expressed in decimal).  For example:

                RADIX   16

changes the default radix to hexadecimal.



                                                          Page 39


4.5.3 PRINTOUT DURING ASSEMBLY:  MESSAGE

The programmer may specify a "message" which will be  printed  on
the  user's  terminal (or output device in a batch job) as Pass 2
parses the line containing  the  directive.   The  format  is  as
follows:

          MESSAGE 'text'

Any text enclosed in single quotes will be printed during Pass  2
of the assembly.  



4.5.4 FLOATING POINT CONTROL:  FLOAT

The directive "FLOAT" followed by a floating  point  fraction  in
the following format:

        [sign] [whole_number] . fraction E [sign] exponent

                (for example: +2.567E-5)

will  deposit  four  bytes  in  IEEE  floating  point  format, as
follows:

          SEEEEEEE EFFFFFFF FFFFFFFF FFFFFFFF
      
                24       16        8        0  (Bit position)

where

         S = sign bit (negative when set)
         E = exponent field (biased by 127)
         F = 23-bit fraction (together with an implicit leading
             1 yields the significant digit field)

and thus the value of the real number is calculated as:

                (-1)^S*(1.F)*2**(E-127)




                                                          Page 40


4.5.5 LOCAL SYMBOL BLOCK CONTROL

The local symbol block control directives allow the programmer to
extend  a  local symbol block past a permanent label, if desired,
or to start a new local symbol block at any time.


4.5.5.1 ENABLE LOCAL

The ENABLE LOCAL directive defines the beginning of a  new  local
symbol block which can only be terminated by a DISABLE LOCAL or a
LOCAL directive (and is not terminated  by  a  permanent  label).
This  makes  possible  a  jump  past a permanent label to a local
label, as in the following example:


                ENABLE LOCAL
                JMP 1$
        FOO     NOP
        1$      NOP
                DISABLE LOCAL  (or LOCAL)

Local symbols appearing  after  an  ENABLE  LOCAL  directive  are
defined  even  if  they duplicate local symbols used prior to the
ENABLE LOCAL directive.


4.5.5.2 DISABLE LOCAL, LOCAL

The LOCAL directive begins a new  local  symbol  block  which  is
terminated  by  a line containing a permanent label or one of the
local  symbol  control   directives.    The   following   example
illustrates the use of local symbols and the LOCAL directive:

        AAA     NOP              New local block
        1$      JMP 2$           2$ is in the same block
        2$      JMP 1$           Jumps to first 1$
                LOCAL            New local block
                JMP 1$           Jumps to second 1$
        1$      JMP 2$           Error- 2$ undefined here
        BBB     JMP 1$           Error- New block starts
                                 here and 1$ not defined

The DISABLE LOCAL directive is identical to the LOCAL directive.



4.5.6 FORWARD BRANCHING:  BRL, BRS **

The BRL (forward branch long)  and  BRS  (forward  branch  short)
directives operate in the same manner as the Motorola OPT BRL and
OPT BRS directives.

BRL (the default) causes forward references  in  relative  branch
instructions  (Bcc,  BRA,  BSR) to assume the longer form (16-bit
displacement, yielding a 4-byte instruction).  
                                                          Page 41


BRS causes forward references in relative branch instructions  to
assume  the  shorter  form (8-bit displacement, yielding a 2-byte
instruction).



4.5.7 FORWARD REFERENCING:  FRL, FRS **

The FRL (forward  reference  long)  and  FRS  (forward  reference
short) directives are similar to the Motorola OPT FRL and OPT FRS
directives.

FRL  (the  default)  causes  forward  references   and   unknowns
(externals  and  addresses  in  foreign sections) to use the long
mode of addressing (32-bit addresses).

FRS forces forward references and unknowns to use the short  mode
of addressing, either PC relative or absolute, depending upon the
PCS directive (see next section).



4.5.8 PC RELATIVE ADDRESSING:  PCS, NOPCS **

The PCS directive (which  is  the  default)  forces  PC  relative
addressing  for addresses in the same section, and, if FRS is on,
for  forward  references,  externals  and  addresses  in  foreign
sections.  Absolute references are not affected.

The NOPCS directive disallows PC relative addressing for  forward
references, externals and addresses in foreign sections, but does
allow it for addresses in the same section.

** Relocatable features described in these sections (for example,
addressing  of externals) may only be used on a relocatable cross
assembler.
                                                          Page 42


4.6 LOCATION CONTROL

4.6.1 SECT

The SECT directive may be used to start or to continue a  section
at  a  certain  location.   The  format of the SECT directive the
first  time  it  occurs  with  each  section   name   is:    SECT
sectionname,  ABS, LOC = n where "section_name" is a user-defined
name (consisting of one to six  alphanumeric  characters),  "ABS"
indicates  an  absolute section, and "n" is the memory address at
which the section should begin.

For example:

          SECT A, ABS, LOC = 100H


          SECT section_name, ABS, PARA = n, LOC = n

where "section_name" is a user-defined name (consisting of one to
six  alphanumeric  characters),  "ABS"  indicates   an   absolute
section, "PARA=n" gives the paragraph number at which the section
should begin, and "LOC=n" gives the number  of  memory  locations
past  the  beginning  of  the  specified  paragraph  at which the
section should begin.

For example:

          SECT A, ABS, PARA=5, LOC=100H

The  use  of  the  "LOC" attribute differs from the ORG directive
described in the next  section  in  that  "LOC=100H"  causes  the
assembler to reserve memory starting at location 100H, whereas an
"ORG 100H" after the SECT directive reserves  memory  from  0  to
100H, then starts to reserve memory (as it is used) from location
100H.

Certain defaults exist for the SECT directive.   If  the  section
name  is  omitted,  it  will  default  to  ".ABS.".   If "ABS" is
omitted, it  will  be  assumed,  since  the  mode  of  the  cross
assembler  is  absolute.   omitted,  it will default to "0".  All
code following a SECT directive  is  assumed  to  belong  to  the
section  described in the directive, until another SECT directive
is given, describing a new section.  

Should the programmer wish to append code to a  section  of  code
which  appeared  earlier,  the  SECT  directive,  followed by the
section name described before, may be issued, as follows:  

          SECT A

Note that no information besides the  section  name  is  allowed.
This  command  causes all following code (until the appearance of
another SECT directive)  to  be  appended  to  previous  code  in
SECTION A.
                                                          Page 43


4.6.2 ORG

After a section has been defined, the programmer may occasionally
wish  to adjust the location counter to some value other than the
current value.  ORG may be used  for  this  purpose,  as  in  the
following example:

          SECT  TEST, ABS, LOC=10
          ORG   0100

In this example, Section TEST begins at  location  10,  and  code
following  the ORG begins at location 100.  The use of ORG forces
forward references to default  to  "short"  (16-bit)  addressing.
ORG.L  may  be  used  in  place  of  ORG,  in  which case forward
references will default to "long" (32-bit).
                                                          Page 44


5.0 FILE FORMATS

5.1 LISTING FILE FORMAT

5.1.1 HEADING

The format of the header on each page allows the listing files to
be  self-documenting.   The  header includes the date and time of
assembly, name and version number of the  product  that  did  the
assembly,  as  well  as  the  title  (as  specified  in the TITLE
directive or ".MAIN." if no title was  specified),  the  subtitle
(if a subtitle has been given with the SUBTTL directive), and the
name of the source file from which the listing was made.


5.1.2 FIELDS IN THE LISTING

There are five fields in a wide  forms  listing,  four  in  short
forms.  These are described from left to right.

     1.  Error Field.  This has room for a pre-determined  number
         of  errors:   5 for normal forms, 3 for short forms.  If
         more errors  occur  than  will  fit  in  the  field,  an
         asterisk is printed in place of the last printed error.

     2.  Address Field.  This shows the value of the  PC  at  the
         start  of the source line.  It is present on lines which
         contain labels and/or data.

     3.  Data Field.  This field displays the data  generated  by
         the  source  line.   If all the data will not fit on one
         line, multiple lines will be generated.

         Data in the listing takes the following form:

                  Bytes:      EDD
                  Words:      EDDDD
         where    E = Equate.  On values which correspond to
                      certain pseudo-ops (EQU, ORG, conditionals,
                      etc.) an equal sign ("=") will precede the
                      data argument.  This indicates that the
                      data is not object code, but only a refer-
                      ence for the user.

                  D = Data

     4.  Sequence Field.  This field  is  not  present  on  short
         forms.   Each  source line (including lines within macro
         expansions) is given a unique number for cross reference
         purposes.  

         If the source line came  from  a  macro  expansion,  the
         sequence  number  will be followed by a single letter (A
         through Z) to indicate the nesting  depth.   For  macros
         nested deeper than 26 levels, a "*" is printed.

         If the current source line contains a  macro  call,  the
                                                          Page 45


         sequence number (and nesting indicator) will be followed
         by a "+".

     5.  Source Field.  This is the source line as it  came  from
         either an input file or a macro expansion.


5.1.3 SYMBOL TABLE

Symbols may be of any length, but for readability symbols  larger
that  nine  characters  (eight  if short forms) are truncated and
followed with an asterisk.

Symbol values will be listed in one of the following ways:

         "Reserved"  - Symbol is a reserved symbol used for
                       opcode parsing (such as register names)

         "Undefind"    - Symbol was referenced but never assigned
                       a value, or was assigned an improper
                       value such as a forward reference.

         "Macro"     - Symbol is a macro name.

         value       - Symbol is a normal user symbol and
                       was assigned the indicated value.



5.1.4 CROSS REFERENCE SYMBOL TABLE

The Cross Reference Symbol Table appears at the end of  the  list
file  if (a) the cross reference option has been purchased by the
customer, and (b) the "/X" switch was used in  the  command  line
when the program was assembled.

The Cross Reference Symbol Table includes the  symbol  field  and
the  value  field as described above.  In addition, the reference
field is included.  This lists the sequence numbers of each  line
which  contains  a  reference  to  the  symbol.   Numbers  may be
followed by:

         # (pound sign)  - indicates that the symbol
                           was defined in this reference.

         $ (dollar sign) - indicates a write reference
                           to the symbol.



                                                          Page 46


5.2 OBJECT FILE FORMAT

The object file produced by this assembler is an  ASCII  file  in
BSO  format.   Since the format is quite complex, and since files
in BSO format are only used as input to other BSO software,  such
as the linker or OBJCNV, no detailed explanation of BSO format is
included in this manual.

When an object file in Motorola format is desired,  the  absolute
file   resulting   from   BSO's   absolute  assembler,  or  BSO's
relocatable assembler and linker, must be run through OBJCNV, the
object  file  conversion utility.  The Motorola format file which
will be produced by OBJCNVis an ASCII file in the format required
by the Motorola loader.  The record layout is shown below:

     
     S            First character of each record
     1 char       Record type: 0-header, 1-data with 2 byte
                  address, 2-data with 3 byte address, or 9-end
     2 chars      Number of bytes to follow
     4 or 6 chars Load address of first byte of record
     2 chars      First data byte
     2 chars      For each additional data byte
     2 chars      Checksum

The checksum is the one's complement of the sum of all the  8-bit
bytes  in  the  record, including the one byte count and two-byte
load address, with carries above 8 bits discarded.
                                                          Page 47


6.0 ERROR HANDLING

This assembler will print error messages at the  user's  terminal
and  in the program listing if the list file was requested in the
command line (unless /N  was  specified  in  the  command  line).
Errors are indicated by one or more characters at the left of the
listing line in which they occurred.  The assembler will  attempt
to  generate  some  code for each source line even if an error is
present so addresses further on in the program do not get out  of
phase.


Error                     Meaning
 Code


A   Address error.  Address specified is out of range  for  given
        instruction.  Relative branch out of bounds, etc.

B   Balance   error.    Unmatched   delimiters   (e.g.    quotes,
        parentheses, brackets, etc.)

C   Character error.  Indicates a character not in the  supported
        subset  for  the assembler, or one appearing in the wrong
        place (e.g.  invalid digit in number, etc.)

D   Macro definition error.  Indicates macro definition which  is
        missing   the  name  of  the  macro.   The  entire  macro
        definition (up to its matching ENDM) is ignored.

E   Expression error.  Invalid syntax in an  expression,  usually
        one of the following:
        (1) Undefined operators
        (2) Unary operators in binary positions, or vice-versa
        (3) Missing expression (blank field)

F   Format error.  Improper delimiters, missing  operand  fields,
        etc.  This error is similar to the Q error.

I   Include error.  Couldn't open an Include file.

J   Warning that address space is filled.  Location counter  will
        wrap  around  from  the highest allowable address to 0 if
        another byte is deposited.

L   Label error.  An illegal label was defined, or  a  label  was
        defined in pass 2 but not in pass 1.

M   Multiply-defined symbol.  A reference was made  to  a  symbol
        defined  more than once (where this is illegal).  All but
        the first definition are ignored.

N   Nesting error.  Mispaired IF:ENDIF, MACRO:ENDM, etc.  This is
        an   error   which   encompasses   more  than  one  line.
        Single-line delimiter pairing  errors  normally  generate
        "B" errors.
                                                          Page 48


O   Undefined instruction mnemonic (opcode).

P   Phase error.  Pass 2 value of symbol  not  equal  to  pass  1
        value  of symbol.  The pass 1 value prevails.  This error
        frequently indicates that a symbol used in an  expression
        argument  to an IF directive was not defined prior to the
        line where the IF appears.

Q   Questionable syntax.  Generally a warning which  indicates  a
        line  is  not  entirely  of  proper  syntax, and that the
        assembler  has  made  some  assumption  about  what   the
        programmer    intended.     Often    indicates   improper
        delimiters, extra delimiters, or missing delimiters.

R   Register error.  The register specified is illegal  for  this
        particular instruction.

    Relocation error.  A relocatable pseudo-op (such as INTERN or
        EXTERN) was used during an absolute assembly.

T   Truncation error.   The  source  line  was  larger  than  132
        characters.

U   Undefined symbol.  A symbol is referenced in  an  expression,
        but  that  symbol  has  no  defined value.  The assembler
        assumes the symbol to have a value of zero.

V   Value error.  An operand  value  was  out  of  range,  or  an
        absolute  value  could  not  be  produced for a Pseudo op
        which requires it.
                                                          Page 49


7.0 SUMMARY OF DIFFERENCES

This assembler is  compatible  with  the  Cross  Macro  Assembler
Reference  Manual,  (M68KXASM(D3)  for the 68000 by Motorola with
several exceptions.  These are listed below.

     1.   The following features conform to BSO standards and may
         conflict   with   similar   features   offered   by  the
         manufacturer.

                   (A)  macro processing
                   (B)  conditional assembly directives
                   (C)  listing control
                   (D)  repeat directives
                   (E)  location control

Please note that in most cases, macros can be written by the user
to  duplicate  directives  that are supported by the manufacturer
but do not appear in BSO  software.   Using  macros  rather  than
specific  directives  may  improve portablity between development
systems.

The list of differences above is accurate  to  the  best  of  our
knowledge,  however BSO does not warrant that it is complete.  In
addition, this or  any  other  BSO  product  is  not  necessarily
compatible  with  any past, current or future implementation of a
similar product by any microprocessor manufacturer.






8.0 INSTALLATION

As distributed by BSO, this software should be accompanied by the
documentation necessary to put the program up on the host system.
If you encounter any difficulty, contact your BSO  Representative
at (617) 894-7800.



 



                   HOW TO REPORT DOCUMENTATION
                      AND SOFTWARE PROBLEMS



Documentation:

At BSO we are constantly striving to improve the quality  of  our
documentation.    If  you  have  had  any  trouble  locating  the
information you need, or have found parts of this  manual  to  be
unclear  or  inaccurate,  we  would  appreciate hearing from you.
Please use the general purpose form on the following page.



Software:

In the event you  encounter  a  problem  with  your  use  of  BSO
software,  please  report  the difficulty to us by mailing in the
following three items:

     1.  The PROBLEM AND SUGGESTION  REPORT  on  the  next  page,
         giving  a  description  of the software problem.  Please
         fill in all requested information.

     2.  A small SAMPLE PROGRAM which illustrates the problem you
         encountered.   We  need  the  source code of your sample
         program ON WHATEVER  MEDIUM  (tape  or  disk)  YOUR  BSO
         SOFTWARE ARRIVED.  If an updated version of the software
         becomes necessary, we will send it to you on the tape or
         disk  you  have  provided  (assuming  you  are currently
         covered under a  new  product  warranty  or  a  software
         maintenance contract).

     3.  TERMINAL SESSIONS and/or LISTINGS of your sample program
         with  arrows  and comments to indicate where the problem
         occurred.

This information has proven to be  essential  for  the  effective
processing  of  any  software  problems.   Your  co-operation  in
sending the above three items, plus  any  additional  information
that  might  prove  helpful, such as command files, object files,
listing files, relocatable binary (ROB) files, etc., will  result
in the speediest possible handling of your problem.



                 THE BOSTON SYSTEMS OFFICE, INC.
                  PROBLEM AND SUGGESTION REPORT


NOTE:  If you are reporting a software problem, DO  NOT  send  in
this  form  alone.   Please  see the previous page for additional
required information.


Product:                                    Version:
-----------------------------------------------------------------
Distribution medium (mag tape, floppy, RK-05, etc.):
-----------------------------------------------------------------
Reported by:                                Date:
-----------------------------------------------------------------
Company:                                    Phone:
-----------------------------------------------------------------
Address
-----------------------------------------------------------------
Host computer/operating system:
-----------------------------------------------------------------

Comments regarding software or documentation:
-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------

-----------------------------------------------------------------


Please  mail  this   form,   along   with   additional   required
information, to:  

                 The Boston Systems Office, Inc.
                        469 Moody Street
                       Waltham, MA  02154
 WC*>