;Racgt, Jacgt, Once, Svacs

BEGIN SUBS	;exports: RACGT, ???, $IO, $C

IFN REALSW,<
INTERNAL $DEV, $C
INTERNAL $OPLOOK, $ADTYP
IFN EXDSW,< INTERNAL $IO, $IOTAB >
>

^RACGT:	0		;GET RAID ACS
	SKIPE	ACSW	;SEE IF USER'S ACS ALREADY SAVED
	JRST	RACGT2	;YES, DON'T CLOBBER, BUT GET OURS AGAIN FOR SAFETY
	MOVEM	17,JAC+17
	MOVEI	17,JAC
	BLT	17,JAC+16
	SETOB	V,ACSW
IFN TYMSHR,<
	SKIPN	1,JOBHRL	;save his JOBHRL (we use it too)
	 JRST	RACGT3
	MOVEM	1,SVJRL
	HRRZS	JOBHRL
	SETZB	1,2
	SETUWP	1,	;setup write privledges, and get old value
	TLO	2,400000
	IORM	2,JOBHRL
	MOVEM	1,SVUWP	;save old write privledges
RACGT3:	MOVNI	1,31
	GETTAB	1,
	 JFCL
	MOVEM	1,SAVMOD	;save break characteristics for terminal
	MOVEI	1,1000	;break on punctuation
	SETMOD	1,
>
IFN STANFO,<
	GETLIN	V	;GET LINE BITS
	CAME	V,[-1]
	JRST	RACNDT	;NOT DETACHED
	SETOM	DETFLG
	MOVEI	V,0
RACNDT:	MOVEM	V,USERLIN	;SAVE FOR USER
	TLO	V,100	;SPECIAL ACTIVATION MODE
	MOVEM	V,RADLIN	;FOR NORMAL RAID OPERATIONS
	TLZ	V,100	;FOR ASCII INPUT OPERATIONS
	MOVEM	V,ASCLIN
	TLO	V,20	;FULL CHARACTER SET MODE, FOR EDITING
	MOVEM	V,EDTLIN
	SETACT	[BRKTI,,0];SAVE HIS BREAK TABLE
>
RACGT2:	MOVSI	17,RAC
	BLT	17,17
IFE FILESW,<	;AVOID DOING SETSYM HERE IF FILE VERSION (DONE IN ONCE)
IFN SORTED,<
	MOVE	V,JOBSYM
	CAME	V,SAVJSM
	 PUSHJ	P,SETSYM ;RESET SYMBOL TABLE IF MOVED (OR FIRST TIME)
>;SORTED
>;NOT FILESW
	HRRZS	RACGT	;BLAST FLAGS
	JRST	2,@RACGT ;SO WE CAN CLEAR THEM HERE (ESP IOT-USER)

IFN TYMSHR,<
SAVMOD:	0
SVUWP:	0
SVJRL:	0
>
IFE UESW!FILESW,<
^JACGT:	0		;GET JOB AC'S
	SKIPN	ACSW
	 JRST	@JACGT
	SETZM	ACSW
	MOVEM	17,RAC+17
	MOVEI	17,RAC
	BLT	17,RAC+16
IFN TYMSHR,<
	MOVE	1,SVUWP	;restore write-privledge
	SKIPE	2,SVJRL	;his version of JOBHRL
	 SETUWP	1,
	 JFCL
	MOVEM	2,JOBHRL
	MOVE	1,SAVMOD	;and the break setting for his terminal
	SETMOD	1,
>
IFN STANFO,<
	SETLIN	USERLIN		;RESTORE USER'S LINE CHARACTERISTICS.
	MOVE	BRKJSR
	TLNE	4000
	 EIOTM		;RESTORE IOT-USER
>;STANFORD
	MOVSI 17,JAC
	BLT 17,17
IFN STANFO,<
	SETACT	[BRKTI]	;PUT BACK USER'S BREAK TABLE
>
	JRST	@JACGT
>;UESW!FILESW=0

^DETFLG:	0		;-1 IF WE ARE DETACHED WHEN STARTING UP
^USERLIN:	0
^EDTLIN:	0
^ASCLIN:	0
^RADLIN:	0

^SVACS:	MOVEM	17,RAC+17	;CALL THIS ROUTINE TO STASH AWAY RAID'S 
	MOVEI	17,RAC		; ACS WHEN WAITING FOR TTY INPUT
	BLT	17,RAC+16	;SO <CALL>, <SAVE>, <DDT> WILL WORK
	MOVE	17,RAC+17
	POPJ	P,



^ONCE:	0
	JFCL	CHKSYM		;JFCL CLOBBERED TO A JRST WHEN ONCE IS DONE
	MOVE	P,[-PDLEN,,PDL-1]
IFN FILESW,<
RAIDXX:	OUTSTR	[ASCIZ /
DMP FILE? (Y or N) /]
	INCHRW	A
	TRZ	A,40
	CAIN	A,"Y"
	 JRST	RDDMPF
	CAIE	A,"N"
	 JRST	RAIDXX	;make sure he responds appropriately
	SETZM	DMPFSW
	GETFIL	(<
TYPE FILE NAME - >,'')
	JRST	RDDMP1

RDDMPF:	SETOM	DMPFSW
	GETFIL (<
TYPE DMP FILE NAME - >,'DMP')
RDDMP1:	OUTSTR [ASCIZ /DO YOU WANT TO MODIFY THE FILE? /]
	SETZM	MODFSW
	INCHRW	A
	TRZ	A,40
	CAIN	A,"N"
	 JRST	RDDMP3
	CAIE	A,"Y"
	 JRST	RDDMP1	;insist on a good response

	SETOM	MODFSW
	ENTER	SVLUP
	 JRST	4,.

RDDMP3:
IFE TYMSHR <
	MOVS	A,FILLUP+3	;- WORD COUNT
	SETCA	A,		;WORD COUNT-1
>;IFE TYMSHR
IFN TYMSHR <
	MOVE	A,FI.SIZ	;WORD COUNT
>;IFN TYMSHR
	SKIPE	DMPFSW
	 ADDI	A,74
	MOVEM	A,FILLST
	SKIPN	DMPFSW
	 JRST	RDDMP2		;MAKE A PHONEY SYMBOL TABLE
	IN [	-<140-74>,,TRKBUF-1
		0	]
	 JRST	FONCA0
	OUTSTR	[ASCIZ /LOST TRYING TO READ LOW CORE
/]
	JRST	4,.

FONCA0:	SKIPE	E,TRKBUF-74+HILOC	;CORE ADDRESS OF START OF UPPER
	 JRST	FONC3C		;JUMP IF THERE IS AN UPPER SEGMENT
	MOVE	E,FILLST
	IORI	E,1777
	MOVEM	E,FJBREL
	MOVEM	E,FJBHRL
	SETZM	UPPRST		;NO UPPER
	JRST	FONC3B

FONC3C:	HRRZM	E,HILOCF	;SAVE CORE ADDRESS OF BEGINNING OF UPPER
	IORI	E,1777
	HRRZM	E,FJBREL
	HRRZ	E,TRKBUF-74+HILOC	;CORE ADDRESS OF START OF UPPER
	CAIGE	E,400000
	 MOVEI	E,400000
	MOVEM	E,UPPRST	;START OF UPPER
	HRRZ	E,TRKBUF-74+HILOC	;CORE ADDRESS OF START OF UPPER
	MOVN	E,E
	ADD	E,FILLST	;SIZE OF THE UPPER - 1
	ADD	E,UPPRST
	MOVEM	E,FJBHRL	;LAST ADDRESS OF UPPER
FONC3B:	SKIPN	A,TRKBUF-74+.JBSYM;SYMBOL TABLE POINTER
	 JRST	RDDMP2		;NO SYMBOL TABLE
	HLRE	C,A		;-SIZE OF SYMBOL TABLE
	MOVN	C,C		;SIZE OF SYMBOL TABLE
	ADDI	C,-1(A)		;CORE ADDRESS OF LAST WORD OF SYMBOL TABLE
	HRRZ	A,A		;CORE ADDRESS OF FIRST WORD OF SYMBOL TABLE
	CAMLE	A,FJBREL	;SKIP IF SYMBOL TABLE BEGINS IN LOWER
	 JRST	FONC4A		;SYMBOL TABLE BEGINS IN UPPER
	CAMLE	C,FJBREL	;SKIP IF SYMBOL TABLE ENTIRELY IN LOWER
	 JRST	RDDMP2		;GOES PAST END OF LOWER
	JRST	FONC4B

FONC4A:	CAML	A,UPPRST	;SKIP (LOSE) IF SYMBOL TABLE STARTS BEFORE UPPER
	 CAMLE	C,FJBHRL	;SKIP (WIN) IF SYM TABLE FINISHES BEFORE UPPER ENDS
	  JRST	RDDMP2		;LOSE.  SYMBOL TABLE DOESN'T FIT ENTIRELY IN UPPER
	SUB	A,UPPRST	;DISTANCE FROM START OF UPPER TO START OF SYM TAB
	ADD	A,HILOCF	;(PSEUDO) CORE ADDRESS OF START OF UPPER
FONC4B:	MOVEI	B,-74(A)	;DISK ADDRESS OF SYMBOL TABLE
	IDIVI	B,200		;C GETS OFFSET OF SYM TAB FROM RECORD BOUNDARY
	USETI	1(B)		;ACCESS TO RECORD CONTAINING SYM TAB
	MOVE	B,TRKBUF-74+.JBSYM	;-LENGTH OF SYM TAB,,
	HRR	B,JOBFF
	ADD	B,C
	MOVEM	B,JOBSYM
	HRL	C,C
	SUB	B,C		;AOBJN POINTER FOR TRANSFER
	HLRE	C,B		;- NUMBER OF WORDS IN TRANSFER
	MOVN	C,C
	ADD	C,JOBFF
	MOVEM	C,JOBFF
FONCA1:	MOVE	C,JOBFF
	IORI	C,1777
	CORE	C,
	JRST	FONCA1
	SUBI	B,1		;MAKE INTO IOWD
	MOVEI	C,0
	IN	B		;READ IN THE SYMBOL TABLE
	 JRST	FONCE3
	OUTSTR	[ASCIZ /LOST TRYING TO READ IN SYMBOL TABLE
/]
	JRST	4,.

RDDMP2:	PUSHJ	P,MKSYTB
FONCE3:	MOVE	E,FILLST
	ADDI	E,1
FONC3A:	MOVEM	E,TUBOUN
	MOVEM	E,PUBOUN
	MOVEI	E,20
	MOVEM	E,TLBOUN
	MOVEM	E,PLBOUN
IFN SORTED,<
	PUSHJ	P,SETSYM
>;SORTED
>;END FILESW
IFE FILESW,<
	MOVEI	E,BEGDDT
	CAIN	E,140		;START AT 140 UNLESS RAID IS FIRST
	 MOVEI	E,ENDDT		;SET LOWER BOUND AT DDTEND TO START WITH
	MOVEM	E,TLBOUN
	MOVEM	E,PLBOUN
>;NOT FILESW
	SKIPN	E,JOBSYM	;SET UPPER BOUND AT LOWER OF JOBSYM AND
	 MOVE	E,SYMSET-3
	MOVEM	E,JOBSYM
	JRST	SYMSET
FAKSYM:	RADIX50	0,FAKE
	 0
	RADIX50	4,$DEV
	 SPECDEV
	RADIX50 4,RAID
	 RAID
	RADIX50	4,FAKSYM
	 XWD	-12,FAKSYM
	RADIX50	0,FAKED
	 0
SYMSET:
IFE SORTED,<
	 MOVEM	E,SAVSYM#
>;NOT SORTED
IFE FILESW,<			;SET UPPER BOUND AT LOWER OF JOBSYM AND
	MOVEI	E,-20(E)	;REMOVE DEFAULT OFFSET
	CAML	E,JOBFF		; JOBFF CONTENTS TO START WITH
	 HRRZ	E,JOBFF
	CAIN	E,ENDDT		;IF RAID IS AT END
	 MOVEI	E,BEGDDT	;THEN SET UPPER BOUND BELOW IT
	MOVEM	E,TUBOUN
	MOVEM	E,PUBOUN
>;NOT FILESW
	MOVEI	E,CTABCN	;NO MACROS YET
	MOVEM	E,TABLEN
	SETOM	DDSW		;DON'T KNOW WHAT KIND OF DISPLAY YET
	MOVS	PNT,SPNT
	MOVE	E,PNT
	SUB	PNT,[1,,1]
	MOVEI	T,MAXDLN	;CLEAR DISPLAY LOCATIONS
	SETZM	(E)
	ADDI	E,1
	SOJG	T,.-2
	SETZB	F,DCON
	SETOM	STPOP
	SETOM	LOCOP
	SETZM	SAVMOD		;SPECIAL CURMOD SAVE VARIABLE (SEE TMPMOD ROUTINE)
	SETZB	C,NBIGWD	;CLEAR C FOR PRGSET
	MOVSI	F1,SINGF
	PUSHJ	P,PRGSET	;FIND A REASONABLE FIRST PROG
				IFN UESW,<MOVE T,[400001,,SPBLT]
					SETZM SPSWT1#
					SETZM SPSWT2#
					CALL T,[SIXBIT/SPCWGO/]
					SKIPN SPSWT1
					JRST .-1
					HRRZ T,SPSWT1
					CALL T,[SIXBIT /CORE/]
					JRST 4,.
					SETOM SPSWT2
					SKIPE SPSWT2
					JRST .-1
					PUSHJ P,WRAP
					MOVEM V,SYMPRG
					MOVEM V,SYMPNT
					TNOFFS>
	MOVSI	E,(<JRST>)	;DESTROY THIS ROUTINE
	HLLM	E,ONCE+1
	JRST	@ONCE

IFN FILESW!DEBSYM,<
^^MKSYTB:MOVE	A,JOBFF
	ADDI	A,216
	CORE	A,
	JRST	4,.
	MOVE	A,JOBFF
	HRRZ	B,A
	ADDI	B,216
	MOVEM	B,JOBFF
	HRLI	A,-216
	MOVEM	A,JOBSYM
	SETOM	(A)
	MOVEI	B,12
	MOVEM	B,1(A)
	MOVEI	B,13
	MOVEM	B,2(A)
	MOVEI	B,14
	MOVEM	B,3(A)
	MOVEM	B,4(A)
	MOVEI	B,214
	MOVEM	B,5(A)
	MOVEI	B,216
	MOVEM	B,6(A)
	MOVEM	B,7(A)
	MOVEM	B,10(A)
	MOVEM	B,11(A)
IFN FILESW,<
	MOVE	B,[RADIX50 0,FRAID]
>
IFN DEBSYM,<
	MOVE	B,[RADIX50 0,DRAID]
>
	MOVEM	B,12(A)
	SETZM	13(A)
	MOVE	B,[RADIX50 50,AFRAID]
	MOVEM	B,214(A)
	SETZM	215(A)
	POPJ	P,
>;FILESW!DEBSYM

IFE SORTED,<
CHKSYM:	MOVE	T,JOBSYM
	SUB	T,SAVSYM
	JUMPE	T,@ONCE
	PUSH	P,ONCE
	ADDM	T,SAVSYM
	HRRE	V,T
	CAME	V,T
	 JRST	SYMRST		;SYMTAB REALLY GRONKED
	ADDM	T,SYMPNT
	ADDM	T,SYMPRG
	MOVEI	V,NUMREF
CHKSY2:	SKIPE	PRGREF(V)
	 ADDM	T,PRGREF(V)
	SKIPE	BLKREF(V)
	 ADDM	T,BLKREF(V)
	SOJGE	V,CHKSY2
	POPJ	P,
>;NOT SORTED
IFN SORTED,<
CHKSYM:	JRST	@ONCE
>;SORTED

IFN FILESW,<
;^XTRASW:0		;-1 IF READING FROM EXTRA CYLINDERS, 0 IF FROM DMP FILE
;			;1 IF FROM XCOP FILE
^DMPFSW:0		;-1 IF DUMP FILE
^MODFSW:0		;+1 IF WANTS TO MODIFY THE FILE
^FILLST:0		;LAST ADDRESS IN FILE
^NOTFIL:0		;FLAG TO GETPOI TO FORGET ABOUT LOOKING IN THE FILE
^FJBREL:0		;JOBREL OF LOWER
^FJBHRL:0		;JOBREL OF UPPER
^UPPRST:0		;STARTING ADDRESS OF UPPER
^HILOCF:0		;BEGINNING CORE ADDRESS OF UPPER

>;FILESW

; END OF ONCE ONLY CODE


;Parameters, Headers, Buffers, Variables for Data Display

IFN REALSW,<?RAIDPG__17;>?RAIDPG__16

DEFINE HJUMDS <35>
HJUMSZ__5

; Device bits, Stanford status word
IFN STANFO,<
?DDBIT__20000
?IIIBIT__400000
>;STANFORD

; Space count for status line, one for large chars, one for small
LITSPS	__ 16	;small chars, needs more spaces
BIGSPS __ 5	;large chars, need fewer spaces

; Device indices

^^.TTY	__ 0	;Best efforts on TTY
^^.VTS	__ 1	;Xerox-PARC VTS protocol
^^.NGP	__ 2	;Sproull's proposed Net. graph. protocol
ifn stanfo,<
^^.DD	__ 3	;Data-Disk
^^.III	__ 4	;III displays
>
IFN TYMSHR,<
^^.LSI __3	;ADM- 1,3A,31	(tymshare 420,430)
^^.ZEN __4	;ZENTEC (normal)
^^.HP4 __5	;HP2621	(tymshare 444)
^^.H19 __6	;HEATHKIT H-19
maxdev__.H19
>

; Bits controlling display of lines, arrows
; Bit 400000	Display this line -- tested with sign test
DOEX__40000		;IF ON, DISPLAY `x' -- EXECUTION POINT
DODOT__20000		;IF ON, DISPLAY `.' -- DOT
DOPT__10000		;IF ON, DISPLAY arrow -- POINTING HERE
; IF ALL ON, USE <=> INSTEAD OF x, ., OR arrow

; RAID text page image buffer

;  See end of prog for actual def, SORT shares DISB
;IQJ__MAXDLN+2	IQJ__IQJ*LINLEN
;DISB:	BLOCK	IQJ			;ROOM FOR ALL THE DATA

; Display pointer tables:
; DSAV: One word per line, currently displayed info:
;  LH: 400000, DOEX, DODOT, DOPNT bits controlling display
;  RH: Address of first word for this line in page image buffer
; DCON: Saved DPNT pointers, to see what changed
; DDCON: Saved displayed address values, to see what changed

DEFINE $SETBLK,<
IQI__0
^^DSAV:	REPEAT MAXDLN+2,
<DISB+IQI
IQI__IQI+LINLEN
>
0

>;END OF $SETBLK
	XLIST
	XCREF
	$SETBLK
	LIST ;AVOID INFINITE EXPANSION
	CREF

DCON:	BLOCK MAXDLN+2
DDCON:	BLOCK MAXDLN+2

IFN STANFO,<
; Display and line information UUO buffer -- Stanford only
PPIBUF:	BLOCK	=20
>;STANFO

; Status control word -- routines set to control status line display
; LH: Index into STSTXT -- a table of ASCII Status indicators
; RH: Number of spaces to precede status --
;     Low-order bit complemented in main loop to draw attention

^NBIGWD:	0

; STATUS TEXT TABLE
STSTXT:	ASCII	/OK/
	ASCII	/?/
	ASCII	/M/
	ASCII	/U/
	ASCII	/SKIP /
	ASCII	/*/
	ASCII	/MEM?/
	ASCII	/PURE?/
	ASCII	/PROT?/
	ASCII	/INST?/

; Arrow tables -- one table for each collection of arrow
;  characters for "dot", "execpt", "arrow", and "universal" combinations

GDAROW:	ASCID /     /			;NO ARROWS -- GOOD KIND
	ASCID /    Y/-100   ; ^Y(31)=arrow GOT HERE VIA `;' OR SOMETHING
	ASCID /   . /			; `.' ONLY
	ASCID /   .Y/-100		; `.' AND POINTING, NO EXECUTE
	ASCID /  x  /			; EXECUTION POINT ONLY
	ASCID /  x Y/-100		; ALL BUT `.'?
	ASCID /  x. /			; DID `;' TO TAKE arrow ELSEWHERE
	ASCID /    W/-100	; double-arrow (^W) SPECIAL CHARACTER FOR ALL

BDAROW:	ASCID /     /	;NO ARROWS -- BAD KIND
	ASCID /    >/	; GOT HERE VIA `;' OR SOMETHING
	ASCID /   . /	; `.' ONLY
	ASCID /   .>/	; `.' AND POINTING, NO EXECUTE
	ASCID /  x  /	; EXECUTION POINT ONLY
	ASCID /  x >/	; ALL BUT `.'?
	ASCID /  x. /	; DID `;' TO TAKE arrow ELSEWHERE
	ASCID /  <=>/	;SPECIAL CHARACTERFOR ALL

; Index pointer, selecting arrow table (see DSET)

^ARRTAB: V,,GDAROW

; Special device-select word, set by user to select undetectable devices
; (NGP, VTS)

^^$DEV:
^SPECDEV: -1,,0	;ASSUME TTY, NO PHYSICAL BACKSPACE

IFN STANFO,<
; Data-Disk Definitions (Control words, sizes, etc.)

VJUMSZ__=12
IFN DMOVSW,<VSTT__=48;>VSTT__=240


; COMMAND WORD -- ALTERNATING COMMANDS AND PARAMETERS
DEFINE CW(C1,B1,C2,B2,C3,B3) <
	<BYTE (8)<B1>,<B2>,<B3> (3)<C1>,<C2>,<C3>>!4
>

; COMMAND NAMES FOR DD COMMAND BYTES
EXCT__0				;EXECUTE
FNCN__1  ALPHBG__6  ALPHA__46	;FUNCTION, USUAL VALUE BYTES
CHNL__2				;CHANNEL SELECT
COLM__3				;COLUMN SELECT
HILIN__4			;HIGH 5 BITS OF LINE
LOLIN__5			;LOW 5 BITS OF LINE

; III Definitions

; ABSOLUTE INVISIBLE VECTOR (III DISPLAY)
DEFINE AIVECT (X,Y,B) <	146+.LEFT.((X),=25)+.LEFT.((Y),=14)+.LEFT.(B,10)>

IIIHST__3000
IIIVSZ__30
IFN DMOVSW,<IIIVST__640;>IIIVST__0

; DD and III display control block, Display buffer
; DPYOUT CONTROL WORDS
	XWD 400000,DTEM		;USE OVERLAPPED MODE ON DD
TWC:	0		;WILL BE DPYOUT COUNT
DDACT:	0		;DD XFER ACTIVE FLAG FROM SYS

^DTEM:	BLOCK 1000
>;STANFO

; VTS initializing string, outstr'd from DSET

VINIT:	BYTE (7) VTSESC,"D",1,VTSESC,"D",2,VTSESC,"C",1,MAXDLN+2
	BYTE (7) VTSESC,"B",1,1,2,1,76,7,150,5
	BYTE (7) 60,VTSESC,"T",1,177,1,VTSESC,"C",2,2,VTSESC,"B",2,1,2
	BYTE (7) 1,2,5,170,1,122,VTSESC,"F",2,1,6,6,VTSESC,"T",2,177,1,0


;Spwget, Dset, Mksel

			IFN UESW,<	SPWGET:	SKIPN SPGG3
					0
					HRLI 2,-1
					DATAO 2
					MOVN 4,2
					ADD 4,SPGG2
					MOVE 5,(4)
					MOVEM 5,SPGG1#
					SETZM SPGG3
					0>

^DSET:
IFN TYMSHR,<
	MOVE	M,SPECDEV	;get requested device
	CAIG	M,MAXDEV	;if bad device requested, guess
	 JUMPGE	M,DEVSTO	;otherwise just save it
;NEW "TERMINAL TYPE" AUXCAL
	HRROI	T,100		;first guess is based on term type
	HRROI	M,-1		;this says "just read the value, thanks"
	AUXCAL	T,M
;CHECK FOR STRAIGHT TYMSHARE MODEL NUMBERS in RH
	MOVEI	T,(M)
	CAIE	T,=420
	 CAIN	T,=430
	  MOVEI	M,.LSI		;models 420,430 are lear-seigler
	CAIN	T,=444
	 MOVEI	M,.HP4		;model 444 is HP2621
	CAME	M,[SIXBIT /ADM1/]
	 CAMN	M,[SIXBIT /ADM31/]
	  MOVEI	M,.LSI		;once again lear-seigler
	CAME	M,[SIXBIT /ADM3/]
	 CAMN	M,[SIXBIT /ADM3A/]
	  MOVEI	M,.LSI		;once again lear-seigler
	CAME	M,[SIXBIT /HP2621/]
	 CAMN	M,[SIXBIT /444/]
	  MOVEI	M,.HP4		;model 444 is HP2621
	CAME	M,[SIXBIT /ZENTEC/]
	 CAMN	M,[SIXBIT /ZEN/]
	  MOVEI	M,.ZEN		;some confusion over ZENTEC's name
	CAMN	M,[SIXBIT /H19/]
	 MOVEI	M,.H19		;heathkit terminal
	CAIG	M,MAXDEV	;if we found a reasonable device
	 JUMPG	M,DEVSTO	; then go save as current
	HRROI	M,15	;guess is based on baud rates
	AUXCAL	M,M	;Read the input rate
	HRROI	T,16
	AUXCAL	T,T	;and the output rate
	LSH	T,4
	IOR	T,M	;Combine into one word
	MOVEI	M,.TTY	;presume hard copy
	CAIL	T,.LEFT.(5,4)+5	;1200/1200 or faster we presume is 2621P
	 MOVEI	M,.HP4
	CAIE	T,.LEFT.(5,4)+1	;1200/150 is ZENTEC
	 CAIN	T,.LEFT.(2,4)+1	;300/150 is also ZENTEC
	  MOVEI	M,.ZEN
DEVSTO:	MOVEM	M,SPECDEV	;save the guessed value (safer)

>
IFE TYMSHR,<
	MOVEI	M,.TTY		; HERE WE USE IT TO SEE WHAT
IFN STANFO,<
	MOVNI	T,1
	GETLIN	T		;GET LINE CHARACTERISTICS
	TLNN	T,DDBIT!IIIBIT	;SKIP IF III OR DATA DISK
	JRST	ISTTY
	PPINFO	PPIBUF
	MOVEI	M,.III		; ASSUME III
	TLNE	T,DDBIT
	MOVEI	M,.DD
ISTTY:
>;STANFO
	SKIPLE	T,SPECDEV	;ALSO, IF REMOTE PROTOCOL WAS ASKED
	HRRZ	M,T		; (VTS, NGP), USE THAT DEVICE.
IFE STANFO,<
	HLRM	T,NBSSW
>
>;IFE TYMSHR
	CAMN	M,DDSW		;NEED TO RE-INITIALIZE IF DEVICE HAS
	 POPJ	P,		; CHANGED.
	MOVEM	M,DDSW
	TRO	F,DPYALL	;FORCE COMPLETE SCREEN REGENERATION
	MOVE	D2,[.OK,,LITSPS]	;ASSUME LITTLE STATUS LINE
	MOVEM	D2,NBIGWD
	MOVEI	D2,GDAROW	;ASSUME THIS SET OF ARROWS
	HRRM	D2,ARRTAB
	MOVE	T,[-MAXDLN-1,,DSAV]
	JRST @(M)[TTYSET	;DEVICE-DEPENDENT
		VTSSET		; INITIALIZATION
		NGPSET
		IFN STANFO,<
		DDSET
		IIISET
		>
		IFN TYMSHR,<
		LSISET
		ZENSET
		HP4SET
		H19SET
		>
		]

IFN TYMSHR,<ZENSET: LSISET: HP4SET: H19SET:
	PUSHJ	P,SCLRCL
>
TTYSET:	TDZA	D2,D2
NGPSET:	HRRI	D2,LITSPS
	HRRM	D2,NBIGWD
	MOVEI	D2,BDAROW
	HRRM	D2,ARRTAB
	POPJ	P,

VTSSET:	MOVEI	D2,BDAROW	;HAVE TO USE BAD SET
	HRRM	D2,ARRTAB
	MOVEI	D2,BIGSPS
	HRRM	D2,NBIGWD
IFE TENEX,<
	OUTSTR	VINIT		;INITIALIZE DISPLAY AREA
>
IFN TENEX,<
	MOVE	A,[PSOUT]
	MOVEM	A,VTINST
	HRROI	A,VINIT
	PUSHJ	P,VTSOUT	;WRITE THE STRING, TRANSPARENT MODE
>
	MOVE	M,[BYTE (7) VTSESC,"R",2,1,1]
	JSP	D2,CNTRL	;First (OK) line special
	MOVE	M,[BYTE (7) VTSESC,"R",1,1,1]
ALVDS:	JSP	D2,CNTRL	;Store VTS replace command in
	ADDI	M,.LEFT.(1,10)	; first word for each line
	JRST	ALVDS		; BCLR will complete command in wd 2


IFN STANFO,<
IIISET:	MOVEI	M,777300	;PP POSITION
	MOVEM	M,DPLOC
	MOVEI	D2,BIGSPS
	HRRM	D2,NBIGWD
	SETZM	DTEM
	MOVE	M,[AIVECT(IIIHST,IIIVST-6,7)] ;Status LINE
	JSP	D2,CNTRL
	MOVE	M,[AIVECT(IIIHST,IIIVST-IIIVSZ,2)] ;PROG/BLOCK NAME LINE
ALLDS:	JSP	D2,CNTRL	;STORE WORD, CYCLE UNTIL DONE
	SUB	M,[.LEFT.(IIIVSZ,=14)]	;NEXT LINE
	JRST	ALLDS

DDSET:	MOVEI	M,777400
	MOVEM	M,DPLOC
	MOVEI	E,VSTT-=12
	PUSHJ	P,MKSEL
	MOVEI	E,VSTT	;FIRST LINE
ALDDS:	JSP	D2,CNTRL
	ADDI	E,VJUMSZ
ALDDSL: PUSHJ	P,MKSEL
	JRST	ALDDS		;AROUND

MKSEL:	MOVE	M,[CW (\COLM,2,\HILIN,0,\LOLIN,0)]
	DPB	E,[POINT 4,M,23];LOW FOUR
	ROT	E,-4
	DPB	E,[POINT 5,M,15];HIGH FIVE
	ROT	E,4		;RESTORE IT
	POPJ	P,

>;STANFORD

CNTRL:	MOVEM	M,@(T)		;STORE A WORD
	AOBJN	T,(D2)		;CONTINUE UNLESS DONE
	POPJ	P,		;DONE


;Redraw, Redisp, Fredsp -- Display Program

^REDISP:MOVE	M,DDCON+1
IFE SORTED,<
	CAME	M,SYMPNT
>
IFN SORTED,<
	CAME	M,BID
>
^FREDSP: TRO	F,DPYALL
	PUSHJ	P,DSET
	TRZE	F,DPYALL
	 JRST [	SETZM	DCON
		MOVE	V,[DCON,,DCON+1]
		BLT	V,DCON+MAXDLN+1
		JRST	NUFSED]
IFN STANFO,<
	MOVE	M,PPIBUF+2
	TRZN	F,DRWALL
	 TLNE	M,200000
>;STANFO
IFE STANFO,<
	TRZE	F,DRWALL
>;NOT STANFO
	 JRST [	MOVSI	V,400000
		MOVS	T,SPNT
		SUB	T,[2,,2]
	ALLP:	IORM	V,DSAV-DPNT(T)	;TURN ON DOIT BIT
		AOBJN	T,ALLP		;CONTINUE UNTIL
		TLNN	T,7
		JRST	ALLP		; REALLY DONE
		JRST	NUFSED]
NUFSED:
IFN STANFO,<
	HRLZ	M,DPLOC		;IF POSITION AND SIZE ARE DIFFERENT THAN WE
	HRRI	M,3002		;WANT THEM TO BE, WE SHOULD MOVE THEM
	MOVE	T,DDSW		;III AND DD ONLY
	CAIL	T,.DD
	 CAMN	M,PPIBUF+3	;PP 0'S CURRENT SETTINGS
	  JRST	NEXTT
	DPYSIZ	3002
	DPYPOS	@DPLOC		;NOW THEY'RE RIGHT
>;STANFO
NEXTT:
LOP1B:	MOVS	T,SPNT		;GETTER
	SUB	T,[2,,2]
	MOVEM	PNT,SAVPNT	;SAVE arrow VALUE

;FALLS THROUGH


;     Loop1, Rdo -- Main Line Control, Each Line Code

;FALLS THROUGH FROM PREVIOUS PAGE

;LOOK AT NEXT LINE, SET UP TO EXAMINE IT
LOOP1:	SKIPN	V,(T)		;DONE?
	 JRST	GODIS		;YES
	MOVE	M,DSAV-DPNT(T)
	HRRZ	E,M		;SET UP BP TO 2D HALF OF LINE
	ADD	E,[POINT 7,HJUMSZ,HJUMDS] ; (FOR ARROW INSERTION)
	MOVEM	E,STRTHR#	;SAVE HERE
	HLRZ	D3,V		;get the display bits

IFN FILESW,<
	SETZM	NOTFIL
	HRRZ	E,T
	CAIGE	E,DPNT+2
	 SETOM	NOTFIL
>;FILESW
	PUSHJ	GETE.V		;read word pointed to by V into E
	 JRST [	MOVE	E,[ASCII /???/]	;cannot do read, display "???"
		MOVEI	D3,.LEFT.(<TXT+2>,5)
		JRST	LOOP1A]

LOOP1A:	MOVE	D2,(T)		;pick up the current Pointer word
	TLNE	D2,3
	 JRST	RDO		;ALWAYS REDO DYNAMIC CELLS
	CAMN	D2,DCON-DPNT(T)	;if the mode/address changed
	 CAME	E,DDCON-DPNT(T)	;or the data changed
	  JRST	RDO		; then reDo the calculation
	JRST	ARND1		;only need to see if mucking with arrow

RDO:	MOVEM	E,DDCON-DPNT(T)	;save the new data
	PUSHJ	P,BCLR
	MOVEI	M,40
	TRNE	D3,400000
	 MOVEI	M,"*"
	IDPB	M,E
	MOVEI	M,.LEFT.(CYM,5)
	CAIE	D3,.LEFT.(STS,5)
	 CAIN	D3,.LEFT.(PRG,5)
	  HRRZ	M,D3
	PUSH	P,T
	PUSH	P,D3
	PUSHJ	P,CONV
	POP	P,M
	CAIN	M,.LEFT.(STS,5)
	 JRST	RET2
	CAIN	M,.LEFT.(PRG,5)
	 MOVEI	M,.LEFT.(BLK,5)
	TRZ	M,400037
	MOVE	E,STRTHR
	MOVE	T,(P)
	MOVE	V,DDCON-DPNT(T)		;pick up the value
	PUSHJ	P,CONV			;and output convert it

;FALLS THROUGH


;RET2, ARND1

;FALLS THROUGH FROM PREVIOUS PAGE

RET2:	POP	P,T		;RESTORE IT
	PUSHJ	P,CRLFOT	;FINISH LINE, COMPUTE SIZE IF NECESSARY
	MOVSI	V,400000 	;DO SOMETHING BIT
	IORM	V,DSAV-DPNT(T)

;WHETHER OR NOT DATA CHANGED, HANDLE VARIOUS ARROW INDICATIONS

ARND1:	HLRZ	V,(T)
	TRZ	V,776037	;RETAIN ONLY TYPE
	CAIL	V,.LEFT.(STS,5)
	 JRST	ARND2
	MOVEI	V,0
	CAMN	T,PNT		;IS THIS WHAT WE'RE POINTING AT?
	 TRO	V,DOPT		; YES, arrow OR DBL THIS LINE
	HRRZ	M,(T)		;GET LOCATION DISPLAYED
	CAMN	M,LOCOP		;IS THIS LINE `DOT'?
	 TRO	V,DODOT		; YES, . OR DBL THIS LINE
	CAMN	M,STPOP		;IS THIS LINE THE EX. POINT?
	 TRO	V,DOEX		; YES, x OR DBL THIS LINE
	HLRZ	M,DSAV-DPNT(T) 	;GET OLD ARROW BITS
	SKIPN	DDSW
	 JRST [	TDC	M,V
		TRNN	M,400000
		 TDNE	M,V
		  TRO	V,400000
		JRST	TR1]
	CAME	M,V		;SAME AS LAST TIME?
	 TRO	V,400000
TR1:	HRLM	V,DSAV-DPNT(T)	;STORE NEW, WITH DISPL DIRECTIVE
	TRZ	V,400000
	LSH	V,-=12		;GET 3 ARROW BITS AS INDEX
	MOVE	V,@ARRTAB	;INDEXED BY V, GET APPROP. ARROWSPEC
	MOVEM	V,@STRTHR	;PLACE INTO LINE

; AROUND THE LINE LOOP

ARND2:	AOBJN	T,LOOP1		;DONE?
	TLNN	T,7		;REALLY DONE?
	 JRST	LOOP1


;Godis -- Actual Displaying Code

GODIS:	MOVE	M,T		;SAVE PTR TO LAST
	HRRZ	V,DSAV-DPNT(M) 	;SAVE END OF LINE LIST
	PUSH	P,V
	SETZM	DSAV-DPNT(M)	;MARK END OF LINE LIST
	PUSHJ	P,DISPLAY	;DISPLAY CHANGED LINES
	POP	P,DSAV-DPNT(M)	;RESTORE
	MOVE	V,[DPNT,,DCON]
	BLT	V,DCON+MAXDLN+1
	POPJ	P,


;RDTRKE, WRTRK
IFN FILESW,<
NFILPG__20		;NUMBER OF 200 WORD BLOCKS
;READ INTO TRACK BUFFER THE TRACK WITH LOC E IN IT
^RDTRKE:PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D1
	MOVEI	A,(E)
	JRST	RDTREA
RDTREX:	POP	P,D1
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,

RDTRE3:	AOS	FILCNT(C)
	MOVEM	C,LSTTRK
	IMULI	C,200
	ADDI	C,TRKBUF(B)
	MOVEM	C,TRKOFF
	JRST	RDTREX

RDTREV:	MOVSI	C,-NFILPG
	HRLOI	D1,377777	;BIG NUMBER
RDTRE5:	CAMG	D1,FILCNT(C)	;SKIP IF FILCNT SMALLER THAN CURRENT MINIMUM
RDTRE6:	 AOBJN	C,RDTRE5
	JUMPGE	C,RDTRE7	;JUMP IF SCAN THROUGH
	MOVE	D1,FILCNT(C)	;NEW MINIMUM
	HRLM	C,(P)		;SAVE INDEX
	JRST	RDTRE6		;LOOP

RDTRE7:	HLRZ	D1,(P)		;GET BACK INDEX OF SLOT TO USE
	POPJ	P,

;NORMAL FILE SYSTEM READ
RDTREA:	SKIPN	DMPFSW
	 JRST	RDTRA1
	CAMG	A,FJBREL
	 JRST	RDTRA2
	CAMLE	A,FJBHRL
	 JRST	RDTREX
	SUB	A,UPPRST	;DISTANCE FROM START OF UPPER TO ADDRESS WE WANT
	ADD	A,HILOCF	;ADD IN STARTING FILE ADDRESS OF UPPER
RDTRA2:	SUBI	A,74
	JUMPL	A,RDTREX
RDTRA1:	IDIVI	A,200		;A_REC # IN FILE (INDEX FROM 0), B_OFFSET IN REC
	MOVSI	C,-NFILPG
	MOVNI	D1,1		;INDEX OF LAST FREE SLOT
RDTREB:	CAMN	A,FILTAB(C)
	 JRST	RDTRE3
	SKIPGE	FILTAB(C)	;SKIP IF SLOT IN USE
	 HRRZ	D1,C		;NOT IN USE, REMEMBER ITS INDEX
	AOBJN	C,RDTREB
	JUMPL	D1,RDTREC	;NO FREE SLOTS.  EVICT SOMEONE
RDTRED:	MOVEM	A,FILTAB(D1)
	SETZM	FILCNT(D1)
	AOS	FILCNT(D1)
	USETI	1(A)
	IMULI	A,200
	MOVN	A,A
	ADD	A,FILLST
	ADDI	A,1		;DISTANCE FROM BEGINNING OF OUR REC TO EOF
	CAILE	A,200
	 MOVEI	A,200
	MOVN	A,A		;SIZE OF XFER
	IMULI	D1,200
	ADDI	B,TRKBUF(D1)
	MOVEM	B,TRKOFF
	ADDI	D1,TRKBUF-1	;IOWD FOR TRANSFER
	MOVEM	D1,FILEWD
	HRLM	A,FILEWD
	INPUT	FILEWD
	JRST	RDTREX

RDTREC:	PUSHJ	P,RDTREV
	JRST	RDTRED

^WRTRK:	SKIPN	MODFSW
	 POPJ	P,
	PUSH	P,A
	PUSH	P,B
	MOVE	A,LSTTRK
	MOVE	B,FILTAB(A)
	USETO	1(B)
	IMULI	A,200
	ADDI	A,TRKBUF-1
	HRLI	A,-200
	MOVEI	B,0
	OUTPUT	A
	POP	P,B
	POP	P,A
	POPJ	P,

^TRKOFF:0
LSTTRK:	0
FILEWD:	0		;IOWD STORED HERE
	0

TRKBUF:	BLOCK NFILPG*200
FILTAB:	REPEAT NFILPG,<-1	;DISK ADDRESS OF BEGINNING OF THIS PAGE
>
FILCNT:	REPEAT NFILPG,<0	;NUMBER OF TIMES REFERENCED
>

^LEAVE:	EXIT

^CLRIO:	TDZA	V,V
^SETIO:	 MOVNI	V,1
	MOVEM	V,$IO
	TRO	F,DPYALL
	POPJ	P,
>;FILESW


;Bclr, Mooror (Display Driver), Crlfot, Offok

BCLR:	MOVE	E,[ASCID /     /]
	MOVEM	E,1(M)	;CLEAR TO ASCID BLANKS
	MOVEI	E,2(M)	;GET BLT WORD
	HRLI	E,1(M)	;...
	BLT	E,LINLEN-1(M)
	MOVEI	E,1(M)	;SET UP BYTE POINTER
	HRLI	E,(<POINT 7,0>)
	PUSH	P,V		;DEVICE-DEPENDENT BUFFER INIT
	MOVE	V,DDSW
	JRST	@(V)[BCRET
		  VTBRET
		  BCRET
		IFN STANFO,<
		  BCRET
		  BCRET
		>;STANFO
		IFN tymshr,<
		  BCRET
		  BCRET
		  BCRET
		  BCRET
		>;tymshr
		]

VTBRET:	MOVE	V,[BYTE (7) =63,0,40,40,40] ;END OF REPLACE, SPACES
	MOVEM	V,1(M)		; 0 WILL BE REPLACED BY LENGTH IN BYTES
	HRLI	E,(<POINT 7,0,13>)	;FIRST SPACE
BCRET:	POP	P,V		;FOR NOW, CLD JUST TEST VTS, BUT...
	POPJ	P,

; Write crlf into line data buffer, finish it up

CRLFOT:	MOVEI	V,15		;WRITE CR
	IDPB	V,E
	MOVEI	V,12		;WRITE LF
	IDPB	V,E
ZEROSS:	MOVE	V,DDSW
	CAIE	V,.VTS
	 JRST	ZEROS1
; Compute char count, deposit for Replace command (VTS)
	PUSH	P,E
	LDB	V,[POINT 3,E,5]
	TRC	V,4
	SUB	E,DSAV-DPNT(T)
	HRRES	E
	IMULI	E,5
	ADDI	E,-7(V)
	MOVE	V,DSAV-DPNT(T)
	DPB	E,[POINT 7,1(V),13]
	POP	P,E
ZEROS1:	TDZA	V,V
	IDPB	V,E		;DEPOSIT A 0
	TLNE	E,760000	;IS BP AT END OF WORD?
	 JRST	.-2		; NO, DEPOSIT 0'S UNTIL TRUE
	SETZM	1(E)		;CLEAR NEXT WORD TO FLAG COPLUP
	POPJ	P,

DISPLAY:MOVSI	V,400000
	MOVE	E,DDSW
	JRST	@(E)[TTDPY
		  VTDPY
		  NGDPY
		IFN STANFO,<
		  DDDPY
		  IIDPY
		>;STANFO
		IFN TYMSHR,<
		  LSIDPY
		  ZENDPY
		  HP4DPY
		  H19DPY
		>]

IFN STANFO,<
DDDPY:	SETZB	V,T
	SKIPE	DDACT
	 DPYOUT	RAIDPG,[0
			0]	;DON'T CLOBBER DATA UNTIL WRITING STOPS
	PUSHJ	P,DDTXT		;COPY IN ONCET
	MOVSI	V,400000	;PREPARE TO COPY AGAIN, AND CLEAR DOLINE
	PUSHJ	P,DDTXT		;DO IT
 	JRST	DPYDUN
IIDPY:	MOVEI	T,1		;LEAVE ROOM FOR III TO STORE RETURN
	PUSHJ	P,DPYTXT	;COPY TWICET (WILL SET ODD FIELDS)
DPYDUN:	SETZM	DTEM(T)		;HALT
	SETZM	DTEM+1(T)	;HALT!
	MOVEM	T,TWC		;COUNT WORD
	AOS	TWC		;THIS MANY
	DPYOUT	RAIDPG,TWC-1	;SHOW ME
	POPJ	P,

DDTXT:	MOVE	D2,[CW(\FNCN,\ALPHA,\CHNL,0,\CHNL,0)]
	MOVEM	D2,DTEM(T)
	ADDI	T,1
>;STANFO

IFN TYMSHR,<ZENDPY: LSIDPY: HP4DPY: H19DPY:
>
TTDPY: VTDPY: NGDPY:
DPYTXT:	SKIPA	D2,[DSAV]	;CONSTANT STUFF
IFE TYMSHR,<LINLUP: JUMPE D3,CPOPJ>
IFN TYMSHR,<LINLUP: JUMPE D3,CURBOT>
	MOVE	D3,(D2)		;DO THIS LINE?
	JUMPL	D3,DOLIN	;YES, MARKED
ifn stanfo,<
	CAIN	E,.III		;Also, always for III
	JUMPG	D3,DOLIN	;UNLESS DONE
>
	 AOJA	 D2,LINLUP		; NO OR DONE
DOLIN:	ANDCAM	V,(D2)		;CLEAR DOIT BIT
	MOVE	F1,(D3)	;FIRST WORD IS ROW SELECT FOR DD
	JRST	@(E)[OUTTTY
		  OUTVTS
		  OUTNGP
		IFN STANFO,<
		  DDCOPY
		  IICOPY
		>;STANFO
		IFN TYMSHR,<
		  OUTLSI
		  OUTZEN
		  OUTHP4
		  OUTH19
		>
		]

IFN STANFO,<
DDCOPY:	JUMPE	V,IICOPY		;Odd rows?
	TRO	F1,10000	;YES, THIS SHOULD DO IT
	JRST	IICOPY		;USE END OF LOOP TO STORE
COPLUP:	SKIPN	F1,(D3)		;DONE WITH LINE?
	 AOJA	 D2,LINLUP		; YES, TEST END OF SCREEN
IICOPY:	MOVEM	F1,DTEM(T)	;STORE A WORD
	ADDI	T,1		;COUNT WORDS
	AOJA	D3,COPLUP		;INCR SOURCE PTR AND LOOP
>;STANFORD

OUTNGP: OUTTTY:
IFE TENEX,<
	OUTSTR	1(D3)
>
IFN TENEX,<
	HRROI	A,1(D3)
	PSOUT
>
	AOJA	D2,LINLUP	;JUST THE STRING

OUTVTS:
IFE TENEX,<
	OUTSTR	(D3)
>
IFN TENEX,<
	HRROI	A,(D3)
	PUSHJ	P,VTSOUT
>
	AOJA	D2,LINLUP		;STRING AND REPLACE CMD

IFN TENEX,<
^VTSOUT: PUSH	P,B
	PUSH	P,A
	MOVEI	A,100
	RFMOD
	PUSH	P,B
	TRZ	B,300
	SFMOD
	EXCH	A,-1(P)
	XCT	VTINST
	POP	P,B
	POP	P,A
	SFMOD
	POP	P,B
	POPJ	P,

^VTINST: PSOUT
>;TENEX VTS OUT


IFN TYMSHR,<
OUTZEN: OUTLSI:	OUTHP4:	OUTH19:	;;terminal type  in e
	begin tymdpy
	PUSH	P,B
	PUSH	P,V
	SETZM	CURPOS		;current position in string output
	MOVEI	A,-DSAV(D2)	;current line number (screen)
	IMULI	A,LINLEN
	ADDI	A,SVTLIN	;plus display base = old line
	HRLI	A,(<POINT 7,0>)	;pointer to current screen contents
	ADDI	D3,1
	HRLI	D3,(<POINT 7,0>)	;pointer to new screen data
;; [current byte , bytepointer]  is  for old: [B,A], for new: [V,D3]
TTYOL1:	ILDB	B,A		;loop through here while screen current
	ILDB	V,D3
	CAME	B,V
	 JRST  [CAIN V,40		;but make a space match a null
		 JUMPE B,[DPB V,A
			  JRST TTYOL2]
		JRST TTYO1]	;but if different, go handle (0 neq cr)
TTYOL2:	AOS	CURPOS		;bump column number and check next char
	JRST	TTYOL1

DIFL2:		;we have already matched, see if worth genpos
	PUSH	P,D3	;Save old byte pointer in case copy
	HRRZ	E,CURPOS
	AOBJP	E,SAMLP2
SAMLP2:	ILDB	B,A
	ILDB	V,D3
	CAIN	B,(V)
	 AOBJP	E,SAMLP2
	CAIN	V,40
	 JUMPE	B,[DPB	V,A
		  AOBJP	E,SAMLP2]	;spaces and nulls are equal
	CAIN	V,15	;IF out of new string
	 JUMPE	B,[SUB	P,[XWD 1,1]	;and out of old, fix stack
		  MOVE	E,DDSW		;restore device code
		  JRST	TTYOD]		;and you are done
;we will have to move the cursor, figure out the best way
	HRRZM	E,CURPOS	;update count
	CAML	E,[XWD 5,0]	;for up to 4 chars, just copy
	 JRST	DOMOVE
	MOVE	E,DDSW	;Recover device code
	LDB	B,(P)		;Get first matching character
OUTPOS:	IONEOU	B	;copy characters from match string
	ILDB	B,(P)
	CAME	D3,(P)	;Are we done?
	 JRST	OUTPOS	;no, go copy more
CURSET:	SUB	P,[XWD 1,1]	;remove byte pointer copy
	CAIN	V,15	;IF end of new string
	 JRST	ERSEOL	; then erase and done
	JRST	TTYO5	; Otherwise, go do normal mismatch
DOMOVE:	HLRZM	E,(P)	;save count of passed over characters
	PUSH	P,[CURSET]	;every positioner returns to curset
	MOVE	E,DDSW
	JRST @[	LSIPOS	;Lsi must "genpos"
		ZENJMP	;Zentec has a "jump" command
		HP4COL	;hp has a "set column" command
		H19POS	;Heath has to "genpos"
		]-.LSI(E)
ZENJMP:	IONEOU	[33]
	IONEOU	["N"]
	MOVE	B,(P)
	JRST	ZENLOC
	
TTYO1:	CAIN	V,15		;here for character wrong
	JRST	TTYO2		; if out of new string, just blank it
	PUSHJ	P,GENPOS	;otherwise position the cursor
TTYO5:	DPB	V,A		;replace old char
	IONEOU	V		;and write it to screen
	AOS	CURPOS		;we moved forward one char
	ILDB	V,D3
	ILDB	B,A
	CAMN	B,V
	 JRST	difl2		;MATCH AGAIN
	CAIN	V,40
	 JUMPE	B,DIFl2	;null matches space
	CAIE	V,15
	 JRST	TTYO5

TTYO6:	JUMPE	B,TTYOD
	JRST	ERSEOL

TTYO2:	JUMPE	B,TTYOD
	PUSHJ	P,GENPOS
erseol:	MOVEI	V,0
	CAIE	E,.HP4
	 JRST	[CAIE	E,.H19	;H19 has "erase to end of line"
		  JRST	TTYO2A
		 JRST	ERSEO1]
ERSEO1:	IONEOU	[33]	;HP 2621 has "erase to end of line"
	IONEOU	["K"]	;Hp 2621 has "erase to end of line"
	DPB	V,A
	ILDB	B,A
	JUMPN	B,.-2
	JRST	TTYOD

TTYO2A:	DPB	V,A
	IONEOU	[" "]		;overwrite with a space
	ILDB	B,A
	JUMPN	B,TTYO2A
TTYOD:	POP	P,V
	POP	P,B
	AOJA	D2,LINLUP

GENPOS:	JRST  @(E)[CPOPJ
		CPOPJ
		CPOPJ
		LSIPOS
		ZENPOS
		HP4POS
		H19POS]

ZENPOS:	IONEOU	[33]	;this is a ZENTEC set cursor
	IONEOU	["C"]
	MOVEI	B,1-DSAV(D2)
	PUSHJ	P,ZENLOC
	MOVE	B,CURPOS	;similarly for character position
ZENLOC:	ROT	B,-4
	ADDI	B,"0"
	IONEOU	B
	ROT	B,4
	ANDI	B,17
	ADDI	B,"0"
	IONEOU	B
	POPJ	P,

HP4COL:	IONEOU	[33]
	IONEOU	["&"]
	IONEOU	["a"]
	JRST	HP4PO2
HP4POS:	IONEOU	[33]
	IONEOU	["&"]
	IONEOU	["a"]
	MOVEI	B,-DSAV(D2)
	PUSHJ	P,HP4LOC
	IONEOU	["r"]	;use absolute memory address
HP4PO2:	MOVE	B,CURPOS
	PUSHJ	P,HP4LOC
	IONEOU	["C"]
	POPJ	P,

HP4LOC:	CAILE	B,9
	 JRST  [PUSH	P,B+1
		IDIVI	B,=10
		ADDI	B,"0"
		IONEOU	B
		ADDI	B+1,"0"
		IONEOU	B+1
		POP	P,B+1
		POPJ	P,]
	ADDI	B,"0"
	IONEOU	B
	POPJ	P,

H19POS:	IONEOU	[33]	;cursor position for H-19's
	IONEOU	["Y"]
	MOVEI	B,40-DSAV(D2)
	IONEOU	B	;line number
	MOVE	B,CURPOS
	ADDI	B,40
	IONEOU	B	;character position
	POPJ	P,

LSIPOS:	IONEOU	[33]	;cursor position for ADM's
	IONEOU	["="]
 	MOVEI	B,40-DSAV(D2)
	IONEOU	B	;Line number
	MOVE	B,CURPOS
	ADDI	B,40
	IONEOU	B	;character position
	POPJ	P,

CURPOS:	0
^LSICL:	IONEOU	[32]	;CLEAR SCREEN
	IONEOU	[33]	;for all LSI's (^Z or $:)
	IONEOU	[":"]
	JRST	ALLCLR
^H19CL:			;same as for the HP2621
^HP4CL:	IONEOU	[33]
	IONEOU	["H"]	;home cursor up
	IONEOU	[33]
	IONEOU	["J"]	;and erase to end-of-display
	JRST	ALLCLR
^ZENCL:	IONEOU	[33]
	IONEOU	["P"]	;CLEAR function (maybe "@")
allclr:	SETZM	SVTLIN
	MOVE	M,[SVTLIN,,SVTLIN+1]
	BLT	M,SVTLIN+<MAXDLN+2>*LINLEN-1
	TRO	F,DRWALL
	POPJ	P,

	BEND TYMDPY

^SCLRCL:;; clear the screen
	MOVE	M,DDSW
	JRST  @(M)[CPOPJ
		CPOPJ
		CPOPJ
		LSICL
		ZENCL
		HP4CL
		H19CL]

^^SVTLIN:	BLOCK <MAXDLN+2>*LINLEN
CURBOT:		;sets cursor to interaction area
	MOVE D2,DDSW
	JRST  @(D2)[CPOPJ
		CPOPJ
		CPOPJ
		LSIBOT
		ZENBOT
		HP4BOT
		H19BOT]

H19BOT:	IONEOU	[33]	;move cursor to bottom
	IONEOU	["Y"]
	IONEOU	["6"]
	IONEOU	[" "]
	OUTCHI	15
	IONEOU	[33]	;and erase line
	IONEOU	["K"]
	POPJ	P,
HP4BOT:	IONEOU	[33]	;move cursor to bottom
	IONEOU	["&"]
	IONEOU	["a"]
	IONEOU	["2"]
	IONEOU	["2"]
	IONEOU	["R"]
	OUTCHI	15
	IONEOU	[33]	;and erase line
	IONEOU	["K"]
	POPJ	P,
LSIBOT:	OUTCHI	15
	IONEOU	[33]
	IONEOU	["="]
	HRRE	D2,SPNT	;MOVE CURSOR TO BOTTOM OF DISPLAYED AREA
	MOVNS	D2
	ADDI	D2,43
	IONEOU	D2	;line number
	IONEOU	[" "]	;character (horizontal) position
	POPJ	P,

ZENBOT:	OUTCHI	15
	IONEOU	[33]
	IONEOU	["C"]
	HRRE	D2,SPNT	;get bottom line number
	MOVNS	D2	;Get proper sign
	ADDI	D2,4
	ROT	D2,-4	;get high-order bits
	ADDI	D2,"0"	;convert to cursor position code
	IONEOU	D2
	ROT	D2,4	;Now get low order line number bits
	ANDI	D2,17	;clear previous junk
	ADDI	D2,"0"	;convert for output
	IONEOU	D2
	IONEOU	["0"]	;column zero for interaction
	IONEOU	["0"]
	IONEOU ["}"]
	POPJ	P,
>


.FORVA__2	;frame operation "read virtual address"
.FOWVA__3	;frame operation "write virtual address"
^^FRAME: 0,,-1
FO.ADD:	0
FO.VAL:	0

^^RD.V.E: ;;read V from address in E.  +1=failure, +2=success
	SETOM	FO.ADD
	TRNE	E,777760
	 JRST	FRM.DO
	MOVE	V,JAC(E)
	AOS	(P)
	POPJ	P,

^^WT.V.E: 	;;write V into address in E.  +1=failure, +2=success
	TRNN	E,777760
	 JRST	[MOVEM	V,JAC(E)
		 JRST	POPJ1]
	SETZM	FO.ADD
	MOVEM	V,FO.VAL
FRM.DO:	EXCH	E,FO.ADD
	HRLI	E,.FOWVA(E)
	HRR	E,FRAME
OPDEF FRMOP [44B8]
	FRMOP	E,FO.ADD
	 SOS	(P)		;woops, failure
	MOVE	E,FO.ADD
	MOVE	V,FO.VAL
POPJ1:	AOS	(P)
	POPJ	P,
^^GETPOI:
GETE.V:	;;read thing pointed to by V.  get address into E, value into V
	;;return +2 if successful, +1 on failure (would ILL MEM REF)
	HRRZ	E,V
	TLNE	V,3	;check for "linked display" bits
	 JRST	DYNCEL	;yes, its dynamic.  go solve dynamic links
DYNC.1:
IFN FILESW,<
	TLNN	V,140	;the "abnormal address space" bits
	 SKIPE	NOTFIL	;flag saying "this comes from RAID"
	  JRST	READIT	
	CAMLE	E,FILLST
	 POPJ	P,	;FAIL if not within address range
	PUSHJ	P,RDTRKE	;READ IN TRACK WITH ADDRESS THAT'S IN E
	MOVE	V,@TRKOFF
	AOS	(P)	;successful
	POPJ	P,
READIT:	TLZE	V,100	;is it RAID-relative?
	 ADDI	E,RAID
	TLZE	V,040	;is it LOOKUP BLOCK-relative?
	 ADDI	E,SVLUP
>;FILESW
	PUSHJ	P,RD.V.E
	 POPJ	P,	;failure
	AOS	(P)	;success
	POPJ	P,


DYNCEL:	;;read thing pointed to by V.  [E is RH]
	PUSH	P,M
	MOVNI	M,1000		;maximum number of indirects to follow
	MOVEM	M,INDCNT#
	MOVE	M,V		;SAVE DYNAMIC POINTER
	PUSHJ	P,DYNC.1	;read the cell anyway
	 JRST	POPMJ
	HLRZ	E,M
	ANDI	E,3	;GET RID OF RANDOM BITS
	XCT	(E)-1+[	HRRZS	E,V	;1 = RH of word
			HLRZS	E,V	;2 = LH of word
			HLRO	E,V]	;3 = EFF addr
	JUMPGE	E,NOPNT
EFFLUP:	ANDI	E,17		;get index field
	JUMPE	E,.+2
	 HRRZ	E,JAC(E)
	ADDI	E,(V)
	TLNN	V,20		;was it indirect?
	 JRST	NOPNT
	TLZ	E,-1
	AOSG	INDCNT
	 PUSHJ	P,DYNC.1
	  JRST	POPMJ
	HLRZ	E,V
	JUMPN	E,EFFLUP
	HRRZS	E,V
NOPNT:	TLZ	E,-1
>;NOT TENEX
>;NOT FILESW
IFN FILESW,<
	JRST	GETPOX
>;FILESW
	CAIGE	E,20
	 ADDI	E,JAC
POPMJ1:	AOS	-1(P)
POPMJ:	POP	P,M
	POPJ	P,

IFN FILESW,<
GETPOX:	SKIPE	NOTFIL
	 JRST	POPMJ1
	SKIPE	DMPFSW
	 JRST	GETPX1		;DUMP FILE
	CAMLE	V,FILLST
	 JRST	POPMJ
	JRST	POPMJ1

GETPX1:	CAIL	V,74
	 CAMLE	V,FJBHRL
	  JRST	POPMJ
	CAMLE	V,FJBREL
	 CAML	V,UPPRST
	  JRST	POPMJ1
	JRST	POPMJ
>;FILESW


;Conv -- Output Conversion Routine Dispatch
; THESE ARE THE OUTPUT ROUTINES -- THEY ALL WRITE INTO THE
; STRING CONTROLLED BY THE BYTE POINTER IN `E'.  THIS IS
; THE MAIN DISPATCH

^CONV:	LDB	T,[POINT 6,M,24] ;GET POSSIBLE ARGUMENT TO ROUTINE
	LSH	M,-5		;GET CONVERT ROUTINE NUMBER
	TRZ	F,CNVABS
	TRZE	M,40		;ABS MODE?
	 TRO	F,CNVABS	;YES
	ANDI	M,37		;GET RID OF EXTRANEOUS GARBAGE
	CAIGE	M,PRG
	 JUMPE	V,IT0		;USUALLY, 0 IS JUST 0
	JRST	@TABC-1(M)	;GO TO APPROPRIATE ROUTINE
	POPJ	P,

TABC:	INSTR		; 1
	HLFWRD		; 2
	CONOCT		; 3
	CONXWD		; 4
	CONR50		; 5
	CONSIX		; 6
	CONASC		; 7
	CONFLT		;10
	CONBYT		;11
	CONDEC		;12
	RHTEXT		;13
	RHTEXT		;14
	RHTEXT		;15
	CONBP		;16
	CONFLG		;17
	LHFLG		;20
	RHFLG		;21
	STSPRT		;22
	PRGPRT		;23
	BLKPRT		;24
repeat 37-24,<
	SETZ	UNKNWN
>;
UNKNWN:	PUSH	P,V
	MOVE	V,[ASCII "MODE "]
HEDLUP:	ROT	V,7
	IDPB	V,E
	TRZ	V,177
	JUMPN	V,HEDLUP
	MOVEI	V,"2"
	TRNE	M,10
	 MOVEI	V,"3"
	IDPB	V,E
	ANDI	M,7
	MOVEI	V,"0"(M)
	IDPB	V,E
	MOVEI	V,":"
	IDPB	V,E
	POP	P,V
	JRST	HLFWRD
;  Fndptr, Fndtbl, Conflg, Rhflg, Lhflg -- alfa J, alfa L, alfa R Commands

BEGIN CONFLG
FNDPTR:	SKIPN	M,FLGPTR	;GET POINTER WORD
	 POPJ	P,	;NO POINTER
FNDTBL:	SOJL	T,CPOPJ1	;THE NUMBER OF TABLE IS IN T
	HLRZS	M	;GET POINTER
	JUMPE	M,CPOPJ	;NO LINK
	SKIPE	M,(M)	;CHECK ADRESS
	 JRST	FNDTBL	;GO ON
	POPJ	P,
PRNTIT:	HRLI	M,-=18	;ONE HALF OF THE WORD
	SETZM	FULLFL#
	MOVEI	D3,0	;FLAG TO SAY IF WE SHOULD PRINT !
	SETZM	FLGNUM#	;SAVE EXTRA BITS HERE
LP1:	TDNN	V,T	;IS THE NEXT BIT ON?
	 JRST	NOBIT	;NO
	SKIPN	D2,(M)	;IS THERE A NAME FOR IT?
	 JRST  [FLGFOO:	IORM	T,FLGNUM	;NO SAVE UP BITS
			JRST	NOBIT]
	PUSH	P,D2
	MOVEI	D2,-13(E)	;GET POINTER
	CAML	D2,SAVEE	;TOO MANY CHRS. SO FAR?
	 SETOM	FULLFL	;YES
	POP	P,D2
	SKIPE	FULLFL	;TOO FULL?
	 JRST	FLGFOO
	SKIPE	D3
	 IDPB	D3,E	;PUT IN ! IF NEEDED
	PUSHJ	P,R5TYP
	MOVEI	D3,"!"	;SET FLAG
NOBIT:	LSH	T,-1	;SHIFT TO NEXT BIT
	AOBJN	M,LP1	;TRY FOR MORE
	SKIPE	FLGNUM	;ANYTHING EXTRA?
	 JRST	[PUSH	P,V	;SAVE VALUE
		SKIPE	D3
		 IDPB	D3,E
		MOVE	V,FLGNUM
		TRNN	V,-1	;CHECK HALF
		 MOVSS	V
		PUSHJ	P,CONOCT	;PRINT IT
		MOVEI	D3,"!"	;SET FLAG
		POP	P,V
		POPJ	P,]
	POPJ	P,


; alfa J PRINTER -- VALUE IN V, TABLE# IN T

^CONFLG:PUSHJ	P,FNDPTR	;GET POINTER NUMBER
	 JRST	HLFWRD		;NO POINTERS, PRINT OCTAL
	HRRZM	E,SAVEE#	;SAVE STARTING POINTER
	MOVSI	T,400000	;START UP
LP2:	PUSHJ	P,PRNTIT	;GO PRINT
	JUMPE	T,[TRON D3,"0"	;IF WE PRINTED NOTHING
		IDPB	D3,E	;THIS WILL NOT SKIP AND GET "0" IN D3
		POPJ	P,]		;EXIT
	TRCN	D3,.XOR.(",","!") ;CHANGE ! TO , SKIP IF ANY WERE ON (! WAS THERE)
	 JRST	LP2	;NO GO DO NEXT HALF
	IDPB	D3,E
	IDPB	D3,E	;PUT IN ,,
	JRST	LP2

; alfa L PRINTER

^LHFLG:	PUSHJ	P,FNDPTR	;SET UP POINTER
	JRST	INSTR	;PRINT AN INSTRUCTION
COMTPN:	PUSH	P,M
	HRRZM	E,SAVEE	;SAVE STARTING POINTER
	PUSH	P,V
	HLLZS	V	;NO ADR FIELD
	PUSHJ	P,INSTR	;PRINT INSTR
	POP	P,V
	POP	P,M	;RESTORE VALUE AND POINTER
	MOVEI	T,400000	;CHECK RH
	PUSHJ	P,PRNTIT
	TRON	D3,"0"
	 IDPB	D3,E
	POPJ	P,

; alfa R PRINTER

^RHFLG:	PUSHJ	P,FNDPTR
	JRST	INSTR
	ADDI	M,=18	;USE RH BITS
	JRST	COMTPN
BEND CONFLG


;  Hlfwrd, Instr, Opdret, Noacq

IT0:	MOVEI	V,"0"
	IDPB	V,E
	POPJ	P,
CSW1:	0


BEGIN HLFWRD

; (UNSIGNED HALFWORD) (UNSIGNED HALFWORD) PRINTER

^HLFWRD:SETZM	CSW1	;CLEAR FLAG
LOOP5:	MOVEI	M,6	;GET COUNT
	MOVEI	PV,0	;CLEAR AC
LOOP4:	LSHC	PV,3	;GET DIGIT
	JUMPN	PV,PNT1	;NON-ZERO?
	SOJG	M,LOOP4	;NO, ZERO
	SETOM	CSW1
	JRST	LOOP5

PNT1:	IORI	PV,60	;OR IN ASCII
	IDPB	PV,E	;DEPOSIT
	SOJLE	M,PNT2	;COUNT
PNT3:	MOVEI	PV,0	;CLEAR
	LSHC	PV,3	;GET NEXT DIGIT
	JRST	PNT1

PNT2:	SKIPE	CSW1	;FIRST OR SECOND HALF?
	 POPJ	P,	;SECOND
	SETOM	CSW1	;SET SWITCH
	MOVEI	PV,40	;PUT OUT A...
	IDPB	PV,E	;SPACE
	MOVEI	M,6
	SOJA	F1,PNT3
BEND HLFWRD

BEGIN INSTR
^INSTR:
	TLCN	V,-1		;LEFT HALF ZERO?
	JRST [	TLC	V,-1	;YES
		JRST	CONXWD]
	TLCN	V,-1		;LEFT HALF =-1?
	JRST	CONOCT		;YES
	TLCN	V,777000	;NO OP-CODE?
	JRST   [TLC	V,777000
		PUSHJ	P,TRYSYM ;TRY TO TYPE AS SYM +OR- SMALL OFFSET
		POPJ	P,
		JRST	CONXWD]	;CAN'T PRINT AS SYM
	TLCN	V,777000
	JRST	CONXWD
	MOVE	T,V		;SAVE VALUE
	PUSHJ	P,OPLOOK	;LOOK UP OPCODE
	JUMPE	D2,OPDF		;NO OP-CODE?
	MOVE	D3,D2		;YES, OPCODE
	PUSHJ	P,SIXOUT	;TYPE IT OUT
^OPDRET:MOVEI	D3,40
	IDPB	D3,E
IFN EXDSW,<
	TRZE	F,CONOFF	;I/O OPCODE?
	 JRST	OPIOPT		;YES
>
	LDB	D2,[POINT 9,T,8]	;GET OP CODE
	MOVEI	PV,-67(D2)
	IDIVI	PV,9
	LDB	D3,INPPTB(V)	;GET TABLE ENTRY
	CAIL	D2,600
	 JRST	OPTEST
	LDB	V,[POINT 4,T,12]	;GET AC FIELD
	JUMPN	V,ACNZ
	TRNE	D3,2		;NO SKIP IF DON'T PRINT ZERO AC FIELD
	 JRST	NOAC
ACTYP:	PUSH	P,D3
	PUSHJ	P,EXACTY	;TYPE OUT AC FIELD AS SYMBOL IF POSSIBLE
	POP	P,D3
	JRST	ACTYPD

ACNZ:	TRNN	D3,1		;SKIP IF PRINT NON-ZERO AC AS NUMBER
	 JRST	ACTYP
	PUSHJ	P,CONOCT
ACTYPD:	MOVEI	V,","
	IDPB	V,E		;OUTPUT A ,
NOAC:	MOVEI	V,"@"
	TLNE	T,20		;@ BIT?
	 IDPB	V,E		;YES
	HRRZ	V,T		;GET ADDRESS FIELD
	JUMPN	V,ENZ
	TRNN	D3,20		;SKIP IF AN I/O INSTRUCTION
	 TLNN	T,17		;SKIP IF XR FIELD IS NON-ZERO
	  TRNE	D3,4
	   JRST	ETYPD		;NOT SUPPOSED TO TYPE 0 E FIELD
	TLNN	T,20		;IF @ WE WANT SYMBOLIC
	 TRNN	D3,30
	  JRST	ETYP
	JRST	EOCT		;WANT TO TYPE LESS THAN 20 AS OCTAL
ETYP:	PUSHJ	P,ADTYP		;TYPE IT OUT
	JRST	ETYPD

ENZ:	CAIL	V,20
	 JRST	ETYP
	TRNN	D3,20	;IF OPCODE IS AN I/O INSTRUCTION, TYPE OCTAL
	 TLNN	T,17
	  CAIA
	  JRST	EOCT
	TLNN	T,20		;IF @ WE WANT SYMBOLIC
	 TRNN	D3,30
	  JRST	ETYP
EOCT:	PUSHJ	P,CONOCT
ETYPD:	LDB	V,[POINT 4,T,17]	;GET INDEX FILED
	JUMPE	V,NOIX		;NO INDEX FIELD?
	MOVEI	PV,"("
	IDPB	PV,E		;PUT OUT A (
	PUSHJ	P,EXACTY	;TYPE IX
	MOVEI	V,")"
	IDPB	V,E		;PUT OUT A )
NOIX:	POPJ	P,

OPTEST:	LDB	V,[POINT 4,T,12]	;GET AC FIELD
	JUMPN	V,TSTANZ
	TRNE	D3,2
	 JRST	TSTACD
TSTANZ:	PUSH	P,D3
	PUSHJ	P,EXACTY
	POP	P,D3
	MOVEI	V,","
	IDPB	V,E
TSTACD:	MOVEI	V,"@"
	TLNE	T,20		;@ BIT?
	 IDPB	V,E		;YES
	HRRZ	V,T		;GET ADDRESS FIELD
	JUMPN	V,TSTENZ
	TLNN	T,17
	 TRNE	D3,4
	  JRST	ETYPD
	JRST	ETYP

;SOME DAY THIS SHOULD DO THE RIGHT THING W.R.T FLAG MODE
TSTENZ:	TRNN	D3,10
	 JRST	ENZ
	CAIL	V,20
	 JRST	ETYP
	JRST	EOCT

^NOACQ:	MOVEI	D3,0		;GET HERE FROM BYTE POINTER PRINTER
	JRST	ACTYPD

IFN EXDSW,<
OPIOPT:	MOVE	D3,V		;GET DEVICE NAME
	LDB	V,[320700,,T]
	LSH	V,2
	JUMPE	D3,OPIOP1	;PRINT NUMERIC DEV
	PUSHJ	P,SIXOUT
	MOVEI	D3,20		;INDICATE OPCODE IS I/O INSTRUCTION
	JRST	ACTYPD

OPIOP1:	MOVEI	D3,20		;INDICATE OPCODE IS I/O INSTRUCTION
	JRST	ACTYP		;TYPE V (DEVICE CODE) AS A NUMBER
>;EXDSW




;INPTBL		INSTRUCTION PRINTING TABLE

;THIS TABLE CONTAINS 4 BITS OF INFORMATION FOR EACH OPCODE BETWEEN
;100 AND 677.  THE BITS CONTROL HOW THE REST OF THE INSTRUCTION IS
;PRINTED

;1:	PRINT AC FIELD AS A NUMBER IF NON-ZERO
;2:	DON'T PRINT AC FIELD IF ZERO
;4:	DON'T PRINT E FIELD IF ZERO
;8:	PRINT E FIELD AS A NUMBER IF LESS THAN 20 UNLESS @

;IN THE CASE OF THE TEST (6XX) INSTRUCTIONS BITS 2 AND 4 WILL HAVE THE SAME
;VALUE: ON IN THE CASE OF THE NEVER SKIP OR ALWAYS SKIP N-TYPE INSTRUCTIONS.
;THE 8 BIT MEANS THAT THE E FIELD REPRESENTS BITS, USE FLAG NAMES OR NUMBERS

INPTBL:	BYTE (4) 0, 1, 2, 4, 6, 0, 0, 0, 0		;67-77	(PHONEY FOR UUOS) 
	0					;100-110
	0					;111-121
	BYTE (4) 0, 0, 0, 0, 0, 0, 0, 0,10		;122-132
	BYTE (4) 2, 0, 0, 0, 0, 0, 0, 0, 0		;133-143
	BYTE (4) 0,10, 0, 0, 0, 0, 0, 0, 0		;144-154
	BYTE (4)10, 0, 0, 0, 0, 0, 0, 0,10		;155-165
	BYTE (4) 0, 0, 0, 0, 0, 0, 0,10, 0		;166-176
	BYTE (4) 0, 0,10, 0, 2, 0,10, 0, 2		;177-207
	BYTE (4) 0,10, 0, 2, 0,10, 0, 2, 0		;210-220
	BYTE (4)10, 0, 0, 0,10, 0, 0, 0,10		;221-231
	BYTE (4) 0, 0, 0,10, 0, 0,10,10,10		;232-242
	BYTE (4) 0,10,10,10,10, 0, 0, 0, 0		;243-253 (*+0)
	BYTE (4) 3, 7, 3, 0, 0, 0, 0, 4, 3		;254-264
	BYTE (4) 0, 0, 0, 0,10, 0, 0, 0,10		;265-275
	BYTE (4) 0, 0,16,10,10,10,16,10,10		;276-306
	BYTE (4)10, 6, 0, 0, 0, 6, 0, 0, 0		;307-317
	BYTE (4) 6, 0, 0, 0, 6, 0, 0, 0, 6		;320-330
	BYTE (4) 2, 2, 2, 6, 2, 2, 2, 4, 0		;331-341
	BYTE (4) 0, 0, 4, 0, 0, 0, 2, 2, 2		;342-352
	BYTE (4) 2, 2, 2, 2, 2, 4, 0, 0, 0		;353-363
	BYTE (4) 4, 0, 0, 0, 2, 2, 2, 2, 2		;364-374
	BYTE (4) 2, 2, 2, 4, 4, 2, 0, 0,10		;375-405
	BYTE (4) 0, 0, 0,10, 0, 0, 0,10, 2		;406-416
	BYTE (4) 0, 0,10, 0, 0, 4, 4, 0, 0		;417-427
	BYTE (4) 0,10, 0, 0, 0,10, 0, 0, 0		;430-440
	BYTE (4)10, 0, 0, 0,10, 0, 0, 4, 4		;441-451
	BYTE (4) 0, 0, 0,10, 0, 0, 0,10, 2		;452-462
	BYTE (4) 0, 0,10, 0, 0, 0,10, 0, 0		;463-473
	BYTE (4) 4, 4, 2, 0, 0,10, 0, 2, 0		;474-504
	BYTE (4)10, 0, 2, 0,10, 0, 2, 0,10		;505-515
	BYTE (4) 0, 2, 0,10, 0, 2, 0,10, 0		;516-526
	BYTE (4) 2, 0,10, 0, 2, 0,10, 0, 2		;527-537
	BYTE (4) 0,10, 0, 2, 0,10, 0, 2, 0		;540-550
	BYTE (4)10, 0, 2, 0,10, 0, 2, 0,10		;551-561
	BYTE (4) 0, 2, 0,10, 0, 2, 0,10, 0		;562-572
	BYTE (4) 2, 0,10, 0, 2,16,16,10,10		;573-603
	BYTE (4)16,16,10,10, 6, 6, 0, 0, 6		;604-614
	BYTE (4) 6, 0, 0,10,10,10,10,10,10		;615-625
	BYTE (4)10,10, 0, 0, 0, 0, 0, 0, 0		;626-636
	BYTE (4) 0, 0, 0, 0, 0, 0, 0, 0, 0		;637-647
	BYTE (4) 0, 0, 0, 0, 0, 0, 0, 0,10		;650-660
	BYTE (4)10,10,10,10,10,10,10, 0, 0		;661-671
	BYTE (4) 0, 0, 0, 0, 0, 0			;672-677

INPPTB:	POINT 4,INPTBL(PV),3
	POINT 4,INPTBL(PV),7
	POINT 4,INPTBL(PV),11
	POINT 4,INPTBL(PV),15
	POINT 4,INPTBL(PV),19
	POINT 4,INPTBL(PV),23
	POINT 4,INPTBL(PV),27
	POINT 4,INPTBL(PV),31
	POINT 4,INPTBL(PV),35


;  Rhtext, Adtyp, R5typ, ADSEL, TRYSYM
; INSTRUCTION PRINTER, R50, SIXBIT, ASCII IN RH

^RHTEXT:PUSH	P,M
	PUSH	P,V
	HLLZ	V,V
	PUSHJ	P,INSTR
	LDB	T,E	;GET LAST CHARACTER OUTPUT
	CAIN	T,"0"
	 ADD	E,[070000,,]
	POP	P,V
	MOVE	M,(P)
	MOVE	T,(M)0-13+['"'+40
			"'"
			'"'+40]
	IDPB	T,E
	XCT (M)0-13+[	HRRZ	D2,V 	;R5TYP TAKES INPUT IN D2
			HRLZS	V
			HRRZS	V]
	PUSHJ P,@(M)0-13+[R5TYP
			  CONSIX
			  RJASC]
	POP	P,M
	MOVE	T,(M)0-13+["'"
			"'"
			'"'+40]
	IDPB	T,E
	POPJ	P,


; ADDRESS (SYMBOLIC+/-DISPLACEMENT) PRINTER

^^$ADTYP:
^ADTYP:	CAIGE	V,140
	JRST	EXACTY
	MOVE	F1,E	;SAVE BYTE POINTER
	MOVEM	V,VSV	;SAVE VALUE
	PUSHJ	P,FNDSYM	;LOOK UP IN SYMBOL TABLE
	MOVE	E,F1	;RESTORE BYTE POINTER
ADTYP1:	PUSHJ	P,ADSEL
	 JRST	CON3Q		;NEITHER ONE IS CLOSE ENOUGH
	 JRST	DNWIN		;DNSYM IS THE CLOSER ONE
	MOVEI	PV,"-"	;HOLD A -
	MOVE	M,D2
	MOVE	V,UPSYM	;GET SYMBOL NAME
	MOVE	D2,UPCUR	;GET BLOCK NAME
DNRET:	PUSHJ	P,SYMTYP	;TYPE OUT SYMBOL
	JUMPE	M,CPOPJ	;DONE?
	MOVE	V,M
	IDPB	PV,E
	JRST	CONOCT

DNWIN:	MOVEI PV,"+"	;HOLD A +
	MOVE V,DNSYM	;GET SYMBOL NAME
	MOVE D2,DNCUR	;GET BLOCK NAME
	JRST DNRET

;CALL ADSEL AFTER FNDSYM.  RETURNS DIRECT IF BOTH ARE TOO FAR AWAY.  SKIPS
;  ONCE IF DNSYM IS THE WINNER AND SKIPS TWICE IF UPSYM IS THE WINNER
^^ADSEL:MOVM	D2,UPDIF	;GET DIFFERENCES
	JUMPE	D2,ADJ2	;EXACT MATCH?
	MOVM	M,DNDIF
	MOVEI	PV,777
	ANDM	PV,WCNT
	ANDM	PV,WCNT+1
	CAMLE	M,WCNT	;IS DNDIF TOO BIG?
	 JRST	DNBIG	;YES
	CAMLE	D2,WCNT+1	;IS UPDIF TOO BIG?
	 JRST	ADJ1	;YES
	MOVE	V,WCNT+3
	IMUL	V,M
	ASH	V,-6
	SUB	V,D2
	SUB	V,WCNT+2
	JUMPLE	V,ADJ1
ADJ2:	AOS	(P)
ADJ1:	AOS	(P)
	POPJ	P,

DNBIG:	CAMLE	D2,WCNT+1
	POPJ P,
	JRST ADJ2

^TRYSYM:MOVEM	V,VSV
	MOVE	F1,E
	PUSHJ	P,FNDSYM	;LOOKUP IN SYM TABLE
	MOVE	E,F1
	MOVE	V,VSV
	MOVEI	D2,777
	ANDM	D2,WCNT
	ANDM	D2,WCNT+1
	MOVM	D2,DNDIF
	MOVM	D3,UPDIF
	CAMLE	D2,WCNT
	 CAMG	D3,WCNT+1
	  JRST	ADTYP1	;TYPE AS SYMBOL + OR - OFFSET
	AOS	(P)
	POPJ	P,	;CAN'T PRINT AS A SYMBOL

^^$C:
^WCNT:	77
	77
	10
	40

BEND INSTR
VSV:	0
EXACTY:	MOVEM	E,D2	;SAVE BYTE POINTER
	PUSHJ	P,FNDSYM	;LOOK UP IN TABLE
	MOVE	E,D2	;RESTORE BYTE POINTER
	SKIPE	UPDIF	;EXACT MATCH?
	 JRST	CONOCT	;NO, TYPE AS NUMBER
	MOVE	V,UPSYM	;GET SYMBOL
	MOVE	D2,UPCUR	;GET BLOCK NAME
SYMTYP:	JUMPE	D2,NOBLK	;NO BLOCK NAME?
	PUSHJ	P,R5TYP	;TYPE BLOCK NAME
	MOVEI	D2,"&"	;TYPE A &
	IDPB	D2,E
NOBLK:	MOVE	D2,V	;GET SYMBOL NAME

;  R5typ -- Radix50 Printer
; VALUE IN D2
; OUTPUT TO E'S BP, AS USUAL

^R5TYP:	TLZ	D2,740000	;CLEAR HIGH ORDER BITS
	IDIVI	D2,50	;GET CHR
	ADDI	D3,60-1	;CONVERT
	CAIGE	D3,13+(60-1);LETTER?
	 JRST	GOTYP	;NO
	ADDI	D3,101-13-(60-1);CONVERT
	CAIG	D3,132	;FUNNY LETTER?
	 JRST	GOTYP	;NO
	CAIN	D3,133
	 MOVEI	D3,"."
	CAIN	D3,134
	 MOVEI	D3,"$"
	CAIN	D3,135
	 MOVEI	D3,"%"
GOTYP:	JUMPE	D2,GOAT1
	HRLM	D3,(P)	;SAVE CHR
	PUSHJ	P,R5TYP	;TYPE FIRST PART
	HLRZ	D3,(P)	;GET CHR.
GOAT1:	IDPB	D3,E	;TYPE THE LETTER
	POPJ	P,


;  Conoct, Consix, Sixout, Opdf

; VALUE IN V

TYPNEG__774000
CON3Q:	SETCM	PV,VSV	;GET IT
	TRNE	PV,TYPNEG	;SMALL NEGATIVE NUMBER?
	 TLC	PV,-1		;NO
	TRCA	PV,-1
CONOCT:	 MOVE	PV,V
	JUMPL	PV,CON3B
CON3A:	IDIVI	PV,10	;THIS HERE IS THE FAMOUS ...
	JUMPE	PV,CON3C	;.. ANY-RADIX-NUMBER-PRINTER
	HRLM	V,(P)
	PUSHJ	P,CON3A
	HLRZ	V,(P)
CON3C:	ORI	V,60
	IDPB	V,E
	POPJ	P,
CON3B:	MOVEI	V,"-"
	IDPB	V,E
	MOVMS	PV
	JRST	CON3A

; SIXBIT PRINTER -- VALUE IN V

CONSIX:	MOVSI	D2,40000
	SKIPA	D3,V
SIXOUT:	 MOVEI	D2,0	;CLEAR
SIXOT:	LSH	D2,-7
	LSHC	D2,6	;GET CHR.
	JUMPE	D2,SIXOUQ	;NULL?
	ADDI	D2,40	;CONV. TO ASCII
	IDPB	D2,E	;OUTPUT
SIXOUQ:	JUMPN	D3,SIXOT	;LOOP IF MORE TO GO
	POPJ	P,

; USER-DEFINED OPCODE FINDER AND PRINTER
; USED BY INSTR ABOVE (I DON'T KNOW EITHER)

OPDF:	MOVE	V,T	;GET VALUE
	MOVE	F1,E
	PUSHJ	P,FNDSYM	;LOOKUP IN SYM TABLE
	MOVE	E,F1
	SKIPE	D3,UPDIF	;EXACT?
	 SKIPA	D3,DNDIF	;NO
	  SKIPA	D2,UPSYM	;YES, GET NAME
	  MOVE	D2,DNSYM	;NO, GET NAME
	MOVE	V,T	;RESTORE VALUE
	TLNE	D3,777000	;CLOSE ENOUGH?
	 JRST	OPDF1	;NO
	MOVE	T,D3	;YES, GET DIFF.
	TLO	T,067000	;PHONEY OPCODE FOR CLEVER CYMBOLIC PRINTOUT
	PUSHJ	P,R5TYP
	JRST	OPDRET

OPDF1:	PUSHJ	P,TRYSYM	;TRY TO TYPE AS SYM + OR - N
	POPJ	P,	;DID IT
	JRST	CONXWD	;CAN'T DO IT


;  Conasc -- Ascii Printer
; VALUE IN V
; IF ALL BUT RH 7 BITS=0, ASSUMES RIGHT-JUSTIFIED, ELSE LEFT

CONASC:	TDNN	V,[-1,,777600]	;ASSUME RJ ONLY IF RH 7 BITS ONLY
RJASC:	 LSH	V,1
	PUSH	P,T	;SAVE ANOTHER
	MOVEI	D3,5	;CONVT.
CONALP:	MOVEI	PV,0
	LSHC	PV,7	;GET CHR.
	JUMPE	PV,PLOPP
	CAIN	PV,12
	 JRST	ITLF
	CAIN	PV,15
	 JRST	ITCR
	CAIN	PV,11	;TAB?
	 JRST	ITAB	;YES
IFN STANFO,<
	CAIN	PV,177	;BACKSPACE?
>;STANFORD
IFE STANFO,<
	CAIN	PV,177	;DEL?
	 JRST	ITDEL
	CAIN	PV,10	;BACKSPACE??
>;NOT STANFORD
	 JRST	ITBS	;YES, USE "\" CHARACTER
	CAIN	PV,ALTMOD	;ALTMODE?
	 JRST	ITALT	;YES
	CAIGE	PV,40
	JRST	ITDIG
PLOP2:	IDPB	PV,E	;DEPOSIT
PLOPP:	SOJG	D3,CONALP	;LOOP
	JUMPGE	V,PPPOPJ	;LOW ORDER BIT ON?
	MOVEI	PV,"@"	;YES, DENOTE IT
	IDPB	PV,E	;AND WRITE IT
PPPOPJ:	POP	P,T	;RESTORE
	POPJ	P,
PTEM:	0
IFE STANFO,<
ITDEL:	SKIPA	T,[ASCII /DEL/]
>;NOT STANFO
ITBS:	MOVE	T,[ASCII /BS/]
	JRST	IT
ITALT:	SKIPA	T,[ASCII /ALT/]
ITAB:	MOVE	T,[ASCII /TAB/]
	JRST	IT
ITCR:	SKIPA	T,[ASCII /CR/]
ITLF:	MOVE	T,[ASCII /LF/]
IT:
	PUSH	P,D3
IFN STANFO,<
	MOVE	D3,DDSW
	JRST @(D3)[ITTTY
		ITVTS
		ITNGP
		ITDD
		ITIII]

ITIII:	TDZA	PV,PV	;CLEAR REST OF WORD
	 IDPB	PV,E
	TLNE	E,760000	;EOW(ORD)?
	 JRST	.-2
	TRO	T,1
	MOVEM	T,2(E)
	MOVEI	T,.LEFT.(1,10)+46
	MOVEM	T,1(E)
	MOVEI	T,.LEFT.(2,10)+46
	MOVEM	T,3(E)
	ADDI	E,3
	HRLI	E,700
	JRST	POPD

ITDD:	MOVEI	T,177
	IDPB	T,E		;PUT OUT 177 TO SIGNAL SPECIAL
	POP	P,D3
	JRST	PLOP2		; (EENSY WORDS DESCRIBING CHARS)
ITTTY: ITNGP: ITVTS:
>;STANFO

	MOVEI	PV,"<"
	IDPB	PV,E
	IDPB	PV,E
	PUSH	P,V
	MOVE	V,T
	PUSHJ	P,CONASC
	POP	P,V
	MOVEI	PV,">"
	IDPB	PV,E
	IDPB	PV,E
POPD:
	POP	P,D3
	JRST	PLOPP
ITDIG:	MOVSI	T,(<ASCII /00/>)
	DPB	PV,[POINT 3,T,13]
	LSH	PV,-3
	DPB	PV,[POINT 3,T,6]
	JRST	IT


;CONR50, CONXWD, CONBP

;  Conr50 -- For Printing Radix50 on Request -- 5 alfa T -- Conbp
; VALUE IN V

CONR50:	MOVE	D2,V
	LDB	V,[POINT 4,D2,3];GET HIGH ORDER BITS
	LSH	V,2
	PUSHJ	P,CONOCT	;TYPE OUT
	MOVEI	V,40	;SPACE
	IDPB	V,E
	JRST	R5TYP

; L,,R PRINTER (EACH HALF SYMBOLIC)

CONXWD:	MOVE	T,V		;HOLD VALUE
	HLRZS	V		;GET LEFT HALF
	JUMPE V,[SETCM	PV,T
		TRNE	PV,TYPNEG	;SMALL NEG NUM IN RIGHT HALF?
		 JRST	C4R1	;NO
		PUSHJ	P,IT0	;YES
		JRST	C4R2]
	PUSHJ	P,ADTYP		;TYPE IT
C4R2:	MOVEI	V,","
	IDPB	V,E
	IDPB	V,E
C4R1:	HRRZ	V,T	;GET RIGHT HALF
	JUMPE	V,IT0	;ZERO?
	JRST	ADTYP	;TYPE IT


; BYTE POINTER PRINTER

CONBP:	PUSH	P,V
	MOVE	D3,['POINT']
	PUSHJ	P,SIXOUT	;TYPE 'POINT'
	MOVEI	V,40
	IDPB	V,E		;TYPE A SPACE
	LDB	V,[POINT 6,(P),11]	;GET SIZE
	PUSHJ	P,PDECCN	;TYPE IT
	MOVE	T,(P)		;GET WORD AGAIN
	TLZ	T,777740	;CLEAR HIGH PART
	PUSHJ	P,NOACQ		;TYPE ADDRESS ETC.
	LDB	V,[POINT 6,(P),5]	;GET POSITION
	SUB	P,[1,,1]
	CAIN	V,44		;IS POSITION 44?
	JRST	CPOPJ 		;YES, DON'T TYPE IT
	MOVEI	M,","
	IDPB	M,E		;TYPE A COMMA
	SUBI	V,43
	JRST	PDECCN		;TYPE POSITION


;  Conflt -- Floating Point Output Routine
   ;INSTRUCTIONS STOLEN FROM DDT
   ;COMMENTS ADDED BY P. PETIT

CONFLT:	MOVM	T,V
	TLNN	T,400	;NORMALIZED?
	 JRST	CONDEC	;NO
	JUMPGE	V,CF2	;need negative sign?
	MOVE	V,T	;yup, want positive later
	MOVEI	T,"-"	;GET -
	IDPB	T,E	;DEPOSIT
CF2:	MOVEM	D1,D1SV	;SAVE D1
	MOVE	D1,V	;GET WORD
	SETZB	D2,D3
	CAMGE	D1,FT01	;TOO SMALL?(LESS THAN .1?)
	 JRST	FP4	;YES
	CAML	D1,FT8	;TOO BIG?(GREATER THAN 10**8?)
	 AOJA	D2,FP4	;YES
FP3:	MULI	D1,400	;GET EXPONENT
	ASHC	D2,-243(D1)	;FIX # AND GET FRACTION IN D3
	MOVE	V,D2	;GET WHOLE (INTEGER) PART
	MOVEI	M,0	;CLEAR COUNT
	PUSHJ	P,PDECCN	;PRINT WHOLE PART
	MOVEI	V,"."	;GET A .
	IDPB	V,E	;PRINT IT
	SUBI	M,10	;ADJUST COUNT
CF3:	MOVE	D2,D3	;GET FRACTION
	MULI	D2,12	;GET DIGIT
	MOVE	V,D2
	PUSHJ	P,CON10B	;TYPE IT
	SKIPE	D3	;DONE?
	 AOJL	M,CF3	;NO, DONE?
	MOVE	D1,D1SV	;YES;
	POPJ	P,
D1SV:	0
FP4:	MOVNI	D3,6
	MOVEI	T,
FP4A:	ASH	T,1	;SHIFT COUNT
	XCT	FCP(D2)	;COMPARE
	 JRST	FP4B	;NO YET
	FMPR	D1,@FCP+1(D2);YES, MULTIPLY
	ORI	T,1	;INSERT A BIT IN COUNT
FP4B:	AOJN	D3,FP4A	;LOOP
	PUSH	P,FSGN(D2)
	PUSHJ	P,FP3	;PRINT ADJUSTED #
	POP	P,M	;GET SIGN
	MOVEI	D2,"E"	;GET AN E
	IDPB	D2,E
	IDPB	M,E	;DEPOSIT SIGN
	MOVE	V,T	;GET COUNT
	JRST	DECCON

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0__FT01+1
FCP:	CAMLE	D1,FT0(D3)
	CAMGE	D1,FT(D3)
	 FT0(D3)
FSGN:	"-"
	"+"


;  Condec, Conbyt -- Decimal, Byte Printer

CONDEC:	MOVE	PV,V
	MOVEI	M,0		;FOR COUNTING FOR COMMAS
	JUMPGE	PV,CONDE1	;POSITIVE?
	MOVEI	V,"-"		;NO, PRINT A -
	IDPB	V,E
	MOVMS	PV
CONDE1:	MOVEI	V,"="
	JUMPE	PV,CON10C
	IDPB	V,E
CON10C:	ADDI	M,1
	IDIVI	PV,12
	HRLM	V,(P)
	JUMPE	PV,[MOVE PV,M
		IDIVI	PV,3
		SKIPN	M,V
		MOVEI	M,3	;SET UP FOR COMMAS
		JRST	.+2]
	PUSHJ	P,CON10C
	SOJL	M,[MOVEI V,","
		IDPB	V,E
		MOVEI	M,2
		JRST	.+1]
	HLRZ	V,(P)
	ADDI	V,"0"
	IDPB	V,E
	POPJ	P,

DECCON:	SKIPL	PV,V
	JRST	CON10A
	MOVEI	V,"-"
	IDPB	V,E
	JRST	CON10A

PDECCN:	MOVM	PV,V
CON10A:	IDIVI	PV,12		;GET DIGIT
	ADDI	M,1
	JUMPE	PV,CON10B	;THAT ALL?
	HRLM	V,(P)		;NO, SAVE REMAINDER
	PUSHJ	P,CON10A	;PRINT REST
	HLRZ	V,(P)		;GET REMAINDER BACK
CON10B:	ADDI	V,"0"
	IDPB	V,E		;DEPOSIT CHR
	POPJ	P,

;CONBYT:  BYTE MODE OUTPUT

CONBYT:	MOVE	M,T	;GET BYTE SIZE
	MOVE	D3,V	;GET #
	MOVEI	T,1
	JUMPE	M,CONB0	;ZERO SIZE?
CONB1:	MOVEI	D2,
	LSHC	D2,(M)	;GET BYTE
	LSH	T,(M)	;COUNT BYTES
	MOVE	V,D2
	PUSHJ	P,CONOCT	;TYPE OUT BYTE
	JUMPE	T,CPOPJ	;DONE?
	MOVEI	V,","	;NO
	IDPB	V,E	;TYPE A ,
	JRST	CONB1	;LOP
CONB0:	SKIPL	M,SMASK+1	;GET MASK
CONB2:	SETCA	M,	;COMPLEMENT
	MOVEI	D2,
CONB4:	LSHC	D2,1	;SHIFT VALUE
	LSH	T,1	;SHIFT COUNT
	LSH	M,1	;SHIFT MASK
	JUMPE	T,.+2
	JUMPL	M,CONB4	;LOOP
	MOVE	V,D2	
	PUSHJ	P,CONOCT	;PRINT RESULT
	JUMPE	T,CPOPJ	;DONE?
	MOVEI	V,","	;TYPE A ,
	IDPB	V,E
	JRST	CONB2


;Stsprt, Prgprt, Blkprt -- special top lines conversions

; Status:
;  Go out rh(NBIGWD) spaces
;  Print text indicated by index in LH(NBIGWD)
;  If undefined, or multiply defined, (check F), 
;   print "--  symbol name"
;  Do special size select things for DD
;  Set LH(NBIGWD) to .OK, for next time

STSPRT:
IFN STANFO,<
	MOVE	T,DDSW
	CAIE	T,.DD
	 JRST	 STSPR1
	MOVE	M,[CW(\FNCN,\ALPHBG,\CHNL,0,\CHNL,0)]
	MOVEM	M,(E)
	ADDI	E,1
>;STANFO
STSPR1:	HRRZ	M,NBIGWD
	SKIPA	V,[" "]
	 IDPB	V,E
	SOJGE	M,.-1
	HLRZ	V,NBIGWD
	CAIE	V,.OK	;MAKE SURE NEXT STATUS PRINTS IF
	 SETOM	 DDCON	; THIS ONE IS NOT "OK"
	MOVE	V,STSTXT(V)
	PUSHJ	P,CONASC
	HRRI	V,.OK
	HRLM	V,NBIGWD
	TLCN	F,PUFL!PMULFL	;BOTH ON MEANS "SKIP"
	 JRST	 SMLSET		; WERE BOTH OFF
	TLNN	F,PUFL!PMULFL	;BOTH ON?
	 JRST	 [MOVE V,SKPVAL
		 PUSHJ P,CONOCT
		 JRST SMLSET]
	SKIPN	D2,SYM
	 JRST	 SMLSET
	MOVE	V,[ASCII / -- /]
	PUSHJ	P,CONASC
	PUSHJ	P,R5TYP
SMLSET:	TLZ	F,PUFL!PMULFL	;ALL TOOK CARE OF
IFN STANFO,<
	CAIE	T,.DD
	 POPJ	P,
	PUSHJ	P,CRLFOT		;NEED CR BEFORE SELECT SMALL
	MOVE	M,[CW(\FNCN,\ALPHA,\CHNL,0,\CHNL,0)]
	MOVEM	M,1(E)
	ADDI	E,1			;ANOTHER CRLFOT WILL BE OK
>;STANFO
	POPJ	P,


; PRGNAM, BLKNAM -- just print (r50) the approp. names

IFE SORTED, <
PRGPRT:	SKIPA	D2,SYMPRG
BLKPRT:	MOVE	D2,SYMPNT
	MOVE	D2,(D2)
>;NOT SORTED
IFN SORTED, <
PRGPRT:	SKIPA	D2,PID
BLKPRT:	MOVE	D2,BID
	MOVE	D2,@BLKNM2
>;SORTED
	JRST	R5TYP


;Spblt, Iotbl, Iofndi -- These Belong Elsewhere
; CODE TO SET UP SPACEWAR STUFF
			IFN UESW,<	SPBLT:	HRLI 2,-1
					DATAO 2
					MOVN 3,2
					MOVE 4,36(3)
					MOVEM 4,SPB1 ;SYS SYMBOL TABLE PTR
					MOVS 5,4
					ADD 4,3
					MOVSS 4
					HRR 4,JOBFF
					MOVEM 4,JOBSYM
					MOVEM 4,SPB2	;BLT WORD
					HRLM 5,JOBSYM
					MOVNS 5
					ADD 5,JOBFF
					MOVEM 5,SPSWT1
					SKIPN SPSWT2
					0
					BLT 4,-1(5)
					SETZM SPBLT
					SETZM SPSWT2
					0
				SPB1:	0
				SPB2:	0>

IFN EXDSW,<
;I/O DEVICE TABLE:::::::
DEFINE IOTB (NAME,NUM)<.LEFT.(NUM,=24)!'NAME'>
IOTBL:
;note that PAG (former value 24, KL value 10) is not there at all
;	instead		MTR=24	 and IOP=10
FOR A IN (<APR,0>,<PI,4>,<IOP,10>,<CCA,14>,<TIM,20>,<MTR,24>
	,<PTP,100>,<PTR,104>,<CTY,120>
	,<LPT,1124>,<DC,1200>,<DCB,2204>,<UTC,1210>,<UTS,1214>,<MTC,1220>
	,<MTS,1224>,<MTM,1230>,<DCSA,1300>,<DCSB,1304>
	,<DKB,1310>,<VDS,1340>,<PK,1370>,<DIL,1374>
	,<TV,1404>,<DP,1430>,<KBD,1434>,<DSK,1444>,<D11,1470>,<C11,1474>
	,<PMP,1500>,<IBM,1504>,<DDD,1510>,<AS,1774>
	,<AD,2424>,<XGP,2440>,<PCLK,2730>)
<IOTB (A)
>
^^$IOTAB: REPEAT 4,<-1>	;DEV CODE PATCH AREA
IOTBLN__.-IOTBL

^IOFNDI:SKIPA	E,SIXSYM	;GET SYM
	 LSH	E,-6	;RIGHT ADJUST
	TRNN	E,77	;DONE?
	 JRST	.-2	;NO
	MOVEI	T,IOTBLN	;GET TABLE LENGTH
ILOPO:	LDB	M,[POINT 24,IOTBL-1(T),35]
	CAME	M,E	;SAME?
	 SOJG	T,ILOPO	;NO, LOOP
	JUMPE	T,CPOPJ	;NONE?
	LDB	M,[POINT 7,IOTBL-1(T),9];GET NUM
	LSH	M,2
	MOVEM	M,NM	;STORE VALUE
>;END EXDSW
^CPOPJ1:AOS	(P)
	POPJ	P,	;LEAVE


;Search Routines -- Oplook -- Opcode (Built-in) Finder

BEGIN OPLOOK

^^$OPLOOK:
^OPLOOK:SETZB	PV,D2	;CLEAR
	MOVEM	V,VSAV	;SAVE VALUE
	LSHC	PV,3	;GET HIGH-ORDER BITS
	JRST	@OTB1(PV)	;GO TO APPROPRIATE ROUTINE

OTB1:	OPUUO
	OP1
	OP2
	OP3
	OP4
	OP5
	OP6
	OPIO

OP3:	MOVEI	PV,0		;CLEAR
	LSHC	PV,3		;GET NEXT 3 BITS
	ADDI	PV,TAB		;GO TO TABLE
LOP1:	MOVE	D3,(PV)		;GET ENTRY
	LDB	PV,[POINT 3,D3,35]	;GET SHIFT COUNT
	IMULI	PV,6
	LSHC	D2,(PV)		;GET CORRECT # OF LETTERS
	MOVNS	PV
	LSH	D3,-3(PV)	;SHIFT BACK
	ADDI	D3,1		;ADJUST
	DPB	D3,[POINT 2,PNT1,35];DEPOSIT # OF BITS FOR NEXT TEST
	SUBI	D3,1		;UNADJUST
	MOVEI	PV,0		;CLEAR
PNT1:	LSHC	PV,0		;GET BITS (INSTRUCTION GETS CLOBBERED)
	ANDI	D3,774		;GET NEXT TABLE #
	JUMPE	D3,DONE		;DONE?
	ADDI	PV,TAB(D3)	;GET NEXT ENTRY
	JRST	LOP1

OP4:	MOVEI	PV,0		;CLEAR
	LSHC	PV,4		;GET 4 BITS
	MOVE	D3,TAB4(PV)	;GET TABLE ENTRY
	LDB	PV,[POINT 3,D3,35]	;GET # OF CHRS.
	IMULI	PV,6
	LSHC	D2,(PV)		;SHIFT IN CHRS.
	MOVEI	PV,0		;CLEAR
	LSHC	PV,2		;GET NEXT BITS
	ADDI	PV,TAB+40	;GO TO IMB TABLE
	JRST	LOP1

OP5:	TLCE	V,240000	;SWAP BITS
	TLCE	V,240000
	TLC	V,240000
	MOVEI	PV,0
	LSHC	PV,2		;GET 2 BITS
	ADDI	PV,TAB12
	JRST	LOP1

OP6:	FOR @$ I IN (50,21,5)
<REPEAT 3,<TLCE V,I$0000>
>
	MOVEI	PV,0
	LSHC	PV,2		;GET 2 BITS
	ADDI	PV,TAB14
	JRST	LOP1

OP2:	MOVEI	PV,0
	LSHC	PV,4		;GET 4 BITS
	ADDI	PV,TAB17	;GO TO TABLE 17
	JRST	LOP1

OP1:	MOVEI	PV,0
	LSHC	PV,4		;GET 4 BITS
;	CAIGE	PV,6		;TOO SMALL?
;	 JRST	DONE		;YES
	ADDI	PV,TAB33
	SKIPN	(PV)		;TABLE	ENTRY EXISTS?
	 JRST	DONE
	JRST	LOP1

DONE:	MOVE	V,VSAV
	POPJ	P,

IFN STANFO,<
OPUUO:	LSHC	PV,6	;GET REST OF OP-CODE
	CAIGE	PV,40
	 POPJ	P,	;NOT SYS UUO
	CAIN	PV,.LEFT.(<CALLI>,-33)
	 JRST	OPCLI	;SPECIAL TREATMENT FOR CALLIS
IONOT:	MOVE	V,VSAV
	HLLZ	D2,V
	TLZ	D2,37
	CALLIT	D2,	;TRY IT WITH AC FIELD
	JUMPN	D2,OPUU2	;GOT IT - NOW AVOID PRINTING AC
OPUU1:	HLLZ	D2,V
	TLZ	D2,777
	TLO	D2,1	;FORCE MAJOR OPCODE LOOKUP
	CALLIT	D2,	;NOW TRY OP ALONE
	JUMPE	D2,OPLUZ
>
OPWIN:	MOVEI	V,73
	DPB	V,[POINT 9,T,8]	;STORE DUMMY OPCODE FOR CLEVER CYMBOLIC MODE PRINTER
OPLUZ:	POPJ	P,	;RETURN WHATEVER
IFN STANFO,<
OPCLI:	MOVE	V,VSAV
	TLNE	V,37	;DON'T DECODE WITH ADR IF ANY @() BITS
	 JRST	OPUU1
	MOVE	D2,V
	TLZ	D2,777
	CALLIT	D2,	;LOOK UP WITH ADR
	JUMPE	D2,OPUU1	;LOSE - RETURN "CALLI" ANYWAY
	TRZA	T,-1	;WIN - AVOID PRINTING ADR
OPUU2:	 TLZ	T,740
>;STANFO


IFE STANFO,<
IFN TYMSHR,<
OPUUO:	LSHC	PV,6
	CAIGE	PV,40
	 POPJ	P,	;USER UUO
	CAIN	PV,.LEFT.(<CALLI>,-33)
	 JRST	OPCLI
	CAIN	PV,.LEFT.(<TTYUUO>,-33)
	 JRST	ISTTYU
OPUU1:	MOVE	D2,TABUUO-40(PV)
	JRST	OPWIN

ISTTYU:	LDB	PV,[POINT 4,VSAV,12]
	MOVE	D2,TTCALS(PV)	;HERE IS THE TTCALL TABLE
	TLZ	T,740
	JRST	OPWIN		;FORCE NOT TO PRINT AC

OPCLI:	MOVE	V,VSAV
	TLNE	V,37
	 JRST	OPUU1		;PRINT NORMAL IF @ OR INDEX
	HRRZS	V
	TRNN	V,1B18
	 JRST	POSCLD		;POSITIVE
	TROE	V,1B19
	 TLO	PV,(1B0)	;SET SIGN BIT
	CAIGE	V,NEGCLI&777777
	 JRST	OPUU1
	JRST	CLICOM

POSCLD:	TRZN	V,1B19
	TLO	PV,(1B0)
	CAILE	V,POSCLI
	 JRST	OPUU1
CLICOM:	SKIPN	D2,CALLIS(V)
	 JRST	OPUU1
	TLNE	PV,(1B0)
	 TRZA	T,-1
	  HRRI	T,200000
	JRST	OPWIN

TTCALS:	'INCHRW'	;0
	'OUTCHR'	;1
	'INCHRS'	;2
	'OUTSTR'	;3
	'INCHWL'	;4
	'INCHSL'	;5
	'GETLCH'	;6
	'SETLCH'	;7
	'RESCAN'	;10
	'CLRBFI'	;11
	'CLRBFO'	;12
	'SKPINC'	;13
	'SKPINL'	;14
	'IONEOU'	;15
	'OUTCHI'	;16
	'OUTPTR'	;17
MAXTTC==.-TTCALS-1

CALLIN:
	'XCHARG'	;-60
	'SETRFC'	;-57
	'TYMCHG'	;-56
	'DATUUO'	;-55
	'DDT620'	;-54
	'VALRMT'	;-53
	'INTRMT'	;-52
	'IDLRMT'	;-51
	'ZAPRMT'	;-50
	'CRERMT'	;-47
	'AUXRED'	;-46
	'ZAPCIR'	;-45
	'CREAUX'	;-44
	'REDPIP'	;-43
	'TINASS'	;-42
	'SETTR2'	;-41
	'SETTR1'	;-40
	'SETTIM'	;-37
	'INTASS'	;-36
	'INTACT'	;-35
	'INTENB'	;-34
	'INTADR'	;-33
	'HANG'		;-32
	'CHKLIC'	;-31
	'LEVDEF'	;-30
	'MOVBUF'	;-27
	'SETMOD'	;-26
	'RUNSEG'	;-25
	'SYSDVF'	;-24
	'DISMIS'	;-23
	'DSKCLR'	;-22
	'SETJAL'	;-21
	'ONEJOB'	;-20
	'SETMAL'	;-17
	'GETTMC'	;-16
	'SETTMC'	;-15
	'REDNXT'	;-14
	'WAITCH'	;-13
	'POKE'		;-12
	'SETPRV'	;-11
	'SETLIC'	;-10
	'SETE'		;-7
	'ATTACH'	;-6
	0		;-5
	0		;-4
	0		;-3
	0		;-2
	'LIGHTS'	;-1
CALLIS:	'RESET'	;0
	'DDTIN'	;1
	'SETDDT'	;2
	'DDTOUT'	;3
	'DEVCHR'	;4
	'DDTGT'	;5
	'GETCHR'	;6
	'DDTRL'	;7
	'WAIT'	;10
	'CORE'	;11
	'EXIT'	;12
	'UTPCLR'	;13
	'DATE'	;14
	'LOGIN'	;15
	'APRENB'	;16
	'LOGOUT'	;17
	'SWITCH'	;20
	'REASSI'	;21
	'TIMER'	;22
	'MSTIME'	;23
	'GETPPN'	;24
	'TRPSET'	;25
	'TRPJEN'	;26
	'RUNTIM'	;27
	'PJOB'	;30
	'SLEEP'	;31
	'SETPOV'	;32
	'PEEK'	;33
	'GETLIN'	;34
	'RUN'	;35
	'SETUWP'	;36
	'REMAP'	;37
	'GETSEG'	;40
	'GETTAB'	;41
	'SPY'	;42
	'SETNAM'	;43
	'TMPCOR'	;44
	'DSKCHR'	;45
	'SYSSTR'	;46
	'JOBSTR'	;47
	'STRUUO'	;50
	'SYSPHY'	;51
	'FRECHN'	;52
	'DEVTYP'	;53
	'DEVSTS'	;54
	'DEVPPN'	;55
	'SEEK'	;56
	'RTTRP'	;57
	'LOCK'	;60
	'JOBSTS'	;61
	'LOCATE'	;62
	'WHERE'	;63
	'DEVNAM'	;64
	'CTLJOB'	;65
	'GOBSTR'	;66
	0		;67
	0		;70
	'HPQ'	;71
	'HIBER'	;72
	'WAKE'	;73
	'CHGPPN'	;74
	'SETUUO'	;75
	'DEVGEN'	;76
	'OTHUSR'	;77
	'CHKACC'	;100
	'DEVSIZ'	;101
CALLIP:
POSCLI==CALLIP-CALLIS-1
NEGCLI==CALLIN-CALLIS>
IFE TYMSHR,<
OPUUO:	LSHC	PV,6
	TRZE	PV,40
	 MOVE	D2,TABUUO(PV)>
IONOT:
>;NOT STANFO
	JRST	OPWIN

IFN EXDSW,<
^^$IO:	IFN UESW!FILESW,<-1;>0	;IF ON, SHOULD PRINT IOTS (SEE BELOW)
OPIO:	MOVE	V,VSAV		;GET VALUE
	SKIPN	$IO		;ARE WE TO PRINT MACHINE IOTS
IFN STANFO,<JRST IONOT>		;NO, TRY UUO IOTS
IFE STANFO,<POPJ P,>
	LDB	PV,[POINT 3,V,12]	;GET REST OF I/O CODE
	MOVE	D2,TABIO(PV)	;GET OPCODE
	LDB	PV,[POINT 7,V,9]	;GET DEVICE #
	MOVEI	D3,IOTBLN	;GET TABLE LENGTH
IOLOP:	LDB	V,[POINT 7,IOTBL-1(D3),9];GET #
	CAIE	V,(PV)		;SAME?
IOLOP2:	 SOJG	D3,IOLOP	;NO, LOOP
	JUMPE	D3,OPIO2	;NOT FOUND?
	HRLI	PV,(D3)		;SAVE POTENTIAL CANDIDATE
	LDB	V,[410300,,IOTBL-1(D3)]	;SEE WHICH PROCESSOR
	CAME	V,$IO
	 JUMPN	V,IOLOP2	;WRONG ONE
OPIO1:	SKIPE	V,D3
	 MOVE	V,IOTBL-1(D3)	;GET NAME
	TLZ	V,777700
	TRO	F,CONOFF
	POPJ	P,

OPIO2:	SKIPL	$IO		;NEG MEANS ALWAYS PRINT AS I/O
	 JRST	IONOT		;TRY AS SYS CALL
	HLRZ	D3,PV
	JRST	OPIO1
>;END EXDSW
IFE EXDSW,<OPIO_IONOT>


;TABIO, TAB, TABOR

DEFINE TT (name,link,bits,chars)
<<SIXBIT /name/>+chars+.LEFT.(link,5)+.LEFT.(bits,3)>
;"name"	is text to match
;"link"	is next table (but... c better fit it)
;"bits"	is number of bits - 1 represented (2 bit field)
;"chars" is number of characters (3 bit field)

TABOR:
TT(OR,0,0,2)

TABIO:	FOR S IN (BLKI,DATAI,BLKO,DATAO,CONO,<CONI>
	,CONSZ,CONSO)
<'S'
>

TAB:
TT(CAI,2,2,3)
TT(CAM,2,2,3)
TT(JUMP,2,2,4)
TT(SKIP,2,2,4)
TT(AOJ,2,2,3)
TT(AOS,2,2,3)
TT(SOJ,2,2,3)
TT(SOS,2,2,3)

TT(A,0,0,0)		;2 (TAB+10)
TT(L,0,0,1)
TT(E,0,0,1)
TT(LE,0,0,2)
TT(A,0,0,1)
TT(GE,0,0,2)
TT(N,0,0,1)
TT(G,0,0,1)

TAB4:
TT(SETZ,0,0,4)		;4 (TAB+20)
TT(AND,0,0,3)
TT(ANDCA,0,0,5)
TT(SETM,0,0,4)
TT(ANDCM,0,0,5)
TT(SETA,0,0,4)
TT(XOR,0,0,3)
TT(IOR,0,0,3)
TT(ANDCB,0,0,5)
TT(EQV,0,0,3)
TT(SETCA,0,0,5)
TT(ORCA,0,0,4)
TT(SETCM,0,0,5)
TT(ORCM,0,0,4)
TT(ORCB,0,0,4)
TT(SETO,0,0,4)

TT(A,0,0,0)		;10 (TAB+40)
TT(I,0,0,1)
TT(M,0,0,1)
TT(B,0,0,1)

TT(A,0,0,0)		;11 (TAB+44)
TT(I,0,0,1)
TT(M,0,0,1)
TT(S,0,0,1)

TAB12:			;12 (TAB+50)
TT(HLL,13,1,3)
TT(HRL,13,1,3)
TT(HRR,13,1,3)
TT(HLR,13,1,3)

TT(A,11,1,0)		;13 (TAB+54)
TT(O,11,1,1)
TT(Z,11,1,1)
TT(E,11,1,1)

TAB14:			;14 (TAB+60)
TT(TR,15,1,2)
TT(TL,15,1,2)
TT(TD,15,1,2)
TT(TS,15,1,2)

TT(N,16,1,1)		;15 (TAB+64)
TT(Z,16,1,1)
TT(C,16,1,1)
TT(O,16,1,1)

TT(A,0,0,0)		;16 (TAB+70)
TT(A,0,0,1)
TT(E,0,0,1)
TT(N,0,0,1)

TAB17:			;17 (TAB+74)
TT(MOVE,11,1,4)
TT(MOVS,11,1,4)
TT(MOVN,11,1,4)
TT(MOVM,11,1,4)
TT(IMUL,10,1,4)
TT(MUL,10,1,3)
TT(IDIV,10,1,4)
TT(DIV,10,1,3)

TT(A,23,1,0)		;21 (TAB+104)
TT(A,24,1,0)
TT(A,25,1,0)
TT(A,26,1,0)

TT(P,27,1,1)		;22 (TAB+110)
TT(J,30,1,1)
TT(ADD,10,1,3)
TT(SUB,10,1,3)

TT(ASH,0,0,3)		;23 (TAB+114)
TT(ROT,0,0,3)
TT(LSH,0,0,3)
TT(JFFO,0,0,4)

TT(ASHC,0,0,4)		;24 (TAB+120)
TT(ROTC,0,0,4)
TT(LSHC,0,0,4)
0			;USED TO BE TT(FIX,0,0,3) ???

TT(EXCH,0,0,4)		;25 (TAB+124)
TT(BLT,0,0,3)
TT(AOBJP,0,0,5)
TT(AOBJN,0,0,5)

TT(JRST,0,0,4)		;26 (TAB+130)
TT(JFCL,0,0,4)
TT(XCT,0,0,3)
TT(MAP,0,0,3)

TT(USHJ,0,0,4)		;27 (TAB+134)
TT(USH,0,0,3)
TT(OP,0,0,2)
TT(OPJ,0,0,3)

TT(SR,0,0,2)		;30 (TAB+140)
TT(SP,0,0,2)
TT(SA,0,0,2)
TT(RA,0,0,2)

0			;31 (TAB+144)
0
0
0

0			;32 (TAB+150)
0
0
0


TAB33:			;33 (TAB+154)
0
TT(A,47,1,0)
TT(DF,42,1,2)
TT(D,50,1,1)
TT(A,43,1,0)		;34
TT(A,44,1,0)
TT(A,41,1,0)
TT(A,37,1,0)
TT(FAD,40,1,3)		;35
TT(FADR,10,1,4)
TT(FSB,40,1,3)
TT(FSBR,10,1,4)
TT(FMP,40,1,3)		;36
TT(FMPR,10,1,4)
TT(FDV,40,1,3)
TT(FDVR,10,1,4)

TT(ILDB,0,0,4)		;37
TT(LDB,0,0,3)
TT(IDPB,0,0,4)
TT(DPB,0,0,3)

TT(0,0,0,0)		;40 (TAB+200)
TT(L,0,0,1)
TT(M,0,0,1)
TT(B,0,0,1)

TT(UFA,0,0,3)		;41
TT(DFN,0,0,3)
TT(FSC,0,0,3)
TT(IBP,0,0,3)

TT(AD,0,0,2)		;42
TT(SB,0,0,2)
TT(MP,0,0,2)
TT(DV,0,0,2)

TT(DMOVE,0,0,5)		;43
TT(DMOVN,0,0,5)
TT(FIX,0,0,3)
TT(EXTE,51,3,4)		; (3 wraps around to 0)

TT(DMOV,45,3,4)		;44 (3 WRAPS AROUND TO 0)
TT(DMOV,46,3,4)		;YUCK
TT(FIXR,0,0,4)
TT(FLTR,0,0,4)

TT(EM,0,0,2)		;45
TT(EM,0,0,2)
TT(EM,0,0,2)
TT(EM,0,0,2)

TT(NM,0,0,2)		;46
TT(NM,0,0,2)
TT(NM,0,0,2)
TT(NM,0,0,2)

TT(JSYS,0,0,4)		;47
TT(ADJSP,0,0,5)
0
0

TT(ADD,0,0,3)		;50
TT(SUB,0,0,3)
TT(MUL,0,0,3)
TT(DIV,0,0,3)

TT(ND,0,0,2)		;51
TT(ND,0,0,2)
TT(ND,0,0,2)
TT(ND,0,0,2)

IFE STANFO,<
TABUUO:	FOR QQ IN ('CALL','INIT','AUXCAL','CHANIO','FRMOP',0,0,'CALLI','OPEN','TTYUUO')
<QQ
>

FOR I_52,54
<0
>

FOR QQ IN (RENAME,IN,OUT,SETSTS,STATO,<GETSTS>
  ,STATZ,INBUF,OUTBUF,INPUT,OUTPUT,CLOSE,<RELEAS>
  ,MTAPE,UGETF,USETI,USETO,LOOKUP,ENTER)
<'QQ'
>
>;NOT STANFO


;SRCH1, SRCH, FNDOP

;CALL WITH TABLE POINTER IN RIGHT HALF OF E, COUNT IN LEFT HALF.
;SEARCHES THE TABLE FOR AN OCCURENCE OF THE FIRST N CHARS OF V.
;LH(T) HAS INITIAL VALUE, RH(T) HAS VALUE TO SHIFT IT BY.
;SKIP RETURNS IF NOT FOUND
SRCH1:	HRRZM	T,LCNT
	HLRZM	T,VAL
	HLRZM	E,CNT1
BEGIN SRCH
^SRCH:	MOVSI	M,E
LOOP1:	MOVE	D3,@M		;GET ENTRY
	LDB	T,[POINT 3,D3,35]	;GET # OF CHARACTERS
	IMULI	T,6
	LSHC	D2,(T)
	LSHC	PV,(T)		;GET CHRS
	MOVNS	T
	CAMN	D2,PV		;SAME?
	 JRST	SAM2		;YES
LOOP2:	LSHC	D2,(T)
	LSHC	PV,(T)		;PUT BACK, NOT SAME
	SOSLE	CNT1		;NOT SAME, TRY NEXT. DONE WITH THIS TABLE?
	 AOJA	M,LOOP1		;NO, TRY NEXT
	AOS	(P)		;SKIP RETURN, NOT FOUND
	POPJ	P,

SAM2:	PUSH	P,M		;SAVE...
	PUSH	P,E
	PUSH	P,T
	LSH	D3,-3(T)	;READJUST
	MOVE	T,VAL		;GET VALUE SO FAR
	LSH	T,@LCNT		;SHIFT
	IORI	T,(M)		;OR IN ADDITIONAL VALUE
	PUSH	P,VAL		;SAVE...
	PUSH	P,LCNT
	PUSH	P,CNT1
	MOVEM	T,VAL		;STORE VALUE
	LDB	T,[POINT 2,D3,35]	;GET # OF BITS
	ADDI	T,1
	ANDI	T,3
	ANDI	D3,774		;GET TABLE NUMBER
	SKIPN	E,D3		;TABLE # ZERO?
	 JRST	ADON		;YES, ALL DONE
	ADDI	E,TAB
	MOVEM	T,LCNT		;SAVE # OF BITS (SHIFT COUNT)
	MOVEI	D3,1
	LSH	D3,(T)		;FORM TABLE LENGTH
	MOVEM	D3,CNT1		;STORE
	PUSHJ	P,SRCH		;TRY NEXT TABLE
	 JRST	ADON		;DONE?
ARET:	POP	P,CNT1		;NOT DONE, RESTORE EVERYTHING
	POP	P,LCNT
	POP	P,VAL
	POP	P,T
	POP	P,E
	POP	P,M
	JRST	LOOP2		;TRY SOME MORE

ADON:	JUMPN	V,ARET		;ANY LEFT?
	SUB	P,[6,,6]	;THROW AWAY SAVED STUFF
	POPJ	P,		;LEAVE
BEND SRCH
CNT1:	0
LCNT:	0
VAL:	0

^FNDOP:	PUSH	P,D3
	PUSH	P,PV
	MOVEI	D2,0
	MOVE	V,SIXSYM	;GET SYMBOL
BEGIN FNDOP
	MOVEI	PV,0
	LSHC	PV,6		;GET FIRST CHR.
	CAIN	PV,'H'		;IS IT H?
	 JRST	ITH		;YES
	CAIN	PV,'T'		;IS IT T?
	 JRST	ITT		;YES
	LSHC	PV,-6
	PUSHJ	P,SOTH
SUUOQ:	PUSHJ	P,SUUO
	POP	P,PV
	POP	P,D3
	POPJ	P,

ITH:	LSHC	PV,-6		;READJUST
	PUSHJ	P,SHCH
	JRST	SUUOQ
ITT:	LSHC	PV,-6
	PUSHJ	P,STTZ
	JRST	SUUOQ

SOTH:	MOVEI	T,TAB4		;FIRST TRY BOOLEAN INSTRUCTIONS
	MOVEI	M,20
LOOP3:	MOVE	D3,(T)		;GET TABLE ENTRY
LOOP3A:	LDB	E,[POINT 3,D3,35]	;GET # OF CHRS
	IMULI	E,6
	LSHC	D2,(E)
	LSHC	PV,(E)
	MOVNS	E
	CAMN	PV,D2 		;SAME?
	JRST	SAM3		;YES, FIND MODE (COME BACK IF TWO OR MORE LEFT)
NOSM3:	LSHC	PV,(E)
	LSHC	D2,(E)
	ADDI	T,1		;NO, TRY AGAIN
	SOJG	M,LOOP3
	JUMPL	M,PNTQ
	MOVE	D3,TABOR
	MOVEI	T,TAB4+7	;ENTRY FOR "IOR"
	JRST	LOOP3A

PNTQ:	MOVE	T,[2,,4]	;NOT HERE, TRY THE 2 GROUP
	MOVE	E,[20,,TAB17]
	PUSHJ	P,SRCH1		;SEARCH THE TABLE
	 JRST	ADONE		;SAME
	MOVE	T,[3,,3]	;NO MATCH, TRY THE 3 GROUP
	MOVE	E,[10,,TAB]
	PUSHJ	P,SRCH1
	 JRST	ADONE		;MATCH
	MOVE	T,[1,,4]	;NO MATCH, TRY THE 1 GROUP
	MOVE	E,[20,,TAB33]
	PUSHJ	P,SRCH1
	 JRST	ADONE		;MATCH
	MOVEI	E,0		;NO, TRY I/O
	MOVEI	T,10
	JSR [	RTJS:	0
			MOVE PV,V
		LPL:	TRNE PV,77
			JRST @RTJS
			LSH PV,-6
			JRST LPL	]
;FALLS THROUGH


;SUUO
;FALLS THROUGH FROM PREVIOUS PAGE
LOOP4:	CAMN	PV,TABIO(E)	;MATCH?
	 JRST	IMAT		;YES
	ADDI	E,1
	SOJG	T,LOOP4		;NO
	POPJ	P,		;NO MATCH ANYWHERE

IMAT:	ADDI	E,16000		;FORM OPCODE
	LSH	E,27		;ADJUST
	TRO	F,CONOF		;SET FLAG
RET:	MOVEM	E,NM		;DEPOSIT
	POP	P,E		;THROW AWAY RETURN
	POP	P,PV		;RESTORE
	POP	P,D3
	POP	P,E		;THROW AWAY RETURN
	TLO	F,NUMF!SYMF!SCFL	;SET FLAGS
	POPJ P,

;ADONE1: MOVEI E,30
;	ADDM E,VAL
ADONE:	MOVE	E,VAL		;GET VALUE
	LSH	E,33		;ADJUST
	JRST	RET

SAM3:	TLNE	V,7700		;IF MORE THAN ONE
	 JRST	NOSM3		; LETTER LEFT TO SATISFY, LOOK SOME MORE
	SUBI	T,TAB4-100	;ADJUST VALUE
	MOVSS	T
	HRRI	T,2		;2 BITS NEXT
	PUSH	P,E
	MOVE	E,[4,,TAB+40]
	PUSHJ	P,SRCH1
	 JRST	ADONE2		;MATCH
	POP	P,E
	LSHC	PV,(E)		;READJUST
	MOVEI	D2,0
	JRST	PNTQ

ADONE2:	POP	P,E
	JRST	ADONE

STTZ:	MOVE	D2,PV
	MOVE	T,[6,,2]	;TRY THE 6 GROUP (T)
	MOVE	E,[4,,TAB14]
	PUSHJ	P,SRCH1
	 JRST	SDONE		;MATCH
	POPJ	P,		;NO MATCH

SDONE:	MOVE	E,VAL
FOR @$ I IN  (5,21,50)
<REPEAT 3,<TRCE E,I>
>
	JRST	ADONE+1
SHCH:	MOVE	D2,PV
	MOVE	T,[5,,2]	;TRY THE 5 GROUP
	MOVE	E,[4,,TAB12]
	PUSHJ	P,SRCH1
	JRST	.+2
	POPJ	P,
	MOVE	E,VAL
	TRCE	E,24
	 TRCE	E,24
	  TRCE	E,24
	JRST	ADONE+1
IFN	STANFO,<
SUUO:	TLNN	V,77
	POPJ	P,		;DOESN'T LOOK LIKE A SYSTEM CALL
	MOVE	E,V
	CALLIT	E,		;SEE IF SYSTEM KNOWS ABOUT IT
	JUMPN	E,RET		;AHA! GOT VALUE FROM SYSTEM
	POPJ	P,		;NO LUCK NOHOW
>;STANFO
IFE STANFO,<
SUUO:	MOVEI	E,
	MOVEI	T,40
	JSR	RTJS
SLOP1:	CAMN	PV,TABUUO(E)	;SAME
	JRST	SDONN		;YES
	ADDI	E,1
	SOJG	T,SLOP1		;DONE?


IFN TYMSHR,<
	MOVSI	E,-20
	CAMN	PV,TTCALS(E)
	 JRST	TTCLTN
	AOBJN	E,.-2
	MOVSI	E,CALLIN-CALLIP
	CAMN	PV,CALLIN(E)
	 JRST	CLIDON
	AOBJN	E,.-2
	POPJ	P,	;CAN NOT FIND IT

TTCLTN:	LSH	E,=23
	TLO	E,(<TTYUUO>)
	JRST	RET

CLIDON:	SUBI	E,CALLIS-CALLIN
	HRLI	E,(<CALLI>)
	JRST	RET
>
IFE TYMSHR,<	
	POPJ	P,		;YUP, NO LUCK>
SDONN:	ADDI	E,40
	JRST	ADONE+1
>;NOT STANFO
BEND FNDOP
^FNDOP__FNDOP

BEND OPLOOK
^FNDOP__FNDOP


IFE SORTED,<	;STANDARD SYMBOL TABLE (UNSORTED) ROUTINES (ENDS ON PAGE 46)
BEGIN FNDSYM

RDF(MNBLK,1)
RDF(CNTF,2)

;  Fndsym -- The VAL to SYM Symbol Table Searcher.
;
; VALUE IN V

; RETURNS IN
;  DNSYM, DNDIF, DNCUR THE SYMBOL NAME, VALUE, AND BLOCK NAME
;    (-1 IF SHOULD NOT BE TYPED) OF THE SYMBOL WHOSE VALUE IS
;    EQUAL TO OR LEAST LESS THAN THE VALUE IN V.
;  UPSYM, UPDIF, UPCOR THE CORRESPODING THINGS FOR THE SYMBOL
;    WHOSE VALUE IS LEAST GREATER THAN THE VALUE IN V.

^FNDSYM:
	MOVEI	PV,NUMCSH-1	;FIRST SEARCH FOR RECENT FINDS
FNDL1:	CAME	V,VALCSH(PV)	;IS VALUE EQ THIS VALUE?
	 SOJGE	PV,FNDL1	;NO, CONTINUE
	JUMPL	PV,FNDS1	;WE FAILED
QUICFD:	SETZM	DNDIF		;EXACT MATCHES ONLY
	MOVEI	E,DNSYM-1	;NOW SAVE SYMBOL NAMES AND BLOCK NAMES
	PUSH	E,VALSYM(PV)	;LOWER SYMBOL NAME
	PUSH	E,VALBLK(PV)	;LOWER BLOCK NAME
	JRST	BDON		;ALL DONE

FNDS1:	MOVEI	E,SYMPRG	;INITIALIZE
	HRRM	E,PNT1
	MOVE	E,[400000,,1]
	MOVEM	E,UPDIF	;INITIALIZE DIFERENCES
	HRLOI	E,377777
	MOVEM	E,DNDIF
	SETZM	UPSYM
	SETZM	DNSYM
	SETOM	WRPSW
	SETOM	UPCUR
	SETOM	DNCUR
	TRNN	F,CNVABS	;USE ABS VAL?
	 SKIPGE	PV,SYMPNT	;GET SYMBOL POINTER
	  POPJ	P,	;NONE
	MOVE	E,1(PV)	;GET BLOCK LEVEL
	MOVEM	E,BLKLV	;SAVE
	TB	O,F,MNBLK
	TB	Z,F,CNTF
LOP2:	MOVSI	M,400000	;INITIAL CODE BIT MASK
LOP1:	SUB	PV,[2,,2]	;GO TO NEXT
	JUMPL	PV,ATTOP	;AT TOP (BOTTOM?) OF TABLE?
PNT1:	;CAMN	PV,SYMPRG	;BACK TO START?
	CAMN	PV,SYMPNT	;BACK TO REAL START?
	 JRST	DON	;YES
	TDNE	M,(PV)	;MASK BIT ON?
	 JRST	LOP1	;YES
	LDB	E,[POINT 4,(PV),3];GET CODE BITS
	CAIN	E,3	;BLOCK NAME?
	 JRST	BLKCHK	;YES
	JUMPE	E,PRGCHK	;PROGRAM NAME?
	MOVE	E,V	;GET VALUE
	SUB	E,1(PV)	;GET DIFFERENCE
	JUMPGE	E,PNT2	;FOUND ONE SMALLER?
	CAMGE	E,UPDIF	;NO, COMPARE FOR BETTER MATCH
	 JRST	LOP1	;NOT BETTER
	CAME	E,UPDIF	;EQUAL MATCH?
	 JRST	.+4
	TB	NE,F,MNBLK,	;IN MAIN BLOCK?
	SKIPN	UPCUR	;OTHER IN MAIN BLOCK?
	 JRST	LOP1	;NO, YES
	MOVEM	E,UPDIF	;DEPOSIT NEW DIF.
	MOVE	E,1(PV)	;ACTUAL VALUE
	MOVEM	E,UPADR	;SAVE FOR QUICK-FIND CACHE STORAGE
	MOVE	E,(PV)	;GET SYMBOL NAME
	MOVEM	E,UPSYM	;SAVE
	SETZM	UPCUR
	TB	NE,F,MNBLK,	;IN THE MAIN BLOCK?
	JRST	LOP1	;YES
LOP3:	MOVE	E,CURBL	;NO, GET BLOCK NAME
	MOVEM	E,UPCUR	;SAVE
	JRST	LOP1
PNT2:	JUMPE	E,PNT3	;EXACT MATCH
	CAMLE	E,DNDIF	;COMPARE FOR BETTER MATCH
	 JRST	LOP1	;NO
	CAME	E,DNDIF	;EQUAL MATCH?
	 JRST	.+4
	TB	NE,F,MNBLK,	;IN MAIN BLOCK?
	SKIPN	DNCUR	;OTHER IN MAIN BLOCK?
	 JRST	LOP1	;NO, YES
	MOVEM	E,DNDIF	;DEPOSIT NEW DIF
	MOVE	E,1(PV)	;SAVE ACTUAL VALUE FOR
	MOVEM	E,DNADR	; QUICK-FIND CACHE STORAGE
	MOVE	E,(PV)	;GET SYMBOL NAME
	MOVEM	E,DNSYM	;SAVE
	SETZM	DNCUR
	TB	NE,F,MNBLK,	;IN THE MAIN BLOCK?
	JRST	LOP1	;YES
	MOVE	E,CURBL	;NO, GET BLOCK NAME
	MOVEM	E,DNCUR	;SAVE
	JRST	LOP1
PNT3:	SETZM	UPDIF
	MOVE	E,(PV)	;GET NAME
	MOVEM	E,UPSYM	;SAVE
	SETZM	UPCUR
	TB	NE,F,MNBLK,	;IN THE MAIN BLOCK?
	JRST	ADON	;YES
	JRST	LOP3	;YES


BLKCHK:	MOVE	E,1(PV)	;GET VLOCK LEVEL
	TB	O,F,MNBLK
	CAMGE	E,BLKLV	;COMPARE WITH CURRENT
	JRST	[MOVEM	E,BLKLV  ;THESE O.K.
		JRST	LOP1]
	TB	Z,F,MNBLK,	;CLEAR FLAG
	MOVE	E,(PV)	;GET BLOCK NAME
	MOVEM	E,CURBL	;SAVE
	JRST	LOP1
PRGCHK:	TLO	M,100000	;LOOK ONLY FOR GLOBALS
	JRST	LOP1
ATTOP:	
	SKIPLE	WRPSW
	 JRST	ADON
	EXCH	PV,V	;HOLD VALUE
			;NOW V HAS THE SYMBOL TABLE POINTER FOR WRAPQ.
	PUSHJ	P,WRAPQ	;GO TO BOTTOM (TOP?) OF TABLE
	EXCH	PV,V	;RESTORE VALUE
	JRST	PNT1
DON:	TB	OE,F,CNTF,	;ALL DONE?
	JRST	ADON	;YES
	CAMN	PV,SYMPNT	;NO BLOCKS?
	JRST	ADON	;YES
	MOVEI	E,SYMPNT	;LOOK FOR SSTARTING POINT
	HRRM	E,PNT1
	SETZM	BLKLV
	SETZM	WRPSW	;HO	HO......
	JRST	LOP2
ADON:	SKIPN	DNSYM		;EXACT	MATCH?
	 SKIPE	DNDIF		;EXACT	MATCH?
	  JRST	BDON		; NO, DON'T STORE IN CACHE
	SOSGE	PV,NCSHPT	;UPDATE MOST RECENT POINTER
	 MOVEI	PV,NUMCSH-1	;WRAPAROUND
	MOVEM	PV,NCSHPT
	HRROI	E,DNADR		;NOW STORE NEWLY FOUND VALUES IN CACHE
	POP	E,VALCSH(PV)	;LOWER VALUE
	POP	E,VALBLK(PV)	;LOWER BLOCK NAME
	POP	E,VALSYM(PV)	;LOWER DITTO
BDON:	TB	Z,F,CNTF
	TB	Z,F,MNBLK
	POPJ	P,
BEND FNDSYM
?WRPSW:	0
^WRPSW_WRPSW
DNSYM: 0
DNCUR: 0
DNADR: 0
UPSYM: 0
UPCUR: 0
UPADR: 0
UPDIF: 0
DNDIF:0
CURBL:0
VSAV:0
BEND SUBS


;Symlok -- Symbol to Value Searcher -- Wrap, Csflush, Cpopj

; HERE IS THE SYM to VALUE SYMBOL TABLE SEARCHER
; RADIX50 FOR SYMBOL IN `SYM', SKIPS AND CONTAINS pointer to SYMBOL
;   ENTRY IN SPNT AND V IF FINDS IT, ELSE NO SKIP

^SYMLOK: MOVEI	V,NUMCSH-1	;FIRST SEARCH THE RECENT CACHE
	MOVE	E,SYM
	CAME	E,SYMCSH(V)	;HAVE WE SEEN IT RECENTLY?
	 SOJGE	V,.-1		; NOT YET
	JUMPL	V,SYMLK1	;QUICK SEARCH FAILED
	MOVE	V,SYMVAL(V)	;GET POINTER TO SYMTAB FOR THIS SYM
	JRST	LOP77		;RETURN FAST FAST FAST

SYMLK1:
	SKIPGE	V,SYMPNT	;GET SYMBOL TABLE POINTER
	 JRST	NONE	;NO SYMBOLS
	MOVE	E,1(V)	;GET BLOCK LEVEL
	MOVEM	E,BLKLV	;SAVE BLOCK LEVEL
	MOVSI	M,200000	;INITIAL CODE BIT MASK
	HLRE	T,JOBSYM	;GET COUNT
	ASH	T,-1	;ADJUST
LOP4:	SUB	V,[2(2)]	;GO TO NEXT
	AOJGE	T,NONE	;DONE?
	JUMPGE	V,.+2	;AT TOP (BOTTOM?) OF TABLE?
	PUSHJ	P,WRAPQ	;YES
LOP5:	TDNE	M,(V)	;MASK BITS ON?
	 JRST	LOP4	;YES, IGNORE SYMBOL
	LDB	E,[POINT 4,(V),3];GET CODE BITS
	CAIN	E,3	;BLOCK NAME?
	 JRST	BLKCHK	;YES
	JUMPE	E,PRGCHK	;PROGRAM NAME?
	LDB	E,[POINT 32,(V),35];GET SYMBOL
	CAME	E,SYM	;SAME?
	 JRST	LOP4	;NO
LOP7:	SOSGE	E,SCSHPT	;GET NEXT FREE MOD SIZE OF CACHE
	 MOVEI	E,NUMCSH-1	;WRAP-AROUND
	MOVEM	E,SCSHPT
	MOVE	M,SYM		;SYMBOL NAME (NO BITS)
	MOVEM	M,SYMCSH(E)	;SAVE NAME FOR QUICK SEARCH
	MOVEM	V,SYMVAL(E)	;SAVE SYMBOL POINTER

LOP77:	MOVE	E,1(V)		;GET VALUE
SYMDOT:	MOVEM	E,NM		;STORE
	MOVEM	V,SYMP		;SAVE POINTER
	TLO	F,NUMF!SYMF!SCFL	;SET FLAGS
ITCHK:	CAIN	C,"."		;IS AHEAD CHAR <ctrl1>.	?
	 CAIE	B,1
	  POPJ	P,		; NO
	TLZ	F,SCFL		;NOT AHEAD ANY MORE
	SETZM	SAVMOD		;DON'T USE ANY INPUT-DRIVEN MODE
	JSR	FNDSCR		;ON SCREEN?
	 JRST	[HLRZ	M,(M)
		TLZ	M,400037 	;CLEAR NON-MODE BITS
		LSH	M,-5	;IN SAVMOD FORMAT
		TLNN	F1,FIRF 	;FIRST THING?
		 HRRM	M,SAVMOD 	;YES, USE THIS MODE
		JRST	.+1  ]
	JRST	ITD1		;USE CONTENTS OF THAT CELL
	POPJ	P,

; FLUSH ALL CACHES, SOMETHING DRASTIC HAS CHANGED

^CSFLUSH:
	SETOM	SYMCSH		;SET TO RIDICULOUS VALUE
	MOVE	E,[XWD SYMCSH,SYMCSH+1]
	BLT	E,CSHEND	;CLEAR ALL TO -1
	POPJ	P,

^WRAPQ:   ^WRAP:
ORDWRP:	HLRE	E,JOBSYM	;GET SYMBOL TABLE LENGTH
	MOVNS	E	;PUT IN POSITIVE FORM
	MOVEI	V,-2(E)	;REDUCE BY 2
	ADD	V,JOBSYM	;FIND END OF TABLE
WRPDON:	HRL	V,E	;PUT POSITIVE COUNT IN LEFT
	AOS	WRPSW
	POPJ	P,


PRGCHK:	TLO	M,100000	;LOOK ONLY FOR GLOBALS
	 JRST	LOP4
BLKCHK:	MOVE	E,1(V)	;GET BLOCK LEVEL
	CAMGE	E,BLKLV	;COMPARE WITH CURRENT LEVEL
	 JRST	[MOVEM	E,BLKLV		;THESE SYMBOLS O.K.
		JRST	LOP4 ]
LOP6A:	MOVSI	E,40000	;MASK BIT
LOP6:	SUB	V,[2(2)]	;GO TO NEXT
	AOJGE	T,NONE	;DONE?
	JUMPGE	V,.+2	;AT TOP?
	PUSHJ	P,WRAPQ	;YES
	TDNN	E,(V)	;GLOBAL OR BLOCK?
	 JRST	LOP6	;NO
	LDB	E,[POINT 4,(V),3];GET CODE BITS
	CAIN	E,3	;BLOCK NAME?
	 JRST	BLKCHK	;YES
	LDB	E,[POINT 32,(V),35]	;GET SYMBOL NAME
	CAME	E,SYM	;SAME?
	 JRST	LOP6A	;NO
	JRST	LOP7	;YES
NONE:
IFN EXDSW,<PUSHJ P,IOFNDI>	;FIND AS I/O DEV. NAME
	TLOA	F,SYMF!SCFL!UNDF	;NOT FOUND
	TLO	F,NUMF!SYMF!SCFL	;FOUND
^CPOPJ:	POPJ	P,


;Prgfnd, Prgset, Blkfnd, Blkfn

^PRGFND:PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES
	TLNN	F1,SINGF	;SINGLE SYMBOL?
	 JRST	CERR	;NO
	MOVEI	T,0	;HUNT FOR PROGRAM NAME
	SETZM	WRPSW
	PUSHJ	P,WRAP	;GET START
	PUSHJ	P,PGFND	;FIND
	 JRST	PU	;COULDN'T
	MOVEM	V,SYMPNT	;SAVE POINTER
	MOVEM	V,SYMPRG	;  "    "
	MOVE	T,(V)
	MOVEM	T,PRGSAV#
	MOVEI	T,3	;LOOK FOR BLOCK
	PUSHJ	P,PBCON
	 JRST	INSBLK	;INSERT IN REF LIST
	MOVEM	V,SYMPNT
	JRST	INSBLK

; PROGRAM NAMES ARE LINKED TOGETHER (USUALLY) VIA NEGATIVE DISTANCES
; IN LEFT HALF OF VALUE WORD -- FIND RIGHT PROGRAM REAL FAST

PGFND:	MOVE	E,(V)	;GET SYMBOL NAME AT THIS LOC (GUARANTEED PROG NAME)
	MOVEI	T,0		;IN CASE HAVE TO CALL PBCON FOR PROG NAME
	CAMN	E,SYM	; (TYPE BITS 0, CAM OK)		;ALL DCS
	 JRST	OKPOPJ	; THIS IS IT
	HLRE	E,1(V)	;GET NEG DISTANCE TO NEXT
	JUMPE	E,PBCON ;END OF LINKS, MAYBE NOT LINKED
	MOVNS	E	;GET POS VALUE
	HRLS	E	;USE ON BOTH HALVES
	SUB	V,E	; pointer to NEXT
	JRST	PGFND

PBFND:	LDB	E,[POINT 4,(V),3];GET CODE BITS
	CAMN	E,T	;SAME?
	 JRST	SAM1	;YES
	JUMPE	E,CPOPJ	;PRG NAME?
PBCON:	SUB	V,[2,,2]	;GO TO NEXT
	JUMPGE	V,PBFND	;LOOP IF MORE TO GO
	POPJ	P,	;NOT FOUND
SAM1:	LDB	E,[POINT 32,(V),35];GET SYMBOL
	CAME	E,SYM	;SAME?
	 JRST	PBCON	;NO, PROCEED
OKPOPJ:	AOS	(P)	;FOUND WHAT WERE LOOKING FOR
	POPJ	P,
^PRGSET:
IFE UESW,<
	HLRO	V,JOBSYM
	MOVN	V,V
	ADD	V,JOBSYM	;PROG CHAIN STARTS AT SYMTAB END
ONCE1:	MOVE	E,-2(V)
	CAME	E,[RADIX50 0,RAID]	;THESE ARE USUALLY BAD CHOICES
	 CAMN	E,[RADIX50 0,JOBDAT]
	  JRST	ONCE2
	HLRZ	B,-1(V)
	JUMPE	B,ONCE4
	CAIL	B,-6
	 JRST	ONCE4		;NOT MANY SYMS - TRY DIFFFERENT PROG
ONCE3:	MOVEM	E,SYM
	JRST	PRGFND		;FIND AND DISPLAY THIS ONE
ONCE4:	JUMPN	C,ONCE2
	MOVE	C,E		;REMEMBER IT THE FIRST TIME
ONCE2:	HLRE	E,-1(V)
	ADD	V,E
	JUMPL	E,ONCE1	;KEEP LOOKING
	SKIPN	E,C
IFN REALSW,<	MOVE E,[RADIX50 0,RAID]	;NO MORE - HAVE TO SETTLE FOR RAID>
IFE REALSW,<	MOVE E,[RADIX50 0,TRAID]>
	JRST	ONCE3
;>	POPJ	P,

^BLKFN:	PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES
	PUSHJ	P,BLKFND

; INSERT PROG/BLOCK PAIR IN BUFFER FOR QUICK REFERENCE (CTRL-Z)

INSBLK:	MOVEI	T,NUMREF	;SEARCH FIRST, MAKE SURE IT'S NOT THERE ALREADY
	MOVE	E,SYMPNT	;CURRENT BLOCK POINTER
	CAME	E,BLKREF(T)	;IS IT?
	 SOJGE	 T,.-1		; NOT YET
	JUMPGE	T,SETGET	;WAS THERE, GO REFRESH
	SOSGE	T,REFPNT	;GET NEXT FREE POINTER
	MOVEI	T,NUMREF-1	;WRAPAROUND
	MOVEM	T,REFPNT
	HRROI	E,SYMPNT	;SAVE PROG POINTER, BLOCK POINTER
	POP	E,BLKREF(T)
	POP	E,PRGREF(T)
SETGET:	MOVEM	T,REFGET	;TAKER POINTER
	POPJ	P,		;GO REFRESH, RETURN


^BLKFND:TLNN	F1,SINGF	;SINGLE SYMBOL?
	 JRST	CERR	;NO
	MOVEI	T,3	;HUNT FOR BLOCK NAME
	MOVE	V,SYMPRG	;GET POINTER
	PUSHJ	P,PBCON	;FIND
	 JRST	PU
	MOVEM	V,SYMPNT	;SAVE POINTER
	MOVE	T,(V)
	MOVEM	T,BLKSAV#
	POPJ	P,
>;NOT SORTED (BEGAN ON PAGE 43 NEAR THE BEGINNING OF THE BLOCK FNDSYM)


IFN SORTED,< ;(ENDS ON PAGE 55)	SETSYM
; Setsym -- Initialize (reset) Symbol Table Variables (SORTED BEGINS HERE)

BEGIN SETSYM
^SETSYM:SETOM	DDSW		;FORCE COMPLETE DEVICE RE-EVALUATION
IFN STANFO,<
	MOVE	A,JOBSYM
	HLRE	A,(A)
	AOJE	A,SETSY1	;IF LH OF FIRST WORD OF SYMTAB IS -1
>
IFE STANFO,<
	MOVS	A,JOBSYM
	CAIE	A,-1	>
	 PUSHJ	P,SORT			;WE HAVE DONE THE SORT ALREADY
SETSY1:	MOVE	E,JOBSYM		;-SIZE,,LOC
	MOVEM	E,SAVJSM		;IF DIFFERENT NEXT TIME, CALL AGAIN
	HRRZM	E,SYMBAS		;FOR RELOCATING OTHER POINTERS
	HRRE	A,(E)
	AOJN	A,.+2
	HLLZS	(E)			;SET RH OF FIRST WORD TO ZERO IF WAS -1
	HRRZ	V,5(E)			;RELATIVE ADDRESS OF FIRST BLOCK OF SYMBOLS
	HRRZ	A,11(E)			;RELATIVE ADDRESS OF WORD AFTER LAST SYMBOL
	SUBM	V,A			;A GETS -NUMBER OF WORDS OF SYMBOLS
	ADD	V,E			;ABSOLUTE ADDRESS OF FIRST WORD OF SYMBOLS
	HRL	V,A
	MOVEM	V,SYMRNG	;-SIZE,,pointer to FIRST FOR ACTUAL SYMBOLS
	MOVEI	V,5(E)
	HRLI	V,A			;ABSOLUTE ADDRESS OF RELATIVE POINTERS
	MOVEM	V,RNGBAS		; TO THE SYMBOLS
	ADDI	V,1
	MOVEM	V,RNGBS1		; RANGE TABLE+1(A)
	HRRZ	V,2(E)		;pointer to BLKVAL
	ADD	V,E			;   TABLE
	HRLI	V,E			; BLKVAL(E)
	MOVEM	V,BLKVAL
	HRLI	V,M
	MOVEM	V,BLKVL1		; BLKVAL(M)
	HRRZ	V,1(E)			; REPEAT FOR NAMES
	ADD	V,E
	HRLI	V,D2
	MOVEM	V,BLKNM2
	HRLI	V,E
	MOVEM	V,BLKNAM
	SUB	V,BLKVAL
	MOVMM	V,BLKSIZ		; SIZE OF BLOCK STRUCTURE TABLES
^FREPOPJ:TRO	F,DPYALL
NOPROG:	POPJ	P,
BEND SETSYM
^SETSYM_SETSYM
^FREPOPJ_FREPOPJ


; Fndsym -- The VAL to SYM Symbol Table Searcher.
;
; VALUE IN V

; RETURNS IN
;  DNSYM, DNDIF, DNCUR THE SYMBOL NAME, VALUE, AND BLOCK NAME
;    (-1 IF SHOULD NOT BE TYPED) OF THE SYMBOL WHOSE VALUE IS
;    EQUAL TO OR LEAST LESS THAN THE VALUE IN V.
;  UPSYM, UPDIF, UPCUR THE CORRESPODING THINGS FOR THE SYMBOL
;    WHOSE VALUE IS LEAST GREATER THAN THE VALUE IN V.

BEGIN FNDSYM
;initialize the search
^^FNDSYM:
	SKIPGE	PID	;Don't bother if there are no symbols
	 POPJ	P,
	PUSHJ	P,GETRNG		;Assign range to A.  Swap V if class 3
	JRST @(A)[FSYM			;Class 1 -- search low-seg addrs only
		FSYM			;      2 -- high-seg addrs only
		QOPCOD			;      3 -- better of "op code", "full srch"
		BIGNUM]			;      4 -- better of "full", "op" srch

QOPCOD:	PUSHJ	P,FSYM		;Classes 3 and 4 cover the same range,
	MOVMS	UPDIF
	TRNN	F,CNVABS	; really, tho class 3 only has those
	 SKIPN	UPDIF		; symbols whose values have RH = 0
	  POPJ	P,		;Don't bother 2d try if Abs mode, just 
	PUSHJ	P,[SVVAL:
		MOVE	E,[DNSYM,,ODNSYM]
		BLT	E,ODNDIF; called FSYM to set up UPDIF, DNDIF, etc.
		POPJ	P,]	;This symbol has 18 low-order zeroes, so
	HLRZS	V	;undo what getrng did	; first try class 3, then if no exact
	MOVEI	A,3		; match, try class 4. Choose the best
	PUSHJ	P,FSYM		; difference, using some reasonable
	MOVMS	UPDIF
	MOVEI	E,1000
	CAMLE	E,ODNDIF	;SKIP IF DIFFERENCE IS RIDICULOUSLY BIG
	 MOVSS	ODNDIF
	CAMLE	E,OUPDIF
	 MOVSS	OUPDIF
	JRST	DCIDE		; algorithm.

BIGNUM:	PUSHJ	P,FSYM		;Here the value has some low order 1's
	MOVMS	UPDIF
	SKIPN	UPDIF		; in the low 18 bits.   So first try the
	 POPJ	P,		; class 4 symbols, then if there is no
	PUSHJ	P,SVVAL		; exact match, zap the low 18, search
	PUSH	P,V		; class 3 for that, then create the
	HLRZ	V,V		; actual differences by re-including the
	MOVEI	A,2		; low-order 1's.  Finally, again, decide
	PUSHJ	P,FSYM		; which set of results gives the best
	MOVMS	UPDIF
	POP	P,V		; answer.
	HRRZ	V,V
	MOVEI	E,1000
	CAMLE	E,DNDIF		;SKIP IF DIFFERENCE IS RIDICULOUSLY BIG
	 JRST [	MOVSS	DNDIF
		HRRM	V,DNDIF
		JRST	.+1]
	CAMLE	E,UPDIF
	 JRST [	SKIPN	UPDIF
		 JRST	BIGNU1
		MOVSS	UPDIF
		SUB	V,UPDIF
		MOVNM	V,UPDIF
		JRST	.+1]
DCIDE:	MOVE	E,ODNDIF	;Here, just choose the set of results
	CAME	E,DNDIF		; which seem to give the best results.
	 JRST	DCIDE1		;ONE OF THEM IS BETTER
	MOVE	E,OUPDIF
	CAML	E,UPDIF
	 POPJ	P,			;NEW IS AS GOOD OR BETTER
FRST:	MOVE	E,[ODNSYM,,DNSYM]	;OLD ONE IS BETTER
	BLT	E,DNDIF
	POPJ	P,

DCIDE1:	MOVE	V,OUPDIF
	CAME	V,UPDIF
	 JRST	DCIDE2			;ONE OF THESE IS BETTER TOO
	MOVE	V,ODNDIF
	CAML	V,DNDIF
	 POPJ	P,			;NEW ONE IS AS GOOD OR BETTER
	JRST	FRST			;OLD ONE IS BETTER

DCIDE2:	CAML	E,DNDIF
	 CAMG	V,UPDIF
	  JRST	.+2
	  POPJ	P,		;NEW ONE IS BETTER ON BOTH COUNTS
	CAMG	E,DNDIF
	 CAML	V,UPDIF
	  JRST	.+2
	  JRST	FRST
	MOVEI	A,0
	CAML	E,DNDIF
	 AOJA	A,[MOVE	E,DNDIF
		   JRST	.+1]
	CAML	E,@(A)[UPDIF
			OUPDIF]
	JRST	DCIDE3
	JUMPE	A,FRST
	POPJ	P,
DCIDE3:	JUMPN	A,FRST
	POPJ	P,

BIGNU1:	HRLOI	E,377777
	MOVEM	E,UPDIF
	JRST	DCIDE


;FSYM
FSYM:	MOVEM	A,RANGE		;only concerned with 3's and not 3's 
	HRLOI	E,377777	;The differences start out very large,
	MOVEM	E,DNDIF		; to be diminished if symbols
	MOVE	E,[400000,,1]
	MOVEM	E,UPDIF		; bracketing the value are found
	SETZM	UPSYM
	SETZM	DNSYM
	SETOM	UPCUR
	SETOM	DNCUR
	SETZM	UPSYMP
	SETZM	DNSYMP
	TRNE	F,CNVABS	;Forget it if abs mode (wants numerical
	 POPJ	P,		; value), wanted to set up result vals.
	PUSH	P,PNT
	HRRZ	PNT,SYMBAS
	MOVE	B,@RNGBAS	;because the compare is more @ with 3's.
	ADD	B,PNT		;B points to low symbol entry in range
	MOVE	C,@RNGBS1
	ADDI	C,-2(PNT)	;C points to high symbol entry in range
	MOVE	A,SUBRNG(A)	;A is 0 if RANGE not 3, 1 if 3.

;check boundary conditions

	CAMLE	B,C		;If the range doesn't exist, just
	 JRST	PNPOPJ		; use the number (may change).
	MOVE	PV,B		;If the symbol falls outside the
	MOVE	E,V		; actual range within this range
	XCT	SUB1(A)		; for this program, just accept 
	JUMPLE	E,BINGO		; the closest in the range
TRYHI:	MOVE	PV,C		;Again, this time on high side
	MOVE	E,V
	XCT	SUB1(A)
	JUMPGE	E,BINGO

;search out best match

GOLOOK:	MOVE	E,C
	SUBI	E,-2(B)		;NUMBER OF WORDS LEFT TO SEARCH OVER
	LSH	E,-1		;NUMBER OF SYMBOLS LEFT TO LOOK AT
	TRZ	E,1		;LIKE (E/2)*2  # WORDS TILL MIDDLE SYM
	MOVE	PV,B		;BEGINNING ADDRESS OF RANGE
	JRST	ADDCOM

LESS:	SUBI	PV,(E)
	CAIGE	PV,(B)
	 MOVEI	PV,(B)
BINSRC:	LSH	E,-1
	TRZ	E,1		;COMPUTE HALF AGAIN
	TRNN	E,777776
	 MOVEI	E,2		;MINIMUM OF 2
	XCT	CAMGE1(A)	;CA(I/M)GE V,@1(PV)
	 JRST	LESS
	XCT	CAMG3(A)	;CA(I/M)G V,@3(PV)
	 JRST	BINGO
ADDCOM:	ADD	PV,E		;ADDRESS MIDWAY FROM BEGINNING TO END
	CAILE	PV,(C)
	 MOVEI	PV,(C)		;MAKE SURE IT'S IN THE RANGE
	JRST	BINSRC


;BINGO, WCHBLK, GETRNG
;found it, find nearest symbols in same program

BINGO:	PUSH	P,T
	PUSH	P,PV
	MOVE	T,PV
	SETZM	EX
	MOVNI	M,1
L3:	CAMGE	PV,B			;If just prev matches, back
	JRST	L1			; up to exact match
	XCT	CAMLE1(A)		;of exact matches for beginning
	 JRST	L1
	SUBI	PV,2
	JRST	L3

L1:	ADDI	PV,2			; symbol in same program,
	CAMLE	PV,C			; give up if none
	JRST	NV
	XCT	MOVE3(A)		;Quit, reject if diff gets out
	SUB	M,V			; of WCNT range
	MOVE	E,RANGE
	XCT	CAMW1(E)		;There may have been an
	JRST	[NV:
		MOVNI	M,1
		PUSHJ	P,VALDAT	; exact match, and if there
		 JRST	NOUPR		; was, use it
		JRST	ACCEPUP]
	PUSHJ	P,VALIDATE		;Accept if possible
	JRST	L1			;Not possible
	PUSHJ	P,VALDAT		;Ok, but check for exact match
	 JFCL				;Exact match same block
ACCEPUP:MOVEM	M,UPDIF			;Store the Difference, Symbol
	MOVEM	T,UPSYM			; value, block value results
	MOVEM	E,UPCUR
	MOVEM	PV,UPSYMP
NOUPR:	POP	P,PV
	JUMPE	M,ACCEPDN
	JRST	.+2
L2:	SUBI	PV,2			;Same sort of thing for lower.
	CAMGE	PV,B
	 JRST	NOLWR
	XCT	MOVE3(A)
	SUBM	V,M
	JUMPL	M,L2			;make sure that the thing we 
	MOVE	E,RANGE			;use is lower 
	XCT	CAMW(E)
	 JRST	NOLWR
	PUSHJ	P,VALIDATE
	 JRST	L2
	JFCL				;There won't be an exact match
ACCEPDN:MOVEM	M,DNDIF
	MOVEM	T,DNSYM
	MOVEM	E,DNCUR
	MOVEM	PV,DNSYMP
NOLWR:	POP	P,T
PNPOPJ:	POP	P,PNT
	POPJ	P,

VALIDATE:
	PUSH	P,M		;PV points to a symbol which is within
	MOVE	T,(PV)		; printing range of V.  Accept it
	TLNE	T,400000	; (skip-return with block name, etc.
	 JRST	MPOPJ		; if it is not half-killed, and if
	MOVEI	E,0		; it is INTERNAL or in the same
	TLNN	T,100000	; program.  A 0 return for block-name
	 JRST	ACCEP		; means no block name should be
	LDB	E,[POINT 13,1(PV),12]	; printed, since symbol is in
	HLRZ	M,@BLKVAL		; current nest.
	CAME	E,PID
	 CAMN	M,PID
	  JRST	.+2
	  JRST	MPOPJ
	PUSHJ	P,WCHBLK
ACCEP:	POP	P,M
	JUMPN	M,APOPJ		;If an exact match, and no block name
	JUMPE	E,APOPJ1	; to print, use it; else if exact,
	MOVEM	E,EXB		; save values for later, will use
	MOVEM	PV,EX		; if no better (exact) found
	POPJ	P,		; Fail for now

; Now T has the symbol, E the block name or 0, M the difference
APOPJ1:	AOS	(P)
APOPJ:	AOS	(P)
	POPJ	P,

MPOPJ:	POP	P,M
	POPJ	P,

;RETURN RANGE IN A FOR VALUE IN V.  
;SWAP THE VALUE TO THE RIGHT HALF ;FOR CLASS 3 VALUES.
^GETRNG:
	MOVEI	A,0		;Symbols fall into four ranges:
	TDNN	V,[-1,,400000]	; 0 -- 0 leq x leq 377777
	 JRST	GOTRNG		; 1 -- 400000 leq x leq 777777
	TLNN	V,-1		; 2 -- not(0 or 1), rh 18 bits=0
	 AOJA	A,GOTRNG	; 3 -- not(0 or 1 or 2)
	TRNE	V,-1		;For range 2 symbols, the value is
	 AOJA	A,MORRNG	; swapped in the table, so we also
	HLRZS	V		; swap our input value here.
MORRNG:	ADDI	A,2		;CLASSES 1-4 ARE RANGES 0-3
GOTRNG:	POPJ	P,

VALDAT:	SKIPN	EX
	 POPJ	P,
	MOVE	PV,EX
	MOVE	E,EXB
	MOVEI	M,0
	MOVE	T,(PV)
	SETZM	EX
	JRST	APOPJ

;WCHBLK:  CALL WITH E AS AN INDEX INTO BLOCK STRUCTURE SPACE FOR A 
;  SYMBOL RETURNS E 0 IF SYMBOL IS IN CURRENT NEST, BLOCK NAME OTHERWISE

^WCHBLK:MOVE	M,BID
WCH:	CAMN	M,E
	 JRST	THISONE
	JUMPE	M,NOONE		;IF GOT TO TOP THEN NOT IN THIS NEST
	HRRZ	M,@BLKVL1	;GET NEXT CONTAINING BLOCK 
	JRST	WCH		;STARTING FROM BID 

NOONE:	SKIPA	E,@BLKNAM	;GET BLOCKNAME OF BLOCK WITH THE SYMBOL
THISONE: MOVEI	E,0
	POPJ	P,


;TABLES FOR LOG SEARCH OF SYMBOL TABLE  SUBRNG

EX:	0
EXB:	0

^SUBRNG:0
	0
	0
	1

SUB1:	SUBI	E,@1(PV)
	SUB	E,@1(PV)

SUB2:	SUBI	M,@1(B)
	SUB	M,@1(B)

MOVE1:	MOVEI	M,@1(B)
	MOVE	M,@1(B)

MOVE2:	MOVEI	M,@1(C)
	MOVE	M,@1(C)

MOVE3:	MOVEI	M,@1(PV)
	MOVE	M,@1(PV)

CAMG3:	CAIG	V,@3(PV)
	CAMG	V,@3(PV)

^^CAMG1:CAIG	V,@1(PV)
	CAMG	V,@1(PV)

CAML1:	CAIL	V,@1(PV)
	CAML	V,@1(PV)

CAME1:	CAIE	V,@1(PV)
	CAME	V,@1(PV)

^CAMGE1:CAIGE	V,@1(PV)
	CAMGE	V,@1(PV)

^CAMLE1:CAILE	V,@1(PV)
	CAMLE	V,@1(PV)

CAMW:	CAMLE	M,WCNT
	CAMLE	M,WCNT
	CAIL	M,1000
	CAML	M,[1000,,0]

CAMW1:	CAMLE	M,WCNT+1
	CAMLE	M,WCNT+1
	CAIL	M,1000
	CAML	M,[1000,,0]

BEND FNDSYM
^GETRNG_GETRNG
^SUBRNG_SUBRNG
^WCHBLK_WCHBLK
^CAMLE1_CAMLE1
^CAMGE1_CAMGE1

?WRPSW:	0
^WRPSW_WRPSW
DNSYM:	0		;THESE MUST STAY IN ORDER
DNCUR:	0
^DNSYMP:0
UPSYM:	0
UPCUR:	0
^UPSYMP:0
UPDIF:	0
DNDIF:	0
ODNSYM:	0
ODNCUR:	0
ODNSYP:	0
OUPSYM:	0
OUPCUR:	0
OUPSYP:	0
OUPDIF:	0
ODNDIF:	0		;ALL THE WAY TO HERE
CURBL:	0
^RANGE:	0
VSAV:	0
BEND SUBS


; Symlok -- Symbol to Value Searcher -- Csflush

; HERE IS THE SYM to VALUE SYMBOL TABLE SEARCHER
; RADIX50 FOR SYMBOL IN `SYM', SKIPS AND CONTAINS pointer to SYMBOL
;   ENTRY IN SPNT AND V IF FINDS IT, ELSE NO SKIP

^SYMLOK:PUSH	P,PV
	MOVEI	PV,NUMCSH-1	;FIRST, SEARCH CACHE OF RECENTLY SEEN
	MOVE	E,SYM		; SYMBOLS, AND IF THE SYM IS FOUND, 
	CAME	E,SYMCSH(PV)	; RETURN IMMEDIATELY -- GUARANTEED OK
	 SOJGE	PV,.-1		; BECAUSE CACHE IS FLUSHED WHENEVER IT
	JUMPL	PV,SYMLK1	; MIGHT BE INVALID
	MOVE	PV,SYMVAL(PV)
	JRST	GOTHIM

SYMLK1:	SETZM	UNIQP
	SETZM	UNIQ
	SETZM	GLOBB
	SETZM	BESTB
	MOVE	PV,SYMRNG
SYMLP:	LDB	E,[POINT 32,(PV),35];GET SYMBOL WITHOUT TYPE BITS IN E
	CAME	E,SYM		;SKIP IF IT MATCHES
	 JRST	SYML		;NO MATCH, LOOK AT MORE SYMBOLS
	MOVE	E,(PV)
	TLNN	E,100000	;SKIP IF NOT GLOBAL
	 JRST [	HRROM	PV,GLOBB
		JRST	SYML]
	LDB	E,[POINT 13,1(PV),12]	;GET BLOCK STRUCTURE POINTER 
	CAMN	E,PID			;FOR THIS SYMBOL 
	 JRST	MAYBE		;SYMBOL IS IN THE RIGHT PROGRAM
	MOVE	M,@BLKNAM	;GET BLOCK NAME OF BLOCK SYMBOL IS IN
	HLRZ	V,@BLKVAL	;GET POINTER TO PROGRAM CONTAINING 
	TLNE	M,140000	;BLOCK SYM IS IN THE ID IS A PROG-ID 
	 CAME	V,PID		;IF THESE BITS ARE OFF. 
	  JRST [SKIPE	UNIQP	;NOT IN RIGHT PROGRAM, SKIP IF DON'T 
				; HAVE SUCH YET 
		 JRST	SYMLK2	;-NOT UNIQUE OUTSIDE OF CURRENT PROGRAM
		HRRZM	PV,UNIQP
		JRST	SYML]
MAYBE:	PUSHJ	P,WCHBLK	;RETURN E=0 IF THIS BLOCK IS 
				;IN THE CURRENT BLOCK NEST 
	JUMPE	E,SYMLK3	;JUMP IF THIS SYMBOL IN THE BLOCK NEST
	SKIPE	UNIQ		;SKIP IF NO OTHER IN THIS PROG BUT NOT IN BLOCK NEST
	 JRST	SYMLK4		;NOT UNIQUE
	HRRZM	PV,UNIQ		;ONLY ONE SO FAR IN PROG 
	JRST	SYML		;BUT NOT IN BLOCK NEST 

SYMLK3:	LDB	E,[POINT 13,1(PV),12]	;GET BLOCK STRUCTURE POINTER 
					;FOR THIS SYMBOL 
	SKIPN	M,BESTB		;SKIP IF THERE IS A SYM IN THE BLOCK NEST ALREADY
	 JRST	SYMLK6
	CAIL	E,(M)		;SKIP IF NEW ONE IS BETTER THAN PREVIOUS ONE
	 JRST	SYML
SYMLK6:	HRLI	E,(PV)
	MOVSM	E,BESTB
	JRST	SYML

SYMLK2:	HRROS	UNIQP
	JRST	SYML

SYMLK4:	HRROS	UNIQ
SYML:	ADD	PV,[2,,2]
SYML1:	JUMPL	PV,SYMLP
	SKIPN	PV,BESTB	;SKIP IF THERE WAS ONE IN THE CURRENT BLOCK NEST
	 SKIPE	PV,GLOBB	;SKIP IF THERE WAS NONE AND NO GLOBAL EITHER
	  JRST	GOTSYM		;USE IT
	SKIPN	PV,UNIQ		;SKIP IF THERE IS ONE IN THIS PROG NOT IN BLOCK NEST
	 SKIPE	PV,UNIQP	;SKIP IF NON IN THIS PROG OR ANY PROG
	  JRST	SYMLK5		;FOUND IN SOME PROG NOT IN CURRENT BLOCK NEST
PNONE:	POP	P,PV
NONE:
IFN EXDSW,<PUSHJ P,IOFNDI>	;FIND AS I/O DEV. NAME
	TLOA	F,SYMF!SCFL!UNDF	;NOT FOUND
	 TLO	F,NUMF!SYMF!SCFL	;FOUND
^CPOPJ:	POPJ	P,

SYMLK5:	JUMPGE	PV,GOTSYM
	TLO	F,PMULFL	;MULTIPLY DEFINED, MARK AS SUCH.
	MOVEI	E,.MUL
	HRLM	E,NBIGWD
GOTSYM:	SOSGE	E,SCSHPT	;STORE THE NEW-FOUND SYMBOL NAME AND POINTER
	 MOVEI	E,NUMCSH-1	; IN THE CACHE (CIRCULAR)
	MOVEM	E,SCSHPT
	MOVE	M,SYM
	MOVEM	M,SYMCSH(E)
	HRRZM	PV,SYMVAL(E)
GOTHIM:	HRRZS	PV		;ADDR IN SYM TABLE OF SYMBOL (MAYBE FOUND IN CACHE)
	PUSH	P,PNT		;PNT IS IN THE INDEX FIELD OF CLASS 4 VALUES
	HRRZ	PNT,SYMBAS	;ADDRESS OF BEGINNING OF SYMBOL TABLE
	MOVE	V,PV		;ADDRESS OF SYMBOL
	SUB	V,PNT		;RELATIVE ADDRESS OF SYMBOL
	MOVEI	E,@1(PV)	;GET VALUE (OR ADDRESS OF VALUE FOR CLASS 4)
	MOVE	M,RNGBAS	;GET ADDRESS OF RELATIVE POINTERS TO SYM CLASSES
	CAML	V,2(M)		;SKIP IF CLASS1 OR CLASS2 (RH VALUES)
	 MOVSS	E		;CLASS 3 VALUES ARE LEFT HALF ONLY VALUES
	CAML	V,3(M)		;SKIP IF CLASS 1, 2 OR 3 (NOT 36 BIT VALUES)
	 MOVE	E,@1(PV)	;GET 36 BIT VALUE
	POP	P,PNT
	MOVE	V,PV		;ADDRESS OF SYMBOL
	POP	P,PV
SYMDOT:	MOVEM	E,NM		;SAVE VALUE FOR LATER USE.
	MOVEM	V,SYMP		;SAVE POINTER TOO.
	TLO	F,NUMF!SYMF!SCFL	;SET FLAGS
ITCHK:	CAIN	C,"."		;IS AHEAD CHAR <CTRL1>`.'?
	 CAIE	B,1
	  POPJ	P,		; NO
	TLZ	F,SCFL		;NOT AHEAD ANY MORE
	SETZM	SAVMOD		;DON'T USE ANY INPUT-DRIVEN MODE
	JSR	FNDSCR		;ON SCREEN?
	JRST   [HLRZ	M,(M)
		TLZ	M,400037 	;CLEAR NON-MODE BITS
		LSH	M,-5		;IN SAVMOD FORMAT
		TLNN	F1,FIRF 	;FIRST THING?
		 HRRM	M,SAVMOD 	;YES, USE THIS MODE
		JRST	.+1]
	JRST	ITD1		;USE CONTENTS OF THAT CELL
	POPJ	P,

; FLUSH ALL CACHES, SOMETHING DRASTIC HAS CHANGED

^CSFLUSH:
	SETOM	SYMCSH		;SET TO RIDICULOUS VALUE
	MOVE	E,[SYMCSH,,SYMCSH+1]
	BLT	E,CSHEND	;CLEAR ALL TO -1
	POPJ	P,


;Prgfnd, Prgset, Blkfnd, Blkfn

^PRGFND:PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES
	TLNN	F1,SINGF	;SINGLE SYMBOL?
	 JRST	CERR		;NO
	MOVEI	E,0
	MOVE	M,SYM
CPRG:	CAMN	M,@BLKNAM
	 JRST	HERE
	HLRZ	E,@BLKVAL
	JUMPN	E,CPRG
	JRST	PU

HERE:	MOVEM	E,PID
	MOVEM	E,BID
	PUSHJ	P,BLFND		;SEARCH FOR BLOCK WHOSE NAME IS IN SYM
	 JFCL
	MOVE	E,BID
	JRST	INSBLK

^PRGSET:
IFE UESW,<
	MOVEI	E,0
	JRST	CPRG2

CPRG1:	HLRZ	E,@BLKVAL
	JUMPE	E,CPRG3
CPRG2:	MOVE	M,@BLKNAM
	CAME	M,[RADIX50 0,RAID]
	 CAMN	M,[RADIX50 0,JOBDAT]
	  JRST	CPRG1		;DON'T USE EITHER OF THESE PROGS
CPRG3:	MOVE	M,@BLKNAM	;GET PROG NAME AND STORE IN SYM FOR
	MOVEM	M,SYM		;BLFND TO FIND
	JRST	HERE
>;NOT UESW
IFN UESW,<POPJ	P,>

^BLKFN:	PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES
	PUSHJ	P,BLKFND

; INSERT PROG/BLOCK PAIR IN BUFFER FOR QUICK REFERENCE (CTRL-Z)

INSBLK:	SKIPGE	T,REFPNT	;FIRST, IF THERE IS A LIST YET,
	 JRST	INSIT		; LOOK IN IT FOR A MATCH
	CAIE	T,NUMREF-1	;FULL?
	 JRST	CAMIT
	MOVE	M,[BLKREF+3,,BLKREF]	;REMOVE THE OLDEST 3
	BLT	M,BLKREF+NUMREF-4
	SUBI	T,3
	MOVEM	T,REFPNT
CAMIT:	CAME	E,BLKREF(T)	;WHEREVER IT IS, AND REPLACE
	 SOJGE	T,CAMIT		; IT AT THE TOP OF THE "STACK"
	JUMPL	T,INSIT

; E is block ID to be inserted in list.
; T pointer to block ID index to be removed.

^ZAPIT:	CAMN	T,REFPNT
	 JRST	INSIT1
	MOVE	M,BLKREF+1(T)
	MOVEM	M,BLKREF(T)
	AOJA	T,ZAPIT
INSIT:	AOS	T,REFPNT
INSIT1:	HRRZM	E,BLKREF(T)
	POPJ	P,


^BLKFND:TLNN	F1,SINGF	;SINGLE SYMBOL?
	 JRST	BLKTHS		;NO
	PUSHJ	P,BLFND		;FIND
	 JRST	PU
	POPJ	P,

BLKTHS:	HRRZ	V,LOCOP
	PUSHJ	P,FNDSYM
	PUSHJ	P,ADSEL
	 JRST	CERR		;NO SYMBOL BEING SHOWN FOR . ANYWAY
	 SKIPA	E,DNSYMP	;DNSYM IS THE WINNER
	 MOVE	E,UPSYMP	;UPSYM IS THE WINNER
	JUMPE	E,CERR
	LDB	E,[POINT 13,1(E),12]	;GET BLOCK STRUCTURE INDEX OF 
	JRST	SETBL			;THIS SYMBOL 

; Open the block containing the last symbol typed.
;BLKTHS:TLNN	F1,VALF		;If there is a value, it's a bug
;	SKIPN	E,SYMP		;If no symbols yet, a bug
;	 JRST	CERR
;	LDB	E,[POINT 13,1(E),12]
;	JRST	SETBL	

;SEARCH THE BLOCK STRUCTURE TABLE FOR THE BLOCK WHOSE NAME IS IN SYM.
;IF IT IS FOUND IN THE CURRENT PROGRAM, THEN PUT ITS INDEX IN BID AND
;SKIP RETURN.  IF NOT, THEN SEARCH THE ENTIRE TABLE, AND IF A UNIQUE
;BLOCK NAME IS FOUND, SET PID AND BID TO THE PROGRAM AND BLOCK INDICES
;RESPECTIVELY AND SKIP RETURN.  IF IT IS NOT FOUND ANYWHERE, THEN TAKE
;THE DIRECT RETURN.
BLFND:	MOVE	E,PID		;FIRST SEARCH THE BLOCKS IN THE 
	MOVEI	V,0		;CURRENTLY OPEN PROGRAM (V=0 IS FLAG)
	SETOM	UNIQ
	HLRZ	M,@BLKVAL	;GET THE INDEX OF THE NEXT PROGRAM 
	JUMPN	M,BLF1		;(OR ZERO) 
BLF:	MOVE	M,BLKSIZ
BLF1:	SUBM	E,M
	HRL	E,M		;E IS -COUNT-1,,BID CANDIDATE-1
	MOVE	M,SYM		;M IS RADIX50 14,BLOCKNAME
	TLOA	M,140000
BFLUP:	 CAME	M,@BLKNAM	;SEARCH THE ENTIRE RANGE UNTIL A MATCH 
BFL1:	  AOBJN	E,BFLUP		; IS FOUND OR THE RANGE IS EXHAUSTED
	JUMPGE	E,BLNOP1	;IF RANGE IS EXHAUSTED, CHECK FOR MORE.
	JUMPE	V,GOTIT1	;IF V STILL 0, FOUND IN OWN PROG, ACCEPT
	SKIPL	UNIQ		;OTHERWISE, SEARCH THE REST, AND REQUIRE
	 JRST	BLNOPE		; THAT THERE BE A UNIQUE BLOCK OF 
	HRRZM	E,UNIQ		; THAT NAME SOMEWHERE, OR GIVE UP.
	JRST	BFL1

GOTIT1:	HRRZM	E,BID		;ACCEPT THE BLOCK, OPEN IT, 
	AOS	(P)		;REPORT SUCCESS. 
BLNOPE:	POPJ	P,		;COME HERE TO RETURN UNSUCCESSFUL.

BLNOP1:	JUMPN	V,CKNOPE	;WHEN RANGE IS EXHAUSTED, IF ONLY THE
	MOVEI	E,0		; CURRENT PROGRAM HAS BEEN SEARCHED, 
	AOJA	V,BLF		; DO ALL OF THEM 

CKNOPE:	SKIPGE	E,UNIQ		;OTHERWISE, IF A UNIQUE BLOCK NAME WAS 
	 JRST	BLNOPE		; FOUND SOMEWHERE, USE IT, 
				; AND MAKE SURE THAT ITS
^SETBL:	MOVE	M,@BLKNAM	; PROGRAM IS ALSO OPEN.
	TLNN	M,140000	;THE CANONICAL PROGRAM NOT BLOCK TEST
	 SKIPA	M,E
	 HLRZ	M,@BLKVAL
	HRRZM	M,PID		;RESET PROG ID.
	JRST	GOTIT1		; AND ACCEPT
>;SORTED (BEGAN ON PAGE 49)


   }@(n