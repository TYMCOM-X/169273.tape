;Gchr1, Gchr, Chtb1, Chtb2
BEGIN SCAN

;CHARACTER IDENTIFICATION FLAGS

ILLG__1
NUM__2
LET__4
AROP__20
SSPC__40
BOK__100
BIL__200
BIG__400
SLT__1000
STRID__2000	;START AN ID GODDAMMIT (FOR FORTRAN KLUDGE)
UOK__4000	;IT'S OK FOR A SYMBOL PRECEDING THIS CHAR
		;TO BE UNDEFINED (OTHERWISE COMPLAIN)

COMMENT \
GET A CHARACTER ROUTINES
GCHR1:		GET A SINGLE CHARACTER. IF STRIN CONTAINS NON-ZERO,
		IT IS ASSUMED TO CONTAIN A BYTE POINTER WHICH IT
		THEN USES FOR GETTING CHRS.  IF STRIN CONTAINS A ZERO,
		IT GETS INPUT FROM THE KEYBOARD.
GCHR:		GET A CHARACTER AND WORRY ABOUT ALT-MODE (1 ALT = CTRL,
		2 ALTS = META, 3 ALTS = CTRL-META) AND BUCKY BITS
GCHRS:		GETS A CHARACTER ALONG WITH ITS BITS FROM THE TABLE
\

LOP1:	SETZM	STRIN	;CLEAR BUF POINTER
	PUSHJ	P,SVACS	;SAVE ACS FOR RESTARTING
	XCT	TYII	;GET 1 CHR. -- THIS WAITS UNTIL AN ACTIVATION CHAR.
IFE STANFO,<
	POPJ	P,
>
IFN STANFO,<
	SKIPN	DETFLG
	POPJ	P,
	PUSH	P,V
	MOVNI	V,1
	GETLIN	V
	CAMN	V,[-1]
	 JRST [	POP P,V		;STILL DETACHED
		POPJ P,	]
	SETZM	DETFLG
	MOVEM	V,USERLIN	;SAVE FOR USER
	TLO	V,100		;SPECIAL ACTIVATION MODE
	MOVEM	V,RADLIN	;FOR NORMAL RAID OPERATIONS
	TLZ	V,100		;FOR ASCII INPUT OPERATIONS
	MOVEM	V,ASCLIN
	TLO	V,20		;FULL CHARACTER SET MODE, FOR EDITING
	MOVEM	V,EDTLIN
	POP	P,V
	POPJ	P,
>;STANFO

^GCHR1:	ILDB	C,STRIN	;GET CHR. (1 CHR.)
	JUMPE	C,LOP1	;NONE?
	POPJ	P,

IFN STANFO!TYMSHR,<
^TYII:	INCHWL	C
>;STANFO!TYMSHR
			

;RETURN 7 BIT CHARACTER IN C, BUCKY BITS IN B.  EACH ALTMODE GIVES 
;ANOTHER BUCKY BIT.
^GCHR:	MOVEI	B,0
GCHRB:	PUSHJ	P,GCHRA
ifn tymshr,<
	caie	c,3	;at TYMSHARE, make ^C work just like <ESC>
>
	CAIN	C,ALTMOD	;ALT-MODE?
IFN STANFO!TYMSHR,<
	AOJA	B,[TRO F,DOSETL	;YES -- FLAG WE HAVE CHANGED MODES.
		PUSH	P,[INCHRW C]
		POP	P,TYII	;THIS IS THE INSTRUCTION.
		JRST	GCHRB]
>;STANFO!TYMSHR
IFE STANFO!TYMSHR,<AOJA B,GCHRB>
IFN STANFO,<	;at TYMSHARE, ignore bits (no terminals have it yet)
	TRNE	C,600			;BUCKY BITS?
	LDB	B,[POINT 2,C,28]	;YES, GET THEM IN B
>
IFN STANFO!TYMSHR,<
	TRZN	F,DOSETL	;IF WE WERE IN SPECIAL MODE,
	 JRST	.+3
	PUSH	P,[INCHWL C]	;PUT TYII BACK
	POP	P,TYII
>;STANFO!TYMSHR
	ANDI	C,177
	POPJ	P,		;NO

^GCHRA:	PUSHJ P,GCHR1	;GET 1 CHR.
IFN STANFO!TYMSHR,<
	CAIN	C,15
	 JRST	EATLF
>;STANFO!TYMSHR
	POPJ	P,

IFN STANFO!TYMSHR,<
EATLF:	SKIPN	STRIN
	INCHRW	C	;GET LF WHICH FOLLOWS CR (ALONG WITH BUCKY BITS)
	SKIPE	STRIN
	ILDB	C,STRIN
	XORI	C,.XOR.(15,12)	;CHANGE IT BACK TO CR, PRESERVING BITS
	POPJ	P,
>

; Non-Stanford Get a character, activate on activation routine

IFE STANFO!TYMSHR,<
^TYII:	PUSHJ	P,.+1
GETCHR:	ILDB	C,INBP
	JUMPN	C,CPOPJ
	PUSH	P,A
	JRST	GLSET
GLRESET:
IFN TENEX,<
	HRROI	A,[XS: ASCIZ /XXX
/]
	PSOUT
>;TENEX
IFE TENEX,<
	OUTSTR	[ASCIZ /XXX
/]>;NOT TENEX
GLSET:	MOVEI	B,0
	MOVE	C,[POINT 7,INBF-1,34]
	MOVEM	C,INBP
GLP:
IFE TENEX,<
	INCHRW	C
>
IFN TENEX,<
	PBIN
	MOVE	C,1
>
	SKIPE	NBSSW
	 JRST	NOBS
	CAIN	C,25
	 JRST	GLRESET
	CAIN	C,177
	 JRST	ADJ
NOBS:	CAIN	C,177
	 JRST	GLRESET
	CAIN	C,1		;CTRL A
	 JRST	ADJ
	CAIE	C,10		;CTRL H (backspace)
	 JRST	VANILLA
ADJ:	MOVSI	C,70000
	ADD	C,INBP
	JUMPGE	C,.+2
	 SUB	C,[430000,,1]
	CAMN	C,[POINT 7,INBF-1,27]
	 JRST	GLRESET
	MOVEM	C,INBP
	ILDB	C,C
	CAIN	C,ALTMOD
	 SUBI	B,1
	SKIPN	NBSSW
	 MOVEI	C,10
IFN TENEX,<
	MOVE	A,C
	MOVE	C,[PBOUT]
	EXCH	C,VTINST
	PUSHJ	P,VTSOUT
	EXCH	C,VTINST	;RESET
>;TENEX
IFE TENEX,<
	OUTCHR	C
>
	JRST	GLP

VANILLA:CAIN	C,15
IFE TENEX,<INCHRW;>PBIN		;SUCK IT
	CAIN	C,37		;EOT
	 MOVEI	C,15
	IDPB	C,INBP
	CAIN	C,ALTMOD
	 AOJA	B,GLP
	JUMPN	B,ACT
	MOVE	A,C
	IDIVI	A,=36
	MOVE	A,BRKTAB(A)
	MOVEI	C,1
	LSH	C,(B)
	MOVEI	B,0
	TDNN	A,C
	 JRST	GLP
ACT:	MOVEI	B,0
	IDPB	B,INBP
	MOVE	A,[POINT 7,INBF-1,34]
	MOVEM	A,INBP
	POP	P,A
	JRST	GETCHR
>;NOT STANFO!TYMSHR

;GCHRS
;GET WORD OF CHARACTER IDENTIFICATION FLAGS IN D1 CORRESPONDING TO THE
;CHARCTER READ IN.  RETURN THE CHARACTER IN C AND ITS BUCKY BITS IN B
^GCHRS:	PUSHJ	P,GCHR		;GET 1 CHR IN C, BUCKY BITS IN B
	CAIG	C,140		;LOWER CASE?
	 JRST	GCHRSA		;NO
	SUBI	C,40		;YES, CONVERT TO UPPER
	CAIL	C,133		;LOWER CASE SPECIAL?
	 ADDI	C,5		;YES
GCHRSA:	MOVE	D1,C		;GET CHR.
	IDIVI	D1,=9		;SEPARATE FOR TABLE FETCH
	LDB	D1,CHTB1(D2)	;GET TABLE ENTRY
	MOVE	D1,CHTB3(D1)	;GET BITS
	TRNE	D1,ILLG		;ILLEGAL CHR?
	 JRST	GCHRS1		;YES
	TRNE	D1,BIG		;IGNORE BUCKY?
	 MOVEI	B,0		;YES, SET BUCKY BITS TO ZERO
	TRNN	D1,BIL		;BUCKY ILLEGAL?
	 POPJ	P,		;NO
	JUMPE	B,.-1		;YES, ANY BUCKY?
GCHRS1:	JRST	INERR		;YES, ILLEGAL

RADIX =10
CHTB1:	FOR I_3,35,4
<	POINT 4,CHTB2(D1),I
>
RADIX 8

DEFINE TBM1 (A1,A2,A3,A4,A5,A6,A7,A8,A9,Q)
<IFDIF <>,<Q>,<.FATAL TOO MANY AT CHTB2>
IFIDN <>,<A9>,<.FATAL TOO FEW AT CHTB2>
	BYTE (4)A1,A2,A3,A4,A5,A6,A7,A8,A9 >

CHTB2:	TBM1  0, 0, 0, 6,10, 0, 0, 0, 0	;  0- 10	^C,^D
	TBM1 10, 6, 0, 0, 6, 0, 0, 0, 0	; 11- 21	TAB,LF,CR
	TBM1  6, 6, 0, 0,12, 0, 6, 6, 6	; 22- 32   ^R,^S,^V,^X,^Y,^Z
	TBM1  6, 0, 0, 6,10, 3, 3, 5,10	; 33- 43	ESC,^^,^_,...
	TBM1 11,11,13, 5,10,10, 3, 3,10	; 44- 54
	TBM1  3, 4, 3, 2, 2, 2, 2, 2, 2	; 55- 65
	TBM1  2, 2, 2, 2,13, 6, 6, 5, 6	; 66- 76
	TBM1 10, 6, 1, 1, 1, 1, 1, 1, 1	; 77-107
	TBM1  1, 1, 1,14, 1, 1, 1, 1, 1	;110-120
	TBM1  1, 1, 1, 1, 1, 1, 1, 1, 1	;121-131
	TBM1  1, 6, 6, 6, 6,13, 6, 6, 6	;132-142    Z,[,\,],^,_,{,|,}
	TBM1  6, 6, 0, 0, 0, 0, 0, 0, 0	;143-153	tilde,DEL

CHTB3:	ILLG			; 0  ILLEGAL CHR.
	LET!BOK			; 1  LETTER- BUCKY O.K.
	NUM!BOK			; 2  NUMBER - BUCKY O.K.
	AROP!BIG		; 3  ARITH OP-IGNORE BUCKY
	SSPC!LET!BOK!SLT	; 4  SPCL CHR-LETTR (.)
	SSPC!BOK 		; 5    "  "  "  BUCKY OK (" ')
	BOK			; 6  BUCKY O.K.
	BIL			; 7    "  ILLEGAL
	BIG			;10    "  IGNORE
	LET!SLT!BOK		;11  SPECIAL LTR ($ %)
	STRID!LET 		;12  START AN ID GODDAMMIT
	BOK!UOK			;13  OK FOR PREV TO BE UNDF (& : _)
	BOK!UOK!LET		;14  SAME, LETTER (K)

;Main Dispatch, <ctrl>., Numbers -- SCAN
^SCAN:	TLZ	F,NUMF!SYMF!UNDF!FLTF!R5FL  ;CLEAR FLAGS
	TLZN	F,SCFL	;GOT A CHR?
	 PUSHJ	P,GCHRS	;NO, GET ONE
	TRNE	D1,LET	;LETTER?
	 JRST	SLET	;YES
	TRNE	D1,NUM	;DIGIT?
	 JRST	SNUM	;YES
	TRNN	D1,SSPC	;SPECIAL SCANNER CHR?
	 POPJ	P,	;NO
	CAIN	C,"="	;=?
	 JRST	DECMAL	;YES
	CAIN	C,42	; "
	 JRST	TEXT	;YES, TEXT FOLLOWS
	CAIN	C,"'"	;'
	 JRST	STEXT	;YES, SIXBIT TEXT FOLLOWS
	JRST	4,.

LETSPC:	CAIN	C,"."	;.?
	 JRST	ITDOT	;YES
	CAIN	C,"%"	;IS IT %?
	 JRST	BYTIN	;YES
	POPJ	P,	;NO

;WANT VALUE OF CURRENTLY OPEN LOCATION

ITDOT:	CAIE	B,1	;1 BUCKY?
	 JRST	DOTBKY	;NO
	HRRZ	E,LOCOP	;GET VALUE OF .
^ITD1:
;;IFE UESW,<
;;	JSR	ECHK
;;IFE FILESW,<
;;	MOVE	E,(E)	;GET VALUE THERE
;;>
;;IFN FILESW,<
;;	PUSHJ	P,RDTRKE
;;	MOVE	E,@TRKOFF
;;ITD1A:
;;>
;;>;NOT UESW
;;				IFN UESW,<MO (E,E)>
IFE UESW,< JSR	ECHK >
IFN FILESW,<
	PUSHJ	P,RDTRKE
	MOVE	E,@TRKOFF
>
IFE FILESW,< CMOVE (E,E) >

	MOVEM	E,NM		;STORE VALUE
	TLO	F,NUMF!SYMF	;SET FLAGS
	POPJ	P,


DOTBKY:	CAIE	B,2	;IS IT META
	 POPJ	P,	;NO
	JRST	PNTIN	;YES, GET BYTE MODE INPUT

;OCTAL OR FLOATING NUMBER INPUT

SNUM:	JUMPN	B,CPOPJ	;BUCKY BITS?
	MOVE	V,[LSH V,3];SET RADIX TO OCTAL
	MOVEM	V,RAD
DNUM:	SETZM	FNM	;CLEAR FLOATING NUMBER
	SETZM	NM	;CLEAR NUMBER
	TLOA	F,NUMF	;NUMBER, SET FLAG
LOP2:	PUSHJ	P,GCHRS	;GET CHR.
	TRNN	D1,NUM	;NUM?
	 JRST	NODIG	;NO
	JUMPN	B,NODIG	;BUCKY BITS?
	MOVEI	V,-60(C)
	EXCH	V,NM	;GET CURRENT NUMBER
RAD:	LSH	V,3	;MULT
	ADDM	V,NM	;ADD IN DIGIT
	MOVEI	V,-60(C)	;GET DIGIT VALUE
	FLOAT	V,	;FLOAT DIGIT
	EXCH	V,FNM	;GET CURRENT FLOATING
	FMPR	V,[10.0]	;MULT
	FADM	V,FNM	;ADD IN DIGIT
	JRST	LOP2

NODIG:	CAIN	C,"."	;.?
	 JRST	FLT	;YES
	TRNE	D1,LET	;LETTER?
	 JRST	SINER	;YES
SINRET:	TLO	F,NUMF!SCFL	;SET FLAGS
	HRRZ	E,NM	;IN CASE WANT CONTENTS
	JRST	ITCHK	;CHECK FOR <ctrl1>`.'

SINER:	JUMPN	B,SINRET	;BUCKY BITS?
SCINR:	JRST	INERR		;NO, ERROR

; FLOATING NUMBER INPUT

FLT:	JUMPN	B,SINRET	;BUCKY BITS?
	MOVE	C,[0.1]
	MOVEM	C,NM
	MOVEI	V,FLG		;SET FLOATING IF ONLY THING SO FAR
	PUSHJ	P,TMPMOD
FLOP:	PUSHJ	P,GCHRS	;GET CHR.
	TRNN	D1,NUM	;NUM?
	 JRST	NODIGF	;NO
	JUMPN	B,NODIGF	;BUCKY BITS?
	ANDI	C,17	;GET DIGIT
	FLOAT	C,	;FLOAT IT
	FMPR	C,NM	;SCALE IT
	FADRM	C,FNM	;ADD IN
	MOVE	V,NM	;GET SCALE FACTOR
	FDVR	V,[10.0]	;ADJUST IT
	MOVEM	V,NM
	JRST	FLOP

NODIGF:	TRNN	D1,LET	;LETTER?
	 JRST	FLTRET	;NO
	JUMPN	B,FLTRET	;NO BUCKY BITS?
	CAIE	C,"E"
	 JRST	INERR	;LETTER WITHOUT B BITS, ERROR
	PUSHJ	P,GCHRS	;GET NEXT CHAR
	JUMPN	B,INERR	;MUST BE + OR - OR NUMBER ALL WITHOUT BUCKY
	SETZM	NEGPWR#
	SETZM	NM	;ACCUMULATE EXPONENT HERE
	TRNE	D1,NUM
	 JRST	FLTEL
	CAIN	C,"+"
	 JRST	FLTEL1
	CAIE	C,"-"
	 JRST	INERR
	SETOM	NEGPWR	;INDICATE NEGATIVE POWER
FLTEL1:	PUSHJ	P,GCHRS
	TRNN	D1,NUM
	 JRST	FLTELD
	JUMPN	B,INERR
FLTEL:	MOVE	B,NM
	IMULI	B,=10
	ADDI	B,-"0"(C)
	MOVEM	B,NM
	JRST	FLTEL1

FLTELD:	MOVE	V,NM
	CAILE	V,=38
	 JRST	INERR
	SKIPE	NEGPWR
	 MOVN	V,V
	MOVE	V,PTENTB(V)
	FMPRM	V,FNM
	TRNN	D1,LET
	 JRST	FLTRET
	JUMPE	B,INERR
FLTRET:	TLO	F,NUMF!FLTF!SCFL;SET FLAGS
	MOVE	V,FNM
	MOVEM	V,NM
	POPJ	P,

RADIX =10
FOR @! I_=38,1,-1 <
	1.0E-!I
>
PTENTB:	1.0
FOR @! I_1,38,1 <
	1.0E!I
>
RADIX 8

;Letters, Decimal, Text -- SLET, DECMAL, TEXT

;SYMBOLIC INPUT

SLET:	JUMPN	B,LETSPC	;BUCKY BITS
	TRNE	D1,STRID	;START AN ID?
	 PUSHJ	P,GCHRS		;YES -- GET FIRST CHAR.
	SETZM	SIXSYM
	MOVE	D2,[POINT 6,SIXSYM]
	MOVEM	D2,BYTSAV	;SET UP BYTE POINTER FOR SIXBIT
	SUBI	C,40		;CONV TO SIXBIT
	IDPB	C,BYTSAV
	TRNE	D1,SLT		;SPECIAL LETTER?
	 PUSHJ	P,SLTCN		;YES
	SUBI	C,'A'-13	;CONVERT TO RADIX 50
	TRNE	D1,NUM
	 ADDI	C,'A'-13-17	;IN CASE FIRST CHAR IS NUMBER.
	MOVEM	C,SYM		;SAVE
	MOVEI	V,6		;COUNT
LOP3:	PUSHJ	P,GCHRS		;GET CHR.
	TRNN	D1,LET!NUM	;LETTER OR DIGIT?
	 JRST	ENSYM		;NO
	JUMPN	B,ENSYM		;BUCKY BITS?
	SOJLE	V,LOP3		;STOP AT 6 CHRS.
	SUBI	C,40		;CONV TO SIXBIT
	TLNN	F,R5FL
	 IDPB	C,BYTSAV	;DEPOSIT
	TRNE	D1,SLT		;SPECIAL LETTER?
	 PUSHJ	P,SLTCN		;YES
	SUBI	C,'A'-13	;CONVERT TO RADIX 50
	TRNE	D1,NUM
	 ADDI	C,'A'-13-17	;CONVER NUM TO RADIX 50
	EXCH	C,SYM		;GET SYMBOL
	IMULI	C,50		;SHIFT
	ADDB	C,SYM
	MOVEM	C,NM
	JRST	LOP3

SLTCN:	CAIN	C,5		;% ?
	 MOVEI	C,47+'A'-13
	CAIN	C,4		;$ ?
	 MOVEI	C,46+'A'-13
	CAIN	C,'.'
	 MOVEI	C,45+'A'-13
	POPJ	P,
BYTSAV:	0

;DECIMAL NUMBER INPUT

DECMAL:	JUMPN	B,CPOPJ
	MOVEI	V,DCM		;PERHAPS SET TEMPORARILY TO
	PUSHJ	P,TMPMOD	;DECIMAL
	MOVE	C,[IMULI V,12]
	MOVEM	C,RAD		;SET RADIX TO DECIMAL
	PUSHJ	P,GCHRS		;GET CHR.
	TRNE	D1,NUM		;DIGIT?
	 JRST	DNUM		;YES, GO PROCESS
	JRST	SCINR		;NO, ERROR

;ASCII WORD (OR EXTENDED TEXT) INPUT "/string/

TEXT:	JUMPN	B,EXTTXT	;BUCKY BITS MEANS MULTI-WORD DEPOSIT
	MOVEI	T,5		;ASCII CHR COUNT
	MOVEI	V,TXT+2		;SET FOR ASCII OUTPUT MAYBE
TEX:	PUSHJ	P,TMPMOD 
	MOVEI	V,0		;INIT VALUE
	MOVNI	M,-14(T)	;FORM SHIFT COUNT
	PUSHJ	P,GCHR1		;GET TERM CHR.
	MOVE	E,C		;HOLD
LOP8:	PUSHJ	P,GCHR1		;GET CHR.
	CAMN	C,E		;TERMINATOR?
	JRST	TEXDON		;YES
	DPB	C,[POINT 5,C-6(M),34];CONVERT TO SIXBIT IF M=6
	LSH	C,-7(M)		;BUT NOT IF M=7
	LSH	V,(M)		;SHIFT VALUE
	OR	V,C		;OR IN CHR.
	SOJG	T,LOP8		;CHR. COUNT DONE?
	PUSHJ	P,GCHR1		;GET CHR
	CAME	C,E		;TERM?
	 JRST	.-2		;NO
TEXRET:	LSH	V,-6(M)		;ADJUST IF ASCII
	MOVEM	V,NM		;STORE VALUE
	TLO	F,NUMF		;SET NUMBER FLAG
	POPJ	P,

	LSH	V,(M)		;NO, ADJUST
TEXDON:	SOJGE	T,.-1		;ENOUGH CHRS.?
	JRST	TEXRET		;YES

;SIXBIT or RADIX50 INPUT  '/string/

STEXT:	MOVEI	T,6		;SIXBIT CHR. COUNT
	MOVEI	V,TXT+1		;SET MAYBE FOR SIXBIT OUTPUT
	JUMPE	B,TEX		;GO DO IF NO BUCKY BITS

;RADIX50 INPUT CTRL1'string

R5TEXT:	TLO	F,NUMF!SCFL!R5FL	;SET FLAGS
	MOVEI	V,TXT		;SET MAYBE FOR RADIX50 OUTPUT
	PUSHJ	P,TMPMOD
	SETZM	SYM		;CLEAR LOCATION
	MOVEI	V,7		;CHR. COUNT
	JRST	LOP3		;GO CONVERT

;TMPMOD, EXTTXT, AMPER, ENSYM

;IF THE FIRST THING TYPED IN IS RECOGNIZABLE AS BEING OF A GIVEN
;DATA TYPE, WE WILL DISPLAY IT IN THAT MODE, AREN'T WE NICE?  --DCS

TMPMOD:	TLNN	F,FIRF		;FIRST THING?
	 MOVEM	V,SAVMOD	;YES, SET UP FOR SPECIAL MODE SET
	POPJ	P,

;MULTI-WORD ASCII INPUT CTRL1"/stringggggggggggggg.../

^EXTTXT:MOVE	M,[EXBUF,,EXBUF+1] 	;CLEAR BUFFER
	SETZM	EXBUF
	BLT	M,EXEND
	MOVE	M,[POINT 7,EXBUF]	;DEPOSIT POINTER
	SETLIN	ASCLIN			;TURN OFF SPECIAL ACTIVATION MODE
	MOVEI	V,5*EXTLN-10		;#CHARS ALLOWED
	PUSHJ	P,GCHR1			;GET CHAR
	MOVE	E,C			;DELIM CHARACTER
	MOVEI	T,42
	IDPB	T,M			;PUT IN "/ OR SOMETHING
	IDPB	E,M
	MOVEI	T,5			;#CHARS BETWEEN INTERVENTIONS

EXL1:	PUSHJ	P,GCHRA			;GET A CHARACTER (DON'T DO ALT MODE THING)
	CAMN	C,E			;ALL DONE?
	 JRST	EXTDN			;YES
EXL3:	JUMPN	T,EXPTH			;MORE TO GO BEFORE INTERVENTION?
	IDPB	E,M			;PUT IN DELIM,BROCK,",DELIM
	MOVEI	T,">"
	IDPB	T,M
	MOVEI	T,42			; " CHAR
	IDPB	T,M
	IDPB	E,M
	MOVEI	T,5			;RESET COUNT
	SUBI	V,4
EXPTH:	IDPB	C,M			;PUT CHAR AWAY
	SOJL	V,[EXL2:PUSHJ	P,GCHR1	;TOSS OUT REMAINING CHARS
			CAME	C,E	;UNTIL DELIMITER SEEN
			 JRST	EXL2
			JRST	EXTDN]	;THEN QUIT
IFN STANFO,<
	CAIN	C,15
	JRST [	MOVEI C,12
		SOJA T,EXL3	]
>;STANFO
	SOJA	T,EXL1			;LOOP

EXTDN:	IDPB	E,M			;ONE MORE DELIMITER
	MOVEI	T,15			;END THE STRING
	IDPB	T,M			;WITH A CRLF
ifn stanfo!tymshr,<
	MOVEI	T,12
	IDPB	T,M
>;ifn stanfo!tymshr
	MOVE	T,[POINT 7,EXBUF]	;LET RAID READ THIS!
	MOVEM	T,STSAV			;SAVE BP FOR DEPO ROUTINE (IF CALLED)
	SETLIN	RADLIN
	TLZ	F,SCFL			;NOT AHEAD ONE
	JRST	SCAN			;RESTART (GET CRLF OR WHATEVER)

;SYMBOL WITH BLOCK NAME MODIFIER

AMPER:
IFE SORTED,<
	PUSH	P,SYMPNT	;SAVE CURRENT SYMBOL TABLE POINTER
>
IFN SORTED,<
	PUSH	P,BID
>
	PUSH	P,V		;SAVE ACS
	PUSH	P,E
	PUSH	P,T
	PUSH	P,F1
	MOVSI	F1,SINGF	;SET UP DUMMY BIT ("YOU STUPID BIT!")
	PUSHJ	P,BLKFND	;FIND THE INDICATED BLOCK
	PUSHJ	P,SCAN		;SCAN NEXT THING
	POP	P,F1		;RESTORE ACS
	POP	P,T
	POP	P,E
	POP	P,V
IFE SORTED,<
	POP	P,SYMPNT	;RESTORE SYMBOL TABLE POINTER
>
IFN SORTED,<
	POP	P,BID
>
	JRST	CSFLUSH		;CLEAR CACHES AND RETURN

ENSYM:	MOVEI	V,CYM	;ALWAYS SET TEMP MODE TO CYMBOLIC IF SYM IS SEEN
	TLNN	F,R5FL	;DON'T CHANGE MODE IF RADIX50 INPUT
	 PUSHJ	P,TMPMOD
	CAIN	C,"&"	;IS IT & ?
	 JUMPE	B,AMPER	;YES, TREAT AS BLOCK NAME, SYMBOL TO FOLLOW
	TLNE	F,R5FL	;RADIX 50 CONVERT?
	 POPJ	P,	;YES
	HRRZ	E,LOCOP	;GET VALUE OF .
	MOVEI	V,45	;RADIX 50 "."
	CAMN	V,SYM	;IS THAT IT?
	 JRST	SYMDOT	;YES
	TLNN	F,FIRF	;FIRST THING?
	 PUSHJ	P,FNDOP	;YES
	JRST	SYMLOK	;GO LOOK UP SYMBOL

;Byte Input

BYTIN:	PUSH	P,D3	;SAVE ACS
	PUSH	P,PV
	PUSH	P,F
	TRO	F,BYTSW	;MAKE EVAL STOP ON COMMAS
	PUSHJ	P,EVAL	;GET NEXT NUMBER
	TLNN	F,USINGF	;UNDEF?
	TLNN	F,VALF	;VALUE?
	JRST	CERR	;NO
	ANDI	V,77	;TRUNCATE
	SETZM	BVAL	;CLEAR VALUE
	SETZM	SHFT	;CLEAR BYTE SIZE
	JUMPE	V,ZERSZ	;ZERO?
	MOVNM	V,SHFT	;NO, STORE COUNT
	TLNN	F,FIRF	;IF FIRST THING, STORE
	DPB	V,[POINT 6,SAVMOD,29] ;BYTE SIZE
	MOVEI	D2,44	;GET MAX (INITIAL SHIFT COUNT)
	MOVEM	D2,SHFTA	;STORE
	MOVEI	D2,1
	LSH	D2,(V)	;FORM MASK.....
	SUBI	D2,1	;...
	MOVEM	D2,BMSK	;STORE
BLOP:	PUSHJ	P,EVAL	;GET NEXT
	TLNE	F,VALF	;VALUE?
	 JRST	CERR	;YES, BUT THIS ISNT POSSIBLE
	CAIE	C,","	;,?
	 JRST	BYDON	;NO, DONE
	PUSHJ	P,EVAL	;GET NEXT
	TLNN	F,VALF	;VALUE?
	 JRST	BYDON	;NO, LEAVE
	TLNE	F,USINGF	;DEFINED?
	 JRST	CERR	;NO
	MOVE	D2,SHFT
	ADDB	D2,SHFTA	;CALCULATE NEW SHIFT COUNT
	AND	V,BMSK	;AND VALUE WITH MASK
	LSH	V,(D2)	;SHIFT
	IORM	V,BVAL	;OR WITH VALUE
	JRST	BLOP	;LOOP

BYDON:	POP	P,PV	;GET OLD FLAGS
	AND	PV,FLGMSK
	ANDCM	F,FLGMSK	;PUT BACK...
	IOR	F,PV	;CERTAIN FLAGS
	MOVE	PV,BVAL	;GET VALUE
	MOVEM	PV,NM	;STORE
	POP	P,PV	;RESTORE ACS
	POP	P,D3
	TLO	F,SCFL!NUMF	;SET FLAGS
	MOVN	V,SHFT	;BYTE SIZE, IF GIVEN
	LSH	V,6	;INTO POSITION
	TRO	V,BYT
	MOVEM	V,SAVMOD	;ALWAYS SWITCH MODE HERE
	POPJ	P,	;LEAVE

FLGMSK:	EHDF!VALF!SINGF!ESPCF!FIRF!EVMF!USINGF,,BYTSW!CONOF
SHFT:	0
SHFTA:	0
BMSK:	0
BVAL:	0

ZERSZ:	SKIPL	D2,SMASK+1	;GET MASK
	 SETCA	D2,		;NORMALIZE
	MOVEM	D2,BMSK		;STORE
ZLOP:	PUSHJ	P,EVAL		;GET NEXT THING
	TLNE	F,VALF		;VALUE?
	 JRST	CERR		;NOT POSIBLE
	CAIE	C,","		;,?
	 JRST	BYDON		;NO, DONE
	PUSHJ	P,EVAL		;GET NEXT
	TLNN	F,VALF		;VALUE?
	 JRST	BYDON		;NO, DONE
	TLNE	F,USINGF	;DEFINED?
	 JRST	CERR		;NO
	MOVEI	D2,44		;INITL POSITION
	MOVEI	D3,		;INITL SIZE
	SKIPN	PV,BMSK		;GET MASK
	 JRST	ZLOP		;ZERO, NO MORE ROOM
	JUMPL	PV,ZERARN	;ALREADY GOT A 1 BIT?
	SUBI	D2,1		;NO, COUNT
	LSH	PV,1		;SHIFT
	JUMPGE	PV,.-2
ZERARN:	ADDI	D3,1		;COUNT SIZE
	LSH	PV,1
	JUMPL	PV,.-2
	MOVE	PV,D2		;SAVE POSITION
	ROT	D3,-6		;GET SIZE
	LSHC	D2,-6		;GET POSITION
	ADDI	D3,BVAL		;AND ADDRS
	IDPB	V,D3		;DEPOSIT VALUE
	ROT	PV,-6		;GET POSITION
	MOVEI	V,0
	IOR	PV,[4400,,BMSK]
	SETCMM	BMSK		;SET THIS FIELD TO 0, NEXT TO 1
	DPB	V,PV		;CLEAR HIGH ORDER BITS
	JRST	ZLOP

;PNTIN	POINT MODE INPUT

PNTIN:	PUSH	P,D3	;SAVE ACS
	PUSH	P,PV
	PUSH	P,F
	TRO	F,BYTSW	;MAKE EVAL STOP ON COMMAS
	PUSHJ	P,EVAL	;GET NEXT NUMBER
	TLNN	F,USINGF	;UNDEF?
	 TLNN	F,VALF	;VALUE?
	  JRST	CERR	;NO
	ANDI	V,77
	LSH	V,=24
	MOVEM	V,BVAL	;SAVE BYTE SIZE
	PUSHJ	P,EVAL	;GET NEXT
	TLNN	F,VALF	;VALUE?
	 CAIE	C,","	;,?
	  JRST	CERR	;YES, BUT THIS ISNT POSSIBLE
	PUSHJ	P,EVAL	;GET NEXT
	TLNN	F,USINGF	;UNDEFINED?
	 TLNN	F,VALF	;VALUE?
	  JRST	CERR	;NO, LOSE
	TLZ	V,777740	;KEEP @ AND XR FIELD
	IORM	V,BVAL
	PUSHJ	P,EVAL
	TLNE	F,VALF
	 JRST	CERR
	CAIE	C,","
	 JRST	PNT44
	PUSHJ	P,EVAL
	TLNN	F,USINGF	;UNDEFINED
	 TLNN	F,VALF	;VALUE
	  JRST	CERR
	MOVN	V,V
	ADDI	V,=35
	JUMPL	V,CERR
	CAILE	V,=35
	 JRST	CERR
PNTDON:	DPB	V,[POINT 6,BVAL,5]
	POP	P,PV	;GET OLD FLAGS
	AND	PV,FLGMSK
	ANDCM	F,FLGMSK	;PUT BACK...
	IOR	F,PV	;CERTAIN FLAGS
	MOVE	PV,BVAL	;GET VALUE
	MOVEM	PV,NM	;STORE
	POP	P,PV	;RESTORE ACS
	POP	P,D3
	TLO	F,SCFL!NUMF	;SET FLAGS
	MOVEI	V,BTP
	MOVEM	V,SAVMOD	;ALWAYS SWITCH MODE HERE
	POPJ	P,	;LEAVE

PNT44:	MOVEI	V,44
	JRST	PNTDON

;Escan -- Scan and Check Reasonable
COMMENT \ CALL THIS TO SCAN, AND CHECK FOR UNDEFINED
 SYMBOLS -- IF UNDEFINED, ABORT UNLESS IT'S OK FOR
 AN UNDEFINED SYMBOL TO BE HERE
\

^ESCAN:	PUSHJ	P,SCAN		;NEED TO SCAN
	TLNE	F,SYMF		;SYMBOL
	 TLNN	F,UNDF		; AND UNDEFINED?
	  POPJ	P,		;NO, OK
	PUSH	P,F		;SAVE (PU WILL CLEAR IF ABORT)
	PUSHJ	P,SCAN		;GET NEXT THING
	TLNN	F,SYMF!NUMF	;SYMBOL, NUMBER, OR
	 TRNN	D1,UOK		; NOT OK TO BE UNDEF?
	  JRST	PU		;RIGHT, UNDEF ERROR
	POP	P,F		;GET UNDF, SCFL (LOOKAHEAD) BACK
	POPJ	P,		;RETURN NORMALLY

;Eval

BEGIN EVAL

^EVAL:	TLZ	F,VALF!SINGFF!FIRF!EVMF
	TRZ	F,CONOF
	TLZE	F,EHDF		;ALREADY GOT ONE?
	 JRST	[MOVE	B,SAVB		;YES
		 MOVE	C,SAVC
		 POPJ	P,]
	PUSHJ	P,ESCAN		;NO
	TLNN	F,NUMF!SYMF	;NUMBER OR SYMBOL?
	 JRST	NONUM3
	TLNE	F,SYMF		;SYMBOL?
	 TLO	F,SINGF!USINGF!VALF	;YES
	TLNE	F,UNDF		;DEFINED?
	 POPJ	P,		; NO
	TLZ	F,USINGF
	TLO	F,FIRF		;DO NOT LOOK FOR OPCODES
LOOP1.:	MOVE	D3,NM		;GET VALUE
LOOP1:	PUSHJ	P,ESCAN		;GET NEXT THING
	TLNE	F,SYMF!NUMF	;SYMBOL OR NUMBER?
	 JRST	PNT1		;YES
	TRNE	D1,AROP		;ARITH OP?
	 JRST	ARP		;YES
	CAIN	C,","		;,?
	 JRST	COM1		;YES, HANDLE
	JSR	ATCHK		;CHECK FOR @... HANDLE
	 JRST	LOOP1		;YES, IT WAS A @
	TLO	F,ESPCF
	PUSHJ	P,LPRNC		;CHECK FOR AND HANDLE (
	 JRST	PNT1		;YES
LEVE:	TLO	F,EHDF!VALF	;WE'RE AHEAD AND WE HAVE A VALUE
	MOVE	V,D3		;GET VALUE
	MOVEM	B,SAVB
	MOVEM	C,SAVC		;SALIENT VALUES
	POPJ	P,

ARP:	TLZ	F,SINGF
	CAIE	C,"/"		;/?
	 CAIN	C,"*"		;*?
	  JRST	MULDIV		;ONE OR THE OTHER
LOP1:	CAIN	C,"-"		;-?
	 JRST	SUBT		;YES
	CAIN	C,"!"
	 JRST	EXCL
	CAIN	C,40		;SPACE?
	 TLO	F,ESPCF		;YES, SET FLAG
LOOP3:	SKIPA	PV,[ADD D3,(P)]	;GET OPERATOR
SUBT:	 MOVE	PV,[SUB D3,(P)]	;  LIKEWISE
LOP4:	PUSHJ	P,ESCAN		;GET NEXT THING
LOOP2:	TLNN	F,NUMF		;NUMBER?
	 JRST	NONUM2		;NO
LOOP7:	TLZE	F,EVMF		;NEGATE?
	 MOVNS	NM		;YES
	TLNE	F,ESPCF		;SPACE SEEN?
	 HRRZS	NM		;YES, CLEAR LEFT HALF
	PUSH	P,NM		;SAVE NUMBER
LOP2:	PUSHJ	P,ESCAN		;GET NEXT THING
	TLNE	F,NUMF		;NUMBER?
	 JRST	PNT1		;YES
	TRNN	D1,AROP		;ARITH OP?
	 JRST	NOOP1		;NO
LOP5:	CAIN	C,"*"		;*?
	 JRST	MULP		;YES
	CAIN	C,"/"		;/?
	 JRST	DIVP		;YES
	XCT	PV		;DO OP
	SUB	P,[1,,1]	;POP
	JRST	LOP1

MULP:	SKIPA	M,[IMULM D2,(P)]	;GET OPERATOR
DIVP:	 MOVE	M,[IDIVM D2,(P)]	;  LIKEWISE
LOOP5:	PUSH	P,M		;SAVE
	PUSHJ	P,ESCAN		;GET NEXT THING
	POP	P,M		;GET BACK
	TLNN	F,NUMF		;NUMBER?
	 JRST	NONUM1		;NO
LOOP6:	MOVE	D2,NM		;GET OPERAND
LOP3:	EXCH	D2,(P)		;SWITCH AROUND
	XCT	M		;DO OP
	JRST	LOP2

NONUM1:	PUSHJ	P,LPRNC		;CHECK FOR ( AND HANDLE
	 JRST	LOOP6		;YES IT WAS
	JSR	ATCHK		;CHECK FOR @ AND HANDLE
	 JRST	LOOP5		;YES IT WAS
	CAIE	C,40		;SPACE?
	 CAIN	C,"+"		;+?
	  JRST	LOOP5		;YES, IGNORE
	CAIE	C,"-"		;-?
	 JRST	INERR		;NO
	PUSHJ	P,ESCAN		;GET NEXT
	TLNN	F,NUMF		;NUMBER?
	 JRST	INERR		;HOW LONG CAN THIS GO ON?
	MOVN	D2,NM		;YES
	JRST	LOP3
NOOP1:	CAIN	C,","		;,?
	 JRST	COM2		;YES, HANDLE
	JSR	ATCHK		;CHECK FOR @ AND HANDLE
	 JRST	LOP2		;YES, IT WAS
NOOP.1:	XCT	PV		;DO OP
	SUB	P,[1,,1]	;POP
	TLO	F,ESPCF
	PUSHJ	P,LPRNC		;TEST FOR AND HANDLE (
	 JRST	PNT1		;YES, IT WAS A (
	JRST	LEVE
NONUM2:	PUSHJ	P,LPRNC		;CHECK FOR ( AND HANDLE
	 JRST	LOOP7		;YES, IT WAS A (
	JSR	ATCHK		;CHECK FOR @ AND HANDLE
	 JRST	LOP4		;YES, IT WAS A @
	CAIE	C,40		;SPACE?
	 CAIN	C,"+"		;+?
	  JRST	LOP4		;YES, IGNORE
	CAIE	C,"-"		;-?
	 JRST	LEVE		;NO
	TLC	F,EVMF		;COMPLIMENT SWITCH 
	JRST	LOP4

MULDIV:	MOVE	PV,[ADD D3,(P)]	;GET DUMMY OP
	MOVEI	D3,		;GET DUMMY OPERAND
	PUSH	P,NM		;SAVE NUMBER
	JRST	LOP5

EXCL:	MOVE	PV,[IOR D3,(P)]
	JRST	LOP4

ATCHK:	0
	JUMPN	B,ATCHKX
	CAIN	C,"@"	;@?
	TLOA	D3,20	;YES, SET @ BIT
ATCHKX:	AOS	ATCHK	;NO, SKIP
	JRST	@ATCHK	;LEAVE

NONUM3:	PUSHJ	P,LPRNC	;CHECK FOR ( AND HANDLE
	 JRST	LOOP1.	;YES, IT WAS (
	CAIN	C,40	;SPACE?
	 JRST	EVAL	;YES, IGNORE
	CAIN	C,"-"
	 JRST	[MOVEI	D3,0	;YES , SET UP DUMMY ZERO
		 TLO	F,FIRF	;SET FLAG
		 JRST	SUBT]	;GO SUBTRACT
	CAIN	C,","
	 JRST	[MOVEI	D3,0	;YES, SET UP DUMMY ZERO
		 TLO	F,FIRF
		 JRST	COM1]
	CAIE	C,"@"	;IS IT @?
	 POPJ	P,	;NO, LEAVE
	JUMPN	B,CPOPJ	;LEAVE IF BUCKY BITS
	MOVSI	D3,20	;YES, GET @ BIT
	TLO	F,FIRF
	JRST	LOOP1

COM1:	TRNE	F,BYTSW	;STOP ON ,?
	 JRST	LEVE	;YES
	HRLZS	D3	;SHIFT RIGHT HALF TO LEFT HALF
	TLO	F,ESPCF	;TRUNCATE FURTHER NUMBERS TO 18 BITS
	PUSHJ	P,ESCAN	;GET NEXT THING
	TLNN	F,NUMF	;NUMBER?
	 JRST	CM1	;NO
LOOP4:	TRNE	F,CONOF	;I/O OPCODE?
	 JRST	[LSH	D3,6  ;YES
		 TLZ	D3,700377
		 JRST	PNT1]
	LSH	D3,5	;MAKE AC FIELD
	TLZ	D3,777000	;...
PNT1:	MOVE	PV,[ADD	D3,(P)];GET DUMMY ADD (+)
	JRST	LOOP2
CM1:	CAIN	C,","	;ANOTHER ,?
	 JRST	LOOP3	;YES
	JRST	LOOP4	;NO
COM2:	TRNE	F,BYTSW	;STOP ON ,?
	 JRST	NOOP.1	;YES
	PUSHJ	P,ESCAN	;GET NEXT THING
	TLNN	F,NUMF	;NUMBER?
	 JRST	CM2	;NO
LLP4:	MOVE	M,(P)	;GET THING
	TRNE	F,CONOF	;I/O OPCODE?
	 JRST	[ANDI	M,774		;YES
		 LSH	M,22+6
		 JRST	LLQ4]
	ANDI	M,17	;MAKE AC FIELD
	LSH	M,22+5
LLQ4:	MOVEM	M,(P)
	XCT	PV	;DO OP
	SUB	P,[1,,1]	;POP
	TLO	F,ESPCF
	JRST	PNT1
CM2:	CAIE	C,","	;ANOTHER ,?
	 JRST	LLP4	;NO
	XCT	PV	;DO OP
	SUB	P,[1,,1]	;POP
	HRLZS	D3	;SWAP
	JRST	LOOP3-1
LPRNC:	CAIE	C,"("	;(?
	 JRST	LL1	;NO
	PUSH	P,D3	;YES, SAVE D3
	PUSH	P,M
	PUSH	P,PV
	PUSHJ	P,EVAL	;EVALUATE THING IN ()
	TLNN	F,VALF	;GET BACK A VALUE?
	 JRST	CERR	;NO
	PUSH	P,V	;YES, SAVE IT
	PUSHJ	P,EVAL	;GET NEXT THING
	CAIN	C,")"	;IS IT A )?
	 TLNE	F,VALF!SYMF!SINGF;...
	  JRST	CERR	;NO, ERROR
	POP	P,NM	;PUT VALUE IN NM
	MOVSS	NM	;SWAP IT
	POP	P,PV	;RESTORE
	POP	P,M
	POP	P,D3
	TLOA	F,FIRF!VALF!NUMF
LL1:	 AOS	(P)
	POPJ	P,
BEND EVAL
^EVAL_EVAL
BEND SCAN

 1OKÈ