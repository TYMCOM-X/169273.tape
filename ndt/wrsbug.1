begin "TAKEIT"

require "SAIL.DEF" source!file;
require "FRMOP.DEF" source!file;
SetVersion(3503);

! version 3503 - 10/10/79 W.R.Soley - 
	1) Shortened min takedown and grace times for HU user.
	2) Changed the method of killing jobs (now does HALT,
	removes page 0 and replaces it with a private one,
	deposits a LOGOFF uuo in AC 1, a 0 in AC 0, and does
	a start at location 1).
	3) Uses TALK uuo to send stuff to other terminals now.
	4) ATTACH command requires WC license now.
	5) Added the OPER command to change oper names.
;	
! version 3502 - 7/10/79 W.R.Soley - fixes problem causing initials
	to be null string if user was WC license.
;
! version 3501 - 7/10/79 W.R.Soley - check for POKE failing.
	Make CloseLog a no-op the second time around.
	Make CleanUp safe to call more than once.
;
! version 35 - 6/6/79 W.R.Soley - no modification, transmitted to world.
;
! version 3403 - 6/1/79 W.R.Soley - put the word "in" back in the
	warning messages which was accidentially omitted.
;
! version 3402 - 5/31/79 W.R.Soley - fixed time scanner to work no
	matter what phase of the moon it is. (fixes "@HH:MM")
;
! version 3401 - 5/25/79 W.R.Soley - changed 2 minute warning to always
	occur.  It used to only happen if Grace < GraceMin.
;
! version 34 - 5/6/79 W.R.Soley - added CONFIG command and internal
	cosmetics.
;
! version 3307 - 5/2/79 W.R.Soley - added stuff to send message to
	CTY previous to hang or crash.
;
! version 3306 - 4/26/79 W.R.Soley - added abilities to cope with
	and trigger the "Notice to Quit" interrupt using the new
	EVICT uuo.  Happens at countdown=0 and at hang.
;
! version 3305 - 4/25/79 W.R.Soley - tracked down bug causing it
	to IO error if no TAKEIT.LOG found.
;
! version 3304 - 4/21/79 W.R.Soley - fixed bug cuasing bedlem at 
	countdown = 0.
;
! version 3303 - 4/20/79 W.R.Soley - put back 1 minute warning in
	the unconditional warning list
;
! version 3302 - 4/19/79 W.R.Soley - fixed bug in log file stuff.
	Log file doesn't update anymore - has to superceed.
;
! version 3301 - 4/9/79 W.R.Soley - cosmetic changes, log now in most
	recent first order, log will be truncated at 50 pages, log
	will be attempted 15 times at 1 sec intervals.
;
! version 33 - 4/1/79 W.R.Soley - added the device: argument to systat
	and job-specs.
;
! version 32 - 3/30/79 W.R.Soley - fixed echo problem as best as can
	be done by doing LevDef at end of every input.
;
! version 31 - 3/29/79 W.R.Soley - added "job-spec" parser to command
	which take job number.  May not detach another job.  Will
	also detect being hung and go away.  May now ^C from any
	dialogue and be returned to the command level.
;
! version 30 - 3/21/79 W.R.Soley - fixed a few things (hopefully),
	added the "GRIPE" command which just dumps stuff to the LOG
	file up to a ^D.
;
! version 29 - 3/21/79 W.R.Soley - removed "ABORT" command, several 
	bug fixes: fixed JBTPRV problem if bad oper password,
	fixed spaces in log file problem, fixed CANCEL command to
	leave user in manual mode, added "AUTO <time>[,<reason>]".
;
! version 28 - 3/17/79 W.R.Soley - fixed the problem preventing the
	slave from being stopped at the proper time.
;
! version 27 - 3/12/79 W.R.Soley - added the Exempt command.
	Miscelaneous bugfixes.
;
! version 26 - 3/11/79 W.R.Soley - changed Auto to force Watch.
	Setup for selective logging of commands.
;
! version 25 - 3/11/79 W.R.Soley - added logging to
	DSK:<myname>.LOG[fpn]
;
! version 24 - 3/12/79 W.R.Soley - fixed a few things about version
	23's changes.  Added the NXjobCount line back to TakeStat
	should it be in manual mode.
;
! version 23 - 3/11/79 W.R.Soley - major modification, created a
	manual mode - now requires "AUTO" command to perform as
	program did before.  New commands: AUTO, MANUAL, SCHED,
	CANCEL, QUIT
;
! version 22 - 1/30/79 W.R.Soley - shortened SlaveHung time limit.
	Rearranged b'cast messages - left only 10,5,2 and 1.  Set
	to shut system at 1 minute.
;
! version 21 - 1/11/79 W.R.Soley - fixed the GetLine routine to
	recognize that <line-waiting> is satisfied when a <brace>,
	<tilde> or <rub> are recieved as well as ctrl chars.  This
	was occasionally causing TAKEIT to hang in TI wait if
	one of these characters were sent without a line terminator.
;
! version 20 - 1/8/79 W.R.Soley - fixed bug in Update!Sys!Message
	routine causing garbage to print for minutes remaining.
	Fixed bug causing excessive type-ahead to hang things up.
	Fixed problem where typeing part of a line will hang
	the countdown.
;
! version 19 - 1/5/79 W.R.Soley - the first message will now be at
	the one hour mark or at takeit startup whichever is last.
	This way, takeit may be started several hours before the
	system is actually to be taken and will be completely
	dormant from other users point of view until T-1 hour.
	Also fixed MINS to give time in format HHH:MM as opposed to
	NNNNNN minute(s).  Also added the reason for takedown to
	the ACCESS.MSG thingy.  Reworked all of the countdown
	software.  Fixed bug reported by Ed Gauci about being
	unable to reattach - OPER-NAME wasn't being cleared.
;
! version 18 - 12/15/78 W.R.Soley - added "Kill (all jobs)" command,
	fixed TakeStat to show action=crash,  ** now kills detached
	jobs durring grace even if they're running **,  minimum grace
	period is now 5 minutes,  leading blanks are now ignored in
	commands, added "* STOPPED Job <n>, <SLAVE>" message.
;
! version 17 - 12/11/78 W.R.Soley - cosmetic changes.
;
! version 16 - 12/09/78 W.R.Soley - added the requirement of giving
	your oper-name upon reattaching to TAKEIT.  Added the 'set'
	command.  Added the 'crash' command.
;
! version 15 - 12/06/78 W.R.Soley - fixed infinite loop problem
	if slave port is zapped while setting up slave.  Also
	made cosmetic change to "?" msg for boots-loaded question.
	Also changed CheckAlone to ignore ^C's copies.  Also
	added "?" msgs for time and grace.
;
! version 14 - 12/05/78 W.R.Soley - added the use of the CONT UUO
	to put self in user mode if attached to while detached.
;
! version 13 - 12/05/78 W.R.Soley - changed spelling of immediately
	(from imediately) in broadcast message.
;
! version 12 - 12/04/78 W.R.Soley - changed EXEMPT to recognize 
	CHKPNT as the job with ACT: inited.  Also fixed HANG to
	indicate the name of a program running on an exempt job
	when it is hung.
;
! version 11 - 11/29/78 W.R.Soley - added check to see if another
	job is running takeit - if so it dies.  Also add ability
	to run to completion detached.
;
! version 10 - 11/28/78 W.R.Soley - added message to indicate what
	license(s) must be given to program.  Also improved the
	response(s) from typing "?" - all prompts now respond to
	"?" by producing a brief help message.
;
! version 9 - 11/27/78 W.R.Soley - added ability to realize that
	the OPER password file lacks WC license.
;
! version 8 - 10/26/78 W.R.Soley - added OPER password reading
	ability - will now run for any user with WC set on job
	or who supplies name and password of an oper-name with
	WC or HU.  In the case of HU, the 10 minute minimums will
	be enforced.;


string Initials, Com, Reason, SysName;
integer Job, J, Grace, Next, JBTLIC, SysMsg, M, SchedSave;
integer JBTSTS, JBTAUN, MyPPN, MyJob, HighJob, JBTUN1, JBTUN2, JBTPRV;
integer JBTNAM, Brk, Flag, SchprvSave, Hold, JBTFPN, DDBLDB;
integer JBTUID, Time!0, jps, jpm, jph, JobN, Action, WC, Mode, PrvSave;
integer LastStates, LastPoll;
boolean Sys!Message, DownFlag, DetachFlag, BroadcastFlag, Watch;
boolean InitFlag, WantSuperShut;
ifc declaration(!SKIP!) thenc elsec external boolean !SKIP!; endc
define sub!title = {comment};
define $$PROU = '255;
external integer array GOGTAB[0:$$PROU];

define ForEachJob = {For Job_1 step 1 until peek(HighJob)};

sub!title	Define special parameters;

define	MinTakedown = 2;	! minimum minutes to take down;
define	MinGrace = 1;		! minimum minutes in grace period;
define	KillLimit = 120;	! seconds to allow job to take to die;
define	HaltLimit = 120;	! seconds to allow job to take to stop;
define	EvictLimit = 120;	! seconds to guarentee job for cleanup;
define	ShutTime = 1;		! shut system at time=1 minutes;
define	firstMsg = 30;		! minutes for first b'cast warning msg;
define	noSchPrv = true;	! don't run with SchPrv;
define	debug = false;		! don't compile for debugging;
define	SlowPollRate = 5;	! polling interval for manual mode;
define	LOL = 62;		! length of fill line for TALK msgs;

! *** don't change the order of these *** ;
define
  manual = 0,
  boots!loaded = 1,
  stand!alone = 2,
  deposit!30 = 3;

! these are break table identifiers;
define
  blanks = 1,
  digits = 2,
  nonBlanks = 3,
  comma = 4,
  noPunct = 5,
  SpecBreak = 6,
  fcblanks = 7;

! Mode values;
define
  Auto = 1;
! Manual = 0;		! already defined;

! Flags to pass to various procedures to modify their behavoir;
define
  Silent = true;

! Arguments and values related to UUO calls, etc.;
define	DiscMask = {(bit(19)+bit(20))};	! Mask of bits in JBTPRV that
			control what to do if cmd port zapped;
define	DiscCont = {bit(19)};	! Bits to set continue on disconnect;
define	AttachUUO = -'6;	! Attach (or detach) a port;
define	BitpokUUO = -'120;	! Change certain bits in physical loc;
define	ContUUO = -'125;	! Continue a job from monitor mode;
define	CreauxUUO = -'44;	! Build a circuit;
define	DateUUO = '14;		! Obtain DEC-format date;
define	DatuuoUUO = -'55;	! Convert dates;
define	DevnamUUO = '64;	! Get physical device name;
define	EvictUUO = -'134;	! Hack the NTQ interrupt for some job;
define	GettabUUO = '41;	! Get miscelaneous garbage from system;
define	HangUUO = -'32;		! Zap a job (or port);
define	HiberUUO = '72;		! Sleep until something happens;
define	LogoffUUO = -'130;	! Run SYS:LOGOUT or such;
define	MstimeUUO = '23;	! Obtain MS past midnight;
define	PeekUUO = '33;		! Read physical core locations;
define	PjobUUO = '30;		! Get my job number;
define	PokeUUO = -'12;		! Write physical core locations;
define	SetjalUUO = -'21;	! Set some bits in JBTSTS;
define	SetnamUUO = '43;	! Set JBTNAM and clear JBTFPN;
define	SetotfUUO = -'126;	! Set other frame;
define	SetuuoUUO = '75;	! Speak to CTY:;
define	SysdvfUUO = -'24;	! Return DDB's from DDB chain;
define	VclearUUO = -'66;	! Clear private page;
define	VcreatUUO = -'67;	! Create private page;
define	ZapcirUUO = -'45;	! Zap all circuits except command port;


! Handle debug stuff and other garbage;

ifc debug
  thenc redefine noSchPrv = true;
  elsec endc

sub!title	Inform person compiling about what's going on;

! The following glibble appears on the terminal at compile time as
well as in response tothe "CONFIGURATION" command...
;

define CFG(A) = {redefine Config = cvms(Config) & {& A & crlf}};
define Config = {crlf & version & crlf};
ifc debug
    thenc CFG ("Debug version: HANG+CRASH+DETACH+SCHED+TALK disabled.");
    elsec CFG ("Production version.");
    endc
ifc compiler!switch("B")
    thenc CFG ("Loaded with BAIL.");
    elsec CFG ("No BAIL.");
    endc
CFG ("License required: WC RC OP SY JL WF.");
ifc noSchPrv
    thenc CFG ("SCHPRV disabled.");
    elsec CFG ("SCHPRV enabled.");
    endc
CFG ("Minimum takedown time is "&cvs(MinTakedown)&" minutes.");
CFG ("Minimum grace period is "&cvs(MinGrace)&" minutes.");
CFG ("First warning at "&cvs(FirstMsg)&" minutes.");
CFG ("System is shut at "&cvs(ShutTime)&" minutes.");
CFG ("Kill time limit is "&cvs(KillLimit)&" seconds.");
CFG ("Halt time limit is "&cvs(HaltLimit)&" seconds.");
CFG ("Evict time limit is "&cvs(EvictLimit)&" seconds.");
CFG ("Low priority polling interval is "&cvs(SlowPollRate)&" seconds.");
CFG ("Fill line length for TALK msgs is "&cvs(LOL)&" chars.");
CFG (null); require crlf&Config message;

sub!title	Define commands;

define	ManMode = (1 lsh Manual);  ! command legal in manual mode only;
define	AutoMode = (1 lsh Auto);   ! command legal in auto mode only;
define	ReqWC = bit(16);	   ! command requires WC license;
define	Logit = bit(17);	   ! command gets logged;
define	AnyMode = '777777;	   ! command legal in any mode;

define
  comcnt = 0,
  comtxt = {},
  comhlp = {"}&ctrl("Z")&{One of the following:} & crlf,
  comfoo = {},
  comflg = {},
  cdef (c,h,f) = {
    redefine comcnt = comcnt + 1;
    redefine comfoo = {com!}&cvps(c);
    evaldefine comfoo = comcnt;
    redefine comtxt = cvms(comtxt) & {,"} & 
	scanc(cvps(c),null," "&ht,"SINK") & {"};
    redefine comflg = cvms(comflg) & {,} & cvps(f);
    redefine comhlp = cvms(comhlp) & {  } & cvps(h) & crlf;
    };

! Add commands to following table: arguments are
    1 - command keyword,
    2 - command help line (pseudo BNF),
    3 - flag bits (combinations of...
	ManMode - allowed only in manual mode,
	AutoMode - allowed only in auto mode,
	AnyMode - allowed in any mode,
	Logit - command line will be entered in TAKEIT.LOG,
	ReqWC - available only to users with WC license)
;

cdef(action	,ACtion [{BootsLoaded|Manual|StandAlone|Crash}],
		AutoMode+Logit);
cdef(attach	,ATtach to <job-spec>, ManMode+Logit+ReqWC);
cdef(auto	,AUtomatic (takedown) [{@<time>|<mins>}[ <reason>]],
		ManMode+Logit);
cdef(cancel	,CAncel (takedown and notify users), AutoMode+Logit);
cdef(clear	,CLear (jbtsts bits for) <job-spec>,
		AnyMode+Logit+ReqWC);
cdef(configuration,CONFiguration (of TAKEIT), AnyMode);
cdef(continue	,CONTinue (countdown), AutoMode+Logit);
cdef(crash	,CRash (system), AnyMode+Logit+ReqWC);
cdef(detach	,Detach {<null>|<job-spec>}, AnyMode+Logit);
cdef(exempt	,Exempt <job-spec>, AnyMode+Logit);
cdef(grace	,GRAce (period is) <minutes>, AutoMode+Logit);
cdef(gripe	,GRIpe <bug-description>, AnyMode);
cdef(hang	,HAng (system), AnyMode+Logit);
cdef(help	,HElp, AnyMode);
cdef(hold	,HOld (countdown), AutoMode+Logit);
cdef(inst	,Instructions (for use of TAKEIT), AnyMode);
cdef(kill	,Kill <job-spec>, AnyMode+Logit);
cdef(oper	,Oper <oper-name>, AnyMode+Logit);
cdef(quit	,Quit (from program), ManMode+Logit);
cdef(talk	,Talk {ALL|TTY<ttyno>:|JOB <job-no>} <message>,
		AnyMode+Logit);
cdef(sched	,SChedule (is) {<null>|Answer|SHut|SUper-shut},
		AnyMode+Logit);
cdef(set	,SEt (countdown to) {@<time>|<mins>}, AutoMode+Logit);
cdef(systat	,SYstat [<job-spec>][HEADING], AnyMode);
cdef(unexempt	,Unexempt <job-spec>, AnyMode+Logit);
cdef(watch	,WATch {ON|OFF}, AnyMode+Logit);
cdef(warning	,WARning, AutoMode+Logit);
cdef(null	,<control-T> (type countdown), AnyMode);

redefine comtxt = cvms(comtxt)[2 to inf];
redefine comflg = cvms(comflg)[2 to inf];
redefine comhlp = cvms(comhlp) & {"};
preset!with comtxt;
string array CMDS[1:comcnt];
preset!with comflg;
integer array CMDF[1:comcnt];


sub!title	Define "reasons" for take-down;

define
  reacnt = 0,
  reatxt = {},
  rdef (reas) = {
    redefine reacnt = reacnt + 1;
    redefine reatxt = cvms(reatxt)&{,"}&cvps(reas)&{"};
    };

rdef(System going down as per schedule.);
rdef(System going down to reload monitor.);
rdef(System going down for hardware maint.);
rdef(System going down for software maint.);
rdef(System going down for network maint.);
rdef(System going down for emergency maint.);
rdef(System going down for software development.);

redefine reatxt = cvms(reatxt)[2 to inf];
preset!with reatxt;
string array REAMSG[1:reacnt];


define comins = {ctrl("Z") & "
For complete instructions, please see the TAKEIT manual.

To hang jobs, one at a time, as with HANGUP, use the command
        KILL job# (user)
where job# is the job number, (user) is the username of the job.
Other criteria may be given to kill a job or group of jobs, for
details, type ""KILL ?"".

To take the system down, in a courteous manner, use the command
        AUTO
and answer the questions as required.  If you are confused by a
question, type ""?"" and it will be explained in detail and reask.
This will automatically handle notification of users and shutting
the system.  Progress reports will be given.

To take the system down, in a dis-courteous manner, like the HANGUP
program used to, use the command
        HANG

For a complete (but brief) list of all available commands, say
        HELP
"};


sub!title	Main program block definition for dynamic allocation;

JobN _ rh(call(hl('15)+hr('11),"GETTAB"));
begin "MAIN"
    label CommandLevel;
    integer array JS[1:JobN];	! see below;
    integer array UID[1:JobN];	! universal frame ID for job;
    string array JU[1:JobN];	! User name for job N;
    string array JDev[1:JobN];	! Devices ass'd to job N;
    string array MsgQ[1:JobN];	! Messages pending for job;

! array JS description...
	bit(0)		- This jobs timer exceeded (hang/evict) limit
	bit(1:8)	- Seconds until job is tardy (timer)
	bit(9)		- This job has been evicted
	bit(10)		- This job has been halted
	bit(11)		- This job has been killed
	bit(16)		- This job is immune
	bit(17)		- This job is exempt
	bit(18:35)	- UUN of job
;
define
    hc(i) = {(i ash 27)},
    expireFlag = {bit(0)},
    evictFlag = bit(9),
    haltFlag = bit(10),
    killFlag = bit(11),
    immuneFalg = bit(16),
    exemptFlag = bit(17),
    jsb(i) = {((i lsh (11-35)) land 7)};

sub!title	Forward procedure definitions;

forward simple integer procedure States;
forward simple procedure TALK(string MSG);
forward simple procedure Schedule(integer SCHED;
			boolean SilentFlag(false));
forward simple boolean procedure OPR;
forward procedure ABORT;
forward procedure FATAL(string msg);
forward simple procedure CleanUp;
forward simple procedure SetOper;
forward boolean procedure CONFIRM;
forward simple boolean procedure Exist(integer JOB);
forward simple string procedure USER(integer JOB);
forward procedure Automatic (string Arg);
forward procedure ClearAutomatic;
forward simple procedure Log (string Msg);
forward simple procedure CloseLog;
forward simple procedure OpenLog;
forward simple procedure HangJob (integer Job);
forward simple integer procedure Peek(integer Adr);
forward simple string procedure Queue(integer STS);
forward simple boolean procedure Exempt(integer Job);
forward simple boolean proc Idle(integer Job);
forward simple string procedure JobLine (integer Job);
forward simple boolean procedure Detached (integer Job);
forward simple procedure Detach (integer Job(0));
forward simple boolean procedure OwnsDevice (integer Job,Dev);
forward simple boolean procedure Evict (integer Job);
forward simple string procedure DayTime;
forward simple procedure lprint(string msg);
forward simple procedure Talk!(integer Job);

sub!title	ScanSpec and Apropos for parsing job specs;

integer	NameSpec,
	GanSpec,
	UunSpec,
	DevSpec,
	JobSpec;
boolean	AllSpec,
	IdleSpec,
	ExemptSpec,
	NonExemptSpec,
	WaitSpec,
	DetSpec,
	HeadSpec,
	MySelfSpec,
	DefaultSpec;
string	QueueSpec,
	UserSpec;

integer	Jobs!;		! keep count of apropos jobs;

boolean procedure ScanSpec (string Spec);
begin "ScanSpec"
    string Token;
    integer Brk;
    simple boolean procedure Match (string T);
	return(equ(Token,T[1 for length(Token)]));
    define Conflict (Msg) = {begin
	print("?conflicting Msg specified",crlf);
	return(false);
	end};
    Jobs! _ 0;		! reset apropos job count;
    NameSpec_GanSpec_UunSpec_DevSpec_JobSpec_0;
    UserSpec_QueueSpec_null;
    HeadSpec_AllSpec_MySelfSpec_
	ExemptSpec_NonExemptSpec_IdleSpec_WaitSpec_DetSpec_false;
    DefaultSpec_true;
    if Spec="?" then begin
	print("Job spec options are:
  (username)   - jobs logged into given username
  [gan,uun]    - jobs logged into this ppn
  [gan,*]      - jobs logged into this gan
  <program>    - jobs running this program
  job-number   - this job
  queue-name   - jobs in this queue (state)
  device:      - jobs owning this device
  IDLE         - only idle jobs
  DETACHED     - only detached jobs
  NONEXEMPT    - only non-exempt jobs
  EXEMPT       - only exempt jobs
  ALL          - all jobs (exempt too)
  WAIT         - ask for confirmation for each job
    Note: the set of jobs acted upon by the command is the 
        intersection of the sets given.
    Note: NonExempt is implied by the absence of Exempt and All.
");
	return(false);
	end;
    while length(Spec) do begin "TokenLop"
	Token _ scan(Spec,SpecBreak,Brk);
	if length(Token)=0 then continue;
	case Brk of begin
	    [")"] if length(UserSpec)=0
		then UserSpec _ Token
		else Conflict(UserName);
	    [":"] if DevSpec=0
		then DevSpec _ cvsix(Token)
		else Conflict(Device);
	    [","] if GanSpec=0
		then GanSpec _ cvo(Token)
		else Conflict(GAN);
	    ["]"] if UunSpec=0
		then UunSpec _ cvo(Token)
		else Conflict(UUN);
	    [">"] if NameSpec=0
		then NameSpec _ cvsix(Token)
		else Conflict(Name);
	    else if cvd(Token) then if JobSpec=0
		then JobSpec _ cvd(Token)
		else Conflict(Job)
	    else if length(Token)=2 then if length(QueueSpec)=0
		then QueueSpec _ Token
		else Conflict(Queue)
	    else if Match("ALL") then AllSpec _ true
	    else if Match("WAIT") then WaitSpec _ true
	    else if Match("DETACHED") then DetSpec _ true
	    else if Match("IDLE") then IdleSpec _ true
	    else if Match("NONEXEMPT") then NonExemptSpec _ true
	    else if Match("EXEMPT") then ExemptSpec _ true
	    else if Match("HEADING") then HeadSpec _ true
	    else begin
		print("?unrecognized token: ", Token, crlf,
		    " type ""?"" argument for help", crlf);
		return(false);
		end
	    end;
	end "TokenLop";
    if NonExemptSpec then ExemptSpec _ false;
    DefaultSpec _ not (NameSpec or GanSpec or UunSpec or JobSpec
	or QueueSpec or IdleSpec or ExemptSpec or DetSpec or DevSpec
	or AllSpec or UserSpec or NonExemptSpec);
    return(true);
    end "ScanSpec";

simple boolean procedure Apropos (integer Job);
begin "Apropos"
    simple boolean procedure CheckJob (integer Job);
    begin "CheckJob"
	print(JobLine(Job),",");
	return(Confirm);
	end "CheckJob";
    boolean A;
    A _ (   not DefaultSpec
	and Exist(Job)
	and (MySelfSpec or (Job neq MyJob))
	and (NameSpec=0 or NameSpec=peek(JBTNAM+Job))
	and (GanSpec=0 or GanSpec=lh(peek(JBTAUN+Job)))
	and (UunSpec=0 or UunSpec=rh(peek(JBTAUN+Job)))
	and (JobSpec=0 or JobSpec=Job)
	and (length(UserSpec)=0 or equ(UserSpec,User(Job)))
	and (length(QueueSpec)=0 or
	    equ(QueueSpec,Queue(peek(JBTSTS+Job))))
	and (DetSpec=false or Detached(Job))
	and (AllSpec or ExemptSpec = Exempt(Job))
	and (IdleSpec=false or Idle(Job))
	and (DevSpec=0 or OwnsDevice(Job,DevSpec))
	and (WaitSpec=0 or CheckJob(Job))
    );
    if A then Jobs! _ Jobs! + 1;
    return (A);
    end "Apropos";

simple string procedure Jobs;
case Jobs! of begin
    [0] return("No jobs");
    [1] return("1 job");
    else return(cvs(Jobs!)&" jobs") end;


sub!title	String I/O routines - noop if detached;

simple procedure LevDef;
begin
    integer SKIP;
    Skip _ !Skip!;
    auxclv(-1,0,'11);
    !Skip! _ Skip;
end;

simple procedure XPrint(integer X;string S);
    ! This procedure is setup in GOGTAB to be called by the
	Print command;
begin "XPrint"
    while length(S)
	do auxclv(-1,lop(S),'3);
    LevDef;
end "XPrint";

define fullCase = {false},
       upperCase = {true};
string procedure get!line(integer Case(upperCase));
begin "G!L"
    integer I;
    string S;
    S _ null;
    do begin
	I _ auxclv(-1,0,'46);
	if I geq '173 then done;	! these are line breaks (ugh);
	if (I geq '140) and (Case = upperCase) then I _ I - '40;
	if I geq '40 then S _ S & I;
    end until I < '40;
    if I = cr then auxclv(-1,0,'46);
    LevDef;				! Try and get node to echo;
    if (I=ctrl("C") or I=esc) then begin
	if DetachFlag then Detach;
	if InitFlag
	    then goto CommandLevel
	    else while true do call(0,"EXIT");
    end;
    !SKIP! _ I;
    return(S);
end "G!L";

simple procedure force(string CMD);
begin
    auxclv(-1,0,6);			! clear input buffer;
    auxclv(-1,location(CMD),'33);	! force input;
end;

procedure CTYspeak(string MSG);
begin "CTY speak"
    integer array M[0:length(MSG)%5+1];
    integer I;
    Msg _ Msg & crlf;
    for i_0 step 5 until length(Msg)
	do M[i%5] _ cvasc(Msg[i+1 for 5]);
    calli(location(M[0]),SetuuoUUO);	! Send string to CTY:;
end "CTY speak";

simple procedure Talk! (integer Job);
if length(MsgQ[job]) then begin "Talk!"
    simple integer procedure BP(integer J);
	return(memory[location(MsgQ[J])]);
    own integer I;
    own integer array IA[0:1];
    SetOper;			! so they can say TALK OPR:;
    MsgQ[job] _ MsgQ[job] & 0;
    IA[0] _ Job;
    IA[1] _ BP(job);
    I _ calli(hl('10)+location(IA[0]),SetuuoUUO);
    if !SKIP! or I then begin 	! error or all done;
	MsgQ[job] _ null;
	return end;
    while IA[1] neq BP(job) do I_lop(MsgQ[job]);
    MsgQ[job] _ MsgQ[job][1 to inf-1];
end "Talk!";

sub!title	OPER name/password/license routines;

define XA (A) = {
  redefine XM = A-P;
  ifc XM 
    thenc redefine XX = cvms(XX) & {[} & cvms(XM) & {]'54,};
    elsec endc
  redefine P = A};

define X1 (A,B) = {
  XA (A);
  redefine XX = cvms(XX) & cvps(B) & {,};
  redefine P = A+1};

define X2 (A,B,C) = {
  XA (A);
  redefine XM = C;
  forc P _ A stepc 1 untilc B doc {
    redefine XX = cvms(XX) & cvms(XM) & {,};
    redefine XM = XM+1;
    } endc
  redefine P = B+1};

define P = '40;
define XM = 0;
define XX = {};

x1('40,'0);
x1('44,'54);
x1('47,'53);
x1('52,'52);
x2('54,'72,'33);
x1('100,'52);
x2('101,'132,'1);

XA ('140);
redefine XX = cvms(XX)[1 to inf-1];

preset!with XX;
own integer array CHRTAB['40:'137];

long real procedure CVNAME(string NAME);
begin
  integer C,NM1,NM2;
  long real L;
  NAME _ (NAME & "            ")[1 for 12];
  NM1 _ NM2 _ 0;
  while length(NAME) do begin
    C _ CHRTAB[lop(name)];
    start!code
      MOVE 3,NM1;
      MOVE 1,NM2;
      IMULI 3,45;
      MULI 1,45;
      ADD 1,3;
      ADD 2,C;
      MOVEM 1,NM1;
      MOVEM 2,NM2;
      end;
    end;
  memory[location(L)] _ NM1;
  memory[location(L)+1] _ NM2;
  return(L);
  end;

integer procedure CVHASH(string PW);
begin
  integer C,FIVES,T1,T2,T3,T4;
  integer array X[0:4];
  X[0] _ X[2] _ X[4] _ '555555555555;
  X[1] _ X[3] _ '361275431652;
  FIVES _ '343277244615;
  T3 _ 0;
  while length(PW) do begin "PSWLP"
    C _ lop(PW);
    X[0] _ X[0] + C;
    X[3] _ X[3] + C;
    T4 _ '40;
    do begin "RAND"
      T1 _ X[T3];
      start!code
	MOVE 1,T1;
	MUL 1,FIVES;
	MOVEM 1,T1;
	MOVEM 2,T2;
	end;
      T3 _ T3 + 1;
      X[T3] _ X[T3] + T2;
      if T3 = 4 then begin
	T3 _ X[4] lsh -'42;
	X[0] _ X[0] + X[4];
	end;
      end "RAND" until (T4_T4-1) leq 0;
    end "PSWLP";
  return(X[0]);
  end;

string OPER!NAME;
integer procedure OPER!LICENSE (string OPN(null));
begin
  long real NAME;
  integer HASH,LIC,PTR,OP,EOF;
  integer array BUF[0:'777];
  string TMP;
  define bomb (X) = {begin
	print(X,crlf);
	release(OP);
	Oper!Name _ null;
	return(0) end};
  define
    bfnm1 = 0,
    bfnm2 = 1,
    bfpsw = 2,
    bflic = 3,
    nm1 = {location(NAME)},
    nm2 = {location(NAME)+1};
  if length(OPN) then TMP _ OPN else forever do begin
    print("Oper name: ");
    TMP _ get!line;
    if TMP = "?"
      then print("Enter your name as it appears in the OPER",
	" license file.",crlf)
      else done;
    end;
  if length(TMP)=0 then bomb("?no name given");
  NAME _ CVNAME (OPER!NAME _ TMP);
  auxclr(-1,memory['200],'64);
  forever do begin
    print("Password: ");
    TMP _ get!line;
    if TMP = "?"
      then print("?",crlf,
	"Enter your password associated with the OPER name ",
	OPER!NAME, ".",crlf)
      else done;
    end;
  HASH _ CVHASH (TMP);
  print(crlf);
  auxclr(-1,memory[0],'64);
  LevDef;
  open(OP_getchan,"SYS",'17,0,0,0,0,EOF_true);
  if EOF then bomb("?Can't init SYS:");
  begin "LOOKUP"
    define !CHLK = '4;		! CHANIO lookup function;
    define !RBLIC = '14;	! RIB address of file license;
    integer array XL[0:!RBLIC];
    XL[0]_arrinfo(XL,2);
    XL[2]_cvsix("DRWSPR");
    XL[3]_cvsix("EPO");
    chnior(OP,XL[0],!CHLK);
    if not !SKIP! then
	bomb("?OPER password file not found");
    if (XL[!RBLIC] land '400000)=0 then 
	bomb("?OPER password file has no license");
    end "LOOKUP";
  do begin "SEARCH"
    arryin(OP,BUF[0],'1000);
    if EOF then done "SEARCH";
    for PTR _ 0 step 7 until '770 do begin "TRY"
      if BUF[PTR+bfnm1] neq memory[nm1] then continue "TRY";
      if BUF[PTR+bfnm2] neq memory[nm2] then continue "TRY";
      EOF _ BUF[PTR+bfpsw] neq HASH;
      LIC _ BUF[PTR+bflic];
      done "SEARCH";
      end "TRY";
    end "SEARCH" until EOF;
  close(OP);
  release(OP);
  if EOF then begin
    print("?Bad name or password",crlf);
    return(0);
    end;
  return(LIC);
  end;


sub!title	Monitor IO routines;

define	uptime = {calli(hl('15)+hr('12),GettabUUO)};

simple integer procedure PEEK(integer ADR);
begin "PEEK"
    return(calli(ADR,PeekUUO));
    end "PEEK";

simple procedure POKE(integer ADR,VAL);
begin "POKE"
    own integer array ARG[0:1];
    ARG[0]_VAL;
    ARG[1]_ADR;
    calli(location(ARG[0]),PokeUUO);
    if not !SKIP! then fatal("POKE uuo failed");
    end "POKE";

integer procedure BITPOK(integer ADR,ANDCAM,IORM);
begin "BITPOK"
    integer array FOO[0:2];
    integer X,Y;
    FOO[0]_ADR;
    FOO[1]_ANDCAM;
    FOO[2]_IORM;
    Y_calli(location(FOO[0]),BitpokUUO);
    if not !SKIP! then Fatal("BITPOK uuo failed");
    return(Y);
    end "BITPOK";

simple procedure SetAdr;
begin "SA"
    own integer NUMTAB,I;
    ttyup(true);
    jps_calli('26000011,GettabUUO);
    jpm_calli('27000011,GettabUUO);
    jph_calli('30000011,GettabUUO);
    setbreak(blanks," "&ht,null,"SINK");
    setbreak(digits,"0123456789",null,"RINK");
    setbreak(nonBlanks," "&ht,null,"RXNK");
    setbreak(comma," ,",null,"SINK");
    setbreak(noPunct,null,"!#$%&()*={}~:-[]^;@\+`|<>./_ "&ht,"SINK");
    setbreak(SpecBreak," :,])>","(<[","SINK");
    NUMTAB_rh(call('23000023,"GETTAB"));
    JBTUID_rh(peek(NUMTAB-'53));
    JBTSTS_rh(peek(NUMTAB));
    JBTLIC_rh(peek(NUMTAB-'20));
    JBTAUN_rh(peek(NUMTAB-'23));
    JBTUN1_rh(peek(NUMTAB-'22));
    JBTUN2_rh(peek(NUMTAB-'21));
    JBTNAM_rh(peek(NUMTAB+'3));
    JBTPRV_rh(peek(NUMTAB+'6));
    JBTFPN_rh(peek(NUMTAB-'25));
    I _ rh(call(lh(-1)+rh(10),"GETTAB"));
    MyJob_call(0,"PJOB");
    MyPPN_peek(JBTAUN+MyJob);
    SchprvSave_peek(JBTSTS+MyJob)land bit(23);
    SchedSave_States;
    PrvSave_peek(JBTPRV+MyJob);
    HighJob_rh(peek(NUMTAB+'12))+'20;
    SysName _ scanc (cvStr (calli ('11,GettabUUO)), "-", null, "SINK");
    for J _ 1 upto peek(HIGHJOB) do if Exist(J) then begin
	JS[j] _ rh(peek(JBTAUN+j));
	UID[j] _ peek(JBTUID+j);
	JU[j] _ user(j);
	end;
    LastPoll _ uptime;
    gogtab[$$PROU] _ location(xprint);
				! setup my own print - so will be noop
				  if job is detached;
    Initials _ user(MyJob);
    DetachFlag _ WantSuperShut _ false;
    DownFlag _ 0;
end "SA";

simple procedure CRASH;
begin "CRASH"
    ! will crash system by deposit in 30;
    Log ("* Crashing system.");
    CleanUp;
    print("Crashing system...");
    ifc debug thenc call(0,"EXIT") elsec endc;
    if Reason then CTYspeak(Reason);
    CTYspeak("Deposit in 30 by user "&User(MyJob)&
	" at "&DayTime&" /"&initials);
    call (5,"SLEEP");
    poke ('30,cvsix (Initials));
    call (5,"SLEEP");
    poke ('30,cvsix("TAKEIT"));
    call(5,"SLEEP");
    fatal ("not responding to deposit in 30");
end "CRASH";

sub!title	Frame operations;

simple procedure Halt!(integer job);
begin "halt"
    integer I;
    I _ FrmopV(job,0,!FOHLT);
    if not !SKIP! then case rh(I) of begin
	['22] begin
	    lprint("?can't halt frame with JACCT: "&JobLine(job));
	    return end;
	['21] nothing;			! already halted;
	else lprint("??!FOHLT error '"&cvo(rh(I))&" for "&JobLine(job))
    end;
    JS[job] _ hc(haltLimit) + haltFlag + rh(JS[job]);
end "halt";

simple procedure Kill!(integer job);
begin "kill"
    integer Err;
    if peek(JBTSTS+job) < 0 then begin
	lprint("?running: "&JobLine(job));
	return end;
    start!code
	label DEP,PROG,PROGEND,XIT;
	MOVE 1,Job;
	MOVEI 1;		! 1 = can't set other frame;
	CALLI 1,SetotfUUO;
	  JRST XIT;
	MOVE 1,[bit(1)+1*bit(17)+0*bit(35)];
	CALLI 1,VclearUUO;	! remove his page 0 if any;
	  JFCL;
	MOVE 1,[bit(1)+3*bit(7)+1*bit(17)+0*bit(35)]; 
	MOVEI 2;		! 2 = can't create page 0;
	CALLI 1,VcreatUUO;	! page 0 R/W in other frame; 
	  JRST XIT;
	MOVE 1,Job;
	HRLI 1,!FOWVA;
	MOVEI 3;		! 3 = can't deposit AC;
	MOVEI 2,0;		! addr to load PROG at in other frame;
	MOVEI 4,PROG;		! 4/ -length,,PROG; 
	SUBI 4,PROGEND;
	HRLI 4,PROG;
	MOVSS 4;
DEP:	MOVE 3,(4);
	FRMOP 1,2;		! deposit;
	  JRST XIT;
	ADDI 2,1;
	AOBJN 4,DEP;		! more?
	MOVE 1,Job;
	HRLI 1,!FOSAA;
	HRROI 2,1;		! start address=1;
	MOVEI 4;		! 4 = can't start frame;
	FRMOP 1,2;		! start frame;
	  JRST XIT;
	SETZ;			! no errors;
	JRST XIT;
	! program to deposit in other frame;
PROG:	0;
	CALLI LogoffUUO;
PROGEND:! XIT-PROG = length of program;
XIT:	MOVEM Err;
    end;
    case Err of begin
	[1] lprint("?SETOTF failure: "&JobLine(Job));
	[2] lprint("?VCREAT failure: "&JobLine(Job));
	[3] lprint("?!FOWVA failure: "&JobLine(Job));
	[4] lprint("?!FOSAA failure: "&JobLine(Job));
	else end;
    JS[job] _ hc(killLimit) + killFlag + rh(JS[job]);
end "kill";

sub!title	Real time and countdown routines;

integer Tics, Mins, LastMin;

simple boolean procedure ReadClock;
begin
    own boolean ChangeingMin;
    if Mode = Manual then return(false);
    Tics _ (if Hold
	then Time!0-Hold
	else Time!0-uptime);
    if Tics < 0
	then Mins _ -(jpm%2-Tics)%jpm	! round to nearest if negative;
	else Mins _ (Tics+jpm-1)%jpm;	! round up if positive;
    ChangeingMin _ LastMin neq Mins;
    LastMin _ Mins;
    return (ChangeingMin);
    end;

simple procedure SetClock(integer T(bit(0)));
begin
    if T=bit(0) then T _ Tics;
    if Hold then Hold _ uptime;
    Time!0 _ uptime + T;
    Tics _ (if Hold
	then Time!0-Hold
	else Time!0-uptime);
    Mins _ (Tics + jpm-1)%jpm; ! always round up;
    LastMin _ bit(0);
    end;

define
    !sign = 4,
    !secs = 2,
    !spcl = 1;
string procedure CvTime (integer Format);
begin
    own integer T,M,S;
    string R;
    R _ null;
    T _ Tics;
    if T<0 then begin
	T _ -T;
	if Format land !sign then R _ "-";
	end;
    if Format land !secs
	then T _ ((T + jps%2)%jps)*jps
	else T _ ((T + jpm%2)%jpm)*jpm;
    if (T leq jph) and (Format land !spcl)
	then begin "nnnn minute(s)(, ss second(s))"
	    M _ (T % jpm);  S _ ((T % jps)mod 60);
	    R _ R & cvs(M) & " minute";
	    if M neq 1 then R _ R & "s";
	    if Format land !secs then begin
		R _ R & ", " & cvs(S) & " second";
		if S neq 1 then R _ R & "s";
	  	end;
	    end
	else begin "hhhh:mm(:ss)"
	    R _ R & cvs(T % jph);
	    setformat(-2,0);
	    R _ R & ":" & cvs((T % jpm)mod 60);
	    if Format land !secs
		then R _ R & ":" & cvs((T % jps)mod 60);
	    setformat(0,0);
	    end;
    return (R);
    end;


sub!title	Warning message and talk control routines;

procedure Warning;
begin "WARN"
    own integer LastWarning;
    if LastWarning neq Mins then begin
	talk ("System " & SysName & " will leave timesharing " &
	    (if Mins=0 then "immediately" else "in "&CvTime(!spcl)) &
	    " /" & Initials);
	Log ("* Warning: " & CvTime(!Spcl) & " /" & Initials);
	end;
    LastWarning _ Mins;
   BroadcastFlag _ true;
  end "WARN";

simple procedure TALK(string MSG);
begin "TALK"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and jsb(JS[Job])=0
	and Job neq MyJob
	    then MsgQ[job]_ MsgQ[job] & bel & crlf &
		";;OPR: - " & msg & crlf & bel;
    print(";;OPR: - ",msg,crlf);
end "TALK";

sub!title	Routines to find about about who owns what devices;

simple procedure DeviceScan;
begin "DeviceScan"
    own integer array X[0:4];
    own integer Job;
    X[0]_X[1]_0;
    for Job_arrinfo(JDev,1) upto arrinfo(JDev,2)
	do JDev[Job] _ null;
    do begin
	calli(hl(arrinfo(X,0))+hr(location(X[0])),SysdvfUUO);
	if not !SKIP! then done;
	Job _ X[4] lsh -29;
	if Job then JDev[Job] _ JDev[Job] & "  " & cv6str(X[1]) & ":";
	end until X[1]=0;
    end "DeviceScan";

simple boolean procedure OwnsDevice (integer Job, Dev);
begin "OwnsDevice"
    own integer array X[0:4];
    if lh(Dev) = lh(cvsix("TTY"))
	then return (Dev = calli(hl(Job)+hr(-'27),GettabUUO))
	else begin
	    X[0]_X[1]_0;
	    do 
		calli(hl(arrinfo(X,0))+hr(location(X[0])),SysdvfUUO)
		until X[1] = Dev or not !SKIP!;
	    return (if !SKIP! then (X[4] lsh -29)=Job else false);
	    end;
    end "OwnsDevice";

simple integer procedure ACTJOB; 
begin "ACTJOB"
    own integer array X[0:4];
    X[0]_X[1]_0;
    do
	calli(hl(arrinfo(X,0))+hr(location(X[0])),SysdvfUUO)
	until X[1]=cvsix("ACT") or not !SKIP!;
    return(if !SKIP!
	then (X[4] lsh -29)
	else 0);
    end "ACTJOB";


sub!title	Routines to tell about other jobs;

simple string procedure USER(integer JOB);
return(cv6str(peek(JBTUN1+job))&cv6str(peek(JBTUN2+job)));

simple string procedure QUEUE(integer STS);
begin "Q"
    own integer ST,I;
    if STS geq 0 then return("^C");
    ST_STS lsh -21 land '37;
    I_ST/3;
    I_call(hl(I)+hr('25),"GETTAB")lsh (12*(ST mod 3));
    return(cvxstr(I)[1 to 2]);
end "Q";

simple boolean procedure Exist(integer JOB);
return(peek(JBTSTS+JOB)land bit(3));

simple boolean procedure DETACHED(integer JOB);
return(lh(call(hl(JOB)+hr(-'27),"GETTAB"))=0);

simple boolean procedure Zapped;
    ! return true if "circuit zapper seen";
begin "Zapped"
    integer I;
    I _ calli(hl(-1)+hr(-'24),GettabUUO) land bit(1);
    if !SKIP! then return(I) else return(false);
end "Zapped";

simple boolean procedure IDLE(integer JOB);
return((peek(JBTSTS+JOB) land bit(0)) = 0);

simple boolean procedure EXEMPT(integer JOB);
begin "EXEMPT"
    if not Exist(Job) then return(false);
    if JOB = MyJob then return(true);
    if JS[job] land exemptFlag then return(true);
    if (cvsix("PJ")=peek(JBTUN1+JOB))
	and DETACHED(JOB)
	    then return(true);
    if Job=ActJob then return(true);
    return(false);
end "EXEMPT";

simple integer procedure NXJobCount;
begin "NXJC"
    own integer I,CNT;
    CNT_0;
    for I_1 upto peek(HIGHJOB) do
	if Exist(I) and not EXEMPT(I)
	    then CNT_CNT+1;
    return(CNT);
end "NXJC";

simple boolean procedure OneJob;
begin "1JOB"
    own integer J;
    for J _ 1 upto peek(HIGHJOB) do
	if Exist(J) and not (J=MyJob) then return(false);
    return(true);
end "1JOB";

simple procedure TakeStat;
begin "TakeStat"
    setformat(0,0);
    print((if States land '200000
	    then "System super-shut."
	    else (if States land '400000
		then "System shut."
		else "System answered.")), crlf);
    if Mode = Auto
	then print(
	    cvtime(!secs), (if Tics<0
	        then " into grace period."
	        else " remaining."), crlf,
	    (if Hold
	        then bel& "Countdown Holding." &bel&crlf
	        else null),
	    GRACE, " minutes grace.", crlf,
	    case ACTION of (null,
	        "System will be hung."&crlf,
	        "System will be stand alone."&crlf,
	        "System will crash."&crlf))
	else print(
	    "Manual mode.", crlf);
    print (NXJobCount, " non-exempt jobs.", crlf);
end "TakeStat";

procedure SYSTAT (string Arg(null));
begin "SYS"
    if not ScanSpec(Arg) then return;
    if DefaultSpec and not HeadSpec then begin
	DefaultSpec _ false;
	NonExemptSpec _ HeadSpec _ true;
	end;
    if HeadSpec then TakeStat;
    if not DefaultSpec then DeviceScan;
    MySelfSpec _ true;
    setformat(2,0);	! fixed format for job numbers;
    if not DefaultSpec then ForEachJob do
	if Apropos(Job)
	    then print(
		JOB, "  ",
		cvxstr(peek(JBTUN1+Job)),cvxstr(peek(JBTUN2+Job)),"  ",
		cvxstr(peek(JBTNAM+JOB)), "  ",
		QUEUE(peek(JBTSTS+JOB)), "  ",
		(if Detached(Job)
		    then "DETACH"
		    else cvxstr(calli(hl(JOB)+hr(-'27),GettabUUO))),
		JDev[Job],
		(if peek(JBTSTS+JOB)land bit(17)
		    then "  Jacct" else null),
		(if peek(JBTSTS+JOB)land bit(20)
		    then "  Jacct2" else null),
		(if peek(JBTSTS+JOB)land bit(23)
		    then "  SchPrv" else null),
		(if Exempt(Job)
		    then "  Exempt" else null),
		(if calli(Job,EvictUUO) and !SKIP!
		    then "  NtQ" else null),
		case jsb(JS[Job]) of
		    (null,"  (killed)","  (evicted)","  (?)"),
		(if length(MsgQ[Job])
		    then "  (msgs)" else null),
		crlf);
    if Jobs!=0 and not HeadSpec then print("No job satisfying request");
    print(crlf);
    setformat(0,0);
end "SYS";

sub!title	Handle things queued for jobs;

procedure CheckQueues(integer Job);
begin "CQ"
    if length(MsgQ[job]) then Talk!(job);
    if (JS[job] land haltFlag) and (peek(JBTSTS+job) > 0)
	then Kill!(job);
    if JS[job] < 0 then begin
	case jsb(JS[job]) of begin
	  [1] lprint("?no response to kill by "&JobLine(job));
	  [2] lprint("?no response to halt by "&JobLine(job));
	  [4] lprint("* no response to evict by "&JobLine(job));
	else FATAL("illegal jsb: JS["&cvs(job)&"]='"&cvo(JS[job])) end;
	Halt!(job);
    end;
end "CQ";
	
procedure POLL!JOBS;
begin "poll-jobs"
    integer JOB,LastPoll!,Elapsed;
    LastPoll! _ LastPoll;
    Elapsed _ ((LastPoll_uptime)-LastPoll!+jps%2)%jps;
    for JOB _ 1 upto JobN do if Exist(job)
	then begin "job-Exists"
	    if UID[job] neq peek(JBTUID+job) then begin "different-job"
		if rh(JS[job]) and jsb(JS[job])=0
		    and Watch then print(
		    "* LOGOUT Job ", job,
		    ", user ", JU[job],
		    bel, crlf);
		JS[job] _ rh(peek(JBTAUN+job));
		UID[job] _ peek(JBTUID+job);
		JU[job] _ user(job);
		MsgQ[job] _ null;
		if Watch then print(
		    "* LOGIN   Job ", job,
		    ", user ", JU[job],
		    bel, crlf);
	    end "different-job";
	    CheckQueues(job);
	end "job-Exists"
	else begin "job-doesnt-Exist"
	    if rh(JS[job]) and jsb(JS[job])=0 
		and Watch then print(
		"* LOGOUT Job ", job,
		", user ", JU[job],
		bel, crlf);
	    JS[job] _ UID[job] _ 0;
	    MsgQ[job] _ JU[job] _ null;
	end "job-doesnt-Exist";
end "poll-jobs";

sub!title	System message control (SYS:ACCESS.MSG);

procedure Update!Sys!Message;
begin "USM"
  integer Flag;
  ifc debug thenc return endc;
  enter(SysMsg,"ACCESS.MSG",Flag);
  if Flag
    then usererr(0,1,"?Can't enter SYS:ACCESS.MSG")
    else begin
	out(SysMsg, "System "& SysName& " will leave timesharing in "&
	    CvTime(!spcl)& " /"& Initials& crlf);
	if length(Reason) then out(SysMsg, Reason & crlf);
	end;
  close(SysMsg);
  SYS!MESSAGE _ true;
  end "USM";

procedure Save!Sys!Message;
begin "SSM"
  integer Flag;
  ifc debug thenc return endc;
  lookup(SysMsg,"ACCESS.MSG",Flag);
  if not Flag then rename(SysMsg,"TAKEIT.MSG",0,Flag);
  SYS!MESSAGE _ not Flag;
  close(SysMsg);
  end "SSM";

procedure Restore!Sys!Message;
begin "DSM"
  integer Flag;
  ifc debug thenc return endc;
  if not SYS!MESSAGE then return;
  lookup(SysMsg,"ACCESS.MSG",Flag);
  if not Flag then rename(SysMsg,null,0,Flag);
  close(SysMsg);
  lookup(SysMsg,"TAKEIT.MSG",Flag);
  if not Flag then rename(SysMsg,"ACCESS.MSG",0,Flag);
  close(SysMsg);
  SYS!MESSAGE _ false;
  end "DSM";


sub!title	System control routines;

simple procedure ContinueOnDisconnect;
    call(PrvSave land (lnot DiscMask) lor DiscCont,"SETPRV");

simple procedure AnswerSystem;
    Schedule ('000000);

simple procedure ShutSystem;
    Schedule ('400000);

simple procedure SuperShutSystem;
    Schedule ('600000);

define ClrSchprv = {calli(hl(7)+hr(false),SetuuoUUO)};

procedure Fatal(string Msg);
begin "Fatal"
  print("?FATAL: ",Msg,crlf);
  CTYspeak("?FATAL error in TAKEIT: "&Msg);
  Log("?FATAL: "&Msg);
  Abort;
end "Fatal";

procedure Abort;
begin "Abort"
  CloseLog;
  Restore!Sys!Message;
  call(PrvSave,"SETPRV");
  if not SchprvSave then ClrSchprv;
  while true do call(0,"EXIT");
  end "Abort";

simple procedure CleanUp;
begin "Cleanup"
  CloseLog;
  Restore!Sys!Message;
  DownFlag _ 0;
  end "Cleanup";

simple procedure SetJACCT;
  calli(bit(17) lor peek(JBTSTS+MyJob),SetjalUUO);

simple procedure ClearJACCT;
  calli((lnot bit(17)) land peek(JBTSTS+MyJob),SetjalUUO);

define SetSchprv = {ifc noSchPrv thenc elsec
	calli(hl(7)+hr(true),SetuuoUUO) endc};

simple procedure CLEAR(integer JOB);
begin "UNJ"
  own integer X;
  X_bitpok(JBTSTS+JOB,bit(17)+bit(20)+bit(23),0);
  if X land bit(17) then print("JACCT ");
  if X land bit(20) then print("JACCT2 ");
  if X land bit(23) then print("SCHPRV ");
  if X land(bit(17)+bit(20)+bit(23))
    then print("cleared for ", JobLine(Job), crlf)
    else print("No bits set for job ", JOB, crlf);
  end "UNJ";

simple boolean procedure OPR;
begin "OPR"
  calli(cvsix("OPR"),DevnamUUO);
  return(!SKIP!);
  end "OPR";

simple procedure SetOper;
begin "SetOper"
  calli(hl(5),SetuuoUUO);
  end "SetOper";

simple procedure Schedule(integer SCHED;boolean SilentFlag(false));
begin "SCHED"
  ! don't change bits other than shut and super-shut;
    integer Was;
    string S;
    Sched _ (Sched land '600000) lor ((Was_States) land '177777);
    if Sched = Was then return;
    if Sched land '200000 and Detached(myjob) then begin
	Sched _ Sched land '577777;
	WantSuperShut _ true;
	end;
    ifc not debug thenc calli(hl(1)+SCHED,SetuuoUUO); endc
    LastStates _ Sched;
    Case (Sched lsh -15) land '6 of begin
	[0] S _ "System answered";
	[4] S _ "System shut";
	[2][6] S _ "System super shut";
	else end;
    Log ("* " & S & " ("&cvos(Was)&" -> "&cvos(Sched)&")");
    if not SilentFlag then print (S, crlf);
    end "SCHED";

simple integer procedure States;
  return(rh(call('17000011,"GETTAB")));

simple procedure Detach (integer Job(0));
if Job=0
    then begin "DetachMe"
	DetachFlag _ true;
	if States land '200000 then begin
	    Schedule(States land '577777);
	    WantSuperShut _ true end;
	print("Detaching from job ",call(0,"PJOB"),"...");
	call(0,"ATTACH");
	setJacct;
	end "DetachMe"
    else begin "DetachHim"
	integer SavPrv;
	ifc debug thenc return; endc
	if not Exist(Job) then return;
	SavPrv _ BitPok(JBTPRV+Job,DiscMask,DiscCont);
				! Set continue on disconnect for job;
	calli(hl(1)+Job,HangUUO);	! Hang job - don't force logout;
	BitPok(JBTPRV+Job,DiscMask,DiscMask land SavPrv);
				! Restore his JBTPRV word;
	Log ("* detached " & JobLine(Job));
	print("* detached ", JobLine(Job), crlf);
	end "DetachHim";

procedure Attach (integer Job);
begin "ATTACH"
    Log ("* Attaching to "&JobLine(Job));
    call(hl(3)+hr(Job),"ATTACH");
    calli(hl(1),LogoffUUO);
    usererr(0,1,"?cant logout","X");
    end;

procedure CONT;
begin "CONT"
    calli(0,ContUUO);
    if not !SKIP! then begin "Gross Hack"
	force("CONT"&cr);
	call(0,"EXIT");
	end "Gross Hack";
    SetJACCT;
    print(crlf,
	"Attached to ",
	cv6str(peek(JBTNAM+MyJob)),
	" run by user ",
	user(MyJob),
	".",crlf);
    if not CONFIRM then DETACH;
    print("Type ""?"" for help.",crlf);
    begin "check-license"
	own integer LIC;
	LIC _ OPER!LICENSE;
  	Log ("* attached by " & Oper!Name);
	if LIC land (bit(16)+bit(18))
	    then WC _ (LIC land bit(18))
	    else begin
	 	Log ("* detached due to bad license");
		print("?write-core (WC) or hang-user (HU) license",
		    " required",crlf);
		DETACH;
		end;
	end "check-license";
    DetachFlag _ false;
    TakeStat;
    end "CONT";

sub!title	Initialization and support routines;

simple procedure CheckMyLicense;
begin "CML"
    own integer LIC;
    LIC_call(-'20,"GETTAB");
    if not LIC land bit(0) then usererr(0,1,"?WC license needed");
    if not LIC land bit(1) then usererr(0,1,"?RC license needed");
    if not LIC land bit(2) then usererr(0,1,"?OP license needed");
    if not LIC land bit(3) then usererr(0,1,"?SY license needed");
    if not LIC land bit(8) then usererr(0,1,"?JL license needed");
    if not LIC land bit(16) then usererr(0,1,"?WF license needed");
    end "CML";

simple boolean procedure CheckUserLicense;
begin "CUL"
    own integer LIC;
    LIC _ call(-'20,"GETTAB");
    if LIC land bit(18) then return(true);
    LIC _ OPER!LICENSE;
    Initials _ OPER!NAME;
    if LIC land bit(18) then return(true);
    if LIC land bit(16) then return(false);
    print("?User has insufficient license",crlf,
        "Hang User (HU) or Write Core (WC) license required",crlf);
    Abort;
    end "CUL";

simple procedure CheckAlone;
begin "CA"
    own integer FPN,NAM,J;
    FPN _ peek(JBTFPN+MyJob);
    NAM _ peek(JBTNAM+MyJob);
    for J _ 1 upto peek(HIGHJOB) do
        if (J neq MyJob)
	    and (peek(JBTFPN+J)=FPN)
	    and (peek(JBTNAM+J)=NAM)
	    and (peek(JBTSTS+J)<0)
	    then begin
		print("Warning: user ", user(J),
		    " already running ", cv6str(NAM),
		    " on job ", cvs(J), ".", crlf);
		end;
    end "CA";


sub!title	Perform action on other jobs;

simple string procedure JobLine (integer Job);
return ("job " & cvs(Job)
	& ", user " & User(Job)
	& " <" & cv6str(peek(JBTNAM+Job)) & "> "
	& Queue(peek(JBTSTS+Job)));


sub!title	procedures to remove jobs, etc.;

simple procedure HangSystem;
begin "HangSystem"
    if not OneJob then begin
	print("?can't hang system-system not stand alone",crlf);
	return; end;
    lprint("* Hanging system...");
    CleanUp;
    ifc debug thenc call(0,"EXIT") elsec calli(hl(4),HangUUO) endc;
    if !SKIP! 
	then begin "Logout"
	    if Reason then CTYspeak(Reason);
	    CTYspeak("System hung by user "&User(MyJob)&
		" at "&DayTime&" /"&initials);
	    call(5,"SLEEP");
	    calli(hl(1),LogoffUUO);
	    call(0,"EXIT");	! just in case;
	end
	else FATAL("HANG uuo failed-can't hang system");
    DownFlag _ 0;
end "HangSystem";

simple procedure HangJob (integer Job);
begin "HangJob"
    if Job=ActJob then Schedule(States lor '400000);
    if not Exist(Job) then begin
	print("?can't hang job ",Job," - job doesn't Exist",crlf);
	return end;
    if UID[job] neq peek(JBTUID+job) then begin
	print("?job ",job," UID does not match",crlf);
	return end;
    if jsb(JS[Job]) and (JS[Job] land expireFlag)=0 then begin
	print("?job ",Job," still processing previous ",
	    case jsb(JS[Job]) of ("?","kill","halt","?","evict"),
	    crlf);
	return end;
    JS[job] _ JS[job] land lnot exemptFlag;
    if Evict(Job) then return;
    lprint("* Killed "&JobLine(Job));
    ifc not debug thenc Halt!(job) endc;
end "HangJob";

simple procedure HangIdleJobs;
begin "HangIdleJobs"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and jsb(JS[Job])=0
	and (Idle(Job) or Detached(Job))
	and not Exempt(Job)
	    then HangJob(Job);
end "HangIdleJobs";

simple procedure HangNXJobs;
begin "HangNXJobs"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and jsb(JS[Job])=0
	and not Exempt(Job)
	    then HangJob(Job);
end "HangNXJobs";

simple procedure HangAllJobs;
begin "HangAllJobs"
    integer Job;
    Schedule(States lor '400000);
    for Job _ 1 upto peek(HighJob) do
	if Exist(Job)
	and jsb(JS[Job])=0
	and Job neq MyJob
	    then HangJob(Job);
end "HangAllJobs";

simple boolean procedure Evict (integer Job);
begin "Evict"
    if JS[Job] land evictFlag
	then return(false);	! don't do it twice for same job;
    if Job=ActJob then Schedule(States lor '400000);
    if calli(hl(1)+Job,EvictUUO)=0
	then return(false);	! wasn't enabled for it;
    if not !SKIP! then return(false);
    JS[Job] _ evictFlag + hc(evictLimit) + rh(JS[Job]);
    lprint("* Evicted "&JobLine(Job));
    return(true);
end "Evict";

simple procedure EvictAllJobs;
begin "EvictAllJobs"
    integer Job;
    for Job _ 1 upto peek(HighJob) do
	Evict (Job);
end "EvictAllJobs";

sub!title	Get parameters from operator;

string procedure GET!OPER!NAME;
begin
    string X;
    forever do begin
	print("Enter your initials: ");
	X _ get!line;
	if length(X)=0 then X _ OPER!NAME;
	if length(X)=0 then X _ User(MyJob);
	if length(X) < 2
	    then print("One of the following:", crlf, 
		"  <initials> - a 2-3 character signature", crlf, 
		"  <cr> - to use your OPER name (if given)", crlf)
	    else return (X);
	end;
    end;

string procedure GET!REASON (string Arg(null));
begin
    string X;
    do begin "get-reason"
	if length(Arg)
	    then X _ Arg
	    else begin
		print("Enter reason for takedown (or ""?""): ");
		X _ get!line(fullCase);
		end;
	Arg _ null;
	if X = "?" then begin "help"
	    integer I;
	    print(
		"One of the following:", crlf,
		"  <cr>", crlf,
		"  <10-60 character message>", crlf,
		"  <reason number (see below)>", crlf);
	    for I _ 1 upto REACNT do
		print(
		    "    ", I, ". ", REAMSG[I], crlf);
	    continue "get-reason";
	    end "help";
	if cvd(X) then begin "number"
	    integer I;
	    I _ cvd(X);
	    if (I > REACNT) or (I < 1) then begin
		print(
		    "Not a valid reason number", crlf);
		continue "get-reason";
		end;
	    return (REAMSG[I]);
	    end "number";
	if length(X)=0 then return(null);
	if length(X) < 10
	    then print("Message must be more than 10 characters", crlf)
	else if length(X) leq 60
	    then return(X)
	    else print("Message must be less than 60 characters", crlf);
	end until false;
    end;

!   boots!loaded = 1,
    stand!alone = 2,
    deposit!30 = 3;
integer procedure GET!ACTION (string Arg(null));
begin
    forever do begin "ga"
	if length(Arg)=0 then begin
	    print("Enter takedown type: ");
	    Arg _ get!line;
	    end;
	case Arg of begin
	    ["B"][null] return(boots!loaded);
	    ["C"] if WC
		then return(Deposit!30)
		else print("?requires Write-Core (WC) license");
	    ["M"] return(manual);
	    ["S"] return(stand!alone);
	    else print("One of the following:",crlf,
		"  Boots-loaded: kill all jobs and hang system",
		    " (default)",crlf,
		"  Crash: kill all jobs then deposit in 30",crlf,
		"  Manual: wait for operator action",crlf,
		"  Stand-alone: kill all jobs except this one",crlf)
	    end;
	Arg _ null;
	end "ga";
    end;

integer procedure GetTakedownTime (string Arg(null));
begin
    integer I;
    string L;
    do begin
	if length(Arg)
	    then L _ Arg
	    else begin
		print("Enter takedown time: ");
		L _ get!line;
		end;
	Arg _ null;
	if L="?" then begin
	    print("One of the following:",crlf,
		"  mmm     - minutes until takedown",crlf,
		"  @hh:mm  - local time of takedown",crlf);
	    continue; end;
	if L="@" then begin "absTime"
	    I _ cvd(scan(L,noPunct,Brk));	! ignore non-digits;
	    if I > (2400) or I mod 100 geq 60 then begin
		print("?bad time format, use @hhmm or @hh:mm",crlf);
		continue; end;
	    I _ ((I%100)*60)+(I mod 100);	! mins past 0000;
	    I _ (I*60000 - call(0,"MSTIME"))%60000;
	    while I < 0 do I _ I + (24*60);
	    I _ I mod (12*60);	! either 12/24 hr clk ok;
	    done; end;
	if cvd(L) > 0 then begin
	    I _ cvd(L);
	    done; end;
	print("?bad time, type ""?"" for help",crlf);
	end until false;
    if (I < MinTakedown) and not WC then
	print("Minimum takedown is ", I _ MinTakedown, crlf);
    return (I * jpm);
    end;

integer procedure GET!GRACE!PERIOD;
begin
    integer I;
    string L;
    do begin
	print("Enter grace period in minutes: ");
	I _ cvd(L _ get!line);
	if length(L)=0 then
	    print("Grace period is ",I_MinGrace,crlf);
	if I=0 and L="0" then begin
	    print("You are nasty!!!",crlf);
	    done; end;
	if I=0 then begin
	    print("Enter time to allow active jobs to remain",
		" after Scheduled down time.", crlf);
	    end;
	end until I;
    if (I < MinGrace) and not WC then
	print("Minimum grace is ",I_MinGrace,crlf);
    return(I);
    end;

boolean procedure CONFIRM;
begin
    string S;
    forever do begin "CONF"
	print("    okay? ");
	S _ get!line;
	if S = "Y" then return(true);
   	if S = "N" then return(false);
	print ("Enter ""Y"" or ""N"" please...");
	end "CONF";
    end;


sub!title	Logging subroutines;

simple procedure lprint(string msg);
begin
    print(bel,msg,crlf);
    log(msg);
end;

require "(SAILIB)EXTEND" library;
external simple string procedure StDate (integer Date,Flag('31));

simple string procedure StTime (integer Time);
begin "StTime"
    integer A,B;
    string T;
    getformat(A,B); setformat(-2,0);
    T _ cvs(Time%3600000) & ":" & 
    	cvs(Time%60000 mod 60) & ":" &
    	cvs(Time%1000 mod 60);
    setformat(A,B);
    return(T);
    end "StTime";

simple procedure ReadDayTime (reference integer Date,Time);
    do begin
	Date _ calli(0,DateUUO);
	Time _ calli(0,MstimeUUO);
	end until Date = calli(0,DateUUO);

simple string procedure DayTime;
begin
    integer Date,Time;
    ReadDayTime (Date,Time);
    return (StDate (Date) & " " & StTime (Time));
end;

integer LogChan;
string LogName;

simple procedure Log (string Msg);
begin
    if not LogChan then return;
    out(LogChan, DayTime);
    out(LogChan, "  ");
    out(LogChan, Msg);
    out(LogChan, crlf);
end;

simple procedure OpenLog;
begin
    open(LogChan_getchan,"DSK",1,0,2, 0,0,!SKIP!);
    if !SKIP! then usererr(0,0,"?can't init DSK:","X");
    LogName _ cvs(MyJob) & cv6str(peek(JBTNAM+MyJob)) & ".TMP";
    enter(LogChan, LogName, !SKIP!);
    if !SKIP! then usererr(0,0,"?can't enter log file: "&LogName,"X");
    Log ("** Session begins: " & cv6str(peek(JBTNAM+MyJob))
	& " version " & cvs(memory['137]) & ".");
    if Oper!Name then Log ("* Opername: "&Oper!Name
			&", Username: "&User(MyJob))
		else Log ("* Username: "&User(MyJob));
    end;

simple procedure CloseLog;
if LogChan then begin
    own integer C,B,E,W,I;
    own string N;
    define MaxTry = 15;	! Max # seconds to try for log file interlock;
    define MaxSize = 500; ! Max size to allow log file to become 
				(in tenths of a page);
    Log ("** Session ends."&crlf);
    W _ LogChan;
    LogChan _ 0;
    close(W);
    open(C,"DSK",1,2,0, 256,B,E);
    if E then return;
    N _ cv6str(peek(JBTNAM+MyJob)) & ".LOG"
	& "[" & cvos(lh(peek(JBTFPN+MyJob)))
	& "," & cvos(rh(peek(JBTFPN+MyJob))) & "]";
    if peek(JBTAUN+MyJob)='3225443 then N _ "(WRS)TAKEIT.LOG";
    for i_1 upto MaxTry do begin
	close(W);
	enter(W,N,E);
	if E
	    then call(1,"SLEEP")
	    else done;
	end;
    if E then begin
	print("?can't update log, please notify OS group",crlf);
	release(C); release(W);
	return;
	end;
    lookup(C,LogName,E);
    while not E do out(W,input(C,0));
    rename(C,null,0,E);
    close(C);
    lookup(C,N,E);
    for i_1 upto MaxSize do begin
	if E then done;
	out(W,input(C,0));
	end;
    if not E then out(W,crlf&"** file truncated **"&crlf);
    close(C);
    close(W);
    release(W);release(C);
    end;


sub!title	Command scanner and handler;

procedure COMMAND;
begin "COM"
    string COM,ARG;
    integer I,C;
    define Error (MSG) = {begin
	print(MSG, crlf);
	return;
	end};
    ARG _ get!line;
    auxclv(-1,0,'6);	! clear input buffer - prevent jam;
    LevDef;
    scan(ARG,nonBlanks,BRK);
    COM _ scan(ARG,blanks,BRK);
    ifc compiler!switch("B") thenc if WC and equ(COM,"BAIL") then begin
	Log ("* Entering BAIL");
	usererr(0,0,0,"B");
	Log ("* Returning from BAIL");
	print(crlf,"Returning from BAIL",crlf);
	return;
	end; endc
    J_0;
    if COM=null then COM_"NULL";
    if COM="?" then COM_"HELP";
    for I _ arrinfo(CMDS,1) upto arrinfo(CMDS,2)
	do if equ(COM,CMDS[I][1 to length(COM)])
	    then begin
		J_J+1;
		C_I;
		end;
    if J < 1
	then error("?unrecognized command");
    if J > 1
	then error("?ambiguous command");
    if (CmdF[c] land ReqWC) and not WC 
	then error("?command requires Write-Core (WC) license");
    if 0=(1 lsh Mode land CMDF[C]) 
	then error("?command illegal in "&
	    (if Mode=Manual then "manual" else "automatic")&
	    " mode");
    if CMDF[C] land Logit then Log (CMDS[C] & " " & Arg);
    case C of begin "commands"
	[com!HELP] print(comhlp);
	[com!CONFIGURATION] print(config);
	[com!INST] print(comins);
	[com!OPER] begin
	    WC _ Oper!License (arg);
	    if Oper!Name then print("okay.",crlf);
	    end;
	[com!NULL] print(
	    DayTime,";   ",
	    (if Mode=Auto then cvtime(!sign+!secs)&";   " else null),
	    NXJobCount, " non-exempt jobs.", crlf);
	[com!GRIPE] if length(Arg) then begin
	    string G,T;
	    G _ "->";
	    do begin
		T _ " " & scan(Arg,blanks,Brk);
		if length(G)+length(T) geq 60 then begin
			Log (G);
			G _ "->";
			end;
		G _ G & T;
		end
	    until Brk=0;
	    if length(G) > 3 then Log (G);
	    print( "Thank you.",crlf );
	    end;
	[com!EXEMPT] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do if Apropos(Job) 
		then JS[job] _ JS[job] lor exemptFlag;
	    print("[", Jobs, "]", crlf);
	    end;
	[com!UNEXEMPT] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ExemptSpec _ true;
	    ForEachJob do if Apropos(Job) 
		then JS[job] _ JS[job] land lnot exemptFlag;
	    print("[", Jobs, "]", crlf);
	    end;
	[com!SCHED] case Arg of begin
	    ["A"]["0"] AnswerSystem;
	    ["S"] case Arg[2 for 1] of begin
		["H"] ShutSystem;
		["U"] SuperShutSystem;
		else end;
	    ["4"] ShutSystem;
	    ["2"]["6"] SuperShutSystem;
	    else if length(Arg)
		then error("?unrecognized state")
		else print("Schedule = ",cvos(States),crlf)
	    end;
	[com!WATCH] begin case Arg[2 for 1] of begin
	    [null] nothing;
	    ["N"] Watch_true;
	    ["F"]["I"] Watch_false;
	    else error("?unrecognized argument") end;
	    print("Watching ",
		(if Watch then "en" else "dis"), "abled.", crlf);
	    end;
	[com!QUIT] Abort;
	[com!CANCEL] begin
	    print("Cancel takedown,");
	    if not Confirm then return;
	    if BroadcastFlag then
		talk("Timesharing will continue until further notice");
	    Restore!Sys!Message;
	    print("Takedown canceled.",crlf,"Manual mode.",crlf);
	    Mode _ manual;
	    DownFlag _ 0;
	    end;
	[com!SYSTAT] systat(arg);
	[com!CLEAR] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do
		if Apropos(Job) then Clear(Job);
	    print(Jobs, " cleared.",crlf);
	    end;
	[com!HANG] begin "TAKE-IT"
	    print("Hang system ", SysName, ",");
	    if CONFIRM
		then DownFlag _ 4;
	    end;
	[com!CRASH] begin
	    print("Crash system ", SysName, " by deposit in 30,");
	    if Confirm then Crash;
	    end;
	[com!KILL] if ScanSpec(Arg) then begin
	    if DefaultSpec then error("?job spec expected");
	    ForEachJob do
		if Apropos(Job) then HangJob(Job);
	    if Jobs!=0 then print("No jobs satisfying request",crlf);
	    end;
	[com!TALK] if ScanSpec(Arg) then begin
	    string msg,lin,tok,T;
	    if DefaultSpec then error("?job spec expected");
	    print("Enter message (end with ^D):",crlf);
	    msg _ bel & crlf &
		";;message from OPR: (" & initials & ")..." & crlf;
	    lin _ null;
	    do begin "input"
		Poll!Jobs;
		print(";; ");
		T _ get!line(fullCase);
		while length(T) do begin "fill"
		    integer Brk;
		    tok _ scan(T,blanks,brk);
		    if length(tok)=0 then continue;
		    if length(lin)+length(tok)+4 > LOL 
			then begin
			    msg _ msg & bel & ";; " & lin & crlf;
			    lin _ tok end
 			else lin _ lin & " " & tok;
		end "fill";
		print("[debug] msg=",msg,crlf);
	    end "input" until !SKIP! = ctrl("D");
	    msg _ msg & crlf & bel;
	    ForEachJob do
		if Apropos(job) then MsgQ[job] _ MsgQ[job] & Msg;
	    print(crlf,"[",Jobs,"]",crlf);
	    end;
	[com!WARNING] Warning;
	[com!AUTO] Automatic (Arg);
	[com!GRACE]
	    if (I_cvd(Arg)) geq (J_(if WC then 0 else minGrace))
		then begin
		    Grace _ I;
		    print( "Grace period set",crlf );
		    end
		else error("?must be "&cvs(J)&" or more");
	[com!HOLD] begin
	    if Hold then error("?countdown already Holding");
	    Hold _ uptime;
	    print("Countdown Holding", crlf);
	    end;
	[com!CONTINUE] begin
	    if Hold=0 then error("?countdown not Holding");
	    Time!0 _ Time!0 + (uptime-Hold);
	    Hold _ 0;
	    print("Countdown continued", crlf);
	    end;
	[com!SET] begin "Set"
	    SetClock( GetTakedownTime( Arg ));
	    print( "Countdown set",crlf );
	    end "Set";
	[com!ACTION] begin "Action"
	    Action _ get!action( Arg );
	    print( "Action set",crlf );
	    end;
	[com!DETACH] if ScanSpec(Arg) then
	    if DefaultSpec
		then Detach
		else begin
		    ForEachJob do
			if Apropos(Job) then Detach(Job);
		    print(Jobs," detached.",crlf);
		    end;
	[com!ATTACH] if ScanSpec(Arg) then begin
	    integer JobNo;
	    if DefaultSpec then error("?job-spec expected");
	    DetSpec _ true;
	    ForEachJob do if Apropos(Job) then JobNo_Job;
	    if Jobs! = 0 then error("?no job satisfying request");
	    if Jobs! neq 1 then error("?job-spec is ambiguous");
	    attach (JobNo);
	    end;
	else error("?command not implimented")
	end;
    end;


sub!title	Once per second and once per minute code;

procedure PER!SECOND;
begin "PS"
    if Zapped then begin
	print (bel, "?this job has been hung", crlf,
	    "?aborting due to hang", crlf);
	Log ("* aborted due to hang");
	Abort;
	end;
    if not DetachFlag and Detached(MyJob) then begin
	Log ("* circuit zapped");
	DetachFlag _ true;
	end;
    if DetachFlag and not Detached(MyJob) then Cont;
    auxclv(-1,0,'50);		! skip if line waiting;
    LevDef;
    if !SKIP! then COMMAND;
    if Mode = Auto then begin "Auto"
	SetOper;
	if Tics<0
	    then begin "GracePeriod"
		Restore!Sys!Message;
		SuperShutSystem;
		if Action = Manual
		    then begin
			Mode _ manual;
			print(bel, "Manual mode.", crlf);
			end
		    else if (Mins leq -Grace) or (NXJobCount=0)
			then case Action of begin
			    [boots!loaded] DownFlag _ 4;
			    [deposit!30] DownFlag _ 5;
			    [stand!alone] DownFlag _ 6;
			    else usererr(Action,0,"??bad Action: ")
			    end
			else DownFlag _ 1;
		end "GracePeriod"
	    else begin "NonGracePeriod"
		end "NonGracePeriod";
	end "Auto";
    POLL!JOBS;
    if States neq LastStates then begin
	print(bel, bel,
	    "**Schedule set to ",cvos(States)," by another job.",crlf,
	    "**Schedule was ",cvos(LastStates),crlf);
	Log ("* Another job set SCHED " & cvos(States)
	    & " from " & cvos(LastStates));
	LastStates _ States;
	end;
    if WantSuperShut then SuperShutSystem;
    if DownFlag geq 1 then HangIdleJobs;
    if DownFlag geq 2 then HangNXJobs;
    if DownFlag geq 3
	and NXJobCount=0 then HangAllJobs;
    if DownFlag geq 4
	and OneJob then begin "StandAlone"
	    print (Bel, "System is Stand-Alone", crlf);
	    case DownFlag of begin
		[4] HangSystem;
		[5] Crash;
		[6] Abort;
		else usererr(DownFlag,2,"??bad value for DownFlag: ")
		end;
	    end "StandAlone";
    end "PS";

procedure PER!MINUTE;
begin "PM"
    print(bel,
	(if Mode = Manual then null else CvTime(!spcl+!sign)&", "),
	NXJobCount, " non-exempt jobs.", crlf);
    if Mode = Manual then return;
    if Mins=0 then SuperShutSystem;
    if Mins=ShutTime then ShutSystem;
    case Mins of begin
	[FirstMsg] begin
	    Warning;
	    if REASON then talk(REASON);
	    end;
	[10][5][2][1][0] Warning;
	else nothing end;
    if Tics > 0 then Update!Sys!Message;
    end "PM";

simple boolean procedure Fast;
! return true if should be polling fast;
begin "fast"
    if (Mode neq Manual) and (Mins leq 5) then return(true);
    if DownFlag then return(true);
    for J _ 1 upto JobN do 
	if jsb(JS[j]) or length(MsgQ[j]) then return(true);
    return(false);
end "fast";

sub!title	Automatic takedown stuff;

procedure Automatic (string Arg);
begin "Auto"
    SetOper;			! make TTY: the OPR: terminal;
    Save!Sys!Message;		! rename SYS:ACCESS.MSG for later;
    if length(Arg)
	then begin "ShortForm"
	    if length(Oper!Name) 
		then Initials _ Oper!Name
		else Initials _ User(MyJob);
	    Reason _ Arg;
	    Arg _ scan(Reason,comma,Brk);
	    if Brk="," and length(Reason)=0
		then Reason _ null
		else Reason _ get!reason(Reason);
	    Action _ Boots!Loaded;
	    Tics _ GetTakedownTime(Arg);
	    Grace _ minGrace;
	    end "ShortForm"
	else begin "LongForm"
	    Initials _ get!oper!name;
	    Reason _ get!reason;
	    Action _ get!action;
	    Tics _ GetTakedownTime;
	    Grace _ get!grace!period;
	    end "LongForm";
    print(
	crlf,
	"System ", SysName,
	" will leave timesharing in ", cvTime(!spcl),
	" /", Initials, crlf,
	"Grace period is ", Grace, " minutes.", crlf,
	(if Reason then Reason&crlf else null));
    if not CONFIRM then begin
	Restore!Sys!Message;
	Mode _ manual;
	print("Automatic takedown aborted",crlf);
	return;
	end;
    Log ("* Countdown = " & cvTime(!spcl) & ", Grace = "
	& cvs(Grace));
    if Reason then Log ("* """ & Reason & """");
    Mode _ Auto;
    SetClock;
    Watch _ true;
    if Mins < FirstMsg then begin
	Warning;
	if Reason then Talk(Reason);
	end;
    end "Auto";

procedure ClearAutomatic;
begin "CA"
    print(bel,bel, "Manual mode.", crlf);
    Restore!Sys!Message;
    Mode _ manual;
    SetClock (0);
    Grace _ 0;
    Action _ 0;
    end "CA";


sub!title	*** M A I N   P R O G R A M ***;

    CheckMyLicense;		! make sure program has license;
    print("TAKEIT version ", memory['137], " at ", DayTime, crlf,
	(if Debug then "** DEBUG **"&crlf else null));
    SetAdr;			! get critical monitor addresses;
    LevDef;			! try and get node to do echoing;
    WC _ CheckUserLicense;	! make sure user has WC or HU;
    InitFlag _ true;		! indicates that we are init'd;
    CheckAlone;			! warning if someone else running this;
    SetJACCT;			! insure control;
    SetSchprv;			! in case someone else has it;
    OpenLog;			! log everything that happens;
    ContinueOnDisconnect;	! in case they hang up on us;
    open(SysMsg_getchan,"SYS",1,0,5,0,0,Flag);
CommandLevel:			! a ^C jumps here (sometimes);
    print("Enter commands (type ""?"" for help):", crlf);
    forever do begin "MIN"
	do begin "SEC"
	    Per!Second;		! execute once per second;
	    calli(hl('21)+(if fast then 1 else SlowPollRate),HiberUUO);
	    end until ReadClock;
	Per!Minute;		! execute once per minute;
	end;
    end "MAIN";
end $

   hHL