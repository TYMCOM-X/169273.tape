TITLE BOOTS - V014 - LEVEL D DISK BOOTSTRAP (LOCATION INDEPENDENT)
SUBTTL R. CLEMENTS /TH
SALL

REPEAT 0,<
ASSEMBLY INSTRUCTIONS:
1. TO MAKE LOCATION INDEPENDENT VERSION FOR LOADING WITH WTBOOT PROGRAM
	ASSEMBLE WITH NO SPECIAL SYMBOL DEFINITIONS.
2. TO MAKE ABSOLUTE PAPER TAPE VERSION, DEFINE CORE TO BE:
	40000	FOR 16K (or n*40000 for n*16K)

	.MAKE FTBOOT.MAC
	ICORE=40000
	$$
	EX$$
	.R MACRO
	PTP:_FTBOOT,BOOTS
>

;SEE BOOTS.MEM FOR OPERATING INSTRUCTIONS
;NOTE THAT THE DISK PACK CODE IS AT BEST OUT OF DATE.

;AC'S

F=0	;FLAGS
	;BITS 29-35=CONTROLER DEVICE CODES
A=1	;GENERAL AC'S
B=2	; ..
C=3	; ..
X=4	;MEMORY ADDRESS COUNTER
W=5	;WORD RETURNED BY RWORD OR SIXBRD
NAME=6	;NAME OF FILE OR UFD BEING SEARCHED FOR
EXT=7	;EXTENSION OF FILE OR UFD BEING SEARCHED FOR
Q=10	;COUNTER TO STEP THROUGH BUFFER OF 1000 DATA WORDS
POSRET=11 ;CONTAINS ADDR OF CURREN/NEXT RETRIEVAL PNTR IN RBUF.
S=11	;BYTE POINTER AT START UP.
N=12	;NUMBER ASSEMBLER IN TYPEIN
M=13	;MEMORY AOBJN POINTER FOR READING THE DATA TO CORE
K=14	;INDEX OF KONTROLLER TYPE
R=15	;CONTAINS RELOCATION OF BOOTS TO MAKE IT LOCATION INDEPENDENT
	;R+1 MUST BE 17 OR LESS - SINCE JSR R USED TO SET R
RET=16	;RETRIEVAL PNTR OF PAGE TO READ
P=17	;STACK POINTER
;CORE ALLOCATION

DTASIZ==2400	;SIZE ALLOWED FOR DATA STORAGE.
CODSIZ==1600	;SIZE ALLOWED FOR CODE.  IF THIS IS CHANGED, YOU
		;MUST CHANGE BOTLOD AND COMMON (SYSCRS) ALSO.

IF1,<			;PASS 1?
WTBOOT==0		;ASSUME ABSOLUTE PAPER TAPE VERSION
IFNDEF CORE,<		;IS CORE UNDEFINED?
	WTBOOT==1	;YES, ASSUME LOCATION INDEPENDENT VERSION IS WANTED
>
>
IFN WTBOOT,<		;LOCATION INDEPENDENT?
	INTERN BOOTSA,MBOOTL

	CORE=.+DTASIZ+CODSIZ	;LAST LOC PLUS 1 FOR BOOTS
>

ZZ=CORE-DTASIZ-CODSIZ		;
BOOTDT=ZZ			;FIRST DATA LOC IN BOOTS

CLRTOP=ZZ-1			;WHEN CLEARING CORE, CLEAR TO HERE

DEFINE U(Z)<	UU(Z,1)>	;ONE WORD ALLOCATION
DEFINE UU(Z,N)<	Z=ZZ
ZZ=ZZ+N
IFGE <ZZ-CORE+CODSIZ>,<
PRINTX ALLOCATION ERROR
>>

IFE WTBOOT,<		;ABSOLUTE ASSEMBLY?
LOC CORE-CODSIZ			;ABSOLUTE ASSEMBLY
>
IFN WTBOOT,<		;LOCATION INDEPENDENT ASSEMBLY?
BLOCK	DTASIZ	;SKIP OVER LOWER CORE STUFF
JOBVER==137
MAJVER==17		;MAJOR VERSION NUM
MINVER==0		;MINOR VERSION NUM
INTERNAL JOBVER
	LOC JOBVER
	XWD	MAJVER,MINVER
	RELOC
>


UU(RBUF,1000)
UU(DBUF,1000)
FIRSTW==20			;FIRST LOCATION CONSIDERED ON WRITE

L.DOT=1				;DOT SEEN IN FILE SPEC
L.LBK=2				;LEFT BRACKET SEEN IN FILE SPEC
L.CMA=4				;COMMA SEEN IN FILE SPEC
L.SLA==10			;SLASH SEEN IN FILE SPEC
L.ALL==17			;ABOVE FLAGS TOGETHER.

;FLAGS, RIGHT HALF OF F

R.KDEV=177			;BITS 29-35=KONTROLLER DEVICE CODE
R.STRT==2000			;ON IF LOAD AND GO. OFF IF JUST LOAD

;SYSTEM PARAMETERS WHICH MUST AGREE WITH COMMOD

LPNHOM==1			;ADDRESSES OF HOME PAGES
LP2HOM==6			; ..
BOOTBK==14			;STARTING ADDRESS OF BOOTS.  (IN
				;BLOCKS.). KI, KL VERSION ONLY.
CODHOM=070717			;VERIFICATION CODE OF HOME PAGE
CODRIB=666666			;VERIF CODE OF A RIB PAGE
PAGCOD==776			;WORD ADDRESS OF VERIF CODE
PAGSLF==777			;WORD ADDRESS OF SELF POINTER

RIBRIB==0			;RET PNTR TO HIGHER RIB.
RIBRPS==1			;RIB'S POSITION IN HIGHER RIB.
RIBSFS==4			;1ST RET PNTR IN SPARE RIB.
RIBNAM==5			;W A OF NAME OF FILE IN THE RIB
RIBEXT==6			;W A OF EXT OF FILE IN THE RIB
RIBSIZ==10			;LENGTH OF FILE IN WORDS.
RIBPFS==51			;1ST RET PNTR IN PRIME RIB.
RIBLST==775			;LOC OF LAST RET PNTR.

RBSPAR==400000
RBREAL==200000
RBINDX==100000

UFDLNK==^D511			;ADDR OF LINK TO NEXT PAGE OF
				;THE UFD WITH THE SAME HASH.

HOMSNM==2			;STRUCTURE NAME IN SIXBIT
HOMLUN==6			;LOGICAL UNIT NO. (OCT) IN STR
HOMREF==10			;NEED TO REFRESH IF NON-ZERO
HOMMFD==25			;RETRIEVAL PNTR OF MFD RIB
HOMHSH==27			;LH IS HASH CONSTANT.

OPDEF PJRST [JRST]		;EQUIVALENT TO TWO INSTR. PUSHJ/POPJ
				; OR THREE INSTR. PUSHJ/POPJ/JRST CPOPJ1
OPDEF PJSP [JSP]		;EQUIVALENT TO TWO INSTR. MOVEI/PJRST
;START HERE

BOOTSA:
GO:	CONO 200000		;I/O BUS RESET(MONITOR CHECKS FIRST INSTR. TO
				;TO SEE IF IT IS CONO 200000
				; ON 147 RESTART OR DEPOSIT IN 30

	TDZA A,A	;NO STRING
	HRLI A,(POINT 7,0(R))	;STRING, SET BYTE PART
	HRRI A,CMDSTR		;DEFAULT COMMAND STRING
	SKIPA
	HRLI A,(POINT 7,)	;SET STRING BYTE PART, ADR ABSOLUTE
;ifcpu(<ki,kl,f3>)<>
	CONO 4,10400		;CLEAR PI SYSTEM
;<>;ifcpu(<ki,kl,f3>)
	MOVSI R+1,(JRST (R))	;RETURN INSTR. FOR JSR
	JSR R			;SETUP RELOCATION OF BOOTS IN R
				; RETURN HERE
	SUBI R,.-GO+DTASIZ+BOOTDT	;ADJUST R TO BASE OF BOOTS DATA AREA
	MOVEM A,STRING(R)	;SET BYTE PART OR NO BYTE PART
REGO:	MOVEI P,PDL-1(R)		;INITIAL STACK POINTER
	SETZB F,PPN(R)		;CLEAR FLAGS, PROJ-PROG NUMBER
	SETZM FNAME(R)		;CLEAR REQUESTED FILE NAME
	SETZM FEXT(R)		;CLEAR REQUESTED FILE EXTENSION
	SETZM SWITCH(R)		;CLEAR COMMAND SWITCHES
	MOVEI A,PROMPT(R)	;GET PROMPT MSG ADDRESS
	PUSHJ P,OUTMSG(R)		;TYPE PROMPT
GOL:	MOVE S,SIXPTR(R)		;POINTER TO THE WORD.
	SETZB N,W		;CLEAR ANSWERS.
SIXBRL:	PUSHJ P,TYI(R)
	CAIG C,"Z"		;LETTER?
	CAIGE C,"A"		; ..
	SKIPA			;NOT A LETTER.
	JRST SIXLTR(R)		;LETTER.
	CAIG C,"9"		;NUMBER?
	CAIGE C,"0"		; ..
	JRST GO0(R)		;NO. RETURN WITH BREAK CHAR.
	LSH N,3			;BUILD OCTAL NUMBER
	ADDI N,-60(C)		;ADD IN THIS DIGIT
SIXLTR:	TRC C,40		;MAKE SIXBIT
	TLNE S,770000		;ONLY 6 CHARS
	IDPB C,S		;STORE CHAR IN W
	JRST SIXBRL(R)		;LOOP FOR MORE.

TYI:	SKIPE STRING(R)
	JRST TYIS(R)	;READ FROM STRING
;ifcpu(<ki,f3>)<
	CONSO TTY,40		;WAIT FOR A KEY TO BE ST(R)UCK
	JRST .-1(R)		; ..
	DATAI TTY,C		;GET THE CHAR
;<>;end ifcpu(<ki,f3>)
TYIC:	PUSHJ P,TYO(R)		;ECHO IT
	ANDI C,177		;ONLY 7 BITS
	CAIN C,177		;RUBOUT?
	JRST REGO(R)		;YES. QUIT.
	CAIL C,140
	SUBI C,40	;CONVERT LOWER CASE TO UPPER
	POPJ P,

TYIS:	ILDB C,STRING(R)
	JUMPN C,TYIC(R)
	SETZM STRING(R)		;OUT OF STRING
	JRST TYI(R)
GO0:	TLNN F,L.ALL		;ANY SYNTAX REQUESTS?
	JRST GO6(R)		;NO. SEE IF FILE NAME.
	TLZE F,L.DOT		;WAS THERE A DOT?
	HLLOM W,FEXT(R)		;YES. STORE EXT. RH IS FLAG IF BLANK.
	TLZE F,L.SLA		;SLASH SWITCH?
	MOVEM W,SWITCH(R)		;YES. SAVE SWITCH WORD
GO7:	CAIG C,40		;SPACE OR CONTROL CHAR?
	JRST DO(R)			;YES. GO PROCESS COMMAND
	CAIE C,"."		;FILE EXTENSION REQUEST?
	JRST GO3(R)		;NO.
	TLO F,L.DOT		;YES. REMEMBER THAT
	JRST GOL(R)		;AND READ ON.

GO3:	CAIE C,"("		;PPN REQUEST?
	JRST GO4(R)		;NO.
	MOVE S,SIXPTR(R)
	SETZB W,W+1
	MOVEI N,^D12
GONM0:	PUSHJ P,TYI(R)
	CAIN C,")"
	JRST GONM1(R)
	SOJL N,GONM0(R)		;READ IN USER NAME
	SUBI C,40
	IDPB C,S
	JRST GONM0(R)

GONM1:	MOVE A,CON1(R)
	MOVE B,CON2(R)
	MOVE C,CON3(R)
	MOVSI X,0
	REPEAT 4,<PUSHJ P,RND(R)>
	XOR C,B
	MOVE W,C
	TLZ W,400000
	IDIVI W,^D887
	XOR A,C
	PUSH P,A		;HASH
	PUSH P,W+1		;PAGE
	MOVSI A,'LUD'
	MOVEM A,FNAME(R)
	MOVSI A,'SYS'
	MOVEM A,FEXT(R)
	SETZM PPN(R)
	PUSHJ P,LOOK(R)
	JRST NOLUD(R)
SRUS2:	MOVE	Q,(P)	;
	LSH	Q,-2		;
	PUSHJ	P,GETRET(R)
	JRST NOUSR(R)
	SOJGE Q,.-2(R)
	MOVEI A,DBUF-1(R)
	PUSHJ P,RDPAG(R)
	JRST RDER(R)
	MOVEI A,DBUF(R)
	POP	P,Q		;
	ANDI	Q,3		;
	IMULI	Q,200		;
	ADDI	A,(Q)	;
	POP P,B
SRUSR:	CAME B,4(A)
	JRST GONM2(R)
	MOVE A,0(A)
	MOVEM A,PPN(R)
	SETZM FNAME(R)
	SETZM FEXT(R)
	JRST GOL(R)

GONM2:	SKIPG C,(A)
	JRST BLKLNK(R)
	MOVE C,2(A)
	ANDI C,177
	ADD A,C
	JRST SRUSR(R)

BLKLNK:	JUMPE C,NOUSR(R)
	PUSH P,B
	PUSH P,C
	MOVEI	POSRET,RBUF+RIBPFS(R) ;
	SKIPN	RBUF+RIBRIB(R)	;CURRENT RIB IS PRIME RIB?
	JRST	SRUS2		;YES.
	MOVE	RET,PRMRIB(R)	;NO, GET THE PRIME RIB.
	PUSHJ	P,GETRIB(R)	;
	JRST	NOUSR(R)
	JRST	SRUS2(R)	;

NOUSM:	ASCIZ /NO USER/
NOLUDM:	ASCIZ /NO LUD/

NOUSR:	MOVEI A,NOUSM(R)
	JRST ERROR(R)

NOLUD:	MOVEI A,NOLUDM(R)
	JRST ERROR(R)
RND:	ADD B,W
	ROTC W,-22
	MOVEI Q,5
RND1:	MOVE N,B(X)
	MUL N,CON4(R)
	ADDM N+1,C(X)
	AOJE X,RND2(R)
	MOVNI X,1
	TRNE B,1
	SKIPL C
	MOVEI X,0
	EXCH A,C
RND2:	SOJG Q,RND1(R)
	POPJ P,

CON1:	555555555555
CON2:	361275431652
CON3:	612754316523
CON4:	5*5*5*5*5*5*5*5*5*5*5*5*5*5*5
GO4:	CAIE C,"/"		;SLASH?
	JRST GOL(R)		;NO.
	TLO F,L.SLA		;YES. MARK SWITCH COMING
	JRST GOL(R)		;RETURN TO SCAN
GO6:	SKIPE W			;NO PUNCTUATION. NAME TYPED?
	MOVEM W,FNAME(R)		;YES. STORE NAME
	JRST GO7(R)		;GO CHECK PUNCTUATION
;HERE WHEN COMMAND STRING SUCCESSFULLY READ. DO THE JOB.

DO:	PUSHJ P,CRLF(R)		;SIGNAL STARTING I/O
	LDB A,[POINT 6,SWITCH(R),5](R)	;GET FIRST CHARACTER
	JUMPE A,RUN(R)		;NO SWITCH MEANS LOAD AND RUN
	CAIN A,"L"-40		;LOAD COMMAND?
	JRST LOAD(R)		;YES.
	CAIN A,"D"-40		;DUMP COMMAND?
	JRST DUMP(R)
	CAIN A,"G"-40		;GO COMMAND?
PROGSA:	JRST NOSA(R)	;YES, IF NOT SPECIFIED ADR, GIVE BELL
				; ***LH CHANGED TO JRST, RH TO ADR***
	CAIL A,"0"-40		;NUMERIC?
	CAILE A,"7"-40		; OCTAL, THAT IS,
	JRST BADSW(R)		;NO OTHERS IMPLEMENTED
	MOVE W,N		;MOVE STARTING ADDRESS TO W
STARTQ:	HRLI	A,GO+CODSIZ+100(R)	;END OF BOOTS
	HRRI	A,SAXBAS
	BLT	A,SAXBAS+37	;RESTORE SA-10 BASE WORDS
	HRLI W,(JRST)		;CHANGE OPCODE TO JRST
	MOVEM W,PROGSA(R)		;SAVE THE STARTING ADDRESS
	TRNE F,R.STRT		;LOAD OR START?
	JRST 0(W)		;START
	JRST REGO(R)		;JUST LOAD. GO GET ANOTHER COMMAND


;LOAD AND RUN COMMANDS

LOAD:	TRZA F,R.STRT		;LOAD BUT DON'T START PROGRAM
RUN:	TRO F,R.STRT		;LOAD AND START PROGRAM
	MOVE A,SYSTEM(R)	;DEFAULT READ-FILE NAME
	SKIPE FNAME(R)		;NAME SUPPLIED?
	JRST LDRN(R)		;YES.
	MOVEM A,FNAME(R)	;NO. PLUG IN DEFAULT.
	MOVEI A,DEFMON(R)	;GET ADR OF DEFAULT MON MSG
	PUSHJ P,OUTMSG(R)	;TYPE MSG
LDRN:	PUSHJ P,LOOK(R)		;TRY TO FIND FILE
	JRST NOFIL(R)		;NOT THERE. FAIL.
				;SUCCESS. FALL INTO RFILE
;HERE WHEN FILE FOUND. FIRST RIB FOR FILE IS IN CORE.

RFILE:	SETZB Q,40		;CLEAR CORE BEFORE READING FILE
				;AND INITIALLY NO WORDS IN DATA BUFFER
	MOVE A,BLTXWD(R)		; ..
	BLT A,CLRTOP(R)		;CLEAR UP TO BASE OF THIS PROGRAM
	SETZM	GO+CODSIZ+100(R)	;CLEAR SAXBAS SAVE AREA ABOVE BOOTS
	HRLI	A,GO+CODSIZ+100(R)	;START OF AREA
	HRRI	A,GO+CODSIZ+101(R)	
	BLT	A,GO+CODSIZ+137(R)
RFILL1:	PUSHJ P,RWORD(R)		;READ A POINTER OR JRST WORD
	SKIPL M,W		;WHICH IS IT?
	JRST STARTQ(R)		;TRANSFER WORD
RFILL2:	PUSHJ P,RWORD(R)		;READ A WORD OF DATA
	PUSHJ	P,CHKADR(R)	;IN SA-10 AREA?
	JRST	SPARRD(R)	;YES
	MOVEM W,1(M)		;STORE IT IN CORE
RFILL3:	AOBJN M,RFILL2(R)		;COUNT THE CORE POINTER.
	JRST RFILL1(R)		;IT RAN OUT. GET ANOTHER.

;SUBROUTINE TO READ A DATA WORD FROM THE FILE.

RWORD1:	MOVE Q,DBUFP(R)		;PREPARE TO COUNT DATA WORDS
	ADDI Q,(R)		;RELOCATE
RWORD:	JUMPGE Q,RWNXTB(R)		;NEED ANOTHER PAGE?
	MOVE W,0(Q)		;NO. GET A WORD.
	AOBJN Q,.+1(R)		;COUNT IT.
	POPJ	P,		;RETURN FROM RWORD
RWNXTB:	PUSHJ P,GTDATA(R)		;NO. READ NEXT DATA PAGE, IF ANY
	JRST RDER(R)		;ERROR RETURN FROM GTDATA
	JRST RWORD1(R)		;READ FROM THIS PAGE
SPARRD:	ADD	M,R
	MOVEM	W,GO+CODSIZ+101-SAXBAS(M); STORE IN SAVE AREA FOLLOWING BOOTS
	SUB	M,R	;RESTORE R
	JRST	RFILL3(R)

CHKADR:	PUSH	P,M		;SAVE M
	HRRZS	M
	CAIL	M,SAXBAS-1
	CAILE	M,SAXBAS+36
	AOS	-1(P)
	POP	P,M
	POPJ	P,
;HERE TO WRITE OUT CORE ON AN EXISTING FILE

DUMP:	MOVE A,CRASH(R)		;DEFAULT FILE NAME
	SKIPN FNAME(R)		;NAME ALREADY SET?
	MOVEM A,FNAME(R)	;NO. USE DEFAULT
	PUSHJ P,LOOK(R)		;TRY TO FIND THE FILE.
	JRST NOFIL(R)		;CANT FIND IT
	SKIPN STRING(R)		;FROM COMMAND?
	JRST DUMP0(R)		;NO
	HRRZ A,RBUF+RIBEXT(R)
	JUMPN A,DUMP0(R)	;HAS ACCESS DATE CHANGED?
	SETZM STRING(R)		;NO, ABORT AUTO RELOAD
	MOVEI A,NOTDMP(R)
	JRST ERROR(R)		;WITH AN ERROR MESSAGE
DUMP0:	SETZB Q,LENGTH(R)	;SET TO RECORD LENGTH WRITTEN
	MOVEI M,FIRSTW-1	;AND CORE ADDRESS COUNTER
DUMPL2:	HRRZS X,M		;START OF A PAGE
DUMPL1:
	SKIPN 1(X)		;THIS WORD ZERO IN CORE?
	JRST DUMP1(R)		;YES. SEE IF END OF A PAGE.
	CAIGE X,CLRTOP+2001(R)	;LOOKED AT ALL OF CORE?
DUMPL5:	AOJA X,DUMPL1(R)	;NO. COUNT PART OF THIS PAGE, LOOK ON.
DUMP1:	MOVEI W,0(M)		;END OF PAGE. IS PAGE EMPTY?
	SUBI W,0(X)		;START MINUS END OF BLK
	JUMPE W,DUMP2(R)	;JUMP IF PAGE EMPTY
	HRL M,W			;MAKE -COUNT,,START-1 FOR COUNTER
	MOVE W,M		;AND FOR DATA IN FILE
	PUSHJ P,WWORD(R)	;WRITE IT OUT AS DATA
DUMPL3:
	MOVE W,1(M)		;GET THE WORD FROM CORE
DUMPL6:	PUSHJ P,WWORD(R)	;OUTPUT TO FILE
	AOBJN M,DUMPL3(R)	;OUTPUT ALL OF PAGE
DUMP2:	CAIGE X,CLRTOP+2001(R)	;CONSIDERED ALL OF CORE?
	AOJA M,DUMPL2(R)	;NO. MOVE ON.
	MOVSI	W,(HALT)	;YES, APPEND TERMINATOR
	PUSHJ P,WWORD(R)	;WRITE OUT THIS WORD
	JUMPL Q,.-1(R)		;IF MORE TO GO IN PAGE, WRITE AGAIN
	SKIPN	RBUF+RIBRIB(R)	;CURRENT RIB IS PRIME RIB?
	JRST	DUMP3(R)	;YES.
	MOVE	RET,PRMRIB(R)	;NO, GET THE
	PUSH	P,LENGTH(R)	;
	PUSHJ	P,GETRIB(R)	;PRIME RIB.
	JRST	WRTER(R)
	POP	P,LENGTH(R)	;
DUMP3:	MOVE A,LENGTH(R)	;NUMBER OF PAGES WRITTEN
	LSH	A,11		;CONVERT TO WORDS
	MOVEM A,RBUF+RIBSIZ(R)	;SAVE IN RIB
	HLLZS RBUF+RIBEXT(R)	;SET A 0 ACCESS DATE
	MOVE	RET,PRMRIB(R) ;GET LOCATION OF RIB
	PUSHJ P,UNISEL(R)	;SET FOR PROPER PAGE AND UNIT
	JRST REGO(R)		;GIVE UP ON ERROR
	MOVEI A,RBUF-1(R)
	PUSHJ P,WRPAG(R)	;WRITE IT OUT
	JFCL			;IGNORE ERROR
	JRST REGO(R)		;AND RESTART PROGRAM FOR NEXT COMMAND

;SUBROUTINE TO WRITE A WORD INTO THE FILE

WWORD:	JUMPL Q,WWORD1(R)	;NEED A NEW POINTER?
	MOVE Q,DBUFP(R)		;YES.  [-1000,,DBUF].
	ADDI Q,(R)		;RELOCATE
WWORD1:	MOVEM W,0(Q)		;PUT WORD INTO BUFFER
	AOBJN Q,CPOPJ(R)	;COUNT POINTER. DONE?
	PUSHJ P,WRDATA(R)	;YES. OUTPUT PAGE, IF POSSIBLE
	JRST WRTER(R)		;NO GOOD.
	AOS LENGTH(R)		;RECORD 1 PAGE WRITTEN
	POPJ	P,		;OK. RETURN.

SPARWT:	ADD	M,R
	MOVE	W,GO+CODSIZ+101-SAXBAS(M)	;GET DATA FROM SAVED AREA
	SUB	M,R
	JRST	DUMPL6(R)

;COMMAND TO SET SENSE SWITCHES

SENSET:
	JRST	REGO(R)		;PROCESS NEXT COMMAND
;SUBROUTINE TO LOOK FOR A FILE.
;EXPECTS PPN, FNAME, AND FEXT.

   ;FIRST TRY TO FIND THE FIRST UNIT IN THE STR.
LOOK:	SETZM	SLUNIT(R)	;START AT UNIT ZERO.
	PUSHJ	P,FNDUNI(R)	;TRY TO FIND FIRST UNIT.
	POPJ	P,		;COULDN'T FIND IT.

   ;FOUND A UNIT, NOW LOOK IN THE MFD FOR THE DESIRED UFD ENTRY.
	SKIPN	NAME,PPN(R)	;GET UFD NAME.
	MOVE	NAME,SYSPPN(R)	;IF NONE, ASSUME 1,4.
	MOVSI	EXT,(SIXBIT /UFD/);EXTENSION IS UFD.
	MOVE	RET,HMCMFD(R)	;RET PNTR OF MFD RIB.
	PUSHJ	P,SRCHFD(R)	;SEARCH FOR THE REQUESTED UFD
	POPJ	P,		;NOT THERE.

   ;FOUND THE UFD ENTRY, NOW LOOK IN THE UFD FOR THE FILE ENTRY.
	MOVE	NAME,FNAME(R)	;NAME OF FILE TO SEARCH FOR.
	MOVSI	EXT,(SIXBIT /SAV/) ;ASSUME SAV EXTENSION
	SKIPE	FEXT(R)		;UNLESS ONE SUPPLIED
	HLLZ	EXT,FEXT(R)	;IN WHICH CASE, USE IT.
	MOVE	RET,4(A)	;RET/ RET POINTER TO UFD.
	PUSHJ	P,SRCHFD(R)	;SEARCH FOR THE FILE IN THE UFD
	POPJ	P,		;NO SUCH FILE.
	MOVE	RET,4(A)	;RET/ RET PNTR TO FILE'S RIB.
	MOVEM	RET,PRMRIB(R)	;
	PUSHJ	P,GETRIB(R)	;GET THE RIB, CHECK IT.
	POPJ	P,		;NO LUCK. ASSUME FILE NOT THERE.
	HLLZ	A,RBUF+RIBEXT(R) ;GET THE EXTENSION FROM RIB.
	CAMN	A,EXT		;DESIRED EXTENSION?
	CAME	NAME,RBUF+RIBNAM(R) ;AND NAME?
	JRST	BADFIL(R)	;NO. QUIT, RIB BAD.
	JRST	CPOPJ1(R)	;SUCCESSFUL RETURN
;SUBROUTINE TO READ IN A RIB PAGE AND CHECK IT.
; EXPECTS RET/ RETRIEVAL PNTR TO RIB.
; SKIP RETURNS IF SUCCESSFUL, ELSE NON-SKIP RETURNS.

GETRIB:	PUSHJ	P,UNISEL(R)	;MAKE SURE ON RIGHT UNIT.
	POPJ	P,		;UNIT NOT THERE.
	MOVEI	A,RBUF-1(R)	;ADDRESS OF THE RIB BUFFER.
	PUSHJ	P,RDPAG(R)	;READ THE FILE'S RIB
	POPJ	P,		;COULDN'T READ IT
	MOVE	A,RBUF+PAGCOD(R) ;CHECK THE CODE WORD
	CAMN	RET,RBUF+PAGSLF(R) ;CHECK PHYSICAL ADDR OF RIB VS DATA
	CAIE	A,CODRIB	; ..
	JRST	BADFIL(R)	;NO GOOD.
	MOVEI	POSRET,RBUF+RIBSFS(R) ;PNTR TO RETRIEVAL PNTR.
	SKIPE	RBUF+RIBRIB(R)	;IS THIS A PRIME RIB?
	JRST	CPOPJ1(R)	;NO.
	MOVE	A,RBUF+RIBSIZ(R) ;YES.  LENGTH OF FILE.
	MOVEM	A,LENGTH(R)	;SAVE FOR EOF TEST
	MOVEI	POSRET,RBUF+RIBPFS(R)
	JRST	CPOPJ1(R)	;SUCCESSFUL RETURN
;SUBR TO SEARCH A UFD FOR FILE & EXT.
; EXPECTS RET/ RETRIEVAL PNTR TO RIB OF THE UFD.
; ON SUCCESS, SKIP RETURNS WITH A/ ADDR OF FILE ENTRY IN BUFFER.

SRCHFD:	LDB	A,RBYPNO(R)	;THE PAGE TO READ RIB FROM HAD
	JUMPE	A,BADDSK(R)	;BETTER NOT BE PAGE ZERO.
	PUSHJ	P,GETRIB(R)	;GET THE RIB.
	POPJ	P,		;CAN'T READ IT.
	PUSHJ	P,HASH(R)	;COMPUTE HASH NUMBER FOR FILE.
	ADDI	POSRET,-1(A)	;GET LOC OF RETRIEVAL PNTR.
SRCHF1:	PUSHJ	P,GTDATA(R)	;READ THIS PAGE OF THE UFD.
	POPJ	P,		;ERROR RETURN.
	MOVE	A,DBUFP(R)	;POINTER TO THE DATA BUFFER
	ADDI	A,(R)		;RELOCATE
SRCHF2:	SKIPN	(A)		;AT END OF DATA IN THIS PAGE?
	JRST	SRCHF5(R)		;YES.
	CAME	NAME,0(A)	;NO.  GET A FILE NAME
	JRST	SRCHF3(R)	;NO MATCH. MOVE ON.
	HLLZ	B,1(A)		;CHECK THE EXTENSION
	CAMN	B,EXT		;IS IT RIGHT TOO?
	JRST	CPOPJ1(R)	;YES. GOOD RETURN, ANSWER AT (A)
SRCHF3:	ADD	A,[4,,4](R)
	AOBJN	A,SRCHF2(R)	;CHECK NEXT FILE IN UFD.

    ;HERE TO GO TO "NEXT" PAGE OF UFD.
SRCHF5:	SKIPN	POSRET,DBUF+UFDLNK(R)
	POPJ	P,		;NO "NEXT" PAGE.
	ADDI	POSRET,RBUF+RIBPFS(R) ;LOC OF NEXT PNTR TO POSRET.
	JRST	SRCHF1(R)		;(UFD RIBS ARE NOT EXTENDED.).




;SUBR TO RETURN THE HASH NUMBER IN A, GIVEN THE FILENNAME
;IN NAME.

HASH:	MOVE	A,NAME
	TLZ	A,(1B0)
	PUSH	P,B
	HLRZ	B,HMCHSH(R)
	IDIVI	A,(B)
	MOVEI	A,1(B)
	POP	P,B
	POPJ	P,
;SUBR TO GET CORRECT UNIT FROM RETRIEVAL POINTER IN RET.

UNISEL:	LDB	A,RBYUNI(R)	;A/ UNIT NUMBER.
	CAMN	A,HMCLUN(R)	;ALREADY AT THIS UNIT?
	JRST	CPOPJ1(R)	;YES. NO NEED TO CHANGE UNITS
	MOVEM	A,SLUNIT(R)	;NO. NEED TO FIND IT.
	PUSH	P,RET		;SAVE THE RETRIEVAL PNTR.
	PUSHJ	P,FNDUNI(R)	;FIND THE UNIT
	SOS	-1(P)		;NOT THERE. SET FOR NON-SKIP RETURN.
	POP	P,RET		;RESTORE RETRIEVAL POINTER.
	JRST	CPOPJ1(R)	;AND SKIP RETURN.




;SUBROUTINE TO READ NEXT PAGE OF DATA INTO DBUF.
; EXPECTS POSRET TO BE ADDR OF NEXT RETRIEVAL POINTER.

GTDATA:	SKIPGE	LENGTH(R)	;ANY DATA LEFT?
	POPJ	P,		;NO.
	MOVNI	A,1000		;SEE IF ANY LEFT
	ADDB	A,LENGTH(R)	;COUNT FILE SIZE DOWN
	PUSHJ	P,GETRET(R)	;SELECT NEXT DATA PAGE OF FILE
	POPJ	P,		;NONE LEFT.
	MOVEI	A,DBUF-1(R)	;SELECT DATA BUFFER
	PJRST	RDPAG(R)	;READ THE PAGE AND RETURN
				; SKIP RETURN IF NO ERROR
;SUBROUTINE TO GET NEXT RETRIEVAL POINTER.
; EXPECTS POSRET TO BE THE ADDRESS OF THE NEXT PNTR.
; NON-SKIP RETURNS IF ERROR, ELSE SKIP RETURNS WITH THE
; RETRIEVAL PNTR IN RET AND POSRET ADJUSTED TO THE NEXT PNTR
; LOCATION (MAY BE EO RIB).

GETRET: CAILE	POSRET,RBUF+RIBLST(R) ;AT END OF THIS RIB?
	JRST	GETRT4		;YES.
GETRT2:	SKIPE	RET,(POSRET)	;NO.  PNTR IS EOF?
	TLNE	RET,RBINDX	;NO, ALSO NO INDX PAGES ALLOWED.
	POPJ	P,		;FAIL.
	JUMPL	RET,GETRT3(R)	;JUMP IF SPARE RIB PNTR.
	TLNN	RET,RBREAL	;REAL BIT ON?
	POPJ	P,		;BAD PNTR.
	PUSHJ	P,UNISEL(R)	;
	POPJ	P,		;
	AOJA	POSRET,CPOPJ1(R)	;YES, GOOD POINTER.

    ;HERE IF SAW SPARE RIB PNTR.  GET THE SPARE RIB.
G:	TLZ	RET,RBSPAR	;
	PUSHJ	P,GETRIB(R)	;GET THE SPARE RIB.
	POPJ	P,		;BAD.
	JRST	GETRT2(R)	;CONTINUE.

    ;HERE FROM EO RIB.  BACK TO HIGHER LEVEL.
GETRT4:	SKIPN	RET,RIBRIB+RBUF(R) ;BAD RIB STR IF PRIME RIB.
	POPJ	P,		;
	PUSH	P,RIBRPS+RBUF(R) ;SAVE POSITION IN HIGHER RIB.
	PUSH	P,LENGTH(R)	;
	PUSHJ	P,GETRIB(R)	;TRY TO GET HIGHER RIB.
	POPJ	P,		;FAILED.
	POP	P,LENGTH(R)	;
	POP	P,POSRET	;GOT HIGHER RIB.
	ADDI	POSRET,RBUF(R)	;
	AOJA	POSRET,GETRET(R) ;GO LOOK AT IT.
;ROUTINE TO FIND A PARTICULAR LOGICAL UNIT IN THE STRUCTURE.
; EXPECTS UNIT NO. WRS STRUCTURE IN SLUNIT.
;SKIP RETURN IF FOUND.

FNDUNI:
	SETZM	TTYPE(R)	;CLEAR SEARCH TEMPS
	MOVEI	K,1
FNDUL3:	SETZM	TCHAN(R)
FNDUL1:	SETZM	TUNIT(R)	; ..
FNDUL2:	MOVE	K,TTYPE(R)	;GET KONTROLLER TYPE
	MOVE	N,TUNIT(R)	;AND UNIT NUMBER
	MOVE	C,TCHAN(R)	;CHANNEL NUMBER FOR SA-10
	PUSHJ	P,HOME(R)	;TRY TO READ ITS HOME PAGE
	JRST	FNDUNX(R)	;NO GOOD. ON TO NEXT.
	MOVE	A,HMCSNM(R)	;FOUND THIS UNIT. IS IT
	MOVE	B,HMCLUN(R)	;THE DESIRED ONE?
	CAMN	A,STRNAM(R)	;CHECK AGAINST DSKB AND
	CAME	B,SLUNIT(R)	;SUPPLIED UNIT NO.
	JRST	FNDUNX(R)	;NO GOOD. ON TO NEXT.
	JRST	CPOPJ1(R)	;CORRECT. SKIP RETURN.

FNDUNX:	AOS	A,TUNIT(R)	;COUNT TO NEXT UNIT ON KONTROLLER
FNDUL4:	CAIG	A,UNIMAX	;TOO BIG?
	JRST	FNDUL2(R)	;NO. GO CHECK THIS ONE
FNDUL5:	AOS	A,TTYPE(R)		;YES. COUNT TO NEXT TYPE OF KONTROLLER
	CAIG	A,TYPMAX	;ALL OF THOSE GONE BY?
	JRST	FNDUL3(R)	;NO. TRY THIS ONE.
	POPJ	P,		;ALL TRIED. GIVE FAIL RETURN.
;ROUTINE TO DETERMINE WHETHER A UNIT EXISTS, AND IF SO, TO READ
;ITS HOME PAGE INTO THE DATA BUFFER, CHECK IT, AND THEN SAVE
;THE LOCS OF INTEREST IN IT.

;CALLING SEQUENCE:
;K/	KONTROLLER TYPE INDEX
;N/	UNIT NUMBER, 0-7
;C/     SA-10 CHANNEL NUMBER
;	PUSHJ P,HOME
;	NOT THERE RETURN
;	OK RETURN

;AT THIS POINT, ANY NEEDED UNIT PARAMETERS ARE SAVED, SUCH AS R.TYPE
HOME:	MOVEM N,CUNIT(R)	;SAVE CURRENT UNIT NUMBER
	MOVEM K,CTYPE(R)	;AND KONTROLLER TYPE
	MOVEM	C,CCHAN(R)
	MOVEI C,UNIINI(R)	;ABS ADR OF INI TABLE BASE(ARG FOR SETCHN)
	TLO C,K			;SET INDEX FIELD FOR RELOCATION BY K(KONT. TYPE)
	LDB A,[POINT 7,@C,9](R)	;KONTROLLER DEVICE CODE FROM INI TABLE
	TRZ F,R.KDEV		;CLEAR KONTROLLER FIELD
	TRO F,(A)		;SET KONTROLLER FIELD
	MOVE	RET,HOME1(R)	;WANT TO READ FIRST HOME PAGE
	MOVEI A,DBUF-1(R)	;BUFFER FOR TEST I/O
	PUSHJ P,SETCHN(R)	;SET UP CHANNEL COMMAND LIST
				; AND CALL INITIALIZE KONT. ROUTINE
	POPJ	P,		;ERROR. NOT THERE.
HOM1:	MOVEI A,DBUF-1(R)	;GET HOME PAGE INTO DATA BUFFER.
	PUSHJ P,RDPAG(R)	;TRY TO READ THE HOME PAGE
	JRST HOM2(R)		;CAN'T READ THAT ONE
	MOVE A,DBUF+PAGCOD(R)	;GET THE CODE WORD
	CAIN A,CODHOM		;IS IT RIGHT?
	SKIPE DBUF+HOMREF(R)	;AND NOT NEEDING REFRESHING?
	JRST HOM2(R)		;NO GOOD.
	MOVE	A,DBUF+HOMMFD(R) ;GOOD, SAVE LOCS OF INTEREST.
	MOVEM	A,HMCMFD(R)	;
	MOVE	A,DBUF+HOMHSH(R) ;
	MOVEM	A,HMCHSH(R)	;
	MOVE	A,DBUF+HOMLUN(R) ;
	MOVEM	A,HMCLUN(R)	;
	MOVE	A,DBUF+HOMSNM(R) ;
	MOVEM	A,HMCSNM(R)	;
	JRST CPOPJ1(R)		;OK RETURN.

HOM2:	CAMN	RET,HOME2(R)	;TRIED BOTH PAGES?
	POPJ	P,		;YES. GIVE FAIL RETURN
	MOVE	RET,HOME2(R)	;NO, TRY ANOTHER ONE.
	JRST HOM1(R)		;READ SECOND HOME PAGE

;INITIALIZE KONTROLLER ROUTINES (CONSO IRRELEVANT - USED TO GET DEVICE CODE

;ifcpu(f3)<
UNIINI:	CONSO 0,APINI(R)
;<>;end ifcpu(f3)
TYPMAX==.-UNIINI-1		;MAX NUMBER OF KONTROLLERS
;ifcpu(f3)<>
	UNIMAX==3	;ONLY 4 UNITS ON AN F3
;<>;end ifcpu(f3)
SAUNMX==77
SACHMX==3
;ifcpu(f3)<>
;AMPEX/CDC TYPE DRIVE HANDLER FOR F3 PROCESSOR

RTYCNT==20000

DRVTYP==CDC
CDC==1
AMPEX==0

IFE DRVTYP-CDC,<
SPT==^D8		;SECTORS PER TRACK (DEPENDS ON HOW FORMATTED)
TPC==^D10		;TRACKS PER CYLINDER (NUMBER OF HEADS)
CPU==^D823-^D10		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>
IFE DRVTYP-AMPEX,<
SPT==^D8		;SECTORS PER TRACK
TPC==^D5		;TRACKS PER CYL (NUMBER OF HEADS)
CPU==^D815-^D5		;CYLINDERS PER UNIT (TAKE AWAY SOME FOR MAINTAINENCE)
>;END IFN AMPEX
PPC==SPT*TPC			;PAGES PER CYLINDER
BPC==PPC*4			;BLOCKS PER CYLINDER
PPU==PPC*CPU			;PAGES PER UNIT
SPT==^D8				;SECTORS PER TRACK
BPT==SPT*^D4			;BLOCKS PER TRACK
USPR==^D17300	;MICROSECONDS PER REVOLUTION.

;DISK IOTS AND REGISTER BIT NAMES.
OPDEF RCMD	[715000000000]	;READ COMMAND REGISTER
	SUNT==1B0		;SELECTED UNIT NOT THERE (SELECT ERROR)
	SUWP==1B1		;SELECTED UNIT WRITE PROTECT
	SUNR==1B2		;SELECTED UNIT NOT READY
;---
	SUOC==1B3		;SELECTED UNIT ON CYLINDER
				; SHOULD ALWAYS BE SET EXCEPT AFTER RECAL UNTIL HEADS ALIGN
	SUSE==1B4		;SELECTED UNIT SEEK ERROR (DETECTED BY DRIVE)
				; RECAL MANDATORY AFTER THIS ERROR, FAULT CLEAR WILL NOT TURN THIS OFF.
	SUF==1B5		;SELECTED UNIT FAULT (DETECTED BY DRIVE)
;---
	SUA==1B6		;SELECTED UNIT ATTENTION
				; SET BY LEADING EDGE OF ON CYLINDER (BIT 3)
	HDECC==1B7		;ECC ERROR ON HEADER
	CI==1B8			;CONTROL IDLE (ONLY IF NO DATA XFER AND NO SEEKS OR RECALS GOING)
;---
	SECC==1B9		;SOFT ECC ERROR (NOT YET IMPLEMENTED IN F3 MICROCODE)
	HECC==1B10		;ECC UNRECOVERABLE ERROR

;FOLLOWING BITS ARE DETECTED BY CONTROLLER:
	ROE==1B11		;READ OVERRUN ERROR
;---
	WOE==1B12		;WRITE OVERRUN ERROR
	SOE==1B13		;SECTOR OVERRUN ERROR
	IPE==1B14		;INTERNAL PARITY ERROR (ONLY VALID IF AE, BIT 28, IS ZERO)
;---

;FOLLOWING ARE FROM LAST LCMD

	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH FC AND CF)
;---
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
;	19 UNUSED
;	20 UNUSED
;---
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
;---
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
;---
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)

;END OF FROM RCMD BITS
	AE==1B28		;ANY  ERROR (EXCEPT IPE, BIT 14)
	AA==1B29		;ANY UNIT ATTENTION
;---

;FROM LCMD
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE

	NA==1B31		;NOT ACTIVE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
;---
;BITS 33, 34 NOT IMPLEMENTED.

	MPE==1B35		;MEMORY PARITY ERROR
;---
OPDEF RMA	[716000000000]	;READ MEMORY ADDRESS
OPDEF RDA	[717000000000]	;READ DISK ADDRESS (IN PAGES)
	AMSUNI==^D3		;SIZE OF UNIT BYTE
	AMPUNI==^D6		;RIGHTMOST BIT
	ROTUNI==-<AMPUNI+1>	;NUMBER OF PLACES TO ROTATE TO GET UNIT FIELD IN
	AMSCYL==^D12
	AMPCYL==^D19
	AMSTRK==^D8
	AMPTRK==^D27
	AMSSEC==^D8
	AMPSEC==^D35
	LDAMSK==034000,,177400	;MASK FOR $0% AND $0O IN DDT
OPDEF RECC	[720000000000]	;READ CONTROL REGISTER
OPDEF LCMD	[721000000000]	;LOAD COMMAND REGISTER
	USC==1B15		;USE SECTOR COUNTER (FOR RPS, TELLS
				; CONTROLLER TO LISTEN TO DRIVE POSITION)
	REL==1B16		;RELEASE (FOR MULTI-PROCESSOR INTERLOCKING)
	RECAL==1B17		;RECALIBRATE (RESETS SEEK ERROR) (USE WITH FC AND CF)
	FC==1B18		;FAULT CLEAR (RESETS SEL UNIT FAULT - USE COMMAND 4)
	SOM==1B21		;SERVO OFFSET MINUS
	SOP==1B22		;SERVO OFFSET PLUS (OFFSET ONLY ON AMPEX DRIVES, NOT CDC)
	CFM==1B23		;COMMAND FROM MEMORY
				; SENDS DATA FROM MEMORY TO DISK (USE WITH WRITE COMMANDS)
	CMD0==1B24		;COMMAND BITS
	CMD1==1B25
	CMD2==1B26
	CMD32==1B27		;32 BIT MODE PACKING
		READ==0B26		;READ PAGE
		WRITE==CFM+1B26	;WRITE PAGE (WITH CFM FOR CONVENIENCE)
		WRITEA==3B26	;WRITE ALL (SECTOR AND FORMAT DATA)
		CF==4B26		;CONTROL FUNCTION
;		SEEK==5B26		;SEEK. (NOT IMPLEMENTED YET . . .)
	AAIE==1B30		;ANY ATTENTION INTERRUPT ENABLE
	DIE==1B32		;DONE INTERRUPT ENABLE (SET BY DCONO WITH NOZERO PI ASSIGNMENT)
OPDEF LMA	[722000000000]	;LOAD MEMORY ADDRESS
OPDEF LDA	[723000000000]	;LOAD DISK ADDRESS
	SU==1B7			;SELECT UNIT
				;MUST BE CLEARED AND SET TO SELECT A UNIT.
OPDEF LECC	[724000000000]	;CLEARS ECC LOGIC, STARTS AND INITS CONTROL.
	SC==1			;START CONTROL
	IC==2			;INIT CONTROL (SEND BEFORE STARTING CMD)
OPDEF DCONO	[740000000000]	;CONO TO DISK CONTROL TO SET PI ASSIGNMENT
OPDEF DCONI	[741000000000]	;CONI FROM DISK CONTROL OPCODE
	DIDLE==10		;SET IF CONTROL IS IDLE
	DPIA==7B35		;PI ASSIGNMENT.
				;NOTE THAT NONZERO PI ASSIGNMENT SETS DIE (SEE LCMD)
OPDEF DCONSO	[742000000000]
OPDEF DCONSZ	[743000000000]

;ROUTINE TO START A FUNCTION UP ON CONTROL

DOKON:	LECC	[IC](R)		;INIT CONTROL
	LCMD	A		;DO THE COMMAND
	LECC	[SC](R)		;START CONTROLLER
	POPJ	P,		;AND RETURN.

CLRKON:	MOVE	A,[CF+FC](R)	;COMMAND FUNCTION FAULT CLEAR
DOWKON:	PUSHJ	P,DOKON(R)		;DO THE COMMAND AND THEN
WATKON:	MOVEI	B,RTYCNT	;NUMBER OF TIMES TO WAIT
	RCMD	A
	TLNN	A,(CI)		;CONTLOL IDLE YET?
	SOJG	B,.-2(R)		;NO
	JUMPG	B,CPOPJ1(R)	;JUMP IF IT WENT IDLE
	POPJ	P,		;DIDN'T.

APINI:	HRRZ	A,CUNIT(R)	;GET UNIT SELECTED
	ROT	A,ROTUNI
	LDA	A
	TLO	A,(<SU>)
	LDA	A
	PUSHJ	P,CLRKON(R)	;CLEAR OUT CONTROL
	  JFCL			;IGNORE ERROR FOR NOW
	RCMD	A		;GET STATUS
	TLNE	A,(<SUNT!SUNR>) ;NON-SKIP IF NOT THERE OR NOT READY
	POPJ	P,
	MOVE	A,[CF+FC+RECAL](R)	;DO A RECAL
	PUSHJ	P,DOWKON(R)
	  POPJ	P,		;DO RECAL NOW.
	MOVSI	A,^D10		;WAIT A LONG TIME
	RCMD	B
	TRNN	B,NA		;WAIT TILL NOT ACTIVE
	SOJG	A,.-2(R)
	JUMPE	A,CPOPJ(R)	;GO IF TIMED OUT
	RCMD	A		;GET STATUS BITS AGAIN
	TRNN	A,AE		;ERROR RETURN IF ANY ERRORS
	AOS	(P)		;NO ERRORS
	POPJ	P,

;HERE TO READ OR WRITE ONE PAGE WITH A CONTAINING THE BLOCK NUMBER
; AND CHNCMD CONTAINING THE IOWD

APWRIT:	SKIPA	C,[WRITE](R)
APREAD:	MOVEI	C,READ
	ROT	A,-^D2		;CONVERT TO PAGES
	TLNE	A,600000	;MAKE SURE WAS REQUESTING AN EVEN PAGE BOUDARY
	HALT	.(R)
	PUSH	P,C		;SAVE COMMAND
	IDIVI	A,PPC		;GET A/CYL, B/PAGES INTO CYL
	IDIVI	B,SPT		;GET B/TRACK, C/SECTOR IN TRACK
	DPB	B,[POINT AMSTRK,C,AMPTRK](R)
	DPB	A,[POINT AMSCYL,C,AMPCYL](R)
	MOVE	A,CUNIT(R)
	ROT	A,ROTUNI	;GET UNIT NUMBER INTO POSITION
	TDO	C,A
	LDA	C
	TLO	C,(<SU>)
	LDA	C
	HRRZ	C,CHNCMD(R)
	ADDI	C,1		;GET ACTUAL ADDRESS
	LMA	C
	HLRE	C,CHNCMD(R)
	MOVMS	C
	CAIE	C,1000
	HALT	.(R)		;MAKE SURE REQUESTING EXACTLY A PAGE
	PUSHJ	P,CLRKON(R)	;CLEAR OUT CONTROL
	  JFCL			;IGNORE FOR NOW
	POP	P,A		;GET COMMAND INTO A
	PUSHJ	P,DOKON(R)	;START THE TRANSFER
	MOVSI	A,^D10		;TIMEOUT IS ABOUT 10 SECS.
	RCMD	B
	TRNN	B,NA		;WAIT TILL NOT ACTIVE
	SOJG	A,.-2(R)
	JUMPE	A,CPOPJ(R)	;TIMED OUT, ERROR
	RCMD	A		;OK, GET COMMAND
	TRNE	A,AE		;MAKE SURE NO ERROR BITS ON
	POPJ	P,		;SORRY.
	TLNE	A,(<IPE>)	;THIS IS ONLY VALID IF AE OFF
	POPJ	P,		;NO GOOD.
	HRRZ	B,CHNCMD(R)
	RMA	A
	TLZ	A,777774	;CLEAR UNUSED BITS
	SUBI	A,1(B)		;GET NUMBER OF WORDS XFERRED
	CAIE	A,1000
	POPJ	P,		;WRONG COUNT
	JRST	CPOPJ1(R)	;OK, SUCCESSFUL XFER.
;<>;end ifcpu (f3)
;ROUTINE TO READ A PAGE FROM THE DEVICE KONTROLLER AND UNIT IN
;CTYPE AND CUNIT INTO THE BUFFER AT (A)+1, FROM RETRIEVAL PNTR
;IN RET. SKIP RETURN IF SUCCESSFUL, NON-SKIP IF ANY HARDWARE ERRORS

RDPAG:	PJSP C,SETCHN(R)	;SETUP CHANNEL CONTROL WORD AND CALL
				; PROPER READ ROUTINE BELOW DEP. ON TYPE

;ifcpu(f3)< >
	Z APREAD(R)	;AMPEX/CDC
;<>;end ifcpu (f3)

;ROUTINE TO WRITE A PAGE AT LOGICAL PAGE NUMBER IN RET,
; ON DEVICE IN CTYPE AND CUNIT, WRITING FROM BUFFER AT (A)+1
; SKIP RETURN IF SUCCESSFUL.

WRDATA:	PUSHJ	P,GETRET(R)	;GET NEXT PAGE OF FILE
	POPJ	P,		;NOT POSSIBLE
	MOVEI A,DBUF-1(R)	;SET TO WRITE FROM DATA BUFFER
				;FALL INTO WRPAG
WRPAG:	PJSP C,SETCHN(R)	;SETUP CHANNEL CONTROL WORD AND CALL
				; PROPER WRITE ROUTINE BELOW DEP. ON TYPE

;ifcpu(f3)< >
	Z APWRIT(R)	;AMPEX/CDC
;<>;end ifcpu (f3)

;SUBROUTINE TO SETUP CHANNEL, THEN DISPATCH TO DEVICE DEP ROUTINE
;CALL:	MOVEI A,ABS. ADR. OF FIRST DATA WORD-1
;	MOVE RET, RETRIEVAL PNTR
;	HRRI C,ABS. ADR. OF FIRST WORD IN DISPATCH TABLE
;	PUSHJ P,SETCHN
;	ERROR RETURN
;	OK RETURN

SETCHN:	HRLI A,-1000		;MAKE IOWD FOR THE CHANNEL
	MOVEM A,CHNCMD(R)	;STORE IT.
	ADDI A,1
	SETZM CHNCMD+1(R)	;END OF CHANNEL CMD LIST
	LDB	A,RBYPNO(R)	;GET A/ PAGE NO.
	JUMPE	A,BADDSK(R)	;NOT ZERO.
	LSH	A,2		;CONVERT TO BLOCK NUMBER.
	MOVE K,CTYPE(R)		;WHAT KONTROLLER?
	ADDI C,(K)	;FORM ABS. ADR. OF PROPER DISPATCH TABLE ENTRY
	PJRST @(C)	;CALL DISPATCH ENTRY AS A SUBROUTINE AND RETURN
CPOPJ1:	AOS (P)			;SKIP RETURN
CPOPJ:	POPJ P,			;NO SKIP RETURN

SAXBAS=300

;TTY I/O SUBRS

CRLF:	MOVEI C,215		;CR, EVEN
	PUSHJ P,TYO(R)		;TYPE IT.
	MOVEI C,12		;LF, EVEN
;ifcpu(<ki,f3>)<>
TYO:	DATAO TTY,C		;SEND OUT CHAR
	CONSZ TTY,20		;WAIT FOR IDLE
	JRST .-1(R)		; ..
	POPJ	P,		;DONE.
;<>;end ifcpu(<ki,f3>)

PROMPT:	ASCIZ /BOOTS:/
DEFMON:	ASCIZ /LOADING (SYS)SYSTEM.SAV/
NOSAM:	ASCIZ /NO START ADRESS/
BADSWM:	ASCIZ /BAD SWITCH/
NOFILM:	ASCIZ /NO FILE/
RDERM:	ASCIZ /READ ERR OR EOF/
WRTERM:	ASCIZ /WRITE ERR OR EOF/
BADFLM:	ASCIZ /BAD FILE/
BADDKM:	ASCIZ /DISK SICK/

NOTDMP:	ASCIZ /PREVIOUS CRASH NOT SAVED/

NOSA:	MOVEI A,NOSAM(R)
	JRST ERROR (R)

BADSW:	MOVEI A,BADSWM(R)
	JRST ERROR(R)

NOFIL:	MOVEI A,NOFILM(R)
	JRST ERROR (R)

RDER:	MOVEI A,RDERM(R)
	JRST ERROR(R)

WRTER:	MOVEI A,WRTERM(R)
	JRST ERROR(R)

BADFIL:	MOVEI A,BADFLM(R)
	JRST ERROR(R)

BADDSK:	MOVEI A,BADDKM(R)
ERROR:	PUSHJ P,OUTMSG(R)
	JRST REGO(R)

OUTMSG:	HRLI A,(POINT 7,0)
	PUSHJ P,CRLF(R)
OUTMS1:	ILDB C,A
	JUMPE C,CPOPJ(R)
	PUSHJ P,TYO(R)
	JRST OUTMS1(R)


SYSPPN:	XWD 1,4			;DEFAULT PROJ-PROG
SYSTEM:	SIXBIT /SYSTEM/		;DEFAULT FILENAME
CRASH:	SIXBIT /CRASH/		;DEFAULT DUMP NAME
DBUFP:	XWD -1000,DBUF		;POINTER TO DATA PAGE
BLTXWD:	XWD 40,41		;FOR CORE-CLEARING
SIXPTR:	XWD 440600,W		;POINTER FOR SIXBIT NAME
STRING:	POINT 7,CMDSTR(R)
CMDSTR:	BYTE (7) "/","D",15,15,0

STRNAM: SIXBIT /DSKB/
RBYUNI:	POINT 8,RET,^D16
RBYPNO: POINT ^D19,RET,^D35
HOME1: XWD RBREAL,LPNHOM
HOME2: XWD RBREAL,LP2HOM
U(PRMRIB)
U(HMCHSH)
U(HMCLUN)
U(HMCMFD)
U(HMCSNM)
U(DEVICE)
U(FNAME)
U(FEXT)
U(PPN)
U(SWITCH)
U(CTYPE)
U(CCHAN)
U(CUNIT)
U(TTYPE)
U(TCHAN)
U(TUNIT)
U(SLUNIT)
U(LENGTH)

LIT

UU(PDL,30)
UU(CHNCMD,2)

UU(ZZMAX,0)
MBOOTL==BOOTSA-.	;MINUS LENGTH OF BOOTS CODE-WRITTEN BY WTBOOTS
IFE WTBOOT,<		;START ADR. IF ABSOLUTE PAPER TAPE
	END JRST GO
>
IFN WTBOOT,<		;NO START ADR. IF LOADED WITH WTBOOT
IFG <.-GO-CODSIZ>,<
PRINTX BOOTS TOO BIG
>
	BLOCK	CODSIZ-<.-GO>	;PAD TO PROPER SIZE
;ifcpu(<ki,kl,f3>)<>
;ROUTINE TO WRITE BOOTS ONTO THE FIRST SIXTEEN UNITS OF DSKB.

LICTAB==-20		;LICENSE GETTAB TABLE
LICOPR==100000		;OP LIC
.STTYO==0		;SETUUO FUNCTION TO WRITE TO OPR
CTYSTR:	
;ifcpu(f3) <>
	ASCIZ /
F3/
;<>;end ifcpu (f3)

DMPIT:	RESET
	HRROI	1,LICTAB
	GETTAB	1,
	 MOVEI	1,0
	TRNN	1,LICOPR	;DOES USER HAVE OP LIC?
	JRST	[OUTSTR [ASCIZ /
OP LIC REQUIRED/]
		 EXIT]
	MOVE	1,[.STTYO,,CTYSTR]	;TELL OPR THAT
	SETUUO	1,			; NEW BOOTS HAS BEEN
	 JFCL
	MOVE	1,[.STTYO,,[ASCIZ/ BOOTS WRITTEN TO HOME FILE
/]]					; WRITTEN TO DISK
	SETUUO	1,
	 JFCL

	MOVEI	5,17		;NUMBER OF UNITS.
WRTLP:	MOVE	1,[SIXBIT/DSKB/]
	MOVEM	1,INITLC
	MOVE	4,[POINT 6,INITLC,^D23]
	MOVE	2,5
	IDIVI	2,10
	JUMPE	2,WRTLP3
	ADDI	2,'0'
	IDPB	2,4
WRTLP3:	ADDI	3,'0'
	IDPB	3,4
	INIT	1,17
INITLC:	0
	0
	JRST	WRTLP4
	USETO	1,BOOTBK
	OUTPUT	1,COM
WRTLP4:	SOJGE	5,WRTLP
	EXIT
;<>;end ifcpu(<ki,kl,f3>)

COM:	IOWD	CODSIZ,GO
	0

	END DMPIT
 K Xù