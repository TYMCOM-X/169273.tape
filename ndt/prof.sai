
BEGIN "PROFILE" 

COMMENT A PROGRAM TO PRODUCE PROGRAM PROFILES USING THE
 LIST AND COUNTER FILES CREATED BY USING THE /K OPTION
 OF SAIL;

IFC DECLARATION(GTJFN) THENC
   DEFINE WANTBANGSW = "TRUE";
   DEFINE DECSW = "FALSE";
   DEFINE TENXSW="TRUE";
   REQUIRE "
COMPILING TENEX VERSION
" MESSAGE;
ELSEC
   IFCR DECLARATION(IFGLOBAL) THENC
      DEFINE DECSW = "FALSE";
      DEFINE TENXSW = "FALSE";
      DEFINE WANTBANGSW = "FALSE";
      REQUIRE "
COMPILING STANFORD AI VERSION
" MESSAGE;
ELSEC
   DEFINE DECSW = "TRUE";
   DEFINE TENXSW="FALSE";
   DEFINE WANTBANGSW = "TRUE";
   REQUIRE "
COMPILING DEC-SYSTEM 10 VERSION
" MESSAGE;
ENDC
ENDC

DEFINE SWTSIZ="12", GOODSWT="""BCFIKLNST""",NEXTCOUNTER="KOUNTR[IKNT_IKNT+1]",
SRCMODE="'17", LSTMODE="0", RELMODE="0", SRCEXT="""KNT""",LSTEXT="NULL",
RELEXT="""PFL""",PROCESSOR="""PROFILE""",EMRK="132",OFILE="BIN",TAB="'11",
CMNTCODE="133";
own integer FINDFF,FINDSEMI,FINDLF,FINDTAB;
	simple procedure reserveSome;
	begin FINDFF_getbreak;FINDSEMI_getbreak;
		FINDLF_getbreak;FINDTAB_getbreak; end;
	require reserveSome initialization;
REQUIRE 400 STRING!PDL; REQUIRE 600 SYSTEM!PDL;

STRING ARRAY NAMES[1:10];
INTEGER ARRAY STRT[1:11],INP[1:4];
INTEGER I,J,N,IFIL,NFIL,FL,CURCOUNT,Q,NTABS,NT,NLEN,OLEN,TYP1,TYP2,
  NTYPE,OTYPE,NLINES,IKNT,NKNT,SEMICOL,FFLAG,PLVL,MXKTR,STPFLG,
  CONIND,BLKIND,LASCOL,CTRCOL,MAXCOL,TI1,TI2,TI3,
  SPAC1,SPAC2,SPACO,SPACT,SPACN,FIRSTSCAN,TIA,IGNCMT;
STRING HEAD1,HEADNG,TABS,NLINE,OLINE,STR1,STR2,STR1A,STR2A,BLANX,BFILL,
  CONFIL,TS1,TS2,IGN;

procedure LocError(integer code; string why);
	USERERR(0,0,why & "
FILE= "&NAMES[IFIL]&"
OLINE= "&OLINE&"
NLINE= "&NLINE&"
NEXT 2 TOKENS= "&STR1A&STR2A);

    DEFINE DSCR="COMMENT ";
    DEFINE #=" "; #
DSCR SCNCMD.SAI -- a package for scanning CUSP-like commands.

DES This package provides a function COMMAND!SCAN, and a set
 of variables and defined values with the following proerties:
PAR The following values must be DEFINEd:
  SRCMODE, LSTMODE, RELMODE the data modes for the approp. files
   (define them all, even if you don't use them)
  SRCEXT, LSTEXT, RELEXT default extension names (they should
   expand to string constants) for the appropriate files.  Blank
   will also be checked as a possible extension for source files.
  PROCESSOR should expand to a string constant.  QQprocessor.RPG
   will be the RPG file looked up (at Stanford).
 The following variables must be set:
  ON!ETIME should be made 0 once only, to force opening of
   the command file.
  NX!TFIL should be made 0 to force COMMAND!SCAN to expect
   a new FILE_FILE command next, instead of more source files.
  WANTBIN should be made true if a `.REL' file is to be
   opened if a file is specified for it.
  WANTLST should be made true if a `.LST' file is to be
   opened if a file is specified for it.
  SOURCECOUNT, after the call on COMMAND!SCAN, may be changed,
   either permanently or temporarily, to control input.
RES on returning from COMMAND!SCAN, the following are available:
 WANTBIN, WANTLST -- true if a file was opened in the approp.
  position, false if false coming in, or no file specified.
 BINFIL, SRCFIL -- the file, extension, and PPN for the approp.
  files (strings).
 SRC, BIN, LST, CMD, DELCHNL (1-5) are channels reserved for
  the obvious functions.  You should use these names.
 CMDTBL, LINTBL, RBRK (15-17) are break tables used by
  COMMAND!SCAN.  Use them if you wish, but don't expect
  them to be there when you get back.
 CRLF,DSCR, and BLANKS are the obvious macros.  Redefine any but DSCR
  if you wish.
SID Channels 1-5, Break Tables 15-17 are reserved by
 COMMAND!SCAN.  Do GETCHANs to obtain channels, or
 be careful.
CAL call COMMAND!SCAN with no parameters.  The first time, and
 any time subsequently that it is called with NX!TFIL=0, it
 will expect optional LST and REL specs, separated by comma,
 followed by a left arrow in the command file, then one or
 more source file names separated by commas, terminated by
 a CRLF.  Only one source file is read the first time.  Subse-
 quent calls on COMMAND!SCAN (without touching NX!TFIL) will
 cause subsequent source files to be looked up--if no more exist
 an error message will be printed.  Set this to FALSE when you
 want a brand new command.  Set ON!ETIME once for every time
 the entire program is restarted.
;

    EXTERNAL INTEGER RPGSW;
    INTEGER WANTBIN,WANTLST,SRCBRK,SRCEOF,CMDBRK,ON!ETIME,NX!TFIL;
    INTEGER SOURCECOUNT,SWTP;
    STRING BINFIL,SRCFIL,SWTSTR;
    INTEGER ARRAY SWTVAL[1:SWTSIZ];
	INTEGER ARRAY BUF[0:'377];
    DEFINE CRLF="('15&'12)", BLANKS="(""                       "")";
INTEGER SRC,BIN,LST,CMND,DELCHNL;
own integer lintbl,cmdtbl,rbrk;
	simple procedure getbrktables;
	begin lintbl_getbreak;cmdtbl_getbreak;rbrk_getbreak; end;
	require getbrktables initialization;

    PROCEDURE COMMAND!SCAN;
    BEGIN "COMMAND SCAN"
       INTEGER EOF,FG,TIA,TIB,TIC,TID,SPCFIL,TIE,TIF;
       STRING CMNDFIL,LSTFIL,LINE,TSA,TSB,TSC,BKSTRNG,TSD,CMNDSTR;

    IFCR NOT TENXSW THENC
	SIMPLE INTEGER PROCEDURE TMPCORSTR
	    (INTEGER CODE; STRING FIL; REFERENCE STRING TEXT);
	BEGIN COMMENT Performs TMPCOR function CODE on FIL, transfering TEXT.
		Only functions 1 (read), 2 (read and delete), 3 (write) are legal.
		Value returned is that returned in AC by the UUO, !SKIP! is
		zero if no error, else !SKIP! is -1;
	EXTERNAL INTEGER !SKIP!;
	START!CODE LABEL FOOEY,WRLUP,WRBOT,WRCLR,NOTWRITE;
	DEFINE P="'17",SP="'16",!="COMMENT";
		MOVE	1,CODE;		! CHECK VALID CODES;
		CAIL	1,1;
		CAILE	1,3;
		 JRST	FOOEY;		! YOU LOSE;
		MOVE	2,BUF;		! FWA;
		MOVEI	2,-1(2);	! FWA-1 FOR IOWD;
		HRLI	2,-'400;	! COMPLETE THE IOWD;
		PUSHJ	P,CVSIX;	! CONVERT FIL TO SIXBIT IN AC1;
		TRZ	1,-1;		! PUT ZEROES IN RIGHT HALF;
				! FILE NAME AND IOWD NOW IN 1 AND 2;
		MOVSI	5,'440700;
		HRRI	5,1(2);		! BP TO BUF;
		MOVE	3,CODE;
		MOVE	4,-1(P);! PTR TO WD2;
		CAIE	3,3;
		 MOVEM	5,(4);		! SET RESULT BP IF SOME SORT OF READ;
		CAIE	3,3;
		 JRST	NOTWRITE;
		HRRZ	3,-1(4);	! LENGTH(TEXT);
		CAILE	3,'400*5;	! CHECK MAX LENGTH;
		 JRST	FOOEY;
		MOVE	4,(4);		! COUNT IN 3, BP IN 4;
		JRST	WRBOT;
	WRLUP:	ILDB	6,4;
		IDPB	6,5;
	WRBOT:	SOJGE	3,WRLUP;
		TDZA	6,6;	! CLEAR REMAINDER OF LAST WORD;
	WRCLR:	IDPB	6,5;
		TLNE	5,'760000;
		 JRST	WRCLR;
	NOTWRITE:MOVS	3,CODE;
		HRRI	3,1;	! PARAM AC FOR TMPCOR;
		SETZM	!SKIP!;
		CALLI	3,'44;
	FOOEY:	 SETOB	3,!SKIP!;
		SKIPGE 1,3;
		MOVEI 3,0;!	SET TO 0 IF NEGATIVE;
		IMULI	3,5;	! CONVERT TO CHAR COUNT;
		MOVE	2,CODE;
		MOVE	4,-1(P);! PTR TO WD 2;
		CAIE	2,3;
		 MOVEM	3,-1(4);! STORE CHAR COUNT IF SOME SORT OF READ;
		SUB	P,['3000003];
		JRST	@3(P);
	END; END;

     ENDC

       PROCEDURE FILENAME(REFERENCE STRING DEVICE,FILE);
       BEGIN "FILENAME"
	  PROCEDURE SWTGET;
	  BEGIN	"SWTGET"
		COMMENT mode "K" added by JFR 6-4-75;
	     SETBREAK(RBRK,"0123456789",NULL,"XAK");
	     TSC_SCAN(LINE,RBRK,CMDBRK);
	     SWTVAL[SWTP_SWTP+1]_CVD(TSC[1 TO  inf -1]);
	     TID_TSC[ inf  FOR 1];
	     TSD_GOODSWT;
	     FOR TIE_1 STEP 1 WHILE (TIF_LOP(TSD)) and TID neq TIF DO;
	     SWTSTR_SWTSTR&TIE;
	     IF	(CMDBRK_LINE)="/"  or  CMDBRK=")" THEN CMDBRK_LOP(LINE)
	  END "SWTGET";
	  SPCFIL_FALSE;
	  FILE_SCAN(LINE,CMDTBL,CMDBRK)	;COMMENT GET A DEVICE OR FILENAME;
	  IF CMDBRK = ":" THEN BEGIN
	     DEVICE_FILE; SPCFIL_TRUE; COMMENT FILE SPECIFIED, NOT INVENTED;
	     FILE_SCAN(LINE,CMDTBL,CMDBRK)
	  END ELSE
	  IF EQU(FILE,"LPT")  or  EQU(FILE,"LPT.")	THEN DEVICE_"LPT" ELSE
	   DEVICE_"DSK";
	  IF CMDBRK="["	THEN BEGIN
	     SETBREAK(RBRK,"]",NULL,"IA");
	     FILE_FILE&"["&SCAN(LINE,RBRK,CMDBRK);
	     FILE_FILE&SCAN(LINE,CMDTBL,CMDBRK)
	  END;
	  WHILE	CMDBRK="/" DO SWTGET;
	  IF CMDBRK="("	THEN BEGIN
	     DO	SWTGET UNTIL CMDBRK=")";
	     CMDBRK_LOP(LINE)
	  END;
       END "FILENAME";

       LABEL NXTIME;
       SWTP_0; SWTSTR_NULL;
       IF NX!TFIL THEN GO TO NXTIME;
       SETBREAK(CMDTBL,"_:,(!/["&'12,'15&" "&'11,"I");
       SETBREAK(LINTBL,'12,'15,"INA"); SETBREAK(RBRK,"]",NULL,"IA");
       RELEASE(BIN); RELEASE(LST);

    COMMENT FIRST GET COMMAND DEVICE;

       IF  not RPGSW THEN OUTSTR(CRLF&"*");
       TSA_ IF RPGSW THEN "DSK"	ELSE "TTY";

       IF  not ON!ETIME THEN BEGIN
	  EOF_0;
	  COMMENT TRY TMPCOR FIRST BEFORE FILE, USE LENGTH OF CMNDSTR
		AS FLAG THAT COMMAND IS IN CMNDSTR RATHER THAN FILE;
	  CMNDSTR_NULL;
    IFCR NOT TENXSW THENC
	  IF RPGSW THEN TMPCORSTR(2,PROCESSOR,CMNDSTR);
    ENDC
	  IF NOT(LENGTH(CMNDSTR)) THEN BEGIN
	    OPEN(CMND_GETCHAN,TSA,0,1,1,100,CMDBRK,EOF_-1);
	    IF EOF THEN USERERR(0,0,"COMMAND DEVICE NOT AVAILABLE");
	    TSB_("000"&CVS(CALL(0,"PJOB")))[INF-2 FOR 3]&PROCESSOR&".TMP";
	    LOOKUP(CMND,TSB,FG);
	    IF FG	THEN USERERR(0,0,"COMMAND FILE NOT FOUND");
	  END;

	  IF RPGSW AND NOT LENGTH(CMNDSTR) THEN	BEGIN "DELETE COMMAND FILE"
	     OPEN(DELCHNL_GETCHAN,"DSK",0,2,0,100,TIA,TIA);
	     LOOKUP(DELCHNL,TSB,FG);
	     RENAME(DELCHNL,NULL,0,FG);
	     RELEASE(DELCHNL)
	  END "DELETE COMMAND FILE";

	  CMNDFIL_TSA&":"&(IF RPGSW THEN TSB ELSE NULL);
	  ON!ETIME_TRUE;
       END;
       LINE_NULL;
       WHILE  not EOF and (LENGTH(LINE) leq 1  or  LENGTH(LINE)<5 and 
	EQU (LINE,BLANKS[1 FOR LENGTH(LINE)-1]&'12)) DO
	 BEGIN COMMENT HANDLE TMPCOR VS. FILE;
	  IF LENGTH(CMNDSTR) THEN BEGIN
	    LINE_SCAN(CMNDSTR,LINTBL,CMDBRK);
	    EOF_NOT(LENGTH(CMNDSTR)) END
	  ELSE
	  LINE_INPUT(CMND,LINTBL); COMMENT GET RID OF BLANK LINES;
	 END;
       IF EOF THEN TIA_CALL(0,"EXIT");

       FILENAME(TSA,TSB);

       IF CMDBRK = "!" THEN BEGIN "NEW!PROGRAM"
	  INTEGER ARRAY	SWPTBL[1:5];
	  SWPTBL[1]_CVSIX(TSA);
	  SWPTBL[2]_CVFIL(TSB,SWPTBL[3],SWPTBL[5]);
	  IF  not SPCFIL THEN SWPTBL[5]_CVSIX("  1  3");
	  IF RPGSW THEN	SWPTBL[4]_1;
	  START!CODE
	     MOVE '14,SWPTBL; MOVEM '14,TIA;
	  END;
	  CALL(TIA,IFC TENXSW OR DECSW THENC "RUN" ELSEC "SWAP" ENDC);
       END "NEW!PROGRAM"

       ELSE IF CMDBRK =	"_" OR CMDBRK =	"," THEN
	IF SPCFIL  or  LENGTH(TSB)	THEN BEGIN "BINARY"
	   TIA_CVFIL(TSB,TIB,TIC);
	   IF TIB=0 THEN TSB_CV6STR(TIA)&"."&RELEXT;
	   TID_-1;
	   IF WANTBIN THEN BEGIN "OPNBIN"
	      OPEN(BIN_GETCHAN,TSA,RELMODE,0,2,0,TIC,TID);
	      IF TID THEN USERERR(0,0,RELEXT&" DEVICE NOT AVAILABLE");
	      ENTER(BIN,TSB,FG);
	      IF FG THEN USERERR(0,0,"CANT ENTER "&RELEXT&" FILE");
	   END "OPNBIN";
	   BINFIL_TSA&":"&TSB;
	END "BINARY" ELSE WANTBIN_0  ELSE USERERR(0,0,PROCESSOR&
	 " COMMAND ERROR");

       IF CMDBRK = "," THEN BEGIN "LISTING"
	  FILENAME(TSA,TSB);
	  TIA_CVFIL(TSB,TIB,TIC);
	  IF TIB = 0 THEN TSB_CV6STR(TIA)&"."&LSTEXT;

	  IF WANTLST THEN BEGIN
	     OPEN(LST_GETCHAN,TSA,LSTMODE,0,2,0,TIC,TIC);
	     ENTER(LST,TSB,FG);
	     IF	FG THEN	USERERR(0,0,"CAN'T ENTER "&LSTEXT&" FILE");
	  END;
	  LSTFIL_TSA&":"&TSB;
	  IF CMDBRK  neq  "_" THEN USERERR(0,0,PROCESSOR & " COMMAND ERROR");
       END "LISTING" ELSE WANTLST_0;
       FILENAME(TSA,TSB);
       OPEN(SRC_GETCHAN,TSA,SRCMODE,2,0,SOURCECOUNT_200,SRCBRK,SRCEOF);

       WHILE TRUE DO BEGIN "SOURCE FILE LOOP"
	  IF CMDBRK neq '12	AND CMDBRK neq "," THEN USERERR(0,0,PROCESSOR&
	   " COMMAND ERROR");
	  CLOSE(SRC);
	  TID_CVFIL(TSB,TIC,TIE);
	  TSC_CVXSTR(TID)&"."&SRCEXT&
	   (IF TIE THEN "["&(TSC_CVXSTR(TIE))[1 FOR 3]&","&TSC[4 FOR 3]&"]"
	    ELSE NULL);
	  FG_-1;
	  IF TIC=0 THEN	LOOKUP(SRC,TSC,FG);
	  IF FG	THEN LOOKUP(SRC,TSB,FG);
	  IF FG	THEN USERERR(0,0,TSB &" FILE NOT FOUND");
	  SRCFIL_TSA&":"&TSB;
	  IF RPGSW THEN
	   OUTSTR(PROCESSOR&":	"&(IF EQU(TSA,"DSK") THEN NULL ELSE TSA)&TSB&
	    '15&'12);
	  NX!TFIL_TRUE;	  RETURN;

	  NXTIME:

	   IF CMDBRK='12  THEN USERERR(0,0,"END OF FILE ON SOURCE FILE");
	  FILENAME(TSA,TSB);
       END "SOURCE FILE LOOP";
    END	"COMMAND SCAN";

    COMMENT Swinehart's scanner package (an old version);


DSCR SCNSER.SAI -- a package to provide SCANNER operations
DES This insert provides a token-scanning service more 
   extensive than the SAIL SCAN function can handle. It
   can handle delimiters, identifiers, and string constants,
   as well as filler characters, and characters which are
   to be ignored completely.  There is provision for extension
   to handle numbers.
CAL Call ATOMINIT("DEL", "TS", "TC", "IGN", "IGN", SS, NUMF)
  to parameterize the scanner.  All characters in DEL will be
  considered delimiters.  The characters in TS are valid characters
  for the start of an identifier.  Those in TC are valid identifier
  characters after the first.  The characters in IGN are fillers --
  they are returned separately, and never appear in a token, but
  will break an identifier scan.  Those in IGN will be ignored on
  input.  SS is the string constant quote character -- otherwise,
  string constants are scanned like SAIL scans them.  NUMF is true
  if numbers are to be handled (not implemented).
 Call I_ATOM(@"TOSS",@"TOKEN") to scan from the input file
  (ignoring line numbers).  See Results below for exact returns.
RES The result of ATOM is a code -- the character code in ASCII
  for a delimiter -- otherwise an integer >127 -- TOKENCODE for
  identifiers (numbers currently returned in string form as IDs),
  STRCONCODE for string constants, ILLEGALCODE for illegal characters,
  EOFCODE when EOF is seen.  TOSSED contains all those fill
   (IGN) characters passed over before reaching the token.  TOKEN
   contains the character(s) of the token itself.  TOKLEN (a local
   variable, see below) contains the length of the token (for string
   constants, the length of the string from the last LF to the end).
PAR The following will be local to the REQUIRing block:
  SETBIT, SELSTR procedures, SCANTABLE(SCT) array,
   TEMP, TEMP1, STEMP, STEMP1 variables, LETTER, LETDIG ... defs.
 The following are also local, and possibly useful:
  DOLAND, DOLOR, UPPERCASE routines (uses obvious on inspection),
  RESCAN variable, if set, causes same token to be returned again
  TOKLEN (see above), OVERDEL, NOTATOM, ... break tables (14-10),
  TOKENCODE, STRCONCODE ... (see above) return codes.
 The following should be set to affect the ATOM routine:
  RESCAN -- set to rescan -- TOKEN and TOSSED will NOT be 
   set during a rescan -- only the return code is saved!!!!!
SID SCNCMD.SAI is required
  Other side effects should be limited to changes to the variables
  described above.
;

own integer OVERDEL, NOTATOM, STRSTOP, STRTEST, CHKLEN;
	simple procedure moreBreaks;
	begin OVERDEL_getbreak; NOTATOM_getbreak; 
		STRSTOP_getbreak;STRTEST_getbreak;CHKLEN_getbreak; end;
	require moreBreaks initialization;

    DEFINE LETTER="1", LETDIG="2", DIGIT="4", PARTOFNUMBER="8",
     STRINGSTART="16", DELIM="32", IGNORE="64",
     IGNORE="128", ILLEGAL="256",LOWERCASE="512";
    DEFINE TOKENCODE="128", STRCONCODE="129", ILLEGALCODE="130",
     EOFCODE="131";



 COMMENT These values go into the scan table, which controls all,
    iff default is indicated by the user
    ;
#

PRELOAD!WITH
 	ILLEGAL,		Comment 0;
 [8]	DELIM,			Comment     and   not    ;
	IGNORE,		Comment TAB;
	DELIM,			Comment LF;
	IGNORE,			Comment VT;
	DELIM,			Comment FF;
	IGNORE,			Comment CR;
 [10]	DELIM,			Comment  inf           swap  ;
	LETDIG LOR LETTER,	Comment UNDERLINE;
 [7]	DELIM,			Comment    neq   leq   geq    or  ;
	IGNORE,		Comment SPACE;
	LETDIG LOR LETTER,	Comment ! -- SAME AS ;
	STRINGSTART,		Comment " ;
 [13]	DELIM,			Comment # # $ % & ' ( ) * + - . /;
 [10]	DIGIT LOR
       LETDIG LOR PARTOFNUMBER,	Comment 0-9;
 [7]	DELIM,			Comment : SEMIC < = > ? @ ;
 [26]	LETDIG LOR LETTER,	Comment A-Z;
 [6]	DELIM,			Comment [ \ ] ^ _ ` ;
 [26]	LETDIG LOR LETTER
	       LOR LOWERCASE,	Comment a-z;
 [2]	DELIM,			Comment { | ;
	ILLEGAL,		Comment ALTMODE;
	DELIM,			Comment ~ ;
	ILLEGAL;		Comment DELETE;

#
    SAFE INTEGER ARRAY SCANTABLE[0:127];
    DEFINE SCT="SCANTABLE";

    INTEGER TEMP,TEMP1,RESCAN,TOKLEN;
    STRING STEMP,STEMP1;

    PROCEDURE DOLAND(REFERENCE INTEGER I; INTEGER MASK);
    I_I	LAND MASK;

    PROCEDURE DOLOR(REFERENCE INTEGER I; INTEGER MASK);
    I_I	LOR MASK;

    PROCEDURE CLEAR(INTEGER MASK);
    BEGIN "CLEAR"
       TEMP1_-1	XOR MASK;
       FOR TEMP_0 STEP 1 UNTIL 127 DO
	DOLAND(SCT[TEMP],TEMP1);
    END	"CLEAR";

    PROCEDURE SETBIT(STRING S;INTEGER MASK);
    IF S neq '177 THEN BEGIN "SETBIT"
       CLEAR(MASK);
       WHILE TEMP_LOP(S) DO DOLOR(SCT[TEMP],MASK)
    END	"SETBIT";

    STRING PROCEDURE SELSTR(INTEGER MASK);
    BEGIN "SELSTR"
       STEMP_NULL;
       FOR TEMP_0 STEP 1 UNTIL 127 DO
	IF SCT[TEMP] LAND MASK THEN STEMP_STEMP&TEMP;
       RETURN(STEMP)
    END	"SELSTR";

    STRING PROCEDURE UPPERCASE(STRING S);
    BEGIN "UPPERCASE"
       STEMP_NULL;
       WHILE LENGTH(S) DO STEMP_STEMP&
	(IF LOWERCASE LAND (TEMP1_SCT[TEMP_LOP(S)]) THEN
	 (TEMP1	LSH -18) ELSE TEMP);
       RETURN(STEMP)
    END	"UPPERCASE";

    PROCEDURE ATOMINIT(
     STRING  DELIMITER!STRING,
     TOKEN!START,
     TOKEN!CONTINUE,
     IGNORE!STRING,
     IGNORE!STRING;
    INTEGER STRING!START,
     NUMBER!FLAG		);

    BEGIN "ATOMINIT"
       FOR TEMP_"a" STEP 1 UNTIL "z" DO
	DOLOR(SCT[TEMP],(TEMP-"a"+"A") LSH 18);

       SETBIT(DELIMITER!STRING,DELIM);
       SETBIT(TOKEN!START,LETTER);
       SETBIT(TOKEN!CONTINUE,LETDIG);
       IF STRING!START neq '177 THEN BEGIN
	  CLEAR(STRINGSTART);
	  DOLOR(SCT[STRING!START],STRINGSTART)
       END ELSE	STRING!START_"""";
       SETBIT(IGNORE!STRING,IGNORE);
       SETBIT(IGNORE!STRING,IGNORE);

       STEMP1_SELSTR(IGNORE); "ALWAYS IGNORED COMPLETELY"

       SETBREAK(OVERDEL,SELSTR(IGNORE)&STEMP1,STEMP1,"XNR");
       SETBREAK(NOTATOM,SELSTR(LETDIG)&STEMP1,STEMP1,"XNR");
       SETBREAK(STRSTOP,STRING!START,NULL,"INA");
       SETBREAK(STRTEST,NULL,NULL,"XNR");
       SETBREAK(CHKLEN,'12,'15,"I");
       RESCAN_FALSE;
    END	"ATOMINIT";

    SIMPLE STRING PROCEDURE NO!BANG(STRING S);
    BEGIN INTEGER C; STRING T;
    T _ NULL;
    WHILE (C _ LOP(S)) DO T _ T & (IF C="!" THEN "" ELSE C);
    RET);
    END;

IFCR WANTBANGSW THENC
    SIMPLE STRING PROCEDURE YES!BANG(STRING Y);
    BEGIN "YES!BANG"
          STRING Q; INTEGER TEMP;
          Q _ NULL;
          WHILE LENGTH(Y) DO
             IF (TEMP _ LOP(Y)) = ("X"-'100) THEN
                Q _ Q & "!"
             ELSE
                Q _ Q & TEMP;
          RETURN(Q);
    END "YES!BANG";
ELSEC
    DEFINE YES!BANG(S) = "S";
ENDC


    INTEGER PROCEDURE ATOM(REFERENCE STRING TOSSED,TOKEN);
    BEGIN "ATOM"
       INTEGER RET;
       IF RESCAN THEN BEGIN
	  RESCAN_FALSE;
	  RETURN(RET)
       END;
       SOURCECOUNT_200;	TOKLEN_1;
       TOSSED_INPUT(SRC,OVERDEL);		"BLANKS AND SUCH"
       IF SRCEOF THEN RETURN(RET_EOFCODE);
       TEMP_SCT[SRCBRK];			"SCANNER TABLE BITS"
       IF TEMP LAND LETTER THEN	BEGIN "TOKEN"
	  TOKEN_NO!BANG(INPUT(SRC,NOTATOM));	"GET IDENTIFIER"
	  TOKLEN_LENGTH(TOKEN);
	  RETURN(RET_TOKENCODE)
       END "TOKEN";

       IF TEMP LAND STRINGSTART	THEN BEGIN "STRCON"
	  TOKEN_NULL;
	  DO BEGIN "GET STRING"
	     SOURCECOUNT_1;
	     TOKEN_TOKEN&INPUT(SRC,0);	"PICK UP STRINGSTART"
	     SOURCECOUNT_200;
	     DO	TOKEN_TOKEN&
	      INPUT(SRC,STRSTOP) UNTIL SRCBRK; "GO UNTIL STRINGSTART"
	     INPUT(SRC,STRTEST);		"CHECK FOR 2 STRINGSTARTS";
	  END "GET STRING" UNTIL  not (SCT[SRCBRK] LAND STRINGSTART);
	  STEMP1_TOKEN;	"COMPUTE TOKLEN"
	  DO STEMP_SCAN(STEMP1,CHKLEN,TEMP) UNTIL TEMP neq '12;
	  TOKLEN_LENGTH(STEMP);	IF TOKLEN neq LENGTH(TOKEN)	THEN TOKLEN_-TOKLEN;
	  RETURN(RET_STRCONCODE)
       END "STRCON";

       "MUST NOW BE EITHER DELIMITER OR ILLEGAL"

       SOURCECOUNT_1; TEMP1_SRCBRK;
       TOKEN_INPUT(SRC,0);			"GET THE CHARACTER"
       "HACK HERE TO ALLOW := FOR _"
       IF TOKEN = ":" THEN
          BEGIN
             STRING TOSS2;
             TOSS2 _ INPUT(SRC,OVERDEL);
             IF SRCBRK = "=" THEN
                BEGIN
                   TOKEN _ "_";
                   TOSS2 _ INPUT(SRC,0);
                   RETURN(RET_"_");
                END;
          END;
       IF TEMP LAND ILLEGAL THEN RETURN(RET_ILLEGALCODE)
	ELSE RETURN(RET_TEMP1)

    END	"ATOM";
DSCR END OF SCNSER
;

COMMENT RESERVED WORD SYMBOL TABLE

THE ARRAY STAB CONTAINS THE NAMES OF ALL THE IMPORTANT RESERVED WORDS
(THOSE NEEDED TO DISTINGUISH DECLARATIONS AND OTHER NON-EXECUTABLE 
STATEMENTS FROM EXECUTABLE STATEMENTS, THUS "PUT" IS NOT IN THE TABLE
BECAUSE IT MERELY INDICATES AN EXECUTABLE STATEMENT, MUCH AS ANY
OTHER IDENTIFIER NOT FOLLOWED BY A COLON).

THE ARRAY LETS CONTAINS THE NAMES OF ALL USER DEFINED RESERVED WORDS
(BY MEANS OF "LET" DECLARATIONS).

THE PROCEDURE LOOKR LOOKS UP A SYMBOL AS FOLLOWS:

	1. IF ANY "LET" DECLARATIONS HAVE BEEN SEEN (THE NUMBER SEEN
	   IS KEPT IN THE INTEGER NLETS) THEN LOOKR
	   DOES A LINEAR SEARCH THROUGH THE LETS ARRAY FOR THE
	   SYMBOL. IF THE SYMBOL IS FOUND, THE "VALUE" OF THE SYMBOL RETURNED
	   IS THE CORRESPONDING ELEMENT OF THE ARRAY LETVAL. THUS, IF
	   LETS[3] WAS THE SYMBOL, LETVAL[3] WOULD BE RETURNED.

	2. OTHERWISE WE USE THE ASCII CODE FOR THE FIRST LETTER OF THE
	   SYMBOL AS AN INDEX INTO THE ARRAY XFERTAB. AN XFERTAB ENTRY
	   CONTAINS TWO INTEGERS PACKED IN A SINGLE WORD. THEY
	   ARE THE INDEX OF THE FIRST ELEMENT OF THE ARRAY STAB WHICH STARTS
	   WITH THE CORRESPONDING LETTER, AND THE INDEX OF THE LAST ELEMENT
	   OF THE ARRAY STAB WHICH STARTS WITH THE SAME LETTER.
	   IF THERE IS NO ENTRY IN STAB STARTING WITH  A GIVEN LETTER
	   THEN THE ENTRIES IN XFERTAB FOR THAT LETTER ARE BOTH 0.
	   IF THERE IS ONLY ONE ENTRY IN STAB STARTING WITH A GIVEN LETTER
	   THEN (FOR SOME UNEXPLAINED REASON) THE ENDING INDEX IS ZERO
	   INSTEAD OF BEING THE SAME AS THE STARTING INDEX. IF THE
	   STARTING INDEX IS NON-ZERO LOOKR DOES A LINEAR SEARCH FROM
	   THAT POSITION IN STAB TO THE ENDING POSITION IN STAB. IF
	   THE SYMBOL IS FOUND THE CORRESPONDING ENTRY IN SVAL IS RETURNED.
	   THUS, IF THE DESIRED SYMBOL IS STAB[5], THEN SVAL[5] WILL
	   BE RETURNED.

	3. IF THE SYMBOL IS NOT FOUND THEN IT IS NOT A CRUCIAL RESERVED
	   WORD AND THE VALUE 0 IS RETURNED.
;

COMMENT PRELOADED ARRAYS FOR SYMBOL TABLE-- LOOKR;

PRELOAD!WITH
"ASSIGNC",	"ARRAY",	"BEGIN",	"BOOLEAN",	"CASE",
"CLEANUP",	"CONTEXT",	"CONTINUE",	"DEFINE",	"DO",
"DONE",		"END",		"ELSE",		"EXTERNAL",	"FOR",
"FOREACH",	"FORTRAN",	"FORWARD",	"GLOBAL",	"GO",
"GOTO",		"IF",		"INTEGER",	"INTERNAL",	"ITEM",
"ITEMVAR",	"LABEL",	"LET",		"LIST",		"LONG",
"MATCHING",	"MESSAGE",	"NEEDNEXT",	"OF",		"OWN",
"PRELOADWITH",	"PRESETWITH",	"PROCEDURE",	"QUICKCODE",	"REAL",
"RECURSIVE",	"REQUIRE",	"RETURN",	"RECORDCLASS",	"RECORDPOINTER",
"SAFE",		"SET",		"SHORT",	"SIMPLE",	"STARTCODE",
"STRING",	"UNTIL",	"WHILE";
STRING ARRAY STAB[1:53];

PRELOAD!WITH [65]0,
'0102,	'0304,	'0510,	'1113,	'1416,	'1722,	'2325,	0,	'2632,	0,
0,	'3336,	'3740,	'4100,	'4243,	'4446,	'4700,	'5055,	'5663,	0,
'6400,	0,	'6500;
SAFE INTEGER ARRAY XFERTAB[0:127];

COMMENT RESERVED WORDS ARE CLASSIFIED AS FOLLOWS:
	1-	"FORWARD" AND "FORTRAN"
	2-	"EXTERNAL"
	3-	NECESSARILY DETERMINES A NON-EXECUTABLE STATEMENT
	4-	A TYPE, THIS MIGHT BE A PROCEDURE DECL.
	5-	"PROCEDURE"
	6-	"NEEDNEXT"
	7-	"BEGIN"
	8-	"CASE"
	9-	"DO"
	10-	"DONE","RETURN","CONTINUE"
	11-	"FOR","FOREACH"
	12-	"WHILE"
	13-	"GO","GOTO"
	14-	"IF"
	15-	"QUICKCODE","STARTCODE"
	16-	"END"
	17-	"ELSE"
	18-	"UNTIL"
	19-	"OF"
	20-	"LET"
	21-	"RECORDCLASS"
	22-	"RECORDPOINTER"
;
PRELOAD!WITH
  3,  3,  7,  4,  8,  3,  4, 10,  3,  9,
 10, 16, 17,  2, 11, 11,  1,  1,  4, 13,
 13, 14,  4,  4,  4,  4,  3, 20,  4,  4,
  4,  4,  6, 19,  3,  3,  3,  5, 15,  4,
  4,  3, 10, 21, 22,  3,  4,  4,  4, 15,
  4, 18, 12;
INTEGER ARRAY SVAL[1:53];

define let#max=20;	INTEGER NLETS;
INTEGER ARRAY LETVAL[1:let#max]; 
STRING ARRAY LETSTR[1:let#max];

define rpc#max=40;	INTEGER NRPC;
STRING ARRAY RPSTR[1:rpc#max];

INTEGER PROCEDURE LOOKR;
	BEGIN INTEGER I,I1,I2;
	IF NLETS >0 THEN
	    BEGIN FOR I_ NLETS min let#max STEP -1 UNTIL 1 DO 
		IF EQU(STR1,LETSTR[I]) THEN RETURN (LETVAL[I]);
	    END;
	I1_(I2_XFERTAB[STR1]) LSH (-6);
	IF I1=0 THEN RETURN(0);
	I2_I2 LAND '77;
	IF I2=0 THEN RETURN(IF EQU(STR1,STAB[I1]) THEN SVAL[I1] ELSE 0);
	FOR I_I1 STEP 1 UNTIL I2 DO
		IF EQU(STR1,STAB[I]) THEN RETURN(SVAL[I]);
	RETURN(0);
	END "LOOKR";

COMMENT FINITE STATE PARSER


IN THE FOLLOWING TRANSITION TABLE, THE POSITIVE ENTRIES INDICATE
	STATE TRANSITIONS AND THE NEGATIVE ONES INDICATE EXITS AS FOLLOWS:
	(-2)	EXECUTABLE STATEMENT
	(-3)	NON-EXECUTABLE STATEMENT
	(-4)	FORWARD OR EXTERNAL PROCEDURE DECL.
	(-5)	ACTUAL PROCEDURE DECL.
	(-6)	ERROR
;
PRELOAD!WITH
-2,-4,2,-3,3,-5,4,[6] -6,		COMMENT ROW 1 BEGINNING OF STATEMENT;
-3,-4,-6,-3,2,-4,-6,[6] -6,		COMMENT ROW 2 SEEN "EXTERNAL" LOOKING FOR "PROCEDURE";
-3,-4,2,-3,3,-5,-6,[6] -6,		COMMENT ROW 3 SEEN TYPE LOOKING FOR "PROCEDURE";
[11] -6,-11,-12;

INTEGER ARRAY XITION[1:4,0:12];


COMMENT MAIN PROGRAM, EXECUTION STARTS HERE;

SCANTABLE['177]_DELIM;
ATOMINIT(",+-|()[]/^_&<>=*%;:{~"&'14&'177,
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!$0123456789@.'",
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!$0123456789@.'",
	'11&'12&'40,
	'177,
	"""",
	0);
COMMENT THE FOLLOWING IS NECESSARY SINCE SAIL DOES NOT ALWAYS CLEAR
THE LOW ORDER BIT IN THE LIST FILE;

FOR I_1 STEP 1 UNTIL 18 DO BREAKSET(I,NULL,"P");
SETBREAK(FINDFF,'14&'12,'15,"IPS");
SETBREAK(FINDSEMI,";",NULL,"IPA"); 
SETBREAK(FINDLF,'12,'15,"IPS");
SETBREAK(FINDTAB,'11,NULL,"IPS");

ON!ETIME_0;

HEAD1_"     PROGRAM PROFILE 				";
NT_0;
SETFORMAT(8,0);
BLANX_"                                                                         "&
  "                                                     ";
TABS_"									"&
  "								";
WHILE TRUE DO
	BEGIN "SUPERLOOP"
	NX!TFIL_0;
	WANTBIN_TRUE;
	WANTLST_FALSE;
	SOURCECOUNT_100;

COMMENT  FIRST OPEN COUNTER FILE AND LISTING FILE;

	COMMAND!SCAN;

COMMENT THE FOLLOWING SWITCHES ARE IMPLEMENTED:
	
	/nB	INDENT n SPACES FOR BLOCKS (default 4)
	/nC	INDENT n SPACES FOR CONTINUATIONS (default 2)
	/F	FILL OUT EVERY 4th LINE WITH .   .   .
	/I	IGNORE COMMENTS OTHER THAN STRING CONSTANTS
	/nK	MAKE COUNTER ARRAY OF SIZE n (default 200)
	/nL	MAXIMUM LINE LENGTH OF n (default 120)
	/N	DON'T FILL OUT EVERY 4th LINE WITH .   .   .
	/S	STOP (EXIT PROGRAM) AFTER THIS PROFILE
	/T	TELETYPE MODE = /1C/2B/80L/F
;

	MXKTR_200;
	CONIND_2;BLKIND_4;
	IGNCMT_STPFLG_0;
	FFLAG_1;
	MAXCOL_ 120;
	for I_1 step 1 WHILE LENGTH(SWTSTR) DO
		CASE TEMP_LOP(SWTSTR) OF
			BEGIN 
			[1]BLKIND_SWTVAL[I];
			[2]CONIND_SWTVAL[I];
			[3]FFLAG_1;
			[4]IGNCMT_1;
			[5]MXKTR_SWTVAL[I];
			[6]MAXCOL_SWTVAL[I];
			[7]FFLAG_0;
			[8]STPFLG_1;
			[9]BEGIN
			    CONIND_1; BLKIND_2; MAXCOL_80; FFLAG_1;
			   END;
			[else]USERERR(0,0,"ILLEGAL SWITCH")
			END;

	CONFIL_BLANX[1 FOR CONIND];
	CTRCOL_ (MAXCOL LAND '777777777770) -8;
	LASCOL_ CTRCOL-9;

BEGIN "KNTLOOP"

INTEGER ARRAY KOUNTR[1:MXKTR];


COMMENT PROCEDURES SCAN1, SCAN2, TERP1, AND TERPRI;


RECURSIVE PROCEDURE SCAN2;
	BEGIN 
	SPAC2_0;
	TYP2_ATOM(IGN,STR2A);
	WHILE TYP2='177 DO
		BEGIN TYP2_ATOM(IGN,STR2A);
		IF TYP2=2 THEN TYP2_ATOM(IGN,STR2A)
		ELSE IF TYP2=3 THEN TYP2_EMRK
		ELSE locError(0,"ILLEGAL CHAR <'" & CVOS(TYP2)
				& "> AFTER '177");
		END;
	IF TYP2=EOFCODE THEN
		BEGIN TYP2_TOKENCODE; STR2_"END";
		STR2A_"END (supplied by scanner)";SPAC2_1;
		RETURN;
		END;
	IF TYP2=TOKENCODE THEN
		BEGIN SPAC2_1;
		STR2_UPPERCASE(STR2A);
		IF EQU(STR2,"COMMENT") THEN
			BEGIN 
			DO 
				STR2A_STR2A&INPUT(SRC,FINDSEMI)
			UNTIL SRCBRK;
			TYP2_CMNTCODE;
			END;
		END
	ELSE BEGIN IF TYP2=STRCONCODE THEN SPAC2_1; STR2_STR2A; END;
	IF TYP2='14 THEN
		BEGIN
		SOURCECOUNT_200; TS1_INPUT(SRC,FINDLF);
		TS2_NULL;
		WHILE (TS1[ inf  FOR 1] neq "-") and (LENGTH(TS1)>0) DO
			BEGIN TS2_TS1[ inf  FOR 1]& TS2;
			TS1_TS1[1 TO  inf -1];
			END;
		TI1_ INTSCAN(TS2,TI2);
 		TS1_INPUT(SRC,FINDLF); "READ THE SECOND HEADING LINE"
		IF (TI1=1) and  not FIRSTSCAN THEN
			BEGIN STR2A_ '15&'14;
			TYP2_CMNTCODE;
			END
		ELSE SCAN2;
		END;
	END "SCAN2";

PROCEDURE SCAN1;
  BEGIN SPAC1_SPAC2; STR1_STR2; STR1A_STR2A; TYP1_TYP2; SCAN2; END;

PROCEDURE TERP1;
	BEGIN INTEGER L2;
	STRING FILL;
	IF NLEN=0 THEN SPACO_0
	 ELSE IF SPACN
		 THEN BEGIN TIA_LOP(NLINE); NLEN_NLEN-1; SPACN_0 END;
	IF LENGTH(OLINE)=0 THEN RETURN;
	if true
	 then out(ofile,yes!bang(bfill&oline&crlf))
	 else begin
	OUT(OFILE,YES!BANG(BFILL&OLINE&TAB));
	IF OTYPE THEN
		BEGIN 
		FILL_ IF (FFLAG neq 0) and ((NLINES LAND 3)=0)
			 THEN "   .   ." ELSE TAB;
		for l2_ (OLEN lor 7) + 1 -1 step 8 until CTRCOL 
			DO OUT(OFILE,FILL);
		IF CURCOUNT<0 THEN LocError(1,"DRYROT: negative count");
		OUT(OFILE,CVS(CURCOUNT)&CRLF);
		OTYPE_0;
		END
	ELSE OUT(OFILE,CRLF);
	 end;
	OLINE_NULL;
	NLINES_NLINES+1;
	END "TERP1";

PROCEDURE TERPRI;
	BEGIN
	TERP1;
	TI3_NT % 8;
	BFILL_TABS[1 FOR TI3]&BLANX[1 FOR NT-8*TI3];
	OLEN_NT;
	END "TERPRI";
COMMENT PROCEDURES INDENT,UNDENT,SPRINT, PRINT1, & COUNTSTR;

PROCEDURE INDENT(INTEGER NCOLS);
	BEGIN
	NT_ NT+NCOLS;
	IF NT geq LASCOL-1 THEN 
	    BEGIN SETFORMAT(0,0);
	    USERERR(0,0,"NESTING TOO DEEP FOR PRINTING. CHANGE INDENTION COUNTS
FOR BLOCKS AND CONTINUATIONS FROM /"&CVS(BLKIND)&"B/"&CVS(CONIND)&"C");
	    END;
	TERPRI;
	END;

PROCEDURE UNDENT(INTEGER NCOLS);
	BEGIN
	NT_ NT-NCOLS;
	TERPRI;
	END;

PROCEDURE SPRINT;
	IF NLEN THEN BEGIN
		OLINE_OLINE&NLINE;
		OLEN_OLEN+NLEN;
		OTYPE_ OTYPE LOR NTYPE;
		NLINE_NULL;
		SPACN_0;
		NLEN_0;
	END;

PROCEDURE PRINT1;
	BEGIN INTEGER L1;
	IF SPAC1  and  SPACO THEN 
		BEGIN STR1A_" "&STR1A; SPACT_1; 
		IF NLEN=0 THEN SPACN_1;
		END ELSE SPACT_0;
	L1_LENGTH(STR1A);
	IF OLEN+NLEN+L1<LASCOL THEN
		BEGIN NLINE_NLINE&STR1A;
		NLEN_NLEN+L1;
		END
	ELSE	BEGIN TERPRI; 
		IF SPACN  and  (NLEN=0) THEN
			BEGIN SPACN_SPACT_0; TIA_LOP(STR1A); L1_L1-1 END;
		IF OLEN+NLEN+L1<LASCOL THEN
			BEGIN NLEN_NLEN+L1;
			NLINE_NLINE&STR1A;
			END
		ELSE	BEGIN OLINE_NLINE;
			OTYPE_NTYPE;
			OLEN_OLEN+NLEN;
			TERPRI; IF SPACT THEN BEGIN TIA_LOP(STR1A); L1_L1-1 END;
			WHILE L1+NT+CONIND > LASCOL DO
				BEGIN OLINE_CONFIL& STR1A[1 FOR LASCOL-NT-CONIND];
				OTYPE_NTYPE;
				OLEN_ LASCOL;
				TERPRI;
				STR1A_STR1A[LASCOL-NT-CONIND+ 1 TO  inf ];
				L1_LENGTH(STR1A);
				END;
			NLINE_CONFIL&STR1A;
			NLEN_L1+CONIND;
			END;
		END;
	SPACO_SPAC1;
	END "PRINT1";
DEFINE PASSCOMMENT= "WHILE (TYP1=STRCONCODE) or (TYP1=CMNTCODE) DO
	BEGIN NTYPE_0; IF TYP1=STRCONCODE THEN PRINTS ELSE
	 PRINTC; SPRINT;SCAN1; END",
	CHECKSEMI= "IF TYP1="";"" THEN 
		BEGIN PRINT1;SPACO_1;SCAN1;SEMICOL_1;
		END ELSE SEMICOL_0;  SPRINT";
DEFINE PASSTOKEN=
		"BEGIN IF TYP1=STRCONCODE THEN PRINTS ELSE 
		  IF TYP1=CMNTCODE THEN PRINTC ELSE
		  BEGIN  IF TYP1=EMRK THEN COUNTSTR; PRINT1 END;
		SCAN1;
		END";

PROCEDURE COUNTSTR;
	BEGIN
	INTEGER I,J;
	GETFORMAT(I,J);
	SETFORMAT(0,0);
	STR1A_"<<"&CVS(NEXTCOUNTER)&">>"; SPAC1_0;
	SETFORMAT(I,J);
	END;


COMMENT PROCEDURES WIDTH,PRINTS, PRINTC, AND FINISH;

INTEGER PROCEDURE WIDTH(STRING ST1; INTEGER STCOL);
	BEGIN COMMENT RETURN THE FINAL COLUMN IF STRING
	  ST1 IS PRINTED STARTING IN COLUMN STCOL;
	INTEGER L1,BRK; STRING ST2;
	L1_STCOL;
	WHILE LENGTH(ST1)>0 DO
		BEGIN 
		ST2_SCAN(ST1,FINDTAB,BRK);
		L1_L1+LENGTH(ST2);
		IF BRK=TAB THEN L1_8+(L1 LAND '777777777770);
		END;
	RETURN(L1);
	END;

PROCEDURE PRINTS;
	BEGIN
	INTEGER L1,BRK,T1,L2;
	STRING ST1;
	IF SPAC1  and  SPACO THEN 
		BEGIN STR1A_" "&STR1A; SPACT_1; IF NLEN=0 THEN SPACN_1 END
		ELSE SPACT_0; 
	ST1_SCAN(STR1A,FINDLF,BRK);
	L1_WIDTH(ST1,NLEN+OLEN);
	IF L1 leq LASCOL THEN
		BEGIN NLINE_NLINE&ST1;
		NLEN_L1-OLEN;
		END
	ELSE	BEGIN
		TERPRI; IF SPACN  and  (NLEN=0) THEN
			BEGIN TIA_LOP(ST1); SPACT_SPACN_0 END;
		L1_WIDTH(ST1,NLEN+OLEN);
		IF L1 leq LASCOL THEN
			BEGIN
			NLINE_NLINE&ST1; NLEN_L1-OLEN;
			END
		ELSE
			BEGIN OLINE_NLINE; OTYPE_NTYPE;
			NLINE_NULL;
			OLEN_OLEN+NLEN; TERPRI;
			IF SPACT THEN  BEGIN TIA_LOP(ST1); SPACT_0 END;
			L1_WIDTH(ST1,OLEN+CONIND);
			IF L1 leq LASCOL THEN
				BEGIN NLINE_CONFIL&ST1; NLEN_ L1-OLEN;
				END
			ELSE	BEGIN L2_WIDTH(ST1,0);
				IF L2 leq LASCOL THEN
				  BEGIN T1_LASCOL-L2;
				  WHILE (L2_WIDTH(ST1,T1))>LASCOL DO
				    T1_T1-1;
				  OLEN_L2;
				  BFILL_BLANX[1 FOR T1];
				  OLINE_ST1; TERPRI;
				  END
				ELSE
				  BEGIN COMMENT JESUS THAT'S A LONG STRING;
				  WHILE(T1_ LENGTH(ST1))>0 DO
				    BEGIN
				    WHILE (L1_WIDTH(ST1[1 FOR T1],OLEN+CONIND))>LASCOL-2 DO
				      T1_T1-1;
				    NLINE_CONFIL&ST1[1 FOR T1]; NLEN_ L1-OLEN;
				    ST1_ST1[T1+1 TO  inf ];
				    IF LENGTH(ST1)>0 THEN
				      BEGIN NLINE_NLINE&"""&"; NLEN_NLEN+2; SPRINT;
				      TERPRI; ST1_CONFIL&""""&ST1;
				      END;
				    END;
				  END;
				END;
			END;
		END;

COMMENT BY HOOK OR CROOK WE GOT THE FIRST LINE OF THE STRING OUT.
  NOW DO THE REST;

	WHILE LENGTH(STR1A)>0 DO
		BEGIN SPRINT; TERP1; ST1_SCAN(STR1A,FINDLF,BRK);
		BFILL_NULL; OLEN_0;
		L1_WIDTH(ST1,0);
		IF L1 leq LASCOL THEN
		      BEGIN NLINE_ST1;
		      NLEN_L1; L1_0;
		      END
		ELSE
		      WHILE(T1_ LENGTH(ST1))>0 DO
			BEGIN
			WHILE (L1_WIDTH(ST1[1 FOR T1],0))>LASCOL-2 DO
			  T1_T1-1;
			NLINE_ST1[1 FOR T1]; NLEN_ L1;
			ST1_ST1[T1+1 TO  inf ];
			IF LENGTH(ST1)>0 THEN
			  BEGIN NLINE_NLINE&"""&"; NLEN_NLEN+2; SPRINT;
			  TERPRI; ST1_CONFIL&""""&ST1;
			  END;
			END;
		END;
	SPACO_SPAC1;
	END "PRINTS";

PROCEDURE PRINTC;
	BEGIN 
	STRING ST1;
	INTEGER BRK;
	IF (LENGTH(STR1A)=2) and EQU(STR1A,'15&'14) THEN 
		BEGIN TERPRI; OUT(OFILE,YES!BANG(STR1A)); RETURN;
		END;
	IF IGNCMT THEN RETURN;
	TERPRI;
	ST1_SCAN(STR1A,FINDLF,BRK);
	NTYPE_0;
	OLINE_ST1;
  	WHILE LENGTH(STR1A)>0 DO
		BEGIN ST1_SCAN(STR1A,FINDFF,BRK);
		IF BRK='14 THEN
		  BEGIN
		  SOURCECOUNT_200; TS1_SCAN(STR1A,FINDLF,BRK);
		  TS2_NULL;
		  WHILE (TS1[ inf  FOR 1] neq "-") and (LENGTH(TS1)>0) DO
			  BEGIN TS2_TS1[ inf  FOR 1]& TS2;
			  TS1_TS1[1 TO  inf -1];
			  END;
		  TI1_ INTSCAN(TS2,TI2);
		  TS1_SCAN(STR1A,FINDLF,BRK);
		  IF (TI1=1) THEN
			  BEGIN TERP1; OUT(OFILE,'15&'14);
			  OLEN_0;
			  END
		  END
		ELSE
		  BEGIN
		  TERP1; OLEN_0; BFILL_NULL;
		  OLINE_ST1;
		  END;
		END;
	TERPRI;
	END "PRINTC";

PROCEDURE FINISH;
	BEGIN
	NTYPE_1;
	WHILE (TYP1 neq ";") and ((TYP1 neq TOKENCODE) or  ( not EQU(STR1,"UNTIL") and 
	   not EQU(STR1,"END") and ( not EQU(STR1,"ELSE") or (TYP2=EMRK)))) DO
		PASSTOKEN;
	CHECKSEMI;
	END;


RECURSIVE PROCEDURE SCAN!STMT(INTEGER DOINDENT);
COMMENT This is the main procedure.  It will scan a single statement
	and write it out to the list file.  If the statement ends
	with a semicolon, the variable semicol will be set to 1 else
	0;

BEGIN "SCAN!STMT"
INTEGER S1,S2; LABEL KP; INTEGER NQ;
WHILE (TYP1=STRCONCODE) or (TYP1=CMNTCODE) or 
  ((TYP1=TOKENCODE) and (TYP2=":")) DO
	BEGIN "SCNLBL" COMMENT FIRST HANDLE LABELS AND COMMENTS;
	IF (TYP1=STRCONCODE) THEN
	      BEGIN NTYPE_0;
	      PRINTS; SPRINT;
	      END
	ELSE  IF TYP1=CMNTCODE THEN 
	      BEGIN PRINTC; SPRINT END
	   ELSE
	      BEGIN FOR S1_NRPC min rpc#max STEP -1 UNTIL 1 DO
		 IF EQU(STR1,RPSTR[S1]) THEN DONE "SCNLBL";
	      TERPRI;
	      NTYPE_1; CURCOUNT_NEXTCOUNTER;
	      PRINT1; SCAN1;
	      PRINT1; SPRINT; TERPRI;
	      END;
	SCAN1;
	END;

COMMENT FIRST DETERMINE WHETHER THIS IS A NULL STATEMENT (SOME NULL
	STATEMENTS ARE CAUGHT BELOW BY THE "PARSER";

IF TYP1=";" THEN
	BEGIN PRINT1;SPACO_1;NTYPE_1;SCAN1;SPRINT;SEMICOL_1; RETURN;END;

COMMENT  DETERMINE THE STATEMENT TYPE BY A FINITE STATE "PARSER";

NQ_1;
KR:
J_LOOKR;
IF J leq 6 THEN
	BEGIN Q_NQ;
	WHILE Q>0 DO
		BEGIN PRINT1; SCAN1;
		IF J>12 THEN LocError(0,"ERROR IN STMT TYPING");
		Q_XITION[Q,J];
		J_LOOKR;
		END;
	J_ -Q;
	END;
CASE J OF
	BEGIN "BIGSW"
	COMMENT ROUTINES FOR SIMPLE EX AND NON-EX STMTS AND PROC. DECLS;

[else] USERERR(0,1,"DRYROT:CASE INDEX = " & cvs(j) & " IN SCAN!STMT");
	
[2]	FINISH; COMMENT  -- A GARDEN VARIETY EXECUTABLE STATEMENT;

[3]	BEGIN  "NONEX" COMMENT  garden variety non-executable statement;
	NTYPE_0;
	WHILE TYP1 neq ";" DO PASSTOKEN;
	PRINT1;SPACO_1;SCAN1;SEMICOL_1;SPRINT;
	END;

[4]	BEGIN "FPROC" COMMENT forward or external procedure declaration;
	TERPRI;
	NTYPE_ PLVL_0;
	WHILE (PLVL>0) or (TYP1 neq ";") DO
		BEGIN PRINT1;
		IF TYP1="(" THEN PLVL_PLVL+1
		ELSE IF TYP2=")" THEN PLVL_PLVL-1;
		SCAN1;
		END;
	PRINT1; SPACO_1;
	SPRINT; SEMICOL_1;
	SCAN1;
	END;

[5]	BEGIN  "PROC" COMMENT an actual real-life procedure declaration;
	TERPRI;
	NTYPE_ PLVL_0;
	WHILE (PLVL>0) or (TYP1 neq ";") DO
		BEGIN PRINT1;
		IF TYP1="(" THEN PLVL_PLVL+1
		ELSE IF TYP2=")" THEN PLVL_PLVL-1;
		SCAN1;
		END;
	PRINT1; SPACO_1;
	SCAN1;
	SPRINT;
	INDENT(CONIND);
	S1_CURCOUNT;
	CURCOUNT_NEXTCOUNTER;
	SCAN!STMT(1);
	UNDENT(CONIND);
	CURCOUNT_S1;
	END;

[6]	Locerror(0,"ERROR IN STMT TYPING");	COMMENT  -- ERROR;
COMMENT ROUTINES FOR BLOCK AND CASE STATEMENTS;

[7]	BEGIN "BLOCK" COMMENT  -- begin, a block or compound statement;
		INTEGER OLDNLETS,OLDNRPC;
	TERPRI;
	NTYPE_1;
	PRINT1; SPRINT; SCAN1;
	PASSCOMMENT;
	IF DOINDENT THEN INDENT(BLKIND);
	OLDNLETS_NLETS; OLDNRPC_NRPC;
	WHILE (TYP1 neq TOKENCODE) or  not EQU(STR1,"END") DO
		SCAN!STMT(1);
	NLETS_OLDNLETS; NRPC_OLDNRPC;
	IF DOINDENT THEN UNDENT(BLKIND) ELSE TERPRI;
	PRINT1; SPRINT; SCAN1;
	PASSCOMMENT;
	CHECKSEMI;
	TERPRI;
	END;

[8]	BEGIN  "CASE"	COMMENT  -- case statement;
	NTYPE_1;
	S1_0;
	TERPRI;
	WHILE (TYP1 neq TOKENCODE) or not EQU(STR1,"OF") or (TYP2=EMRK)
	 DO PASSTOKEN;
	PRINT1; SPRINT; INDENT(CONIND);
	SCAN1; NTYPE_0;
	PASSCOMMENT; 
	IF not EQU(STR1,"BEGIN") THEN LocError(0,"NO BEGIN AFTER CASE");
	PRINT1;SPRINT; SCAN1; INDENT(CONIND);
	DO
		BEGIN  "CASE1"
		TERPRI; SEMICOL_0;
		CURCOUNT_NEXTCOUNTER;
		PASSCOMMENT;
		WHILE TYP1="[" DO
			BEGIN 
			DO BEGIN PRINT1; SCAN1; END UNTIL TYP1="]";
			PRINT1; SCAN1
			END;
		SCAN!STMT(1);
		S1_S1+CURCOUNT;
		END
	UNTIL SEMICOL=0;
	PASSCOMMENT; 
	IF not EQU(STR1,"END") THEN LocError(0,"NO END AFTER CASE");
	UNDENT(CONIND); PRINT1; NTYPE_0; 
	SCAN1;
	CHECKSEMI;
	UNDENT(CONIND); CURCOUNT_S1;
	END;

COMMENT DO,DONE,RETURN,FOR,FOREACH,WHILE,GOTO;

[9]	BEGIN "DOSTMT"	COMMENT  -- do statement;
	TERPRI; PRINT1; NTYPE_1; SPRINT;
	INDENT(CONIND);
	CURCOUNT_NEXTCOUNTER;
	SCAN1;
	SCAN!STMT(1);
	PASSCOMMENT;
	UNDENT(CONIND);
	IF not EQU(STR1,"UNTIL") THEN LocError(0,"NO UNTIL AFTER DO");
	PRINT1; SCAN1;
	FINISH;
	TERPRI;
	CURCOUNT_NEXTCOUNTER;
	END;


[10]	BEGIN "DONE"	COMMENT  -- done, continue, return statements;
	FINISH;
	TERPRI;
	CURCOUNT_0;
	END;

[11]	BEGIN "FORST"	COMMENT  -- for, and foreach statements;
	TERPRI;
	NTYPE_1;
	WHILE  not EQU(STR1,"DO") DO
		PASSTOKEN;
	PRINT1; SPRINT;
	INDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	SCAN1;
	SCAN!STMT(1);
	UNDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	END;

[12]	BEGIN  "WHILE"	COMMENT  -- while statement;
	TERPRI;
	CURCOUNT_NEXTCOUNTER;
	NTYPE_1;
	WHILE  not EQU(STR1,"DO") DO
		PASSTOKEN;
	PRINT1; SPRINT;
	INDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	SCAN1;
	SCAN!STMT(1);
	UNDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	END;

[13]	BEGIN "GOTO"	COMMENT  -- go to statement;
	FINISH;
	TERPRI;
	CURCOUNT_0;
	END;


COMMENT IF STATEMENT AND START!CODE, ALSO NULL STATEMENT, AND LET;

[14]	BEGIN "IFSTMT"	COMMENT  -- if statement;
	TERPRI;
	S1_CURCOUNT;
	NTYPE_1;
	WHILE (TYP1 neq TOKENCODE) or  not EQU(STR1,"THEN") or (TYP2=EMRK) DO
		PASSTOKEN;
	PRINT1; SPRINT; SCAN1;
	INDENT(CONIND); CURCOUNT_NEXTCOUNTER;
	S2_S1-CURCOUNT;
	SCAN!STMT(1); S1_CURCOUNT;
	PASSCOMMENT;
	IF (SEMICOL=0)  and EQU(STR1,"ELSE") THEN
		BEGIN UNDENT(CONIND); CURCOUNT_S2;
		PRINT1; SPRINT; SCAN1;
		INDENT(CONIND); SCAN!STMT(1);
		S2_CURCOUNT;
		END;
	UNDENT(CONIND);
	CURCOUNT_S1+S2;
	END;

[15]	BEGIN "CODE"	COMMENT  -- start!code and quick!code;
	TERPRI;
	PRINT1; NTYPE_1; SPRINT; SCAN1; PASSCOMMENT;
	IF DOINDENT THEN INDENT(BLKIND) ELSE TERPRI;
	NTYPE_0;
	WHILE  not EQU(STR1,"END") DO
		BEGIN PRINT1;
		IF TYP1=";" THEN
			BEGIN  SCAN1; PASSCOMMENT;
			SPRINT; TERPRI;
			END
		ELSE SCAN1;
		END;
	IF DOINDENT THEN UNDENT(BLKIND) ELSE TERPRI;
	PRINT1; SPRINT; SCAN1; PASSCOMMENT;
	CHECKSEMI;
	TERPRI;
	END;

COMMENT  -- NULL STATEMENT NOT ENDING IN SEMICOLON;
COMMENT  -- THREE COPIES ARE NEEDED;

[16]	BEGIN  "NULL1"	COMMENT null statement, no semicolon--for END;
	STRING TSA;
	TSA_STR1A; STR1A_"  "; SPAC1_0;
	PRINT1;STR1A_TSA; SPAC1_1;
	NTYPE_1; SPRINT;
	SEMICOL_0;
	END;

[17]	BEGIN  "NULL2"	COMMENT null statement, no semicolon--for ELSE;
	STRING TSA;
	TSA_STR1A; STR1A_"  "; SPAC1_0;
	PRINT1;STR1A_TSA; SPAC1_1;
	NTYPE_1; SPRINT;
	SEMICOL_0;
	END;

[18]	BEGIN  "NULL3"	COMMENT null statement, no semicolon--for UNTIL;
	STRING TSA;
	TSA_STR1A; STR1A_"  "; SPAC1_0;
	PRINT1;STR1A_TSA; SPAC1_1;
	NTYPE_1; SPRINT;
	SEMICOL_0;
	END "NULL3";

[19]	LocError(0,"ILLEGAL USE OF ""OF""");	COMMENT  -- ERROR;

[20]	BEGIN "LET"	COMMENT -- let statement;
	STRING TSA;
	INTEGER J1;
	NTYPE_0;
	WHILE TYP1 neq ";" DO
	    BEGIN PRINT1; SCAN1; TSA_ STR1; PRINT1; SCAN1;
	    IF TYP1 neq  "=" THEN locError(0,"BAD LET STATEMENT");

	    PRINT1;
	    SCAN1; J1_ LOOKR;
	    IF J1 neq 0 THEN
		BEGIN NLETS_ NLETS+1;
		IF NLETS>let#max
		 THEN USERERR(0,0,"TOO MANY LET STMTS")
		 ELSE BEGIN LETSTR[NLETS]_ TSA; LETVAL[NLETS]_ J1; END;
		END;
	    PRINT1;
	    SCAN1;
	    END;
	PRINT1; SPACO_1; SCAN1; SEMICOL_1; SPRINT;
	END;

[21]	BEGIN "RECORDCLASS"
	IF (NRPC_NRPC+1)>rpc#max
	 THEN LocError(0,"TOO MANY RECORD CLASSES")
	 ELSE RPSTR[NRPC]_STR2;
	TERPRI; NTYPE_0; PLVL_0;
	WHILE (PLVL>0) OR (TYP1 NEQ ";") DO
	   BEGIN PRINT1;
	   IF TYP1="(" THEN PLVL_PLVL+1
	   ELSE IF TYP1=")" THEN PLVL_PLVL-1;
	   SCAN1 END;
	PRINT1; SPACO_1; SPRINT; SEMICOL_1; SCAN1; END;

[22]	BEGIN "RPTR"
	COMMENT must scan past parenthesized class list, then reenter 
		parser loop to allow for record!pointer procedures;
	DO BEGIN PRINT1; SCAN1 END UNTIL TYP1=")"; 
	PRINT1; SCAN1;
	NQ_3; 
	GOTO KP 
	END "RPTR"

COMMENT END OF THE VARIOUS STATEMENT ROUTINES;

		END;
	END "SCAN!STMT";


COMMENT THE REST OF THE MAIN PROGRAM;

LABEL MLO; COMMENT PUT THERE TO LOCATE LOOP IN DDT;

	NFIL_NKNT_IKNT_0;

COMMENT NOW READ IN THE COUNTER FILE;

	WHILE TRUE DO
		BEGIN 
		ARRYIN(SRC,INP[1],4);
		IF SRCEOF THEN DONE;
		N_INP[4];
		N_-(N%262144);
		NAMES[NFIL_NFIL+1]_CVXSTR(INP[1]);
		STRT[NFIL]_NKNT_NKNT+1;
		IF NKNT+N>MXKTR THEN USERERR(0,0,
		  "TOO MANY COUNTERS, USE THE /#K SWITCH (YOU HAVE AT LEAST "&CVS(NKNT+N)&" COUNTERS)");
		ARRYIN(SRC,KOUNTR[NKNT],N);
		NKNT_NKNT+N-1;
		END;
	STRT[NFIL+1]_NKNT+1;
	RELEASE(SRC);


COMMENT NOW READ IN THE LIST FILES AND PRODUCE THE 
 PROFILES.  THE LIST FILE NAMES ARE FOUND IN THE COUNTER
 BLOCK HEADERS WRITTEN OUT TO THE DISK AFTER EXECUTION;

	OPEN(SRC_GETCHAN,"DSK",0,2,0,SOURCECOUNT,SRCBRK,SRCEOF);
MLO:	FOR IFIL_1 STEP 1 UNTIL NFIL DO
		BEGIN "SRCLOOP"
		IKNT_STRT[IFIL]-1;
		FL_-1; LOOKUP(SRC,NAMES[IFIL]&
              IFCR DECSW THENC ".CRF" ELSEC ".LST" ENDC ,FL);
		IF FL THEN USERERR(0,0,"CAN'T FIND FILE-"&NAMES[IFIL]&
                   IFCR DECSW THENC ".CRF" ELSEC ".LST" ENDC);
		HEADNG_YES!BANG(HEAD1&NAMES[IFIL]);
		OUT(OFILE,'14&'15&HEADNG&'15&'12&'12);
		NLINES_0;
		FIRSTSCAN_1; SCAN1;
		FIRSTSCAN_0; SCAN1;
		PASSCOMMENT;
		IF EQU(STR1,"ENTRY") THEN 
			BEGIN CURCOUNT_NTYPE_0;
			WHILE TYP1 neq ";" DO BEGIN PRINT1; SCAN1 END;
			PRINT1;SPACO_1; SCAN1;
			SPRINT;
			END
		ELSE CURCOUNT_1;
		TERPRI;
		SCAN!STMT(0);
		TERPRI;
		CLOSE(SRC);
		IF IKNT neq (I_STRT[IFIL+1]-1) THEN
			USERERR(0,1,CVS(ABS(IKNT-I)) 
			  & (IF IKNT<I THEN " TOO FEW" ELSE " TOO MANY")
			  & " COUNTERS FOUND FOR-" & NAMES[IFIL]);
		END "SRCLOOP";
	RELEASE(SRC);
	RELEASE(OFILE);
	IF STPFLG THEN DONE;
END "KNTLOOP";
	END "SUPERLOOP";
OUTSTR("
THAT'S ALL FOLKS
");
END "PROFILE";

  sN5