; Modset, Tmdst, Amodst, Nmdst, Umodst, Bytmod, Flgmod, Lftt, Rftt
BEGIN ROUTS -- THESE ARE THE ROUTINES DISPATCHED TO

^MODSET:LDB	V,[POINT 6,M,5]	;GET MODE
MODSE1:	LSH	V,5		;ADJUST
MDGO:	HRLS	V
	SETZM	SAVMOD		;DON'T USE TEMP MODE IF CHANGING MODE
	LDB	M,[POINT 12,V,30]
	XCT	MODTB-1(B)	;PUT IN CORRECT PLACE (B HAS BUCKY COUNT)
	POPJ	P,		;LEAVE

MODTB:	DPB	M,[POINT 12,(PNT),12]	;SET MODE FOR THIS ONE
	HRRM	V,CURMOD	;SET CURRENT MODE
	MOVEM	V,CURMOD	;SET PERMANENT MODE

^TMDST:	TLNE	F1,VALF		;VALUE TYPED?
	 SKIPA	V,VALUE		;YES, GET IT
	 MOVEI	V,7		;NO   (TXT=5)
	CAIG	V,7
	 CAIG	V,4
	  JRST	CERR
	JRST	MODSE1

IFN FILESW,<
^SETDV:	TLNE	F1,VALF		;VALUE TYPED?
	 SKIPA	V,VALUE		;YES, GET IT
	 HRLZI	V,-1		;NO, make it undefined and re-guess
	MOVEM	V,specdev
	POPJ	P,
>;FILESW

^AMODST:MOVE	M,CURMOD
	HRLI	M,.LEFT.(40,5)
	TRO	M,.LEFT.(40,5)
	MOVEI	V,1
	XCT	AMODTB-1(B)	;B HAS BUCKY COUNT
	POPJ	P,

AMODTB:	DPB	V,[POINT 1,(PNT),7]
	HRRM	M,CURMOD
	IORM	M,CURMOD

^NMDST:	MOVEI	V,.LEFT.(DCM,5)		;DECIMAL MODE
	TLNE	F1,VALF		;VALUE TYPED?
	 MOVEI	V,.LEFT.(OCL1,5)	;YES, OCTAL
	JRST	MDGO

^UMODST:TLNE	F1,VALF		;VALUE?
	 SKIPA	V,VALUE		;YES,GET IT
	 MOVEI	V,7		;NO
	CAIG	V,7
	 CAIG	V,4
	  JRST	CERR
	ADDI	V,6		;UTX=13 
	JRST	MODSE1

^BYTMOD:TLNN	F1,VALF
	 JRST	CERR
	MOVE	V,VALUE
	ANDI	V,77
	LSH	V,13
	ADDI	V,.LEFT.(BYT,5)
	JRST	MDGO

^FLGMOD:MOVEI	M,.LEFT.(BTS,5)	;THE MODE BITS
COMFLG:	TLNN	F1,VALF	;VALUE TYPED?
	 TDZA	V,V	;NO SET ZERO
	 MOVE	V,VALUE	;ELSE USE TYPE VALUE
	ANDI	V,77
	LSH	V,13	;PACK AWAY
	ADD	V,M	;AND PUT IN MODE BITS
	JRST	MDGO	;GO GO

^RFTT:	MOVEI	M,.LEFT.(RBT,5)
	JRST	COMFLG

^LFTT:	MOVEI	M,.LEFT.(LBT,5)
	JRST	COMFLG

;Depo1, Echk

DEPO1:	TLNE	F,LOCOPF	;LOCATION OPEN?
	 TLNN	F1,VALF		;VALUE?
	  POPJ	P,		;JUST QUIT
	SKIPE	E,SAVMOD	;SPECIAL MODE FOR THIS THING?
	 DPB	E,[POINT 7,(PNT),12];YES, CHANGE MODE FOR THIS LINE
	LSH	E,-6		;IF V, THIS  IS BYTE SIZE
	JUMPE	E,.+2
	 DPB	E,[POINT 6,(PNT),6]	;PUT THERE
	SETZM	SAVMOD		;FOR GRINS
	HRRZ	E,LOCOP
	JSR	ECHK
	MOVE	V,VALUE	;GET VALUE
IFE UESW,<
IFE FILESW,<
	CAIG	E,@JOBREL
IFN SEGSW,<
	 JRST .+3
	SKIPGE	JOBHRL
	PUSHJ	P,UNPUR
>
IFE SEGSW,<
	 JRST	.+2
	JRST	CERR
>
	MOVEM	V,(E)	;DEPOSIT
>;NOT FILESW
IFN FILESW,<
	PUSHJ	P,RDTRKE	;READ IN TRACK THAT CONTAINS E
	MOVEM	V,@TRKOFF
	PUSHJ	P,WRTRK		;WRITE IT BACK OUT
>
>;END NOT UESW
			IFN UESW,<	MOVEM	V,SSS1#
					MOVEM	E,SSS2#
					SETZM	SSS3#
					MOVE	V,[XWD 400001,SSSDO]
					CALL	V,[SIXBIT /SPCWGO/]
					SKIPN	SSS3
					JRST	.-1
					TNOFFS
					MOVE	V,SSS1>
	POPJ	P,
			IFN UESW,<SSSDO:SKIPE	SSS3
					 0
					HRLI	2,-1
					DATAO	2
					MOVN	3,2
					ADD	3,SSS2
					MOVE	4,SSS1
					MOVEM	4,(3)
					SETOM	SSS3
					0>

^ECHK:	0
IFE FILESW!UESW,<
	CAIG	E,17	;AC?
	ADDI	E,JAC	;YES
	CAMLE	E,JOBREL	;TOO BIG?
IFE SEGSW,<
	 JRST	CERR 	;YES
>
IFN SEGSW,<
	 JRST [	CAIL	E,400000
		 CAILE	E,@JOBHRL
		  JRST	CERR
		JRST	@ECHK]
>
	JRST @ECHK
>;END NEITHER FILESW NOR UESW

IFN FILESW,<
	SKIPE	DMPFSW
	 JRST	ECHKD1		;DUMP FILE
	CAMLE	E,FILLST
	 JRST	CERR
	JRST	@ECHK

ECHKD1:	CAIL	E,74
	 CAMLE	E,FJBHRL
	  JRST	CERR
	CAMLE	E,FJBREL
	 CAML	E,UPPRST
	  JRST	@ECHK
	JRST	CERR
>;FILESW

IFE SORTED,<
; Refblk, Refclr, Refrst, Frepopj

; GET BACK A PREVIOUS PROG/BLOCK PAIR (nCTRL1-Z, n=1 DEFAULT)

^REFBLK:
	TLNE	F1,VALF		;WAS A VALUE TYPED?
	 SKIPA	D1,VALUE	;YES, USE IT
	 MOVEI	D1,1		;NO, USE LAST PROG/BLOCK USED
	ADD	D1,REFGET	;OFFSET FROM LAST ENTERED
	MOVMS	D1
	IDIVI	D1,NUMREF	;GET MOD
REFDSP:	SKIPN	E,PRGREF(D2)	;GET PROGRAM POINTER
	 JRST	CERR		;NONE THERE
	MOVEM	D2,REFGET	;CURRENT GETTER
	MOVEM	E,SYMPRG	;UPDATE THIS
	MOVE	E,BLKREF(D2)	;GET BLOCK POINTER
	MOVEM	E,SYMPNT
^FREPOPJ:
	TRO	F,DPYALL	;START FROM SCRATCH
	POPJ	P,		;REFRESH THE SCREEN, USE NEW BLOCK

;GET HERE WHEN SOMETHING GROSS BEFALLS THE SYMBOL TABLE
^SYMRST:MOVSI	F1,SINGF
	MOVE	T,PRGSAV
	MOVEM	T,SYM
	PUSHJ	P,PRGFND
	MOVE	T,BLKSAV
	TLZ	T,740000
	PUSHJ	P,BLKFND
;CTRL2-Z -- clears block reference history, enters current block

^REFCLR:SETZM	PRGREF
	MOVE	E,[PRGREF,,PRGREF+1]
	BLT	E,BLKREF+NUMREF-1
	SETZM	REFGET
	SETZM	REFPNT
	JRST	INSBLK		;GO INSERT CURRENT IN BUFFER

>;NOT SORTED

IFN SORTED,<
; Refblk, Refclr

;GET BACK A PREVIOUS PROG/BLOCK PAIR (nCTRL1-Z, n=1 default)

^REFBLK:
	SKIPGE	REFPNT		;THERE MUST BE SOMETHING OPEN
	 JRST	CERR
	TLNN	F1,VALF		;WAS A VALUE TYPED?
	 SKIPA	T,[-1]		;NO
	 MOVN	T,VALUE		;YES, USE IT
	ADD	T,REFPNT	;OFFSET FROM LAST ENTERED
	JUMPGE	T,.+2
	 MOVEI	T,0		;TOO LARGE YIELDS BOTTOM OF STACK
	HRRZ	E,BLKREF(T)	;USE THIS BLOCK ID
	PUSHJ	P,SETBL		;MAKE SURE ITS PROGRAM IS OPEN
	 JFCL			; (SKIP-RETURNS)
	PUSHJ	P,ZAPIT		;REMOVE AND RE-INSERT AT TOP
	JRST	FREPOPJ		;MARK COMPLETE REDISPLAY AND QUIT

;CTRL2-Z -- CLEARS BLOCK REFERENCE HISTORY, ENTERS CURRENT BLOCK

^REFCLR:
	SETZM	BLKREF
	MOVE	E,[BLKREF,,BLKREF+1]
	BLT	E,BLKREF+NUMREF-1
	SETOM	REFPNT
	MOVE	E,BID
	JRST	INSBLK		;GO INSERT CURRENT IN BUFFER
>;SORTED

; Depo, Opens, Openu, Fndscr, Openp -- Open a Cell (see if it's there)

^DEPO:	SKIPN	E,STSAV		;WAS MULTI-WORD ASCII INDICATED?
	 JRST	DPO11		; NO
	MOVEM	E,STRIN		;YES, LET RAID READ THIS WEIRD STRING
	JRST	MAIN		;FROM THE TOP

DPO11:	PUSHJ	P,DEPO1
	HLRS	CURMOD		;RESET MODE
	POPJ	P,

^OPENS:	TLNE	F1,VALF		;VALUE TYPED?
	 JRST	SOPENS		;YES
	TRO	F1,1		;NO, SET FLAG
	HRRZ	E,(PNT)		;GET CURRENT ADDRS
	JSR	ECHK
IFN FILESW,<
	PUSHJ	P,RDTRKE	;READ IN THE TRACK THAT CONTAINS E
	MOVE	E,@TRKOFF
>
IFE FILESW,<	CMOVE (E,E)	>

OPENU:	MOVEM	E,VALUE
SOPENS:	MOVEI	T,0
OPENQ:	HRRZ	E,VALUE		;GET VALUE
	JSR	FNDSCR		;ON SCREEN? (ALSO SETS `M' TO POINT TO THE LINE)
	 JRST	PNT2		; YES
PNT4:	TLO	F,LOCOPF 	;LOCATION OPEN
	AOBJN	PNT,PNT1 	;GO TO NEXT, AT END?
	TLNE	PNT,7		;NOT REALLY AT END?
PNT9:	 MOVS	PNT,SPNT	;AT END,GET START POINTER
PNT1:	SKIPL	(PNT)		;PERMANENT?
	 JRST	GOTIT		;NO
	JUMPGE	PNT,PNT99	;AT LAST ONE?
	 MOVE	E,PNT		;GET POINTER
	SKIPGE	1(E)		;NEXT ONE PERMANENT?
	 AOBJN	E,.-1		;YES, TRY AGAIN
	JUMPGE	E,[PNT99:
		TRON	F1,2
		 JRST	PNT9
		JRST	CERR]
	HRRZS	E
LOP1:	MOVE	V,(E)		;FOUND ONE, SHUFFLE DOWN
	MOVEM	V,1(E)
	TLNN	V,20		;DOES SOMEONE POINT HERE?
	 JRST	NOPONT		;NO
	MOVS	D2,SPNT		;GET POINTER FOR SEARCH
LOP2:	MOVE	D3,(D2)
	TLNN	D3,17		;IS THIS A POINT TYPE THING?
	 JRST	NOLOP1		;NO
	CAIN	E,(D3)		;DOES THIS POINT TO IT?
	 AOS	(D2)		;YES, UPDATE
NOLOP1:	AOBJN	D2,LOP2		;LOOP
	TLNN	D2,7
	 JRST	LOP2
NOPONT:	CAIE	E,(PNT)		;BACK TO START?
	 SOJA	E,LOP1		;NO
GOTIT:	MOVE	E,VALUE		;GET LOCATION
	HRL	E,CURMOD	;GET CURRENT MODE
	MOVEM	E,(PNT)		;DEPOSIT
	TRZN	F1,1
	 HRRZM	E,LOCOP
OPTHP:	IORM	T,(PNT)		;MARK AS PERMANENT
	POPJ	P,

PNT2:	MOVE	PNT,M
	TLO	F,LOCOPF
	IORM	T,(PNT)
	HRRZ	E,(PNT)
	TRZN	F1,1
	 MOVEM	E,LOCOP
	POPJ	P,

^FNDSCR: 0
	MOVS	M,SPNT	;GET START POINTER
PNT3:	SKIPN	D2,(M)	;DONE?
	 JRST	PNT44	;YES
	TLZ	D2,777760
	CAMN	E,D2	;SAME?
	 JRST	@FNDSCR	;YES
	AOBJN	M,PNT3	;LOOP, AT END?
	TLNN	M,7	;REALLY AT END?
	 JRST	PNT3	;NO
PNT44:	AOS	FNDSCR	;SKIP ROUTINE, FIND
	JRST	@FNDSCR

^OPENP:	MOVSI	T,400000
	TLNE	F1,-1	;A VALUE TYPED IN?
	JRST	OPENQ
	JRST	OPTHP

^BSSET:	SKIPA	C,["<"]
^LFSET:	 MOVEI	C,">"
	SUB	P,[1,,1]
	JRST	CDCONT

; Macdef, Macexp, Macimm -- Define and Expand Macros

^MACDEF:
	TLNN	F1,VALF			;THERE MUST BE AN ADDRESS
	 JRST	CERR			; THERE ISN'T
IFE TENEX,<
	MOVE	T,[INCHRW C]		;ONE CHAR
>
IFN TENEX,<
	MOVE	T,[^BIN1:
		PUSHJ	P,[PBIN
			MOVE	C,1
			POPJ	P,
		]	]
>
	EXCH	T,TYII
	PUSHJ	P,GCHRS
	MOVEM	T,TYII			;HAVE A CHARACTER
	LSH	C,4			;PREPARE DISPATCH TABLE ENTRY
	TRO	C,10			;DOUBLE-BUCKY CHARACTER FOR MACRO
	HRLI	C,MACEXP		;ROUTINE WHICH EXPANDS MACROS
	AOS	T,TABLEN		;GET A NEW ENTRY
	CAIG	T,CTABCN+20		;IS THERE ROOM?
	 JRST	OKMAC			; YES, ENTER IT
IFE TENEX,<
	OUTSTR	[ASCIZ "TOO MANY MACROS "]
>
IFN TENEX,<
	HRROI	A,[ASCIZ "TOO MANY MACROS "]
	PSOUT
>
	SOS	TABLEN
	JRST	CERR			;GO COMPLAIN
OKMAC:	MOVSM	C,CTAB(T)		;A NEW DISPATCH ENTRY
	MOVE	V,VALUE			;THE MACRO TEXT LOCATION
	TLNN	V,-1			;UNLESS USER SUPPLIED BP BITS,
	 HRLI	V,440700		;CREATE A BYTE POINTER
	MOVEM	V,MACLOC-CTABCN(T)	;PARALLELS DISPATCH ENTRY
	POPJ	P,			;DONE

^MACIMM:
	TLNN	F1,VALF			;THERE MUST BE AN ADDRESS
	 JRST	CERR			; THERE ISN'T
	MOVE	V,VALUE			;GET IT
	TLNN	V,-1			;MAKE BP IF NOT THERE
	 HRLI	V,440700
	SKIPA
^MACEXP: MOVE	V,MACLOC-CTABCN(T)	;BYTE POINTER
	MOVEM	V,STRIN			;TTY SIMULATOR
	JRST	ERET			;ROUND WE GO

; Edit -- Edit Previous Value Using System Line Editor

IFN STANFO,<
^EDIT:
	MOVE	E,DDSW
	JRST @(E)[CERR
		CERR
		CERR
		EDDIT
		EDDIT]
EDDIT:	HRRZ	E,VALUE		;IF THERE IS ONE
	TLNN	F1,VALF		;A VALUE?
	 HRRZ	E,LOCOP		;NO, USE .
	JSR	ECHK		;ADJUST IF AC
	JSR	FNDSCR		;ON SCREEN?
	JRST [	HLRZ	M,(M)	;YES, USE SCREEN LINE'S MODE
		JRST	ED1]
	HRRZ	M,CURMOD	;NO, USE CURRENT MODE
ED1:	TRZ	M,774037	;CLEAR NON-MODE BITS
	MOVE	V,M
	LSH	V,-5		;PUT IN SAVMOD FORMAT
	MOVEM	V,SAVMOD	;SAVE IT
	
; NOW PREPARE FOR CONVERSION

IFE FILESW,<	MOVE	V,(E)>		;SAVE VALUE
IFN FILESW,<
	PUSHJ	P,RDTRKE
	MOVE	V,@TRKOFF
>
	MOVE	E,[POINT 7,EXBUF] 	;PUT STRING REP HERE
	MOVEM	E,STRIN			;FOR RAID STRING INPUT
	MOVEI	T,0			;ASSUME NOT TEXT
	CAIN	M,.LEFT.(6,5)		;SIXBIT
	 MOVEI	T,"'"			; YES
	CAIN	M,.LEFT.(7,5)		;ASCII?
	 MOVEI	T,42			;YES, " CHAR
	JUMPE	T,NOTX1			;NOT A TEXT RQST
	IDPB	T,E			;TEXT RQST
; FOR ASCII TEXT, MUST EDIT THE VALUE, FIND VALID DELIM, ELIMINATE 
; ACTIVATION CHARS
	MOVEI	D2,002		; character alpha 
	PUSH	P,D2		;SAVE DELIMITER
	CAIE	M,.LEFT.(7,5)		;ASCII?
	 JRST	NOASCI		;NO
	MOVE	D3,V		;GET TEXT VAL
	SETZB	V,T		;CLEAR THESE
ASL:	JUMPE	D3,ASD		;DONE
	MOVEI	D2,0
	LSHC	D2,7		;NEXT CHAR
	CAIE	D2,15		;ELIMINATE ACTIVATION
	 CAIN	D2,12		;CHARS
	  JRST	ASL
	CAIN	D2,ALTMOD
	 JRST	ASL
	CAIN	D2,002	;alpha (^B)
	 TRO	T,4
	CAIN	D2,003	;beta (^C)
	 TRO	T,2
	CAIN	D2,006	;epsilon (^F)
	 TRO	T,1
	LSH	V,7
	IOR	V,D2		;COLLECT NEW VALUE
	JRST	ASL

	LSH	V,7
ASD:	JUMPE	V,.+3
	 TLNN	V,376000	;SHIFT TO LEFT
	  JRST	.-3		;UNTIL TO LEFT
	LSH	V,1		;ONE MORE
	MOVEI	D2,0		;NOW GET DELIM
	TRNN	T,4
	 MOVEI	D2,002		;alpha (^B)
	TRNN	T,2
	 MOVEI	D2,003		;beta (^C)
	TRNN	T,1
	 MOVEI	D2,006		;epsilon (^F)
	JUMPE	D2,CERR		;NO AVAIL DELIM
	MOVEM	D2,(P)		;SET UP DELIM
NOASCI:	IDPB	D2,E		;PUT IN DELIMITER
NOTX1:	PUSHJ	P,CONV		;CONVERT TO EXTERNAL REP
	HRRZ	V,SAVMOD
	CAIL	V,6		;IF TEXT,
	 CAILE	V,7
	  JRST	ABCDE
	POP	P,T
	IDPB	T,E		;FINISH OUT TEXT INPUT FORMAT
ABCDE:	PUSHJ	P,[FINLIN:
		MOVEI	C,15
		IDPB	C,E
IFN STANFO,<
		MOVEI	C,12
		IDPB	C,E
>;STANFO
		MOVEI	C,0
		IDPB	C,E
		POPJ	P,]

; TIME TO PLAY EDITOR
	SETLIN	EDTLIN		;FCS ON, SPECIAL ACTIVATION OFF
	CLRBFI			;CLEAR INPUT
	PTLOAD [0
		EXBUF]  	;SEND TO LINE EDITOR
	SETLIN	ASCLIN		;FCS SAME AS USER'S, 
				;SPECIAL ACTIVATION OFF 
	PUSHJ	P,SVACS
	INWAIT	T		;#CHARS EDITED
	SETLIN	RADLIN		;NORMAL RAID CHARACTERISTICS
	MOVE	E,[POINT 7,EXBUF]
	JRST	EDL1		;GO LOOP

EDL:	INCHRW	C		;GET CHAR
	CAIN	C,ALTMOD
	 JRST	ERET		;ABORT
	CAIE	C,15		;IGNORE CRLFS
	 CAIN	C,12
	  JRST	EDL1
	IDPB	C,E		;COLLECT STRING
EDL1:	SOJGE	T,EDL
	PUSHJ	P,FINLIN	;INSERT CRLF-NULL
	JRST	MAIN1		;WILL FEED DEPO
>;STANFORD

; Upar,Lnfd, Etc.; Lefsq2, Tab, Etc. -- <>...Routs, <tab>etc., MVTST
^UPAR:	PUSHJ	P,MVTST		;GET CURRENT LOCATION
	HLLZ	M,(PNT)		;GET MODE OF CURRENT ONE
	MOVS	T,PNT		;GET CURRENT POINTER
	CAME	T,SPNT		;AT TOP?
	 JRST	UPA1		;NO
	AOBJN	PNT,.		;YES, GO TO END
	SKIPN	-1(PNT)		;NULL?
	 SOJA	E,[MOVS	PNT,SPNT	;YES, MOVE DOWN INSTEAD
		  JRST	MOVL1]
	SKIPL	(PNT)		;PERMANENT?
	 JRST	UPA1A		;NO
	SUB	PNT,[1,,1]	;YES
	JRST	.-3

UPA1:	SUB	PNT,[1,,1]
UPA1A:	SUB	PNT,[1,,1]
	SOJA	E,MOVL1		;GO TO PREVIOUS

^LNFD:	PUSHJ	P,MVTST	;GET CURRENT LOCATION
	HLLZ	M,(PNT)	;GET MODE OF CURRENT ONE
	ADDI	E,1	;GO TO NEXT
MOVL1:	TRNN	B,2	;LEFT BUCKY ON?
	JRST	OPENU	;NO
	TLZ	M,400037	;CLEAR RANDOM BITS
	PUSH	P,M	;SAVE MODE OF THIS ONE
	MOVEI	F1,4
	PUSHJ	P,OPENU
	MOVSI	M,377777
	ANDCAM	M,(PNT)	;CLEAR MODE
	POP	P,M	;GET MODE OF OLD ONE
	IORM	M,(PNT)
	POPJ	P,

^MOVUP:	PUSHJ	P,MVTST
	MOVS	M,(PNT)		;GET MODE OF CURRENT ONE
	TLO	F,LOCOPF	;LOCATION OPEN
	MOVS	E,SPNT		;GET STARTING POINTER
	CAMN	PNT,E		;AT TOP?
	 JRST	MOVL2		;YES
	SUB	PNT,[1(1)]	;NO, MOVE UP 1
	JRST	MOVL3		;GO DISPLAY
MOVL2:	AOBJN	PNT,.		;AT TOP, MOVE TO BOTTOM
	JRST	MOVL3
^MOVDN:	PUSHJ	P,MVTST
	MOVS	M,(PNT)
	TLO	F,LOCOPF	;LOCATION OPEN
	AOBJN	PNT,.+3		;MOVE DOWN 1, AT END?
	 TLNE	PNT,7		;REALLY AT END?
	  MOVS	PNT,SPNT	;YES, GO TO TOP
MOVL3:	HRRZ	T,(PNT)
	MOVEM	T,LOCOP
	TRNN	B,2		;LEFT BUCKY BIT ON?
	 POPJ	P,		;NO
	LSH	M,-5
	DPB	M,[POINT 12,(PNT),12]	;SET NEW MODE ON THIS ONE
	POPJ	P,

^LEFSQ2:TRO	F1,1
^TAB:	MOVEI	D2,0
	JRST	RLCON

^RITSQ2:TRO	F1,1
^RITSQ4:MOVEI	D2,1
	JRST	RLCON

^ATSIN2:TRO	F1,1
^ATSIN4:MOVEI	D2,2
RLCON:	PUSHJ	P,MVTST
	MOVE	V,(PNT)
	PUSHJ	P,GETPOI
	 JRST	CERR
IFE UESW,<
IFE FILESW,<
	XCT (D2)[MOVE E,(E)
		 MOVS E,(E)
		 MOVE M,(E)]
>
IFN FILESW,<
	PUSHJ	P,RDTRKE
	XCT (D2)[MOVE E,@TRKOFF
		 MOVS E,@TRKOFF
		 MOVE M,@TRKOFF]
>
>;END NOT UESW
			IFN UESW,<	CMOVE (E,E)
					CAIN D2,1
					MOVSS E
				>
	CAIN	D2,2
	PUSHJ	P,GPELOP
	JRST	OPENU

MVTST:	HRRZ	E,LOCOP
	TLNE	F,LOCOPF
	 TLNN	F1,VALF		;ANY VALUE TYPED?
	  POPJ	P,
	PUSHJ	P,DEPO1		;YES, DEPOSIT
	MOVE	E,LOCOP
	POPJ	P,		;NO

^LEFSQ1:MOVEI	D2,1
	JRST	LRATDO

^RITSQ1:SKIPA	D2,[2]
^ATSIN1: MOVEI	D2,3
LRATDO:	MOVSI	M,400020
	IORM	M,(PNT)		;MARK THIS ONE
	MOVEM	PNT,VALUE	;OPEN A POINTER
	TRO	D2,400000	;MAKE IT PERMANENT
	MOVS	T,D2
	TRO	F1,1
	JRST	PNT4		;AVOID FINDING ANOTHER COPY ON SCREEN

^REMPER:MOVSI	V,400000	;GET SIGN BIT
	ANDCAM	V,(PNT)		;CLEAR
	JRST	REDISP

^REFRSH:
	PUSHJ	P,SCLRCL	;CLEAR SCREEN
	TRO	F,DPYALL+DRWALL	;REDO EVERYTHING
	POPJ	P,

^SCLR:
IFN STANFO!TYMSHR,<
	PUSHJ	P,SCLRCL
>
	MOVS	PNT,SPNT
	SUB	PNT,[1,,1]
	MOVEI	M,0
	TLZ	F,LOCOPF
	JRST	INC
; Sclrsv, Incr, Leffnd, Eqiv, Wdsrch, Etc.

^SCLRSV:
IFN STANFO!TYMSHR,<
	PUSHJ	P,SCLRCL	;CLEAR THE SCREEN IF DATA DISK
>
	TRZ	F,DRWALL
	TRO	F,DPYALL
	MOVS	M,SPNT		;GET POINTER TO DPNT
	MOVE	V,M
SCLRS1:	SKIPGE	T,(M)		;SKIP IF NOT PERMANENT
	 JRST	SCLRS4
SCLRS3:	AOBJN	M,SCLRS1
	TLNN	M,7
	 JRST	SCLRS1
	MOVE	PNT,V
	SUB	PNT,[1,,1]	;POINTER TO LAST LINE USED
	JUMPGE	V,SCLRS6
SCLRS5:	SETZM	(V)
	AOBJN	V,SCLRS5
	TLNN	V,7
	 JRST	SCLRS5
SCLRS6:	TLNN	F,LOCOPF
	POPJ	P,
	MOVE	E,LOCOP
	JSR	FNDSCR		;SKIP IF NOT ON SCREEN NOW
	 POPJ	P,		;ON SCREEN, OK
	MOVS	V,PNT
	ADD	V,[1,,1]
	CAMN	V,SPNT
	 TLZA	F,LOCOPF
	 CAIA
	 POPJ	P,
	MOVE	V,(PNT)
	PUSHJ	P,GETPOI
	 JFCL
	HRRZM	E,LOCOP
	POPJ	P,

SCLRS4:	MOVEM	T,(V)		;FOUND A PERMANENT ENTRY
	MOVE	T,DSAV-DPNT(M)
	HLLM	T,DSAV-DPNT(V)	;MOVE THE ARROW FLAGS
	AOBJN	V,SCLRS3
	JRST	SCLRS3

^INCR:	TLNE	F1,VALF		;VALUE TYPED?
	JRST	.+3		;YES
	MOVN	E,SPNT		;NO, GET CURRENT #
	AOJA	E,.+2		;INCREMENT
	SOS	E,VALUE		;GET TYPED VALUE
	HRRZS	E
	CAILE	E,MAXDLN-3		;TOO BIG?
	JRST	CERR		;YES
	MOVS	V,PNT
	SUB	V,SPNT		;GET POINTER TO WHERE WE ARE IN DISPLAY
	CAIGE	E,(V)
	JRST [	MOVEI	V,0
		HLRZ	M,SPNT
		HRRM	M,PNT
		JRST	.+1]
	MOVN	M,E
	HLL	M,SPNT
	EXCH	M,SPNT		;DEPOSIT NEW DISPLAY SIZE
IFN STANFO!TYMSHR,<
	SUB	M,SPNT		;OLD -SIZE MINUS NEW -SIZE
	TRNE	M,400000	;SKIP IF NOT DECREASING SIZE
	 PUSHJ	P,SCLRCL	;CLEAR THE SCREEN
>;STANFO
	SUB	E,V
	MOVN	M,E
	HRL	PNT,M
INC:	SUBM	PNT,M		;POINTER TO LAST ELEMENT IN THIS SIZE
	SETZM	1(M)
	HRLI	M,1(M)
	ADDI	M,2
	BLT	M,DPNT-1+MAXDLN
	POPJ	P,

^LEFFND:MOVE	E,STPOP
	JRST	OPENU

^EQIVL:	0
^EQIV:	MOVEI	V,IFE UESW!FILESW,<EQIVL;> -1
	EXCH	V,VALUE		;DEPOSIT AND GET TYPED VALUE
	TLNE	F1,VALF		;VALUE TYPED?
	 MOVEM	V,EQIVL		;YES, DEPOSIT IT
	TRO	F1,1		;DO NOT MOVE .
	PUSH	P,CURMOD
	MOVEI	V,100		;CHANGE MODE TO OCTAL
	HRRM	V,CURMOD
	PUSHJ	P,SOPENS	;OPEN IT
	POP	P,CURMOD	;RESTORE MODE
	POPJ	P,

^LB1:	MOVEI	E,TLBOUN
	JRST	LRB
^LB2:	MOVEI	E,PLBOUN
LRB:	TLNN	F1,VALF
	 JRST	CERR
	MOVE	V,VALUE
	HRRZM	V,(E)
	HRRZM	V,1(E)
	POPJ	P,

^RB1:	MOVEI	E,TUBOUN
	JRST	LRB
^RB2:	MOVEI	E,PUBOUN
	JRST	LRB
^PLBOUN:0
^TLBOUN:0
	0
^PUBOUN:0
^TUBOUN:0
	0

; WORD, EFFECTIVE ADDRESS, NOT-EQUAL SEARCHES

^SRCON:	TRZN	F,SRCHSW	;SEARCH IN PROGRESS?
	 POPJ	P,		;NO
	MOVE	V,VSSVQ
	MOVE	M,SRCHCN
	JRST	WDSCON

^ESRCH:	MOVEI	M,2
	JRST	SRST
^WDSRCH:TDZA	M,M
^NWDSR:	 MOVEI	M,1
SRST:	MOVE	V,TLBOUN
	MOVE	E,VALUE		;GET VALUE
	XCT	STB1(M)
	 JRST	ZPU
	MOVEM	E,SRVAL#	;STORE
WDSCON:	MOVEI	E,1		;GET INITL COUNT
	MOVS	T,SPNT		;GET POINTER
WDSLUP:	SKIPL	(T)		;PERMANENT?
	 ADDI	E,1		;NO, COUNT
	AOBJN	T,WDSLUP	;LOOP
	TLNN	T,7		;DONE?
	 JRST	WDSLUP		;NO
	LSH	E,-1		;DIVIDE BY 2
	JUMPE	E,CERR		;NO LOCATIONS
	MOVEM	E,SRCNT#
LOPP1:	CAML	V,TUBOUN	;DONE?
	 JRST	WDON		;YES
IFN FILESW,<
	CAIGE	V,20
	JRST [	MOVE	E,JAC(V)
		JRST	LOPP1A]
	HRRZ	E,V
	PUSHJ	P,RDTRKE
	MOVE	E,@TRKOFF
LOPP1A:
>
IFE FILESW,<
	CAIG	V,17		;AC?
	 SKIPA	E,JAC(V)	;YES
	 MOVE	E,(V)		;GET WORD
>
	XCT	STB1(M)
	 AOJA	V,LOPP1
	XOR	E,SRVAL		;COMPARE
	AND	E,@STB3(M)	;AND WITH MASK
	XCT	STB4(M)
	 AOJA	V,LOPP1		;NO
FND1:	PUSH	P,V
	PUSH	P,M
	MOVEM	V,VALUE
	SETZB	T,F1
	PUSHJ	P,OPENQ		;OPEN FOUND LOCATION
	SOSG	SRCNT		;n FOUND?
	 SKIPA	E,[.STAR]
	 PUSHJ	P,REDISP	;DRAW HERE IF NOT RETURNING TO TOP LEVEL
	POP	P,M
	POP	P,V
	SKIPLE	SRCNT		;ENOUGH FOUND?
	 AOJA	V,LOPP1
	TRO	F,SRCHSW	;YES, SET FLAG
	HRLM	E,NBIGWD
	MOVEM	M,SRCHCN#	;SAVE TYPE OF SEARCH
	MOVEM	V,VSSVQ#
	AOS	VSSVQ
	POPJ	P,
WDON:	MOVE	V,PLBOUN
	MOVEM	V,TLBOUN
	MOVE	V,PUBOUN
	MOVEM	V,TUBOUN
	TRZ	F,SRCHSW
	POPJ	P,

;   Wdsrch Subroutines

^STRIN:	0		;IT'S $M-1 IF REALLY RAID
IFN REALSW,<INTERN $M,DDTEND>
^$M:
^SMASK:	-1
	-1
	0
^FLGPTR:0
STB1:	SKIPA
	SKIPA
	PUSHJ	P,CALCE
STB3:	SMASK
	SMASK
	[777777]
STB4:	JUMPE	E,FND1
	JUMPN	E,FND1
	JUMPE	E,FND1

CALCE:	MOVE	T,E
	LDB	D2,[POINT 4,E,17]	;GET IX
	JUMPE	D2,CLOP1	;NO IX
	ADD	T,JAC(D2)	;ADD IX
CLOP1:	HRRZS	T		;CLEAR LEFT HALF
	MOVEM	T,CTSV
	TLNN	E,20		;@?
	 JRST	CDONE		;NO
IFE FILESW,<
	CAMLE	T,JOBREL	;O.K.?
IFE SEGSW,<POPJ	P,>
IFN SEGSW,<JRST	[CAIL	T,400000
		  CAILE	T,@JOBHRL
		   POPJ	P,
		JRST	.+1]>
>;NOT FILESW
IFN FILESW,<
	CAIGE	T,20
	JRST [	MOVE	E,JAC(T)
		CALCE1]
	HRRZ	E,T
	CAIL	E,74
	 CAMLE	E,FJBHRL
	  POPJ	P,
	CAMLE	E,FJBREL
	 CAML	E,UPPRST
	  JRST	.+2
	  POPJ	P,
	PUSHJ	P,RDTRKE
	MOVE	E,@TRKOFF
CALCE1:
>
IFE FILESW,<
	CAIG	T,17	;AC?
	ADDI	T,JAC	;YES
	MOVE	E,(T)	;GET WORD
>
	HRRZ	T,E
	CAME	T,CTSV
	JRST	CALCE
	POPJ	P,
CTSV:	0
CDONE:	MOVE	E,T
	AOS	(P)
	POPJ	P,

; Symdef, Symdf1, Symkil, Symfnd, Symfn1 -- Create and Delete Symbols
IFE SORTED,<

; SYMBOL_VALUE
^SYMDEF:
	PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES, SO AS NOT TO CONFUSE
	PUSH	P,SYM	;SAVE SYMBOL
	PUSHJ	P,EVAL	;GET VALUE
	TLNN	F,VALF	;VALUE?
	 JRST	CERR	;NO
	POP	P,SYM	;RESTORE SYMBOL
	JRST	DFQ1	;GO ENTER

; SYMBOL:
^SYMDF1:
	PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES
	TLNN	F,LOCOPF	;LOCATION OPEN?
	 JRST	ZPU		; NO
	MOVE	V,LOCOP		;GET VALUE OF .

DFQ1:	MOVEM	V,VALUE	;SAVE
	PUSHJ	P,SYMFN1	;FIND THE CURRENT NAME ENTRY, IF ANY
	 JRST	THERE		; FOUND ONE
	MOVN	V,[2,,2]
	ADDB	V,JOBSYM	;FIX JOBSYM
	MOVSI	E,2		;UPDATE POINTERS
	ADDM	E,SYMPNT
	ADDM	E,SYMPRG
	MOVE	E,SYM		;GET SYMBOL
	TLO	E,40000 	;MAKE GLOBAL
	MOVEM	E,(V)		; SYMBOL
THERE:	MOVE	E,VALUE		;SAVED VALUE TO OLD LOCATION, 
	MOVEM	E,1(V)		; OVERRIDING PREVIOUS DEF.
	JRST	FREPOPJ

;SYMBOL alfa K -- SUPPRESS SYMBOL
^SYMKIL:PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES
	PUSHJ	P,SYMFND	;FIND ENTRY
	 CAIA			;FOUND	ONE
	 JRST	PU		;NONE
	MOVE	PV,SYMP		;GET POINTER
	MOVSI	D3,400000	;GET KILL FLAG
	IORM	D3,(PV)		;KILL SYMBOL
	TRO	F,DPYALL	;HAVE TO START FROM SCRATCH
	JRST	CSFLUSH

;SYMBOL beta K -- ANNIHILATE IT
^SYMNIL:PUSHJ	P,SYMKIL	;MERELY KILL IT
	MOVE	D3,[RADIX50 50,$UNDEF]
	MOVEM	D3,(PV)		;NO SUCH NAME ANYMORE!
	POPJ	P,

;SUBROUTINE USED BY ABOVE BIG GUYS
SYMFND:	TLNE	F1,USINGF	;DEFINED?
	 POPJ	P,		; NO
SYMFN1:	TLNN	F1,SINGF	;ySINGLE SYMBOL?
	 JRST	CERR		;NO
	TLZ	F,UNDF	
	MOVS	PV,F		;SAVE FLAGS
	PUSHJ	P,SYMLOK	;FIND IN TABLE
	TLZ	F,SCFL		;RESTORE SCFL FLAG...
	ANDI	PV,SCFL		;....
	TSO	F,PV		;...
	TLNE	F,UNDF		;DEFINED?
	AOS	(P)		;YES
	POPJ	P,
>;NOT SORTED

IFN SORTED,<	; Symdef, Symdf1, Symkil -- Create and Delete Symbols

; SYMBOL_VALUE
^SYMDEF:PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES, SO AS NOT TO CONFUSE
	PUSH	P,SYM		;SAVE SYMBOL
	PUSHJ	P,EVAL		;GET VALUE (MIGHT MAKE CACHE ENTRY)
	TLNN	F,VALF		;VALUE?
	 JRST	CERR		;NO
	POP	P,SYM		;RESTORE SYMBOL
	PUSHJ	P,DFQ1		;GO ENTER
	JRST	CSFLUSH		;FLUSH AGAIN SINCE WE MOVED THE SYMBOLS

; SYMBOL:
^SYMDF1:PUSHJ	P,CSFLUSH	;FLUSH ALL CACHES
	TLNN	F,LOCOPF	;LOCATION OPEN?
	 JRST	ZPU		;NO
	MOVE	V,LOCOP		;GET VALUE OF .
DFQ1:	PUSH	P,B		;Save EVAL Ahead-values
	PUSH	P,C
	PUSH	P,PNT
	MOVEM	V,VALUE		;Assume INTERNAL (not prev. def), and 
	MOVE	E,PID		;set up symbol for that -- in that
	LSH	E,5		;case, any PID will do, so use current.
	PUSH	P,E
	PUSHJ	P,SYMFN1	;If the symbol already exists, save its
	 JRST	NTHERE		;type bits and its block ID, then remove
	MOVE	PV,SYMP
	PUSH	P,(PV)		; it from the face of the globe.
	HLRZ	E,1(PV)
	MOVEM	E,-1(P)
	PUSHJ	P,SYMNIL
	POP	P,SYM
NTHERE:	MOVE	PNT,SYMBAS
	MOVE	V,VALUE		;Determine the range of the new value,
	PUSHJ	P,GETRNG	; and under the conditions:
	MOVEM	A,RANGE		;1) The symbol is in range 3 (full word)
	MOVEM	V,VALUE		;2) No free list entries for overflow
	MOVE	M,5(PNT)	;REL PTR TO ONE AFTER LAST FREE
	MOVE	T,4(PNT)	;REL PTR TO FIRST FREE
	HRRZ	PV,(PNT)	;IS THERE A FREE LIST FOR 36 BIT VALUES
	JUMPN	PV,RM		; THERE IS: WORD FOR VAL FROM THERE
	CAIN	A,3		;A HAS THE RANGE
	 ADDI	T,1		;RESERVE FIRST WORD OF FREE FOR 
				;	THE 36 BIT VALUE
	SUBI	M,2		;NEW FIRST SYMBOL
RM:	CAIL	T,(M)
	 JRST	CERR		;MUST LEAVE AT LEAST ONE FREE
	MOVEM	T,4(PNT)	;STORE IN CASE IT WAS INCREMENTED ABOVE
	MOVE	PV,@RNGBAS	;BEGINNING OF RANGE THAT SYM GOES IN
	ADDI	PV,(PNT)
	MOVE	B,@RNGBS1	;BEGINNING OF FOLLOWING RANGE
	ADDI	B,(PNT)
	MOVNI	M,2
	SETCM	E,A		;-NUMBER OF CLASSES THAT ARE MOVING
	MOVEI	T,5(PNT)	;ADDRESS OF RELATIVE POINTER OF CLASS 1
	HRLI	T,(E)
	ADDM	M,(T)		;UPDATE POINTERS 
	AOBJN	T,.-1		; OF ALL CLASSES THAT MOVED
	MOVN	E,[2,,2]
	ADDM	E,SYMRNG
	MOVE	E,SUBRNG(A)	;E GETS 0 IF CLASSES 1-3 , 1 IF CLASS 4
HRDLUP:	CAIGE	PV,(B)
	 XCT	CAMG1(E)
	  JRST	INSTAL
	ADDI	PV,2		;IN EITHER CASE WILL INDICATE THE ENTRY 
	JRST	HRDLUP		; JUST AFTER THE NEW SYMBOL LOCATION

INSTAL:	MOVE	T,5(PNT)	;POINTER TO NEW START OF CLASS 1
	ADDI	T,(PNT)
	MOVEI	M,2(T)		;POINTER TO OLD START OF CLASS 1
	HRLI	T,(M)		;MAKE A BLT POINTER
	BLT	T,-3(PV)
	MOVE	T,SYM		;THE NAME IS EASY -- INCLUDING THE TYPE 
	TLNN	T,740000
	 TLO	T,40000
	MOVEM	T,-2(PV)	; DERIVED ABOVE.
	CAIE	A,3
	 JRST	NBD
	HRRZ	T,(PNT)		;POINTER TO FREE LIST OF 
				;	36 BIT VALUE WORDS
	JUMPE	T,NEWW
	ADDI	T,(PNT)		;MAKE ABSOLUTE
	HRRZ	M,(T)		;RELATIVE POINTER TO NEW HEAD OF FREE
	HRRM	M,(PNT)		;UPDATE POINTER TO FREE LIST
	JRST	HHERE

NEWW:	HRRZ	T,4(PNT)
	ADDI	T,-1(PNT)
HHERE:	MOVEM	V,(T)
	HRRZ	V,T
	SUBI	V,(PNT)		;REL POINTER TO VALUE IN RH OF SYM
	MOVEI	T,PNT		;TURN ON INDEX FIELD 
	IORM	T,(P)		; IN BLOCK POINTER HALF
NBD:	POP	P,E		;The new symbol value word has Block ID 
	HRL	V,E		; info in the left half, value (or ptr)
	MOVEM	V,-1(PV)
	POP	P,PNT
	POP	P,C
	POP	P,B
	JRST	FREPOPJ

;REVIVE, SYMKIL, SYMNIL, ZAPSYM, SYMFND, SYMFN1
;SYMBOL eqiv :
^REVIVE:
	SKIPA	D1,[ANDCAM D3,(PV)]	;REVIVE KILLED SYMBOL
;SYMBOL alfa K
^SYMKIL: MOVE	D1,[IORM D3,(PV)]	;KILL A SYMBOL
	PUSHJ	P,SYMFND		;FIND ENTRY
	 JRST	PU			;NO SUCH ENTRY ANYWAY
	MOVSI	D3,400000		;GET KILL FLAG
	XCT	D1			;KILL SYMBOL
FLSHRT:	TRO	F,DPYALL		;HAVE TO START FROM SCRATCH
	JRST	CSFLUSH

;SYMBOL beta K -- ANNIHILATE IT
^SYMNIL:
	PUSHJ	P,SYMFND	;flush cache, look up the symbol.
	 JRST	PU			;NO SUCH ENTRY ANYWAY
^ZAPSYM:
	MOVE	PNT,SYMBAS
	MOVE	D1,1(PV)		; gets its pointer to PV.
	TLNN	D1,37			;If the deleted symbol has an
	 JRST	NOFLOW			; overflow word,
	HRRZ	T,(PNT)			;Put the overflow word on the
	HRRM	D1,(PNT)		;list of free full words
	ADD	D1,PNT
	HRRZM	T,(D1)			;(was HRROM)
NOFLOW:	MOVE	T,5(PNT)
	ADDI	T,(PNT)		;ABSOLUTE ADDRESS OF FIRST SYMBOL

	CAIL	T,(PV)		;SKIP IF symbol at not at bottom
	 JRST	FRETWO
	MOVEI	E,(T)		;will open up room at bottom of table
	MOVE	A,0(E)		;prepare for shuffle up (back BLT)
	MOVE	B,1(E)		;by getting first pair
SHFTLP:	ADDI	E,2
	EXCH	A,0(E)		;put current pair down,
	EXCH	B,1(E)		;and get the next pair
	CAIGE	E,(PV)		;SKIP IF just over-wrote the symbol
	 JRST	SHFTLP

FRETWO:	SETZM	(T)
	SETZM	1(T)
	MOVEI	T,2
	MOVEI	A,0
	SUBI	PV,(PNT)		;MAKE PV A RELATIVE POINTER
NOFLW3:	CAMGE	PV,@RNGBAS
	 JRST	FLSHRT
	ADDM	T,@RNGBAS		;UPDATE RELATIVE POINTERS 
	AOJA	A,NOFLW3		;TO SYMS 

;SUBROUTINE USED BY ABOVE BIG GUYS
SYMFND:	PUSHJ	P,CSFLUSH		;FLUSH ALL CACHES
	TLNE	F1,USINGF		;DEFINED?
	 JRST	PU			; NO
SYMFN1:	TLNN	F1,SINGF		;SINGLE SYMBOL?
	 JRST	CERR			;NO
	TLZ	F,UNDF	
	MOVS	PV,F			;SAVE FLAGS
	PUSHJ	P,SYMLOK		;FIND IN TABLE
	TLZ	F,SCFL			;RESTORE SCFL FLAG...
	ANDI	PV,SCFL			;....
	TSO	F,PV			;...
	MOVE	PV,SYMP			;GET POINTER
	TLNN	F,UNDF			;DEFINED?
	 AOS	(P)			;YES, succeed
	POPJ	P,
>;SORTED

;$nB, 1 leq n leq Brknum -- Brkins, Brkjsr, Dobrk, Brkpln

COMMENT / THE FORMAT OF THE BREAKPOINT TABLE
     IS AS FOLLOWS:
$1B:	RIGHT HALF IS THE ADDRESS OF THE BREAKPOINT
	LEFT HALF IS ZERO, THIS LOCATION IS -1 IF NOT USED
/
BRKCNT__1	;THIS IS THE MULTIPLE PROCEDE COUNT
BRKSKP__2	;THIS IS THE CONDITIONAL SKIP INSTRUCTION.
		;IF NON-ZERO, RAID WILL EXECUTE THIS INST.
		;WHEN YOU HIT THIS BREAKPOINT AND WILL
		;IGNORE THE BREAKPOINT IF THE INST. SKIPS
BRKSTR__3	;THIS IS THE STRING POINTER.  WHEN YOU HIT THIS 
		;BREAKPOINT, THE STRING POINTED TO GETS EXECUTED AS IF
		;IT WAS BEING TYPED IN [IF THE POINTER IS NON-ZERO]
BRKCON__4	;THE REAL CONTENTS OF THE BREAKPOINT LOCATION 
		;ARE STORED HERE
BRKNUM__20	;MAX NUMBER OF BREAKPOINTS
BLOCNM__5	;NUMBER OF WORDS PER BREAKPOINT IN TABLE

IFN UESW,<
^JOBREL:,,-1
>

IFN DEBSYM!UESW,<
^JOBSYM:0	;DON'T CLOBBER REAL JOBSYM SO WE CAN DEBUG
>

IFE UESW!FILESW,<
$1B:	-1
	BLOCK BLOCNM-1
FOR @@ ZILCH_2,BRKNUM
<IFN REALSW,<$@ZILCH@B:>	-1
	BLOCK BLOCNM-1
>
   	       	     	    
IFN REALSW,<INTERN $1B
FOR @! Z_2,BRKNUM
<INTERN $!Z!B
>>

^BRKINS:0
	SKIPE	BRKSW#		;SKIP IF BREAKPOINTS ARE NOT IN CORE YET
	 JRST	@BRKINS
	SETOM	BRKSW		;INDICATE BREAKPOINTS ARE IN CORE
	MOVEI	M,$1B		;GET POINTER TO TABLE
	MOVEI	D3,BRKNUM
LOP11:	SKIPGE	V,(M)		;USED?
	 JRST	ARN1		;NO
	MOVE	T,[JSR BRKJSR]	;GET THE JSR
	CAIG	V,17		;AC?
	 ADDI	V,JAC		;YES
	EXCH	T,(V)		;DEPOSIT
	MOVEM	T,BRKCON(M)	;SAVE VALUE
ARN1:	ADDI	M,BLOCNM	;GO TO NEXT
	SOJG	D3,LOP11	;LOOP IF NOT DONE
	JRST	@BRKINS

IFN REALSW,< $I:
INTERN $I
>
^BRKJSR:0
	MOVEM	P,RAC+P
	MOVE	P,[-PDLEN,,PDL-1]
	EXCH	P,RAC+P
	JSR	RACGT		;GET THE AC'S
	JSR	ONCE		;TO BE SURE
	SOS	BRKJSR		;POINT TO BREAKPOINT INSTR
^DOBRK:	SETZM	PNTREM
	JSR	BRKPUL		;PULL OUT THE BREAKPOINTS
	SKIPN	M,PNTREM	;GET POINTER TO THIS ONE
	 JRST	HITT		;NO???????
	SKIPN	V,BRKSKP(M)	;GET SKIP INST.
	 JRST	NORMAL	 	;NO SKIP
	MOVEI	T,0		;SKIP-DETECTOR
	JSR	JACGT		;GET USER BACK
	XCT	RAC+V		;EXECUTE IT (RAID SAVED AC)
	 AOS	RAC+T		;SKIPPED NONE
	 AOS	RAC+T		;SKIPPED ONE
				;SKIPPED TWO
	JSR	RACGT		;GET RAID'S ACS BACK (INCL M.)
	JRST	.+1(T)
	 JRST	PROCEE		;SKIPPED TWO
	 JRST	HIT		;SKIPPED ONE
				;SKIPPED ZERO (normal)
NORMAL:	SOSLE	BRKCNT(M)	;CHECK PROCEDE COUNT
	 JRST	PROCEE		;NOT EXHAUSTED
	SETZM	BRKCNT(M)	;EXHAUSTED
HIT:	SKIPN	T,BRKSTR(M)	;IS THERE A STRING POINTER?
	 JRST	HIT1		; NO
	TLNN	T,-1		;DID USER SPECIFY BP PART?
	 HRLI	T,440700	; NO, START AT WORD BEGINNING
HIT1:	MOVEM	T,STRIN		;SET RAID INTERNAL INPUT BP
	MOVE	V,(M)
	TLNE	V,40		;DID WE HIT A TEMPORARY BREAKPOINT????
	SETOM	(M)		;YES, REMOVE IT..
HITT:	SKIPN	V,BRKJSR	;WAS THERE A LOCATION?
	 JRST	NOVALU
	MOVEI	T,.STAR
	HRLM	T,NBIGWD
	PUSHJ	P,OPNQQQ	;OPEN BREAKPOINT LOCATION
	SKIPN	PNTREM		;REAL BPT?
	 TRNE	F,ISOPC		;NO, JOBOPC KLUDGE?
	  JRST	NOVALU		;ONE OF THE ABOVE
	AOS	V,BRKJSR	;IT'S A JSR $I, FIX THE PC
	PUSHJ	P,OPNQQQ	;AND DISPLAY THE PROCEED LOC
	SOS	VALUE
	PUSHJ	P,OPENQ		;NOW SET . BACK TO JSR
NOVALU:
IFN TENEX,<
	MOVEI	A,100
	TRZN	F,ISOPC
	CBIBF
>
IFE TENEX,<
	TRZN	F,ISOPC
	CLRBFI
>
	SKIPE	DDSW		;TEST DEVICE
	 JRST	E1RET		;GO DO RAID
	JRST	ERET		;TTY, NO NEED TO REDRAW

OPNQQQ:	HRRZM	V,VALUE
OPENQQ:	HRRZM	V,STPOP
	MOVE	T,V
	SUB	T,(PNT)
	MOVEI	T,-2(T)
	JUMPN	T,NOSKPT
	SOS	VALUE
	MOVEI	T,0
	MOVEI	F1,4
	PUSHJ	P,OPENQ
	AOS	VALUE
NOSKPT:	SETZB	T,F1
	JRST	OPENQ

^GOGOGO:
	MOVE	V,VALUE		;GET VALUE
	TLNN	F1,VALF		;WAS THERE A VALUE?
	 MOVE	V,JOBSA		;NO, GET JOBSA
	HRRM	V,BRKJSR	;DEPOSIT
GOPRO:	JSR	BRKINS		;INSERT BREAKPOINT
	JSR	JACGT		;GET JOB AC'S
	JRST	2,@BRKJSR	;GO TO JOB

^BRKPLN:
	TLNN	F1,VALF		;VALUE TYPED?
	 JRST	CERR		; NO
	PUSHJ	P,BRKREM
	MOVEI	M,$1B
	MOVEI	T,BRKNUM
BLOP:	SKIPGE	(M)		;EMPTY?
	 JRST	BBFND		;YES
	ADDI	M,BLOCNM	;GO TO NEXT
	SOJG	T,BLOP
	JRST	CERR		;NO ROOM
BBFND:	HRRZ	V,VALUE
	CAIG	V,@JOBREL
	 JRST	BBOK
IFN SEGSW,<
	CAIL	V,400000
	 CAILE	V,@JOBHRL
	  JRST	CERR
	SKIPGE	JOBHRL
	 PUSHJ	P,UNPUR
>
IFE SEGSW,<JRST	CERR>
BBOK:	MOVEM	V,(M)		;STORE
	SETZM	BRKCNT(M)
	SETZM	BRKSTR(M)
	SETZM	BRKSKP(M)
	POPJ	P,

; Brkrem, Brkpul, Tbproc

^BRKREM:
^BKRM:	HRRZ	V,VALUE		;GET VALUE IF ANY
	MOVEI	T,$1B		;GET TABLE POINTER
	MOVEI	M,BRKNUM	;AND COUNT
	TLNN	F1,VALF		;VALUE?
	 JRST	REMALL		;NO, REMOVE ALL BREAKPOINTS
LOOP1:	CAMN	V,(T)		;THIS IT?
	 JRST	BFND		;YES
	ADDI	T,BLOCNM	;NO, GO TO NEXT
	SOJG	M,LOOP1		;LOOP IF NOT DONE
	POPJ	P,
BFND:	SETOM	(T)		;REMOVE IT
	POPJ	P,
REMALL:	SETOM	(T)
	ADDI	T,BLOCNM	;GO TO NEXT
	SOJG	M,REMALL	;LOOP
	POPJ	P,

;REMOVE THE BREAKPOINTS.  PNTREM GETS SET TO THE INDEX OF THE 
;BREAKPOINT WHOSE LOCATION IS NOW IN BRKJSR
^BRKPUL:0
	SKIPN	BRKSW		;SKIP IF BREAKPOINTS HAVE BEEN INSTALLED IN CORE
	 JRST	@BRKPUL
	SETZM	BRKSW		;SAY THAT BREAKPOINTS ARE NO LONGER IN CORE
	MOVEI	M,$1B		;GET POINTER TO TABLE
	MOVEI	D3,BRKNUM
LOP12:	SKIPGE	V,(M)		;GET LOCATION
	 JRST	ARN2		;NOT USED
	MOVE	T,BRKCON(M)	;GET WORD WHICH GOES THERE
	ANDI	V,-1
	CAIN	V,@BRKJSR	;IS THIS THE ONE?
	 MOVEM	M,PNTREM	;YES REMEMBER POINTER
	CAIG	V,17		;AC?
	 ADDI	V,JAC		;YES
	MOVEM	T,(V)		;DEPOSIT
ARN2:	ADDI	M,BLOCNM	;GO TO NEXT
	SOJG	D3,LOP12	;LOOP
	JRST	@BRKPUL

; TBPROC:	PLANT A TEMPORARY BREAKPOINT AT "."  AND PROCEED
^TBPROC:
	HRRZ	E,(PNT)		;GET "."
	MOVEM	E,VALUE		;PRETENT IT...
	TLO	F1,VALF		;...WAS TYPED
	PUSHJ	P,BRKPLN	;PLANT A BREAKPOINT AT "."
	MOVSI	V,40
	ORM	V,(M)		;MAKE IT A TEMPORARY BREAKPOINT
	JRST	PROCEE		;PROCEED..

; Proced, Gpelop, Elop, Pstbrk, Prmbrk, $SBP

^PROCED:
	SKIPN	M,PNTREM	;HAVE A POINTER?
	 JRST	GOPRO		;NO, USER JSR $I'ED, OR JRSTED DDT
	MOVE	V,VALUE		;REPEAT COUNT
	TLNE	F1,VALF		;VALUE TYPED?
	 HRRZM	V,BRKCNT(M)	;YES, DEPOSIT
PROCEE:	PUSHJ	P,STEP		;STEP ONE LOCATION
	JRST	GOPRO		;PROCEDE
PNTREM:	0

STEP:	HRRZ	M,BRKJSR	;GET CURRENT PC
	CAIG	M,17		;AC?
	 ADDI	M,JAC		;YES
	MOVEM	M,BRKJSQ#	;SAVE
STP1:	MOVE	M,@BRKJSQ	;GET THE INST. TO BE DONE
	PUSHJ	P,ECALC		;CALCULATE EF. ADDRS.
	CAMGE	M,[SOS]		;IF INST IS SOS OR GREATER, IT'S SAFE
	 CAMGE	M,[JFFO]	;IF IT IS LESS THAN JFFO, IT'S SAFE
	  JRST	SAFE
	LDB	M,[POINT 9,M,8]	;GET OPCODE
	CAIL	M,321		;IF IT'S JUMPL OR GREATER IT'S JUMP-SKIP
	 JRST	JSKP
	CAIN	M,243		;JFFO?
	 JRST	OJUM		;YES
	CAIGE	M,252		;AOBJNP OR GREATER?
	 JRST	SAFE		;NO
	CAIL	M,270		;IF ADD OR GREATER, SAFE
	 JRST	SAFE
	 JRST	@JUMSTP-252(M)	;DISPATCH ON TYPE OF JUMP

JUMSTP:	OJUM			;AOBJP
	OJUM			;AOBJN
	OJRST			;JRST
	OJUM			;JFCL
	HXCT			;XCT
	SAFE			;?????
	HPSHJ			;PUSHJ
	SAFE			;PUSH
	SAFE			;POP
	HPPJ			;POPJ
	HJSR			;JSR
	HJSP			;JSP
	HJSA			;JSA
	OJUM			;JRA

OJUM:	PUSHJ	P,ECALC		;GET THE EFFECTIVE ADDRS. IN E, 
				;INSTRUCTION IN M
	TLZ	M,37		;CLEAR @ AND X
	HRRI	M,ITJ		;PUT IN OUR OWN ADDRESS
	MOVEM	M,OINST		;STORE INTR.
	JSR	JACGT1		;GET JOB AC'S

OINST:	0			;DO THE INSTR.
	JSR	RACGT1		;GET RAID AC'X
AOSR:	AOS	BRKJSR		;UPDATE PC
	POPJ	P,		;LEAVE

ITJ:	JSR	RACGT1		;GET RAID AC'S
	HRRM	E,BRKJSR	;UPDATE PC
	POPJ	P,

OJRST:	PUSHJ	P,ECALC
	TLNN	M,100		;AC 2 ON?
	 JRST	OJUM+1		;NO
	TLNN	M,20		;@ ON?
	 JRST	OJUM+1		;NO
	TLZ	M,17
	HRRI	M,MSAV
	MOVEM	M,OINST
	MOVE	M,MSAV
	TLZ	M,37
	HRRI	M,ITJ
	MOVEM	M,MSAV
	JRST	OINST-1

SAFE:	MOVE	M,@BRKJSQ	;GET INST.
	SETZM	BRCNT#
	LDB	T,[POINT 9,M,8]	;GET OPCODE
	CAIN	T,41		;INIT?
	JRST	INITI		;YES
	CAIGE	T,100
	JRST	ITSUUO
SF1:	JSR	JACGT1		;GET JOB AC
	XCT	@BRKJSR		;EXECUTE THE INST
	 AOS	BRCNT
	 AOS	BRCNT
	 AOS	BRCNT
INRET:	JSR	RACGT1		;GET RAID AC'S
	MOVEI	T,4		;UPDATE PC
	ADD	T,BRKJSR	
;...
	SUB	T,BRCNT
	HRRM	T,BRKJSR
	POPJ	P,

INITI:	MOVS	M,BRKJSQ
	HRRI	M,INTQ
	BLT	M,INTQ+2	;GET THE INIT
	JSR	JACGT1		;GET JOB AC
INTQ:	BLOCK 3

	AOS	BRCNT
	JRST	INRET
ITSUUO:	CAIGE	T,40
	 JRST	ITSU40
	PUSH	P,M		;SAVE INSTRUCTION
	JSR	BRKINS
	POP	P,@BRKJSQ	;RESTORE INSTRUCTION IN CASE OF BRKPOINT
	PUSHJ	P,SF1
	JSR	BRKPUL
	POPJ	P,
ITSU40:	JUMPE	T,SF1
	HRR	M,E
	TLZ	M,37
	MOVEM	M,40
	MOVEI	E,41
	MOVEM	E,BRKJSQ
	JRST	STP1

RACGT1:	0
	JSR	RACGT		;GET RAID AC'S
	HLL	T,RACGT1	;GET JOB FLAGS
	HLLM	T,BRKJSR	;DEPOSIT
	JRST	@RACGT1

JACGT1:	0
	MOVE	T,BRKJSR	;GET JOB FLAGS
	HLLM	T,JACGT1	;DEPOSIT
	JSR	JACGT		;GET JOB AC'S
	JRST	2,@JACGT1	;RETURN & RESTORE JOB FLAGS

ECALC:	SKIPA	M,@BRKJSQ	;GET INST
^GPELOP: SETZM	BRKJSQ
>;END OF IFE UESW!FILESW

^ELOP:
IFN UESW!FILESW,<
^GPELOP:PUSH	P,M
>
ELOOPP:	HRRZ	E,M		;GET ADDRESS FIELD
	LDB	T,[POINT 4,M,17]	;GET IX FIELD
	JUMPE	T,.+3		;ANY IX?
 	 ADD	E,JAC(T)	;YES, ADD IN
	 HRRZS	E
	TLNN	M,20		;@?
	 JRST	EDON		;NO
	JSR	ECHK
	MOVE	M,(E)		;GET WORD
	JRST	ELOOPP
EDON:
IFE UESW!FILESW,<
	MOVEM	M,MSAV
	MOVE	M,@BRKJSQ ;ELSE > POP P,M
	POPJ	P,

IFN REALSW,<
$SBP:
INTERN $SBP
>;REALSW
IFE UESW!FILESW,<
; USER CALLS JSR AC,$SBP TO SET BREAKPOINT AT LOCATION NAMED IN AC
^PSTBRK:0
	JSR	RACGT		;GET RAID ACS
	JSR	ONCE		;SET UP FOR RAID IF FIRST EXPOSURE
	JSR	BRKPUL		;PULL, BECAUSE THEY'RE GOING TO CHANGE
	TLO	F1,VALF		;SIMULATE SUCCESSFUL VALUE SCAN
	HRRZ	V,PSTBRK	;RETURN ADDR
	LDB	V,[POINT 4,-1(V),12]	;AC FIELD OF `JSR AC,$SBP'
	HRRZ	V,JAC(V)	;USER'S VERSION OF THIS AC
	MOVEM	V,VALUE		;FINISH SIMULATION
	PUSHJ	P,BRKPLN	;PLANT THE BREAKPOINT
	JSR	BRKINS		;INSERT BREAKPOINTS
	JSR	JACGT		;GET JOB'S ACS BACK
	JRST	2,@PSTBRK	;RETURN TO SENDER
IFN REALSW,<
$RBP:
INTERN $RBP
>;REALSW
^PRMBRK:0
	JSR	RACGT		;PRETTY MUCH A REPEAT
	JSR	ONCE		;SET UP FOR RAID IF FIRST EXPOSURE
	JSR	BRKPUL		;PULL, BECAUSE THEY'RE GOING TO CHANGE
	TLO	F1,VALF		;SIMULATE SUCCESSFUL VALUE SCAN
	HRRZ	V,PRMBRK	;RETURN ADDR
	LDB	V,[POINT 4,-1(V),12]	;AC FIELD OF `JSR AC,$RBP'
	HRRZ	V,JAC(V)	;USER'S VERSION OF THIS AC
	MOVEM	V,VALUE		;FINISH SIMULATION
	PUSHJ	P,BKRM		;REMOVE THE BREAKPOINT
	JSR	BRKINS		;INSERT BREAKPOINTS
	JSR	JACGT		;GET JOB'S ACS BACK
	JRST	2,@PRMBRK	;RETURN TO SENDER

; Steppe, Stepp, Xeq1, Xeq2

MSAV:	0
JSKP:	TRNE	M,10		;JUMP OR SKIP?
	 JRST	SAFE		;SKIP, SAFE
	JRST	OJUM		;JUMP, HANDLE
HJSR:	PUSHJ	P,ECALC		;GET DFFECTIVE ADDRESS IN E, INST IN M
	AOS	T,BRKJSR	;GET THE PC WORD
	CAILE	E,17		;AC?
	 SKIPA	V,E		;NO
	 MOVEI	V,JAC(E)	;YES
	MOVEM	T,(V)		;DEPOSIT PC WORD
	AOJA	E,JSRET
HJSP:	PUSHJ	P,ECALC		;GET EF AD IN E
	AOS	T,BRKJSR	;GET THE PC
	LDB	V,[POINT 4,M,12];GET AC FIELD
	MOVEM	T,JAC(V)	;DEPOSIT PC IN THE AC
JSRET:	HLL	E,BRKJSR 	;GET FLAGS
	TLZ	E,20000		;CLEAR THE BIS FLAG
JSAET:	MOVEM	E,BRKJSR	;DEPOSIT NEW PC
	POPJ	P,
HJSA:	PUSHJ	P,ECALC		;GET DF AD
	AOS	T,BRKJSR	;GET THE PC
	LDB	V,[POINT 4,M,12];GET AC FIELD
	MOVE	PV,JAC(V)	;GET AC
	CAILE	E,17		;IS E AN AC?
	 SKIPA	D3,E		;NO
	 MOVEI	D3,JAC(E)	;YES
	HRL	T,E		;PUT E IN LEFT OF PC WORD
	MOVEM	T,JAC(V)	;DEPOSIT PC IN AC
	MOVEM	PV,(D3)		;DEPOSIT AC IN E
	HLL	E,BRKJSR	;GET FLAGS
	AOJA	E,JSAET
HPSHJ:	PUSHJ	P,ECALC		;GET ADDRS
	AOS	T,BRKJSR	;GET THE PC
	MOVEM	T,OINST		;STORE
	LDB	T,[POINT 4,M,12]	;GET AC
	DPB	T,[POINT 4,HP1,12]	;DEPOSIT
	JSR	JACGT1		;GET JOB AC
HP1:	PUSH	P,OINST		;PUSH THE PC
	JSR	RACGT1		;GET RAID AC
	JRST	JSRET
HPPJ:	MOVE	M,@BRKJSQ	;GET INST
	LDB	T,[POINT 4,M,12]	;GET AC FIELD
	DPB	T,[POINT 4,HP2,12]	;DEPOSIT
	JSR	JACGT1		;GET JOB AC
HP2:	POP	P,OINST		;GET THE RETURN ADDRS
	JSR	RACGT1		;GET RAID AC
	MOVE	E,OINST		;GET THE NEW PC
	HRRM	E,BRKJSR	;STORE
	POPJ	P,
HXCT:	PUSHJ	P,ECALC		;GET EF AD
	CAIG	E,17		;AC?
	 ADDI	E,JAC		;YES
	MOVEM	E,BRKJSQ	;DEPOSIT
	JRST	STP1		;DO THAT ONE

^STEPP:	MOVE	M,LOCOP
	TLNN	F,LOCOPF
	 JRST	CERR
	HRRM	M,BRKJSR
^STEPPE:PUSHJ	P,STEP		;DO IT
	MOVE	V,BRKJSR	;GET PC
	HRRZM	V,VALUE		;DISPLAY IT
	JRST	OPENQQ

XQINST:	LDB	T,[POINT 9,M,8]	;GET OPCODE
	CAILE	T,37		;UUO?
	CAIN	T,260		;or PUSHJ?
	 AOS	(P)		;YES
	CAIL	T,264		;JSR,JSP, or JSA
	 CAILE	T,266
	  POPJ	P,		;Nope, return
	AOS	(P)		;YES
	POPJ	P,		;NO

^XEQ2:	MOVE	M,LOCOP
	TLNN	F,LOCOPF
	 JRST	CERR
	HRRM	M,BRKJSR
^XEQ1:	HRRZ	M,BRKJSR	;GET PC
	CAIG	M,17		;AC?
	 ADDI	M,JAC		;YES
	MOVEM	M,BRKJSQ
	MOVE	M,(M)		;GET INST
	PUSHJ	P,XQINST	;SUBR. CALL INST?
	 JRST	STEPPE		;NO, STEP
NOSTPP:	MOVEM	M,NONST		;STORE INST
	PUSHJ	P,NOSTP		;DO IT
	MOVE	V,BRKJSR
	HRRZM	V,VALUE
	PUSHJ	P,OPENQQ
	JRST	ERET

; Xeq3, Yxeq, Mstep

^XEQ3:	TLNN	F1,VALF		;VALUE TYPED?
	 JRST	CERR		;NO
	MOVE	M,VALUE		;GET INST
	MOVEM	M,NONST
	PUSHJ	P,XQINST	;SUBR. CALL INST?
	 SKIPA			;NO
	 JRST	YES1		;YES
	PUSH	P,BRKJSR	;SAVE PC
	MOVEI	T,NONST 	;SET UP TEMP PC
	HRRM	T,BRKJSR
	PUSHJ	P,STEP		;DO THE INST
	HRRZ	M,BRKJSR
	SUBI	M,NONST
	PUSHJ	P,SKPSET
	POP	P,M		;RESTORE PC
	HRRM	M,BRKJSR
	POPJ	P,

YES1:	MOVE	T,XQPNT		;GET TABLE POINTER
	PUSH	T,BRKJSR	;SAVE PC
	MOVEM	T,XQPNT		;SAVE OVER BRKINS
	PUSHJ	P,NOSTP		;GO GET BRKPNTS, DO
	HRRZ	M,BRKJSR
	SUBI	M,@(T)
	PUSHJ	P,SKPSET
	POP	T,M
	MOVEM	T,XQPNT		;RESTORE TABLE POINTER
	HRRM	M,BRKJSR	;RESTORE PC
	JRST	ERET

SNUM__10	;number of SKIPS to check out
NOSTP:	JSR	BRKINS		;INSERT BREAKPOINTS
	MOVE	T,XQPNT		;GET TABLE POINTER
NOST:	PUSH	T,BRKJSX#	;SAVE OLD PC
	PUSH	T,BRKJSR	;SAVE OLD USER PC TOO
	POP	P,M		;GET RETURN ADDRS
	HRLM	M,-1(T)		;SAVE
	MOVEM	T,XQPNT		;STORE POINTER
	MOVEI	M,SNUM
	MOVEM	M,BRKJSX
	JSR	JACGT1		;GET JOB AC

NONST:	0			;DO INST
	REPEAT SNUM,<SOS BRKJSX>
	JSR	RACGT1		;GET RAID AC
	JSR	BRKPUL		;REMOV BRK PNTS
	MOVE	M,NONST		;GET INST.
	LDB	E,[POINT 4,M,12]	;GET AC FIELD
	PUSHJ	P,ELOP		;CALC EF. ADDRS.
	MOVE	T,XQPNT
	POP	T,BRKJSR
	AOS	M,BRKJSX
	ADDM	M,BRKJSR
	POP	T,M
	MOVEM	T,XQPNT
	HRRM	M,BRKJSX
	MOVSS	M
	JRST	(M)

XQTBLN__20
XQTB:	BLOCK XQTBLN
XQPNT:	-XQTBLN,,XQTB-1
^MSTSW1:0
^MSTSW2:0

^LEAVE:	MOVE	M,[EXIT]
	MOVEM	M,VALUE
	TLO	F1,VALF
^YXEQ:	TLNN	F1,VALF
	 JRST	CERR
	MOVE	M,VALUE		;GET INST TO BE EXECUTED
	MOVEM	M,YXINST	;DEPOSIT
	PUSHJ	P,XQINST	;IS IT SUBR CALL?
	 CAIA	
	 JRST	XEQ3		;YES
	MOVEI	T,2
	MOVEM	T,YXCNT
	JSR	BRKINS	;PLANT BREAKPOINTS
	JSR	JACGT1	;GET JOB AC'S
YXINST:	0
	SOS	YXCNT
	SOS	YXCNT
	JSR	RACGT1
	JSR	BRKPUL
	SKIPE	M,YXCNT
	 PUSHJ	P,SKPST1
	JRST	ERET

YXCNT:	0

SKPSET:	SOJLE	M,CPOPJ
SKPST1:	MOVEM	M,SKPVAL
	TLO	F,PMULFL!PUFL
	HRRI	M,.SKIP
	HRLM	M,NBIGWD
	POPJ	P,
^MSTEP:	TLNN	F1,VALF		;IF THERE WAS A REPEAT FACTOR,
	 JRST	MSTEP2
	MOVE	M,VALUE		;USE IT AS NUMBER TO EXECUTE 
	MOVEM	M,RPTCNT	;BEFORE DISPLAYING
	JRST	MSTEP2

STPQ:	TRNE	B,1
	AOS	MSTSW1
STP:	PUSHJ	P,STEPPE	;STEP INST
MSTEP1:	SOSGE	RPTCNT
	 PUSHJ	P,REDISP	;DRAW INTERMEDIATE RESULTS
MSTEP2:	HRRZ	M,BRKJSR	;GET PC
	MOVE	V,M
	MOVEM	M,VALUE
	CAIG	M,17		;AC?
	 ADDI	M,JAC		;YES
	MOVEM	M,BRKJSQ	;DEPOSIT
	MOVE	M,(M)		;GET INST
	MOVEM	M,NONST		;DEPOSIT
	PUSHJ	P,XQINST	;SUBR. CALL INST?
	 JRST	STPNOS		;NO
	SKIPN	MSTSW1		;ANY SWITCH SETTING FOR THIS?
	 JRST	STPYES		;NO
	PUSHJ	P,OPENQQ	;YES, OPEN IT
	SKIPL	MSTSW1		;WHICH WAY
	 JRST	STP		;STEP
	JRST	STPX		;XEQ

STPNOS:	CAIE	T,263	;POPJ?
	 CAIN	T,267	;JRA?
	  JRST	STPJ	;YES
	CAIN	T,254	;JRST @?
	 TLNN	M,20
	  JRST	STPNO	;NO
STPJ:	SKIPN	MSTSW2	;CHECK SWITCH
STPYES:	 TLO	F,STARSW	;YES, TURN ON STAR
STPNO:	PUSHJ	P,OPENQQ	;OPEN PC LOCATION
	TLZN	F,STARSW	;WAS IT SUBR CALL?
	 JRST	STPQQ		;NO
	MOVEI	M,.STAR
	HRLM	M,NBIGWD
	PUSH	P,TYII		;SAVE CURRENT INPUT INSTR
IFN TENEX,<
	PUSH	P,BIN1 ;> PUSH P,[INCHRW C]
	POP	P,TYII		;DDTIN MODE
	PUSHJ	P,REDISP	;DRAW CHANGE, STAR
	PUSHJ	P,GCHRS		;YES, GET A CHR.
	PUSH	P,B
	PUSH	P,C
	PUSHJ	P,REDISP	;TURN OFF THE STAR
	POP	P,C
	POP	P,B
	POP	P,TYII		;RESTORE PREV INSTR

	TRNE	B,2		;CTL2?
	 SETOM	MSTSW2		;YES
	TRNE	B,1		;CTL1?
	 SETZM	MSTSW1		;YES
	CAIN	C,"S"		;IS IT S?
	 JRST	STPQ		;YES, STEP
	CAIE	C,"X"		;IS IT X?
	 JRST	ERET		;NEITHER, LEAVE
	TRNE	B,1
	 SETOM	MSTSW1
	MOVE	M,@BRKJSQ
	PUSHJ	P,XQINST	;IS IT SUBR TYPE?
	 JRST	STP		;NO
STPX:	PUSHJ	P,NOSTP		;YES, EXECUTE THE INST
	JRST	MSTEP1		;LOOP

STPQQ:	INCHRS		;IS THERE A CHR?
	 JRST	STP	;NO
	JRST	ERET	; AND LEAVE
>;UESW!FILESW
BEND ROUTS

D wå