BSAIL ENTRY CNVDATE,CNVDTIM;
BEGIN "SLBCVD"
INTEGER JFYSEC;
OWN INTEGER ARRAY CNV[0:2];
REQUIRE "(SAILIB)TYMGET.DEF" SOURCE!FILE;
REQUIRE "(SAILIB)TYMCAL.DEF" SOURCE!FILE;
SIMPLE PROCEDURE SETJFC;
JFYSEC_CALL(GETTAB!JFYSEC,"GETTAB");

REQUIRE SETJFC INITIALIZATION;

INTERNAL SIMPLE INTEGER PROCEDURE CNVDATE(INTEGER DATE,FROM,TO);
BEGIN CNV[0]_DATE; CNV[2]_FROM LSH 18+TO;
CNV[1]_(1200*60)*JFYSEC; CALLI (LOCATION(CNV[0]),CALLI!DATUUO);
RETURN(CNV[0]) END "CNVDATE";

INTERNAL SIMPLE PROCEDURE CNVDTIM(REFERENCE INTEGER
	DATE,TIME; INTEGER FROM,TO);
BEGIN
CNV[0]_DATE; CNV[2]_FROM LSH 18+TO; CNV[1]_TIME*JFYSEC;
CALLI(LOCATION(CNV[0]),CALLI!DATUUO);
DATE_CNV[0]; TIME_CNV[1]%JFYSEC END "CNVDTIM";
END "SLBCVD"

BSAIL ENTRY INIUFR,NXTUFR;
BEGIN "SLBUFD"
REQUIRE "(SAILIB)TYMIO.DEF" SOURCE!FILE;
REQUIRE "<><>" DELIMITERS;
DEFINE BIT(A,B)=<(A LSH (35-B))>;
EXTERNAL SIMPLE PROCEDURE GENARY(INTEGER ARRAY ARGS; INTEGER LOC);
EXTERNAL BOOLEAN !SKIP!; INTEGER ARRAY ARGS[1:3];

RECORD!CLASS UFDREC(INTEGER CHAN,POINTR,NUMENT;
	INTEGER ARRAY HEAD,DATA);
RECORD!POINTER (UFDREC) RP;
INTERNAL SIMPLE RECORD!POINTER (UFDREC) PROCEDURE INIUFR(
	STRING NAME,EXTENSION; INTEGER CHANNEL,BITS(0),SIZE(102));
BEGIN

RP_NEW!RECORD(UFDREC);
UFDREC:CHAN[RP]_CHANNEL;
ARGS[1]_1;ARGS[2]_0;ARGS[3]_7;
GENARY(ARGS,LOCATION(UFDREC:HEAD[RP]));
SIZE_(SIZE MAX 1) MIN 102;
UFDREC:HEAD[RP][1]_CVSIX(NAME);
UFDREC:HEAD[RP][2]_CVSIX(EXTENSION);
UFDREC:HEAD[RP][4]_UFDREC:HEAD[RP][5]_UFDREC:HEAD[RP][6]_
	UFDREC:HEAD[RP][7]_UFDREC:HEAD[RP][3]_0;
IF BITS LAND 1 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_BIT(1,2);
	UFDREC:NUMENT[RP]_1 END;
IF BITS LAND 2 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,3);
	UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+1 END;
IF BITS LAND 4 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,4);
	UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+1 END;
IF BITS LAND 8 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,1);
	UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+1 END;
IF BITS LAND 16 NEQ 0 THEN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,0);
IF BITS LAND 32 NEQ 0 THEN UFDREC:HEAD[RP][3]_UFDREC:HEAD[RP][3]
  LOR BIT(('200+((BITS LSH -6) LAND '177)),17);
ARGS[3]_(UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+2)*SIZE-1;
GENARY(ARGS,LOCATION(UFDREC:DATA[RP]));
UFDREC:HEAD[RP][0]_(-ARGS[3]-1) LSH 18
	+POINT(0,UFDREC:DATA[RP][0],35);
USETI(CHANNEL,1);
RETURN(RP) END "INIUFR";

INTERNAL SIMPLE BOOLEAN PROCEDURE NXTUFR(INTEGER ARRAY OUTDT;
	RECORD!POINTER (UFDREC) RPA);
BEGIN
 WHILE UFDREC:HEAD[RPA][7]=0 DO BEGIN
   CHNIOR(UFDREC:CHAN[RPA],UFDREC:HEAD[RPA][0],CIO!UFD);
   UFDREC:POINTR[RPA]_0;
   IF NOT !SKIP! THEN RETURN(FALSE) END;
 ARRBLT(OUTDT[0],UFDREC:DATA[RPA][UFDREC:POINTR[RPA]],
	UFDREC:NUMENT[RPA]);
 UFDREC:POINTR[RPA]_UFDREC:POINTR[RPA]+UFDREC:NUMENT[RPA];
 UFDREC:HEAD[RPA][7]_UFDREC:HEAD[RPA][7]-1;
RETURN (TRUE) END "NXTUFR";
END "SLBUFD"

BSAIL ENTRY GENARY;
BEGIN "GENARY"

COMMENT THE ROUTINE GENARY IS DESIGNED TO GENERATE ARRAYS
	TO BE STORED INTO RECORDS. THESE ARRAYS WILL BE
	PROPERLY GARBAGE COLLEDTED WHEN THE RECORDS ARE DELETED.
	GENARY TAKES TWO ARGUMENTS. THE FIRST IS AN INTEGER ARRAY
	OF ONE DIMENSION. THE RANGE OF INDICES MAY BE
	ANYTHING DESIRED. THE FIRST VALUE IS THE NUMBER
	OF DIMENTIONS DESIRED. THE SECOND IS THE LOWER BOUND
	FOR THE FIRST DIMENTSION, THEN THE UPPER BOUND FOR
	THE FIRST DIMENTION, THEN THE LOWER FOR THE SECOND
	DIMENSION, ETC.
	THE SECOND ARGUMENT TO GENARY IS THE ADDRESS OF THE
	ARRAY ARGUMENT IN THE RECORD.
	IF RP IS THE RECORD POINTER, RC THE RECORD CLASS,
	AND RA THE ARRAY FIELD IN THE RECORD, THEN USE
		LOCATION(RC:RA[RP])
	FOR THE SECOND ARGUMENT;

INTERNAL SIMPLE PROCEDURE GENARY(INTEGER ARRAY ARGS;INTEGER LOC);
BEGIN INTEGER FSTEL,NUMDIM,AG,I; LABEL LOOP;
EXTERNAL INTEGER PROCEDURE LRMAK;
DEFINE P='17;

AG_LOCATION(ARGS[(FSTEL_ARRINFO(ARGS,1))+1]);
I_ARGS[FSTEL+((NUMDIM_ARGS[FSTEL]) LAND '777777)*2];
START!CODE MOVE 1,AG; HRRZ 2,NUMDIM; LOOP: PUSH P,(1);
   PUSH P,1(1); ADDI 1,2;
  SOJG 2,LOOP; PUSH P,NUMDIM; PUSHJ P,LRMAK; MOVE 2,LOC;
  MOVEM 1,(2) END;
END
END "GENARY"
BSAIL ENTRY LOKDUL;
BEGIN "LOKDUL"
INTEGER DULCHL,DULEOF,DULBLK;
INTEGER ARRAY DULARY[0:127];
DEFINE DULHSH=101;

SIMPLE PROCEDURE INIDUL; DULCHL_DULBLK_-1;
REQUIRE INIDUL INITIALIZATION;

INTERNAL SIMPLE STRING PROCEDURE LOKDUL(INTEGER PPN);

COMMENT READS DUL TO FIND CORRESPONDENCE TO PPN;

BEGIN INTEGER I; STRING ST;
SIMPLE STRING PROCEDURE BRKPPN(INTEGER PPN);
RETURN ("["&CVOS(PPN LSH -18)&","&CVOS(PPN LAND '777777)&"]");

IF DULCHL<0 THEN OPEN(DULCHL_GETCHAN,"DSK",'16,0,0,DULEOF,DULEOF,DULEOF);
IF DULBLK<0 THEN LOOKUP(DULCHL,"DUL.SYS[1,4]",DULEOF);
COMMENT ORIGINALLY DULEOF AND DULCHL ARE SET -1, FORCES 
	CONTINUED LOOKUPS IF DUL WAS NOT FOUND BEFORE;
IF DULEOF NEQ 0 THEN RETURN (BRKPPN(PPN));
USETI (DULCHL,I_PPN MOD DULHSH+1);
WHILE TRUE DO BEGIN "ARRSRC"
   IF I NEQ DULBLK THEN ARRYIN(DULCHL,DULARY[0],128);
   DULBLK_I;
   FOR I_0 STEP 3 UNTIL 127 DO
	IF DULARY[I]=PPN THEN DONE "ARRSRC" ELSE IF
	DULARY[I]=0 THEN RETURN (BRKPPN(PPN)) ELSE IF
	DULARY[I]<0 THEN DONE;
   USETI(DULCHL,I_DULARY[I] LAND '777777+1) END "ARRSRC";
COMMENT NEGATIVE IS THE LINK CONVENTION;

ST_CVXSTR(DULARY[I+1])&CVXSTR(DULARY[I+2]);
WHILE ST[INF FOR 1]=" " DO ST_ST[1 FOR INF-1];
COMMENT REMOVE TRAILING BLANKS;
RETURN("("&ST&")") END;

END "LOKDUL"

BSAIL ENTRY RDDATE,STDATE;
BEGIN "SLBDAT"
PRELOAD!WITH "JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE",
	"JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER",
	"DECEMBER";
OWN STRING ARRAY MONTHS[1:12];
SIMPLE INTERNAL BOOLEAN PROCEDURE RDDATE(REFERENCE INTEGER DATE,
	OVSCAN; VALUE INTEGER FSTSCN; REFERENCE STRING STR);
BEGIN

COMMENT THIS PROCEDURE READS THE DATE FROM THE STRING PASSED.
	IT USES SCANU AND STRSRC. IT ASSUMES THAT SCANU
	HAS BEEN CALLED BEFORE IT AND THE VALUE RETURNED BY
	SCANU IS PASSED IN FSTSCN. IT CALLS SCANU ONE EXTR TIME
	AND RETURNS THE VALUE IN OVSCAN. THE DATE IS RETURNED
	IN DATE IN THE STANDARD DEC DATE FORMAT

		((YR-64)*12+MONTH-1)*31+DAY-1
	IT ACCEPTS DATES IN THE FOLLOWING FORMATS
		MM-DD-YY
		DD-MONTH-YY
		MONTH DD,YY
	DD IS THE DAY (AS A NUMBER) MM THE MONTH (AS A NUMBER)
	MONTH THE NAME FOR THE MONTH (OR A SHORTENED VERSION AS
	SEP FOR SEPTEMBER). THE - MAY BE OMITTED OR REPLACED
	BY A /. THE YEAR (YY) MAY BE EITHER A 2 DIGIT YEAR AS 76
	OR A 4 DIGIT YEAR AS 1976;

EXTERNAL SIMPLE BOOLEAN PROCEDURE SCANSS(BOOLEAN B);
EXTERNAL SIMPLE BOOLEAN PROCEDURE SCANSN(BOOLEAN B);
EXTERNAL SIMPLE INTEGER PROCEDURE SCANU(REFERENCE STRING STR);
EXTERNAL INTEGER SCNVAL;
EXTERNAL STRING ACCUM;
EXTERNAL SIMPLE INTEGER PROCEDURE STRSRC(STRING ARRAY NAMES;
	STRING LOOK; BOOLEAN EXACT);
INTEGER MON,DAY,YR;
BOOLEAN BOOL,BOOL2,BOOL3;
PRELOAD!WITH 31,29,31,30,31,30,31,31,30,31,30,31;
OWN INTEGER ARRAY MONDYS[1:12];

SIMPLE BOOLEAN PROCEDURE RSTSCN;
BEGIN SCANSN(BOOL3); RETURN(SCANSS(BOOL2)) END "RSTSCN";

SIMPLE INTEGER PROCEDURE DSHSCN(REFERENCE STRING STR);
BEGIN INTEGER I;
IF (I_SCANU(STR))=3 THEN IF NOT "-" NEQ SCNVAL NEQ "/" THEN
   RETURN(SCANU(STR)) ELSE RETURN(0) ELSE RETURN(I)
END "DSHSCN";

BOOL2_SCANSS(FALSE); BOOL3_SCANSN(FALSE);
CASE FSTSCN MIN 3 OF BEGIN
[0][3] RETURN(RSTSCN);
 COMMENT WE KNOW RSTSCN WILL RETURN FALSE AT THIS POINT;
[1] IF (MON_STRSRC(MONTHS,ACCUM,BOOL))=0 OR SCANU(STR) NEQ 2
   OR NOT(MONDYS[MON] GEQ (DAY_SCNVAL)>0) OR SCANU(STR) NEQ 3 OR
   SCNVAL NEQ "," OR SCANU(STR) NEQ 2
    THEN RETURN(RSTSCN);
[2] BEGIN DAY_SCNVAL;
   CASE DSHSCN(STR) OF BEGIN
   [0][3] RETURN (RSTSCN);
   [2] IF NOT(12 GEQ (MON_DAY)>0) OR
	NOT(MONDYS[MON] GEQ (DAY_SCNVAL)>0) OR
	DSHSCN(STR) NEQ 2 THEN RETURN(RSTSCN);
   [1] IF (MON_STRSRC(MONTHS,ACCUM,BOOL))=0 OR NOT(MONDYS[MON]
	GEQ DAY>0) OR DSHSCN(STR) NEQ 2
	THEN RETURN(RSTSCN)
   END
  END
END;
IF NOT(44 GEQ (YR_IF SCNVAL>100 THEN SCNVAL-1964 ELSE SCNVAL-64)
   GEQ 0) THEN RETURN(RSTSCN);
RSTSCN;
OVSCAN_SCANU(STR); DATE_(YR*12+MON-1)*31+DAY-1;
RETURN (TRUE) END "RDDATE";



SIMPLE INTERNAL STRING PROCEDURE STDATE(INTEGER DATE,FLAG);
BEGIN

COMMENT THIS PROCEDURE TAKES AN INTEGER DATE IN DEC DATE FORMAT
	AND GENERATES A STRING FROM IT. THE INTEGER FLAG CONTROLS
	THE FORMATTING FOR THE STRING RETURNED AS FOLLOWS:

	BITS 33-35 (FLAG LAND '7) IS THE GENERAL FORMAT
	 (DD INDICATES DAY AS A NUMBER MM MONTH AS A NUMBER
	  MON MONTH AS TEXT AND YY YEAR AS A NUMBER (2 OR 4 DIGITS)
	 0 MM-DD-YY
	 1 DD-MON-YY
	 2 DD-MM-YY
	 3 MON DD,YY
	 UNASSIGNED FORMATS ARE THE SAME AS 1.
	BITS 29-32 (FLAG LSH -3 LAND '17) ARE THE SIZE
	 OF THE MON STRING (0 IS FULL WIDTH) THIS IS THE MAX
	 WIDTH.
	BIT 28 (FLAG LAND '200) INDICATES THAT THE YEAR IS
	 4 DIGITS NOT 2
	BITS 26-27 (FLAG LSH -8 LAND '3) GIVE A CHR TO REPLACE
	 THE - IN FORMATS 0,1, AND 2: 0 IS - 1 IS / 2 IS BLANK
	 3 IS UNDEFINED (BLANK);

INTEGER DAY,MON,YR,I,J; STRING DAYS,MONS,YRS,SMON,ST;
DAY_DATE MOD 31+1; MON_(DATE DIV 31) MOD 12+1;
YR_DATE DIV (31*12)+64;
IF FLAG LAND '200 NEQ 0 THEN YR_YR+1900;
GETFORMAT(I,J); SETFORMAT(0,0);
DAYS_CVS(DAY); MONS_CVS(MON); YRS_CVS(YR); SETFORMAT(I,J);
ST_CASE (FLAG LSH -8) LAND '3 OF ("-","/"," "," ");
SMON_MONTHS[MON];
IF (I_(FLAG LSH -3) LAND '17) NEQ 0 THEN SMON_SMON[1 FOR I];
CASE FLAG LAND '7 OF BEGIN
   [0] RETURN (MONS&ST&DAYS&ST&YRS);
   [1][4][5][6][7] RETURN (DAYS&ST&SMON&ST&YRS);
   [2] RETURN (DAYS&ST&MONS&YRS);
   [3] RETURN (SMON&" "&DAYS&","&YRS) END
END "STDATE";
END "SLBDAT"

BSAIL ENTRY RDTIME;
BEGIN "RDTIME"
INTERNAL SIMPLE BOOLEAN PROCEDURE RDTIME(REFERENCE INTEGER TIME
	,OVSCAN; VALUE INTEGER FSTSCN; REFERENCE STRING STR);
BEGIN

COMMENT THIS PROCEDURE READS THE TIME FROM THE STRING PASSED.
	IT USES SCANU AND ASSUMES THAT SCANU HAS BEEN CALLED
	BEFORE IT. THE VALUE RETURNED BY SCANU IS IN FSTSCN.
	THE TIME FORMATS ACCEPTED ARE HHMM OR HH:MM. THE TIME
	RETURNED IN TIME IS IN MIN SINCE MIDNIGHT. OVSCAN IS
	SET TO THE OUTPUT OF SCANU FOR THE NEXT ELEMNT OF THE
	LINE;

EXTERNAL SIMPLE INTEGER PROCEDURE SCANU(REFERENCE STRING STR);
EXTERNAL INTEGER SCNVAL;
INTEGER HR,MIN;

IF FSTSCN NEQ 2 THEN RETURN(FALSE);
HR_SCNVAL;
IF NOT ( (OVSCAN_SCANU(STR))=3 AND SCNVAL=":") THEN BEGIN
   IF NOT(2400 GEQ SCNVAL GEQ 0) OR (MIN_HR MOD 100)>59
   THEN RETURN(FALSE);
   TIME_(HR DIV 100)*60+MIN; RETURN(TRUE) END;
IF SCANU(STR) NEQ 2 OR NOT(60>SCNVAL GEQ 0) OR NOT(24*60 GEQ
	(TIME_HR*60+SCNVAL) GEQ 0) THEN RETURN(FALSE);
OVSCAN_SCANU(STR); RETURN (TRUE)
END;
END "RDTIME"

BSAIL ENTRY SCANU,SCANSS,SCANSN;
BEGIN "SLBSCN"
INTEGER BRK!BLNK,BRK!ID;
BOOLEAN SCANTYPE,SCANSIGN;
SIMPLE PROCEDURE INISCN;
BEGIN BRK!BLNK_GETBREAK; BRK!ID_GETBREAK;
  SCANSIGN_TRUE; SCANTYPE_FALSE;
SETBREAK(BRK!BLNK," "&'11,NULL,"XR");
SETBREAK(BRK!ID,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"&
	"abcdefghijklmnopqrstuvwxyz",NULL,"XR")
END "INISCN";

REQUIRE INISCN INITIALIZATION;

INTERNAL SIMPLE INTEGER PROCEDURE SCANU(REFERENCE STRING ARG);
BEGIN INTERNAL STRING ACCUM; INTERNAL INTEGER SCNVAL;
INTEGER BCHR;

COMMENT SCANU(STRING) ACTS AS A SIMPLE SCANNER. IT RETURNS
	AN INTEGER DEPENDENT ON THE ELEMENT SCANNED.
	0 STRING IS NULL (END OF LINE)
	1 IDENTIFIER (SAY EXTERNAL STRING ACCUM AND ACCUM WILL
	   CONTAIN THE TEXT
	2 NUMBER (INTEGER) EXTERNAL INTEGER SCNVAL HAS THE NUMBER
	3 SPECIAL CHARACTER AGAIN SCNVAL HAS THE VALUE.
STRING WILL CONTAINE THE REMAINING CHRS AFTER THE CALL.
CALLING SCANSS(TRUE) WILL CAUSE AN IDENTIFIER TO BE TERMINATED
AFTER THE FIRST CHARACTER. CALLING SCANSS(FALSE) RETURNS TO NORMAL
MODE.
LEANDING BLANKS (AND TABS) ARE IGNORED;

SCAN(ARG,BRK!BLNK,BCHR);
IF LENGTH(ARG)=0 THEN RETURN(0);
IF "0" LEQ BCHR LEQ "9" OR (SCANSIGN AND NOT ("-" NEQ BCHR NEQ "+"))
	THEN BEGIN SCNVAL_INTSCAN(ARG,BCHR); RETURN(2) END;
IF "A" LEQ BCHR LEQ "Z" OR "a" LEQ BCHR LEQ "z" THEN
	BEGIN ACCUM_SCAN(ARG,BRK!ID,BCHR); RETURN(1) END;
SCNVAL_LOP(ARG); RETURN(3) END "SCANU";

INTERNAL SIMPLE BOOLEAN PROCEDURE SCANSS(BOOLEAN B);
BEGIN IF SCANTYPE=B THEN RETURN(B);
SCANTYPE SWAP B; IF SCANTYPE THEN SETBREAK(BRK!ID,"ABCDEFGHIJK"&
 "LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",NULL,"XR") ELSE
 SETBREAK(BRK!ID,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr"&
 "stuvwxyz0123456789",NULL,"XR"); RETURN(B) END "SCANSS";
INTERNAL SIMPLE BOOLEAN PROCEDURE SCANSN(BOOLEAN B);
BEGIN SCANSIGN SWAP B; RETURN(B) END "SCANSN";
END "SLBSCN"

BSAIL ENTRY RPGINI,RPGNXT;
BEGIN "SLBRPG"
RECORDCLASS RPGPNT(STRING TXT; INTEGER TYPE,CHNL,EOF,BRK);
INTEGER BRKNUM;
SIMPLE PROCEDURE START;
SETBREAK(BRKNUM_GETBREAK,'12,'15&'14,"ISN");

REQUIRE START INITIALIZATION;

INTERNAL RECORDPOINTER (RPGPNT) PROCEDURE RPGINI(STRING NAME);
BEGIN
BOOLEAN ERRFLAG;
RECORDPOINTER (RPGPNT) RP;

RP_NEWRECORD(RPGPNT);
RPGPNT:TXT[RP]_TMPIN(NAME,ERRFLAG);
IF ERRFLAG THEN BEGIN INTEGER ARRAY A[1:2];
  A[1]_CVSIX(NAME); A[2]_0; CALL(2 LSH 18+LOCATION(A[1]),"TMPCOR");
  RPGPNT:TXT[RP]_SCANC(RPGPNT:TXT[RP],"",0,"ISN"); RETURN(RP) END;
RPGPNT:TYPE[RP]_1;
IF (RPGPNT:CHNL[RP]_GETCHAN)<0 THEN RETURN(RP);
OPEN(RPGPNT:CHNL[RP],"DSK",0,1,0,200,RPGPNT:BRK[RP],RPGPNT:EOF[RP]);
LOOKUP(RPGPNT:CHNL[RP],(("000"&CVS(CALL(0,"PJOB")))[-2 FOR 3])&NAME
	&".TMP",ERRFLAG);
IF ERRFLAG THEN RELEASE(RPGPNT:CHNL[RP]) ELSE RPGPNT:TYPE[RP]_2;
RETURN(RP)
END "RPGINI";

SIMPLE INTERNAL BOOLEAN PROCEDURE RPGNXT(REFERENCE STRING LINE;
 RECORDPOINTER (RPGPNT) RP);
CASE RPGPNT:TYPE[RP] OF BEGIN
[0] IF LENGTH(RPGPNT:TXT[RP])=0 THEN RETURN(FALSE) ELSE BEGIN
     LINE_SCAN(RPGPNT:TXT[RP],BRKNUM,RPGPNT:BRK[RP]);
     RETURN(TRUE) END;
[1] RETURN(FALSE);
[2] BEGIN
     LINE_INPUT(RPGPNT:CHNL[RP],BRKNUM);
     IF RPGPNT:EOF[RP] THEN RETURN(TRUE);
     RPGPNT:TYPE[RP]_1; RENAME(RPGPNT:CHNL[RP],"",0,RPGPNT:EOF[RP]);
     RELEASE(RPGPNT:CHNL[RP]);
     RETURN(FALSE) END END;
END "SLBRPG"

BSAIL ENTRY STRSRC;
BEGIN "STRSRC"
INTERNAL SIMPLE INTEGER PROCEDURE STRSRC(STRING ARRAY NAMES;
	STRING LOOK; REFERENCE BOOLEAN EXACT);
BEGIN INTEGER FIRST,LAST,PREV,I;

COMMENT THIS ROUTINE IS CALLED WITH A STRING AND A STRING
    ARRAY. IT SEARCHES FOR A MATCH AND RETURNS THE INDEX
    INTO THE ARRAY OF THE MATCH. TO AVOID CONFUSION, THE
    LOWER ARRAY BOUND SHOULD BE 1 OR GREATER. IF NO MATCH IS
    FOUND, 0 IS RETURNED. THE PROCEDURE WILL TRY TO FIND
    AN EXACT MATCH. FAILING THIS, IT WILL LOOK FOR STRINGS
    WHICH MATCH ON ALL THE CHARACTERS IN THE STRING ARGUMENT.
    THE FLAG EXACT WILL BE SET TRUE IF AN EXACT MATCH IS FOUND.
    IF NO EXACT MATCH IS FOUND AND SEVERAL PARTIAL MATCHES EXIST
    THE PROCEDURE WILL RETURN 0.
	CALL IS STRSRC(ARRAY,STRING,FLAG);

PREV_0; FIRST_ARRINFO(NAMES,1); LAST_ARRINFO(NAMES,2);
FOR I_FIRST STEP 1 UNTIL LAST DO
IF EQU(LOOK,NAMES[I]) THEN BEGIN EXACT_TRUE;
	RETURN(I) END
ELSE IF EQU(LOOK,NAMES[I][1 FOR LENGTH(LOOK)]) THEN
	PREV_IF PREV NEQ 0 THEN -1 ELSE I;
EXACT_FALSE; RETURN(PREV MAX 0)
END 
END "STRSRC"
BSAIL ENTRY !PORTX;
begin "SLBPRT"
define !="COMMENT";
require "GOGTAB.DEF" source!file;
external integer array GOGTAB[0:ENDREN];

simple procedure portout( integer port; string s );
! outputs string to port, waits if necessary;
start!code	define !AXOPC='67;		! SAIL portout UUO;
		external integer INTRPT,DDFINA;	! for polling point;
		define sp='16;	! string stack;

	hrl	1,port;		! get port number;
	hrri	1,!AXOPC;	! and opcode;
	SKIPE	INTRPT;	! SAIL code for polling point;
	 XCT	DDFINA;	! SAIL code for polling point;
	auxcal	1,-1(sp);	! put it out to the port;
end;

own integer formertrap;

simple procedure out!trap(integer chan; string data );
if chan<0 and 0 = chan land ('377777 lsh 18)
 then portout(chan,data)
 else begin	integer stringFormatter;
	gogtab[$$PROU]_formerTrap;
	stringFormatter_ gogtab[$$FSTR]; gogtab[$$FSTR]_ 0;
	cprint(chan,data);
	gogtab[$$FSTR]_ stringFormatter;
	gogtab[$$PROU]_location(out!trap);
      end;


internal simple boolean procedure !portx( boolean enabling );
begin	boolean wasOn;
wasOn_ gogtab[$$PROU]=location(out!trap);
if enabling and not wasOn
 then begin
	formerTrap_ gogtab[$$PROU];
	gogtab[$$PROU]_ location(out!trap);
      end
 else if wasOn and not enabling
	then gogtab[$$PROU]_ formerTrap;
return(wasOn);
end;
end "SLBPRT" 

BSAIL ENTRY SOUNDX;
begin "SOUNDX"
define !="Comment";
Comment		a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z;
preload!with	0,1,2,3,0,1,2,0,0,2,2,4,5,5,0,1,2,6,2,3,0,1,0,2,0,2;
own safe integer array soundexTable["A":"Z"];
simple internal integer procedure soundx( string s );
start!code
	define byptr=0,res=1,cnt=2,vals=3,ch=4,last=5, sp='16,p='17;
	label getfirst,skipass,chlast,passmore,donev,return;
	pop	sp,byptr;
	pop	sp,cnt;
	hrrz	cnt,cnt;
getfirst:		! loop here to find first alphabetic;
	sojl	cnt,return;
	ildb	ch,byptr;
	trz	ch,'40;		! force upper case;
	cail	ch,"A";
	 caile	ch,"Z";
	  jrst	getfirst;
	movei	res,"A"-1(ch);
	movei	vals,3;
	skipa	ch,soundexTable[0](ch);
skipass:		! got a "vowel" (or non-letter);
	tdza	last,last;
chlast:
	 movei	last,0(ch);	! put ch in last;
passmore:
	sojl	cnt,donev;
	ildb	ch,byptr;
	trz	ch,'40;		! force upper case;
	caile	ch,"A";
	 caile	ch,"Z";
	  jrst	skipass;
	skipe	ch,soundexTable[0](ch);
	cain	last,(ch);
	 jrst	chlast;
	lsh	res,3;
	ior	res,ch;
	sojg	vals,chlast;
	 popj	p,;
donev:
	imuli	vals,3;
	lsh	res,(vals);
return:
	popj	p,;
end;
end "SOUNDX"
BSAIL ENTRY SAVLOW;
begin "savlow"

define !="Comment";


simple integer procedure setstart;
start!code	own integer rfsave, spsave, psave, retsav;
		own integer save17, blteff; ! for saving start acs;
		label gostart, strtgo, savacs, baksav;
		external integer rpgsw, iniacs;
		define p='17,sp='16,rf='12,rslt=1;
	pop	p,retsav;	! save return address;
	movem	rf,rfsave;
	movem	sp,spsave;
	movem	p,psave;
	movei	1,iniacs;	! now make BLT setup pointers;
	addi	1,'16;
	movem	1,blteff;	! one for the effective address;
	addi	1,1;		! and one to save the BLT ac used;
	movem	1,save17;
	movei	rslt,gostart;	! and return with start instruction;
				! for the save file;
	jrst	@retsav;
gostart:jrst	baksav;

strtgo:	setzm	rpgsw;		! mark entered normally (not RPGjrst	savacs;

baksav:	jrst	strtgo;
	 setom	rpgsw;		! mark entered via RPG entry;
savacs:	movem	'17,@save17;	! save all ACs in INIACS;
	movei	'17,iniacs;	! saved '17, now save rest;
	blt	'17,@blteff;	!  now all acs saved;
	move	p,psave;	! restore SAILs 3 magic registers;
	move	sp,spsave;
	move	rf,rfsave;
	seto	rslt,;		! indicate coming back from a save;
	jrst	@retsav;
end;



internal simple integer procedure savlow( string outfile );
begin
	integer chan, eof, startup, base;
	external integer !jbpfi, !jbrel, !jbsa, !jbddt, !jb41;
	define !jbhcu="memory['72]", !jbjda="memory['75]";
	COMMENT these are defined since JOBDAT doesn't have them;
	integer o!jbsa, o!jbddt, o!jb41;

if !jbhcu or !jbjda
  then begin usererr(0,1,"SAVLOW: files open"); return(0); end;
open( chan_getchan, "DSK",'13, 0,4, 0,0,eof_false );
    if eof then return(0); ! save failed;
enter( chan, outfile, eof );
    if eof then begin release(chan); return(0); ! save failed; end;

o!jbsa_ !jbsa; o!jbddt_ !jbddt; o!jb41_ !jb41;
if -1=startup_ setstart		! ie came back from saved core image;
 then begin
	!jbsa_ o!jbsa; !jbddt_o!jbddt; !jb41_ o!jb41;
	release(chan);
	return(-1); ! return from save;
      end;
!jbsa_ memory[startup];
for base_location(!jbpfi)+1 step 1 until !jbrel
   do if memory[base]
	 then begin	integer btop;
		for btop_ base+1 step 1 until !jbrel
		 do if memory[btop]=0 then done;
		wordout( chan, (base-btop) lsh 18 lor base-1 );
		arryout( chan, memory[base], btop-base );
		base_ btop;
	      end;
wordout( chan, memory[startup] );	! write out start address;
!jbsa_ o!jbsa;
release( chan ); return(1); ! save succeeded;
end;

end "savlow"

BSAIL ENTRY DSIN,DCOS,DTAN;
begin "SLBDTR"
define halfPi="(((0@@0 lor '021026430215) rot 36) lor '201622077325)",
	   Pi="(((0@@0 lor '021026430215) rot 36) lor '202622077325)",
	twoPi="(((0@@0 lor '021026430215) rot 36) lor '203622077325)",
	!="COMMENT";
external long real procedure dfract( long real val );

long real work,start;
boolean negate;
real last;

long real simple procedure maclaurin;
begin	long real rslt,rlOld;
rslt_ work;
if start geq 2.^-31	! t0 is given, t1/t0 = x^2/2 or x^2/6;
 then begin		! if start<2^-31 then t0/t1<2^-63, answer is t0;
	start_start*start;
	  do  begin
		rlOld_rslt;
		work_ -work*start/((last+1)*(last_last+2));
		rslt_ rslt+work;
	      end
	 until rslt = rlOld;
      end;
return(if negate then -rslt else rslt);
end;

internal long real procedure dsin(long real x);
! approximation: SIN x = sum[n=0:inf](  -1^n * x^(2n+1) / (2n+1)!  )
  normalized to the first quadrant
;
begin	boolean neg;
if negate_(x<0) then x_-x;
if x geq twoPi then x_ twoPi*dfract(x/twoPi);
if x geq pi then begin negate_ not negate; x_ x-pi; end;
if x > halfPi then x_ pi- x;
work_start_x; last_1;
return( maclaurin );
end;

internal long real procedure dcos(long real x);
! approximation: COS x = sum[n=0:inf](  -1^n * x^(2n) / (2n)!  )
  normalized to the first quadrant
;
begin
if x<0 then x_-x;
if x geq twoPi then x_ twoPi*dfract(x/twoPi);
if x > pi then x_ twoPi-x;
if negate_(x > halfPi) then x_ pi- x;
start_x; work_1; last_0;
return( maclaurin );
end;

internal long real procedure dtan(long real x);
return(dsin(x)/dcos(x));
end "SLBDTR"
 # \‹