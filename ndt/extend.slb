BSAIL(SAIAGN:GENARY)

COMMENT THE ROUTINE GENARY IS DESIGNED TO GENERATE ARRAYS
	TO BE STORED INTO RECORDS. THESE ARRAYS WILL BE
	PROPERLY GARBAGE COLLEDTED WHEN THE RECORDS ARE DELETED.
	GENARY TAKES TWO ARGUMENTS. THE FIRST IS AN INTEGER ARRAY
	OF ONE DIMENSION. THE RANGE OF INDICES MAY BE
	ANYTHING DESIRED. THE FIRST VALUE IS THE NUMBER
	OF DIMENTIONS DESIRED. THE SECOND IS THE LOWER BOUND
	FOR THE FIRST DIMENTSION, THEN THE UPPER BOUND FOR
	THE FIRST DIMENTION, THEN THE LOWER FOR THE SECOND
	DIMENSION, ETC.
	THE SECOND ARGUMENT TO GENARY IS THE ADDRESS OF THE
	ARRAY ARGUMENT IN THE RECORD.
	IF RP IS THE RECORD POINTER, RC THE RECORD CLASS,
	AND RA THE ARRAY FIELD IN THE RECORD, THEN USE
		LOCATION(RC:RA[RP])
	FOR THE SECOND ARGUMENT
;
INTERNAL SIMPLE PROCEDURE GENARY(INTEGER ARRAY ARGS;INTEGER LOC);
BEGIN INTEGER FSTEL,NUMDIM,AG,I; LABEL LOOP;
EXTERNAL INTEGER PROCEDURE LRMAK;
DEFINE P='17;

AG_LOCATION(ARGS[(FSTEL_ARRINFO(ARGS,1))+1]);
I_ARGS[FSTEL+((NUMDIM_ARGS[FSTEL]) LAND '777777)*2];
START!CODE MOVE 1,AG; HRRZ 2,NUMDIM; LOOP: PUSH P,(1);
   PUSH P,1(1); ADDI 1,2;
  SOJG 2,LOOP; PUSH P,NUMDIM; PUSHJ P,LRMAK; MOVE 2,LOC;
  MOVEM 1,(2) END;
END "GENARY";
ESAIL(SAIAGN)
BSAIL(SAICVD:CNVDATE,CNVDTIM)
INTEGER JFYSEC;
OWN INTEGER ARRAY CNV[0:2];
REQUIRE "(SAILIB)TYMGET.DEF" SOURCE!FILE;
REQUIRE "(SAILIB)TYMCAL.DEF" SOURCE!FILE;
SIMPLE PROCEDURE SETJFC;
JFYSEC_CALL(GETTAB!JFYSEC,"GETTAB");

REQUIRE SETJFC INITIALIZATION [0];

INTERNAL SIMPLE INTEGER PROCEDURE CNVDATE(INTEGER DATE,FROM,TO);
BEGIN CNV[0]_DATE; CNV[2]_FROM LSH 18+TO;
CNV[1]_(1200*60)*JFYSEC; CALLI (LOCATION(CNV[0]),CALLI!DATUUO);
RETURN(CNV[0]) END "CNVDATE";

INTERNAL SIMPLE PROCEDURE CNVDTIM(REFERENCE INTEGER
	DATE,TIME; INTEGER FROM,TO);
BEGIN
CNV[0]_DATE; CNV[2]_FROM LSH 18+TO; CNV[1]_TIME*JFYSEC;
CALLI(LOCATION(CNV[0]),CALLI!DATUUO);
DATE_CNV[0]; TIME_CNV[1]%JFYSEC END "CNVDTIM";
ESAIL(SAICVD)
BSAIL(SAIDAT:RDDATE,STDATE)
PRELOAD!WITH "JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE",
	"JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER",
	"DECEMBER";
OWN STRING ARRAY MONTHS[1:12];
SIMPLE INTERNAL BOOLEAN PROCEDURE RDDATE(REFERENCE INTEGER DATE,
	OVSCAN; VALUE INTEGER FSTSCN; REFERENCE STRING STR);
BEGIN

COMMENT THIS PROCEDURE READS THE DATE FROM THE STRING PASSED.
	IT USES SCANU AND STRSRC. IT ASSUMES THAT SCANU
	HAS BEEN CALLED BEFORE IT AND THE VALUE RETURNED BY
	SCANU IS PASSED IN FSTSCN. IT CALLS SCANU ONE EXTR TIME
	AND RETURNS THE VALUE IN OVSCAN. THE DATE IS RETURNED
	IN DATE IN THE STANDARD DEC DATE FORMAT

		((YR-64)*12+MONTH-1)*31+DAY-1
	IT ACCEPTS DATES IN THE FOLLOWING FORMATS
		MM-DD-YY
		DD-MONTH-YY
		MONTH DD,YY
	DD IS THE DAY (AS A NUMBER) MM THE MONTH (AS A NUMBER)
	MONTH THE NAME FOR THE MONTH (OR A SHORTENED VERSION AS
	SEP FOR SEPTEMBER). THE - MAY BE OMITTED OR REPLACED
	BY A /. THE YEAR (YY) MAY BE EITHER A 2 DIGIT YEAR AS 76
	OR A 4 DIGIT YEAR AS 1976;

EXTERNAL SIMPLE BOOLEAN PROCEDURE SCANSS(BOOLEAN B);
EXTERNAL SIMPLE BOOLEAN PROCEDURE SCANSN(BOOLEAN B);
EXTERNAL SIMPLE INTEGER PROCEDURE SCANU(REFERENCE STRING STR);
EXTERNAL INTEGER SCNVAL;
EXTERNAL STRING ACCUM;
EXTERNAL SIMPLE INTEGER PROCEDURE STRSRC(STRING ARRAY NAMES;
	STRING LOOK; BOOLEAN EXACT);
INTEGER MON,DAY,YR;
BOOLEAN BOOL,BOOL2,BOOL3;
PRELOAD!WITH 31,29,31,30,31,30,31,31,30,31,30,31;
OWN INTEGER ARRAY MONDYS[1:12];

SIMPLE BOOLEAN PROCEDURE RSTSCN;
BEGIN SCANSN(BOOL3); RETURN(SCANSS(BOOL2)) END "RSTSCN";

SIMPLE INTEGER PROCEDURE DSHSCN(REFERENCE STRING STR);
BEGIN INTEGER I;
IF (I_SCANU(STR))=3 THEN IF NOT "-" NEQ SCNVAL NEQ "/" THEN
   RETURN(SCANU(STR)) ELSE RETURN(0) ELSE RETURN(I)
END "DSHSCN";

BOOL2_SCANSS(FALSE); BOOL3_SCANSN(FALSE);
CASE FSTSCN MIN 3 OF BEGIN
[0][3] RETURN(RSTSCN);
 COMMENT WE KNOW RSTSCN WILL RETURN FALSE AT THIS POINT;
[1] IF (MON_STRSRC(MONTHS,ACCUM,BOOL))=0 OR SCANU(STR) NEQ 2
   OR NOT(MONDYS[MON] GEQ (DAY_SCNVAL)>0) OR SCANU(STR) NEQ 3 OR
   SCNVAL NEQ "," OR SCANU(STR) NEQ 2
    THEN RETURN(RSTSCN);
[2] BEGIN DAY_SCNVAL;
   CASE DSHSCN(STR) OF BEGIN
   [0][3] RETURN (RSTSCN);
   [2] IF NOT(12 GEQ (MON_DAY)>0) OR
	NOT(MONDYS[MON] GEQ (DAY_SCNVAL)>0) OR
	DSHSCN(STR) NEQ 2 THEN RETURN(RSTSCN);
   [1] IF (MON_STRSRC(MONTHS,ACCUM,BOOL))=0 OR NOT(MONDYS[MON]
	GEQ DAY>0) OR DSHSCN(STR) NEQ 2
	THEN RETURN(RSTSCN)
   END
  END
END;
IF NOT(44 GEQ (YR_IF SCNVAL>100 THEN SCNVAL-1964 ELSE SCNVAL-64)
   GEQ 0) THEN RETURN(RSTSCN);
RSTSCN;
OVSCAN_SCANU(STR); DATE_(YR*12+MON-1)*31+DAY-1;
RETURN (TRUE) END "RDDATE";
SIMPLE INTERNAL STRING PROCEDURE STDATE(INTEGER DATE,FLAG);
BEGIN

COMMENT THIS PROCEDURE TAKES AN INTEGER DATE IN DEC DATE FORMAT
	AND GENERATES A STRING FROM IT. THE INTEGER FLAG CONTROLS
	THE FORMATTING FOR THE STRING RETURNED AS FOLLOWS:

	BITS 33-35 (FLAG LAND '7) IS THE GENERAL FORMAT
	 (DD INDICATES DAY AS A NUMBER MM MONTH AS A NUMBER
	  MON MONTH AS TEXT AND YY YEAR AS A NUMBER (2 OR 4 DIGITS)
	 0 MM-DD-YY
	 1 DD-MON-YY
	 2 DD-MM-YY
	 3 MON DD,YY
	 UNASSIGNED FORMATS ARE THE SAME AS 1.
	BITS 29-32 (FLAG LSH -3 LAND '17) ARE THE SIZE
	 OF THE MON STRING (0 IS FULL WIDTH) THIS IS THE MAX
	 WIDTH.
	BIT 28 (FLAG LAND '200) INDICATES THAT THE YEAR IS
	 4 DIGITS NOT 2
	BITS 26-27 (FLAG LSH -8 LAND '3) GIVE A CHR TO REPLACE
	 THE - IN FORMATS 0,1, AND 2: 0 IS - 1 IS / 2 IS BLANK
	 3 IS UNDEFINED (BLANK);

INTEGER DAY,MON,YR,I,J; STRING DAYS,MONS,YRS,SMON,ST;
DAY_DATE MOD 31+1; MON_(DATE DIV 31) MOD 12+1;
YR_DATE DIV (31*12)+64;
IF FLAG LAND '200 NEQ 0 THEN YR_YR+1900;
GETFORMAT(I,J); SETFORMAT(0,0);
DAYS_CVS(DAY); MONS_CVS(MON); YRS_CVS(YR); SETFORMAT(I,J);
ST_CASE (FLAG LSH -8) LAND '3 OF ("-","/"," "," ");
SMON_MONTHS[MON];
IF (I_(FLAG LSH -3) LAND '17) NEQ 0 THEN SMON_SMON[1 FOR I];
CASE FLAG LAND '7 OF BEGIN
   [0] RETURN (MONS&ST&DAYS&ST&YRS);
   [1][4][5][6][7] RETURN (DAYS&ST&SMON&ST&YRS);
   [2] RETURN (DAYS&ST&MONS&YRS);
   [3] RETURN (SMON&" "&DAYS&","&YRS) END
END "STDATE";
ESAIL(SAIDAT)
BSAIL(SAIDUL:LOKDUL)
INTEGER DULCHL,DULEOF,DULBLK;
INTEGER ARRAY DULARY[0:127];
DEFINE DULHSH=101;

SIMPLE PROCEDURE INIDUL; DULCHL_DULBLK_-1;
REQUIRE INIDUL INITIALIZATION;

INTERNAL SIMPLE STRING PROCEDURE LOKDUL(INTEGER PPN);

COMMENT READS DUL TO FIND CORRESPONDENCE TO PPN;

BEGIN INTEGER I; STRING ST;
SIMPLE STRING PROCEDURE BRKPPN(INTEGER PPN);
RETURN ("["&CVOS(PPN LSH -18)&","&CVOS(PPN LAND '777777)&"]");

IF DULCHL<0 THEN OPEN(DULCHL_GETCHAN,"DSK",'16,0,0,DULEOF,DULEOF,DULEOF);
IF DULBLK<0 THEN LOOKUP(DULCHL,"DUL.SYS[1,4]",DULEOF);
COMMENT ORIGINALLY DULEOF AND DULCHL ARE SET -1, FORCES 
	CONTINUED LOOKUPS IF DUL WAS NOT FOUND BEFORE;
IF DULEOF NEQ 0 THEN RETURN (BRKPPN(PPN));
USETI (DULCHL,I_PPN MOD DULHSH+1);
WHILE TRUE DO BEGIN "ARRSRC"
   IF I NEQ DULBLK THEN ARRYIN(DULCHL,DULARY[0],128);
   DULBLK_I;
   FOR I_0 STEP 3 UNTIL 127 DO
	IF DULARY[I]=PPN THEN DONE "ARRSRC" ELSE IF
	DULARY[I]=0 THEN RETURN (BRKPPN(PPN)) ELSE IF
	DULARY[I]<0 THEN DONE;
   USETI(DULCHL,I_DULARY[I] LAND '777777+1) END "ARRSRC";
COMMENT NEGATIVE IS THE LINK CONVENTION;

ST_CVXSTR(DULARY[I+1])&CVXSTR(DULARY[I+2]);
WHILE ST[INF FOR 1]=" " DO ST_ST[1 FOR INF-1];
COMMENT REMOVE TRAILING BLANKS;
RETURN("("&ST&")") END "LOKDUL";

ESAIL(SAIDUL)
BSAIL(SAIRPG:RPGINI,RPGNXT)
RECORDCLASS RPGPNT(STRING TXT; INTEGER TYPE,CHNL,EOF,BRK);
INTEGER BRKNUM;
SIMPLE PROCEDURE START;
SETBREAK(BRKNUM_GETBREAK,'12,'15&'14,"ISN");

REQUIRE START INITIALIZATION;

INTERNAL RECORDPOINTER (RPGPNT) PROCEDURE RPGINI(STRING NAME);
BEGIN
BOOLEAN ERRFLAG;
RECORDPOINTER (RPGPNT) RP;

RP_NEWRECORD(RPGPNT);
RPGPNT:TXT[RP]_TMPIN(NAME,ERRFLAG);
IF ERRFLAG THEN BEGIN INTEGER ARRAY A[1:2];
  A[1]_CVSIX(NAME); A[2]_0; CALL(2 LSH 18+LOCATION(A[1]),"TMPCOR");
  RPGPNT:TXT[RP]_SCANC(RPGPNT:TXT[RP],"",0,"ISN"); RETURN(RP) END;
RPGPNT:TYPE[RP]_1;
IF (RPGPNT:CHNL[RP]_GETCHAN)<0 THEN RETURN(RP);
OPEN(RPGPNT:CHNL[RP],"DSK",0,1,0,200,RPGPNT:BRK[RP],RPGPNT:EOF[RP]);
LOOKUP(RPGPNT:CHNL[RP],(("000"&CVS(CALL(0,"PJOB")))[-2 FOR 3])&NAME
	&".TMP",ERRFLAG);
IF ERRFLAG THEN RELEASE(RPGPNT:CHNL[RP]) ELSE RPGPNT:TYPE[RP]_2;
RETURN(RP)
END "RPGINI";

SIMPLE INTERNAL BOOLEAN PROCEDURE RPGNXT(REFERENCE STRING LINE;
 RECORDPOINTER (RPGPNT) RP);
CASE RPGPNT:TYPE[RP] OF BEGIN
[0] IF LENGTH(RPGPNT:TXT[RP])=0 THEN RETURN(FALSE) ELSE BEGIN
     LINE_SCAN(RPGPNT:TXT[RP],BRKNUM,RPGPNT:BRK[RP]);
     RETURN(TRUE) END;
[1] RETURN(FALSE);
[2] BEGIN
     LINE_INPUT(RPGPNT:CHNL[RP],BRKNUM);
     IF RPGPNT:EOF[RP] THEN RETURN(TRUE);
     RPGPNT:TYPE[RP]_1; RENAME(RPGPNT:CHNL[RP],"",0,RPGPNT:EOF[RP]);
     RELEASE(RPGPNT:CHNL[RP]);
     RETURN(FALSE) END END;
ESAIL(SAIRPG)
BSAIL(SAISCN:SCANU,SCANSS,SCANSN)
INTEGER BRK!BLNK,BRK!ID;
BOOLEAN SCANTYPE,SCANSIGN;
SIMPLE PROCEDURE INISCN;
BEGIN BRK!BLNK_GETBREAK; BRK!ID_GETBREAK;
  SCANSIGN_TRUE; SCANTYPE_FALSE;
SETBREAK(BRK!BLNK," "&'11,NULL,"XR");
SETBREAK(BRK!ID,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"&
	"abcdefghijklmnopqrstuvwxyz",NULL,"XR")
END "INISCN";

REQUIRE INISCN INITIALIZATION;

INTERNAL SIMPLE INTEGER PROCEDURE SCANU(REFERENCE STRING ARG);
BEGIN INTERNAL STRING ACCUM; INTERNAL INTEGER SCNVAL;
INTEGER BCHR;

COMMENT SCANU(STRING) ACTS AS A SIMPLE SCANNER. IT RETURNS
	AN INTEGER DEPENDENT ON THE ELEMENT SCANNED.
	0 STRING IS NULL (END OF LINE)
	1 IDENTIFIER (SAY EXTERNAL STRING ACCUM AND ACCUM WILL
	   CONTAIN THE TEXT
	2 NUMBER (INTEGER) EXTERNAL INTEGER SCNVAL HAS THE NUMBER
	3 SPECIAL CHARACTER AGAIN SCNVAL HAS THE VALUE.
STRING WILL CONTAINE THE REMAINING CHRS AFTER THE CALL.
CALLING SCANSS(TRUE) WILL CAUSE AN IDENTIFIER TO BE TERMINATED
AFTER THE FIRST CHARACTER. CALLING SCANSS(FALSE) RETURNS TO NORMAL
MODE.
LEANDING BLANKS (AND TABS) ARE IGNORED;

SCAN(ARG,BRK!BLNK,BCHR);
IF LENGTH(ARG)=0 THEN RETURN(0);
IF "0" LEQ BCHR LEQ "9" OR (SCANSIGN AND NOT ("-" NEQ BCHR NEQ "+"))
	THEN BEGIN SCNVAL_INTSCAN(ARG,BCHR); RETURN(2) END;
IF "A" LEQ BCHR LEQ "Z" OR "a" LEQ BCHR LEQ "z" THEN
	BEGIN ACCUM_SCAN(ARG,BRK!ID,BCHR); RETURN(1) END;
SCNVAL_LOP(ARG); RETURN(3) END "SCANU";

INTERNAL SIMPLE BOOLEAN PROCEDURE SCANSS(BOOLEAN B);
BEGIN IF SCANTYPE=B THEN RETURN(B);
SCANTYPE SWAP B; IF SCANTYPE THEN SETBREAK(BRK!ID,"ABCDEFGHIJK"&
 "LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",NULL,"XR") ELSE
 SETBREAK(BRK!ID,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr"&
 "stuvwxyz0123456789",NULL,"XR"); RETURN(B) END "SCANSS";
INTERNAL SIMPLE BOOLEAN PROCEDURE SCANSN(BOOLEAN B);
BEGIN SCANSIGN SWAP B; RETURN(B) END "SCANSN";
ESAIL(SAISCN)
BSAIL(SAISRC:STRSRC)
INTERNAL SIMPLE INTEGER PROCEDURE STRSRC(STRING ARRAY NAMES;
	STRING LOOK; REFERENCE BOOLEAN EXACT);
BEGIN INTEGER FIRST,LAST,PREV,I;

COMMENT THIS ROUTINE IS CALLED WITH A STRING AND A STRING
    ARRAY. IT SEARCHES FOR A MATCH AND RETURNS THE INDEX
    INTO THE ARRAY OF THE MATCH. TO AVOID CONFUSION, THE
    LOWER ARRAY BOUND SHOULD BE 1 OR GREATER. IF NO MATCH IS
    FOUND, 0 IS RETURNED. THE PROCEDURE WILL TRY TO FIND
    AN EXACT MATCH. FAILING THIS, IT WILL LOOK FOR STRINGS
    WHICH MATCH ON ALL THE CHARACTERS IN THE STRING ARGUMENT.
    THE FLAG EXACT WILL BE SET TRUE IF AN EXACT MATCH IS FOUND.
    IF NO EXACT MATCH IS FOUND AND SEVERAL PARTIAL MATCHES EXIST
    THE PROCEDURE WILL RETURN 0.
	CALL IS STRSRC(ARRAY,STRING,FLAG);

PREV_0; FIRST_ARRINFO(NAMES,1); LAST_ARRINFO(NAMES,2);
FOR I_FIRST STEP 1 UNTIL LAST DO
IF EQU(LOOK,NAMES[I]) THEN BEGIN EXACT_TRUE;
	RETURN(I) END
ELSE IF EQU(LOOK,NAMES[I][1 FOR LENGTH(LOOK)]) THEN
	PREV_IF PREV NEQ 0 THEN -1 ELSE I;
EXACT_FALSE; RETURN(PREV MAX 0)
END "STRSRC";
ESAIL(SAISRC)
BSAIL(SAITIM:RDTIME)
INTERNAL SIMPLE BOOLEAN PROCEDURE RDTIME(REFERENCE INTEGER TIME
	,OVSCAN; VALUE INTEGER FSTSCN; REFERENCE STRING STR);
BEGIN

COMMENT THIS PROCEDURE READS THE TIME FROM THE STRING PASSED.
	IT USES SCANU AND ASSUMES THAT SCANU HAS BEEN CALLED
	BEFORE IT. THE VALUE RETURNED BY SCANU IS IN FSTSCN.
	THE TIME FORMATS ACCEPTED ARE HHMM OR HH:MM. THE TIME
	RETURNED IN TIME IS IN MIN SINCE MIDNIGHT. OVSCAN IS
	SET TO THE OUTPUT OF SCANU FOR THE NEXT ELEMNT OF THE
	LINE;

EXTERNAL SIMPLE INTEGER PROCEDURE SCANU(REFERENCE STRING STR);
EXTERNAL INTEGER SCNVAL;
INTEGER HR,MIN;

IF FSTSCN NEQ 2 THEN RETURN(FALSE);
HR_SCNVAL;
IF NOT ( (OVSCAN_SCANU(STR))=3 AND SCNVAL=":") THEN BEGIN
   IF NOT(2400 GEQ SCNVAL GEQ 0) OR (MIN_HR MOD 100)>59
   THEN RETURN(FALSE);
   TIME_(HR DIV 100)*60+MIN; RETURN(TRUE) END;
IF SCANU(STR) NEQ 2 OR NOT(60>SCNVAL GEQ 0) OR NOT(24*60 GEQ
	(TIME_HR*60+SCNVAL) GEQ 0) THEN RETURN(FALSE);
OVSCAN_SCANU(STR); RETURN (TRUE)
END "RDTIME";
ESAIL(SAITIM)
BSAIL(SAIUFD:INIUFR,NXTUFR)
REQUIRE "(SAILIB)TYMIO.DEF" SOURCE!FILE;
REQUIRE "<><>" DELIMITERS;
DEFINE BIT(A,B)=<(A LSH (35-B))>;
EXTERNAL SIMPLE PROCEDURE GENARY(INTEGER ARRAY ARGS; INTEGER LOC);
EXTERNAL BOOLEAN !SKIP!; INTEGER ARRAY ARGS[1:3];

RECORD!CLASS UFDREC(INTEGER CHAN,POINTR,NUMENT;
	INTEGER ARRAY HEAD,DATA);
RECORD!POINTER (UFDREC) RP;
INTERNAL SIMPLE RECORD!POINTER (UFDREC) PROCEDURE INIUFR(
	STRING NAME,EXTENSION; INTEGER CHANNEL,BITS(0),SIZE(102));
BEGIN

RP_NEW!RECORD(UFDREC);
UFDREC:CHAN[RP]_CHANNEL;
ARGS[1]_1;ARGS[2]_0;ARGS[3]_7;
GENARY(ARGS,LOCATION(UFDREC:HEAD[RP]));
SIZE_(SIZE MAX 1) MIN 102;
UFDREC:HEAD[RP][1]_CVSIX(NAME);
UFDREC:HEAD[RP][2]_CVSIX(EXTENSION);
UFDREC:HEAD[RP][4]_UFDREC:HEAD[RP][5]_UFDREC:HEAD[RP][6]_
	UFDREC:HEAD[RP][7]_UFDREC:HEAD[RP][3]_0;
IF BITS LAND 1 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_BIT(1,2);
	UFDREC:NUMENT[RP]_1 END;
IF BITS LAND 2 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,3);
	UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+1 END;
IF BITS LAND 4 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,4);
	UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+1 END;
IF BITS LAND 8 NEQ 0 THEN BEGIN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,1);
	UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+1 END;
IF BITS LAND 16 NEQ 0 THEN UFDREC:HEAD[RP][3]_
	UFDREC:HEAD[RP][3] LOR BIT(1,0);
IF BITS LAND 32 NEQ 0 THEN UFDREC:HEAD[RP][3]_UFDREC:HEAD[RP][3]
  LOR BIT(('200+((BITS LSH -6) LAND '177)),17);
ARGS[3]_(UFDREC:NUMENT[RP]_UFDREC:NUMENT[RP]+2)*SIZE-1;
GENARY(ARGS,LOCATION(UFDREC:DATA[RP]));
UFDREC:HEAD[RP][0]_(-ARGS[3]-1) LSH 18
	+POINT(0,UFDREC:DATA[RP][0],35);
USETI(CHANNEL,1);
RETURN(RP) END "INIUFR";

INTERNAL SIMPLE BOOLEAN PROCEDURE NXTUFR(INTEGER ARRAY OUTDT;
	RECORD!POINTER (UFDREC) RPA);
BEGIN
 WHILE UFDREC:HEAD[RPA][7]=0 DO BEGIN
   CHNIOR(UFDREC:CHAN[RPA],UFDREC:HEAD[RPA][0],CIO!UFD);
   UFDREC:POINTR[RPA]_0;
   IF NOT !SKIP! THEN RETURN(FALSE) END;
 ARRBLT(OUTDT[0],UFDREC:DATA[RPA][UFDREC:POINTR[RPA]],
	UFDREC:NUMENT[RPA]);
 UFDREC:POINTR[RPA]_UFDREC:POINTR[RPA]+UFDREC:NUMENT[RPA];
 UFDREC:HEAD[RPA][7]_UFDREC:HEAD[RPA][7]-1;
RETURN (TRUE) END "NXTUFR";
ESAIL(SAIUFD)

   