COMMENT \HISTORY
AUTHOR,SAIL,REASON
025  300300000015  \;


COMMENT \
VERSION 3-3(13) 11-30-77 BY SDD remove non-ASCII chars where possible
VERSION 3-3(12) @ BY WFW lots of TYMSHARE stuff
VERSION 3-3(11) 1-11-74 BY JRL USE CMU VERSION
VERSION 3-3(10) 12-4-73 BY RHT ADD LIBHED KLUGE TO SCISS
VERSION 3-3(9) 12-4-73 
VERSION 3-3(8) 7-13-73 BY JRL AVOID "RENAME DIFFICULTY" FOR SAIREM
VERSION 3-3(7) 7-4-72 BY DCS FIX "D" BUG WHEN SELECTING FROM PROMPT
VERSION 3-3(6) 6-25-72 BY DCS ADD NAM COMMAND TO ORDER, LIBNAM FEATURE TO SCISS
VERSION 3-3(5) 5-23-72 BY DCS AVOID HDRFIL IF NOT NEEDED
VERSION 3-3(4) 2-24-72 BY DCS ADD RENSW CONTROL, CHANGE  PARAMETER INPUT
VERSION 3-3(3) 2-10-72 BY DCS ADD OVERRIDE CAPABILITY FOR INTERMEDIATE FILE CREATION
VERSION 3-3(2) 2-10-72 BY DCS UPGRADE ORDER BUSINESS
VERSION 3-3(1) 12-2-71 BY DCS INSTALL VERSION NUMBER

\;



begin "SCISS"
EXTERNAL PROCEDURE BAIL;
  DEFINE VERSION!NUMBER = "'300300000015";
   DEFINE
    !="COMMENT",
    CRLF="('15&'12)",
    BIT (X,Y)="((Y) LAND (X))",	PUTBIT (X,Y)="X_X LOR (Y)",
    REMBIT(X,Y)="X_X XOR (Y)",
    TYPE="OUTSTR(",	EOM="&('15&'12))",
    WRITE="OUT(DSKO,",	READ="INPUT(DSKI,EndDscr)",
    CONTROLC="'3";

   REQUIRE VERSION!NUMBER VERSION;
integer junk;	! write-only variable;
   STRING STR,LINE,LINE1,COMNAM,TS,FILE,FFFF,GOGFIL;
   STRING LIBNAM, HLBNAM,GASNAM;
   INTEGER I,J,TTYCHAR,FILCNT,SWITCH,W,BRKCHR,EOF,LOW,HIGH,BEOF,ENTSEEN;
   INTEGER SYMBOL,SYMBOLS,RELOC,CCOUT,SYMCNT,TYPP,COMNO,SEEN,IQ;
   INTEGER DELETING, COMMNT, DSCRING, WILLTELL, EACHASK, MAXTHS;
   INTEGER NOTINCOM,TEMPP,DOLIB,DOFAIL,CT,YV,DOEXTR;
   INTEGER ENTPNT,DOHEAD,FILDEX,MAXFIL,GOGDO,EXTR,INTFIL,RENTLIB,GASLIB;
   INTEGER WANTNOHDR,BTHLIB;
   LABEL ENDER,LAB;
   EXTERNAL BOOLEAN RPGSW;	! true iff CCL start;

DEFINE	WILLDO=1,HAVDON=2, ERROR=4; 


   DEFINE MAXCOMP=70;
   DEFINE EXTRACT=1, HEADBIT=2, DOITBIT=4, GOGBIT=8, KLUGEBIT='4000;

DEFINE DOCCL=TRUE;	! set true for automatic pass 2;

   STRING ARRAY ORDER,FILES[1:MAXCOMP]; INTEGER ARRAY BITS[1:MAXCOMP];
   INTEGER ARRAY SPEC[1:10],BUFR,SYMBLOK[0:'23];
   STRING ARRAY FILLST[1:20];
   INTEGER ARRAY ENTRS[0:299];
   INTEGER ARRAY DOTHIS[1:20];
INTEGER CMUSW,STANSW,TYMSW;

STRING SITEID;
REQUIRE "<><>" DELIMITERS;
IFC EQU(COMPILER!BANNER[LENGTH(SCANC(COMPILER!BANNER,"-",NULL,
	"IA"))+1 FOR 8],"TYMSHARE") THENC
   DEFINE TYMSWC=<TRUE>; ELSEC DEFINE TYMSWC=<FALSE>; ENDC;
REQUIRE UNSTACK!DELIMITERS;

IFCR DOCCL THENC 
INTEGER RPGCHL,RPGEOF;
ENDC

! Break tables:;
define EndDscr= 1;  ! break on CR or ^V (end-of-DSCR);
define sepRate= 2;  ! break on CR, comma or ^Y (right arrow???);
DEFINE TOCRLF=  8;  ! break on lineFeed, ignore CR,FF;
DEFINE OVERDEL= 9;  ! break anything but space or tab;
DEFINE KLUGETB=13;  ! break on line feed, append;
DEFINE COMDEL= 11;  ! break on character DELIM (dynamic, for comments);
INTEGER DELIM;		! break character for COMDEL (pass comments);

! channels:	(and [RPGCHL] if we are doing CCL);
INTEGER BINI,	! binary input (mode 8);
	BINO,	! binary output (mode 8);
	COMO,
	FUNI,	! used for checking file times (lookups only);
	SYMO,
	TTY,
	DSKI,	! disk input file (ascii);
	DSKO;	! disk output file (ascii);
PROCEDURE CPYFIL(STRING InputFile, OutputFile, FIRSTLINE);
! Copies file named "inputFile" onto "OutputFile" 
	beginning with FirstLine.  Break table used: KLUGETB
Uses DSKI, DSKO
;
	begin
	INTEGER I,J;
	LOOKUP(DSKI, InputFile, I_0);
	 IF I THEN USERERR(1,1,"TROUBLE LOOKING UP:"& InputFile );
	ENTER(DSKO, OutputFile, J_0);
	 IF J THEN USERERR(0,0,"TROUBLE WITH ENTER ON:"& OutputFile );
	IF LENGTH(FIRSTLINE) THEN OUT(DSKO,FIRSTLINE);
	DO Out(dsko,INPUT(DSKI,KLUGETB)) UNTIL EOF;
	CLOSE(DSKO);
	CLOSE(DSKI);
	end;


INTEGER PROCEDURE FILTIM;
! returns the file write time of the most recent file.  
  (monotonic increasing value, but regard it as indivisible)
;
begin INTEGER ARRAY X[0:6];
FILEINFO(X);
RETURN ( (IFC TYMSWC THENC (X[1] LAND '140000) LSH 9 ELSEC
	(X[1] LAND '700000) LSH 8 ENDC) LOR
	((X[2] LAND '7777) LSH 11) LOR ((X[2] LSH -12)
		LAND '3777));
END "FILTIM";


PROCEDURE TIMCHK(STRING S1,S2;INTEGER NUM);
begin INTEGER TIM3,TIM2,FLG; STRING S3;
TIM2_0;		! tim2 is the maximum filtim for all files in s2;
WHILE length(S3_SCAN(S2,SepRate,TIM3)) 
   DO begin
	LOOKUP (FUNI,S3,FLG);
	 IF FLG NEQ 0 THEN begin TIM2_(-1 lsh -1); DONE; END;
	TIM2_TIM2 MAX FILTIM;
      END;
IF RENTLIB OR BTHLIB
 THEN LOOKUP (FUNI,"SAH"&S1[4 TO INF]&".REL",FLG)
 ELSE LOOKUP (FUNI,S1&".REL",FLG);
IF NOT RENTLIB AND BTHLIB THEN begin
	IF FLG=0 
	 THEN begin TIM3_FILTIM; LOOKUP (FUNI,S1&".REL",FLG); END 
	 ELSE TIM3_0; END;
IF FLG NEQ 0 OR TIM2 GEQ (TIM3 MAX FILTIM)
 THEN BITS[NUM]_BITS[NUM] LOR DOITBIT;
END "TIMCHK";



PROCEDURE KLUGE(INTEGER COMNO);
	begin
	IF RPGSW THEN begin BITS[I]_BITS[I] LOR DOITBIT; RETURN; END;
	IF not (BITS[COMNO] LAND KLUGEBIT) THEN begin
		TIMCHK(ORDER[COMNO],FILES[COMNO],COMNO); RETURN; END;
	IF EQU(ORDER[COMNO],"SAIHED") THEN
		begin
		FILES[COMNO]_"SAIHED.FAI,HEAD";
		TIMCHK(ORDER[COMNO],"SAIHED.FAI,HEAD",COMNO);
		end
	ELSE IF EQU(ORDER[COMNO],"SAILEP") THEN
		begin
		CPYFIL("LEPRUN","SAILEP.FAI","SEARCH HDRFIL"&CRLF);
		TIMCHK("SAILEP","LEPRUN,HDRFIL.FUN,GOGOL,HEAD",COMNO);
		FILES[COMNO]_"SAILEP.FAI/R";
		end
	ELSE IF EQU(ORDER[COMNO],"SAIREM") THEN
		begin
		CPYFIL("WRDGET","SAIREM.FAI","SEARCH HDRFIL"&CRLF);
		TIMCHK("SAIREM","WRDGET,HDRFIL.FUN,GOGOL,HEAD",COMNO);
		FILES[COMNO]_"SAIREM.FAI/R";
		end
	ELSE
		begin
		OUTSTR("SURPRISE USE OF HAIRY KLUGE: "&ORDER[COMNO]&"
TYPE ANY KEY TO GO ON (SHOULD BE OK)");
		INCHRW;
		TIMCHK(ORDER[COMNO],FILES[COMNO],COMNO);
		end;
	end;



   PROCEDURE LIBHED(STRING FLN);  COMMENT PROCEDURE TO GROVEL OVER SAIHED.REL;
   begin "LIBHED"
      INTEGER COUNT,TYPEWD,BLKSIZ,BRK,EOF; DEFINE SRC="BINI",DST="BINO";
      INTEGER PERLINE;
      INTEGER ARRAY BLOCK[0:17];

      PROCEDURE GETBLK;
      begin "GETBLK"
	 IF COUNT=0 THEN begin
	    TYPEWD _ WORDIN(SRC);
	    COUNT _ TYPEWD LAND '777777;
	    TYPEWD _ TYPEWD LSH -18
	 end;
	 WORDIN(SRC);
	 ARRYIN(SRC,BLOCK[0],BLKSIZ _ COUNT MIN 18);
	 COUNT _ COUNT - BLKSIZ
      end "GETBLK";

      PROCEDURE PUTBLK(INTEGER TYP, VAL1, VAL2);
      begin "PUTBLK"
	 INTEGER CT;
	 WORDOUT(DST,TYP LSH 18 + (CT_CASE TYP OF (0,0,2,0,1,1,2)));
	 WORDOUT(DST,IF TYP=5 THEN '2 LSH 33 ELSE 0);
	 WORDOUT(DST,VAL1);
	 IF CT=2 THEN WORDOUT(DST,VAL2);
      end "PUTBLK";

      STRING PROCEDURE R50TO7(INTEGER SYM); begin "R50TO7"
	COMMENT CONVERT RADIX50 TO ASCII;
			INTEGER CHAR; string result;
	result_null;
	While sym >0 
	   do begin
		CHAR_SYM MOD '50; sym_ sym div '50;
		result_ result & 
			(	IF CHAR = 0	THEN (0+" ")
			 ELSE IF CHAR LEQ 10	THEN CHAR+("0"-1)
			 ELSE IF CHAR LEQ 36	THEN CHAR+("A"-11)
			 ELSE IF CHAR=37	THEN (0+".")
			 ELSE IF CHAR=38	THEN (0+"$")
						ELSE (0+"%")	);
	      end;
	RETURN(result)
	end "R50TO7";

      IF not DOLIB THEN RETURN;

      OUTSTR("COPYING (SPECIALLY) SAIHED.REL
");

      LOOKUP(SRC,FLN,COUNT);
	IF COUNT NEQ 0 THEN USERERR (0,0,"MISSING " & FLN);

      PERLINE_COUNT_0;
      DO GETBLK UNTIL TYPEWD=2;
	SYMO_GETCHAN;
      OPEN(SYMO,"DSK",0,0,3,I,I,I); IF I THEN USERERR(0,0,"NO DSK TODAY");
      ENTER(SYMO,"GOGTAB.DEF",I); IF I THEN USERERR(0,0,"CANT ENTER GOGTAB.DEF");
	      OUT(SYMO,"REQUIRE ""[][]"" DELIMITERS;"&CRLF&
	"COMMENT SYMBOLIC USER TABLE INDICES");
      DO begin
	 INTEGER B,C;
	 C_BLOCK[0];
	 IF (LDB(POINT(6,C,5)) LAND '74) = '44 THEN begin
	    PUTBLK(4,B_C LAND '37777777777,0);
	    PUTBLK(6,B,0);
	    PUTBLK(2,C,BLOCK[1]);
	    IF not (PERLINE LAND '37) THEN OUT(SYMO,";"&CRLF&CRLF&"DEFINE ")
	    ELSE OUT(SYMO,IF not (PERLINE LAND 3) THEN ","&CRLF ELSE ",");
	    OUT(SYMO,R50TO7(B)&"=['"&CVOS(BLOCK[1])&"]");
	    PERLINE_PERLINE+1;
	    PUTBLK(5,0,0);
	 end;
	 GETBLK
      end UNTIL TYPEWD=5;
      OUT(SYMO,";"&CRLF&CRLF&"REQUIRE UNSTACK!DELIMITERS;"); RELEASE(SYMO);

   COMMENT AS FUDGE2 DOES NOT COPY THE LAST ELEMENT WE MUST PROVIDE A DUMMY;
      PUTBLK(0,0,0);

      CLOSE(SRC);
   end "LIBHED";



   PROCEDURE LIBMAK  (STRING F;INTEGER ITYP);
   begin
      STRING FILN; INTEGER ETWAS;
      BEOF_0; ENTPNT_ETWAS_0;
      IF DELETING THEN begin "DEL FAIL"
	 LOOKUP(BINI,F&".FAI",I);
	IF I=0 THEN begin
	 RENAME (BINI,"",0,I);
	 OUTSTR((IF I THEN "RENAME DIFFICULTY WITH " ELSE NULL)&
	  F&(IF I THEN ".FAI  " ELSE ".FAI DELETED  "));END;
	 CLOSE (BINI);
	 ETWAS_TRUE;
      end "DEL FAIL";
      IF ITYP NEQ 0 THEN FILN_"SAH"&F[4 TO INF]&".REL" ELSE
      FILN_F&".REL";
      IF EQU(F,"SAIHED")  THEN
       LIBHED(FILN)
	ELSE IF DOLIB THEN begin "COP FIL"
	   LOOKUP	(BINI,FILN,I);
	   IF not I THEN OUTSTR( "COPYING "&FILN) ELSE
		OUTSTR ("MISSING "&FILN);
	   ETWAS_TRUE;
	   SYMBLOK[1]_SYMCNT_0;
	   IF not I THEN WHILE not BEOF DO begin "COP BLK"
	      DEFINE WORD="BUFR[0]";
	      DO WORD _ WORDIN(BINI) UNTIL BEOF or WORD neq 0;
	      TYPP_WORD LAND '77000000;
	      CCOUT _ WORD LAND '777 ;
	      ARRYIN (BINI,BUFR[1],(CCOUT*19+17)/18);
	      IF TYPP='4000000 THEN begin "ENTRY BLOCK"
		 ARRBLT(ENTRS[ENTPNT],BUFR[2],CCOUT);
		 ENTPNT_ENTPNT+CCOUT;
	      end "ENTRY BLOCK" ELSE
	      begin "NOT ENTRY"
		 IF ENTPNT THEN begin "WRITE ENTRY"
		    WORDOUT(BINO,'4000000+ENTPNT);
		    FOR I_0 STEP 18 UNTIL ENTPNT-1 DO begin "WR ECH"
		       WORDOUT(BINO,0);
		       ARRYOUT(BINO,ENTRS[I],18 MIN (ENTPNT-I));
		    end "WR ECH"
		 end "WRITE ENTRY";
		 ENTPNT_0;
		 IF TYPP = '5000000 AND SYMCNT THEN begin "END BLOCK"
		 COMMENT THIS IS THE END BLOCK -- FORCE OUT SYMBOLS.;
		    SYMBLOK[0] _ '2000000 +SYMCNT ;
		    ARRYOUT (BINO,SYMBLOK[0],SYMCNT+2);
		 end "END BLOCK";
		 IF TYPP  neq '2000000  THEN begin "NOT SYMBOLS"
		 COMMENT COPY THE BLOCK TO THE OUTPUT FILE;
		    ARRYOUT (BINO,BUFR[0],CCOUT+2);
		 end "NOT SYMBOLS" ELSE
	      COMMENT THESE ARE SYMBOLS. COPY THEM IF SYMBOLS
		 ARE REQUESTED.  OTHERWISE,
		 IGNORE UNLESS INTERNAL OR EXTERNAL.;
		 FOR I_2 STEP 2 UNTIL CCOUT+1 DO
		  IF LDB(POINT(1,BUFR[I],2)) neq 1 THEN
		   begin "SYMS"
		      SYMCNT _ SYMCNT +2;
		      SYMBLOK[SYMCNT]_BUFR[I];
		      SYMBLOK[SYMCNT+1]_BUFR[I+1];
		      SYMBLOK[1]_SYMBLOK[1] LOR (((BUFR[1]
		       ROT (2*I)) LAND '17 ) ROT (-2*SYMCNT));
		   COMMENT LAST LINE WAS UPDATING RELOCATION BITS.;
		      IF SYMCNT ='22 THEN begin
			 SYMBLOK[0] _ '2000022 ;
			 ARRYOUT (BINO,SYMBLOK[0],'24);
			 SYMCNT_SYMBLOK[1]_0;
		      end;
		   end "SYMS";
		 IF TYPP ='5000000 THEN DONE
	      end "NOT ENTRY"
	   end "COP BLK"
	end "COP FIL";
      IF DELETING THEN begin "DEL FIL"
	 CLOSE (BINI);
	 LOOKUP (BINI,FILN,I);
	 RENAME (BINI,"",0,I);	ETWAS_TRUE;
	 OUTSTR((IF I THEN "  RENAME FAILURE FOR " ELSE "  ")&
	  FILN & (IF I THEN NULL ELSE " DELETED"));
      end "DEL FIL";
      IF ETWAS THEN TYPE NULL EOM;
   end;


   BOOLEAN PROCEDURE YESNO(STRING S);
   begin
      OUTSTR(S&"?");
      RETURN(IF (YV_INCHWL)="N" THEN FALSE ELSE YV)
   end "YESNO";
COMMENT -- BLOCK TYPE MISMATCH -- HAVE"YESNO", NEED ;

   BOOLEAN PROCEDURE SUBEQU(STRING S1,S2);
   RETURN(EQU(S1,S2[1 FOR LENGTH(S1)]));

   STRING PROCEDURE COMPRESS(STRING L,M);
   begin "COMPRESS"
      IF DSCRING or NOTINCOM or M=";" or not LENGTH(M)
       or SUBEQU("COMPIL",M) THEN RETURN(NULL)
	ELSE RETURN(L&CRLF)
   end "COMPRESS";

   PROCEDURE GETLINE;
   begin "GETLINE"
      LINE1_LINE_INPUT(DSKI,TOCRLF);
      TS_SCAN(LINE1,OVERDEL,I);
      IF not DSCRING and SUBEQU("DSCR",LINE1) THEN DSCRING_TRUE;
      IF SUBEQU("COMMENT",LINE1) or 
       SUBEQU("Comment",LINE1) or 
	SUBEQU("comment",LINE1) THEN
	 begin
	    TS_SCAN(LINE1_LINE1[8 TO INF],OVERDEL,I);
	    if i leq 0
		 then usererr(0,0,"Ill-formatted Comment:"&line)
		 else if delim=i 
		     then delim_lop(line1)	! table set ok;
		     else SETBREAK(COMDEL,DELIM_lop(line1),NULL,"IN");
	    I_0; TS_SCAN(LINE1,COMDEL,BRKCHR); 
	    While BRKCHR neq DELIM DO LINE1_INPUT(DSKI,COMDEL);
	    LINE1_NULL
	 end;
      OUT(DSKO,COMPRESS(LINE,LINE1));
		! '26 = ^V = XOR = "end-of-dscr";
      IF DSCRING and (LINE1='26 or LINE1=";") THEN DSCRING_FALSE;
   end "GETLINE";


   BOOLEAN PROCEDURE FIND(STRING S);
   begin "FIND"
      FOR COMNO_1 STEP 1 UNTIL MAXTHS DO
       IF EQU(S,ORDER[COMNO]) THEN RETURN(TRUE);
      RETURN(FALSE)
   end "FIND";


   PROCEDURE MARKIT(INTEGER C);
   begin
      INTEGER I;
      FOR I_1 STEP 1 UNTIL MAXFIL DO
       IF EQU(FILES[C],FILLST[I]) AND (BITS[C] LAND DOITBIT) THEN begin
	  IF BITS[C] LAND GOGBIT THEN GOGDO_TRUE;
	  DOTHIS[I]_TRUE; DONE
       end;
      IF BITS[C] LAND EXTRACT THEN FILES[C]_ORDER[C]&"/R";
   end "MARKIT";
COMMENT -- BLOCK TYPE MISMATCH -- HAVE"MARKIT", NEED ;



procedure getspecification;
begin "GETSPECS"
DEFINE SavedSpecs="(TYMSW,CMUSW,STANSW,RENTLIB,EACHASK," &
		"WILLTELL,DELETING,DOLIB,GASLIB,BTHLIB)";
IFCR DOCCL THENC 
 IF RPGSW THEN begin
   OPEN (RPGCHL_GETCHAN,"DSK",'14,1,0,RPGEOF,RPGEOF,RPGEOF);
   LOOKUP (RPGCHL,("000"&CVS(CALL(0,"PJOB")))[INF-2 FOR 3]&
	"SCI.TMP",RPGEOF);
   IF RPGEOF=0 THEN begin
	FORLC spec=SavedSpecs DOC "spec_WORDIN(RPGCHL);" ENDC
	if call(0,"PJOB") neq WORDIN(RPGCHL)
	 then usererr(0,0,"got a BAD CCL file for SCISS (pass 2?)");
      END
  END;
 IF NOT RPGSW OR RPGEOF NEQ 0 THEN begin 
ENDC

OUTSTR("SITE ID (<CR> OK FOR "&IFC TYMSWC THENC "TYMSHARE"
	ELSEC "SU-AI" ENDC &") = ");
SITEID_INCHWL;
STANSW_TYMSW_CMUSW_0;
IF EQU(SITEID,"SU-AI") THEN STANSW_1;
IF EQU(SITEID,"TYMSHARE") THEN TYMSW_1;
IF EQU(SITEID,"CMU") THEN CMUSW_1;
IF LENGTH(SITEID=0) THEN IFC TYMSWC THENC TYMSW ELSEC STANSW ENDC_1;

IF TYMSW THEN DELETING_FALSE;

   IF not YESNO("STANDARD") THEN begin "ASK"
      STRING ANSWER; INTEGER FROMPASS1;

      OUTSTR("
TYPE THE NUMBERS OF THOSE PARAMETERS YOU WISH TO AFFECT:
 INDEX	DESCRIPTION
");
IF NOT CMUSW THEN
      OUTSTR(IF not RPGSW THEN "
   1	PASS 2 NOW
   2	DON'T CHAIN TO FAIL
   3	DON'T CREATE INTERMEDIATE FILES
   4	MAKE RE-ENTRANT LIBRARY
   5	SELECT ENTRIES FROM PROMPT-LIST
   6	SPECIFY ENTRIES EXPLICITLY
   7	DON'T DELETE INTERMEDIATE FILES (PASS 2)
   8	DON'T MAKE A LIBRARY (PASS 2)
   9	MAKE LOW SEG LIBRARY
  10	DO DELETE INTERMEDIATE FILES (PASS 2)
" ELSE "
   4	MAKE A RE-ENTRANT LIBRARY
   5	SELECT ENTRIES FROM PROMPT-LIST
   6	SPECIFY ENTRIES EXPLICITLY
   7	DON'T DELETE INTERMEDIATE FILES
   8	DON'T MAKE A LIBRARY
   9	MAKE LOW SEG LIBRARY
  10	DO DELETE INTERMEDIATE FILES
");
IF CMUSW THEN
  OUTSTR(IF not RPGSW THEN "
   1	PASS 2 NOW
   2	DON'T CHAIN TO FAIL
   3	DON'T CREATE INTERMEDIATE FILES
   4	MAKE RE-ENTRANT LIBRARY
   5	SELECT ENTRIES FROM PROMPT-LIST
   6	SPECIFY ENTRIES EXPLICITLY
   7	DON'T DELETE INTERMEDIATE FILES (PASS 2)
   8	DON'T MAKE A LIBRARY (PASS 2)
   9	MAKE LOW SEG LIBRARY
  10	DO DELETE INTERMEDIATE FILE (PASS 2)
  11	MAKE GAS LIBRARY (IMPLIES REENTRANT)
" ELSE "
   4	MAKE A RE-ENTRANT LIBRARY
   5	SELECT ENTRIES FROM PROMPT-LIST
   6	SPECIFY ENTRIES EXPLICITLY
   7	DON'T DELETE INTERMEDIATE FILES
   8	DON'T MAKE A LIBRARY
   9	MAKE LOW SEG LIBRARY
  10	DO DELETE INTERMEDIATE FILES
  11	MAKE GAS LIBRARY (IMPLIES REENTRANT)
");

      OUTSTR("*");
      ANSWER_INCHWL;
      FROMPASS1_FALSE;
      WHILE LENGTH(ANSWER) DO begin
	 LABEL TOOBIG; INTEGER ANSCODE,I;
	 ANSCODE_INTSCAN(ANSWER,I); IF not ANSCODE THEN DONE;
	 IF not RPGSW THEN CASE ANSCODE MIN 11 OF begin
	    [1]	 begin
	       RPGSW_TRUE; FROMPASS1_TRUE
	    end;
	    [2]	 DOFAIL_FALSE;
	    [3]	 INTFIL_FALSE;
	    [4]	 RENTLIB_TRUE;
	    [5]	 EACHASK_TRUE;
	    [6]	 WILLTELL_TRUE;
	    [7]	 DELETING_FALSE;
	    [8] DOLIB_FALSE;
		[9] BTHLIB_FALSE;
		[10] DELETING_TRUE;
	     [11] IF NOT CMUSW THEN  GO TO TOOBIG	ELSE 
			RENTLIB_GASLIB_TRUE;
	    [10] 
	 end ELSE
	 CASE (CASE ANSCODE MIN 12 OF (0,0,0,0,3,4,5,1,2,6,7,8,9)) OF begin
	     [1]  DELETING_FALSE;
	     [2]  DOLIB_FALSE;
	     [3]  RENTLIB_TRUE;
	     [4]  EACHASK_TRUE;
	     [5]  WILLTELL_TRUE;
	[6] BTHLIB_FALSE;
	[7] DELETING_TRUE;
	     [8] IF NOT CMUSW THEN GO TO TOOBIG ELSE RENTLIB_GASLIB_TRUE;
	     [9]
	      TOOBIG:OUTSTR(CVS(ANSCODE)&" TOO BIG -- IGNORED"&('15&'12))
	  end;
      end;
   end "ASK";
IFCR DOCCL THENC 
 END;
 IF NOT RPGSW THEN begin
   OPEN (RPGCHL_GETCHAN,"DSK",'14,0,1,RPGEOF,RPGEOF,RPGEOF);
   ENTER(RPGCHL,("000"&CVS(CALL (0,"PJOB")))[INF-2 FOR 3]&
	"SCI.TMP",RPGEOF);
	FORLC spec=SavedSpecs DOC "WORDOUT(RPGCHL,spec);" ENDC
   WORDOUT(RPGCHL,call(0,"PJOB"));
   RELEASE(RPGCHL) 
 END;
ENDC
END "GETSPECS";
COMMENT MAIN EXECUTION STARTS HERE;

   OPEN( DSKI_GETCHAN,"DSK",  1, 2,0, 400,BRKCHR,EOF);
   OPEN( DSKO_GETCHAN,"DSK",  1, 0,2,   0,W,W);
   OPEN( BINI_GETCHAN,"DSK",'10, 4,0, 400,BRKCHR,BEOF);
   OPEN( BINO_GETCHAN,"DSK",'10, 0,4,   0,W,W);
   OPEN( COMO_GETCHAN,"DSK",  1, 0,2,   0,W,W);
   OPEN( FUNI_GETCHAN,"DSK",  0, 0,0,   junk,junk,junk);

SETBREAK(EndDscr, '26&'15, '12, "INP"); ! '26=^V = XOR = "end-of-dscr";
SETBREAK(SepRate, ","&'15&'31, null, "IP"); ! '31=^Y = right-arrow ???;
SETBREAK(TOCRLF,  '12, '15&'14, "IN");
SETBREAK(OVERDEL, '40&'11, NULL, "XNR");
SETBREAK(KLUGETB, '12, NULL, "INA");
delim_-2;		! indicate COMDEL not set;

ttyup(true);

GASLIB_EACHASK_WILLTELL_GOGDO_RENTLIB_WANTNOHDR_FALSE;
   BTHLIB_DELETING_DOLIB_DOHEAD_DOEXTR_DOFAIL_INTFIL_TRUE;
getspecification;
   IF RENTLIB THEN DOLIB_TRUE;
   W_CALL (W,"PJOB");
   COMNAM_"0"&CVS( W % 10 )&CVS( W MOD 10)&"FAI.TMP";

   I_0;
COMMENT READ IN THE ORDER CODE;
   GOGDO_FALSE; COMMENT ON IF COMPIL SPEC WANTS GOGOL;
   LOOKUP	(DSKI,"ORDER",I);
   IF I THEN begin
      TYPE "CAN'T FIND ORDER" EOM; GO ENDER
   end;
   LINE_READ; COMMENT GET COMMENT LINE;
   LINE_READ; COMMENT GET REST OF COMMENT LINE;
   MAXTHS_MAXFIL_0;
   DOTHIS[1]_FALSE; ARRBLT(DOTHIS[2],DOTHIS[1],19);
   WHILE not SUBEQU("END",FFFF_READ) DO begin "GSPEC"
      STRING GGGG;  GGGG_FFFF[1 TO 3]; FFFF_FFFF[5 TO INF];
      EXTR_0;
      IF EQU("NAM",GGGG) THEN begin "LIBRARY NAME"IBNAM_"LIBSA"&(GGGG_SCAN(FFFF,SepRate,I))&".REL";
	 HLBNAM_"HLBSA"&GGGG&".REL";
	 GASNAM_"GLBSA"&GGGG&".REL";
      end "LIBRARY NAME" ELSE
      IF EQU("ALL",GGGG) THEN
       WHILE LENGTH(FFFF) DO begin "PREP HDRFIL"
	  GGGG_SCAN(FFFF,SepRate,I); IF GGGG="!" THEN
	   GGGG_GOGFIL_GGGG[2 TO INF];
	  FILLST[MAXFIL_MAXFIL+1]_GGGG;
	  DOTHIS[MAXFIL]_TRUE
       end "PREP HDRFIL" ELSE begin "LIB LIST"
		LABEL DONEONELIBL;
	  IF EQU("HDR",GGGG) THEN begin "STD LIB"
		IF FFFF[INF FOR 1]="*" THEN begin
			IF GASLIB THEN begin
				OUTSTR(READ&" NOT BEING DONE BECAUSE THIS IS GASSY"&CRLF);
				GO TO DONEONELIBL;
			end ELSE FFFF_FFFF[1 TO INF-1];
		end;
	     EXTR_IF EQU(FFFF,GOGFIL) THEN EXTRACT+GOGBIT ELSE EXTRACT;
	     FOR I_1 STEP 1 UNTIL MAXFIL DO IF EQU(FFFF,FILLST[I]) THEN DONE;
	     IF I>MAXFIL THEN FILLST[MAXFIL_MAXFIL+1]_FFFF
	  end "STD LIB" ELSE IF EQU("HED",GGGG) THEN EXTR_HEADBIT+KLUGEBIT
	ELSE IF EQU("FAI",GGGG) THEN EXTR_0 ELSE EXTR_KLUGEBIT;
	  LINE_(READ)[2 TO INF];
	  WHILE LENGTH(LINE) DO begin "ONE LIB"
	     ORDER[MAXTHS_MAXTHS+1]_"SAI"&SCAN(LINE,SepRate,J);
	     BITS[MAXTHS]_EXTR;
	     FILES[MAXTHS]_FFFF
	  end "ONE LIB";

DONEONELIBL:
       end "LIB LIST"
   end "GSPEC";
   CLOSE(DSKI);

   IF not WILLTELL THEN begin "GET ORDER"
      INTEGER K,KK,J; K_0;
      IF EACHASK THEN TYPE "TYPE `Y', `N', OR `DONE'" EOM;
      FOR I_1 STEP 1 UNTIL MAXTHS DO begin
	 TS_ORDER[I];
	 IF not EACHASK or (KK_YESNO(TS))="Y" THEN begin
	KLUGE(I);
	    MARKIT(I)
	 end ELSE IF KK="D" THEN
	 IF (I_I-1)<0 or K=0 THEN DONE ELSE EACHASK_FALSE;
	 K_KK
      end
   end "GET ORDER" ELSE
   begin "TAKE ORDER"
      TS_NULL;
      TYPE "TYPE LIBRARY TITLES, `DONE' WHEN DONE" EOM;
      NEEDNEXT WHILE not EQU("DONE",TS) DO begin
	 OUTSTR("*");
	 TS_INCHWL; NEXT;
	 IF SUBEQU("SAI",TS) and LENGTH(TS)=6 and FIND(TS) THEN begin
	KLUGE(I);
	    MARKIT(COMNO)
	 end ELSE
	 TYPE TS&" INVALID -- TRY AGAIN " EOM;
      end;
   end "TAKE ORDER";



   IF RPGSW THEN begin "SECOND PASS -- PROCESS LIBRARY"
      IF DELETING AND not WANTNOHDR THEN begin
	 LOOKUP(BINI,"HDRFIL",I);
	IF I=0 THEN begin
	 RENAME (BINI,"",0,I);
	 IF I THEN TYPE "RENAME DIFFICULTY WITH HDRFIL" EOM
	  ELSE TYPE "HDRFIL DELETED" EOM; END;
	 CLOSE (BINI);
	 IF RENTLIB OR BTHLIB THEN begin
	    LOOKUP(BINI,"SAIREN.FAI",I);
	    RENAME(BINI,"",0,I);
	    IF I THEN TYPE "RENAME DIFFICULTY WITH SAIREN" EOM
	     ELSE TYPE "SAIREN.FAI DELETED" EOM;
	    CLOSE (BINI)
	 end
      end;
IF DOLIB THEN FOR IQ_IF GASLIB THEN 2 ELSE IF RENTLIB THEN 1
	ELSE 0 STEP 1 UNTIL IF GASLIB THEN 2 ELSE IF RENTLIB
	OR BTHLIB THEN 1 ELSE 0 DO begin
	I_0;
	ENTER (BINO,(GASNAM_CASE IQ OF (LIBNAM,HLBNAM,GASNAM)),I);
      IF I THEN begin
	 TYPE "CAN'T ENTER "&GASNAM EOM; GO ENDER
      end;
      FOR COMNO_1 STEP 1 UNTIL MAXTHS DO IF BITS[COMNO] LAND DOITBIT THEN
       LIBMAK (ORDER[COMNO],IQ);
      CLOSE (BINO);	COMMENT THIS IS THE LIBRARY;
	END;

      IF DOLIB THEN begin
	 TYPE "RUN CARMEL ON YOUR NEW LIBRARY(S)!" EOM
      end
      ELSE begin
	 TYPE "READY FOR WHATEVER" EOM
      end;

   end "SECOND PASS -- PROCESS LIBRARY" ELSE begin "FIRST PASS"
      INTEGER PTYSW;

      ENTER (COMO,COMNAM,I);
      DOHEAD_DOEXTR_FALSE;
      IF I THEN TYPE "CANNOT ENTER COMMAND FILE" EOM;
      begin
	INTEGER FUNTIM,HEDTIM;

	COMMENT Check creation date of HDRFIL.FUN to see if we need a new one;
	LOOKUP(FUNI,"HDRFIL.FUN",I); IF I THEN WANTNOHDR_FALSE ELSE begin
	    FUNTIM_FILTIM; CLOSE(FUNI);
	    LOOKUP(FUNI,"HEAD",I); HEDTIM_FILTIM; CLOSE(FUNI);
	    LOOKUP(FUNI,"GOGOL",I); HEDTIM_FILTIM MAX HEDTIM; CLOSE(FUNI);
	    WANTNOHDR_IF FUNTIM>HEDTIM THEN TRUE ELSE FALSE;
	     end;
      end;
      IF not WANTNOHDR THEN OUT(COMO,"HDRFIL/R_HDRFIL"&CRLF);
      FOR COMNO_1 STEP 1 UNTIL MAXTHS DO
       IF BITS[COMNO] LAND DOITBIT THEN begin
	  STRING SRCFIL;
	  IF BITS[COMNO] LAND (EXTRACT LOR KLUGEBIT) THEN DOEXTR_TRUE;
	  IF BITS[COMNO] LAND HEADBIT THEN DOHEAD_TRUE;
	IF RENTLIB OR BTHLIB THEN OUT (COMO,"SAH"&ORDER[COMNO]
		[4 TO INF]&"/R_SAIREN.FAI,"&FILES[COMNO]&CRLF);
	IF NOT RENTLIB THEN OUT(COMO,ORDER[COMNO]&"/R_"&
	FILES[COMNO]&CRLF);
	  TYPE ORDER[COMNO]&" WILL BE ASSEMBLED" EOM
       end;
      OUT(COMO,"DSK:SCISS!"&CRLF);
      CLOSE(COMO); CLOSE(DSKO);
      IF RENTLIB OR BTHLIB THEN begin
	 ENTER(DSKO,"SAIREN.FAI",I); IF I THEN
	  USERERR(0,0,"TROUBLE WITH SAIREN");
	 OUT(DSKO,"?RENSW__1"&CRLF&CRLF);
	IF GASLIB THEN OUT(DSKO,"?GASSW__1"&CRLF&CRLF);
	 CLOSE(DSKO)
      end;
      IF DOHEAD and INTFIL THEN begin
	 ENTER(DSKO,"SAIHED.FAI",I); IF I THEN
	  USERERR(0,0,"TROUBLE WITH SAIHED");
	 WRITE CRLF&"?HEDSYM__1" EOM;
	 CLOSE (DSKO);
      end;



BAIL;
      IF INTFIL and DOEXTR THEN begin "CR INT FIL"
	 NOTINCOM_FALSE;
	    ENTER(DSKO,IF WANTNOHDR THEN "JUNK" ELSE "HDRFIL",I);
	    IF I THEN USERERR(0,0,"TROUBLE WITH HDRFIL");
	    WRITE "
UNIVERSAL HDRFIL
?ALWAYS__0" EOM;
	 CT_0; PTYSW_0; FILDEX_0;
	 WHILE TRUE DO begin "DO FILE"

	    boolean PROCEDURE nofilesleft; begin "OPNFIL"
	    if dscring 
	     then usererr(0,1,"Finished in middle of DSCR:"&file);
	    IF SUBEQU("HEAD",FILLST[FILDEX+1]) AND WANTNOHDR 
		THEN FILDEX_FILDEX+1;
	    for FILDEX_FILDEX+1 step 1 until MAXFIL 
	     DO IF DOTHIS[FILDEX] THEN done;
	    if fildex > maxfil then return(true);
	    FILE_FILLST[FILDEX];
	    CLOSE(DSKI);
	    DSCRING_FALSE;
	    OUTSTR("LOOKING AT "&FILE&CRLF);
	    LOOKUP(DSKI,FILE,I);
	      IF I THEN USERERR(0,0,"CAN'T FIND "& FILE);
	    EOF_FALSE;
	    return(false);
	    end "OPNFIL";

	    if nofilesleft THEN DONE;
	    DO begin "READ THE LINES"
	       GETLINE;
	       IF SUBEQU("COMPIL",LINE) THEN begin "IS A COMPILE"
		  IF CT=MAXTHS+1 or not PTYSW and CT=MAXTHS THEN DONE;
		  IF EQU(FILE,GOGFIL) and not GOGDO THEN
		   begin
		      OUTSTR("ABANDONING "&FILE&" AFTER HDRFIL"&CRLF);
		      WRITE "END" EOM; COMMENT END OF UNIVERSAL FILE;
		      if nofilesleft THEN DONE "DO FILE"
		   end;
		  notincom_ not FIND(TS_"SAI"&LINE[8 FOR 3])
				or BITS[COMNO] LAND (DOITBIT+EXTRACT) 
					neq DOITBIT+EXTRACT;
		  IF not notincom
		  THEN begin "WANT THIS ONE"
		       WRITE "END" EOM; CLOSE(DSKO);
		       CT_CT+1;
		       ENTER(DSKO,TS&".FAI",I);
		       IF I THEN USERERR(0,0,"TROUBLE WITH SAI"&TS);
		       TYPE TS&" FOUND" EOM;
		       IF EQU(TS,"PTY") THEN PTYSW_TRUE;
		       COMMNT_DSCRING_FALSE;
			WRITE "SEARCH HDRFIL" EOM;
		       WRITE LINE EOM
		    end "WANT THIS ONE"
	       end "IS A COMPILE"
	       ELSE NOTINCOM_ NOTINCOM or SUBEQU("ENDCOM",LINE1);
	    end "READ THE LINES"
	     UNTIL EOF or ((MAXTHS=CT) and not PTYSW) or (CT=MAXTHS+1);
	    IF MAXTHS=CT and not PTYSW or CT=MAXTHS+1 THEN DONE;
	 end "DO FILE";
      end "CR INT FIL";

      CLOSE(DSKO);

   COMMENT NOW CHAIN TO FAIL, ONE WAY OR ANOTHER;

      SPEC[1]_CVSIX("SYS");
      SPEC[2]_CVFIL(IF STANSW THEN "FAIL.DMP" ELSE "FAIL",SPEC[3],SPEC[5]);
      SPEC[4]_IF STANSW THEN 1 ELSE 0;
      SPEC[6]_0;
      IF DOFAIL THEN CALL(
       (IF STANSW THEN 0 ELSE '1000000)+POINT(0,SPEC[1],35),
       IF STANSW THEN "SWAP" ELSE "RUN"	   );
   end "FIRST PASS";

ENDER:

end "SCISS";
  Hç