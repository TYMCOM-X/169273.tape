;SORT

BEGIN SORT

IFN TENEX,<
UPR__400000
SYMTP__765000
>

^SORT:
IFN DEBSYM,<
	SKIPN	JOBSYM
	 JRST	MKSYTB
>
;PASS 1 - LOOK THRU THE OLD SYMBOL TABLE AND COUNT VARIOUS THINGS.

	SETZM	CLASST		;ZERO CLASS COUNTERS
	MOVE	A,[CLASST,,CLASST+1]
	BLT	A,CLASST+5
	HLRE	V,JOBSYM	;-N
	MOVN	V,V		;N
	SUBI	V,2
	HRL	V,V		;N-2,,N-2
	HRRZ	PV,JOBSYM	;ADDR
	ADD	PV,V		;N-2,,ADDR+N-2
	MOVEM	PV,OPTR		;SAVE POINTER
SYMLP1:	SKIPN	V,(PV)		;GET RADIX50
	 JRST	SYLP1Z		;NOTHING THERE
	MOVE	A,1(PV)		;A_VALUE, V_RADIX50
	MOVEI	B,0		;ASSUME "CLASS 0" = BLOCK/PROGRAM NAME
	LDB	T,[POINT 4,V,3]	;GET SYMBOL TYPE
	JUMPE	T,SYLP1A	;0 IS PROGRAM NAME
	CAIN	T,3
	 JRST	SYLP1A		;14 IS BLOCK NAME
IFN PADSYM,<
	CAIE	T,1	;4 IS NON-DELETED, NON-HALF-KILLED INTERNAL
	 JRST	NODOTS
	LDB	D1,[POINT 32,V,35]	;GET SYMBOL WITHOUT TYPE BITS
	IDIVI	D1,50*50	;FLUSH LAST TWO CHARACTERS
	CAME	D1,[<RADIX50 0,....XX>/<50*50>]
	 JRST	NODOTS
	SETZM	(PV)		;THIS IS A BOGUS SYMBOL DEFINED IN RAID
	SETZM	1(PV)		;FOR THIS PURPOSE OF PROVIDING SPACE
	JRST	SYLP1Z
NODOTS:
>;PADSYM
	PUSHJ	P,CLASS		;B_CLASS TYPE (1,2,3 OR 4)
SYLP1A:	AOSA	CLASST(B)	;COUNT EACH SYMBOL CLASS
SYLP1Z:	 AOS	CLASST+5	;COUNT ANOTHER FREE
	SUB	PV,[2,,2]
	JUMPG	PV,SYMLP1
;;FALL OFF PAGE

;NOW, HOW BIG IS SYMBOL TABLE GOING TO BE?
IFE TENEX,<
IFE FILESW,<
	MOVE	V,CLASST+5
	ADDM	V,CLASST+5	;NUMBER OF FREE WORDS
	MOVE	B,CLASST+4	;EXTRA WORDS FOR CLASS 4 SYMBOLS
	ADDI	B,12		;PLUS OVERHEAD WORDS
	CAMLE	B,CLASST+5	;SKIP IF THERE IS ROOM FOR IT ALL
	 JRST	TOOMAN
	MOVN	B,B
	ADDM	B,CLASST+5	;LEAVE COUNT OF FREE CELLS
TOOMA3:
>;NOT FILESW
IFN FILESW,<
	MOVEI	B,20
	MOVEM	B,CLASST+5
	MOVE	B,CLASST
	ADD	B,CLASST+1
	ADD	B,CLASST+2
	ADD	B,CLASST+3
	ADD	B,CLASST+4
	ASH	B,1
	ADD	B,CLASST+4
	ADD	B,CLASST+5
	ADDI	B,12		;NUMBER OF WORDS OF SYMBOL TABLE
	HRRZ	C,JOBSYM
	ADDI	C,-1(B)
	CORE	C,
	 JRST	4,.
	MOVN	D1,B
	HRLM	D1,JOBSYM
>;FILESW
	MOVE	A,JOBREL
	MOVEM	A,SAVJRL
IFE FILESW,<
	HLL	A,JOBSYM	;-WC,,MA-1 OF NEW SYMBOL TABLE
>
IFN FILESW,<
	MOVN	B,B
	HRL	A,B		;-WC,,MA-1 OF NEW SYMBOL TABLE
>
	ADDI	A,1
	MOVEM	A,NPTR		;SAVE AOBJN POINTER TO NEW SYMBOL TABLE
	HRRZM	A,NBASE		;SET BASE OF NEW SYMBOL TABLE
	HLRZ	B,OPTR		;OLD WC-2
	ADDI	A,1(B)		;LAST ADDRESS NEEDED
	MOVE	C,A		;SAVE THIS (IS LAST ADDRESS FOR BLT)
	HRRZ	A,A
	CORE	A,		;GET SOME CORE
	 JRST	4,.
>;NOT TENEX
IFN TENEX,<.FATAL FIGURE OUT WHAT TO DO HERE>
	MOVE	PNT,NBASE
	SETZM	(PNT)
	HRL	PNT,PNT		;NBASE,,NBASE
	ADDI	PNT,1		;SOURCE,,DEST FOR BLT
	BLT	PNT,(C)		;ZERO NEW CORE SPACE FOR SYMBOL TABLE
	MOVE	PNT,NBASE	;GET BASE ADDRESS AGAIN
	HRROS	(PNT)		;-1,, FLAGS THE NEW FORMAT SYMBOLS
	MOVEI	C,12		;POINTER TO BN
	MOVEM	C,1(PNT)	;BN POINTER
	ADD	C,CLASST	;PLUS NUMBER OF BN'S
	MOVEM	C,2(PNT)	;GIVES POINTER TO BS'S
	ADD	C,CLASST	;PLUS NUMBER OF BS'S (= NUMBER OF BN'S)
	MOVEM	C,3(PNT)	;GIVES POINTER TO FV'S
	ADD	C,CLASST+4	;PLUS NUMBER OF FV'S
	MOVEM	C,4(PNT)	;GIVES POINTER TO FF
	ADD	C,CLASST+5	;PLUS AMOUNT OF FREE SPACE
	MOVEM	C,5(PNT)	;GIVES POINTER TO CLASS1
	ADD	C,CLASST+1
	ADD	C,CLASST+1	;PLUS 2*CLASS1 SPACES
	MOVEM	C,6(PNT)	;POINTER TO CLASS2 SPACE
	ADD	C,CLASST+2
	ADD	C,CLASST+2
	MOVEM	C,7(PNT)	;POINTER TO CLASS3 SPACE
	ADD	C,CLASST+3
	ADD	C,CLASST+3
	MOVEM	C,10(PNT)	;POINTER TO CLASS4 SPACE
	ADD	C,CLASST+4
	ADD	C,CLASST+4
	MOVEM	C,11(PNT)	;POINTER TO THE END OF THE AREA

;PASS 2 - COPY SYMBOL NAMES TO NEW SYMBOL TABLE.  BUILD BN/BS AREAS

;PNT STILL CONTAINS NBASE

	SETZM	CLASST		;ZERO CLASS COUNTERS
	MOVE	B,[CLASST,,CLASST+1]
	BLT	B,CLASST+5
	SETOM	SVSTK
	SETOM	ID
	SETZM	PD
	MOVE	PV,OPTR		;GET POINTER TO OLD TABLE
SYMLP2:	SKIPN	V,(PV)		;GET RADIX50
	 JRST	SYLP2Z		;NOTHING THERE.
	MOVE	A,1(PV)		;A_VALUE; V_RADIX50
	LDB	T,[POINT 4,V,3]	;GET SYMBOL TYPE
	JUMPE	T,SYLP2B	;0 IS PROGRAM NAME
	CAIN	T,3
	 JRST	SYLP2C		;14 IS BLOCK NAME
	PUSHJ	P,CLASS		;B_CLASS TYPE (1,2,3 OR 4)
	AOS	C,CLASST(B)	;COUNT CLASS TYPE
	CAIN	B,3		;CLASS 3 SYMBOL?
	 MOVSS	1(PV)		;YES.  SWAP HALVES TO MAKE THE SORT WORK
	LSH	C,1		;DOUBLE COUNT TO MAKE INDEX
	ADDI	B,4(PNT)	;GET ADDRESS OF BASE OF CLASS
	ADD	C,(B)		;RELATIVE ADDRESS IN NEW SYMBOL TABLE+2
	ADDI	C,(PNT)		;ABSOLUTE ADDRESS+2
	MOVEM	V,-2(C)		;STORE RADIX50 OF SYMBOL
	HRLZ	M,ID		;GET BLOCK ID
	LSH	M,5		;SHIFT TO MAKE ROOM FOR INDEX/INDIRECT
	HRRI	M,1(PV)		;POINTER TO THE VALUE CELL
	MOVEM	M,-1(C)		;STUFF IN NEW SYMBOL TABLE
	JRST	SYLP2Z		;LOOP

SYLP2B:	MOVE	D3,PD		;HERE IF SYMBOL IS PROGRAM NAME
	MOVEI	A,0		;ARGUMENT TO SYLPOP
	CAMGE	D3,ID		;IF PD .LT. ID THERE WERE NESTED BLOCKS
	 PUSHJ	P,SYLPOP	;POP NESTED BLOCKS WITHIN PREVIOUS PD
	AOS	D3,ID		;COUNT NEW PROGRAM ID
	MOVE	D1,1(PNT)	;GET BASE OF BN AREA
	ADDI	D1,(PNT)
	ADDI	D1,(D3)		;PLUS CURRENT INDEX
	MOVEM	V,(D1)		;STORE CURRENT PROGRAM NAME IN BN SPACE
	MOVE	E,PD		;GET PD OF PREVIOUS PROGRAM
	MOVEM	D3,PD		;STORE NEW PD
	MOVE	D1,2(PNT)	;GET POINTER TO BS SPACE
	ADDI	D1,(PNT)
	ADDI	D1,(E)
	HRLZM	D3,(D1)		;LH POINTER TO CURRENT ID IN PREVIOUS PROG'S WORD
	JRST	SYLP2Z		;GET NEXT

SYLP2C:	AOS	D3,ID		;COUNT NEW BLOCK
	MOVE	D1,1(PNT)	;GET BASE OF BN AREA
	ADDI	D1,(PNT)
	ADDI	D1,(D3)		;PLUS CURRENT INDEX
	MOVEM	V,(D1)		;STORE CURRENT BLOCK NAME IN BN SPACE
	PUSHJ	P,SYLPOP	;A HAS BLOCK LEVEL.
SYLP2Z:	SUB	PV,[2,,2]
	JUMPG	PV,SYMLP2
	MOVE	D3,PD
	MOVE	D1,2(PNT)	;GET BASE OF BS AREA
	ADDI	D1,(PNT)
	ADDI	D1,(D3)		;PLUS CURRENT INDEX
	SETZB	A,(D1)		;FINISH BS LINKAGE FOR LAST PROGRAM
	CAMGE	D3,ID
	 PUSHJ	P,SYLPOP	;FINISH DANGLING BLOCK STRUCTURE
;;FALL OFF PAGE

;WE SORT THINGS HERE
	MOVE	B,5(PNT)		;FIRST ADDRESS FOR CLASS1
	MOVE	C,6(PNT)		;FIRST ADDRESS BEYOND CLASS1
	ADDI	B,(PNT)			;MAKE ADDRESSES ABSOLUTE
	ADDI	C,-2(PNT)		;MAKE ADDRESS WITHIN CLASS
	CAILE	C,(B)			;DON'T SORT ZERO OR ONE ITEMS
	 PUSHJ	P,SSORT			;SORT RANGE
	MOVE	B,6(PNT)		;FIRST ADDRESS FOR CLASS2
	MOVE	C,7(PNT)		;FIRST ADDRESS BEYOND CLASS2
	ADDI	B,(PNT)			;MAKE ADDRESSES ABSOLUTE
	ADDI	C,-2(PNT)		;MAKE ADDRESS WITHIN CLASS
	CAILE	C,(B)			;DON'T SORT ZERO OR ONE ITEMS
	 PUSHJ	P,SSORT			;SORT RANGE
	MOVE	B,7(PNT)		;FIRST ADDRESS FOR CLASS3
	MOVE	C,10(PNT)		;FIRST ADDRESS BEYOND CLASS3
	ADDI	B,(PNT)			;MAKE ADDRESSES ABSOLUTE
	ADDI	C,-2(PNT)		;MAKE ADDRESS WITHIN CLASS
	CAILE	C,(B)			;DON'T SORT ZERO OR ONE ITEMS
	 PUSHJ	P,SSORT			;SORT RANGE
	MOVE	B,10(PNT)		;FIRST ADDRESS FOR CLASS4
	MOVE	C,11(PNT)		;FIRST ADDRESS BEYOND CLASS4
	ADDI	B,(PNT)			;MAKE ADDRESSES ABSOLUTE
	ADDI	C,-2(PNT)		;MAKE ADDRESS WITHIN CLASS
	CAILE	C,(B)			;DON'T SORT ZERO OR ONE ITEMS
	 PUSHJ	P,SSORT			;SORT RANGE

;COPY SYMBOL VALUES TO NEW TABLE
	MOVE	B,5(PNT)		;FIRST CLASS1 VALUE
	MOVE	C,10(PNT)		;FIRST BEYOND CLASS3
	ADDI	B,(PNT)			;MAKE ADDRESSES ABSOLUTE
	ADDI	C,(PNT)
SYMLP3:	CAIL	B,(C)			;AT THE END YET?
	 JRST	SYML3A			;YES.
	MOVE	D1,@1(B)		;GET VALUE
	HRRM	D1,1(B)			;REPLACE POINTER WITH VALUE
	ADDI	B,2
	JRST	SYMLP3

SYML3A:	MOVE	B,10(PNT)		;FIRST CLASS4 VALUE
	MOVE	C,11(PNT)		;FIRST BEYOND CLASS4
	MOVE	D1,3(PNT)		;ADDRESS OF FULL WORD SPACE
	ADDI	B,(PNT)			;MAKE ADDRESSES ABSOLUTE
	ADDI	C,(PNT)
	ADDI	D1,(PNT)
	MOVE	D2,3(PNT)		;RELATIVE ADDRESS 
					;OF FULL WORD SPACE
	HRLI	D2,14			;SET INDEX FIELD
SYML3B:	CAIL	B,(C)			;AT THE END YET?
	JRST	SYMXIT			;YES, ALL DONE
	MOVE	D3,@1(B)		;GET VALUE
	MOVEM	D3,(D1)			;STORE IN FULL WORD SPACE
	DPB	D2,[POINT 23,1(B),35]	;STORE INDEX AND 
					; RELATIVE POINTER TO SYMBOL.
	ADDI	B,2			;ADVANCE TO NEXT SYMBOL
	ADDI	D1,1		;ADVANCE ABSOLUTE PTR TO FULL WD SPACE
	AOJA	D2,SYML3B	;ADVANCE RELATIVE PTR TO FULL WD SPACE

SYMXIT:	HRRZ	A,JOBSYM
	HRL	A,NPTR
	HLRE	B,NPTR			;AMOUNT TO BLT
	MOVN	B,B
	ADDI	B,-1(A)
	BLT	A,(B)
IFE TENEX,<
	MOVE	A,SAVJRL
	CORE	A,
	JFCL
>
IFN TENEX,<.FATAL HERE TOO>
	POPJ	P,

;CALL WITH B=FIRST ADDRESS IN RANGE, C=ADDRESS OF LAST ITEM IN RANGE
;THIS IS QUICKSORT WITHOUT STRAIGHT INSERTION SORT FOR SMALL SUBFILES.

SSORT:	MOVEI	D1,(B)		;LEFT POINTER
	MOVEI	D2,(C)		;RIGHT POINTER
	MOVE	D3,@1(D1)	;"KEY LEFT" ELEMENT
MRST1:	CAML	D3,@1(D2)	;IF "KEY LEFT" .GT. "KEY RIGHT"
	 JRST	MRST2		;NEED TO EXCHANGE (OR MAYBE STOP?)
	SUBI	D2,2		;MOVE RIGHT SIDE TOWARD CENTER
	JRST	MRST1		;LOOP

MRST2:	CAIN	D1,(D2)		;REACHED THE MIDDLE YET?
	 JRST	MRST4		;YES. NOW TIME TO SORT THE SUBFILES.
	MOVE	E,(D1)		;EXCHANGE
	EXCH	E,(D2)
	MOVEM	E,(D1)
	MOVE	E,1(D1)
	EXCH	E,1(D2)
	MOVEM	E,1(D1)
MRST3:	ADDI	D1,2		;MOVE LEFT END TOWARD CENTER
	CAMLE	D3,@1(D1)
	 JRST	MRST3		;"KEY RIGHT" .GT. "KEY LEFT"
	CAIN	D1,(D2)		;REACHED THE MIDDLE YET?
	 JRST	MRST4		;YES. NOW TIME TO SORT THE SUBFILES.
	MOVE	E,(D1)		;EXCHANGE
	EXCH	E,(D2)
	MOVEM	E,(D1)
	MOVE	E,1(D1)
	EXCH	E,1(D2)
	MOVEM	E,1(D1)
	SUBI	D2,2			;MOVE RIGHT SIDE TOWARD CENTER
	JRST	MRST1			;LOOP

MRST4:	MOVEI	D3,(C)
	SUBI	D3,(B)
	JUMPE	D3,CPOPJ	;IF B=C, THE ONE ELEMENT FILE IS SORTED
	LSH	D3,-1		;D3=1/2 SIZE OF ORIGINAL FILE.
	MOVEI	E,(C)
	SUBI	E,(D2)		;E=SIZE OF RIGHT SUBFILE
	CAILE	D3,(E)		;IF E .GT. D3 THEN LEFT SUBFILE FIRST
	 JRST	MRST5		;D3 .GT. E SORT RIGHT SUBFILE FIRST
	MOVSI	D3,2(D1)
	HRRI	D3,(C)		;LEFT EDGE,,RIGHT EDGE OF RIGHTSUBFILE
	MOVEI	C,(D1)		;SET RIGHT EDGE OF SMALL SUBFILE
	JRST	MRST6

MRST5:	MOVSI	D3,(B)
	HRRI	D3,-2(D1)
	MOVEI	B,(D1)
MRST6:	PUSH	P,D3			;STUFF ON STACK.
	PUSHJ	P,SSORT			;!
	POP	P,D3
	MOVEI	C,(D3)
	HLRZ	B,D3
	JRST	SSORT

;SYLPOP, CLASS

SYLPOP:	HRL	D3,PD		;PD COPIED TO LH OF ARGUMENT
	SKIPGE	E,SVSTK		;GET "STACK TOP"
	 JRST	SYLPSH		;STACK IS EMPTY.  TIME TO PUSH
SYLPP1:	ADD	E,2(PNT)	;GET STACK ADDRESS
	ADDI	E,(PNT)
	HRRZ	D2,(E)
	CAMG	D2,A		;STACK LEVEL GREATER THAN BLOCK LEVEL?
	 JRST	SYLPSH		;NO. WE CAN PUSH NEW ENTRY
	HLRE	D2,(E)		;GET NEW STACK TOP TO 10
	MOVEM	D2,SVSTK	;SAVE NEW STACK TOP
	MOVEM	D3,(E)		;STORE NEW STUFF IN STACK
	SKIPL	E,D2
	 JRST	SYLPP1		;LOOP UNTIL NO STACK OR FIND THE PLACE
	JUMPLE	A,CPOPJ		;STACK EMPTIED.  ONLY PUSH ITEM IF REAL
SYLPSH:	HRL	A,SVSTK		;OLD STACK POINTER,,BLOCK LEVEL
	HRRZM	D3,SVSTK	;STORE NEW TOP OF STACK
	ADD	D3,2(PNT)
	ADDI	D3,(PNT)
	MOVEM	A,(D3)		;STUFF DATA ON TOP OF STACK.
	POPJ	P,


;CALL WITH VALUE IN A, RETURNS CLASS NUMBER IN B
CLASS:	MOVEI	B,2
	TDNN	A,[-1,,400000]
	 SOJA	B,CPOPJ
	TLNN	A,-1
	 POPJ	P,
	TRNE	A,-1
	 ADDI	B,1
	AOJA	B,CPOPJ

IFE FILESW,<
TOOMAN:
IFE TENEX,<
	OUTSTR	LOSMES
>
IFN TENEX,<
	HRROI	A,LOSMES
	PSOUT
>
	SUB	B,CLASST+5	;NUMBER OF FREE WORDS NEEDED
	MOVNM	B,CLASST+5
	MOVE	PV,OPTR
TOOMA1:	SKIPN	(PV)
	 JRST	TOOMA2		;NO VALUE THERE
	MOVE	A,1(PV)		;GET VALUE
	PUSHJ	P,CLASS		;GET ITS CLASS
	CAIE	B,4
	 JRST	TOOMA2		;NOT CLASS 4
	SETZM	(PV)
	SETZM	1(PV)
	SOS	CLASST+3	;ONE LESS CLASS 4
	AOS	CLASST+5	;ANOTHER FREE
	AOSL	CLASST+5
	 JRST	TOOMA3		;GOT ENOUGH
TOOMA2:	SUB	PV,[2,,2]
	JUMPG	PV,TOOMA1
	JRST	TOOMA3

LOSMES:	ASCIZ /
NOT ENOUGH ROOM FOR OVERHEAD WORDS AND FULLWORD VALUES,
DELETING ENOUGH CLASS 4 VALUES TO WIN.
/
>;NOT FILESW

NBASE:	0
OPTR:	0
NPTR:	0		;POINTER TO NEW SYMBOLS
CLASST:	BLOCK 6		;PROG/BLOCK, CLASS 1 THRU CLASS 4, FREE
PD:	0
ID:	0
SVSTK:	0
SAVJRL:	0		;SAVED JOBREL AT SORT

BEND SORT

IFN PADSYM,<
; Add 64 symbols with names ....xx and garbage values, to pad
; symbol table
FOR @' I_0,7,1,<
INTERNAL .....'I
.....'I_I
>
FOR @' I_10,77,1,<
INTERNAL ....'I
....'I_I
>
>;PADSYM
   