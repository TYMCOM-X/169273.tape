SUBTTL	TABLE OF CONTENTS

;	+++++++++++++++++++++++++++++++++++++++++++
;	++  David W. Smith	<DWS@LLL-MFE>    ++
;	++  Lawrence Livermore Lab               ++
;	++  P.O. Box 808   L-440		 ++
;	++  Livermore, CA   94550                ++
;	++  (415) 422-0661   FTS 532-0661        ++
;	+++++++++++++++++++++++++++++++++++++++++++

;                  Table of Contents for SQUISH
;
;
;			   Section			      Page
;
;    1. TABLE OF CONTENTS  . . . . . . . . . . . . . . . . . .   1
;    2. ASSEMBLY PARAMETERS  . . . . . . . . . . . . . . . . .   2
;    3. REVISION HISTORY . . . . . . . . . . . . . . . . . . .   3
;    4. DEFINITIONS  . . . . . . . . . . . . . . . . . . . . .   4
;    5. MACRO DEFINITIONS  . . . . . . . . . . . . . . . . . .   5
;    6. LOWSEG STORAGE . . . . . . . . . . . . . . . . . . . .   6
;    7. SWITCH DEFINITIONS AND DOSCAN MACRO  . . . . . . . . .   8
;    8. PROGRAM INITIALIZATION   ( .ISCAN & .OSCAN ) . . . . .   9
;    9. COMMAND LOOP - READ THE COMMAND  (.TSCAN)  . . . . . .  10
;   10. SUPPLY APPROPRIATE DEFAULTS TO THE COMMAND . . . . . .  11
;   11. FIND AND OPEN THE NEXT INPUT FILE  ( .LKWLD )  . . . .  12
;   12. SET UP OUTPUT FILE   ( .SCWLD )  . . . . . . . . . . .  13
;   13. BYTESIZE EVALUATION  . . . . . . . . . . . . . . . . .  14
;   14. PASS1 - COUNT THE CHARACTERS AND BUILD THE TREE  . . .  16
;   15. PASS1 - SCAN THE TREE, BUILDING NEW BIT STRINGS  . . .  17
;   16. PASS2 - WRITE OUT THE HEADER, TREE, AND COUNT  . . . .  18
;   17. PASS2 - SUBSTITUTE NEW BIT STRINGS FOR INPUT BYTES . .  19
;   18. BOTTOM OF MAIN LOOP - CLOSE FILES  . . . . . . . . . .  20
;   19. FILE DISPLAY AND VERIFICATION ROUTINES . . . . . . . .  21
;   20. INPUT/OUTPUT SUBROUTINES . . . . . . . . . . . . . . .  22
;   21. SUBROUTINES CALLED BY SCAN . . . . . . . . . . . . . .  23
;   22. VARIOUS ERROR ROUTINES . . . . . . . . . . . . . . . .  24
;   23. ROUTINE TO PRINT DEVICE/FILE ERROR INFORMATION . . . .  25
;   24. LITERALS . . . . . . . . . . . . . . . . . . . . . . .  26
SUBTTL	ASSEMBLY PARAMETERS

SQIWHO==5		; /DWS
SQIVER==0		; MAJOR VERSION
SQIMIN==4		; MINOR VERSION
SQIEDT==11		; EDIT NUMBER

SEARCH	UUOSYM, MACTEN, SCNMAC
.DIRECTIVE .XTABM		; TABS ARE NOT PART OF MACROS
SALL				; NOR DO WE WANT TO SEE ANY OF THEM

TITLE.	(SQI,SQUISH,<File Compression by Huffman Coding>)

SQITTL				; GENERATE TITLE
SQIPTX				; YELL ON PASS2

TWOSEG

.REQUEST REL:SCN7C, REL:WLD7A
.REQUIRE REL:HELPER, REL:GETEOL

LOC	<.JBVER==137>
BYTE (3)SQIWHO(9)SQIVER(6)SQIMIN(18)SQIEDT
RELOC

ND FTBUGS,0		; NON-ZERO FOR DEBUGGING CODE
SUBTTL	REVISION HISTORY

; THE SCAN/WILD SHELL WAS LAST EDITTED ON 2-Jul-80

COMMENT \
D(7)-5	(18-27)-Dec-79
	Complete rewrite of SQUISH/BLOAT from earlier (circa March '78)
	version.  SCAN/WILD capabilities added.  Tree building/scanning
	logic reworked.  Switches added to aid the general public in
	choosing an appropriate byte size, including an option to let
	SQUISH 'guess' a bytesize.

D(10)-5	18-JAN-80
	1.  ADD /OKBIG TO MAKE PEOPLE STATE EXPLICITELY THAT THEY
	    DON'T MIND IF SQUISH MAKES THEIR FILES BIGGER.
	2.  ADD COMPRESSION STATISTICS CODE
	3.  FIX FLAW IN BYTESIZE EVALUATION LOGIC.
	4.  FIX ERROR RECOVERY FLOW TO RETURN TO ADDRESS IN E$EXIT,
	    INSTEAD OF ALWAYS TO NXTCMD:

D(11)-5 3-Mar-80
	1.  Fix another flaw in bytesize evalution logic.
	2.  Preserve file protections & dates
\
SUBTTL	DEFINITIONS

; ACCUMULATORS		****  0-7 SHOULD AGREE WITH SCAN AND WILD  ****

	F==	0		;FLAGS
	T1==	1
	T2==	2
	T3==	3
	T4==	4
	P1==	6
	N==	7
	A1==	10	;****  NOT USED BY SCAN OR WILD  ****
	A2==	11
	A3==	12
	A4==	13
	A5==	14
	P==	17		; STACK POINTER

; CHANNELS

	IN==	1		; DISK INPUT
	OUT==	2		; DISK OUTPUT

; OTHER DEFINITIONS

	PDLSIZ==100		; STACK SIZE
	LE$BLK==20		; SIZE OF LOOKUP/ENTER BLOCK
	PT$BLK==.FXLND+3	; LENGTH OF PATH BLOCK

; SQUISH DEFINITIONS

	EOL==	400000		; END-OF-LIST BIT
SUBTTL	MACRO DEFINITIONS

DEFINE	FATAL (CODE$,GOTO$,TEXT$)<
	JRST	[ FATAL0 (CODE$,TEXT$)
		  JRST    GOTO$]
>

DEFINE	FATAL0 (CODE$,TEXT$)<
E$$'CODE$:
	MOVE	T1,[''CODE$'',,[ASCIZ \TEXT$\ ]]
	PUSHJ	P,ERRMSG
>

DEFINE	WARN (CODE$,GOTO$,TEXT$)<
	JRST	[ WARN0 (CODE$,TEXT$)
		  JRST    GOTO$]
>

DEFINE	WARN0 (CODE$,TEXT$)<
W$$'CODE$:
	MOVE	T1,[''CODE$'',,[ASCIZ \TEXT$\ ]]
	PUSHJ	P,WRNMSG
>

DEFINE  ERROR ( CODE$ ) <
	JRST	E$'CODE$
>


DEFINE	TELL (TEXT$) <
IFE FTBUGS, <>			; NO FTBUGS, NO CODE!
IFN FTBUGS, <
	OUTSTR	[ASCIZ\[TEXT$]
\]
>
>


DEFINE	BRKPNT (TEXT$) <	; HANDY MACRO FOR DEBUGGING
IFE FTBUGS, <>			; NOT DEBUGGING? NO CODE!
IFN FTBUGS, <
	JRST	[ PUSH	P,[.+1]	; PUSH ADDR+1 ON STACK
		  SKIPN	.JBDDT	; DDT LOADED?
		   POPJ	 P,	; NO, GO BACK  
		  OUTSTR  [ASCIZ/[TEXT$]
/]
		  PUSH	P,.JBDDT ; PUSH/POPJ BECAUSE LH(.JBDDT)
		  POPJ  P,]	 ; CONTAINS JUNK
>; END IFN FTBUGS
>; END BRKPNT
SUBTTL	LOWSEG STORAGE

;  NOTE THAT [LOWSZF .. LOWSZL] IS CLEARED AT EVERY NEW COMMAND, NOT
;  NECESSARILY AT EVERY NEW FILE.  LIKEWISE [SWTCH .. SWTCHX] IS SET TO
;  ONES AT EVERY COMMAND.  [ZFILE .. ZFILEX] IS WHERE YOU SHOULD LOCATE
;  STORAGE THAT HAS TO BE CLEARED AT THE BEGINNING OF EACH FILE PROCESS.

IFE FTBUGS,<RELOC 0>

INICOR:	BLOCK	1		; INITIAL CORE SPACE FOR CLEANUP
CCLFLG:	BLOCK	1		; 1 IF CALLED VIA CCL, ELSE 0
E$EXIT:	BLOCK	1		; ADDRESS OF WHERE TO RECOVER FROM ERRORS
PDL:	BLOCK	PDLSIZ		; THE STACK

LOWSZF==.		; START OF AREA TO ZERO BEFORE SCAN
SCNPTR:	BLOCK	1		; POINTER FOR WILD (?)
IFILE:	BLOCK	1		; -1 IF INPUT FILE SPECIFIED
OFILE:	BLOCK	1		; -1 IF OUTPUT FILE SPECIFIED
IFILEP:	BLOCK	1		; WILL HOLD POINTER TO IFILEA
IFILEA:	BLOCK	.FXLEN		; INPUT FILE INFO (FROM SCAN)
OFILEP:	BLOCK	1		; WILL HOLD POINTER TO OFILEA
OFILEA:	BLOCK	.FXLEN		; OUTPUT FILE INFO (FROM SCAN)
IOPBLK:	BLOCK	3		; INPUT OPEN BLOCK
OOPBLK:	BLOCK	3		; OUTPUT OPEN BLOCK
LKPBLK:	BLOCK	LE$BLK+1	; LOOKUP BLOCK
ENTBLK:	BLOCK	LE$BLK+1	; ENTER BLOCK
IPTBLK:	BLOCK	PT$BLK		; INPUT PATH BLOCK
OPTBLK:	BLOCK	PT$BLK		; OUTPUT PATH BLOCK
LOWSZL==.-1		; END OF AREA TO CLEAR

SWTCH==.		; START OF AREA TO SET TO -1 BEFORE SCANNING
CHRSIZ:	BLOCK	1		; INPUT BYTE SIZE
TOGUES:	BLOCK	1		; 'GUESS' A BYTE SIZE, IF NOT SUPPLIED
TOASK:	BLOCK	1		; REQUEST VERIFICATION OF FILE SPECS
TOSHOW:	BLOCK	1		; DISPLAY FILE NAMES AS PROCESSED
OKBIG:	BLOCK	1		; USER DOESN'T MIND IF FILE GROWS
SWTCHX==.-1		; END OF AREA TO SET TO ONES
SWTLEN==.-SWTCH			; NUMBER OF SWITCHES

SWTINI:	BLOCK	SWTLEN		; AREA TO MEMORIZE SWITCH.INI DEFAULTS

; CONTINUED ON NEXT PAGE
; CONTINUED FROM LAST PAGE

ZFILE==.		; START OF AREA TO ZERO BEFORE EACH FILE PROCESS
IBUF:	BLOCK	3		; INPUT BUFFER HEADER
OBUF:	BLOCK	3		; OUTPUT BUFFER HEADER
BYTSIZ:	BLOCK	1		; INPUT BYTE SIZE
FREQ:	BLOCK	1000		; CHARACTER FREQUENCY HISTOGRAM
COUNT:	BLOCK	1		; CHARACTER COUNT
NODE:	BLOCK	1000		; NODE LABEL TABLE
TREE:	BLOCK	1000		; THE HUFFMAN TREE
TRSIZE:	BLOCK	1		; THE SIZE OF THE TREE
LAST:	BLOCK	1		; THE LAST NODE VISITED
INWRD:	BLOCK	1		; COUNT OF INPUT WORDS
INBLK:	BLOCK	1		; COUNT OF INPUT BLOCKS
OUTWRD:	BLOCK	1		; COUNT OF OUTPUT WORDS
OUTBLK:	BLOCK	1		; COUNT OF OUTPUT BLOCKS
ZFILEX==.-1		; END OF AREA TO ZERO BEFORE EACH FILE PROCESS

IFE FTBUGS,<RELOC 400000>
SUBTTL	SWITCH DEFINITIONS AND DOSCAN MACRO

; EXAMPLE OF BOOLEAN (YES/NO/NOT SPECIFIED) SWITCH
;	SN <SWITCH NAME>, <STORAGE>, FS.NUE

; EXAMPLE OF SWITCH STORING SPECIFIC VALUE
;	SS <SWITCH NAME>, <STORAGE>, <VALUE>, FS.NUE


; DEFINE SWITCHES WHICH CAN APPEAR IN A COMMAND LINE

DEFINE	SWTCHS, <
SN	ASK,	TOASK,	FS.NUE		; ASK FOR VERIFICATION
SN	SHOW,	TOSHOW,	FS.NUE		; SHOW FILE NAMES AS PROCESSED
SS	6BIT,	CHRSIZ,	6, FS.NUE	; USE SIXBIT COMPRESSION
SS	7BIT,	CHRSIZ, 7, FS.NUE	; USE SEVEN BIT COMPRESSION
SS	9BIT,	CHRSIZ,	9, FS.NUE	; USE NINE BIT COMPRESSION
SN	GUESS,	TOGUES,	FS.NUE		; I DUNNO, GUESS A SIZE
SN	OKBIG,	OKBIG,	FS.NUE		; DON'T CARE IF FILE GETS BIGGER
>

XLIST			; DOSCAN (SWSQI )
	DOSCAN (SWSQI)
LIST

; NOW DEFINE SWITCHES WHICH CAN APPEAR IN A SWITCH.INI
; -- NOTE THAT ONLY LOCALLY DEFINED SWITCHES (E.G. NOT STANDARD SCAN
;    SWITCHES) ARE HANDLED CORRECTLY.  THE PROBLEM IS THAT DEC IS UNCLEAR
;    AS TO HOW THE STANDARD SWITCHES ARE 'MEMORIZED'.

DEFINE	SWTCHS,<
SN	ASK,	TOASK,	FS.NUE		; ASK FOR VERIFICATION
SN	SHOW,	TOSHOW,	FS.NUE		; SHOW FILE NAMES AS PROCESSED
SN	GUESS,	TOGUES,	FS.NUE		; GUESS A BYTSIZE IF NOT SUPPLIED
SN	OKBIG,	OKBIG,	FS.NUE		; FILE MAY GET BIGGER
>

XLIST			; DOSCAN ( SWINI )
	DOSCAN (SWINI)
LIST
SUBTTL	PROGRAM INITIALIZATION   ( .ISCAN & .OSCAN )

;  HERE WE INITIALIZE THE PROGRAM BY PERFORMING SOME MINOR HOUSEKEEPING
;  CHORES, THEN BY INITIALIZING SCAN, WHICH DOES SOME HOUSEKEEPING AND
;  CORE DIDDLING OF ITS OWN, AND LAST BY READING DEFAULT LOCAL SWITCHES
;  FROM DSK:SWITCH.INI, IF PRESENT.

START::	TDCA	F,F			; CLEAR F AND SKIP
	 MOVEI	F,1			; IF CALLED WITH OFFSET
	MOVEM	F,CCLFLG		; REMEMBER HOW CALLED

	RESET				; MONITOR COURTESY

	MOVE	P,[IOWD PDLSIZ,PDL]	; SET UP STACK

	MOVE	T1,[6,,[IOWD 2,['SQUISH']
			CCLFLG,,'SQI'
			0,,0
			0,,0
			PROMPT,,MONRET]]

	PUSHJ	P,.ISCAN##		; INITIALIZE SCAN

	MOVE	A1,.JBFF##		; PICK UP CORE USAGE
	MOVEM	A1,INICOR		; AND SAVE FOR CLEANUP

	SETOM	SWTCH			; PREPARE SWITCH AREA
	MOVE	A1,[SWTCH,,SWTCH+1]	; BY SETTING IT ALL TO
	BLT	A1,SWTCHX		; TO -1

	MOVE	T1,[3,,[IOWD SWINIL,SWININ
			SWINID,,SWINIM
			0,,SWINIP]]
	PUSHJ	P,.OSCAN##		; READ SWITCH.INI FOR DEFAULTS

	MOVE	A1,[SWTCH,,SWTINI]	; SAVE ALL DEFAULTS TO APPLY LATER
	BLT	A1,SWTINI+SWTLEN-1
SUBTTL	COMMAND LOOP - READ THE COMMAND  (.TSCAN)

;  PERFORM A BIT OF CORE CLEANUP, THEN CALL SCAN TO PARSE THE
;  NEXT COMMAND.  NOTE THAT .ISCAN LEAVES A FEW INTERNAL HOOKS FOR
;  .TSCAN TO TELL IT WERE TO GO FOR THE COMMAND (E.G. TMP: OR CCL
;  FILE, IF NECESSARY).

NXTCM0:	PUSHJ	P,.TCRLF##		; SKIP TO NEXT LINE

NXTCMD:	MOVE	P,[IOWD PDLSIZ,PDL]	; RESET STACK

	MOVE	A1,INICOR		; PICK UP INITIAL CORE USAGE
	MOVEM	A1,.JBFF##		; AND CORE DOWN TO IT
	CORE	A1,			; TO CLEAN UP AFTER OURSELVES
	 FATAL	(CUF,MONRET,<CORE UUO failed>)

	MOVE	T1,[10,,[IOWD SWSQIL,SWSQIN
			SWSQID,,SWSQIM
			0,,SWSQIP
			-1
			SCNCLA,,0
			SCNAIN,,SCNAOT
			SCNMSD,,SCNASD
			SCNCSD,,1B19]]

	PUSHJ	P,.TSCAN##		; SCAN THE COMMAND LINE

	SKIPN	IFILEA+1		; WE'D BETTER HAVE A FILE NAME
	 FATAL	(NFS,NXTCM0,<No file specified>)
SUBTTL	SUPPLY APPROPRIATE DEFAULTS TO THE COMMAND

; FIRST WE APPLY WHATEVER SWITCHES WERE SPECIFIED IN SWITCH.INI (IF PRESENT).

	HRLZI	A1,-SWTLEN		; MAKE A LOOP INDEX TO THE SWITCH TABLE
INISET:	SKIPGE	SWTCH(A1)		; SWITCH SPECIFIED IN COMMAND LINE?
	 SKIPGE	A2,SWTINI(A1)		; NO, SPECIFIED IN SWITCH.INI?
	  CAIA				; IF IN COMMAND WE WON'T DEFAULT
	   MOVEM A2,SWTCH(A1)		; IF NOT WE'LL SUPPLY A DEFAULT
	AOBJN	A1,INISET		; LOOP

; NEXT WE ADJUST SCAN POINTERS AND FIXUP WILDCARDS, IF NECESSARY

	SKIPN	OFILE			; OUTPUT FILE SPECIFIED? (SET BY SCAN)
	 JRST	[MOVEI A1,IFILEA	; NO, POINT TO INPUT FILE AREA
		 MOVEM A1,OFILEP	; SAVE AS POINTER TO OUTPUT SPEC AREA
		 JRST .+1]

	SKIPN	IFILEA+3		; NO EXTENSION SPECIFIED?
	 JRST	[MOVEI	A1,-1		; NONE, WE'D BETTER ASSUME NOTHING
		 HRRZM	A1,IFILEA+3
		 JRST	.+1]

	SKIPN	OFILEA+1		; OUTPUT NAME SPECIFIED?
	 JRST	[MOVE	A1,IFILEA+1	; NO, PICKUP INPUT FILE NAME
		 MOVEM	A1,OFILEA+1	; AND USE IT
		 MOVE	A1,IFILEA+2	; PICKUP WILDCARDS, IF ANY
		 MOVEM	A1,OFILEA+2	; AND USE THEM
		 SKIPE	OFILEA+3	; EXTENSION SPECIFIED?
		  JRST	.+1		; YES, DON'T WORRY
		 MOVE	A1,IFILEA+3	; NO, USE INPUT EXTENSION
		 MOVEM	A1,OFILEA+3	; ...
		 JRST	.+1]

	SKIPN	OFILEA+3		; EXTENSION SUPPLIED FOR OUTPUT?
	 JRST	[MOVEI	A1,-1		; NONE, ASSUME NONE
		 HRRZM	A1,OFILEA+3
		 JRST	.+1]

SUBTTL	FIND AND OPEN THE NEXT INPUT FILE  ( .LKWLD )

;  CLEAN UP THE LOWSEG STORAGE FOR THIS FILE PROCESS PASS, THEN
;  CALL WILD TO FIND THE NEXT WILD FILE.  NOTE THAT SCAN AND WILD LEAVE
;  HOOKS FOR EACH OTHER THAT BORDER ON THE MYSTIC, SO DON'T TOUCH THE
;  ARGUMENT BLOCK TO .LKWLD

NXTFIL:	MOVE	A1,INICOR		; PICK UP INITIAL CORE ALLOCATION
	MOVEM	A1,.JBFF##		; RESET JOBDAT POINTER

	SETZM	ZFILE			; CLEAR STORAGE FOR THIS PASS
	MOVE	T1,[ZFILE,,ZFILE+1]
	BLT	T1,ZFILEX

	MOVE	T1,[5,,[IFILEP,,0	; IF THIS LOOKS LIKE MAGIC ....
			IOPBLK,,LKPBLK
			.FXLEN,,LE$BLK
			1B0+1B1+IN_^D18+SCNPTR
			0]]
	PUSHJ	P,.LKWLD##		; LOOK FOR THE NEXT WILD FILE
	 JRST	NXTCMD			; OUT OF FILES

	PUSHJ	P,.CHKTM##		; CHECK DATE SWITCHES
	 JRST	NXTFIL			; NOPE, FILE LOSES

	MOVEI	T1,.IOASC		; MODE OF INPUT FILE
	MOVEM	T1,IOPBLK+0		; SAVE IN OPEN BLOCK

	MOVEI	T1,IBUF			; POSITION INPUT BUFFER
	MOVEM	T1,IOPBLK+2		; IN INPUT BUFFER HEADER

	MOVEI	A1,NXTCM0		; GO BACK FOR NEXT COMMAND ..
	MOVEM	A1,E$EXIT		; IF OPEN FAILS.

	OPEN	IN,IOPBLK		; OPEN DEVICE FOR INPUT
	 ERROR	IOP			; FAILED, GO HANDLE IT

	MOVEI	A1,NXTFIL		; GO FOR NEXT FILE  ..
	MOVEM	A1,E$EXIT		; IF THE LOOKUP FAILS

	LOOKUP	IN,LKPBLK		; LOOKUP THE FILE
	 ERROR	LKP			; CAN'T GET AT IT, GO TELL WHY.

	INBUF	IN,12			; USE LOTS OF INPUT BUFFERS

	MOVE	A1,LKPBLK+.RBSIZ	; PICK UP LENGTH OF FILE IN WORDS
	MOVEM	A1,INWRD		; SAVE FOR COMPRESSION STATS
SUBTTL	SET UP OUTPUT FILE   ( .SCWLD )

;  CALL WILD AGAIN TO DETERMINE THE NAME OF THE OUTPUT FILE.  THE
;  ROUTINE USED IN WILD (.SCWLD) IS DUBIOUS AT BEST, BUT SUFFICES.

	MOVE	T1,[4,,[IFILEP,,OFILEP	; SET UP CALL TO CALCULATE OUTPUT FILE
			IOPBLK,,OOPBLK
			LKPBLK,,ENTBLK
			[LKPBLK+.RBEXT],,LE$BLK]]
	PUSHJ	P,.SCWLD##		; CALCULATE OUTPUT FILENAME
	 JRST	NXTFIL			; SOME SORT OF ERROR

	SKIPLE	TOASK			; SHOULD WE ASK FOR VERIFICATION?
	 JRST	[PUSHJ P,ASK		; YES, ASK
		  JRST NXTFIL		; USER SAID NO, GO FOR NEXT FILE
		 JRST .+1]		; USER SAID YES, PROCEED

	HRRZ	T1,LKPBLK+.RBEXT	; PICK UP CREATION DATE/TIME
	HRRM	T1,ENTBLK+.RBEXT	; SAVE IN ENTER BLOCK
	MOVE	T1,LKPBLK+.RBPRV	; PICK UP PROTECTION WORD
	MOVEM	T1,ENTBLK+.RBPRV	; SAVE IN ENTER BLOCK

	MOVEI	T1,.IOBIN		; OUTPUT MODE
	MOVEM	T1,OOPBLK+0		; STORE IN OPEN BLOCK

	HRLZI	T1,OBUF			; POSITION OUTPUT BUFFER HEADER
	MOVEM	T1,OOPBLK+2		; IN OUTPUT BUFFER HEADER

	MOVEI	A1,NXTCM0		; GO FOR NEXT COMMAND IF ..
	MOVEM	A1,E$EXIT		; THE OPEN FAILS

	OPEN	OUT,OOPBLK		; OPEN DEVICE FOR OUTPUT
	 ERROR	OOP			; GO HANDLE ERROR

	MOVEI	A1,NXTFIL		; GO FOR NEXT FILE IF ..
	MOVEM	A1,E$EXIT		; THE ENTER FAILS

	ENTER	OUT,ENTBLK		; ENTER OUTPUT FILE
	 ERROR	ENT			; FAILED, GO TELL WHY

	OUTBUF	OUT,12			; USE LOTS OF OUTPUT BUFFERS
SUBTTL	BYTESIZE EVALUATION

	SKIPG	A1,CHRSIZ		; CHARACTER SIZE SUPPLIED?
	 JRST	GUESS			; NOPE, MAY HAVE TO GUESS ONE
	MOVEM	A1,BYTSIZ		; SAVE AS OUR BYTESIZE FOR NOW
	JRST	CHKSIZ			; BUT GO CHECK IT

GUESS:	SKIPLE	TOGUESS			; DID USER REALY WANT ME TO GUESS?
	 JRST	GUESS1			; YES, GO GUESS
	FATAL	(NBS,GUESSB,<No Bytesize Specified>)
GUESSB:	CLOSE	OUT,40			; SAFELY DISPOSE OF OUTPUT FILE
	JRST	NXTCM0			; GO BACK FOR NEXT COMMAND

GUESS1:	MOVEI	A1,6			; I GUESS 6. (HARD, WASN'T IT)
	MOVEM	A1,BYTSIZ		; SAVE GUESSED SIZE

CHKSIZ:	MOVE	A1,BYTSIZ		; PICK UP CURRENT BYTE SIZE
	CAIE	A1,7			; ASCII WE HAVE TO BE DOUBLE SURE OF
	 JRST	GOTSIZ			; 6 BIT AND 9 BIT ARE SAFE

	IN	IN,			; READ THE FIRST BUFFER
	CAIA				; SKIP IF SUCCESSFUL
	 JRST	[FATAL	(FIE,E$FIEX,<File >)
		E$FIEX:
		 MOVEI	T1,IOPBLK	; POINT TO OPEN BLOCK
		 MOVEI	T2,LKPBLK	; POINT TO LOOKUP BLOCK
		 PUSHJ	P,.TOLEB##	; TYPE THEM OUT
		 OUTSTR	[ASCIZ . is empty.]
		 PUSHJ	P,.TCRLF##
		 JRST	@E$EXIT]

	HRRZ	A1,IBUF+1		; PICK UP POINTER INTO BUFFER
	HLRZ	A1,1(A1)		; PICK UP LH OF FIRST WORD
	CAIE	A1,-1			; CHECK VARIOUS POSSIBLE FUCKUPS
	 CAIG	A1,^D9			; SUCH AS ALREADY BEING SQUISHED
	  CAIA				; SKIP ON ERROR
	   JRST	GOTSIZ			; A SIMPLE TEST, REALLY
	SKIPG	TOGUES			; USER WANT US TO CORRECT ERROR?
	 ERROR	BYT			; NO, BLOW HIM UP
	MOVEI	A1,6			; YES, ASSUME BYTESIZE=6
	MOVEM	A1,BYTSIZ
	MOVE	T1,IBUF+2		; PICK UP BYTE COUNT
	IDIVI	T1,5			; DIVIDE INTO WORDS
	IMULI	T1,6			; CONVERT INTO SIXBIT
	MOVEM	T1,IBUF+2		; STORE UPDATED COUNT

;CONTINUED ON NEXT PAGE
;CONTINUED FROM LAST PAGE

GOTSIZ:	MOVE	A1,BYTSIZ		; PICK UP CHOSEN SIZE
	DPB	A1,[POINT 4,IBUF+1,11]	; AND TELL THE BUFFER HEADER
	JRST	PASS1			; (THE MONITOR DOES THE REST)

E$BYT:	FATAL	(CUS,E$BYT1,<Cannot SQUISH >)
E$BYT1:	MOVEI	T1,IOPBLK		; POINT TO OPEN BLOCK
	MOVEI	T2,LKPBLK		; POINT TO LOOKUP BLOCK
	PUSHJ	P,.TOLEB##		; TYPE THEM OUT
	MOVEI	T1,[ASCIZ . with a bytesize of 7.]
	PUSHJ	P,.TSTRG##		; FINISH OFF THE MESSAGE
	PUSHJ	P,.TCRLF##
	JRST	NXTFIL			; TRY AGAIN WITH NEXT SET
SUBTTL	PASS1 - COUNT THE CHARACTERS AND BUILD THE TREE

PASS1:	MOVEI	N,1			; INIT THE TREE POINTER

PASS1A:	PUSHJ	P,GETBYT		; GET A BYTE
	 JRST	PASS1B			; DONE COUNTING, START BUILDING
	AOS	FREQ(T1)		; INCREMENT THE CHARACTER HISTOGRAM
	AOS	COUNT			; AND THE CHARACTER COUNT
	JRST	PASS1A			; KEEP AT IT

PASS1B:	SETZB	A1,T1			; CLEAR A PAIR OF NODE POINTERS
	SETZB	A2,T2			; AND THEIR VALUE HOLDERS

	HRLZI	A3,-1000		; SET UP THE TABLE POINTER
PASS1C:	SKIPN	FREQ(A3)		; ANYTHING THERE FOR THIS CHARACTER?
	 JRST	PASS1E			; NOPE
	JUMPE	A1,PASS1D		; NO VALUE YET?  GO LOAD ONE
	CAMG	A1,FREQ(A3)		; OR IS THIS VALUE .LT.?
	 JRST	PASS1E			; NO, CHECK THE NEXT
PASS1D:	MOVE	A1,FREQ(A3)		; LOAD THE NEW VALUE
	MOVEI	T1,(A3)			; AND POINT TO IT
PASS1E:	AOBJN	A3,PASS1C		; MORE TO LOOK AT? DO IT.
	SETZM	FREQ(T1)		; ERASE THIS VALUE FROM THE LIST

	HRLZI	A3,-1000		; SET UP ANOTHER INDEX POINTER
PASS1F:	SKIPN	FREQ(A3)		; ANYTHING THERE?
	 JRST	PASS1H			; NO, IGNORE
	JUMPE	A2,PASS1G		; NO VALUE YET? GO LOAD IT
	CAMG	A2,FREQ(A3)		; OR IS THIS ON .LT. (T2)?
	 JRST	PASS1H			; NO GOOD, LOOK FOR MORE
PASS1G:	MOVE	A2,FREQ(A3)		; LOAD THE NEW VALUE
	MOVEI	T2,(A3)			; AND POINT TO IT
PASS1H:	AOBJN	A3,PASS1F		; IF MORE TO LOOK AT, DO IT.
	JUMPE	A2,PASS1X		; IF WE CAN'T FIND ANOTHER, WE'RE DONE

	ADDM	A1,FREQ(T2)		; OTHERWISE ADD THE TWO
	SKIPN	A4,NODE(T1)		; IS THIS ONE ALREADY A NODE?
	 MOVEI	A4,EOL(T1)		; NO, TURN ON END-OF-LIST BIT.
	SKIPN	A5,NODE(T2)		; IS THE OTHER A NODE?
	 MOVEI	A5,EOL(T2)		; NO, TURN ON END-OF-LIST BIT
	MOVEM	N,NODE(T2)		; MAKE ONE THE NEW NODE
	SETZM	NODE(T1)		; AND CLEAR THE OTHER

	HRL,TREE(N)		; LINK LEFT TO TREE
	HRRM	A5,TREE(N)		; LINK RIGHT TO TREE
	AOJA	N,PASS1B		; INCREMENT THE TREE POINTER AND GO.

PASS1X:	MOVEI	N,-1(N)			; ADJUST THE TREE POINTER
	MOVEM	N,TRSIZE		; REMEMBER THE TREE SIZE
SUBTTL	PASS1 - SCAN THE TREE, BUILDING NEW BIT STRINGS

SCAN:	MOVEI	A3,(N)			; POINT TO THE TOP OF THE TREE
	MOVEI	A2,1			; INIT LEADING BIT IN STRING

SCAN1:	CAIL	A3,EOL			; ARE WE AT A TERMINAL NODE?
	 JRST	SCAN3			; YES, GO MARK IT
SCAN1A:	HRRZ	A1,TREE(A3)		; LOOK AT THE RIGHT BRANCH
	CAMN	A1,LAST			; HAVE WE BEEN THERE?
	 JRST	SCAN4			; YES, TIME TO MOVE UP
	PUSH	P,A3			; SAVE THE POINTER
	HLRZ	A1,TREE(A3)		; LOOK AT THE LEFT BRANCH
	CAMN	A1,LAST			; HAVE WE BEEN THERE?
	 JRST	SCAN2			; YES, MOVE DOWN RIGHT
	LSH	A2,1			; BIT PATTERN SAYS 'GOING LEFT'
	MOVEI	A3,(A1)			; BRANCH TO LEFT NODE
	JRST	SCAN1			; AND KEEP SCANNING

SCAN2:	LSH	A2,1			; SHIFT THE BIT STRING
	ORI	A2,1			; MAKE IS SAY 'GOING RIGHT'
	HRRZ	A3,TREE(A3)		; BRANCH TO THE RIGHT
	JRST	SCAN1			; AND PROCEED

SCAN3:	MOVEM	A2,FREQ-EOL(A3)		; AT <EOL>, SAVE BIT STRING

SCAN4:	MOVEM	A3,LAST			; REMEMBER NODE LAST VISITED
	CAIN	A3,(N)			; ARE WE BACK AT TREE TOP?
	 JRST	SCAN5			; YES, WE'RE DONE
	POP	P,A3			; ELSE PICK UP PRIOR NODE
	LSH	A2,-1			; ADJUST THE BIT STRING
	JRST	SCAN1A			; AND GO CHECK ANOTHER NODE

SCAN5:	SKIPLE	TOSHOW
	 OUTSTR	[ASCIZ .[Tree Complete]
.]
SUBTTL	PASS2 - WRITE OUT THE HEADER, TREE, AND COUNT

PASS2:	HRLZ	T1,BYTSIZ		; <BYTE SIZE>,,0
	HRR	T1,TRSIZE		; <BYTE SIZE>,,<TREE SIZE>
	PUSHJ	P,PUTBYT		; FIRST WORD OF COMPRESSED FILE

	MOVEI	A1,1			; POINT TO FIRST WORD OF TREE
PASS20:	MOVE	T1,TREE(A1)		; LOAD IT
	PUSHJ	P,PUTBYT		; DUMP IT
	AOJ	A1,			; INCREMENT THE POINTER
	CAMG	A1,TRSIZE		; UNTIL WE POINT PAST THE TREE
	 JRST	PASS20			;  WE DUMP THE TREE, TRA LA..

	MOVE	T1,COUNT		; PICK UP COUNT OF INPUT BYTES
	PUSHJ	P,PUTBYT		; STORE IN COMPRESSED FILE
SUBTTL	PASS2 - SUBSTITUTE NEW BIT STRINGS FOR INPUT BYTES

	USETI	IN,1			; SET TO REREAD INPUT FILE

	SETZ	T2,			; CLEAR THE OUTPUT WORD
	MOVEI	A3,^D36			; SET THE BIT COUNT

PASS2A:	PUSHJ	P,GETBYT		; GET AN INPUT BYTE
	 JRST	PASS2B			; ALL DONE, GO CLEANUP
	MOVE	A1,FREQ(T1)		; GET THE NEW BIT STRING
	JFFO	A1,.+2			; FIND THE LEADING BIT
	 FATAL	(INT,MONRET,<INTERNAL ERROR, PASS2 CONTRADICTS PASS1>)
	LSH	A1,1(A2)		; LEFT JUSTIFY THE BIT STRING
	HRREI	A4,-<^D36-1>(A2)	; CALCULATE -SHIFT
	LSHC	A1,-^D36(A3)		; SHIFT THE BIT STRING INTO PLACE
	OR	T2,A1			; AND OR IT INTO PLACE
	ADD	A3,A4			; ADD -SHIFT TO BIT COUNT
	JUMPG	A3,PASS2A		; ROOM LEFT? GO FOR ANOTHER BYTE

	MOVE	T1,T2			; PUTBYT EXPECT BYTE IN T1
	PUSHJ	P,PUTBYT		; NO ROOM LEFT, DUMP THE STRING
	SETZ	T2,			; CLEAR THE OUTPUT WORD
	MOVEI	A3,^D36(A3)		; CALCULATE NEW FREE BIT COUNT
	OR	T2,A2			; OR REMAINING BITS (IF ANY) INTO WORD
	JRST	PASS2A			; AND GO BACK FOR MORE

PASS2B:	JUMPE	A3,PASS2C		; ANY SPARE BITS FLOATING ABOUT?
	MOVE	T1,T2			; YES, LOAD INTO CORRECT AC
	PUSHJ	P,PUTBYT		; AND DUMP TO OUTPUT FILE

PASS2C:	MOVE	A1,INWRD		; PICK UP COUNT OF INPUT WORDS
	IDIVI	A1,200			; CONVERT TO BLOCKS
	SKIPE	A2			; IF OVERFLOW
	 ADDI	A1,1			; ROUND UP
	MOVEM	A1,INBLK		; SAVE BLOCK COUNT

	MOVE	A3,OUTWRD		; LOAD COUNT OF OUTPUT WORDS
	IDIVI	A3,200			; CONVERT TO BLOCKS
	SKIPE	A4			; EVEN BLOCK BOUNDARY?
	 ADDI	A3,1			; ROUND UP
	MOVEM	A3,OUTBLK		; SAVE OUTPUT BLOCK COUNT

	CAMLE	A3,A1			; DID THE FILE GET BIGGER?
	 SKIPLE	OKBIG			; YES, DOES THE USER MIND?
	  JRST	ENDFIL			; AHH.... WE WIN!

	FATAL	(NGC,PASS2D,<Negative compression for >)
PASS2D:	MOVEI	T1,IOPBLK		; POINT TO OPEN BLOCK
	MOVEI	T2,LKPBLK		; AND LOOKUP BLOCK
	PUSHJ	P,.TOLEB##		; TYPE THEM OUT
	PUSHJ	P,.TCRLF##
	CLOSE	OUT,40			; RELEASE THE OUTPUT FILE
	JRST	NXTFIL			; GO TRY THE NEXT FILE
SUBTTL	BOTTOM OF MAIN LOOP - CLOSE FILES

ENDFIL:	SKIPLE	TOSHOW		; WANT TO DISPLAY FILENAMES WHEN PROCESSED?
	 PUSHJ	P,SHOW		; YES, GO DISPLAY

	CLOSE	IN,		; CLOSE THE INPUT FILE
	CLOSE	OUT,		; AND THE OUTPUT FILE

	RELEAS	IN,		; LET GO OF INPUT CHANNEL
	RELEAS	OUT,		; AND OUTPUT CHANNEL

	JRST	NXTFIL		; GO BACK FOR ANOTHER SET OF FILES
SUBTTL	FILE DISPLAY AND VERIFICATION ROUTINES

ASK:	PUSHJ	P,SHOWF			; DISPLAY THE FILE FLOW
	PJRST	YESNO			; AND POP THE BIG QUESTION


SHOW:	PUSHJ	P,SHOWF			; DISPLAY FILES
	OUTSTR	[ASCIZ .  .]		; MAKE SOME ROOM
	MOVE	A2,INBLK		; GET COUNT OF INPUT BLOCKS
	MOVE	A1,OUTBLK		; GET COUNT OF OUTPUT BLOCKS
	IMULI	A1,^D100		; SET FOR % CALCULATION
	IDIV	A1,A2			; DIVIDE
	JUMPL	A1,[OUTCHR ["-"]	; NEGATIVE? GHASTLY!
		    MOVNS   A1
		    JRST .+1]
	MOVEI	T1,^D100		; START WITH 100%
	SUB	T1,A1			; SUBTRACT COMPRESSION
	PUSHJ	P,.TDECW##		; TYPE IN DECIMAL
	OUTSTR	[ASCIZ .% compression.]	; LABEL THE MAGIC NUMBER
	PJRST	.TCRLF##		; PRINT CRLF AND RETURN



SHOWF:	SKIPN	OFILE			; OUTPUT FILE SPECIFIED?
	 JRST	SHOWF1			; NO, DON'T LIST
	MOVEI	T1,OOPBLK		; POINT TO OPEN BLOCK
	MOVEI	T2,ENTBLK		; AND ENTER BLOCK
	PUSHJ	P,.TOLEB##		; AND TYPE THEM OUT
	OUTSTR	[ASCIZ . <-- . ]	; INDICATE FLOW OF DATA
SHOWF1:	MOVEI	T1,IOPBLK		; POINT TO INPUT OPEN BLOCK
	MOVEI	T2,LKPBLK		; AND LOOKUP BLOCK
	PUSHJ	P,.TOLEB##		; TYPE THEM OUT
	POPJ	P,			; BACK TO CALLER


YESNO:	OUTSTR	[ASCIZ .? .]		; PROMPT CHARACTER
	INCHWL	A1			; GET A CHARACTER
	CAIE	A1,"Y"			; BIG "Y" FOR YES?
	 CAIN	A1,"Y"+40		; OR LITTLE "Y" FOR yes?
	  AOS	(P)			; SET TO SKIP FOR SUCCESS!!
	PUSHJ	P,GETEOL##		; CLEAR THE REMAINDER OF INPUT
	POPJ	P,			; AND LEAVE
SUBTTL	INPUT/OUTPUT SUBROUTINES

; GETBYT - GET THE NEXT BYTE FROM THE INPUT CHANNEL
;  <EOF RETURN>
; <GOOD RETURN>

GETBYT:	SOSGE	IBUF+2			; ANY BYTES LEFT IN BUFFER?
	 JRST	GETBUF			; NO, TIME FOR A NEW BUFFER
	ILDB	T1,IBUF+1		; LOAD THE BYTE
CPOPJ1:	AOS	(P)			; GET SET TO . . .
COPJ:	POPJ	P,			; S K I P !

GETBUF:	IN	IN,			; INPUT A BUFFER
	JRST	GETBYT			; READ O.K. TRY FOR THE BYTE AGAIN
	 STATZ	IN,IO.EOF		; END OF FILE?
	  POPJ	P,			; YES, GIVE NON-SKIP RETURN
	FATAL	(IER,GETBF1,<Input error, STATUS = >)
GETBF1:	GETSTS	IN,T1			; GET CHANNEL STATUS
	PUSHJ	P,.TOCTW##		; TYPE IN OCTAL
	JRST	E$MSGX			; OUT THROUGH COMMON ERROR EXIT


; PUTBYT - OUTPUT BYTE IN T1 TO OUTPUT CHANNEL
; <RETURN HERE ALWAYS>   (ALMOST)

PUTBYT:	SOSGE	OBUF+2			; ROOM LEFT IN OUTPUT BUFFER?
	 JRST	PUTBUF			; NO, GO DUMP IT
	IDPB	T1,OBUF+1		; DEPOSIT BYTE INTO BUFFER
	AOS	OUTWRD			; KICK UP THE OUTPUT WORD COUNT
	POPJ	P,			; AND GO HOME

PUTBUF:	OUT	OUT,			; DUMP THE BUFFER
	JRST	PUTBYT			; AND TRY AGAIN WITH THE BYTE
	 FATAL	(OER,PUTBF1,<Output error, STATUS = >)
PUTBF1:	GETSTS	OUT,T1			; GET CHANNEL STATUS
	PUSHJ	P,.TOCTW##		; TYPE IN OCTAL
	JRST	E$MSGX			; OUT THROUGH COMMON ERROR EXIT
SUBTTL	SUBROUTINES CALLED BY SCAN

; ROUTINE TO PROMPT FOR INPUT
PROMPT:	SKIPN	T1			; CONTINUATION LINE ?
	 POPJ	P,			; YES, NO PROMPT
	OUTCHR	T1			; PRINT THE PROMPT
	POPJ	P,			; AND RETURN TO SCAN

; ROUTINE TO EXIT TO THE MONITOR
MONRET:	RESET				; MERELY A COURTESY
	EXIT	1,
	JRST	START

; ROUTINE TO (RE)SET FLAG VALUES TO -1 OR 0.
SCNCLA:	SETOM	SWTCH			; SET FIRST WORD TO -1
	MOVE	T1,[SWTCH,,SWTCH+1]	; SET BLT POINTER
	BLT	T1,SWTCHX		; AND BLT THROUGH THE REST
	SETZM	LOWSZF			; SET FIRST WORD TO 0
	MOVE	T1,[LOWSZF,,LOWSZF+1]	; SET BLT POINTER
	BLT	T1,LOWSZL		; BLT!!
	POPJ	P,


; ROUTINE TO TELL SCAN WHERE TO PUT INPUT FILE INFO
SCNAIN:	SKIPE	IFILE			; SKIP IF NO INPUT SPECIFIED YET
	 FATAL	(IFS,NXTCM0,<Multiple input specifications are illegal>)
	SETOM	IFILE			; INPUT FILE SPECIFIED
	MOVEI	T2,.FXLEN
	MOVEI	T1,IFILEA
	MOVEM	T1,IFILEP		; SAVE POINTER FOR WILD
	POPJ	P,


; ROUTINE TO TELL SCAN WHERE TO PUT OUTPUT FILE INFO
SCNAOT:	SKIPE	OFILE			; OUTPUT FILE SPECIFIED YET?
	 FATAL	(OFS,NXTCM0,<Multiple output specifications are illegal>)
	SETOM	OFILE			; OUTPUT FILE SPECIFIED
	MOVEI	T2,.FXLEN
	MOVEI	T1,OFILEA
	MOVEM	T1,OFILEP		; SAVE THE POINTER FOR WILD
	POPJ	P,


; ROUTINE TO MEMORIZE STICKY DEFAULTS
SCNMSD:	POPJ	P,			; NO ACTION YET

; ROUTINE TO APPLY STICKY DEFAULTS
SCNASD:	POPJ	P,			; GO HOME

; ROUTINE TO CLEAR STICKY DEFAULTS
SCNCSD:	POPJ	P,			; NOPE
SUBTTL	VARIOUS ERROR ROUTINES

; ISSUE AN ERROR OR A WARNING MESSAGE, WITH APPROPRIATE PREFIX
ERRMSG:	MOVSI	T2,"?"			; SET UP PREFIX
	CAIA				; SKIP INTO REST OF CODE
WRNMSG:	MOVSI	T2,"%"			; SET UP PREFIX
	SKPINC				; CLEAR ^O
	 JFCL
	HRRI	T2,(T1)			; SET UP FOR CALL
	HLRZS	T1			; BY A BIT OF
	HRLI	T1,'SQI'		; CONSTRUCTIVE SHUFFLING
	PJRST	.ERMSG##		; ISSUE THE MESSAGE


; OPEN FAILURE FOR INPUT DEVICE
E$IOP:	FATAL	(IOP,E$IOP1,<OPEN failed for >)
E$IOP1:	MOVE	T1,IOPBLK+1		; PICK UP DEVICE NAME
	HRRZ	A1,IOPBLK		; SAVE ERROR NUMBER
	JRST	E$OPEN			; SKIP INTO NEXT ROUTINE

; OPEN FAILED FOR OUTPUT DEVICE
E$OOP:	FATAL	(OOP,E$OOP1,<OPEN failed for >)
E$OOP1:	MOVE	T1,OOPBLK+1
	HRRZ	A1,OOPBLK		; SAVE ERROR NUMBER
E$OPEN:	PUSHJ	P,.TSIXN##
	PUSHJ	P,.TCOLN##		; TYPE A COLON
	MOVE	T1,A1			; RECOVER ERROR NUMBER
	JRST	E$MSG1			; GO TYPE ERROR NUMBER
; LOOKUP FAILURE
E$LKP:	FATAL	(LKP,E$LKP1,<LOOKUP failed for >)
E$LKP1:	MOVEI	T1,IOPBLK		; POSITION INPUT OPEN BLOCK
	MOVEI	T2,LKPBLK		; POSITION LOOKUP BLOCK
	PUSHJ	P,.TOLEB##		; TYPE FILE SPEC
	HRRZ	T1,LKPBLK+.RBEXT	; PICK UP ERROR CODE
	JRST	E$MSG			; PRINT DEC MESSAGE, IF GIVEN

; ENTER FAILURE
E$ENT:	FATAL	(ENT,E$ENT1,<ENTER failed for >)
E$ENT1:	MOVEI	T1,OOPBLK		; POSITION OUTPUT OPEN BLOCK
	MOVEI	T2,ENTBLK		; POSITION ENTER BLOCK
	PUSHJ	P,.TOLEB##		; TYPE FILE SPEC
	HRRZ	T1,ENTBLK+.RBEXT	; PICK UP ERROR CODE
	JRST	E$MSG			; TYPE DEC TEXT, IF GIVEN
SUBTTL	ROUTINE TO PRINT DEVICE/FILE ERROR INFORMATION

; JRST'D TO WITH ERROR # IN T1, EXITS TO NXTFIL
E$MSG:	MOVEI	A1,(T1)			; SAVE THE ERROR NUMBER
	PUSHJ	P,.TCOMA##		; TYPE A COMMA
	PUSHJ	P,.TSPAC##		; TYPE A SPACE
	CAIG	A1,FERLEN		; HIGHEST KNOW ERROR CODE
	 SKIPN	T1,FERMSG(A1)		; LOAD THE ERROR TEXT, IF GIVEN
	  JRST	E$MSG2
	PUSHJ	P,.TSTRG##		; TYPE THE MESSAGE
	JRST	E$MSGX			; JUMP TO ROUTINE EXIT

E$MSG1:	MOVEI	T1,[ASCIZ ., Error .]
	PUSHJ	P,.TSTRG##		; LABEL THE ERROR

E$MSG2:	MOVEI	T1,"("			; PRINT ERROR NUMBER
	PUSHJ	P,.TCHAR##
	MOVE	T1,A1			; RECOVER NUMBER
	PUSHJ	P,.TOCTW##
	MOVEI	T1,")"
	PUSHJ	P,.TCHAR##
E$MSGX:	PUSHJ	P,.TCRLF##
	SKIPN	T1,.JBDDT##		; IS DDT LOADED?
	 JRST	@E$EXIT			; [10] BACK TO WHEREVER ...
	PUSHJ	P,(T1)			; ENTER DDT
	JRST	@E$EXIT			; BACK TO TRY AGAIN

; FILE ERROR MESSAGES (INDEXED BY FILE ERROR #)
FERMSG:	[ASCIZ .file not found.]
	[ASCIZ .non-existent UFD.]
	[ASCIZ .protection failure.]
	[ASCIZ .file being modified. ]
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	[ASCIZ .SFD not found.]
	[ASCIZ .search list empty.]
	[ASCIZ .SFDs nested too deep.]
FERLEN==.-FERMSG
SUBTTL	LITERALS

IFN FTBUGS,<
LIT:	LIT			; DUMP THE LITERALS
>; END IFN FTBUGS

	END	START
    N "ø