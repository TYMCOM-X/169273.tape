COMMENT $ HISTORY
AUTHOR,REASON
021  202200000030 $;

COMMENT $
VERSION 18-2(24) 11-DEC-80 by SDD some String space changes for WCR
VERSION 18-2(23) 28-JUN-80 by SDD finish the .JBxxx/JOBxxx work
VERSION 18-2(22) 24-JAN-80 by SDD finally get rid of EXPO/NOEXPO macros
VERSION 18-2(21) 15-JAN-80 by SDD many more IFNDEF things
VERSION 18-2(20) 03-DEC-79 by SDD Rutgers merge, TENX dsplen__=350
VERSION 18-2(19) 25-OCT-79 by SDD Change FIX (UUO opcode 3) to FIXUUO
VERSION 18-2(18) 11-OCT-78 by SDD TYMSHARE means compile only KI10 code
VERSION 18-2(17) 10-13-77 by SDD (mostly lowercase) more ifndef (FILSPEC)
VERSION 18-2(16) 6-11-76 BY JES ALLOCATE LOCAL ITEMS IN DESCENDING ORDER (URLEAP)
VERSION	18-2(15) 3-18-76 BY RFR ADDED NEW LEAP SEARCHES F6,F7 UDER URHASH AND URSTAT SWITCHES
VERSION 18-2(14) 3-26-75 BY JFR TENX DSPLEN__=330 (P.9)
VERSION 18-2(13) 2-16-75 BY JFR BAIL P.7,17 TYPE CODE FOR REC!PNTR, RUNTIME PROC DESCR FILE
VERSION 18-2(12) 2-16-75 BY RLS JUST LOOKING
VERSION 18-2(11) 2-16-75 BY RLS LOOKING AT TENEX SWITCH SETTINGS
VERSION 18-2(10) 2-2-75 BY JFR CLAIM TYPE CODE FOR ITEMVARS IN BAIL, P.17
VERSION 18-2(9) 2-1-75 BY RLS TENEX PSI SYSTEM
VERSION 18-2(8) 12-10-74 BY JFR MORE BAIL LOADMODULE RESIDENCE DEFINITION
VERSION 18-2(7) 12-7-74 BY JFR DEFINE RESIDENCE OF  BAIL  LOADMODULE
VERSION 18-2(6) 11-17-74 BY JFR USER TABLE ENTRY FOR COMMUNICATION BETWEEN BAIL AND ERROR HANDLER
VERSION 18-2(5) 11-7-74 BY JFR KEEP PPN IN CDB
VERSION 18-2(4) 11-2-74 BY JFR REVISE DATA AND ZERODAT CHECKS TO USE "PRINTX", GIVE MORE INFORMATION
VERSION 18-2(3) 10-18-74 BY rls check TENEX file setting for v. 8
VERSION 18-2(2) 10-18-74 BY RHT V 18
VERSION 17-2(104) 10-14-74 BY RHT MAKE FILES SAY SAISG8, ETC
VERSION 17-2(103) 10-10-74 BY JFR FEAT %BS% NEW WAY TO DO BREAK TABLES
VERSION 17-2(102) 10-10-74 BY RHT FEAT BR ELIMINATE HACKS
VERSION 17-2(101) 10-10-74 
VERSION 17-2(100) 10-10-74 
VERSION 17-2(99) 9-20-74 BY JFR INSTALL BAIL
VERSION 17-2(98) 9-5-74 BY RHT ADD ITSSW
VERSION 17-2(97) 7-18-74 BY RHT FEAT %BK% NEEDED NEW LOSER TABLE ENTRY
VERSION 17-2(96) 7-7-74 BY RHT MINOR EDITS FOR REC GC
VERSION 17-2(95) 7-7-74 
VERSION 17-2(94) 6-6-74 BY RHT ADD RGCSW
VERSION 17-2(93) 5-30-74 BY RLS BUG #SM# TEST FOR OVERFLOW OF DISPATCH TABLE
VERSION 17-2(92) 5-27-74 
VERSION 17-2(91) 5-25-74 BY RLS MAKE V. 54 OF LOADER DEFAULT ON TENEX
VERSION 17-2(90) 5-25-74 BY RLS EDIT
VERSION 17-2(89) 5-25-74 BY rls edit
VERSION 17-2(88) 5-25-74 BY RLS PARAMETERIZE JRST TABLE
VERSION 17-2(87) 5-25-74 
VERSION 17-2(86) 5-25-74 BY RLS NEW STDBRK
VERSION 17-2(85) 5-24-74 
VERSION 17-2(84) 5-10-74 BY RHT MODIFY CMU TREATMENT OF GLOBSW MACROS
VERSION 17-2(83) 5-5-74 BY RHT ADD PRNINF TO USER TABLE
VERSION 17-2(82) 4-11-74 BY RHT ADD RECSW & ASSOCIATED MACROS
VERSION 17-2(81) 4-7-74 BY RHT FEAT %BI% ADD RECUUO
VERSION 17-2(80) 4-7-74 BY RHT ADD RECTYP DEF
VERSION 17-2(79) 3-26-74 BY RLS CHANGE TENEX LOADVR TO 54
VERSION 17-2(78) 3-19-74 BY RHT GO OVER FILE WITH RS
VERSION 17-2(77) 3-17-74 BY RLS  EDIT
VERSION 17-2(76) 3-17-74 BY RLS INSTALL SITE SWITCHES
VERSION 17-2(75) 3-17-74 BY RLS INSTALL TENEX FEATURES, TENEX SYSTEM SWITCHES
VERSION 17-2(75) 2-24-74 BY RHT FEAT %BH% TMPB FOR REF ITEM DATUM
VERSION 17-2(74) 1-11-74 
VERSION 17-2(73) 1-11-74 BY JRL ADD CMU SWITCHES SPACE ALLOCATION COMVER
VERSION 17-2(72) 1-11-74 
VERSION 17-2(71) 1-11-74 
VERSION 17-2(70) 12-9-73 BY KVL %BC% ADD BAIL SWITCH
VERSION 17-2(69) 12-6-73 BY jrl REMOVE AS MANY NON STANFORD CHARS AS POSSIBLE
VERSION 17-2(68) 12-3-73 BY RHT ITMANY__0
VERSION 17-2(67) 12-3-73 
VERSION 17-2(66) 12-3-73 BY RFS INSERT CALLIS FOR EXPORT SYSTEM
VERSION 17-2(65) 12-3-73 
VERSION 17-2(64) 12-3-73 BY RFS ELIMINATED ALL III DISPLAY STUFF
VERSION 17-2(63) 12-2-73 BY RHT HEREFK MACRO & REMOVE USELESS FILSPC TAPE HISTORY
VERSION 17-2(62) 12-2-73 
VERSION 17-2(61) 11-30-73 BY RHT ADD STANSW & DECSW
VERSION 17-2(60) 11-26-73 
VERSION 17-2(59) 11-26-73 
VERSION 17-2(58) 11-26-73 BY RHT DIDDLE THE FILSPC STUFF
VERSION 17-2(57) 11-24-73 BY RHT FEAT %AM% ALLOW MANY USER PHASES OF INIT
VERSION 17-2(56) 11-24-73 
VERSION 17-2(55) 11-21-73 BY RFS CHANGE 'TEST' TO 'TSTSEG'
VERSION 17-2(54) 11-18-73 
VERSION 17-2(53) 11-18-73 BY RHT FEAT %AJ% -- ADD IN FILSPC
VERSION 17-2(52) 11-18-73 
VERSION 17-2(51) 11-18-73 
VERSION 17-2(50) 11-18-73 
VERSION 17-2(49) 11-18-73 
VERSION 17-2(48) 11-18-73 BY RHT FEAT %AJ% -- RESTRUCTURE HEAD
VERSION 17-2(47) 11-10-73 BY RHT ADD CORERR, ERRPRI, ERFLGS BITS
VERSION 17-1(46) 7-26-73 BY RHT TRY VERSION 17
VERSION 17-1(45) 7-26-73 *********************
VERSION 16-2(44) 7-9-73 BY JRL REMOVE LAST REFERENCES TO DCS SWITCH
VERSION 16-2(43) 4-23-73 BY RHT CHANGE ARGTYP TO RFITYP
VERSION 16-2(42) 2-7-73 BY RHT ADD TYPE FOR ARG LIST ITEM
VERSION 16-2(41) 1-28-73 BY JRL PUT QBIND,FBIND HERE SO STATS CAN USE
VERSION 16-2(40) 1-23-73 BY RHT MAKE NIC & UNBOUND THE SAME
VERSION 16-2(39) 1-23-73 BY JRL CHANGE CODE FOR UNBND
VERSION 16-2(38) 1-8-73 BY JRL ADD MAXLOC MAXIMUM NUMBER OF FOREACH LOCAL ITEMVARS ALLOWED
VERSION 16-2(37) 12-13-72 BY jrl BUG #KS# ADD LOADVR SWITCH
VERSION 16-2(36) 11-21-72 
VERSION 16-2(35) 11-10-72 BY HJS MODIFY QPOP TO TAKE AS AN ARGUMENT AN ADDRESS FOR THE POPPED ENTRY
VERSION 16-2(34) 10-16-72 BY JRL CHANGE INVTYP TO 31 TO ALLOW CONTEXT ARRAY ITEMS
VERSION 16-2(33) 9-15-72 BY RHT ADD USER TABLE ENTRIES FOR INTERRUPTS
VERSION 16-2(32) 8-27-72 BY RHT PUT CELL FOR STACK UNWINDER RET ADRS IN USER TABLE
VERSION 16-2(31) 8-23-72 BY JRL ADD UNBND "ITEM"
VERSION 16-2(30) 8-20-72 BY RHT MODIFY USER TABLE
VERSION 16-2(29) 8-6-72 BY RHT ADD PRILIS TO USER TABLE
VERSION 16-2(28) 8-3-72 BY JRL ADD MPBIND TO TBITS DEFS FOR MATCHING PROCEDURES
VERSION 16-2(27) 7-27-72 BY RHT MAKE MACRO FOR DECLARING PD. ENTRIES
VERSION 16-2(26) 7-20-72 BY JRL CHANGE ARRTYP VALUE
VERSION 16-2(25) 7-20-72 BY RHT ADD PROCESS ITEM (TYPE 11)
VERSION 16-2(24) 6-20-72 BY DCS BUG #HU# BETTER TTY INFORMATION
VERSION 16-2(23) 5-16-72 BY DCS INTRODUCE VERSION 16
VERSION 15-2(9-22) 5-4-72 LOTS OF THINGS
VERSION 15-2(8) 2-19-72 BY RHT THE BRAVE NEW WORLD
VERSION 15-2(7) 2-5-72 BY DCS BUG #GJ# ADD LSTON LISTING CONTROL STUFF
VERSION 15-2(6) 2-5-72 BY DCS BUG #GI# REMOVE TOPSTR DUE TO NEW `CAT'
VERSION 15-2(5) 2-1-72 BY DCS BUG #GE# INSTALL SYMB %ALLOC BLK INDICES
VERSION 15-2(4) 1-31-72 BY DCS BUG #GE# UPDATE USER TABLE, %ALLOC BITS, INDICES
VERSION 15-2(3) 1-3-72 BY DCS BUG #FX# REMOVE COM2, COM2SW COMPLETELY
VERSION 15-2(2) 12-24-71 BY DCS BUG #FF# REMOVE SAILRUN(ASSUME RUNTIM OR LIB)
VERSION 15-2(1) 12-2-71 BY DCS INSTALL VERSION NUMBER

$;


COMMENT \ INTRODUCTION
	THIS IS THE FILE OF MACRO DEFINITIONS AND GLOBAL AC
	ASSIGNMENTS FOR THE SAIL COMPILER, THE SAIL RUNTIME
	ROUTINES.  NEEDLESS TO SAY, NOT ALL PORTIONS ARE USED
	BY ALL PEOPLE.
\

IFNDEF .JBVER < IFNDEF JOBVER < ?.JBVER__137 >> ;must be a constant
IFNDEF .JBREN < IFNDEF JOBREN < ?.JBREN__124 >> ;must be a constant

DEFINE JD ' (A) <
	IFNDEF .JB'A < 
		IFDEF  JOB'A < DEFINE .JB'A <JOB'A>>
		IFNDEF JOB'A < EXTERNAL .JB'A >
		>
	IFNDEF JOB'A < DEFINE JOB'A <.JB'A> >
>
JD (SA)
JD (VER)
JD (REN)
JD (UUO)
JD (SYM)
JD (FF)
JD (REL)
JD (41)
JD (DDT)
JD (CNI)
JD (TPC)
JD (APR)
JD (HRL)
JD (HGH)
JD (HVR)
JD (OPC)

;EXTERNAL JOBSA,JOBVER,JOBREN,JOBUUO
;EXTERNAL JOBSYM,JOBFF,JOBREL,JOB41,JOBDDT,JOBCNI,JOBTPC
;EXTERNAL JOBAPR,JOBHRL,JOBHGH,JOBHVR,JOBOPC
;;note:  RECSER also asks for JOBINT, but it wants it external


SUBTTL	SAIL/GOGOL MACROS AND SWITCHES


COMMENT \  SWITCHES : AN INTRODUCTION
Conditional assembly runs rampant in SAIL.  Most of the switches are used to
 select options (debug or no debug, etc.) Some are only valid at Stanford.

We have a program which, by reading the SAIL files and looking for switch-
 testing macros, can do the conditional assembly once and for all (removing
 the conditional stuff from the files.  It is such a set of files which
 we normally send out, so if you see some switches and macros below that
 never get referenced, it's because that code was taken out of your files.

The conditional assembly switches are assigned in the following files:

DCS	DCS	_2				;SLS (experimental) system
	FTDEBUG _1				;include debugging in cmplr

;NOCOM	COM2SW	_0				;OBSOLETE SWITCH, WAS TO
						; DISTINGUISH 2-SEG COMPILER
WOM	DCS	_1				;WOM (experimental) system

HEAD
	DCS	_if NDEF then 0 else DCS
;	COM2SW	_if NDEF then 1 else 0
	SIXSW	_if NDEF then STANSW else SIXSW ;sixbit PPN's
	HEDSYM	_if NDEF then 0 else HEDSYM	;With HEDSYM on, assembling HEAD
						; yields HEAD.REL, a symbol
						; file for the USERCON function

GLB	GLOBSW	_1				;runtimes know about glb mdl

LOW	SEGS	_1				;upper or lower assembly
	LOWER	_1				;assembles SAILOW or GLBLOW
	UPPER	_0

UP	SEGS	_1
	LOWER	_0
	UPPER	_1				;assembles UPPER or GLOBAL

FILSPC IS PART OF HEAD AS OF NOV 1973
FILSPC	FILXXX	_SAISGn				;SAIL upper segment name
	SLOFIL	_SAILOW				;SAIL lower segment name
GLOB <
	FILXXX	_GLBSGn				;global model upper segment name
	SLOFIL	_GLBLOW				;global model lower segment name
>;GLOB
	SGDEVC	_0		;device for segment files
	SGPPNN	_0		;PPN for segment files
	LOCSYM	_0				;no local uppers in lower file
	NOPROT	_0				;want upper segment protected

DB	FTDEBUG	_1

SAIL	LEAPSW	_1				;LEAP exists
	FTDEBUG	_if NDEF then 0 else FTDEBUG
	GLOBC	_if LEAP and STANSW then 1 else if NDEF then 0 else GLOBC
	PATSW	_if NDEF then 0 else PATSW	;compile AOS/SOS to PAT words
	RENSW	_if NDEF then 1 else RENSW	;compile Re-entrant Code
	TMPCSW	_if NDEF then (if STANSW then 0 else 1) else TMPCSW
					;TMPCOR UUO available and used
;; #KS BY JRL (12-13-72) ADD LOADVR SWITCH
	LOADVR  _if NDEF then 54 else LOADVR (for differences in block code
			for required rel files,libraries in LOADER 54)
	 SAILRUN was a switch controlling some runtimes.  Now runtimes will
	  be assembled to assume a compiler (since that's common anyway).
;; %BC% BY KVL (1/3/74) ADD BAIL SWITCH
	BAISW	_if STANFO then 1 else 0	;Bail only at stanford

GOGOL	UPPER	_if NDEF then 0 else 
	UPPER	_if NDEF then 0 else UPPER
	LOWER	_if NDEF then 0 else LOWER
	SEGS	_UPPER or LOWER
	GLOBSW	_if NDEF then 0 else GLOBSW
	RENSW	_if NDEF then 1 else RENSW	;assemble Upper-Segment Library
	 SAILRUN  no longer exists.


; SWITCH SETTINGS & MACROS

These macros come in pairs, and exist so that the above-mentioned
 program will have an easy job of it.  The meaning of each pair is
 obvious.  They may be used only as in the following example:
SW <		;or NOSW, starting in col. 1 (any comment out here)
(code to appear under this switch)
>;SW			or NOSW, must be same, any comment out here
 These things may be nested without confusing anyone.

Here are the macros
\

COMMENT \ The sites for SAIL compilers which want some code changes
	CMU	Carnegie-Mellon University
	IMSSS	Stanford University IMSSS (version of TENEX)
	ITS	MIT (Incompatible Timesharing System)
	JPL	Jet Propulsion Laboratory
	NIH	National Institutes of Health
	PARC	Xerox Palo Alto Research Center
	SRIAI	Stanford Research Institute AI
	SUAI	Stanford University AI
	SUMEX	Stanford University Medical Exchange - AI in Medicine
	TYMSHR	TYMSHARE (TYMCOM-X monitor)
	UOR	University Of Rochester
\

DEFINE STSW (V,VL) <IFNDEF V,<?V__VL>>	;sets switch if not defined
DEFINE STDEF (NAME,DEFINITION) <IFNDEF NAME,<DEFINE NAME <DEFINITION>>>
					;sets definition if not defined

FOR @# SITE IN (CMU,ITS,JPL,NIH,PARC,SRIAI,SUMEX,UOR,DEC) <
	DEFINE site <IFN site#SW,>
	DEFINE NO#site <IFE site#SW,>
  >
define def2 # (name,reason) <
	DEFINE name <IFN reason,>
	DEFINE NO#name <IFE reason,> 
  >
def2(TYMSHR,TYMSW)		;TYMSHARE code (names are not regular)
def2(STANFO,STANSW)		;SU-AI code (names are not regular)
def2(IMSSS,IMSSSW)		;IMSSS code (names are not regular)
def2(BAIL,BAISW)		;DEBUGGER STUFF
def2(GLOB,GLOBSW)		;global compiler (GLOBC) can service
				; non-global code, GLOBC is different
def2(GLOC,GLOBC)		; from GLOB (global model)
def2(HACK,HACKSW)		;TEMPORARILY VERSION FOR STANFORD
				; WILL DISAPPEAR NEXT SAISG
def2(KI10,KI10SW)		;CPU IS A KI10 (or KL10)
def2(KL10,KL10SW)		;CPU IS A KL10
def2(LOW,LOWER)			;lower bootstrap for 2 seg thing (only used in runtime) 
def2(LEP,LEAPSW)		;this compiler understands LEAP
def2(NRC,NRCSW)			;NEW-STYLE RECORD DESCRIPTORS
def2(REC,RCDSW)			;RECORDS ARE CONDITIONAL UNTIL DEBUGGED BETTER
				;RECSW WAS A VARIABLE IN THE COMPILER
def2(REN,RENSW)			;Re-entrant output (comp), runtimes (runtim)
def2(RENC,RENCSW)		;The compiler itself is reentrant
def2(RGC,RGCSW)			;RECORD GARBAGE COLLECTION (INSTEAD OF REF CNT)
def2(SFDS,SFDLVL)		;Operating system supports SFDs 
				;note: SFDLVL can be gtr 1, was IFG,IFE
def2(TENX,TENXSW)		;FOR TENEX (or TOPS-20) SYSTEMS
def2(UP,UPPER)			;upper segment code (only used in runtime)
def2(URHASH,URHSW)		;NEW LEAP HASH ROUTINES AND SEARCHES
def2(URLEAP,URLPSW)		;TRUE FOR DESCENDING ITEM ALLOCATION
				;FALSE FOR LOCALS ASCENDING, GLOBALS DESCENDING
def2(URSTAT,URSTSW)		;TRUE IF YOU WANT LEAP SEARCH STATISTICS
def2(XCOM,XCOMSW)		;COMPILER SAVE/RESTART (EXTEND) FACILITY


; ** CONDITIONAL SETTINGS ** SITE DEPENDENT

IFDEF AUXCAL,<STSW (TYMSW,1)>	;AUXCAL ONLY DEFINED AT TYMSHARE
IFDEF SPCWAR,<STSW(STANSW,1)>	;SPCWAR ONLY DEFINED AT STANFORD AI
IFDEF GTJFN, <STSW(TENXSW,1)>	;GTJFN on TENEX
IFDEF JGTJFN,<STSW(TENXSW,1)>	;JGTJFN on TOPS-20
STSW(TENXSW,0)			;normally non-tenex (over-ride follows)
FOR @# SITE IN (CMU,ITS,JPL,NIH,PARC,SRIAI,SUMEX,UOR,TYM,STAN,IMSS) <
	IFNDEF site#SW, <?site#SW__0> >

STANFO <
STSW (SIXSW,1)
?KI10SW__1
?KL10SW__1
?SFDLVL__0		;STANFORD DOESN'T HAVE SFD'S
>;STANFO	

CMU < ;**** EXTRA SWITCHES FOR CMU ******
DEFINE GGAS <IFN GASSW,>	;cmu version of global segment
DEFINE NOGGAS <IFE GASSW,>	;inverse
DEFINE GGGON <^^ GLOBSW__GASSW>	;
DEFINE GGGOFF <^^ GLOBSW __0>	;USED TO SELECT SOME OF SU-AI GLOB STUFF
STSW(GASSW,0)			;NOT USUALLY CMU GLOBAL
STSW(GLOBSW,0)			;CMU WILL DIDDLE THIS SWITCH DIRECTLY
?SFDLVL__0		 ;CMU DOESN'T HAVE SFD'S
>;CMU

IMSSS <;DEFAULT SETTINGS AT IMSSS
?TENXSW__1			;TENEX AT IMSSS
?KI10SW__1			;AND A KI
?SIXSW__1			;USE SIXBIT PPN'S FOR LOADER AT IMSSS
>;IMSSS

PARC <
?TENXSW__1			;TENEX AT PARC
?KI10SW__1
?SIXSW__0
>;PARC

JPL <
?TENXSW__1
?SIXSW__0
>;JPL

SRIAI <
?TENXSW__1			
?SIXSW__0
>;SRIAI

SUMEX <
?IMSSSW__1			;MOST IMSSS FEATURES
?SIXSW__0			;EXCEPT DONT USE SIXBIT
?TENXSW__1			;BUT IS TENEX
?KI10SW__1			;IS KI
>;SUMEX

UOR <
?DECSW __ 1			;DEC TOPS-10 MONITOR
?KL10SW__1			;IS KL
?STANSW __ 0			; NOT AT STANFORD
?GLOCSW __ 0			; NO GLOBAL MODEL
?GLOBSW __ 0			; NO GLOBAL MODEL STUFF
?URHSW __ 1			; USE NEW HASH TECHNIQUE
?URLPSW __ 1			; ALLOCATE ITEMS TOP DOWN
>;UOR

TYMSHR<
?SFDLVL__0			;NO SFD'S AT TYMSHARE
?KI10SW__1			;ALL KI'S
STSW(KL10SW,0)			;NO KL10 code for production (confusing)
>;TYMSHR

TENX <
?RENCSW__1			;WANT A RE-ENTRANT COMPILER
?RENSW__1			;WANT A RE-ENTRANT RUNTIME
?DECSW__0			;NOT A DEC SYSTEM
?STANSW__0			;IN FACT, EXPLICITLY NOT STANFORD
?GLOBSW__0			;NOT USUALLY GLOBAL FOR TENEX
?GLOBC__0			;
STSW(LOADVR,=54)			;TENEX SITES SEEM TO HAVE V. 54
?SFDLVL__0			;NO TENEX SITE HAS SFD'S
>;TENX


;; ** Conditional settings ** set if not defined above
IFN STANSW!TENXSW!CMUSW!TYMSW, <STSW(DECSW,0)>
STSW (HACKSW,STANSW)	;ONLY AT STANFORD
STSW (RENCSW,0)		;NOT USUALLY A REENTRANT COMPILER
STSW (DECSW,1)		; USUALLY DEC 10-50 BASED SYSTEM
STSW (HEDSYM,0)		;USUALLY NOT A USER-TABLE SYMBOL GENERATOR
STSW (KL10SW,.CPU.-2)	;.CPU. IS 4 FOR KL, 2 FOR KI, 1 FOR KA, 0 FOR 6
STSW (KI10SW,.CPU.-1)	;(funny character '26 = ^V = XOR)
STSW (XCOMSW,1)		;COMPILER SAVE/RESTART USUALLY SUPPORTED
STSW (SFDLVL,5)		;NORMAL SITE ALLOWS SFDs
STSW (RCDSW,1)		; NORMAL SITE ALLOWS RECORDS
STSW (RGCSW,RCDSW)	; NORMAL SITE USES RECORD GARBAGE COLLECTION
STSW (NRCSW,1)		; USUALLY A NEW-STYLE RECORD SYSTEM (now) ****
STSW (GLOBSW,0)		;USUALLY NOT A GLOBAL SEGMENT BEING MADE
STSW (SIXSW,0)		;usually PPNs are not SIXBIT
STSW (BAISW,1)		;USUALLY ON (BAIL)
STSW (URLPSW,1)		; from 9 on default to ROCHESTER LEAP 
STSW (URHSW,URLPSW)	;	ROCHESTER LEAP NEEDS ROCHESTER HASH
STSW (URSTSW,0)		;GENERALLY DON'T WANT THIS
IFG URLPSW-URHSW,<	;IF URLPSW = 1 & URHSW = 0
	PRINTX	URLPSW REQUIRES URHSW [FAIL ERROR ON NEXT LINE]
	#SWERR
>

KL10<	?KI10SW__1		;NORMALIZE
>;KL10
NOKI10<	?KL10SW__0
>;NOKI10

FOR SWITCH IN (CMUSW,ITSSW,JPLSW,PARCSW,SRIAISW,SUMEXSW,UORSW,STANSW,TYMSW,IMSSSW,TENXSW,DECSW)
 <IFN SWITCH <
	PRINTS * SWITCH: ON *
>>
IFG STANSW+TENXSW+CMUSW+TYMSW-1,<	;AT MOST ONE OF THESE CAN BE SET
	PRINTX	SWITCH INCOMPATIBILITY [TOO MANY SITES TURNED ON]
	#SWERR
>


COMMENT \ THE FILSPC STUFF -- OLDER HISTORY \


COMMENT \
VERSION 17(3) 8-19-73 BY RHT DECUS!!!
VERSION 17(2) 7-26-73 
VERSION 16-2(11) 7-26-73 BY JRL VERSION 17
VERSION 16-2(10) 7-26-73 BY jrl RECONFIGURE FOR VERSION 17
VERSION 16-2(9) 1-8-73 BY JRL LIB NAMES NOW LIBSA5,HLBSA5
VERSION 16-2(8) 12-2-72 BY RHT CONFIGURE FOR SAISG5, ETC
VERSION 16-2(7) 9-21-72 BY JRL RECONFIGURE FOR SAIL
VERSION 16-2(6) 8-29-72 BY RHT CONFIGURE FOR NSAIL (PROCESSES, EVENTS, ETC.)
VERSION 16-2(5) 7-2-72 BY RHT PUT UP VERSION 16
VERSION 16-2(4) 6-25-72 BY DCS SAISG4 UPDATES V16 FEATURES
VERSION 16-2(3) 6-24-72 BY DCS BUG #HX# PARAM PROCESSOR NAME, LIBRARIES
VERSION 16-2(2) 5-13-72 BY DCS INSTALL VERSION 16
VERSION 15-2(1) 12-2-71 BY DCS INSTALL VERSION NUMBER

\;


; FILSPC FILES

STSW(TSTSEG,0)
NOTENX <

DEFINE GSYSIN <>
?SYSIND__0
DEFINE FILEXX (str,len) <
	radix =10
	,len		;string
	point 7,[asciz /str/],-1
	radix =8
	>

IFN TSTSEG,<
stdef(filxxx,<SIXBIT /SAISGT/>)
stdef(slofil,<SIXBIT /SAILWT/>)
stdef(sgdevc,<SIXBIT /DSK/>)
STANFO <
stdef(sgppnn,<SIXBIT /  SAIL/>)
>;STANFO
?LOCSYM__1
?NOPROT__1
>;IFN TSTSEG

stdef(FILXXX,<SIXBIT /SAISG9/>)
;SAILOW FOR PROCESSOR SAIL, EXTENSION SAI
;SAILOX  "	      OSAIL,   "      OSA
;SAILOY  "	      NSAIL,   "      NSA
stdef(SLOFIL,<SIXBIT /SAILOW/>)		;PRODUCTION SAIL
stdef(SGDEVC,<SIXBIT /SYS/>)
stdef(SGPPNN,<0>)
STSW(LOCSYM,0)		;DON'T WANT LOCAL SEGMENT SYMBOLS
STSW(NOP)		;DON'T WANT SEGMENT PROTECT IF NOT GLOBAL

stdef(procsr,<ASCIZ /SAIL: />)		;FOR PRINTOUT OF PROCESSOR
stdef(rpgfil,<SIXBIT /QQSAIL/>)		;FOR COMPIL PURPOSES
stdef(defext,<'SAI'>)			;DEFAULT EXTENSION
stdef(BKTFIL,<FILEXX(<BKTBL.BKT>,9)>)	;Standard break tables
stdef(BKTDEV,<FILEXX(<SYS>,3)>)

stdef(liblow,<FILEXX(<SYS:LIBSA9>,10)>)	;REQUIRED LIBRARY
stdef(libhi,< FILEXX(<SYS:HLBSA9>,10)>)	; (HISEG VERSION)
BAIL<
stdef(bailod,<FILEXX(<SYS:BAIL.REL>,12)>)	;RESIDENCE OF BAIL
stdef(baipds,<FILEXX(<SYS:BAIPD9.REL>,14)>)	;JFR pd's FOR RUNTIMES
>;BAIL
stdef(opdev,<SIXBIT /SYS/>)	;DEVICE FOR OPCODE FILE
stdef(opname,<SIXBIT /2OPS2/>)	;NAME (EXTEN ALWAYS OPS)
stdef(opppn,<0>)		;WHERE IT'S AT

GLOB <
DEFINE FILXXX <SIXBIT /GLBSG9/>
DEFINE SLOFIL <SIXBIT /GLBLOW/>
DEFINE SGDEVC <SIXBIT /SYS/>
DEFINE SGPPNN <0>
?NOPROT__1
?LOCSYM__1
>;GLOB

CMU <
GGAS <	;OH WELL
DEFINE SGDEVC <SIXBIT/DSK/>
DEFINE FILXXX <SIXBIT/CONSEG/>
DEFINE SGPPNN <XWD 1305,60410>	
		;KLUDGE - HACK - A700CR00, WHEREON THE CONTROLLER LIVES.
>;GGAS
>;CMU
>;NOTENX



TENX <
?SYSIND__2
define gsysin <
	MOVE	SYSIND,$OSTYP	; 0 for TENEX, 2 for TOPS20
>;
DEFINE FILEXX (tnxstr,tnxlen,t20str,t20len) <
	radix =10
	,tnxlen
	point 7,[ASCIZ /tnxstr/],-1
	,t20len
	point 7,[ASCIZ /t20str/],-1
	radix =8
	>

IFN TSTSEG,<
stdef(FILXXX,<FILEXX(<<SAIL>T-SAISGT.SAV>,18,<SAI:T-SAISGT.EXE>,16)>)
stdef(SLOFIL,<SIXBIT /SAILWT/>)
stdef(LIBLOW,<FILEXX(<LIBSAT.REL>,10,<LIBSAT.REL>,10)>)
?LOCSYM__1
?NOPROT__1
>;IFN TSTSEG

BAIL<
stdef(BAILOD,<FILEXX(<<SAIL>BAIL.REL>,14,<SAI:BAIL.REL>,12)>)
;;%##% JFR 2-16-75 FOR KNOWLEDGE OF SAIL RUNTIMES
stdef(BAIPDS,<FILEXX(<<SAIL>BAIPD9.REL>,16,<SAI:BAIPD9.REL>,14)>)
>;BAIL
stdef(FILXXX,<FILEXX(<<SAIL>T-0-SAISG9.SAV>,20,<SAI:T-0-SAISG9.EXE>,18)>)
stdef(SLOFIL,<SIXBIT /LOWTSA/>)
stdef(SLOLOD,<ASCIZ/SYS:LOWTSA,/>)		;FOR INTERFACE TO LOADER
stdef(LIBLOW,<FILEXX(<<SAIL>LIBSA9.REL>,16,<SAI:LIBSA9.REL>,14)>)
stdef(LIBHI,< FILEXX(<<SAIL>HLBSA9.REL>,16,<SAI:HLBSA9.REL>,14)>)
IMSSS<
stdef(SDTLOD,<ASCIZ /,SDDTRL[S,AIL]/>)
>;IMSSS
IFE TSTSEG,<
stsw(LOCSYM,0)
stsw(NOPROT,0)
>;IFE TSTSEG

STSW(SEGPAG,630)		;PAGE WHERE THE SEGMENT STARTS
STSW(STARTPAGE,610)		;PAGE WHERE CHANNEL BUFFERS BEGIN
STSW(JFNSIZE,20)		;NUMBER OF CHANNELS ALLOWED

stdef(RUNLOD,<FILEXX(<<SUBSYS>LOADER.SAV>,18,SYS:LINK.EXE,12)>)
stdef(LODTFN,<FILEXX(LOA.TMP,7,LNK.TMP,7)>)
stdef(BKTFIL,<FILEXX(<<SAIL>BKTBL.BKT>,15,BKTBL.BKT,9)>)
stdef(BKTDEV,<FILEXX(DSK,3,SAI,3)>)
stdef(UDTFIL,<FILEXX(<<SAIL>UDDT.SAV>,14,<SYS:UDDT.EXE>,12)>)
stdef(OPFILE,<FILEXX(<<SAIL>3OPS3.OPS>,15,<SAI:3OPS3.OPS>,13)>)
>;TENX


; NARRATIVE FILSPC ACCOUNTS

STANFO <  ; ACTUALLY, NOT KEPT UP LATELY
COMMENT \
HISTORY OF SAIL SYSTEMS
3-1-71   VERSION 'SG1',,10
 NEW SAIL SYSTEM UP, COMPILER AND RUNTIME
 FEATURES:
   NEW SEGMENT SCHEME ELIMINATES SAISYM GARBAGE, ALLOWS EXPO SHARED
	SEGMENTS, USE OF LATEST DEC LOADER.
   NEW RAID WENT UP AT SAME TIME.
   NEW LOADER (.052 MODIFIED) AT SAME TIME; WORKS AS LISP LOADER.
   NEW DDT?
   I/O ERROR ENABLE BUSINESS; BETTER SUBSTRING STUFF;
	PUNCTUATION ERROR ENABLE IN LOOKUP, ETC.
   NONSTD BUFFER SIZES
   USERCON
   FREITM
   GC CHANGE (WORKS WITH XPAND 0)
   CVFIL, CVOS BETTER.
3-12-71  GLOBAL SEGMENT GLBLOW,GLBSG2 UP
   FIXED PTYALL BUG, WHICH CAUSED MESSAGE PROCEDURES TO BLOW
3-15-71 GLOBAL SEGMENT GLBLOW,GLBSG3 UP
   PTYALL FIXES SOME MORE -- GLUB.
3-21-71  GLBLOW, GLBSG4 CREATED, TESTED
    REQUIRE -1 NEW!ITEMS (GLOBAL OR NOT) INHIBITS LOCAL MODEL
3-21-71 FILES FOR RUNTIMES, GREATLY MODIFIED, TRANSFERRED
    FROM T,AIL WHERE THEY HAD BEEN SUCCESSFULLY TESTED IN
    ALL CONFIGURATIONS I COULD THINK OF -- FACILITATE MUCH
    MORE RAPID LIBRARY CREATION (THERE IS NOW ONLY 1 SCISS).
6-22-71  MESPRO CHANGED TO ADD NEW FEATURE TO PUT!DATA.

7-16-71 VERSION 'SG2',,11  (version SG6 for global model)
 NEW SAIL SYSTEM, COMPILER AND RUNTIME
 FEATURES:
  CASE STATEMENT IMPROVEMENTS OUTLINED IN NEWMAN AND DOCS.UPD
  REQUIRE n VERSION IMPLEMENTED
  MYRIAD BUGS FIXED
  LEABOT AND FRLOC TABLES ELIMINATED FROM USER TABLE
  REQUIRE -1 NEW!ITEMS GIVES NO LOCAL MODEL ALLOCATION
  RETURN CODE CHANGED -- MORE EFFICIENT -- NOW A LOCAL STRING
    VARIABLE MAY BE RETURNED FROM A RECURSIVE STRING PROCEDURE.
  AOS PAT/SOS PAT STUFF REMOVED FROM GENERATED PROCEDURES.
  FREITM MOVED TO BE WITH OTHERS IN USER TABLE
  THE RES COUNTER SYSTEM (/K) INSTALLED (SEE DOCS.UPD ETC.)
7-21-71 VERSION GLBLOW,GLBSG7 UP
	MESSAGE PROCEDURE ROUTINE PUT!DATA(0,0,NAME) CHANGED TO REQUIRE
ALL JOBS ENTERED TO HAVE SAME VERSION NUMBER
10-20-71 VERSION GLBSG8 UP - RANDOM BUGS FIXED

5-13-72 VERSION 16 (16 runtime) OF SAIL UP FOR EXPERIMENTATION
 FEATURES:
  1. Various improvements
  2. New stack structure, up-level addressing, jumps out BY RHT
  3. Improved LEAP by JRL
  4. Improved macros by HJS
 SAISG3
6-25-72 VERSION 16 PUT UP AS STANDARD PROCESSOR,  NSAIL.  The files:
  NSAIL.DMP[1,3] is the compiler, ext. NSA (uses SAISG4).
  SAILOY.REL[1,3] is the low segment (always for NSAIL)
  SAISG4.SEG[1,3] is the segment
  LIBSA1, HLBSA1[1,3] are the libraries.
 Will go back to SAISG3 shortly.
7-3-72 VESRION 16 PUT UP AS STANDARD SAIL
  OLD SAIL (VERSION "15") BECOMES STANDARD PROCESSOR "OSAIL"
	EXTENSION .OSA , LOW SEGMENT IS SAILOX (PREV SAILOW)
	SAISG2.REL IS ITS UPPER
  NOW SAISG3.SEG IS THE UPPER, SAILOW.REL IS THE LOWER, LIBSA1, HLBSA1 
  ARE THE LIBRARIES.
10-22-72 NEWER, BETTER SAIL PUT UP.  SAISG4 IS THE SEGMENT

12-7-72 VERSION 16 (REVISED) PUT UP AS STANDARD PROCESSOR
 FEATURES:
  1. miscellaneous bugs fixed
  2. More LEAP modifications by JRL
  3. CLEANUPs to blocks
  4. User initialization happens as first executable statement.

 SAISG5.SEG is the segment.  LIBSA5.REL is the library.

7-25-73 VERSION 17 PUT UP AS STANDARD PROCESSOR (DECUS RELEASE??)
 FEATURES
  1. bug fixes
  2. macro changes
  3. process changes
 SAISG6.SEG is the segment. LIBSA6.REL, the library.
 GLBSG6.SEG is the global segment.

8-19-73 TRANSFERRED FILES OVER TO X,AIL FOR DECUS RELEASE
\
>;STANFO
;LISTING CONTROL MACROS & THE LIKE

;VARIOUS HANDY MACRO DEFINITIONS TO TRY TO MAKE THE CODE
;SOMEWHAT MORE READABLE.

II__1
FOR @' JJ IN (HEAD,SAIL,PARSE,PDEFS,PRODS,SUBRS,SMTB,SYM,GEN,<ARRAY>
,EXPRS,STATS,LEAP,TOTAL,COMSER,GOGOL,STRSER,IOSER,LEPRUN,MESPRO,WRDGET) <
?..'JJ__II
II__II1
>
IFDEF SETLST,<SETLST>

IFNDEF ..LIST,<
..LIST__0
FOR @' JJ IN (HEAD,SAIL,PARSE,SYM,GEN,ARRAY,EXPRS,STATS,LEAP,<TOTAL>
,COMSER,GOGOL,STRSER,IOSER,LEPRUN,MESPRO,WRDGET) <
?..LIST__..LIST!..'JJ
>
>;ifndef ..list

IFDEF SETLS2,<SETLS2>
DEFINE LSTON ' (JJ) <
	XLIST
IFN ..LIST & ..'JJ,<
	LIST>
>
	LSTON	(HEAD)

DEFINE DSCR <COMMENT  > ; FOR DIRECTORY MAKER

DEFINE GEN <IFE .NOGEN,<LALL>>
DEFINE NOGEN <XALL>
?.NOGEN__1	;DON'T EXPAND MACROS AT ALL AFTER FIRST NOGEN
	NOGEN

DEFINE IFNB (X) <IFDIF <><X>,>
DEFINE IFB (X) <IFIDN <><X>,>


DSCR  STORAGE MANAGEMENT MACROS


DSCR  HERE
CAL MACRO
PAR ROUTINE NAME
DES For runtime routine vector.  If this is a library or one-segment
 run, this is equivalent to placing a label "HERE".  Otherwise, the
 label is placed on a JRST instruction in a vector of JRST's in the
 upper segment.  The  JRST is to "HERE".  This allows the code for
 runtimes to be changed without forcing everyone to forsake their
 SAIL-compiled core images.


NOTENX <
?DSPLEN__=280	;LAST CHANGED 2-8-77, FROM 260
>;NOTENX


TENX <
?DSPLEN__=350	;LAST CHANGED 12-03-79, FROM 330  (SDD)
>;TENX
GLOB <
?DSPLEN__DSPLEN+=50 ; SINCE THIS TAKES MORE
>;GLOB

;;#SM# 5-30-74 RLS TEST FOR OVERFLOW OF DISPATCH TABLE
DEFINE HERE(X) <
UP <
	FQQQQ __ .
	USE DSPCH	;SO THAT THE LABELS HAVE THE SAME ADDRESS
			;FROM ONE ASSEMBLY TO ANOTHE.
^^ X :	JRST	FQQQQ
IFGE .-DSPBAS-DSPLEN, <
PRINTS / Dispatch vector size exceeded, bump DSPLEN
/
>;
	USE
>;UP
NOUP <
^^ X :			;IF NOT MAKING AN UPPER SEGMENT, DOES NOT MATTER.
>;NOUP
>
;;#SM#

DEFINE HEREFK (X,XFAKE) <
UP<
^^ XFAKE:		; A FAKE LABEL (FELLOW WILL HAVE REAL THING IN SPARES
>;UP
NOUP <
HERE(X)			;ONLY MATTERS IF MAKING A SEGMENT
>;NOUP
>

DSCR SETCOR (SIZE,FIRST,LAST)
CAL MACRO
PAR SIZE is CORGET size desired
 FIRST (optional) is vbl which will point to first word
 LAST (optional) is vbl which will point to first word after block
RES CORGET called, B put into FIRST, LAST computed
ERR if not enough core, complains
DES used in ALLOC (SAILOR sequence)
SEE ALLOC


DEFINE SETCOR (SIZE,FIRST,LAST) <
	MOVE	C,SIZE
	PUSHJ	P,CORGET
	ERR	<CAN'T GET CORE FOR FIRST ALLOCATION>
	IFDIF <FIRST><>, <MOVEM	B,FIRST>
	IFDIF <LAST><>,<
		ADD	C,B
		MOVEM	C,LAST
>>

DSCR DATA, ZERODATA, TABLEDATA,--etc.
CAL MACRO
PAR One argument, a description
RES For ZERODATA, the ZVBLS PC is switched to for the data.  For others,
 the VBLS PC.  A check is made to ensure that the appropriate area is
 big enough for the new data.
DES This allows data to be concentrated in one area (for reentrancy
 consideration, one-instruction CLEAR operations, etc.), but to
 be defined locally.  Some special purpose programs can examine the
 CREF listing file to print summaries, sorted cross-references, etc.


DEFINE DATA (MSG) <
	USE	VBLS
	IFGE	.-DBASE-DSIZE,<
	PRINTX	DATA AREA TOO SMALL [you will get a FAIL error on next line]
	#DATERR
>>

DEFINE TABLEDATA (MSG) <
	ZERODATA ()
>

DEFINE TABCONDATA (MSG) <
	DATA ( )
>

DEFINE ZERODATA (MSG) <
	USE	ZVBLS
	IFGE	.-ZBASE-ZSIZE,<
	PRINTX	ZEROED DATA AREA TOO SMALL [you will get a FAIL error on next line]
	#DATERR
>>

DEFINE BITDATA (MSG) <	USE>

DEFINE BITDDATA (MSG) <	USE>

DEFINE BIT2DATA (MSG) <	USE>

DEFINE BITD2DATA (MSG) < USE>

DEFINE ACDATA (MSG) <	USE>

DEFINE AC2DATA (MSG) <	USE>

DEFINE ENDDATA <
IFDEF ZBASE, <
	DATA ()		;CHECK
	ZERODATA ()		;CHECK
	USE
>>




COMMENT 

DSCR LEVPOINT
DES CHEAP MACRO TO GENERATE POINTERS TO DISPLAY LEVEL FIELD OF WORDS


DEFINE LEVPOINT(AD)< POINT DLFLDL,AD,35-LLFLDL>

;;%  % CMU STYLE TRAP CALL MACRO -- SHOULD REALLY BE TURNED INTO ROUTINE CALL
DEFINE TRPCAL (P1,P2,P3,P4,ADR) <
BEGIN
	SKIPN	ADR
	 JRST 	 NOTRP
CMU <
	GGGON ;
>;CMU
GLOB <
	PUSH	P,USER
	MOVE	USER,GOGTAB	;IT MAY HAVE BEEN GLUSER
>;GLOB
	PUSH	P,TEMP
	PUSH	P,UUO1(USER)
	MOVEI	TEMP,.TRACS
	BLT	TEMP,.TRACS+11
	MOVE	TEMP,-1(P)
	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	PUSHJ	P,@ADR
	MOVSI	TEMP,.TRACS
	BLT	TEMP,11
	POP	P,UUO1(USER)
	POP	P,TEMP
GLOB <
	POP	P,USER		;GET IT BACK
>;GLOB
CMU <
	GGGOFF			;DELSELECT GLOBAL STUFF
>;CMU
NOTRP:
BEND
>;END TRPCAL DEF


; MACHINE-EXTENDING MACROS (SOME USEFUL CONSTANT, STORAGE/STORAGE MANIPULATORS)

DSCR MOVEWI, MOVEW, MOVE6, MOVEI7, LOAD6, LOADI7
CAL MACRO
DES Provide extended "instructions" for data movement
 MOVEWI(I,J) moves J (immed) to I via TEMP
 MOVEW(I,J)  moves J to I via TEMP
 MOVE6(I,J)  moves SIXBIT /J/ to I via TEMP
 MOVEI7(I,J) moves addr of ASCIZ /J/ to I via TEMP
 LOAD6 (I,J) moves SIXBIT /J/ to AC I
 LOADI7(I,J) moves addr of ASCIS /J/ to AC I
SID TEMP -- sometimes changed


DEFINE MOVEWI (I,J) <
		MOVEI TEMP,J
		MOVEM TEMP,I
>

DEFINE MOVEW (I,J) <
		MOVE	TEMP,J
		MOVEM	TEMP,I
>

DEFINE MOVE6 (I,J) <
		MOVE	TEMP,[SIXBIT /J/]
		MOVEM	TEMP,I
>

DEFINE MOVEI7 (I,J) <
		MOVEI	TEMP,[ASCIZ /J/]
		MOVEM	TEMP,I
>

DEFINE LOAD6 (I,J) <
		MOVE	I,[SIXBIT /J/]
>

DEFINE LOADI7 (I,J) <
		MOVEI	I,[ASCIZ /J/]
>

DSCR	PWORD,PCHAR,IPWORD,IPCHAR,PLEFT,PRIGHT,IPLEFT,IPRIGHT
CAL MACRO
DES MAKE BYTE POINTERS EASIER TO TYPE
  THE ONES WITH "P" ARE SETUP SO THAT AN LDB FETCHES THE VALUE
  THE ONES WITH "IP" ARE SETUP SO THAT AN ILDB FETCHES THE VALUE


DEFINE PWORD (A) <
	POINT	36,A,35>
DEFINE PLEFT (A) <
	POINT	18,A,17>
DEFINE PRIGHT (A) <
	POINT	18,A,35>
DEFINE PCHAR (A) <
	POINT	7,A,35>
DEFINE IPWORD (A) <
	POINT	36,A>
DEFINE IPLEFT (A) <
	POINT	18,A>
DEFINE IPRIGHT (A) <
	POINT	18,A,17>
DEFINE IPCHAR(A) <
	POINT	7,A>

DSCR SAVACS, RESTACS (L)
CAL MACRO
PAR a list like <A,C,LPSA>
RES specified AC's pushed on (popped from) P-stack

DEFINE SAVACS (L) <
 FOR II IN  L ,<
	PUSH	P,II
>>
DEFINE RESTACS (L) <
FOR II  IN  L, <
	POP	P,II
>>

DSCR CALL6(I,J)
CAL MACRO
PAR I is AC# if J is present, else see J
 J is symbolic value for a system CALL
RES does CALLI AC,U&INDEX 
 AC defaulted to 0


NOTENX <
NOSTANFO <
DEFINE CALL6 ' (I,J) <
	IFNB <J>,<
		IFNB <I>,<CALLI I,U'J>
		IFB <I>,<CALLI U'J>
	>
	IFB <J>,<CALLI	U'I>
>
>;NOSTANFO

STANFO <
DEFINE CALL6 ' (I,J) <
	IFNB <J>,<
		IFNB <I>,<J I,>
		IFB <I>,<J>
	>
	IFB <J>,<I>
>
>;STANFO

NOSTANFO <
DEFINE CX ' (Y,Z) <
?U'Y__Z
>

	CX RESET,0	;0 RESET IO
	CX DDTIN,1	;1 EXT-GET DDT CHAR.
	CX SETDDT,2	;2 SETDDT LOC IN PROTECTED JOB DATA
	CX DDTOUT,3	;3 EXT:SEND DDT CHAR.
	CX DEVCHR,4	;4 DEVICE CHARACTISTICS
	CX DDTGT,5	;5 GET DDT MODE
	CX GETCHR,6	;6 DEVICE CHAR.(DIFF. NAME)
	CX DDTRL,7	;7 RELEASE DDT MODE
	CX WAIT,10	;10 WAIT TILL DEVICE INACTIVE
	CX CORE,11	;11 CORE UUO
	CX EXIT,12	;12 EXIT
	CX UTPCLR,13	;13 CLEAR DEC TAPE DIRECTORY 
	CX DATE,14	;14 GET DATE
	CX APRENB,16	;16 ENABLE APR FOR TRAPPING
	CX SWITCH,17	;20 RETURN DATA SWITCHES
	CX REASSIGN,21	;21 REASSIGN DEVICE TO ANOTHER JOB
	CX TIMER,22	;22 RETURN JIFFY CLOCK TIME
	CX MSTIME,23	;23 RETURN TIME OF DAY IN MS
	CX GETPPN,24	;24 RETURN PROJECT-PROGRAMMER NUMBER
	CX TRPSET,25	;25 SET PI TRAP LOC, AND USER IO
	CX TRPJEN,26	;26 DISMISS INTERRUPT TO EXEC MODE
	CX RUNTIM,27	;27 RETURN TOTAL JOB RUNNING TIME
	CX PJOB,30	;30 RETURN JOB NUMBER
	CX SLEEP,31	;31 SLEEP FOR N SECONDS, THEN RETURN TO USER
	CX SETPOV,32	;32 SET PUSH DOWN OVERFLOW TRAP
				;(FOR COMPATIBILITY ONLY)
	CX PEEK,33	;33 PEEK INTO SYSTEM CORE.		;JS
	CX GETLIN,34	;34 GET NAME OF TTY
	CX RUN,35	;35 RUN COMMAND
	CX SETUWP,36	;36 SET USER WRITE PROTECT
	CX REMAP,37	;37 REDO CORE MAP
	CX GETSEG,40	;40 GET SEGMENT
	CX GETTAB,41	;41 GETTAB ILLEGAL AT STANFORD.
>;NOSTANFO
>;NOTENX




;  TELETYPE COMMUNICATION MACROS

DEFINE OP1 &(OPR,MS,ACC)  <
	IFIDN <ACC><>, <II__0>
	IFDIF <ACC><>, <II__ACC>
	OPR&. II,[ASCIZ /MS/]
>

DSCR IOERR (STR)
CAL MACRO
PAR ASCII string to be printed
RES calls IOERR. UUO to print message, either restart
 compiler or EXIT


DSCR ERR (STR,CODE,ROUT)
CAL MACRO -- calls ERR. UUO
PAR STR ASCII string to be printed
 CODE determines how UUO functions
 ROUT is address or literal to jump to if ERR continues
RES If SAIL is on DPY, displays input line
 Prints STR
 CODE%2 determines what else to print -- if CODE is:
  0-1:  Print nothing more
  2-3:  Ident name for Semantics in LPSA (SAIL only)
  4-5:  Ident name for Semantics in UUO instr (SAIL only)
  6-7:  Value of AC in AC field of instr preceding UUO
 10-11: The UUO in octal
 12-13: Value of AC field of instr preceding that indicated
        by UUO1(GOGTAB)

 If CODE is even, don't allow continuation -- otherwise
  allow continuation in manner described by error message.
 If ROUT is present, jump to it -- else continue in line

FOR OP  IN  (ERR,IOERR) <
DEFINE OP (MSG,AC,ADDR) <
	IFIDN	<ADDR><>,<OP1 (OP,<MSG>,AC)>
	IFDIF <ADDR><>,<JRST	[OP1 (OP,<MSG>,AC)
			   JRST	ADDR ]>
>>

DSCR CORERR
CAL MACR
PAR	message
RES	Types the message, then exits the program 
SID none

DEFINE CORERR(MSG) < JRST [	PUUO	3,[ASCIZ /MSG
/]
NOTENX <
				HALT	.	;DOT IN LITERALS REFERS TO THE
						;LOC COUNTER OUTSIDE THE LITERAL
>;NOTENX
TENX <
				JSYS	HALTF
>;TENX
							]>

DSCR PRINT, TERPRI (STR)
CAL MACRO -- calls prin.. uuo.  
PAR Ascii message
RES Types string -- types CRLF after if TERPRI -- ERRPRI sends to log file if
user is enabled for that.
SID none

DEFINE ERRPRI (X) <
	PUSH	P,A
	MOVEI	A,[ASCIZ /X
/]
	PUSHJ	P,PRINT.
	POP	P,A
>

DEFINE PRINT (X) <
	PUUO 3,[ASCIZ /X/]
>

DEFINE TERPRI (X) <
	PUUO	3,[ASCIZ /X
/]>

DEFINE SPRINT(X) <	;SAFE PRINT, BEFORE UUO SET UP
	TTCALL 	3,[ASCIZ /X/]
>



;  INPUT/OUTPUT AIDS

DSCR MAKCDB (CHN, NAM, MODE, I, O)
CAL MACRO
PAR CHN channel number
 NAM Prefix for symbols defined
 MODE data mode
 I,O # input, # output buffers
RES generates a table to specify all (most?) data about
 a file (Source, Rel, Command, etc.), instructions
 tailored for this channel -- it takes the form: 


DEFINE MAKCDB &  (CHN,NAM,MODD,I,O)  <
NAM&CDB:
NAM&MOD: MODD			;DATA MODE
NAM&DEV: 0			;DEVICE NAME IN SIXBIT
NAM&HED:
	IFN O,<XWD NAM&HDR,0>	;BLOCK HEADER POINTER
	IFE O,<XWD NAM&HDR,NAM&HDR>
NAM&HDR: 0			;I/O HEADER BLOCK
NAM&PNT: 0			;I/O BYTE POINTER
NAM&CNT: 0			;I/O CHAR COUNT
^NAM&FIL: 0			;I/O FILE NAME
^NAM&EXT: 0			;I/O EXTENSION
;;#%%# BY JFR 11-7-74 KEEP PPN HERE, TOO
^NAM&PPN: 0			;I/O PPN
NAM&OP:	OPEN	CHN,NAM&CDB	;OPEN INSTRUCTION
NAM&NT:
notymshr <
	IFN I,<LOOKUP CHN,NAME>
	IFE I,<ENTER  CHN,NAME>
>;notymshr
tymshr <
	IFN I,<LOOKUP CHN,IODCNT>
	IFE I,<ENTER CHN,IODCNT>
>;tymshr
NAM&SPC:
	IFN O,<OUTBUF CHN,O>
IFE O,<
NOSTANFO <
	 IFIDN <NAM> <SRC>, <
		PUSHJ P,[MOVEI TEMP,.+1 ; PTR TO DESCRIPTOR, CALL UINBF ROUTINE
			 JRST	UINBF] >
	 IFDIF <NAM> <SRC>, <INBUF CHN,I>
>;NOSTANFO
STANFO <
		    UINBF CHN,.+1
>;STANFO
>;IFE O
NAM&BFS: IFN O,<O>
	IFE O,<I>	;# OF BUFFERS
	202		;MAKE BIGGER BUFFERS THAN NORMAL (INPUT ONLY)
;;=I10=	ADD PLACE FOR SFD'S
SFDS<
NAM&PTH:	BLOCK 4+SFDLVL	;PLACE FOR PATH TO GO
> ;SFDS
>; end MAKCDB definition

DSCR CHKCHN, TSTERR, TSTEOF
CAL MACRO
PAR First argument is channel # (AC containing same for CHKCHN)
 2d argument is routine name for CHKCHN, address for TSTEOF
RES CHKCHN makes sure channel # in AC is legal
  prints error message using routine name, if not legal
 TSTERR does an error STATZ
 TSTEOF jumps to Address if EOF is present on the channel

DEFINE CHKCHN (AA,ROUTIN) & <
		TRZE	AA,777760	;ZERO BITS AND TEST VALID
		ERR <ROUTIN&: INVALID CHANNEL NUMBER>
>

DEFINE TSTERR (CHAN) <
		STATZ CHAN,740000 ;ANY ERRORS?
>

DEFINE TSTEOF (CHAN,EOFADD) <
		STATZ CHAN,20000  ;END OF FILE?
		JRST EOFADD	  ; YES
>



; RANDOM OTHER MACROS

DEFINE SETNIT <
	MOVE	TEMP,[PUSHJ P,%UUOLNK]	;MAKE SURE WE CAN DO UUOS
	MOVEM	TEMP,41
	MOVE	P,ALLPDP	;AND PUSHJ'S
>

DSCR SETPOV(AC,STR)
CAL MACRO
PAR AC REPRESENTING PUSH-DOWN POINTER
STR REPRESENTING SOME SUGGESTIONS FOR ACTION WHEN THIS PTR OVERFLOWS
RES POVTAB has one entry for each AC.  the string pointer (0 if none)
 is put into this entry.  If a PDP in this AC overflows,  POVTRP, which
 is enabled in SALNIT for PDL-OV, prints the string as a standard fatal
 error message.  POVTRP is in  COMSER.
SEE POVTRP


DEFINE SETPOV (AC,STR) <
 IFNB <STR>,<MOVEI TEMP,[ASCIZ ?STR?]>	;GET VALUE
 IFB <STR>,<MOVEI TEMP,0>
 II__(AC+17)&17			;BETWEEN 0 AND 17
 JJ__II-(2*(II/2))		;ODD OR EVEN
 IFE JJ,<HRLM TEMP,POVTAB+(II/2)>	;EVEN-- LEFT
 IFN JJ,<HRRM TEMP,POVTAB+(II/2)>	;ODD -- RIGHT
>;SETPOV

DSCR OPTSYM(SYM)
CAL MACRO
PAR SYM IS SYMBOL TO BE DEFINED
RES IF  WHERSW  IS ON, THEN  SYM  is defined as a loader symbol
with value of PCNT.
Principally to help external code optimizer.


DEFINE OPTSYM(SYM)<
	MOVE	TEMP,[RADIX50 50,SYM]
	PUSHJ	P,OPTSY.
>



;TBITS DEFINITIONS

DEFINE BIT(NAME,BITT) <IFDIF <NAME><SPARE>,<?NAME__BITT>>
DEFINE DEFTBS <
	BIT	(RES,400000)	;RESERVED WORD
	BIT	(CNST,200000)	;CONSTANT ENTRY
	BIT	(SPARE,100000)	;****
	BIT	(INTRNL,40000)	;INTERNAL SYMBOL (SYMBOL EXPORTED)
	BIT	(EXTRNL,20000)	;EXTERNAL SYMBOL (STORAGE FOUND ELSEWHERE)
	BIT	(MPBIND,10000)	;MATCHING PROCEDURE OR BINDING ITEMVAR
	BIT	(VALUE,4000)	;FORMAL PARAMETER CALL BY VALUE
	BIT	(REFRNC,2000)	;FORMAL PARAMETER CALL BY REFERENCE
	BIT	(CONOK,1000)	;OK TO CALL INTRINSIC WITH CONST ARGS AT COMPTIME
	BIT	(SIMPLE,400)	;FOR DISPLAY SYSTEMS ONLY
	BIT	(MESSAGE,200)	;A MESSAGE PROCEDURE !!!!!(STANFORD ONLY).
	BIT	(OWN,100)	;OWN VARIABLE ?
	BIT	(ANYTYP,40)	;ANYTYPED VARIABLE (USED IN PROCEDURE CALLS)
	BIT	(SAFE,20)	;SAFE -- FOR ARRAYS AND SUCH.
	BIT	(DEFINE,10)	;DEFINED MACRO IDENTIFIER
	BIT	(RECURS,4)	;THIS ROUTINE IS REENTRANT
	BIT	(BILTIN,2)	;IF ON IN TBITS, DON'T SAVE AC'S ON CALL.
	BIT	(SBSCRP,1)	;SUBSCRIPED VARIABLE (ARRAY)

;RIGHT HALF BITS -- TBITS WORD.

	BIT	(INPROG,400000)	;PROCEDURE BEING DEFINED, KEEP FIXUP CHAIN
	BIT	(GLOBL,200000)	;GLOBAL LEAP VARIABLE
	BIT	(FORTRAN,100000);FORTRAN PROCEDURE (EXTERNAL)
	BIT	(FORWRD,40000)	;FORWARD PROCEDURE OR LABEL
	BIT	(PROCED,20000)	;PROCEDURE
	BIT	(SHORT,10000)	;SHORT INTEGER OR SHORT REAL
	BIT	(ITMVAR,4000)	;LEAP ITEMVAR
	BIT	(PNTVAR,2000)	;RECORD POINTER VARIABLE
	BIT	(BOOLEAN,1000)	;BOOLEAN VARIABLE ?? (SAME AS INTEGER FOR NOW
				; SEE TYPSET IN FILE "GEN"
	BIT	(ITEM,400)	;LEAP ITEM
	BIT	(STRING,200)	;A FHQ STRING
	BIT	(LPARRAY,100)	;TYPE OF THIS ITEM IS ARRAY
	BIT	(SET,40)	;LEAP SET
	BIT	(LABEL,20)	;LABEL
	BIT	(LSTBIT,10)	; COMPLEX NUMBER ?? (NOT IMPLEMENTED)
	BIT	(DBLPRC,4)	; DOUBLE PRECISION NUMBER ?? (NOT IMPLEMENTED)
	BIT	(FLOTNG,2)	;REAL NUMBER
	BIT	(INTEGR,1)	;INTEGER NUMBER

;LEFT HALF OF %ERFLGS WORD -- STATE OF ERROR HANDLER

	BIT	(KEEP,1)	;DO NOT FLUSH TYPE AHEAD
	BIT	(QUIET,2)	;DO NOT PRINT MESSAGES
	BIT	(NUMBS,4)	;DO PRINT THE "CALLED FROM .." STUFF
	BIT	(LOGGIN,10)	;SEND MESSAGES TO LOG FILE
	BIT	(CONT,20)	;CONTINUABLE ERROR
	BIT	(AUTO,40)	;AUTOMATIC CONTINUATION MODE
	BIT	(LOGOPN,100)	;LOG FILE IS CURRENTLY OPEN
	BIT	(ERRNOW,200)	;WE ARE CURRENTLY IN THE MIDDLE OF AN ERR. UUO
	BIT	(MINUS,400)	;WE JUST SAW A MINUS!
	BIT	(MADEPT,1000)	;WE HAVE ALREADY MADE A BYTE POINTER FOR FAKETTY
	BIT	(BUFOPN,2000)	;HE HAVE A BUFFER FOR DUMP MODE LOGGING

>

DEFTBS		;DEFINE THE TBITS

?FNYNAM __ RECURS 		;EXTERNAL+OWN+FNYNAM MEANS EXT REQ IS FOR
				; FOO$ INSTEAD OF FOO (CF SIN)



; VARIOUS DEFINITIONS OF USER UUO'S.
FLOAT_2B8	OPDEF	FLOAT	[2B8]
STANFO <
PDPFIX_<KAFIX>	OPDEF	PDPFIX	[KAFIX]
>;STANFO
;;25-OCT-79 SDD Changed name from FIX to FIXUUO [name overlap]
DEFINE FIX <printx FIX opcode unchanged here!! (error coming)
	### cause error ###
	>;to catch bad use of FIX (ie ambiguous)
FIXUUO_3B8	OPDEF	FIXUUO	[3B8]

DMOVE_120B8	OPDEF	DMOVE	[120B8]
DMOVEM_124B8	OPDEF	DMOVEM	[124B8]
DMOVN_121B8	OPDEF	DMOVN	[121B8]
DMOVNM_125B8	OPDEF	DMOVNM	[125B8]

FIXR_126B8	OPDEF	FIXR	[126B8]
FLTR_127B8	OPDEF	FLTR	[127B8]
KIFIX_122B8	OPDEF	KIFIX	[122B8]
ADJSP_105B8	OPDEF	ADJSP	[105B8]

DFAD_110B8	OPDEF	DFAD	[110B8]
DFSB_111B8	OPDEF	DFSB	[111B8]
DFMP_112B8	OPDEF	DFMP	[112B8]
DFDV_113B8	OPDEF	DFDV	[113B8]

DADD_114B8	OPDEF	DADD	[114B8]
DSUB_115B8	OPDEF	DSUB	[115B8]
DMUL_116B8	OPDEF	DMUL	[116B8]
DDIV_117B8	OPDEF	DDIV	[117B8]

IOERR._4B8	OPDEF	IOERR.	[4B8]
ERR._5B8	OPDEF	ERR.	[5B8]
SIXPNT_6B8	OPDEF	SIXPNT	[6B8]
ARERR_7B8	OPDEF	ARERR	[7B8]
;;%BI% --! RECORDS
RECUUO _ 10B8	OPDEF	RECUUO	[10B8]
DECPNT_11B8	OPDEF	DECPNT	[11B8]
OCTPNT_12B8	OPDEF	OCTPNT	[12B8]
;;%CJ% JFR 7-20-75
ERRSPL_13B8	OPDEF	ERRSPL	[13B8]
SNGL_14B8	OPDEF	SNGL	[14B8]
TENX <
PUUO_15B8	OPDEF	PUUO	[15B8]
		OPDEF	TTCALL	[PUUO]
>;TENX
NOTENX <
PUUO_<TTYUUO>	OPDEF	PUUO	[TTYUUO]
		OPDEF	TTCALL	[TTYUUO]
>;NOTENX

JFOV_<JFCL 1,0>	OPDEF	JFOV	[JFCL 1,0]

;;3! JFR 9-17-75 CHEAP WAY TO GET SOME MICRO-EFFICIENCY
		OPDEF	TRZ	[ANDCMI]
		OPDEF	TRC	[XORI]
		OPDEF	TRO	[IORI]

STANFO <
DPYOUT_703B8	OPDEF	DPYOUT	[703B8]
DPYCLR_701B8	OPDEF	DPYCLR	[701B8]
UINBF_704B8	OPDEF 	UINBF	[704B8]

?SEGSIZUUO 	_ 400022	;GET SIZE OF SECOND SEGMENT.
?CORE2UUO	_ 400015	;GET SOME MORE SECOND SEGMENT.
?GLBAR		__ 1000		;CURRENT LENGTH OF GLOBAL MODEL AREA.
>;STANFO



SUBTTL	SAIL/GOGOL USER TABLE DESCRIPTION


DSCR USER DATA AREA TEMPLATE  
DES These values serve as indices for the run-time routines
  into the user's data table. The table is necessary to allow
  the routines to be re-entrant.  The table is allocated
  in the SAILOR sequence at startup time; many of its values
  (data area bounds, etc.) are placed in it at that time.
 One can force re-initialization of this and all other dynamic
  areas by setting GOGTAB to 0 before next CORGET.
SEE XX descriptions for all these goodies directly below


DEFINE XX (SYMBOL,SIZE,BACKUP) <
	?SYMBOL__LOCAT
IFN HEDSYM,<
	ENTRY	SYMBOL			;FOR HEAD.REL SYMBOL FILE
>;IFN HEDSYM
	LOCAT__LOCAT+1
	IFDIF<SIZE><>< LOCAT__LOCAT+SIZE-1>
	IFDIF<BACKUP><>< LOCAT__LOCAT-BACKUP>
>

LOCAT__0		;MAKES SYMBOLS ABSOLUTE

; THESE VARIABLES WILL NOT BE RE-INITIALIZED BY THE INIT ROUTINE


; LINK TO STRING BLOCKS FOR STRING GARBAGE COLLECTOR

 XX CLER,,1

 XX UUO1	;TRADITIONAL LOC FOR GOGOL RETRN ADRS FOR ERROR MSGS.

;LOADER LINK CHAINS
 XX STRLNK
 XX SPLNK	;LINK END FOR SPACE ALLOCATION.
 XX SETLNK	;LINK END FOR SETS.
 XX SGROUT	;LINK UP STRING DSCRPTR GENERATOR ROUTINES HERE
 XX KNTLNK	;PROFILE COUNTER LINK END

;IMPORTANT STRING SPACE ENTRIES
 XX STWCRL	;HEAD of "Width Control Records" list
 XX STWCRA	;active "Width Control Record" 0 if none selected, 
		;- if "deselected", + if needs "deselect" storage
;STHAND now in WCR[$STHAND]
;XX STHAND	;Handle for current string space (was ST)
 XX STLIST	;HEAD OF LIST OF STRING SPACES
 XX TOPBYTE	;NEXT FREE BYTE
 XX REMCHR	;-REMAINING FREE CHARS
 XX SGLIGN	;ON IF MUST BE ALIGNED TO FW BDRY (COMPILER ONLY).

; I/O CHANNEL POINTER TABLE
; EACH POINTS TO A "CHANNEL DATA BLOCK" FULL OF GOODIES
 XX CHANS,20

; I/O BREAK TABLES (FOR INPUT SCANNING ROUTINES)
 XX BKTPRV		;0 for UNPRIVILEGED, non-0 for PRIVILEGED. 
 XX BKTPTR,4,,		;POINTERS TO CORGET BLOCKS OF 18 BREAKTABLES EACH
	DSPTBL__0		;BREAK CHAR DISPOSITION TABLE
	LINTBL__=19+DSPTBL	;LINE NUMBER DISPOSITION TABLE 
	BRKTBL__=19+LINTBL	;BREAK CHAR TABLE
	BKJFFO__=128+BRKTBL	;RESERVATION WORD
	BRKCVT__1+BKJFFO	;UPPER CASE CONVERSION
	BRKOMT__1+BRKCVT	;OMIT SPEED UP
	BRKDUM__1+BRKOMT	;%DQ% used to hold "Z" bit flag
;;%BS% ^ MOVED INTO CORGET BLOCK FOR BREAK TABLES

;;%##% RHT THESE FOR ADDED RUNTIMES
XX  TTYCVT		; DITTO FOR TTY INPUT
XX  FSTATS		; FOR GETSTS

 XX PDL		;IOWD SIZE,BASE  FOR SYSTEM PDL
 XX SPDL	;XWD SIZE,BASE FOR STRING PDL

STANFO <
XX  ZAPBEG,,1	;BEGINNING OF SECOND SEGMENT COPY OF STUFF.
		;FOR GLOBAL MODEL ONLY.
>;STANFO
CMU <
XX  ZAPBEG,,1	;JUST LIKE SU-AI
>; CMU

;LEAP   THINGS.

STANFO <
 XX CURMES		;CURRENT MESSAGE.
>;STANFO
 XX MAXITM		;CURRENT TOP ITEM NUMBER.
 XX OLDITM		;LINKED LIST OF OLD ITEMS (DUMP HEAP).
 XX INFOTAB		;POINTER TO "GOOD POINTER" BLOCK OF CORE.
 XX DATAB		;POINTER TO DATUM AREA.
 XX HASTAB		;POINTER TO THE LEAP HASH TABLE.
 XX FP1			;FREE STORAGE -- 1 WORD.
 XX FP2			;FREE STORAGE -- 2 WORDS.
 XX HASMSK		;THE MASK FOR HASHING INTO OUR HASH SPACE.
;; \UR#3\ START OF NEW USER TABLE ENTRIES FOR BIG LEAP
URHASH <
XX RMASK1		;NEW MASK FOR MODIFIED LEAP ROUTINES
			;(RICK RASHID 3/15/76) WHICH IMPROVE
			;A XOR Y EQV Z AND X XOR B EQV Z SEARCHES
XX RMASK2
XX RMASK3
XX RMASK4		;END OF NEW MASKS (3/15/76 --
			;BEWARE THE IDES OF MARCH!)
>;URHASH
URLEAP <
XX BRACKL		;POINTER TO LIST OF BRACKETED TRIPLE BLOCKS
>;URLEAP
;; \UR#3\ END OF NEW USER TABLE ENTRIES FOR BIG LEAP
 XX HASHP		;FOR PNAMES. XWD NEXT FREE ARRAY ENTRY,ARRAY BASE.
 XX MKBP		;MAKE BREAK-POINT
 XX ERBP		;ERASE BREAK-POINT
 XX PUBP		;PUT BREAK-POINT (NOT IMPLEMENTED)
 XX REBP		;REMOVE BREAK-POINT.(NOT IMPLEMENTED)
 XX ITMTOP		;MAXIMUM PERMISSIBLE ITEM NUMBER.
 XX LEABOT		; PTR TO SEARCH CONTROL BLOCK FOR DERIVED SETS ERASE. 
 XX FRLOC		; PTR TO CURRENT ACTIVE FOREACH CONTROL BLOCK POINTER
 XX SCBCHN		; PTR TO CHAIN OF ABANDONED SCB'S
 XX FREITM	;NUMBER OF FREE ITEMS REMAINING

; MISC. ARRAY THINGS.
 XX ARYDIR	;FOR TELLING FOUR ARRAY ROUTINES WHICH END IS UP.
 XX ARYLS	;A LINKED LIST (LUCKILY) OF STRING ARRAYS IN LEAP, AND SO FORTH.
		;THIS IS SO STRING GARB COLLECTOR CAN FIND THEM ALL.

; BLOCK CONTROL TABLE INFORMATION
;THIS IS FOR SAIL'S CORE MANAGEMENT ROUTINES (CORGET,CORREL,CORINC...)

XX BLKTAB,3,3	;BASE OF BLOCK CONTROL TABLE
   XX LOWC	;LOW LIMIT OF ALLOCATABLE "BLOCK" CORE
   XX TOP	;UPPER LIMIT OF SAME
   XX FRELST	;POINTER TO BLOCK FREE STORAGE LIST

 XX XPAND	;PERMISSION TO EXPAND IN CORREL IF 0
 XX ATTOP	;REQUEST TO ALLOCATE OFF TOP OF CORE IF NON-0
 XX NOSHRK	;IF ON, CORREL NOT GIVEN PERMISSION TO SHRINK CORE
STANFO <
 XX USCOR2	;IF ON, CORGET WILL USE CORE2 ROUTINES.
>;STANFO

 XX BUFACS,10,,	;FOR BUFFER ALLOCATOR
STANFO <
XX ZAPEND,,1	;END OF SECOND SEGMENT AREA.
>;STANFO
CMU <
XX USCOR2		;THE COPYCATS
XX ZAPEND,,1		;ditto ZAPBEG
>;CMU

; INTERNAL VARIABLES FOR RE-ENTRANT ROUTINES

;;%  % DCS 12-3-73 New entries, delete some old ones (strngc) 
 XX STBUCK,1,1	;USED IN STRING GC TO KEEP TRACK OF BLOCKS
   XX OFFSET		;Distance to move a string space, see STRNGC
 XX STINCR		;String space increment size, see STRNGC
 XX STREQD		;String space threshold size, see STRNGC

 XX SGCCNT		;NUMBER OF TIMES STRNGC HAS BEEN CALLED
 XX SGCTIME		;Time of last GC if non-zero, else not enabled
 XX SGCTOTAL		;Total GC time while enabled (set SGCTIME -1 to enable)
 XX SGCNUM		;Number of strings collected last GC
 XX SGCWASTE		;Number of wasted words after last GC

 XX SRELOC
 XX CODAC		;SAVE AC 1 OVER CALLS ON "CODE" RUNTIME ROUTINE
 XX WDTH		;GLOBAL WIDTH FOR STRING CONVERSION ROUTNES
 XX DIGS		; "" FOR # OF DECIMAL DIGITS

; I/O INTERNAL VARIABLES

 XX CDBLOC	;IF CHNL IS A CH #, @CDBLOC(USER) GETS ITS CDB ADDR

 XX FNAME	;ENTER-LOOKUP TABLE
 XX EXT
 XX WD3
 XX PRPN
 XX LONGWD	;LONG FORM LOOKUPS AND ENTERS POKE THIS
 XX LONG2	; AND THIS -- FILEINFO ROUTINE GIVES TO USER

 XX PROJ		;USED BY FILNAM ROUTINE

TYMSHR<
XX FUSER
XX FUSER1	;TYMSHARE USER NAMES
>;TYMSHR
; AC SAVE AREAS

 XX RACS,13,,	;RE-ENTRANT ROUTINES SAVE HERE
 XX SGACS,14,,	;AVAILABLE ANY TIME IF YOU ARE NOT
 		; LIKELY TO CALL STRNGC
 XX STACS,14,,	;YET ANOTHER AC SAVE AREA
 XX PGNNFL

;SOME STUFF FOR MULTIPLE PROCESSES

?NPRIS__20	;NUMBER OF PRIORITIES
 XX PRILIS,NPRIS,, 	;PRIORITY LIST HEADERS
 XX GGDAD		;THE BASE FOR THE MAIN PROCESS (IF HAVE ONE)
 XX TIMER		;COUNTED DOWN FOR CLOCK INTERRUPTS
 XX SCHDRQ		;SET non-0 FOR A SCHEDULER REQUEST
			;(USED BY EVENTS)
 XX STKURT		;PLACE FOR STACKUNWINDER RETN ADRS
 XX INTQWP		;INTERRUPT NOTICE BUFFER WRITE PTR
 XX INTQRP		;READ PTR
 XX INTQWT		;TOP OF BUFFER 
 XX INTQWB		;BOTTOM OF BUFFER
 XX INTPRC		;INTERRUPT PROCESS BASE
 XX DISPAT		;DISPATCH TABLE FOR INTERRUPT LEVEL MODULE
 XX DFRINF		; AOBJN PTR TABLE FOR DEFERRED INTERRUPTS
NOTENX<
 XX IPDP		;INTERRUPT PDP
>;NOTENX
TENX<
 XX IPDP1
 XX IPDP2
 XX IPDP3
 XX ISPDP1
 XX ISPDP2
 XX ISPDP3
 XX TIMFRK		;TABLE OF FORK HANDLES FOR INTERRUPT SYSTEM, PROCESSES
>;TENX
 XX IJBCNI		;JOBCNI FROM A DEFERRED INTERRUPT
 XX IJBTPC		;JOBTPC FROM DEFERRED INTERRUPT
 XX IRUNNR		;RUNNER AT TIME OF DEFERRED INTERRUPT
NOTENX<
 XX ISPDP		;STRING PDP FOR INTERRUPT LEVEL
>;NOTENX
;;%##%  ADDING THESE
 XX $FSLIS		;LIST OF FREE STORAGE ALLOCATORS
 XX PRNINF		;$PRINT DEFAULTS
;;%##% BY JFR 11-17-74 COMMUNICATION BETWEEN BAIL AND ERROR HANDLER
 XX BAILOC		;IF NONZERO, ADDRESS OF BAIL INTERCEPT ROUTINE
 XX JFRCEL		; USED TO BE XX <NOTHING>
;;%CC% FOR STRNGC OF RECORD STRINGS
 XX RSGCLK		;THE TWO WORD BLOCK REQUIRED BY SGINS
 XX RSGCL2		; AND A SECOND WORD
 XX STBLST		;HEAD OF CHAIN OF STRING DESCR ARRAYS FOR RECORDS
;;%CC% ^
;;%DA%			
 XX RGCOFF		;SET THIS TO TURN OFF AUTO GC
 XX TGRADJ		;PUT PUSHJ ADR HERE TO ADJUST OWN TRIGGER LEVELS
 XX RGCRHO		;-1.0+1/"%FILL" LEVEL DESIRED FOR RECORD SPACES
;;%BR% -- RHT USED TO BE 2 %DA MADE IT 1 (FROM 4)
 XX SPARUT,1,,		;SPARE USER TABLE ENTRIES
;;%DA% ^^
 XX PRTINF		;PRINT OUTPUT INFORMATION  XWD BITS,CHAN
 XX $$PROU		;PRINT OUTPUT TRAP FOR ALL STRINGS
 XX $$FINT		;USER FORMATTING FUNCTION FOR INTEGERS
 XX $$FREL		; "         "       "      "  REALS
 XX $$FITM		; "         "       "      "  ITEMS
 XX $$FSET		; "         "	    "	   "  SETS
 XX $$FLST		; "	    "	    "	   "  LISTS
 XX $$FSTR		; "	    "       "      "  STRINGS
 XX $$FREC		; "         "       "      "  RECORDS
;;%DU%
 XX $$FLRL		;LONG REAL

;;=I09=	ADD PATH BLOCK FOR USE BY I/O ROUTINES WITH SFD'S
SFDS<
 XX PATHBL,4+SFDLVL,,		;PATH BLOCK
> ;SFDS

;;%DY% ! GJA/JFR 1-13-77
 XX EXPCHR	;"@" OR "E" FOR REAL NUMBER EXPONENT CHARACTER
;;%DZ% 2! GJA/JFR 1-13-77
 XX SEGBOT	;ADDR WHICH SAIL FREE STORAGE MUST NOT EXCEED
		; (DEFAULT TO 400000 = LOWEST ADDR OF USER PURE CODE)

;;SDD 13-DEC-78 add hooks for 1022 interface (core and channel code)
 XX CORINS	; CORE uuo hook (non-zero means this instead of core)
 XX BKGETC	; if non-zero, execute on entry to GETCHAN
 XX BKOPEN	; if non-zero, execute on entry to OPEN
 XX BKRELS	; if non-zero, execute on entry to RELEASE
;;^^ SDD 13-DEC-78 ^^

 XX ENDREN	; END OF USER DATA TABLE

SUBTTL	Global AC Definitions, Indices, Bits

AC2DATA (GLOBAL AC ASSIGNMENTS)
?P	_17
?SP	_16
?USER	_15
?TEMP	_14
?LPSA	_13
?RF	__12			;THE ALMIGHTY F REGISTER
?TAC1	__TEMP
?TAC2	__LPSA

BITDATA (BITS FOR %ALLOC SPACE REQUEST BLOCK ENTRIES)
?STDSPC __400000	;"INDIRECT" SPECIFICATION OF STANDARD AREA
?WNTADR __200000	;ADDRESS OF AREA TO BE STORED AS SPECIFIED
?WNTEND __100000	;ADDRESS OF NEXT AREA TO BE STORED AS SPECIFIED
?WNTPDP __ 40000	;PDP TO AREA TO BE STORED " "
?WNTPDL __ WNTPDP	;WNTPDP, WNTPDL -- WHAT'S THE DIFFERENCE?
?USRTB  __ 20000	;RESULT ADDRESSES ARE IN THE USER TABLE
?MINSZ  __ 10000	;THIS SIZE TO BE USED ONLY IF NO OTHERS GIVEN

BITDATA (INDICES OF STANDARDLY ALLOCATED AREAS (SEE %ALLOC))
?SYSPD	__ 1		;SYSTEM!PDL
?SYSSPD	__ 2		;STRING!PDL
?STRSP	__ 3		;STRING!SPACE

BITDATA (INDICES INTO THE FIXED PORTION OF EACH %ALLOC SPACE REQ. BLOCK)
?$ITNO	__1		;MAX ITEM NUMBER DECLARED THIS COMPILATION
?$NWITM __2		;XWD REQUIRED BUCKETS,REQUIRE  NEW!ITEMS 
?$GITNO	__3		;MAX (MIN?) GLOBAL ITEM NUMBER DECLARED
?$MSLNK	__4		;POINTER TO MESSAGE PROCEDURE LIST PUT HERE
?$PNMNO	__5		;REQUIRE n PNAMES PUTS n HERE
?$VRNO	__6		;VERSION NUMBER
?$SGNM	__7		;REQUIRED GLOBAL SEGMENT NAME (USUALLY EMPTY)
?$SGD	__10		;REQUIRED GLOBAL SEGMENT FILE DEVICE
?$SGF	__11		;" FILE NAME
?$SGPP	__12		;" PPN
?$TINIT __13		; POINTER TO INITIAL ITEM TYPES
?$PINIT __14		; POINTER TO INITIAL PRINTNAMES
?$CMVER __ 15		;com version
?$OBPDA __ 16		; pointer to outer block pda
?$SPREQ __ 20		; leaves a spare
		; *** SEE ALSO SPCSIZ (TOTAL) IF CHANGE THIS ***
ENDDATA


BITDATA (LINK NAMES)
?%STLNK __ 1
?%SPLNK __ 2
?%SETLK __ 3
?%SGROT __ 4
?%KTLNK __ 5
?%PDLNK __ 6
?%INLNK __ 7
?%RBLNK __ 10
BAIL<
?%BALNK __ 11
>;BAIL
;;%CB% ! NEED A NEW LINK TYPE
?%RCLNK __ 12		;RECORD CLASS LINK

BITDATA (PROCEDURE DESCRIPTOR INDICES)

	DEFINE PDX(I),<
		?I __ PD.XXX
		PD.XXX__PD.XXX+1
>
PD.XXX	__ 0
	PDX	PD.	;0
	PDX	PD.ID1	;1
	PDX	PD.ID2	;2
	PDX	PD.PDB	;3
	PDX	PD.NPW	;4
	PDX	PD.DSW	;5
	PDX	PD.LLW	;6
	PDX	PD.DLW	;7
	PDX	PD.PDA	;10
	PDX	PD.PPD	;11
	PDX	PD.PCW	;12
	PDX	PD.BDI	;13

?PD.XXX__PD.XXX

BITDATA (TYPE CODES WITHIN RH OF INFOTAB ENTRY)
	NOTYPE __ 1	;NO TYPE AT ALL
        BRKITM __ 2	;BRACKETED TRIPLE
	STTYPE __ 3	;STRING ITEM
	FLTYPE __ 4	;REAL ITEM
	INTYPE __ 5	;INTEGER ITEM
	LSTYPE __ 7	;LIST ITEM (TYPE SHOULD ALWAYS BE 1 MORE THN SETYPE
	SETYPE __ 6	;SET ITEM
	PITTYP __ 10	;PROCEDURE ITEM
	PRCTYP __ 11	;PROCESS ITEM
	EVTTYP __ 12	;EVENT TYPE ITEM
	CTXTYP __ 13	;CONTEXT ITEM
	RFITYP __ 14	;REFERENCE ITEM
	RECTYP __ 15	;RECORD
;;%BR% -- ADD A FEW & LEAVE ROOM TO GROW
	LBLTYP __ 16	;LABEL
	RCLTYP __ 17	;RECORD CLASS
;;#%%# 2! BY JFR 2-2-75 CLAIM ONE FOR BAIL
	ITVTYP __ 20	;ITEMVAR	***** UNUSED 12-9-76 *****
;;%DU%
	LFLTYP __ 21	;LONG REAL
	LINTYP __ 22	;LONG INTEGER
	MXSTYP __ LINTYP; LAST SIMPLE TYPE
	ARRTYP __ 24	;ARRAYS ARE THIS PLUS SIMPLE TYPE CODE
			; used to be 15
;;%BR% ^
	INVTYP __ MXSTYP+ARRTYP+1; NON-VALID TYPE CODE

BITDATA (RECORD CLASS TYPE BITS)
	NODELC __ 1	;DO NOT DELETE RECORDS OF THIS CLASS (VIA GC)
	CMPLDC __ 2	;THIS RECORD CLASS IS COMPILED-IN
	HASRPS __ 4	;HAS RPTR / RPTR ARRAY
	HASSTR __ 10	;HAS STRING / STRING ARRAY SUBFIELDS
;;%DU%
	HASDBL __ 20	;HAS DOUBLE (LONG REAL) FIELDS

BITDATA( PROC DESC STUFF)
?BLKCOD__17				;BLOCK BOUNDARY CODE
?EOPCOD__0				;END OF PROC LVI CODE
?AACOD__1					;ARITH ARRAY
?SACOD__2					;STRING ARRAY
?SETCOD__3				;SET
?LACOD__4					;LIST OR SET ARRAY
?FRCCOD__5				;FOREACH STATEMENT
?KLCOD__6				;KILL LIST
?CTXCOD __ 7				;CONTEXT
?CLNCOD __ 10				;CLEANUP PROC
?RPCOD __ 11				;RECORD PTR
?RPACOD __ 12				;RECORD PTR ARRAY
ENDDATA

BITDATA (USE OF THE RESERVED ITEMS)
; ANY IS REPRESENTED BY 0
	ITMANY __ 0	;ITEM FOR ANY
	MAINPI __ 1	;ITEM NUMBER OF THE MAIN PROCESS ITEM
	UNBND  __ 2	;UNBOUND (?ITEMVARS ETC)
	EVTYPI __ 3	;THE ITEM EVENT!TYPE
	NIC    __ UNBND	;ITEM GET BACK FROM EMPTY NOTICE QUEUE
;;# # MAKE NIC & UNBOUND THE SAME ITEM -- RHT
;;     I.E. NULL INTERROGATIONS RETURN UNBOUND NOW

	?MAXLOC __ =10	;MAXIMUM NUMBER OF LOCAL ITEMVARS IN FOREACH
	?QBIND __ 200	;A ? ITMVR (NOT A MP PARM)
	?FBIND __ 100	;A BIND ITMVR(HERE BECAUSE OF STATS)

BITDATA (THE NAMED BITS FOR REF ITEMS)
;;%BH% RHT ADD TEMP BIT
	?TMPB __ 400000 ; SIGN BIT MEANS A TEMP REF ITEM
	?REFB __ 200000	;USUALLY SET
	?QUESB __ 100000;FOR ? ITEMVARS
	?BINDB __ 40000	;FOR BIND ITEMVAR
	?PROCB __ 20000	;NOT NOW REALLY USED
	?ITEMB __ 10000	; AN ITEM (ITEMVAR)
	?ARY2B __ 4000	;FOR * ARRAY ITEMVAR ARRAY REFERENCES
	?MSK6BT __ 3740 ; BITS FOR SIX BIT TYPE
	?MSKUNT __ 3700	;BIT MASK FOR UNTYPED 
ENDDATA

;;%AM% MANY USER PHASES 
 SYSPHS__2			;TWO SYSTEM PHASES
 USRPHS__3			;THREE USER PHASES (FOR NOW)
				; (0, 1, 2) -- 1 IS DEFAULT

IFN HEDSYM, <		;MAKE AN HONEST ASSEMBLY OUT OF IT
	TITLE	HEAD
	END
>;IFN HEDSYM

 ;&5j7