COMMENT ;@@SUBROUTINE DECUNS
@@PURPOSE TO DECREMENT ATBUMC,MXW, AND REMOVE SPT ENTRY FOR AN
UNSHARED DP SO THAT IT CAN BE MOVED TO ANOTHER FILE.
@@ENTRY P3,P4 CONTAIN LMAP SLOT DATA, ACTIVE OR INACTIVE.
T2/ DP
P2/ ATB OF OLD FILE (OR DUMMY ATB ADDRESS IF PRIVATE PAGE)
@@ACCUM USES T1-T4.
@@EXIT P3,P4 STILL CONTAINLMAP SLOT DATA - STATUS SET TO UNSHARED IF
ENTERED AS SHARED. LMYATB NO LONGER VALID.
SKIP IF PAGE WAS NOT BEING SHARED BY ANYONE. NON-SKIP IF PAGE WAS BEING
SHARED.
@@FUNCTION IF SLOT IS UNSHARED, SEARCH SPT FOR DP. IF DP IS IN SPT OR SLOT
IS SHARED, AND SPT SHARE COUNT IS NOT 1, GIVE NON-SKIP RETURN (MUST BE
GREATER THAN 1). ELSE DELETE SPT ENTRY (CALL REMSPT).
IF DP IS NOT IN SPT, DECREMENT ATBUMC.
DECREMENT ATBMXW IF MAX WRITE IS ON FOR SLOT.
(NOTE %=CB, !=SAT)
@@;
EXTERNAL GETCBR,GIVCB1,GIVCBR,SRCSPT,SPTUSC,ATBSTS,ATPMXU,ATMMWC,ATBMWC
EXTERNAL LMPMXW,LMPSHR,REMSPT,GETSPT


DECUNS:	PUSHJ	P,GETCBR	;! GET CB WHILE MESSING WITH ATB AND SPT
	JUMPGE	P3,DECUN1	;%! IF SHARED, DON'T HAVE TO CHECK FOR SPT
				;%! EVEN IF ITS ACTIVE UNSHARED CAN'T GUARANTEE
				;%!  THAT IT DOESN'T HAVE AN SPT ENTRY,
				;%!  ACTLMA DOESN'T CHECK - ONLY PAGE FAULT.
	PUSHJ	P,GETSPT	;%! GET SPT ENTRY ADDRESS IN T1 FOR SHARED SLOT.
	JRST	DECUN2		;%! AND GO SEE IF ANYONE ELSE IS REALLY USING IT.
DECUN1:	MOVE	T1,P2		;%! GET ATB ADDRESS IN T1 FOR SRCSPT
	PUSHJ	P,SRCSPT	;%! SEE IF IT HAS AN SPT ENTRY
	  JRST	DECUN3		;%! NO SPT ENTRY, JUST DECREMENT COUNTS
DECUN2:	MOVE	T3,SPTUSC(T1)	;%! GET USE COUNT
	TRNE	T3,SPMUSC-1	;%! EQUAL TO 1? (CAN'T BE ZERO)
	PJRST	GIVCBR		;%! NO, JUST GIVE BACK CB AND GIVE NON SKIP RETURN.
	PUSHJ	P,REMSPT	;%! YES, GET RID OF ENTRY (MAYBE WHOLE SPT TABLE)
	TLNE	P3,LMPMXW	;%! MAX WRITABLE ON FOR THIS SLOT?
	PUSHJ	P,DECMXW	;%! YES, DECREMENT MAX WRITE COUNT
	TLZ	P3,LMPSHR	;%! SLOT NO LONGER SHARED (IF WAS AND WAS INACTIVE,
				;%!  LMYSPT IS NOW GARBAGE.
	JRST	GIVCB1		;%! GIVE SKIP RETURN.

DECUN3:	TLNE	P3,LMPMXW	;%! MAX WRITE ON?
	PUSHJ	P,DECMXW	;%! YES, DECREMENT MAX WRITE COUNT
	PUSHJ	P,DECUMC	;%! WASN'T IN SPT, DECREMENT ATBUMC, DRBCNT
				;%! ETC.
	PJRST	GIVCB1		;%! AND RETURN.

DECMXW:	SOS	T3,ATBMWC(P2)	;%! YES, DECREMENT IT
	TRC	T3,ATMMWC	;%! HAS IT OVERFLOWED?
	TRCN	T3,ATMMWC	;%!  (ALL BITS GO TO 1)
	STOPCD	(SLO)		;%! YES, CRASH
	MOVEI	T4,ATPMXU	;%! GET READY TO CLEAR MAX WRITE UP BIT
	TRNN	T3,ATMMWC	;%! COUNT STILL NON-ZERO?
	ANDCAM	T4,ATBSTS(P2)	;%! NOT ANYMORE, CLEAR THE BIT.
	POPJ	P,		;%! RETURN.


SUBTTL KMOVPG

COMMENT #
@@SUBROUTINE KMOVPG
@@PURPOSE
KERNEL ROUTINE USED TO TAKE A PAGE WHICH IS MAPPED AND NOT CURRENTLY
PART OF A FILE AND CAUSE IT TO BE MAPPABLE FROM THE SPECIFIED POSITION
IN THE FILE OPEN ON THE CHANNEL. USEFUL FOR MOVING PAGES FROM ONE FILE
TO ANOTHER, OR FOR MOVING A PRIVATE PAGE INTO A FILE.
@@ENTRY
T1/ USER'S VP SPECIFICATION, T2/FILE PAGE LOCATION TO BEGIN INSERTING
SIGN BIT OF T1 ON IFF USER MODE CALLER.
J/ TARGET FRAME NUMBER, CONTEXT PAGES IN %UPX
F/ DDB
@@ACCUM
DESTROYS P1-P4, T1-T4, U, AND PG.
@@EXIT
SKIP RETURNS IF SUCCESSFUL.
NON-SKIP RETURN IF ERROR, WITH LH(T1) CONTAINING THE VP NUMBER ON WHICH
THE FAILURE OCCURRED, AND RH(T1) CONTAINS THE ERROR CODE.
@@FUNCTION
FOR EACH VP
  IF VP IS NON-EXISTENT OR SUPER, GIVE ERROR RETURN.
  IF DP HAS OTHER USERS, CONVERT VP TO PRIVATE USING COPY-ON-WRITE AND
    GO UP TO TOP
  IF VP IS A PRIVATE VIRGIN PAGE, VIOLATE IT.
  IF VP IS PRIVATE (WAS NEVER IN A FILE) DO VALIDATE START.
    (HAVE TO MAKE SURE DISK DATA IS NOT LEFTOVER FROM LAST USER OF DP)
  GET ATOMIC FILE LOCK FOR WRITE (WILL BE CHANGING ALLOCATION OF FILE)
  IF FILE IS APPEND ONLY AND FIRST PAGE TO INSERT IS BELOW END OF FILE, GIVE
    ERROR RETURN.
  EXTEND FILE OUT TO LAST PAGE USER REQUESTED TO INSERT WITH HOLES.
FOR EACH VP
  IF PAGE IS PRIVATE, DO VALIDATE/WAIT.
  IF CALLER IS USER MODE AND DIRECTORY IS OVER QUOTA, GIVE ERROR RETURN.
  GET SAT COMPLETELY LOCKED FOR VP'S DP. IF F BIT ALREADY ON, GIVE ERROR RETURN.
  GET RIB CONTAINING SPECIFIED FP MAPPED WRITE LOCKED.
  IF SPECIFIED FP ALREADY EXISTS, GIVE ERROR RETURN.
  SET F BIT FOR DP.
  PUT RETRIEVAL POINTER IN RIB AND DDB.
  CHARGE DP AGAINST FILE'S DIRECTORY'S QUOTA.
  CALL DECUNS TO DISCONNECT VP FROM ITS OLD ATB IF ITS UNSHARED.
  INCREMENT UMC, MXW FOR NEW ATB.
  IF SLOT IS ACTIVE, SET PGYATB TO NEW ATB, CLEAR PGYSPT
  IF SLOT IS INACTIVE, SET DP AND ATB IN THE SLOT.
@@#
EXTERNAL ATBSTS,ATBMWC,ATPMXU,ATMMWC,ATYBSZ,CNVATB,CPRCOW,DABBIT
EXTERNAL DECUMC,DEVATB,DEVRBN,DEVRET,DEYRPS
EXTERNAL GETATB,GETCPA,GETDPA,GETLMA,GETSAT,GETSPT
EXTERNAL INCUMC,IOBDRB
EXTERNAL LM3ATB,LM3CUR,LMMEXS,LMPACT,LMPMXW,LMPSHR,LMPSUP
EXTERNAL MAPCML,NOWRT,PGYATB,PGYSPT,RBREAL,SETACH
EXTERNAL REDLMA,REMSPT,SPMUSC,SPTUSC,STOLMA,SWEPRH,TSTVIR
EXTERNAL UPDAC0,VALID,VL.VPP,VL.WAT,VLIOE%,%UPT,UPTJOB

KMOVPG::PUSHJ	P,SETARR	;W/PGE, P2/COUNT, P1/BITS
	  POPJ	P,		;BAD ARG FROM USER, GIVE ERROR RETURN
	MOVE	M,T2		;GET FP NUMBER IN T2
	JUMPE	M,KMOVBF	;IF ARG EQ 0, ITS BAD, GIVE ERROR.
	CAMGE	M,[-1]		;-1 MEANS AT END OF FILE
	JRST	KMOVBF		;NO GOOD.
	PUSH	P,W		;SAVE ARGS FOR LOOP LATER
	PUSH	P,M
	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,F		;SAVE DDB ADDRESS
	PUSH	P,W
	PUSH	P,P2		;FIRST LOOP DEALS ONLY WITH VPS
KMOVP1:	PUSHJ	P,REDLMA	;GET LMAP SLOT
	TLNN	P3,LMMEXS	;DOES PAGE EXIST?
	JRST	KMOVEE		;NO, GO GIVE NON-EXIST ERROR.
	TLNE	P3,LMPSUP	;IF SUPER PAGE, GIVE ERROR RETURN.
	JRST	KMOVSE
	PUSHJ	P,GETATB	;GET ATB ADDRESS
	SKIPL	ATBSTS(T1)	;SKIP IF ITS PRIVATE
	JRST	KMOVP2		;NOT PRIVATE, DONT'T HAVE TO VIOLATE IT
	PUSHJ	P,TSTVIR	;IS SLOT VIRGIN?
	  JRST	KMOVNV		;NO.
	PUSHJ	P,VPADR		;TAKE PAGE IN W AND MAKE ADDR OUT OF IT IN T1,
				; AND WET PC.UIO PROPERLY FOR A REFERENCE.
	UMOVE	T1,(T1)		;AND CAUSE VIRGIN PAGE TO BE VIOLATED.
				;NOTE CANNOT ASSUME PAGE NOT DIRTY WHEN WE COME BACK.
PRINTX STILL HAVE CONTEXT PAGE LOCK AND DOING UMOVE



KMOVNV:	HRRZ	T1,W		;GET PAGE
	HRLI	T1,VL.VPP+1	;SETUP ARG
	PUSHJ	P,VALID		;MAKE SURE PAGE NO LONGER DIRTY
	  JRST	KMOVVE		;VALIDATE ERROR.
KMOVP2:	AOS	W,-1(P)		;STEP TO NEXT VP NUMBER
	SOSLE	(P)		;DECREMENT COUNT, AND JUMP IF
	JRST	KMOVP1		;MORE TO GO
	POP	P,T1
	POP	P,T1		;GET USED JUNK OFF THE STACK.

;NOW ALL PRIVATE PAGES THAT WERE DIRTY HAVE BEEN STARTED OUT,
; NO SUPER PAGES FOUND IN RANGE, THEY ALL EXIST, NO VIRGIN PRIVATE PAGES
; ANYMORE.

	MOVE	F,(P)		;GET F BACK
	MOVE	M,-3(P)		;FIRST FP TO DO
	MOVE	W,-4(P)		;IN CASE OF ERROR RETURN.
	MOVEI	T3,KMOVPG	;STUPID CODE FOR DELXCH.
	PUSHJ	P,DELXCH	;RETURN T4 HPW, FILE LOCKED UNMODIFIED
	  JRST	KMOVXE		;ERROR CODE ALREADY IN T1.
	PUSHJ	P,SETACH	;ASSUME FILE'S ALLOCATION WILL CHANGE.
	ADD	M,-1(P)		;GET LAST FP + 1
	SUBI	M,1		;CONVERT TO LAST FP WANT TO CREATE.
	CAMLE	M,T4		;SKIP IF LAST PAGE WE WANT TO INSERT
				; TO FILE IS NOT BEYOND HPW
	JRST	KMOVPH		;IS BEYOND, MUST CREATE HOLES FOR NEW PAGES
	HLLZ	T1,DEVIAD(F)	;IS TOTALLY WITHIN FILE, CHECK FOR APPEND ONLY
	TLNE	T1,NOWRT	;SKIP IF NOT APPEND ONLY
	JRST	KMOVNA		;SORRY, CANT TOUCH BELOW HPW
	JRST	KMOVNH		;OK, LET IT THROUGH.

KMOVPH:	PUSHJ	P,LOKHPW	;GET FILE LOCKED PROPERLY.
	  JRST	KMOVBR		;BAD RIB, TAKE CARE OF IT
	JUMPL	T1,KMOVNH	;IF T1 IS NEGATIVE, MEANS FILE SIZE CHANGED
				; SUCH THAT REQUESTED FP NO LONGER ABOVE
				; HIGHEST EXISTING FILE PAGE.
	MOVE	T4,M		;REMEMBER HIGHEST PAGE TO BE INSETRED
	SKIPGE	-3(P)		;IF -1 FOR HPW+1 WAS SPECIFIED,
	JRST	[
		ADD	T4,-1(P) ;THEN M/HPW+1 AND NOT HIGHEST PAGE TO INSERT.
		SOJA	T4,.+2]	;AND DONT RESET M. T4 NOW HIGHEST PAGE TO INSERT.
	MOVE	M,-3(P)		;M WAS SPECIFIED EXPLICITLY, SO RESTORE FIRST
				; PAGE TO CREATE.
	HRRZ	T2,DEVATB(F)	;GET ATB ADDRESS IN T2
	LDB	T3,ATYBSZ
	ADDI	T3,3
	LSH	T3,-BLKSPP	;T3/HPW AGAIN.
	HLLZ	T1,DEVIAD(F)	;GET NOWRT BIT
	TLNE	T1,NOWRT	;IF FILE IS APPEND ONLY AND
	CAMLE	M,T3		;FIRST PAGE TO INSERT IS BELOW HPW,
	JRST	.+2		;(OK, INSERTING ABOVE CURRENT EOF)
	JRST	KMOVNA		;APPEND ONLY AND THIS IS NOT APPEND
	AOS	M,T3		;FIRST PAGE TO CREATE IS HPW+1
	SUB	T4,M		;NUMBER OF HOLES TO DO IS LAST FP TO INSERT
	ADDI	T4,1		;-(HPW+1)+1. (CREATE HOLES FROM HPW+1 TO LAST FP)
	SETO	T1,		;DON'T STOP ON CONTROL CCC (TOO BAD)
	PUSHJ	P,SWEPRH	;CREATE HOLES SO WE CAN INSERT DPS LATER.
	  JRST	[CAIE T1,FALAQA	;DISK FULL OR QUOTA EXCEEDED OR
		 CAIN T1,FALRBE	;RIB ERROR?
		 JRST KMOVXE	;YES, GO GIVE PROPER ERROR RETURN.
		 STOPCD(SLO)]	;NO, SHOULDN'T GET THIS.
	PUSHJ	P,RELRIB	;GET RID OF RIB IN CASE USETST HAS TO GET IT BELOW.



;NOW WE ARE GUARANTEED THAT THERE ARE RIB SLOTS FOR ALL PAGES WE WISH TO INSERT.

KMOVNH:	MOVE	W,-4(P)		;RESTORE ORIGINAL W AND
	MOVE	M,-3(P)		;M
KMOVP3:	PUSHJ	P,REDLMA	;GET LMAP SLOT
	PUSHJ	P,GETATB
	SKIPL	ATBSTS(T1)	;SKIP IF ITS PRIVATE
	JRST	KMOV2N		;NOT PRIVATE.
	PUSH	P,W
	PUSH	P,M
	HRRZ	T1,W
	HRLI	T1,VL.WAT+VL.VPP+1 ;WAIT, DO IT FOR PRIVATE PAGE, COUNT OF 1.
	PUSHJ	P,VALID		;DO IT
	  JRST	KMOVVE		;VALIDATE ERROR
	POP	P,M
	POP	P,W
	MOVE	F,(P)		;RESTORE F
KMOV2N:	TLNE	F,GETB		;IF GETB ON, DON'T CHECK FOR QUOTA
	JRST	KMOV3N
	PUSHJ	P,CHKQTA	;SEE IF CAN ALLOCATE IN C(F)'S DIRECTORY
	  JRST	KMOVOQ		;OVER QUOTA IN THIS DIRECTORY.
	PUSHJ	P,USETST	;GET DDB SETUP TO SLOT POINTED TO BY M
	  JRST	KMOVBR		;BAD RIB.
	MOVE	T2,@DEVRET(F)	;GET CONTENTS OF THAT SLOT
	TLNE	T2,RBREAL	;IS SLOT A HOLE?
	JRST	KMVNHO		;NO
	PUSHJ	P,REDLMA	;GET LMAP SLOT IN P3 AND P4 AGAIN, DELCRE RESCHEDULES

	PUSHJ	P,GETDPA	;GET DISK ADDRESS IN T2
	TLO	T2,RBREAL	;MAKE ACCEPTABLE TO GETSAT
	PUSH	P,T2		;SAVE RETRIEVAL POINTER FOR LATER.
	MOVEI	T1,MAPCML	;MAP COMPLETELY LOCKED - THE SAT PCB LOCK IS WHAT
				; KEEPS DP FROM CHANGING STATUS (KEEPS MAPPERS
				; FROM SNEAKING IN AND CHANGING STATUS TO SHARED, ETC)
	PUSHJ	P,GETSAT	;GET SAT, SETUP T1 AND T3
	  JRST	KMOVBS		;GIVE SAT ERROR RETURN.
	TDNE	T1,%SAT+400(T3)	;M BIT SHOULD BE ON (ZERO)
	STOPCD	(SLO)
	TDNN	T1,%SAT(T3)	;HAS USER SPECIFIED PAGE STILL PART OF A FILE?
	JRST	KMOVPF		;YES, GIVE HIM THE ERROR RETURN.
	PUSH	P,T1		;REMEMBER WHERE IN SAT TO DIDLE
	PUSH	P,T3		;BECAUSE WE CAN'T SET IT IN CASE PAGE IS SHARED.

;NOW WE KNOW PAGE IS NOT IN A FILE. MAKE SURE ITS NOT SHARED. IF IT IS, MUST
; GET RID OF SAT, TURN PAGE INTO PRIVATE PAGE WITH COPY-ON-WRITE, AND TRY AGAIN.
;SAT LOCK IS ENOUGH TO MAKE SURE SPT COUNT DOESN'T CHANGE, ONLY NEED CB; TO MESS WITH ENTIRE SPT STRUCTURE.

KMOV3N:	PUSHJ	P,REDLMA	;GET LMAP SLOT AGAIN
	MOVE	T2,(P)
	TLZ	T2,RBREAL	;GET RID OF IT SO SRCSPT WONT BARF.
	JUMPL	P3,KMOV3A	;IF SLOT IS SHARED, JUST GET SPT ADDRESS FROM SLOT.
	PUSHJ	P,GETATB	;UNSHARED, GET ATB ADDR FROM SLOT
	PUSHJ	P,SRCSPT	;GET SPT ENTRY POINTER IN T1
	  JRST	KMOV3C		;NOT SHARED, NO SPT ENTRY.
	JRST	KMOV3B		;AND CHECK TO SEE IF STILL SHARED.
KMOV3A:	PUSHJ	P,GETSPT	;GET SPT ENTRY ADDRESS IN T1
KMOV3B:	HRRZ	T3,SPTUSC(T1)	;GET USE COUNT IN T3
	CAILE	T3,1		;ITS REALLY UNSHARED IF COUNT IS 1.
	JRST	KMVMKP		;SHARED, GO MAKE IT PRIVATE.

KMOV3C:	POP	P,T3		;GET SAT BIT AND POS BACK
	POP	P,T1
	ANDCAM	T1,%SAT(T3)	;SET (MAKE 0) F BIT, ITS GOING TO BE IN A FILE NOW.

	POP	P,T2
	MOVSI	T1,PTRCHG
	IORM	T1,DEVIAD(F)	;MARK OUR DDB AS HAVING CHANGED
	MOVEM	T2,@DEVRET(F)	;SET IN DDB
	PUSHJ	P,ONESLT	;UPDATE OTHER DDBS THAT HAVE THIS FILE POSITION
				;FILE SIZE ALREADY SETUP CORRECTLY FROM SWEPRH.
	PUSHJ	P,RELRIB	;DON'T GIVE UP SAT TILL EVERYTHING IS FIXED.
	HRRZ	T2,DEVATB(F)	;GET ATB ADDRESS IN T2 FOR UPDAC0
	MOVEI	T1,1		;ALLOCATE 1 MORE PAGE TO THIS DIRECTORY
	MOVN	T3,T1		;UPDAC0 NEEDS THIS
	PUSHJ	P,UPDAC0	;ADJUST ATPALP, DRBALC, DRBMXA
	PUSHJ	P,GETLMA	;NOW GET LMAP SLOT FOR C(W)
	PUSHJ	P,GETATB	;GET ATB ADDRESS FOR OLD SLOT
	MOVE	P2,T1		;GET INTO P2 FOR DECUNS
	MOVE	T2,@DEVRET(F)	;GET POINTER BACK, UPDAC0 SMASHED IT
	TLZ	T2,RBREAL	;T2 HAD PTR, CLEAR RBREAL TO GET JUST DP
	PUSHJ	P,DECUNS	;DISCONNECT THAT DP FROM OLD ATB
	  STOPCD		;NOT SUPPOSED TO BE SHARED ANYMORE.
	HRRZ	T1,DEVATB(F)	;GET ATB FOR FILE
	PUSHJ	P,INCUMC	;INCREMENT ATBUMC, DRBCNT, ETC. FOR FILE
	HRRZ	T1,DEVATB(F)	;GET NEW ATB ADDRESS AGAIN.
	TLNN	P3,LMPMXW	;MAX WRITE ON?
	JRST	KMOVP4		;NO
	AOS	T4,ATBMWC(T1)
	TRNN	T4,ATMMWC	;MAKE SURE IT DIDN'T OVERFLOW
	STOPCD
	MOVEI	T4,ATPMXU	;SET BIT THAT COVERS ATBMWC NON-ZERO
	IORM	T4,ATBSTS(T1)
KMOVP4:	PUSHJ	P,CNVATB	;CONVERT ATB ADDR IN T1 TO ATB POINTER.
	TLNN	P3,LMPACT	;IS THIS AN ACTIVE SLOT?
	JRST	KMOVP5		;NO
	PUSHJ	P,GETCPA	;GET CP IN PG
	DPB	T1,PGYATB	;SET IT IN PGY TABLE
	SETZ	T1,		;MAKE SURE PGYSPT IS ZERO, THIS PAGE ISN'T SHARED
	DPB	T1,PGYSPT
	JRST	KMOVP6		;AND GO RELEASE SAT, LOOP
KMOVP5:	DPB	T1,LM3ATB	;SET ATB POINTER IN SLOT
KMOVP6:	PUSHJ	P,STOLMA	;STORE NEW SLOT BACK.
	PUSHJ	P,RELSAT	;NOW GIVE UP SAT SO OTHERS CAN MAP IT AGAIN.
				; (HAD TO WAIT UNTIL PGY STUFF, ETC, FIXED UP SO
				; IT IS SAFE TO MAP IT AGAIN)
				;KEEP ATOMIC FILE LOCK SO FILE SIZE DOESNT CHANGE

	AOS	M,-3(P)		;STEP TO NEXT M AND
	AOS	W,-4(P)		;W
	SOSLE	-1(P)		;DECREMENT REPEAT COUNT AND
	JRST	KMOVP3		;JUMP IF ANOTHER TO DO.
KMOVEX:	PUSHJ	P,UNLFIL	;UNLOCK FILE NOW.
	POP	P,F
	POP	P,P2
	POP	P,P1
	POP	P,M
	POP	P,W		;GET RID OF ALL JUNK ON STACK
	JRST	CPOPJ1		;AND GIVE SKIP RETURN.
PRINTX MAKE SURE ERROR RETURNS THAT HAVE TO UNLOCK CORRECT STUFF


;HERE IF DISCOVERED THAT PAGE WAS SHARED AFTER GETTING SAT. USE TRICK
; OF MAKING PAGE COPY-ON-WRITE AND WRITING INTO IT TO MAKE IT
; UNSHARED AGAIN, AND START AT TOP OF THE SECOND FOR EACH VP LOOP.
;VP NUMBERT IN W.

KMVMKP:	POP	P,T3		;GET SAT BIT AND POS BACK OFF
	POP	P,T1		;WE WONT USE THEM ANYMORE.
	POP	P,T2		;GET DP OFF STACK, THROW IT AWAY.
	PUSHJ	P,RELSAT
	PUSHJ	P,RELRIB	;GET RID OF EVERYTHING.
	PUSHJ	P,UNLFIL	;GET RID OF FILE LOCK (NOW WE HAVE TO GO THRU
				; STUFF ABOUT HPW, SINCE ALLOCATION/DEALLOCATION
				; CAN HAPPEN NOW.
	PUSHJ	P,GETLMA	;GET SLOT OFFICIALLY.
	LDB	P1,LM3CUR	;GET PROTECTION IT HAS NOW
	MOVEI	T2,CPRCOW	;SET CURRENT PROTECTION TO COPY ON WRITE
	DPB	T2,LM3CUR
	TLNE	P3,LMPACT	;IF ACTIVE,
	TRZ	P4,PGE.W	;RESET WRITE BIT SO IT WILL FAULT.
	PUSHJ	P,STOLMA	;SET IT BACK IN SLOT.
	PUSHJ	P,VPADR		;GET ADDR TO REF VP IN T1
	XCTBU	<SETMM (T1)>	;WRITE INTO THE PAGE, MAKING IT PRIVATE.
	PUSHJ	P,GETLMA	;GET SLOT AGAIN
	DPB	P1,LM3CUR	;RESTORE OLD PROTECTION
	TLNE	P3,LMPACT	;AND IF ACTIVE,
	TRZ	P4,PGE.W	;CLEAR WRITE BIT IN CASE OLD PROT WASN'T R/W
	PUSHJ	P,STOLMA	;SET SLOT BACK.
	JRST	KMOVP3		;NOW TO TOP OF FOR EACH VP LOOP TO DO CHECKS ON
				; FILE AGAIN, VALIDATE.

;LITTLE ROUTINE TO TAKE PAGE NUMBER IN W, CONVERT TO REFERENCE ADDRESS AND SET USER IOT
; BIT PROPERLY.

VPADR:	HRRZ	T1,W		;GET PAGE NUMBER
	CAIGE	T1,1000		;IF USER PAGE
	JRSTF	@[PC.UIO,,.+2]	;SET USER IOT AND SKIP
	SUBI	T1,CNVVPN	;ELSE CONVERT TO HARDWARE PAGE NUMBER
				; (USER IOT SET BECAUSE CALLER WAS EXEC MODE)
	LSH	T1,^D9		;TURN INTO ADDRESS.
	POPJ	P,		;AND RETURN.

;VARIOUS ERROR RETURNS, NEED TO GET STUFF OFF STACK AND UNLOCK.
; ERROR CODE ALWAYS IN RH(T1), VP IN W.

;HERE ON ERROR RETURN FROM VALIDATE.

KMOVVE:	MOVEI	T1,(T1)		;GET ERROR CODE
	CAIE	T1,VLIOE%	;IS IT I/O ERROR?
	STOPCD			;NO, SOMETHING ELSE WENT WRONG.
KMOVPE:	POP	P,T2
	POP	P,T2		;ALWAYS 2 EXTRA THINGS ON THE STACK.
KMOVXE:	PUSHJ	P,UNLFIL	;IN CASE WE HAVE FILE LOCK. (F BETTER BE SETUP)
	POP	P,F
	POP	P,P2
	POP	P,P1
	POP	P,M
	HRLI	T1,(W)		;GET FAILING VP IN LH T1
	POP	P,W
	POPJ	P,		;AND GIVE ERROR RETURN.

;NON-EXISTENT PAGE
KMOVSE:	SKIPA	T1,[FALNSE]	;TRYING TO STICK SUPERMAPPED PAGE INTO FILE.
				;(MAYBE SOMEDAY ALLOW THIS UNDER PROPER CONDITIONS)
KMOVEE:	MOVEI	T1,FALNEX
	JRST	KMOVPE		;POP 2 THINGS OFF STACK AND GIVE ERROR.
;BAD RIB
KMOVBR:	MOVEI	T1,FALRBE
	JRST	KMOVXE
KMOVOQ:	MOVEI	T1,FALAQA
	JRST	KMOVXE
KMVNHO:	PUSHJ	P,RELRIB	;GET RID OF RIB
	MOVEI	T1,FALNHL
	JRST	KMOVXE		;GET T1 AND T3 OFF STACK TOO.
KMOVBF:	MOVEI	T1,FALFPZ
	HRLI	T1,(W)
	POPJ	P,
KMOVPF:	POP	P,T2		;GET RID OF DP ON STACK
	PUSHJ	P,RELRIB
	PUSHJ	P,RELSAT	;GET RID OF RIB AND SAT
	MOVEI	T1,FALALF	;ALREADY IN A FILE
	JRST	KMOVXE
KMOVBS:	POP	P,T2
	PUSHJ	P,RELRIB
	MOVEI	T1,FALBDS
	JRST	KMOVXE

KMVELK:	PUSH	P,T1
	PUSHJ	P,RELRIB	;GET RID OF RIB AND SAT IF HAVE THEM
	PUSHJ	P,RELSAT
	POP	P,T1		;RESTORE ERROR CODE
	POP	P,T2		;GET T2 OFF STACK
	JRST	KMOVPE		;POP T1 AND T3 OFF STACK AND RETURN.

KMOVNA:	MOVEI	T1,FALNWT
	JRST	KMOVXE



COMMENT #
@@SUBROUTINE LOKHPW
@@PURPOSE
COMMON ROUTINE USED BY KFCRE AND KMOVPG. WHEN THESE KERNEL ROUTINES DISCOVER
 THAT A SLOT PAST HIGHEST PAGE WRITTEN (HPW) IS NEEDED, THEY ONLY HAVE THE
 ATOMIC FILE LOCK IN READ MODE. SINCE MIGHT BE CHANGING RIB STRUCTURE,
 HAVE TO GET FILE WRITE LOCKED, MAKING SURE SIZE DIDN'T CHANGE OR FILE
 DIDN'T GO BAD WHILE WAITING.
@@ENTRY
M/-1 TO INDICATE HPW+1 OR HIGHEST FP THAT WILL BE CREATED/INSERTED INTO FILE.
@@ACCUM T1-T3
@@EXIT NON-SKIP IF FILE GOT RIB ERROR WHILE WAITING FOR ATOMIC LOCK
SKIP RETURN WITH T1<0 IFF HIGHEST FP IS NOW BELOW HIGHEST PAGE THAT EXISTS
IN THE FILE. IF M/-1 ON ENTRY, CHANGE TO CURRENT HPW+1 OF FILE, ELSE
RETURN VALUE OF M UNCHANGED (HIGHEST FP TO BE INSERTED INTO FILE)
@@FUNCTION
SAVE OLD FILE SIZE (IN BLOCKS). RELEASE FILE READ LOCK, GET FILE WRITE LOCKED.
GIVE NON-SKIP IF RIB IS BAD NOW. ELSE IF M/-1, SET M TO BE THE HIGHEST PAGE
EXISTING IN THE FILE NOW + 1, T1/>=0, AND SKIP RETURN.
IF M/>=0, IF SIZE HASNT CHANGED JUST GIVE SKIP RETURN AND
FILE WRITE LOCKED. IF SIZE HAS CHANGED AND FP IN M IS NO LONGER ABOVE HIGHEST
EXISTING PAGE IN FILE, CHANGE LOCK BACK TO READ, SET T1/-1, AND SKIP RETURN.
IF FP IN M IS STILL ABOVE HIGHEST EXISTING PAGE, SKIP RETURN WITH
T1/NOT -1.
@@#
PRINTX CONVERT KCREAT CODE AT CREAT2 TO USE THIS ROUTINE.
LOKHPW:	HRRZ	T2,DEVATB(F)	;SAVE FILE SIZE
	LDB	T1,ATYBSZ	;FOR CHECK.
	PUSHJ	P,UNLFIL	;UNLOCK BEFORE LOCK MODIFY.
	MOVEM	S,DEVIOS(F)	;
	PUSHJ	P,LOKMOD	;GET LOCKED MODIFY.
	MOVE	S,DEVIOS(F)	;FILE DIED WHILE
	TLNE	S,IOBDRB	;WAITING?
	POPJ	P,		;YES, GIVE ERROR RETURN.
	LDB	T3,ATYBSZ	;GET CURRENT FILE SIZE.
	JUMPGE	M,LOKHP1	;JUMP UNLESS LAST+1.
	ADDI	T3,3		;CALC THE
	LSH	T3,-BLKSPP	;LAST PAGE
	ADDI	T3,1		;+1.
	MOVE	M,T3		;AND PUT INTO M.
	JRST	CPOPJ1		;GIVE SKIP RETURN
LOKHP1:	CAMN	T1,T3		;CHANGED WHILE WE WAITED?
	JRST	CPOPJ1		;NO, JUST GIVE SKIP, T1 NOT -1.
	ADDI	T3,3	;YES.
	LSH	T3,-BLKSPP	;
	CAMLE	M,T3		;REQUESTED FP NOW BELOW HIGHEST EXISTING PA	JRST	CPOPJ1		;NO, JUST GIVE SKIP WITH T1/NOT -1
	PUSHJ	P,LOKLES	;
	SETO	T1,		;MAKE T1 NEGATIVE AS SIGN FOR CALLER TO NOT EXTEND
	JRST	CPOPJ1		;FILE AND RETURN.

   /Ij»